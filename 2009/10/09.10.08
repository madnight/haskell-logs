00:00:01 <mmorrow> > flip runCont id (callCC (\k -> k 1))
00:00:02 <lambdabot>   1
00:00:35 <mmorrow> @let cont m = flip runCont id m
00:00:36 <lambdabot>  Defined.
00:00:49 <mmorrow> > cont (callCC (\k -> forever (k 42)))
00:00:50 <lambdabot>   42
00:01:19 <mmorrow> unfortunately without the ability to make a datatype, you can't get the "k" out of there
00:02:14 <mmorrow> , runCont id (do (x,lbl) <- labelCC 7; when (n < 1000) (jump lbl (x+3)); return x)
00:02:16 <lunabot>  luna: Occurs check: cannot construct the infinite type:
00:02:22 <mmorrow> , [$ty| jump |]
00:02:25 <lunabot>  forall b m a . ContM m => a -> Label m a -> m b
00:02:35 <mmorrow> , runCont id (do (x,lbl) <- labelCC 7; when (x < 1000) (jump lbl (x+3)); return x)
00:02:36 <lunabot>  luna: Occurs check: cannot construct the infinite type:
00:02:39 <mmorrow> grr
00:02:47 <mmorrow> , runCont id (do (x,lbl) <- labelCC 7; when (x < 1000) (jump (x+3) lbl); return x)
00:02:48 <lunabot>  1000
00:03:21 <mmorrow> (that's using monadLib's pre-packaged type that you can stick the conts you get from callCC in)
00:03:58 <mmorrow> each time you call "jump", that "labelCC" call returns again, but with the value you jumped with
00:10:45 <Tony[`]> can anyone suggest a low-medium level exercise with haskell that would force someone to use monad transformers? :)
00:10:50 <Tony[`]> something like
00:11:12 <Tony[`]> make a program to apply huffman coding or something
00:11:18 <Tony[`]> more than just simple 2 line exercises
00:11:48 <Saizan> mh, implement a parsing monad?
00:13:41 <Berengal> @unmtl StateT String [] a
00:13:41 <lambdabot> String -> [(a, String)]
00:13:51 <Berengal> Huh, whaddya know
00:14:51 <Saizan> we need a <spoiler> tag
00:20:45 <dmead> > callCC (\k -> k 1)
00:20:46 <lambdabot>   No instance for (GHC.Show.Show (m b))
00:20:46 <lambdabot>    arising from a use of `M6200883361...
00:20:52 <dmead> o0
00:47:43 <quicksilver> BMeph: it eliminates side-effects.... from the evaluation process.
01:45:09 <pozic> Why doesn't deriving MonadTrans simply generate instance MonadTrans (MT ..) where lift = MT . lift* ?
01:47:44 <quicksilver> not sure I understand that question.
01:48:02 <quicksilver> MonadTrans is in a library. Surely there isn't a special deriving for it?
01:48:21 <quicksilver> deriving is just for certain base typeclasses, plus the simple newtype trick.
01:52:06 <sinelaw> what's the usual alternative to hetergenous lists in Haskell?
01:52:36 <sinelaw> heterogeneous
01:54:02 <quicksilver> sinelaw: depends on the detail of the problem.
01:54:30 <quicksilver> for a finite degree of heterogeneity, a list of an algebraic type
01:54:47 <ivanm> there is a heterogenous list package on hackage...
01:54:53 <ivanm> if you absolutely _must_ have one
01:54:59 <quicksilver> for a list of Int or String or Double, use a list of data OneOfThem = I Int | S String | D Double
01:55:04 <quicksilver> ivanm: yes, but it's not to be used.
01:55:19 <ivanm> quicksilver: it's just there to make lisp lovers stfu? ;-)
01:55:43 <sinelaw> quicksilver, ok i have a DSL in which elements are composed, so that their type matches (something like a->b ~> b->c ) but the types are heterogeneous, and i want to create list of elements by some criterion
01:55:44 <quicksilver> it's there as a proof of concept of what is possible in GHC if you enable language extensions which break the language.
01:55:44 <maartenm> hello, it's been a while since I did anything in haskell
01:56:09 <maartenm> I forgot the [[a]] -> [a] function that does [[1,3],[1]] -> [1,3,1]
01:56:14 <Botje> concat
01:56:18 <maartenm> thanks
01:56:21 <Botje> @hoogle [[a]] -> [a]
01:56:21 <lambdabot> Prelude concat :: [[a]] -> [a]
01:56:21 <lambdabot> Data.List concat :: [[a]] -> [a]
01:56:21 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:56:24 <quicksilver> sinelaw: then you probably want to represent that criterion as an existential.
01:56:26 <maartenm> ok, like that
01:56:29 <maartenm> thank you
01:56:29 <Botje> next time, ask hoogle (or \bot) first ;)
01:56:36 <maartenm> didn't know hoogle could do that
01:56:46 <maartenm> well, I assumed, but thought I'd get 1000 results
01:56:55 <quicksilver> that's specifically what hoogle was designed for
01:57:00 <quicksilver> (finding functions from types)
01:57:06 <quicksilver> the other kinds of searches it can do were an afterthought :)
01:57:08 <ivanm> maartenm: lambdabot's hoogle lists the top 3
01:57:09 <Botje> it does a pretty good job most of the time
01:57:12 <sinelaw> quicksilver, what do you mean? i'm new at this
01:57:15 <ivanm> (or less...)
01:57:26 <ivanm> Botje: better job than @index, anyway ;-)
01:57:45 <ivanm> quicksilver: you mean function names?
01:57:45 <quicksilver> sinelaw: you haven't given enough information for me to give a more detailed answer.
01:58:00 <quicksilver> ivanm: and package names and whatever else it does
01:58:06 <ivanm> it does package names? :o
01:58:08 <ivanm> @hoogle fgl
01:58:09 <lambdabot> package fgl
01:58:14 <ivanm> waddaya know, it does...
01:58:22 <ivanm> only the extra-libs packages I presume?
01:58:42 <quicksilver> sinelaw: but the answer is almost always : define a type T such that [T] is your 'heterogenous' list
01:58:52 <sinelaw> quicksilver, ok, i'll try that
01:58:55 <quicksilver> sinelaw: the details of how you construct T depend on what you expect to be able to actually do.
01:59:14 <ivanm> if you're only ever applying one type class result to it, using a forall sometimes works
01:59:20 <ivanm> s/result/function/
01:59:33 <sinelaw> i'm not sure the heterogeneity is small enough for that
01:59:51 <quicksilver> sinelaw: yes, it always is.
02:00:13 <quicksilver> I list of completely heterogenous types is obviously completely useless
02:00:17 <quicksilver> because there is nothing you can do with it
02:00:25 <quicksilver> (except measure its length and permute it and so on :P)
02:00:30 <sinelaw> quicksilver, they are parameterized on one type
02:00:33 <sinelaw> i mean
02:00:37 <quicksilver> so, there must always be *something* you can do with it
02:00:43 <sinelaw> I need [T a, T b, T c, ...]
02:00:47 <quicksilver> and that *somethign* helps you choose the right type T to represent.
02:01:08 <quicksilver> then you just need a type "AnyT" which is exists x . T x
02:01:39 <maartenm> , ljust
02:01:40 <lunabot>  luna: Not in scope: `ljust'
02:01:46 <quicksilver> data AnyT = forall a . AnyT (T a)
02:01:47 <sinelaw> ah, ok. I need to learn more about existential types :)
02:01:51 <sinelaw> thanks
02:02:03 <idnar> sb end
02:02:05 <idnar> oops
02:03:12 <mux> any of you haskellers on google wave?
02:04:04 <quicksilver> sinelaw: of course, you're restricted to only operations which work on (T a) for all a
02:04:48 <sinelaw> yes - you mean i can't assume anything about a?
02:05:11 <ivanm> only that it's an isntance of T
02:06:11 <sinelaw> so if data T a = Show a => Blah a, i can assume that a is an instance of Show
02:06:15 <quicksilver> ivanm: not an instance.
02:06:19 <quicksilver> ivanm: T is a type not a class.
02:06:33 <quicksilver> sinelaw: no, that doesn't work :)
02:06:43 <quicksilver> constraints on data types don't work
02:06:45 <ivanm> quicksilver: oh, I thought your forall was on a class
02:07:24 <sinelaw> quicksilver, if I have that T and then define AnyT as before, it won't allow me to use the constraints on a unless i re-specify them in AnyT?
02:08:13 <quicksilver> sinelaw: "data T a = Show a => Blah a" is simply broken
02:08:18 <quicksilver> sinelaw: this is a haskell 98 bug
02:08:27 <quicksilver> sinelaw: constraints in data definitions are not helpful.
02:08:31 <simplicio> no
02:08:35 <ivanm> quicksilver: well, Complex uses it for some reason :s
02:08:35 <simplicio> that code is not H98
02:08:55 <simplicio> isn't it data (Show a) => T a = ...?
02:09:06 <ivanm> yeah, something like that
02:09:11 <quicksilver> sinelaw: however if you use GHC's GADT syntax extension you *will* get the behaviour you want
02:09:17 <sinelaw> hmm
02:09:19 <simplicio> data T = forall a. Show a => Blah a
02:09:23 <quicksilver> sinelaw: (the Blah constructor will 'unlock' the Show constraint)
02:09:27 <quicksilver> simplicio: that's not what he's talking about.
02:09:37 <quicksilver> simplicio: please don't confuse the issue (further0
02:09:45 <sinelaw> i'm already confused
02:10:03 <simplicio> oh, right. but I think the class constraint needs to come before the =
02:10:07 <sinelaw> what's the basic way to parameterize a type on another type with a constraint?
02:10:08 <quicksilver> sinelaw: well in trying to solve your first problem  you've just hit against a bizarre flaw in haskell 98
02:10:14 <quicksilver> sinelaw: in haskell 98, you don't do that.
02:10:31 <quicksilver> sinelaw: there is no sensible (haskell 98) way to include constraints in types.
02:10:32 <sinelaw> but people do it in haskell , no?
02:10:41 <sinelaw> all the time? even in tutorials
02:10:42 <ivanm> the constraint goes in the function, not in the data type
02:10:48 <quicksilver> GHC has a sane behaviour in its GADT syntax.
02:11:00 <quicksilver> arguable this behaviour ought to have been mandated by h98, but it wasn't.
02:11:00 <ivanm> sinelaw: the only place I've seen a constraint on a data type is for Data.Complex
02:11:10 <sinelaw> yeah i've seen some GADTs
02:11:15 <ivanm> some advanced stuff might have it, but I haven't seen it in any tutorials or anything...
02:11:22 <quicksilver> as a point of style, though, it's normally better not to put constraints on your data t ypes.
02:11:34 <sinelaw> so in H98 it works only on functions?
02:11:52 <maartenm> ,uniq
02:11:53 <lunabot>  luna: No instance for (GHC.Show.Show (a -> GHC.Types.Int))
02:11:56 <sinelaw> f :: (Show a) => a -> a
02:11:58 <sinelaw> ?
02:12:30 <quicksilver> sinelaw: it's not that it only *works* on functions.
02:12:35 <quicksilver> constraints on types are legal
02:12:38 <quicksilver> they're just not useful
02:12:44 <quicksilver> and therefore not recommended :)
02:12:46 <ivanm> because you need it in the function as well
02:12:55 <quicksilver> and simplicio is right, they have to go to the left of the =
02:12:55 <ivanm> IIRC, RWH has a good section on this topic
02:13:01 <quicksilver> although GHC supports them to the right
02:13:16 <quicksilver> (and, in some versions at least, has a bug which permits them there even with no extensions turned on)
02:13:25 <sinelaw> ok, i guess i need to read more again :)
02:13:58 <sinelaw> i don't have any constraints in my code anyway, i was just trying to figure out stuff
02:14:09 <quicksilver> sure.
02:15:07 <sinelaw> quicksilver, this page uses them though in the example "Constructing a heterogeneous list":
02:15:09 <sinelaw> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
02:15:25 <sinelaw> (it uses Show)
02:15:29 <quicksilver> sinelaw: yes, but that's different; that's an existential
02:15:37 <quicksilver> that is indeed sane behaviour - but not haskell98
02:15:51 <quicksilver> note that it's data ShowBox, not data ShowBox s
02:15:57 <quicksilver> that's the critical difference between it and your T
02:16:47 <sinelaw> I see. So you can't for a constraint on a parameterized type, but you can force one on the constructor
02:16:57 <sinelaw> *force
02:21:44 <hackagebot> dataenc 0.13.0.1 - Data encoding library (MagnusTherning)
02:28:51 <pozic> ghc: panic! (the 'impossible' happened)
02:28:52 <pozic>   (GHC version 6.10.4 for i386-unknown-linux):
02:28:52 <pozic> 	idInfo co{v a9lFw} [tv]
02:28:52 <pozic> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:29:01 <pozic> Long live type-families!
02:34:00 <pozic> Any perceived win for using Haskell is nullified by bad implementations :(
02:34:04 <FunctorSalad_> haskell-cafe: "Yes, and some points of view aren't as good as other. That's why we  have psychiatric hospitals."
02:34:41 <quicksilver> pozic: type families are an incomplete feature and known to have bugs.
02:35:20 <pozic> I figured that if people were able to write the mtl with them, that they worked. Apparently, I was wrong.
02:35:49 <quicksilver> yes, you were.
02:36:03 <FunctorSalad_> fundeps ftw
02:36:05 <quicksilver> AFAICR they weren't even in the releases notes for 6.10 as a feature.
02:36:14 <quicksilver> it was an experimental preview of them
02:36:28 <quicksilver> 6.12 will have a better implementation but I think it's still not complete.
02:37:08 <pozic> I heard that they wanted to get rid of fundeps, but when is that going to happen then?
02:37:26 <quicksilver> I doubt they'll be removed from the compiler in the forseeable future
02:37:42 <quicksilver> what may happen is that fundeps never get included in any version of a haskell standard
02:37:49 <quicksilver> whilst, eventually, type families might.
02:37:50 <FunctorSalad_> pozic: really?
02:37:59 <ivanm> quicksilver: you mean I shouldn't have ported some of my classes from fundeps to type families?
02:38:00 <ivanm> :o
02:38:17 <ivanm> but the type family implementation looks cleaner (except for continually having "Foo a" everywhere...)
02:38:42 <pozic> FunctorSalad_: I guess we would just have to pool resources and get an independent compiler some day then.
02:39:19 <FunctorSalad_> pozic: how isn't ghc independent? but more resources would be good, sure
02:39:19 <ivanm> pozic: independent of what?
02:39:35 <ivanm> well, there's JHC, UUHC, etc.
02:39:43 <FunctorSalad_> pozic: btw I was /opposing/ removal of fundeps unless there's a good reason I don't know
02:40:53 <FunctorSalad_> example advantage of fundeps: works with TH (IIRC)
02:41:15 <FunctorSalad_> do typefams work with syb?
02:41:55 <FunctorSalad_> (deriving (Data,Typeable))
02:42:11 <quicksilver> no.
02:42:18 <pozic> I don't trust type-families. It took > 10 years before fundeps were properly implement.
02:42:25 <pozic> Why would type-families be any different?
02:42:49 <pozic> implemented*
02:44:41 <pozic> If you extrapolate that, you get that it would take >100 years in a C language.
02:44:52 <pozic> Which, of course, is non-sense.
02:51:36 <Cale> pozic: hmm. The perceived advantage of type families is that their interactions with other type system features are simpler to define. Particularly with GADTs.
02:54:01 <pozic> Cale: but GADTs are not well-integrated either.
02:54:21 <pozic> Features that work for data stop working when you use GADTs to define them.
02:54:57 <pozic> That might not be a problem in theory, but in practice I am not going to use them, until they dominate.
02:54:58 <Cale> Like what? Deriving?
02:55:03 <pozic> Cale: for example.
02:55:19 <Cale> Deriving is a much more complicated feature for GADTs.
02:55:42 <pozic> I don't see why it would be hard to get it up to par with normal declarations.
02:55:51 <int-e> I find it a bit discouraging that newtype deriving breaks with type families.
02:56:39 <int-e> (But you could argue that that's because newtype deriving is a gross hack.)
02:57:36 <pozic> The compiler should derive everything for instances which there only exists one way to implement it.
02:57:55 <quicksilver> the next version of GHC tries much hard to derive stuff for GADTs
02:58:24 <quicksilver> I think it does the 'syntactically obvious' derivation, and if that generates a compile error, it hits you with a sausage.
02:58:42 <pozic> But what would be better is working TH within the defining module.
02:59:33 <kgoj> Hello, I've got a dumb problem: http://haskell.pastebin.com/m5dc4e738
03:00:25 <kgoj> It's just 3-liner, I tried to explain what I meant to do in comment
03:00:27 <dolio> Chage [hh:tt] to (hh:tt).
03:00:55 <kgoj> dolio: It worked, thanks!
03:00:56 <dolio> [hh:tt] is a match against a single-element list whose element is a list of at least one element.
03:01:00 <simplicio> putStrLn.show = print
03:01:33 <kgoj> simplicio: thank you, I didn't know about print
03:01:48 <simplicio> > sequence ["cb", "a", "rtg"]
03:01:49 <lambdabot>   ["car","cat","cag","bar","bat","bag"]
03:03:34 <kgoj> thank you
03:03:44 <kgoj> I felt it should be in stdlib, but i couldn't hoogle it
03:05:15 <maartenm> heh, I named a fucntion "pents" in solving euler44
03:05:24 <maartenm> and now I'm looking at "drop y pents" hehe..
03:10:57 <hackagebot> KiCS 0.8.5 - A compiler from Curry to Haskell (BerndBrassel)
03:12:06 <quicksilver> @hoogle Show a => a -> IO ()
03:12:06 <lambdabot> Prelude print :: Show a => a -> IO ()
03:12:07 <lambdabot> System.IO print :: Show a => a -> IO ()
03:12:07 <lambdabot> System.IO hPrint :: Show a => Handle -> a -> IO ()
03:12:25 <quicksilver> kgoj: you could have hoogled it ;)
03:17:18 <maartenm> ,el
03:17:19 <lunabot>  luna: Not in scope: `el'
03:17:36 <maartenm> ,elem
03:17:37 <lunabot>  luna: No instance for (GHC.Show.Show (a -> [a] -> GHC.Bool.Bool))
03:28:06 <pozic> Where is the monad instance for Either defined or is it not in the std libs?
03:28:19 <opqdonut> @info Error
03:28:19 <lambdabot> Error
03:28:25 <opqdonut> @instances Error
03:28:26 <lambdabot> IOError, String
03:28:29 <opqdonut> gah
03:28:45 <opqdonut> anyway, Control.Monad.Error
03:28:46 <opqdonut> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html
03:36:15 <maartenm> is there a `lazy`  elem, that takes advantage of sorted lists?
03:37:13 <maartenm> @hoogle a -> [a] -> Bool
03:37:13 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
03:37:13 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
03:37:13 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
03:37:27 <PeakerWork> @let arg = flip (.) ; result = (.)
03:37:29 <lambdabot>  Defined.
03:37:42 <quicksilver> maartenm: that's not really laziness you're talking about; or at least not as normally used
03:37:57 <quicksilver> maartenm: but, no, there isn't an elem which takes advantage of sorted lists
03:38:01 <quicksilver> easy to do, though
03:38:06 <PeakerWork> @type (\x xs -> x `elem` takeWhile (<=x) xs)
03:38:07 <lambdabot> forall a. (Ord a) => a -> [a] -> Bool
03:38:10 <maartenm> ok, thanks
03:38:25 <PeakerWork> maartenm: this?
03:38:30 <maartenm> yeah, that :)
03:38:36 <quicksilver> I thin it's missing a take 1
03:39:01 <maartenm> yeah just the head.. I could've done this myself, just wodnered why it isn't in prelude
03:39:09 <quicksilver> > let elem' x s = x `elem` takeWhile (<=x) xs in elem' 2 [1,3..]
03:39:10 <lambdabot>   Not in scope: `xs'
03:39:17 <quicksilver> > let elem' x xs = x `elem` takeWhile (<=x) xs in elem' 2 [1,3..]
03:39:18 <lambdabot>   False
03:39:28 <quicksilver> oh, I see
03:39:41 <maartenm> or perhaps taking advantage of sorted lists is not really something that occurs a lot outside of mathematical contexts?
03:39:48 <quicksilver> no it's fine although I was thinkinh of the take 1 . dropWhile version
03:40:09 <PeakerWork> quicksilver: oh, not reusing elem
03:40:23 <PeakerWork> maartenm: sure they're used
03:40:47 <maartenm> isn't it strange that elem' isn't standard?
03:40:54 <quicksilver> well for fast membership tests one tends to use Sets instead
03:41:02 <quicksilver> and that's faster than a sorted list ;)
03:41:10 <maartenm> they serach binary?
03:41:12 <quicksilver> asmptotically at least
03:41:15 <PeakerWork> a sorted array is nice for all sorts of algorithms (also fast membership)
03:41:18 <quicksilver> yes, Sets are binary trees
03:41:31 <PeakerWork> not a "binary search" though, that would be on a sorted array
03:41:37 <quicksilver> sorted arrays are considerably more useful than sorted lists
03:41:51 <quicksilver> I would call it a kind of binary search.
03:41:59 <maartenm> ah I didn't know sorted arrays were trees
03:42:03 <quicksilver> it is a one-branch search through a binary tree, after all
03:42:10 <quicksilver> sorted arrays are not trees
03:42:11 <quicksilver> Sets are :)
03:42:21 <quicksilver> sorted arrays have the same complexity as trees for many operationst hough
03:42:25 <int-e> sorted arrays are flat. but the way a binary search works, they could just as well be binary trees.
03:42:34 <maartenm> I call anything that searches log-wise a tree :)
03:42:40 <maartenm> I think it's a good definition
03:42:44 <Cale> though, one thing which sorted lists do that Sets cannot is describe infinite sets
03:43:05 <quicksilver> right.
03:43:13 <int-e> > 0 `elem` [1..] -- *ducks*
03:43:17 <lambdabot>   mueval-core: Time limit exceeded
03:43:25 <quicksilver> although you can use some exotic trees for some kinds of infinite set
03:43:33 <quicksilver> you need an asymmetric one for [1..] though
03:44:02 <maartenm> I do have a feeling that when I need binary searching for those euler problems I'm doign something wrong :)
03:44:23 <int-e> well, a set is a function foo -> Bool, and you can store that in a Trie ala MemoTrie.
03:44:33 <quicksilver> > let elem' x xs = x `elem` takeWhile (<=x) xs in elem' 0 [1..]
03:44:34 <lambdabot>   False
03:44:36 <int-e> (for foo = Integer in particular)
03:44:50 <quicksilver> int-e: yes, your example is (essentially) the example we were talking about
03:45:01 <quicksilver> your ducks, that is :)
03:45:10 <int-e> gotcha.
03:47:25 <ilid> hmm, seems like you could represent [1..] or even [..] with an infinite binary search tree. not sure how useful that'd be though
03:47:35 <int-e> heh. one list isn't enough anyway. the complement of that set is [0,-1..] and that's sorted in the opposite direction. (you need a well-founded order for things to work out. which I guess is the basic idea behind all the infinite trie constructions.)
03:47:36 <ilid> since it would need to be infinitely unbalanced :-/
03:47:55 <int-e> ilid: it's useful for memoizing sparsely used functions.
03:48:51 <ilid> int-e: i'd think there are better representations for that, to be honest
03:50:34 <int-e> ilid: I've been using data NatTrie a = NatTrie { zeroT :: a, oddT :: NatTrie a, evenT :: NatTrie a } and data IntTrie a = IntTrie { nonnegT :: NatTrie a, negT :: NatTrie a }
03:50:59 <int-e> ilid: Which is not really a binary search tree.
03:52:09 <int-e> (in the classical ordered sense)
03:53:37 <ilid> that looks pretty reasonable to me
03:55:01 <ilid> though i think that is a binary search tree for an unusual ordering of the integers ;-)
03:55:03 <quicksilver> I think I'd call the fields of NatTrie T0 and T1
03:55:13 <quicksilver> then it's the binary expansion of the number
03:55:14 <quicksilver> (isnt it?)
03:55:24 <quicksilver> t0 and t1 rather
03:56:07 <quicksilver> no, that's not quite correct
03:56:23 <quicksilver> binary expansion of the number ommitting the initial '1', perhaps?
03:56:44 <quicksilver> binary expansion of (number minus one) ommitting initial 1?
03:57:06 <quicksilver> (number plus one)!
03:57:06 <quicksilver> I dunno :)
03:57:06 <ilid> int-e: what do you put in zeroT . negT $ trie?
03:57:42 <maartenm> anyone who *could* do euler 44 without using Sets/other binary search methods?
03:58:02 <ilid> it's a weird ordering where there are infinitely many elements between any two naturals.
03:59:07 <int-e> ilid: the value representing -1
03:59:22 <quicksilver> ilid: like, for example, lexicographic comparison of binary representations on numbers
03:59:25 <ilid> int-e: i see :)
03:59:31 <quicksilver> ilid: to which it is very closely related ;)
03:59:45 <ilid> quicksilver: exactly like that, except on the reversal of the digits i think? :)
03:59:57 <SamB_XP> well, it's the little-endian representation
04:00:10 <int-e> ilid: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=8812
04:00:26 <SamB_XP> like we figure arabic numerals were originally ;-)
04:00:37 <pozic> Is there an easy way to define a monad which only has an escape method? So, a kind of restricted continuation monad? I seem to always use infinite types or end up with some Error e constraint, that I don't want.
04:03:01 <pozic> The obvious thing to do is to use StateT ContT and simply store the continuation at the beginning and call it when one wants to escape.
04:03:18 <pozic> But that requires infinite types or so I believe.
04:23:28 <SamB_XP> Cale: any idea why this doesn't work:
04:23:33 <SamB_XP> @spell definately
04:23:41 <SamB_XP> Cale: ?
04:24:15 <SamB_XP> Cale: I think it should at least give an error message
04:24:17 <dibblego> because 'a' `notElem` "definitely"
04:24:44 <SamB_XP> dibblego: what it's supposed to do is tell me a list of words that I might mean, iirc
04:24:52 <dibblego> ah ok
04:25:29 <SamB_XP> I'm thinking that perhaps the program and/or datafile it needs for that may be missing from lispy's machine (on which lambdabot resides)
04:25:52 <SamB_XP> but that @spell should probably *tell* you when it has such issues
04:27:07 <SamB_XP> I would also ask lispy if he had any idea, but he's not here
04:27:36 <SamB_XP> @help spell
04:27:36 <lambdabot> spell <word>. Show spelling of word
04:28:01 <SamB_XP> just to show you that there actually is such a command, and lambdabot isn't spell-correcting that to a do-nothing command ;-)
04:28:11 <simplicio> @help seen
04:28:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:28:45 <simplicio> preflex: xseen lispy
04:28:46 <preflex>  lispy was last seen on freenode/#haskell 4 hours and 34 minutes ago, saying: and on that note, I'm going to bed
04:28:55 <SamB_XP> simplicio: that command was removed intentionally
04:29:03 <SamB_XP> because it was hardly ever working
04:29:20 <SamB_XP> and perhaps the plugin was even messing up the rest of lambdabot?
04:32:38 <quicksilver> it had a memory leak
04:32:53 <quicksilver> which was causing lambdabot to eventually hog resources
04:32:57 <quicksilver> quite a slow leak
04:34:34 <ivanm> about a litre a day...
04:34:43 <ivanm> ;-)
04:34:48 <maartenm> I can't compile anything that imports Data.Set
04:34:52 <maartenm> euler44.o:fake:(.text+0x40f): undefined reference to `containerszm0zi2zi0zi1_Dat aziSet_Tip_closure' euler44.o:fake:(.text+0x891): undefined reference to `__stginit_containerszm0zi2 zi0zi1_DataziSet_' euler44.o:fake:(.text+0x3b3): undefined reference to `containerszm0zi2zi0zi1_Dat aziSet_insert_info' euler44.o:fake:(.text+0x41e): undefined reference to `containerszm0zi2zi0zi1_Dat aziSet_foldlStrict_info'
04:34:59 <ivanm> maartenm: :o
04:35:07 <int-e> maartenm: use --make or -package containers when compiling the program
04:35:11 <SamB_XP> @google litre in megabytes
04:35:13 <maartenm> is that a smilie or a parameter?
04:35:16 <lambdabot> http://www.theinquirer.net/inquirer/news/1137496/shuttle-reveals-via-nano-sff-box
04:35:17 <lambdabot> Title: Shuttle reveals via nano sff box - The Inquirer
04:35:18 <ivanm> maartenm: which version of ghc? which platform?
04:35:27 <ivanm> maartenm: oh, are you just using ghc Foo.hs ?
04:35:31 <quicksilver> the answer is surely --make
04:35:34 <ivanm> that doesn't actually create the executable...
04:35:36 <SamB_XP> maartenm: don't you mean "or a GHCi/hugs command"?
04:35:38 <maartenm> I'll try make, sorry
04:35:45 <ivanm> SamB_XP: really looks relevant...
04:35:47 <int-e> ivanm: yes it does.
04:35:50 <maartenm> I don't know ghc compilation very well
04:36:04 <maartenm> ok, linking works fine.. thanks
04:36:04 <SamB_XP> ivanm: what really looks relevant ?
04:36:13 <ivanm> SamB_XP: the google result
04:36:21 <SamB_XP> oh, yeah
04:36:24 <SamB_XP> didn't notice it
04:36:30 <SamB_XP> it looks *that* relevant
04:37:08 <ivanm> "Is that a capacity of three litres of megabytes, or just three litres of bytes; perhaps three litres of megahurtz?"
04:37:12 <ivanm> (second comment)
04:37:38 <int-e> (note that with --make, the executable will be called Foo, not a.out, on posix systems. (What's the situation on Windows?))
04:38:02 <ivanm> int-e: wasn't it calling it a.out until 6.6 or something?
04:38:28 <ivanm> I remember when I started playing Haskell that I had to do -o to get decent names...
04:38:34 <quicksilver> ivanm: drifting off topic but along the general lines of a litre of megabtyes you may be amused by http://www.theregister.co.uk/2007/08/24/vulture_central_standards/
04:39:03 <ivanm> quicksilver: heh
04:44:07 <opqdonut> @unmtl StateT a []
04:44:07 <lambdabot> err: `StateT a []' is not applied to enough arguments, giving `/\A. a -> [(A, a)]'
04:44:08 <MyCatVerbs> int-e: Foo.exe on Windows, I am almost sure.
04:44:10 <opqdonut> @unmtl StateT a [] b
04:44:11 <lambdabot> a -> [(b, a)]
04:46:45 <maartenm> I want to write an uncurried "has only unique elements" [a] -> Bool  function
04:46:46 <maartenm> distinct = (== (length . nub) (length))
04:46:55 <maartenm> eh, oops
04:47:51 <maartenm> distinct = (==) (length . nub) (length)
04:47:56 <quicksilver> functions with only one argument are neither curried nor uncurried :)
04:48:04 <maartenm> anyway, I'm just wondering how you write one without lambda
04:48:09 <MyCatVerbs> @pl \x -> (length . nub $ x) == (length x)
04:48:09 <lambdabot> ap ((==) . length . nub) length
04:48:09 <maartenm> I can't get my brian around it
04:48:29 <MyCatVerbs> maartenm: Use the @pl plugin. :)
04:48:33 <quicksilver> you can't, without using "ap" or "join" or a similar trick to 'duplicate' the argument
04:48:37 <maartenm> quicksilver: what's the name then for what I'm trying to do?
04:48:41 <quicksilver> maartenm: I don't know.
04:48:50 <MyCatVerbs> Your program really requires the ((e) ->) monad.
04:49:02 <quicksilver> maartenm: I don't know which part of the problem you were trying to allude to when you said 'uncurried'
04:49:05 <MyCatVerbs> import Control.Monad.Instances # if you want that to work.
04:49:16 <quicksilver> if you mean, not explicitly mentioning the parameter by name, then that's called "point-free"
04:49:19 <poe> http://en.wikipedia.org/wiki/SKI_combinator_calculus you want the S combinator
04:49:21 <maartenm> quicksilver: removing parameters by name
04:49:27 <maartenm> point-free, yes, I remember now
04:49:45 <quicksilver> the reason it's hard is the parameter is mentioned twice
04:49:47 * maartenm 's formal logic education is coming back
04:49:52 <quicksilver> let's take a much much simpler example
04:49:57 <quicksilver> \x -> x + x
04:50:00 <quicksilver> @pl \x -> x + x
04:50:01 <lambdabot> join (+)
04:50:10 <quicksilver> you really need a primitive to duplicate the parameter like that
04:50:22 <maartenm> is that syntactic sugar, btw?
04:50:25 <maartenm> or does haskell work with it
04:50:26 <quicksilver> the code for @pl uses 'join' or 'ap' in both cases
04:50:33 <benmachine> :t join
04:50:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:50:55 <quicksilver> s/in both cases/in these cases/ I mean
04:51:11 <maartenm> I mean, does this have any effect on the performance of the functions?
04:51:18 <quicksilver> it could do.
04:51:32 <maartenm> wow, really?
04:51:33 <quicksilver> it probably won't in practice because the compiler inlines small functions and it all works out the same
04:51:37 <quicksilver> but in principle it might do.
04:52:57 <quicksilver> well it's not really news that different code may have different performance characteristics :)
04:53:19 <quicksilver> GHC compiles the code you give it, there is no 'normal form' for haskell.
04:53:36 <quicksilver> but, it's true that in simple cases like this when everything inlines, it very often all ends up the same or nearly so.
04:54:08 <maartenm> ok, thanks for the explanation
04:54:38 <maartenm> a small part of my brain just triggered it as odd that writing a function point-free wise could have an impact on its algorithmic complexity
04:54:56 <quicksilver> unlikely to have an effect on its *asymptotic* complexity
04:55:01 <quicksilver> (Which is what we normally mean by 'complexity')
04:55:16 <quicksilver> but it can certainly have an effect on its concrete running time - the number of machine code operations it produces may be different.
04:55:24 <maartenm> yes, ok
04:55:26 <SamB_XP> well, unlikely to effect the big-O anyway
04:55:38 <quicksilver> however, transformations which add or remove sharing can in fact affect big-O
04:55:42 <SamB_XP> the assymptotic complexity might actually include constant factors too ...
04:55:43 <maartenm> interesting question, if there are instances where O complexity can be influenced by writing it point-free
04:56:32 <maartenm> Sam: I've always learned that at school as well, but I've noticed a lot of people discard constants in the big O
04:59:35 <ivanm> maartenm: with big-O notation, the actual constants don't really matter
04:59:52 <ivanm> you're generally more interested in how the complexity scales with different input sizes
05:00:53 <SamB_XP> I'm thinking big-O isn't the only possible meaning of asymtotic complexity ?
05:01:21 <SamB_XP> because, e.g., the asymptotes of a hyperbola *definately* have constant factors!
05:01:27 <hackagebot> CPL 0.0.5 - An interpreter of Hagino's Categorical Programming Language (CPL). (MasahiroSakai)
05:01:34 <dibblego> > 'a' `notElem` "definitely"
05:01:36 <lambdabot>   True
05:01:42 <SamB_XP> dibblego: please stop that
05:01:49 <dibblego> likewise
05:02:40 <SamB_XP> definitely
05:02:42 <quicksilver> SamB_XP: the asymptotes of hyperbolae are not the kind of thing you use O() notation for, though.
05:02:46 <dibblego> thanks
05:02:53 <SamB_XP> okay, I set up x-chat to replace definitely with definitely automatically
05:03:00 <SamB_XP> quicksilver: obviously
05:03:25 <quicksilver> "g(x) is O(f(x))" means \exists k s.t. g(x) < k f(x) for all sufficiently large x
05:03:41 <SamB_XP> I'm just saying, I think that asymtotic complexity could also refer to something that includes constant factors
05:03:44 <quicksilver> which implies that constant factors are not very interesting
05:03:46 <SamB_XP> +p
05:03:53 <quicksilver> (although not forbidden)
05:04:09 <pozic> If we only had a bigger universe ;)
05:04:50 <SamB_XP> quicksilver: clearly -- but you can talk about things other than the big-O !
05:05:32 <quicksilver> indeed.
05:05:49 <quicksilver> Sometimes people give actual numbers of cycles on some chosen concrete machine
05:06:00 <SamB_XP> yeah
05:06:03 <quicksilver> normally a fictional machine, in my experience
05:06:09 <quicksilver> concrete fictional machine :)
05:06:13 <SamB_XP> well that usually makes it easier
05:06:15 <pozic> SamB_XP: it's common that before big-O analysis concrete amount of operations are being counted in courses on algorithm/data structures.
05:06:26 <pozic> algorithms*
05:07:00 <lpsmith> the problem with giving an actual number of cycles on a modern machine is that it's very difficult to do,  even under ideal circumstances,  and it's impossible to do in real-world circumstances
05:07:17 <pozic> Maybe we should get rid of modern machines then?
05:07:22 <SamB_XP> I'm thinking that a function that is >= the cycle count on a reasonable such machine could be considered an asymptotic complexity as well
05:07:41 <SamB_XP> lpsmith: well, yes
05:07:45 <pozic> I would like to have a hardware architecture again where I can count cycles and where every cycle takes the exact same amount of time.
05:07:47 <p_l> pozic: or start putting more notice on other complexities than big-O?
05:07:51 <quicksilver> very hard to account for cache stalls, though SamB_XP
05:07:59 <quicksilver> (or pipeline stalls, but cache stalls are much worse)
05:08:03 <SamB_XP> yeah
05:08:05 <quicksilver> what's a cache miss? 100 cycles? 1000 cycles?
05:08:23 <p_l> quicksilver: depends on how severe the miss is
05:08:27 <pozic> I think you can still buy those, but I don't know of a website which lists these things in a trivial way.
05:08:36 <SamB_XP> but you have to admit that including constant factors is a bit more accurate than not, don't you?
05:08:51 <p_l> quicksilver: it might be quite long
05:08:56 <pozic> I mean reading hundreds of data sheets to see that they don't have this property is a kind of waste of my time.
05:09:02 <quicksilver> I don't think the two are strictly comparable but I know what you mean smg
05:09:05 <koala_man> pozic: get a pentium cpu. you can count cycles, but not instructions
05:09:07 <quicksilver> SamB_XP, not smg, sorry.
05:09:19 <pozic> koala_man: I want to count time too.
05:09:23 <quicksilver> pentium-class machines can have cache misses too.
05:09:28 <SamB_XP> pozic: all the cycles take the same amount of time, really, unless you change the clockspeed dynamically
05:09:32 <pozic> koala_man: there are some timers in it, but they are not exact.
05:09:33 <quicksilver> I think you need something pre-virtual memory
05:09:41 <quicksilver> 68000 or Z80
05:09:50 <SamB_XP> well, it doesn't need to be pre-VM
05:09:55 <p_l> quicksilver: 6502?
05:09:58 <lpsmith> virtual memory is a feature of an operating system, not a cpu :-)
05:10:09 <koala_man> pozic: you consider the cpu frequency to waver too much?
05:10:12 <quicksilver> lpsmith: it's typically backed by a piece of hardware (an MMU)
05:10:12 <pozic> SamB_XP: ok, so you are saying that on a pentium CPU you can do real-time programming?
05:10:14 <SamB_XP> but you'd have to disable VM for the memory used for the algorithm ;-P
05:10:20 <p_l> 68k was rather complex chip, iirc
05:10:21 <SamB_XP> pozic: didn't say that per-se
05:10:30 <quicksilver> lpsmith: and the MMU typically has the property that the time for a from-memory-load is no longer predictable.
05:10:35 <lpsmith> quicksilver:  true enough,  but you could always run DOS on a 386
05:10:42 <SamB_XP> pozic: just that the clockspeed is still basically constant on any given CPU
05:10:51 <quicksilver> sure. You could run an MMU-capable machine and not use the MMU, this is true :)
05:11:13 <SamB_XP> some CPUs *can* have it dynamically configured to one of a smallish number of speeds, but you can generally control this
05:11:17 <pozic> I also don't know whether these chips specify the exact amount of cycles they take maximally.
05:11:32 <pozic> (to execute some instruction)
05:11:54 <quicksilver> p_l: yes, 6502 is fine, I think.
05:11:55 <SamB_XP> pozic: I expect you'd need to look at the motherboard and RAM specs to actually know
05:11:59 <quicksilver> 6502 / Z80 would be good.
05:12:01 <pozic> In some cases it is specified, but not in all, I think.
05:12:15 <SamB_XP> yeah, yeah
05:12:30 <koala_man> pozic: nope. and the same instruction can take a different number of cycles depending on context
05:12:31 <p_l> 6502 had nicely specified cycle counts etc. for all operations
05:12:37 <SamB_XP> I think the pentium didn't do superscalar stuff though ?
05:12:41 <pozic> Some Forth CPUs do specify it exactly.
05:12:42 <quicksilver> pozic: I think pipelining, caches, memory management, and branch prediction are the main gotchas.
05:12:50 <quicksilver> so you want something which does none of thsoe.
05:13:01 <quicksilver> SamB_XP: That's my memory. That's what PPro was about, IIRC.
05:13:02 <SamB_XP> p_l: of course, different units may have different cycle count tables ...
05:13:08 <p_l> SamB_XP: P5 included superscalar, but didn't have recoder which appeared in P6
05:13:17 <SamB_XP> ah
05:13:23 <pozic> What do the people that control factories use then?
05:13:25 <SamB_XP> well, that's still pretty predictable then
05:13:42 <SamB_XP> pozic: by "unit to unit", I actually mean "model to model"
05:13:45 <p_l> SamB_XP: P6 used iirc 112 bit instructions
05:14:18 <SamB_XP> not like e.g. the SID chips which, reportedly, are more-or-less unique
05:14:48 <p_l> SamB_XP: as for 6502, the assembler manuals basically had "this instruction takes this many cycles to complete" etc.
05:15:10 <p_l> cycles -> time was dependant on bus cpu clock
05:15:10 <SamB_XP> p_l: well, there's more than one model of 6502-series chip
05:15:11 <mgee> hi, i have "word1 word2 word3". now from that string i want to produce: ["word1", "word1 word2", "word1 word2 word3"] is there a library function for that? subsequences is similar, but not the same
05:15:26 <SamB_XP> I assume they don't all have the same cycle tables
05:15:50 <simplicio> > inits . words $ "foo bar baz"
05:15:51 <lambdabot>   [[],["foo"],["foo","bar"],["foo","bar","baz"]]
05:15:54 <pozic> SamB_XP: and how can you check that they are not lying?
05:16:00 <pozic> SamB_XP: that also takes lots of time.
05:16:03 <cocon> can negation be implemented on the typeclass level?
05:16:03 <simplicio> > map unwords . drop 1 . inits . words $ "foo bar baz"
05:16:04 <lambdabot>   ["foo","foo bar","foo bar baz"]
05:16:06 <ziman> > map unwords . tails . words $ "word1 word2 word3"
05:16:07 <lambdabot>   ["word1 word2 word3","word2 word3","word3",""]
05:16:11 <Cale> > map unwords . inits . words $ "word1 word2 word3"
05:16:12 <lambdabot>   ["","word1","word1 word2","word1 word2 word3"]
05:16:18 <p_l> SamB_XP: the most common (to me) one, the one in C64 and Atari 800/65XE/128, didn't differ too much.
05:16:38 <mgee> wow thanks all!
05:16:57 <p_l> there was for example clear difference between zeropage and normal memory accesses etc.
05:17:11 <SamB_XP> pozic: well, if you can get a hobbyist-made document giving detailed cycle-by-cycle memory access information for every possible opcode -- documented or not -- I think that's pretty damn reliable ;-P
05:18:14 <pozic> SamB_XP: anything specific? (URL)
05:18:28 <p_l> SamB_XP: iirc zeropage access on 6502 was one cycle, while rest was at least two cycles
05:18:37 <SamB_XP> did you know that even the 6510 sometimes starts working on one instruction before it has finished the previous one?
05:18:55 <p_l> SamB_XP: pipelined? :D
05:18:57 <SamB_XP> I don't think any memory access instruction was just one cycle ;-)
05:19:43 <SamB_XP> Well, you see, after it grabs the opcode byte, it grabs the next byte on the assumption that it will be needed as an argument
05:20:00 <p_l> SamB_XP: I only remember that zeropage access was much faster
05:20:36 <SamB_XP> ... so if the instruction turns out to be one byte, it can skip fetching the next opcode since it already has it
05:23:08 <maartenm> @hoogle Int -> Int -> [Int]
05:23:09 <lambdabot> Prelude replicate :: Int -> a -> [a]
05:23:09 <lambdabot> Data.List replicate :: Int -> a -> [a]
05:23:09 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
05:23:29 <maartenm> @hoogle Int -> (Int -> Int) -> Int -> [Int]
05:23:30 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
05:23:30 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
05:23:30 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
05:23:57 * p_l suddenly recalls that on modern PC you can forget any accurate timings, because it might enter SM mode at any time
05:24:35 <ivanm> p_l: what is "SM" mode?
05:24:40 <ivanm> sado-masochism mode? :p
05:24:49 <p_l> ivanm: System Management, but Sadomaso would fit
05:25:11 <ivanm> heh
05:25:11 <p_l> yanks control from OS back to BIOS
05:25:34 <p_l> afaik triggered by hardware NMI
05:25:39 <ivanm> well, IIRC bios took all that fun kind of stuff when designing criterion...
05:25:53 <ivanm> but yes, accurate timings are difficult
05:26:38 <p_l> afaik most PCs could run just as well without it, though certain features on some cpus require firmware called this way
05:27:50 <p_l> also, EFI requires it, iirc
05:28:50 <ivanm> p_l: so EFI makes the BIOS take over?
05:28:59 <ivanm> even though EFI replaced BIOS? :p
05:29:17 <p_l> ivanm: in this case, it's EFI that gets called
05:29:24 <ivanm> (then you have the fun systems like mine where they pretend the EFI is a crippled cut-down BIOS...)
05:29:30 <ivanm> p_l: yeah, I know ;-)
05:29:43 <p_l> you can have the same with OpenFirmware etc :P
05:29:51 <ivanm> heh
05:30:41 * p_l personally prefers the way PALcode ran
05:40:20 <maartenm> @hoogle [a] -> Bool
05:40:20 <lambdabot> Prelude null :: [a] -> Bool
05:40:20 <lambdabot> Data.List null :: [a] -> Bool
05:40:20 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
05:47:07 <maartenm> how strange that on euler problem #49 ( http://projecteuler.net/index.php?section=problems&id=49 )  the solution is also in steps of 3330
05:47:37 <maartenm> or no, that's not that odd
05:47:38 <maartenm> heh
05:50:07 <byorgey> maartenm: it does seem a bit strange to me.  did you think of a good reason why it's the case?
05:50:35 <maltem> Depending on how you read the problem description, it's demanded to be in steps of 3330 :)
05:50:49 <maartenm> no, it's not explicitely demanded
05:51:11 <maartenm> but you need a certain amount of 'room' to be able to permutate over 4 or 3 numbers
05:51:14 <maltem> ok, "this property" = (i) and (ii)... right
05:51:14 <byorgey> yes, I suppose that's a bit unclear, but I took "this property" to mean just an arithmetic sequence of primes which are permutations of one another
05:51:26 <maartenm> it's either 3330 or 330 I think, intuitively at least
05:52:23 <byorgey> I believe you intuitively but it's certainly not obvious!  well, not to me at least. =)
05:52:51 <maartenm> yeah it's not obious, the maethamtical explanation is probably scary
05:52:58 <maartenm> or not, might be incredibly simple
05:53:07 <byorgey> I doubt it's scary.
05:53:12 <maartenm> yeah, nto scary
05:53:19 <maartenm> just, annoying
05:53:20 <byorgey> although I guess that also depends on your perspective ;)
05:54:00 <Cale> Hmm...
05:54:33 <Cale> Yeah, the fact that you want the result to be a permutation of the original digits a few times in a row probably puts some limits on what you could be adding each time.
05:56:33 <byorgey> I note that in both cases the permutations consists of repeated rotation of the first three digits, but rotating left in the example and right in the solution.
05:56:41 <maartenm> oddly enough the second solution starts with 2969, which has two digits that are the same
05:57:03 <maartenm> which makes it less intuitive that you need that much room to make all digits have a turn at being the most significant left one
05:57:53 <maartenm> it's almost like the carries perform magic
06:03:39 <opqdonut> i'm doing a branch&bound, simple recursion in the state monad
06:03:55 <opqdonut> however i'd like to stop the optimization when a good enough solution has been found
06:04:15 <opqdonut> (say, within 1% of the theoretical optimum)
06:04:43 <maartenm> byorgey: either way, if you just do this:
06:04:46 <maartenm> [(a,b,c) |                        a <- [1000..9999],                       b <- takeWhile (<a) [1000..9999],                       let c = (a + (a - b)),                   (sort $ show a) == (sort $ show b),                   (sort $ show b) == (sort $ show c)]
06:04:48 <opqdonut> @unmtl StateT a Either b
06:04:48 <lambdabot> a -> Either (b, a)
06:04:59 <maartenm> you see that a lot of different steps than 3330 are possible
06:05:18 <opqdonut> @unmtl StateT a Maybe b -- i could use this
06:05:18 <lambdabot> a -> Maybe (b, a)
06:05:53 <opqdonut> but i'd need to retain the state, so MaybeT State might be better...
06:06:23 <mmorrow> opqdonut: could you just use whileM?
06:06:42 <mmorrow> (for some hypothetical whileM)
06:06:50 <maartenm> [45,333,495,450,405,549,666,504,945,1665,3330]  .. these are all the different steps for permutations of 3 numbers of four digits
06:07:02 <opqdonut> mmorrow: hmm, that might work
06:07:03 <maartenm> oops, there's more of them
06:07:35 <mmorrow> opqdonut: it seems like that'd be the cleanest/most-direct way to spin until you're within some bound
06:08:38 <opqdonut> there might still be some overhead
06:09:07 <opqdonut> from recursing some even after the limit
06:09:17 <maartenm> [45,333,495,450,405,549,666,504,945,1665,2277,2223,3033,3222,2772,3330,3348,3393 ,3483,3303,3933,..?  (still calculating but I don't suppose there are any more)
06:09:40 <mmorrow> opqdonut: well, i guess it's either doing a <# every spin, or doing a pattern match every (>>=)
06:10:17 <opqdonut> indeed. i'd like to shortcircuit everything somehow
06:11:04 <opqdonut> basically i do "optimize foo = mapM_ optimize (children foo)"
06:11:31 <mmorrow> opqdonut: this might be perfect for a single top-level callCC
06:11:45 <mmorrow> > flip runCont id (callCC (\k -> forever (f 42)))
06:11:47 <lambdabot>   No instance for (SimpleReflect.FromExpr
06:11:47 <lambdabot>                     (Control.Monad....
06:11:50 <opqdonut> i was thinking continuations would fit :)
06:11:52 <mmorrow> > flip runCont id (callCC (\k -> forever (k 42)))
06:11:53 <lambdabot>   42
06:13:39 <mmorrow> opqdonut: if we're going here, this might be useful (although i can't stand the sight of the name "TxM" :) http://hackage.haskell.org/packages/archive/monad-tx/0.0.1/doc/html/Control-Monad-Tx.html
06:13:55 <maartenm> byorgey: final list is [45,333,495,450,405,549,666,504,945,1665,2277,2223,3033,3222,2772,3330,3348,3393 ,3483,3303,3933,891,855]   .. as you can see my 'intuition' for 3330 was just stupid
06:14:22 <mmorrow> although it doesn't play very well with other monads (but only because it's not a transformer)
06:15:00 <opqdonut> hmm interesting
06:15:04 <mmorrow> opqdonut: are you using mtl MonadState?
06:15:07 <opqdonut> yes
06:15:09 <opqdonut> the strict one
06:15:31 <Cale> maartenm: Of course, the odd ones aren't really candidates
06:15:54 <maartenm> ah, right :)
06:15:54 <mmorrow> opqdonut: ok, lemme tweak that module (it's super short, and i have multiple versions locally anyway)
06:15:55 <Cale> maartenm: all those numbers have a special property
06:16:09 <Cale> maartenm: Their digit sum is a multiple of 9
06:16:27 <maartenm> Cale: note that all of them have a permutated neighbour int hat list as well
06:16:39 <maartenm> but I guess those facts are related
06:18:49 <maartenm> the real odd ones are 1665 (no permutated neighbour), and 891 and 855
06:19:53 <cads> hola
06:20:08 <byorgey> cads: hi there
06:20:21 <byorgey> maartenm: interesting =)
06:21:07 <cads> good morning byorgey. What's goin on in #haskell today?
06:21:23 <Cale> maartenm: because those sum to 18?
06:21:58 <maartenm> well, 891 and 855 are the only ones that don't have a permutated neighbour, while the neighbours would be in range
06:22:12 <maartenm> you'd expect a 198 and 585 from the pattern, but there isn't
06:24:39 <maartenm> I'm gonna put a frequency count with these numbers
06:25:51 <byorgey> good morning cads.  you know, the usual: code golf, Project Euler, discussions of asymptotic complexity...
06:30:10 <maartenm> [(72,45),(65,333),(7,405),(70,450),(80,495),(8,504),(5,549),(8,666),(1,855),(1,8 91),(5,945),(10,1665),(3,2223),(3,2277),(3,2772),(5,3033),(3,3222),(4,3303),(40, 3330),(4,3348),(4,3393),(4,3483),(2,3933)]
06:30:15 <maartenm> (frequency, step)
06:30:22 <mmorrow> opqdonut: fwiw, here's the current version of monad-tx that i've been using for 90% of my monad needs the last 6 months (w/ a MonadState instance added)  http://moonpatio.com/repos/monad-tx-alt/
06:30:26 <maartenm>  I can't make any sense of it
06:31:26 <mmorrow> opqdonut: it does some trickery to get rid of that annoying "o" parameter, and i've been using it daily for about 6months it this one project of mine without a hitch, but in the interest of full disclosure :)
06:32:36 <cads> byorgey, any interesting algorithms analyzed?
06:33:31 <cads> btw this makes me happy and fucking horrified at the same time http://www.cs.umass.edu/~immerman/descriptive_complexity.html
06:33:55 <mmorrow> opqdonut: basically, it's just (StateT s (ContT o) a), and the "transactions" on the state are implemented with the combination of (1)mtl-callCC,(2)monadLib-callCC,(3)monadLib-Label-type (all locally cloned to avoid deps)
06:34:42 <cads> what in god's name is co-np
06:35:03 * cads has started just assuming all concepts will come in a co-form
06:35:06 <mmorrow> so you can bail out to the last "begin" point with any of the four combinations of ({error,a result},{rolled-back state, dirty state})
06:35:46 <mmorrow> (and bailing to the last "begin" is O(1))
06:36:00 <gwern> cads: well, you know how you have data, and codata? it's like that
06:36:11 <maartenm> "In computational complexity theory, the complement of a decision problem is the decision problem resulting from reversing the yes and no answers. "
06:36:23 <maartenm> never heard of it either to be honest, but it makes sense
06:36:24 <ilid> cads: for any concept there's a corresponding ncept, and for every ncept there's a rresponding concept.
06:36:46 <opqdonut> mmorrow: hmm, nice
06:37:47 <tavelram> Whats the support for ghc(i) on arm? I remember running ghci or hugs on a mips device like 4 years ago, but doesnt ghc(i) have some x86-specific snippets?
06:38:14 <cads> gwern, that must be similar to the way I have a girlfriend and a co-girlfriend :)
06:39:39 <pozic> How do I write a Monad instance for the newtype without a monad instance here? http://paste.debian.net/48542/
06:40:00 <opqdonut> mmorrow: i already implemented it using ErrorT State tho :)
06:40:06 <mmorrow> opqdonut: :)
06:40:42 <cads> it seems like all co-np problems would also belong in np.. didn't know you could take the complement of a problem though, this is neat
06:41:41 <maartenm> is that true, that co-np = np?
06:41:46 <pozic> cads: providing a certificate of non-existence is not trivially as difficult as proving a certificate of existence.
06:42:20 <pozic> maartenm: nobody knows, but most people think it isn't.
06:42:24 <quicksilver> tavelram: it runs fine, as far as I know, in slow "via portabl-ish C" mode
06:42:34 <quicksilver> tavelram: it's packaged up in the debian-arm distro, for example.
06:42:50 <pozic> maartenm: otherwise there would also be no point in giving it a name, would there?
06:43:03 <cads> :)
06:43:08 <pozic> quicksilver: do you have an idea on my monad instance?
06:43:24 <cads> this stuff on codata is fascinating as well
06:43:27 <maartenm> no I didn't think it was.. but obviously I can;'t think of any examples
06:44:29 <quicksilver> pozic: I would need to think rather harder than I have time for right now to answer that :)
06:44:40 <pozic> I don't like the co overloading. It's the same for dual.
06:44:58 <pozic> It's all arbitrary, and there is no unifying concept which makes it possible to derive everything.
06:45:19 <pozic> For some concepts, co makes sense, but not for all.
06:45:56 <Alpounet> what would cohaskell be then ?
06:45:57 * edwardk has apparently survived the swine flu.
06:46:06 <mmorrow> :o
06:46:19 <edwardk> I've come on here to infect the channel.
06:46:51 <mmorrow> did you grow any extra mutant limbs in the survival process?
06:47:24 <edwardk> No mutant limbs, but I did feel an overwhelming urge to play Champions Online for a couple of days there.
06:47:41 <mmorrow> ah, figures
06:48:23 <Cale> pozic: huh?
06:48:49 <yitz> hi edwardk, have a speedy complete recovery
06:48:52 <pozic> Cale: ?
06:49:07 <Cale> pozic: I'm not sure I understand your complaint about duals.
06:49:19 <Cale> There is a unifying idea.
06:49:26 <edwardk> yitz: fever's gone for a couple of days now, so I'm back in action.
06:49:32 <Cale> The arrows in some category are having their direction switched. :)
06:49:39 <yitz> edwardk: great!
06:50:48 <edwardk> I'm a big fan of duality, but perhaps that is my background as a geometer speaking.
06:50:52 <pozic> Cale: I had an example where this didn't hold, but now I think about it, it does hold. So, maybe it is.
06:51:28 <edwardk> The best thing about duality is you prove something and you get something else for free.
06:52:00 <pozic> What is the category for dual graphs?
06:53:12 <Cale> Ah, that one is tricky :)
06:53:30 <maartenm> I sense G"odel approaching..
06:53:39 <edwardk> Dual graphs are an abuse of terminology ;)
06:54:15 <edwardk> They depend on a particular plane embedding
06:54:28 <Cale> Right, but once you have that...
06:54:41 <dayz> hi
06:54:59 <Cale> The dual of a planar graph is another planar graph
06:55:44 <dayz> i'm trying to install cabal-install, but when i run cabal update it complains about 'openFile: permission denied (Permission denied)' (ref. Writing default configuration to /home/foobar/.cabal/config) does anyone know what's going on? the .cabal/config doesn't exist though.
06:56:14 <dcoutts> dayz: check the permissions on the ~/.cabal/ directory
06:56:25 <dcoutts> dayz: check it's not owned by root or something crazy
06:56:51 <pozic> edwardk: that was what I was complaining about.
06:57:47 <edwardk> I think the notion of duality in projective geometry is more applicable than the category theoretic one here, swapping the roles of points and lines. Here you swap the roles of vertices and the empty space on your plane. There is a duality here, just not the simple 'flip the arrows' kind.
06:57:56 <Cale> Well, clearly we shouldn't define the dual of a plain graph. It should have to come with combinatorial information about how it's embedded.
07:00:45 <quicksilver> well just the cells is enough
07:00:59 <quicksilver> a planar graph is (vertices,edges,cells)
07:02:03 <dayz> ok i'm trying to reinstall cabal-install now, but i keep getting the error 'Could not find module `Distribution.Simple':' after running ./bootstrap.sh i already have cabal installed though.
07:02:45 <dcoutts> dayz: are you sure? does ghc-pkg list Cabal say you've got it?
07:03:17 <dcoutts> dayz: and if it's installed in the user package db, rather than the global one, are you sure the files have not accidentally been deleted?
07:04:04 <dcoutts> another check: ghci -package Cabal and then do :browse Distribution.Simple
07:05:05 <Cale> I suppose we can encode a planar graph as a category whose objects are the vertices, edges and faces of the graph, and there is a unique arrow u -> v if u is a part of v
07:05:24 <naoto`> question.  i want to de-allocate lists. because my program allocates huge lists of String just to make a Map. after the Map is created, i dont need the original [String].
07:05:27 <dayz> dcoutts, this is what i get from ghc-pkg list Cabal: http://pastebin.com/m365406d2 is it normal to have getcwd() fialed?
07:05:37 <Cale> So there's a unique arrow from a vertex to each edge and face that it belongs to
07:06:00 <Cale> and from each edge to each face it belongs to
07:06:01 <naoto`> according to the profiling result, it consumes a loot of memory for the List. and terribly slow.
07:06:03 <dcoutts> dayz: no, that's not normal
07:06:08 <ziman> naoto`, the garbage collector will reap the lists if you don't keep any references to them
07:06:30 <Cale> naoto`: Is the [String] somehow still in scope?
07:06:35 <dcoutts> dayz: my first guess is that the files for the Cabal-1.6.0.3 in your local package db got deleted.
07:06:36 <dayz> dcoutts, ghci -package Cabal gives me http://pastebin.com/m400bc895
07:06:44 <dayz> dcoutts, right
07:06:51 <dcoutts> dayz: right, looks that way
07:07:01 <dcoutts> dayz: did you do something like rm -r ~/.cabal ?
07:07:24 <dayz> dcoutts, hmm yeah i think i did.
07:07:25 <dcoutts> dayz: if so, all the registered per-user packages will be borked, but still registered
07:07:38 <dcoutts> dayz: you'll want to blow the registration away too
07:07:41 <dayz> dcoutts, ooh! hmm what's a good way to uninstall Cabal and reinstall again?
07:07:43 <Cale> pozic: and then the dual graph would be the dual of that category :)
07:07:49 <dayz> dcoutts, or should i try again on top?
07:08:15 <dcoutts> dayz: rm ~/.ghc/i386-linux-6.8.2
07:08:23 <dcoutts> dayz: re-installing cabal will not help
07:08:32 <dcoutts> dayz: blowing away the borked packages will.
07:08:48 <naoto`> ziman, Cale: uh... Strings are refered from the Map.  hmm maybe that's why
07:08:51 <quicksilver> Cale: so the "vertices" are those objects with no incoming arrows, the "edges" are those objects with only incoming arrows from vertices, and the "faces" are the rest?
07:09:28 <dayz> dcoutts, i see. and then reinstall Cabal?
07:09:43 <dcoutts> dayz: it's already installed globally, so no need
07:09:44 <Cale> quicksilver: yeah
07:10:03 <Cale> naoto`: Right, you might be losing the list structure, but not the strings
07:10:05 <dcoutts> dayz: the Cabal package is installed I mean. You can then install the cabal-install package.
07:10:38 <dayz> dcoutts, ah ok. thanks
07:11:35 <mmorrow> speaking of dual graphs (not planar dual) http://moonpatio.com/vacuum/gallery/duals.png
07:11:42 <mmorrow> (has nothing to do with vacuum)
07:12:21 <mmorrow> (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2362)
07:12:39 <ziman> naoto`, if you use the strings as keys, you might want to consider some kind of patricia trees instead of Data.Map
07:12:50 <mmorrow> that's actually my desktop background as of yesterday, coincidently
07:12:57 <quicksilver> mmorrow: please put spaces around URLs if you put them in parantheses so I can click them :P
07:13:08 <mmorrow> quicksilver: nevar!
07:13:27 <quicksilver> then I shall boycott your links!
07:13:28 <naoto`> Cale: actually, i'm trying to port a python program into haskell. it should not be that slow.  but this doesn't seem to be the cause, then.
07:13:33 <quicksilver> and possible arrange industrial action!
07:13:41 <quicksilver> picket lines around your thunks!
07:13:42 <mmorrow> speaking of that, the links in /topic have that affliction too
07:13:50 <mmorrow> quicksilver: oh noes!
07:14:07 <quicksilver> well, oddly enough my terminal program is happy with "" around links, but not ()
07:14:26 <naoto`> ziman: patricia trees! never heard of that. i'll look into it. thanks.
07:14:29 <ziman> naoto`, also, ByteStrings provide efficient storage of strings
07:14:34 <mmorrow> i always get a stray ] for the logs link
07:15:52 * mmorrow can't seem to stop trying to imagine what a picket line around his thunks would look like
07:16:17 <Cale> Yep, this seems to work. Dualising the graph is taking the opposite category :)
07:16:21 <tavelram> quicksilver, ok, great.
07:16:22 <naoto`> ziman: ByteStrings sound more familier. i'll try that too.
07:16:28 <tavelram> quicksilver, cheers
07:16:42 <Cale> Kind of a cheap encoding :)
07:16:50 <mmorrow> heh
07:16:55 <dayz> dcoutts, hi again. just a quick question, should root own .ghc?
07:17:03 <dcoutts> dayz: no
07:17:18 <dcoutts> dayz: it looks like at some point you did sudo cabal install blah
07:17:28 <dcoutts> dayz: using root to install into your own home directory
07:17:35 <dayz> dcoutts, yeah i think so.
07:17:35 <Cale> Categories are really pretty good at encoding incidence structure.
07:19:31 <dayz> dcoutts, it's all good now. thanks
07:19:45 <dcoutts> great
07:25:27 <mun_> hi
07:25:59 <mun_> i'm trying to install base-4.1.0.0 using cabal but i keep getting the error 'It requires ghc-prim -any and integer -any'
07:26:03 <mun_> isn't ghc-prim part of base?
07:26:55 <dcoutts> mun_: you don't want to install base
07:27:09 <dcoutts> it's already installed and cannot be upgraded
07:27:14 <dcoutts> not without upgrading ghc
07:28:59 <HairyDude> what's the precedence of the type operator (->)?
07:29:44 <mun_> dcoutts, oh right. i'm trying to install hxt-filter-8.3.0 but it seems to need base >= 4. so would i need to upgrade ghc?
07:30:08 <dcoutts> mun_: right, or possibly find an older version of that package that will work with your older ghc version
07:31:12 <EvilRanter> HairyDude, lower than any other type operators
07:31:21 <EvilRanter> HairyDude, and right-associative
07:31:38 <HairyDude> thanks
07:31:46 <mun_> dcoutts, i'm trying hxt-filter-8.1.0. on hackage, it says it only needs base >= 3, but in cabal it says it needs base==4.*
07:31:49 <EvilRanter> (of course, there's no other type operators unless you're using the TypeOperators extension, so without that the first bit's moot)
07:32:06 <HairyDude> oh, "infixr with fixity 0" says the ghc user guide
07:32:45 <mun_> cabal install hxt-filter-8.1.0 should be the right command, right?
07:33:28 <dcoutts> mun_: yes
07:34:18 <quicksilver> "Function arrow is infixr with fixity 0. (This might change; I'm not sure what it should be.)"
07:34:25 <quicksilver> ah yes, you found it just before I did :)
07:34:28 <dcoutts> mun_: you'll also need to tell it to use an older hxt
07:34:28 <mun_> ok i know what the problem is
07:34:28 <mun_> thanks
07:34:36 <mun_> dcoutts, yeah that's right
07:35:00 <dcoutts> mun_: cabal install --dry-run -w ghc-6.8.2 hxt-filter-8.1.0 'hxt < 8.2'
07:35:25 <dcoutts> you can omit the -w ghc-6.8.2 bit of course.
07:35:33 <dcoutts> I need that to select the older ghc version
07:36:38 <Cale> Grr, my mouse seems to be randomly sending wheel up and down signals now. Seems like it's time for a new mouse.
07:37:07 <voker57__> genius?
07:37:47 <theclaw> I was trying to work through the "Function parsers" chapter of Programming in Haskell, however I get a type error with this code: http://paste.ubuntu.com/288618/
07:38:02 <theclaw> it's exactly the code as it's printed in the book. any idea why?
07:38:27 <Botje> theclaw: which error do you get?
07:38:32 <theclaw> Botje: "Couldn't match expected type `Char' against inferred type `[(Char, String)]'"
07:38:56 <Botje> on which line?
07:39:11 <theclaw> sorry, 45:16
07:39:25 <mun_> dcoutts, hmm strange. curl's one of the dependencies, so i'm trying to install that. but i keep getting 'error: curl libraries not found, so curl package cannot be built'
07:39:32 <theclaw> Botje: err, wait
07:39:34 <Cale> theclaw: There is no line 45
07:39:39 <dcoutts> mun_: that'll be the C libs
07:40:07 <theclaw> http://paste.ubuntu.com/288664/
07:41:37 <mun_> dcoutts, ah right
07:42:03 <Cale> theclaw: You can't use do-notation if you're not going to write an instance of Monad
07:42:40 <Cale> theclaw: You've defined return and >>= which are the components of a Monad instance, without actually writing an instance of Monad
07:43:15 <Cale> Of course, the Parser type here can't actually be made an instance of Monad, because it's just a type synonym rather than a proper type constructor.
07:43:16 <quicksilver> I don't understand why he's not getting an error saying 'no instance of Monad for String -> [(a,String)]'
07:43:16 <theclaw> Cale: I don't know much about monads yet
07:43:31 <Cale> theclaw: you could write
07:43:33 <theclaw> Cale: monads are discussed later in that book
07:43:51 <Cale> p = item >>= \x -> item >>= \_ -> item >>= \y -> return (x,y)
07:44:07 <Cale> which is what the do-notation would desugar to anyway
07:44:23 <theclaw> yes I tried that, this works
07:44:27 <Cale> I wonder if there's a flag we could use...
07:44:31 <mun_> now i'm trying to install HUnit with cabal, but i keep getting an error saying "Test/HUnit/Lang.hs:22:1: lexical error at character 'i'" does anyone know why?
07:44:38 <Botje> oh. that's a silly constraint :)
07:45:03 <theclaw> Cale: I just noticed the errata says that some definitions won't work as printed in the book :)
07:45:08 <quicksilver> Cale: are you thinking of -XNoImplicitPrelude ?
07:45:50 <dcoutts> mun_: that would usually be a missing -cpp flag, but I'm surprised you'd get that with Hunit, what version?
07:46:32 <Cale> quicksilver: yeah, but it doesn't work
07:46:43 <mun_> dcoutts, it's 1.2.2.0
07:47:36 <Cale> oh, we're not defining (>>) yet, maybe that has something to do with it
07:47:43 <quicksilver> Cale: as I said, I don't really understand why you get that error
07:48:07 <quicksilver> Cale: how can it even try to type-check that definition without a monad instance for Parser in scope?
07:48:26 <Cale> yeah, after defining  p >> q = p >>= const q
07:48:43 <Cale> and adding {-# LANGUAGE NoImplicitPrelude #-}
07:48:46 <Cale> to the top of the file
07:49:02 <dcoutts> mun_: gosh, that version of the package is totally broken with older ghc
07:49:13 <Cale> and of course, adding (>>) to the hiding list for the Prelude import
07:49:18 <Cale> it compiles :)
07:49:26 <dcoutts> mun_: try version 1.2.0.3
07:49:30 <cads> Hey, you guys, suppose that we have a large collection of pirated math texts, but we're experiencing the problem that a fraction of them are corrupt, and they are named and categorized poorly. Suppose that there are hundreds if not thousands of books. What kind of solution would we try out?
07:49:32 <mun_> dcoutts, yeah, that version is fine.
07:49:35 <Cale> ghci> p "abc"
07:49:35 <Cale> [(('a','c'),"")]
07:50:22 <Cale> cads: Tediously organise them all by hand?
07:51:19 <Cale> cads: It'll probably still take less time than writing some kind of general OCR and classification engine which did anything at all useful.
07:51:36 <quicksilver> mechanical turks ftw.
07:51:53 <Cale> cads: Another option is just to get a better collection of pirated books which someone has already organised for you.
07:52:32 <cads> I think it should be possible to look the books up on amazon and get their metadata and bibliographies.
07:52:49 <tomh-> or hire someone to do it for you on the money you saved by not buying the originals
07:53:23 <ystael> RIP I.M.Gel'fand
07:53:33 <cads> As for OCR engines, many pirated texts already have searcheable texts even though they're simply scanned images, due to what I'd guess must be OCR
07:53:52 <cads> ystael:  :(
07:56:59 <ystael> cads: amazon's book metadata is very poor quality.  i don't know if librarything makes their library service connector code available, but library of congress would be my first stop for metadata, at least for math books.  the problem with that is they often only have a record and isbn for the hardcover edition.
07:58:13 <PeakerWork> does someone have a parallel swap-based quick-sort handy for a jdh reply? Or is it better not to reply to jdh?
07:59:14 <cads> I think someone content management system must already solve this kind of problem for researchers, but I haven't run across anything more sophisticated than a bibliography database in open source
08:01:33 <ilid> PeakerWork: don't waste your time on it :)
08:02:07 <ystael> that's basically what you want, though, isn't it?  that and maybe content search or tagging inside the documents?  i don't think you're going to find a good and easy solution for bad scans, particularly with the variety of ways people screw them up.
08:04:18 <quicksilver> PeakerWork: it is better not to reply to jdh
08:04:33 <ystael> (i have one where every m pages, for some m i haven't counted, there is a sequence of pages arranged n-1, n, n+3, n+1, n+4, n+2, n+5, n+6, ...  almost makes me think the book they scanned was sewn wrong.)
08:04:39 <quicksilver> PeakerWork: it is sometime worth replying to other people jdh has confused or misled, if that seem likely to be productive.
08:04:39 <PeakerWork> quicksilver: don't people that see a criticism without a response assume there might be something to it?
08:04:57 <quicksilver> PeakerWork: you can spend your whole life worrying about such possibilities ;)
08:07:08 <PeakerWork> quicksilver: I guess at least Reddit has a mechanism for this, downvotes
08:07:51 <Cale> jdh is a famous troll
08:09:52 <cads> ystael: at the least it should allow you to verify integrity of your documents, and maintain a database of sections of the text that you highlight, insert notes into, tag, or make links to
08:11:05 <cads> I think a CMS tends to be a cross between your pdf reader, a desktop publishing suite, a file explorer, and a web browser.
08:12:38 <cads> there seem to be some guides for scientists using a CMS for their writing :)
08:13:50 <PeakerWork> Cale: I do think he believes most of what he says, though
08:14:19 <jmcarthur_work> it's hard to tell
08:14:23 <PeakerWork> Cale: I think maybe code speaks louder than words, so replies to jdh should maybe consist more of code and less words, but that takes more time than I can put into it
08:15:05 <jmcarthur_work> i think a lot of what he says is rationalization, which is a kind of belief self-protection system, perhaps
08:15:24 <jmcarthur_work> and if that's the case, no amount of sound logic will convince him of anything else
08:15:26 <Cale> PeakerWork: I'm not so sure that he actually believes what he says. He has some kind of misguided financial motivation to say the things that he says though.
08:15:51 <PeakerWork> jmcarthur_work: except, perhaps, debunking his points with actual code
08:16:27 <jmcarthur_work> PeakerWork, try debunking any belief system with concrete evidence. people are less rational than one might wish
08:16:59 <jmcarthur_work> and that's coming from somebody with a strong religious background
08:17:56 <Raynes> I bet my religious background could beat yours at arm wrestling.
08:18:20 * jmcarthur_work shows Raynes his HUGE religious background
08:20:30 <jmcarthur_work> For the record, I don't believe in "debunking" belief systems. I only believe in open mindedness. So, religious dogma and illogical rationalization simply annoy me.
08:21:20 <quicksilver> PeakerWork: he is a troll in the pure sense; he says things primarily because of the reaction he hopes to provoke.
08:21:31 <PeakerWork> quicksilver: the financial one?
08:21:34 <quicksilver> it may well be that he often believes the what he writes is truth or half-truth
08:21:42 <quicksilver> I'm not sure it always is
08:21:52 <quicksilver> the ultimate motive is presumably financial yes
08:21:58 <jmcarthur_work> and sadly, the best trolls do speak in half truths, not lies
08:22:18 <quicksilver> the very best lie is that which is almost entirely true.
08:22:25 <jmcarthur_work> exactly
08:22:46 <jmcarthur_work> like, it's true that we lack very good hash tables. the lie is in how important that is
08:23:09 <Cale> actually, that's a lie too
08:23:35 <Cale> We have a binding to Judy which is a very fast hashtable structure.
08:23:45 <jmcarthur_work> i thought Judy was more like a trie
08:25:06 <pozic> I thought they were just arrays that resize when needed.
08:25:21 <jmcarthur_work> no they are much more complex than that
08:25:27 <Cale> It uses hashing, and it's a sort of table, anyway ;)
08:25:45 <jmcarthur_work> Judy is *extremely* complex
08:26:22 <PeakerWork> jmcarthur_work: the interface seemed pretty tiny.. what kind of hash bin'ing does it do?
08:26:28 <quicksilver> "like a trie" seems a reasonable summary
08:26:44 <ilid> Cale: we do, however, lack a very good hash table, which works for any contained type of kind *, and doesn't cause the GC to thrash
08:26:48 <PeakerWork> btw: It does seem that jdh stopped saying "omgz, Haskell no hash table" and started saying "omgz, Haskell no simple parallel quicksort", at least in a recent thread
08:27:09 <pumpkin> isn't judy basically hash + intmap, all in c?
08:27:30 <jmcarthur_work> i forget the number exactly, but judy uses at least 20 or so distinct data structures internally, iirc
08:27:47 <Cale> ilid: That sounds impossible. You can't hash things if you don't know anything about them.
08:28:18 <ilid> Cale: not entirely true. suppose your 'createHash' function takes a hashing function...
08:28:25 <ilid> *createHashTable
08:28:35 <Cale> Well, okay
08:28:37 <jmcarthur_work> PeakerWork, http://judy.sourceforge.net/application/shop_interm.pdf
08:28:49 <ilid> Cale: or sure, impose a typeclass constraint if you want
08:28:57 <ilid> either way, we don't have one of those ;-)
08:28:59 <Cale> But then a lot of the performance of your hashtable will be up to how good a hash function your users can come up with.
08:29:25 <pozic> PeakerWork: I think he just doesn't want to repeat himself.
08:29:34 <ilid> that's true for any hashtable implementation, so isn't an argument against haskell, or the hashtable implementation, or...
08:30:03 <pozic> PeakerWork: A language implementation in which you have to use libraries to get better performance as the default is a bit weird.
08:30:24 <quicksilver> ilid: well, in languages where object addresses are safe (like java) you can use the pointer to the object as the basis of the hash
08:30:41 <PeakerWork> pozic: than writing it yourself?
08:30:42 <quicksilver> ilid: that is fast and doesn't tend to give you degenerate behaviour
08:30:54 <ilid> quicksilver: it really depends on what form of identity you want for the keys. keying off object addresses isn't always the right thing
08:31:06 <quicksilver> ilid: yes, I know.
08:31:13 <quicksilver> ilid: nonetheless it's a popular solution :)
08:31:36 <quicksilver> it's what java does if you don't override "hashValue()" or whatever they call the method, I think?
08:31:41 <jmcarthur_work> pozic, it's not that weird. every language is this way, to varying extents
08:32:24 <pozic> Do you have use unsafeCoerce to avoid having to introduce a fundep?
08:32:30 <jmcarthur_work> quicksilver, we could do the same thing with a simple collection of IORefs
08:32:34 <sproingie> why doesn't someone just write an updated hashtable using data-hash?
08:32:40 <pozic> Have you used*
08:32:47 <Cale> pozic: That's a weird question :)
08:32:51 <ilid> quicksilver: i believe so. is your contention that the lack of object identity in haskell (stableptr aside) means that we fundamentally can't compete with such implementations?
08:33:06 <ilid> (at least, not without extra restrictions on the hash keys)
08:33:06 <pozic> Cale: yes, it was a terrible hack that should work, I think.
08:33:21 <pumpkin>  sproingie: the main problem with the hashtable is GC behavior
08:33:22 <quicksilver> ilid: well, my contention is that one particular "cheap and dirty" solution isn't available to us, that's all
08:33:48 <jmcarthur_work> it's available to us if we make the same sacrifices everybody else makes
08:33:58 <jmcarthur_work> IORef gives us identity
08:34:14 <jmcarthur_work> we are just more picky
08:34:35 <quicksilver> actually the API of IORef doesn't give you a hash function, as far as I recall
08:34:46 <quicksilver> even though one could, in principle, exist
08:34:47 <PeakerWork> IORefs can be moved around can't they?
08:35:17 <ilid> would an IORef (StablePtr a) work reliably?
08:35:18 <quicksilver> ilid: I've actually never let the absence of hash table bother me
08:35:26 <jmcarthur_work> PeakerWork, if that's the case, surely their references are updated properly?
08:35:30 <quicksilver> IIRC StablePtrs aren't reliable.
08:35:38 <sproingie> StablePtrs aren't?
08:35:48 <quicksilver> I've never hapened to write code for which Data.Map or Data.IntMap wasn't appropriate
08:35:58 <jmcarthur_work> nor i
08:36:01 <quicksilver> I know it bothers people who do write this kind of code
08:36:14 <PeakerWork> quicksilver: supposedly hash tables have faster lookup than Data.Map and possibly IntMap. I am not sure if that's true
08:36:24 <quicksilver> mostly if you are CPU-bounded and dependent on hash mutation speed, I think.
08:36:27 <pumpkin> PeakerWork: Data.Map I can see
08:36:29 <jmcarthur_work> that doesn't mean there are no use cases for hash tables, but they are really best for a small subset of cases
08:36:34 <quicksilver> I've never written a program like that ;)
08:36:47 <quicksilver> jmcarthur_work: right. Although 'best' doesn't mean 'necessary'
08:36:51 <pumpkin> but most of the time it's people screaming about the O(log n) time who don't really think it through
08:36:57 <quicksilver> I don't necessarily drive the 'best' car money can buy.
08:37:04 <quicksilver> but, my car works fine for me.
08:37:12 * pumpkin buys quicksilver a bugatti veyron
08:37:19 <quicksilver> \o/
08:37:21 <ilid> in practice, log n is small, and hashing time must scale as log n if your hash function doesn't suck.
08:37:29 <pumpkin> quicksilver: but you need to pay for gas and insurance!
08:37:30 <jmcarthur_work> if the library is free, the car analogy doesn't really apply ;)
08:37:35 <pumpkin> ilid: yeah
08:37:46 <quicksilver> jmcarthur_work: the point isn't the money part.
08:37:51 <pumpkin> jmcarthur_work: the car is free for quicksilver too
08:37:56 <quicksilver> jmcarthur_work: the point you don't always need the best of everything.
08:38:19 <jmcarthur_work> no, but if the best is readily available then i think you should use it
08:38:34 <jmcarthur_work> that doesn't mean we should be rushing to make limited use hash table libraries
08:39:17 <quicksilver> and of course persitence/immutability is also an interesting virtue
08:39:33 <pozic> Immutability when you don't need it only costs.
08:39:40 <jmcarthur_work> not true
08:39:42 <quicksilver> I rather like the fact [Int]Map is persistent and immutable although I can't immeditately think of a case I'd use it.
08:39:58 <quicksilver> sorry, case I *have* used it
08:39:58 <jmcarthur_work> immutability can be faster than mutability for many things
08:39:59 <quicksilver> pozic: speed when you don't need it only costs.
08:40:07 <jmcarthur_work> consider a mutable finger tree. have fun with that
08:40:07 <pumpkin> can't we build a hashing + intmap "hashtable"? isn't that what clojure does?
08:40:12 <pozic> jmcarthur_work: then why does Clean have uniqueness types?
08:40:15 <pumpkin> they call it a persistent hashtable, which is an oxymoron to me
08:40:38 <pumpkin> (and I think it's mostly for the sake of their image, and in that respect they're smarter than we are :P)
08:40:39 <jmcarthur_work> pozic, for the same reason we have IO, isn't it?
08:40:43 <pozic> jmcarthur_work: and why does Clean code work faster than Haskell code and why is there research being done in adding uniqueness types to Haskell?
08:41:14 <jmcarthur_work> pozic, because uniqueness types apparently have some advantages over an IO monad. perhaps easier to optimize?
08:41:17 <pozic> jmcarthur_work: and that it constitutes a proof that it is unique, so mutable data structures can be used under the hood.
08:41:43 <quicksilver> well the point is, it's a trade-off
08:41:50 <pumpkin> doesn't Clean have difficulty with multithreading?
08:42:04 <quicksilver> I don't think Clean's speed over haskell is primarily due to the difference of the language
08:42:09 <quicksilver> I think it's just a better code generator
08:42:10 <pozic> quicksilver: how can there be a trade-off if you know that you don't need persistence?
08:42:22 <quicksilver> pozic: how can there be a trade-off if I know that I don't need speed?
08:42:35 <jmcarthur_work> pozic, i think a uniqueness proof is different from mutability in general
08:42:38 <nhjoe> Hello guys; although I am perfectly aware that Haskell is a kickass - language for concurrency, is it also possible to have hot code swapping features in it, Erlang - style? Thanks in advance.
08:42:45 <ilid> jmcarthur_work: i think i read somewhere that, when compiling functions with unique arguments, if the argument is the right size, the space is reused for the result, saving a GC
08:42:56 <quicksilver> I know speed is absolutely irrelevant to me so I like have persistence on the off-chance that turns out useful.
08:42:56 <jmcarthur_work> ilid, sounds about right
08:43:10 <quicksilver> you may know persistence is irrelevant and so you like to have speed in case that is useful
08:43:13 <quicksilver> fair enough.
08:43:15 <quicksilver> that's what I mean by a trade-off.
08:43:25 <ilid> persistence is irrelevant right up until the moment you need it. then it's a nightmare to add it
08:43:33 <ilid> performance is the same, minus the nightmare.
08:43:45 <quicksilver> nhjoe: it's not easy.
08:43:54 <pozic> ilid: it's the same when you start with a persistent structure and what to switch to a mutable one.
08:43:55 <quicksilver> nhjoe: it's not impossible but it's not really a language feature.
08:43:57 <nhjoe> quicksilver: but is it possible
08:44:05 <quicksilver> nhjoe: it's more of a GHC feature
08:44:13 <quicksilver> and not a terribly well documented one :)
08:44:15 <sproingie> nhjoe: to the degree of erlang?  no.
08:44:18 <nhjoe> I see, is there anybody working on this?
08:44:25 <quicksilver> from time to time people work on it
08:44:39 <nhjoe> I see
08:44:40 <quicksilver> see http://hackage.haskell.org/package/dyre
08:44:50 <quicksilver> and, much older, http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:44:51 <ilid> pozic: i don't actually agree with that. i think that transformation is simpler...
08:44:55 <sproingie> anything sufficiently isolated and stateless can be "hot swapped", but it's not a built in feature
08:45:40 <jmcarthur_work> ilid, i agree with pozic on that one. where i disagree is whether it's a common enough thing that i care
08:45:48 <pozic> ilid: it is still a lot of work. If a compiler would do this on the other hand...
08:46:42 <nhjoe> sproingie: so it is kind of difficult to implement erlang - style hot code swapping without changing the language in very significant terms you mean.
08:46:50 <ilid> pozic: well, yeah, automatically specializing functions if their arguments are unique to work in place would be awesome
08:47:01 <nhjoe> thanks quicksilver, browsing through
08:47:28 <quicksilver> pozic: although not necessarily faster
08:47:35 <quicksilver> because it breaks GC invariants
08:47:44 <quicksilver> (which, basically, is the same reason Data.Hashtable is slow)
08:47:54 <sproingie> nhjoe: probably.  the type system does not like having new code dropped in.
08:48:07 <ilid> well, Java implementations combine a generational GC with mutability and the performance isn't abysmal
08:48:08 <pozic> quicksilver: yes, I have been thinking about GC. I think something like LinearLisp is a lot better in that regard. No garbage.
08:48:23 <nhjoe> hmm i wonder if it is the "impurity" in Erlang that allows this to happen more easily
08:48:32 <pozic> I don't know of more recent approaches, though. I mean there is region-inference, but the exact relation ships?
08:48:34 <quicksilver> if you are talking about a tight loop in which you can potentially eliminate the garbage entirely then yes, that's a solution
08:48:50 <quicksilver> that is a substantial piece of code-gen work, of course
08:49:03 <quicksilver> but would be nice to have working well enough for a good selection of cases
08:49:14 <pozic> quicksilver: no, I mean that in LinearLisp _no_ garbage is ever created.
08:49:15 <sproingie> nhjoe: doubtful, i think it's the overall lack of local state
08:49:26 <ilid> i vaguely recall reading that Chris Lattner was adding region inference to LLVM but i don't know how well it works
08:49:26 <sm> naively, it seems that hot-installing new code is easy if you type check it only as an isolated unit
08:49:26 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
08:49:31 <quicksilver> I was imagining an intermediate solution
08:49:33 <sm> @messages
08:49:33 <lambdabot> kowey said 1d 1h 57m 47s ago: gwern pointed out that perhaps darcscommitbot should have some sort of anti-flood check (eg coalesce > 5 patches into fewer messages) - context: 75 patch push ahead
08:49:51 <quicksilver> where only some code is analysed for space-linearity
08:50:15 <quicksilver> ilid: sure, but I think the haskell GC is quite a bit faster than the Java one because of the immutability assumption
08:50:17 <nhjoe> sproingie: it kind of draws a pretty thick line on where to use Erlang and when Haskell when it comes to having to deal with real - time disaster - dealing scenarios
08:50:31 <quicksilver> ilid: I'm not saying it's impossible to make it work - obviously it isn't - but it is a big speed advantage in itself
08:51:06 <quicksilver> so you have to ask if the loss there outweighs the gain you'd just made
08:51:19 <quicksilver> of course, you can imagine a separate nursery for the mutable stuff
08:51:23 <quicksilver> you can imagine all kinds of things :)
08:51:34 * Baughn imagines a CPU with hardware support for thunks
08:52:20 <nhjoe> thanks guys, I will study this a bit further; it's been a pleasure :)
08:52:58 <Beelsebob> Baughn: the thing they're building at York?
08:53:09 <Baughn> Beelsebob: I'm imagining a haskell-specific CPU
08:53:40 <Baughn> Beelsebob: It might be a bit of a pipe dream, but /eventually/, nanotechnology should do for hardware what programmability has done for software
08:53:48 <ilid> quicksilver: you would know at the point of allocation that the object was going to be used linearly, so yeah, a best-of-both-worlds GC might be possible
08:53:52 <sproingie> Baughn: where they don't fab the CPU til the program runs?
08:54:06 <pozic> Baughn: do you know FabAtHome?
08:54:17 <Baughn> pozic: I'm well aware of quite a few of those initiatives, yes
08:54:35 <sproingie> translating abstract machines into silicon has typically not worked out so well
08:54:48 <Baughn> sproingie: At install time, more likely. Include a few general-purpose CPUs to run code instantly, and people just have to wait a few hours (tops) before it can run at full speed
08:54:56 <pozic> Baughn: the demos look quite impressive. I don't know how feasible it is, though.
08:55:08 <sproingie> even orthodox virtual machines like the jvm have done pretty poorly on "java chips"
08:55:31 <Baughn> I suspect the benefit would be by far largest for /un/orthodox languages
08:55:51 <Baughn> pozic: It's interesting, and if they get it properly working I'd definitely get one, but what I'm thinking of is the sort in http://www.youtube.com/watch?v=zqyZ9bFl_qg
08:59:27 <Baughn> pozic: Also, one reason I'm thinking this will happen is that, as far as we can tell, nano-computers (of the sort we can design now) would have enormous power densities. Which means, you can't /use/ a very large on - it'd vaporize - and with the manufacturing cost being roughly zero that leaves a lot of room for specialized subcircuits.
09:00:12 <pozic> Baughn: or the government will disallow it.
09:00:27 <Baughn> pozic: That would be the stupidest thing they could do
09:00:34 <pozic> Baughn: it would be _extremely_ cool to have a factory on my desktop.
09:00:37 <sproingie> you just need efficient cooling
09:00:48 <sproingie> power densities of existing CPUs are already ludicrous
09:00:51 <Baughn> sproingie: Um, we're talking "megawatts per cubic centimeter" here
09:01:18 <pozic> Baughn: the thing is,as technology becomes cheaper, governments become more useless.
09:01:19 <Baughn> While diamondoid is easy to cool and can take a lot of heat, that's still unreasonable.
09:01:24 <ystael> Baughn: gives a whole new meaning to the phrase "Sun workstation" :)
09:01:44 <Baughn> pozic: Anyway. It's not something you can police, and the last thing they should do is incentivize a black market.
09:01:46 <kakeman> i have string of real values divided by spaces so how to read these values to list?
09:02:09 <Baughn> pozic: So long as the government allows people to have nanofactories, they can then put reasonable restrictions on how those work. The moment the restrictions become /un/reasonable, they've lost.
09:02:16 <Baughn> kakeman: Prelude.words
09:02:20 <sproingie> actually i think we already beat the sun as sheer power density goes
09:02:24 <kakeman> thanks
09:02:28 <Baughn> > words "42.2 13 xxy"
09:02:30 <lambdabot>   ["42.2","13","xxy"]
09:02:35 <sproingie> the surface maybe.  then again the surface of the sun ain't that dense.
09:02:45 <pozic> Baughn: if there are restrictions, then it is immediately not as interesting anymore.
09:03:18 <Baughn> pozic: Of course, but unrestricted nanofactories would be ridiculously dangerous to have around. :P
09:03:29 <sproingie> yay grey goo
09:03:33 <Baughn> ..no, not that.
09:03:43 <sproingie> yay nanoviruses
09:03:52 <pozic> Baughn: so, how do you write a program that decides what is dangerous and what is not?
09:03:54 <Baughn> So they have to restrict them somewhat, while still not making people want to get the unrestricted black-market version..
09:03:58 <tromp> > map read (words "42.2 13") :: [Double]
09:03:58 <pozic> Baughn: hello halting problem.
09:04:00 <lambdabot>   [42.2,13.0]
09:04:02 <Baughn> pozic: Probably using building blocks
09:04:37 <pozic> Baughn: I doubt that will help a lot.
09:04:39 <Baughn> pozic: You'd have to limit them to only a subset of the actually safe designs, then have a reasonable program to allow for legalizing designs that go outside that
09:04:52 <pozic> Baughn: you can still make weapons from slightly bigger stuff.
09:05:05 <Baughn> pozic: Oh, sure. You can't stop people making weapons.
09:05:12 <pozic> Baughn: the solution is to make society such that nobody wants to make weapons.
09:05:25 <Baughn> However, you may be able to stop them making weapons that are overpoweringly better than today's
09:05:37 <Baughn> Or poison dust, or billions of insect cameras, or...
09:05:41 <Crusty84> Can anybody tell me the purpose of the # sign in a type declaration. For example; data ThreadId = ThreadId ThreadId# deriving( Typeable )
09:05:59 <Baughn> Crusty84: # is an illegal character. :3
09:06:15 <Baughn> Thus, it's typically used for internal types you should avoid touching
09:06:32 <ilid> Crusty84: it's a GHC extension, which signifies the type is Deep Magic :)
09:06:34 <Baughn> You have to turn on an extension to even be able to name it. Basically, it's a "danger ahead!" sign
09:06:51 <PeakerWork> pozic: out of billions of people, you're bound to have some nut-cases in any case
09:07:17 <Baughn> pozic: It's impossible to make nanotechnology completely safe. It's also impossible to prevent it, and we wouldn't want to anyway.
09:07:22 <Baughn> So we need to make it /as safe as possible/.
09:07:26 <pozic> PeakerWork: right, which is why I argue for no restrictions on these kinds of things. The chance of one guy killing everyone seems quite small.
09:07:52 <Baughn> pozic: There are much simpler dangers
09:08:02 <Baughn> Think of /mistakes/
09:08:15 <EvilMachine> Hey all! Im wondering about existential types: Why does Haskell complain about the missing a on the right side, when I define data T = C a => T a without the forall a.? I mean doesnn C a already tell it, what a is?
09:08:25 <Crusty84> Ahh ok, cause I was looking into finalizers of Haskell, and there the same sign comes into the type definition. I thought, why are there finalizers only for weak memory pointers, MVars and ForeinPtrs. Why can't I create a finalizers for my own object. So if the object is removed. A message is shown
09:08:27 <Baughn> Like, making a nanocomputer-based laptop that just happens to come out of the fabber covered in nanodust, which gives you cancer
09:08:33 <Baughn> ..that sort of thing
09:08:37 <mauke> EvilMachine: no
09:08:47 <mauke> EvilMachine: a is simply an undeclared variable there
09:08:51 <pozic> Baughn: by the time we can do that, cancer will be long cured.
09:08:59 <PeakerWork> EvilMachine: "C a" puts a restriction on what "a" can be, but it doesn't tell what a is
09:09:08 <Baughn> pozic: I'd estimate ~2020-2025, so I doubt that.
09:09:27 <pozic> Baughn: have you seen That's impossible and then the Eternal life episode?
09:09:34 <Baughn> pozic: No.
09:09:48 <pozic> Baughn: they cured some kind of cancer in rats.
09:09:52 <pozic> Baughn: or mice
09:09:52 <pozic> same thing ;)
09:10:05 <EvilMachine> mauke: Why doesnt that suffice? After all its enough for function types like f :: C a => a.
09:10:08 <pozic> Baughn: using nano-bots
09:10:09 <Baughn> pozic: Trust me, they wouldn't be able to cure it if the mouse had been pumped full of carcinogens.
09:10:36 <pozic> I didn't know we already had working nano-bots.
09:10:40 <Baughn> pozic: Anyway, the cancer was just an example. Nanotubes are not fundamentally different from asbestos in its effect on the lungs..
09:10:55 <Baughn> We don't, exactly, but we do have caner-fighting /micro/bots
09:10:59 <mauke> EvilMachine: type declarations simply don't work that way
09:11:00 <Baughn> An extension of MEMS.
09:11:03 <PeakerWork> EvilMachine: for data constructors, you don't want to get existential types implicitly
09:11:26 <Baughn> pozic: ..they're still small enough to fit in a blood vessel. It's just that nanobots would be small enough to fit between cells. Also, let's go to #haskell-blah.
09:11:28 <quicksilver> EvilMachine: it's just a syntax thing.
09:11:29 <EvilMachine> mauke: Thats not much of an explanaiton is it? ^^
09:11:34 <EvilMachine> +i
09:11:40 <quicksilver> EvilMachine: if you use the GADT extension, you can write it this way:
09:12:03 <quicksilver> data T where T :: C a => a -> T a
09:12:19 <quicksilver> which is the same as the function notation.
09:13:18 <PeakerWork> quicksilver: don't you need to specify that T is *->* or use "a" there?
09:13:27 <quicksilver> typo
09:13:29 <quicksilver> data T where T :: C a => a -> T
09:13:32 <quicksilver> is what I meant :)
09:13:36 <EvilMachine> quicksilver: ah. ok. because the forall a. to me looks like something that is an obvious given in data T = C a => T a. I wonder if there is some other meaning that it could mean without the forall, so that the GHC people decided to do it this way. :)
09:13:46 <PeakerWork> quicksilver: and you get an existential without mentioning "forall" anywhere?
09:13:51 <quicksilver> PeakerWork: yes.
09:13:52 <EvilMachine> btw: what is GADT?
09:13:59 <PeakerWork> quicksilver: dangerous ;-)
09:14:02 <mauke> Generalized ADT
09:14:03 <quicksilver> EvilMachine: just one of those weird evolved syntax things
09:14:06 <PeakerWork> quicksilver: well, might confuse people
09:14:13 <quicksilver> I don't think there is a deep reason for it.
09:14:32 <quicksilver> "data T = C a => T a" is illegal haskell 98, AFAIK
09:14:54 <quicksilver> so they could have used that syntax for existentials
09:14:54 <quicksilver> I don't know why they chose to require the forall
09:15:04 <PeakerWork> iirc: it didn't have Rank2/RankN/existentials, so yeah
09:15:51 <hackagebot> hmk 0.9.3 - A make alternative based on Plan9's mk. (MathieuBoespflug)
09:16:38 <EvilMachine> PeakerWork: I *love* dangerous tools, that give you freedom, and dont limit you by expecting that youre not able to use them properly. ^^ Thats why I fight the horrors of reading the whole Haskell report and the extensions.
09:17:53 <PeakerWork> EvilMachine: freedom of one thing is the restriction of another..
09:17:56 <EvilMachine> quicksilver: thank you for that explanaiton. at least now I know that its just evolved that way. :)
09:18:21 <EvilMachine> PeakerWork: i disagree. care to prove it? ^^
09:18:47 <quicksilver> EvilMachine: when people are trying out an exciting new language feature they are more interested in how it works than choosing a good syntax
09:18:51 <EvilMachine> PeakerWork: its only true if those two things use (at least partially) the same space
09:18:51 <mauke> free the variables!
09:18:56 <hackagebot> hmk 0.9.4 - A make alternative based on Plan9's mk. (MathieuBoespflug)
09:18:56 <quicksilver> so, sometimes we get nasty syntaxes evolving
09:19:03 <EvilMachine> quicksilver: *gg* i agree
09:20:41 <EvilMachine> mauke: Do not try and use the variables. That's impossible. Instead... only try to realize the truth.
09:21:12 <mauke> CANDY FOR BREAKFAST
09:21:14 <Baughn> There are no variables.
09:21:17 <EvilMachine> mauke: There are no variables.
09:21:19 <EvilMachine> exactly
09:21:20 <EvilMachine> :D
09:21:29 <Baughn> Instead, we have bindings, parameters and values. :3
09:21:32 <PeakerWork> EvilMachine: when you allow existentials, you restrict other code that interacts with those existentials, for example, because while one piece of code is free to choose whatever type, another piece is no longer free to choose it, and needs to be polymorphic/restricted
09:21:38 <pumpkin> There are no variables, only The Monoid
09:21:43 <mauke> SKKSKSKKKKSSSKS
09:21:50 <EvilMachine> Baughn: you should have waited for mauke so say what truth :D
09:21:50 <pumpkin> http://www.reddit.com/r/programming/comments/9r775/ask_proggit_what_do_you_think_of_when_you_think/c0e5myb
09:21:51 <Baughn> There are no monoids, only Zuul
09:22:07 <Baughn> EvilMachine: I did. Then he said "candy for breakfast".
09:22:13 <PeakerWork> EvilMachine: restricting side effects allows more freedom in analysis
09:22:26 <pumpkin> "With a concatenative language the only construct is the monoid, and structuring a language with this in mind makes all types optional"
09:22:28 <quicksilver> pumpkin: shirley you mean 'there are no types, only the monoid'
09:22:48 <EvilMachine> PeakerWork: how so? what would be restricted?
09:22:51 <cads> Hey, if I write a function like "F:: Set B  B  P(P(B)): X  {Y  P(X)  |Y|  |X|/2}" I'm basically saying "F(X) is the largest collection of subsets of X such that each subset Y in F(X), the size of Y is no more than half the size of X"
09:23:08 <cads> for each subset*
09:23:09 <EvilMachine> Baughn: ok
09:23:21 <cads> what i'm wondering is, what is F?
09:23:33 <cads> is it a function?
09:23:47 <sproingie> pumpkin: comes as news to slava i'm sure, who has a plethora of types in his language
09:24:01 <pumpkin> sproingie: little does he know that all he has is The Monoid :)
09:24:06 <cads> its target set seems to be dependent on its argument
09:24:08 <PeakerWork> EvilMachine: ability to modify values restricted -> freedom to assume more things about values
09:24:33 <sproingie> hell i'm not sure how a monoid even applies at all.  the response puts words next to each other, but they don't seem to form any meaning
09:24:56 <pumpkin> sproingie: yeah, I chuckled when I read it, but honestly I can't make any sense of that reply at all
09:25:18 <sproingie> monoid to me says "commutative, associative, and identity", and that's about all i know about monoid
09:25:25 <pumpkin> yeah
09:25:30 <sproingie> and the first two don't even seem to fit in concatenative
09:25:32 <EvilMachine> PeakerWork: there are no side effects. :) if you see the code as a whole, its a set of data streams between transforming functions. there, side effects are mere functions with more than one output stream. like (x', sideEffect) = f x
09:25:33 <EvilMachine> :D
09:25:47 <pumpkin> @remember neuraxon77 With a concatenative language the only construct is the monoid, and structuring a language with this in mind makes all types optional
09:25:48 <lambdabot> I will never forget.
09:25:51 <pumpkin> there we go
09:25:56 <pumpkin> future generations can ponder the meaning of that
09:26:21 <PeakerWork> EvilMachine: well, if you get rid of that tuple's second element, you restrict the code, but make its analysis simpler (which frees the analyzer to do more things)
09:26:30 <jmcarthur_work> we put so much emphasis on inferring types from our functions...
09:26:40 <jmcarthur_work> i would rather infer our functions from our types!
09:26:50 <PeakerWork> EvilMachine: if you restrict your language to always halt, you lose turing completeness, but you gain freedom to do equational reasoning
09:26:53 <quicksilver> that's what @djinn is for, jmcarthur_work
09:26:59 <PeakerWork> jmcarthur_work: Epigram?
09:27:11 <sproingie> someone needs to work djinn into emacs haskell-mode
09:27:15 <jmcarthur_work> quicksilver, djinn only does a subset of what i wish we had. there are other things too, but we aren't there yet :(
09:27:27 <pumpkin> I want djinn to be able to figure out fix for me!
09:27:30 <pumpkin> :)
09:27:30 <jmcarthur_work> PeakerWork, epigram is just type-guided programming, isn't it?
09:27:42 <quicksilver> if we were there, you'd be dreaming of somewhere else, jmcarthur_work
09:27:43 <EvilMachine> PeakerWork: hmm i still dont get, where existential types restrict the ability to modify values. after all, you would not be able to modify them in the first place, without knowing anything about their varying types (eg when in a list)
09:27:43 <sproingie> hell i'd be happy to see hoogle get haskelldoc integration
09:27:46 <PeakerWork> jmcarthur_work: its supposed to write the code based on the types, from what I read
09:27:52 <quicksilver> you're all the same, you programming idealists
09:27:59 <pumpkin> damn right
09:28:04 <jmcarthur_work> hell yeah
09:28:11 <pumpkin> the type system is always greener
09:28:15 <jmcarthur_work> PeakerWork, it's an interactive system, i think
09:28:35 <PeakerWork> jmcarthur_work: And that, I think is very good
09:28:39 <cads> quicksilver: some of us just want a language that'll understand any math notation we throw at it :)
09:28:40 * jmcarthur_work keeps misreading EvilMachine as EvilTerran
09:29:04 <jmcarthur_work> PeakerWork, conversely, would interactive type inference be good? it's an interesting idea, actually
09:29:05 <EvilMachine> PeakerWork: you restrict the code? i think we should talk this over with a beer or something, because I dont get it at all. ^^
09:30:36 <PeakerWork> EvilMachine: if a function can be used with any type, its restricted to use only operations common to all types. If it is free to use more operations, its caller becomes more restricted with the types he can give.. following?
09:30:37 <EvilMachine> PeakerWork: ok, i agree on the always halting restriction. but i wonder what of it still has much to do with the forall construct. :D
09:31:01 <Berengal> Interactive type inference might be nifty. In Haskell today the compiler sometimes just can't infer a type for you, so you have to infer it yourself, but you don't get any help doing so
09:31:02 <PeakerWork> EvilMachine: It doesn't have much to do with it, I merely tried to explain why "more freedom" is not always necessarily good, and often implies something else gets restricted when you add freedom
09:31:18 <jmcarthur_work> Berengal, exactly what i'm thinking
09:32:23 <quicksilver> Berengal: and it's a nightmare if you use a really complex set of type classes, like the session types stuff
09:32:31 <EvilMachine> cads: since when does a human understand any math notation we throw at it? ^^
09:32:33 <quicksilver> which is why such things seldom get used outside of PhD theses
09:32:52 <Berengal> quicksilver, indeed. This is the biggest reason I gave up on takusen and wrote a yaml parser instead
09:33:06 <EvilMachine> PeakerWork: yes, following. :)
09:34:12 <Berengal> Also, sometimes, when I'm in a scripting mood, I program without regard for types at all. I rely on the compiler to yell at me if I get it wrong, but it'd be nice if it also suggested improvements.
09:35:14 <Berengal> "Couldn't match expected type `[a]' against inferred type `Set a'. Which type did you want the expression `foo bar' to have?"
09:35:37 <EvilMachine> PeakerWork: i agree, that in your example, there is no more freedom. an freedom seems to be a resource that isnt infinite. and so someone has to decide what gets it. which makes sense. although you could of course say, that that freedom to choose where the freedom goes, is in itself an addition to your freedom. but i fear if we continue this road of thought, my head might explode. :P
09:36:09 <PeakerWork> EvilMachine: :-)
09:36:20 <qwr> Berengal: this could be cool idea for someone creating a haskell ide ;)
09:36:25 <PeakerWork> EvilMachine: I follow you, and indeed, even adding that freedom takes away freedom from Haskell compiler writers :)
09:36:51 <PeakerWork> EvilMachine: who have to cope with more complexity in the type system, which perhaps prohibits other features from being tractable
09:36:52 <cads> EvilMachine: In soviet russia, you know, math notation comprehends you :)
09:36:59 * pumpkin facepalms
09:37:20 <quicksilver> Berengal: it's quite difficult because haskell type inference isn't directed
09:37:22 <seanmcl> Why is the following program killing my memory?  It should loop, indeed, but the memory requirements should be tiny:
09:37:27 <seanmcl> index n i (x:xs) = if x == n then i else index n (i+1) xs
09:37:27 <seanmcl> main = putStrLn $ show $ index 0 0 [1..]
09:37:42 <quicksilver> Berengal: it doesn't necessarily start from the smallest components of expressions and work up, nor does it necessarily start from the largest and work down
09:37:49 <seanmcl> It is blatantly tail recursive
09:37:56 <quicksilver> Berengal: (and in fact, of course, it's recursive)
09:38:02 <EvilMachine> PeakerWork: LOL. Good point!
09:38:21 <Baughn> seanmcl: Let me guess, stack overflow?
09:38:25 <jmcarthur_work> seanmcl, in the presence of laziness, tail recursion doesn't necessarily mean very much
09:38:37 <Berengal> quicksilver, no, but it might help in locating a type error in some polymorphic construct that makes ghc point in the wrong places
09:38:40 <seanmcl> Baughn: no, just eats  2GB in about 5 seconds
09:38:50 <quicksilver> Berengal: I'm just saying it's hard to design the assistant
09:38:53 <quicksilver> Berengal: (not impossible)
09:38:54 <jmcarthur_work> well, it does actually, but it looks different from in a strict language
09:39:13 <quicksilver> seanmcl: huge thunk in the "i" parameter
09:39:20 <EvilMachine> PeakerWork: but i dare to add a dimension to even that: add a compiler flag, which lets the compiler writer do both, and the code writer too. (ok youve done it! now my brains are spread on the ceiling! :P)
09:39:26 <Berengal> quicksilver, for example, if I can't find the error in 30 seconds by looking at the place where the error is, I insert it's type. Often a type error will show up somewhere else, usually in the place where I made the mistake
09:39:32 <quicksilver> seanmcl: force the "i" parameter using seq or a strictness annotation
09:39:40 <Baughn> seanmcl: Ah. n. n never changes.
09:39:41 <seanmcl> quicksilver: in i!!
09:39:50 <cads> EvilMachine: I think you know what I mean though; another mathematician is able to read a math paper and "compile" what he reads into something that either gives him confidence a proposition is true, or tells him it's false
09:39:53 <quicksilver> seanmcl: yes, each iteration builds a new (+) thunk
09:40:01 <seanmcl> oh damn
09:40:07 <Baughn> seanmcl: Every time your function recurses, haskell adds another thunk wrapping i - it goes (i+1)+1)+1+1)...
09:40:18 <Baughn> seanmcl: And of course, it's infinite recursion
09:40:24 <quicksilver>  index n i (x:xs) = i `seq` if x == n then i else index n (i+1) xs
09:40:25 <EvilMachine> cads: so you say they had an artificial intelligence based on math notation running? you only wish! :P
09:40:27 <quicksilver> this should fix it
09:40:28 <pumpkin> (and thunks go on the heap)
09:40:29 <Baughn> If you made n finite but large, it'd crash with a stack overflow instead
09:40:33 <jmcarthur_work> seanmcl, ironically, this is exactly the same problem you have with a function that is not tail recursive! ;)
09:40:39 <seanmcl> :)
09:40:44 <pumpkin> or enable bang patterns, and just make it index n !i (x:xs)
09:41:00 <Baughn> Or use $!
09:41:04 <cads> heh, if you excuse that bit of programming language analogy.. I don't think the process of comprehending math is that simple
09:41:25 <Baughn> seanmcl: Oh, and compiling with -O2 might "fix" this bug without you doing anything whatsoever
09:41:44 <jmcarthur_work> yeah strictness analysis is seen by some as magic
09:41:50 <quicksilver> don't think it will, no
09:41:54 <pumpkin> not by jmcarthur_work though
09:41:55 <quicksilver> index is *not* strict in 'i'
09:42:02 <seanmcl> Baughn: yep
09:42:09 <quicksilver> so the strictness analyser will not say it is :)
09:42:10 <seanmcl> it's hovering at 20 MB now
09:42:16 <pumpkin> yeah, the current one could be using lazy Naturals
09:42:19 <Baughn> quicksilver: True, since it's bottom instead..
09:42:29 <quicksilver> or hang on
09:42:38 <quicksilver> actually, it is strict in i
09:42:47 <quicksilver> index n _|_ xs = _|_ for all possible n,xs
09:43:01 <quicksilver> so, yeah, possibly the strictness analyser would have caught that.
09:43:04 <cads> EvilMachine: you have to admit there's some strong language processing going on in the mathematician's brain :)
09:43:16 <jmcarthur_work> quicksilver, not if + is lazy
09:43:44 <pumpkin> I don't think it would work with lazy naturals actually
09:43:55 <pumpkin> because the if is getting in the way
09:43:56 <EvilMachine> cads: well, give me a big enough neural net, and I will make it comperehend math. :P
09:44:00 <Berengal> Even lazy naturals have a (+) strict in the first argument
09:44:07 <PeakerWork> jmcarthur_work: even then
09:44:16 <Berengal> > 5 < foldl (+) 0 [1..1000000]
09:44:17 <lambdabot>   * Exception: stack overflow
09:44:23 <Berengal> > 5 < foldl (flip (+)) 0 [1..1000000]
09:44:24 <lambdabot>   * Exception: stack overflow
09:44:29 <pumpkin> (5 :: Natural)
09:44:31 <PeakerWork> jmcarthur_work: because index eventually returns i or _|_ in any case. so if i is _|_ it can only return _|_
09:44:31 <Berengal> > (5 :: Natural) < foldl (flip (+)) 0 [1..1000000]
09:44:33 <lambdabot>   True
09:44:39 <Berengal> > (5 :: Natural) < foldl (+) 0 [1..1000000]
09:44:40 <jmcarthur_work> Berengal, the strictness analysis doesn't apply for lambdabot, i think
09:44:41 <lambdabot>   * Exception: stack overflow
09:44:42 <Berengal> There we go
09:44:53 <PeakerWork> jmcarthur_work: oh, sorry, its a different i in recursive calls
09:45:03 <jmcarthur_work> PeakerWork, yeah
09:45:19 <Berengal> jmcarthur, I'm pretty sure it doesn't, but in the case of lazy naturals, it's mostly that (+) isn't lazy enough that's the problem
09:46:31 <ystael> @src (+) :: Natural -> Natural -> Natural
09:46:31 <lambdabot> Source not found. You speak an infinite deal of nothing
09:46:37 <pumpkin> we need lazy naturals to use unamb
09:47:01 <pumpkin> not sure how that would work
09:47:19 <pumpkin> oh I guess just (x + y) `unamb` (y + x)
09:47:21 <jmcarthur_work> (a + b) `unamb` (b + a)
09:47:28 <Berengal> a + b = (natPlus a b) `unamb` (natplus b a)
09:47:37 <PeakerWork> @type unamb
09:47:39 <lambdabot> Not in scope: `unamb'
09:47:48 <Berengal> Where natPlus is the primitive addition function for naturals
09:48:01 <EvilMachine> hey, i wonder why ghc-generated executables always are so huge? i mean, i write a little single-file test code of a couple of lines, and it throws a binary of over a megabyte at me. why not just some 100 bytes or so?
09:48:02 <PeakerWork> @let fakeUnamb x y = if True then x else y
09:48:03 <lambdabot>  Defined.
09:48:06 <PeakerWork> @type fakeUnamb
09:48:08 <lambdabot> forall t. t -> t -> t
09:48:09 <pumpkin> EvilMachine: static linkage
09:48:24 <pumpkin> PeakerWork: that's profound
09:48:31 <PeakerWork> @type \binop x y -> (x `binop` y) `unamb` (y `binop` x)
09:48:32 <lambdabot> Not in scope: `unamb'
09:48:38 <PeakerWork> @type \binop x y -> (x `binop` y) `fakeUnamb` (y `binop` x)
09:48:39 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t -> t1
09:48:42 <EvilMachine> pumpkin: oh. ghc links everything static by default? can i switch that off? should I?
09:48:47 <jmcarthur_work> > fakeUnamb undefined 5
09:48:48 <Baughn> EvilMachine: There's no dynamic linking, and the RTS itself is pretty large
09:48:49 <lambdabot>   * Exception: Prelude.undefined
09:48:51 <jmcarthur_work> fail
09:48:55 <jmcarthur_work> :P
09:49:04 <jmcarthur_work> (i know you just wanted the type)
09:49:06 <Baughn> EvilMachine: ..however, this changes for 6.12, so just wait.. um, a few hours, apparently. RC should be out soonishly.
09:49:07 <pumpkin> EvilMachine: in 6.12 you'll be able to turn it off
09:49:13 <seanmcl> all: thanks for the help
09:49:17 <PeakerWork> @let commutative binop x y = (x `binop` y) `fakeUnamb` (y `binop` x)
09:49:18 <lambdabot>  Defined.
09:49:31 <PeakerWork> jmcarthur_work: I was careful not to actually name it 'unamb' :)
09:49:34 <EvilMachine> Baughn: lol. what a timing
09:49:34 <Berengal> What, RC out in just a few hours?
09:49:37 <PeakerWork> @type commutative
09:49:38 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t -> t1
09:49:52 <Baughn> Berengal: Yes, they're building it now
09:49:54 <PeakerWork> now you can commutative all your functions to be lazy in both arguments
09:49:59 <Berengal> Nice
09:50:13 <PeakerWork> @type commutative (+)
09:50:14 <lambdabot> forall t. (Num t) => t -> t -> t
09:50:31 <Baughn> PeakerWork: ..however, anything using unamb /freaks me out/. ^^;
09:50:36 <EvilMachine> Baughn: lool. funny how you implicitly stated, that building GHC takes a few hours. (which i know from own experience. it also takes gigabytes of ram)
09:50:46 <PeakerWork> Baughn: exponential threading? :)
09:50:51 <Baughn> EvilMachine: Takes about forty minutes for me. :P
09:50:53 <Baughn> PeakerWork: Quite
09:50:54 <Berengal> PeakerWork, lazy in either argument, not both
09:51:04 <PeakerWork> Berengal: yeah
09:51:07 <Baughn> EvilMachine: However, release engineering is more than just building the thing
09:51:14 <EvilMachine> Baughn: yeah well, for me too if I get your computer. :P
09:51:29 <EvilMachine> Baughn: true
09:52:32 <EvilMachine> Baughn: because else, they could just shove the source on the server and let me install it right away. (i compile my own binary anyway)
09:52:50 <Baughn> EvilMachine: Oh, you can do /that/ anyway. Just grab a snapshot.
09:53:09 <Baughn> EvilMachine: But it isn't all that useful, since lots of packages must be updated to fit. cabal-install, unix, network, haskell-src...
09:53:38 <MyCatVerbs> Baughn: what is release engineering? Isn't it just packaging up the sources (with pregenerated configure script and a few other bits and pieces) then testing to see that you can build and run the binaries from them - and also packing up the binaries that you build in the process?
09:53:47 <EvilMachine> Baughn: true. but i dont want to compile the updated snapshot tomorrow too. ^^ so i usually dont install snapshots but releases.
09:54:09 <Berengal> Hmmm... this is perhaps a good excuse to go look for all the previous installations of ghc I've got...
09:54:16 <Berengal> And remove them
09:54:20 <MyCatVerbs> I mean, there's nowt in there aside from building it, testing it and then triaging bugs. :)
09:54:26 <EvilMachine> Baughn: hmm ill wait for the updated ebuild (Gentoo package description). then it does all that for me.
09:54:33 <MyCatVerbs> Or please correct me if I'm wrong there.
09:54:43 <Berengal> I think I've four copies of half of hackage...
09:54:47 <Baughn> MyCatVerbs: UPdating the website, testing against other packages, writing release notes, etc. Everything.
09:54:52 <EvilMachine> MyCatVerbs: And updating the site, saying that now its out! ^^
09:55:02 <Baughn> It tends to be a much bigger deal in companies, for bureaucratic reasons. :P
09:55:26 <EvilMachine> Berengal: you mean like emerge -atv --depclean? :)
09:55:44 <Berengal> EvilMachine, I mean like "I should install arch again this weekend"
09:55:57 <EvilMachine> Berengal: lol. ok.
09:56:55 <EvilMachine> Baughn: oh, and documentation the ugly parts that one likes to forget. ^^
09:57:42 <Baughn> EvilMachine: Ideally, the documentation is updated along with the code patches
09:58:09 <EvilMachine> Baughn: *Ideally* :D
09:59:10 <MyCatVerbs> I don't think there ought to be any "Ideally" about it.
09:59:25 <MyCatVerbs> If you update the documentation long after writing the patches then you're going to forget all the details.
10:00:16 <Berengal> MyCatVerbs, and set yourself up for hours and hours of fun logic puzzles. Much better than sudoku
10:00:56 <EvilMachine> By the way: May I say, that I *love* the Haskell community and Haskell? I literally was designing a Haskell-like language when I found, that it had be done, and done better. The amount of innovation and intelligent here is incredible. I mean you literally see other language communities imitating the basic things of Haskell, while you here are wayy ahead, like another level of thought.
10:01:44 <EvilMachine> MyCatVerbs: 100% agreed.
10:02:11 <EvilMachine> lool
10:02:41 <EvilMachine> See how I made a typo right there in the word intelligence?  /FAIL
10:02:49 <EvilMachine> but you know what i meant
10:03:18 * EvilMachine is soo intelligence. ;)
10:03:19 <Athas> EvilMachine: I agree!  It's a great community.  I hope I can contribute and not be a drain on it.
10:03:22 <Berengal> EvilMachine, I wouldn't if you hadn't pointed it out
10:03:35 <EvilMachine> Baughn: :D
10:04:30 <EvilMachine> Hey, is there by any chance a Haskell IDE in the process of being developed? Because I would have to add some big ideas to it.
10:04:49 <Berengal> EvilMachine, yi and leksah
10:04:49 * EvilMachine is a bit of an interface designer freak. :)
10:05:18 <Athas> I also heard about a plan to write an IDE "backend" that would talk to Emacs.
10:05:25 <Athas> That sounded more interesting than anything else IMO.
10:06:03 <Berengal> yi is already a bit like emacs, but with haskell instead of elisp
10:06:55 <EvilMachine> about yi: uum, I meant something graphical. Not with the mouse, but with al the power of graphics put to real use.
10:06:57 <Athas> Yeah, but I seriously doubt it'll ever match Emacs.
10:07:29 <Athas> Having tried to reimplement Emacs myself, it's... really hard.  Emacs is very big.
10:07:44 <Berengal> EvilMachine, oh, you're one of those people...
10:07:54 <EvilMachine> I dont think its a good idea to imitate Emacs. Because Emacs (while to some being the editor of their choice), follows the inner platform antipattern. :)
10:07:57 <seanmcl> does anyone use yi?
10:08:08 <seanmcl> any reviews out there?
10:08:22 <Berengal> Athas, give it 30 years. If both are still around, we'll probably have better grounds for comparison. As it stands now, I use yi for all my haskell development, and emacs for other things
10:08:41 <Athas> Well, the idea of writing an IDE backend would be that you could tie it to any specific editor you wanted, yet develop the actual logic in a central place.
10:08:51 <Athas> Most editors can talk to subprocesses.
10:08:52 <EvilMachine> Emacs actually should be a thing that you choose in your bootloader, because its more an OS than just an editor. (dont worry, im not really judging here.)
10:09:19 <Athas> EvilMachine: well, you need stuff like Xorg to get proper fonts.
10:09:52 <Athas> And yes, Emacs is like a very bad Lisp machine.
10:09:52 <EvilMachine> Athas: i wonder why software isnt generally written with a separate backend. its so much nicer and cleaner.
10:09:52 <Berengal> There was some talk of integrating yi in leksah. Don't know what happened to that, but I think they at least got it somewhat working
10:10:16 <Athas> EvilMachine: you have to develop a communication protocol, so you have to think a little more.
10:10:21 <sproingie> EvilMachine: for an antipattern, it sure seems to have staying power that "designed" stuff doesn't
10:10:27 <EvilMachine> Athas: Des. Id write my programming IDEs GUI in OpenGL. :D
10:11:46 <EvilMachine> Athas: you have to develop an interface between the model and the view/controller anyway. just wrap both ends in a transparent default serializer, and youre good. :)
10:12:09 <Athas> That's... really a very simplistic way of looking at it.
10:12:15 <sproingie> emacs lisp is based on maclisp, which was in fact the ancestor of zetalisp, the dialect spoken by lisp machines
10:12:32 <Athas> sproingie: yes, but Emacs Lisp is like the retarded cousin.  Or the weird aunt who's still stuck in the late 70s.
10:12:48 <sproingie> it's more like the savant cousin
10:12:51 <EvilMachine> sproingie: i dont think staying power is any means to prove quality of a design concept. By that view, MS Office is also pretty well designed. ^^
10:12:52 <Berengal> Lisp isn't a language. It's a syntax
10:13:08 <sproingie> EvilMachine: i didn't say it was well designed, i said it gets the job done
10:13:20 <sproingie> as opposed to fapping over what's proper
10:13:49 <sproingie> it's an editor, not a missile control system
10:14:03 <sproingie> .oO(M-x launch-icbm-mode)
10:14:04 <maltem> What can be the reason, roughly, when a function compiles with the type sig commented out, but not with a type sig pasted from ghci?
10:14:24 <Berengal> maltem, imports
10:14:32 <Berengal> For example
10:14:41 <EvilMachine> Athas: No actually its not. Ive done this. And in Java such stuff its pretty much standardized. You can put a network interface in between two communicating modules of your program in literally half an hour of mostly generating the interfaces, and configuring things a bit.
10:14:53 <Berengal> Or other things... sometimes you just aren't allowed to write the correct type signature
10:14:56 <sproingie> yi would be nice if i could get it to build.  guess i'll stick with a binary
10:15:37 <maltem> Berengal, imports? I don't import anything in ghci except this module, if you mean that
10:15:47 <maltem> and what can be the other things?
10:16:03 <Berengal> maltem, what's the module you import?
10:16:03 <Berengal> sorry, the type
10:16:03 <Berengal> inferred by ghc
10:16:03 <Berengal> i
10:16:12 * Berengal has had too much coffee, and it's starting to wear off
10:16:51 <nomeata> Hi. My haskell program SEGVs in a ffi call (to Xlibs XFree, to be precise), but not very reproducible yet. Any hints how to debug this?
10:16:55 <EvilMachine> sproingie: lol. i never disagreed about emacs getting things done. i just thing that still, its a good idea to design software well. which means avoiding re-implementing a lower interface/language badly instead of directly using it. :)
10:17:01 <_zenon_> Berengal: quick! Hurry, get more!
10:17:15 <sproingie> emacs in fact was designed around a separate front and back end
10:17:29 <sproingie> at least multics emacs was, which is the one that gave us lisp programmability
10:17:33 <Berengal> _zenon_, heh, last night I spent three hours trying to sleep because I was overcaffeinated. Trying to tone it down a bit today
10:17:34 <EvilMachine> sproingie: sure Emacs is not a missile control system? I bet the code is in there. :D
10:17:41 <maltem> Berengal, I've tried to blindly load more extensions, but that didn't change anything
10:17:54 <Berengal> maltem, what's the type and the expression?
10:18:05 <sproingie> emacs's buffer implementation is the ancestor of the zipper
10:18:21 <Athas> Modern GNU Emacs is designed around everything.
10:18:31 <Athas> The Emacs 23 release has a daemon ("backend") mode.
10:18:48 <sproingie> i wouldn't mind if they updated the elisp language a bit tho
10:18:56 <Berengal> <3 emacs daemon
10:19:04 <Athas> They can't really break compatibility, unfortunately.
10:19:09 <_zenon_> Berengal: Well, that doesn't sound to good for you. (to tone it down :p )
10:19:22 <Berengal> sproingie, I'm not sure how much of emacs would remain if they did that...
10:19:51 <maltem> Berengal, I'm a little hesitant to paste it because the code is so stupid :) First thing to note, it involves a multi-param type class, and I can eliminate the problem by adding a FD to that class
10:20:10 <sproingie> emacs does minor compatibility breakage every major revision, so it's not that severe.  i'm thinking more additive than subtractive.
10:20:23 <Berengal> maltem, it's a bit hard to help if we can't even see the problem
10:20:26 <sproingie> i'm not saying switch it to scheme or anything like that
10:20:43 <maltem> Berengal, I'll try to paste something meaningful
10:21:31 <EvilMachine> I thing every software evolves to a point, where the best thing to do is, to do a complete rewrite from scratch. that way you can design it with all new additions properly integrated instead of patched on. of course as this takes very long, one would still use the old program until the new one has 100% of the old functions and starts to surpass it.
10:21:36 <EvilMachine> g=k
10:22:09 <Athas> Emacs is the counterproof, it works extremely well all things considered.
10:22:35 <Berengal> sproingie, in general I don't like adding to a language unless it offers significant advantages. Lisp has an advantage in that additions usually don't involve keywords or new syntax, but it still complicates matters
10:22:47 <sproingie> ditch lisp and it ain't emacs
10:22:48 <_zenon_> Oleg would implement Emacs in a type system, bet ya that
10:22:58 <Berengal> EvilMachine, worked well for netscape...
10:23:04 <sproingie> much as i like haskell i don't give yi long odds on displacing emacs
10:23:15 <EvilMachine> maltem: how will you learn then? theres no such thing as stupid questions or code, when the goal is, to learn how its done better.
10:23:26 <sproingie> Berengal: that's because netscape navigator was a piece of garbage and there weren't many compelling alternatives
10:23:54 <Berengal> sproingie, that was sarcasm...
10:24:09 <sproingie> Berengal: some people have made that argument seriously
10:24:16 <sproingie> "it took a while but look, it's so much better now"
10:24:33 <Berengal> That's true, but it's not netscape anymore
10:24:59 <EvilMachine> Athas: well, then apparently, it was designed extremely well. perhaps its because the inner platform offers a big and proper enough abstraction so that you can literally change big things inside, without affecting it as a whole.
10:25:15 <Berengal> My version of the story is basically "they deleted all their source code, lost all their market and money and became hippies"
10:25:17 <sproingie> emacs's main problems in evolving is its ui conventions
10:25:22 <EvilMachine> Athas: but that means that the programmers were really good :)
10:25:24 <Athas> EvilMachine: yes, it's because Emacs is a platform.  Nobody cares about Emacs, they care about the stuff that runs in it.
10:25:30 <maltem> EvilMachine, yeah, hold on guys
10:25:36 <sproingie> who here actually likes the buffer switch mechanism of C-x C-b and doesn't override it with something else?
10:25:37 <EvilMachine> Athas: well said
10:25:37 <EvilMachine> ok
10:26:38 <_zenon_> sproingie: I use it
10:26:52 <sproingie> i do when i haven't gotten around to overriding it
10:27:07 <EvilMachine> Berengal: actually, Firefox is not that great for a redesign. ^^ People already complain much about its inner design. But the next generation will come
10:27:13 <sproingie> "split the window, make you change to it manually, then keep it split when you select"
10:27:13 <_zenon_> sproingie: And what about emacs add on plugin ability?
10:27:17 <sproingie> yeah, great design
10:27:20 * EvilMachine now comes back on topic and wants to stay there. :D
10:27:33 <sproingie> _zenon_: can't be beat
10:27:45 <sproingie> <3 emacs, just not some of its out-of-the-box behaviors
10:27:51 <_zenon_> If you can't plug it into Emacs, it's not worth using.
10:28:03 <Berengal> EvilMachine, yeah, they kinda messed up firefox as well, which is sort of ironic when you think about their reasons for a rewrite. But then again, they were up against IE...
10:28:05 * sproingie tries to plug his gf into emacs
10:28:18 <_zenon_> :)
10:28:28 <_zenon_> http://www.cs.chalmers.se/~catarina/agda/commands.html
10:29:17 <Berengal> I found out eclipse has a emacs keybinding setup today... it's only half-working, but it still made my day
10:29:47 <EvilMachine> sproingie: i thought girlfriends and emacs were exclusive on this planet. ;)
10:30:13 <_zenon_> Berengal: Learned that ClearCase worked with emacs, IMMD
10:30:13 <EvilMachine> Baughn: many things have emacs keybinding setups. I think NetBeans too.
10:30:22 <EvilMachine> lool
10:30:27 <sproingie> EvilMachine: so i'm discovering
10:30:47 <sproingie> most compilers have an "emacs format" for their output
10:31:25 <sproingie> except of course for msvc
10:31:31 <EvilMachine> sproingie: arent all Haskell users explorers and discoverers in this world of C, Java and *ugg* PHP *yuck*.
10:31:49 <maltem> Berengal, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10551
10:32:03 <_zenon_> EvilMachine: You said the P word!
10:32:10 <EvilMachine> sproingie: but i bet emacs has a plugin to convert msvc output anyway. :P
10:32:36 <Athas> Emacs is an excellent ball of glue for tying all sorts of Unix programs together.  If pipes are the plumbing of Unix, then Emacs is the central water exchange.
10:32:51 <sproingie> the compiler mode has supported msvc's format for a while, yes
10:32:53 <_zenon_> All hail to Emacs
10:32:54 <_zenon_> <_<
10:32:56 <_zenon_> >_>
10:33:12 <EvilMachine> _zenon_: I knoooww! Im so sorry man! But Im still traumatized from nearly 4 years of having to exclusively use it at work.
10:33:16 <Athas> I'm kinda following the idea that all my programs must be easy to write an Emacs interface for... we'll see if that works out.
10:33:20 * EvilMachine bursts into tears
10:33:31 <sproingie> i'm pondering using emacs as the frontend for my roguelike
10:33:35 <_zenon_> EvilMachine: Let it out, just let it out.
10:33:42 <sproingie> i found it's already been done actually
10:33:50 <sproingie> but sadly it was ported away from emacs to CL
10:34:30 <EvilMachine> Athas: let me guess: another layer of universal inner platform? :D
10:34:34 * EvilMachine hides from Athas
10:34:48 <Athas> EvilMachine: I don't understand the question.
10:34:59 <earthy> hm. emacs. hohum.
10:35:02 <mmorrow> preflex: seen Saizan_
10:35:02 <preflex>  Saizan_ was last seen on #haskell 1 day, 13 hours, 4 minutes and 12 seconds ago, saying: add `seq` if you want foldl'
10:35:03 <EvilMachine> Athas: maybe its better that way
10:35:42 <mmorrow> preflex: seen Saizan
10:35:42 <preflex>  Saizan was last seen on #haskell 10 hours, 20 minutes and 51 seconds ago, saying: we need a <spoiler> tag
10:35:56 <Berengal> maltem, look closely at the error you get: Could not deduce (Embed p (ErrorT a m)) from the context (Embed p (ErrorT a1 m), [...]
10:36:51 <maltem> I did, and now?
10:36:59 <Berengal> They're different a's
10:37:27 <maltem> hmm... and how does ghci differentiate those?
10:37:58 <Berengal> I don't know. But the fact is, the type returned by the monad returned by run has absolutely no constraints on it
10:38:04 <Athas> This may be a long shot, but... does anyone here use Twelf?
10:38:10 <Berengal> So the only possible value is bottom
10:38:22 <Berengal> ghc might be able to make it typecheck, but it won't be able to make it run
10:38:30 <Berengal> (without an infinite loop or exception)
10:38:50 <maltem> That's how it should be, "Fail" is supposed to be analogous to "fail"
10:39:06 <maltem> and no, it needn't be bottom
10:39:30 <maltem> or wait
10:39:38 <Berengal> Yeah, you're right.
10:39:50 <EvilMachine> Im always confused by bottom. I mean I know what it is and what it means. (I think.) But how do you express it in Haskell? With (). No?
10:40:00 <Berengal> I think it's as it should be
10:40:03 <mauke> EvilMachine: undefined
10:40:09 <maltem> Berengal, I should better say, it will always be bottom, because I call fail :)
10:40:12 <sproingie> EvilMachine: a = a
10:40:12 <EvilMachine> mauke: ah. oh.
10:40:15 <mauke> () is very non-bottom
10:40:23 <sproingie> or yeah undefined
10:40:24 <Berengal> () is top
10:40:38 <sproingie> (_|_) looks like a bottom
10:40:43 <EvilMachine> mauke: and the _ in patterns? looks to me like that too.
10:40:51 <mauke> ()
10:40:56 <EvilMachine> sproingie: you need a bottom. :D
10:40:56 <maltem> Berengal, so any idea what the type checker is up to?
10:40:58 <mauke> _ is just a fresh variable
10:41:47 <Berengal> maltem, not in detail
10:42:03 <sproingie> huh undefined raises.  is it really bottom then?
10:42:13 <EvilMachine> mauke: hey, cool. how do you type  on your keyboard? and does ghc accept it? :D
10:42:26 <sproingie> all i get is a square
10:42:33 <mauke> I type `uni{up tack}
10:42:35 <Berengal> sproingie, it's bottom in everything but IO
10:42:36 <EvilMachine> sproingie: you miss the right font
10:42:50 <maltem> maybe something to ask on the ghc mailing list
10:42:53 <sproingie> deja sans mono here
10:43:12 <mauke> get more fonts
10:43:21 <sproingie> i like pretty fonts
10:43:37 <sproingie> i could use code2000 but ew
10:43:59 <mauke> use all of them
10:43:59 <maltem> EvilMachine, bottom is not something to have in a Haskell expression, so ghc does not "accept" it
10:44:18 <sproingie> when emacs does font substitution, sure
10:44:20 <mauke> > let  = undefined in ()
10:44:21 <lambdabot>   <no location info>: parse error on input `'
10:44:22 <EvilMachine> mauke: trying it: `uni'
10:44:40 <mauke> what
10:45:02 <maltem> hey it's confusing to define that
10:46:23 <EvilMachine> I love how I can enter all the mathematical symbols right and greek letters, etc right on my keyboard, and GHC accepts it just like that. just some characters are misdetected as beloning in the alphanumeric category, while really they are operators.
10:46:31 <maltem> then you have error "blah" ==== , but you don't have error "blah" == 
10:47:24 <EvilMachine> All on my num block:    :D
10:49:04 <EvilMachine> hey, I even have  and  on my keyboard. I NEED to define forall as
10:49:08 <mauke> 
10:49:09 <EvilMachine> 
10:49:22 <mauke> (that was `uni{snowman})
10:49:26 <EvilMachine> loool
10:50:46 <Athas> EvilMachine: yeah, but please don't write code like that!
10:50:47 <hackagebot> arbtt 0.4 - Automatic Rule-Based Time Tracker (JoachimBreitner)
10:52:39 <EvilMachine> Athas: why? :D
10:53:15 <EvilMachine> Athas: after all, the brains of mathematicians are pretty good, according to you. :D
10:53:32 <Athas> EvilMachine: if you want to go nuts, then go nuts for real.  Put terminal control characters into your code source files so they'll be syntax-highlighted when 'cat'ed.
10:54:03 <ilid> > let f = sin (2 * x) in f / x
10:54:04 <lambdabot>   2 * cos (2 * x) / 1
10:55:00 <Athas> Wait, what?
10:55:05 <Beelsebob> impressive
10:55:07 <Athas> How does that work?
10:55:12 <EvilMachine> Athas: nah. thats the job of a syntax highlighter.
10:55:26 <paper_cc> > let f = x^2 in f
10:55:27 <lambdabot>   Not in scope: `f'
10:55:50 <Beelsebob> > let f =x^2 in f / x
10:55:51 <lambdabot>   Not in scope: `f'Not in scope: `x'
10:55:55 <mauke> haha
10:57:05 <PeakerWork> why does unicode have a snowman?
10:57:28 <paper_cc> ilid: what
10:57:38 <mauke> PeakerWork: weather symbol
10:57:40 <paper_cc> +'s the magic in your ?
10:57:40 <sproingie> the snowman lobby is powerful
10:57:46 <ilid> :D
10:57:52 <mauke> http://unicodesnowmanforyou.com/
10:58:20 <Athas> Unicode has everything.
10:58:20 <sproingie> http://www.inference.phy.cam.ac.uk/cjb/codepoints.html
10:58:43 <ilid> http://.net/
10:59:00 <mauke> http://mauke.ath.cx/stuff/javascript/unicode.html
11:00:39 <Athas> 
11:01:00 <trzkril> Athas: what was that?
11:01:08 <Athas> A small sun.
11:01:13 <mauke> U+0489 (d2 89): COMBINING CYRILLIC MILLIONS SIGN []
11:01:19 <Athas> I have to use that for a monadic operator.
11:01:38 <trzkril> ah, a combining character
11:01:51 <ilid> po uop-psdn oddns lls sop
11:01:58 <trzkril> it was combined with the nickname
11:02:01 <mauke> ou qqod
11:02:01 <Athas> It's a sun, dammit.
11:02:35 <ilid> s  s, :n
11:02:44 <mauke> > let s = 42 in s
11:02:45 <lambdabot>   42
11:06:23 <kau> hello!
11:06:31 <EvilMachine> > let     = sin(2.0/48000.0) + ;  = pi; () = (*) in map ( 440.0 1.0) [0.0..48000.0/5.0]
11:06:32 <lambdabot>   [1.0,1.0000002974993043,1.0000005949986086,1.000000892497913,1.000001189997...
11:06:42 <Athas> Oh God.
11:06:48 <mauke> splendid work
11:07:09 <EvilMachine> its a sinus wave at 44 hz with a amplitude of 1.0, sampled at  a resolution of 48kHz dD
11:07:11 <EvilMachine> :D
11:07:22 <EvilMachine> oops
11:07:24 <EvilMachine> 440 Hs
11:07:25 <EvilMachine> Hz
11:07:37 <EvilMachine> but the reason I did it,
11:07:47 <mauke> > let  = ;  = 42 in 
11:07:48 <lambdabot>   42
11:07:50 <EvilMachine> is to show you the proper use of unicode chars in haskell. :D
11:07:59 <inimino> sine wave
11:08:02 <Athas> That is not propeeeeeer!
11:08:18 <EvilMachine> mauke: there is a font change character in unicode?
11:08:27 <mauke> no
11:08:52 <EvilMachine> Athas: no? why not? because I used only greek letters as variable names? :D
11:09:21 <kau> sorry, i can't manage to do a simple thing... how to display a counter that update itself every second?
11:09:44 <EvilMachine> is there a sleep function in haskell?
11:09:48 <mauke> EvilMachine: threadDelay
11:09:52 <Athas> kau: well, what kind of program are you writing (console/graphical/curses)?
11:09:54 <EvilMachine> mauke: ah
11:10:01 <mauke> careful with the maxBounds
11:10:11 <kau> Athas: jusdt console
11:10:37 <kau> Athas, i'm trying to make a simple chess clock
11:10:55 <Athas> kau: right, then just 'putStr "\r"' to go back to the start of the line.
11:11:30 <EvilMachine> kau: i think you know how to loop with recursion right?
11:12:27 <kau> two counters, the first or the second is incremented depending if it's white or black turn...
11:12:41 <kau> EvilMachine: yes
11:13:07 <Athas> How will the turn change?
11:13:17 <kau> Athas: pressing space bar
11:13:21 <Athas> You're sort of limited with respect to UI when writing a plain console application.
11:13:34 <Athas> Hm, I think you need to go beyond the standard libraries.
11:13:53 <Tobsan> @pl get >>= \s -> bg >>= \a -> put s >> return a
11:13:53 <lambdabot> (bg >>=) . (. return) . (>>) . put =<< get
11:14:30 <cads> EvilMachine: code you pasted makes me want to get some kind of funky extended keyboard to type those extra characters more comfortably :)
11:15:19 <Athas> Curse those APL hackers and their sexy input devices.
11:16:17 <kau> Athas: i'm trying to use IORef to store the clocks
11:16:40 <mauke> oh god, the clocks! they're everywhere!
11:16:52 <kau> i have something like this to display a counter:
11:17:00 <kau> forkIO $ forever $ threadDelay 1000000 >> (putStrLn $ (readIORef cmptBlanc >>= (return . show)) )
11:17:25 <kau> but nothing displays
11:17:49 <mauke> does that compile?
11:17:51 <EvilMachine> cads: I use the German NEO 2.0 layout, and all those characters I used are in it. I normally code a bit like that. :)
11:18:01 <kau> mauke: hu, no
11:18:11 <mauke> you can't print an IO action
11:18:20 <kau> better: sequence $ repeat $ threadDelay 1000000 >> readIORef cmptBlanc
11:18:22 <mauke> you want readIORef cmptBlanc >>= print
11:18:25 <Cale> kau: another problem is that if the main thread finishes, the whole program ends.
11:18:27 <EvilMachine> cads: but I stopped looking at the keyboard. the keys printed on them are the default boring german layout. :)
11:18:51 <kau> mauke: thanks
11:19:06 <Cale> kau: So you'll need something for the main thread to be doing while your forked thread does its thing.
11:19:26 <kau> Cale: but if run in GHCI?
11:19:35 <Baughn> Like, waiting on an MVar that the forked thread will `finally` be putting () in
11:19:52 <Baughn> kau: GHCi doesn't quit unless you tell it too
11:20:16 <kau> so the forked thread won't exit
11:21:46 <kau> but i think counters are horrible, say i came to haskell with the hope to get ride of them...
11:22:15 <Baughn> You can at least hide them.
11:22:30 <kau> is these a cleaner way to implement it?
11:22:57 <Baughn> replace forkIO with forkIOAndIncrementGlobalSemaphore, and finish off main with waitUntilSaidSemaphoreHitsZero
11:23:17 <EvilMachine> > let ab = 111*b in a 6
11:23:18 <lambdabot>   666
11:23:45 <kau> like storing the timestamps in a list each time space bar is hit, a making a lazy calculus over the list to get the clocks values...
11:23:47 <Baughn> EvilMachine: What is that box?
11:24:07 <Baughn> kau: Wait, what are you trying to do with that, exactly?
11:24:07 <EvilMachine> Baughn: oh, it shows as a box? here, it is a zero-width caracter
11:24:11 <EvilMachine> +h
11:24:43 <kau> Baughn: just display two clocks to play chess.
11:25:05 <Baughn> kau: Sounds like a job for.. Reactive Programming!
11:25:14 <kau> a clock is incremented on turn after space bar is hit.
11:25:17 <Baughn> ..though I may be kidding; it doesn't seem quite mature yet
11:26:03 <Baughn> It would be so very convenient, though. ;_;
11:27:40 <kencausey> If I need to install GHC on a system with old libc (timer_create issue) is the best (only?) solution to simply install an older version?
11:28:02 <Baughn> kencausey: Arguably, the best solution is to upgrade libc. :P
11:28:30 <Baughn> kencausey: However, it should be possible to install an older, and then compile a newer version. The old-libc code never went away, it's just selected at compile time.
11:28:55 <kencausey> Baughn: Ah, thanks
11:29:18 <kw317> guys, I need some advice
11:29:32 <Baughn> kw317: Never crosss the road while it's being resurfaced
11:29:40 <kw317> I'm a 3rd year undergrad and I need to come up with some individual project
11:29:43 <sproingie> don't stick your johnson in a light socket
11:30:08 <kw317> I want to write some sort of a compiler, for a language that is quite small but non-trivial, maybe with some twist
11:30:08 <EvilMachine> Thats the only problem I have with Haskell: In most everyday languages, kaus problem would be a 5 minute job. But in Haskell it involves advanced theories and complex new concepts. ^^
11:30:26 <kw317> sproingie, Baughn: classics ;-)
11:30:38 <Baughn> kw317: How much time are we talking? A third of a semester?
11:30:55 <kw317> say 8 weeks, 10 stretch
11:31:18 <Baughn> If you feel up to it, it should be possible to write a C variant with hindley-milner type inference in that time
11:31:23 <Baughn> No optimization, of course. :)
11:31:32 <sproingie> how about a lisp variant with type inference
11:31:34 <jmcarthur_work> EvilMachine, what exactly about kau's problem is unique to haskell?
11:31:52 <kw317> sproingie: lisp?! that's a weird idea
11:31:54 <kw317> why lisp?
11:32:01 <sproingie> because sexps are nicer
11:32:08 <Baughn> kw317: 'cause you can write a lisp parser in about half an hour
11:32:20 <kw317> for a whlle I was thinking about A+ to CLR
11:32:20 <sproingie> sexps look nicer and they're damn easy to parse
11:32:27 <kau> EvilMachine: i like to ask twisty questions ;)
11:32:30 <kw317> but A+ is too big and god damn quirky
11:32:42 <Baughn> sproingie: Nicer than C, but my current favorite syntax is actually haskell's
11:32:45 <EvilMachine> jmcarthur_work: i never said that the problem was unique. i said that the way to the solution is a 50 mile ride uphill in the snow instead of just around the corner. ^^
11:32:50 <kw317> hmm.. true, parser for lisp is quit easy to do
11:32:57 <jmcarthur_work> EvilMachine, how would you do it in any other languages then?
11:33:04 <sproingie> Baughn: put parenthesis around the top level of expressions and haskell suddenly looks very lispy
11:33:12 <sproingie> granted it ain't the same
11:33:17 <jmcarthur_work> EvilMachine, it seems to me that the 50 mile ride uphill is self-inflicted, not due to haskell in any way
11:33:21 <kw317> however, strongly typed C-like language with type inference isn't too bad either
11:33:46 <sproingie> a forth with type inference.  because with concatenative languages, all you have is Monoid, right? ;)
11:33:48 <Baughn> A point in favor of the c-like language is that you could actually make it compile to C
11:34:03 <Baughn> If you do that, you'd get optimization for free. :)
11:34:11 <kw317> hehe
11:34:15 <EvilMachine> jmcarthur_work: thats up to kau to decide. :)
11:34:17 <Baughn> So that's basically "read source, annotate with types, write out source"
11:34:17 <sproingie> a C compiler that compiles to C
11:34:26 <Baughn> Hey, I'd use it. :D
11:34:29 <sproingie> i'll call it the "C Automation Tool", or "cat" for short
11:34:45 <kw317> Baughn: that might be too trivial
11:34:45 <sproingie> i'll make BILLIONS
11:34:59 <Baughn> kw317: Not at all. It'd be /useful/.
11:35:09 <EvilMachine> ROFL@ sproingie
11:35:14 <Baughn> kw317: I'm not aware of any such projecs, and if it's complete it's something I'd really want to use.
11:35:24 <Baughn> kw317: ..even if it isn't, a good base, or even just example...
11:35:38 <sproingie> how about a language that describes the available actions in the challenges described at http://github.com/ryanb/ruby-warrior
11:35:46 <sproingie> might be a bit longer than an 8-week project tho
11:36:02 <sproingie> describes and executes that is
11:36:24 <Phyx-> good evening
11:36:57 <sproingie> not sure that works as anything but a DSL tho
11:37:07 <kw317> sproingie: looks interesting, I'll have to have a look
11:37:11 <Phyx-> does anyone know why http://phyx.pastebin.com/d762db797 is segfaulting on testType2 NoFields, while testType2 (Other 7) works
11:38:20 <EvilMachine> hey, you could write a Haskell interpreter in a self-developed variant of emacs that is interpreted in x86 virtual machine for javascript. :P
11:38:25 <jmcarthur_work> EvilMachine, in my own experiences, if i have any trouble writing a program in haskell it's the kind of thing i would have had a problem with in any other language
11:38:33 <sproingie> EvilMachine: there's an emacs mode for that
11:39:04 <EvilMachine> jmcarthur_work: to me not, i find many very basic problems to become very complex beasts in Haskell.
11:39:20 <jmcarthur_work> EvilMachine, how new to haskell are you?
11:39:26 <EvilMachine> jmcarthur_work: not to say, that I still like Haskell the most
11:40:05 <Athas> I find that Haskell sometimes feels like more work, but ultimately you're just cramming much more into each line.
11:40:18 <jmcarthur_work> Athas, agreed
11:40:22 <Athas> The style of thinking hard and then writing a few lines of code appeals a lot me personally, though, so I'm OK with it.
11:40:29 <Athas> I also like literate programming, with which it meshes well.
11:40:35 <jmcarthur_work> Athas, also, you spend more time up front covering all your bases
11:40:39 <Baughn> Sure. I spend half an hour writing five lines, which feels like a lot - until I try rewriting it in C.
11:40:54 <EvilMachine> jmcarthur_work: hmm pretty new id say. i understand monads, have read a book about haskell, and am just reading the whole haskell report. i also know one or two glasgow extensions already, but still miss some parts of ghcs bigger standard libraries.
11:40:57 <Phyx-> I guess that's a no
11:41:05 <kau> Athas: i'm OK with brainstorming too
11:41:14 <jmcarthur_work> EvilMachine, how long?
11:41:29 <EvilMachine> jmcarthur_work: undefinable, because of the big pauses i took.
11:41:34 <jmcarthur_work> ah
11:41:38 <Athas> The Report is good, but Real World Haskell is awesome.
11:41:49 <jmcarthur_work> i guess it goes without saying that it gets easier with practice
11:41:59 <EvilMachine> Athas: i agree about the cramming. but i actually love that thing about haskell.
11:42:09 <Athas> The Report misses a lot of the stuff I like about Haskell (like monad transformers), and even RWH doesn't go into the really awesome stuff like existential quantification or (IIRC) multi-parameter typeclasses.
11:42:12 <EvilMachine> Athas: Real World Haskell? I have to check it out. :D
11:42:17 <sproingie> i find i have to take a break from haskell for a year then come back and another thing sticks
11:42:19 <kau> but wait guys, i said i could write that chess program in minute with haskell to my colegues to impress them...
11:42:19 <jmcarthur_work> i now find it significantly harder to write programs in C (or Python or C# or <insert imperative language here>) than in Haskell
11:42:26 <kau> too bad
11:42:35 <sproingie> took me several tries for monads.  i still can't make monad transformers stick, but i'm hopeful this time
11:43:02 <Athas> I think the trick is to read a lot of code.
11:43:06 <EvilMachine> I dislike literate programming. Im more of a self-documenting code type. Thats why I dislike one-letter variables too.
11:43:20 <sproingie> i think the monad tutorials are finally catching on that cute analogies hurt more than they help
11:43:22 <Athas> I really learned Haskell by having to modify Flask for my bachelors degree.
11:43:23 <jmcarthur_work> EvilMachine, what if those variables have no intrinsic meaning?
11:43:52 <sproingie> i finally got it when i saw that monads are just a bunch of operators, and they all kinda behave in a similar way but there's no single metaphor that applies to all of them
11:44:18 <Baughn> sproingie: Yep. Have you read the typeclassopedia?
11:44:25 <sproingie> Baughn: nope, where's that?
11:44:34 <jmcarthur_work> sproingie, no metaphor, right, but they do have specific properties, which is the important bit
11:44:36 <jmcarthur_work> :)
11:44:47 <EvilMachine> jmcarthur_work: the sad thing is, that im incredibly fast to write anything in fasten your seatbelt PHP! :/ I had to use it 4+ years, despite being a good Java developer back then. Luckily I knew how to code properly, even in that dirty, dirty PHP. ^^
11:44:58 <sproingie> monads have a "get this thingie into the monad" and a "do the next thing with this thingie" and that's about it
11:45:15 <Athas> PHP?  Yuck.  Wash your mouth.
11:45:16 <Baughn> sproingie: http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
11:46:19 <Baughn> What monads have in common is the type signatures of the monad functions, which happens to decide how it's technically possible to compose functions - thus Control.Monad. And that's it.
11:46:44 <EvilMachine> Athas:  So what goes into the really awesome stuff? I too found the books more than lacking. Reading some stuff in the wiki was like a completely different language to me. With constructs that i could not even search for because they were so strange.
11:46:55 <jmcarthur_work> monads are nothing more than values which are tied to context
11:47:15 <jmcarthur_work> i don't like to say "wrapped" as that implies some sort of actual container
11:47:26 <Athas> EvilMachine: nothing really.  Various papers and stuff.  I learned about most of the cool Haskell extensions by reading code.
11:48:11 <EvilMachine> jmcarthur_work: well, i write practical code. so i usually dont have such situations
11:48:26 <jmcarthur_work> EvilMachine, what situations?
11:50:08 <Baughn> EvilMachine: The GHC manual works for finding the extensions in the first place, and I even understand some of them
11:50:17 <Baughn> Rank-N types and such are beyond me, but I haven't needed them yet.
11:52:02 <EvilMachine> Athas: well, i decided that after the haskell report, i go through the GHC extensions documentation, and search a wiki page or something about all those things, until i understand them. then i will start reading more real-world solutions. ill  read examples for common problems, etc.
11:52:26 <Athas> I'd advise you to read real programs.
11:52:54 <EvilMachine> jmcarthur_work: situations where the variables have no intrinsic meaning.
11:54:31 * Baughn has a nasty tendency to write "h" instead of "handle". Anyone else?
11:54:54 <mauke> ecchi
11:55:30 <Baughn> mauke: I also get lap-dances from my laptop.
11:55:56 <EvilMachine> Athas: real programs are not going to help. i tried that. the code just makes no sense when i get to those strange constructs. and in a way, that does not even let me form any questions about them. so its impossible for me to even search for them. what would I enter? the two operators i dont know? the composititon of constructs i know, but that make no sense to me in that composititon? it was a horrible experience. :/
11:56:05 <Athas> Looks to me like most Haskell uses a C-ish very abbreviated naming scheme.
11:56:45 <jmelesky> Athas: i think it's more like a math-ish very abbreviated naming scheme
11:56:56 <jmelesky> but it may boil down to the same thing
11:57:30 <EvilMachine> Baughn: well, if h is a local thing then thats ok. but it if its used everywhere, handle makes more sense.  in case you have another h with a different meaning (eg height):D
11:57:50 <Athas> Well, math sort of uses various typographical tricks...
11:57:53 <Baughn> EvilMachine: Oh, sure. It's local in each function that uses it. :P
11:58:14 <Athas> EvilMachine: well, reading Real World Haskell is a good intro.
11:58:20 <EvilMachine> Athas: dont use that nasty letter C! ^^
11:58:33 <EvilMachine> Athas: its way to tinny!
11:58:35 <EvilMachine> +o
11:58:46 <Athas> EvilMahine: I won't, then.
11:58:47 <jmelesky> Athas: if you're using emacs, you can set haskell-mode to use some similar typography (lambdas, alpha, beta, etc for types, arrows, all sorts of stuff)
11:59:05 <jmelesky> it's still line-oriented, though
11:59:18 <Zao> Or leksah.
11:59:24 <jmelesky> yep
11:59:56 <EvilMachine> jmelesky: or you simply use a keyboard layout that supports those charaters.
12:00:16 <Phyx-> mauke might you know some FFI? been looking at some code here and can't really figure out what's wrong
12:00:27 <mauke> maybe
12:00:34 <jmelesky> EvilMachine: well, you're still typing in \, a, b, ->, etc. haskell-mode just displays them differently
12:00:41 <Baughn> "Before that day, he had only coded a few lines of BASIC and batch script, but Shane knew that C++ was relatively easy. " <-- Oh no. Ooh dear.
12:01:12 <Phyx-> mauke my code is http://phyx.pastebin.com/d762db797 , the call with "NoFields" as arguments seems to fail, cauzed my heap to be corrupted, while the call with the other constructor works
12:01:36 <EvilMachine> jmelesky: yes, thats something that I see as a problem in Haskell: you cant really redefine some basic things like \ or =.
12:01:39 <mauke> Phyx-: where is alignment coming from?
12:02:07 <PeakerWork> EvilMachine: in a sense, you can, if you think of functions as instances of Arrow, you can just redefine Arrow instances
12:02:36 <jmelesky> EvilMachine: i'm not convinced of the general merit of that level of redefinition
12:02:57 <EvilMachine> PeakerWork: oh, ok :D Im not yet far enough for Arrows. :/
12:02:57 <mauke> Phyx-: peek .. IO Int looks suspicious. shouldn't that be IO CInt or something?
12:03:23 <sinelaw> is: cabal install leksah supposed to work? it complains about missing glib, gtk
12:03:27 <EvilMachine> jmelesky: luckily, I dont have to ask you what I should want or will install on my system. :D
12:04:11 <Phyx-> mauke might be, though Int is also a valid type, but i'll try CInt, and the alignment comes form the Foreign.Storable instance of itself in this case
12:04:29 * EvilMachine just executed emerge leksah
12:04:36 <mauke> oh right
12:04:50 <mauke> Phyx-: so you didn't define it
12:05:01 <jmelesky> EvilMachine: wouldn't dream of telling you that, nor how to program. just saying that, though i can see the benefit of operator overloading in OO environments, it doesn't make as much sense (to me) in a typeful functional environment
12:05:03 <mauke> why not alignment _ = error "no alignment for you"?
12:05:27 <Phyx-> mauke no reason, I just found a tutorial on this stuff and it suggested doing it that way
12:05:34 <mauke> burn the tutorial
12:06:05 <Phyx-> lol
12:06:10 <mauke> I don't trust those unsafePerformIOs
12:06:47 <Phyx-> but the odd part is the second call always succeeds
12:07:02 <Phyx-> CInt gave the same error, let me try with not defining the alignment
12:07:42 <mauke> er, that's what you're already doing
12:07:57 <Phyx-> right, ofcourse, i was calling itself
12:08:08 <Phyx-> hm, how would one usually define the alignment?
12:09:33 <mauke> #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
12:09:50 <Athas> The only thing I miss from C++ in Haskell is properly scoped field accessors.
12:09:58 <mauke> alignment _ = #alignment TwoCases
12:10:05 <Athas> Haskell records are very bare-bones.
12:10:23 <mauke> Athas: some people say the same thing about C++ enums
12:10:26 <Phyx-> oh, i i have no idea what the #let does though, lol. i should probably read up on that
12:10:35 <mauke> defines a new # command
12:10:55 <EvilMachine> Im sorry, my X server crashed because of the stupid buggy ati drivers (of course). :(
12:11:13 <Athas> I would also like a better module system.  And a pony (with wings).
12:11:38 <Phyx-> mauke but what coomes after it is also a bit confusing on it's own
12:11:40 <Phyx-> lol
12:11:45 <jmelesky> Athas: agreed on the module system. winged ponies are Django's arena, though, iirc
12:11:55 <mauke> C magic
12:12:24 <EvilMachine> Athas: I could arrange that. Just wait 50 years for genetics to catch up. :D
12:12:47 <Phyx-> mauke ahahah
12:13:18 <Phyx-> i'll rewrite the function without the unsaferPerformIOs and see it it works then
12:14:14 <EvilMachine> oh noo!! guys, you wont believe what crashed my X server: installing leksah was what did it!!
12:14:25 <aug_triad> Hi. I would like to use regular expression in a case expression with the library Text.Regex.Posix. I can't find anything about it on the web... I can do it without problems with the =~ operator when I'm not using case expressions.
12:14:28 <EvilMachine> or compling it to be more exact
12:14:32 <Zao> EvilMachine: Considering that Leksah ate my source files, I wouldn't be surprised.
12:14:40 <FunctorSalad_> nomnomnom
12:14:55 <EvilMachine> FunctorSalad_: thats omnomnom :D
12:15:05 <Zao> omnomnom
12:15:18 <FunctorSalad_> EvilMachine: I thought that was just a variant
12:15:22 <mauke> 
12:15:22 <hackagebot> hpage 0.2.1 - A scrapbook for Haskell developers (FernandoBenavides)
12:15:25 <alinp> hi guys
12:15:26 <EvilMachine> Zao: lol. but how can a can a compiler crash an x server? that thing does not even have access to X, or has it?
12:15:36 <EvilMachine> FunctorSalad_: :D
12:15:36 <Zao> EvilMachine: TH? :)
12:15:40 <kynky> eclipse supports haskell, but i guess leksah would be preferred , for an ide that is ?
12:15:42 <alinp> how can I strict evaluate this: foldl (+) 0 [1..999999]
12:15:42 <Zao> EvilMachine: I'd blame you running a hippie system :)
12:15:43 <alinp>  ?
12:16:02 <FunctorSalad_> evidence http://i7.photobucket.com/albums/y274/hollywoodron/nom-nom-nom.jpg
12:16:02 <Zao> @type foldl'
12:16:02 <jmelesky> EvilMachine: it's been a few years since i used X as a desktop, but i don't recall it exactly being the model of stability
12:16:02 <alinp> because of the laziness, I'm getting stack overflow
12:16:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:16:06 <EvilMachine> Zao: TH?
12:16:17 <Zao> EvilMachine: Template Haskell. Can do all kinds of Fun Stuff[TM].
12:16:29 <Phyx-> mauke rewrite it without the unsafeperform IO and it still crashed. for some reason the first one always fails
12:16:53 <mauke> :-(
12:16:55 <EvilMachine> Zao: you mean i experimental system you know experimenal as the spirit of Haskell. :D
12:16:55 <FunctorSalad_> Zao: but a TH function calling into X? ^^
12:16:57 <alinp> Zao: ?
12:17:44 <EvilMachine> jmelesky: its apparently the ati-driver who dies when something big compiles. never happened with nvidia before.
12:17:54 <Zao> alinp: The ' variants are strict in the accumulator.
12:18:02 <FunctorSalad_> (and how are hippies involved?)
12:18:14 <alinp> hmmmm
12:18:16 <Phyx-> mauke i get a valid pointer, but when i try to unmarshall whatever is there from a pointer to a structure it crashes on the first one on the C# side
12:18:20 <alinp> I don't have something like this
12:18:22 <Zao> > foldl' (+) 0 [1..999999]
12:18:23 <lambdabot>   499999500000
12:18:29 <alinp> <interactive>:1:0: Not in scope: `foldl''
12:18:33 <Phyx-> with an unknown exception
12:18:34 <EvilMachine> Zao: lol. ok. TH is an evil beast.
12:18:40 <EvilMachine> Zao: kill it with fire!
12:18:41 <mauke> alinp: import Data.List
12:18:51 <alinp> oh, thanks mauke
12:19:00 <alinp> & thanks Zao
12:19:50 <PeakerWork> Athas: records being their own namespace is a C feature, not a C++ one. The C++ convulted it, with inheritance, into a big namespace mangling thing that makes unqualified imports look great
12:19:59 <FunctorSalad_> the vast majority of TH function will do no IO except reify and generating fresh names, so I doubt that crashed your X
12:20:15 <FunctorSalad_> *functions
12:20:29 <Zao> Mentioning TH was a joke. I'd blame unstable hardware/software.
12:20:35 <Zao> A memtest would probably not hurt.
12:21:17 <FunctorSalad_> I see
12:21:31 * Phyx- wishes he could see what's happening behind the scene
12:21:43 <Zao> Of course, I've made X servers keel over from spamming too much to xterms :)
12:21:50 <EvilMachine> FunctorSalad_: hippies are the fuel. their campfires heat their bongs, which then drive them like turbines, dancing in circles, while pulling a wheel with their dreads that got caught in the wheel, which then generates electricity for the computer. but because its filled with the spirits of kumbaya, it fucks up all kinds of programs. :P
12:22:10 <Phyx-> mauke anyway, thanks for trying atleast
12:22:29 * Phyx- alteast knows the proper way to calculate alignment now
12:23:51 <dlocpuwons> Hey all, is there anyway to refer to the list being created during a list comprehension?
12:25:21 <EvilMachine> Zao: its the ati graphics driver. no doubt about it. i used the nvidia one before, and it never ever crashed. i also tried it with the console and the vesa framebuffer driver on ati: completely stable, even while compiling ghc. but in X with the ati driver, and then compiling something with ghc and it dies. typical ati thing though. the previous driver was not even compatible with recent kernels. ^^
12:25:39 <FunctorSalad_> dlocpuwons: let x = [ ...... ] in ....
12:25:46 <FunctorSalad_> dlocpuwons: the comprehension can refer to x
12:25:50 * EvilMachine is ashamed for drifting off topic so often.
12:27:00 <dlocpuwons> so if I do let x = [...] I can refer to x in "...." part, and it would point to whats been created so far of the list?
12:28:34 <Zao> > let x = [y | y <- 1:x] in take 10 x
12:28:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
12:28:42 <Athas> GHC requires an Nvidia video card.
12:28:57 <FunctorSalad_> dlocpuwons: to the final result, actually :)
12:29:15 <aug_triad> Hi. I would like to use regular expression in a case expression with the library Text.Regex.Posix. I can't find anything about it on the web... I can do it without problems with the =~ operator when I'm not using case expressions.
12:29:25 <dlocpuwons> thanks all
12:29:29 <olsner> FunctorSalad_: it's up to you to clean up the mess after his brain explodes now :P
12:30:53 <Phyx-> mauke I figured it out, It wasn't the haskell side, in case you were wondering
12:36:14 <EvilMachine> Athas: of course. :P
12:36:35 <EvilMachine> Athas: but hey, I think actually, GPGPU would speed up GHC like crazy.
12:36:57 <Athas> I don't think GHC uses too many floating point computations.
12:38:40 <nomeata> aug_triad: what kind of cases do you want to distinguish?
12:39:49 <EvilMachine> Athas: uum, graphics cards do integers just as well. ^^ but i know what you mean. although i thing those 800-1600 tiny processors in modern gpus must be put to use somehow. :D
12:40:32 <EvilMachine> woah, I hadnt seen the new haskell logo: http://upload.wikimedia.org/wikipedia/commons/4/43/Haskell-Logo-Variation.pnglooks very cool actually. especially compared to the old one.
12:40:38 <EvilMachine> oops.
12:40:46 <EvilMachine> (space missing)
12:40:58 <data_jepp> How do I return something that is "Maybe Int" in a function?
12:41:15 <Vulpyne> Have the function evaluate to "Just some_integer" or Nothing.
12:41:24 <data_jepp> oh
12:41:40 <Vulpyne> funky x = if x > 10 then Nothing else Just x
12:42:13 <data_jepp> hm
12:42:49 <Vulpyne> The maybe monad could also be useful, if anything in it evaluates to Nothing, the whole thing evaluates to Nothing.
12:42:52 <juhe> Hello people, I'm playing with Data.Generics and I'm trying to find out if there is a inverse function to toConst. In other words, is there a way to get type constructor from value of Constr type?
12:43:11 <aug_triad> nomeata: I would like to distinguish beetween comments ("^--"), ("^key=") and then I would like to catch the rest with a _, and then use the =~ operator
12:44:38 <nomeata> aug_triad: its not clear to me what you are trying to do. why dont you paste some relevant code on http://moonpatio.com?
12:44:59 <aug_triad> I will do
12:46:08 <FunctorSalad_> what is a moonpatio anyway? :)
12:47:16 <FunctorSalad_> , src 'fromConstr -- juhe
12:47:17 <lunabot>  luna: parse error (possibly incorrect indentation)
12:47:22 <FunctorSalad_> , src 'fromConstr
12:47:25 <lunabot>  fromConstr :: forall a . Data a => Constr -> a
12:48:13 <FunctorSalad_> iirc it returns a value with all the fields undefined though
12:48:27 <FunctorSalad_> , fromConstr (toConstr (1,2))
12:48:28 <lunabot>  ()
12:48:54 <FunctorSalad_> , fromConstr (toConstr (1,2)) :: (Int,Int)
12:48:55 <juhe> hm...
12:48:55 <lunabot>  luna: Prelude.undefined
12:49:04 <aug_triad> nomeata: Strange.. Now it works, after I have re-entered the code I had. Thank you anyway :)
12:49:30 <nomeata> aug_triad: you are welcome :-)
12:49:41 <nomeata> (Its strange how often problems disappear when I try to help people)
12:49:41 <aug_triad> No sorry, I'm stupid now! I will paste it now, hehe
12:50:10 <Phyx-> juhe you could recursively call it using fromConstrM and build a skeleton with "default" values
12:50:17 <Phyx-> so just a generic producer
12:50:33 <FunctorSalad_> ,src 'fromConstrM
12:50:36 <lunabot>  fromConstrM :: forall m a . (Monad m, Data a) => (forall d . Data d => m ...
12:50:36 <lunabot>                                                   Constr -> m a
12:51:00 <data_jepp> What does Equations give different arities for "evalProg" mean?
12:51:29 <nomeata> data_jepp: that you gave more than one definition for evalProg, and some have more arguments than others
12:51:42 <data_jepp> hmm
12:51:47 <juhe> FunctorSalad_: I'm interested in this: data Foo = Bar | Baz String; and I wish that fromConstr(toConstr Baz "asdf") would return just Baz, which is actually of type String -> Foo
12:51:52 <nomeata> @eval let {func 1 = 0; func = id} in func 1
12:51:59 <Cale> data_jepp: There's a bit of an arbitrary restriction which says that all the definitions you give for the same function have to *syntactically* have the same number of parameters.
12:52:00 <nomeata> data_jepp: ^^ this is invalid
12:52:16 <aug_triad> nomeata: I have posted it now
12:52:38 <nomeata> aug_triad: can you paste the link?
12:52:43 <aug_triad> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4311#a4311
12:53:51 <juhe> FunctorSalad_: I'm not sure If the thing I want is possible (or even logical), it seems that if I write 'fromConstr (toConstr (Baz "asdf")) :: String -> Foo' I get what I want, but I'd like to avoid typing the :: String -> Foo, i.e. type
12:54:15 <nomeata> aug_triad: how about "if x `elem` ["","(^--)","(^key=)"] then parseForm xs else let..."
12:54:17 * ksf is thinking about generic special-purpose binary formats like ebml vs. just dumping everything into say a btrfs image
12:54:24 <nomeata> aug_triad: gets rid of the repeating parseForm
12:54:58 <FunctorSalad_> juhe: I think you first need to get the (Baz undefined) with fromConstr, then update the String in it
12:55:29 <aug_triad> Yes, that's maybe a better solution. But is it possible (for future work) to do it with a case expression?
12:55:50 <ksf> ...you can, in fact, map ebml semantics onto a file system, easily and straigt forward. well, directory contents on a fs usually aren't ordered, but that's a minor detail.
12:56:46 <ksf> ...maybe that's just what I should do. write a FUSE interface to ebml files.
12:57:03 <FunctorSalad_> , toConstr [1] == toConstr [2]
12:57:04 <lunabot>  True
12:57:05 <juhe> FunctorSalad_: Hm,  so it meanst that string ("asdf") actually gets into data representation - I'd expect the show on value of Constr type would tell me that
12:57:39 <FunctorSalad_> juhe: the value of Constr type only specifies which constructor was used
12:57:56 <juhe> FunctorSalad_: nod
12:58:54 <nomeata> aug_triad: well, you are using a case expression now, arent you?
12:59:36 <nomeata> aug_triad: ah, there is a comment, one moment...
13:00:03 <nomeata> aug_triad: no, you can not do that directly with a case expression.
13:00:12 <EvilMachine> ksf: i love ebml. add a tag-id-to-name mapper to it, and you got XML in a much more compact but still very proper format
13:00:30 <zloog> Does lambabot have one of those free function generators?
13:00:35 <zloog> Input a type and get a definition?
13:00:44 <PeakerWork> @djinn a -> a
13:00:45 <lambdabot> f a = a
13:00:51 <zloog> Cool
13:00:52 <zloog> thanks
13:00:52 <PeakerWork> @djinn Maybe a -> Maybe b -> Maybe (a,b)
13:00:53 <lambdabot> f a b =
13:00:53 <lambdabot>     case a of
13:00:53 <lambdabot>     Nothing -> Nothing
13:00:53 <lambdabot>     Just c -> case b of
13:00:53 <lambdabot>               Nothing -> Nothing
13:00:55 <lambdabot>               Just d -> Just (c, d)
13:00:59 <ksf> in fact, ebml dtd's specify names for tags.
13:01:05 <EvilMachine> ksf: can you imagine that i did a very basic ebml parser and serializer for javascript and php communication back in 2003/2004! ^^
13:01:12 <PeakerWork> zloog: its actually a theorem prover :)
13:01:16 <aug_triad> nomeata: ok, then I have to do it with a lot of nested if then else's? It would be much nicer with a case here.
13:01:21 <ksf> ...but the RFC is so buggy that it's no wonder noone has written a generic parser on top of it, yet.
13:01:26 <nomeata> aug_triad: you could put the stuff in a list of tuples  [("regex",what-to-do),("regex",.. and pass that to a small function that matches each regex until the first on matches, and then uses the right value.
13:01:51 <ksf> ...though it wouldn't be a hard feature to add, with the current state of my lib.
13:01:55 <nomeata> aug_triad: this way, you have almost case syntax
13:01:56 <edwardk> > zipWith id (iterate (fac .) fac) [1..]
13:01:57 <lambdabot>   [1,2,2601218943565795100204903227081043611191521875016945785727541837850835...
13:02:17 <ksf> the problem is that the semantics are a mess. common mkv files don't match the dtd, at all.
13:02:37 <ksf> (well they use the same ids and field types, but things like cardinality and ordering are messed)
13:03:35 <aug_triad> nomeata: thank you, I will try to figure something out
13:03:36 <EvilMachine> ksf: i just took the basics: a tag id, a length value, and then comes the content of the specified lenght, also consisting of such constructs. thats it
13:04:08 <EvilMachine> ksf: ebml is not equal to mkv!
13:04:14 <ksf> still, ebml maps semantics quite literally onto byte layout. e.g. there's to btree-fs like "write a meg into the middle of a 128-meg file and end up with three extends, and just one meg + small overhead write to the disk"
13:04:23 <EvilMachine> ksf: mkv is to ebml as xhtml is to xml
13:04:38 <ksf> well, while looking for ebml files, mkv's are the only example I could find
13:04:46 <ksf> I didn't search long, though.
13:05:01 <EvilMachine> ksf: true.
13:06:12 <ksf> supporting fragmentation is great for editing files, but a no-fragment mode is definitely needed. like for a network protocol
13:06:16 <EvilMachine> ksf: i gave up back then, even ignored that unicode-like method for tag ids and lengths (i think), and just used fixed width values for the tag id and lenght fields, with a width that i knew would never become too small
13:06:26 <ksf> (and ebml, with minor fixes, makes a fine binary protocol)
13:06:41 <EvilMachine> ksf: agreed
13:07:14 <ksf> but then, one could push exactly those editing-deltas over the net, too.
13:08:46 <ksf> hey those vints are the only part of my code that's quickcheck-tested.
13:09:14 <ksf> I'm ignoring a lot of corner cases too, though. like variable length stuff.
13:10:04 <EvilMachine> i even thought about completely backing away from xml as a storage format forever. id use my own version of ebml, and use companion tag to name mapping files for from- and to- xml conversions. i still dream of combining it with a complete semantic file system where there is no difference between the file system and the files. i with i had something like that, implemented in haskell, as a FUSE file system.
13:10:16 <ksf> mhhh actually variable length isn't needed at all if there were a standard "partial field" tag.
13:11:00 <ksf> simplifies the semantics, a lot.
13:11:19 <EvilMachine> ksf: ok, youre deeper in the spec as im right now. :)
13:12:31 <ksf> the standard ebml dtd specifies a CRC32 container, for example. it's supposed to transparently fit around any other container.
13:12:58 <EvilMachine> nice
13:13:07 <ksf> http://www.matroska.org/technical/specs/rfc/index.html  look for "%children"
13:13:26 <sinelaw> if I have:
13:13:35 <sinelaw> f Blah a = <some code>
13:13:42 <sinelaw> f Bleh a = <the same code as above>
13:13:47 <sinelaw> f _ = <something else>
13:14:00 <sinelaw> how can i write the first two lines without duplication? :)
13:14:08 <i-blis> does lambdabot supports 6.10.4? shall I still apply patches to run it locally with 6.10.4?
13:14:10 <Cale> f x a = case x of
13:14:18 <Cale>         Blah -> u
13:14:22 <Cale>         Bleh -> u
13:14:25 <sinelaw> ah ok :)
13:14:28 <Cale>         _ -> <something else>
13:14:34 <sinelaw> where
13:14:36 <Cale>   where u = <some code>
13:14:51 <Cale> Not sure if that's actually better.
13:15:08 <sinelaw> it applies DRY
13:15:12 <sinelaw> which is better
13:15:16 <ksf> but I haven't figured out the semantics of combining edtds yet, anyway. my matroska dtd consists of the ebml and matroska dtd cat'ed together.
13:15:32 <Cale> sinelaw: well, certainly if <some code> is of any length
13:19:19 <EvilMachine> ksf: i think i should go to bed. this stuff starts to go over my head as i stare at the screen. :) hey, but if you would just create a simplified, fixed version of the embl spec yourself, and publish that? ^^ it could help it actually being implemented elsewhere. :) you could save us all the pain that you already went trough in exchange for some fame! :P
13:19:38 <EvilMachine> anyway. im off. but i like it here. :)
13:21:29 * ksf would rather smash his head repeatedly into a brick wall, or, preferrably, spec ebml 2.0 than suffering the agony of fixing the current RFC draft...
13:25:00 <ksf> does anyone have good pointers about non-vanilla-path based file systems?
13:25:19 <ksf> ...like, database-like models.
13:25:53 <ksf> specifically ones that don't just talk blue sky about usability, but ones that contain infos about actual wins
13:26:32 <ksf> ...as, I guess, most if not all stuff can be expressed with sufficiently smart usage of hierachical names, anyway.
13:29:57 <Athas> ksf: what about the Smalltalk systems?
13:30:57 <nswill> ksf: are you talking about a disk level file system that behaves like an RDBMS at a physical level, or something entirely different?
13:31:41 <ksf> I'm not talking about anything, I'm dreaming blue sky and want to reduce the search space.
13:33:18 * ksf is sceptical about sql-databases, anyway.
13:33:37 <ksf> too often they're used as a one-size-fits-all kludge
13:33:40 <nswill> WinFS was supposed to be a database file system; but, they have yet to get it working.
13:34:21 <nswill> I think there are other projects to do something similar; but, no one has gotten anything remotely close to a usable system yet.
13:34:42 <camio> killerfs?
13:34:55 <camio> Oh, sorry, I mean reiserfs.
13:35:38 <ksf> reiserfs is a hierachical fs, like any other unix fs.
13:36:00 <nswill> They wanted to turn the file system into a database at one point
13:36:32 <nswill> But, most of the time they just discover it's easier to tack on a user space file indexer and meta data system that you can query
13:36:53 <ksf> ...and, tbh, it's not hard at all to add e.g. a mime-type index to a hierachical fs.
13:37:04 <ksf> exactly.
13:38:26 <ksf> ...and having every file reachable by name gives you a nice way of telling what's supposed to be on the fs.
13:38:49 <hackagebot> hmk 0.9.5 - A make alternative based on Plan9's mk. (MathieuBoespflug)
13:40:05 <hiredman> I think filesystem interfaces have solidified, which is why indexing systems and such tend to be layer somewhere above the filesystem these days
13:40:59 <ksf> it might make sense to spec the interface to hierachical names as just one under many possible interfaces, though.
13:41:42 <ksf> that is, provide plug-in name resolvers that can offer their own view of the fs.
13:42:25 * sm eyes hmk
13:42:51 <hackagebot> TrieMap 0.5.1 - Automatic type inference of generalized tries. (LouisWasserman)
13:42:52 <ksf> like ls /find/*.hs/\// listing all the .hs files under / in a flat dir.
13:43:11 <augur> i just want everyone to know: the english word "donate" has the time signature ((e -> t) -> (e -> t) -> ((e -> t) -> (e -> t) -> e -> t) -> e -> t) -> e -> t
13:43:48 <jmcarthur_work> @djinn ((e -> t) -> (e -> t) -> ((e -> t) -> (e -> t) -> e -> t) -> e -> t) -> e -> t
13:43:48 <lambdabot> -- f cannot be realized.
13:44:08 <augur> :P
13:44:29 <Cale> time signature?
13:44:31 <nswill> They way I've always thought would be neat to interact with your files is to have it as a flat file database and using stored queries to replace queries. OS X has basic features to enable such a workflow for a subset of the file system; but, they haven't fleshed it out and it's very clunky to use in the manner I described
13:45:17 <nswill> stored queries to replace folders*
13:46:12 <jmcarthur_work> nswill, me too, and i think os x's smart folders is an okay step in the right direction, besides lacking some power and not caching enough things
13:47:05 <augur> actually i mightve calculated the type signature wrong. :(
13:47:29 <ksf> http://en.wikipedia.org/wiki/Inferno_(operating_system)
13:47:53 <frosty> good evening
13:48:25 * Cale likes his hierarchical filesystem. However, I do think the distinction between directories and files is a bit silly. Just give me a tree where every node can contain data.
13:49:09 <augur> yeah i miss calculated :(
13:49:10 <augur> but!
13:49:35 <sinelaw> @type apply
13:49:37 <lambdabot> Not in scope: `apply'
13:49:43 <frosty> would anyone be able to tell me the recommended procedure for installing GHC 6.10.4 on Ubuntu 8.04 (hardy)?
13:49:49 <frosty> or am I out of luck?
13:49:59 <Cale> frosty: Install the generic linux binary
13:50:03 <camio> Cale, are you suggesting something like having a folder be a makefile and its contents be what it makes?
13:50:13 <frosty> cale: that should work?
13:50:24 <ksf> that saved queries-thing is a cool thing.
13:50:26 <sinelaw> @type ($)
13:50:28 <lambdabot> forall a b. (a -> b) -> a -> b
13:50:30 <Cale> camio: If you'd like.
13:50:50 <sinelaw> frosty, haskell platform
13:50:51 <Cale> camio: Or an html document with subfiles that were the various resources it needed.
13:51:02 <camio> hrm
13:51:09 <augur> to word "to" is: to = \p q r -> rpq :: ((e -> t) -> (e -> t) -> t) -> e -> t
13:51:22 <sinelaw> frosty, http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html
13:51:22 <nswill> If a file system were setup to be modeled as a set then it would be a generalization of the hierarchal file system which is what I think would be cool. In principle you could get an existing operating system working with in a set theory based file system and then from there you can do whatever you want with it, the UI could present itself so it acts no different than a hierarchal system unless you intentionally wish to break it
13:51:23 <camio> Ah, sort-of like index.html.
13:51:24 <Cale> frosty: yes, works fine for me
13:51:54 <frosty> I've been looking at installing the haskell platform, but it said it required ghc-6.10.4
13:52:14 <Cale> nswill: isn't that kind of like what we have now then?
13:52:14 <frosty> sinelaw: that exact guide, in fact
13:52:29 <Cale> nswill: The filesystem is really a graph, but by default it's a tree?
13:52:30 <ksf> mkv's, for example, have attachments.
13:52:36 <frosty> sinelaw: it provides deb/deb-src repos, but they only provide packages as far back as intrepid
13:52:39 <frosty> and i'm on hardy
13:52:53 <nswill> With symlinks you can make it act that way
13:52:54 <sinelaw> ah
13:52:56 <nswill> Like a graph
13:53:22 <ksf> one could very well imagine an overlay-fs that maps an ebml file to its attachments if opened as directory, and as itself if opened as file.
13:53:27 <Philonous> The error message "Inferred type is less polymorphic than expected" should really mention that this might be due to the monomorphism restriction
13:53:28 <nswill> To the user it doesn't present the system as a set of subsets of the file superset
13:53:38 <ksf> (or, actually, a proper tree of all of its elements)
13:53:53 <Cale> frosty: Unless there are binaries for your OS, installing the Haskell Platform is a little bit pointless. Just get GHC and cabal-install and you're set.
13:54:00 <sinelaw> @type uncarry
13:54:01 <lambdabot> Not in scope: `uncarry'
13:54:07 <sinelaw> oops
13:54:08 <sinelaw> @type uncurry
13:54:09 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:54:16 <frosty> cale: I'm trying the binary now
13:54:18 <ksf> Philonous, but then, usuall it's because of an escaped existential
13:54:28 <frosty> I was trying building from source earlier, but it was taking forever
13:54:32 <frosty> and OOM'd at one point :/
13:54:43 <Cale> frosty: Yeah, you're not meant to compile GHC yourself.
13:55:01 <Cale> frosty: (At least unless you're hacking on it, it's not worth the trouble)
13:55:51 <ksf> nswill, unix fs are set-based. there's hardlinks.
13:56:03 <ksf> it's just that the contains-relationship is inverted.
13:56:21 <Philonous> ksf: Right, the problem here really is the monomorphism restriction. It bites me more often than I care for. Maybe I should create a template that adds NoMonomorphismRestriction at the top of every haskell file I edit.
13:56:25 <ksf> no of course not.
13:56:50 <Cale> I hate the MR too
13:56:56 <ksf> a directory is a bag of indexes to a universe of binary chunks.
13:57:14 <Cale> and NoMonomorphismRestriction is so annoying to type for something which really should be the default
13:57:22 * ksf never uses it.
13:57:39 <ksf> I actually like the warning and don't mind annotating a top-level fun.
13:58:45 <nswill> Hmm, I see, so really it's just an issue of user space tools that present the file system
13:59:31 <ksf> and, in the case of saved queries, a matter of having a rich enough interface so the fs can tell the search that something was updated.
13:59:34 <Philonous> What good is type inference if you can't rely on it. I don't see a point in annotating simple synonyms like foo = bar when I already annotated foo.
13:59:43 <Cale> That's just because you haven't spent an hour trying to figure out why runST thinks your ST computation is insufficiently polymorphic only to find out that it's the simple definition of some monad combinator without an explicit type signature screwing things up and causing the s to be defaulted to ()
14:00:07 <frosty> Cale: It worked!!!
14:00:09 <frosty> thank you :D
14:00:15 <Cale> frosty: no problem :)
14:00:17 <frosty> why i didn't try the binaries in the first place, i have no clue
14:00:23 <frosty> all the guides i found told me otherwise
14:00:30 <ksf> well yes but that's defaulting. those default warnings should be on by default.
14:00:47 <Cale> I just think the MR is completely misguided and needs to die.
14:01:43 <ksf> ...well, it's a big difference between calling a fun with one argument and calling a fun with one argument and 100 passed dictionaries.
14:02:02 <ksf> the mr is a way of saying "bleeding tell me which one you want"
14:02:51 <Cale> That's stupid. I always want the most polymorphic type unless I say otherwise explicitly.
14:03:50 <ksf> well ok but keep -fwarn-monomorphism
14:04:45 <Cale> Sure. I just think that type inference should be as complete as possible.
14:06:23 <PeakerWork> ksf: the dictionaries of which you speak are just an implementation detail, afaic
14:06:58 <Philonous> Btw. is there anything that prevents haskell from having instances based on what structure a type doesn't have? Like an instance for all types that are not functions?
14:07:11 <Cale> Yeah, the MR is the only thing in the whole standard which has anything to do with operational semantics.
14:07:52 <Cale> Philonous: What could you possibly do with the information about what type a value isn't?
14:10:14 <Cale> You still can't pattern match, and there would be no functions you could reasonably apply to a value based on that, apart from other class methods which were defined in the same way...
14:10:32 <Cale> I suppose it might be doable though.
14:10:40 <skorpan> i'd do it
14:10:42 <Philonous> Cale: I'd like to iterate over the arguments of a functions (for example count the number of rgument it takes). for that I need to tell if the b in (a->b) is itself a function
14:11:56 <dibblego> can you get higher kinds out of C++ templates?
14:12:22 <camio> dibblego, What do you mean by higher kinds?
14:12:32 <camio> dibblego, type functions?
14:12:36 <dibblego> type constructors of kind * -> *
14:12:52 <dibblego> can I express the signature of fmap?
14:13:11 <camio> dibblego, I've actually been working on exactly that. The answer is yes.
14:13:16 <PeakerWork> @type fmap
14:13:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:13:27 <dibblego> camio, may I see an example?
14:13:39 <PeakerWork> dibblego: not the type-class constraint, that's for sure :)
14:13:45 <camio> dibblego, Sure, you know of a c++ paste site?
14:13:45 <dibblego> PeakerWork, right
14:13:50 <PeakerWork> dibblego: I think templates have higher kinds though
14:13:58 <camio> PeakerWork, Yes including the type class constraint.
14:13:59 <dibblego> camio, http://paste.pocoo.org/+cpp
14:14:09 <Philonous> Cale: Or converting nested pairs to a list. It's doable if you add an instance for every base type you want to use.
14:14:20 <tvn2009> how do I string matching or find substring in haskell ?   for example   check if a string contains "abc"   ?
14:14:20 <PeakerWork> camio: how?
14:14:28 <Philonous> Cale: But obviously that's not what you want to do
14:14:32 <PeakerWork> camio: concepts were voted out
14:14:45 <camio> http://paste.pocoo.org/show/143880/
14:14:45 <dibblego> tvn2009, hint: isPrefixOf and tails
14:15:07 <dibblego> camio, thanks
14:15:11 <camio> PeakerWork, concepts is just syntax for something that already existed.
14:15:18 <camio> np
14:15:25 <camio> It may be useful to see an instance...
14:15:41 <dibblego> concepts are for emulating type-classes/implicit dictionary passing when I looked
14:15:47 <PeakerWork> camio: what already existed?
14:16:06 <camio> http://paste.pocoo.org/show/143882/ <- The IO monad instance.
14:16:19 <PeakerWork> camio: instead of constraints, it has duck-typing, afaik
14:17:04 <camio> PeakerWork: You can enforce that a type T has a meta<T> template specialization.
14:17:11 <dibblego> camio, how can the type-class instance be used implicitly, as in Haskell?
14:17:40 <camio> dibblego, I don't understand what you mean by implicitly.
14:17:43 <tvn2009> thanks dibblego
14:18:11 <dibblego> camio, type-classes are used implicitly as opposed to data structures explicitly; they are not passed as arguments
14:18:45 <PeakerWork> camio: can you implement a C++ compiler that uses dictionary passing instead of duck typing?
14:19:01 <dibblego> newtype Eq a = Eq (a -> Bool); forall :: Eq a -> [a] -> Bool -- explicit
14:19:26 <dibblego> class Eq a = where eq :: a -> a -> Bool; forall :: Eq a => [a] -> Bool -- impliciy
14:19:48 <camio> So it would be a template that takes a metafunction as a template argument, no?
14:21:17 <camio> Like the IO metafunction (combined with its unapply metafunction) provides what the Eq example does.
14:23:01 <frosty> so close, yet so far
14:23:16 <frosty> cabal-install is hanging (by the seems of it) when Linking when i run bootstrap.sh
14:23:42 <PeakerWork> frosty: linking, for some odd reason, is a really intense activity that takes a long time
14:23:51 <PeakerWork> frosty: its chewing lots of RAM too, not sure why
14:24:01 <frosty> hmm, I'll leave it going for a while longer then
14:24:02 <frosty> thanks :)
14:25:02 <ksf> ...so...
14:25:32 <ksf> who wants to write a haskell-src-fs that presents a r/w file-system interface to haskell source files?
14:26:01 <hackagebot> Vec-Transform 1.0.0 - Extends the Vec package with some 4x4 transform matrices (TobiasBexelius)
14:26:35 <jmcarthur_work> ooh, he's making some conveniences for GPipe
14:28:04 <ksf> maybe all those Zs are breaking ld's hash algo or something.
14:28:38 <data_jepp> Could anyone give me some starting hand with my evaluator? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4312#a4312
14:30:03 <ksf> start with var.
14:30:24 <ksf> ...and get the stuff around working, so you've got a simple repl.
14:30:25 <data_jepp> Okay, that would require a lookup in the table.
14:30:31 <ksf> then do let.
14:30:53 <ksf> ...you can start out with an initial environment.
14:31:02 <hackagebot> thrist 0.1.2 - Type-threaded list (GaborGreif)
14:31:47 <data_jepp> But for EVERY call I need to maintain the list so that get passed on, how do I do that?
14:32:31 <ksf> don't worry.
14:33:09 <ksf> Let Expr Expr Expr should be Let Char Expr Expr, btw.
14:33:34 <data_jepp> I know, but grammer is that way. And I'm not allowed to change the grammar :p
14:33:40 <ksf> you pass on the extended list into the evaluation of the second expression.
14:33:59 <Saizan_> ?hackage thrist
14:33:59 <lambdabot> http://hackage.haskell.org/package/thrist
14:34:15 <ksf> ...well, then you're going to define variables by chr'ing an expression that returns the ascii value of a character.
14:34:17 <data_jepp> ksf: omg, you are right.
14:34:21 <ksf> esoteric programming ftw.
14:34:53 <data_jepp> About the Let Char expr expr
14:35:45 <aug_triad> Hi. Are there a function like concatMap for monads? Like e.g. mapM?
14:36:07 <aug_triad> *is there :)
14:36:29 <data_jepp> ksf: how would I referer the content of the tuple?
14:36:30 <ksf> concatMap is []'s >>=
14:36:56 <ksf> just use lookup, like the hints say
14:37:37 <benmachine> @pl concatMap
14:37:37 <lambdabot> (=<<)
14:37:38 <ksf> evalProg (Var x) = lookup x
14:38:12 <data_jepp> ksf: hmm, so I dont need a varable on the left side to represent the list?
14:38:30 <ksf> :t lookup 'c'
14:38:31 <lambdabot> forall b. [(Char, b)] -> Maybe b
14:39:08 <ksf> ...the only thing that matters is that the types match. and if you remove "Expr" from evalProg's type, that one matches.
14:39:29 <Berengal> ... and that you've got the same amount of variables for each pattern
14:39:40 <ksf> iirc ghc will complain if you've got a different number of variables in one chunk of patterns, though.
14:40:10 <data_jepp> How do I add to the list if I don't have a variable for it?
14:40:20 <ksf> ...introduce one.
14:40:29 <aug_triad> ksf: what do you mean?
14:40:47 <Berengal> @src [] (>>=)
14:40:48 <lambdabot> xs >>= f     = concatMap f xs
14:41:06 <ksf> > (('a',1):) []
14:41:07 <lambdabot>   [('a',1)]
14:41:15 <ksf> :t (('a',1):)
14:41:16 <lambdabot> forall t. (Num t) => [(Char, t)] -> [(Char, t)]
14:41:27 <ksf> that's called an operator section.
14:41:52 <Philonous> aug_triad: I htink you will have to use liftM concat .: mapM (where (.:) = (.).(.))
14:41:56 <ksf> > let f = (('a',1):) in f . f . f . f $ []
14:41:57 <lambdabot>   [('a',1),('a',1),('a',1),('a',1)]
14:43:33 <data_jepp> what lookup finds needs to be put in an Int ?
14:43:51 <ksf> it's going to be an int, already.
14:44:00 <Berengal> a Maybe Int
14:44:08 <ksf> well a maybe int, but that's the same thing that you need to return.
14:44:23 <data_jepp> =)
14:45:20 <ksf> you _can_ do the Let Expr Expr Expr thing sanely, btw.
14:45:32 <Berengal> A ReaderT [(Char, Int)] Maybe would've worked nicely here...
14:45:35 <data_jepp> Let Char Expr Expr
14:45:53 <data_jepp> Hmm
14:46:20 <ksf> just start out with a initial environment of "zip ['a'..'z'] (map ord ['a'..'z'])"
14:46:47 <data_jepp> ksf: was that to me :S?
14:46:50 <ksf> ...and then use chr inside evalProg (Let...)
14:46:52 <ksf> yep.
14:47:07 <Berengal> ksf, you're talking madness... as in the resulting language would become pure cra<y
14:47:33 <Berengal> Yes, so crazy the zs go bonkers!
14:47:54 <ksf> no I'm only speaking truth. If that truth makes the instructor exercise his teeth on the edge of the desk, then so be it.
14:48:03 <Berengal> Hehe
14:48:08 <tredontho> hey, can somebody take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10554 and tell me what I'm missing?
14:48:24 <Berengal> Instead of names, there'd be memory locations
14:48:36 <Berengal> Computable memory locations
14:49:04 <ksf> ...indexed by unicode code point, but calculated as integers.
14:49:05 <fergie> I'm getting a ghci runtime linker error "I found a duplicate definition for symbol    fps_minimum" Google says I need to reinstall something and it will be fine. How do I find out what to reinstall?
14:49:08 <ksf> I'm fine with that.
14:49:27 <Berengal> ksf, the code point could be sugar...
14:49:48 <meese> hi, just wondering, is there any way to easily write long string constants in haskell like in C? like, in C you can do printf("foo bar" <linebreak> " baz bar\n"); and it will print "foo bar baz bar".
14:49:54 <Berengal> tredontho, you can't return two different index types. If you want to, you have to wrap them in an existential
14:50:19 <Berengal> > "foo bar \    \ <- newlines and space go there"
14:50:20 <lambdabot>   "foo bar  <- newlines and space go there"
14:50:23 <camio> tredontho, that or return an Either Integer (Integer,Integer)
14:50:37 <ksf> you're going to need an initial environment of "zip ['0'..'9'] [0..9]", anyway.
14:50:43 <ksf> and redefining those will be fun.
14:51:01 <meese> how do you do that without inserting newlines though?
14:51:12 <meese> inserting newlines into the string*
14:51:14 <jmcarthur_work> huh?
14:51:23 <fergie> meese: don't close the quotation marks
14:51:24 <Berengal> meese, nothing's inserted between the escapes
14:51:31 <aug_triad> Philonous: I have liftM concat mapM loadInput' parsed_paths; where mapM loadInput' parsed_paths just returns a list. What do you mean with (.:) = (.).(.) ?
14:51:53 <tredontho> Berengal can you please explain to me why it doesn't work, though?  Am I just not understanding how polymorphism works, here?
14:52:00 <meese> ah, I see
14:52:02 <meese> thanks
14:52:35 <meese> heh, screws up vim's syntax highlighting but oh well
14:52:53 <Saizan_> tredontho: when you have a type signature like "fromSignal :: Ix i => (Signal a) -> (Array i a)
14:53:08 <Saizan_> tredontho: it's the caller that can choose the type to use for 'i'
14:53:18 <Saizan_> tredontho: the body of the function can't choose
14:53:33 <tredontho> Saizan_ ahh, I see now
14:53:34 <Berengal> tredontho, when you have a function :: (Ix i) => i, you're saying "for all types 'i' that are in class Ix, I can return an i". What you want to say is "There exists some type 'i' in class Ix that I can return"
14:53:55 <meese> any way to do that with long numbers?
14:54:01 <tredontho> Thank you
14:54:41 <Berengal> meese, put them in a config file and load them...
14:55:11 * ksf should get a hold of his curcuma and get his rice kebab going, but he doesn't wanna.
14:55:31 <Berengal> meese, or, if you want to be real clever, input it as a string and call read on it
14:55:42 <stuhlbein> hi, i'm kinda new to haskell, so please forgive me if i'm asking completely bullcr*p ;) - anyway, i wonder if there is any special syntactical difference between declaring a variable (like `let helloworld = "Hello World"`) and declaring a function (like `let factorial n = if n == 0 then 1 else n * factorial (n - 1)`)?
14:55:54 <ksf> it's the perfect case of "wanna eat, don't wanna cook, too late to call the delivery service"
14:55:58 <Berengal> stuhlbein, not in syntax, no
14:55:59 <v0|d> ksf: rice & kebap? gee, what the heck?
14:56:04 <v0|d> ksf: try adana kebap.
14:56:07 <v0|d> :)
14:56:28 <ksf> "kebap" is the meat.
14:56:32 <ksf> it's not the bread.
14:56:37 <Berengal> stuhlbein, except the number of arguments, obviously ;)
14:56:42 <Philonous> aug_triad: (.:) is functional composition but the first functions takes two arguments before the result is fed into the other function. In your case you could also write liftM concat $ mapM loadInput' parsed_paths . (Btw. mapM doesn't return simple lists, it returns a monad action that computes a list)
14:56:45 <ksf> it's turkish for "something grilled"
14:57:07 <stuhlbein> Berengal: okay, so (yes, i'm not done with asking stupid questions :P), how would i do "int foo = 5;" in haskell? it doesn't seem to be trivial or something... (i'm also currently reading the tutorial)
14:57:42 <camio> stuhlbein: Variables aren't declared that way. Variables are declared with the mkIORef functions.
14:57:43 <ksf> ...the common way to eat it around here is as http://en.wikipedia.org/wiki/D%C3%B6ner_kebab
14:57:56 <stuhlbein> carlocci: mkIORef?
14:58:05 <Berengal> stuhlbein, you wouldn't, normally. The compiler will know it's an int without you telling it. Unless you use it as a float, or Integer, or any other number type, in which case it'll know it's that type instead
14:58:08 <ksf> which is usually shortened to "Dner", which makes even less sense as it means "turns"
14:58:10 <stuhlbein> camio: --^
14:58:19 <ksf> as in "something grilled rotates"
14:58:22 <Alpounet> pilav st dner rocks, definitely.
14:58:40 <stuhlbein> Berengal: okay, so it's  basically implicitly statically typed? that's actually nice :D
14:58:46 <camio> stuhlbein, sorry, I meant newIORef makes a variable.
14:58:58 <ksf> ...well, http://en.wikipedia.org/wiki/D%C3%B6ner_kebab#Germany
14:59:04 <ksf> germany's national dish.
14:59:19 <Berengal> stuhlbein, it's very nice, actually. You'll come to love it very soon
14:59:22 <stuhlbein> besides potatoes and bratwurst
14:59:31 <Philonous> stuhlbein: You can always add type annotations like so: foo = 5 :: Int  or  foo :: Int  foo = 5
14:59:33 <camio> stuhlbein, the typical top-level "a=b" syntax defines a value. It doesn't vary. Similar to the "const" prefix in other languages.
14:59:41 <stuhlbein> Berengal: i think so too, thank you :D
15:00:23 <stuhlbein> camio: okay
15:00:33 <ksf> well, you get potatoes everywhere, but it isn't a dish.
15:00:58 <ksf> ...try to find a saussage that's offered everywhere in germany. you won't find it.
15:01:02 <Berengal> camio, names denoting values are usually called variables in haskell, because they can still vary, but only inbetween function calls
15:01:25 <ksf> that's why they should be called bindings.
15:01:40 <Berengal> I usually call them bindings, or don't refer to them at all
15:01:42 <stuhlbein> ksf: i'm sure it's not too hard to get a weiner in pretty much any place in germany :P
15:01:52 <ksf> bavaria?
15:01:54 <camio> Berengal, oh I wasn't aware of that.
15:02:11 <ksf> around here, too. usually you get frankfurters.
15:02:22 <ksf> or polser
15:02:25 <ksf> (which are danish)
15:02:41 <ksf> rostbratwurst, too.
15:02:46 <stuhlbein> i'm not sure where "around here" is, so i suppose you're from frankfurt? :P
15:03:07 <ksf> hamburg
15:03:22 <Berengal> camio, references are usually called... references. They're values holding a reference to another value, and can change which value they reference
15:03:22 <stuhlbein> ooh, that's nice too, nice city anyway :P
15:03:35 <stuhlbein> so you're basically a hamburger :P
15:04:04 <ksf> well I'm glad I'm living just west of it, so I don't smell their streets all the time.
15:04:10 <ksf> I'm born there, but nothing more.
15:04:30 <Berengal> ... all this talk of food makes me hungry. Now I either need to get a hamburger, or go to sleep so I can buy breakfast in the morning
15:04:37 <aug_triad> Philonous: thank you!
15:05:06 <ksf> I don't eat much hamburgers.
15:05:14 <ksf> ...one or two per year, approx.
15:05:17 <camio> Hrm, this mixmatch of the same words meaning different things depending on the language must get beginners very confused.
15:05:32 <ksf> but we _do_ put our bbq steaks into buns before eating them.
15:06:09 <stuhlbein> hamburgers are people too, no need to eat them
15:06:15 <Saizan_> steaks into buns?
15:06:19 <ksf> not at all. "hamburger" and "hamburger" have a different pronounciation.
15:06:57 <ksf> Saizan_, sure. you don't want to burn your fingers, now do you?
15:07:12 <stuhlbein> real men eat steaks, unless it's homemade hamburgers :P
15:07:41 <Philonous> Maybe this is a good time to advertise for #haskell.de
15:07:53 <Saizan_> ksf: that's why we use forks and knives here!
15:07:56 <ksf> germany's got a huge diversity of different kind of buns.
15:08:22 <stuhlbein> Philonous: i didn't know a german haskell channel exists ;)
15:08:29 <ksf> Saizan_, I consider using forks and knives during a bbq as a capital offense.
15:08:31 * camio gets anxious for the next round of Haskell discussion.
15:08:45 <ksf> it's like yelling at me (or even asking) why I spice the steaks with beer.
15:08:53 <Saizan_> hehe
15:09:12 <Saizan_> camio is right, this should move to -blah if it continues :)
15:09:40 <data_jepp> Anyone up for making a working version of my evaluator? *angleEyes*
15:10:06 <noknok> Hi Haskell-people out there. It is midnight here in Amsterdam and for the last couple of hours I am trying to install additional Haskell modules, and I am getting pretty desparate by now.
15:10:19 <ksf> "different langues" is an interesting topic, though. http://en.wikipedia.org/wiki/Berliner_(pastry) is called "Berliner" nearly everywhere but in berlin.
15:10:38 <Berengal> noknok, what seems to be the problem?
15:10:51 <noknok> As a meta-installation to install anything at all, I went to http://haskell.org/cabal/download.html, extracted cabal-install-0.6.2.tar.gz and started the ./bootstrap.sh, which complained: The Haskell package 'parsec' is required but it is not installed. So I started synaptic, searched for parsec, but the installation wasn't possible either ... Can't seem to get started. I tried to install the whole new Haskell platform on my Ubuntu, but that
15:10:51 <noknok>  failed as well.
15:11:04 <mrsolo> in real world haskell using databases ... "When using lazy reading, it is critically important that you finish reading the entire data set before you attempt to close the connection or execute a new query." ...
15:11:09 <mrsolo> what will happen if we do not?
15:11:27 <Berengal> noknok, do you have ghc?
15:11:31 <dcoutts> noknok: have you got ghc installed?
15:11:34 <noknok> oui
15:11:41 <noknok> yet
15:11:42 <Saizan_> which version?
15:11:59 <fooman_> when I try to install hsp, cabal complains with "ghc: could not execute: trhsx", but it's in my path, and I can execute it just fine
15:12:17 <noknok> Berengal: version 6.10.4
15:12:29 <Saizan_> mrsolo: the content will get truncated, i believe
15:12:44 <Berengal> doesn't ghc come bundled with cabal already?
15:12:54 <dcoutts> Berengal: not the program
15:13:27 <noknok> Berengal: when I run cabal (from the shell) it says "not in scope"
15:13:27 <Saizan_> noknok: can you paste the log of how the haskell platform failed to install?
15:13:39 <Saizan_> @paste
15:13:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:14:59 <data_jepp> How do I prepend something to a list?
15:15:12 <noknok> Berengal: sorry, I made a mistake, ghci was still running, but when I run "cabal" from the shell, it says "command not found"
15:15:16 <Saizan_> > "something" ++ "list"
15:15:17 <lambdabot>   "somethinglist"
15:15:31 <data_jepp> that is concat, or is there no difference?
15:15:31 <Philonous> > 'a' : "bc"
15:15:32 <lambdabot>   "abc"
15:15:38 <data_jepp> there we are
15:15:39 <monadic_kid> does anyone know if hsc2hs can handle C casts expersions?
15:15:51 <Philonous> @type concat
15:15:52 <monadic_kid> *expressions
15:15:53 <lambdabot> forall a. [[a]] -> [a]
15:16:14 <monadic_kid> c2hs can't handle cast expressions
15:16:19 <Berengal> noknok, you're on ubuntu?
15:16:32 <monadic_kid> c2hs: "GenBind.evalConstCExpr: Casts are not implemented yet."
15:16:35 <Philonous> data_jepp: (:) prepends one element to a list (it's the list constructor), (++ ) concatenates two lists and concat concatenates a list of lists
15:16:37 <noknok> Berengal: yes, ubuntu
15:18:21 <noknok> Saizan, the terminal with the attempt to install the platform is lost.
15:18:32 <noknok> Do you want me to run it again?
15:18:34 <Berengal> noknok, I can't remember how I got ghc installed... but you could try to apt-get install ghc6. That should bring in cabal as well, unless I'm mistaken
15:18:37 <Berengal> Actually, let me check
15:18:54 <dcoutts> it does not bring in the 'cabal' program
15:19:13 <PeakerWork> data_jepp: a list is defined as "empty list" or "a head element cons'd to a tail list" where empty list is called [] and cons is called (:).  So [1,2,3] desugars to:  1 : 2 : 3 : []
15:19:20 <Saizan> noknok: either that or libghc6-network-dev from apt-get
15:19:32 <PeakerWork> data_jepp: and (:) is right-associative so 1 : 2 : 3 : []   is   1 : (2 : (3 : []))
15:19:48 <Berengal> dcoutts, grr
15:19:54 <PeakerWork> data_jepp: so if you want to add a single element to the beginning of a list, just use  x : your_list
15:19:56 <Berengal> I have no idea how I got cabal...
15:20:09 <Saizan> noknok: with should also install libghc6-parsec-dev as a dependency
15:20:11 <noknok> Berengal, I did that several times via synaptic; re-installed all sorts of things that appeared after a search of "haskell", but now it complains again and again about some dependencies and uninstalled packages.
15:20:24 <dcoutts> Berengal: if not from a distro package or the Haskell Platform then you probably installed it manually
15:20:37 <data_jepp> PeakerWork: but if the function is defined   evalProg :: Expr -> [(Char,Int)] ->  Maybe Int How do I access the list in the pattern?
15:21:27 <PeakerWork> data_jepp: evalProg expr [] = ... ; evalProg expr (x:xs) = ...
15:21:29 <Berengal> dcoutts, or I got it from 6.10.1, maybe?
15:21:46 <Saizan> noknok: if you don't tell us what the problems actually are it's difficult to help, if you can't get apt-get or synaptic to work then you could install those packages manually via their Cabal's Setup scripts
15:21:47 <PeakerWork> data_jepp: so your two patterns catch the two possible things a list can be, an empty list or a cons of head and tail
15:22:05 <data_jepp> PeakerWork: Thanks!!! I'll test it right away.
15:22:30 <Saizan> noknok: or ditch your installation of ghc from the ubuntu repos completely and use the binary package provided on the ghc website
15:22:42 <noknok> Saizan, I just did "sudo apt-get install libghc6-parsec-dev", but it stopped with "libghc6-parsec-dev: Depends: ghc6 (< 6.8.2+) but 6.10.4-1.0~ppa2 is to be installed"
15:22:47 <Saizan> noknok: it will contain these packages prebuilt
15:23:25 <Saizan> noknok: ok, then it seems the ubuntu repos didn't update the library packages to the new ghc
15:23:51 <Saizan> noknok: unless they are on some other repo you didn't add
15:24:09 <Saizan> noknok: what i proposed above still applies
15:24:18 <noknok> Saizan, how can I do that? Should I remove everything Haskell and start all over again?
15:25:04 <jkramer> Hello
15:25:23 <jkramer> Does anyone use Text.XHtml here?
15:25:32 <Saizan> noknok: basically, but restarting by installing the appropriate binary package from here http://www.haskell.org/ghc/download_ghc_6_10_4.html#binaries
15:25:46 <Raevel> jkramer: is it similar to Text.Html?
15:25:53 <jkramer> I think so
15:25:54 <Berengal> jkramer, I've used it some
15:26:14 <jkramer> I'm having a problem with prettyHTML and textarea
15:26:50 <jkramer> prettyHtml adds spaces in the textarea which are rendered literally, so I get ugly spaces prefilled in the textarea in the browser
15:27:01 <jkramer> Does anyone know a workaround? :)
15:27:03 <noknok> Can't I just install this over the old stuff, or do I really have to remove every thing, first? When I search for "haskell" in synaptic it lists a very long list of things.
15:27:46 <Saizan> noknok: this binary package will install in /usr/local/ so it should work by installing it over, yeah
15:27:47 <jkramer> Using renderHtml instead of prettyHtml seems to fix it, but then again, the rest of the HTML is kind of ugly :)
15:28:02 <Saizan> noknok: though the "old stuff" won't work with it
15:28:08 <Berengal> jkramer, why do you care about it being ugly?
15:28:31 <noknok> Saizan, I owe you! I am going to proceed as you suggested....
15:28:46 <jkramer> I just prefer nice things :)
15:29:02 <jkramer> The thing I'm working on is kind of a demo, so it would be cool if the HTML was readable
15:29:03 <Saizan> noknok: make sure "which ghc" points to the right one at the end
15:29:23 <Raevel> renderHtml does render it looking very wierd
15:29:28 <Saizan> noknok: then the bootstrap.sh script should work fine
15:29:50 <jkramer> Yup, it adds a linebreak before every >
15:29:59 <Berengal> jkramer, primHtml (renderHtmlFragment someTextarea)
15:30:59 <data_jepp> PeakerWork: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4313#a4313 How do work this out?
15:31:26 <jkramer> Berengal: Great, exactly what I was looking for :) Thanks a lot
15:32:11 <data_jepp> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4313#a4313 anyone can help me out :p
15:32:50 <Berengal> data_jepp, evalProg x to get a Maybe Int out of it, then pattern match on that
15:33:39 <PeakerWork> data_jepp: what is the list argument for?
15:34:26 <data_jepp> Berengal: what? :p :s
15:34:31 <Raevel> var declarations i presume
15:34:32 <fooman> why do I have to specify the full path to trhsx when it's definitely in my path?
15:34:44 <fooman> It's causing cabal scripts to break
15:34:46 <data_jepp> PeakerWork: variables in a let expression
15:34:52 <Berengal> data_jepp, case evalProg x of Just x' -> - x'; Nothing -> Nothing
15:35:41 <Saizan> fooman: how are you running cabal?
15:35:57 <fooman> "cabal install hsp"
15:36:05 <fooman> not as root
15:36:06 <PeakerWork> data_jepp: ah, its the lexical scope?
15:36:13 <data_jepp> PeakerWork: Jepp :D
15:36:22 <Saizan> if it's running as the same user it's weird
15:36:25 <PeakerWork> data_jepp: then your code seems right, just needs to pass along that scope to the recursive call
15:36:27 <Raevel> or dynamic?
15:36:34 <PeakerWork> data_jepp: and needs to apply the negation INSIDE the maybe
15:36:36 <fooman> Saizan: yeah I agree that it's weird :-P
15:36:38 <PeakerWork> data_jepp: to do that, you can use fmap
15:36:44 <Berengal> If I've understood his task right, there's only one scope, so it doesn't matter
15:36:45 <data_jepp> PeakerWork: gimme code :D
15:36:48 <PeakerWork> data_jepp: If you have (Maybe Int) from the recursive call...
15:36:55 <Saizan> fooman: are you sure the $PATH variable as you see it is propagated to subprocesses and it's not local to your current shell?
15:37:05 <PeakerWork> data_jepp: and you want to apply a function inside the Int in the maybe, you use   fmap func
15:37:20 <PeakerWork> data_jepp: so    fmap (0-)    applies negation inside a maybe
15:37:25 <Raevel> i'm thinking fmap is a little too advanced :-)
15:37:25 <Saizan> fooman: i.e. did you use export when setting it?
15:37:28 <data_jepp> Oh
15:37:32 <fooman> Saizan: it should be... it's in my .bash_profile, and when I run ghci and 'getEnv "PATH"' it says the right thing
15:37:49 <inaeternum> ---my program's main do-block first reads some information from a file. then I would like to make a bunch of definitions based on that file (e.g.: newfunc x = oldfund y x, where y is a value obtained from the file). do I really have to out all those definitions in the same main-block or can I put them somehow into another file?
15:37:52 <PeakerWork> data_jepp: evalProg (Neg x) scope = fmap (0-) (evalProg x scope)
15:38:46 <Berengal> inaeternum, the usual solution is to put it in the reader monad
15:39:44 <inaeternum> Berengal: thx, i'll check that out (still barely experience with monads ;-)
15:40:07 <PeakerWork> inaeternum: the general idea is that you pass it as arguments to the functions you want
15:40:24 <PeakerWork> inaeternum: and when passing arguments manually gets tedious, you use a monad just to automate the argument passing for you
15:41:21 <PeakerWork> inaeternum: a simple function value of type (a -> b)   is said to be an instance of the reader monad, reader of a's. You can combine readers of a using monadic operations
15:41:33 <Saizan> fooman: i can only say that "cabal install hsp" works here, but i don't know what the problem might be
15:41:42 <PeakerWork> > do { x <- (*2) ; y <- (+10) ; return (x,y) } 1
15:41:43 <data_jepp> PeakerWork: evalProg contains like one line for every datatype, so no I get "Equations give different arities for "evalProg""
15:41:43 <lambdabot>   <no location info>: parse error on input `1'
15:41:45 <fooman> Saizan: yeah, my .bash_profile says: export PATH="~/.bin:~/.cabal/bin:"$PATH
15:41:48 <PeakerWork> > do { x <- (*2) ; y <- (+10) ; return (x,y) } $ 1
15:41:49 <lambdabot>   (2,11)
15:42:19 <PeakerWork> inaeternum: notice how the "1" was passed to all the statements in the do block automatically
15:42:24 <Berengal> data_jepp, make sure every definition has the same amount of arguments on the left-hand-side
15:42:31 <PeakerWork> data_jepp: paste?
15:42:39 <fooman> Saizan: "ghc -F -pgmF ~/.cabal/bin/trhsx" works, but "ghc -F -pgmF trhsx" does not
15:43:03 <Saizan> fooman: i'm far from a bash expert, but i'd try using $HOME instead of ~ in your  export PATH="~/.bin:~/.cabal/bin:"$PATH
15:43:19 <Berengal> fooman, what about {-# OPTIONS_GHC -F -pgmF trhsx #-} inside the file?
15:43:25 <inaeternum> PeakerWork: I see, thx :-)
15:43:39 <data_jepp> PeakerWork: working on it, sec
15:44:04 <Saizan> fooman: maybe ghc won't interpret ~ as $HOME when seeing it in the $PATH
15:44:22 <PeakerWork> inaeternum: in the case of the simple function monad, I think it doesn't make that much sense to use this monad. There's a more general type class called Applicative that you can use instead
15:44:26 <fooman> Saizan: whatever. I just coppied trhsx to /usr/local/bin and it works
15:44:28 <fooman> Saizan: ah, let me experiment
15:44:33 <fergie> I have a ghci runtime linker error to do with bytestring. does anyone know which packages I will need to reinstall to make it go away?
15:44:39 <PeakerWork> inaeternum: though in your case, you want IO + Reader, so you can't use Applicative, so forget it :)
15:45:24 <Berengal> Are there applicative transformers?
15:45:35 <fergie> GHCi runtime linker: fatal error: I found a duplicate definition for symbol    fps_minimum
15:45:50 <data_jepp> PeakerWork: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4314#a4314
15:46:18 <PeakerWork> Berengal: you don't need them.. they compose more naturally
15:47:00 <Berengal> PeakerWork, how?
15:47:01 <PeakerWork> Berengal: For example, (liftA2 . liftA2) (+1)  can penetrate an IO (Maybe a) and act on the 'a', getting both the IO and Maybe effect
15:47:23 <Berengal> Hmmm....
15:47:35 <fooman> Saizan: yeah, that was it :-P
15:47:37 <PeakerWork> oops, that should be (+)
15:47:50 <PeakerWork> Berengal: or (liftA . liftA) (+1)
15:48:15 <PeakerWork> Berengal: do you see why Functor Transformers aren't necessary?
15:48:28 <Berengal> PeakerWork, yes. This makes sense now
15:48:42 <Berengal> Applicatives have no join
15:48:53 <Berengal> There's nothing to commute
15:49:15 <PeakerWork> much of what people use Monads for can be done with Applicatives
15:49:30 <Cale> Well, it's lucky that the composition of two applicatives is an applicative
15:49:39 <data_jepp> PeakerWork: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4314#a4314 *blink blink*
15:49:52 <PeakerWork> applicatives have liftAn, and (>>) and sequence, and many operations people use monads for, not noticing they never needed join/>>=
15:50:06 <Cale> But the fact that the composition of two functors is a functor is easier to see :)
15:50:08 <Berengal> I just wish there was a nicer notation for them
15:50:10 <mmorrow> Saizan: finally found my ATAPL book and read the relevant chapters on modules. all the references from when we were talking the other day are clear now
15:50:17 <PeakerWork> Berengal: I think "she" has
15:50:25 <PeakerWork> data_jepp: due to syntactic problems, you have to have the same number of patterns on left side
15:50:28 <Cale> Berengal: Conal has a TypeCompose library which does that.
15:50:33 <Berengal> PeakerWork, she does, but I don't have her
15:50:36 <PeakerWork> data_jepp: so in the Var case, you have to mention scope on both sides of =
15:51:13 <data_jepp> PeakerWork: how to do that without it changing it?
15:51:34 <PeakerWork> Cale: now that I think of it, it would be much nicer if monad transformers didn't require defining return/>>= but only join (since Applicative composition comes for free, and only join is needed to extend it to be a monad, too)
15:51:48 <fooman> ok, tildes in your PATH are BAD
15:51:51 <PeakerWork> data_jepp: evalProg (Var x) scope = lookup x scope
15:51:59 <noknok> Hi Saizan. I now downloaded the ghc again and installed it on my ubuntu according to the instructions. A "which ghc" returns "/usr/local/bin/ghc" and in this bin directory there is ghc etc, but no cabal. And running "cabal" from the shell still answers with an "unknown". Everything seems as it was in the first place. I am about to give up.
15:52:08 <PeakerWork> Cale: I guess that needs class aliases
15:52:23 <mmorrow> Saizan: i've made a repo with a modified (and to-be-replaced-with-a-modified-haskell-src-exts parser) haskell-src parser that i pulled from some other code, that has at least "signature" and "structure" additions to the haskell syntax
15:52:26 <Saizan> mmorrow: heh, i still have to finish those, i got sidetracked by wanting to implement some of the type systems
15:52:31 <Berengal> noknok, now you run the bootstrap.sh script
15:52:40 <Saizan> noknok: no
15:53:00 <Saizan> noknok: now you're in the right position to run the bootstrap.sh script from the cabal-install package
15:53:00 <noknok> Berengal, which one, you mean the cabal bootstrap?
15:53:22 <Cale> PeakerWork: You can also combine monads by defining a distributive law, though not all monad transformers come from a distributive law, as I understand it.
15:53:31 <noknok> Saizan, Berengal: ok, I'll try that.
15:53:42 <mmorrow> Saizan: with the intention of (1) modifying a haskell-src-exts parser to add what's needed, (2) define some mechanical compilation/translation of the resulting module lang into regular haskell modules
15:53:51 <gabor> tricky type class instance question: I have a 2 parameter type (P a b). Can I declare an instance so that for (a == b)  instance Monad (P a)   ?
15:53:52 <mmorrow> Saizan: http://moonpatio.com/repos/hs-modules/
15:55:02 <Saizan> mmorrow: heh the interesting part is the image of the translation in (2)
15:55:06 <Cale> If you have monads M and N and you want to make MN into a monad, you need a natural transformation join: MNMN -> MN. If you have a natural transformation dist: NM -> MN, then you can apply it to the middle NM to go from MNMN -> MMNN, and then apply join on the M's and join on the N's to get to MN
15:55:09 <jkramer> Anyone using HSQL.SQLite3?
15:55:24 <data_jepp> PeakerWork: How would the Tall be defined, it wont let me just add scope on each side? evalProg (Tall x) scope = x scope is no good
15:55:29 <mmorrow> Saizan: example of the syntax it has so far http://moonpatio.com/repos/hs-modules/examples/Example0.hs
15:55:37 <Cale> actually, the dist needs to satisfy some simple laws to ensure the result is a monad, but that's the idea anyway :)
15:55:37 <PeakerWork> Cale: interesting :)
15:55:40 <jkramer> toSqlValue doesn't seem to escape ticks correctly
15:55:44 <mmorrow> Saizan: right, i think it's totally doable
15:55:47 <Saizan> gabor: no, 'b' has to be free to be instantiated to any type
15:57:13 <gabor> Saizan: is there some way that both parameters are free and equal?
15:57:30 <mmorrow> Saizan: but it's also critical that the parser handle full haskell, because the translator may need to pass over the code and (say) replace references to nested modules with a ref to whatever thing it tranforms that into wrt regular haskell modules
15:57:37 <Saizan> mmorrow: yeah, there's a paper about translating translucent sums to System F, so it should be
15:58:05 <mmorrow> Saizan: right, i'm trying to collect as many papers with that exact topic
15:58:17 <mmorrow> *as many as i can find
15:58:30 <Saizan> gabor: newtype P' a = P' (P a a)
15:58:31 <mmorrow> to see what people've done
16:00:06 <gabor> Saizan: yeah, I was mentally going in that direction, but it may be ugly with that extra constructor (P')
16:00:11 <zou> can you do mallocBytes() then write arbitary bytes to the allocated buffer? is there an code example?
16:02:19 <mmorrow> Saizan: err, and Module.Syntax.{ListComp,Undo,Math} are technically unrelated, but they were tied to this Module.Syntax, so i figured i'd include them as well "just cuz"
16:02:54 <mmorrow> Saizan: maybe we can mess with alternate list comprehension and/or do-notation desugaring/translation to whatever as well
16:03:36 <mmorrow> (i think it'd be interesting to be able to turn them into *arbitrary* things, possibly having nothing to do with lists or monads)
16:03:41 <noknok> Berengal, Saizan: Sorry to bother you again and again and thank's for your time. I've now installed the cabal and that (after a lot of displayed lines) ended with "The 'cabal' program has been installed in /home/noknok/.cabal/bin" But now it recommends to add this directory to my PATH and I forgot how to do that.
16:05:02 <Berengal> noknok, in your home dir, echo 'export PATH=$PATH:~/.cabal/bin' >> .bashrc
16:05:14 <Saizan> use $HOME instead of ~
16:05:56 <Saizan> so you're sure it gets expanded by bash
16:06:29 <Saizan> mmorrow: i was thinking of this one: http://www.cs.rutgers.edu/~ccshan/xlate/xlate.pdf
16:07:00 <Saizan> mmorrow: list comprehensions into arbitrary things?
16:11:33 <mmorrow> Saizan: almost like quasiquoters-idea, you provide a function (Exp -> [Stmt] -> m Exp), and the translator'll transform those list comps you (somehow) indicate using your provided function
16:11:46 <mmorrow> Saizan: basically full syntactic macros
16:11:53 <mmorrow> same for "do"
16:12:56 <noknok> Saizan, Berengal: IT WORKS! If Haskell people are allowed in heaven, I am sure your place is save! Thank's a lot! I think, I'll manage from here to install more modules with cabal. ;-)
16:13:16 <Saizan> noknok: great :)
16:13:38 <noknok> Saizan: Great indeed!
16:14:02 <mmorrow> e.g., you could turn        [a[i] := a[i-1,j+2] | i <- [0..4], j <- [1..i-1]] into code that when run would pretty-print C code that would perform those array operation when compiled
16:14:29 <mmorrow> (to pick an "out there" example)
16:14:31 <Saizan> noknok: be sure to come back to ask if you get any problem with cabal-install, and also check the faq http://www.haskell.org/cabal/FAQ.html
16:15:19 <noknok> Saizan: yeah, I'll do that, thanks
16:15:56 <Saizan> mmorrow: that looks nice, recycling existing sugar instead of producing new one :)
16:16:00 <mmorrow> Saizan: oh nice link
16:17:36 <gabor> Saizan: thanks!
16:21:17 <Person_> >map(+)[1,2,3,4]
16:21:27 <Person_> >map(+1)[1,2,3,4]
16:22:03 <ivanm> Person_: need a space
16:22:07 <ivanm> > map succ [1..4]
16:22:08 <lambdabot>   [2,3,4,5]
16:22:11 <CalJohn> > map + [1..4]
16:22:12 <lambdabot>   Couldn't match expected type `(a -> b) -> [a] -> [b]'
16:22:12 <lambdabot>         against infer...
16:22:22 <Person_> > map(+1) map(-1)[1,2,3,4]
16:22:23 <lambdabot>   Couldn't match expected type `[a]'
16:22:23 <lambdabot>         against inferred type `(a1 -> b)...
16:22:24 <ivanm> > foldl' (+) 0 [1..4]
16:22:25 <lambdabot>   10
16:22:31 <CalJohn> ivanm: ;)
16:22:35 <Person_> >_<
16:22:41 <ivanm> > map succ $ map pred [1..4]
16:22:43 <lambdabot>   [1,2,3,4]
16:23:09 <Saizan> > map (+1) (map (subtract 1) [1,2,3,4])
16:23:10 <lambdabot>   [1,2,3,4]
16:23:14 <Saizan> > (-1)
16:23:16 <lambdabot>   -1
16:23:25 <ivanm> so, with this announcement that hashed-storage has been merged into darcs, does this mean the hashed-storage package on hackage is going the way of the dodo?
16:24:21 <Saizan> Person_: when you write "map(+1) map(-1)[1,2,3,4]" you're passing "(+1)", "map", "(-1)" and "[1,2,3,4]" as parameters to the first "map"
16:24:45 <benmachine> was the dodo merged into some other more successful species of bird?
16:24:56 <Saizan> Person_: the use of whitespace doesn't matter, you've to use parentheses
16:24:59 <ivanm> benmachine: heh
16:25:43 <Saizan> maybe by "merged" they mean they now use that package in all of darcs
16:27:01 <BMeph> benmachine: I think the dodo was merged into a more successful species of dog (if by "merged into" you'll accept "eaten by")...does that count? ;)
16:27:22 <benmachine> um, yes.
16:27:41 <ivanm> Saizan: they were already using it...
16:27:46 <ivanm> BMeph: heh
16:27:51 <Person_> > map(+1) (map(-1)[1,2,3,4])
16:27:52 <lambdabot>   No instance for (GHC.Num.Num (a1 -> a))
16:27:52 <lambdabot>    arising from a use of syntactic ...
16:28:10 <ivanm> Person_: you have to use (subtract 1)
16:28:16 <ivanm> (-1) is a number
16:28:22 <ivanm> > subtract 3 5
16:28:23 <lambdabot>   2
16:28:26 <ivanm> @src subtract
16:28:27 <lambdabot> subtract x y = y - x
16:28:30 <PeakerWork> (0-1) could be a nicer number
16:28:33 * BMeph feels hungry enough to "merge into" the whole refrigerator...but that sounds a little dangerous. ;p
16:28:53 <PeakerWork> refrigrator >>= bmeph
16:28:56 <ivanm> BMeph: no, you mean to have the refrigerator contents be merged into you
16:28:57 <Person_> map(+1) (map(*2)[1,2,3,4])
16:29:04 <ivanm> Person_: need >
16:29:05 <ivanm> ;-)
16:29:06 <Person_> > map(+1) (map(*2)[1,2,3,4])
16:29:07 <lambdabot>   [3,5,7,9]
16:29:09 <Person_> yeah yeah, i know
16:29:12 <Person_> wow, it worked
16:29:18 <PeakerWork> > map ((+1) . (*2)) [1,2,3,4]
16:29:20 <lambdabot>   [3,5,7,9]
16:29:31 * BMeph immediately books a flight to Soviet Russia
16:29:47 <ivanm> BMeph: unless there's a time machine handy, you're a tad late...
16:29:54 <PeakerWork> ivanm: no, his refrigirator eats people
16:29:58 <Saizan> also, it's better style to actually put spaces between the arguments
16:30:01 <ivanm> (then again, it appears Putin is wanting to turn the clock back anyway...)
16:30:19 <PeakerWork> > (map . map) (*2) [[1,2,3],[4,5,6]]
16:30:20 <lambdabot>   [[2,4,6],[8,10,12]]
16:30:31 <ivanm> PeakerWork: heh, show off
16:30:47 <PeakerWork> > (map . first . map) (*2) [[(1,2),(2,3),(3,4)],[(4,5),(5,6),(6,7)]]
16:30:49 <lambdabot>   Couldn't match expected type `([a], d)'
16:30:49 <lambdabot>         against inferred type `[a1]'
16:31:14 <PeakerWork> > (map . first . map) (*2) [([1,2,3], 5), ([4,5,6], 7)]
16:31:15 <lambdabot>   [([2,4,6],5),([8,10,12],7)]
16:31:23 <aavogt> @type map . map . first
16:31:24 <lambdabot> forall b c d. (b -> c) -> [[(b, d)]] -> [[(c, d)]]
16:31:37 <PeakerWork> @let each = map
16:31:38 <lambdabot>  Defined.
16:31:49 <PeakerWork> > (each . first . each) (*2) [([1,2,3], 5), ([4,5,6], 7)]
16:31:51 <lambdabot>   [([2,4,6],5),([8,10,12],7)]
16:31:57 <cads> BAAAAHAHAHAAH: http://xkcd.com/643/
16:32:31 <Person_> lol
16:33:02 <Person_> With great power comes great current times voltage?
16:33:09 <PeakerWork> @let nth 0 f (x:xs) = f x : xs ; nth n f (x:xs) = nth (n-1) f xs ; nth _ _ [] = error "Invalid index given to nth"
16:33:10 <lambdabot>  Defined.
16:33:23 <PeakerWork> > (nth 0 . first . each) (*2) [([1,2,3], 5), ([4,5,6], 7)]
16:33:24 <lambdabot>   [([2,4,6],5),([4,5,6],7)]
16:33:37 <ivanm> cads: methinks you're a bit behind the times...
16:33:44 <PeakerWork> > (nth 0 . first . each . fmap) (*2) [([Just 1,Nothing], 5), ([4,5,6], 7)]
16:33:46 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
16:33:46 <lambdabot>    arising from the lite...
16:34:10 <PeakerWork> > (nth 0 . first . each . fmap) (*2) [([Just 1,Nothing], 5), ([Just 4, Just 5], 7)]
16:34:12 <lambdabot>   [([Just 2,Nothing],5),([Just 4,Just 5],7)]
16:34:19 <PeakerWork> SECs are great :-)
16:34:30 <PeakerWork> records should come with accessors and SECs for their fields
16:35:08 <Cale> Securities and Exchange Commissions? :)
16:35:28 <CalJohn> i also enjoy SECS
16:36:11 <i-blis> cads: http://xkcd.com/645/
16:36:29 <Cale> ahaha, I was just about to link that same one :)
16:36:42 <Cale> Comic today's you confuses here click if.
16:39:04 <Person_> there's always this
16:39:11 <Person_> Let's test Haskell's floating point integrity!
16:39:20 <Person_> > (e^pi) - e
16:39:20 <cads> POSTFIXINS!!!!!
16:39:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:39:21 <lambdabot>    `GHC.Real.Integral a'
16:39:21 <lambdabot>   ...
16:40:09 <Person_> > (^ e pi) - pi
16:40:10 <lambdabot>   Couldn't match expected type `a -> b'
16:40:10 <lambdabot>         against inferred type `Simple...
16:40:14 <Person_> haha FAIL
16:42:01 <Saizan> > (exp 1 ^ pi) - exp 1
16:42:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:42:02 <lambdabot>    `GHC.Float.Floating a'
16:42:02 <lambdabot>  ...
16:42:10 <Saizan> > (exp 1 ** pi) - exp 1
16:42:12 <lambdabot>   20.42241080432022
16:42:18 <gOcOOl> so when the documentation says getContents is IO lazy, the amount of stuff getContents actually fetches at one time is dependent on the context in which it's being fetched or does it always fetch one line at a time?
16:42:57 <i-blis> > exp pi - exp 1
16:42:58 <lambdabot>   20.422410804320222
16:43:28 <Cale> gOcOOl: it reads as characters from the resulting string are demanded
16:43:34 <Saizan> gOcOOl: i think ti fetches a Char at a time depending on how you force it, but there's always the system buffering that interferes with that
16:43:42 <Person_> > exp pi - pi
16:43:43 <lambdabot>   19.999099979189474
16:43:55 <Saizan> see hSetBuffering and stdin
16:43:55 <Person_> > (exp pi - pi) == 20
16:43:56 <lambdabot>   False
16:44:00 <Cale> > exp (pi * sqrt(163)) :: CReal
16:44:02 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
16:44:04 <Person_> Haskell fail!
16:44:09 <Person_> (exp pi - pi ) == 20
16:44:18 <Person_> > (exp pi - pi) == 20
16:44:19 <lambdabot>   False
16:44:28 <Person_> lambdabot has spoken
16:44:32 <Cale> > exp pi - pi :: CReal
16:44:33 <Saizan> s/Haskell/machine floats/
16:44:33 <lambdabot>   19.9990999791894757672664429846690444960689
16:44:46 <Cale> It's actually not 20
16:44:50 <Cale> It's just close
16:45:31 <Cale> It would be a fun thing to try to prove by hand.
16:45:42 <Cale> Kind of brutal :)
16:48:38 <Saizan> we could use roconnor's exact contructive reals in coq :)
16:50:14 <Cale> I used CReal which works reasonably well :)
16:50:24 <Cale> Oh, you mean to do the proof?
16:51:02 <Cale> The fun part is trying to figure out what approximations to take by hand. Computers make it easy to overkill :)
16:51:19 <Cale> > exp (pi * sqrt 37) :: CReal
16:51:20 <lambdabot>   199148647.9999780465518567665009238753359004336659
16:51:22 <Saizan> i think a proof of that would just be given by evaluation, but you also have a proof of correctness for the implementation
16:51:33 <Cale> > exp (pi * sqrt 58) :: CReal
16:51:35 <lambdabot>   24591257751.9999998222132414695761923552658122276102
16:51:47 <Cale> > exp (pi * sqrt 67) :: CReal
16:51:48 <lambdabot>   147197952743.9999986624542245068292613125786285081833
16:53:49 <aavogt> Saizan: and a proof of the correctness of your proof...
16:55:29 <PeakerWork> > 5:+6
16:55:31 <lambdabot>   5.0 :+ 6.0
16:55:45 <Cale> > exp (pi * sqrt 652) :: CReal
16:55:45 <benmachine> @type (:+)
16:55:46 <PeakerWork> > exp 1 ** (pi * 0:+1)
16:55:46 <lambdabot>   68925893036109279891085639286943768.0000000001637386442092346075723290625709
16:55:47 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
16:55:47 <lambdabot>   0.5403023058681398 :+ 0.8414709848078965
16:56:09 <Cale> > exp (pi * sqrt 1467) :: CReal
16:56:09 <benmachine> does Complex not do gaussian integers then?
16:56:10 <lambdabot>   18095625621654510801615355531263454706630064771074975.999999990123693671241...
16:56:22 <benmachine> well it does but not
16:56:26 <benmachine> in the way I am thinking
16:57:06 <narens> What is the best way to represent a simple 2D matrix using just the standard libraries?
16:57:08 <Cale> It doesn't do Gaussian integers because abs is foolishly in the Num class
16:57:15 <benmachine> oh
16:57:17 <benmachine> how foolish
16:57:40 * benmachine implemented abs as error "don't be silly"
16:57:49 <aavogt> @notsmack
16:57:49 <lambdabot> :)
16:58:05 <benmachine> hah
16:58:24 * notsmack always enjoys that  (and so does LB)
16:58:56 <benmachine> imo lambdabot should stop its arcane divination of people's typos
16:59:07 <benmachine> @info do x
16:59:08 <lambdabot> x
16:59:17 <benmachine> @info do { x; y }
16:59:18 <BMeph> @godsmack
16:59:18 <lambdabot> x >> y
16:59:19 <lambdabot> Unknown command, try @list
16:59:33 <benmachine> @info do { (x:xs) <- x; y }
16:59:33 <lambdabot> x >>= \ a -> case a of { (x : xs) -> y; _ -> fail ""}
16:59:39 <ksf> do we have a ready-to-use tool to measure line count with and without comments?
16:59:42 <BMeph> Drat, three off. Pity... ;)
16:59:46 <ksf> ...with and without checks, too.
16:59:47 <aavogt> benmachine: so @info is really @undo?
16:59:52 <benmachine> aavogt: apparently
17:00:12 <benmachine> wouldn't believe how long it took me to work that out
17:00:12 <benmachine> I was doing
17:00:12 <benmachine> @info Num
17:00:12 * Cale wonders if there is an n such that exp (pi * sqrt n) is closer to an integer than when n = 163
17:00:13 <lambdabot> Num
17:00:19 <benmachine> and it just does that^
17:00:31 <benmachine> hey hold on
17:01:20 <Adv_Dretch> @info ACTION plib
17:01:21 <lambdabot>  Illegal character ''\SOH''
17:01:21 <lambdabot>  at "ACTI..." (column 1)
17:01:25 <benmachine> aw
17:02:38 <Cale> Well, apart from n = 0 ;)
17:04:49 <Cale> > let x = exp (pi * sqrt 163) in -log (abs (x - round x))
17:04:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:04:50 <lambdabot>    `GHC.Float.Floating a'
17:04:50 <lambdabot>  ...
17:05:07 <Cale> > let x = exp (pi * sqrt 163) in -log (abs (x - fromInteger (round x))) :: CReal
17:05:09 <lambdabot>   27.9187999893296374403275376667769324952737
17:05:20 <mmorrow> , fmap (uncurry (flip (-)) . zip`ap`tail . fmap ((pi *) . sqrt . fromIntegral) $ [0..]
17:05:21 <lunabot>  luna: parse error (possibly incorrect indentation)
17:05:29 <mmorrow> , fmap (uncurry (flip (-))) . zip`ap`tail . fmap ((pi *) . sqrt . fromIntegral) $ [0..]
17:05:30 <lunabot>  luna: precedence parsing error
17:05:36 <mmorrow> , fmap (uncurry (flip (-))) . (zip`ap`tail) . fmap ((pi *) . sqrt . fromIntegral) $ [0..]
17:05:38 <lunabot>  [3.141592653589793,1.301290284568573,0.998515154544287,0.8417872144769332...
17:06:09 <narens> anyone? A good way to represent a 2D matrix using standard libraries? Just need one to perform the Warshall algorithm on it for transitive closure.
17:06:18 <Cale> @let score n = -log (abs (x - fromInteger (round x))) :: CReal where x = exp (pi * sqrt n)
17:06:19 <lambdabot>  Defined.
17:06:44 <mmorrow> , 4
17:06:48 <Saizan_> narens: one of the arrays?
17:06:51 <lunabot>  4
17:07:18 <narens> Saizan_: hmm, i wanted to avoid that.
17:07:26 <Saizan_> narens: if you use tuples has indices you get multidimensional ones
17:07:55 <narens> Saizan_: Yea but, in this particular algorithm I need to get an entire matrix row easily and update it
17:07:58 <Cale> > [(n,score n) | n <- [1..]]
17:08:01 <lambdabot>   [(1.0,1.9611776774319143880929420933932289672338),(2.0,3.927379149431429976...
17:08:34 <Alpounet> @type score
17:08:35 <lambdabot> CReal -> CReal
17:08:38 <narens> Saizan_: tbh, I haven't used arrays and that's the stupid reason I am avoiding it. I usually just do something with maps
17:08:39 <Alpounet> @src score
17:08:40 <lambdabot> Source not found. Maybe you made a typo?
17:08:53 <Cale>  score n = -log (abs (x - fromInteger (round x))) :: CReal where x = exp (pi * sqrt n)
17:09:03 <Alpounet> nice, a new bot heh
17:09:09 <Alpounet> Thanks Cale :-)
17:09:15 <mmorrow> , sortBy (compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> abs (x - (fromIntegral . round) x)) . fmap ((pi *) . sqrt . fromIntegral) $ [0..]
17:09:17 <Cale> > score 163
17:09:17 <lunabot>  [(0,0.0),(58062,1.9328896996739786e-5),(76690,2.211520552464208e-5),(1276...
17:09:19 <lambdabot>   27.9187999893296374403275376667769324952737
17:09:34 <Cale> ^^ see if you can find an integer n which beats that score :)
17:09:39 <Saizan_> narens: you could also use nested lists, depending on the operations you need
17:09:45 <Cale> (a positive integer)
17:09:50 <Saizan_> narens: and how much you care about performance
17:10:12 <Cale> > maximum (map score [1..10000])
17:10:13 <mmorrow> , let score n = let x = exp (pi * sqrt n) in -log (abs (x - fromInteger (round x))) in score 58062
17:10:14 <lunabot>  NaN
17:10:17 <lambdabot>   mueval-core: Time limit exceeded
17:10:20 <Cale> > maximum (map score [1..1000])
17:10:23 <narens> Saizan_: Well, I care about perf on this one. Because the algorithm itself is order of n^2
17:10:24 <lambdabot>   mueval-core: Time limit exceeded
17:10:37 <Cale> It takes annoyingly long to evaluate the things though :P
17:10:50 <Alpounet> > head . sort . map score $ [1..1000]
17:10:55 <lambdabot>   mueval-core: Time limit exceeded
17:10:58 <Alpounet> > head . sort . map score $ [1..100]
17:11:03 <lambdabot>   mueval-core: Time limit exceeded
17:11:06 <narens> Saizan_: There will be lots of updates, so a list won't work. So, If I am using an array would I be using the STArray?
17:11:07 <Alpounet> huh
17:11:08 <Cale> > score 58062
17:11:11 <lambdabot>   3.2593671121226904196019654073355740137833
17:11:25 <mmorrow> oh hmm, what are we testing again?
17:11:39 <mmorrow> oh, exp
17:11:46 <Cale> It's a measure of how close exp (pi * sqrt n) is to an integer
17:11:54 * mmorrow forgot the exp
17:12:01 <Randroid> I'm sure this has been asked a thousand times, but has anyone gotten GHC to compile on Snow Leopard? My whole Haskell tool chain is dead.
17:12:12 <Alpounet> > score 164
17:12:13 <mmorrow> , sortBy (compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> abs (x - (fromIntegral . round) x)) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..]
17:12:14 <lambdabot>   5.9246942050373051538644272681666153614533
17:12:16 <lunabot>  [(99999,NaN),(99998,NaN),(99997,NaN),(99996,NaN),(99995,NaN),(99994,NaN),...
17:12:19 <mmorrow> heh
17:12:22 <Randroid> I've talked to my therapist and she assures me I can get through it.
17:12:25 <Cale> Must use CReal
17:12:34 <mmorrow> , filter (not . isNaN . snd) . sortBy (compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> abs (x - (fromIntegral . round) x)) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..]
17:12:37 <lunabot>  [(0,0.0),(117,0.0),(128,0.0),(129,0.0),(130,0.0),(131,0.0),(132,0.0),(133...
17:12:44 <mmorrow> :(
17:13:01 <mmorrow> we need gmp arb-precision floating point
17:13:58 <Cale> Randroid: http://hackage.haskell.org/trac/ghc/ticket/3400
17:14:11 <Randroid> Thanks, Cale.
17:14:20 <mmorrow> , exp (pi * sqrt 2)
17:14:21 <lunabot>  85.01969522320721
17:14:50 <arsenm> mmorrow: http://hackage.haskell.org/package/hmpfr
17:14:51 <mmorrow> , let x = exp (pi * sqrt 2) in abs (x - (fromIntegral . round) x)
17:14:52 <lunabot>  1.9695223207207846e-2
17:14:55 <Alpounet> > let go n = if score n < 27 then go (n+1) else (n, score n) :: go (n+1) in head . go $ 0
17:14:57 <lambdabot>   Couldn't match expected type `(+) n GHC.Generics.Unit'
17:14:57 <lambdabot>         against infe...
17:15:08 <mmorrow> i don't get what's happening with the NaNs?
17:15:14 <mmorrow> arsenm: ooh
17:15:32 <Alpounet> huh
17:15:49 <Cale> mmorrow: loss of precision
17:15:57 * ddarius just used filterM (const [True, False]) for a practical purpose.
17:15:58 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
17:15:59 <mmorrow> , let go n = let x = exp (pi * sqrt n) in abs (x - (fromIntegral . round) x) in fmap go [0..]
17:16:00 <lunabot>  [0.0,0.1406926327792668,1.9695223207207846e-2,0.23541168085424147,0.49165...
17:16:11 <mmorrow> oh, there're coming from "score"
17:16:25 * mmorrow thought he was losing his mind for a second there
17:16:33 <mmorrow> oh no
17:16:42 <Cale> Double precision floating point will fail miserably here.
17:17:05 <mmorrow> , filter (not . isNaN . snd) . sortBy (compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> abs (x - (fromIntegral . round) x)) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..]
17:17:08 <lunabot>  [(0,0.0),(117,0.0),(128,0.0),(129,0.0),(130,0.0),(131,0.0),(132,0.0),(133...
17:17:09 <Cale> @let f n = exp (pi * sqrt n) :: CReal
17:17:10 <lambdabot>  Defined.
17:17:11 <mmorrow> oh!
17:17:14 <Cale> > f 163
17:17:16 <lambdabot>   Ambiguous occurrence `f'
17:17:16 <lambdabot>  It could refer to either `L.f', defined at <local...
17:17:18 <Cale> er
17:17:19 * mmorrow is a foool!
17:17:20 <Cale> d'oh
17:17:26 <Cale> @undef
17:17:27 <mmorrow> , filter (not . isNaN . snd) . sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> abs (x - (fromIntegral . round) x)) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..]
17:17:29 <lunabot>  [(116,0.5),(123,0.5),(127,0.5),(76,0.4971923828125),(4,0.4916555247646101...
17:17:37 <Cale> @let score n = -log (abs (x - fromInteger (round x))) :: CReal where x = exp (pi * sqrt n)
17:17:38 <lambdabot>  Defined.
17:17:51 <Alpounet> > score 100
17:17:52 <lambdabot>   3.5400664040215275249410727144125807432919
17:17:56 <Alpounet> 'kay
17:18:01 <Cale> > exp (pi * sqrt 163)
17:18:03 <lambdabot>   2.6253741264076826e17
17:18:06 <Cale> > exp (pi * sqrt 163) :: CReal
17:18:07 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
17:18:13 <Cale> > round (exp (pi * sqrt 163))
17:18:14 <lambdabot>   262537412640768256
17:18:22 <Cale> > round (exp (pi * sqrt 163) :: CReal)
17:18:23 <lambdabot>   262537412640768744
17:18:55 <mmorrow> well since we can't use CReal to search, i figure resorting to Double is the only way ;)
17:19:25 <Alpounet> > filter (flip (>) 27 . score) [1..100]
17:19:29 <lambdabot>   mueval-core: Time limit exceeded
17:19:35 <Alpounet> > filter (flip (>) 27 . score) [1..10]
17:19:37 <lambdabot>   []
17:19:44 <Alpounet> of course...
17:20:02 <mmorrow> lunabot gets hmpfr
17:21:17 <Alpounet> > score 42
17:21:17 <mmorrow> Cale: ah, score's using log
17:21:18 <lambdabot>   3.50202949731637587309040841125915315331
17:22:29 <mmorrow> , filter (not . isNaN . snd) . sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> -log (abs (x - (fromIntegral . round) x))) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..]
17:22:32 <lunabot>  [(0,Infinity),(117,Infinity),(128,Infinity),(129,Infinity),(130,Infinity)...
17:22:39 <mmorrow> , isInf
17:22:40 <lunabot>  luna: Not in scope: `isInf'
17:22:42 <mmorrow> , isInfinity
17:22:44 <lunabot>  luna: Not in scope: `isInfinity'
17:22:49 <mmorrow> sigh
17:22:53 <mmorrow> what is that one?
17:22:58 <mmorrow> , isInfinite
17:22:59 <lunabot>  luna: No instance for (GHC.Show.Show (a -> GHC.Bool.Bool))
17:23:19 <Alpounet> > let go n = (n, score n > 20) :: (go (n+1)) in take 2 $ go 0
17:23:21 <lambdabot>   Couldn't match expected type `(+) n GHC.Generics.Unit'
17:23:21 <lambdabot>         against infe...
17:23:33 <mmorrow> , filter (\(_,x) -> (not . or) [isNaN x,isInfinite x]) . sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> -log (abs (x - (fromIntegral . round) x))) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..]
17:23:36 <lunabot>  [(37,10.722029327800417),(58,10.279424672742795),(67,8.605448239171125),(...
17:23:36 <Alpounet> @type score
17:23:38 <lambdabot> CReal -> CReal
17:23:51 <Alpounet> > (1 :: CReal) + 1
17:23:53 <lambdabot>   2.0
17:23:55 * mmorrow gives up on double
17:24:46 <Alpounet> > fix score
17:24:50 <lambdabot>   mueval-core: Time limit exceeded
17:24:51 <Alpounet> heh
17:26:04 <mmorrow> Cale: is there no way to phrase "score" so that the ordering is preserved without needing the precision?
17:26:38 <narens> could anyone point me to a good resource for understanding how Arrays in Haskell work?
17:27:41 <Cale> mmorrow: seems hard without some major insight into the problem
17:27:51 <mmorrow> oh nice, hmpfr has an ST interface too
17:28:07 <Alpounet> where is CReal defined ?
17:28:13 <Cale> mmorrow: Especially since the number we're trying to beat is already so damn close to an integer.
17:28:24 <Cale> Alpounet: in the numbers package in Data.Number.CReal
17:28:29 <Alpounet> okay thanks
17:28:29 <Lemmih> narens: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html ?
17:29:05 <mmorrow> hmm, which if these do people think is best for lunabot? Data.Number.MPFR.Instances.Down Data.Number.MPFR.Instances.Near Data.Number.MPFR.Instances.Up Data.Number.MPFR.Instances.Zero
17:29:09 <Alpounet> @type fix
17:29:11 <lambdabot> forall a. (a -> a) -> a
17:29:21 <mmorrow> (their mutually exclusive on account of each defining a Num for MPFR)
17:29:24 <mmorrow> *they're
17:29:39 <mmorrow> Neat i guess
17:29:42 <mmorrow> NEar
17:30:19 <Cale> narens: hmm
17:30:30 <Alpounet> @index fix
17:30:30 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
17:30:31 <Cale> narens: Well, you should at least know about the haddock docs.
17:30:38 <mmorrow> , pi :: MPFR
17:30:40 <lunabot>  luna: Ambiguous occurrence `pi'
17:30:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
17:34:34 <narens> Cale: Yea, sorry. Going crazy.
17:34:58 <mmorrow> , pi :: MPFR
17:35:00 <lunabot>  luna: <command line>: can't load .so/.DLL for: mpfr (libmpfr.so: cannot o...
17:35:22 <mmorrow> slowly but surely
17:37:02 <mmorrow> , pi :: MPFR
17:37:03 <lunabot>  luna: <command line>: can't load .so/.DLL for: mpfr (libmpfr.so: cannot o...
17:37:16 <Alpounet> isn't there a parallel map somewhere ?
17:37:16 <Cale> narens: Basically, arrays are structures which are best used when you can construct them once and then read from them a whole bunch. Updates on immutable arrays are not usually so efficient. One nice thing though is that it's possible to define arrays whose elements are evaluated lazily -- so they can even be recursive.
17:38:07 <sproingie> isn't the whole hashtable benchmark business a product of the gc not being happy with arrays?
17:38:10 <mmorrow> if the mutable array is on unboxed non-pointers it's ok though
17:38:11 <Cale> narens: The basic way to build an array is by using the array function with a pair consisting of the bounds of the array (for rectangular arrays, that'll be something like ((0,0),(m,n)))
17:38:28 <narens> Cale: great, exactly what I wanted to know. So, you say they are no good for updating them a lot?
17:38:34 <mmorrow> sproingie: that's just the interaction of generational GC with mutable arrays of GC-followed pointers
17:38:44 <narens> Cale: so, no good for a matrix?
17:38:46 <Cale> narens: Well, they're immutable, so updating makes a 'copy'
17:38:56 <narens> Cale: what about MArray?
17:38:57 <Cale> That's not to say they're not a good matrix representation.
17:39:02 <Cale> MArrays are mutable
17:39:11 <mmorrow> narens: STUArray is what you want
17:39:14 <sproingie> mmorrow: ah.  that would be thrashy on almost anything.
17:39:42 <Cale> narens: If you have dense matrices and you're, say, multiplying them, you're almost certainly multiplying them into a new array anyway
17:40:02 <narens> mmorrow: I just followed the Linear Bloom Filter example from real world haskell to learn about arrays
17:40:26 <Cale> narens: Another decent option is Data.Map
17:40:43 <Cale> Data.Map, while immutable, has fast updates
17:40:56 <narens> Cale: tbh, all I want to do is to run the Warshall algorithm on the matrix. Its a pretty simple alg... and the main thing I need to do is to be able to read a matrix row and update it.
17:41:16 <Cale> Isn't that a graph algorithm?
17:41:19 <narens> Cale: I might just end up using Map, perhaps indexed by (x,y)
17:41:33 <narens> Cale: Yea, well, I am representing it as an adj matrix
17:42:10 <mmorrow> , pi :: MPFR
17:42:12 <lunabot>  luna: <command line>: can't load .so/.DLL for: mpfr (libmpfr.so: cannot o...
17:42:13 <mmorrow> gah!
17:42:22 <mmorrow> oh
17:42:52 <Alpounet> Cale, no higher score than 29.7[...] between 1 and 1000
17:43:52 <mmorrow> , pi :: MPFR
17:43:54 <lunabot>  3.141592653589793
17:43:56 <mmorrow> woo
17:43:58 <Alpounet> yay
17:44:18 <Cale> narens: I don't think it should be too bad to use arrays for Floyd-Warshall, since you're essentially constructing an entirely new array on each iteration anyway.
17:44:27 <Alpounet> , (pi :: MPFR)**100
17:44:27 <lunabot>  5.187848314319592e49
17:44:55 <mmorrow> , 1e-42 :: MPFR
17:44:56 <lunabot>  1.0e-42
17:45:00 <mmorrow> , 1e-42000 :: MPFR
17:45:02 <narens> Cale: But, before I run the FW alg... I am running an another alg which does other things with it first.
17:45:04 <lunabot>  1.0e-42000
17:45:10 <mmorrow> , 1e-42000 :: Double
17:45:12 <lunabot>  0.0
17:45:14 <mmorrow> :)
17:45:25 <Alpounet> heh
17:45:58 <narens> Cale: But, I will try both ways ;-). Will give me good chance to use an array.
17:46:03 * Alpounet trying to get more computations, more quickly, with Control.Parallel.Strategies
17:46:07 <mmorrow> , filter (\(_,x) -> (not . or) [isNaN x,isInfinite x]) . sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . take 100000 . fmap (\x -> -log (abs (x - (fromIntegral . round) x))) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..] :: [(Int,MPFR)]
17:46:08 <lunabot>  luna: Ambiguous occurrence `isNaN'
17:46:13 <mmorrow> stab me with forks!
17:46:14 <Cale> narens: Probably best to use strict arrays in that case (UArray), because then you don't have to worry about whether all the cells on each iteration are causing old versions of the array to be retained in memory
17:46:42 <narens> Cale: And I only need to hold 0 or 1.
17:46:57 <Alpounet> mmorrow, for the moment I'm experimenting -- this is my first use of Control.Parallel.Strategies
17:47:00 <mmorrow> , isInfinite
17:47:01 <lunabot>  luna: Ambiguous occurrence `isInfinite'
17:48:00 <mmorrow> ah ok i get it. just hide everything but the MPFR type in the main module, then import the instance module
17:49:05 <mmorrow> , isNaN (pi :: MPFR)
17:49:05 <lunabot>  ./luna: error while loading shared libraries: libmpfr.so.1: cannot open s...
17:59:46 <hackagebot> HXQ 0.18.1 - A Compiler from XQuery to Haskell (LeonidasFegaras)
18:01:27 * SamB_XP woulda thought the other direction more useful ;-P
18:02:13 <Alpounet> heh
18:02:27 <Alpounet> categorial XQuery'd definitely be fun.
18:02:29 <Alpounet> +c
18:03:47 <hackagebot> hunit-gui 0.1.1 - A GUI testrunner for HUnit (KimWallmark)
18:10:07 <mmorrow> , sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . filter (\x -> (not . or) [isNaN x,isInfinite x]) . take 400 . fmap (\x -> -log (abs (x - (fromIntegral . round) x))) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..] :: [(Int,MPFR)]
18:10:10 <lunabot>  [(16,5.639753911490384),(21,5.624681184307317),(17,4.954758357858625),(5,...
18:10:46 <ivanm> does " {-!!!!!!!-}" mean that mmorrow is really bored? :p
18:11:55 <mmorrow> it means that it was one of many glitches that turned into an epic to get MPFR working in lunabot
18:11:57 <mmorrow> :)
18:12:15 <mmorrow> writing instances of RealFloat are a total pita btw :)
18:12:31 <mmorrow> the odd thing is, this is non-deterministic apparently
18:12:32 <mmorrow> , sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . filter (\x -> (not . or) [isNaN x,isInfinite x]) . take 400 . fmap (\x -> -log (abs (x - (fromIntegral . round) x))) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..] :: [(Int,MPFR)]
18:12:35 <lunabot>  [(103,33.23773799203455),(109,31.82336616222842),(100,31.8232190596819),(...
18:12:36 <mmorrow> , sortBy (flip {-!!!!!!!-} compare `on` snd) . zip [0..] . filter (\x -> (not . or) [isNaN x,isInfinite x]) . take 400 . fmap (\x -> -log (abs (x - (fromIntegral . round) x))) . fmap (exp . (pi *) . sqrt . fromIntegral) $ [0..] :: [(Int,MPFR)]
18:12:38 <lunabot>  [(105,71.5934976339708),(16,5.639753911490384),(21,5.624681184307317),(36...
18:12:41 <mmorrow> hmm
18:12:55 <ivanm> heh
18:13:03 <ivanm> what is MPFR? Multi Precision Floating ???
18:13:04 <mmorrow> at least it works!!!@
18:13:08 <mmorrow> yeah
18:13:17 <ivanm> R_______ = ?
18:13:20 <mmorrow> <arsenm> mmorrow: http://hackage.haskell.org/package/hmpfr
18:13:37 <mmorrow> , 1e-4200000000 :: MPFR
18:13:43 <lunabot>  Killed.
18:13:46 <mmorrow> , 1e-4200000 :: MPFR
18:13:49 <EvilTerran> ivanm, ...epresentation?
18:13:52 <lunabot>  luna: out of memory (requested 2097152 bytes)
18:13:54 <mmorrow> , 1e-42000 :: MPFR
18:13:58 <lunabot>  1.0e-42000
18:14:01 <ivanm> or else aRithmetic? *shrug*
18:14:08 <mmorrow> bot i think
18:14:11 <mmorrow> *both
18:14:17 <ivanm> wikipedia doesn't seem to know...
18:14:24 <mmorrow> @go MPFR
18:14:25 <lambdabot> Maybe you meant: google googleit do
18:14:28 <mmorrow> @google MPFR
18:14:31 <lambdabot> http://www.mpfr.org/
18:14:31 <lambdabot> Title: The MPFR Library
18:14:34 <ivanm> so how does MPFR differ from IEEE754 (or whatever it is)
18:14:36 <ivanm> ?
18:14:43 <mmorrow> it's arbitrary precision
18:14:50 <mmorrow> like Integer vs. Int
18:15:18 <ivanm> *nod*
18:15:20 <mmorrow> (gmp also has an arb prec floating type too)
18:15:42 <mmorrow> but there aren't any haskell bindings that i know of
18:16:03 <ivanm> IIRC, someone (copumpkin?) started work on proper GMP bindings...
18:16:03 <mmorrow> i wonder why that's being non-deterministic though
18:16:20 <mmorrow> , pi + 0.000000000000000000000000000000000000000000001 :: MPFR
18:16:21 <ivanm> mmorrow: to spite you, of course! ;-)
18:16:21 <lunabot>  3.141592653589793
18:16:35 <mmorrow> , (pi + 0.000000000000000000000000000000000000000000001) - pi :: MPFR
18:16:37 <lunabot>  9.98972538044059e-46
18:16:38 <ivanm> , pi + 0.000000000000000000000000000000000000000001 - pi :: MPFR
18:16:38 <mmorrow> , (pi + 0.000000000000000000000000000000000000000000001) - pi :: MPFR
18:16:39 <lunabot>  9.999988796927344e-43
18:16:40 <lunabot>  9.98972538044059e-46
18:16:44 <mmorrow> hmm
18:17:00 <ivanm> so not quite accurately represented (still have binary problems)...
18:17:07 <ivanm> but shmeh, looks like it's good enough
18:17:16 <mmorrow> well, it's all there, it just prints that much
18:17:35 <nvoorhies> is any well polished stuff out there for haskell & interval arithmetic?
18:17:45 <mmorrow> , 1e-4200000000 :: MPFR {- tries to allocate the whole thing -}
18:17:46 <EvilTerran> ivanm, i'm getting the impression from the paper that the r may have something to do with rounding
18:17:52 <lunabot>  Killed.
18:17:56 <ivanm> EvilTerran: ahhh
18:18:09 <ivanm> nvoorhies: IIRC, there's a library on hackage that deals with it
18:18:16 <ivanm> don't know the name off the top of my head though
18:18:31 <mmorrow> , let score n = let x = exp (pi * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: MPFR
18:18:32 <lunabot>  Infinity
18:18:38 <mmorrow> noooooooooooooooooooo
18:18:55 <ivanm> heh
18:19:06 <ivanm> mmorrow: lunabot decided to cheat and take the easy way out?
18:19:15 <mmorrow> , let score n = let x = exp (pi :: MPFR * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: MPFR
18:19:16 <lunabot>  luna: parse error on input `*'
18:19:19 <Saizan_> R stands for "correct rounding", how could you not guess that?
18:19:23 <mmorrow> , let score n = let x = exp ((pi :: MPFR) * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: MPFR
18:19:24 <lunabot>  Infinity
18:19:26 <ivanm> Saizan_: heh
18:19:47 <SamB_XP> , let score n = let x = exp (pi * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: CReal
18:19:48 <lunabot>  luna: Not in scope: type constructor or class `CReal'
18:19:58 <mmorrow> my exceedingly hackish RealFloat instance may be to blame here
18:20:02 <SamB_XP> mmorrow: how come no CReal ?
18:20:11 <mmorrow> SamB_XP: CReal is too slow
18:20:16 <SamB_XP> > let score n = let x = exp (pi * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: CReal
18:20:18 <lambdabot>   2.1962031322303588075471956297735902604031
18:20:26 <mmorrow> SamB_XP: now search [0..10000000] :)
18:20:34 <SamB_XP> mmorrow: I meant, why doesn't lunabot have any ?
18:20:50 <mmorrow> SamB_XP: oh, no reason in particular
18:21:13 <mmorrow> hmm, maybe the rounding mode is to blame too
18:21:26 <ivanm> SamB_XP: yeah, BReal... who actually uses CReal? :p
18:21:39 <SamB_XP> whnat does the B stand for?
18:21:45 <ivanm> SamB_XP: BReal == be real
18:21:46 <ivanm> ;-)
18:21:59 * ivanm has a weird sense of humour
18:22:43 <Gracenotes> some like cereal in the morning, others like beereal
18:23:07 <ivanm> Gracenotes: that's even worse than mine...
18:23:59 <Gracenotes> it couldn't have existed without yours
18:24:26 <Alpounet> I'm off, good night.
18:24:43 <Gracenotes> :o
18:26:09 * mmorrow is going to find a whether there's a score > score 167 in [0..1000] now even if it kills him, having put 30+ minutes in already :)
18:26:40 <ivanm> mmorrow: ummm.... a > a == False ...
18:27:08 <mmorrow> , (>) .=. (>)
18:27:09 <lunabot>  luna: Not in scope: `.=.'
18:27:12 <mmorrow> , (>) .==. (>)
18:27:15 <lunabot>  True
18:27:18 <mmorrow> i knew it!
18:27:19 <Gracenotes> mmorrow: what is the problem you're solving?
18:27:32 <ivanm> mmorrow: :o
18:27:49 <copumpkin> :O
18:27:53 <copumpkin> sounds like a worthy endeavor, even though I have no idea what a score is
18:28:34 <ivanm> copumpkin: it's what you get after playing many types of games
18:28:35 <mmorrow> Gracenotes: Cale had some random thing with Reals and this score function, which lead to me installing some haskell MPFR bindings in lunabot, which proceeded in a epic, finally seems to work, AND I GOT INFINITY JUST LIKE WITH DOUBLE!
18:28:38 <mmorrow> :)
18:28:54 <ivanm> the idea being, whoever has the highest score (though sometimes it's the lowest) wins the game/tournament/whatever
18:28:56 <ivanm> ;-)
18:29:07 <Gracenotes> score :: Real -> Real?
18:29:16 <mmorrow> > let score n = let x = exp ((pi :: MPFR) * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: CReal
18:29:17 <lambdabot>   Not in scope: type constructor or class `MPFR'
18:29:23 <mmorrow> > let score n = let x = exp (pi * sqrt n) in -log (abs (x - fromInteger (round x))) in score 167 :: CReal
18:29:25 <lambdabot>   2.1962031322303588075471956297735902604031
18:29:28 <mmorrow> > score 167
18:29:30 <lambdabot>   2.1962031322303588075471956297735902604031
18:29:33 <mmorrow> is the highpoint
18:29:49 <mmorrow> CReal is too slow to search, and Double can't handle the precision
18:30:01 <Gracenotes> the maximum of a function
18:30:01 <ivanm> mmorrow: and the point of this mystical score function is?
18:30:10 <mmorrow> and it's not clear an equiv formulation of score that doesn't require that precision
18:30:19 <mmorrow> ivanm: i don't even know :)
18:30:23 <Gracenotes> that has.. odd asymptotes at places?
18:30:49 <copumpkin> it be cheesin' time
18:31:03 <SamB_XP> mmorrow: you tried calculus on it ?
18:31:04 <mmorrow> , round pi :: MPFR
18:31:05 <lunabot>  luna: No instance for (GHC.Real.Integral Data.Number.MPFR.FFIhelper.MPFR)
18:31:11 <mmorrow> , round (pi :: MPFR)
18:31:12 <lunabot>  3
18:31:21 <Gracenotes> the floor function makes the whole calculus angle suspect :/
18:31:22 <mmorrow> SamB_XP: shotgun debugging FTW
18:31:30 <SamB_XP> mmorrow: hmm?
18:31:33 <copumpkin> use teh calculus on it
18:31:37 <Saizan_> the function was something like "\x -> exp (pi * sqrt x) - pi"
18:31:37 <copumpkin> teh lambda calculus
18:31:43 <mmorrow> heh
18:31:53 <SamB_XP> I mean, did you use the pencil & paper and the integrodifferential calculus?
18:32:26 <mmorrow> SamB_XP: as in, no i've just been blindly firing random expressions to the bot rather than following a coherent organized strategy to find a solution
18:32:54 <Gracenotes> at least it is not periodic
18:33:03 <SamB_XP> mmorrow: I would suggest cracking open the calculus textbook to see what it suggst you do to find maximum values ;-)
18:33:37 <mmorrow> the real problem here is, "can haz a rep for R that has enough precision to work here, while still being fast enough to finish before the sun burns out?"
18:33:59 <SamB_XP> mmorrow: how abouts you stop trying to cleverly bruteforce it, mkay?
18:34:36 <mmorrow> SamB_XP: no!
18:34:52 <SamB_XP> do I get to call you a stupid git now ?
18:34:56 <hackagebot> HXQ 0.18.2 - A Compiler from XQuery to Haskell (LeonidasFegaras)
18:35:08 <SamB_XP> wonder what was wrong with the last one ?
18:35:13 <mmorrow> really though, if you can symbolically solve it with the bot, then you win
18:35:31 <SamB_XP> mmorrow: I don't see why using the bot is so essential!
18:35:33 <mmorrow> teh calcoolus is illegal
18:35:53 <SamB_XP> that's only because you won't let me define datatypes :-(
18:36:37 <SamB_XP> anyway, I wasn't trying to win
18:36:40 <copumpkin> why not use that differentiation thingy
18:36:45 <copumpkin> in your bot
18:37:02 <SamB_XP> I thought you were trying to kille teh PE
18:37:46 <Gracenotes> so the idea is: take e^(pi*sqrt n), find how much it differs from the nearest integer
18:37:47 <mmorrow> SamB_XP: ok fine, you win
18:37:50 <mmorrow> SamB_XP: http://www.wolframalpha.com/input/?i=+D(exp+(pi+*+sqrt+x)+-+pi)
18:37:53 <Gracenotes> expressed logarithmically, like pH
18:38:10 <copumpkin> zomg
18:38:20 <Gracenotes> for this mysterious 'score' function. I can see how it would be rather irregular then. like, very.
18:38:21 <mmorrow> err, forgot the log
18:39:00 <mmorrow> the qustion is, which element of this sequence is closest to an integer
18:39:14 <copumpkin> oh
18:39:19 <copumpkin> out of how many?
18:39:32 <mmorrow> well, 167 is the highpoint
18:39:33 <Gracenotes> <sagan>billions and billions</sagan>
18:39:40 <mmorrow> you have the continuum to work with :)
18:39:43 <copumpkin> oh
18:39:43 <SamB_XP> mmorrow: oh, wow .... that's pretty crazy ...
18:39:47 <ksf> ebml again. the RFC specs an "ordered" mode (supposedly used by default, but I've never seen it used in a mkv), which constraints elements of a container to only appear in the same order as they're mentioned in the dtd. It's supposed to allow parsers to return default values for missing elements earlier, that is, upon seeing the next element, instead of finishing the whole block.
18:39:52 <ksf> does that actually make sense?
18:39:58 <Gracenotes> so technically you wouldn't need the log in the scoring function
18:40:06 <ksf> I would guesstimate that the overhead of tracking is too big.
18:40:06 <Gracenotes> ..not like that changes much
18:40:59 <SamB_XP> might save a good few cycles of CReal ?
18:41:29 <ksf> ...and the stuff you have to parse are maximally say 50 element id's and their lengths, which amounts to max. 50*8 = 400 bytes, or, more commonly, less than 100 bytes.
18:44:02 <mmorrow> i think maybe a way to go after it would be to numerically compute the derivative of the score function, and find the max in [0..1000] or whatever
18:45:18 <Gracenotes> http://www.wolframalpha.com/input/?i=derive%28exp%28pi*sqrt%28x%29%29-floor%28exp%28pi*sqrt%28x%29%29%2B.5%29%2Cx%29
18:45:40 <camio> Offtopic: That Marten Fokkinga tutorial on Category theory rocks!
18:45:53 <ksf> link or it doesn't exist
18:46:13 * camio is getting the link...
18:46:20 <SamB_XP> ksf: well, might as *well* not exist ;-P
18:46:31 <Gracenotes> derivative itself isn't so helpful
18:46:42 <ksf> it's a paraphrase
18:46:49 <Gracenotes> and plus, you are only looking for integer solutions
18:47:15 <ksf> of 4chan-like conversations like "zomg my mouse ate my cat!" "pics or it didn't happen!"
18:48:00 <ikke> pics or it didn't happen!
18:48:00 <SamB_XP> yeah, sorry
18:48:19 <Gracenotes> here is your link, sir. http://socksrockingtutorialoncategorytheorybymartenfokkinga.com/
18:48:24 * bos is getting the conversations confused. commutative diagram or it didn't happen!
18:48:33 <Gracenotes> tip please
18:48:38 <camio> http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.html
18:49:02 * ksf hands Gracenotes a lambdacake
18:49:29 * SamB_XP eats the cake
18:49:53 <bos> the arrow is a lie.
18:49:57 <SamB_XP> ... even though it's a lie
18:49:58 <bos> the algebra is a lie.
18:50:06 <camio> It is a great companion to the Asperti Longo book.
18:50:06 <SamB_XP> darn it, bos
18:50:10 <bos> ba-dump BUMP, ladies and gentlemen!
18:50:12 <SamB_XP> you got to the reference before I did
18:50:25 <SamB_XP> I didn't even know you guys had heard of that game ...
18:50:41 * SamB_XP wishes he had that game, or even something he could play it on ...
18:51:22 <ksf> ...some of those fields in the matroska dtd which don't come with a cardinality attribute are clearly required, and some that don't come with a cardinality attribute are clearly missing out of a lot of mkvs.
18:51:43 * ksf concludes that cardinality defaults to what's sensible for the current application.
18:51:53 <ksf> which is a sensible semantics, but not very formal.
18:52:11 <SamB_XP> what does cardinality mean for mkv?
18:52:17 <ksf> ebml.
18:52:27 <Gracenotes> the inverse of this statement is a lie
18:52:29 <ksf> ...how often an element may occur
18:52:48 <ksf> ebml is actually trying to be something of a parser spec language.
18:52:54 <ksf> ...underspecified and buggy.
18:53:07 <Gracenotes> hm. intresting.
18:53:14 <SamB_XP> Gracenotes: but does it shave itself?
18:54:55 <ksf> sometimes I think plain, simple EBNF would be a better choice for dtds than those ad-hoc languages.
18:55:18 <mmorrow> , let go t f' f'' x = let !x' = x - f' x / f'' x in if abs (x' - x) < t then x' else go t f' f'' x' in go 0.01 (\x -> 3*x^2 - 2*x - 3) (\x -> 6*x - 2) 1
18:55:19 <lunabot>  1.3874398073836276
18:55:25 <SamB_XP> ksf: have you seen the EBNF for XML?
18:55:35 <ksf> no, and I don't want to.
18:55:37 <SamB_XP> anyway, Relax NG is obviously what you want ;-P
18:55:51 <ksf> I meant using ebnf instead of dtds
18:55:54 <SamB_XP> especially in it's Compact representation
18:56:10 <SamB_XP> that's the one that people are actually able to author
18:56:17 <ksf> ...specifying which elements nest into which, and their ordering.
18:56:27 <SamB_XP> ksf: yeah, that's Relax NG
18:56:39 <SamB_XP> more or less
18:58:19 <ksf> that looks kind of my prototype parser. but mine supports applying cardinalities over a whole list of elements with Control.Applicative...
18:58:49 <SamB_XP> ksf: hmm?
18:59:15 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10557#a10557
19:00:19 <ksf> ...where zeroOrOne = fmap (Cardinality 0 1)
19:00:40 <SamB_XP> that sounds crazy evil
19:01:54 <SamB_XP> there's a reason that RNG only allows /[?+*]?/
19:02:13 <ksf> a sensible one?
19:02:16 <SamB_XP> well, I mean, there's no reason it couldn't do that brackety thing
19:02:35 <ksf> there's {1,4}
19:02:44 <ksf> ...at least in the bnf I learned in class.
19:02:56 <mmorrow> http://www.wolframalpha.com/input/?i=Plot[-Log[Abs[E^(Pi+Sqrt[x])+-+Floor[E^(Pi+Sqrt[x])]]]%2C+{x%2C+0%2C+180}]
19:02:59 <SamB_XP> well, I don't think RNG actually has that at the moment
19:03:03 * mmorrow sees that and admits defeat
19:03:06 <SamB_XP> but there's no theoretical difficulty
19:03:38 <ksf> ...that's what I was thinking. Cardinality is a pair of natural numbers from 0 to infinity: lower and upper bound.
19:03:59 <ksf> you can test whether it's satisfied, whether it's still accepting etc.
19:04:13 <ivanm> mmorrow: is that correct?
19:04:25 <ivanm> round /= tail
19:04:36 <SamB_XP> ksf: ah
19:04:53 <ivanm> (not that trying it with Ceil makes much difference)
19:04:55 <SamB_XP> I misread ...
19:05:12 <ivanm> or round
19:05:15 <mmorrow> whoa http://www.wolframalpha.com/input/?i=Plot[-Log[Abs[E^(Pi+Sqrt[x])+-+Floor[E^(Pi+Sqrt[x])]]]%2C+{x%2C+120%2C+120.000000001}]
19:05:20 <greap> Hi #haskell. I'm getting [ghc: unrecognised flags: -I] when I try to install gpipe. Is this a ghc version thing?
19:05:24 <mmorrow> ivanm: yeah, it's just a crazy function
19:05:27 <ksf> ...I should probably use my dtd parser not to generate something my parser lib understands, but a sensible representation of stuff that I can then edit until it makes sense.
19:05:35 <SamB_XP> ksf: what if some joker picks Cardinality infinity infinity ?
19:05:40 <mmorrow> it's not continuous either
19:06:06 <ksf> well, it's not a problem for a lazy stream.
19:06:13 <mmorrow> i wonder how to plot in C in that
19:06:14 <ksf> though it doesn't make much sense, either.
19:06:50 <ksf> anyway, I'm not using that constructor directly, as ebml only supports *+? and so on.
19:07:21 <SamB_XP> ksf: all documents would fail it ;-P
19:07:39 <ksf> well, but only if they end.
19:07:45 <ksf> until then, they succeed.
19:08:13 <ksf> ...expecting infinitely more elements doesn't mean that I can't return the first one.
19:08:21 <mmorrow> oh floor is messing with things
19:08:43 <ksf> in my appartment, things are messing with my floor.
19:10:23 <c_wraith> @pl \x -> (x, "y")
19:10:24 <lambdabot> flip (,) "y"
19:10:42 <copumpkin> or wait a day for 6.12, and use (,"y")
19:11:02 <aavogt> copumpkin: one day?
19:11:05 <ivanm> copumpkin: it comes out tomorrow? :o
19:11:13 <copumpkin> well, the RC is coming very soon
19:11:34 <ivanm> copumpkin: it was meant to come out a week or two after ICFP :p
19:11:44 <ksf> there's an rc.
19:11:47 <copumpkin> yeah, but in #ghc they mentioned today, but it might be tomorrow
19:11:49 <ksf> doesn't build the libraries, though.
19:11:58 <ksf> ...well, at least there's a version tagged with 6.12
19:12:06 <ivanm> ksf: which makes it kinda useless then, doesn't it?
19:12:06 <copumpkin> yeah, that's different
19:13:23 <ksf> ...the thing i'm trying to fix is that orderedness and unorderedness doesn't have to coincedence in span with a formal container.
19:13:46 <ksf> ...and the difference between a cardilality of two in an unordered and an ordered container.
19:14:05 <ksf> one might want to have those two successive, even if the rest of the container is unordered.
19:14:48 <ksf> ...or say "they can contain any number in this container, but in pairs of two"
19:15:04 <ksf> "but not before elem x or after elem y"
19:15:51 <ksf> that just doesnt' work if cardinality doesn't live in a different spanspace than containers/elements.
19:16:01 <mmorrow> analytic number theory is weird stuff
19:16:27 <ivanm> mmorrow: anyway, IIRC that was the first useful thing I've seen alpha used for!
19:16:42 <ivanm> (and it wasn't that useful since that function had no purpose AFAICT...)
19:16:51 <mmorrow> ivanm: heh, i started at the integrator, then saw that input box on the side and tried it
19:16:55 <SamB_XP> ivanm: I thought it was a PE problem!
19:17:13 <ivanm> SamB_XP: a Physical Education problem? :p
19:17:19 <SamB_XP> ... no
19:21:09 <hackagebot> pcap 0.4.4 - A system-independent interface for user-level packet capture (BryanOSullivan)
19:22:36 <ivanm> bos: you shaving yaks again? ;-)
19:22:45 <bos> ha!
19:26:39 <copumpkin> yeah, he really needs that pcap for his data.text
19:26:45 <copumpkin> just like criterion and statistics
19:26:54 <Gracenotes> D:
19:27:12 <ivanm> copumpkin: yes, he has to check how well data.text transmits strings over the interwebs... >_>
19:27:28 <copumpkin> oh, true dat
19:27:45 <copumpkin> Data.Text.sendDatTextThruDaToobs
19:27:56 <copumpkin> :: Text -> DaToobs -> IO ()
19:28:01 <ivanm> hmmm.... does "functional yak shaving" mean that given the same yak, you'll cut its hair off the same way each time? :p
19:28:25 <SamB_XP> ivanm: it means you can use the hair off the same yak as many times as you want
19:28:31 <ivanm> SamB_XP: ahhh
19:28:55 <ksf> relax ng's interleaving is interesting
19:28:56 <bos> hey, you people should clam up and put that yap to use writing some useful software!
19:28:59 <Jedi_Stannis> hi, can someone explain why the following code gives an overlapping match warning? http://pastebin.com/db63267e
19:29:03 <bos> :-)
19:29:18 <ivanm> bos: but would you be able to write a blog post demonstrating _why_ criterion is better than the other benchmarking tools on hackage?
19:29:41 <SamB_XP> ivanm: probably the name
19:29:42 <ksf> because c1 and otherwise are never matched.
19:29:45 <bos> ivanm: the other ones only go up to 10. criterion goes up to 11 for when you need that bit more.
19:29:48 <ivanm> bos: jfredett seemed to get annoyed about how much software I was announcing... >_>
19:29:52 <ksf> you can't match against the contents of variables
19:29:54 <ivanm> bos: 10 what?
19:29:58 <ivanm> SamB_XP: of course!
19:30:09 <ksf> ...what you're doing introduces new bindings c0 and c1
19:30:16 <ksf> ...and c0 already matches everything.
19:30:19 <bos> new software?
19:30:21 <Jedi_Stannis> ksf: o, I didn't realize that
19:30:22 <ivanm> Jedi_Stannis: use guards or something
19:30:27 <ivanm> bos: well, new releases...
19:30:35 <Jedi_Stannis> ok, thanks
19:30:41 <ivanm> Jedi_Stannis: I've been bitten by that myself before :s
19:30:54 <ksf> btw, does ghc do something like perfect hashing for cases?
19:31:12 <ivanm> (it would be a nice feature, but I don't know how feasable implementing it would be)
19:31:25 <Jedi_Stannis> ivanm: yeah, I had specific versions that work, and was just trying to generalize
19:32:34 <ksf> case c of _ | c == c0 -> ...; _ | c == c1 -> ...
19:32:42 <ksf> ...or use plain ifthenelse
19:33:26 <ivanm> ksf: no need for the extra _
19:33:32 <ksf> not?
19:33:47 <ivanm> I believe you can do the full guard thing with otherwise and everything there
19:34:15 <ksf> well you can't do otherwise without _ as all paterns have to have the same number of vars
19:34:17 <SamB_XP> yeah, you don't need to repeat the same pattern just to add another guard to it
19:34:36 <ksf> ah.
19:35:11 <ksf> but that'd be case c of _ | c == c0 -> ...; | c == c1 -> ....; otherwise ->
19:36:27 <ksf> the most confusing parts of haskell, are, in expontentially increasing order, 1) semantics, 2) syntax, 3) lexical syntax of comments.
19:36:52 <ivanm> ksf: | c == c0 = ...; | c == c1 = ...; | otherwise = ...
19:36:57 * copumpkin moos loudly
19:37:07 <ksf> wtf did think of making --$ an operator?
19:37:09 <ivanm> copumpkin: go find a dairy farmer
19:37:25 <ivanm> ksf: ummm, "-- " is a comment marker
19:37:29 <SamB_XP> --> is a nice one though
19:37:34 <ksf> but --$ is an operator.
19:37:46 <ivanm> AFAIK, any other bunch of symbols (excluding parens, etc.) is an operator
19:37:56 <ksf> which is why the lexical syntax of comments is the most confusing part of haskell.
19:38:02 <aavogt> it messes with regex highlighting of haskell code
19:38:09 <ivanm> ksf: I thought it was the unary minus... :p
19:38:12 <ksf> vim does it right.
19:38:25 <ksf> we should change unary minus to ---
19:38:31 * ivanm wishes haskell-mode for emacs understood haddock comments properly for indentation purposes
19:38:36 <ivanm> @skap ksf
19:38:37 * lambdabot locks up ksf in a Monad
19:39:35 <Jedi_Stannis> ivanm: | c == c0 = ...; | c == c1 = ...; | otherwise = ... is there a way to get this in the middle of a do-block?
19:39:39 <ksf> mmmmh it's warm and fuzzy in here.
19:39:50 <ivanm> Jedi_Stannis: let a | c == c0 = ...
19:39:51 <ivanm> etc.
19:40:01 <SamB_XP> ksf: lol!
19:40:12 <ivanm> heh
19:40:17 * SamB_XP admits that he was already laughing oujt loud when he saw that
19:40:29 <ivanm> @remember ksf * lambdabot locks up ksf in a Monad <ksf> mmmmh it's warm and fuzzy in here.
19:40:29 <lambdabot> Done.
19:42:14 <hackagebot> hoauth 0.1.4 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
19:55:39 <ivanm> c_wraith: make up your mind if you want the underscore or not! ;-)
19:56:29 <c_wraith> I just noticed the link to the freenode nick faq, and saw I could link names.  So I had to switch to _, identify, switch back, group, and then return _. :)
19:58:00 <ksf> you can identify while having the wrong nick
19:58:22 <ivanm> excuses, excuses!
19:58:23 <ksf> the nickserv user name and reserved nicknames are distinct.
20:02:09 <byorgey> sing hey nonny nonny
20:03:05 <Rotaerk> hmm I'm considering having my game state data in a database rather than in the State monad
20:03:49 <c_wraith> that's just replacing state with IO
20:04:32 <Rotaerk> because it just seems like I'd be reinventing databases anyway to have a bunch of "Map CharacterID Character" "Map PartyID Party" in my game state
20:04:46 <Rotaerk> so I might as well just USE a database
20:05:02 <ksf> Rotaerk, IxSet
20:05:32 <Rotaerk> that doesn't come up in hoogle
20:05:34 <ksf> http://hackage.haskell.org/package/happstack-ixset
20:05:51 <ksf> it's way less scary than it looks.
20:06:02 <ksf> http://tutorial.happstack.com/tutorial/ixset
20:06:08 <ivanm> byorgey: you been drinking or something? :p
20:07:18 <ksf> ...I suppose the reason why you have those ID types is because you index more than one other map with them.
20:08:39 <Rotaerk> I have the ID's so that, say, a Character can have a PartyID
20:08:55 <Rotaerk> while the Party value itself may change
20:09:29 <Rotaerk> that character can always be associated with the current state of that party
20:09:52 <Rotaerk> in a mutable language you don't need this, because the objects don't change location in memory
20:09:59 <ksf> but you could also just look up that Character in your [Party]
20:10:33 <ksf> there's no need for backrefs. you're optimizing prematurely.
20:11:08 <ksf> it doesn't matter whether you get the storage right, as long as you're using it with an interface that allows you to mess with the storage model.
20:11:14 <ksf> ...that is, encapsulation.
20:11:25 <ksf> err change the model.
20:11:40 <Rotaerk> putting the characters in the party (data Party = Party { characters :: [Character] }) would potentially make sense, if those were the only two types involved
20:11:45 <ksf> ...in contrast to changing the model with the interface.
20:12:12 <Rotaerk> but doing that would make looking up a character in a party-agnostic way not as easy
20:12:53 <Rotaerk> and besides, the ID is necessary even in that case, because you'd end up with party containing a map of character ID's to characters
20:13:35 <aavogt> ksf: but as it is, IxSets sort of have to regenerate the multiple Maps whenever you need to make a query afaict
20:14:07 <Rotaerk> ksf, currently the Party type has no knowledge of its characters, just as you would represent it in a database
20:14:10 <ksf> ...if you insert.
20:14:32 <Rotaerk> instead you'd do a filter on the map for all characters with PartyID = blah
20:14:33 <aavogt> but only for the first query
20:15:54 <aavogt> too bad IxSets aren't terribly typesafe
20:16:33 <aavogt> in that a query on a set that doesn't have your key type will just return an empty set, instead of being a compile-time type error
20:16:37 <byorgey> ivanm: a bit punch-drunk from my combinatorics homework, that's all =)
20:16:44 <ivanm> heh
20:16:49 <byorgey> I've been drinking hot chocolate, does that count?
20:17:11 <ivanm> byorgey: did you put a little something into it to help warm you up?
20:17:16 <ivanm> if not, then no, it doesn't count
20:17:24 <byorgey> hehe, no, but I should have =)
20:17:45 <byorgey> I did put a lot of marshmallows in it
20:18:24 <Saizan_> ksf: do you use ixset much?
20:18:44 <ksf> ...well, with an IxSet, you can look up a Party <-> Character combination by both characters and parties.
20:19:18 <ksf> if you query on "Party "ReservoirDogs"" you get a list of characters, if you query on a character, you get zero to however many parties.
20:19:48 <ksf> Saizan_, not terribly, no.
20:19:49 <Rotaerk> ksf, my code also does that, I'm just saying it's very much like a database, and I'd be reinventing the wheel to do so; IxSet may be wheel, only already built, though
20:20:00 <Rotaerk> may be that wheel*
20:20:29 <Saizan_> aavogt: it wouldn't be that hard to fix that, though it'd require to add a class Index key value where index :: value -> key to the interface, i've never got around to make that change though
20:20:45 <ksf> well let's say using a database-like storage model is no excuse for using IO.
20:21:00 <Rotaerk> I agree that IO would be undesirable
20:21:39 <Rotaerk> thanks for the suggestion, looks promising
20:23:43 <ksf> actually, the only thing I'm using IxSet for is indexing into available fonts.
20:23:56 <ksf> ...you might want to query by family, style or whatever.
20:24:00 <aavogt> Saizan_: hmm, that would give unpleasant errors that suggest adding an instance, right?
20:24:09 <aavogt> but that's better that currently
20:24:35 <aavogt> better than how it works now, that is
20:25:08 <Rotaerk> ah. IxSet uses SYB
20:25:24 <Rotaerk> to me SYB doesn't seem like a good idea for state traversal
20:25:42 <Saizan_> aavogt: it'll give an error that you need an instance when you're trying to create an ixset with an invalid index, when you're trying to query with an invalid index it'll give an error like "no instance for Get Nil YourIndex"
20:25:57 <Rotaerk> but for, say, XML processing, SYB is probably good
20:25:58 <Saizan_> aavogt: oh, and it'll stop using SYB
20:26:28 <Rotaerk> because of the extraneous traversal SYB does
20:27:03 <ksf> I don't think it uses syb for actual data storage and retrieval
20:27:08 <Saizan_> in IxSet SYB is only used to try to extract a field of the given type from the value
20:27:10 <ksf> ...rather for some obscure template magic
20:27:24 <Rotaerk> ah
20:27:31 <Rotaerk> fair enough
20:27:44 <Saizan_> so that it can use it as key for the Maps
20:28:14 <Saizan_> IxSet is just an heterogeous list of Map key (Set value)
20:30:47 <ksf> I don't think it will free you of IDs, completely, but you'd need a full-fledged graph library for that, anyway, most likely.
20:30:58 <ksf> (which, incedentally, use a hell a lot of IDs)
20:34:18 <ksf> but I guess you're procrastinating, anyway. You only want to make sure that your interface to your data is independent of its representation, not re-invent databases. Go code that fierce dragon, already.
20:37:40 <malsyned> Isn't [a, b..c] syntactic sugar for enumFromTo? I'm looking at the GHC source and enumFromTo seems to be defined in terms of the [a,b,..c[ syntax.  circular much?
20:37:58 <bos> it's sugar for enumFromThenTo
20:39:04 <malsyned> enumFromThenTo, right.  Same question though.
20:39:16 <ahanwadi> bos: e
20:39:23 <ahanwadi> 20:36 *** togameru QUIT Read error: 110 (Connection timed out)
20:42:03 <bos> google wave. we need lambdabot for it.
20:47:36 <ivanm> bos: do we? why?
20:47:55 <bos> ivanm: so it's useful for something, anything ;-)
20:48:07 <ivanm> heh
20:48:13 <ivanm> you mean lambdabot or google wave? :p
20:49:33 <ksf> lesson number one: never design a generic parser in terms of a generic grammar. define the grammar as sugar on top of parser primitives.
20:50:23 <ivanm> lessen number one of what?
20:51:00 <inimino> ksf's short course in parser design
20:51:21 <ksf> making sense of the EBML RFC
20:52:06 <ksf> you can tell it was designed top-down by the code smell and non-adherence as well as the number of obvious bugs in the spec
20:53:45 <joevandyk> Does haskell have a test code coverage tool?
20:53:51 <bos> yep.
20:53:57 <inimino> ksf: I don't think I ever heard of someone using EBML before, what are you doing with it?
20:54:23 <ksf> right now, parsing matroska files.
20:54:28 <inimino> oh
20:54:42 <ksf> I could extract those attached ttf files with a few keystrokes, now.
20:55:11 <ksf> it's all fast and lazy and stuff, but the way dtds are specified and interpreted sucks.
20:55:54 <ksf> I'm parsing the official dtd, throwing everything away except the id<->name relations and then using a hand-written haskell fun to parse part of it.
20:56:22 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10557
20:58:27 <Zeiris> ksf, is that using parsec or your own stuff? o.O
20:58:37 <Makoryu> @let ((||~),(&&~)) = (liftA2 (||), liftA2 (&&))
20:58:39 <lambdabot>  <local>:2:17:
20:58:39 <lambdabot>      Ambiguous type variable `f' in the constraint:
20:58:39 <lambdabot>        `Ap...
20:58:50 <ksf> that's using polyparse.
20:59:58 <Makoryu> :t liftA2
21:00:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
21:00:11 <Makoryu> :t liftA2 (||)
21:00:13 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
21:00:37 <Makoryu> :t (||~)
21:00:37 <ksf> ....mapping a Spine to a Foo String:     http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10557#a10559
21:00:38 <lambdabot> Not in scope: `||~'
21:00:44 <ivanm> bos: I wonder why you could answer in the affirmative to joevandyk so quickly... ;-)
21:00:47 <Makoryu> @let (||~) = liftA2 (||)
21:00:49 <lambdabot>  Defined.
21:01:05 <ksf> ...the spine being produced out of a mmaped bytestring, lazily.
21:01:21 <Makoryu> :t even ||~ odd
21:01:22 <lambdabot> forall a. (Integral a) => a -> Bool
21:01:45 <ksf> the cool thing with polyparse is that it's lazy, so I don't have to parse the whole file to return something, which is _very_ useful.
21:02:07 <ksf> ...considering that it's hard to get by mkv's which are less than 200m, more commonly 700m.
21:02:10 <bos> ivanm: because i've used it?
21:02:19 <davidL> @seen Cale
21:02:20 <lambdabot> Unknown command, try @list
21:02:25 <davidL> preflex: seen Cale
21:02:26 <preflex>  Cale was last seen on #haskell 3 hours, 16 minutes and 11 seconds ago, saying: narens: Probably best to use strict arrays in that case (UArray), because then you don't have to worry about whether all the cells on each iteration are causing old versions of the array to be retained in memory
21:02:29 <bd_> ksf: the corrolary being that parse errors manifest as _|_? :)
21:02:33 <ivanm> oh, whoops, thought you were referring to criterion :s
21:02:41 * ivanm should stop skimming so quickly
21:02:44 <bos> @t genericLength
21:02:45 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:02:49 <bos> @type genericLength
21:02:51 <lambdabot> forall b i. (Num i) => [b] -> i
21:02:52 <ksf> the corrollary being that there are no parse errors.
21:03:17 <ksf> unparsable stuff is returned as-is.
21:03:19 <FunctorSalad> ksf: which one of the polyparse parses does one use? the variety scared me off ;)
21:03:27 <ksf> StateLazy
21:03:49 <ksf> ...you can even take the fixpoint of a parser.
21:04:07 <ksf> ...which I'm going to have to do, looking at the parse result to figure out the default value of an element.
21:04:39 <Makoryu> :t even . const
21:04:41 <lambdabot> forall a b. (Integral (b -> a)) => a -> Bool
21:05:05 <Makoryu> :t (even .) . const
21:05:06 <lambdabot> forall a b. (Integral a) => a -> b -> Bool
21:06:02 <FunctorSalad> as I understand polyparse does backtracking automatically? (no 'try')?
21:06:09 <ksf> yep
21:06:28 <FunctorSalad> can you do left recusion straightforwardly?
21:06:50 <ksf> uhm dunno.
21:06:55 <FunctorSalad> (iirc parsec loops if you translate a left-recursive rule directly)
21:07:08 <ksf> I've never used yacc-likes, so I never cared about parsing semantics.
21:07:37 <FunctorSalad> (say Expr ::= Expr '+' Expr | '0')
21:07:44 <ksf> I'm doing a decent amount of manual onFail handling in unordered, though.
21:08:14 <ksf> well it shouldn't if you try the lhs of the |
21:08:33 <ksf> ...or is it _that_ greedy?
21:09:08 <FunctorSalad> I think it infinitely descends into the left Expr of the left rule
21:10:12 <ksf> hmmm I'm using my own choice combinator, and don't use recursion.
21:12:16 <ksf> zomg http://www.cs.york.ac.uk/fp/polyparse/haddock/src/Text/ParserCombinators/Poly/StateLazy.html#Parser underlines underscores.
21:12:23 <ksf> they appear to be keywords...
21:14:08 <ksf> guesstimating from the oneOf' source, you still have to put your recursions to the right side.
21:17:53 <FunctorSalad> needs an Applicative instance D:
21:24:17 <FunctorSalad> ksf: tried it, fails with either parsec or poly
21:24:42 <FunctorSalad> (stack overflow)
21:25:54 <ksf> afaik no parsing lib actually analyses the parser.
21:26:43 <ksf> but then it should be possible to detect left-recursion with those fancy new observable sharing and whatnot libs.
21:26:56 <FunctorSalad> hmm I think I misimplemented 'string' in my poly version though ;)
21:26:58 <SamB_XP> ksf: lava isn't that new is it ?
21:27:05 <ksf> ...at least potential left recursion.
21:27:07 <FunctorSalad> string x = mapM_ (\c -> satisfy (=='c')) x >> return ()    -- ?
21:27:51 <ksf> er, huh?
21:28:04 <ksf> seems like you're trying to match "cccccccccccccccc"
21:28:12 <FunctorSalad> trying to implement parsec's "string"
21:28:15 <FunctorSalad> oh :)
21:28:24 <FunctorSalad> *embarassed*
21:28:45 <Gracenotes> hm, I'll see if I can compile ghc HEAD now
21:29:55 <FunctorSalad> I'm probably associated single Chars and quotes too strongly in my head
21:30:00 <FunctorSalad> s/I'm/I
21:31:11 <Gracenotes> mainly I'm interested in these register allocation options...
21:32:10 <Gracenotes> how does GHC use the stack, anyhow. only for things it can analyze to be strict?
21:32:46 <ksf> it's got more than one stack.
21:32:59 <ksf> ...but the details escaped my memory.
21:33:12 <ksf> there's that really, really cool stg paper you should read.
21:34:00 <Gracenotes> .. is that SPJ's 1988 paper on implementing functional programming?
21:34:12 <Gracenotes> 87
21:34:13 <ksf> I think it has been updated.
21:34:49 <ksf> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:35:27 <Gracenotes> interesting as the introduction to the 1987 book was (discussing semantics and whatnot), I don't think I got past it
21:36:40 <mmorrow> Gracenotes: it uses the stack every time it updates a thunk. it pushes an "update frame" that is just a place to save some regs and that the eval of that thunk'll return to, trigger an update of itself getting overwritten with an ptr ("indirection") to its value (the thunk gets overwritten), then the regs'll get restored and execution continues. the update frame also has an info table just like heap allocated closures, so if a gc happens
21:36:40 <mmorrow>  the collector can use that info table to find the ptrs on the stack
21:38:28 <mmorrow> Gracenotes: one way that a compiler that didn't use a stack might do it is how smlnj does, which is what would be the topmost update frame (infoptr + saved regs) is kept in callee-saved registers, and the rest of what would be the stack is in the heap
21:38:41 <Gracenotes> I've never thought it like that before, but laziness really does entail doing destructive updates on thunks
21:38:46 <mmorrow> right
21:38:53 <Gracenotes> at least with JVN-based whatnot
21:38:58 <mmorrow> it's a crucial aspect actually
21:39:31 <ksf> it also features nice gentoo-warnings about writeable code sections.
21:39:42 <mmorrow> heh
21:39:48 <Gracenotes> perhaps I always thought the thunk was just stored somewhere far away :)
21:39:51 <ksf> self-modifying code was very en vogue, back in the good ole days.
21:40:12 <ksf> then they discovered goto, then structured programming, and then everything went haywire.
21:40:50 <Saizan> fib : functional languages :: peano naturals : inductive datatypes
21:40:50 <mmorrow> yeah, the whole ghc heap is writeable + exec, although i'm not sure exactly why now that i think about it (ffi dynamic stubs and the bytecode interp dynamically generate machine code, but that's it as far as i'm aware)
21:41:45 <blackdog> they call it fib because it helps you lie in benchmarks.
21:41:46 <ksf> ...to overwrite calls to eval other thunks with loading a value out of the info table?
21:41:47 <mmorrow> (the bytecode interp just spits out a < 30 or so byte sequence for constructor info tables, which just jumps to the constructor-eval entrypoint of the interp, so they're "self-evaluating")
21:42:01 <mmorrow> (the same 30 byte sequence always)
21:42:11 <Gracenotes> self-modifying code is becoming pretty trendy nowadays. Well, if by code you mean ".NET or Java bytecode" and by self-modifying you mean "compiling just-in-time to machine code"
21:42:20 <mmorrow> ksf: but that's just a write of a ptr
21:42:28 <mmorrow> no executable code is being modified
21:42:43 <c_wraith> Gracenotes: VMWare and similar virtualization platforms JIT code from one platform to itself.  that's amusing.
21:42:45 <mmorrow> the indirections get collapsed every gc
21:43:05 <mmorrow> c_wraith: yeah that's cool how they do binary translation
21:43:56 <ksf> so that's the reason windoze runs faster in vmware? they'er optimising the opcodes?
21:44:45 <ksf> makes me wonder what wonders a x86 dsl implemented in haskell could do.
21:45:09 <Axman6> aren't there already things for that?
21:45:16 <mmorrow> harpy!
21:45:18 <Axman6> there's a rather well known one, whose name i can't remember
21:45:21 <Axman6> that one!
21:45:38 * mmorrow wants an x86_64 haskell runtime assembler bad
21:45:46 <mmorrow> unfortunately harpy only does x86
21:45:54 <ksf> that one says "code generation", not "parsing"
21:45:58 <inimino> LLVM
21:46:07 <ivanm> Axman6: looks like the chances of me joining you in ANU next year have gone up
21:46:18 <Axman6> oh hoorah :)
21:46:21 <ksf> ...I'm thinking of using an elf executable as input to ghc.
21:46:29 <ivanm> since I didn't get the scholarship to go overseas and they guarantee PhD positions to 1st class honours recipients
21:46:39 <ivanm> Axman6: so we can start the Haskell underground in earnest! :p
21:46:51 <mmorrow> ksf: there're two pure haskell elf parsers i know of, although neither implement /writing/ an elf
21:47:18 <mmorrow> ksf: although rwbarton did a hackjob in his brainfuck compiler :) http://moonpatio.com/repos/brain/
21:47:27 <mmorrow> http://moonpatio.com/repos/brain/haddocks/src/Brain-Elf.html
21:47:38 <c_wraith> So....  use brainfuck as an intermediate language?
21:47:39 <mmorrow> (hard-coded for an ET_EXEC on x86)
21:47:39 <ivanm> mmorrow: well, doesn't GHC produce ELFs? :p
21:47:43 <c_wraith> I like the way you think :)
21:47:43 <ivanm> c_wraith: heh
21:47:44 <Axman6> ivanm: sounds good. we've already got a few hackell experts here anyway (like ben lipp..er... benl23 >_>)
21:47:45 <mmorrow> ivanm: just asm
21:47:57 <ivanm> mmorrow: ahhh
21:48:01 <Gracenotes> "Happy version 1.16 or later is required to compile GHC."  :(
21:48:02 <mmorrow> ivanm: it relies on ld to build the elf (or mach-o)
21:48:06 <Gracenotes> why does this error seem familiar
21:48:20 <ivanm> Gracenotes: because you've seen it before?
21:48:39 <Gracenotes> true. perhaps it was DDC.
21:48:43 <BMeph> Ooh, Program an FPGA to be a BFVM...Wicked! >:)
21:49:17 <Gracenotes> well, I looked back at README and it said "told ya so, sucker"
21:49:28 <mmorrow> and if you have a [Word8] (or a bytestring) it's super easy to piggyback on ghc's FFI (via libffi) to ccall into it http://moonpatio.com/repos/ohhai.hs
21:49:38 <ivanm> Axman6: what's the public transport like? (in terms of starting to consider places to live)
21:49:43 <mmorrow> the only non-trivial part is encoding the instructions
21:49:46 <Axman6> excellent
21:49:49 <ivanm> \o/
21:50:14 <ivanm> Axman6: because wherever I live, it would probably have to be semi-convenient to ADFA (my youngest brother is going to be there till end of next year at least)
21:50:40 <Axman6> ivanm: i live about 25 mins drive from ANU, and it only takes me 40 mins to ride there by bike. so, if you want to save money and get fit, a bike's a great way to get around canberra
21:51:04 <ivanm> hmmmm...
21:51:20 <Axman6> but the busses are pretty good here (they fucked the timetable somewhat recently, but it's still good)
21:51:48 <Gracenotes> okay.. seeing many warnings.. hoping there's no error...
21:51:54 <Gracenotes> hurrah.
21:53:09 <_dmp_> is there an identity type constructor?
21:53:18 <Axman6> Id?
21:53:19 <ksf> a what?
21:53:23 <Axman6> @src Id
21:53:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:53:26 <Axman6> bah
21:53:27 <ivanm> Identity Monad?
21:53:31 <ivanm> @hoogle Identity
21:53:32 <lambdabot> module Control.Monad.Identity
21:53:32 <lambdabot> Control.Monad.Identity newtype Identity a
21:53:32 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
21:54:03 <ksf> actually, there can't be.
21:54:07 <_dmp_> a type constructor that when applied to a type returns that type
21:54:14 <ksf> well sure there can.
21:54:19 <_dmp_> like the identity function, but for types
21:54:27 <ksf> type family Id a;  type instance Id a = a
21:54:34 <ivanm> type ID a = a ;-)
21:55:56 <ksf> well, but that one doesnt' use strange extensions that you could use to scare harmless newbies.
21:55:58 <mmorrow> Saizan: (i may be trying to force something that doesn't fit, but) what do you make of this? in particular, wheretf should that "s" tyvar go? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4315#a4315
21:56:18 <ivanm> ksf: oh, I thought we weren't meant to scare the newbies away... >_>
21:56:43 <ksf> we have to avoid success at all costs, but be nice. so we have to be cryptic.
21:56:54 <mmorrow> _dmp_: unfortunately not one you can do anything useful with really (can't partially apply type synonyms, etc)
21:57:31 <ksf> when are we going to get closed type funs and data kinds?
21:57:34 <ksf> 6.14?
21:57:54 <ivanm> ksf: when you bother to implement them :p
21:58:06 <_dmp_> so if I have data A c = Foo (c Bool)
21:58:11 <ksf> there's some fun type magic that's enabled by both of them...
21:58:27 <_dmp_> I can have type Blah = data A []
21:58:49 <mmorrow> you can
21:58:53 <_dmp_> but there  is nothing that can just give me a data constructor that is Foo Bool
21:58:57 <_dmp_> ?
21:59:03 <mmorrow> _dmp_: right, no nothing
21:59:09 <_dmp_> ok, thanks
21:59:13 <mmorrow> _dmp_: (which would be handy)
21:59:28 <ski> (`type Blah = data A []' is syntax error)
21:59:28 <_dmp_> yeah, I would like it
21:59:41 <mmorrow> err, yeah s/data//
21:59:53 <_dmp_> yeah, sorry
22:00:14 <ksf> can't you do the Foo Bool thing with the type family above and A Id?
22:00:47 <mmorrow> ksf: i don't think you can partially apply the type family constructor
22:00:48 <ksf> type families aren't synonyms, after all
22:00:48 <_dmp_> so type Id a = a
22:00:50 * ski would suspect the type family doesn't like partial application
22:06:52 <Saizan> mmorrow: well, first 's' shouldn't be an argument in the newtype S s a = .. definition, i'd rather add a type StateType = s and use that
22:07:40 <Gracenotes> *shivers* I don't even want to think of the extent to which I would irrevocably damage my brain if I looked into the GCC source
22:07:55 <Saizan> mmorrow: and at that point a "State s" structure already matches the StateM signature, if you rename the field accordingly
22:08:24 <Saizan> Gracenotes: brain integrity is overrated
22:09:18 <mmorrow> Saizan: right, i tried various ways before arriving here, but i couldn't seem to find a decent way to bind `s' in (S s) to S
22:10:01 <Saizan> mmorrow: well it'd help using different names for the two :)
22:10:10 <mmorrow> Saizan: heh, yeah that go annoying too :)
22:10:52 <mmorrow> but i mean, so we have  (Monad.M = State.S s), but by the time StateM gets it, all it knows/sees is (M : Monad)
22:11:16 <Saizan> i'd just write type S = s; newtype M a = S {unS :: s -> (a,s) }
22:11:27 <mmorrow> so how (syntactically) to indicate that some forall'ed `s' is StateDict.S (or something)
22:11:29 <Saizan> in the definition of the State structure
22:11:47 <mmorrow> Saizan: hmm, yeah that seems decent
22:11:49 * ski wonders where `type S = s' would be allowed
22:11:52 <mmorrow> oh
22:12:00 <mmorrow> *in* the State structure
22:12:03 <mmorrow> hmm
22:12:08 <ski> (inside an `instance' definition ?)
22:12:27 <Saizan> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4315#a4315 <- ML-like structures
22:12:35 <mmorrow> ski: yeah, that's another thing, i dunno what exactly that should mean
22:12:43 <Gracenotes> could be scoped type variables... except type declarations are top-level, so no
22:12:48 <Saizan> mmorrow: are we assuming some kind of structural subtyping or not?
22:13:07 <mmorrow> Saizan: sure
22:13:14 <ski> who added ML-like structures and signatures to Haskell ?
22:13:31 <mmorrow> ski: oh yeah heh, hypothetical syntax gymnastics ;)
22:13:35 <Saizan> ski: we're doing it now, as we go :)
22:13:39 <ski> ah. ok :)
22:13:39 <mmorrow> ski: weee
22:13:53 <Saizan> well, mostly mmorrow
22:14:31 <Saizan> mmorrow: with the subtyping the new definition of State once applied to its type parameter s, will match the StateM sig
22:14:58 <ski> (why `[|' and `|]' ?)
22:15:11 <Saizan> uhm, no
22:15:23 <mmorrow> ski: here's a hacked-to-pieces haskell-src parser that at least parses stuff like (so far) (but what it was being used for before i had to strip out a bunch of haskell features, so want to replace it with a modified haskell-src-exts parser) http://moonpatio.com/repos/hs-modules/examples/Example0.hs
22:15:48 <Saizan> let x = State t, x :: StateM x
22:16:07 <mmorrow> ski: here's a darcs repo if you're interested http://moonpatio.com/repos/hs-modules/ (just assembled it from spare parts, haven't actually done anything with them yet ;)
22:16:33 <mmorrow> ski: oh, i just made the [| .. |] up, no reason really
22:16:45 <Saizan> i'm not sure if StateM should take (M : Monad) as argument or rather "include" a Monad
22:16:59 * ski would just use layout ..
22:17:14 <mmorrow> (wanted to bracket that somehow for clarity while i was working on it, and found the [|..|] the only decent looking brackets)
22:17:20 <mmorrow> ski: yeah, that's what it does currently
22:17:41 <mmorrow> (in the Parser.y in that repo)
22:18:08 <ski> why does `State' take a parameter ?
22:18:30 <mmorrow> ski: just to stick it somewhere to highlight that i had no idea where to put that `s'
22:19:03 <ski> i don't see why one would need to "put" it anywhere
22:19:30 <mmorrow> well, because in "StateDict" i felt like the `s' in "type S = s" was kind of coming from nowhere
22:19:33 <ski> (either the operations are polymorphic in it. or it can be a local type in the structure)
22:20:12 <mmorrow> right, how would you indicate that, given that StateM (M : Monad) = sig [|type S; ...|]
22:20:14 <mmorrow> ?
22:20:24 <mmorrow> (i may be inventing a problem that's not here)
22:20:59 <mmorrow> maybe just omit the definition of S, which would be defined to imply that it's polymorphic?
22:21:35 <mmorrow> (and you could tell by seeing that where "S" should be in the other typesigs, there's now a polymorphic `s') (maybe)
22:22:14 <Saizan> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4315#a4317
22:22:46 <mmorrow> Saizan: oh nice.
22:23:01 * mmorrow reads up on include
22:23:17 <Saizan> include might be something i've invented on the spot :)
22:23:21 <mmorrow> heh
22:23:59 <Saizan> if you see modules as extensible records it's much like concatenation
22:24:26 <ski> are you wanting to include something like `mapState' in this structure ?
22:24:33 <ski> @type Control.Monad.State.mapState
22:24:35 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
22:24:38 <mmorrow> sure
22:24:57 <ski> .. or is it the same `s' everywhere in the structure ?
22:24:58 <mmorrow> (trying to use this as an example to figure out what the issues with whatever are)
22:25:33 <ski> i suppose either one could
22:25:43 <mmorrow> hmm
22:25:56 <ski>   (a) make a monomorphic structure for some particular value of `s' .. like `[Int]' or something
22:26:18 <ski>   (b) make a polymorphic structure that is still "monomorphic inside"
22:26:32 <Saizan> in mapState the 's' doesn't change, but i see what you mean
22:26:45 <ski>   (c) make a structure that includes a parameterized type, plus polymorphic operations
22:27:10 <ski> Saizan : err, right it doesn't .. for some reason i thought it did
22:27:28 <mmorrow> ski: oh, so the goal here is the write a source-to-source translator from haskell+some-ml-module-lang to (some number of) haskell modules encoding that sequence of structures/functor apps, etc
22:28:07 <ski> mmorrow : yes, i was suspecting that :)
22:28:33 <mmorrow> i'm thinking it'd be similar to how ghc encodes classes with dictionaries, but you'd build the interlinked structure of these dicts within the module lang, then they'd get spit out into a big knot
22:28:50 <ski> (io was just trying to enumerate sensible options)
22:29:26 * ski recalls a thread on comp.lang.functional about encoding ML structures and functors in Haskell
22:30:08 <Saizan> for State the (b) feels more natural to me, but i agree that it should cover all of those nicely
22:30:56 <Saizan> but if 's' becomes polymorphic inside the module, than there's no reason to take it as an argument to the structure
22:31:07 <ski> right
22:32:27 <blackdog> is there a consensus on the least painful way of getting unixy stuff on windows? cygwin?
22:33:35 <c_wraith> cygwin isn't bad these days
22:36:55 <blackdog> c_wraith: righto. had a quick look at msys, but i think i want terminals and all that as well.
22:49:12 <hackagebot> text 0.5 - An efficient packed Unicode text type (BryanOSullivan)
22:52:42 <ksf> mmmmhhh why, oh why, does matroska mess with ebml by having seek indices measured in bytes?
22:53:36 <ksf> that just utterly messes with the transport layer/data layer separation
22:54:11 <Makoryu> chr $ ord '1' - ord '/'
22:54:16 <Makoryu> > chr $ ord '1' - ord '/'
22:54:17 <lambdabot>   '\STX'
22:54:25 <Makoryu> > chr $ ord '/' - ord '1'
22:54:27 <lambdabot>   * Exception: Prelude.chr: bad argument
22:54:40 <Makoryu> > ord '\STX'
22:54:42 <lambdabot>   2
22:55:03 <ksf> you shouldn't do any arithmetic with chars that doesn't involve 0..9 , a..z or A..Z, all seperate domains.
22:55:22 <ksf> even C doesn't spec more (that is, it doesn't spec ascii)
22:55:52 <ksf> and it still has to decrypt ebcdic to support that arithmetic.
22:56:14 <ksf> ...so don't rely on anything, you could be running on an IBM mainframe.
22:56:20 <Makoryu> >_>
23:01:58 <dolio> If you're running Haskell on an IBM mainframe, it has unicode characters implemented.
23:03:55 <dolio> And at least 30-bit Ints.
23:06:39 <Makoryu> > let gr '~' = '\"'; gr '}' = '!'; gr x | x `elem` ['!'..'|'] = chr $ ord x + 2 | otherwise = x in map gr "int main(int argc, char *argv[]) {"
23:06:40 <lambdabot>   "kpv ockp*kpv ctie. ejct ,ctix]_+ }"
23:09:05 <jokerGTA> guys anyone can help me with something
23:09:58 <augur> so i have a minor question about type classes
23:10:06 <dolio> Well, if anyone can, then you should be in good shape. :)
23:10:21 <jokerGTA> i have this new type i defined
23:10:25 <jokerGTA> newtype MyType = My (Int,Int) deriving (Show)
23:11:01 <jokerGTA> if i want from another module to access first element from that type...i mean that first Int
23:11:02 <augur> if you have a type class like   class C a where ; f :: a -> b -> c
23:11:05 <jokerGTA> how would i do that
23:11:18 <jokerGTA> I cant treat this as pair?can i?
23:11:26 <jfredett> jokerGTA: well, you need to use pattern matching
23:11:29 <Makoryu> jokerGTA: You have to pattern match on it.
23:11:30 <augur> does this necessitate some other definition elsewhere like   class C b where ; f :: a -> b -> c
23:11:30 <augur> ?
23:11:48 <opqdonut> no
23:11:49 <Makoryu> jokerGTA: For example, foo (My (x, _)) = x
23:11:53 <jfredett> so - like when you use a list
23:12:05 <jfredett> you write a function foo [] = -- something to do on the empty list
23:12:07 <opqdonut> augur: no, why would it?
23:12:14 <dolio> augur: It means f :: forall a b c. C a => a -> b -> c.
23:12:17 <augur> opqdonut: conversely, if i had the (C b) case, would this be a valid type class?
23:12:27 <jfredett> then another case, foo (x:xs) = -- something to do with the first element (x) and the rest of the list (xs).
23:12:33 <dolio> But that doesn't have very many interesting implementations.
23:12:37 <opqdonut> augur: yeah
23:12:49 <ski> dolio : not `f :: forall a b c. C b => a -> b -> c', then ?)
23:12:54 <opqdonut> but as dolio said, neither of those is an interesting typeclass
23:13:03 <ski> mmorrow : you want `State' to have both signatures, yes ?
23:13:05 <augur> opqdonut: ok. i was just curious about what, precisely, type classes were doing with multiple arguments
23:13:10 <blackdog> augur: the typeclass doesn't make a lot of sense - informally, you're saying that you can give an implementation for 'a' that given an 'a', can take a 'b' and give a 'c'
23:13:12 <jfredett> So, when you define a type (newtype or data) in haskell, you get the ability to pattern match on it's constructors for free
23:13:33 <jokerGTA> what would happend for example if instead of those 2 being ints..what if those 2 ints where different data types
23:13:37 <jokerGTA> would i do same
23:13:38 <opqdonut> augur: the typeclass only affects the explicitly mentioned type parameters
23:13:39 <ski> mmorrow : one could also have a substructure with signature `Monad' inside `State'
23:13:44 <augur> so basically, f is defined for all types except the type-class quantified argument
23:13:50 <jfredett> jokerGTA: eg, you can write "foo (Foo (i,_)) = i" to get the first element of the newtype Foo = Foo (Int, Int) type
23:13:57 <augur> in which case for that argument its only defined for the specified type
23:14:00 <jfredett> jokerGTA: precisely the same thing
23:14:10 <jfredett> jokerGTA: except your return type would change
23:14:14 <ski> augur : which specified type ?
23:14:18 <jokerGTA> ok..tx
23:14:21 <jfredett> so in my example, foo has type Foo -> Int
23:14:23 <augur> well, i say all types, i mean obviously precisely the types mentioned in the signature for f
23:14:29 <opqdonut> augur: well
23:14:30 <jfredett> if it's a diff type, it'll be Foo -> <whatever>
23:14:43 <opqdonut> "forall a b c. C a => a -> b -> c" is in a sense defined for all a
23:14:56 <opqdonut> the C a constraint is checked after other type-inference and checking
23:14:58 <augur> such that a is a subtype of C
23:15:25 * jfredett is being a lazy ass... he should be working on HWN2... :/
23:15:31 <augur> ok. this makes sense. thank you. :)
23:16:06 <ski> `C' is not a type, so there is no subtypes of `C'
23:16:15 <augur> well, type class.
23:16:26 <augur> dont judge me! >o
23:16:34 <ski> why not ? :)
23:16:56 <augur> :|
23:17:08 <dolio> You can, in a way, think of type classes as kinds.
23:17:14 <jokerGTA> i know but for example
23:17:25 <dolio> forall (a :: C) (b c :: *). a -> b -> c
23:17:25 <jokerGTA> my data type has 2 elements
23:17:31 <dolio> Single-parameter type classes, that is.
23:17:38 <jokerGTA> lets call it element 1 and element 2
23:17:38 <augur> dolio: i was just typing something for the sake of being able to reference the notion of being a member of a typeclass
23:17:46 <augur> "subtype" was nice and short and you get the point
23:17:46 <jokerGTA> myData (Element 1, Element 2)
23:17:54 <ibid> dolio: resulting in subkinding?
23:18:00 <dolio> Yes.
23:18:04 <jokerGTA> now my element 1 is actually another type
23:18:19 <dolio> And intersection kinding if you specify more than one constraint, I guess.
23:18:36 <dolio> On a single type, that is.
23:19:05 <augur> btw, does it bother anyone that regular languages are closed under boolean combinations, but not all boolean combinations are implemented in the overwhelming majority of RegEx languages, despite their frequent utility?
23:19:19 <ski> dolio : i would rather think of type classes as having kinds ..
23:20:03 <ski>   MonadState :: (s :: *) -> (m :: * -> *) -> Monad m => instance
23:20:09 <ski> (or something like that)
23:20:38 <ski> (where `instance' would be the kind of fully applied type classes)
23:21:02 <performance> i have a list of lists of strings, how do i sort the original list by the third column ?
23:22:05 <c_wraith> what original list?  third column of what?
23:22:20 <c_wraith> How do you sort the other list by the third string in each sublist?
23:22:21 <dolio> Yeah, that notion extends more naturally to multi-parameter classes.
23:22:24 <c_wraith> *outer
23:22:46 <dolio> And is more useful for implementing type classes in languages without them.
23:23:03 <c_wraith> If that's the question you're asking, the answer would be something like sortBy (compare `on` (!! 3))
23:23:04 <ski> @type sortBy (comparing (!! 2))
23:23:06 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]]
23:23:13 <c_wraith> er, yes.  0-indexed.  !!2
23:23:39 <ski> @type (compare `on`)
23:23:40 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
23:23:45 <ski> @type comparing
23:23:46 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:23:51 <performance> c_wraith: yes lets say a list of first name, last name, city ..  thanks ski
23:24:25 <ski> performance : but it sounds like you should probably use tuples or records, instead
23:24:29 <c_wraith> @hoogle comparing
23:24:29 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
23:24:54 <ski>   sortBy (comparing city)
23:24:58 <ski> assuming
23:25:06 <ski>   data Foo =
23:25:16 <ski>     { firstName :: String
23:25:24 <ski>     , lastName  :: String
23:25:31 <ski>     , city      :: String
23:25:35 <ski>     , ...
23:25:37 <ski>     }
23:25:56 <ski> so `city' is an accessor function of type `Foo -> String'
23:27:19 <ski> (s/Foo =/Foo = MkFoo)
23:27:35 <performance> ski, this is easier to write, just read the csv file iinto flc $ lines$  ( groupBy  delimiter ) $ sortbycity $ unlines. [ well $ or dot, i'll find the mistake soon in ghci :)]
23:28:12 <ski> (the brackets are unneeded)
23:28:21 <ski> and s/$/./, yes
23:42:25 <performance> my objective is to see if i can automate my currently partially manual process .. and replace awk grep etc.. with haskell functions :)
23:44:14 <performance> i have a source tree with several .cxx files, but some functions have been deprecated, there is a static checker tool which takes a list of suspect functions, and the root of the source tree and inserts comments before each instance where a deprecated function is used
23:45:27 <performance> currently i run this once, then grep for the commented lines, and extract it into a file, and then pipe it through a bunch of unix tools like grep, sort , uniq, etc
23:46:48 <performance> what im left iwth is, a single file with  (deprecated function name,  status,  hint for porting if availalbe) on each line
23:48:12 <performance> im trying to clean this up a bit so that i can get to all the instances of a particular function easily
23:54:08 <mxc> "erlang is a gateway drug, haskell is the hard stuff"
23:54:09 <mxc> i liked tht
23:57:20 <mmorrow> ski: ah yeah, i tried the Monad inside State, but couldn't seem to get it sorted out
23:59:40 <mmorrow> ski: i got as far as defining it (i think), but wasn't sure how to go from there http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4315#a4318
