00:01:04 <recurs|ve> I hate to be a noob but what is the haskell platform?
00:01:12 <recurs|ve> Is that just a collection of proggies?
00:01:23 <ivanm> a batteries-included collection of libraries
00:01:39 <recurs|ve> Alright, so to get started, I just need the ghc
00:01:46 <ivanm> at the moment, IIRC it's just a re-branding of the old ghc-extralibs
00:01:47 <recurs|ve> dont need the libs right?
00:01:52 <ivanm> recurs|ve: no, not for basic stuff
00:02:10 <ivanm> you'll probably want cabal-install if your OS/distro doesn't have haskell packages available
00:02:13 <recurs|ve> Alright, and finally, I did add the platform on my mac, where did it install stuff?
00:02:47 <recurs|ve> Grr :( thats why I hate precompiled stuff, who knows where it goes :(
00:02:51 <Axman6> /usr
00:02:55 <ivanm> recurs|ve: it's mainly libraries, so as long ghc knows where it is you don't need to know ;-)
00:03:10 <Axman6> recurs|ve: i highly recommend installing the platform
00:03:16 <Axman6> saves a lot of hassle
00:03:23 <ivanm> Axman6: O RLY
00:03:31 <recurs|ve> ivanm: true, but I would like to know as I am on a networked computer and if I switch computers, I want access to everything.
00:03:31 <Axman6> yarly
00:03:52 <ivanm> recurs|ve: install it per-user then? *shrug*
00:04:46 <igel> morning
00:05:20 <ivanm> afternoon
00:06:50 <ivanm> Axman6: by installing the platform, I get cgi, editline, opengl, glut and alex (none of which I need/use) and downgraded regex-{base,posix,compat}
00:07:10 <recurs|ve> ivanm: yea may have to do that.  The issue is I just need it on my user then I will have it.  I did the same for a custom ruby build, in ~/usr/bin
00:07:14 <Axman6> you also get cabal-install so you can upgrade everything you need
00:07:28 <ivanm> Axman6: I already have that ;-)
00:07:44 <ivanm> hmmm.... can cabal-install install the platform?
00:07:47 <recurs|ve> What is cobal-install -- I didn't get that
00:07:49 <ivanm> that might be the best way to do it...
00:07:59 <recurs|ve> Ah, cAbal install
00:08:03 <ivanm> recurs|ve: an installer/downloader/etc. for haskell packages
00:08:08 <ivanm> recurs|ve: right ;-)
00:09:15 <Cale> ivanm: Remember, it's running on a different machine
00:09:36 <Cale> (and it relies on the system having the appropriate fortune databases installed)
00:09:46 <ivanm> Cale: ahh, yes, forgot about the server change
00:29:23 <ivanm> @. elite quote
00:29:24 <lambdabot> cOW4rd1YDR4gON 54y$: [FR0/\/\ a REDdiT C0mMEnT +Hre4D] Don't 9E7 m3 s7aR7ed 0n mONAd. WHAT is TH47, A maN wI+h 4 5INGle +EzTiC|E?
00:29:44 <Axman6> ha
00:29:49 <boxxy> @. elite quote
00:29:49 <lambdabot> TarAl S4Yz: bUT I (4n d0 dp in (, whIC|-| hAz no rT
00:29:53 <boxxy> cOW4rd1YDR4gON 54y$: [FR0/\/\ a REDdiT C0mMEnT +Hre4D] Don't 9E7 m3 s7aR7ed 0n mONAd. WHAT is TH47, A maN wI+h 4 5INGle +EzTiC|E?
00:29:55 <boxxy> ha
00:30:02 <boxxy> TarAl S4Yz: bUT I (4n d0 dp in (, whIC|-| hAz no rT
00:30:15 <ivanm> boxxy: we all read them when lambdabot said them...
00:30:31 <boxxy> boxxy: we all read them when lambdabot said them...
00:30:36 <medfly> I didn't
00:30:55 <boxxy> I didn't
00:31:14 <Axman6> i didn't think we got trolls in here...
00:31:15 <ivanm> @slap boxxy
00:31:15 <lambdabot> stop telling me what to do
00:31:21 <Axman6> @slap boxxy
00:31:22 * lambdabot places her fist firmly on boxxy's jaw
00:31:24 <boxxy> i didn't think we got trolls in here...
00:31:27 <boxxy> @slap boxxy
00:31:27 * lambdabot beats up boxxy
00:31:28 <ivanm> @where ops
00:31:29 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
00:31:30 <boxxy> stop telling me what to do
00:31:33 <boxxy> @slap boxxy
00:31:33 <lambdabot> stop telling me what to do
00:31:36 <boxxy> @where ops
00:31:36 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
00:31:38 --- mode: ChanServ set +o dcoutts
00:31:40 <boxxy> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli
00:31:44 <ivanm> yay! dcoutts!
00:31:52 <boxxy> yay! dcoutts!
00:31:58 --- mode: ChanServ set +o Cale
00:32:13 --- mode: Cale set +b *!*@c-66-30-245-236.hsd1.ma.comcast.net
00:32:13 --- kick: boxxy was kicked by Cale (Cale)
00:32:27 <ivanm> thanks Cale
00:32:27 <jkff> O bliss
00:32:30 <fnord123> queen of /b/ indeed
00:32:34 <Cale> actually, I'm pretty sure that's the same guy as from yesterday
00:32:44 <medfly> there's a guy from yesterday?
00:32:46 <Cale> I seem to recall the n=qqqq part
00:33:00 <Axman6> must be troll #freenode today
00:33:03 <plcs> pre-programmed messages?
00:33:09 <Axman6> s/today/day today
00:33:16 <plcs> Axman6: it is? Righto!
00:33:16 <medfly> 2009 Oct 03 11:02:07 *	bottttt (n=qqqq@c-24-218-200-148.hsd1.ma.comcast.net) has joined #haskell
00:33:22 <dcoutts> crazy
00:33:23 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
00:33:23 --- mode: ChanServ set -o dcoutts
00:33:29 <medfly> I think his IP changes.
00:33:36 --- mode: Cale set +b *!*n=qqqq@*
00:33:58 --- mode: Cale set -b *!*@c-24-218-200-148.hsd1.ma.comcast.net
00:34:20 --- mode: Cale set -o Cale
00:49:32 <Phyx-> *tap tap tap* is this thing on....
00:49:49 <ivanm> no, it isn't
00:49:56 <ivanm> there's absolutely no-one here
00:50:16 <Phyx-> so you don't count yourself as someone? of was that an automated response?
00:50:41 <ivanm> s/automated/sarcastic or semi-humorous/
00:51:27 <Phyx-> mkay.. guess it's too early for me to detect sarcasm :)
00:59:24 <Phyx-> well, i'm off, have a good day everyone
01:10:42 <fasta> What's the purpose of the stricter record syntax proposal?
01:13:54 <fasta> Never mind, I have read the whole proposal now. Still, just because some people write weird confusing code is no reason to disallow it.
01:17:16 <marcuse> hi guys, i'm reading real world haskell, and i keep seeing for example putStrLn $ whatever, what does the $ do?
01:18:14 <amaot> @src ($)
01:18:14 <lambdabot> f $ x = f x
01:18:38 <amaot> if this seems pointless to you, you're reading it right
01:19:28 <Phyx-> marcuse: it's a function with really low priority which does nothing. the use of it is, that when parsing f $ x + y for instance will be treated ast f (x+y)
01:19:53 * Phyx- stares at Saizan_ 
01:20:00 <bob2> ah, clever
01:20:05 <marcuse> Phyx-: oh, so i can replace $ .. with ( .. ) ?
01:20:23 <nlogax> yes
01:20:28 <Phyx-> marcuse: yes
01:21:02 <marcuse> ok, cool
01:34:46 <stanv> > elem 1 [0..0]
01:34:47 <lambdabot>   False
01:35:08 <stanv> :))) [0..0] - is infinite list :)
01:35:12 <ivanm> is that the surprised owl? :p
01:35:17 <ivanm> > [0..0]
01:35:19 <lambdabot>   [0]
01:35:25 <ivanm> stanv: no it isn't
01:35:37 <ivanm> note that if it was an infinite list, elem would either return True or hang
01:35:40 <stanv> > elem 1 [0,0..0]
01:35:44 <lambdabot>   mueval-core: Time limit exceeded
01:35:49 <stanv> :)))
01:35:53 <stanv> ah
01:35:55 <ivanm> see?
01:36:00 <stanv> yes :)
01:36:02 <ivanm> @. elite quote
01:36:03 <lambdabot> BLaIrphOugHton $aYs: "in /\/\y EGotis7IC4l 0pInI0n, /\/\0$T PE0pl3's c pr0GRAMz $H0uLD 83 IndEnted 5IX FEet downw4Rd aNd co\/3r3D WI+h dIR+." -- Bl4IR P. HouGH+On
01:37:34 <amaot> preflex: quote
01:37:35 <preflex>  <uninverted> Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
01:38:02 <opqdonut> @quote
01:38:03 <lambdabot> psnl says: ndm: you should have stayed around for the part where Conor denied he was Conor.
01:38:13 <ivanm> why, you remove the \0 from the end of the string?
02:14:26 <mmorrow> ski, Saizan_, dolio: here're the steps for (\m -> sum [prod [1..n] | n <- [1..m]]) that i've got in mind: http://moonpatio.com/repos/Fuse.hs
02:15:00 <mmorrow> currently trying to sort out everything that's happening there well enough to code it
02:16:30 <mmorrow> (also note that the encoding that's using for datatypes isn't typeable in system F (scott encoding))
02:16:44 <mmorrow> well, you can do it with a newtype
02:17:25 <mmorrow> e.g. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=112
02:19:36 <mmorrow> the end result is a nested, register-only pair of loops
02:42:21 <ivanm> gah, the report doesn't actually define what classes _are_
02:43:07 <FunctorSal> what, haskell classes?
02:43:20 <ivanm> yeah
02:43:27 <ivanm> OK, found wadler's paper on them, that'll do
02:49:28 <mmorrow> the sum[prod|..] version for 40000 takes 17.82 seconds, allocates 64,257,039,256 bytes, and does 122562 minor, 3 major collection (maybe 2, -sstderr seems to always have 1 major no matter what)
02:49:56 <mmorrow> and the optimized version on 40000 takes 4.8 seconds, and does 0 gc's
02:51:05 <mmorrow> it'd probably be faster too if ghc had fallthroughs between basic blocks
02:51:54 <mmorrow> err, actually probably wouldn't make a difference in this case (maybe)
02:52:17 <quicksilver> sounds promising
02:52:26 <quicksilver> although not good for exception handling / non-threaded rts :)
02:52:59 <mmorrow> quicksilver: heh, yeah no task switching
02:54:03 <quicksilver> if GHC actually gets good at compilnig code which has no allocations, it will have to invent a way to add safe points every few hunderd thousand cycles, I guess
02:54:10 <quicksilver> still I doubt that's too hard.
02:54:51 <Peaker> if ghci could run in an X window, this would be a cool feature: http://imgur.com/7bAxb.png
02:55:02 <Peaker> (checking for a GraphicShow instance or such, and using that would be awesome)
02:55:34 <Peaker> I guess it could also show cyclic structures and stuff as such.. or at least, that could be vacuum's result
02:55:40 <mmorrow> quicksilver: a solution to that that worked and didn't slow down the non-allocating code (unreasonably) would be really nice
02:56:40 <quicksilver> Peaker: yes. a workbook like interface with other show-like classes for other kinds of display would be nice
02:56:47 <mmorrow> Peaker: cool, what is that?
02:56:54 <Peaker> mmorrow, The "Factor" REPL
02:57:06 <mmorrow> Peaker: neat, i'll have to check that out
02:57:07 <Peaker> From Reddit
02:58:12 <quicksilver> preferably without descending into too deep a tarpit of non-terminating representations
02:58:23 <quicksilver> although, of course, Show instances can also fail to terminate.
03:01:49 <ibt> morn
03:05:48 <loremi> Hi, I have a 1500000 elems list of (Bool,Double,Double,Double), any ideas how to efficiently sort the list by second Double, it seems that Data.List.sortBy requires loads of memory?
03:07:15 <Peaker> quicksilver, It can terminate Show by length or time, a graphic representation of list of lists or such can also be terminated by length or time
03:07:31 <Peaker> (And if its just an array of some size, it can be terminated by time...)
03:08:18 <ivanm> loremi: use a schwartzian transform
03:08:23 <mmorrow> loremi: if you could possibly use uvectors somehow either instead of the list or convert to uvector(s) somehow, this might help http://hackage.haskell.org/package/uvector-algorithms
03:08:31 <ivanm> actually, forget that
03:08:41 <ivanm> you're not calculating the second Double each time
03:08:53 <ivanm> loremi: sortBy should be O(n log n) in your case...
03:09:03 <ivanm> @src sortBy
03:09:04 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
03:09:21 <ivanm> it really uses insertion sort? :o
03:09:22 <int-e> fiction.
03:09:26 <ivanm> loremi: do you have duplicates?
03:09:30 <loremi> it seems I have problem with memory (not enough RAM)
03:09:30 <int-e> no, it uses a merge sort.
03:09:33 <ivanm> if not, S.toList . S.fromList ?
03:09:33 <mmorrow> , rnf [1..1500000] `seq` ()
03:09:36 <lunabot>  ()
03:09:37 <loremi> ivanm: no duplicates
03:09:42 <quicksilver> Peaker: actually, haskell has no faciltity to terminate show instances by time.
03:09:43 <ivanm> right, use a Set ;-)
03:09:47 <int-e> which actually becomes a heap sort dynamically.
03:10:00 <ivanm> int-e: OK, lambdabot is lying then...
03:10:08 <ivanm> or else insertBy is a poorly chosen name
03:10:10 <ivanm> @src insertBy
03:10:11 <lambdabot> insertBy _   x [] = [x]
03:10:11 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
03:10:11 <lambdabot>                                  GT -> y : insertBy cmp x ys'
03:10:11 <lambdabot>                                  _  -> x : ys
03:10:22 <ivanm> yup, insertBy seems to lead to insertion sort
03:10:26 <int-e> ivanm: sort is defined that way in the haskell report.
03:10:26 <quicksilver> ivanm: @src is a work of fiction. Believe it at your peril.
03:10:35 <ivanm> quicksilver: heh
03:10:41 <quicksilver> ivanm: it has no correspondance with the actual source of actual functions.
03:10:53 <mmorrow> , (rnf . sort . take 1500000) (randoms (mkStdGen 09747) :: [Double])) `seq` ()
03:10:54 <lunabot>  luna: parse error on input `)'
03:10:58 <mmorrow> , (rnf . sort . take 1500000) (randoms (mkStdGen 09747) :: [Double]) `seq` ()
03:11:03 <lunabot>  Killed.
03:11:03 * ivanm wonders how feasible it would be for lambdabot to parse the library sources to get real source code...
03:11:26 <ivanm> mmorrow: that mkStdGen must be at fault! :p
03:11:54 <ivanm>  , (rnf . Data.Set.toList . Data.Set.fromList . take 1500000) (randoms (mkStdGen 09747) :: [Double]) `seq` ()
03:11:59 <mmorrow> , (rnf . sort) (fmap fromIntegral [1500000,1500000-1..1::Int] :: [Double]) `seq` ()
03:12:05 <lunabot>  ()
03:12:06 <ivanm> , (rnf . Data.Set.toList . Data.Set.fromList . take 1500000) (randoms (mkStdGen 09747) :: [Double]) `seq` ()
03:12:07 <lunabot>  luna: Not in scope: `Data.Set.toList'
03:12:11 <mmorrow> aww, that's not so bad
03:12:28 <ivanm> mmorrow: see? it _was_ the randomness! ;-)
03:12:41 <mmorrow> loremi: maybe the memory use isn't on account of sort?
03:12:45 <ivanm> mmorrow: doesn't lunabot know about sets?
03:12:57 <Peaker> quicksilver, It could terminate them by time easily, though :-)
03:13:20 <mmorrow> ivanm: System.Random is like watching a slow-mo replay of a slow-mo replay
03:13:47 <mmorrow> ivanm: importing things qualified is a huge pita with the ghc-api unfortunately
03:13:55 <mmorrow> well, in ghci too for that matter
03:14:40 <Baughn> mmorrow: System.Random is that slow?
03:14:45 <mmorrow> hmm, actually it's not *that* big of a pita, i'mmmm just lazy ;)
03:14:58 <Baughn> mmorrow: ..guess I'll use /dev/urandom then
03:14:58 <mmorrow> Baughn: slower!
03:15:10 <Baughn> Hm. No, actually.
03:15:14 <mmorrow> cat /dev/urandom | od | HsColour -tty
03:15:15 * Baughn needs a cryptographic PRNG
03:17:02 * mmorrow uses HsColour -tty for all kinds of random crap
03:17:05 * Baughn wonders if the decision to use 32-bit message lengths in this protocol will bite him on the back some day
03:17:12 <mmorrow> in this case, literally!
03:17:44 <mmorrow> Baughn: 32bit is deprecated
03:18:09 <Baughn> mmorrow: But it saves me four bytes!
03:18:22 <Baughn> ..on average.
03:18:27 <mmorrow> 16bit saves you 6!
03:18:30 * Baughn pokes the 16-byte block cipher
03:18:32 <loremi> thanks, I will try Data.Set
03:19:16 <Baughn> mmorrow: I might argue that, as I'm using strict bytestrings, a design that requires >4GB messages is fundamentally broken
03:19:19 <ibt> Baughn: what do you mean by 'cryptographic prng'?
03:19:33 <Baughn> ibt: You know. Blum Blum Shub and friends.
03:19:40 <mmorrow> Baughn: hah, i just realized that you said _lengths_
03:19:42 <Baughn> That still sounds like something from a lovecraft novel.
03:22:33 <ibt> Baughn: what's the application?
03:22:36 <mmorrow> ibt: that given a hash, you can't do any more than a probabilistically negligible amount better than guessing at random what the original message was
03:23:05 <Baughn> ibt: Network encryption
03:23:14 <Baughn> ibt: Specifically, generating the keys and IVs
03:23:26 <Baughn> So, yeah, need cryptographic PRNG.
03:23:29 <ibt> mmorrow: wasn't sure if he meant prng using crypto or a CSPNG or whatever
03:23:33 <loremi> ivanm: and about sorting and Swarzian Transform - does haskell laziness automatically swarzian transforms?
03:23:37 <Baughn> OpenSSL's is /probably/ BBS, but it doesn't guarantee that..
03:23:49 * Baughn will just implement it in haskell. Again. Wonder if it'll be faster than System.Random?
03:24:07 <ivanm> loremi: no
03:24:31 <mmorrow> oh, cryptographic _prng_
03:24:35 <ivanm> since you still end up re-calculating the (a -> b) function (if you don't transform)
03:24:39 <int-e> loremi: How much is 'loads of memory' in your case? 300, maybe 400 MB is what I'd expect.
03:24:41 * mmorrow thought he said hash function
03:24:44 <ivanm> after all, Haskell doesn't memoize by default!
03:25:01 <Baughn> ibt: The neat thing about BBS is, its randomness is of such quality that you could use it for a one-time pad and it'll be safe. :P
03:25:24 <Baughn> Now there's a funny story..
03:25:44 <ivanm> where? I don't see one...
03:25:58 <Baughn> Um. Might not be that funny. Oh well..
03:26:00 <loremi> int-e: maybe I'm doing something wrong, but > 1GB, after that I don't know (OOM killer, tharshing etc)
03:26:53 <Baughn> ivanm: Back in middle school, I wrote a chat program based on one-time padding with BBS, with RSA used to distribute the seed. I decided, later, that obviously that's insecure.
03:27:19 <Baughn> ivanm: ..and then, last year, I discovered I'd just been reinventing the wheel and it was about the most secure scheme we have. ^^;
03:27:26 <ivanm> heh
03:27:31 <ivanm> was about to ask how it was insecure...
03:28:41 <medfly> do you want a cookie?
03:29:07 <ivanm> nah, I'm OK at the moment
03:29:07 <fasta> Has "any" been generalized already to general sequences?
03:29:09 <ivanm> ;-)
03:29:16 <ivanm> @hoogle any
03:29:17 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
03:29:17 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
03:29:17 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
03:29:22 <ivanm> fasta: yup
03:29:27 <fasta> Ah, nice.
03:29:41 * ivanm just always forgets whether such functions are in Foldable or Traversable
03:30:19 * Baughn has yet to figure out what Traversable is /for/
03:30:34 <Baughn> (Haven't tried very hard, I must admit)
03:30:58 <quicksilver> mapping a monadic (or applicative) action over a structure and keeping the results in the same shape structure
03:31:14 <quicksilver> generalising mapM from lists, that is.
03:31:18 <ivanm> quicksilver: whereas foldable is for collapsing a structure?
03:31:26 <quicksilver> (or sequence)
03:31:32 <quicksilver> right.
03:31:33 <Baughn> quicksilver: Oh, so that's it..
03:31:42 <Baughn> quicksilver: I was looking for something like a zipper typeclass. :P
03:31:54 <quicksilver> foldable is for collapsing to a single value.
03:32:15 <ivanm> is Haskell' looking at making [] use Foldable/Traversable and thus having to avoid importing them qualified?
03:32:20 <quicksilver> no.
03:32:30 <ivanm> because that would be too drastic?
03:32:40 <ivanm> or because it would remove the "learning" behaviour of Haskell?
03:34:04 <quicksilver> well mostly because it hasn't been proposed, I think ;)
03:35:08 <ivanm> heh
03:36:47 <int-e> loremi: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10456#a10456 confirms my guess - maybe your program hangs on to more memory when it creates the list?
03:38:19 <fasta> What do you think abou this? http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax
03:38:53 <fasta> about*
03:38:54 <ivanm> I don't think that's really that useful...
03:39:17 <fasta> I think there are much better reasons to kill backwards-compatibility.
03:39:19 <loremi> int-e: thanks, will look into this, I have (bool,(double,double,double)), but that should not increase results too much
03:39:26 <ivanm> especially since hlint keeps telling me to remove parentheses!
03:39:33 <ivanm> fasta: agreed
03:40:12 <fasta> I don't think backward-compatibility is that important. Just give people the tools to do the conversion if you want to change something.
03:40:34 <ivanm> fasta: well, we don't want a _complete_ rewrite
03:40:50 <fasta> ivanm: what do you mean?
03:41:02 <ivanm> you don't want Haskell' to look nothing like Haskell ;-)
03:41:07 <fasta> Oh, right.
03:41:13 <ivanm> and it looks good of what Haskell' is doing now where each year they (possibly) produce a slightly different report, so you gradually change the language...
03:41:40 <SamB_XP> Haskell' is obviously supposed to be the derivative of Haskell ;-P
03:41:47 <ivanm> SamB_XP: heh
03:41:52 <ivanm> :o looks like it's been accepted...
03:48:20 <int-e> This is a great opportunity for quoting out of context: "I propose that all of f, g, h and i be made illegal."
03:48:29 <ivanm> heh
03:48:48 <SamB_XP> int-e: oh, you're saying that about the proposal ?
03:49:12 <ivanm> SamB_XP: I believe he meant the letters...
03:49:17 <SamB_XP> @remember int-e This is a great opportunity for quoting out of context: "I propose that all of f, g, h and i be made illegal."
03:49:17 <lambdabot> It is forever etched in my memory.
03:49:18 <ivanm> ;-)
03:49:36 <int-e> yes. I don't mind the proposal either way actually, despite making use of that feature (i.e. I have some code that I'd have to fix).
03:49:36 <ivanm> SamB_XP: should reference the proposal in that quote...
03:49:50 <SamB_XP> ivanm: but that's not out-of-context
03:50:00 <ivanm> heh
03:50:00 <SamB_XP> duh
03:50:06 <ivanm> people have to know how out-of-context it is!
03:50:23 <int-e> besides, google will find the context for you.
03:50:37 <ivanm> true
03:50:46 <ivanm> @google "I propose that all of f, g, h and i be made illegal."
03:50:48 <lambdabot> No Result Found.
03:50:58 <ivanm> int-e: you were saying?
03:51:00 <SamB_XP> @remember int-e I propose that all of f, g, h and i be made illegal. (referring to http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax as it existed on 2009-10-05)
03:51:00 <lambdabot> It is stored.
03:51:25 <SamB_XP> okay, now they could find it if they thought to try looking for another quote with that in it ;-P
03:51:32 <ivanm> heh, true
03:51:59 <SamB_XP> the date is just in case that gets changed in a way such that the letters don't mean the same things ;-)
03:52:47 <ivanm> yeah, it might refer to g, h, i and j tomorrow...
03:53:50 <SamB_XP> ivanm: unlikely that it would be tomorrow, I think, but something like that, yes ;-)
03:54:30 <SamB_XP> unless you know something that I don't -- which you probably do, but possibly nothing relevant ;-P
03:54:49 <SamB_XP> for instance, you may know your telephone number, but that's hardly germane
03:55:21 <ivanm> heh
03:56:46 <SamB_XP> but then again you may know that there is some intense discussion on the haskell' list, which is indeed relevant ;-)
03:57:27 <ivanm> heh, I don't read the haskell' list
03:57:39 <ivanm> or the libraries list
03:59:46 <SamB_XP> me either, generally
03:59:58 <SamB_XP> but I didn't know that
04:04:21 <SamB_XP> heh
04:04:45 <SamB_XP> some"one" is claiming to want my picture because they "saw" my profile on ohloh.net
04:04:53 <Veinor> I think haskell is one of the few languages where i is not the most common one-letter variable
04:05:08 <Baughn> Now, now. There's also Scheme.
04:05:09 <SamB_XP> or, wait, "she" claims to want to send her picture to me
04:05:18 <Veinor> that's why I said "one of the few", not "the only" :P
04:05:26 <Veinor> I'm guessing most functional languages use f more than i :P
04:05:37 <flux> veinor, how about this claim: mostly imperative languages have 'i' as the most common one-letter variable?
04:05:44 <Veinor> yeah.
04:05:44 <flux> f and x :)
04:05:47 <ivanm> Veinor: heh
04:05:54 <Baughn> Veinor: Oh, and i isn't a common variable name in Malbolge, either.
04:05:56 <SamB_XP> yeah, it's definately claiming to be interested in romance
04:06:00 <Veinor> Baughn: :V
04:06:59 <ivanm> SamB_XP: what, your OS expertise sounds really sexy or something? :p
04:07:33 <SamB_XP> ivanm: I don't have OS expertise do I ?
04:07:50 <ivanm> SamB_XP: open source, I mean
04:07:54 <SamB_XP> hehehe
04:08:02 <SamB_XP> I guessed ;-P
04:08:14 <SamB_XP> but like being obtuse
04:08:26 <ivanm> no, really?
04:08:30 <ivanm> I would never have guessed...
04:08:42 <SamB_XP> I see you like too ;-)
04:10:10 <int-e> ivanm: well, searching for that works for me.
04:11:03 <SamB_XP> flux: and j as the second-most-common?
04:11:19 <SamB_XP> though x actually gets used a lot too
04:13:18 <Veinor> that's a good question, x vs j in imperatives
04:13:29 <Veinor> I'd say j, probably
04:13:54 <ivanm> a would be popular in Haskell as well, though mainly as a type variable...
04:14:40 <Veinor> yeah.
04:15:05 <Veinor> I write austere haskell. all of my variables are named a, a', a'', a''', etc.
04:15:16 <SamB_XP> Veinor: hehe
04:15:30 <ivanm> @remember Veinor I write austere haskell. all of my variables are named a, a', a'', a''', etc.
04:15:31 <lambdabot> Good to know.
04:15:32 <SamB_XP> why not just use (?) (??) (???) like that one IOHCC?
04:16:00 <SamB_XP> @quote variable
04:16:00 <lambdabot> ghc says: At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
04:16:05 <SamB_XP> @quote variable
04:16:05 <lambdabot> ghc says: There must be at least one non-type-variable in the instance head
04:16:09 <SamB_XP> @quote variable
04:16:10 <lambdabot> blackdog says: My variables aren't varying.
04:16:16 <SamB_XP> @quote variable
04:16:16 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
04:16:17 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
04:16:33 <SamB_XP> lol
04:16:36 <SamB_XP> I love that one
04:16:41 * SamB_XP lies
04:16:52 * SamB_XP didn't actually laugh out loud just now
04:16:59 <SamB_XP> @quote variable
04:16:59 <lambdabot> ghc says: There must be at least one non-type-variable in the instance head
04:17:01 <SamB_XP> @quote variable
04:17:02 <lambdabot> ghc says: At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
04:17:04 <SamB_XP> @quote variable
04:17:04 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
04:17:08 <SamB_XP> @quote variable
04:17:08 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
04:17:19 <blackdog> heh, thought i'd been summoned
04:17:47 <SamB_XP> blackdog: why weren't your variables varying?
04:17:47 <blackdog> hm, i wonder how many olin quotes there are in there
04:17:55 <SamB_XP> @quote OlinShivers
04:17:56 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
04:17:58 <blackdog> buggered if i know :)
04:17:59 <SamB_XP> @quote OlinShivers
04:18:00 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
04:18:02 <int-e> I love that cjs quote.
04:18:23 <SamB_XP> int-e: welcome to the club
04:18:29 <SamB_XP> how do we form a club, anyway?
04:18:45 <SamB_XP> @quote cjs
04:18:45 <lambdabot> cjs says: In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in
04:18:46 <lambdabot> the system), and come out having *enjoyed* myself? Praise to the Lord!
04:18:48 <blackdog> is it kosher to quote out-of-irc?
04:18:52 <ivanm> SamB_XP: I think you need to see the government about that...
04:19:01 <blackdog> from olin: I'm not twitching. I'm controlling my impulse to snag my 9mm Sig-Sauer out from my day-pack and make a few strong points about the quality of undergraduate education in Amerika.
04:19:20 <SamB_XP> blackdog: what has that to do with anything ?
04:19:40 <SamB_XP> hmm, I wonder what language cjs was talking about there ???
04:19:40 <blackdog> one day, i hope to make something cool enough to put a bad-ass acknowledgment up front
04:19:50 <blackdog> SamB_XP: oh, very little. it's just a cool quote.:)
04:20:20 <SamB_XP> oh, I wait, I wasn't reading it right, it could be Haskell he meant
04:24:20 <SamB_XP> blackdog: oh, you mean like a book ?
04:25:55 <blackdog> SamB_XP: yeah. that's in the acknowledments for the SCSH manual
04:26:26 <SamB_XP> scsh? oh, scheme shell?
04:27:27 <SamB_XP> hmm, is non-melt-able valid english ?
04:32:08 <blackdog> SamB_XP: yeah. http://www.scsh.net/docu/html/man.html
04:32:18 <byorgey> SamB_XP: I'd write it "non-meltable"
04:32:25 <blackdog> unmeltable?
04:32:28 <blackdog> meltless
04:32:30 <blackdog> :)
04:32:31 <SamB_XP> byorgey: that's what I had
04:32:34 <SamB_XP> but mozilla didn't like it
04:32:47 <byorgey> I've never seen that word specifically, but no native English speaker would even blink at it
04:33:00 <byorgey> but yeah, it probably isn't in any dictionaries
04:33:25 <SamB_XP> well, if people laugh at it, so much the better ;-)
04:33:30 <byorgey> ok =)
04:33:48 <blackdog> SamB_XP: if it won't melt, you need a bigger death ray.
04:34:22 <SamB_XP> what if it burns instead?
04:36:28 <byorgey> when increasing the power of the death ray, you may have to lower the ambient oxygen concentration in order to achieve proper meltage.
04:36:33 <blackdog> you can't do science without incinerating a few whatever-it-was-es.
04:37:12 <blackdog> byorgey++. just the right combination of science nerd with disturbing mad professorage.
04:37:16 <byorgey> from the death ray owner's manual, page 48, "Tips and Tricks"
04:37:43 <ivanm> byorgey: where did you get your death ray from?
04:38:21 <SamB_XP> byorgey: and since when do they come with manuals ?
04:38:36 <byorgey> ivanm: I make them.
04:38:39 <ivanm> ahhh, OK
04:38:41 <byorgey> I wrote the manual myself.
04:38:46 <ivanm> byorgey: so you're reading from your own manual?
04:38:53 <byorgey> yes.
04:38:58 <blackdog> byorgey--. self-citing considered harmful.
04:39:04 <byorgey> aww =(
04:39:08 <ivanm> @slap blackdog
04:39:09 <lambdabot> I'd rather not; blackdog looks rather dangerous.
04:39:13 <blackdog> hey, easy come, easy go.
04:39:16 <blackdog> ha!
04:39:21 <byorgey> hehe
04:39:26 <blackdog> lambdabot has seen my new haircut.
04:39:27 <quicksilver> non-well-founded citation graphs are the best kind.
04:39:36 <jstintime> I wouldn't critique someone with a death ray myself
04:39:56 <mmorrow> unless there's a lot of ambient oxygen, that is
04:40:35 <ivanm> true
04:41:27 <SamB_XP> hmm ... I wonder how you can model a total order without decidable comparison?
04:46:37 <byorgey> SamB_XP: hmm, so it's clasically a total order, but not intuitionistically?
04:47:08 <byorgey> do you have an actual example/use case, or just wondering?
04:47:14 <byorgey> I'm curious
04:47:18 <SamB_XP> well, I don't have a use case myself
04:47:33 <SamB_XP> but I'd think it would be nice for e.g. the constructive reals ?
04:48:08 <byorgey> there isn't decidable comparison on the constructive reals?
04:48:10 <EvilTerran> quicksilver, if we could devise some concept of "parameterised citation", we could have structurally recursive citation graphs...
04:54:47 <quicksilver> byorgey: it would still be a total order, even intuitionsistically
04:54:58 <quicksilver> byorgey: it's just that you wouldn't (always) be able to check the axioms
05:01:29 <byorgey> oh, I see, you just have the total-order-ness as an axiom
05:06:31 <bastl> hi. how can I create the default ColorPreferences value for HsColour quickly? (when using it as a library=
05:06:33 <bastl> =?
05:08:47 <malcolmw> bastl: cat .hscolour ? or Language.Haskell.HsColour.Colourise.defaultColourPrefs?
05:12:49 <bastl> ok, thanks. defaultColourPrefs works. (But i cant find it in hoogle? )
05:13:23 <ivanm> bastl: hoogle only covers a limited number of packages
05:13:26 <ivanm> hayoo has more
05:15:35 <bastl> what is the ratio here? how should I decide where to go when looking for something? (in any case: I dont want to decide, just lookup and find the right thing)
05:19:54 <ivanm> what does CPP stand for?
05:20:14 <Zao> C Pre-Processor?
05:20:41 <ivanm> that's the one, thansk Zao
05:22:04 <Schalken> What's the shortest way to write 'A list of 400 zeros ('0')'? At the moment I have: take 400 ['0', '0'..]
05:22:23 <Zao> @t replicate
05:22:23 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:22:27 <Zao> @type replicate
05:22:28 <lambdabot> forall a. Int -> a -> [a]
05:22:37 <Zao> There's also repeat for infinite repetition.
05:22:51 <Schalken> Aha!
05:22:55 <Schalken> replicate 400 '0'
05:23:01 <Schalken> Exactly what I was looking for
05:23:04 <Zao> > let x = replicate 400 '0' in (length x, x)
05:23:05 <lambdabot>   (400,"000000000000000000000000000000000000000000000000000000000000000000000...
05:23:43 <ziman> > let (✕) = replicate in 400✕'0'
05:23:44 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
05:31:31 <younder> Why dopeople find the proof of NP compeltion difficult?
05:32:12 <younder> It is obvious, once gotten away with Turing macines and started with lanbda calulus.
05:32:34 <younder> You just imply the pumping theorem.
05:32:39 <Jafet> Feel free to come up with a proof for it
05:33:44 <younder> From there it just comes down to 'Differental equatins and why we can't sovle very many of them' by Braun
05:34:19 <ziman> what do you mean by "the proof of NP completion"?
05:34:19 <younder> You just substitute descrete varabes for real variables in the proof.
05:34:50 <younder> ziman:  yes
05:35:24 <ilid> by substitution, then: "Why dopeople find yes difficult?" i'm not sure they do
05:35:32 <Beelsebob> you mean yes by the proof of NP completion?
05:35:32 <younder> Exponatial developes because in primitive recurion you have a non-reductible two pump.
05:35:33 <Beelsebob> well yes, yes is easy to prove
05:35:36 <Beelsebob> yes
05:35:40 <Beelsebob> QED
05:35:45 <ilid> i actually take yes as an axiom
05:35:48 <Beelsebob> exactly
05:36:07 <younder> And yes in 50 years i ave heard that noone has proved it. Why is that?
05:36:41 <Jafet> Because no one has been as smart as you were just now
05:37:00 <ivanm> Jafet: s/as smart/as much of a smart-arse/ ? :p
05:37:18 * Jafet quiet
05:37:30 <younder> If you need a book on theory of computation' I suggest Lewis and Papadimtrou
05:38:47 <younder> pumping theore
05:38:50 <younder> m
05:38:55 <ilid> younder: i suggest you publish your result as soon as you can, before someone else from this channel beats you to it!
05:39:07 <ilid> there's a million dollar prize at stake!
05:39:13 <younder> I don't want iit it is trivial
05:39:38 <younder> ilid: well take it
05:40:40 <younder> I won't feed you, but I have given you a few hint's.
05:40:42 <ilid> younder: i'm sorry, i'm not smart enough to understand your proof so i can't take it :(
05:41:25 <younder> f cource I hope I have missed something basic, or I will be embarrassed on sake of humanity.
05:41:34 <Jafet> http://math.ucr.edu/home/baez/crackpot.html random fun link
05:41:46 <ivanm> is the proof any more complex than "because"?
05:42:15 <ivanm> heh: "40 points for comparing yourself to Galileo, suggesting that a modern-day Inquisition is hard at work on your case, and so on. "
05:42:18 <younder> beacause? I just provded a outline
05:42:35 <ilid> younder: no, you've not even clearly stated what it is you think you've proven
05:42:42 * ivanm hasn't been paying attention...
05:43:23 <younder> iild: what do you know of the pumping theorem?
05:45:05 <younder> A one pump gives rise to a recursive decent or LALR compiler ore even A stack based one LR(n)
05:45:37 <ilid> younder: traditionally people start with a statement of what they're proving before they move on to the proof itself
05:46:54 <younder> Not if you read Spivak. I am trying to do a bit of forward reasoning to justify my claim.
05:47:25 <Philippa> "the" pumping theorem/lemma?
05:47:28 <Philippa> there are a number of them
05:49:05 <Beelsebob> Philippa: well obviously there's only one that proves the NP completeness theory
05:49:06 <Beelsebob> >.>
05:49:06 <Beelsebob> <.<
05:49:27 <Beelsebob> I have to admit, he's more imaginative than the average troll
05:51:06 <younder> basically a F(x,y) is pumping if there is a irrep (x, y)
05:51:45 <younder> or you could write it f(x')
05:53:05 <Philippa> but your line of argument is clearly mistaken, as shown by the narf theorem
05:56:34 <younder> Now Under what criteria could you do that: You can solve all difference equalions if they are on the form Q(X, y) = 0
05:57:00 <Baughn> younder: ..get thee to #math
05:58:00 <Philippa> younder: but Q is clearly different from F
05:58:18 <younder> so if you have a Q(X, Y) = Z
05:58:51 <younder> Philippa: They are just stand'ins for functions, they regard heir genral form not theit values
06:00:03 <younder> sorry that went by a bit fast. (lot's of spelling errors)
06:00:04 <Philippa> but the narf theorem clearly shows that they have no general form!
06:00:23 <Philippa> their highest-ranking form is that of major!
06:01:05 <younder> Evere heard of a minimal subset!
06:01:08 <Baughn> ..you're all doing this wrong
06:01:19 <ilid> even if they had a most general form, heigel's reciprocity formula doesn't hold in the quasi-uniform bessel space you're operating in, so the transformation is ill-founded
06:01:22 <Baughn> By using a minimal algebra over the empty set, proving that P=NP is /trivial/
06:04:03 <younder> iild ?
06:04:59 <fasta> Philippa: did you attend Curt Sampson's talk and asked a question there?
06:05:20 <Philippa> fasta: nope
06:05:27 <Philippa> didn't make anything in Edinburgh
06:05:31 <younder> iild: Heigel is a philosopher.. Not a mathematician
06:06:16 <ilid> younder: you don't know heigel's reciprocity formula?
06:06:24 <Philippa> younder: only constructive criticism, thanks. And any constructivist knows the two are isomorphic
06:09:42 <younder> Philippa: No they are a mapping. (Russel, Descartes, Pascal etc. are. but say Plato, Augustion are not)
06:10:12 <younder> Sorry this is degeneration into nonsence, I will shut up
06:10:28 <fasta> ilid: you were the one that read the Merlin paper, right?
06:10:28 <Philippa> younder: you simply don't know how to interpret them mathematically, that doesn't mean that such an interpretation doesn't exist
06:10:38 <ilid> fasta: yeah, i read it
06:11:00 <fasta> ilid: where was the point that it assumed exponential precision according to you?
06:11:36 <ilid> i don't remember, and i can only cope with one P=NP "proof" per day, sorry! :)
06:12:24 <ilid> fasta: in any case, merlin can't work because younder has proved that P/=NP
06:13:02 <fasta> ilid: the paper that we talked about that might refute an entire class of algorithms like that, doesn't seem to apply to this particular approach, but I have the idea that there might be an exponential amount of sub-routes, which would require exponential precision in the summation to 1.
06:13:24 <fasta> ilid: is that a joke?
06:19:55 <ilid> fasta: yeah, requiring internal precision to grow exponentially to get extra precision in the LP's optimum would have the same type of issue
06:23:50 <younder> iild and had if possible has a polynomial bound, look a at the phase space not the values
06:24:20 <fasta> ilid: but still it remains quite tricky to see exactly where it goes wrong.
06:28:30 <fasta> younder: can you give a proper citation? Google doesn't find what you referred to.
06:33:10 <younder> I don't use Google much, It is based on my own observations. You wand a computation to be computable, in the range of the function you need a upper bound which is polynomial. What made me realize this was Limangood 'The distribution of prime numbers'
06:33:56 <Philippa> *cough*EXPTIME/EXPSPACE*cough*
06:34:44 <younder> Where you frequently narrow bands you reason about by using upper and lower limits.
06:35:00 <fasta> younder: come back when you have written something which is a bit more precise and clear.
06:35:15 <younder> fasta: agreed
06:36:31 <younder> This has not been coming out as well formulated as I hoped..
06:38:51 <younder> But basically it is Chachuy's squeze.
06:39:46 <younder> Familiar to people used to real analysis.
06:41:14 <fasta> You mean Cauchy?
06:41:19 <younder> yes
06:45:53 <younder> Sorry, I'm not really good at these chat channel things, I tend to come out to come upt too headstrong and cock sure, and I don't have time to think things through
06:46:53 <younder> That is not to say I haven't have time to think the NP-solution through, I just choose the wrong medium
06:47:13 <mmorrow> @slap younder
06:47:13 <younder> My apologies, for being a troll
06:47:14 * lambdabot smashes a lamp on younder's head
06:47:37 * mmorrow is so upset
06:49:40 <younder> mmorrow: but HELL you could use the stimulation.. ;)
06:51:01 <mmorrow> :)
06:51:39 <fasta> younder: probably at least 10,000s of people have had the idea that they solved P?NP. None of them has been able to provide a clear argument or was wrong.
06:52:06 <younder> fasta: I am aware of that.
06:52:26 <fasta> Probably it is faster to just let a program search for proofs than to let a human solve it.
06:53:09 <younder> Like Gauss said, You need the right notions, not the right notations.
06:54:00 <fasta> Notation is a wonderful way to make uninteresting stuff look interesting.
06:54:16 <Beelsebob> no, it's a wonderful way to make interesting stuff look uninteresting
06:54:17 <Beelsebob> :/
06:54:27 <Beelsebob> why do you think so many people don't do maths at even high school level
06:55:52 <younder> Beelsebob:  Unleash Mathematica and image processing etc Make it practical.
06:56:21 <Beelsebob> younder: shush – you should be busy writing up your proof
07:03:17 <fasta> Beelsebob: half-full/half-empty distinction.
07:03:59 * fasta notes that takeDirectory is quite useless.
07:04:31 <fasta> You would guess that for /a/b/c where c is a directory it would return a/b/c, but it doesn't.
07:04:54 * mmorrow prefers the half-full-of-empty/half-empty-of-full distinction
07:08:02 <mmorrow> data Half a = Empty a | Full a; fix (\T -> Half T)
07:09:21 * mmorrow wonder what being half full of half empty means
07:09:54 <Jafet> 1/2 of 1/2 = 1/4
07:11:04 <Beelsebob> but maybe it's also half empty of half full at the same time
07:11:18 <mmorrow> fix (\a -> 1/2 full of a)
07:11:58 <mmorrow> 1/2 full of {orange juice, walruses, half empty (of ...)}
07:12:10 <ziman> imo, half full = <0,0.5>, half empty = <0,0.5) :)
07:15:37 <fasta> What's the rationale behind getDirectoryContents returning relative file names?
07:16:03 <fasta> Efficiency? Since, I don't see any other reason.
07:16:29 <earthy> um.
07:16:29 <byorgey> fasta: well, if you can call getDirectoryContents, then you already know the base dir.
07:16:31 <earthy> no.
07:16:39 <byorgey> seems easier to prepend the base dir than strip it off.
07:16:43 <earthy> the base dir may be reachable through multiple paths
07:17:05 <earthy> it may well be that the path following '..' links in the dir is not the path used to originally reach it
07:17:30 <Botje> fasta: it's how readdir works
07:17:47 <Botje> fasta: and you often want to skip certain entries in a directory (like . and ..)
07:17:58 <Botje> stripping out the dirname every time is not very productive
07:18:17 <fasta> Botje: right, that's why I wrote my own get_absolute_file_names.
07:18:21 <Botje> also, map (dirname</>) `fmap` getDirectoryContents dirname
07:18:27 <Botje> it's not impossible :)
07:19:15 <saml> can you write file as a specific user?
07:20:20 <bastl> im making a custom build with userhooks. Now ./Setup.hs doesn find some dependencies that "cabal configure" did not complain about !?
07:20:39 <dcoutts> bastl: --user
07:20:54 <bastl> dcoutts: with ./Setup.hs !?
07:20:56 <dcoutts> bastl: see the Cabal FAQ for a more detailed explanation
07:21:00 <bastl> k
07:21:31 <dcoutts> bastl: note also that you can use your custom Setup.hs with the 'cabal' program.
07:21:38 <dcoutts> just cabal configure as per-usual
07:28:17 <bastl> dcoutts: then something is wrong with my hook. It works fine without cabal. Is it ok, to return "emptyBuildInfo" in my case? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4275#a4275
07:29:17 <dcoutts> bastl: you need to specify in your .cabal file that you're using build-type: Custom
07:31:21 <burp> how to do timeout for Network.connectTo?
07:31:44 <bastl> dcouuts: yeah, getting a step further ..
07:31:49 <bastl> tx
07:46:28 <burp> ok System.Timeout ;)
07:48:35 <hackagebot> typehash 1.4.0.0 - Create a unique hash value for a type. (LennartAugustsson)
07:49:05 <darrint> What's the function to determine if a FilePath or String represents a directory or file?
07:49:41 <quicksilver> doesDirectoryExist
07:49:45 <quicksilver> doesFileExist
07:50:22 <darrint> thanks.
07:50:41 <quicksilver> (not entirely logical I know)
07:54:36 <bastl> I would like to simulate OO-dot-notation for selector-functions of data-records. What would be a good, short name for (.) ?
07:54:52 <quicksilver> # is sometimes suggested
07:54:54 <burp> dot
07:54:56 <bastl> or is there already something for that ?
07:55:24 <quicksilver> well, I meant # for record dereference and keep (.) for function composition, of course.
07:55:47 <bastl> quicksilver: thanks
08:00:33 * Baughn notes that using M-x fill-paragraph on a haskell function produces hilarious results
08:04:40 <bastl> quicksilver: can i make # bind stronger than function application? so that I dont need parentheses for 'f person#name' ?
08:05:11 <quicksilver> no.
08:05:20 <quicksilver> nothing binds stronger than function application.
08:05:28 <quicksilver> that is a function of the grammar
08:06:00 <fasta> If you can choose between specifying the order of elements in an XML document or not, what do you choose?
08:07:12 <fasta> So, e.g. specifying that <c><a/><b/></c> is legal and <c><b/><a/></c> is illegal for example or just saying that any order is OK.
08:07:52 <quicksilver> I would say that any order is OK
08:08:00 <fasta> Specifying an order will make it faster to parse.
08:08:18 <quicksilver> that's a possible good reason to specify an order :)
08:11:07 <blackh> Hi all.  I want to give an introductory talk at the Linux conference in New Zealand and I wonder if you lot can help me with the title.  I should be able to do the rest by myself, hopefully. :)
08:12:02 <blackh> It's a bit tricky because I want to say Haskell is advanced without making it sound experiment or difficult.
08:13:05 <burp> @hoogle parMapM
08:13:06 <lambdabot> No results found
08:13:08 <burp> @hoogle parMap
08:13:09 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
08:13:19 <blackh> "Kicking bug butt with Haskell" :)
08:14:43 <Taejo> blackh: is your angle an anti-bug one? because I think it's a good angle, and certainly not a bad title
08:14:44 <hackagebot> KiCS 0.8.3 - A compiler from Curry to Haskell (BerndBrassel)
08:15:27 <Jafet> Stupidity is a pretty significant factor in bugs
08:15:33 <joevandyk> Hello all!  I'm just starting out w/ Haskell, having some experience w/ Ruby and C++.  It looks like an interesting language.
08:16:04 <joevandyk> does the show function print to stdout?
08:16:12 <Baughn> @type show
08:16:13 <lambdabot> forall a. (Show a) => a -> String
08:16:30 <Baughn> joevandyk: It returns a string, and is not in the IO monad, so it can't.
08:16:31 <Jafet> putStr might
08:16:36 <Baughn> Or print. ;)
08:16:38 <Baughn> @type print
08:16:39 <lambdabot> forall a. (Show a) => a -> IO ()
08:16:50 <Jafet> Or that
08:17:05 <dcoutts> blackh: btw, I did some refactoring with the Cabal stuff related to intra-package deps. I can't swear I didn't break it.
08:17:12 <blackh> Taejo: Anti-bugs will be a big theme, because essentially bugs are killing the industry, and Haskell has a lot to offer people.
08:17:35 <dcoutts> blackh: and I almost certainly changed things so that the patch you sent recently will not apply
08:17:43 <Jafet> I think Haskell programs are less buggy mainly because incompetent programmers stay away from it
08:18:15 <dcoutts> blackh: I tried darcs but if you've got some quick test case then give it a spin
08:18:36 <Taejo> blackh: I think most people would disagree that they're killing the industry. We've always had bugs, and part of our job is fixing them
08:18:45 <blackh> dcoutts: OK - I'll do that and flick you an email.
08:18:47 <Taejo> it's not like we're experiencing a sudden epidemic
08:18:55 <dcoutts> blackh: ta
08:19:13 <Jafet> Taejo, it's more of a slow, painful, decades-old terminal condition
08:19:35 <Jafet> Like AIDS
08:19:48 <blackh> Taejo: Well, that's a good point (that most people would disagree).  I won't say it like that - though it is my opinion.
08:19:56 <fasta> blackh: just explain the type-inferencer does more work.
08:21:20 <fasta> But please don't say that Haskell programs are shorter than their untyped equivalents. They are not.
08:21:34 <Taejo> types and purity also allows us to make things like quickcheck (which I thought was impressive when I first heard of it, and still am impressed when I use it)
08:21:38 <blackh> I'll go into detail about exactly how Haskell reduces bugs.
08:21:52 <Jafet> fasta, it depends on the language compared to
08:22:15 <Taejo> btw, I first heard of qc in John Hughes' ICFP 2007 talk
08:22:36 <Jafet> I suppose if you compare to perl (which is still somewhat typed)
08:22:38 <dv-> someone remind me what it means when ghc says that a package is hidden
08:22:54 <blackh> I'll only be comparing Haskell with the mainstream (Java, C# etc)
08:22:54 <fasta> Jafet: Take Scheme and a 5-10K LOC Haskell program.
08:23:08 <Philippa> fasta: sometimes haskell /can/ be shorter
08:23:52 <Jafet> Yes, but linux coders don't know scheme either
08:24:13 <Jafet> Except maybe the audiophiles
08:24:26 <haskellnoob> how do i do modular exponentiation efficiently in Haskell (code compiled using ghc)? I want to do the operation a^b mod m, where the values of a and b can be up to 10^20, and m can be up to 10^8. The naive way of doing this (a^b `mod` m) is too slow for my need.
08:24:27 <blackh> joevandyk: I'm certainly very pleased that you're starting out with Haskell.  You're going to learn some very interesting and useful stuff!
08:24:27 <Philippa> (when type info allows inference about which terms to use, as happens with type classes)
08:25:13 <ilid> haskellnoob: i'd define a data type (with a Num instance) which represents values mod m. then i'd use (^) with that type.
08:25:37 <Philippa> haskellnoob: same way you'd do it in another language? You might want to check that the types involved are the ones you're expecting though
08:25:39 <Jafet> The naive way being repeated squaring?
08:25:40 <joevandyk> blackh: yes, i hope so.  right know, i'm trying to figure out how to loop over each line from stdin and do something with it.  http://gist.github.com/202186 is where I'm at now.
08:26:04 <joevandyk> i'm working my way through the Real World Haskell book
08:26:18 <Rotaerk> joevandyk, look up "interact"
08:26:22 <Rotaerk> via hoogle
08:26:23 <joevandyk> thanks
08:26:42 <blackh> joevandyk: Try this:  main = interact (unlines . something . lines)  ...  and something is of type [String] -> [String]
08:27:04 <Saizan> dv-: are you using cabal?
08:27:16 <Baughn> Wasn't there a way to access cabalized package version info from inside the package?
08:27:39 <Saizan> dv-: http://www.haskell.org/cabal/FAQ.html#hidden-packages-a
08:27:44 <dv-> Saizan: yes. I'm trying to install lazysmallcheck
08:28:09 <dcoutts> Baughn: yep
08:28:16 <dv-> Saizan: ahh, thanks
08:28:43 <joevandyk> blackh: how does [char] differ from [String]?
08:29:01 <Baughn> dcoutts: Right. I can't seem to find it.
08:29:13 <blackh> joevandyk: 'echo getLine' won't work.  You have to say do ; x <- getLine ; echo x
08:29:19 <dcoutts> Baughn: it's in the Paths_${pkgname} module
08:29:30 <blackh> joevandyk: [String] is a synonym for [[Char]] (list of list of char)
08:29:30 <Rotaerk> joevandyk, [Char] is String
08:29:53 <haskellnoob> ilid: Thanks, but I'm afraid I can't see why using a data type would speed things up.
08:29:54 <haskellnoob> is there an implementation of, say, the Montgomery reduction (http://en.wikipedia.org/wiki/Montgomery_reduction) available with ghc?
08:30:03 <blackh> joevandyk: Things of type 'IO something' are boxes, and you need to use <- to pull the thing out of the box.
08:31:20 <Philippa> haskellnoob: because you could have a type that uses the montgomery encoding and conversions between that and other numeric types
08:31:24 <joevandyk> blackh: hm, ok.  When I use interact, it seems to slurp up the stdin all at once.  what would be the best way to loop over each line in the file?
08:31:58 <blackh> joevandyk: Well, if your function is lazy, it will only read it as it is needed, interactively.
08:32:00 <hackagebot> KiCS 0.8.4 - A compiler from Curry to Haskell (BerndBrassel)
08:32:07 <PeakerWork> fasta: Haskell programs can vary greatly in size.. I think the shortest way to write a Haskell program is typically shorter than a similar Python program. I don't have much experience with real world Scheme to compare, but I'd suspect that its shorter than that too
08:32:32 <blackh> joevandyk: The only thing is, with interact, you can't do file I/O or network I/O - it's only any good for implementing filters from stdin/stdout but you can write a game using interact.
08:32:37 <PeakerWork> fasta: But when you start using explicit recursions and unboxed arrays and various optimizations, Haskell code is no longer very short..
08:32:48 <PeakerWork> @type interact
08:32:49 <lambdabot> (String -> String) -> IO ()
08:32:52 <Jafet> Scheme is a family of related languages, too
08:32:54 <PeakerWork> only a stateless game
08:33:05 <blackh> joevandyk: As long as it doesn't save anything.  You can also do line-by-line I/O using getLine, of course!
08:33:15 <Jafet> There are PLT scheme, MIT scheme, plain r5rs (read: worthless)
08:33:24 <blackh> joevandyk: And then you can do other I/O.
08:34:15 <fasta> Example: parse_foo xml = expect "foo" xml In Haskell I cannot get rid of this redundancy.
08:34:20 <blackh> joevandyk: To loop I/O code, you can use explicit recursion. This isn't the only way of doing things, but it's a good way to start off to get the feel of it.
08:34:50 <haskellnoob> joevandyk: I don't know if this is the best way, but one way I use is the following:
08:34:52 <haskellnoob> main = do input <- getContents
08:34:53 <haskellnoob>                  mapM_ process_one_line $ lines input
08:34:55 <haskellnoob> process_one_line :: String -> IO()
08:34:55 <Philippa> PeakerWork: I was under the impression interact doesn't do the line-by-line splitting for you? Which allows state, just not persistant state
08:35:26 <Baughn> "if (isJust foo) then return foo else bar foo" <-- This has to be a common pattern, so what common combinator am I missing?
08:35:27 <joevandyk> haskellnoob: mapM_process_one_line ?
08:35:28 <fasta> In something like Forth, it would be possible to refer to the name of the function recover the <foo> part and use that in the definition of parse_<foo>.
08:35:28 <PeakerWork> Philippa: well, I mean your (String -> String) function cannot carry state to its next invocation
08:35:45 <PeakerWork> Baughn: "maybe" ?
08:35:53 <haskellnoob> joevandyk: mapM_  process_one_line $ lines input
08:35:54 <PeakerWork> Baughn: fromMaybe?
08:36:24 <Baughn> PeakerWork: ..yeah. Doh.
08:36:29 <blackh> joevandyk: If you think Haskell is restricting you, you're right. It's carefully designed not to give you enough rope to hang yourself with. :)
08:36:53 <joevandyk> for example, this is how i'd do it in ruby: STDIN.readlines.each { |l| puts "Yes, #{ l }" }
08:37:21 <Baughn> joevandyk: As you might find out later, it turns out that, the more structure (i.e. restrictions) there are on something, the more functions can be written to work on all cases of the "something".
08:37:39 <Baughn> joevandyk: You're right that Haskell is somewhat on the B&D side of language design, but we get good payment.
08:37:51 <joevandyk> heh
08:38:07 <fasta> And of course the major source of code blow up in Haskell is do the  foo <- make_foo. That is the binding of variables.
08:38:12 <PeakerWork> joevandyk: restrictions on the programmer is freedom for the language implementor, and vice-versa
08:38:32 <jmcarthur_work> joevandyk, interact $ withLines ("Yes, " ++)
08:38:43 <PeakerWork> joevandyk: restricting the language allows more freedom to do interesting things at the language-level and has also forced Haskell to come up with innovative ways to do things that are sometimes much better than the conventional approahes
08:39:05 <fasta> PeakerWork: what does Haskell do much better?
08:39:09 <dv-> er, is there a Test.QuickCheck.Applicative, or is that a typo in reactive-0.11?
08:39:13 <jmcarthur_work> oh i didn't read high enough
08:39:13 <fasta> Concurrency is a hardware thing.
08:39:17 <jmcarthur_work> you already have used interact
08:39:32 <Baughn> fasta: Immutability makes concurrency much easier to work with, as you well know
08:39:39 <blackh> dv-: QuickCheck 1.2 vs 2.0?
08:39:50 <fasta> Baughn: yes, but you can do that in lots of imperative languages too. You just have to start from scratch.
08:40:07 <blackh> dv-: A lot of older packages don't specify an upper bound on QuickCheck versions, and things break with 2.0
08:40:16 <PeakerWork> fasta: I'd say exceptions are done better, the "polymorphic semicolon" we end up with is better than what you have conventionally
08:40:25 <Baughn> fasta: Haskell is better because you don't have to. ;)
08:40:30 <joevandyk> jmcarthur_work: where does withLines come from?
08:41:04 <fasta> PeakerWork: do you know who the first guy is who said polymorphic semicolon?
08:41:06 <jmcarthur_work> joevandyk, it's a function i often define myself: withLines = (unlines .) . (. lines)
08:41:11 <dv-> blackh: doesn't seem to be that. It says >2 and also, there's no Test.QuickCheck.Applicative as far as I can see anywhere in hackage
08:41:15 <PeakerWork> fasta: no, who?
08:41:21 <jmcarthur_work> @let withLines = (unlines .) . (. lines)
08:41:22 <lambdabot>  Defined.
08:41:38 <fasta> PeakerWork: I don't know, but I would like to know. It might even have been me, but I doubt it.
08:41:45 <jmcarthur_work> > withLines (++ "!") "foo\nbar\nbaz"
08:41:46 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:41:46 <lambdabot>         against inferred ty...
08:41:53 <blackh> dv-: Oh!
08:42:06 <jmcarthur_work> :t withLines
08:42:07 <lambdabot> ([String] -> [String]) -> String -> String
08:42:09 <fasta> PeakerWork: I called it a programmable semi-colon, though.
08:42:19 <ziman> > withLines (map (++ "!")) "foo\nbar\nbaz"
08:42:20 <lambdabot>   "foo!\nbar!\nbaz!\n"
08:42:20 <jmcarthur_work> umm
08:42:26 <jmcarthur_work> oh yeah
08:42:29 <PeakerWork> fasta: Well, I think those are 2 examples, but there are more.. I think the way explicit forked IO threads are done is better than the typical equivalent in other languages (sharing mostly immutable state, rather than mutable state). STM is nicer.  par annotations.  and more
08:42:31 <jmcarthur_work> <-- dummy
08:42:50 <PeakerWork> fasta: Well, its a nice observation if it is you :)
08:42:53 <dv-> blackh: I removed it and it built. How odd
08:43:04 <Baughn> @hoogle IO a -> Maybe a -> IO a
08:43:05 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
08:43:05 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
08:43:05 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
08:43:21 <ziman> @pl withLines f xs = unlines (map f (lines xs))
08:43:22 <lambdabot> withLines = (unlines .) . (. lines) . map
08:43:36 <PeakerWork> fasta: Many of these things would not have arrived if Haskell wasn't restricted and had to find alternate ways to do things.. I think the unrestriction of "lazy I/O" Haskell is doing is delaying a nicer solution (Iteratee style) from arriving
08:43:43 <Baughn> ..oh hoogle, you bastard. None of those actually match.
08:43:48 <fasta> PeakerWork: it was basically a monad tutorial before that concept existed on the web at least ;)
08:43:50 <PeakerWork> Baughn: what are you looking for?
08:43:57 <Baughn> PeakerWork: What I just wrote. ;P
08:44:06 <PeakerWork> Baughn: but what should it do?
08:44:14 <PeakerWork> Baughn: the type allows a few behaviors
08:44:45 <PeakerWork> @type \x -> maybe x return
08:44:45 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> Maybe a -> m a
08:44:45 <Baughn> PeakerWork: Writing a combinator is easy enough, but I keep thinking there should be something general.. um, "foo _ (Just m) = return m; foo act _ = act"
08:44:54 <quicksilver> fasta: http://osteele.com/archives/2007/12/overloading-semicolon
08:45:09 <quicksilver> fasta: may well be the first mention; certainly it's about the age I'd expect.
08:45:17 <quicksilver> but there might be earlier.
08:45:25 <PeakerWork> @pl \x -> maybe x return
08:45:25 <lambdabot> flip maybe return
08:45:28 <fasta> quicksilver: Mine was in 2003, I think.
08:45:41 <PeakerWork> Baughn: (`maybe` return) :-)
08:46:05 <Baughn> Hm. That works.
08:46:29 <Philippa> fasta: monads and monad transformers give you a powerful effect system for free, that's a good example of something haskell does better
08:46:48 <Philippa> incidentally, /exploiting/ hardware concurrency is very much a (semantics of) language issue
08:47:26 <fasta> Why wouldn't a C library with par be able to do the same things?
08:47:39 <Philippa> purity
08:47:43 <opqdonut> what was the funtion to reverse an ordering
08:47:52 <opqdonut> @hoogle Ordering -> Ordering
08:47:52 <lambdabot> Prelude pred :: Enum a => a -> a
08:47:53 <lambdabot> Prelude succ :: Enum a => a -> a
08:47:53 <lambdabot> Prelude id :: a -> a
08:47:54 <fasta> You would have to keep track of which things are pure and which are not, but otherwise it would work in the same way.
08:47:56 <opqdonut> gah
08:48:00 <PeakerWork> A C library would have to establish purity somehow, or burden the programmer with proving it -- which is what many C parallelization libraries do
08:48:09 <Philippa> that's an awful big catch
08:48:15 <Baughn> PeakerWork: Having learned way too much about how GHC is actually implemented (pre-optimization), I find myself wanting to carefully write code that avoids one sixteen-byte memory allocation per message sending.
08:48:24 <PeakerWork> fasta: A C library can have "par" but it cannot, like Haskell, prove a minimal/inexistent effect on semantics
08:48:28 <Baughn> PeakerWork: While copying the entire message three times for encryption and padding.
08:48:35 <Philippa> Baughn: read up on unboxed tuples, you'll find it helps
08:48:46 <PeakerWork> Baughn: heh
08:49:00 <Baughn> Philippa: Oh, I have. I /meant/ it when I said I've learned too much. :P
08:49:30 <Baughn> PeakerWork: I also find myself wanting to rewrite hsopenssl to avoid that copying, but as that's a lot more work, I'm able to resist the call.
08:49:31 <fasta> PeakerWork: I think the main advantage of Haskell is typed polymorphism combined with the lack of segfaults, without the overdosis of type-annotations.
08:50:09 <Jafet> Type classes is a major part of that
08:50:16 <Philippa> fasta: so you'd be just as happy coding in ML. Others wouldn't
08:50:27 <Philippa> (me, I really want a best-of hybrid of the two)
08:50:34 <fasta> Philippa: yes, probably.
08:51:00 <Baughn> @. pl undo do foo <- act p; return (foo, p)
08:51:00 <lambdabot> flip (,) p `fmap` act p
08:51:23 <theclaw> hi
08:54:17 <joevandyk> hooray!  http://gist.github.com/202203
08:54:39 <joevandyk> probably terrible code, but it works
08:55:18 <Baughn> @pl prefix_yes string = "Yes, " ++ string
08:55:18 <lambdabot> prefix_yes = ("Yes, " ++)
08:55:23 <jmcarthur_work> @pl loop_over_line input = unlines (map prefix_yes (lines input))
08:55:23 <lambdabot> loop_over_line = unlines . map prefix_yes . lines
08:55:34 <Baughn> joevandyk: You'll find @pl useful for discovering interesting tricks. Sometimes it blows up, but when it looks reasonable, use it.
08:55:45 <jmcarthur_work> loop_over_line = withLines (map prefix_yes)
08:55:52 <joevandyk> @pl ?
08:55:53 <lambdabot> (line 1, column 1):
08:55:53 <lambdabot> unexpected "?"
08:55:53 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:56:03 <joevandyk> oh
08:56:03 <joevandyk> ha
08:56:04 <Baughn> joevandyk: "pointless"
08:56:16 <Baughn> Where "string" is a "point" in that case
08:56:26 <jmcarthur_work> @pl \f g x -> f (g x)
08:56:27 <lambdabot> (.)
08:56:31 <Baughn> @pl foo (a,b) c d = c (b,d) a
08:56:31 <lambdabot> foo = uncurry (flip (flip . (flip .) . flip (.) . (,)))
08:57:00 <joevandyk> hm, how can i access @pl outside of irc?
08:57:08 <jmcarthur_work> joevandyk, the pointfree package
08:57:19 <jmcarthur_work> gives you a command line tool called pointfree
08:57:21 <Baughn> Or the ghci-lambdabot fusion thingy
08:57:34 <Baughn> joevandyk: However, you can still access \bot via private messages
08:58:02 <Baughn> @hoogle String -> [String] -- Here's another useful tool
08:58:03 <lambdabot> Parse error:
08:58:03 <lambdabot>   --count=20 "String -> [String] -- Here's another useful tool"
08:58:03 <lambdabot>                                 ^
08:58:14 <Baughn> ..that doesn't understand comments
08:58:31 <joevandyk> is  prefix_yes = ("Yes, " ++) better than specifying the arguments?
08:59:00 <Baughn> Some think so. It's modifying a function, rather than values. Still, YMMV; try it, and just use whatever fits.
08:59:20 <joevandyk> modifying a function?
08:59:27 <Baughn> Right. ++, in this case.
08:59:28 <blackh> joevandyk: I was just appreciating your code. Which one is better depends on what's clearer and more readable.  They're both good in their own way.
08:59:44 <Baughn> joevandyk: Oh, and your loop_over_line function returns a /list/, not an array. Important difference; Data.Array has arrays.
09:00:07 <joevandyk> thanks, i'll look into it
09:02:52 <Baughn> joevandyk: (Arrays are pretty much read-only, as you have to copy the whole thing to modify one. Use STArray/IOArray for imperative stuff, preferably the former.)
09:02:55 <joevandyk> Baughn: about 'modifying a function', I'm still unclear by what you mean by that.
09:03:15 <Baughn> joevandyk: You take one function (namely ++), and do something to it to get another function.
09:03:23 <joevandyk> Baughn: If you don't specify the arguments that a function takes, is it assumed that it always takes one?
09:03:33 <joevandyk> ah...
09:03:38 <Baughn> joevandyk: All functions take one, period; see currying
09:03:48 <joevandyk> that's right, i read that
09:03:52 <joevandyk> craziness
09:03:54 <Baughn> ..which is a bit of a lie-to-children
09:04:28 <PeakerWork> joevandyk: what is a lie-to-children?
09:04:32 <Baughn> A function like "foo x y = ..." /pretends/ to take just one, but it only starts doing any actual work once it has two. Partial application is not supported
09:04:51 <Baughn> At least, not non-explicitly..
09:05:16 <bd_> well, it _could_ do work after one. depending on how the compiler transforms it
09:05:34 <Baughn> I don't see how we'd fit that into lazy evaluation, but it'd be neat. :P
09:05:49 <bd_> foo x y = (x * x) + bar y  could be transformed into foo x = \x -> let z = (x * x) in \y -> z + bar y
09:06:00 <PeakerWork> Baughn: you're talking about ghc though, not Haskell
09:06:16 <bd_> provided that (*) on x's type can be proven to never result in _|_, and x is never _|_ either
09:06:28 <Baughn> PeakerWork: Since it's common for all haskell implementations I'm aware of, it's more than that
09:06:37 <quicksilver> Baughn: no, it's not
09:06:50 <Saizan> Baughn: most of the time you care about sharing, not about it evaluating the thing sooner, like in bd_'s example
09:06:51 <quicksilver> Baughn: as bd says, a compiler could easily transform it like that.
09:06:56 <bd_> the hard part is those proofs, as otherwise (foo undefined) `seq` () would do the wrong thing
09:07:17 <Baughn> ..it's useful to have some idea of how haskell is actually executed, to write reasonably fast code.
09:07:37 <Baughn> You're perfectly right that none of this is /guaranteed/, but it should still be on the curriculum - just like lazy evaluation
09:08:13 * Baughn wonders if we've scared away joevandyk now. Um..
09:08:16 * Baughn proffers a cookie
09:08:18 <joevandyk> Great, so I've got http://gist.github.com/202213.  how can i get the prefix_yes into the main line.
09:08:19 <joevandyk> haha
09:08:37 <bd_> which is yet more evidence that seq is evil :)
09:08:40 <quicksilver> well I have a strong suspicion that GHC can make transformations like this
09:08:50 <bd_> I suppose it should be mentioned that most compilers aren't smart enough to do the required strictness proofs :)
09:08:52 <quicksilver> but I don't know what kind of test case to write to tickle it the right way.
09:08:53 <Baughn> joevandyk: Since prefix_yes is now pointless, you can simply substitute prefix_yes for its definition
09:08:59 <bd_> or well, termination proofs
09:09:09 <quicksilver> bd_: well, GHC does strictness analysis
09:09:09 <Baughn> joevandyk: (If it wasn't, you'd have to use a lambda expression)
09:09:21 <joevandyk> Baughn: lost
09:09:32 <joevandyk> perhaps i can't get the syntax right
09:09:38 <bd_> quicksilver: yeah, but if you look at my example above, it needs to know that arguments involved in the memoized portion won't be _|_
09:09:46 <bd_> so I suspect this might only be possible if the function's inlined partially
09:09:46 <Baughn> joevandyk: Wherever you call a function or use a value, in haskell, you can substitute the name of that value/function with its definition
09:10:01 <Baughn> joevandyk: E.g. "interact (unlines . map ("Yes, " ++) . lines)
09:10:19 <joevandyk> ah, was forgetting the parens
09:10:22 <quicksilver> bd_: no it doesn't; z is memoized but still evaluated lazily
09:10:27 <joevandyk> i'm still unclear on when they are necessary
09:10:29 <quicksilver> bd_: so even if x is _|_ that's fine.
09:10:33 <Baughn> joevandyk: (All this, and more, will be yours for only a modest loss of sharing. It doesn't affect semantics; it does affect performance.)
09:10:35 <bd_> quicksilver: ah, well, I meant if z was kept strict then :)
09:10:43 <bd_> so throw a z `seq` in there somewhere
09:10:49 <bd_> but I see what you mean - that could be memoized
09:10:54 <bd_> rather than strictly computed
09:10:55 <quicksilver> bd_: sure, but even if you don't keep it strict
09:11:01 <quicksilver> you'd still be able to observe the sharing change
09:11:07 <quicksilver> (for some loose sense of 'observe')
09:11:18 <quicksilver> like - observe by using debug.trace or vacuum
09:11:21 <bd_> quicksilver: indeed, debug.trace in the implementation of (*) ought to be able to do it
09:11:38 <Baughn> joevandyk: Parantheses are necessary whenever you need to override precedence. In this case.. function application (i.e. the "space operator") binds more tightly than anything else.
09:11:56 <quicksilver> bd_: and GHC certainly *does* do sharing-increasing let movements
09:12:07 <Baughn> joevandyk: So if you forget the parantheses, there, haskell will pass "Yes, " as the first parameter to map. Then it'll hit the ++, and get really confused.
09:12:08 <quicksilver> bd_: but I odn't know if that exact example would work, or if not, what would...
09:13:01 <Saizan> i think there's a faq about this
09:13:05 <joevandyk> Baughn: prefix_yes = "Yes, " ++
09:13:13 <joevandyk> Baughn: why are the parens required there?
09:13:34 <joevandyk> Baughn: and they aren't if I specify the argument to the prefix_yes function
09:13:48 <Baughn> joevandyk: A limitation of the parser, in that case. Expressions can continue over multiple lines.
09:13:55 <bd_> joevandyk: ++ is an operator, in order to do an operator slice, you need to put in parenthesis
09:14:14 <joevandyk> operator slice?
09:14:14 <Beelsebob> joed: you could ofc use it like a function
09:14:20 <bd_> joevandyk: if there was a hypothetical append function, you could do, prefix_yes = append "Yes, " without parenthesis; or you can do prefix_yes = (++) "Yes, "
09:14:22 <Beelsebob> and do prefix_yes = (++) "Yes, "
09:14:36 <Baughn> joevandyk: It needs to know where to /stop/ slicing. In theory there are a few cases where the parantheses might be avoided, but it'd be a lot of work for no good reason.
09:14:38 <bd_> joevandyk: that's what it's called when you give an operator only one of its arguments. (1 +) or (* 8) or ("Yes, " ++)
09:15:14 <Saizan> bd_, quicksilver: http://www.haskell.org/haskellwiki/GHC:FAQ#When_can_I_rely_on_full_laziness.3F
09:17:04 <PeakerWork> joevandyk: (expression   <infix_operator>) or  (<infix_operator>  expression)  are called "sections"
09:17:09 <joevandyk> is main = interact (unlines . map ("Yes, " ++) . lines) good yet?
09:17:13 <Baughn> joevandyk: That is, (+ 1) is not ambiguous, and "+ 1" is not ambiguous as the sole element of a function; however, the latter case is very rare (you just happened to hit it), and it'd be ambiguous /anywhere else/ if it were allowed.
09:17:34 <joevandyk> Baughn: makes sense, thanks.
09:17:41 <Baughn> joevandyk: Yep, I don't think you'll get that any terser. :P
09:18:01 <PeakerWork> unless you have inLines
09:18:15 <Baughn> Writing that might be a good exercise
09:18:30 <PeakerWork> main = interact . inLines $ prefix_yes
09:18:31 <Baughn> mapLines a better name, maybe?
09:18:46 <PeakerWork> I meant: main = interact . inLines $ map prefix_yes
09:18:53 <PeakerWork> inLines f = unlines . f . lines
09:19:44 <joevandyk> so for testing.. what are the good tools?
09:19:54 <Baughn> ghci's the main one
09:20:05 <joevandyk> i'm used to ruby's autotest tool, where it runs tests everytime you save the source file
09:20:37 <Baughn> You could get that with emacs and haskell-mode, if you want
09:20:43 <joevandyk> Baughn: vim :(
09:20:49 <Baughn> Oh, and use ghc/ghci with -Wall
09:21:30 <gwern> joevandyk: in theory you could have a convention where every module you are hacking on defines a 'tests' and then you re-define ghci's :r binding to reload and then evaluate test
09:21:34 <PeakerWork> joevandyk: to write tests, you use QuickCheck
09:21:45 <gwern> joevandyk: or yeah, you could do much the same but with 'cabal test'
09:21:54 * gwern doesn't even know, do we actually have 'cabal test' yet?
09:22:28 <Baughn> We do, but I'm not sure it does anything
09:23:15 <dcoutts> it's approximately useless
09:24:51 <Baughn> Approximately?
09:26:04 <Saizan> it calls the test hook in the Setup.hs script
09:26:21 <Baughn> Which has no convenient default definition. Pity.
09:26:45 <Baughn> It'd be nice to have it run main in a Test.hs or something, at least, if not more convenient quickcheck integration
09:27:41 <gwern> maybe we could just tell everyone to run quickcheck tests in template haskell :)
09:27:46 <PeakerWork> automatically run prop_*.hs or all prop_ symbols in files or such
09:28:13 <Baughn> gwern: Don't joke about such things
09:28:22 <Baughn> It struck me as a good idea for almost five seconds
09:28:25 * gwern wonders if it's such a bad idea
09:28:32 <Baughn> See?
09:28:36 <gwern> if it's a bad idea, it's probably the fault of the TH implementation
09:28:44 <Baughn> ..main problem would be that you can't /turn it off/
09:28:52 <gwern> why *can't* we define probabilistic compile-time checks? just like weaker types
09:29:11 <opqdonut> hehe
09:29:12 <Baughn> Oh, you can. TH can run IO stuff just fine.
09:29:36 <Baughn> And if it couldn't, there's always unsafePerformIO
09:30:14 <gwern> Baughn: no, I mean TH has all these weird restrictions
09:30:31 <Jafet> gwern, that sounds worthless
09:30:32 <gwern> like you can't use TH in the same module as a definition the TH expression needs, or something really awful like that
09:30:49 <Jafet> Good for stealing LCDs, maybe
09:30:54 <joevandyk> huh
09:30:58 <joevandyk> 5/3 == 5/3 doesn't work
09:31:12 <Baughn> gwern: That's "you can't use a binding defined via TH in the same module as it's defined"
09:31:14 <opqdonut> , 5/3 == 5/3
09:31:16 <lunabot>  True
09:31:23 <gwern> > (5/3 :: CReal) == (5/3 :: CReal)
09:31:24 <lambdabot>   True
09:31:32 <gwern> > 5/3 == 5/3
09:31:33 <lambdabot>   True
09:31:38 <joevandyk> really?
09:31:38 <joevandyk> hm
09:31:41 <Baughn> Well, not in other TH code. Hm, I suppose that could get in the way of quickcheck.
09:31:43 <gwern> maybe lambdabot's defaults are different from ghci
09:31:47 <opqdonut> joevandyk: what types?
09:31:48 <Baughn> They are
09:31:54 <joevandyk> oh, nm.  was getting a warning
09:31:55 <gwern> no, it works with doubles just fine in ghci
09:32:18 <Baughn> @check \a b -> a == b
09:32:19 <lambdabot>   "OK, passed 500 tests."
09:32:36 <PeakerWork> That's a horrible default, btw
09:32:46 <Beelsebob> it is
09:32:46 <gwern> defaults to (), iirc, doesn't it?
09:32:48 <Beelsebob> probably the only sane one though
09:32:50 <Baughn> Yep. Which leads to..
09:32:53 <Baughn> @check (==)
09:32:54 <lambdabot>   "OK, passed 500 tests."
09:32:56 <PeakerWork> Beelsebob: why not Int/Integer?
09:33:01 <Baughn> See, (==) works. :)
09:33:04 <opqdonut> :)
09:33:20 <joevandyk> do you guys always write out the types declarations for all functions?
09:33:27 <Beelsebob> PeakerWork: why int/integer
09:33:29 <opqdonut> top-level funcs yes
09:33:29 <quicksilver> defaulting to () is just annoying imo
09:33:32 <Baughn> joevandyk: GHC shouts at me if I don't
09:33:33 <gwern> joevandyk: during cleanup, usually, yeah
09:33:34 <quicksilver> > const
09:33:35 <lambdabot>   {()->{()->()}}
09:33:46 <opqdonut> oh, show instances?
09:33:46 <opqdonut> cool
09:33:55 <bd_> > const :: Bool -> Bool -> Bool
09:33:56 <Beelsebob> joed: yes, it's good documentation, and it helps track down bugs when you do get a type error
09:33:56 <lambdabot>   {True->{True->True;False->True};False->{True->False;False->False}}
09:33:57 <PeakerWork> Beelsebob: so there can be non-equal elements
09:33:59 <ziman> joevandyk, i usually start with types, it helps me to think about the function bodies i'm about to write
09:34:00 <quicksilver> > (+1)
09:34:02 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
09:34:06 <Baughn> joevandyk: Also, I'm not good enough yet to figure out type errors that are three functions removed from the one with the actual bug. Typing out signatures helps constrain errors.
09:34:33 <byorgey> it would be nice if it put some spaces in there...
09:35:18 <gwern> joevandyk: another advantage of type sigs, especially with lists, is that surprisingly often when you are mutating and tweaking and refactoring internals, you'll wind up with a module which is, type-inference wise, internally consistent - but not at all what you meant
09:35:27 <Baughn> joevandyk: Once you feel ready for a real challenge, you should read the typeclassopedia. Meanwhile, might want to bookmark it.
09:35:47 <joevandyk> thanks.
09:35:57 <joevandyk> is this not a valid type?  add :: forall a. (Num a) => a -> a -> a
09:36:17 <Baughn> You shouldn't type out the forall, but otherwise it looks fine
09:36:32 <gwern> yeah, why *does* ghci print the forall?
09:36:33 <joevandyk> Baughn: i get a parse error on =>
09:36:39 <Baughn> (Also, it's in the wrong position, I think)
09:36:48 <Baughn> gwern: Lazy authors?
09:36:53 <Jafet> :t (+)
09:36:54 <lambdabot> forall a. (Num a) => a -> a -> a
09:37:03 <Baughn> joevandyk: Just remove the "forall a." bit
09:37:08 <gwern> Baughn: bah. I'd file a bug but I'm too lazy
09:37:11 <gwern> or... am I?
09:37:17 * Baughn observes gwern 
09:37:21 <byorgey> joevandyk: that is a perfectly valid type, but the 'forall a' syntax is an extension
09:37:35 <byorgey> joevandyk: normally you just write  (Num a) => a -> a -> a  and the 'forall a' is implicit.
09:37:40 <joevandyk> Baughn: right.  so that's saying 'when a is a Num, this function accepts two variables of type a and returns a variable of type a'?
09:37:47 <Baughn> joevandyk: Specifically, the "forall a." bit is an extension that only matters when the forall /isn't/ in the prefix position
09:38:13 <byorgey> Baughn: and also for ScopedTypeVariables =P
09:38:37 <Baughn> joevandyk: Kind of, though of course you'd get a type error if a /isn't/ in Num. "when" implies it might do something else otherwise.
09:38:58 <Baughn> joevandyk: Also, they're not variables; I like to use "bindings" or "parameters", depending. Or values.
09:39:44 <gwern> does anyone have a quick definition to plug into ghci for the 'forall' thing?
09:39:50 <byorgey> 'this function accepts two values of type a and returns a value of type a, where a must be an instance of Num'
09:40:40 <Baughn> joevandyk: Type-classes are very useful, especially when you consider that types like "Binary a => ByteString -> a" are legal; return-value polymorphism. That's from the Data.Binary library, by the way, for binary serialization.
09:41:03 <Baughn> joevandyk: (If you find yourself wanting to store data to disk or pass it over a network, efficiently, look it up)
09:41:33 <sergio> @pl
09:41:34 <lambdabot> (line 1, column 1):
09:41:34 <lambdabot> unexpected end of input
09:41:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:41:49 <Baughn> joevandyk: Oh, and the typeclassopedia is all about how type-classes work, with an overview of the most useful bundled ones
09:42:19 <joevandyk> What is going on here?  http://gist.github.com/202236
09:42:46 <Baughn> What did you expect line nine to do?
09:42:58 <joevandyk> Right, haskell doesn't have variables.  I'm still getting used to the FP mindset.
09:43:05 <joevandyk> Baughn: erm, run tests?
09:43:09 <joevandyk> works in ghci
09:43:25 <Baughn> joevandyk: That's ghci. In .hs files, you have to use a main function to run anything.
09:43:33 <Makoryu> joevandyk: Remember... Variables don't. Constants aren't.
09:43:34 <joevandyk> doh
09:43:36 <byorgey> joevandyk: you can't stick arbitrary expressions in a file like that; you could type 'quickCheck check' at the ghci prompt but not put it in a file.
09:44:31 <byorgey> joevandyk: I think it would work to just put   main = quickCheck check
09:44:38 <Baughn> joevandyk: ghci pretends to be a big do-block. Start with "main = do", and put your code on the line below.
09:45:00 <Baughn> (But note that "do foo" = "foo")
09:45:21 <Makoryu> @undo do foo
09:45:21 <lambdabot> foo
09:45:22 <byorgey> well, except that you can type pure expressions at the ghci prompt as well as things in IO.
09:45:27 <Makoryu> @undo do foo; bar
09:45:28 <lambdabot> foo >> bar
09:45:47 <joevandyk> Right.  http://gist.github.com/202236  I'm not sure how to interpret that error
09:46:03 <ilid> @undo "hello" <- return foo; return foo
09:46:04 <lambdabot>  Parse error at "<-" (column 9)
09:46:07 <ilid> @undo do "hello" <- return foo; return foo
09:46:08 <lambdabot> return foo >>= \ a -> case a of { "hello" -> return foo; _ -> fail ""}
09:46:16 <Baughn> joevandyk: With the information you've given ghc there, it has no way of knowing /which/ Num type you mean
09:46:24 <Baughn> joevandyk: ghci defaults it, ghc doesn't
09:46:35 <joevandyk> which Num type?
09:46:36 <byorgey> joevandyk: quickCheck doesn't (yet) know how to check polymorphic functions.
09:47:00 <byorgey> you have to tell it which type you want it to use for its tests.  Int? Double? ...?
09:47:05 <Baughn> joevandyk: Num is a type-class. Num a => a means "any type a, which is an instance of Num".
09:47:23 <byorgey> it should work to replace Main.check with   (Main.check :: Int -> Int -> Bool)  , for example.
09:47:32 <Baughn> joevandyk: GHC can't produce an actual runnable program without narrowing that down to a /single/ type a, though it can be a different one at each use of check
09:48:10 <joevandyk> thanks all, i think i got it:  main = Test.QuickCheck.quickCheck (Main.check :: Int -> Int -> Bool)
09:48:24 <Baughn> joevandyk: By the way, you don't need to qualify either quickCheck or check, there; they're unambiguous as is. Well, unless there's a "check" binding in Test.QuickCheck, I guess.
09:48:27 <byorgey> joevandyk: yup, that ought to do it.
09:48:35 <joevandyk> Baughn: there was, i think
09:48:37 <byorgey> Baughn: there is.
09:48:48 <Baughn> Okay. You still don't need to qualify Test.QuickCheck
09:49:04 <Baughn> ...quickcheck
09:51:06 <ezyang> I'd like to define an Ix instance for an Array
09:51:40 <ezyang> This particular array happens to be small (6 entries), so I could just transform it into a 6-tuple, or a 6-level nested set of 2-tuples, but I was wondering if there was a cleverer way
09:52:27 <ezyang> (also, it's not obvious to me if I can specify a = (b, a) without getting the infinite type error)
09:54:27 <joevandyk> ok, i've got the next function that will power my web 3.0 startup: http://gist.github.com/202239  Now, say I want to modify the add function so that if I don't give it two arguments, it returns the first argument.  I can use pattern matching for that, right?  The thing I'm wondering is, how does that affect the type specifier?
09:55:19 <Baughn> joevandyk: That's something you actually can't do, without Evil Hacks.
09:55:46 <Baughn> In practice, there are almost always better alternatives. The sum function, say.
09:55:55 <Baughn> > sum [2,3,4]
09:55:56 <lambdabot>   9
09:56:38 <birkenfeld> in ghci, after "let Just a = Nothing", why is "a" of type GHC.Prim.Any? I kind of understand that an getting error immediately is contrary to laziness, but what is special about that type?
09:59:41 <Baughn> birkenfeld: It's what GHCi defaults to if you don't somehow specify some type. \bot likes () instead.
09:59:47 <Baughn> Either way, it's just a type.
10:00:03 <Berengal> An empty type, I might add
10:00:43 <birkenfeld> empty means, only bottom is a possible value?
10:00:50 <Baughn> birkenfeld: Anyway. Laziness is why you're not getting a pattern-match failure, but type defaulting is why it's not giving you a type error
10:00:52 <Berengal> Yep
10:00:53 <Baughn> Yes
10:01:15 <Baughn> The type level is /not/ a lazy language, it's a logic-programming language
10:02:01 <birkenfeld> can that defaulting be overridden?
10:02:50 <Makoryu> @pl \f xs -> mapM f xs >>= liftM concat
10:02:51 <lambdabot> flip flip (fmap join) . ((>>=) .) . mapM
10:03:08 <Baughn> birkenfeld: Sure, just add a type signature
10:04:10 <birkenfeld> Baughn: let Just (a :: Bool) = Nothing  "works" -- nice :)
10:04:51 <Makoryu> :t ((>>= liftM concat) .) . mapM
10:04:53 <lambdabot> forall a a1. (a1 -> [[[a]]]) -> [a1] -> [[a]]
10:05:05 <Makoryu> :t \f xs -> mapM f xs >>= liftM concat
10:05:07 <lambdabot> forall a a1. (a -> [[[a1]]]) -> [a] -> [[a1]]
10:05:23 <Baughn> I'm being confused by a maze of haskell-modes, all alike. Where is the newest one?
10:05:41 <Baughn> ..oh.
10:07:46 <Makoryu> :t \f xs -> liftM concat $ mapM f xs
10:07:48 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
10:07:54 <Makoryu> Hmmm, okay
10:07:57 <Makoryu> @pl \f xs -> liftM concat $ mapM f xs
10:07:58 <lambdabot> (fmap join .) . mapM
10:11:52 <tuukkah> how's this supposed to work: cabal warns that ghc -main-is is not portable. is there some other way to have main in a module which is not called Main?
10:14:11 <byorgey> tuukkah: no; according to the language standard, there must be a module called Main which must export the value main.
10:14:26 <byorgey> but using -main-is is probably fine in practice.
10:15:00 <byorgey> although I'm sure some would disagree with me.
10:15:06 <Philippa> -main-is can be treated as a shortcut for adding a trivial new module
10:15:38 <ilid> what's wrong with adding a module called Main? are you building multiple binaries from the same source tree?
10:15:50 <Philippa> some of us do that
10:15:54 <Perceptron> hey guys, quick question I have a type Matrix = [[Double]] and am trying to write a matrix multipication function multMM :: Matrix -> Matrix -> Matrix
10:15:57 <tuukkah> byorgey, Philippa, thanks
10:16:02 <tuukkah> ilid, i am
10:16:36 <int-e> @type transpose
10:16:37 <lambdabot> forall a. [[a]] -> [[a]]
10:17:03 <Philippa> you can have multiple Main modules under different filenames?
10:17:07 * DrSyzygy would like a nice, easy to implement, fun instance of Functor for a homework assignment.
10:17:21 <DrSyzygy> (homework I'm _assigning_, not _solving_)
10:17:54 <tuukkah> cabal let's me specify the names of the files (with main-is). but i import those files in other modules for some of the functions that they contain, so i can't use the module name Main multiple times
10:18:06 <jmcarthur_work> DrSyzygy, how easy is too easy?
10:18:35 <DrSyzygy> jmcarthur_work: I'll have shown them the trivial functor, lists, trees with values in nodes, trees with values in leaves and Maybe.
10:18:52 <DrSyzygy> And given the course so far, I wouldn't call anything too easy.
10:18:54 <int-e> DrSyzygy: data Tree a = Level a | Nest (Tree (a, a))
10:19:09 <Philippa> tuukkah: sure you can, just create stub files that import the other ones and export main
10:19:12 * DrSyzygy is getting disillusioned with his students after a mere week or two.
10:19:14 <jmcarthur_work> DrSyzygy, how about (->) a ?
10:19:17 <mmorrow> int-e: hah, i was just typing "maybe something with polymorphic recursion"
10:19:21 <int-e> (too hard?)
10:19:22 <DrSyzygy> jmcarthur_work: Nice one!
10:19:50 <tuukkah> Philippa, yeah, but that's boring, duplicating the number of modules just to work around a stupid detail in the language standard
10:19:50 <DrSyzygy> int-e: Functor instance just acts on everything? I don't think it's too hard, unless that type has subtleties I don't see.
10:20:23 <jmcarthur_work> DrSyzygy, do you suspect their problem is motivational or due to preconceptions or something else?
10:20:28 <DrSyzygy> int-e: Oh, wait.... So that's a fully populated binary tree, is it?
10:20:34 <int-e> DrSyzygy: right
10:21:02 <DrSyzygy> jmcarthur_work: I think their problem is due to "Prove that P" seems to be a kind of question NONE of the CS undergrads are used to seeing, much less answering.
10:21:05 <int-e> DrSyzygy: a perfectly balanced one.
10:21:06 <jmcarthur_work> i hate to see students becoming disenfranchised to nice languages
10:21:23 <Philippa> tuukkah: yeah, boring happens. OTOH, one has to ask why you have big 'main' modules
10:21:24 <jmcarthur_work> aha
10:21:33 <DrSyzygy> jmcarthur_work: These already like Haskell. Enough that they come take a class in category theory to complement the haskell course they already took.
10:21:42 <jmcarthur_work> oh!
10:21:50 <Philippa> normally, Main itself should be pretty small, with not a lot that's used by anything other than main itself
10:22:02 <jmcarthur_work> they like haskell and haven't yet internalized functors?
10:22:03 <DrSyzygy> And my looking for fun functor instances is to give them homework that isn't on the shape "Prove X".
10:22:24 <DrSyzygy> They probably have. I'm telling them about functors from a CT perspective rather than a Haskell perspective.
10:22:37 <jmcarthur_work> of course, to verify a functor instance you still have to show that the laws are satisfied
10:22:41 <jmcarthur_work> oh i see
10:22:45 <DrSyzygy> The difference between "homomorphism of categories" and "container which lets you apply functions"
10:22:45 <Philippa> DrSyzygy: a cute use I have for functors is to provide 'style sheets' in a prettyprinting lib. Something mildly surprising like that could be fun?
10:23:00 <DrSyzygy> Philippa: Oooooooooh. Link?
10:23:02 <svein> I need to parse something like *(5,5), can i that like this: parseExpr ('*':'(':X:',':Y:s)) and then use x and y in the result?
10:23:06 <svein> I need to parse something like *(5,5), can i that like this: parseExpr ('*':'(':X:',':Y:s)) and then use x and y in the result?
10:23:08 <Alpounet> Either a b is a bifunctor in a and b and Either a is a functor (in b), right ?
10:23:27 <tuukkah> Philippa, i didn't say the modules as big =) i suppose i'm used to the python style, with a simple "test" main at the end of each module that can be easily run for final testing (this is a gui project))
10:23:31 <jmcarthur_work> Alpounet, sounds right to me
10:23:33 <data_jepp> I need to parse something like *(5,5), can i that like this: parseExpr ('*':'(':X:',':Y:s)) and then use x and y in the result?
10:23:43 <DrSyzygy> Alpounet: I haven't talked bifunctors yet, but I think I use Either a as a functor in b, as a generalization fo Maybe b.
10:23:47 <int-e> data_jepp: once is enough.
10:24:03 <data_jepp> int-e: huh?
10:24:04 <Philippa> DrSyzygy: don't have it online yet, but it's basically Wadler's lib from A Prettier Printer, extended with a "tag" function that wraps docs with a tag. Parameterise on the tag type, supply fmap and have the prettyprinter throw out a presupplied bunch of text around it to get eg XHTML out
10:24:12 <tuukkah> Philippa, i suppose i leave it as it is for now, and remember to think this over again at some point
10:24:15 <int-e> data_jepp: you just asked that question three times in a row.
10:24:19 <Alpounet> DrSyzygy, yeah, I'm rather asking for the usage of the "bifunctor" expression for 'Either a b'
10:24:24 <data_jepp> Oh, fuck. Sorry
10:24:26 <Alpounet> jmcarthur_work, ok, thanks :)
10:24:32 <Philippa> so initially you tag for semantic markup, then you map it to how you want it rendered
10:24:47 <Baughn> Has anyone made haskell-indentation.el work with view patterns yet?
10:24:49 <jmcarthur_work> Alpounet, i have defined an instance of Bifunctor for Either in alt-stdlib
10:25:04 <DrSyzygy> Philippa: Nice!
10:25:07 <Alpounet> jmcarthur_work, ok, then it's the right name, thanks
10:25:30 <int-e> data_jepp: and no, you can't, unless the 5 is limited to a single character. ('*':'(':x:',':y:')':s) is a valid pattern then.
10:26:09 <int-e> data_jepp: but I suspect you want to allow several characters, too. e.g. *(23,42)
10:26:17 <ilid> DrSyzygy: if you want to give your students a headache, there's always data Foo a b = Foo ((b -> a) -> b)
10:26:26 <jmcarthur_work> O_o
10:26:30 <DrSyzygy> ilid: I have a few students who need headaches. :-)
10:26:46 <Philippa> DrSyzygy: you can try just supplying the "output document" type for now, which is missing most of the neat stuff but is still an okay way to do "marked up text". Or data ML a = Tag a (ML a) | Str String | Seq (ML a) (ML a) or similar
10:26:46 <data_jepp> int-e: it is limited to single chars :)
10:26:50 <DrSyzygy> ilid: Functorial in both arguments? (should be)
10:26:55 <Philippa> er, you'll want a Nil in there too
10:27:00 <int-e> data_jepp: ah. then you're in luck and such a pattern will work.
10:27:10 <jmcarthur_work> @djinn (b -> c) -> ((b -> a) -> b) -> ((c -> a) -> c)
10:27:11 <lambdabot> f a b c = a (b (\ d -> c (a d)))
10:27:17 <data_jepp> int-e: *writing some code*
10:27:17 <ilid> DrSyzygy: it's cofunctorial in the first
10:27:18 <Alpounet> jmcarthur_work, in Control.Monad ?
10:27:23 <DrSyzygy> ilid: Right.
10:27:24 <jmcarthur_work> Alpounet, Data.Either
10:27:30 <Philippa> DrSyzygy: if they're compscis, then the quick rip on XML-like structures will appeal too :-)
10:27:36 <Alpounet> jmcarthur_work, ok :)
10:28:00 <data_jepp> int-e: the x y would also work? extracting values like that from the string?
10:28:11 <jmcarthur_work> Alpounet, and current the Bifunctor type class is inappropriately placed in Control.Arrow, i think
10:28:14 <Alpounet> jmcarthur_work, have you added it recently ?
10:28:22 <jmcarthur_work> Alpounet, within the last few days
10:28:40 <int-e> data_jepp: yes. (they need to be variables, i.e. lower case. they'll bind values of type Char - after all String = [Char], a list of characters)
10:28:49 <Alpounet> jmcarthur_work, okay, I'll update my local version then.
10:28:50 <data_jepp> int-e: weee :D
10:29:14 <jmcarthur_work> Alpounet, it's in Control.Arrow because it replaces some of the other classes i had in there before
10:29:22 <jmcarthur_work> Alpounet, generalizes first, second, etc.
10:29:50 <Makoryu> Oh god
10:30:17 <Makoryu> Now someone posted "Hs:TCP" on Hacker News?
10:32:08 <data_jepp> int-e: *(expr, expr) would be this datatype i made Mult Expr Expr. How can i convert it into that?
10:32:40 <Alpounet> jmcarthur_work, okay, thanks.
10:42:21 <data_jepp> Why cant 'A' be a string? Function takes a string and won't let one char as value?
10:43:15 <mux> in Haskell, a String is just a list of char
10:43:24 <mux> @src String
10:43:24 <lambdabot> type String = [Char]
10:43:35 <mgee> data_jepp: "A"
10:43:36 <mux> the String type is a mere alias
10:44:15 <Athas> It's the Best!
10:44:38 <Athas> Only 16 bytes of overhead per character on 64bit too!
10:44:40 <data_jepp> Oh, but im extracting the value from a string with patern matching?
10:45:06 <mux> data_jepp: if c is a Char, [c] is a String
10:45:31 <data_jepp> parseExpr :: String -> (Expr, String)
10:45:36 <data_jepp> parseExpr ('*':'(':x:',':y:')':s) = (Mult(parseExpr x, parseExpr y),s)
10:45:39 <data_jepp> Is not allowed?
10:45:46 <ilid> Athas: so is that 20 bytes per character including the 4 byte UCS-4 representation of Char?
10:46:03 <mux> data_jepp: x and y are Char's here
10:46:04 <Athas> ilid: I suppose so, yes.
10:46:04 <ilid> or is the Char boxing in addition to that 16 bytes?
10:46:13 <DrSyzygy> Philippa: I have a feeling I'm not pushing the boundaries as far as possible with the current formulation: http://haskell.org/haskellwiki/User:Michiexile/MATH198/Lecture_3  << last question. Thoughts on how to make it cooler?
10:46:30 <mux> data_jepp: this pattern matching won't do what you think it does
10:46:37 <Athas> ilid: I don't think you need to box Chars.
10:47:11 <data_jepp> mux: I will call rescursivly to check again if the char is an uppercase variable or a number between 1-9. What is wrong :( ?
10:47:25 <Makoryu> data_jepp: That pattern will work if x and y are exactly one character each
10:47:37 <data_jepp> They are
10:47:43 <mux> data_jepp: ah, so in that case you want to pass [x] and [y]
10:47:50 <data_jepp> :d
10:47:51 <data_jepp> :D
10:47:52 <mux> data_jepp: I didn't think you actually wanted x & y to be characters
10:48:16 <mux> otherwise your recursive call can't typecheck since you're calling yourself back with a Char instead of a String
10:48:44 <Athas> Actually, the String overhead suddenly seems a bit excessive.  Is there a space-efficient String-workalike?
10:48:51 <mux> Athas: ByteString
10:51:15 <ilid> Athas: i /think/ all lifted (_|_-containing) types must be boxed, but i could be horribly wrong :)
10:52:53 <Athas> ilid: oh right... but you may be able to use pointer tagging to avoid memory overhead for some primitives.
10:55:47 <ilid> Athas: in principle certainly (there's certainly a few spare bits in a 4-byte Char), but whether GHC actually does that is a separate issue :)
10:57:28 <ilid> DrSyzygy: minor erratum: in your final example your deriving clause should list show with an uppercase S
10:57:39 <ilid> s/example/homework question/
11:01:27 <dcoutts> tuukkah: your main-is does not need to be Main.hs, it can be any file, so you can have multiple Main modules.
11:11:57 <DrSyzygy> ilid: Thanks.
11:13:21 <joevandyk> what method can i use to see if a string contains a certain character?
11:13:37 <aavogt> joevandyk: any (=='x')
11:13:40 <pasc1> elem?
11:13:44 <opqdonut> elem
11:13:46 <opqdonut> :t elem
11:13:47 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:13:53 <aavogt> heh, I'm indirect
11:14:22 * aavogt just translated the request into haskell from english
11:15:10 <Makoryu> @src elem
11:15:11 <lambdabot> elem x    =  any (== x)
11:15:31 <tuukkah> dcoutts, yeah, the part where i and haskell98 disagree is putting library functions and main functions into same modules
11:16:01 <blackh> joevandyk: Incidentally, the 'text' package contains a more comprehensive set of string functions than Data.List, but it works on a different data type called Text.
11:16:59 <joevandyk> thanks
11:17:05 <hackagebot> sample-frame 0.0.1 - Handling of samples in an (audio) signal (HenningThielemann)
11:17:21 <joevandyk> pattern matching is new to me, and it seems like a really handy tool.  are there any downsides to it?
11:17:41 <idnar> joevandyk: you might forget how to do it the hard way in languages that don't have it ;)
11:17:49 <joevandyk> idnar: ha
11:18:10 <Saizan> well, it doesn't apply to abstract datatypes unless you use views
11:18:46 <Saizan> like in Data.Sequence
11:19:05 <hackagebot> sample-frame-np 0.0.1 - Orphan instances for types from sample-frame and numericprelude (HenningThielemann)
11:19:17 <blackh> joevandyk: It's definitely very handy. I can highly recommend turning the -fwarn-incomplete-patterns flag on - then it'll catch potential runtime bugs where you've not handled a certain case.  I always use that.
11:19:32 <joevandyk> blackh: does -Wall have that?
11:20:06 <blackh> joevandyk: Yes
11:20:39 <tuukkah> can some tool help me convert from -fglasgow-exts to the actually needed language pragmas?
11:20:42 <blackh> joevandyk: Actually ignore me because I don't know.
11:23:10 <Jedai> tuukkah: #haskell is handy for that, also you could try just removing -fglasgow-exts and see what GHC says to you
11:24:41 <ilid> joevandyk: the big downside to pattern matching is that, in order to allow it, you need to expose the constructors of your type, which runs counter to encapsulation
11:25:13 <dolio> Yeah, ghc will usually tell you what extensions you need to cause error not to happen.
11:25:48 <dolio> Assuming it can figure that out. Rank-2 types it has trouble with, I think, for instance.
11:26:52 <monochrom> If you write "forall" it knows. If you have no type sig, it's hard to tell between a mistake or a need for higher-rank types.
11:26:54 <tuukkah> Jedai, ok, let's see :-)
11:27:48 <dolio> Does it? I thought in the past it would just complain that it couldn't make sense of "(forall a) . (b)" and such.
11:28:31 <monochrom> Oh
11:28:35 <monochrom> Let me try.
11:29:16 <dolio> Since without rank-2 types, those are potentially valid type variables.
11:29:28 <monochrom> You're right.
11:29:47 <dolio> (You also need to not have ScopedTypeVariables on, I suppose. Possibly not ExistentialQuantification.)
11:32:34 <Baughn> With some help from #emacs, I've got haskell-indentation.el working with view patterns. I'm not very familiar with either elisp or the code, so.. anyone care to test it? Or, well, check my code for me?
11:33:56 <Baughn> The actual code is at http://brage.info/~svein/hask-indent-viewpatterns.diff - yeah, it turned out to be pretty simple.
11:34:35 <dolio> Is that a patch to the regular haskell-mode, or the kuribas indentation?
11:35:06 <Baughn> The haskell-indentation.el in the CVS repo. I'm not aware of a Kurbias.
11:35:16 <dolio> Okay.
11:36:11 <Baughn> dolio: Where would I find kuribas' version?
11:36:33 <dolio> http://kuribas.hcoop.net/haskell-indentation.el
11:37:02 <tuukkah> ok, this is the first non-trivial one: after removing -fglasgow-exts, i get "The last statement in a 'do' construct must be an expression"
11:37:24 <Baughn> tuukkah: Yes, it must. What is the last statement at the moment?
11:37:36 <dolio> Well, that's a bit odd. I wouldn't expect an extension to affect that.
11:37:47 <Baughn> dolio: Can I assume that "kuribas" == the author of haskell-indentation.el?
11:38:11 <dolio> Yeah, that's the handle he uses here, although I don't think he shows up much.
11:38:19 <tuukkah> i don't know which expression exactly, as the line number in the error message is wrong
11:38:28 <joevandyk> i have this devowelize function: http://github.com/joevandyk/haskell/blob/master/beginnings/no-vowels.hs  right now, it acts on on Char.  I'd like to cleanly change it so that it acts on whole strings.  What's the best way to do that (while keeping the general logic the same)
11:38:48 <joevandyk> oops, bug in that
11:38:50 <joevandyk> hold on :)
11:38:56 <Baughn> dolio: Oh, and the patch applied cleanly to said newer version. Say, why isn't it in the cvs repo?
11:39:06 <joevandyk> fixed
11:39:39 <dolio> Baughn: Why isn't the kuribas indentation in the cvs repo?
11:39:51 <Baughn> dolio: Yes. Maybe I should say, what does it improve?
11:40:04 <dolio> I don't know how related it is.
11:40:18 <dolio> For one, tab indents and backspace outdents, there's no cycling.
11:40:30 <Baughn> That's the same one, then
11:40:36 <tuukkah> Baughn, dolio, seems it was RecursiveDo
11:40:37 <Makoryu> joevandyk: map devowelize
11:40:38 <dolio> And it tends to pick the right indentation from the start for me.
11:40:52 <joevandyk> Makoryu: ?
11:40:58 <Baughn> The CVS version is also kuribas', I think - same author - but older
11:41:07 <dolio> Huh.
11:41:15 <Baughn> ..I'll just send this over to him.
11:41:29 <dolio> Well, maybe they just picked up his version. I didn't realize.
11:42:07 <Baughn> dolio: Well, the haskell-mode cvs currently has three separate indentation implementations. :P
11:42:19 <monochrom> RecursiveDo is fabled to allow "x <- m" as the last line, but I haven't been able to reproduce it.
11:42:21 <Baughn> Things get "fun" if you accidentally mix them
11:42:24 <Makoryu> joevandyk: Ah, never mind, you have that :p
11:42:30 <dolio> Oh okay.
11:43:40 <dolio> Baughn: You can tell I follow haskell-mode development closely. :)
11:43:46 <Berengal> monochrom, recursive do still needs to return a value...
11:44:46 <monochrom> The fable says that x is the return value too.
11:45:06 <Berengal> it's a fable. You need to return x afterwards to put it back in the monad
11:45:18 <Makoryu> joevandyk: If you want to explicitly pattern match on entire strings, you have to worry about the structure of the list as well as whether a character is a vowel
11:45:26 <Berengal> Unless I've forgotten the mdo rewriting rules...
11:45:37 <monochrom> The mdo papers have mdo { x <- m x } as valid.
11:46:20 <Baughn> dolio: /Any/how.. did you check the view-pattern bit?
11:46:45 <dolio> I'll check it.
11:46:51 <Berengal> I guess the solution is to try mdo {x <- m x} and see if it works then
11:46:58 <monochrom> In mdo { x<-... ; y<-...; z<-...; ... } all of x,y,z are implicitly put back in the monad.
11:46:59 <joevandyk> what function can i use to see if any element in list1 exists in list2?
11:47:15 <mauke> :t any
11:47:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:47:26 <mauke> any (`elem` list2) list1
11:47:37 <Makoryu> joevandyk: Do you want to test, or filter?
11:47:48 <Makoryu> :t (any, filter)
11:47:49 <lambdabot> forall a a1. ((a -> Bool) -> [a] -> Bool, (a1 -> Bool) -> [a1] -> [a1])
11:48:15 <Baughn> joevandyk: Data.List has a number of (very inefficient) set functions on lists. However, they assume there are no duplicates.. also, they're inefficient; Data.Set is faster, except for very small lists.
11:48:19 <joevandyk> mauke: what's the purpose of the `?
11:48:21 <tuukkah> perhaps the actual issue was that the parser hit the mdo word and didn't recognise it as a key word? in case you want to have a look, the module is here: http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs/Fenfire/Vobs.fhs
11:48:40 <mauke> joevandyk: to turn a normal identifier into an infix operator
11:48:53 <burp> <joevandyk> what function can i use to see if any element in list1 exists in list2? <- is this somewhere in a common tutorial? :D
11:49:03 <dolio> Baughn: Appears to work here.
11:49:04 <burp> I remember someone asking the same yesterday
11:49:21 <Makoryu> joevandyk: x `f` y == f x y
11:49:25 <Baughn> dolio: Well, that's good. :)
11:49:45 <Baughn> dolio: Believe it or not, haskell-mode's lack of view-pattern support has been my main reason to avoid them
11:50:42 <dolio> It's sort of annoyingly sensitive to new additions like that.
11:51:24 <Baughn> It basically implements a haskell parser, and unfortunately it doesn't have very good fallbacks in case of trouble
11:52:10 <Baughn> Replacing the error calls with something that at least does a raw character insert would help a lot, and be a pretty trivial fix
11:52:30 <ski> > mdo {x <- [1]}
11:52:30 <lambdabot>   <no location info>:
11:52:31 <lambdabot>      The last statement in a 'do' construct must be an ...
11:52:42 <monochrom> In "recursive monadic bindings", there is an example of mdo { p1<-e1 ; ... ; pN<-eN } and its desugaring. It is explicitly said "This condition can be relaxed in the µdo notation" and "In this variation we define the final result to be the value of the last generator."
11:53:22 <joevandyk> http://gist.github.com/202334.  Running that I get: No instance for (Arbitrary Char) arising from a use of `quickCheck' at no-vowels.hs:8:2-19
11:53:42 <mistermatt> Would you guys recommend 'real world haskell' to someone with no functional programming experience?
11:54:19 <joevandyk> mistermatt: i would
11:54:23 <tuukkah> in another module, "Not in scope: `mdo'" is much clearer :-)
11:54:30 <joevandyk> mistermatt: it does a decent job of explaining the concepts
11:54:30 <burp> mistermatt: worked for me too
11:54:42 <mistermatt> right now I'm reading learn you a haskell online
11:55:28 <monochrom> I recommend 3 books/tutorials to everyone. The one that makes you click is always the 3rd or the 5th.
11:55:58 <Baughn> In my case, it was implementing FRP. :P
11:56:04 <mistermatt> I got to the part about list comprehensions, and I decided that I'd like to buy a book too :)
11:56:13 <Baughn> ..trying to. Well, but there's something to be said for practical experience.
11:57:44 <monochrom> The quest for "the best book so I need only read one" is misguided and completely ignores your own psychology. Your psychology is such that you need it re-said in 3 or 5 different ways before you listen.
11:58:07 <monochrom> Yes, before you even listen.
11:58:34 <nostrand> or you can take one and really bang it into your head =)
11:58:57 <Baughn> joevandyk: You mentioned using vim.. not to start any flame-wars, but you should /try/ emacs; haskell-mode for emacs does a better job at indentation than anything else I've tried. (Trust me, it ain't trivial)
11:59:26 <Philonous> Is there a class of datatypes that can be "zipped", i.e. class zippable z where zipWith :: (a->b->c) -> z a -> z b -> z c ?
12:01:01 <patch-tag> hw can I use UTCTime, deriving Typeable and Data? (want to use UTCTime in happstack).
12:01:04 <dolio> There is a vim indenter out there that does an all right job.
12:01:30 <ski> @type \f ia ib -> pure f <*> ia <*> ib
12:01:31 <Baughn> Philonous: I would have thought Foldable, since it has toList, but I can't find a zip function. Still, you can use toList.
12:01:31 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
12:01:41 <ski> Philonous : ^
12:02:05 <dolio> Although it's mostly 'keep the same line' except that it recognizes that the line below 'do a <- m' should start under a.
12:02:07 <ski> (may or may not be what you want, depending on what you mean by `zip')
12:02:25 <dolio> 'Keep the same column' even, I suppose.
12:03:02 <Baughn> <*> is not usually anything I'd call zipping. :P
12:03:17 <idnar> what about ZipList? :)
12:03:18 <patch-tag> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4278#a4278
12:03:24 <dolio> Well, for a lot of things that can be zipped, you can define a zipping applicative functor.
12:03:34 <dolio> Although you need to be tricky in some cases.
12:03:56 <patch-tag> I guess I should have said I'd like to use newtype deriving rather than define instance myself if that's possible.
12:04:13 <Baughn> Right, but the basic structure I'd assume for a zipper is that it's.. an ordered list. LIke Foldable.
12:04:54 <ski> (a "zipper" is not the same as a data structure that can be zipped)
12:05:03 <Baughn> ..oops
12:05:04 <dolio> For instance, with Map, you need to wrap it in something so that you can express "every key maps to f" for pure.
12:05:51 <Baughn> A Map version with built-in defaulting would be very useful at times
12:06:44 <Berengal> patch-tag, unfortunately, UTCTime has a component of a hidden datatype which isn't an instance of Typeable or Data, and since it's not exported it's impossible to create the instance as well
12:06:51 <Berengal> If it were exported, it'd be pretty easy
12:07:20 <Berengal> I've spent many a moment cursing this fault myself... Always export your types people! No exceptions!
12:07:37 <data_jepp> http://stackoverflow.com/questions/1521710/haskell-recursive-problem-tiny-parser-a-few-things ? Anyone care to take a look (a)
12:08:00 <patch-tag> Berengal: what about modifying the package and cabal installing, with it exported?
12:08:13 <patch-tag> what's the hidden datatype? E12?
12:08:19 <Philonous> Baughn: Fodable is no good. I want to retain the structure and don't mold it into a list.
12:08:30 <Philonous> But I guess the applicative thing might work.
12:08:37 <Berengal> patch-tag, that's possible, but could break other things. The correct solution is to patch the existing package, but that takes time
12:08:50 <Berengal> patch-tag, Day, or something. Can't remember off the top of my head
12:09:17 <ski> Philonous : if you can't implement both operations (satisfying laws), though, it is probably better to make a new class
12:09:36 <patch-tag> Berengal: a package is hidden if when you do :info in ghci, it comes out as fully qualified, right?
12:09:55 <patch-tag> pity also that newtype deriving doesn't give you a nicer error message like "deriving choked at type blah"
12:10:13 <Berengal> patch-tag, it comes fully qualified if it's not imported, so you'll have to try to import it to see if it's really hidden
12:10:26 <Baughn> Philonous: I'm not sure, but I'm thinking you should make a new class
12:11:39 <Berengal> data_jepp, you want an alpha-version tutorial on how to write your own parser library?
12:13:29 <eu-prleu-peupeu> hiii
12:16:10 <plcs> Twigathy: Eek Andee CIV
12:16:15 <plcs> woops.
12:18:15 <data_jepp> Berengal: something like that :p
12:19:04 <Berengal> data_jepp, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10461#a10461
12:19:22 <patch-tag> I just darcs got time package and attempted to install. cabal install didn't work because missing configure fle. there's a .ac file there, so I tried first autoconf, then cabal install. configure file got created, but failed with config.status: error: cannot find input file: include/HsTimeConfig.h.in. now what?
12:19:45 <patch-tag> my goal is to patch time package so can do data generics deriving.
12:19:52 <Berengal> patch-tag, use System.Time instead?
12:20:01 * Berengal shrugs and sighs
12:20:10 <patch-tag> could try that...
12:20:54 <Berengal> It already has a Serializeable instance defined in one of the happstack modules, so there's probably a Typeable and Data instance somewhere as well
12:20:54 <data_jepp> Berengal: I'll read it!
12:22:52 <sunrayser> is it possible to catch exceptions within a do construct?
12:23:20 <patch-tag> :t Prelude.catch...
12:23:21 <lambdabot> parse error (possibly incorrect indentation)
12:23:36 <patch-tag> :help
12:23:41 <patch-tag> >help
12:23:42 <sunrayser> more precisely, catch the error result hint's interpret function so that it doesn't jump out of the runInterpreter stuff
12:23:43 <Berengal> Catching exceptions is just applying a function, which is an expression, which is allowed pretty much everywhere
12:24:42 <patch-tag> sanrayser: right, imagine parenthisis around the do black, and a type sig at the end, eg ... :: IO ResultType
12:25:02 <patch-tag> you can actually add the annotation if that helps.
12:25:42 <patch-tag> Prelude> :t catch
12:25:43 <patch-tag> catch :: IO a -> (IOError -> IO a) -> IO a
12:26:01 <sunrayser> patch-tag: umm it's a recursive do construct, so I have to catch the exception within it
12:26:14 <Makoryu> @idx isInfixOf
12:26:15 <lambdabot>  isInfixOf
12:26:19 <Makoryu> @hoogle isInfixOf
12:26:20 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
12:26:20 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
12:26:20 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
12:26:59 <sunrayser> I mean compileall = case whatever -> compile (this throws something) otherwise compileall rest
12:27:37 <hackagebot> property-list 0.0.0.5 - XML property list parser (JamesCook)
12:27:41 <sunrayser> umm not case but do
12:28:50 <sunrayser> compileAllFunctions [] = return() \n compileAllFunctions (x:xs) = do compileFunction x; compileAllFunctions outputFileName options xs
12:29:08 <newsham> "vectors, matrices, etc re-emerge as memo-tries"  wow.
12:29:09 <sunrayser> and compileFunction jumps out if an error occurs, I want to prevent that
12:29:32 * Berengal read that as emo-tries
12:31:02 <shepheb> Berengal: can only store morose poetry?
12:31:09 <shepheb> well, "poetry"
12:32:34 <Berengal> shepheb, infinite prefix-trees which structure is spiraling downwards, towards the dark abyss
12:32:36 <sunrayser> ehh how to make `IO a' from an `t IO ()'?
12:32:53 <Berengal> sunrayser, depends on the t
12:33:04 <data_jepp> Berengal: How do I check if a char is a number between 0-9. Would if work?
12:33:23 <shepheb> Berengal: haha
12:33:25 <sunrayser> Berengal: it doesn't tell me what t is
12:33:31 <Berengal> data_jepp, how far have you gotten?
12:33:45 <burp> > ord 'x'
12:33:46 <lambdabot>   120
12:33:46 <Berengal> sunrayser, then you can't...
12:34:09 <Berengal> data_jepp, I parse numbers at the end of the tutorial
12:34:32 <sunrayser> Berengal: somehow my catch (compilefunction x) (\_->error "error") construct doesn't work
12:34:42 <data_jepp> Berengal: reading the link you gave me, and waiting for a reply from the professor if I can use parsec.
12:34:53 <sunrayser> Berengal: and it's within a do...
12:35:23 <Berengal> sunrayser, what, the error doesn't typecheck? Because it should...
12:35:37 <Berengal> Which catch are you using by the way? Prelude or Control.Exception?
12:36:05 <sunrayser> Berengal: prelude I think
12:36:54 <sunrayser> Berengal: my compilefunction is (MonadTrans t, MonadInterpreter (t IO)) =>     [Char] -> [Char] -> [Char] -> t IO ()
12:36:57 <Berengal> data_jepp, even if you can't use parsec you could write your own parser. It's easy peasy (once you know how :P). Besides, parsec has a few quirks making it a bit harder to use than a simple one
12:37:23 <sunrayser> Berengal: and I want to catch everything it throws
12:37:56 <Berengal> sunrayser, oh, but here t is any type that's both MonadTrans and MonadInterpreter.
12:38:00 <Berengal> @type runIdentityT
12:38:01 <lambdabot> Not in scope: `runIdentityT'
12:38:04 <Berengal> :/
12:38:45 <Berengal> You just need to find a suitable type that's both of those classes, and find it's run function
12:38:55 <Berengal> @index MonadInterpreter
12:38:55 <lambdabot> bzzt
12:39:01 <Berengal> @hoogle MonadInterpreter
12:39:02 <lambdabot> No results found
12:39:05 <Berengal> :/
12:39:06 <ziman> data_jepp, c `elem` ['0'..'9'], for example
12:39:10 <Berengal> Where's that one defined?
12:39:34 <sunrayser> Berengal: umm that should be in the hing package
12:39:37 <data_jepp> ziman: oh :)
12:39:39 <sunrayser> *hint
12:39:47 <Berengal> sunrayser, which module?
12:39:55 <sunrayser> Berengal: Language.Haskell.Interpreter
12:40:01 <sunrayser> maybe...
12:41:08 <Berengal> Looks like it, but it doesn't import any instances...
12:45:45 <data_jepp> Can't I use list generator inside a where expression?
12:45:56 <data_jepp> where elem a [0..9] = True  Wont work
12:46:13 <Botje> where is for defining variables
12:46:13 <data_jepp> Unexpected ..
12:46:16 <Berengal> where isn't an expression, it introduces a list of definitions
12:46:22 <Botje> it's not meant to add additional constraints
12:46:31 <data_jepp> Ok
12:47:38 <monochrom> If you can't write "elem a [0..9] = True" at the top level, you can't write it inside where either.
12:51:27 <data_jepp> Hmm, i write out the list. But the return is suppose to be a number. a in this case is a char. How can I convert it to a number?
12:52:53 <Berengal> digitToInt
12:52:56 <Berengal> In Data.Char
12:53:03 <data_jepp> nice
12:53:04 <Berengal> (or read)
12:54:18 <dolio> haskell-cafe is pretty rowdy today.
12:54:47 <monochrom> What is happening there? (Unsubscribed long time ago)
12:55:13 <monochrom> Or is it just everyone replies to everyone because it's Monday, backlog, etc?
12:55:14 <dolio> Lots of yelling about whether (n, n) is a number, given that n is a number.
12:55:28 <dolio> And whether complex numbers are pairs of numbers.
12:55:30 <dolio> And so on.
12:55:47 <monochrom> Hahahaha that is a fueling kind.
12:56:06 <dolio> Plus a little bit of John A. De Goes talking about how Haskell is terrible because it doesn't have operator overloading.
12:56:12 <monochrom> Will someone eventually bring up "is Haskell discovered or invented?"
12:56:40 <idnar> discovered!11
12:56:42 <monochrom> Maybe I should re-subscribe just to do that. Then unsubscribe and sit back.
12:57:08 <idnar> dolio: why doesn't he get ejected from the list?
12:57:10 <tromp> people have that argument about Go...
12:57:20 <idnar> surely everyone is tired of the trolling by now?
12:57:31 <monochrom> All of these "is a real number a Cauchy sequence of rational numbers" is stupid. You would think computer scientists has figured it out.
12:57:38 <dolio> Well, to be fair, it was only one message, and no one replied to it.
12:58:08 <dolio> The bulk of the thread was someone arguing with augustss about the pair of numbers thing.
12:58:10 <monochrom> "Is a stack a cons list or an array?"
12:58:37 <tromp> is the smallest natural 0 or 1?
12:58:55 <monochrom> "Is an abstract data type a concrete implementation in primitive terms?"
12:59:38 <ilid> tromp: depends who you ask
13:00:00 * ilid notices that he should read back further for more context before diving in
13:00:35 <tromp> 0 if you ask me:)
13:00:37 <Zeiris_> Is 0.999 repeating equal to 1?
13:00:49 <dolio> Having 0 gets you more nice properties.
13:01:02 <tromp> 1-0.999... = 0.000 = 0
13:01:06 <ilid> Zeiris_: yes, by definition of recurring decimals :)
13:01:08 <monochrom> augustss fudges Num in every way to the point BASIC makes sense in Haskell. Why would anyone argue with him? I mean, not to say he is right, but you already know you can't convince him he's wrong anymore.
13:01:25 <dolio> :)
13:02:38 <data_jepp> How do I call charToDigit and return at the same time ?
13:02:50 <skorpan> why is everyone hating on john de goes?  i think he has some valid points about haskell.
13:02:55 <idnar> monochrom: does Haskell have the Buddha nature?
13:03:05 <skorpan> :t charToDigit
13:03:06 <lambdabot> Not in scope: `charToDigit'
13:03:10 <monochrom> Buddha has the Haskell nature.
13:03:13 <skorpan> :t Data.Char.charToDigit
13:03:14 <lambdabot> Not in scope: `Data.Char.charToDigit'
13:03:14 <opqdonut> idnar: Mu
13:03:29 <idnar> skorpan: as far as I can tell, he's a destructive troll; as such, any value his points have are pretty much lost in the vitriol
13:03:31 <Baughn> Say, shouldn't ghc 6.12 be out about now?
13:04:45 <tuukkah> how do i use Graphics.UI.Gtk.on? more specfically, how do i construct the Signal argument it takes?
13:07:06 <data_jepp> What "Not in scope"?
13:08:55 <hackagebot> cml 0.1.3 - Events and Channels as in Concurrent ML (BenFranksen)
13:10:27 <Berengal> > digitToInt '5'
13:10:28 <lambdabot>   5
13:11:35 <jmillikin> Is it possible to link to two different versions of a library? I'd like to use HXT and Parsec 3 in the same lib, but Cabal refuses to install due to dependency conflicts.
13:11:51 <jmillikin> I assume because HXT's .cabal file specifies (parsec < 3)
13:13:20 <Berengal> jmillikin, you could try bumping HXT's .cabal file to parsec == 3.*, but that likely won't work. I think there were some major changes...
13:14:11 <Berengal> Or you could link HXT and parsec 2.1, then use that resulting object to link into your program... but that's messy
13:14:30 <jmillikin> Berengal: I actually did that, and it seemed to work (built fine), but obviously I can't expect users to do that before installing my library.
13:14:36 <tuukkah> ok, so this is what i need: Graphics.UI.Gtk.changed :: (Graphics.UI.Gtk.Types.ComboBoxClass self) => System.Glib.Signals.Signal self (IO ())
13:19:41 <m4ik3ru> Howdy.
13:19:42 <loremi> hm, which is 'better' (speed,leaks?) mapAccumL or evalState / State monad?
13:20:07 <m4ik3ru> When I said that my program compiled, I meant that I could open it in GHCi.
13:20:31 <m4ik3ru> When I tried to use GHC, I got errors.  Links to follow...
13:21:02 <blackh> loremi: That depends on the laziness properties of whatever you are using it for.
13:21:12 <monochrom> GHCi automatically links in lots of libraries that GHC doesn't. But "ghc --make" does.
13:21:49 <loremi> blackh: how about speed? would mapAccumL be faster?
13:22:00 <ilid> mapAccumL is just mapM for the State monad, and should probably behave roughly the same as that
13:22:02 <monochrom> If you don't use Cabal or your own makefile, you should use --make.
13:22:09 <blackh> loremi: In theory there should be no difference, but it depends on the subtleties of optimization.
13:22:22 <m4ik3ru> Code (a lot is left out, let me know if I need to repaste in entirety): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10463#a10463
13:22:35 <tuukkah> cabal sdist doesn't seem to understand preprocessors defined in UserHooks :-/
13:22:56 <monochrom> What kind of errors do you get?
13:23:02 <ilid> m4ik3ru: can you also hpaste the errors?
13:23:09 <m4ik3ru> Error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10464#a10464
13:23:28 <ilid> m4ik3ru: add --make to your ghc command line
13:23:47 <user317> i want to impement a class that depends on monad, i guess a superclass, and i want to implement the instance of that class via state, but i cant figure it out, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10462#a10462
13:23:47 <user317> i want to impement a class that depends on monad, i guess a superclass, and i want to implement the instance of that class via state, but i cant figure it out, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10462#a10462
13:23:48 <ilid> hmm, it's already there :(
13:23:54 <m4ik3ru> yup :)
13:23:56 <user317> sorry for the dup, any ideas?
13:24:14 <__JN> Hello, I have a gtk2hs question, maybe someone can help me? Can I write Pixbufdata (from pixbufGetPixels) into a new Pixbuf?
13:24:46 <ilid> m4ik3ru: looks weird. ghc 6.4.2 is very old by the way, have you considered upgrading (assuming that's possible)?
13:24:46 <Berengal> m4ik3ru, delete any existing objects. Do a clean build
13:25:16 <m4ik3ru> ilid: I'm SSHed into the CS department's server, I'm at work and can't install GHC on this comp
13:25:22 <jmcarthur_work> user317, instance Getter (State Int String) where  should be  instance Getter (State Int) where  i think
13:25:22 <m4ik3ru> Berengal: wut?
13:25:34 <monochrom> delete *.o and *.hi files
13:25:42 <m4ik3ru> monochrom: gotcha :)
13:25:50 <Berengal> m4ik3ru, at least that's happened to me. If I've forgotten --make, I sometimes have to delete the already built object files before compiling will work
13:25:54 <monochrom> (Actually deleting *.hs files also eliminates all errors cleanly!)
13:25:59 <user317> jmcarthur_work: briliant! thank you very much
13:26:10 <Berengal> monochrom, wasn't there a ghc version that did just that?
13:26:14 <monochrom> (Oops forgot those *.lhs )
13:26:24 <ilid> user317: also it'd be more normal to have 'class Monad a => Getter a where getter :: a String'
13:26:38 <m4ik3ru> monochrom: hat hat :)
13:26:44 <m4ik3ru> or har har, rather
13:27:30 <user317> ilid: thats what i thought, but i was trying to simplify the problem, at least in my head that looked  simpler :).  thanks for the help
13:27:31 <monochrom> I am indeed a believer of the slogan "all human society problems are caused by humans".
13:27:37 <m4ik3ru> wow.  that worked.  thanks monochrom :)
13:27:53 <monochrom> Berengal suggested it. I just detailed.
13:28:07 <lpsmith> ok,   If I write f x = x + c    where   c = some_exp_not_depending_on_x,     c only gets evaluated once (assuming it has a monomorphic type)  in ghc.
13:28:08 <m4ik3ru> and thanks Berengal :)
13:28:50 <lpsmith> How do I prevent this?
13:28:50 <Berengal> lpsmith, does it really?
13:28:50 <Cale> lpsmith: define c as a function if you want it evaluated each time
13:29:06 <Cale> lpsmith: You can even make it a function of ()
13:29:17 <Berengal> Perhaps make a let...
13:29:23 <Cale> let is the same as where
13:29:43 <lpsmith> IIRC,  older versions of GHC didn't do this
13:29:51 <lpsmith> I don't know how old you have to get though
13:29:55 <inaeternum> ---is ($) equivalent to (\f x -> f x) (exept for it's priority)?
13:30:05 <Berengal> Cale, f x = let y = z in x + y isn't the same as f = let y = z in \x -> x + y
13:30:10 <Berengal> Unless that changed...
13:30:20 <monochrom> Make c polymorphic! (You even said it...)
13:30:26 <Cale> oh, for sure, yes
13:30:49 <lpsmith> monochrom:  heh,  problem is I don't want to make it polymorphic, for performance reasons
13:31:03 <monochrom> I realize I'm trolling. <duck>
13:31:09 <lpsmith> :)
13:31:33 <lpsmith> AndyP, IIRC,  there are reasons I don't want to make it a function of ()
13:31:37 <Cale> lpsmith: The reason that the polymorphism makes it evaluated multiple times is that it really becomes a function of the typeclass dictionary
13:31:41 <lpsmith> Right
13:31:51 <Cale> Why don't you want to make it a function of () ?
13:32:18 <Cale> Actually, why do you want it to be evaluated more than once anyway?
13:32:28 <ilid> lpsmith: why do you /mind/ c only being evalutated once, and how can you tell? space leak?
13:32:34 <lpsmith> improve space behavior
13:32:42 <Cale> Oh, hang on.
13:32:56 <Cale> c should only be evaluated once per call to f there.
13:32:59 <monochrom> Hrm, so c takes up a lot of memory?
13:33:02 <lpsmith> yeah
13:33:06 <lpsmith> it's not actually an int
13:33:15 <lpsmith> It's a big datastructure
13:33:20 <Cale> But it ought to be evaluated more than once if f is called more than once.
13:33:21 <lpsmith> if it was just an int, I wouldn't care
13:33:41 <lpsmith> I swear I remember hearing about this change way back
13:33:44 <Cale> (it ought to be garbage collected when it falls out of scope)
13:34:21 <monochrom> I wonder if there is a pragma to flag it "don't keep".
13:34:40 <ilid> Cale: why? let lifting should pull it out of f, no?
13:35:16 <lpsmith> oh,  making a function of () doesn't work either
13:35:21 <Cale> ilid: Perhaps that's what's happening, but it's not really a very safe optimisation to do in that case.
13:35:25 <Berengal> ilid, I thought that was one of the forbidden optimizations, because of space behaviour
13:35:52 <ilid> Cale, Berengal: i was reading about this on the wiki earlier today. it won't lift a let to between two lambdas, but it'll lift a let entirely past a lambda otherwise
13:36:04 * ilid looks for a reference
13:36:09 <monochrom> I wonder if {-# INLINE c #-} helps.
13:36:25 <Berengal> So the solution is f = \x -> let y = z in x + y ?
13:36:27 <lpsmith> is the wiki accurate
13:36:33 <Cale> ilid: That's scary.
13:37:08 <ilid> yeah :(
13:37:15 <Cale> ilid: It becomes extra hard to analyse space behaviour if your compiler will shuffle around the only means of control over the heap that you have.
13:37:32 <Cale> If it's really doing that, perhaps report a bug.
13:38:01 <Berengal> Maybe there's some flag to turn this off?
13:38:16 <ilid> http://www.haskell.org/haskellwiki/GHC:FAQ#When_can_I_rely_on_full_laziness.3F
13:39:10 <Cale> Oh, yes, that's appropriate.
13:39:24 <Cale> All the stuff there agrees with how I'd think about space.
13:39:30 <data_jepp> Bleh, sick of trying. Can anyone make a function that takes in a string that returns the first element as a digit if its between 0-9 :p ? Please
13:39:53 <Botje> and what should it return if the first char ISN'T a digit?
13:40:11 <data_jepp> Nothing, I dont need error checking ^^
13:40:11 <jmillikin> And what for an empty string?
13:40:20 <data_jepp> I'll taken care of that.
13:40:27 <Botje> data_jepp: sorry, i won't write unsafe functions for you :)
13:40:29 <jmillikin> So it's (Char :: -> Maybe Int)?
13:40:29 <ilid> Cale: the last map transformation doesn't agree with how i'd think about space
13:40:30 <Botje> union won't let me
13:40:49 <Cale> ilid: It's not lifting the computation of expensive x out of the function
13:40:50 <ilid> Cale: suppose "expensive x" generates a lazy list which + consumes
13:40:51 <data_jepp> jmillikin: yes, and whats Maybe?
13:41:04 <jmillikin> data_jepp: it's a data type for when you need to possibly return Nothing
13:41:09 <ilid> Cale: in that case GHC has introduced a space leak
13:41:14 <data_jepp> Wee, pretty :D
13:41:35 <Berengal> > let parseDigit input = if null input then Nothing else if head input `elem` ['0'..'9'] then Just (digitToInt (head input), tail input) else Nothing in parseDigit "12345"
13:41:35 <lambdabot>   Just (1,"2345")
13:41:50 <ilid> Cale: f x vs = map (\y -> [x..] !! y) vs
13:41:50 <Cale> :t isDigit
13:41:52 <lambdabot> Char -> Bool
13:42:00 <lpsmith> erhm
13:42:13 <ilid> Cale: is that constant space or O(max(vs))?
13:42:16 <lpsmith> Ok,  I reviewed the code I was trying to fix :-D
13:42:25 <Cale> :t let f [] = Nothing; f (x:xs) | isDigit x = Just (digitToInt x) | otherwise = Nothing in f
13:42:26 <lambdabot> [Char] -> Maybe Int
13:42:29 <ilid> ok obviously it's the latter but is it also O(1)? :)
13:42:30 <lpsmith> The problem is that what's getting memo'ed is already a function of ()
13:42:40 <saml> is there a simple markup library that does variable?    "{1 hello} world. {1}" ==> "hello world. hello"
13:42:45 <jmillikin> data_jepp: here's a more readable version, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10467
13:43:02 <lpsmith> (but I'm pretty sure that CAFs in where clauses get memo'ed as well)
13:43:32 <data_jepp> Thanks
13:43:38 <ilid> lpsmith: i'd guess ghc can see straight through your function of () which (presumably) doesn't use its argument. what does ghc-core make of it?
13:44:01 <Cale> ilid: I suspect O(max vs)
13:44:39 <Cale> ilid: Though I get what you mean :)
13:46:06 <m4ik3ru> it's compiling now, but when i run it with a test file, it works up until a point and prints a non-exhaustive patterns error
13:46:10 <m4ik3ru> here's the pertinent code
13:46:11 <m4ik3ru> lexer.exe: CliteLexer.hs:207:6-61: Non-exhaustive
13:46:14 <m4ik3ru> wrong
13:46:22 <m4ik3ru> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10468#a10468
13:46:23 <m4ik3ru> that's it
13:46:57 <ilid> http://hackage.haskell.org/trac/ghc/ticket/917 looks somewhat related
13:47:52 <m4ik3ru> the error is on line 18 in the pasted code
13:48:05 <lpsmith> ilid:  actually, it looks like exactly the problem :)
13:48:16 <m4ik3ru> hang on...
13:48:47 <m4ik3ru> nvm, didn't work
13:49:08 <lpsmith> ahh,  the dreaded full laziness transform again :-P
13:49:38 <lpsmith> thanks ilid!
13:49:43 <lpsmith> ilid++
13:51:21 <Berengal> And SPJ suggests a flag, -fno-full-laziness
13:51:46 <Cale> Except...
13:51:56 <Cale> Doesn't the wiki explicitly state that there's no full laziness transform?
13:52:21 <Berengal> Then the wiki's wrong
13:52:32 <lpsmith> lol, suprise suprise
13:52:38 <Cale> I can't believe that it would just float every let to the top level.
13:52:43 <Berengal> It's not fully full, since it doesn't always perform it...
13:54:03 <Berengal> f = \x -> let y = z in (\() -> x + y) () ?
13:54:39 <Cale> It says that it floats things up as long as it doesn't have to separate two lambdas in the process.
13:55:15 <m4ik3ru> Any ideas on why I'm getting an non-exhaustive pattern error on line 18: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10468
13:55:17 <Berengal>  (\() -> (\x -> let y = z in x + y)) () ?
13:55:26 <data_jepp> generel question, when using where boolExpression = doSomethinghere. If boolexpression is true is dosomething executed?
13:55:27 <Berengal> Is there no way to write this with dummy-variables?
13:55:36 <Cale> I think there's a typo there though. "Here, the (expensive x) can be floated out of the \x->... lambda" -- that should be "\y->"
13:55:51 <Berengal> data_jepp, you can't have an expression on the left side of an equals
13:56:22 <Cale> data_jepp: You're saying that boolExpression is *equal* to doSomethinghere, so it will be defined as the same thing as that.
13:56:42 <lpsmith> ugh
13:56:48 <lpsmith> that didn't fix it
13:56:48 <Berengal> > let 5 = 6 in "Hello!" -- as seen on reddit
13:56:50 <lambdabot>   "Hello!"
13:57:17 <Cale> data_jepp: and doSomethinghere will only be *evaluated* if boolExpression needs to be evaluated.
13:57:27 <Cale> (executed is something else)
13:57:48 <data_jepp> :S functional programming is such a punch in the balls :(
13:58:23 <Cale> data_jepp: What are you trying to accomplish?
13:58:38 <Berengal> data_jepp, no, that's imperative programming. You've just gotten so used to it you think it's how it's always been
13:58:42 <data_jepp> Finishing one of my compulsory tasks.
13:58:54 <Cale> data_jepp: I mean programming-wise :)
13:59:00 <data_jepp> Berengal: Haha :D
13:59:11 <Cale> data_jepp: Do you know about if-expressions?
13:59:22 <Cale> if boolExpression then foo else bar
13:59:48 <data_jepp> Cale: Yes. Im trying in a function already defined, check if a string starts with a number 0-9 and then return it as an int.
13:59:49 <Cale> If boolExpression evaluates to True, then the value of the if-expression is foo, otherwise it is bar
14:00:39 <Berengal> > (\c -> if c `elem` ['0'..'9'] then Just (digitToInt c) else Nothing) '5'
14:00:40 <lambdabot>   Just 5
14:00:43 <Berengal> > (\c -> if c `elem` ['0'..'9'] then Just (digitToInt c) else Nothing) 'l'
14:00:44 <lambdabot>   Nothing
14:00:49 <Cale> data_jepp: You need to decide a value to produce if the number is not 0-9. You can produce an error, but that would only be appropriate if you're *really* sure that it will never happen.
14:00:52 <data_jepp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10470#a10470
14:01:09 <data_jepp> The task says to assume that input is perfect.
14:01:44 <data_jepp> Cale: (Tall x) is same as Int
14:01:55 <Berengal> data_jepp, parseExpr (x:s) | x `elem`['0'..'9'] = stuff
14:02:03 <Cale> isDigit x
14:02:10 <Cale> :t isDigit
14:02:11 <lambdabot> Char -> Bool
14:02:21 <Berengal> I keep forgetting about these convenience functions...
14:02:44 <Berengal> No matter, I feel inspired to write a parser with -XNoImplicitPrelude
14:02:51 <Berengal> (And no imports)
14:02:59 <Cale> data_jepp: Are you sure you don't need to parse more than one-digit numbers?
14:03:16 <data_jepp> Yes, only one-digit numbers.
14:04:29 <data_jepp> Berengal: the stuff line gives a char and not an int
14:05:35 <data_jepp> I feel so helpless when what would be trivial in java is so complicated. I could done this task 100 different ways is java on the time it takes to do this haskell.
14:06:08 <m4ik3ru> data_jepp: that's just until you figure functional programming out.  then it gets fun :)
14:06:09 <Cale> data_jepp: Only because you're new to Haskell.
14:06:11 <jmillikin> That's what happens when learning a new language.
14:06:19 <yaxu1> I'm trying to reinstall the haskell platform and getting dependency errors with regex stuff: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10471#a10471
14:06:38 <Cale> data_jepp: It's best to pretend that you just don't know how to program yet :)
14:06:58 <yaxu1> any clues?
14:06:58 <data_jepp> I KNOW, because the noobs in my class are doing better than me :p
14:07:36 <Cale> data_jepp: Rather than imagining how it might be done in Java (which is almost completely unhelpful, because it's so different).
14:08:18 <lkjlkjlkj1> kkfd fggf
14:08:29 <lkjlkjlkj1> <<----
14:08:33 <Cale> data_jepp: Actually, the way I'd solve this problem is to use a proper parsing library like parsec. Parsec gives you parsers as first class values that you can stick together with nice high-level functions.
14:08:36 <Berengal> data_jepp, stop trying to figure out "what do I do now?" Rather, try to figure out "what is this?"
14:08:37 <lkjlkjlkj1> kjh
14:08:49 <data_jepp> Im stuck with this task, while we have already started using prolog. University educations are such a pain the ass :p
14:08:56 --- mode: ChanServ set +o monochrom
14:09:04 <Cale> lkjlkjlkj1: lkflkfl xlkxcl?
14:09:14 <data_jepp> Cale: waiting for an answear on that if im allowed to use parsec.
14:09:27 <halcyon10> hi, i have a problem with a space leak and have extracted the problematic code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10469#a10469   How can i get the function binSamples to be strict in the samples-argument or  how do i otherwise get the code to run in constant space?
14:09:36 <Berengal> data_jepp, using parsec almost requires you to know what a monad is...
14:10:25 <Berengal> The good news is, the task you're doing now taught me just that.... two months later :P
14:10:26 <data_jepp> Berengal: And from the link you gave me, monads are a bitch to understand ?
14:10:37 <jmillikin> Not at all, monads are easy.
14:10:47 <Berengal> data_jepp, heh, I wrote that just as I was starting to understand them
14:10:47 <Cale> Berengal: I learned what monads were about by using Parsec :)
14:10:47 <jmillikin> They just tend to be taught very very poorly.
14:11:15 <Berengal> Cale, similarly, I learned what monads were about when writing my own simple monadic parser combinator library
14:11:26 <blackdog> the reason monads seem hard is that people try to use metaphors to grasp them
14:11:32 <Berengal> Parsers are a great way to learn monads
14:11:52 <data_jepp> Awww, I hope im allowed to use parsec.
14:11:56 <jmillikin> data_jepp: You should take a look at the book "Real World Haskell", especially chapter 14: http://book.realworldhaskell.org/read/monads.html
14:11:57 <Berengal> blackdog, and people try to use metaphors, because usually that's how people learn
14:12:23 <blackdog> Berengal: yeah, it's usually a good strategy. but monads aren't anything more than the definition.
14:12:27 <jmillikin> Maybe is probably the best way to grasp monads, because it's quite simple, self-contained, and doesn't deal with any hairy ideas such as state.
14:12:47 <lpsmith> jmillikin:  I dunno;  they seem easy now,  but when I was trying to understand them...  of course I didn't really have a teacher
14:13:00 <data_jepp> jmillikin: bookmarked. ;)
14:13:15 <Berengal> blackdog, indeed, and that's what made it hard for me.. "IO is a monad... so you can sequence things. But lists are monads too? WTF? And what's this about burritos and refridgerators?"
14:13:19 <lpsmith> Berengal:  I agree,  "Monadic Parser Combinators" really was one of the light-bulb papers for me with regard to monads.
14:13:38 <jmillikin> lpsmith: Most of the tutorials I've seen are for "magic" monads like IO or State. Reducing them to the simplest form, Maybe, was the breakthrough for me.
14:13:53 <jmillikin> Well, State isn't really magic, but it *is* complicated.
14:14:02 <Berengal> State isn't very magical...
14:14:27 <Berengal> Lists are, and functions, and I say that not because they're complicated, but because they're simple and awesome
14:15:04 <yaxu1> the only thing I can think is that there might be something left around from a previous installation of haskell that's stopping the haskell-platform from installing, but I can't see what that might be
14:15:55 <Berengal> Hmmm... perhaps typeclassopedia might be a good resource?
14:17:53 <lispy> Never tried irc from pidgin before...This is interesting.
14:21:55 <data_jepp> Im on inch away, and ya'll probably not to far from hating my questions. But Here it goes. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10472#a10472
14:22:30 <mauke> what is x?
14:22:33 <jmillikin> data_jepp: did you look at my hpaste post from earlier?
14:22:34 <data_jepp> x is a char
14:22:46 <mauke> isNumber looks redundant
14:22:57 <data_jepp> Yes, but I couldnt combine it with an already defined function
14:23:10 --- mode: monochrom set -o monochrom
14:23:15 <mauke> parseExpr (x : xs) | isDigit x = (Tall (digitToInt x), xs)
14:23:21 <jmillikin> Ah, some homework restriction?
14:23:26 <danly> sm: Going waaaay back, I ended up just settling for a tonne of swap space on a removable disc. GHC on the OLPC XO works ok then. Hugs works much better, interestingly. I haven't tried nhc98
14:23:46 <data_jepp> jmillikin: Some 5 pages of restrictions. :p
14:23:54 <data_jepp> mauke: :D Ill test it
14:24:13 <jmillikin> Oh dear. Well, it won't be elegant, but you can just write: digitToInt '0' = 0; digitToInt '1' = 1; etc
14:24:31 <mauke> import Data.Char
14:24:42 <jmillikin> mauke: He's not allowed to use pre-defined functions
14:24:45 <sm> danly: good to know. Worth filing/commenting on a bug in the ghc bug tracker probably, you might be the first to use it on the XO
14:25:21 <aavogt> you can save some letters by writing it:   digitToInt x = case x of '0' -> 0; '1' -> 1; ...
14:25:41 <danly> sm: good point, I'll do that
14:26:01 <mauke> jmillikin: what, not even prelude?
14:26:37 <data_jepp> Thanks for the help guys... i'd be lost without it. I'll be at it again tomorrow. Later ;)
14:27:29 <mauke> isDigit c = c >= '0' && c <= '9'; digitToInt c = fromEnum c - fromEnum '0'
14:28:24 <Berengal> digitToInt = flip lookup (zip ['0'..'9'] [0..9])
14:28:52 <jmillikin> mauke: That's what I'm assuming, based on his statements.
14:29:46 <aavogt> @type lookup
14:29:46 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:30:06 <aavogt> that's even safer
14:30:19 <aavogt> than the built in digitToInt
14:30:48 * Berengal has a strong dislike for partial functions. Long live Maybe, king of monads!
14:31:34 <monochrom> I wonder what you think of partial orders.
14:32:17 <sbahra> mauke, hey, could preflex join ##logic too?
14:32:34 <sbahra> mauke, it would be nice if we were able to make use of his features there.
14:32:56 <ilid> > digitToInt "one"
14:32:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:32:57 <lambdabot>         against inferred type...
14:32:59 <monochrom> Do ##logic people need help evaluating 1+1? :)
14:34:48 <Saizan_> no, but they may need 4 pages of irc logs for 2 + 2 though
14:35:23 <monochrom> haha
14:35:30 <ilid> you should see ##philosophy. they need 5 pages of irc logs just to evaluate 1
14:35:38 <monochrom> hahaha
14:41:43 <Phyx-> rofl..
14:48:28 <mun> hi
14:48:35 <mun> which library do i need to import to use 'fromJust'?
14:48:44 <Berengal> base
14:48:51 <Saizan_> the Data.Maybe module
14:49:08 <mun> thanks
14:49:26 <Saizan_> ?hoogle fromJust
14:49:26 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
14:57:13 <DrSyzygy> Philippa: The exercise I built from your prettyprinting idea immediately makes building a monad out of it obvious and desirable!
14:57:16 <DrSyzygy> :-D
14:57:46 <yaxu1> is there a process to clear out an old haskell install before installing a new one?
14:57:58 <yaxu1> assuming I didn't go the .deb route...
14:58:55 <Phyx-> hm, i feel like reading some papers
14:58:58 <Zao> Judicious use of rm -rf.
14:59:01 * Phyx- finds a good Oleg paper
15:00:10 <tingi> how can i generate number from 1 to 2^n -1, so that they are ordered in lexicographic fashion of the bits set say , n=3, it should be 1,2,4,3,5,6,7
15:00:11 <Saizan_> /usr/local/lib/ghc ~/.ghc ~/.cabal/{lib,share} and ghc bits in /usr/local/bin/
15:00:25 <yaxu1> I did this: cd /usr/local/lib;ls */ghc*|grep :|perl -pe 's/(.*?)\/.*/$1/'|uniq|xargs sudo rm -rf
15:00:54 <ivanm> is the deps of syb-0.1.0.1 wrong? shouldn't it be base >= 4? http://hackage.haskell.org/package/syb
15:01:13 <yaxu1> ah, missed ~/.ghc
15:02:43 <Saizan_> ivanm: what happens if you compile it against base-3?
15:03:01 <ivanm> missing Data.Data
15:03:10 <ivanm> http://dpaste.com/103020/
15:03:10 <yaxu1> I'd rather not go to sleep without a working haskell installation
15:03:16 <yaxu1> How would I dream?
15:04:19 <Botje> yaxu1: imperatively! perish the thought.
15:04:31 <Saizan_> ivanm: it seems it should then
15:04:51 <Botje> tingi: why does 4 come before 3?
15:05:03 * Saizan_ wonders why his cabal manages to pick base 4 
15:05:05 <cygnus> Does anyone know whether Corey O'Connor (vty author) hangs out here?
15:05:06 <sereven> @quote yaxu
15:05:06 <lambdabot> yaxu says: I'd rather not go to sleep without a working haskell installation. How would I dream?
15:05:06 <tingi> Botje, the number of bits set in 4 is 1, whereas in 3 is 2
15:05:15 <ilid> tingi: i think that's more like a colexicographical order
15:05:26 <Zao> Do you truncate leading zeroes?
15:05:36 <tingi> Zao, it is bits set so shouldn't matter
15:05:37 <lispy> cygnus: hmm...no idea.
15:05:44 <Zao> Oh, missed that bit.
15:05:52 <Zao> Is N known or dynamic?
15:05:52 <Botje> tingi: one solution could be to work with [Int] and generate a list with one 1, two 1s, three 1s.
15:06:21 <Botje> then generate the number from the [Int]
15:08:13 <yaxu1> yep, killing ~/.ghc seemed to do the trick
15:08:18 <tingi> i was thinking of like O(2^n) using recursion. What you said will be O(n*2^n) if i'm not wrong
15:08:44 <yaxu1> thanks Saizan_
15:09:58 <Saizan_> yaxu1: np, ~/.ghc contains the user package dbs, while the packages' files are in ~/.cabal/lib
15:16:16 <Phyx-> :t toDec
15:16:17 <lambdabot> Not in scope: `toDec'
15:16:23 <Phyx-> oh, it's no longer there
15:16:26 <Phyx-> :t fromDec
15:16:27 <lambdabot> Not in scope: `fromDec'
15:19:21 <ivanm> @hoogle toDec
15:19:22 <lambdabot> No results found
15:19:29 <ivanm> was this a @let definition?
15:21:19 <Veinor> http://img177.imageshack.us/img177/6708/linuxenlosnegociospr0.jpg
15:23:04 <phira> http://spreadsheets.google.com/viewform?formkey=dDExMVFOWmYwSGhIbDhIWVJZRFhqb0E6MA  <- Please answer very short survey on favorite aspects of programming languages (for private ad-hoc research, non-commercial, anonymous)
15:23:07 <phira> :D
15:23:41 <ilid> > map sum . sortBy (comparing length) . subsequences . take 3 $ iterate (*2) 1
15:23:42 <lambdabot>   [0,1,2,4,3,5,6,7]
15:23:58 <ilid> > map sum . sortBy (comparing length) . subsequences . take 5 $ iterate (*2) 1
15:23:59 <lambdabot>   [0,1,2,4,8,16,3,5,6,9,10,12,17,18,20,24,7,11,13,14,19,21,22,25,26,28,15,23,...
15:26:31 <aavogt> @pl let on0 x v = x v =<< C.defaultChannels v in on1 x = flip $ on0 . flip (flip . x)
15:26:32 <lambdabot> (line 1, column 52):
15:26:32 <lambdabot> unexpected "="
15:26:32 <lambdabot> expecting variable, "(", operator or end of input
15:26:59 <aavogt> @pl \x -> flip $ on0 . flip (flip . x)
15:26:59 <lambdabot> flip . (on0 .) . flip . (flip .)
15:27:09 <aavogt> @. unpl pl \x -> flip $ on0 . flip (flip . x)
15:27:10 <lambdabot> (\ n b c -> on0 (\ g j -> n g j c) b)
15:27:31 <aavogt> @pl on0 x v = x v =<< C.defaultChannels v
15:27:31 <lambdabot> on0 = (`ap` C.defaultChannels) . ((=<<) .)
15:44:27 <user317> how do i get a superclass to work with monadtrans?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10462#a10473
15:47:25 <Phyx-> test
15:47:29 <Phyx-> > id 8
15:47:30 <lambdabot>   8
15:47:49 <mauke> http://cgi.4chan.org/r/src/1254781396175.gif
15:48:50 <ilid> user317: you shouldn't need to. if your code works for an apbitrary monad, it works for monads produced by monad transformers
15:48:51 <sunfun> :D
15:49:11 <zzzs> is there a way to allocate some bytes then write some data into the allocated bytes without having to write those function in C?
15:49:31 <aavogt> @hoogle malloc
15:49:31 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
15:49:31 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
15:49:31 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
15:49:49 <user317> hmm, ok
15:49:57 <Zao> @hoogle alloca
15:49:57 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
15:49:57 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:49:57 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:50:12 <Zao> Quite convenient.
15:51:21 <zzzs> aavogt/zao, is there an example that i can take a look at?
15:51:54 <zzzs> also, is there a way to check @hoogle in emacs w/o the result being displayed in the browser?
15:52:23 <ilid> user317: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10462#a10475
15:52:36 <ivanm> zzzs: install hoogle locally
15:53:01 <ivanm> or use erc to connect to Freenode and ask lambdabot... >_>
15:53:01 <Zao> zzzs: malloc gives you a (Ptr a) you can peek and poke into.
15:53:21 <Zao> zzzs: alloca takes a function (Ptr a -> IO b) that when returning frees the memory.
15:53:23 <user317> oh i see
15:54:07 <Zao> zzzs: Skim the Foreign docs for memory fiddling in general.
15:54:26 <zzzs> ivanm, i installed hoogle, and it works in commandline, i'm wondering if i can get the result in emacs via 'haskell-hoogle', which seems only display the result in a browser
15:54:30 <zzzs> Zao, thank
15:56:17 <burp> @src map
15:56:17 <lambdabot> map _ []     = []
15:56:17 <lambdabot> map f (x:xs) = f x : map f xs
15:56:38 <user317> ilid: does this make sense: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10462#a10476
15:58:35 <ilid> user317: presumably useGetter :: StateT String (State Int) Bool here?
15:59:21 <Tony[`]> Anyone know of any good resources on coinduction? :)
15:59:44 <user317> yea, basically "usegetter" is traversing some data structure with some local state, and when it reaches certain points it calls the functions provided by the class, i just used "getter" to play with the types
16:01:01 <user317> what does the -XNoMonomorphismRestriction#- do exactly?
16:01:05 <ilid> user317: well, it looks correct. personally i'd put type signatures on the top-level bindings arather than on the bindings inside the do
16:01:47 <ilid> -XNoMonomorphismRestriction turns off the monomorphism restriction :)
16:02:21 <user317> :), what is the monomorphism restriction?
16:02:25 <sunfun> :D
16:02:27 <ilid> the monomorphism restriction requires certain bindings to be monomorphic (in particular, your runGetter, userGetter and getState are hit by this because they're top-level functions with no arguments)
16:02:54 <user317> i see, so if i just add the types that requirement would go away?
16:03:15 <ilid> if you add type annotations for those functions the problem would disappear, yes
16:03:17 <Saizan> yes
16:03:38 <user317> cool, would ghci ever be wrong about the types?
16:03:55 <Saizan> also, the MR applies only when there's a typeclass context
16:04:24 <Saizan> user317: it might fail to find a type if you use some GHC extensions
16:05:23 <ilid> user317: also, ghci doesn't do defaulting on expressions passed to :t.
16:05:27 <user317> its kind of sad that i can generate type signatures that i can't understand :)
16:06:33 <user317> i guess thats why i am an engineer and not a mathematitan
16:11:22 <jvoorhis> Tony[`]: Haskell Road to Logic, Maths and Programming has a chapter about corecursion that might help
16:13:22 <Tony[`]> corecursion I understand, it's the proving process with coinduction that loses me; is that covered as well?
16:17:45 <jvoorhis> i can't remember offhand :) i don't have a copy at work
16:18:22 <Tony[`]> jvoorhis: just bought a copy :) thanks for the recommendation
16:18:30 <FunctorSalad> that book title has a funny metaphysical sound to it...
16:40:34 <ivanm> zzzs: you can integrate it into ghci
16:40:47 <ivanm> and I'm pretty sure you can integrate it into haskell-mode as well
16:42:04 <ivanm> zzzs: if you're using haskell-mode integration, you still need a browser though, but you can use emacs-w3m
16:42:25 <ivanm> http://www.haskell.org/haskellwiki/Hoogle
16:43:00 <ivanm> zzzs: if you're wanting to do ghci integration, then the version on the ghci page is better: http://www.haskell.org/haskellwiki/GHCi
17:32:14 <tehgeekmeister> wow, quiet tonight.
17:32:14 <lambdabot> tehgeekmeister: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:33:01 <ivanm> @. elite quote
17:33:02 <enolan> Everyone is in the cool-kids channel. They don't like our kind.
17:33:02 <lambdabot> <dDaRiu5> 54Ys: mM0RROW: NOT|-|in9 i$ e\/alU4+eD UNTi| i+ Is
17:33:05 <ivanm> tehgeekmeister: happy now? ;-)
17:33:49 <tehgeekmeister> ivanm: haha
17:34:02 <tehgeekmeister> oh was that a split up there?
17:34:09 <ivanm> don't think so
17:34:27 <tehgeekmeister> oh yeah, it's all spread out
17:36:39 <BMeph> So which hcannel is "the cool-kids channel" - #catsters? ;p
17:36:47 <BMeph> *channel
17:36:51 <Saizan> i'd ignore join/part/quit if i weren't an operator
17:37:25 <Saizan> you tricked me, there's no #catsters channel
17:37:46 * BMeph chortles with evil glee!
17:38:09 <BMeph> Saizan: Ah, but for one bright shining moment, there was... >;)
17:38:28 <ivanm> BMeph: when?
17:38:42 <ivanm> "/topic #catsters" told me there wasn't
17:38:44 <Saizan> well, i'm still there
17:39:05 <ivanm> so you're saying that freenode is lying to me? :o
17:50:33 <kyagrd> I'm looking for a paper discussed in #haskell which was about expressing monads that captures effects (e.g. read, write), having hard time trying to dig up from the channal logs.
17:51:18 <kyagrd> I remember it being some kind of functional pearl, quite recent maybe submitted or to appear in JFP or something.
17:52:31 <ivanm> State?
17:53:02 <Saizan> kyagrd: the description is a bit vague
17:53:23 <Saizan> expressing in what way?
17:53:25 <Cale> kyagrd: Who wrote it?
17:53:29 <kyagrd> It was about using additional type parameters clevery so that you can have IO of read and IO of read and write
17:53:49 <Cale> ah, okay, that's a bit more to go on...
17:54:12 <kyagrd> Cale: That's the problem. I think the author mentioned his homepage or something and I forgot to jot down
17:54:13 <Cale> Could it be "Data types à la carte"?
17:54:14 <Saizan> Data Types a la Carte has some of that, but it's not so recent
17:54:17 <ivanm> where else but #haskell can someone ask for a paper and get a reply of "which one are you talking about?" ;-)
17:54:44 <Cale> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
17:55:32 <kyagrd> Oh, that was it ah
17:56:00 <kyagrd> That's why I wasn't able to search for monad in the titles
17:56:07 <kyagrd> Thanks
17:56:39 <Saizan> yeah, the part that directly talks about monads is the last paragraph
17:56:53 <Saizan> (or so)
18:22:51 <shepheb> Haskell++
18:22:54 <shepheb> QuickCheck++
18:23:32 <shepheb> wasn't certain of my thinking on the algorithms problem, wrote a bit of code to use quickCheck to compare my clever algorithm against the n^2 one, fix a bug and now I'm convinced it's correct.
18:23:43 <hackagebot> pureMD5 1.0.0.3 - MD5 implementations that should become part of a ByteString Crypto package. (ThomasDuBuisson)
18:24:30 <djahandarie> Who uses MD5 anyways? D:
18:28:50 <kyagrd> MD5 should not be used any more.
18:28:57 <ivanm> djahandarie: for download verification? *shrug*
18:29:02 <kyagrd> But there are always legacy codes
18:38:42 <Makoryu> :t fmap fmap fmap =<< concatMap
18:38:44 <lambdabot> forall a. (a -> [[a]]) -> a -> [[[a]]]
18:41:12 <ivanm> :t fmap fmap fmap =<< concat
18:41:14 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a]'
18:41:14 <lambdabot>     In the second argument of `(=<<)', namely `concat'
18:41:14 <lambdabot>     In the expression: fmap fmap fmap =<< concat
18:41:19 <ivanm> heh
18:42:05 <dbelange> fap fap fap =<< concat
18:42:23 <ivanm> @slap dbelange
18:42:24 * lambdabot smacks dbelange about with a large trout
18:47:32 <ezyang> I want to make this code faster: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10479#a10479
18:47:52 <ezyang> Are there any obvious optimizations that can be made?
18:48:08 <ezyang> (the reason I'm bothering is because I'm brute forcing a 10 ** 12 size search space)
18:48:18 <ivanm> maybe not use lists?
18:48:24 <ivanm> depending on what you're doing with them
18:48:29 <byorgey> ezyang: what's that // operator?
18:48:32 <ivanm> ezyang: is order important?
18:48:37 <ivanm> byorgey: Set.difference for lists
18:48:42 <byorgey> that wouldn't be a DiffArray update, would it?
18:48:44 <ezyang> byorgey: from GHC.Arr
18:48:49 <byorgey> :t (\\)
18:48:49 <ivanm> @type (//)
18:48:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
18:48:50 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:48:55 <ezyang> ivanm: Order isn't important
18:48:56 <ivanm> oh, wrong way round... it's for arrays
18:48:58 <ivanm> my mistake
18:49:09 <ivanm> ezyang: then maybe use a Set?
18:49:20 <byorgey> ezyang: what type arrays are you using?
18:49:35 <ivanm> ezyang: what is RunningTuringMachine?
18:49:39 <ezyang> let me post the rest of the code
18:49:46 <ivanm> and where are the arrays coming from?
18:50:04 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10480#a10480
18:50:14 <ezyang> ivanm: Looking at a Set
18:50:41 <ezyang> type TuringMachine = Array TuringIndex TuringTransition
18:50:51 <ivanm> ahhhh
18:51:04 <ivanm> OK, maybe a Map rather than a Set
18:51:15 <ezyang> Tried it; it caused a slight performance degradation
18:51:35 <byorgey> ezyang: // is slooooooooow
18:51:38 <ivanm> ezyang: I've found that generally, unless you are going to be doing them "in-order", maps generally outperform arrays
18:51:42 <byorgey> it's O(n) in the size of the array
18:51:45 <ivanm> ezyang: have you profiled?
18:51:52 <ivanm> that would probably be your best bet ;-)
18:51:59 <ezyang> I'm doing something really odd, which is starting off with an "undefined" turing machine that represents all turing machines, and then constraining it as I operate the turing machine, using the list monad
18:52:06 <ezyang> I've profiled, but am having trouble getting useful info out of it
18:52:15 <byorgey> heh, interesting
18:52:25 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10481#a10481
18:52:50 <ezyang> the really commonly called stuff is pretty obvious
18:53:03 <ezyang> But a huge amount is ambient code execution in stepMachine
18:53:08 <ezyang> and I don't know how to make it faster
18:53:51 <ivanm> hmmm, you're missing the library profiling info in there :s
18:54:12 <ezyang> what flags do I add?
18:54:16 <ivanm> and there appear to be too many CAFs
18:54:24 <ivanm> this is how I normally profile:
18:54:43 <ivanm> ghc -O2 -Wall -funbox-strict-fields -prof -auto-all -caf-all --fforce-recomp --make
18:55:06 <ezyang> gotcha
18:56:44 <ezyang> I don't think a Set would be useful in this case
18:57:44 <ezyang> ok, better profiles!
18:57:55 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10482#a10482
18:58:15 <ezyang> It looks like MoveTape is pretty expensive
18:58:21 <ezyang> Maybe I should unbox it
18:58:55 <ivanm> manual unboxing and inlining isn't always that great an idea unless you know what you're doing
18:59:09 <ezyang> ok.
19:01:38 <ezyang> Hmm, it looks like at its current speed it'll take 15.31 days to terminate
19:01:44 <ezyang> maybe I just won't bother optimizing
19:02:01 <dbelange> That's what you get for using haskell for actual computations.
19:02:58 <djahandarie> dbelange, nah, Haskell can go plenty fast.
19:03:03 <djahandarie> Just need to have the fu
19:03:13 <Saizan> that's what you get with combinatorial explosions :)
19:03:29 <ivanm> yup!
19:03:29 <Saizan> ezyang: i'd add bangs to the fields of Tape, btw
19:03:30 <Axman6> dbelange: haskell isn't slow, if you know what you're doing
19:03:38 <ivanm> dbelange: if you think that, then what are you doing here?
19:03:41 <ezyang> Saizan: What does that do?
19:03:42 <Cale> Besides, these aren't actual computations, it's simulating a Turing machine ;)
19:04:03 <ivanm> ezyang: helps force them to be evaluated rather than leaving thunks lying around for people to trip over
19:04:10 <ezyang> But... they're infinite lists
19:04:23 <ivanm> ezyang: for lists, it just forces the first element
19:04:23 <Saizan> ezyang: it won't evaluate them fully
19:04:31 <Saizan> not even the first element
19:04:34 <Saizan> the first cons
19:04:34 <ezyang> ah, ok
19:04:44 <Cale> But will that actually help?
19:04:49 <ezyang> I've never used this syntax before
19:04:51 <Saizan> however the main effect will be on Symbol i think
19:04:53 <Axman6> i wrote a turing machine in haskell once. and then went ahead and implemented things like addition and multiplication of binary numbers (it was a binary turing machine
19:04:55 <ezyang> Is there reference somewhere?
19:05:03 <Saizan> since Symbol could get unpacked
19:05:23 <Saizan> though moving it to the lists will pack it again, mmh
19:05:41 <djahandarie> Every decision I make in real life gets modeled in a finite-state machine.
19:05:59 <ezyang> I'd hate to have to use a turing machine to model real life decisions...
19:06:18 <ezyang> "Wait a few hours while I construct a n-state, 2-symbol turing machine for this decision graph..."
19:06:22 <djahandarie> Yeah, it's my excuse for not getting anything done.
19:06:26 <Cale> How big is this array called 'machine' in stepMachine?
19:06:33 <ezyang> Cale: just a sec
19:07:00 <ezyang> 2 states * 4 symbols = 8
19:07:05 <ezyang> it's 8 elements large
19:07:28 <c_wraith> that's huge
19:07:28 <c_wraith> I almost can't count that on my fingers
19:07:40 <ezyang> uhh, does that mean I shouldn't be using an array?
19:07:46 <djahandarie> c_wraith, that's what your toes are for!
19:07:46 <Cale> ezyang: ah, so it's not one of these (minBound, maxBound) arrays?
19:07:57 <ezyang> Well...
19:08:15 <ezyang> undefinedMachine = array (minBound, maxBound) $ zip (range (minBound, maxBound)) (repeat undefinedTransition)
19:08:18 <ezyang> :-P
19:08:22 <joevandyk> does haskell have anything equivalent to lisp macros?
19:08:33 <c_wraith> bah.  I can't install criterion because it depends on chart, which depends on gtk, which I'm not going through the effort to install.
19:08:34 <Axman6> it has template haskell
19:08:38 <ezyang> the index is a two-tuple of a 2 member enum and a 4 member enum
19:08:55 <Axman6> c_wraith: cabal install criterion -f-chart
19:09:00 <Cale> ezyang: Ah, okay
19:09:07 <c_wraith> heh.  ok, then.  I'll give that a try
19:09:24 <Axman6> c_wraith: you can only get cvs output though
19:09:26 <ezyang> Maybe another datatype is more appropriate?
19:09:35 <Cale> ezyang: Still, using arrays means that you're going to do a lot of unnecessary allocation.
19:09:41 <ezyang> Ok.
19:09:46 <ezyang> I could use an 8-tuple
19:09:47 <c_wraith> You means CSV?
19:09:50 <c_wraith> *mean
19:09:56 <c_wraith> CSV is good enough for me
19:10:00 <Axman6> uh, yeah, CSV
19:10:07 <ezyang> will that have better characteristics?
19:10:14 <Cale> ezyang: well, you see this  machine // [(i,[trans])] -- it allocates a whole new array
19:10:32 <ezyang> I don't really see how I can get around that
19:10:34 <ivanm> use a record type maybe?
19:10:36 <ezyang> w/o using a diff array
19:10:43 <ivanm> if you're using a fixed size array anyway...
19:10:52 <Cale> You could try using a DiffArray and seeing how that goes
19:11:07 <Cale> That would be a cheap thing to at least attempt
19:11:16 * c_wraith banishes cvs to t dark ages
19:11:35 <Cale> ezyang: But, why is your maching changing as it runs?
19:11:38 <Cale> machine*
19:12:07 <c_wraith> Heh.  Now that's a good question.
19:12:09 <ezyang> That's the algorithm I'm using ;-)
19:12:11 <Cale> ezyang: It's becoming less nondeterministic?
19:12:38 <ezyang> Added .4s to execution
19:12:40 <ezyang> :-(
19:12:45 <ezyang> Cale: Yep!
19:13:10 <dolio> I seem to recall doing some benchmarks that indicated that n-field algebraic types are quite a bit faster than n-element arrays.
19:13:17 <dolio> If you can stand to work with the former.
19:13:33 <ezyang> Hmm... 8-tuples would be kind of painful to work with
19:13:48 <dolio> Yeah, it gets out of hand quite fast.
19:13:56 <dbelange> Wild troll uses slow on #haskell!  It's super-effective!
19:14:12 <c_wraith> @where criterion
19:14:12 <lambdabot> http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
19:14:23 <ezyang> The alternate algorithm is to enumerate all state machines and test them one by one
19:17:15 <ezyang> I think the conclusion to make here is "The List Monad Is Slow"
19:17:35 <Cale> ezyang: How long does it take to run on your machine?
19:17:52 <Cale> It finishes in 7.5 seconds here.
19:18:02 <Cale> and my machine is not very fast
19:18:08 <Cale> How are you compiling it?
19:18:10 <ezyang> Sounds about right
19:18:42 <ezyang> 1.812s on my machine
19:18:42 <dolio> Are you using the list monad for non-determinism?
19:18:44 <ezyang> wait, huh
19:19:11 <ezyang> why did it suddenly get faster
19:19:17 <dolio> Because there are better options for that from performance perspectives.
19:19:37 <ezyang> dolio: Yeah
19:19:41 <ezyang> What are the alternatives?
19:19:46 <ezyang> 1M = 17.917s
19:19:49 <Cale> My profile looks rather different from yours
19:20:00 <dolio> @hackage logict
19:20:00 <lambdabot> http://hackage.haskell.org/package/logict
19:20:01 <Cale> Though stepMachine is still the culprit
19:20:23 <ezyang> I have a slightly new stepMachine
19:20:26 <ezyang> Lemme post it
19:20:26 <Cale> I'm compiling with -O2
19:20:41 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10483#a10483
19:20:48 <ezyang> same here. ghc --make -O2
19:21:25 <dolio> logict uses continuation passing, which GHC seems to optimize better.
19:21:47 <ezyang> Ooh, pretty
19:22:29 <ezyang> Hmm... I don't need backtracking
19:22:38 <dolio> As long as you don't take apart lists using their constructors, though, it should be a pretty straight-forward translation.
19:24:36 <ezyang> Hmm, should I be looking at the paper for docs?
19:25:13 <dolio> The paper is mainly about the implementation.
19:25:36 <dolio> It works pretty much the same as lists with MonadPlus.
19:25:47 <ezyang> hm
19:25:52 <dolio> l `mplus` r is nondeterministic choice between l and r.
19:25:55 <ezyang> see, I don't understand what it's doing
19:25:57 <ezyang> oh!
19:26:12 <dolio> 'return a' succeeds with a, 'mzero' fails.
19:26:37 <ezyang> given a list, can I convert that into `mplus` form easily?
19:27:03 <dolio> Yeah, 'msum . map return' is a pretty standard [a] -> NonDet a function.
19:27:30 <dolio> Although it's not included in there. That's something that should go in mtl, really.
19:27:31 <Cale> ezyang: It's not much, but you can replace that  length transitions == 1  with  null . tail $ transitions
19:27:59 <Cale> (you know that transitions must be nonempty or you wouldn't have got that far)
19:28:15 <ezyang> Ok. NonDet isn't what the actual type is called. What should I use?
19:28:20 <Cale> (and you don't care about the exact length, so that saves a sliver of time for longer lists)
19:28:23 <ezyang> Logic a?
19:28:26 <Cale> yeah
19:28:28 <dolio> Logic is the equivalent of [].
19:28:52 <dolio> The C.M.L.Class module has a class with additional fancy operations you probably don't really need, too.
19:29:21 <dolio> Like choice between two things by interleaving their successes, rather than taking all from one, followed by all from another.
19:29:57 <dolio> Which is important if you have infinitely many successes.
19:30:37 <ezyang> Ok. So my problem domain is lots of failures marked by one success somewhere far away
19:30:49 <ezyang> but I've been returning a list of Maybe a's so I can track progress
19:30:59 <ezyang> Does logic give me a way to do this, or should I keep doing what I'm doing?
19:31:42 <ezyang> Hmm... maybe that is slowing things up too
19:31:59 <dolio> You mean, like, when you're consuming the end result, you output "I'm still looking" while eating Nothings?
19:32:06 <ezyang> Yeah
19:32:08 <dolio> That does sound like it'd take a lot of extra time.
19:32:13 <ezyang> savvy
19:32:17 <dolio> And, no, Logic is like [] in that aspect.
19:33:20 <ezyang> Ok. So I still want to observeAll at the end
19:33:39 <dolio> Yes.
19:34:32 <Cale> also, I think just getting the head of observeAll will be essentially as fast as observe
19:37:49 <Axman6> :t zip `ap` tails
19:37:50 <lambdabot> forall a. [a] -> [(a, [a])]
19:38:26 <Axman6> > zip `ap` tails [1..5]
19:38:27 <lambdabot>   Couldn't match expected type `[a] -> [b]'
19:38:27 <lambdabot>         against inferred type `[[...
19:38:38 <Axman6> > (zip `ap` tails) [1..5]
19:38:38 <lambdabot>   [(1,[1,2,3,4,5]),(2,[2,3,4,5]),(3,[3,4,5]),(4,[4,5]),(5,[5])]
19:38:56 <Axman6> > (zipWith (/) `ap` tail) [1..5]
19:38:57 <lambdabot>   [0.5,0.6666666666666666,0.75,0.8]
19:39:40 <Axman6> > let fibs (x,y) = x : fibs (y,(x+y)) in  (zipWith (/) `ap` tail) fibs
19:39:41 <lambdabot>   Couldn't match expected type `[a]'
19:39:41 <lambdabot>         against inferred type `(t, t) ->...
19:40:01 <Axman6> > let fibs (x,y) = x : fibs (y,(x+y)) in  zipWith (/) `ap` tail $ fibs (0,1)
19:40:02 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
19:40:11 <ezyang> Holy crap!
19:40:21 <Cale> ezyang: faster?
19:40:32 <ezyang> actually, hard to say. Just a sec
19:40:51 <Cale> It can save a lot of allocation of list cells.
19:40:54 <ezyang> tentatively, that shaved off 2s off of 17s
19:41:33 <ezyang> Yep, definitely faster
19:41:48 <Cale> How does the new profile look?
19:41:53 <ezyang> dolio <3!
19:41:58 <ezyang> just a sec
19:45:37 <nha_> Is there any common idiom for (Map.intersectionWith + Map.unon) to update tree elements with some new info, without losing the old data that doesnt interesct? it seems like i end up using this a lot.
19:45:48 <ezyang> How do I cabal install profiling libraries?
19:46:13 <ivanm> you mean with cabal-install?
19:46:14 <ezyang> (I don't have them for logict)
19:46:20 <ivanm> ezyang: see ~/.cabal/config
19:46:36 <dolio> --enable-library-profiling, I think
19:46:46 <ivanm> library-profiling: True
19:47:04 <ezyang> ok, I did that
19:47:07 <ezyang> now do I reinstall?
19:47:13 <nha_> cabal config --enable-library-profiling
19:47:30 <aavogt> is it possible for cabal to rebuild all dependencies that are missing profiling libraries?
19:47:31 <nha_> configure*
19:47:33 <ivanm> ezyang: yup
19:47:34 <ezyang> unrecognised command: config (try --help)
19:48:12 <ezyang> Still failing
19:48:33 <ezyang> doh
19:48:35 <ezyang> they're commented out
19:49:52 <gwern> aavogt: no
19:49:58 <gwern> aavogt: it's an outstanding request iirc
19:50:22 <ezyang> wat
19:50:25 <ezyang> that can't be right
19:50:31 <aavogt> gwern: too bad
19:50:37 <duaneb> hrm
19:51:05 <ezyang> There's like, nothing in the .prof file
19:51:06 <duaneb> in ghci, when I do ``let a = 1; b = 2; c = a * b in c''
19:51:18 <duaneb> and then do ``let a = 3 in c''
19:51:24 <nha_> try runhaskell Setup.hs configure --enable-library-profiling
19:51:24 <duaneb> it's still 2
19:51:25 <duaneb> :/
19:51:35 <gwern> (we can do semicolons like that in let?)
19:51:39 <duaneb> I dunno
19:51:52 <duaneb> I was trying to represent my situation in two lines :P
19:51:57 <gwern> > let a = 1 in let b = 2 in let c = a * b in c
19:51:58 <lambdabot>   2
19:52:09 <gwern> well, 2*1, seems right to me
19:52:09 <duaneb> whatever
19:52:15 <duaneb> it is!
19:52:23 <duaneb> but, when I redefine a to be 3
19:52:30 <duaneb> why isn't c redefined as well?
19:52:37 <duaneb> c is a * b, not 1 * 2
19:52:38 <gwern> c was already evaluated
19:52:41 <Makoryu> duaneb: Because you're not actually redefining it
19:52:44 <duaneb> :(
19:52:45 <Makoryu> duaneb: You're shadowing it
19:52:56 <ezyang> there we go
19:53:14 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10484#a10484
19:53:54 <Makoryu> duaneb: Every time you type a definition into ghci, you're creating a new (nested) scope
19:54:09 <Makoryu> And obviously, outer scopes can't reach into inner scopes
19:54:39 <duaneb> hrm
19:54:52 <duaneb> but this is a ghci behavior and not a haskell behavior, no?
19:54:53 <ezyang> stepMachine is still the offender
19:55:03 <gwern> ah, even using something like 'c <- return(a*b)' and then redefining a doesn't work
19:55:04 <ivanm> execute the offender!
19:55:10 <duaneb> as in, a repl could have different behavior and still be ``correct''
19:55:12 <gwern> interesting; I rather thought c would be lazy
19:55:12 <nha_> wasnt GHC 6.12.1 RC supposed to be released in sep.
19:55:25 * duaneb wants snow leopard support
19:55:42 <ivanm> duaneb: then get to work! ;-)
19:55:59 <duaneb> the last time I tried compiling ghc, my computer caught fire
19:56:18 <Axman6> 6.12 compiles ok
19:56:18 <ivanm> then there's something wrong with your computer...
19:56:27 <Axman6> needs babying though
19:56:30 <ivanm> Axman6: the as-yet-unreleased 6.12?
19:56:33 <Makoryu> duaneb: ^ I'm not sure what you're asking. You can't redefine stuff at runtime in Haskell, whether in or out of a REPL
19:56:40 <Axman6> yeah
19:56:49 <duaneb> Makoryu: I'm saying at compile time
19:57:00 <duaneb> I'm trying to figure out which definition the compiler chooses
19:57:13 <duaneb> ahh, it complains if there's more than one definition
19:57:15 <Makoryu> duaneb: Do you understand how lexical scoping works?
19:57:20 <Makoryu> Yeah.
19:57:25 <duaneb> yes, I do
19:57:33 <duaneb> I'm playing with an idea that's similar to a repl
19:57:53 <duaneb> think mathematica x repl
19:58:07 <Makoryu> Not familiar with Mathematica, unfortunately
19:58:14 <Makoryu> I mean, I know it solely by reputation
19:58:23 <duaneb> well, it's the idea of the notebook
19:58:25 <duaneb> I really like it
19:58:26 <Makoryu> Explain?
19:58:31 <duaneb> there are ``cells'' that you evaluate
19:58:45 <duaneb> and I often update variables
19:58:58 <duaneb> basically, it's recompiling the ``program'' every time you evaluate a cell
19:59:09 <duaneb> (where the program is the cells that have already been evaluated)
19:59:22 <duaneb> but, with good engineering, it doesn't need to be slow
19:59:33 <duaneb> I think it would work quite well with haskell
19:59:59 <byorgey> duaneb: ah, I like that idea =)
20:00:06 <gwern> sounds very lisp-like...
20:00:14 <duaneb> yea
20:00:18 <duaneb> but it's also very declarative
20:01:01 <duaneb> anyway, I think  that that + things like graphics, new input, would be very cool
20:01:13 <duaneb> woot! I have a new project.
20:02:08 <aavogt> practically it doesn't seem too much different than just writing your program in a file and then reloading whenever the file is changed
20:02:36 * gwern wonders if duaneb finished the last project
20:02:51 <monochrom> There is a blog on this kind of spreadsheet behaviour and the "loeb" operator.
20:03:32 <duaneb> gwern: almost certainly not
20:03:36 <Makoryu> aavogt: The funny thing about Lisp is that serious developers recommend doing exactly that, because actually taking advantage of the full extent of interactive development tends to be.... hackish
20:03:50 <duaneb> I'm really motivated about a project until I fully understand it
20:03:53 <duaneb> then it becomes boring
20:04:01 <Makoryu> duaneb: Heh, I hear you there
20:04:15 <Makoryu> Except, well, stuff
20:04:23 <Makoryu> Actually I don't.
20:04:26 <Makoryu> Ignore me.
20:06:20 <Lycurgus> perhaps the perception of full understanding is actually something else
20:06:45 <Lycurgus> such as a relutance to actually do stuff
20:06:56 <Lycurgus> *reluctance
20:07:13 <c_wraith> Hmm.
20:07:59 <c_wraith> Why does criterion report a confidence interval on the standard deviation?
20:08:27 <gwern>  maybe it's only sampling the occasional timing?
20:08:42 <Lycurgus> (other than thinking to a certain depth)
20:08:43 <Lycurgus> in my experience of several decades of programming, you don't really understand a non-trivial application till a complete baseline of it has been implemented
20:09:43 <ezyang> Ok. Thanks all for your optimization help!
20:09:47 <ezyang> Now, off to let it run
20:10:57 <duaneb> what's the best haskell gui bindings?
20:10:58 * Cale brings back (.) = fmap !
20:11:02 <duaneb> I'm leaning toward HTK right now
20:11:12 <Cale> duaneb: Gtk2Hs maybe?
20:11:23 <Cale> duaneb: Depends on what you're looking for.
20:11:26 <duaneb> Cale: nah, not cross platform
20:11:30 <duaneb> doesn't run on OS X
20:11:35 <Cale> Huh? Gtk2Hs is cross platform.
20:11:40 <duaneb> without X11 or a buggy quartz backend
20:11:55 <duaneb> and, to be honest, I don't care about windows
20:12:00 <c_wraith> well, regardless of not understanding that detail, it looks like my implementation of permutations is, in fact, faster than Data.List's.  It does return a different order, though.  I wonder if that matters.  (Neither are lexicographic)
20:12:12 <Cale> duaneb: There's WxHaskell
20:12:24 <duaneb> is it better than HTK?
20:13:38 <c_wraith> also, is there some way to coax openoffice into producing box&whiskers charts?
20:13:57 <Cale> duaneb: I don't really know much about HTK
20:14:03 <duaneb> ok
20:14:12 <Cale> In fact, where is HTK?
20:14:59 <c_wraith> Hmm.  It seems there is.  somewhat strangely, called "stock charts"
20:15:48 <Cale> duaneb: ah, as expected, HTK is a Tk binding, so the results can be a little ugly. WxHaskell at least looks *somewhat* pretty :)
20:16:13 <Cale> duaneb: (in that it uses the platform's controls)
20:16:38 <Cale> > (+1) . [1,2,3]
20:16:38 <duaneb> yea
20:16:39 <lambdabot>   [2,3,4]
20:16:39 <duaneb> nice
20:17:50 <duaneb> wait
20:17:58 <duaneb> dammit, my wxWidgets is 64 bit!
20:18:11 <duaneb> I really miss my 64-bit linux install :(
20:18:37 <calsaverini> Hi
20:19:01 * Cale doesn't have a 64 bit machine, so hasn't had the opportunity to experience those sort of compatibility pains yet :)
20:19:09 <Cale> calsaverini: hello!
20:19:14 <calsaverini> I'm having a problem (maybe a very simple one)
20:19:31 <calsaverini> with haskell syntax
20:19:31 <Cale> What is it?
20:19:46 <calsaverini> I'm trying to learn how to create a typeclass
20:19:53 <Cale> okay
20:19:53 <calsaverini> so I created a very simple one
20:20:16 <calsaverini> with just a simple ''multiplication'' operation
20:20:17 <Cale> If you'd like, you can paste the code on hpaste.org
20:20:35 <calsaverini> oh, nice... I'll come back in just a sec then
20:20:41 <Cale> class MyClass t where
20:20:46 <Cale>   multiplication :: t -> t -> t
20:20:51 <Cale> Something like that?
20:20:54 <calsaverini> yep
20:21:02 <calsaverini> but I'm trying to use * as a simble
20:21:06 <calsaverini> symbol
20:21:07 <Cale> (*) is taken
20:21:20 <Cale> You could hide the (*) from the Prelude
20:21:31 <calsaverini> humm
20:21:39 <calsaverini> that's exactly the problem.
20:22:01 <calsaverini> when I use (*), the interpreter complains about not knowing to what (*) I'm refering to
20:22:03 <Cale> But most people find it more convenient just to use a different string of symbol characters.
20:22:07 <Cale> right
20:22:22 <Axman6> (.*)
20:22:27 <calsaverini> right
20:22:27 <Cale> Because you have the (*) from the Prelude, and the (*) from your class, and it's not sure which one you want.
20:22:38 <Cale> You can import Prelude hiding ((*))
20:23:04 <calsaverini> I thought the interpreter would guess the right (*) because of the type of the arguments I'm passing
20:23:06 <Cale> which will import everything from the Prelude except for the normal multiplication operation
20:23:11 <calsaverini> right
20:23:26 <Cale> It can't do that, because any given type might be an instance of both your new class and Num
20:23:47 <calsaverini> oh right... well, I guess it's simpler to just choose another symbol
20:24:00 <Axman6> much simpler
20:24:10 <calsaverini> ok then :)
20:24:16 <calsaverini> now I understand the problem
20:24:17 <calsaverini> thanks
20:24:54 <Cale> No problem! Don't hesitate to ask any questions here if you get stuck :)
20:25:10 <calsaverini> You know, besides the amazing features of the language, I must say that this channel is one of the main reasons that drives people to learn Haskell
20:25:27 <calsaverini> People are always very nice and available
20:25:32 <calsaverini> thanks
20:26:03 <Cale> Yeah, we try to be helpful :)
20:26:27 <byorgey> Cale++
20:26:32 <byorgey> Cale's middle name is helpful
20:26:39 <ivanm> dammit, you mean that to keep avoiding success we have to be _rude_?
20:26:43 <ivanm> _now_ you tell me!
20:27:04 <calsaverini> hahahaha
20:27:10 <byorgey> I don't think that actually works.  I mean, look at C++.
20:27:23 <calsaverini> HAHAHA
20:27:23 <Cale> Somehow the channel has actually lost members though. I wonder what that's about.
20:27:31 <ivanm> byorgey: but people don't _choose_ C++
20:27:47 <Cale> ivanm: Sadly, they do. :)
20:27:52 <ivanm> :o
20:27:58 <ivanm> I thought that _managers_ chose C++
20:28:05 <ville> Hey no disrespecting C++
20:28:29 <byorgey> ivanm: the guy who won the ICFP programming contest this year said he used C++ because he loves it
20:28:32 <Fitbos> excuse me, can u guys answer an easy question for me? i'm a totally newbie in haskell......
20:28:33 <ivanm> wasn't there a fake interview that "admitted" that C++ was deliberately written to stop people from using it!
20:28:39 <Cale> Fitbos: sure
20:28:39 <byorgey> Fitbos: sure, what's the question?
20:28:59 <ivanm> byorgey: he must have lost a bet...
20:29:00 <Axman6> Fitbos: that's what we're here for
20:29:18 <stoney> guys can you have multiple if else statements in haskell
20:29:24 <Axman6> yes
20:29:25 <Fitbos> i wondered how to print a triangle formed by '*' in haskell?
20:29:34 <Cale> stoney: You can nest if/then/else expressions
20:29:38 <stoney> like i have 2 guards
20:29:39 <Saizan_> stoney: you can nest them, or use guards
20:29:53 <Fitbos> i mean in the most haskell way
20:29:57 <stoney> and i would like in each guards to have 4 choices(if else statements)
20:30:12 <Cale> stoney: But if they get nested deeply, it's usually nicer to use guards, even artificially like  case () of _ | guard1 -> ... | guard2 -> ...
20:30:29 <stoney> yeah but for guard 1 i want to have 3 choices
20:30:33 <stoney> same for guard 2
20:30:54 <Axman6> Fitbos: i'm not sure i understand the question
20:31:13 <Axman6> Fitbos: do you mean print an ascii triangle?
20:31:26 <monochrom> Perhaps like "*\n**\n***\n****\n"
20:31:37 <Fitbos> yep! exactly!
20:31:38 <Cale> Fitbos: maybe something like  putStr . unlines $ [replicate n '*' | n <- [1..10]]
20:31:39 <Axman6> > text "*\n**\n***\n****\n"
20:31:40 <lambdabot>   *
20:31:40 <lambdabot>  **
20:31:40 <lambdabot>  ***
20:31:40 <lambdabot>  ****
20:31:45 <Axman6> >_>
20:31:56 <Fitbos> >.<
20:31:59 <monochrom> Programmer English is miserable.
20:32:00 <Axman6> Cale++
20:32:18 <Cale> > replicate 5 '*'
20:32:19 <lambdabot>   "*****"
20:32:32 <Axman6> > unlines ["hello","world"]
20:32:32 <lambdabot>   "hello\nworld\n"
20:32:43 <calsaverini> Just another simple question: to define a function as an infix symbol instead of a prefix I just declare it with parenthesis?
20:32:49 <Cale> Fitbos: So we make a list of strings with different numbers of stars like that, then use unlines on it to get a string where those are the lines of text
20:32:51 <heatsink> stoney, 3 choices?
20:32:57 <Cale> Fitbos: and then putStr to print it out
20:33:06 <Saizan_> putStr . unlines . take n . iterate ('*':) $ "*"
20:33:12 <Cale> calsaverini: It also has to be made of symbol characters
20:33:17 <stoney> for example guard1
20:33:21 <Cale> calsaverini: you can even define it by using it infix
20:33:33 <heatsink> calsaverini, Infix symbols are made of operator symbols, or ordinary names inside backquotes
20:33:44 <stoney> i have 2 guards
20:33:44 <heatsink> > 4 `max` 5
20:33:45 <lambdabot>   5
20:33:47 <Cale> (x:xs) /\/ (y:ys) = x : y : (xs /\/ ys)
20:33:48 <heatsink> > 4 * 5
20:33:49 <lambdabot>   20
20:33:52 <Axman6> Cale: you can say define this: 4 min 5. you need to use a symbol character
20:33:53 <Cale> ^^ like that
20:34:03 <stoney> and within each guards id like to have maybe 3 or 4 expressions
20:34:07 <Fitbos> how to use lambdabot here? just use the '>' as a prefix?
20:34:14 <Axman6> can't*
20:34:19 <Cale> Fitbos: yeah
20:34:22 <calsaverini> Cale, heatsink - thanks
20:34:29 <Cale> Fitbos: "> " as a prefix, actually
20:34:34 <Cale> (the space is required)
20:34:37 <Axman6> gah, totaly failing at irc today
20:34:40 <Saizan_> Fitbos: and it won't do IO
20:34:51 <Fitbos> > putStr 'Hello World"
20:35:00 <lambdabot>   <no location info>:
20:35:00 <lambdabot>      lexical error in string/character literal at chara...
20:35:00 <Fitbos> > putStr 'Hello World'
20:35:01 <lambdabot>   <no location info>:
20:35:01 <lambdabot>      lexical error in string/character literal at chara...
20:35:05 <Axman6> Fitbos: you can't do IO in lambdabot
20:35:06 <Cale> putStr . unlines . iterate ('*':) $ "*" -- infinite triangle of doom!
20:35:10 <Axman6> :t putStr
20:35:11 <lambdabot> String -> IO ()
20:35:22 <Saizan_> also, you use double quotes for strings
20:35:31 <heatsink> > system "rm -rf /"
20:35:32 <lambdabot>   Not in scope: `system'
20:35:32 <Cale> > putStr "Hello World"
20:35:34 <lambdabot>   <IO ()>
20:35:48 <Fitbos> oh... i c...
20:35:51 <Cale> It evaluates to an IO action, but doesn't execute the IO action.
20:36:12 <stoney> if <condition>    then       <true-value>    else       <false-value>
20:36:13 <Axman6> > return 1 :: IO Int
20:36:14 <lambdabot>   <IO Int>
20:36:17 <stoney> this gives me only 2 choices
20:36:32 <heatsink> stoney, you can use &&, ||, and if-else inside guards
20:36:56 <Cale> It's also possible to define your own variations on if
20:37:12 <heatsink> > if True then 1 else if False then 1 else if True then 1 else 1
20:37:13 <lambdabot>   1
20:37:15 <stoney> yes but if i use the one i showed you that gives me only 2 choices
20:37:24 <Cale> stoney: right
20:37:26 <stoney> oh i see
20:37:57 <Cale> stoney: nesting ifs can get ugly, so using case with guards is often preferable
20:38:15 <Axman6> or just straight guards
20:38:19 <Cale> yeah
20:38:26 <Cale> If it doesn't matter that it be an expression
20:38:36 <dons> ?yow
20:38:36 <lambdabot> Couldn't find fortune file
20:38:38 <dons> boo!
20:38:41 <Cale> case () of _ | condition1 -> ...
20:38:45 <Cale>              | condition2 -> ...
20:38:48 <Cale>              | condition3 -> ...
20:38:52 <stoney> oh i see cale
20:39:10 <Cale> It's kind of cheesy, but nicer than nesting if expressions
20:39:18 <Axman6> or f x | cond1 = ... | cond 2 = ...
20:39:23 <stoney> but is there any other options
20:39:43 <Axman6> what more could you want?
20:39:49 <Cale> Yeah, if the whole function is defined based on that selection, you use guards on the left of the = for the function.
20:39:49 <Axman6> i ternary if?
20:39:58 <stoney> no but since cale said its cessy i thought maybe there is better way
20:40:09 <Fitbos> where can i find some small programs in haskell to study it?
20:40:26 <Cale> Fitbos: you might look through what's available on Hackage
20:40:27 <Axman6> Fitbos: do you have a tutorial to follow?
20:40:33 <Cale> stoney: Well, it's an idiom anyway.
20:40:42 <Cale> stoney: You can also define your own choice operations
20:40:54 <Cale> for example...
20:41:04 <Cale> data Choice a = Bool :-> a
20:41:12 <Cale> pick :: [Choice a] -> a
20:41:33 <Fitbos> yes... actually i'm a C++ programmer, and i just can't make my think as the haskell way
20:41:40 <Cale> pick [] = error "pick: ran out of options"
20:41:50 <Fitbos> i mean my brain
20:41:59 <Cale> pick ((True :-> x) : xs) = x
20:42:01 <Axman6> Fitbos: i'd recomment lyah:
20:42:04 <Cale> pick ((False :-> x) : xs) = pick xs
20:42:04 <Axman6> @where lyah
20:42:05 <lambdabot> www.learnyouahaskell.com
20:42:10 <Axman6> Fitbos: ^^^^^^^^^^^^^^^^^^^^
20:42:15 <heatsink> stoney, my preferred style is to define complicated guard conditions in a where clause
20:42:43 <Fitbos> thx!
20:42:44 <Cale> stoney: with that, you can write something like  pick [condition1 :-> result1, condition2 :-> result2, ...]
20:42:45 <heatsink> foo x y | xIsBad = ... | yIsBad = ... where xIsBad = ...; yIsBad = ...
20:43:09 <stoney> tx cale
20:43:20 <Cale> stoney: The reason that writing things like that is possible is that we have lazy evaluation.
20:43:35 <Cale> stoney: So you can be sure that choices which aren't selected won't be evaluated.
20:44:02 <Cale> stoney: and conditions past the first one to succeed won't get evaluated either
20:44:10 <stoney> yeah i am still trying to wrap my head around lazy evaluation and pattern matching
20:44:18 <Fitbos> i've read some on lyah, but i still can't use haskell for general programming. maybe i didn't read much
20:44:42 <Cale> stoney: If you prefer not to use a custom datatype, you could also just use normal pairs for pick
20:44:55 <Cale> pick ((True,x):xs) = x
20:44:56 <Cale> etc.
20:45:14 <stoney> isnt that pattern for list
20:45:17 <Cale> Fitbos: It takes a while to become sufficiently accustomed.
20:45:20 <Saizan_> you can define a ~> b = (a,b) for nicer syntax
20:45:23 <Cale> stoney: yeah
20:45:27 <Cale> stoney: a list of pairs
20:45:33 <Axman6> Fitbos: read more, spend more time in here, and ask lots of questions
20:45:43 <stoney> thanks man
20:46:07 <Cale> stoney: but most people would just use the case expression
20:46:33 <Fitbos> thanks u guys. actually this is the first time i use irc...... i'll ask questions here often~
20:46:40 <Cale> stoney: but if you have something more complicated, it's nice to see that this much is doable :)
20:46:59 <stoney> true cale.....i just hope i get up to speed with haskell
20:47:03 <stoney> i actually like it
20:52:47 <Makoryu> stoney: http://echo.rsmw.net/n00bfaq.html <- There's this too, if it's any help. Still incomplete, but eh.
20:53:34 <stoney> thanks makoryu
21:03:52 <ivanm> preflex: seen dcoutts
21:03:53 <preflex>  dcoutts was last seen on #haskell 10 hours, 2 minutes and 26 seconds ago, saying: tuukkah: your main-is does not need to be Main.hs, it can be any file, so you can have multiple Main modules.
21:05:59 <calsaverini> is it possible to run ghci without loading the Prelude?
21:06:41 <bd_> calsaverini: hmm.. try loading a file that does an import qualified Prelude () ?
21:06:54 <Veinor> calsaverini: in ghci, do :m -Prelude?
21:06:58 <Veinor> without the ?, obviously :P
21:07:07 <bd_> or gah, ghci -fno-implicit-prelude
21:07:09 <bd_> er
21:07:10 <bd_> ah*
21:07:20 <Veinor> or do that
21:09:44 <calsaverini> thans
21:09:46 <calsaverini> thanks
21:11:13 <ivanm> is there a preferred way of referencing Hackage in a paper?
21:11:40 <sproingie> a url, i imagine
21:11:43 <ivanm> heh
21:12:03 <ivanm> unlike other big things (cabal, etc.), there doesn't seem to be a paper on hackage I can reference...
21:13:53 <Axman6> not everything has to be the result of research ivanm ;)
21:14:10 <sproingie> no doubt a sign of a language's maturity :)
21:14:31 <sproingie> "i hacked it together in haskell" \o/
21:14:44 * Axman6 hacks stuff together in haskell all the time
21:14:46 <ivanm> Axman6: I know
21:14:49 <sproingie> i wish i could
21:14:51 <ivanm> but citing papers > citing websites
21:15:05 <sproingie> sure but what's to
21:15:13 <Axman6> sproingie: you need to ask more questions in here obviously ;)
21:15:14 <sproingie> sure but what's to "cite" about hackage?
21:15:16 * ivanm hacks stuff together in haskell, and then fixes the code up when he has time
21:15:17 <ivanm> ;-)
21:15:33 <ivanm> sproingie: language advocacy ;-)
21:16:17 <Axman6> you don't advocate things using papers
21:16:45 <sproingie> i'm vacillating between scala, clojure, and haskell for my next project
21:17:26 <sproingie> scala tool support is infuriating me, and if i go with clojure, i may as well just go all the way functional instead
21:18:22 <sproingie> not like haskell tool support is all goodness, but flymake gives me pretty good feedback
21:20:29 <sproingie> i still don't know how to convert heavily-OO code to functional
21:21:11 <monochrom> Perhaps don't convert. Reverse-engineer the specification. Re-design and re-implement afresh.
21:21:13 <Elly> lots of lambdas!
21:21:17 <Cale> sproingie: I have a bit of an article about at least a simple approach to problems that seem naturally object oriented
21:21:34 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
21:22:18 <Cale> sproingie: It doesn't give you subtyping, but often you don't really need that.
21:23:13 <Cale> (as an added bonus, it's really very much functional programming, because it relies on the ability to construct data structures that are composed of functions, and occasionally on laziness)
21:24:03 <blackdog> sproingie: ah, good to see another flymake user. it's great, hey.
21:25:30 <sproingie> i kind of do need some amount of subclassing, but i can probably do it without subtyping
21:25:51 <sproingie> i just need a function parent :: GameObject -> GameObject
21:25:58 <Cale> yeah, that's also possible :)
21:26:08 <idnar> composition is better than inheritance (subtyping)
21:26:18 <sproingie> sure but sometimes you really do want inheritance
21:26:55 <sproingie> my first real OO experience was with a prototype-OO language, so i can deal with delegation just fine
21:27:04 <idnar> I think I never want typing, it's just that I can't find a better option
21:27:17 <idnar> er, subtyping/inheritance
21:27:28 <idnar> of course I want typing :)
21:27:28 <sproingie> blackdog: i just discovered flymake myself, it's been nice for my perl code
21:27:37 <SamB_XP_> sproingie: what the heck?
21:27:43 <SamB_XP_> how do you compiler perl code?
21:27:45 <sproingie> and i found some scripts that made it work with haskell
21:27:55 <sproingie> SamB_XP_: it just runs perl -c on it to hilight errors
21:28:16 <sproingie> flymake doesn't actually build as far as i can tell
21:28:33 <idnar> OMG YOU CAN'T PARSE PERL11111
21:29:08 <sproingie> thankfully i don't have any code that produces side effects in BEGIN
21:29:19 <sproingie> well not visible ones
21:29:34 <monochrom> Play a movie. My favourite side effect.
21:30:11 <idnar> haha
21:30:35 <SamB_XP_> sproingie: flymake *can* presumably build
21:30:44 <SamB_XP_> based on the name, anyway
21:32:06 <sproingie> it runs on temporary buffers
21:32:34 <sproingie> i suppose you could bend it into a background compiler, it just isnt set up that way out of the box
21:33:20 <SamB_XP_> didn't say it compiled such that the results were of any use ...
21:34:49 <monochrom> pure, referentially transparent build?
21:36:29 <blackdog> sproingie: my trouble is keeping the different checkers laid out nicely. had it set up for ruby, perl, ocaml and haskell at one stage, but i think the ocaml and haskell checkers interfere
21:36:34 <blackdog> elisp isn't much of a development language
21:44:25 <calsaverini> Suppose I define a new type similar to [a] using something like
21:44:45 <calsaverini> data List a = Cons a | End
21:44:49 <calsaverini> ops
21:45:01 <calsaverini> data List a = Cons a (List a) | End
21:45:48 <calsaverini> Then I can construct a large ''list'' just using the constructor Cons
21:46:27 <Makoryu> calsaverini: Sure. You could even spell Cons as (:-) or something
21:46:37 <calsaverini> but with the default lists I can do it in two ways: by using (:) and by enclosing coma separated values like [1,2,3]
21:46:48 <ivanm> right, you can't duplicate the second
21:46:58 <calsaverini> hmmm
21:46:58 <ivanm> that's built-in syntactic sugar
21:47:11 <calsaverini> oh, right... that was my doubt
21:47:36 <calsaverini> well, I can live with that :P
21:47:46 <calsaverini> But it would be nice to be able to do it
21:48:08 <calsaverini> okay, thanks again
21:48:46 <Axman6> calsaverini: fromList (x:xs) = Cons x (fromList xs); fromList [] = End ;)
21:49:03 <Axman6> then you can just use normal lists syntax :P
21:49:08 <calsaverini> hahahah
21:49:17 <calsaverini> right
21:49:30 <Makoryu> Axman6: fromList = foldr Cons End
21:49:32 <Draconx> fromList xs = foldr Cons End
21:49:40 <Draconx> er, s/xs // -- I lose.
21:49:45 <Makoryu> :D
21:50:07 * Axman6 maintains that his is more clear. especially for someone beginning haskell
21:50:16 <ray> wrong
21:50:21 <ivanm> Axman6: but it's not the Haskell Way! :p
21:50:27 <ray> especially for someone beginning haskell
21:50:37 * ivanm agrees with Axman6 
21:50:40 <calsaverini> I was asking this cause I was trying to build a type similar to Python's dictionary just to see If I understood the syntax of typeclasses and Algebraic types and such
21:50:45 <ray> then they see a mess instead of a beautiful pointless fold
21:50:58 <ivanm> ray: yes, but beginners usually don't understand pointfree
21:51:04 <Axman6> ray: pointless /= easy to understand
21:51:11 <SamB_XP> for a beginner, Axman6's way would be clearer
21:51:13 <ivanm> Axman6: almost the exact opposite ;-)
21:51:14 <SamB_XP> for me, the other one
21:51:21 <Axman6> indeed
21:51:37 <Axman6> pointfree style just makes life harder when you're beginning to use haskell
21:51:45 <calsaverini> Then I wanted to use a beautiful {} thing
21:51:50 <ivanm> anyone here willing to proof-read the draft of the paper I'm submitting to PEPM on SourceGraph?
21:51:51 <SamB_XP> mostly because I wouldn't be staring at a bunch of boilerplate trying to figure out what boilerplate it is ;-)
21:51:52 <Makoryu> Axman6: Once you have the syntax down, an understanding of folds is one of the most important things you can know in Haskell.
21:52:01 <Axman6> things like addOne = map (+1) can be somewhat easy to understand, but beyond that, it's not
21:52:31 <deew123123> can someone please tell me how to fix this error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10487#a10487
21:52:32 <ray> folds aren't exactly @pl output territory
21:52:42 <ray> that's obsucatory for just about anyone
21:52:45 <SamB_XP> of course, there's an intermediate version which is not point-free but *is* a fold
21:53:08 <ray> yeah you stick xs on the end
21:53:16 <ivanm> ray: _both_ ends!
21:53:28 <ray> and then you point out to your young, malleable mind that since they both have an xs at the end you can actually leave it off
21:53:32 <SamB_XP> ivanm: no, no
21:53:35 <ray> while squeezing
21:53:42 <SamB_XP> it doesn't work to stick xs on the front!
21:53:43 <ray> gently yet firmly
21:53:48 <ivanm> well, you know what I mean
21:53:55 <Axman6> calsaverini: does foldr Cons End make sense to you?
21:54:19 <ray> if not i hear cale has some images
21:54:22 <Draconx> Axman6, fromList xs = foldr Cons End xs -- there, not pointless.
21:54:50 <Axman6> my problem wasn't actually with it being pointfree (for once)
21:54:51 <deew123123> did anyone check out my code
21:54:56 <c_wraith> @pl interleave y@(yh:yt) = (x:y):[ yh:z | z <- interleave yt]
21:54:56 <lambdabot> (line 1, column 22):
21:54:56 <lambdabot> unexpected "="
21:54:56 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
21:55:06 <Axman6> deew123123: i did, you didn't tell us what the problem was did you?
21:55:15 <ivanm> nope, no error there
21:55:25 <ivanm> Axman6: the error is there's no error! :p
21:55:31 <Axman6> :O
21:55:48 <ray> c_wraith: try a lambda expression
21:55:48 <ivanm> deew123123: are you trying to parse C code?
21:55:51 <Axman6> deew123123: if you want help, you need to tell us what the error is
21:55:54 <deew123123> for some reason i get a compile error
21:56:06 <ivanm> ray: no, I think the problem is @pl doesn't grok list comprehensions
21:56:11 <Axman6> deew123123: ... more details...
21:56:12 <ivanm> or @
21:56:22 <c_wraith> I can rewrite that without a list comprehension.
21:56:24 <ray> it'd be as-patterns
21:56:26 <ivanm> deew123123: chuck the entire error output into another paste
21:56:29 <ray> i guess
21:56:30 <deew123123> parse error on input '=' line 224:13
21:56:39 <ivanm> ray: yes, but I don't know if it knows @-patterns
21:56:40 <c_wraith> @pl foo x = x + x
21:56:41 <lambdabot> foo = join (+)
21:56:49 <ray> @pl probably doesn't know list comprehensions either
21:56:49 <lambdabot> probably doesn't know list comprehensions either
21:56:58 <ivanm> deew123123: what is that newtok doing there?
21:57:05 <ivanm> is it indented too far?
21:57:09 <ray> @pl \be -> quiet lambdabot
21:57:09 <lambdabot> const (quiet lambdabot)
21:57:12 <calsaverini> Axman6, sorry, I didn't saw your question
21:57:14 <deew123123> im trying to create a parser for a simple C language
21:57:20 <Axman6> deew123123: you need to align newtok with newp
21:57:22 <ray> good, be a constantly quiet lambdabot
21:57:32 <calsaverini> Axman6, I had a really HARD time trying to understando foldr
21:57:42 <c_wraith> @pl f ggs@(g:gs) = g : (ggs ++ gs)
21:57:42 <lambdabot> (line 1, column 14):
21:57:43 <lambdabot> unexpected "="
21:57:43 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
21:57:45 <calsaverini> Now I think I got it
21:57:50 <ray> structural recursion!
21:57:51 <c_wraith> yeah, @pl can't handle @
21:57:58 <ezyang> ghci has mysteriously stopped being to reference anything in Main.hs if I load it with `ghci Main.hs`
21:58:07 <ezyang> did something change in a new version?
21:58:16 <calsaverini> but not withouf filling pages and pages of step by step evaluation
21:58:28 <ray> @pl f ggs = (head ggs) : (ggs ++ (tail ggs))
21:58:28 <lambdabot> f = liftM2 (:) head (ap (++) tail)
21:58:53 <Axman6> calsaverini: the easiest way to understand foldr is that in foldr a b xs, it replaces all the (:)'s in the list with a, and the [] withg b
21:59:06 <deew123123> sorry guys if im kinda vague
21:59:21 <ezyang> hmm, ok, that's not strictly true
21:59:24 <Makoryu> deew123123: Mixing tabs and spaces, I take it?
21:59:30 <ezyang> monomorphic functions (with type signatures) are not accessible
21:59:43 <ray> calsaverini: http://en.wikipedia.org/wiki/File:Right-fold-transformation.png
21:59:44 <Axman6> deew123123: did you see what i said? you need to align newtok with newp
21:59:54 <c_wraith> I keep feeling like "interleave y@(yh:yt) = (x:y):[ yh:z | z <- interleave yt]" should be expressable with a fold.  But I can't see how.
22:00:06 <deew123123> i might be.. some of the program our teacher gave us and i typed some...so i might have put spaces and or tabs in there.
22:00:12 <deew123123> axman: how do i do that
22:00:28 <Axman6> make sure the n's are above each other
22:00:30 <ivanm> deew123123: are you using tabs or spaces for alignment?
22:00:35 <Axman6>     newp
22:00:39 <ivanm> because if you're using tabs, ghc interprets a tab as being 8 spaces
22:00:39 <Axman6>     newtok
22:01:03 <jmcarthur> dang i didn't think about what version of opengl is required for GPipe, but of course mesa doesn't support opengl 3.1 yet
22:01:11 <Makoryu> deew123123: First, make sure your editor shows tabs as 8 spaces. Second, look at line 224 or so
22:01:19 <Axman6> jmcarthur: only needs 2.1...
22:01:44 <mgorbach> Anyone know how to do a "double" list comprehension?
22:01:52 <jmcarthur> Axman6: "Main: user error (unknown OpenGL extension entry glUniform1uiv, check for OpenGL 3.1)"
22:02:05 <mgorbach> I have list xs and I'm trying to sort get 2 lists, one of its elements >= x and the other of its elements < x.
22:02:08 <ezyang> mgorbach: combinatoric or zip?
22:02:13 <mgorbach> I want to do this with out iteration of xs instead of 2.
22:02:16 <mgorbach> *with one
22:02:30 <deew123123> axman: whats that for again?
22:02:37 <ivanm> mgorbach: probably need two comprehensions for that
22:02:40 <ivanm> or use partition or something
22:02:44 <ivanm> @src partition
22:02:45 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
22:02:45 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
22:02:45 <lambdabot>                               | otherwise = (ts, x:fs)
22:03:08 <jmcarthur> Axman6: or perhaps it could be my graphics card, but either way it's complaining that it wants opengl 3.1
22:03:18 <Axman6> :\
22:03:31 <idnar> > partition (>= 10) [1..20]
22:03:32 <lambdabot>   ([10,11,12,13,14,15,16,17,18,19,20],[1,2,3,4,5,6,7,8,9])
22:03:38 <Axman6> deew123123: what's what for?
22:03:39 <idnar> > partition even [1..20]
22:03:40 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
22:04:06 <deew123123> axman: newp newtok
22:04:10 <jmcarthur> Axman6: it works great until you try to render to a texture, apparently
22:04:10 <ivanm> > partition (liftM2 (||) even odd) [1..20]
22:04:11 <ivanm> ;-)
22:04:12 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[])
22:04:38 <Axman6> > > partition (liftM2 (||) even odd) [1,2,3,4,5,6,7,8,undefined]
22:04:39 <lambdabot>   <no location info>: parse error on input `>'
22:04:43 <Axman6> > partition (liftM2 (||) even odd) [1,2,3,4,5,6,7,8,undefined]
22:04:44 <lambdabot>   ([1,2,3,4,5,6,7,8* Exception: Prelude.undefined
22:04:48 <Axman6> >_>
22:05:59 <deew123123> ok thanks anyways guys...im gonna get off now
22:06:14 <deew123123> if any of yall figure it out my email is deew123123@yahoo.com
22:06:39 <ivanm> figure what out?
22:06:42 <ivanm> we told him the answer...
22:06:52 <ivanm> deew123123: partition sounds like what you want
22:07:02 <deew123123> what is that
22:07:06 <ivanm> *sigh*
22:07:11 <mgorbach> ivanm: Partiiton does the trick. Thanks.
22:07:11 <ivanm> > partition even [1..10]
22:07:13 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
22:07:15 <idnar> that was mgorbach, not deew123123
22:07:21 <ivanm> oh, whoops, mixed up deew123123 and mgorbach :s
22:07:23 <ivanm> sorry deew123123
22:07:30 <idnar> the keys are right next to each other! :)
22:07:30 <deew123123> np...
22:07:41 <ivanm> idnar: they are?
22:07:48 <jmcarthur> well dang. now i'm all disappointed and stuff
22:07:48 <ivanm> d and m are nowhere near each other here...
22:07:53 <ivanm> heh
22:08:08 <jmcarthur> maybe my mac would fare better for this...
22:08:19 <idnar> ivanm: http://bash.org/?5300
22:08:23 <Axman6> deew123123: i already told you how to fix it...
22:08:30 <deew123123> i just did that
22:08:37 <ivanm> idnar: lol
22:08:37 <idnar> but also, d and m are diagonally adjacent on dvorak :)
22:08:48 * ivanm really should get around to trying out dvorak...
22:08:59 <ivanm> though now that I'm used to xmonad, the keys would be in all the wrong places :s
22:09:12 <blackdog> ivanm: it really is true - once you go dvorak, you never go back.
22:09:14 <idnar> just translate your mappings
22:09:20 <ivanm> sshhh!
22:09:20 <Makoryu> deew123123: You have several errors in your paste, and the ones I can see are of a similar nature
22:09:28 <idnar> so that you're using the same key, even if it's a different letter
22:09:37 <ivanm> idnar: you're not meant to make sensible suggestions! :p
22:09:49 <ivanm> Makoryu: tabs vs spaces you think?
22:10:19 <Makoryu> ivanm: I'm thinking he has one of those "tabs are 4 spaces" editors ;)
22:10:29 <ivanm> yeah
22:10:31 <deew123123> ok thanks guys...ill mess with that and see if i can get it working
22:10:34 <ivanm> which I said before...
22:10:39 <ivanm> deew123123: spaces not tabs!
22:10:45 <ivanm> that's your problem!
22:10:53 <deew123123> so take all tabs out and just use spaces?
22:10:57 <sereven> ivanm: there are dvorak and colemak bindings available. that's no excuse.
22:10:57 <ivanm> yes
22:11:04 <deew123123> ok thanks again
22:11:05 <ivanm> sereven: pfffttt!
22:11:14 <student> hello
22:11:18 <ivanm> IIRC, haskell' is banning tabs for alignment...
22:11:29 <student> Sorry, What is this chat room?
22:11:34 <ivanm> for Haskell
22:11:46 <blackdog> for fans of the logician Curry.
22:11:47 <ivanm> student: you realise you shouldn't be using your Administrator account in XP for everyday tasks?
22:11:47 <student> I dont now
22:11:52 <ivanm> blackdog: heh
22:12:06 <Cale> student: It's for the programming language Haskell.
22:12:20 <Axman6> student: how did you get here?
22:12:45 <Makoryu> student: Are you just looking through all the big channels on Freenode?
22:12:50 <ivanm> @remember chak ... In other words, FP is inevitable.
22:12:50 <lambdabot> Done.
22:13:07 <idnar> ivanm: I'm contrariwise that way
22:13:08 <student> haskell for serving?
22:13:22 <Axman6> serving what?
22:13:22 <Makoryu> student: ...........What
22:13:52 <student> Where to use the programming language Haskell?
22:14:11 <Makoryu> student: Everywhere
22:14:18 <idnar> you can use it for just about anything and everything
22:14:43 <Makoryu> student: It's great for writing programs that translate themselves into C or assembler
22:14:46 <Makoryu> student: And for compilers
22:14:52 <Makoryu> student: And for fast, secure websites
22:15:02 <Makoryu> student: And for other network apps
22:15:13 <ivanm> and for GUI hacking utilities
22:15:14 <ivanm> ;-)
22:15:26 <Makoryu> ivanm: On Linux, yes >_>
22:15:30 <jmcarthur> and for graphics programming and multicore
22:15:40 <Makoryu> Multicore definitely
22:15:44 <student> Assembler program I know about but have not heard of  this
22:15:45 <Makoryu> Multicore anything!
22:15:59 <student> thanks for you explication
22:16:00 <student> and
22:16:04 <c_wraith> Hmm.  To what degree does criterion force its output?  Does it just call evaluate on it?
22:16:13 <jmcarthur> c_wraith: whnf, i think
22:16:25 <ivanm> not rnf? :o
22:16:33 <jmcarthur> no, you have to do it yourself
22:16:49 <student> anyone can help me by sending a file to learn more about this programming  language
22:16:55 <student> :)
22:16:57 <ivanm> student: haskell.org
22:17:03 <ivanm> wikipedia
22:17:06 <ivanm> google
22:17:08 <Axman6> @where lyah
22:17:08 <lambdabot> www.learnyouahaskell.com
22:17:11 <jmcarthur> @where rwh
22:17:11 <lambdabot> is http://www.realworldhaskell.org/blog/
22:17:12 <Axman6> student: ^^^^^^^^^^^^
22:17:27 <ivanm> Axman6: he wants to know _about_ Haskell, not how to _use_ Haskell!
22:17:32 <idnar> @type criterion
22:17:33 <lambdabot> Not in scope: `criterion'
22:17:41 <ivanm> @where criterion
22:17:42 <lambdabot> http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
22:17:52 <ivanm> @hackage criterion
22:17:53 <lambdabot> http://hackage.haskell.org/package/criterion
22:17:58 <ivanm> idnar: ^^ wanting one of these?
22:18:12 <student> is a good explication makoryu
22:18:21 <idnar> well, whatever c_wraith meant
22:18:36 <c_wraith> yes, idnar, I meant that package.
22:18:41 <c_wraith> Both of the links refer to it
22:18:46 <idnar> okay
22:19:15 <student> and some pdf or tutorial on this language
22:19:16 <student>  
22:19:24 <Axman6> @where lyah
22:19:24 <lambdabot> www.learnyouahaskell.com
22:19:28 <Axman6> student: ^^^^^^^^^^
22:20:04 <student> I will visit these websites
22:20:20 <Makoryu> student: That site is a good explanation
22:20:34 <student> there is free this program
22:20:39 <student> thanks
22:20:43 <Makoryu> student: Yes, this is free
22:20:50 <student> ohhh thanks
22:21:13 <student>    is easy to learn
22:21:58 <Makoryu> student: For some people, yes.
22:22:05 <student> anyone have any program code that is easy to understand
22:22:15 <c_wraith> Ok, hmm.  I'm benchmarking permutation algorithms that have the return type [[a]].  Assuming the algorithms are correct, What's my best-case expression forcing all permutations to be generated by a whnf evaluation?  "length . map length"?
22:22:21 <jmcarthur> Axman6: actually, i think this might be a bug in GPipe
22:22:40 <Makoryu> > [1 .. 20] -- For student
22:22:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
22:22:45 <jmcarthur> that function doesn't seem to actually exist in the spec for 3.1 anyway, as far as i can tell
22:22:49 <student> please send me
22:23:10 <Makoryu> student: If you have one line of code, you can type it into this channel
22:23:21 <Makoryu> student: lambdabot will run the code and show you the result
22:23:32 <c_wraith> Blah, that won't work.  It won't actually eval the length of the sublists.
22:23:34 <Makoryu> student: Write "> " before the code
22:23:43 <Axman6> > 1 + 2
22:23:44 <lambdabot>   3
22:23:47 <Makoryu> > ['a' .. 'z']
22:23:49 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
22:23:50 <c_wraith> "sum . map length"?
22:23:56 <student> you can send them a file of any code word please thanks
22:24:18 <Axman6> student: code word?
22:24:41 <student> microsoft word file because I do not understand well, sorry
22:24:55 <Makoryu> student: Are you a programmer?
22:25:29 <jmcarthur> oh, nevermind, it is in the spec
22:25:54 <student> Copy the code into a file in microsoft word please
22:26:01 <student> AND SEND ME PLEASE
22:26:06 <Axman6> student: you don't use microsoft word for programming
22:26:16 <student> yes I now
22:26:32 <Axman6> so... what do you need a word file of then?
22:26:35 <Axman6> what should be in this word file
22:26:37 <Axman6> ?
22:26:59 <Makoryu> student: Relax
22:27:10 <student> but is easy copy the code then can I send me
22:27:17 <student> yes I am relax
22:27:45 <jmcarthur> student: what is your native language?
22:28:13 <student> spanish, I now little english
22:28:26 <student> sorry for my languaje
22:28:36 <jmcarthur> if anybody here knows spanish, please help student
22:29:01 <student> please send me  the code in word
22:29:37 <student> I run it after
22:29:46 <student> in the program
22:29:53 <student> please help me
22:30:21 <jmcarthur> why must you receive the code in word? why can't you just read it here?
22:31:06 <student> because I must be going
22:31:07 <student> and
22:31:20 <Makoryu> student: For some programs, the code can be very short. It can fit on one line.
22:31:40 <student> i
22:31:41 <student> is better if you send me so .. then I understand
22:32:17 <Makoryu> student: Here is a program that prints the size of its input: main = interact (show . length)
22:32:44 <student> please I need the code
22:32:49 <Makoryu> student: That is the code
22:33:02 <Makoryu> main = interact (show . length)
22:33:14 <student> some small programs
22:33:27 <student> for what is this code?
22:33:44 <student> maKoryu
22:33:58 <student> please send me
22:34:01 <jmcarthur> it prints the length of its input
22:34:18 <student> anyone here speak Spanish
22:34:24 <student> please
22:34:33 <Makoryu> student: ¯\O_o/¯
22:34:50 <c_wraith> well, "sum . map length" certainly forces complete evaluation of the nested list structure.  Is there something simpler anyone knows?
22:35:26 <jmcarthur> c_wraith: there's always good ol' rnf
22:35:32 <c_wraith> ...  Any by simpler, I mean "that does less work"
22:35:39 <Makoryu> c_wraith: rnf (map rnf)?
22:35:40 <c_wraith> doesn't rnf force the elements, too?
22:35:48 <Makoryu> c_wraith: No.
22:36:02 <c_wraith> Oh.  Hmm.
22:36:05 <Makoryu> @src rnf []
22:36:06 <lambdabot> Source not found. It can only be attributed to human error.
22:36:09 <Makoryu> @src rnf
22:36:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:36:10 <student> what?
22:36:13 <Makoryu> Bah
22:36:26 <student> any people help me?
22:36:42 <Makoryu> student: Sorry. Nobody speaks Spanish today.
22:37:09 <enolan> I only speak Spanish on alternate Wednesdays :P
22:37:19 <jmcarthur> student: maybe try again some other time?
22:37:29 <student> do you now the pics? I studied electronic engineering
22:37:48 <Makoryu> student: Do your friends speak English?
22:38:10 <student> please I dont can any other day
22:38:20 <jmcarthur> why not?
22:38:43 <Makoryu> student: Your friends could translate http://www.learnyouahaskell.com/
22:38:45 <student> I am busy because I studied
22:39:05 <student> plis send me a code
22:39:09 <student> please
22:40:00 <student> any I can send for you information about the pics, is realy interesting
22:40:08 <student> do you want?
22:40:16 <Makoryu> student: What pics?
22:40:50 <c_wraith> ok, rnf . map rnf was quite wrong.
22:40:52 <student> I send a file to know ok...
22:40:59 <Makoryu> c_wraith: My bad :(
22:40:59 <student> he pics
22:41:12 <enolan> PIC microcontrollers?
22:41:15 <c_wraith> rnf by itself looks to be right, though.
22:41:35 <c_wraith> Oh, wait, no it's not.
22:41:42 <c_wraith> It's forcing the list elements.
22:41:53 <c_wraith> It's about half the speed of "sum . map length"
22:41:59 <student> yes you now enolan
22:43:03 <student> how can I send a file can not find the icon
22:43:13 <student> :-[
22:43:54 <student> how can I send a file can not find the icon
22:44:11 <Makoryu> student: DCC sends files
22:44:15 <Makoryu> student: Learn DCC
22:44:25 <Makoryu> @google DCC IRC
22:44:27 <lambdabot> http://en.wikipedia.org/wiki/Direct_Client-to-Client
22:44:27 <lambdabot> Title: Direct Client-to-Client - Wikipedia, the free encyclopedia
22:44:42 <Cale> student: Who do you want to send a file to?
22:45:27 <Cale> Another IRC user? If DCC send doesn't work for you, you could always do something like get their e-mail address.
22:45:42 <Cale> Or put it on the web somewhere.
22:45:43 <enolan> student: I don't really need any info on PICs, thanks.
22:47:42 <student> ok
22:47:45 <student> and
22:48:26 <student> ha ok sorry but is a information important
22:48:53 <student> and is projects interesting
22:51:16 <Makoryu> student: Will this help? http://www.cs.uu.nl/~jeroen/courses/fp-sp.pdf
22:51:51 <c_wraith> hmm.  "foldl1' (+) . map length" seems to be faster yet.
22:52:23 <Makoryu> student: It's 14 years old. However, it's all I could find in Spanish
22:53:03 <Makoryu> student: Sorry
22:53:28 <student> ok thanks
22:54:07 <Makoryu> c_wraith: Are you doing this in ghci?
22:54:18 <c_wraith> no.  ghc -O2
22:55:24 <Makoryu> c_wraith: ....wow. I thought sum was better optimized
22:55:52 <c_wraith> Makoryu:  It's left non-strict for non-strict numeric types.  Like Natural
22:56:14 <Makoryu> c_wraith: Ah.
22:56:16 <c_wraith> > 5::Natural > sum [1..]
22:56:17 <lambdabot>   <no location info>: parse error on input `..'
22:56:24 <c_wraith> > (5::Natural) > sum [1..]
22:56:32 <lambdabot>   mueval: ExitFailure 1
22:56:38 <c_wraith> oops.  I br0ked it
22:57:16 <Makoryu> > text "It still works!"
22:57:19 <lambdabot>   It still works!
22:57:51 <Saizan_> using foldl won't work on infinite lists anyway
22:58:26 <c_wraith> Saizan_:  My use case is decidedly non-infinite.
22:58:57 <c_wraith> But the expression I gave lambdabot up there should have evaluated to false
22:59:17 <c_wraith> > length [1..]
22:59:21 <lambdabot>   mueval-core: Time limit exceeded
22:59:30 <c_wraith> See?  That's the time limit message
22:59:49 <c_wraith> mueval was not happy with my expression, for some reason.
22:59:59 <c_wraith> ...  And Cale just logged out.
23:00:36 <Makoryu> ¯\O_o/¯
23:00:46 <Saizan_> sometimes the time limiting thread doesn't get a chance to execute and the process gets terminated from the outside
23:01:04 <student> this languaje is like languaje C
23:01:42 <Makoryu> student: Sometimes, yes
23:01:47 <Makoryu> student: You know C?
23:01:47 <c_wraith> > (5::Natural) > sum [1..]
23:01:52 <lambdabot>   mueval: ExitFailure 1
23:02:20 <Saizan_> when that happens it depends on the expression being evaluated
23:02:20 <idnar> > (5::Natural) < sum [1..]
23:02:28 <lambdabot>   mueval: ExitFailure 1
23:02:30 <Saizan_> so repeating won't change much
23:02:38 <c_wraith> ah
23:02:40 <idnar> > sum [1..] < (5::Natural)
23:02:45 <lambdabot>   mueval-core: Time limit exceeded
23:02:46 <idnar> meh
23:02:54 <aavogt> > (5::Natural) > foldr (+) 0 [1..]
23:02:55 <lambdabot>   False
23:02:56 <c_wraith> Well, that's clearer
23:03:00 <idnar> weird
23:03:04 <idnar> oh, not so much
23:03:18 <idnar> I get it
23:03:19 <aavogt> > length [0..]
23:03:22 <lambdabot>   mueval-core: Time limit exceeded
23:03:46 <ivanm> anyone here willing to proof-read the draft of the paper I'm submitting to PEPM on SourceGraph?
23:03:56 <idnar> > (10::Natural) < genericLength [0..]
23:03:57 <lambdabot>   True
23:05:48 <Raevel> ivanm: i might be able to take a look at it tonight, though I'm not familiar with SourceGraph
23:06:02 <ivanm> thanks Raevel
23:06:07 <ivanm> @time Raevel
23:06:08 <lambdabot> Local time for Raevel is Tue Oct  6 08:06:08 2009
23:06:23 <ivanm> hmmm, I probably won't be here when it's night for you ;-)
23:06:36 <ivanm> Raevel: http://code.haskell.org/~ivanm/SourceGraph-Draft.pdf
23:07:43 <Raevel> got it, i'll talk to you later then
23:07:52 <ivanm> thanks! :D
23:19:14 <hackagebot> gitit 0.6.5 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
23:23:15 <Veinor> I think I found something harder to parse than perl.
23:23:33 <portnov> Veinor: malbolge? ;)
23:23:38 <Veinor> :P
23:23:43 <Veinor> MediaWiki.
23:24:00 <Veinor> <includeonly>{{#ifeq:{{{sortable|}}}|on|<span style="display:none">{{padleft:{{{1}}}|16|0}}</span>}}{{convert/{{{2}}}|{{{1}}}|{{#ifeq:{{#expr:{{{3|0}}}*0}}|0|0}}|{{{3|}}}|{{{4|}}}|{{{5|}}}|{{{6|}}}|r={{#ifeq:{{{sp}}}|us|er|re}}|d=L{{{lk|off}}}A{{{abbr|off}}}D{{{disp|b}}}S{{{adj|{{{sing|off}}}}}}|s={{{sigfig|}}}}}</includeonly><noinclude>{{Documentation}}</noinclude>
23:27:28 <DarkUnicorn> looks a bit like lisp
23:27:54 <Veinor> You're just saying that cause of all the curlies :P
23:27:59 <DarkUnicorn> right
23:28:58 <Veinor> it's not really a programming language, although I think it's turing complete.
23:29:03 <DarkUnicorn> but the the mix of xml and brackets is cool
23:29:37 <Veinor> {{x|y|z}} means: include the content of template x, passing y and z as params
23:29:49 <Veinor> {{x|y=1|z=2}} means: include the content of template x, passing y=1, z=2
23:29:58 <Veinor> I forget what #ifeq and #expr do.
23:31:47 <Veinor> DarkUnicorn: mediawiki template-y syntax is very interesting actually
23:33:33 <DarkUnicorn> Veinor: but its not the same they use for the actual content, right?
23:33:41 <ClaudiusMaximus> suppose i 'cabal install'd a load of things without paying much attention, and now i want to reinstall them all with profiling enabled - what's the current best solution?
23:33:43 <Veinor> it is.
23:34:00 <Veinor> You know the [citation needed] stuff? in the actual mediawiki source, that's just {{cn}}
23:34:36 <DarkUnicorn> hm, that seems not very user friendly to me
23:34:57 <Veinor> well, that thing I just typed is what {{convert}} is
23:35:23 <Veinor> which is the template for conversions is. So the EU would just type {{convert|160|mi|km}} to get 160 miles (blah kilometers)
23:35:32 <Veinor> where blah gets replaced with the number of km in 160 mi, to however many sig figs
23:36:15 <DarkUnicorn> this is something different to the template inclusion above?
23:36:36 <Saizan_> ClaudiusMaximus: you can get the list of installed packages with "ghc-pkg list"
23:36:47 <Veinor> no, it's all templates
23:37:24 <DarkUnicorn> and in the convert template is a giant switch?
23:37:49 <Veinor> well, the convert template automatically loads the other templates called {{convert/mi}}, {{convert/km}}, etc.
23:38:09 <DarkUnicorn> oh, i see
23:38:17 <Veinor> Yea. It's kind of deep magic.
23:38:33 <DarkUnicorn> well, it works
23:38:37 <Veinor> indeed.
23:38:44 <Veinor> I think it's intereesting, since most people don't know about it.
23:39:05 <DarkUnicorn> most expert-wikipedia-users should. or not?
23:39:53 <Veinor> you can be a very good wikipedia editor without knowing what the hell's going on in that bit of code
23:40:15 <Veinor> hell, I barely understand it myself
23:41:03 <jfredett_> so, apparently vacuum can't do infinite datatypes so well? :)
23:42:14 <Veinor> and I'm an admin, so. anyway, yeah.
23:43:49 <ivanm> jfredett_: did I release too much software for you last week? :p
23:44:13 <jfredett_> ivanm: for the last three weeks, you've been quite prolific. :)
23:44:18 <ivanm> heh
23:44:34 <ivanm> it's been called "OK, here's a release... oh, noes, a bug! quick, re-release!" ;-)
23:44:48 * ivanm will probably have another couple of releases either today or tomorrow
23:45:03 <jfredett_> its a good thing, don't get me wrong, but I think I need to start keeping a scoreboard...
23:45:16 <jfredett_> post weekly topscores. :)
23:45:30 <ivanm> heh
23:48:04 <jfredett> ivanm: actually, it wouldn't even be that hard, hackage keeps a list of packages submitted + the people who submitted them, so it could be fully automatic...
23:48:04 <lambdabot> jfredett: You have 1 new message. '/msg lambdabot @messages' to read it.
23:48:07 <rrjamie> how do you pattern match a list of a single element?
23:48:18 <simplicio> [x]
23:49:34 <aavogt> uglier, but maybe more consistent:   (x:[])
23:50:01 <Veinor> what's the difference?
23:50:19 <ClaudiusMaximus> Saizan_: cool - helps that i didn't use global installs so i have separate lists for "safe to mess with" stuff vs "came with ghc, don't touch" stuff
23:50:45 <idnar> Veinor: purely syntactical, they have the same effect
23:50:51 <Veinor> ah
23:51:01 <ivanm> in general, heaps of little libs are nicer than large monolithic ones...
23:51:02 <idnar> [x] is syntax sugar for (x:[])
23:51:11 <ivanm> until you need to create packages for all the new libraries that gitit uses :s
23:51:30 <aavogt> using [x] doesn't generalize to ignoring or naming the tail of the list
23:55:24 <jfredett> crap, I should probably go to sleep. goodnight folks.
23:56:10 <Veinor> night.
