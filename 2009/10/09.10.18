00:00:00 <copumpkin> or just use a where or something
00:00:11 <Fragsworth> The use case would be mostly for an after-the-fact quick change that modifies the meaning of the whole program
00:00:14 <copumpkin> fac = fac moo where fac' = blah
00:00:25 <Fragsworth> But the only time I can think of needing that is to log stuff, which is I/O, so maybe it doesn't apply here
00:00:25 <copumpkin> Fragsworth: yeah, we're not into that kind of thing
00:00:44 <Jafet> Besides fac should really describe the factorial function, not something resembling it
00:00:48 <dons> breaks reasoning if you go monkeypatching things.
00:03:43 <dancor> i would say haskell still supports monkeypatching you just do it with (myDecorator $ ..).  and having to use (where) when modifying multiline functions is not so bad
00:04:09 * dancor is all for hacks in haskell ;)
00:04:22 <Jafet> Haskell generally makes hacks look ugly, as they should
00:04:37 <dancor> but (hack $) is not ugly!
00:04:46 <Fragsworth> What is the $ operator?
00:05:19 <dancor> Fragsworth: f (g x) is the same as f $ g x
00:05:38 <dancor> :t ($)
00:05:39 <lambdabot> forall a b. (a -> b) -> a -> b
00:05:54 <Fragsworth> Only for two parameters? or can there be more?
00:05:59 <dancor> f $ g $ hx
00:06:05 <dancor> f $ g $ h x   works too
00:06:06 <Fragsworth> ah, ok
00:06:21 <dancor> its primary use is reducing number of parens
00:07:02 <dons> you can use rewrite rules
00:07:05 <copumpkin> @src ($)
00:07:05 <lambdabot> f $ x = f x
00:07:07 <dons> just fyi
00:07:37 <dons> rewrite rules == haskell's monkey patching
00:08:21 <dancor> yikes, i hadn't seen those before.  http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
00:08:28 <dons> oh.
00:08:52 <Fragsworth> This is GHC-specific right?
00:08:54 <dons> you can also implement type classes with them, http://donsbot.wordpress.com/2008/05/12/type-classes-in-the-time-of-recession/
00:08:57 <Fragsworth> Not part of Haskell?
00:09:08 <dons> Fragsworth: yes, and not for monkey patching tasks, more aimed at optimizations
00:09:18 <dancor> ghc-only
00:10:03 <dons> use the f $ g approach for "decoration" -- aka composition
00:13:52 <Gracenotes> {#- RULES
00:13:57 <Gracenotes> "freedom/slavery" forall b x y. if b then x else y = if b then y else x
00:14:02 <Gracenotes> "ignorance/strength" not = id
00:14:04 <Gracenotes> #-}
00:14:29 <Gracenotes> now we just need a war/peace, of course
00:14:31 <allbery_b> haskell'84?
00:15:28 <Gracenotes> perhaps sum = product
00:17:10 <c_wraith> Ah-ha.  Figured out how to implement Lift for my type.  yay!
00:17:14 <dancor> sumtimes it does
00:17:15 <allbery_b> wouldn't war/peace be IO / Identity?
00:18:06 <Gracenotes> unless you can convince the typechecker that readLine is Identity String :/ and it is expression-level, not type-level
00:18:48 <allbery_b> there's a wrapper for something like that on hackage already, no?
00:18:54 <Gracenotes> dancor: sounds 2 good 2 be true
00:19:12 <dancor> it has a familiar Ring 2 it
00:19:32 <copumpkin> more like a semiring to it
00:20:50 <dancor> negative
00:54:42 <periodic> Huh, so using Arbitrary to generate a random program doesn't work very well because everything is so recursive. :(
00:55:10 <opqdonut> hehe
00:56:05 <periodic> I wanted to generate random program-like gibberish to test a lexer/parser.  The programs seem to either be < 100 characters or > 1,000,000 characters
00:56:55 <shambler> pretty random lol
01:05:13 <Exteris> what does this mean? Occurs check: cannot construct the infinite type a = [a] when generalizing the types for `intersperse' (i'm doing the rwh book)
01:05:54 <ibid> it means what it says
01:06:00 <Saizan_> Exteris: it means that you use some expression in your code as both a list and an element to that list
01:06:06 <Saizan_> s/to/of/
01:06:17 <ibid> ah, Saizan_'s explanation is way better than mine :)
01:06:56 <Exteris> can i do (list:list2) to split [[a]] to [a]'s ?
01:07:35 <Saizan_> if you do that you get (list :: [a]) and (list2 :: [[a]]) if the whole thing is [[a]]
01:08:03 <Saizan_> so list is the first list, and list2 is the list of the other lists
01:08:06 <Exteris> yeah
01:08:22 <Exteris> well that's what it's supposed to do in my opinion, so that cant be the problem
01:08:28 <Exteris> could you take a look at my code? i'll upload it
01:08:29 <Exteris> in a sec
01:08:34 <Saizan_> @hpaste
01:08:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
01:11:43 <Exteris> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10878
01:12:17 <ivanm> @tell dons love your liberty vs type safety quote on your blog
01:12:17 <lambdabot> Consider it noted.
01:12:19 <Saizan_> well, the else branch is the problem
01:12:36 <Saizan_> as we said above, (list2 :: [[a]])
01:12:37 <Exteris> lol found it
01:12:41 <Exteris> i think
01:12:52 <Exteris> in the then branch
01:13:24 <Exteris> can i just use flatten or something?
01:13:24 <Saizan_> the then looks ok, actually
01:13:38 <Exteris> though probably not at all efficient
01:14:04 <Saizan_> intersperse is supposed to return a list of elements of the same type as the separator, no?
01:14:10 <Saizan_> not a list of lists
01:14:20 <Exteris> yeah
01:14:25 <Exteris> that's why the else branch is wrong
01:14:29 <Exteris> right?
01:14:31 <Saizan_> yeah
01:14:56 <Saizan_> list2 :: [[a]] and you're trying to use it as a value of type [a]
01:15:02 <Saizan_> those don't match.
01:15:48 <Exteris> okay, i get the problem
01:15:58 <Exteris> i just cant easily find a solution :p
01:16:04 <Saizan_> the typechecker tries to find a solution for the equation [[a]] = [a], so it decomoses the external [], and gets [a] = a, which raises the occurs check error
01:16:18 <Exteris> ah
01:16:44 <Saizan_> well, in the else branch you know that list2 is either the empty list, or a singleton list, right?
01:16:58 <Exteris> LOL
01:17:10 <Saizan_> ah, no, you've >= 1
01:17:17 <c_wraith> :t mapM
01:17:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:17:22 <Saizan_> so list2 must be the empty list
01:17:29 <Exteris> exactly
01:17:37 <Exteris> thats what was so stupid
01:17:50 <Exteris> i need to be doing something with the first list
01:17:57 <Saizan_> yeah
01:18:09 <Exteris> replacing list2 with list fixed the entire thing
01:18:15 <Saizan_> good
01:18:21 <Exteris> i do not need the last line, do i?
01:18:27 <Saizan_> though that's not a very good way to implement that function
01:18:49 <Saizan_> you need it, otherwise your function will crash if given the empty list as second argument
01:19:15 <Exteris> what would be a better way to implement this then?
01:19:27 <Saizan_> using pattern matching instead of length and if
01:19:47 <Saizan_> you're using length to know something about the structure of the list
01:20:11 <Saizan_> you can do the same with pattern matching, and since you don't really need the length, it's also more efficient
01:20:40 <Saizan_> length takes linear time in the size of the list, because it has to traverse all of it
01:21:30 <Exteris> lol
01:21:32 <Exteris> fixed it
01:21:49 <Saizan_> how does it look now?:)
01:21:50 <Exteris> and it's better to read too
01:21:54 <Saizan_> yeah
01:22:54 <Exteris> blergh moonpatio is slow
01:22:58 <Exteris> only one line has changed
01:23:56 <Exteris> intersperse separator (list:list2) = list ++ (separator:(intersperse separator list2))
01:24:00 <Exteris> THE REST IS THE SAME
01:24:04 <Exteris> lol oops
01:24:09 <Exteris> sorry
01:25:55 <Exteris> lol
01:26:04 <Exteris> i did make an error somewhere
01:27:12 <Saizan_> well, you have to make a different case for when list2 is empty
01:27:28 <Exteris> yeah, that
01:27:37 <Saizan_> and it has to be above that one, because they overlap.
01:28:55 <Saizan_> (you can use another pastebin if you prefer, btw=
01:29:14 <Exteris> well it seems like my own internet is the problem
01:29:22 <Exteris> because hoogle is extremely slow as well
01:29:28 <Saizan_> i'd write intersperse as tree different cases, btw
01:29:37 <Saizan_> interperse sep [] = ..
01:29:48 <Saizan_> interperse sep [lastline] = ..
01:30:07 <Saizan_> intersperse sep (list:lists) = ..
01:30:44 <Saizan_> except for typos :)
01:30:44 <mornfall> I'd import Data.List( intersperse ) myself... : - P
01:30:44 <Saizan_> and lastline should have been lastlist
01:30:55 <Saizan_> mornfall: well, it's quite clear that this is an exercise :)
01:31:20 <mornfall> :)
01:31:28 * ksf suggests changing the topic to "We're kind to newbies, but you _will_ get your brain asploded"
01:32:03 <Exteris> hehe yeah i was expecting that when i started
01:32:09 <Saizan_> [x] matches only a singleton list, btw
01:32:22 <Saizan_> if that wasn't clear :)
01:32:46 <Exteris> it was, but i wasnt aware you could use it that way
01:32:52 <Exteris> but thats actually pretty logical
01:33:01 <c_wraith> :t forM
01:33:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
01:33:06 <ksf> it's sugar for (x:[])
01:33:22 <ksf> ...which, in contrast to (x:xs), matches two constructors.
01:33:41 <Saizan_> yeah, the interesting thing is that you can arbitrarily nest patterns
01:34:03 <ksf> [x,y] == (x:y:[])
01:34:18 <Saizan_> and : associates to the right
01:34:30 <ksf> useful in things like main = do [foo, bar] <- getArgs
01:34:47 <FunctorSalad> I think the confusing part for newcomers about [x] is more that it looks analogous to the type-level [foo] :)
01:35:07 <Saizan_> yeah, that's often the case
01:35:56 <ksf> there's agda-fanboys arguing that having non-unified type and constructor namespaces is a bad idea.
01:36:10 <ksf> (which might be because in agda there's no choice about it)
01:36:42 <FunctorSalad> I think they shouldn't be unified in Haskell... less arbitrary choices to make
01:37:02 <FunctorSalad> because (data Foo = Foo .... ) is the canonical choice for 1-constructor types
01:37:32 <FunctorSalad> and Build_Foo is a bit lengthy
01:37:50 <ksf> they use MkFoo over there
01:37:53 <dolio> Namespacing isn't the issue.
01:38:09 <dolio> It's when you have constructs on both the value and type levels.
01:38:22 <dolio> For instance, ML has type tuples that aren't the same as product types.
01:38:45 <ksf> I guess I was never confused about it because I knew about the curry-howard iso.
01:38:59 <ksf> ...and knew that -> means "implies"
01:39:04 <dolio> So it can't use (a,b) as the type of products of a and b, because they need to use it for the pair of types a and b.
01:39:37 <ksf> in fact, I think every explanation of the haskell type system should include a brief description of curry-howard
01:39:46 <xide> i need 9 ppl to register at this link, that's kinda of a promotion in the russian facebook) sum1 do me a favour, spend 2 minutes of ur life and follow this link http://vk.com/reg480180
01:40:02 <c_wraith> is there any way to tell cabal to execute multiple targets?
01:40:43 <dolio> Of course, you can get away with a lot less of that in Haskell because types aren't absolutely first-order.
01:40:52 <ksf> cabal-install does some automation there.
01:41:08 <dolio> You can write 'Either a b' instead of '(a,b) sum' in ML.
01:41:11 <Saizan_> xide: this channel is not for announcements, if you don't have an interest in haskell, please leave.
01:41:12 <ksf> e.g. you can configure it to do both install and haddock.
01:41:19 <FunctorSalad> what have constructor-names to do with curry-howard?
01:41:36 <FunctorSalad> (is that legal albeit nonstandard english btw?)
01:41:42 <Saizan_> c_wraith: what do you mean exactly?
01:41:52 <c_wraith> I just want to be able to do clean, configure, build in one command
01:41:52 <ksf> it's about cofusing [a] with [x]
01:42:04 <ksf> ...that is, confusing the type with the value level.
01:42:14 <ksf> ...which isn't surprising, as they're iso.
01:42:17 <Saizan_> c_wraith: ah, no
01:42:23 <c_wraith> I guess I can write a script that does those, but that doesn't get possible savings from skipping the overhead of multiple starts
01:42:40 <ksf> separate namespaces help to keep the concepts apart.
01:42:40 <Twey> FunctorSalad: Quite legal, and not at all non-standard, though there shouldn't generally be a hyphen between â€˜constructor namesâ€™ (it's not a recognised compound [AFAIK] and the parse order is not confusing)
01:42:47 <Saizan_> you can install --inplace though
01:43:31 <FunctorSalad> Twey: yeah, I didn't mean the hyphen, but the contrast to "what do constructor names have to do ..."
01:43:49 <ksf> only use hypens when you actually want to write constructornames, one day.
01:43:58 <ksf> hypenisation is a pre-curser to gluing, in english.
01:44:05 <c_wraith> Hm.  I didn't know about that option.  that sounds handy.  gets me configure and build in one step.
01:44:10 <FunctorSalad> the hyphen was an accident
01:44:29 <dolio> But, if you had nice syntax for type lists you'd have the same issue. Is [a] the type of lists of a, or the singleton list of the type a? But Haskell doesn't have that problem either, because the best you can do is "a ::: Nil".
01:44:41 <Twey> Yes, entirely legal.  â€˜Doâ€™ as an auxiliary verb for questions didn't arise until relatively recently, and the old form of asking questions simply by fronting the question word is still valid, though generally considered poetic in most cases.
01:44:47 <benl23> "It's not just you! http://haskell.org looks down from here."
01:45:04 <ksf> FunctorSalad, at least you didn't write "what have constructor names with curry-howard to do"
01:45:47 <Twey> Hehe
01:46:07 <FunctorSalad> Twey: *nod* it does sound "old" somehow
01:46:17 * ksf thinks it's hard to say it in a different way without using phrases like "what's the relationship" or something like that
01:46:30 <Twey> FunctorSalad: â€˜Doâ€™ used to be used for commands.  â˜º
01:46:39 <Twey> Do you study Middle English!
01:46:47 <FunctorSalad> hehe
01:46:50 <medfly> No!
01:47:32 <ksf> you can't have "do constructor names..." without using "something" or "anything" or such
01:49:00 <Twey> You can say â€˜What do constructor names have to do with Curry-Howard?â€™
01:49:03 <Twey> That's fine too.
01:49:22 <ksf> yep.
01:49:23 <maltem> It's funny when English natives find Shakespearean English hard to read at times, where the "old" word order is used, where it's totally natural to read to a German (or Dutch or Swedish or ...) person
01:49:43 <Twey> maltem: I much prefer itâ€¦ it makes so much more sense.
01:49:55 <ksf> but, you see, german is kinda particular when it comes to optimizing sentences to their shortest possible length.
01:50:05 <Twey> ksf: No way!
01:50:12 <ksf> ...without that, we could'nt possibly make such long ones.
01:50:25 <Twey> German doesn't cut corners with grammar like English does.
01:50:33 <Twey> Or, well, not so much at least.
01:50:40 <maltem> Twey, and it gets awkward when Shakespeare takes the opposite to the extreme (a zillion times "doth")
01:50:41 <ksf> it's got an awful lot of tricks to shorten stuff.
01:51:06 <Twey> maltem: Haha
01:51:11 <maltem> German isn't particularly good at short sentences though ;)
01:51:48 <ksf> that's because we use commas where english uses periods, and periods where english uses paragraph breaks.
01:52:46 <maltem> heh. A German teacher once wrote in the margin of a class test of mine, "This sentence could have done with an additional full stop."
01:53:35 <Twey> Hahaha.
01:53:41 <Twey> ksf: Ack!
01:54:04 <Saizan_> ksf: and paragraph breaks where ..?
01:54:25 <ksf> sections. sometimes chapters.
01:54:33 <FunctorSalad> there are no paragraph breaks on the internet.
01:54:35 <FunctorSalad> ;)
01:54:42 <FunctorSalad> WALL OF TEXT
01:54:50 <Saizan_> hehe
01:55:25 * maltem takes a copy of the Critique of Pure Reason off the shelf just to enjoy
01:55:27 <Saizan> the odd one is english in this context, btw
01:55:34 <ksf> It's not as common in dialect or everyday language, though.
01:55:49 <ivanm> Saizan: sure, blame English...
01:55:58 <ksf> I guess that's because german was designed by people who were kinda predisposed for long sentences.
01:56:00 <ivanm> the fact that as a language it's absolute garbage is irrelevant! :p
01:56:07 <ksf> i.e. goethe, luther, schiller.
01:56:20 <FunctorSalad> ksf: cause and effect?
01:56:35 <ksf> low saxon more or less reads like simple english, but doesn't sound stupid doing so.
01:56:37 <ivanm> or did they write long sentences because that's how german was? :p
01:57:00 <ksf> dunno, I don't live around weinmar.
01:57:09 <Saizan> italian prose have much longer periods than english, too
01:59:12 <medfly> not sounding stupid is the most important language trait of all
02:00:58 <ksf> hm reading through http://nds.wikipedia.org/wiki/Plattd%C3%BC%C3%BCtsch , it seems to be that low saxon is being enriched with a formal style, after all.
02:01:50 <ksf> it's hard to fit formality into a language that calls a baby (or any child, if a parent wants to express "I love you, even though...") a bundle of shit.
02:03:42 <FunctorSalad> awww
02:03:54 <Saizan> @remember ksf [on low saxon] it's hard to fit formality into a language that calls a baby (or any child, if a parent wants to express "I love you,  even though...") a bundle of shit.
02:03:54 <lambdabot> Done.
02:04:47 <SmurfOR> I'm trying to pass a function to another function so I can grab a field from a data type inside the function but I'm getting a funny type error. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4424#a4424
02:05:27 <maltem> ksf, what word is that? Not Hosenkacker, apparently, since that's not a bundle of shit?
02:06:32 <ksf> "schietbüddel"
02:06:46 <ksf> the whole phrase is "Lütten Schietbüddel"
02:07:06 <ksf> (lütt == little)
02:07:06 <maltem> heh, didn't know that one yet
02:07:14 <Jafet> German question marks!
02:07:26 <ksf> that's all u umlauts.
02:07:52 <Saizan> SmurfOR: you should apply pred to (from r), not the opposite
02:07:57 <elbar> i smell fishheads ;)
02:08:02 <ksf> quite elegantly translates to "little shitbundle"
02:08:02 <Jafet> dict: No definitions found for "lÃ¼tt"
02:08:22 <Jafet> Wait, that isn't german
02:08:50 <ksf> http://nds.wikipedia.org/wiki/Platt
02:08:57 <SmurfOR> Saizan, have i ever told you how much i love you ;)
02:09:16 <SmurfOR> but how woefully incompetent you make me feel at the same time :P
02:09:18 <Saizan> SmurfOR: not yet :)
02:09:39 <hackagebot> WL500gPControl 0.3.2 - A simple command line tools to control the  Asus WL500gP router (VasylPasternak)
02:09:45 <Saizan> heh, well, we all started somewhere :)
02:35:29 <sohum> @pl \(x,y) -> (x,f y)
02:35:30 <lambdabot> second f
02:37:42 <sohum> @pl \x -> (a+b):x
02:37:43 <lambdabot> (a + b :)
02:37:56 <sohum> oh, doy
02:38:02 <Jafet> :)
02:38:26 <dmwit> "(a + b" makes lambdabot smile
02:41:43 <sohum> heh
02:42:39 <Twey> Hehe.
02:45:39 <sohum> @pl \x -> ((f k):x)
02:45:40 <lambdabot> (f k :)
02:45:46 <sohum> yay less brackets
02:46:59 <dmwit> <schoolmarm type="English">fewer</schoolmarm>
02:52:41 <ksf> http://shootout.alioth.debian.org/u64/benchmark.php?test=knucleotide&lang=all&box=1
02:53:02 <ksf> I say that's nowhere as good as we could do.
02:54:33 <ksf> ...concerning the hashtable thing: why don't we just use a Map HashedKey (Map Key Value) ?
02:55:06 <sohum> @pl \(x,y) -> (f x,g y)
02:55:06 <lambdabot> f *** g
02:56:02 <Jafet> -- Note: Hash tables are not generally used in functional languages, so there are no available library implementations for Haskell. This benchmark requires a hash table. This is why I have implemented the hash table here.
02:56:07 <Jafet> Hrm
02:56:29 <FunctorSalad> :(
02:56:51 <FunctorSalad> seems a bit excessive to proscribe a hashtable
02:57:04 <ksf> IntMap HashedKey (Map Key Value) might even be faster than a plain (Map Key Value), considering that we can't use bytestring-trie as it's a lib.
02:57:38 <Jafet> Incremental hashtables are quite in functional style, actually
02:57:55 <ksf> ...and starting of with IntMap.empty is definitely a small default size.
02:57:59 <FunctorSalad> if they force you to be imperative, why not just do it in ST
02:58:17 <ksf> they don't say anything about imperativeness, there.
02:58:45 <FunctorSalad> force you to use a data structure that isn't used in FP much
02:58:47 <Jafet> It only seems to build one big hash table, so the default size shouldn't matter
02:59:13 <ksf> a hashtable is just a multi-stage map.
02:59:55 <FunctorSalad> type Hashtable = Map Key, and hope nobody will notice? ;)
03:00:09 <Jafet> The benchmark will
03:00:58 <ksf> nope type Hashtable (k -> Int) k v = IntMap h (Map k v)
03:01:20 <Peaker> Jafet, what are incremental hash tables?
03:01:30 <ksf> the standard ones.
03:01:36 <ksf> perfect hashes are the other ones.
03:01:42 <ksf> ...or rather, minimal perfect ones.
03:01:47 <Jafet> Haha, first time I've heard them described as "standard"
03:02:04 <Peaker> well, how are they functional style?  The "standard" hash tables need array entry modification for updates
03:02:26 <Jafet> Well, they only need to update a very small number of entries.
03:02:36 <ksf> you don't need arrays to do hashtables.
03:02:59 <maltem> Hash-search-trees!
03:03:02 <Jafet> I've never seen hash tables implemented any other way myself
03:03:22 <ksf> it's actually not even a good idea, while you get O(1) access, you have to seriously limit the range your hash function.
03:03:26 <ksf> collisions ensue.
03:03:41 <c_wraith> In practice, that turns out fine.
03:03:48 <Jafet> I thought the O(1) access is part of the whole point
03:03:48 <maltem> ksf, why, that's the point of a hashtable?
03:04:02 <c_wraith> In practice, few hashtables will hit 20 entries.
03:04:07 <ksf> there's no real point to non-perfect hashing.
03:04:24 <ksf> tries are usually at least as fast, and don't come with as bad worst-case bounds.
03:04:33 <dmwit> ?index equating
03:04:33 <lambdabot> bzzt
03:04:40 <dmwit> :t Data.Function.equating
03:04:41 <lambdabot> Not in scope: `Data.Function.equating'
03:04:45 <dolio> @type on (==)
03:05:06 <ksf> see hash tables aren't O(1), they're O(k + collisions)
03:05:06 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
03:05:06 <FunctorSalad> :o
03:05:06 <Jafet> ksf, depends on the storage media and input type, mind you
03:05:06 <Peaker> I see huge hash tables all the time. By wasting more space, you get less collisions.. these are not functional-style
03:05:15 <dmwit> :t Data.Eq.equating -- ?
03:05:16 <lambdabot> Not in scope: `Data.Eq.equating'
03:05:20 <dmwit> ah well
03:05:28 <maltem> Hashtables vs. search trees is a really old debate
03:05:50 <ksf> you always have to hash, which is at least O(log k), usually O(k) with a relatively high constant factor. and if your hash function isn't perfect, you have to resolve collisions.
03:05:53 <Jafet> There are no new debates
03:05:57 <ivanm> maltem: and you're sick of it? ;-)
03:06:09 <ksf> heck you even get vulnerable to dos attacks that way if your hash isn't cryptographic.
03:06:10 <ivanm> Jafet: just re-labellings of old ones?
03:06:36 <c_wraith> anyway, my real point is that any benchmark that is so low-level that it depends on having a hash table available isn't a good benchmark.
03:06:37 <Jafet> I bet vi vs teco was a real big one in the old days.
03:06:39 <FunctorSalad> maybe we can just ask them to allow trees and tries too
03:06:50 <maltem> ivanm: Not that much, no. But isn't that exciting either ;)
03:06:59 <Jafet> c_wraith, no benchmark is a good benchmark
03:07:01 <FunctorSalad> we must get ahead of ocaml and scala again.
03:07:03 <FunctorSalad> ;)
03:07:03 <ksf> I'd say we just go with the hashes but use maps nontheless.
03:07:07 <Saizan> afaiu, hash tables are a win when their compact representation gives enough cache locality
03:07:14 <ksf> it's going to be hard for them to say that we must use arrays.
03:07:16 <Saizan> which you're less likely to get with trees
03:07:33 <Jafet> ksf, but can you beat them with tries?
03:07:50 <FunctorSalad> hehehe
03:08:20 <ksf> that's the fun part. the vanilla generic map is quite slow on strings (and in general), so a fast hash function and IntMap could at least in theory be faster.
03:08:26 <Saizan> ksf: that's a good point
03:08:36 <ksf> ...and we can't use goodies like bytestring-trie, as they're not a standard lib.
03:09:16 <Saizan> is it too large to copy/paste in the benchmark entry?:)
03:09:37 <ksf> and we can minimize collisions quite effectively as IntMap works just fine with sparse indices
03:09:39 <Jafet> I assume the input for that shootout is going to be fairly random, so poor hashing might beat a good tree
03:10:37 <FunctorSalad> we could use some of the ancient bytestring variants used in ghc...
03:10:43 <FunctorSalad> :)
03:10:48 <FunctorSalad> if we can't use libs
03:10:57 <ksf> well see but we _have_ to use hashing.
03:11:09 <ksf> and we've got a trie if we use IntMap
03:12:05 <ksf> mhhh wait how many keys do we have to hash?
03:12:17 <ksf> if it's less than maxint, we could even use a perfect hash.
03:12:17 <sohum> is there a way to not import, say, the show instance for Word16 and provide my own?
03:12:41 <dmwit> sohum: No, instances are universal.
03:12:43 <ksf> you can't override instances afaik
03:12:53 <ksf> do a newtype.
03:12:56 <dmwit> sohum: So use a different function than show for whatever it is you want.
03:13:25 <ksf> you can derive the rest of the instances, so it's not much pain.
03:13:42 <dmwit> sohum: (Anyway, "show" should be reserved for showing in such a way that is both "reads"able and can be dropped straight into Haskell source.)
03:13:47 <FunctorSalad> ksf: 'count all the 3- 4- 6- 12- and 18-nucleotide sequences'
03:13:49 <Jafet> ksf, input file is 100 CGATs
03:13:52 <Jafet> Er, 100k
03:14:20 <maltem> Say, why would an STArray with a hash function not be the way to go? (I missed the origin of the discussion)
03:14:33 <dmwit> > 4^18 :: Integer < fromIntegral (maxBound :: Int)
03:14:34 <lambdabot>   <no location info>: parse error on input `Int'
03:14:39 <hcube> Hi! I'm curious how many people are interested in computer graphics/frp based games here.
03:14:41 <sohum> dmwit: right, thanks
03:14:44 <FunctorSalad> > 4 ^ 18
03:14:45 <lambdabot>   68719476736
03:14:47 <dmwit> > (4^18 :: Integer) < fromIntegral (maxBound :: Int)
03:14:47 <ksf> > 18^4
03:14:48 <lambdabot>   True
03:14:48 <lambdabot>   104976
03:15:06 <ksf> > logBase 2 (4^18)
03:15:07 <lambdabot>   36.0
03:15:18 <FunctorSalad> ;)
03:15:26 <Jafet> That's surely overcompensating
03:15:43 <FunctorSalad> ?
03:15:44 <dmwit> hcube: I guess not that many, considering there's only one real frp-based game...
03:15:48 <Saizan> maltem: bad interaction with the GC
03:15:52 <ksf> we have to do 32bit, too, don't we?
03:15:53 <dmwit> hcube: Though there are definitely frp buffs hanging around.
03:16:03 <ksf> hcube, count me in.
03:16:24 <maltem> Saizan, because of the "grow the hashtable from a small default size" part?
03:16:44 <ksf> reactive isn't usable for games yet by a quite large margin, though.
03:16:47 <Saizan> maltem: not really
03:17:34 <hcube> i asked this because i'll release an initial version of my haskell rendering engine soon.
03:17:37 <ksf> e.g. I get about 100fps at 35% cpu with http://www.haskell.org/haskellwiki/Reactive/Tutorial/A_FPS_display , which is abysmal.
03:18:25 <Jafet> Oh whoops, the actual input file is 240 MB
03:18:33 <dmwit> ksf: 100fps rendering what?
03:18:40 <Saizan> maltem: because when an array is modified it gets marked for linear scanning by the GC to tell if some value is not referenced anymore, this becomes a big overhead for large arrays
03:18:43 <ksf> a gl string with the fps.
03:18:53 <dmwit> ksf: ... wow
03:18:55 <dmwit> =(
03:19:20 <Saizan> maltem: the solution is to not use a single mark for each array, but rather mark subblocks, so that you don't have to scan the whole array just for a single update
03:19:26 <hcube> have you tried elerea?
03:19:39 <ksf> not yet
03:19:54 <maltem> Saizan, is this a plain shortcoming of STArray/GHC?
03:19:58 <hcube> it works and it's fast
03:20:09 <Saizan> maltem: though there isn't that much real need for fast large arrays, so ghc devs didn't spend time on it
03:20:15 <maltem> ok
03:20:18 <ksf> ...and I'm kinda suspicious because of unsafe* hackery
03:20:44 <hcube> but unsafe stuff is hidden
03:21:30 <hcube> i use elerea for my examoles
03:21:33 <Saizan> maltem: dons made a ffi binding for judy arrays recently, as an alternative if this behaviour bites you
03:21:43 <hcube> *examples
03:22:03 <ksf> heck I should stop not trusting haskell libs that don't come with a paper, I don't demand papers in the c world, either...
03:22:41 <maltem> Saizan, wait, from a web search I'm suggested that this isn't a problem for STUArrays?
03:22:44 <Jafet> ...but do you trust C libs?
03:23:01 <ksf> not as far as I can throw gdb
03:23:23 <Saizan> maltem: no, unboxed arrays don't have this problem because they don't contain references
03:23:44 <ksf> there's a difference between non-total functions and functions that segfault for unknown inputs.
03:24:00 <Saizan> ..so i guess they'd be perfect for an hashtable
03:24:32 <Saizan> well, it depends on what are your values
03:24:44 <maltem> There you go :)
03:25:17 <ksf> but heck perfect hashing all those 4^18 values _is_ a good idea. we can generate a perfect hash function with output inside a 64-bit int with some lib and then use IntMap
03:25:18 * maltem wanders off to shower
03:25:25 <Saizan> what do we need to store in the hash table for this benchmark?:)
03:25:41 <ksf> "strings"
03:25:48 <hcube> who is good in computer graphics here?
03:25:53 <Jafet> A few hundred million twisty little strings, all alike
03:26:21 <ksf> it's a 4 element alphabet as far as I see, and the length is up to 18
03:26:26 <Saizan> do we have a bound on their size?
03:26:43 <Jafet> The size is fixed
03:26:58 <ksf> the lower ones should be perfectly hashable to 32 bit.
03:27:13 <Jafet> Suddenly I have the unclean thought of a bloom table in haskell
03:27:37 <Saizan> there's bloom filters on hackage already :)
03:27:45 <ksf> ...and we can use IntMap hibytes (IntMap lobytes v) on 32bit, anyway.
03:28:03 <Jafet> A bloom table would work well for this benchmark, since it doesn't ask for exact numbers
03:28:56 <Saizan> i think we could make a Storable instance for these "strings" and use an unboxed array
03:30:03 <Saizan> but the IntMap way would be cooler :)
03:30:50 <Saizan> "we can beat your mutable arrays with a tree."
03:31:01 <Saizan> an immutable tree, even
03:32:21 <Jafet> "We pwnt you lol" "But you're disqualified lol"
03:34:02 <FunctorSalad> Saizan: (on STArray) why would GC have to rescan the whole thing? it knows which cells were modified
03:34:18 <Saizan> FunctorSalad: does it?
03:34:23 <FunctorSalad> I thought
03:34:36 <FunctorSalad> it can only be modified with writeSTArray I thought
03:35:03 <Saizan> yes, but that's the point, that information isn't stored at that granularity
03:35:04 <FunctorSalad> I could be 'rong
03:35:09 <FunctorSalad> ah
03:35:19 <Saizan> you only have "whole array" granularity :)
03:35:53 <FunctorSalad> so it's no fundamental problem? you'd just have to remember the writings?
03:35:55 <Saizan> you probably want chunks
03:36:04 <Saizan> yeah
03:36:52 <sohum> @pl \[x,y] -> y
03:36:53 <lambdabot> (line 1, column 2):
03:36:53 <lambdabot> unexpected "["
03:36:53 <lambdabot> expecting pattern
03:37:13 <sohum> @pl \[x:y:z] -> y
03:37:14 <lambdabot> (line 1, column 2):
03:37:14 <lambdabot> unexpected "["
03:37:14 <lambdabot> expecting pattern
03:37:44 <Jafet> @pl \(x:(y:z)) -> y
03:37:44 <lambdabot> head . tail
03:37:56 <dmwit> ?pl \(x, y) -> (min x y, max x y)
03:37:57 <lambdabot> uncurry (ap (ap . ((,) .) . min) max)
03:39:58 <sohum> Jafet: thanks
03:40:02 <c_wraith> :t uncurry min &&& uncurry max
03:40:03 <lambdabot> forall a. (Ord a) => (a, a) -> (a, a)
03:40:03 <Saizan> tbc, it's already the case that the array won't be scanned unless there has been a writeArray
03:40:32 <Jafet> @ty \x:y:z -> y
03:40:33 <lambdabot> parse error on input `:'
03:40:38 <Jafet> @ty \(x:y:z) -> y
03:40:39 <lambdabot> forall t. [t] -> t
03:41:12 <dmwit> ?pl \uncurry -> uncurry min &&& uncurry max
03:41:12 <lambdabot> liftM2 (&&&) ($ min) ($ max)
03:42:56 <dmwit> > (length "f (x, y) = (min x y, max x y)", length "f = uncurry min &&& uncurry max", length "f = liftM2 (&&&) ($ min) ($ max) uncurry")
03:42:57 <lambdabot>   (29,31,40)
03:47:45 <EvilTerran> > length "f = on (&&&) uncurry min max"
03:47:46 <lambdabot>   28
03:48:03 <dmwit> shortest one yet
03:48:05 <EvilTerran> :D
03:48:47 <dmwit> ...but it would be really spiteful to use that in any real code.
03:50:12 <Saizan> nah
03:51:54 <dmwit> "These flags are: ... 'Ignore flag' (value: 0x8000) If on, all other flags should be ignored"
03:51:56 <dmwit> WTF
03:51:59 <dmwit> This spec is whacked out.
03:52:02 <Saizan> not more than the liftM2 one at least :)
03:53:13 <Berengal> Could we steal clojure's vectors?
03:53:19 <Berengal> Has someone done so already?
03:54:10 <shambler> but why?
03:54:19 <Saizan> dmwit: because checking if the field is equal to zero was too hard?
03:54:48 <dmwit> Saizan: apparently
03:55:15 <Berengal> shambler, they're immutable, but providest fast append
03:55:19 <dmwit> It's a little bizarre.
03:55:54 <Berengal> Meaning we could have array code that doesn't rely on ST
03:55:57 <dmwit> I'm torn between representing it the way it is in the file and cleaning it up so that there's no ignore flag, and if you read that flag it just empties the other flags.
03:56:12 <dolio> > foldl (|>) empty [1..1000000]
03:56:14 <lambdabot>   Not in scope: `|>'Ambiguous occurrence `empty'
03:56:14 <lambdabot>  It could refer to either `C...
03:56:58 <Saizan> Berengal: benchmark against Data.Sequence first :)
03:57:39 <Berengal> Saizan, indeed. I think they're pretty similar, actually
03:58:09 <Berengal> But clojure's vectors have a higher fanout
03:59:00 <Berengal> I'll have to take a look at it's code, methinks
04:04:35 <en0th> is this haskell spaghetti code? http://hackage.haskell.org/packages/archive/dsp/0.2.1/doc/html/src/Matrix-Simplex.html#Simplex
04:05:54 <dmwit> yawp
04:06:16 <Berengal> sometimes, single-letter variables just don't cut it anymore, even in haskell
04:07:03 <dmwit> "This module wastes inodes"?
04:07:04 <en0th> i'll try to re-look at it after lunch, hehe
04:07:09 <dmwit> It doesn't do any file I/O!
04:07:43 <Exteris> how can i take a list and get a list of all succesive triples (eg [1,2,3,4] -> [[1,2,3],[2,3,4]]
04:07:50 <ben_m> addart scares me
04:07:53 <en0th> lol i guess he means "installing it you waste.."
04:08:07 <dmwit> en0th: oh, heh
04:08:22 <dmwit> > map take 3 . tails $ [1..4]
04:08:23 <lambdabot>   Couldn't match expected type `a -> b'
04:08:23 <lambdabot>         against inferred type `[[a1] ...
04:08:30 <dmwit> > map (take 3) . tails $ [1..4]
04:08:31 <lambdabot>   [[1,2,3],[2,3,4],[3,4],[4],[]]
04:08:51 <Exteris> almost :p
04:08:59 <dmwit> You should be able to finish it from there.
04:09:04 <Exteris> yeah
04:09:07 <dmwit> I was just showing the idea.
04:09:07 <Exteris> i'l try
04:09:59 <dmwit> > let f xs = zipWith const (map (take 3) . tails $ xs) (drop 2 xs) in f [1..4]
04:10:00 <lambdabot>   [[1,2,3],[2,3,4]]
04:10:14 <dmwit> > let f xs = zipWith const (map (take 3) . tails $ xs) (drop 2 xs) in f [1..]
04:10:15 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
04:10:25 <Exteris> awesome
04:10:57 <Berengal> Man, arrows are a bit too much fun
04:11:30 <dmwit> Exteris: Hm, I hope I didn't just solve a homework problem.
04:11:48 <Exteris> i'm just trying to learn haskell
04:11:53 <eflister> @djinn m (Maybe (Either a b)) -> (a -> m b) -> m (Maybe (Either b b))
04:11:54 <lambdabot> -- f cannot be realized.
04:11:55 <Berengal> dmwit, don't worry. Homework problems all have folds ;)
04:12:00 <Exteris> it's not homework or anything
04:12:05 <dmwit> Berengal: heh =)
04:12:18 <dmwit> Exteris: Okay, great. =D
04:12:54 <Exteris> it's just nice to be able to come in here and get help whenever i cant figure it out myself
04:12:58 <Exteris> though i probably should try harder :p
04:13:03 <eflister> hrm, can anyone help me understand why my function can't be realized?
04:13:10 <dmwit> eflister: You need a Monad constraint.
04:13:20 <eflister> what's that?
04:13:31 <eflister> i know that m is IO in the case i care about...
04:13:37 <dmwit> @djinn Monad m => m (Maybe (Either a b)) -> (a -> m b) -> m (Maybe (Either b b))
04:13:37 <lambdabot> -- f cannot be realized.
04:14:10 <dmwit> huh
04:14:14 <dmwit> djinn seems wrong here
04:14:23 <eflister> i am sure that it should work with some combinations of left and Traversable.mapM
04:14:27 <FunctorSalad> @djinn Monad m => a -> m a
04:14:27 <lambdabot> f = return
04:14:38 <dolio> @djinn Monad m => b -> m b
04:14:38 <lambdabot> -- f cannot be realized.
04:14:54 <eflister> whoa
04:15:03 <eflister> what's up with that?
04:15:10 <FunctorSalad> alphaequivalence fail
04:15:32 <dmwit> eflister: Anyway, your function is definitely realizable.
04:15:34 <FunctorSalad> :)
04:15:35 <Saizan> dmwit: djinn simply doesn't know about monads
04:15:40 <dmwit> Saizan: Not true!
04:15:41 <dolio> Contexts in djinn are implemented by adding monomorphic parameters to the start.
04:16:00 <Saizan> well, it doesn't know how to work with constructor classes :)
04:16:01 <Athas> Is there a standard module that defines Applicative and Alternative instances for the Parsec Parser type?
04:16:04 <dolio> To correctly model the Monad m context, you'd need higher-rank polymorphism.
04:16:26 <dmwit> Athas: Yes, parsec-3
04:16:32 <eflister> @djinn Monad m => m (Maybe (Either b a)) -> (b -> m a) -> m (Maybe (Either a a))
04:16:32 <lambdabot> -- f cannot be realized.
04:16:43 <dolio> And djinn doesn't do higher-rank polymorphism.
04:16:48 <Exteris> can i drop items from the end of the list?
04:17:14 <dmwit> > init [1..4]
04:17:14 <lambdabot>   [1,2,3]
04:17:25 <Exteris> but if i want to drop the 3 last ones
04:17:27 <FunctorSalad> @typ take
04:17:28 <lambdabot> forall a. Int -> [a] -> [a]
04:17:34 <eflister> dmwit: any chance you can help me realize it?  :)
04:17:36 <Athas> dmwit: thanks, I wonder what version I have...
04:17:50 <dmwit> > reverse . drop 3 . reverse $ [1..4]
04:17:51 <lambdabot>   [1]
04:17:58 <dmwit> eflister: well...
04:18:06 <Saizan> > let dropEnd n xs = zipWith const xs (drop n xs) in dropEnd 3 [1..5]
04:18:07 <lambdabot>   [1,2]
04:18:20 <Saizan> it's O(n) though
04:18:30 <Exteris> dmwit: what is better, calling init 3 times or doing 2 reverses?
04:18:59 <dmwit> :t \mmeab f -> do { meab <- mmeab; case meab of { Just (Left a) -> fmap (Just . Left) (f a); x -> return x } }
04:18:59 <lambdabot> forall (m :: * -> *) a b. (Monad m, Functor m) => m (Maybe (Either a b)) -> (a -> m a) -> m (Maybe (Either a b))
04:19:21 <dmwit> urgh
04:19:51 <dmwit> :t \mmeab f -> do { meab <- mmeab; case meab of { Just (Left a) -> liftM (Just . Left) (f a); Just (Right b) -> return (Just (Right b)); Nothing -> return Nothing } }
04:19:52 <lambdabot> forall (m :: * -> *) t b a. (Monad m) => m (Maybe (Either t b)) -> (t -> m a) -> m (Maybe (Either a b))
04:19:56 <FunctorSalad> Exteris: if you cared about speed, you wouldn't use a list for this ;)
04:20:17 <dmwit> Athas: ghc-pkg list parsec # this command will tell you what version you have
04:20:32 <eflister> dmwit: this is a problem that i've been trying to solve for a while -- i have a solution that cases out the either (i think like you just did) -- but i've been wanting to find a way to let the monads do the work :)
04:20:55 <dmwit> eflister: You can't let the monads do the work here.
04:20:57 <Phyx-> I have 2 questions I was hoping someone could answer. http://phyx.pastebin.com/d4ef3ccd small piece of code and questions in them (mostly about type classes)
04:21:07 <Exteris> FunctorSalad: you're right i dont really care about speed ;P
04:21:17 <dmwit> eflister: You could maybe restructure into a MaybeT/EitherT stack, but that would involve significant changes to the surrounding code as well.
04:21:18 <eflister> dmwit: cuz either isn't a monad?  i was thinking Arrow.left would address that...
04:21:18 <Saizan> my dropEnd is the best of the three alternatives :P
04:21:24 <FunctorSalad> Exteris: Data.Sequence presumably can do it in constant time
04:21:45 <Exteris> nice
04:21:57 <FunctorSalad> drop1 xs = case viewR xs of ys :> y -> ys
04:22:03 <FunctorSalad> @kind Seq
04:22:04 <lambdabot> Not in scope: type constructor or class `Seq'
04:22:08 <FunctorSalad> @kind Data.Sequence.Seq
04:22:09 <lambdabot> * -> *
04:22:56 <FunctorSalad> @ty viewR
04:22:56 <lambdabot> Not in scope: `viewR'
04:22:59 <Saizan> Phyx-: the methods of the Default class are unusable, because they mention only one parameter, so there's no way to pick an instance just by looking at the type you'd use them at
04:23:06 <Athas> dmwit: is it not possible to install parsec-3 via cabal install?
04:23:14 <FunctorSalad> @ty viewr
04:23:16 <lambdabot> Not in scope: `viewr'
04:23:17 <dmwit> Athas: cabal install parsec-3
04:23:21 <dmwit> should do
04:23:21 <FunctorSalad> @ty Data.Sequence.viewR
04:23:22 <lambdabot> Not in scope: `Data.Sequence.viewR'
04:23:23 <FunctorSalad> @ty Data.Sequence.viewr
04:23:24 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.ViewR a
04:23:32 <FunctorSalad> and so on
04:23:40 <Saizan> Phyx-: i.e. instances of Default are indexed by 2 types, but when you use one of the methods there you can only specify one of them
04:23:54 <Athas> dmwit: cabal: There is no available version of parsec that satisfies ==3
04:23:57 <Berengal> Phyx-, also, the "could not deduce..." message deals with two different type variables, most likely because of what Saizan said
04:24:04 <dmwit> Athas: cabal update
04:24:12 <dmwit> Athas: Your hackage list must be way out of date.
04:24:13 <Athas> dmwit: already did that.  Perhaps it doesn't update properly?
04:24:30 <Athas> It downloads from 'http://hackage.haskell.org/packages/archive', is that correct?
04:24:41 <Berengal> Athas, try writing out the entire version number, not just the major version
04:24:48 <dmwit> Oh, right.
04:24:54 <dmwit> parsec-3.0.1
04:25:00 <Athas> Oh, that works.  Thanks.
04:25:08 <dmwit> Berengal++
04:25:37 <Phyx-> Saizan: ah ok I see, so when theres for instance Default Int String and Default Float String for instance it can't differentiate if i understood correctly. makes sense
04:25:38 <Athas> Now I have both parsec 2 and 3 installed, will that cause any trouble?  (I suppose not, if packages indicate the proper version in their .cabal.)
04:25:39 <Saizan> Phyx-: and the instance you specify is Undecidable because you could easily form a loop by writing a similar instance in the other direction, so GHC can't guarantee that instance resolution terminates
04:25:50 <eflister> dmwit: is there an EitherT?  as far as i can tell, either isn't a monad?
04:26:10 <dmwit> There is an EitherT.  Either is a monad.
04:26:18 <dmwit> Either a is a monad, rather.
04:26:18 <eflister> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
04:26:29 <FunctorSalad> isn't it ErrorT?
04:26:34 <Berengal> It's called Error, yeah
04:26:40 <Saizan> Phyx-: yeah, if you use (nDefault :: String) the typechecker only knows that it has to search for an instance of Default a String, it has no way to tell which 'a' you want
04:26:54 <FunctorSalad> newtype ErrorT e m a = ErrorT {runErrorT :: m (Either e a)}
04:27:00 <dmwit> Either a is a monad in the category-theory sense; Error e => Either e is a monad in the Haskell sense.
04:27:03 <Berengal> And has a weird constraint on the left type...
04:27:19 <Phyx-> Saizan: cool, thanks, Think I know how to fix it now
04:28:02 <FunctorSalad> @unmtl StateT s m a
04:28:02 <lambdabot> s -> m (a, s)
04:28:29 <Saizan> Phyx-: in general every method has to list all the type parameter of the typeclass in its type, or a superkey of them if you use functional dependencies
04:28:37 <dmwit> :k RWS
04:28:38 <lambdabot> * -> * -> * -> * -> *
04:28:43 <dmwit> ?unmtl RWS a b c d e
04:28:44 <lambdabot> err: `a -> c -> (d, c, b)' is not a type function.
04:28:46 <dmwit> ?unmtl RWS a b c d
04:28:46 <lambdabot> a -> c -> (d, c, b)
04:28:51 <FunctorSalad> RWS :D
04:28:54 <Saizan> *parameters
04:29:35 <ksf> why, oh why am I running gperf.
04:29:43 <ksf> the hash function is just obvious.
04:30:12 * Berengal feels like posting some random arrow code
04:30:33 <dmwit> ?unmtl RWS h a lloween ppyh
04:30:33 <lambdabot> h -> lloween -> (ppyh, lloween, a)
04:30:38 <ksf> if you've got a two bit alphabet and want to have a perfect hash for all permutations, bleeding use two bits per symbol and it's even minimal.
04:30:50 <Phyx-> Saizan: yeah, I remember reading that a while back, but forgot it along the way :(
04:31:04 <dmwit> aw
04:32:39 <ksf> using that as a hash function is going to invoke the wrath of the shootout guys, I figure.
04:33:58 <Saizan> yeah, what's this clever use of bits?
04:35:02 <Saizan> we couldn't even use the standard unboxed arrays for Bool, because they are bit packed.
04:35:03 <ksf> it's the optimal minimum perfect hash functions for a key set that uses a 4-element alphabet.
04:35:49 <ksf> ...for all permutations, that is.
04:36:22 <FunctorSalad> clever use of bits is banned?
04:36:32 <Baughn> In what sense is that a hash?
04:36:55 <ksf> see, all the keys we can encounter are:
04:37:02 <ksf> > replicateM 2 "GATC"
04:37:02 <lambdabot>   ["GG","GA","GT","GC","AG","AA","AT","AC","TG","TA","TT","TC","CG","CA","CT"...
04:37:12 <ksf> > replicateM 18 "GATC"
04:37:13 <lambdabot>   ["GGGGGGGGGGGGGGGGGG","GGGGGGGGGGGGGGGGGA","GGGGGGGGGGGGGGGGGT","GGGGGGGGGG...
04:37:16 <ksf> ...and so on.
04:37:47 <ksf> using a minimal perfect hash function maps each of those to exactly one bucket
04:38:00 <ksf> (perfect hashes, by definition, don't do collisions)
04:38:38 <ksf> the difference between minimal and non-minnimal being that a minimal one doesn't use more buckets than keys.
04:38:51 <FunctorSalad> @let nuc = let f 'A' = 0; f 'C' = 1; f 'G' = 2; f 'T' = 3 in f
04:38:52 <lambdabot>  Defined.
04:39:10 <ksf> if we wouldn't have to hash all permutations, things would be slightly more interesting
04:39:23 <ksf> (or rather, vastly more interesting)
04:41:07 <Phyx-> :t nuc
04:41:08 <lambdabot> forall t. (Num t) => Char -> t
04:41:17 <FunctorSalad> @let nucl = foldl (\x y -> 4*x + nuc y) 0
04:41:18 <lambdabot>  Defined.
04:41:26 <FunctorSalad> > nucl "CGATTTTA"
04:41:27 <lambdabot>   25596
04:41:30 <ksf> ...they're going to be pissed because IntMap allows for sparse indexing, in contrast to arrays, which is the reason perfect hashing is feasible here.
04:42:18 <dmwit> That's stupid, true hash maps allow for sparse indexing, too.
04:42:44 <ksf> ...the resulting maps, yes, but not the arrays they're usually made of.
04:43:10 <burp> @hoogle Socket
04:43:10 <lambdabot> module Network.Socket
04:43:11 <lambdabot> Network data Socket
04:43:11 <lambdabot> Network.Socket data Socket
04:43:17 <ksf> ...but, we are, after all, hashing, so it's worth a try imo
04:43:34 <FunctorSalad> sort-of ;)
04:46:27 <Athas> In general, how fast is Parsec compared to generators like Happy?  (I realise this is how asking "how fast is a 200hp engine", but still.)
04:46:37 <ksf> fast enough.
04:47:15 <ksf> it's designed not to be slow, that is.
04:47:27 <Baughn> It depends on your grammar. Parsec uses an entirely different approach than happy.
04:47:32 <Athas> Right, I won't need to parse more than a few thousand lines of a simple grammar at a time in my program, so it's not a problem for me.  I'm just curious.
04:47:43 <EvilTerran> the whole point of needing to use "try" is that it allows parsec to be a lot faster
04:48:38 <FunctorSalad> I'd like happy better if it'd be easier to debug o_o
04:52:37 <dmwit> toEnum :: Enum a => Int -> a -- =(
04:52:43 <dcoutts> EvilTerran: a similar design is polyparse where 'try' is the default and if you want performance then you can 'commit', so that backtracking info can be discarded.
04:53:00 <dcoutts> the point is that it's then compositional by default
04:53:04 <ksf> dmwit, direct hatemails to the library mailing list.
04:53:14 <dmwit> ksf: Will it make a difference?
04:53:24 <ksf> maybe.
04:53:40 <ksf> if it fails, try h'.
04:53:44 <dmwit> =)
04:53:51 <dcoutts> dmwit: what's wrong with toEnum?
04:54:02 <dmwit> toEnum :: Enum a => Integer -> a -- =D
04:54:07 <dcoutts> oh heh
04:55:13 <ksf> dcoutts, c2hs generates toEnum. and if you're trying to use 64-bit bitmasks on a 32bit-machine, or 32-bit enums on a haskell impl than only has 30 bit ints, you're... fucked.
04:55:38 <eflister> dmwit: ok, i've read thru the ErrorT docs.  but can you help me understand why the right mix of Traversable.mapM and Arrow.left won't work?
04:56:03 <dmwit> eflister: Oh, there may be some magic with Traversable.
04:56:17 <dmwit> I should really sit down and understand Traversable some day.
04:56:19 <burp> :t printf
04:56:20 <lambdabot> forall r. (PrintfType r) => String -> r
04:58:18 <eflister> dmwit: well, i'm hoping to use it to just get the IO back outside of the Maybe/Either
04:59:09 <eflister> > Control.Monad.liftM (Control.Arrow.left (+ 5)) $ Just $ Left 6
04:59:10 <lambdabot>   Just (Left 11)
04:59:42 <ToRA> is hackage down?
05:00:28 <en0th> i cannot connect to hayoo
05:00:48 <Saizan> yeah, it seems to not work
05:01:03 <eflister> dmwit: that works just like i want -- it's just that in my real situation, the function that goes where (+ 5) is adds an IO, which i want on the outside
05:01:29 <burp> :t printf "%x" 100
05:01:31 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
05:01:44 <en0th> what's the standard to specify character encoding in a text file?
05:02:14 <EvilTerran> eflister, so you're trying to go from, say, Maybe (IO a) to IO (Maybe a)?
05:02:16 <Saizan> there's no way to choose, at least in GHC, you've to use utf8
05:03:10 <burp> > fmap (printf "%x") [1,2,3]
05:03:11 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:03:11 <lambdabot>    `Text.Printf.PrintfType ...
05:03:13 <en0th> i recall a line like #!/bin/sh but with encoding infos..
05:03:39 <Saizan> oh, "text file", i thought about haskell source files
05:03:44 <dmwit> en0th: There is no standard for that.
05:03:53 <burp> printf is mysterious for me
05:03:55 <dmwit> en0th: (X)HTML has a standard for it, though.
05:04:00 <benmachine> printf is a little bit magic
05:04:05 <eflister> EvilTerran: well, i have an IO (Maybe (Either a b)) and an (a -> IO b), and i want an IO (Maybe (Either b b))
05:04:17 <dmwit> > printf "%x" 1
05:04:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:04:18 <lambdabot>    `Text.Printf.PrintfType ...
05:04:20 <benmachine> the PrintfType has instances for functions
05:04:21 <dmwit> > printf "%x" 1 :: String
05:04:22 <lambdabot>   "1"
05:04:30 <en0th> mm ok, thanks :)
05:04:31 <benmachine> it relies very heavily on type inference to work out what to do
05:04:32 <dmwit> > map (printf "%x") [1..3] :: [String]
05:04:33 <lambdabot>   ["1","2","3"]
05:04:45 <dmwit> burp: Does that help? =P
05:04:50 <burp> dmwit: yes ;)
05:04:56 <Saizan> en0th: maybe this http://en.wikipedia.org/wiki/Byte-order_mark
05:04:57 <mmorrow> > printf "%d %d" 42 :: String
05:04:58 <lambdabot>   "42 * Exception: Printf.printf: argument list ended prematurely
05:05:43 <dmwit> Saizan: hum; I guess you know that byte-order isn't the same as encoding
05:05:52 <mmorrow> > $(printf "%d %d" 42)
05:05:53 <lambdabot>   <no location info>: parse error on input `$'
05:05:55 <mmorrow> , $(printf "%d %d" 42)
05:05:56 <lunabot>  luna: Couldn't match expected type `t -> Language.Haskell.TH.Lib.ExpQ'
05:06:04 <mmorrow> er
05:06:09 <mmorrow> , [$ty| printf |]
05:06:12 <lunabot>  String -> ExpQ
05:06:18 <mmorrow> oh right
05:06:26 <mmorrow> , [$ty| $(printf "%d %d") |]
05:06:28 <lunabot>  ()
05:06:33 <mmorrow> :(
05:06:49 <mmorrow> , [$ty| $(printf "%d %d") 42 |]
05:06:51 <lunabot>  ()
05:07:00 <mmorrow> aaaanyways..
05:07:20 <ksf> , $(printf "%d %d") 42
05:07:22 <mmorrow> , $(printf "%d %d") 42 42
05:07:23 <EvilTerran> eflister, i see
05:07:23 <lunabot>  luna: No instance for (GHC.Show.Show (a[a7f5] -> GHC.Base.String))
05:07:24 <lunabot>  "42 42"
05:07:43 <mmorrow> the TH one is safe (in that you won't get a runtime error)
05:07:56 <mmorrow> but the fmt string has to be statically known
05:08:05 <ksf> spj+oleg's funtypefuns paper has a safe printf
05:08:08 <mmorrow> (which 99.9% of the time it is with printf anyways)
05:08:30 <mmorrow> , ppDoc <$> printf "%d %d"
05:08:32 <lunabot>  \x_0 x_1 -> ("" ++ show x_0) ++ ((" " ++ show x_1) ++ ("" ++ [])) :: fora...
05:08:32 <lunabot>                                                                           ...
05:08:32 <lunabot>                                                                           ...
05:08:39 <mmorrow> , ppDoc <$> printf "%d"
05:08:41 <lunabot>  \x_0 -> ("" ++ show x_0) ++ ("" ++ []) :: forall a_1 . (Integral a_1, Sho...
05:08:41 <lunabot>                                                                           ...
05:08:43 <trofi_> gettext in haskell in't very popular
05:08:44 <mmorrow> , ppDoc <$> printf "%s"
05:08:47 <lunabot>  \x_0 -> ("" ++ x_0) ++ ("" ++ []) :: forall . String -> String
05:09:06 <eflister> EvilTerran: it's easy if you case out the either, but i'm sure that Traversable.mapM and Arrow.left should let me do it without resorting to casing...
05:09:30 <EvilTerran> ?type left
05:09:30 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
05:09:54 <EvilTerran> uh
05:10:10 <EvilTerran> ?instances-importing Control.Arrow ArrowChoice
05:10:10 <lambdabot> (->), Kleisli m
05:10:13 <ksf> heck someone vote on http://www.reddit.com/r/programming/comments/9v6zf/simon_peyton_jones_how_to_give_a_good_research/
05:10:21 <ksf> two hours without any votes is kinda strange
05:10:27 <ksf> ...even if the talk is 1:15
05:15:41 <c_wraith> Is there any way to use a newtype as a key in an IntMap ?
05:16:00 <dmwit> No, IntMap's are for Int's only.
05:16:10 <c_wraith> It's an int at runtime....
05:16:19 <dmwit> You can, of course, use a normal Map.
05:16:21 <c_wraith> Heh.  unsafeCoerce is the wrong answer
05:16:35 <Baughn> You could, of course, unwrap it
05:16:40 <dmwit> Unwrapping the constructor has no runtime cost, you know.
05:16:42 <c_wraith> Oh, but it's a compiletime transform to unwrap it, isn't it?
05:16:56 <c_wraith> so, yeah, that's ok.
05:17:47 <ksf> there's e.g. EnumMap
05:18:08 <c_wraith> ksf, it's an Int.
05:18:11 <ksf> well yes that's what IntMap uses.
05:18:13 <c_wraith> I don't need a different map type.  I just need to unwrap it.
05:18:24 <Baughn> Go right ahead
05:18:24 <ksf> that's what EnumMap does.
05:18:39 <Baughn> No, EnumMap uses fromEnum. That is not necessarily a cheap operation.
05:18:43 <ksf> newtype Foo = Foo Int deriving (Enum)
05:19:02 <ksf> Int's enum method should be quite efficient.
05:19:10 <Baughn> Sure. Not quite zero, though.
05:19:23 <ksf> it should reduce to id.
05:19:31 <Baughn> id is not free
05:19:38 <c_wraith> Unwrapping is entirely at compile time.  hard to beat that.
05:19:39 <ksf> and ghc should nuke that use of id.
05:19:52 <Baughn> Only if the use is inlined
05:20:17 <Baughn> That's quite probable. It would be interesting to see if it is.
05:20:21 <ksf> well it's still faster than writing a wrapper around IntMap
05:20:46 <ksf> premature optimisation is the root of all evil.
05:20:48 <c_wraith> The wrapper is already present.  It's just a matter of whether it unwraps a newtype, or just uses a type
05:20:58 <c_wraith> And I want the newtype for type safety
05:21:07 <dmwit> ksf: Nobody is wrapping IntMap.
05:21:10 <dmwit> That's absurd.
05:21:15 <ksf> enummap does it.
05:21:37 <c_wraith> You're the only one talking about EnumMap
05:22:02 <ksf> ...because that's the fastest way to get an IntMap for a newtyped Int.
05:23:53 <ksf> you know, to get your code to run faster, you _could_ learn quantum mechanics and research quantum computers.
05:24:13 <ksf> but then, you could live with O(2) instead of O(1)
05:24:21 <c_wraith> or, you could listen to what I'm saying
05:24:27 <dmwit> O(2)=O(1)
05:24:34 <ksf> ...that's part of the point.
05:24:36 <c_wraith> I'm adding type safety to existing code.
05:24:45 <dmwit> But sometimes big-Oh notation is not the right measure.
05:24:47 <c_wraith> There's a fair bit done already.
05:25:03 <eflister> EvilTerran: any thoughts?  :)
05:25:09 <c_wraith> It's less of a change to unwrap than to switch to an EnumMap
05:25:33 <ksf> so, you can either a) unwrap the Int each time you pass it to some map function or b) switch to enummap
05:25:41 <ksf> ...you could also c) use gmap or such.
05:25:50 <Baughn> > fromEnum (2^70 :: Integer)
05:25:51 <lambdabot>   0
05:26:35 <ksf> I think we even got a generic map library that figures out the most efficient implementation based on key type.
05:26:41 <ksf> ...automagically, that is.
05:27:09 <burp> > foldr1 (.|.) $ zipWith shiftL [127,0,0,1::Word32] [24,16,8,0]
05:27:10 <lambdabot>   2130706433
05:27:15 <EvilTerran> eflister, looks to me like it should work with Traversable etc; not sure how exactly
05:27:22 <burp> > printf "%x" $ foldr1 (.|.) $ zipWith shiftL [127,0,0,1::Word32] [24,16,8,0]
05:27:23 <Baughn> ksf: But would it figure out a newtyped int?
05:27:23 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:27:24 <lambdabot>    `GHC.Show.Show b'
05:27:24 <lambdabot>      a...
05:27:25 <EvilTerran> eflister, use of "either" instead of "left" may be in order
05:27:32 <burp> woops
05:27:35 <EvilTerran> ?type either
05:27:36 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:27:42 <ksf> I think it would use Enum, if you provide an instance.
05:27:57 <ksf> hackage is down, though, so I can't find the library.
05:29:47 <c_wraith> yeah, hackage is apparently down whenever I want to code when I should be asleep.
05:30:03 <ksf> ...or you could provide one of its resolver instances, of course.
05:30:27 <ksf> instance Key Foo where type Map Key = IntMap...
05:30:35 <ksf> er Map Foo.
05:30:38 <ksf> whatever.
05:31:03 <eflister> EvilTerran: yeah, i was playing with that too, but digging the IO out from inside is the problem...
05:35:57 <Berengal> ListT IO is a funky type constructor
05:37:50 <ksf> I think it's triemap, but I'm not 100% sure.
05:38:09 <ksf> wtf archive.org is down?
05:38:35 <ivanm> ksf: there might be an archived copy on archive.org! ;-)
05:41:01 <mercury^> Which type matches the value `undefined' best? (i.e. if I have a program that I want to typecheck without implementing everything and I need a type, what choice makes the most sense?)
05:41:32 <ksf> :t undefined
05:41:33 <lambdabot> forall a. a
05:41:37 <ksf> choose any.
05:41:51 <mercury^> I know that I can use any type. I'm asking which one would be an elegant choice.
05:42:00 <Berengal> mercury^, the type that is a subtype of everything, or if you don't have subtyping, the union of all types
05:42:01 <mmorrow> @type undefined :: a -> Tree (Either () [Maybe (Int,Double)])
05:42:01 <ksf> depends on your program.
05:42:02 <lambdabot> forall a. a -> Tree (Either () [Maybe (Int, Double)])
05:43:02 <Botje> hmm. I wonder when Maybe (Maybe a) would _not_ be the same as Maybe a
05:43:22 <dmwit> Always?
05:43:23 <mercury^> A type containing only undefined seems like a natural choice. But how can I create one?
05:43:25 <ksf> there's more error information.
05:43:34 <ksf> data Foo
05:43:35 <Berengal> Botje, Map Key (Maybe value) -> lookup now gives a Maybe (Maybe value)
05:43:39 <c_wraith> Huh?  This is strange.  I can't seem to newtype deriving Enum.
05:43:47 <Botje> oh, heh.
05:43:48 <benmachine> mercury^: I think you need an extension
05:43:49 <Botje> okay :)
05:43:54 <ksf> use {-# LANGUAGE EmptyDataDecls #-}
05:43:54 <benmachine> -XEmptyDataDecls or something similar
05:44:04 <mmorrow> c_wraith: none of the constructors can have any args
05:44:06 <Berengal> Botje, each maybe having different semantics
05:44:07 <benmachine> then you can just do data EmptyType
05:44:07 <mmorrow> for Enum
05:44:12 <benmachine> with no constructors
05:44:19 <burp> has anyone used HsOpenSSL successfully?
05:44:23 <mmorrow> c_wraith: oh, newtype derive
05:44:26 <mmorrow> not sure
05:44:49 <ksf> -XGeneralisedNewtypeDeriving
05:44:51 <burp> I get a segfault when using contextSetDefaultCiphers on a newly created context
05:45:03 <burp> in SSL_CTX_set_cipher_list
05:45:17 * voker57 did
05:45:51 <c_wraith> that did it, ksf.  thanks
05:46:12 <ksf> c_wraith, I think http://209.85.229.132/search?q=cache:1X4cGzTw5fsJ:hackage.haskell.org/packages/archive/TrieMap/0.0.1.1/doc/html/TrieMap.html+site:hackage.haskell.org+triemap&hl=de&client=firefox-a&gl=de&strip=1 is what you want, in the end.
05:46:34 <Veinor> hackage is down?
05:46:51 <dmwit> Veinor: seems so, yes
05:49:52 <burp> voker57: recently? so context >>= contextSetDefaultCiphers works for you?
05:50:02 <idnar> mercury^: forall a. a only contains undefined
05:50:33 <idnar> but I guess EmptyDataDecls might be nicer
05:52:23 <ksf> I'd like to have an internet announce board.
05:52:38 <Jafet> /topic
05:52:55 <benmachine> @help topic-cons
05:52:55 <ksf> where providers can confess when they fuck up their nets.
05:52:56 <lambdabot>  @topic-cons #chan <mess> -- Add a new topic item to the front of the topic list
05:53:06 <benmachine> oic
05:53:23 * Jafet carefully puts that in the unworkable ideas bin
05:54:05 <dnivra> i have been reading about functional programming in wiki and have not yet been able to make out what exactly is the advantage of this over OOP. can anyone help me out?
05:54:15 <burp> really annoying hackage is down such often
05:54:34 * EvilTerran fights with category theory
05:54:35 <voker57> burp: didn't use it. Which module is it?
05:54:43 <burp> OpenSSL.Session
05:54:49 <benmachine> dnivra: it's easier to prove things about a functional program
05:54:50 <ksf> fp is actually orthogonal to oop, but we don't use oop much around here as fp gives enough abstraction on its own.
05:54:53 <ivanm> EvilTerran: who's currently winning? ;-)
05:54:57 <dnivra> how can elimination of program state be so much great(i'm in my second semester doing my engineering in computer science so forgive me for my ignorance)
05:54:59 <voker57> burp: yep, segfault
05:55:02 <burp> ok :(
05:55:02 <benmachine> agreed with ksf too
05:55:22 <Jafet> dnivra, for one thing, there are definitions of FP everyone can generally agree on
05:55:23 <benmachine> I think that FP doesn't so much compete with OOP as show it's not necessary
05:55:41 <benmachine> program state isn't eliminated, it's explicit
05:55:45 <benmachine> and that's really handy sometimes
05:55:51 <dnivra> benmachine: meaning?
05:55:54 <benmachine> e.g. for testing, serialisation
05:55:59 <benmachine> dnivra: which bit
05:56:06 <ksf> dnivra, there's usually still state involved, but no mutable state. it means that you can't mess up by getting the order of mutations wrong.
05:56:12 <dnivra> benmachine: program state is explicit
05:56:15 <EvilTerran> ivanm, currently, "given [f:A->B, g:B->C, f iso, (g.f) iso], prove [g iso]" is winning)
05:56:18 <c_wraith> oh, right.  cabal install is broken too, when hackage is down.
05:56:20 <c_wraith> *sigh*
05:56:25 <benmachine> dnivra: oh, I mean like the State monad and stuff like that
05:56:35 <benmachine> everything that is required by a function is fed into the function
05:56:39 <EvilTerran> (it's homework)
05:56:44 <Jafet> dnivra, SICP is a good easy introduction, Haskell probably isn't
05:57:06 <Jafet> Presumably you come from Java or basic
05:57:10 <ksf> sicp is by no means an intro to fp, no matter how great it is.
05:57:16 <ksf> sicp is an intro to scheme.
05:57:25 <dnivra> Jafet: only C and C++
05:57:38 <ksf> ...employing a lot of strictness and side-effects.
05:57:42 <Jafet> Scheme is a more accessible intro to FP, I feel
05:57:51 <mercury^> Not at all imo.
05:57:56 <medfly> scheme is FP?
05:58:06 <mercury^> One can do some FP in scheme.
05:58:11 <EvilTerran> scheme is functional, but so is perl
05:58:11 <ksf> only if you equate fold with fp.
05:58:16 <EvilTerran> neither are purely functional
05:58:36 <RayNbow> dnivra: have you ever debugged C or C++ programs? :)
05:58:38 <EvilTerran> i equate lambdas with fp
05:58:56 <EvilTerran> well, functions as first-class values
05:58:59 <Jafet> Haskell is on this far end, with lazy evaluation, type classes, and monads, which distract from the basic concepts of FP (although they are of course relevant)
05:59:43 <dnivra> RayNbow: yes but they are usually simple ones such as seg faults and common syntax errors. never worked on big or even multi-file programs
05:59:47 <medfly> news to me. :)
06:00:03 <RayNbow> dnivra: so how many of those bugs were related to state? :p
06:00:12 <ksf> dnivra, http://www.haskell.org/haskellwiki/Why_Haskell_just_works
06:00:27 <c_wraith> I guess it's time to sleep, and possibly when I wake up, hackage will be back
06:00:34 <Jafet> Haskell just works -- after you get it to compile
06:00:40 <medfly> heh
06:00:48 <Jafet> Although the winner of that goes to C++
06:00:51 <dnivra> RayNbow: can you please enlighten me on what exactly state and why is it so important; read the wikipedia page not much sense as to why it's important?
06:01:10 <ksf> yep. haskell can be frustrating for beginners because it won't compile, instead of blowing up into their faces.
06:01:33 <Jafet> ksf, it's part of the strangeness and mystique
06:01:44 <c_wraith> admittedly, GHC's error messages could be less obscure.
06:02:06 <c_wraith> It took me a couple months to get used to what some of the  more verbose ones are conveying
06:02:20 <Jedai> c_wraith: It's already so much better than it was a couple of year in the past
06:02:25 <ksf> dnivra, if you do x = 2 in c, you can do x = 4 , afterwards. confusion ensues, because different things might work or work not with different values for x, and thus you might blow up.
06:03:01 <RayNbow> ^ this :)
06:03:04 <c_wraith> Probably true...  Sometimes I feel like it gives too much context on the simple type errors, though.
06:03:26 <c_wraith> Why is there a 6 line error message for one argument to a function being the wrong type?
06:03:27 <RayNbow> Joe Armstrong makes a similar point in his Erlang book
06:03:30 <mmorrow> dnivra: the main advantage of functional programming is that you can pass functions around, so other functions can take other functions as args
06:03:30 <ksf> to really, really grok the difference between a pure and an impure language you have to have coded in both, I think.
06:03:36 <medfly> I think most of the "problem" with Haskell is that the people you're talking of which study it, are people who have programmed before and have a fixed view on how code should be written.
06:03:47 <mercury^> ksf: that's a bad example, because one can write C in SSA style. The real problem is that you modify through pointers.
06:03:52 <medfly> all the guides I'm looking at "let's explain to this guy who only does imperative programming how to use Haskell"...
06:04:13 <mmorrow> dnivra: that may sounds trivially in words, but the result is that how you build the equivalent of say a C function, is by composing say 20 functional functions together
06:04:15 <Twey> I think LYAH doesn't assume any prior experience
06:04:16 <Jedai> dnivra: The important point is that in C or C++, the same function called with the same argument can have different results depending on when or where you call it
06:04:32 <medfly> Twey, no, it's written for people with experience with imperative languages.
06:04:36 <medfly> it even says so.
06:05:05 * EvilTerran tries to work out how to prove (f . (g.f)^-1 . g = id) when we only know f and (g.f) are iso, but not that g is iso
06:05:15 <Jafet> medfly, proselytism isn't always a bad thing
06:06:14 <Twey> medfly: Â« This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python â€¦) but haven't programmed in a functional language before (Haskell, ML, OCaml â€¦). Although I bet that even if you don't have any significant programming experience, a smart chap like you will be able to follow along and learn Haskell. Â»
06:06:19 <ksf> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.pdf   makes a better argument of fp than we're going to be able to come up with here, I think.
06:06:24 <darrint> Is hackage dead?
06:06:31 <ksf> darrint, yes.
06:06:36 <medfly> I'm just saying I think there isn't really a problem with Haskell.
06:06:41 <ksf> direct hatemails to galois, please.
06:06:50 <Jedai> dnivra: this leads to profound problems and difficult to find bugs... Most good engineers in those languages in fact try their best to reduce the instances of this, trying to keep the different parts of the program as independents as possible and banishing any kind of global state...
06:07:10 <mercury^> EvilTerran: g is injective for that to make sense, so you have f . f^{-1} . g^{-1} . g = id naturally.
06:07:12 <medfly> Twey, okay, we read that sentence differently. :)
06:07:20 <mmorrow> EvilTerran: (f . (g.f)^-1 . g = id) ==> ((g.f)^-1 . g = f^-1) ==> (g = (g.f) . f^-1) ==> (g = g)
06:07:32 <Jedai> dnivra: So instead of letting the programmer do all the work of ensuring that, Haskell choose this statelessness as the default and let the type system encode this guarantee
06:07:39 <ksf> not at all least and even less least, purity enables the compiler to do optimizations imperative compilers can only dream of.
06:08:01 <ksf> that is, ghc actually reduces the time-complexity of your program.
06:08:01 <EvilTerran> mmorrow, ah, the (f . (g.f)^-1 . g = id) <==> ((g.f)^-1 . g = f^-1) seems to be what i was missing, thanks
06:08:13 <Jafet> ...except it doesn't.
06:08:21 <Jafet> Well, not as well as it could
06:08:28 <dnivra> Jedai: so absence of state means no mutable data such as variables. instead only symbols are used?
06:08:29 <medfly> it should be better!
06:09:18 <dnivra> Jedai: so how can the absence of state be helpful. still can't comprehend this fact.
06:09:20 <Jedai> dnivra: Right, and side-effects (IO...) are prohibited in normal code (only code enclosed in an IO monad can do them)
06:09:25 <Jafet> Getting better all the ti-i-ime
06:10:04 <ksf> dnivra, I think you have to code to understand it.
06:10:28 <dnivra> ksf: i did code actually; hold on ok
06:10:42 <Jedai> dnivra: Implicit state is the source of many, if not most, bugs in big systems, this is the reason that even in imperative languages, good engineers try to avoid it
06:10:42 <Twey> medfly: Hehe.
06:10:49 <medfly> Twey, :)
06:11:30 <dnivra> Jedai: ok
06:11:32 <RayNbow> dnivra, http://dpaste.com/108898/
06:11:42 <Jedai> dnivra: So Haskell is constructed around concept that makes it easier to do things without implicit state and allows side-effect or state only in a controlled fashion (controlled by the type system)
06:12:25 <ksf> oh. parallelism is another key point. if you don't have any uncontrollable side-effects, it's trivially easy to run a program in parallel.
06:13:02 <Jedai> ksf: I wouldn't say that... Many program are still constrained to be sequential by data dependancy
06:13:10 <medfly> I'm kind of new to coding big things, and I've been trying to make a lot of bits of code which are reusable, but it's starting to feel really redundant, should I keep at it, or just write ugly stuff? what do you say, guys? :-)
06:13:24 <EvilTerran> mercury^, but if you have no proof that g is iso, then you can't take g^-1, surely?
06:13:45 <Twey> medfly: Writing reÃ¼sable code feels redundant?  I think you're doing it wrong :Ã¾
06:13:55 <dnivra> RayNbow: i have a doubt this paragraph where Joe Armstrong talks about the variations that might occur, is loop in OOP an example?
06:14:05 <Jedai> ksf: but it sure is easier to parallelize a potentially parallel program and FP tends to push you towards parallelizable algorithms more than imperative languages, probably
06:14:20 <ksf> Jedai, sure.
06:14:50 <ksf> I can't, for example, safely parallelize multiple gf's, in general.
06:14:56 <medfly> Twey, it's just the result I'm trying to achieve is rather simple as well
06:14:57 <Saizan> and you know you can't lose correctness by evaluating those concurrently
06:15:15 <ksf> though I'm not sure about the data dependencies there.
06:15:17 <RayNbow> dnivra: Joe Armstrong doesn't really mention any examples
06:15:18 <Berengal> Also, using data parallelism, your program will still work just the same as if you didn't, but possibly slower if you messed it up
06:15:21 <ksf> seems they do mutexes or something.
06:15:37 <RayNbow> dnivra: but in case of OOP I'd say that a good example would be all the different call sites of a method
06:15:39 <idnar> ksf: hahaha
06:16:09 <Twey> medfly: It's less to do with how simple the end result is and more to do with how useful the intermediate code could be, I think
06:16:19 <ksf> medfly, write concrete, generalize lazily.
06:16:35 <medfly> ksf, can you explain what that means?
06:16:36 <ksf> ...premature generalisation is the root of all procrastination.
06:16:42 <medfly> hehe :)
06:16:53 * medfly is actually procrastinating.
06:17:01 <Saizan> @remember ksf ...premature generalisation is the root of all procrastination.
06:17:02 <lambdabot> Nice!
06:17:07 <Jafet> FP is just a way to organize semantics, which is a problem "OOP" systems also in their turn try to solve, but usually badly
06:17:39 <medfly> Twey, so if the intermediate result doesn't seem very useful at all, just stop splitting it into a million and one functions?
06:18:03 <RayNbow> class Foo { int bar=0; void changeBar(int newbar) { this.bar = newbar; } /* more code */ }   // dnivra: now, assume that you find this.bar has the wrong value whe debugging. You now have to inspect all calls to the changeBar method
06:18:03 <palgorithm> hi everyone. The GHC devel wiki is down at the moment (at least for me). Could someone send me the darcs location? I'd like to check out head, but can't find the location.
06:18:06 <RayNbow> *whe debugging -> while debugging
06:18:06 <Saizan> medfly: splitting things can also make them more readable and testable
06:18:28 <medfly> I suppose that's very true.
06:18:42 <Jafet> So, how long does it take nine ghc instances to make a baby?
06:18:50 <shambler> :-)
06:19:06 <SamB_XP_> palgorithm: it's in http://darcs.haskell.org/ somewhere ;-)
06:19:50 <dnivra> RayNbow: true i agree you need to check all calls to the changeBar method to know when it happened
06:20:35 <palgorithm> SamB_XP: thanks. That's somewhere for me to start :)
06:20:36 <Twey> medfly: Yeah.  â˜º
06:20:45 <Twey> medfly: Unless it's no extra effort to do so.
06:21:05 <fxr> hackage down?
06:21:26 <Saizan> yes
06:21:37 <ivanm> can someone please put a message about hackage being down into the topic?
06:21:41 <ivanm> so people stop asking? :p
06:22:11 <fxr> well I looked at the topic before
06:22:27 <burp> feels like it's down every second sunday
06:23:07 --- mode: ChanServ set +o Saizan
06:23:10 <yitz> ivanm: then the faq becomes: "the topic says that hackage is down. is it still down, or did it come up again?"
06:23:13 <ivanm> burp: the server has to go to church! ;-)
06:23:22 <ivanm> yitz: true...
06:23:24 <Jafet>   @topic-cons #haskell Hackage needs more pylons
06:23:32 <ivanm> Saizan: maybe put the downforeveryone link? *shrug*
06:23:38 <ivanm> then it can stay there! ;-)
06:23:46 <Saizan> meh
06:24:06 <Baughn> I find that link funny. Half the time, they're mistaken.
06:24:10 --- mode: Saizan set -o Saizan
06:24:23 <Baughn> Just because it's down for them, doesn't mean it's down for everyone else..
06:24:24 <palgorithm> darcs.haskell.org appears to be down as well :)
06:24:45 <Berengal> So basically, haskell.org is down
06:24:45 <Jafet> That depends on how many places they check from
06:24:57 <ivanm> Berengal: there are 3 or 4 servers involved...
06:25:11 <ivanm> Baughn: well, if it's down for you and down for them, then that increases the likelihood that it's down for everyone... >_>
06:25:11 <Saizan> it's a conjure!
06:25:24 <Berengal> ivanm, that can only mean the entire internet is broken!
06:25:32 <ivanm> Berengal: heh
06:25:42 <Saizan> i suspect the clojure guys.
06:25:54 <Jafet> That's why we're sitting in IRC watching everything crumble
06:26:08 <maltem> The internet? Is that thing still around?
06:26:27 <ivanm> maltem: apparently
06:26:30 <Berengal> Saizan, you mean dynamic types didn't work out quite as well for them?
06:26:38 <maltem> (quoting Homer Simpson, that is)
06:27:16 <yitz> It's first thing in the morning on the U.S. east coast. Hmm... why is it that when major servers go down, it is usually that time of day?
06:27:19 <SamB_XP_> yeah, downforeveryoneorjustme.com should actually have multiple servers in different places ...
06:27:36 <SamB_XP_> yitz: this is not "first thing in the morning"
06:27:52 <yitz> SamB_XP_: well, I guess it depends for whom
06:28:17 <SamB_XP_> unless you figure morning starts later on sundays ?
06:28:20 <Saizan> Berengal: i must confess that i don't get the joke there :)
06:28:37 <Berengal> Saizan, you didn't miss much. It was horrible
06:29:34 <Berengal> Hmm... 'openLazyUri uri >>= \Right bytes -> L.writeFile file bytes' turns into a 40-line function when I add error checking, verbose output etc...
06:30:04 <Berengal> This is the difference between scripting and coding, I guess
06:30:13 <ivanm> Axman6: you around?
06:31:41 <ivanm> oh, right, daylight saving time...
06:35:27 <mercury^> Anyone here knows whether minimal arithmetic is sufficient for statements of the form "kolmogorovComplexity(s) > n"?
06:36:03 <Jafet> Minimal arithmetic? Is that like arithmetic?
06:36:33 <mercury^> It's the theory used for the first incompleteness theorem.
06:36:45 <Jafet> The Peano axioms, I think
06:36:55 <mercury^> No.
06:36:58 <mercury^> Weaker.
06:37:27 <Jafet> I suspect you can formulate the statements, but you can't prove them
06:37:27 <Jafet> In general, that is
06:37:43 <mercury^> In minimal arithmetic, exactly the correct \exists-rudimentary sentences are theorems.
06:38:11 <mercury^> You cannot prove them in general in any theory, but whether you can formulate them is not so clear to me.
06:38:22 <mercury^> I know you can do it in Peano arithmetic.
06:38:25 * Jafet rtfms
06:45:14 <Tobsan> @arr
06:45:15 <lambdabot> I'll crush ye barnacles!
06:45:51 <Tobsan> Thanks!
06:49:02 <Jafet> I can't make head or tail of GÃ¶del's paper today, I'm afraid
06:51:02 <Berengal> Jafet, (head:tail) = Gödel's paper
06:51:02 <Saizan> maybe you've found the escher version
06:52:10 <stanv> how to get list of random numbers in range 1..100 :: Int ?
06:52:28 <Berengal> randomRIO (1,100)
06:52:36 <Jafet> Worse, I'm reading a translation!
06:53:00 <poe> http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
06:53:32 <yitz> stanv: in the IO monad, do g <- getStdGen. Then pass g to any function, in which you can do randomR (1,100) g
06:54:16 <yitz> stanv: you'll get your random value, and a new g that you can use to get further random values
06:54:27 <Berengal> stanv, a more convenient interface is MonadRandomT, which gives you random numbers in any old monad
06:54:37 <stanv> > take 10 (repeat (randomRIO (1, 100)) :: [Int])
06:54:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:54:38 <lambdabot>         against inferred type ...
06:54:41 <stanv> :(
06:54:52 <yitz> @type randomR
06:54:53 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:55:02 <yitz> @type randomRIO
06:55:03 <lambdabot> forall a. (Random a) => (a, a) -> IO a
06:55:06 <Berengal> @type randomsRIO
06:55:07 <lambdabot> Not in scope: `randomsRIO'
06:55:19 <yitz> @type randomRs
06:55:20 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
06:55:38 <poe> > randomRs (1,100) (mkStdGen 42)
06:55:39 <lambdabot>   [72,72,18,15,17,92,19,72,59,76,66,80,77,19,5,46,88,52,94,37,67,5,33,95,37,1...
06:57:55 <stanv> thanks!
06:59:12 <Berengal> > evalState (replicateM 5 (State (randomR (1,100)))) (mkStdGen 1234)
06:59:14 <lambdabot>   [60,98,74,49,74]
06:59:45 <poe> be careful that the generator should come from a source of values different with time, or you'll get the same random numbers again and again
07:00:20 <Berengal> Is there an easy way to read dev/random yet?
07:00:56 <Berengal> newStdGen just splits and updates the old one...
07:04:39 <mercury^> Ah, minimal arithmetic is sufficient indeed.
07:07:09 <mmorrow> Berengal: oh, that reminds me of that snippet you gave me to try in lunabot, i got sidetracked at the time
07:07:14 <mmorrow> Berengal: trying that now
07:07:42 <Berengal> Ah, right. I had forgotten about that
07:07:47 <mmorrow> gah hackage
07:07:56 <Berengal> mmorrow, how did you display the craps by the way?
07:07:59 <mmorrow> anyone have a tarball of the monadrandom pkg?
07:08:17 <Berengal> mmorrow, I do
07:08:24 <mmorrow> Berengal: by utf8-encoding those unicode chars
07:08:48 <mmorrow> , "âš€âšâš‚âšƒâš„âš…"
07:08:49 <lunabot>  "\9856\9857\9858\9859\9860\9861"
07:09:05 <mmorrow> , utf8enc "\9856\9857\9858\9859\9860\9861"
07:09:06 <lunabot>  "\226\154\128\226\154\129\226\154\130\226\154\131\226\154\132\226\154\133"
07:09:06 <Berengal> But they didn't have any quotes around them, if I recall
07:09:12 <mmorrow> , (text . utf8enc) "\9856\9857\9858\9859\9860\9861"
07:09:14 <lunabot>  âš€âšâš‚âšƒâš„âš…
07:09:39 <mmorrow> i used a newtype around Char, then made the Show instance be
07:09:45 <Berengal> Ah
07:10:02 <mmorrow> instance Show Die where show (Die o) = utf8enc [o]
07:10:05 <Berengal> anyway, you want the tarball?
07:10:11 <yitz> Berengal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10881#a10881
07:10:12 <mmorrow> yes, thanks
07:10:37 <Berengal> where to?
07:10:51 <Berengal> yitz, nifty
07:10:58 <mmorrow> Berengal: oh, email you mean?
07:11:08 <mmorrow> morrow@moonpatio.com
07:11:52 <Berengal> sent
07:11:57 <mmorrow> thanks
07:12:43 <Gilly_> I have a type class Intersectable a b and would like to automatically instantiate Intersectable b a (with function intersect = flip intersect) whenever Intersectable a b... can I do this?
07:14:01 <dmwit> With UndecidableInstances, I suppose.
07:14:22 <dmwit> instance Intersectable a b => Intersectable b a where intersect = flip intersect
07:14:26 <Saizan> yeah, but then it's easy to make the typechecker spin :)
07:14:35 <dmwit> yeah, real easy
07:14:49 <Berengal> With an instance like that especially
07:14:51 <Gilly_> I tried that but I guess I failed :) (Got overlapping instances)
07:15:09 <dmwit> Oh yes, with that every instance will overlap.
07:15:17 <dmwit> Because you can apply that flip twice!
07:15:22 <Gilly_> yep
07:15:26 <benmachine> the Monoid solution for this was to make a newtype
07:15:44 <benmachine> newtype Dual a = Dual { getDual :: a } I think
07:15:53 <benmachine> then Monoid a => Monoid (Dual a)
07:15:55 <benmachine> no that doesn't work
07:15:56 <benmachine> never mind
07:16:07 <Saizan> it works for Monoid
07:16:24 <Berengal> You can make instance Intersectable (Flip b) (Flip a)
07:16:41 <dmwit> or even just Intersectable (Flip b) a
07:16:51 <dmwit> though the asymmetry is a bit unaesthetic
07:17:01 <Gilly_> yeah... i'm writing a small piece of geometry drawing software and I got figures like lines and circles and I'd like to be able to just intersect Line with Circles to automatically deduce that I can also intersect Circles with Lines :)
07:17:16 <Berengal> We need product kinds and type-level uncurrying :P
07:17:20 <dmwit> hum
07:17:31 <dmwit> That sounds like a data-level thing, not a class-level thing.
07:17:41 <dmwit> Are you super-duper sure that you want to use classes at all?
07:17:56 <Gilly_> well - i'd like to be able to intersect arbitrary shapes later on
07:18:25 <Gilly_> (i'm going to write some general parametric curve thingy that can be approximated with line segments and then intersect those segments)
07:18:28 <Berengal> mmorrow, email failed :(
07:18:29 <mmorrow> Berengal: hmm, did you maybe use "mmorrow" instead of "morrow"?
07:18:32 <mmorrow> heh, ok
07:18:37 <Berengal> Just got a bounce
07:18:42 <mmorrow> was starting to worry that my mail server was borked
07:18:47 <Berengal> And I used morrow
07:18:51 <dmwit> Gilly_: yes... I'm not seeing a need for multiple types yet from your description
07:18:53 <mmorrow> hmm, odd
07:19:07 <mmorrow> Berengal: what did the response email say?
07:19:11 <Berengal> <mailto:morrow@moonpatio.com>: Recipient address rejected: User unknown in local recipient table (state 14).
07:19:19 <mmorrow> :o
07:19:30 <dmwit> data Region = Circle Point Radius | Line Point Point | PolyCurve [Curve] -- ?
07:19:34 <Gilly_> dmwith: i think it'd be a bit unaesthetical to have separate "intersect_line_with_circle" "intersect_circle_with_circle" ...
07:19:46 <dmwit> Gilly_: Oh, I agree that would be horrible.
07:20:03 <dmwit> But what about just intersect :: Region -> Region -> Region?
07:20:07 <Gilly_> hm, yea i guess that would work
07:20:17 <dmwit> And let Region be a data type inhabited by lines, circles, and other shapes as necessary?
07:20:30 <Gilly_> can you tell me why this would be preferred to classes? and when to use classes at all then?
07:20:34 <mmorrow> Berengal: hmm, do you have any idea what could be causing that, since i can definitely receive send mail, but i'm not too informed about mail servers, so i may have neglected to configure something?
07:20:59 <yitz> mmorrow: 554 <morrow@moonpatio.org>: Relay access denied
07:21:08 <mmorrow> yitz: oh
07:21:12 <yitz> during telnet moonpatio.org 25
07:21:17 <dmwit> Classes are good for ad-hoc polymorphism, that is, when you want to use the same name to have many different behaviors, depending on what type it's used at.
07:21:52 <Berengal> mmorrow, I have very little knowledge of email in general, so no
07:22:39 <dmwit> It's a little subtle when you want to use sum types and when you want to use separate types, I agree. =)
07:22:43 <Gilly_> well, if i did it your way how would you solve my orignal problem: suppose I have written intersect (Line a b) (Circle p r) and would like to be automatically intersect Circles with Lines
07:22:57 <dmwit> You can have a final case
07:22:59 <Saizan> in a sense ad-hoc polypmorphism is another thing, a more accurate term is bounded polymorphism
07:23:02 <dmwit> intersect x y = intersect y x
07:23:05 <mmorrow> Berengal: in the meantime just use moonpatio@gmail.com
07:23:21 <Gilly_> hm, yes
07:23:48 <dmwit> Just be careful not to introduce a loop that way. =)
07:23:51 <Berengal> mmorrow, sent, again
07:23:56 <Gilly_> :)
07:24:39 <Berengal> dmwit, with a bit of Maybe and a helper function, you could probably turn that loop into an error pretty easily
07:25:25 <Gilly_> now things get complicated, however... let's say i'd like to find circumcenter of a circle, but circle is of type Region and circumcenter doesn't really make sense for arbitrary regions
07:26:00 <Berengal> I'd probably write several functions, 'intersectLineWithCircle, intersectPointWithCircle', then have one function dispatch to those. That way I get warnings when there's a pattern missing
07:26:57 <dmwit> As a side note, can I ask how you got away with having only two type variables for your Intersect class?
07:27:08 <dmwit> That doesn't make a lot of sense to me; what was the return type of intersect?
07:27:19 <Gilly_> A list of points.
07:28:04 <dmwit> ah
07:28:06 <dmwit> weird =)
07:28:37 <Gilly_> :) well - this is supposed to be for drawing geometric constructions, ala euclid
07:28:49 <Gilly_> so i don't really have anything but finite intersections
07:28:51 <poe> Gilly_: what about type Locus = Set Point
07:29:37 <Gilly_> poe: hm, huge finite point sets don't seem like a good thing
07:29:53 <dmwit> As for circumcenter... would circumcenter :: Region -> Maybe Point work?
07:29:58 <dmwit> I see where you're going with this, though.
07:30:11 <poe> Gilly_: possibly data Locus = Points (Set Point) | Circle .. | Line .. where ".." is the specialized datastructure.
07:30:13 <dmwit> If it's feasible to know at compile-time whether a thing is a circle or a line, it would be nice to use that information.
07:30:13 <Berengal> Phantom types!
07:30:52 <Berengal> data Region a where Line :: Point -> Point -> Region Line; Circle :: Point -> Radius -> Region Circle
07:31:05 <Gilly_> i think it's a bit of hassle to have to deal with nothings :P and usually the user knows whether he wants a circle or a line
07:31:11 <Berengal> (and have empty decls for Line, Circle etc)
07:31:59 <Gilly_> hum, i don't really know anything about phantom types :)
07:32:02 <Berengal> That way you have 'intersect :: Region a -> Region b -> [Point]', and 'circumcenter :: Region Circle -> Point'
07:32:20 <Gilly_> interesting
07:33:04 <Berengal> and maybe some functions like 'isCircle :: Region a -> Maybe (Region Circle)'
07:34:02 <dmwit> I expect the most pragmatic thing will be to just write an extra instance for each mirror image.
07:34:16 <dmwit> It's not very long.
07:34:25 <Gilly_> well, no - it isn't
07:34:28 <dmwit> instance Intersectable Circle Line where intersect = flip intersect
07:34:56 <sproingie> bah i knew i should have downloaded that hackage tarball yesterday
07:37:35 <Gracenotes> that's the problem with commutative two-param typeclasses...
07:38:02 <Gracenotes> unfortunately, you still do need dual dispatch for an intersectio
07:38:03 <Gracenotes> n
07:38:28 <Gracenotes> well. unless you're writing, like, a ray tracer
07:38:33 <FunctorSalad> what is the problem?
07:39:31 <Gilly_> FunctorSalad: i was just trying to find a neat way to automatically write instances for intersecting a line and a circle given that we have an instance for intersecting a circle and a line (notice order)
07:39:56 <FunctorSalad> can't you just call the first instance from the second?
07:40:15 <dmwit> That's not automatic. =)
07:40:23 <FunctorSalad> template haskell
07:40:39 <Gilly_> yea - but then if i add a lot of shapes i'll have to do the same for all of those, thus introducing a lot of "empty code"
07:42:42 <FunctorSalad> at least not duplicated code :)
07:43:36 <Gracenotes> it might simplify things to use triangle meshes. simplify, at least, complicated 3D shapes; circles and lines can't be represented so well with it
07:45:46 <mmorrow> Berengal: beautiful, that works (by providing a way to stay in-monad while running craps multiple times)
07:45:48 <mmorrow> , randM (replicateM 4 crapsM)
07:45:50 <lunabot>  [(âš‚,âš…),(âš‚,âš‚),(âš,âš‚),(âš€,âš€)]
07:46:31 <dolio> , [$ty| crapsM |]
07:46:33 <mmorrow> but i think doing it without a runFoo function and some monad is borked for some reason in the bot
07:46:34 <lunabot>  Rand StdGen ((Die, Die))
07:46:47 <Berengal> mmorrow, gotta love static types
07:46:59 <mmorrow> , [$ty| randM |]
07:47:02 <lunabot>  forall a . Rand StdGen a -> a
07:47:34 <mmorrow> i should expose more of MonadRandom too, just have to sweep it for ways that unsafePerformIO could sneak through
07:48:17 <Phyx-> @src (=<<)
07:48:17 <lambdabot> f =<< x = x >>= f
07:48:25 <mmorrow> oh nice, just can expose the MonadRandom class
07:48:30 <Berengal> mmorrow, the in-monad actions should be safe
07:48:50 <Berengal> IO only happens at the entry point
07:49:44 <xcodem> How do i write this list comprehension with do-notation: http://codepad.org/xqA2OHtr
07:50:02 <Megant> xcodem: guard
07:50:03 <Berengal> xcodem, use guard
07:50:19 <xcodem> oh
07:50:25 <mmorrow> , randM (getRandomRs (0,3::Int))
07:50:26 <Taejo_> :t guard
07:50:28 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:50:28 <lunabot>  [0,1,0,0,0,0,3,1,3,1,2,3,2,3,1,1,3,2,0,3,1,3,0,2,0,1,2,3,2,1,2,1,0,0,1,0,...
07:50:30 <Gracenotes> ooh, I have an idea about the intersection thing - make an overlapping Intersectable2, with one instance for Intersectable a b => a b, and another for Intersectable b a => a b. >_>
07:50:32 <mmorrow> , randM (getRandomRs (0,3::Int))
07:50:34 <lunabot>  [0,1,2,1,1,1,0,0,3,3,2,0,1,0,2,3,0,2,3,1,1,0,2,2,2,2,1,3,1,2,2,3,3,0,2,1,...
07:50:37 <mmorrow> nice
07:50:39 <Gracenotes> and trust the compiler not to shoot you in the foot
07:51:30 <mmorrow> now "mkStdGen <bang on keyboard randomly>" can be avoided :)
07:51:40 <Berengal> Gracenotes, will that work? Does the resolution backtrack?
07:52:10 <Phyx-> @pl map (id &&& id)
07:52:11 <lambdabot> map (id &&& id)
07:52:37 <Berengal> map (join (,))
07:53:20 <ben_m> (,) confuses me so much
07:53:41 <ben_m> I still haven't figured out map ((,) <*> f) [1..] quite yet
07:53:47 <Gracenotes> Berengal: so long as forall a. b (a, b) in intersectable =/> (b, a) in intersectable (which automatically rules out (a, a), it shouldn't fail. it would just be a pain to code and, to an extent, for the compiler to deal with.
07:54:03 <Phyx-> Berengal: oh, right, thanks
07:54:23 <Gracenotes> @type (,)
07:54:25 <lambdabot> forall a b. a -> b -> (a, b)
07:54:27 <dolio> (<*>) is the S combinator in that case.
07:54:31 <Gracenotes> that expression is a peculiarity of <*> at work there, for the most part.
07:54:52 <Berengal> Gracenotes, the restriction on (a, a) might be a killer
07:54:52 <dolio> (,) <*> f = \x -> (,) x (f x)
07:55:16 <stroan> is hackage down for anyone else?
07:55:22 <aavogt> , [$ty| randM |]
07:55:23 <ben_m> Yeah I understand that, I just don't know why it works
07:55:24 <lunabot>  forall a . Rand StdGen a -> a
07:55:27 <ben_m> Or what <*> does exactly.
07:55:32 <voker57> yes
07:55:41 <Gracenotes> Berengal: oh, hm.. true.. after all, you'd reasonably want to know if, say, a line intersects a line
07:55:49 <ben_m> I'm reading about Applicative Functors right now, so that might help.
07:55:57 <Berengal> ben_m, f <*> g = \x -> f x (g x)
07:56:12 <ben_m> I see
07:56:18 <Gracenotes> so, (,) <*> g = \x -> (x, g x)
07:56:22 <ben_m> yeah
07:56:28 <stanv> are any other do same thing: foldr ($) nil (map insTree [1..10]) ?
07:56:29 <Berengal> ben_m, it's the basic S combinator, from SKI combinator calculus
07:57:08 <Gracenotes> in the original paper on applicatives, that application is particularly discussed, among others
07:57:38 <Gracenotes> dually, but somewhat coincidentally: f =<< g = \x -> f (g x) x. So, (,) =<< g = \x -> (g x, x)
07:58:01 <Berengal> <*> is basically function application in a context. As with all other things, functions are one of the most interesting (and golf-enabling) contexts
07:58:44 <Berengal> Gracenotes, the difference between (<*>) and (=<<) is rather illuminating on the difference between applicatives and monads
07:59:07 <mmorrow> here's that craps code in lunabot if anyone is interested http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4427#a4427
07:59:08 <Gracenotes> for the function application monad, not as much :)
07:59:30 <mmorrow> (along with utf8enc for sompleteness)
07:59:31 <Berengal> Gracenotes, even for the function instances
07:59:33 <mmorrow> *completeness
08:00:28 <Phyx-> (a >>= b) only evaluates b if a succeeds right, is there one that evaluates b only when a fails?
08:00:34 <Gracenotes> I suppose there is some comparison to be made in the way they are each chained together. it's still vague though
08:00:43 <Berengal> mmorrow, I just love how it exposes part of IO in a safe way
08:00:52 <Berengal> Phyx-, mplus, or <|>
08:01:16 <FunctorSalad> Berengal: Rand?
08:01:19 <mmorrow> Berengal: yeah, selectively exporting things from modules is handay
08:01:25 <Phyx-> Berengal: ah ofcourse. why do i keep forgetting this stuff
08:01:30 <mmorrow> FunctorSalad: MonadRandom
08:01:40 <FunctorSalad> what's IO about it?
08:01:44 <Berengal> Gracenotes, if you look at the application order, =<< allows you to compute the function to apply to x, but <*> doesn't, because it applies x first
08:01:47 <Gracenotes> mmorrow: like instances? :P
08:01:48 <mmorrow> , randM (getRandomRs (0,3::Int))
08:01:49 <mmorrow> , randM (getRandomRs (0,3::Int))
08:01:50 <lunabot>  [3,1,3,0,3,3,1,3,3,0,0,1,3,3,0,3,1,3,3,3,2,1,3,2,2,1,3,2,1,1,3,1,2,2,3,0,...
08:01:52 <lunabot>  [3,0,2,2,2,3,0,2,0,1,2,3,0,2,1,3,1,3,0,3,0,3,1,1,2,3,3,1,1,1,1,2,2,0,2,3,...
08:02:20 <FunctorSalad> but only the runner needs to do IO?
08:02:25 <mmorrow> right
08:02:39 <Guest14240> [d
08:02:46 <mmorrow> it's probably just a (Reader StdGen) or equiv
08:02:52 <mmorrow> err, ReaderT IO
08:03:23 <Berengal> mmorrow, State StdGen, I think
08:03:30 <mmorrow> oh right, State
08:08:42 <mmorrow> now lunabot needs some way of taking bets ..
08:09:07 <mmorrow> paypal accepted!
08:09:30 <burp> hehe
08:10:25 <mmorrow> and also possibly a server on some caribbean island
08:10:56 <Berengal> I'd rather have the island ;)
08:11:07 <Raevel> bet bet bet, place your bets!
08:11:29 <Raevel> betting ends.
08:11:37 <Phyx-> bets on?
08:11:43 <mmorrow> , randM (replicateM 4 crapsM)
08:11:45 <lunabot>  [(âš,âš),(âš€,âš€),(âš,âš),(âš,âš€)]
08:11:54 <Raevel> :-o
08:12:04 <Raevel> is that unicode dice?
08:12:16 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4427#a4427
08:14:12 <aavogt> , unsafePerformIO undefined -- just checking
08:14:13 <lunabot>  luna: parse error (possibly incorrect indentation)
08:14:18 <aavogt> , unsafePerformIO undefined
08:14:19 <lunabot>  luna: Not in scope: `unsafePerformIO'
08:14:30 * Saizan now realizes those aren't just boxes
08:14:31 <evanbd> What am I doing wrong?  let s = 1 : [sum x | x <- tail (inits s)]
08:14:48 <Saizan> mmorrow: you should make "-- comments" work in lunabot.
08:15:11 <mmorrow> Saizan: yeah true, that starts to get annoying
08:16:14 <Saizan> and it only requires a newline :)
08:16:59 <mmorrow> :)
08:17:14 <mmorrow> i think i'll just parse the expression, then prettyprint it
08:17:30 <evanbd> I can't take any items beyond the first from that list.  I think "take 5 s" should return [1,1,2,4,8], and "take 5 (1 : [sum x | x <- tail (inits [1,1,2,4])])" works.
08:17:44 <Berengal> evanbd, inits is strict in the tail of the cons, unfortunately
08:17:46 <mmorrow> evanbd: "let" is recursive
08:18:01 <mmorrow> oh wait, you know that
08:18:10 <mmorrow> , let s = 1 : [sum x | x <- tail (inits s)] in s
08:18:15 <lunabot>  luna: out of memory (requested 2097152 bytes)
08:18:18 <evanbd> mmorrow: Yeah, I'm trying to create an infinite list
08:18:23 <Berengal> evanbd, it works if you drop the 'tail'
08:18:35 <Berengal> > let s = 1: [sum x | x <- inits s] in s
08:18:37 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
08:18:38 <evanbd> Berengal: Yeah, but then I have a spurious [] in my list
08:18:57 <mmorrow> dropWhile (not . null)
08:19:17 <Berengal> evanbd, I know. Write your own inits, I guess
08:19:20 <mmorrow> err
08:19:24 <mmorrow> dropWhile null
08:19:25 <mmorrow> ;)
08:19:32 <evanbd> OK, thanks.
08:20:28 <Berengal> dropWhile null won't work either
08:20:30 <evanbd> Is there documentation somewhere that details things like inits being strict?
08:20:39 <Berengal> @src inits
08:20:39 <lambdabot> inits []     =  [[]]
08:20:40 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
08:20:52 <aavogt> > inits $ 1:2:undefined
08:20:53 <lambdabot>   [[],[1]* Exception: Prelude.undefined
08:21:28 <ziman> why isn't it [] : map (x:) (inits xs) ?
08:21:41 <Berengal> Besides, you need two numbers to get started on the fibs anyway
08:21:55 <Berengal> > let s = 0:1: [sum x | x <- tail (inits s)] in s
08:21:56 <lambdabot>   [0,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1...
08:22:10 <evanbd> Berengal: It's not the fibs, it's [1,1,2,4,8,16..] if it's working the way I want
08:22:21 <Berengal> Oh right
08:22:46 <evanbd> > let s = 1:1: [sum x | x <- tail (inits s)] in s
08:22:48 <lambdabot>   [1,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:23:20 <mmorrow> , fix ((1:) . fmap (join (+)))
08:23:21 <lunabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
08:23:45 <mmorrow> , 1 : fix ((1:) . fmap (join (+)))
08:23:46 <lunabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131...
08:24:06 <mmorrow> , fix ((0:) . scanl (+) 1)
08:24:07 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
08:25:06 <huntse> Is hackage down then?  I can't seem to reach it.
08:25:33 <Saizan> ziman: because it looks nicer that way i guess
08:26:11 <Saizan> mh, that means we could make init lazier
08:26:47 <Saizan> inits xs = [] : case xs of [] -> []; (x:xs) -> map (x:) (inits xs)
08:28:50 <evanbd> Saizan: Nifty.  That works.
08:29:16 <evanbd> Now I'm confused as to what makes the normal inits strict and that not :)
08:29:44 <FunctorSalad> that one is nonempty even for undefined arg
08:29:58 <Saizan> the pattern match happens in the subexpression here
08:30:25 <Saizan> so it doesn't need to look at the input at all to return the first element of the result
08:31:45 <FunctorSalad> > let inits xs = [] : case xs of { [] -> []; (x:xs) -> map (x:) (inits xs) } in inits [3,4,5]
08:31:46 <lambdabot>   [[],[3],[3,4],[3,4,5]]
08:32:46 <voker57> @topic-cons #haskell "Hackage is down"
08:33:08 <Saizan> mode +t
08:34:31 <voker57> echo "documentation: True" >> ~/.cabal/config ftw
08:34:40 <evanbd> OK, thanks guys.  Now I have a different set of questions, but I need to run...
08:35:21 <roconnor> voker57: http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
08:36:22 <Saizan> mirror :O
08:36:27 <voker57> cool
08:36:34 <voker57> but i still like local docs more
08:36:58 <Saizan> are you using the central index too?
08:38:33 <Berengal> Nice, reverse deps
08:38:34 <voker57> hey, it _doesn't_ have any docs
08:49:16 <roconnor> oh this reverse dependencies list is a "popularity" ranking
08:49:31 <roconnor> base is quite popular
08:50:58 <roconnor> oh, except that applications end up at the bottom
08:51:10 <roconnor> so this ranking is only potentially useful for libs
08:52:20 <Jagwire> how do you express a list of a specific type without using the form x:xs ?
08:52:32 <Jagwire> like as an argument...
08:52:55 <Heffalump> just use any variable name
08:52:59 <Twey> Jagwire: I don't think you mean what you think you mean.  Can you rephrase and/or provide sample code?
08:53:06 <Heffalump> type inference will probably figure it out
08:55:31 <Jagwire> Sure
08:55:55 <Jagwire> f :: [S] -> [S] -> Bool
08:56:17 <Jagwire> f ((NT x):xs) (NT ys) = ...
08:56:27 <Jagwire> NT is obviously a constructor for S
08:56:53 <Jagwire> and the first term is fine, but the second term is giving me grief
08:57:12 <Berengal> The second isn't a list they way you've written it there
08:57:35 <Jagwire> is it always no matter what supposed to be written like x:xs ?
08:57:55 <Berengal> No, you could just do 'ys
08:58:06 <Jagwire> but ys needs to specifically be of NT
08:58:09 <Twey> No, of course not â€” a list is just another value, and can be matched to a variable the same as any other value
08:58:22 <Twey> But if the second argument there is an NT, then it's not a list, is it?
08:58:23 <Berengal> Jagwire, the type signature already determines that
08:59:03 <Jagwire> but if I leave it  as ys, I get type errors
08:59:09 <Twey> (:) is just another constructor.  You can write f ((:) (NT x) xs) (NT ys) if that makes it any clearer for you.
08:59:31 <Berengal> Jagwire, then you've got type errors somewhere else
08:59:57 <Twey> The â€˜NT ysâ€™ has no (:) in it, so it's not a list, so the compiler complains (because you *told* it that the second argument is a list)
09:00:35 <Twey> If you just say â€˜f ((NT x) : xs) ysâ€™ then the whole of the second argument will be bound to â€˜ysâ€™
09:00:57 <Twey> Which means that â€˜ysâ€™ will be a list, and your function must treat it as one
09:01:14 <Jagwire> right, so I should be able to use it with notElem
09:01:37 <Twey> Sure
09:01:41 <Twey> foo `notElem` ys
09:01:59 <Jagwire> BUT...
09:02:06 <Jagwire> ys is a list of S
09:02:13 <Twey> Yes it is
09:02:20 <Jagwire> and x is it's own variable inside the NT constructor
09:02:49 <Jagwire> is there a way to pick apart ys?
09:02:52 <Twey> Errr, awkwardly phrased, but I'll assume that you mean that â€˜xâ€™ is the value of an NT-wrapped variable
09:03:02 <Jagwire> correct.
09:03:10 <Jagwire> my apologies.
09:03:14 <Twey> Of course â€” the same way you picked apart the first argument
09:03:22 <Berengal> I assume you're trying to do something like x `notElem` ys?
09:03:28 <Twey> You can do ((NT y) : ys)
09:03:29 <Jagwire> yes, Berengal.
09:03:37 <Twey> To get the first value in y
09:04:15 <Berengal> Jagwire, well, x is not of type S, so you can't check if it's in ys. You can check "NT x `notElem` ys" though
09:04:42 <Jagwire> I like that idea
09:05:04 <Berengal> Of course, is there a reason you need the x at all, or do you just need the NT x?
09:05:34 <Berengal> Because if you don't need the x itself, you could just do 'f (x:xs) ys = ...'
09:06:00 <Jagwire> I need to make sure it's an NT
09:06:05 <huntse_> hi there, so I can see where I can configure my .cabal/config to have a hackage mirror, but I can't seem to find any actual mirrors, in spite of much googling.
09:06:09 <Berengal> Ah, okay
09:06:14 <Jagwire> because I'll be passing the function a list of different types of S
09:06:23 <Twey> Jagwire: Then try f (x@NT{} : xs) ys
09:06:25 <burp> wow, hackage is still down
09:06:28 <dcoutts> huntse_: I don't think we have any mirrors atm
09:06:34 <Twey> burp: *sad*
09:06:45 <dcoutts> burp: it's unlikely to change 'til Monday morning
09:06:50 <huntse_> dcoutts: aah. Thanks.  I would be very happy to set one up.
09:06:56 <burp> ok :(
09:07:01 <dcoutts> when the IT admin gets in
09:07:14 <huntse_> But of course, without hackage I can't download the big tarball of the packages.
09:07:17 <Berengal> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
09:07:19 <huntse_> :-(
09:07:30 <huntse_> Computers suck so bah.
09:07:37 <huntse_> Berengal- Thanks.
09:07:52 <dcoutts> that doesn't have the tarballs, only the meta-data
09:07:59 <Berengal> Not sure if it'll work with cabal though. someone just posted it a little while ago
09:08:00 <Jagwire> with NT x `notElem` ys, I get undefined type constructor NT
09:08:06 <Berengal> dcoutts, ah, that sucks
09:08:15 <dcoutts> Berengal: it would work, if it had the tarballs
09:08:31 <Berengal> dcoutts, it even links to them...
09:08:33 <Berengal> Oh well
09:08:58 <dcoutts> sure since it's just copying the cgi scripts
09:09:01 <dcoutts> so it has links
09:09:03 <Berengal> Some day we'll have mirrors everywhere, everyone will be writing in functional languages and ice-cream will be free!
09:09:05 <dcoutts> but not the full archive
09:09:13 <dcoutts> Berengal: :-)
09:09:29 * dcoutts notes the new hackage server impl will make mirroring easier too
09:10:32 <dcoutts> I could set the new impl up as a mirror but unfortunately I don't have a current snapshot of the tarballs, only one from a few months ago
09:11:35 <Jagwire> mmm, actually that was my bad
09:12:00 <Jagwire> Berengal, pm?
09:14:55 * Jagwire guesses not :(
09:17:14 <Berengal> Jagwire, sorry, was away a couple of minuts
09:17:21 <Jagwire> you're fine
09:26:36 <burp> any mirror for http://darcs.haskell.org/c2hs/?
09:26:43 <burp> erm darcs.haskell.org?
09:33:54 <FunctorSalad> would haskell make a good proof assistant? :) (at the value level, not at the type level)
09:34:00 <McManiaC> hey, how do i get the previous element of an element in a Map?
09:34:14 <FunctorSalad> you could use the full power of haskell to manipulate proof objects...
09:34:14 <Twey> McManiaC: You don't â€” maps are unordered
09:34:32 <McManiaC> :S
09:34:39 <Zao> Grab the keys, sort them, find yours, take the preceeding key.
09:34:41 <FunctorSalad> (random crazy idea)
09:34:41 <aavogt> they are ordered by keys though
09:34:45 <Twey> You can convert it with toAscList based on the values of the keys and then pick it out of that list, if you like
09:34:54 <McManiaC> the next element of a map with a lower keyâ€¦
09:35:00 <Twey> aavogt: They are internally, but shh.  People aren't supposed to know that.  ;)
09:35:15 <Twey> (which is why it's bad that the key needs to be Ord)
09:35:23 <Phyx-> hmm for some reason i keep thinking i'm generating something not needed.. http://phyx.pastebin.com/d40315871
09:36:04 <Berengal> I'm thinking it should be possible to easily her subtrees of a Map
09:36:10 <Berengal> get*
09:36:48 <Twey> Subtrees?  o.@
09:36:51 <Twey> Maps are flatâ€¦
09:37:00 <Berengal> Not internally
09:37:17 <Berengal> But yes, slices if you will
09:37:17 <aavogt> McManiaC: I think some combination of split / splitLookup and findMax / findMin can probably do the same as converting to an ordered list (and doing a search on that list)
09:37:29 <aavogt> @type M.splitLookup
09:37:31 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, Maybe a, M.Map k a)
09:38:02 <Twey> I don't see why Map wasn't exposed as OrderedMap or something and then specialised
09:38:03 <aavogt> Berengal: subtrees in the sense of splitLookup?
09:38:03 <Twey> Would make more sense
09:38:22 <Berengal> aavogt, that does seem interesting
09:38:52 <dons> Twey: what form of specialization?
09:39:13 <McManiaC> aavogt: perfect! thx
09:39:23 <Berengal> something like restrictMap map lower higher = let (_,_,map') = splitLookup map lower; (map'',_,_) = splitLookup map higher in map''
09:39:27 <Twey> dons: Mostly, hiding everything that gives away the fact that it's ordered
09:39:40 <FunctorSalad> o_o
09:39:57 <Berengal> What's the complexity of splitLookup?
09:40:35 <FunctorSalad> the haddock might say
09:40:51 <aavogt> O(log n). The expression (splitLookup k map) splits a map just like split but also returns lookup k map.
09:42:52 <Berengal> So restrictMap should be O(log n) as well then
09:43:27 <Berengal> So it's a somewhat easier to use, less powerful version of IxSet
09:45:03 <Phyx-> @pl fromJust.(\x-> lookup x list `mplus` (guard (x `elem` vars) >> Just "void*") `mplus` Just x)
09:45:04 <lambdabot> fromJust . ap (mplus . ap (mplus . flip lookup list) ((>> Just "void*") . guard . (`elem` vars))) Just
09:45:11 <Phyx-> that's not really better...
09:45:17 <Twey> Eww
09:45:25 <Twey> Pointless isn't always :th
09:45:27 <Twey> :Ã¾**
09:46:00 <Phyx-> lol, is there a nicer way or writing that?
09:46:15 <aavogt> Phyx-: fromJust (y `mplus` Just x) === fromMaybe x y
09:46:40 <aavogt> @check \x y -> fromJust (y `mplus` Just (x::Bool)) == fromMaybe x y
09:46:41 <lambdabot>   "OK, passed 500 tests."
09:46:46 <Phyx-> ah ok, so i can simplify that a bit
09:47:30 <aavogt> since `fromJust Nothing' can happen, while fromMaybe is safe on its own
09:47:54 <Phyx-> thought fromJust Nothing can't happen in my first expression either
09:48:27 <aavogt> yeah, it can't. But why put the burden of proving that on the person reading your code?
09:48:33 <Phyx-> true
09:49:01 <Phyx-> made it
09:49:03 <Phyx-> \x-> fromMaybe x  (lookup x list `mplus` (guard (x `elem` vars) >> Just "void*"))
09:50:39 <Phyx-> or
09:50:40 <Phyx-> \x-> fromMaybe (if (x `elem` vars) then "void*" else x)  (lookup x list)
09:51:21 <Phyx-> i guess the second one is clearer
09:56:23 <dons> mm. google chrome is pretty usable
09:57:00 * SamB_XP_ wonders if the fixed installer has made it's way to the official Chrome installer download link
09:57:10 <Berengal> dons, I've had some javascript problems with it
09:57:28 <SamB_XP_> Berengal: it happens sometimes ... what sort of problems ?
09:57:30 <Raevel> my problem is that i don't have an account
09:57:48 <SamB_XP_> methods that didn't do the same thing as in Mozilla, or?
09:57:59 <dons> the safe sandboxing is intuitive to a haskell person
09:58:07 <dons> the renderer process can't do IO.
09:58:13 <dons> we should do bindings to webkit
09:58:14 <Berengal> SamB_XP_, wouldn't run at all, even though it worked in FF, IE and Opera
09:58:23 <Berengal> (IE 6, 7 and 8)
09:58:35 <SamB_XP_> Berengal: what do you mean, wouldn't run at all ?
09:59:21 <Jagwire> what's the easiest way to call a list of functions within another one? Just use an if tree?
09:59:33 <dolio> mmorrow: http://code.haskell.org/~dolio/agda-share/html/NestPoly.html
09:59:34 <SamB_XP_> also, did it work in ... what's apple's browser called again?
09:59:42 <Berengal> SamB_XP_, well, I didn't debug or anything, but none of the JS would run. Not the framework-generated, nor the small handwritten ones that simply changed the colour of a span
09:59:46 <SamB_XP_> or Konq?
09:59:57 <Berengal> Only tried on windows machines
10:00:04 <Phyx-> SamB_XP_: Safari?
10:00:10 <SamB_XP_> Phyx-: ah, yeah, that was it
10:00:16 <Berengal> No unix except on servers at work :(
10:00:20 <dons> mmorrow: what happend with the specialized IntMap you were working on?
10:00:20 <SamB_XP_> Safari looks really damn odd on Windows, let me tell you ;-P
10:00:24 * dons wants to see code
10:00:33 <Jagwire> if f1 then (if f2 then (if f3 then (if f4 then ... else ... ) else ... ) else ...) else ...
10:00:35 <Phyx-> SamB_XP_: what apple software doesn't look odd on windows?
10:00:51 <SamB_XP_> Phyx-: uh, CUPS?
10:00:56 <Jagwire> java console...
10:01:00 <Phyx-> wth is CUPS?
10:01:07 <Jagwire> call ur parents soon :D
10:01:19 <Phyx-> (-.-)
10:01:27 <Jagwire> xD
10:01:31 <SamB_XP_> it's that printing system they bought
10:01:51 <SamB_XP_> actually, I doubt it *runs* on Windows
10:02:00 <SamB_XP_> at least, probably not very well or often
10:03:16 <yb> can anyone help me with this error message? "Could not find module `Control.Monad.State': it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2".  I want to (try and) use the State monad.
10:04:21 <Phyx-> yb: you have to hide one of packages since both have a module Control.Monad.State. or use a cabal file to compile
10:04:23 <Berengal> yb, 'import "monads-fd" Control.Monad.State'
10:04:30 <Twey> Jagwire: If all the â€˜elseâ€™ clauses are different and unpredictable, then yes
10:04:32 <Phyx-> oh, that works?
10:04:39 <Twey> Otherwise, you probably want something like a monad or a functor
10:04:48 <yb> i'll let you know if it works in a mo :)
10:05:08 <Twey> Apple bought CUPS?
10:05:11 <Twey> Huh
10:05:20 <Berengal> yb, you probably need {-# LANGUAGE PackageImports #-} or something like that for it to work. ghc will tell you the exact name
10:05:24 * Phyx- thinks Haskell's module system is pretty odd...
10:05:26 <yb> Package-qualified imports are not enabled; use -XPackageImports
10:05:41 <Phyx-> ah, so it's a GHC extension
10:05:49 <Phyx-> GHC language Extension rather*
10:05:49 <yb> yep, but I don't actually know what that means I should do
10:05:53 <Berengal> yb, yeah, put what I wrote on the very top of the module
10:06:00 <yb> ok
10:06:14 <Berengal> or run it with the -XPackageImports flag
10:06:25 <yb> with the comments?
10:06:47 <Berengal> Phyx-, I just recently found out about it. Imported both mtl Control.Monad.Trans and transformers Control.Monad.Trans in the same module (qualified), and used both. Was nice
10:07:00 <Berengal> yb, yes, it's called a compiler pragma
10:07:20 <yb> cool, i think that worked. Just my own errors now :)
10:07:24 <yb> thanks very much
10:07:53 <Phyx-> Berengal: cool, I'll have to keep that one in mind, it's handy
10:07:59 <Berengal> yb, if you know you're never going to use one of those packages, you can do 'ghc-pkg hide foo' on the command line to permanently hide it (until you ghc-pkg expose it again)
10:08:30 <yb> i've no idea what's in those packages, I'm still n00b
10:08:31 <Berengal> You can still install other packages that depend on it, because cabal will explicitly state which packages should be visible, which works even for hidden ones
10:09:03 <yb> and I can't get onto haskell.org to have a look, some dead server somewhere on the interweb...
10:09:12 <Berengal> yb, yeah, it's down :(
10:09:12 <IvatarHome> is there a backup location for haskell platform downloads?  hackage.haskell.org doesn't seem to be working very well...
10:09:16 <IvatarHome> ahh
10:09:24 <Phyx-> Haskell.org works fine here
10:09:54 <Berengal> haskell.org works, but not hackage, and presumably some of the other parts of that site as well
10:10:00 <Phyx-> ah
10:10:09 <yb> thanks for the tip Berengal
10:10:17 <Phyx-> yeah, seems hackage is dead
10:10:40 <SamB_XP_> dons: do you know the masters of hackage.haskell.org ?
10:10:52 <yb> it dies somewhere around Oregon :)   easystreet.com is the last server I can get
10:14:18 <dons> yes, there is a problem with the hackage server.
10:14:21 <dons> we're investigating
10:17:36 <Phyx-> gah... why does weekend tv suck so bad... don't they realise people are at home in the weekends...
10:18:45 <mmorrow> dons: the one using the x86_64 bsr instruction, or the "WordMap"?
10:19:10 <mmorrow> dons: the former i got sidetracked and haven't benchmarked yet, the latter is on my todo list
10:19:34 <copumpkin> WordMap ftw!
10:19:58 <copumpkin> GMPNaturalMap ftw!
10:20:13 <Phyx-> BumpMap ftw!
10:20:15 <monochrom> TransfiniteOrdinalMap
10:20:22 <mmorrow> dons: (with the bsr one, i had to modify the IntMap.s, so the modification only exists at that level)
10:20:48 <mmorrow> using-cpp-macros-to-parameterize-the-intmap-module ftw!!@
10:21:06 <opqdonut> cop-macros?
10:21:32 <mmorrow> "do you why i pulled you over?"
10:22:17 <SamB_XP_> hmm, I wish csrss.exe's console was better at sending SIGSUSP ...
10:22:30 <SamB_XP_> or do I mean SIGSTOP ...
10:24:45 <mmorrow> dolio: awesome
10:24:59 <mmorrow> dolio: is --universe-polymorphism new?
10:25:05 <dolio> Relatively.
10:25:13 <dolio> And still incomplete, really.
10:25:21 <mmorrow> interesting
10:25:47 <dolio> Because to do everything you might want, you need ways to lift things up in the universe hierarchy.
10:26:06 <mmorrow> heh, that reminds me of my brief Agda code that imports ByteString and can do IO.. ;)
10:26:08 * mmorrow finds it
10:26:16 <dolio> At least, since Agda doesn't automatically have rules like A : Set i => A : Set (i + k).
10:27:01 <mmorrow> dolio: the ability to add arbitrary axioms seems to me like the best thing it could provide
10:28:24 <dolio> You can assume arbitrary axioms, but just assuming them wouldn't work the right way.
10:28:45 <dolio> Like, 'up (A -> B) = (up A) -> (up B)'.
10:29:14 <dolio> You could assume more rules for that, of course, but then you'd be littering your code with conversions, and they'd all be non-computational.
10:29:20 <mmorrow> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=584
10:29:33 <mmorrow> dolio: ah i see. hmm
10:32:38 <dolio> Anyhow, I think their current plan is to have the conversions, but have the system insert them automatically whenever possible.
10:33:48 <mmorrow> dolio: ah, so this is more approached from the direction of modifying the input into a form that is ok with the existing system, rather than an extension of the underlying system itself
10:33:57 <mmorrow> (?)
10:34:45 <dolio> Well, the conversions don't exist at all yet. Only the Level builtin and Set i.
10:35:10 <dolio> Which lets you do a lot of stuff, but not everything.
10:35:27 <mmorrow> dolio: btw, blackboard bold FTW! (â„•)
10:36:00 <dolio> Like, one example they have on the wiki for universe polymorphism has some term algebra Monad datatype, and defining join in terms of >>= requires futzing around with universe levels.
10:36:27 <mmorrow> dolio: are there any documents/posts/descriptions of the current state of affairs/considerations/etc wrt this and agda?
10:36:34 <mmorrow> * .. that are online?
10:36:44 <mmorrow> oh nice
10:36:46 <dolio> Not much.
10:36:56 <SamB_XP_> mmorrow: there's been some messages on the list ...
10:37:07 <koeien> is hackage down for anybody else?
10:37:12 <dolio> They mention it briefly in the AIM10 notes.
10:37:13 <SamB_XP_> koeien: yes
10:37:16 <SamB_XP_> it is officially down
10:37:19 <mmorrow> dolio: ah, i said "oh nice" before i read the second half of that sentence
10:37:21 <koeien> ok ty
10:37:26 <SamB_XP_> the company that runs it is investigating
10:38:23 <dolio> mmorrow: At least, I think it requires the conversions. I modified my little pure type system checker to have universe polymorphism, and I wasn't able to get their example to type, since I didn't implement conversions, either.
10:38:51 <dolio> Anyhow, time for some food.
10:39:05 <mmorrow> dolio: oh, i've been meaning to ask you ever since you pasted a link to some of your agda code the other week. what program is doing the (code->highlighted-html-*with-linked-idents*) conversion?
10:39:20 <dolio> agda --html
10:39:30 <mmorrow> i like it, and that'd be really handy if HsColour linked idents optoinally
10:39:47 <mmorrow> dolio: ah nice, so i guess just snake it from the agda code ;)
10:40:04 <dolio> Good luck. :)
10:40:26 <mmorrow> dolio: ah nice, that'd be really cool if you turned that PTS checker into a library
10:42:27 <mmorrow> dolio: i like that color-scheme too
10:42:38 <mmorrow> is that the default?
10:42:52 * mmorrow steals dolio's .css
10:44:57 <mcfunley> http://downforeveryoneorjustme.com/hackage.haskell.org
10:46:07 <mmorrow> dolio: is there any particular reason you're not using â„• for `Level'?
10:46:37 <brad_larsen> I've been looking at the work on stream fusion & iteratees recently.
10:46:51 <mmorrow> dolio: as in, induction : âˆ€{i : â„• } {P : â„• â†’ Set i}
10:47:10 <brad_larsen> We have Data.Foldable, but there doesn't seem to be a Data.Streamable or equivalent, along with instances for the common collections
10:49:54 <brad_larsen> Is it just because no one has written Data.Streamable?  I want to be able to describe my traverals/loops over, e.g., Data.Map using an iteratee/enumerator.
10:51:02 <brad_larsen> on a related note, is there no way to implement new instances for Data.Map without patching the library?
10:51:08 <mmorrow> brad_larsen: you'd need to modify the Map/etc modules and add functions to do monadic maps/folds/etc over them, since those modules don't currently have those, and the types are abstract
10:51:08 <brad_larsen> its internals are not exposed
10:51:17 <mmorrow> right
10:51:50 <brad_larsen> kind of annoying.  I like what is done with Data.ByteString, where there is an internal module
10:51:58 <brad_larsen> that you can use to write new instances
10:52:11 <mmorrow> so you'd need to make your own fork (and try to get your modifications merged into the libraries modules if desired)
10:52:30 <brad_larsen> although, I think there is some issue in certain versions of GHC with optimizations breaking when modules are defined like that?
10:52:40 <mmorrow> defined like what?
10:52:49 <brad_larsen> data.bytestring exposes its internals
10:52:54 <brad_larsen> Data.ByteString.Char8.Internal, or something
10:53:07 <brad_larsen> so you could import that and write new instances, etc
10:53:25 <mmorrow> hmm, not sure how you mean (wrt optimizations breaking), but i can't think of how that could be the case
10:53:36 <brad_larsen> something regarding inlining?
10:53:39 <brad_larsen> i don't know
10:53:49 <brad_larsen> just thought I heard something along those lines
10:54:06 <mmorrow> anything like that i'd consider to be a bug
10:54:17 * brad_larsen shrugs
11:06:01 <codnik> i'm reading real world haskell's chapter on I/O and have a question: with lazy output a program will read a file, process and write to an output file in parts (not the whole file at once) freeing memory as it goes?
11:06:26 <codnik> if so, what happens if you are doing two different things with the input and writing to two different files? does it read, process for both and write to both then frees memory or does it do it one at a time?
11:07:39 <Botje> depends how your program is structured
11:10:42 <titto> can you access http://hackage.haskell.org/ ?
11:10:49 <koeien> titto: no, down
11:12:16 <titto> so what happened to hackage?
11:14:13 <burp> bill not paid
11:14:55 <SamB_XP_> burp: I think galois would have noticed if they forgot to pay their 'net bill!
11:14:59 <codnik> Botje: say you have inpStr <- readFile "input.txt" and then process and write two files with writeFile "output.txt" (map toUpper inpStr) and writeFile "output2.txt" (map processData inpStr) where processData does some other stuff to the input
11:15:10 <SamB_XP_> dons: any word ?
11:15:29 <burp> SamB_XP_: oh, didn't know galois was hosting/paying for it
11:22:41 <warren__> is hackage down today for some reason? I can't connect
11:22:50 <nha_> yea
11:22:56 <nha_> was working a few hours ago
11:23:42 <warren__> I guess I try back later
11:23:46 <Botje> codnik: i _think_ it'll keep the file in memory..
11:24:09 <sereven> no hayoo no hackage .... if c.h.o, hoogle or lambdabot dies too will have to declare a day of mourning and go to the pub to discuss web reliability I guess.
11:26:23 <SamB_XP_> sereven: or, discuss switching to plan9 or NT ;-P
11:26:33 <SamB_XP_> not that win32 crap -- just NT ;-P
11:28:12 <codnik> Botje: hmm ok thanks
11:31:48 <Botje> codnik: actually, on closer inspection it looks like it'll process the input file twice.
11:32:08 <sereven> SamB_XP_: I can just see the reddits now, "code.haskell.org moves to git on NT servers" Maybe should wait for 1 Apr 2010 for that one.
11:33:00 <phr1> what's the appropriate GHC version to install on a new machine these days?
11:33:13 <phr1> i.e. is 6.10.x the most solid by now?
11:33:21 <SamB_XP_> phr1: the one that comes with the Platform ?
11:39:44 <phr1> using "yum install ghc" on fedora 11... it's installing 6.10.3 which i hope is ok.
11:40:10 <brad_larsen> is hackage down?
11:40:15 <SamB_XP_> is that the latest 6.10.4?
11:40:18 <SamB_XP_> brad_larsen: yes
11:45:04 <dolio> mmorrow: LEVEL is a separate built-in. I don't know if you could designate it as the same built-in as NATURAL or not.
11:46:09 <SamB_XP_> dolio: what I read was that you could but it would be unutterably stupid
11:46:09 <phr1> samB, the current fedora package is 6.10.3, does that have no Platform?  i just installed it and notice that it didn't install cabal
11:46:25 <SamB_XP_> dolio: that is, things were assumed to break very badly if you actually *tried* that
11:46:34 <dolio> Ah.
11:47:22 <dolio> To be honest, I'm already a bit wary about Level living in Set0 at all, although I can't think of an actual problem that'd cause.
11:47:47 <SamB_XP_> dolio: it lives in a Set ???
11:48:00 <SamB_XP_> I'd have it live in \box
11:48:11 <dolio> Yes. data Level : Set where zero : Level ; suc : Level -> Level
11:48:12 <SamB_XP_> if I recall the notation correctly
11:49:04 <dolio> Well, the closest thing to box is Set\omega, I think. But it seems to produce errors when that actually gets referred to anywhere.
11:49:15 <SamB_XP_> oh?
11:49:28 <dolio> Like, if you ask the type of \(i : Level) -> Set i, it fails with a complaint about Set\omega not being a valid type.
11:49:30 <SamB_XP_> so what the heck is this Set 0 thing ?
11:49:47 <SamB_XP_> ... or is that just what we called Set ?
11:50:00 <dolio> Er, (i : Level) -> Set i. The lambda expression obviously has that as a type.
11:50:20 <dolio> Set0 gets abbreviated as Set, yes.
11:50:58 <dolio> And under --universe-polymorphism SetN is an alias for Set N, where N is the appropriate Level.
11:51:01 <SamB_XP_> haven't actually done any Agda lately
11:52:01 <dolio> mmorrow: Also, my pts thing is essentially a library, I just haven't written a .cabal for it. Most of the stuff is in Language.PTS.*, though, and then I wrote a REPL on top of it.
11:54:31 <raim0_> is hackage.haskell.org down?
11:54:52 <SamB_XP_> raim0_: yes
11:55:06 <raim0_> crap, where can I download haskell platform now?
11:55:17 <SamB_XP_> hmm, someone should temporarily change @faq to say "Yes, hackage.haskell.org is down!" ;-P
11:56:08 <SamB_XP_> hmm, maybe we should put it on pirate's bay ;-P
11:56:08 <mmorrow> dolio: nice, i'll have to read through it.
11:57:20 <jimi_hendrix> can someone explain why i cannot do  zipWith (\x y -> print [x,y]) ['a'..'z'] ['a'..'z']
11:57:24 <paolino> anyone has a tarball of rosezipper around ?
11:57:37 <raim0_> SamB_XP_: that would be a great idea if user could somehow check the authencity of the package?
11:57:43 <FunctorSalad> jimi_hendrix: you can, but it will build a list of IO actions
11:57:59 <FunctorSalad> use "sequence" to turn it into one action that executes all the actions
11:58:11 <pabloh> why this code doesn't work ?
11:58:13 <pabloh> foldr ((&&) . fst) True . zip
11:58:19 <jimi_hendrix> :t sequence
11:58:19 <SamB_XP_> dcoutts: do you have a copy of the Haskell Platform installer ?
11:58:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:58:57 <paolino> :t foldr ((&&) . fst) True . zip
11:58:58 <lambdabot>     Couldn't match expected type `[(Bool, b)]'
11:58:58 <lambdabot>            against inferred type `[b1] -> [(a, b1)]'
11:58:58 <lambdabot>     Probable cause: `zip' is applied to too few arguments
11:59:11 <jimi_hendrix> FunctorSalad, so example please?
11:59:21 <paolino> :t foldr ((&&) . fst) True
11:59:23 <lambdabot> forall b. [(Bool, b)] -> Bool
11:59:24 <FunctorSalad> > let foo = sequence [modify (+1), modify (*2)] in runState foo 10
11:59:25 <lambdabot>   ([(),()],22)
11:59:31 <SamB_XP_> or ... who else is trusted ?
11:59:32 <FunctorSalad> @ jimi_hendrix
11:59:32 <pabloh> can un make zip be aplied with 2 arguments ?
11:59:57 <paolino> :t (foldr ((&&) . fst) True .) . zip
11:59:59 <lambdabot> forall b. [Bool] -> [b] -> Bool
12:00:13 <jimi_hendrix> paolino, tu parli italino?
12:00:20 <paolino> zi
12:00:30 <paolino> su #haskell.it
12:01:21 <jimi_hendrix> Non ho visto que canale
12:01:32 <FunctorSalad> @let commutator x y = liftM2 (-) (x >> y) (y >> x)
12:01:34 <lambdabot>  Defined.
12:01:34 <jimi_hendrix> (sono un studente di italiano)
12:02:22 <jimi_hendrix> FunctorSalad, uhh that confused me?
12:02:52 <FunctorSalad> jimi_hendrix: uh that last definition was just me fooling around, nothing to do with your question
12:02:53 <mmorrow> dolio: (i had to guess a license so cabal would build it) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4428#a4428
12:03:09 <mmorrow> dolio: also, sweet email address
12:03:29 <jimi_hendrix> no the let foo thing, whats the runState part
12:04:00 <jimi_hendrix> and in the returned list, why are there two empty tuples
12:04:42 <dolio> I guess I should add something like that.
12:04:46 <FunctorSalad> jimi_hendrix: because "modify" returns ()
12:04:52 <mmorrow> dolio: do it!
12:05:07 <FunctorSalad> the first component of the result is the value, the second is the end state
12:05:26 <mmorrow> dolio: that's an instantiation of my .cabal template that i use for pretty much everything..
12:05:29 <jimi_hendrix> ok, and what does modify do?
12:05:39 <dolio> I have a fork that implements Luo's ECC, too, although you can't see it from the code.haskell.org web server.
12:05:43 <paolino> (archlinx is useful when hackage is down)
12:05:53 <paolino> :t modify
12:05:55 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
12:05:55 <FunctorSalad> jimi_hendrix: I just used State as an example monad because IO is banned in lambdabot
12:05:57 <mmorrow> dolio: also, this makes pretty docs with highlighted source and source links:
12:06:09 <dolio> At least, ECC without inductive types.
12:06:11 <jimi_hendrix> uhu
12:06:14 <FunctorSalad> ("modify" modifies the state in a state monad)
12:06:19 <dolio> Although the parser's kind of broken.
12:06:23 <mmorrow> dolio: ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
12:06:30 <mmorrow> and a hoogle file too
12:06:39 <jimi_hendrix> FunctorSalad, so can you quickly cook up the version that would do my zipWith thing ( zipWith (\x y -> print [x,y]) ['a'..'z'] ['a'..'z'] )
12:06:57 <FunctorSalad> sequence ( zipWith (\x y -> print [x,y]) ['a'..'z'] ['a'..'z'] )
12:07:08 <mmorrow> dolio: ah nice, link to background?
12:07:23 <mmorrow> @google Luo ECC
12:07:25 <lambdabot> http://www.cs.rhul.ac.uk/~zhaohui/type.html
12:07:25 <lambdabot> Title: Publications by Z. Luo
12:07:28 <mmorrow> handay
12:08:51 <mmorrow> dolio: his module-related papers sound interesting too
12:09:05 <FunctorSalad> > let print = tell . show in runWriter (sequence ( zipWith (\x y -> print [x,y]) ['a'..'z'] ['a'..'z'] ))
12:09:06 <lambdabot>   ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
12:09:17 <FunctorSalad> > let print = tell . show in execWriter (sequence ( zipWith (\x y -> print [x,y]) ['a'..'z'] ['a'..'z'] ))
12:09:18 <lambdabot>   "\"aa\"\"bb\"\"cc\"\"dd\"\"ee\"\"ff\"\"gg\"\"hh\"\"ii\"\"jj\"\"kk\"\"ll\"\"...
12:09:59 <dolio> mmorrow: ECC is a dependent type theory with impredicative Prop, infinite universe hierarchy, and strong sums.
12:10:04 <mmorrow> dolio: happy+alex ftw
12:10:15 <mmorrow> dolio: oh interesting
12:10:28 <dolio> And it has an inclusion relation Type[i] < Type[j].
12:10:55 <FunctorSalad> dolio: 'extensional'?
12:11:01 <mmorrow> dolio: what is the nidex type there?
12:11:04 <mmorrow> *index
12:11:13 <FunctorSalad> oh wait that was "ETT" I think
12:11:36 <mmorrow> dolio: and also, is it a partial or total order?
12:11:49 <dolio> No. It doesn't have any built-in equality type or anything. You just simulate it with Eq A x y = (P : A -> Prop) -> P x -> P y.
12:12:22 <FunctorSalad> btw is there any alive extensional dependent type theory thingy?
12:12:30 <mmorrow> ah, i `in` Ï‰
12:12:53 <paolino> (it is galois.com which is down)
12:13:05 <dolio> mmorrow: It has an infinite number of universes Type[i] : Type[j]. But anything with type Type[i] can also be used where a Type[j] is expected, if i < j.
12:13:14 * mmorrow wonders why the index isn't ever just an arbitrary category
12:13:15 <dolio> Er, Type[i] : Type[i+1].
12:13:42 <FunctorSalad> mmorrow: a preorder is kinda a category with proof irrelevance ;)
12:13:53 <dolio> And there's also Pi x:A. B < Pi x:A'. B' if A ~= A' and B < B', and so on.
12:14:20 <mmorrow> FunctorSalad: true, but not all categories are iso to preorders
12:14:40 <mmorrow> (fsvo of iso there)
12:14:58 * mmorrow tries to parse that
12:15:07 <ddarius> mmorrow: All categories are equivalent to their nerve categories which are preorders.
12:15:35 <mmorrow> Pi (x:A).  B  <  (Pi (x:A').  B')       if A ~= A' and B < B'
12:15:40 <mmorrow> ddarius: interesting
12:15:48 <ddarius> mmorrow: Not really.
12:15:56 <mmorrow> not interesting
12:16:01 <FunctorSalad> (I meant my statement in the sense "if you consider hom(A,B) as the Prop 'A <= B' and its elements as proofs")
12:16:01 <ddarius> I'd say the point of CT is to avoid such quotienting.
12:16:01 <mmorrow> :)
12:16:16 <mmorrow> what is it about preorders as opposed to postorders?
12:16:29 <mmorrow> the asymmetry bothers me
12:16:35 <FunctorSalad> a preorder is a reflexive transitive relation
12:16:44 <FunctorSalad> "pre" because antisym is missing
12:16:48 <ddarius> mmorrow: "pre" as in "before" an order.  Its something that isn't quite an ordering yet.
12:16:58 <mmorrow> oh
12:17:13 <mmorrow> i wasn't even thinking of the right thing here...
12:17:52 * mmorrow was equating preorder with a category with an initial object
12:18:21 <mmorrow> oh, "order theory"
12:18:45 <FunctorSalad> ddarius: you don't mean this nerve do you? http://en.wikipedia.org/wiki/Nerve_%28category_theory%29
12:20:41 <ddarius> Yeah, I meant skeleton actually http://en.wikipedia.org/wiki/Skeleton_%28category_theory%29 it's related to nerve categories though.
12:20:58 <mmorrow> the definition of preorder on wikipedia makes it sound like just a less general definition of a category-like thing
12:21:23 <ddarius> A preorder is a category with at most one arrow between any two objects.
12:21:24 <mmorrow> s/</->/
12:21:35 <mmorrow> ah, _at most one_ is what i overlooked
12:21:59 <ddarius> @google Category theory as coherently constructive lattice theory
12:22:01 <lambdabot> http://citeseer.ist.psu.edu/269479.html
12:23:48 <mmorrow> dolio: what is (~=) in "<dolio> And there's also Pi x:A. B < Pi x:A'. B' if A ~= A' and B < B', and so on."?
12:24:17 <dolio> mmorrow: Beta convertability.
12:24:26 <mmorrow> ah
12:25:14 <ddarius> On linux, if I have 2 NICs and I want to talk to a computer on one network that happens to have the same IP address as my computer is assigned on the other network, what magick incantation do I need?
12:26:07 <mmorrow> ddarius: probably a bridge between the two different cards you're using
12:26:10 <mmorrow> or some such
12:26:24 <mmorrow> (i'm assuming your computer has two here)
12:26:51 <mmorrow> since i think that has to be the case
12:26:52 <SamB_XP_> mmorrow: that isn't going to help a bit
12:27:01 <mmorrow> SamB_XP_: why?
12:27:04 <ddarius> mmorrow: I don't need the two networks to be able to talk to each other, just my computer to be able to talk to each (or rather one computer on one.)
12:27:14 <SamB_XP_> because it will still route those packets through lo ?
12:27:18 <mmorrow> oh right
12:27:52 <SamB_XP_> ddarius: I think you need to get the socket bound to the interface explicitly?
12:27:52 <mmorrow> ddarius: don't each of your cards have different addresses?
12:27:56 <mmorrow> yeah
12:28:07 <ddarius> I think I would be fine if it wasn't for the fact that my computer has the same IP address as the computer I want.
12:28:21 <SamB_XP_> stop using IPv4?
12:28:46 <ddarius> SamB_XP_: Yeah.  I tried fiddling with the routing tables but that didn't seem to work.
12:29:03 <Zao> ddarius: Add a route for that particular host at that interface.
12:29:10 <mmorrow> i hate things like this, it always turns out to be an epic pita
12:29:17 <SamB_XP_> ddarius: I'm not talking routing tables ... I mean, if you want that, you're going to have to make the application open the socket more specifically
12:29:27 <SamB_XP_> there's no other way to do it that I am aware of ...
12:30:11 <SamB_XP_> ddarius: and I was serious about trying IPv6, btw!
12:31:34 <ari> Sooooooo what's up with Hackage?
12:31:36 <SamB_XP_> ddarius: also, tell both organizations about the importance of IPv6 and using globally-unique addresses!
12:31:42 <ddarius> SamB_XP_: Can you specify which interface to use for ssh?  Nothing jumped out at me.  Setting up IPv6 would be more effort than its worth for this.
12:31:42 <ddarius> ari: It's down.
12:31:55 <ari> ddarius: ty
12:32:03 <ddarius> SamB_XP_: In this case the organizations are my wireless network and a softmodded xbox.
12:32:15 <FunctorSalad> doesn't anyone have the tarball? ;) (not for me)
12:32:27 <SamB_XP_> oh, in that case, switch your IP address on the WLAN
12:32:33 <SamB_XP_> duh
12:33:46 <SamB_XP_> or the Xbox, if that's actually running something that lets you do that ...
12:34:12 <ddarius> SamB_XP_: Yeah, but I was hoping for something slightly more temporary than that (not that that is particularly cumbersome) and I was curious if what I described originally was even possible, and I just couldn't figure it out.
12:34:28 <SamB_XP_> ddarius: not practical
12:34:29 <ddarius> SamB_XP_: Currently both (or rather all three) are using DHCP.
12:34:45 <SamB_XP_> you would only do it if you couldn't solve the problem any other way ...
12:35:10 <SamB_XP_> ddarius: well, why don't you get them all to use the same DHCP server then?
12:36:56 <Liskni_si> I once wrote a simple preload library for the very purpose of binding ssh sockets to a particular interface (not that it is less temporary than changing the IPs, though)
12:37:13 <paolino> ddarius: 2 nics on the same segment is not easy to route
12:37:51 <SamB_XP_> paolino: they aren't, they just have conflicting address spaces visible through them :-(
12:41:06 <paolino> well the xbox has its only interface in the same segment that the other nic on the host. Looks like they must be on the same segment, but maybe I got it wrong
12:43:29 <paolino> probably a prerouting rule could help in ipfilters , but I couldn't write it down
12:43:38 <c_wraith> hackage is still down?  noooo.  The deal with the magical sleep monkeys was "if I go to sleep, it'll be back up when I wake up." ;)
12:44:05 <paolino> (galois.com is down)
12:48:55 <phr1> is it about time for a mirror?
12:49:54 <Baughn> Sounds useful.
12:50:15 <Baughn> ..sounds sueful, if we don't first get some cryptography on it
12:50:30 <paolino> is it an haskell process serving hackage ?
12:51:09 <c_wraith> I just want to install a package so my project will give me compiler errors so I can fix whatever stupid mistakes I made
12:51:26 <zenzike> I noticed that the haskell platform webpage is down; do the mods know about this?
12:51:35 <paolino> c_wraith: which package ?
12:51:46 <c_wraith> EnumMap
12:52:23 <Orclev> ok, I know there's a function to do this, but I can't think of what it is... I want to take a pair of lists, apply a function to each element of both lists, and return the result as a list... so > foo (*) [1,2,3] [1,2,3] -> [1,4,9]
12:52:27 <c_wraith> zenzike, quite a few related haskell sites are currently down.  I'm sure whoever runs them is aware
12:52:53 <zenzike> c_wraith: righto, just making sure.
12:52:56 <mauke> Orclev: zipWith?
12:53:30 <Orclev> mauke: yep, for some reason I was thinking zipWith returned values in the form (a,b)
12:53:45 <c_wraith> Orclev: that's just zip
12:53:49 <Orclev> > zipWith (*) [1,2,3] [1,2,3]
12:53:50 <lambdabot>   [1,4,9]
12:53:55 <Orclev> perfect, thanks
12:54:18 <Botje> you could ask hoogle
12:54:32 <Botje> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
12:54:33 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:54:33 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:54:33 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
12:55:01 <sproingie> > zipWith (,) [1..5] [1..5]
12:55:01 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5)]
12:55:13 <sproingie> zip is just zipWith (,)
12:55:28 <c_wraith> > join zipwith (*) [1..]
12:55:29 <lambdabot>   Not in scope: `zipwith'
12:55:34 <c_wraith> > join zipWith (*) [1..]
12:55:35 <lambdabot>   Couldn't match expected type `a -> b -> c'
12:55:35 <lambdabot>         against inferred type `[...
12:55:51 <Orclev> is there a better way to "reverse" a number, than to convert it to a string, run reverse on it, then convert it back into a number?
12:55:52 <c_wraith> > join (zipWith (*)) [1..]
12:55:53 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
12:58:28 <Baughn> Orclev: Undoubtedly. However, that way would be easy to write. Is this reversal something that's likely to happen a lot?
12:59:01 <Orclev> Baughn: yes, although I just realized I don't actually need to convert it back into a number, it's for a test and the test works equally well while it's in string form
13:01:35 <Phyx-> is there a way to tell ghc-pkg to unregister all versions of a package at one time?
13:03:27 <Phyx-> oh, seems unregister already does that
13:03:28 <Phyx-> handy
13:07:27 <xci> win goto active
13:09:29 <trofi> @src nub
13:09:29 <lambdabot> nub = nubBy (==)
13:10:01 <Phyx-> xci: ^_^
13:10:29 <Phyx-> i constantly forget the / too
13:14:21 <xci> ^^
13:14:41 <burp> > fmap (read . reverse . show) [10..50] :: [Int]
13:14:41 <lambdabot>   [1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,52,62,72,82,92,3,13,23,33,43,53...
13:15:07 <loop> xci: just press meta-a? :)
13:15:26 <burp> @oaeis 1,11,21,31,41,51,61,71,81,91,2,12
13:15:27 <lambdabot>  Read n backwards (referred to as R(n) in many sequences).
13:15:27 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,52,62,72,82,...
13:15:55 <burp> clever oaeis :)
13:16:45 <xci> loop: using mobile phone atm :]
13:19:07 <trofi> @oeis 1,2,3,4,5,6,7,8
13:19:07 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
13:19:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:19:15 <trofi> @oeis 0,0,0,0,0,0
13:19:16 <lambdabot>  Triangle read by rows: T(n,k)=1 if k divides n, T(n,k)=0 otherwise.
13:19:16 <lambdabot>  [1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0...
13:19:22 <SamB_XP_> heh
13:19:37 <FunctorSalad> eh?
13:20:22 <FunctorSalad> > [0,0,0,0,0,0] `isPrefixOf` [1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0]++undefined
13:20:23 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
13:20:23 <lambdabot>    arising from a use of...
13:20:27 <Baughn> @oeis 1 9 19 29
13:20:28 <lambdabot>  Table by antidiagonals of n-Stohr sequences: T(n,k) is least positive intege...
13:20:28 <lambdabot>  [1,2,1,3,2,1,4,4,2,1,5,7,4,2,1,6,10,8,4,2,1,7,13,15,8,4,2,1,8,16,22,16,8,4,2...
13:20:29 <SamB_XP_> FunctorSalad: the triangle only consists of those (n,k) pairs where k <= n
13:20:33 <burp> FunctorSalad: doesn't have to be prefix
13:20:36 <FunctorSalad> > [0,0,0,0,0,0] `isPrefixOf` ([1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0]++undefined)
13:20:38 <lambdabot>   False
13:20:42 <FunctorSalad> burp: ah
13:20:58 <burp> @oeis 2,3,4,5,6,7
13:20:58 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
13:20:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:21:14 <burp> I think just somewhere in the sequence, as long as they saved it
13:21:38 <FunctorSalad> @oeis 1 1 23 1 1 1
13:21:39 <lambdabot>  a(n) = n if n is a prime, otherwise a(n) = 1.
13:21:39 <lambdabot>  [1,2,3,1,5,1,7,1,1,1,11,1,13,1,1,1,17,1,19,1,1,1,23,1,1,1,1,1,29,1,31,1,1,1,...
13:22:47 <Fdot23> hi
13:22:53 <Berengal> Hello
13:23:11 <Fdot23> how can I compare an integer to the result of  a sqrt in haskell ?
13:23:32 <mauke> convert the integer first
13:23:39 <Berengal> fromInteger
13:23:39 <burp> > fromIntegral (2::Int) == sqrt 4
13:23:40 <mauke> probably with fromIntegral
13:23:40 <lambdabot>   True
13:24:05 <Fdot23> Oh ok thanks
13:24:10 <FunctorSalad> you might want to square the inequality instead though
13:24:42 <Fdot23> oh that's a good idea
13:24:47 <mercury^> Is there a way to make ghci show single reduction steps?
13:32:34 <Baughn> mercury^: The stepper?
13:32:55 <mercury^> Baughn: how do I use that?
13:33:15 <Eelis> what would be really awesome is if some tool would take a Haskell expression, would display it as a graph, and would let you click on nodes to selectively reduce it. does something like that exist?
13:33:17 <Baughn> mercury^: Ah.. I haven't, myself, actually. It's in the ghc user guide, if you read that.
13:33:32 <Baughn> Eelis: I think there was something like that for 6.4. :/
13:33:51 <Baughn> Eelis: Meanwhile, vacuum at least lets you display it as a graph
13:34:19 <Eelis> interesting. i'll have a look
13:34:39 <Eelis> or rather, i would if hackage wasn't down again
13:34:49 <Baughn> Eelis: Combine vacuum with isEvaluated (assuming that /works/), hack things up a bit, and you should be able to make what you want
13:35:32 <srparish> is hackage.haskell.org down? i'm not getting any pages to load from there
13:35:43 <Zao> Supposedly.
13:35:45 <Eelis> srparish: http://downforeveryoneorjustme.com/hackage.haskell.org
13:35:46 <mmorrow> ddarius: that pdf you linked to earlier is good
13:36:05 <Baughn> Eelis: Ironically, downforeveryoneorjustme.com is down for me.
13:36:16 <Eelis> Baughn: heh, not for me
13:36:45 <srparish> Baughn: downforeveryoneorjustme worked fine for me just now
13:37:03 <Baughn> srparish: I tried checking http://downforeveryoneorjustme.com/downforeveryoneorjustme.com, but it's not loading.
13:37:05 <Phyx-> hahaha
13:37:12 <srparish> oic, lol
13:37:55 <srparish> Baughn: actually that page loaded for me:
13:38:02 <srparish> "If you can see this page and still think we're down, it's just you."
13:38:14 <Phyx-> yeah, got that too
13:38:14 <Baughn> I figured it might.
13:38:41 <mercury^> The stepper isn't very revealing. :(
13:38:51 <srparish> any idea when hackage.haskell will be back up? is this a common occurance (pretty new to haskell)
13:39:50 <SamB_XP_> srparish: no
13:40:05 <SamB_XP_> it's not common, and I've no idea
13:40:10 <SamB_XP_> what were you hoping to download ?
13:40:23 <FunctorSalad> does the smile on the web hosting site linked to from there appear fake to everyone or just me? o_o
13:40:33 <mmorrow> ddarius: i wish i could get a hold of the .tex file for that
13:40:35 <srparish> i was hoping to install the batteries included stuff
13:40:42 <fxr> srparish: if it is urgent, use archlinux AUR tarballs.
13:40:47 <srparish> i can wait
13:41:21 <ddarius> mmorrow: Email the author.
13:41:32 <dpratt71> what's a good resource for trying to understand how the Haskell implementation of Monad(s) maps to the Category Theory concept of the  same?
13:41:59 <mmorrow> ddarius: good idea
13:44:24 <SamB_XP_> srparish: what platform ?
13:44:57 <srparish> SamB_XP_: ubuntu
13:46:26 <SamB_XP_> can't help you there :-(
13:46:52 <srparish> i was planning on just installing from source
13:46:59 <srparish> (if that changes anything)
13:47:31 <SamB_XP_> well, I don't have it sitting around ...
13:47:44 <srparish> oic, no problem, thanks
13:50:58 <Berengal> Could category theory be said to be a theory of composition?
13:52:06 <monochrom> Yes.
13:52:58 <monochrom> Such MBA-type qualitative simplifications are highly flexible. You can use it to "prove" anything.
13:53:34 <dpratt71> WP describes a Monad as a Functor with two associated natural transformations...
13:53:53 <monochrom> they are return and join in haskell.
13:54:03 <dpratt71> I can see how the definition of "functor" lines up with Haskell's Functor...
13:54:16 <monochrom> liftM provides the functor part.
13:54:42 <dpratt71> monochrom: I see...let me try to see if I can grok that
13:55:27 <dpratt71> unfortunately, I gotta run, but thanks
14:04:33 <phr1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10885#a10885   ghc 6.10.3 panic
14:05:25 <phr1> yeah i know about the redundant Num instance
14:05:35 <Vanadium> .4 too, fwiw :3
14:06:53 <chaosape> phr1: Remove the colon from your pragma
14:09:47 <sinelaw> is OCaML purely functional
14:09:49 <sinelaw> ?
14:09:56 <sinelaw> (dunno why the caps)
14:09:59 <burp> nope
14:10:07 <fxr> Objective CaML
14:10:12 <Taejo> sinelaw: I think it's usually written OCaml
14:10:43 <sinelaw> burp, so side effects happen "magically" behind the scenes?
14:10:57 <burp> yes
14:11:11 <burp> http://en.wikipedia.org/wiki/Ocaml
14:11:22 <fxr> http://caml.inria.fr/
14:11:28 <burp> multi-paradigm: imperative, functional, object-oriented
14:11:47 <sproingie> ocaml is not "pure" in the sense haskell is
14:11:59 <srparish> sinelaw: it has "cells" that are allowed to mutate
14:12:08 <srparish> iirc it also allows io in any function
14:12:18 <sproingie> i wish the "O" part of ocaml didn't suck so much
14:12:34 <sproingie> you get a ripping fast language as long as you actually stay away from the nice OO parts
14:12:36 <sinelaw> hhhhhhhokay, folks
14:13:04 <sproingie> at which point method dispatch is totally dynamic.  may as well be python.
14:13:30 <mercury^> @pl flip fmap
14:13:31 <lambdabot> flip fmap
14:13:35 <phr1> chaosape, thanks
14:13:57 <phr1> i thought i'd also bring up the panic here since the haskell bug tracker (hosted on hackage...) is down
14:14:01 <phr1> i'll try to file a bug later
14:14:15 <chaosape> phr1: I have spent time with that exact error ;^)
14:14:32 <phr1> hee
14:14:37 <phr1> maybe it's fixed in 6.10.4
14:15:18 <chaosape> phr1: it seems ghc is pretty sensitive to pragma typos
14:15:18 <yitz> phr1: no, confirmed on 6.10.4 also (MacOS X Tiger)
14:15:57 <chaosape> is hackage.haskell.org down?
14:16:03 <phr1> yitz is there already an open bug for it?  if yes i don't have to repor tit
14:16:08 <phr1> chaosape yes hackage is down
14:16:09 <phr1> since last night
14:16:16 <yitz> phr1: Vanadium also seems to have gotten it on 6.10.4. (platform?)
14:16:28 <phr1> vanadium?
14:16:33 <yitz> phr1: don't know. can't check. :(
14:16:41 <phr1> what's vanadium?
14:16:45 <fxr> http://www.haskell.org/haskellwiki/Monads_as_computation "Motivation part written wonderful"
14:17:13 <Vanadium> Platform is linux/x86_64
14:17:28 <phr1> oh!  sorry!!
14:17:34 <Vanadium> The pragma parsing code seems rather fragile :V
14:17:45 <phr1> thought "vanadium" referred to a program :)
14:18:11 <Vanadium> I wish!
14:19:45 <Paczesiowa> if I have a class A and instance A Foo (Foo is more complicated), then I can use methods of A on some expression as long as it is "subtype" of Foo, it's not about unification, right?
14:19:51 <yitz> phr1: copumpkin is checking it now in 6.12 (on #ghc)
14:20:23 <phr1> cool
14:20:49 <yitz> seems to be fixed already in 6.12
14:20:56 <Vanadium> Hooray
14:21:22 <phr1> Paczesiowa if i understand the question, then yes
14:21:37 <phr1> i mean haskell doesn't have subtypes
14:21:41 <phr1> so it's not clear what you mean
14:22:22 <copumpkin> subclass maybe?
14:22:43 <copumpkin> no, I guess it doesn't make sense like that
14:22:57 <Paczesiowa> copumpkin: no, it's not that
14:23:39 <Paczesiowa> phr1: if I have instance A (Foo -> a), then I can't use it with (a -> Foo), even though those types can be unified
14:24:18 <Paczesiowa> phr1: I'm asking if it as about unification in only one direction (subtyping?)
14:24:26 <Paczesiowa> *if it is
14:25:25 <phr1> Paczesiowa i'm afraid i'm lost, sorry.
14:26:38 <SamB_XP_> for those interested, there is http://nun.haskell.org/~SamB/HaskellPlatform-2009.2.0.2-setup.exe.torrent
14:27:45 <Fdot23> how do I convert an integer to a string in haskell ?
14:28:03 <Taejo> Fdot23: read
14:28:04 <Botje> :t show
14:28:05 <lambdabot> forall a. (Show a) => a -> String
14:28:19 <Taejo> oh, right, I read that the wrong way round
14:28:24 <Heffalump> SamB_XP_: is anyone seeding that?
14:28:28 <Paczesiowa> > show 1337
14:28:29 <lambdabot>   "1337"
14:28:33 <SamB_XP_> Heffalump: me
14:28:44 <SamB_XP_> and nun.haskell.org has an HTTP seed...
14:28:52 <Fdot23> oh show.. thanks
14:28:56 * Heffalump wonders why his client can't figure that out
14:29:25 <Badger> heh
14:29:29 <Badger> > show or
14:29:30 <lambdabot>   "[]->\n  False\n[True]->\n  True\n[True,True]->\n  True\n[True,True,True]->...
14:29:34 <SamB_XP_> huh, what trackers did it connect to ?
14:30:21 <Heffalump> tracker.publicbt.com, and two incomprehensible ones beginning z6gw6 which both reported errors
14:30:38 <Botje> Badger: woah. that's scary voodoo magic. how'd it do that?
14:30:53 <SamB_XP_> huh
14:30:57 <Heffalump> Botje: same way quickcheck makes up inputs
14:31:04 <Botje> oh.
14:31:05 <Botje> cool :)
14:31:15 <Taejo> > show exp
14:31:16 <lambdabot>   "-0.375->\n  0.6872892787909722\n-0.75->\n  0.4723665527410147\n-1.5->\n  0...
14:31:45 <Taejo> > show ((+1) :: Int -> Int)
14:31:46 <lambdabot>   "{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}"
14:31:56 <Heffalump> SamB_XP_: never mind, I don't actually need it, I just wanted to help seed it if I could easily
14:32:58 <PeakerWork> if quickcheck only makes lists with True in them.. we're in bad shape? :)
14:32:59 <SamB_XP_> Heffalump: I uploaded a new torrent file with more | in it ... maybe it works better ?
14:33:24 <Axman6> > show
14:33:25 <PeakerWork> @check \xs -> False `notElem` xs
14:33:25 <lambdabot>   {()->"()"}
14:33:26 <lambdabot>   "Falsifiable, after 4 tests:\n[True,False]\n"
14:33:47 <PeakerWork> the next one after [True,True,True] it seems :)
14:34:20 <yitz> @check \x -> x || undefined
14:34:20 <lambdabot>   Undefined
14:34:35 <Heffalump> SamB_XP_: nope. never mind.
14:35:14 <PeakerWork> yitz: well the particular case was list of bools
14:35:16 <yitz> oh
14:35:43 <SamB_XP_> Heffalump: what client ?
14:35:50 <Heffalump> utorrent
14:36:17 <SamB_XP_> huh, it's working fine here!
14:36:33 <Botje> @check \xs -> False `elem` xs and True `elem` xs
14:36:34 <lambdabot>   Precedence parsing error
14:36:34 <lambdabot>      cannot mix `GHC.List.elem' [infix 4] and `GHC...
14:36:39 <Botje> @check \xs -> False `elem` xs && True `elem` xs
14:36:40 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
14:36:50 <SamB_XP_> ... I think ?
14:37:08 <SamB_XP_> huh ... my http seeds didn't go through ?
14:38:27 <Axman6> > sort . show $ 2^1234
14:38:29 <lambdabot>   "00000000000000000000000000000000000000000000011111111111111111111111111111...
14:38:45 <Axman6> > group . sort . show $ 2^1234
14:38:46 <lambdabot>   ["000000000000000000000000000000000000000000000","1111111111111111111111111...
14:39:05 <Axman6> > map (head *** length) . group . sort . show $ 2^1234
14:39:06 <lambdabot>   Couldn't match expected type `([a], [a1])'
14:39:06 <lambdabot>         against inferred type `[...
14:39:19 <Axman6> :t (head *** length)
14:39:20 <lambdabot> forall c a. ([c], [a]) -> (c, Int)
14:39:25 <Axman6> :t (head &&& length)
14:39:27 <lambdabot> forall c. [c] -> (c, Int)
14:39:34 <Axman6> > map (head &&& length) . group . sort . show $ 2^1234
14:39:35 <lambdabot>   [('0',45),('1',38),('2',43),('3',40),('4',29),('5',28),('6',33),('7',33),('...
14:40:40 <sundaymorning> I've been reading up on primitive recursion and I learned that foldr implements it in a manner that all you gotta do is implement the function which knows how to handle n and f(n-1). Are there more recursion patterns out there? I know about map and filter but they can be both implemented in terms of fold.
14:40:42 <wagle> hackage is down?
14:41:00 <Blasa> wagle, it is for me
14:41:07 <chaosape> wagle: yar.
14:41:15 <Axman6> @yar
14:41:15 <lambdabot> I'll crush ye barnacles!
14:41:21 <Axman6> @yarrrrrrrrrrrrrrrrr!
14:41:21 <lambdabot> Unknown command, try @list
14:41:24 <Axman6> :(
14:41:49 <wagle> @fix yar
14:41:49 <lambdabot> Maybe you meant: bid faq ft id thx
14:41:51 <Axman6> @help bid
14:41:51 <lambdabot> bid symbols.  Sum up the bid and ask prices for symbols.
14:41:55 <Paczesiowa> sundaymorning: are you asking if there is something more powerful than structural recursion?
14:41:58 <PeakerWork> sundaymorning: foldl, though that can be implemented using foldr with function composition and then applying it all
14:42:26 <PeakerWork> sundaymorning: You could implement "zip" with foldr but it would not be easy.. so maybe zip/zipWith is a different recursion "pattern"
14:43:45 <kw317> is it proper to write [something is] type-checked, or typechecked?
14:43:47 <sundaymorning> I probably lack the right terms for that sort of thing. I just thought the idea of identifying recurring patterns and naming it to be good.
14:44:19 <skorpan> kw317: maybe even "type checked"?
14:44:37 <kw317> the definitive record of english language (oed.com) is not very definitive :-(
14:44:44 <Paczesiowa> sundaymorning: there is deforestation scheme based on foldrs (and builds) so probably anything that isn't fusible under it, isn't possible to be defined with foldrs (zip, concatMap, foldl)
14:44:53 <kw317> but again, if no one knows for sure then any way is a good way ;-)
14:45:38 <Paczesiowa> kw317: well-formed formula?
14:47:16 <Blasa> @type unfoldr
14:47:17 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:47:18 <Paczesiowa> kw317: or well-formed expression in case of haskell
14:48:44 <Blasa> Is sundaymorning looking for anamorphisms, etc...  I still haven't got my head around them myself.
14:48:57 <copumpkin> zygohistormorphic prepromorphisms
14:50:31 <kw317> maybe it's better to leave them unnamed
14:54:57 <kw317> I'm wondering if I've got the ghc pipeline right: front end: lex, parse, tc, desugar -> Core; middle-end (simplifier?): C-to-C optimisations -> STG (any opt on STG?); back-end: STG to C, C-- or native code
14:55:20 <Botje> i think STG comes before C :)
14:55:30 <Botje> and C isn't used anymore, there's a native backend now
14:55:34 <kw317> oh, by that C I mean Core
14:55:37 <Botje> ah.?
14:55:40 <Botje> okay :)
14:55:46 <kw317> sorry, wanted to save some space ;-)
14:55:51 <kw317> and FAILed
14:56:33 <kw317> what is STG used for?
14:58:30 <Paczesiowa> phr1: can you explain this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10889 ?
15:01:18 <Botje> STG encodes the graph reduction process in sequential code
15:01:25 <Botje> if i understood the paper correctly
15:06:42 <phr1> Paczesiowa that looks fine
15:07:27 <phr1> you're not trying to do something like b :: (A a) => a -> ()
15:10:06 <tommd> Anyone here using Haskell for computer vision or any sort of audio recognition?
15:12:09 <Dridus> hey does anyone have any quick pointers on how to make cabal put .o and .hi files and so on in a separate directory from the source dirs? It's quite annoying to have all those extra files laying around the src dir
15:12:22 <Dridus> or is it a matter of fiddling with compiler-specific options
15:12:32 <dcoutts> Dridus: it does do that
15:12:56 <Dridus> dcoutts: hrm, I have a ton of them laying around, maybe I have them laying around from some old ghc --make
15:12:59 <Dridus> dcoutts: thanks
15:13:04 <dcoutts> Dridus: cabal puts all generated files in dist/ nothing goes in the source dirs
15:13:32 <Paczesiowa> phr1: it looks like if f is a function then f x typechecks if type of x can be unified with type of f's first argument. but if f is a method then, f x typechecks only if type of x is "subtype" of f's first argument
15:13:32 <dcoutts> it's possible to do multiple builds in the same source tree with different sets of generated files
15:14:19 <Nafai> dcoutts: Is it possible to have multiple repos for cabal?
15:14:35 <dcoutts> Nafai: what do you mean exactly?
15:15:48 <Nafai> Well, by default, cabal uses hackage as it's repo.  Say I wanted to have an internal repo to my company for private packages but also have hackage available.
15:16:06 <dcoutts> Nafai: yes
15:16:08 <TomMD> I think he means having "cabal install from=hackage bloomfilter ; cabal install from=internal MechanicEngine"
15:16:26 <Nafai> essentially, though it would be nice to not have to do from= unless there was a conflict
15:16:38 <TomMD> Right.
15:16:43 <dcoutts> you can set multiple servers in the ~/.cabal/config
15:16:58 <dcoutts> the package sets overlay in the order in which you list the servers
15:16:59 <Cale> Paczesiowa: (Num n => n) is the usual type of the integer literal 1
15:17:08 <Nafai> Ah, cool, I just saw remote-repo: and I wasn't sure if it could be listed multiple times
15:17:22 <Cale> Paczesiowa: so adding that signature doesn't change anything -- that's already the inferred type
15:17:29 <Paczesiowa> Cale: I know, I just didn't want it to narrowed down to simple type
15:17:41 <Paczesiowa> *get narrowed
15:17:58 <Dridus> dcoutts: okay one more dumb questions and I'll stop bugging you -- any way to make cabal preprocess .chs files?
15:18:30 <dcoutts> Dridus: yes, just list the modules as normal, if cabal finds .chs files then it'll use c2hs on them
15:18:38 <Dridus> dcoutts: okay, thanks again
15:18:56 <dcoutts> Nafai: right, all the settings can be listed multiple times, what's not obvious is if they're using the list or last monoid :-)
15:19:06 <Dridus> dcoutts: I don't have any modules listed, so I guess that's why it's not doing it already
15:19:12 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10890#a10890 -- I've been staring at this for some time now and don't see what's wrong with beta.
15:19:24 <dcoutts> Dridus: right, you're supposed to list all the exposed/other-modules
15:19:33 <Paczesiowa> Cale: you like theory, can you explain that( my code that is, not your preferences:)?
15:19:46 <Nafai> dcoutts: Good to know.  Thanks for answering my questions.
15:20:24 <Dridus> dcoutts: yeah, this is an executable and the executable section in the docs only mentions main-is...  I'll add other-modules
15:20:38 <Cale> Paczesiowa: In the case of b, it knows that the first part of the tuple you pass it ought to be an Int, and so if you put something polymorphic there, and Int satisfies the typeclass constraints, then n becomes Int
15:20:58 <Cale> Paczesiowa: In the case of a, it fails because of an ambiguity.
15:21:24 <dpratt71> trying to grok Category theory via Haskell and Wikipedia...
15:21:26 <Cale> Paczesiowa: It's not certain which instance of A you want, and it has no idea what instances of A might exist in future modules (ones which import this one)
15:21:41 <Cale> dpratt71: Want a book?
15:21:55 <dpratt71> Cale: do I?
15:21:56 <dcoutts> Nafai: it could be better documented that's for sure.
15:22:06 <Cale> yeah
15:22:09 <dpratt71> not much for book larnin' :)
15:22:17 <dcoutts> Nafai: we've had the multiple remote servers thing for a while, but I don't know how much it really gets used
15:22:28 <ivanm> dpratt71: just wiki learning?
15:22:57 <mercury^> dpratt71: ["Category Theory for the Working Mathematician", "Toposes, Triples, Theories"]
15:23:13 * Cale sends Awodey's book :)
15:23:18 <dcoutts> Dridus: it does say it can use the other "build information" fields
15:23:32 * ivanm got stuck half-way through "Categories and Computer Science"...
15:23:39 <mercury^> Cale: have you looked at the broken beta reduction I posted?
15:23:41 <yitz> mercury^: this isn't your problem, but "if m /= n then True else False" is just "m /= n".
15:23:51 <mercury^> yitz: right
15:23:53 <dpratt71> so WP says that a Monad consists of a "functor" and two "natural transformations"...
15:23:55 <Cale> Awodey is a lot better than CTftWM for computer scientists.
15:24:06 <Cale> dpratt71: that's right
15:24:08 <Dridus> dcoutts: it sure does. I don't know what the issue is, but me and cabal don't get along :-/
15:24:14 <yitz> mercury^: how is it broken?
15:24:16 <dpratt71> I think I see how a "functor" relates to liftM...
15:24:43 <dpratt71> and I'm told the two natural transforms are return and bind...
15:24:48 <Cale> no
15:24:53 <Cale> They're return and join
15:25:17 <Cale> bind is a bit more complicated than join to formalise in that language
15:25:22 <mercury^> yitz: let s = Lam (App (Var 2) (App (Var 1) (Var 1))); y = App (Lam (App s s)) in red $ y (Lam (Var 1))
15:25:23 <dpratt71> ah, I probably translated bind to join when I heard it
15:25:39 <mercury^> yitz: that should loop indefinitely, but outputs (Var 1)
15:25:46 <Dridus> dcoutts: thanks for the tips though -- I'm not seeing the extraneous files now that I manually cleaned them out (must be from some manual tool run back in time) and it's processing the .chs file now that I've named the module
15:25:49 <Cale> return is usually called Î· and join is called Î¼
15:26:11 <Cale> fmap/liftM is called T, or whatever the name of the functor is.
15:26:30 <dpratt71> Cale: ah, that's (a big part of) what I was trying to figure out, thanks
15:27:12 <coarcher> The category theory videos on youtube are interesting.
15:27:24 <ivanm> Cale: is this the awodey you're talking about? http://www.andrew.cmu.edu/user/awodey/
15:27:31 <dcoutts> Dridus: great
15:27:40 <Cale> ivanm: that's the guy
15:28:20 <ddarius> "From sets, to types, to categories, to sets." sounds interesting
15:29:27 <coarcher> These give a full course --> http://www.youtube.com/user/TheCatsters Not designed for computer scientists. But still another resource
15:30:06 <yitz> mercury^: how do you know which is the bound variable in a lambda?
15:30:35 <mercury^> yitz: de Bruijn indices
15:30:41 <Taejo> "But these are all inadequate, because the infinite abyss can only be filled by an infinite and immutable object, that is to say, only by Haskell itself." - Blaise Pascal
15:31:11 <Cale> The Casters are appropriate for computer scientists in that they don't really demand you to know very much outside of category theory itself. A lot of treatments of category theory seem to expect that you know lots of things about modules and topology and all the other fun structures in mathematics.
15:32:31 <mercury^> Need something to motivate the five lemma.
15:32:48 <mercury^> yitz: any idea?
15:33:11 <yitz> mercury^: still looking...
15:33:14 <mercury^> It's so annoying. I've gone over it at least 40 times now and don't think I'll spot the mistake today.
15:33:37 <SamB_XP_> five : because even rabbits can count that high!
15:34:07 <mercury^> Some tool that lets you interactively evaluate an expression in steps would be really helpful.
15:38:57 <yitz> mercury^: all simpler cases you've tried reduce correctly?
15:39:44 <mercury^> I haven't tried very many, but the few I did reduced correctly.
15:40:10 <dpratt71> so Category theory uses terminology such as "objects" and "arrows"...arrows seem to me to map directly to the concept of functions, but what about "objects"? are objects types? values? does it matter?
15:40:43 <mercury^> Arrows are more general than functions. But if you use that analogy, objects are sets.
15:40:50 <Paczesiowa> Cale: that argument about not knowing about future instances (I agree that would result in many suprises) is the only thing that forbids using regular unification?
15:41:31 <mpwd> dpratt71: Objects are like types in haskell
15:41:32 <dpratt71> so a function is a specialized arrow where the objects are sets?
15:41:48 <dpratt71> mpwd: ok, makes sense
15:42:29 <mercury^> dpratt71: "just" functions are the arrows of the category of sets, Set.
15:42:53 <dpratt71> mercury^: that's what I was afraid of :)
15:42:56 <mercury^> Other categories add structure on sets or have objects that aren't sets at all.
15:43:20 <mpwd> mercury^: Like the category of little categories :)
15:43:23 <mercury^> For Haskell, the category of Haskell types, Hask is what you work with.
15:43:27 <mpwd> small categories, rather
15:43:49 <mercury^> yitz: I think I'll slip into a rage induced coma over that bug now.
15:44:01 <mercury^> If you find anything, just message me somehow, my client will stay online.
15:45:49 <kw317> what kind of optimisations are done on Core?
15:46:13 <Paczesiowa> inlining?
15:46:25 <mpwd> How much work has really been done on formalizing category theory in Isabelle or Coq?
15:46:58 <dpratt71> so in the Hask category, arrows are functions and objects are types?
15:48:14 <kw317> http://blog.sigfpe.com/2009/10/what-category-do-haskell-types-and.html
15:48:42 <kw317> dpratt71: ^^
15:48:47 <Taejo> dpratt71: yes, but kw317's link is worth reading
15:52:06 <ddarius> mpwd: There have been a few formalisations in Coq I believe.
15:52:34 <yitz> mercury^: the equation for Lam t looks suspicious. How can you compute that without looking inside the structure of s?
15:52:42 <ddarius> @google Category Theory in Coq
15:52:44 <lambdabot> http://citeseer.ist.psu.edu/355887.html
15:54:17 <Aduros> Is Hackage down right now?
15:54:42 <stroan> seems to be
15:54:44 <dancor> kw317: what about haskell functions that need variable? (some kind of multiline expressions cannot be @pl'd right?)  are those just irrelevant for CCC proofs
15:54:49 <dancor> Aduros: same here
15:54:50 <yitz> Aduros: not responding (even though actually it's not down)
15:55:30 <Aduros> :/ Thanks. Is it usually back up shortly?
15:55:57 <kw317> dancor: I'm not an expert here, I can barely define a category ;-)
15:56:03 <defun> Just out of curiosity, how poeple are on this channel, for whom haskell is not their first programming language?
15:56:08 <defun> *people
15:56:24 <kw317> mine was C
15:56:29 <zakwilson> "how people"?
15:56:39 <c_wraith> Probably most.  I doubt many people started with haskell
15:56:40 <defun> *how many
15:56:43 <PeakerWork> defun: I don't think there are many for whom Haskell was a first language..
15:56:58 <c_wraith> I started with Basic.  It turns out not to have damaged me *too* much.  :)
15:57:07 <kw317> I would be surprised to see many for whom it was
15:57:09 <dancor> heh me neither.  anyway i think there are functions which cannot be made pointfree (not sure tho..?) and the article seems to imply they all can be programmatically made that way
15:57:10 <c_wraith> (that was like 24 years ago now.  I've had time to get over the bad habits)
15:57:54 <dancor> i started with qbasic and it was awesome
15:57:55 <zakwilson> I *think* Basic was the first programming language I used, but I didn't do anything interesting with it.
15:58:11 <bd_> dancor: with the s (join) and k (const) combinators, you can transform any function into a pointfree form mechanically
15:58:19 <zakwilson> The first language I used to write a non-trivial program was Hypertalk.
15:58:21 <bd_> also fix, if you're using recursion
15:58:36 <ddarius> bd_: You don't need fix if you don't have types.
15:58:40 <dancor> i used to make music by manually entering in beep durations, in my ascii platformers
15:58:57 <dancor> bd_: ok
15:59:58 <defun> Haskell was my first language. I personally found it rather enjoyable to learn (though not easy, since I've never written code before). For all of you who didn't have it as their first, did you find it 'hard' to acclimate yourself to pure fp, laziness etc.
16:00:00 * dancor has always found everything hard
16:00:20 <PeakerWork> defun: I think a lot of the knowledge of other languages actually made it harder to learn Haskell. Of course some things were easier
16:01:09 <dancor> i don't feel that it was harder.  the contrasts might make it easier.  any knowledge you start with is something to go from if you don't get stuck some place mentally
16:01:34 <dancor> "haskell for a c programmer" etc are pretty good imho
16:02:28 <skorpan> i'm sceptical to all things on the form "X for Y programmers" or "X in Y days"
16:02:36 <defun> Because, some of my friends (C/Java/Ruby coders), when I tried to introduce them to Haskell, found it distasteful, and viewed me suspiciously when I tried to explain the encapsulation of state (i.e. IO monad).
16:02:54 <defun> But maybe that's only for that particular group
16:03:25 <defun> Anyway, thanks. Just wanted to see if this was a usual first reaction, or not.
16:03:32 <skorpan> state isn't necessarily IO though, but that's just a matter of definitions
16:03:47 <defun> skorpan: I know, but I'm being a bit loose with terms.
16:03:52 <dpratt71> defun: I don't think that my "imperative" background made Haskell harder to learn, but I'm used to picking up languages quite quickly, yet Haskell was almost (but not quite) like starting over
16:04:08 <skorpan> if you say "state is impure and impure is bad" to an OOP programmer, of course they will be suspicious :)
16:04:18 <defun> good point.
16:04:26 <zakwilson> I was fairly used to impure FP and laziness from Clojure already.
16:05:43 <dancor> some pythoners i know think that haskell makes things hard on the programmer in return for making it so the compiler can know more and make stuff faster
16:05:57 <zakwilson> I still don't fully understand some of the abstractions used in Haskell to isolate side effects, but I'm working on it.
16:06:07 <sundaymorning> defun:  I like learning haskell, it's quite fun. But I feel like I need a phd to fully understand it, whereas I could fully understand C in a few months.
16:06:20 <dancor> but, io isolation is pretty sweet for e.g. lambdabot
16:06:23 <zakwilson> Strong static typing was probably the hardest thing for me to get used to.
16:06:47 <defun> zakwilson: when did you start learning haskell?
16:07:09 <zakwilson> I've mostly avoided static languages; Common Lisp and more recently Clojure have been my languages of choice.
16:07:18 <zakwilson> defun: maybe six months ago
16:07:18 <defun> I see.
16:07:24 <kynky> i thought haskell was a simple language, C is complex (language feature wise), the concepts of haskell are harder than the concepts in C
16:07:47 <zakwilson> I don't think C is all that complex. C++, yes, but not C.
16:07:56 <c_wraith> C is basically assembler with a slightly prettier interface.
16:08:45 <dancor> i'm much happier with type classes and polymorphism in haskell than i was with duck typing in python or templates in c++ or (if it's even worth mentioning) generics in java.  but i still have crises of faith about if laziness is really worth it
16:08:51 <sundaymorning> kynky: I think my opinion is the opposite of yours :P
16:08:59 <copumpkin> c_wraith: nuh uh
16:09:05 <copumpkin> c_wraith: in the 70s maybe
16:09:29 <c_wraith> Well.  it hasn't been updated for new architectures. :)
16:09:41 <kynky> sundaymorning, you think concepts in C are harder, whats harder than monads in C ?
16:09:54 <zakwilson> I've often seen typeclasses cited as one of the things that's hard to 'get' about Haskell. Was that true for anyone here?
16:09:57 <skorpan> monads aren't "hard"
16:10:02 <defun> copumpkin: how did c differ in the 70s from today?
16:10:02 <Draconx> kynky, the semantics of the restrict keyword.
16:10:06 <dancor> c is still too hard for me to avoid segfault.  i may get better at it tho.  also there are annoying limitations with like the creation of complex datatype literals.
16:10:16 <defun> zakwilson: not really,,,
16:10:26 <skorpan> dancor: YES1
16:10:27 <skorpan> !
16:10:31 <skorpan> fscking segfault
16:10:37 <c_wraith> I had trouble with typeclasses until I realized that the programs were only ever built with types, and typeclasses are NOT an equivalent to object inheritance.
16:10:39 <copumpkin> defun: the language didn't change (much) but the change in architectures means that the compilers have had to do a lot more than what a regular assembler would
16:10:46 <sundaymorning> kynky: well, that part I agree, I just disagree that C is more complex than haskell
16:11:16 <jimi_hendrix> is there a way to print inside of a list comprehension?
16:11:18 <pabloh> is it posible to do this using only composition:
16:11:18 <zakwilson> I think it may be the use of the word "class" that confuses people; they expect it to be like a class in Java or C++
16:11:22 <kynky> i didnt think there was much to the haskell language
16:11:29 <pabloh> (\a -> g a + f b) ???
16:11:43 <jimi_hendrix> sundaymorning, i think C is easier to get going with, but it has more hidden rules than haskell
16:12:06 <sinelaw> @type accumE
16:12:07 <lambdabot> Not in scope: `accumE'
16:12:10 <jimi_hendrix> thus taking longer to master, while haskell is challenging but you can get it more quickly
16:12:23 <PeakerWork> jimi_hendrix: your list comprehension can compute print actions.  Then you can sequence the result prints into one big action that would print when executed
16:12:33 <skorpan> jimi_hendrix: are you looking for Debug.Trace.trace?
16:12:37 <jimi_hendrix> no
16:12:39 <dancor> i think haskell has a lot of things you have to pick up before the code you are writing looks anything like that of ppl who are good at it
16:12:40 <jimi_hendrix> ?
16:12:41 <Cale> Paczesiowa: Well, the fact that there might be more than one instance is what really does it
16:12:43 <PeakerWork> I think he wants prints, not debug prints
16:12:43 <dancor> and profiling is hard
16:13:09 <sundaymorning> jimi_hendrix: I'm not sure I agree. C has very little rules, you basically manage pointers and memory positions. It's quite simple and it has very little syntax, imho.
16:13:13 <Cale> Paczesiowa: But yeah, by design it will never make use of the fact that there isn't an instance available.
16:13:55 <c_wraith> Basically, I figured out typeclasses were, exactly, when I looked at "show . read", and why it didn't compile without specifying a type.
16:14:08 <sundaymorning> whereas in haskell I have a hard time even understanding how to do IO in my program
16:14:27 <dancor> and there isn't a good multidimensional non-number data structure yet etc (and many other library deficiencies probably a direct result of a limited userbase)
16:14:33 <phr1> :k Var
16:14:34 <lambdabot> Not in scope: type constructor or class `Var'
16:14:36 <Paczesiowa> sundaymorning: have you tried doing it without understanding?
16:14:44 <Paczesiowa> Cale: thank you
16:14:50 <jimi_hendrix> sundaymorning, on second thought, you are right, C++ has many hidden rules (rule of three...etc) that arnt always obveious
16:14:55 <sundaymorning> Paczesiowa: yes, I have lots of surprises that way
16:15:14 <sundaymorning> yeah, C++ is quite complex language
16:15:20 <jimi_hendrix> so, anyway, can i print in a list comprehension
16:15:39 <jimi_hendrix> sundaymorning, its a good language until you combine its features
16:15:40 <Paczesiowa> sundaymorning: runtime or "wtf, why doesn't it compile?!?"
16:15:42 <sundaymorning> I think haskell is quite elegant, but it takes a lot of effort to understand and use
16:15:59 <c_wraith> jimi_hendrix:  Not without unsafePerformIO (or something implemented in terms of it)
16:16:03 <dancor> jimi_hendrix: i think you can create a list of IO actions but then you'll have run sequence on them
16:16:16 <ddarius> dancor: Map (X, Y) Z
16:16:19 <sundaymorning> Paczesiowa: both. I have seen code that I had no idea why they worked
16:16:27 <PeakerWork> jimi_hendrix: Functions map, actions do. a list comprehension is basically syntax for a composition of a bunch of functions -- it can only map, not do
16:16:38 <dancor> ddarius: i want to do arbitrary slicing easily
16:16:39 <jimi_hendrix> ok
16:17:04 <ivanm> @time sundaymorning
16:17:07 <lambdabot> Local time for sundaymorning is Sun Oct 18 21:15:34 2009
16:17:10 <jimi_hendrix> ok, well then i need some help rethinking my function
16:17:16 <ivanm> sundaymorning: doesn't look like Sunday morning to me ;-)
16:17:26 <jimi_hendrix> @time jimi_hendrix
16:17:27 <lambdabot> Local time for jimi_hendrix is Sun Oct 18 19:17:24
16:17:32 <PeakerWork> jimi_hendrix: well, paste it?
16:17:55 <zakwilson> I always feel like I'm solving a puzzle when I use Haskell. Other languages rarely do that to me.
16:17:55 <jimi_hendrix> o hey PeakerWork
16:17:57 <PeakerWork> jimi_hendrix: if you think you need to print in a list comprehension, you probably want a forM_ or such
16:18:02 <dancor> zakwilson: agreed
16:18:23 <dancor> i also sometimes feel that way when running cabal-install..
16:18:25 <dancor> ;)
16:18:28 <zakwilson> That said, my Haskell programs are far more likely to produce correct results once accepted by the compiler than most any language I know.
16:18:37 <ivanm> Haskell is a jigsaw puzzle, with the bumps being the types
16:19:16 <sundaymorning> ivanm: my nickname is only acurate for 5 hours a week, better than none I guess :P
16:19:35 <ivanm> sundaymorning: heh
16:20:10 <dancor> i love how as we discuss the faults of haskell, hackage.haskell.org remains down
16:20:42 <ivanm> dancor: shhh!
16:20:42 <ivanm> ;
16:20:47 <dancor> it can hear me?
16:20:49 <ivanm> * ;-)
16:20:52 <ivanm> dancor: yes
16:20:54 <ivanm> :p
16:21:03 <c_wraith> every time someone complains, it decide to stay down another 5 minutes.
16:21:21 <dancor> @vixen who wrote that algorithm?
16:21:22 <jimi_hendrix> well what i want to do is this:  take in a list of tuples of type (Integer, [Char]), run each element of the list through a function i have defined that takes a tuple of that type and collect the strings it returns into an array, then (heres the part that keeps messing me up) print each string on a new line like this (where : a) example string i got from the function \n b) another example ...
16:21:22 <ivanm> exactly!
16:21:59 <defun> @time defun
16:21:59 <jimi_hendrix> s/\(where /\(where \\n is a new line)/
16:22:09 <lambdabot> Plugin `vixen' failed with: thread killed
16:22:10 <lambdabot> Local time for defun is Sun Oct 18 19:11:29 2009
16:22:14 <Vanadium> jimi_hendrix: An array?
16:22:36 <skorpan> jimi_hendrix: mapM_ putStrLn $ map tupleToString $ myListOfTuples
16:23:24 <jimi_hendrix> s/array/list/
16:23:30 <dancor> mapM_ (putStrLn . tupleToString) myListOfTuples
16:23:35 <skorpan> or mapM_ (putStrLn . tuple..)
16:23:35 <skorpan> yeah
16:23:39 <jimi_hendrix> i keep using those interchangably from my large C family experience
16:23:48 <jimi_hendrix> ok
16:24:22 <copumpkin> nuh uh
16:24:26 <dancor> OR putStr . unlines $ map tupleToString myListOfTuples
16:24:42 <skorpan> OR... no, that's enough
16:25:10 <jimi_hendrix> now how do i get the a) b) c) ... parts at the start of each line?
16:25:18 <dancor> oooh
16:25:24 <skorpan> oh!
16:25:45 <c_wraith> I actually used mapM yesterday.  For the return value!  That was a new experience
16:25:46 <jimi_hendrix> (i these are options for the user to pick from)
16:25:47 <Vanadium> You could zip ['a'..'z'] into it somehow
16:26:04 <dancor> putStr . unlines $ zipWith tupleToString ['a'..] myListOfTuples
16:26:39 <dancor> tupleToString c (i, s) = c ++ ") my example " ++ show i ++ ": " ++ s
16:26:46 <dancor> tupleToString c (i, s) = [c] ++ ") my example " ++ show i ++ ": " ++ s
16:27:57 <dancor> or whatever.  i probably made a bunch of wrong assumptions about what you are doing.  zipWith is the cool part
16:28:55 <PeakerWork> jimi_hendrix: the key is to separate the IO from the computation
16:29:09 <jimi_hendrix> ok
16:29:23 <jimi_hendrix> so try and isolate all IO as much as possible?
16:30:43 <PeakerWork> jimi_hendrix: yeah, so your computations are more reusable
16:31:09 <CalJohn> jimi_hendrix: you'll stop mixing them up eventually (i always say function instead of method with OO langs).  so long as you know arrays and lists are totally different structures
16:32:20 <jimi_hendrix> whats the diff in haskell again?
16:33:49 <PeakerWork> jimi_hendrix: list is a linked list, array is an array
16:34:02 <PeakerWork> jimi_hendrix: anyway, we never finished that session about ADT definitions...
16:34:10 <copumpkin> preflex: seen edwardk
16:34:11 <preflex>  edwardk was last seen on #haskell 3 days, 3 hours, 14 minutes and 43 seconds ago, saying: * edwardk is afraid the next works out of byorgey will be 'get him!'
16:34:17 <jimi_hendrix> PeakerWork, well i am about to go afk for a bit, then i will be here
16:34:26 <Vanadium> jimi_hendrix: Lists appear to correspond better to recursion :3
16:34:49 <Vanadium> ie you need to create an array with a fixed size, but for a list you can just keep going and return [] when you are bored
16:35:34 <codm`> I sometimes wish there were efficient Queues, in addition to lists and arrays...
16:35:50 <codm`> I use tailqs all the time in C, and miss them in Haskell.
16:35:52 <c_wraith> codm`: DList
16:36:27 <codm`> @hoogle DList
16:36:28 <lambdabot> Text.Html dlist :: Html -> Html
16:36:28 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
16:36:28 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
16:36:33 <copumpkin> not that
16:36:38 <c_wraith> @hackage dlist
16:36:38 <lambdabot> http://hackage.haskell.org/package/dlist
16:36:44 <c_wraith> except hackage is down
16:36:47 <c_wraith> so that doesn't help you
16:37:05 <copumpkin> failckage
16:37:07 <codm`> Oh well.  Is DList pure?  I can obviously do this with MVars.
16:37:14 <c_wraith> yes, it is.
16:37:30 <copumpkin> there are also other listy things that support efficient append
16:37:40 <copumpkin> FMList, Seq
16:37:54 <copumpkin> or in some cases, even a regular list using unfoldr
16:38:20 <codm`> Okay, checking out http://code.haskell.org/~dons/code/dlist/Data/
16:38:29 <copumpkin> it's a very simple idea
16:38:47 <copumpkin> newtype DList a = DL { unDL :: [a] -> [a] }
16:39:52 <copumpkin> :t (`id` 5)
16:39:54 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
16:39:58 <codm`> Shoot, am getting errors trying to run DList.hs through haddock.
16:41:04 <codm`> ah, cpp stuff
16:42:16 <sinelaw> hackage is dead, long live google cache
16:42:46 <gwern> who do we lynch for the downtime?
16:42:48 <codm`> I'm surprised there's no hackage mirror.  I might be able to host.  Is it easy to download the whole web site and mirror it?
16:42:50 <tcleval> have anyone considered using LINDA together with haskell for parallel programming?
16:42:54 <ivanm> gwern: you!
16:42:58 <gwern> eek!
16:43:14 <gwern> REMEMBER ME - As A PEACE-MAKER!
16:43:34 <monochrom> pace maker
16:43:45 <ivanm> peace maker == doomsday device?
16:44:35 <gwern> (y'know, I don't even know what I was alluding to there. the extent to which my mind has been colonized by memes is a little scary)
16:48:00 <skorpan> would someone remind me again what the *advantage* of newtype vs. data is?  e.g. newtype  DList vs. data DList (i'm asking for the advantage as i can't find any actual difference)
16:48:12 <ivanm> skorpan: faster runtime
16:48:15 <gwern> skorpan: one less pointer indirection at runtime, or something
16:48:24 <PeakerWork> skorpan: the difference is that newtype is compiled away to nothing
16:48:24 <codm`> DList looks like just what I need in several situations.  Thanks, guys!
16:48:26 <ivanm> skorpan: at runtime, Int and newtype F = F Int are indistinguishable
16:48:29 <PeakerWork> skorpan: and adds no new bottoms
16:48:48 <PeakerWork> skorpan: http://www.haskell.org/haskellwiki/Newtype
16:48:57 <PeakerWork> are the exact behavioral differences
16:49:00 <c_wraith> Plus, at compile time, newtype is a different type, which provides stronger safety
16:49:11 <c_wraith> Oh.  data creates a new type.  nevermind
16:49:15 <c_wraith> thought you were comparing to type
16:49:36 <ivanm> heh
16:49:43 * ivanm passes a pair of reading glasses to c_wraith 
16:49:51 <skorpan> i heard from someone that newtype is used for isomorphisms somehow?  or that they can be seen as isomorphisms?  i don't know CT, but i'm interested.
16:50:03 <skorpan> this is a separate question btw
16:50:15 <c_wraith> I'm just driven to distraction by the lack of hackage.
16:50:29 <c_wraith> I wonder if I could find the package I need somewhere else to download it.
16:50:33 <ivanm> c_wraith: there's that reverse dependency mirror of hackage...
16:50:42 <ivanm> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/
16:50:46 <PeakerWork> skorpan: newtype N = N Type -- N is completely isomorphic to Type.   data D = D Type  -- D is like "Type" + one extra value, _|_
16:50:59 <ivanm> this is probably a better link: http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
16:51:05 <ivanm> don't know how up-to-date it is though
16:51:16 <skorpan> PeakerWork: but only categories can be "morphic" to eachother right?
16:51:18 <PeakerWork> skorpan: for every value of Type, there's exactly one value of N, and vice-versa.  But D has an extra bottom value that Type does not have, so its not morphic
16:51:22 <PeakerWork> not isomorphic that is
16:51:29 <skorpan> (i don't suppose Integer is a category)
16:51:51 <PeakerWork> skorpan: afaiu, isomorphism has little to do with CT.. its basically structural equivalence. Though maybe I'm not understanding correclt
16:51:51 <c_wraith> "The requested URL /~roel/hackage/packages/archive/EnumMap/0.0.2/EnumMap-0.0.2.tar.gz was not found on this server." nooooo. :(
16:51:58 <ivanm> heh
16:52:05 <ivanm> OK, it only has the web pages, not the tarballs
17:03:11 <Paczesiowa> @hoogle Int -> Double
17:03:12 <lambdabot> Prelude toEnum :: Enum a => Int -> a
17:03:12 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
17:03:12 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
17:04:04 <ivanm> fromInteger is probably a better option
17:04:08 <ivanm> > toEnum 3
17:04:09 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
17:04:13 <ivanm> > toEnum 3 :: Double
17:04:14 <lambdabot>   3.0
17:04:33 <ivanm> @src Double toEnum
17:04:33 <Cale> skorpan: Integer can be thought of as a category in a number of ways (though there isn't a canonical way), and no, not only categories have morphisms between them. In general, a homomorphism is a function of some sort which preserves whatever structure we might be interested in at the time, and an isomorphism is a homomorphism with an inverse that is also a homomorphism.
17:04:33 <lambdabot> Source not found. I am sorry.
17:04:37 * ddarius made a module containing an implementation of real-time queues copied from Okasaki's PhD.
17:04:48 <ivanm> ddarius: is that the one on hackage?
17:05:02 <skorpan> Cale: thanks for the late explanation
17:05:02 <ivanm> AKA that website we can't access? :p
17:05:07 <Cale> skorpan: In the case of Hask, the morphisms between types are just the Haskell-definable functions.
17:05:21 <SamB_XP_> AKI fail
17:05:30 <skorpan> what about the morphisms between typeclasses?  are there any such morphisms?
17:05:58 <Cale> skorpan: and an isomorphism between two types A and B is then just a function f :: A -> B, such that there is another function g :: B -> A so that g . f = id, and f . g = id
17:06:41 <ddarius> ivanm: No.  I imagine there's an implementation on hackage, but the only ones I found (looking specifically at data structure libraries) only had amortized implementations.
17:06:45 <Cale> Conal likes to talk about typeclass morphisms, but what he really means there are morphisms between types which belong to those typeclasses and respect the operations of the typeclass in some way
17:06:56 <ivanm> ddarius: *nod*
17:07:01 <ivanm> I think it's part of some other package IIRC
17:07:20 <skorpan> so an isomorphism some kind of abstraction of bijections?
17:07:21 <Cale> (and the laws of the typeclass)
17:07:37 <Cale> skorpan: yeah, bijections are the isomorphisms in the category of sets and functions
17:07:48 <skorpan> makes sense
17:08:45 <Cale> As to how you can think of the integers as a category, there are a few good ways: you can form a category with just one object, and where the arrows from that object to itself are the integers, and composition is addition, or multiplication
17:09:05 <copumpkin> order!
17:09:05 <chrisf> Cale: there are bijections which are not isomorphisms...
17:09:10 <skorpan> the arrows?
17:09:13 <Cale> You can also form a category whose objects are the integers, and where there is an arrow n -> m when n <= m
17:09:19 <SamB_XP_> chrisf: how can that be ?
17:09:28 <Cale> chrisf: In the category of sets?
17:10:12 <Cale> Or a category whose objects are the integers, and instead, there is a unique arrow n -> m when n divides m.
17:10:20 <chrisf> last i checked, an isomorphism had to be structure-preserving too.
17:10:37 <chrisf> is that conveniently sidestepped by saying `in the category of sets` ?
17:10:42 <Cale> chrisf: Yeah, but there's no structure to preserve in the category of sets, apart from cardinality.
17:10:43 <SamB_XP_> chrisf: depends on the structure you want preserved!
17:10:59 <chrisf> thanks Cale :)
17:11:07 <Cale> chrisf: An isomorphism is an arrow which has an inverse, in whatever category you're talking about.
17:11:33 <chrisf> ok
17:11:52 <SamB_XP_> so, is there a category of rings ?
17:11:55 <chrisf> i'm quite happy to be mistaken, need some mind-expansion ;)
17:12:23 <copumpkin> SamB_XP_: I think there's a category for every algebraic structure isn't there?
17:12:53 <chrisf> SamB_XP_: you should be able to define all kinds of categories, but they may or may not be useful :)
17:13:15 <SamB_XP_> how about a category of mood rings ?
17:13:38 <copumpkin> **** rings?
17:13:46 <copumpkin> where **** = mood obviously
17:13:53 <SamB_XP_> ????
17:14:27 <allbery_b> dont you also need a category for pet rocks in that case?
17:14:54 <chrisf> what meaningful morphisms can you define on that?
17:15:15 <allbery_b> chia?
17:15:16 <copumpkin> pet rock friendship
17:15:22 <copumpkin> where friendship is transitive
17:20:38 <jimi_hendrix> PeakerWork, want to finish our discussion?
17:20:51 <PeakerWork> jimi_hendrix: sorry, a little busy at the moment
17:21:01 <jimi_hendrix> np
17:22:05 <jimi_hendrix> PeakerWork, just got to the Maybe example in learn you a haskell for great good
17:22:47 <jimi_hendrix> could one theoretically make a kernel in haskell?
17:23:29 <ivanm> jimi_hendrix: see House
17:23:32 <ivanm> @where House
17:23:32 <lambdabot> http://programatica.cs.pdx.edu/House/
17:24:34 <tommd1> jimi_hendrix: There have actually been several.
17:24:47 <jimi_hendrix> 0.0
17:24:50 <tommd1> House, hOp, and an L4.
17:24:57 <tommd1> Two L4s, truth be told.
17:25:05 <tommd1> And there are many versions of House.
17:25:43 <ivanm> oh? I only knew of one version...
17:25:57 <tommd1> ivanm: One from Portland State and one from NICTA.
17:26:19 <ivanm> ahhhh
17:26:54 <jimi_hendrix> anyone here try to make one?
17:27:09 <chrisf> guys... where can i find a *good* introduction to category theory? i took the one course my college offered on abstract algebra, and grokked that fine.
17:27:24 <TomMD> Ask wchogg.
17:27:36 <jimi_hendrix> was that @ me?
17:28:10 <ivanm> chrisf: heh, that was asked a couple of hours ago...
17:28:23 <ivanm> Cale: care to provide that book reference to chrisf?
17:28:24 <sinelaw> chrisf, Awoday?
17:28:27 <TomMD> No, I was suggesting chrisf ask chogg about category theory if no one else spoke up... but hogg isn't here either.
17:29:14 <TomMD> jimi_hendrix: You need a compiler that doesn't assume an underlying OS, to start with.  The House project modified GHC to do that, so start there.
17:29:53 <chrisf> "start by modifying the haskell compiler" is a pretty nasty starting point for any project ;)
17:29:59 <TomMD> Or you can look at my kernel modules work for related information.
17:30:12 <jimi_hendrix> lol @ chrisf
17:30:15 <TomMD> chrisf: Well if you shy away from compilers then you probably shouldn't be making a kernel.
17:30:30 <chrisf> truth.
17:31:02 <PeakerWork> @type fmap mappend
17:31:03 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f a -> f (a -> a)
17:31:18 * TomMD going out with his wife.
17:32:03 <chrisf> is it necessary to mod the compiler, or just the runtime library?
17:32:05 <Cale> Sure
17:32:10 <jimi_hendrix> i always just wanted to make a hello world kernel, never got that far in C (windows could have been part of the problem though)
17:32:32 <jimi_hendrix> (hand some linking problem if i recall)
17:32:34 <skorpan> doesn't windows already use a hello world kernel?
17:32:49 <chrisf> *groan*
17:33:18 <monochrom> it uses a hello hell kernel
17:33:27 <chrisf> if you think the NT kernel is crap, you don't understand it ;)
17:33:43 <chrisf> the *rest* of windows might be garbage...
17:34:03 <jimi_hendrix> personally, anyone who writes an OS doesnt deserve complaints
17:34:08 <ivanm> chrisf: by "NT Kernel", do you mean the one in NT itself?
17:34:12 * jimi_hendrix never had a problem with windows
17:34:20 * jimi_hendrix just likes linux better
17:34:22 <ivanm> jimi_hendrix: why, you've never used it? :p
17:34:27 <jimi_hendrix> no
17:34:33 <jimi_hendrix> i have used it extensively
17:34:33 <chrisf> the one in NT versions 3.x - uh, 6.1 :P
17:34:45 <chrisf> where 6.1 = 7
17:35:03 <monochrom> > let 6.1=7 in "good"
17:35:04 <lambdabot>   "good"
17:35:11 <skorpan> chrisf: i know nothing of kernels (like nothing *at all*), it was merely a joke that had to be told
17:35:23 <chrisf> i understand :)
17:36:09 <ivanm> skorpan: well, it didn't _have_ to...
17:37:13 <monochrom> I have to tell you jokes. I have to. I need it desperately.
17:38:07 <gwern> hm. "the tragedy of windows is that it could've had VMS security, Mac userland, and unix-like performance; but it got Mac security, VMS performance, and Unix userland"
17:38:11 <gwern> to repurpose the old canada quip
17:38:25 <monochrom> haha
17:38:26 <ivanm> "old canada quip"?
17:38:34 <ivanm> gwern: and what's wrong with unix userland?
17:38:47 <gwern> ivanm: it's terrible
17:38:51 <gwern> next question
17:39:00 <skorpan> what's better?
17:39:04 <ivanm> are you including GNU userland in that categorisation?
17:39:06 <monochrom> what is the tragedy of c#?
17:39:09 <chrisf> gwern: i wouldnt wish mac userland upon anyone.
17:39:09 <gwern> skorpan: well, mac, obviously
17:39:29 <Baughn> If it had unix userland, I'd be able to run xmonad, wouldn't I?
17:39:31 <ivanm> monochrom: fine, what is it...
17:39:31 <skorpan> monochrom: it SUCKS
17:39:44 <chrisf> skorpan: c# rocks.
17:39:52 <chrisf> for "getting shit done"
17:39:53 <skorpan> chrisf: the only thing that rocks about it is linq
17:39:55 <gwern> monochrom: aw shucks, I don't know c# well enough. maybe ocaml performance, haskell expressivity, and java popularity?
17:40:27 <chrisf> gwern: almost. haskell is still more expressive ;)
17:40:40 <monochrom> java performance, ocaml expressivity, haskell popularity :)
17:40:47 <tehgeekmeister> how do i insert inside my newtype ProblemMap here: http://bit.ly/ZNRHX
17:40:55 <gwern> ivanm: yeah, you've never heard it? iirc it goes could have had french cooking, british culture, and german tech; rearrange the obvious way
17:41:02 <ivanm> gwern: ummmm.... are you saying haskell is or isn't expressive?
17:41:11 <tehgeekmeister> can't derive a functor instance, so fmap won't work.  I wouldn't have a newtype, but without it the template haskell seems to not work.
17:41:11 <ivanm> gwern: oh, I haven't heard of it as a canadian joke
17:41:15 <ivanm> just a heaven/hell joke
17:41:26 <gwern> ivanm: really? I can't think how it'd work for that
17:41:52 <ivanm> gwern: heaven has french cooking, etc.; re-arrange for hell
17:42:02 <gwern> ivanm: oh. canada works better
17:42:35 <ivanm> gwern: only for people in north america
17:42:47 <ivanm> sometimes you yanks seem to forget there are other people in the world...
17:42:58 * EvilTerran (a brit) heard it told about north america as a whole
17:43:08 <gwern> monochrom: ok, that arrangement works for me! I might've said haskell performance and java expressivity tho
17:43:20 <gwern> ivanm: lies! all the other people are unimportant
17:43:22 <ivanm> EvilTerran: yeah, that's better :p
17:43:29 <ivanm> @slap gwern
17:43:29 * lambdabot hits gwern with an assortment of kitchen utensils
17:43:56 <monochrom> haskell performance is a moving target. not unanimously fast but not unanimously slow either.
17:44:38 <chrisf> not unanimously... people can't agree on whether it is fast or not?
17:44:48 <tehgeekmeister> monochrom: depends largely on how well you've adapted to haskell-style programming, more so than say, someone going from ruby to python.  for obvious reasons.
17:44:49 <gwern> every language whines like that: 'but over here we're fast!'
17:45:36 <ivanm> gwern: wow, computational/mathematical abstractions can whine? :o
17:45:39 <jimi_hendrix> delayed response, i like C#
17:45:53 <gwern> ivanm: they're turing complete, of course they can whine!
17:45:54 <ivanm> jimi_hendrix: and the response is delayed because of your C# IRC client? :p
17:46:11 <c_wraith> Haskell can benchmark really fast when you forget to force the entire result.
17:46:19 <ivanm> gwern: ummmm..... turing complete -/-> AI
17:46:25 <ivanm> c_wraith: heh
17:46:39 <gwern> ivanm: of course turing complete means you can run a strong AI
17:46:41 <EvilTerran> ivanm, so they can whine, you just have to tell them too first
17:46:45 <chrisf> ivanm: perhaps it was his haskell irc client had a slight laziness bug and decided to cons several gigs of heap before replying.
17:46:48 <EvilTerran> s/too/to/
17:47:00 <chrisf> c_c
17:47:04 <ivanm> EvilTerran: heh
17:47:11 <jimi_hendrix> ivanm, no, because i was minimized...
17:47:31 <ivanm> jimi_hendrix: someone minimized you? how? :p
17:47:36 <monochrom> tehgeekmeister: addProblem p = modify (\pm -> ProblemMap (Map.insert 1 p (unProblemMap pm))) where unProblemMap (ProblemMap x) = x
17:47:38 <Orclev> @src last
17:47:39 <lambdabot> last [x]    = x
17:47:39 <lambdabot> last (_:xs) = last xs
17:47:39 <lambdabot> last []     = undefined
17:47:53 <jimi_hendrix> ivanm, i ate a poisoned mushroom i found in a box with a ? on it
17:47:56 <aavogt> > last []
17:47:57 <lambdabot>   * Exception: Prelude.last: empty list
17:48:02 <ivanm> jimi_hendrix: oh, OK
17:48:04 <aavogt> lambdabot: lies!
17:48:10 <ivanm> aavogt: heh
17:48:10 <jimi_hendrix> how would i get the char for the next key pressed
17:48:19 <ivanm> @hoogle getChar
17:48:19 <lambdabot> Prelude getChar :: IO Char
17:48:20 <lambdabot> System.IO getChar :: IO Char
17:48:20 <lambdabot> System.IO hGetChar :: Handle -> IO Char
17:48:45 <tehgeekmeister> monochrom: awesome, thanks.
17:49:35 <chrisf> monochrom: that code looks interesting, what the hell does it do?
17:49:36 <jimi_hendrix> perfect
17:50:04 <ivanm> chrisf: it looks interesting
17:50:09 <ivanm> what more do you want it to do? :p
17:50:10 <jimi_hendrix> now how can i turn that char to the ASCII int
17:50:14 <jimi_hendrix> no wait
17:50:15 <SubStack> hackage.haskell.org is down. I feel lost.
17:50:17 <ivanm> @hoogle ord
17:50:17 <lambdabot> Data.Char ord :: Char -> Int
17:50:17 <jimi_hendrix> let me google
17:50:17 <lambdabot> module Data.Ord
17:50:17 <lambdabot> Prelude class Eq a => Ord a
17:50:20 <jimi_hendrix> or that works
17:50:23 <ivanm> ;-)
17:50:32 <Baughn> Or you can use fromEnum, which is also in the prelude
17:50:36 * ivanm gives SubStack a map and a compass
17:50:41 <monochrom> unpacks a newtype that's simply a Data.Map.Map, adds a key and value, re-packs the result back to the newtype.
17:50:50 * SubStack orienteers
17:50:54 <ivanm> > fromEnum 'a' == ord 'a'
17:50:54 <lambdabot>   True
17:51:13 <aavogt> @check \x -> fromEnum x == ord x
17:51:14 <Baughn> @check \x -> fromEnum x == ord x
17:51:14 <lambdabot>   "OK, passed 500 tests."
17:51:15 <lambdabot>   "OK, passed 500 tests."
17:51:22 <monochrom> It looks interesting because it is a conjugate, like PDP^-1 in linear algebra and gxg^-1 in group theory.
17:51:36 <copumpkin> @check liftA2 (==) fromEnum ord
17:51:38 <lambdabot>   "OK, passed 500 tests."
17:51:41 <jimi_hendrix> now how do i do it with an IO Char
17:51:42 <chrisf> indeed.
17:51:57 <Baughn> jimi_hendrix: fmap fromEnum into it
17:51:59 <chrisf> the form of `where unFoo Foo x = x` is nice :)
17:52:24 <chrisf> i'm new to this btw :S
17:52:29 <aavogt> > all (liftA2 (==) fromEnum ord) $ take 500 ['\NULL' .. ]
17:52:30 <lambdabot>   <no location info>:
17:52:31 <lambdabot>      lexical error in string/character literal at chara...
17:52:39 <aavogt> > all (liftA2 (==) fromEnum ord) $ take 500 ['\0' .. ]
17:52:40 <lambdabot>   True
17:52:47 <SamB_XP_> monochrom: I've never heard of *that* PDP before ...
17:52:50 <monochrom> "where" is the best thing since scoping.
17:52:51 <SamB_XP_> how is it pronounced ?
17:53:17 <Baughn> > all (liftA2 (==) fromEnum ord) $ ['\0'..]
17:53:18 <lambdabot>   True
17:53:20 <monochrom> pattern matching is the best thing since algebraic data types.
17:53:34 <ivanm> Baughn: OK, that's enough...
17:53:47 <ivanm> > last ['\0'..]
17:53:48 <lambdabot>   '\1114111'
17:53:49 <SamB_XP_> monochrom: sliced bread is the best thing since ?
17:53:56 <copumpkin> hot water
17:54:03 <jimi_hendrix> and how do i use fmap please
17:54:06 <jimi_hendrix> my guessing was wrong
17:54:20 <copumpkin> fmap is like map, except more general!
17:54:23 <copumpkin> > fmap (+1) [1..10]
17:54:31 <copumpkin> > fmap (+1) (Just 5)
17:54:31 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:54:33 <lambdabot>   Just 6
17:54:40 <Baughn> > fmap fromEnum getChar
17:54:41 <lambdabot>   <IO Int>
17:54:43 <BMeph> newtype MyProblemMap = ProblemMap {unProblemMap :: Data.Map.Map MyKey MyValue} -- or the moral equivalent thereof... :)
17:54:44 <copumpkin> > fmap (+1) (+5) 4
17:54:45 <aavogt> > succ . [1..10]
17:54:45 <lambdabot>   10
17:54:46 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:54:50 <monochrom> sliced bread is the best thing since sliced meat
17:55:22 <chrisf> when is `... where foo` nicer than `let foo in... `?
17:55:22 <SamB_XP_> bugs are the best thing since ?
17:55:50 <copumpkin> insects
17:55:52 <SamB_XP_> chrisf: when those definitions will just annoy the reader who is trying to see what's going on
17:56:08 <monochrom> Equally nice. Some syntactic restriction may force you to use one of them.
17:56:09 <chrisf> so do we prefer `where` ?
17:56:11 <EvilTerran> chrisf, the way i look at it is that, in "foo ... = ... where ...", the primary equation, defining foo, is all grouped together
17:56:12 <chrisf> oh.
17:56:35 <EvilTerran> chrisf, and, in an equivalent "foo ... = let ... in ...", the primary equation has a block in the middle. which i find undesirable.
17:56:38 <chrisf> ok, where looks more consistent with the way i've done math :)
17:56:44 <jimi_hendrix> ok
17:56:56 <aavogt> you can use 'let' in more cases since it is an expression, while where isn't
17:57:16 <jimi_hendrix> ah
17:57:18 <jimi_hendrix> i see
17:57:20 <monochrom> I try to use both together so the let fans hate me for mixing in where, and the where fans hate me for mixing in let.
17:57:22 <SamB_XP_> aavogt: ... unlike in math
17:57:27 <jimi_hendrix> i was doing fmap getChar fromEnum
17:57:28 <jimi_hendrix> xD
17:57:29 <chrisf> also, where to after doing `learn you a haskell...` ?
17:57:52 <SamB_XP_> chrisf: you could look for a pirated copy of Real World Haskell ...
17:57:58 <SamB_XP_> ... or you could just use the site ;-P
17:58:34 <BMeph> :t `fmap` getChar fromEnum
17:58:35 <lambdabot> parse error on input ``'
17:58:44 <monochrom> f x = let y = z in y where z = x y
17:58:47 <BMeph> :t (`fmap` getChar) fromEnum
17:58:48 <lambdabot> IO Int
17:58:49 <chrisf> i've read RWH.
17:59:20 <SamB_XP_> chrisf: A [not-so-]Gentle Introduction to Haskell ?
17:59:24 <aavogt> the scoping is different too:
17:59:27 <BMeph> chrisf: How about "A gentle Introduction to Haskell"? :)
17:59:44 * BMeph likes the way Sam_XP_ thinks!
17:59:52 <aavogt> > do x <- return y; let z = x; return z
17:59:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:59:59 <SamB_XP_> (how come they haven't retitled it to that yet?)
18:00:24 * aavogt can't desugar layout right now
18:00:32 <ivanm> chrisf: my first step after reading LYAH would be to scrub my brain with a coarse brush... >_>
18:00:44 <SamB_XP_> do { x <- return y; let z = x; return z }
18:00:47 <monochrom> The next step is write your own tutorial.
18:00:59 <SamB_XP_> > do { x <- return y; let z = x; return z }
18:01:01 <lambdabot>   <no location info>: parse error on input `}'
18:01:12 <aavogt> > do x <- return y; let {z = x} ; return z
18:01:13 <SamB_XP_> monochrom: on Haskell, not Monads, I hope?
18:01:13 <lambdabot>   No instance for (GHC.Show.Show (m SimpleReflect.Expr))
18:01:13 <lambdabot>    arising from a us...
18:01:25 <ivanm> SamB_XP_: damn, you beat me to it!
18:01:30 <aavogt> > do x <- [1..10]; let {z = x} ; return z
18:01:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:01:40 <ivanm> @undo do { x <- return y; let z = x; return z}
18:01:40 <lambdabot>  Parse error at "}" (column 40)
18:01:45 <ivanm> @undo do x <- return y; let z = x; return z
18:01:45 <lambdabot>  Parse error at end of input
18:01:49 <ivanm> @undo x <- return y; let z = x; return z
18:01:50 <lambdabot>  Parse error at "<-" (column 3)
18:01:56 <ivanm> @slap lambdabot
18:01:56 <lambdabot> I don't perform such side effects on command!
18:01:57 <aavogt> > do { x <- [1..10]; return z } where z = x -- doesn't work
18:01:58 <lambdabot>   <no location info>: parse error on input `where'
18:02:03 <SamB_XP_> @undo do x <- return y; let {z = x}; return z
18:02:03 <lambdabot> return y >>= \ x -> let { z = x} in return z
18:02:26 <aavogt> @slap you
18:02:26 * lambdabot beats up you
18:02:35 <aavogt> @slap lunabot
18:02:36 * lambdabot throws some pointy lambdas at lunabot
18:02:44 <drhodes> is the  do notation in IO different from other monads?
18:02:57 <ivanm> drhodes: no
18:03:15 <drhodes> ok. thanks ivanm
18:03:17 <aavogt> the results can be different in other monads though
18:03:28 <jimi_hendrix> bah, can i make an IO int an Int so i can access my list?
18:03:32 <ivanm> aavogt: well, the _notation_ is the same
18:03:51 <ivanm> jimi_hendrix: myInt <- myIOInt
18:03:57 <c_wraith> Syntactically, IO is just like any other monad.  Semantically, it has a few differences.  (mostly in that outside events can change things)
18:04:08 <Baughn> jimi_hendrix: No, but you can make the function you'd use to access it into an IO function. :3
18:04:30 <Baughn> jimi_hendrix: ..though do-syntax does a good job at pretending you can.
18:04:38 <aavogt> ivanm: exactly
18:04:42 <jimi_hendrix> ok
18:06:27 <Orclev> @src nub
18:06:27 <lambdabot> nub = nubBy (==)
18:06:35 <Orclev> @src nubBy
18:06:35 <lambdabot> nubBy eq []             =  []
18:06:35 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:07:05 * SamB_XP_ is a bit surprised that a cmd.exe process owns its console window ... wonders if that's true in RoS yet ...
18:07:39 <Orclev> hmm... so nub just runs filter over and over again... that seems very... inefficient
18:07:40 <ivanm> SamB_XP_: RoS?
18:07:47 <ivanm> Orclev: it is
18:07:50 <ivanm> O(n^2)
18:07:52 <SamB_XP_> ReactOS
18:07:55 <ivanm> ahhhh
18:07:57 <SamB_XP_> the free NT clone
18:08:08 <Baughn> Orclev: Given its type signature, there is little else it could possibly do
18:08:08 <ivanm> SamB_XP_: well, the free Windows clone
18:08:13 <SamB_XP_> no, NT clone
18:08:19 <SamB_XP_> it's *not* going for 9x
18:08:19 <ivanm> Orclev: there are nicer things you can do if you allow Ord
18:08:24 <SamB_XP_> (that's too hard!)
18:08:24 <ivanm> SamB_XP_: it used to be...
18:08:26 <chrisf> SamB_XP_... cmd owning its own console... what version of windows is this?
18:08:31 <ivanm> nowadays it's going for XP though, isn't it?
18:08:33 <jimi_hendrix> and what does IO b mean
18:08:37 <SamB_XP_> ivanm: XP is still NT
18:08:49 <ivanm> well, NT based
18:08:49 <Orclev> ivanm: anything standard that requires Ord, or are these nicers things you have to write yourself?
18:08:56 <ivanm> Orclev: yourself
18:09:01 <SamB_XP_> NT is the core
18:09:01 <Baughn> ivanm: Although, it should be possible to use some type-class hackery to make an efficient nub for Ord types
18:09:06 <Axman6> jimi_hendrix: it's an IO action, that returns something of type b
18:09:06 <Baughn> Orclev: Data.Set, mainly
18:09:07 <ivanm> Orclev: well, if you don't care about the order, theres Set.toList . Set.fromList
18:09:18 <SamB_XP_> like Linux is what sits inside Ubuntu Hoary
18:09:23 <jimi_hendrix> where b means what
18:09:27 <jimi_hendrix> is it just like a?
18:09:28 <ivanm> ir you do care about the order, then you write smarter filters, etc.
18:09:31 <SamB_XP_> scheduling ur processes
18:09:32 <Axman6> jimi_hendrix: yes
18:09:34 <ivanm> jimi_hendrix: a type variable, yes
18:09:41 <Orclev> @hoogle nub
18:09:41 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
18:09:41 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
18:09:45 <ivanm> greetings Man ox Ax, 6th of that name! ;-)
18:09:48 <ivanm> *of
18:10:26 <aavogt> ah, how Haskell would be without camel case
18:10:34 <monochrom> performance of man, userland of ox, expressivity of axe...
18:10:37 <aavogt> nubby is quite different from nubBy
18:10:59 * Axman6 takes a bow
18:11:06 <SamB_XP_> ivanm: do you get it now ?
18:11:23 <ivanm> SamB_XP_: well, it's an NT-series kernel...
18:11:38 <ivanm> but doesn't NT itself refer to that version of Windows?
18:11:46 <SamB_XP_> that's called NT 4
18:11:51 <jimi_hendrix> and what does it mean when ghc cant match an IO b to <whatever type the function i just tainted's return type is>
18:12:13 <Axman6> it means you did it wrong...
18:12:19 <SamB_XP_> XP is in the 5.x series
18:12:23 <SamB_XP_> I forget exactly where
18:12:28 <Axman6> you'll need to give us more details to tell you what your problem is jimi_hendrix
18:12:33 <chrisf> 5.1
18:12:38 <Orclev> @hoogle Set a -> Int
18:12:39 <lambdabot> Data.Set size :: Set a -> Int
18:12:39 <lambdabot> Data.Set findMax :: Set a -> a
18:12:39 <lambdabot> Data.Set findMin :: Set a -> a
18:12:42 <ivanm> Axman6: heh, I was thinking of saying that but decided to be nice on the newbie...
18:12:49 <SamB_XP_> okay, 2000 must be NT 5.0 then ...
18:13:00 <chrisf> indeed it is.
18:13:05 <chrisf> and 2k3 = 5.2
18:13:14 <jimi_hendrix> Axman6, what else do you need
18:13:20 <Axman6> jimi_hendrix: the code and the error
18:13:26 <ivanm> not here though!
18:13:29 <ivanm> paste it up somewhere
18:13:32 <Axman6> @where hpaste
18:13:32 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
18:13:35 <SamB_XP_> ... so, is Windows 7 actually NT 7.0 ?
18:13:44 <monochrom> scientific method. reproducible problem.
18:13:45 <chrisf> no, it's 6.1
18:13:45 <ivanm> SamB_XP_: I think it's 6. something
18:13:52 <SamB_XP_> lame lame
18:13:54 <chrisf> no fucking clue why.
18:14:17 <SamB_XP_> they should have bumped the number just to make things match :-P
18:14:19 <chaosape> hackage mirror anywhere?
18:14:29 <chrisf> hackage is *still* down?
18:14:32 <monochrom> no hackage mirror
18:14:35 <SamB_XP_> :-(
18:14:49 <SamB_XP_> chaosape: I think we've learned our lesson re: lack of hackage mirrors ...
18:15:01 <SamB_XP_> ... I just hope we do what that implies we should do!
18:15:26 <magma_> @undo do progName <- getProgName; putStr $ usageMsg progName; exitWith $ ExitFailure 1
18:15:27 <lambdabot> getProgName >>= \ progName -> putStr $ usageMsg progName >> exitWith $ ExitFailure 1
18:15:29 <jimi_hendrix> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10901#a10901 Axman6
18:16:13 <chaosape> f.
18:16:28 <monochrom> Axman6: http://www.multivax.com/last_question.html  :)
18:16:52 <ivanm> monochrom: yeah, that's a good one
18:17:07 <Orclev> @hoogle [a] -> a
18:17:08 <lambdabot> Prelude head :: [a] -> a
18:17:08 <lambdabot> Prelude last :: [a] -> a
18:17:08 <lambdabot> Data.List head :: [a] -> a
18:17:17 <ivanm> monochrom: heh: http://www.multivax.com/
18:17:24 <ivanm> (which I presume you've seen...)
18:17:24 <monochrom> Yeah!
18:17:29 <jimi_hendrix> need more?
18:17:49 <ivanm> ooohhhhh.... there was a comic version of the last question? :o
18:17:59 <ivanm> http://www.multivax.com/images.html
18:18:17 <monochrom> I love the story more because it rubs "insufficient data for a meaningful answer" into people.
18:18:24 <ivanm> heh
18:18:57 * ivanm recently managed to finally get hold of a copy of asimov's "last" foundation novel and read it
18:19:40 <jimi_hendrix> well what else do you want?
18:19:48 <ivanm> monochrom: heh: http://interconnected.org/notes/2003/05/last-query.html
18:19:53 <ivanm> s/multivax/google/ ;-)
18:20:35 <Absolute0> What is wrong with: 'let helper _ _ _ _ m m  = m + 1' ?
18:20:42 <Absolute0>  Conflicting definitions for `m'
18:20:42 <Absolute0>     In the definition of `helper'
18:20:58 <monochrom> cannot have "m" twice in pattern
18:21:31 <monochrom> helper _ _ _ _ m n | m==n = m+1  if you really ask for equality
18:21:37 <Cale> Perhaps you want  helper _ _ _ _ m n | m == n = m + 1 ... yeah
18:22:12 <jimi_hendrix> here is my full function with the error
18:22:24 <ivanm> jimi_hendrix: give Axman6 time! ;-)
18:22:46 <jimi_hendrix> i thought he wanted more info?
18:23:20 <ivanm> preflex: seen Axman6
18:23:20 <preflex>  Axman6 was last seen on #haskell 9 minutes and 48 seconds ago, saying: @where hpaste
18:23:31 <ivanm> jimi_hendrix: you gave him the paste of the code and the error?
18:23:38 <ivanm> what more info would he want?
18:24:07 <ivanm> jimi_hendrix: what is the type of getPlayer ?
18:24:16 <ivanm> jimi_hendrix: is it an IO function? ;-)
18:24:20 <Absolute0> monochrom: Oh I am confusing variables with constants, thanks :)
18:24:34 <ivanm> jimi_hendrix: you want: return $ getPlayer hands !! (choice - 97)
18:24:34 <jimi_hendrix> no
18:24:45 <Warrigal> I suppose that if I want a Haskell program to have persistent data, I should use a database.
18:24:53 <ivanm> jimi_hendrix: in a do-block, it has to all be monadic statements
18:25:03 <ivanm> Warrigal: or something like it, yes
18:25:04 <jimi_hendrix> getPlayer hands = hands !! 0
18:25:06 <jimi_hendrix> ivanm, what?
18:25:12 * jimi_hendrix hasnt gotten to monads yet
18:25:24 <ivanm> jimi_hendrix: OK, let's simplify
18:25:40 <monochrom> make that: it has to all be IO actions.
18:25:52 <ivanm> in a do-block, every statement has to be one of these: a <- foo; let b = blah or else some IO function/action
18:26:01 <jimi_hendrix> same error
18:26:03 <ivanm> monochrom: bah, I prefer call them functions still
18:26:19 <jimi_hendrix> ok
18:26:21 * Warrigal ponders what sort of data he wants to store.
18:26:43 <ivanm> jimi_hendrix: so, if you have a non-IO function and you want the result of that do-block to be the output of the function, you need to do: return $ foo a
18:26:54 * jimi_hendrix made his last statement return ... and it works
18:27:45 <jimi_hendrix> ok
18:28:04 <Warrigal> Does using a database mean goodbye, 1-megabyte executable?
18:28:07 <Warrigal> (I'm guessing not.)
18:28:30 <jimi_hendrix> no
18:28:43 <Warrigal> Keiya: hey, I didn't know you were a Haskelleur.
18:28:58 <monochrom> I don't know which side of goodbye you mean.
18:29:10 <ivanm> Warrigal: well, the databases are usually external...
18:29:20 <ivanm> since you don't typically edit the actual executable ;-)
18:29:27 <Warrigal> Indeed!
18:29:34 <jimi_hendrix> mysql is its own daemon for example
18:29:45 <ivanm> Warrigal: and executables produced by GHC typically are always the same size
18:29:51 <jimi_hendrix> really?
18:30:01 <ivanm> since most of it is taken up by the RTS, etc.; using extra libs doesn't take up all that much extra space
18:30:38 <ivanm> OK, here, I have xmonad at 1.5M, darcs at 5.9M and pandoc at 7.5M
18:30:44 <ivanm> so there is some increase
18:30:46 <Warrigal> Those aren't the same size at all.
18:31:00 <ivanm> Warrigal: not much of an order of magnitude change
18:31:18 <ivanm> Warrigal: despite using static linking, the executables don't blow out to hundreds or megs
18:31:41 <Warrigal> So, I guess I'll want to link a database engine.
18:32:37 <Warrigal> Shall I use HaskellDB, then?
18:33:32 <Warrigal> Maybe there's another standalone option.
18:33:34 * ivanm has never used a DB in Haskell...
18:33:55 <jimi_hendrix> now Common Lisp executables are 10 mb for hello world
18:33:59 <ivanm> Warrigal: maybe sqlite if you want a stand-alone DB?
18:34:23 <TomMD-TB> when you hear "ffi" what libaries come to mind?
18:34:33 <ivanm> Warrigal: RWH uses HDBC...
18:34:43 <ivanm> TomMD-TB: ones written in C ;-)
18:35:26 <monochrom> gtk
18:35:30 <jimi_hendrix> ffi?
18:36:32 <TomMD-TB> gtk, that would be a tough one
18:37:23 <TomMD-TB> ffi= foreign function interface
18:37:46 <jimi_hendrix> ah
18:38:22 <TomMD-TB> cool, but causes issues
18:38:58 <patch-tag> is hackage.haskell.org down?
18:39:00 * TomMD-TB goes away
18:39:24 <copumpkin> http://downforeveryoneorjustme.com/ belongs in the topic :P
18:39:29 <copumpkin> patch-tag: yes
18:39:38 <patch-tag> cool site :)
18:39:49 <dolio> Nobody reads the topic anyway.
18:39:51 <roconnor> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
18:40:08 <dolio> You can put "Yes, foo is down" in the topic, and people still ask.
18:40:24 <Absolute0> Whats the type signature for a function that accepts to functions and returns and int?
18:40:48 <lispy> Absolute0: what is the type signature of a function
18:40:51 <Absolute0> (a -> b) -> (b -> c) -> Int doesn't do the job.
18:41:13 <ivanm> copumpkin: I already suggested that!
18:41:14 <copumpkin> that would be a very strange function
18:41:26 <monochrom> I don't see "hackage is down" in the topic.
18:41:28 <copumpkin> or a very useless one
18:42:00 <ivanm> copumpkin: I go for the latter
18:42:05 <lispy> > :t \x y -> 5 :: (a -> b) -> (b -> c) -> Int
18:42:06 <lambdabot>   <no location info>: parse error on input `:'
18:42:14 <ivanm> @djinn (a -> b) -> (b -> c) -> Int
18:42:15 <lambdabot> Error: Undefined type Int
18:42:17 <ivanm> gah
18:42:18 <Absolute0> FUNC :: (f1 takes a returns b) -> (f2 takes b returns c) -> c
18:42:20 <dolio> It isn't in the topic, but it wouldn't matter even if it were.
18:42:20 <ivanm> @djinn (a -> b) -> (b -> c) -> Integer
18:42:20 <lambdabot> Error: Undefined type Integer
18:42:24 <lispy> > :t (\x y -> 5) :: (a -> b) -> (b -> c) -> Int
18:42:25 <lambdabot>   <no location info>: parse error on input `:'
18:42:30 <monochrom> It is also a topic set on July 30.
18:42:40 <lispy> > > (\x y -> 5) :: (a -> b) -> (b -> c) -> Int
18:42:41 <lambdabot>   <no location info>: parse error on input `>'
18:42:44 <lispy> > (\x y -> 5) :: (a -> b) -> (b -> c) -> Int
18:42:45 <lambdabot>   {{()->()}->{{()->()}->5}}
18:42:47 <ivanm> why doesn't djinn like the Int? doesn't it use "real" types?
18:42:56 <lispy> ivanm: nope
18:43:00 <Absolute0> i mean c sorry
18:43:05 * monochrom adds "reddit may be down some time in the future" to the topic :)
18:43:14 <ivanm> lispy: :(
18:43:20 <ivanm> Absolute0: (.) ?
18:43:30 <ivanm> Absolute0: you need to provide an a as well...
18:43:31 <dolio> @djinn-add data Int = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
18:43:32 <lambdabot> Cannot parse command
18:43:32 <ivanm> monochrom: heh
18:43:32 <lispy> :t (.)
18:43:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:43:44 <lispy> ugh, that's Caleskell
18:43:46 <lispy> Not Haskell
18:43:50 <ivanm> lispy: :o
18:43:50 <lispy> ?hoogle (.)
18:43:51 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
18:43:51 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
18:43:51 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
18:43:53 <copumpkin> @djinn-add data Int = One | Two | Three | Four | Five | Six | Seven | Eight
18:44:03 <ivanm> @type (.)
18:44:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:44:13 <ivanm> @djinn (a -> b) -> (b -> c) -> Int
18:44:13 <lambdabot> f _ _ = One
18:44:21 <lispy> :t Prelude.(.)
18:44:22 <lambdabot> Not in scope: data constructor `Prelude'
18:44:22 <ivanm> copumpkin: should have had a Zero...
18:44:30 <Absolute0> http://pastie.org/660042 <- this is what i am trying to do, check if f an g are inverses of each other for the range [min..max]
18:44:32 <ivanm> :t (Prelude..)
18:44:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:44:37 <Absolute0> I am getting errors
18:44:42 <ivanm> lispy: ^^ need parens around the whole thing
18:45:16 <ivanm> Absolute0: \x -> x == (f . g) x
18:45:30 <Absolute0> http://pastie.org/660044
18:45:36 <Cale> Absolute0: f.g x means f . (g x)
18:45:42 <ivanm> Absolute0: \f g range -> all (\x -> x == (f . g) x) range
18:46:05 <ivanm> (f . g) x == f $ g x == f . g $ x
18:46:23 <BMeph> Has anyone on tried that "Leo" outlining editor? I'm unimpressed by the semi-spam, yet still curious... :)
18:46:52 <ivanm> Leo /= emacs, so no ;-)
18:47:36 <ivanm> ugh, the screenshots look ugly :s
18:48:14 <lispy> BMeph: the person that brought up Leo and was very pro-Leo admitted to not actually using it
18:48:37 <lispy> BMeph: to me, that made it not even worth looking at unless I was going to explicitly set out to be inspired by it
18:49:00 <lispy> BMeph: But, don't listen to me, I'm an old curmudgeon at times
18:49:48 <sjanssen> @djinn Int
18:49:48 <lambdabot> f = One
18:49:59 <sjanssen> @djinn Maybe a -> Int
18:49:59 <lambdabot> f a =
18:49:59 <lambdabot>     case a of
18:49:59 <lambdabot>     Nothing -> One
18:49:59 <lambdabot>     Just _ -> Two
18:50:08 <sjanssen> @djinn Maybe Int -> Int
18:50:08 <lambdabot> f a =
18:50:08 <lambdabot>     case a of
18:50:08 <lambdabot>     Nothing -> One
18:50:08 <lambdabot>     Just b -> b
18:50:25 <BMeph> lispy: Eh, I'm a general goofball-turned old curmudgeon, so it works for me. :)
18:50:48 <monochrom> f.g x == f.g x is disturbing on two counts.
18:50:54 <sjanssen> @djinn Maybe (Maybe (Maybe ())) -> Int
18:50:54 <lambdabot> f a =
18:50:55 <lambdabot>     case a of
18:50:55 <lambdabot>     Nothing -> One
18:50:55 <lambdabot>     Just b -> case b of
18:50:55 <lambdabot>               Nothing -> One
18:50:56 <lambdabot>               Just c -> case c of
18:50:59 <lambdabot>                         Nothing -> One
18:51:00 <lambdabot>                         Just _ -> Two
18:51:03 <sjanssen> okay, done spamming, sorry
18:51:17 <BMeph> ivanm: Shouldn't your third and second clauses of that multi-equality be swapped? :)
18:51:28 <ivanm> @djinn Int -> Int -> Int
18:51:29 <lambdabot> f a b =
18:51:29 <lambdabot>     case a of
18:51:29 <lambdabot>     One -> b
18:51:29 <lambdabot>     Two -> b
18:51:29 <lambdabot>     Three -> b
18:51:31 <lambdabot>     Four -> b
18:51:31 <lispy> BMeph: I'd rather have someone make an email client that is open source and similar to gmail...So like Zimbra but open source...Editor is lower on my list of deseriables :)
18:51:33 <lambdabot>     Five -> b
18:51:35 <lambdabot>     Six -> b
18:51:37 <lambdabot>     Seven -> b
18:51:39 <lambdabot>     Eight -> One
18:51:40 <ivanm> :o
18:51:40 <dancor> zomg
18:51:44 <lispy> Okay, seriously
18:51:45 <dolio> Wow.
18:51:45 <copumpkin> wow, spambot
18:51:48 <lispy> Someone ban lambdabot ;)
18:51:53 <ivanm> that's a weird djinn output...
18:51:54 <copumpkin> spambdabot
18:52:05 * ivanm doesn't get the Eight -> One ...
18:52:20 <dancor> who defined Int in djinn
18:52:21 <sjanssen> lambdabot leverages the full power of a theorem prover to spam #haskell
18:52:24 <ivanm> BMeph: eh, I typed `em as I thought `em
18:52:28 <lispy> sjanssen: haah
18:52:32 <ivanm> dancor: some vegetabalish nick methinks...
18:52:35 <copumpkin> lol
18:52:36 <ivanm> ;-)
18:52:39 <lispy> sjanssen: that needs to appear in HWN!
18:52:51 <ivanm> lispy: then @remember it!
18:53:08 <lispy> ?remember [after using djinn] <sjanssen> lambdabot leverages the full power of a theorem prover to spam #haskell
18:53:13 <lambdabot> Done.
18:53:36 <ivanm> lispy: ummmm.... you do realise that the quote now belongs to [after ?
18:53:41 <BMeph>  ?remember sjanssen [after using djinn] lambdabot leverages the full power of a theorem prover to spam #haskell
18:53:42 <copumpkin> lispy: that won't work at all
18:53:44 <lispy> ivanm: ah, bummer
18:53:46 <ivanm> @forget  [after using djinn] <sjanssen> lambdabot leverages the full power of a theorem prover to spam #haskell
18:53:46 <lambdabot> Done.
18:53:51 <ivanm> @quote djinn
18:53:51 <BMeph> ?remember sjanssen [after using djinn] lambdabot leverages the full power of a theorem prover to spam #haskell
18:53:51 <lambdabot> sjanssen says: @djinn Haskell -> Curry
18:53:51 <lambdabot> I will never forget.
18:53:55 <ivanm> @quote djinn
18:53:55 <lambdabot> sjanssen says: @djinn Haskell -> Curry
18:53:56 <ivanm> @quote djinn
18:53:57 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
18:53:58 <ivanm> @quote djinn
18:53:59 <lambdabot> sjanssen says: [after using djinn] lambdabot leverages the full power of a theorem prover to spam #haskell
18:54:02 <ivanm> OK, it's in
18:54:17 <copumpkin> @djinn Program -> Proof
18:54:18 <lambdabot> Error: Undefined type Program
18:54:19 <ivanm> @quote [after
18:54:20 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:54:20 <ivanm> ;-)
18:54:32 <lispy> ?quote your mom
18:54:32 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
18:54:35 <sjanssen> @djinn-add data Int = GoAway
18:54:44 <ivanm> sjanssen: :(
18:54:53 <ivanm> @djinn Int -> Int
18:54:53 <lambdabot> f a = a
18:54:56 <ivanm> @djinn Int -> Int -> Int
18:54:56 <lambdabot> f _ a = a
18:54:58 <ivanm> heh
18:55:35 <ivanm> @djinn-add data Peano = Zero | Succ Peano
18:55:35 <lambdabot> Error: Recursive types are not allowed: Peano
18:55:39 <ivanm> @djinn-add data Peano = Zero | Succ_Peano
18:55:40 <lambdabot> Cannot parse command
18:55:42 <ivanm> bah
18:56:01 <Absolute0> What's an elegant way to check how many (f.f.f....) n compositions are needed to equal some number k < MAX?
18:56:01 <monochrom> djinn doesn't do recursive data like those.
18:56:12 <ivanm> monochrom: yeah, I know
18:56:18 <Absolute0> I tried different foldl variations
18:56:22 <ivanm> I was just hoping it would take "Succ Peano" literally
18:56:23 <Absolute0> its hard to construct it properly
18:56:28 <sjanssen> Absolute0: dropWhile and iterate?
18:56:31 <dancor> Absolute0: what happens on MAX?  error "max!"
18:56:31 <dancor> ?
18:56:35 <ivanm> sjanssen: agreed
18:56:45 <sjanssen> > iterate succ 1
18:56:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:56:48 <Absolute0> if k >= max then return max + 1
18:56:54 <monochrom> > iterate f a
18:56:55 <ivanm> sjanssen: actually, takeWhile would be better
18:56:55 <lambdabot>   [a,f a,f (f a),f (f (f a)),f (f (f (f a))),f (f (f (f (f a)))),f (f (f (f (...
18:57:02 <magma_> Hey folks, I saw "do ~[n] <- getArgs" somewhere, and it seems to assign the first arg to "n".  But I can't find the "~[x]" notation documented anywhere... What IS that??
18:57:21 <ivanm> magma_: ~ == irefutable patterns or some such
18:57:49 <ivanm> @src partition
18:57:49 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:57:49 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:57:49 <lambdabot>                               | otherwise = (ts, x:fs)
18:57:50 <sjanssen> magma_: ~ is a lazy pattern match, it means that if there isn't exactly one arg, the program will crash when you use 'n' rather than where the pattern appears
18:58:23 <monochrom> http://www.haskell.org/onlinereport/exps.html#sect3.17.1  has ~pattern.
18:58:39 <magma_> ivanm, sjanssen, monochrom: thank you!!
18:59:07 <monochrom> IMO ~[n]<-getArgs is not a good idea. no reason to postpone checking.
18:59:26 <BlackM> Okay, no "your mom" jokes for lambdabot - got it. :)
19:00:25 <monochrom> As it happens, Gentle Introduction also has a section on ~pattern.
19:00:30 <dancor> is there a mirror of hackage
19:00:37 <monochrom> No mirror.
19:00:50 <dancor> welcome to clowntown
19:01:05 <BlackM> ...yet! :)
19:01:27 <monochrom> "mirror mirror! what is the best haskell library repo in the whole world?" "that would be hackage, except it has no mirror"
19:02:29 <dancor> "mirror mirror!  ping!   .."
19:02:40 <sjanssen> oh, is hackage down?
19:02:44 <copumpkin> lol
19:02:48 <copumpkin> wait, hackage is down?
19:02:53 <dancor> the system is down
19:02:59 <copumpkin> j/k
19:03:01 * sjanssen must have missed something :)
19:03:10 <sjanssen> but somebody knows, right?
19:03:26 <copumpkin> dons and some guy called paul know
19:03:34 <copumpkin> and apparently they're the ones who need to
19:03:55 <Absolute0> monochrom: i need to rephrase: (iterate f n)[i] = n where number of iterations is less than some number m.
19:04:20 <c_wraith> :t iterate
19:04:20 <lambdabot> forall a. (a -> a) -> a -> [a]
19:04:26 <Absolute0> can I have 2 conditions in dropWhile?
19:04:41 <Absolute0> where one condition checks size of current accumilated list?
19:04:45 <dancor> dropWhile (\ x -> f x && g x)
19:05:03 <Absolute0> dropWhile only filters the next element..
19:05:29 <Absolute0> I mean the lambda function only accepts an element of the list
19:05:51 <Absolute0> can I iterate m times only?
19:06:05 <sjanssen> Absolute0: take m (iterate f x)
19:06:05 <c_wraith> take m $ iterate f n
19:06:16 <Absolute0> ok thats what i need thanks!
19:06:26 <dancor> > let max = 10; k = 7 in listToMaybe . dropWhile (/= k) . take max $ iterate succ 1
19:06:27 <lambdabot>   Just 7
19:06:31 <dancor> > let max = 10; k = 17 in listToMaybe . dropWhile (/= k) . take max $ iterate succ 1
19:06:32 <lambdabot>   Nothing
19:06:44 <Absolute0> listToMaybe is builtin?
19:06:50 <monochrom> (iterate f n)[i] = n is a strange requirement because it is easily satisfied by picking i=0.
19:07:05 <c_wraith> @hoogle listToMaybe
19:07:06 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
19:07:11 <Absolute0> monochrom: I need the smallest i, just wrote that as an illustration.
19:07:14 <c_wraith> You have to import it, but it's in base
19:09:00 <Absolute0> dancor: listToMaybe = dropWhile not Maybe?
19:09:07 <Absolute0> i mean takeWhile
19:09:21 <dancor> hm?
19:09:26 <dancor> :t listToMaybe
19:09:27 <lambdabot> forall a. [a] -> Maybe a
19:09:33 <dancor> @src listToMaybe
19:09:34 <lambdabot> listToMaybe []        =  Nothing
19:09:34 <lambdabot> listToMaybe (a:_)     =  Just a
19:10:09 <Absolute0> I don't compute that. :)
19:10:23 <Absolute0> s/don't/can't/
19:10:37 <Absolute0> it's not recursive?
19:10:40 <Absolute0> wtf?
19:11:00 <dancor> can you compute this:
19:11:09 <dancor> > let max = 10; k = 7 in dropWhile (/= k) . take max $ iterate succ 1
19:11:10 <lambdabot>   [7,8,9,10]
19:11:10 <Absolute0> that returns first element or nothing
19:11:10 <copumpkin> why would it be recursive?
19:11:15 <copumpkin> yep
19:11:48 <Absolute0> oh ok, it is simply casting a list to a type (sort of)
19:12:19 <dancor> heh sure
19:13:10 <dmwit> s/type/Maybe/
19:13:19 <Absolute0> yup :)
19:13:23 <Absolute0> was about to do that myself.
19:13:37 <Absolute0> you dmwit!
19:16:35 <Absolute0> @src succ
19:16:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:17:14 <Absolute0> Is there a builtin avg function?
19:17:15 <dancor> Absolute0: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:succ
19:17:20 <copumpkin> Absolute0: nope
19:17:31 <Absolute0> that seems odd.
19:17:39 <Absolute0> there's a sum
19:17:43 <Absolute0> and length
19:17:52 <copumpkin> you could do liftA2 (/) sum genericLength
19:18:07 <copumpkin> but that's not as efficient as it could be
19:18:17 <Absolute0> this works: avg xs = sum xs / genericLength xs
19:18:34 <Absolute0> got that from 'learn you a great haskell'
19:18:46 <Absolute0> :t liftA2
19:18:48 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:19:24 <dancor> copumpkin: can you use liftA2 with normal length?
19:19:33 <copumpkin> sure, but you can't divide it
19:19:52 <copumpkin> Absolute0: that's what I wrote! ;)
19:20:05 <dancor> > let avg = liftA2 (/) sum (fromIntegral . length) in avg [4, 5]
19:20:06 <lambdabot>   4.5
19:20:26 <copumpkin> @src genericLength
19:20:26 <lambdabot> genericLength []    = 0
19:20:26 <lambdabot> genericLength (_:l) = 1 + genericLength l
19:20:36 <dancor> copumpkin: so genericLength is actually slower than fromIntegral . length?
19:20:36 <Absolute0> copumpkin: you wrote that guide?
19:20:41 <copumpkin> Absolute0: nope
19:20:52 <Absolute0> you wrote that part?
19:20:54 <porrifolius> Hi folks.  Anyone know how to use the haskell curl bindings to get the response of a multipart/form-data POST?
19:20:55 <copumpkin> dancor: yes, but fromIntegral . length will be wrong for sufficiently large lists
19:21:00 <dancor> ya
19:21:06 <dmwit> > let (<) = flip liftA2; (>) = ($); f = sum <(/)> genericLength in f [1..10]
19:21:06 <lambdabot>   5.5
19:21:17 <dmwit> ooooh yes
19:21:35 <porrifolius> curlMultiPost looks like the only way to do a multipart and it's result is an IO ()
19:26:12 <dmwit> porrifolius: I haven't used Haskell's curl package myself, but from that type, I would expect to be able to set some handlers before calling that.
19:40:16 <porrifolius> dmwit: looks like it... curlMultiPost takes [CurlOption], one of which is CurlWriteFunction WriteFunction, WriteFunction is type synonym for Ptr CChar ->... ->... Pretty grim interface :( I think I'll dig into the code and see how the other convenience wrappers are done. Thanks.
19:41:48 <Absolute0> How do I assign a tail of a list to a name?
19:42:09 <dmwit> (_:name) = list
19:42:28 <Absolute0> So I would have to do that in a where clause?
19:42:41 <dmwit> Yes, or a case or a let.
19:42:42 <Absolute0> f1 $ tail list
19:42:53 <Absolute0> no such thing?
19:42:58 <dmwit> That's fine, too.
19:43:02 <Absolute0> :-P
19:43:12 <Absolute0> pfft
19:43:22 <dmwit> But it doesn't fulfill your demand of assigning a name.
19:43:49 <Absolute0> Right, didn't phrase that properly.
19:44:09 <dmwit> drop 1 is generally safer than tail.
19:44:10 <Absolute0> x = tail list
19:44:21 <Absolute0> whats the difference?
19:44:26 <dmwit> > tail []
19:44:27 <lambdabot>   * Exception: Prelude.tail: empty list
19:44:31 <dmwit> > drop 1 []
19:44:31 <lambdabot>   []
19:44:32 <Absolute0> aye caramba
19:44:33 <Absolute0> :)
19:47:04 <ddarius> dmwit: drop 1 is not an adequate replacement for tail.
19:47:11 <ddarius> Usually
19:47:44 <dmwit> no indeed
19:47:51 <ivanm> ddarius: in what way?
19:48:04 <Absolute0> well an exception is good..
19:48:19 <Absolute0> no tail in the input causes an exception state to occur.
19:48:24 <Absolute0> take 1 is more general
19:48:31 <ivanm> Absolute0: which was my point
19:48:42 <ivanm> if you _know_ that the list is non-empty, then you can use tail; but depending on the situation, then drop 1 might suffice
19:48:59 <dmwit> drop 1 and tail are different functions, applicable in different situations
19:49:00 <ddarius> ivanm: Being passed an empty list usually means something different than being passed a singleton.
19:49:03 <dmwit> No need to start a war or anything.
19:49:14 <ivanm> dmwit: heh
19:49:23 <monochrom> I use negate to replace abs.
19:49:38 <ivanm> monochrom: ...
19:49:59 <aavogt> > signum 0
19:50:00 <lambdabot>   0
19:50:02 <copumpkin> :t max <*> negate
19:50:03 <lambdabot> forall a. (Ord a, Num a) => a -> a
19:50:11 <porrifolius> Hmmm, I would download the curl bindings but I can't get to hackage.haskell.org.  Anyone else having trouble?
19:50:21 <ivanm> porrifolius: everyone
19:50:23 <monochrom> copumpkin understands me. :)
19:50:52 <copumpkin> :)
19:51:09 <aavogt> looks like an unnecessary Ord constraint
19:51:14 <copumpkin> nuh uh
19:51:21 <Absolute0> copumpkin: do you give out free pumpkins on holloween? :)
19:51:36 <copumpkin> Absolute0: do give out free family members on other holidays?
19:51:41 <monochrom> I think copumpkin takes in free pumpkins.
19:51:49 <blackh> porrifolius: I can give you a copy of the curl package if you get desperate.
19:52:16 <aavogt> copumpkin: you don't?
19:52:17 <Absolute0> Is Int a bad type to use consistantly in type signatures?
19:52:18 <porrifolius> ivanm: Ah. Anyone know if the curl bindings can be downloaded from elsewhere? Or if cabal caches the downloaded packages?
19:52:29 <monochrom> Int is a good type.
19:52:30 <copumpkin> Absolute0: yeah, but it doesn't stop it from being used a lot
19:52:36 <Absolute0> All my input tupes for my child examples are Int's :(
19:52:36 <ivanm> porrifolius: if you use cabal-install, it might be in ~/.cabal/ somewhere...
19:52:38 * copumpkin is an anti-Inter
19:52:55 <copumpkin> Inter being the soccer/football team
19:53:14 <monochrom> Is soccer better than football?
19:53:14 <Absolute0> When I look at other code I see all these fancy Ord and Eq, etc, I get very jealous :(
19:53:21 <gwern> @flush
19:53:38 <gwern> no one will ever know what I removed :)
19:53:46 <ivanm> does @flush record sjanssen's Int definition for @djinn as well?
19:53:49 <ivanm> gwern: :o
19:53:51 <gwern> BWA HA HA HA
19:53:52 <ivanm> @slap gwern
19:53:52 * lambdabot pushes gwern from his chair
19:54:08 <idnar> pfft, as if gwern were seated on a chair to begin with
19:54:16 <ivanm> hmmmm.... how did lambdabot know gwern was male? :o
19:54:27 <aavogt> how do you know?
19:54:37 <monochrom> Indeed, gwern was standing on a chair to begin with. All the more nasty.
19:54:41 <ivanm> aavogt: the name sounds male-ish? ;-)
19:54:50 <copumpkin> I wouldn't have a clue actually
19:54:53 <ivanm> monochrom: on a chair on the top of a high platform?
19:55:01 <monochrom> @slap Margaret
19:55:02 <lambdabot> I won't; I want to go get some cookies instead.
19:55:07 <ivanm> heh
19:55:11 <ivanm> @botsnack
19:55:11 <lunabot>  :o
19:55:11 <lambdabot> :)
19:55:15 <ivanm> here, have a cookie!
19:55:17 <aavogt> @slap jenny
19:55:17 <gwern> ivanm: you think gwern sounds maleish?
19:55:18 * lambdabot slaps jenny
19:55:25 <gwern> strange, usually everyone thinks female
19:55:28 <Absolute0> I gotta go, thanks for the help!
19:55:28 <gwern> because of 'gwen'
19:55:38 <copumpkin> that extra R is so masculine
19:55:39 <copumpkin> and virile
19:55:45 <chrisf> gwern: don't be silly, there's no girls on the internet!
19:55:56 <gwern> copumpkin: arrgh.
19:56:05 <chrisf> c_c
19:56:12 <gwern> chrisf: well, the fbi agents have to call themselves *something*
19:56:12 <copumpkin> >_>
19:56:35 <aavogt> @slap woman
19:56:36 <lambdabot> stop telling me what to do
19:56:52 <chrisf> lol what?
19:57:28 <ivanm> gwern: yes, but I'm of wog-ish origin! ;-)
19:57:46 <idnar> gwern doesn't sound anything like gwen though
19:57:51 <gwern> ivanm: can I collect you?
19:57:55 <ivanm> :o
19:57:57 <gwern> I used to collect wogs
19:58:03 <ivanm> gwern: golliwog =/= wog
19:58:10 <idnar> but, who knows
19:58:14 <ivanm> (at least down under)
19:58:22 <gwern> oh, sorry, I meant *pog*
19:58:23 <ivanm> gwern:
19:58:24 <ivanm> http://en.wikipedia.org/wiki/Wog#As_an_ethnic_reference_in_Australian_Englisht
19:58:27 <gwern> I used to collect *pogs*
19:58:33 * copumpkin had pogs too
19:58:33 <ivanm> gah, just http://en.wikipedia.org/wiki/Wog#As_an_ethnic_reference_in_Australian_English
19:58:46 <ivanm> gwern: that definition isn't quite right...
19:58:46 <copumpkin> Middle Eastern and eastern or southern European origin.
19:58:47 <porrifolius> blackh: yeah that'd be great if you could send me through the curl package... looks like cabal has cached some packages tgzs but not that one.
19:58:49 <ivanm> but it's close
19:58:52 <copumpkin> that's quite a collection of people to merge
19:58:57 <monochrom> Englisht haha
19:59:16 <ivanm> monochrom: yeah, I mis-typed
19:59:18 <blackdog> copumpkin: you europeans all look the same to us :P
19:59:27 <copumpkin> blackdog: guess so :)
19:59:29 <ivanm> blackdog: he's a yank
19:59:32 <copumpkin> no I'm not
19:59:34 <ivanm> :o
19:59:45 <ivanm> isn't comcast in the USA?
19:59:45 <copumpkin> well, on paper I may be
19:59:54 <copumpkin> ivanm: people can move :P
19:59:58 <blackdog> see, he denies it. any true yankee would burst into flames rather than deny his heritage.
20:00:05 <ivanm> copumpkin: ssshhhH! ;-)
20:00:08 <ivanm> blackdog: heh, true
20:00:21 <ivanm> blackdog: so, he won't care if we call him a seppo? ;-)
20:00:25 * copumpkin isn't really from anywhere
20:00:26 <blackh> porrifolius: http://upcycle.it/~blackh/hackage/  Tell me if you need anything else. :)
20:00:40 <blackdog> copumpkin: not even the internet?
20:00:48 <copumpkin> blackdog: nope!
20:00:51 <copumpkin> I'm originless
20:01:15 * blackdog is realising that lua coroutines are not the cure to all ills. bugger.
20:01:20 <ivanm> copumpkin: so your axes don't meet? :p
20:01:20 * blackh 's hackage mirror is open for business!
20:01:34 <copumpkin> ivanm: my axes will meat your head soon!
20:01:35 <aavogt> pumpkins are supposed to have originated in North America
20:01:37 <ivanm> quick! everyone! DDOS blackh's mirror as well! ;-)
20:01:48 <ivanm> copumpkin: s/meat/meet/ ;-)
20:01:48 <copumpkin> aavogt: that may be the case for me too :P
20:01:55 <copumpkin> ivanm: it was intentional :P
20:01:59 <ivanm> oh
20:02:12 <ivanm> blackh: awwww, there's only one tarball there! :(
20:02:24 <blackdog> copumpkin: i've always wondered - is it "copumpkin" as in "coinductive"?
20:02:30 <ivanm> yeah
20:02:34 <ivanm> he thinks he's witty
20:02:34 <blackh> ivanm: Rome wasn't built in a day, you know!
20:02:35 <monochrom> Yes it's the same co
20:02:38 <ivanm> blackh: heh
20:02:43 <gwern> blackdog: coroutines are a poor man's laziness
20:02:44 <blackdog> not a policeman with half a munchkin, then. aw.
20:02:44 <copumpkin> :(
20:02:53 <ivanm> blackdog: heh
20:03:16 <monochrom> ghc is built in a day. half if you have dual core.
20:03:20 <blackdog> gwern: yeah. they don't buy me much here - need to hold a socket open waiting to signal an external event
20:03:32 <ivanm> monochrom: 40 min here...
20:03:37 <porrifolius> blackh: Are you just teasing me?! :) 403 on the file, directory is alright though.
20:03:43 <monochrom> yeah I'm matching a meme
20:03:49 <ivanm> even on my old first-gen centrino laptop it only took about 1.5-2hrs
20:03:54 <ivanm> monochrom: oh
20:04:03 <ivanm> monochrom: you should be more obvious then ;-)
20:04:06 <monochrom> haskell platform is built in a day. half if you have dual core.  maybe this one works better.
20:04:08 <gwern> monochrom: fail - the expression is 'wasn't' built in a day
20:04:11 <blackh> porrifolius: Fixed.
20:04:13 <ivanm> monochrom: yeah
20:04:49 <porrifolius> blackh: Thanks matey.
20:05:00 <blackdog> gwern: that's why GHC is better than Rome!
20:05:05 <monochrom> ghc isn't built in a day. just download a binary.
20:05:34 <copumpkin> nothing is better than rome!
20:05:39 <copumpkin> roma caput mundi
20:06:35 <gwern> when a man is tired of rome, he is tired of life?
20:06:38 <monochrom> roma catapult mudi --- rome is catapulted into mud
20:08:22 <blackdog> hm, so in haskell-blah they're talking about haskell, and here we're talking about Rome... we're both off-topic :/
20:08:26 <monochrom> Deutschland Ã¼ber alles
20:08:31 <copumpkin> lol
20:09:07 <monochrom> No one is talking in #haskell-blah, don't bluff me.
20:09:08 <gwern> rule indiana!
20:09:21 <copumpkin> well in the category of cities and the ordering of awesomeness relation as morphisms, rome is the terminal object
20:09:36 <ivanm> blackdog: bah
20:09:49 <copumpkin> <= awesomeness, that is
20:10:31 <gwern> copumpkin: you are dismissing london, new york city, and tokyo-yokohama?
20:10:39 <gwern> worse than rome?
20:10:43 <gwern> I THINK NOT
20:10:50 <copumpkin> hmm
20:10:56 <copumpkin> they're awesome in different ways
20:11:02 <monochrom> terminal object is like ()
20:11:05 <gwern> the pussy's answer!
20:11:11 <copumpkin> meow
20:11:15 <copumpkin> monochrom: ?
20:11:47 <monochrom> () is terminal object.  f :: a->()
20:11:52 <ivanm> heh
20:12:00 <copumpkin> well yeah, but I was talking about a different category
20:12:01 <ivanm> monochrom: no, () is the terminal type/value!
20:12:07 <ivanm> Haskell doesn't use objects!
20:12:07 <ivanm> ;-)
20:12:22 <Cale> ivanm: Types are objects in the sense that he means it
20:12:28 * monochrom collapses
20:12:32 <ivanm> monochrom: :o
20:12:39 <Cale> (which have nothing to do with OO objects)
20:12:39 <ivanm> Cale: whatever :p
20:12:43 <gwern> ivanm: we have closures, but closures are a poor man's object
20:12:46 <seanmcl> I'm having trouble understanding this type:  (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
20:12:56 <monochrom> ivanm's "object" is a pun. I like it. :)
20:13:01 <Cale> Though, there are actually two maps a -> () which is slightly unfortunate...
20:13:13 <copumpkin> seanmcl: rewrite it with the Arrow a infix, it might be clearer
20:13:13 <ivanm> monochrom: is it? :o
20:13:19 <seanmcl> seems like the function is going in the wrong direction
20:13:27 * ivanm is obviously wittier than he thinks he is...
20:13:30 <monochrom> Cale may be a teach-bot.
20:13:44 <ivanm> monochrom: it took you _this long_ to figure that out?
20:13:46 <ddarius> gwern: And objects are a poor man's closure.
20:13:51 <copumpkin> seanmcl: not really, although I can see what you mean
20:13:56 <gwern> ddarius: surely not
20:14:06 <monochrom> better than taking infinite time!
20:14:28 <copumpkin> seanmcl: if you translate that to ~> notation, you have (c ~> d) -> (b -> c) -> (b ~> d)
20:14:52 <seanmcl> copumpkin: oh, that makes it more clear.
20:15:06 <seanmcl> does ghc accept this notation?
20:15:16 <copumpkin> :t (<<^)
20:15:18 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> (b -> c) -> a b d
20:15:21 <chrisf> that thing composes a normal function onto the front of an arrow?
20:15:25 <chrisf> (informally)
20:15:29 <copumpkin> :t (<<^) :: (Arrow (~>)) => (c ~> d) -> (b -> c) -> (b ~> d)
20:15:30 <lambdabot> forall (~> :: * -> * -> *) c d b. (Arrow (~>)) => (~>) c d -> (b -> c) -> (~>) b d
20:15:32 <copumpkin> :)
20:16:45 <monochrom> closure is poor man's object. object is poor man's closure. this makes poor man's galois-connected with itself, or you can say self-adjoint. closure is poor man's poor man's closure. this makes poor man's poor man's a closure operator.
20:20:11 <ivanm> monochrom: owwww!!
20:20:46 <monochrom> amirite?
20:21:05 <ivanm> monochrom: since I couldn't follow your argument, I don't know ;-)
20:21:09 <monochrom> haha
20:24:54 <copumpkin> fucking netsplits...
20:25:11 <absentia> net.splits
20:25:26 <copumpkin> did my question get lost?
20:25:29 <ivanm> copumpkin: yes
20:25:37 <ivanm> and it should stay that way! :p
20:25:52 <copumpkin> :(
20:29:33 <ivanm> copumpkin: *sigh* what was your question?
20:30:04 <copumpkin> I saw a mention of the category of graphs on wikipedia but no more info, and was wondering if graphs were the objects and subgraphness was the morphisms
20:30:23 <monochrom> vertex object, edge morphism
20:30:51 <SamB_XP> so really, it's a family of categories
20:30:56 <monochrom> but I guess your one works too as a different category
20:31:18 <copumpkin> well it seemed that what I was talking about is just a special case of the poset idea
20:31:34 <monochrom> If poset idea, vertex and edge.
20:31:40 <SamB_XP> copumpkin: if it's a DAG
20:32:15 <SamB_XP> oh, wait, we have now a DAG with graphs as nodes ;-P
20:32:26 <copumpkin> that's what I thought the category of graphs was
20:32:30 <copumpkin> I mean, every category is a graph
20:33:09 <SamB_XP> what monochrom said sounds more like the category of *a graph*
20:34:13 <monochrom> if object is graph, morphism is not exactly subgraphness; there is graph homomorphism for it.
20:36:01 <SamB_XP> monochrom: aren't you allowed many categories with the same objects ?
20:36:37 <copumpkin> so both of them work, but the canonical "Category of Graphs" is the homomorphisms one and not the subgraph one?
20:39:16 <ddarius> SamB_XP: Sure.
20:39:24 <ddarius> copumpkin: Yes.
20:39:31 <Cale> Yeah, a homomorphism G -> H where G and H are graphs if f(x) and f(y) are adjacent in H whenever x and y are adjacent in G.
20:39:46 <Cale> er, that got mangled
20:40:11 <Cale> A function G -> H is a homomorphism if ...
20:40:38 <ddarius> copumpkin: The category of graphs (and graph homomorphisms) forms a topos by the way.
20:40:51 <copumpkin> I've heard that word before, and know its plural :P
20:40:57 <copumpkin> that's the most I can say about it though
20:41:47 <copumpkin> "In mathematics, a topos (plural "topoi" or "toposes") is a type of category that behaves like the category of sheaves of sets on a topological space. "
20:41:51 <copumpkin> nope, doesn't help :P
20:42:30 <Cale> I think the formal definition is clearer.
20:42:33 <ddarius> copumpkin: A topos is a category where you can do (intuitionistic) set theory in it.
20:42:50 <monochrom> As usual, "like" is obfuscating.
20:43:49 <copumpkin> my lack of topology knowledge may be hindering my understanding of this
20:44:18 <ddarius> You don't need topology (though it wouldn't hurt).
20:45:17 <gwern> @quote endofunctor
20:45:17 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
20:45:29 <copumpkin> hmm
20:45:32 <Cale> A topos is a category with all finite limits and colimits, with exponential objects (and so is Cartesian closed), and additionally has something called a subobject classifier.
20:46:17 <ddarius> The subobject classifier of the category of graphs is pretty good example.  It's covered in Barr and Well's lecture notes pretty well.
20:46:53 <Cale> A subobject classifier is something which takes the role of Bool or 2 in the category of sets, in that there is a correspondence between arrows X -> 2 and subobjects of X
20:47:03 <copumpkin> ah
20:47:32 <copumpkin> alright, I guess I understand all the bits that make up its definition then :P
20:48:25 <copumpkin> ddarius: do you have a link for that? can't find anything obvious from those names alone
20:48:46 <Cale> That is, there is a morphism t: 1 -> 2 such that for any monomorphism U -> X there is a unique morphism X -> 2 such that the square with U -> 1 -> 2, U -> X -> 2 is a pullback diagram.
20:49:04 <ddarius> @google Barr Wells ESSLLI
20:49:06 <lambdabot> http://www.let.uu.nl/esslli/Courses/barr-wells.html
20:49:07 <lambdabot> Title: Courses: Barr / Wells
20:49:33 <copumpkin> ah
20:49:36 <copumpkin> thanks
20:49:51 <mmorrow> copumpkin: this is the def of sheaf http://upload.wikimedia.org/math/6/d/4/6d4a3642e4594f6989e85141f9252ed4.png
20:50:07 <copumpkin> mmorrow: lol, thanks
20:50:10 <monochrom> topos gives me the impression that someone was trying to do set theory but wasn't admitting it.
20:50:12 <mmorrow> it's a contravariant functor s.t. some conditions
20:50:46 <SamB_XP> monochrom: why the "and wasn't admitting it" part ?
20:51:00 <copumpkin> (keep in mind that the highest math I've taken is an honors linear algebra course :P)
20:51:10 <ddarius> copumpkin: Hmm, the Graph example might be in TTT.
20:51:26 <SamB_XP> paragraph 1.11 seems to be pretty explicit about that ...
20:53:39 <copumpkin> TTT?
20:53:44 <copumpkin> is that a new Audi?
20:54:33 <copumpkin> Toposes, Triples and Theories ?
20:54:37 <copumpkin> I see
20:54:51 <monochrom> haha new Audi
21:01:47 <ddarius> copumpkin: That's a higher math course than me.
21:02:05 <copumpkin> ddarius: I know :) but somehow you've probably spent more time thinking about pure math than I have
21:02:08 <copumpkin> or maybe were just born with it
21:02:21 <luite> is highness of math courses a linear order? :p
21:02:22 <copumpkin> but up until a few months ago, I had no idea any of this existed :P
21:02:27 <copumpkin> luite: certainly!
21:02:46 <SamB_XP> luite: of course not -- it's a partial order!
21:04:27 <sshc> it's logarithmic
21:06:02 <SamB_XP> sshc: that doesn't do much to the order of things ...
21:06:19 <SamB_XP> ... except it means you can't have things <= 0 ...
21:12:03 <amz> how do I pattern match a fraction?
21:12:16 <amz> "f (a % b)" seems to give me an error
21:12:24 <amz> [Data.Ratio is imported]
21:12:42 <copumpkin> :%
21:13:14 <dmwit> haha, "Programming is the process of adding bugs to an empty file."
21:13:17 <amz> ?
21:13:32 <dmwit> http://www.reddit.com/r/programming/comments/9v9wi/sunday_is_the_day_of_the_week_i_get_to_do_some/
21:13:39 <dmwit> A load of great quotes.
21:13:54 <dmwit> I especially liked this thread: http://www.reddit.com/r/programming/comments/9v9wi/sunday_is_the_day_of_the_week_i_get_to_do_some/c0elzqs
21:15:15 <codm`> Hey, is there any way to have a data type in which some fields have names, and others done?
21:15:19 <copumpkin> dons: you around?
21:15:33 <dmwit> codm`: Not within the same constructor, no.
21:15:44 <codm`> dmwit: Okay, thanks.
21:15:50 <dmwit> codm`: However, you can make a constructor with totally unnamed fields and write the selector/update functions yourself.
21:15:54 <copumpkin> amz: I guess you can't, cause it doesn't look like the Ratio constructor is exported
21:16:03 <amz> I see
21:16:14 <codm`> dmwit: Yeah, that's what I've been doing.
21:16:18 <amz> so I guess I'll just match the whole thing and extract num/denom
21:16:33 <luite> is there something like graphviz that can draw hypergraphs?
21:17:24 <SamB_XP> luite: you mean, with edges connected by hyperedges or something ?
21:17:42 <luite> SamB_XP: just vertices connected by hyperedges
21:17:56 <luite> where a hyperedge is a subset of V
21:18:00 <SamB_XP> luite: that doesn't make any sense
21:18:06 <SamB_XP> what makes an edge hyper ?
21:18:11 <Elbow> Anyone here know VB.net?
21:18:25 <copumpkin> Elbow: maybe, but we try to suppress the memories
21:18:30 <SamB_XP> Elbow: are you looking for Erik Meijer ?
21:18:42 <dmwit> SamB_XP: It can connect more than two vertices.
21:18:43 <luite> SamB_XP: that the edge can be incident to any number of vertices
21:18:46 <Gracenotes> it somewhat annoys me that there is no function Integral a => Ratio a -> (a, a)
21:18:47 <dmwit> SamB_XP: (r fewer)
21:18:48 <Elbow> I'm not looking for anyone in particular, just need help
21:18:58 <ddarius> copumpkin: Okay, it is in the ESSLLI lecture notes, example 11.3.3.
21:19:01 <copumpkin> Gracenotes: make it
21:19:12 <Gracenotes> (numerator *** denominator) just ain't the same
21:19:23 <copumpkin> Gracenotes: I mean as a patch to libraries@
21:19:33 <Gracenotes> hm... that would be &&& actually
21:19:43 <SamB_XP> Elbow: I just figured maybe you would be because his is a big name in Haskell, but he's currently working on the design of VB and C# afaik ...
21:19:47 <copumpkin> ddarius: thanks!
21:20:01 <copumpkin> Elbow: this is a channel about haskell, not about "programming" :)
21:20:09 <copumpkin> Elbow: we'll be happy to sell you our product though ;)
21:20:23 <Elbow> I don't even know what Haskell is...never heard of it?
21:20:24 <luite> SamB_XP: wikipedia has an example: http://en.wikipedia.org/wiki/Hypergraph, I'm looking for a simple way to make such images with a haskell program
21:20:27 <SmurfOR> haha
21:20:30 <SamB_XP> copumpkin: ... just as soon as Hackage comes up again!
21:20:32 <Elbow> Would anyone be willing to help me though?
21:20:39 <Elbow> It's probably cake for most of you
21:21:05 <dmwit> more like mud pie
21:21:10 <dmwit> Still easy to make, but not as fun to eat at the end.
21:23:20 <SamB_XP> I don't know why you guys like to badmouth it so much -- if Erik Meijer helped design it it can't be *that* bad!
21:23:28 <copumpkin> Elbow: have you tried #vb.net
21:23:33 <ivanm> @hoogle Int -> [a] -> [[a]]
21:23:34 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
21:23:34 <lambdabot> Prelude drop :: Int -> [a] -> [a]
21:23:34 <lambdabot> Prelude take :: Int -> [a] -> [a]
21:23:37 <ivanm> bah
21:23:42 <chrisf> c# is awesome. vb.net is utter garbage ;)
21:23:48 <ivanm> is there no splitting function?
21:24:02 <SamB_XP> chrisf: ... I heard they were virtually identical ...
21:24:15 <Axman6> ivanm: Data.List.Split
21:24:17 <chrisf> except they're not.
21:24:17 <SamB_XP> :t splitAt
21:24:18 <lambdabot> forall a. Int -> [a] -> ([a], [a])
21:24:37 <SamB_XP> chrisf: how do they differ, besides syntactically ?
21:24:38 <ivanm> Axman6: OK, I'll go install it... oh wait, hackage is down! :s
21:24:42 <chrisf> SamB_XP: VB lacks generator expressions, and is approx 5x more verbose.
21:24:45 <Axman6> :(
21:24:58 <SamB_XP> chrisf: *5* ?
21:25:05 <chrisf> ivanm: i'm *sure* you can write split yourself.
21:25:09 <SamB_XP> I thought it was more like 1.5x -- 2x
21:25:09 <ivanm> SamB_XP: yeah, I could do repetitions of that (though I actually want to split based upon the mod of the position... but that would work with a transpose)
21:25:11 <Axman6> > unfoldl (\xs -> if null xs then Nothing else Just (split 10 xs)) [1..]
21:25:12 <lambdabot>   Not in scope: `unfoldl'
21:25:19 <Axman6> > unfoldr (\xs -> if null xs then Nothing else Just (split 10 xs)) [1..]
21:25:20 <lambdabot>   Couldn't match expected type `[a] -> (a1, [a])'
21:25:20 <lambdabot>         against inferred ty...
21:25:22 <ivanm> chrisf: but I'm getting sick of re-writing it each time I want/need it!
21:25:33 <Axman6> :t unfoldr
21:25:34 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:25:40 <chrisf> give a VB.NET programmer and ME the same task. i can guarantee their code will be at least 5x the size.
21:25:49 <SamB_XP> ivanm: just make a note to get resick later when hackage ain't down
21:25:51 <Axman6> :t split 10
21:25:52 <ivanm> chrisf: in what language?
21:25:52 <lambdabot> forall t. (Num t, RandomGen t) => (t, t)
21:25:55 <chrisf> c#.
21:26:03 <ivanm> SamB_XP: heh
21:26:04 <chrisf> and they wont have a clue what i did
21:26:05 <copumpkin> @tell dons I have some time now to work on uvector and the GHC 6.12 RC has fixed the newtype deriving bug, so I'll probably work on making sure every function is safe and the Binary serialization stuff. One thing I'd like to do too is nested UArrs using the DPH-style technique for it. Let me know if you have any thoughts
21:26:06 <lambdabot> Consider it noted.
21:26:09 <SamB_XP> chrisf: that doesn't mean that VB.net is inherantly 5x as verbose
21:26:28 <chrisf> it is IDIOMATICALLY 5x as verbose.
21:26:32 <Axman6> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 10 xs)) [1..]
21:26:32 <dancor> ya when ppl don't understand my code, i know i've done a Great Job!
21:26:33 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,...
21:26:35 <chrisf> you CAN play golf in it.
21:26:40 <chrisf> if you really want to.
21:26:58 <copumpkin> Axman6: that can be golfed a lot more, come on!
21:27:16 <Axman6> @pl (\xs -> if null xs then Nothing else Just (splitAt 10 xs))
21:27:16 <lambdabot> ap (flip if' Nothing . null) (Just . splitAt 10)
21:27:35 <Axman6> > unfoldr ((flip if' Nothing . null) (Just . splitAt 10)) [1..
21:27:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:27:40 <copumpkin> if it's on an infinite list you don't even need the null check
21:27:46 <Axman6> > unfoldr (ap (flip if' Nothing . null) (Just . splitAt 10)) [1..
21:27:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:27:53 <Axman6> > unfoldr (ap (flip if' Nothing . null) (Just . splitAt 10)) [1..]
21:27:54 <lambdabot>   Not in scope: `if''
21:27:58 <Axman6> >_<
21:28:09 <copumpkin> you can avoid the if using guard
21:28:16 <SamB_XP> > unfoldr (\xs -> guard (null xs) >> return (splitAt 10 xs)) [1..]
21:28:18 <lambdabot>   []
21:28:21 <SamB_XP> hmm ...
21:28:22 <ivanm> Axman6: yeah, lambdabot uses it but doesn't have it defined...
21:28:23 <copumpkin> not . null
21:28:31 <ivanm> @let if' p t f = if p then t else f
21:28:32 <lambdabot>  Defined.
21:28:36 <SamB_XP> > unfoldr (\xs -> guard (not . null $ xs) >> return (splitAt 10 xs)) [1..]
21:28:38 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,...
21:28:40 <ivanm> Axman6: go for it!
21:28:48 <Axman6> > unfoldr (ap (flip if' Nothing . null) (Just . splitAt 10)) [1..]
21:28:50 <SamB_XP> > unfoldr (\xs -> guard (not . null $ xs) >> return (splitAt 10 xs)) [1..34]
21:28:52 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,...
21:28:54 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,...
21:28:56 <SamB_XP> > unfoldr (\xs -> guard (not . null $ xs) >> return (splitAt 10 xs)) [1..24]
21:28:57 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24]]
21:29:20 <Axman6> :t notNull
21:29:21 <lambdabot> Not in scope: `notNull'
21:29:24 <Axman6> :(
21:29:32 <Axman6> @let notNull = not . null
21:29:33 <lambdabot>  Defined.
21:29:37 <dancor> cheating
21:29:54 <ivanm> heh
21:31:12 <dancor> everyone knows that creating reusable components is cheating when making your code as small and arcane as possible
21:31:15 <copumpkin> > unfoldr (liftA2 (>>) (guard $ not . null) (pure . splitAt 10)) [1..]
21:31:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:31:16 <lambdabot>         against inferred type ...
21:31:19 <copumpkin> meh
21:31:23 <ivanm> > let splitPos n = let splitter [] = Nothing; splitter as = Just $ splitAt n as in transpose . unfoldr splitter in splitPos 2 ['a'..'g']
21:31:24 <lambdabot>   ["aceg","bdf"]
21:31:27 <ivanm> \o/
21:31:43 <vininim> > empty
21:31:44 <lambdabot>   Ambiguous occurrence `empty'
21:31:45 <lambdabot>  It could refer to either `Control.Applicative...
21:31:54 <vininim> @type empty
21:31:55 <lambdabot>     Ambiguous occurrence `empty'
21:31:56 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
21:31:56 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:57:0-22
21:32:03 <vininim> @type Control.Applicative.empty
21:32:05 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
21:32:38 <vininim> gee, I can't read that
21:34:25 <vininim> @src Control.Applicative.empty
21:34:26 <lambdabot> Source not found. My brain just exploded
21:34:37 <copumpkin> it's a method
21:35:30 <ivanm> wtf? ghci keeps specialising the type of a function I'm defining using let! :@
21:35:55 <ivanm> @type map (\as -> (head as, length as)) . group . sort
21:35:56 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
21:36:34 <ivanm> even if I give it an explicit type sig, it keeps saying that the type of the function is [()] -> [((),Int)] :@
21:37:08 <copumpkin> ivanm: damn MR
21:37:09 <ivanm> ahhh, appears to be a MR problem or something
21:37:15 <ivanm> copumpkin: yeah, just figured that out :@
21:39:18 <ivanm> Bynbo7: *sigh* I thought you'd forgotten/given up on that stupid nick...
21:39:40 <copumpkin> it was just an alternate nick
21:41:35 <dmwit> Oh, I get it.
21:41:38 <dmwit> > map succ "Axman6"
21:41:39 <lambdabot>   "Bynbo7"
21:41:57 <ivanm> dmwit: _please_ don't remind everyone about that...
21:42:56 <copumpkin> > map (succ &&& pred) "ivanm" -- ;)
21:42:57 <lambdabot>   [('j','h'),('w','u'),('b','`'),('o','m'),('n','l')]
21:43:00 <copumpkin> damn
21:43:08 <copumpkin> > (map succ &&& map pred) "ivanm" -- ;)
21:43:10 <lambdabot>   ("jwbon","hu`ml")
21:43:18 <ivanm> @slap copumpkin
21:43:18 * lambdabot pushes copumpkin from his chair
21:43:19 <dmwit> > unzip . map (succ &&& pred) $ "ivanm"
21:43:20 <copumpkin> > unzip $ map (succ &&& pred) "ivanm" -- ;)
21:43:20 <lambdabot>   ("jwbon","hu`ml")
21:43:21 <lambdabot>   ("jwbon","hu`ml")
21:43:23 <copumpkin> :)
21:43:38 <juhp> is hackage down?
21:43:42 <aavogt> yes
21:43:43 <dmwit> juhp: yes
21:43:44 <copumpkin> lol
21:43:49 <juhp> ok...
21:43:53 <juhp> thanks!
21:43:57 <copumpkin> that should be a quote of the week on HWN
21:44:11 <dmwit> What, "yes"?
21:44:21 <juhp> is it coming back? :)
21:44:22 <copumpkin> @remember everbody is hackage down?
21:44:23 <lambdabot> It is forever etched in my memory.
21:44:49 <copumpkin> juhp: I would hope so :)
21:45:28 <juhp> so people are working on it presumably or it is a scheduled outage or something?
21:46:26 <dmwit> unscheduled as far as I know
21:47:48 <Axman6> > map (pred *** succ) " Axman6"
21:47:49 <lambdabot>   Couldn't match expected type `(b, b')'
21:47:49 <lambdabot>         against inferred type `GHC.T...
21:47:50 <ivanm> > cycle "Is Hackage down? "
21:47:50 <lambdabot>   "Is Hackage down? Is Hackage down? Is Hackage down? Is Hackage down? Is Hac...
21:48:10 <juhp> might be better to put it in the topic? :)
21:48:13 <copumpkin> > text . cycle $ "ivanm: Is Hackage down? "
21:48:18 <lambdabot>   mueval: ExitFailure 1
21:48:27 <copumpkin> I guess cycle and text don't get along
21:48:32 <Axman6> > text . take 100 . cycle $ "Is hackage down?\n"
21:48:33 <lambdabot>   Is hackage down?
21:48:33 <lambdabot>  Is hackage down?
21:48:33 <lambdabot>  Is hackage down?
21:48:33 <lambdabot>  Is hackage down?
21:48:33 <lambdabot>  Is ...
21:48:39 <Axman6> >_>
21:48:44 <medfly> that's a good thing
21:48:47 <dmwit> > transpose . map (sequence [pred, id, succ]) $ "Axman6"
21:48:48 <lambdabot>   ["@wl`m5","Axman6","Bynbo7"]
21:48:50 <c_wraith> I'm willing to believe that text is strict.
21:48:59 <vininim> wat, lambdabot is escaping \n now?
21:49:03 <vininim> *not escaping
21:49:10 <c_wraith> text doesn't do esccaping
21:49:21 <c_wraith> > text "1\n2"
21:49:23 <lambdabot>   1
21:49:23 <lambdabot>  2
21:49:38 <medfly> I'm tempted to > text . cycle $ ".\n"
21:49:42 <vininim> ^
21:49:50 <vininim> someone probably done it before
21:49:58 <Axman6> > text . cycle $ ".\n"
21:49:59 <c_wraith> won't work, strictly.  text is strict.  you can't give it infinite input
21:50:03 <ivanm> copumpkin: text isn't lazy
21:50:03 <lambdabot>   mueval: ExitFailure 1
21:50:08 <copumpkin> ivanm: I noticed
21:50:13 <medfly> I'm tempted to > text . take 100 . cycle $ ".\n" then!
21:50:14 <Axman6> > text . take 100 . cycle $ ".\n"
21:50:15 <lambdabot>   .
21:50:15 <lambdabot>  .
21:50:15 <lambdabot>  .
21:50:15 <lambdabot>  .
21:50:15 <lambdabot>  .
21:50:17 <lambdabot> [21 @more lines]
21:50:20 <medfly> damn!
21:50:23 <Axman6> heh
21:50:34 <vininim> still floody x_x
21:50:34 <c_wraith> @more
21:50:35 <lambdabot>  .
21:50:35 <lambdabot>  .
21:50:35 <lambdabot>  .
21:50:35 <lambdabot>  .
21:50:35 <lambdabot>  .
21:50:37 <lambdabot> [16 @more lines]
21:50:46 <ivanm> @slap c_wraith
21:50:46 <lambdabot> why on earth would I slap c_wraith?
21:51:44 <medfly> lambdabot is cool
21:54:36 <BMeph> @more
21:54:58 <BMeph> Awww... ;)
21:55:03 <juhp> lambdabot: do you ignore privmsg?
21:55:48 <copumpkin> nope
21:55:59 <copumpkin> but she doesn't listen to :t in private messages
21:58:57 <ivanm> umopepisdn`: please make up your mind what your nick is!
21:59:03 <ivanm> copumpkin: :o
21:59:05 <ivanm> didn't know that...
21:59:10 <ivanm> but @type works just as well
21:59:20 <copumpkin> you have to use @type or ?type
21:59:20 <copumpkin> yeah
21:59:49 <umopepisdn`> HARDER THAN YOU THINK!
22:02:40 <ivanm> OT, but does anyone know a quote-like environment in LaTeX which lets you specify who the quote is attributed to?
22:02:48 <ivanm> google is failing me :(
22:06:36 <dmwit> ?ty 0 -- works too, and is ever so slightly shorter than ?type
22:06:37 <lambdabot> forall t. (Num t) => t
22:06:38 <copumpkin> is proof-carrying code any more sophisticated than just a typed language with a typechecker?
22:06:52 <copumpkin> the berkeley page I found on it made it sound like that
22:07:00 <dmwit> It can be.
22:07:10 <dmwit> The proofs can be available at runtime, so that you can send code across the network.
22:07:22 <dmwit> ...I think.
22:07:56 <Axman6> umopepisdn`: it's really not
22:08:10 <copumpkin> hmm
22:08:45 <defun> Is it proper to say "You can download my source /codes/ for project X" or "You can download my source /code/ for project X"
22:08:54 <copumpkin> code
22:08:56 <Nafai> defun: the latter, I believe
22:09:02 <defun> thanks
22:09:14 <dancor> codes is usually a lol
22:09:47 <aavogt> code sources
22:11:06 <inimino> some1 give me codes for quiksort plz???
22:11:49 <copumpkin> u no can haz kthx
22:11:52 <blackdog> the codes for quicksort are kept on the president's person at all times, for safety.
22:12:01 <defun> lol
22:12:54 <dancor> i have a quick sorting question
22:13:56 <blackdog> i've heard "codes" used for scientific computing, but it always sounds bizarre
22:14:33 <blackdog> also, parenthetically: you bastards are so helpful and prompt and thoughtful that you've ruined me for every other irc channel. THANKS FOR NOTHING, #HASKELL
22:15:21 <ivanm> I always get caught out on wanting to typeset a >= b in LaTex: I keep thinking of it as "a is larger than or equal to b", and hence enter $a \le b$ :s
22:15:28 <Chile> blackdog: 'codes' is a fortran thing, in my experience.
22:16:56 <Berengal> Why's it called "code" anyway? In my opinion, it's quite the opposite
22:17:53 <Chile> Berengal: because it's an encoding of an algorithm into instructions for a computer
22:18:02 <Chile> pre-functional programming, of course :)
22:18:14 <Berengal> Mmmm, I guess
22:18:15 <blackdog> Berengal: i suppose when you're implementing an algorithm in machine language, it does feel like you're encrypting it
22:18:45 <Chile> s/machine language/fortran/
22:18:58 <ivanm> blackdog: methinks you have the wrong meaning of "code"
22:19:07 <blackdog> Chile: heh. i've never actually used Fortran - is it that bad?
22:19:12 <ivanm> Chile is referring to coding theory
22:19:27 <ivanm> blackdog: Fortran 95 and later is quite nice actually
22:19:27 <blackdog> ivanm: sure. they're linked, though.
22:19:30 <ivanm> a bit verbose, but still
22:19:35 <Berengal> I usually find I have to encrypt my algorithms in english when explaining to other people. Writing them in haskell, then, is decoding
22:19:40 <ivanm> blackdog: well, codes in cryptography are word substitutions...
22:20:00 <Chile> the original fortran was proposed as an automatic way to encode instructions for computers... as in, OMG, we don't have to write in asm anymore!
22:20:16 <Chile> hence FORmula TRANslation
22:20:24 <aavogt> MULASLATION
22:20:28 <blackdog> Berengal: that's both true and depressing. unless you handwave mightily, the essence is usually lost
22:20:32 <ivanm> whereas coding theory is to do with compressing and/or adding redundancy to text
22:20:49 <ivanm> Chile: hmmmm..... I suppose...
22:21:03 <ivanm> aavogt: heh
22:21:10 <juhp> asked since I can't get lambdabot to respond to my msg's...
22:21:27 <copumpkin> juhp: are you asking politely?
22:21:33 <Berengal> blackdog, oh, don't worry, I always wave my hands _very hard_ when talking to other people
22:21:35 <ivanm> juhp: what kind of messages are you sending?
22:21:47 <ivanm> juhp: does "/msg lambdabot @quote" work?
22:21:54 <Berengal> I sometimes wave my hands when writing haskell as well, but it tends not to work that well
22:22:01 <ivanm> Berengal: and how many people do you knock out on average? ;-)
22:22:07 <juhp> ivanm: yes!
22:22:19 <copumpkin> juhp: you were probably just giving it a bad command in private :P
22:22:24 <ivanm> agreed
22:22:28 <juhp> seems so
22:22:51 <copumpkin> I'd say RTFM (not really) but there isn't much of a manual
22:22:54 <ivanm> lambdabot: needs "@" prefixed to all plugins, even in privmsg (or optionally "> " for code evaluation)
22:22:58 <juhp> ok at least now it tells me as much
22:23:02 <Berengal> ivanm, most have learned to stay away :(
22:23:06 <inimino> Berengal: the problem is that we don't have input devices that would allow the computer to see you waving your hands
22:23:20 * juhp wishes one didn't need @ for privmsg but anyway
22:23:30 <copumpkin> you can use ? too
22:23:38 <copumpkin> and > for @run
22:23:44 <ivanm> Berengal: heh
22:24:28 <copumpkin> look at my horse, my horse is amazing
22:24:37 <aavogt> @quote problem
22:24:38 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
22:24:38 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
22:24:39 <juhp> would be it over the top to cons "hackage is down"?
22:24:46 <copumpkin> ?
22:24:58 <blackdog> copumpkin: arargarh. that won't be out of my head for days now.
22:25:08 <copumpkin> give it a lick!
22:25:12 <blackdog> mmm!
22:25:29 <juhp> @topic-cons hackage is down
22:25:29 <lambdabot> I do not know the channel hackage
22:25:29 <aavogt> blackdog: it is a good thing that I don't get the reference?
22:25:34 <blackdog> aavogt: yes.
22:25:42 <juhp> @topic-cons #haskell hackage is down
22:25:46 <blackdog> by all means, stay right the hell away from shutupwomangetonmyhorse.com
22:26:12 <juhp> of course - guess i can't...
22:26:57 <copumpkin> you can if you know the secret
22:27:39 <juhp> cool
22:41:38 <brooksbp> Is anyone here studying of has studied separation logic?
22:49:13 <ksf> gragh hackage still down
22:52:29 <dancor> sick sad world
22:52:51 <ksf> @where+ hackage http://web.archive.org/web/20080624112926/http://hackage.haskell.org/
22:52:52 <lambdabot> I will remember.
22:54:53 <ksf> @where- hackage
22:54:54 <lambdabot> Maybe you meant: where where+
22:54:58 <ksf> uhm.
22:55:07 <ksf> archive.org doesn't seem to index subpages
22:56:59 <ksf> don't we have a backup or mirror, _anywhere_?
23:00:05 <ksf> hu. http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
23:00:56 <ksf> ...well it has reverse deps, but no tgzs.
23:07:44 <ksf> does anyone happen to have elerea and elerea-examples tar.gzs flying around in his ~/.cabal?
23:08:37 <c_wraith> heh.  If we're down to trading tarballs...  ksf, do you have EnumMap around? ;)
23:09:09 * ivanm has none of them
23:09:11 <ksf> you see, the thing is: I nuked my ~/.cabal recently.
23:09:16 <c_wraith> ah.  sadness.
23:09:19 <ivanm> we need distributed Hackage!
23:09:37 <c_wraith> quick, let's hack bittorrent into cabal. >_>
23:09:46 <ksf> I can offer gpipe and all its deps, though.
23:10:18 <aavogt> you're going to do that with the bittorrent file parsing library on hackage... oh wait
23:10:33 <ksf> we do have a bt client.
23:11:07 <c_wraith> does it support any of the distributed trackers?  (down with single points of failure!)
23:11:44 <ksf> it's called conjure, and is hosted on darcs.haskell.org, which is the same as hackage (how could it be otherwise?)
23:12:11 <ksf> when it rains, it's pouring.
23:12:16 <akamaus> Hi all. Does anybody know what happened to hackage?
23:12:30 <c_wraith> I don't think there's been any announcement.
23:12:31 <ivanm> akamaus: it died a long, slow, painful death
23:12:39 <ivanm> c_wraith: no official one, no
23:12:50 <c_wraith> do we know anything more than "it's being looked at"?
23:13:12 <akamaus> ivanm, when did it happen? And are there any plans for ressurection?
23:13:16 <c_wraith> This sort of downtime would seem to indicate either hardware issues or data loss.  >_>
23:13:18 <ksf> do we know whether there are any backups?
23:13:29 <SmurfOR> i'd hope so
23:13:30 <ivanm> akamaus: no idea to either
23:13:38 <ksf> there's a mirror of the database though, but without tarballs.
23:13:42 <c_wraith> It went down sometime less than 24 hours ago
23:13:42 <Saizan> we know that the /srv filesystem is down on monk, which is presumably the server :)
23:13:56 <ivanm> ksf: is that mirror up to date though?
23:14:05 <ivanm> ksf: maybe it's the reverse dep patches that stuffed it? :p
23:14:07 <c_wraith> Since I was able to use it until about 4 or 5 this morning (local time)
23:14:56 <ksf> the database isn't worth a thing without the tarballs... not to mention that all that info is in the tarballs, too.
23:15:00 <akamaus> c_wraith, it was down 15 hours ago then I tried.
23:15:35 <c_wraith> Yeah, I noticed it down at 5 this morning, local time.  That was... 17 hours ago.
23:15:44 <Saizan> mh, maybe it's not that the darcs. machine is down too, but that the name servers are down.
23:15:46 <c_wraith> 18
23:15:49 <c_wraith> I suck at math
23:15:57 <c_wraith> > 23 - 5
23:15:58 <lambdabot>   18
23:16:04 <ksf> nah it's the server, both are resolved to monk.galois.com
23:16:13 <akamaus> Saizan, no way, ip is resolved
23:16:23 <ivanm> Saizan: IIRC, darcs and hackage are on the same machine
23:16:26 <Saizan> ah, opendns says otherwise
23:16:35 <akamaus> poor monk..
23:16:36 <ivanm> code.haskell is still up, IIRC haskell proper is still up
23:16:45 <ivanm> ksf: so it's dons' fault? :p
23:17:22 <ksf> we should definitely backup all that stuff to somewhere.
23:17:51 <ksf> heck every other open source repository has a gazillion of mirrors
23:17:56 <Saizan> well, galois should have backups
23:18:11 <Saizan> ah, mirrors are another thing :)
23:18:45 <ivanm> ksf: compare how old and commercially backed other repos might be
23:18:48 <ivanm> to Hackage
23:18:50 <ksf> and torrent-enabled hackage and darcs would rock, too, of course.
23:18:54 <ivanm> how old is Hackage? about 3 years now?
23:19:06 <Saizan> i wonder how much bandwidth it takes to run hackage
23:19:08 <ivanm> ksf: not sure how useful torrent hackage would be, since the files are typically rather small
23:19:26 <ksf> that's not the main point, the main point is distribution.
23:23:16 <dancor> the main point is availability
23:24:51 <c_wraith> well.  if it's a centralized tracker, torrents don't help much with availability
23:27:25 <ksf> there's dht.
23:27:37 <ksf> and opentracker etc. are very, very unlikely to fail.
23:28:44 <ksf> more importantly, you can host a bunch of .torrent files with nearly no capacity.
23:29:16 <ksf> a dsl line should be more than sufficient to take that load.
23:34:02 <SmurfOR> you need a seeder though
23:34:28 <c_wraith> cabal will be split into cabald and cabalc
23:34:38 <ksf> hackage can do http seeding, and then we can get a thousand seeding peers
23:34:40 <c_wraith> everyone who has the package will seed!
23:35:02 <ksf> we can encourage running cabald by providing a http haddock server.
23:35:17 <ksf> ...including hoogle search and such.
23:35:28 <ivanm> c_wraith: that only works for people who use cabal-install rather than system packages
23:35:39 <c_wraith> true.
23:36:03 * ksf doesn't think any developer solely uses systam packages.
23:36:13 <ivanm> ksf: well, I only use cabal-install to test my own packages
23:36:31 <ivanm> (and if I'm working on two or three related ones, the local install reflects the "live" package)
23:37:08 * ksf just located ~/.cabal-old and... it doesn't include elerea.
23:37:14 <ksf> but enummap.
23:37:47 <ksf> c_wraith, is 0.0.2 fine? I've also got gmap-0.1
23:38:12 <c_wraith> yes, 0.0.2 is current
23:38:38 <ksf> I'd recommend gmap, though, it's more generic.
23:38:57 <c_wraith> Eh.  Can you send me both?
23:39:06 <ksf> sure
23:40:01 <ksf> http://rapidshare.com/files/294931249/stuff.tar.gz.html
23:40:48 <ivanm> ugh, I _hate_ rapidshare
23:41:18 <ksf> I'd use ifile.it, but they switched to demanding registration
23:41:22 <ksf> (even if it's free)
23:41:52 * ivanm uses code.haskell for his file distribution :p
23:42:32 <Goldy> if a:[list] puts element a at the start of [list], is there a way to put a at the end of list easily, without having to put a into a list?
23:42:42 <Goldy> all i have so far is [list]++[a]
23:42:47 <ksf> nope.
23:43:02 <Goldy> ok, thanks
23:43:09 <ksf> lists aren't designed towards appending stuff at the end
23:43:20 <ksf> Data.Seq is going to be way faster for that.
23:43:49 <ksf> O(1) cons and snoc and O(log (min m n)) append
23:44:03 <c_wraith> where did the name "snoc" come from?
23:44:08 <ksf> cons
23:44:10 <Goldy> cons backwards?
23:44:22 <c_wraith> oh.  hah.
23:44:23 <ivanm> snoc
23:44:38 <ksf> snoc/deah/liat
23:44:43 <ivanm> oh, wait, you were asking where snoc came from... I just wrote cons backwards from what Goldy said :s
23:44:47 <dancor> @src snoc
23:44:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:44:52 <dancor> :t snoc
23:44:53 <lambdabot> Not in scope: `snoc'
23:45:03 <ksf> it's called "|>"
23:46:02 <dancor> @let snoc l x = l ++ [x]
23:46:03 <lambdabot>  Defined.
23:46:10 <dancor> :t snoc
23:46:11 <lambdabot> forall t. [t] -> t -> [t]
23:46:23 <c_wraith> woo.  O(n) snoc. :)
23:46:43 <dancor> the cult of dO(n)e
23:47:11 <ksf> you call tell that I'm desparate by looking at my terminal and seeing "% find . -iname \*elerea\*"
23:47:39 <dancor> @pl \ l x -> l ++ [x]
23:47:39 <lambdabot> (. return) . (++)
23:47:55 <dancor> why not (. (:[])) . (++)
23:48:19 <dancor> @pl (:[])
23:48:19 <lambdabot> return
23:48:43 <c_wraith> hmm.  @pl doesn't like the monkey face operator
