00:00:16 <mmorrow> dmead: a so called "real" callcc would operate at the level of the rts, so if you did  (callcc (\k -> 2 + k 1) + 3) you'd get 4
00:00:26 <mmorrow> no Cont monad needed
00:00:41 <FunctorSalad> jfredett: with "normal form" (made that up) I mean a product/sum type built up from (+) and (*) etc type constructors
00:00:51 <FunctorSalad> jfredett: actually that's what some generics libraries do
00:00:53 <British0zzy> does anyone use snipmate with vim??
00:01:18 <jfredett> FunctorSalad: right, so I guess then I'm just approximating the generics libraries -- which makes sense.
00:02:22 <FunctorSalad> jfredett: maybe this already does what you had in mind? http://people.cs.uu.nl/andres/Rec/MutualRec.pdf
00:03:04 <FunctorSalad> jfredett: it doesn't calculate whether two types are isomorphic, but it makes these isomorphisms to a type built from standard sum/product combinators
00:03:13 <copumpkin> mmorrow: yeah, but it's nicer (in my opinion) to be able to implement it in the language itself!
00:03:18 <jfredett> FunctorSalad: interesting.
00:03:41 <dmead> mmorrow, where are you passing someting to your lambda there?
00:04:16 <jfredett> This paper is going to have to wait till morning though... It's far to late for literature this heady... :)
00:04:22 <FunctorSalad> jfredett: recursive types complicate the matter though
00:04:35 <FunctorSalad> (and mutually recursive families complicate it more)
00:04:49 <mmorrow> copumpkin: i'm not sure that's possible without having full control of the low-level stuff, like say in C, you'd need the ability to allocate new stacks and switch between them
00:04:58 <jfredett> FunctorSalad: Yah, I hadn't figured out how to deal with those yet, but I figured I might be able to get something interesting for "plain" types.
00:05:06 <copumpkin> mmorrow: I guess :)
00:05:19 <jfredett> at least enough to 'lead' my brain at some later date.
00:05:43 <mmorrow> dmead: i passed the lambda to callcc
00:06:04 <jfredett> FunctorSalad: my habit is to hack some 'bait' code and leave it hanging around for later when I'm appreciably smarter and able to actually tackle the project.
00:06:14 <FunctorSalad> jfredett: (in fact, apparently the main point of the paper is how to deal with mutually recursive types)
00:06:26 <jfredett> FunctorSalad: I gathered from the title. :)
00:06:37 <FunctorSalad> oh right :)
00:06:42 <mmorrow> copumpkin: with a real callcc, you can do cool stuff like implement cooperative multitasking (or even preemptive if you use signals) within the language itself though (without having to be in a monad)
00:06:44 <dmead> mmorrow, oh snap
00:06:58 <dmead> mmorrow, wait..
00:07:05 <dmead> mmorrow, what happens at k 1
00:07:20 <mmorrow> dmead:      callcc (\k -> k 1) ==== 1
00:07:22 <copumpkin> mmorrow: you could do that in Cont still though (minus the signals) couldn't you?
00:07:23 <mmorrow> dmead:      callcc (\k -> 1) ==== 1
00:07:29 <mmorrow> dmead:      callcc (\k -> 3 + k 1) ==== 1
00:07:34 <mmorrow> dmead:      callcc (\k -> 3 + 1) ==== 4
00:07:49 <dmead> mmorrow, buuuut your lambda doesn't have a name
00:07:57 <dmead> mmorrow, how does putting k 1 mean a recursive call?
00:08:02 <mmorrow> copumpkin: kind of
00:08:09 <dmead> mmorrow, k is just the parameter
00:09:38 <dmead> gah
00:09:43 <mmorrow> dmead: it means "callcc (\k -> .... k x .......)" turns into "x"
00:09:57 <mmorrow> no matter what the "....." parts are
00:10:10 <mmorrow> or how deeply nested they are, etc
00:10:49 <mmorrow> copumpkin: http://moonpatio.com/repos/Scheduler.hs
00:10:50 <dmead> mmorrow, what?
00:11:28 <copumpkin> mmorrow: looks fancy :)
00:11:34 <jfredett> alright, time for caffiene... afk.
00:11:48 <mmorrow> dmead: (\f -> callcc (\k -> callcc (\z -> callcc (\w -> f (k 4))))) (\x -> error "omg")
00:11:52 <mmorrow> dmead: equals 4
00:11:58 <copumpkin> dmead: using the parameter callcc gives you is very similar to an early return out of a function in an imperative language
00:12:37 <Saizan>  though the context matters
00:12:41 <mmorrow> copumpkin, dmead: it starts to get interesting though when you start putting "k"s from different callcc's into data though, and saving them places
00:12:54 <copumpkin> yeah
00:12:54 <dmead> eesh
00:13:08 <mmorrow> that's how that scheduler works
00:13:17 <ski> then you can prove things line `Either a (Not a)' ..
00:13:40 <copumpkin> zomg
00:13:51 <copumpkin> anyway, with that insightful comment, I shall hit the hay
00:13:54 <copumpkin> g'night everyone :)
00:13:56 <mmorrow> aww
00:14:03 <mmorrow> night
00:14:17 <dolio> :t callCC (\k -> return . Right $ k . Left)
00:14:18 <lambdabot> forall b (m :: * -> *) a. (MonadCont m) => m (Either a (a -> m b))
00:16:11 <dmead> i don't understand this, i guess i'll buy a book
00:17:03 <FunctorSalad> what's the best way to send in patches for a project that doesn't seem to have any repo?
00:17:13 <dolio> :t let peirce :: ((a -> b) -> a) -> a ; peirce = undefined in peirce (\k -> Right $ k . Left)
00:17:14 <lambdabot> forall b a. Either a (a -> b)
00:17:18 <mmorrow> dmead: it's kind of like exceptions, only you can save the point you threw the exception from for later too, and also "throw exceptions" to other of these save-points, possibly on different stacks (thinking in terms of C or C++)
00:18:15 <mmorrow> dmead: you could probably implement callcc in C with ucontext.h and a bunch of (possible non-portable) hackery
00:19:04 <mmorrow> but setjmp.h wouldn't cut it (since you need to be able to jump /between/ stacks, not just /up/ one stack)
00:20:10 <ski> (mmorrow : i used `Thread = [Thread] -> IO ()', in one scheduler ..)
00:20:26 <mmorrow> heh, nice
00:20:50 <ski> each thread took the other threads as argument, and did something
00:21:03 <ski>   schedule :: [Thread] -> SystemM ()
00:21:09 <ski>   kill :: SystemM Void
00:21:14 <mmorrow> cool, i'll have to try to work that out
00:22:06 <ski> where `SystemM a' was (more or less) `StateT [Thread] (ContT () IO) a'
00:22:45 <ski> (and the use of `Void' there above simplified things so i could avoid scary `undefined's
00:22:48 <ski> )
00:24:18 <mmorrow> heh, yeah i tried to keep the current suspended Label in the state in a (ContT State), but then everything gets so knotted i needed to snip it with an Any eventually
00:24:41 <British0zzy> is there an integer divide in haskell?
00:24:50 <mmorrow> type S o = Label (M o) (Maybe (Either (Label (M o) (Maybe ())) Any))
00:24:56 <mmorrow> newtype M o a = M {unM::ContT o (State (S o)) a}
00:24:57 <mmorrow> gah!
00:24:58 <notsmack> British0zzy, div
00:25:43 <mmorrow> (also needed the Any because since the tasks are allowed to return values, the `a' would show up in the state type, ruining monad-ness)
00:26:21 <mmorrow> well, that's actually the only reason the Any's needed i think
00:26:22 <British0zzy> notsmack: thanks! didn't realize there was a difference between (/) and div
00:29:53 <Gracenotes> technically they do the 'same' thing: you could make a Divide typeclass. But, since typeclasses group functions, (/) is grouped with fractional types, and div is grouped with integer types. some typeclass extensions could clean things like this up, somewhat...
00:29:56 <dmead> mmorrow, in the example you showed me : (\f -> callcc (\k -> callcc (\z -> callcc (\w -> f (k 4))))) (\x -> error "omg")
00:30:12 <dmead> mmorrow, how is 4 returned? i'm still not clear how that terminates
00:30:32 <dmead> i understand the concept of perserving the current state
00:30:40 <dmead> but it's just not clear snytactically how that happens
00:30:51 <dmead> am i making sense?
00:30:57 <mmorrow> dmead: since calling `k' with something jumps back out to the callcc that `k's from, and continues from there
00:31:53 <mmorrow> (\f -> callcc (\k -> callcc (\z -> callcc (\w -> f [|k 4|])))) (\x -> error "omg") ====> (\f -> 4) (\x -> error "omg")
00:32:53 <bos> continuations make the head asplode quite frequently.
00:32:55 <mmorrow> dmead: it's not something you can phrase in terms of any constructs of a C-like language (save for something like ucontext.h)
00:33:11 * bos `ap` bed
00:33:16 <mmorrow> night
00:33:17 <dmead> hmm
00:33:57 <dmead> so i suppose you would want to mix CPS with do-blocks or a bunch of IO
00:34:07 <dmead> or else all you can do is call the next contination?
00:34:37 <mmorrow> dmead: think of the `k' as literally holding the register contents of right before the callcc call as well as the address of the code right after the callcc, and calling the k with a value restores those registers, sticks that value in one of them, then jumps to that label
00:35:09 <dmead> that k is the same k right afer the first callcc?
00:35:12 <mmorrow> since that's pretty much what it would do
00:35:14 <mmorrow> yeah
00:35:22 <ski> mmorrow : i'm not sure what your labels are for ..
00:35:38 <mmorrow> ski: err, in what?
00:35:53 <ski> <mmorrow> heh, yeah i tried to keep the current suspended Label in the state in a (ContT State), but then everything gets so knotted i needed to snip it with an Any eventually
00:36:32 <mmorrow> ski: oh, the Label is from monadLib, it's just a newtype to be able to get the "k" out of callCC (\k -> ...)
00:36:43 <mmorrow> , src ''Label
00:36:48 <lunabot>  newtype Label m a = Lab ((a, Label m a) -> m ())
00:37:08 <ski> why `()' ?
00:37:18 <ski> (instead of e.g. `Void' ?)
00:37:19 <dmead> mmorrow, so how would you stick a compution between calls to callcc?
00:38:01 <mmorrow> dmead: callcc (\k -> 2 + callcc (\z -> 3 + z 4)) == 6
00:38:03 <mmorrow> ?
00:38:10 <mmorrow> ski: i'm not sure the rationale
00:40:04 <ski> .. in my case, i "extracted" the continuation out of `callCC' by using `T :: ([Thread] -> IO ()) -> Thread'
00:40:06 <dmead> mmorrow, z makes control jump back to where?
00:40:14 <mmorrow> ski: i used a clone of Label in this though, along with both variants of callCC for (StateT Cont), to get a "transactional state" thingy which i thought was neat http://hackage.haskell.org/packages/archive/monad-tx/0.0.1/doc/html/src/Control-Monad-Tx.html
00:40:21 <ski> dmead : back to the inner `callcc' call
00:40:50 <mmorrow> callcc (\k -> k 1) == 1
00:40:54 <mmorrow> callcc (\k -> 1) == 1
00:41:08 <ski>      ..(callcc (\k -> 2 + callcc (\z -> 3 + z 4)))..
00:41:14 <mmorrow> callcc (\k -> 2 + callcc (\z -> z 1)) == 3
00:41:18 <mmorrow> callcc (\k -> 2 + callcc (\z -> k 1)) == 1
00:41:28 <ski>   =  ..(let k x = ..x.. in 2 + callcc (\z -> 3 + z 4)))..
00:42:02 <dmead> so thats all we have to say where control returns to?
00:42:12 <dmead> the name of the variable of the function being called by callcc?
00:42:13 <ski>   =  ..(let k x = ..x.. in 2 + let z y = ..(2 + y).. in 3 + z 4)..
00:42:38 <mmorrow> dmead: right
00:42:44 <ski> (hrm .. i should really add some abort, in there)
00:44:37 <dmead> mmorrow, so you can't have multiple variables?
00:45:17 <dmead> mmorrow, i think it's starting to sink in a bit
00:45:28 <mmorrow> err, how do you mean? callcc takes a function, then gives that function /another/ function which, if it gets called, resumes from /after/ the callcc
00:48:24 <mmorrow> yeah, it's kind of mind bending at first, but then you just get comfortable with the idea
00:48:24 * ski thinks dmead should implement  ('a -> 'b) -> ('a * 'b cont) cont  in SML/NJ
00:48:24 <mmorrow> i'm so pissed smlnj doesn't work on x86_64
00:48:24 <dmead> i haven't done sml for quite a while
00:48:24 <ski> (where `foo cont' is the type of continuations expecting to be jumped to with an argument of type `foo')
00:48:24 <mmorrow> i need to play with it in vmware :(
00:48:24 <ski> Scheme would also work, except that you don't have static types
00:48:24 <dmead> mm_freak, why wouldn't it work on your machine?
00:48:24 <dmead> err mmorrow why wouldn't it work for you?
00:48:24 <mmorrow> dmead: its codegen doesn't do x86_64
00:48:24 <mmorrow> only x86, and some others
00:48:24 <dmead> your os doesn't have a compatibility lib?
00:49:11 <mmorrow> dmead: some of the actual instructions are different though, so some x86 asm is illegal on x86_^4
00:49:45 <dmead> mmorrow, sure, your compatibility lib should take care of that
00:50:04 <dmead> smlnj works for me on gentoo x86_64
00:50:10 <mmorrow> :o
00:50:20 <mmorrow> dmead: what is this compatibility lib?
00:50:40 <mmorrow> it runs 32bit binaries or something?
00:50:42 <dmead> the stuff that lets a 64 bit os use 32 bit machine code
00:50:43 <dmead> yea
00:51:31 <dmead> or if you have gentoo it'll just install the source for sml
00:51:31 <mmorrow> would i already have it, or do i need to get it? (like, what's it called?)
00:51:31 <mmorrow> fedora
00:51:31 <dmead> what os do you run?
00:51:31 <dmead> yum will probably just install it automatically
00:51:34 <dmead> if you want to install something that doesn't have a 64 bit binary
00:51:44 <dmead> but i really doubt they don't have 64 bit sml
00:52:06 <mmorrow> grr, smlnj isn't in any of the yum repos i've got
00:52:20 <mmorrow> dmead: yeah, apparently their codegen doesn't support x86_^4 yet
00:52:29 <mmorrow> gah, keep hitting ^ for 6 :)
00:52:34 <dmead> that can't be true
00:52:58 <mmorrow> dmead: i'm fairly certain, i read that in the code last time i tried
00:53:11 <dmead> i'm running smlnj right now on gentoo x86_64
00:53:19 <mmorrow> i was building from source though
00:53:28 <dmead> yea, it built from source
00:53:30 <dmead> thats all gentoo does
00:53:32 <mmorrow> :o
00:53:43 <mmorrow> ok, i'm going to get the tarball again then
00:54:06 <mmorrow> (maybe there's a port different from the official sml/nj version of their website)
00:54:18 <dmead> should just be some compiler options
00:54:27 <dmead> you shouldn't have to do anything special
00:54:45 <dmead> one more question about cps
00:54:46 <mmorrow> when i checked in maybe march their configure script didn't have an x86_64 option (it just said "TODO" or something)
00:54:51 <dmead> ahh
00:55:12 <mmorrow> maybe it's "DIDDO" now :)
00:55:22 <dmead> mmorrow, :      callcc (\k -> k 1)  ==== 1
00:55:25 <dmead> mmorrow, :      callcc (\k ->  1)  ==== 1
00:55:29 <mmorrow> right
00:55:47 <dmead> so how do you get a permentant 'loop'
00:56:01 <dmead> or persistance etc
00:56:19 <mmorrow> callcc (\k -> f 1 k), where `f' can be anything
00:56:27 <dmead> iah
00:56:29 <dmead> ah
00:56:35 <dmead> so you can have f return another k?
00:56:47 <dmead> or not?
00:56:51 <mmorrow> think of it like (callcc f)
00:57:14 <mmorrow> that `f' gets handed a function (lets call it `k') that it can use to escape
00:57:39 <fnord123> ?t GLdouble
00:57:40 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:57:44 <dmead> you're passing 1 and k to f?
00:57:50 <fnord123> ?type GLdouble
00:57:51 <lambdabot> Not in scope: data constructor `GLdouble'
00:57:55 <mmorrow> it can also stick that `k' in some piece of data that it returns too, and if anyone happens to call that `k' later, execution jumps /back/ to the point after that callcc
00:58:15 <dmead> mmorrow, does the callcc get shed after it returns?
00:58:16 <ivanm> preflex: seen Raevel
00:58:16 <preflex>  Raevel was last seen on #haskell-blah 12 hours, 5 minutes and 24 seconds ago, saying: http://www.schneier.com/blog/archives/2009/10/dont_let_hacker.html
00:59:02 <mmorrow> dmead: well, you'll always continue after the callcc, but depending on whether you take that `k' with you or not, you might jump back there multiple times
00:59:09 <fnord123> if a type is defined using 'type' then it's not actually a new type, right? So I have some Double values being passed to typeclassed functions that have instances defined for GLdouble. GLdouble is 'type GLdouble = Double'
00:59:18 <fnord123> however I'm getting compilation errors.
00:59:34 <fnord123> Maybe there's some super syntax to import instance decls that i'm not aware of?
00:59:40 <dmead> mmorrow, so callcc might do nothing if you don't return k?
01:00:26 <ski> dmead : whether it does something special or nor depends on whether you apply `k' to something
01:01:09 <notsmack> fnord123, what's the error?
01:01:34 <ski> dmead : e.g., in the proof of `Either a (Not a)', that uses `callCC', captures a continuation `k :: Not (Either a (Not a))', and just returns `Right ka' where `ka :: Not a'
01:01:37 <mmorrow> dmead: so you can either (1) discard the k and return as usual => resuming after the callcc, (2) call the k and escape out to after the callcc, (3) either (1) or (2) but squirrel the k away somewhere for later, in which case calling it will jump you back to immediately after that callcc
01:01:58 <ski> i.e. `callCC (\k -> let ka = ... in Right ka)'
01:02:12 <dmead> mmorrow, i get it!
01:02:17 <mmorrow> dmead: yay!
01:02:37 <dmead> sooo i this...
01:02:41 <dmead> mmorrow, :      callcc (\k -> k 1)  ==== 1
01:02:49 <dmead> you're passing 1 to k?
01:02:54 <mmorrow> right
01:02:55 <ski> then, if/when `ka :: Not a' is ever applied to a value `a :: a', then that application never returns, and instead the original `callCC (\k -> ...)' returns *again*, this time with answer `Left a'
01:03:00 <ski> so
01:03:33 <ski>   callCC (\k -> let ka = mkCont (\a -> throwCont k a) in Right ka)
01:03:34 <ski> where
01:03:41 <dmead> mmorrow, so where does that value go when it returns to \k?
01:03:44 <ski>   throwCont :: Not a -> a -> b
01:03:56 <ski>   mkCont :: (a -> Void) -> Not a
01:04:20 <mmorrow> dmead: "just" returning without calling the `k' is the same as wrapping /everything/ in that k
01:04:59 <fnord123> notsmack: No insance for (MatrixComponent Doubl) arising from a use at [filename:line]\n Possible fix: add an instance declaration for (MatrixComponent Double)
01:05:20 <mmorrow> dmead: at this point i think you just need to play around with it, in either smlnj or the Cont monad
01:05:31 <ski> dmead : when `k' is called with `42', that makes the original `callCC (\k -> ...)' expression return the value `42'
01:05:34 * mmorrow meanwhile tries to get smlnj setup
01:05:47 <ski> (regardless of whether it has returned already or not)
01:05:50 <dmead> mmorrow, smlnj has real callcc?
01:06:27 <ski> dmead : yes
01:06:35 <ski> (as does Scheme)
01:06:43 <dmead> ski, in my head i'm just imaging that  the k after the arrow just dissapears
01:06:50 <fnord123> sorry for the spelling. this keyboard is really awful.
01:06:59 * fnord123 will never buy another mac
01:07:17 <mmorrow> dmead: yeah, that's why smlnj is so awesome :)
01:07:22 <ski> (and "real callcc" is a side-effect .. which explains why Haskell cannot have it (even though TheHunter implemented it, iirc))
01:07:23 <mmorrow> dmead: and it's O(1) callcc too
01:07:34 <notsmack> fnord123, and GLDouble is an instance of MatrixComponent i gather?
01:07:37 <dmead> i would prefer a real callcc in haskell
01:07:47 <ski> dmead : which "k after the arrow" ?
01:07:58 <dmead> ski:      callcc (\k -> k 1)  ==== 1
01:08:01 <mmorrow> ski: TheHunter?
01:08:02 <ski> dmead : see parenthetical remark, above ^
01:08:07 <dmead> ski  .... -> k
01:08:08 <dmead> that k
01:08:16 <dmead> gotcha
01:08:17 <fnord123> notsmack: correct. GLdouble is an instance of MatrixComponent, but for some reason Double isn't.
01:08:18 <ski> mmorrow : yes. it's in one of the Monad.Reader issues, iirc
01:08:28 <mmorrow> ski: oh nice
01:08:59 <ski> (mmorrow : it uses linear implicit parameters, and probably `unsafeCoerce', too :)
01:09:08 <mmorrow> ski: heh
01:10:32 <dmead> ski, mmorrow, so in reality the second time control hits k it ignores it?
01:10:40 <notsmack> fnord123, seems strange to me, but i'm no expert...  the instance declaration is in scope?  possibly Double should be the instance instead of GLdouble?
01:10:45 <ski> dmead : which example are you talking about ?
01:10:50 <dmead> ski:      callcc (\k -> k 1)  ==== 1
01:11:03 <ski> there's no "second time", there
01:11:22 <dmead> ski:      callcc (\k ->  1  k)  ==== 1
01:11:29 <dmead> how about there?
01:11:40 <ski> `1 k' is ill-typed (unless you have functional numbers :)
01:11:52 <dmead> oh right
01:11:55 <dmead> ski:      callcc (\k -> f 1  k)  ==== 1
01:12:12 <ski> what happens there depends fully on what `f' does
01:12:25 <ski> `1' might be the answer, or it might not
01:12:32 <dmead> lets say it does some stuff and makes control go back to \k
01:12:41 <mmorrow> dmead:  callcc (\k -> (k 1) + (k 2)) == depends on evaluation order
01:12:44 <ski> if the `f' call returns `1', then that is the answer
01:12:50 <fnord123> should be inscope afaik
01:13:07 <dmead> ski: if it returns k, then control goes back to \k yea?
01:13:10 <dmead> err
01:13:12 <dmead> mmorrow, ^^
01:13:24 <ski> if the `f' call ever invokes `k', the execution of `f' will abort, and the whole `callcc' call will immediately yield as result what `k' was invoked with
01:14:03 <ski> dmead : if `f 1 k' returns `k' itself, then you have circular types .. won't type-check (without some wrapping)
01:14:42 <mmorrow> dmead:      case (callcc (\k -> Left k)) of Left k -> print 42 >> k (Right 12); Right n -> print n
01:14:46 <mmorrow> would print
01:14:48 <mmorrow> 42
01:14:49 <mmorrow> 12
01:15:11 <mmorrow> (ignoring that that probably wouldn't typecheck in haskell)
01:15:11 <ski> indeed
01:16:51 <younder> Hi, want that website.
01:17:10 * ski gives younder that website
01:17:49 <ski> question : what's the dual of `want' ?
01:17:55 <dmead> innnnnteresting
01:18:15 <dmead> ah yea
01:18:18 <dmead> so you're calling
01:18:30 <dmead> (\k -> Left Right k)?
01:18:38 <dmead> i mean
01:18:38 <ski> nope
01:18:40 <dmead> (\k -> Left Right 12)?
01:18:44 <ski> nope
01:19:04 <ski> first time, `callcc (\k -> Left k)' returns `Left k' (for a certain captured continuation `k')
01:19:19 <ski> so we `print 12' and then call `k (Right 12)'
01:19:29 <mmorrow> calling (k (Right 12)) jumps back to [|callcc (\k -> Left k)|] and replaces that with (Right 12)
01:20:09 <dmead> ski do you mean print 42 and then call k (right 12)?
01:20:09 <ski> that last invocation of the continuation `k' makes the current execution (the `Left k -> ...' branch) be aborted, and instead we jump back to `callcc (\k -> Left k)' which now returns `Right 12'
01:20:27 <ski> er, right. ty
01:20:29 <dmead> mmorrow, oh so the whole expression after callcc is replaced?
01:20:45 <mmorrow> the callcc expression is replaced
01:21:00 <ski> dmead : the `callcc (\k -> ...)' expression is replaced with whatever `k' was invoked with
01:21:06 <dmead> ooooh
01:21:08 <mmorrow> (case [|HOLE|] of Left k -> print 42 >> k (Right 12); Right n -> print n)
01:21:16 <mmorrow> calling k fills that HOLE
01:21:20 <dmead> i thought it was just placeing the k parameter of that lambda
01:21:25 <ski> (i.e. `callcc (\k -> ...)' "returns" `Right 12' since our call to `k' was `k (Right 12)')
01:21:39 <younder> No, no the P /= NP bit. I promised yo to publish it today. But I can't.. The Clay prize committee needs to evaluate it first.
01:21:44 <dmead> ski cool cool
01:22:18 <ski> so now `callcc (\k -> ...)' has returned two times (and has returned different values those two times)
01:22:29 <dmead> right
01:22:35 <younder> Them committees and that prise is probably why it took so long..
01:22:36 <ski> and it is the *same* call to `callcc' which returns two times
01:22:36 <dmead> all while not wasting stack space on recursive calls
01:22:58 <dmead> or is it heap space?
01:23:09 <nha_> the wiki needs more stuff on continuations
01:23:17 <ski> i'm not sure how space considerations enter in this specific example
01:23:32 <dmead> the continuations examples on the wiki are just awful
01:23:37 <ski> dmead : btw, in SML/NJ, the stack is allocated on the heap :)
01:23:41 <dmead> ah
01:23:55 <nha_> most of the features they show off seem useless haha
01:24:01 <ski> (and in Chicken Scheme, the heap is allocated on the stack ;)
01:24:04 <nha_> or are things you can do other/better ways
01:24:05 <dmead> ski or mmorrow  should put something intelligable in there
01:24:11 <mmorrow> dmead: it's kind of like an inverted tree instead of a stack too
01:24:19 <ski> (aka Cheney on the MTA)
01:24:22 <younder> You do Lisp here?
01:24:34 <younder> funny
01:24:45 <ski> younder : a little Scheme should not be problematic, imo
01:25:21 <dmead> i can't think about ghc internals  now
01:25:29 <dmead> i need to go sit and let this sink in
01:25:30 <dmead> i'll bbl
01:25:31 <ski> nha_ : which pages are you referring to ?
01:25:35 <dmead> thanks for you help gus
01:25:43 <ski> dmead : my pleasure
01:25:44 <mmorrow> no problem :)
01:25:48 <dmead> ski http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
01:25:51 <dmead> that page is awful
01:25:53 <dmead> bbl
01:26:33 <younder> It is and so is the title, it should be deleted
01:26:34 <fnord123> notsmack: it appears that I need to use TypeSynonymInstances if I want to be able to use Synonym's on instances. However it doesn't appear to work across module boundaries.
01:26:36 <ski> continuations build character
01:27:45 <nha_> the deliminated cont example wasnt so great either i think
01:27:50 <younder> Put it all in a continuations page
01:28:07 <nha_> you can do the same thing with an infinite type + returning the next recurse call
01:28:50 <ski> younder : what page were you talking about before, btw ?
01:28:54 <dirotis> can someone explain to me what this 5-line function means: http://pastebin.org/38299 ; I get most of it but I don't understand what the "in flatten' ls[]" is at the end
01:29:09 <younder> obviously continuations is just continuing where you left off, why makeit so difficult.
01:29:24 <en0th> is put (inc (get s)) s  equivalent to put . inc . get s  ?
01:29:57 <ski> younder : well, part of the power of continuations is to not have to continue where you left off, at least not directly
01:30:07 <younder> ski: dmead  http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
01:30:11 <ski> en0th : `put . inc . get $ s'
01:30:30 <ski> i meant
01:30:30 <ski> <younder> Hi, want that website.
01:30:31 <en0th> mkay
01:30:31 <Botje> dirotis: let (BINDINGS) in (BODY)
01:30:43 <Botje> dirotis: the body here is the call to flatten' ls []
01:30:50 <Botje> and the bindings define the function flatten'
01:31:08 <younder> ski: just that page
01:31:09 <Cale> dirotis: What an unusual way to write the identity function
01:31:13 <Peaker> dirotis, usually "where" is used for that rather than "let ... in"
01:32:02 <dirotis> so if you used where then you wouldn't have to define a body?
01:32:10 <Cale> dirotis: flatten' is supposed to be like flatten, except that it has an extra parameter, presumably for managing some intermediate state as the algorithm proceeds.
01:32:41 <Botje> where is used as (BODY) where (BINDINGS)
01:32:44 <Botje> so you always have a body
01:32:57 <Cale> dirotis: This value 'a' starts out as the empty list, and flatten' flips the original list over into it as it walks down the original list
01:32:58 * Botje notes: haskell syntax does not make it easy to hide bodies.
01:33:29 <dirotis> haha! @ Botje
01:33:32 <Cale> and then when it reaches the end of the list, it reverses a, resulting in... well, the original list, if it was finite
01:33:44 <ski> Botje : "hide bodies" ?
01:33:50 <Peaker> dirotis, if you used "where" you wouldn't need to have the "in".  Just f = <body>  where  <definitions>
01:34:08 <Peaker> dirotis, instead of   f = let <definitions>  in  <body>
01:34:12 <Cale> This is also indented using tabs, which is a bad idea.
01:34:28 <dirotis> oh I see, thanks for the explanation
01:34:34 <dirotis> I put in the tabs manually should I use 4-spaces
01:34:49 <Cale> dirotis: You should configure your editor to replace tabs with spaces automatically.
01:35:01 <ski> > let Just f = lookup 'a' [('a',square sin)] where square g = g . g in f pi
01:35:01 <Cale> (essentially all good text editors have that feature)
01:35:02 <lambdabot>   1.2246467991473532e-16
01:35:46 <dirotis> oh
01:36:10 <Cale> dirotis: The reason why is that the Haskell implementation will treat the tabs as aligning to the next 8-space multiple, regardless of how they look in your editor.
01:36:20 <Cale> and it's possible for it to matter
01:36:33 <dirotis> oh
01:36:36 <Cale> (since layout in Haskell is all about how things line up from line to line)
01:37:10 <Baughn> By all modern standards, there being a tab /character/ is a huge mistake. It's best not to use it.
01:37:30 <Baughn> (Or should I say, there being a character without that character having a defined meaning)
01:38:12 <dirotis> I see
01:38:51 <younder> fair enough, you remember what it did in a typewriter: Well it does the same in a word processor. Just don't use it for ASCII text.
01:39:51 <en0th> isFinal s = (get s) == []   goes    isFinal = (== []) . get      , right?
01:40:14 <ski> yes .. but write `null' instead of `(== [])'
01:40:21 <ski> @type null
01:40:22 <lambdabot> forall a. [a] -> Bool
01:40:24 <ski> @type (== [])
01:40:25 <lambdabot> forall a. (Eq a) => [a] -> Bool
01:40:32 <ski> (see the difference in types)
01:40:37 <en0th> it's good
01:41:28 <en0th> miranda didn't have that i guess, SPJ even wrote that function with case expr..
01:43:14 <younder> on my emacs 'Tab' si mapped to abbrev completion anyways. Good use of a otherwise useless key
01:43:35 <younder> hint
01:44:13 <dirotis> what would it complete for me in Haskell
01:44:53 <quicksilver> on my emacs, 'tab' jumps to the next haskell indentation position to the right of the cursor.
01:45:04 <quicksilver> which takes considerable pain out of layout code.
01:45:21 <fnord123> gwern: you still around? If so, I'd like to send you a tar.gz with my little game
01:45:21 <younder> Because the default emacs mode for Haskell is sub standard.
01:45:35 <fnord123> i updated it for 6.10.4 finally :D
01:45:40 <Baughn> I've got M-tab mapped to pabbrev, but tab's for layout. :)
01:46:43 <younder> Baughn: It is a BAD way to layout text
01:47:13 <Baughn> younder: tab, as in indent-for-tab-command
01:47:20 <dirotis> how long is Haskell supposed to destroy your brain
01:47:28 <Baughn> dirotis: Oh, it never truly stops.
01:48:27 <dirotis> damn
01:49:34 <en0th> ( is there a way to stop kate automatic indentation? )
01:50:00 * ski wonders who kate is
01:50:27 <en0th> a kde text editor
01:50:38 <dirotis> http://kate-editor.org/
01:51:12 <younder> I use crtl-forward (the arrow bit) for indent and ctrl-backward for dedent
01:51:15 <Baughn> en0th: If you're worried that kate might not be the best editor to write haskell code in..
01:51:20 <Baughn> You're absolutely correct. ^_^
01:51:56 <en0th> yes, i'm getting tired. i disable auto indent and 'she' enables it again..
01:52:12 <ski> you're using she ?
01:52:20 <en0th> :(
01:52:24 <ski> @where she
01:52:24 <lambdabot> I know nothing about she.
01:52:27 <ski> bah
01:52:32 <Baughn> @where kate
01:52:33 <lambdabot> I know nothing about kate.
01:52:55 <Baughn> en0th: http://kate-editor.org/article/katepart_modelines
01:53:22 <Baughn> en0th: Although, I do think you ought to try emacs. Haskell-mode is :3.
01:53:37 <fnord123> colon 3?
01:53:43 <ski> yes
01:53:59 <fnord123> I thought it would be M-x haskell-mode
01:54:02 <en0th> i've always stayed aware of emacs. it kinda scares me
01:54:10 <fnord123> :3 looks more like a vim command
01:54:47 * ski refrains from a russian reversal
01:55:39 <quicksilver> in soviet russia, russian reversal refrains from YOU?
01:55:44 <Baughn> ..geez
01:55:44 <ivanm> en0th: you've stayed aware of emacs? then you're halfway there! ;-)
01:55:52 <British0zzy> What are your guys preferred way of reading input files?? Is there a good lightweight haskell library that allows you to describe the input file's format and read it in easily??
01:55:55 <Baughn> :3, as in "cat-face smiley"
01:55:56 <ivanm> quicksilver: so we've degenerated into /. have we?
01:56:11 <younder> seems so
01:56:20 <Baughn> British0zzy: Several, depending on what is actually in the input file
01:56:28 <Baughn> British0zzy: To begin with, binary or textual?
01:56:33 * ski 's only seen it on uncyclopedia ..
01:56:34 <British0zzy> textual
01:56:35 <en0th> ivanm: away.. sorry i'm still at the first coffee..
01:56:43 <ivanm> there's an ini-based parsing library IIRC...
01:56:52 <dirotis> can someone help me with a beginning haskell problem, it's 10 lines: http://pastebin.org/38326 , apparently I have to fix the flatten function's type, so i tried to do a type declaration : flatten :: [[Integer]] -> [Integer]  but that doedsn't work,  the sumThemAll function is correct and shouldn't be changed
01:56:52 <ivanm> either gitit or happstack uses it IIRC
01:57:02 <Baughn> British0zzy: Based on a common existing format? CSV, XML, .ini, etc?
01:57:13 <younder> take the editor bit to the emacs group..
01:57:41 <ivanm> @hackage ConfigFile
01:57:42 <lambdabot> http://hackage.haskell.org/package/ConfigFile
01:57:47 <ivanm> @hackage EEConfig
01:57:48 <lambdabot> http://hackage.haskell.org/package/EEConfig
01:57:54 <ivanm> etc.
01:58:14 <Baughn> dirotis: It's generally a good idea to write type signatures before the functions. That way, you won't get type errors in the callers that are actually because of errors in the callees
01:58:18 <British0zzy> sadly no. actually, in other languages i'd probably use a regexp.
01:58:28 <Baughn> British0zzy: Parsec.
01:58:48 <ivanm> British0zzy: :o
01:58:48 <ivanm> or polyparse
01:58:48 <ivanm> or any other parsing library
01:58:54 <Baughn> British0zzy: It's more powerful than regexes. You could also use a regex, but parsec's nice.
01:59:19 <ivanm> Baughn: did you mean s/nice./much nicer and easier with fewer hacks!/ ? :p
01:59:25 <younder> parsec is overly verbose
01:59:30 <dirotis> oh ok
01:59:32 <dirotis> I updated here: http://pastebin.org/38330
01:59:34 <ski> dirotis : that doesn't flatten
01:59:34 <Baughn> ivanm: I wouldn't want to insult regexes
01:59:39 <ivanm> heh
02:00:00 <British0zzy> is there a good tutorial for parsec
02:00:09 <ivanm> British0zzy: http://hackage.haskell.org/package/#cat:parsing
02:00:13 <British0zzy> parsec always struck me as a heavy duty solution
02:00:13 <younder> Baughn: Please do, they are cryptic to the point of being inpenetrable
02:00:15 <ski> dirotis : your `flatten' is `id' on (finite) total lists
02:00:21 <fnord123> British0zzy: yes. the one in real world haskell is very good
02:00:27 <Baughn> younder: Whiel parsec is overly verbose? :P
02:00:42 <British0zzy> ah, didn't know there was an example in RWH
02:00:47 <dirotis> oh
02:00:50 * younder nods
02:00:50 <Baughn> younder: ..I find that it's easy enough to write combinators that un-verbose it
02:00:59 <fnord123> otherwise scheme in 48 hours is good. however they have very different codings styles. I much prefer the one in RWH
02:01:17 <fnord123> chapter 16
02:01:17 <ivanm> what is the main attraction of parsec over other libraries? it's been around longer and thus has more support, etc. for it?
02:01:35 <ivanm> (even though no-one seems to use parsec-3...)
02:01:38 <Baughn> It's been around longer, and people know it
02:01:44 <ivanm> *nod*
02:01:52 <Baughn> ..well, that's because parsec 3 is noticably slower. ^^;
02:02:00 <ivanm> still?
02:02:22 <Baughn> For my purposes.. yes.
02:02:31 <ivanm> any idea why it's slower?
02:02:38 <Baughn> Not me
02:02:44 <Baughn> Although Parsec is vast overkill for my usual purposes. I could usually use Data.Binary instead.
02:03:42 <ivanm> I just used polyparse because I inherited graphviz with polyparse already used there
02:03:47 <ivanm> and I've never used parsec
02:04:41 <younder> I wish I never had..
02:04:55 <quicksilver> I think a real parsing library is generally preferable to Data.Binary
02:05:09 <quicksilver> I'm not very keen on parsec's interface but those are fairly minor points.
02:05:22 <quicksilver> you can either use polyparse or something, or just wrap the combinators with something a bit nicer.
02:05:25 <Baughn> Data.Binary is.. what should I call it, single-lookahead, no-backtracking? What's that called?
02:05:28 <younder> But a full on parser for regular text?
02:05:31 <ronc> hey haskell people
02:05:36 <younder> seems excessive
02:05:38 <ronc> I have a stupid question
02:05:49 <ronc> head (tail x) OR (head . tail) x
02:05:51 <ronc> :P
02:06:00 <Baughn> head $ tail x
02:06:03 <ivanm> agreed
02:06:07 <quicksilver> younder: I would say the oppossite. I would say "regexes for a simple parsing job? seems excessive :P"
02:06:12 <ivanm> or head . tail $ x
02:06:26 <ronc> why? :X
02:06:58 <Cale> The  head . tail $ x  style is nice because it makes things easy to refactor.
02:07:06 <Cale> Basically, because (.) is an associative operator
02:07:14 <Baughn> In actual fact, regexes are at a lower language level than full-on parsers, and can be implemented with higher performance. Data.Binary is a level below that again.
02:07:18 <Cale> So if you have something like  f . g . h $ x
02:07:27 <Baughn> If people insist on /misusing/ regexes that's a problem, though..
02:07:37 <ronc> I could have head . tail without x in there, in a point-free way
02:07:46 <Cale> then  g . h  is a well-typed expression, as are f . g, f . g . h, h $ x, g . h $ x, and so on.
02:07:49 <ronc> (my function is that simple)
02:08:02 <Cale> Ah, then leave the x out :)
02:08:06 <ronc> cool
02:08:12 <ronc> ^___^
02:08:18 <ski> ronc : `(head . tail) x' is fine .. but all three versions suggested work ok
02:08:25 <Cale> foo = head . tail
02:08:37 <dirotis> ok if I try this then: flatten ls = foldl (++) ls []
02:08:43 <dirotis> shouldn't that flatten a list of lists?
02:08:56 <Cale> dirotis: Parameters in the wrong order
02:09:04 <Cale> also, foldl is worse than foldr here
02:09:15 <Cale> (it won't work on infinite lists)
02:09:18 <younder> ?
02:09:23 <dirotis> how come
02:09:27 <younder> of cource it won't
02:09:39 <Cale> > foldl (++) [] [[k] | k <- [0..]]
02:09:44 <lambdabot>   mueval-core: Time limit exceeded
02:09:47 <Cale> > foldr (++) [] [[k] | k <- [0..]]
02:09:50 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
02:10:07 <Cale> Let's see why :)
02:10:17 <Cale> @src foldl
02:10:18 <lambdabot> foldl f z []     = z
02:10:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:10:25 <younder> foldl is made to be efficient
02:10:31 <ivanm> any of you willing to read through my (updated) draft on SourceGraph for PEPM?
02:10:34 <younder> forldr isn't
02:10:35 <Cale> younder: It's not so simple as that
02:10:42 <ivanm> (I have just under two hours before it's due)
02:10:45 <Cale> younder: Often foldr is more efficient than foldl
02:10:47 <Baughn> younder: I'm not aware of any situations in which foldl is actually the efficient choice. :P
02:10:53 <Baughn> foldl', though.
02:11:02 <Cale> foldl (++) [] [[1],[2],[3]]
02:11:05 <Cale> Let's reduce that
02:11:08 <ski> `foldl' is a bulk-operation
02:11:18 <Cale> -> foldl (++) ([]++[1]) [[2],[3]]
02:11:19 <ski> `foldr' can be incremental
02:11:20 <Baughn> > foldl (++) [] [[a],[b],[c]]
02:11:21 <lambdabot>   [a,b,c]
02:11:26 <Cale> -> foldl (++) (([]++[1])++[2]) [[3]]
02:11:30 <Baughn> > foldl f [] [[a],[b],[c]]
02:11:31 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
02:11:31 <lambdabot>    arising from a use of `Simp...
02:11:35 <Cale> -> foldl (++) ((([]++[1])++[2])++[3]) []
02:11:42 <Cale> -> (([]++[1])++[2])++[3]
02:11:49 <younder> It has to do with primitive recursion
02:12:13 <Cale> We had to walk all the way down the list before we got something which wasn't a foldl
02:12:28 <Cale> So already, you can see that it won't work with infinite lists
02:12:53 <Cale> But now comes the even more scary part, we have a left-associated bunch of ++'s
02:13:07 <Cale> xs ++ ys takes O(length xs) steps to evaluate fully
02:13:23 <Cale> Basically, we're going to see quadratic time behaviour out of this.
02:13:34 <younder> being lazy has it's prise
02:13:44 <younder> price
02:13:56 <Baughn> Next up, the foldr version. Just you wait. :)
02:14:12 <Cale> This isn't about the price of laziness. It's just different. foldr is going to win by a good deal :)
02:14:22 <Cale> (and it'll win over any strict algorithm)
02:14:27 <en0th> let's see why :)
02:14:39 <Cale> @src foldr
02:14:40 <lambdabot> foldr f z []     = z
02:14:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:14:52 <Cale> foldr (++) [] [[1],[2],[3]]
02:15:07 <Cale> -> [1] ++ (foldr (++) [] [[2],[3]])
02:15:20 <Cale> -> 1 : [] ++ (foldr (++) [] [[2],[3]])
02:15:27 <Cale> -> 1 : foldr (++) [] [[2],[3]]
02:15:46 <Cale> Look at that! We have the first element of our list before the foldr has even finished.
02:15:57 <younder> thx cale.
02:16:09 <Cale> -> 1 : [2] ++ foldr (++) [] [[3]]
02:16:16 <Cale> -> 1 : 2 : [] ++ foldr (++) [] [[3]]
02:16:20 <Cale> -> 1 : 2 : foldr (++) [] [[3]]
02:16:24 <Cale> and the second
02:17:03 <younder> shut up cale
02:17:17 <Cale> hm?
02:17:19 <younder> we get the picture
02:17:19 <quicksilver> younder: that's not very nice.
02:17:47 <younder> Ok, I am not the most patient mani in the world
02:18:08 * ski trades a couple of `='s in exchange for Cale's `->'s :)
02:18:10 <Baughn> > foldr f [x,y,z] :: [Expr]
02:18:11 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
02:18:11 <lambdabot>         against inferre...
02:18:20 <Baughn> > foldr f [] [x,y,z] :: [Expr]
02:18:21 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
02:18:21 <lambdabot>    arising fr...
02:18:37 <Cale> > foldr f [] [x,y,z] :: Expr
02:18:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:18:38 <lambdabot>         against inferred ...
02:18:40 <Cale> er
02:18:41 <Cale> right
02:18:44 <Baughn> This used to work. ;_;
02:18:46 <Cale> > foldr f a [x,y,z] :: Expr
02:18:47 <lambdabot>   f x (f y (f z a))
02:18:59 <Baughn> Hm
02:19:04 <dirotis> if you make an explicit type declaration before a function, does that stop lazy evaluation
02:19:10 <Cale> dirotis: Not at all
02:19:12 <dirotis> no, right?
02:19:21 <dirotis> ok
02:19:22 <Baughn> > foldl f a [x,y,z] :: Expr -- Meanwhile, this should strike fear into anyone who sees it
02:19:23 <lambdabot>   f (f (f a x) y) z
02:19:31 <dirotis> thanks
02:19:52 <Cale> Baughn: Well, that on its own doesn't show the real problem
02:20:08 <Cale> mm... it sort of does
02:20:12 <Baughn> True, you also need to know that haskell operates on graph reduction
02:20:27 <Cale> In that the outermost call to f is applied to z which is the *last* element of the list
02:20:49 <dirotis> are you a Haskell founder...how do you know all of this?!
02:20:59 <Cale> But the foldl has already done all its work -- the real problem is that you get nothing but foldl of some args until the foldl has consumed the whole list
02:21:13 <Baughn> dirotis: No, he's a great old one
02:21:17 <Cale> dirotis: I've just been programming in Haskell for 8 years or so.
02:21:31 <dirotis> wow
02:21:32 <en0th> > foldr f a [x,y,z] :: Expr
02:21:33 <lambdabot>   f x (f y (f z a))
02:21:55 <Baughn> Cale: That, and foldl being non-strict by default
02:22:23 <Baughn> > x : [y]
02:22:24 <lambdabot>   [x,y]
02:22:46 <Baughn> > iterate f x -- Kinda convenient, these expressions
02:22:47 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
02:24:02 <en0th> i still don't get where does foldr stop
02:24:16 <Cale> @src foldr
02:24:17 <dirotis> it doesn't until it gets evaluated right
02:24:17 <lambdabot> foldr f z []     = z
02:24:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:24:27 <Cale> foldr immediately passes control to f
02:24:33 <Cale> (as you can see from that definition)
02:24:46 <Baughn> So, foldr stops at once
02:24:53 <Cale> It passes f some parameters, and includes a call to foldr in the second one.
02:24:56 <Baughn> It's just that the second argument of f, if f uses it, calls foldr again
02:25:10 <Cale> So only if and when f needs its second parameter will the call to foldr continue
02:25:20 <dirotis> so after it folds a sufficient amount from your infinite list it stops executing?
02:25:43 <dirotis> by sufficient amount I mean if you used some conditional expression
02:25:46 <Baughn> Where "sufficient" is defined as "as much as required to compute the results you actually use"
02:25:53 <Baughn> It's lazy evaluation again. :)
02:25:55 <younder> I may be a dunce here but isn't foldr NP complete and survives by efficient cutoff
02:26:04 <Cale> huh? NP complete?
02:26:16 <Peaker> younder, do you know what "NP complete" means?
02:26:18 <ronc> nothing is NP complete
02:26:30 <ronc> only my mom is NP complete
02:26:32 <ronc> ='(
02:26:37 <Baughn> ronc: I've got a cousin who's a salesman that would disagree
02:26:49 <younder> Exponential development then.
02:26:53 * ski peers at Dunce "younder" Scotus, quizzingly
02:26:54 <Cale> younder: foldr f z just replaces each (:) in the list with f and [] with z
02:27:01 <Baughn> younder: No
02:27:06 <Cale> younder: it's at worst linear time in the number of calls to f
02:27:15 <younder> Ok, thanks
02:27:54 <Cale> (but if f doesn't need its second parameter to produce part of its result, then the foldr might not even recurse at all)
02:28:02 <ski> > foldr (\x xs -> xs ++ x : xs) [] [3,2,1,0]
02:28:03 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
02:28:49 <younder> Got it dunce
02:29:28 <Cale> http://cale.yi.org/index.php/Fold_Diagrams <-- some diagrams of what the various folds and scans do.
02:29:38 <ski> (<http://en.wikipedia.org/wiki/Duns_Scotus>)
02:29:41 <Baughn> > foldr (\x y -> if x < 3 then x:y else [x]) [] [1,2,4,1]
02:29:42 <lambdabot>   [1,2,4]
02:30:01 <dirotis> that bot just runs all the haskell you ask it to?
02:30:05 <Cale> dirotis: yep
02:30:07 <dirotis> > 5+5
02:30:09 <lambdabot>   10
02:30:14 <dirotis> sweet
02:30:44 <dirotis> clearly, a great use of the bot I just demonstrated
02:30:51 <ski> > putStrLn "Missiles launched !"
02:30:52 <lambdabot>   <IO ()>
02:30:57 <Cale> > fix ((0:) . scanl (+) 1)
02:30:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:31:44 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
02:31:46 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:32:06 <Cale> > nubBy (((>0).).gcd) [2..]
02:32:11 <lambdabot>   mueval-core: Time limit exceeded
02:32:12 <Cale> hm
02:32:14 <Peaker> > forever . putStrLn $ "Missiles launched !"
02:32:15 <lambdabot>   Ambiguous type variable `b' in the constraint:
02:32:15 <lambdabot>    `Data.Typeable.Typeable b...
02:32:22 <Peaker> > forever . putStrLn $ "Missiles launched !" :: IO ()
02:32:23 <lambdabot>   <IO ()>
02:32:32 <dirotis> jesus, what is going on
02:32:41 <ski_> we're launching nuclear missiles
02:32:47 <Peaker> forever!
02:32:48 <Cale> oh, d'oh
02:32:49 <younder> rotfl
02:32:51 <Cale> > nubBy (((>1).).gcd) [2..]
02:32:53 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:33:30 <Baughn> > let a = [1..] in (last a,a)
02:33:31 <Cale> dirotis: I suppose he's showing that the bot won't execute IO actions, only evaluate them, which has no side effects.
02:33:39 <lambdabot>   mueval: ExitFailure 1
02:33:46 <dirotis> oh
02:34:02 <dirotis> I thought <IO ()> was some sort of ASCII representation of a missile
02:34:05 <ski> > fix id `seq` putChar '!'
02:34:05 <Cale> hehe
02:34:06 <younder> IO actions have side affects
02:34:09 <lambdabot>   <IO ()>
02:34:14 <Cale> I suppose you can think of it that way :)
02:34:22 <ski> appears it doesn't even force them ..
02:34:43 <Cale> Ah, yeah, since the show instance is so lazy :)
02:34:57 <ski> (no actionas have side effects .. every action *represents* a side effect (mayhaps the trivial one))
02:35:19 <Cale> or even s/side//
02:35:33 <ski> actions has effects, yes
02:35:42 <younder> That's why you use Monads, so they won't be quite that lazy. (Print the lot..)
02:35:52 <ski> > [1,2,3,4]   -- <- an effectful computation
02:35:54 <lambdabot>   [1,2,3,4]
02:36:41 <Cale> Well, the thing about IO being a monad is a red herring.
02:37:04 <ski> (wrt what ?)
02:37:05 <Cale> It's really unimportant that IO happens to be a monad. That just means we have a certain general API for gluing IO actions together.
02:37:23 * ski nods
02:37:27 <Baughn> Monads were invented for IO, but that's a historical accident
02:37:29 <Cale> The really important point is that IO actions are values, and evaluating those values doesn't cause those actions to occur.
02:37:53 <Cale> Actually, that too is questionable. The early papers on monads in functional programming don't mention I/O
02:37:55 <ski> (`IO' forms a monad .. but you don't have to make an instance of class `Monad' to use `IO')
02:38:38 * ski raises eyebrow
02:38:50 <Cale> ski: sure.
02:39:27 <Cale> ski: A completely different API would work as well, though it's hard to imagine one for which you wouldn't be able to write an instance of Monad for yourself in the end.
02:39:36 <ketil> Binary: Int64 truncated to fit in 32 bit Int
02:39:36 <ketil> ghc: panic! (the 'impossible' happened)
02:39:36 <ketil>   (GHC version 6.10.4 for i386-unknown-linux):
02:39:36 <ketil>         Prelude.chr: bad argument
02:39:46 <Cale> ketil: awesome.
02:39:47 <ketil> Anybody know what this means?
02:40:00 <Cale> ketil: It means there's a bug in GHC
02:40:04 <ski> Cale : aye .. (since `IO' actually forms a monad)
02:40:32 <Baughn> ketil: Do you know what triggers it?
02:40:36 <ski>   putChar :: Char -> Answer -> Answer
02:40:44 <ski>   getChar :: (Char -> Answer) -> Answer
02:40:48 <ski>   &c.
02:40:55 <ketil> Cale, this is from the Ubuntu beta, so I should probalby check the bug repository.
02:41:04 <sereven> ketil: that's also shown up for xmonad users when .hi and .o files weren't cleaned between rebuilds mixing different versions. usually between ghc updates IIRC.
02:41:08 <ketil> Baughn, ./Setup.hs build
02:41:11 <ketil> :-)
02:41:13 <Cale> ski: Though perhaps there's a completely different sort of way of specifying what our programs are to do which doesn't let you have that monad directly.
02:41:20 <ski> (and then `main :: Answer -> Answer')
02:41:22 <ketil> sereven, Ah, that's probably it.
02:42:03 <ketil> sereven, goodie, ./Setup.hs clean fixed it.
02:42:08 <sereven> awesome
02:42:24 <ski> Cale : hard to disprove :)
02:42:35 <ronc> I need to lambalize a function
02:42:40 <ronc> lambdalize
02:42:51 <ketil> lambast?
02:43:03 <ski> if the function is `f', then say `\x -> f x'
02:43:10 <ski> presto, you have a lambda expression !
02:43:22 <ronc> mult x y z = x.y.z
02:43:32 <ivanm> anyone know if it's possible to change a document in latex from being twoside to oneside part-way through?
02:43:42 <ski> ronc : do you mean you want to rewrite that to pointless style ?
02:44:06 <Cale> ronc: mult x y z t = (x . y . z) t = x (y (z t))
02:44:09 <ski> ronc : if so, you could ask lambdabot by the `pl' command .. or maybe you want to see how to rewrite it ?
02:44:12 <ronc> ski: I need to rewrite the x.y.z using only lambda
02:44:23 <younder> http://en.wikipedia.org/wiki/Monad_(functional_programming)
02:44:28 <ski> ronc : not even using `x',`y',`z' ?
02:44:47 <ronc> ski: \x -> f (g (h x)) ?
02:45:18 <ivanm> nvm, worked it out
02:45:21 <younder> You seem to think this a diferent approach. I am saying it is hut a permutation of the Monad idiom
02:45:29 <ski> `\x -> f (g (h x))' is not the same as `x . y . z', if that's what you're asking .. (but it is the same as `f . g . h', indeed)
02:45:49 <ronc> ops
02:45:59 <ronc> I change their names, ski :P
02:46:01 <younder> The built in syntax need not be followed no.
02:46:02 <ronc> changed
02:46:04 <Cale> younder: http://www.haskell.org/haskellwiki/Monads_as_Computation
02:46:11 * ski . o O ( `class Idiom i where iret :: a -> i a; iap :: i (a -> b) -> (i a -> i b)' )
02:46:57 <dirotis> this may be the wrong place to ask this, but does anyone here speak German
02:47:11 <ronc> ski: mult f g h = f.g.h is changed into mult f g h = \x -> f (g (h x))
02:47:16 <Cale> younder: But, when I'm talking about IO there, all I mean is that it's not so important that we recognise that it's a monad as the fact that we're representing actions directly as values. Any system which did that would be okay with lazy evaluation. It just happens that most of them turn out to be monads as an afterthought.
02:47:25 <ronc> ski: amirite?
02:47:30 <ski> yes, sir
02:47:39 <ski> (or lady, as the case may be)
02:47:45 <ronc> ^__^ is happy
02:47:45 <Zao> dirotis: Google Translate does.
02:47:48 <ronc> sir
02:48:05 <ski> further, that is equivalent to `mult f g h x = f (g (h x))'
02:48:33 <dirotis> I was actually wondering if the ch is always pronounced like English ch after a consonant: Mdchen, for example
02:48:35 <ronc> nice!
02:48:38 <younder> Cale: Ok, the I agree
02:49:07 <dirotis> but I shall find a German channel for that
02:49:17 <ski> (also, `mult = ((.) .) . (.)', if you prefer that)
02:50:28 * ski wonders why `pl' gives something more complex ..
02:50:47 <ivanm> any of you willing to read through my (updated) draft on SourceGraph for PEPM?
02:50:48 <FunctorSalad> terminology: is a type starting with "forall" considered a monomorphic type? (if all vars in the body are bound)
02:51:03 * ivanm thinks its OK, but wants some of the Haskell stuff explicitly checked
02:51:07 <FunctorSalad> oh wait
02:51:18 <FunctorSalad> obviously it isn't ;)
02:52:16 <ski> if all type variables in the body are bound, one might perhaps call it a "closed type" or a "type combinator"
02:52:39 <ski> (though that sounds somewhat strange in that in one sense, things like `Bool' are also variables)
02:52:45 <ronc> ski: I just wanted to "lambdalize" the function :P
02:52:53 <FunctorSalad> I forgot for a moment that all vars are bound implicitly in haskell
02:53:03 <ronc> stating the function with a lambda expression
02:53:14 <ski> FunctorSalad : not always in GHC, though
02:53:29 <FunctorSalad> ([a] being the same as (forall a. [a]))
02:53:35 <ski>   mult = \f g h x -> f (g (h x))
02:53:54 <younder> If all is now about avoiding having to deal with side effects (monads) what is the point of Haskell?
02:53:55 <FunctorSalad> ski: in the sense that subtrees of the AST can contain free variables, yes
02:53:59 <ski> FunctorSalad : no .. `foo :: [a]' being the same as `foo :: forall a. [a]'
02:54:05 <FunctorSalad> (but a haskell program can't have any FV)
02:54:19 <FunctorSalad> ski: yes I meant that
02:54:28 <younder> Shouldn't you be doing Ocalm or something.
02:54:42 <ski> younder : O'Caml is fine, too
02:54:55 <ronc> ski, is IKEA cheaper in Sweden?
02:55:00 * younder is sarcastically asking
02:55:15 <ski> (ronc : no idea, never been at IKEA)
02:55:35 <ronc> lolwut
02:55:49 <younder> ronc: No It is cheaper in the USA
02:56:06 <ronc> I'm not in the USA :(
02:56:09 <younder> Not tat it has anything to do with Haskell
02:57:04 <ronc> jeez, come on, you have to just talk about Haskell here?
02:57:16 <ski> not only
02:57:34 <ronc> ok, I want to make a 3d engine in Haskell with IKEA furniture being the test objects
02:57:49 <ski> but usually non-haskell-related talk is moved to #haskell-blah (e.g.) if there's actual haskell-related talk atm
02:58:02 <ronc> oh
02:58:18 <ski> (that's imo, others may be stricter or non-stricter)
02:58:35 <ski> (and imo, functional programming is haskell-related :)
03:01:18 <dirotis> what happens if I say data Donkey = Fn Integer String
03:01:26 <dirotis> is Fn a reserved keyword?
03:01:51 <ski> no
03:02:01 <dirotis> also what is the difference between doing data Something = Something1 Something2 and type Something = Something1 Something2
03:02:14 <ski> that creates a datatype `Donkey', *together' with a new constructor `Fn' for the datatype
03:02:37 <ski> the form for `data' is
03:02:47 <ski> (simplifying somewhat)
03:03:10 <ski>   data <type-name> = <constructor-name> <type>*
03:03:21 <ski>                    | ...
03:03:33 <ski> while for `type' you have
03:03:34 <dirotis> what do I do with the constructor
03:03:40 <ski>   type <type-name> = <type>
03:03:45 <en0th> and then you build values of type Donkey using it/its constructors
03:03:47 <ski> in the
03:03:51 <ski>   data Donkey = Fn Integer String
03:04:07 <ski> that creates a `Donkey' type, together with a function (a constructor)
03:04:14 <ski>   Fn :: Integer -> String -> Donkey
03:04:29 <ski> so you use the constructor (`Fn') to construct values of the new data type
03:04:40 <dirotis> so to make a Donkey what do I say? Donkey newDonkey = Fn 5 "Hello"?
03:04:47 <ski> (you can also match on the constructor, applied to arguments)
03:05:04 <Baughn> dirotis: Yep
03:05:04 <ski>   newDonkey = Fn 5 "Hello"
03:05:11 <ski> optionally preceded with
03:05:15 <ski>   newDonkey :: Donkey
03:05:28 <ski> (actually, that type signature doesn't have to be directly preceding)
03:05:41 <dirotis> so I don't have to prefix newDonkey with Donkey?
03:05:45 <ski> if you just want to pass the new donkey to a function, you don't need to name it, though
03:05:51 <ski> dirotis : not at all
03:06:05 <dirotis> Donkey newDonkey = Fn 5 "Hello"? is redundant due to type inferencing?
03:06:06 <ski>   foo (Fn 5 "hello")
03:06:16 <ski> passes a donkey to `foo' without naming it
03:06:32 <ski> dirotis : well, it is wrong haskell syntax
03:06:33 <dirotis> oh I see
03:06:35 <dirotis> thanks ski
03:06:51 <dirotis> which one, the redundant one?
03:07:11 <ski> presumably by `Donkey newDonkey = Fn 5 "Hello"' you mean to make something called `newDonkey' of type `Donkey', which is defined to be `Fn 5 "hello"' ?
03:07:23 <ski> if so, that corresponds to the haskell code
03:07:29 <ski>   newDonkey :: Donkey
03:07:35 <ski>   newDonkey = Fn 5 "hello"
03:07:44 <dirotis> oh ok
03:07:56 <ski> but as you suspected, the `newDonkey :: Donkey' line is (almost always) redundant
03:08:06 <ski> (due to type inference)
03:08:07 <Zao> I name all my creation functions mkDonkey, thanks to some SPJ presentations ages ago.
03:08:19 <dirotis> I see
03:08:21 <dirotis> what?
03:08:26 <dirotis> you name them mkDonkey??
03:08:30 * ski has sometimes named functions `rolig', due to Koen Claessen
03:09:11 <quicksilver> Zao: how do you tell whick mkDonkey is which?
03:09:24 <ski> quicksilver : module prefixing, obviously !
03:10:18 <Zao> :3
03:10:28 <en0th> anyone familiar with the G-Machine?
03:11:32 <ilid> ski: what does 'rolig' mean?
03:11:36 <ski> dirotis : anyway, `type Cat = [([Ingredient],Food -> Satisfaction)]' only names an existing type, it doesn't create a new type .. the two types on the left and on the right of `=' are the same time
03:11:45 <ski> ilid : "funny", in swedish
03:12:07 <ski> dirotis : while `data' always creates a *new* type
03:12:27 <ski> s/time/type/
03:13:01 <ski> (ilid : and incidentally, it means "calm" in danish :)
03:13:02 <data_jepp> Where was that pastebin for haskell?
03:13:23 <ski> @paste
03:13:24 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:14:10 <ivanm> so lambdabot doesn't advocate hpaste proper anymore? :o
03:14:25 <zenzike> does anybody know why kleisli notation got changed from the originally suggested (=>>=) to the ugly (>=>) in Control.Monad?
03:14:31 <ski> @where paste
03:14:32 <lambdabot> http://hpaste.org/new
03:14:32 <ski> @where hpaste
03:14:33 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
03:14:34 <dirotis> ski: when you did [([Ingredient], Food -> Satisfaction)] what is the second part of that tuple ? a function type?
03:14:34 <zenzike> (I'm not trolling, I'm just curious)
03:15:08 <ski> dirotis : yes, the type of functions that consume inputs of type `Food' and produce outputs of type `Satisfaction'
03:15:30 <ski> zenzike : where was `(=>>=)' suggested ?
03:15:56 <zenzike> ski: in the original discussion: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/5412/focus=5412
03:15:57 * ski saw `(>@>)' before `(>=>)' was introduced (i think)
03:16:12 <zenzike> ski: I think it used to be @@
03:16:28 <dirotis> if someone creates the following: type Apple = String
03:16:53 <dirotis> then, data Expression = IntegerExp Int | StringExp Apple
03:17:02 <data_jepp> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=4293#a4293 Still working on my tiny parser, negation of an expression is the problem.
03:17:02 <ski> (.. then `Apple' and `String' is exactly the same type)
03:17:07 <dirotis> what can I do with Expression?
03:17:46 <ski> you can check whether an `Expression' is of the `IntegerExp i' or the `StringExp a' shape
03:18:05 <ski> (where `i :: Int' alt. `a :: Apple', i.e. `a :: String')
03:18:15 <Cale> dirotis: You can make values of it like  IntegerExp 42  and  StringExp "golden", and you can write functions which pattern match values of that type
03:18:24 <ski>   case anExpression of
03:18:25 <Cale> foo (IntegerExp n) = n
03:18:33 <Cale> foo (StringExp x) = length x
03:18:34 <ski>     IntegerExp i -> do something with i
03:18:46 <ski>     StringExp  a -> do something with a
03:18:57 <dirotis> I see, and due to the name of the constructor it will inference the type ?
03:19:15 <ski> s/inference/infer/, but yes
03:19:41 <dirotis> whoops
03:19:50 <ski> np
03:19:58 <dirotis> cool , thanks
03:21:15 <ski> zenzike : well, i saw `(>@>)' in the craft way before that was posted :)
03:21:46 <ski> (mayhaps Cale recalls whether `@@' came from somewhere else ?)
03:22:54 <dirotis> if someone makes f (x,y) = let z = 2 * x in z + y, is this any different than simplifying to f(x,y) = 2 * x + y
03:23:11 <ski> no
03:23:35 <zenzike> ski: that makes sense. I'm glad it's not *that* anymore! I just happened to use (=>>=), and didn't realise that it was already defined as (>=>).
03:23:38 <ilid> >=> is pleasantly similar to >>>
03:24:01 <ski> (but if `z' were used more than once, there might be performance differences)
03:24:18 <ski> zenzike : "it's not *that*" what ?
03:24:39 <zenzike> ski: sorry, I was saying I'm glad it's not >@> anymore :)
03:24:46 <ski> .. oh
03:25:01 * ski preferred/prefers `>@>' for some reason
03:25:17 <ski> (probably irrational and/or unexplicable)
03:25:18 <zenzike> hehe. this is why syntax tzars are a good idea
03:25:51 <ski> well, there's more important and less important matters in syntax
03:26:16 <ski> imo, using `<*>' for `ap' in `Applicative' is just plain bad :)
03:26:16 <quicksilver> ski: '@' screams application to me, and this isn't a kind of application.
03:26:20 <zenzike> yup. and I guess this is one of those don't care situations. again, I was just curious
03:26:44 <zenzike> ski: very true. I would have swapped <$> and <*>
03:26:54 <zenzike> since $ is ap anyway
03:27:03 <ski> `<$' or `<@' would be better
03:27:26 <zenzike> ski: why asymetry?
03:27:32 <ski> because of the type
03:27:36 <ski> @type (<*>)
03:27:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:27:51 <ski> `f (a -> b)' is not symmetric to `f a'
03:28:07 <ski> `<*>' to me suggests a type `f a -> f b -> f (a,b)'
03:28:20 <ski> (or something in the same vein)
03:28:23 <zenzike> hmm. I see what you mean. not sure why it feels ik to be asymmetric. probably just e beging wierd
03:28:41 <zenzike> *me being
03:29:53 <idnar> in that case, <$> is also "wrong"
03:30:03 <ski> of course :)
03:30:06 <idnar> so is $, I guess
03:30:10 <ski> (and `<**>' is even worse)
03:31:07 <ski> `$' is usually shown as an assymetric glyph .. while the `<' and `>' in `<$>' catches the eye, suggesting some kind of symmetry (in my eyes)
03:31:52 <ski>   (<*) :: f (a -> b) -> f a -> f b
03:31:57 <zenzike> ski: $ is shown as asymmetric? what do you mean by that?
03:32:01 <ski>   (*>) :: f a -> f (a -> b) -> f b
03:32:13 <ski> would be fine to me, by this criteria
03:32:38 <yitz> ski but that's not analagous to $> and <$
03:32:45 <ski> zenzike : if you flip the `$' glyph left-to-right, you don't get back the same glyph
03:33:26 <zenzike> ski: ah. I guess we never see the flipped version so I consider it symmetric.
03:33:39 <ski> (obviously `<$' would have to be changed, too .. maybe to `<$_' or something)
03:33:50 <quicksilver> not legal, I'm afraid
03:33:53 <quicksilver> but I take the point.
03:34:22 * ski checks what he used some time ago
03:34:32 <quicksilver> > let (<$_) = (++) in "This " <$_ "is not legal syntax"
03:34:33 <lambdabot>   <no location info>: Parse error in pattern
03:36:04 <Beelsebob> I think I would use ^$ for <*> and ^* for <$> given the choice
03:36:11 <Beelsebob> "lifted application"
03:38:00 <zenzike> Beelsebob: hmm. yeah, I kinda like that too
03:40:56 <quicksilver> they are both lifted application in different senses though
03:41:13 <quicksilver> I thikn I'd come up with something like @> and @@>
03:41:17 <quicksilver> (or $> and $$>)
03:42:45 <Beelsebob> one could argue for $^ for fmap and ^$^ for ap
03:42:54 <Beelsebob> showing which arguments are lifted
03:44:48 <dirotis> what type is Set.Set String
03:44:55 <dirotis> using this library: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
03:45:02 <Beelsebob> it's... a set of strings?
03:45:15 <dirotis> What does Set.Set mean
03:45:22 <dirotis> I don't see any function called Set there
03:45:32 <Beelsebob> it means the data type Set, from the module Set
03:45:32 <ski_> the type `Set' from the module named `Set'
03:46:14 <Raevel> they have imported Set using import qualified Set, meaning everything in Set is available as Set.x
03:47:21 <dirotis> oh I see
03:47:26 <dirotis> what is with the mass exodus of users
03:47:46 <Raevel> netsplit, some freenode server has problems
03:48:53 <yitz> dirotis: it probably actually means Data.Set.Set, after "import qualified Data.Set as Set".
03:49:21 <dirotis> oh ok
03:49:28 <dirotis> thank you
03:55:43 * SamB_XP wonders what the opposite of exodus is
03:55:47 <dirotis> if I have a tuple ("hello","goodbye")
03:55:56 <dirotis> to put it into a set, how do I do this
03:56:00 <opqdonut> SamB_irssi: coexodus
03:56:00 <dirotis> as separate elments
03:56:25 <dirotis> can I chain things
03:56:32 <dirotis> like
03:56:32 <SamB_XP> opqdonut: dual != opposite
03:56:34 <dirotis> Set.Set.insert
03:56:40 <opqdonut> dirotis: let x = ("hello","goodbye") in insert (fst x) . insert (snd x) $ set
03:56:54 <opqdonut> remember, insert returns the modified set
03:56:58 <yitz> dirotis: it's easier if they're in a list
03:56:58 <opqdonut> you can then use it again
03:57:32 <dirotis> what is the $ sign
03:57:32 <yitz> > let x = ("hello","goodbye") in insert (fst x) . insert (snd x) $ set
03:57:34 <lambdabot>   Not in scope: `set'
03:57:37 <ski> @src $
03:57:37 <lambdabot> f $ x = f x
03:57:44 <yitz> > let x = ("hello","goodbye") in insert (fst x) . insert (snd x) $ S.empty
03:57:46 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
03:57:46 <lambdabot>         against inferred ...
03:57:52 <ski>   insert (fst x) . insert (snd x) $ set  =  (insert (fst x) . insert (snd x)) set
03:58:39 <ski> dirotis : so `$' is just function application (with low precedence)
03:58:49 <yitz> > let x = ("hello","goodbye") in insert (fst x) . insert (snd x) $ Data.Set.empty
03:58:50 <opqdonut> dirotis: f . g . h $ k === f (g (h k))
03:58:51 <lambdabot>   Not in scope: `Data.Set.empty'
03:59:28 <dirotis> $ has lower precedence than .   ?
03:59:34 <British0zzy> is there a function that returns the largest member of a list?
03:59:40 <yitz> @type S.empty
03:59:42 <lambdabot> forall a. S.Set a
03:59:51 <FunctorSalad> hmm I accidentally the ghc-src tarball and wondered why installation takes so long ;)
04:00:00 <ski> > let x = ("hello","goodbye") in S.insert (fst x) . S.insert (snd x) $ S.empty
04:00:01 <lambdabot>   fromList ["goodbye","hello"]
04:00:02 <FunctorSalad> British0zzy: maximum
04:00:08 <yitz> ahh
04:00:16 <ilid> i like <$> and <*>. $ because it's just application (under a functor), and * because it's joining / sequencing / multiplying effects
04:00:16 <yitz> > let x = ("hello","goodbye") in S.insert (fst x) . S.insert (snd x) $ Data.Set.empty
04:00:17 <lambdabot>   Not in scope: `Data.Set.empty'
04:00:19 <British0zzy> of course...
04:00:27 <yitz> > let x = ("hello","goodbye") in S.insert (fst x) . S.insert (snd x) $ S.empty
04:00:28 <lambdabot>   fromList ["goodbye","hello"]
04:00:32 <yitz> yay
04:00:55 <ski> (ilid : so why not `(<*>) :: Applicative i => i a -> i b -> i (a,b)', then ?)
04:01:30 <dirotis> yitz why did you do $ at the end instead of .
04:01:47 <dirotis> it's not the same here?
04:01:47 <ski> dirotis : because `S.empty' is not a function
04:01:54 <ski> it's never the same
04:01:57 <Jafet> . is function composition, $ is application
04:02:05 <dirotis> oh
04:02:06 <Jafet> Blame ascii for this
04:02:13 <ilid> ski: that'd be reasonable but much less useful. a -> b -> (a,b) and (a->b) -> a -> b are both sensible ways of combining two values, and the latter is more general, so...
04:02:20 <yitz> dirotis: the . combines two functions to make another function. The $ applies a function to a value. $ is lower precedence than .
04:02:26 <ski> `f . g $ x' is the same as `f $ g $ x', that doesn't mean `f . g' is the same as `f $ g'
04:02:47 <ski> the former is `(f . g) $ x', while the latter is `f $ (g $ x)'
04:03:02 <ilid> ski: <*$> or <$*> both seem fine though
04:03:26 <dirotis> what is the point of using $ instead of putting a space?
04:03:38 <FunctorSalad> @let pair x y = (,) <$> x <*> y
04:03:39 <lambdabot>  Defined.
04:03:41 <FunctorSalad> @type pair
04:03:42 <ski> ilid : actually they are inter-expressible
04:03:42 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => f a -> f a1 -> f (a, a1)
04:04:12 <FunctorSalad> @let apply f x = ($) <$> pair f x
04:04:13 <lambdabot>  <local>:2:20:
04:04:13 <lambdabot>      Couldn't match expected type `a -> b'
04:04:13 <lambdabot>             against...
04:04:24 <pao> I remember I've seen TH used for defining Binary instances...
04:04:29 <ski> uncurry
04:04:34 <pao> can anyone point me to some doc?
04:04:44 <SamB_XP> pao: TH has been used to define a lot of instances!
04:04:52 <ski> @let apply f x = uncurry ($) <$> pair f x
04:04:53 <lambdabot>  Defined.
04:04:58 <ski> @type apply
04:04:59 <lambdabot> forall (f :: * -> *) b b1. (Applicative f) => f (b -> b1) -> f b -> f b1
04:05:02 <FunctorSalad> ski: doh you're right :)
04:05:02 <SamB_XP> @google Derive Haskell
04:05:03 <lambdabot> http://hackage.haskell.org/package/derive
04:05:04 <lambdabot> Title: HackageDB: derive-2.0.1
04:05:17 <SamB_XP> pao: look around there, perhaps ?
04:05:19 <FunctorSalad> anyway, that was @ilid (<*> isn't really more general)
04:05:19 <ski> ilid : see ^; interdefinable
04:05:26 <pao> SamB_XP: thanks for the pointer
04:05:29 <ski> @ilid
04:05:30 <lambdabot> Maybe you meant: bid id
04:05:49 <SamB_XP> pao: quite welcome ;-)
04:06:07 <dirotis> so function x y is the same as function $ (x y)
04:06:10 <ski> no
04:06:12 <pao> SamB_XP: that is exactly what I was looking for
04:06:12 <SamB_XP> hmm, I suppose I could just have done @hackage derive
04:06:24 <dirotis> I thought it was function application?
04:06:33 <ski> dirotis : it expresses (almost) the same thing, though .. but in different ways
04:07:18 <ski> dirotis : in the first case, `function' is a function that takes `x' as argument and returns a function that takes `y' as argument (so then `function' is aka a curried function)
04:07:45 <ski> dirotis : in the second case, `function' is a function that takes a pair as single argument .. that pair is here the pair of `x' and `y'
04:08:01 <ski> the type of `function' in the two cases are different
04:08:19 <ski>   function :: X -> Y -> Z  -- in first case .. this is same as `X -> (Y -> Z)'
04:08:32 <zenzike> dirotis: did you mean f $ x y = f (x y)?
04:08:36 <ski>   function :: (X,Y) -> Z   -- in second case
04:08:48 <SamB_XP> freaky trivia: (\x y -> f x y) is apparently different from (\x -> \y -> f x y) in some way ...
04:09:01 <FunctorSalad> SamB_XP: oh no! why?
04:09:10 <dirotis> I see
04:09:10 <SamB_XP> something to do with _|_
04:09:11 <FunctorSalad> is it this evil seq again?
04:09:18 <dirotis> zenzike, is that a true statement
04:09:19 <ski> SamB_XP : only if `y' was a refutative pattern, iirc ?
04:09:28 <zenzike> dirotis: yup
04:09:40 <British0zzy> is there anyway to avoid a stack overflow in this expression? maximum $ map (3+) [1..1000000]
04:09:46 <dirotis> ok, that makes sense
04:10:18 <zenzike> dirotis: I find it helps to think of $ as extend brackets right, as far as you can
04:10:29 <FunctorSalad> British0zzy: foldl1' max $ map (3+) [1..1000000]
04:10:31 <ski>      foo $ ...
04:10:35 <FunctorSalad> @type foldl1'
04:10:35 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
04:10:37 <ski>   =  foo (...)
04:10:45 <FunctorSalad> @type maximum'
04:10:46 <lambdabot> Not in scope: `maximum''
04:11:03 <FunctorSalad> >  foldl1' max $ map (3+) [1..1000000]
04:11:04 <lambdabot>   1000003
04:11:20 <British0zzy> so maximum was too lazy?
04:11:31 <FunctorSalad> British0zzy: apparently. surprises me a bit too
04:11:49 <SamB_XP> me also, a bit
04:11:54 <SamB_XP> I mean, sure sum and product are
04:11:56 <British0zzy> is there a way to tell haskell that one of it's arguments is strict
04:12:25 <ski>   foo x !y z = ..x..y..z..
04:12:26 <SamB_XP> British0zzy: yes, but it doesn't work on buried recursion patterns
04:12:33 <British0zzy> ah
04:13:21 <FunctorSalad> > maximum (\(!x) (!y) -> max x y) $ map (3+) [1..10^6]
04:13:22 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
04:13:26 <FunctorSalad> :p
04:13:41 <dirotis> ok thanks
04:13:58 <FunctorSalad> > maximum (\x y -> x`seq`y`seq`max x y) $ map (3+) [1..10^6]
04:13:59 <lambdabot>   The lambda expression `\ x y
04:13:59 <lambdabot>                             -> x `GHC.Prim.seq...
04:14:04 <ski> , maximum (\(!x) (!y) -> max x y) $ map (3+) [1..10^6]
04:14:05 <lunabot>  luna: The lambda expression `\ (!x) (!y) -> GHC.Classes.max x y'
04:14:16 * ski nods slowly
04:14:21 <FunctorSalad> (that probably isn't equivalent to the foldl1' version though)
04:14:27 <zenzike> @src foldl1'
04:14:28 <lambdabot> Source not found. You type like i drive.
04:14:33 <FunctorSalad> *confused*
04:14:37 <ski> (anyway, this wouldn't help here, in this case)
04:15:04 <SamB_XP> lunabot: what about the lambda expression ?
04:15:13 <FunctorSalad> @src maximum
04:15:13 <lambdabot> maximum [] = undefined
04:15:13 <lambdabot> maximum xs = foldl1 max xs
04:15:26 <ski> SamB_XP : just the lambda expression. don't you see ?
04:15:34 <Alpounet> heh
04:15:51 <ski> @yow
04:15:52 <lambdabot> Couldn't find fortune file
04:15:53 <SamB_XP> ski: I'm thinking it was going to say something about a type error, maybe ?
04:15:55 <FunctorSalad> hmm with foldr it would help I think
04:16:43 <SamB_XP> foldr isn't how to do maximum
04:16:59 <FunctorSalad> but foldr with a strict max?
04:17:11 <SamB_XP> no
04:17:27 <ski> > foldr min infinity [5,7,1,4,2,8,infinity]
04:17:28 <lambdabot>   1
04:17:36 <SamB_XP> it'll blow the stack a different way
04:17:51 <FunctorSalad> foldr1 max' (x:xs) = max' x (foldr1 max' xs)
04:18:33 <British0zzy> what are good ways to memoize a function in haskell?
04:18:34 <FunctorSalad> ahh it is strict but not a tail-call?
04:21:07 <ski> ?
04:22:04 <SamB_XP> > infinity
04:22:05 <lambdabot>   * Exception: stack overflow
04:22:10 <SamB_XP> :t infinity
04:22:11 <lambdabot> Natural
04:22:41 <trzkril> @src Natural
04:22:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:22:50 <FunctorSalad> > infinity > 1
04:22:51 <lambdabot>   True
04:23:07 <FunctorSalad> peano naturals, presumably
04:23:36 <trzkril> > infinity + infinity == infinity
04:23:40 <lambdabot>   mueval-core: Time limit exceeded
04:23:50 <ski>   infinity = fix succ  -- iirc
04:24:04 <ski> > min 3 infinity
04:24:05 <lambdabot>   3
04:24:16 <Jafet> > infinity == fix succ
04:24:22 <lambdabot>   mueval: ExitFailure 1
04:24:32 <ski> obviously it is not observable :)
04:24:50 <ski> > infinity /= 5
04:24:51 <lambdabot>   True
04:26:02 <ziman> > let inf = succ inf in min 3 inf
04:26:05 <lambdabot>   mueval-core: Time limit exceeded
04:26:20 <ziman> > let inf = inf+1 in min 3 inf
04:26:24 <lambdabot>   mueval-core: Time limit exceeded
04:26:25 <Jafet> I can hear Cantor rolling
04:26:33 <trzkril> > min 3 (1 + infinity)
04:26:33 <lambdabot>   3
04:26:56 <trzkril> :t min
04:26:57 <lambdabot> forall a. (Ord a) => a -> a -> a
04:27:18 <FunctorSalad> > let inf = succ (inf::Natural) in min 3 inf -- ziman
04:27:19 <lambdabot>   3
04:27:30 <ziman> ah
04:27:45 <ziman> > let inf = fix succ :: Natural in min 3 inf
04:27:46 <lambdabot>   3
04:29:18 <dirotis> I have a function that returns the set of FreeVariables given an expression: freeVariables :: Exp -> Set.Set String    ... what should I do for example if I get a conditional expression? Like, freeVariables x = case x of Cond exp1 exp2 exp3 -> ??
04:31:24 <FunctorSalad> dirotis: union
04:31:29 <en0th> ( is there an Integer version of drop ?)
04:31:29 <BarackHusseinOba> dirotis: union
04:31:33 <FunctorSalad> free variables is a static notion
04:31:38 <BarackHusseinOba> free variables is a static notion
04:31:49 <FunctorSalad> @where ops
04:31:49 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:31:54 <BarackHusseinOba> @where ops
04:31:55 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:32:15 <dirotis> why is that guy repeating everything
04:32:23 <BarackHusseinOba> why is that guy repeating everything
04:32:48 <dirotis> so I do, Set.union exp1 . Set.union exp2 $ Set.union exp 3 ?
04:32:53 --- mode: ChanServ set +o dibblego
04:32:53 <BarackHusseinOba> so I do, Set.union exp1 . Set.union exp2 $ Set.union exp 3 ?
04:33:06 --- kick: BarackHusseinOba was kicked by dibblego (dibblego)
04:33:11 <dirotis> haha
04:33:15 <SamB_XP> I guess he wants someone to say "Barack Hussein Obama is a jerk"
04:33:21 <SamB_XP> but I'm not going to actually say it
04:33:34 <SamB_XP> especially considering he was over the nick length limit!
04:33:35 --- mode: dibblego set -o dibblego
04:34:05 <en0th> is there an Integer version of drop, like genericdrop
04:35:48 <dcoutts> @hoogle genericdrop
04:35:49 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
04:36:24 <en0th> woot, thanks
04:36:42 <dcoutts> en0th: you can look this stuff up in ghci
04:37:25 <en0th> is there a way to search?
04:42:09 <ivanm> is that the same repeating guy from yesterday?
04:42:18 <dcoutts> en0th: there's :browse Module
04:42:26 <dcoutts> en0th: and there's tab completion
04:42:33 <dcoutts> and :i name
04:42:41 <dcoutts> eg:
04:42:43 <dcoutts> :i Data.List.genericDrop
04:42:43 <dcoutts> Data.List.genericDrop :: (Integral i) => i -> [a] -> [a]
04:42:43 <dcoutts>   	-- Defined in Data.List
04:43:35 <en0th> ok, thanks again.
04:43:39 <dcoutts> en0th: or if I loaded the Data.List module and did, :i generic<tab> it'll list the completions
04:44:03 <dcoutts> en0th: for full search you can install hoogle locally
04:44:59 <SamB_XP> (but then you need to makes sure you've got the hoogle databases installed ...)
04:45:16 <en0th> oh. now i notice hoogle is a website.
04:46:47 <en0th> anyways, i've wrote down the mark1 g-machine from spj book and it seems to work. hooray
04:51:02 <int-e> dph question, am I doing anything stupid here? I see a massive slowdown when going from 2 workers to 3 workers. This is expected to some extend with only 2 cores, but I didn't expect an order of magnitude difference. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10521#a10521
04:52:40 <int-e> (will be afk for a bit, I'll read any responses later)
04:58:25 <quicksilver> int-e: subtle cache effect?
04:58:31 <quicksilver> int-e: although when I say "subtle"....
04:58:45 <quicksilver> I mean, subtle to comprehend, not subtle to observe.
04:59:31 <PeakerWork> en0th: The Hayoo! website has hoogle databases for a lot more libraries
05:02:02 <en0th> bookmarked!
05:04:51 <dirotis> gr Gott!
05:07:04 <ivanm> PeakerWork: does it? I thought they had their own database format...
05:09:13 <int-e> quicksilver: I found the culprit - it's the parallel GC.
05:09:39 <int-e> quicksilver: and that makes sense - it's designed with the assumption that all workers are running in parallel
05:12:06 <jkramer> Hello
05:12:25 <jkramer> What can I do when a module is found in multiple packages and ghc refuses to compile?
05:13:10 <ivanm> jkramer: which package is this?
05:13:18 <ivanm> jkramer: I take it this is a non-cabal compilation?
05:13:54 <quicksilver> int-e: the degree of pain it causes is still surprising, I think
05:14:13 <quicksilver> int-e: I imagine JaffaCake (or his proxy, glasgow-haskell-users) would appreciate a report on the effect
05:14:25 <jkramer> ivanm: It's Control.Monad.State, and its found in moads-fd and in mtl
05:14:40 <ivanm> jkramer: yes, but what are you trying to build? gtk2hs?
05:15:06 <jkramer> I'm trying to compile a simple test program the demonstrates Control.Monad.State :)
05:15:12 <jkramer> *that
05:15:22 <ivanm> jkramer: simple method: "ghc-pkg hide <whichever you don't want>"
05:15:27 <ivanm> then after you're done, expose it
05:15:35 <jkramer> But which one is the right one?
05:15:40 <ivanm> better solution: write a .cabal file and use cabal-install
05:15:49 <ivanm> jkramer: which Control.Monad.State are you demonstrating? ;-)
05:15:59 <ivanm> how am _I_ supposed to know which you want?
05:16:08 <jkramer> ivanm: I only know one :)
05:16:21 * ivanm guesses mtl
05:16:28 <jkramer> Sorry, I'm pretty new to Haskell and just playing around with the modules
05:16:43 <jkramer> http://dpaste.com/103819/ - this is what I'm trying to build
05:16:46 <ivanm> jkramer: which documentation are you reading that you're playing with Control.Monad.State
05:16:48 <ivanm> ?
05:17:09 <ivanm> jkramer: probably mtl
05:17:18 <ivanm> jkramer: note that doubleState = modify (*2)
05:17:29 <ivanm> and get >>= return looks redundant
05:17:34 <ivanm> (just use get)
05:17:49 <ivanm> I also don't think that'll typecheck...
05:18:04 <ivanm> main is IO, stateFun is (Num a) => State a
05:18:12 <ivanm> well, State a a
05:20:26 <hackagebot> bindings-common 1.3 - Preprocessor combinator library for low level FFI. (BasVanDijk)
05:20:28 <hackagebot> bindings-posix 1.2 - Low level bindings to posix. (BasVanDijk)
05:20:30 <hackagebot> bindings-libusb 1.3 - Low level bindings to libusb. (BasVanDijk)
05:20:32 <hackagebot> usb 0.2 - Communicate with USB devices (BasVanDijk)
05:20:39 <jkramer> ivanm: The hide-thing worked, thanks
05:20:53 <ivanm> jfredett: OK, can't just blame _me_ for all the new releases on hackage ;-)
05:21:03 <ivanm> jkramer: just remember to re-expose it once you're done
05:21:12 <jkramer> Yup
05:34:29 <dayz> hi
05:35:28 <kowey> hi all, does Magnus Therning hang out on IRC at all?
05:35:35 <ivanm> sometimes, I think...
05:35:38 <ivanm> but I forget his nick :s
05:37:45 <dayz> i have a slightly out-of-topic question: if i have a FOL formula like \all x:S \exists y:T, F. F(x,y) and i have an axiom that \all x:Child, \exists y:Mother. Mother(x,y) is the latter a 'model' of the former? or is it an 'instantiation' or something else?
05:37:58 <data_jepp> Im reading about parsec, and it says its an combinator parser? whats combinator?
05:38:12 <ivanm> dayz: no idea what you're saying, sorry... try #maths
05:38:28 <ivanm> data_jepp: combinator == combine different sub-chunks using nice easy to use functions
05:38:32 <ivanm> something like that, anyway ;-)
05:40:19 <kowey> email it is, thanks!
05:40:31 <Cale> dayz: Isn't that second order logic?
05:40:52 <Cale> Well, I suppose it can be formalised in FOL anyway
05:41:03 <data_jepp> ivanm: thanks
05:41:47 <dayz> Cale, sorry, yes it is second order.
05:41:50 <data_jepp> Can I use parsec to evaluate code aswell?
05:41:59 <ivanm> data_jepp: no
05:42:15 <ivanm> not if you mean arbitrary haskell code, anyway
05:42:18 <poe> maybe using ParsecT
05:42:21 <ivanm> there is only limited support for evaluating parsed code; see mueval, etc.
05:42:33 <data_jepp> ivanm: and the point is to print out a syntax tree
05:42:44 <ivanm> data_jepp: is this for Haskell code?
05:42:45 <data_jepp> ok
05:42:53 <dayz> Cale, so would you say instantiating F to MotherOf etc. makes the latter a 'model' of the former?
05:43:01 <data_jepp> No, a tiny language defined in my homework task.
05:43:11 <ivanm> data_jepp: if you write your own interpreter then of course you can evaluate code!
05:43:29 <Cale> dayz: If S, T, and F can be treated as free variables, then the axiom is an instantiation of that first formula.
05:44:12 <data_jepp> ivanm: but would the interpeter and the parser be to different large functions?
05:44:21 <ivanm> data_jepp: probably, yes
05:44:31 <ivanm> parse to an AST, then run your "interpreter" on the AST
05:44:31 <data_jepp> omg I hate this task
05:44:35 <ivanm> heh
05:44:43 <data_jepp> Its so hard.
05:44:50 <data_jepp> ivanm: parsec can print out an AST?
05:45:36 <dayz> Cale, right. but can it not be a model of the first formula? to instant F to MotherOf, it needs to verify whether the constraints on the arguments hold, i.e. \all x:S, \exists y:T
05:45:40 <ivanm> data_jepp: not by itself
05:45:54 <ivanm> data_jepp: you use parsec to parse the code into your own data structure; in this case an AST
05:46:11 <ski> dayz : is `F' existentially quantified in the former ?
05:46:24 <dayz> ski, yes that's right
05:46:37 <opqdonut> that's not FOL then
05:46:45 <data_jepp> Could I use a tree structure, and then use some sort a 2d library for printing?
05:47:07 <ivanm> data_jepp: see graphviz for creating a tree-like structure
05:47:12 <dayz> opqdonut, it should be HOL
05:47:13 <data_jepp> ivanm: ok
05:47:19 <ivanm> either create your own custom graph conversion functions, or use FGL
05:47:23 <ivanm> *shameless plug* :p
05:47:29 <ski> (or both !)
05:47:43 <dayz> i'm just not sure with the terminology.. what makes an instantiation a 'model'
05:48:06 <ski> usually, a `model' is taken to be a semantic object of a certain kind
05:48:47 <ski> (so since this is about the syntax, i wouldn't use `model' here .. not sure what word to use, though)
05:49:29 <dayz> ski, but are there no semantics involved here? there are constraints on what arguments F can take.
05:49:38 <Cale> Yeah, normally a model is something like an assignment of sets and functions and predicates to the various basic elements of a language such that a particular set of axioms is satisfied.
05:50:36 <Cale> You could try to say that any model of the more specific axiom will be a model of the more general one, though formalising that requires some higher order stuff, because you're existentially quantifying over sets and functions.
05:50:56 <dayz> right. so if i have a set of axioms, then an instantiation that satisfies these axioms would be a 'model'?
05:50:57 <ski> (and why is `Mother' used both as a domain and as a relation ?)
05:51:23 <ski> dayz : what do you mean by `instantiation', here ?
05:51:29 <dayz> ski, sorry, it's MotherOf for the function
05:51:42 <dayz> typo
05:52:11 <Cale> dayz: Let's just stick to first order logic for the moment. In a first order language, you have some set of constant symbols, you have some function symbols, and you have some relation symbols.
05:52:24 <dayz> Cale, yeah
05:52:35 <Cale> dayz: A model of a set of first order axioms over some language consists of:
05:52:48 <Cale> 1) A set over which all quantifiers are taken to quantify over.
05:53:01 <Cale> 2) For each constant symbol c, an element of that universe set.
05:53:19 <Cale> 3) For each function symbol f, a set function U -> U
05:53:48 <Cale> 4) For each n-ary relation symbol R, an appropriate subset of U^n representing that relation.
05:54:04 <ski>    (usually one would say a function `f : U^n -> U' if the arity of `f' is `n')
05:54:14 <Cale> oh, sure, yes :)
05:54:37 <data_jepp> damit, were did we paste code again?=
05:54:43 <Cale> Such that all the axioms are satisfied when treated as statements about the corresponding sets, functions, and relations
05:54:48 <Cale> @hpaste
05:54:48 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:54:54 <Cale> er
05:54:56 <Cale> @where hpaste
05:54:57 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
05:55:04 <Cale> the first one, usually :)
05:55:17 <ski> @where paste
05:55:17 <lambdabot> http://hpaste.org/new
05:55:27 <Cale> dayz: So a model isn't really a statement, but all this other structure.
05:55:40 <dayz> hmm
05:56:20 <data_jepp> Noob error here, check if a char is between A-Z and only uppercase: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4294#a4294
05:57:05 <Cale> data_jepp: looks like you want a guard, rather than a where clause
05:57:52 <Cale> data_jepp: maybe   parseExpr (x:s) | (x >= 'A' && x <= 'Z') = (Var x, s)
05:58:51 <en0th> how do i apply f :: String -> String to x :: IO String?
05:58:52 <data_jepp> Cale: :D Thanks
05:59:04 <en0th> do i have to lift f ?
05:59:49 <ski> `liftM f' or `fmap f' probably
06:00:09 <ilid> data_jepp: can you use isUpper? (or are you the person from yesterday who can't use Prelude functions for some reason?)
06:00:19 <ski> (or possibly `(f =<<)' in case `f' returns an `IO'-action)
06:00:35 <Cale> en0th: yeah, or run the IO String first, and use f on its result
06:00:42 <ski> (.. which i can see it doesn't)
06:00:52 <Cale> do v <- x; ... f v ...
06:01:08 <en0th> okay
06:02:39 <hackagebot> estreps 0.3.1 - Repeats from ESTs (KetilMalde)
06:03:39 <FunctorSalad> , src 'SigD
06:03:41 <lunabot>  data Dec = ... | SigD Name Type | ...
06:03:41 <lunabot>  infixl 9
06:03:54 <FunctorSalad> oh nvm it's a signature decl
06:04:18 <dayz> Cale, according to http://en.wikipedia.org/wiki/Structure_(mathematical_logic) rational numbers are models of fields (\sigma-structures) but why? fields only has two binary functions + and *.
06:04:26 * ski wonders how `x,y :: Int' is expressed with `Dec'
06:04:33 <dayz> and a -
06:05:28 <int-e> dayz: rational numbers with the usual addition, multiplication, negation and inverse form a field.
06:05:38 <FunctorSalad> , [d| x,y::Int |]
06:05:39 <lunabot>  luna: The type signature for `y' lacks an accompanying binding
06:05:49 <FunctorSalad> , [d| x,y::Int; x=1; y=1 |]
06:05:50 <Cale> dayz: rational numbers have a + and * and - as well.
06:05:50 <lunabot>  SigD y (ConT Int)
06:05:50 <lunabot>  SigD x (ConT Int)
06:05:50 <lunabot>  ValD (VarP x) (NormalB (LitE (IntegerL 1))) []
06:05:55 <int-e> dayz: oh and the constants 0 and 1.
06:06:00 <FunctorSalad> lol didn't expect that to work
06:07:11 <dayz> but the signature of rational numbers is larger than that of fields. that's ok?
06:07:46 <Cale> dayz: eh?
06:07:54 <FunctorSalad> dayz: in this view the rationals don't *have* any signature. signatures are syntactic
06:07:59 <FunctorSalad> the rationals are a semantic thing here
06:08:01 <Cale> dayz: The rational numbers here are just a particular set
06:08:20 <Cale> dayz: and the interpretations of + and * are functions on that set
06:09:13 <Cale> The only signature we're talking about here is the signature for fields.
06:09:26 <dayz> right
06:09:32 <Cale> Which is (0,1,-,+,*)
06:09:49 <int-e> (why is there a - but no ^-1?)
06:10:00 <Cale> Well, good question.
06:10:14 <FunctorSalad> you don't need either
06:10:29 <int-e> right, and you don't actually need 0 or 1.
06:10:39 <Cale> I believe that's because ^-1 doesn't have full domain.
06:10:41 <FunctorSalad> (but a symbol is more convenient than an existential q)
06:10:55 <Cale> So you'd need to get more careful about your definition of interpretation.
06:10:56 <FunctorSalad> ahhh partiality :D
06:11:03 <int-e> right, that makes sense
06:11:12 <Cale> But yeah, you don't really need - to be there
06:11:41 <hackagebot> xsact 1.7.2 - Cluster EST sequences (KetilMalde)
06:12:05 <FunctorSalad> (partiality is quite evil if you don't want to sweep it under the rug)
06:12:28 <FunctorSalad> (in dependent-type based systems your terms are suddenly cluttered with proof terms)
06:13:58 <Cale> dayz: So, is this starting to make sense?
06:14:02 <int-e> > iterate (\x -> (x + 2) / (1 - 2*x)) 1 :: [Rational]
06:14:03 <lambdabot>   [1 % 1,(-3) % 1,(-1) % 7,13 % 9,(-31) % 17,3 % 79,161 % 73,(-307) % 249,191...
06:14:34 <ilid> > iterate (\x -> (x+1) / (1-2*x)) 1 :: [CReal]
06:14:38 <lambdabot>   mueval-core: Time limit exceeded
06:14:39 <int-e> (challenge: prove that all elements of that sequence are defined)
06:14:58 <Cale> dayz: Your interpretation of a statement in the language of fields in this model will be a statement about the set Q which is true or false depending on its status in, say, ZFC.
06:15:11 <Cale> (or whatever set theory you'd like to be using)
06:15:42 <hackagebot> rbr 0.8.5 - Mask nucleotide (EST) sequences in Fasta format (KetilMalde)
06:17:43 <hackagebot> xml2x 0.4.2 - Convert BLAST output in XML format to CSV or HTML (KetilMalde)
06:17:49 <dayz> hmm
06:19:10 <Cale> dayz: There are statements in the language of fields which will be true in some fields but not for all of them, such as  exists x. x * x = 1 + 1
06:19:24 <Cale> That one will be false in Q, but true in the real numbers, for example.
06:19:50 <ilid> int-e: if 1-2x == 0, then on the previous iteration, x == 1/2. on the iteration before that, x = 3/4. on the iteration before that, x = -1/2. and on the iteration before that, 5 = 0 ;-)
06:20:16 <EnglishGent> what do people think of this? (it's not mine, but I've had thoughts along similar lines)
06:20:20 <EnglishGent> http://eigold.tripod.com/papers.html
06:20:44 <hackagebot> korfu 0.1.1 - The Korfu ORF Utility (KetilMalde)
06:20:54 <quicksilver> Cale, int-e : on signature minimality - there is considerable flexibility in replacing signature elements with axioms and vice versa, and I think one aims more for clarity that any specific kind of minimality.
06:22:04 <dayz> Cale, i guess i'll need to read more on it
06:22:06 <dayz> thanks a lot
06:23:02 <Cale> quicksilver: right
06:23:53 <Cale> EnglishGent: What do we think of all of E. Goldberg's papers and talks?
06:24:06 <int-e> ilid: 3/4 should be -3/4. but actually, there's an argument like that which works.
06:24:36 <quicksilver> Cale: I was going to ask you but you weren't around - is there a name for the inverse to the operation (\n -> n ^ n) ? I couldn't find one but it's very hard to google.
06:26:17 <Cale> quicksilver: Well, it's possible to write it in terms of the Lambert W function.
06:26:27 <quicksilver> I'm sure somebody somewhere must have given it a name :)
06:26:44 <int-e> ilid: the trick is to work modulo 2. (a / b = q (mod p) if gcd(p, b) = 1 and a = b q (mod p))
06:27:02 <quicksilver> ah, interesting.
06:27:18 <Cale> One solution to y^y = x is given by y = log x / W(log x)
06:27:37 <ilid> int-e: nice :)
06:27:47 <hackagebot> monadiccp 0.6 - Constraint Programming (TomSchrijvers)
06:27:58 <quicksilver> and it's analytic?
06:28:42 <ilid> i found references to a ProductLog function but it seems that it's a Mathematica Special :)
06:29:12 <Cale> quicksilver: There are some discontinuities
06:29:21 <Cale> Yeah, ProductLog = Lambert W function
06:29:26 <ddarius> It's meromorphic, right?
06:29:50 <ddarius> W, I mean.
06:29:57 <Cale> Well, W has a line of discontinuity
06:31:34 <quicksilver> Cale: analytic on some suitable subdomain or riemann surface is fine with me :)
06:32:10 <pozic> What is the point of the Exit monad on the Wiki?
06:32:25 <saml> > exit
06:32:26 <lambdabot>   Not in scope: `exit'
06:32:50 <pozic> It seems that you can _only_ run computations which call exitWith when they end, as opposed to in just one special branch of the computation.
06:32:59 <quicksilver> yes.
06:33:00 <pozic> Example: runExit (return 1) => calls error.
06:33:08 <quicksilver> that is precisely the point yes :)
06:33:13 <pozic> Why would one ever want that?
06:33:25 <quicksilver> it is for computations which are either incomplete (and carrying some kind of incompleteness state) or complete
06:33:38 <quicksilver> and can complete at any point - shortcircuiting if so.
06:33:43 <saml> > runExit (return 1)
06:33:45 <lambdabot>   Not in scope: `runExit'
06:33:56 <pozic> saml: not in the standard libraries.
06:34:22 <pozic> I basically used it to replace ErrorT, so I thought.
06:34:44 <saml> there are 800 ways to handling error situation
06:34:51 <saml> i mean, runtime errors
06:35:11 <pozic> It's not an error situation, it's a shortcut.
06:35:33 <pozic> So, I need a ShortCutT.
06:36:01 <Cale> You could also use ContT
06:36:19 <Cale> Though, that's somewhat overkill :)
06:36:43 <ilid> ContT (Either e) would work as a short-circuiting ErrorT (but doesn't ErrorT short-circuit anyway?)
06:37:51 <ilid> or rather ContT (ErrorT e m) if you want a transformer
06:38:14 <eevar2> > foldl1 (+) [1,..]
06:38:15 <lambdabot>   <no location info>: parse error on input `..'
06:38:21 <eevar2> > foldl1 (+) [1..]
06:38:29 <lambdabot>   mueval: ExitFailure 1
06:39:23 <ilid> eevar2: foldl is always _|_ on infinite lists.
06:40:22 <ilid> (because the result is (your function) (some computation) (last element of list))
06:41:00 <ilid> and the list is traversed to find the last element before it calls your function
06:41:18 <eevar2> wanted to see how the bot responded
06:43:02 <ilid> > let x = x in x
06:43:06 <lambdabot>   mueval-core: Time limit exceeded
06:44:34 <Axman6> ilid: you sure you don't mean foldl?
06:44:39 <Axman6> uh, foldr?
06:45:10 <ilid> Axman6: yeah, i'm sure. :)
06:45:11 <Axman6> > foldl (\x y -> even x || y) [1..]
06:45:12 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:45:12 <lambdabot>         against inferred type ...
06:45:16 <Axman6> > foldl (\x y -> even x || y) True [1..]
06:45:17 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
06:45:18 <lambdabot>    arising from a use of ...
06:45:25 <Cale> I wonder why half of the time we get ExitFailure 1, and half of the time we get Time limit exceeded
06:45:26 <Axman6> > foldl (\x y -> x || even y) True [1..]
06:45:34 <lambdabot>   mueval: ExitFailure 1
06:45:37 <Cale> (for computations which time out)
06:45:47 <ilid> > foldr (\x y -> even x || y) True [1..]
06:45:50 <lambdabot>   True
06:47:30 <ilid> Cale: random stab in the dark: the process gets killed, and it depends on whether the SIGCHLD arrives before or after mueval produecs the 'Time limit exceeded' message
06:48:53 <gwern> ilid: well, it may not be the watchdog process killing mueval; it may be one of the watchdog threads
06:49:12 <Cale> ilid: yeah, probably something like that
07:11:41 <deech`> Hi all, has anyone had any issues installing Haskell Platform on Snow Leopard? I don't have a Mac and a collegue of mine wanted to know.
07:12:02 <Beelsebob> deech`: you need to fiddle with /usr/bin/ghc after install, but it works
07:12:33 <deech`> Beelsebob: is there an online tutorial for that?
07:13:10 <Beelsebob> it's in the archives of the mailing list, basically you need to add -m32 -arch=i386 for compiler and linker
07:13:35 <deech`> Beelsebob: Ok I'll check ... thanks!
07:26:34 <stanv> is it possible see (>) definition ?
07:26:45 <ski> for which type ?
07:26:48 <sioraiocht> :src (>)
07:26:51 <stanv> any
07:26:56 <sioraiocht> :src (>) Int
07:27:04 <mux> @src Int (>)
07:27:04 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:27:08 <mux> @src (>)
07:27:08 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
07:27:12 <sioraiocht> my "at" key is broken -_-
07:27:12 <ski> there is a default implementation
07:27:15 <mux> that's the default definition
07:27:45 * ski wonders why that calls `compare' instead of `(<=)'
07:28:12 <stanv> thanks! I look for 'compare'
07:30:57 <ski> @src compare
07:30:58 <lambdabot> compare x y | x == y    = EQ
07:30:58 <lambdabot>             | x <= y    = LT
07:30:58 <lambdabot>             | otherwise = GT
07:31:24 <stanv> recursive definition ?
07:31:35 <ski> it's open recursion, though
07:31:36 <sioraiocht> stanv: yes, you have to overload some of them, but not all
07:31:37 <mux> mutually recursive default definitions
07:32:05 <sioraiocht> @src (==)
07:32:05 <lambdabot> x == y = not (x /= y)
07:32:09 <sioraiocht> @src (/=)
07:32:09 <lambdabot> x /= y = not (x == y)
07:32:12 <sioraiocht> same thing =)
07:32:35 <ilid> @src (<=)
07:32:35 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
07:33:12 <ilid> hmm. that's less lazy than it needs to be :-/
07:33:23 <ilid> s/needs to/can/
07:33:36 <quicksilver> well it's a method so you can override it
07:33:41 <quicksilver> that's just the default impl.
07:33:46 <ilid> sure. and indeed i do for Natural
07:34:09 <stanv> now clear :)
07:57:59 <pozic> I am having some issues with type families, mostly because of unfamiliarity: http://paste.debian.net/hidden/4b1c39b8/ I would like to know how to define the escape method. There is also something wrong with the type. The intention is that the first argument to escape is returned.
08:01:08 <pozic> class MonadEscape m where type EscType m escape :: a -> m a would make the most sense to me, but then I cannot get the trivial definition for escape value = ShortCut value to type-check.
08:02:06 <Cale> pozic: If the class method's type doesn't make use of the associated type, what would be the point of having an associated type?
08:03:32 <pozic> Cale: ok, but if I remove the associated type I get the same problem.
08:05:06 <pozic> Cale: never mind, I see the solution.
08:09:52 <pozic> Cale: hmm, no, I don't see how I can define it to be a monad and be able to define escape for this type.
08:10:33 <pozic> The problem is that the sc parameter is in the type of the monad.
08:11:14 <Cale> I'm not really sure what you're trying to do with this.
08:13:29 <pozic> Cale: Basically, I implemented an Escape monad, and now I am trying to define a corresponding type-class. I think I have an idea on how to solve it again.
08:15:35 <pozic> Well, it compiles, so, it should work.
08:20:29 <data_jepp> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4298#a4298 I'm missing one part, and then I will at least pass. Negation of an Expr. Please have a loksi. Easy!
08:21:38 <pozic> data_jepp: is that the way they teach you how to do that?
08:22:03 <Alpounet> does anyone know if qthaskell's development is still active ?
08:22:18 <mauke> parseExpr ('-' : s) = (Neg x, s') where (x, s') = parseExpr s
08:23:17 <Alpounet> wow
08:23:21 <Alpounet> there's been a release recently !
08:23:22 <Alpounet> yeah
08:24:04 <roy-t> Hey everyone, small question, is there anyway to temporarily remember a result of a function? Say I would like todo func (x:xs) = F(x) : (func xs F(x)) what do I do to not calculate F(x) twice?
08:24:33 <pozic> roy-t: you use where or let.
08:24:37 <tromp> bind it
08:25:03 <roy-t> Wouldn't where calculate F(x) twice?
08:25:06 <data_jepp> mauke: <3 hihi
08:25:23 <mauke> roy-t: no
08:25:30 <pozic> roy-t: where and let are exactly the same.
08:25:49 <roy-t> Oh ok, I didn't know that
08:26:19 <brad_larsen> Is it a bug in ghc if inlining a function definition where it is used causes a type error?
08:27:18 <int-e> brad_larsen: not necessarily, especially if the function in question has a higher rank type.
08:27:29 <brad_larsen> the greater context of this example is fairly complicated
08:27:30 <brad_larsen> but
08:27:55 <brad_larsen> arrTest5 = mapA (lam $ \x -> x `add` int 1) arrTest1
08:28:01 <brad_larsen> causes ghc to give a type error
08:28:28 <brad_larsen> arrTest5a = mapA addOne_int arrTest1 where addOne_int = lam $ \x -> x `add` int 1
08:28:33 <brad_larsen> arrTest5a works fine
08:29:00 <brad_larsen> the same, modulo beta reduction (?)
08:29:14 <mauke> could be caused by polymorphism
08:30:50 <brad_larsen> meh, I don't understand what's going on.
08:31:07 <mauke> what are the types, what's the error message?
08:32:35 <brad_larsen> I'm messing around with ``finally-tagless'' edsls more.  the type signatures are huge and basically unreadable
08:33:28 <brad_larsen> the signature for arrTest5a is 9 lines long in ghci :-(
08:34:01 <brad_larsen> (a shortcoming of the finally tagless approach?)
08:34:14 <brad_larsen> there are type families involved also
08:34:40 <brad_larsen> the error I get from ghci is:  No instance for (ArithExpr repr Int) arising from a use of `add'
08:35:21 <pozic> How can Foo ~ Fun bar constraints be eliminated?
08:36:08 <brad_larsen> pozic:  say more
08:39:06 <pozic> Never mind, I just need to be more careful with these type-families.
08:39:14 <brad_larsen> pozic: they are tricky!
08:40:52 <pozic> There is some value in being able to eliminate "useless" class-parameters.
08:41:33 <hackagebot> hebrew-time 0.0.0 - Hebrew dates and prayer times. (MichaelSnoyman)
08:47:44 <brad_larsen> if i use functional dependencies instead of type families, I don't get such errors
08:48:14 <pozic> Ah, cool. It works.
08:48:40 <pozic> brad_larsen: yes, functional dependencies appear to be easier to define.
08:49:18 <brad_larsen> pozic: I guess I don't really understand type families ;-)
08:51:29 <pozic> And I guess, type-families have not been implemented for the real-world, since you cannot have overlapping instances.
08:53:07 <pozic> instance (MonadTrans t, Monad (t m), MonadEscape m) => MonadEscape (t m) where type EscType (t m) = EscType m escape = lift . escape
08:53:26 <pozic> For example, that cannot coexist with a specific t.
08:53:55 <pozic> So, you have to introduce lots of boilerplate code.
08:57:22 <thaldyron> Is there a way to deprecate a hackage package?
08:58:04 <pozic> thaldyron: I know it has been asked before.
08:58:29 <Berengal> I don't think so, appart from uploading a newer version
08:59:53 <Saizan> thaldyron: yes, mail the hackage maintainer
09:00:28 <thaldyron> Saizan: ok, thanks
09:02:51 <pozic> Newtype deriving also doesn't work for associated types.
09:03:11 <pozic> It seems they are simply just not integrated. Has this changed in the HEAD?
09:03:26 <Saizan> associated data, you mean?
09:03:45 <Saizan> and, even if you use a newtype instance?
09:04:25 <pozic> Saizan: I only use class Foo a where type Zork a ..
09:04:33 <gwern> doing data structures is so terrible in java :(
09:04:41 <pozic> Saizan: yes, in a newtype.
09:05:04 <pozic> gwern: you mean polymorphic ones?
09:05:21 <gwern> thaldyron: the usual way to deprecate is to not fix breakage caused by cabal/ghc/library changes; people will get the message when they can't compile it...
09:05:24 <Saizan> pozic: what's the example of newtype deriving that doesn't work?
09:05:26 <gwern> pozic: well, any, honestly
09:07:39 <pozic> Saizan: I don't have a short example, but I might make one tomorrow.
09:07:46 <pozic> Saizan: is it supposed to be working then?
09:08:01 <pozic>     (even with cunning newtype deriving:
09:08:02 <pozic>        the class has associated types)
09:08:04 <Berengal> gwern, indeed, java is surprisingly bad at data in general.
09:08:18 <pozic> The error message seems to suggest that is not supposed to be working.
09:09:17 <Saizan> pozic: ah, i thought you were trying to derive for a newtype containing an associated type, not just a class with them
09:09:39 <pozic> Saizan: that also doesn't work, I think.
09:10:02 <pozic> Anyway, just like GADTs, not having what you are used to, is quite annoying.
09:10:13 <Saizan> pozic: yeah, but i don't see how it can work for that case
09:10:36 <pozic> "Oh, look, we can write this and that better now (but you have to do horrible workarounds, so it is still worthless). "
09:10:49 <pozic> That's a bit the impression I get from it.
09:11:49 <Saizan> there are things that are impossible :)
09:12:05 <pozic> Saizan: assumed to be impossible. FTFY
09:12:18 <Saizan> FTFY?
09:12:31 <pozic> Fixed That For Ya.
09:12:51 <gwern> 'let us assume we do not have an oracle; therefore, the halting problem is impossible...'
09:15:53 <Saizan> most of the time you can find a solution by changing the problem, i agree
09:17:28 <quicksilver> preferably, you change the problem into "where can I get a beer?"
09:18:08 <pozic> Or more interestingly "how to reduce beer?".
09:31:25 <FunctorSalad> hmm am I right in thinking that I can de-recursify a data declaration "data Foo a b c = constructors" as "FIX self -> (/\ a b c -> constructors with 'Foo' replaced by 'self')"?
09:31:58 <FunctorSalad> (I'm not totally sure about the parameters, but I think they must go on the inside of the FIX)
09:32:11 <FunctorSalad> ("FIX" is a type-level fix)
09:32:20 <quicksilver> yes, and Mu is the one-parameter type-level fix
09:32:25 <quicksilver> (conventionally)
09:32:51 <FunctorSalad> by putting them on the inside I can handle non-regular types right?
09:33:20 <quicksilver> :t In (Just (In Nothing))
09:33:21 <lambdabot> Mu Maybe
09:33:30 <quicksilver> Mu Maybe ~= [()]
09:33:57 <tinLoaf> hey guys.. if i want to use the "type families" extension in ghc(i), do i have to use some command line switch or something?
09:34:16 <int-e> close. [(),undefined] ...
09:34:47 <quicksilver> int-e: that is not type syntax?
09:35:01 <quicksilver> that's value syntax, but Mu Maybe is a type.
09:35:11 <int-e> quicksilver: that was an example of a value representable by [()] but not Mu Maybe
09:35:25 <int-e> stupid bottoms :)
09:35:32 <quicksilver> in any case, ~= denotes equivalent in the absence of _|_ :P
09:35:45 <quicksilver> that's why I didn't write == or ===
09:35:50 <int-e> okay.
09:36:02 <FunctorSalad> (FWIW I'm trying to convert template haskell ASTs to something where datatypes are actually described rather than just occuring by name)
09:36:10 * int-e wasn't aware of that convention.
09:36:18 <quicksilver> int-e: of course not. I just invented it :)
09:36:21 <FunctorSalad> , src ''Maybe
09:36:24 <lunabot>  data Maybe a = Nothing | Just a
09:36:25 <FunctorSalad> err
09:36:32 <FunctorSalad> , [t| Maybe |]
09:36:33 <lunabot>  luna: `Data.Maybe.Maybe' is not applied to enough type arguments
09:36:40 <FunctorSalad> , [t| Maybe Int |]
09:36:41 <lunabot>  AppT (ConT Maybe) (ConT Int)
09:36:44 <quicksilver> int-e: but, there was a reason I chose "~" which normally denotes something slightly less than equality.
09:36:54 <quicksilver> except in GHC's aberrant equality constraints
09:37:19 <int-e> quicksilver: I read it as 'isomorphic to'
09:37:24 <FunctorSalad> ("Maybe" is just a name there, I want to expand it to a full description)
09:37:43 <FunctorSalad> so I think fixed points are the way to go if I don't want an infinite cyclic structure ;)
09:37:55 <int-e> and it is, if we can agree that there are no bottoms.
09:41:46 <FunctorSalad> wow this actually works... "data List a = Nil | Cons a (List a)" is converted to: " RFix Main.List (RLam (RData [RCon Main.Nil [],RCon Main.Cons [RVar Nothing,RApp (RVar (Just Nothing)) (RVar Nothing)]]))"
09:41:51 <FunctorSalad> :)
09:42:19 <FunctorSalad> (using Maybe for de-bruijn indices)
09:43:47 <FunctorSalad> (the RFix and RLam are binders)
09:44:26 <aavogt> is it just me, or do these functions have an inconvenient parameter order: http://hackage.haskell.org/packages/archive/ConfigFile/1.0.5/doc/html/Data-ConfigFile.html
09:46:15 * Alpounet playing with leksah
09:47:26 <aavogt> everything is defined as:    x :: ConfigParser -> x -> y -> m ConfigParser
09:48:18 <aavogt> @hoogle MEndo
09:48:18 <lambdabot> No results found
09:48:23 <aavogt> @hoogle EndoM
09:48:24 <lambdabot> No results found
10:07:59 <mornfall> @hoogle Int -> Int -> Float
10:08:00 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
10:08:00 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlow :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b
10:08:00 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
10:08:06 <mornfall> Pff.
10:08:27 <mornfall> I just want reasonable division...
10:09:50 <mornfall> Sorta, x ./ y = fromIntegral x / fromIntegral y
10:09:58 <mornfall> Anything better in the standard libs?
10:11:04 <Cale> I would just leave the fromIntegrals in
10:11:55 <Cale> If they start to become a pain to type, sometimes I'll write  where fI = fromIntegral  or something.
10:12:21 <Cale> It's usually a good idea to be careful about where you do your conversions.
10:12:24 <mornfall> Well, (fromIntegral $ (zeroes' v - ones' v)^2) / (fromIntegral $ 8 * length v) -- looks really bad.
10:12:45 <mornfall> It's a rather simple formula, too.
10:12:50 <Cale> It's not *too* bad. :)
10:13:01 <DrSyzygy> Hmmmm.
10:13:19 <DrSyzygy> Do I do Functors, then Adjunctions, then Monads, then Products/coproducts/limits/colimits?
10:13:30 <Cale> DrSyzygy: teaching?
10:13:36 <DrSyzygy> Or do I do Functors, then Products/coproducts/limits/colimits, and then adjunctions and monads?
10:13:40 <DrSyzygy> Teaching.
10:13:59 <Cale> DrSyzygy: You can move the limit stuff anywhere there.
10:14:05 <Cale> Even before functors if you want.
10:14:14 <DrSyzygy> THAT's the one place it isn't going.
10:14:16 <Cale> Er, well, I suppose that's a little unnatural.
10:14:27 <DrSyzygy> The functors lecture is today, and already written.
10:14:30 <Cale> It's possible to put products and coproducts before functors
10:14:34 <DrSyzygy> Whereas the other stuff isn't written yet.
10:14:38 <Cale> Limits is more questionable
10:14:55 <brad_larsen> int-e, mauke: I think my type signature problem (inlining the function def.) is a ghc bug in 6.10.4.  I tried with a recent snapshot of 6.12, and my program is accepted.
10:15:03 <DrSyzygy> I do want to connect the limit discussion up with the products/coproducts.
10:15:37 <Cale> I would usually consider limits more elementary than adjunctions and monads, but if I think about it, that's kind of an unjustified feeling.
10:15:49 <brad_larsen> so when does ghc 6.12 officially come out?  :-)
10:16:08 <vinicius> when it's ready
10:16:18 <hackagebot> dedukti 1.0.3 - A type-checker for the -modulo calculus. (MathieuBoespflug)
10:16:19 <brad_larsen> awww, that's a boring answer
10:16:29 <vinicius> i'm a boring person :/
10:16:40 <brad_larsen> teehee
10:16:52 <Cale> DrSyzygy: Are you going to do the string diagram explanations? :)
10:17:36 <data_jepp> Funny problem. I call parseExpr::String->(Expr,String) from parseProg::String->Expr And it won't work. How do I handle the string return in parseExpr? (Its empty)
10:17:43 <DrSyzygy> Cale: There is a narrative thread around there that runs from Functors, Natural transformations, Functors as container types, Transformations as polymorphic functions, continuing on to Monads as containers with sequencing, as monoids in endofunctors, et.c.
10:20:47 <hackagebot> htzaar 0.0.0 - A two player abstract strategy game. (TomHawkins)
10:21:41 <Cale> Ooh, a GIPF game :)
10:21:58 <viator_sg> there are any "easy" way to execute a haskell script from a haskell program (maybe in some context)?
10:22:14 <Cale> viator_sg: There's hint
10:22:26 <Cale> http://hackage.haskell.org/package/hint
10:24:38 <Cale> DrSyzygy: One thing which I find helpful is to always do an example where you plug in a preorder category and see what the concept reduces to in terms of ordering.
10:25:04 <DrSyzygy> String diagram might come up. But I need the monoidal structure in place for that.
10:25:05 <viator_sg> Cale: Thanks! :)
10:26:10 <Cale> DrSyzygy: Right, but if you're going to do monads as monoids in the endofunctor category, you'll need that too.
10:26:21 <Cale> (to define monoid object)
10:27:24 <DrSyzygy> Good point.
10:28:05 <DrSyzygy> So this is a strong argument for products/coproducts first, so I can introduce monoidal categories and stirng reasoning, so I can talk about monoid objects, so I can be complete when talking about monads.
10:30:41 <data_jepp> Anyone, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4299#a4299 simple function "call" with wrong types
10:32:16 <ilid> data_jepp: you want parseProg to ignore the second element of parseExpr's result tuple?
10:32:26 <ilid> @type fst
10:32:27 <lambdabot> forall a b. (a, b) -> a
10:32:30 <ilid> @src fst
10:32:31 <lambdabot> fst (x,_) =  x
10:32:58 <data_jepp> yes
10:33:11 <data_jepp> AH
10:33:13 <data_jepp> :D
10:33:17 <data_jepp> So easy heh? :p
10:33:36 <numeromancer> Shouldn't \s_ be the same as (\w|_) in a C file?
10:33:57 <numeromancer> When I try it, it only matches ?_.
10:34:11 <ilid> Cale: interesting, i didn't know tamsk had been 'replaced' :)
10:34:32 <nomeata> tomh-: Hi. Did you just upload htzaar?
10:34:42 <nomeata> tomh-: it does not build: Could not find module `Play'
10:35:06 <numeromancer> Oops!  Wrong room.
10:38:37 <mornfall> Hm. Implementing X9.31 in Haskell for cryptography assignment turned out to be a massive win.
10:39:11 <Zao> Correctly?
10:39:39 <mornfall> Who knows. :)
10:39:55 <Zao> QuickCheck to the rescue?
10:40:27 <mornfall> It's a pseudo-random number generator. I don't know how to exploit QC there.
10:42:16 <mornfall> For the single reference input/output, the results match. (A key, seed and DT sequence and a resulting 1024 random byte sequence.)
10:42:43 <mornfall> I guess an incorrect implementation is fairly unlikely to produce the right result. :-)
11:10:39 <ogloom> guys, Im having some syntax woes with haskell. I am just starting out and am trying to sum all natural numbers <1000 that are multiples of 3 or 5. I know what I have to do, but I cant seem to get the code to work...
11:11:16 <Vq> what code have you come up with so far?
11:11:33 <ogloom> so : http://pastebay.com/59674
11:11:42 <thomastc> you basically have two options: some standard functions, or a list comprehension
11:11:46 <Baughn> > sum [n | n <- [1..1000], n `mod` 3 == 0, n `mod` 5 == 0]
11:11:47 <lambdabot>   33165
11:12:17 <ogloom> getnum determines the lenght of the arithmetic series
11:12:21 <ogloom> arith attempts to compute it
11:12:35 <mauke> why so smart?
11:12:43 <mauke> it's easier to do it the stupid way
11:12:58 <Baughn> ogloom: One thing to keep in mind is that / is flaoting-point division. You want div for integer division.
11:13:32 <Baughn> ..this looks very mathematical
11:13:35 <ogloom> yeah Thanks Baughn. I used it intentionally, as I wanted to know how many times x goes into a number
11:14:38 <Baughn> ogloom: I guess I can understand using it, but.. a formula that uses inexact math to get a presumably exact result just feels wrong
11:15:03 <ogloom> I did feel dirty inside when writing it :P
11:15:04 <danco> Baughn: i think you summed things multiples of 3 _and_ 5
11:15:33 <ogloom> but what I dont get is why I cant do something like this: function 1 x y = 2*x + 3*function 2 (y);
11:15:35 <Baughn> So I did. Oops.
11:15:39 <danco> > sum $ filter (\ x -> x `mod` 3 == 0 || x `mod` 5 == 0) [1..1000]
11:15:40 <ogloom> like it seems its not letting me have nested functions
11:15:40 <lambdabot>   234168
11:15:51 <ogloom> lambdabot that was the first answer I got
11:15:54 <ogloom> you're off by a bit
11:15:58 <Baughn> ogloom: That should be fine, as such
11:16:04 <ogloom> its <1000 not <=1000
11:16:11 <benmachine> ogloom: function has three arguments but you are calling it with two?
11:16:37 <ogloom> woops, Im being so stupid in describing my problem
11:16:38 <mauke> > let arith d = getnum d * (getnum d - 1) `div` 2 * d; getnum n = 999 `div` n + 1 in  arith 3 + arith 5 - arith 15
11:16:39 <lambdabot>   233168
11:16:48 <danco> > sum $ filter (\ x -> x `mod` 3 == 0 || x `mod` 5 == 0) $ take 1000 [0..]
11:16:49 <lambdabot>   233168
11:16:52 <mauke> yay
11:16:53 <ogloom> correct
11:18:27 <danco> you could also just (print 233168) then prove your program correct ;)
11:18:51 <ogloom> haha
11:19:00 <Baughn> > $(2)
11:19:01 <lambdabot>   <no location info>: parse error on input `$'
11:20:49 <dmoranda> I'm trying to win a trip to Autodesk University.  Any views would be much appreciated! http://www.youtube.com/watch?v=PzoCdLjN_gw
11:24:33 <tinLoaf> hey guys.. if i want to use the "type families" extension in ghc(i), do i have to use some command line switch or something, or should it work out of the box?
11:24:54 <benmachine> I believe there is an -XTypeFamilies
11:24:57 <benmachine> never personally used it though
11:24:58 <seanmcl> yep
11:25:05 <seanmcl> I've used it.
11:25:09 <Baughn> tinLoaf: Typically, a {-# LANGUAGE TypeFamilies -#} line at the top of the file
11:25:29 <Baughn> (LANGUAGE pragmas are comma-separated)
11:25:31 <seanmcl> maybe better in the Cabal file
11:25:49 <benmachine> putting LANGUAGE in files kind of makes sense
11:26:05 <tinLoaf> yep, i think i'll put it into that file
11:26:20 <tinLoaf> Baughn: so what do i need to seperate by commas there?
11:26:31 <Baughn> tinLoaf: In case you want more than one extension
11:26:31 <tinLoaf> my ghci complains about it not being comma seperated
11:26:43 <tinLoaf> i don't want more than one, and ghci still complains ;)
11:26:57 <Baughn> What does the line look like, exactly?
11:27:01 <tinLoaf> h
11:27:07 <tinLoaf> #- instead of -#
11:27:23 <tinLoaf> i copied and pasted what you wrote, but the last thing should be a #-}
11:32:17 <jmcarthur_work> until very recently, i liked LANGUAGE pragmas, but i am beginning to question whether in the cabal file is better
11:32:33 <jmcarthur_work> it's not like i really care which files in a single project are and aren't using the extension
11:32:48 <Baughn> I rather like being able to open the files in ghci
11:32:58 <jmcarthur_work> oh, yeah, i didn't think about that
11:33:01 <seanmcl> Cabal is less typing, and it is obvious if the code is portable, without grepping through files
11:33:12 <seanmcl> yeah, you need a separate .ghci file
11:33:18 <seanmcl> with the same extensions as in the Cabal file
11:33:30 <jmcarthur_work> woah, a .ghci file? didn't even know those existed
11:33:32 <danco> what about keeping metadata close to data
11:34:08 <ray> i like knowing which files use which extensions too
11:34:38 <seanmcl> why?  do you use the files in independent projects?
11:34:50 <jmcarthur_work> i could see things like scoped types or something being in LANGUAGE pragmas
11:34:56 <jmcarthur_work> things you don't *want* in every file
11:34:56 <danco> it will never be obvious the code is portable (since there might be more extensions in the files), it will only be obvious that it is at-least-this-unportable right?
11:35:03 <cads> hey, I've been using unicode math symbols in my code to represent math notations
11:35:11 <ray> some pretty obvious things could go in the .cabal file
11:35:16 <jmcarthur_work> but there are a lot of extensions that i usually end up putting in nearly every file of a project anyway
11:35:17 <cads> and i was wondering if there's a preffered editor for tht
11:35:22 <danco> right
11:35:29 <seanmcl> cads: emacs with Agda input mode
11:35:42 <benmachine> LANGUAGE is kind of a bit like import anyway if you ask me
11:35:49 <danco> heh
11:36:01 <seanmcl> ha, true
11:36:10 <ray> import ScopedTypes
11:36:29 <Vanadium_> from future use
11:37:14 <danco> so to whatever extent you reexport imports from e.g. Common.hs, you should consolidate extensions in .cabal/.ghci
11:42:02 <tibbe> after reading the reddit comments on JaffaCake's blog post I wonder if people understand how many cores you can use before Amdahl's law makes extra cores essentially useless.
11:42:49 <tibbe> someone mentioned 1024 core computers while a program with only 5% sequential code sees almost no speed-ups at 128+ cores
11:49:11 <sproingie> for some classes of problems, when cores > inputs
11:49:28 <sproingie> i.e. effectively never
11:49:38 <Berengal> Amdahl's law can be defeated by parallellizing everything, i.e. regular multitasking
11:51:01 <Berengal> Often it's not that important how fast you can solve a problem, but how many problems you can solve each time unit
11:51:15 <Berengal> e.g. serving web-pages or doing db lookups
11:51:33 <tinLoaf> what are the special characters that i may use in defining infix "operators"?
11:51:54 <danco> unicode characters (as opposed to unicode letters)
11:51:56 <sproingie> i suspect we'll be boiling the oceans before our capacity for computation outstrips our demand
11:51:59 <danco> err symbols
11:52:02 <Berengal> tinLoaf, punctuation, mostly
11:52:29 <tinLoaf> hum.. _ and ' seem not to work.. let's try :
11:52:39 <seanmcl> I use      among others
11:52:40 <sproingie> : works, _ is not punctuation
11:53:28 <tinLoaf> seanmcl: doesn't it enerve you to type these characters?
11:53:31 <danco> ya _ and ' don't work.  : has a limitation iirc where as the _first_ symbol it implies that you have a constructor
11:53:31 <sproingie> didn't know you could use unicode identifiers in haskell
11:53:51 <seanmcl> tinLoaf: using Agda input method and dynamic abbrevs makes it easy
11:54:12 <seanmcl> for instanc, to get  you type \le
11:54:30 <mauke> varsym  -> (symbol {symbol | :}) \ (reservedop | dashes)
11:54:50 <sproingie> is teh googlez slow for everyone else today or is it just me?
11:55:01 <tinLoaf> seanmcl: what editor are you using for this?
11:55:05 <mauke> reservedop  -> .. | : | :: | = | \ | '|' | <- | '->' | @ | ~ | =>
11:55:10 <seanmcl> emacs
11:55:23 <byorgey> sproingie: probably just you, works fine for me.
11:55:30 <tinLoaf> hum.. that's what i'm using, too. perhaps i should make my emacs learn these nice shortcuts, too
11:55:31 <seanmcl> you can use dozens if not hundreds of unicode infix symbols
11:55:42 <seanmcl> you need to load Agda2 mode
11:55:50 <seanmcl> and then set your input method to be Agda2
11:56:07 <seanmcl> you can read about input methods in the info files for emacs if you're not familiar with them
11:56:11 <tinLoaf> i'll have a look at that. according to google, agda actually is an own language?
11:56:14 <seanmcl> for instance, there's a Latex input method
11:56:26 <tinLoaf> i shall read that, yes
11:56:27 <tinLoaf> thanks
11:56:33 <seanmcl> agda is a theorem prover, but you can just use some of the emacs code they wrote
11:56:46 <seanmcl> you don't need to install agda, but you can with cabal install agda
11:57:08 <kosmikus> agda2 is really more a programming language than a theorem prover
11:57:16 <kosmikus> but with dependent types, the distinction blurs
11:57:24 <seanmcl> I guess at that level it's not so clear the difference
11:57:27 <sproingie> got a url for agda2-mode?
11:57:58 <seanmcl> http://wiki.portal.chalmers.se/agda/
11:58:23 <seanmcl> download it and it's in src/emacs-mode
11:58:32 <sproingie> cool
11:58:40 <seanmcl> you need to 'require agda2
11:58:47 <seanmcl> I mean (require 'agda2)
11:59:09 <seanmcl> and (require 'agda-input)
11:59:21 <seanmcl> then (setq default-input-method "Agda")
11:59:43 <seanmcl> Turn the input method on with ctrl-\, and then insert away
12:07:21 <etpace> [QUOTE=Blaah Blaah]Yeah I was just about to send you a message on Facebook actually. Couldn't work out if I recognised you from TSR or Caius, and I'm doing horribly with names anyway :p:
12:08:14 <sproingie> bleah.  my order for Algebra of Programming was cancelled, it was out of stock, big surprise
12:48:27 <burp> @hoogle CReal
12:48:28 <lambdabot> No results found
12:49:05 <burp> I always forget where CReal is in :|
12:49:19 <burp> it's in Data.Number.CReal, but what's the package?
12:51:02 <jmcarthur_work> numbers, i think
12:51:22 <jmcarthur_work> and i think there is another packages called Numbers which is different :\
12:51:32 <burp> oh yes :|
12:51:38 <burp> there is also Numbers
12:52:58 <Armin4> I want to view the output ( in c ) directly on notepad , i.e. an automatic popup notepad window with the output of .C please help
12:53:31 <Makoryu> Armin4: Hi, this is #haskell, where we don't talk about C very much
12:54:01 <medfly> it would be funnier if he got an answer
12:56:02 <Elenbert> Hi there
12:56:08 <Raevel> hi hi
13:03:35 <copumpkin> I think hackage should be case insensitive
13:03:44 <copumpkin> the numbers vs. Numbers thing is silly
13:04:22 <jmcarthur_work> agreed
13:04:48 <jmcarthur_work> and the scary thing is cabal-install's case-insensitivity
13:04:54 <copumpkin> yeah
13:05:00 <jmcarthur_work> except it distinguishes between those two i think
13:05:26 <aug_triad> Hi, I have some trouble recursing in a monad. First, this will work, but gives me a [IO b] and I think it is nicer with a IO [b]
13:05:27 <aug_triad> impMidiFromForm' (x:xs) =
13:05:28 <aug_triad> 			let midiPart = loadInput x
13:05:28 <aug_triad> 			in midiPart:(impMidiFromForm' xs)
13:05:50 <copumpkin> call seqence on it
13:06:05 <aug_triad> When I try
13:06:06 <aug_triad> impMidiFromForm' (x:xs) = do
13:06:06 <aug_triad> 		midiPart <- loadInput x
13:06:06 <aug_triad> 		return midiPart:(impMidiFromForm' xs) :: IO Performance
13:06:10 <aug_triad> I get an error
13:06:17 <copumpkin> "an error"?
13:07:03 <copumpkin> your problem is that you can't use : on the IO
13:07:10 <mauke> also precedence
13:07:45 <copumpkin> easiest way is probably to do mapM loadInput xs
13:08:03 <aug_triad> Couldn't match expected type `[m a]  against inferred type `IO b'
13:08:07 <mauke> impMidiFromForm' (x : xs) = do midiPart <- loadInput x; pointlesslyLongVariableName <- impMidiFromForm' xs; return (midiPart : pointlesslyLongVariableName)
13:08:16 <copumpkin> lol
13:08:19 <copumpkin> @src mapM
13:08:20 <lambdabot> mapM f as = sequence (map f as)
13:08:22 <aug_triad> Hehe
13:08:40 <copumpkin> aug_triad: you're explicitly recursing to do something you can do easily with a library function
13:09:40 <copumpkin> impMidiFromForm' = mapM loadInput -- unless I'm missing something
13:14:54 <ddvlad> @type (***)
13:14:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:16:21 <aug_triad> Thank you very much. I didn't know the mapM function
13:46:01 <Peaker> > foldr (.) id [f,g,h]
13:46:02 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:46:03 <lambdabot>    `Test.SmallCheck.Serial ...
13:46:09 <Peaker> > foldr (.) id [f,g,h] :: Expr
13:46:11 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:46:11 <lambdabot>         against inferred ...
13:59:51 <Peaker> can IO actions be debugged? :break/etc seem to debug the *evaluation* process
13:59:56 <Peaker> I want to debug an IO action, bind-by-bind
14:00:36 <jmcarthur_work> Peaker, you could perhaps insert getChar every once in a while to pause the program until you hit a key?
14:01:00 <jmcarthur_work> i'm not very familiar with the debugger
14:01:19 <jmcarthur_work> i guess that doesn't help you inspect state
14:02:27 <Peaker> jmcarthur_work, once my IO action was executed once, its no longer traced at all
14:46:38 <data_jepp> Anyone?
14:48:08 <Person_> Hello Haskell
14:49:31 <Zao> Hello World^WPerson_
14:53:40 <Person_> Haha
14:53:45 <Person_> I'm new to Haskell
14:53:55 <Person_> I'm looking at the Haskell for C Programmers document
14:54:02 <Person_> This is insane
14:54:38 <shepheb> it's an exhilerating kind of insane, though.
14:54:56 <Peaker> Person_, I think the "Haskell for C programmers" is considered a bit off at some points, so take it with a grain of salt
14:55:07 <Person_> Will do...
14:55:29 <Person_> What purpose does | serve?
14:55:45 <sproingie> put that in your | and smoke it
14:55:51 <monochrom> punctuation in a particular bit of syntax
14:55:54 <Peaker> Person_, It allows a single type to have multiple possible data constructors as possible values
14:56:09 <Vanadium_> Fancy enums
14:56:22 <mightybyte> Fancy and type safe enums
14:56:49 <mightybyte> (amongst other things)
14:56:50 <monochrom> You have all forgotten guards.
14:56:53 <Person_> Interesting
14:57:27 <seanmcl> and functional dependencies
14:57:44 <monochrom> This is the problem with picking out one token to ask for its semantics. It has none. A whole construct has a semantics.
14:58:01 <Person_> I am trying to write a recursive function, and am having much difficulty
14:59:40 <Person_> If one had a lists of lists, how would you go about
14:59:44 <monochrom> Another example: , has no semantics. Punctuation. (x,y) and [x,y] have semantics - two unrelated semantics.
14:59:50 <Person_> reversing every element in each list, and then the lists in the super-list
15:00:12 <Person_> for example [ [1,2,3,4,5] [1,2,3]] -> [[3,2,1] [5,4,3,2,1]]
15:00:23 <seanmcl> rev . map rev
15:00:31 <seanmcl> sorry
15:00:34 <seanmcl> reverse . map reverse
15:01:10 <nickrolfe> I think he'd like to see it done with explicit recursion.
15:01:35 <Person_> I'm starting with reverseMe: List L -> List L
15:01:43 <Person_> ::
15:03:10 <seanmcl> Starting with rev, you could say
15:03:17 <monochrom> If you want to write the whole thing yourself, start with reversing a simple list. Do not be afraid of writing multiple functions, each doing one part of the task, then gluing them together.
15:03:26 <seanmcl> reverse xs = rev xs []
15:03:33 <seanmcl> where rev [] xs = xs
15:03:50 <seanmcl>           rev (y:ys) xs = rev ys (y:xs)
15:05:05 <Person_> Alright
15:05:13 <Person_> The problem that I'm facing, is that I do not know if it is a list of lists,
15:05:15 <Person_> a list of lists, of lists
15:05:17 <Person_> etc.
15:05:27 <Person_> Is there a way to tell how far down the rabbit hole you are?
15:06:12 <seanmcl> That's the point of parametric polymorphism.  You can write the code not caring what the list elements are
15:06:26 <seanmcl> Then you can map the reverse function at any level.
15:06:53 <seanmcl> Of course, if you have an actual value, as in your example, then the types tell you how deep the hole is
15:07:10 <Person_> Interesting
15:07:20 <Person_> Nice chatting guys, but I've got to run to class
15:07:22 <Person_> I'll be back later
15:19:35 <data_jepp> http://stackoverflow.com/questions/1534557/haskell-recursive-problem-tiny-parser-check-variables if any one is up for it. Thank you in advance. Good night. :)
15:19:47 <skorpan> ooh, points
15:19:58 <data_jepp> ^^
15:21:04 <skorpan> "[...] defined in a task at school" <- bummer
15:21:22 <monochrom> To a large extent, parsing methods need to be taught explicitly. Can't expect students to invent it themselves just by a sink-or-swim tactic.
15:21:41 <data_jepp> I hate it, everyone hates it. :p
15:21:46 <monochrom> Yes, most students will sink, the teacher will achieve nothing.
15:22:02 <copumpkin> he'll be able to claim he's "selective"
15:22:07 <data_jepp> High flunk rate.
15:22:21 <skorpan> 77 percent flunked the advanced fp course when i took it
15:22:32 <monochrom> Perhaps some teachers' goal is mass extermination of humanity, like me.
15:22:34 <copumpkin> wow
15:22:37 <data_jepp> wow
15:22:49 <copumpkin> monochrom: humanity like you, or the professor's intention is like yours?
15:22:55 <monochrom> intention :)
15:23:04 <copumpkin> oh no!
15:23:04 <poe> skorpan: how many students were following at the beginning?
15:23:20 <Saizan> EXTERMINATE, EXTERMINATE
15:23:22 <skorpan> poe: i don't know, in the beginning we were maybe 40 students, maybe more
15:23:31 * copumpkin tries to figure out how many people are probably in that class given that he could come up with a 77% figure
15:23:44 <skorpan> i can look it up if you want
15:23:46 <copumpkin> I'm gonna guess exactly 100!
15:23:53 <copumpkin> (not 100, 100 factorial)
15:25:53 <Makoryu> > let fac = product . enumFromTo 1 in length . show . fac $ 100
15:25:55 <lambdabot>   158
15:26:11 <copumpkin> yep
15:26:33 <Peaker> > let fac n = product [1..n] ; l = length . show . fac ; map l [1,10,100,1000]
15:26:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:26:39 <Peaker> > let fac n = product [1..n] ; l = length . show . fac in map l [1,10,100,1000]
15:26:41 <lambdabot>   [1,7,158,2568]
15:26:50 <aavogt> > sum . map digitToInt . show . product $ [1..100]
15:26:50 <Peaker> > let fac n = product [1..n] ; l = length . show . fac in map l [1..30]
15:26:51 <lambdabot>   648
15:26:52 <lambdabot>   [1,1,1,2,3,3,4,5,6,7,8,9,10,11,13,14,15,16,18,19,20,22,23,24,26,27,29,30,31...
15:27:01 <copumpkin> @oeis 1,7,158,2568
15:27:02 <lambdabot>  Number of digits in (10^n)!.
15:27:02 <lambdabot>  [1,7,158,2568,35660,456574,5565709,65657060,756570557,8565705523,95657055187...
15:27:05 <copumpkin> oh god
15:27:29 <aavogt> @oeis 1,6,3,4
15:27:29 <lambdabot>  a(n) = smallest m such that primorial(n)/2 - 2^m is prime.
15:27:29 <lambdabot>  [0,1,1,1,1,1,1,1,3,1,2,1,25,2,1,6,6,19,1,13,3,3,11,29,2,1,6,3,4,2,6,4,15,6,4...
15:27:38 <copumpkin> @oeis 2,8,159,2569
15:27:38 <poe> skorpan: just wondering, I never witnessed such a high drop rate, I thought they could have been a very small class?
15:27:39 <lambdabot>  Sequence not found.
15:27:42 <copumpkin> w00t
15:27:51 <Peaker> @oeis 1,1,1,2,1,1,2,1,1
15:27:52 <lambdabot>  Unique sequence of 1's and 2's where g.f. A(x) satisfies A(x) = B(B(x)) such...
15:27:52 <lambdabot>  [1,2,2,1,2,1,2,2,1,2,1,2,2,2,2,2,1,1,1,1,1,2,2,1,1,1,2,2,1,2,1,2,2,1,1,1,1,1...
15:28:08 <Peaker> that's not what I had in mind...
15:29:39 <skorpan> poe: the person who taught the course back then (and possibly still) is quite into fp and programming logic and it was the first time he taught the course, so it's understandable... maybe.
15:40:17 <aavogt> @oeis 1203984
15:40:18 <lambdabot>  Sequence not found.
15:42:14 <ari> @bot
15:42:14 <lunabot>  :o
15:42:16 <lambdabot> :)
15:42:20 <monochrom> :)
15:42:54 <ari> Ahh, I was wondering why lambdabot wasn't responding, must have gotten netburped or something
15:44:13 <copumpkin> that proves it! monochrom is a bot
15:44:40 <monochrom> In fact I have been waiting for the opportunity.
15:45:02 <Botje> that's what bots do! burn him!
15:45:21 * copumpkin points monochrom at Botje and burns him
15:52:25 <hackagebot> htzaar 0.0.1 - A two player abstract strategy game. (TomHawkins)
16:08:56 <gOcOOl> trying to load ":m +Text.Regex.Posix" from ghci fails with "could not find module" error
16:09:09 <copumpkin> did you install it?
16:09:09 <gOcOOl> what do I need to do to load it?
16:09:22 <gOcOOl> cabal install Text?
16:10:17 <gOcOOl> is that how I install that module?
16:14:52 <byorgey> gOcOOl: Text.Regex.Posix is from the regex-posix package
16:15:00 <byorgey> so you would 'cabal install regex-posix'
16:15:55 <gOcOOl> ah ok, perfect. that did it
16:16:46 <gOcOOl> is there an easy way to find out, given a certain module, what package it belongs to?
16:17:33 <byorgey> gOcOOl: you can search for their names on hackage or hayoo
16:17:40 <byorgey> @where hackage
16:17:41 <lambdabot> http://hackage.haskell.org/
16:17:43 <byorgey> @where hayoo
16:17:43 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:19:52 <lpjhjdh> is there a way to say something like "type X = Y in f, g"?  I think you could in gofer or something
16:20:04 <gOcOOl> byorgey: makes sense, thank you!
16:20:18 <lpjhjdh> in ghc I should add
16:23:41 <byorgey> lpjhjdh: you mean to create a local type synonym?
16:23:49 <byorgey> I don't think there is.
16:24:35 <byorgey> although implementing such a feature seems like it would be simple in theory.
16:25:44 <lpjhjdh> byorgey: yeah
16:26:17 <lpjhjdh> blast, seems like a reasonably useful utility
16:26:30 <lpjhjdh> byorgey: thanks
16:27:40 <byorgey> lpjhjdh: what's your use case?
16:28:05 <byorgey> put another way, why do you want the type synonym to NOT be global?
16:28:12 <byorgey> I'm just curious.
16:28:14 <seanmcl> yeah, you can do this in ML.  It's a nice feature.
16:28:57 <seanmcl> you can also do local data decls.  Useful in big functions where you don't want to pollute the namespace with lots of types.  Or it's another way of hiding type info.
16:29:20 <lpjhjdh> byorgey: just want a shorthand for something I'll use only once.  I can't think of a good name for it since it's so local and it just feels dirty to make everything else see it
16:29:27 <lpjhjdh> not that they have to use it of course
16:30:13 <lpjhjdh> seanmcl: haven't used ml much but it seems like as far as modularity it's far ahead of haskell
16:30:21 <lpjhjdh> seanmcl: well, modularity of modules that is
16:31:16 <seanmcl> lpjhjdh: yeah, I think the ML module system is great.  I miss it, though the many other features of Haskell almost make up for it.
16:31:37 <lpjhjdh> seanml: did peyton jones ever implement the first class module stuff that was presented in a paper long ago?  Seems like that would give a lot of the power functors offer
16:32:53 <seanmcl> lpjhjdh: I heard he made a comment recently that adding parameterized modules to Haskell would have a low effect / semantic + implementation effort ratio.  Seems like he doesn't think it's worth it at the time.
16:33:13 <seanmcl> just heresay though.  I can't cite a paper.
16:33:43 <lpjhjdh> honestly haskell just needs full blown dependant types methinks, then it's built in
16:34:25 <seanmcl> haha
16:34:56 <seanmcl> yeah, you could code up modules nicely with dependent types, as you can in Coq.  Though I still like the syntax of modules.
16:35:27 <mmorrow> seanmcl: i think the module system is a pressing issue too
16:35:45 <lpjhjdh> seanmcl: true, easy enough to add some syntactic sugar.  Or just offer a nice parser like isabelle
16:35:50 <seanmcl> mmorrow: maybe we can hire a lobbyist.
16:35:59 <binrapt> How suited is Haskell for webdev?
16:35:59 <seanmcl> send them to cambridge
16:36:14 <binrapt> Can you execute arbitrary new code without having to create a new process?
16:36:30 <Cale> binrapt: poeple do it, and yes, you can arrange for that to happen.
16:36:38 <Cale> people*
16:37:24 <mmorrow> seanmcl: heh
16:38:19 <mmorrow> binrapt: how do you mean arbitrary? like you have a [Word8] and you want to call it?
16:38:27 <Cale> binrapt: If you want to load new Haskell code at runtime, check out the hint library on Hackage, which is a nice wrapper for the GHC API.
16:38:37 <binrapt> mmorrow I meant Haskell code
16:38:43 <binrapt> No idea what [Word8] is
16:38:47 <binrapt> I don't know Haskell really
16:38:48 <mmorrow> binrapt: it's machine code
16:38:51 <mmorrow> :)
16:39:01 <binrapt> Oh you mean a byte
16:39:04 <Cale> It's a list of bytes
16:39:05 <mmorrow> binrapt: so what form is this "arbitrary code" in?
16:39:22 <binrapt> I just wondered if it was possible to use Haskell in a PHP like fashion
16:39:32 <binrapt> Without having to use ghci + cgi or something along those lines
16:39:32 <mmorrow> binrapt: ok, so it's in text form
16:39:32 <QtPlaty[HireMe]> binrapt: Its a list of octets/bytes
16:40:18 <mmorrow> binrapt: so you'd need to compile it first, which pretty much means you'd need to use ghc's api
16:41:12 <mmorrow> binrapt: hmm, actually there's a thing called hsp, but i'm not sure the status of that
16:41:44 <mmorrow> (lets you embed haskell similar to php/whatever in webpages)
16:42:22 <mmorrow> unfortunately it's almost certain that getting hsp working won't be "trivial"
16:42:28 <darrint_> binrapt, I think as a rule people don't use it in a php like manner so trying would require more contortions than just learning haskell.
16:42:37 <binrapt> I see :/
16:42:49 <binrapt> I thought it might be a laugh
16:44:30 <jmcarthur> not a laugh. there are some projects that use haskell code for configuration or as a plugin interface
16:44:45 <jmcarthur> but i don't think it is necessarily the easiest way to go
16:46:54 <darrint_> binrapt, Your original question, how suited to webdev? I'd say if you have a preconcieved notion of what should be available and easy, you'll be disappointed.
16:47:34 <darrint_> binrapt, Especially if you are used to Django or Rails. It isn't those. You'll have fun learning and useing, no question.
16:48:30 <binrapt> I couldn't stand either ;(
16:49:42 <darrint_> binrapt, What do you like currently?
16:50:39 <binrapt> None really, I worked with PHP for a long time
16:51:14 <binrapt> A few weeks ago I invented a scripting language and started working on an interpreter for it so I can embed it into a web server I have written
16:51:26 <binrapt> And then I'm just going to link it all together with nginx or something like that
16:51:48 <darrint_> binrapt, If you want to reinvent the foundations of web programming you'll love haskell. I'd take a look at hackage. In particular HSP and Happstack.
16:53:43 <binrapt> I considered embedding Python for this purpose, but as it turns out CPython is basically not suited for embedding, it doesn't support more than one environment per process and it leaks memory when you try to free it etc
16:54:54 <copumpkin> ew
16:58:27 <darrint_> binrapt, If haskell turns out to not be your thing, factor just got support for multiple environments per process.
16:58:50 <seanmcl> this code is in Agda:
16:58:51 <seanmcl> isSuccess :: Result -> Bool
16:58:51 <seanmcl> isSuccess Success{} = True
16:58:51 <seanmcl> isSuccess _         = False
16:58:56 <seanmcl> what do the curly braces mean?
16:59:01 <seanmcl> after Success?
16:59:07 <copumpkin> empty record match
16:59:18 <copumpkin> basically means you don't care what parameters Success carries
16:59:26 <seanmcl> you can't write Success _
16:59:28 <seanmcl> ?
16:59:33 <copumpkin> well, you can, but that would imply just one parameter
16:59:41 <seanmcl> oh
16:59:44 <copumpkin> if you changed that later, you'd need to change that pattern match everywhere
16:59:51 <binrapt> It's totally beyond me why you would design a scripting API which is not properly modularised, not supporting multiple environments per process
16:59:52 <seanmcl> so {} matches any number of arguments?
16:59:56 <copumpkin> {} means you don't care if it's nullary, unary, or so on
17:00:10 <seanmcl> cool
17:00:11 <copumpkin> yep
17:01:46 <seanmcl> Can you use it in other ways?  I tried case A 1 2 3 of A 5 {} -> 7.  Didn't work.
17:03:20 <copumpkin> nope, sadly
17:03:26 <copumpkin> it's really just abusing record notation
17:03:38 <copumpkin> you can do that with records, but then you need to start naming your fields
17:04:04 <copumpkin> one nice extension though, if you do use a lot of records, is RecordWildcards (or something like that)
17:04:21 <seanmcl> thanks.  I'll check  it out.
17:04:51 <copumpkin> you can then do data Moo = Moo { oink :: Int, baa :: Bool, woof :: Woof } and case x of Moo{..} -> if baa then oink else fromWoof woof
17:05:01 <seanmcl> oh, they stole that from SML
17:05:04 <copumpkin> it automatically brings all the record accessor names into scope
17:05:06 <copumpkin> ah, cool
17:05:18 <copumpkin> I haven't played with *ML much at all
17:05:54 <seanmcl> -XNamedFieldPuns also
17:06:17 <seanmcl> though they seem slightly more expressive in Haskell
17:08:42 <copumpkin> holy crap: Shed Skin consists of only 6,900 lines of Python code, and about 19,000 lines of C++ code (implementation of builtins and library modules). Unfortunately, there is still only one active developer, so please consider joining the project!
17:08:56 <copumpkin> that's a lot of work to go to for something like this...
17:10:09 <binrapt> 981 KiB of code
17:10:09 * copumpkin looks forward to 6.12 and the new shootout results from it
17:10:26 <binrapt> I've never written that much for a single project before, that is indeed a lot
17:10:37 <copumpkin> probably about 1000 lines of haskell ;)
17:11:33 <seanmcl> How about this.  The Agda people are using a macro for exception handling.  It looks like
17:11:35 <seanmcl> zipWithM' f []	     (_ : _)  = {- ' -} __IMPOSSIBLE__
17:11:42 <seanmcl> what's the {- ' -}?
17:11:43 <binrapt> But I wrote 427 KiB of C++ and Python for a Diablo II cheat haha
17:11:48 <seanmcl> If I take it out it doesn't compile.
17:12:04 <binrapt> And another 250 KiB of C++ for another Diablo II cheat :/ pathetic
17:12:19 <Person_> Interesting
17:12:22 <binrapt> copumpkin what does it even do?
17:12:28 <copumpkin> seanmcl: you can take out the = I think
17:12:29 <Person_> I am trying to reverse a list of lists, I type
17:12:35 <Person_> reverse.reverse [[1,2,3],[1,2,3]]
17:12:38 <Person_> to no luck
17:12:39 <copumpkin> seanmcl: there's also an #agda channel
17:12:49 <binrapt> Oh "Shed Skin is an experimental compiler that translates pure but implicitly statically typed Python programs into optimized C++"
17:13:08 <copumpkin> Person_: if you just want to reverse the external one, reverse is enough
17:13:13 <copumpkin> > reverse [[1,2,3],[1,2,3]]
17:13:13 <seanmcl> reverse . map reverse $ [[1,2,3], [1,2,3]]
17:13:15 <lambdabot>   [[1,2,3],[1,2,3]]
17:13:15 <sproingie> translate it into haskell
17:13:26 <Peaker> binrapt, not our kind of "pure"
17:13:52 <seanmcl> copumpkin: so {- ' -} is not a Haskell primitive
17:14:00 <seanmcl> something agda cooked up?
17:14:07 <copumpkin> seanmcl: I've never seen that before :)
17:14:10 <Person_> No luck...
17:14:11 <copumpkin>  (in agda or haskell)
17:14:20 <sproingie> i have a hard time with the shootout results from haskell when much of it is so godawfully unidiomatic
17:14:20 <Person_> reverse . map reverse [[1,2,3],[1,2,3]]
17:14:28 <copumpkin> you need the $
17:14:30 <seanmcl> they include
17:14:31 <sproingie> some of it looks like C in haskell
17:14:31 <seanmcl> #define __IMPOSSIBLE__ (throwImpossible (Impossible __FILE__ __LINE__))
17:14:31 <copumpkin> or more parentheses
17:14:35 <Person_> gotcha
17:14:55 <copumpkin> seanmcl: oh interesting, agda preprocesses the file with CPP first?
17:14:55 <sproingie> tho chameneos kicked ass even with idiomatic code
17:15:00 <seanmcl> yeah
17:15:12 <seanmcl> but I don't know what happens to the {- ' -} thing.
17:15:23 <copumpkin> sproingie: well often there's a slightly slower one that's very much more idiomatic
17:15:37 <copumpkin> seanmcl: dunno :/ but I normally just leave it out altogether
17:15:39 <Person_> HAHA
17:15:42 <Person_> haskell is so cool!
17:15:44 <Person_> =)
17:15:48 <copumpkin> :)
17:15:52 <copumpkin> note that $ isn't syntax
17:16:00 <copumpkin> it's just another function/operator
17:16:08 <Person_>  map reverse $[[1..10],[5..10]]
17:16:14 <Person_> amazing!
17:16:22 <copumpkin> > map reverse $ [[1..10], [5..10]]
17:16:23 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1],[10,9,8,7,6,5]]
17:16:32 <Person_> That is incredible
17:16:35 <Person_> doing that would take at least
17:16:37 <Person_> 5 minutes in java
17:16:41 <copumpkin> :)
17:16:45 <Person_> or more
17:16:49 <Person_> defining the main class
17:16:52 <Person_> defining the object
17:16:53 <seanmcl> > .
17:16:54 <Person_> constructor
17:16:54 <lambdabot>   <no location info>: parse error on input `.'
17:16:57 <Person_> importing ArrayList, etc.
17:16:59 <Person_> LOL
17:17:01 <copumpkin> we can show you some ridiculous haskell golf if you'd like
17:17:02 <seanmcl> > (.)
17:17:02 <Person_> <3 haskell
17:17:02 <sproingie> assume you have an ide to automate that stuff
17:17:03 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
17:17:03 <lambdabot>                    GHC.Show...
17:17:11 <sproingie> it would still get lost in the boilerplate tho
17:17:29 <copumpkin> > fix ((0:) . scanl (+) 1) -- Person
17:17:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:17:52 <Person_> lol
17:17:54 <Person_> fibonacci
17:17:58 <sproingie> @src fix
17:17:59 <lambdabot> fix f = let x = f x in x
17:18:01 <Person_> hahaha that's just fantastic
17:18:21 <copumpkin> > nubBy isMultipleOf [2..] -- Person
17:18:21 <sproingie> that alone is awesome
17:18:22 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:18:25 <copumpkin> damn
17:18:30 <copumpkin> I keep getting it backwards
17:18:38 <aavogt> heh
17:18:46 <copumpkin> > nubBy isMultipleOf [2..] -- Person
17:18:48 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:18:49 <copumpkin> there we go
17:19:03 <Person_> lol
17:19:04 <sproingie> i wonder if there's a way to make haskelldoc-mode show source
17:19:13 <Person_> Implementing trees in haskell though
17:19:17 <Person_> bit of a challenge, no?
17:19:17 <Warrigal> GHC prefers modules that call themselves Main, right?
17:19:21 <copumpkin> Person_: not at all
17:19:25 <Warrigal> Does the name of a module have to have anything to do with its filename?
17:19:32 <copumpkin> Person_: you simply must use the cofree comonad of [] ;)
17:19:34 <sproingie> trees are ridiculously easy in haskell
17:19:43 <aavogt> that needs a Data.List import, and the definition of isMultipleOf in terms of mod
17:19:47 <Person_> To construct, or to operate on?
17:19:49 <Warrigal> Can I nicely keep two programs in one directory?
17:19:49 <copumpkin> Person_: just kidding, you can define them without any fancy mathy names
17:19:52 <sproingie> updating them efficiently gets a little fiddly
17:19:53 <copumpkin> Person_: both
17:20:02 <sproingie> i still don't really grok zippers
17:20:27 <Person_> Interesting
17:20:27 <ivanm> that "RETURNED MAIL" message in -cafe... was that spam?
17:20:35 <ivanm> or a trojan or something?
17:20:38 <Person_> A homework assignment asks to reverse a tree, completely and recursively
17:20:50 <Person_> Having a bit of trouble with it, trying to learn the basics of tree operations in haskell
17:20:54 <shepheb> ah, no, needs an import. hrm.
17:20:55 <Cale> Person_: The language practically has a feature for implementing trees.
17:20:56 <Peaker> Person_, every left child with right child?
17:20:57 <copumpkin> Person_: what's your tree structure?
17:21:06 <Person_> Binary tree
17:21:11 <copumpkin> I mean
17:21:12 <aavogt> Warrigal: the module only has to match the filename if you want to import it from some other file.
17:21:14 <copumpkin> how did you define it?
17:21:18 <Warrigal> Okay.
17:21:22 <Person_> as a module
17:21:26 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a) -- here's a decent binary tree
17:21:32 <Person_> data Tree a = Leaf a | Node a (Tree a) (Tree a)
17:21:36 <copumpkin> ok :)
17:21:41 <Cale> Okay, pretty close :)
17:21:43 <Person_> I don't want to get expelled,
17:21:51 <Person_> Don't tell me how to do it haha
17:21:56 <copumpkin> we won't!
17:22:05 <Cale> Person_: do you know about pattern matching?
17:22:09 <Peaker> Person_, if your Leaf becomes a Node with two Tips in it, then you don't need the "a" in it
17:22:09 <ivanm> us? help you? don't be absurd! :p
17:22:11 <Person_> Cale: No
17:22:23 <Warrigal> So I can have foo/servermain.hs, foo/serverback.hs, foo/clientmain.hs, foo/clientback.hs, foo/helper.hs and call them Main, ServerBack, Main, ClientBack, and Helper, respectively.
17:22:43 <Cale> Person_: You probably can't write any functions at all which operate on trees without knowing a bit about pattern matching.
17:22:51 <Cale> (well, any nontrivial ones anyway)
17:23:10 <ivanm> Warrigal: you can have more than one program in the same directory if their modules don't clash
17:23:17 <ivanm> but is there any reason for doing so?
17:23:29 <Cale> Person_: So, it just works by writing definitions of your function for each of the two cases defined in the data declaration
17:23:40 <Cale> f (Leaf x) = ...
17:23:45 <Cale> f (Branch x l r) = ...
17:24:09 <Warrigal> Not that much, I suppose. They'll probably share some functions.
17:24:13 <Cale> So on the right hand side of each of those = signs, you can refer to the parts of the tree (x, l, and r) which were matched on the left.
17:24:46 <Person_> Cale: Interesting
17:24:57 <copumpkin> Person_: the patterns can be arbitrarily complex (so you could envision updating a balanced binary tree by making your matching deeper)
17:25:07 <Warrigal> Though the client's back end might include the server's back end, I suppose...
17:25:16 <ivanm> Warrigal: right, thta makes sense then
17:25:21 * Warrigal nods.
17:25:28 <Person_> I'm having trouble understanding how the tree declaration works though
17:25:32 <ivanm> if it gets too big, you might want to split it up into a common library, and then two applications that use that library
17:25:39 <mmorrow> rotl (Bin l (Bin rl rr)) = Bin (Bin l rl) rr
17:25:44 <Warrigal> Heck, I might not even make the client and the server separate applications.
17:26:40 <Axman6> Person_: what's the trouble?
17:26:46 <Warrigal> So I could have main.hs, server.hs, client.hs, and helper.hs, where main.hs is the front end, server.hs and client.hs are the back ends, and helper.hs contains abstract helpful stuff.
17:27:20 <Peaker> Warrigal, I hate misc/utils/helper names for stuff.. can't helper be split into whatever stuff it has in it?
17:27:21 <Cale> Person_: okay, the syntax of a data declaration is basically  data <Name of type being defined> <type parameters...> = <case 1> | <case 2> | ..., where each case consists of a name of a data constructor (must start with an uppercase letter), and a sequence of types, separated by spaces, which are the types of the parameters to that data constructor
17:27:31 <Person_> Axman6: In the definition, I do not understan the purpose of the pipe
17:27:40 <Person_> Axman6: As well as why each elem can be called a
17:27:47 <Cale> Person_: The | symbol in the data declaration just separates each of the possible cases.
17:28:06 <Cale> Person_: So your definition  data Tree a = Leaf a | Branch a (Tree a) (Tree a) says:
17:28:07 <ivanm> Peaker: well, if you just have a module full of common utility functions used in your project, what's wrong with Utils.hs ?
17:28:07 <Axman6> Person_: it's sating that a tree is either a Leaf with an a, or an Branch, w9ith an a, and two sub-trees
17:28:07 <Person_> ok
17:28:17 <Cale> Person_: A Tree of values of type a is either:
17:28:27 <mmorrow> void rotl(Tree *t){ Tree *tmp; tmp = t->r->r; t->r->r = t->r->l; t->r->l = t->l; t->l = t->r; t->r = tmp; return;} /* omg i have no idea if this is right :) */
17:28:29 <Cale> Person_: 1) The data constructor Leaf applied to a value of type a
17:28:32 <copumpkin> mmorrow: lol
17:28:34 <mmorrow> rotl (Bin l (Bin rl rr)) = Bin (Bin l rl) rr
17:28:34 <Warrigal> Peaker: I could call it something more descriptive, like math.hs.
17:28:37 <mmorrow> heh
17:28:39 <Person_> mmorrow: you're going to get me expelled buddy
17:28:42 <Person_>  didn't see that
17:28:47 <copumpkin> Person_: nah, it's nothing you need :)
17:28:50 <Cale> Person_: or 2) The data constructor Branch applied to a value of type a, and two trees of values of type a
17:29:03 <Peaker> ivanm, if the best name for what the module does is "utils", usually it means its not grouped meaningfully.. split "utils" to little modules named by the functionality in them.. meaningful names
17:29:06 <Axman6> Person_: luckily that's C, not haskell ;)
17:29:18 <ivanm> Peaker: right, so one module per function...
17:29:23 <Person_> Axman, he followed it up ;-)
17:29:31 <ivanm> (OK, maybe not quite so split up)
17:29:32 <Cale> Person_: does that explanation make sense?
17:29:40 <Axman6> not with anything that helps you Person_ ;)
17:29:41 <mrsolo_> hmm HSH is it good to use? or there is something better?
17:29:55 <Person_> Cale: That makes a lot of sense
17:30:03 <Peaker> ivanm, I would even have a module for 1 function, if its the only one that has to do with a certain thing -- allows for a place to add more things related to that concept :)  If I don't want to do that, I just put the function where it is used
17:30:08 <Cale> Person_: So, for example, a value of type Tree Integer might be   Branch 5 (Branch 3 (Leaf 1) (Leaf 4)) (Leaf 7)
17:30:33 <Person_> Cale, understood, now how to access that internal data?
17:30:43 <ivanm> Peaker: *nod* each to their own, I suppose
17:30:45 <Axman6> you need to use recursion
17:30:47 <Peaker> mmorrow, I just wrote an RBTree in C recently.. it can be clearer than that :)
17:30:50 <Cale> and when pattern matched with a pattern like (Branch x l r), then x = 5, l = Branch 3 (Leaf 1) (Leaf 4), and r = Leaf 7
17:31:13 <Person_> I think I see what's going on
17:31:20 <Person_> You abstract the data to be x, l, and r
17:31:20 <Peaker> ivanm, if there are "utils" and "misc" modules about, it destroys my ability to guess where things are hosted
17:31:24 <Warrigal> Now, I suppose I'm wondering if there's a proper term for a network in which there are nodes of type A and B, and each A is connected to exactly one B, and Bs connect with each other freely.
17:31:27 <Person_> Then define operations on the abstracted x l and r
17:31:32 <mmorrow> Peaker: ooh neat, is it online anywhere? (here's my C intmap http://moonpatio.com/repos/intmap-c/ , yay union)
17:31:36 <Person_> such that x is unchanged, l and r are switched
17:31:39 <Cale> Person_: right, x, l, and r refer to the parts of the structure which are being matched
17:31:41 <Warrigal> If there were only the former connections, it would be client-server; if there were only the latter, it would be peer-to-peer.
17:31:42 <ivanm> Peaker: *cough* documentation *cough*
17:31:43 <ivanm> ;-)
17:31:46 <Peaker> mmorrow, It was for work, so now is propietary :-(
17:31:49 <Person_> Cale: This makes me want to rage so hard
17:31:51 <Cale> Person_: ah, yeah, for flipping the tree, you'd want to do that
17:31:54 <Person_> Cale: No pointers....
17:31:54 <mmorrow> Peaker: aww :)
17:32:02 <Cale> Person_: Pointers just overcomplicate things.
17:32:04 <Axman6> Person_: pointers--
17:32:08 <Peaker> mmorrow, its basically like the Linux one, I think, though I only glimpsed at it
17:32:13 <Peaker> mmorrow, (Its intrusive)
17:32:14 <Person_> flipping a tree with pointers is soooo easy
17:32:21 <Cale> Person_: this is so much easier
17:32:27 <Person_> Cale: Probably
17:32:31 <Axman6> Person_: it's eay easier in haskell imo
17:32:33 <Person_> Cale: going to hack @ this for 15-30 mins
17:32:38 <monochrom> flip (Branch x l r) = Branch x r l
17:32:38 <Axman6> way*
17:32:40 <Person_> I'll leave you guys alone for now
17:32:42 <ivanm> Peaker: e.g. I used it for SourceGraph when doing the analysis stuff; I had a Everything, Imports and Module modules, and then Utils.  Utils was mainly visualisation with a couple of extra ones thrown in
17:32:56 <monochrom> r, l are pointers too.
17:32:57 <Axman6> Person_: stick around, ask questions
17:33:05 <Peaker> ivanm, may I suggest "Visualization" as an alternate name? :)
17:33:12 <Cale> monochrom: Of course, that just swaps the top branch.
17:33:20 <monochrom> Given immutability, "the whole tree" and "pointer to the whole tree" need no distinction.
17:33:20 <ivanm> Peaker: well, it started off as other stuff then I put visualisation functions in there...
17:33:23 <Cale> (rather than flipping the whole tree)
17:33:34 <ivanm> Peaker: and the other stuff is still mainly there
17:34:21 <Peaker> mmorrow, I like intrusive data structures cause they usually free you from having to malloc. Not sure if intmap can do that though
17:34:28 * ddarius wishes there was an implementation of CLF.
17:34:38 <copumpkin> CLF?
17:34:41 <Axman6> Person_: the important thing about pattern matching is that it allows you to think more clearly about what need to be done with each case. for example, how do you reverse Leaf 7?
17:34:49 <ddarius> copumpkin: Concurrent Logical Framework
17:34:51 <Cale> Person_: another really nice way to do it is to define an operation foldTree which takes two functions l and n, and a tree, and replaces each Leaf constructor in the tree with l, and each Node constructor with n
17:34:51 <ivanm> @wn CLF
17:34:51 <copumpkin> ah
17:34:53 <lambdabot> No match for "CLF".
17:35:05 <monochrom> "flip" is an English word and I never know how much to flip. Do you want to "flip" the whole tree?
17:35:06 <ivanm> ddarius: see? even lambdabot doesn't know what you're talking about :p
17:35:10 <Cale> Peaker: many many natural operations on trees are immediate applications of that function
17:35:19 <Person_> Every l node becomes the r node
17:35:23 <Person_> every r node becomes the l node
17:35:27 <monochrom> flip_the_whole_tree (Branch x l r) = Branch x (flip r) (flip l)
17:35:34 <ddarius> ivanm: Most programs don't.
17:35:41 <monochrom> err
17:35:45 <Cale> monochrom: He didn't want an answer.
17:35:45 <ivanm> ddarius: heh
17:35:46 <copumpkin> Person_: and how about tips?
17:35:52 <monochrom> flip_the_whole_tree (Branch x l r) = Branch x (flip_the_whole_tree r) (flip_the_whole_tree l)
17:35:57 <Person_> The root node is a root
17:36:04 <Person_> Everything below that is switched
17:36:07 <Person_> And then recursively
17:36:12 <copumpkin> Person_: I mean, what if you get a Tip
17:36:15 <mmorrow> Peaker: hmm, i've never heard the term instrusive before actually, but i like when the datastructure mallocs/frees its own structural pieces, and doesn't touch/care about what's being stored inside (and everything takes a (foo_t**))
17:36:38 <ddarius> mmorrow: Parametricity.
17:36:53 <Person_> copumpkin: Then it is unchanged
17:37:04 <copumpkin> Person_: cool, so you can write that almost exactly as you described it
17:37:07 <Cale> Person_: So in English, the flip of a tree which is a branch is a branch whose left subtree is the flipped version of the original tree's right subtree, and whose right subtree is the flipped version of the original tree's left subtree.
17:37:09 <Axman6> Person_: so... reverse (Left x) = ?
17:37:09 <Peaker> mmorrow, do you point at the nodes, or do you get contained by them?
17:37:11 <mmorrow> ddarius: hmm, i more meant wrt malloc/free, but yeah that too i prefer (void* ftw)
17:37:24 <mmorrow> Peaker: you get contained by them
17:37:36 <mmorrow> err, wait
17:37:38 <Peaker> mmorrow, at the beginning, it sounds like?
17:37:39 <mmorrow> who is "you"
17:37:42 <mmorrow> ?
17:38:05 <Peaker> mmorrow, the generic data structure nodes
17:38:10 <copumpkin> Axman6: not sure you meant that :)
17:38:11 <ddarius> mmorrow: If you could use parametrically polymorphic types in C, you would have more information on whether or not a type is malloced/freed.  (void * does give the capability to free)
17:38:22 <Axman6> heh, no, i didn't :P
17:38:36 <mmorrow> Peaker: it basically operates of keys of void* and values of void*
17:38:38 <Peaker> mmorrow, for example, do you have struct list { struct list *prev, *next; }  or do you have a void* in there?
17:38:44 <Axman6> Person_: what i meant was: reverse (Leaf x) = ?
17:38:46 <mmorrow> oh, yeah void*
17:38:57 <Peaker> mmorrow, intrusive data structures avoid the need for that void*
17:39:07 <mmorrow> Peaker: ah, ok.
17:39:12 <zxc> anyone had experience with hs-dotnet?
17:39:23 <copumpkin> sigbjorn finne does
17:39:42 <mmorrow> Peaker: so what would this look like re-done as an intrusive structure:
17:39:44 <Peaker> mmorrow, you just hole a   struct list   inside your struct, and use a macro that converts &your_struct->some_list  to &your_struct.  Then &your_struct can also be in multiple lists in the same time
17:39:46 <Person_> haha wow
17:39:52 <Person_> Haskell can handle arbitrarily large numbers
17:39:54 <Person_> 9999^9999
17:39:56 <copumpkin> Person_: yep :)
17:39:57 <Cale> Person_: indeed
17:40:03 <Person_> > 9999^9999
17:40:04 <lambdabot>   367897836216551579269262598478356580455025438573477618640185661384561636087...
17:40:11 <Person_> > 999999999999^9999999999999999
17:40:16 <lambdabot>   mueval: ExitFailure 1
17:40:19 <zxc> i have cabal installed it, have .net 3.0, running on of the examples throws up "NET bridge error"
17:40:21 <copumpkin> > length . show $ 9999 ^ 9999
17:40:22 <lambdabot>   39996
17:40:24 <Axman6> that will take a while...
17:40:24 <Cale> At some point, you'll run out of time and/or space :)
17:40:26 <copumpkin> almost 4000 digits
17:40:27 <Person_> ha ha ha
17:40:30 <copumpkin> 40000
17:40:31 <Peaker> mmorrow, the generic linked list code only manages linked lists of (struct list) without having to deal with malloc/free.  The guys using list can use any memory scheme they want
17:40:36 <mmorrow> Peaker: struct tip {void *k; void *v;}; struct bin {Pre pre; Mask mask; IntMap *l; IntMap *r;};
17:40:39 <Person_> let's see how smart haskell really is
17:40:42 <Person_> > 9999 / 0
17:40:43 <lambdabot>   Infinity
17:40:46 <Person_> :(
17:40:55 <Person_> I was expecting the truth
17:40:56 <monochrom> Is this a provocative troll?
17:40:57 <Cale> That's IEEE Double
17:41:12 <Person_> monochrom: Not trolling you guys, I'm just learning haskell
17:41:13 <Cale> > 9999 `div` 0
17:41:21 <lambdabot>   * Exception: divide by zero
17:41:21 <Axman6> Person_: what did you expect 9999/0 to be?
17:41:27 <mmorrow> (struct IntMap {Tag tag; Nat data[];/* in retrospect would've stuck a tag in each of tip/bin, and punned*/})
17:41:30 <dolio> What's the truth?
17:41:31 <Person_> Axman6: The secret... to the universe? just kidding around
17:41:37 <Cale> > 0^0
17:41:38 <seanmcl> zxc: I won't be any help, but am interested in your experience.  I visited MSR last month and they were pushing F# in .Net.  I wonder how it compares with Haskell.net
17:41:38 <lambdabot>   1
17:41:44 <Cale> ^^ I love that we get this right :)
17:41:45 <SamB_XP> > 9999 `div` 0 :: Nat
17:41:46 <lambdabot>   Not in scope: type constructor or class `Nat'
17:41:47 <Axman6> Person_: anyway, you didn't answer my question earlier :P
17:41:48 <SamB_XP> > 9999 `div` 0 :: Natural
17:41:53 <lambdabot>   mueval-core: Time limit exceeded
17:41:54 <Person_> Axman6: Your question was?
17:42:06 <Axman6> reverse (Leaf x) = ...?
17:42:10 <SamB_XP> Person_: well, if you wait long enough, it seems you get the truth ;-P
17:42:14 <Peaker> mmorrow, gotta go, hope I remember to discuss this further later :)
17:42:18 <mmorrow> Peaker: right, i'm clear on that part, but i'm not exactly clear on the "intrusive"
17:42:19 <mmorrow> ok
17:42:21 <mmorrow> see ya
17:42:30 <Person_> Axman6: reverse(Leaf x) won't do anything
17:42:37 <Peaker> mmorrow, intrusive just means that the data structure data is inside the user's struct, rather than points at it
17:42:38 <Axman6> so, what does it equal?
17:42:40 <zxc> seanmcl: i'm just trying to make this thing working
17:42:41 <Person_> that operation is on the leaf as a tip
17:42:41 <Peaker> gone...
17:42:42 <Cale> Person_: It's still got to have some value.
17:42:46 <Person_> reverse (Leaf x) = x?
17:42:47 <mmorrow> Peaker: oh. ok, i gotcha.
17:42:51 <Axman6> not quite
17:42:55 <Cale> Person_: It should be a tree, shouldn't it?
17:43:04 <Person_> Is it being treated as a leaf? or as a tip?
17:43:16 <Person_> If it's being treated as a leaf w/ an associated tip, then it gets reassigned to the opposite branch
17:43:21 <Person_> If it's treated as a tip... then nothing
17:43:28 <Cale> Person_: well, you gave  data Tree a = Leaf a | Node a (Tree a) (Tree a), yeah?
17:43:44 <mmorrow> ddarius: yeah, usually i have the freeFoo function take a function ptr to free the contained values
17:43:44 <Person_> yes
17:43:53 <mmorrow> ddarius: (if desired)
17:43:57 <Cale> Person_: That's the nice thing, that  Leaf x  is the *whole* tree that you're flipping.
17:43:59 * ddarius wonders what would happen if he made a dependently type C.
17:44:00 <Axman6> only things of the form Leaf x, or Branch x l r are trees righgt?
17:44:02 <Axman6> -g
17:44:09 <Cale> Person_: So which tree is the result?
17:44:11 <SamB_XP> ddarius: typed C?
17:44:31 <ddarius> dependently typed, yes.
17:44:38 <Cale> x wouldn't be a tree in general, because it might be (Leaf 5), say
17:44:43 <Cale> so x = 5 there
17:44:48 <Person_> Cale: Then it will just return (leaf 5)
17:44:52 <Cale> Person_: right
17:45:01 <Axman6> LEaf 5* ;)
17:45:02 <dolio> C with types? How novel!
17:45:08 <Axman6> argh, sticky shift
17:45:11 <Cale> Person_: so  flipTree (Leaf x) = what? :)
17:45:14 <Axman6> Leaf 5*
17:45:16 <Person_> x
17:45:20 <Cale> Not x
17:45:20 <Axman6> no!
17:45:21 <Axman6> :P
17:45:25 <Person_> flipTree(leaf x) = Leaf x?
17:45:30 <Axman6> yes!
17:45:30 <Cale> flipTree (Leaf 5) = Leaf 5
17:45:38 <Person_> NO
17:45:41 <SamB_XP> Cale: that won't typecheck!
17:45:41 <ddarius> C has types, it just doesn't have type soundness, some unimportant thing those ivory tower academics get in a tizzy about.
17:45:42 <Axman6> yes!
17:45:45 <Person_> flipTree(Leaf 5) = Tree 5
17:45:50 <Axman6> no!
17:45:55 <Cale> SamB_XP: It's not polymorphic, but it's an equation that we want to satisfy.
17:45:59 <SamB_XP> ddarius: you're sure those things are types ?
17:46:07 <ddarius> SamB_XP: Yes.
17:46:08 <Axman6> Person_: you were right the first time :)
17:46:11 <Cale> Person_: Tree is a type constructor, not a data constructor
17:46:19 <Axman6> flipTree (Leaf x) = Leaf x
17:46:28 <SamB_XP> ddarius: they look more like "guidelines" than actual types
17:46:32 <mmorrow> C types are basically "n", for each n `in` [1..] bytes
17:46:42 <ddarius> mmorrow: If only.
17:46:54 <ddarius> Cryptol is way better there.
17:46:59 <Warrigal> Hmm, I pretty much want math.hs to be a Haskell version of Metamath. Metamath already exists, though.
17:47:13 <Person_> Interesting
17:47:16 <MyCatVerbs> ddarius: (let x = x in x) -- and Haskell does?
17:47:17 <mmorrow> ddarius: heh, of course they're named random things that give no info as to which "n" they are ;)
17:47:23 <Person_> Now I will test the floating point capabilities of Haskell,
17:47:25 <Person_> I am expecting 20
17:47:28 <mmorrow> that's the fun part!
17:47:34 <Person_> > e^pi - pi
17:47:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:47:35 <lambdabot>    `GHC.Real.Integral a'
17:47:35 <lambdabot>   ...
17:47:38 <Warrigal> Nicely, "Hmm" is the name of a Haskell library for Metamath.
17:47:44 <Axman6> > exp pi - pi
17:47:44 <mmorrow> (fun part @ named random things)
17:47:44 <Person_> > (e^pi) - pi
17:47:45 <lambdabot>   19.999099979189474
17:47:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:47:45 <lambdabot>    `GHC.Real.Integral a'
17:47:45 <lambdabot>   ...
17:47:57 <MyCatVerbs> Person_: We've all read that particular XKCD strip.
17:48:01 <Axman6>  exp pi - pi ~= 20
17:48:03 <Warrigal> > round (exp pi - pi)
17:48:04 <lambdabot>   20
17:48:05 <SamB_XP> Person_: programming languages don't tend to have a constant named "e"
17:48:07 <Person_> :-p
17:48:11 <Axman6> > exp pi - pi :: CReal
17:48:12 <lambdabot>   19.9990999791894757672664429846690444960689
17:48:12 <Warrigal> See, it works.
17:48:24 <ddarius> MyCatVerbs: I'm not sure why you directed that at me and/or what your intent was.
17:48:48 <SamB_XP> ddarius: have type soundness
17:48:51 <MyCatVerbs> ddarius: Oh, I'm sorry. "< ddarius> C has types, it just doesn't have type soundness, some unimportant thing those ivory tower academics get in a tizzy about."
17:49:13 <Cale> > exp (pi * sqrt 163)
17:49:14 <lambdabot>   2.6253741264076826e17
17:49:17 <Cale> > exp (pi * sqrt 163) :: CReal
17:49:19 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
17:49:19 * MyCatVerbs hugs .
17:49:20 <Axman6> Person_: so anyway. how do you flip a branch of a tree? flipTree (Branch x l r) = Branch ...?
17:49:25 <mmorrow> MyCatVerbs: let x = x in x  is clearly :: ((),Float)
17:49:28 <MyCatVerbs> Whups, wrong channel.
17:49:34 <Person_> Axman6: flipTree (Branch x l r ) = Branch x r l
17:49:36 <SamB_XP> Cale: what the heck ?
17:49:39 <Cale> Person_: close
17:49:40 <Axman6> Person_: almost
17:49:52 <MyCatVerbs> mmorrow: Sure. Amongst other things. :)
17:49:53 <Cale> Person_: Except that you don't just want to flip the top level, right?
17:49:54 <Axman6> Person_: aren't l and r also trees?
17:49:55 <SamB_XP> Cale: ... why the heck did the decimal jump a bunch of digits there ?
17:50:02 <Person_> YES
17:50:03 <Cale> SamB_XP: e17
17:50:14 <SamB_XP> Cale: ahhhh
17:50:15 <Axman6> so... do l and r also need to be flipped?
17:50:16 <Person_> flipTree(branch x l r ) = Branch x flipTree(r) flipTree(l)
17:50:28 <Cale> Person_: close, but your parens are wrong
17:50:30 <MyCatVerbs> e17?
17:50:34 <Axman6> looks good :)
17:50:44 <Cale> Person_: (flipTree r) and (flipTree l)
17:50:50 <mmorrow> MyCatVerbs: imo non-termination is a whole different story than trying to deref floats
17:50:56 <mmorrow> ;)
17:50:56 <Axman6> flipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)
17:51:01 <Person_> flipTree(branch x l r) = Branch x (fliptree r) (fliptree l) ....
17:51:02 <Cale> Person_: also, watch the caps.
17:51:12 <Cale> Branch must have an uppercase B
17:51:21 <Person_> There's no way that's going to work....
17:51:28 <Cale> Person_: why?
17:51:30 <Axman6> i'll bet you $2 it will
17:51:32 <Person_> What happens if you have a solo leaf
17:51:42 <Cale> Person_: then the other equation we already wrote is used
17:51:42 <Person_> like a tip, with one leaf
17:51:49 <copumpkin> Person_: you add a pattern for that
17:51:55 <Axman6> you've already defined what happens for flipTree (Leaf x) right?
17:52:06 <Person_> What I mean is, flipTree (Branch x l)
17:52:12 <Axman6> flipTree (Leaf x) = Leaf x
17:52:14 <Cale> Person_: There is no such thing.
17:52:17 <Axman6> flipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)
17:52:26 <Person_> It doesn't have to be a full binary tree
17:52:28 <Cale> Person_: A binary tree either has two subtrees, or it is a leaf.
17:52:36 <copumpkin> Person_: oh?
17:52:47 <copumpkin> Person_: your data definition earlier does
17:52:55 <Cale> Person_: This is a bit of a strange structure for putting values on the leaves though.
17:52:57 <SamB_XP> Person_: hmm, you may need to redo your "data" definition
17:53:03 <Person_> Well, the data definition is given
17:53:06 <Person_> So I am being a big dummy
17:53:06 <copumpkin> if one of the branches can be missing, you'll need to change your data definition slightly
17:53:08 <Person_> Thanks guys
17:53:10 <copumpkin> oh :)
17:53:12 <Cale> A better binary tree is  data Tree a = Tip | Branch a (Tree a) (Tree a)
17:53:15 <Axman6> Person_: what do you think Branchy 3 (Branch 2 (Leaf 1) (Leaf 2)) (Leaf 6) is?
17:53:22 <copumpkin> Branchy!
17:53:24 <Axman6> -y
17:53:34 <SamB_XP> if the def is given, maybe you just don't understand the structure you're supposed to use?
17:54:09 <Cale> Person_: If you apply the Branch constructor to too few arguments, you'll get a function which takes the rest of the args and produces a tree
17:54:16 <Person_> awesome
17:54:24 <Person_> Now to implement the polymorphism
17:54:29 <pumpkin> polymorphism?
17:54:31 <Cale> Person_: done.
17:54:38 <Cale> Person_: the code you wrote is polymorphic
17:54:38 <pumpkin> it already works on any type!
17:55:00 <mmorrow> omg pumpkin is back
17:55:08 <pumpkin> mmorrow: omg I'm about to disappear again :P
17:55:09 <Person_> You're right
17:55:09 <Axman6> :O
17:55:15 <mmorrow> pumpkin: oh noes!
17:55:24 <pumpkin> :)
17:55:26 <Cale> Person_: Those two lines are the whole definition. No fucking around with pointers and manually overloading things on various types :)
17:55:40 <Axman6> Person_: now, make sure you understand the code, and convince yourself that it will indeed flip any tree it is given
17:55:54 <Person_> Axman6: sure thing, just putting it together in the .hs file
17:56:03 <pumpkin> flip dat tree
17:56:09 <Axman6> :)
17:56:22 <gOcOOl> 'main = interact $ show . map ((!! 7) . words) . filter (=~ "Reply rate") . lines' works just fine and returns a list of strings representing numbers as expected but the moment i change it to:
17:57:01 <gOcOOl> 'main = interact $ show . sum . map (read . (!! 7) . words) . filter (=~ "Reply rate") . lines' it fails with "prelude read no parse" error each time
17:57:08 <SamB_XP> *implement* the polymorphism indeed!
17:57:16 <Axman6> Person_: you'll soon see that haskell makes it much easier to reason about what you're doing. you don't have to worry about pointers and that useless crap, you just write what you mean, anfd it's all done
17:57:37 <pumpkin> @type main = interact $ show . sum . map (read . (!! 7) . words) . filter (=~ "Reply rate") . lines
17:57:39 <seanmcl> does anyone have Hat (tracer) working with 6.10.[1..4]?
17:57:40 <lambdabot> parse error on input `='
17:57:40 <dolio> flip :: Tree (Ptr Void) -> Tree (Ptr Void)
17:57:44 <pumpkin> @type let main = interact $ show . sum . map (read . (!! 7) . words) . filter (=~ "Reply rate") . lines in main
17:57:45 <lambdabot> IO ()
17:57:47 <Axman6> gOcOOl: you need to speficy the sype that show is reading
17:57:49 <Cale> dolio: ehehe
17:58:00 <Warrigal> @type (=~)
17:58:01 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
17:58:04 <SamB_XP> seanmcl: you mean sometimes it doesn't segfault midway through viewing a trace ?
17:58:04 <Axman6> type*
17:58:07 <Warrigal> Eep.
17:58:08 <mmorrow> dolio: pfft. flipTree :: Ptr a -> Ptr a
17:58:16 <seanmcl> no, I can't get it to compile at all
17:58:19 <seanmcl> on linux or mac
17:58:20 <gOcOOl> Axman6: how is it that it complies just fine then?
17:58:20 * pumpkin goes poof!
17:58:37 <pumpkin> gOcOOl: it'll probably work if you pass it () in a string
17:58:38 <Axman6> gOcOOl: because >_>
17:58:40 <ivanm> pumpkin: please keep your sexual preferences to yourself! :p
17:58:44 <seanmcl> SamB_XP: yours is working?
17:58:48 <SamB_XP> seanmcl: no!
17:58:49 <pumpkin> ivanm: :O
17:58:51 <SamB_XP> never has!
17:58:51 <seanmcl> (modulo segfaults)
17:58:54 <Person_> crap
17:58:56 <SamB_XP> it always segfaulted for me
17:58:59 <Person_> I'm being passed in a tree
17:59:02 <SamB_XP> and I haven't tried it lately
17:59:06 <Person_> And do not know how to extract the x,l,r
17:59:08 <pumpkin> buhbye
17:59:11 <Axman6> gOcOOl: replace read with (read :: <numtype you want to read> -> String)
17:59:21 <seanmcl> SamB_XP: darn.  I could really use it now.
17:59:32 <ivanm> pumpkin: aren't you aware of that pejorative?
18:00:35 <Axman6> Person_: flipTree (Branch x l r) assign x to whatever the value at that node is, and l and r to the left and right trees
18:00:43 <gOcOOl> Axman6: isn;t it supposed to be the other way round?
18:00:56 <gOcOOl> i.e. main = interact $ show . sum . map ((read::String -> Int) . (!! 7) . words) . filter (=~ "Reply rate") . lines
18:01:00 <Axman6> gOcOOl: good call! yes, sorry :P
18:01:09 <gOcOOl> still no luck though
18:01:23 <monochrom> Do you have an input file to reproduce your problem
18:01:40 * Axman6 needs breakfast
18:02:46 <gOcOOl> monochrom: sure, how about a file with a bunch of "tfk7.cap2: Reply rate [replies/s]: min 73.0 avg 143.8 max 319.0 stddev 117.7 (4 samples)" repeating lines?
18:04:58 <monochrom> Something defaulted to Integer but 143.8 is not integer.
18:05:12 <monochrom> > read "143.8" :: Double
18:05:13 <lambdabot>   143.8
18:05:19 <monochrom> > read "143.8" :: Integer
18:05:20 <lambdabot>   * Exception: Prelude.read: no parse
18:05:27 <ddarius> MyCatVerbs: _|_ is a legitimate value of a type, so Haskell does (modulo unsafePerformIO and/or, obviously, unsafeCoerce and, uh, the entire Foreign hierarchy)
18:05:37 <monochrom> replace String->Int by String->Double
18:06:09 <Warrigal> Is it considered safe to use unsafePerformIO to read from an MVar that I know will only be written once?
18:06:17 <Warrigal> I mean, I don't see why it wouldn't be.
18:06:24 <gOcOOl> monochrom: ahhh, good catch, that did it!
18:06:26 <gOcOOl> thanks!
18:06:35 <monochrom> Once again, the scientific method triumphs over idle chatter.
18:06:38 <Rotaerk> it says "unsafe" so it's never safe duh
18:06:40 <Rotaerk> *cough*
18:07:00 <SamB_XP> Rotaerk: that's not what "unsafe" means
18:07:11 <Axman6> Warrigal: you're a horrible man if you do it
18:07:12 <SamB_XP> "unsafe" means you have to be careful to use it in a safe manner
18:07:22 <c_wraith> unsafePerformIO can be plenty safe.  It just means it can't prove it by itself
18:07:39 <gOcOOl> monochrom: "scientific method" being actually trying for ourselves?
18:07:44 <Axman6> Warrigal: unsafePerformIO is there for the FFI. any other use is... well not recommended
18:07:46 <c_wraith> Using it to catch pattern match failures in pure code is basically always safe.
18:07:57 <Rotaerk> there needs to be a sarcasm font
18:07:59 <Rotaerk> :P
18:08:02 <c_wraith> (and a sign that the pure code you're using could stand to be re-written)
18:08:18 <monochrom> scientific method being reproducible
18:08:20 <ivanm> Axman6: oh, and for Debug.Trace ...
18:08:31 <Warrigal> unsafePerformIO (return 5)
18:08:57 <Warrigal> c_wraith: sure it can prove it by itself; it just doesn't want to.
18:09:00 <monochrom> A scientific report is supposed to give enough information so readers can reproduce the claimed observations.
18:09:30 <SamB_XP> or some similar ones, at least
18:10:11 <Cale> Warrigal: you can do that if you really feel that you need to, but it's better just to pass a partially applied version of readMVar around.
18:11:14 <Warrigal> I do wonder why I wanted to do it in the first place.
18:11:26 <Cale> Warrigal: unsafePerformIO is asking for trouble, because the meaning of your program ends up subtly tied up with the way that GHC implements things.
18:13:35 <Axman6> Person_: so, are you happy with the definition?
18:14:08 <Warrigal> Seems the only thing that could go wrong is GHC insisting that the readMVar be evaluated before anything else happens.
18:15:35 <Person_> Axman6 yes, still working at it
18:16:44 <Axman6> try playing with a few examples. like, in ghci, make sure that flipTree (Branch 7 (Leaf 2) (Leaf 5)) gives you Branch 7 (Leaf 5) (Leaf 2)
18:17:40 <SamB_XP> then you can start learning quickcheck ;-P
18:17:47 <Axman6> indeed
18:18:00 <Axman6> and make sure that flipTree (flipTree x) == x
18:18:20 <Person_> yes, the problem is though
18:18:28 <Warrigal> Darn, Hmm seems to have gone missing. Its link is broken.
18:18:30 <Person_> I have two definitions
18:18:38 <Person_> flipTree x l r = x r l
18:18:45 <Axman6> no!
18:18:47 <Person_> flipTree x = x
18:18:52 <Axman6> nonono
18:19:01 <Axman6> you had it perfect before
18:19:13 <Person_> flipTree x l r = x (flipTree l) (flipTree r)
18:19:13 <Axman6> flipTree (Leaf x) = Leaf x
18:19:24 <Axman6> flipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)
18:19:35 <Axman6> you _need_ to have the Leaf and Branch there
18:19:43 <Axman6> they're _very_ important :)
18:19:51 <Warrigal> I'm going to email its author about it.
18:20:33 <SamB_XP> Warrigal: what's gone missing ?
18:20:46 <Axman6> Person_: those two lines i just pasted are _exactly_ the definition of what you need
18:21:49 <Warrigal> SamB_XP: Hmm, a Haskell Metamath library.
18:22:07 <monochrom> It's so blissful to "rephrase" what you have learned in your own terms.
18:22:31 <Axman6> Person_: a data consytructor like Branch is sort of like a struct. Branch has an a, and two sub trees
18:22:46 <Axman6> but... don't think about structs
18:23:26 <Person_> I won't
18:23:42 <Axman6> Person_: do you see what you were doing wrong?
18:25:07 <Saizan> monochrom: though it's hard to infer a rule by the examples without trying to see when it breaks
18:25:14 <Person_> Axman6: Yes, trying quickcheck now
18:25:24 <Axman6> so, you got it to compile?
18:25:31 <Saizan> this is also why i don't like learning only by example
18:25:34 <Axman6> and have you tested it by hand?
18:25:40 <Person_> Axman6: it's compiling
18:25:46 <Person_> *compiled
18:26:09 <Axman6> and what definition of flipTree do you have? (paste it here)
18:27:17 <Axman6> Person_: ?
18:28:36 <yrlnry> I have a function f :: [a] -> a  which takes a finite sequence and produces the next element in the sequence.  I want to write a "fix" function that produces the complete infinite sequence, given an initial sequence and f.  But I can't figure out how to write it.
18:28:44 <Person_> Axman: It has compiled, but I'm trying to get quickcheck up
18:28:45 <yrlnry> Any suggestions?
18:28:56 <Axman6> Person_: don't worry about quickcheck
18:29:19 <Axman6> :t fix
18:29:20 <lambdabot> forall a. (a -> a) -> a
18:29:31 <yrlnry> I know about that fix, but it's not quite what I want.
18:30:00 <Person_> Axman, getting a problem with the two inputs
18:30:08 <mmorrow> yrlnry: you'd need f to be :: [a] -> (a, [a])
18:30:08 <Axman6> what two inputs?
18:30:09 <Person_> treeReverse (Leaf a) = a
18:30:16 <Axman6> no
18:30:24 <Axman6> you're doing it wrong again :P
18:30:30 <Axman6> flipTree (Leaf x) = Leaf x
18:30:43 <Axman6> treeReverse (Leaf x) = Leaf x
18:30:46 <yrlnry> mmorrow: why so?
18:30:48 <mmorrow> yrlnry: well, actually you could just do tail too, if "f" doesn't influence the rest of the seq
18:30:52 <Person_> gotcha
18:30:54 <Person_>  Occurs check: cannot construct the infinite type: t = Tree t     When generalising the type(s) for `treeReverse'
18:31:15 <Axman6> treeReverse (Branch x l r) = Branch x (treeReverse r) (treeReverse l)
18:31:16 <Person_> alright, that took care of it
18:31:27 <Person_> haha, got it done
18:31:45 <nvoorhies> Where's a good place to start looking if I want to play with haskell and llvm?
18:31:46 <mmorrow> yrlnry: as an artificial example, (\(x:y:xs) -> if x==5 then (x,y*2:xs) else (x,y:xs))
18:32:49 <mmorrow> nvoorhies: using haskell bindings to llvm you mean, or to use llvm as a library to /compile/ haskell?
18:32:53 <Axman6> Person_: so, have you tested it?
18:33:11 <nvoorhies> mmorrow: the former.
18:33:22 <mmorrow> nvoorhies: http://hackage.haskell.org/package/llvm
18:33:28 <nvoorhies> Awesome.  Thanks!
18:33:34 <mmorrow> nvoorhies: also, check out augustss blog for examples
18:34:02 <mmorrow> nvoorhies: e.g. the first post http://augustss.blogspot.com/
18:34:12 <Saizan> yrlnry: well, there's an obvious solution that requires (++)
18:34:16 <mmorrow> is a complete example that looks neat
18:34:28 <nvoorhies> great
18:34:37 <Saizan> yrlnry: or we can use a comonad i guess
18:34:55 <Person_> Axman6, not yet
18:35:06 <Person_> Trying to test if treeFlip(treeFlip(x)) == x
18:35:08 <yrlnry> I was thinking about a comonad, but it seemed like too big a hammer.
18:35:11 <Saizan> yrlnry: do you know about zippers?
18:35:32 <SamB_XP> yrlnry: haven't you seen any anime?
18:35:38 <SamB_XP> you can NEVER have too big a hammer!
18:35:56 <yrlnry> Saizan: The Gerard Huet thing?
18:36:08 <Saizan> yrlnry: yes, but for lists in this case
18:36:13 <mmorrow> yrlnry: ohhh, that "f" is computing the /rest/ of the sequence
18:36:14 <Cale> Person_: If you define: treeFold l n = f where f (Leaf x) = l x; f (Node x l r) = n x (f l) (f r), then you can write things like  treeFlip = treeFold Leaf (\x l r -> Node x r l)
18:36:27 <mmorrow> yrlnry: i misread what you said
18:36:28 <yrlnry> mmorrow: ultimately, but it only computes it one element at a time.
18:36:54 <Cale> Person_: and  treeSize = treeFold (\x -> 1) (\x l r -> 1 + l + r)
18:37:10 <yrlnry> f init  produces the next element, so say   extend init = init ++ [f init].  Then what I want is extend $ extend $ extend ..... init
18:37:10 <Saizan> which il basically Zipper a = Z { past :: [a], current :: a, future :: [a] } though your 'f' will use only the past i guess
18:37:20 <Axman6> Cale: that's a pretrty huge leap for someone who's still struggling with pattern matching...
18:37:45 <Cale> Axman6: Still an interesting thing to see, I think :)
18:38:02 <SamB_XP> Cale: picture yourself confused
18:38:04 <Person_>  Axman6, need to define equality
18:38:07 <Axman6> yes, but far too complicated for now i think ;)
18:38:15 <SamB_XP> then picture the concept of fold being thrown at your poor overworked brain!
18:38:42 <Cale> hehe
18:38:43 <yrlnry> Saizan: Okay.  and we store the past in reverse order for convenience?
18:38:47 <Axman6> Person_: ah, change the definition to: "data Tree a = Leaf a | Branch a (Tree a) (Tree a) deriving (Eq,Show)"
18:38:48 <Cale> SamB_XP: Perfect!
18:38:57 <Axman6> @src Eq
18:38:58 <lambdabot> class  Eq a  where
18:38:58 <lambdabot>     (==), (/=)   :: a -> a -> Bool
18:39:00 <mmorrow> yrlnry: hrm, so after each application of "f", the next application of "f" needs (xs ++ [x]), right?
18:39:05 <Person_> AxMan, I do have that definition
18:39:12 <Saizan> yrlnry: yeah
18:39:13 <mmorrow> yrlnry: which is kind of a pita for efficiency
18:39:18 <SamB_XP> Cale: no, consider that you were confused by the most elementary concept in the language!
18:39:25 <Axman6> Person_: with the deriving part at the end?
18:39:29 <mmorrow> ah nice, you two are already on it :)
18:39:37 <yrlnry> I'm not worrying abut efficiency when I can't figure out how to write it at all.
18:39:38 <Person_>  yes, with deriving
18:39:39 <Cale> Confusion is the ideal state for learning! :)
18:39:42 <Saizan> yrlnry: but that won't work well if 'f' needs to consume the past in-order
18:39:49 <Axman6> and it has Eq and Show?
18:39:51 <Person_> yes\
18:39:59 <SamB_XP> Cale: generally it's best to be confused in a relevant manner
18:40:03 <Axman6> well, then you don't need to define equality ;)
18:40:03 <mmorrow> @type \f xs -> xs ++ fix (\k acc -> let x = f (xs ++ reverse acc) in x : k (x:acc)) xs
18:40:05 <lambdabot> forall a. ([a] -> a) -> [a] -> [a]
18:40:05 <SamB_XP> and preferably not about the syntax!
18:40:24 <Person_> alright, well then, I've got the following lines in
18:40:27 <mmorrow> probably would be better if f just dealt with the reverse sequence
18:40:31 <Person_> testFlip:: Tree t -> Bool testFlip x = treeReverse(treeReverse(x)) == x
18:40:38 <Person_> testFlip:: Tree t -> Bool
18:40:38 <Person_>  testFlip x = treeReverse(treeReverse(x)) == x
18:40:59 <Axman6> looks good (though too many parens ;)
18:41:09 <Person_> doesn't compile
18:41:10 <mmorrow> @type \f xs -> let ys = reverse xs in xs ++ fix (\k acc -> let x = f acc in x : k (x:acc)) ys
18:41:12 <lambdabot> forall a. ([a] -> a) -> [a] -> [a]
18:41:25 <Axman6> testFlip x = treeReverse (treeReverse x) == x
18:41:26 <yrlnry> mmorrow: yeah, something like that.  Thanks.
18:41:36 <Person_>   Could not deduce (Eq t) from the context ()       arising from a use of `=='
18:41:37 <mmorrow> yrlnry: np
18:41:41 <Saizan> yrlnry: this is an inefficient solution "init ++ map fst iterate (\(_,past) -> let next = f past in (next, past ++ [next])) (undefined,init)"
18:41:49 <monochrom> stream confusion is stream with fusion
18:41:49 <aavogt> @hoogle Either a b -> b
18:41:49 <lambdabot> Data.Either rights :: [Either a b] -> [b]
18:41:50 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
18:41:50 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
18:42:07 <Saizan> yrlnry: if 'f' consumes the reversed past you can use "init ++ map fst iterate (\(_,past) -> let next = f past in (next, past ++  [next])) (undefined,init)"
18:42:11 <Saizan> oop
18:42:24 <aavogt> there's no unsafe fromRight defined somewhere?
18:42:39 <Axman6> Person_: can you please paste all your code on http://hpaste.org/fastcgi/hpaste.fcgi/new ?
18:42:53 <Saizan> yrlnry: "init ++ map fst iterate (\(_,past) -> let next = f past in (next, next : past) ) (undefined,reverse init)" -- this one if 'f' consumed it reversed
18:43:05 <yrlnry> mmorrow, Saizan: Okay, I have to think about this.  Thanks.
18:43:11 <Saizan> and that one will be efficient.
18:43:11 <mmorrow> @type \f xs -> let ys = reverse xs in xs ++ fix (\k acc -> let x = f acc in x : k (x:acc)) ys
18:43:13 <lambdabot> forall a. ([a] -> a) -> [a] -> [a]
18:43:23 <Person_> Axman6, done
18:43:23 <mmorrow> Saizan's second and that one are equiv i believe
18:43:25 <aavogt> hmm, there is Data.Either.Utils.forceEither
18:43:40 <Saizan> mmorrow: ah, yeah, it looks so
18:43:46 <aavogt> I guess hoogle doesn't index it
18:44:29 <Axman6> Person_: oh, you need this: testFlip :: Eq t => Tree t -> Bool. you can leave out that line entirely if you like
18:44:40 <Axman6> bleh, stupid keyboard -_-
18:45:30 <Person_> Axman6, what does that do?
18:46:11 <Axman6> Person_: it says that the t type in the Tree must also have equality definied on it
18:46:19 <Person_> gotcha
18:46:38 <aavogt> Person_: note that the t defaults to '()' which isn't the best for testing, since there is only one value
18:46:45 <Axman6> so, you can't  check to see if two trees are the same, unless you can check the elements in the tree are the same
18:47:03 <aavogt> @check \x -> all (x==) $ permutations x
18:47:07 <lambdabot>   mueval-core: Time limit exceeded
18:47:33 <aavogt> @check \x' -> let x = take 4 x' in all (x==) $ permutations x
18:47:34 <lambdabot>   "OK, passed 500 tests."
18:47:55 <Person_> Axman6, thx
18:48:00 <Person_> Axman6, it actually...
18:48:00 <Person_> works
18:48:01 <Person_> wtF?
18:48:08 <Axman6> of course it does :)
18:48:51 <aavogt> @check \x' -> let x = take 4 x' in all (x==) $ permutations (x::[Bool])
18:48:52 <lambdabot>   "Falsifiable, after 1 tests:\n[True,False]\n"
18:48:53 <Axman6> Person_: now, are you sure you understand pattern matching?
18:49:03 <ivanm> Axman6: is someone doubting you again?
18:49:08 <Person_> Axman6, much better than before...
18:49:25 <Person_> Axman6: Much simpler than I thought it would be, unfortunately I'm still going to have problems w/ wrapping around it
18:49:39 <SamB_XP> Person_: wrapping what around it?
18:49:41 <SamB_XP> your head ?
18:49:42 <Axman6> Person_: well, we're here to help, so keep asking questions :)
18:49:50 <ivanm> SamB_XP: presumably wrapping his head around it
18:51:53 <monochrom> Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
18:51:57 <ivanm> heh
18:52:06 <ivanm> @remember monochrom Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
18:52:06 <lambdabot> Done.
18:52:52 <SamB_XP> if you find you've wrapped your head around Haskell, fix the problem by making Haskell more complicated ;-P
18:54:08 <Axman6> Person_: have you been given any more problems?
18:54:25 <Person_> Axman6, yes, but I'm going for dinner quickly
18:54:31 <Axman6> bah!
18:54:36 <Axman6> haskell > food!
18:54:36 <Axman6> ;)
18:55:23 <seanmcl> I know you can see core files using -ddump-simpl, but this dumps it to the screen.  Is there a way to generate intermediate files?  For instance, in a big project, if you want to look at some tiny function somewhere it would be nice to be able to narrow down where you're looking.
18:55:46 <Axman6> have you tried ghc-core
18:55:48 <Axman6> ?
18:55:54 <Axman6> cabal install ghc-core
18:55:54 <seanmcl> Axman6: no
18:55:59 <monochrom> Does redirection help?  ghc -ddump-simpl blahblah.hs > filefile
18:56:12 <Axman6> makes life easier. colourises the output, and also gives you the asm
18:56:25 <seanmcl> monochrom: but you can't compile a file in the middle of a package without compiling everything
18:56:30 <seanmcl> oh, I guess you can
18:56:35 <seanmcl> but the others must be compiled already
18:56:55 <ChilliX> Does anybody have any idea how to get dtrace/Instruments on macos to give one a trace of the system calls of a process (like strace on Linux)  this is actually Haskell related; I'm debugging the Haskell LLVM bindings
18:56:56 <seanmcl> Axman6: thanks.  I'll try it.
18:57:40 <Axman6> ChilliX: man -k dtrace will give you a list of all the dtrace scripts
18:58:02 <stivioo> there is a spanish haskell group?  or channel?
18:58:50 <ChilliX> Axman6: ah, that *is* very useful - ta!
18:58:58 <Axman6> no worries :)
18:59:13 <Axman6> don't bother writing your own scripts for stuff like that
18:59:36 <Axman6> ChilliX: i'd very much like to play with these bindings when they're in a usable state
18:59:38 <ChilliX> Axman6: yeah, I thought it's kind of silly that you have to write your own scripts for such things
18:59:46 <ChilliX> but google didn't know any better
18:59:50 <Makoryu> stivioo: Good question
19:00:12 <ChilliX> and a quick look at developer.apple.com didn't help either (though it is certainly somewhere there)
19:00:50 <Axman6> i think Apple have installed the dtrace toolkit thing (can't remember its actual name)
19:02:07 <stivioo> Makoryu: but  have an answer? haha
19:02:28 <Makoryu> stivioo: No idea!
19:02:38 <Axman6> stivioo: it's possible there is one. #haskell-es? #haskell.es?
19:02:47 <stivioo> nou
19:02:49 <Axman6> check it out, and see if there are people in there
19:02:59 <Axman6> there are a few haskell channels
19:05:23 <stivioo> #haskell.es exist!.. thanks
19:05:53 <Axman6> are you sure it exists?
19:06:02 <Axman6> you create channels my joining them...
19:06:09 <Axman6> is there anyone else in there?
19:06:18 <SamB_XP> stivioo: if you're lucky, there might even be someone in there who knows Haskell!
19:07:32 <stivioo> Axman6: i know..
19:07:41 <Axman6> ok, juct checking :)
19:07:44 <stivioo> yeah  some inactive dudes
19:08:17 <Axman6> well, inactive > none
19:08:38 <Axman6> data ChanState = None | Inactive | Active deriving Ord
19:09:05 <Makoryu> type ChanState = Maybe Bool
19:09:14 <Makoryu> > Nothing < Just True
19:09:16 <lambdabot>   True
19:09:21 <Axman6> less descriptive
19:09:48 <Axman6> > Just minBound > Nothing
19:09:49 <lambdabot>   True
19:09:53 <Axman6> heh
19:09:57 <Axman6> > minBound
19:09:57 <lambdabot>   ()
19:10:02 <Axman6> -_-
19:10:15 <Makoryu> > default Int
19:10:17 <lambdabot>   <no location info>: parse error on input `default'
19:10:42 <aavogt> do people ever use default declarations?
19:10:57 * aavogt has never seen them in the wild
19:10:59 <Makoryu> No.
19:11:55 <SamB_XP> aavogt: I think I saw some in GHC.*
19:12:06 * monochrom starts a rumour. Haskell Prime will eliminate it.
19:12:14 <Axman6> ChilliX: so how are these LLVM bindings going?
19:12:31 <copumpkin> I thought that was augustss
19:12:57 <monochrom> augustss already started the same rumour?
19:13:02 <Axman6> ChilliX: this is for Accelerate
19:13:04 <copumpkin> I mean the LLVM
19:13:11 <aavogt> SamB_XP: but nothing other than Integer, Double or whatever is specified in the h98 report?
19:13:19 * monochrom starts more rumours.
19:13:36 <Axman6> uh, copumpkin, not ChilliX >_<
19:13:51 <Axman6> copumpkin: LLVM backend for Accelerate
19:13:55 <copumpkin> ah
19:14:07 * Axman6 wants an OpenCL one
19:14:11 <SamB_XP> that increases the velocity of your computer ?
19:14:20 <monochrom> hahaha
19:14:22 <SamB_XP> for example, by throwing it out the window?
19:14:33 <monochrom> Don't go past the velocity of light.
19:15:01 <monochrom> Don't throw the computer out the window with the programmer.
19:15:02 <SamB_XP> monochrom: clearly that won't happen in atmosphere ;-P
19:15:23 <SamB_XP> which is the baby, which the bathwater ?
19:15:29 <Axman6> SamB_XP: it's a library for array computations, that will eventually have GPU code generation
19:15:34 <monochrom> programmer is bathwater
19:17:52 <yrlnry> Why does ghci's command line sometimes get evaluated in Prelude context and sometimes in Main context?
19:18:22 <aavogt> yrlnry: some subtle difference between :load and :module?
19:18:38 <aavogt> with respect to scoping
19:19:08 <yrlnry> aavogt: that's not it.  I can add Main explicitly with :module, but if I don't, sometimes it's there, sometimes not.
19:20:58 <aavogt> hmm, so it just what the label is for your prompt, or also which functions are in scope?
19:21:12 <yrlnry> Both.
19:24:01 <aavogt> yrlnry: it also has something to do with ghci loading existing .hi or .o files. You should check the ghc manual for a better description :)
19:24:50 <yrlnry> thanks.
19:34:35 <ChilliX> Axman6: well, the llvm bindings don't work with ghci at all and they don't even link on snow leopard
19:45:49 * jmcarthur has been meaning to toy with llvm
19:45:52 <yrlnry> Is there a way to get ghci to tell me the type that it would have inferred for a value, had I not supplied my own type constraint for it?
19:46:20 <c_wraith> supply an incorrect type for it
19:46:29 <c_wraith> it'll tell you what it inferred in the compiler error
19:46:38 <yrlnry> No, I want to do it without editing the code.
19:46:47 <blackdog> don't just toy with it, play the hell out of it!
19:46:54 <yrlnry> If I were going to change the code, I could just comment out the type annotation, and then use :t.
19:47:00 <blackdog> squeeze those vectors till they beg for mercy
19:47:19 <c_wraith> I'm pretty sure GHC doesn't keep that info around after compilation
19:47:23 <fata_erro> is it possible to use virtual alloc in haskell then write some hex bytes to that memory and then call that code using haskell?
19:47:26 <yrlnry> Thanks.
19:48:53 <fata_erro> in C++ i can cast that mem pointer to a func pointer and then call but can i do that same thing in haskell
19:48:54 <fata_erro> ?
19:49:12 <yrlnry> No pointers.
19:49:13 <c_wraith> Maybe with the FFI.  certainly not in pure haskell.
19:49:20 <fata_erro> dang
19:49:44 <SamB_XP> @google "hell.hs"
19:49:47 <lambdabot> http://www.cafepress.com/hs_usa.180197308
19:49:47 <lambdabot> Title: Heaven and Hell > hs-usa : hs-usa store
19:49:52 <SamB_XP> @google "hell.hs" haskell
19:49:53 <lambdabot> No Result Found.
19:50:56 <fata_erro> so not possible?
19:51:09 <fata_erro> but is it from FFI?
19:51:33 <SamB_XP> fata_erro: that's what the hell.hs that I was just looking for does, more-or-less
19:51:35 <seanmcl> why would someone write module A.B.C ( f, g, A.B.C.h ) where ... ?
19:51:38 <c_wraith> It's almost certainly possible from the FFI, as the FFI can call C code, and you can write a C function to do that.
19:51:44 <seanmcl> it's in the Agda source
19:51:56 <yrlnry> c_wraith,: Actualy what he is asking for is illegal in C.
19:52:09 <yrlnry> c_wraith: you are not allowed to interconvert object and function pointers.
19:52:14 <ChilliX> fata_erro: you can do that in the FFI
19:52:19 <seanmcl> does it do something wrt namespaces?
19:52:27 <SamB_XP> yrlnry: illegal, but quite possible!
19:52:35 <ChilliX> fata_erro: there is support to turn a C function pointer into a Haskell function
19:52:35 <c_wraith> Yet it happens all the time.  Just cast through a void* !
19:53:03 <SamB_XP> I think POSIX allows that kind of intercasting, though, as does win32
19:54:04 <fata_erro> will it mess with haskell though?
19:54:10 <SamB_XP> of course, you aren't supposed to dereference the pointers ;-P
19:54:18 <yrlnry> c_wraith: converting a function pointer to a void* is illegal.
19:54:25 <SamB_XP> fata_erro: you should try reading the FFI addendum
19:54:31 <fata_erro> will do
19:54:37 <SamB_XP> yrlnry: you seem to be missing the point
19:54:52 <yrlnry> I guess so!
19:54:56 <c_wraith> fata_erro:  It could.  It's up to you to not do it.  the FFI has the power to be most decidedly unsafe.
19:56:59 <fata_erro> thanks all for clearing things up
19:57:28 <yrlnry> Informative Annex J discusses conversion of object and function pointers as a "common extension".
19:57:33 <seanmcl> ah, I see.  they do it since they're importing unqualified a module with an h field
19:57:49 <yrlnry> Well, this is off-topic, so I'll shut up now.
19:57:56 <SamB_XP> yrlnry: yeah, as I said, POSIX and win32 allow it
19:58:27 <SamB_XP> as do probably most non-POSIXy, non-win32y implementations, but certainly not all
20:00:03 <nsfx> anyone in here familiar with muds/moos?
20:00:22 <jfoutz> yes. kind of.
20:00:27 <yrlnry> nsfx: I am.
20:00:49 <yrlnry> I've spent a lot of time hacking on tinymuck, lambdamoo, and original tinymud.
20:00:57 <SamB_XP> I wrote an HTTP 0.9 server in MOO
20:00:57 <nsfx> cool
20:01:27 <SamB_XP> to fit with the resource framework that was in JHCore ...
20:01:36 <yrlnry> Also I once worked with Pavel Curtis.
20:01:38 <yrlnry> :)
20:01:41 <nsfx> i feel like muds are ripe for a comeback, but not moo, mfo (mud function oriented)
20:01:50 <jfoutz> i played on a dikumud 15 years ago.
20:01:54 <jfoutz> :p
20:02:00 <Tony[`]> if we could just get a better natural language parser
20:02:01 <nsfx> i've just been brainstorming a lot
20:02:25 <nsfx> tumblr / facebook + mud
20:02:30 <nsfx> might be cool
20:02:57 <nsfx> i don't have anyone to talk about it with though.. seems like #haskell was the right choice!
20:04:24 <fata_erro> what are muds?
20:04:27 <monochrom> haha
20:04:41 <nsfx> fata_erro: something like multiplayer interactive fiction
20:04:47 <fata_erro> ah
20:05:02 <yrlnry> The big problem I always had with moo was that there was no way for a moo to incorporate core improvements from another moo.
20:05:03 <nsfx> and sometimes non-fiction
20:05:33 <yrlnry> If I was running a moo based on lambdacore 1.3, and then 1.4 came out, there was no way to incorporate the improvements.
20:05:46 <SamB_XP> yrlnry: hmm
20:05:52 <SamB_XP> you'd think there could be a way
20:06:04 <nsfx> some sort of migration process
20:06:09 <yrlnry> These days it might be easier.  Revision control systems are much better now.
20:06:20 <yrlnry> This was fifteen years ago.
20:06:22 <nsfx> what was the data store for lambacore?
20:06:32 <SamB_XP> I was thinking of something involving "diff" and "patch"
20:06:46 <SamB_XP> nsfx: well, you can dump stuff to a textual read-in format, I believe
20:06:55 <yrlnry> there was no data store.  It was all in core.
20:07:07 <yrlnry> You could dump it as a text file and load it from same.
20:07:07 <nsfx> i was thinking couch db  + javascript for the builder language
20:07:22 <yrlnry> When a lambdacore was released, they would dump out the core objects and publish the dump file.
20:07:42 <yrlnry> s/they/pavel/
20:07:55 <aavogt> I have a function which is the same as    (withModificationFun :: ([Double] -> [Double]) -> x -> y -> z)
20:07:58 <SamB_XP> yrlnry: so couldn't you compare one with the previous one ?
20:08:18 <aavogt> where Double is actually some other concrete type
20:08:33 <yrlnry> you could, and you could build a patch.  But it would incorporate all sorts of absolute object numbers that might conflict with the ones in your database.
20:08:40 <yrlnry> Applying the patch to your own dump would be insane.
20:08:45 <nsfx> is ee
20:08:47 <nsfx> i see*
20:08:49 <nsfx> fascinating stuff
20:08:49 <aavogt> is it possible to wrap the same function so that the ([Double] -> [Double]) has the type  ([a] -> [a]) ?
20:08:53 <SamB_XP> yrlnry: hmm, true
20:09:17 <SamB_XP> but I bet it wouldn't be THAT impossible to engineer a patch that used $variables ....
20:09:33 <nsfx> nowadays i guess there is wow and secondlife
20:09:47 <aavogt> the point is that the function passed should not care about the specific type
20:09:55 <nsfx> i'm wondering if the visual aspect really matters  or if the demographic just switched
20:10:02 <aavogt> while it does in fact operate on a monomorphic type
20:10:20 <yrlnry> It would be better if, #1, absolute object references were replaced with symbols, #2 each verb were dumped to a separate file, and #3, the whole thing was managed with a 21st-century VCS.
20:10:23 <aavogt> how do I accomplish this?
20:11:21 <SamB_XP> yrlnry: hmm, reminds me of moonix or whatever it's called ...
20:11:36 <aavogt> more specifically, I'm trying to provide a cleaner interface to this module: http://www.eng.uwaterloo.ca/~aavogt/xmonad/docs/XMonad-Actions-WorkspaceCursors.html
20:11:46 <yrlnry> And if the object space supported some sort of namespaces.
20:11:52 <sproingie> istr coldmud used symbolic object references instead of numbers
20:12:20 <mmorrow> fata_erro: easy partay http://moonpatio.com/repos/ohhai.hs ;)
20:12:24 <sproingie> also had frobs, something like perl "blessed" objects that were immutable
20:12:28 <SamB_XP> yrlnry: well, you could use an object as a namespace, sortof
20:13:45 <cjs_> Why does Num include (*)?
20:13:54 <mmorrow> fata_erro: you'll want to read about `foreign import ccall "dynamic"' in the FFI spec
20:13:56 <aavogt> it is convenient
20:14:07 <yrlnry> What good is it to have numbers that you can't multiply?
20:14:38 <monochrom> why ask why
20:14:40 <mmorrow> fata_erro: it has to be from ffi, since C code and haskell code have different calling conventions
20:14:40 <fata_erro> tahanks mmorrow
20:14:48 <mmorrow> :)
20:15:07 <sproingie> damn i kinda miss MOO coding
20:15:17 <sproingie> programming was fun then
20:15:26 <yrlnry> mmorrow: I made a definition of my list-function-fixedpoint thingy that does what I want.
20:15:27 <fata_erro> mmorrow just what i needed
20:15:41 <mmorrow> (libffi is essentially just some asm that takes a description of the args, and dynamically makes a code stub in some exec mem that'll translate calling conventions for you)
20:15:52 <mmorrow> yrlnry: oh cool
20:16:05 <mmorrow> yrlnry: what did you end up with?
20:16:46 <cjs> Well, it's causing me a problem. For example, I've got what I call a Qty, which is a number of lots of a intstrument (stock, bond, future, option, what-have-you) in a certain direction (Long or Short, which you can think of as Bid or Offer, as well, or just positive or negative). It comes very, very close to making sense as a Num, except that of course multiplying two Qtys doesn't make sense; you'd multiply a Qty by, say, an Int.
20:16:46 <yrlnry> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10532#a10532
20:16:47 <mmorrow> fata_erro: (i mention libffi since that's what ghc uses, but you don't necessarily have to care, just fyi)
20:17:15 <yrlnry> cjs: would it work to make it a Num, where (*) = undefined ?
20:17:21 <mmorrow> yrlnry: nice
20:17:29 <cjs> Well, then the type system isn't helping me out much, there.
20:17:36 <yrlnry> mmorrow: is it?  I thought it looked kind of skanky.
20:17:42 <cjs> Hm. So Num is a ring, right?
20:17:57 <mmorrow> yrlnry: the only thing is that it's inefficient to do (xs ++ [x]) a bunch
20:18:02 <mmorrow> O(n^2)
20:18:17 <yrlnry> mmorrow: yes, but I decided to disregard that.  I did not need efficiency.
20:18:27 <byorgey> cjs: it's more like a Ringjkxzv.  The jkxzv is some extra junk that got thrown in.
20:18:32 <yrlnry> I am more concerned with code style.
20:18:34 <yrlnry> Hi, Brent.
20:18:42 <byorgey> hi yrlnry
20:18:48 <yrlnry> <--- Dominus
20:18:51 <mmorrow> yrlnry: in that case, nice :)
20:19:06 <byorgey> yrlnry: aha!  I hadn't made the connection =)
20:19:08 <mmorrow> yrlnry: yeah, making the f have to deal with the reverse sequence would be a pita
20:19:10 <cjs> Hm. I've heard that before. What's the extra junk again, besides fromInteger? And what's the thing I need, like a ring but without (*)?
20:19:13 <Makoryu> cjs: The Haskell 98 numeric typeclasses don't really correspond well to mathematical categories of stuff.
20:19:28 <yrlnry> mmorrow: actually the particular f I am interested in is not sensitive to the order of the elements of the list.
20:19:29 <byorgey> cjs: abs, signum, Show, Eq.
20:19:48 <cjs> byorgey: But not negate?
20:19:54 <yrlnry> cjs: vector space.
20:20:10 <alexsuraci> What's going wrong with this GHCI session? http://paste.pocoo.org/show/143706/
20:20:14 <byorgey> cjs: no, that's part of the ring.  it should be a group wrt. addition.
20:20:34 <cjs> I've also got the issue that it doesn't make sense to combine two Qtys with different lot sizes, but I guess I need dependent types for that.....
20:20:38 <yrlnry> byorgey: I think he wants a vector space.  The vectors form an abelian group, but he also has regular numbers as scalars.
20:20:41 <alexsuraci> crazy 0, crazy 1, and crazy 2 are working properly, but crazy 3 breaks despite working fine when I enter the replaced function code
20:20:44 <mmorrow> yrlnry: hmm, in that case it may pay to deal with the reverse, and s/(++)/(:)/
20:20:54 <Saizan> cjs: it seems they are a vector space
20:20:57 <cjs> Ah, yes, I was thinking that what I had sounded kind of like a vector.
20:21:04 <cjs> So what's the type class for that?
20:21:05 <byorgey> yrlnry: yes, that sounds right.
20:21:23 <yrlnry> mmorrow: if I ever care about efficiency here, I will certainly do that first, but the chance of that is vanishingly small.
20:21:31 <mmorrow> yrlnry: (and if you're going for style, you could drop some parens)
20:21:43 <byorgey> cjs: there isn't one, make one yourself =)
20:21:54 <Saizan> there are some vectors lib on hackage, maybe they have one
20:21:54 <yrlnry> mmorrow: where?
20:22:10 <cjs> byorgey: Hm, so this "vector-space" library isn't related? :-)
20:22:16 <cjs> http://www.haskell.org/haskellwiki/Vector-space
20:22:20 <mmorrow> init ++ rest init
20:22:29 <mmorrow> next ++ rest (ls ++ next)
20:22:44 <byorgey> cjs: well, yes, taking a look at some existing libraries is probably a good idea =)
20:22:44 <mmorrow> application binds tightest
20:23:17 <yrlnry> Okay,  thanks.  Ive been meaning to get that straight for a while.
20:23:21 <cjs> Hm. Anyway, also, is there some simple way to deal with the "two Qtys with different lot sizes are really different types" issue?
20:23:55 <byorgey> alexsuraci: it's because of the type of 'replicate'
20:23:58 <yrlnry> I have a lot of cargo-cult parentheses.  Like I have 1 + (maximum ls) because I thought that it went wrong without the parens, but I only thought that because I originally had 1 + max ls, which failed.
20:23:58 <byorgey> @type replicate
20:23:59 <lambdabot> forall a. Int -> a -> [a]
20:24:01 <Saizan> cjs: you could make the sizes type-level parameters of the type
20:24:10 <byorgey> alexsuraci: hence crazy has the type  Int -> Int
20:24:11 <mmorrow> yrlnry: these would be my own personal style prefs http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10532#a10533
20:24:23 <alexsuraci> byorgey: ahhh, that makes sense
20:24:26 <byorgey> alexsuraci: but when you type out the definition like that, the 3's can have different types
20:24:30 <byorgey> so it defaults to Integer
20:24:34 <alexsuraci> right
20:24:38 <Saizan> cjs: there are various type-level representations for numbers
20:24:47 <alexsuraci> byorgey: thanks, mystery solved ;)
20:24:52 <mmorrow> @pl \init -> init ++ rest init
20:24:53 <lambdabot> ap (++) rest
20:25:00 <mmorrow> hmm
20:25:01 <Saizan> cjs: on hackage, i mean
20:25:04 <byorgey> alexsuraci: sure.  thanks for the fun puzzle, I had to stare at it for a minute and scratch my head =)
20:25:26 <alexsuraci> byorgey: haha, no problem
20:25:27 <yrlnry> mmorrow: it seems to me that it should be possible to write the first line of the function in terms of a single call to rest, but I can't quite figure it out.
20:25:29 <cjs> Saizan: Mmm. I've seen this sort of thing before. I guess I need to go find a  spare day to look through these and play with them, though.
20:28:12 <mmorrow> yrlnry: grr, i think it's either as-is or to use `ap' (i'd go with as-is personally)
20:28:30 <mmorrow> , ap(++)show"ap(++)show"
20:28:31 <lunabot>  "ap(++)show\"ap(++)show\""
20:30:07 <Saizan> cjs: it can be simple depending on which operations you'd need on the sizes and how you create these Qty
20:30:08 <mmorrow> , (fromJust . fromDynamic . eval) (ap(++)show"ap(++)show") :: String
20:30:11 <lunabot>  "ap(++)show\"ap(++)show\""
20:31:27 <Saizan> cjs: the simplest example is sized lists: data S a; data Z; data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
20:31:27 <yrlnry> No way am I using "ap" :)
20:31:31 <mmorrow> haha
20:31:33 <mmorrow> :)
20:31:44 <cjs> Saizan: Hm. Well, at the moment I know all my possible lot sizes at compile time, come to think of it. So yes, this could as simple as a type parameter, couldn't it?
20:31:46 <yrlnry> mmorrow:  I just have a sense that it is about 20% longer than it ought to be.
20:31:56 <Saizan> cjs: yeah
20:32:00 <mmorrow> oh, i thought you said "no way, i'm _using_ ap"
20:32:45 <yrlnry> It's easy to use ap.  You take arbitrary function f, hand its definition to @pl, and then plug in the output, which always looks like (ap .) (.) (flip (map .) ap (map flip .) cokebottle)
20:32:49 <Axman6> ChilliX: i've got all the trig functions added now, want to patches?
20:33:00 <cjs> I just need, e.g., "data Lot100k; data Lot500k" etc. and whatever extension makes that work, and then "addQty :: Qty -> Qty -> Qty" just becomes "addQty :: Qty a -> Qty a -> Qty a", doesn't it?
20:33:30 <Saizan> cjs: right, that works fine
20:33:55 <cjs> Neat. Thanks.
20:34:16 <mmorrow> yrlnry: the only time i ever use ap is in that quine and in the mechanical instance def for "instance Applicative m where" where m is a Monad
20:34:17 <Saizan> you just need to make sure you tag the values with the right LotN
20:34:37 <mmorrow> pure = return; (<*>) = ap
20:35:17 <ChilliX> Axman6: yes, please send me the patches
20:35:22 <yrlnry> what's the yntax for guarded clauses?   try x = guardClause | value  ?
20:35:40 <Saizan> try x | guard = value
20:36:05 <yrlnry> Thanks.
20:36:14 <Saizan> try x | guard = value ..  | otherguard = othervalue
20:37:18 <yrlnry> YAAAY.  Problem is solved.
20:37:35 <yrlnry> [1,3,4,9,11,16,21,23,28,33,35,40,45,47,52,57,59,64,69,71,76,81,83,88,93,95,100,105,107,112...]
20:37:39 <ivanm> Axman6: what are you adding trig functions to?
20:38:12 <hackagebot> vty-ui 0.2 - A user interface composition library for Vty (JonathanDaugherty)
20:38:45 <Axman6> ChilliX: i could probably the add the rest of Floating if you wanted. there's not much more to add (though i think the problem then becomes making sure all the backends can implement these functions? like (**)?)
20:38:50 <yrlnry> That sequence has the property that if x and y are any elements of the sequence, then |x-y| is *not* an element.
20:38:50 <Axman6> ivanm: Accelerate
20:39:25 <ChilliX> Axman6: if you'd add some more, that'd be great
20:39:30 <ChilliX> I wouldn't worry about backends
20:39:40 <Axman6> ok, sure thing
20:40:01 <ChilliX> if there are indeed functions that a backend can't implement then maybe it can approx them or otherwise, it'll have to throw an error
20:42:14 <hackagebot> hoauth 0.1.3 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
20:51:09 <Axman6> ChilliX: sounds like a plan
20:55:45 <ivanm> so is Accelerate meant to be used within Haskell code as an EDSL or something?
20:55:49 <Axman6> ChilliX: got a better name for mkExp, where mkExp = exp? mkExp is already taken
20:55:52 <ivanm> or a stand-alone language?
20:56:01 <Axman6> ivanm: within haskell
20:56:15 <ivanm> *nod*
20:56:46 <ivanm> so as an alternative to hmatrix with its LAPACK, etc. stuff or hblas?
20:56:53 <ivanm> or a different domain of problems?
20:57:13 <ChilliX> Axman6: use mkExpFloating
20:58:14 <Axman6> ok
20:58:23 <Axman6> i just changed it to mkExpon, but i can change it again
20:58:53 <ChilliX> just because it is from the FLoating class
20:58:58 <ChilliX> makes it easier to remember
20:59:31 <Axman6> yeah, good call
21:00:24 <Axman6> going to be a big diff....
21:00:37 <ChilliX> :)
21:00:39 <Axman6> (had to change a lot of indentation to make everything line up again ;)
21:00:47 <ChilliX> ic
21:00:53 <ChilliX> I got to make a public darcs repo
21:01:03 <Axman6> yeah, what would be very helpful
21:01:43 <Axman6> mind if i make it mkExpFloat? just for brevity?
21:02:09 <Axman6> actually, i'll keep it. looks float specific if it change it
21:02:15 <ivanm> Axman6: but then it might only be valid for Float rather than Double, etc.! :p
21:02:23 <ivanm> dammit, you beat me to it!
21:02:33 <ChilliX> Axman6: and it more important for such idents to be easy to remeber than to be short
21:03:51 <yrlnry> I want to write sieve x y = foo(z) | ... ; otherwise ...   where z = bar(x).   But I get parse errors.
21:03:58 <Axman6> ChilliX: true
21:04:33 <yrlnry> putting the "where" clause before the "otherwise" clause does not work either.
21:04:42 <yrlnry> What do I need to do here?  Should I paste the code?
21:05:24 <Axman6> ChilliX: do you have a preferred diff format btw? i've been using unified diffs, but i can use something else if you like
21:05:37 <ivanm> yrlnry: paste the code
21:05:44 <ivanm> looks like you're not defining something properly
21:05:55 <yrlnry> Okay.
21:06:04 <ChilliX>  Axman6: unified diff is fine
21:06:42 <Axman6> ok, i'll email it now (i've made sure it all compiles, so should be good to go)
21:07:00 <yrlnry> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10534#a10534
21:08:15 <yrlnry> I could use "let" to define "forbidden", but I'd rather not.
21:08:17 <ivanm> yrlnry: and the error?
21:08:20 <lispy> ?check 1 + 1 == 2
21:08:21 <lambdabot>   "OK, passed 500 tests."
21:08:35 <ivanm> lispy: *few* looks like our mathematics is still correct
21:08:40 <ivanm> s/few/phew/
21:08:48 <lispy> ivanm: yeah, unless you use graphviz
21:09:03 <ivanm> lispy: heh
21:09:05 <yrlnry> ivanm:  as written, I cannot use "base" in "forbidden" because it is scoped to "sieve".  I want to put the definition of "forbidden" into "sieve".
21:09:21 <ivanm> yrlnry: have a nother where for sieve
21:09:25 <ivanm> *another
21:09:39 <yrlnry> I want to write sieve x y = foo(z) | ... ; otherwise ...   where z = bar(x).   But I get parse errors.
21:09:42 <yrlnry> putting the "where" clause before the "otherwise" clause does not work either.
21:09:47 <yrlnry> What do I need to do here?  Should I paste the code?
21:10:06 <lispy> ivanm: did I already tell you that I wasn't able to get a newer version of graphviz to test with?
21:10:13 <ivanm> yrlnry: why are you asking again?
21:10:18 <ivanm> lispy: no, you didn't ;-)
21:10:43 <Axman6> ChilliX: sent
21:10:48 <Makoryu> yrlnry: There's no semicolon between guard clauses
21:11:05 <ivanm> yrlnry: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10534#a10535
21:11:13 <yrlnry> you said "have another where for sieve".  Since my original question was exactly where to put the where clause, I thought you had forgotten what the question was.
21:11:28 <ivanm> heh, OK, misunderstood you then ;-)
21:12:15 <yrlnry> ivanm:  Aha!  That was what I tried first, except I had the inner "where" aligned with "sieve" instead of indented farther.  Thanks!
21:12:28 <ivanm> no worries ;-)
21:17:20 <lispy> ivanm: have you ever thought of applying your graphviz-fu to visualizing darcs patch history?
21:17:42 <ivanm> lispy: vaguely... ;-)
21:18:11 <lispy> ivanm: it would be well received I'm sure
21:22:01 <Axman6> ivanm: i think you should apply your graphviz fu to making criterion produce charts without Chart
21:23:16 <c_wraith> graphviz isn't really designed for that.
21:23:29 <ivanm> lispy: my "graphviz-fu" is mainly applied to having haskell <--> graphviz, rather than _using_ graphviz ;-)
21:23:31 <copumpkin> graphviz is for the graph theory kind of graphs
21:23:37 <ivanm> Axman6: wrong type of charts
21:23:59 <c_wraith> but there is a command-line tool designed for that that kind of graph.
21:24:04 <yrlnry> Thanks folks.  Good night.
21:24:05 <c_wraith> I've used it, but can't recall the name of it
21:24:09 <hiredman> gnuplot
21:24:13 <c_wraith> yes, that's the one
21:24:19 <copumpkin> there's already a hackage package for it
21:24:22 <copumpkin> or a cabbage
21:24:26 <hiredman> (because they are plots, not graphs)
21:24:28 <copumpkin> but it's not terribly fun to use
21:24:33 <ivanm> the gnuplot on hackage is _bad_
21:24:43 <ivanm> I tried using it...
21:24:43 <c_wraith> gnuplot is pretty easy to use from the command line
21:24:48 <c_wraith> is it actually worse than that
21:24:49 <c_wraith> ?
21:24:56 <copumpkin> does gnuplot have an API or just a command-line interface?
21:24:58 * ivanm once considered writing a Writer-based haskell -> gnuplot library
21:25:06 <ivanm> but people told me it was a stupid idea
21:25:11 <ivanm> copumpkin: command-line only AFAIK
21:25:16 <copumpkin> that's annoying
21:25:21 <lispy> ivanm: So, I guessed that was the nature of your graphviz-fu, but it still seems like you're a prime candidate for the job :)
21:25:36 <ivanm> graphviz appears to have an actual API, but most wrappers for it appear to use/generate Dot language rather than the API
21:25:42 <ivanm> lispy: heh
21:25:52 * ddarius suspects the aspects of being a "prime candidate" include not being lispy.
21:25:58 <ivanm> lispy: tbh, I want to get this generic graph project Cale and I started work on finished first
21:26:12 <ivanm> then go and re-write HGAL (since jyp seems to have abandoned it...)
21:26:22 <ivanm> ddarius: that's a consideration I guess... ;-)
21:26:28 <lispy> ivanm: hmm...generic graph?  So like a replacement for inductive graph?
21:26:41 <ivanm> yes
21:26:52 <ivanm> which works with [Int]Map-based things, etc.
21:27:03 <ivanm> which a lot of people use because they don't like FGL or Data.Graph
21:27:13 <ivanm> so this way we could have algorithms that worked for all of them
21:27:57 <Axman6> ivanm: obviously you don't have enough fu then ;)
21:28:03 <ivanm> Axman6: heh
21:28:27 <sproingie> ENOFU
21:28:45 <ivanm> emofu?
21:29:00 <Axman6> emofucutcutcut
21:30:59 <ivanm> heh
21:32:47 <BMeph> Is there a binding to plot in Scheme? What would they call it, Conspiracy? ;p
21:33:25 <Makoryu> That would be a pretty awesome name for a programming language
21:34:12 <BMeph> An even better one would be Cabal, but...y'know. So,... yeah. :)
21:39:49 <blackdog> BMeph: hm. i do like the idea of a series of related packages with related names. Maybe the haskell section of Hubris should get its own moniker. Pride, maybe?
21:40:13 <FunctorSalad_> someone remarked once why not (Eq Void), but I forgot why :(
21:40:14 <ivanm> what's Hubris?
21:40:34 <ivanm> FunctorSalad_: because you don't want to try comparing things to the void?
21:40:34 <ivanm> ;-)
21:41:04 <FunctorSalad_> ivanm: but you can't obtain a::Void, so it's ok to compare them, no?
21:41:13 <FunctorSalad_> (it was some undefined-weirdness again)
21:41:19 <ivanm> I have no idea what Void is ;-)
21:41:23 <FunctorSalad_> data Void
21:41:30 <FunctorSalad_> (that's it)
21:41:37 <ddarius> FunctorSalad: I don't see anything wrong with it.  The only reasonable definition is _ == _ = undefined
21:44:18 <ddarius> Actually, even _ == _ = True might be sensible.
21:44:52 <FunctorSalad_> yes :) (maybe the problem was only with deriving more general classes for Void)
21:45:48 <FunctorSalad_> I guess the proper Eq instance depends on what the laws for Eq are in the presence of bottoms
21:46:26 <Axman6> giggity
21:47:46 <ivanm> Axman6: "giggity"?
21:47:57 <Axman6> lrn2familyguy
21:48:07 <ddarius> From the perspective of a total language, none of these functions would be callable so any implementation would be acceptable.
21:50:07 <mmorrow> does anyone know exactly what the difference is between (data Foo = forall a. Foo a) and (data Foo = exists a. Foo a)?
21:50:31 <ddarius> mmorrow: The latter doesn't exist (in GHC)
21:50:40 <ivanm> Axman6: "lrn2familyguy"?
21:50:45 <mmorrow> ddarius: right, suppose this is some hypothetical language
21:51:03 <ddarius> mmorrow: But technically, if you take the logic for the use of forall a in the former, then it would mean something different from the latter.
21:51:18 <Axman6> ha. oo = inifity in wolfram alpha
21:51:26 <Gracenotes> hm. do recursive descent parsers, to some extent, remove the need for an extra tokenization phase?
21:51:40 <ddarius> Gracenotes: Not usually.
21:51:43 <Gracenotes> particularly in programming language parsing
21:52:03 <ddarius> Gracenotes: You could get rid of them, but in many cases you could with other tools (painfully)
21:52:34 <mmorrow> ddarius: ok, so syncing background assumption. (1) i've read that "conveniently" (forall a. Foo a) is "kinda" like exists in system F, and (2) what's the relation of using system F as a base to how haskell types are "concrete by default" as opposed to "abstract by default" (like in ML modules)
21:52:35 <mmorrow> ?
21:52:51 <FunctorSalad_> the latter would (by that logic) be "Foo :: exists a. a -> Foo", which is like "Foo :: forall r. (forall a. (a -> Foo) -> r) -> r"
21:53:13 <mmorrow> FunctorSalad_: "like" := ?
21:53:32 <mmorrow> (is exactly what i'm after, yes)
21:53:49 <FunctorSalad_> mmorrow: isomorphic (except I'm not sure whether r may depend on a in some way)
21:53:54 <mmorrow> hmm
21:54:09 <Gracenotes> ddarius: hm, I see. I suppose with laziness, one could do tokenization and parse tree construction effectively 'simultaneously'.. perhaps better to keep things logically separate which should be
21:54:46 <mmorrow> FunctorSalad_: that's a good way to say it. what notion of isomorphism are they using here?
21:55:30 <FunctorSalad_> mmorrow: existence of functions to/from which are inverse to each other?
21:56:15 <FunctorSalad_> mmorrow: I noted the iso here http://www.haskell.org/haskellwiki/Existential_type#Existentials_in_terms_of_.22forall.22
21:56:20 <ddarius> mmorrow: The former means: forall a. a -> Foo <=> (exists a. a) -> Foo, the latter means exists a. a -> Foo <= (forall a. a) -> Foo
21:57:01 <mmorrow> FunctorSalad_, ddarius: ok perfect, thanks
21:57:22 <ddarius> Gracenotes: The main issue with tokenizing while parsing is coding complexity.  There isn't really any difference between lexing and parsing.
21:58:38 <ddarius> Gracenotes: You can see some of this fuzziness in, for example, keywords which are sometimes lexed into separate tokens and sometimes into just a KEYWORD token or even a generic IDENTIFIER or WORD token.
21:59:06 <ddarius> Parsec parses tend to include tokenization with parsing.
21:59:19 <ddarius> s/parses/parsers
21:59:42 <mmorrow> ddarius: hmm, ok re: (exists a. a). what would the syntactic scope then be of that "a", e.g. (a -> (exists a. a) -> a)?
22:00:25 <ddarius> mmorrow: exists and forall are binders.  In (exists a. a) the scope would just be those parentheses as usual.
22:00:52 <mmorrow> ddarius: hmm, alright. what i'm really after are various syntactic ways to indicate type sharing of existential types
22:00:56 <Gracenotes> hm
22:01:26 <mmorrow> data Foo = exists a. Foo a;  data Goo = exists a. Goo (b -> Int); with Foo.a = Goo.a;    (or something)
22:01:30 <mmorrow> err,
22:01:38 <Gracenotes> there is also some redundancy too. of course, the good thing about redundancy is that it makes things more organized
22:01:38 <mmorrow> data Goo = exists a. Goo (a -> Int)
22:01:45 <Gracenotes> sometimes
22:02:12 <mmorrow> s/type sharing/type equality/
22:03:37 <ddarius> mmorrow: Those would need to be packaged together or perhaps you could open Foo in Goo and unify a with the variable.
22:03:57 <mmorrow> (exists a. data Foo = Foo a; data Goo = Goo (a -> Int); four :: Goo -> Foo -> Int; four (Goo g) (Foo a) = g a) i guess
22:04:00 <mmorrow> right
22:04:26 <mmorrow> err, ah right, "opening"
22:04:41 <ddarius> (In the latter case, you may want a forall on Goo, the idea being "for every a that equals Foo's a"
22:04:46 <ddarius> )
22:05:35 <ddarius> I would have to think more about the latter case.
22:05:59 * mmorrow thinks about it as well
22:06:14 * ivanm just thinks in general
22:07:43 <copumpkin> unlike me
22:10:17 <ddarius> mmorrow: Yeah, the latter case I described doesn't lead to anything interesting.  You'd have type Foo = exists a. a; open Foo as x :: t in { type Goo = t -> Int; blah, blah, blah }.
22:11:04 <ddarius> This would be similar to the former case.  You have to have the Goo tied to a specific packing (exists) of Foo for them to work together.
22:13:43 <ivanm> copumpkin: well, yes, but we put up with you anyway ;-)
22:13:54 <copumpkin> and for that I am thankful!
22:14:36 <mmorrow> ddarius: ah, nice
22:14:39 <ivanm> even though on certain locations you profess a belief that you are a deity...
22:15:30 <copumpkin> ivanm: like reddit?
22:15:35 <ddarius> mmorrow: You may find looking at papers behind lambdaProlog interesting in this regard as they very explicitly and concretely use existential and universal quantification for modularity purposes.
22:15:46 <ivanm> copumpkin: exactly
22:16:38 <mmorrow> ddarius: ah perfect
22:16:59 <ddarius> An ML signature is basically a big existential type around a record type.  A module matching that signature is a packing of a record.  Opening a module is opening the existential.
22:20:20 <duaneb> yo, #haskell
22:20:33 <duaneb> is there an *ascii* symbol that's not used in haskell's syntax?
22:20:43 <duaneb> Supposedly, `@' is used
22:20:47 <copumpkin> ?
22:21:04 <copumpkin> > let (?) = (+) in 5 ? 6
22:21:05 <lambdabot>   11
22:21:16 * BMeph was thinking of Twitter
22:21:23 <copumpkin> you could also use a double @ I think
22:21:26 <duaneb> > let (@) = (+) in 5 @ 6
22:21:27 <lambdabot>   <no location info>: parse error on input `@'
22:21:30 <duaneb> ooh
22:22:08 <ivanm> duaneb: @ is for at-patterns
22:22:33 <ivanm> > (\xs@(x:_) -> (x,xs)) [1..10]
22:22:34 <lambdabot>   (1,[1,2,3,4,5,6,7,8,9,10])
22:22:46 * BMeph thought they were "as-patterns," but he is often wrong...
22:23:57 <ivanm> BMeph: eh, they're the whatsisname-patterns that use @ for variables when pattern matching or whatever
22:28:55 <duaneb> ivanm: dammit, I forgot about that
22:29:13 <duaneb> I'm trying to create a documentation preprocessor for haskell
22:29:21 <duaneb> and I need just 1 significant character
22:29:50 <duaneb> there is the question mark...
22:30:00 <duaneb> I can't think; is that used for much?
22:30:01 <ivanm> methinks all the ascii ones are used for one thing or another...
22:30:18 <ivanm> duaneb: nope, don't think so
22:30:26 <duaneb> dammit
22:30:27 <ivanm> ' is used for chars, but only in pairs
22:30:33 <duaneb> why does haskell have to be used so thorougly?
22:30:42 <ivanm> duaneb: why? if it isn't used, what's wrong with ?
22:30:56 <duaneb> ivanm: nothings wrong with it :P
22:31:15 <ivanm> heh
22:31:20 <Rotaerk> duaneb, perhaps a character combination that's never seen in haskell would be appropriate
22:32:01 <ivanm> preflex: seen Raevel
22:32:01 <preflex>  Raevel was last seen on #haskell 9 hours, 35 minutes and 53 seconds ago, saying: hi hi
22:32:14 <ivanm> @tell Raevel Thank you very much for proof-reading my draft!
22:32:14 <lambdabot> Consider it noted.
22:32:44 <Rotaerk> oh lord.. a mailing system over IRC
22:32:55 <ivanm> wtf?
22:33:17 <Rotaerk> I'm assuming lambdabot will tell him than next time he logs on?
22:33:23 <duaneb> Rotaerk: yea
22:33:24 <ddarius> mmorrow: http://www.lix.polytechnique.fr/Labo/Dale.Miller/lProlog/docs.html The book at the bottom is probably a good overview.  A lot of the papers give specific information on modules in lambdaProlog if that isn't detailed enough.
22:33:32 <Rotaerk> heh
22:33:32 <ivanm> Rotaerk: oh, the @tell command
22:33:45 <ivanm> Rotaerk: well, the next time he says anything that isn't a lambdabot command
22:33:49 <ivanm> there's also memoserv...
22:37:10 <gokul> what am I doing wrong here? let l = [1, 2, 3] in sum l/length l
22:37:46 <ivanm> gokul: sum and length return integers
22:38:00 <ivanm> / (division) requires floating point numbers
22:38:13 <ivanm> try this: fromIntegral (sum l) / fromIntegral (length l)
22:39:26 <gokul> ah ok, that makes sense. but what if 'l' is a list of Doubles?
22:39:29 <ddarius> mmorrow: Crap.  That isn't what I want.
22:39:53 <ivanm> gokul: duh, sorry
22:39:55 <ivanm> then sum is right
22:39:55 <copumpkin> gokul: length still returns an Int (grr)
22:39:59 <ivanm> but length is still wrong
22:40:02 <ivanm> copumpkin: why grr?
22:40:04 <copumpkin> you can use genericLength
22:40:11 <copumpkin> ivanm: I think it's a silly default
22:40:13 <ivanm> copumpkin: only returns an Integral, doesn't it?
22:40:20 <ivanm> @type genericLength
22:40:21 <lambdabot> forall b i. (Num i) => [b] -> i
22:40:26 <ivanm> take it back
22:40:34 <ivanm> copumpkin: so you can have a list of length 2.3, can you?
22:40:39 <copumpkin> no
22:40:44 <copumpkin> you can have a list of length -3?
22:41:57 <copumpkin> I understand why it's Int, but after 11 years you'd think it'd change type to something like Word, at least (if not a special arbitrary precision Natural type)
22:42:09 <Rotaerk> > let safePerformIO = unsafePerformIO
22:42:10 <lambdabot>   not an expression: `let safePerformIO = unsafePerformIO'
22:42:40 <Rotaerk> > safePerformIO = unsafePerformIO
22:42:40 <lambdabot>   <no location info>: parse error on input `='
22:42:46 <copumpkin> you want @let
22:42:51 <Rotaerk> oh
22:42:52 <copumpkin> but unsafePerformIO isn't in lambdabot
22:43:18 <dme> hello channel
22:44:28 <ddarius> mmorrow: See Chapter 3 in Joshua Hodas' PhD dissertation.  That should be a decent overview of the relevant parts.
22:45:39 <Axman6> @let simonSaysPerformIO = unsafePerformIO
22:45:39 <lambdabot>  <local>:3:21: Not in scope: `unsafePerformIO'
22:45:44 <Axman6> lame
22:46:06 <Axman6> @let unsafePerformIO = const (test "unsafePerformIO")
22:46:07 <lambdabot>  <local>:3:25: Not in scope: `test'
22:46:11 <Axman6> @let unsafePerformIO = const (text "unsafePerformIO")
22:46:12 <lambdabot>  Defined.
22:46:15 <Axman6> @let simonSaysPerformIO = unsafePerformIO
22:46:16 <lambdabot>  Defined.
22:46:46 <Axman6> > simonSaysPerformIO (print 1)
22:46:47 <lambdabot>   unsafePerformIO
22:47:44 <ivanm> copumpkin: I would think Word would be better for efficiency purposes than a Natural type
22:48:09 <copumpkin> I wouldn't expect it to be that big a difference
22:48:29 <copumpkin> the S#/J# distinction already in Integer could be used to keep a native word around for the small values
22:48:36 <copumpkin> then the only overhead is checking the size
22:48:50 <ddarius> ivanm: What's wrong with a list of non-natural length?
22:49:22 <dme> anybody know where the haskell command option is in haskell-mode?
22:49:24 <ivanm> ddarius: copumpkin is saying that we should make length :: (Num t) => [a] -> t
22:49:32 <ivanm> dme: for emacs?
22:49:33 <copumpkin> ivanm: no I'm not
22:49:37 <Rotaerk> ddarius, that.. would be unnatural
22:49:39 <dme> ivanm, yes
22:49:42 <Rotaerk> *cough*
22:49:55 <ivanm> dme: what do you actually mean by the haskell-command option?
22:49:56 <copumpkin> ivanm: I'm saying it should either be [a] -> Word or [a] -> Natural
22:50:20 <copumpkin> and the various other things that explicitly check for negative integers and barf should follow suit
22:50:20 <dme> i  mean i get an error message when i try to load ghci
22:50:23 <ivanm> dme: I have this in my custom-set-variables if it's what you mean: '(haskell-program-name "ghci -idist/build/autogen")
22:50:27 <gokul> i'm still confused as to how do I go about dividing the sum of a list of Doubles by the length of the list, how exactly do i achieve that?
22:50:34 <ivanm> copumpkin: ahhhh
22:50:34 <dme> hmm k
22:50:37 <copumpkin> sum xs / genericLength xs
22:50:43 <copumpkin> aka liftA2 (/) sum genericLength ;)
22:50:46 <ivanm> @src genericLength
22:50:46 <lambdabot> genericLength []    = 0
22:50:46 <lambdabot> genericLength (_:l) = 1 + genericLength l
22:50:49 <ivanm> copumpkin: heh
22:50:54 <ivanm> @src length
22:50:54 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:51:02 <ivanm> length is just specialised on the type?
22:51:16 <ivanm> gokul: what copumpkin said
22:51:49 <gokul> what module is (genericLength) it in?
22:51:56 <gokul> Prelude doesn;t seem to have it
22:52:05 <quicksilver> @index genericLength
22:52:06 <lambdabot> Data.List
22:52:44 <quicksilver> isn't "sum xs / (fromIntegral . length $ xs)" better though?
22:53:00 <ivanm> better in which way?
22:53:09 <quicksilver> Int length is more efficient
22:53:15 <ivanm> efficiency wise, using genericLength appears to avoid conversion to/from Integer
22:53:15 <quicksilver> and then you do a single conversion at the end
22:53:24 <ivanm> quicksilver: ahhh
22:53:30 <quicksilver> the converion to/from Integer is an illusion ;)
22:53:35 <ivanm> quicksilver: :o
22:53:40 <quicksilver> fromIntegral gets specialised by the compiler anyway
22:53:42 <ivanm> INLINEd or something?
22:53:45 <ivanm> quicksilver: *nod8
22:53:48 <ivanm> s/8/*/
22:54:17 <gokul> quicksilver: would that work if xs were, for instance, a list of doubles too?
22:54:25 <ivanm> gokul: yes
22:54:28 <ivanm> @type fromIntegral
22:54:29 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:55:08 <quicksilver> > let av xs = sum xs / (fromIntegral . length $ xs) in av [1.5,2.5,3.5]
22:55:09 <lambdabot>   2.5
22:59:15 <Saizan__> also, genericLength is a foldr
22:59:28 <ivanm> isn't length?
22:59:33 <ivanm> or does it use foldl'?
22:59:44 <ivanm> (in which case, why doesn't genericLength?)
22:59:56 <copumpkin> foldr allows something like
23:00:04 <copumpkin> > genericLength [1..] > (3 :: Natural)
23:00:05 <lambdabot>   True
23:00:13 <ivanm> :o
23:00:17 <ivanm> but length doesn't?
23:00:20 <Saizan__> no
23:00:27 <Saizan__> because Int is not that lazy
23:00:27 <ivanm> > length [1..] > 3
23:00:31 <lambdabot>   mueval-core: Time limit exceeded
23:00:32 <ivanm> Saizan__: *nod*
23:00:45 <ivanm> > genericLength [1..] > (3 :: Integer)
23:00:46 <lambdabot>   * Exception: stack overflow
23:00:56 <ivanm> which types are accepted for that trick? just Natural?
23:01:21 <copumpkin> Natural is defined lazily
23:01:33 <copumpkin> I think it's actually unary peanos
23:01:48 <ivanm> *nod*
23:01:53 <ivanm> @hoogle Natural
23:01:53 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
23:01:53 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
23:01:53 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
23:02:05 <ivanm> wow, that's _so_ helpful lambdabot!
23:02:27 <copumpkin> it's in the numbers package I think
23:02:29 <copumpkin> @hackage numbers
23:02:29 <lambdabot> http://hackage.haskell.org/package/numbers
23:02:32 <copumpkin> (not Numbers)
23:02:35 <copumpkin> (grr)
23:02:49 <copumpkin> data Natural = Z | S Natural
23:03:05 <ivanm> yeah, in that sense I wish hackage was case-insensitive, at least for URLs
23:03:12 <copumpkin> me too
23:05:21 <copumpkin> (that isn't the natural I was talking about for the length default, by the way)
23:05:32 <ivanm> heh
23:05:36 <ivanm> copumpkin: not efficient enough?
23:05:45 <ivanm> you want Integer but with -ves disallowed?
23:05:48 <copumpkin> well, unary numbers aren't ideal for fast
23:05:50 <copumpkin> yeah
23:05:59 <copumpkin> maybe a binding to the mpn interface of gmp
23:06:13 <copumpkin> that may be too much, given how rough the API is
23:07:33 <ivanm> copumpkin: you mean you haven't fixed it yet? :o
23:07:34 <ivanm> :p
23:08:19 <copumpkin> well the next major release of GMP is supposed to have a nice natural API too, but the current one is "internal" with an advertised (but ugly) API for people who need the ultimate performance
23:08:46 <copumpkin> but so many things are signed right now that shouldn't be
23:09:18 <ivanm> yeah.... that credit card I picked up on the street shouldn't have been signed...
23:09:19 <ivanm> ;-)
23:09:25 <copumpkin> :o
23:10:03 <quicksilver> well binary-represented peanos are quite a bit more efficient
23:10:10 <quicksilver> asymptotically fine, in fact
23:10:16 <quicksilver> although still slow in practice
23:10:25 <copumpkin> oh, you mean for lazy naturals?
23:10:29 <quicksilver> yes
23:10:35 <quicksilver> isn't that what we were talking about? ;)
23:10:36 <copumpkin> that would also be nice to have
23:10:50 <copumpkin> well, I just wanted a fast natural type to replace all the bad instances of Int in the standard library
23:10:58 <copumpkin> indices into arrays/lists, lengths, etc.
23:11:09 <copumpkin> well, array indices can be Word
23:11:18 <Saizan> negative arrays indices are legit
23:11:24 <copumpkin> really?
23:11:25 <copumpkin> (or Fin)
23:11:33 <copumpkin> oh
23:11:42 <Saizan> > arrayList (-10,10) [1..20]
23:11:43 <lambdabot>   Not in scope: `arrayList'
23:11:44 <copumpkin> yeah I see
23:12:03 <copumpkin> but the Ix itself is converting that to a linear index
23:12:05 <copumpkin> which is still an Int
23:12:10 <copumpkin> (and should be a Word) :P
23:14:20 <copumpkin> anyway, bedtime
23:14:21 <copumpkin> ciao :)
23:14:27 <Saizan> bye :)
23:15:35 <FunctorSalad_> why does TH have its own Haskell AST types (missing some stuff) if there's a perfectly comprehensive one in the ghc api? portability and stability I think...
23:17:52 <FunctorSalad_> ok and maybe the ghc api is a bit messier ;)
23:19:58 <ivanm> FunctorSalad_: and less portable?
23:23:37 * FunctorSalad_ is wondering how viable it would be to make a haskell editor which operates on the ghc-api AST :)
23:24:29 <FunctorSalad_> you'd get a lot of stuff almost "for free". (e.g., display type of currently selected subexpression in the status bar)
23:25:24 <dmead> ?yow
23:25:25 <lambdabot> Couldn't find fortune file
23:25:28 <dmead> ?yow
23:25:29 <lambdabot> Couldn't find fortune file
23:25:33 <dmead> :/
23:25:51 <ivanm> @. elite quote
23:25:51 <lambdabot> JohNn0W4K 5ayS: oi I Ne3D A BReak. i juzT TRied 70 r3ad '0xphOrD' Az A Hex4dEcima|.
23:28:36 <Adamant> that really IS an elite quote
23:28:46 <Adamant> in more ways that one! :)
23:29:02 <danco> than 0x1
23:29:11 <dmead> hey guys
23:29:22 <dmead> do i need to install something to get parsec in a regular ghc install?
23:29:30 <dmead> or is that by default now
23:30:00 <ivanm> dmead: you need to install parsec...
23:30:16 <ivanm> it used to be part of extralibs I think, which means it's part of the platform now
23:33:29 <dmead> ah
23:33:40 <dmead> i thought since it was on the libs page it was in by default now
23:34:26 <ivanm> nope
23:35:28 <ivanm> in by default for 6.10.4 are rts, ghc, ghc-prim, integer, base, syb, array, packagestring, containers, bytestring, old-locale, old-time, filepath, unix (for the *nix version), directory, process, pretty, hpc, template-haskell, cabal, random, haskell98, extensible-exceptions
23:37:59 <dmead> ah
23:42:37 <BMeph> Does anyone have a good reason why it's so popular to say that Haskell "eliminates side-effects" when vastly more accurate to say that it "classifies" or even "identifies side-effects" instead? :\
23:43:09 <dons> "controls"
23:43:23 <dons> identifies/ tags/ delimits
23:43:42 <ivanm> BMeph: because we keep telling newbies not to do stuff in IO
23:43:56 <ivanm> (except, strangely enough, I/O...)
23:44:02 <Berengal> eliminates by lifting them into effects which happen up front... is my mental view anyway
23:44:59 <Gracenotes> hm. it's confusing why Parsec complains about a parse failing, when said parse occurs inside a 'many' block and failing should merely mean that the list ends. no?
23:45:13 * BMeph thinks "city delimits" would be an Awesome name for a blog...
23:45:17 <ivanm> Gracenotes: could be that _none_ of them parse?
23:45:24 <ivanm> and so it has no idea wtf to do...
23:45:36 <Berengal> Gracenotes, only if it fails on the first character of the parser, if I recall correctly
23:45:43 <ivanm> especially if many desugars to something like p1 `onFail` p2 `onFail` p3 ...
23:45:50 <Berengal> Unless you try it
23:45:59 <ivanm> ummm, forget that...
23:46:15 <ivanm> I for some reason am getting confused with polyparse's oneOf :s
23:46:37 <Gracenotes> well, the general structure is: statements <- many (spaces >> statement); char '}'. And statement itself is a choice (map try [...]), with some additional cleanup at the end
23:46:49 <Gracenotes> maybe I should just wrap the whole of statement in a try?
23:47:01 <ivanm> Gracenotes: what are you parsing there?
23:47:51 <Gracenotes> trying to parse a C-like language
23:48:01 <ivanm> *nod*
23:48:07 <Gracenotes> except with about 1% of the syntax
23:48:28 <Gracenotes> lemme try the try, so to speak
23:48:51 <dmead> :t callCC
23:48:53 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
23:50:01 <dmead> > callCC (\k -> if k == 0 then [1] else 1 ++ k 0)
23:50:02 <lambdabot>   No instance for (Control.Monad.Cont.Class.MonadCont [])
23:50:02 <lambdabot>    arising from a u...
23:50:13 <Gracenotes> okay, that fixed it. more complicated (many x) calls were wrapped with (many (try x)). Berengal, your inkling about consuming input seems correct
23:50:48 <lispy> When to use 'try' is the most confusing aspect of parsec, IMO
23:51:22 <Berengal> lispy, when in doubt... usually works
23:51:53 <dmead> > callCC (\k -> if k == 0 then [1] else [1] ++ k 0)
23:51:55 <lambdabot>   No instance for (Control.Monad.Cont.Class.MonadCont [])
23:51:55 <lambdabot>    arising from a u...
23:52:07 <Gracenotes> I use it quite a few times in the 40 lines of the parser
23:52:30 <lispy> What I've heard is that if you consume some input before you fail, then you'll need a 'try' if other parsers would need to see that consumed input
23:52:32 <Gracenotes> it just means that your grammar is context-free, I suppose -_-
23:53:20 <Gracenotes> and somewhat less efficient, trying various paths and whatnot. It's more space efficient than trying all possible paths at the same time, though, at least for big input
23:53:59 <lispy> I have yet to try it, but alex may be a nice way to go for your parser if you already have the grammar handy
23:54:45 <Gracenotes> I think we have another parser that's non-deterministic like that, for context-free (and beyond?) grammars...
23:54:46 <lispy> and on that note, I'm going to bed
23:55:22 <Gracenotes> night
23:56:12 <Gracenotes> http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Text-ParserCombinators-ReadP.html
23:59:38 <mmorrow> @tell ddarius great, thanks for the links
23:59:38 <lambdabot> Consider it noted.
