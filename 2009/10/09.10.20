00:00:17 <copumpkin> hasta and desde have names in the standard library, almost
00:00:23 <copumpkin> but maybe you're not supposed to use those?
00:00:38 <stanv> is it possible make alias to any type? Like this: type Tuple = (a,a)
00:00:52 <copumpkin> yes, except the a has to come from somewhere
00:00:55 <Ray__> copumpkin, nope, not supposed to
00:00:57 <copumpkin> type Tuple a = (a, a)
00:00:58 <c_wraith> stanv: it would have to be: type Tuple a = (a, a)
00:01:12 <stanv> c_wraith: thanks!
00:01:20 <stanv> copumpkin: :)
00:01:22 <c_wraith> copumpkin got there before me, though. :)
00:01:51 <stanv> read from down to up :)
00:12:28 <Ray__> And what's wrong with the typing here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10933#a10933 (error included)
00:19:34 <inimino> Ray__: typo on line 18
00:19:56 <Ray__> ...what a helpful error message.
00:20:12 <Ray__> It says error on line 1, and something about infinite types.
00:24:06 <inimino> Ray__: probably has something to do with 'x' being used as though it were a function, if you try to unify the types yourself it makes some sense
00:30:57 <stanv> is it possible require class for `a' in type Pair a = (a,a) ?
00:34:25 <ksf> argh ouch elerea can't handle external signals that arrive faster than the network is stepped
00:36:06 <aleator> I have a Ptr Double (with strides). Can I get an UArr efficiently?
00:36:25 <aleator> (Or other similar structure)
00:37:04 <copumpkin> not really
00:37:13 <copumpkin> not a UArr, anyway
00:38:47 <aleator> hmm
00:59:17 <ksf> it'd be cool if elerea wouldn't re-evaluate nodes that depend on external input that hasn't changed.
01:00:01 <ksf> that would allow me to step the network at each external event occurence without bad conscience (about performance)
01:00:08 <ksf> I _hate_ dropping events.
01:00:18 <ksf> ...at least implicitely.
01:02:35 <Saizan> elerea is yet another frp?
01:03:02 <ksf> it's the unsafePerformIO one.
01:05:36 <ksf> and even though it's essentially pull-based, laziness can't kick in as sampling the network is done by storing values inside IORefs, and the whole dependency graph is thus strict.
01:06:17 <ksf> that's not to say that I don't expect elerea to be faster than reactive even if I do all that unesscessary work of re-sampling unchanged input.
01:07:18 <SmurfOR> is it possible to love a type system?
01:07:31 <SmurfOR> it may just be the honeymoon period i suppose :)
01:07:50 <Saizan> yes, it is, you can't marry one yet though
01:08:45 <Saizan> ksf: how about a bastard child of elerea and Adaptive then?
01:09:25 <ksf> mhhh when pushing values into the net from the outside one can put some info into the nodes the signal depends on
01:09:48 <A1kmm> Does anyone know why GHC gives the following error message:
01:09:55 <ksf> @hpaste
01:09:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
01:10:03 <A1kmm> Inferred type is less polymorphic than expected / Quantified type variable `vr1' is mentioned in the environment
01:10:20 <ksf> you can't jail-break existentials.
01:10:37 <ksf> they're confined to their scope.
01:10:54 <A1kmm> ksf: this isn't really intended to be an existential type, I am trying to use functional dependencies.
01:11:16 <A1kmm> The code is:   data DatabaseCache = DatabaseCache {
01:11:17 <A1kmm>         dbcacheFeedItems :: GetRec FeedItems vr1 => [Record vr1],
01:11:43 <ksf> Saizan, now look at what you've made me do. I'm reading a paper.
01:11:47 <A1kmm> I am only using the type there so functional dependencies will be used to work out vr1 so I don't have to repeat it.
01:11:57 <ksf> ...that is, I would, if the link wasn't broken.
01:12:00 <A1kmm> So is there any better way to do that (the type is very long).
01:24:37 * ksf wonders why elerea uses IO instead of ST
01:24:58 <ksf> ah outside accessibility of external inputs.
01:25:09 <quicksilver> and outputs like openGL, I imagine
01:26:05 <ksf> nope, that's a concern orthogonal to frp.
01:27:02 <ksf> ...you construct IO actions or a structure that's interpreted by some library with frp.
01:28:13 <quicksilver> well, elerea might have built in interfaces for that kind of thing
01:28:16 <quicksilver> but you're right, yes.
01:28:25 <quicksilver> my reactive implementation needs IO for timing and stuff
01:28:29 <quicksilver> can't do timing in ST.
01:28:43 <ksf> heh _that's_ pure in elerea.
01:29:20 <ksf> you pass in a delta time to a superstep function (that lives in the IO monad)
01:30:10 <quicksilver> sure, you can contstruct a model of a timed process without IO
01:30:13 <quicksilver> but you need IO to run it
01:30:25 <ksf> elerea is quite bare-bones, and that's good
01:30:35 <quicksilver> I have a pure interface but I need IO to run
01:31:21 <ksf> that's going to be fine for at least another say 20 years.
01:31:49 <c_wraith> gah.  I'm geting lost in typeclasses I don't know well enough.
01:32:01 <ksf> elerea's interface is pure, too, btw.
01:32:32 <ksf> ...and vasly applicative, the rest being MonadFixy.
01:32:45 <c_wraith> What's the cleanest way to read the first 8 bytes of a file and turn them into a Word64?
01:33:04 <ksf> Word64's binary instance?
01:33:07 <terminus_> Hi.  I have a question
01:33:15 <c_wraith> Ok.  Binary typeclass it is
01:33:21 <ksf> depends on endianess, of course.
01:33:44 <c_wraith> Don't actually care, for my use. :)
01:33:46 <terminus_> I'm trying to parse a number (while working on write scheme in 48 hours)
01:34:00 <terminus_> parseNumber :: Parser LispVal
01:34:08 <c_wraith> (which is reading from /dev/random
01:34:09 <c_wraith> )
01:34:10 <terminus_> parseNumber = liftM (Number . read) $ many1 digit
01:34:11 <ksf> > read "123" + read "321" ::Int
01:34:12 <lambdabot>   444
01:34:13 <EnglishGent> I'm going through that at the moment terminus_ :)
01:34:19 <EnglishGent> (write scheme in 48 hours)
01:34:19 <EnglishGent> :)
01:34:21 <terminus_> :)
01:34:34 <terminus_> so this works for me: parseNumber = liftM (Number . read) $ many1 digit
01:35:22 * ksf prefers (Number.read) <$> many1 digit
01:35:52 <terminus_> however: parseNumber2 = (>>=)  (many1 digit) (liftM (Number . read))
01:35:59 <terminus_> this gives a type error
01:36:16 <ksf> many1 digit >>= return . Number . read
01:36:28 <Botje> yes
01:36:30 <terminus_> ksf: don't know the <$> operator yet :)
01:36:30 <skorpan> @src liftM2
01:36:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:36:38 <ksf> <$> == fmap
01:36:45 <Botje> liftM f x = x >>= return . f
01:36:52 <ksf> == liftM == liftA
01:36:56 <skorpan> uh, i wasn't following your discussion, that was just a conincidence
01:37:12 <ksf> == (.)
01:37:16 <skorpan> i'm reading the cafÃ© list about the "between 0.5 and -0.5"..
01:37:19 <Botje> (in caleskell)
01:37:27 <terminus_> this is probably a stupid question: but why is liftM not appropriate here
01:37:27 <Axman6> @check \x -> liftM (+2) x == liftA (+2) x
01:37:28 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary (m a),
01:37:29 <lambdabot>                    GHC.S...
01:37:32 <Axman6> bah
01:38:05 <Botje> terminus_: it is, but not if you use >>= too
01:38:07 <ksf> @check \x -> liftM (+2) x == liftA (+2) (x :: [Int])
01:38:07 <lambdabot>   "OK, passed 500 tests."
01:38:14 <Botje> liftM (Number . read) $ many1 digit
01:38:17 <Botje> is equivalent to
01:38:27 <Botje> many1 digit >>= return . Number . read
01:38:36 <Axman6> > liftM (+2) [1..10]
01:38:37 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
01:38:52 <ksf> > toUpper . "amazing"
01:38:53 <lambdabot>   "AMAZING"
01:39:02 <Axman6> o.O
01:39:07 <Axman6> who broke (.)!
01:39:14 <ksf> :t (.)
01:39:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:39:18 <ksf> why it's fine.
01:39:21 <SmurfOR> (.) was an inside job!
01:40:06 * Axman6 blames Cale 
01:40:19 <Axman6> he's up to no good that man, i swear it
01:40:41 <Axman6> ksf: actually that is quite useful. somehow feels sort of rubyish though
01:40:52 <Baughn> > liftA2 (,) 3
01:40:53 <lambdabot>   No instance for (GHC.Num.Num (f a))
01:40:53 <lambdabot>    arising from the literal `3' at <int...
01:41:00 <Axman6> like "hello".toUpper.foo.randomStuff
01:41:25 <ksf> I thought it was perl that holds the standard of being flexible beyond comprehension
01:41:52 <Baughn> @let (.) x a b = b (a x)
01:41:53 <lambdabot>  <local>:19:0:
01:41:53 <lambdabot>      Multiple declarations of `L..'
01:41:53 <lambdabot>      Declared at: .L.hs:79...
01:42:18 <terminus_> Botje, ksf: Thanks.  Heading back to process all this :)
01:42:32 * scott_ attacks Axman6 for using camelcase in a Ruby method
01:42:47 * Axman6 stabs all the underscore users
01:42:56 <Axman6> DEATH TO UNDERSCORES!
01:42:58 <scott_> Get out of my Ruby!
01:43:26 <Axman6> screw ruby
01:43:27 * Baughn sends Axman6 to #haskell_
01:44:33 <Axman6> i hate using underscores in code. i find it much harder to read than camelcase
01:45:08 <scott_> I tend to follow the common style for whatever language I'm using
01:45:31 <scott_> I don't really have any strong feelings for underscores or camelcase
01:48:38 <stanv> I can't understand task: "You are asked to implement search trees with a count of the number of times element occurs." . Earlie said that each value can occur one one time, without duplicates.
01:50:01 <fasta> What happens when you marshall an undefined value to C? I expect a run-time error, but it would be nice to know if it wouldn't happen.
01:50:02 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
01:50:17 <A1kmm> hmm, so is it impossible to rely on functional dependencies outside of the type class they are defined for?
01:50:28 <A1kmm> and is there any extension to relax that behaviour?
01:50:38 <quicksilver> fasta: the FFI forces the value, so you'll get a runtime error
01:51:02 <quicksilver> (it has to force it to place it on the C stack for the function call)
01:51:25 <quicksilver> A1kmm: not sure that makes sense. functional dependencies can be relied on everywhere..
01:51:42 <fasta> quicksilver: yes, that's what I expected, but it might simply translate undefined to 0 under the hood.
01:51:53 <A1kmm> hmm, ghc seems to be treating myvr in: type TableRecords r = GetRec r myvr => [Record myvr]
01:51:59 <fasta> quicksilver: that would qualify as a big hack, though.
01:52:01 <c_wraith> err.  I haven't worked with bytestrings before.
01:52:09 <A1kmm> as if it was an existential variable.
01:52:14 <c_wraith>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
01:52:14 <c_wraith>            against inferred type `ByteString'
01:52:28 <A1kmm> Even though GetRec is defined as "class GetRec er vr | er -> vr, vr -> er where"
01:52:45 <quicksilver> c_wraith: strict/laxy bytestring are different types
01:53:06 <c_wraith> I thought I was using lazy bytestrings. >_>
01:54:17 <quicksilver> A1kmm: don't think that's legal at all
01:54:31 <quicksilver> A1kmm: type synonyms can't hide variables
01:54:56 <A1kmm> quicksilver: It isn't supposed to hide myvr, I want myvr to inferred from r and the functional dependency.
01:55:08 <c_wraith> Oh. I think I see...
01:55:32 <A1kmm> quicksilver: I've tried doing it without the type directly in data as well, with the same result.
01:55:58 <quicksilver> it will be inferred but it still has to be a variable.
01:56:08 <quicksilver> I appreciate that seems odd but there you go ;)
01:56:26 <quicksilver> I'm not entirely sure type synonyms with constraints work well, either
01:56:31 <quicksilver> I never use them
01:56:52 <A1kmm> quicksilver: So is there any other way to achieve the same thing?
01:56:58 <c_wraith> There.  Looking at two different sets of docs that I thought were the same ones.
01:57:12 <c_wraith> ...  Just because all the functions were the same.
01:57:42 <A1kmm> quicksilver: (or a ghc extension that lets functional dependencies be used in that way)?
01:58:15 <quicksilver> to me it seems like you're asking a solution to a non problem.
01:58:27 <quicksilver> you have to keep the variable around, but it will be correctly inferred
01:58:33 <quicksilver> the functional dependency does work
01:58:41 <quicksilver> it just doesn't stop you having to mention the variable.
01:59:36 <A1kmm> oh... all the way up my hierarchy (I have a data inside a data inside a data)...
02:00:09 <A1kmm> I guess that should work, it just looks like it would get out of hand if I had too many such variables.
02:00:16 <fasta> Can I tell c2hs to use C99?
02:00:59 <dcoutts> fasta: it should grok C99 + GNU extensions
02:01:17 <fasta> The type specifiers of this declaration do not form a legal ANSI C(89) type.
02:01:23 * Axman6 would love it if it could also grok blocks
02:01:54 <fasta> GCC processes it correctly.
02:02:02 <dcoutts> fasta: what form is that exactly?
02:03:10 <Axman6> hmm, implementing B-trees in haskell is difficult :(
02:03:15 <fasta> dcoutts: http://paste.debian.net/hidden/5da08545/
02:03:26 <quicksilver> A1kmm: there is a GHC extension which solves this, and that's type families / associated types
02:03:51 <fasta> dcoutts: (I do #include <stdbool.h>)
02:03:54 <quicksilver> A1kmm: it's a completely different approach but the main effect is to make "r" the main type and "myvr" a property of that type.
02:04:02 <quicksilver> you can't easily do two way deps though I believe
02:05:13 <dcoutts> fasta: and does that typedef bool as _Bool ?
02:05:29 <dcoutts> _Bool being the C99 type
02:05:53 <quicksilver> C99-- # ridiculous to define types with names like that ;)
02:05:53 <fasta> dcoutts: I believe bool is a macro, which expands to _Bool, yes, but I haven't checked that GCC does that.
02:06:21 <A1kmm> quicksilver: Ah... I'm not sure that will work for me, because the functional dependency comes from an existing library (HaskellDB), but looks like it would be the solution otherwise.
02:06:24 <fasta> quicksilver: basically to please everyone else already using a bool type (a horrible design decision).
02:07:09 <quicksilver> legacy++ # making committees everywhere a laughing stock by forcing them to make absurd design decisions.
02:08:01 <dcoutts> fasta: works for me, gcc and c2hs process it ok
02:09:25 <dcoutts> fasta: so it parses it ok, but I'm guessing you're using get/set on the bool fields? the rest of c2hs might not grok the new C99 basic types
02:09:52 <fasta> dcoutts: I do that in the rest of the file. Let me see whether I can create a minimal example.
02:15:17 <fasta> dcoutts: I found a rather interesting minimal example: the empty file. Make a file containing module Wowsers where
02:15:17 <fasta> #include "test".h
02:15:19 <dcoutts> fasta: hmm, though it's not clear what Haskell FFI type to map C99 _Bool to
02:15:36 <fasta> dcoutts: yes, that's the second thing I did before I asked here.
02:16:07 <dcoutts> fasta: that's what I did, I made an empty .chs file and ran c2hs test.h test.chs
02:16:27 <dcoutts> where test.h is the code you pasted, plus #include <stdbool.h>
02:16:47 <fasta> dcoutts: yes, but now I am referring to another example.
02:16:48 <quicksilver> dcoutts: as we were discussing only the other day, C99 doesn't specify an ABI ;) I imagine that on the x86 ABI _Bool is passed in a word though.
02:17:30 <fasta> dcoutts: so, test.h is completely empty.
02:17:54 <dcoutts> quicksilver: mm
02:19:57 <fasta> Is there any particular reason why you cannot write module Foo where #include "test.h"?
02:22:47 <Baughn> Is the cvs.haskell.org pserver broken for anyone else? I get authorization errors.
02:22:56 <Baughn> (Instructions at http://cvs.haskell.org/)
02:23:08 <fasta> Ok, it depends on the contents of the file Foo.chs whether or not the header file is parsed correctly.
02:23:31 <fasta> It seems a leak of laziness.
02:23:54 <MyCatVerbs> Baughn: uh, I don't think anybody actually uses CVS any more?
02:24:01 <Baughn> MyCatVerbs: haskell-mode does
02:24:11 <dcoutts> fasta: yes, a bug in the c2hs parser, put a blank line at the top of the .chs file.
02:24:15 <MyCatVerbs> Ah, bummer.
02:24:24 <Baughn> And I now can't get at it.
02:25:18 <dcoutts> fasta: so it's not a laziness issue, since it does not parse directives in the the initial line properly it then does not know to look at the .h file.
02:26:02 <dcoutts> the bug is that it looks for \n# but of course at the first line in the file there is no preceding \n
02:26:11 <dcoutts> bug in the lexer
02:26:13 <fasta> dcoutts: I think this is something else. If I uncomment one line at the end of the file, it stops working.
02:26:41 <fasta> --  sizeOf _ = {#sizeof colliding_box_t #}
02:27:05 <fasta> So, uncommenting this (in a file containing lots of other stuff) results in an illegal type.
02:27:27 <dcoutts> is that surprising?
02:27:27 <fasta> Currently part of an empty Storable instance.
02:27:32 <marcuse> could anyone explain this? (surely something very simple) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4441#a4441
02:27:39 <dcoutts> fasta: isn't colliding_box_t the one that contains _Bool ?
02:27:51 <PetRat> How does one find a profiling version of a particular library, in this case Control.Monad.Random?
02:28:04 <dcoutts> so calculating the sizeof, when it does not know about the _Bool type is indeed likely to fail
02:28:14 <fasta> dcoutts: yes, so, in that sense not _very_ surprising, but just that C99 apparently does not completely work.
02:28:39 <FunctorSalad_> PetRat: cabal install --reinstall --enable-library-profiling --ghc-option=-auto-all
02:28:40 <Saizan_> PetRat: you've to reinstall the package with -p
02:28:53 <FunctorSalad_> ooh that's shorter
02:29:12 <fasta> I will just typedef the bool and be done with it.
02:29:18 <dcoutts> fasta: yes, you're quite right, while c2hs can parse all of C99, it does not fully support binding to all of it
02:29:22 <dcoutts> fasta: good idea
02:29:41 <PetRat> Saizan, FunctorSalad---I'll try it. (Saizan's version first.)
02:29:49 <Saizan_> marcuse: the semantics of readsPrec are not like that
02:29:59 <dcoutts> fasta: a ticket in the c2hs trac would be good so we don't forget
02:30:37 <Saizan_> PetRat: well, -p is a shortcut for --enable-library-profiling, and you need --reinstall if the package is installed already
02:30:51 <FunctorSalad_> :)
02:31:04 <Saizan_> marcuse: the semantic of readsPrec is a bit different than what seems to be your understanding
02:31:24 <marcuse> Saizan_: yes, i'm trying to figure it out
02:31:42 <Saizan_> ?type readsPrec
02:31:43 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
02:31:47 <PetRat> the  ghc-option=-auto-all has something to do with placing cost centers on all functions in the library?
02:31:57 <FunctorSalad_> PetRat: yep
02:32:03 <marcuse> Saizan_: according to that readsPrec does what i built, right?
02:32:33 <marcuse> one string -> one instance, string
02:32:39 <marcuse> the int is ignored in all examples i've found
02:32:58 <Saizan_> marcuse: in "String -> [(a, String)]" in here you're supposed to consume a prefix of the input string to build your value, and return the rest of the string in the tuple with it
02:33:06 <FunctorSalad_> nomnomnom
02:33:09 <marcuse> aha!
02:33:29 <marcuse> Saizan_: thanks!
02:34:04 <Saizan_> nad you can use e.g. lex to deal with whitespace and such
02:34:08 <Saizan_> ?type lezx
02:34:09 <lambdabot> Not in scope: `lezx'
02:34:10 <Saizan_> ?type lex
02:34:12 <lambdabot> String -> [(String, String)]
02:36:05 * Baughn wonders who, if anyone, is maintaining haskell-mode now.
02:36:30 <Baughn> Saizan_: Why is that a list? Does it ever return more than one?
02:38:52 <Saizan_> Baughn: not sure, but it fits better with readsPrec etc. that way
02:39:06 <Saizan_> basically it's using StateT String [] as a parser monad
02:39:41 <opqdonut> @unmtl StateT String []
02:39:41 <lambdabot> err: `StateT String []' is not applied to enough arguments, giving `/\A. String -> [(A, String)]'
02:39:44 <opqdonut> @unmtl StateT String [] a
02:39:44 <lambdabot> String -> [(a, String)]
02:46:24 <quicksilver> Baughn: stefan monnier (sp.?) as far as I know is still maintaing it.
02:46:47 <Baughn> quicksilver: So I sent my patch to the wrong person, then. Still..
02:46:53 <Baughn> It's been two years since the last release
02:48:20 <skorpan> i find it curious that an emacs developer such as stefan monnier doesn't mind having a major mode with a key sequence containing C-g
02:50:02 <Baughn> A.. right.
02:50:20 <quicksilver> Baughn: he still maintains the CVS though
02:50:34 <fasta> skorpan: which?
02:50:41 <skorpan> fasta: haskell-mode
02:50:47 <skorpan> C-c C-g inserts and indents a guard
02:50:48 <fasta> skorpan: no, I mean sequence.
02:51:03 <fasta> Oh, well, cannot be bothered about that ;)
02:51:14 <skorpan> i hit C-c C-g all the time by accident
02:51:28 <quicksilver> that's odd, I agree with skorpan
02:51:32 <opqdonut> :D
02:51:34 <skorpan> mostly because i was going to hit C-c followed by something else and changed my mind and want to escape the squence
02:51:44 <A1kmm> hmm, is there a way in TH to use a TypeQ as a type - something like the splice operator but for types?
02:53:45 <FunctorSalad_> Control.Monad.Trans.lift doesn't have a Monad m constraint?
02:53:57 <quicksilver> Baughn: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/CONTRIB/haskell-modes/emacs/
02:54:03 <quicksilver> Baughn: most recent changes 8 months ago
02:54:06 <quicksilver> Baughn: so, not completely dead.
02:55:10 <quicksilver> skorpan: in fact, your bug was removed in may 2008 ;)
02:55:17 <quicksilver> 2008-05-30  Stefan Monnier  <monnier@iro.umontreal.ca>
02:55:25 <quicksilver> Disable C-c C-g binding
02:55:38 <skorpan> quicksilver: oh, i see...  i remember sending some comment about it, but i never received any response
02:56:12 <LambdaFred> @pl \number digit -> 10*number + digitToInt(digit)
02:56:12 <lambdabot> (. digitToInt) . (+) . (10 *)
02:56:17 <LambdaFred> lol
03:00:05 <Volfram> join #yate
03:00:27 <Volfram> oops, sorry
03:07:32 <jkff> Hi. Any thoughts on how to optimize parsec3 performance? My .prof file looks fearsome: it's completely dominated by parsec's >>=, uncons, etc. Core tells me that it might be because the parser has not been specialized to the identity monad and to the bytestring instance of Stream.
03:09:21 <juhe> Hello people, I have an Word32 and need to convert it to Float, any ideas?
03:09:56 <jkff> > fromIntegral (5::Word32) :: Float
03:09:56 <lambdabot>   5.0
03:10:45 <blueonyx> is there a function like all, but it takes a list of predicates?
03:10:46 <juhe> Right.... I wrote wrong spec, the Word32 is actually float from C (4 bytes).
03:11:15 <juhe> I.e. 32 bits = 1 sign, 8 exponent, 23 significand
03:11:38 <mux> you want a CFloat
03:12:02 <juhe> Ok, I can use realToFrac to convert from CFloat to Float
03:12:18 <juhe> Is there an easy way to get CFloat from Word32?
03:12:45 <jkff> Is there a way to know why a {-# SPECIALIZE #-} pragma has no effect? Some ghc flag perhaps?
03:13:05 <mux> why would you want a Word32 since the correct type is CFloat?
03:13:34 <juhe> I'm using binary to decode some float numbers written to disk from C.
03:13:50 <jkff> mux: Why don't you look at the Binary instance for Float, then?
03:13:57 <jkff> Oh, I mean, juhe:
03:14:34 <juhe> As I understand instance Binary Float, it stores one Integer, and one Int which is 64 + 32 = 96 bytes, not 32 bytes.
03:15:26 <kalven> bits
03:15:29 <ClaudiusMaximus> juhe: hGetBuf, peekArray
03:15:31 <mux> you shouldn't need Binary here, you can just use the FFI, CFloat, and its Storable instance via peek
03:15:35 <juhe> bits* right...
03:15:54 <mux> otherwise see this package: http://hackage.haskell.org/package/data-binary-ieee754
03:16:02 <juhe> hm, FFI and storable looks interesting
03:16:16 <mux> look at that link though, it defines Binary instances to pickle C floats
03:16:24 <juhe> ...as well as data-biunary-ieee754...
03:16:32 <mux> well, it doesn't define instances but getters in the Get monad
03:16:39 <jkff> My god, parsing dates with parsec3 (parsedate) is so slow that I'm going to write an FFI binding to strptime
03:16:40 <mux> which is good enough
03:16:54 <juhe> Nod, that's what I need :-)
03:16:58 <juhe> thanks people!
03:17:07 <mux> you're welcome
03:17:55 <zygoloid> @type \x -> all ($x) -- blueonyx
03:17:56 <lambdabot> forall a. a -> [a -> Bool] -> Bool
03:18:25 <zygoloid> @type all . flip id
03:18:26 <lambdabot> forall b. b -> [b -> Bool] -> Bool
03:19:24 <blueonyx> thanks zygoloid i only got \ps a = and $ map (\p -> p a) ps
03:19:42 <simplicio> @src all
03:19:43 <lambdabot> all p =  and . map p
03:19:59 <blueonyx> @type all
03:20:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:20:22 <blueonyx> @sry and
03:20:23 <lambdabot> and   =  foldr (&&) True
03:20:26 <blueonyx> @srs and
03:20:27 <lambdabot> and   =  foldr (&&) True
03:20:36 <blueonyx> O.o
03:20:49 <ClaudiusMaximus> juhe: if you need a concrete example (of possibly dubious quality) i read a file consisting of contiguous GLfloat (native endian) here (search for first occurence of toMats to get to roughly the right part of the code...) https://code.goto10.org/svn/maximus/2009/dualist/reflex.hs
03:21:51 <skorpan> untrusted connection
03:22:48 <juhe> ClaudiusMaximus: ok, thanks!
03:23:34 <tuukkah> anyone got a fresh copy of http://darcs.serpentine.com/criterion which is down?
03:29:28 <profmakx> dcoutts, as a fallout from yesterdays hackage-downtime: it would be nice when cabal install gave some kind of error message when downloading some file fails
03:36:35 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10935#a10935
03:36:38 <ksf> that's so cool.
03:36:41 <ksf> I'm freezing.
03:37:39 <profmakx> ksf now reimplement it in Java! for the fun of it! *runs*
03:38:10 <ksf> no thanks, I had my share of continuation-passing java.
03:38:52 <ksf> ...or, rather, trampolining java, for the lack of efficient closures.
03:38:54 <oteren> what does it do?
03:39:06 <oteren> in laymans terms
03:39:32 <ksf> print this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10935#a10936
03:39:53 <ksf> ...if you leave out the first propagate it leaves out the 40
03:40:16 <mreh> what would you recommend as being the safest way to install gtk2hs?
03:40:47 <ksf> a chainsaw, a length of thin thread and some gaffa tape.
03:40:47 <sereven> mreh: use your package manager?
03:40:49 <profmakx> pacman -S gtk2hs
03:41:09 <profmakx> i was thinking about "dont do it". but then again
03:41:18 <mreh> sereven: sorry wrong channel, I have to back port from debian sid
03:44:06 <ksf> it's beatiful. it's the perfect push-based thingie.
03:50:28 <mreh> has anyone installed gtk2hs from a debian backports source before?
03:50:43 <mreh> and care to share the source with me? :(
03:51:12 * ksf recommends exorcising debian
03:51:34 <sereven> it's too bad it's not part of the Platform. That would be handy for situation like this.
03:51:56 <stanv> please help, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10937#a10937
03:51:57 <mreh> I'd prefer a secular solution
03:52:10 <ksf> a lobotomy?
03:52:14 <ksf> should work, too.
03:52:35 <mreh> I don't understand why you're being so unhelpful :(
03:52:41 <mreh> :..(...
03:52:52 <stanv> why I can't specify `a` as `(a1,a2)` in instance ?
03:53:09 <ksf> and he can see no reasons 'cos there are no reasons what reason do you need to be sure
03:53:17 <sereven> mreh: ksf has ingested too much reactivity and has become reactionary
03:53:23 <Cale> mreh: I've only installed the version from the gtk2hs website
03:53:35 <mreh> Cale: from source?
03:53:49 <Cale> Uh, yeah, I think it was from source.
03:54:15 <Cale> stanv: 'a' is not a parameter of your typeclass
03:54:32 <Cale> stanv: The implementation of foo must be completely polymorphic in a
03:55:48 <stanv> Cale: but, under 'a' I suggest 'tuple'
03:56:43 <Cale> stanv: Parametrically polymorphic functions are not allowed to decide what to do based on which type they actually get. They must act uniformly on all types.
03:57:43 <Cale> foo isn't allowed to do something fundamentally different if it's being used at type  Integer -> MyType Integer -> MyType Integer  than if it's being used at  (Bool, String) -> MyType (Bool, String) -> MyType (Bool String)
03:57:53 <Cale> er, missed a comma, but you get the idea
03:58:03 <fasta> How do I write foreign export ThisModule.foo:: CInt -> IO CInt?
03:58:13 <fasta> The ThisModule. part does not work.
03:58:18 <Cale> Basically, that polymorphism ensures that it does not inspect the value that it's passed in any way
03:58:34 <fasta> Of course, I can work around it, but it seems to be a bug.
03:59:10 <stanv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10937#a10938  -- see revision, also doesn't work :(
03:59:27 <fasta> If I leave of the ThisModule. part, it is ambiguous.
03:59:49 <Cale> stanv: you're still pinning down the type 'a' to be a pair
04:00:19 <Cale> stanv: try  foo z (Constructor _) = Constructor z
04:01:18 <stanv> Cale: :))
04:01:43 <stanv> but, i need access to part of z
04:02:13 <stanv> i know z - is a pair :)
04:02:34 <Cale> stanv: You don't know that z is a pair. Your type signature for foo allows it to be anything at all.
04:03:35 <Cale> According to the type signature for foo, I should be able to call  foo reverse (Constructor (map toUpper)) and have it work
04:03:47 <stanv> so... exit from this situation define something like data Pair a = Pair (a,Int) ?
04:03:54 <Axman6> hmm, i wonder how useful a function that worked something like this would be: replace x (c _) = c x, where c would match any constructor taking one argument
04:04:01 <Cale> Or change the type of foo
04:04:44 <stanv> Cale: like what?
04:05:11 <Cale> It seems like maybe you want  foo :: (a,b) -> f (a,b) -> f (a,b) ?
04:05:52 <Cale> Or perhaps you want a multiparameter typeclass
04:06:01 <Cale> class MyClass f t where
04:06:07 <stanv> Axman6: I don't Óonsider practicality :)
04:06:07 <Cale>   foo :: t -> f t -> f t
04:07:00 <stanv> I can't change signature for `foo' :( becose it is in class MyClass.
04:07:40 <mreh> I have installed the gtk2hs binaries, but how do I make it visible to cabal?
04:08:48 <stanv> :)
04:13:11 <SamB_XP_> ï¾“???
04:13:28 <Cale> stanv: Then your problem is that you really don't want to implement foo at all, but something completely separate.
04:18:04 <Saizan> mreh: they should be already if you got them installed for the right ghc
04:18:28 <mreh> Saizan: shall I explicitly tell it which GHC to install for?
04:19:08 <Saizan> mreh: you can tell cabal to use a particular ghc with the --with-ghc= flag
04:19:40 <mreh> after running the configuration script, the only packages it was installing were "glib" and "gio"
04:20:09 <Saizan> that's a bit weird
04:20:23 <Saizan> maybe you're missing the headers?
04:20:30 <Saizan> *gtk headers
04:20:56 <Saizan> you want to install the -dev package for gtk, if you're on debian
04:21:14 <mreh> Saizan: it's only been released on sid
04:21:21 <mreh> the unstable distribution
04:21:30 <mreh> libghc6-gtk-dev
04:21:49 <fasta> When I want to install Leksah I get Cabal hell: http://paste.debian.net/49527/
04:22:01 <Saizan> mreh: i meant the -dev for the C gtk package
04:22:27 <Saizan> mreh: it's needed to use the haskell bindings
04:24:00 <mreh> Saizan: GTK+ 2.0 we're talking about here?
04:24:06 <Saizan> mreh: yes
04:24:25 <mreh> Saizan: thanks
04:24:43 * SamB_XP_ still hasn't figured out what the 2 in gtk2hs stands for ;-P
04:24:52 <mreh> to?
04:25:26 <SamB_XP_> its clearly either that, or part of "gtk2"
04:25:33 <SamB_XP_> but which ???
04:26:02 <Saizan> fasta: try with --constraint="regex-posix < 0.80"
04:28:01 <fasta> Saizan: that gives a similar result.
04:28:41 <fasta> Saizan: and by similar I meant exactly the same ;)
04:29:10 <Saizan> bah.
04:29:54 <xenoblitz> dcoutts: Hi, if I am not mistaken you said currently Glade is not supported by gtk2hs... is this still true? Thanks :)
04:30:58 <SamB_XP_> xenoblitz: eh? there's libglade bindings ...
04:31:21 <mreh> unknown package cairo 10.1?!
04:32:01 <SamB_XP_> mreh: you may also need to install the -dev package for cairo?
04:32:15 <xenoblitz> SamB_XP_: i downloaded a version from dcoutt's website which works with GHC 6.10.3 but if I am not mistaken he said that Glade is not supported
04:32:35 <SamB_XP_> oh?
04:32:43 * SamB_XP_ wonders why you need a wierd version for that ...
04:33:10 <xenoblitz> SamB_XP_: I am not sure mind you... wanted to check with him because I need to do some GUI programming :/
04:33:19 <Saizan> maybe he just didn't build that package for that binary package
04:33:37 <mreh> SamB_XP_: that's the odd thing, it's already installed
04:33:45 <mreh> libcairo2-dev
04:34:09 <SamB_XP_> before you ran ./configure for gtk2hs ?
04:34:24 <xenoblitz> Saizan: if you are referring to me then what do you suggest?
04:35:03 <mreh> SamB_XP_
04:35:05 <mreh> yes
04:35:15 <SamB_XP_> mreh: huh!
04:35:47 <Saizan> xenoblitz: check the gtk2hs site for a binary package that suits your needs
04:35:47 <mreh> SamB_XP_, !!!!
04:36:30 <FunctorSalad_> "A monad is nothing but an algebra over the MonadM monad."
04:36:39 <FunctorSalad_> I like that.
04:36:45 <xenoblitz> Saizan: ironically if i use an older version I can't make use of leksah to program :P
04:37:19 <SamB_XP_> FunctorSalad_: that sounds ... really damn recursive ;-P
04:37:39 <xenoblitz> anyway's I'll try RWH's tutorial and see how it goes
04:37:48 <FunctorSalad_> it's from the http://hackage.haskell.org/package/compose-trans        package. looks cool
04:39:09 <Saizan_> xenoblitz: learn how to build it yourself then?:)
04:39:30 <xenoblitz> Saizan_: instead of using glade?
04:39:42 <xenoblitz> Saizan_: sure as soon as I can find a good tutorial to get me started
04:40:50 <xenoblitz> Saizan_: found http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/
04:41:00 <xenoblitz> Saizan_: hope its not outdated
04:42:28 <Saizan_> xenoblitz: i meant build gtk2hs
04:42:58 <mreh> I really don't understand how make can't find a package i've already installed
04:43:15 <mreh> although it's looking for cairo1.10, and i've got cairo2
04:43:37 <Saizan_> can you paste the full error?
04:43:42 <mreh> <command line>: unknown package: cairo-0.10.1
04:44:09 <Saizan_> running make?
04:44:13 <mreh> yeah
04:44:24 <xenoblitz> Saizan_: dcoutts said it's a very hard process... wouldn't even know where to get started
04:44:29 <Saizan_> i'd try make clean and restart from configure
04:45:02 <dcoutts> xenoblitz: what did I say was very hard?
04:45:11 * Saizan_ doesn't know much about gtk2hs though, so he's mostly guessing here
04:45:44 <Saizan_> dcoutts: building gtk2hs on windows
04:45:45 <xenoblitz> dcoutts: hi there... you remember you told me download a version of gtk2hs off your website but you said it doesn't support glade yet? Am I mistaken? Is that still true?
04:45:48 <dcoutts> ah, well it's not that hard
04:45:58 <dcoutts> xenoblitz: it's not changed
04:46:11 <mreh> Saizan_: good tip, i
04:46:25 <mreh> Saizan_: good tip, i'm going for a last ditch attempt and then giving up for a little while
04:46:30 <SamB_XP_> dcoutts: how come it doesn't support libglade ?
04:46:52 <dcoutts> SamB_XP_: the build I did was a minimal one for my own purposes. I did not need glade.
04:46:58 <SamB_XP_> ah.
04:47:40 <dcoutts> but since people were clamouring for a binary build that worked with 6.10.4 I made mine available, with that caveat
04:47:48 <FunctorSalad_> is there some name for this operation (T a transformer): ( (m a -> T m b) -> T m a -> T m b ) ?
04:47:50 <SamB_XP_> what makes gtk2hs so windows-unfriendly -- the configure script ?
04:47:56 <xenoblitz> dcoutts: does this http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/ still apply for not making use of glade?
04:48:12 <FunctorSalad_> like bind but with (m a) as the "ground level"
04:48:16 <dcoutts> SamB_XP_: yes, it's just more work to configure since you need to get the C libs installed etc
04:48:35 <SamB_XP_> dcoutts: well, yeah ...
04:48:42 <SamB_XP_> and with nowhere to install them!
04:48:55 <dcoutts> you can install them anywhere :-)
04:49:06 <dcoutts> and just set an env var to say where
04:49:08 <SamB_XP_> that's the problem precisely
04:49:41 <SamB_XP_> damn OS needs a distro
04:49:51 <dcoutts> xenoblitz: you can tell if it's using glade because it'll tell you that you need to import glade
04:49:54 <ivanm> which OS?
04:50:03 <SamB_XP_> ivanm: Windows
04:50:05 <ivanm> ahhh
04:50:14 <ivanm> that's classified as an OS now? :o
04:50:14 <ivanm> :p
04:50:26 <SamB_XP_> xenoblitz: also, there will be ".glade" files involved somehow
04:50:40 <SamB_XP_> ivanm: yeah, it's an OS
04:50:53 <xenoblitz> I am completely lost on what to do xD
04:50:54 <SamB_XP_> it just needs distros and packages
04:50:57 <Botje> GtkBuilder supercedes glade :)
04:51:04 <SamB_XP_> Botje: the what now ?
04:51:13 <SamB_XP_> does that use a different sort of file ?
04:51:17 <Botje> yes
04:51:28 <SamB_XP_> is there a library for loading them?
04:51:33 <Botje> yeah
04:51:38 <Botje> it's in the new gtk libs
04:51:45 <SamB_XP_> what, gtk 3?
04:51:54 <Botje> it's basically the "convention over configuration" approach applied to glade
04:51:56 <ski> FunctorSalad_ : i have pondered that one a little, calling it `tbind' tentatively
04:51:58 <Botje> no, in gtk 2.26ish?
04:52:10 <SamB_XP_> oh, how does that qualify as "the new"?
04:52:20 <ski> FunctorSalad_ : it is a `MonadMonad' (or maybe `MonadFunctor') method
04:52:22 <SamB_XP_> Botje: so, how does that change the format ?
04:52:23 <Botje> wait
04:52:26 <Botje> it's 2.12, even :)
04:52:38 <luite> dcoutts: have you documented how you built it for windows somewhere? I have made some instructions ( should still post them to the gtk2hs mailing list, http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10033 ) , but a few steps are probably not correct
04:52:43 <ivanm> Botje: yeah, that sounds familiar...
04:52:49 <SamB_XP_> Botje: you don't think I'm going to be able to remember the version, much less complain if you got it wrong ?
04:53:00 <Botje> http://www.micahcarrick.com/05-30-2008/gtk-builder-libglade-faq.html#3
04:53:05 <mreh> Saizan_: thanks
04:53:16 <mreh> it's compiled
04:53:16 <ski> FunctorSalad_ : hm, actually no .. i was thinking of `tbind :: (Monad m,Monad n) => (forall a. m a -> t n a) -> t m a -> t n a'
04:53:17 <Botje> SamB_XP_: some people do that :)
04:53:31 <FunctorSalad_> ski: I was going to say it :)
04:53:33 <SamB_XP_> I'd have been happy if you said "a recent 2.x"
04:53:36 <Botje> :)
04:53:42 <dcoutts> luite: you can simplify by using the C libs provided on the sourceforge download page
04:53:42 <Botje> well, gtkbuilder files are _MUCH_ smaller
04:54:10 <Botje> and you can generate them, if you want
04:54:12 <FunctorSalad_> ski: I call the other one "liftBind" now
04:54:13 <ski> FunctorSalad_ : so  `return' : `lift' :: `(=<<)' : ?
04:54:17 <mreh> woohoo, it works
04:54:22 <SamB_XP_> Botje: that's nice
04:54:24 <FunctorSalad_> ski: exactly
04:54:26 <ski> FunctorSalad_ : i was just going to suggest `liftBind' :)
04:54:42 <dcoutts> luite: the gtk2hs-0.10.0-clibs-win32(-dev).zip are available so you don't need to regenerate them
04:54:57 <SamB_XP_> they have better defaults I guess ?
04:55:05 <luite> dcoutts: ah I missed them because they are only in the 0.10.0 folder
04:55:34 <Botje> yup
04:55:40 <ski> FunctorSalad_ : if i may ask, what incited you to look for this operation ?
04:56:09 <luite> dcoutts: but they probably suffer from the same problems as the ones downloaded by the scripts, like outdated (and broken according to their site) gstreamer libraries
04:56:15 <FunctorSalad_> ski: though I'm not sure whether (liftBind f) isn't just ((=<<) (f . return))
04:56:33 <ski> @type \f -> (f . return =<<)
04:56:33 <FunctorSalad_> @type \f -> (=<<) (f . return)
04:56:34 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m1, Monad m) => (m1 a -> m b) -> m a -> m b
04:56:35 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m1, Monad m) => (m1 a -> m b) -> m a -> m b
04:56:53 <dcoutts> luite: maybe, I dunno, I omitted everything except for gtk + cairo
04:56:56 <Botje> http://www.pygtk.org/docs/pygtk/class-gtkbuilder.html
04:57:06 <Botje> compare that example to what glade spits out if you create something similar
04:57:22 <SamB_XP_> ski: that's a bit hard to read
04:57:27 <FunctorSalad_> ski: I was trying to make a "BinderT" that adds binders to a given theory ;)
04:57:31 <SamB_XP_> took me a while to realize it was a section
04:57:35 <FunctorSalad_> not sure if that's even possible
04:57:40 <SamB_XP_> and not a freak of parsing
04:57:43 <hackagebot> strptime 0.1 - Efficient parsing of CalendarTime using a binding to C's strptime (EugeneKirpichov)
04:57:52 <dcoutts> luite: those instructions look basically sane
04:57:52 <ski> FunctorSalad_ : in `\f -> (f . return =<<)', the `m1' type there is trivial (comes from the `return'), but in `liftBind', `m' is related to `t m'
04:58:01 <ski> FunctorSalad_ : so it should not be the same, i think
04:58:02 <FunctorSalad_> ski: but for example, the lambda calculus monad would be "BinderT FreeMagma"
04:58:56 <ski> SamB_XP_ : not harder than `\f -> (>>= f . return)' (or possibly even `\f -> (=<<) (f . return)'), i hope :)
04:59:29 <SamB_XP_> ski: not really, no
04:59:39 <ski> FunctorSalad_> @src BinderT
04:59:43 <FunctorSalad_> ski: but it still isn't subsumed by ((=<<) (f . return)) if you restrict the type?
05:00:01 <ski> hm
05:00:06 <SamB_XP_> ski: I guess it would just be easier with parens around the (f . return)
05:00:30 <FunctorSalad_> ski: current attempt is this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10940#a10940
05:00:35 <ski> SamB_XP_ : if you prefer
05:01:09 <ivanm> anyonw know what changes bos has made to statistics for the 0.3.5 release? his blog/darcs repo appear to be down...
05:01:24 <FunctorSalad_> ski: (using deBruijn indices)
05:01:56 <ski> what's the complete type of `liftBind' ?
05:02:28 <FunctorSalad_> class MonadTrans t => LiftBind t where
05:02:28 <FunctorSalad_>     liftBind :: Monad m => (m a -> t m b) -> t m a -> t m b
05:02:41 <FunctorSalad_> tentatively
05:02:44 <luite> dcoutts: I did build one C library frome source (gtkglext-1.2.0), by configure/compile in msys, followed by a make install into a specified dir and then zipping the dir's contents. but I ran into trouble because of .la files pointing (?) to the wrong locations. I 'fixed' it by deleting the .la files. do you know more about this?
05:03:33 <dcoutts> luite: I don't know a lot about .la files except that they're what libtool uses. Do the gtk+ win32 libs use them? If not I think it's fine to delete them.
05:03:34 <ski> FunctorSalad_ : so i suppose the question is whether, for a given known `t', one can "locally run" `t m a' to get not `a', but `m a', in a nontrivial way
05:03:52 <ski> (and `m' is arbitrary/unknown, here)
05:04:24 <ski> i.e., is there a sensible `foo :: m a' other than `return x :: m a' that one can pass to the argument ?
05:04:36 <FunctorSalad_> ski: it does seem possible... intuitively, (>>=) substitutes terms for variables while liftBind substitutes terms for terms of the base language
05:04:52 <FunctorSalad_> (going with the monad = language picture)
05:05:09 <trzkril> @hoogle a -> [a -> Bool] -> Bool
05:05:10 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
05:05:10 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
05:05:10 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
05:05:12 <luite> dcoutts: not sure, but I ran into trouble when trying to build a recent gstreamer, which has lots of dependencies. I'll look into it later
05:05:14 <ski> FunctorSalad_ : btw, in `BinderT deco m', `m' is suppose to be an expression monad, for your application ?
05:05:26 <FunctorSalad_> ski: yes
05:05:36 <dcoutts> luite: personally I'm quite happy to ignore gstreamer :-)
05:05:53 <FunctorSalad_> (so there are sensible (foo :: m a))
05:06:09 <FunctorSalad_> you'd need liftBind to lift the application or whatever, I think
05:06:56 <ski> FunctorSalad_> @src FreeMagma
05:07:54 <FunctorSalad_> ski: annotated the paste
05:09:03 <FunctorSalad_> ski: I reckon I'll need the Traversable too
05:09:12 <FunctorSalad_> (for the 'm')
05:09:12 <zygoloid> @type (\f x -> x >>= f . return) :: (Monad m, Monad (t m)) => (m a -> t m b) -> t m a -> t m b
05:09:13 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) b. (Monad (t m), Monad m) => (m a -> t m b) -> t m a -> t m b
05:09:14 <ski> so why do you decorate the binders with these trees ?
05:09:27 <luite> dcoutts: It's not that I need gstreamer, I just wanted to find out how to build those kind of things correctly on windows... in linux it always just works
05:09:29 <acidjnk> hello
05:09:36 <ski> also, since `FreeMagma :: * -> *', isn't `BinderT FreeMagma' a kind error ?
05:09:37 <dcoutts> luite: aye
05:09:58 <FunctorSalad_> ski: the 'deco' will give the use the possibility to make different kinds of binders, like data Deco = Exists | Forall
05:10:05 <dcoutts> luite: when you get it sorted, send patches in for the files/scripts in the main gtk2hs repo
05:10:12 <FunctorSalad_> ski: BinderT () FreeMagma
05:10:20 <ski> <FunctorSalad_> ski: but for example, the lambda calculus monad would be "BinderT FreeMagma"
05:10:24 <FunctorSalad_> *will give the user
05:10:24 <dcoutts> luite: the reason they were not updated for 0.10.1 is the release manager had a HDD crash
05:10:24 <ski> oh
05:10:32 <FunctorSalad_> oh right, that was a mistake
05:10:45 <ski> ok, then i understand
05:11:01 <acidjnk> I had a 4 semester course about CS in general, know very little FP, know the OO mainstream approach very well. Should I buy "Introduction to the Theory of Computation" (Michael Sipser) or are there alternatives to consider?
05:11:53 <ski> acidjnk : i would suppose it depends on what your goal is ..
05:12:14 <ski> (ftr, i have not read that book)
05:12:26 <acidjnk> Take the next step into CS.
05:12:29 <Cale> Sipser's book is good, but it's certainly not about FP.
05:13:02 <ski> acidjnk : SICP might be the kind of thing you're looking for
05:13:22 <ski> (it's not only FP, but certainly includes much of it)
05:13:53 <ski> CTM and TaPL might be interesting, as well
05:14:27 <acidjnk> I'm not currently looking for another FP book. Just CS in general.
05:15:18 <ski> SICP and CTM contain info on multiple paradigms
05:15:24 <ski> TaPL is about type systems
05:15:39 <acidjnk> thanks
05:16:31 <ski> ("Structure and Interpretation of Computer Programs", "Concepts, Techniques, and Models of Computer Programming", "Types and Programming Languages")
05:16:31 <SamB_XP_> acidjnk: consider grad school, also ;-)
05:16:36 <ski> @where SICP
05:16:36 <lambdabot> http://mitpress.mit.edu/sicp/
05:16:38 <ski> @where CTM
05:16:39 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
05:16:41 <ski> @where TaPL
05:16:42 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
05:16:43 <SamB_XP_> speaking of which ... where should I go for gradschool if I want to do FP?
05:16:50 <shambler> oh nice
05:17:09 <ski> acidjnk : ^ full title and links
05:17:38 <SamB_XP_> unfortunately, TaPL is not available for download afaik :-(
05:17:53 <ski> not CTM, either, iirc
05:18:07 <SamB_XP_> unlike ATaPL
05:18:15 <ski> (maybe you can find an old pre-release version pdf floating around on the web)
05:18:18 <SamB_XP_> which is really unreadable if you don't know type theory
05:18:35 <ski> oh, ATTaPL is available on the web ?
05:18:55 <SamB_XP_> I've seen it, yeah ...
05:19:04 <ski> @where ATTaPL
05:19:05 <lambdabot> I know nothing about attapl.
05:19:09 <SamB_XP_> ... but haven't read Types and Programming Languages
05:19:09 <ski> @where+ ATTaPL http://www.cis.upenn.edu/~bcpierce/attapl/
05:19:10 <lambdabot> It is stored.
05:19:12 <mux> I found it in PDF once
05:19:26 <mux> I need to buy it too, if only so that it keeps company to my TaPL book
05:19:27 <SamB_XP_> I probably saved a copy of said PDF
05:21:37 * SamB_XP_ is amused that uTorrent doesn't avoid trying to connect to its own UPnP-forwarded port ...
05:23:18 <Axman6> > map (round . sin) [0.0,0.01..]
05:23:20 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:23:23 <Axman6> > map (round . sin) [0.0,0.1..]
05:23:24 <lambdabot>   [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,...
05:23:33 <Axman6> > map (round . cos) [0.0,0.1..]
05:23:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
05:23:54 <Axman6> oh, bugger, now i know why that thing i was trying didn't work >_<
05:24:27 <SamB_XP_> Axman6: why ?
05:24:50 <Axman6> > map (round . (/2) . (+0.5) . cos) [0.0,0.1..]
05:24:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:24:59 <Axman6> > map (round . (/2) . (+0.5) . cos) [0.0,0.2..]
05:25:00 <lambdabot>   [1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,...
05:25:12 <Axman6> bugger, that's exactly the signal i was after
05:25:57 <stanv> i want class for pair types
05:26:34 <ski> FunctorSalad_ : so, can you think of a nontrivial definition of `liftBind' for `BinderT' ?
05:27:16 <Axman6> class Pairs p where foo :: P a b -> a; bar :: P a b -> b; baz :: P a b -> (a,b)
05:27:27 <Axman6> uh, s/P/p
05:27:51 <stanv> tuples
05:28:57 <FunctorSalad_> ski: no :) only if I changed the "Lift a" constructor to "Lift (m a)"
05:29:24 <stanv> is it possible require 'a' to be tuple ?
05:31:06 <FunctorSalad_> ski: to make matters worse, my tangle of mutually recursive functions for (Monad (BinderT deco m)) doesn't even terminate ;))
05:33:01 <FunctorSalad_> *looks through it again*
05:33:15 <ksf> iff there is a way of combining adaptive and elerea, it's a truly unholy union.
05:34:22 <ksf> it's all the same with those continuation-passing monads (especially including iteratees): you don't get values out.
05:34:36 <ksf> cps infects all of the program.
05:35:43 <ski> FunctorSalad_ : howdo you define `Bound n >>= k' ?
05:37:00 <FunctorSalad_> ski: doesn't touch bound vars
05:37:10 <ski> .. oh, right
05:39:04 <ski> (`instance Monad m => Monad (BinderT deco m) where return = Lift; Lift a >>= k = k a; Bound n >>= _ = Bound n; Binder d m >>= k = Binder d (liftM (k =<<) m)', no ?)
05:41:02 * ski doesn't see where the mutual recursion would enter
05:42:03 <dancor> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style doesn't seem to do a good job of making me want to ever use continuations.. :/
05:42:22 <mux> continuations are one of the very very few things I've never tried in haskell :-P
05:42:26 <FunctorSalad_> ski: in that paste I have (BinderT' deco m a) and (BinderT deco m a), which is a newtype for "m (BinderT' deco m a)"
05:42:38 <dancor> i guess it's a what not why article
05:42:46 <FunctorSalad_> ski: I think I do need to have 'm' on the outside
05:43:15 <FunctorSalad_> (what else should one lambda applied to another lambda give?)
05:46:11 <ski> FunctorSalad_ : "on the outside" ?
05:47:23 <FunctorSalad_> ski: I mean (BinderT deco m a) must be of the form ( m( something ) )
05:47:26 <ski> dancor : yes, the examples there doesn't sound that interesting
05:47:36 <ski> FunctorSalad_ : and it is
05:47:52 <FunctorSalad_> ski: yes, but only through two mutually recursive types :)
05:48:18 <ski> oh, that's the mutual recursion you meant
05:48:21 <FunctorSalad_> as I see it your instance didn't take that into account
05:48:47 * ski thought FunctorSalad_ was talking about mutual recursion of functions
05:49:11 <ski> i doesn't i forgot about the newtype :)
05:49:14 <FunctorSalad_> ski: I was; I implemented the instances with mutual recursion too
05:49:52 <FunctorSalad_> (but wrongly :))
05:50:38 <ski>   instance Monad m => Monad (BinderT deco m)
05:50:39 <ski>     where
05:50:47 <ski>     return = W . return
05:50:52 <ski>     ma >>= amb = W (unW ma >>= unW . amb)
05:51:05 <ski>   instance Monad m => Monad (BinderT' deco m)
05:51:07 <ski>     where
05:51:14 <ski>     return = Lift
05:51:22 <ski>     Lift a >>= k = k a
05:51:29 <ski>     Bound n >>= _ = Bound n
05:51:46 <FunctorSalad_> (here's the complete mess I have right now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10944#a10944 )
05:53:02 <ski>     Binder d m >>= k = Binder d (W (liftM (k =<<) (unW m)))  -- i think
05:54:03 <ski> hm .. you have  point  and  shift' 1  doing something
05:55:11 <FunctorSalad_> the shift' doesn't affect the types, it's just to avoid capture
05:55:34 <FunctorSalad_> (and it doesn't call the other stuff so it's not responsible for the nontermination)
05:56:18 <FunctorSalad_> 'point' is like 'return', I thought I could get away with the base monad being pointed and traversable, not a monad ;)
05:56:22 <FunctorSalad_> but that isn't so important
05:56:49 <ski> oh .. right
05:57:26 <ski> `dist' ?
05:59:42 * FunctorSalad_ tries to parse how you did it without dist
06:00:15 * ski notes he forgot about double layers in  m (BinderT' deco m a)
06:00:29 <FunctorSalad_> dist turns (terms of the base language, containing terms with binders as variables) to (terms with binders)
06:00:29 <ski> FunctorSalad_ : don't bother yet, it's not type correct :)
06:01:14 <FunctorSalad_> (in the lambda calc example, it is for turning "App t1 t2" into a type of value BinderT () FreeMagma a)
06:03:15 <ski> (i should have said `return = W . return . return' .. i.e. your `point' in the middle .. pondering the `Binder' case atm)
06:03:20 <FunctorSalad_> hmm I think me using sequenceA in dist is nonsense
06:03:46 <FunctorSalad_> (you don't want the application to distribute into binders somehow)
06:06:10 <ski> so we're looking for
06:06:18 <ski>   BinderT' deco m a -> (a -> m (BinderT' deco m b)) -> m (BinderT' deco m b)
06:06:19 <ski> i think
06:06:35 <FunctorSalad_> if you know a better way to define the datatypes that's fine too btw ;)
06:06:53 <FunctorSalad_> (the types will be opaque to the user)
06:07:37 <ski> i'm just trying to see a sensible way to define it at all, atm
06:08:38 <ski> hm
06:08:42 <ski>   a -> m (BinderT' deco m b)
06:08:46 <ski> can be converted into
06:08:55 <ski>   a -> BinderT' deco m (m (BinderT' deco m b))
06:09:11 <ski> so using
06:09:14 <ski>   BinderT' deco m a
06:09:15 <ski> we get
06:09:22 <ski>   BinderT' deco m (m (BinderT' deco m b))
06:09:31 <ski> if we had
06:09:42 <ski>   m (BinderT' deco m b) -> BinderT' deco m (m b)
06:09:45 <ski> we could get
06:09:54 <ski>   BinderT' deco m (BinderT' deco m (m b))
06:09:55 <ski> and then
06:10:00 <ski>   BinderT' deco m (m b)
06:10:10 <ski> but i don't know if this sensible (or possible)
06:10:23 <FunctorSalad_> I think this type is impossible: (m (BinderT' deco m b) -> BinderT' deco m (m b))
06:10:44 <ski> hm .. yes you are right, since `m' is a skolem
06:10:47 <FunctorSalad_> the left type can have an application (in the LC example) on the outside
06:11:29 <FunctorSalad_> (the right type can only contain applications under binders)
06:12:31 <FunctorSalad_> even a (Monad m, Traversable m) constraint would be fine I think
06:13:20 <FunctorSalad_> and BinderT' needn't be a Monad actually
06:13:31 <FunctorSalad_> (only BinderT)
06:14:52 <ski> it might be nice with some example evaluation .. hm
06:15:43 <FunctorSalad_> yes
06:16:57 <FunctorSalad_> I think the FreeMagma / LC example illustrates the general situation well enough
06:18:04 <FunctorSalad_> so the types would unfold to "BinderT is an application term of BinderT's, BinderT' is either a free variable, a bound variable, or a BinderT"
06:18:22 <FunctorSalad_> which seems like LC to me :)
06:18:50 <FunctorSalad_> (the free variables are the values of type 'a')
06:21:50 <ski> (yes)
06:23:24 <FunctorSalad_> think I just need to rewrite 'dist'
06:24:15 <Cale> The tagsoup library ought to have a convenient infix operator like  ts /> f = ts >>= partitions f  -- I've found that to be quite a useful one.
06:25:45 <skorpan> was (!=) not a popular inequality operator when haskell was designed?
06:26:07 <Cale> skorpan: I think /= is a nicer name anyway.
06:26:08 <ivanm> skorpan: /= looks more mathematical
06:26:14 <ivanm> Cale: "name"?
06:26:24 <Cale> For that function
06:26:34 <skorpan> but /= looks like someone who's insecure... "=/"
06:26:35 <ivanm> you mean symbol?
06:26:39 <ivanm> skorpan: bah
06:26:47 <ski>   (\f. f x) g
06:26:49 <ski> becomes
06:26:50 <skorpan> =/= would be nice though
06:26:51 <ski>   W (Var (Binder () W (Var (Bound 0) `App` (Var (Lift "x")))) `App` (Var (Lift "g")))
06:27:06 <ivanm> skorpan: bit too long... ;-)
06:27:11 <Cale> return tags /> isTagOpenName "script" /> (TagText "Capture(share.field_28_UI_share)" ~==) /> isTagOpenName "b" /> isTagText
06:27:49 <FunctorSalad_> ski: that looks correct
06:27:56 <Cale> ^^ the head of the head of the resulting list is my Internet address, as scraped from the crappy HTML off my cheap router. ;)
06:28:04 <ski> so, one could bind that to
06:29:14 <FunctorSalad_> I think we're missing some sort of flattening function after applying the bind to the Lift's
06:29:15 <ski>   \`x' -> `g x'; `g' -> `h x'
06:29:41 * ski is trying to determine what we want bind to do, on some simple example
06:29:56 <ski> well, i suppose one should include a binder in the substitution
06:30:06 <FunctorSalad_> yes
06:30:18 <FunctorSalad_> ((>>=) will only substitute free vars)
06:30:48 <FunctorSalad_> or you mean include it in the example ;)
06:30:57 <ski> yes
06:31:11 <ski>   \`x' -> `g x'; `g' -> `\y. h y y'
06:31:14 <ski> e.g.
06:31:19 <ski> so we want to express
06:31:32 <ski>   `(\f. f x) g' >>= \`x' -> `g x'; `g' -> `\y. h y y'
06:31:34 <FunctorSalad_> uhoh this will get unwieldy already
06:31:42 <Cale> It's kind of nice though in that it says "look for a script tag, which has the text "Capture(share.field_28_UI_share)" occurring before the next script tag, followed by a B tag, followed by some text
06:31:42 <ski> the result should be
06:31:57 <ski>   (\f. f (g x)) (\y. h y y)
06:32:22 <ski> FunctorSalad_ : unfortunately, yes
06:32:23 <Cale> (each layer partitions the document into smaller and more manageable pieces)
06:32:24 <FunctorSalad_> yes
06:32:57 <ski> maybe a substitution of a single variable would suffice ?
06:33:11 <FunctorSalad_> ski: apparently you need to push the f in (>>= f) down to the Lift's first, then flatten the result
06:34:12 <FunctorSalad_> W x >>= f = W (flatten (fmap (fmap f) x))
06:34:27 <ski> s/flatten/join/ ?
06:35:08 <FunctorSalad_> implicit param abuse tells me that flatten must be of type: (?flatten::m (BinderT' deco m (BinderT deco m b))
06:35:08 <FunctorSalad_>                                 -> m (BinderT' deco m b))
06:35:10 <FunctorSalad_> ;)
06:35:26 <ziman> > Data.IntMap.findMin $ Data.IntMap.fromList [(1,3)]
06:35:26 <lambdabot>   Not in scope: `Data.IntMap.findMin'Not in scope: `Data.IntMap.fromList'
06:35:42 <saml> @type flatten
06:35:43 <lambdabot> forall a. Tree a -> [a]
06:35:52 <saml> > flatten (Leaf 1)
06:35:53 <Saizan> FunctorSalad_: so join modulo newtypes?
06:35:54 <lambdabot>   Not in scope: data constructor `Leaf'
06:35:55 <ziman> ^^ this returns 3, which in turn breaks IntMultiSet's findMin :(
06:36:03 <ski> well,  m (BinderT' deco m (BinderT deco m b)  is more or less  BinderT deco m (BinderT deco m b)
06:36:23 <ski> FunctorSalad_ : so we've reduced `(>>=)' to `join' :)
06:36:41 <FunctorSalad_> Saizan: not quite :( modulo newtypes it is "m (BinderT (m BinderT b))) -> m (BinderT b)"
06:36:47 <ski>   ma >>= amb = join (fmap amb ma)  -- basically :)
06:36:53 <FunctorSalad_> (leaving out the decos now)
06:37:18 <FunctorSalad_> in that sense it's a join, yes
06:37:29 <Cale> @tell ndm I've found the following simple infix function really useful with TagSoup:  ss /> f = ss >>= partitions f
06:37:29 <lambdabot> Consider it noted.
06:37:30 <FunctorSalad_> but this is the monad instance for BinderT ;)
06:37:35 <Cale> @flush
06:37:50 <ski> FunctorSalad_ : aren't you confusing  BinderT  and  BinderT'  there ?
06:37:59 <FunctorSalad_> so I think we really want "m (BinderT' (m BinderT' a))) -> BinderT' a"
06:38:02 <FunctorSalad_> ski: yes
06:38:21 <FunctorSalad_> and that last type is missing an 'm' in the result type
06:38:34 <ski> i'm not sure if that is possible
06:38:53 <ski> (without wrapping an extra `Binder' .. which we don't want)
06:39:34 <FunctorSalad_> (   m (B' (m (B' a)))) -> m (B' a) ) needs some sort of distribution
06:39:41 <FunctorSalad_> (or commutation)
06:39:55 <FunctorSalad_> if we can commute any two items then we can apply join ;)
06:40:08 <ski>   B' . m -> m . B'  -- could do it, no ?
06:40:23 <ski> hm
06:41:18 <Saizan> do you have join for B'?
06:41:34 <jkff> Hi again. Can ghc on an i386 machine compile to amd64 binaries? (I'd like to make a reasonably portable debian package from my program)
06:41:56 <Saizan> jkff: no
06:42:21 <Saizan> you might use a vm, maybe
06:42:41 <jkff> That's quite a pity :-| Even with -fvia-c?
06:43:13 <Saizan> yeah, the generated C is not portable
06:43:15 <FunctorSalad_> Saizan: uh, sort of. it is mutually recursive with the thing being defined
06:44:07 * FunctorSalad_ wonders how he managed to make untyped lambda calculus that complicated
07:03:36 <Cale> http://timfreeman.org/copyright_dip.png -- ahaha
07:04:28 <ksf> waaagh where's my ctm
07:10:43 <skorpan> Cale: what the heck
07:11:16 <Cale> skorpan: apparently the publisher was a bit confused about the whole copyright thing ;)
07:12:07 <ksf> well you _can_ still copyright stuff like the layout.
07:12:23 <ksf> at least I think so.
07:13:25 <Cale> Yeah, I think when you put multiple licenses like that, you grant people the option of using whichever one they want.
07:14:27 <poucet> re
07:14:30 <hackagebot> strptime 0.1.1 - Efficient parsing of LocalTime using a binding to C's strptime (EugeneKirpichov)
07:18:41 <ski> FunctorSalad_ : hm, i got something type-checking ..
07:18:53 <ski> .. trying to rewrite it a bit
07:19:04 <FunctorSalad_> ski: me too
07:19:51 <FunctorSalad_> (just implemented the 'flatten' function)
07:19:51 <FunctorSalad_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10946#a10946
07:20:58 <saml> that's the longest haskell code i have ever seen
07:22:07 <FunctorSalad_> there is longer
07:22:12 <zygoloid> Cale: it pretty clearly says: (1) you have all sorts of copying rights, and (2) you have no copying rights unless we say, in writing, that you do
07:23:39 <zygoloid> you could apply both simultaneously; the upshot would still seem to be that the (1) rights apply since they constitute prior written permission, as far as i can see (but i'm not a lawyer...)
07:24:53 <Vanadium> Is (2) not pretty much the default state anyway?
07:29:28 <jmcarthur> i don't think that counts as multiple licenses since it is not explicitly stated so, but i think zygoloid is right that (2) does not nullify (1)
07:31:30 <ski> FunctorSalad_ : <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10940#a10947> you probably want to do something with the deBruijn indices in the environment, at the recursive call of `loop'
07:32:06 <maltem> That's why it stated "*prior* written permission" :)
07:34:54 <FunctorSalad_> ski: yeah, though I should prevent terms with free bound variables from leaking out in the first place
07:39:08 <ski> (Cale : maybe the different licenses apply to different portions of the work ?)
07:43:27 <ski> FunctorSalad_ : may i assume that everytime you enter a `Binder', you want to bump every (free) deBruijn index in the environment up one step ?
07:46:34 <terra> I'm having a problem installing GHCi 6.10.4 on Snow Leopard. I'm using the .pkg installer from haskell.org, and when I get to the final page, the "Install" button is disabled.
07:48:40 <FunctorSalad_> ski: I think there should be an invariant that all user-supplied BinderT values don't have any free deBruijm-indices
07:48:51 <FunctorSalad_> Bruijn
07:49:22 <ski> in that case, what do you think of my annotation ?
07:51:58 <pao> @seen dons
07:51:59 <lambdabot> Unknown command, try @list
07:52:06 <pao> @list
07:52:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:52:49 <pao> dons: can I ask a couple of question?
07:53:58 <FunctorSalad_> ski: it's equivalent to what I ended up doing, except you wrote the bind directly and I did (flatten . (fmap (fmap f))) :)
07:56:53 <guerrilla> is there a way to have cabal output a build somewhere other than 'dist/build/blah/blah' ?
07:57:21 <ski> FunctorSalad_ : added code which i think possibly handles free vars correctly
07:57:37 <ski> <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10940#a10950>
07:58:38 <ski> (hm, your  shift'  seems related to my  bump  )
07:58:49 <dolio> You should use locally nameless representation.
07:59:09 <FunctorSalad_> ski: I'm confused what the proper semantics for env's containing free indices even is :)
07:59:15 <ski> dolio : i assume you mean using GADTs ?
07:59:30 <FunctorSalad_> (maybe I should put an assertion there)
07:59:39 <FunctorSalad_> dolio: isn't this locally nameless?
07:59:43 <ski> FunctorSalad_ : substitution under binders, obviously ;)
08:00:27 <FunctorSalad_> I tried putting the indices on the type level at first, but it got out of hand
08:00:38 <dolio> ski: I mean you have both named variables and indices, and when you want to go under a binder, you instantiate all corresponding indices to names, and then abstract over the name on your way out.
08:01:02 <dolio> And you only work with terms where there are no non-bound indices.
08:01:20 <FunctorSalad_> ski: anyway thanks for the helpful discussion on this problem :)
08:01:45 <FunctorSalad_> writing the "abstract" function next, yes
08:01:54 <FunctorSalad_> that will be the only way for the user to make binders
08:02:00 <ski> FunctorSalad_ : i'd be interested to know whether my code there works correctly on some examples you may have
08:02:30 <ski> dolio : would that be simpler ?
08:02:37 <ski> more robust ?
08:02:45 <ski> better in other way ?
08:03:04 <FunctorSalad_> ski: I don't have any test cases yet... should probably make something like your earlier example a test case
08:03:13 <dolio> It avoids arithmetic like bump, if you can be sure that you're only working with well-scoped terms.
08:03:16 <FunctorSalad_> dolio: isn't that exactly what we're doing?
08:03:32 <dolio> At least, the first case of bump.
08:03:42 <ski> dolio : but then you need `gensym', instead ..
08:03:47 <dolio> Is it? I didn't look very closely.
08:04:06 <FunctorSalad_> well the thing is a monad, with the argument type being the type of free variables
08:04:15 <FunctorSalad_> bound variables are deBruijn
08:04:16 <ski> how would you instantiate indices to names when you enter a binder, otherwise ?
08:04:17 <dolio> Ah.
08:04:39 <FunctorSalad_> the intention is to make it impossible for the user to create terms with free indices
08:05:09 <FunctorSalad_> ski: you could bump the free variable type from a to Maybe a :)
08:05:22 <FunctorSalad_> that's a nice gensym
08:05:34 <dolio> ski: Well, the Conor McBride solution is to structure names such that you can make unique names by only making local decisions.
08:05:51 <ski> FunctorSalad_ : that's the GADT approach, isn't it ?
08:06:09 <dolio> So you don't need a global gensym.
08:06:12 <ski> dolio : sounds interesting. any relevant paper off-hand ?
08:06:17 <FunctorSalad_> ski: you mean this one in bird-patterson with the nested types?
08:06:26 <dolio> Yeah, I Am Not a Number, I Am a Free Variable.
08:06:28 <FunctorSalad_> they use the (Maybe a) for bound variables too
08:06:42 * ski doesn't know where he's seen the GADT approack
08:06:48 <ski> s/ck/ch/
08:07:24 <ski> basically `Binder :: Expr (Maybe a) -> Expr a' and `Bound :: a -> Expr a'
08:07:31 <ski> starting with `Expr ()' on the top
08:07:35 <FunctorSalad_> the problem with using (Maybe a) for free variables is that you don't have a regular type anymore, so traversals and instances become tricky typewise
08:07:56 <dolio> His method may not be an option if you're parameterizing by the type of names, though.
08:08:15 <FunctorSalad_> ski: yes, like that
08:08:20 <dcoutts> guerrilla: yes, that's what the --builddir= flag does
08:08:47 <dcoutts> guerrilla: note that since the configuration is also stored in that dir, you need to give the flag to each command, configure, build, etc
08:08:53 <FunctorSalad_> but now any fold-type traversals will need tricky polymorphic functions
08:09:05 <ski> *nod*
08:09:20 <ski> (.. which might be fun to figure out, though)
08:12:43 <FunctorSalad_> I guess I should really start making some test-cases for the shifting stuff ;)
08:15:02 <thomastc> nominolo|uni: you there?
08:15:36 <stanv> how to suppress messages like:  Warning: No explicit method nor default method for `treeVal'' ? I will not call this methods.
08:16:05 <thomastc> nominolo|uni: JP Moresmau has made many improvements to EclipseFP, but they require his own modified Scion
08:16:29 <thomastc> nominolo|uni: and now he'd like to release this EclipseFP version, so it'd be good if that would be paired with a new Scion release
08:16:50 <FunctorSalad_> ski: now that I'm writing 'abstract' it seems the right way would be to have the env take an extra parameter telling it the current scope
08:17:23 <FunctorSalad_> (because if you're abstracting (Lift "x") under a binder, it becomes (Bound 1), not Bound 0)
08:20:16 <ski>   treeVal' = error "treeVal' : not implemented"  -- stanv ?
08:20:20 <FunctorSalad_> (but I'm just writing a special-purpose 'abstract' function now...)
08:21:00 <ski> `abstract' as in that paper ?
08:22:12 <absentia> I'm going to santa fe next week
08:22:19 <absentia> I miss it too.. the summers were hot.
08:22:29 <absentia> fvck, sorry.. lagg.. wrong channel
08:22:29 <PetRat> I solved my stack overflow problem--- has to do, I think, with the possibility that mapM cannot operate lazily on monads with state: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10952#a10952  --However I need to know a way to do the equivalent.
08:22:43 <FunctorSalad_> abstract like in (abstract 'x' (\f. f x)   =  (\x. (\f. f x)))
08:23:00 <hackagebot> bla 2009.10.20 - a stupid cron (JinjingWang)
08:23:20 <mauke> I don't know who that guy is, but he has the best package names
08:24:43 <FunctorSalad_> mauke: yes
08:24:43 <jmcarthur_work> PetRat, it can't be lazy for any monad
08:24:58 <jmcarthur_work> PetRat, would could try unsafeInterleaveIO for this use case, i think
08:25:02 <jmcarthur_work> *you could
08:26:02 <PetRat> jmcarthur_work: I'll look it up.
08:26:48 <sproingie> man i'm losing my motivation reading RWH.  i mean PGM?  Really?
08:28:23 <PetRat> jmcarthur_work: I don't follow how unsafeInterleaveIO would help me. I would think that's for the IO monad, while I'm dealing with the Rand monad.
08:28:32 * ski doubts `unsafePerformIO' would be appropriate ..
08:28:38 <sproingie> downloadable examples don't even provide a pgm.  which might be my only chance to ever see this goofy format
08:29:09 <ski> PetRat : maybe you want to use a splittable RNG, so you can avoid state ?
08:29:21 <ski> @type split
08:29:23 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
08:30:40 <FunctorSalad_> hmm if I substitute the zeroth deBruijn index then all others need to be debumped right?
08:30:54 <FunctorSalad_> or maybe not
08:31:04 <ski> FunctorSalad_ : i need to leave for now .. will maybe look more into this later
08:31:14 <FunctorSalad_> ski: ok :)
08:31:21 <PetRat> ski: I guess that would be one possibility. I was trying to get away from passing generators around---that was my motivation to use Rand. Another idea would be to put all the stages of my computation in a single Rand monad and call mapM only once. If the state is never "demanded out from" a mapM call, can it then operate lazily?
08:31:40 <PetRat> .. single Rand _computation_ ..
08:32:21 <ski> PetRat : well, possibly you can make something like `Rand', but using `split' .. iiuc
08:32:30 <ski> anyway, gtg
08:35:31 <PetRat> Regarding this question of lazy operation of mapM, I would have thought that something like   let nums = evalRand (mapM g chars) gen   would operate lazily because it never needs to reach the "far side" of the mapM computation.
08:36:46 <Arnar> hmm.. can I get a live ghci session to see modules just installed with cabal since starting it?
08:37:44 <dcoutts> Arnar: :set -package blah
08:37:55 <dcoutts> and :reload
08:38:35 <Arnar> dcoutts: blah in what form?
08:38:46 <Arnar> edit-distance and edit-distance-0.1.2 both give "unknown package2
08:40:31 <dcoutts> Arnar: same as on the command line, eg :set -package binary-0.5.0.2
08:41:02 <dcoutts> Arnar: hmm, perhaps you can't since ghci doesn't re-read the set of registered packages
08:41:02 <xenoblitz> dcoutts: is there a way to make a drawingarea to periodically redraw itself apart from using timeoutAdd (widgetQueueDraw canvas >> return True) 50, for example?
08:41:32 <Arnar> dcoutts: seems so
08:42:20 <dcoutts> xenoblitz: it redraws after it is invalidated which you can do directly and it also happens when window system moves another window in front etc
08:42:37 <xenoblitz> how do i invalidate it directly?
08:42:55 <Arnar> dcoutts: yup.. :set -package doesn't work with new packages
08:43:09 <dcoutts> xenoblitz: by calling a function to do so, see the docs
08:43:45 <xenoblitz> dcoutts: thanks
08:46:30 <Arnar> blargh..
08:46:41 <Arnar> ~/.ghc/ghci_history only works for the first ghci instance
08:47:15 <dcoutts> Arnar: file a ticket
08:47:27 <Arnar> dcoutts: on it
08:47:33 <dcoutts> describe what it does, what you expect, what bash/readline does differently
08:55:56 <Arnar> dcoutts: #3601 filed
08:56:02 <dcoutts> great
09:21:15 <bn-> hello. I wanted to ask. maybe someone succeded in using haskell on Snow Leopard?
09:21:59 <medfly> maybe you can try to use pkgsrc to install it, if it doesn't work
09:22:07 <medfly> in some other method you've used
09:22:42 <bn-> pkgsrc?
09:23:38 <medfly> although I'm not sure...
09:24:02 <medfly> it's like the netbsd package system, I hear it works on other operation systems, or something. you basically compile the stuff.
09:25:28 <acidjnk> Why is determining whether a mathematical statement is true or false considered unsolvable for computers?
09:25:50 <acidjnk> For example (7 < 3) && (1 == 1) can be solved by a computer, it will find that it is false.
09:28:03 <pumpkin> not specific statements
09:28:31 <acidjnk> So it gets much harder for a computer when quantifiers are involved, like exists and forall?
09:28:47 <pumpkin> you may be talking about the SAT problem
09:28:54 <pumpkin> whether a logical statement can ever be true
09:28:58 <pumpkin> and that's just NP-complete
09:29:19 <aavogt> is it good practice to use record notation to document parameters in a multiple-constructor ADT?
09:29:23 <pumpkin> meaning we don't know of a subexponential way of figuring it out (but it's solvable with enough time). It also means we can verify the answer in polynomial time
09:29:26 <MyCatVerbs> acidjnk: It gets impossible quite quickly for a computer when the statements involve some recursion.
09:30:09 <aavogt> it seems that I would be exporting partial functions however
09:30:21 <acidjnk> That's an entirely different question to me, pumpkin.
09:30:45 <MyCatVerbs> acidjnk: For example, you cannot write a computer program that takes another computer program as input, and tells you whether or not that computer program will ever halt.
09:30:57 <seydar> hey guys
09:31:04 <seydar> what's an example of a waterborne pollutant
09:31:04 <pumpkin> zomg it's seydar
09:31:06 <aavogt> acidjnk: people can't solve all mathematical statements either
09:31:23 <aavogt> seydar: dihydrogen monoxide
09:31:28 <seydar> hey pumpkin
09:31:35 <MyCatVerbs> seydar: poo.
09:31:39 <acidjnk> So some statements can be resolved to true or false by computers, some by humans, and some by neither.
09:31:41 <seydar> aavogt: ooh, i hear that if you inhale too much you drown
09:31:58 <acidjnk> thanks
09:32:01 <seydar> no really guys i need this question answered so i can become an eagle scout so i can go to college
09:32:45 <aavogt> fowl water
09:32:49 --- mode: ChanServ set +o monochrom
09:33:03 --- mode: monochrom set -o monochrom
09:33:10 <MyCatVerbs> "Requested" by monochrom?
09:37:27 <aavogt> is there some way for haddock documentation to refer to the individual arguments to a constructor, without having to export the field access labels?
09:44:26 <Berengal> Am I crazy in thinking that concurrent arrows might be a good idea?
09:45:19 * Twey scratches his head.
09:45:26 <Twey> Aren't arrows kind of sequential?
09:45:28 <seydar> oh hot damn
09:45:39 <seydar> i understand arrows for like a day a few weeks ago
09:45:48 <seydar> s/understand/understood
09:45:51 <seydar> but i forgot it
09:46:04 <Berengal> Twey, yes, but list arrows, for example, are sequential in a very different way
09:46:45 <Twey> seydar: It's simple!  Arrows are like conveyor belts with robots in between packing boxes full of radioactive waste whilst wearing space-suitsâ€¦
09:46:58 <seydar> oh dude
09:47:01 <Twey> Berengal: I guess so
09:47:01 <seydar> that makes sense
09:47:17 <seydar> can i see an example?
09:47:20 <Twey> Or was that monads?  :Ã¾
09:47:22 <Berengal> Twey, the other day I wrote a screen-scraper in hxt, looking for images in several webpages, downloading them and collating the result in a common html, and the program execution read very differently from the program code
09:47:48 <Twey> Berengal: *nod*
09:47:55 <Twey> Parallel arrows, then
09:48:04 <Berengal> Yes, but not in a data-parallelism sense
09:48:32 <Berengal> I'm thinking arrows of type a -> IO [b], with explicit splitting and joining
09:52:28 <hackagebot> strptime 0.1.2 - Efficient parsing of LocalTime using a binding to C's strptime (EugeneKirpichov)
09:53:00 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10954#a10954
10:00:30 <hackagebot> jarfind 0.1.0.1 - Tool for searching java classes, members and fields in classfiles and JAR archives (EugeneKirpichov)
10:01:11 <Berengal> neat
10:13:33 <hackagebot> digest 0.0.0.8 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now. (EugeneKirpichov)
10:25:45 <jfredett> Twey: robots packing boxes of radioactive waste while wearing space-suits would be more like Kliesli arrows, methinks. :)
10:30:37 <sproingie> why would the robots need space suits?
10:30:52 <sproingie> maybe they're packing boxes of radioactive space suits?
10:33:39 <hackagebot> geohash 1.0 - Geohash latitudes and longitudes. (MariusEriksen)
10:33:40 <maltem> can radioactivity influence the functioning of electronic circuits?
10:34:18 <sproingie> hell yeah
10:35:10 <sproingie> but you'd just shield the electronics directly.  maybe they're more like androids than robots then...
10:35:32 <sproingie> silly analogy is silly
10:35:43 * maltem missed the analogy ;)
10:35:55 <maltem> ah, Kleisli arrows
10:35:58 <skorpan> what's an ogy?
10:36:04 <maltem> sssh
10:37:02 <morganson> =)
10:43:18 <maltem> I've been recently put off by this chair shortening Numerical Analysis to numanal
10:45:23 <shambler> :)
10:59:31 <rlisam> hi! Could someone help me to understand the following syntax from the quicksort solution: sort [y | y <- xs, y < x]
10:59:34 <jkff1> Oh, what a relief is it to write Haskell after writing Java. I thought that I am cool enough at Java to have a lot of pleasure writing in it, but then I wrote in Haskell for several days and things have changed. Help, I don't wanna go back!
10:59:48 <Elly> owned :P
10:59:57 <jkff1> > [y | y <- [1..5], y < 4]
10:59:58 <lambdabot>   [1,2,3]
11:00:08 <jkff1> > [y | y <- [4,2,1,5,3], y < 4]
11:00:09 <lambdabot>   [2,1,3]
11:00:09 <Igloo> rlisam: "The list of elements y, where y comes from xs, and y < x"
11:00:56 <jkff1> rlisam: Why didn't you try it out yourself in ghci? :)
11:02:55 <rlisam> thank you ... but I'm still a bit confused on the "|" and the "<-" which I've only seen in guard expressions and do statements
11:03:21 <mauke> > do { y <- [4,2,1,5,3]; guard (y < 4); return y }
11:03:22 <lambdabot>   [2,1,3]
11:03:27 <sproingie> > [ (x,y) | x <- [1..5], y <- [1..5] ]
11:03:27 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
11:03:31 <skorpan> [ y from y in range(1,6) if y < 4 ] <- python, more readable
11:03:36 <mauke> s/more/less/
11:03:54 <skorpan> except that it's more readable
11:03:54 <sproingie> you mean y for y in range(1,6)
11:04:03 <skorpan> sproingie: of course :)
11:04:09 <sproingie> and i don't consider python's goofy half-open ranges to be more readable
11:04:27 <mauke> "[ y for y" <- wtf, confusion right there
11:04:38 <skorpan> mauke: how is that confusing?
11:04:47 <mauke> it makes no sense
11:04:53 <sproingie> you can have any computation on y
11:04:59 <sproingie> or heck none at all
11:05:10 <skorpan> mauke: does "[ y * 2 for y" make more sense to you?
11:05:11 <sproingie> [ 1 for _ in range(1,6) ]
11:05:15 <Resurge> Hey, i'm new to haskell and i seem to have a problem with defining functions. I typed this in ghci: "simple x y z = x * (y + z)".  The error it returns is: "<interactive>:1:0 Not in scope: `simple´"
11:05:21 <mauke> skorpan: that's not the issue
11:05:29 <sproingie> (which is a dumb way to say [1] * 5)
11:05:42 <Resurge> ups i mean
11:05:50 <mauke> skorpan: the problem is that "y for y" is not a syntactic entity at all and shouldn't be parsed like that
11:05:51 <skorpan> sproingie: not really [1] * 5
11:06:01 <Resurge> <interactive>:1:13: parse error on input '='
11:06:19 <mauke> Resurge: yes, you can't just type haskell code into ghci
11:06:23 <sproingie> skorpan: true, for reference types it's different
11:06:26 <skorpan> mauke: it's not a "syntactic entity"?
11:06:41 <yairchu> naming question: what module/package name would be good for ADT getters generated using TH (see http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10956#a10956 )
11:06:55 <mauke> skorpan: it's { { y } for {y in ...} }
11:07:11 <Resurge> mauke: so ghci can only be used for single expressions?
11:07:14 <jkff1> Resurge: When you're defining functions or values in ghci, you must prefix them with "let", like: > let f x y = x + y
11:07:26 <Resurge> aha, thanks
11:07:28 <mauke> Resurge: workaround: 1) type code into file, load file into ghci;  2) if it's just a single definition, use "let"
11:07:44 <skorpan> mauke: okay whatever, i am now convinced that the haskell version is way more readable
11:07:58 <mauke> hah
11:08:30 <mauke> I probably can't explain this in a way that makes sense, but the python version throws my internal parser off
11:08:32 <sproingie> i like python's flatten.  [y for x in foo for y in x]
11:08:45 <skorpan> sproingie: what the?
11:08:47 <mauke> [ y | x <- foo, y <- x ]
11:09:05 <sproingie> eh.  i'd read it out loud the same way
11:09:14 <skorpan> that doesn't make much more sense in haskell to be honest
11:09:29 <mauke> makes perfect sense to me :-)
11:09:32 <skorpan> i mean i'm sure it makes sense, it's just "my internal parser"
11:09:48 <mauke> wait, how is this a syntactic issue?
11:09:53 <sproingie> [ y | x <- [[1..5], [6..10]], y <- x ]
11:10:13 <sproingie> > [ y | x <- [[1..5], [6..10]], y <- x ]
11:10:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:10:20 <skorpan> mauke: i don't know how to make an AST out of the string, that's parsing
11:10:45 <sproingie> 'course there's much nicer ways to express that in haskell
11:10:45 <mauke> uh, ok. in that case you might want to learn about list comprehensions, I guess
11:10:54 <burp> > concat [[1..5], [6..10]]
11:10:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:11:11 <skorpan> mauke: what would you call it if i don't immediately see how that thing works?
11:12:16 <mauke> I don't know, something like "you don't understand how this works"
11:12:36 <skorpan> right
11:12:48 <jmcarthur_work> @undo do x <- foo; y <- x; return y
11:12:48 <lambdabot> foo >>= \ x -> x >>= \ y -> return y
11:13:00 <jmcarthur_work> @pl foo >>= \ x -> x >>= \ y -> return y
11:13:00 <lambdabot> join foo
11:13:05 <jmcarthur_work> :)
11:13:31 <jmcarthur_work> (of course, join = concat)
11:13:35 <zygoloid> mauke: i don't follow your objection to python. you don't like "y for y" but you're ok with "y | y" ?
11:13:46 <zygoloid> *python's list comprehension syntax
11:14:01 <mauke> zygoloid: something about python's surface syntax just doesn't look right to me
11:14:01 <skorpan> zygoloid: obviously "y for y" is not a "syntactic entity" and makes no sense!
11:14:18 <zygoloid> skorpan: right, and the same is true of "y | y"; that was my point
11:14:28 <mauke> I keep parsing it as "y for y" when it doesn't belong together
11:14:33 <skorpan> zygoloid: i was being ironic :)
11:14:33 <sproingie> python's list comprehension syntax is virtually identical, it just uses different keywords
11:14:41 <mauke> | is different because it doesn't look like a word
11:14:52 <burp> python adopted it from haskell
11:15:02 <mauke> sproingie: s/different //
11:15:09 <int-e> Obviously, y | y is bit-wise disjunction and makes no sense as a list comprehension. ;-)
11:15:36 <mauke> int-e: hah, I'm too familiar with OCaml to make that mistake
11:16:01 <zygoloid> mauke: that's simply a matter of familiarity i think. do your brain's parse rules come from perl's "foo if bar" expressions, do you think?
11:16:01 <mauke> (but !x was annoying at the beginning)
11:16:03 <jmcarthur_work> i can't parse that python version at all
11:16:12 <mauke> zygoloid: could be
11:16:17 <jmcarthur_work> perhaps with practice, but i found haskell's syntax to make sense the very first time i saw it
11:16:34 <sproingie> read enough python and it parses fine.  keywords start to jump out at you
11:16:37 <mauke> or even perl's "foo for bar"
11:16:48 <Twey> ($) threw me a bit to start with
11:16:49 <zygoloid> i found python's syntax to make sense the first time i saw it, but i thought the multiple for clauses worked the opposite way around to how they actually work :)
11:16:55 <jmcarthur_work> certainly syntax highlighting helps, too
11:16:58 <sproingie> python's got "a if b else c" now, which was so awful even *perl* didn't have it
11:16:58 <Twey> I got used to it, though
11:17:10 <int-e> and if keywords don't jump out at you, there is syntax highlighting to help.
11:17:24 <skorpan> sproingie: that's just because they didn't want the ?: syntax
11:17:32 <jmcarthur_work> i don't like haskell's if a then b else c syntax
11:17:37 <jmcarthur_work> i wish if was just a function
11:17:39 <mauke> all I'm saying is that python isn't inherently more readable (or readable at all)
11:17:41 <sproingie> skorpan: i can sympathize with that, but the ?: syntax is in that order for a reason
11:17:41 <skorpan> all programming languages should just make their if statements into if expressions
11:17:59 <int-e> sproingie: heh. that would almost make sense if the conditional were in the middle :)
11:18:07 <mauke> skorpan: hah, pascal would eat your face for that
11:18:18 <int-e> and it is.
11:18:19 <sproingie> int-e: it is in the middle in python
11:18:23 <lament> sproingie: a if b else c is delightfully Forth-ish
11:18:43 <skorpan> we should just all be glad python isn't ruby
11:18:52 <zygoloid> mauke: i find the mean readability of haskell and python are pretty similar, but the standard deviation in haskell is higher :)
11:18:59 <sproingie> ?: has the property that you can chain it and if you line them up on multiple lines it makes a nice table
11:18:59 <lambdabot> Maybe you meant: . ? @ v
11:19:15 <skorpan> sproingie: a table that is hard to understand :)
11:19:19 <trofi> :t S.fromList
11:19:20 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
11:19:29 <trofi> > S.fromList [1,2,3]
11:19:30 <lambdabot>   fromList [1,2,3]
11:19:31 <sproingie> actually a lot easier to understand than alternative syntaxes
11:19:32 <mauke> zygoloid: I like haskell but I just can't stand python :-)
11:19:45 <sproingie> of course haskell has nicer syntax yet for that sort of thing
11:19:45 <zygoloid> sproingie: foo1 if bar1 else \n foo2 if bar2 else \n foo3 if bar3 else \n default ?
11:19:48 <Twey> skorpan: s/\bif //g
11:19:49 <trofi> > S.find 2 (S.fromList [1,2,3])
11:19:50 <lambdabot>   Not in scope: `S.find'
11:20:01 <skorpan> Twey: haha
11:20:03 <trofi> does set support such operation?
11:20:11 <jmcarthur_work> zygoloid, in my experience that is mostly because haskell syntax is more dense and thus expressed more ideas in one place, making it often harder to understand per volume of code
11:20:35 <mauke> trofi: what would it do?
11:20:47 <jmcarthur_work> of course that sounds like something to wave in front of python, but i don't really mind a little verbosity
11:20:47 <trofi> True if yet, false if absent
11:20:51 <tectum> hi
11:20:53 <mauke> that's elem, not find
11:20:56 <mauke> :t S.member
11:20:57 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
11:21:06 <jmcarthur_work> as long as that verbosity isn't like boilerplate
11:21:09 <trofi> oh, thanks. overlooked that
11:21:13 <jmcarthur_work> (which i do happen to feel that a lot of it is)
11:21:16 <int-e> @topic-init
11:21:16 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
11:21:22 <sproingie> forth love if honk then
11:21:22 <zygoloid> jmcarthur_work: i can't say i find readability a reason to choose between python and haskell; they're both good enough for my purposes
11:21:42 <tectum> What's the best way to get ghc running on a SuSE Itanium box?
11:22:17 <jmcarthur_work> zygoloid, i have come to see "readability" as a vague concept and perhaps without the benefits that a lot of people claim.
11:22:40 <Twey> It's certainly very malleable.
11:22:43 <tectum> (I'm saying SuSE because that excludes just installing the Debian package)
11:22:44 <sproingie> somehting not readable has little benefit except as dadaist art
11:22:56 <mauke> .oO( piet )
11:23:00 <Twey> mauke: :-D
11:23:02 <int-e> (regarding the topic, http://tunes.org/~nef/logs/haskell/?C=M;O=D would be slightly more useful as a link to the channel logs, because the recent logs would be sorted first)
11:23:05 <sproingie> it may be subjective, it's certainly not without value
11:23:14 <int-e> piet is pretty.
11:23:19 <jmcarthur_work> sproingie, highly abstract code doesn't make any more sense in a more "readable" syntax
11:23:52 <sproingie> in fact it does, given that that's kind of the definition of readability
11:24:08 <pao> hi all ... I'm giving a look to dons' judy bindings... he suggests using a stablepointer to pass a "ref" to the array ... but how do I convert a StablePointer to a Word?
11:24:14 <jmcarthur_work> sproingie, it was in quotes because nobody agrees on the definition
11:24:21 <zygoloid> there are certainly times when i find haskell a lot more expressive than python, and conversely for code which is 'naturally' formulated in imperative OO style i find python more expressive
11:24:28 <sproingie> i guarantee most people here can make more sense of code in haskell than in J
11:24:52 <jmcarthur_work> sproingie, many people claim things like "readability means all code has apparently concrete meaning," which is directly counter to writing abstract code
11:25:51 <sinelaw> funky, i was just reading about J
11:25:57 <sproingie> readability's the subjective value of being able to get meaning out of it.  obviously if the underlying concepts are foreign, the representation won't make much difference
11:26:05 <pao> dons: can I ping you? :-)
11:26:06 <jmcarthur_work> sproingie, exactly.
11:26:33 <sproingie> i love some of the rosetta examples for J
11:26:43 <sproingie> map a function over an array:   "_1
11:27:05 <jmcarthur_work> sproingie, so when your inputs and outputs are, say, parametrically polymorphic, you can't really use syntax to make a function much more readable
11:27:38 <lament> sproingie: eh, and the haskell equivalent of that is "map"?
11:28:01 <monochrom> readability depends on reader's educational level. English is unreadable to infants.
11:28:06 <jmcarthur_work> J is pretty scary, but J programmers never seem to have trouble reading others' J code
11:28:11 <Twey> skorpan: Haha, argh
11:28:19 <Twey> APL is pretty cool in a scary way.
11:28:28 <Twey> Speaking of extreme unreadability.
11:31:05 <monochrom> I briefly looked at APL or J once. Very brief, so the following may be wrong. There was something inconsistent or non-uniform or non-orthogonal about it.
11:31:34 <lament> there's something non-orthogonal about pretty much everything
11:31:59 <monochrom> I have also forgotten what my problem was. But I can try to tell you similar but worse problems in other languages.
11:32:04 <lament> is non-orthogonal a synonym for TMTOWTDI?
11:33:04 <monochrom> Take 8086 assembly for example. It has 4 registers. You can only multiply with 2 of them. That's unsatisfactory. 68000 in the same era already allowed you to multiply with any pair of 8 data registers.
11:33:14 <sproingie> orthogonality usually creates multiple ways to do things
11:33:30 <mauke> and that's bad!
11:33:54 <mauke> that way *shudders* ... lies perl
11:34:08 <monochrom> Another example. Some languages allow you to pass functions as parameters, but not operators like +. It's annoying.
11:34:24 <sproingie> doesn't ghc still depend on perl some places?
11:34:40 <absentia> in pewl, there's usually more than one way to do it.. but, if you do it the wrong way, you get yelled at.
11:34:49 <sproingie> i see it still ships with it
11:35:38 <tectum> sproingie: the C backend depends on perl
11:36:29 <tectum> hi all... do I have to bootsrap from .hc files in order to get ghc running on Itanium/IA-64?
11:39:57 <tectum> what does this mean?: ghc-6.8.2: missing -B<dir> option
11:40:15 <mauke> you probably ran the wrong program
11:41:03 <tectum> mauke: sorry?
11:41:21 <mauke> why are you sorry?
11:41:41 <tectum> :)
11:41:55 <sw17ch> hello
11:41:57 <tectum> what do you mean by 'wrong program'? I run ghc?
11:42:19 <tectum> ok, I'm running it off a manually extracted debian package, so something is indeed wrong
11:42:24 <mauke> there are two of them
11:42:28 <tectum> ahh
11:42:40 <mauke> the usual ghc executable is a shell script that calls the actual program
11:42:47 <mauke> adding the right -B options
11:43:23 <Stalafin> !books
11:43:47 <tectum> mauke: thanks, that helped
11:43:48 <tectum> however...
11:43:50 <tectum> ghc-6.8.2: Can't find package.conf as usr/lib/ghc-6.8.2/driver/package.conf.inplace
11:43:50 <tectum>  
11:44:05 <tectum> what is this?
11:46:07 <tectum> what is the file package.conf for?
11:50:09 <esdee> is there a way to make cabal install stuff system wide instead of in my home dir, without doing the whole fetch/configure/build part as root also?
11:50:32 <dcoutts> esdee: yes, that's what the --global flag is for
11:50:49 <dcoutts> esdee: if that's what you want to do by default you can set it in the ~/.cabal/config file
11:51:07 <dcoutts> and there's a root-cmd which you can set to sudo so that you can build as user and install as root
11:52:47 <esdee> perfect, thanks
11:59:41 <shapr> Does Ubuntu Karmic have built-in support for Cabal?
12:01:02 <monochrom> not sure how built-in is built-in. I'll check if it has a cabal package.
12:02:47 <shapr> I can't find one with apt-cache search, just wondering if I'm missing something.
12:03:17 <smorg> yojo
12:03:29 <shapr> y0 smorg
12:03:30 <monochrom> The ghc6 package includes the cabal library, but not the cabal executable.
12:03:45 <shapr> oh well, I'll have to fix it myself...
12:04:02 <shapr> I wonder who runs the haskell section of ubuntu universe?
12:05:00 <monochrom> It is just taken from debian's haskell section with little change
12:06:30 <monochrom> There is no ubuntu package containing the cabal executable.
12:38:16 <ehamberg> i want to generate a list from another list (of lenght n)? i want to randomly pick n elements from the original list, with replacement. i haven't really used randomness in haskell much, so any pointes would be appreciated.
12:40:20 <Berengal> ehamberg, MonadRandom works wonders
12:41:06 <cads> hola
12:41:43 <Twey> coi
12:42:03 <Cale> dons: Loading package download-0.3 ... linking ... <interactive>: /home/cale/.cabal/lib/download-0.3/ghc-6.10.3/HSdownload-0.3.o: unknown symbol `stat64'
12:43:14 <rsnake> Hey guys... I have a problem here: http://paste.pocoo.org/show/146056/ , it says "parse error on input '='"... no idea what I'm doing wrong, can someone help me please?
12:43:23 <Cale> dons: Perhaps I'm missing something that I need, but the cabal didn't warn me of any problems...
12:43:25 <rsnake> (on the last where line)
12:43:37 <poucet> @usrs
12:43:38 <lambdabot> Maybe you meant: src url
12:43:41 <poucet> @users
12:43:42 <lambdabot> Unknown command, try @list
12:43:45 <Cale> er, -the ;)
12:44:11 <Cale> rsnake: there are tabs in your file
12:44:41 <Cale> rsnake: Tab characters are pure unadulterated evil. Configure your editor to replace them with spaces.
12:45:06 <rsnake> really? :/ I like tabs... are they really that bad?
12:45:10 <Cale> Yes.
12:45:13 <skorpan> yes
12:45:21 <Berengal> yes
12:45:26 <sinelaw> yes
12:45:34 <Vanadium> yes
12:45:44 <Cale> It becomes impossible to align things vertically properly.
12:45:46 <Cale> Well, to be fair, it's possible to use them, if you configure your editor to 8-space tabs.
12:46:02 <Cale> But other people will still shout at you for using them. ;)
12:46:06 <sinelaw> right
12:46:23 <Cale> I think they should simply be considered a lexical error.
12:46:30 <skorpan> indeed
12:46:34 <rsnake> I guess I could use spaces... so what is it I need to align vertically? the '=' sign?
12:46:45 <Stalafin> heya, i am looking for a book on haskell for people with a non-cs background (i took one year of general cs though where functional programming was covered up to the point where i wanted to shoot myself using sml....)
12:46:53 <lenny222> Hi, i struggle to build gtk2hs on a Mac:
12:46:55 <lenny222> ghc --make FFI.hs
12:46:56 <lenny222> [1 of 1] Compiling System.Glib.FFI  ( FFI.hs, FFI.o )
12:46:56 <lenny222> glib/System/Glib/FFI.hs.pp:58:8: parse error on input `import'
12:46:58 <skorpan> @lyah
12:46:58 <lambdabot> Unknown command, try @list
12:47:01 <Cale> rsnake: you need the  "sub" to line up vertically with "fv"
12:47:01 <skorpan> hm
12:47:09 <Berengal> rsnake, the first non-whitespace letters in a block need to be aligned
12:47:15 <lenny222> line 58 is:
12:47:15 <lenny222> foreign import ccall "dynamic"
12:47:21 <skorpan> Stalafin: i recommend the online "book" named "learn you a haskell"
12:47:24 <lenny222> i don't see what's wrong with that
12:47:25 <Cale> rsnake: That is, the definitions that are inside the 'where' have to line up vertically.
12:47:41 <rsnake> Ok... thanks guys
12:47:50 <sinelaw> Stalafin or Real World Haskell (also available online free)
12:48:07 <rsnake> I just really don't get haskell's indentation... beautiful as the language may be
12:48:12 <Stalafin> skorpan: ha, now thath looks like fun! :D
12:48:17 <skorpan> Stalafin: i know right?!
12:48:28 <sw17ch__> will Cabal let me set per-file GHC options?
12:48:29 <Lemmih> lenny222: There should be a makefile for you to run.
12:48:31 <Berengal> rsnake, you'll get used to it. It helps if you know python (but there are differences)
12:48:52 <Stalafin> sinelaw: can i use that as a reference as well? can you tell me smth about 'Haskell: The Craft of Functional Programming' by thompson?
12:48:57 <skorpan> i for one still don't understad how if/then/else should be indented when on multiple lines
12:49:09 <skorpan> Stalafin: most people i've talked to dislike that book
12:49:10 <Cale> Oh, that's easy:
12:49:13 <Cale> if foo
12:49:14 <rsnake> I use tabs in python! they work just fine
12:49:15 <Cale>    then bar
12:49:18 <Cale>    else quux
12:49:22 <Cale> Or:
12:49:25 <Cale> if foo then bar
12:49:31 <Stalafin> skorpan: thanks
12:49:32 <rsnake> (sorry cale)
12:49:35 <Cale>        else quux
12:49:39 <skorpan> Cale: what if i have "if foo then" on one line and then want to continue?
12:49:45 <Cale> skorpan: that's bad
12:49:46 <lenny222> Lemmih: there is a top level Makfile, when i use that it stops:
12:49:47 <lenny222> glib/System/Glib.hs:13:0:
12:49:48 <lenny222>     Failed to load interface for `System.Glib.UTFString':
12:49:48 <lenny222>       Use -v to see a list of the files searched for.
12:50:01 <skorpan> Cale: i guess that's why it's so weird to use that in haskell
12:50:02 <Cale> skorpan: continue on the same line, or move the then to the next line
12:50:16 <Cale> The important thing is that 'then' and 'else' should line up.
12:50:28 <Cale> and they should occur on a later column than 'if'
12:50:35 <Lemmih> lenny222: Did you run the configure script?
12:50:42 <lenny222> Lemmih: yes
12:50:45 <Berengal> 'if' isn't a block anyway. You can indent it however you like
12:50:57 <sinelaw> hi, where can i learn about equational reasoning?
12:50:58 <skorpan> Cale: i've seen cases where "if", "then" and "else" on the same column works just fine
12:51:03 <Twey> Stalafin: It's pretty poor
12:51:06 <lenny222> Lemmih: according to http://www.haskell.org/haskellwiki/Gtk2Hs#Using_the_GTK.2B_OS_X_Framework
12:51:10 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10966#a10966
12:51:13 <Cale> Right, you can, but good style dictates that you do at least as much as I'm specifying ;)
12:51:28 <Cale> skorpan: Yes, such cases exist, but not everywhere.
12:51:33 <Berengal> Cale, does emacs and yi agree with you?
12:51:36 <skorpan> right, which is confusing!
12:51:39 <Cale> skorpan: Inside a do-block, it's a problem.
12:51:54 <Cale> skorpan: Not *that* confusing.
12:52:10 <Cale> I don't think that lining up the 'then' with the 'if' should work at all, myself.
12:52:18 <sinelaw> Stalafin, i don't know about the thompson one. wht do you mean as a reference? for what purposes
12:52:24 <Cale> You should be forced to start it on a later column.
12:52:34 <skorpan> Cale: agreed
12:52:52 <Lemmih> lenny222: You're either missing a dependency or didn't download the sources correctly.
12:53:08 <lenny222> Lemmih: :( thanks
12:53:16 <Berengal> Cale, going by most other languages it seems to be 'if pred then\n  trueExpr\nelse\n  falseExpr'
12:53:16 <esdee> anyone know if there's a way to use the haskell fastcgi module for externalfcgi apps?  (like you start the fcgi app yourself on a whole other server and it talks to the webserver over tcp)
12:53:38 <Berengal> Of course, going by most other languages, 'ifthenelse' is a statement, not an expression...
12:53:52 <Cale> Since if/then/else doesn't really influence the layout algorithm at all, there are lots of wacky indentations which will work in some cases, but inside of other things which do involve layout, in order to continue an expression, it has to start on a strictly later column.
12:54:13 <Cale> Berengal: right, that layout is illogical and I've stopped using it in other languages too ;)
12:54:40 <Cale> Clearly the 'then' and 'else' are siblings, so it makes sense to line them up :)
12:54:49 <cads> Hey, has anyone here heard of bigraphs, and bigraphical reactive systems?
12:55:07 <Berengal> Well, in if-statements, the else is more like the if than the then
12:55:20 <cads> I feel as if conal would know all about it
12:55:38 <Cale> Oh? It also contains a block of code to execute, just like the 'then' does.
12:56:04 <Cale> bash is much happier with the Haskell-style layout, I've found
12:56:24 <Berengal> bash is happy with semicolons, I've found ;)
12:56:47 <Cale> I mean, you can avoid semicolons altogether if you use Haskell-style indentation.
12:57:02 <Berengal> Anyway, I try to use as few ifs as possible (in languages lacking if-expressions)
12:57:26 <Berengal> Sometimes I have to, but sometimes a few lambdas are enough, and give me if-expressions
12:57:40 <Berengal> depending on the language
12:58:37 <conal> cads: i've never heard of them.
12:58:44 * conal googles
13:05:49 <binrapt> What's the most mature interpreter for Haskell in your opinion? Hugs appears to be quite outdated - the last release is already over 3 years old. I'm sure Haskell has changed a lot since then
13:06:11 <roconnor> ghci
13:06:22 <binrapt> Ok thanks
13:06:26 <Cale> http://hal.archives-ouvertes.fr/docs/00/39/25/47/PDF/bigraphs.pdf -- I like the diagrams in this paper :)
13:06:30 <tommd> binrapt: Haskell hasn't had a release since the 98 standard, so no - it hasn't changed and won't till the first Haskell' release.
13:06:51 <Cale> tommd: Uhh... the Haskell *standard* hasn't changed
13:06:53 <tommd> On the other hand, there are lots of extensions that aren't yet "Haskell"
13:06:54 <binrapt> Haskell' is a new standard?
13:06:59 <Cale> Haskell itself has changed a *lot*
13:07:00 <binrapt> ' implying change?
13:07:01 <tommd> Cale: Yeah, that's my point.
13:07:13 <Cale> binrapt: yeah
13:07:27 <Cale> binrapt: The idea is just to formalise some of the new stuff that's in GHC.
13:07:34 <Cale> Implement first, ask questions later :)
13:07:37 <Vanadium> Like hierarchical modules!
13:07:37 <roconnor> tommd: also, the H 98 report has been revised several times
13:07:43 <tommd> binrapt: There is "Glasgow Haskell" and "Haskell"  users of "Glasgow Haskell" (most people) just call it Haskell.
13:07:54 <binrapt> Ok
13:07:57 <tommd> roconnor: Sure, the FFI from 2003 being the most recent?
13:08:18 <roconnor> could be.  I thought there was a 2005 revision ...
13:08:34 <Cale> I consider Haskell to be some sort of integral over all the languages which people call "Haskell" :)
13:08:43 <Berengal> The H 98 report specifically calls the language "Haskell 98", leaving just Haskell as the name for whatever weird dialect they may come up with
13:08:59 <roconnor> webage says Dec 2002 is the last revision
13:09:20 <tommd> We hope to see Haskell '10 soon :-)  I hear it will have this new MPTC concept.
13:09:21 <Cale> Which even has room for things like she :)
13:09:56 <Cale> She is Haskell too!
13:09:56 <Cale> hehe
13:09:56 <tommd> That's what she said.
13:10:13 <aavogt1> were MPTCs around when they standardized H98?
13:10:27 <Cale> aavogt1: Perhaps.
13:10:34 <Berengal> Cale, once you start messing with the syntax, I become a little less inclusive, but indeed, I still wouldn't call she anything but Haskell (until we possible get bored with her)
13:10:46 <Cale> aavogt1: Certainly the state of the art in typeclasses was more than what they standardised.
13:11:02 <Cale> At the very least, (the equivalent of) FlexibleInstances was there.
13:11:04 <roconnor> problem is MPTC's are almost useless without something like fundeps
13:11:42 <Cale> The standard is extremely conservative when it comes to what classes and instances are allowed.
13:11:49 <Twey> What is this she you speak of?
13:11:55 <aavogt1> @where she
13:11:55 <lambdabot> I know nothing about she.
13:12:01 <Cale> The Strathclyde Haskell Enhancement
13:12:05 <tommd> @where is she
13:12:05 <lambdabot> I know nothing about is.
13:12:16 <Cale> @where she
13:12:16 <lambdabot> I know nothing about she.
13:12:19 <Cale> huh
13:12:29 <Twey> Â« I seem to have released some software. Iâ€™m as surprised as you are. No good can possibly come of it. Â»
13:12:30 <Cale> http://personal.cis.strath.ac.uk/~conor/pub/she/
13:12:33 <Twey> Hahaha.
13:12:35 <Cale> @where+ she http://personal.cis.strath.ac.uk/~conor/pub/she/
13:12:35 <lambdabot> I will remember.
13:12:39 <Twey> Ooh.
13:13:02 <Berengal> @hackage she
13:13:03 <lambdabot> http://hackage.haskell.org/package/she
13:13:11 <tommd> lambdabot: You will only remember if someone else remembers to tell you to flush.  Personally I think you should know enough to flush on your own.
13:13:15 <Vanadium> Why does hackage's trac still use the old logo :(
13:13:42 <tommd> Hackage is due for a makeover (once coutts decides hackage-server is ready)
13:14:16 <Berengal> I'm looking forward to that
13:18:26 <jvoorhis> why doesn't haddock use the new logo for that matter
13:19:04 <skorpan> what really pisses me off about haddock is the broken HTML it produces
13:19:14 <skorpan> headers don't use H1/H2/H3 etc
13:19:18 <jvoorhis> i haven't used it long enough to be annoyed by that yet :)
13:19:39 <stanv> How to replace few functions (signatures) in Class for some type?
13:19:41 <jvoorhis> i know you can pass it a css file, but can it also use a template?
13:20:05 <DrSyzygy> Calling all category theorists. Can we express the exponential in a CCC as a limit?
13:20:11 <skorpan> i think letting people use their own templates would be a bit overkill, but it should at least be possible to get xhtml 1.0 out of it
13:20:30 <skorpan> maybe it is possible, i haven't really checked
13:21:28 <Cale> DrSyzygy: My initial response is "no", at least not in the category which we're discussing (though probably in some other closely related category).
13:22:09 <Cale> Then again, I might be wrong, let me actually think about it a moment :)
13:22:40 <DrSyzygy> I'm happy with conjuring a different category to make it work as a limit. I'm just hoping I can introduce exponentials-as-limits before I start talking about adjoints.
13:23:06 <DrSyzygy> OR if not, then at least know why not.
13:23:22 <Cale> It can certainly be constructed from an adjunction.
13:23:38 <DrSyzygy> It's easy and obvious as an adjunction, but that's not until next week.
13:24:51 <jvoorhis> has anyone here worked with both the haskell ffi and done a little mac programming?
13:26:03 <Cale> Let's see... consider the category of morphisms X x Y -> Z for fixed objects Y and Z in your CCC. The exponential is a terminal object for that isn't it?
13:26:10 <jvoorhis> (and not necessarily Cocoa/ObjC)
13:26:32 <DrSyzygy> Doh. Of course.
13:28:28 <Cale> Well, more precisely, the evaluation map for the exponential is a terminal object, but you know what I mean already.
13:29:08 <ezyang> I want to right a stream-based power-series calculator. Should I use comonads or arrows?
13:29:12 <ezyang> *write
13:29:31 <Tobsan> is there a way in Haskell to do something like receive ... after from erlang?
13:29:57 <Cale> ezyang: I can see a place for comonadic stuff to be useful, but start with no abstractions and see what fits later.
13:30:46 <ezyang> The point behind this exercise is to get a feel for how comonads work, but that does seem sensible
13:30:50 <Twey> Tobsan: What does receive â€¦ after do?
13:31:13 <Tobsan> Twey: it sees if any clause in the receive matches, or does something after the amount of time has passed
13:31:21 <Tobsan> I could post an example!
13:31:21 <Tobsan> brb
13:31:27 <Cale> Tobsan: oh, sure.
13:32:03 <Cale> Tobsan: Well... it can be approximated in any number of ways, depending on how you choose to implement message passing.
13:32:41 <Tobsan> Cale: hmm, alright.
13:33:17 <Cale> You might start with a function that races a number of actions with each other.
13:33:18 <Tobsan> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10967#a10967
13:33:32 <binrapt> Why does #haskell have a disproportionally large IRC population on Freenode? The Haskell share on the market of programming languages is rather small in comparison
13:33:35 <Tobsan> not exactly sure about the after syntax now, but it's just an example
13:33:53 <Tobsan> Cale: Sounds like a good idea.
13:33:56 <Cale> Then you can race the action for receiving the message with one which simply calls threadDelay and then returns a value.
13:34:15 <Tobsan> exactly
13:34:16 <Vulpyne> binrapt: Maybe because Haskell is fairly esoteric, pretty much all Haskell programmers come here. Programmers for other languages are spread across more networks.
13:34:27 <binrapt> Perhaps
13:34:38 <binrapt> maybe Haskell users also need more help than others
13:34:38 <Cale> I'm not sure if most Haskell programmers actually come here, but we do try to be friendly.
13:34:41 <copumpkin> we're also incredibly friendly
13:34:42 <binrapt> Haha
13:34:47 <copumpkin> ;)
13:34:51 <roconnor> binrapt: no one understands how to program in Haskell, so they all need to come here.
13:35:01 <binrapt> roconnor yeah I figured as much
13:35:03 <roconnor> in that Haskell's learning curve is unbounded
13:35:12 <Twey> Heh
13:35:15 <Twey> Haskell's isn't
13:35:18 <Cale> I always see download counts and things which make it seem like we're the tip of an iceberg, and I wonder how all the other Haskell programmers get along without using IRC.
13:35:19 <copumpkin> I think there are a lot of people who intend to learn haskell at some point and were already on IRC, so join the channel hoping to soak some in
13:35:27 <Twey> But the channel also covers many of the things you can do in Haskell :Ã¾
13:36:03 <Cale> Yeah, it again comes down to what you mean by "learning Haskell"
13:36:23 <centrinia> Cale, I just automatically download GHC at semi-regular intervals using my botnet.
13:37:55 <Cale> At some point you become pretty familiar with the spec and various extensions, but there's an unbounded number of abstractions which can be implemented by libraries.
13:38:47 <Cale> and which can take as much effort to learn as programming language features
13:39:00 <Cale> (if not more)
13:42:13 <cads> cale, you can't read CS papers without running into haskell
13:42:27 <SubStack> it's true
13:43:14 <cads> then you're like "oh neat, this is like if someone took basic category theory and made it a programming language", and you feel happy
13:43:22 <jvoorhis> conversely, it's hard to learn haskell without running into CS papers
13:43:51 <sproingie> and it's hard to learn CS papers without running into weird notation
13:49:51 <mreh> matt@mattpc:~$ cabal install leksah
13:49:51 <mreh> Resolving dependencies...
13:49:51 <mreh> cabal: cannot configure leksah-0.6.1. It requires gtksourceview2 >=0.10.0
13:50:23 <ezyang> What's a good way to zip sum three lists? I can think of some obvious ways to do it, but they feel clunky
13:50:25 <aavogt> mreh: do you have gtk2hs installed?
13:50:35 <mreh> aavogt: yes
13:50:44 <mreh> which packages?
13:52:04 <aavogt> mreh: gtk2hs should provide gtksourceview2, but perhaps it wasn't enabled in your build of gtk2hs (I may be wrong about this, but I vaguely remember having to check gtksourceview2 in gtk2hs's configure stuff)
13:52:29 <mreh> aavogt, thx
13:52:29 <binrapt> F:\Code\Haskell>C:\ghc\ghc-6.12.0.20090924\bin\ghci.exe; GHCi, version 6.12.0.20090924: http://www.haskell.org/ghc/  :? for help: HSghc-prim-0.2.0.0: The specified module could not be found. Loading package ghc-prim ... <command line>: can't load .so/.DLL for: HSghc-prim-0.2.0.0 (addDLL: could not load DLL)
13:52:33 <binrapt> What's happening? :(
13:52:39 <binrapt> That's a fresh ghc installation
13:52:44 <mreh> someone set us up the bomb
13:52:46 <aavogt> @type zipWith3 (\x y z -> x+y+z) -- like this ezyang?
13:52:47 <lambdabot> forall c. (Num c) => [c] -> [c] -> [c] -> [c]
13:53:02 <ezyang> Yeah, that was one possibility
13:53:21 <aavogt> @type map sum . transpose
13:53:23 <lambdabot> forall a. (Num a) => [[a]] -> [a]
13:53:32 <monochrom> ezyang: zipWith3 (\x y z -> x+y+z) is a good way to zip sum three lists
13:54:12 <aavogt> > map sum . transpose $ [[1,2,3],[3,2,1],[0,1,0]]
13:54:13 <lambdabot>   [4,5,4]
13:54:46 <aavogt> but I expect the zipWith version to be faster
13:54:49 <binrapt> C:\ghc\ghc-6.12.0.20090924\lib\ghc-prim-0.2.0.0 looks ok to me, why is it failing on me?
13:55:52 <ezyang> aavogt: that's really cute!
13:56:45 <sproingie> is there a ghc snapshot that doesn't depend on libtinfo?
13:56:56 <sproingie> libtinfo is like some obsolete thing i havent seen in years
13:57:41 <sproingie> i wonder if i can just symlink libncurses
14:01:28 <HairyDude> is gtk2hs on hackage? I can't find it
14:01:46 <gwern> HairyDude: nope
14:01:48 <gwern> can't
14:02:03 <HairyDude> how come?
14:03:42 <mreh> HairyDude: I've just installed it from the sources today
14:03:50 <mreh> you have to do it by hand I'm afraid
14:04:31 <HairyDude> heh, that's weird. ubuntu has gtk2hs-doc but not gtk2hs
14:09:08 <monochrom> refutation: http://packages.ubuntu.com/source/jaunty/gtk2hs lists all the binary packages that combine to gtk2hs
14:10:18 <monochrom> For starters http://packages.ubuntu.com/jaunty/libghc6-gtk-dev
14:12:49 <ezyang> ok, I sketched out the program using normal infinite lists
14:12:54 <ezyang> it's actually pretty concise
14:13:32 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10968#a10968
14:13:58 <ezyang> now I am wondering how to turn it into comonadic code
14:14:57 <HairyDude> monochrom: hmm. I expected there to be a package foo if there's a package foo-doc, obviously I was wrong
14:15:38 <profmakx> haskelldb-hsql is borken :/
14:15:53 <profmakx> hm.
14:15:58 <profmakx> why is it installing 0.10 o.O
14:16:37 <monochrom> I just accept the fact that I have superior search-and-infer skills.
14:17:24 <profmakx> nevermind. i fsckd up
14:21:18 <ezyang> I guess... I'm not convinced that comonads are useful to me yet
14:21:19 <HairyDude> hmm, configure can't find firefox-dev (yes I did install it)
14:22:28 <HairyDude> or libgstreamer-dev
14:24:48 <jmcarthur> comonads are very useful... for certain applications
14:25:09 <copumpkin> are there any nontrivial functors that are both monads and comonads?
14:25:52 <jmcarthur> what is nontrivial?
14:25:54 <jmcarthur> Stream?
14:25:57 <HairyDude> lists are both aren't they?
14:26:01 <ezyang> jmcarthur: Yeah. I'm trying to figure out if it's useful for this
14:26:16 <ystael>  /me thinks copumpkin's nick seems curiouser and curiouser as halloween approaches
14:26:22 <ezyang> Hmm
14:26:23 <jmcarthur> HairyDude: lists are not. nonempty lists maybe
14:26:23 <copumpkin> :)
14:26:29 <mreh> i've tried to reinstall gtk2hs with --enable-gtksourceview2, but cabal still can't detect it has been installed
14:26:29 <HairyDude> ah yes
14:26:36 <copumpkin> what's join on streams?
14:26:40 <HairyDude> coreturn [] = undefined
14:26:50 <dcoutts> mreh: is it actually registered?
14:26:51 <mreh> do I need to uninstall then reinstall?
14:27:00 <mreh> dcoutts: I don't know :( :(
14:27:05 <mreh> how do I find out
14:27:07 <dcoutts> mreh: ask ghc-pkg list
14:27:11 <mreh> oh
14:27:19 <ezyang> so, is cojoin a = iterate tail a the correct implementation for lists?
14:27:39 <mreh> dcoutts: no
14:27:40 <ezyang> I guess I lose left-locality as I cdr down the list
14:27:57 <jmcarthur> copumpkin: if you imagine a stream of streams as an infinitely large matrix (or something like that), the resulting stream is the elements on the diagonal
14:28:22 <copumpkin> jmcarthur: aha
14:28:50 <mreh> dcoutts: any suggestions?
14:28:57 <dcoutts> mreh: do the gtk2hs ./configure --enable-gtksourceview2 and check that configure completes successfuly
14:29:04 <dcoutts> then make and make install
14:29:15 <dcoutts> check each that step says it completes successfully
14:29:21 <mreh> dcoutts: oh it does, it even tells me it's going to install gtksourceview2
14:29:42 <dcoutts> mreh: you're not using --enable-packager-mode I presume
14:29:50 <mreh> dcoutts, no
14:29:58 <dcoutts> mreh: and the make and make install steps did not report any failures?
14:30:16 <mreh> by failures, they didn't say "ERROR" and die prematurely
14:30:22 <mreh> no failures
14:31:13 <mreh> dcoutts: no
14:32:55 <dcoutts> mreh: I guess my only other suggestion is to make clean and run the configure, make, make install again
14:33:20 <dcoutts> you're using the released tarball right? 0.10.1?
14:33:38 <mreh> 0.10.1, yes
14:35:11 <dcoutts> mreh: if it's still not working, hpaste the log of the tail end of make install
14:35:30 <sinelaw> @src liftM2
14:35:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:35:44 <copumpkin> sinelaw: liftA2 is nicer!
14:35:48 <sinelaw> @src liftA2
14:35:49 <lambdabot> liftA2 f a b = f <$> a <*> b
14:35:52 <sinelaw> :)
14:35:58 <Heffalump> does cabal-install support GHC 6.12 yet?
14:36:08 <copumpkin> nope
14:36:10 <sinelaw> @src <*>
14:36:11 <lambdabot> Source not found. You untyped fool!
14:36:14 <sinelaw> @type <*>
14:36:16 <lambdabot> parse error on input `<*>'
14:36:18 <copumpkin> sinelaw: it's ap, for applicatives
14:36:25 <sinelaw> @type ap
14:36:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:36:27 <copumpkin> sinelaw: it's a method though, and you need parentheses
14:36:41 <sinelaw> right
14:40:29 <deech> Hi all, I was wondering if someone could help me understand weak head normal form. My understanding is that you evaluate an expression until its first constructor or operator. So for example [1,2,3] becomes "(:) 1 _ " and (1 + 2 + 3) is "(+) 1 _"
14:40:55 <Botje> + is strict
14:41:04 <Botje> so 1 + 2 + 3 in WHNF is 6
14:41:20 <copumpkin> nuh uh
14:41:31 <copumpkin> (+) is just a method
14:41:35 <jmcarthur> deech: [1,2,3] is (:) _ _ in WHNF
14:41:47 <sinelaw> and I ask if someone can explain the difference with HNF
14:43:30 <deech> Then I'm confused, I'm trying to understand how `par` works. It evaluates it's left argument to WHNF and returns the right. What does "evaluating its left argument to WHNF" mean? And how is this different from lazy evaluation in general?
14:43:58 <Cale> jmcarthur: err...
14:44:07 <deech> s/lazy evaluation/strict evaluation/
14:44:35 <Cale> [1,2,3] is syntax sugar for 1 : (2 : (3 : [])) which is already in WHNF on its own
14:45:13 <jmcarthur> i meant if it we being generated lazily
14:45:18 <jmcarthur> *was
14:45:18 <Cale> deech: You're describing seq, not par
14:45:41 <jmcarthur> but yeah, i was wrong the way i said it
14:46:09 <Cale> deech: par adds its first argument to a queue of expressions to be evaluated by some worker thread if there's time before it's needed, before evaluating to its second argument
14:47:42 <Cale> That is, when the expression (par x y) is evaluated, x is added to a queue of things which ought to be worthwhile computing in parallel if there's spare time on some processor, and then it reduces to y
14:48:22 <deech> Cale: And where does WHNF come into it? RWH mentions that 'x' is reduced to WHNF and then queued.
14:48:51 <Cale> It's the other way around. It will be evaluated to WHNF if it gets taken from the queue by some worker.
14:49:28 <Baughn> (This will always happen, unless there's never any spare cpu time or it's already evaluated by the time there is)
14:49:29 <deech> Cale: Then once it gets taken from the queue why not evaluate it all the way?
14:49:39 <Baughn> deech: "All the way" is undefinable
14:49:39 <Cale> (the worker will stop evaluating if it reaches a plain lambda with no more args, or a data constructor)
14:49:59 <Cale> This is just what "evaluate" means in Haskell :)
14:50:08 <Baughn> deech: There's a whole set of functions in Control.Parallel.Strategies to let you hook arbitrary amounts of evaluation on rwhnf, though
14:50:21 <Baughn> Well..
14:50:25 <Cale> It means roughly "do the least amount of work on this expression which could conceivably be required to pattern match on it"
14:50:37 <Baughn> "par (rnf x) y" would reduce x all the way, actually
14:50:40 <Cale> (Though, that's not quite right for function types)
14:50:44 <Baughn> Don't do it with an infinite x. ;)
14:51:11 <Baughn> Also, rnf always walks the full tree, even if it has already been evaluated
14:51:16 <Cale> Provided that rnf is an implementation of "reducing all the way" as it's supposed to be.
14:51:29 <Baughn> I feel relatively confident.
14:51:34 <Cale> yeah :)
14:51:46 <deech> In RWH (http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html) in the "Knowing what to evaluate in parallel" section, it mentions that evaluation of the left argument had to be 'force'd.
14:51:47 <Cale> The instances normally do a pretty good job of that :)
14:52:12 <Baughn> It's just annoying that so many libraries don't provide NFData instances. Like bytestring.
14:52:38 <Baughn> Granted, rwhnf works on strict bytestrings, but.. you still want rnf defined
14:53:48 <Cale> deech: Yeah, I guess what they're trying to say in that part about par is that it does amount to trying to evaluate the first arg to WHNF in parallel. But that evaluation may or may not ever actually begin.
14:54:56 <Baughn> deech: The capabilities (ghc-speak for OS threads you start with -Nfoo; there's at least one) run sparks whenever they've got nothing else to do. This may not happen.
14:55:00 <Cale> In particular, if the value is needed before some other worker thread gets to it, or if the value is actually garbage collected before that happens, then it'll never be evaluated.
14:55:12 <Baughn> Weak references are nifty. ;)
14:55:51 <Cale> An interesting thing though is that the meaning of the program (par x y) is the same as the meaning of the program y
14:56:10 <Cale> The only difference is in performance :)
14:56:16 <Baughn> Since haskell functions never have side-effects, and par x y's value is just y
14:56:29 <Cale> Even if x is an infinite loop to evaluate
14:56:31 <Baughn> The value is all that matters for the /meaning/
14:56:34 <Cale> Or an error
14:56:51 <Cale> > par (error "ack!") ()
14:56:51 <lambdabot>   ()
14:56:53 <Baughn> ..although, if it's an infinite loop, your program will be very annoying to run. Or it might lock up.
14:56:58 <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"...
14:57:05 <Baughn> dpratt71: Yeah. We failed.
14:57:21 <Cale> dpratt71: That's right. Successful languages have problems that we'd *like* to avoid, if possible.
14:57:26 <dpratt71> Baughn: ah, you killed my follow-up :)
14:57:34 <Baughn> dpratt71: There are warts in the prelude now (like, er, most of the prelude..) that will never be fixed
14:57:49 <deech> Someone note that quote for the Haskell Weekly News. I don't know how.
14:57:49 <ziman> how about Haskell'?
14:57:50 <dpratt71> that's what I was getting at...
14:57:51 <Baughn> Nobody cares enough to deal with the fallout of, e.g., making Monad a subclass of Applicative
14:57:59 <copumpkin> I care
14:58:01 <dpratt71> why haven't those been fixed
14:58:02 <dpratt71> ?
14:58:07 <Baughn> copumpkin: Me too. There's two of us.
14:58:15 <copumpkin> Baughn: #alt-stdlib ;)
14:58:17 <jmcarthur> me three
14:58:23 <Cale> ziman: Haskell' is not really the place for fixing the Prelude. What we need is a different mindset about backwards compatibility, really.
14:58:23 <sproingie> would that make it a subclass of Functor?
14:58:27 <Baughn> dpratt71: By the time we figured out that the current way was troublesome, there was too much breakable code
14:58:29 <Botje> deech: @remember nickname quote
14:58:32 <Botje> is the syntax
14:58:42 <dpratt71> but who relies on the code not breaking?
14:58:53 <Baughn> dpratt71: Although, with the base-3/base-4 scheme, there's no /particular/ reason the Prelude couldn"t be completely revamped for base-5...
14:59:01 <sproingie> mv Prelude.hs OldPrelude.hs
14:59:07 <Cale> ziman: At least, if Haskell' is going to define a fixed prelude, then we ought to implement it first.
14:59:19 <dpratt71> is Haskell used much in production...other than @ Gal..uh..something?
14:59:19 <deech> @remember dpratt71 "<dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid
14:59:19 <deech>            success at all costs"...
14:59:19 <deech> <Baughn> dpratt71: Yeah. We failed."
14:59:19 <lambdabot> It is stored.
14:59:34 <Cale> Baughn: yeah, and I think we *should* do that.
14:59:38 <deech> Hope that worked
14:59:50 <Cale> deech: uh, it didn't.
14:59:55 <sproingie> Galois
14:59:58 <jmcarthur> i use xmonad and xmobar at work. does that could as in production?
15:00:02 <jmcarthur> *count
15:00:06 <Cale> deech: You can't split it across lines like that :)
15:00:14 <Cale> @forget dpratt71 "<dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid
15:00:14 <Baughn> Cale: Join #alt-stdlib too, then. :)
15:00:15 <lambdabot> Done.
15:00:27 <jmcarthur> oh, i also use haskell for database migrations in one of my projects
15:00:34 <Cale> Baughn: Oh right... I forgot to add it to my join list.
15:00:40 <jmcarthur> and i prototyped a few things in it
15:00:50 <dpratt71> Cale: you dashed my one shot at immortality!
15:01:09 <sproingie> he just mangled the paste
15:01:17 <Cale> dpratt71: we can do a better job of it :)
15:01:40 <deech> @remember Baughn "<dpratt71> so I read somewhere that the unofficial  motto of Haskell was \"avoid success at all costs\"...<Baughn> dpratt71: Yeah. We failed."
15:01:40 <lambdabot> I will remember.
15:01:41 <dpratt71> I don't own that quote anyways :)
15:01:45 <Cale> @remember dpratt71 <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed."
15:01:45 <lambdabot> Okay.
15:01:51 <Cale> er
15:01:51 <sproingie> @quote success
15:01:51 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed."
15:01:54 <Cale> @forget dpratt71 <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed."
15:01:55 <lambdabot> Done.
15:01:56 <Cale> @forget dpratt71 <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
15:01:57 <lambdabot> No match.
15:02:01 <Cale> @remember dpratt71 <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
15:02:01 <lambdabot> Nice!
15:02:05 <Cale> There we go ;)
15:02:10 <dpratt71> :)
15:02:16 <deech> Cool. Thanks!
15:02:37 <Vanadium> I cannot tell what you changed, aa
15:03:27 <dpratt71> one thing that tends to confuse me is the proliferation of lift/map functions; if Haskell is ever "fixed", do those go away?
15:04:16 <mreh> from the leksah haskell wiki page: "you have to install gtksourceview2 in a version > 2.4.0 "
15:04:20 <mreh> what does that mean?
15:04:33 <skorpan> mreh: that you need gtksourceview2 which is newer than version 2.4.0
15:05:07 <mreh> i've installed it with gtk2hs and i've got a version numbered 0.10.1
15:05:21 <mreh> gtk2hs0.10.1
15:05:50 <mreh> does it want newer c libs? the problem is with the haskell source though
15:07:13 <heatsink> Is there a way to make GHC look through type synonyms when deciding whether a type function is fully applied?
15:08:12 <dpratt71> where can I submit feature requests for lambdabot? I'm thinking of something like @wasthatadumbquestion
15:08:30 <heatsink> e.g. if I have:  {type App t a = t a;  type family T :: * -> *; type B = App T Int}
15:08:40 <dcoutts> mreh: it means the version of the gtksourceview C libs
15:09:29 <dcoutts> mreh: $ pkg-config --modversion gtksourceview-2.0
15:09:42 <heatsink> then GHC reports an error becasue T isn't applied to any arguments
15:10:23 <mreh> 2.2.2
15:10:30 <mreh> :{
15:10:37 <aavogt> dpratt71: you'd need a more complicated Functor class to handle things like Data.Set (which requires elements to be members of Ord)
15:10:37 <heatsink> erm.  I mean "type family T a :: *"
15:14:11 <bran> :w
15:14:21 <copumpkin> :q
15:15:46 <yrlnry> Is there a way to define fmap in terms of join, return, and (>>=) ?
15:16:22 <skorpan> i think some monads do that
15:16:41 <skorpan> the general answer would be no i guess, since not all functors are monads
15:16:46 <heatsink> :t \f m -> m >>= \x -> return (f x)
15:16:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
15:17:05 <yrlnry> That's it.  Thanks very much.
15:17:32 <yrlnry> :t \f m -> m >>= (return . f)
15:17:32 <Berengal> liftM is return
15:17:32 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> a1) -> m a -> m a1
15:17:37 <Berengal> *fmap
15:17:40 <Berengal> I get confused...
15:17:48 <yrlnry> :t liftM
15:17:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:19:12 <monochrom> @src liftM
15:19:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:19:22 <yrlnry> I'm pondering connections between modal logic and monads, and if you interpret m as "possibly true", then (>>=) is obviously valid, and so is <$>, but fmap is really weird and non-obvious.  Thanks to heatsink, I now have a proof.
15:19:27 <monochrom> exercise: turn it into >>=
15:20:08 <Berengal> monochrom, turn what into >>=?
15:20:12 <yrlnry> And moreover, join, return, and <$> have all been considered historically as possible axioms for modal logic.
15:20:48 <heatsink> yrlnry, it's modus ponens under a modality, right?  if possibly x, and x implies y, then possibly y.
15:20:50 <monochrom> turn liftM f m1 = do { x1 <- m1; return (f x1) } into >>=
15:21:15 <yrlnry> heatsink:  yes, but that is not obviously true.
15:21:18 <benmachine> > toRational pi
15:21:19 <lambdabot>   884279719003555 % 281474976710656
15:21:24 <benmachine> ^ am I the only one who is amused by this notion
15:21:35 <yrlnry> Because you don't know that x implies y in the same world that x is true in.
15:21:35 <sproingie> @undo do { x1 <- m1; return (f x1) }
15:21:35 <lambdabot> m1 >>= \ x1 -> return (f x1)
15:21:55 <sproingie> obvious enough
15:22:06 <yrlnry> By studying this proof, I hope to understand why the theorem follows.
15:22:18 <monochrom> @type (<$>)
15:22:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:22:49 <sproingie> wait isn't that liftM?
15:22:56 <monochrom> > toRational (pi :: CReal)
15:22:57 <lambdabot>   * Exception: CReal.toRational
15:23:04 <yrlnry> @type  <*>
15:23:05 <lambdabot> parse error on input `<*>'
15:23:06 <monochrom> I am amused by that instead.
15:23:11 <yrlnry> @type  (<*>)
15:23:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:23:20 <yrlnry> I meant <*>, not <$>.
15:23:46 <sproingie> lots of operators for the same thing
15:24:07 <yrlnry> Oh, that one holds if f is necessity, not possibility.
15:24:19 <yrlnry> The converse is true when f is possibility.
15:24:23 <monochrom> @type ap
15:24:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:24:44 <yrlnry> (<>a -> <>b) -> <>(a -> b).
15:25:01 <yrlnry> Well, this is probably off-topic.  Sorry and thanks.
15:25:15 <monochrom> on-topic as long as there is a haskell disguise
15:25:37 <heatsink> It's fine.  #haskell is the unofficial #cs.
15:25:40 <dpratt71> @src ap
15:25:40 <lambdabot> ap = liftM2 id
15:25:44 <Berengal> It has pointy syntax. Must be haskell
15:26:39 <monochrom> ghc 7.4 will allow you to write "(Monad <>) => <>(a->b) -> <>a -> <>b" :)
15:27:10 <ddarius> yrlnry: You've read "A Judgemental Reconstruction of Modal Logic" ?
15:27:11 <heatsink> that would be cool
15:27:21 <yrlnry> ddarius:  No, but I would like to.
15:27:26 <yrlnry> Looking it up now.
15:27:53 <yrlnry> Got.  Thanks.
15:28:08 <Berengal> More like (Monad â‹„) => â‹„(a â†’ b) â†’ â‹„a -> â‹„ b
15:28:44 <monochrom> yeah!
15:28:58 <heatsink> yrlnry: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.92.2299
15:29:46 <monochrom> ghc 8.6 will let you write (â„³ â‹„) â‡’ â‹„(a â†’ b) â†’ â‹„a â†’ â‹„ b
15:29:51 <yrlnry> heatsink:  got that too.
15:29:56 <heatsink> :)
15:29:59 <Berengal> When programmable lcd keyboard become commonplace, haskell will turn into APL++
15:30:19 <sproingie> ghc 9.8 will include a copy of Oleg
15:30:27 <Berengal> Well, more like APLâ§º
15:31:13 * heatsink wonders when Yi will correctly render fortressMode
15:31:42 <Berengal> Ooo, found my parallel-arrow composition operator: â¬±
15:31:47 * sproingie imagines dwarfFortressMode
15:32:23 <sproingie> where all my programs end in tantrum spirals
15:33:10 <copumpkin> Berengal: awesome!
15:33:30 <Berengal> Now I just need to figure out their semantics ;)
15:33:40 <copumpkin> it takes a 4-tuple of arrows
15:34:02 <Berengal> copumpkin, why 4?
15:34:03 <kwallmark> sproingie: "=> has been content lately.  She dined in a legendary dining room recently.  She complained about the draft.  She likes Integers and monads for their transformability"
15:34:13 <copumpkin> Berengal: because I can't count
15:35:11 <ddarius> heatsink, yrlnry: This looks much better and has more references: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.141.7109
15:35:11 <Berengal> I'm wondering if I should impose a monoid constraint on the last arrow in a parallel execution...
15:35:22 <sproingie> kwallmark: she absolutely detests side effects.
15:35:28 <Veinor> copumpkin: I feel special :D
15:35:40 <copumpkin> Veinor: how come?
15:35:48 <Veinor> for being on your list :P
15:35:52 <Berengal> Probably easiest, but monoids aren't commutative
15:35:53 <copumpkin> oh lol
15:36:07 <copumpkin> Veinor: it's actually my shitlist of people to murder
15:36:13 <Veinor> oh no D:
15:36:57 <Veinor> actually, DF is one of those embarrassingly parallelizable things
15:36:58 <heatsink> ddarius, Thanks, I'll check it out.
15:37:00 <Veinor> except in a few cases
15:37:20 <Vanadium> Maybe we should rename haskell Monad Fortress
15:37:28 <Veinor> so I guess it's not embarrassingly parallel, but it's still quite parallelizable
15:37:46 <sproingie> rewriting DF in haskell can't be so hard ;)
15:38:15 <Berengal> Do we want concurrent arrows for that? ;)
15:38:25 * Berengal needs an incentive to try to see if they're possible
15:39:09 <Veinor> does that make unsafePerformIO the magma trap of Monad Fortress?
15:39:17 <Veinor> it can be really powerful but can also screw you over massively
15:39:27 <gOcOOl> in ghci/Prelude, when trying to import a module it can;t find, it often prints out this message: "Use -v to see a list of the files searched for." Where & how do I specify the "-v" to look for the list of files searched?
15:39:53 <heatsink> gOcOOl, add it as a parameter on the command line.
15:40:03 <Veinor> ghci -v
15:40:07 <heatsink> gOcOOl, interactively, you can type ":set -v"
15:40:07 <Veinor> then do whatever.
15:40:15 <gOcOOl> ah ok, thanks
15:40:27 <Veinor> how do you unset it? :set +v? or :set --v?
15:40:37 <kwallmark> Veinor: :unset -v
15:41:21 <sproingie> i guess cats would represent space leaks
15:41:58 <Veinor> this is like, some kind of horrible nerd humor
15:42:11 <Veinor> reminds me of psdoom
15:42:29 <sproingie> DF is the only game where you see bug reports start with "so there I was throwing cats into a magma furnace"
15:43:29 <Veinor> Wasn't there some bug a while ago that was so awesome it was made a feature?
15:43:37 <Veinor> I know it wasn't murdercarp.
15:43:40 <dpratt71> I thought I understood currying, but in trying to reason about the definition of "ap", I realize I don't quite get it
15:43:48 <Veinor> :src ap
15:43:58 <Veinor> I mean
15:44:00 <benmachine> @src ap
15:44:01 <lambdabot> ap = liftM2 id
15:44:01 <Veinor> @src ap
15:44:02 <lambdabot> ap = liftM2 id
15:44:03 <Veinor> yeah
15:44:09 * benmachine thinks liftM2 ($) is clearer
15:44:14 <benmachine> @type liftM2 ($)
15:44:16 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
15:44:49 <dpratt71> benmachine: I agree, but I'm still trying to understand how "id" works
15:45:13 <benmachine> > f `id` x
15:45:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:45:15 <lambdabot>    `GHC.Show.Show a'
15:45:15 <lambdabot>      a...
15:45:18 <benmachine> bah
15:45:21 <benmachine> > f `id` x :: Expr
15:45:22 <lambdabot>   f x
15:45:25 <benmachine> :P
15:45:26 <Axman6> > id (+1) 2
15:45:27 <lambdabot>   3
15:46:09 <Veinor> @src id
15:46:09 <lambdabot> id x = x
15:46:13 <Axman6> id (+1) 2 --> (\x -> x) (+1) 2 --> (+1) 2
15:46:38 <benmachine> basically ($) is just a special case of id
15:46:52 <dpratt71> :t liftM2
15:46:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:47:12 <HairyDude> how do I give a C library a callback that is ultimately a Haskell function? is it possible to define a function like "setCallback :: <fntype> -> IO ()" so <fntype> is just an ordinary Haskell type?
15:47:17 <Berengal> ($) :: (a -> b) -> a -> b == (a -> b) -> (a -> b)
15:47:57 <dpratt71> so "id" is bound to "(a1 -> a2 -> r)" ?
15:48:16 <dpratt71> but the type of "id" is a -> a ?
15:48:30 <ddarius> HairyDude: Read the FFI report.  You can do what you want.
15:48:36 <ddarius> @where ffi
15:48:37 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:48:55 <Berengal> a -> a unified with (a1 -> b) -> (a1 -> b) => a = (a1 -> b)
15:50:26 <dpratt71> Berengal: ok; is there some resource that will give me a better understanding of the rules of "unification"?
15:51:19 <SmurfOR> i'm using the vim script http://www.vim.org/scripts/script.php?script_id=2603 to insert lambdas and the like but i can't escape in my strings now. \ always inserts a lambda.  anyone know a fix?
15:51:51 <dpratt71> it's weird; I tend to think of currying as consuming arguments, but this is more like substitution...sorta
15:52:02 <osfameron> can you do a list comprehension over an arbitrary number of variables?
15:52:17 <osfameron> e.g. to calculate probabilities of sums of dice, for example
15:52:34 <osfameron> where I might be looking at 2 dice, or 5
15:54:04 <sjanssen> osfameron: the syntax of list comprehensions requires a static number of variables
15:54:20 <sjanssen> but list comprehensions are really just concatMap/(>>=) on the inside
15:54:38 <dpratt71> @src liftM2
15:54:38 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:55:20 <osfameron> sjanssen: ah yes, thanks
15:55:53 <sjanssen> > replicateM 2 [1 .. 6]
15:55:54 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[3...
15:56:00 <sjanssen> osfameron: replicateM is handy for what you're doing
15:56:18 <osfameron> :t replicateM
15:56:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:56:39 <benmachine> @src replicateM
15:56:40 <lambdabot> replicateM n x = sequence (replicate n x)
15:57:45 <osfameron> I don't underestand how that works... but it looks like it does what I want, yes :-)
16:01:31 <Axman6> > group . sort . replicateM 3 $[1..6]
16:01:32 <lambdabot>   [[[1,1,1]],[[1,1,2]],[[1,1,3]],[[1,1,4]],[[1,1,5]],[[1,1,6]],[[1,2,1]],[[1,...
16:01:49 <Axman6> >  sort . replicateM 3 $[1..6]
16:01:50 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,1,6],[1,2,1],[1,2,2],[1,2,3],[1...
16:02:06 <osfameron> yarr, I've got as far as:  group . sort . map sum . flip replicateM [1..6] $ 3
16:02:10 <Axman6> >  sort . replicateM 5 $[1..6]
16:02:12 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,1,6],[1...
16:02:18 <osfameron> then (head &&& length) or whatever
16:03:21 <osfameron> > map (head &&& length) . group . sort . map sum . flip replicateM [1..6] $ 3
16:03:23 <lambdabot>   [(3,1),(4,3),(5,6),(6,10),(7,15),(8,21),(9,25),(10,27),(11,27),(12,25),(13,...
16:04:06 <Axman6> group doesn't work right :(
16:04:13 <Axman6> > group . sort . replicateM 5 $[1..6]
16:04:14 <lambdabot>   [[[1,1,1,1,1]],[[1,1,1,1,2]],[[1,1,1,1,3]],[[1,1,1,1,4]],[[1,1,1,1,5]],[[1,...
16:04:27 <Axman6> > group . sort . map sort . replicateM 5 $[1..6]
16:04:28 <lambdabot>   [[[1,1,1,1,1]],[[1,1,1,1,2],[1,1,1,1,2],[1,1,1,1,2],[1,1,1,1,2],[1,1,1,1,2]...
16:04:43 <Axman6> > map (head *** length) .  group . sort . map sort . replicateM 5 $[1..6]
16:04:45 <lambdabot>   Couldn't match expected type `([a], [a1])'
16:04:45 <lambdabot>         against inferred type `[...
16:05:03 <Axman6> > map (head &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:05:04 <lambdabot>   [([1,1,1,1,1],1),([1,1,1,1,2],5),([1,1,1,1,3],5),([1,1,1,1,4],5),([1,1,1,1,...
16:05:13 <osfameron> ah, I'm summing, you're grouping the sorted dice results
16:05:42 <Axman6> > sortBy (comparing snd) . map (sum &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:05:43 <lambdabot>   No instance for (GHC.Num.Num [a])
16:05:43 <lambdabot>    arising from a use of `Data.List.sum' ...
16:05:50 <Axman6> :\
16:06:05 <Axman6> >  map (sum &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:06:06 <lambdabot>   No instance for (GHC.Num.Num [a])
16:06:06 <lambdabot>    arising from a use of `Data.List.sum' ...
16:06:24 <Axman6> :t map (sum &&& length)
16:06:26 <lambdabot> forall a. (Num a) => [[a]] -> [(a, Int)]
16:07:07 <Axman6> >  map (sum . head  &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:07:08 <lambdabot>   [(5,1),(6,5),(7,5),(8,5),(9,5),(10,5),(7,10),(8,20),(9,20),(10,20),(11,20),...
16:07:30 <Axman6> > sortBy (comparing snd) .  map (sum . head  &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:07:31 <lambdabot>   [(5,1),(10,1),(15,1),(20,1),(25,1),(30,1),(6,5),(7,5),(8,5),(9,5),(10,5),(9...
16:07:33 <ivanm> hey Axman6
16:07:43 <Axman6> o/
16:08:00 <copumpkin> sortBy (flip $ comparing snd)
16:08:19 <Axman6> > sortBy (flip comparing snd) .  map (sum . head  &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:08:20 <lambdabot>   Couldn't match expected type `(a, b) -> b'
16:08:20 <lambdabot>         against inferred type `(...
16:08:25 <Axman6> > sortBy (flip $ comparing snd) .  map (sum . head  &&& length) .  group . sort . map sort . replicateM 5 $[1..6]
16:08:27 <lambdabot>   [(15,120),(16,120),(17,120),(18,120),(19,120),(20,120),(11,60),(12,60),(13,...
16:08:40 <Axman6> man, stats in haskell are so nice
16:08:42 <ivanm> oh, no, not the character that has pretensions of being a vegetable from some alternate dimension...
16:08:52 <copumpkin> ivanm: surely you mean "the yank"
16:08:53 <ivanm> Axman6: you mean bos' statistics package?
16:08:56 <ivanm> or just calculating from scratch?
16:09:01 <Axman6> the latter
16:09:17 <ivanm> copumpkin: I thought you didn't approve of that pejorative, and so I was trying to take your sensibilities into account...
16:09:23 <copumpkin> aw
16:09:24 <ivanm> but if you don't mind "yank"... :D
16:09:32 <copumpkin> I'll live with it :)
16:10:35 <ivanm> Axman6: yeah, it's amazing how hard it is to do generic calculations in most languages which are so easy in Haskell
16:12:27 <Axman6> damn, i wish i was doing the MIT Multicore programming course. it's all done on the Cell
16:12:32 <Axman6> using PS3's
16:13:46 <ivanm> Axman6: must be a bit hard to work from home though...
16:13:48 <copumpkin> I bet that'd be frustrating if you knew haskell
16:13:59 <Axman6> me too
16:14:03 <Axman6> all C and C++
16:14:14 <copumpkin> clunk clunk clunk
16:14:14 <ivanm> @tell dcoutts you may wish to stop bytestring-0.9.1.5 from being built with 6.10.*; it appears some packages fail to build because of it, e.g. http://hackage.haskell.org/packages/archive/hashed-storage/0.3.9/logs/failure/ghc-6.10
16:14:14 <lambdabot> Consider it noted.
16:16:41 <benmachine> I never got a response from haskell-cafe-owner about why I couldn't post to haskell-cafe
16:16:50 <benmachine> is there anyone I can poke on IRC to ask about it?
16:17:11 <sjanssen> benmachine: are you subscribed?
16:17:16 <benmachine> sjanssen: yes
16:17:20 <benmachine> hmm
16:17:23 <benmachine> that is a point actually
16:17:29 <benmachine> gmail has several of my addresses
16:17:38 <benmachine> could be that the default send one isn't the same one that receives stuff
16:17:51 <benmachine> I have to send mail from the subscribed address, I suppose?
16:18:10 <sjanssen> seems like a good thing to investigate.  Yes, the list will only accept mail from subscribed addresses
16:18:14 <sjanssen> spam reasons, etc.
16:18:18 <benmachine> ah okay
16:18:32 <benmachine> thanks
16:18:38 * benmachine will look into it tomorrow
16:18:45 <br1> why/how does quickcheck default to () for my Ord a argument?
16:19:20 <copumpkin> MR
16:19:29 <benmachine> DMR :O
16:19:39 <profmakx> is there any recent documentation on haskellDB?
16:19:41 <Axman6> HDMR >_>
16:19:57 <benmachine> hidef monomorphism?
16:19:58 <sproingie> KMFDMR
16:25:27 <tectum> oh
16:25:30 <tectum> hi
16:25:52 <Axman6> 'lo tectum
16:25:58 <tectum> anybody running GHC on Itanium?
16:26:56 <heatsink> Not for a while.
16:27:04 <heatsink> The last supported GHC was 6.4
16:27:25 <heatsink> There were some people from Uni Bayreuth doing parallel programming on Itanium with GHC
16:27:55 <heatsink> Did you want an Itanium GHC?
16:27:59 <dpratt71> I think for one brief shining moment I understand the definition of "ap"...
16:28:19 <copumpkin> dpratt71: we can try to explain it if you want :)
16:28:29 <copumpkin> lest the moment escape you
16:29:00 <dpratt71> copumpkin: maybe I should try to explain it and you tell me if I'm right
16:29:05 <copumpkin> sounds good
16:29:17 <dpratt71> @src ap
16:29:18 <lambdabot> ap = liftM2 id
16:29:24 <dpratt71> @src liftM2
16:29:24 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:29:25 <Axman6> dpratt71: all it does is take a monad with a function inside it (or many functions in the case of lists), and applies that function to another monad of the same type
16:29:44 <dpratt71> so f = id...
16:29:59 <Axman6> dpratt71: it could be written as: ap mf mx = do {f <- mf; x <- mx; return (f x)}
16:30:22 * Cale blows the abuse of terminology whistle
16:30:25 <copumpkin> lol
16:30:31 <dpratt71> which makes the type of id "(t1 -> t2) -> (t1 -t2)"
16:30:38 <copumpkin> I was tempted to
16:30:49 <Cale> (values whose type are m t where m is a monad are not called monads)
16:31:03 <copumpkin> the Monad is [] or Maybe
16:31:18 <copumpkin> (along with some methods)
16:31:34 <tectum> heatsink: yes, I would like one indeed
16:31:39 <dpratt71> which means that the type of m1 (from liftM2) is Monad(t1 -> t2)...
16:31:48 <tectum> heatsink: do you remember who in Bayreuth?
16:31:49 <dpratt71> ...oh crap...it's fading!
16:31:53 <copumpkin> oh noes!
16:31:58 <zygoloid> dpratt71: it was going so well... :)
16:32:01 <dpratt71> stand by...
16:32:01 <copumpkin> dpratt71: quick, do you understand fmap??
16:32:27 <dpratt71> ok, back on track I think...
16:32:28 <heatsink> tectum, Simon Melzner was involved, as a technician I think
16:32:44 <zygoloid> dpratt71: it means that f :: (t1 -> t2) -> t1 -> t2, so x1 :: t1 and x2 :: t2
16:32:49 <Axman6> dpratt71: does this definition of ap make sense to you? ap mf mx = do {f <- mf; x <- mx; return (f x)}
16:32:51 <copumpkin> dpratt71: ap is a bit like fmap, except cooler
16:32:56 <heatsink> tectum, If you can stand using old technology, GHC 6.4 should still work on Itanium.
16:33:05 <zygoloid> dpratt71: oops, x1 :: t1 -> t2, x2 :: t1
16:33:06 <dpratt71> basically, liftM2 is going to "unwrap" the monad and apply the function as the argument to id...
16:33:27 <dpratt71> ...which is going to turn back around and return the unwrapped function...
16:33:31 <tectum> heatsink: there is an IA64 debian package for 6.8.2 -- doesn't this imply that it has been supported more recently?
16:33:55 <heatsink> tectum, Huh.  Yeah, try that.
16:33:59 <dpratt71> ...and the last argument is going to be applied to the formerly Monad-wrapped function?
16:34:01 <osfameron> is there a shorthand for: groupBy (\a b -> fst a == fst b)
16:34:04 <osfameron> ?
16:34:09 <osfameron> like with sortBy (comparing fst) ?
16:34:16 <copumpkin> dpratt71: I think looking at ap through liftM2 id is a bad way about going about it, for what it's worth
16:34:22 <tectum> heatsink: I have the rather prosaic problem that my OS is SuSE
16:34:27 <zygoloid> dpratt71: yep. and because we're inside do notation, we get back a monad-wrapped value
16:34:32 <Cale> dpratt71: liftM2 f x y  will run x and then y, and then apply f to the results, returning that
16:34:38 <copumpkin> dpratt71: the liftM2 along with the do notation that expands to distracts you from the basic idea
16:34:46 <Axman6> dpratt71: ?
16:34:49 <heatsink> Hmm.
16:34:53 <zygoloid> @type ap
16:34:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:35:00 <dpratt71> ok
16:35:11 <Cale> "unwrap the monad" is an awkward way of thinking about it. Sure, if the action has type m t, then the result has type t
16:35:14 <zygoloid> ^^ i think meditating on the type of ap is probably at least as helpful as the definition
16:35:15 <heatsink> tectum, You can build an unregisterised compiler, but it may take a bit of hacking
16:35:24 <dpratt71> but semantically, I'm not too far off the mark?
16:35:32 <Cale> but yeah, you're not far off :)
16:35:44 <copumpkin> > ap [(+1), (*3)] [7, 8]
16:35:45 <dpratt71> ok, thanks all
16:35:46 <lambdabot>   [8,9,21,24]
16:35:48 <heatsink> tectum, The instructions for that are in the porting guide at http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
16:35:56 <Cale> The m t is typically something which you are running in order to produce a result of type t
16:36:08 <zygoloid> dpratt71: instead of thinking of do notation as 'unwrapping', it's more useful to think of it as threading together some monadic values
16:36:10 <Cale> (in the computation analogy)
16:36:25 <dpratt71> FYI, I wasn't really trying to understand ap, per se, just using it to understand more of Haskell
16:36:28 * copumpkin goes and writes a monad tutorial
16:36:31 <tectum> heatsink: thanks
16:36:40 <copumpkin> dpratt71: in that case, I'd start with Applicative and its version of ap, <*>
16:36:40 <Cale> liftM2 f x y = do v <- x; w <- y; return (f v w)
16:36:47 <copumpkin> dpratt71: it has less "noise" around it
16:37:00 <Cale> So that says: "Run x to get v, run y to get w, and return (f v w)"
16:37:13 <Axman6> dpratt71: does this make any sense to you? ap mf mx = do {f <- mf; x <- mx; return (f x)} it's probably the easiest way to understand ap
16:37:19 <copumpkin> lol
16:37:27 <dpratt71> well, I guess the kiddos aren't going to put themselves to be...be back later, hopefully
16:37:34 <copumpkin> :)
16:37:38 <Axman6> or you could just keep ignoring me, i don't care
16:37:39 <dpratt71> s/be/bed
16:37:52 <copumpkin> don't worry, we'll all still have our best ways of understanding it when you come back
16:38:07 * Axman6 goes off to have a shower
16:38:07 <BMeph> equating, not comparint. :)
16:38:07 <BMeph> Err, *comparing
16:38:58 * heatsink afks itself
16:43:00 <alexander> anyone know what this is?
16:43:02 <alexander> http://www.haskell.org/fitz/arch/arch.html
16:45:18 <fooman_> how would one turn an Integer in to a [Word8]?
16:45:31 <dons> is this guy being aggressive, or am I misreading, http://www.reddit.com/r/haskell/comments/9vilt/where_is_the_people_who_does_not_like_haskell/c0eo2ba
16:46:13 <copumpkin> he's being an ass
16:46:50 <dons> ok. i was just surprised at what i read as someone flying off the handle.
16:47:47 <ivanm> dons: yeah, I don't get that either...
16:48:16 <ivanm> he says their broken, but not how/why
16:48:48 <ivanm> *they're
16:49:11 <copumpkin> what annoys me more is that he says it's broken and then is trying to say that he doesn't want it fixed
16:49:21 <copumpkin> which is basically the definition of non-constructive criticism
16:49:21 <ivanm> copumpkin: yeah
16:49:49 <ivanm> so, is he saying cabal is broken, hackage is broken or indidividual packages are broken?
16:50:00 <ivanm> or, the most likely reason, he's being an ass like copumpkin said ;-)
16:50:01 <copumpkin> "it's broken"
16:50:10 <dons> ok. that was my reading. i didn't understand why he seemed so angy
16:50:11 <dons> angry
16:50:38 <dons> people who take the time to write that much stuff, but can't mail the maintainers, I find tiresome.
16:50:45 <Vanadium> fooman_: I assume you were looking for something more elegant than reverse . unfoldr (\n -> if n > 0 then Just (fromIntegral $ n `mod` 256, n `div` 256) else Nothing) ?
16:51:01 <ivanm> dons: sure you didn't mean "angsty"? :p
16:51:18 <fooman_> Vanadium: yeah, seems like it shouldn't take any work at all
16:51:20 <copumpkin> "let me have my opinions (complain about stuff being broken)! don't challenge my angst with pesky things called solutions"
16:51:33 <fooman_> all data is a [Word8]
16:51:40 <ivanm> dons: btw, I know you were at one point discussing giving a talk at ANU in the near future? is that still the case?
16:51:47 <ivanm> s/future?/future./
16:51:54 <Vanadium> fooman_: No, all data is an unpackedByteArray# or something :>
16:52:06 <Vanadium> fooman_: But who knows what the proper internal structure of the Integer is?
16:52:13 <Vanadium> Maybe it is stored as a [Word16]~
16:52:18 <dons> ivanm: not sure when i'll be back yet. january probably.
16:52:22 <copumpkin> GMP does, but you can't rely on it
16:52:26 <ivanm> ahhh, OK
16:52:35 <copumpkin> because as of 6.12, GMP isn't definite
16:52:49 <ivanm> dons: I was under the impression it was going to be in november; as such I was considering scheduling my house-hunting for when you were going to be there
16:53:00 <fooman_> Vanadium: hm, as long as it stays consistent, I don't really care. I just want a mapping between Integers and [Word8]s... actually I don't even care if it theoretically would change in a future version of GHC
16:53:06 <ivanm> copumpkin: I wouldn't say "definite"... "compulsory" maybe
16:53:09 <copumpkin> fooman_: then just repeatedly shift
16:53:23 <copumpkin> ivanm: it isn't something you can take for granted, I'll say :)
16:53:38 <ivanm> yeah
16:53:39 <BMeph> copumpkin: "I'M NOT FIGHTING YOU!! QUIT BEING SO DEFENSIVE!!" ;p
16:53:42 <dons> ivanm: yikes
16:53:49 <dons> don't plan you life around me being in .AU :)
16:53:55 <ivanm> dons: heh, I wasn't
16:54:23 <ivanm> but if you were going to be at ANU in november and I was going to be there looking for a place to live for next year, then it would be advantageous to hear you speak whilst you're there ;-)
16:54:51 <ivanm> and here comes another .AU person...
16:56:18 <alexander> dons: actually, giving non-constructive critisism was never asked for
16:56:27 <BMeph> Vanadium, fooman_: I prefer the "elegance" of the worker-wrapper version. :)
16:56:39 <alexander> *never not asked for*
16:57:10 <copumpkin> > reverse (unfoldr (\x -> guard (x /= 0) >> pure (fromIntegral (x .&. 0xFF), x `shiftR` 8)) (123456789 :: Integer)) :: [Word8]
16:57:12 <lambdabot>   [7,91,205,21]
16:57:17 <copumpkin> fooman_: ^
16:57:32 <Vanadium> Now you are just showing off :[
16:57:33 <binrapt> I am strongly influenced by C++ in the way I think of algorithms and how to process data. What's the "equivalent" of say, struct blah { long a; std::string b; float c; }; in Haskell? Would you use type blah = (Long, String, Float) or something like that?
16:57:34 <alexander> dons: and i don't think he's angry, he's just a bitter developer who honestly answered a question
16:57:44 <fooman_> copumpkin: nice
16:57:44 <dpratt71> Axman6: are you still in the shower?
16:57:52 <Axman6> just got out
16:57:54 <copumpkin> fooman_: the reverse is unnecessary too
16:57:58 <alexander> > "bitter" == "angry"
16:57:59 <lambdabot>   False
16:58:01 <dpratt71> Axman6: apologies
16:58:05 <ivanm> dpratt71: why, you wanted to join him? :p
16:58:12 <Vanadium> dons: As someone who is still very easily intimidated by hackage packages of any kind, my natural reaction is not so much "all right sending a patch" but "oh god what did i do wrong now oh no i broke it aaah"
16:58:13 <copumpkin> ivanm: don't project your desires onto other people
16:58:22 <Axman6> s'all right
16:58:23 <ivanm> @slap copumpkin
16:58:23 * lambdabot moulds copumpkin into a delicous cookie, and places it in her oven
16:58:29 <copumpkin> wow
16:58:36 <copumpkin> I've never seen that one before
16:58:41 <copumpkin> "her oven" sounds rude though
16:58:46 <dpratt71> your efforts to help me were drowned out by the overwhelming onslaught of help :)
16:58:46 <ivanm> yay! lambdabot finally listened to me! :p
16:58:49 <monochrom> I thought copumpkin was immune
16:59:11 <copumpkin> damn, he's found my achilles' stem
16:59:12 <dons> Vanadium: interesting!
16:59:59 <dpratt71> copumkin cookies!
17:00:03 <copumpkin> :)
17:00:50 <ivanm> Vanadium: how are you intimidated?
17:01:00 <dpratt71> would they have cochocolate chips in them, perhaps?
17:02:00 <Vanadium> ivanm: I easily assume that I underestimated the amount of effort required to properly use the package or that I misunderstood the documentation
17:02:17 <ivanm> Vanadium: :o
17:02:59 <copumpkin> dpratt71: indeed :(
17:04:12 <dpratt71> I was thinking that copumpkin might be an alias of pumpkin, but I see both are "in the room", so no?
17:04:26 <copumpkin> I just have two computers online right now :)
17:04:31 <dpratt71> ah
17:04:43 <copumpkin> my desktop is across the room and I'm being lazy on a bean bag with my laptop
17:04:55 <gOcOOl> given a list, what's a good way of partitioning it on alternating elements. for instance, given [1, 2, 3, 4, 5, 3] would return ([1, 3, 5][2, 4, 3])
17:05:00 <dpratt71> I was wondering if there was some Haskell/pumpkin connection I wasn't aware of...
17:05:01 <sjanssen> lrn2ssh
17:05:21 <copumpkin> gOcOOl: pair them up and take the transpose
17:05:29 <dpratt71> ...two pumkins in one room seemed like too much coincidence
17:05:32 <Vanadium> i bet the answer to that question involves the list monad in a v. scary way
17:05:52 <ivanm> gOcOOl: you want code, or a hand in working out what code to do?
17:06:12 <copumpkin> [1, 2, 3, 4, 5, 3] => [[1, 2], [3, 4], [5, 3]] => [[1, 3, 5], [2, 4, 3]]
17:06:34 <sproingie> damn that kid on reddit needs to take his ritalin
17:06:55 <sjanssen> that kid?
17:06:57 <gOcOOl> copumpkin: how do I pair them up?
17:06:59 <ivanm> sproingie: the "hackage packages" one?
17:07:03 <sproingie> i saw a broken package and SEND PATCHES HRRRARGH *throw stuff*
17:07:05 <monochrom> I think both of them, both, don't know when to stop.
17:07:10 <copumpkin> gOcOOl: write a quick function :)
17:07:18 <ivanm> sjanssen: http://www.reddit.com/r/haskell/comments/9vilt/where_is_the_people_who_does_not_like_haskell/c0eo2ba
17:07:27 <ivanm> gOcOOl: see splitAt
17:07:31 <ivanm> @hoogle splitAt
17:07:32 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
17:07:32 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
17:07:32 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
17:07:41 <ivanm> (or, if you only ever want pairs, then you can do it by hand)
17:07:50 <copumpkin> > unfoldr (\x -> guard (not . null $ x) >> pure (splitAt 2 x)) [1..6]
17:07:52 <lambdabot>   [[1,2],[3,4],[5,6]]
17:08:16 <copumpkin> > transpose . unfoldr (\x -> guard (not . null $ x) >> pure (splitAt 2 x)) $ [1..6]
17:08:18 <lambdabot>   [[1,3,5],[2,4,6]]
17:08:19 <sjanssen> dons is being kinda obtuse there.  Neither person is working to forward the conversation
17:08:31 <sproingie> i mean i actually see his frustration, i feel that way when i get told that about linux software.  but man, some folks are just angermonkeys
17:08:39 <ivanm> copumpkin: oooohhhh, never knew you could do it that way with guard...
17:08:42 <ivanm> @type guard
17:08:43 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:08:59 <copumpkin> :)
17:09:03 <sproingie> i think that "continue this thread" link is actually one of reddit's most genius features.  threads that go on that long are rarely worth following.
17:09:03 <ivanm> copumpkin: but if you're using monad notation, why use pure rather than return?
17:09:09 <copumpkin> it's shorter :P
17:09:13 <ivanm> heh
17:09:15 <copumpkin> and I don't like writing Just
17:09:19 <copumpkin> it feels ugly somehow
17:09:19 <monochrom> > take 6 (cycle ["broken", "send patches"])
17:09:21 <lambdabot>   ["broken","send patches","broken","send patches","broken","send patches"]
17:09:29 <sproingie> TheOneAndOnly = Just
17:09:34 <copumpkin> lol
17:09:44 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/OptimizationFuel.html
17:09:48 <copumpkin> some interesting module names in GHC
17:10:01 <Vanadium> "just" would be a better name than "pure"/"return", wouldn't it
17:10:03 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/OccurAnal.html *whistles*
17:10:29 <sproingie> i could say someone pulled that name out of their ass
17:10:31 <sproingie> i guess i just did
17:10:39 <dolio> copumpkin: If you want good modules names, you should check out the epigram repository.
17:10:53 <dolio> Glom, Higgledy, Piggledy.
17:10:53 <copumpkin> dolio: ooh
17:11:01 <copumpkin> epigram 1?
17:11:08 <copumpkin> oh yeah
17:11:12 <dolio> Well, 2 I think.
17:11:15 <copumpkin> like Parsley in SHE
17:11:17 <ivanm> dolio: of course, that makes for good documentation, readability and maintenance, doens't it ;-)
17:11:18 <osfameron> yay, dicewars probabilty sketch - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10974#a10974
17:11:41 <dolio> Actually, I'm not sure if it's 2 or not. It hasn't changed in a while.
17:11:54 <dolio> http:/www.e-pig.org/darcs/epigram, whatever that is.
17:11:55 <copumpkin> definitely seems to be conor's style :P
17:12:14 <copumpkin> Glom.lhs
17:12:18 <copumpkin> I definitely know what that does
17:12:31 <dolio> ivanm: Well, it's in the "Higgledy" directory, so I think it's random one-off experiments.
17:12:32 <copumpkin> what's even better is that there are no comments, but it's all literate style
17:12:50 <ivanm> dolio: hmmmm...
17:13:00 <ivanm> copumpkin: so wtf is the point of the literate style usage then?
17:13:00 <dolio> The actual src/ directory doesn't have such weird names.
17:13:10 <dolio> Except for "Idiomatica" which is in both directories.
17:13:19 <copumpkin> ivanm: it's higgledly glom, if you know what I mean
17:13:32 <ivanm> dolio: so does Idomatica do stuff idomatically, or is it for idiots? :p
17:13:37 <ivanm> copumpkin: no...
17:13:46 <copumpkin> read the comments on my language
17:13:51 <sproingie> no that's Idiotica
17:14:02 <ivanm> ahhh, right
17:14:18 <dolio> ivanm: Idiomatica has lots of Applicative related stuff, I think.
17:14:28 <dolio> Since "Idioms" are what they originally called them.
17:14:35 <ivanm> ahhh
17:14:53 <sproingie> Toronto Police Pipe Band "Idiomatica" - Bob Dunsire Bagpipe Forums
17:14:58 <sproingie> that was not what i expected
17:15:12 <Endial> So anyone here know how to program in Java?
17:15:27 <ivanm> Endial: unfortunately, yes... but it's not relevant to this channel
17:15:32 <ivanm> Endial: see ##java ...
17:15:40 <Endial> ahh thank you
17:15:46 <lispy> Endial: no, just choco ;)
17:15:57 <ivanm> lispy: mmmmmmmm.....
17:15:57 <dolio> This channel is only for discussing Eddie Haskell from Leave It to Beaver.
17:16:07 <copumpkin> lol
17:16:10 <dpratt71> dolio: heh :)
17:16:35 <ivanm> dolio: it is? you mean I've been talking about the wrong kind of haskell all these years and no-one has told me? :o
17:16:56 <dpratt71> I think the universe wants imperative programmers to find Haskell
17:17:07 <dolio> Well, we didn't want to make you feel awkward.
17:17:07 <copumpkin> must be
17:17:18 <ivanm> heh
17:18:11 <monochrom> We comment too much on other languages in this channel, that is why search engines direct everyone to here. In contrast, other language channels seldom bring up the names of their own languages; they go straight to discussion over their code.
17:18:38 <dpratt71> monochrom: makes sense
17:18:43 <copumpkin> other language channels engage mostly in bashing newbies who use incorrect words when describing their problems
17:19:17 <copumpkin> "surely you meant an if STATEMENT, not EXPRESSION. Now correct your question and if you're lucky, I may grace you with an answer"
17:19:18 <dpratt71> monochrom: although no thanks for making a rational argument that refutes my irrational one
17:19:42 <ivanm> monochrom: right, we need to stop discussing the coffee-language, the single-letter-language (and it's pseudo-successors the incremented-single-letter-language and single-letter-raised-by-a-semitone-langauge)
17:19:43 <ivanm> ;-)
17:19:55 <dpratt71> copumpkin: indeed, you folks are a friendly and patient bunch
17:19:57 <ivanm> copumpkin: "that's homework! we're not going to help you with that!"
17:20:03 <copumpkin> maybe I'll invent a C flat language
17:20:12 <ivanm> dpratt71: we are? damn, is that what we've been doing wrong all this time? :p
17:20:14 <copumpkin> or double flat
17:20:15 <ivanm> copumpkin: D flat!
17:20:21 <copumpkin> lol
17:20:25 <aavogt> B flat
17:20:25 <blackh> dpratt71: Until someone asks us a C question! :)
17:20:28 <monochrom> I bash people who use poor wording. Actually, I don't bash them, I troll them.
17:20:29 <Vanadium> ivanm: What about the speech-impediment-language
17:20:43 <copumpkin> lithp?
17:20:46 <ivanm> Vanadium: that's a family of languages
17:20:52 <dpratt71> I figure you all have given in to the fact that there will be no end of newbies asking questions
17:21:04 <monochrom> "Hi how do I convert number to string?" \_ -> "three"
17:21:05 <ivanm> then we have harrops version of single-letter-language-raised-by-a-semitone
17:21:09 <copumpkin> dpratt71: I usually enjoy it, cause they ask questions which I can then play with golfing
17:21:14 <ivanm> monochrom: heh
17:21:33 <dpratt71> copumpkin: :)
17:21:52 <ivanm> copumpkin: you latte-sipping golf fanatic...
17:22:02 <copumpkin> latte = milk
17:22:08 <copumpkin> and I gulp it
17:22:17 <dpratt71> it still surprises me: "oh, that 20-step imperative method...thats f. g . h"
17:22:22 <ivanm> eh, whatever
17:22:27 <ivanm> dpratt71: heh
17:24:24 <dpratt71> by the way, I've figured out why Haskell is such a challenge for "imperative" programmers such as myself...
17:24:37 <monochrom> pray tell!
17:24:40 <dpratt71> ...I thought it was the lack of side-effects...
17:24:52 <dpratt71> ...or maybe higher order functions...
17:24:58 <dpratt71> ...or Monads...
17:25:07 <monochrom> accelerate!
17:25:09 <dpratt71> ...not quite
17:25:19 <copumpkin> wait wait, the suspense is building up
17:25:27 <copumpkin> okay, I'm ready
17:25:36 <monochrom> should I play my own drumroll music?
17:25:49 <dpratt71> in imperative languages, you can't encapsulate pure code structure...
17:26:04 <lament> you can't?
17:26:05 <dpratt71> ...there are maybe 4 control-flow constructs...
17:26:50 <dpratt71> in Haskell, there's a whole slew of 'em
17:27:51 <monochrom> and user-definable. and without going macro or meta.
17:27:53 <Vanadium> every non-trivial project uses whole libraries full of additional ones >:|
17:27:56 <dpratt71> lament: I mean structure in the absence of actual functionality
17:28:52 <monochrom> control-flow structure/construct/thing/thygn/whatever
17:28:55 <dpratt71> I'm just not accustomed to one term implying what would be a whole control-flow construct
17:29:23 <dpratt71> (nevermind that there are so many)
17:29:40 <monochrom> forever (putStrLn "And He shall reign forever and ever")
17:30:08 <dpratt71> Haskell programmer's brains must look similar to those of London cabbies
17:30:35 <monochrom> How come?  Which aspect of those cabbies?
17:30:51 <copumpkin> knowing all the streets?
17:30:57 <dpratt71> copumpkin: right
17:31:14 <monochrom> Well, then, Hong Kong is even more demanding.
17:31:17 <tectum> perhaps more like a glasgow cabby
17:31:53 <dpratt71> monochrom: right, because it's hard to focus when you're trying not to die
17:32:16 <monochrom> Hong Kong cabbies have to know all the streets plus how to take inefficient routes in case of tourists to con more money.
17:32:24 <copumpkin> lol
17:32:27 <dpratt71> :)
17:33:09 <dpratt71> I think I could take a very ineffienct route without knowing any of the streets...but I digress
17:33:18 <dpratt71> *sigh*
17:33:25 <monochrom> But I guess that's the opposite of what Haskell people do. Haskell people golf, try to shorten not lengthen.
17:33:30 <dpratt71> inefficient!
17:34:06 <blackh> juNc24HU
17:34:19 <Gracenotes> hmmmm... the main problem with using maxBound as an infinity-esque value in dynamic programming problems is that infinity + x != infinity. >_> duh
17:35:15 <copumpkin> blackh: meow
17:35:34 <copumpkin> Gracenotes: just augment your values with a Maybe
17:35:44 <copumpkin> and write a Num a => Num (Maybe a) instance
17:35:46 <copumpkin> or Ord
17:35:58 <copumpkin> up to you whether it's a positive or negative infinity :P
17:36:07 <Gracenotes> > minimum [Just 4, Nothing, Just 3]
17:36:08 <lambdabot>   Nothing
17:36:21 <Gracenotes> :/
17:36:29 <monochrom> > maximum [Just 4, Nothing, Just 3]
17:36:30 <lambdabot>   Just 4
17:36:48 <monochrom> well then, Nothing is -oo
17:36:51 <Gracenotes> probably better just to have a specialized "add" function that checks if a particular argument (that may be 'infinity') really is that
17:37:14 <Gracenotes> Either Integer () would cover it. but yeah, special add is special.
17:37:14 <monochrom> Ah, special add is a pretty clean way
17:37:31 <Gracenotes> it makes a magic value, but eh, infinity is a magic value
17:37:57 <Gracenotes> the special add that is
17:39:31 <Gracenotes> but yeah, I was wondering why -2147480274, -2147483306, and -2147483648 were so optimal
17:55:49 <catch[`]> How can I write something in GHCi that spans multiple lines?
17:56:03 <heatsink> catch[`], use braces
17:56:14 <heatsink> Hmm, actually that doesnt work, nevermind
17:56:29 <heatsink> I don't know
17:56:50 <catch[`]> :(
17:56:56 <heatsink> You can cram it all onto one line with braces, though.
17:57:05 <catch[`]> duly noted
17:57:40 <aavogt> I'm pretty sure there is a way to do it, but if you have to write that much, it is probably better to start a file
17:58:00 <monochrom> don't span multiple lines
17:58:22 <catch[`]> monochrom: what a creative solution!
17:59:35 <heatsink> catch[`]: your code is too long.
17:59:37 <monochrom> haha, I mean the same as what they said, write like let { x=1; y=2 } in x+y
18:00:23 <catch[`]> heatsink: ...thanks for the completely useless advice? lol
18:00:34 <catch[`]> There are just some examples I want to try that span multiple lines
18:01:49 <aavogt> catch[`]: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
18:01:58 <aavogt> apparently you can start a block with :{
18:02:11 <aavogt> and it ends with :}
18:02:16 <BMeph> catch[`]: UR DOIN IT RONG! -- Bacause someone had to say it... ;p
18:02:29 <BMeph> *Because
18:02:41 <ivanm> BMeph: well, people implied it...
18:02:49 <aavogt> hmm, but it doesn't accept layout rule, so that kind of sucks
18:02:57 <aavogt> > it
18:02:58 <lambdabot>   Not in scope: `it'
18:03:04 <monochrom> Oh god, that :{ :} is awful.
18:03:47 * BMeph is reminded of Kirby for some reason...
18:04:22 <catch[`]> thanks for the actual help now - got what I was looking for between aavogt and heatsink :)
18:04:30 <Nafai> -server
18:04:30 <Nafai> -XX:+DoEscapeAnalysis
18:04:37 <Nafai> Sorry
18:04:42 <Nafai> Wrong window focused
18:05:10 <ivanm> Nafai: you want to analyse escapes from your server? :p
18:06:01 <ivanm> I got that
18:06:57 <c_wraith> Nafai:  Playing with java 7?
18:07:17 <Nafai> c_wraith: Nope, Scala and those were recommended settings for Eclipse for their plug-in
18:07:39 <alexander> @pl \f a b c d e -> f a b a d e d e
18:07:41 <lambdabot> ((const .) .) . flip flip id . ((flip . ((flip . (ap .)) .)) .) . flip flip id . ((flip . (liftM2 flip .)) .) . (flip =<<)
18:07:49 <alexander> coooooooooooool
18:07:50 <c_wraith> Ah.  I remember seeing that the JVM has had escape analysis added in recent preview builds of 7.
18:08:17 <c_wraith> wait.  (flip =<<)?
18:08:22 <Axman6> heh
18:08:45 <Saizan> ?type (flip =<<)
18:08:46 <c_wraith> Oh.  It's not flip (=<<)
18:08:46 <lambdabot> forall a b c. (b -> a -> b -> c) -> b -> a -> c
18:11:11 <Axman6> @unpl (flip =<<)
18:11:11 <lambdabot> (\ d -> d >>= \ a b c -> a c b)
18:12:13 <Kruppe> I know there has to be a less awkward way of doing this: do {seed <- randomIO; seedInt <- return (seed :: Int); functionThatUsesStdGen (mkStdGen seedInt)}     but I'm too noob to know. Can anyone help me out?
18:12:29 <Kruppe> basically i want a StdGen made from a random number
18:12:38 <ivanm> Kruppe: you have no need to do the seedInt <- return
18:12:49 <ivanm> @type randomIO
18:12:50 <lambdabot> forall a. (Random a) => IO a
18:13:04 <ivanm> @type mkStdGen
18:13:04 <lambdabot> Int -> StdGen
18:13:07 <ivanm> Kruppe: the types will force seed to be an Int
18:13:10 <Kruppe> ivanm: hmm, I think maybe i screwed something up there then
18:13:14 <ivanm> Kruppe: however, why not use newStdGen ?
18:13:18 <ivanm> @type newStdGen
18:13:19 <lambdabot> IO StdGen
18:13:35 <ivanm> Kruppe: ^^ better than trying to get a random Int and make a new stdGen from it
18:13:49 <ivanm> so it'll just be newStdGen >>= functionThatUsesStdGen
18:13:55 <ivanm> do-less! :D
18:13:59 <Kruppe> ah nice
18:14:04 <Kruppe> less boilerplate
18:14:09 <Kruppe> i like
18:14:10 <ivanm> zigackly!
18:14:38 <Kruppe> so that does the exact same thing i was doing yes?
18:14:43 <monochrom> Kruppe added seedInt to enforce a certain type
18:14:57 <ivanm> monochrom: yes, but it isn't needed
18:15:01 <ivanm> Kruppe: yes
18:15:10 <monochrom> Oh nevermind, mkStdGen enforces it.
18:15:24 <Kruppe> monochrom: yeah thats why i did it, but i guess i dont actually need it
18:15:29 <ivanm> monochrom: do keep up ;-)
18:15:31 <Kruppe> monochrom: which is good
18:15:37 <Kruppe> monochrom: cause that code was bothering me
18:15:42 <Kruppe> monochrom: so gross
18:16:17 <ivanm> Kruppe: of course, you can improve it by using mersenne-random{,-pure64} or the PRNG from statistitcs ...
18:16:25 <ivanm> (improve efficiency-wise, I mean)
18:17:05 <Kruppe> this some haskell library i can get my hands on or something?
18:17:05 <dpratt71> how hard would it be to setup one's own personal lambdabot?
18:17:11 <ivanm> all three are haskell libraries on hackage
18:17:33 <ivanm> dpratt71: you can do it; you just need to install it as a user (if you want to run it as a user)
18:17:34 <ivanm> because it needs to be able to modify some of its files, IIRC
18:17:44 <Kruppe> ivanm: nice, ill check them out. I'm making a genetic algorithm so speed would be nice
18:17:58 <ivanm> Kruppe: there's a GA package or two on hackage as well IIRC
18:18:16 <Kruppe> ivanm: its how im learning haskell though lol, so i want to do as much of it by myself as possible
18:18:32 <ivanm> fair enough ;-)
18:18:41 <dpratt71> ivanm: ok; can it work as a console-prompt sort of thing? i.e. no IRC
18:18:55 <ivanm> Kruppe: note that whilst the two mersenne packages at least support the Random class from System.Random, they're not recommended
18:19:09 <ivanm> (using them that way can make your code even slower than StdGen :s)
18:19:14 <ivanm> dpratt71: yes
18:19:28 <ivanm> dpratt71: there was also rudimentary support for integrating lambdabot into ghci, but AFAIK that's dead
18:19:37 <Kruppe> ivanm: i see, ill be wary
18:20:00 <dpratt71> ivanm: I see; I'll investigate further
18:20:17 <ivanm> @where goa
18:20:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
18:20:19 <Kruppe> im still shocked how easy quick sort is to make in haskell
18:20:23 <Kruppe> no thinking involved
18:20:24 <ivanm> dpratt71: ^^ that's what I'm talking about
18:20:31 <ivanm> Kruppe: it's not the real QS though... >_>
18:20:38 <ivanm> (which haskell-haters keep pointing out)
18:20:44 <lpjhjdh> so I'm getting a multiply defined symbol error while processing: /usr/lib/ghc-6.10.4/bytestring-0.9.1.4/HSbytestring-0.9.1.4.o
18:20:53 <Kruppe> ivanm: ehhh still works decent though
18:20:55 <ivanm> lpjhjdh: do you have bytestring 0.9.1.5 installed?
18:20:56 <lpjhjdh> anyone know where this is coming from or how I should attempt to fix it?
18:21:00 <lpjhjdh> ivanm: yeah
18:21:18 <ivanm> lpjhjdh: there's your problem: some packages are using 0.9.1.4 still from GHC; others are using the new 0.9.1.5
18:21:23 <tommd> lpjhjdh: Did you build with --make?
18:21:27 <tommd> That is the typical problem.
18:21:29 <ivanm> and the package with the error is trying to use libraries that use both
18:21:36 <lpjhjdh> ivanm: ah, thanks
18:22:12 <ivanm> (this is why I'm about to go and completely wipe out the stand-alone bytestring package from the gentoo-haskell overlay; it took me long enough to get 0.9.1.5 completely working)
18:22:13 <lpjhjdh> tommd: nah, I'm using -hide-all-packages -package xxx ... with ghci
18:22:18 <tommd> oh, misread - please continue ignoring me.
18:22:18 <ivanm> lpjhjdh: I suggest you nuke 0.9.1.5
18:22:41 <ivanm> Cabal is realistically the only package that gets shipped with GHC that you should upgrade
18:22:51 <tommd> Or you could just unregister it - thats more environmentally friendly.
18:23:02 <ivanm> tommd: that's equivalent to nuking it
18:23:11 <ivanm> by nuke, I mean uninstall
18:24:08 <lpjhjdh> ivanm: i'll try that, thanks
18:24:54 <lpjhjdh> ivanm: hmm, seems that would break several packages :(
18:25:12 <ivanm> lpjhjdh: rebuild them
18:25:23 <lpjhjdh> ah, thanks
18:25:25 <ivanm> lpjhjdh: it's either that, or you find every package that depends on 0.9.1.4 and rebuild them
18:33:15 <lpjhjdh> ivanm: that did the trick, thanks
18:45:41 <Axman6> ChilliX: you around?
18:47:43 <tectum> cross-compiling ghc for IA64 is giving me headaches... is there a way of using the 6.8.2 debian package for IA64 on SuSE without root access?
18:50:22 <heatsink> tectum, You can try to unpack the files from the package and install them in the appropriate paths.
18:50:26 <heatsink> However,  I don't know if that's really the best approach
18:50:51 <heatsink> Because the files will depend on other files being in the right places based on where Debian puts them
18:51:07 <heatsink> And it'll probably be difficult figuring out what those are.
18:52:00 <heatsink> I cross compiled ghc for ia64 a long time ago, I might be able to help if you're having a problem.
19:10:01 <kyagrd> I'm using the GHC API for the first time.  It's not the most well documented API but able to do some work ... but using unsafeCoerece every time I have HValue is sad
19:11:10 <kyagrd> If only there were a way to do typeOf for polymorphic, or overloaded values I wouldn't have to use GHC API :(
19:12:48 <lpjhjdh> kyagrd: what about the polytypeable package?
19:12:48 <dolio> Oleg has a way to do typeOf for Hindley-Milner polymorphic types, but it's evil.
19:13:50 <kyagrd> dolio: that only works for certain level, and oleg's posting is for only level 1
19:14:35 <copumpkin> ooh Oleg and evil
19:14:44 <aavogt> kyagrd: so you're not trying to do something like `runInterpreter (setImports ["Prelude"] >> typeOf "(1 Prelude.+)")' == Right "(Num a) => a -> a"
19:15:10 <aavogt> (this is using Language.Haskell.Interpreter)
19:15:39 <codm`> I need a class that's like a Monoid, but also has a null predicate to test whether something is mempty or not.  I could just require Eq and Monoid, but I'm wondering if there's anything with a closer fit in standard libraries.
19:15:47 <aavogt> oh, you want typeOf like from Typeable..
19:15:50 <kyagrd> aavogt: I need to automate quickcheck on polymophic or overloaded properties
19:16:11 <kyagrd> not for all type instances but for specific closed world of types
19:17:13 <kyagrd> Say I have list of types of my iterest Bool, Int, Double and I want to automate quickcheck to run \x -> x==x on all those three instances
19:17:44 <kyagrd> and \ x -> x+x == 2 on only two of the instances Int and Double but not Bool
19:19:09 <dons> sjanssen: re. obtuse, i agree, i strongly argue that it is not acceptable to complain + refuse to contribute.
19:19:40 <tectum> heatsink: just saw your message. thanks, I might ask you at some point
19:20:27 <heatsink> tectum, Alright.  I'm leaving in a few minutes (it's late) but I'll be around tomorrow.
19:20:32 <kyagrd> lpjhjdh: ah, I think polytypeable can save me some work, although it doesn't handle overloaded types but seems good enough for my purpose
19:20:44 <kyagrd> lpjhjdh: thanks
19:21:40 <lpjhjdh> kyagrd: no problem, I was just looking around for a similar tool the other day to do some subtyping stuff over polymorphic sums
19:24:00 <kyagrd> lpjhjdh: so if you have used polytypable the a1, a2 those variables are just TyCons but with a strange name starting with lowercase?
19:26:53 <dancor> should i make a type for lists-that-must-contain-at-least-one-element
19:26:55 <SmurfOR> is there any way to get a string representation of a type that i can use later?
19:27:10 <kyagrd> lpjhjdh: yes it is I just looked up the source
19:27:29 <dancor> i kind of wish List was a typeclass i could define for my type
19:28:26 <jystic> is it possible to use cabal through a proxy with a username/password?
19:28:32 <kyagrd> dancor: Well you can define it a type class version of it but then the problem is you don't have pattern matching
19:29:11 <dancor> mm
19:29:22 <aavogt> view-patterns though
19:29:31 <Saizan> jystic: yes, you've to set an environment variable, let me see if i can find its name
19:30:05 <jystic> thanks
19:32:22 <Saizan> jystic: HTTP_PROXY
19:32:39 <repnop> hello everyone
19:32:42 <jystic> Saizan: awesome, thanks! I guess this works even on windows?
19:33:39 <Saizan> jystic: yes
19:33:59 <jystic> Saizan: perfect, thanks I'll give it a try when I get to work :)
19:34:28 <Saizan> jystic: on windows it should also try to take the proxy from the registry, the one you set with "internet settings"
19:34:59 <kyagrd> Oh great polytypeable + template-haskell might work ... has there been a package that translates TypeRep into the template haskell Type or TypeQ?
19:35:15 <Saizan> the code is in Distribution.Client.HttpUtils btw
19:35:29 <jystic> Saizan: yeah it looked like it was trying but failing, because you can't tell windows anywhere what the username and password for the proxy is. Being able to set an environment variable should do the trick
19:35:47 <bfrog> can haskell be used like erlang in terms of the networking aspects?
19:36:10 <Axman6> it can be used as an erlang node if you like
19:36:18 <Axman6> @hoogle erlang
19:36:19 <lambdabot> No results found
19:36:25 <Axman6> @hackage erlang
19:36:25 <lambdabot> http://hackage.haskell.org/package/erlang
19:36:26 <Axman6> even
19:37:03 <SamB_XP> does that allow for non-disruptive reloading ?
19:37:12 <Axman6> i doubt it
19:37:13 <Saizan> there isn't that strong built-in support for distribution that erlang has, but there are libraries in that area
19:37:28 <bfrog> yeah, I mean hot loading was one of the really nice features
19:37:28 <SamB_XP> so ... wouldn't it make more sense to just use erlang ?
19:37:37 <bfrog> probably :-)
19:37:43 <bfrog> I was mostly just curious
19:37:56 <SamB_XP> of course, the completely weak typing is a bit of a downer ...
19:38:00 <dons> bfrog: " in terms of the networking aspects"
19:38:08 <dons> as in , massively concurrent networking? definitely.
19:38:17 <dons> haskell's significantly faster than erlang, which helps.
19:38:24 <SamB_XP> dons: the what now ?
19:38:31 <dons> it doesn't do cross-machine distribution though, if you're running on a cluster.
19:38:38 <SamB_XP> apparantly whatever it is doesn't matter to much for telecoms ...
19:39:59 <dons> you can be a bit more aggressive with the optimization of haskell too.
19:40:17 <repnop> i have a simple question regarding loading a large static dataset
19:40:27 <dons> great!
19:40:40 <dons> what is the question?
19:41:10 <repnop> i have a static data set of 54 million records (double, unsigned char) could i output it into a single file and compile it then just reference it rather than deal with loading from a file?
19:41:23 <dons> yes.
19:41:24 <repnop> memory isn't really an issue
19:41:26 <repnop> nice :)
19:41:37 <dons> it will appear as a Ptr Word8 or some such
19:41:46 <dons> so you can access it as if it was a C array, via the Foreign.* modules
19:42:12 <dons> i've some examples of static data here, http://code.haskell.org/~dons/code/compiled-constants/
19:42:23 <repnop> thanks dons :)
19:42:35 <repnop> be more interesting to learn haskell with a real dataset
19:43:02 <dons> that example shows how to load a Map String Int, iirc, as a C array
19:43:09 <dons> your example should be easier.
19:46:42 <tectum> if ghc is needed to build ghc how can a debian package exist for ghc?
19:46:59 <repnop> bootstrap?
19:47:07 <Saizan> magic fairies
19:47:26 <monochrom> Many versions ago it was bootstrapped from C.
19:47:26 <ivanm> tectum: someone gets a version of ghc (e.g. the generic linux binary) and uses it to bootstrap the ghc sources
19:47:28 <tectum> doesn't bootstrapping require generating .hc files on another machine that has ghc?
19:47:35 <BMeph> Magic boot-wearing fairies? ;)
19:47:44 <ivanm> monochrom: 6.2 or something was the last release with C sources, wasn't it?
19:47:57 <ivanm> tectum: use an older/pre-built ghc
19:48:25 <monochrom> Now it could still be bootstrapped in principle but no one bothers to make it easy. Unnecessary.
19:48:32 <BMeph> Did anything ever come of using LLVM as a GHC backend?
19:48:58 * BMeph decides to ask that in #ghc, where it's slightly more "relevant"...
19:49:03 <tectum> might starting off with 6.2 be a good porting strategy?
19:50:15 <Saizan> i don't think so, i think you can make the .hc route work for 6.8.x or maybe even later versions
19:51:38 <Saizan> checked the wiki?
19:52:22 <tectum> yeah
20:08:09 <kyagrd> k
20:34:19 <gio123> hi all
20:34:39 <gio123> Cale: hi
20:35:12 <ChilliX> Axman6: just on the jump, but bbl
20:52:40 <tomoj> my haskell-fu is very weak. http://gist.github.com/214859
20:52:53 <tomoj> I get an error that the last statement in a 'do' construct must be an expression
20:53:00 <tomoj> but.. isn't let .. in .. an expression?
20:53:56 <idnar> hmm, maybe the in needs to be indented?
20:54:12 <inimino> tomoj: it's a layout problem, you can't have the in outdented that far
20:54:33 <tomoj> oh, I see
20:54:36 <tomoj> thanks
20:54:56 <tomoj> huh, haskell-mode won't indent it any other way
20:55:33 <johnthexiii> Can anyone point me towards a good socket tutorial for Haskell
20:55:59 <tomoj> am I doing something weird to confused haskell-mode?
20:56:39 <sw17ch> johnthexiii, what sorts of things are you trying to do?
20:56:41 <c_wraith> johnthexiii:  how technical is what you want to do?
20:57:01 <sw17ch> i don't have a tutorial.. .but i might be able to answer some questions
20:57:18 <c_wraith> johnthexiii:  If all you want is to open a socket and send some bytes (in blocking mode), the the docs for Network are good enough.
20:57:40 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
20:59:00 <johnthexiii> Umm nothing complicated maybe a small chat program, just something to start learning with.
20:59:30 <sw17ch> johnthexiii, i have an example for you then...
20:59:51 <sw17ch> johnthexiii, http://gist.github.com/178673
20:59:55 <sw17ch> a small UDP chat client
21:00:18 <sw17ch> runhaskell chat.hs [remote host] [remote port]
21:00:46 <sw17ch> it shouldn't be that hard to look at the Network.Socket docs and convert it to TCP
21:01:35 <johnthexiii> sw17ch thanks that is exactly what I was looking for.
21:01:37 <copumpkin> withSocketsDo is a rather ugly name
21:02:07 <copumpkin> why not just withSockets ?
21:02:41 <sw17ch> copumpkin, withSocketsDo is needed by windows :(
21:02:51 <copumpkin> oh, I understand why it's necessary
21:02:55 <copumpkin> but the name bothers me :P
21:02:59 <sw17ch> yeah...
21:03:08 <sw17ch> i agree :)
21:03:09 <johnthexiii> Also thanks to c_wraith that was useful info.
21:03:23 <sw17ch> johnthexiii, anything else?
21:03:38 <c_wraith> You're welcome.
21:03:47 <johnthexiii> Nope that will do for now. Thanks for asking.
21:04:55 <sw17ch> johnthexiii, :)
21:13:20 <binrapt> How small can you make Haskell binaries on Linux?
21:13:31 <copumpkin> strip makes them a bit smaller
21:13:34 <binrapt> Windows binaries are usually at at least 520-660 KiB it seems
21:13:36 <copumpkin> you can use 6.12 and dynamic linking
21:13:48 <binrapt> What size can you reduce a "hello world" one to?
21:14:10 <copumpkin> beats me
21:14:11 <alexander> @seen oleg
21:14:12 <lambdabot> Unknown command, try @list
21:14:17 <lament> @quote oleg
21:14:18 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:14:57 <sw17ch> has any one seen the error: "Attempted to get declarator of builtin entity!" from c2hs?
21:16:45 <binrapt> -rwxr-xr-x  1 void void 641508 2009-10-21 06:14 a.out
21:16:49 <binrapt> Similar size, curious
21:16:55 <alexander> haha
21:17:01 <alexander> uid: void
21:17:01 <binrapt> -rwxr-xr-x  1 void void 441288 2009-10-21 06:14 a.out
21:17:07 <binrapt> How is that funny
21:17:10 <binrapt> That's stripped
21:17:28 <alexander> binrapt: whut? stripped?
21:17:34 <alexander> i thought that was your username
21:17:58 <binrapt> Among others, sure
21:18:07 <binrapt> What's so funny about it? I don't get it
21:18:40 <SubStack> is it legit to define an instance for another module outside of that module lacking the instance in libraries which may be used elsewhere?
21:18:50 <alexander> it's like that story in the oddyse, with the giant and "no one"
21:19:01 <alexander> (or however it was translated)
21:19:43 <SubStack> read "legit" as "good practice" or what-have-you
21:20:09 <alexander> S
21:20:22 <aavogt> SubStack: well they aren't called orphan instances for nothing, right?
21:20:41 <aavogt> you wouldn't want to be creating orphans, would you?
21:20:52 <SubStack> I would not. Unless I would.
21:20:55 <alexander> SubStack: lik this? "data D ... f :: D -> a..." <- Mod, and then having maybe a module Mod.Monad?
21:21:05 <sproingie> orphans are the tenderest and yummiest
21:21:15 <SubStack> anyways, I can side-step this with a bit of kludge, so I'll just do that instead
21:21:47 <SubStack> it's only a tiny bit of kludge
21:23:02 <Saizan> SubStack: in an program do as you wish, in a library it'ss better to use a newtype
21:23:04 <jystic2> i'm trying to do a "cabal update" from behind a http proxy on windows but i'm getting a error relating to hGetBufNonBlocking. Has anyone encountered this before?
21:23:34 <SubStack> I rather figured as much.
21:23:54 <jystic2> i've found online that there seems to be a problem with hGetBufNonBlocking on windows, but nothing really relating to cabal specifically
21:23:55 <SubStack> good to have these other opinions on the matter though!
21:24:57 <Saizan> jystic2: you could try looking in the bugtracker
21:25:57 <sw17ch> dangit, i hate vararg functions in C...
21:27:33 <jystic2> Saizan: is that this one http://hackage.haskell.org/trac/hackage/ ?
21:27:57 <Saizan> jystic2: yes
21:29:11 <Rotaerk> sw17ch, pfft, they've got beautiful syntax
21:29:13 <Rotaerk> *cough*
21:29:24 <sw17ch> hah
21:29:45 * sw17ch wonders if he can make the va_list an instance of storable...
21:29:51 <jystic2> hmm there doesn't seem to be any matches for hGetBufNonBlocking, i'll keep looking
21:31:35 * sw17ch gives up for tonight
21:37:13 <Eduard_Munteanu> Hi. How complete is Fruit? I'd like to use it to make a simple app interfacing a database.
21:40:53 <copumpkin> anyone know of any zeroconf (or other discovery protocols) implementations on hackage?
21:41:28 <colton_> Is there some way to develop qt applications using haskell?
21:41:51 <binrapt> I'd imagine it's difficult if nobody bothered to write an interface for it so far
21:42:10 <ivanm> copumpkin: apart from the ones you're going to write? :p
21:42:15 <copumpkin> ivanm: yep
21:42:16 <ivanm> colton_: there was qthaskell...
21:42:21 <ivanm> dunno if it's still alive though :s
21:44:36 <gwern> ivanm: well, qthaskell is maintained still, I think
21:44:52 <Eduard_Munteanu> There's wxHaskell as well, but it's not, ahem, functional.
21:45:13 <ivanm> gwern: :o
21:45:26 <ivanm> Eduard_Munteanu: "working functional" or "programming functional"?
21:45:29 * ivanm presumes the former...
21:45:35 <gwern> ivanm: both, his jest goes
21:45:40 <ivanm> ahhh
21:45:45 <gwern> wxhaskell has issues, though it's still reasonably useful
21:45:46 <Eduard_Munteanu> ivanm, programming functional.
21:45:51 * Cale purposefully submits questions to the Wolfram Alpha Homework Day site that he knows Mathematica falls down on.
21:45:59 <ivanm> Cale: heh
21:46:01 <ivanm> what site is this?
21:46:09 <Cale> "Plot the set of points such that |1 - x^2 - y^2| = 1 - x^2 - y^2"
21:46:27 <Cale> http://homeworkday.wolframalpha.com/
21:46:29 <Eduard_Munteanu> I didn't use wxHaskell yet though, I'm still researching alternatives like Fruit.
21:46:38 <copumpkin> ugh, why does network use strings?
21:46:50 <Eduard_Munteanu> so it could very well be "working functional"
21:46:53 <ivanm> Cale: how does it fall down on it?
21:47:05 <gwern> copumpkin: what else would it use?
21:47:12 <copumpkin> gwern: a ByteString?
21:47:12 <Saizan> copumpkin: legacy!
21:47:21 <gwern> stringlike? lazy bs? strict bs? lazy char8 bs? strict char8 bs?
21:47:22 <copumpkin> Saizan: the word I hate the most! :P
21:47:25 <gwern> utf-string?
21:47:29 <Saizan> copumpkin: i think there are alternatives on hackage
21:47:37 <Cale> ivanm: Well, Alpha just displays nothing at all when asked to plot that.
21:47:40 <copumpkin> gwern: regular strict ByteString
21:47:41 <ivanm> heh
21:47:46 <ivanm> Cale: keep up the good work! :p
21:47:55 <ivanm> Cale: did you read about the iphone app for alpha?
21:47:58 <Cale> ivanm: Mathematica's ContourPlot gives a jagged broken outline of a circle
21:48:07 <Saizan> gwern: the char8 ones are the same as the others. also network in not even near the level of worrying about encodings, afaict
21:48:15 <gwern> Eduard_Munteanu: incidentally, be wary what GUI lib you pick. everyone lies.
21:48:22 <Cale> The actual solution is the closed unit disc.
21:48:28 <ivanm> gwern: is that a lie? :p
21:48:37 <gwern> ivanm: it would be, if I were a person
21:48:56 <ivanm> gwern: you didn't say "all people lie" or somesuch; you said "everyone lies"
21:49:19 <gwern> ivanm: and what is an everyone?
21:49:23 <ivanm> ssshhhh!
21:49:25 <gwern> can a non-person speak?
21:49:38 <ivanm> gwern: computers aren't people...
21:49:41 <gwern> 'a dog may shake your hand, but only a human can give you assurance'
21:50:44 <gwern> ('"I don't speak," Bijaz said. "I operate a machine called language. It creaks and groans, but is mine own."')
21:52:05 <SubStack> Is there a way to make a module on disk take precedence over the one registered with ghc-pkg without messing with ghc-pkg?
21:52:16 <SubStack> basically I think I want to cons onto the include path instead of appending to it
21:52:43 <ivanm> SubStack: give it a different name? *shrug*
21:53:24 <ivanm> otherwise, you'd have to use {-# #-} statements (IIRC, someone asked something about mtl vs transformers on -cafe, and that was one of the responses rather than hiding/unregistering in ghc-pkg)
21:53:41 <Saizan> SubStack: modules in the source tree do take precedence over installed ones by default.
21:54:49 <hiredman> huh
21:55:10 <SubStack> looking for this message
21:55:52 <Saizan> i.e. if you have a Control/Monad.hs it'll take precedence over the one in base
21:56:24 <SubStack> that's pretty much what i want
21:56:32 <SubStack> I think
21:56:47 <SubStack> I found the thread anyways, reading up
21:57:08 <Saizan> the thread is about a different thing if ivanm's description is accurate.
21:57:30 <ivanm> Saizan: yeah, it is
21:57:41 <ivanm> but I wasn't sure if on-disk definitely overrode a library
21:57:54 <ivanm> and there was a pragma to tell ghc to hide a particular library or something IIRC
21:58:19 <Saizan> what i'm saying is that it should just work, if it doesn't we need more details :)
21:58:30 <SubStack> -XPackageImports looks like the thing
22:02:26 <copumpkin> hmm, if I were to write a network-based Chan-alike, should it be bidirectional?
22:03:25 <SubStack> oh wow actually it was doing what I wanted it to do by default, there was just some other error >_<
22:11:45 <SubStack> it works \o/
22:14:14 <Saizan> yay.
22:15:27 <SubStack> my fork of Network.OpenID, that is
22:15:36 <SubStack> which adds Network.OpenID.Easy
22:40:36 <largos> I just wrapped up a CLI for hpaste, if anyone is interested :)
22:40:37 <largos> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10990
22:42:08 <copumpkin> :t encode
22:42:09 <lambdabot> Not in scope: `encode'
22:47:37 <ivanm> @hoogle encode
22:47:37 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
22:47:38 <lambdabot> Network.CGI formEncode :: [(String, String)] -> String
22:47:38 <lambdabot> Network.CGI.Protocol formEncode :: [(String, String)] -> String
22:48:34 * copumpkin goes to sleep
22:55:00 <kyagrd> hmm, why is hackage upload so slow?
22:55:33 <hackagebot> polytypeable-utils 0.1.0.0 - Utilities for polytypeable. (KiYungAhn)
22:55:38 <kyagrd> yeah
22:56:20 <kyagrd> @hackage polytypable-utils
22:56:21 <lambdabot> http://hackage.haskell.org/package/polytypable-utils
22:59:10 <largos> hmm.. does hackage accept apache 2-licensed code?
23:00:33 <ivanm> largos: not as a default
23:00:53 <ivanm> largos: you can put it as OtherLicense in the .cabal file and then specify apache2 as the license in your license file
23:01:38 <largos> ah, ok
23:01:38 <ivanm> largos: or write Apache2 and require Cabal-1.6 or greater; it won't understand it (and thus complain), but will categorise it as `UnknownLicense "Apache2"' (or however you specify it)
23:01:48 <ivanm> using OtherLicense is probably preferred though
23:01:56 <ivanm> AFAIK, hackage will accept any license
23:02:04 <ivanm> except for AllRightsReserved, methinks...
23:05:47 <kyagrd> Oh, the apache alias is broken
23:06:02 <kyagrd> the lambdabot's
23:06:09 <kyagrd> @hackage polytable-utils
23:06:09 <lambdabot> http://hackage.haskell.org/package/polytable-utils
23:06:30 <kyagrd> when did this start not to work?
23:06:46 <kyagrd> The longer version works http://hackage.haskell.org/cgi-bin/hackage-scripts/package/polytypeable-utils
23:08:07 <ivanm> kyagrd: ummm... it should work...
23:08:18 <ivanm> kyagrd: you have different words there!
23:08:27 <ivanm> polytable-utils vs polytypeable-utils !
23:08:28 <kyagrd> Ah my bads
23:08:46 <kyagrd> I thought lambdabot checks it before giving out the link
23:09:05 <kyagrd> @hackage polytypeable-utils
23:09:06 <lambdabot> http://hackage.haskell.org/package/polytypeable-utils
23:09:53 <kyagrd> So, @hackage is implemted as just  \str -> (++str) ?
23:10:25 <kyagrd> I mean \str -> ("http://hackage.haskell.org/package/"++str) :(
23:11:38 <ivanm> yup
23:16:23 <sereven> @hackage polyethylene-tables
23:16:23 <lambdabot> http://hackage.haskell.org/package/polyethylene-tables
23:17:06 <ivanm> @hackage I_CAN_HAZ_LINK_TO_NONEXISTING_PACKAGE_PLZ_KTHNX_BYE
23:17:06 <lambdabot> http://hackage.haskell.org/package/I_CAN_HAZ_LINK_TO_NONEXISTING_PACKAGE_PLZ_KTHNX_BYE
23:18:44 <blackdog> stupid bootstrapping problems... if i had Hubris already, i could use it to import haskell-src-exts which would help me build Hubris...
23:18:55 <ivanm> what's Hubris?
23:19:02 <blackdog> haskell-ruby bridge
23:19:07 <ivanm> ahhh....
23:19:15 <blackdog> i'm trying to un-**** it
23:19:17 <ivanm> hang on, isn't that yours?
23:19:21 <blackdog> yep:)
23:19:24 <ivanm> if so, why don't you already have it? :p
23:19:44 <blackdog> well, i have both broken halves :)
23:19:48 <ivanm> ahhh
23:19:49 <ivanm> blackdog: why does having hubris help you install hsx?
23:20:05 <blackdog> i'm doing some unprincipled string hacking to gather information about haskell source
23:20:11 <blackdog> i'd rather use haskell-src-exts
23:20:21 <blackdog> but i'm doing the logic in ruby
23:20:26 * ivanm has to go...
23:20:28 <blackdog> so i need to be able to call it from ruby...
23:20:43 <blackdog> hence stupid bootstrapping issues
23:24:46 <oteren> out of curiosity, why would you do the logic in ruby? :p
23:25:08 <blackdog> was the easiest way up front. i'm thinking of moving some of it to haskell
23:25:30 <oteren> i'd imagine it would be a lot easier to call it from python
23:25:43 * oteren is an anti ruby crusader
23:25:44 <oteren> :D
23:25:57 <blackdog> might be able to cut the interface down a bit if i move some of it to haskell. bears further thought.
23:26:01 <blackdog> what's your beef with rub?
23:26:04 <blackdog> ruby?
23:26:20 <oteren> i implementet a small thingie in it, textbook imlementation
23:26:27 <blackdog> i think it's about the same amount of work in any OOish language
23:26:33 <oteren> at four users it was at 100% load
23:26:45 <blackdog> rails?
23:27:21 <oteren> ye
23:27:21 <oteren> s
23:27:25 <kyagrd> ruby is a language that doesn't even implement closures correctly (so as python but a bit better)
23:28:15 <blackdog> can't argue with either of those, really, but it's got a large base of users who are generally pretty adventurous about trying new things
23:28:25 <blackdog> and if it's slow, all the better - more reason to try Hubris:
23:28:26 <blackdog> :)
23:28:32 <oteren> well, my beef is more with the whole ruby on rails package
23:28:45 <blackdog> kyagrd: yeah, scoping in ruby is awful. just broken.
23:28:47 <oteren> ruby in it self isnt inherently bad
23:29:01 <blackdog> oteren: oh. but i didn't mention rails at all, did i?
23:29:04 <oteren> true
23:29:44 <blackdog> what was the app, btw? i'm on the lookout for a good use case for Hubris - something really computationally intensive and useful would be great.
23:30:28 <oteren> it's long gone
23:30:34 <oteren> was a server monitoring frontend
23:30:41 <oteren> for counter strike
23:31:26 <blackdog> ah well.
23:31:29 <oteren> just saw how it used resources, then we all went O_O
23:31:33 <oteren> and redid it in python :p
23:31:55 <blackdog> there are generally a few immediate optimisations you can do in rails to speed it up in any specific case
23:31:59 <oteren> yes, i know i'm a predjucided bastard!
23:32:12 <blackdog> but it's really optimised for development speed rather than anything else
23:32:21 <oteren> well yeah
23:32:30 <oteren> i dont think RoR was ever meant to be used for large scale stuff
23:32:39 <oteren> as in a couple of hundred consecutive users
23:32:49 <oteren> or, i hope it wasnt meant for that :p
23:33:08 <blackdog> still, if you can try out 10 designs in the same time it would usually take to build 1, it's still a good tradeoff even if every rails app needs to be rewritten for production use
23:33:17 <oteren> true
23:34:03 <blackdog> and if you can avoid rewriting the whole thing by contracting the hard bits out to Haskell, so much the better *pimppimppimp*
23:34:10 <blackdog> anyway. pub time.
23:34:18 <oteren> pub time?
23:34:21 <oteren> what timezone are you in?
23:34:26 <blackdog> AU
23:34:28 <blackdog> east coast
23:34:35 <oteren> aha
23:34:40 <oteren> have fun :)
23:34:48 <blackdog> cheers
23:36:23 <SubStack> woooo
23:36:28 <SubStack> http://github.com/substack/hsopenid/blob/master/examples/easy.hs
23:37:44 <hackagebot> PastePipe 1.0 - CLI for pasting to hpaste.org (RoganCreswick)
23:41:37 <SubStack> openid is super easy now, so everybody better start using it >_<
23:43:39 <coolguy4> hi, I just started playing with haskell because I'm installing xmonad with xmobar. xmobar has a couple of dependencies that I didn't have (I found these on Hackage). The dependencies were parsec and stm. Now parsec has the dependency of base >=3.0.3&&<4 . And now I come to my question, how do I check what version of base I have?
23:44:11 <kyagrd> coolguy4: use ghc-pkg
23:44:33 <kyagrd> ghc-pkg list base
23:44:41 <kyagrd> then it will show you what's installed
23:45:01 <Saizan> if you have an older base you might be able to use an earlier version of parsec
23:46:02 <kyagrd> And, you can allways install higher versions of parsec using cabal
23:46:27 <coolguy4> thanks, I did ghc-pkg latest base and it said I had 3.0.1 .
23:53:15 <juturnas> I want to gather input from sockets, and process it after a set amount of time, & repeat.  I'm gathering input into a Chan now, but I'm not sure about the delay part, or if what i'm doing is the best way
23:53:18 <juturnas> any thoughts?
23:53:53 <shambler> use select?
23:54:00 <shambler> erm
23:54:02 <shambler> wait
23:54:26 <juturnas> let me explain a little better
23:54:35 <shambler> yes plox
23:54:51 <juturnas> I am working on a MUD, and I want to get any inputs from connected players, and then update the game probably 4 times a second
23:55:09 <shambler> oh
23:55:23 <juturnas> so I have threads putting messages from players into a Chan, and the main thread has access to that Chan and all of the game data
23:56:10 <coolguy4> when I tried to compile base, I got '<interactive>:1:22: Not in scope: `System.IO.stderr'
23:59:11 <stanv> what is mean "`b' is a rigid type variable" ?
