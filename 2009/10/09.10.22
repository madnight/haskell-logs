00:01:11 <dancor> mm.  i can't even tell if SDL the C library supports this with wrapper functions or if you are supposed to lock the surface, read the pixel format and read the pixel data directly
00:12:41 <dancor> i guess i'll just use pngload
00:18:33 <dancor> hm that didn't like what imagemagick convert gave it
00:22:09 <dancor> ooh sdl surfaceGetPixels
00:23:40 <anborn> hi all! I have the following monadic (apparently tail recursive) code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4451. It produces a stack overflow, but given that everything should be evaluated strictly I don't understand why. Any help?
00:25:08 <dancor> the CLisp version of Graphics.GD binding has get-pixel !
00:25:15 <dancor> but not the haskell one
00:25:39 <sjanssen> anborn: use Control.Monad.Writer.Strict instead of lazy
00:25:48 <Cale> sjanssen: he is
00:25:54 <anborn> yes, I'm using it
00:26:01 <sjanssen> oh, oops
00:26:11 <sjanssen> anborn: by the way, print <$> is not what you want there
00:26:26 <sjanssen> this give main the type IO (IO ())
00:26:49 <Cale> That's the inferred type...
00:26:49 <anborn> sjanssen: I see...
00:26:55 <Cale> Though that's somewhat suspicious.
00:27:22 <sjanssen> print . fst =<< runWriterT (sum' whatever) -- is correct
00:28:20 <anborn> sjanssen: ok, that fixes the type. But not the stack overflow...
00:29:32 <sjanssen> anborn: yeah, I think WriterT will have this linear stack use no matter what you do
00:30:32 <sjanssen> pretty obvious when you look at the instances here http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Writer-Strict.html#WriterT
00:31:21 * dancor sad the GD doesn't document gdImageGetPixel vs gdImageGetTrueColorPixel
00:33:40 <dancor> i think truecolor is legacy
00:35:51 <dancor> @hoogle int
00:35:51 <lambdabot> Text.PrettyPrint.HughesPJ int :: Int -> Doc
00:35:51 <lambdabot> Language.Haskell.TH.PprLib int :: Int -> Doc
00:35:51 <lambdabot> module Data.Int
00:36:02 <dancor> is there an int under Foreign?
00:36:45 <sjanssen> @hoogle CInt
00:36:46 <lambdabot> Foreign.C.Types data CInt
00:36:46 <lambdabot> Foreign.C.Types data CIntMax
00:36:46 <lambdabot> Foreign.C.Types data CIntPtr
00:37:01 <dancor> nm
00:41:51 <paolino> good morning, I need to prune off a rosetree branches where each node satisfy a given condition. IÂ´ve thought a solution using the zipper, where the underlying tree is augmented in each node with a boleean meaning the node has been checked already. Is there a solution with such a complexity wich doesn't involve this boolean and/or not  using the zipper ?
00:43:31 <earthy> paolino: sounds like me you want a breadth-first walk
00:43:49 <earthy> (good morning, let me get my brain in gear first)
00:44:11 <earthy> still does sound like you want a breadth-first walk
00:44:25 <Cale> data Tree a = Branch a [Tree a] ?
00:44:41 <paolino> earthy, the pruning condition is all the branch nodes satisfy the condition
00:44:50 <earthy> see e.g. http://blogs.msdn.com/matt/archive/2008/05/11/breadth-first-tree-traversal-in-haskell.aspx
00:44:51 <paolino> Cale yes
00:45:00 <paolino> or Data.Tree
00:45:26 <earthy> oh! you want a bottom-up walk
00:45:32 <Cale> foldTree b = f where f (Branch x ts) = b x (map f ts)
00:45:53 <Cale> oh, hmm
00:46:14 <Cale> I'm a little unclear about what you're actually trying to write
00:46:15 <paolino> earthy, very possible
00:46:35 <earthy> sounds like me he wants to color the tree from the leaves up
00:46:52 <earthy> only coloring tree nodes when all the underlying nodes have the same color
00:47:11 <earthy> and then prune all colored subtrees
00:47:27 <paolino> that is a correct description
00:47:40 <earthy> still getting my brain in gear though... my english sucks today
00:48:04 <paolino> the goal is staying linear
00:48:33 <paolino> with the number of leaves
00:48:39 <earthy> impossible.
00:48:58 <earthy> you can go linear in the total number of nodes (including leaves)
00:49:04 <earthy> but not linear in the leaves.
00:49:14 <paolino> correct
00:50:40 <paolino> I wonder if there is a solution without the zipper, and also if I got it right with it
00:51:09 <earthy> methinks a foldMap would suffice.
00:51:42 <paolino> @hoogle foldMap
00:51:42 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:51:42 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
00:52:52 <earthy> or possibly traverse
00:53:20 <paolino> @hoogle traverse
00:53:20 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:53:21 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
00:54:19 <paolino> mhh, my solution goes twice in the non-leaves nodes
00:54:35 <paolino> traverse goes once
00:55:02 * earthy nods
00:55:23 <earthy> will build a relatively sizeable deferred computation though
00:55:33 <earthy> depending on the size of the tree, ofcourse
00:56:47 <paolino> I cannot guess it, even traversing twice, I must think about that
00:58:32 <paolino> it looks to me  you cannot walk bottom up with traverse and this is defeating linerity complexity, but I'm no mathematically ready to prove that
01:00:21 <dancor> i've packed four unsigned bytes into a CInt using shiftL.  will using shiftR to get them back do crazy things bc CInt is treated as signed?
01:05:34 <Saizan> try it out :)
01:10:59 <mmorrow> dancor: looks at the Bits instance code
01:11:18 <mmorrow> dancor: also, you may want to use a CUInt
01:12:06 <ivant> is there a combinator in Haskell which applies some function N times to the given argument? It's easy to write one, but I wonder if there is one already. Using iterate and (!!) is ugly.
01:12:24 <mmorrow> @type (\n -> foldr (.) id . replicate n)
01:12:24 <lambdabot> forall b. Int -> (b -> b) -> b -> b
01:12:41 <mmorrow> @let ntimes n = foldr (.) id . replicate n
01:12:42 <lambdabot>  <local>:23:0:
01:12:42 <lambdabot>      Multiple declarations of `L.ntimes'
01:12:42 <lambdabot>      Declared at: <lo...
01:12:42 <mux> ivant: more annoyingly, using iterate and (!!) blows the stack up
01:12:46 <mux> you need a stricter iterate
01:12:50 <mmorrow> > ntimes (*2) 1
01:12:51 <lambdabot>   The section `GHC.Num.* 2' takes one argument,
01:12:51 <lambdabot>  but its type `GHC.Types.Int'...
01:12:52 <mmorrow> grr
01:12:58 <mmorrow> @let ntimes' n = foldr (.) id . replicate n
01:12:59 <lambdabot>  Defined.
01:13:02 <mmorrow> > ntimes' (*2) 1
01:13:03 <lambdabot>   The section `GHC.Num.* 2' takes one argument,
01:13:03 <lambdabot>  but its type `GHC.Types.Int'...
01:13:09 <mmorrow> > ntimes' 8 (*2) 1
01:13:10 <lambdabot>   256
01:13:50 <ivant> Wouldn't foldr blow up the stack?
01:13:57 <mmorrow> not for (.)
01:14:17 <mux> @let ntimes'' f n = let iterate' f x = x `seq` iterate' (f x) in iterate' f x !! n
01:14:18 <lambdabot>  <local>:24:42:
01:14:18 <lambdabot>      Occurs check: cannot construct the infinite type: t = a ...
01:14:33 <mux> @let ntimes'' f n = let iterate' f x = x `seq` iterate' f (f x) in iterate' f x !! n
01:14:34 <lambdabot>  Defined.
01:14:48 <mux> > ntimes' (*2) 123
01:14:49 <ivant> okay, screw it, I'll just write a tail-recursive function
01:14:49 <lambdabot>   The section `GHC.Num.* 2' takes one argument,
01:14:49 <lambdabot>  but its type `GHC.Types.Int'...
01:15:04 <mux> > ntimes'' (*2) 123
01:15:07 <lambdabot>   mueval-core: Time limit exceeded
01:15:17 <mux> > ntimes (*2) 123
01:15:20 <lambdabot>   The section `GHC.Num.* 2' takes one argument,
01:15:20 <lambdabot>  but its type `GHC.Types.Int'...
01:15:49 <mux> ivant: well at least ntimes'' should work, I've used it this way alreayd ;-)
01:16:19 <mmorrow> @let seqList xs = foldr seq () xs `seq` xs
01:16:21 <lambdabot>  Defined.
01:16:24 <ivant> mux, thanks! Still I'm surprised that it's not in the default libraries
01:17:25 <mmorrow> mux: i think you used the `x' from SimpleReflect
01:17:28 <mmorrow> > x
01:17:29 <lambdabot>   x
01:17:48 <mmorrow> @type ntimes''
01:17:49 <lambdabot> forall a. (Expr -> Expr) -> Int -> a
01:18:08 <mmorrow> (not sure if that was intended)
01:20:00 <Baughn> ivanm: Apparently so, but I need CVS access first so I can port the revision history. ;_;
01:21:21 <mmorrow> <ivant> okay, screw it, I'll just write a tail-recursive function
01:21:30 <mmorrow> ivanm: the foldr (.) really will work :)
01:22:22 <mmorrow> , ntimes n = foldr (.) id . replicate n in time (ntimes 1000000 (*2) (1::Int))
01:22:23 <lunabot>  luna: parse error on input `='
01:22:27 <mmorrow> , let ntimes n = foldr (.) id . replicate n in time (ntimes 1000000 (*2) (1::Int))
01:22:30 <lunabot>  Stack space overflow: current size 8388608 bytes.
01:22:30 <lunabot>  Use `+RTS -Ksize' to increase it.
01:22:36 <mmorrow> sigh
01:22:51 <mmorrow> , let ntimes n = foldr (.) id . replicate n in time (ntimes 1000000 (\ !x -> x*2) (1::Int))
01:22:54 <lunabot>  Stack space overflow: current size 8388608 bytes.
01:22:54 <lunabot>  Use `+RTS -Ksize' to increase it.
01:22:58 <mmorrow> :o
01:23:03 <ivant> :-)
01:23:04 * mmorrow takes back his statement
01:23:41 <ivant> mmorrow: that's why I decided to write a tail-recursive function: it's easy to read and understand, and it's clear that it won't blow up the stack
01:24:02 <ivant> mmorrow: until I get smart about the stack effects, I prefer to play it safe
01:24:08 <mmorrow> ivanm: yeah, to be honest i'd probably write a directly recursive version too ... ;)
01:24:29 <oteren> ivant: what do you work as?
01:24:40 <ivant> I appreciate a concise point-free definitions which I can understand though
01:26:00 <ivant> oteren: what do I work *at*? a program (for a personal use) to read/write Sun SPOT flash memory over USB
01:26:20 <mmorrow> , let ntimes n _ !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (*2) (1::Int))
01:26:21 <lunabot>  luna: No instance for (Luna.SimpleReflect.FromExpr GHC.Types.Int)
01:26:51 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (*2) (1::Int))
01:26:55 <lunabot>  (1.239811,0)
01:27:15 <mmorrow> zero!?
01:27:31 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1 (*2) (1::Int))
01:27:33 <lunabot>  (0.0,2)
01:27:50 <mmorrow> how could that possibly be zero?
01:27:57 <mmorrow> (the result, not the time)
01:27:59 <int_e> > last $ takeWhile (/=0) $ iterate (*2) 1
01:28:03 <lambdabot>   mueval-core: Time limit exceeded
01:28:08 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000 (*2) (1::Int))
01:28:10 <int_e> > last $ takeWhile (/=0) $ iterate (*2) 1 :: Int
01:28:10 <lunabot>  (1.0e-3,0)
01:28:11 <lambdabot>   -9223372036854775808
01:28:23 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 10 (*2) (1::Int))
01:28:25 <lunabot>  (0.0,1024)
01:28:45 <oteren> ivant: no, more like professionally
01:28:55 <oteren> he didnt want to answer that it seems!
01:28:56 <oteren> :p
01:29:40 <int-e> mmorrow: Hey, you're into that low level stuff. I'm surprised that you're surprised. :)
01:30:11 <mmorrow> int-e: i'm baffled, is this some sort of weird bug?
01:30:34 <ivant> oteren: are you sure you aren't confusing me with ivanm (or some other ivan here)? :-) I'm a software engineer, write real-time code in C and Real-time Java
01:30:35 <int-e> mmorrow: 2^64 :: Int = 0. You're calculating 2^1000000
01:30:59 <dreixel> how does one include UTF-8 chars in a cabal package file?
01:30:59 <mmorrow> > (2::Int)^64
01:31:00 <lambdabot>   0
01:31:06 <oteren> ivant: ah, there are two of you
01:31:07 <mmorrow> news to me :)
01:31:16 <Jafet> > (2::Int)^32
01:31:17 <lambdabot>   4294967296
01:31:21 <oteren> that explains how you can help newbies and discuss advanced stuff in here 24/7
01:31:24 <mmorrow> , (2::Int)^32
01:31:25 <lunabot>  0
01:31:27 <oteren> that was what i was wondering
01:31:27 <oteren> hehe
01:31:46 <medfly> he just joined
01:32:01 <medfly> oh, nvm
01:32:09 <mmorrow> oh right of course...
01:32:24 <mmorrow> , (1::Int) `shiftL` 32
01:32:25 <lunabot>  0
01:32:34 <int-e> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 100000 (*2) (1::Integer))
01:32:37 <lunabot>  (0.7138909999999999,99900209301438450794403276433003359098042913905418169...
01:32:51 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (+1) (1::Int))
01:32:55 <lunabot>  (1.265807,1000001)
01:33:07 <ivant> oteren: I'm a lurker, I sometimes helped newbies here, but I haven't been programming in Haskell for a while and was wondering if I forgot that there's a better choice than iterate + !!
01:33:13 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (^2) (1::Integer))
01:33:17 <lunabot>  (1.930707,1)
01:33:24 <mmorrow> gmp is speedy
01:33:38 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (*29374623423) (1::Integer))
01:33:38 <int-e> gmp was not involved in that case.
01:33:42 <lunabot>  luna: out of memory (requested 1048576 bytes)
01:33:52 <oteren> ivant: i prefer to lurk as well :)
01:33:58 <int-e> @src Integer
01:33:58 <lambdabot> data Integer = S# Int#
01:33:59 <lambdabot>              | J# Int# ByteArray#
01:34:27 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (^2) (2::Integer))
01:34:33 <lunabot>  Killed.
01:34:42 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 10000 (^2) (2::Integer))
01:34:48 <lunabot>  Killed.
01:34:52 <int-e> 2^10000 bits is a bit too many
01:34:56 <Botje> does the J stand for Jumbo? :)
01:34:57 <mmorrow> i think that's more atoms
01:34:58 <mmorrow> yeah :)
01:35:09 <mmorrow> .. than there are in teh universe
01:35:22 <Baughn> ..well, no.
01:35:28 <mmorrow> yuh huh!
01:35:29 <Baughn> More than there are particles, sure, but bits....
01:35:52 <int-e> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 25 (^2) (3::Integer))
01:35:58 <lunabot>  Killed.
01:36:15 <permagreen> Kind of reminds me of that time I wrote a tetration function,,,
01:37:13 <permagreen> It would have worked beautifully if my computer contained an infinite amount of memory
01:37:18 <Botje> one of the Euler problems is about tetration.
01:37:23 <Botje> i'm still wondering how to solve it
01:37:41 <Botje> I figured out there's a fixpoint in there, but i can't seem to get the right answer :(
01:38:13 <int-e> If it's the one I think it is, the key is to use Euler's Totient theorem.
01:38:26 <Baughn> @seen dons
01:38:26 <lambdabot> Unknown command, try @list
01:38:32 <Baughn> ..whut
01:39:21 <medfly> preflex, seen dons
01:39:22 <preflex>  dons was last seen on #xmonad 2 hours, 35 minutes and 51 seconds ago, saying: yeah! there's a page on the haskell.org wiki, but it is obscure.
01:39:33 <int-e> (now-10):25:41 <dons> sinelaw: no
01:39:44 <Baughn> dons: So, about cvs.haskell.org...
01:39:44 <mmorrow> oh duh, i just realized why that foldr (.) didn't work (maybe)
01:40:42 <mmorrow> , let ntimes n = foldr (.) id . replicate n . ($!) in time (ntimes 1000000 (*2) (1::Int))
01:40:45 <lunabot>  Stack space overflow: current size 8388608 bytes.
01:40:45 <lunabot>  Use `+RTS -Ksize' to increase it.
01:40:54 <mmorrow> unfortunate
01:40:57 <paolino> earthy: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4452#a4452 -- untested
01:41:38 <trez> d
01:45:30 <mmorrow> , time (fix (\k n f !x -> if n < 1 then x else k (n-1) f (f x)) 1000000 (+1) (1::Int))
01:45:34 <lunabot>  (1.961701,1000001)
01:45:47 <mmorrow> , let ntimes n f !x | n < 1 = x | otherwise = ntimes (n-1) f (f x) in time (ntimes 1000000 (+1) (1::Int))
01:45:51 <lunabot>  (1.233812,1000001)
01:46:16 <mmorrow> i'd hope that that becomes the same thing in compiled code with all the optims
01:51:06 <mmorrow> this is somewhat interesting http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4453#a4453
01:59:52 <mmorrow> i wonder if gcc'd create a specialize instance of a tiny function that takes a function ptr and does ntimes, or probably that's too much to ask
01:59:59 <int-e> , let ntimes n f i = foldl' (const . f) i (replicate n ()) in time (ntimes 1000000 (+1) (1::Int))
02:00:01 <lunabot>  (0.256961,1000001)
02:00:12 <mmorrow> not bad
02:00:26 <mmorrow> err, well that's jumping into compiled code i guess
02:00:51 <int-e> I'd hope so :)
02:01:06 <mmorrow> , let foo f !z [] = z; foo f !z (x:xs) = foo f (f z x) xs in ntimes n f i = foo (const . f) i (replicate n ()) in time (ntimes 1000000 (+1) (1::Int))
02:01:07 <lunabot>  luna: parse error on input `='
02:01:15 <mmorrow> , let foo f !z [] = z; foo f !z (x:xs) = foo f (f z x) xs; ntimes n f i = foo (const . f) i (replicate n ()) in time (ntimes 1000000 (+1) (1::Int))
02:01:18 <lunabot>  (0.931859,1000001)
02:01:31 <mmorrow> still handily beats the explicit one
02:02:36 <mmorrow> which depending on why may turn out to be disturbing or .. err, actually that's somewhat disturbing
02:03:47 <mmorrow> i've been meaning to look up exactly the optims the bytecode interp leaves out to be able to actually be able to guess at the compiled diff between two functions given the diff between them as bytecode
02:05:03 <mmorrow> sigh, it starts to get tedious writing functions in C whose result type depends on the result type of a passed in function ptr
02:05:29 <mmorrow> all of a sudden every type in the entire prog in void*
02:06:05 <quicksilver> s/whose.*//;
02:06:48 <mmorrow> well, that too of course
02:08:11 <int-e> mmorrow: replicate is still using compiled code, so the counter got unboxed.
02:10:41 <mmorrow> unsurprisingly gcc does not specialize on a known function ptr
02:10:50 <mmorrow> int-e: ah, true
02:12:19 <mmorrow> good thing for the C preproc!
02:12:26 <mmorrow> :|
02:21:46 <mmorrow> at least gcc does the sane thing with a macro http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4453#a4454
02:22:24 <mmorrow> (namely doesn't even do the the loop at all, since the result is statically knowable/computable)
02:22:59 <ivanm> have people been using my nick in vain again? :p
02:23:00 <quicksilver> true although I've always been uneasy about that kind of optimisation.
02:23:27 <quicksilver> seems to me that C compilers should really be looking for the most efficient way to implement an algorithm in machine code
02:23:30 <quicksilver> not changing the algorithm.
02:24:13 <mmorrow> true, at least it's an option
02:24:21 <quicksilver> such optimisations which totally change behaviour are fragile too
02:24:36 <quicksilver> and it can be even *more* suprising when you make an innocent code change and suddenly get much slower code
02:25:00 <mmorrow> heh, all of a sudden you actually have to do something
02:25:04 <quicksilver> (mind you that criticism can also be levelled at pretty much GHC's entire static optimisation set up)
02:25:16 <mmorrow> yeah, also true
02:25:26 <quicksilver> optimisations like that are really useful for optimising generated code, though
02:25:35 <p_l> quicksilver: afaik that's why GCC has special attributes to sign when it is safe to compute the result during compilation etc.
02:25:45 <quicksilver> like the output of the that  fft c
02:25:52 <quicksilver> that ML fft c code generator
02:25:55 <Baughn> It's why I usually compile haskell without -O
02:25:56 <quicksilver> (I was trying to type)
02:26:02 <quicksilver> p_l: yes, true.
02:26:10 <Jafet> If you had to compile all C code correctly, even the darkest tiniest corner cases, your desktops would be even slower than they are now
02:26:10 <Baughn> I want my code to work /whatever/ you guys do to the compiler in the future..
02:26:18 <ivanm> Baughn: why don't you use optimisations?
02:26:23 <Baughn> ivanm: Er. When developing.
02:26:48 <Jafet> (Insert linux kernel null pointer check joke here)
02:26:50 <quicksilver> I don't use -O when developing, to make compile times faster, until some part of my code stards to rely on it.
02:26:51 <Baughn> ivanm: It's mainly about not shoving needed strictness annotations under the carpet
02:26:52 <ivanm> as in you test your code without optimisations to make sure it works?
02:26:56 <ivanm> oh, strictness...
02:27:07 <ivanm> but why not -Ox ?
02:27:36 <p_l> Jafet: what check? :)
02:27:56 <Baughn> ivanm: There are limits to what I'm willing to accept in bad performance.
02:28:17 <xpika> help! deamon is loaded but can't see anything on http://127.0.0.1:5984/_utils/index.html
02:28:20 <Baughn> ivanm: But it's kind of funny, isn't it? In C, I have to test with optimizations on because turning them on sometimes /breaks/ my programs. In haskell, it's the exact opposite.
02:28:24 <jystic> is downloading the source .tar.gz file from hackage the best way to fix a package that specifies incorrect version dependencies? or is there a way you can do it from cabal on the command line?
02:28:51 <Baughn> jystic: cabal fetch'll do
02:28:53 <ivanm> Baughn: I've found that some code doesn't work well without -O2 in the past
02:28:58 <ivanm> or at least compilation differences
02:29:07 <Baughn> ivanm: What, in C?
02:29:14 <ivanm> no, ghc
02:29:21 <Saizan> jystic, Baughn: cabal unpack
02:29:30 <ivanm> (pretty sure there's something about the name of the Main module, etc. that works with -O2 but not without or vice versa...)
02:29:35 <Saizan> jystic: there's also --constraint= to add constraints
02:29:52 <MyCatVerbs> Baughn: I don't think I've ever seen a program break when -O was turned on, provided that it passed through valgrind with a clean bill first.
02:30:19 <ivanm> there are occasional C-based apps like mplayer that are fragile wrt which CFLAGS they're compiled with...
02:30:24 <jystic> Saizan: thanks, how does --constraint work?
02:30:45 <ivanm> (and then you get stupid gentoo users that bitch that they can't use their way cool CFLAGS with them...)
02:30:52 <p_l> ivanm: that's because the writers have went apeshit crazy regarding the code produced by compiler? :)
02:30:55 <jystic> i need to do a 'cabal install happstack-helpers' with a constrainst that hscolour needs to be 1.14
02:31:17 <Baughn> MyCatVerbs: Eheh. Mine don't.
02:31:18 <ivanm> p_l: heh, could be
02:31:20 <mmorrow> quicksilver: yeah, generated code is definitely the killer app for that kind of optim
02:31:24 <Saizan> jystic: cabal install happstack-helpers --constraint="hscolour == 1.14"
02:31:39 <Baughn> MyCatVerbs: Well, *mine* do, but the various projects I'm working with..
02:31:48 <jystic> Saizan: that's great, thanks!
02:32:04 <p_l> ivanm: frankly speaking, it's because of that attention to detail that I actually ended switching to Linux full-time :)
02:32:08 <jystic> that's much easier than what I was about to attempt :)
02:32:30 <mmorrow> quicksilver: the line blurs though too, since technically *all* code the compiler optimizes is "generated" in some sense
02:32:31 <ivanm> p_l: you mean you did switch or stopped switching?
02:33:00 <Saizan> jystic: cabal unpack foo; cd foo-$ver; edit foo.cabal; cabal install ? :)
02:33:05 <p_l> ivanm: PlayingAround -> FullTimeUser
02:33:10 <ivanm> ahhh
02:33:17 <jystic> Saizan: yup, haha :)
02:33:42 <Baughn> ivanm: mplayer mainly breaks with the wrong optimization flags because of assembly use
02:33:44 <p_l> ivanm: it was the only player that didn't give me problems due to slow computer, even using VESA framebuffer :)
02:34:02 <ivanm> Baughn: yeah
02:34:13 <Baughn> ivanm: It's actually pretty reliable, per se, but when you've got inline assembly that requires GCC to allocate six of eight possible registers to it, the compilation becomes fragile
02:34:21 <mmorrow> quicksilver: well, that's probably less true for a (non-intensely optimizing/restructuring) C compiler than say haskell, but still
02:34:27 <Baughn> In a "won't compile if you turn off optimization and -fomit-frame-pointer" sense, not a "won't work" sense
02:34:58 <ivanm> or a "won't compile/work properly if you use batshit insane CFLAGS sense..." ;-)
02:35:13 <Baughn> ..mm, but that's /always/ true
02:35:56 <p_l> Baughn: at least multimedia coders can give a real reason to usage of inline assembly, at least from time to time
02:36:25 <mmorrow> speaking of that, i noticed there's an selinux flag/whatever "enable mplayer exec stack"
02:36:34 <mmorrow> bean meaning to look what it uses that for
02:36:38 <mmorrow> *been
02:37:01 <mmorrow> i'm guessing it dynamically generates code, sticks it on the stack, then jumps?
02:37:35 <ivanm> s/jumps/breaks/ :p
02:37:39 <mmorrow> like code that implements some filter or something
02:38:13 <mmorrow> but specialized to the particular runtime parameter vals or something maybe
02:41:03 <mxc> i love this community..
02:41:06 <Deewiant> ivanm: No, there's no direct way of skipping certain matches :-/
02:41:25 <ivanm> Deewiant: :(
02:41:26 <Deewiant> If performance doesn't worry you can just do a filter over the result list
02:41:30 <mxc> can't exactly imagine MS coming out and emailing everyone an explanation for a delay in a VS release and asking people what they think they should do
02:41:31 <ivanm> I guess I can't use glob then :(
02:41:46 <ivanm> Deewiant: I already have a hackish manual search function
02:41:51 <ivanm> I guess I"ll keep using it
02:42:00 <Deewiant> You could use Glob to simplify it :-P
02:42:18 <Deewiant> I.e. in each directory search for *.hs with it, or whatever
02:44:27 <quicksilver> mmorrow: yes, one justification for such optimisations is they might act on the result of other optimisations or, conversely, they might expose future optimisations
02:44:27 <ivanm> Deewiant: doesn't glob do recursive stuff though?
02:44:43 <Baughn> Deewiant: There's also the "**/*.hs" pattern, which includes subdirectories
02:44:52 <quicksilver> mmorrow: I don't think that's particularly convincing in the case of compile-time-calculation for constant folding though :)
02:44:52 <mreh> I can't get this fp support working in eclipse, I've pointed it to GHC and when you click run, nothing happens
02:45:07 <mmorrow> quicksilver: heh, fair point
02:45:16 <quicksilver> I thought the eclipsefp stuff bitrotted many moons ago
02:45:48 <quicksilver> mmorrow: I think it would be interesting to write a paper on what program rewrite / refactorisation laws we "give up" for each of GHC's clever optimisations.
02:45:48 <ivanm> quicksilver: I thought someone had a GSoC for them...
02:46:13 <quicksilver> mmorrow: ("give up" in the sense of, they still apply but they can destroy running time)
02:46:21 <mreh> this guy maintains it http://jpmoresmau.blogspot.com/
02:46:26 <quicksilver> mmorrow: still it would be a bit of an unproductive negative paper :)
02:46:42 <quicksilver> mreh: oh, that's good news.
02:46:49 <quicksilver> mreh: I hope the project gets revived then!
02:47:00 <Deewiant> ivanm: If you use the IO function, yes, but you have to do your own getDirectoryContents anyway in order to filter out _darcs and whatnot
02:47:27 <ivanm> Deewiant: oh, use glob rather than filter for checking the extensions?
02:47:35 <Deewiant> And of course, if you don't use a pattern like **/*.hs it won't descend into subdirs.
02:47:52 <ivanm> oh, true
02:47:53 * Baughn wonders if glob actually implements **
02:47:56 <Deewiant> ivanm: Yeah, that's what I meant. Might not be worth it if it's already simple enough. :-)
02:48:00 <Deewiant> Baughn: Yes, it does.
02:48:25 <ivanm> Deewiant: because you claim glob is faster than filter (isHaskellExtension . takeExtension) ?
02:48:34 <Deewiant> Er, glob(3) doesn't, that is, but my Haskell library does.
02:49:00 <Deewiant> ivanm: Hard to be much faster than that, I think :-)
02:49:12 <oteren> EclipseFP
02:49:23 <oteren> now those guys are a bunch of people with good intentions and bad results
02:49:24 <mreh> oteren: what about it?
02:49:25 <mgsloan1> hey, is it possible to compile a haskell file to a single, standalone C/C++ file?
02:49:32 <ivanm> Deewiant: *nod* so what you're saying is that your library is useless to me? :p
02:49:40 <oteren> how can you make a plugin for eclipse, that requires a buttload of *other* stuff to be manually installed
02:49:42 <ivanm> mgsloan1: I doubt it...
02:49:59 <oteren> the whole plugin system of eclipse is based around plug and play
02:50:10 <mreh> oteren: well i just installed it without any hassle
02:50:12 <ivanm> oteren: because they didn't want to re-invent the wheel, the reins and the beer fridge? :p
02:50:18 <mreh> any hassle to do with eclipse
02:50:25 <oteren> mreh: eclipsefp 1 or 2?
02:50:28 <Deewiant> ivanm: I'm saying that the best you can do with it is maybe turn five lines of code into one :-P
02:50:28 <mgsloan> ivanm - darn, because I wanted to use haskell for a Java / C++ only coding competition
02:50:29 <oteren> only the 1 goes smooth
02:50:31 <Baughn> mgsloan: No. If nothing else, it'll need a plethora of weird headers and ghc libraries
02:50:33 <mreh> oteren: 2
02:50:38 <ivanm> but IIRC from when I tried eclipseFP, it brought all the dependencies in for me...
02:50:44 <Baughn> mgsloan: ..also, it wouldn't be /readable/ C in any case
02:50:46 <oteren> as it is now, eclipsefp 2 cant be installed unless you have installing rights on the computer
02:50:54 <ivanm> Deewiant: *nod* so abstraction, not performance
02:50:56 <oteren> (which is the case for me on the uni labs)
02:51:04 <mreh> oteren: well fair
02:51:05 <Deewiant> ivanm: Yep.
02:51:06 <mgsloan> Baughn: if I understand the rules, readability doesn't matter at all
02:51:25 <int-e> mgsloan: maybe along the lines of http://www.de.ioccc.org/1984/mullender.c ;-)
02:51:45 <Baughn> mgsloan: You could run cpp over it to get something marginally self-contained, but it'll still need the library files
02:51:56 <Deewiant> I guess I'll have to think about doing an ignore-things-that-match-this-pattern feature, or something.
02:52:18 <ivanm> Deewiant: you considered extending glob to provide features like in the RWH glob/find chapter?
02:52:32 <ivanm> it provides fine control on how to recurse, etc.
02:52:43 <ivanm> QtPlaty[1ireMe]: how long has it been without work for you now?
02:52:45 <mmorrow> quicksilver: that would be interesting indeed. my opinion is that optims could/should be done on arbitrary directly-recursive jumbles of code (which is what everything is once it's been inlined (save for recursion hidden by higher-order functions), since then optims are durable to arbitrary refactorings/different ways of expressing the equivalent (wrt complexity) computation
02:53:22 <mmorrow> rather than special case rewrites, e.g. fold/build, etc
02:55:06 <Deewiant> ivanm: Seems to me like that's a job for a different library... it's implementing 'find' with an arbitrary matcher function rather than globbing :-P
02:55:20 <oteren> ivanm: thats because you used eclipsefp1 i guess
02:55:23 <ivanm> Deewiant: well, they use globbing...
02:55:23 <oteren> 2 requires Scion
02:55:25 <oteren> some sort of IDE lib
02:55:29 <quicksilver> mmorrow: it's the recursion hidden by higher order functions that worries me, though
02:55:30 <ivanm> but IIRC they convert the globs to regexes
02:55:33 <int-e> mgsloan: jhc may be a better starting point than ghc if you want C code.
02:55:37 <ivanm> oteren: *shrug*
02:55:40 <quicksilver> mmorrow: argument passing across module boundaries, etc.
02:56:02 <mgsloan> int-e: would it be possible to achieve this in a couple days?
02:56:04 <quicksilver> mmorrow: you start with code which compiles well, then you abstract it by recognising the higher-order pattern and pulling the kernel out as a function.
02:56:21 <quicksilver> mmorrow: it still compiles well, until you put the kernel into another module and it rises above the inlining threshold
02:56:25 <quicksilver> mmorrow: and then *bam*
02:56:53 <int-e> mgsloan: dunno, which planet do you live on? (But seriously, I don't know how hard it is to build jhc nowadays.)
02:56:57 <Deewiant> ivanm: I don't see any explicit support for it... am I looking at the wrong thing?
02:57:29 <ivanm> Deewiant: e.g. http://my.safaribooksonline.com/9780596155339/glob#X2ludGVybmFsX1NlY3Rpb25Db250ZW50P3htbGlkPTk3ODA1OTYxNTUzMzkvZ2xvYl90cmFuc2xhdGU=
02:57:31 <mmorrow> quicksilver: right, you can't really do anything until you've got a function made of at least 2/3+ (better 5/10+) basic functions
02:57:54 <mmorrow> quicksilver: and module boundaries are death for higher order code efficiency
02:58:22 <mmorrow> good thing foldr/foldl implement the entire prelude (almost) :)
02:58:33 * quicksilver nods
02:59:07 <Saizan> maybe we should just throw a jit at it
02:59:11 <quicksilver> mmorrow: part of me thinks whole program compilation is the solution but I'd hate to lose dynamic loading.
02:59:28 <quicksilver> mmorrow: ...to which the answer might be jit, as Saizan just psychically inferred.
02:59:36 <mmorrow> quicksilver: yeah, i wouldn't want to lose that either
02:59:38 <Saizan> ;)
02:59:38 <quicksilver> Saizan++ # completing my sentences before I've started them.
02:59:50 <mgsloan> int-e: ah, I see :)  Well, it would be rather cool
02:59:51 <ivanm> Saizan: a "jit"?
03:00:01 <mmorrow> Saizan: i think there're interesting possibilities with that for sure
03:00:01 <quicksilver> do the optimisation "Just In Time"
03:00:07 <quicksilver> or some portion of the optimisation.
03:00:11 <oteren> do it JAVA style
03:00:14 <mgsloan> perhaps I'll use haskell as a generator in other ways
03:00:37 <Deewiant> ivanm: Ah. No recursion control there, though, just plain filter over getDirectoryContents
03:00:40 <ivanm> mmorrow: how are module boundaries death for higher order code efficiency?
03:01:17 <ivanm> Deewiant: oh, next chapter
03:01:20 <mmorrow> ivanm: as in, having to jump to the code for (.), when you do ((+1) . (*2) . (/4)) in another module would be really sucky
03:01:25 <Deewiant> ivanm: Yeah, that's what I was looking at previously :-)
03:01:25 <ivanm> which isn't actually globbing; it's a find command
03:01:31 <Deewiant> Exactly.
03:01:37 <mmorrow> (and jump to it twice at that)
03:01:39 <ivanm> mmorrow: you mean when writing or compiling/using?
03:01:50 <mmorrow> rather than doing  addq $7,_
03:01:52 <Saizan> ivanm: at runtime
03:01:55 <ivanm> :o
03:02:09 <ivanm> I thought modules were removed at compilation/runtme...
03:02:20 <ivanm> Deewiant: OK, so not exactly what your library is for
03:02:30 <Deewiant> It seems to me that it's somewhat nontrivial to encode next to a glob pattern how different parts of it should recurse into subdirs
03:02:32 <mmorrow> ivanm: right, but if you don't have access to the code for (.) at compile-time, you're screwed
03:02:50 <oteren> at compile time?
03:02:57 <ivanm> mmorrow: what do you mean you don't have access to it?
03:03:03 <ivanm> as in it's an external library?
03:03:05 <mmorrow> in C i can compile
03:03:08 <oteren> how can you not have access to it at compile time?
03:03:20 <ivanm> Deewiant: *nod*
03:03:33 <mmorrow> int f(int x){ return asdf(4) + asdf(x) + asdf(9); }
03:03:39 <mmorrow> without knowing what asdf is
03:03:50 <Saizan> the point is that you don't generally inline code from other modules at compile-time, while that's how (.) gets optimized away
03:03:53 <mmorrow> it could be    asdf(int x){return x;}
03:04:03 <quicksilver> ivanm: the code for (.) is in an object file called "Prelude.o"
03:04:07 <Saizan> ghc in fact has some of the code to inline stored in the .hi files
03:04:10 <quicksilver> ivanm: so the compiler doesn't have access to the soruce
03:04:15 <quicksilver> ivanm: ..only this is not actually true :)
03:04:17 <ivanm> quicksilver: ahhh
03:04:20 <ivanm> heh
03:04:26 <quicksilver> because GHC actually stores the source for small functions
03:04:30 <quicksilver> precisely to solve this problem.
03:04:36 <quicksilver> but, if it didn't, that would be the problem.
03:04:43 <ivanm> Saizan: *nod*
03:04:54 <ivanm> mmorrow: so is it a good or a bad thing you can do that in C?
03:05:13 <mmorrow> ivanm: neither (well, it's good because it's useful), but the thing is
03:05:38 <ivanm> mmorrow: well, technically, you can write that in Haskell without knowing what asdf is as long as its defined in a module you import...
03:05:48 <mmorrow> you use, say, foldl to implement a for loop. consider a C function with 10 for loops, 5 of them 3-levels deep
03:06:05 <mmorrow> you need the whole C function to compile it of course
03:06:19 <mmorrow> but the asymmetry here is that not having access to foldl
03:06:33 <mmorrow> is like not having access to the knowledge of what a for loop compiles to
03:06:53 <mmorrow> but rather having to jump to some unknown-at-compile-time lib to implement a for loop
03:07:21 <mmorrow> that's the difficulty with haskell/functional langs
03:07:23 <Jafet> Hmm, so ghc technically already contains part of a JIT?
03:07:54 <mmorrow> Jafet: it stores the info it needs to inline at the AST level, rather than asm/lower level
03:08:30 <mmorrow> (AST for Core)
03:08:52 <Jafet> I take that as yes
03:08:56 <Saizan> no
03:09:03 <Saizan> the inlining is done statically
03:09:07 <int-e> it's a no, because all that happens at compile time
03:09:13 <Jafet> Oh, I read ghci
03:09:15 <mmorrow> well, it combines functions at a much higher than asm level
03:09:21 <Jafet> Right
03:09:35 <ivanm> mmorrow: so because less of Haskell is built-in, the compiler has trouble being smart about how to magically mash stuff together to be more efficient?
03:09:35 <Saizan> you can say that it's a whole-program compiler in disguise, though :)
03:09:36 <mmorrow> but in the sense that a JIT specializes code, it's similar yes
03:09:48 <Jafet> Actually, JIT implies a virtual machine, so I'm abusing the term regardless
03:09:52 <int-e> but it isn't. the view is always a local one
03:09:54 <mmorrow> ivanm: yeah, that's one way to say it
03:11:12 <mmorrow> ivanm: another way would be to say that a single haskell function is the equivalent (wrt a "building block" of larger things) to a block of C statements
03:11:25 <mmorrow> or a builtin loop construct
03:11:26 <ivanm> *nod*
03:12:13 <mmorrow> a C function is pretty much (wrt being a thing made of pieces) the equivalent to an entire module of haskell functions
03:14:17 <Baughn> Well, except that a four-hundred-line module of haskell functions would be a really big C function
03:14:23 <ivanm> heh
03:14:39 <ivanm> Baughn: especially being able to selectively use sections of a C function from outside of it
03:14:48 <Baughn> Mm. The analogy fails.
03:15:00 <Cale> Haskell functions whose parameters consist of all the mutable variables that each part of the C function has access to?
03:15:03 <Saizan> well, i've seen C functions of 600 lines that i've rewritten with 10 lines of haskell code
03:15:29 <Jafet> Cale, data types!
03:15:33 <mmorrow> Baughn: yeah, that also confuses things, since a single haskell function can have the complexity of 10 modules of functions too
03:15:56 <fasta> Saizan, I would love to see that one.
03:15:58 <Cale> One nice trick for translating imperative programs line by line is just to turn each line of the imperative program into a separate function, and use mutual recursion to define control flow.
03:15:58 <mmorrow> well, you could write a web browser in a single C function if you really wanted to..
03:16:10 <int-e> Saizan: I guess you get part of the effects that whole program optimization would give you. But for example no amount of aggressive inlining will allow you to notice that a big (too big to be inlined) polymorphic function is only ever used with a single type, and thus could be specialised. So when that function is exported from some module, it will always be compiled to the polymorphic version.
03:16:32 <Cale> After you turn the imperative program into a functional program, you can start manipulating and simplifying it.
03:16:37 <Baughn> Cale: For "horrifying" values of "nice". Sounds cute.
03:16:51 <Jafet> Psst, I heard google did that: main and fork
03:16:56 <Cale> I've done it before in order to understand imperative programs.
03:17:05 <mmorrow> Cale: totally, that's a good viewpoint. functions are labels, function calls are gotos, ...
03:17:20 <Cale> because I certainly wasn't going to think about what was happening to the state step by step.
03:17:23 <mmorrow> (gotos w/ formal params)
03:18:15 <mmorrow> this is essentially what SSA is actually
03:18:18 <ivanm> Saizan: because you used a whole bunch of library functions?
03:18:20 <Saizan> fasta: compare the spread.log client library with the (albeit terrible, i need to rewrite it some day) code in hspread, i was referring to the receive function specifically
03:18:33 <ivanm> mmorrow: heh (about the web browser)
03:19:47 <fasta> Saizan, if the spread library is decent C code, it would make a good show case.
03:20:30 <Saizan> ivanm: i was using network and binary
03:20:49 <ivanm> and presumably base, containers, etc.? :p
03:21:20 <Saizan> fasta: i'm no C expert :) i kind of hope it wasn't, for the good name of C
03:22:38 <ivanm> C has a good name now?
03:22:56 <Saizan> int-e: yeah, basically the users have access to extra information, but not vice versa
03:25:22 <oteren> how smart is the ghc compiler? can it change " 0 < x < 50 " into unsigned int > 50 for example?
03:26:10 <oteren> (the latter is only done with -O2 for C with gcc afaik)
03:26:22 <mmorrow> oteren: i'm not sure wrt that in particular actually
03:27:14 <mmorrow> oteren: this prog is handy to see what it's doing though
03:27:20 * mmorrow finds link
03:27:37 <mmorrow> (don's ghc core viewer)
03:27:51 <mmorrow> @hackage ghc-core
03:27:52 <lambdabot> http://hackage.haskell.org/package/ghc-core
03:28:22 <mmorrow> which cleans up and highlights -ddump-simpl and -S in a pager
03:28:29 <oteren> sweet
03:29:07 <Cale> http://www.reddit.com/r/programming/comments/21nue/how_do_you_write_the_factorial_function_totally/c21o40 -- found one! This isn't the most complicated example of where I've translated something directly from C to Haskell, but it's a fun one :)
03:36:29 <oteren> which part is you?
03:36:36 <oteren> there is no cale in the discussio
03:36:37 <oteren> n
03:36:42 <Cale> cgibbard
03:37:08 <int-e> /whois cale would help :)
03:37:12 <Cale> I translated the C code from the main link :)
03:37:13 <oteren> it really produces 42?
03:37:23 <Cale> It produces 12
03:37:32 <Cale> But a small modification of it produces 42
03:37:32 <ivanm> Cale: nah, you didn't introduce extra variables that don't do anything there! ;-)
03:37:48 <Cale> I did, I introduced n, and the parameters to fac
03:38:01 <ivanm> Cale: I meant the 'a'
03:38:05 <int-e> With that modification, i would have the values 1 -> 2 -> 6 -> 42. Yes it would.
03:38:09 <Cale> I have an a
03:38:47 <ivanm> oh, right, took me a while to work out why it's only 12... you shouldn't change the value of your incrementing variable
03:38:55 <ivanm> hmmm.... is that C or Java code though?
03:39:07 <ivanm> there's no pointers, so it can't be C! ;-)
03:39:42 <luite> 'public int factorial' suggests java
03:40:04 <ivanm> yeah
03:40:05 <int-e> or C++ *shudders*
03:40:06 <luite> the C++ syntax is a bit different
03:40:06 <Cale> Oh, I suppose it does :)
03:40:30 <Cale> All those languages are the same anyway ;)
03:40:31 <oteren> dunno if its java
03:40:38 <oteren> but it will compile in java
03:40:38 <ivanm> oteren: why not?
03:40:42 <ivanm> ahhh, right
03:41:01 <int-e> luite: oh right.
03:41:02 <ivanm> Cale: well, if the only language he learnt at uni was Java, no wonder that guy was an idiot ;-)
03:41:24 <ivanm> whilst my uni is a Java school, at least they teach you a couple of other langs in first and second year at least
03:41:54 <oteren> hey hey ivanm
03:42:01 <oteren> i've only learned java at my uni too
03:42:04 <medfly> what's wrong with only learning one language in uni? not everyone studies Cs :s
03:42:07 <medfly> CS*
03:42:11 <oteren> except this mini course that sent me into haskell and prolog
03:42:21 <ivanm> medfly: well, the point of that was about CS majors
03:42:31 <Aviator> anyone else failed to "cabal install hdbc" in haskell platform?
03:42:31 <oteren> and honestly, we're not really learning languages, but programming in general as CS majors
03:42:43 <medfly> CS teaches you programming? =)
03:42:54 <oteren> hehe
03:42:57 <sinelaw> Check out this horrible stuff:
03:42:58 <sinelaw> http://github.com/sinelaw/cext/blob/master/test.cpp
03:43:02 <fasta> Some universities skip that.
03:43:03 <sinelaw> trying to add ADT's to C
03:43:03 <medfly> just kidding! I haven't even been to uni yet
03:43:03 <Jafet> For some value of programming
03:43:05 <oteren> medfly: not if you wanna split hairs
03:43:19 <Jafet> And that's not much value
03:43:25 <oteren> i like CS over the engineering majors, because we learn more basic theory and math
03:43:26 <ivanm> Cale: anyway, the previous WTF is better ;-)
03:43:37 <ivanm> Aviator: IIRC, hdbc is bitrotted
03:43:58 * ivanm technically learnt IT, not CS... and didn't even know there was a difference until 3rd year :s
03:44:02 <Aviator> ivanm: bit wha..?
03:44:04 <sinelaw> well adding ADTs to C++ actually....still horrific
03:44:15 <ivanm> Aviator: unmaintained and no longer working with new ghc
03:44:29 <dcoutts> ivanm, Aviator: no, that's hsql, not hdbc
03:44:29 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:44:38 <ivanm> dcoutts: oh
03:44:39 <sinelaw> next thing, need to add pattern matching.
03:44:47 <dcoutts> HDBC is maintained and is the recommended option
03:44:50 <dcoutts> and it works
03:45:03 <dcoutts> Aviator: you'll need to give more details, it builds for me
03:45:06 <Aviator> but in doesn't on my setup
03:45:45 <Aviator> using ghc 6.10.4..
03:46:02 <ivanm> Aviator: paste the build output somewhere
03:46:04 <ivanm> @hpaste
03:46:04 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:46:07 <mornfall> Talking of databases, is there something to talk to LDAP?
03:46:19 <ivanm> mmorrow: you've stolen the default paste site again, have you?
03:46:20 <oteren> ivanm: i would guess the biggest difference is that i study a lot more discrete maths and stuff
03:46:23 <Aviator> ah, okay
03:46:23 <mornfall> I tried the LDAP package from hackage, but it's segfaulting ghci, so it probably isn't the best option. ; - (
03:46:29 <oteren> while the IT guys learn about running oracle databases and the like
03:46:39 <quicksilver> ivanm: HDBC is maintained by CosmicRay, who is one of the more responsive (and prolific!) hacakge authors
03:46:49 <ivanm> oteren: well, I did math and phys with IT, and did a lot of computational science courses in my IT degree
03:47:04 <ivanm> quicksilver: right, I got them mixed up, get off my back! :p
03:47:13 <ivanm> quicksilver: now, if only he ported offlineimap to haskell...
03:47:27 <oteren> yes ivanm, but that wasnt in your default study program i would guess?
03:47:41 <ivanm> oteren: yeah, I hated all the DB stuff, and our 3rd year project was a web frontend to a database *shudder*
03:47:46 <oteren> but yeah, it seems like every other uni has a different idea about what the difference between ICT, IT and CS should be
03:47:56 <ivanm> oteren: nope, but there was a fair amount of flexibility
03:48:25 <ivanm> the most CS-y course I took was an elective for software design using verification tools; it was a compulsory software engineering subject but hardly any IT students took it
03:48:25 <Cale> I like Waterloo's take on CS. It's part of the mathematics faculty.
03:48:29 <oteren> i'm about to start a masters degree in algorithms, looking forward to it
03:48:53 <Aviator> here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4455#a4456
03:48:53 <ivanm> Cale: well, here at UQ you can do CS as a major in either IT or in Science, but AFAIK the only real difference is less compulsory courses on Java
03:49:00 <oteren> classes will be 50/50 CS / math department
03:49:01 <mornfall> ivanm: Hm, last time I checked, offlineimap was a spectacular CPU hog. (But the last time was, indeed, more than 5 years ago...)
03:49:12 <ivanm> mornfall: it's not thab
03:49:17 <ivanm> *that bad
03:49:18 <mornfall> Switched to mbsync long time ago.
03:49:30 <Jafet> ivanm, compulsory Java?
03:49:35 <ivanm> but it's buggy, so much so that I took a recommendation from one site and use cron to check it's still alive every 5 minutes
03:49:46 <Cale> I really like the way that Waterloo has a mathematics faculty. It doesn't really make sense to put it under science or arts.
03:49:50 <ivanm> Jafet: if you do CS through an IT degree, you have to take the compulsory subjects including Java
03:49:58 * ivanm still doesn't understand Design Patterns
03:50:05 <fasta> Jafet, is that so weird? Lots of universities use Java as a first language.
03:50:07 <oteren> thats not CS ivanm
03:50:09 <oteren> thats ICT
03:50:09 <Jafet> I see. Thanks for the warning.
03:50:18 <oteren> or ther information science
03:50:19 <ivanm> oteren: that's my point!
03:50:30 <Jafet> Design patterns are just names
03:50:32 <mornfall> Fortunately, we have Haskell as first language. However, the course is not among the most... fortunate.
03:50:35 <oteren> i mean, i was forced to learn UML and stuff
03:50:44 <ivanm> Cale: eh, not enough prestige/funding here... the mathematics department has already lost a fair amount of rooms, and is losing even more including most of the grad school rooms :s
03:50:50 <oteren> Haskell is used for the first time ehre
03:50:50 <fasta> If I would be professor, I would just play the SICP videos ;)
03:50:52 <oteren> *here
03:50:56 <oteren> was SML up until this year
03:51:05 <fasta> There are only a few teachers who are that good.
03:51:05 <ivanm> (to be given to one of the microbial science schools and OHS :s )
03:51:24 <fasta> I had a few of those.
03:52:03 <ivanm> Aviator: hmmm.... I've seen similar Typeable instance problems before, but not just for HDBC
03:52:07 <ivanm> can't recall what the fix was though
03:52:30 <ivanm> mornfall: what's mbsync?
03:52:56 <mornfall> ivanm: A C implementation of a two-way IMAP sync.
03:53:12 <ivanm> hmmmm.....
03:53:16 <ivanm> gentoo doesnt' have it :(
03:53:17 <mornfall> It doesn't support 3-way though.
03:53:47 <ivanm> mornfall: what do you mean by 3-way?
03:54:02 <mornfall> ivanm: Keeping 3 IMAP servers in sync. :)
03:54:04 <ivanm> atm, I use offlineimap to sync from gmail to a local dovecot server, which then provides it to my mail client
03:54:15 <ivanm> mornfall: ahhh.... and offlineimap does I take it?
03:54:16 <mornfall> It used to be called isync btw.
03:54:19 <mornfall> ivanm: No idea.
03:54:29 <ivanm> ooohhh, isync I have till 1.0.4
03:54:47 <mornfall> Yeah, 1.0.4 is it.
03:54:56 <mornfall> The binary is called mbsync. But I use a locally hacked version (need GSSAPI).
03:55:13 * ivanm goes off to make a TODO list just so he can put isync on it
03:55:19 <mornfall> : - P
03:55:26 <ivanm> mornfall: why, not SSL encryption when syncing?
03:55:51 <mornfall> ivanm: Sure it does SSL. But I have kerberos tickets, so why not use them...
03:55:54 <Aviator> ivanm: i've seen more errors :)
03:55:58 <ivanm> ahhh
03:56:28 <oteren> got some sourcecode here that declares "namespace"
03:56:29 <oteren> before class
03:56:34 <oteren> what language is that?
03:56:39 <oteren> http://www.luschny.de/math/factorial/csharp/FactorialPoorMans.cs.html
03:56:52 <ivanm> mornfall: I know I had fun a couple of weeks ago when gmail kept changing it's base folder names for Spam, etc., so once I found out I updated offlineimap, had to resync _everything_... only to see it get changed again :@
03:57:14 <oteren> i prefer to not use an email any arbitrary person in google can access
03:57:29 * oteren puts on his tin foil hat
03:57:47 <ivanm> oteren: I needed a new email address to replace hotmail, and wanted one with at least POP support (which hotmail doesn't)
03:57:53 <ivanm> at the time, gmail was the best "big" option
03:57:54 <mornfall> ivanm: :) I am one of those oldfashioned guys who run their own SMTP server. (But I use that GSSAPI for work-work email, I don't run a home KDC don't worry...)
03:58:03 <oteren> and the imap function for google sucked so horrendously when i last tried
03:58:12 <ivanm> oteren: but I do agree with you about requiring a tin foil hat at times
03:58:19 <ivanm> yes, it still pretty much sucks
03:58:24 <oteren> didnt quite get how their folder naming worked
03:58:30 <oteren> it just made folders completely at random
03:58:32 <ivanm> mornfall: *nod* I don't only because I don't have a machine on all the time ;-)
03:58:34 <oteren> based on email tags
03:58:42 <ivanm> oteren: yeah, that's what it does
03:58:59 <oteren> so my email client ended up having folders popping in and out every time i went online
03:59:00 <ivanm> tbh, I quite like it, and wished I could sync it's internal state and use it in my client rather than have 2 or 3 copies of each email
03:59:02 <oteren> didnt much care for that :p
03:59:17 <oteren> i pay like 150 dollars a year for hosting
03:59:20 <oteren> and keep my mail there
03:59:48 <oteren> so i can make new adresses whenever i damn feel like it :)
04:00:01 <ivanm> but I started using offlineimap because the nice thing about POP was that you had the emails on your computer (I've once been saved by having a copy of my plane ticket in my POP'd mail when the phone subcontractor disconnected us by accident, and thus no net :s )
04:00:03 <mornfall> But, bassoon time! See y'round.
04:00:10 <ivanm> osfameron: I don't pay _anything_!
04:00:11 <ivanm> cya mornfall
04:00:18 <ivanm> s/osfameron/oteren/
04:00:20 <ivanm> sorry osfameron
04:00:36 <ivanm> mornfall: you play it, listening to it, or using it as a random "I'm getting out of here" excuse? :P
04:00:41 <oteren> hum
04:00:51 <oteren> cant all clients for imap be set to store locally as well?
04:00:54 <oteren> thats always how i do it
04:00:57 <mornfall> ivanm: Play.
04:00:58 <oteren> i read the email on my laptop
04:01:02 <oteren> then just open it at the airport
04:01:09 <oteren> and the mail is accessible
04:01:24 <oteren> thats default in the Os/x Mail.app
04:01:29 <oteren> same in thunderbird afaik
04:01:30 <ivanm> oteren: not all clients seem to cache imap
04:01:53 <ivanm> I was using claws at the time; dont' know if it was gmail's dodgy implementation, but claws blowed at getting gmail imap
04:02:32 <Aviator> nvm. installing an older version solved the problem
04:02:41 <sinelaw> @type runST
04:02:42 <lambdabot> forall a. (forall s. ST s a) -> a
04:03:02 <oteren> never even heard of claw :p
04:03:11 <ivanm> claws-mail.org IIRC
04:03:38 <ivanm> I stopped using it because it wasn't all that keyboard-friendly, and the popup dialog to change folder kept increasing in size under xmonad... :s
04:04:48 <sinelaw> i'm using mozilla thunderbird, and it supports both imap mail and google calendar
04:04:58 <sinelaw> (with a plugin for the calendar)
04:06:09 * ivanm is using gnus atm
04:21:02 <sinelaw> @src runST
04:21:02 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
04:21:12 <sinelaw> @src newSTRef
04:21:12 <lambdabot> newSTRef init = ST $ \s1# ->
04:21:13 <lambdabot>     case newMutVar# init s1# of { (# s2#, var# #) -> (# s2#, STRef var# #) }
04:23:18 <sinelaw> am I the only one who can
04:23:23 <sinelaw> .....can't read that
04:23:24 <sinelaw> ?
04:23:57 <Cale> sinelaw: You're not supposed to read it.
04:24:05 <Cale> sinelaw: I don't know why it's even in the bot ;)
04:24:17 <Cale> sinelaw: These are primitive things.
04:24:51 <Cale> That code is a sort of lower-level Haskell code used by GHC to implement newSTRef.
04:25:01 <sinelaw> Cale, so I guess I'm misunderstandig...STRef actually uses side effects? i thought  it doesn't
04:25:11 <Cale> Its implementation does.
04:25:27 <sinelaw> ah, so it's an optimization?
04:25:30 <Cale> yeah
04:25:45 <sinelaw> but in theory it's possible to implement it purely.
04:25:55 <Cale> Well, it's also kind of hard to implement without some hacky things involving the types.
04:26:18 <sinelaw> yeah i was wondering how it decides what the type of the state is
04:27:36 <sinelaw> Cale, so I cant implement an imperative algorithm with ST and the complexity  is expected to be the same?
04:27:40 <Cale> You could make a pure interpreter which constructed some kind of explicit heap of the values of all existing STRefs, but it would probably have to do some unsafeCoerce'ing.
04:27:54 <Cale> You can.
04:29:59 <Cale> The fact that the type system prevents STRefs from escaping the clutches of runST means that you get a guarantee of purity too.
04:30:24 <Cale> So you can implement pure algorithms imperatively, and nobody has to know.
04:31:32 <Cale> However, typically I will opt out of using ST unless it really seems necessary to get the constant factor I'm looking for.
04:32:04 <Cale> Essentially all imperative algorithms can be encoded using things like Data.Map in place of a heap of mutable state.
04:38:47 <sinelaw> still, not a bad solution conceptually. the stuff you do with ST is _implemented_ imperatively, but it's a pure description of an imperative algorithm
04:39:13 <sinelaw> and you get the assurance that it doesn't have any other side effects
04:39:16 <sinelaw> (or do you?)
04:39:36 <Saizan> unless you use unsafeIOtoSTM
04:39:49 <Saizan> err, s/STM/ST/
04:40:35 <FunctorSalad> as I understand it, the only thing that makes it not implementable purely is that the type of the state is not fixed like in the State monad
04:40:54 <sinelaw> FunctorSalad, that's what i'm guessing too
04:41:23 <sinelaw> btw, does ghc have a warning for using unsafe stuff?
04:41:57 <SamB_XP> sinelaw: 'tis called "grep"
04:42:30 <sinelaw> :( would be nice if anything that calls anything .... that calls anything unsafe, gets a warning.
04:42:47 <SamB_XP> no, no it wouldn't!
04:43:13 <Cale> sinelaw: There would have to be a way to cut that off explicitly though.
04:43:20 <oteren> hmm
04:43:26 <oteren> i found this mailing list i wanted to be on
04:43:29 <sinelaw> why?
04:43:32 <Cale> sinelaw: Because the unsafe stuff is there in order to give you ways to construct new safe primitives.
04:43:44 <sinelaw> how can you go from unsafe to safe?
04:43:46 <oteren> then i got a mail back saying i'm put on there, which i accidentally replied to
04:43:51 <Cale> Without going to the trouble of modifying GHC.
04:43:53 <oteren> which then replied to me again that i should not reply to this address
04:43:57 <Cale> sinelaw: By proving something.
04:43:59 <oteren> i then put that address on the mailing list
04:44:04 <oteren> ..and now it stopped sending mails
04:44:16 <sinelaw> oteren, :) nasty
04:44:38 <oteren> one should think that there would be a die; on a check of this
04:44:42 <oteren> but yeah
04:44:43 <oteren> haha
04:44:48 <Cale> sinelaw: Or at least having a suspicion that you could prove that things are referentially transparent.
04:45:38 <sinelaw> ok, but that's not a common thing to do, is it? i'm more concerned about how my beautiful program is not really as pure as i think
04:45:46 <mmorrow> consider
04:45:50 <mmorrow> let a = runST (newSTRef 0); b = runST (readSTRef a) in .... runST (do writeSTRef a 1000000) {- now b == 10000000 !! -} .......
04:46:08 <Cale> sinelaw: The unsafe things are essentially only there for that purpose.
04:46:28 <mmorrow> that's impossible, and is impossible ONLY because there's only a (runST :: forall s. ST s a -> a)
04:46:31 <Cale> sinelaw: There are many many things in the basic libraries where unsafePerformIO gets used to implement low-level datastructures.
04:46:44 <mmorrow> and the "forall s." is what makes that impossible, because it can't be type correct
04:47:10 <Cale> sinelaw: Consider implementing pure immutable arrays using explicitly allocated chunks of memory.
04:47:34 <Saizan> mmorrow: except that you lack a pair of parens there
04:47:40 <Cale> You need a way to do some impure stuff even though in the end, the interface will only provide a pure view of things.
04:47:48 <mmorrow> ST is related to Clean's "uniqueness types", in the sense that what it's really doing is enforcing that there can't be two aliasing references that both point to a mutable thing
04:48:08 <mmorrow> Saizan: heh
04:48:16 <mmorrow> the difference with Clean though is
04:48:58 <mmorrow> that instead of passing an imaginary "state" token around (the `s' in forall s), in Clean the state token IS the data that's being mutated
04:49:04 <sinelaw> now i understand what all the unsafe stuff is doing there
04:49:24 <sinelaw> but i'm still afraid that i'm using something that's actually not pure
04:49:41 <sinelaw> (not conceptually pure even)
04:49:52 <SamB_XP> sinelaw: don't worry so much
04:49:54 <mmorrow> and since the state token/data-in-clean can only be referenced in a linear way by construction, you can mutate inside ST/the data
04:50:13 <mmorrow> sinelaw: it's impossible to do that and be type-correct
04:50:28 <sinelaw> why? I'm not talking only about ST
04:50:30 <SamB_XP> mmorrow: he's worried about unsafePerformIO, I think
04:50:31 <mmorrow> so unless you're unsafeCoerce'ing, you're ok
04:50:43 <mmorrow> sinelaw: oh, what are you talking about?
04:50:44 <mmorrow> ah
04:50:45 <sinelaw> what if the library i'm using is doing something nasty
04:51:49 <SamB_XP> sinelaw: some crazy library you downloaded from the outskirts of hackage?
04:51:53 <mmorrow> sinelaw: safety is just an illusion that's created by opaque interfaces
04:51:56 <SamB_XP> I guess you'll just need more grep
04:52:01 <sinelaw> :)
04:52:06 * ManateeLazyCat .hs-boot file make me crazzzzzzzzzzzzzzzzzzy.
04:52:17 <Saizan> summon the referential transparency ninjas
04:52:26 <SamB_XP> ManateeLazyCat: those, at least, don't mess with referential transparency ;-)
04:53:18 <ManateeLazyCat> Don't let user poll it if GHC don't want fix it.
04:53:20 <SamB_XP> Saizan: but they can't do anything to anybody!
04:54:22 <Saizan> SamB_XP: they just make so you evaluate to a horrible, horrible, death
04:54:25 <ManateeLazyCat> SamB_XP: .hs-boot problem can't avoid if you programming Gtk+ with Haskell.
04:55:23 * ManateeLazyCat 54 files in my project with .hs-boot problem, crazy me....
04:56:15 <ManateeLazyCat> Who invent .hs-boot ?
04:56:41 <FunctorSalad> SamB_XP: is grepping for 'unsafe' safe? ;)
04:56:49 <SamB_XP> FunctorSalad: what do you mean ?
04:57:13 <FunctorSalad> SamB_XP: whether there is any way to do unsafe stuff without having the string 'unsafe' in your code
04:57:19 <FunctorSalad> or importing libs who do that
04:57:52 <SamB_XP> don't think there is
04:58:04 <SamB_XP> well, to be safe, you should use -i
04:58:54 <Saizan> it should be easy with TH
04:59:05 <FunctorSalad> oh right
04:59:18 <quicksilver> FunctorSalad: yes, import Data.Typeable + Data.Dynamic gives you access to more or less anything you want.
04:59:20 <SamB_XP> :-(
04:59:20 <Saizan> but maybe you'd get Unsafe by the modules
04:59:41 <quicksilver> at least, that gives you unsafeCoerce
04:59:54 <quicksilver> not sure if it can be twisted to give unsafePerformIO
05:00:17 <FunctorSalad> but isn't the interface revealed by Typeable safe?
05:00:18 <Saizan> i think so, with runST
05:00:20 <FunctorSalad> due to the Maybe
05:00:45 <Saizan> it'd be if you couldn't make a cheating Typeable instance
05:00:48 <mmorrow> FunctorSalad: you can lie in Typeable instances
05:00:50 <FunctorSalad> (but might still break parametricity?)
05:01:03 <FunctorSalad> mmorrow: ah
05:02:51 <FunctorSalad> , $(varE (mkName (reverse  "OImrofrePefasnu")))
05:02:52 <lunabot>  luna: Not in scope: `unsafePerformIO'
05:02:58 <FunctorSalad> hehehe
05:05:04 <FunctorSalad> mmorrow: why is it called lunabot?
05:05:21 <mmorrow> FunctorSalad: to be honest i don't remember :)
05:05:23 <mmorrow> oh
05:05:38 <mmorrow> i do, it's because i got the domain name moonpatio.com
05:05:51 <mmorrow> and lunabot's running there
05:06:05 <quicksilver> ManateeLazyCat: surely that's not true? gtk+ requires recursive modules, how?
05:06:08 <quicksilver> dcoutts: tell me it's not true!
05:06:11 <FunctorSalad> mmorrow: :)
05:06:22 <mmorrow> well, i got moonpatio.{com,info,org}, and lunabot's at .info (which hpaste points to too)
05:06:26 <dcoutts> quicksilver: it's not true :-)
05:06:28 <FunctorSalad> /nick lunaticbot
05:06:43 <quicksilver> dcoutts: thanks.
05:07:26 * dcoutts has no idea what ManateeLazyCat is taking about wrt .hs-boot
05:07:27 <ManateeLazyCat> quicksilver: I'm now develop gtk2hs program, sometimes i need some Center module communication different module, then got recursive modules.
05:07:27 <int-e> quicksilver: how about this: gtk+ needs ghc which relies on recursive modules ... somewhere? :)
05:07:28 <SamB_XP> so, what *is* a moon patio anyway ?
05:07:51 <quicksilver> ManateeLazyCat: I don't believe that is in any way required.
05:07:57 <dcoutts> nor do I
05:07:58 <quicksilver> ManateeLazyCat: that's a design decision you have made.
05:08:02 <quicksilver> (probably a bad one in my opinion ;)
05:08:13 <dcoutts> I've developed non-trivial GUIs with Gtk2Hs
05:08:23 <mmorrow> SamB_XP: i was trying to think of a domain name that wasn't (1) really long, (2) that sucked, (3) something like <somecoolname>2234.com
05:08:32 <mmorrow> SamB_XP: i randomly thought of that
05:08:41 * ManateeLazyCat pasted "IORefObject.hs" at http://paste2.org/get/479506
05:08:48 <ManateeLazyCat> quicksilver: Above is Center module for communication different module.
05:08:57 <SamB_XP> mmorrow: that's irrelevant to my question!
05:08:59 <mmorrow> (after about 100 whois queries)
05:09:13 <mmorrow> SamB_XP: it's whatever you want it to be ;)
05:09:27 <ManateeLazyCat> quicksilver: I must use IORefObject to make different module keep some data synchronous.
05:09:47 <dcoutts> ManateeLazyCat: there's no need for the view to know about the controler
05:10:03 <ManateeLazyCat> quicksilver: I don't know how to develop gtk2hs program that never need center control module.
05:10:06 <dcoutts> the view does not need to know about the state of the application
05:10:10 <quicksilver> put the types in different modules from the code, ManateeLazyCat
05:10:27 <dcoutts> and don't have the view take the state bundle type
05:10:33 <quicksilver> the IORefObject modules may need access to the *types* of ViewList, ViewNodeList and so
05:10:42 <quicksilver> but it shoudln't need access to the code that works on them
05:10:47 <dcoutts> but not vica-versa
05:11:10 <quicksilver> sometimes it's simpler to put the types in one module Manatee.UI.ViewTypes
05:11:16 <ManateeLazyCat> quicksilver: I always transform IORefObject instance to different module in Main.hs
05:11:27 <quicksilver> (if a substantial proportion of them are mutually recursive types)
05:12:10 <SamB_XP> he's reimplementing himself in as a Gtk app?
05:12:14 <ManateeLazyCat> quicksilver: When i use IORefObject control different module that need synchronous, other modules recursive reference.
05:12:34 <mmorrow> ghc has recursive modules, which imo makes arguments that they aren't needed/useful less convincing :)
05:13:11 <dcoutts> ManateeLazyCat: why does Manatee.UI.* need the Manatee.IORefObject module?
05:13:25 <SamB_XP> yeah, but you probably don't need the 74 that ManateeLazyCat said he has ...
05:13:39 <SamB_XP> 74 .hs-boots, I mean
05:13:48 <quicksilver> mmorrow: they aren't *often* needed, they aren't *often* useful, and they are *often* bad code smell.
05:14:39 <mmorrow> quicksilver: quite the *often* assault i must say :)
05:14:57 <mmorrow> (i agree)
05:15:13 <ManateeLazyCat> dcoutts: Because, i'm developing IDE that need split current screen, so i need reference ioRefObject for synchronous ViewList when i add new View.
05:15:46 <mmorrow> but when they are, any workarounds are project-restructuring or excessive parameterization
05:16:46 <dcoutts> ManateeLazyCat: in the GUIs I've built, the view just provides a bunch of callbacks for interesting events. The interaction logic then connects to all the callbacks and is the bit that holds the state.
05:16:52 <mmorrow> dcoutts: (i saw a graphviz-rendered module graph of his project) he's got at least 50 modules
05:17:04 <mmorrow> so it's definitely a non-trivial situation
05:17:13 <dcoutts> it can be done incrementally
05:17:31 <dcoutts> to convert a view module into a form that does not depend on the state of the application
05:18:05 <quicksilver> ManateeLazyCat: anyhow, you're totally wrong to say ".hs-boot problem can't avoid if you programming Gtk+ with Haskell"
05:18:20 <quicksilver> you've chosen the recursive module solution but it isn't necessary, nor the only solution.
05:18:27 <ManateeLazyCat> quicksilver: Sorry, for my bad English.
05:18:42 <SamB_XP> mmorrow: did I misremember the number of .hs-boot files he'd stated ?
05:19:09 <mmorrow> SamB_XP: i meant total number of modules, not number of boot modules/files
05:19:11 <SamB_XP> ManateeLazyCat: he's not arguing about your bad english ;-)
05:19:18 <SamB_XP> mmorrow: yeah, I gather that
05:19:32 <mmorrow> SamB_XP: ah, then i don't know what you're referring to
05:20:01 <ManateeLazyCat> quicksilver: Yes, if GHC developer  need .hs-boot file to fix recursive problem, it's better. isn't?
05:20:02 <SamB_XP> but above I said 74 .hs-boots ... which is a bit more than 50 ;-P
05:20:10 <ManateeLazyCat> s/need/don't need
05:20:34 <mmorrow> SamB_XP: ah, yeah i was being conservative in my guesstimate (and that was a month or two ago when i saw his module graph)
05:20:53 <SamB_XP> ManateeLazyCat: without those .hs-boot files, compiling would be a lot slower!
05:21:08 <int-e> with recursive modules but without .hs-boot files, you'd have to type check multiple modules at the same time, which goes against ghc's one-module-at-a-time compilation strategy.
05:21:38 <ManateeLazyCat> SamB_XP: But have .hs-boot, it make me crazy, i have 54 files in my project.
05:22:06 <mmorrow> int-e: "module-at-a-time... oh yeah, and portions of the code for every module this module references"
05:22:23 <Axman6> :t print <$> fst
05:22:24 <lambdabot> forall a b. (Show a) => (a, b) -> IO ()
05:22:40 <quicksilver> ManateeLazyCat: well, GHC developers might make wrong decisions too, so I might consider their use of recursive modules wrong too.
05:22:42 <dancor> :t print . fst
05:22:43 <int-e> mmorrow: you mean inlining? at least that doesn't get circular ;)
05:22:43 <lambdabot> forall a b. (Show a) => (a, b) -> IO ()
05:22:49 <mmorrow> int-e: true
05:22:57 <quicksilver> but even if I don't, the fact that the technique is right in *one* context doesn't make it right in every context :)
05:23:30 <Axman6> huh, main = print <$> fst <$> runWriterT (sum' 100000000 0) is just main = print . fst . runWriterT . sum' 100000000 $ 0 right?
05:24:21 <Cale> Is this still that stack overflow program?
05:24:41 <Axman6> it is, yes
05:24:56 <Axman6> i opened the link before i left, and only just looked at it
05:24:57 <ManateeLazyCat> quicksilver: .hs-boot can fix recursive problem, but when project module is too many, it give me unused import information, that haven't any help with big project.
05:25:04 <Cale> ah
05:25:24 <ManateeLazyCat> quicksilver: If draw some patch Graphics, then point which path is wrong, that's maybe help.
05:25:34 <Cale> It's a bit funny to use WriterT over IO in the first place.
05:25:57 <Axman6> Cale: so am I right? <$> = fmap = (.)?
05:26:14 <Cale> Uh, the original program gives main the type IO (IO ())
05:26:27 <Axman6> oh
05:26:50 <Cale> You can't  fst . (runWriterT ...)
05:26:54 <ivanm> hey Axman6
05:26:58 <Cale> But apart from that
05:26:59 <Axman6> 'lo
05:27:08 <Cale> one of the <$>'s can be a (.)
05:27:13 <Axman6> yeah
05:27:20 <Cale> (as is always the case when you have more than one)
05:27:45 <Cale> fmap f . fmap g = fmap (f . g)
05:28:05 <Cale> So,  f <$> g <$> x = f . g <$> x
05:28:14 <Axman6> was it you who made (++) = mappend?
05:28:17 <Cale> yeah
05:28:26 <ivanm> @slap Cale
05:28:26 * lambdabot throws some pointy lambdas at Cale
05:28:27 <ivanm> ;-)
05:28:33 <Cale> It's a much prettier name for such an important operation.
05:28:48 <Cale> In fact, I believe in that change much more strongly than (.) = fmap
05:29:21 <Cale> The people who want (.) = (Control.Category..) have a decent point.
05:29:21 <int-e> > concat [Just 1, Nothing]
05:29:23 <lambdabot>   Couldn't match expected type `[a]'
05:29:23 <lambdabot>         against inferred type `Data.Mayb...
05:29:23 <Axman6> well, it's really annoying when you're expecting (++) to have the tpye of (++)
05:29:23 <ManateeLazyCat> dcoutts: Thinking about callback solution....
05:29:48 <int-e> (I know, it's msum)
05:29:51 <ManateeLazyCat> dcoutts: Now, many modules in my project need IORefObject for keep state reference.
05:30:20 <dcoutts> ManateeLazyCat: eg view <- FooView.new FooView.Actions { FooView.thingyUpdate = \x -> ...
05:32:49 <Cale> int-e: Oh, good point, I hadn't changed that :)
05:33:28 <Cale> > sortBy (comparing length ++ compare) (words "here are some words for you")
05:33:30 <lambdabot>   ["are","for","you","here","some","words"]
05:34:54 <ManateeLazyCat> dcoutts: You have time to review my source code, i think it's have many problem, i want your suggestion help me improve design, though i know you're very busy, but just few haskeller have gtk2hs experience can help me.
05:35:14 <paolino> what is the fixity of `mplus` ?
05:36:23 <paolino> or how does it work mixing `mplus` and >>=  ?
05:36:33 <dcoutts> ManateeLazyCat: if it's quick
05:36:36 * ToRA just realises that Monoid b => Monoid (a -> b)
05:36:42 <ManateeLazyCat> dcoutts: Okay.
05:36:48 <ToRA> Cale: thanks, I now have to go refactor a ton of code :p
05:37:23 <dcoutts> paolino: it's the default fixity for functions
05:38:07 <paolino> dcoutts so it's higher than any binary operator ?
05:39:36 <dancor> :t (++)
05:39:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:39:49 <paolino> ((right t `mplus` parent) >>= process f) `mplus` Just t -- here I can erase the inner ones ?
05:39:55 <dancor> :t comparing
05:39:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:40:26 <dcoutts> paolino: no the default for when used in the `style`
05:40:52 <mercury^> What's the correct way to do this:
05:40:53 <mercury^> type Foo a b = Nat -> Nat
05:40:54 <mercury^> instance Category Foo where
05:40:55 <dancor> what's the monoid instance of Char -> Char -> Ordering
05:41:06 <dcoutts> paolino: when used as a prefix function then yes it's higher than all operators, as usual
05:41:29 <dancor> > (comparing length ++ compare) "a" "a"
05:41:30 <lambdabot>   EQ
05:41:30 <dcoutts> paolino: you can ask ghci :i mplus. It reports no special fixity, so it's the defaults.
05:41:36 <dancor> > (comparing length ++ compare) "a2" "a1"
05:41:37 <lambdabot>   GT
05:42:35 <ManateeLazyCat> dcoutts: I have send source code to you, if you want compile it, you need darcs version of gtk2hs, because i use VTE code in darcs version. Thanks!
05:42:57 <dcoutts> ManateeLazyCat: I'll look at it but not compile it
05:43:16 <ManateeLazyCat> dcoutts: Thanks.
05:43:22 <paolino> dcoutts : how do I get the defaults ?
05:43:35 <paolino> from ghci ?
05:44:08 <ManateeLazyCat> dcoutts: Reboot.hs Core.hs control recompile itself and don't need reboot.
05:44:30 <ManateeLazyCat> Data subdir is pure sub-library for project.
05:44:48 <ManateeLazyCat> `Event` subdirectory for handle Event.
05:44:50 <dcoutts> paolino: it's given in the H98 report
05:44:50 <Baughn> When I've got a "negotiate :: StateT Peer IO ()".. is it possible to have multiple function clauses, with guards reading the actual state?
05:45:15 <ManateeLazyCat> `Keymap` subdirectory for handle keymap for local or global mode.
05:45:57 <ManateeLazyCat> `PageMode` subdirectory for different page mode, such as, Haskell-Mode, C-Mode, Browser-Mode.etc.
05:46:35 <ManateeLazyCat> `PageView` subdirectory for speical Page implement, such as, editor, file-manager, terminal.
05:47:17 <ManateeLazyCat> `State` subdirectory for pick up `pure state` for keep state through reboot.
05:48:09 <Baughn> @hoogle Monad m => m Bool -> m () -> m ()
05:48:09 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
05:48:09 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
05:48:09 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
05:48:10 <ManateeLazyCat> `UI` subdirectory like it's name for control UI draw, and those modules depend IORefObject.hs.
05:48:34 <Baughn> @djinn Monad m => m Bool -> m () -> m ()
05:48:35 <lambdabot> f _ a = a
05:48:35 <ManateeLazyCat> `Utils` subdir is contain many Utils function for different purpose.
05:49:04 <ManateeLazyCat> `Widget` subdirs contain some speical Widget for build UI.
05:51:18 <ManateeLazyCat> dcoutts: I use reference IORefObject everywhere, though I just declare it in main (), but it really like `Global variable` because i transform to most modules.
05:52:05 <ManateeLazyCat> dcoutts: I think it's bad design that make most modules depend IORefObject, just haven't idea how to improve it.
05:52:38 <ManateeLazyCat> dcoutts: Because IORefObject module, you can find have many .hs-boot files in my project.
05:56:31 <ManateeLazyCat> dcoutts: In IORefObject.hs file, IORefObjectViewList and IORefObjectViewNodeList for control screen split handle, like below screenshot. http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
05:56:57 <ManateeLazyCat> It split screen to 5 View.
05:58:31 <ManateeLazyCat> dcoutts: Every View contain notebook, so it use notebook contain many Page in one View.
05:59:10 <ManateeLazyCat> dcoutts: Many view have some Page List.
05:59:23 <dcoutts> ManateeLazyCat: how about moving the ioRefObjectNew out of Manatee.IORefObject
05:59:36 <dcoutts> ManateeLazyCat: or moving IORefObject into a separate Manatee.IORefObject.Type
06:01:43 <dcoutts> ah, I see, the problem is your state refers to all the types
06:01:45 <dcoutts> and that gets passed to each view
06:01:57 <dcoutts> tying everything together
06:02:02 <ManateeLazyCat> dcoutts: When my project start, it haven't IORefObject, but i found i need write `long` argument list for transform IORef argument to function, so i create IORefObject.
06:02:39 <dcoutts> ManateeLazyCat: so my main suggestion there is to separate the presentation/view parts from the interaction/state
06:02:51 <ManateeLazyCat> dcoutts: If split IORefObject with IORefObject.Type, it less depend, but it's hard to coding with different modules, too long argument list.
06:03:08 <dcoutts> ManateeLazyCat: the interaction/state will then refer to the various views, but the views will then not need to refer to each other.
06:03:52 <dcoutts> the problem currently is that each event handler in each view has a direct reference to all other views in the whole system
06:06:05 <dcoutts> ManateeLazyCat: to partition the view from the state/interaction stuff I use a pattern like:
06:06:06 <dcoutts>   new :: Actions -> IO View
06:06:14 <dcoutts> Actions is a record of callbacks
06:06:32 <dcoutts> View is an abstract type but it holds various key widgets in the view
06:06:44 <dcoutts> so then other methods look like: doSomething :: View -> IO ()
06:06:45 <ManateeLazyCat> dcoutts: Looks is good idea, but never use Actions before, i try to understand what's you mean.
06:07:18 <dcoutts> the key point is that the onButtonPress or whatever for widgets in the view do not need to know who they are calling
06:07:29 <dcoutts> they just call the callback function passed in when the view was constructed
06:07:42 <dcoutts> your interaction logic then makes the view and sets all the callbacks
06:08:49 <dcoutts> the key point is that ViewA knows nothing about ViewB etc
06:12:16 * ManateeLazyCat Thinking about dcoutts suggestions, use callback instead IORefObject communication different module.....  
06:22:42 <ManateeLazyCat> dcoutts: I'm not sure i understand you mean completely. So i give a example for describe my understand. In IORefObject.hs i have ioRefObjectPageCounter, it ticker when new Page create, current implement is transform IORefObject to function `pageAdd` (Manatee/UI/Page.hs) for ticker ioRefObjectPageCounter. So if we use state/interaction implement, we can generate signal `afterPageAdd`, just ticker `ioRefObjectPageCounter` when recive
06:22:42 <ManateeLazyCat> signal `afterPageAdd` in IORefObject.hs, but Page.hs know nothing about IORefObject. I catch your point?
06:24:52 <ManateeLazyCat> s/recive signal/recevie signal
06:24:57 <dcoutts> ManateeLazyCat: right
06:29:17 <ManateeLazyCat> dcoutts: In state/interaction design model, we still use IORefObject catch below modules signal for center control, but below modules know nothing about IORefObject, then we fix recursive reference problem, right?
06:30:57 <dcoutts> ManateeLazyCat: the IORefObject depends on all the views, but the View modules depend on very little so there's no recursion
06:41:24 <ManateeLazyCat> dcoutts: I can't understand 'new :: Actions -> IO View', how to generate signal that make IORefObject can catch it? Can you more detail?
06:43:07 <hackagebot> curry-base 0.2.6 - Functions for manipulating Curry programs (BerndBrassel)
06:43:15 <dcoutts> ManateeLazyCat: when constructing the view you call the function from the Actions record
06:43:29 <dcoutts> ManateeLazyCat: when calling new from outside, you pass in the actions you want to be called
06:48:34 <jystic> what does it mean when ghc says "No instances for (Bar m) arising from a use of 'foo' at ..."?
06:49:18 <zygoloid> jystic: it means that in order to use 'foo' you need an instance of Bar m, and there isn't an instance of Bar m available
06:50:16 <zygoloid> jystic: probably you need to add Bar m to the context of whatever function contains the use of 'foo'.
06:50:46 <jystic> ok, so it just wasn't able to infer the types?
06:51:15 <jystic> I'll give the specific example
06:51:15 <ManateeLazyCat> dcoutts: Thanks for your help, i will refactory my code.
06:51:18 <Baughn> jystic: If you have an explicit type signature, Haskell will never override it. It may detect conflicts, in which case you get errors like that.
06:51:36 <Saizan> this might be caused by the MR
06:51:37 * ManateeLazyCat It's a really big refactory work, but worth to do it.....
06:51:48 <jystic> test = fileServe ["test.html"] "."
06:51:57 * oteren ponders ManateeLazyCats use of third person irc mode
06:52:18 <jystic> where fileServe has the type
06:52:19 <Saizan> jystic: what's the type of fileServe?
06:52:48 <jystic> fileServe :: (WebMonad Response m, ServerMonad m, FilterMonad Response m, MonadIO m) => [FilePath] -> FilePath -> m Response
06:53:13 <Saizan> yeah, it's the monomorphism restriction.
06:53:34 <dcoutts> oteren: you mean you don't talk about yourself in the third person? :-)
06:54:06 <Saizan> jystic: add a type signature to your "test" or add {-# LANGUAGE NoMonomorphismRestriction #-} to your module
06:54:44 <jystic> Saizan: thanks, what's the most accepted way of doing this?
06:55:27 * Saizan still doesn't see why they introduced all those typeclasses
06:55:49 <Saizan> jystic: well, the latter is easier and more general
06:56:16 <oteren> dcoutts: hehe, he just took a regular sentence and put /me in front of it! considering i am in the internet etiquette police, it is my prerogative to tell him
06:56:47 <jystic> Saizan: yeah the later seems cleaner to me
06:57:47 <dcoutts> oteren: hmm, I wonder if I could join the internet etiquette police, I have a qualification in pedantry
06:57:54 <zygoloid> GHC's usually pretty good at saying "possibly caused by the monomorphism restriction applied to..."
06:58:08 <zygoloid> dcoutts: pure mathematician?
06:58:13 <int-e> jystic: you can do both.
06:58:25 <FunctorSalad> pure math isn't really pedantry is it?
06:58:38 <dcoutts> FunctorSalad: it's not just pedantry
06:58:49 <FunctorSalad> you gloss over stuff as soon as you've grasped it
06:58:53 <jystic> is there any reason why you wouldn't always use the no monomorphism declaration at the top of a module?
06:59:08 <FunctorSalad> it's really "as much pedantry is necessary, as much informality as possible" no?
06:59:37 <lucky__> help; what's the correct way to write this code: http://codepad.org/9yFwXSjM
06:59:38 <zygoloid> jystic: you might want to wait for haskell' to turn the DMR off by default :)
06:59:52 <oteren> dcoutts: please cat your application to /dev/null and we will look at it shortly
06:59:52 <FunctorSalad> or make an emacs yasnippet for it
06:59:59 <FunctorSalad> I have snippets for most lang pragmas..
07:00:06 <FunctorSalad> -xnmr <tab>
07:00:11 <Saizan> jystic: the MR is a strong warning about the fact that polymorphic values won't get shared even if they don't have formal parameters
07:01:21 <Saizan> lucky__: inp <- fmap lines . ...
07:01:34 <zygoloid> @type print . lines =<< readFile . head =<< getArgs
07:01:35 <lambdabot> Not in scope: `getArgs'
07:01:58 <jystic> Saizan: shared in what sense? (sorry i'm still pretty new, perhaps I should just google 'monomorhpism restriction' so i don't waste everyones time :)
07:02:19 <lucky__> can you explain why fmap should work while =<< does not?
07:02:21 <Saizan> jystic: in the sense of being computed only once
07:03:14 <FunctorSalad> jystic: if you do a top-level "x = 1+1 :: Int"  that is computed only once
07:03:19 <Saizan> jystic: e.g. let x = sum [1..100000000] in (x,x), here x gets a monomorphic type because of MR and because of defaulting that type is Integer
07:03:20 <FunctorSalad> apparently the polymorphic variant is
07:03:27 <FunctorSalad> (even if accessed at the same type?)
07:03:33 <Saizan> jystic: in that case the sum is only computed once
07:03:57 <jystic> yep
07:04:08 <FunctorSalad> what if you have -XNMR but a specialize pragma?
07:04:12 <Saizan> jystic: if instead you add a signature let x :: Num a => a; x = sum [1..1000000000] in (x,x), the sum is computed twice
07:04:15 <FunctorSalad> or automatic spec by ghc
07:04:34 <Cale> It has to do with the fact that typeclasses are implemented using functions, and functions are *not* automatically memoised.
07:04:39 <oteren> http://thedailywtf.com/Articles/Tenth-Times-The-Charm.aspx
07:04:40 <oteren> haha
07:04:46 <oteren> Cale: i thank you
07:04:51 <oteren> havent read dailywtf in several years
07:04:57 <oteren> been reading for couple of hours now
07:05:13 <jystic> ok, I understand :)
07:05:39 <Saizan> lucky__: well the types wouldn't match for >>=, lines is a pure function
07:05:44 <Saizan> ?type fmap
07:05:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:05:59 <Cale> jystic: But mostly, the MR is just a massive pain.
07:06:13 <lucky__> ?type liftM_
07:06:14 <lambdabot> Not in scope: `liftM_'
07:06:23 <jystic> so if you said let x :: Int instead of Num a => a then x would only be calculated once
07:06:44 <Saizan> ?type liftM -- this is the same as fmap, but implemented using >>= and return
07:06:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:06:49 <Cale> jystic: and it certainly has no place being in the standard. It's the only thing in the standard which can only be justified by the particular operational semantics of an implementation.
07:06:51 <Saizan> ?src liftM
07:06:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:06:53 <FunctorSalad> a spec pragma would be nicer for performance stuff
07:07:02 <Cale> jystic: yeah
07:07:13 <lucky__> ?src fmap
07:07:13 <lambdabot> Source not found. It can only be attributed to human error.
07:07:45 <Saizan> fmap is the method of the Functor typeclass, it doesn't have a general definition
07:08:15 <jystic> Cale: so there's nothing stopping a particular compiler from doing memoization?
07:08:26 <lucky__> so for the IO monad fmap and liftM does the same thing?
07:08:28 <FunctorSalad> it ought to do the same stuff for every monad
07:08:41 <FunctorSalad> liftM is mostly so you can define fmap=liftM for a moanad
07:08:51 <Cale> jystic: right, apart from the fact that it needs to solve a very hard problem in general to decide if it's worthwhile
07:09:05 <lucky__> what is the difference between the two then?
07:09:31 <jystic> Cale: yep, i can imagine
07:09:32 <Cale> (and it's usually not)
07:10:11 <zygoloid> lucky__: it's my understanding that for a law-abiding instance of both Functor and Monad, fmap and liftM must be identical (as a consequence of the uniqueness of fmap)
07:10:35 <zygoloid> one difference is the context; if you're given a (Monad m) => m a, you can apply liftM to it but not fmap
07:11:18 <burp> and <*> = ap
07:11:27 <quicksilver> I think it's impossible for a type of kind * -> * to have more than one interesting fmap choice anyway
07:11:28 <burp> for applicatives
07:11:34 <quicksilver> (where 'interesting' means 'total', roughly)
07:11:34 <zygoloid> burp: that doesn't follow, and isn't true for Either e
07:11:43 <burp> zygoloid: for monads
07:11:54 <lucky__> oh okay i see now
07:11:55 <zygoloid> burp: it isn't true for Either e
07:11:58 <burp> oh?
07:11:59 <quicksilver> so liftM and fmap are forced to agree because they are both unique.
07:12:00 <burp> hm
07:12:33 <zygoloid> quicksilver: i thought there was only one fmap choice, independent of 'interestingness'?
07:13:16 <zygoloid> though perhaps this is another case of "it depends on whether the laws apply to _|_"?
07:15:45 <quicksilver> zygoloid: right
07:16:00 <quicksilver> zygoloid: well, that was my assumption anyway ;)
07:16:20 <quicksilver> zygoloid: possibly this uniqueness proof holds even in the presence of _|_ but most of them fail.
07:16:38 <zygoloid> "fmap id = id" is quite a strong property
07:16:53 <quicksilver> satisfied by "fmap f = id" though
07:17:00 <zygoloid> that's ill-typed
07:17:16 <quicksilver> ah yes
07:17:24 <Saizan> oteren: the funny part is the comments section there, with people surprised by the recursion, or that fail to understand it
07:17:41 <quicksilver> Saizan: the comments section of daily wtf is always more wtf than the article
07:18:05 <quicksilver> Saizan: in a typical sample, 99.9% of the commentors had not actually understood the wtf in the first place :)
07:19:26 <Saizan> quicksilver: that's reassuring.
07:19:38 <quicksilver> Saizan: I find it so.
07:19:45 <quicksilver> Saizan: reassures me about job security, etc :)
07:31:54 <oteren> Saizan: hahaha
07:31:58 <oteren> i started reading the comments now
07:32:03 <oteren> that guy talking about value vs reference
07:32:04 <oteren> golden!
07:32:48 <oteren> and ppl not knowing difference of i++ and ++i
07:32:50 <oteren> :D
07:35:03 <FunctorSalad> are you talking about the -cafe post mentioning dailywtf? about lazy sort
07:35:11 <jmcarthur> thedailywtf hurts my soul
07:35:13 <FunctorSalad> I thought Data.List.sort is strict
07:35:31 <Saizan> we're talking about the one oteren linked above
07:36:04 <FunctorSalad> ok, different
07:36:10 <oteren> http://thedailywtf.com/Comments/Tenth-Times-The-Charm.aspx
07:36:14 <oteren> this one FunctorSalad
07:36:27 <oteren> people making comments about recursion
07:36:31 <oteren> and just guessing on the numbers
07:36:35 <Saizan> Data.List.sort is strict in the sense that it evaluates the whole list, but it starts giving out elements before completing the sorting
07:36:50 <oteren> its scary that many of those commenters probably are professionals of some sort
07:36:55 <Saizan> so taking the first k elements is O(n log k)
07:37:37 <Saizan> or k log n?
07:38:07 <Saizan> that looks more sensible, i've never done the analysis myself though :)
07:39:37 <oteren> what sorting algo does List.sort use?
07:40:08 <Saizan> mergesort
07:40:19 <oteren> how can it start to give out elements before its done if its mergesort?
07:40:35 <Jafet> Why not?
07:41:04 <Jafet> Admittedly, it's easier to do with quicksort
07:41:34 <Jafet> n log k sounds more correct
07:41:34 <oteren> how would you do that? if you take elements from a merge sort before the merge you only get a subset..?
07:41:43 <oteren> maybe i'm not understand what you mean by giving out elements
07:41:56 <oteren> s/understand/understanding
07:42:47 <jmcarthur> oteren: when you take the first element it only merges as close to the head of the list as possible, not the whole thing
07:43:28 <Saizan> look at the code :)
07:43:33 <Saizan> @source Data.List
07:43:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
07:43:34 <Jafet> Actually, I don't see it from mergesort either.
07:43:39 <oteren> yeah, i was just about to say i'd rather look at the code
07:43:49 <ManateeLazyCat> Oh, god, i debate so much about Haskell in #emacs with my friend.
07:43:54 <oteren> cause i have no idea how to implement mergesort (in a good way) in haskell :p
07:44:24 * ManateeLazyCat Some haskeller help me? ... joking.... :)
07:45:25 <Jafet> oteren, are you kidding
07:45:42 <oteren> no, i'm quite new to haskell
07:46:28 <quicksilver> you have to look at the whole list to get the first element
07:46:32 <quicksilver> that should be obvious ;)
07:46:39 <quicksilver> you can't get the first element in less than O(n)
07:46:58 <quicksilver> but what you can do is avoid paying the entire "n log n" cost of sorting everything.
07:47:57 <oteren> ah like that
07:48:01 <Saizan> yeah, i started thinking in terms of lookups in a search tree, but we'd need to build it first, anyway
07:48:17 <oteren> i just didnt understand the question
07:48:29 <quicksilver> Saizan: but you can just build part of it
07:48:30 <oteren> i ofc know you can take the k first items in a list in O(n)
07:48:31 <quicksilver> much like a heap
07:49:10 <Jafet> "-- I am curious as to why the List.sort implementation in GHC is a quicksort algorithm rather than an algorithm that guarantees n log n time in the worst case?" ~~~ because it's faster, dolt
07:49:34 <int-e> the lazy merge sort does exactly that, it builds a heap made of thunks.
07:50:06 <Jafet> oteren, "first" before sorting or "first" after sorting?
07:50:09 <quicksilver> in fact, in some sense I think all the "partially sorted" tricks amount to a kind of head
07:50:13 <quicksilver> heap.
07:50:16 <quicksilver> just built in a strange way
07:50:17 <oteren> before sorting jafet
07:51:09 <oteren> or wait
07:51:18 <oteren> the "first" as in what would be first in a sorted list
07:51:23 <oteren> extracted from a non sorted list
07:51:51 <Jafet> I am pretty sure the optimum is O(n log k) for the general case
07:53:20 <oteren> thats because k can grow up to n, which then becomes the lower general bound of n log n
07:53:51 <quicksilver> Jafet: except in haskell there is no good way to choose a pivot
07:54:02 <quicksilver> Jafet: so merge sort is a better general purpose sort in haskell.
07:54:08 <quicksilver> for several reasons:
07:54:14 <oteren> but for small k its O(n) Jafet
07:54:20 <oteren> the bigger k, the bigger constant
07:54:30 <oteren> but the big-oh is still O(n)
07:54:31 <quicksilver> (a) a haskell quicksort isn't really a quicksort anyway (b) there is no good way to choose a pivot (c) merge sort builds the tree lazily
07:54:32 <Jafet> k is not a constant, so that doesn't work
07:54:58 <Jafet> Tree means recursion tree, quicksilver?
07:55:19 <oteren> i'm not talking proofs here now Jafet
07:55:34 <oteren> but that i.e. finding the first 5 elements of a 1million sized list ist ~~ O(n)
07:55:36 <quicksilver> Jafet: yes
07:55:38 <Jafet> ...er, then what are you talking about here now?
07:55:49 * oteren has lost track of what we're discussing
07:55:49 <oteren> :D
07:56:29 <Jafet> quicksilver, you can do that with quicksort, to an extent
07:56:42 <Jafet> But apparently the sort is supposed to be stable, so I'll stare at the code a bit more
07:58:25 <oteren> Jafet: i think we're agreeing
07:58:29 <quicksilver> Jafet: probably the fact that there is no good way to choose a pivot is the single most important factor.
07:58:42 <oteren> finding k first elements ranged from O(n) to O(n log n) which makes sense
07:58:47 <oteren> *ranges
07:59:07 <Jafet> quicksilver, well, I just can't see how choosing a pivot in Haskell would be different from choosing a pivot in $lang
07:59:23 <oteren> yes, how is haskell stopping you from picking a good pivot?
08:00:13 <Jafet> If you're saying that quicksort is inherently flawed in the way it chooses pivots, there are two resolutions: 1) use a median-approximating algorithm 2) use Sedgewick's hybrid algorithm with mergesort as the fallback
08:00:49 <Saizan> Jafet: we're talking about lists here, not arrays
08:01:06 <Jafet> It's not really all that different.
08:03:16 <iaefai> I have a function: showSet set = Data.Foldable.foldr (++) " | " (List.intersperse " | " (List.map showPiece (toList set)))    that gives me an error Couldn't match expected type `[Char]' against inferred type `Char'  but the List I am operating on is a [String]. I am not sure the cause of my trouble.
08:04:36 <doserj> iaefai: intersperse takes a Char, not a String
08:04:48 <FunctorSalad> @let showSet set = foldr (++) " | " (intercalate " | " (map showPiece (toList set)))
08:04:48 <lambdabot>  <local>:26:55: Not in scope: `showPiece'
08:04:48 <lambdabot>  
08:04:48 <lambdabot>  <local>:26:66: Not in scope: `to...
08:04:58 <FunctorSalad> @let showSet set = foldr (++) " | " (intercalate " | " (map show (toList set)))
08:04:58 <lambdabot>  <local>:26:61: Not in scope: `toList'
08:05:02 <FunctorSalad> @let showSet set = foldr (++) " | " (intercalate " | " (map show (Set.toList set)))
08:05:03 <lambdabot>  <local>:26:61: Not in scope: `Set.toList'
08:05:06 <FunctorSalad> @let showSet set = foldr (++) " | " (intercalate " | " (map show (S.toList set)))
08:05:07 <lambdabot>  <local>:26:44:
08:05:07 <lambdabot>      Couldn't match expected type `[Char]' against inferred t...
08:05:13 <iaefai> doserj: Not quite correct. List.intersperse :: a -> [a] -> [a]   a :: String in this case
08:05:30 <FunctorSalad> @let showSet set = foldr (++) " | " (intersperse " | " (map show (S.toList set)))
08:05:31 <lambdabot>  Defined.
08:05:32 <quicksilver> Jafet: because in other languages choosing a pivot is O(1)
08:05:36 <FunctorSalad> @type showSet
08:05:37 <quicksilver> Jafet: in haskell it's O(n)
08:05:37 <lambdabot> forall a. (Show a) => S.Set a -> [Char]
08:05:50 <quicksilver> Jafet: unless you always pick the first item
08:05:56 <FunctorSalad> iaefai: (why use foldable to fold a list?)
08:06:01 <quicksilver> ...which is what the classic quicksort does, and that's unacceptable.
08:06:06 <Jafet> Picking the first item isn't always bad. Or good.
08:06:17 <iaefai> FunctorSalad: No particular reason, its just how it ended up late at night
08:06:18 <Jafet> Anyway, partitioning is O(n) regardless
08:06:19 <quicksilver> it is an unacceptable choice for a standard library.
08:06:35 <Jafet> It works fine for the C++ standard library.
08:06:47 <Jafet> (Disclaimer, g++'s impl.)
08:06:49 <quicksilver> the C++ standard library uses the first item as a pivot?
08:06:52 <FunctorSalad> iaefai: it's fine, I just wondered whether you had a specific reason
08:07:01 <Saizan> iaefai: what's the type of showPiece?
08:07:09 <FunctorSalad> (will probably spec to the same thing)
08:07:13 <Jafet> Not sure, but for every pivot selection algorithm there exists a worst case, so why sweat it?
08:07:15 <iaefai> showPiece :: (Piece, Colour) -> String
08:07:24 <quicksilver> Jafet: because nearly sorted data is a very common case
08:07:36 <quicksilver> Jafet: you really don't want sort([1..n]) to be O(n^2)
08:07:55 <Jafet> Sedgewick already resolved that with a clever hack
08:07:59 <oteren> picking always the first item will always make 1..n ... quicksilver beat me to it
08:08:13 <Jafet> Well, he named it at least, if anything
08:08:36 <doserj> Jafet: randomising the input list?
08:08:43 <Saizan> iaefai: it's probably a problem in some other part of the code then
08:08:53 <Jafet> That's silly and does not fix the worst case, doserj, but merely sidesteps it
08:09:18 <oteren> i think (hope) he was joking
08:09:35 <iaefai> Sorry, my bad, I had a -> [String] type sig when it should have been -> String
08:10:08 <oteren> anyways, how would you hack around that in haskell jafet?
08:10:48 <Jafet> Same way you hack around that in any other programming language...
08:11:13 <jmcarthur> i consider quicksort to be about as safe regarding algorithmic complexity as UUIDs are regarding correctness
08:11:27 <iaefai> Final function that works: showSet set = "| " ++ (Data.Foldable.foldr (++) " |" (List.intersperse " | " (List.map showPiece (toList set))))      any way to simplify the looks of this?
08:11:33 <jmcarthur> i guess a bit less safe, much of the time
08:11:43 <Jafet> (...and to think I just stated the answer, above...)
08:12:06 <mmorrow> i think the real problem here is that since we're sorting lists, and not arrays, picking any pivot other than the first one (wlog) would increase the computational complexity, no?
08:12:19 <quicksilver> no, just the constant.
08:12:32 <quicksilver> it's still O(n log n) best case, O(n^2) worst case
08:12:41 <quicksilver> (because it's just an extra O(n) per partition)
08:12:41 <jmcarthur> umm
08:13:06 <mmorrow> oh right
08:13:06 <quicksilver> so all it increases is the constant
08:13:06 <quicksilver> but, it's a massive increase
08:13:06 <jmcarthur> oh yeah, not multiplying, just adding
08:13:06 <Jafet> It's a pretty small constant -- you probably don't incur new cache hits, or work the gc any more
08:13:30 <quicksilver> and the constant was the only advantage quicksort had over mergesort anyway
08:13:33 <jmcarthur> i don't think it sounds like a small constant if the alternative is mergesort
08:13:34 <Jafet> And the Matthew effect strikes me again -- it's not by Sedgewick, but a bloke named Musser
08:14:11 <quicksilver> FURTHERMORE, the haskell quicksort is worse than the C quicksort because the functional partitioning does much more copying than the classic imperative algorithm
08:14:21 <quicksilver> which also doesn't increase the complexity but pushes the constant up
08:14:30 <quicksilver> and you end up with a situation where quicksort looks less and less attractive.
08:14:39 <quicksilver> (in fact, I don't thnk the haskell one deserves the name quicksort)
08:15:30 <Jafet> It's always been a misnomer
08:15:41 <Jafet> But I'm just going by the timing data in the source comments
08:17:36 <Jafet> Then again those were done with a 2002 ghc
08:17:44 <quicksilver> and have weird omissions
08:17:49 <quicksilver> "stack overflows" which really shouldn't have been there
08:18:07 <quicksilver> you shouldn't get a stack overflow merging a 100K list.
08:18:22 <quicksilver> > sort [1..100000]
08:18:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:18:23 <Jafet> Black magic is Haskell's other name
08:18:31 <quicksilver> > length $ sort [1..100000]
08:18:32 <lambdabot>   100000
08:18:33 <quicksilver> > length $ sort [1..1000000]
08:18:37 <lambdabot>   mueval-core: Time limit exceeded
08:18:40 <Jafet> > sort [100000..1]
08:18:43 <lambdabot>   []
08:18:49 <Jafet> Erm
08:18:51 <oteren> haha
08:18:52 <ystael> oops
08:18:56 <quicksilver> > length $ sort [100000,99999..1]]
08:18:57 <lambdabot>   <no location info>: parse error on input `]'
08:19:01 <quicksilver> > length $ sort [100000,99999..1]
08:19:03 <lambdabot>   100000
08:19:21 <oteren> from someone who doesnt know haskell too good yet
08:19:26 <oteren> why didnt the first one work?
08:19:40 <medfly> because you didn't tell it how to go.
08:20:02 <oteren> isnt 100000..1 = [10000, 999 etc..] =
08:20:04 <oteren> ?
08:20:07 <quicksilver> default increment for .. is always +1
08:20:10 <trzkril> but it worked! perfectly
08:20:10 <oteren> ah
08:20:33 <Jafet> I wonder if anyone's tried timsort
08:22:37 <tuukkah> what should i do when compiling a package fails with this? Module `Data.Array.Vector' does not export `concatU'
08:23:48 <Saizan_> make it use an older version of uvector?
08:23:56 <Saizan_> you can do it with --constraint=
08:26:56 <tuukkah> Saizan_, so concatU has been removed from newer versions of concatU? what constraint should i use?
08:27:41 <tuukkah> s/versions of concatU/versions of uvector/
08:28:08 <mmorrow> , length $ sort [1..1000000]
08:28:11 <lunabot>  1000000
08:28:17 <mmorrow> , length $ sort [1..10000000]
08:28:22 <lunabot>  Killed.
08:29:19 <mmorrow> , filter (== sort "lunabot") dict
08:29:24 <lunabot>  []
08:29:25 <Traveler4> Hi
08:29:56 <mmorrow> , filter ((== sort "lunabot") . sort) dict
08:29:57 <Traveler4> hi, I need some help on a haskell assignment
08:30:00 <lunabot>  ["butanol"]
08:30:26 <Traveler4> anyone care to assist me?
08:30:27 <mmorrow> , filter ((== sort "splendid") . sort) dict
08:30:32 <lunabot>  ["spindled","splendid"]
08:30:43 <mmorrow> , filter ((`isInfixOf` sort "splendid") . sort) dict
08:30:48 <lunabot>  ["d","dd","de","dei","deil","deli","didle","die","died","diel","dindle","...
08:30:57 <mmorrow> , reverse . filter ((`isInfixOf` sort "splendid") . sort) $ dict
08:31:02 <lunabot>  ["splined","spline","splendid","spinel","spindled","spindle","sp","s","ps...
08:31:03 <fasta> Is anyone still using darcs?
08:31:19 <fasta> It seems that all the Emacs modes are not maintained anymore. Darcs is considered "legacy".
08:31:55 <Saizan_> tuukkah: i was just guessing, since cabal defaults to the latest version
08:32:02 <Saizan_> tuukkah: i've never used uvector
08:32:21 <Traveler4> I'm trying to sort a String of words by the frequency of words and if the frequency count is the same, than alphabetically. Can anyone help me please?
08:32:33 <jmcarthur> fasta: huh? darcs is picking up steam, i thought
08:33:06 <fasta> jmcarthur: well, a few years ago I used some Emacs mode, I think dcs and it worked great. Now, I try to use it again, and it doesn't.
08:33:19 <jmcarthur> i haven't seen real statistics though, so it could just be an illusion because i switched to it this year
08:33:39 <jmcarthur> ah, well, i haven't tried any emacs modes for it
08:34:08 <fasta> I think I will just do it via the command line, but I like the Emacs modes, because there are so many version controls systems. I really cannot be bothered about all their commands.
08:35:06 <jmcarthur> darcs is so different from most others that i can't imagine that a "universal" interface would work well at all for it
08:35:08 <Traveler4> I'm trying to sort a String of words by the frequency of words and if the frequency count is the same, than alphabetically. Can anyone help me please?
08:36:33 <sproingie> darcs is a dvcs, that's all.  the command set isn't too strange for emacs to deal with
08:36:35 <roconnor> Traveler4: your tools are: sort, group, length, and sortBy
08:37:07 <jmcarthur> but you lose all of darcs' power when you turn it into the same thing as everything else
08:37:10 <sproingie> if emacs can deal with the weirdness of git, it can handle darcs
08:37:19 <jmcarthur> git isn't that weird
08:37:29 <sproingie> it's not emacs's job to preserve its "specialness", it's there to version individual files
08:37:52 <jmcarthur> right. which is why i don't use emacs to handle my VCS ;)
08:38:06 <sproingie> i find it handy for one-off commits
08:38:30 <sproingie> i kind of wish i could do C-x-v-v and have it add to a changeset that i push later, but alas
08:38:55 <sproingie> with hg that isn't so bad, i can just uncommit the individual changes and roll them into one
08:39:24 <sjanssen> darcs UI for recording changes is basically the same as other DVCS.  Things start looking different when pulling/pushing/applying patches
08:39:37 <sproingie> not as emacs vc is concerned
08:40:15 <EnglishGent> Traveler4 - what form is the input in? are the words simply space delimited?
08:41:17 <en0th_away> i'm trying to set up some utility function to manipulate a matrix. Am i proceeding in the correct way? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4458
08:43:11 <en0th_away> (flip snd and fst on row 37)
08:43:27 <tuukkah> Saizan_, the cabal repo of uvector seems to have never heard of concatU...
08:44:55 <tuukkah> pumpkin has implemented one here on 09.01.20 though =)
08:45:00 <quicksilver> en0th_away: looks like you've not noticed some of the utility functions which already exist on Array
08:45:40 <quicksilver> oh perhaps not
08:45:47 <quicksilver> sorry I missed you're doing one *row* at a time
08:45:49 <quicksilver> apologies.
08:46:03 <en0th> no, i guess you're right
08:46:25 <zygoloid> @doc , let not = id; available = text . head $ sortBy (compare `on` sort) dict in
08:46:26 <lambdabot> , let not = id; available = text . head $ sortBy (compare `on` sort) dict in not available
08:46:31 <lunabot>  hee-hee!
08:47:17 <copumpkin> @doc preflex: seen lambdabot
08:47:18 <lambdabot> preflex: seen lambdabot not available
08:47:18 <preflex>  lambdabot was last seen on #haskell 53 seconds ago, saying: , let not = id; available = text . head $ sortBy (compare `on` sort) dict in not available
08:47:49 <en0th> i'm considering the range  function
08:47:58 <copumpkin> @@ @doc @run text ", 5"
08:47:59 <lambdabot> Plugin `compose' failed with: Unknown command: "doc"
08:48:06 <copumpkin> interesting
08:48:28 <zygoloid> @@ @docs @run text ", let not = id; available = 5 in"
08:48:29 <lambdabot>  , let not = id; available = 5 in not available
08:48:42 <copumpkin> I think text prefixes it with a space
08:48:47 <fasta> When I run darcs, it feels like a fork-bomb.
08:48:49 <copumpkin> or just @run output
08:49:00 <copumpkin> fasta: sorry to hear that
08:49:04 <fasta> About 30/40 sh processes started.
08:49:21 <zygoloid> @@ @docs , let not = id; available = (@run 5) in
08:49:22 <lambdabot>  , let not = id; available =   5
08:49:22 <lambdabot>  in not available
08:49:27 <fasta> I am not trolling, but there is something wrong (at least I assume this is not how it is supposed to work).
08:49:35 <copumpkin> fasta: try #darcs
08:49:58 <zygoloid> fasta: do you have a shell function called 'darcs'? :)
08:50:19 <fasta> zygoloid: it only happens with darcs send
08:51:12 <maltem> fasta, compiled darcs to use wget or something?
08:51:13 <zygoloid> fasta: actually sending an email, or with -o?
08:51:25 <Cale> darcs(){darcs|darcs&}
08:51:32 <copumpkin> lol
08:51:51 <fasta> zygoloid: I just do darcs send. It asks some questions, I answer them and then the horror begins.
08:51:52 <maltem> (or no, then it wouldn't (only) happen with send)
08:54:59 <fasta> Heh, I think I know what the problem is.
08:59:55 <walrus> [5~[5~[5~[5~[5~[5~[6~[6~[6~[6~[6~[6~
09:02:17 <EnglishGent> hi copumpkin :)
09:02:22 <copumpkin> hi :)
09:02:52 <fasta> Ok, machine crashed again, because of my fork-bomb, but everything works again :)
09:03:52 <copumpkin> what was the problem?
09:04:01 <copumpkin> you said it wasn't darcs' fault?
09:06:51 <fasta> copumpkin: even if it was darcs' fault, it would still be my fault for using darcs in the first place, but it was causes by a script called sendmail in my bin dir to sendmail instead of to /usr/sbin/sendmail and I only found out this quite some time after I created the script.
09:08:42 <dons> Baughn: works for me.
09:09:34 <Arnar> hmm.. how can I stop the ghci prompt from growing bigger than my arm?
09:10:00 <quicksilver> Arnar: customise it to something else?
09:10:18 <Baughn> dons: With cvs login?
09:10:55 <Baughn> dons: Authorization failed is all I get
09:12:02 <quicksilver> Arnar: or.. use a smaller font and stretch your arm?
09:12:19 <dons> i've not tried to log in via cvs. please report it to libraries@
09:12:23 <dons> and inform Igloo
09:12:25 <dons> i'm not an admin
09:12:43 <Baughn> I see
09:13:17 <Arnar> quicksilver: arm stretched to the limit :) -- I'm looking for how to customize the prompt
09:13:30 <Igloo> :set prompt foo
09:14:17 <Arnar> Igloo: aha..
09:14:19 <Arnar> thanks
09:14:39 <tommd> But how do you use a particular PNG as the prompt?  Thats really important.
09:14:53 <Elly> a PNG? oO
09:15:15 <Saizan_> NPG
09:15:24 <Saizan_> like, clippy
09:15:25 <quicksilver> RPG
09:15:29 <quicksilver> boom.
09:15:45 <Gracenotes> hm. *has* someone tried to make an html-querying monad? similar to how xpath works?
09:15:47 <Arnar> :set prompt "data:afee953gg....."
09:16:12 <Saizan_> Gracenotes: isn't HXT kind of that?
09:16:21 <Gracenotes> I don't know. lemme see
09:16:30 <sproingie> xpath doesn't sound terribly monadic
09:16:41 <Saizan_> though it's arrows, but they are ArrowApply iirc
09:16:48 <sproingie> maybe applicative
09:17:32 <Gracenotes> no? sounds a bit like the list monad to me
09:17:47 <sproingie> oh right multiple results
09:18:01 <Gracenotes> yeah, that's the idea
09:18:06 <sproingie> was thinking more OO in terms of nodesets
09:18:22 <sproingie> but a sequence would be more, uh, good
09:19:27 <Baughn> Igloo: So, cvs.haskell.org? Should I send an email, or can you handle it?
09:20:08 <Igloo> Baughn: I don't know what you want handled, but best to send an e-mail
09:20:28 <Baughn> Igloo: It would be nice if it /worked/
09:20:52 <Baughn> I'm not looking for anything in particular other than a working pserver, really
09:21:15 <jmcarthur> hmm... probably a straight up ADT and SYB would be a nice way to dig into HTML
09:21:31 * ManateeLazyCat Bye all, good night! :)
09:21:48 <jmcarthur> why by "nice" i mean "handy," not necessarily "elegant"
09:22:31 <jmcarthur> Gracenotes: i guess tagsoup doesn't count for what you are wanting?
09:22:44 <jmcarthur> it's not really concerned with structure that much
09:23:38 <Gracenotes> actually, I was working with a short python script that used beautiful soup just now :) I was thinking maybe a list monad-type-thing was a good medium ground between a formal parser and just soup
09:24:15 <Gracenotes> not like middle grounds are, in and of themselves, useful in any way
09:25:14 <quicksilver> I think you just want a combinator library, not a monad.
09:25:29 <jmcarthur> i think the ADT with SYB approach sounds pretty close to a middle ground, assuming the ADT is loosely structured enough that malformed HTML can still fit into it
09:26:02 <quicksilver> there isn't an obvious central fashion that combinators for querying would necessarily form a monad
09:26:02 <jmcarthur> yeah, a monad for a monad's sake isn't really a great approach in general, IMO
09:26:02 <hackagebot> estimators 0.1 - Tool for managing probability estimation (SashaRush)
09:26:04 <quicksilver> although in practice they probably would in some boring way
09:26:11 <quicksilver> start with combinators, IMO
09:26:20 <quicksilver> notice if they happen to be members of famous typeclasses later
09:27:13 <quicksilver> HaXml combinators are "arrow-like" but don't use any of the arrow combinators
09:28:04 <Gracenotes> eh. the word monad comes not from the buzzwordiness of monads in general, but the list monad in particular
09:28:21 <Gracenotes> not for parsing, just for querying, supporting operations similar to xpath
09:28:51 <jmcarthur> oh, you mean the semantics might look similar to the list monad?
09:29:12 <quicksilver> the list monad is about concatMap
09:29:20 <quicksilver> is that useful for queries
09:29:34 <jmcarthur> i think it sounds feasible
09:29:35 <quicksilver> perhaps it is, for combining queries
09:29:40 <lispy> get down with the concatMap
09:29:47 <lispy> :t concatMap
09:29:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
09:30:03 <hackagebot> semiring 0.2 - Semirings, ring-like structures used for dynamic programming applications (SashaRush)
09:30:18 <jmcarthur> if i get all the div blocks that are inside other div blocks, i might get something like [[Div]], which i could concat down to just [Div]
09:30:24 <Gracenotes> concat map, with my limited knowledge of xpath, could at least model a subset reasonably. the map part would be some form of internal lookup
09:31:04 <hackagebot> estimators 0.1.1 - Tool for managing probability estimation (SashaRush)
09:31:43 <paolino> @hoogle assert
09:31:44 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:31:45 <lambdabot> Control.OldException assert :: Bool -> a -> a
09:31:45 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
09:33:46 <burp> @hoogle CReal -> Double
09:33:47 <lambdabot> Warning: Unknown type CReal
09:33:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:33:47 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:33:59 <burp> erm I need Double -> CReal
09:34:16 <roconnor> realToFrac
09:34:42 <burp> thanks
09:35:18 <ahnfelt> I wrote a simple interpreter for a minimal (and pure) core of language I'm toying with.
09:35:45 <ahnfelt> While I did anticipate side effects, I decided to make a pure implementation first.
09:36:24 <ahnfelt> Unfortunately now that I am ready to introduce side effects, it seems I will have to do a lot of rewriting to introduce a monad that can contain it.
09:36:57 <roconnor> your pure interpreter didn't specify any sequencing of operations
09:37:13 <roconnor> you should refactor it into the identity monad
09:37:28 <roconnor> putting the the sequencing order you expect
09:37:45 <roconnor> then you can change the monad to hold effects
09:38:08 <ahnfelt> roconnor: That seems like a very reasonable approach
09:38:48 <ahnfelt> However, I tried doing that with the IO monad (not using any IO functions, in effect it could just as well have been the identity monad)
09:39:01 <ahnfelt> and the code grew quite a bit
09:39:07 <roconnor> yes
09:39:14 <roconnor> more information
09:39:35 <roconnor> not sure it should grow that much
09:39:41 <sinelaw> I wish GHC could print messages like these: http://www.cs.uu.nl/wiki/bin/view/Helium/Features
09:39:53 <ahnfelt> I am probably not doing this the optimal way
09:39:55 <roconnor> but it depends a lot on what you have
09:40:30 <ahnfelt> I have this so far: http://github.com/Ahnfelt/Piqo/blob/master/Interpreter.hs
09:40:46 <quicksilver> roconnor: that was a very elegant way to explain the problem.
09:40:46 <ahnfelt> (don't worry, I don't expect you to read it ;-) )
09:41:05 <ahnfelt> Glossing over it, it's not a lot of code (although there are certainly other modules which will have to be modifed)
09:41:48 <roconnor> was this discussed on haskell-cafe this week?
09:41:51 <roconnor> or last week
09:42:28 <roconnor> something about the difficulty of having lambda interact with monads and call-by-name vs call-by-value and stuff
09:43:00 <ahnfelt> Is haskell-cafe another irc channel?
09:43:08 <roconnor> no it is a mailing list
09:43:09 <lament> sinelaw: I wish Helium had type classes
09:43:11 <ahnfelt> Ah
09:44:02 <ahnfelt> I haven't discussed my code with anybody, but I guess it's a common issue to have to introduce monads into existing non-monadic code
09:44:33 <roconnor> well I heard that getting it to interact with lambdas is tricky
09:44:38 <roconnor> http://www.haskell.org/pipermail/haskell-cafe/2009-October/067269.html
09:44:43 <roconnor> this is the thread I was thinking of
09:45:08 <roconnor> anyhow, my advice still stands, though there might be some delecate thought needed when dealing with function application
09:46:01 <ahnfelt> Thank you
09:46:49 <sproingie> ahnfelt: generally it's easier to lift non-monadic code into monads
09:47:26 <mmorrow> this page is pretty cool http://en.wikipedia.org/wiki/List_of_fractals_by_Hausdorff_dimension
09:47:27 <Saizan_> ahnfelt: http://haskell.org/papers/modular-interpreters.ps <- great paper on the subject
09:47:42 * mmorrow just got sidetracked for 20 minutes staring at images
09:47:56 <sproingie> fractal pr0n
09:48:05 <copumpkin> fapfap
09:49:01 <ahnfelt> sproingie: I haven't done much of that yet, but I will certainly investigate that
09:49:49 <sinelaw> lament, yes. do you think that's why helium is able to support such good messages?
09:49:49 <ahnfelt> Saizan_: Thank you, I will read that
09:49:58 <sinelaw> (i'm guessing it is so)
09:50:10 <lament> sinelaw: yes
09:50:13 <lament> mmorrow: pretty
09:53:10 <sinelaw> mmorrow, amusingly, the human brain has the same value as the "Menger sponge"
09:53:17 <sinelaw> :P
09:57:17 <hackagebot> Advgame 0.1 -  (TimWawrzynczak)
10:00:17 <hackagebot> Advgame 0.1.1 - Lisperati's adventure game in Lisp translated to Haskell (TimWawrzynczak)
10:03:34 <ahnfelt> roconnor: By the way, nice point about the sequencing. I hadn't looked at it that way.
10:10:29 <ludflu> hello haskellers! I'm new to haskell, and I'm trying to choose a data structure to store some monte-carlo simulation data. (I'd like to write a go/baduk playing robot). My first thought is a mutable array. Any suggestions?
10:11:52 <maltem> ludflu, what are you requirements for the data structure?
10:12:10 <lament> a go playing robot! Yay!
10:12:46 <lament> ludflu: Choose whatever structure you feel like, but hide it behind an interface - chances are, you'll change it a few times anyway
10:13:03 <Botje> ludflu: if you're going to model game states, you probably want some kind of tree.
10:13:21 <lament> ludflu: also, there're papers on thsi
10:13:23 <c_wraith> Hiding a mutable array behind an interface is kind of tough, since it requires you at least have it in the ST monad.
10:13:23 <lament> *this
10:13:35 <lament> it's not even an array
10:13:44 <lament> it's a big scary tree
10:13:48 <lament> of stuff
10:13:50 <ludflu> well, its a 19x19 grid, and each cell has one of three values. (Black, White or Empty) there's also a bunch of meta-data I'd rather not recompute on each step, life strings of adjacent same-colored nodes
10:14:36 <ludflu> a tree of matrices?
10:14:39 <lament> ludflu: that's just one position in the tree, and you want to have results for a (portion of) the tree
10:15:11 <lament> or if you don't want it now, you'll want it later :)
10:15:23 <c_wraith> actually, go states are more of a graph than a tree.  It's not even an acyclic graph, unless you're playing with the strong Ko rule.
10:16:26 <ludflu> I think I do need the strong ko rule, otherwise the simulation (move evaluator) can get stuck in a loop.
10:17:08 <c_wraith> I don't think anyone objects to the strong Ko rule in practice.  It just requires a bit more bookkeeping.
10:17:23 <ludflu> the only reason I think it has to be mutable was because I don't want to recompute all the board metadata. but maybe I don't have to.
10:17:48 <ludflu> I guess it would simplify things if it was immutable
10:18:27 <lament> c_wraith: iirc superko is not an issue for actual monte carlo simulation
10:18:51 <lament> since you're picking moves at random, it's too unlikely to get stuck
10:19:09 <c_wraith> Given how bad I am at go, I can't say I've ever even thought of how to approach AI for it.
10:19:22 <ludflu> lament: then you just put some limit on the number of moves for the simulation?
10:19:32 <lament> no, you simulate till the end of the game
10:20:05 <lament> since you pick moves randomly, you won't get stuck forever
10:21:04 <tromp> you certainly don't want to use my go rules in haskell implementation
10:21:11 <tromp> it's crazy slow
10:21:31 <ludflu> when I tried this, I did in fact get stuck in loops toward the end of the game where there are only a few legal moves. anyway...the data structure. If I go immutable- how do I take a board and add a move to it? I have to copy the whole thing?
10:22:11 <ludflu> tromp: I'd be happy to have them as a starting point. My go rules are slow too. (in java)
10:22:47 <Baughn> ludflu: Depends on how you represent the board. You do not, in fact, probably want to represent it as a straight-out array of stones most of the time..
10:22:56 <tromp> see http://www.cwi.nl/~tromp/go.html
10:23:03 <Baughn> ludflu: Go programs are practically AIs; higher-level structures are the order of the day
10:24:46 <lament> as i understand, writing a MCT go program is all about optimization
10:24:50 <lament> and magic
10:25:00 <lament> heavily optimized magic
10:25:11 <ludflu> Baughn: yes, I'd agree. but what kind? A tree of moves perhaps?
10:25:24 <lament> ludflu: read a paper on MCT if you haven't yet
10:26:10 <Baughn> ludflu: I have no idea.
10:27:06 <ludflu> lament: I've read a couple papers on mogo., good stuff. I'd eventually like to take advantage of Haskell's semi-automatic parallelization goodness
10:29:43 <ludflu> http://www.lri.fr/~gelly/paper/nips_exploration_exploitation_mogo.pdf
10:35:54 <mmorrow> sinelaw: i snagged at least 5 images from there into my desktop-background-pool dir
10:39:59 <ludflu> tromp: thanks much.
10:42:47 <brad_larsen> The default Ord instance for Data.Array.Unboxed.UArray performs dreadfully.
10:42:55 <brad_larsen> Does anyone have a definition of a fast one?
10:43:33 <brad_larsen> I wrote one by hand, using unsafeIndex, etc, but the index variable in the generated code is a boxed Int.  :-(
10:44:48 <brad_larsen> my hand-written comparison for unboxed arrays performs better than the default, but is very slow and does loads of heap allocation, when it really shouldn't be doing any
10:45:36 <Baughn> brad_larsen: Even on -O2?
10:45:47 <brad_larsen> Baughn, yes, even with -O2
10:46:31 <Baughn> brad_larsen: Show me?
10:46:41 <Baughn> (The code. Hpaste)
10:47:51 <brad_larsen> Baughn, hold on
10:47:57 <gOcOOl> what's the difference between a haskell list & array? is it that the former is immutable while the latter is not?
10:48:20 <Baughn> gOcOOl: No, arrays are also immutable.
10:48:30 <roconnor> lists are effectively linked lists and can share tails
10:48:39 <Baughn> gOcOOl: The difference would be that a list is a singly-linked list, while an array is an.. array. Um, these are basic CS terms
10:48:42 <sm> arrays are fixed length
10:48:51 <roconnor> arrays are contiguous blocks of memory of fixed size (per instance)
10:48:55 <idnar> it's not necessarily obvious that "list" means linked list
10:48:59 <Baughn> gOcOOl: Each list cell has a pointer to the next. Arrays are contiguou.. oh, never mind
10:49:03 <idnar> eg. Python's "list" type is a mutable dynamic array
10:49:15 <Baughn> idnar: That's just Python. *Every* other language uses it right, so..
10:49:16 <gOcOOl> Baughn: ah ok, so when we refer to a list, it's basically a linked list
10:49:20 <Baughn> Yes
10:49:31 <gOcOOl> ok, makes sense
10:49:34 <Cale> Though, there's a bit of extra subtlety to both of these structures over the usual strict datastructures.
10:49:39 <idnar> Baughn: eh, I dunno
10:49:50 <Baughn> gOcOOl: Singly-linked. You'll find that a doubly-linked list is impossible to alter without copying the whole thing.
10:49:54 <idnar> I think .NET uses "list" as the name for their generic sequence interface, for example
10:50:10 <Baughn> gOcOOl: (Which is not to say that you can't have data structures with the same performance characteristics as one, but they have to be implemented differently)
10:50:46 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11051#a11051
10:51:01 <Cale> It's possible that a program which uses a Haskell list only ever keeps one element of the list in memory at a time.
10:51:36 <Cale> (since the tail might always be an as-yet-unevaluated expression, and the head becomes garbage right after it's used)
10:51:43 <brad_larsen> specifically, I'm working with 2D arrays, indexed with a strict pair in package 'strict' on hackage
10:51:59 <brad_larsen> but the 'go' worker function takes an int argument
10:52:11 <brad_larsen> ghc-core shows that in some cases, the argument is a boxed int
10:52:52 <idnar> http://en.wikipedia.org/wiki/List_%28computing%29
10:52:58 <brad_larsen> the default 'compare' function in the Ord instance for UArrays converts to a list of associations, which doesn't get fused away
10:53:25 <brad_larsen> (all this tested with ghc-6.10 series on a couple machines)
10:53:57 <ludflu> it seems that the Go playing robot CrazyStones stores a tree of moves. I guess I start looking into appropriate haskell tree structures, and then decide if I need it to be mutable or not
10:54:06 <ludflu> http://remi.coulom.free.fr/CG2006/CG2006.pdf
10:56:36 <maltem> ludflu, tree structures in Haskell are just user-defined data types (partly due to the fact that we don't have a master tree library), and there's not much point to have an especially "mutable" tree structure
10:57:43 <maltem> well unless you embed the tree in an array ;)
10:59:35 <Baughn> brad_larsen: I don't suppose telling you "I can't see why it won't work" helps?
10:59:44 <ludflu> maltem: what I'm thinking is that when I take an existing board position (a leaf on the tree) and I want to extend it, I don't want to copy the whole tree. I want to create a new tree, just like the old one, but with an extra leaf node. If I can do that with an immutable tree, so much the better
11:00:06 <brad_larsen> Baughn, heh, not really.  ;-)
11:00:29 <roconnor> ludflu: just make the infinite tree, it will only be expanded when demanded. :)
11:00:37 <brad_larsen> I think 'numelements' is partially responsible
11:00:44 <brad_larsen> * 'numElements'
11:00:51 <brad_larsen> from Data.Array.Base
11:01:01 <brad_larsen> its result is a boxed array for some reason
11:01:22 <brad_larsen> and since I compare against its result in the 'go' worker, the index variable is boxed
11:01:25 <Jafet> Technically, since go is a finite game (by certain ko rules), the tree is finite
11:01:28 <maltem> ludflu: That's somehow one of the points of having a tree, that you don't have to copy the whole thing all the time
11:02:04 <lament> go is finite anyhow, since the board is finite, provided you handle cycles intelligently
11:02:20 <lament> superko is just a crutch to simplify implementation
11:03:11 <Jafet> It's a functional tree anyhow, why are we fussing over storage? Hash it or something
11:03:36 <roconnor> ludflu: oh maltem's right.  When you add change a leaf in a tree only the nodes from the root the the leaf are copied, the rest of the tree is shared.
11:03:37 <lament> the problem is the tree has some data on each node
11:03:43 <lament> and this data gets updated
11:03:46 <viator_sg> Question, can I execute sentences in ghci session in batch way? It's for a tutorial. Or the only way is doing c&p?
11:03:57 <lament> (for example, the number of times this node has been visited, and the average winning probability of this node)
11:04:07 <ludflu> Jafet: what if I need to alter a node? The various simulations may change the expected "goodness" of that move. yes, what lament said
11:04:08 <lament> so it's not very functional
11:04:15 <quicksilver> viator_sg: make them functions in a file and then call them ?
11:04:20 <quicksilver> viator_sg: (I don't really understand your question)
11:04:26 <anborder> hi. I have a code like the following: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4461. I would like to make the function pap access the reader monad. I can derive a MonadReader instance for the R type, but that would make the reader accessible to any other code. Is there a way to make the MonadReader instance private to the module (and its functions, such as "pap")?
11:04:36 <Jafet> roconnor, that's still unacceptably inefficient, unless one of those current-view tricks exists for trees
11:04:41 <burp> viator_sg: like so? echo "1+1" | ghci
11:04:42 <ludflu> lament: that's why I'm here. Is there a
11:04:52 <ludflu> "more functional" way to do it?
11:04:54 <Jafet> ...or I'm stupid, which is likely
11:05:30 <maltem> heh, I'm not so familiar with imperative trees
11:05:38 <mmorrow> quicksilver: is that one opengl prog you wrote for force directed graph layout on the internet anywhere?
11:05:53 <quicksilver> didn't I email it somewhere?
11:05:55 <viator_sg> burp: Yes, but seems that only works with one sentence
11:05:57 <roconnor> log(n) is effectively bounded by 64 :)
11:06:07 <burp> viator_sg: what do you mean, one sentence?
11:06:10 <burp> one line?
11:06:18 <viator_sg> yes
11:06:23 <burp> no
11:06:30 <burp> you can do cat filewithmultiplelines.txt | ghci
11:06:38 <burp> try it
11:06:46 <mmorrow> quicksilver: i've got it somewhere, currently digging
11:07:17 * quicksilver searches haskell-cafe for emails fromhim
11:07:26 <Jafet> Oh god, haskell one liners
11:07:38 <mmorrow> quicksilver: found it
11:07:47 <quicksilver> me too.
11:07:59 <quicksilver> 24/4/09 Re: [Haskell-cafe] Re: ANNOUNCE: vacuum-cairo: a cairo frontend tovacuum for live Haskell data visualization
11:08:23 <mmorrow> should have searched in code/GRAPHICS/ first..
11:08:31 <mmorrow> oh nice
11:08:32 <quicksilver> email is the filesystem
11:09:12 <mmorrow> bookmarked
11:10:03 <fergie> how do I catch the prelude.read no parse exception from outside the IO monad?
11:10:04 <mmorrow> quicksilver: ooh, purdy
11:10:21 <mauke> fergie: don't, use reads instead
11:10:23 <viator_sg> burp: Thanks, it works. But the let lines aren't shown, so I'll try using putStrLn or something to simulate that.
11:10:53 <burp> hm, don't know about that
11:11:08 <quicksilver> mmorrow: thanks. It was pretty much the simplest thing I could imagine which would work.
11:11:33 <fergie> mauke: can you give me a quick example. reads "5"::Float gives me an error
11:11:39 <quicksilver> mmorrow: really it's a good example of how easily you can get these thigns going in haskell if you know how to drive the library.
11:12:05 <mauke> > reads "5" :: [(Float, String)]
11:12:06 <lambdabot>   [(5.0,"")]
11:12:23 <mmorrow> quicksilver: what license does that code have?
11:12:35 <fergie> mauke: Thank you
11:12:47 <quicksilver> anything I post to haskell-cafe is freely reusable for any purpose by any person
11:13:30 <quicksilver> looking at the code again the reactive combinators are a bit ugly still
11:13:33 <quicksilver> work in progress they are.
11:13:35 <mmorrow> :)
11:21:05 <mmorrow> quicksilver: here's a diff of the (hack) steady state quicky i added last time i played with it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4462#a4462
11:21:42 <mmorrow> (i totally botched arrow-movement...)
11:36:22 <hackagebot> NetSNMP 0.1.2 - Bindings for net-snmp's C API for clients (JohnDorsey)
11:38:19 <quicksilver> mmorrow: ack, contextual or unified diffs please, this isn't 1975 any more
11:38:56 * quicksilver passes out
11:39:13 <quicksilver> (hack) wasn't enough to prepare me for that mess of unsafePerformIO, seq and NOINLINE
11:46:27 <mmorrow> quicksilver: heh, i should've said (hackity hack)
11:47:07 <dolio> I think mmorrow doesn't actually like Haskell. :)
11:47:59 <tommd> unsafePerformNoInline?
11:47:59 <mmorrow> dolio: hate it, to be honest
11:50:38 <mmorrow> but really though, you've got one minute, are not allowed to look at the rest of the program, you're using opengl, in IO, and you need a steady state (and you're seeing the prog for the first time)..... GO!
11:51:01 <mmorrow> was the context :)
11:51:05 <dolio> Ah. :)
11:51:20 <dolio> I'd be screwed, because I don't know OpenGL.
11:51:36 <dolio> No ammount of unsafePerformIO can help that.
11:51:43 <dolio> Or can it...
11:51:52 <mmorrow> well, that hack didn't really need any opengl-specifics
11:52:06 <tommd> I'm still looking for anyone who has used both the OpenGL and OGL packages on hackage and has an opinion about them.  Anyone?
11:52:35 <mmorrow> dolio: i wouldn't be surprised if it can
11:52:39 <dolio> :)
11:53:05 <dv-> hi. does cabal work on windows, and why not?
11:53:05 <dcoutts> dv-: yes
11:53:34 <dv-> i'm trying to install something, but it fails. it says: setup.exe: sh: runGenProcess: does not exist (No such file or directory)
11:53:58 <dcoutts> it's not a good error message but that means that the package in question uses a ./configure script
11:54:10 <dcoutts> which means you need MSYS for that package
11:54:42 <dv-> hm. alright. thanks
11:55:04 <Asztal> I get 40 or so "sh.exe has crashed" messages because I have a windows sh.exe :|
11:55:30 <Asztal> (which apparently just crashes when it tries to fork, or something.)
11:55:41 <paolino> is it possible to write function readB here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4463#a4463 ?
11:57:46 * dcoutts wonders if dv- saw his reply before he got cut off
11:58:28 <tommd> dcoutts: dv- saw what you said and thanked you
11:58:34 <dcoutts> :-)
11:58:46 <Paczesiowa> does ghc use Wadler's idea from 1990 for auto-deforestation [Deforestation: transforming programs to eliminate trees] and why not?
12:00:46 <sinelaw> Paczesiowa, "Deforestation is an important optimisation for programs written in the âlistfulâ style that Haskell encourages, but Wadlerâs original transformation algorithm (Wadler, 1990b) had proven too expensive for daily use. Instead, GHC used short-cut deforestation, which depends on two combinators: foldr, which consumes a list, and build."
12:01:19 <sinelaw> that was once.
12:01:53 <Paczesiowa> sinelaw: where did you find that?
12:02:17 <sinelaw> http://portal.acm.org/citation.cfm?id=1238856&dl=GUIDE&coll=GUIDE&CFID=57390487&CFTOKEN=50896203
12:02:36 <sinelaw> A History of Haskell: Being Lazy with Class
12:03:10 <Paczesiowa> sinelaw: thanks
12:03:11 <sinelaw> Paczesiowa, i have no idea what deforstation is, i didn't get to that part yet :)
12:03:59 <Berengal> sinelaw, not building intermediate datastructures that are just going to become garbage anyway
12:04:01 <travisbrady> Anyone have recommendations for which library to use if I'd like lightweight and fast arrays?
12:04:02 <Paczesiowa> sinelaw: I know what it is. do they explain what does "too expensive" mean?
12:04:38 <dcoutts> travisbrady: the array package isn't so bad :-)
12:05:04 <sinelaw> Paczesiowa, nope, but they give this paper
12:05:07 <sinelaw> Gill, A., Launchbury, J., and Peyton Jones, S. (1993). A short cut to
12:05:07 <sinelaw>       deforestation. In ACM Conference on Functional Program-
12:05:07 <sinelaw>       ming and Computer Architecture (FPCAâ93), pages 223â232,
12:05:07 <sinelaw>       Cophenhagen. ACM Press. ISBN 0-89791-595-X.
12:05:22 <travisbrady> dcoutts: ok, cool.  I wasn't sure if there was some new whizz bang package with stream fusion or something i should be looking at
12:05:36 <dcoutts> travisbrady: there is one of those too
12:05:54 <travisbrady> uvector?
12:05:55 <dcoutts> sinelaw: though that paper also doesn't give many specifics on why Phil's algorithm isn't that great in practise.
12:06:06 <dcoutts> travisbrady: yep
12:06:32 <sinelaw> dcoutts, ok :) i'm just serving as a knowledge base here (with no AI)
12:07:14 <dcoutts> I looked into it for my thesis and didn't find much in the literature on exactly why it was discarded
12:07:25 <paolino> anyone ?
12:07:28 <Parkotron> Beginner question: Is it possible to make all instances of type class A automatically members of type class B, assuming A provides sufficient interface to implement B?
12:07:35 <mauke> Parkotron: no
12:07:41 <Paczesiowa> sinelaw: I've read that, anyway thanks for info on that history paper
12:08:00 <mmorrow> how much ram did personal puters have in 1993?
12:08:16 <mmorrow> and processor speed
12:08:36 <dcoutts> mmorrow: about 33Mhz and 4Mb or thereabouts
12:08:50 <absentia> 1MB ..
12:09:18 * earthy bought one in april of 1993 with a 33 MHz 386sx and 3MB of RAM
12:09:51 <earthy> sx implying no FP unit
12:09:52 <Parkotron> mauke: So is there a more elegant way of making Tree and BinTree instances of Ord than this http://pastebin.ca/1638091 ?
12:09:52 <maltem> Parkotron, if you code that the "obvious" way, then you can't have any B instance that isn't an A instance
12:10:32 <earthy> the 3MB posed a bit of a challenge when installing linux in october of 1993
12:10:39 <mmorrow> Paczesiowa: this is a good one http://portal.acm.org/citation.cfm?id=651622&dl=GUIDE&coll=GUIDE&CFID=59106406&CFTOKEN=62222695
12:10:49 <Parkotron> maltem: What the obvious way? :)
12:10:54 <earthy> as SLS's installer required 4...
12:11:44 <hackagebot> yuuko 2009.10.23 - A transcendental HTML parser gently wrapping the HXT library (JinjingWang)
12:12:11 <lament> what
12:12:17 <maltem> Parkotron, if you don't know then you're cleverer then me because it's plain wrong: instance A a => B a where ...
12:12:50 * mux wonders what a transcendental parser is supposed to be
12:13:03 <mmorrow> transcend parsing of course
12:13:26 <maltem> Parkotron, in your example I'd probably omit the functions in question from your other class, no point in having part of Ord duplicated in another type class
12:13:42 <maltem> i.e. just define the Ord instance right away
12:14:19 <Parkotron> maltem: But then I'd have to define those functions once for each of my TraceableTree instances, right?
12:14:50 <maltem> ah you're having defaults
12:15:32 <Parkotron> Exactly. All but one of the functions are defaults. The instance only needs to implement "traces".
12:15:55 <maltem> But you dou have some instances that overwrite the defaults?
12:16:18 <Parkotron> No. Only "traces" gets reimplemented.
12:17:02 <maltem> then, easy: scratch the defaults, and write them as plain functions (i.e. move them out of the class definition)
12:17:46 <Parkotron> What type will they take as input, then?
12:18:06 <maltem> just try it out and let the type-checker infer the type, and observe in ghci
12:18:41 <Parkotron> I don't see how that would make things any easier.
12:19:34 <maltem> Erm, yes, if thinking of your original problem, that doesn't solve it really ;)
12:19:57 <Parkotron> What I have works. It's just the fact that the implementation of "instance Ord(Tree a)" is identical to "instance Ord(BinTree a)".
12:20:20 <Parkotron> My instinct tell me that there should be a clever way to avoid that repetition.
12:20:28 <Parkotron> But maybe there isn't.
12:21:03 <maltem> I see now. Don't drink and write, they say :)
12:22:12 <maltem> But there isn't a way to not have one "instance Ord" declaration for each type, no.
12:22:41 <maltem> You *could* write along the lines of:
12:22:56 <Parkotron> maltem: Thanks. That answers my question.
12:23:29 <maltem> newtype TraceOrder a = TraceOrder a; instance Traceable a => Ord (TraceOrder a)
12:24:42 <maltem> then you wrap your trees in TraceOrder to use the Ord instance
12:25:05 <solidsnack> What is weakening?
12:25:14 <mreh> The leksah doc says this: Run leksah and when it asks for paths under which haskell source packages may be
12:25:14 <mreh> found add the following to the list.
12:25:45 <Parkotron> maltem: I see. Seems like overkill in this particular case, but I'll keep that in mind. Thanks.
12:25:54 <mreh> with some long location that doesn't exist on my system, and probably never will
12:26:06 <ad4m> is there a way to write a partially applied function for the - function with the right operand provided? (-2) doesn't work because it is parsed as negative 2
12:26:22 <mauke> :t subtract
12:26:23 <lambdabot> forall a. (Num a) => a -> a -> a
12:26:25 <mreh> any ideas what the haskell source packages are? are they src files for the library
12:26:33 <Paczesiowa> mmorrow: what's so interesting about it?
12:26:43 <mreh> libraries*
12:28:05 <mmorrow> Paczesiowa: it classifies 4 related systems of program specialization, and gives mapping between the methods of each
12:28:44 <ad4m> mauke: thanks, i thought there might be a syntax trick to get it to work with -, but i guess not?
12:28:52 <mauke> no, - just hates you
12:29:02 <mmorrow> Paczesiowa: (deforestation is the least powerful of the three as well)
12:29:03 <mauke> (unary minus)--
12:29:07 <Paczesiowa> mmorrow: I'm only interested in deforestation atm
12:29:09 <mmorrow> *of the four
12:29:53 <mmorrow> Paczesiowa: why deforestation in particular?
12:30:38 <fnord123_> does anyone have a good link for examples of usage of Data.FingerTree? Maybe the yi source would be a good example?
12:30:44 <Paczesiowa> mmorrow: I'm going to give a talk about stream-fusion and I wanted to start with that Wadler's idea and foldr/build
12:32:16 <mmorrow> Paczesiowa: what sort of information are you looking for in particular?
12:32:39 <Paczesiowa> fnord123_: http://apfelmus.nfshost.com/monoid-fingertree.html . sigfpe also had a post about using them
12:33:19 <Paczesiowa> mmorrow: what happened to Wadler's idea, it was the only one that was fully automatic (but first order)
12:38:26 <sinelaw> mmorrow, huh?? the acm portal actually says that I'm you when I access the link you gave
12:38:44 <Botje> hurray for inadvertent session hijacking :]
12:38:49 <sinelaw> that's surprising (though it doesn't actually think i really have a membership)
12:39:13 <sinelaw> :}
12:39:16 <mmorrow> Paczesiowa: section 2 of the "A Short Cut to Deforestation" paper seems to cover the "major drawbacks" of deforestation
12:39:46 <mmorrow> sinelaw: haha, that's what they get for using IIS
12:39:50 <sinelaw> does it ever end? every paper i read makes me fell stupid if i don't read at least 50% of the cited papers
12:40:04 <sinelaw> *feel
12:40:08 <Botje> sinelaw: eventually you will get to the _|_, don't worry.
12:40:33 <Paczesiowa> unless there is a pair of mutually recursive papers
12:40:39 <Berengal> sinelaw, I have that problem too. Why can't more people write about simple stuff, like adding and subtracting regular integers?
12:41:01 * mmorrow logs out before anyone haxxors his account
12:41:12 <Paczesiowa> Berengal: there's plenty of that...at the type level
12:41:19 <Berengal> Paczesiowa, :(
12:41:26 <sinelaw> mmorrow, nah i already tried haxxoring it but it only shows your name, not allowing anything really
12:41:34 <mmorrow> sinelaw: heh
12:41:54 <Cale> An integer n is called regular if ...
12:42:46 <Berengal> Cale, I'm hoping something more along the lines of 'You have one apple, then you get two more. The number of apples you've got now is called Î£. What is Î£?"
12:43:04 <sinelaw> It's a thunk
12:43:08 <Berengal> "Î£ is 3. Q.E.D."
12:43:31 <mmorrow> you need a mirror i think for the QED there..
12:43:42 <sinelaw> See (Pythagoras, 1000B.C.)
12:44:08 <Berengal> sinelaw, I bet it's a bitch to get a hold of some of his papers
12:44:31 <sinelaw> today i toyed a little with the idea of adding ADTs to C/C++, this is how far I got
12:44:38 <sinelaw> http://github.com/sinelaw/cext/blob/master/test.cpp
12:44:42 <sinelaw> (not very far at all)
12:45:51 <sinelaw> the real approach should be to define a complete DSL in haskell that is translated to C
12:47:26 <sproingie> sinelaw: looked at Loki?
12:47:32 <Paczesiowa> sinelaw: there's C monad
12:48:21 <sinelaw> sproingie, nope
12:48:46 <sproingie> sinelaw: it's the ne plus ultra of C++ template abuse
12:48:53 <sproingie> does a list datatype
12:48:56 <burp> a C monad?
12:49:19 <Paczesiowa> burp: http://hackage.haskell.org/package/cmonad
12:49:52 <burp> "makes it very slow." o0 ;)
12:50:06 <fnord123_> Paczesiowa: thanks.
12:50:21 <sinelaw> Paczesiowa, i'll look at that
12:50:27 <sinelaw> sproingie, Loci doesn't seem to be what i want.
12:51:01 <Paczesiowa> burp: probably some rewrite rules to make it use regular IORefs would bring back the speed of ugly, imperative haskell
12:51:41 <sproingie> i think there are some shootout samples that show off imperative haskell in all its hideous glory
12:52:06 <sinelaw> Paczesiowa, what I really want is to translate it directly to C
12:52:30 <Paczesiowa> sinelaw: there's Language.C, you can generate some code:)
12:52:53 <sinelaw> sorry - not this, i want a DSL that is translated to C, and has the equivalent semantics of C + polymorphic ADTs (which needs definition...)
12:54:11 <sinelaw> ah that could be nice
12:54:43 <Paczesiowa> sinelaw: well, simple embedded "compiler" taking cmonad and outputting Language.C would be ok. plus some safe wrapper for tagged unions to implement adts
12:54:48 <sinelaw> i guess the hard work will be to define how these ADTs work and to implement them in C
12:55:41 <sinelaw> Paczesiowa, yip. I hope I get around to doing it....Peaker is also considering it
12:56:14 <Paczesiowa> there's nothing better than "getting around to do something":)
12:56:36 <Paczesiowa> oh, look! shiny red ball!
12:57:16 <sinelaw> :) with a toddler running around my home, it's literally that
13:00:18 <thermoplyae> we just had a keal visit in #math, and i wanted to thank whoever added the @keal function to lambdabot
13:01:19 <dolio> Was it actually keal, or just a doppelganger?
13:01:49 <sinelaw> what's @keal?
13:01:53 <dolio> @keal
13:01:54 <lambdabot> i can explain why something is without knowing what the rules decided by man are
13:02:10 <dolio> @keal
13:02:11 <lambdabot> there is no way to prove the failsafe exists
13:02:14 <thermoplyae> he's as real a keal as i've ever experienced
13:02:51 <maurer_> Does anyone know of any packages that use HUnit well? I would like to learn to use it, and I learn best by example.
13:05:30 <sinelaw> What's the "parametricity property that polymorphic functions enjoy"?
13:05:47 <sinelaw> and why does 'seq' weaken it?
13:06:53 <dolio> @free a -> b -> b
13:06:54 <lambdabot> Extra stuff at end of line
13:07:00 <dolio> @free seq :: a -> b -> b
13:07:01 <lambdabot> g . seq x = seq (f x) . g
13:08:33 <sinelaw> dolio, the point is that seq doesn't actually satisfy this?
13:09:27 <dolio> I'm not actually sure. There are a lot of assumptions about f and g that aren't stated there.
13:10:15 <dolio> But, I suppose, if you pick f _ = undefined, that equiation is wrong.
13:10:29 <sinelaw> or even x = undefined
13:11:03 <dolio> Well, that case may work, because I think the free theorems typically state that f and g are supposed to be strict.
13:11:07 <hackagebot> yuuko 2009.10.23.1 - A transcendental HTML parser gently wrapping the HXT library (JinjingWang)
13:11:15 <sinelaw> ah
13:11:22 <dolio> So f undefined = undefined is assumed, which makes things work out.
13:12:22 <sinelaw> dolio, but then there's no difference between seq and any other function
13:12:33 <sinelaw> in this equation
13:13:13 <sinelaw> because for any h :: a -> b -> b, you have: g . h x != h (f x) . g, when f = undefined
13:13:15 <dolio> No, other functions would be expected to behave appropriately in the f _ = undefined case, I think.
13:13:59 <maurer_> Does anyone know how to invoke a HUnit style or similar testsuite from a .cabal file?
13:14:02 <sinelaw> why should they
13:14:19 <dolio> Well, the other cases are a constant function...
13:14:50 <dolio> g (const x y) = const undefined (g y), which is fine if it's a non-strict constant function.
13:15:38 <dolio> And without seq, there's no way to make a strict, polymorphic constant function.
13:16:00 <dolio> Of course, that doesn't bode well for, say, ML. But I'm a bit out of my depth here.
13:16:26 <sinelaw> ok, so what is the parametricity property?
13:17:02 <dolio> The other case is undefined. g (undefined x y) = undefined (f x) (g y), both sides of which are undefined if g is strict.
13:17:57 <dolio> I don't think I'm equipped to explain it. You'll have to read Wadler's Theorems for Free.
13:18:38 <jmcarthur> Free Theorems in the Presence of Seq
13:18:41 <Paczesiowa> maurer_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11056#a11056
13:18:46 <dolio> Yes, there's that, too.
13:18:52 <sinelaw> dolio, ok, added to stack :) i've heard of it already
13:19:18 <jmcarthur> http://citeseer.ist.psu.edu/johann04free.html
13:19:19 <Paczesiowa> maurer_: Test.hs uses HUnit
13:19:44 <maurer_> Paczesiowa: OK. I don't suppose that there's some way to use a compiled version instead? My testsuite is going to take fucking forever if interpreted.
13:20:02 <maurer_> i.e. can I maybe build an Executable target and then have it not be installed?
13:20:28 <Paczesiowa> maurer_: system () can do whatever you want, use ghc -O2 and then ./binary
13:21:18 <Paczesiowa> maurer_: does it have to be cross-platform?
13:22:33 <maurer_> Paczesiowa: Technically no, though it would be nice if it was. I was hoping to build the test app via cabal if possible though, to avoid package version silliness.
13:24:01 <Paczesiowa> maurer_: make cabal build executable, but only if configured to do so
13:24:12 <Paczesiowa> maurer_: with no by default
13:25:11 <maurer_> Paczesiowa: Yeah, I can see that option, I just assumed we probably had a "right" way of doing this so that the app would be built and run on cabal test, but not on anything else.
13:25:51 <maurer_> Paczesiowa: Also, if you are going to use runhaskell to invoke it anyways, why not import your testfile into Setup.lhs and invoke the tests directly?
13:26:36 <Paczesiowa> maurer_:  no idea, I copied that from somewhere
13:26:56 <Paczesiowa> maurer_: but that wouldn't be good for distribution
13:27:10 <maurer_> How so?
13:27:22 <sinelaw> (:[]) is the list gorilla
13:27:24 <maurer_> You would still execute cabal test to trigger the testing.
13:27:42 <Paczesiowa> maurer_: regular users would have to compile my tests
13:27:42 <mm_freak> i'm reading from a source where lines end in either \r or \n, so i can't use hGetLine (portably)
13:27:49 <mm_freak> do i have to do all the buffering myself now?
13:28:07 <Paczesiowa> maurer_: those tests require HUnit and other libraries
13:28:27 <mm_freak> i can't use hGetContents, because it lacks proper error handling
13:28:31 <maurer_> Paczesiowa: I suppose. I just figured there would be a right way to deal with this inside cabal
13:28:48 <Paczesiowa> mm_freak: hGetContents and split it yourself
13:29:01 <Paczesiowa> maurer_: dcoutts is over there:)
13:29:15 <mm_freak> Paczesiowa: see above
13:29:27 <mm_freak> i'd need to reinvent hGetContents
13:29:37 <mm_freak> (although that's probably not that bad)
13:36:39 <stanv> my vim doesn't open file under cursor when I press 'gf' or 'ctrl-w-ctrl-f' at import :(
13:37:09 <SubStack> @pl \x -> print x >> return x
13:37:09 <lambdabot> liftM2 (>>) print return
13:37:12 <SubStack> o_O
13:37:27 <stanv> E447: Can't find file "Tree" in path
13:37:28 <SubStack> oh wow, that seems completely obvious now
13:37:29 <stanv> :(
13:39:13 <sinelaw> is academia the only way to get to research whatever you want ?
13:39:30 <dpratt71> well, I see that Ch. 4 of Erik Meijer's Haskell lecture is up on Channel 9...
13:39:40 <Paczesiowa> being rich also works
13:40:06 <Berengal> dpratt71, downloading it now
13:40:15 <dpratt71> ...what do y'all think about Haskell getting this kind of main-stream dev sphere attention?
13:40:17 <Berengal> (I'm actually watching to learn more about C#)
13:40:34 <sinelaw> Paczesiowa, unfortunately, that's not the case
13:40:38 <dpratt71> Berengal: hey, we should do a knowledge swap :)
13:41:09 <Berengal> dpratt71, not sure if I want to. I'm quite happy with Haskell ;)
13:41:28 <dpratt71> :)
13:42:55 <Berengal> dpratt71, as for your other question, I think it's great. I hope we'll write better code faster in the future, and I think functional programming is the right way to go
13:43:10 <Paczesiowa> what's Roman Leshchinskiy's nickname?
13:43:11 <dpratt71> Haskell seems pretty perfect to me in my limited understanding; thus it's been interesting to see Erik point out the occasional thing that may be better in imperative /OO langs vs. Haskell
13:43:19 <Berengal> (At least I'm writing better code faster in haskell than any other language at the moment)
13:43:32 <Associat0r> dpratt71 it's good because it will result in better languages
13:43:41 <Associat0r> dpratt71 I mean better mainstream langs
13:43:51 <dpratt71> Associat0r: better than Haskell? how? :)
13:44:02 <dpratt71> ah
13:44:13 <dpratt71> too late with my retort :(
13:44:16 <Associat0r> dpratt71 systems languages for one
13:44:19 <Berengal> dpratt71, some things are made more convenient in imperative/OO languages, but in my experience it's not hard to express the same abstractions in haskell
13:44:26 <mmorrow> @let symGroupGens n = let x = take n ['a'..]; xs = permutations x; ys = nub [(a,b)  | a <- xs, b <- xs, and (zipWith (/=) a b)] in (x,x) : take (length ys `div` 2) ys
13:44:27 <lambdabot>  Defined.
13:44:34 * mmorrow puts a bounty on golfing that
13:44:53 <mmorrow> (it computes the generators of the symmetric group on n elements)
13:44:54 <Associat0r> dpratt71 a better mainstream systems language than C++ is what I would like to see
13:45:14 <Berengal> dpratt71, plus you get the ability to write your own abstractions that work for more than just imperative/OO type programming styles
13:45:19 <dpratt71> please forgive me, as I say this in relative ignorance of Haskell...
13:45:24 <mmorrow>  == the distinct permutations of a set of n elements, no of which leave any element fixed
13:45:38 <mmorrow> > synGroupGens 3
13:45:39 <lambdabot>   Not in scope: `synGroupGens'
13:45:43 <mmorrow> > symGroupGens 3
13:45:45 <lambdabot>   [("abc","abc"),("abc","bca"),("abc","cab"),("bac","cba"),("bac","acb"),("cb...
13:45:49 <mmorrow> > symGroupGens 2
13:45:50 <lambdabot>   [("ab","ab"),("ab","ba")]
13:45:56 <mmorrow> > length $ symGroupGens 3
13:45:56 <lambdabot>   7
13:45:59 <dpratt71> ...the one thing I would wish for in H is somewhat clearer organization/naming of stuff...
13:46:06 <mmorrow> err, i included id in there too
13:46:49 <dpratt71> ...maybe namespaces or something similar to give some more organization to the RTL?
13:47:32 <Associat0r> dpratt71 better modules, better records, there is a lot of room for improvement
13:47:33 <Berengal> dpratt71, we've got modules, and they work good enough. It's just a matter of getting used to them
13:48:16 <Berengal> dpratt71, of course, since haskell isn't as extensively used as more mainstream languages, things like namespaces aren't stressed as much, and we can get by with simpler solutions
13:48:22 <dpratt71> Berengal: the functionality is good...I'm just used to a more hierachical (sp?) structure...Haskell's seems kinda flat
13:48:48 <sinelaw> dpratt71, there's qualified imports
13:48:53 <sproingie> the Prelude is kind of a mishmash, without it there would be more hierarchy
13:48:55 <sinelaw> (that should be the default, but aren't)
13:49:17 <dpratt71> ...and the naming of things?...liftM2?
13:49:20 <sproingie> just the way functional tends to go though, you usually want your combinators in a nice flat namespace
13:49:51 <dpratt71> sproingie: yeah, I wouldn't want to namespace-qualify an operator
13:50:57 <sproingie> i think the explosion of infix operators has added a lot of noise to what's otherwise the cleanest syntax around
13:51:11 <dpratt71> F# does some kind of block-scoping for Monads...uh...or whatever F# calls them
13:51:41 <sproingie> i wouldn't mind a syntax for infix that says "this whole token is the operator", not based on just it being all punctuation
13:51:54 <sproingie> foo Â«apÂ» bar
13:51:54 <Associat0r> dpratt71 computation expressions
13:52:02 <dpratt71> Associat0r: right
13:52:33 <sproingie> backtick is all right i guess.  i kinda like guillemets
13:52:36 <Associat0r> dpratt71 in H you would do block $ do bla
13:52:39 <sproingie> (unicode ftw)
13:52:57 <mmorrow> err, i meant (symGroupGens n) are the /elements/ of the symmetric group on the underlying set of n elements, and those elements can be identified with the permutations of a set of (n`div`2) elements where none of those perms leave any element fixed
13:53:05 <mmorrow> phew
13:53:14 <dpratt71> what's guillemets?
13:53:24 <sproingie> Â«french quotesÂ»
13:53:41 <dpratt71> sproingie: I see
13:53:45 <Associat0r> dpratt71 same thing really
13:53:48 <sproingie> there's just so much noise when everyone defines their own infix operators
13:54:00 <Associat0r> dpratt71 are you into F# too?
13:54:03 <mmorrow> here's S_4 http://upload.wikimedia.org/wikipedia/commons/3/3f/GrapheCayley-S4-Plan.svg
13:54:07 <mmorrow> > symGroupGens 4
13:54:09 <lambdabot>   [("abcd","abcd"),("abcd","dcba"),("abcd","cdba"),("abcd","bcda"),("abcd","d...
13:54:29 <dpratt71> Associat0r: sorta; it's hard to enjoy F# after you've seen haskell
13:54:52 <Associat0r> dpratt71 I am into it too
13:54:59 <Associat0r> dpratt71 I idle a lot in #fsharp
13:54:59 <dpratt71> I mean, even "let"  everywhere annoys me :)
13:55:19 <sproingie> maybe someone should revive liskell :)
13:55:38 <dpratt71> sproingie: what's liskell?
13:55:44 <sproingie> dpratt71: sexp syntax for haskell
13:56:23 <dpratt71> sproingie: perhaps a heretical thing to say, but I've never bothered to try to pick up Lisp
13:56:35 <sproingie> sure but you know what it looks like
13:57:19 <dpratt71> (((((((((((((((((((((((((((((((((((....)))))))))))))))))))))))))))))))))))
13:57:34 <Elly> that would be badly-written lisp
14:01:08 <Vanadium> @let (â¬) = flip ($)
14:01:10 <lambdabot>  Defined.
14:02:15 <pumpkin> @let (Â¥) = ($) . ($)
14:02:16 <lambdabot>  Defined.
14:03:02 <Jafet> I have witnessed the birth of future lol
14:03:17 <pumpkin> :t (Â¥)
14:03:18 <lambdabot> Not in scope: `??'
14:03:20 <pumpkin> :(
14:03:24 <O_4> Aww
14:03:30 <Jafet> ...hampered by unicode.
14:03:31 <pumpkin> > (+1) Â¥  5
14:03:33 <lambdabot>   6
14:03:43 <pumpkin> I guess :t is dumber
14:03:53 <sproingie> @type (Â¥)
14:03:54 <lambdabot> Not in scope: `??'
14:04:50 <sproingie> > length "Â¥"
14:04:51 <lambdabot>   1
14:05:11 <sproingie> does just seem to be :t that's confused
14:05:29 <pumpkin> @run (+1) Â¥ 1
14:05:31 <lambdabot>   2
14:06:49 <sproingie> yen symbol might not be the best test.
14:06:58 <sproingie> > length "åª½"
14:06:59 <lambdabot>   1
14:07:06 <sproingie> and the world is sane
14:07:24 <pumpkin> in many languages that is not the case
14:07:26 <pumpkin> sadly
14:07:44 <sproingie> even a ligature is still just one character
14:07:48 <pumpkin> > length "ðª¥
14:07:50 <lambdabot>   <no location info>:
14:07:50 <lambdabot>      lexical error in string/character literal at end o...
14:07:53 <pumpkin> > length "ðª¥
14:07:55 <lambdabot>   <no location info>:
14:07:55 <lambdabot>      lexical error in string/character literal at end o...
14:07:57 <pumpkin> dammit
14:08:05 <pumpkin> I think my IRC client is failing on that one, not lambdabot
14:08:20 <Giarome> hi i have a question: where are the files located, the :load command takes them from?
14:08:47 <Giarome> im using windows Haskell Platform 2009.2
14:09:13 <tommd> Giarome: The local directory, but you can provide the full path I believe.
14:09:34 <tommd> I don't usually use :load.  I use :module for my loading needs.
14:09:51 <O_4> You can use ":cd <dir>" to change the current directory
14:10:30 <Giarome> thanks !!!
14:10:33 <Giarome> works
14:11:03 <Giarome> my prompt changed
14:11:33 <Giarome> how can i unload modules?
14:12:12 <sproingie> :m -Module.Name
14:12:59 <Vanadium> > ("foo", "bar") â¬ do f <- fst ; s <- snd ; const $ f ++ s
14:13:01 <lambdabot>   "foobar"
14:13:03 <Vanadium> I am pretty bad at this
14:13:14 <pumpkin> lol
14:13:15 <pumpkin> that's cute
14:13:49 <Giarome> doesn
14:13:54 <Giarome> 't work
14:14:10 * pumpkin attempts to read Giarome's mind
14:14:12 * pumpkin fails
14:14:14 <Giarome> i have located my module in C:\ch2\add.hs
14:14:41 <Giarome> loaded with :load C:\ch2\add.hs
14:14:46 <Giarome> can
14:14:47 <Giarome> t unload
14:15:02 * Baughn has gotten in the habit of prefixing all his IO functions with liftIO. Anyone else?
14:15:05 <ystael> is there anywhere out there a set of "finger exercises" in basic combinators, so that for instance i can learn to see at a glance that ($) . ($) = ($), and eventually perform @pl with the power of my mind ?
14:15:19 <pumpkin> ystael: you just get used to it
14:15:32 <pumpkin> ystael: fwiw, ($) is id with a more restricted type signature
14:15:37 <pumpkin> ystael: so id . id = id
14:16:24 * ystael facepalms.  i never realized that, having always thought of ($) as taking two arguments.
14:16:46 <pumpkin> > (+1) `id` 5
14:16:47 <pumpkin> :)
14:16:47 <lambdabot>   6
14:16:59 <pumpkin> $ just has a lower precedence and fewer characters
14:17:00 <Saizan_> arity is overrated
14:17:17 <ystael> pumpkin: when did you lose your dualization, anyway?
14:17:26 <Baughn> @type ($)
14:17:26 <pumpkin> ystael: I'm on my big computer right now
14:17:27 <lambdabot> forall a b. (a -> b) -> a -> b
14:17:33 <Baughn> @type ($) . ($)
14:17:34 <lambdabot> forall a b. (a -> b) -> a -> b
14:17:47 <Paczesiowa> :t flip id
14:17:48 <lambdabot> forall b c. b -> (b -> c) -> c
14:17:51 <pumpkin> ystael: my big computer tends to be pumpkin and my tiny laptop is copumpkin, but that's not always true
14:17:57 <Baughn> @type iterate ($)
14:17:58 <lambdabot> forall a b. (a -> b) -> [a -> b]
14:19:04 <ystael> pumpkin: the functional analyst in me thinks it should be the other way around, on account of the natural embedding into-but-not-necessarily-onto the double dual of a banach space :)
14:19:17 <Saizan_> > iterate ($) (+1) `sequence` 1
14:19:18 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
14:21:31 <ystael> @type iterate ($) (+1)
14:21:33 <lambdabot> forall a. (Num a) => [a -> a]
14:23:37 <ystael> Saizan: so the monad on which sequence acts in that is the reader monad?
14:24:23 <Baughn> Reader's nifty. ^_^
14:24:44 * Baughn is now up to "ReaderT Context (StateT Peer IO a)"
14:24:59 <Saizan> ystael: yup
14:25:27 <Baughn> @unmtl ReaderT Context (StateT Peer) IO a
14:25:27 <lambdabot> err: `StateT Peer IO' is not applied to enough arguments, giving `/\A. Peer -> IO (A, Peer)'
14:25:40 <Baughn> @unmtl ReaderT Context StateT Peer IO a
14:25:40 <lambdabot> err: `StateT Peer' is not applied to enough arguments, giving `/\A B. Peer -> A (B, Peer)'
14:25:44 <Baughn> ..how /do/ I write that?
14:26:03 <Baughn> @unmtl ReaderT Context (StateT Peer IO) a
14:26:03 <lambdabot> Context -> Peer -> IO (a, Peer)
14:29:35 <_Ray_> Hey, question. In pattern matching, can I match a non-normal-form expression? Like, func foo (bar baz) = baz?
14:29:57 <opqdonut> if bar is a function, no
14:30:05 <pumpkin> it must be constructors
14:30:06 <opqdonut> if bar is a constructor, natrually
14:30:22 <_Ray_> Hrm, damn. Yeah, bar was a function. I should use guards, then?
14:30:35 <pumpkin> yep, or view patterns
14:30:59 <_Ray_> Just starting in Haskell, don't think I'm supposed to use patterns yet xD (for a class assignment)
14:31:32 <lament> either guards or just an if statement
14:37:25 <Twey> _Ray_: What exactly are you trying to do?
14:37:35 <Twey> There's probably a way to do it.
14:37:55 <mreh> how might one automate the exhaustive process of discovering the minimum dependencies of a package you've writte
14:38:56 <_Ray_> Twey, it's long and ugly :p I'm traversing a grid, and I want the adjacent coordinates if I'm at a point (x, y). If I'm at 1 1, the adjacents are 1 2 and 2 1. I can match " 1 1 " in my function, then. But I want a similar thing when I'm at (width height), meaning the lower right of the grid. Those two things are functions of the grid. I wanted to see if I could match it directly instead of using guards.
14:39:20 <pumpkin> _Ray_: sounds like a project euler problem
14:39:35 <PetRat> Question about Control.Exception : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11061#a11062  (look at the last entry)
14:39:46 <_Ray_> pumpkin, not really.
14:40:24 <_Ray_> I'm given a black-white colored grid, and I want to find the largest "cluster" of white cells, where a cluster is a white cell with a white cell to the right, top, left or down.
14:41:01 <Baughn> @hoogle unsafeIOToSTM
14:41:01 <lambdabot> No results found
14:41:01 <Twey> _Ray_: You can use view patterns: foo (((== width grid) -> True), ((== height grid) -> True)) = bar
14:41:06 <_Ray_> I'm traversing each cell, and if it's white, I get the math pathLength starting from tha cell, and without touching that cell. pathLen tries to do the same (grab my neighbours, ask them the longest path they have without going back)
14:41:06 <Twey> I think guards are best suited, though.
14:41:35 * Baughn reads the warnings on unsafeIOToSTM. Eep. unsafePerformIO sounds safer.
14:41:43 <_Ray_> Twey, I'm not supposed to, however :(. Hell I can't even use higher order functions or lists by comprehension :(
14:41:44 <Saizan> PetRat: it doesn't even get called unless the exception is of the matching type
14:41:52 <ddarius> I believe unsafeIOToSTM almost never works.
14:42:00 <Twey> Haskell, without the Haskell!
14:42:13 <Baughn> ddarius: I was hoping it'd just be something like "function might be run multiple times, or not at all"
14:42:21 <Baughn> I could live with that. It's just verifyPublicKey.
14:42:39 <pumpkin> Baughn: why is verifyPublicKey in IO anyway?
14:42:47 <Twey> Reasonable for a teaching exercise, though, I guess.
14:42:47 <Twey> At least in the early stages.
14:42:52 <pumpkin> does it actually check a cert and a CRL?
14:43:20 <Baughn> pumpkin: Because a lot of hsOpenSSL functions are in IO, regardless of whether or not they technically should need to be
14:43:35 <Baughn> pumpkin: However, STM apparently /bypasses exception handlers/ if it terminates... ugh
14:43:41 <pumpkin> Baughn: if they're referentially transparent, just unsafePerformIO it then
14:43:41 <Twey> >.<
14:43:57 <Baughn> pumpkin: They are. However, they allocate memory that needs manual cleanup.
14:44:02 <pumpkin> oh, ew
14:44:05 <Baughn> C-heap memory, that is
14:44:11 <ddarius> Allocation is a side-effect.
14:44:20 <pumpkin> ugh :)
14:44:39 <Baughn> The function as a whole should be referentially transparent, IF exception handlers aren't bypassed
14:44:49 * Baughn hits STM with something hard
14:45:07 <Baughn> ..come to think of it, that behaviour would drastically break my FRP implementation inside atomically, too
14:45:56 <Baughn> ...so, what, do I put a "don't use inside STM" warning on them? o_O
14:46:11 <PetRat> Saizan: I'll think about this. handleJust has a type with the constraint Exception e, and ArithException is an instance. But I don't know if I've ever tried to write a functiont hat behaved like handleJust---something that responds to the "type" it is given rather than the "type constructor"
14:46:15 <ddarius> Baughn: Try them and see what happens.
14:46:40 <Baughn> ddarius: Random lockups, I bet. I've got "unsafePerformIO $ withMVar ..." in there.
14:46:56 <Baughn> ddarius: ..I'll be sure to test that once it's usable.
14:48:17 <Saizan> PetRat: reading the extensible exceptions paper should clarify it up
14:48:40 <Baughn> ..hey, you found my pet rat!
14:48:54 <Baughn> PetRat: How are you liking haskell? :)
14:49:41 <PetRat> Baughn: best language ever. Makes C++ look like Pascal.
14:49:57 <lament> uh, what? Pascal is much better than C++
14:50:32 * mpwd still doesn't get why "unsafePerformIO" gets such a crazy name while "hd", which is like the same thing has such a simple name
14:50:54 <mpwd> Only hd is for the list monad instead of IO
14:51:15 <PetRat> Saizan: okay I found that paper online. It is mentioned in the Haddock docs but not linked from there.
14:51:18 <Twey> âhdâ?
14:51:25 <Twey> :t hd
14:51:26 <lambdabot> Not in scope: `hd'
14:51:28 <lament> mpwd: anyone can write head, because the definition of lists is available
14:51:30 <Twey> head?
14:51:31 <luite> head?
14:51:38 <lament> mpwd: but unsafePerformIO is completely magical
14:51:39 <luite> unsafePerformDecapitation?
14:51:43 <Twey> Hahaha
14:51:50 <mpwd> lament: I guess
14:52:26 * mpwd is sad that ocaml's hd has gotten mixed up with haskell's head
14:52:38 <PetRat> Baughn: I still haven't gotten to any major appolications, but rewrote a Python program of mine, in Haskell. Amazing how much shorter and clearer it became.
14:52:45 <mpwd> ....and in the back of my mind looms car... I'm happy I don't program lisp anymore...
14:53:15 <PetRat> Went from 1000 lines to maybe 400 lines. Probably could be less than that if I were a Haskell expert.
14:53:52 <tomh-> if you remove all enters it can be one line :)
14:54:04 <ddarius> PetRat: Try rewriting it in C++, maybe it will also be shorter.
14:54:21 <lament> in Pascal dammit.
14:54:29 <sm> PetRat: that's nice. I've found python still pretty competitive with haskell, at least in small progs
14:55:05 <sm> I bet you could have shrunk that python prog
14:55:09 <ddarius> lament: I never wrote any Pascal.  I could read it but never bothered learning to write it.  I'm pretty sure I would prefer C++ to Pascal though.
14:55:17 <Twey> The lack of types hurt me in Python more than anything else
14:55:41 <Baughn> PetRat: Always nice to see people joining us. The road to failure is paved with newbies.
14:55:44 <Baughn> Um...
14:56:00 <tromp> > take 10 $ nubBy (\a b -> b `mod` a == 0) [2..]
14:56:01 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:56:14 <ddarius> Baughn: Is that what newbies are for?
14:56:32 <Baughn> ddarius: Paving the road? Yes, of course.
14:56:40 <Baughn> ddarius: But only /after/ their brains explode.
14:57:03 <sproingie> rewrite it in J, it'll be one line
14:57:04 <Berengal> Baughn, did you figure out the MonadIO exception issue?
14:57:09 <ddarius> Yay J!
14:57:25 <Baughn> Berengal: By trying to write runMVar.
14:57:35 <Berengal> Baughn, http://hackage.haskell.org/packages/archive/Takusen/0.8.5/doc/html/Control-Exception-MonadIO.html
14:57:51 <PetRat> In this particular program, laziness helped a lot, because I needed to pass a long chain of characters through processing, keeping track of a running total of properties, and stop when it hit a number. In Haskell I could write each chain of processing as a lazy infinite loop, then just 'take' from the last list.
14:57:54 <Berengal> Baughn, this suggests a few things...
14:58:16 <tromp> :t nubBy
14:58:17 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:59:09 <Baughn> Berengal: Hm. Maybe..
14:59:14 <Baughn> Berengal: Bit of a hack, though
14:59:43 <Berengal> Baughn, indeed, but I don't think you can do it properly
14:59:55 <Baughn> Berengal: Er, sorry. Misread that sentence.. no, I have not figured out the MonadIO issue. I just froze it to IO.
15:00:50 <Berengal> Baughn, with the class you get what you already have, plus any MonadIO that bothers to define the CaughtMonadIO instance
15:01:03 <tromp> > nubBy (((==0).).mod) [2..99]
15:01:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
15:01:29 <Baughn> Berengal: ..and define it right. True, though I'd have to be very careful; I haven't checked that definition of bracket, but there's a good chance it's got race conditions.
15:01:37 <Baughn> Didn't see any reference to block when I glanced over it.
15:02:40 <Berengal> Baughn, the IO instance should be correct, no? Doesn't 'catch' block?
15:02:57 <Baughn> Berengal: ..of course.
15:03:01 <Baughn> So it does.
15:04:01 * Baughn is unsure whether he can write modifyMVar with just bracket, though
15:04:52 <Berengal> There's a small gap between acq and gcatch...
15:04:52 <Berengal> But that might be true for the IO bracket as well....
15:04:52 * Berengal checks the source
15:05:45 <Berengal> Baughn, gbracket is faulty. real bracket: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/src/Control-Exception-Base.html#bracket
15:06:04 <Baughn> ..righto.
15:07:36 <Berengal> What happens to async exceptions that are thrown in a blocking section by the way?
15:07:51 <Heffalump> they arrive when you unblock, IIRC
15:07:55 <dpratt71> Gah! Erik just said he likes dynamic dispatch more than pattern matching!
15:08:18 <Baughn> They arrive after you unblock. Not necessarily /immediately/ after, you understand.
15:08:27 <Berengal> dpratt71, he did, but I took it ironically, since he wanted people to implement 'and' using double dispatch as homework
15:08:48 <dpratt71> Berengal: gosh, I hope your right
15:09:12 <Berengal> dpratt71, (he probably wasn't ironic, but I still chuckled when he proposed that)
15:09:38 <dpratt71> maybe it's Dutch humor :)
15:11:25 <ddarius> Multiple dispatch is nice.
15:11:29 <Twey> Berengal, dpratt71: âErikâ who?
15:11:38 <dpratt71> Erik Meijer
15:11:41 <Twey> Ah
15:12:59 * ddarius recommends people look at a language Neel Krishnaswami started working on a while back called Needle.
15:14:18 <hackagebot> yuuko 2009.10.23.2 - A transcendental HTML parser gently wrapping the HXT library (JinjingWang)
15:15:21 <Twey> Designing OO functional languages is a PL smell IMO
15:16:03 <dpratt71> PL smell?
15:16:30 <dpratt71> PL?
15:16:37 <Twey> Like a code smell, but for programming languages.  âº
15:16:51 <dpratt71> Twey: ah
15:16:54 <Twey> And yes, there were too many acronyms in that message.  Sorry.
15:17:51 <ddarius> Needle seemed reasonably clean.
15:18:01 <sinelaw> oo sorta contradicts functionality
15:18:04 <sinelaw> at least pureness
15:18:18 <dpratt71> sinelaw: indeed
15:18:20 <ddarius> OO doesn't (have to) mean state.
15:18:26 <sinelaw> but also functional composability
15:18:51 <sinelaw> which may be the bigger issue
15:18:53 <dpratt71> ddarius: but isn't state encapsulation sort of the point of objects?
15:19:02 <Twey> It doesn't have to (which is why it's only a smell), but state is a big part of the reasoning behind OO
15:19:11 <ddarius> There are many concepts conflated into OO.
15:19:17 <dpratt71> ddarius: agreed
15:19:19 <ddarius> (Similarly for FP.)
15:19:22 <sinelaw> message passing
15:19:37 <dpratt71> ddarius: something I didn't appreciate before being exposed to FP, actually
15:19:45 <lament> all of OO is about compartmentalizing mutable state into mentally manageable chunks
15:19:56 <Twey> Aye
15:20:04 <PetRat> Coming to Haskell from OO, I found it interesting to discover that "classes" and "types" were different things.
15:20:17 <PetRat> OO conflates these in a way
15:20:18 <dpratt71> PetRat: exactly
15:20:23 <sproingie> that's my biggest difficulty in mentally translating OO code to functional, is dealing with state
15:20:33 <xcoder42> Hi, I'm pretty new to haskell, but i'm building a prolog parser in haskell  using the parsec library, will working on this i'm running into some problems with parsec, it seems that i cannot parse anything unless i know what is coming, which is a problem. more concretely i use " rest <- many (noneOf "."); " to get a piece of prolog out of my string, but i dont know if this is an array or a variable. i was hoping i could use try 
15:20:34 <Twey> It's about confining state mutations to an object scope, so that you get a sort of object-level referential transparency
15:20:34 <sinelaw> ddarius, can you enumerate? besides the state compartmentalization
15:20:44 <sproingie> i found a lot of what i thought was state was naught but illusion, just intermediate recordkeeping
15:21:00 <Twey> If you create an object and call a specific series of methods on it with the same arguments, you should get the same result
15:21:04 <sproingie> the stuff that really is state, well, i still have trouble with :)
15:21:24 <jmcarthur> that's not state either! :)
15:21:46 <jmcarthur> there is no such things as state. it's just a model we use in a purely functional world
15:22:00 <xcoder42> am i making any sense, and does anyone happen to know parsec and able to give a hand?
15:22:04 <sproingie> there was some article on writing games in a functional language that really flipped the switch in my brain.  i wish i could remember where it was
15:22:05 <sinelaw> Twey,  yeah, so OO doesn't have to imply evil side effects
15:22:29 <mmorrow> xcoder42: you could separate the logic that determines what the chars represent from the code that sucks non-"."s out of the char-stream
15:23:26 * ddarius personally thinks concurrency leads to a natural OO style that is clean.  Indeed, this is one of the sources of OO, but that aspect has been lost over time in most OO languages.
15:23:29 <sinelaw> xcoder42, you can use try, but i'm also new to parsec so i don't know if that's the best way
15:23:34 <mmorrow> xcoder42: and possibly pass two functions to that function, the first which will continue if it's one case, the second if it's the other
15:23:35 <ddarius> (and a bunch of other crap has been added.)
15:23:40 <jmcarthur> ddarius: yes
15:23:55 <sinelaw> ddarius, maybe Erlang captures that idea?
15:23:56 <sproingie> oh yah concurrency forces the encapsulation issue.  at least if you want to stay sane.
15:24:09 <sinelaw> basically message passing between concurrent objects
15:24:28 <jmcarthur> sinelaw: against the judgement of those more experienced with the language, i think erlang is one of the most pure OO languages
15:24:39 <pikhq> sinelaw: Erlang, Smalltalk (to an extent)... Yeah.
15:24:40 <mmorrow> do rest <- many (noneOf "."); whatToDo rest ({-is a var-}do .. assuming var) ({-is an array-}do .. assuming array)
15:24:53 <sproingie> erlang's a great platform, shame the syntax is so wretched.
15:24:58 <xcoder42> mmorrow: okay, so basically build some helper functions and send my substring to the helper for analyse?
15:25:01 <sinelaw> jmcarthur, it still allows side effects, if i understand correctly
15:25:02 <Twey> s/syntax/language/
15:25:12 <Twey> It allows side-effects in user-defined functions
15:25:24 <Twey> â¦ so only built-in functions are allowed in many contexts
15:25:28 <mmorrow> xcoder42: right, and also give control of the future path of execution to that function
15:25:29 <Twey> It's hideous
15:25:48 <sproingie> it's not pure, no, but it's better about it than python or perl
15:26:06 <mmorrow> xcoder42: and additionally pass it a parser for each of the possibilities it might need to continue with (or something)
15:26:07 <jmcarthur> it should do side effects by sending messages to processes which do it on your behalf
15:26:09 <sinelaw> is concurrent haskell similar to a pure erlang?
15:26:16 <jmcarthur> i don't recall how it actually works, though
15:26:33 <sinelaw> (without Erlang's process virtualization features)
15:26:44 <Twey> It's half-implemented
15:26:44 <sproingie> erlang is above all a practical thing
15:26:44 <Twey> sinelaw: Sort of
15:27:02 <xcoder42> mmorrow: alright, i'll give that a try, thx and thx to you too sinelaw, i'll try that if the first idea fails :)
15:27:15 <pikhq> sproingie: The language itself is a massive hack with some decent ideas behind it.
15:27:26 <sinelaw> xcoder42, you can also look at this, my attempt at a scheme parser
15:27:29 <sproingie> was originally written in prolog i hear
15:27:38 * pikhq nods
15:27:44 <sinelaw> xcoder42, from a fellow noob: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11064#a11064
15:28:00 <sinelaw> Speaking of Erlang
15:28:40 <xcoder42> sinelaw: great, i'll have a look
15:28:41 <sinelaw> I'm doing a project on FRP (my initiative) and a professor here seems to think it's a silly idea
15:28:44 <sinelaw> when you have Erlang
15:28:53 <Twey> pikhq: *nod*
15:29:16 <sproingie> erlang is an implementation, FRP is an idea
15:29:26 <sproingie> lot more fine-grained than erlang processes for sure
15:29:27 <sinelaw> sproingie, erlang's model, then
15:29:27 <Twey> Erlang is not an implementation of FRP
15:29:40 <Twey> Aye, as sproingie says
15:29:43 <sinelaw> Twey, i know he's wrong, but i need strong evidence
15:29:58 <Twey> FRP offers a lot more control, and type safety
15:29:59 <sinelaw> like a good example of what FRP would give
15:30:33 <sinelaw> for some reason he thinks that type safety is nice if you want to build a nuclear reactor,
15:30:59 <sproingie> dedicated mechanical devices are nice if you want to build a nuclear reactor
15:31:04 <sinelaw> but not for less critical stuff. i really disagree with him but have trouble formulating my arguments
15:31:48 <sproingie> i've a suspicion he's not going to be open minded
15:31:56 <sproingie> welcome to academia
15:31:56 <sinelaw> no, he actually is
15:32:03 <Twey> Ask him in what possible situation stability and automatic sanity-checking is a bad thing :Ã¾
15:32:07 <sinelaw> he's not eve in my department
15:32:20 <sinelaw> i just barged into his office because he's one of the few FP people here
15:33:07 <sproingie> the more expressive your type system is, the more properties you can prove about your system before you even write line 1 of code
15:33:17 <sproingie> well technically types are code, but they don't really compute
15:33:27 <sinelaw> true
15:33:42 <sinelaw> what i'd really like to show is a nice example
15:34:10 <sinelaw> of a reactive system implemented in a few different environments, and modelled in FRP (maybe implemented in Yampa)
15:34:23 <sproingie> i could never wrap my head around yampa
15:35:11 <sinelaw> neither can i, esp. the dpSwitch stuff, yet.
15:35:21 <dpratt71> it seems like the benefits of strong-typing are obvious; the better question, I think, is what are the disadvantages?
15:36:12 <Berengal> sinelaw, if you just want an argument for types, think about what they do besides provide safety. You can for example have a correct program in an untyped language (manual proof, or just dumb luck), but you can't dispatch on the return type of a function
15:36:16 <sinelaw> dpratt71, i guess "flexibility" when writing code
15:36:17 <sproingie> difficulty of expression
15:36:50 <Twey> But that's not really true
15:37:06 <sinelaw> Berengal, dispatch on the return type of a function <--- what?
15:37:09 <dpratt71> sinelaw: with a good type inference implementation, I'm not sure that's a disadvantage of strong-typing
15:37:13 <Twey> An error in a statically-typed language is generally an error in a weakly-typed language, too
15:37:15 <Berengal> @type read
15:37:17 <lambdabot> forall a. (Read a) => String -> a
15:37:24 <Berengal> sinelaw, ^^
15:37:25 <Twey> It just doesn't get caught until testing instead of straight away
15:37:58 <Berengal> sinelaw, go ahead, write a function that can parse anything (that's parseable)
15:38:00 <dpratt71> sinelaw: of course, you need an expressive type system underneath that, too
15:38:16 <sproingie> in the duck-typed language you're allowed to just catch the exception, or just take the risk and let it abort execution when it does happen
15:38:26 <sproingie> static types, you gotta reason about it up front
15:38:45 <sinelaw> Berengal, ok, i just didn't understand what you meant :)
15:38:49 <sinelaw> now i do
15:39:10 <sproingie> erlang handles messages it doesn't understand by ignoring them, no?
15:39:19 <Berengal> I don't find haskell to be inflexible compared to python. In fact, I often find python to be less flexible, because I can't encode some properties using types, and have to use a much more verbose runtime proof instead
15:39:21 <sinelaw> well you can do heterogenous data structures easily
15:39:22 <sproingie> or am i thinking of scala actors
15:39:36 <sinelaw> and with strong static typing it requires trickery
15:39:56 <Berengal> And these properties don't just all provide safety
15:40:13 <sproingie> that's because you bother with proofs
15:40:15 <Twey> A better way to say it is that Python doesn't provide built-in support for type-checking â it's necessary to do all the type-checking yourself, at runtime (lest the program crash)
15:40:21 <sinelaw> i've built a graph library in python, and nodes could have any types for the values (obviously)
15:40:22 <Berengal> On the other hand, dynamic languages does have an advantage when it comes to dynamic values...
15:40:26 <sproingie> of course all those unit test freaks are also bothering with proofs
15:40:37 <sinelaw> i have no idea how to do something equivalent in haskell or what that something should be
15:40:39 <sproingie> i've got a test suite called a compiler
15:40:48 <Twey> sinelaw: You can do heterogenous lists easily â but in practice, that's not actually very useful
15:40:53 <sjanssen> sproingie: data Graph a = Graph ...
15:40:55 <Berengal> In conclusion, I can't say which is the most flexible, but they're flexible in different areas
15:41:09 <Twey> What's the point?  You don't know what you're going to get back
15:41:38 <Twey> The only place it could be useful is having something like a list of alternating types, which can be encoded using a list of pairs
15:42:02 <sjanssen> sproingie: in Haskell, we don't bother with containers for "any" type, those are stupid.  Instead, our containers are polymorphic, and can hold any one type
15:42:33 <FunctorSalad> is there a way to get haskell-mode to work with projects where the source root directory is different from the .cabal file's dir?
15:42:34 <lament> containers for "any" type are stupid, hence Data.Dynamic
15:42:36 <FunctorSalad> e.g. ./src
15:42:39 <sjanssen> and there's always Data.Dynamic if one really does need an "any" type
15:42:54 <sinelaw> yeah i've heard of that one
15:42:57 <sproingie> sjanssen: that's the case with any statically typed language naturally.  tho an OO one, you can hold instances that are polymorphic
15:42:58 <FunctorSalad> ./src/Data/FooData.hs
15:43:02 <FunctorSalad> (relative to the .cabal)
15:43:16 <dcoutts> FunctorSalad: presumably the .cabal file does specify hs-src-dirs
15:43:27 <FunctorSalad> hmm guess I should just make a symlink to Data
15:43:34 <Berengal> sproingie, there's existentials, if that's your cup of tea
15:43:42 <SubStack> my derivied read doesn't parse my derivied show :(
15:43:43 <FunctorSalad> dcoutts: yes but haskell-mode ignores it?
15:43:45 <sproingie> Berengal: they kinda get there
15:43:55 <dcoutts> FunctorSalad: no idea, never used emacs
15:43:55 <FunctorSalad> (I'm not an elisp hacker sadly)
15:44:06 <sjanssen> sproingie: yes, open extension of types in Haskell isn't very fun
15:44:15 <sjanssen> we suck at that end of the expression problem
15:44:39 <FunctorSalad> classes...?
15:44:41 <sproingie> my first experience doing any serious amount of programming was with MUDs, so i always think in terms of "how would i implement an inventory" for containers, or "how would i resolve a combat round" for logic
15:44:44 <Berengal> sproingie, I haven't really had any genuine use for them though. A couple of times I've started out writing some existential type and messing around, but I've always ended up with either a simple ADT or maybe a class
15:45:13 <FunctorSalad> class + existential if you need to hold it in a container
15:45:51 <Berengal> FunctorSalad, but there are other ways of keeping stuff around that doesn't need explicit containers
15:45:53 <sinelaw> i wanted to build a structure where each node has typed input and output ports, and the ports must match
15:46:19 <FunctorSalad> sinelaw: category :)
15:46:21 <FunctorSalad> or arrow
15:46:32 <sinelaw> when you connect nodes, but the various types of nodes can be infinite (due to infinite possibilities of i/o ports types)
15:46:48 <sproingie> Berengal: i can usually get traditional OO polymorphism translated to generic polymorphism, but not always.  i'm still not quite "thinking in FP" all the time
15:47:24 <sproingie> sticking functions in records and using lots of composition works pretty well
15:47:38 <sinelaw> FunctorSalad, category only allows 'one port' so to speak
15:47:54 <FunctorSalad> sinelaw: I mean your nodes would be the arrows
15:48:01 <FunctorSalad> domain = input, codomain = output
15:48:28 <Berengal> sproingie, I can't do the translation either, but I very seldom find myself wanting to anyway. I blame the mismatch
15:48:42 <sinelaw> FunctorSalad, that's what Yampa does?
15:49:13 <sinelaw> and does Arrow allow any graph?
15:50:50 <sinelaw> what i don't like about arrow is that you explicitly have to say what is parallel to what
15:50:56 <sinelaw> if i understand Arrow at all
15:51:12 <sinelaw> i just want to say: connect node A port x to node B port y
15:51:34 <FunctorSalad> @type (<<<)
15:51:36 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
15:51:36 <Berengal> sinelaw, that's just arrow composition
15:51:50 <sinelaw> Berengal, not if A and B have multiple ports which are connected to other nodes
15:52:09 <FunctorSalad> use product types?
15:52:17 <Berengal> sinelaw, mutliple ports = single tuple-typed port
15:52:40 <Berengal> then, to connect e.g. the left port:
15:52:42 <Berengal> @type left
15:52:44 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
15:52:50 <Berengal> or
15:52:53 <Berengal> @type first
15:52:55 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:53:00 <sinelaw> Berengal, that's the point. you're forced to think in unnatural terms, and keep dealing with packaging/unpackaging your tuples to route the connections
15:53:22 <Berengal> sinelaw, or you could use arrow syntax
15:53:38 <FunctorSalad> how else do you want to deal with variable number of types on the type level?
15:53:52 <Berengal> FunctorSalad, recursion
15:54:20 <sinelaw> polymorphic recursion?
15:54:40 <Berengal> Recursion on the type-level
15:54:57 <sinelaw> example?
15:55:59 <Berengal> sinelaw, it's not unusual; you've probably done it lots of times already
15:56:04 <Berengal> @type fmap fmap fmap
15:56:05 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:56:11 <permagreen> Are you talking about recursive data structures? As in when you define a type in terms of itself?
15:56:25 <Berengal> Recursive unification
15:58:16 <sinelaw> i didn't do it, i'm still a haskell noob. how do you use that for this purpose?
15:58:50 <Berengal> sinelaw, still working on that :P I'm pretty noobish with arrows myself
15:59:35 <sinelaw> anyway, my point was that constructing this with arrows leaves you with a very 'dirty' structure (full of packings/unpackings)
16:00:14 <Berengal> sinelaw, but basically, by using arrows, you shouldn't have to care about the types of your arrows except the two you're connecting. How they work inside is none of your business
16:00:38 <Berengal> And neither is how they're used
16:00:47 <sinelaw> when i just want to know who is connected to one of A's ports, i have to do some major processing on the arrow structure
16:01:09 <sinelaw> Berengal, but i want to use this for building a structure that i can process (a DSL)
16:06:40 <sinelaw> i'm still waiting for ideas on how to do this without polluting the structure. maybe i'm missing something and it's entirely possible to build a clean structure using Arrow
16:07:46 <SamB_XP> sinelaw: so ... what are you actually attempting to do ?
16:07:59 <sinelaw> implement FRP :)
16:08:12 <tommd>  reimplement?
16:08:14 <sinelaw> (as an exercise)
16:08:54 <sinelaw> (and because i want to try something slightly different)
16:09:38 <sinelaw> tommd, also, if i'm not mislead, Reactive has bugs, and also i'm not sure I like Yampa's model for dynamicism
16:11:09 <sinelaw> probably i don't understand it, either
16:14:15 <sm> wow, hint looks pretty useful
16:14:47 <sm> maybe I can use it to load largish modules discovered at runtime
16:22:39 <SubStack> I am beginning to hate non-derivied instances of read and show
16:23:15 <sinelaw> what does "non-derivied" mean?
16:23:20 <permagreen> SubStack: For instance?
16:23:31 <SubStack> custom instances
16:23:45 <SubStack> which are broken
16:24:25 <SubStack> breaks my stuff which derives read and show
16:27:24 <SubStack> finally \o/
16:43:34 <dejones> If I have a data type, such as "data Foo = Foo Word64", is there a way I can convert the type of an instance of Foo into a Word type?
16:43:53 <aavogt> dejones: pattern match
16:44:29 <dejones> aavogt: Can you give me an example?
16:44:41 <dejones> aavogt: I'm not sure on the syntax for that.
16:45:56 <aavogt> you have to define   fooToWord (Foo x) = x
16:46:22 <dejones> aavogt: yea, I thought so, but wasn't sure of the syntax.
16:49:50 <gOcOOl> is there anything special I need to do to be able to define new data types in ghci/Prelude?
16:49:50 <gOcOOl> "Prelude> data Shape = Circle Float | Rectangle Float" keeps throwing a "parse error"
16:50:05 <rsnake> Hey guys... I'm having a prob with haddock; I have a file named 'Main.hs' which imports two modules I created. I try to do 'haddock -o doc --html Main.hs' and it says 'the following names could not be created: IO'
16:50:17 <rsnake> resolved*
16:50:37 <gOcOOl> ah maybe I need to say "let data Shape ..."
16:50:57 <gOcOOl> nope, no luck ;)
16:50:58 <permagreen> g0c00l: I was just about to say...
16:51:05 <dolio> You can't define data types in ghci.
16:51:23 <aavogt> you can also define it using record syntax:  data Foo = Foo { fooToWord :: Word64 }
16:51:44 <rsnake> g0c00l: Try writing it down on a .hs file and running 'ghci yourfile.hs'
16:52:14 <gOcOOl> ah ok, too bad. will give that a shot
16:56:14 <rsnake> Any help guys? it's as is haddock did not recognize my data types
16:58:58 <newsham> rsnake: iirc haddock is primarily for documenting libraries, not programs.
17:00:37 <sohum> @pl \x -> p (f x) (g x)
17:00:37 <lambdabot> liftM2 p f g
17:00:47 <sohum> shiny
17:01:31 <rsnake> What's an 'internal Happy error'=
17:01:32 <rsnake> ?
17:01:53 <ddarius> sohum: Or p <$> f <*> g
17:01:54 <tommd> Its an unhappyness about happy
17:02:46 <ddarius> @where frown
17:02:46 <lambdabot> I know nothing about frown.
17:02:48 <tommd> rsnake: happy is a parse generator for Haskell (iirc); i.e. a command line tool.  So you probably have a bad or old copy of happy.
17:03:16 <sohum> ddarius: less shiny ;)
17:03:49 <ddarius> sohum: I tend to prefer liftM style functions to the applicative style.
17:04:59 <sohum> ddarius: yea. now if they can only generalise it to liftM 2 instead of requiring a new name each time..
17:05:03 <sohum> on that note
17:05:32 <sohum> does anyone know how the printf function manages its multi-arg magic?
17:05:44 <ddarius> sohum: It's just inductive type classes.
17:05:53 <sohum> ..."just"?
17:05:57 <ddarius> Yep.
17:06:15 * sohum grumbles about smart people, goes to look this thing up
17:06:17 <ddarius> Inductive instances of a type class to be more precise.
17:06:29 <ddarius> sohum: Just look at the source for printf
17:07:02 <tomoj> it seems seriously doubtful to me that I will ever understand half the stuff that's talked about in here
17:07:13 <tomoj> I wonder why that is? doesn't seem that way for many other languages
17:07:38 <Warrigal> > isAlpha 'É'
17:07:39 <lambdabot>   True
17:08:09 <sohum> ddarius, oh, this thing? "(PrintfArg a, PrintfType r) => PrintfType (a -> r)"
17:08:14 <ddarius> Yep.
17:08:18 <sohum> aah
17:08:21 <Warrigal> I'm going tÉ use that lettÉr all thÉ time.
17:08:26 <sohum> hey that's pretty cool
17:08:59 <rsnake> economize vowels: use É
17:09:17 <rsnake> ÉcÉnÉmÉzÉ vÉwÉls
17:10:05 <MyCatVerbs> Obviously the best way to do that is to settle on a smaller set of vowels that still cover all the situations in which we need vowels right now.
17:10:33 <ddarius> vwls rnt ncssry fr ndrstndng
17:10:47 <MyCatVerbs> SÃ¸mÃ¦thÃ®ng Ã¦lÃ¸ng thÃ¦sÃ¦ lÃ®nÃ¦s.
17:11:30 <Warrigal> Well, you don't have to econÉmize *all* Éf them.
17:12:05 * ddarius economizes vowels to death.
17:12:06 <MyCatVerbs> Â¥ÉÃ Ã ÄÃ¸
17:12:24 <Warrigal> Eh, to each his own.
17:23:53 <Warrigal> ddarius: y knw, t wld b mpssbl t tlk bt  f w ddn't s vwls.
17:24:05 <Warrigal> Thn gn,  dn't knw wht  s, s n lss.
17:25:13 <heatsink> Warrigal, http://en.wikipedia.org/wiki/Abjad
17:29:40 <kyagrd> > isAlpha 'Î±'
17:29:41 <lambdabot>   True
17:29:47 <heatsink> heh
17:29:49 <kyagrd> that makes sense
17:30:10 <newsham> > isAlpha 'Î²'
17:30:12 <lambdabot>   True
17:30:25 <newsham> ahh.. right, this is the internet...
17:31:17 <kyagrd> > isLower 'Î±'
17:31:19 <lambdabot>   True
17:32:07 <kyagrd> @qc \c -> not (isAlpha c) || isLower c || isUpper c
17:32:07 <lambdabot> Not enough privileges
17:32:16 <kyagrd> @check \c -> not (isAlpha c) || isLower c || isUpper c
17:32:17 <lambdabot>   "Falsifiable, after 7 tests:\n'\\139883'\n"
17:32:20 <newsham> > 'Î²' `isLower` 'Î±'
17:32:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
17:32:21 <lambdabot>         against inferred...
17:32:50 <kyagrd> wow so there is a character that isAlpha but neither isLower nor isUpper!!!!
17:33:38 <heatsink> > isLower 'â'
17:33:39 <lambdabot>   True
17:33:45 <heatsink> huh.
17:33:53 <heatsink> Planck's constant is lowercase.
17:33:57 <kyagrd> > xor
17:33:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:33:58 <lambdabot>    `Data.Bits.Bits a'
17:33:58 <lambdabot>      ...
17:34:21 <kyagrd> @check \c -> not (isAlpha c) || (isLower c /= isUpper c)
17:34:22 <lambdabot>   "Falsifiable, after 14 tests:\n'\\32626'\n"
17:34:23 <heatsink> > isUpper 'â«'
17:34:25 <lambdabot>   True
17:34:38 <kyagrd> There are many of them duh
17:34:49 <dolio> > randM crapsM
17:34:50 <lambdabot>   Not in scope: `randM'Not in scope: `crapsM'
17:34:53 <dolio> , randM crapsM
17:34:55 <lunabot>  (â,â)
17:35:00 <heatsink> > isUpper 'â'
17:35:01 <lambdabot>   False
17:35:02 <Warrigal> Hmm.
17:35:16 <dolio> > (isUpper 'â', isLower 'â')
17:35:17 <lambdabot>   (False,False)
17:35:47 <heatsink> (isUpper 'â¤', isLower 'â¥')
17:35:51 <kyagrd> So, in haskell some alphabet(?)s are neither lowercase nor uppercase
17:35:53 <heatsink> > (isUpper 'â¤', isLower 'â¥')
17:35:55 <lambdabot>   (False,False)
17:35:55 <Warrigal> fileformat.info informs me that \139883 is not a valid Unicode character.
17:36:19 <Warrigal> It would make a hell of a lot of sense for some alphabets to be neither lowercase nor uppercase, seeing as how some alphabets don't make that distinction.
17:36:22 <kyagrd> Warrigal: but how is that an isAlpha? isAlpha is buggy?
17:36:37 <kyagrd> > isAlpha '\139883'
17:36:38 <Warrigal> Why would it not be an isAlpha?
17:36:38 <lambdabot>   True
17:36:53 <kyagrd> > isUpper '\139883'
17:36:55 <lambdabot>   False
17:36:58 <kyagrd> > isLower '\139883'
17:37:00 <lambdabot>   False
17:37:22 <Warrigal> > (isAlpha '×', isUpper '×', isLower '×')
17:37:23 <lambdabot>   (True,False,False)
17:37:25 <heatsink> It might be using unicode blocks as a shortcut, rather than testing exact characters.
17:37:42 <Warrigal> There, the Hebrew letter aleph: it's a letter, but neither uppercase nor lowercase.
17:37:56 <Warrigal> Now, let me see if I can find any others...
17:38:06 <kyagrd> The online report says http://www.haskell.org/onlinereport/char.html isAlpha c = isLower c || isUpper c
17:38:26 <kyagrd> GHC implementation of Char.isAlpha does not conform to the standard
17:38:27 <heatsink> There's a good explanation: If you look carefully, you can see that it's bigger than a lowercase letter and smaller than an uppercase letter.
17:38:40 <kyagrd> What is the GHC definition of isAlpha then?
17:38:51 <newsham> view source
17:39:33 <heatsink> > isAlpha 'ã'
17:39:35 <lambdabot>   True
17:39:35 <kyagrd> > isAlpph 'ã±'
17:39:37 <lambdabot>   Not in scope: `isAlpph'
17:39:40 <kyagrd> > isAlpha 'ã±'
17:39:41 <lambdabot>   True
17:39:44 <kyagrd> > isAlpha 'ê°'
17:39:46 <lambdabot>   True
17:39:49 <Warrigal> Huh, good question.
17:39:50 <kyagrd> > isAlpha 'ê°'
17:39:52 <lambdabot>   True
17:39:56 <kyagrd> grr
17:40:04 <heatsink> > (isUpper 'ã', isLower 'ã')
17:40:05 <lambdabot>   (False,False)
17:40:14 <Warrigal> Apparently that Japanese hiragana is a letter, even though it's not a character of an alphabet.
17:40:49 <sioraiocht> Warrigal: no, but it's a character of a syllabary
17:40:54 <Warrigal> > (isAlpha 'Ç', isUpper 'Ç', isLower 'Ç')
17:40:55 <lambdabot>   (True,True,False)
17:41:08 <Warrigal> > toUpper 'Ç'
17:41:09 <lambdabot>   '\455'
17:41:16 <Warrigal> > toUpper 'Ç' == 'Ç'
17:41:17 <lambdabot>   False
17:41:31 <kyagrd> > (isUpper 'ã±', isLower 'ã±')
17:41:31 <Warrigal> Apparently, it's an uppercase letter whose uppercase form is not it.
17:41:32 <newsham> ?let f c = (isAlpha c, isUpper c, isLower c)
17:41:32 <lambdabot>   (False,False)
17:41:33 <lambdabot>  Defined.
17:41:37 <Warrigal> > isTitle 'Ç'
17:41:38 <lambdabot>   Not in scope: `isTitle'
17:42:09 <heatsink> > fromEnum 'ã±'
17:42:11 <lambdabot>   12593
17:42:48 <newsham> > f 'ã'
17:42:49 <lambdabot>   Ambiguous occurrence `f'
17:42:49 <lambdabot>  It could refer to either `L.f', defined at <local...
17:42:55 <newsham> > L.f 'ã'
17:42:56 <lambdabot>   (True,False,False)
17:43:25 <kyagrd> I think current isAlpha just makes it confusing it should just contain latin1
17:43:38 <Warrigal> kyagrd: I'm guessing that the GHC definition of isAlpha is that Unicode calls it a letter.
17:43:54 <Warrigal> > generalCategory 'ã'
17:43:55 <lambdabot>   OtherLetter
17:44:08 <kyagrd> Warrigal: but it doesn't even implements that correctly
17:44:09 <Warrigal> Unicode says it's a letter.
17:44:13 <Warrigal> No?
17:44:22 <kyagrd> @check \c -> not (isAlpha c) || (isLower c /= isUpper c)
17:44:23 <Warrigal> Where does it not match Unicode?
17:44:23 <lambdabot>   "Falsifiable, after 16 tests:\n'\\155861'\n"
17:44:49 <kyagrd> > generalCategory '\155861'
17:44:50 <lambdabot>   OtherLetter
17:44:53 <newsham> > L.f '\155861'
17:44:55 <lambdabot>   (True,False,False)
17:44:55 <kyagrd> oh it is a letter wow
17:45:17 <kyagrd> > generalCategory '\139883'
17:45:18 <lambdabot>   OtherLetter
17:45:34 <kyagrd> > generalCategory 'ã±'
17:45:35 <lambdabot>   OtherLetter
17:45:41 <kyagrd> > generalCategory 'A'
17:45:42 <lambdabot>   UppercaseLetter
17:45:49 <kyagrd> @type OtherLetter
17:45:51 <lambdabot> GeneralCategory
17:46:06 <Warrigal> @check \x -> isAlpha c /= elem (generalCategory c) [UppercaseLetter,LowercaseLetter,TitlecaseLetter,ModifierLetter,OtherLetter]
17:46:07 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:46:19 <newsham> > length [c | c <- [minBound..maxBound], L.f c == (True,False,False)]
17:46:22 <lambdabot>   90255
17:46:30 <Warrigal> @check \c -> isAlpha c /= elem (generalCategory c) [UppercaseLetter,LowercaseLetter,TitlecaseLetter,ModifierLetter,OtherLetter]
17:46:31 <lambdabot>   "Falsifiable, after 0 tests:\n'\\777209'\n"
17:47:12 <Warrigal> > (isAlpha '\777209', generalCategory '\777209')
17:47:12 <lambdabot>   (False,NotAssigned)
17:47:45 <Warrigal> @check \c -> isAlpha c == elem (generalCategory c) [UppercaseLetter,LowercaseLetter,TitlecaseLetter,ModifierLetter,OtherLetter]
17:47:46 <lambdabot>   "OK, passed 500 tests."
17:48:02 <newsham> > let cs = [minBound..maxBound]; cf f = length (filter f cs) in (cf isAlpha, cf isUpper, cf isLower)
17:48:04 <lambdabot>   (93455,1452,1748)
17:49:38 <Warrigal> The number of uppercase letters doesn't match the number of lowercase letters?
17:50:20 <Warrigal> @check \c -> c == toLower (toUpper c) || c /= toLower c
17:50:21 <lambdabot>   "OK, passed 500 tests."
17:50:35 <Warrigal> @check \c -> c == toUpper (toLower c) || c /= toUpper c
17:50:36 <lambdabot>   "OK, passed 500 tests."
17:51:16 <Warrigal> @check \c -> isUpper c && c /= toUpper c
17:51:17 <lambdabot>   "Falsifiable, after 0 tests:\n'\\268440'\n"
17:51:43 <newsham> > let cs = [minBound..maxBound]; us = filter isUpper cs; ls = filter isLower cs in take 5 $ (map toUpper ls) \\ us
17:51:44 <lambdabot>   "\170\186\223I\312"
17:53:19 <Warrigal> I wonder why that's an uppercase letter.
17:54:03 <Warrigal> Hi, Keiya_.
17:59:46 <mmorrow> dolio: yay http://standish.stanford.edu/pdf/00000056.pdf
18:02:42 <BMeph> > isAlpha '_'
18:02:43 <lambdabot>   False
18:03:03 <BMeph> Okay, there goes that theory... :\
18:03:28 <kyagrd> @check \c -> isUpper c ==> c /= toUpper c
18:03:30 <lambdabot>   No instance for (Test.QuickCheck.Testable
18:03:30 <lambdabot>                     (Test.QuickCh...
18:03:40 <kyagrd> @type (==>)
18:03:41 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
18:04:38 <kyagrd> I wonder why ==> isn't working with lambdabot
18:05:21 <kyagrd> Warrigal: quickCheck (\c -> isUpper c ==> c == toUpper c) ... this doesn't find any counterexample
18:07:00 <c_wraith> kyagrd: did it run through th entire Char range?
18:07:18 <c_wraith> By default, quickcheck doesn't cover that many cases.
18:07:25 <kyagrd> But, there is a counterexample for this  quickCheck (\c -> isLower c ==> isUpper(toUpper c))  *** Failed! Falsifiable (after 15 tests): '\170' of course and that goes with you
18:09:30 <ray> @ungpl
18:09:30 <lambdabot> ()
18:12:56 <ivanm> ray: :o
18:19:41 <ddarius> mmorrow: You may also like the book "Vicious Circles" which you should be able to find online somewhere.
18:21:34 <kyagrd> I've just posted the Data.Char strangeness on the haskell libraries list
18:22:36 <ivanm> what strageness?
18:22:41 <ivanm> *strangeness
18:22:43 <kyagrd> "\170\186\223I\312"
18:22:58 <kyagrd> Ooops "\170\186\223\312"
18:23:03 <blackdog> is there an NFData instance for ByteStrings floating about anywhere? my google-fu is weak today
18:23:18 <ivanm> kyagrd: and what's so strange about that?
18:23:25 <ddarius> blackdog: For strict ByteStrings, seq is fine.
18:23:35 <blackdog> using lazy :/
18:23:53 <kyagrd> ivanm: quickCheck (\c -> isLower c ==> isUpper(toUpper c))  run this you will know :)
18:23:53 <ddarius> You could always do the ole seq length trick.
18:23:54 <blackdog> i'm playing around with the widefinder example in RWH
18:24:12 <blackdog> hm. that's a thoguht
18:24:13 <kyagrd> They are isLower but cannot turn into an uppercase
18:24:24 <ivanm> kyagrd: what letters are they?
18:24:30 <ivanm> s/letters/characters/ ?
18:24:40 <kyagrd> ÂªÂºÃÄ¸
18:24:42 <ivanm> maybe they don't have uppercase equivalents? e.g. what is toUppser '!'
18:24:42 <kyagrd> :(
18:24:53 * ivanm doesn't recognise the first 2
18:24:55 <ddarius> > filter (\c -> isLower c && not (isUpper (toUpper c))) ['\0'..]
18:24:56 <lambdabot>   "\170\186\223\312\329\397\411\426\427\442\446\496\545\564\565\566\567\568\5...
18:25:16 <ddarius> , filter (\c -> isLower c && not (isUpper (toUpper c))) ['\0'..]
18:25:17 <lunabot>  "\170\186\223\312\329\397\411\426\427\442\446\496\545\564\565\566\567\568...
18:25:34 <ddarius> , text $ take 10 $ filter (\c -> isLower c && not (isUpper (toUpper c))) ['\0'..]
18:25:34 <ivanm> kyagrd: @check doesn't like that ;-)
18:25:35 <lunabot>  Êºß¸IÍÊ«
18:25:41 <kyagrd> let cs = [minBound..maxBound]; us = filter isUpper cs; ls = filter isLower cs in take 5 $ (map toUpper ls) \\ us
18:25:50 <kyagrd> > let cs = [minBound..maxBound]; us = filter isUpper cs; ls = filter isLower cs in take 5 $ (map toUpper ls) \\ us
18:25:52 <lambdabot>   "\170\186\223I\312"
18:26:07 <kyagrd> Oh it only took 5 of them there are more yes
18:26:51 <kyagrd> , filter (\c -> isLower c && not (isUpper (toUpper c))) [minBound..maxBound]
18:26:52 <lunabot>  "\170\186\223\312\329\397\411\426\427\442\446\496\545\564\565\566\567\568...
18:27:00 <blackdog> ddarius: so, something like rnf a = seq (LB.length a) () ?
18:27:07 <blackdog> (where LB = lazy bytestring)
18:27:47 <sjanssen> blackdog: it would be better to use the toChunks function
18:28:03 <ddarius> That's not quite to normal form, per se, but probably does what you want.  Possibly rnf . toChunks would be more evaulated.
18:28:42 <sjanssen> foldr seq () . toChunks
18:29:00 <blackdog> sjanssen: so rnf a = seq (length $ LB.toChunks a) ()
18:29:13 <sjanssen> blackdog: that isn't RNF
18:29:28 <sjanssen> blackdog: and one ought to avoid length, it sucks
18:29:57 <sjanssen> (actually, I think that would reduce to normal form in the latest versions of ByteString, but it's still not optimal)
18:30:15 <blackdog> righto. but if i try rnf . toChunks, the compiler complains about having no instance for Internal.Bytestring.
18:31:21 <sjanssen> blackdog: you should probably define that, it's just flip seq ()
18:31:33 <kyagrd> Someone should upload an old Haskell 98 version of isAlpha isLower isUpper libraries on Hackage
18:32:09 <aavogt> kyagrd: shouldn't you get those if you import Char ?
18:32:20 <kyagrd> aavogt: Char just reimports Data.Char !!!
18:32:40 <kyagrd> > isLower '\170'
18:32:41 <lambdabot>   True
18:32:47 <sjanssen> kyagrd: what's wrong with the hierarchical libraries version?
18:33:40 <kyagrd> isLower c ==> isUpper(toUpper c)  does not hold for all c::Char
18:34:10 <blackdog> sjanssen: cheers, that did the trick. that's effectively saying any internal bytestring is already in normal form?
18:34:15 <kyagrd> There are lowercase letters that you cannot turn into uppercase letters ain't that strange? Why are they considred lowercase then?
18:35:11 <sjanssen> blackdog: *.Internal.ByteString is actually just the regular non-lazy ByteString
18:35:39 <sjanssen> blackdog: what it's saying is that RWHNF is the same as RNF for a strict ByteString
18:36:26 <sjanssen> kyagrd: I believe GHC calls to some Unicode library for this
18:36:27 <blackdog> ah, that's right. so if you've looked at any part of it at all, it's completely evaluated. I really need to start internalising the technical terms rather than relying on intuition :/
18:47:56 <travisbrady> What do you I need to do to be able to put a custom type in a UArr?
18:47:58 <kyagrd> sjanssen: Unicode itself is a mess
18:48:12 <kyagrd> on defining what lowercase and upppercase are
18:52:47 <kyagrd> So, I don't want to use predicates like isLower over all unicode (that doesn't make any sense to me at all, its contextless of charsets)
18:53:27 <kyagrd> Say for japanese isHiragana, isKatagana, isGagi makes sense isAlpha .. WTF :(
18:54:43 <hetman__> hi guys, how can I make GHC automagically cast a 'Foreign.Ptr.Ptr Foreign.C.CChar' to 'Foreign.String.CString'
18:54:47 <hetman__> Foreign.String has the internal definition: type CString = Ptr CChar, but no explicit casting functions
18:54:49 <hetman__> I need the Ptr CChar initially so I can check if it's null, then I need a CString for marshalling to Haskell
18:55:09 <ivanm> hetman__: haskell never automagically casts (unless you use the dynamic typign stuff)...
18:55:32 <ivanm> hetman__: and they are the same...
18:55:40 <ivanm> type definitions are just aliases
18:55:53 <hetman__> ivanm: does that mean Haskell will let me use them interchangeably?
18:56:03 <ivanm> "CString" is just an alias for "Ptr CChar"
18:56:28 <ivanm> if by interchangeably you mean (a :: CString) == (a :: Ptr CCHar), then yes!
18:58:16 <hetman__> ivanm: that's convenient... though it feels a little unsafe?
18:58:20 <hetman__> ivanm: or will haskell only allow that when they definitely ARE aliases
18:58:25 <ivanm> yes
18:58:35 <hetman__> ivanm: awsome, cheers
18:58:40 <ivanm> type declarations are only there for programmer convenience
18:58:47 <ivanm> at runtime they don't exist
18:58:51 <hetman__> ah
18:59:13 <ivanm> (newtype is a slightly stronger version which doesn't allow interchangeability, often used to hide the underlying implementation whilst having no runtime overhead)
19:00:07 <hetman__> hm, totally forgot about the distinction between type and newtype
19:00:12 <c_wraith> newtype is also good when you have a bunch of different things that are the same type internally, but you don't want to be interchangeable.
19:00:33 <c_wraith> A common case of that is when you're assigning Int ids to different types of things.
19:01:10 <c_wraith> I never want to use a FooId when I'm supposed to use a BarId, even though they're the same thing internally.
19:01:11 <hetman__> so then it's up to the implementor of the library to ensure casting is possible if it makes sense
19:01:44 <blackdog> aw, no threaded profiling in ghc? isn't that the case where you actually want it to go fast?
19:02:01 <c_wraith> yes, though conversion functions generally aren't thought of as "casting"
19:03:06 <hetman__> yeh makes sense
19:03:15 <hetman__> thanks!
19:04:37 <Makoryu> @pl \file f -> readFile file >>= print . f
19:04:59 <lambdabot> (. (print .)) . (>>=) . readFile
19:05:19 <c_wraith> :t interact
19:05:20 <lambdabot> (String -> String) -> IO ()
19:05:36 <c_wraith> Oh, I see.  There's no version of interact that takes two handles, is there?
19:05:50 <Makoryu> Not that I know of, no.
19:06:40 <ivanm> blackdog: I think 6.12 has thread profiling...
19:06:44 <Makoryu> Not that it'd make this any shorter, anyway
19:06:53 <c_wraith> when is 6.12 due, anyway?
19:06:55 <ivanm> at least, there's the threadscope app (which atm requires 6.10 to build as gtk2hs doesn't support 6.12...)
19:07:03 <ivanm> c_wraith: Any Time Now (c) ;-)
19:07:09 <Makoryu> c_wraith: Aren't there RCs out already?
19:07:12 <blackdog> ivanm: ah, righto. remember seeing that video and getting all excited:)
19:07:14 <ivanm> Makoryu: there's 1
19:16:11 <heatsink> Explicit type equality constraints lead to uninformative type errors :(
19:16:25 <Cale> heatsink: oh?
19:16:40 <c_wraith> well, GHC often says [Char]
19:16:49 <c_wraith> Which is almost never how I think about that type
19:17:24 <heatsink> I get this kind of error message: Couldn't match ... against ... in the definition of `topLevelFunction'
19:17:57 <heatsink> To narrow down the problem, I replace parts of the code with 'undefined' until the error message goes away
19:18:54 <heatsink> Type errors that assign blame to a specific expression are more useful
19:20:03 <heatsink> Actually, it's because of type families, not type equality constraints.
19:20:10 <heatsink> But I started using both at once.
19:24:30 <heatsink> Is there a paper about evaluating expressions by lazily pushing substitutions through them?  This seems like the kind of thing someone's invented before.
19:24:46 <heatsink> sorry, OT I guess
19:44:38 <iaefai> What does the ! mean in this: sum' 0  !n = return n
19:45:33 <c_wraith> iaefai:  It's an extension called BangPatterns
19:45:54 <c_wraith> iaefai:  It means "evaluate this argument strictly when you match it"
19:46:13 <iaefai> hmm, what is the effective result of that?
19:46:17 <c_wraith> iaefai:  It's generally used to prevent building up chains of thunks and blowing up the stack
19:46:38 <c_wraith> > foldl (+) 0 [1..10000]
19:46:38 <lambdabot>   50005000
19:46:42 <c_wraith> > foldl (+) 0 [1..100000]
19:46:43 <lambdabot>   5000050000
19:46:54 <c_wraith> > foldl (+) 0 [1..10000000]
19:46:58 <lambdabot>   mueval-core: Time limit exceeded
19:47:05 <c_wraith> > foldl' (+) 0 [1..10000000]
19:47:08 <lambdabot>   50000005000000
19:47:22 <iaefai> > foldl (+) 0 [1..10001]
19:47:24 <lambdabot>   50015001
19:47:44 <c_wraith> I'm used to seeing the stack blow up well before it times out.
19:48:03 <c_wraith> lambdabot is on a 64 bit machine, though.  Might have a bigger max stack size.
19:48:29 <camio> if n is _|_, then the result of evaluating sum' would be _|_. If the bang pattern wasn't there, the result of evalating sum would be a thunk starting with the return function.
19:48:56 <camio> What I said isn't entirely correct.
19:49:34 <camio> The result of evaluting sum could be some data type with _|_ in it. For the 2-tuple monad it could return (a,_|_).
19:49:54 <iaefai> _|_ being?
19:50:09 <camio> bottom
19:50:20 <c_wraith> generally, it represents an error has occurred.
19:50:38 <camio> I imagine you would like to know what bottom is. Hrm...that's a tough one to explain.
19:50:45 <c_wraith> error and undefined both result in _|_, for instance.
19:52:51 <camio> Every "thing" in haskell represents a mathematical value. The mathematical value for a function called with arguments, such that it would never terminate, is _|_.
19:53:06 <ivanm> bottom is roughly equivalent to a null value in object-oriented languages
19:54:15 <camio> That's why when a function has the signature Integer->Integer, it really is a function from IntegerOrBottom -> IntegerOrBottom.
19:57:14 <iaefai> My display server went all wierd on me
19:57:45 <aavogt> ivanm: but you can't say   if x == _|_ then halting_problem_solution ...
19:57:57 <ivanm> aavogt: I did say "roughly"
19:58:04 <ivanm> ;-)
19:58:21 <ivanm> (in that it's there for most types, trying to use it for calculations can cause problems, etc.)
19:58:22 <camio> iaefai: if you really want to know what _|_ means, you'd have to do a little study into denotational semantics. There's a freely availible book online (how I learned it) called denotational semantics.
19:58:40 <c_wraith> Basically, the most important part of bang patterns is that they force the thunk passed as that argument to the function.
19:59:03 <c_wraith> So you use them in cases where you'd otherwise build up a big chain of thunks for no particular reason.
19:59:19 <c_wraith> Usually in accumulator loops working with numeric types.
20:00:39 <iaefai> Doesn't sound like something I have to be worried about much
20:00:39 <ivanm> > cycle "thunk-a-"
20:00:41 <lambdabot>   "thunk-a-thunk-a-thunk-a-thunk-a-thunk-a-thunk-a-thunk-a-thunk-a-thunk-a-th...
20:00:50 <ivanm> iaefai: it is if you want performance usually ;-)
20:03:13 <iaefai> I do have this weird problem with my code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11072#a11072  on line 19, "Not in scope: data constructor `Seq'"   I do not understand why, because I use it elsewhere. I know my show instance probably isn't in a working state, but this does confuse me. I am trying to work up to a proper solution.
20:04:21 <c_wraith> Everywhere else in that file uses the type Seq
20:04:28 <c_wraith> Rather than the data constructor.
20:04:47 <iaefai> oh dear, I forget what the difference truly means
20:04:59 <c_wraith> data Bool = True | False
20:05:08 <c_wraith> Bool is the type.  True and False are the data constructors
20:05:16 <aavogt> > True < False
20:05:18 <lambdabot>   False
20:05:18 <c_wraith> they are different namespaces.
20:05:31 <c_wraith> fine, False | True.  :)
20:06:12 <iaefai> ok, I would think Seq row  would be a nice pattern match
20:06:59 <c_wraith> Well, that import really should cover both the type and the constructors.
20:07:33 <c_wraith> Oh.  But that type doesn't export a constructor
20:08:01 <c_wraith> Err, well.  The module doesn't export a constructor.
20:08:07 <c_wraith> You can't pattern-match without the constructor
20:09:17 <iaefai> I don't have Data.Sequence listed in file:///Library/Frameworks/GHC.framework/Versions/610/usr/share/doc/ghc/libraries/base/index.html
20:09:50 <c_wraith> It's not in base.
20:09:52 <c_wraith> it's in containers
20:10:02 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Sequence.html
20:11:10 <iaefai> ok, so how would i properly code what I want?
20:11:37 <iaefai> I was thinking about adding a Row type that might make some of this easier
20:11:38 <c_wraith> I'm not sure exactly what you're trying to do.
20:12:18 <iaefai> I have a datatype that is essentially the chess board. I want to show a grid when I call show
20:14:08 <iaefai> I think I might be able to do this without a constructor
20:14:15 <iaefai> I can convert it to a list easily enough
20:18:56 <c_wraith> Well, take a look at the Foldable class that it supports.
20:19:34 <c_wraith> You might be able to use one of those functions directly
20:19:44 <iaefai> yeah, I think I am getting an idea...
20:21:27 <iaefai> Would it be true that by not including a constructor that they can implement things that they otherwise couldn't so easily?
20:21:49 <c_wraith> Well.  It means your interface is more restricted.
20:22:04 <c_wraith> So the fact that the type is implemented as a tree is hidden from you
20:22:11 <c_wraith> and you interact with it as if it was a simple list
20:22:27 <c_wraith> Also, it's a structured tree.
20:22:48 <c_wraith> If you could construct them manually, you could make invalid structures.
20:22:58 <c_wraith> And then the algorithms wouldn't necessarily work.
20:23:23 <c_wraith> So, in a sense, you can use better algorithms that work on more restricted input types, by restricting the input types.
20:23:45 <iaefai> yeah, I was just thinking that about my chess board
20:24:25 <iaefai> Can I say what datatype it is without providing a constructor?
20:24:50 <c_wraith> Only at the module level.
20:25:17 <c_wraith> module ( Foo ) where data Foo = Foo | Bar
20:25:26 <c_wraith> That only exports the type, not the constructors.
20:25:34 <c_wraith> To export the constructors, it'd be:
20:25:39 <c_wraith> module ( Foo(..) ) where data Foo = Foo | Bar
20:25:52 <c_wraith> Err.  Pretend I put a module name in both of those.
20:26:13 <iaefai> Perhaps I should make a Data.Chess :p
20:26:52 <iaefai> It appears that Seq is really a newtype
20:27:25 <iaefai> newtype Seq a = Seq (FingerTree (Elem a))
20:32:57 <Cale> Well, it could be
20:33:03 <Cale> I think they specialised it
20:33:51 <Cale> FingerTree is awesome and it would be really nice if GHC was smart enough to do this specialisation itself.
20:34:59 <Gracenotes> let's put a special check for finger trees in ./compiler/ :P
20:35:51 <Gracenotes> hm. what features of Haskell tend to be the most interesting and wow-inducing (but not too esoteric) for people familiar with programming languages other than it?
20:36:09 <Gracenotes> in particular, mostly imperative language background, maybe some ML
20:36:18 <iaefai> monads?
20:36:22 <Gracenotes> I'm thinking list comprehensions would be a good example of a neat feature
20:36:23 <Makoryu> Gracenotes: Overloaded return values is always a fun one
20:36:36 <Gracenotes> iaefai: that's more headache-inducing than wow-inducing :)
20:36:50 <Gracenotes> Makoryu: hm. as in the Read typeclass?
20:37:03 <jmcarthur> i once explained the reader monad to an imperative programmer and he thought it was completely wild
20:37:09 <Makoryu> Gracenotes: Or any typeclass, really
20:37:15 <jmcarthur> (that is, he liked it)
20:37:33 <jmcarthur> the trick is i never used the word "monad"
20:37:35 <jmcarthur> ;)
20:37:45 <Gracenotes> jmcarthur: without explaining monads? did you describe it more as an implicit argument?
20:37:51 <jmcarthur> essentially
20:37:54 <jmcarthur> and a run function
20:38:09 <jmcarthur> and i showed what using it is like
20:38:18 <jmcarthur> when you define abstractions with it, at least
20:38:34 <jmcarthur> i used a Connection of some sort as a running example
20:38:47 <camio> Gracenotes: I'm more impressed by what has been done with the simple language haskell. How something so simple can be so expressive and produce such composible code. There are so many examples, DSELs and category theory libraries are my favorites.
20:39:12 <jmcarthur> and various operations that use it as the primitives that i simply explained were part of the abstraction, but you could easily define them yourself
20:39:33 <jmcarthur> and contrasted it with a global variable
20:39:52 <dmead> hey channel
20:39:58 <Gracenotes> except, one that is totally controlled, and only modifiable in subcalls
20:39:59 <jinjing> what's wrong with this code (simplest type class)? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11074#a11074
20:40:12 <jmcarthur> exactly the contrast i was referring to ;)
20:40:13 <ivanm> jinjing: what's the error?
20:40:21 <dmead> is it possible to pass patterns in variables to be used in case statements?
20:40:26 <jinjing> Illegal instance declaration for `Show a'
20:40:28 <dmead> anybody know?
20:40:35 <Gracenotes> I should probably also explain the value of Haskell and the functional style. so examples should be cool, but not too out there :)
20:40:56 <ivanm> jinjing: hmmm, not sure how valid it is to do that kind of automatica "all instances of Foo are instances of Bar" declaration
20:41:05 <ivanm> jinjing: it's an oft-wanted feature though
20:41:07 <Gracenotes> with some non-straw-man imperative code to compare.
20:41:34 <ivanm> jinjing: mainly because, what happens if you make Int an instance of Test? which instance does "show 2" use?
20:42:10 <Gracenotes> I think you can get around that by a shady GHC extension
20:42:24 <jinjing> ivanm: ahh, that makes sense
20:42:32 <ivanm> Gracenotes: yeah... overlapping instances?
20:42:52 <Gracenotes> undecidable too I think
20:43:03 <ivanm> probably
20:53:27 <iaefai> With something like this: instance (Show a) => Show (Tree a) where   why is 'a' on the left and 'Tree a' on the right?
20:54:50 <kyagrd> iaefai: Because (Tree a) depens on a
20:55:17 <iaefai> so could you have instance Show (Tree) where ...
20:55:18 <kyagrd> To show the tree you must know how to show its elements
20:56:05 <jfredett> there was a problem about automatic theorem proving with a big german name I can't spell that began with an 'Ent' and ended with a 'shdung' (or something similar) anyone know what that was off the top of their head? (Google is coming up empty)
20:56:21 <kyagrd> iaefai: If you are defining something that you don't have know about the substructure or element you can
20:56:39 <kyagrd> type :info [] in GHC you will see
20:57:07 <huntse> hi there
20:57:51 <huntse> I've got a type problem that I'm banging my head on and hoping someone here can enlighten me.
20:59:05 <huntse> given data Q u q = Q { amt :: q, units u }
20:59:18 <kyagrd> huntse: use hpaste or pastebim
20:59:43 <kyagrd> paste self contained code then someone may look and give you insight
20:59:47 <kyagrd> @where hpaste
20:59:48 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
21:00:00 <kyagrd> @where pastebin
21:00:01 <lambdabot> http://rafb.net/paste
21:00:07 <huntse> awesome, thanks.
21:00:33 <kyagrd> huntse: well you should give URL here so that people in #haskell can click on :)
21:00:38 <kyagrd> after pasting it
21:01:20 <jfredett> eureka, http://en.wikipedia.org/wiki/Entscheidungsproblem
21:01:42 <Gracenotes> iaefai: if you could see the source for show Tree (I think it might be automatically derived, you'd see something like show (Node val forest) = "Node {rootLabel = " ++ show val ++ ", subForest = " ++ show forest ++ "}"
21:02:14 <Gracenotes> note how it calls "show val". Too show a val of type a, you need (Show a) in the context somewhere
21:02:18 <huntse> sure thing.  Quick q before I do.  say I'm defining a "Flexible Instance".  Is there any way in the body of the instance of getting at the type parameter?
21:03:08 <Gracenotes> that's for Data.Tree, which has one value per node and any number of child elements
21:03:12 <huntse> think "instance Monad (Thing a)" and I'm writing return, and I want a.
21:05:33 <deech> Hi all, is there any way to get continous stats from a running Haskell program?
21:05:57 <kyagrd> huntse: define a function of type Thing a -> a and use that function when defining return
21:06:28 <huntse> kyagrd: Doh!  of course.  That fixes everything actually.
21:08:47 <kyagrd> And its a common convention that if Thing is a one data constructor type, newtype Thing a = Thing { unThing :: a }
21:09:01 <kyagrd> Then you automatically have a function unThing :: Thing a -> a
21:09:51 <huntse> kyagrd: oh I can see why that would be a good idea.
21:14:42 <SmurfOR>  /j #reddit
21:14:45 <SmurfOR> :|
21:14:49 <SmurfOR> oops
21:24:00 <iaefai> With http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11075#a11075  is there any way that I could 'fix' my Show instances so I don't need FlexibleInstances and UndecidableInstances? (unless that is ok...)
21:27:02 <kyagrd> Why can't you just say instance Show Piece where ... ?
21:27:12 <ivanm> kyagrd: agreed
21:27:24 <ivanm> iaefai: why are you doing "Show Piece => Show Piece" ?
21:27:34 <iaefai> kyagrd: because I didn't explicitly know I could?  I am mainly copying patterns I am seeing
21:27:35 <ivanm> that means, if Piece is an instance of Show, then Piece can be an instance of Show
21:27:51 <ivanm> iaefai: the left hand side of => is a constraint on the types involved
21:28:11 <iaefai> perfect, thank you
21:28:49 <iaefai> Is there a quick and clean way of implementing some Read, and what function would it be best to implement if I am just saying stuff like "B" and turning it into Bishop?
21:29:56 <ivanm> iaefai: realistically, Show and Read should only be used to generate the equivalent code for hacking/testing using ghci
21:30:08 <ivanm> and you should define your own show-like functions for printing values
21:30:19 <ivanm> and then use a parsing library if you really want to read them back in
21:30:39 <iaefai> I will be hacking with ghci for a while
21:30:58 <ivanm> iaefai: in that case, add a "deriving (Show)" to your data structure
21:31:16 <ivanm> and replace your current Show instance with a custom function for pretty-printing
21:32:02 <iaefai> I can have both deriving and instance?
21:32:16 <ivanm> iaefai: not for the same Class you can't
21:32:44 <ivanm> the only time you should really have a custom Show instance is if you're not wanting the internals of a data structure to be revealed, which is what Data.Map, etc.d o
21:32:48 <ivanm> *etc. do
21:33:59 <iaefai> I don't care about the internals, this is a product for my own consumption
21:34:12 <ivanm> right
21:34:44 <ivanm> what I'm saying is, derive the Show instance and then have showPiece :: Piece -> String, which currently does what you've done with your instance
21:34:55 <iaefai> ok
21:35:18 <iaefai> If I have an instance like I have now, but say for another class, do I have to implement all of the functions of that class?
21:35:21 <ivanm> it's a good habit to get into: I spent _ages_ replacing the show instances in a library I wrote with pretty-printing classes, which would have been much easier if I did them up front
21:35:32 <ivanm> iaefai: what do you mean?
21:35:48 <ivanm> the documentation for most classes will say if you don't have to define all of them (e.g. see the documentation for Ord)
21:36:11 <iaefai> Say if I had a NicePrint class that had niceprint and a niceread
21:36:15 <iaefai> i.e. making a new class
21:36:24 <ivanm> OK
21:36:32 <ivanm> in that case, you could use niceRead = undefined for now
21:36:44 <ivanm> which will typecheck, just crash if you ever try to use it
21:37:08 <iaefai> ok, that is a nice thing to know
21:38:15 <ivanm> dons: how do you package bytestring for arch (_do you_ have a standalone package, or rely on ghc's version?)
21:39:30 <dons> the latest version is in AUR, but the default ghc package comes with ghc's
21:39:38 <dons> only if you need the new version does it use the AUr package
21:39:57 <ivanm> should any package really be relying on a specific version/range of versions?
21:40:16 <ivanm> according to the PVP, they should all have the same API anyway (or does 0.9.1.* have some additions?)
21:40:59 <ivanm> dons: I'm asking because kolmodin and I discussed scrapping it in gentoo because of packaging problems (when some deps are linked to ghc's version and others to the stand-alone one), but it seems some packages rely on specific versions, ranges, etc. :s
21:41:00 <kyagrd> ivanm: I recently had the problem of gitit relying on higher versions of bytestring than my debian unstable packaging and two bytestring installation drove me to hell
21:41:15 <iaefai> I have seen some functions that will error out at runtime, I have a function I would like to do that for, what would be the way of doing that?
21:41:52 <ivanm> kyagrd: yeah, that's the thing... the only API changes that 0.9.1* should have is possibly some extra functions if versioning follows the PVP
21:42:00 <ivanm> and since dcoutts is one of the devs, you'd expect it to follow PVP
21:42:09 <ivanm> iaefai: what do you mean?
21:42:31 <iaefai> I noticed this in Sequence.hs: _ -> error "gunfold"
21:42:49 <ivanm> iaefai: right, you can do the same
21:42:55 <ivanm> undefined already does something like it:
21:42:57 <ivanm> @src undefined
21:42:57 <lambdabot> undefined =  error "Prelude.undefined"
21:43:27 <c_wraith> @src error
21:43:28 <lambdabot> error s = throw (ErrorCall s)
21:43:40 <c_wraith> huh.  I didn't actually expect that.
21:44:10 <iaefai> heh
21:44:19 <ivanm> dons: so you've never had a problem in arch where someone upgrades bytestring to 0.9.1.5, has some libs build on it and then have the diamond dependency problem with other deps relying on ghc's bytestring version?
21:44:26 <ivanm> c_wraith: what did you expect?
21:44:29 <ivanm> @hoogle ErrorCall
21:44:29 <lambdabot> Control.Exception data ErrorCall
21:44:29 <lambdabot> Control.Exception ErrorCall :: String -> ErrorCall
21:44:29 <lambdabot> Control.OldException ErrorCall :: String -> Exception
21:44:48 <iaefai> If I wanted to define a new type that as a (Piece, Colour) would that be done with 'newtype'?
21:44:57 <ivanm> you could use type
21:45:08 <sohum> @src throw
21:45:08 <lambdabot> throw exception = raise# exception
21:45:18 <sohum> @src raise#
21:45:18 <lambdabot> Source not found. Take a stress pill and think things over.
21:45:21 <c_wraith> Ah.  There's the magic one
21:45:27 <sohum> well, thar we go
21:45:39 <ivanm> iaefai: there are 3 reasons for using newtype over type: 1) hide implementation details from users, 2) avoid people using the wrong kind of value (extra safety), 3) to have new instances for classes
21:45:49 <mcnster> hi.  how do i write 'foreign import ccall unsafe "header.h &structure.elem" theElem :: ElemType' without getting a compile error?
21:46:05 <mauke> what compile error?
21:46:09 <dons> ivanm: you can obviously get into that state
21:46:10 <iaefai> Do I need to have a constructor for a newtype?
21:46:15 <dons> more common with quickcheck or haxml
21:46:16 <mauke> iaefai: yes
21:46:31 * ivanm makes a wild vague guess that it's unsafePerformIO hackery time for mcnster 
21:46:37 <mauke> mcnster: &structure.elem doesn't make sense
21:47:13 <ivanm> dons: that's precisely why we're considering scrapping bytestring as a stand-alone package: it took me forever to manually rebuild everything to use 0.9.1.5 (since ghc-pkg check doesn't reveal problems, so I had to find them all by hand)
21:48:00 <mcnster> mauke: i can't make a c decl of "struct foo structure;" and then refer to "&structure.elem" in haskell?
21:48:03 <ivanm> dons: but is there any reason why (remembering that in gentoo we're supporting a much greater range of ghc versions) users should/would want to use a new bytestring rather than the one that ships with ghc?
21:48:19 <mauke> mcnster: "&structure.elem" isn't haskell, it's linker
21:48:23 <mauke> and there is no such symbol
21:49:22 <mcnster> mauke:  ohho... then is it possible to address "elem" of "structure" using some other magic?
21:51:26 <mauke> structureElem = #{ptr struct foo, elem} theStruct
21:51:32 <mauke> assuming you're using hsc2hs
21:52:06 <mcnster> odd, this used to compile in ghc-6.8.2, but barfs errors on the .hc in 6.10.4...
21:56:15 <a2dk> (sorry if I'm doing this wrong)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11077#a11077
21:56:38 <ivanm> a2dk: what are you trying to do?
21:56:59 <a2dk> trying to write the equivalent of a record accessor function
21:57:09 <c_wraith> pattern-match
21:57:15 <ivanm> yup
21:57:19 <ski>   fromT2 (T2 as) = as
21:57:20 <a2dk> Small code snippet in the hpaste link
21:57:35 <ivanm> a2dk: but then you'd have to write your own setter as well
21:57:50 <mcnster> ok, thanks mauke.  :)  i'll try hsc2hs or reorder my struct members or something...
21:57:56 <a2dk> That's ok. Mostly trying to understand things. ty
22:02:07 <dons> ivanm: a bug was fixed that affected a corner case
22:02:42 <ivanm> dons: ahhh
22:02:51 <ivanm> dons: so you recommend we keep the bytestring package?
22:02:54 <ivanm> yay :s
22:04:15 <tommd> Bah, down with hsc2hs!  Up with c2hs.
22:05:55 * ivanm doesn't know what the difference is
22:06:05 <ivanm> all I know that apparently it's c2hs' fault that gtk2hs isn't cabalised
22:09:56 <arsenm> gtk2hs is also using a rather old fork of c2hs
22:11:14 <tommd> c2hs performs static analysis of the code while hsc2hs is a Haskell program that builds a c program which, once compiled and ran, will emit a Haskell source file.
22:11:41 <tommd> Cross compiling has a future with c2hs while hsc2hs is a dead end.
22:12:17 * tommd takes a walk
22:16:06 <kyagrd> @dice 6
22:16:07 <lambdabot> 6 => 6
22:16:24 <kyagrd> How does dice work, it always gives the number I gave :(
22:16:54 <mauke> @dice 1d6
22:16:54 <lambdabot> 1d6 => 2
22:17:09 <kyagrd> ah
22:18:01 <kyagrd> @dice 2d6
22:18:02 <lambdabot> 2d6 => 7
22:18:08 <kyagrd> hmm it only shows the sum
22:19:23 <jfredett> kyagrd: you could always write a patch...
22:29:26 <tommd> @dice 1d6
22:29:26 <lambdabot> 1d6 => 2
22:29:26 <tommd> @dice 1d6
22:29:26 <lambdabot> 1d6 => 6
22:40:01 <conal> i've forgotten: what's a simple & cheap way to convert from Float to Double?
22:42:11 <conal> i think there's a ghc-specific primitive or method, and i've forgotten what it is.
22:43:37 <zs> i have p::[char] = [[char]], and  'p [] = [[]]' ..., but ghc complains that it can't construct infinit type: char = [char], what does it mean
22:44:09 <Saizan> it's p :: [Char] -> [[Char]]
22:44:28 <Saizan> ?type \[] -> [[]]
22:44:30 <lambdabot> forall t a. [t] -> [[a]]
22:44:39 <Saizan> that branch does match that type
22:44:45 <Saizan> so it must be something else.
22:45:55 <Saizan> that error means that you've tried to use a Char where a [Char] was needed or vice-versa
22:46:04 <Saizan> or maybe a [Char] instead of a [[Char]]
22:48:24 <zs> so is [Char]->[[Char]] not the right type signature?
22:57:36 <zs> try to calculate permutation of a string with this perms(w) = [[x]:y | x<-w, y <
22:57:57 <zs> y <- perms(w \\ [x])]
22:59:29 <Cale> zs: Will each permutation really be a list of lists?
22:59:58 <Cale> > [1]:[[2,3,4],[5,6]]
22:59:59 <lambdabot>   [[1],[2,3,4],[5,6]]
23:01:00 <Cale> Also, it's a bit unfortunate to use \\ which uses Eq. You shouldn't need equality testing at all to construct the permutations of a list.
23:01:01 <zs> Cale, i was thinking [char]:[char]
23:01:35 <BMeph> zs: Then you weren't thinking... ;)
23:02:11 <BMeph> zs: However, I'll go back to lurking and let Cale enlighten...everyone. :)
23:03:51 <zs> ok, so Cale/BMehph, what's the right way to generate a permutation of a list then? let's say it's a list of chars, before we move to any type in the list
23:07:33 <Saizan> ?type (:)
23:07:34 <lambdabot> forall a. a -> [a] -> [a]
23:07:54 <Saizan> zs: the : constructor takes an element as first argument not a list
23:07:54 <quicksilver> zs: perms [] = [[]]
23:08:15 <quicksilver> zs: perms (x:xs) = map (x:) (perms xs)
23:08:42 <quicksilver> ++ map (++[x]) (perms xs)
23:09:00 <quicksilver> not particularly efficient but naive.
23:09:28 <quicksilver> contains duplicates too
23:09:30 * quicksilver ponders.
23:09:42 <quicksilver> too early, not enough coffee
23:10:05 <Saizan> > permutations [1,2,3]
23:10:06 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
23:10:09 <Saizan> there.
23:10:10 * ivanm passes quicksilver a bottle of pure caffeine
23:10:14 <Cale> zs: Start by writing a function  select :: [a] -> [(a,[a])]  which takes a list and produces a list of pairs consisting of each element of the list, together with a list of the other elements.
23:11:06 <Cale> > select [1,2,3]
23:11:08 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
23:11:10 <Cale> ^^ like that
23:11:41 <Cale> You should be able to do it with plain recursion and maybe a list comprehension or map
23:12:13 <ivanm> are you guys @let-ting in the background again?
23:12:27 <Cale> yes, that was a background @let so as not to give it away :)
23:15:34 <dancor> @src permutations
23:15:34 <lambdabot> Source not found. :(
23:15:49 <dancor> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#permutations
23:16:11 <dancor> if you can't do, peek
23:20:57 <zs> select [w] = [(x,y) | x <- w, y <- w \\ [x]]
23:21:09 <zs> Cale, this doesn't seem to work,
23:21:23 <zs> is this what you meant?
23:22:00 <twb> What was dons' joke (pastiche) explanation of monads?
23:24:51 <hackagebot> PastePipe 1.3 - CLI for pasting to hpaste.org (RoganCreswick)
23:25:04 <zs> in erlang, one can something like perms([]) -> [[]]; perms(L) -> [[H|T] || H <- L, T <- perms(L--[H])]. to do permutations
23:25:54 <dmwit> ?quote dons monad
23:25:54 <lambdabot> dons says: First you had to get the monads, then you get the power, then you get the women.
23:26:01 <dmwit> ?quote dons monad
23:26:01 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
23:26:05 <dmwit> ?quote dons monad
23:26:05 <lambdabot> dons says: First you had to get the monads, then you get the power, then you get the women.
23:26:08 <dmwit> ?quote dons monad
23:26:31 <zs> the code in data.list looks much more complex
23:26:31 <lambdabot> dons says: <dons> there once was a man with a monad <dons> oh, that's not going to end well
23:26:34 <dmwit> Very odd.  In privmsg, I got the same one three times in a row and figured there was only one.
23:27:14 <dmwit> ?quote dons xerox
23:27:15 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
23:27:19 <dmwit> twb: ?
23:27:38 <twb> Something about apples and oranges in a spacesuit in an ocean
23:28:08 <dmwit> > let perms [] = [[]]; perms l = [h:t | h <- l, t <- delete h l] in perms [1..4] -- zs
23:28:09 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
23:28:20 <dmwit> whoops, forgot to recurse
23:28:27 <dmwit> > let perms [] = [[]]; perms l = [h:t | h <- l, t <- perms (delete h l)] in perms [1..4] -- zs
23:28:28 <lambdabot>   [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1...
23:28:41 <dmwit> zs: But the Data.List version is more efficient, probably.
23:28:51 <dancor> can i build just one executable from a .cabal file with several?  maybe using flags?  or should i just make a separate cabal file
23:29:00 <dmwit> ?quote monad.*spacesuit
23:29:01 <lambdabot> No quotes match. Do you think like you type?
23:29:09 <dmwit> ?quote spacesuit.*monad
23:29:10 <lambdabot> No quotes match. Wrong!  You cheating scum!
23:29:23 <dancor> @quote spacesuit
23:29:24 <lambdabot> No quotes match. Are you on drugs?
23:29:31 <dancor> @quote spaces
23:29:32 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. <souwh> oooh, those can be saved and reused later!
23:29:38 <dancor> @quote spacesu
23:29:39 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
23:29:47 <dmwit> ?quote nuclear
23:29:48 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
23:30:53 <dmwit> dancor: You can have different "executables:" lines based on a flag, yes.
23:31:19 <zs> dmwit, that's intuitive, thanks
23:31:53 <hackagebot> quickcheck-poly 0.1.0.0 - Automating QuickCheck for polymorphic and overlaoded properties in a small world of types (KiYungAhn)
23:32:36 <dmwit> @vixen Entertain me!
23:32:37 <lambdabot> Crazy little wanker!
23:32:42 <dmwit> jeepers
23:35:56 <twb> ?quote spacesuit
23:35:56 <lambdabot> No quotes match.
23:36:02 <Saizan> you can have multiple executable stanzas, regardless of flags
23:36:04 <twb> ?quote orange
23:36:04 <lambdabot> No quotes match. stty: unknown mode: doofus
23:36:11 <twb> grmph
23:36:25 <zs> dmwit, i getting     Occurs check: cannot construct the infinite type: t = [t]
23:36:42 <dmwit> zs: Paste your code/try it on lambdabot?
23:36:55 <twb> lambdabot: sarahbot could beat you with one hand behind her back!
23:36:55 <dmwit> (Hard to fix an error like that without seeing the code. =)
23:37:51 <zs> dmwit, found the error, i was doing perms [l] on the recursion
23:38:07 <zs> thoug the error msg is strange
23:38:26 <dmwit> Hi, byorgey.
23:38:28 <dmwit> Can't sleep?
23:38:36 <byorgey> hi dmwit!
23:38:46 <byorgey> oh, I'm sure I could sleep if I tried.
23:38:54 <dmwit> =)
23:39:01 <byorgey> the problem is that my combinatorics homework can't do itself.
23:39:20 <dmwit> heh
23:42:22 <twb> byorgey: just make it the captchas for your blog
23:42:36 <byorgey> twb: ah, great idea!
23:45:05 <dancor> checking the solution is only easy for some combinatorics problems
23:45:36 <dancor> i guess you can require proofs
23:45:37 * c_wraith is off to a late-night diner with some pdfs and html pages to learn parsec
23:45:38 <dmwit> If several people submit the same solution, you could consider it "checked".
23:45:51 <dancor> or the solution is "" or "die"
23:45:55 <dancor> asdf
23:48:28 <kyagrd> @hackage quickcheck-poly
23:48:28 <lambdabot> http://hackage.haskell.org/package/quickcheck-poly
23:49:24 <kyagrd> This is an automation for quickcheck for polymophic/overloaded properties. It lets you run quickcheck for multiple possible types for such generic property withtout annotating them differently every time.
23:50:07 <kyagrd> There can be many improvements but this level is okay for me right now.  I hope I could do this without going through an interperter :(
23:54:56 <zs> can someone explain to me why is permutation written this way in data.list?
23:55:09 <zs> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#permutations
23:55:26 <zs> or why is it efficient i guess?
23:56:48 <pantsd_> Anyone know what the credientals are for cvs.haskell.org
23:56:57 <dmwit> zs: First thing, check the type of the "perms" that you wrote: it has an "Eq a" constraint.
23:56:59 <dancor> kyagrd: cool!
23:57:00 <dmwit> That's kind of silly.
23:59:21 <Saizan> is code.haskell.org very slow, or is it just me?
23:59:37 <zs> dmwit, ok, i understand that, what else?
23:59:47 <dmwit> I'm still reading it. =)
