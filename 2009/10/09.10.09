00:01:21 <mmorrow> i think that "type S" in there has to go (since the intention is that it connect up with the polymorphic `s' that you can't even see)
00:02:15 <mmorrow> maybe a signature can have some forall'ed tyvars "forall a b. signature Foo = sig ..."
00:03:37 <mmorrow> i mean, i think it's pretty clear what we're trying to do, we just need to find some coherent way of saying everything that needs to be said with the syntax
00:03:42 <Saizan> those are just arguments, usually
00:04:07 <Saizan> it's actually just a dependent function
00:04:14 <mmorrow> ah
00:04:29 <Saizan> signature Foo (a :: *) (b :: *) = sig ..
00:05:00 <mmorrow> pi (M:Monad). sig ...
00:05:17 <Saizan> yeah
00:05:28 <mmorrow> nice, for some reason i was trying to not do that, but that makes the most sense
00:06:02 <Saizan> well sometimes you want Monad to be in the resulting dictionary rather than an argument
00:06:23 <Saizan> s/dictionary/structure/
00:07:08 <dolio> In Agda-ish, State : * -> * -> *, and then Monad and MonadState are records parameterized by State s.
00:08:09 <Saizan> a structure has a traslucent dependent sum type, while functors have pi types
00:08:20 <mmorrow> functor Trie (k::*) (M:Map) = struct [|data Trie k a = Trie (Maybe a, M k (Trie a); ...|]
00:09:13 <mmorrow> you could even choose the Map implem based on the type of the key (since we see the type before it even gets translated back to haskell then to ghc)
00:09:22 <mmorrow> if Int then IntMap
00:09:28 <mmorrow> if Double then DoubleMap
00:09:43 <mmorrow> and have the key types unboxed in the constructors of the (M:Map)
00:09:50 <Saizan> yay for losing parametricity
00:09:58 <mmorrow> but the type's abstract
00:10:04 <mmorrow> ftw!
00:10:05 <mmorrow> :)
00:10:27 <mmorrow> and your code wouldn't even have to care, or notice
00:10:55 <Saizan> however if you take 'k' as argument to the functor Trie it doesn't seem to make sense as an argument of data Trie too
00:11:04 <mmorrow> ah, true
00:11:26 <mmorrow> dolio: oh nice
00:11:40 <mmorrow> dolio: what is agda's module system like?
00:11:46 <mmorrow> or whatever system
00:12:03 <Saizan> not that far from what we're describing actually
00:12:20 <mmorrow> nice, i'll have to read the quick overview
00:12:24 <dolio> Modules aren't first class, but records are, of course, and you can parameterize modules by any type.
00:12:49 <dolio> And all records automatically get a module associated with them, so you can open records, essentially.
00:13:02 <mmorrow> dolio: and these are the kind of records where each field's type depends on the val (or type) of all the prev, right?
00:13:47 <dolio> Actually, it's a module parameterized by the given record type, so you can either open it in general, and get haskell-like record selectors, or open it with a particular value of the record type, which is like opening the record-as-module.
00:13:58 <mmorrow> oh, so their kind of like lexical closures then, in the sense that they capture whatever they use from that module just like functions capture whatever freevars are in them?
00:14:02 <dolio> Yeah, they're dependent records.
00:14:15 <mmorrow> what do you bring into scope with open?
00:14:25 <Saizan> the accessors
00:14:29 <dolio> The names in a module.
00:14:57 <dolio> If you have "record Foo where { fields { a :: T } }" or something...
00:15:10 <Saizan> (you can actually define functions in a record type definition and they get inserted in the module)
00:15:46 <dolio> There is automatically a "module Foo (f : Foo) where { ... a refers to the a in f here ... }"
00:16:11 <dolio> So, without doing anything, if 'f : Foo' then you can say 'Foo.a f'.
00:16:13 <mmorrow> so say |module ... rec = {field0=4::Nat,two=stuff::b} ... fib = ... stuff = ...|, then in another module "open rec"
00:16:21 <bos> a writeup of the new text 0.5 release: http://bit.ly/1u4UOT
00:16:21 <dolio> If you 'open Foo' you can say 'a f'.
00:16:26 * mmorrow reads what you just said
00:16:32 <dolio> And if you say 'open Foo f' you can say 'a'.
00:16:43 <mmorrow> oh, ok
00:16:50 <Saizan> mmorrow: you've to define a record type separately from the record values
00:16:59 <mmorrow> ah
00:18:20 <Saizan> what would make them really nice is structural subtyping, imo
00:18:24 <dolio> Wow, a 4-way hyphenated algorithm name.
00:18:39 <mmorrow> leet!
00:19:51 <ivanm> bos: really, why do you bother using a URL shortener?
00:19:59 <mmorrow> Saizan: yeah, that would. you mean like  {one::(Int,a)} < {one::(a,b),two::Double} ?
00:20:05 <ivanm> (and why don't you ever seem to announce anything on the mailing lists?)
00:20:06 <mmorrow> (or flip (<))
00:20:52 <dolio> Sometimes referred to as (>).
00:21:04 <mmorrow> bos: those density plots rock
00:21:14 <ivanm> bos: so searching over strings is now faster than over bytestrings? :o
00:21:37 <Saizan> mmorrow: yes, flipped
00:21:41 <mmorrow> dolio: nu uh
00:21:41 <bos> ivanm: yep
00:21:50 <ivanm> bos: very nice!
00:21:55 <bos> mmorrow: thanks!
00:22:15 * ivanm doesn't think he'll ever have a use for Text, but it still looks very nice
00:22:16 <Saizan> bos: wouldn't make more sense to have graph that properly overlap when you're comparing densities?
00:22:24 <Saizan> *graphs
00:22:25 <bos> ivanm: there's a boyer-moore bytestring search package that i haven't tested for performance.
00:22:38 <ivanm> bos: *nod*
00:22:42 <bos> Saizan: yeah, but i haven't written the code to do that yet
00:22:50 <bos> only so many hours inna day
00:22:59 <Saizan> heh :)
00:23:41 <ivanm> quick everyone! donate your spare hours to bos!
00:23:42 <ivanm> :p
00:24:15 <ivanm> bos: but how expensive is pack/unpack?
00:24:45 <bos> ivanm: you shouldn't be using pack or unpack in normal code
00:24:56 <ivanm> so how do you convert to/from String?
00:25:04 <ivanm> or are you meant to read it in as Text?
00:25:04 <bos> use bytestring I/O, and avoid String completely
00:25:08 <ivanm> ahah
00:25:17 <ivanm> there's a bytestring -> Text conversion?
00:25:23 <bos> yep
00:25:39 <ivanm> ahhh, in Encoding
00:25:40 <Axman6> where's Text from? (got here late)
00:25:53 <ivanm> Axman6: bos' new (well, updated) package
00:25:59 <bos> night, all
00:26:01 <ivanm> that begat criterion that begat statistics
00:26:01 <Axman6> which package?
00:26:03 <ivanm> cya bos
00:26:06 <ivanm> Axman6: Text
00:26:06 <ivanm> ;-)
00:26:07 <Axman6> o/ bos
00:26:14 <ivanm> @hackage text
00:26:15 <lambdabot> http://hackage.haskell.org/package/text
00:26:16 <Axman6> heh, i see :P
00:27:01 <ivanm> Axman6: http://www.serpentine.com/blog/2009/10/09/announcing-a-major-revision-of-the-haskell-text-library/
00:27:04 <ivanm> pretty graphs...
00:27:13 <ivanm> that you mac fan[atic]s can't have! :p
00:27:33 <sohum> @src lex
00:27:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:27:38 <sohum> :t lex
00:27:39 <lambdabot> String -> [(String, String)]
00:27:45 <sohum> lex "abscd"
00:27:49 <sohum> > lex "abscd"
00:27:50 <lambdabot>   [("abscd","")]
00:28:27 <dolio> > lex "{- abcde -} let i = n in i"
00:28:28 <lambdabot>   [("{","- abcde -} let i = n in i")]
00:28:36 <Axman6> > lex "'lo sohum"
00:28:37 <lambdabot>   []
00:28:43 <Axman6> phail
00:29:06 <dolio> > lex "'c':l"
00:29:07 <lambdabot>   [("'c'",":l")]
00:29:12 <sohum> so what, it's the haskell lexer?
00:29:27 <Saizan> basically.
00:29:39 <sohum> fair enough
00:30:05 <Gracenotes> alex, as he/she/they/ze likes to be called. :/
00:30:18 <Saizan> it's used in Read instances, i think
00:31:01 <Saizan> Gracenotes: no, alex is a lexer generator written in haskell, "lex" is a function implementing a lexer _for_ haskell
00:31:05 <Gracenotes> mm, /that/ lexer is for Show/Read particularly
00:31:20 <Gracenotes> it's described in the Haskell 98 report
00:31:40 <Axman6> > lex "123.456"
00:31:41 <lambdabot>   [("123.456","")]
00:31:42 <Gracenotes> yeah, my brain is recovering from a wonderfully cathartic jog. -.-
00:32:03 <Gracenotes> woot, #1 google result for alex
00:32:50 <ivanm> hmmmm.... google hasn't updated it's hackage index for a while...
00:33:38 <int-e> @hoogle String -> Maybe a -> m a
00:33:38 <lambdabot> Debug.Trace trace :: String -> a -> a
00:33:39 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
00:33:39 <lambdabot> Text.Html gui :: String -> Html -> Html
00:33:45 <dolio> > read "{- abcde -} 12345" :: Int
00:33:47 <lambdabot>   * Exception: Prelude.read: no parse
00:34:58 <ivanm> > lex "{- abcde -} 12345"
00:35:00 <lambdabot>   [("{","- abcde -} 12345")]
00:35:05 <ivanm> heh
00:35:50 <dolio> Skimps on the comment lexing.
00:35:57 <ivanm> yeah
00:36:07 <ivanm> I'm guessing the comments are meant to be stripped out before lexing
00:36:15 <int-e> > read ('"':repeat ' ') :: Int
00:36:21 <lambdabot>   mueval: ExitFailure 1
00:40:40 <dolio> > read "(((12345)))" :: Int
00:40:41 <lambdabot>   12345
00:46:22 <benmachine> :t \a -> maybe (fail a) return
00:46:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> Maybe a -> m a
01:14:36 <sohum> @instances Bits
01:14:37 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
01:14:53 <sohum> @instances-importing Data.Word Bits
01:14:53 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
01:18:24 <Axman6> FARK >_<
01:18:41 <Axman6> darcs failed:  Codec.Compression.Zlib: incompatible zlib version <-- fuck you darcs >_<
01:19:01 <vegai> runtime?
01:19:19 <Axman6> yeah
01:19:30 <vegai> auch :-/
01:22:10 <pabloh> is there some haskell function equivalent to hugs's :t command?
01:22:47 <quicksilver> not really
01:22:48 * Axman6 notes that ghci has the same command
01:23:04 <quicksilver> although there is 'typeOf' which only works on Typeable things.
01:23:11 <quicksilver> but basically, types are not values
01:23:18 <quicksilver> and don't "exist" at runtime.
01:23:42 <pabloh> so it simply can't be implemented?
01:24:00 <Axman6> i'm sure it could be, but...
01:25:04 <Axman6> damn it.... seems i'm the only person ever to have run into this damn darcs problem
01:25:08 <Axman6> god damn it
01:25:43 <Axman6> searching google for "darcs failed:  Codec.Compression.Zlib: incompatible zlib version" turns up one link: http://tunes.org/~nef//logs/haskell/09.08.10 which is a log of me having this damn problem
01:26:14 <SmurfOR> lol
01:30:19 <Raevel> how do i convert from lazy bytestring and back, and vice versa?
01:30:44 <quicksilver> from *and* back *and* vice versa?
01:30:49 <Raevel> ehm
01:30:52 <Raevel> ehm ehm
01:30:53 <quicksilver> that's a whole lot of conversion directions ;)
01:31:01 <quicksilver> convert to what?
01:32:05 <quicksilver> if you mean String, then it's pack/unpack
01:32:20 <Raevel> i managed to do write my question very poorly
01:32:36 <quicksilver> if you mean strict BS, then fromChunks/toChunks
01:32:39 <Raevel> from strict to lazy bytestring
01:32:48 <quicksilver> if you mean Gold, then with a philosopher's stone
01:33:20 <Raevel> OK
01:33:34 <quicksilver> @hoogle fromChunks
01:33:35 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
01:33:35 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
01:33:36 <Raevel> ah right, and what confused me about chunks is why it returns a list
01:33:42 <Raevel> or takes a list
01:33:43 <Axman6> also knows as a socerer's stone in the US
01:34:01 <Axman6> fucking darcs >_<
01:34:07 <quicksilver> because a lazy bytestring is much like a list of strict bytestrings
01:34:18 <quicksilver> you can just put one strict bytestring in the list if that's all you have.
01:34:27 <quicksilver> (in the other direction you can call 'concat')
01:34:43 <Raevel> great
01:35:22 <Raevel> i'm trying to unbreak the hackage torrent package, successfully
01:36:00 <Raevel> and i really can't form a sentence today
01:36:07 <Axman6> ok, sorry darcs. fucking Zlib
01:36:29 <Axman6> some nerve giving me this error: *** Exception: user error (Codec.Compression.Zlib: incompatible zlib version)
01:36:35 <Axman6> user error? get stuffed
01:46:48 <Baughn> Axman6: Some 32/64-bit confusion?
01:47:03 <Axman6> yeah. seems i need to add flags to the hsc2hs script
01:48:54 <ivanm> Axman6: what did you want darcs to get stuffed with? :p
01:52:12 <quicksilver> a bit of sweet chestnut, some garlic, some carefully chosen herbs, etc
01:52:37 <Axman6> anyone know anything about this error? "darcs: memory allocation failed (requested 2901409792 bytes)"
01:52:44 <Baughn> Rocket fuel, perhaps?
01:52:46 <Axman6> > 2^32
01:52:47 <lambdabot>   4294967296
01:52:54 <Axman6> > logBase 2 2901409792
01:52:56 <lambdabot>   31.434106928609957
01:53:01 <Baughn> ..well, that's a lot
01:53:50 <Axman6> bloody hell. i'm going back to the binaries yet again
01:54:00 <vegai> a very recent darcs, perhaps?
01:55:28 <Axman6> finally >_<
01:56:14 <ivanm> <_>
02:08:57 <yaxu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10560 # any tips on fixing this linker error?
02:09:38 <Axman6> reinstall time?
02:10:40 <yaxu> reinstalling is when my problems started
02:10:43 <yaxu> I'll try again tho, ta
02:22:02 <jethr0> heyho
02:25:01 <mmorrow> Axman6: that looks like you may be getting killed by some rlimit
02:25:06 <mmorrow> , fix id
02:25:12 <lunabot>  luna: out of memory (requested 2097152 bytes)
02:25:22 <mmorrow> "darcs: memory allocation failed (requested 2901409792 bytes)"
02:25:28 <Axman6> mmorrow: well, it's not like it was a big repo or anything
02:25:32 <mmorrow> maybe that's just ghc's error msg actually
02:25:39 <mmorrow> when it can't alloc
02:26:01 <mmorrow> yeah, since the prog name is prefix, probably ghc
02:26:16 <mmorrow> n/m :)
02:27:16 <jethr0> does anyone have experience with using the same binary on different windows machines?
02:27:17 <mmorrow> Axman6: do ghc -e 'let xs = [0..] in length xs `seq` sum xs' and see if you get killed at the same memlimit maybe?
02:27:49 <mmorrow> Axman6: i can't think of anything other that rlimits than would prevent you from allocating mem
02:27:56 <mmorrow> (or cause that error msg)
02:28:00 <jethr0> i've compiled an opengl program and it seems the problem is that different graphics card vendors ship different opengl.dll's which won't work with the same binary...
02:28:09 <jethr0> not sure how I can investigate this further, any ideas?
02:28:35 <Axman6> mmorrow: this follows a string of darcs problems. i just downloaded one of the binaries, and it works ok
02:28:43 <mmorrow> ah
02:29:29 <jethr0> ...
02:33:34 <FunctorSalad>     Can't make a derived instance of `Typeable1 (D Maybe)'
02:33:34 <FunctorSalad>       (`D' has arguments of kind other than `*')
02:33:56 <FunctorSalad> can it just not derive them or can't I write a legal instance of Typeable either?
02:34:23 <FunctorSalad> (for higher-order kinds)
02:35:14 <FunctorSalad> (I'd better be careful because afaik Typeable guards unsafe coercion in cast)
02:35:18 <FunctorSalad> @src cast
02:35:18 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:37:30 <yaxu> Axman6: wiping everything and reinstalling did the trick
02:37:38 <Axman6> good good
02:41:09 <Axman6> so... is anyone else going to be really fucking pissed if the moon implodes when
02:41:13 <Axman6> NASA bomb it?
02:41:52 <yaxu> the surfers will
02:41:58 <Axman6> yah
02:42:44 <quicksilver> FunctorSalad: I don't think there are typeable classes for the whole hierarchy of kinds
02:42:52 <quicksilver> FunctorSalad: only for the 'flat' kinds * -> * -> * etc
02:42:57 <quicksilver> FunctorSalad: I may have misunderstood though
02:43:35 <FunctorSalad> quicksilver: yep. I have (D :: (* -> *) -> * -> *). I'm trying this now:
02:43:46 <FunctorSalad> instance Typeable1 m => Typeable1 (D m) where ...
02:44:02 <quicksilver> that might work :)
02:44:36 <FunctorSalad> typeOf seems to work, let's try cast...
02:44:38 <ivanm> is plugins hs-plugins reloaded?
02:49:59 <pozic> I have two monads AT and BT, AT needs to have access to random numbers. BT already has this facility, so I could just lift all random operations. This complicates type-signatures a bit. Another thing I can do is add a real RandT layer to AT and initialize a generator based on the random number generator in BT. If the random number generator would be a true random number generator, this would work, but I am not sure whether in practice the distributions a
02:52:13 <jethr0> pozic: have you thought about passing in an infinite stream of random numbers to AT and manage its state in AT?
02:52:37 <jethr0> or is that not applicable to your monads?
02:54:20 <pozic> jethr0: yes, I considered that, but I don't think it will solve anything.
02:55:38 <jethr0> and how about using a newtype derived new monad that combines AT and BT. that might solve your "complicates type-signatures" issues...
02:55:39 <pozic> I just wrote a MonadRandom instance which lifts everything transparantly.
02:55:49 <jethr0> ah, k
02:55:56 <pozic> So, for AT.
02:57:02 <pozic> I first defined this hugely general declaration with MonadTrans t, Monad (t m), well you probably also have written one of these before, but it resulted in instances being called that I didn't expect.
02:59:21 <jethr0> what are you using as pseudo random generator. i was shocked to find out just how slow the System.Random one is compared to Mersenne twister, etc. in hackage
03:01:17 <pozic> jethr0: I still use System.Random.
03:01:36 <pozic> jethr0: I will switch when I find it is a bottleneck.
03:02:00 <pozic> If Mersenne twister dominates System.Random surely it will be replaced some day.
03:03:08 <jethr0> can't find the url right now of the benchmark, but the alternatives where many times faster than system.random, if memory serves me.
03:07:22 <ilid> pozic: i vaguely recall that not all RNGs are compatible with System.Random's interface (in particular, the need to support a "split")
03:08:04 <jethr0> http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
03:08:41 <ivanm> ilid: most aren't
03:08:48 <ivanm> the mersenne ones for example don't
03:09:08 <ivanm> they have an instance for Random, but they're bog slow when you use them via the class
03:09:08 <jethr0> according to those benchmarks, when you use more than just a few random numbers, System.Random is almost bound to become your bottleneck
03:09:47 <quicksilver> jethr0: that's a false deduction.
03:10:13 <ivanm> quicksilver: because you can't prove it?
03:10:17 <quicksilver> those benchmarks indicate that if you need on the order of 1 million random numbers per second, System.Random is likely to become your bottleneck.
03:10:19 <ivanm> and it could be IO bound, etc. as well?
03:10:25 <ivanm> ahhh
03:10:39 <jethr0> quicksilver: a simplifying one. if you use enough random numbers a factor of 0.7 vs >>100 is going to be a simple optimization
03:10:42 <quicksilver> if you need, perhaps, 1000 random numbers per second (which still strikes me as quite a lot, to be honest) System.Random will not be the bottleneck.
03:10:57 <quicksilver> jethr0: it's going to be an absolutely irrelevant optimisation if it's not the bottleneck.
03:11:08 <jethr0> depending obviously on how hard the rest of your code works
03:11:15 <Baughn> It would still be nice to have a decent default PRNG in ghc
03:11:21 <Baughn> ..and a cryptographic one, too
03:11:22 <quicksilver> if you take a part of your code which takes 0.1% of your running time, and improve it by a factor of 100
03:11:28 <jethr0> quicksilver: are you sure? i've used system.random with less than 1000/s and as far as i recall it was SLOOOOW
03:11:39 <jethr0> quicksilver: i completely agree
03:11:45 <quicksilver> then you've improved your overall running time by 0.1% :)
03:11:53 <quicksilver> well I'm just using bos's numbers
03:12:04 <Jafet> "Even the initializer is optimized!"
03:12:27 <quicksilver> he seems to say System.Random can generate 1.6M doubles per second, on his hardware
03:12:51 <ivanm> mersenne is still faster than the statistics PRNG though, isn't it?
03:13:09 <Jafet> What does System.Random do?
03:13:23 <quicksilver> simple linear congruence I think
03:13:31 <jethr0> Jafet: it provides an interface to a pseudo random number generator
03:13:43 <ivanm> quicksilver: nope
03:13:46 <Jafet> Well, which a?
03:13:59 <quicksilver> apparently it uses "Portable Combined Generator of L'Ecuyer"
03:13:59 <ivanm> it's a bunch of linear generators combined together to make it more "random"
03:14:26 * ivanm had to summarise that paper for a computational physics course, when we had to discuss the default PRNG of our languages
03:14:29 <Baughn> Yesh, it's linear congruence
03:14:37 <jethr0> quicksilver: i agree. the program where i used random numbers was basically a monte carlo simulation, therefore relying almost completely on the speed of supplied random numbers
03:14:53 <ivanm> Baughn: well, it's not _normal_ linear congruence (ax+b mod c)
03:15:00 <Baughn> ivanm: Still.
03:15:15 <ivanm> it's multiple linear congruences, so it's not _that_ bad ;-)
03:15:18 <Baughn> Given that the mersenne twister seems to have basically no disadvantages, why not use it? Just split?
03:15:51 <ivanm> Baughn: IO for the IO one
03:15:56 <ivanm> pure64 is slower however
03:16:08 <Jafet> MT is a tad slow
03:16:17 <Baughn> Not /this/ slow
03:16:33 <Jafet> jethr0, I would not ever use linear generators, regardless of apparent complexity, in a monte carlo simulation
03:16:37 <Jafet> Ever
03:16:46 <ivanm> Baughn: IIRC, there's a slight dodginess in how it's used/implemented because of how you pass around a big block
03:16:57 <ivanm> also, yes, lack of a split can be a pain
03:17:18 <ivanm> "It is also extremely fast, between 2 and 3 times faster than the Mersenne Twister. " :o
03:17:25 <ivanm> this is from the statistics documentation
03:17:30 <Baughn> Well.. couldn't you implement split as "use MT to create new MT state"?
03:17:36 <ivanm> but it's not cryptographically secure, whereas MT is IIRC
03:17:44 <ivanm> Baughn: yeah, but it's hacky and slow IIRC
03:17:49 <Jafet> MT is linear.
03:17:57 <Baughn> I've never heard MT described as cryptographically secure before
03:17:57 <Jafet> (Which is another problem)
03:18:04 <quicksilver> Baughn: that doesn't give you a state which is independent, or not provably so.
03:18:14 <ivanm> Baughn: maybe not
03:18:16 <quicksilver> Baughn: you can see correlations between new state and old.
03:18:20 <Baughn> quicksilver: Does it need to be?
03:18:22 <quicksilver> yes
03:18:25 <jethr0> i'm (as so often) in over my head. shift register pseudo random number generators have very good crypto distribution and are really fast. what about one of those in haskell?
03:18:32 <quicksilver> split is supposed to produce two independent states ;)
03:18:41 <ivanm> hmmm.... the statistics package doesn't seem to have a function to get a system-based seed ala newStdGen...
03:18:52 <Jafet> Shift registers aren't fast in software
03:18:53 <Baughn> quicksilver: I mean, will this actually affect the produced random numbers in ways that can be detected by normal statistical tests?
03:19:03 <Jafet> Well, generally speaking
03:19:07 <Baughn> I don't count cryptographic stuff here. If we wanted /that/, we'd be using BBS
03:19:22 <sinelaw> is this valid syntax?
03:19:32 <sinelaw> f x@(a,b) = blabla
03:19:36 <Baughn> Sure
03:19:39 <jethr0> Jafet: so what principle is system.random based on if neither linear congruence nor shift registers?
03:19:41 <sinelaw> thanks
03:19:50 <pozic> Baughn: BBS?
03:19:59 <Jafet> jethr0, no idea, I asked a minute ago and no one seems to agree on each other's answers
03:20:04 <Baughn> pozic: Blum Blum Shub, a PRNG derived from poking around R'Lyeh.
03:20:04 <jethr0> hehe
03:20:21 <Jafet> I imagine from the name it would have something to do with the system's randomness pool, but apparently not so
03:20:23 <ivanm> Baughn: heh
03:20:23 <porcopino> isNonWhite = \c -> notElem c [' ','\t','\n','\r','\f']
03:20:25 <jethr0> Baughn: was that an actual answer? ;)
03:20:25 <pozic> Baughn: I heard of that one, I just didn't recognize the acronym.
03:20:30 <porcopino> am I right?
03:20:34 <ivanm> @remember Baughn Blum Blum Shub, a PRNG derived from poking around R'Lyeh.
03:20:35 <lambdabot> Good to know.
03:20:36 <Baughn> jethr0: Well, the first half was. :P
03:20:47 <ivanm> porcopino: or not . isWhiteSpace ;-)
03:20:51 <ivanm> @hoogle whitespace
03:20:52 <lambdabot> Text.Parsec.Token whiteSpace :: GenTokenParser s u m -> ParsecT s u m ()
03:20:52 <lambdabot> Text.ParserCombinators.Parsec.Token whiteSpace :: GenTokenParser s u m -> ParsecT s u m ()
03:21:05 <ivanm> @hoogle isSpace
03:21:06 <lambdabot> Data.Char isSpace :: Char -> Bool
03:21:06 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
03:21:06 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
03:21:07 <Baughn> jethr0: BBS is the simplest PRNG I know, and /obviously/ correct
03:21:10 <jethr0> what the heck is '\f'
03:21:15 <ivanm> porcopino: I mean not . isSpace
03:21:16 <porcopino> form feed
03:21:16 <ivanm> ;-)
03:21:16 <quicksilver> jethr0: System.Random is basically linear congruence
03:21:16 <Baughn> jethr0: Also, just as unbreakable as RSA. :3
03:21:19 <ivanm> @src isSpace
03:21:20 <lambdabot> Source not found. Where did you learn to type?
03:21:30 <quicksilver> jethr0: it is a slight modification of two combined linear congruences
03:21:34 <Athas> Is it possible to link my single-file Haskell program with the Cabal-installed X11 library without using Cabal to do it?  (And if so, how?)
03:21:47 <ivanm> Athas: using ghc --make
03:21:49 <porcopino> ivanm: it's a custom nonwhitespace thing with lambda expression :P
03:21:53 <jethr0> Jafet: so, if you wouldn't use a linear congruence PRNG for monte carlo (which i can kinda understand) what WOULD you use?
03:21:56 <ivanm> porcopino: whatever then
03:21:57 <ivanm> ;-)
03:22:00 <Athas> ivanm: ooh, thanks.
03:22:33 <Baughn> jethr0: A HRNG would be nice
03:22:58 <ivanm> Baughn: H == ?
03:23:00 <Baughn> ..honestly, I don't get why modern CPUs don't have a built-in RNG
03:23:01 <Jafet> jethr0, I don't do many monte carlo simulations, frankly, but if it mattered I might use arc4
03:23:04 <Baughn> ivanm: Hardware
03:23:07 <ivanm> Baughn: cost
03:23:13 <ivanm> it's too expensive :s
03:23:20 <ivanm> but IIRC, some workstation-based ones do
03:23:25 <Jafet> Baughn, because we don't trust CPU manufacturers to do it right!
03:23:25 <pozic> Baughn: what would the purpose be?
03:23:28 <Baughn> ivanm: I doubt it'd add more than $5 to the manufacturing cost
03:23:31 <ivanm> just not commodity ones
03:23:38 <ivanm> Baughn: *shrug* ask Intel, not me ;-)
03:23:42 <pozic> Baughn: for cryptography, people would probably not use it.
03:23:42 <jethr0> and real randomness is really hard to implement! especially if you want it to be moderately tamper-proof
03:23:55 <Baughn> pozic: A hardware RNG could produce /true/ randomness, at extreme speeds
03:24:05 <jethr0> i.e. not influencable from the outside to force patterns
03:24:20 <Baughn> jethr0: Well, ideally you'd use some reasonably unforceable QM decoherence effect
03:24:20 <ivanm> Baughn: apparently they're slow
03:24:25 <pozic> Baughn: true randomness might not even exist.
03:24:26 <Jafet> Baughn, do not confuse data bandwidth with entropy content
03:24:54 <ivanm> is it just me, or is wikipedia trying a new layout and failing badly?
03:25:01 * ivanm is having trouble reading anything :s
03:25:01 <jethr0> Baughn: afaik, this has not been done yet. there are some hardware devices, but power analysis, radiation, heat, ... can influence many of the used hardware randomness sources
03:25:04 <Baughn> ..excite the outermost orbital of an atom, see how long time passes before it emits the photon again
03:25:31 <FunctorSalad> isn't the least significant digit of classical phenomena just good enough? ;)
03:25:33 <porcopino> ivanm: what does lambdabot's unlambda do?
03:25:37 <Baughn> I know we've got single-photon capable CCDs, so it shouldn't be /that/ hard
03:25:38 <jethr0> plus for many physical effects their distribution cannot be proven to be 'truely' random AND unobservable from the ouside AND not be influenced from outside
03:26:00 <jethr0> many of the hardware sources i know of are rather slow in producing random numbers
03:26:00 <ivanm> @unlambda (\ x -> (x + 3) ^ 5)
03:26:01 <lambdabot>   unlambda: Unknown operator '('
03:26:04 <pozic> Baughn: I agree that it would be quite good, but then convincing the user that this is really what the device does, is another story.
03:26:07 <ivanm> @unlambda \ x -> (x + 3) ^ 5
03:26:07 <lambdabot>   unlambda: Unknown operator '\\'
03:26:12 <ivanm> porcopino: good question! ;-)
03:26:15 <FunctorSalad> I doubt you could even influence the last digit of acustic noise level or something
03:26:19 <pozic> Baughn: imagine one company building all these chips.
03:26:19 <Baughn> jethr0: Quantum electrodynamics has a lot of true-random exponential decay processes, though
03:26:21 <poe> it interprets unlambda
03:26:41 <Baughn> pozic: Well..
03:26:52 <Baughn> pozic: Um. Make them with RepRap? ^_^
03:27:01 <pozic> Baughn: yep
03:27:07 <porcopino> poe, what is unlambda :P
03:27:15 <jethr0> Baughn: absolutely, but is it feasible to put a sensor for it on the dye, and can you be sure that no radiation, heat, agitation, ... will influence the decay process?
03:27:21 <pozic> Baughn: but then you have to make the first RepRap yourself.
03:27:26 <Baughn> porcopino: An esoteric programming language based on lambda calculus
03:27:32 <pozic> Baughn: trust is a bitch ;)
03:27:55 <jethr0> obviously talking about crypto applications here. for screensaver-like randomness a simple hardware source would be obviously nice, even if only to seed a PRNG
03:28:07 <Baughn> pozic: If CPU makers want to control your computer, there are simpler ways than subtly biasing an RNG.
03:28:23 <FunctorSalad> heh
03:28:24 * jethr0 wants a bootstrapping reprap...
03:28:32 <pozic> Baughn: the video you referred to, is that something they are really working on or is it just an animation?
03:28:48 <ivanm> jethr0: you mean a self-bootstrapping rep-rap?
03:28:55 <Baughn> pozic: Just an animation - for now. We've still got a lot of components left to figure out before we can even /try/ putting it all together.
03:28:56 <ivanm> isn't part of the point of a rep-rap that it bootstraps?
03:28:58 <jethr0> yes! :)
03:29:21 <pozic> Baughn: and by we, you mean humanity?
03:29:25 <Baughn> Yes
03:29:28 <ivanm> right... that's like opening a box using the crowbar inside the box...
03:29:43 <jethr0> the rep-rap can produce itself (which is 'obviously' its purpose). but one that starts from almost nothing would be cool ^_^
03:29:50 <Jafet> @unlambda `c``s`kr``si`ki
03:29:50 <lambdabot>  Done.
03:29:53 <FunctorSalad> ivanm: well in haskell...
03:29:55 <Baughn> jethr0: You mean, the RepStrap?
03:30:04 <ivanm> FunctorSalad: heh... yay for tying the knot!
03:30:04 <poe> Jafet - indeed kind of disappointing.
03:30:13 <Jafet> repstrap sounds like a sex toy
03:30:30 <pozic> RepStrap actually exists.
03:30:40 <pozic> It sounded like a pun.
03:31:04 <jethr0> it did indead sound like a pun
03:31:11 <quicksilver> the rep-rap is a big con, it's can't produce itself at all
03:31:17 <jethr0> "aka the RepStrap machine, or making a RepRap machine from nothing. "
03:31:25 <quicksilver> it can produce itself except for a huge long list of things it can't make.
03:31:27 <ivanm> quicksilver: well, it produces parts for a new rep-rap
03:31:29 <jethr0> these people are even more crazy than me
03:31:31 <ivanm> oh?
03:31:32 <quicksilver> some parts, yes.
03:31:40 <Baughn> quicksilver: Fortunately, those bits are typically the cheap mass-produced ones
03:31:46 <quicksilver> Baughn: sure. it's clever
03:31:49 <Baughn> And they're /working/ on making it print those
03:31:50 <quicksilver> it's just not what it says it is.
03:31:58 <MyCatVerbs> What's the big thing with partial von Neumann machines, anyway?
03:31:59 <Baughn> I don't think it's ever claimed to be other than what it is
03:32:05 <Baughn> MyCatVerbs: They're neat!
03:32:06 <Jafet> Yes it has, Baughn.
03:32:08 <pozic> A real RepRap would use fusion to create any material from garbage.
03:32:09 <FunctorSalad> partial?
03:32:18 <Jafet> "A RepRap can make itself" -- bzzt
03:32:24 <MyCatVerbs> Baughn: We already have a working implementation of a self-reproducing machine.
03:32:30 <Baughn> Jafet: Well, if you don't read the small text..
03:32:37 <Baughn> *fine print
03:32:38 <MyCatVerbs> Baughn: on the order of about six and a half billion of the bloody things!
03:32:42 <jethr0> i think the goal is for the reprap to make itself. this is still work in progress
03:32:44 <FunctorSalad> "neat how you contain a machine for making more of you" :)
03:33:04 <Jafet> MyCatVerbs, they have this unfortunate weakness of having to work in pairs
03:33:11 <ivanm> "it would still require an external supply of several currently non-replicable components such as sensors, stepper motors or microcontrollers."
03:33:18 <ivanm> MyCatVerbs: heh
03:33:22 <FunctorSalad> Jafet: it's a feature.
03:33:31 <quicksilver> Baughn: I'm not claiming they are part of some big conspiracy to deceive. they're honest enough in the details. But the headlines lie.
03:33:34 <MyCatVerbs> Jafet: that's not a weakness. Recombination is actively useful.
03:33:45 <Jafet> And they also work very slowly at it. There are numerous defective units
03:33:46 <quicksilver> we're a very very long way from a truly replicating rep-rap
03:33:48 <MyCatVerbs> (Besides, it's not particularly difficult to find matching pairs.)
03:33:50 <Baughn> quicksilver: Oh, well. They're headlines. It's what they do.
03:34:10 <Baughn> pozic: At any rate, the nanofactory in that video is currently obsolete. They've figured out a better design.
03:34:31 <Baughn> pozic: Going from six to one hour for complete self-replication, in theory. :)
03:35:13 <pozic> But do they have any idea how to implement the designs?
03:35:39 <Baughn> To some degree. Not in detail, obviously.
03:35:53 <Baughn> We still can't manipulate atoms well enough to make one, though we're getting there.
03:35:55 <pozic> I mean, what they present can already work on a scale of blocks of 10 centimeters. The hard part is that nano ;)
03:36:04 <Baughn> ..it's a bit of a "open box with crowbar inside box" thing
03:36:25 <Jafet> I think the way to go is Heinlein's waldoes.
03:37:24 <Jafet> Using those as an example, you can work steadily upwards in complexity, building your tools, then using them to make other things, then finally making a new set of waldoes.
03:38:01 <Baughn> We've already /got/ nanofactories, though. They're cells.
03:38:18 <Baughn> Might as well use them, yes?
03:38:52 <Jafet> The "use" part might not be easy to get right
03:39:06 <Baughn> Working on it.
03:39:24 <arcatan> is there some standard function for expanding ~ in paths to $HOME? i looked in FilePath library but didn't find anything
03:40:27 <quicksilver> arcatan: no
03:41:14 <arcatan> okay
03:45:31 <mmorrow> @let replace ifthis that = foldr (\c -> if ifthis c then (that++) else (c:)) []
03:45:33 <lambdabot>  Defined.
03:46:01 <mmorrow> > replace (=='~') "$HOME" "~/.."
03:46:03 <lambdabot>   "$HOME/.."
03:46:42 <arcatan> i wrote one already, no worries :)
03:48:15 <Alpounet> > replace (=='~') "$HOME" "~/ ~/haskell/ ~/porn/"
03:48:17 <lambdabot>   "$HOME/ $HOME/haskell/ $HOME/porn/"
03:50:05 <Baughn> Alpounet: Too naive. ~ is valid in a filename, and does /not/ need to be escaped except if it's the first character of a path component.
03:50:30 <Baughn> Then there's the "~username" construction...
03:50:32 <ilid> Alpounet: what about haskell porn? ~/haskell/oleg?
03:50:53 <MyCatVerbs> ilid: You use symlinks to handle that case.
03:51:31 <ilid> Then there's the ~integer construction to refer to old $PWDs
03:52:35 <ilid> Then there's the ~user-defined-name construction which some shells support ;-)
03:52:47 <jethr0> mkdir ./~
03:53:37 <MyCatVerbs> If you want to mimic a shell's expansions, there are functions glob(3) and wordexp(3) for handling wildcards and tilde expansion respectively.
03:53:57 <MyCatVerbs> In POSIX, I mean. No idea whether or where the Haskell equivalents would be.
03:56:02 <Alpounet> ilid, heh, I haven't such ones, yet. Any good pointer about that ? Oh actually I may have. Are oleg's papers what we call "haskell porn" ?
03:56:38 <Alpounet> Baughn, yeah. It the path must start  with ~/ to replace by $HOME/ actually.
03:56:45 <MyCatVerbs> In Haskell, I guess I'd recommend using the HSH library from Cabal. HSH.ShellEquivs has a function (glob :: FilePath -> IO [FilePath]) that handles tilde expansion and wildcards all in one go.
03:57:03 <ilid> Alpounet: i think it depends a lot on your particular perversions ;-) i suspect some people would consider augustss's BASIC stuff to be pornographic :)
03:57:05 <mmorrow> > let sub env ('$':s) = let (x,t) = span isUpper s in (maybe ('$':x) id . lookup x) env ++ sub env t; sub env (c:cs) = c : sub env cs; sub _ [] = [] in iterate (sub [("O","$O$O")]) "$O"
03:57:07 <lambdabot>   ["$O","$O$O","$O$O$O$O","$O$O$O$O$O$O$O$O","$O$O$O$O$O$O$O$O$O$O$O$O$O$O$O$...
03:57:24 <MyCatVerbs> Alpounet: don't forget ~username/ expanding to username's homedir. :)
03:59:37 <flux> alpounet, which may not always be /home/xx, so it requires using getpwent or an equivalent
04:00:22 <Alpounet> to be fully functional, yeah, it's better to use posix tools.
04:00:33 <Alpounet> ilid, heh
04:09:05 <ski> (mmorrow : why not `structure M :: Monad' ?)
04:10:14 <mmorrow> are you talking about syntax or a particular use of that?
04:12:03 <mmorrow> ski: do you mean "these exact chars, in particular a \"::\" instead of \":\"", or wrt a previous code snippet?
04:14:14 <mmorrow> err, or do you mean instead of `structure M :> Monad' in StateM
04:14:40 <aleator> I'm having GLut program running extremely slow on os x (It draws unshaded teapot and nothing else). How can I get it to use hardware?
04:15:35 <mmorrow> a long shot, but maybe try -fno-state-hack to see if that's what's causing it
04:15:56 <jethr0> aleator: have you profiled your program?
04:16:58 <mmorrow> if it's reeeeally slow, it might be -fno-state-hack
04:17:23 <quicksilver> aleator: on OSX it should use hardware out of the box; are you sure you're right in diagnosing that as the problem?
04:18:26 <aleator> quicksilver: Well.. I could be wrong of course, since I've got rather limited opengl experience.
04:18:33 <aleator> Let me paste the thing for you
04:19:11 <mmorrow> there's this one ghc ticket where the state hack interacted really badly with a prog that rendered a mesh, but the teapots not a mesh actually i guess
04:20:18 <aleator> http://haskell.pastebin.com/d574ac87c
04:20:38 <aleator> This is what I'm trying to do.
04:22:10 <quicksilver> works fine for me
04:22:17 <quicksilver> in what sense do you mean to describe it as "slow" ?
04:23:16 <aleator> In a sense that in this machine the objects do not really move at all vs. my linux box where they circle around nicely
04:23:30 <quicksilver> circles around nicely for me
04:23:49 <quicksilver> of course you're making no attempt to clamp the frame rate
04:23:57 <quicksilver> so it runs at whatever speed the card wants to run at
04:24:44 <aleator> Hmm. Well, that could be it, but faster machine shouldn't make for slower results. I'll go back and do it with timers.
04:26:07 <quicksilver> you have to compare the graphics cards on the two machines too.
04:26:52 <ivanm> diff /machine1/GPU /machine2/GPU
04:26:53 <ivanm> ;-)
04:31:53 <Alpounet> aleator, I'd rather change the way you organize the rendering code.
04:32:23 <Alpounet> not sure though, but sometimes it's just a little thing that slows quite much your program.
04:33:49 <jethr0> i have some code that only draws a few 2d textured quads and the opengl code it is slow as well. i'll likely switch from arbitrary sized mipmaps to 2^n sized textures and see if that helps at all...
04:34:03 <jethr0> seemingly small change, hopefully big resulting change
04:34:16 <jethr0> s/change/cause/
04:36:42 <Lemmih> Raevel: Ping.
04:37:10 <Alpounet> jethr0, a problem I encountered with my 3D text drawing app was that there were *few* computations I was doing at each display refreshing whereas it was not needed. After that, my program was amazingly fast.
04:38:50 <aleator> Alpounet: How would you organise it?
04:39:05 <Raevel> Lemmih: pong
04:39:07 <Alpounet> aleator, let me take a look, 'cause actually I haven't looked yet.
04:39:14 <aleator> Ah.
04:39:18 <Alpounet> it was a general advice
04:40:09 <aleator> Perhaps it is that I've got more complicated setup that is making it slower. Are timers still the proper way to make animations?
04:42:05 <Alpounet> the best I've found so far.
04:42:24 <Alpounet> and actually, that's what we see in most GLUT/GL & Haskell related docs.
04:42:38 <Lemmih> Raevel: Your changes to the torrent package looks great. The repository is located here: http://darcs.haskell.org/~lemmih/torrent/
04:43:15 <Raevel> \o/
04:44:27 <Alpounet> aleator, actually, your code is similar to mine, concerning the organization.
04:44:38 <Alpounet> do you have optimizations, threading and all enabled ?
04:44:56 <Alpounet> (even if actually threading wouldn't be of help AFAIK)
04:44:58 <aleator> Just -O2
04:45:46 <aleator> Well. Anyways, it is just a toy so it is not so large problem. If my students give me heat with that, they earn more lambda calculus
04:46:06 <vegai> good idea.
04:46:32 <Lemmih> Raevel: Send a darcs patch my way and I'll push a new version to hackage.
04:48:09 <Baughn> jethr0: You should check for non-power-of-two texture support before /using/ non-power-of-two textures. Get a copy of glew. ;)
04:48:17 <Raevel> Lemmih: alright!
04:48:29 <Baughn> jethr0: In theory it's supposed to error out, but lots of drivers pretend.
04:49:17 <jethr0> Baughn: i just copied-pasted some code and it worked. but opengl is slow and so i'm now trying to see whether non-2^n textures are the reason...
04:49:51 <Lemmih> Raevel: OOI, why are you parsing torrent files?
04:50:11 <Alpounet> aleator, I don't see what's time consuming except the rendering itself, that you have to do anyway...
04:51:19 <aleator> So it is then either some weird hardware conf error, or that redrawing on idle is in general bad idea without extra machinery
04:52:17 <Alpounet> oh
04:52:32 <Alpounet> you don't draw on idle
04:55:16 <Raevel> Lemmih: I want to see what files a torrent is associated with, to clean up my torrent folders
05:11:45 <Raevel> Lemmih: http://ecmascript.se/etc/repos/torrent
05:12:17 <Raevel> i hope that's what you meant, i have not used darcs very much
05:44:34 <EvilMachine> hey, is there a reason in the theories behind Haskell, that Classes are treated differently than data types? To me they look as if it’s neither e problem of type safety nor of anything other I know. Maybe you can enlighten me. :)
05:44:45 <EvilMachine> e=a
05:45:03 <ivanm> why would they be the same?
05:45:10 <Botje> type classes are a mechanism for function overloading.
05:45:12 <ivanm> classes are a method of providing ad-hoc polymorphism for haskell
05:45:14 <EvilMachine> i’m not saying that they would be the same
05:45:30 <EvilMachine> i know all this
05:46:34 <EvilMachine> but from a pure practical standpoint: why not simply allow a list over a class? it would be very useful, and spare one the whole existential type stuff.
05:47:25 <EvilMachine> (When I say class, I always mean type classes, never the classes of object oriented programming. Except when I say so. :)
05:47:28 <jafet> What on earth is a "list over a class"
05:47:55 <ivanm> what existential type stuff?
05:47:58 <jafet> List is a (parametrized) type, lists are objects of that type
05:48:53 <EvilMachine> jafet: well, suppose you have a “class Shape s where …”. then imagen you could simply write “[Shape)”, and have no… what was it called… monomorphism restriction?
05:48:58 <EvilMachine> oops
05:49:05 <EvilMachine> i meant “[Shape]”
05:49:30 <jafet> Er, and that syntax describes... what?
05:49:58 <RayNbow`> http://www.haskell.org/haskellwiki/Heterogenous_collections ?
05:50:17 <EvilMachine> jafet: i don’t understand what you are not understanding in it… can you explain?
05:50:30 <Botje> EvilMachine: go easy on the unicode, not all people can read it :)
05:50:45 <jafet> Simply put, I have no idea what using list syntax in that way achieves
05:50:45 <Botje> EvilMachine: you can do [forall a. Shape s => s]
05:50:51 <pozic> What they mean is that assuming Shape a is a type class, that [Shape] means the existential data ShapeList = forall a.(Shape a)=>ShapeList [a]
05:51:56 <EvilMachine> RayNbow: Thank you. :) That was an obvious solution I did not think of. :)
05:53:08 <Lemmih> Raevel: Did you add Data.Torrent.Helpers?
05:53:31 <RayNbow> http://www.haskell.org/pipermail/haskell-cafe/2009-September/065952.html [Haskell-cafe] How to understand the 'forall' ?  <--  this might also be of interest
05:53:32 <EvilMachine> RayNbow: now if one could do that, without the need to declare an extra data type with a constructor for every type you want to use in that collection… :)
05:54:41 <EvilMachine> Botje: Oh, sorry. I'm used to it, because my keyboard layout supports it by default. Don't you use a unicode font? :)
05:54:57 <Botje> EvilMachine: oh, i can read yours just fine :)
05:55:02 <Botje> other people might not
05:55:59 <EvilMachine> Botje: hmm… if they’re using Windows 98/ME or a really old version of a linux distribution… :D
05:57:05 <jafet> Or a font with only ASCII glyphs
05:57:46 <jafet> ☃
05:58:57 <EvilMachine> jafet: ok, what it should achieve, is the same thing that existential types achieve. but without having to create a special data type, an instance for it to map to the class below it, or having to learn advanced concepts like existential types for no reason. ^^ I looks like a “why simple, when you can make it extra-complicated” ^^
05:59:34 <Cale> Heh, my mouse randomly firing mousewheel events as it breaks down has made me acutely aware of just how many user interface elements respond to mousewheel events.
06:00:15 <EvilMachine> jafet: yes. or a font with ASCII glyphs. or one for EBCDIC. ^^
06:01:03 <EvilMachine> Cale: open the mouse and take out the wheel. ^^
06:01:31 <EvilMachine> Cale: then map button 4 and 5 to wheel up and wheel down. :D
06:01:41 <EvilMachine> (if you have those)
06:01:47 <jafet> The horizontal axis will be a problem
06:01:54 <ivanm> EvilMachine: you're assuming that there are extra physical buttons for Cale to map...
06:02:16 <EvilMachine> ivanm: that’s why i said “if you have those” :)
06:02:19 <jafet> My mouse has both a clickable scrollwheel and a pair of side buttons, though
06:02:21 * RayNbow has a different mouse problem... left mouse button is a bit broken and sometimes the down signal is interrupted... causing accidental double clicks, failing drag/drop actions, or the effect of a jammed weapon when playing a FPS
06:02:34 <EvilMachine> just an idea anyway. :)
06:02:39 <ivanm> EvilMachine: right, after I started writing what I wrote ;-)
06:02:49 <ivanm> RayNbow: I had that... I bought a new mouse
06:02:56 <ivanm> $20 mice don't last long nowadays... :(
06:02:59 <jafet> So, existential types. I should do a bit of reading about those
06:03:09 <EvilMachine> RayNbow: do you have a Razer Copperhead by any chance? I sometimes got the same problem.
06:03:22 <RayNbow> no, a Logitech MX610
06:03:28 <EvilMachine> RayNbow: cleaning the little triggers on the inside helps
06:03:29 <jafet> But it seems that you're just simplifying the syntax a bit by munging it with existing syntax
06:03:42 <jafet> And C++ is famous for doing that well
06:03:52 <RayNbow> EvilMachine: I have no idea how to disassemble this mouse :p
06:04:28 <jafet> A sturdy flat-headed screwdriver works for practically any consumer electronics product
06:04:31 <luite> RayNbow: it probalbly has some screws (phillips) under a sticker or the feet
06:04:48 <jafet> ...unless you really want it back together later for some strange reason
06:05:01 <Cale> I think the spurious wheel clicks have something to do with the sensor firing randomly. Actually, just disabling those buttons in my X config would be a good idea, though my xorg.conf doesn't seem to have a section describing the mouse anymore.
06:06:12 <ivanm> Cale: isn't hal wonderful? :s
06:06:31 <EvilMachine> jafet: I just came up with that idea because I thought about what a hard special extension thing (existential types) i had to learn, just to get to something very very simple and basic: iterate over a list of different types with the same interface, calling the same function of that single interface for all of them. that should in no way be that hard to do. Good theory behind a language and such things are not mutually exclusiv
06:06:58 <jafet> xmodmap can do buttons
06:07:38 <jafet> Well, the existing wrappers seem good enough (tm) for me
06:07:38 <EvilMachine> RayNbow: unscrew all screws (sometimes one of them is below a sticker of glide pad) and then open the front or the back first (the side that had less screws).
06:07:57 <EvilMachine> RayNbow: very easy actually. helps you clean the insides
06:09:52 <EvilMachine> Cale: well, either the button’s trigger is somehow stuck in a chattering position, or your cable has a broken wire on the inside, or something like that.
06:09:57 * RayNbow fears he might have to remove all 4 glide pads
06:10:26 <EvilMachine> Cale: nowadays, you don’t configure the mouse in the xorg.conf. but i could help you with hal.
06:10:35 <RayNbow> http://www.helpmij.nl/leden/frisian/images/LogitechMX610/MX610_Batterij.jpg <-- since I don't see any screws in plain sight :p
06:10:40 <Cale> EvilMachine: Well, it already did have a problem with its main USB cable.
06:11:20 <luite> RayNbow: have you removed the batteries, there might be one there, or some latch
06:11:33 <EvilMachine> Cale: I replaced the usb cable of my mouse with that of an old mouse. the old cables were of higher quality (thicker), and apparently, the connectors inside the mouse usually are the same.
06:11:38 <Cale> (There was a bit of frayed wire right around where the cable entered the mouse, which I 'solved' by shifting the wire inward a bit)
06:12:19 <Cale> So, at least it's not randomly turning off and on, but there are some random signals, it seems.
06:12:36 <RayNbow> luite: none :p
06:12:48 <EvilMachine> RayNbow: pay attention to the glide pads. you never ever want to have them fall off later. Logitech mice have problems with that. But you can always buy thick teflon tape, cut out a piece, and have the best gliding mouse in your life. :)
06:13:51 <EvilMachine> Cale: i had your exact problem. the cable was broken where it came out the mouse. the replacement solved it perfectly. :)
06:14:50 * EvilMachine wonders if he fell into the hardware support channel without noticing it. ^^
06:16:07 <jafet> Come for the monads, stay for the mousepads
06:16:25 <EvilMachine> i thought there were only monoids…
06:16:59 <EvilMachine> … the love children of zuul and a mathematician extremist. ^^
06:20:34 <Cale> A monoid monoid is a commutative monoid. :)
06:21:28 <Cale> I'm seeing some noise about '/etc/hal/fdi/policy/mouse-wheel.fdi', but I don't have that file. Should I just create it?
06:21:31 <jafet> It doesn't rhyme as well
06:26:48 <Botje> Cale: yes.
06:27:11 <Botje> those .fdi files describe transformations on the Xorg config in memory. using xml. :)
06:29:51 <SmurfOR> :o
06:32:20 <EvilMachine> but it’s not specifically a bad thing if a fdi file does not exist. it just means that nothing happens, except for that which would be defined to happen in that file. so if you do not want anything special to happen, you don’t really need the file. :)
06:32:57 <EvilMachine> except of course, if your /usr/share/hal/ directory is missing, or something like that. that would be bad. ^^
06:35:30 <ilid> hmm, my /etc/hal/fdi/policy/preferences.fdi starts with <?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
06:35:36 <ilid> couldn't they make up their minds?
06:35:57 <Botje> that looks like a vim / emacs hint
06:36:37 <EvilTerran> -*- ... -*- isn't a vim modeline
06:37:00 <ilid> vim autodetects that it's XML, presumably from the <?xml :-)
06:41:27 <EvilMachine> ilid: maybe It’s the disease of using both XML and SGML headers, that you had to use to make XHTML work in Internet Explorer some time ago. (I hope it’s not the case anymore.) And someone just thought that would be a normal thing to do everywhere. But then I have no idea what that -*- stuff means. ASCII art? ^^
06:42:25 <trzkril> EvilMachine: it is an emacs mode thing
06:42:31 <EvilMachine> ah. ok
06:42:35 <trzkril> i don't remember the actual name of the construct
06:42:49 <trzkril> it's about local variables and modes
06:43:34 <etpace> What's a typical `choose k from n' in haskell? I can do permutations but Im not sure how to do thid`
06:44:31 <EvilMachine> Oh man, Haskell is really hard. Because things like that would require defining whole new language constructs and keywords in other languages. While in Haskell, they are just a simple part of a library. That thing is *crazy* for someone who isn’t used to so much freedom. :)
06:45:35 <Zao> forever $ baffle mind
06:46:23 <EvilMachine> (By “that thing” I mean things like just adding “scrap your boilerplate” as a library, instead of it meaning it’s a whole new language. )
06:46:35 <nswill> Anyone have any suggestions for making this a bit nicer? Is a fold even the best way to do this? foldr (\x -> (++) [x, x]) [] [1,2,3] --output [1,1,2,2,3,3]
06:46:45 <EvilMachine> I bet Cthulhu programs in Haskell. :D
06:47:03 <SmurfOR> after a big glass of whiskey monads _kind of_ make sense
06:47:13 <EvilMachine> nswill: you could use a foldr1 in this case
06:47:23 <pozic> How can I get a profile from a non-terminating program?
06:47:25 <Saizan> nswill: i'd use concatMap
06:48:07 <nswill> Thanks, I'll check those out
06:48:08 <Saizan> pozic: ^C
06:48:09 <FunctorSalad_> > repeat 2 =<< [1,2,3]
06:48:10 <lambdabot>   Couldn't match expected type `a -> m b' against inferred type `[t]'
06:48:18 <FunctorSalad_> > replicate 2 =<< [1,2,3]
06:48:19 <lambdabot>   [1,1,2,2,3,3]
06:48:30 <EvilMachine> FunctorSalad_: lol. gooy idea. ^^
06:48:41 <Saizan> =<< = concatMap
06:48:45 <EvilMachine> y=d
06:49:05 <FunctorSalad_> yes, I had read Saizan's suggestion and just wanted to type less or something
06:49:06 <nswill> It's actually a prototype for a simultaneous upsampling and convolution operator so the "x's" would have different coefficients
06:52:03 <pozic> I get that (.) allocates 60%?
06:52:09 <kakeman> how to do this? http://pastebin.com/d213448a
06:54:50 <kakeman> there is strings inside lists inside list
06:55:34 <kakeman> too much for me
06:55:47 <Saizan> you don't want "do" there
06:55:50 <Botje> kakeman: don't use "do" there
06:56:15 <Botje> kakeman: also, what are the parameters to listVertex supposed to do ?
06:56:17 <Saizan> and, what's the second String input to listVertex?
06:56:27 <pozic> kakeman: you just have to decompose the problem if it is too complicated.
06:57:13 <pozic> kakeman: you want to parse a file, which is the same as parsing a bunch of lines, which is the same as parsing a word followed by exactly 3 doubles separated by spaces.
06:57:15 <kakeman> i'm trying to parse .obj http://en.wikipedia.org/wiki/Obj
06:57:30 <pozic> kakeman: you can almost completely type that in Parsec.
06:57:42 <kakeman> parsec?
06:57:51 <kakeman> lets see
06:58:17 <pozic> It does take some time to learn maybe how Parsec works, but writing a parser is trivial once you know how it works.
06:58:34 <pozic> The documentation is on the website.
07:03:06 <trzkril> is there some more elegant way to write these to functions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10564#a10564
07:05:44 <Lemmih> trzkril: What is it supposed to do?
07:06:11 <trzkril> Lemmih: create all Valuations that are defined exactly on the given set of atoms
07:07:17 <trzkril> it's part of a very simple tautology checker for propositional logic
07:09:06 <trzkril> @pl foldr \a l -> ap (changeVal a True) l ++ map (changeVal a False) l [undefined]
07:09:06 <lambdabot> (line 1, column 7):
07:09:06 <lambdabot> unexpected "\\"
07:09:06 <lambdabot> expecting variable, "(", operator or end of input
07:09:18 <trzkril> @pl foldr (\a l -> ap (changeVal a True) l ++ map (changeVal a False) l) [undefined]
07:09:18 <lambdabot> foldr (ap (ap . ((++) .) . ap . flip changeVal True) (map . flip changeVal False)) [undefined]
07:10:07 <trzkril> @pl \a b v p = if p == a then b else v p
07:10:07 <lambdabot> (line 1, column 10):
07:10:07 <lambdabot> unexpected "="
07:10:07 <lambdabot> expecting pattern or "->"
07:10:11 <Eelis> has anyone ever suggested that lambdabot be made more economic in how many lines it uses for its output?
07:10:17 <trzkril> @pl \a b v p -> if p == a then b else v p
07:10:17 <lambdabot> (ap .) . flip . (if' .) . (==)
07:10:48 <EvilTerran> Eelis, almost certainly
07:11:40 <Eelis> then i take it its author is not of the opinion that this would be worthwhile :)
07:11:50 <byorgey> trzkril: what's the  foldr f' [undefined] for?
07:11:58 <byorgey> folding over a length-1 list is strange.
07:12:00 <ilid> @type map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)])
07:12:01 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
07:12:06 <ilid> trzkril: ^^ like that?
07:12:27 <pao> can anyone explaing when unsafeReadDouble (Data.ByteString.Lex.Double) is unsafe to use? the doc isn't very clear
07:12:49 <Lemmih> byorgey: Have a look at the number of arguments to 'foldr'.
07:12:52 <pao> it states "It uses strtod directly on the bytestring buffer. strtod requires the string to be null terminated, or for a guarantee that parsing will find a floating point value before the end of the string. "
07:12:52 <ilid> byorgey: he's not folding over a length-1 list. the accumulator starts as a length-1 list
07:13:04 <byorgey> Lemmih: oh! duh.
07:13:56 <trzkril> ilid: i have to digest that first, will take some time
07:14:23 <ilid> trzkril: the trick is that 'sequence' for the list monad produces all lists comprised of taking one element from each given list.
07:15:09 <ilid> trzkril: so i give it a list of lists of ==a, /=a, and it gives me back the set of lists of the form [(op1 a), (op2 b), (op3 c), ...] for op<i> from (==), (/=)
07:15:36 <ilid> (where as == [a,b,c,...])
07:15:54 <nswill> FunctorSalad, thanks for that tip, I had to read a bit to figure out how that actually worked, I can just replace the replicate with my convolution kernel
07:16:21 <nswill> > (\x -> [x/2, -x/2]) =<< [1,2,3]
07:16:22 <lambdabot>   [0.5,-0.5,1.0,-1.0,1.5,-1.5]
07:16:34 <nswill> :)
07:16:50 <trzkril> @type sequence
07:16:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:24:54 <hackagebot> htzaar 0.0.2 - A two player abstract strategy game. (TomHawkins)
07:35:27 <trzkril> > sequence . map (\a -> [(==a), (/=a)]) $ [1, 2, 3]
07:35:28 <lambdabot>   [[{-3->False;-2->False;-1->False;0->False;1->True;2->False;3->False},{-3->F...
07:36:02 <trzkril> ilid: that just does not seem right
07:36:12 <trzkril> > map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]
07:36:13 <lambdabot>   [{-3->False;-2->False;-1->False;0->False;1->False;2->False;3->False},{-3->F...
07:37:15 <trzkril> > let changeVal a b v p = if p == a then b else v p
07:37:16 <lambdabot>   not an expression: `let changeVal a b v p = if p == a then b else v p'
07:38:17 <jkff> Lambdabot won't let you let
07:38:46 <trzkril> > let changeVal a b v p = if p == a then b else v p; f' a l = (map (changeVal a True) l) ++ (map (changeVal a False) l) in foldr f' [undefined] [1,2]
07:38:47 <lambdabot>   [* Exception: Prelude.undefined
07:39:03 <Jafet> let where?
07:40:02 <jkff> Undefinedwhere
07:43:05 <Raevel> Lemmih: yep, i added Helpers
07:44:44 <trzkril> > let changeVal a b v p = if p == a then b else v p; f' a l = (map (changeVal a True) l) ++ (map (changeVal a False) l) in lenght $ foldr f' [undefined] [1,2]
07:44:45 <lambdabot>   Not in scope: `lenght'
07:44:50 <trzkril> > let changeVal a b v p = if p == a then b else v p; f' a l = (map (changeVal a True) l) ++ (map (changeVal a False) l) in length $ foldr f' [undefined] [1,2]
07:44:51 <lambdabot>   4
07:45:11 <trzkril> > length $ map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) [1,2]
07:45:12 <lambdabot>   The section `GHC.Classes.== a' takes one argument,
07:45:12 <lambdabot>  but its type `[a -> GHC...
07:45:43 <trzkril> > length $ map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]
07:45:44 <lambdabot>   4
07:46:34 <trzkril> > (map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]) ! 0
07:46:35 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
07:46:36 <lambdabot>         against inferred t...
07:46:40 <trzkril> > (map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]) !! 0
07:46:41 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->False;2->False;3->False}
07:46:45 <trzkril> > (map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]) !! 1
07:46:47 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->True;2->False;3->False}
07:46:56 <trzkril> > (map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]) !! 2
07:46:57 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->False;2->True;3->False}
07:47:03 <trzkril> > (map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) $ [1,2]) !! 3
07:47:05 <lambdabot>   {-3->True;-2->True;-1->True;0->True;1->False;2->False;3->True}
07:48:49 <trzkril> ilid: so your method gives False as the default, that's not quite what i wanted but will do anyway
07:49:37 <trzkril> @type (\fs x -> all ($x) fs)
07:49:38 <lambdabot> forall a. [a -> Bool] -> a -> Bool
07:50:04 <trzkril> @type all
07:50:05 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:56:34 <nok> Hallo Haskellers, greetings from Amsterdam. May I ask you for advise for a problem concerning haddock.
07:56:56 <nok> I have written a package where the Show type class is replaced by a Display type class for more comfortable screen output for my data types. Main function of this Display type class is display::a->IO(), which works like print. Instancs of display are Bool, Int, Char, but also String. Now, ghci cannot load this module in default mode, because Display String is illegal, since String is a type synonym. However, after :set -fglasgow-exts, ghci acce
07:56:56 <nok> pts this and everything works fine. But now I want to write the documentation and haddock refuses and recommends: "Use -XFlexibleInstances if you want to disable this." But how can I set extensions for haddock? The man page doesn't explain that.
07:59:33 <Saizan> nok: put {-# LANGUAGE FlexibleInstances #-} in the file
08:00:00 <nok> Saizan: at the top of the module?
08:00:18 <Saizan> nok: yes
08:01:57 <jokerGTA> can anyone help me with something please
08:02:06 <hackagebot> safe-freeze 0.0 - Support for safely freezing multiple arrays in the ST monad. (ReinerPope)
08:02:28 <trzkril> @type \x -> all ($x) fs
08:02:29 <lambdabot> Not in scope: `fs'
08:02:37 <trzkril> @type \x -> ($x)
08:02:39 <lambdabot> forall a b. a -> (a -> b) -> b
08:03:11 <jokerGTA> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4319#a4319
08:04:02 <Raevel> jokerGTA: shouldn't mainType be MainType?
08:04:34 <jokerGTA> oh sorry that was the typo...my question is about MainType
08:05:00 <trzkril> @type \x -> all ($x)
08:05:01 <lambdabot> forall a. a -> [a -> Bool] -> Bool
08:05:14 <jokerGTA> in function "some" if i return just MyType2 it works just fine
08:05:22 <nok> Saizan: I put {-# LANGUAGE FlexibleInstances #-} before the "module TextDisplay where ..." and ghci loads that. But haddock now complaints with "Illegal instance declaration for 'Display String' ... Use -XTypeSynonymInstances if you want to disable this". Can I add this, too, and how?
08:05:45 <jokerGTA> but what i need is for example if i want to return for example thius
08:05:59 <jokerGTA> i want to return first element of Type1 which is list of integers
08:06:05 <jokerGTA> and i cant do that for some reasons
08:06:08 <EvilTerran> nok, the syntax is {-# LANGUAGE AnExtension, AnotherOne, AndAnother #-}
08:06:30 <nok> EvilTerran: Thanks, I try that...
08:07:04 <Raevel> jokerGTA: so, MainType -> [Int] ?
08:08:26 <jokerGTA> well for example i could do this    .....since I need first element of Type 1 i could do this "fst(fst(a))
08:08:30 <EvilTerran> nok, incidentally, the need for FlexibleInstances wasn't because String is a type synonym, it was because, in haskell98, instances have t obe of the form "instance SomeClass (SomeType typeVar typeVar ...)" (0 or more type vars), and String = [Char] = [] Char
08:08:32 <jokerGTA> i cant do that for some reasons
08:09:16 <EvilTerran> (and Char isn't a type variable, it's just a type)
08:09:27 <jokerGTA> because i am taking first element of mainType and then i am taking first elemnt of type1
08:09:49 <Raevel> jokerGTA: since you have newtypes you cannot treat the types as tuples, if you want a type synonym you can use type instead of newtype
08:10:08 <hackagebot> curry-base 0.2.5 - Functions for manipulating Curry programs (BerndBrassel)
08:10:10 <jokerGTA> i need more then just name for type thats why i used newtype
08:10:24 <Raevel> jokerGTA otherwise you have to pattern match to get the tuple out of there
08:10:26 <jokerGTA> so there is no way to access this like i though i could
08:10:42 <ilid> trzkril: to be honest i'm not completely sure what you're trying to do... most of the functions you produce will be of the form (x==a && x==b && p x) (for some p)
08:10:43 <dpratt71> poking around with ghci, I often encounter difficulty with type annotations (or the lack thereof)...
08:11:06 <trzkril> ilid: exactly
08:11:07 <dpratt71> ...for example, if I do mappend 2 3, that is ambiguous
08:11:12 <jokerGTA> can you show me example
08:11:26 <ilid> trzkril: do you expect 'x' to compare equal to multiple distinct things?
08:11:33 <trzkril> ilid: no
08:11:34 <dpratt71> is there a good resource for how to specify type annotations inline
08:11:38 <Raevel> jokerGTA: (MainType (My1 (list,_)),_) = list
08:11:46 <dpratt71> (using ghci)
08:12:05 <EvilTerran> dpratt71, if EXP is an expression and TYP is a type, (EXP :: TYP) is an expression
08:12:14 <nok> EvilTerran: HEUREKA! It works! Thank you very much EvilTerran and Saizan, you made my day. And I think I understand the underlying mechanics of your solutions, and that probably helps me with some other difficulties I have. Thank's a lot!!!!
08:12:22 <trzkril> ilid: i want to create all the predicates (valuations) that differ for the elements on the list
08:12:30 <trzkril> s/for/on/
08:12:48 <jokerGTA> so my list of integers is then in the "list" now
08:13:07 <Raevel> jokerGTA: right
08:13:19 <dpratt71> EvilTerran: thanks; can you give me a concrete example of how to express the "Sum" instance of mappend?
08:13:57 <jokerGTA> but why is the list on the right side of =
08:14:01 <jokerGTA> rather then on the left
08:14:29 <jokerGTA> oh god yes..i see what you mean
08:14:35 <Raevel> :-)
08:14:52 <ilid> trzkril: looks like "\xs -> map (==) xs ++ [const False]" would give you the same list, without duplicates, assuming your Eq instance is well-behaved and your input list is duplicate-free
08:15:19 <jokerGTA> why is pattern matching this way...like doesnt java has same thign with paramethars
08:15:37 <EvilTerran> > Sum 2 `mappend` Sum 3
08:15:38 <lambdabot>   Sum {getSum = 5}
08:15:41 <jokerGTA> like whats the difference
08:15:42 <EvilTerran> dpratt71, ^
08:15:50 <trzkril> > length $ \xs -> map (==) xs ++ [const False] $ [1,2]
08:15:51 <lambdabot>   The lambda expression `\ xs
08:15:51 <lambdabot>                             -> GHC.Base.map (GH...
08:16:35 <Makoryu> > Just True < Just False
08:16:36 <lambdabot>   False
08:16:39 <Saizan> you can't take the length of a function :)
08:16:57 <trzkril> Saizan: i did not
08:16:59 <EvilTerran> > Nothing < undefined
08:17:01 <lambdabot>   * Exception: Prelude.undefined
08:17:06 <EvilTerran> > Nothing <= undefined
08:17:08 <lambdabot>   * Exception: Prelude.undefined
08:17:10 <hackagebot> KiCS 0.8.6 - A compiler from Curry to Haskell (BerndBrassel)
08:17:10 <EvilTerran> huh
08:17:21 <ilid> > length $ (\xs -> map (==) xs ++ [const False]) [1,2]
08:17:22 <lambdabot>   3
08:17:23 <trzkril> Saizan: should have been a list of functions
08:17:38 <dpratt71> EvilTerran: ah, thanks
08:17:42 <Raevel> jokerGTA: i'm not sure what you mean
08:17:53 <Saizan> trzkril: but something of the form "\xs -> .." is always a function
08:17:54 <ilid> trzkril: lambda extends as far to the right as it can
08:17:59 <Makoryu> jokerGTA: What code are you looking at, again?
08:18:06 <trzkril> ah, yes
08:18:08 <jokerGTA> well for example in java.....this function 1(int i , int j){some body here}
08:18:10 <Raevel> jokerGTA: but you might want to check out record syntax
08:18:13 <trzkril> my bad
08:18:18 <jokerGTA> now i call that function from somewhere like this
08:18:26 <jokerGTA> function1(1,2)
08:18:28 <ilid> *shrug* lots of people seem to expect $ to be syntax rather than an operator
08:18:32 <jokerGTA> isnt that pattern matching as well?
08:18:33 <Makoryu> trzkril: Write (\...) if you want to use it in the middle of an expression
08:18:35 <trzkril> ilid: 3 is not enough, there are 4 predicates
08:18:46 <Raevel> ok n/m record syntax
08:18:52 <Makoryu> jokerGTA: No.
08:18:56 <Saizan> jokerGTA: no
08:19:11 <Saizan> jokerGTA: pattern matching is more like generalized switch statements
08:19:30 <trzkril> > (\xs -> map (==) xs ++ [const False]) [1,2]
08:19:30 <lambdabot>   [{-3->False;-2->False;-1->False;0->False;1->True;2->False;3->False},{-3->Fa...
08:20:11 <Rotaerk> pattern matching is the opposite of OO type polymorphism
08:20:14 <trzkril> ilid: that is missing the one where both elements are mapped to True
08:20:17 <ilid> trzkril: heh, right, i've pruned out too many of them
08:20:20 <EvilTerran> > id :: Int -> Int -- what's going on here
08:20:22 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
08:20:22 <Makoryu> jokerGTA: If Java had pattern matching, you could write something like: int[] xs; {x, y, zs...} = xs;
08:20:23 <EvilTerran> i see
08:20:35 <trzkril> > length $ (\xs -> map (==) xs ++ [const False]) [1,2,3]
08:20:36 <lambdabot>   4
08:20:42 <trzkril> ilid: a lot to many ;)
08:20:46 <trzkril> too
08:21:07 <ilid> trzkril: not a lot actually
08:21:15 <sproingie> Makoryu: if java had useful syntax we wouldn't need scala
08:21:17 <jokerGTA> well no but you could do xs = [1,2,3] couldnt you
08:21:25 <Makoryu> sproingie: Yes, but that's beside the point ;)
08:21:28 <jokerGTA> only difference i see is that here you could have infinite list
08:21:29 <trzkril> > length $ map (\fs x -> all ($x) fs) . sequence . map (\a -> [(==a), (/=a)]) [1,2,3]
08:21:30 <lambdabot>   The section `GHC.Classes.== a' takes one argument,
08:21:30 <lambdabot>  but its type `[a -> GHC...
08:21:33 <Rotaerk> OO type polymorphism allows you to define a fixed number of operations in terms of a non-fixed number of data models
08:21:36 <EvilTerran> sproingie, scala has far too much syntax for its own good, though
08:21:42 <ilid> trzkril: i was aiming at pruning out all that had two (==)s, but i also hit the one which had none ;-/
08:21:50 <Makoryu> jokerGTA: Pattern matching lets you take things apart on the left side of the =
08:21:51 <Saizan> jokerGTA: the difference is that you can take apart the values with the same syntax you construct them
08:21:52 <Rotaerk> whereas pattern matching lets you define a non-fixed number of operations in terms of a fixed number of data models
08:22:07 <Saizan> jokerGTA: simple variable binding is not the same thing
08:22:25 <ilid> trzkril: for length xs > 1, (\xs -> map (==) xs ++ [const False, not.elem xs]) is i think right
08:22:32 <Rotaerk> well... pattern matching on discriminated unions, that is
08:22:33 <Makoryu> jokerGTA: If something like [1,2,3] is a regular value, that's called a literal.
08:22:42 <ilid> for length xs <= 1 it's still right but contains duplicates :-)
08:22:50 <jokerGTA> ok
08:23:03 <fxr> wow hyena is very fast
08:23:16 <Rotaerk> not as fast as cheetah
08:23:28 <Makoryu> jokerGTA: If you want to look inside the array, Java forces you to use the "xs[0], xs[1], etc." syntax
08:23:29 <fxr> what's cheetah?
08:23:56 <Rotaerk> a fast cat
08:24:00 <jokerGTA> yes
08:24:05 <jokerGTA> it does
08:24:25 <fxr> strange comparison
08:24:40 <ilid> trzkril: though i suspect you actaully want: map (\fs x -> any ($x) fs) . sequence . map (\a -> [(==a),(/=a)])
08:24:42 <Rotaerk> I'm just being a smartass, don't know what "hyena" is :P
08:24:43 <Makoryu> jokerGTA: The Haskell equivalent is the (!!) operator, for the record
08:25:02 <fxr> @where hyena
08:25:03 <lambdabot> I know nothing about hyena.
08:25:05 <ilid> trzkril: hmm, not that either :-/
08:25:21 <Saizan> ?src maybe
08:25:21 <lambdabot> maybe n _ Nothing  = n
08:25:21 <lambdabot> maybe _ f (Just x) = f x
08:25:27 <fxr> Rotaerk: http://github.com/tibbe/hyena
08:25:39 <Saizan> jokerGTA: see the maybe definition above ^^ it's pattern matching on the Maybe value
08:25:44 <Rotaerk> ah cool
08:25:52 <Saizan> using the same constructors you'd use to build it
08:25:56 <Saizan> ?src Maybe
08:25:56 <lambdabot> data Maybe a = Nothing | Just a
08:26:02 <trzkril> ilid: the function you gave originally gives exactly those functions i want, so there is no need to prune any of them
08:26:04 <jokerGTA> oh i see...
08:26:46 <Saizan> a single variable is sort of a trivial pattern that matches any value
08:27:01 <fxr> well it does 6000 requests per second  (each with 32K data) with 6 MB resident memory on my machine
08:27:01 <Saizan> and it's useful if you just want to thread that value around instead of inspecting it
08:27:09 <ilid> trzkril: that function applied to [1,2,3] gives you [\a -> a==1 && a==2 && a==3, \a -> a==1 && a==2 && a/=3, \a -> a==1 && a/=2 && a==3, ...] all of which are False everywhere
08:27:11 <trzkril> ilid: but i still don't really understand that first lambda expression. fs is a list of predicates to be combined, x is the parameter of the function to create
08:27:25 <trzkril> ilid: but which list is all applied to?
08:27:31 <jokerGTA> tx guys
08:27:31 <ilid> trzkril: so the produced list contains duplicates
08:27:51 <trzkril> ilid: which duplicates?
08:28:29 <ilid> trzkril: the function (\a -> a==1 && a==2 && a==3) and the function (\a -> a==1 && a==2 && a/=3) are extensionally equal for a well-behaved Eq
08:28:41 <ilid> (assuming that 1 and 2 are distinct)
08:28:57 <ilid> trzkril: since they both return False for all inputs
08:29:04 <trzkril> ilid: right, hm
08:29:32 <ilid> trzkril: i suspect you actually want something more like: map (flip elem) . subsequences
08:30:00 <ilid> trzkril: that is, for every subset of your initial set, the indicator function for that subset
08:31:21 <trzkril> hm
08:31:29 <ilid> (put another way, given a set of elements of some type with an Eq instance, you want the list of all total predicates which can be constructed)
08:31:34 <trzkril> yes, exactly
08:32:04 <ilid> it's actually only half of them: you also have the choice of what it should return on elements not in the given set
08:32:06 <trzkril> well, i do not need the total ones, the minimally defined would do as well
08:32:11 <tinLoaf> if i have associated a certain type with another type in a class instance via type families, can i somehow "access" that associated type?
08:33:10 <Saizan> tinLoaf: only if you fix a particular type for its index
08:33:27 <ilid> all of them would be, i think: concatMap (\xs -> [flip elem xs, not . flip elem xs]) . subsequences
08:33:28 <Saizan> or with the class methods
08:33:47 <tinLoaf> Saizan: so i should declare a class method returning that type?
08:34:19 <ilid> or just: (\xs -> [(`elem` xs), (`notElem` xs)]) <=< subsequences
08:35:02 <Saizan> tinLoaf: i guess so, you'd also need methods if you want to manipulate it polymorphically
08:35:15 <hackagebot> property-list 0.0.0.6 - XML property list parser (JamesCook)
08:36:43 <trzkril> ilid: subsequences, sequences, that's the stuff i was missing
08:42:17 <hackagebot> curry-frontend 0.2.5 - Compile the functional logic language Curry to several intermediate formats (BerndBrassel)
08:47:18 <hackagebot> KiCS 0.8.7 - A compiler from Curry to Haskell (BerndBrassel)
08:55:20 <trzkril> @type >=>
08:55:21 <lambdabot> parse error on input `>=>'
08:55:26 <trzkril> @type (>=>)
08:55:27 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:56:53 <trzkril> @type elem
08:56:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:57:25 <trzkril> @type return . elem
08:57:26 <lambdabot> forall (m :: * -> *) a. (Monad m, Eq a) => a -> m ([a] -> Bool)
08:58:05 <trzkril> @type (subsequences >=> return . elem)
08:58:06 <lambdabot> forall a. (Eq a) => [a] -> [[[a]] -> Bool]
08:58:14 <trzkril> na
08:58:28 <trzkril> @type (subsequences >=> flip elem)
08:58:29 <lambdabot>     Couldn't match expected type `[c]'
08:58:29 <lambdabot>            against inferred type `a -> Bool'
08:58:29 <lambdabot>     In the second argument of `(>=>)', namely `flip elem'
08:58:33 <trzkril> @type (subsequences >=> return . flip elem)
08:58:34 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
08:59:17 <trzkril> ilid: why pair elem and notElem? there is another subsequence which covers exactly the notElem case
08:59:40 <trzkril> > length $ (subsequences >=> return . flip elem) [1,2]
08:59:41 <lambdabot>   4
08:59:43 <trzkril> > length $ (subsequences >=> return . flip elem) [1,2,3]
08:59:44 <Jafet> @pl \f a b -> f a b c
08:59:44 <lambdabot> flip flip c . (flip .)
08:59:44 <lambdabot>   8
09:10:00 <trzkril> ilid: thanks, thats not even a lot shorter but also easier to understand
09:10:40 <trzkril> s/even/only
09:17:30 <Raevel> oh Lemmih, i forgot to add Helpers it seems, darcs confuses me, it's in my repo now though
09:18:07 <Raevel> i expected diff or whatsnew to tell me that there was an untracted file
09:18:28 <Raevel> untracked*
09:19:38 <ilid> trzkril: the pairing of elem and notElem is to cover what happens when the given value is not an element of your input list. one of them will return True, the other False in that case.
09:20:39 <trzkril> ilid: so i would get twice as many functions as i actually need
09:20:54 <ilid> depends on whether you care about elements not in your input set
09:21:10 <jmcarthur_work> Raevel, darcs w -l
09:21:11 <trzkril> ilid: the ideal case would be, if the function was just undefined for everything not in the list
09:21:31 <Raevel> jmcarthur: oo
09:22:34 <ilid> trzkril: that's easy enough to arrange, but it'd be extra work for a case which (presumably) will never come up
09:23:36 <trzkril> ilid: right
09:23:44 <trzkril> ilid: well, the second part
09:24:04 <ilid> trzkril: incidentally, foo >=> return . bar is the same as fmap bar foo (or "bar <$> foo" if you prefer)
09:24:06 <trzkril> ilid: i will think a while about the difficulty
09:24:54 <trzkril> ah, did not see that :(
09:25:56 <trzkril> @type fmap (flip elem) subsequences
09:25:57 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:26:38 <trzkril> @type subsequences >=> return . flip elem
09:26:39 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
09:28:35 <trzkril> @type return . flip elem
09:28:36 <lambdabot> forall (m :: * -> *) a. (Monad m, Eq a) => [a] -> m (a -> Bool)
09:29:27 <Philippa> @src <$>
09:29:28 <lambdabot> f <$> a = fmap f a
09:29:44 <trzkril> ilid: sure about that? seems to me as if the types don't fit
09:29:46 <Philippa> @src <*>
09:29:47 <lambdabot> Source not found. You untyped fool!
09:34:32 <ilid> @type \xs -> fmap (flip elem) subsequences
09:34:33 <lambdabot> forall t a. (Eq a) => t -> [a] -> [a] -> Bool
09:34:38 <ilid> @type \xs -> fmap (flip elem) (subsequences xs)
09:34:39 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
09:34:56 <ilid> trzkril: yeah, sorry, i meant >>= not >=> ;-)
09:35:24 <ilid> @type fmap (flip elem) . subsequences
09:35:25 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
09:36:03 <EvilMachine> LOL. Only in a Haskell wiki can you find sentences like this: “To show you how this could be useful, we will implement an evaluator for the typed SK calculus.”Yeah right, very “real world”, that example! :P And the next line looks like this: “[…] the combinator λ x y z . x z ( y z ) which, in simply typed lambda calculus, have types a → b → a and (a → b → c) → (a → b) → a → c. […]”“Oh teh horr
09:36:03 <EvilMachine> ot. ^^
09:37:29 <data_jepp> I have a function that just returns the input, if it is indeed an int.
09:37:31 <data_jepp> evalProg (Tall x) d = Just x
09:37:38 <data_jepp> Is that wrong?
09:37:48 <nswill> I'm constantly surprised how often when I write something in haskell that compiles it does what I intended, it's like GHC is reading my mind!
09:37:52 <data_jepp> Tall is an alias for Int
09:38:14 <nswill> Seriously though the super strong typing system in haskell forces me to clarify my intentions more than any other language methinks
09:40:16 <ski> (Botje : i think `[exists a. Shape a *> a]' rather than `[forall a. Shape a => a]' was wanted ..)
09:40:39 <ski> data_jepp : unless `Tall' is a data constructor, that won't work
09:40:43 <Botje> oh, i'm not too familiar with such things yet :;)
09:40:49 <trzkril> > subsequences "11"
09:40:50 <lambdabot>   ["","1","1","11"]
09:40:54 <Botje> was just a wild guess :)
09:40:56 <data_jepp> ski: it is defined in my datatype
09:40:58 <ski> data_jepp : what is the intended type of `evalProg' ?
09:41:00 <ilid> nswill: i do find a lot more errors are caught at compile time rather than at runtime compared to, say, C++.
09:41:04 <trzkril> > subsequences . nub "11"
09:41:05 <lambdabot>   Couldn't match expected type `[a]'
09:41:06 <lambdabot>         against inferred type `GHC.Types...
09:41:09 <trzkril> > subsequences . nub $ "11"
09:41:10 <lambdabot>   ["","1"]
09:41:13 <data_jepp> ski: Maybe Int
09:41:13 <ski> Botje : those two are very different :)
09:41:13 <ilid> it'd be nice if i understood the error messages, but... ;-)
09:41:35 <ski> data_jepp : i don't believe that .. `evalProg' must be a function
09:41:35 <nswill> C/C++ just can do such bizarre and subtle things that can be really difficult to debug
09:42:11 <ski> data_jepp : i.e. `evalProg' must have a type looking something like `... -> ...'
09:42:11 <data_jepp> ski: it needs to parse a lot of different datatypes for expressions and stuff
09:42:44 <ilid> i would quite like an interactive tool which i could tell which of the inferred/expected types is correct, and have it tell me where the wrong one came from :)
09:42:51 <Botje> ski: woops :)
09:43:14 <nswill> ilid, you mean like a code intelligence feature in an ide?
09:43:57 <trzkril> @pl \f -> nub . concatMap (pure . f)
09:43:57 <lambdabot> (nub .) . (=<<) . (pure .)
09:44:01 <ski> data_jepp : `evalProg' must have a type like `X -> Y -> Z' .. the only question is what `X',`Y',`Z' actually are
09:44:02 <ilid> nswill: yeah, something like that, or a command-line tool
09:44:05 <nswill> That would be really cool to have it underline typing errors in realtime
09:44:19 <nswill> Err, no pun intended
09:44:26 <trzkril> @pl \f -> nub . toList . fmap f
09:44:27 <lambdabot> ((nub . toList) .) . fmap
09:44:33 <data_jepp> X is Expr, Y is a list, and Z is the result of the evaluation
09:44:37 <ilid> the trouble is, it doesn't really know where the typing error is, just where it detected it :(
09:44:50 <data_jepp> Y list can be ignored in this case
09:45:05 <ski> data_jepp : anyway, if ou have said `type Tall = Int' then that `Tall' has nothing to do with the one in `evalProg (Tall x) d = ...'
09:45:26 <ski> for the latter to work, you must make some type with `Tall' as a *constructor*
09:45:40 <ilid> data_jepp: i'm assuming you have 'data Expr = ... | Tall Int | ...' in which case your code looks fine (but I'd use _ rather than d for the other parameter)
09:45:40 <data_jepp> ski: pastebin site? :p
09:45:44 <ski> @paste
09:45:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:45:49 <ilid> @where paste
09:45:49 <lambdabot> http://hpaste.org/new
09:45:50 <data_jepp> ilid: yes
09:45:57 <data_jepp> ok
09:46:12 <ski> (ilid : i'm not assuming that .. yet :)
09:46:29 <data_jepp> ski: I've been in here all week with the same program :p
09:46:48 <ski> ilid : you want an interactive tool supporting type error slicing
09:46:56 <ilid> ski: s/i'm assuming/on the assumption that/ s/ in which case/,/
09:47:16 <ski> (fair enough)
09:47:28 <data_jepp> ilid: Still it wont just return the number when it finds the type (Tall x)
09:47:37 <ilid> ski: if type error slicing means what i want then that's what i want ;-)
09:47:39 <nswill> To those that know more about these kinds of things, hypothetically if someone were to try to make a code intelligence backend to some ide; I suppose you'd just run code through ghci?
09:47:58 <ski> ilid : there's some paper somewhere .. i forgot what it's named
09:48:12 <ilid> nswill: i think one would probably use the GHC API directly
09:48:29 <ski> the idea is to keep track of exactly which part of the program provide which part of the types
09:48:55 <ski> such that when a type error is found, it reports the minimal set of locations that contribute to that error
09:49:05 <ski> not just the first spot where it noticed the error
09:49:13 <ilid> ski: to be honest, i'd be happy with something where i could just say either 'the inferred type is right' or 'the expected type is right' and have it slam in a type signature for that expression and compile again
09:49:15 <nswill> Passing the program through the type checking phase of the compilation gives you a line by line drill down of which argument is incorrectly typed, would you hook that?
09:49:37 <ski> so at least one of the reported locations must be changed to fix the error, and all locations are relevant
09:50:12 <ilid> ski: that sounds pretty awesome
09:51:06 <ski> (of course, fixing the error might entail that you have to change one or more of those locations in such way that you have to alse change new locations, to fix all aspects of this error)
09:51:10 <nswill> Yeah, that would just make an incredibly fast workflow
09:51:14 <data_jepp> oh oh oh, it says no instance for                                                                                x _br_
09:51:23 <data_jepp> 18:37:28   lambdabot | Haskell pastebin: http:(Show ([(Char, Int)] -> Maybe Int))
09:51:24 <nswill> Combined with an editor with a good vi mode you'd feel like a haskell ninja
09:51:31 <data_jepp> obs
09:52:00 <ski> data_jepp : pasted yet ?
09:52:08 <data_jepp> ski: sec
09:52:57 <data_jepp> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4320#a4320
09:53:37 <ski> (you don't need to attribute the link to only me .. others here might be interested in looking at the paste)
09:54:16 <ski> well, that loos ok, for a start
09:54:20 <ski> what's the error ?
09:54:26 <data_jepp> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4321#a4321 it wont let me print out Tall 5, says something about show not being implemented for evalProg
09:54:45 <ski> data_jepp : next time, annotate the original paste
09:55:06 <data_jepp> what does annotate mean?
09:55:09 <ski> (it looks like `evalProg' will have type `Expr -> Maybe Int', btw)
09:55:25 <data_jepp> ski: Not when I need to look up variables in that list
09:56:06 <ski> data_jepp : if you click on the "add revision" link, you can add an annotation (or more) to the paste, and they will all show up on the original page
09:56:21 <data_jepp> oh, thanks for the tip
09:56:45 <ski> that way, it is easier to group related pastes, and to see all more or less at once
09:56:53 <data_jepp> the datatype is deriving show so why won't let it print out?
09:56:54 * ski has no idea why it is called "revision", though ..
09:57:42 <ski> .. oh
09:58:02 <ski> it looks like you are trying to `show' `evalProg' applied to just one argument
09:58:30 <ski> you need to try something like `evalProg (Tall 42) []', instead of `evalProg (Tall 42)'
09:58:44 <data_jepp> hmm
09:58:47 <data_jepp> ok ill test
09:59:00 <ski> the latter is still a function, because it is missing the environment argument .. and functions can't be printed sensibly, generally
09:59:02 <data_jepp> ski: it worked :p haha
10:00:01 <ski> (tip : when you see an error like "no instance for `Show (Blah -> Bleh)'", check for missing arguments)
10:00:16 <data_jepp> I wont forget that part ^^^^
10:01:43 <data_jepp> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4321#a4322 how about Sum of the expressions?
10:02:46 <ski> that's not quite ok for two reasons
10:03:29 <ski>   (a) `x = evalProg x scope' is a recursive binding, shadowing the `x' from the argument (and mutatis mutandis for `y')
10:04:18 <data_jepp> ski: Expr is an resursive datatype, it must be evaluated. Before I can use math on it.
10:05:15 <ski>   (b) even so, `xVal = evalProg x scope' would make `xVal' have type `Maybe Int' (and same for `yVal'), so `Just (xVal + yVal)' is still an error, since you don't want to add `Maybe Int's, you want to add `Int's  (and then wrap that into a `Maybe Int', not a `Maybe (Maybe Int)', by the `Just')
10:05:55 <Eduard_Munteanu> Hi.
10:06:19 <ski> data_jepp : yes .. but here you must use either (a) `case'; (b) a helper function which pattern-matches; or (c) some library function which does one of the two former options
10:07:17 <ski> data_jepp : `evalProg x scope' will give you a `Maybe Int', but you want to access the `Int', if there was one (`Just xVal'), and do something else if there wasn't one (`Nothing')
10:07:27 <ski> have you seen `case', before ?
10:07:35 <data_jepp> ski: No I havent.
10:07:43 <ski> ok, then you can try a helper
10:07:48 <ski> something like
10:08:14 <ski>   evalProg (Sum x y) scope = check (evalProg x scope) (evalProg y scope)
10:08:15 <ski>     where
10:08:44 <ski>     scope (Just  x) (Just  y) = ..y..z..
10:09:30 <ski>     scope  Nothing  ???       = ...
10:09:40 <ski>     ..maybe more cases.. ?
10:09:47 <ski> do you understand the idea ?
10:10:03 <ski> er, sorry, those two lines should start with `check', not `scope'
10:10:25 <data_jepp> ski: hehe ok
10:10:25 <ski> i.e.
10:10:34 <ski>     check (Just  x) (Just  y) = ..y..z..
10:10:34 <ski>     check  Nothing  ???       = ...
10:11:01 <ski> so `check' is just a quick way to check whether you actually got an answer by evaluating `x' and `y'
10:11:18 <ski> if you want to try `case' instead, it will look like
10:11:34 <ski>   evalProg (Sum x y) scope = case (evalProg x scope,evalProg y scope) of
10:11:48 <ski>     (Just  x,Just  y) -> ..y..z..
10:12:04 <ski>     (Nothing ,???     ) -> ...
10:12:23 <data_jepp> (Just x, Just y) -> ? what is going here?
10:12:48 <Berengal__> evalProg (Sum x y) scope = (+) <$> evalProg x scope <*> evalProg y scope
10:13:05 <ski> the difference is that `case <scrutinee> of <pattern0> -> <expression0> <newline> <pattern1> -> <expression1> ...' is an expression
10:13:38 <ski> data_jepp : `(Just x,Just y)' is a pattern, just as `(Just x)' and `(Just y)' is
10:13:46 <data_jepp> Oh
10:13:58 <ski> when you pattern-match on the arguments of a function, you can pattern-match on all the arguments
10:14:06 <Eduard_Munteanu> I recently read about the total functional paradigm. Is there any Haskell compiler that provides a strictly total functional subset?
10:14:19 <lament> hi
10:14:33 <ski> but you can only `case' on one expression at a time, not many, so i put those two expressions into a pair, to be able to pattern-match on the two parts anyway
10:14:51 <Philippa> Eduard_Munteanu: which one? There's more than one notion of it now, unfortunately :-(
10:15:09 <ski> (if you wanted, you could make the `check' above take a pair instead of two arguments, it would work just as fine)
10:15:26 <sunrayser> why can't I use case within a let expression without defining the case stuff in an external function?
10:15:27 <Philippa> you can write total functions if you avoid anything with a fixpoint in it, but that's probably a bit limited
10:15:44 <Philippa> sunrayser: are you doing GADT matches?
10:15:47 <ski> sunrayser : how do you mean ?
10:15:52 <sunrayser> let whatever = case stuff of a->"A" b->"B" seems not to work
10:16:08 <sunrayser> it says parse error
10:16:12 <Eduard_Munteanu> Philippa, the one that guarantees halting. Does any Haskell compiler allow bailing out in case termination cannot be deduced?
10:16:30 <Philippa> Eduard_Munteanu: nope, Haskell's fairly unavoidably partial
10:16:32 <Eduard_Munteanu> i.e. Turner's non-Turing complete.
10:16:44 <Philippa> try Agda, Epigram or Coq
10:16:48 <sunrayser> Philippa: it's just a simple Maybe String
10:16:49 <ski> > let whatever = casae stuff of {a -> "A" ; b -> "B"}; stuff = () in whatever
10:16:50 <lambdabot>   <no location info>: parse error on input `of'
10:16:56 <ski> > let whatever = case stuff of {a -> "A" ; b -> "B"}; stuff = () in whatever
10:16:57 <lambdabot>   "A"
10:17:26 <ski> sunrayser : if you are putting several branches on the same line, you need to separate them with `;'
10:17:39 <Eduard_Munteanu> Philippa, could you elaborate on why is it unavoidably partial? I wonder if there's a subset of Haskell that could do it.
10:17:47 <sunrayser> ski: no, it was put on two lines (the one-line was just for irc)
10:17:55 <ski> sunrayser : otherwise, check that your branches are indented more than the `w' in `whatever'
10:17:56 <Eduard_Munteanu> Philippa, in fact not a subset, because we need codata.
10:18:16 <ski> (sunrayser : it doesn't suffice to me more indented than the `let')
10:18:21 <Philippa> that alone should tell you a lot :-) You also need recursion schemes, because you can't use general recursion any more
10:18:33 <Philippa> and suddenly let doesn't work any more...
10:19:08 <Philippa> (so you can reduce it to non-recursive let, but now you've got no way of doing anything recursive without adding induction and coinduction, which Haskell doesn't have because that's what fix gets it)
10:19:13 <sunrayser> ski: http://pastebin.ca/1607572 it's the one that gives the parse error
10:20:03 <ski> that looks fine, in isolation
10:20:07 <Eduard_Munteanu> Philippa, hm, hm... I really like Haskell and thought I would be able to try "total functional" in a friendly/known environment :)
10:20:25 <sunrayser> ski: yep, only looks
10:20:35 <ski> sunrayser : oh, right - also make sure you're not mixing tabs and spaces for indentation
10:20:51 <ski> (most would say never use tabs)
10:20:55 <sunrayser> ski: everything is space, vim highlights everything
10:21:09 <ski> so i think we need more context
10:21:38 <Eduard_Munteanu> Philippa, thanks.
10:22:52 <sunrayser> ski: ok I have a separated source
10:23:18 * ski doesn't know what "separated" means, here
10:23:39 <Cale> There we go. I just went out and got a new mouse :)
10:23:59 <sunrayser> ski: http://pastebin.ca/1607588 here is a complete source that gives the error
10:25:03 <ski> Cale : three-buttoned ?
10:25:43 <Cale> ski: Well, including the wheel button. Plus the wheel has two axes.
10:25:49 <ski> sunrayser : that's different code from the previous one :)
10:26:03 <sunrayser> ski: yep, but still gives the error
10:26:16 <sunrayser> ski: I tried to make it as simple as possible
10:26:19 <ski> sunrayser : also, not that the branches there are not indented more than the `a' .. which i noted ought to be, above
10:26:25 <ski> s/not/note/
10:27:04 <Philippa> Eduard_Munteanu: if you write some Generic Haskell, you may be able to build induction and coinduction for algebraic datatypes generally - if you're consistent about where you use what, you might be able to write some sensible code. You'll have to check it's total yourself though
10:27:10 <ski> <ski> sunrayser : otherwise, check that your branches are indented more than the `w' in `whatever'
10:27:13 <ski> <ski> (sunrayser : it doesn't suffice to me more indented than the `let')
10:27:21 <sunrayser> ski: ah sorry I see, it works now thanks
10:27:29 <Philippa> Agda and Coq'll be the place to look. Agda's fairly haskell-influenced in its syntax, AIUI
10:27:44 <ski> sunrayser : and does the non-simplified code work, too ?
10:28:02 <sunrayser> ski: moment and I'll check it
10:28:49 <ski> (btw, the brackets around `Just "hello"' there is not needed)
10:29:10 <sunrayser> ski: yes it works, after adding more indentation to the case
10:29:11 <Eduard_Munteanu> Philippa, so a total Prelude variant couldn't resort to some sort of type-checking to prove total-correctness?
10:29:25 <data_jepp> evalProg (Sum x y) scope = case (evalProg x scope,evalProg y scope) of
10:29:31 <data_jepp> obs
10:29:33 <data_jepp> evalProg (Sum x y) scope = case (evalProg x scope,evalProg y scope) of
10:29:34 <sunrayser> ski: however I don't understand the reson behind this behaviour
10:29:42 <data_jepp> grrr sec
10:29:45 <sunrayser> *reason
10:29:53 <ski> sunrayser : the `case', as well as the branches most be more indented than the left-hand-side of the `='
10:30:11 <ski> (but the branches doesn't need to be more indented than the `case')
10:30:12 <data_jepp> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4321#a4323 would this be crazy talk?
10:31:02 <lenny222> i am struggling with let/in/if/then/else indendation: http://codepad.org/hEuhffip
10:31:11 <Eduard_Munteanu> Eduard_Munteanu, it would seem to me Prelude definitions (which are above the compiler level IIRC) could be changed to forbid non-total constructs.
10:31:12 <sunrayser> ski: ok but why does it need to be indented more? Is it otherwise so difficult to parse?
10:31:12 <ski> data_jepp : that's closer .. but you can't just return `x + y', you want to return a `Maybe Int', but `x + y' is an `Int'
10:31:23 <lenny222> can anyone tell me how to fix the indendation of the if/then/else block?
10:31:30 <data_jepp> Just(x+y)?
10:31:38 <ski> that would work, yes
10:31:43 <data_jepp> :D
10:31:55 <Botje> lenny222: have you tried putthing the code for the then and else branches on the same line as their keywords?
10:32:02 <ski> data_jepp : also, you need to say what to do when either (or both) of the results of the recursive call yields `Nothing'
10:32:30 <ski> sunrayser : the simple answer is that the syntax specifies that it must be
10:33:42 <lenny222> Botje: is there no other way?
10:34:11 <Botje> actually, your code looks fine to me.
10:34:15 <ski> sunrayser : everything inside a block must be indented at least to the indentation level of that block. if the block has subblocks, they must be indented more .. if there comes text which is indented less, that is interpreted as the block ending just before that text
10:34:23 <Botje> are you sure you're not mixing tabs and spaces?
10:34:25 <lenny222>     parse error (possibly incorrect indentation)
10:34:42 <burp> which line?
10:34:58 <lenny222> the last line
10:35:08 <lenny222> 54:74:
10:35:09 <ski> sunrayser : operationally, there's a pass that translates the indentation blocks to `{',`;',`}' (you can use them instead, if you don't want to use layout)
10:35:16 <lenny222> while 54 is the last line of the snippet
10:35:16 <burp> missing )?
10:35:19 <sunrayser> ski: so why is let different? (I'm not a pro at haskell but I don't usually get this error)
10:35:27 <burp> lenny222: there seems to be missing a )
10:35:28 <ski> sunrayser : different from what ?
10:35:43 <burp> no?
10:35:44 <Botje> oh.
10:35:47 <lenny222> burp: you are right, thanks
10:35:48 <Botje> lenny222: you're missing a )
10:35:49 <Botje> bleh :)
10:35:50 <ski> this is do different from if you had typed into a file
10:35:50 <quicksilver> sunrayser: let, case, and do are specified to use layout notation.
10:35:58 <ski>   module Foo
10:36:00 <ski>      where
10:36:07 <lenny222> oh my god, i already thought i was in indendation hell. thanks guys anyway
10:36:09 <ski>      foo :: Int -> Int -> Int
10:36:10 <sunrayser> ski: everything works with always-4-char-indentation, except let
10:36:14 <ski>      foo m n =
10:36:19 <ski>    m + n
10:36:57 <sunrayser> quicksilver: layout notation? do you have a simple definition of that or should I google it?
10:37:15 <quicksilver> it's pretty simple. It says that if something is indented more, it continues the last item
10:37:22 <ski> in this case, `m + n' are indented less than the (supposedly) containing block (which starts at `foo m n ='), so it complains that the `foo' definition is incomplete
10:37:27 <quicksilver> if it's indented the same, it's a new item
10:37:38 <quicksilver> and if it's indented less, it's the end of that thing, back to the enclosing thign
10:37:52 <sunrayser> quicksilver: ok but for "let" this seems not to be enough
10:38:03 <ski> sunrayser : yes it is
10:38:11 <lenny222> bye
10:38:13 <ski> `let' introduces a new block
10:38:43 <ski> the first token after `let' determines the indentation level for that block
10:38:57 <sunrayser> ski: it seems to me that the "let" itself isn't in the block itself but the block starts with the "a" after let, and that is what specifies the indentation
10:39:11 <ski> as soon as something is indented the same as that level, a new item inside `let' is started (and the previous one is ended)
10:39:26 <sunrayser> ski: so what if I use a \n after let?
10:39:38 <ski> as soon as something is indented less than that level, the whole block is ended (and the previous item is also ended)
10:39:55 <ski> sunrayser : doesn't matter with a new-line, since that is whitespace
10:39:57 <jkff> Hi guys. I'm playing with defunctionalization; I've written 3 functions for tree height: a recursive one, and obtained mechanically from it a CPS one and a defunctionalized CPS one. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10566 I can't figure out how to mechanically make a stack-based tree height function from height3.
10:40:30 <ski> the first non-whitespace (including comments, iirc) after the `let' (or `where' or `do') determines where the block starts
10:40:31 <sunrayser> ski: but that may reduce the indentation level needed because the "a" will have less indentation
10:40:34 <ski> so
10:40:35 <ski>   foo x = let
10:40:45 <ski>       bar y = ..x..y..
10:40:50 <ski>     in ..x..bar..
10:40:51 <ski> is ok
10:41:33 <ski> the first token after `let', i.e. `bar' here, determines what indentation level the block has
10:41:38 <jkff> ...This, like, should be a matter of spotting a reduntant constructor that is immediately deconstructed, but I can't find it.
10:41:57 <sunrayser> I see
10:42:14 <sunrayser> I thought that let itself specifies the indentation
10:42:20 <ski> nope
10:42:43 <ski> this is similar with the other block-starting keywords, like `where' and `do'
10:44:04 <ski> (and that's more or less what quicksilver said, only more elaborated)
10:44:27 <quicksilver> I note that always 4 spaces is certainly a rule you can use
10:44:32 <quicksilver> ..you just don't have to
10:44:48 <quicksilver> some people like to *always* put a newline after let/do/where/case
10:44:54 <quicksilver> precisely so they can use 'always 4 spaces'
10:44:59 <jkff> hmm... So well, how does one write a non-recursive stack-based tree height function?.. /me remembers The Basics
10:45:18 <quicksilver> sorr, rather than after case I mean after of ;)
10:45:19 <sm> I have a packaging question
10:45:23 <sm> I'd like to split an app into several hackage packages, but still have a single main binary which acquires more subcommands as you install more packages
10:45:41 <quicksilver> jkff: in haskell recursion is the only iteration you have available to you.
10:45:47 <jkff> quicksilver: I know
10:46:07 <quicksilver> jkff: you can store an explicit stack to convert some recursion patterns into other recursion patterns :)
10:46:10 <sm> so guess I'd like to discover installed packages at run time. Any idea of the best way to go about this dcoutts, anyone ?
10:46:22 <quicksilver> e.g. change a binary recursion into a simple one
10:46:22 <Saizan> if you want to avoid _explicit_ recursion you've to write a fold for your tree first
10:46:23 <jkff> quicksilver: Have you seen the code? :) I am actually writing this code to explain a mechanical and simple way of eliminating recursion in general
10:46:40 <quicksilver> ah sorry. jupming in halfway through then.
10:46:45 * quicksilver retracts his comments.
10:47:03 <jkff> And it seems to me that CPS and defunctionalization is an easier way than immediately coming up with a stack-based thing
10:47:05 <dcoutts> sm: having discovered them at runtime, how would you call them? are these things other executables?
10:47:29 <sm> good question.. I thought to import them.. but of course I can't do that (unless with dyre or something)
10:47:44 <jkff> So, well, my defunctionalized version of the CPS-ed version is close to a stack-based one, but not quite. I'm seeking for the last step.
10:48:59 <Eduard_Munteanu> Philippa, it would seem to me Prelude definitions (which are above the compiler level IIRC) could be changed to forbid non-total constructs.
10:49:05 <sm> I'd like to have folks install hledger, and later install hledger-web, hledger-extras etc. without recompiling the first
10:49:29 <Eduard_Munteanu> Wouldn't type checking be enough? We already do some proofs in Haskell.
10:49:30 <sm> I guess that means either dynamic recompilation, or invoking separate binaries
10:49:58 <quicksilver> you might be able to do something with GHC-API, sm
10:50:12 <quicksilver> maybe each package has a top-level symbol called 'moduleDescr' of some fixed type
10:50:22 <quicksilver> and you explicitly grab that with GHC-API directly
10:50:29 <ilid> quicksilver: i do the always-newline-after-layout-keyword thing. but if/then/else ends up ugly, and i never know where to put 'where' =(
10:50:33 <quicksilver> (it presumably has other useful stuff inside it bundled in existentials or similar)
10:50:52 <quicksilver> I don't find if/then/else ugly
10:50:53 * sm ponders that
10:51:11 <quicksilver> if/then/else is a single expression so it's perfectly logical that then/else be more indented than if.
10:51:22 <quicksilver> (it's just a different kind of perfectly logical to other languages we're used to)
10:51:36 <quicksilver> I strongly oppose the Haskell' plan to "fix" this "problem"
10:51:45 <quicksilver> as for "where", you're right, that's a troubel
10:51:52 <quicksilver> you have to backspace a half-indent for it
10:51:55 <sm> I wonder how this works in xmonad
10:51:56 <quicksilver> but I never use where, really
10:52:18 <quicksilver> sm: xmonad recompiles a single file which gives a fixed module name
10:52:25 <sm> I think there, all the extras are gathered up in xmonad-contrib, and you do recompile everything
10:52:28 <ilid> quicksilver: the result is that if then and else are the only keywords which are followed by an expression
10:52:30 <quicksilver> sm: that's not the same as finding an arbitrary package
10:52:42 <ilid> which i find visually jarring
10:53:36 <ski> jkff : `KCons :: Either (Tree a) Int -> Context a -> Context a' ?
10:54:06 <jkff> ski: Clarify please?
10:54:28 <ski>   data Context a = KNil  -- i.e. `Id'
10:54:50 <ski>                  | KCons (Either (Tree a) Int) (Context a)
10:54:58 <ski> there's your two constructors
10:55:03 <jkff> ski: That's just isomorphic to what I've written
10:55:14 <jkff> Essentially 3 constructors
10:55:15 <ski> (and `Context a' is a stack of `Either (Tree a) Int')
10:55:27 <ski> of course it's isomorphic
10:55:32 <jkff> Can't we just get with [Tree a]?
10:55:42 <sm> dyre seems to be oriented towards recompiling/restarting when a config file changes
10:56:10 <quicksilver> sm: I think what I suggested can work but I'm not absolutely sure how you use the GHC API to load a package by name and find a fixed (name) symbol from it.
10:56:11 <ski> you need to store the intermediate result of one sub-tree, while exploring another sub-tree
10:56:25 <ilid> quicksilver: i suspect i'd not avoid if so much if i could write 'if foo then\n  bar\nelse\n  baz'
10:56:27 <ski> i suppose you could possibly avoid that with an accumulator, though
10:56:38 <jkff> Yes, precisely
10:56:41 <sm> quicksilver: I didn't follow it completely alas
10:56:58 <ski> but i don't see how that would generalize simply
10:57:22 <sm> quicksilver: how would the main binary discover the installed subpackages ?
10:57:41 <ski> hm, actually, since you use `max', i'm not fully sure an accumulator works ..
10:57:46 * ski ponders
10:58:03 <jkff> ski: Well, I seem to have forgotten how one writes a stack-based tree height :)
10:58:21 <jkff> Have I just worked too much for today, or does it really require Either?
10:58:31 <ski> i'm suspecting it does
10:59:38 <ski> (the usual call stacks are generally heterogenous)
11:00:11 * ski wonders if one could maybe do pointer-reversal ..
11:00:41 <jkff> Better not :)
11:01:00 <ski> (not in the literal sense, of course :)
11:01:35 <sm> it seems like the easiest thing is to have the main program use system/shell facilities to detect installed subprograms, and act as a front-end that just passes through command-line arguments
11:01:59 <sm> maybe a bit more fragile though
11:02:00 <jkff> But hey, after all that's what reallyUnsafeReversePointers# is for!
11:04:14 <ski> jkff : i mean in the sense that if you do it, then with uniqueness analysis, a compiler could optimize (simply) what you wrote into performing pointer-reversal de re
11:04:58 <ski> (i.e. what i did when traversing the graph of a simple (acyclic) text adventure map)
11:24:35 <tony_> I've got an associated type question if anyone's available
11:24:44 <tony_> I wanted to do this: class Foldable a => BQueue a where
11:24:49 <tony_> for a bounded capacity queue
11:25:03 <tony_> and have an associated type type Elem a
11:25:40 <tony_> Writing the class was a bit awkward since in order to get the kinds right I had to write a lot of: a (Elem a) in function types
11:25:59 <tony_> But then when I went to define an instance, I couldn't get around the Kind mis-match
11:26:30 <tony_> Because in the instance I want to write: instance BQueue (MyQueue a) where ...
11:26:48 <tony_> but ghc is expecting a kind of * -> *
11:26:58 <tony_> anyone have any tips on this one?
11:28:46 <tony_> Here's the code that won't type check, http://haskell.pastebin.com/d7ee5d400
11:30:07 <jkff> tony_: Why do you need those a (Elem a) ?
11:30:11 <jkff> Why not just 'a' ?
11:30:27 <tony_> Because you get a kind mis-match due to the Foldable a otherwise
11:30:48 <jkff> Ah, ok. Then you need to declare an instance for MyQueue, not for MyQuee a
11:30:57 <jkff> Because it's a type constructor class, not a type class
11:31:00 <tony_> But then I can't define Elem
11:31:12 <jkff> Why?
11:31:31 <jkff> Doesn't " instance BQueue ListQueue where type Elem (ListQueue a) = a " work?
11:31:45 <tony_> I think I tried that, I'll double check
11:32:07 <tony_> No luck
11:32:22 <jkff> Have you looked at how UArrays are implemented, or some other type-family-related stuff
11:32:26 <jkff> ?
11:32:38 <SamB_XP> jkff: ITYM PArrays
11:32:53 <tony_> Not in depth. I've used associated types in a few places, but never run into this issue before.
11:32:59 <SamB_XP> not quite positive though
11:33:00 <jkff> Probably. Or the heterogenous collections
11:33:03 <SamB_XP> @hoogle UArray
11:33:04 <lambdabot> Data.Array.Unboxed data UArray i e
11:33:04 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
11:33:04 <lambdabot> Data.Array.IO.Internals castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
11:33:13 <jkff> Ugh
11:33:17 <SamB_XP> okay, you definitely don't mean *that* UArray
11:33:26 <jkff> Not heterogenous, I mean those self-optimizing ones
11:33:36 <jkff> By dons
11:33:37 <mux> uvector?
11:33:51 <jkff> http://hackage.haskell.org/package/adaptive-containers
11:33:55 <mux> oh.
11:34:08 <SamB_XP> ah, yeah, uvector must be what he was thinking of with UArrays, right?
11:34:18 <SamB_XP> @hackage uvector
11:34:19 <lambdabot> http://hackage.haskell.org/package/uvector
11:34:32 <mux> no, he really means something else
11:34:41 <jkff> Yeah, uvector fits too
11:34:46 <mux> but then again both uvector and the adaptive containers use the same tricks
11:34:47 <SamB_XP> mux: I think he was thinking of several different things
11:35:01 <tony_> they don't have constraints
11:35:03 <SamB_XP> and that uvector was what he called UArrays ;-)
11:35:09 <mux> associated data types to select optimized unbox representations
11:35:13 <tony_> which is what's given me my trouble
11:35:16 <mux> unboxed
11:35:27 <SamB_XP> tony_: what error messages have you been getting ?
11:35:48 <tony_> It's always a kind mis-match
11:36:01 <tony_> whether it's in the class or the instance depends on how I try to fix it
11:36:02 <SamB_XP> did you define your own class ?
11:36:12 <SamB_XP> okay, yes, your own
11:36:17 <tony_> Yes, the paste is here: http://haskell.pastebin.com/d7ee5d400
11:36:46 <SamB_XP> jkff: no wonder you were confused -- the type is called UArr!
11:37:02 <SamB_XP> dons: that was a *real* good idea to name that type UArr!
11:37:13 <tony_> the class looks nasty because without applying a to an argument, I'd get a kind mis-match due to the Foldable constraint
11:37:17 <SamB_XP> or, wait, not his?
11:37:21 <SamB_XP> ... confused ...
11:38:08 <tony_> If I take Data.Adaptive.List as a best practice example, perhaps I should assume that the class constraint approach doesn't work in this scenario
11:38:27 <SamB_XP> okay, apparantly someone else wrote that module ...
11:38:58 <SamB_XP> dons: how come uarray doesn't have full author information in the haddock headers of the modules ?
11:40:19 <SamB_XP> @localtime dons
11:40:20 <lambdabot> Local time for dons is Fri Oct  9 11:40:19 2009
11:40:39 <SamB_XP> is he at lunch, or actually working, or something ?
11:41:04 * SamB_XP just got up, even though
11:41:09 <SamB_XP> @localtime SamB_XP
11:41:11 <lambdabot> Local time for SamB_XP is Fri Oct 09 14:40:01
11:41:30 <SamB_XP> well, okay, I got up 40 minutes ago, but that's pretty much just
11:41:59 * SamB_XP is on fall break, and he apparantly needed quite a bit of sleep
11:43:18 <Arnar> hey guys
11:43:38 <Arnar> was wondering, want to play with dsp algorithms for audio, e.g. for changing pitch etc
11:43:50 <Arnar> any pointers on hs libraries for such exercises?
11:44:24 <sproingie> someone should port supercollider to haskell
11:44:48 <Arnar> supercollider?
11:45:00 <ksf> csound.
11:45:28 <ksf> ...a week or two ago someone wanted to make a new jack binding
11:45:50 <Arnar> ksf: thanks
11:45:50 <Arnar> aha
11:45:56 <Arnar> what's wrong with the old one?
11:46:03 <ksf> it doesn't compile.
11:46:09 <sproingie> Arnar: soft synth, has its own weird language
11:46:25 <ksf> it's not that it's hard to get stuff working.
11:46:30 <sproingie> supposed to be awesomely powerful
11:46:35 <Arnar> sproingie: aha.. looks interesting
11:47:15 <ksf> I _think_ haskore also comes with some build-in dsp stuff
11:47:24 <ksf> ...I don't think it's rt, though
11:47:57 <ksf> Haskore specializes more on messing with scores, generating midi and input for supercollider/csound than dsp itself.
11:48:18 <en0th> hayoo reports some DSP  modules
11:48:32 <Arnar> ksf: ok..
11:49:05 <elliottt> sproingie: there's a supercollider binding on hackage
11:49:08 <Arnar> ultimately, I want a simple program that I can play stuff in, place markers (and jump to them) and change the speed (with pitch correction)
11:49:43 <ksf> ...sounds like something I'd use jack for.
11:50:12 <ksf> that gives you timecode, i.e. seeking support, you just have to collect those markers and apply them as soon as you're told to produce a sample.
11:50:14 <elliottt> http://hackage.haskell.org/package/hsc3
11:50:52 <sproingie> you want a program to do it, i suggest an audio editing program
11:50:54 <ksf> you can prolly start out with a gui-less app that just takes a list of markers and does the processing.
11:50:57 <Arnar> csound looks like it could be fun to play with realtime effects
11:51:01 <sproingie> heck even audacity can do those things
11:51:05 <Arnar> ksf: gui-less is what I'm aiming for anyways
11:51:24 <Arnar> sproingie: I want to do it on the fly
11:51:26 <ksf> then you're going to love jack.
11:51:30 <sproingie> jack then
11:51:39 <ksf> it's the swiss army knife of gluing together audio apps
11:51:52 <Arnar> hmm ok..
11:52:12 <Arnar> commercial apps that do what I want include transcribe and capo (for os-x)
11:53:09 <Arnar> can slowing down/speeding up be done with something like jack? it must be the app that has the data that does so (i.e. can't do it with stream processors)
11:53:25 <pao> hmmm has anyone a suggestion to make Data.Map.intersection strict on the values?
11:53:57 <ksf> usual suspects for audio stuff on linux include ardour, muse, rosegarden, a hell a load of softsynth + ladspa effects and/or csound/supercollider, fluidsynth as wavesynth, and that postprocessing prog whose name I forgot.
11:54:44 <dikini> Arnar, you can't in jack, but there are ladspa plugins for that, just use one of the ladspa hosts
11:55:01 <Arnar> dikini: ah, thanks.. *looking into it*
11:57:35 <dikini> Arnar: jack is your patch rats nest, you reroute streams whichever way you fancy, and just do some processing in between, just named pipes for audio
11:57:58 <ClaudiusMaximus> Arnar: ecasound might be a useful engine for doing what you want, it has a control interface (don't know if there are haskell bindings, though)
11:58:14 <mistermatt> what does it mean for a function to be pure?
11:58:53 <Arnar> ClaudiusMaximus: thanks
11:59:07 <mistermatt> or rather, what does it mean when a function/code is impure
11:59:40 <ksf> mhh you _can_ of cousrse just cache some previous frames to base your current calculation on with jack, but that breaks erm "seeking transparency"
12:00:03 <Arnar> ksf: right..
12:00:04 <ksf> i.e. if you jump in the stream with the jack transport, you'd have to nuke your cache.
12:00:04 <pao> mistermatt: a function is pure when is referentially transparent, i.e. the output depends only on the input
12:00:42 <pao> mistermatt: to be referentially transparent a pure function cannot use state or "side effects" (i.e input/output vs the world)
12:00:54 <ksf> I guess ladspa does exactly that.
12:01:03 <pao> mistermatt: when a function in not referentially transparent is unpure
12:01:19 <Arnar> mistermatt: a pure function satisfies two conditions: 1. as pao said, its output depends only on the inputs, same inputs give same outputs every time and 2. the function does not cause any observable side effects, such as printing stuff on the screen etc
12:01:42 <ksf> letting the cpu run hot?
12:02:01 <ksf> a function doesn't become impure because it causes a tracer to print a line.
12:02:06 <Arnar> ksf: if it is observable :)
12:02:19 <mistermatt> okay, thanks guys
12:02:19 <ksf> it's the inside semantics of the program that matter, not its outside behaviour.
12:02:39 <Arnar> (audiowise) this look very cool: http://www.sonicvisualiser.org/
12:02:56 <Arnar> look like just what I need
12:03:12 <monochrom> Instead of arguing out whether debugging messages and power consumption constitute side effects, why don't you guys be polymorphic about side effects.
12:04:21 <mistermatt> I also just wrote my first recursive function in haskell, but I'm not sure if using the length function on a list was cheating or not
12:04:25 <Arnar> monochrom: what do you mean?
12:04:51 <data_jepp> I finally finished my task, a big thankyou to everyone!!!!
12:04:53 <Arnar> mistermatt: writing the length function is a nice little excercise if you want to make sure :)
12:05:24 <mistermatt> Arnar, actually I think I'll try to do that
12:05:54 <Arnar> mistermatt: good on you :) -- we are right here if you need any help
12:06:28 <mistermatt> I'm just really not used to thinking recursively at alkl
12:06:31 <mistermatt> all, rather
12:07:12 <ksf> every iteration is a recursion. there's a dead simple transformation scheme.
12:07:28 <monochrom> All pointless debates can be settled by going polymorphic.
12:07:38 <mistermatt> ksf, actually we'll be learning that in my discrete math class next week
12:07:43 <mistermatt> I think
12:07:51 <ksf> @remember <monochrom> All pointless debates can be settled by going polymorphic.
12:07:52 <lambdabot> I will remember.
12:07:58 <ksf> noone's going to get that one.
12:08:06 <monochrom> You need to remove < > manually.
12:08:14 <ksf> no I don't.
12:08:34 <monochrom> @quote debates
12:08:35 <lambdabot> Adamant says: Godwin's Law of Programming Debates: Hitler = ASM
12:08:42 <en0th> lmao.
12:09:05 <monochrom> @quote monochrom All
12:09:05 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:09:12 <ksf> my code isn't slow, your compiler is too dumb.
12:09:31 <monochrom> @quote <monochrom>
12:09:32 <lambdabot> <monochrom> says: All pointless debates can be settled by going polymorphic.
12:09:44 <monochrom> (Do you see the difference?)
12:09:49 <ksf> sure I do.
12:09:49 <en0th> my compiler actually goes into infinite loop.
12:10:13 <ksf> but I don't need to remove the angle brackets. you might want to like having them removed.
12:10:45 <ksf> er you might like having them removed.
12:11:02 <ksf> or you might want having them removed.
12:11:02 <ksf> composing those two doesn't really work out.
12:11:21 <mistermatt> jeez, netsplit
12:12:49 <sunrayser> umm nevermind, my client seems a bit confused
12:15:26 <Rotaerk> what naming convention do you use for your State monads?
12:15:31 <mistermatt> how am I supposed to keep track of a length when I only have a single parameter in my function
12:15:36 <Rotaerk> type ____ = State GameState
12:15:47 <ksf> mistermatt, tuples.
12:15:52 <ksf> or two parameters.
12:15:57 <Rotaerk> I've been using "Game" there, but I'm thinking maybe.. GameTransition or something
12:16:13 <monochrom> GameStateMonad
12:16:18 <ksf> a transition is a function GameState -> GameState
12:16:56 <Rotaerk> but a State monad is basically just that... a chain of state transitions
12:17:04 <Rotaerk> execution once you run it on some initial state
12:17:05 * ksf would call the monad after the game.
12:17:19 <Rotaerk> executed*
12:17:28 <ksf> e.g. blockLeft :: Tetris ()
12:18:45 <Rotaerk> hmm perhaps
12:18:47 <ilid> Rotaerk: i have a type called SSA and a monad for working with it called SSAM. does that help?
12:19:09 <ilid> GameM might be a little ugly i guess :(
12:19:50 <ksf> it's not called InputOutputMonad, either.
12:20:20 <monochrom> And because of that, IOArrow has to be called IOArrow, not IO.
12:20:26 <ksf> a type is a type is a type that might accidentally form a monad but it's a type not a monad.
12:21:06 <ksf> IO is a functor, too. do you want to call the type IOMonad or IOFunctor?
12:21:51 <Rotaerk> aren't all monads functors?
12:22:13 <ksf> ...instead of bikeshedding here, we should rather think of a way to combine at least functor/applicative/monad/arrow/indexed applicative/indexed monad into a sane typeclass hierarchy.
12:22:13 <monochrom> I concede about IO.
12:22:18 <ksf> all monads are monoids.
12:22:38 <Rotaerk> don't know what a monoid is yet, but any monad should be fmap-able
12:23:06 <ksf> a monoid is a warm, fuzzy thingie with an binary relation and an identity element.
12:23:06 <Cale> Yes, a monad is actually defined as a functor with certain natural transformations
12:23:11 <monochrom> In "type ____ = State GameState" there is nothing accidental about forming a monad. It is deliberately a monad.
12:23:38 <ksf> e.g. the natural numbers under + with identity 0, under * with identity 1, lists under ++ with identity [], etc.
12:23:40 <Rotaerk> monochrom, point being?
12:24:03 <ksf> type Tetris = State TetrisState
12:24:16 <monochrom> I'm answering ksf's "accidental" argument.
12:24:23 <ksf> type Tetris = WriterT [Char] (State TetrisState)
12:25:05 <ksf> still, a typename shouldn't contain the names of any class it implements. that's just confusing.
12:25:20 <ksf> you don't say IntegerReadNumShowEqOrd, either.
12:25:30 <Rotaerk> thing I don't like about that naming style is.. given x :: Tetris (), x isn't "a Tetris", it's "a Tetris action"
12:25:41 <ksf> yep.
12:25:56 <ksf> just like IO () isn't "an IO" but "an IO action"
12:26:01 <dv-> so, () means "action"
12:26:03 <Rotaerk> true
12:26:07 <jmcarthur_work> in my opinion, type aliases are for things that have obvious names, not merely for saving keystrokes
12:26:25 <jmcarthur_work> if there is no name more obvious than "State GameState," it probably doesn't need a type alias
12:26:37 <Rotaerk> jmcarthur_work, imo it's for centralizing type definitions
12:26:45 <ksf> I'd go for a newtype, anyway.
12:26:56 <ksf> it's a matter of encapsulation.
12:27:18 <ksf> ...I want to add another transformer to the stack without editing half of my code.
12:27:25 <jmcarthur_work> if it's a matter of abstraction it's another story
12:27:26 <Rotaerk> jmcarthur_work, i.e. if I changed from State GameState to WriterT [Char] (State GameState), I'd have to update all the expressions that explicitly use "State GameState"
12:27:37 <jmcarthur_work> but if the sole interface is State, i say just expose that
12:27:41 <Rotaerk> so a type definition would centralize that change
12:27:49 <jmcarthur_work> Rotaerk, that sounds like abstraction. newtype would be nicer, IMO
12:28:25 <Rotaerk> newtype is the same thing, just with the added consequence of being treated as a different type
12:28:31 * ksf goes for encapsulation quite eagerly.
12:28:37 <jmcarthur_work> Rotaerk, another alternative would be a MonadGame type class so that all your type annotations can be more generic
12:28:57 <jmcarthur_work> Rotaerk, it's not the same thing. a newtype allows you to control what is and is not exposed
12:29:05 <Rotaerk> ah
12:29:13 <Rotaerk> and what's this about a MonadGame class?
12:29:26 <ksf> it also makes for better inferred types.
12:29:28 <jmcarthur_work> Rotaerk, MonadGame as in the same sense as MonadState, MonadWriter, etc.
12:29:40 <Rotaerk> ah
12:29:43 <ksf> nothing beats having a type error with a 20-element transformer stack.
12:29:57 <Rotaerk> interesting
12:30:05 <ksf> Rotaerk, look at e.g. chp for an example.
12:30:09 <jmcarthur_work> Rotaerk, then you can have things like foo:: (MonadGame m, MonadWriter [Char] m) => a -> m b, etc.
12:30:12 <ksf> there's the CHP monad, and MonadCHP.
12:30:35 <ksf> ...because chp uses some sub-monads for specific functionality, e.g. sections that may fork threads.
12:30:36 <jmcarthur_work> Rotaerk, and it means you don't have to lift things all the time (with the exception of IO which is a weird case)
12:31:42 * ksf thinks a game monad shouldn't include IO.
12:31:51 * jmcarthur_work agrees with ksf
12:31:55 <ksf> ...you do one state pass, then render the state, then do another pass.
12:32:23 <ksf> you might want to have a Draw monad, though.
12:32:27 <sunrayser> what is the simplest way to return an IO() but do nothing? (I now have return(putstrln "") )
12:32:28 <Rotaerk> yea my current type is "type Game = StateT GameState IO" but I was trying to think of a way to change that
12:32:32 <jmcarthur_work> or at the worst have a Prompt monad at the bottom that communicates high level actions back up to the top
12:32:47 <Rotaerk> sunrayser, "return ()"
12:32:57 <jmcarthur_work> where "the top" means "the run function"
12:33:27 <sunrayser> Rotaerk: doesn't work: Couldn't match expected type `IO ()' against inferred type `()'
12:33:27 <jmcarthur_work> sunrayser, undefined
12:33:28 <jmcarthur_work> :P
12:33:55 <jmcarthur_work> sunrayser, sounds like you have nested IO monads?
12:33:56 <ksf> a game should _always_, _always_ have a function that looks like this: foo st = let st' update st in draw st' >> foo st'
12:34:11 <ksf> don't ever, ever, mix state updates with drawing.
12:34:33 <jmcarthur_work> ksf, not always. not if you are going for a more declarative approach. that "draw" action looks very imperative to me
12:34:40 <sunrayser> jmcarthur_work: well, I'm actually in an Interpreter monad
12:34:56 <ksf> ...that draw takes a description of a world and renders it.
12:35:04 <sunrayser> jmcarthur_work: so it's possible I actually need an Interpreter(IO())
12:35:18 <Rotaerk> jmcarthur_work, it's an IO action isn't it?
12:35:28 <jmcarthur_work> ksf, i get that. but "draw" is a verb
12:35:34 <Rotaerk> so it is "imperative"
12:35:41 <jmcarthur_work> Rotaerk, right
12:35:43 <edwardk_> @seen bos
12:35:43 <lambdabot> Unknown command, try @list
12:35:49 <edwardk_> preflex: seen bos
12:35:49 <preflex>  bos was last seen on #haskell 12 hours, 9 minutes and 49 seconds ago, saying: night, all
12:35:49 <jmcarthur_work> sunrayser, return (return ()) ?
12:35:51 <ksf> "update" is a verb, too.
12:35:55 <ksf> "show", also.
12:36:10 <jmcarthur_work> ksf, but those actually *return* new information
12:36:14 <bos> edwardk_: mrp?
12:36:16 <jmcarthur_work> "draw" changes world state
12:36:24 <sunrayser> jmcarthur_work: wow it works, thx
12:36:27 <ksf> no it returns a new world.
12:36:37 <edwardk_> bos: was following up on the instance of Data for Text thing
12:36:38 <jmcarthur_work> ksf, either way, it's imperative
12:36:50 <edwardk_> bos: it shouldn't be that hard to cobble one together. I've built a few the hard way.
12:36:51 <ksf> so is the fix update thingie.
12:36:56 <Rotaerk> ksf, a whole new world? :O
12:37:16 <jmcarthur_work> ksf, sometimes state makes sense, sometimes not.
12:37:17 <edwardk_> I'll see what I can do when I'm sitting in front of a Haskell compiler this evening ;)
12:37:23 <Rotaerk> a dazzling place I never knew?
12:37:27 <jmcarthur_work> ksf, traditionally, games are made in a stateful way
12:37:28 <Rotaerk> *cough* anyway
12:37:30 <bos> edwardk_: yeah, i can build *something*, i just want to feel happy about it instead of depressed.
12:37:32 <jmcarthur_work> ksf, but that isn't the only way
12:37:39 <jmcarthur_work> ksf, a "game state" needn't exist
12:37:49 <Rotaerk> jmcarthur_work, really?
12:37:54 <ksf> games are traditionally, and in the vast majority of cases most naturally expressed as finite automata.
12:37:56 <jmcarthur_work> ksf, a FRP approach would avoid that, for example
12:38:06 <Rotaerk> hmm
12:38:08 <edwardk_> bos: heh, the other trick is your Data instance should probably be fairly opaque like the one for Data.Set, etc.
12:38:34 <jmcarthur_work> one can describe the behavior of the game instead of describing its state changes
12:39:06 <bos> edwardk_: yeah, i'm not too clear on how to achieve that either.
12:39:06 <ksf> ...depending on its state.
12:39:12 <Rotaerk> foo st = let st' update st in draw st' >> foo st'  is also not desireable if you want to try to have two separate threads doing your rendering and updating
12:39:13 <jmcarthur_work> ksf, what state?
12:39:19 <Rotaerk> (though I've never done that... I hear it's hard)
12:39:20 <ksf> stateless games are _really_ rare. like some puzzles or such.
12:39:31 <bos> edwardk_: i mean, i see what the Data instance for Array does, but i don't see too clearly what its consequences are.
12:40:01 <jmcarthur_work> ksf, all games are stateless. we impose state on them
12:40:04 <edwardk_> well, you can derive Typeable at least. That is low hanging fruit ;)
12:40:13 <ksf> Rotaerk, do a par.
12:40:20 <ksf> update is pure, that's the whole point.
12:40:46 <jmcarthur_work> emulation of state in pure code does not make it stateless
12:40:57 <edwardk_> if you support gfoldl they'll be able to iterate over your contents generically. that is what matters.
12:41:09 <ksf> expressing state in terms of frp doesn't make it stateless, either.
12:41:14 <Rotaerk> how are all games stateless?
12:41:24 <edwardk_> the toConstr, gunfold, dataTypeOf and dataCast1 would allow them to violate your invariants though.
12:41:29 <jmcarthur_work> ksf, where is the state then?
12:41:32 <Rotaerk> take chess for example, how can that be done without state
12:41:35 <jmcarthur_work> "internally" doesn't count
12:42:01 <ksf> buttonState :: Behaviour Bool
12:42:35 <jmcarthur_work> ksf, looks immutable to me
12:42:40 <edwardk_> Rotaerk: i've done mutationless chess programming in haskell, it isn't terribly efficient, but it can be done ;)
12:42:53 <sshc> how can a complete fps game with ui be done without state?
12:42:55 <jmcarthur_work> ksf, where do i change the state of that button?
12:43:05 <edwardk_> sshc: look at Frag
12:43:09 <ksf> in some other IO action.
12:43:18 <ksf> that you execute before update.
12:43:21 <jmcarthur_work> ksf, IO action is not a part of FRP
12:43:33 <jmcarthur_work> IO action is FFI
12:43:34 <ksf> it's not part of update, either.
12:43:38 <Rotaerk> edwardk_, hmm.. how? do you build a lazily evaluated tree of all possible branches of the game
12:43:47 <Rotaerk> and then input simply selects which one to traverse
12:43:52 <jmcarthur_work> ksf, update gives me a new state. behaviors have no update function
12:43:58 <monochrom> Why does the mind have memory and invent state?
12:44:00 <sshc> edwardk_: it doesn't have any menus
12:44:02 <edwardk_> rotaerk: basically, you can actually do it very easily in the list monad.
12:44:12 <ksf> yeah. the fixed point is moved _into_ the function.
12:44:27 <ksf> ...which doesn't mean that there's no cyclic state passing going on.
12:44:36 <jmcarthur_work> ksf, *i* never touch it
12:44:48 <jmcarthur_work> ksf, pure code has a stateful implementation too, but we don't call it stateful
12:44:58 <edwardk_> Rotaerk: write a small monadic action that takes a board and computes a move. then 'binding' that computes the next move in the tree, so you can bind it several levels deep and evaluate. there is also a monad for iterative deepening based search.
12:45:13 <edwardk_> er sorry, takes a board, and computes a list of all possible moves.
12:46:11 <ksf> ...anyway, the discussion is moot, as reactive is in no way usable for any complex games, yet.
12:46:27 <mistermatt> whew I finally figured out how to write length
12:46:32 <Rotaerk> edwardk_, meh, that's really still stateful.  the state is just the one you're currently traversing at the point of input
12:46:38 <jmcarthur_work> ksf, likewise, a state monad might have a pure implementation, but that doesn't mean we should call it pure
12:46:46 <jmcarthur_work> only its run function is "pure"
12:46:49 <Baughn> ksf: (Or simple ones)
12:46:55 <edwardk_> Rotaerk: the list representation makes a lot of things very elegant, for instance, you can do full disambiguated move parsing just by building the list, and filtering it based on the notation provided, if you get one resulting board then you parsed the move.
12:46:59 <monochrom> Some chessmasters sometimes show off by playing 20 chess games against 20 opponents interleavingly. The best way to do it is to keep no memory, no state, in your mind. Re-evaluate every chess board for every move. Pure lazy functional.
12:46:59 <jmcarthur_work> ksf, implementation details are an aside to all this
12:47:01 <Astrobe> monochrom: because inferior beings like the ones found on earth are doomed to live in the illusion of time.
12:47:32 <ksf> so, by your definition, "pure" values are only those that have kind *?
12:47:37 <jmcarthur_work> ksf, no
12:47:40 <edwardk_> monochrom: my uncle used to do those demonstrations. that approach works unless you have to do it blindfolded, then you have to keep the narrative ;)
12:47:52 <jmcarthur_work> pure values are those which are referentially transparent
12:48:06 <ksf> ...applicatives are good, monads evil, and arrows a work of the devil?
12:48:24 <edwardk_> ksf: a fair assessment of current haskell community biases, yes.
12:48:35 <edwardk_> by that token monoids on the other hand, are incredibly sexy.
12:48:44 <ksf> I agree that most monads could use better typing. For example by using indexed ones. but they aren't _impure_.
12:48:46 <jmcarthur_work> ksf, no
12:48:55 <jmcarthur_work> monads are pure
12:49:06 <jmcarthur_work> some of the things you can make with them do not have pure interfaces, though
12:49:12 <jmcarthur_work> IO is a blaring example
12:49:17 <Rotaerk> IO values are pure, producing them has no side effects
12:49:21 <jmcarthur_work> State is similar
12:49:28 <ksf> IO could be better.
12:49:34 <edwardk_> ksf: monads are pure, they are just too powerful in that there are fewer of them than I would like. If you assert less, like with applicative of monoid, you can have more instances running around to play with
12:49:44 <ksf> ...e.g. using indexing to statically distinguish opened from closed handles.
12:49:51 <edwardk_> er with applicative or
12:50:19 <jmcarthur_work> Rotaerk, IO is not pure in the sense that you must worry about a stateful machine when you write code for it
12:50:24 <monochrom> Moral of my story: Maybe the real world has state, but smart people stay pure lazy functional and relegate state-keeping to inferior minions. :)
12:50:29 <jmcarthur_work> Rotaerk, this is why State is also stateful
12:50:42 <ksf> so you define impure as "is an automaton"?
12:50:54 <Rotaerk> yea true
12:50:59 <jmcarthur_work> ksf, you can also describe an automaton's behavior in a non-stateful way
12:51:00 <ksf> automata have very clean semantics.
12:51:17 <jmcarthur_work> ksf, but the interface we provide is what gives something its statefulness
12:51:18 <ksf> ...and that's the way I think about imperative stuff.
12:51:18 <sproingie> just not necessarily deterministic semantics
12:51:50 <monochrom> I love non-determinism
12:52:10 <sproingie> i (amb love hate) nondeterminism
12:52:23 <monochrom> Heh
12:52:26 <ksf> a crucial and undervalued element of game design.
12:52:57 <Rotaerk> determinism is better for some kinds of games
12:53:01 <jmcarthur_work> > ["I " ++ x ++ " nondeterminism" | x <- ["love", "hate"]]
12:53:02 <lambdabot>   ["I love nondeterminism","I hate nondeterminism"]
12:53:16 <ksf> puzzles, yes. anything remotely resembling physics, no.
12:53:32 <Rotaerk> for, say, turn based strategy games, it's preferable to be able to predict what will happen
12:53:38 <sproingie> physics is nondeterministic?
12:53:43 <ksf> it's fuzzy.
12:53:48 <jmcarthur_work> ksf, most physicists talk about physics in a declarative way
12:53:48 <Rotaerk> but for fast paced games, a bit of chaos is always good
12:53:52 <sproingie> ok i'll grant that
12:54:00 <jmcarthur_work> ksf, *we* are the ones that talk about "update functions"
12:54:04 <Rotaerk> or at least, less painful, since you don't have time to think
12:54:11 <ksf> the same collision shouldn't always yield the exact same result as you're not modelling everything a real system would have.
12:54:32 <sproingie> sure, but less actors should mean it's even more deterministic
12:54:37 <jmcarthur_work> ksf, so you are saying that we should have randomness because our model is not realistic?
12:54:42 <ksf> yep.
12:54:54 <ksf> imagine a shotgun always shooting its bullets in the same pattern.
12:55:02 <ksf> you do a random distribution to make it realistic.
12:55:12 <Rotaerk> if you don't represent all the rules, reduce them to a probability and make it stochastic
12:55:15 <jmcarthur_work> realism is a bit different from nondeterminism, though
12:55:21 <ksf> "random" is a very close approximation to the turbulences involved.
12:55:39 <Rotaerk> random but not an even distribution
12:55:40 <jmcarthur_work> it's close enough to fool people, is all that matters
12:55:44 <ksf> determinism is kept by saving random seeds
12:56:09 <ksf> ...so you can replay a game. but you won't be able to just record all mouse input and get the same result.
12:56:31 <jmcarthur_work> ksf, with the possible exception of graphics, i disagree
12:56:52 <jmcarthur_work> multiplayer, for example, is far simpler when the game is deterministic
12:56:59 <sproingie> the shot pattern of a shotgun in a game isn't going to be simulated with physics
12:57:07 <jmcarthur_work> right
12:57:08 <en0th> the key point is that latest advances in physics show that the real world seems to be ineherently non-deterministic
12:57:13 <ksf> all have the same random seed. it's replicable.
12:57:18 <jmcarthur_work> en0th, that is a theory...
12:57:25 <Rotaerk> determinism isn't feasible over networked multiplayer games
12:57:33 <ksf> that, too.
12:57:37 <Baughn> en0th: How's that? Every law I'm aware of is fully deterministic
12:57:39 <Rotaerk> due to latency resulting in paradoxes that need to be resolved
12:57:47 <sproingie> anything you do simulate with physics is still pretty deterministic, it's just the inputs that vary randomly
12:57:50 <ksf> ...but that doesn't concern shotgun patterns, that much.
12:57:59 <en0th> take quantum mechanics
12:58:11 <Baughn> Yes..?
12:58:27 <sproingie> n-body collisions are a tricky problem
12:58:28 <jmcarthur_work> ksf, you seem to only be saying that you should have different inputs to the game every time, not that you should have a different outcome for the same inputs every time
12:58:59 <ksf> hell if there'd be two exactly equal physical state that would imply a looping universe.
12:59:11 <sproingie> who's to say it isn't
12:59:14 <Baughn> ksf: Sure, that seems inevitable
12:59:15 <sproingie> who's to say it isn't
12:59:16 <en0th> qm is settled over non determinism
12:59:21 <ksf> jmcarthur_work, yep.
12:59:36 <ksf> it's not a big practical difference, though.
12:59:42 <Baughn> en0th: No, you're thinking of the collapse hypothesis. If you remove wavefunction collapse from the model, it's fully deterministic.
12:59:47 <jmcarthur_work> well, i wouldn't call it nondeterminism though
13:00:01 <sproingie> .oO( "there is the theory of the moebius.  a twist in the fabric of space, where time becomes a loop.  from which there is no escape" )
13:00:01 <ksf> ...you could unsafeInterleaveIO true randomness or use a prng, it just matters for replicablity.
13:00:09 <sproingie> great Orbital track
13:00:21 <ksf> ...the degree of jitter in the results has to be accounted for in other ways.
13:00:31 <ksf> e.g. your shotgun should'nt shoot backwards.
13:01:05 <SamB_XP> ksf: or at least not often!
13:01:09 <SamB_XP> but it might be funny if it did sometimes
13:01:24 <jmcarthur_work> it should do something funky if it gets clogged with mud
13:13:24 <ksf> when shotGunShoots $ if (somethingFunky shotgun) then newProjectiles Backward else newProjectivels Forward
13:13:32 <ksf> see, you did a state-based thingie.
13:13:43 <Baughn> Don't forget the foot-shooting option
13:14:43 <SimonRC> I wrote a primitive library for infinite heaps of Data.Stream.Streams...
13:14:52 <SimonRC> would such a thing be a useful addition to the library?
13:15:22 <ksf> what's "the library"?
13:16:04 <ksf> if you mean hackage, certainly. if you mean the base libs, you're in the wrong lobby.
13:16:54 <SimonRC> oops, I did mean hackage
13:17:23 <SimonRC> how much work is maintainting a hackage package?
13:17:36 <ksf> don't worry, just add. we're going to have a reddit-like voting thingie any time soon, anyway.
13:17:53 <ksf> depends on how much bugs your program has and how much support you give.
13:18:07 <Baughn> SimonRC: Make it work, make a .cabal, run cabal-upload
13:18:18 <meese> how do I delete all occurrences of an element from a list in haskell?
13:18:19 <jmcarthur_work> i hope it's a rating thing and not a voting thing
13:18:24 <Baughn> meese: filter
13:18:26 <ksf> ...every two years, fix a backwards incompability.
13:18:31 <jmcarthur_work> votes are overrated
13:18:57 <ksf> rating is overrated. different number of stars mean different things for different people.
13:19:23 <meese> Baughn: oh, right. thanks
13:19:57 <jmcarthur_work> but good libraries that aren't well-known can get good ratings, but not many votes
13:20:16 <lament> ksf: so by 'overrated' you mean like, rating is four and a half stars when it should be at most three and a half?
13:20:33 <ksf> yep.
13:21:28 <meese> Baughn: so something like this? deleteAll e lst = filter p lst where p x = (x /= e)
13:21:53 <ksf> I think different topics to vote for are a better way to do things. vote up/down for doc quality, I use it, code quality, usefulness, best-of-its-kind, etc.
13:22:06 <Baughn> meese: Sure
13:22:18 <lament> ksf: usefulness obviously means the same thing to everybody.
13:22:22 <jmcarthur_work> ksf, a "good/bad" vote is a rating
13:22:24 <SimonRC> Baughn: of those three steps, I think "make it work" is the biggest
13:22:32 <Baughn> meese: deleteAll x = filter (/= x)
13:22:43 <Baughn> SimonRC: Right, and you'd need that regardless of hackage
13:22:57 <SimonRC> I have only the functions needed for he primes-finding program
13:22:58 <meese> Baughn: whoa, that's cool. thanks.
13:23:29 <ksf> well let's make that "completed feature creeping" and "design of interface"
13:23:49 <ksf> "simple but easily extendable"
13:24:12 <SimonRC> I didn't like the programs that inserted infinite streams of composites into maps, so I wrote the infinite stream heap to be an efficient way to merge them
13:24:23 <ksf> ...some metrics that make it easy to contrast a bunch of packages solving similar problems.
13:25:11 <ksf> and, of course, "I think this comment is helpful"
13:31:44 <jvoorhis_> i have a funny strictness question pertaining to ghc and wondered if somebody could answer it
13:32:12 <jvoorhis_> if i modify this expression:
13:32:14 <jvoorhis_> > let ones = 1 : ones in take 10 ones
13:32:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
13:32:20 <jvoorhis_> so it reads like this
13:32:39 <jvoorhis_> let ones = (1:) $! ones in take 10 ones
13:32:49 <jvoorhis_> then ghc just hangs until i interrupt it
13:33:07 <jvoorhis_> but what surprises me is that ghci's CPU stays at 0%, with no memory growth
13:33:56 <jvoorhis_> does the compiler just detect this sort of thing, or is there something else to it?
13:35:16 <ddarius> jvoorhis: It does detect it, but it should just give you an exception.  However, for the threaded run-time it would block in this case (which should also produce an exception for a compiled program)
13:36:32 <ddarius> There's no reason for there to be memory growth in any case, but 0% CPU suggests the blocked situation.
13:37:55 <jvoorhis> thanks; i haven't tried compiling that guy yet, but it makes sense for ghc to avoid spinning on non-IO things whose value is obviously _|_
13:38:03 <jvoorhis> i just didn't realize it was that smart :)
13:39:30 <dolio> I was under the impression that it silently blocks whenever various signal handlers are modified, as well, which is the case in ghci.
13:40:59 <ddarius> What happens is GHC marks the thunk as a "blackhole" thunk when entering it.  If a blackhole thunk is entered then in the non-threaded case, then it must be the expression under evaluation try to evaluate itself which is a circular dependency and throws a blackhole exception.  In the threaded case, it may just mean one thread started evaluating it before you got there, in which case you block until its done to avoid duplica
13:40:59 <ddarius> te work.
13:41:48 <ddarius> You should get an exception if all threads are blocked, though that should never happen due to blackholing.
13:43:10 <jvoorhis> so if a thread is evaling a blackhole thunk, is an asyncrhonous exception the only way to wake it up?
13:43:46 <ksf> you won't be able to wake up a thread that evaled a blackholed thunk, as it won't be alive afterwards.
13:44:05 <ksf> a blackhole thunk looks like this: throw NonTermination
13:44:21 <ksf> @src NonTermination
13:44:21 <lambdabot> Source not found. My mind is going. I can feel it.
13:44:44 <ksf> ...well, it's just a data constructor with a show instance that says <<loop>>
13:44:57 <jvoorhis> i've seen that before :)
13:45:21 <edwardk_> to be pedantic, the blackholing may be saved up until GC time at which point when unwinding the stack it just blackholes the stuff indicated, unless the eager blackholing flag is on, IIRC.
13:53:20 <dons> yo yo what's up y'all
13:53:20 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:53:51 * dons is in #haskell, somewhere over eastern oregon, 35k feet high
13:54:28 <monochrom> One of those IRC-while-flying people again.
13:54:35 <SamB_XP> dons: huh ?
13:54:53 <SamB_XP> why are you in the air ?
13:54:55 <monochrom> Next year someone will be IRCing while on the ISS.
13:54:58 <Heffalump> dons: apparently, you are up.
13:54:59 <ziman> > 35000* 0.3048
13:55:00 <lambdabot>   10668.0
13:55:18 <SamB_XP> monochrom: that's a planned event ?
13:55:44 <dons> all the lambdas look like ants
13:55:53 <monochrom> And the year after next, a Chinese astronaut will be chatting with us from the moon.
13:55:56 <SamB_XP> dons: those *are* ants
13:56:16 <ziman> i hope you're not texting while driving ;)
13:56:17 <SamB_XP> monochrom: they're getting deported ?
13:56:32 <SamB_XP> ziman: texting while piloting a plane is considerably safer
13:56:49 <monochrom> And lambdabot will be rovering on Mars.
13:56:58 <SamB_XP> monochrom: no, she won't
13:57:01 <SamB_XP> she'd crash the rover
13:57:11 <SamB_XP> and Cale would be unavailable to restart her!
13:57:18 <monochrom> "Functional programmers on Mars are so HOT!"
13:57:39 <monochrom> "Functional programmers on Mars are so HOT!  mu-eval: parse error"
14:00:05 <kakeman> :o
14:32:01 <shazam> hello, could we remove the 2 year nickban on "palomer" ? the person in question is very sorry he caused trouble
14:32:24 <dons> very unlikely.
14:32:31 * MyCatVerbs blinks.
14:32:35 <MyCatVerbs> Two years? oO
14:32:49 <dons> you'll just have to use a different nick, palomer
14:32:50 <SamB_XP> unlikely he's sorry, or unlikely we could remove it, or unlikely he was banned ?
14:33:11 <SamB_XP> I vaguely remember there having been such a nick
14:33:17 <SamB_XP> I don't remember anything about it's bearer
14:33:58 <MyCatVerbs> My logfiles say... 2008?
14:34:04 <MyCatVerbs> Like, January.
14:34:07 <SamB_XP> and it really seems all our bans should be expired at least every two years ...
14:34:36 <sproingie> @palomer
14:34:36 <lambdabot> Pfft
14:34:40 <MyCatVerbs> Oh huh weird.
14:34:43 <sproingie> huh
14:34:46 <sproingie> @palomer
14:34:46 <lambdabot> I have news for you, it's pointless
14:34:57 <MyCatVerbs> \bot has an @palomer command. Part of the 'quote' module.
14:35:13 <jvoorhis> @palomer
14:35:14 <lambdabot> Blargh!
14:35:16 <shazam> my quotes, they're quite amusing sometimes
14:35:17 <shazam> @palomer
14:35:18 <lambdabot> Category theory is the Paris Hilton of mathematics
14:35:24 <MyCatVerbs> WTF
14:35:28 <shazam> classic
14:35:38 <MyCatVerbs> 2008-02-01:23:36 -!- mode/#haskell [-bb *!n=palomer@* palomer!*@*] by Cale
14:35:47 <MyCatVerbs> 2008-02-02:18:43 -!- mode/#haskell [+b *!n=palomer@*] by ChanServ
14:35:59 <MyCatVerbs> This pattern crops up like three or four times in my logfiles.
14:36:01 <medfly> it's still 2009 isn't it
14:36:06 <MyCatVerbs> It is indeed 2009.
14:36:10 <sproingie> it is?
14:36:13 <MyCatVerbs> Er, last I checked.
14:36:15 <sproingie> damn i'm late
14:36:20 <SamB_XP> since when does Category Theory own the Hilbert ?
14:36:23 <medfly> come back in 2010!
14:36:50 <SamB_XP> shazam: hmm?
14:38:39 <shazam> SamB_XP, err, I wasn't referring to hotel ownership
14:39:01 <monochrom> That is why it's so funny. No one knows what it means.
14:39:07 <SamB_XP> hehehe
14:39:37 <SamB_XP> the Hilbert is, like, the only hotel in maths, right?
14:39:58 <hackagebot> stb-truetype 0.1.2 - A wrapper around Sean Barrett's TrueType rasterizer library. (BalazsKomuves)
14:40:58 <hackagebot> combinat 0.2.4 - Generation of various combinatorial objects. (BalazsKomuves)
14:43:02 <hackagebot> vacuum-opengl 0.0.1 - Visualize live Haskell data structures using vacuum, graphviz and OpenGL. (BalazsKomuves)
14:43:46 <shazam> @palomer
14:43:47 <lambdabot> They're telling you lies!
14:46:10 <sunfun> hi all, if i use svcadm enable <service>, on reboot that service will start during startup?
14:46:20 <sunfun> ops sorry
14:46:26 <sunfun> wrong channel
14:47:28 <monochrom> heh
14:48:13 <mistermatt> Man, real world haskell got all confusing on me in chapter 3
14:48:57 <Caseus> waer*
14:49:03 <Caseus> ...totally wrong window
14:49:04 <Caseus> Don't mind me.
14:50:23 <monochrom> If it is because of the English meaning of "data", ignore English meaning. "data" and "type" are keywords not taking on their English meanings.
14:50:54 <mistermatt> it's just a lot at once I think
14:51:11 <sproingie> it does start to pick up some speed in chapter 3
14:51:15 <monochrom> Then slow down. Spend one hour per 10 lines.
14:51:20 <sproingie> where are you stuck?
14:51:31 <SamB_XP> monochrom: that's definitely true when they are set in fixed-width among mainly proportional text
14:51:51 <Gracenotes> @pl \a b c -> c
14:51:51 <lambdabot> const (const id)
14:52:02 <Gracenotes> :o
14:52:02 <Warrigal> Wrong channel!
14:52:09 <Warrigal> Oops, I meant to type that into another tab.
14:52:13 <mistermatt> the introduction of parameterized types, and recursive types
14:52:22 <shazam> emacs totally screws up indentation when editing a happy file (test.y), is there a happy mode or something?
14:53:15 <sproingie> yeah it probably should have spent a little more time on parameterized types
14:53:27 <mistermatt> It's like, a page
14:53:31 <sproingie> yep
14:53:34 <monochrom> SamB_XP: The problem is lots of mainstream languages have trained lots of programmers to take daily English meanings seriously.
14:53:44 <sproingie> mistermatt: are you familiar with C++ templates or Java generics?
14:54:16 <mistermatt> I did a little C++ in school, but we never got far into the STL
14:54:17 <SamB_XP> monochrom: in proportional text in a book, that is a fairly sensible thing to do ...
14:54:36 <SamB_XP> if you s/daily english/daily technical english/
14:55:20 <monochrom> But I mean keywords in code.
14:55:43 <SamB_XP> ah, sure
14:55:47 <mistermatt> I'll probably re read the chapter after I'm done with it and then try to do the practice problems
14:55:50 <SamB_XP> certainly there you shouldn't assume that ;-P
14:57:09 <sproingie> learnyouahaskell spills some more words on the subject, but not terribly coherently
14:58:24 <monochrom> I have seen several beginners showing their confusion in #haskell due to sticking on "type". They expect "type" to mean defining user types.
14:58:27 <SamB_XP> shazam: I generally just use haskell-mode for happy files
14:58:38 <mistermatt> yeah I noticed that they seem to be missing something between the end of part 3, and 4
14:58:41 * dolio blames ML.
14:58:54 <SamB_XP> dolio: that's silly
14:59:04 <SamB_XP> most of these people haven't used ML!
14:59:05 <dolio> Your mom is silly.
14:59:14 <SamB_XP> sometimes, yes, but that's hardly relevant
14:59:19 <dolio> Heh.
14:59:22 <SamB_XP> she's not even home right now!
14:59:31 <mistermatt> monochrome, I'm also not used to this kind of abstraction
14:59:41 <mistermatt> it's just different
14:59:46 <SamB_XP> I myself enjoy being silly quite often
15:00:00 <monochrom> Anyway, the point of Real World Haskell being text as opposed to video is that you can mull over one single line for days, unlike videos.
15:00:40 <SamB_XP> monochrom: I thought it was so you could read it on the bus
15:00:49 <mjrosenb> dolio: wait, what are you blaming on ml now?
15:00:50 <SamB_XP> or use it at school without headphones
15:01:08 <SamB_XP> mjrosenb: people expecting "type" to be for user-defined types
15:01:12 <monochrom> Both. Mull over it on the bus for days.
15:01:14 <dolio> mjrosenb: That people thing 'type' is for defining new types.
15:01:16 <SamB_XP> not just aliases
15:01:23 <dolio> Think, even.
15:01:23 <SamB_XP> monochrom: that, you can't do so well
15:01:30 <sproingie> i don't think most people who are confused by it in haskell didn't start with ml
15:01:35 <SamB_XP> they generally kick you off after a round trip at most
15:01:40 <mjrosenb> in sml, type creates aliases
15:01:46 <tamiko> monochrom: To mull over a single line for days is not that satisfying :)
15:01:47 <SamB_XP> sproingie: that's just what I said ;-P
15:01:56 * mjrosenb knows not about ocaml
15:01:59 <monochrom> The tricky bit is to not get other people think you're a homeless begger.
15:02:20 <Gracenotes> hm.. I wonder if one could make :reload replace the current modules only /after/ it is successful.
15:02:53 <sproingie> i think playing with it interactively is the best idea
15:02:55 <Gracenotes> as to avoid the annoying situation, where :t information is very useful but unreachable due to being reduced to the Prelude
15:03:00 <dolio> Oh, I guess I must be thinking of OCaml.
15:03:06 <sproingie> Just 123 :: Maybe Int
15:03:15 <sproingie> Just "hello" :: Maybe [Char]
15:03:15 <SamB_XP> monochrom: I suppose you *might* be able to pull it off if you get a different driver every time and pretend you got on the bus going the wrong way ...
15:03:27 <SamB_XP> but you'd have to keep switching busses
15:03:38 <Gracenotes> the functions I'm dealing with are super-ugly reduced to one line
15:03:39 <dolio> That's a difference between the two that wikipedia doesn't mention.
15:03:39 <sproingie> :t Just Just Just Just Nothing
15:03:40 <lambdabot>     Couldn't match expected type `(a -> Maybe a)
15:03:40 <lambdabot>                                   -> (a1 -> Maybe a1)
15:03:40 <lambdabot>                                   -> Maybe a2
15:03:50 <sproingie> darg.  parens
15:04:16 <Samy> :t Just "hello"
15:04:17 <lambdabot> Maybe [Char]
15:04:28 <Samy> :t Just 123
15:04:29 <lambdabot> forall t. (Num t) => Maybe t
15:04:44 <Gracenotes> how hard would it be to do define :reload this way? unless, of course, the module-reloading code is somewhat mutable, with an IOVar or something
15:05:20 <SamB_XP> Gracenotes: I haven't the slightest idea how hard it would be to implement that
15:06:03 <monochrom> "I want a tree of Int's." "I want a tree of Bool's." "I want a tree of ByteString's." ... After a while you will want to parameterize. After a long while. You have to have written 10,000 tree boilerplates, one for each "key" type, before you want the generalization so much you think it's an obvious next step.
15:06:34 <Gracenotes> hm, one way to hack around it: define a fake :reload that copies a module to a single file when it successfully compiles, falling back on the copy when the main one is unsuccessful
15:06:52 <monochrom> Ability to abstract comes from having done enough concrete cases to get bored.
15:06:54 <Gracenotes> for single-module .hs loading
15:07:44 <SamB_XP> monochrom: I get bored way easier than that!
15:07:46 <SamB_XP> yay ADD!
15:08:12 <monochrom> Then ADD gives you a competitive edge.
15:08:33 <SamB_XP> do you suppose that's why it's so popular lately?
15:09:05 <monochrom> It is now slowly being recognized that some autism-related traits help programming and related activities eg abstract math.
15:09:11 <Gracenotes> don't write 10,000 tree boilerplates yourself -- make the compiler write 10,000 tree boilerplates!
15:09:22 <ksf> http://www.reddit.com/r/haskell/comments/9ski4/a_more_approachable_approach_to_category_theory/
15:09:23 <beanmachine> what would be *really* cool is if when one function failed to typecheck the functions that didn't depend on it loaded anyway
15:09:28 <Gracenotes> hello thar, C++ and parametrized modules in ML
15:09:51 <SamB_XP> Gracenotes: the latter is a good deal saner ...
15:10:07 <Gracenotes> that is true.
15:10:19 <SamB_XP> has some nice things like typechecking
15:10:53 <Gracenotes> typed-LC-based systems go a long way
15:11:29 <mistermatt> bleh
15:11:39 <Gracenotes> well, so occasionally do type systems like C++'s, if by "long way" you mean "off a cliff"
15:11:42 * SamB_XP is referring to the way that C++ template arguments don't really have types
15:12:17 <ksf> we don't have proper kinds, either.
15:12:21 <mistermatt> I think why the parameterized types page is confusing is because of the sue of Maybe
15:12:23 <mistermatt> use
15:12:31 <ksf> ...at least c++ has type-level integers.
15:12:32 <sproingie> Maybe is probably the simplest parameterized type
15:12:38 <ksf> (am I defending c++?)
15:12:49 <ksf> (maybe I should get a lobotomy)
15:12:54 <mrsolo_> hmm System.Console.Readline is gone? in ghc 6.10.4?
15:12:55 <sproingie> it might help if book had you build up your own Maybe type from first principles tho
15:13:04 <SamB_XP> ksf: hehe
15:13:05 <mrsolo_> use System.console.Editline.Readline from now on?
15:13:09 <monochrom> Tangentially, this is also why OOP is hard to teach. 1st-year students haven't experienced enough repetitive coding to see the need to abstract. They see it as cost not revenue.
15:13:28 <sproingie> monochrom: i don't think abstraction has to be taught as a refactoring method alone
15:13:47 <mrsolo_> ah gpl issue..
15:14:02 <SamB_XP> monochrom: yeah, multiple functions/procedures/whatever are hard enough to teach!
15:14:15 <sproingie> we're pretty good at learning abstractions then applying them to instances as we see them
15:14:17 * ksf would say that oop-style abstraction doesn't scale well enough.
15:14:18 * mistermatt starts chapter over
15:14:34 <SamB_XP> sproingie: well, they have to be motivated somehow!
15:14:38 <ksf> no first-year student would complain to abstract foldr (+) 0 to sum
15:14:41 <monochrom> I believe in Piaget's theory and I believe in going from concrete to abstract, from a million concrete examples to one abstraction. I also believe a bit in "you could have invented it yourself" as a very persuading tutorial.
15:14:46 <sproingie> mistermatt: you know how functions can be polymorphic, right?
15:14:47 <benmachine> :t foldr (maybe id (:)) []
15:14:48 <lambdabot> forall a. [Maybe a] -> [a]
15:15:09 <mistermatt> sproingie, meaning they are generalized to accept multiple types?
15:15:11 <mistermatt> I think?
15:15:14 <sproingie> piaget isn't wrong, i just don't think it's the whole story
15:15:23 <ksf> erm well that's not abstractions, it's encapsulation by concretizising.
15:15:37 <SamB_XP> sproingie: well, what do you figure he's missing ?
15:15:40 <sproingie> mistermatt: yeah basically.  like let's say you have a function that returns the same value twice, in a tuple
15:15:44 <ksf> but foldr is a good example. loops are all over the place. maps, too.
15:15:55 <sproingie> mistermatt: twice x = (x,x)
15:16:39 <sproingie> mistermatt: see how that's polymorphic?  works on anything.
15:16:47 <sproingie> , let twice x = (x,x) in twice "foo"
15:16:51 <lunabot>  ("foo","foo")
15:16:56 <sproingie> , let twice x = (x,x) in twice 123
15:16:57 <lunabot>  (123,123)
15:17:06 <SamB_XP> ksf: well, I was figuring how it can be hard to convince them not to just stick everything in main()
15:17:29 <mistermatt> right
15:17:32 * ddarius would say OOP style abstraction doesn't scale -down- well enough.
15:17:39 <ksf> , let twice x = (x, x) in twice (twice 1)
15:17:40 <lunabot>  ((1,1),(1,1))
15:18:09 <ksf> _that's_ polymorphism. the other one was just type inference.
15:18:17 <sproingie> mistermatt: that's called parametric polymorphism.  types can be the same way
15:18:53 <ddarius> SamB_XP: Just let them keep writing it their own way...
15:19:05 <ksf> ...by giving them a task that messes up their brain if they don't encapsulate.
15:19:29 <sproingie> mistermatt: notice how all the types before in that chapter didn't have any args.  you had Book, you had BillingInfo, and so on, but on the left side of the =, no parameters
15:19:32 <ksf> it really doesn't make sense to split your program into three procedures that you subsequentially call in sequence, each once.
15:19:56 * ddarius makes procedures that are used one time all the time.
15:19:59 <sproingie> data BookInfo = Book Int String [String]
15:20:04 <sproingie> see, no parameters
15:20:18 <sproingie> for BookInfo that is
15:20:28 <mistermatt> right
15:20:43 <SamB_XP> ksf: well, it can
15:21:00 <SamB_XP> if it makes Linus happy, it's worth it
15:21:14 <mistermatt> meaning those are not polymorphic
15:21:19 <ksf> In C, I always made a point out of that by using one big function with multiple anonymous blocks inside.
15:21:24 <ksf> ...to declare private variables.
15:22:12 <ksf> you can change them to loops, which becomes more involved, but is still manageable.
15:22:18 <sproingie> mistermatt: right, they're not parametric.  you can have all sorts of books with different data, but there's only one BookInfo type
15:22:19 <SamB_XP> ksf: if you want to see what I mean, read the coding style document in the Linux source tree
15:22:35 <ksf> use really complex loops, and people use functions without you telling them to.
15:22:38 <SamB_XP> way better read than the GNU coding style document ;-)
15:22:58 <mistermatt> sproingie, I'm starting to see what you're saying
15:23:15 <sproingie> mistermatt: now let's say you had a different type of BookInfo that could take a string for the stock id (what we're using the Int for right now)
15:23:29 <sproingie> mistermatt: you'd have to create a whole new BookInfo type
15:23:29 <ksf> ...they will see that it's sensible to have a function called "nextIndex" if they a) got to use it more than once and b) it spans at least four lines.
15:23:47 <sproingie> data BookInfo2 = Book2 String String [String]
15:23:55 <SamB_XP> it's always saying stuff like "if you keep running up against the 80-column margin with 8-space indentation, your function is too complicated!"
15:24:24 <ddarius> Bah, just give beginners a language that doesn't even have procedures or supports the call/return pattern and they will appreciate procedures when they come.
15:24:25 <SamB_XP> "if you need to declare variables in mid-function, your function is too complicated!"
15:24:39 <sproingie> mistermatt: instead of having to do that, you figure, why not create a type where i can tell it what type i'm going to use in the data constructor.
15:24:42 <SamB_XP> ddarius: then how will they *do* anything ?
15:24:44 <ksf> ha! the didactic revenge of the goto.
15:24:46 <ksf> I like that.
15:24:49 <ddarius> SamB_XP: goto
15:24:55 <ksf> ...we should use continuations instead of gotos, though.
15:24:55 <sproingie> mistermatt: data MyBook a = a String [String]
15:25:08 <SamB_XP> of course, people love :to in LOGO because it lets them define commands to make shapes on the screen ;-)
15:25:18 <monochrom> I went through that. I had BASIC first. Then went to college doing Pascal and I was so happy.
15:25:19 <SamB_XP> or do I mean TO
15:25:25 * ddarius started off writing QBASIC using only goto.
15:25:26 <SamB_XP> oh, yeah, :TO quotes it or something
15:25:32 * ksf hated pascal for the lack of goto.
15:25:45 <SamB_XP> I just wish LOGO used LISP syntax
15:25:48 <sproingie> mistermatt: now that type probably isn't a great idea, since you don't want just anything to be used as an id, but you could do it that way
15:25:50 <ksf> using a gazillion additional booleans just to prevent a break is utterly pointless.
15:25:51 <SamB_XP> would make it easier to understand ;-P
15:26:26 <ksf> there's no single code construct that obfuscates code. it's always the programmer's (or reader's) mind.
15:26:42 <SamB_XP> I wish I could remember the difference betwene "X and :X in logo :-(
15:26:55 <SamB_XP> ksf: or a goto
15:27:02 <ksf> ...under j2me, I used for(;;) switch x {...} to emulate gotos.
15:27:03 <ddarius> @google difference between "TO and :TO in logo
15:27:04 <sproingie> mistermatt: as for the Maybe type, that one is actually a good idea :)  think of it as being the type of an optional value.  so a "Maybe something" is either something or nothing
15:27:04 <lambdabot> No Result Found.
15:27:16 <sproingie> mistermatt: with me so var?
15:27:20 <SamB_XP> ddarius: that's not even valid google syntax ...
15:27:21 <sproingie> so far
15:27:25 <mistermatt> yeah
15:27:36 <ksf> ...sometimes, it's just the bleeding most obvious and cleanest way to do things.
15:27:42 <ksf> use sparingly and wisely.
15:27:49 <sproingie> mistermatt: so instead of using the really terse 'a', you could define Maybe like this:
15:27:50 <SamB_XP> ksf: yeah, I tend to wish Python had it
15:27:54 <ksf> but outlawing it is fascism.
15:27:57 <sproingie> mistermatt: data Maybe something = Just something | Nothing
15:28:14 <SamB_XP> at least Lisp has a way to escape several constructs at once, even if it doesn't have GOTO per se
15:28:15 <monochrom> I think goto is a minor point and gosub is a major point. gosub doesn't take parameters and doesn't return values. very limiting. when moving to pascal, the happiest thing is procedure call for real. and then recursion naturally, too.
15:28:24 <sproingie> mistermatt: or better yet, since osmething is a type:
15:28:28 <ksf> Haskell has Maybe.
15:28:34 <sproingie> mistermatt: data Maybe sometype = Just sometype | Nothing
15:28:36 <SamB_XP> monochrom: who was talking about BASIC?
15:28:44 <monochrom> I was talking about BASIC.
15:28:47 <sproingie> yah i shouldn't use Maybe
15:28:57 <ksf> monochrom, that's true.
15:29:11 <mistermatt> sproingie, I think I'm understanding it a lot more now.
15:29:14 <sproingie> data Optional a = Only foo | Nada
15:29:19 <sproingie> argh
15:29:21 <SamB_XP> well, yeah, I hate how GOSUB doesn't do any scopy or parametery stuff in basic basic
15:29:22 <sproingie> data Optional a = Only a | Nada
15:29:27 <ksf> while coding in nasm, I had my procedure call macros (with the original c calling convention) and a simple if/then/else construct.
15:29:30 <SamB_XP> thankfully qbasic/quickbasic outgrew this ;-)
15:29:39 <ksf> ...I still did loops explititely.
15:29:46 <monochrom> I was pre-qbasic. More like applesoft basic.
15:29:49 <sproingie> mistermatt: play around with Maybe in ghci.  a lot.  a whole lot.
15:29:57 <mistermatt> I'll probably try to power through the chapter, and then go back and read it slower
15:30:08 <sproingie> mistermatt: because Maybe is all over Haskell, and it'll come back in more advanced places (like monads)
15:30:08 <mistermatt> while playing around with ghci
15:30:10 <dolio> data Picard a = MakeItSo a | BelayThat
15:30:12 <SamB_XP> not saying I actually got anywhere in qbasic back in the day or anything
15:30:29 <SamB_XP> I got way more out of reading than out of actual programming in those days
15:30:51 <mistermatt> will do, thank you sproingie
15:30:57 <SamB_XP> I guess the languages available just weren't good enough for me ;-P
15:31:06 <SamB_XP> or maybe I was just too young, I dunno
15:31:12 <ddarius> I like the noton in "Structured programing with go to statements"
15:31:21 <ddarius> s/noton/notation/
15:31:25 <ksf> the first programming I did was doing a config.sys startup menu wich did tell the autoexec.bat what app to start.
15:31:48 <ksf> ...so my parents were able to write their stuff without typing "word"
15:31:56 <sproingie> mistermatt: that chapter gets pretty dense
15:32:23 <mistermatt> yeah I'll have to take it section by section
15:32:29 <ksf> back in the days, these things were actually _documented_ on _dead wood_
15:33:05 <ksf> you could slay a cat with those manuals.
15:33:13 <SamB_XP> ksf: seriously ?
15:33:24 <SamB_XP> I don't know that we had any in quite that format
15:33:25 <ksf> nowadays you get a piece of paper that's not even sufficient to swat a fly.
15:33:58 <ksf> well I didn't say that the cat won't have a chance to hurt you.
15:34:00 <monochrom> At least the piece of paper doesn't self-destruct yet.
15:34:00 <SamB_XP> but, the C64 Programmer's Manual is the bestest computer manual in the world ...
15:34:11 <ksf> but 1kg of paper, moved fast enough should be enough.
15:34:14 <SamB_XP> monochrom: what difference would it make ?
15:34:24 <narens> hello. I've been trying to use Data.Tree. I can't seem to figure out how to add subtrees once it has been constructed.
15:34:30 <mistermatt> I know that I do get cought up a lot on syntax
15:34:32 <mistermatt> when I
15:34:33 <mistermatt> m reading
15:34:33 <monochrom> If it self-destructs, you don't even get to own it!
15:34:34 <SamB_XP> monochrom: it's not as if the piece of paper actually has anything useful on it
15:35:08 <ksf> it tells you that if you use the computer to control your microwave, you musn't put pets into the microwave.
15:35:30 * ksf loves these japanese safety drawings
15:35:59 <sproingie> i used to have this sign on the cover of my laptop
15:36:00 <SamB_XP> oh, so you *can* kill a cat with thet piece of paper!
15:36:01 <sproingie> http://www.engrish.com/2000/11/danger-sign/
15:36:17 <SamB_XP> ... you just have to be clever enough to have already known how to kill a cat ...
15:37:19 <ksf> http://pics.nase-bohren.de/roadsigns.jpg
15:37:29 <notsmack> narens, well it's immutable
15:37:53 <monochrom> narens: I imagine http://hackage.haskell.org/package/rosezipper helps
15:38:26 <narens> monochrom: how wonderful, thanks.
15:38:26 <monochrom> "zipper" is generally very convenient for "editing" things like trees.
15:39:02 <sproingie> "zipper" is convenient for "undressing" people like your date
15:39:07 <mistermatt> I think I'll type up all the code that I see in the book so I can play with it in ghci
15:39:21 <mistermatt> at least for chapter 3
15:39:27 <SamB_XP> mistermatt: that's not a bad idea ;-)
15:39:46 <SamB_XP> playing with things in GHCi is definitely a good way to learn stuff
15:39:50 <monochrom> You mean you haven't?!
15:40:09 <mistermatt> when I've needed to
15:40:18 <mistermatt> but like sproingie said, chapter 3 is dense
15:40:27 <mistermatt> so I'm going to really need to
15:40:30 <monochrom> When I was learning dBase][, I took a book and typed in all examples to get the self-gratification that they worked.
15:40:42 <ddarius> monochrom: Did they all work?
15:40:46 <monochrom> Yes.
15:40:59 <monochrom> I finished learning dBase][ that way in under 3 hours.
15:41:00 <sereven> mistermatt: you're talking about RWH?
15:41:09 <mistermatt> sereven, yes
15:41:13 <monochrom> Henceforth I wondered why other people kept saying it was so hard.
15:41:20 <narens> one other question. Would you recommend I use gtk or wxHaskell for GUI in general. And, what If I want a good UI element for displaying large lists? which would be a better choice?
15:41:23 <sereven> the source examples used to be downloadable from the OReilly page iirc
15:41:51 <mistermatt> I'll look into it, but I think typing them in manually might help with my memory
15:42:05 <monochrom> It is a great psychological tool.
15:42:26 <monochrom> Admit that you're a human not a bot. A bot learns by just downloading. A human needs psychological tricks.
15:42:33 <sereven> mistermatt: yeah, all learning modes in play kinesthetic visual auditory....
15:43:40 <sereven> I guess the playing with the code seems higher value than simply entering it to me, so don't think there's much loss with starting from pre-existing examples, say with School of Expression, hsc, rwh
15:44:25 <SamB_XP> monochrom: I've never known a bot ot learn anything
15:45:08 <monochrom> Oh I know a catchy thing to say. Real World Haskell is not a spectator sport. :)
15:46:01 <SamB_XP> and obviously those matrix people, despite downloading stuff to learn it, actually have to go through all the psychological tricks too ... only they somehow manage to do this much more quickly than should be possible.
15:49:05 * SimonRC goes
15:49:25 * ksf learned monads by having enough knowledge of didactics to notice that none of the authors of the tutorials had any knowledge of didactics
15:50:05 <ksf> ...and doing the thing using nothing but lambdas.
15:50:28 <ksf> ...it's just like doing cons car cdr as functions in scheme.
15:51:24 <SamB_XP> how do you take a course in didactics ?
15:51:51 <monochrom> Yes, most tutorials and blogs are written for author's self-gratification, not designed for the audience.
15:52:31 <SamB_XP> monochrom: well, some of them may be written for the author's future reference as well!
15:52:45 <ksf> well... I'm a trained youth sqad leader, which includes a lot of paedagogics.
15:52:51 <ksf> and then it's just practice.
15:53:03 <mistermatt> I noticed that some of the practice rpoblem answers for chapter 2 and 3 online use stuff that you learn in chapters 6 7 and 8
15:53:29 <monochrom> Yes, you're supposed to do a fixed point over the whole book. :)
15:53:34 <SamB_XP> hehehehe
15:53:46 <burp> @djinn (a,b,c) -> (a,b)
15:53:47 <lambdabot> f (a, b, _) = (a, b)
15:54:16 <ksf> also, being the one that all those clueless people ask when needing help with their code helps
15:54:29 <ksf> ...if you've got enough backbone to actually teach, that is.
15:54:36 <Gracenotes> hm. I don't even want to think how much uglier my 'parse tree -> intermediate code' function would like without the State monad
15:55:04 <Gracenotes> now, perhaps to do type checking /before/ it...
15:56:59 <SamB_XP> ksf: like to think that I do
15:57:06 <SamB_XP> I don't like to do it for them, that's for sure!
15:58:25 <ksf> ...you know you can do it when you do the following for the first time: notice that someone is confused, thus loosing interest, then distracting him until he's forgotten the confusion, then leading him towards the problem again, from a different direction.
15:59:00 <SamB_XP> hmm, I'll try to remember that
16:00:46 <Gracenotes> mapM is very much like a fold in the state monad
16:00:56 * SamB_XP lol @ http://www.shortpacked.com/d/20050131.html
16:01:34 <SamB_XP> Gracenotes: hmm, more like a scan maybe ?
16:01:56 <Gracenotes> oh, true, mapM_ would be more foldish. as it is, it's more like mapAndAccumL :P
16:02:34 <Gracenotes> s/And//
16:02:43 <SamB_XP> @type scanr
16:02:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
16:02:47 <SamB_XP> @type scanl
16:02:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:02:50 <SamB_XP> oh.
16:02:58 <SamB_XP> hmm.
16:03:04 <mauke> a scanr drkly
16:03:57 <Gracenotes> that would be the famed imperative programming language, Substance D
16:04:10 <SamB_XP> that's a language now ?
16:04:21 <mistermatt> oh another thing I'm also not sure about, how do you wrtie a function's type declaration? I wrote a function that evaluates to the length of a list, how would I write it's type signature?
16:04:27 <SamB_XP> sounds more like a drug ...
16:04:36 <mistermatt> type declaration? type signature?
16:04:38 <SamB_XP> mistermatt: :t foo
16:04:53 <monochrom> yourfunction :: [a] -> Int
16:04:54 <mistermatt> it's not required though is it?
16:05:06 <SamB_XP> mistermatt: did your code load ?
16:05:12 <mistermatt> yeah it works fine
16:05:29 <mistermatt> I'm confused as to when you need one versus when you don't
16:05:30 <Gracenotes> http://en.wikipedia.org/wiki/D_%28programming_language%29  http://en.wikipedia.org/wiki/A_Scanner_Darkly#Synopsis
16:05:59 <SamB_XP> mistermatt: well, they're helpful to read
16:06:10 <SamB_XP> ... they help you out when your code does not work ...
16:06:21 <mistermatt> sam, that was my next question
16:06:33 <Gracenotes> Haskell supports "type inference", meaning that you don't need to explicitly write signatures, but signatures can tell you much information about a function
16:06:36 <SamB_XP> ... and they also let you avoid the monomorphism restriction
16:06:57 <SamB_XP> mistermatt: that is, they make the type error messages more relevant
16:07:04 <mistermatt> ah, gotcha
16:07:06 <Gracenotes> information that the compiler could guess anyway -- except in some corner cases...
16:07:22 <mistermatt> thanks guys
16:07:23 <SamB_XP> since otherwise it won't have any clue where the types went askew from what you wanted them to be
16:07:51 <SamB_XP> there's also some things like polymorphic recursion that might need type signatures?
16:08:28 <ksf> iirc polymorphic recursion works just fine
16:08:32 <Gracenotes> not to mention.. sometimes the compiler has a vaguer idea about the function than you do, e.g. it thinks you want to use any number type but you really want Integer...
16:08:42 <SamB_XP> that's also true
16:08:47 <ksf> there's no difference between calling a polymorphic from inside itself than from anywhere else
16:09:03 <SamB_XP> ksf: ah
16:09:07 <ksf> you need a data type to do recursive types, though.
16:09:14 <mauke> polymorphic recursion requires explicit type signatures
16:09:53 <SamB_XP> oh, hmm, that's what I suspected ... I shouldn't listen to people who disagree with my suspicions so easily I guess?
16:10:18 <ksf> you should never ever listen to me if I use stuff like iirc afaik etc
16:10:32 <SamB_XP> ksf: oh, point
16:10:40 <ksf> and if I don't use them I'm even less reliable, not even knowing that I don't know.
16:11:20 <ksf> so the general advice is: don't believe a word that I say but do what I tell you.
16:11:30 <mauke> > let f n x | n <= 0 = show x | otherwise = f (n - 1) (n, x) in f 3 ()
16:11:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a1, a)
16:11:39 <Gracenotes> recursion in higher-level polymorphism can get messyish
16:11:47 <mauke> > let f :: (Show a) => Int -> a -> String; f n x | n <= 0 = show x | otherwise = f (n - 1) (n, x) in f 3 ()
16:11:48 <lambdabot>   "(1,(2,(3,())))"
16:12:26 <Gracenotes> perhaps just by merit of being higher-level
16:12:27 <ksf> erm yes but I wasn't thinking about that kind of fun.
16:12:28 <SamB_XP> that's the way!
16:12:39 <SamB_XP> prove it one way or the other once and for all ;-)
16:12:42 <ksf> the one I had in mind was traversing a finger tree
16:12:49 <SamB_XP> well, until we forget again
16:15:38 <shazam> what's the easiest way to write a basic lexer in happy?
16:15:52 <ksf> the easiest way is to use parsec
16:15:59 <SamB_XP> shazam: well, you'd write it in Haskell code
16:16:02 <SamB_XP> or use alex
16:16:19 <SamB_XP> happy is no good at lexers itself ;-P
16:17:11 <ksf> ...which seems strange, considering that lexing is a less-complicated subset of parsing
16:17:34 <SamB_XP> it's not really that strange
16:17:52 <SamB_XP> it makes sense to have different tools for different jobs
16:19:15 <SamB_XP> and breaking text into tokens isn't exactly part of L<whatever> parsing, now is it?
16:22:46 <ksf> well but matching terminals to non-terminals is
16:23:02 <ksf> it's not even proper parsing, it's just matching. a slightly more complex tr
16:23:21 <ksf> ...as you can collapse multiple source tokens into one target token.
16:24:33 <SamB_XP> ksf: well, it makes perfect sense to relegate it to another tool, though
16:24:46 <SamB_XP> it's a fairly orthogonal task
16:25:15 <ksf> well I see tokenizing an the first part of a multipass parser.
16:25:51 <SamB_XP> you might even want to write a tokenizer by hand
16:26:10 <SamB_XP> or use something besides a happy parser to process the tokens produced by an alex lexer
16:26:46 <SamB_XP> ... or, *gasp*, use some other lexer-generator than alex!
16:27:06 <ksf> or, *gasp* a parsec parser!
16:27:49 <SamB_XP> well, I tend to find that gets painful when I try to use it to parse a programming language ...
16:32:50 <shazam> my %tokentype is String, how do I define the token that represents any string?
16:34:06 <shazam> %token anystring { _ } doesn't work
16:34:12 <shazam> (in happy )
16:39:52 <mle> shazam: you have %tokentype { String } ?
16:40:09 <mle> hm
16:40:27 <mle> don't you mean { $$ } then, for the token itself?
16:44:59 <shazam> yeah
16:45:16 <shazam> but I get a warning then
16:45:22 <shazam>     Warning: Pattern match(es) are overlapped
16:45:22 <shazam>              In a case alternative: _ -> ...
16:45:57 <SamB_XP> shazam: perhaps you should put that one last ?
16:46:21 <shazam> tried
16:46:33 <shazam> the problem is this: 	_ -> happyError' (tk:tks)
16:46:36 <SamB_XP> oh, that's probably just a case that happy inserts then
16:46:41 <SamB_XP> ah, yeah, just ignore that
17:08:49 <porcofino> sup guys
17:09:07 <porcofino> I had an epiphany
17:09:29 <porcofino> it came clear that everything that I do in haskell can be made with lambda expressions
17:10:01 <Philippa> aside from pattern-matching, yep
17:10:23 <porcofino> Feels good, man.
17:10:42 <porcofino> sure, it's going to have lots of parenthesis, but Alonzo Church and Haskell Curry would buy me a drank in Heaven
17:13:38 <barry> hey guys i'm a noob ---- what do you recommend i read to get started with haskell?
17:14:29 <mayahustle> Hi would someone please explain what the withMVar function does? I'm sort of new to concurrency in haskell.  I'm reading some the tcp code in the networking chapter of Real World Haskell, and they wrote this:
17:14:34 <Zao> barry: learn you a haskell, real world haskell?
17:14:35 <mayahustle> withMVar lock
17:14:36 <mayahustle>                  (\a -> handlerfunc clientaddr msg >> return a)
17:14:59 <mayahustle> Personally, i've really enjoyed real world haskell.. I'd recommend it as well
17:15:34 <barry> thanks Zao... i'll try out real world haskell
17:15:41 <dpratt71> barry: from a fellow noob: I would suggest http://learnyouahaskell.com/chapters, and/or http://book.realworldhaskell.org/read/
17:16:27 <dpratt71> that first URL got messed up: http://learnyouahaskell.com/chapters
17:17:13 <barry> i tried looking at the Haskell School of Expression and Haskell road to logic anyone rate those?
17:22:02 <SamB_XP> barry: SoE was too basic for me
17:22:20 <jmcarthur> barry: HSE is somewhat unconventional in my opinion. i know little about HRL
17:22:37 <jmcarthur> barry: RWH and LYAH are pretty nice. the former is more advanced
17:22:47 <SamB_XP> I was hoping it would have more tips&tricks for EDSL/Combinator Library design :-(
17:22:53 <Cale> I forget what School of Expression is like (I haven't actually read it, only skimmed it anyway). Haskell Road is okay as its own sort of thing, but if you just want to learn Haskell, or you just want to learn basic number theory, I think there are nicer treatments of each.
17:23:09 <jmcarthur> SamB_XP: yeah, considering who wrote it...
17:23:21 <SamB_XP> jmcarthur: not considering just that
17:23:34 <SamB_XP> considering the descriptions of it that I'd seen, too
17:23:39 <jmcarthur> ah, yeah
17:24:04 <SamB_XP> matter of fact, I can't say as I remember who wrote it
17:24:18 <mrsolo_> real world haskell mentions Data.Array.Vector for performance optimzation on list
17:24:27 <mrsolo_> is there something even better now?
17:25:41 <burp> better for what?
17:26:03 <burp> depends on usage I think
17:27:23 <mrsolo_> even faster replacement   RHW uses that as an example  just wondering if something has superceed that
17:27:53 <monochrom> Always read 3-5 books and tutorials.
17:28:07 <Gracenotes> modify (\t -> t { recVTable = f (recVTable t) }). eek.
17:28:24 <SamB_XP> by what critereon?
17:29:02 <hackagebot> bindings-libffi 0.2 - Low level bindings to libffi. (MauricioAntunes)
17:29:08 <mrsolo_> monochrom: what other books do you recommend?
17:29:27 <Gracenotes> at least that code is reusable. in the copy/paste sense
17:29:29 <Cale> In fact, whether Data.Array.Vector is "better" than lists depends on your criteria to begin with :)
17:30:20 * SamB_XP was attempting to make a bad pun
17:31:08 <monochrom> I recommend all books you can find in a library you have access to.
17:31:57 <SamB_XP> monochrom: that will take far too long
17:32:11 <SamB_XP> do you have any idea how many libraries I have access to, or how slowly I read?
17:32:27 <SamB_XP> (partly on account of spending too much time on the computer before going to bed?)
17:32:50 <monochrom> By now Haskell books and tutorials are a commodity like college algebra. It is not which ones that count, but how many that counts. Each person has a number n such that the nth reading material makes him "click" and pretty independent on who wrote them.
17:33:23 <SamB_XP> too bad the colleges keep using the most recent edition :-(
17:33:27 <monochrom> SamB_XP I would recommend webpage tutorials to you in your case.
17:33:42 <SamB_XP> monochrom: oh, you were talking about books on a specific subject now?
17:33:47 <SamB_XP> I thought you meant *all* the books
17:33:58 <monochrom> I am asked "which books" very specifically and I answered accordingly.
17:34:14 <orclev> is there a #haskell-iphone channel yet?
17:34:14 <lambdabot> orclev: You have 1 new message. '/msg lambdabot @messages' to read it.
17:34:32 <SamB_XP> monochrom: so, say, you really think Full Metal Panic volumes 7-9 are going to help?
17:34:55 <monochrom> SamB_XP please take the context into consideration. You are supposed to be better than a pushdown automaton.
17:35:13 <SamB_XP> a pushdown automaton wouldn't come up with such a silly example ;-P
17:35:20 <monochrom> All your trolling questions are due to taking every word I say out of context.
17:35:25 <SamB_XP> no
17:35:25 <orclev> I never thought I'd see a discussion of FMP in the #haskell channel... then again I often see discussions in here I'd never expect
17:35:39 <SamB_XP> orclev: "discussion" isn't the word
17:35:45 <monochrom> I shall choose to never answer you again.
17:35:52 <gwern> @quote panda
17:35:53 <lambdabot> bos says: [On the type signature of hPrintf] This makes me a sad Irish panda.
17:36:08 <SamB_XP> I only mentioned that because I believe they were among the books recently returned to the library on my behalf ;-P
17:36:16 <SamB_XP> monochrom: ... right!
17:36:22 <Gracenotes> a pushdown automaton can output Σ*
17:36:25 <Gracenotes> fkjri4gt348t04oirepgs;fzd'fs;hfjdklsgh
17:36:27 <gwern> fumoffu!
17:36:39 <gwern> @quote simonSays
17:36:40 <lambdabot> lilac says: ponders whether unsafePerformIO would be better as simonSaysPerformIO
17:36:42 <orclev> gwern: I much preferred the original
17:36:49 <p_l> ... did someone say fumoffu?
17:36:58 <SamB_XP> monochrom: and honestly, I didn't know if you were just being smart-alecky or not
17:36:59 <orclev> lol@lilac quote
17:37:00 * p_l decides that there's definitely weird combination here...
17:37:26 <gwern> orclev: first and second raid were pretty dull - I've seen a billion mecha and whatnot, fmp had nothing new. what was brilliant was hardened-soldier+highschool-romance-comedy
17:37:42 <gwern> @quote representation
17:37:43 <lambdabot> ksf says: (But if (on the other hand)) (I think only a number in general (whether it be five or a hundred)) (this thought is rather the representation of a method (whereby a multiplicity (for
17:37:43 <lambdabot> instance a  thousand) may be represented (in an image in conformity with a certain concept)) than the image itself."
17:38:50 <SamB_XP> orclev: original what?
17:39:12 <Gracenotes> uh. why do I have a constructor Assignment (Symbol, Expression), when it could be Assignment Symbol Expression. how redundant.
17:39:16 <orclev> gwern: highschool-romance-comedy is not my cup of tea, so I didn't get much of anything out of fumoffu, but I'll take a nice mecha series any day even if it is unoriginal
17:39:23 <orclev> SamB_XP: FMP
17:39:27 <p_l> gwern: some technicalities (like realistically failing subsystems that don't result in kaboom) were a nice touch
17:39:33 <SamB_XP> orclev: as opposed to ?
17:39:34 <gwern> @quote SCIENCE
17:39:35 <lambdabot> Cale says: I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other
17:39:35 <lambdabot> memories and prescience to rule over everyone and everything for millenia.
17:39:42 <orclev> SamB_XP: fumoffu
17:39:57 <SamB_XP> orclev: oh, what's that translate to in english?
17:40:03 * gwern chants: fumo fumo fumoffu!
17:40:13 <orclev> SamB_XP: fumoffu was basically FMP minus the action and mecha
17:40:13 <p_l> SamB_XP: that's not really translateable nor meaning anything
17:40:39 <SamB_XP> I somehow wasn't aware that fumoffu was distinct from FMP ...
17:40:59 <orclev> SamB_XP: yeah, there's actually 3 series, with fumoffu being sandwiched in the middle
17:41:03 <SamB_XP> not that I've seen, read, or otherwise imbibed anything labeled fumoffu
17:41:34 <p_l> FMP, FMP: Fumoffu & FMP: Second Raid, iirc
17:41:35 <SamB_XP> I figured it must be a japanese abbreviation of an english title
17:41:41 <orclev> p_l: correct
17:41:58 <SamB_XP> like Full Metal Fury or something
17:42:03 <orclev> SamB_XP: nope, it's more like a sound effect near as I can tell
17:42:34 <p_l> nah, it's not furikuri... furi...kuri...furikurafurikurifurikura...
17:42:39 * p_l descends into madness
17:43:03 <SamB_XP> p_l: huh?
17:43:06 <Gracenotes> FRKR :o
17:43:26 <orclev> SamB_XP: ah, found the answer on the wikipedia page: "Fumoffu" is the sound made by Bonta-kun, the series' fictional mascot, which resembles a human-sized, yellow teddy-bear.
17:43:26 <SamB_XP> fooly-cooly?
17:43:43 <orclev> so wait, is it fooly, or cooly?
17:43:44 <gwern> SamB_XP: no, it's more like this:
17:43:49 * gwern makes groping motions
17:43:49 <SamB_XP> orclev: why the "fictional"?
17:43:57 <mrsolo_> fumoffu :-)
17:44:02 <orclev> SamB_XP: don't ask me, I didn't write it
17:44:04 * p_l cackles madly in the background
17:44:09 <Gracenotes> because wikipedia doesn't talk about fictional universes like they're real
17:44:12 <mrsolo_> that anime was very funny
17:44:18 <orclev> FLCL rocked
17:44:18 <SamB_XP> aren't most mascots for fiction also fictional?
17:44:37 <SamB_XP> I have not seen/read/drank FLCL :-(
17:44:38 * orclev ponders a real mascot for a fictional series.
17:44:41 <gwern> SamB_XP: my school had a mascot which ran around
17:44:42 <Gracenotes> some mascots are non-fictional
17:44:45 <gwern> he didn't seem fictional to me
17:44:55 <SamB_XP> gwern: is your school a work of fiction?
17:45:09 <gwern> SamB_XP: sometimes I wondered
17:45:19 <Gracenotes> http://en.wikipedia.org/wiki/WP:WAFFLES
17:45:22 <SamB_XP> and yet you evidently attented
17:45:38 <SamB_XP> er. modulo spelling.
17:45:47 <p_l> SamB_XP: reality got drunk with fiction at gwern's school, apparently
17:46:01 <Gracenotes> woo, waffles
17:46:05 <orclev> SamB_XP: FLCL hails from the random hyper-active school of anime... stuff happens, for no apparent reason, and is rarely explained... you just sort of have to sit back and take it all in
17:46:32 <SamB_XP> hmm, what anime have I seen snippets of that fit that description?
17:46:48 <p_l> FLCL was kinda like "let's get a ton of drugs and unwind after “End of Evangelion” as much as possible"
17:47:00 <orclev> SamB_XP: uhm... excel saga?
17:47:10 <SamB_XP> hmm ... there was one where a michael-jackson-esque guy was dancing and hypnotizing everyone?
17:47:14 <Gracenotes> @pl \x -> f <$> g x
17:47:14 <lambdabot> (f <$>) . g
17:47:26 <SamB_XP> hmm ... then how about that bobobobbobobobob
17:47:36 <orclev> SamB_XP: yeah, that one fits
17:47:38 <gwern> p_l: well, his and her circumstances was more that
17:47:43 <orclev> SamB_XP: but FLCL was more hyper
17:47:53 <gwern> I see karekano as eva set in real life
17:48:13 <p_l> gwern: karekano was based on an existing manga, so not really (though I loved the yuri episode! xD)
17:48:41 <gwern> p_l: you watched kk, didn't you? how can you say that it was just based?
17:49:00 <gwern> you would have to be blind to not see how every other image was borrowing or alluding to eva
17:49:24 <p_l> gwern: I haven't yet started reading original manga, but yes, it was alluding - at least in the graphic style, which I appreciated very much
17:49:30 <sevvie> Full Metal Panic?
17:49:39 <p_l> NGE was a mayor landmark in my development :P
17:49:42 <sproingie> mmm waffles
17:50:06 <SamB_XP> they're talking about Kare Kano or somthing
17:50:25 <SamB_XP> so, what is the mascot for Love Hina?
17:50:35 <sproingie> wikipedia certainly has comprehensive guidelines that in reality boil down to "all your hard work on anything will be undone by a cult of editorial acolytes looking to increase their edit count"
17:50:35 <sevvie> Turtles.
17:50:40 <p_l> SamB_XP: that stuffed toy!
17:50:48 <SamB_XP> p_l: that what ?
17:50:48 <gwern> now, flcl certainly does have connections to other gainax works, like the daicon videos and the ED liveaction scenes mimicking KK
17:50:55 <gwern> but the eva connections are minimal
17:51:21 <p_l> SamB_XP: there was a stuffed toy in Naru's room (which was very important for the plot)
17:51:22 <orclev> gwern: other than the general sense of WTF? as you're watching it
17:51:40 <SamB_XP> p_l: darn it
17:51:52 <SamB_XP> I must have read too far into the manga to remember that :-(
17:51:55 <gwern> @quote twitch
17:52:03 <lambdabot> OlinShivers says: They look at me funny; they think I twitch a lot. I'm not twitching. I'm controlling my impulse to snag my 9mm Sig-Sauer out from my day-pack and make a few strong points about the
17:52:09 <lambdabot> quality of undergraduate education in Amerika.
17:52:12 <gwern> orclev: yeah; the closest I can connect them is that they're both bildungsromans
17:52:17 <gwern> which isn't much
17:52:36 <gwern> (and, iirc, the famous mangamation in FLCL first showed up in KK)
17:52:37 <orclev> bildungsromans?
17:53:20 <orclev> gwern: I've never seen KK so I wouldn't know
17:53:35 <gwern> orclev: literature term, wiki it
17:53:40 <orclev> k
17:53:41 <p_l> orclev: IIRC it means "story about transition" usually "from children to adult", but I'm in MSci course, not BLitt :P
17:54:21 <orclev> ah, I thought that sounded german
17:54:36 <orclev> p_l: MSci?
17:54:39 <SamB_XP> MSci?
17:54:46 <orclev> lol
17:54:48 <SamB_XP> made up sciences ?
17:54:49 <sproingie> the common modern term is "coming of age story"
17:55:02 <SamB_XP> sproingie: that's way over-used!
17:55:07 <p_l> orclev: Master in Science, something close to MSc minus thesis (just project)
17:55:12 <gwern> sproingie: which is silly, of course
17:55:12 <p_l> in CS&AI
17:55:26 <sproingie> yes, and "bildungsroman" is used by people who want to sound all smart and shit
17:55:33 <SamB_XP> p_l: oh, you should have just called it M.S.
17:55:54 <SamB_XP> or MS
17:56:08 <orclev> ah, I don't think I could ever finish a MS program...
17:56:09 <p_l> SamB_XP: MSci is the abbreviation used here. Where I come from, there's just Bachelor/Masters/PhD/PhD w/ habilitation
17:56:10 <sproingie> hackneyed term for a well-worn story archetype
17:56:22 <sproingie> ("coming of age" that is)
17:56:22 <gwern> sproingie: smart? I learned the term in 7th grade
17:56:26 <SamB_XP> what's that last one ?
17:56:38 <gwern> it's about as smart as 'epic'
17:56:51 <SamB_XP> gwern: not really
17:56:58 <SamB_XP> epic is easier to remember how to spell
17:57:08 <p_l> SamB_XP: additional step after PhD, in theory requires original research. Required for certain positions, like "normal" professor (which is actually a title in Poland)
17:57:33 <gwern> p_l: ...you can get a phd without OR?
17:57:37 <SamB_XP> is that a professor who's magnitude has been adjusted to 1?
17:57:55 <p_l> gwern: said original research must result in something "new"
17:57:56 <orclev> Bildungsroman being of german original is probably more common around countries that either have a large german speaking population or are neighbors of german speaking countries
17:58:06 <Gracenotes> @pl \x -> g x >>= f
17:58:06 <lambdabot> (f =<<) . g
17:58:20 <sproingie> the germans sure do love their compound words
17:58:33 <p_l> gwern: like solve some well-known problem or advance science in that discipline
17:58:33 <orclev> lol, normalized professor
17:58:34 <gwern> bildungsroman, picaresque, epic, these are all standard genres
17:58:53 <orclev> never heard of picaresque either
17:59:00 <Gracenotes> sproingie: you should see my other nick, Vorschlagsnoten...
17:59:04 <SamB_XP> gwern: I thought epic was an adjective
17:59:10 <gwern> SamB_XP: noun too
17:59:15 <SamB_XP> most often applied to the noun phail
17:59:17 <Gracenotes> adjective comes from noun, I believe
17:59:40 <sproingie> typically "heroic epic"
17:59:46 <p_l> as for "normal" vs. not-normal professors - the later ones are appointed individually by each university at their whim, the first one is national
17:59:55 <sproingie> but heroic epics themselves typically contain multiple stories
18:00:24 <orclev> sproingie: sort of a compound story... I'd never thought of it like that before
18:00:34 <gwern> sproingie: sure. like Beowulf has at least 2 internal stories, even if you count the three acts of beowulf as one story
18:00:56 <Gracenotes> then there's the word "aktionsarten", which means "Linguists who only study tense and aspect in one language make contradictory models"
18:01:04 <gwern> and how many stories get told in the iliad or the odyssey? most of the odyssey isn't even in the frame story
18:01:04 <Gracenotes> or at least, as far as I can tell, from the literature
18:01:23 <gwern> @quote magic.*science
18:01:24 <lambdabot> dons says: ah, via the magic of SCIENCE
18:01:33 <gwern> @quote let.*loose
18:01:34 <lambdabot> dobblego says: many of my colleagues used to be [fond of ruby] as well until I was let loose on them
18:01:44 <gwern> @quote hackage
18:01:45 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
18:01:48 <gwern> @quote hackage
18:01:49 <lambdabot> int-e says: I propose that all of f, g, h and i be made illegal. (referring to http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax as it existed on 2009-10-05)
18:01:57 <gwern> @quote hackage
18:01:58 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
18:02:20 <stoney> can anyone help me on how to do pattern matching pls
18:02:45 <sproingie> lambdabot: wat te uck?
18:02:47 <SamB_XP> I thought that was spelled plz
18:03:11 <SamB_XP> sproingie: you seem to have a problem with your "h" and "f" keys
18:03:17 <gwern> @quote on.*hackage
18:03:18 <lambdabot> dons says: [on whether a library is wanted] *yes* put it on Hackage!
18:03:25 <sproingie> SamB_XP: they're illegal :)
18:03:29 <gwern> @quote parsec
18:03:29 <lambdabot> BMeph says: (about parsec)> 'Cause it's light-years ahead of the competition!
18:03:38 <stoney>  myfunction (someType (a, b))            = a
18:03:51 <stoney> i am trying to get first element of a
18:03:53 <gwern> @quote comeon
18:03:53 <lambdabot> No quotes match. :(
18:04:03 <gwern> @quote reddit
18:04:04 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
18:04:04 <lambdabot> background
18:04:14 <gwern> @quote reddit
18:04:15 <lambdabot> cowardlydragon says: [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
18:04:24 <gwern> @quote reddit
18:04:24 <lambdabot> cowardlydragon says: [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
18:04:29 <stoney> a is a type of pair
18:04:40 <stoney> i want to get first eleement out and work on it
18:04:41 <gwern> @quote programming.*reddit
18:04:42 <lambdabot> ray says: i think programmers make the worst programmers. also the worst people. and i'm saying this having not looked at programming reddit in a while.
18:04:46 <Gracenotes> @hoogle (a -> Bool) -> [a] -> ([a], [a])
18:04:47 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
18:04:47 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
18:04:47 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
18:04:53 <gwern> @quote greek
18:04:53 <lambdabot> Orclev says: ... a lot of haskell still looks greek to me, and I'm not talking about lambdas.
18:05:00 <gwern> @quote cabbage
18:05:00 <Gracenotes> @type partition
18:05:01 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:05:01 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
18:05:06 <gwern> what
18:05:06 <Gracenotes> that's it
18:05:09 <gwern> @quote cabbage
18:05:10 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
18:05:11 <gwern> @quote cabbage
18:05:12 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
18:05:13 <gwern> @quote cabbage
18:05:13 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
18:05:19 * SamB_XP lols at http://www.shortpacked.com/d/20050610.html -- batman ? DDR? too funny!
18:05:19 <sproingie> enough of that
18:05:29 <Gracenotes> what as that oft-quoted definition of insanity again
18:05:41 <gwern> Gracenotes: given that it's a randomized process...
18:05:58 <Gracenotes> okay, insanity has a probability threshold -_-
18:06:14 <monochrom> I thought stoney had a question.
18:06:24 <stoney>  myfunction (someType (a, b))            = a
18:06:31 <sproingie> SamB_XP: http://www.pvponline.com/2009/09/21/bat-a-hang/
18:06:34 <stoney> type a is a pair
18:06:38 <gwern> Gracenotes: put any threshold on your probabilities, and I can dutchbook you
18:06:44 <stoney> and i need to get first eleement out of that pair
18:06:52 <stoney> i cant do fst a
18:07:14 <gwern> stoney: just say 'a'?
18:07:24 <gwern> > let foo (a,b) = a in foo (1,2)
18:07:25 <lambdabot>   1
18:07:34 <stoney> because well the way function is now it just return type a
18:07:34 <orclev> sproingie: the fourth panel of that one is a bit disturbing
18:07:36 <monochrom> What is "someType"? Is it actual code or just speaking figuratively?
18:07:39 <gwern> @quote performance.*darcs
18:07:40 <lambdabot> No quotes match.
18:07:45 <stoney> i need first element of that that type a
18:08:13 <sproingie> orclev: for some reason the third one just cracks me up
18:08:25 <stoney> it is newType = myType([Int],Int)
18:08:27 <SamB_XP> stoney: no way
18:08:41 <stoney> so i need to get that list out
18:09:30 <stoney> ;l
18:09:33 <Gracenotes> stoney: just one thing, capitalization is rather important in types :)
18:09:46 <stoney> i know i was just trying to type fast my problem:)
18:09:59 <Gracenotes> data Blah = Foo [Int], will compile. data Blah = foo [Int]... uh, probably not
18:10:06 <SamB_XP> stoney: how about you don't and we just don't flood ;-)
18:10:08 <monochrom> Incomplete questions get incomplete answers, you know that?
18:10:25 <stoney> ok sorry
18:10:39 <morganson> hello everyone. I'm new to Haskell. =)
18:10:56 <morganson> nice language
18:11:27 <orclev> morganson: haskell does some cool stuff
18:11:37 <Gracenotes> for pattern matching, like func (a, b) = a + b, if the type of (a, b) is (Int, Int), then the type of a is Int, and the type of b is Int
18:11:42 <orclev> morganson: just takes a while to get used to
18:12:37 <Gracenotes> if you have "let x = fst y", then if the type of y is ([Int], Int), then the type of x will be [Int]
18:13:18 <stoney> well if the type a is like this "newType Something = something(type1,type2)"
18:13:30 <morganson> what does list comprehension really mean? how does it look in haskell. Am I right that it is "creating lists based on other lists"?
18:13:52 <morganson> allright orclev. =)
18:13:58 <monochrom> Yes. [ x+1 | x <- [4,1,6] ]  is an example
18:14:03 <stoney> if type1 is "newType somethinelse =somethingElse ([Int],Int)
18:14:04 <Gracenotes> stoney: do you mean: newtype Something = Something (Type1, Type2)? capitalization is important...
18:14:07 <orclev> morganson: list comprehension is more like making a list from a function
18:14:08 <gwern> morganson: list comps are more easily understood if you see what combination of filters and maps etc they get turned into. they're syntax sugar
18:14:15 <stoney> yes Gracenotes
18:14:27 <stoney> so now if i have that and i do this...
18:14:29 <morganson> allright
18:14:35 <stoney>  myfunction (someType (a, b))            = a
18:14:40 <monochrom> And I'm surprised that some people still haven't heard of pastebins.
18:14:45 <stoney> this will return a which is of type!
18:14:49 <stoney> Type1
18:14:56 <morganson> pastebins are good
18:15:07 <stoney> so since I have a why cand i do "fst a"
18:15:14 <dpratt71> I was just scanning back through the chat log and saw that someone summoned lambdabot via @pl...what is the meaning of this incantation?
18:15:17 <stoney> to get that list out of Type1
18:15:52 <SamB_XP> dpratt71: pointless!
18:16:08 <Gracenotes> stoney: not quote. "SomeType (a, b)" has Type1. (a, b) has type ([Int], Int). a has type [Int]
18:16:11 <Gracenotes> quite
18:16:21 <monochrom>  @pl It rewrites for example (\x -> f x) to f.
18:16:30 <dpratt71> SamB_XP: thanks; for a minute there, I thought you were insulting my question
18:16:45 <SamB_XP> dpratt71: just teasing you ;-P
18:16:51 <dpratt71> :)
18:17:22 <Gracenotes> stoney: pattern matching breaks down types into their subcomponents. Perhaps you're not sure about what "newtype" does
18:17:29 <stoney> ok let me write this in moonpatio Gracenotes
18:17:35 <stoney> give me few
18:17:47 <monochrom> After 10 minutes finally.
18:18:20 <monochrom> I do hear that in the American and Canadian culture, people chat for 10 minutes about "how was your weekend" before getting to the point.
18:18:20 <orclev> > take 10 [ x*2 | x <- [1..] ]
18:18:21 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:18:51 <SamB_XP> monochrom: well, sometimes that makes sense!
18:18:56 <SamB_XP> sometimes that is part of the point
18:19:03 <orclev> monochrom: some do, some don't, but I don't think that's necessarily an American or Canadian exclusive thing
18:19:16 <monochrom> No. "how was your weekend" for 10 minutes before pasting code to pastebin.
18:19:40 * Gracenotes hands out #haskell-subsidized chill pills
18:19:55 <orclev> > take 10 $ map (*2) [1..]
18:19:56 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:19:58 <Gracenotes> no poison, promise
18:20:33 <SamB_XP> Gracenotes: you want people to go to #haskell-subsidized ?
18:20:35 <orclev> ipso facto, [ x*2 | x <- [1..] ] === map (*2) [1..]
18:20:43 <Gracenotes> > partition even [1..10]
18:20:44 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
18:20:45 <SamB_XP> monochrom: okay, that makes no sense ;-P
18:20:51 <Gracenotes> SamB_XP: if they have monies
18:24:17 <dpratt71> to anyone who cares to answer: what would you change about Haskell if you could?
18:25:04 <orclev> dpratt71: I haven't used it enough to have a good answer to that, but I think a way to inline foreign languages like C or assembly would be cool
18:25:05 <monochrom> axioms to be verified when writing typeclass instances  <evil grin>
18:25:05 <stoney> Gracenotes http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4329#a4329
18:25:09 <SamB_XP> dpratt71: MonadPlus, put back monad comprehensions, figure out how the heck to implement Typeclass aliases, and get someone working on the numeric hierarchy
18:25:34 <monochrom> But more seriously, one of those improvements of record-related syntax
18:25:35 <SamB_XP> er. I mean, add MonadZero
18:25:59 <SamB_XP> oh, yeah, and swapping in one of those extensible record systems would be a good idea ...
18:26:01 <Gracenotes> monochrom: yes please
18:26:04 <Cale> dpratt71: Lots of stuff in the Prelude.
18:26:27 <Gracenotes> stoney: do you know the difference between the keywords "newtype" and "type"?
18:26:30 <monochrom> Institutionalize the property language of QuickCheck or SmallCheck.
18:26:53 <SamB_XP> monochrom: you know, that is something that we *could* do
18:27:04 <Cale> I would add some system of polymorphic extensible records and variants.
18:27:19 <stoney> i think type is basically just synonim or name for it
18:27:28 <dpratt71> SamB_XP: can you explain the numeric hierarchy thing a bit more?
18:27:29 <orclev> property language of QuickCheck?
18:27:49 <monochrom> notation for QuickCheck properties.
18:27:57 <dpratt71> (thanks all for the responses, btw)
18:28:12 <Cale> dpratt71: Show and Eq are superclasses of Num, which is annoying for defining many useful instances. Also Num contains signum and abs which shouldn't be in there.
18:28:34 <SamB_XP> and the inclusion of fromInteger is questionable as well
18:28:42 <Cale> No, fromInteger is fine
18:28:47 <Gracenotes> we must appease those who demand non-numerical Num instances :o
18:28:47 <SamB_XP> no it isn't ;-P
18:28:51 <dpratt71> so the Prelude conflates too much in that area?
18:28:54 <Cale> any ring admits a homomorphism from Z
18:28:55 <SamB_XP> what about galois fields ?
18:29:00 <Cale> fromInteger should be that homomorphism
18:29:08 <SamB_XP> fine, fine ...
18:29:10 <Cale> Finite fields also
18:29:13 <SamB_XP> be homo if you want
18:29:29 <Gracenotes> and then, toInteger to complete the homomorphism :)
18:29:35 <Cale> (a unique homomorphism, moreover ;)
18:29:49 <Cale> Gracenotes: you mean an isomorphism?
18:29:54 <Gracenotes> stoney: right, 'type' just makes a synonym, which is interchangeable. 'newtype' makes a wrapper constructor.
18:30:21 <Gracenotes> Cale: oh, hm, what's the opposite of a homomorphism again?
18:30:37 <SamB_XP> could it be heteromorphism ?
18:30:42 <Gracenotes> or complement, or whatever is needed such that homomorphism + x = isomorphism
18:30:43 <stoney> yeah i kind of had problem with constructors as well because at the time i didnt know i have to have only one parametar
18:31:05 <Cale> Gracenotes: well, you need another homomorphism which is the inverse of the first.
18:31:14 <SamB_XP> stoney: that's only for newtypes
18:31:20 <Gracenotes> Cale: is there a name for that?
18:31:27 <Gracenotes> do you know about 'data' too? That allows you to create constructors that have many parameters
18:31:29 <SamB_XP> Gracenotes: an inverse ?
18:31:38 <dpratt71> SamB_XP: also, what is the concept of a "monad comprehension"? does that relate in any way to "do" notation?
18:31:42 <monochrom> stoney: myFunction (Type3 (Type1 (a,c), b)) = a  {- the way you set up Type3, the list is hidden that deep, yes -}
18:31:56 <stoney> no i didnt know that...newtype worked so far so i didnt have need to do it
18:32:00 <SamB_XP> dpratt71: basically, it's list comprehensions generalized to Monad
18:32:21 <dpratt71> SamB_XP: I see
18:32:24 <SamB_XP> or MonadPlus or ...
18:32:32 <Gracenotes> Cale: I mean, like how there are names for injective vs. surjective functions, and combined there is bijection
18:32:44 <stoney> yeah i did made it little more complicated but i didnt know any better
18:34:23 <Cale> Gracenotes: Well, if a ring homomorphism is bijective, then it happens to be an isomorphism, but that's a special property of rings.
18:34:47 <Gracenotes> stoney: that's fine. although, for something that represents a data type, I'd tend to use 'data'. or something that is about conceptually the same as its type, but could use a wrapper for technical reasons, I'd use 'newtype'.
18:35:23 <Cale> SamB_XP: MonadZero, which we don't have anymore, but should
18:35:35 <SamB_XP> Cale: yeah, I knew that was involved somehow
18:36:20 <lispy> and MonadNonZero would be what?
18:36:22 <orclev> hmm... how would I apply a function to each member of a tuple?... so f -> (a,b) === (f a, f b)
18:36:30 <stoney> thanks Gracenotes
18:36:48 <lispy> ?hoogle (a -> b) -> (a, a) -> (b, b)
18:36:48 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
18:36:49 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
18:36:49 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
18:36:50 <orclev> I want more or less the equivalent of map but for a tuple
18:37:19 <lispy> :t (***)
18:37:20 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:37:22 <Gracenotes> orclev: well, not just any tuple, (a, b) where the type of a == the type of b
18:37:34 <orclev> Gracenotes: true
18:37:36 <Gracenotes> mm, there is this sort of complicated "join (***) f"
18:38:00 <lispy> :t join (***)
18:38:02 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:38:14 <lispy> oh that is nic
18:38:16 <lispy> nice*
18:38:31 <BMeph> MonadAnnililator! >:)
18:38:51 <monochrom> @type (&&&)
18:38:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:39:29 <monochrom> > ((f :: Expr -> Expr) *** f) (0, 'a')
18:39:31 <lambdabot>   Ambiguous type variable `c'' in the constraints:
18:39:31 <lambdabot>    `GHC.Show.Show c''
18:39:31 <lambdabot>     ...
18:39:41 <monochrom> Oh, I goofed.
18:39:45 <lispy> yeah
18:39:47 <monochrom> > ((f :: Expr -> Expr) *** f) (0, 1)
18:39:48 <lambdabot>   Ambiguous type variable `c'' in the constraints:
18:39:48 <lambdabot>    `SimpleReflect.FromExpr...
18:39:58 <monochrom> Ha, nevermind.
18:40:00 <lispy> um?
18:40:10 <orclev> ?hoogle (a -> b) -> (c -> d) -> (a, c) -> (b, d)
18:40:11 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
18:40:29 <lispy> > (join (***)  f) (1,1)
18:40:30 <lambdabot>   Ambiguous type variable `c' in the constraints:
18:40:31 <lambdabot>    `SimpleReflect.FromExpr ...
18:40:39 <lispy> > (join (***)  f) (1,1) :: Expr
18:40:40 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:40:40 <lambdabot>         against inferred ...
18:41:03 <orclev> hmm... wouldn't >< be a op?... how would you have a 3 arg op?
18:41:40 <lispy> > let (%) a b c = 1 in % 1 2 3
18:41:41 <lambdabot>   <no location info>: parse error on input `%'
18:41:51 <lispy> > let (%) a b c = 1 in 1 % 2 3
18:41:52 <lambdabot>   No instance for (GHC.Num.Num (t1 -> t))
18:41:52 <lambdabot>    arising from the literal `2' at ...
18:41:59 <copumpkin> > let (%) a b c = 1 in 1 % 2 $ 3
18:42:00 <lambdabot>   1
18:42:10 <orclev> > (><) (take 10) (take 10) ([1..20],[1..20])
18:42:11 <lambdabot>   Not in scope: `><'
18:43:08 <BMeph> @let (><) = join (***)
18:43:09 <lambdabot>  Defined.
18:43:17 <BMeph> > (><) (take 10) (take 10) ([1..20],[1..20])
18:43:19 <lambdabot>   Couldn't match expected type `[a] -> [a]'
18:43:19 <lambdabot>         against inferred type `([...
18:43:52 <Gracenotes> lambdabot sure be complainin' lots.
18:44:05 <BMeph> Wait a minute... that's kind of silly. :)
18:44:12 <copumpkin> > (><) (take 10) ([1..20],[1..20])
18:44:13 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
18:44:18 <BMeph> > (***) (take 10) (take 10) ([1..20],[1..20])
18:44:19 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
18:44:32 <copumpkin> > take 10 >< ([1..], [2..])
18:44:33 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11])
18:44:37 <orclev> hmm
18:45:08 <BMeph> Is there a way to see all of the stull defined in L.hs? :)
18:45:09 <orclev> :t (***)
18:45:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:45:20 <BMeph> Err, *stuff
18:45:54 <orclev> :t (***) (take 10) (take 10) ([1..20],[1..20])
18:45:55 <lambdabot> forall a a1. (Num a, Enum a, Num a1, Enum a1) => ([a], [a1])
18:46:26 <BMeph> orclev: Using Conal's notation, (***) :: (b ~> c) -> (b' ~> c') -> (b, b') ~> (c, c')
18:46:30 <orclev> what's the type of a in the definition of (***)?
18:46:38 <Gracenotes> okay, my-practically-unusable-subset-of-C compiler is coming along, 168 lines of Haskell, gotta do assembly generation now :o
18:47:21 <BMeph> orclev: (a :: * -> * -> *) . (Arrow a) -- I.e., a is an Arrow type
18:47:31 <orclev> BMeph: ah, I
18:47:34 <orclev> doh
18:47:39 <orclev> I'm unfamiliar with Arrow
18:47:42 <Gracenotes> (->) is a type constructor, just like Maybe or []
18:47:53 <copumpkin> more like Either or (,)
18:48:07 <Gracenotes> true, in approximate kindedness
18:48:14 <SamB_XP> @kind (->)
18:48:15 <lambdabot> ?? -> ? -> *
18:48:22 <SamB_XP> ... but nevermind that for now ;-P
18:48:26 <lispy> ?kind Either
18:48:27 <lambdabot> * -> * -> *
18:49:06 <copumpkin> that's a subkind of ?? -> ? -> *
18:49:09 <Gracenotes> the main difference is, it doesn't have any constructors, like (:), Nothing, or Right
18:49:38 <Gracenotes> well, not the main difference to the compiler. but typewise
18:50:15 <lispy> It's also weird to think of Either a b, as a proof of b given a
18:50:44 <orclev> > (***) (take 10) (take 10) $ partition even [1..]
18:50:45 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
18:51:12 <lispy> > take 10 *** drop 10 $ partition even [1..]
18:51:13 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20],[21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,...
18:51:32 <orclev> (><) (take 10) $ partition even [1..]
18:51:38 <orclev> > (><) (take 10) $ partition even [1..]
18:51:39 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
18:52:03 <orclev> > take 10 >< partition even [1..]
18:52:04 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
18:55:01 <Gracenotes> @src partition
18:55:01 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:55:02 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:55:02 <lambdabot>                               | otherwise = (ts, x:fs)
18:58:28 <hackagebot> bindings-libcddb 0.2 - Low level binding to libcddb. (MauricioAntunes)
18:59:28 <orclev> :t (><)
18:59:29 <lambdabot>     Ambiguous occurrence `><'
18:59:29 <lambdabot>     It could refer to either `L.><', defined at <local>:7:0
18:59:29 <lambdabot>                           or `Test.QuickCheck.><', imported from Test.QuickCheck
18:59:38 <orclev> :t (L.><)
18:59:39 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
19:00:04 <Gracenotes> @type partition
19:00:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:00:37 <Gracenotes> so then, I basically have (a -> Bool) -> (a -> b) -> [a] -> ([b], [a])
19:01:13 <orbitz> hey, anyone work through Bird's sudoku solver?
19:01:35 <ddarius> :t (partition .) .  first . map
19:01:36 <lambdabot>     Couldn't match expected type `a -> Bool'
19:01:36 <lambdabot>            against inferred type `(c, d)'
19:01:36 <lambdabot>       Expected type: a1 (b, d) (a -> Bool)
19:01:40 <dolio> I've read through it.
19:01:47 <dolio> Or, someone riffing on his stuff, at least.
19:01:58 <ddarius> dolio: You've probably read his.
19:02:16 <dolio> Is the one on the haskell wiki actually by him?
19:02:31 <ddarius> There's a paper where he describes an implementation.
19:02:40 <orbitz> i'm trying to implement it
19:02:42 <dolio> Oh, I don't think I've read that.
19:02:48 <orbitz> and not all of his code maps properly
19:02:55 <ddarius> dolio: It's like a pearl on Pearls.
19:03:08 <jfredett> orbitz: I flipped through the paper that was on reddit, but otherwise no.
19:03:15 <orbitz> he has
19:03:16 <orbitz> "The function group groups a list into component lists of length boxsize"
19:03:28 <orbitz> and he impelments it as group = groupBy boxsize where boxsize = 3
19:03:31 <orbitz> which is clealry wrong
19:03:39 <dolio> http://haskell.org/haskellwiki/Sudoku#Sudoku_incrementally.2C_.C3.A0_la_Bird
19:03:44 <jfredett> orbitz: maybe he uses a different groupBy?
19:03:50 <jfredett> not necessarily the one from Data.List
19:03:57 <dolio> That's the one I read. It's actually by Graham Hutton.
19:04:19 <jfredett> that is, he defines groupBy to be a generalized version of `group`
19:04:29 <orbitz> hrm
19:04:38 <orbitz> what is a 'component list'?
19:04:39 <ddarius> Where groupBy = chunk (or the function usually called chunk)
19:04:49 <ddarius> Or I guess map chunk
19:06:03 <Gracenotes> heh, my partition is more complicated compared to the normal partition than I thought
19:06:41 <orbitz> is a chunk of 3 on [1, 2, 3, 4] = [1, 2, 3], [2, 3, 4]?
19:06:45 <ddarius> Gracenotes: Can't you trivially define it in terms of the normal partition or are there different semantics beyond the one suggested by the type.
19:08:00 <Gracenotes> well, here it is particularly
19:08:17 <Gracenotes> partitionDecl xs = foldr sortDecl ([],[]) xs
19:08:19 <Gracenotes> sortDecl (MidDeclare v) ~(decls, stmts) = (v:decls, stmts)
19:08:20 <Gracenotes> sortDecl midstmt        ~(decls, stmts) = (decls, midstmt:stmts)
19:09:34 <Gracenotes> the constructor pattern matching would probably, if not a function definition, require a list comprehension, which makes it more like a filter, not a partition, meaning one must go through the list two times
19:09:59 <Gracenotes> not like it's a /huge/ list :)
19:14:11 <orclev> couldn't you define a groupBy the way he does as something like: groupBy x y = [take x y]:groupBy (drop x y)
19:14:42 <copumpkin> you'd probably want span
19:15:16 <Gracenotes> splitAt isn't so bad
19:15:22 <orclev> copumpkin: what does span do?
19:16:15 <orclev> ah, think I figured it out
19:16:40 <Axman6> > span (< 5) [1..10]
19:16:41 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
19:18:15 <orclev> span would most likely be more efficient, but harder to work with when trying to do a quick one liner in here
19:21:12 <Veinor> I know you've missed me.
19:21:20 <copumpkin> I have
19:21:37 <Veinor> Hooray!
19:22:17 * Saizan hugs Veinor 
19:22:25 * Veinor hugs back
19:23:32 * Saizan waits for the ghci joke
19:24:30 <orclev> what ghci joke?
19:24:37 <copumpkin> ghci vs hugs
19:24:44 * Axman6 ghci's Saizan 
19:24:46 <orclev> oh
19:25:00 * orclev groans.
19:36:18 <orclev> anyone happen to know if there's a jailbreak for the iPhone 3.1 software yet? I asked over in #haskell-iphone but everyone seems to be dead in there
19:36:29 * copumpkin whispers something
19:37:31 <Axman6> how handy: http://www.khronos.org/files/opencl-quick-reference-card.pdf
19:38:41 <copumpkin> there's something wrong with your API when your quick reference card is several pages long
19:40:43 <SamB_XP> copumpkin: you're actually allowed two pages
19:40:49 <SamB_XP> since cards have two sides, you know
19:41:20 <copumpkin> I figured that
19:41:25 <copumpkin> but this one has more than two pages
19:42:49 <Draconx> maybe it should be called a "quick reference deck"
19:43:14 <Draconx> bonus points if the text is still meaningful when you shuffle it.
19:44:09 <Saizan> ohter bonus points if you manage to sell it as a trading card game
19:44:19 <SamB_XP> lol
19:55:06 <BMeph> Is there a way to "freeze" the RTS, with a certain configuration, to shrink the size and start-up time?
19:57:06 * ksf can't believe it, he got 12 up and no downvote in 4 hours on reddit
19:57:27 <copumpkin> :o
19:57:42 <copumpkin> does it involve narwhals, bacon, and a "dear reddit"?
19:57:52 <ksf> no. but sharpened lambdas.
19:57:55 <ezyang> I never understood why people downvote so much on Reddit.
19:58:30 * Saizan doesn't want to know what narwhals have to do with bacon on reddit
19:58:39 <Saizan> but i'm intrigued.
19:58:39 <Cale> ezyang: I used to downvote a lot, but the signal to noise ratio is so low now that I gave up on voting.
19:58:40 <lament> ezyang: because stuff is usually sufficiently up as is
19:58:40 <jfredett> ezyang: because they're hateful, hateful people.
19:59:04 <ezyang> ha
19:59:16 <SamB_XP> ezyang: it depends on how dumb the thing is ...
19:59:28 <lament> also because of sturgeon's law, yeah
20:00:06 <medfly> if you don't like shitty websites like reddit then just don't follow them
20:00:27 <lament> reddit is pretty cool
20:00:28 <Cale> My criterion was:  vote (if article `interestingTo` Cale then Up else Down)
20:00:36 <ezyang> aha
20:00:46 <lament> but due to sturgeon's law, 90% of stuff submitted to it is crap
20:00:51 <copumpkin> is Cale a constructor of Person?
20:00:58 <Cale> copumpkin: apparently
20:01:00 <ksf> don't downvote for "not interesting"
20:01:02 <ezyang> I've always thought the criterion as 1 = "Yes!", 0 = "Meh", -1 = "Dude, that's even more lame than usual."
20:01:07 <SamB_XP> lament: kind of like newgrounds ?
20:01:17 <SamB_XP> newgrounds has a system to deal with a lot of that
20:01:29 <ksf> downvote for "offtopic" or "use that spealing on 4chan, craptard"
20:01:36 <SamB_XP> or "wrong"
20:01:46 <Cale> If you don't downvote for "not interesting to you", then you're only making use of half of your voting power.
20:01:47 <ksf> (both the spelling and the comment pointing it out)
20:01:53 <Saizan> "spelling"
20:02:15 <Cale> But it's tedious to do.
20:02:33 <medfly> why do you all follow that website anyway
20:02:35 <Saizan> we should clearly automate the task
20:02:48 <Cale> medfly: Because interesting articles are posted there, despite all the junk.
20:02:55 <SamB_XP> Saizan: if we could do that, what would we need reddit for anyway?
20:02:56 * ksf votes stuff that exhibits genuine and original thought up, pontless ego-mongering down and leaves the rest as is.
20:03:00 <medfly> if you didn't vote up, then vote down, saiam
20:03:04 <jfredett> medfly: reddit? Because it's got some good stuff, every now and again.
20:03:06 <medfly> Saizan
20:03:13 <Saizan> SamB_XP: trolls?
20:03:21 <copumpkin> some of the trolls are awesome
20:03:28 <SamB_XP> Saizan: we can get them out of usenet archives though!
20:03:30 <Cale> Yeah, a good "downvote everything on this page that I haven't already upvoted" button would be handy.
20:03:34 <ksf> trolling is an art form.
20:04:00 <Saizan> SamB_XP: i want fresh ones!
20:04:47 * Saizan doesn't actually read reddit apart from what filters to him from the haskell community
20:05:16 <ksf> http://www.reddit.com/r/haskell/comments/9ski4/a_more_approachable_approach_to_category_theory/
20:05:33 <Saizan> like that.
20:05:41 <dolio> The haskell reddit is all right.
20:05:46 <ksf> ...we _do_ have our own haskell subreddit, you know.
20:05:46 <ezyang> ==dolio
20:05:49 <dolio> I don't bother with programming anymore, though.
20:06:03 <ezyang> dolio: I'm getting close to that point. I mostly ignore the comments there, at least
20:06:03 <copumpkin> ezyang: you're dolio?
20:06:10 <ksf> I skim it.
20:06:16 <Cale> Yeah, the haskell subreddit is generally pretty good :)
20:06:18 <ezyang> copumpkin: (==) == agree ;-)
20:06:20 <Saizan> that's old stuff though!
20:06:23 <dolio> Yes, I'm talking to myself right now.
20:06:35 <ksf> there's karma to be had there for spilling rare drops of wisdom amidst the ignorant masses.
20:06:36 <copumpkin> ezyang: ah, I was confused for a moment ;)
20:07:06 <ksf> scan for the frontline of the flames, write something that pleases both sides.
20:07:12 <ksf> instant gratification.
20:07:15 <copumpkin> lol
20:07:37 <copumpkin> I find general programmer attitudes really frustrating, but I keep reading proggit anyway
20:07:42 <copumpkin> I think it's cause I'm dumb
20:08:01 <copumpkin> @quote monoid
20:08:01 <lambdabot> stepcut says: I wish someone had told the designers of XML about monoids :(
20:08:04 <copumpkin> @quote monoid
20:08:04 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
20:08:10 <ksf> no it's because the haskell reddit alone is not big enough to properly procrastinate
20:08:17 <Adamant> ksf: that and $2 will get you a McDonald's coffee
20:08:20 <copumpkin> that too
20:08:32 <Adamant> the karma that is
20:08:55 <copumpkin> @quote neuraxon77
20:08:55 <lambdabot> neuraxon77 says: With a concatenative language the only construct is the monoid, and structuring a language with this in mind makes all types optional
20:09:23 <ksf> ...well I noticed that my comment karma exceeds my link karma, so I'm going to switch priorities for some time.
20:09:38 <Gracenotes> "banana" 10 +
20:09:42 <Cale> That quote seems rather questionable. After all, there's more than one monoid out there.
20:10:04 <copumpkin> Cale: yeah, I @remembered it because I had no clue what he was talking about it and I don't think he did either
20:10:46 <ksf> Saizan, the important thing isn't the link but sharpening lambdas and threatening category theorists.
20:10:47 <Adamant> good, I thought I was the only one confused by that quote.
20:10:50 <copumpkin> http://www.reddit.com/r/programming/comments/9r775/ask_proggit_what_do_you_think_of_when_you_think/c0e5myb
20:11:09 <Gracenotes> hm, .does. Haskell do the optimization: map (func x ++) ["yes", "no"]  ->  let t = func x in map (t ++) ["yes", "no"]?
20:11:31 <Gracenotes> it would fall under CSE... but it might exist partially, I dunno.
20:11:45 <gwern> Gracenotes: the Core knows
20:12:04 <gwern> but we'll have to breach their blackice
20:12:05 <Gracenotes> I'd ask it directly if I could
20:12:30 * ezyang is instantly reminded of /Accelerando/ 
20:12:34 <Saizan> copumpkin: would i be a racist if i commented saying "dynamic types are not a type system"?
20:12:39 <ezyang> no wait, /Neuromancer/ I mean
20:12:40 <gwern> when johnny detonates his AI personality, the firewall will collapse briefly, and we'll be able to jack in and rip their datasilos
20:12:44 <Cale> Gracenotes: yes, it does
20:12:47 <copumpkin> Saizan: you'd be a typist, which is much worse
20:13:03 <dolio> Type theory people say that kind of thing all the time, I think. :)
20:13:18 <Adamant> and they're wrong :P
20:13:22 <copumpkin> oh yeah, I forgot the "e theor"
20:13:29 <Gracenotes> Cale: nice. what's the logic behind that? partial application done to the greatest extent possible?
20:13:40 <copumpkin> Adamant: "wrong" is a strong word
20:13:43 <gwern> dynamic type systems are type systems! they just take a very inclusive view of what is 'compilation' as opposed to 'runtime' :)
20:13:56 <Cale> Gracenotes: There are limitations on it...
20:14:22 <ddarius> dolio: A dynamic type system is a trivial static type system.
20:14:26 <Adamant> copumpkin: they want to study complicated type system and that usually means static, so they have an interest in promoting that worldview :P
20:14:27 <Cale> Gracenotes: It won't share the evaluation of two different subexpressions just because they happen to be the same syntactically, for one
20:14:36 <Cale> Gracenotes: it's just moving the definition of the constant upward
20:14:59 <copumpkin> Adamant: it seems sort of like saying high school algebra is algebra
20:15:01 <Gracenotes> yeah, I know some have clamored for true CSE
20:15:03 <Cale> Gracenotes: It will never move the definition of a constant upward such that it separates two lambdas
20:15:04 <dolio> Sure, if you look at it as a system with a single type. I don't think dynamic typing people would be pleased with that, though.
20:15:06 <copumpkin> it's true, but nobody cares
20:15:25 <Cale> That is, if you have \x -> \y -> let z = f x in g z
20:15:30 <Adamant> copumpkin: that assumes everyone cares about static type systems
20:15:37 <ddarius> Actually, fields aren't algebraic (let alone the real numbers) for one definition of "algebraic"...
20:15:46 <Cale> It will never change that to  \x -> let z = f x in \y -> g z
20:16:01 <Adamant> what I especially care about is that the typing is not weak
20:16:16 <Adamant> and there are strong static and dynamic type systems
20:16:23 <Gracenotes> Cale: how are those semantically different?
20:16:29 <copumpkin> Adamant: why do you care?
20:16:50 <gwern> oh noes, another type holy war
20:16:51 <Cale> Gracenotes: They only differ in terms of time and space usage
20:17:15 <Adamant> copumpkin: I want my program to either detect the bad things that might happen and spit out a compiler error, or stop the program from doing the bad thing
20:17:39 <Adamant> sometimes 1 is necessary, other times 2 is sufficent
20:17:48 <Cale> Gracenotes: If you supply only one parameter, the result of the second is a function which will share the evaluation of z between calls to itself, and z will stay in memory as long as that function remains in scope
20:18:11 <Cale> Gracenotes: The first function will produce a function that will re-evaluate z every time
20:18:59 <Cale> That is, with  \x -> \y -> let z = f x in g z, you get re-evaluation, and with  \x -> let z = f x in \y -> g z  you get sharing.
20:19:12 <Adamant> then again I still program in C when required to, but I don't use it as a go-to language for most things at this point, and that is good
20:19:41 <Cale> Sometimes re-evaluation is better because you're not sure if you're going to call the function ever again and you don't want it to keep z in memory between calls. Of course, sometimes computing z is expensive and you want it shared.
20:20:01 <gwern> Adamant: but surely you use it as a go-to language!
20:20:09 <Cale> Gracenotes: Does that make sense?
20:20:20 <SamB_XP> gwern: go-to!
20:20:28 <Gracenotes> yep, makes sense. And as for the map...
20:20:38 <Adamant> ow
20:20:41 <dolio> Sometimes re-evaluation is better because keeping it around in memory until you next actually use it will use up all your memory. :)
20:20:51 <Adamant> gwern++, but BADDD pun :P
20:20:58 <Gracenotes> the 'func x' is a thunk which gets replaced with its value when evaluated, I suppose
20:21:12 <Cale> The map behaves a little unexpectedly, because it will lift the definition of that subexpression upward in order to share the evaluation
20:21:13 <gwern> Adamant: be grateful I didn't work in a starwars joke about GO-TO
20:21:37 <ezyang> R2GO2?
20:21:46 <Adamant> GO-TO walker
20:21:47 <Cale> The reason that it does that lifting is that it's not splitting up two lambdas which are already adjacent -- the two lambdas are already separated by the map function
20:21:55 <copumpkin> preflex_: seen seydar
20:21:55 <preflex_>  seydar was last seen on #haskell 18 days, 2 hours, 18 minutes and 6 seconds ago, saying: does anyone use geometer's sketchpad?
20:22:28 <copumpkin> you know what I realized I'd like?
20:22:40 <Adamant> copumpkin: ?
20:22:43 <Gracenotes> huh. I guess I am somewhat misinformed about compiler optimizations for partial application
20:22:50 <copumpkin> a categorical recursion scheme problem set in haskell
20:22:57 <copumpkin> just for the fun of it
20:23:16 <copumpkin> "use g_histo to compute X"
20:23:16 <Gracenotes> it does it in a different way than I thought, moving things upward
20:23:16 <monochrom> Don't ask to say. Just say.
20:23:37 <copumpkin> monochrom: it was a rhetorical question
20:23:55 <Cale> Gracenotes: The reason it can't do the "full-laziness transform" is that it creates memory problems, and there's not a good enough heuristic to tell if it's really okay.
20:24:04 <monochrom> I'm exactly targetting rhetorical questions.
20:24:08 <Cale> (space usage can go way up)
20:24:42 <copumpkin> well, you're a rhetoricalist!
20:24:42 <Cale> Gracenotes: but you can write functions for which partial applications are sure to share some of the computation by using let explicitly with a lambda inside the 'in' part
20:25:07 <Gracenotes> mm, and manual CSE in general
20:26:58 <Cale> You can see the difference with:
20:27:00 <Cale> let f x y = product [1..x] + y in map (f 10000) [1..10]
20:27:09 <Cale> let f x = let u = product [1..x] in \y -> u + y in map (f 10000) [1..10]
20:28:04 <FunctorSal> Gracenotes: Cale : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10574#a10574
20:28:23 <mmorrow> (\x -> \y -> let z = f x in g z) is a somewhat bad example though, since other things would happen that'd skew the point
20:28:31 <FunctorSal> same result it seems.
20:28:31 <mmorrow> like, y is dead, and z would be inlined
20:29:00 <mmorrow> (\x -> \y -> let z = f x in g y z z) would be better i think
20:29:02 <dolio> Gracenotes: I don't think that 'map (func x ++) l' is a very difficult case. map gives '(func x ++)' a name and refers to it by that, so it seems like it'd translate pretty straight-forwardly to an updating closure in the STG/Core language.
20:29:13 <Cale> FunctorSal: Possibly after optimisation it discovers that it likes one of the two better, though that breaks the rule as I understood it about when it's free to lift a definition upward.
20:30:13 <Cale> FunctorSal: (though, that core doesn't look like the programs I just gave to me...)
20:30:31 <BMeph> Are rhetorical questions really useful? ;p
20:30:41 <FunctorSal> Cale: Gracenote's original programs (I added the source now)
20:30:59 <Cale> FunctorSal: Oh! Yes, those are equivalent
20:31:14 <Cale> FunctorSal: Because it lifts the t out itself, just like you did manually there.
20:32:22 <Gracenotes> FunctorSal: what's the ghc command for that?
20:32:45 <FunctorSal> Gracenotes: -ddump-simpl
20:32:53 <Cale> Gracenotes: -ddump-simpl or use the ghc-core program from Hackage
20:33:11 <Cale> (which does some other nice stuff like colouring and displaying extra info about optimisations)
20:33:16 <FunctorSal> I tried the latter first but didn't know how to remove the ANSI codes ...
20:33:44 <lispy> Cale: it does coloring?  I've used ghc-core a fair bit and never seen it do anything with color but it has confused my terminal lots
20:34:00 <Cale> lispy: Maybe your terminal doesn't support colour?
20:34:07 <lispy> It definitely supports it
20:34:12 <lispy> My prompt is colorful
20:34:15 <Cale> hmm
20:34:18 <Cale> What terminal program?
20:34:24 <lispy> Terminal.app
20:34:26 <Cale> It works in gnome terminal
20:34:40 <Cale> Ah, probably different colour codes
20:34:51 <FunctorSal> Maybe your pager doesn't support colors
20:34:58 <Cale> Oh, or that.
20:35:00 <lispy> The only weird thing is that I have TERM=rxvt for historic reasons, but everything else works
20:35:30 <SamB_XP> historic reasons ?
20:35:35 <Gracenotes> oh, I think I've enabled -ddump-simpl in ghci before
20:35:59 <FunctorSal> ghci uses the simplifier?
20:36:12 <lispy> my pager is less
20:36:19 <Gracenotes> I don't know, but it can :set it.
20:37:16 <Gracenotes> it uses @ for function call thunks, right?
20:38:04 <FunctorSal> Gracenotes: I think for types
20:38:08 <dolio> @ has to do with types.
20:38:24 <FunctorSal> (core has type lambdas)
20:38:27 <dolio> \ (@ t) means t is a type.
20:38:41 <dolio> foo @ t is application of the type parameter of foo.
20:38:47 <Gracenotes> @ must be the most wildly variable symbol between programming languages :)
20:39:32 <Gracenotes> on the other hand, you have somethling like +...
20:39:36 <FunctorSal> btw why doesn't it evaluate the map?
20:40:00 <FunctorSal> the list is fixed
20:40:19 <lispy> What does it mean in mathematical parlance when someone says 'morally'?
20:40:20 <SamB_XP> maybe it only does that for broken lists ?
20:40:39 <lispy> For example, "foo is morally equivalent to bar."
20:40:42 <monochrom> I think I have never heard "morally" in math.
20:40:57 <SamB_XP> monochrom: spoke too soon, didn't you ?
20:41:07 <FunctorSal> lispy: it means that it isn't equivalent but it can be helpful to think of it as if it was
20:41:07 <mmorrow> FunctorSal: that starts to get into partial eval as opposed to inline+beta-reduce
20:41:26 <FunctorSal> (is not neccessarily equivalent, rather)
20:41:43 <FunctorSal> mmorrow: hmm and no inline for map?
20:42:02 <lispy> FunctorSal: okay. hmm.
20:42:03 <mmorrow> FunctorSal: like "\\y -> let x = sum [0..10000] in (x,y)"
20:42:05 <SamB_XP> FunctorSal: it only inlines when it thinks it'd be a good idea
20:42:22 <mmorrow> FunctorSal: sure it might inline map
20:42:43 <lispy> FunctorSal: I still strugle with the idea that if something is not true, why would you pretend it is to help elucidate something
20:43:13 <SamB_XP> lispy: maybe "compare with" is more accurate than "pretend it is"
20:43:34 <FunctorSal> lispy: maybe the reason why it's not equivalent is technical and not the point in the situation
20:43:41 <mmorrow> FunctorSal: but actually turning that into "let y = func x in [y ++ "yes", y ++ "no"]" is a different matter
20:45:11 <FunctorSal> mmorrow: hmm yes because the inlined map would still be recursive?
20:45:28 <FunctorSal> so is this what the various new compilers do?
20:46:02 <mmorrow> yeah, you'd need to symbolically evaluate it given ["yes","no"]
20:47:30 <mmorrow> FunctorSal: i'm not sure if any current compilers do that or not, i don't think there's one best particular way to go about that
20:50:36 <FunctorSal> could one make a monad that's like Q but any monadic values are guaranteed to have all type syns expanded?
20:50:59 <FunctorSal> ("return" would do expanding)
20:51:09 <FunctorSal> I guess that's a performance nightmare though
20:51:14 <mmorrow> do you mean the TH Q?
20:51:17 <FunctorSal> yes
20:51:40 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.2695
20:51:42 <mmorrow> and you mean for any given Type value, tysyns are guaranteed expanded?
20:51:52 <FunctorSal> yes
20:51:55 <SamB_XP> mmorrow: what other Q is there?
20:51:58 <Saizan> derive has "peephole optimizations" that do something like that
20:52:00 <mmorrow> ddarius: cool
20:52:12 <mmorrow> SamB_XP: just making sure
20:52:42 <mmorrow> FunctorSal: i think that's more a question of the functions that produce/get Types via reify
20:53:07 <mmorrow> rather than the monad itself that these functions happen to return results in
20:53:11 <FunctorSal> mmorrow: 'reify' would be wrapped to (exreify :: Name -> QE Info)
20:53:28 <mmorrow> FunctorSal: hmm, yeah that seems like a way to go about it
20:53:32 <FunctorSal> the monad would just be so you don't forget to expand
20:53:45 <FunctorSal> but I think the expanding return would be too slow
20:53:56 <FunctorSal> (implicit returns are everywhere, no?)
20:54:05 <mmorrow> FunctorSal: i'm not sure though how the monad would be able to make sure that all Types are expanded
20:54:29 <Fragsworth> Is it ok that it seems to take me at least a day or two to learn even one little concept in haskell?
20:54:39 <mmorrow> maybe by hijacking return, and using (everywhere (mkT expandSyns)), but everything won't be (Data a) => a
20:54:41 <ddarius> Putting "expand" into return is likely to violate the monad laws.
20:54:46 <mmorrow> yeah
20:54:46 <copumpkin> Fragsworth: yep
20:54:54 <SamB_XP> Fragsworth: define little?
20:55:15 <FunctorSal> mmorrow: oh right, "return" must be unrestricted
20:56:21 <FunctorSal> another way would be to make a newtype for expanded values, but that'd be inconvenient I think
20:58:04 <FunctorSal> is there any good reason why syns appear in TH anyway? you just care about the semantics of the produced code
20:58:21 <Saizan> couldn't you just expand on splicing and show?
20:58:56 <FunctorSal> Saizan: no, I'm transforming data declarations
20:59:09 <FunctorSal> so fields of synonym type could break the recursion
20:59:29 <FunctorSal> (data List a = Nil | Cons a (ListSyn a))
20:59:34 <mmorrow> FunctorSal: i've got an expandSyns function somewhere, i'll try to find it
21:01:26 <FunctorSal> mmorrow: thanks I think I got one somewhere too ;)
21:02:12 <ivanm> well, _I_ don't! :p
21:02:59 * ddarius wonders if his TH code is still in GHC.
21:03:03 * ddarius doubts it.
21:03:04 <mmorrow> it's non-trivial since you need to do beta-reduction wrt stuff like "(forall a. [(forall b. Maybe b) a]) (Foo Int)" you get when you substitute
21:03:22 <mmorrow> ddarius: what did/does it do?
21:03:49 <ddarius> It was code to allow TH to handle records.
21:04:31 <FunctorSal> mmorrow: yes, I just accumulated the right arguments upon encountering an AppT
21:04:42 <FunctorSal> (for the left recusion)
21:04:56 <FunctorSal> then when you encounter a tysyn, apply it to the accumulated list
21:05:11 <ddarius> It was in GHC 5.4.3 (I think)
21:05:20 <mmorrow> ddarius: heh, nice
21:06:20 <FunctorSal> mmorrow: but how does the 'forall' come in?
21:06:33 <FunctorSal> (how does it need special treatment?)
21:06:42 <mmorrow> FunctorSal: here we go, here's rwbarton's code to do it (which is in lunabot too) http://github.com/rwbarton/oldtype
21:07:26 <FunctorSal> thanks
21:07:32 <mmorrow> FunctorSal: my exapandSyn function uses lunabot's eval to get do dynamic reify to avoid Q, and iirc i have a version that just uses reify somewhere, but i can't find it
21:08:20 <mmorrow> FunctorSal: there're some corner cases that are tricky, but i don't recall exactly what they are
21:08:45 <mmorrow> "type Foo = forall a. Maybe a" is legal for instance
21:10:55 <mmorrow> (forall a. [(forall b. Maybe b) a]) (Foo Int) ====> [Maybe (Foo Int)]
21:11:04 <mmorrow> (not sure if that was clear)
21:11:57 <monochrom> forall is type-level lambda. not special per se. just takes extra work.
21:12:09 <FunctorSal> uh isn't that a kind error?
21:12:18 <FunctorSal> as I see it forall *isn't* type-level lambda
21:12:33 <FunctorSal> @kind (forall b. Maybe b)
21:12:34 <lambdabot> *
21:12:43 <mmorrow> FunctorSal: it is (syntactically) when you expand syns though
21:12:45 <FunctorSal> a lambda should have kind * -> *
21:12:49 <kyagrd> forall is an existential
21:13:01 <FunctorSal> mmorrow: expanded syns are type-level lambdas, yes
21:13:50 <FunctorSal> but for (type List a = [a]), we don't have List Foo = (forall a. [a]) Foo
21:14:04 <FunctorSal> we have List Foo = (lambda a. [a]) Foo
21:14:09 <FunctorSal> seems different
21:14:34 <mmorrow> however to want to phrase it of course, but it's convenient to use the existing
21:14:36 <mmorrow> ForallT
21:14:57 <mmorrow> then you can expand to those, then do lambda-calc-like beta reduction
21:15:13 <FunctorSal> I started making an alternative AST with lambdas, but it's a bit tedious ;)
21:15:25 <mmorrow> heh, yeah ForallT is super convenient here
21:15:26 <FunctorSal> (and type-de-bruijn for local vars)
21:15:55 <FunctorSal> but do you agree forall isn't really lambda?
21:16:12 <mmorrow> yes
21:16:24 <mmorrow> well, if you have type applications it is
21:16:31 <FunctorSal> yes
21:16:32 <mmorrow> "big lambda" or whatever
21:16:37 <FunctorSal> it's lambda wrt specialization probably
21:16:45 <FunctorSal> (forall)
21:16:53 <SamB_XP> here I thought it was more like pi ...
21:17:07 <ddarius>  /\ is a term level, type to term lambda.
21:17:25 <mmorrow> ah, right
21:17:27 <Cale> I've also seen it as a type-level type-to-type lambda.
21:17:42 <FunctorSal> what is type-to-type lambda wrt type application then?
21:18:03 * ddarius usually sees little lambda used.
21:18:05 <FunctorSal> (thought that was /\)
21:18:15 <Cale> FunctorSal: Well, you beta expand...
21:18:21 <Cale> er, reduce :)
21:18:58 <ddarius> FunctorSal: It depends on what type application you mean.  The type applications, such as the ones in core, are at the term level and usually the corresponding lambda is /\.
21:20:04 <ddarius> Usually what I see is: \ = term to term, /\ = type to term, pi = term to type, \ = type to type
21:20:08 <FunctorSal> ddarius: the one denoted by juxtaposition in plain haskell
21:20:49 <Cale> Of course, usually it's possible to tell all those things apart, so you could really just have a single lambda which was all of them.
21:20:55 <FunctorSal> (AppT)
21:21:13 <ddarius> Well, PTSes take that to an extreme and usually just use Pi.
21:21:17 <mmorrow> Cale: yeah, that's how i like to see it. the context makes it clear
21:21:24 <ddarius> FunctorSal: That's a type to type application.
21:21:49 <Cale> The product notation is probably the least straightforward though...
21:22:03 <FunctorSal> I'm not sure what we're debating anymore, but I was just saying that you need type-to-type lambda to expand type synonyms, and "forall" isn't it ;)
21:22:34 <Cale> Well, what it does to my brain is strange, even if it is really just like lambda :)
21:23:06 <monochrom> "morally lambda"
21:23:46 <SamB_XP> Cale: I thought it was just like lambdas type signature ?
21:23:54 <Cale> pi suggests to me that I should think of it as a giant iterated product
21:24:22 <ddarius> Cale: Think classically and it is.
21:24:42 <Cale> Right, I know that I can think of it that way, but... I'm not sure how productive it is to do that :)
21:24:44 <FunctorSal> Cale: the word "product" in type theory confused me for a long time too
21:24:57 <Cale> FunctorSal: Oh, it usually really is a product.
21:24:59 <ddarius> Pi tends to make me think of limit nowadays (and thus preserved by continuous functors)
21:25:10 <FunctorSal> yes it is, but we don't usually think of functions as products ;)
21:25:22 <jfredett> @hoogle getArgs
21:25:22 <lambdabot> System.Environment getArgs :: IO [String]
21:25:30 <FunctorSal> (I don't, anyway)
21:25:53 <Cale> FunctorSal: Well, you can think of iterated products as function spaces, if you like.
21:26:09 <copumpkin> :t sequence getArgs
21:26:10 <lambdabot> Not in scope: `getArgs'
21:26:22 <copumpkin> :t sequence (undefined :: IO [String])
21:26:23 <lambdabot>     Couldn't match expected type `[m a]'
21:26:23 <lambdabot>            against inferred type `IO [String]'
21:26:23 <lambdabot>     In the first argument of `sequence', namely
21:26:28 <Cale> (sort of anyway)
21:27:06 <Cale> I guess they're really just parts of function spaces
21:27:24 <Cale> product over a in A of B  will be the same as  A -> B
21:27:40 <Makoryu> > toLower 'Ü'
21:27:41 <lambdabot>   '\252'
21:27:47 <Makoryu> > 'Ü'
21:27:48 <lambdabot>   '\220'
21:27:59 <monochrom> > text (toLower 'Ü')
21:28:00 <lambdabot>   Couldn't match expected type `GHC.Base.String'
21:28:00 <lambdabot>         against inferred typ...
21:28:08 <FunctorSalad_> *back*
21:28:10 <mmorrow> FunctorSal: ah, i just remembered the tricky part of it. so since we're re-using the ForallT constructor for convenience, it can mean two different things in two different contexts, and there's no way to tell the two contexts apart other than to keep track of them yourself. so (ForallT [a] (f a) `AppT` c) means (ForallT [a] (f a c)) if (ForallT [a] (f a)) *didn't* come from a tysyn you just expanded *OR* the tysyn you just expanded was e
21:28:10 <mmorrow> .g. (type Foo = forall a f a), but ((ForallT [a] (f a) `AppT` c) means (f c) if you just expanded e.g. (Foo a = f a)
21:28:11 <monochrom> It wants string.
21:28:16 <monochrom> > text ([toLower 'Ü'])
21:28:18 <Cale> But if it's  product over a in A of B_a, then that's something like A -> union over a in A of B_a, restricted such that a is sent to something in B_a.
21:28:18 <lambdabot>   ü
21:28:43 <Makoryu> monochrom: I'm just making sure it does what I expect it to :p
21:28:55 <Cale> FunctorSalad_: oh, you missed that I said that they're sort of related in that product over a in A of B  is the same as A -> B
21:29:16 <monochrom> Sorry I have been writing for conservative mathematicians these few days, and so I have redundant parentheses in text ([stuff]) and P(P(X)).
21:29:17 <Cale> blah
21:29:19 <FunctorSalad_> mmorrow: so I was right being suspicious of abusing it? ;)
21:29:33 <Cale> oh, good, still here :)
21:30:29 <Cale> monochrom: another funny thing is to see composition associate the wrong way :)
21:30:31 <FunctorSalad_> Cale: yes I see how A -> B = pi_{a in A} B, I just don't picture a function as an enormous tuple ;)
21:30:56 <Cale> f∘g(x) -> (f . g) x
21:31:24 <mmorrow> FunctorSalad_: the solution is to reduce *immediately* upon expansion, then continue to expand/reduce recursively, rather than fully expand top-down, then reduce bottom-up, since you loose track of which ForallTs are which in the latter case
21:31:31 <Cale> FunctorSalad_: right, that's why I mentioned the pi notation makes my brain do strange things
21:31:44 <monochrom> The relative precedence between composition and application is probably a sticky and not-thought-out point.
21:32:05 <Cale> (because it looks like you're expressing an enormous tuple, but it's really a function)
21:32:34 <FunctorSalad_> mmorrow: what I said about accumulating the right arg when recursing into the left arg of AppT?
21:32:35 <Cale> monochrom: often, yeah
21:32:46 <Cale> monochrom: Usually I'll throw in extra parens
21:33:00 <mmorrow> FunctorSalad_: i'm trying to think if that's ok currently
21:33:47 <mmorrow> type A = forall a. B a; type B a = Maybe a; expand [t|B A|]
21:34:05 <FunctorSalad_> monochrom: in category theory it's even common to notate both composition and application by space ;)
21:34:26 <mmorrow> FunctorSalad_: i think that test-case should distinguish between correct/incorrect expansion algos
21:34:27 <copumpkin> or even lack of space, I think?
21:34:39 <FunctorSalad_> GF(f) (for G,F functors, f morphism)
21:35:10 <copumpkin> I saw something saying that a monomorphism is gf == gh -> f == h
21:35:11 <FunctorSalad_> mmorrow: ok
21:35:39 <Cale> Composition and application are *sort of* the same thing
21:35:50 <mmorrow> FunctorSalad_: so the correct expansion is (forall a. Maybe a) rather than (Maybe (forall a. Maybe a))
21:36:30 <Cale> Certainly in the category of sets, you can just decide that an element of A is a function 1 -> A, and then composition and application are identical.
21:36:48 <copumpkin> ah interesting
21:36:49 <Cale> But it doesn't work out as nicely with groups.
21:36:54 <mmorrow> FunctorSalad_: goo, i meant you need to expand recursively fully, *then* ... hrm now i'm confused :) but that test-case i think captures the trickiness
21:37:38 <Cale> (I guess you could identify elements of groups with group homomorphisms Z -> G, though)
21:37:47 <mmorrow> errr, wait maybe the correct expansion of that *is* (Maybe (forall a. Maybe a))..
21:37:59 <copumpkin> does CT have any specific notion of equality?
21:38:10 <mmorrow> FunctorSalad_: anyways, iirc rwbarton's is correct
21:38:14 <copumpkin> for the mono/epi thing, for example
21:38:15 <SamB_XP> Chrono Trigger?
21:38:15 <SamB_XP> eh?
21:38:17 <Cale> copumpkin: It inherits one.
21:38:31 <FunctorSalad_> mmorrow: (Maybe (forall a. Maybe a)) seems right
21:38:36 <Cale> copumpkin: Normally equality is taken as something from the underlying logic, even.
21:38:36 <mmorrow> yeah, i think so too
21:39:02 <mikste> > let op x = fromJust $ findIndex (> x) $ iterate (*10) 1 in op 1410065408
21:39:04 <lambdabot>   10
21:39:18 <monochrom> equality is considered a given.
21:39:18 <Cale> Though making use of equality directly is often not really in the spirit of category theory.
21:39:22 <copumpkin> module CT {A : Something} (_==_ : Rel A) where
21:39:52 <Cale> Usually you want to compare things up to some sort of equivalence (which might involve the equality in its definition)
21:40:18 <orbitz> So STM in .net looks neat, still weaker than Haskell though
21:41:04 <FunctorSalad_> up-to-isomorphism extremism seems to cause lots of bureaucracy with all the congruence and coherence properties you need to prove, though
21:41:11 <orbitz> i was thinking, perhaps you could have a non pur elanguage, but functions with side effects have a special type, liek IO a, and any functin that uses something that returns IO a is forced to be IO a.
21:41:32 <FunctorSalad_> e.g. I think I prefer categories with chosen products instead of "has products"
21:41:44 <SamB_XP> orbitz: isn't there one of those already?
21:41:50 <SamB_XP> named, perhaps, Haskell?
21:41:51 <orbitz> what's it called?
21:42:00 <orbitz> i don't beleiv eit
21:43:17 <Cale> FunctorSalad_: Yeah, the coherence properties begin to become a serious technical issue for higher-dimensional category theory.
21:43:20 <SamB_XP> you can't even spell
21:43:32 <SamB_XP> Cale: doesn't that make the diagrams way harder to read ?
21:43:45 <Makoryu> orbitz: I can't wait for CFLAGS ricers to benchmark .NET's new copying STM scheme, and completely freak out when they discover it's no faster or easier than locks
21:44:08 * FunctorSalad_ hugs his 1-categories ;)
21:44:08 <jfredett> :w
21:44:09 <Cale> SamB_XP: well, sort of, though you usually focus on only a few dimensions at a time, or have corresponding diagrams at all dimensions, or something.
21:44:14 <jfredett> oops. wrong window.
21:44:35 <SamB_XP> I mean, those two-dimensional diagrams are hard enough to follow
21:44:37 <monochrom> Made me thought :w was a new emoticon :)
21:45:02 <SamB_XP> a 4d one would be darn-near mind-breaking
21:45:07 <Cale> SamB_XP: Oh, "higher-dimensional" just means that there are more arrows between the arrows, and then arrows between the arrow-arrows and so on.
21:45:15 <SamB_XP> 5d would be impossible
21:45:41 <Cale> SamB_XP: You might think of the arrows between the arrows as 2-dimensional "sheets" which join the arrows together.
21:45:43 <FunctorSalad_> Cale: yes but it leads to diagrams in the corresponding dimension
21:45:47 <mmorrow> FunctorSalad_: ok, so i think the *real* correct way is to expand/reduce _bottom-up_
21:45:54 <mmorrow> B (B A) ==> B (B (forall a. B a)) ==> B (B (forall a. Maybe a)) ==> B (Maybe (forall a. Maybe a)) ==> Maybe (Maybe (forall a. Maybe a))
21:45:57 <orbitz> Makoryu: no easier because you still hav eot be smart enough to annotate yoru code?
21:45:57 <SamB_XP> Cale: already on it ;-P
21:46:05 <Cale> SamB_XP: and then the arrows between those as 3-dimensional surfaces, and so on.
21:46:19 <SamB_XP> Cale: volumes, actually
21:46:27 <Cale> yeah, volumes, right ;)
21:46:34 <mmorrow> FunctorSalad_: gah, this test-case actually doesn't distinguish correct/incorrect
21:46:48 <Cale> Looking down from infinite dimensions, everything is a surface ;)
21:46:52 * mmorrow finds the one he and rwbarton used initially
21:47:34 <FunctorSalad_> mmorrow: wait I'll rewriteup my version
21:47:46 <FunctorSalad_> thought it worked
21:48:05 <mmorrow> here we go
21:48:15 <mmorrow> type A x = [x]; type B f = forall x. f x; type C f = f Integer
21:48:20 <Cale> SamB_XP: I guess why I said 3-dimensional surfaces is that I want to bend them a bit in the 4th dimension so that parallel ones don't overlap :)
21:48:38 <mmorrow> having non-* args + foralls in syns is the tricky combo
21:49:03 <SamB_XP> Cale: okay, stop trying to break my head
21:51:52 <Cale> Apparently an infinity-category is the same thing as a topological category (restricted to some suitably nice sort of topologies), where that just means that instead of a set of objects and a set of arrows, those are topological spaces, and the source and target functions, the function which sends an object to its identity map, and compositions are all continuous
21:52:16 <Cale> Don't ask me to explain that yet though, I don't really understand how it's the same thing.
21:52:55 <Cale> So somehow all that higher dimensional structure is replaced with topological structure on the objects and arrows.
21:53:33 <monochrom> I wonder how suddenly openness comes into the picture.
21:54:41 <Cale> Yeah, it seems a bit bizarre to me still. I'm working toward understanding that :)
21:55:08 <Cale> (but I don't really know all that much about n-categories yet)
21:57:48 <FunctorSalad_> mmorrow: another thing: don't we need to break cycles somehow? (data decl -> constructor -> type -> ConT -> (reify) -> data decl -> ....)
21:58:01 <FunctorSalad_> since the reify will force stuff
21:58:15 <mmorrow> FunctorSalad_: since tysyns can't have cycles you're ok
21:58:27 <mmorrow> with newtypes you do
21:58:35 <FunctorSalad_> but won't recursive expansion loop on the datatypes anyway?
21:59:10 <mmorrow> FunctorSalad_: just expanding the tysyns won't loop you
21:59:17 <FunctorSalad_> or wait, I think you just leave ConT's that reify to data decls alone
21:59:42 <mmorrow> right (but also expand any tysyns therein)
21:59:51 <FunctorSalad_> (I once tried to make a nameless AST and it looped :))
21:59:55 <mmorrow> heh
22:00:18 <FunctorSalad_> you can probably purify it somehow with sharing
22:00:33 <FunctorSalad_> but it gave me a headache
22:01:10 <FunctorSalad_> (I mean an AST where you don't have (ConT Name), but (DataT (DataDecl)))
22:01:21 <FunctorSalad_> the Q seemed to strictify it
22:02:13 <FunctorSalad_> (which is bad because it's an infinite structure)
22:02:16 <gwern> @remember ReinierLamers If we keep up the current pace of performance hacking, darcs will be complete before you even hit the enter key in a few years
22:02:17 <lambdabot> It is forever etched in my memory.
22:02:54 <monochrom> I think I saw it quite some time ago.
22:02:55 <gwern> @flush
22:03:16 <gwern> nameless AST? oh the jokes...
22:03:40 <monochrom> Please tell me the jokes!
22:03:44 <FunctorSalad_> gwern: ?
22:03:59 <FunctorSalad_> age, sex, type?
22:04:14 <FunctorSalad_> (that was horrible)
22:04:36 <gwern> oh, I'd tell you, but I dare not name it
22:04:43 <monochrom> haha
22:05:44 * FunctorSalad_ feels stupid
22:06:13 <FunctorSalad_> maybe you pronounce AST differently
22:06:51 <FunctorSalad_> in germany "Ast" means "branch (of a tree)"
22:07:06 <dolio> You don't just say the letters?
22:07:12 <FunctorSalad_> (these trees that grow outside)
22:07:39 * Axman6 wonders if mast is related to ast
22:08:02 <ivanm> Axman6: you mean as in mast of a tree?
22:08:05 <ivanm> s/tree/ship/
22:08:06 <dolio> Then again, I always thought DSL was just pronounced by the letters, too. I'd never thought of "dizzle".
22:08:13 <ivanm> dolio: same
22:08:13 <Axman6> ship, yes
22:08:25 <ivanm> and I wonder how you get "official" pronounciations :s
22:08:33 <monochrom> TCL is a DSL  <duck>
22:08:33 * ivanm still doesn't get calling SQL "sequel" :s
22:09:02 * mmorrow refuses to call SQL sequel
22:09:12 <ivanm> well, I still have nfi what a DSL is, and how an EDSL differs from a well-defined specialised API
22:09:17 <Makoryu> ivanm, mmorrow: I hear you there
22:10:21 * Axman6 really wishes someone would rewrite macports in haskell instead of TCL
22:10:40 <dolio> And EDSL is just when your API is good enough that it's pretty close to what you'd write if you made a non-E DSL.
22:10:41 <ivanm> Axman6: and that someone is.... YOU!
22:10:49 <Makoryu> Axman6: That would be strictly awesome
22:11:08 <Makoryu> Axman6: Of course, they're writing it in C instead
22:11:10 <Axman6> i've tried starting a project, but i don't have a clue how to do it, or the time, and no one seemed interested
22:11:27 <ivanm> dolio: did you miss sending a message? you started with "And EDSL..." :s
22:11:50 <dolio> No, my fingers just decided there should be a 'd' there.
22:12:00 <monochrom> Give me $5000 so I can buy a MacBook Pro and an iPod Touch and accessories, then I will be interested!
22:12:05 <ivanm> dolio: heh
22:12:16 <ivanm> dolio: right, so what is a non-E DSL?
22:12:30 <Axman6> you don't need $5000. half that will probably get you an MBP
22:12:33 <pastah> i have a bug to report concerning the haskell platform
22:12:36 <ivanm> (since IIRC, the people at the DSL conference couldn't even define it...)
22:12:43 <ivanm> pastah: :o
22:12:47 <ivanm> that's impossible! :p
22:12:53 <Makoryu> monochrom: In MacPorts? It's a package management system for OS X
22:12:53 <Axman6> pastah: i think they may have a trac somewhere
22:13:04 <pastah> the librare "editline" is not included in the dependency check done by ./configure
22:13:11 <pastah> *library*
22:13:23 <Axman6> pastah: i don't think it should be, since ghci uses haskeline
22:13:41 <Makoryu> Axman6: OR DOES IT?
22:13:43 <pastah> Configuring the editline-0.2.1.0 package failed
22:13:45 <pastah> make: *** [build.stamp] Error 2
22:13:46 <monochrom> "and an iPod Touch" "and accessories"!  You don't think extra power plugs are free, do you?
22:14:10 <ivanm> Axman6: IIRC some other lib wants it...
22:14:18 <Axman6> like the editline lib :P
22:14:48 <ivanm> well, I don't have it installed, so I don't think anything I have needs
22:14:57 <ivanm> * it
22:15:07 <dolio> It's a language that's tailored for building solutions or expressing constructs in some problem domain.
22:15:26 <dolio> Possibly by experts in that domain who aren't programmers, in general.
22:15:31 <dolio> Or something of that sort.
22:15:45 <ivanm> heh
22:15:54 <ivanm> so probably not turing complete?
22:16:05 <ivanm> e.g. graphviz's Dot could be described as a DSL?
22:16:21 <gwern> dolio: so, R, then?
22:16:27 <sohum> ok this is probably a really dumb question, but how does one thread state through a happy-generated parser? I thought of using a monad, but the {% } syntax doesn't seem to give you access to the result of the previous steps
22:16:36 <dolio> I don't really know either of those. :)
22:16:41 <ivanm> dolio: heh
22:16:53 <pastah> hmm... thiks kinda sucks... i can't install ghc + platform in ubuntu WITHOUT installing the distros standard ghc packages first
22:16:57 <dolio> SQL would probably be classed as a DSL, although I don't know how well that fits into my defintion. :)
22:17:07 <ivanm> *nod*
22:17:21 <gwern> pastah: weord. I didn't have that issue
22:17:27 <Axman6> pastah: ghc needs ghc to compile. does ubuntu compile everything?
22:17:44 <ivanm> Axman6: I doubt it
22:17:48 <ivanm> binary distro
22:18:15 <gwern> is he compiling ghc?
22:19:40 <Makoryu> Too bad GHC doesn't have a bytecode backend of some kind for bootstrapping purposes
22:20:05 <Makoryu> I guess C sort of counts, but eh.
22:20:27 <Cale> pastah: If you can install GHC, you can basically ignore the platform. It's more something intended for the distro people.
22:20:33 <ivanm> yeah, they need to make another C-only release to simplify bootstrapping
22:20:37 <hiredman> pffft, C
22:20:44 <ivanm> Cale: well, and people looking for recommended libs
22:21:10 <pastah> Cale: i want to use the platform to get the "generic" OpenGL-version
22:21:13 <Cale> pastah: On Ubuntu, I just install the generic linux binary of GHC, and then cabal-install, and from there, you're set, because you can use cabal-install to install anything else you might need.
22:21:20 <pastah> (= the one that 'everyone else' uses)
22:21:48 <Mortoc> hey, sorry for the noob question, but I can't seem to find anything online about this... how to I recreate the enum functionality from C++ esque languages?
22:21:50 <Cale> (note: not ubuntu's GHC binary, since that's really really old)
22:22:17 <monochrom> 6.8
22:22:32 <Cale> Mortoc: data MyEnumeration = Foo | Bar | Baz deriving (Eq, Ord, Show, Enum)
22:22:37 <ivanm> Mortoc: by creating a new algebraic datatype and creating the appropriate instances
22:22:44 <ivanm> as Cale just demonstrated ;-)
22:22:47 <mmorrow> and then use toEnum/fromEnum
22:22:55 <Axman6> :t toEnum
22:22:56 <lambdabot> forall a. (Enum a) => Int -> a
22:22:59 <Axman6> :t fromEnum
22:23:00 <lambdabot> forall a. (Enum a) => a -> Int
22:23:03 <pastah> Mortoc: note Cales 'deriving Enum', that gives you what you want
22:23:13 <Axman6> > toEnum 7 :: Word
22:23:13 <Mortoc> ahh ok, thanks
22:23:14 <lambdabot>   7
22:23:16 <pastah> Mortoc: in ghci: >:i Enum
22:23:19 <Cale> Well, depending on what you really do want :)
22:23:39 <Axman6> Mortoc: having Enum means you can also use [a..b]
22:23:43 <Cale> If all you want is a new type with a few values in it, and you don't care about the mapping to/from numbers, you can leave the Enum off
22:23:46 <Axman6> :t enumFromTo
22:23:47 <lambdabot> forall a. (Enum a) => a -> a -> [a]
22:23:51 <Cale> But yeah, it's convenient
22:23:55 <mmorrow> might as well derive (Bounded) too
22:24:02 <Axman6> > enumFromTo 1 10
22:24:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:24:17 <Cale> > [1..10]
22:24:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:24:18 <Axman6> > toEnum (-3) :: Word
22:24:19 <lambdabot>   * Exception: Enum.toEnum{Word}: tag (-3) is outside of bounds (0,1844674407...
22:24:21 <mmorrow> , [minBound..maxBound] :: [Bool]
22:24:22 <lunabot>  [False,True]
22:24:25 <mmorrow> , [minBound..maxBound] :: [Ordering]
22:24:27 <lunabot>  [LT,EQ,GT]
22:24:29 <Axman6> > toEnum (-3) :: Integer
22:24:30 <lambdabot>   -3
22:24:39 <Axman6> > toEnum minBound :: Integer
22:24:40 <lambdabot>   -9223372036854775808
22:24:59 <Cale> The fact that toEnum and fromEnum use Int instead of Integer is yet another silliness.
22:25:31 <dolio> Yeah, what's the deal with that?
22:25:35 <Cale> > fromEnum (product [1..100] :: Integer)
22:25:36 <lambdabot>   0
22:25:41 <FunctorSalad_> what is to be expanded in your A/B/C test case? ;)
22:25:49 <Makoryu> Cale: And ignoring it just because "everyone will move to 64 bit" is a state of denial
22:25:53 <dolio> > toEnum 5 :: Integer
22:25:54 <lambdabot>   5
22:25:56 <FunctorSalad_> <mmorrow> type A x = [x]; type B f = forall x. f x; type C f = f Integer
22:26:03 <Axman6> > toEnum maxBound :: Integer
22:26:04 <lambdabot>   9223372036854775807
22:26:04 <dolio> Considering Integer is an Enum, it seems like a no-brainer.
22:26:14 <Cale> Makoryu: 64 bits is still tiny
22:26:17 <Axman6> > fromEnum (9223372036854775808 :: Integer)
22:26:18 <lambdabot>   -9223372036854775808
22:27:07 <Cale> The next number is worse, since at least -9223372036854775808 == 9223372036854775808 in Int ;)
22:27:18 <mmorrow> FunctorSalad_: i can't remember what the actual test-case was, but i remember it used those three :/
22:27:24 <bogner> do the debian-haskell people hang out here? you guys have done a fantastic job lately. I just want to say thanks.
22:28:24 <Gracenotes> what version of GHC is on Debian now?
22:29:26 <bogner> 6.10.4 I believe
22:29:58 <Gracenotes> hm.. I guess Ubuntu hasn't caught up
22:30:04 <monochrom> http://packages.debian.org/search?keywords=ghc6&searchon=names&suite=unstable&section=all
22:30:11 <Gracenotes> although I'm pretty sure the .debs would work anyway
22:30:17 <FunctorSalad_> mmorrow: here's my accumulating variant http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10582#a10582
22:30:47 <monochrom> http://packages.ubuntu.com/search?keywords=ghc6&searchon=names&suite=karmic&section=all
22:31:07 <bogner> Gracenotes: karmic has 6.10.4
22:31:16 <monochrom> See my urls
22:31:47 <Gracenotes> hm, jaunty is stuck in 6.8
22:32:05 <monochrom> karmic is in beta and will be official in just 20 days.
22:32:14 <Gracenotes> well, I'll be getting my 6.10 on the 30th!
22:32:26 <Gracenotes> plus a couple of other updates I've wanted
22:32:51 <monochrom> I'm looking forward to Fraktur letters.
22:32:55 <Cale> and so Ubuntu probably won't get 6.12 for at least another 6 months if not 12, even though it's probably coming out in a similar time frame as karmic.
22:32:58 <bogner> Gracenotes: like haddock not being 0.8 anymore? karmic makes some serious improvements
22:33:07 <gwern> Gracenotes: well, just avoid L
22:33:14 <Gracenotes> yeah. not just Haskell
22:33:21 <gwern> totally broke my desktop and laptop for weeks until I reinstalled them
22:33:43 <Gracenotes> L?
22:33:46 <mmorrow> FunctorSalad_: that looks good, except for one thing. in substInType you need to remember the forall-bound vars of each ForallT you recurse into
22:33:53 <gwern> I tried to fix them myself, but I was defeated by how the bootup had been completely trashed by the upstart switch
22:34:00 <gwern> Gracenotes: whatever is bleeding-edge right now
22:34:12 <Gracenotes> there are many bleeding-edge things. uh.
22:34:25 <monochrom> Oh, L means what comes after Karmic.
22:34:49 <mmorrow> FunctorSalad_: so you don't forget about the bound `a' in (G a) in "subst [(a,Int)] (forall a. F (forall b. G a))"
22:35:01 <Gracenotes> ah, okay. damn lemurs.
22:35:06 <monochrom> M will give you assignments and Q will give you cars with weapons and champagne
22:35:31 <Gracenotes> okay, here is my unusuable-subset-of-C compiler, now generates MIPS :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10581
22:35:39 <fooman> Lascivious Lemur
22:36:04 <FunctorSalad_> mmorrow: I am preventing shadowing, but you're right in that I don't expect capture
22:36:13 <sohum> ok this is probably a really dumb question, but how does one thread state through a happy-generated parser? I thought of using a monad, but the {% } syntax doesn't seem to give you access to the result of the previous steps
22:36:13 <Cale> Meanwhile, L will merely foil your plans to create a new world order with your ability to kill anyone just by imagining their face and writing their name.
22:36:15 <FunctorSalad_> mmorrow: (I'm trusting TH to have uniquified everything)
22:36:24 <Gracenotes> not like MIPS is the assembly programming language of the future, but it's what I know at the moment
22:36:57 <mmorrow> FunctorSalad_: it's pretty easy to add a bound-var list/Set though, it can't hurt
22:37:13 <Gracenotes> now I should actually work on what's been assigned to me this week in Java
22:38:11 <gwern> Cale: I was reading the american script of death note today
22:38:14 <gwern> it was terrible
22:38:19 <mmorrow> FunctorSalad_: oh wait, since you're only substituting a single (Name,Type) pair at a time you're ok
22:38:29 <Cale> Heh, american script?
22:38:31 <monochrom> You likely can't see 𝔉 now, but once in Karmic you will. Fraktur capital F, U+1D509. Visit also http://www.vex.net/~trebla/u.html
22:38:39 <Cale> monochrom: I can see it.
22:38:41 <mmorrow> FunctorSalad_: (since you just bail upon seeing a shadowing)
22:39:09 <gwern> Cale: yes. in it, light is the good guy, there are no shinigami and there is no misa
22:39:09 <monochrom> Then you are ready for my bleeding-edge writing!
22:39:18 <FunctorSalad_> mmorrow: but I fail on something like (subst (a,b) (forall b. a))
22:39:21 <Cale> gwern: Whaaaaaaat
22:39:37 <mmorrow> FunctorSalad_: yeah, you probably want to subst a [(Name,Type)] at a time
22:39:59 <mmorrow> FunctorSalad_: right, that too
22:40:24 <monochrom> Sounds like someone did an abstract interpretation when translating Death Note to Americanese.
22:40:38 <Cale> gwern: Then again, if I don't even like it when things are just dubbed, how can I be expected to tolerate a cultural adaptation?
22:40:40 <gwern> Cale: I'm not even kidding. light's mother is murdered by criminals, and that's his motive to become kira. the death note is evil, and at the end he has lost his memories - but instead of then killing L, he abandons the note he left for himself, thereby vindicating himself for his crimes
22:40:49 <FunctorSalad_> mmorrow: I thought the variables appearing in a type synonym declaration are unique, though
22:41:09 <FunctorSalad_> (and the ones bound by forall too, hopefully)
22:41:11 <gwern> oh yes, and he's named Luke
22:41:16 <Cale> gwern: Well, wasn't Light always the good guy? ;)
22:41:35 <mmorrow> FunctorSalad_: they probably are
22:41:38 <FunctorSalad_> mmorrow: but you're right I might want to correct it in case the user passes his own AST
22:41:46 <FunctorSalad_> (not obtained from TH)
22:41:51 <gwern> Cale: I always wanted to say that, but by the end it's hard to root for light
22:42:06 <mmorrow> FunctorSalad_: in the general case, you'd want a renameType function too
22:42:28 * Cale was rooting for kira all teh way. I was hoping there'd be one last twist right up to the end. :)
22:42:44 <gwern> Cale: well, there is, in a way. near only won by cheating
22:42:53 <Cale> yeah
22:44:13 <gwern> Cale: I have an essay about the ending and who won :) http://community.haskell.org/~gwern/static/Death%20Note%20Ending.html
22:44:53 <monochrom> Why do people put their fetishes on haskell.org?!
22:45:03 * gwern lies. I actually wrote that essay in the last 10 seconds; as a seed AI approaching the singularity, I can do that sort of thing
22:45:50 <FunctorSalad_> mmorrow: oops. I still have to re-AppT everything left in the accumulator at the end
22:46:00 <monochrom> DrSyzygy puts his fetish on haskell.org too. His is inflicting category theory lectures to his students.
22:46:30 <mmorrow> sohum: the haskell-src package has an example (although that has a hand-written lexer rather than an alex one)
22:46:34 <monochrom> Perhaps I should do that too.
22:47:01 * monochrom records his voice saying "exterminate all humans" and prepares to upload.
22:48:58 <gwern> monochrom: hey, if you know of a free hosting service with darcs which I can keep my repo and gitit on...
22:49:05 <gwern> I'll gladly inflict my wiki on it
22:49:07 <monochrom> We should set up a betting pool on when ghc 6.12 comes out. :)
22:49:46 <gwern> only if it's a tontine
22:50:16 <monochrom> What do you need darcs and gitit for a wiki? Even geocities would suffice!
22:50:58 <gwern> geocities? you mean that site on the butcher's block?
22:52:45 <gwern> Cale: my essays are also places to use words I don't normally get a chance to use
22:52:49 <gwern> like 'quondam'
22:53:34 <gwern> one day, I hope to come up with a way to use the phrase 'quondam Gundam'
22:53:45 <sohum> mmorrow: thanks
22:53:53 <sohum> > let a = False in let a = True in a
22:53:54 <lambdabot>   True
22:54:05 <Axman6> quantum state!
22:54:09 <Axman6> >_>
22:54:35 <Axman6> a is both True AND False, depending on where you observe it
22:56:02 <Rotaerk> @src mfix
22:56:02 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:56:02 <monochrom> "While the quondam Gundam was about Zeon, the present series hitherto thereof focuses on newtypes."
22:56:45 <Axman6> "hitherto thereof"? that sounds terrible
22:56:48 <monochrom> "While the quondam Gundam was about Zeon, the present series hitherto thereof focuses on newtypes deriving."
22:57:06 <FunctorSalad_> can a forall type ever be applied to something?
22:57:43 <Gracenotes> to a research paper topic?
22:58:02 <FunctorSalad_> @kind (forall a. c a) Int
22:58:03 <lambdabot> Not in scope: type variable `c'
22:58:16 <FunctorSalad_> @kind forall c. ((forall a. c a) Int)
22:58:16 <lambdabot>     Kind error: `forall a. c a' is applied to too many type arguments
22:58:16 <lambdabot>     In the type `(forall a. c a) Int'
22:58:16 <monochrom> Rotaerk: http://www.haskell.org/haskellwiki/MonadFix is the best article on mfix.
22:58:29 <FunctorSalad_> @kind forall (c :: * -> * -> *). ((forall a. c a) Int)
22:58:30 <lambdabot>     `c a' is not applied to enough type arguments
22:58:30 <lambdabot>     Expected kind `*', but `c a' has kind `* -> *'
22:58:30 <lambdabot>     In the type `(forall a. c a) Int'
22:58:51 <FunctorSalad_> apparenlty the left arg of an AppT must always be fully applied?
22:59:00 <Rotaerk> i'm just a little confused by this implementation of mfix http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-State-Lazy.html#State
22:59:04 <FunctorSalad_> err no nevermind that last one
22:59:37 <Rotaerk> particularly, what is the a in (f a)
22:59:43 <FunctorSalad_> but a "forall ..." can't be applied, right?
22:59:48 <monochrom> It is best to spec out what it should do before reading how it is codified.
23:00:31 <FunctorSalad_> monochrom: I'm just asking because I'm wondering whether my TH function needs to handle it
23:00:47 <monochrom> I mean the mfix code.
23:01:35 <monochrom> But I have never seen "(forall a. a->a) Int" in haskell code.
23:01:37 <Gracenotes> FunctorSalad_: well.. you can make data F b = forall a. F (C a b), right... but that's not direct...
23:02:11 <monochrom> (Outside haskell code, I am more than glad to do it!)
23:02:38 <FunctorSalad_> Gracenotes: I mean in a type expression
23:02:49 <Rotaerk> hmm, well what mfix does isn't central to my issue with it... i just don't get how it can refer to a before it exists
23:03:01 <Rotaerk> let (a, s') = runState (f a) s
23:03:23 <Rotaerk> thinking that's a mistake
23:03:37 <monochrom> It is correct.
23:04:06 <monochrom> > let x = ('x' : x) in x
23:04:08 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
23:04:32 <Rotaerk> hmm interesting
23:04:41 <monochrom> This shows that it is correct syntax and good semantics to "refer to x" "before" it "exists".
23:04:54 <Rotaerk> yea
23:28:57 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
23:28:57 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
23:43:14 <kamatsu> does anyone know any good books on category theory for haskell programmers?
23:44:11 <kamatsu> i keep trying to penetrate it, but i think the lack of haskell-targeted examples might be throwing me a little
23:48:06 <Gracenotes> uh. I vaguely recall there are some online posts, no books or anything. one issue is that the Haskell types category isn't necessarily representative (many things are true of it that aren't true by default..)
23:49:05 <Gracenotes> there is this, which some here seem to like: http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
23:49:34 <Gracenotes> not haskell-specific
23:51:46 <Gracenotes> ..and this tops google, http://dekudekuplex.wordpress.com/2009/01/16/
23:52:30 <sproingie>     *  dead pixels
23:52:31 <sproingie> A defective Desktop PC, Notebook, or Tablet PC that is returned for a replacement may be repaired or replaced in Newegg's sole discretion, unless otherwise required by law. While we strive to adhere to our own standard RMA processing times, we cannot guarantee that these times will be met, especially in situations where the item must be sent to the manufacturer for repair. If you have a question regarding returning a Desktop PC, Notebook, o
23:52:37 <sproingie> whups
23:52:45 <sproingie> twitchy middle mouse button
23:54:22 <sproingie> one of these days i'll end up accidentally pasting my bank passwords
23:57:04 * mmorrow loves that thinkpads have 3 buttons
23:57:09 <sohum> is there a way to check what the type of a function has to be? I tried using the function somewhere and stub defining it (fn = undefined), but that just gives :t fn = a
23:57:39 <mmorrow> you can sometimes use implicit parameters for that
23:57:50 <Gracenotes> or explicit arguments
23:58:12 <mmorrow> @type (\f -> (\g h -> h (\_ -> g (\k -> ?omg k f))))
23:58:13 <lambdabot> forall t t1 t2 t3 t4 t5. (?omg::t1 -> t2 -> t3) => t2 -> ((t1 -> t3) -> t4) -> ((t -> t4) -> t5) -> t5
23:58:31 <Gracenotes> except loading modules with top-level definitions, not so much
23:59:00 <Gracenotes> or, actually, *checks* it should work
23:59:23 <mmorrow> @djinn t2 -> ((t1 -> t3) -> t4) -> ((t -> t4) -> t5) -> t5
23:59:23 <lambdabot> -- f cannot be realized.
23:59:48 <mmorrow> @djinn  (t1 -> t2 -> t3) ->       t2 -> ((t1 -> t3) -> t4) -> ((t -> t4) -> t5) -> t5
23:59:49 <lambdabot> f a b c d = d (\ _ -> c (\ e -> a e b))
