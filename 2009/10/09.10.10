00:01:19 <Gracenotes> sohum: the basic idea is, with func a b = g a + g b, or something, make it an argument: func a b g = g a + g b. Or with the -XImplicitParams enabled (a compiler/ghci option), func a b = ?g a + ?g b
00:01:59 <Gracenotes> ?something is an implicit parameter. a function using it can't be called, but the type is displayed like ?omg
00:01:59 <lambdabot> Unknown command, try @list
00:02:07 <Gracenotes> ?botsnack
00:02:08 <lambdabot> :)
00:02:33 <mmorrow> (it can be called with "let ?omg = ... in ..." of course though)
00:02:34 <Gracenotes> while ghci is running, :set -XImplicitParams
00:03:28 <morganson> > ord 'c' + 3
00:03:29 <lambdabot>   102
00:04:16 <mmorrow> @let accum xs = case ?stuff of (fold,(<>),unit) -> fold (<>) unit xs
00:04:17 <lambdabot>   Parse error: VarSym "?"
00:04:22 <mmorrow> aww
00:05:31 <morganson> when I type "ord 'c' + 3" in ghci i get the following message: "Not in scope: `ord'". Does anybody know why?
00:05:38 <mmorrow> :m + Data.Char
00:05:41 <Axman6> Data.Char
00:06:10 * Axman6 thought that ord and chr were prelude functions, but was wrong :(
00:06:13 <sohum> Gracenotes: shiny, thanks
00:06:21 <morganson> thank you
00:06:37 <morganson> It works. I imported Data.Char as you said
00:06:54 <morganson> =)
00:07:17 <FunctorSalad_> mmorrow: think I'll upload the expander to hackage, it's not much for a hackage package, but why let everyone reinvent the wheel...
00:07:51 <FunctorSalad_> an alternative would be a "grab bag of th utils" package, but then nobody will find it ;)
00:08:01 <mmorrow> FunctorSalad_: cool
00:08:02 <Gracenotes> .o
00:08:45 <mmorrow> FunctorSalad_: i've got a grab bag of utils in haskell-src-meta's Utils module (not to say you shouldn't upload a separate pkg of course :)
00:09:24 <mmorrow> FunctorSalad_: also there's a bunch of unorganized stuff in this pkg i'm planning on eventually extracting http://moonpatio.com/repos/kure-th/
00:09:51 <FunctorSalad_> mmorrow: ah didn't know about the Utils module (proving my point ;)))
00:10:14 <mmorrow> FunctorSalad_: :)
00:11:06 <FunctorSalad_> I think I ought to do some testing first though
00:11:20 <FunctorSalad_> (quickcheck instances for Type? another package ;))
00:11:45 <mmorrow> oh that reminds me, just recently figured out and implem the graph algo that was a stopper for deriving a recursive version of that View class given a Name</random>
00:11:54 <mmorrow> should re-visit that
00:12:37 <FunctorSalad_> View class?
00:12:45 <mmorrow> there's actually a module that may be a useful start for the TH quickcheck stuff that i stole from HERA, one sec
00:12:59 <mmorrow> FunctorSalad_: in that (messy) kure-th package
00:13:34 <mmorrow> (half of that package has nothing to do with (its original purpose) of deriving stuff for andygill's KURE)
00:13:42 <FunctorSalad_> (I'd propose making a category "Template Haskell" btw)
00:13:49 <mmorrow> http://moonpatio.com/repos/kure-th/haddocks/
00:13:54 <mmorrow> FunctorSalad_: ooh, good idea
00:14:52 <mmorrow> (the graph algo i needed was: given an SCC and a root, find all possible closed paths root->root)
00:14:56 <FunctorSalad_> I hope a small-package approach wouldn't be consideres as spam, but I think it's better if you can find an appropriate package from the synopsis already
00:15:12 <mmorrow> FunctorSalad_: i think you should definitely upload it
00:18:09 <mmorrow> FunctorSalad_: oh right, forgot about that HERE QuickCheck module, one sec
00:18:14 <mmorrow> , randExp()
00:18:15 <lunabot>  luna: Not in scope: `randExp'
00:18:18 <mmorrow> , randE()
00:18:21 <lunabot>  [(- 3) 7, 7 "Th"]
00:18:22 <mmorrow> , randE()
00:18:25 <lunabot>  "Th" (x4 (x3 "T"))
00:18:26 <mmorrow> heh
00:18:51 <FunctorSalad_> nice
00:19:12 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/ArbTH.hs
00:19:37 <mmorrow> also if may pay to use the derive command-line prog on the TH Syntax module
00:19:47 <mmorrow> derive -dArbitrary -dArbitrary2
00:20:13 <FunctorSalad_> hmm but you need to be careful to limit the size
00:20:17 <mmorrow> (although you'd probably have to make a few minor tweaks to that module that lie, in order to hide the Int#s
00:20:34 <mmorrow> FunctorSalad_: yeah, the module lunabot uses that uses that module is fwiw:
00:20:42 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/RandExp.hs
00:21:01 <mmorrow> sample' (suchThat (arbitrary::Gen Exp) (\e -> let s = gsize e in 20 < s && s < 80))
00:21:10 <mmorrow> hax
00:21:42 <FunctorSalad_> ah, meant prevent the trees from going infinite almost surely
00:22:03 <FunctorSalad_> (which you are doing with the n parameter in the first link)
00:23:11 <mmorrow> oh right
00:23:20 <FunctorSalad_> err or with the 'tree' function apparently
00:24:45 <mmorrow> that first module is almost verbatim from HERA, just hadd to make a few changes (on account of the new QuickCheck or something iirc)
00:25:02 <mmorrow> http://code.haskell.org/HERA/
00:25:27 <mmorrow> some neat TH stuff in there
00:25:37 <morganson> what does this do "=>" before the type definitions? Has it something to do about classes? Or that it can use types from a class? I am a little bit confused. =) but I will probably soon learn more about this interesting language.
00:25:59 <mmorrow> it's part of the syntax of type signatures
00:26:06 <mmorrow> (SomeClass a) => a
00:26:08 <morganson> allright
00:26:09 <mmorrow> (SomeClass a) => a -> b
00:26:17 <morganson> which means?
00:26:22 <mmorrow> @type enumFromTo
00:26:23 <lambdabot> forall a. (Enum a) => a -> a -> [a]
00:26:46 <mmorrow> morganson: (SomeClass a) means that `a' (whatever it ends up being) has to be an instance of SomeClass
00:26:55 <mmorrow> @type 42
00:26:56 <lambdabot> forall t. (Num t) => t
00:27:04 <mmorrow> @type (42::Double)
00:27:05 <lambdabot> Double
00:27:07 <mmorrow> @type (42::Int)
00:27:08 <lambdabot> Int
00:27:12 <mmorrow> @type (42::a -> Int)
00:27:13 <lambdabot>     Could not deduce (Num (a -> Int)) from the context ()
00:27:13 <lambdabot>       arising from the literal `42' at <interactive>:1:1-2
00:27:13 <lambdabot>     Possible fix:
00:27:14 <morganson> allright I think I understand better. Thank you!
00:27:26 <mmorrow> no problem
00:27:29 <FunctorSalad_> *looks up what HERA is*
00:28:07 <FunctorSalad_> wait, is this different from the HERA on hackage?
00:28:11 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_0.png
00:28:13 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_1.png
00:28:17 <mmorrow> yeah, different HERAs
00:28:42 <FunctorSalad_> that sounds cool
00:29:07 <FunctorSalad_> but seems to have fallen into disrepair from the timestamps? :(
00:29:19 <mmorrow> FunctorSalad_: (managing to compile the actual ajaxgui part is very non-trivial (involves hackery, i managed to get it running at one point, but almost surely incorrectly)
00:29:42 <mmorrow> FunctorSalad_: yeah, he took the rewriting ideas from that and turned it into KURE
00:30:02 <mmorrow> there's a HERA wikipage that describes it
00:30:28 <mmorrow> http://haskell.org/haskellwiki/Hera
00:31:21 <mmorrow> FunctorSalad_: yeah, it's too bad it's in disrepair
00:31:30 <en0th> to implement an iterative solving algorithm (i.e. apply some transformations until the problem is solved), should ii involve monads?
00:31:45 <mmorrow> en0th: no necessarily
00:31:49 <mmorrow> s/no/not/
00:32:07 <Cale> Maybe a nondeterminism monad if you have to try different possibilities
00:32:12 <Cale> Otherwise, probably not.
00:32:18 <mmorrow> en0th: if you have a bunch of parameters you'd need to pass around between every function, you might consider the State monad, e.g.
00:33:06 <mmorrow> en0th: alternatively, you could put the thing being transformed *in* the `s' in (State s a) and have solve be
00:33:08 <FunctorSalad_> in principle you can just write a recursive function, but a State monad might be convenient
00:33:13 <mmorrow> solve :: State Thing ()
00:33:32 <mmorrow> modify :: (Thing -> Thing) -> State Thing ()
00:33:36 <FunctorSalad_> (e.g. to have top-level helper functions which know about the state)
00:33:51 <mmorrow> execState :: State Thing () -> (Thing -> Thing)
00:34:39 <Cale> I would start with a plain function, and maybe refactor to using the state monad if it really looked like it would clean things up (a good sign is if you're screwing around with pairs to thread what would be the state along)
00:35:15 <en0th> the problem is that i can't really get grip with monads. i understand what functors are for, but monads are still beyond my scope
00:35:24 <Cale> Yeah, then don't worry about it.
00:36:19 <en0th> i mean, i would like to understand why i need it. Say, if i would like to make an abstract solver, then i'll need them i bet
00:36:53 <Cale> If you want a solver which is going to do lots of backtracking, then a nondeterminism monad (like the list monad) can be rather nice.
00:37:26 <Cale> StateT over a nondeterminism monad can also be a good choice
00:37:37 <Cale> But it depends on the sort of solving that you're doing.
00:38:45 <Cale> It's probably not best to say "hmm, I'm going to use a monad for this", and then set out to look for a library which happens to be a monad. Look for a library which helps you solve your problem, and if it's a monad, then that's good, you can use the stuff in Control.Monad with it.
00:39:37 <en0th> I understand. the point is i'd like to make an abstract one first, to work with simplex - like problem class (optimization, etc)
00:40:09 <en0th> the naive implementation is a big until, i guess
00:40:59 <en0th> until isOptimal doStep initial_step
00:41:22 <Cale> Yeah, I would worry a lot more about what linear algebra library to use :)
00:41:58 <FunctorSalad_> if only there was a standard interface so you could drop in a different lib later
00:42:08 <mmorrow> en0th: monads just let you make you be able to do some book-keeping implicitly during the "<-" in "do x <- m; return x"
00:42:38 <mmorrow> if the monad is State, that book-keeping would be to update the State
00:43:29 <en0th> so, if i  would need a monad into my naive implementation, it would be the step
00:43:43 <mmorrow> if the monad is (ghc's) IO, the book-keeping would be to pass around something equivalent to (), in order to enforce that things happen sequentially via data-dependencies (data deps on that ()-equivalent value)
00:43:44 <Cale> Specific monads are really a lot like any other library, it's just they share a common API.
00:44:51 <Cale> So if the library you're using happens to be a monad, you get things like sequence and replicateM and so on for free.
00:45:12 <Cale> (which you'll have to interpret in the particular monad you're working with)
00:45:35 <mmorrow> > let m = (do (m,n) <- get; put (n,m+n); return m) in runState m (0,1)
00:45:36 <lambdabot>   (0,(1,1))
00:45:43 <mmorrow> > let m = (do (m,n) <- get; put (n,m+n); return m) in runState (replicateM 10 m) (0,1)
00:45:43 <lambdabot>   ([0,1,1,2,3,5,8,13,21,34],(55,89))
00:46:01 <Cale> The State monad specifically is just a library for describing computations which take an initial state and compute a value along with some final state, and chaining those computations together.
00:46:29 <mmorrow> and you get to use the standard monad combinator functions to do stuff
00:46:29 <Cale> Of course, it's really just functions, and things which combine functions
00:46:45 <mmorrow> get = State (\s -> (s,s))
00:46:53 <mmorrow> put s = State (\_ -> ((),s))
00:47:04 <mmorrow> return a = State (\s -> (a,s))
00:47:36 <en0th> mm it seems clear
00:47:57 * Axman6 still can't get his head around State... but hasn't tried very hard
00:48:04 <jfredett> someone yell when they get HWN... I'm trying the new script I wrote which will (hopefully) settle the sendout procedure once and for all...
00:48:13 <mmorrow> State f >>= k = State (\s -> case f s of (a,s') -> case k a of State g -> g s')
00:48:21 <en0th> mm let me find a thing i would like to paste..it's from SPJ book
00:48:50 <mmorrow> so (>>=) just hides this pattern from view
00:49:04 <mmorrow> \s -> let (a,s') = f s
00:49:09 <jfredett> the sequence.complete.org version won't be up for a while though, so don't go looking. :)
00:49:24 <mmorrow>         (b,s'') = g a s'
00:49:32 <mmorrow>     in ...
00:50:14 <mmorrow> (in (b,s''))
00:50:28 <en0th> this one: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4330#a4330
00:51:02 <mmorrow> en0th: right, that's just beggin for a State monad
00:51:06 <en0th> a monad here would hide all put / get
00:51:06 <mmorrow> *begging
00:51:29 <jfredett> @remember mmorrow: right, that's just beggin for a State monad.
00:51:29 <lambdabot> I will remember.
00:51:43 <mmorrow> heh
00:51:45 <jfredett> it's better with 'beggin' :P
00:52:05 <jfredett> maybe it's just the 4am, but that was wicked funny.
00:52:16 <mmorrow> en0th: it'd become  "s <- gets (\(_,_,stack,_) -> stack)"
00:52:19 <mmorrow> etc (or whatever)
00:52:51 <Cale> Well, you'd presumably still write getStack and putStack
00:52:54 <mmorrow> what you'd really do would be to make GmState a record datatype
00:53:08 <mmorrow> do s <- gets gmStack; ...
00:53:14 <Cale> But their type would change :)
00:53:22 <mmorrow> data GmState = GmState {gmStack :: ..., ...}
00:53:52 <Cale> But this code isn't really so bad as it is.
00:54:16 <mmorrow> en0th: so what would really change is how you then wrote code that would *use* the stuff set up by that paste, as opposed to what's *in* that paste
00:54:23 <Cale> Yeah, I would stop using the large tuples, that's the main thing.
00:54:26 <jfredett> allright, sleep time. hopefully HWN went out... gnite.
00:54:30 <mmorrow> night
00:54:32 <Cale> (make a proper datatype :)
00:54:32 <en0th> n8
00:55:13 <en0th> so a function to add a thing to the stack would be?
00:55:37 <en0th> push item =<< state
00:57:24 <mmorrow> > let push x = modify (\(stack,whatever) -> (x:stack,whatever)); pop = do {(x:stack,foo) <- get; put (stack,foo); return x} in flip runState ([],42) (do push 3; push 9; push 20; replicateM 2 pop)
00:57:25 <lambdabot>   ([20,9],([3],42))
00:57:29 <Cale> do s <- getStack; putStack (push item s)
00:58:13 <Cale> You might write a modifyStack, so that you could write  modifyStack (push item)
00:58:16 <mmorrow> > let push x = modify (\(stack,whatever) -> (x:stack,whatever)); pop = do {(x:stack,foo) <- get; put (stack,foo); return x} in flip runState ([],42) (do push 3; push 9; mapM_ push [20,30]; x <- pop; xs <- replicateM 2 pop; return (x:xs))
00:58:17 <lambdabot>   ([30,20,9],([3],42))
00:59:14 <mmorrow> so it frees you from having to actually manipulate the state in functions you write
00:59:36 <mmorrow> you can just do    foo x y = do a <- pop; push x; return (a+y)
01:00:22 <mmorrow> bar x y z = do a <- foo x y; b <- foo a z; return (a*b)
01:00:29 <mmorrow> etc
01:00:38 <en0th> mm i think i'll need to save the log of this
01:01:37 <mmorrow> (not that in the def of "pop" above, i didn't bother to make sure the stack wasn't empty for simplicity)
01:01:41 <mmorrow> s/not/note/
01:01:54 <en0th> okay
01:02:35 <Cale> (but don't take from this that monads in general have anything to do with state -- they're more about how things are wired up than anything)
01:03:50 <en0th> i thought i had to interpret them as tools to access things inside containers
01:04:13 <mrsolo> that what i though initially
01:04:27 <mrsolo> and it is really bad to learn monads through irc :-)
01:04:40 <mrsolo> monads basically describe chain of computations
01:04:45 <mrsolo> or relationship of
01:04:48 <en0th> heh but here we've got some good professors
01:05:47 <en0th> monday i'll go at univ and start to ask about monads. i bet i'll go back home without *any* answer.
01:06:28 <DrSyzygy> en0th: Read my lecture notes. I'll get to monads in 3 weeks, but I'll get there with a reasonable grounding in theory. ;-)
01:06:29 <en0th> anyway, i think the do notation is what makes people go crazy
01:07:06 <DrSyzygy> Or, if categories isn't your most helpful approach - stay the h*ll away from my notes. ;-)
01:07:17 <Cale> en0th: That's another way to look at it. Each monad is a sort of container, and the monad operations are container operations. Essentially every monad can be looked at that way, if you're willing to stretch your definition of 'container' far enough :)
01:08:11 <Cale> It's not at all a bad analogy to use, and it's good in that 'container' is pretty concrete as far as abstractions go.
01:08:37 <Baughn> (However, the "container" analogy actually belongs to Functor, and Monad is just a subclass of that)
01:08:43 <Cale> Right.
01:09:23 <en0th> in fact, i've found the functor more enlightening than monads
01:09:37 <Cale> A monad is a special sort of container that has certain operations then, beyond the only one required by Functor, which is the ability to apply a function to all elements.
01:09:51 <en0th> <*> ?
01:10:02 <Cale> fmap is the Functor operation
01:10:06 <mmorrow> @type [ap,(<*>)]
01:10:07 <lambdabot> forall (m :: * -> *) a b. (Monad m, Applicative m) => [m (a -> b) -> m a -> m b]
01:10:09 <Cale> Or <$>
01:10:16 <mmorrow> @type [fmap,(<$>)]
01:10:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
01:10:21 <mmorrow> @type [fmap,(<$>),liftM]
01:10:22 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => [(a -> b) -> f a -> f b]
01:10:29 <Cale> <*> is from Applicative. Applicative functors sit in between Functor and Monad
01:10:47 <Axman6> how are they inbetween?
01:10:59 <mmorrow> they've got pure/return
01:11:02 <Cale> Axman6: Every Monad is an Applicative, every Applicative is a Functor.
01:11:08 <Axman6> ah, fair enough
01:11:11 <mmorrow> but no join
01:11:34 <Axman6> got an example of something that's Applicative but not a Monad?
01:12:21 <PetRat> I have a question related to zipping things and lifting into a monad. Question here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10583#a10583
01:13:17 <ivanm> I think this applies well here: http://icanhascheezburger.files.wordpress.com/2009/09/funny-pictures-bunny-naps-on-homework.jpg
01:13:19 <Cale> Axman6: ZipList
01:13:35 <en0th> hehe
01:14:33 <en0th> it's strange to me that <*> wants a monad m *and* an applicative m. maybe it's due to implementation
01:14:46 <Cale> PetRat: hmmm...
01:14:50 <Axman6> :t (<*>)
01:14:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:15:10 <Axman6> en0th: that was only because liftM was in the list
01:15:33 <Cale> PetRat: That's going to be tricky, since it's like zipWithM, but with two separate monads.
01:15:34 <en0th> oh!
01:16:11 <Cale> PetRat: But since one of the monads is the list monad, we're in luck :)
01:16:13 <mmorrow> @let push x = modify (\(stack,whatever) -> (x:stack,whatever))
01:16:14 <lambdabot>  Defined.
01:16:20 <mmorrow> @let pop = do {(x:stack,foo) <- get; put (stack,foo); return x}
01:16:21 <lambdabot>  Defined.
01:17:11 <Cale> PetRat: er, oh, right
01:17:19 <Cale> PetRat: Never mind what I said before ;)
01:17:20 <mmorrow> @let op2 f = do x <- pop; y <- pop; push (f x y)
01:17:21 <lambdabot>  Defined.
01:17:23 <PetRat> Cale: excellent. zipWithM doesn't quite apply because we've got 'a' in a list and 'b' in a list in Rand.
01:17:31 <mmorrow> @let op1 f = do x <- pop; push (f x)
01:17:32 <lambdabot>  Defined.
01:17:47 <PetRat> I see this as somehow lifting zipWith into the Rand monad.
01:17:49 <en0th> i smell something, morrow
01:17:58 <Cale> PetRat: do fs <- xs; return (zipWith f ys fs)
01:18:05 <mmorrow> @let op3 f = push =<< f <$> pop <*> pop <*> pop
01:18:06 <lambdabot>  Defined.
01:18:25 <Cale> Past bedtime for me :)
01:18:42 <en0th> here it's 10 am
01:18:48 <ivanm> @time
01:18:49 <PetRat> Cale: don't quite follow. Is that the entire answer? Should I study it while you are off to bed?
01:18:49 <lambdabot> Local time for ivanm is Sat Oct 10 18:18:49
01:18:55 <Cale> PetRat: Just run the thing in the Rand StdGen monad, take your list of floats
01:19:08 <Cale> PetRat: and then do the zipWith that you wanted to do
01:19:14 <Cale> That is the answer :)
01:19:17 <Axman6> ivanm: 21 seconds off being awesome :(
01:19:28 <Axman6> 31 even
01:19:32 <mmorrow> @let add = op2 (+); sub = op2 (-); mul = op2 (*); dup = do {x <- pop; replicateM_ 2 (push x)}; swap = do x <- pop; y <- pop; mapM_ push [y,x]}
01:19:33 <lambdabot> Plugin `eval' failed with: Internal error: empty context in popContext
01:19:35 <mmorrow> aww
01:19:41 <ivanm> Axman6: heh
01:19:50 <mmorrow> @let add = op2 (+)
01:19:51 <PetRat> Cale: I want to keep the answer in the Rand monad because I am chaining Rand monads over the entire section of my program that uses randonmness.
01:19:51 <lambdabot>  Defined.
01:19:56 <mmorrow> @let sub = op2 (-)
01:19:57 <lambdabot>  Defined.
01:20:01 <mmorrow> @let mul = op2 (*)
01:20:02 <lambdabot>  Defined.
01:20:05 <Cale> PetRat: Indeed, there's no other way.
01:20:14 <mmorrow> @let dup = do {x <- pop; replicateM_ 2 (push x)}
01:20:15 <lambdabot>  Defined.
01:20:23 <mmorrow> @let swap = do {x <- pop; y <- pop; mapM_ push [y,x]}
01:20:24 <lambdabot>  Defined.
01:20:28 <Cale> PetRat: You run the computation xs in order to get a list. (Probably shouldn't be called xs, since it's not a list.
01:20:29 * Axman6 watches as the majestic mmorrow coderati defines a DSL in public
01:20:29 <Cale> )
01:21:07 <mmorrow> Axman6: don't make me blush
01:21:33 <Cale> PetRat: You do this in the Rand StdGen monad
01:21:42 <Cale> PetRat: So it's just  do rs <- xs
01:21:50 * Axman6 thinks that the mmorrow may have spotted him. he ducks slowly to try and avoid being seen, while he wonders if those pure-fft patches have been merged
01:22:03 <Cale> and then rs :: [Float] is the result of running xs
01:22:08 <mmorrow> @let runIt pgm = runState pgm ([],42)
01:22:10 <lambdabot>  Defined.
01:22:25 <Cale> PetRat: understandable? It's 4:20am or something here
01:22:27 <mmorrow> Axman6: haha, thanks for the subtle reminder :)
01:22:51 * Axman6 it seems the mmorrow may be just about to finish his DSL dance of courtship. it is a truly wonderful sight
01:23:21 <Cale> PetRat: So then on the next line, you're clear to do whatever zipping/what-have-you that you need to do, and the whole thing is a do-block describing a computation in the Rand StdGen monad
01:23:30 <mmorrow> > runIt (do mapM_ push [2,3,4]; add; mul; dup; push 9; swap; sub; mul)
01:23:31 <lambdabot>   ((),([-70],42))
01:24:07 <PetRat> Cale: oh I get it.
01:24:59 * Axman6 and there we have it. a truly wonderful display of mmorrow coderati's ability to produce a DSL on a whim. certainly the most magnificant of all the coderati family
01:25:00 <PetRat> Now one thing I am starting to understand about monads that contain some state like Rand, is that the state gets passed from one to the next even when doing mapM, sequence, replicateM, etc. I know this is obvious but I hadn't realized it.
01:25:41 <Cale> PetRat: yeah, it's hard to avoid that, in fact
01:25:50 <PetRat> So now that I am using p-randomness and don't want to trust split, I am careful to be sure a fresh generator is passed along.
01:26:04 <Raynes> It's not really that obvious, but that's the point. ;)
01:27:19 <PetRat> So I'm thinking, hmm, okay I unwrap a Rand monad, do something, and wrap it back up.. and does the state get passed along? I guess it does. It's all in the definition of >>=. Using <- in do-notation is just another way of writing >>=.
01:27:57 <Cale> PetRat: yeah.
01:28:35 <Cale> PetRat: and if you *wanted* them all the computations you were mapping over to get the same initial state, you'd run into the problem of which one gets to determine the final state
01:28:56 <Cale> PetRat: so it would be unnatural to have such an operation in a state monad.
01:29:11 <PetRat> Cale: hmm. so a lot of behavor falls out from just asking what makes sense.
01:30:29 <PetRat> In typeclassopedia, there is an exercise to define sequence. I realized I had defined it with the help of >>=, so a sequence of monads (and mapM and replicateM call sequence implicitly) is just a big chain glued together with >>= or >>.
01:30:53 <Cale> sequence in a monad
01:31:12 <Cale> (you only use sequence with one monad at a time, it takes a list of computations in that one monad)
01:31:52 <PetRat> Oh, I'm not as precise as a should be about the distinction between a "computation" and a "monad".
01:32:02 <Cale> But yeah, everything which is polymorphic such that it works in an arbitrary monad in some sense must be some composition of return and >>=
01:32:32 <Cale> "The monad" refers to the thing at the type level which gets applied to your types
01:32:54 <PetRat> List is a monad. The stuff in the list is/are the computations. Right?
01:33:19 <Cale> Each list is itself a computation in the list monad.
01:33:28 <Cale> For example, [1,2,3] is a computation in the list monad
01:33:45 <PetRat> Ah.
01:34:15 <Cale> :t getLine
01:34:16 <lambdabot> IO String
01:34:21 <Cale> getLine is a computation in the IO monad
01:34:38 <PetRat> This whole project has to do with rewriting a Python program as an experiment. Looks like it will come out to 25% or less in lines of code.
01:34:44 <Cale> IO is all one monad, with many computations of various types :)
01:34:45 <Baughn> PetRat: This sort of thing is where the "computation" analogy breaks down
01:35:02 <Cale> Though not entirely.
01:35:05 <PetRat> Baughn: which sort of thing?
01:35:09 <Baughn> PetRat: You can stretch it if you like, but really, what monads have in common are the /type signatures/ and some basic rules. Nothing more, nothing less.
01:35:12 <Baughn> Lists
01:35:24 <PetRat> I'm not even sure what the "computation" analogy is because computation is such a generic word.
01:35:27 <Cale> You can imagine [1,2,3] as the computation which produces the results 1, 2 and 3 all at once.
01:35:50 <Baughn> Unless you're using the list monad as a list comprehension, in which case you don't. :P
01:35:52 <Cale> The list monad models nondeterminism
01:36:17 <PetRat> I know I asked a couple weeks ago what nondeterminism is, but remind me.
01:36:23 <Baughn> "do x <- xs; guard (x > 2); return x"
01:36:29 <Cale> So when you have x <- [1,2,3], it's like you're forking the universe into 3, and in each universe, x has a different value
01:36:46 <Cale> In one universe, it has the value 1, in the second it has the value 2,...
01:37:07 <Cale> and then the list monad arranges that the results from all the universes are collected into a list at the end
01:37:20 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
01:37:21 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
01:37:47 <en0th> omg, 6 universes
01:38:06 <Cale> [] then is something which kills off that universe when you run it
01:38:36 <mrsolo> it follows list monad chaining rule; pretty cute really.. everything falls neaty in place.  the api that is
01:38:37 <Cale> > do x <- [1,2,3]; y <- [1,2,3]; if x > y then [] else [()]; return (x,y)
01:38:38 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
01:38:52 <PetRat> So nondeterminism is related to the idea of "multiple universes"---that is, multiple ways of interpreting your input which may need to coexist for some time before they are "collapsed" into a single answer?
01:39:09 <Cale> PetRat: or, if you want, a list of answers
01:39:24 <en0th> an overlapping, maybe
01:39:38 <Cale> PetRat: If you want, just read  x <- [1,2,3] as  "pick x from [1,2,3] in each possible way"
01:39:58 <c_wraith> let p [] = [[]] ; p (x:xs) = p xs >>= i where { i [] = [[x]] ; i yys@(y:ys) = (x:yys):(i ys >>= (x:)) } in p [1..3]
01:40:03 <c_wraith> > let p [] = [[]] ; p (x:xs) = p xs >>= i where { i [] = [[x]] ; i yys@(y:ys) = (x:yys):(i ys >>= (x:)) } in p [1..3]
01:40:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
01:40:11 <c_wraith> d'oh.  where'd I get the typo...
01:40:13 <PetRat> I know that parsers deal with the problem of multiple ways of interpreting the next chunk of input.
01:40:19 <Cale> In the end, it's not implemented with any real parallelism (though it could be), and you just get a bunch of nested loops, (or concatMaps really).
01:40:50 <c_wraith> > let p [] = [[]] ; p (x:xs) = p xs >>= i where { i [] = [[x]] ; i yys@(y:ys) = (x:yys):(i ys >>= (y:)) } in p [1..3]
01:40:51 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
01:41:04 <Cale> PetRat: right, absolutely, you could build a parsing monad from the list monad, by adding some details to take care of the remaining input
01:41:20 <PetRat> A parser may want to allow mulitple interpretations to exist at some point in the computation before it acquires sufficient information to pick one alternative.
01:41:35 <Cale> PetRat: Or in the end, return a list of all possible parses.
01:41:52 <Cale> (you could just pick the first one by convention too)
01:42:14 <PetRat> To change the subject briefly, I'm working on a piece of softwre for music composition. I was originally writing this in Python.
01:42:33 <c_wraith> > let p [] = [[]] ; p (x:xs) = p xs >>= i where { i [] = [[x]] ; i yys@(y:ys) = (x:yys):(i ys >>= return . (y:)) } in p [1..3]
01:42:34 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
01:42:40 <PetRat> It was my plan to allow myself to control parts of the program by writing Python scripts and interpreting them within the main program.
01:42:48 <c_wraith> there.  list monad obfuscation!
01:43:26 <PetRat> Sort of like using the full power of Python to provide a kind of command-line interface to a system, which also has a GUI component, and maintains and displays documents.
01:44:11 <PetRat> I don't know hwo to do this in Haskell. In Python you can "exec" a bit of code right in the environment of your main program.
01:44:51 <Baughn> PetRat: Check out the hs-plugins package
01:45:07 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; perms xs = evalStateT (mapM (const (StateT select)) xs) xs in perms [1,2,3]
01:45:08 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
01:45:09 <Baughn> Hm. Actually, just "plugins"
01:45:15 <PetRat> Baughn: thanks. "plugins"
01:45:56 <Baughn> Unfortunately, it /still/ breaks haddock
01:46:18 <PetRat> It can't be built with haddock?
01:46:33 <Baughn> Right, so no documentation.
01:46:55 <Baughn> ..well, that might be going a bit far. There's the original paper, at least.
01:46:55 <PetRat> I am not really that fmailiar with plugins, but I understand the basic idea is to link some code into an application at runtime?
01:46:59 <Baughn> Yes
01:47:19 <c_wraith> Hmm.  That implementation uses select.  It must be slow.
01:47:26 <PetRat> So I could actually be writing and compiling this code WHILE my application is running?
01:47:38 <PetRat> That's my requirement.
01:47:41 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; perms = join (evalStateT . (mapM . const . StateT $ select)) in perms [1,2,3]
01:47:43 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
01:47:44 <Baughn> PetRat: Sure
01:48:00 <Baughn> PetRat: Although, I'm not entirely sure what way would be best. There's the GHCi API too, for interpreted code
01:48:04 <Cale> There we go, that's pretty obfuscated ;)
01:48:27 <c_wraith> Sure, but my implementation is also faster than Data.Lists's. :)
01:48:29 <PetRat> While working with a document, I will see a way to manipulate it and want to write Haskell to do so. So while still loaded, I want to write the Haskell and somehow plug it in.
01:49:06 <Baughn> Right. It's possible.
01:49:07 <Cale> PetRat: hint is good for that
01:49:19 <PetRat> "hint"? is that a package?
01:49:22 <Cale> yeah
01:49:38 <Baughn> Wraps the GHC api, I see. Looks good.
01:49:47 <Baughn> PetRat: It provides an eval function. :)
01:50:08 <Baughn> interpret :: (MonadInterpreter m, Typeable a) => String -> a -> m a
01:50:09 <Cale> Yeah, and if you have a compiled .o alongside your module, it will use that too, so you can use it for compiled plugins too.
01:50:20 <Cale> (albeit with the sourcecode)
01:53:50 <PetRat> Yeah hint may be the best way.
01:53:57 <PetRat> Well g'night everyone
01:54:03 <en0th> n8
01:54:04 <Baughn> PetRat: Oh, and..
01:54:34 <Baughn> PetRat: Linking in GHC will balloon your program explosively. However, this is fixed in 6.12, so Don't Panic.
01:55:05 <mrsolo> explosively?
01:55:15 <Raevel> hmm
01:55:17 <Baughn> A hint-based hello,world is something like 20MB. :P
01:55:23 <PetRat> Baughn: thanks. I had run into some of these problems and was told by the author of qtHaskell that 6.12would provide dynamic linking.
01:55:23 <mrsolo> ouch
01:55:29 <mrsolo> ah dynamic linking
01:55:42 <Baughn> PetRat: It does, and it seems to work great
01:56:02 <mrsolo> dynamic linkling will solve some license issue as well right?
01:56:34 <Baughn> Not really, since ghc likes to do cross-package inlining
01:56:34 <Cale> Though, it doesn't totally solve the problem if you're distributing the program, since programs more or less will be no ABI compatibility between versions of the shared libraries.
01:56:40 <PetRat> Thanks all!
01:56:50 <Cale> But it will cut down on memory usage if you have multiple Haskell programs runnign
01:56:54 <Cale> running*
01:57:12 <Cale> s/be/have/
01:57:29 <Baughn> It also cuts down on linking time, disk use, and startup time
01:57:35 <mauke> oh/be/have
01:57:45 <Cale> heh
01:59:06 <Cale> Nine this clothes her egg raiment
01:59:18 <Baughn> Seven of cute?
01:59:54 <mauke> parse error
02:00:15 <Baughn> parse error on token "parse"
02:00:49 <Cale> Sorry, I don't know how to parse "error".
02:01:49 <Cale> Nondisclosure agreement.
02:02:02 <mauke> ah!
02:02:16 <Baughn> Disclosure disagreement?
02:02:23 <Cale> Nine this clothes her egg raiment
02:03:00 <mauke> I got the agreement part, but I got stuck somewhere around dis-clos
02:03:14 <mauke> preflex: quote
02:03:15 <preflex>  <dumont> if i have a recent version of linux, perl would obviously be new, so I shouldn't concern myself with the version of the manual, and only watch out for depricated functions, correct?
02:03:19 <Cale> Yeah, it's kinda thin ;)
02:03:58 <Cale> @keal
02:03:58 <lambdabot> they dumbified you
02:04:08 <Cale> @ghc
02:04:08 <lambdabot> ghc says: Command stack underflow at command
02:04:57 <mauke> preflex: quote
02:04:57 <preflex>  <wangster> Functionality per dollar is pretty high in the gimp. Mind you it's a divide by zero error...
02:05:21 <Axman6> heh
02:05:34 <Cale> cale@zaphod:/usr/local/lib/ghc-6.10.3$ strings ghc | grep underflow
02:05:35 <Cale> Command stack underflow at command:
02:05:35 <Cale> arithmetic underflow
02:06:04 <Cale> But... can the error be triggered? :)
02:20:03 <Raevel> Lemmih: hello?
02:21:34 <sohum> I must be missing something really obvious: http://haskell.pastebin.com/da4e02ab
02:21:43 <sohum> can anyone help?
02:23:33 <ivanm> sohum: what's the error?
02:23:49 <ivanm> (note that I have no idea about how to use happy...)
02:23:52 <Raevel> @tell Lemmih sorry about the missing file, it's in my repo now though if you didn't catch my message earlier, still http://ecmascript.se/etc/repos/torrent
02:23:52 <lambdabot> Consider it noted.
02:25:26 <sohum> ivanm: in the ghci session, the Return in the second position of the tokenlist should trigger the fail branch at line 21
02:25:42 <Raevel> i'm want to use Regex.PCRE with bytestrings, is it not implemented?
02:26:02 <sohum> ivanm: for some reason the modify commands in line 19 aren't getting propagated
02:27:09 <Raevel> maybe i should check the api first, why do i always do this :-)
02:28:16 <ivanm> sohum: yeah, no idea sorry
02:28:33 <sohum> ivanm: thanks for trying
02:28:38 <ivanm> sohum: but as a guess... are you expecting $1 to be returned?
02:28:55 <ivanm> don't forget, only the last return statement is seen outside of a monad...
02:29:00 <ivanm> s/return//
02:30:58 <sohum> ivanm: I'm thinking it has to be some weird way in which happy interacts with passing state down the parse tree...
02:31:37 <sohum> ivanm: that is how you use the state monad, right? do modify (...); <expr involving changed state>?
02:34:10 <ivanm> sohum: well, there's no point in having a return statement mid-way through a do-block
02:34:42 <sohum> ivanm: so how would you do the computation there but return it later?
02:36:17 <ivanm> sohum: actually, why do you bother having "s <- return $1" if you then do return s later?
02:36:22 <ivanm> why not just return $1 later?
02:36:34 <ivanm> or is this happy syntax/restrictions that I don't know about?
02:36:49 <mauke> 'a <- return b' probably better written as 'let a = b'
02:36:56 <sohum> ivanm: state monad. I want to do the computation in that state, and then change the state again before returning it
02:37:04 <ivanm> mauke: agreed... but I'm wondering why you'd even bother with that
02:37:09 <ivanm> and why nto just use b everywhere
02:37:28 <ivanm> sohum: so you're wanting to get the current state, change it and then return the original state?
02:37:30 <mauke> 'return' does not make use of the state
02:38:29 <sohum> mauke: but /presumably/ $1 does
02:39:04 <ivanm> ahhhh
02:39:12 <ivanm> sohum: right, so "let s = $1"
02:39:21 <mauke> sohum: no
02:40:53 <sohum> mauke: no?
02:42:30 <ivanm> sohum: no!
02:42:34 <ivanm> ;-)
02:43:02 <mauke> 'return x' is the computation that has no effects and simply returns x
02:43:18 <mauke> so it doesn't matter what $1 is
02:43:31 <ivanm> return x = State (\ s -> (s,x)) IIRC
02:43:35 <ivanm> @src State return
02:43:36 <lambdabot> Source not found. My pet ferret can type better than you!
02:43:40 <ivanm> @src St return
02:43:41 <lambdabot> Source not found. There are some things that I just don't know.
02:43:45 <ivanm> OK, lambdabot doesn't know...
02:45:31 <mauke> @unmtl State s a
02:45:31 <lambdabot> s -> (a, s)
02:45:46 <mauke> @djinn a -> (s -> (a, s))
02:45:46 <lambdabot> f a b = (a, b)
02:46:11 <sohum> ok, modified it to http://haskell.pastebin.com/d2625855
02:46:14 <sohum> still doesn't help
02:46:20 <ivanm> OK, I had it the pair the wrong way round
02:53:34 <stanv_> does keywords: `newtype' and `data' a same ?
02:54:10 <sohum> stanv_: http://www.haskell.org/haskellwiki/Newtype has a good breakdown
02:55:26 <ManateeLazyCat> I get string `6.012302s" from funciton `diffUTCTime`. So have exist function that can parse string `6.012302s` then split it to Integer 6 and Integer 012302 ?
02:55:45 <sohum> :t split
02:55:46 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
02:55:52 <sohum> ...
02:55:53 <mauke> diffUTCTime doesn't return a string
02:55:53 <sohum> not that
02:55:54 <ManateeLazyCat> I mean exist function, i know i can split string then transform to Integer.
02:56:15 <ManateeLazyCat> NominalDiffTime
02:56:33 <mauke> yeah
02:57:00 <ManateeLazyCat> sohum: One solution i think is, use show get String result, then transform String to Integer.
02:57:13 <mauke> why do you want two integers?
02:57:37 <ManateeLazyCat> diffUTCTimeWithSecond t1 = truncate . diffUTCTime t1
02:57:51 <ManateeLazyCat> mauke: Above function just pick `second`.
02:57:58 <mauke> yes
02:58:25 <ManateeLazyCat> mauke: I want get different picosecond between two UTCTime.
02:58:34 <mauke> well, that's not how you do it
02:58:37 <ManateeLazyCat> mauke: For timer.
02:58:56 <mauke> note that 00015 == 0015 == 015 == 15
02:59:27 <mauke> if you want picoseconds, just multiply by 10^12
02:59:36 <ManateeLazyCat> mauke: Yes, i know that.
02:59:55 <ManateeLazyCat> mauke: So have a better function that get picosecond between two UTCTime.
02:59:56 <ManateeLazyCat> ?
03:00:06 <mauke> what?
03:00:17 <mauke> I just told you how to do it
03:00:41 <ManateeLazyCat> mauke: I mean not use differUTCTime fucntion.
03:00:46 <mauke> why not?
03:00:59 <ManateeLazyCat> mauke: I don't want transform.
03:01:06 <mauke> what?
03:01:53 <ManateeLazyCat> mauke: If you want pick picosecond, you must get `String` result then transform String to Integer, right?
03:01:58 <mauke> no
03:02:26 <ManateeLazyCat> mauke: Better idea?
03:02:33 <mauke> <mauke> if you want picoseconds, just multiply by 10^12
03:03:29 <ManateeLazyCat> mauke: Oh, i misunderstand you said.
03:05:40 <ManateeLazyCat> diffUTCTimeWithMillisecond t1 t2 = truncate $ (1000 *) $ diffUTCTime t1 t2
03:06:22 <ManateeLazyCat> diffUTCTimeWithPicosecond t1 t2 = truncate $ (1000000 *) $ diffUTCTime t1 t2
03:06:32 <mauke> no, that's microseconds
03:08:00 <ManateeLazyCat> mauke: Yes, copy wrong text. :)
03:08:07 <ManateeLazyCat> mauke: Thanks for your help.
03:08:46 <ManateeLazyCat> mauke: I don't realise i can multiply with `NominalDiffTime` directly.
03:09:09 <mauke> it's an instance of Num and Fractional
03:09:18 <mauke> so all the usual stuff works
03:09:55 <ManateeLazyCat> mauke: Yes, i realise that when you repeat your words.
03:10:13 <ManateeLazyCat> mauke: Sorry for my stupid question. :)
03:16:35 <sohum> mauke: so, any ideas? even without the return, it's still not propagating the changes correctly
03:36:32 <kw317> hmm.. I'm trying to run the examples bundled with alex an all I get is lexical error
03:37:00 <kw317> say I run lexer for haskell with let x = 3 and I get lexical error
03:42:01 <hackagebot> DAG-Tournament 0.1 - Real-Time Game Tournament Evaluator (JoachimBreitner)
03:42:25 <jaareer> /quit
03:52:49 <Baughn> http://blog.desudesudesu.org/wp-content/uploads/2009/02/27dcd29da9440ccf385d601ad5ea6ae0c9033f4a.jpg <-- Hum. Looks like we've got a haskell-tan.
03:53:11 <Baughn> ..anyone capable of translating that japanese?
03:53:21 <Axman6> :o
03:55:20 <Berengal__> o_O
03:56:33 <Berengal__> Let me guess, she is the strict type, has a pure soul, but is really lazy
03:56:45 <olsner> :)
03:56:54 <Baughn> Also, she exists. :)
03:57:40 <Baughn> Looks like a tsundere type to me. At first she's cold and hard to understand, but when she warms up she becomes your best friend.
05:25:07 <morganson> howdy
05:27:29 <Axman6> o/ morganson
05:28:05 <Axman6> morganson: well done on breaking 1.5 hours of no one talking
05:33:39 <kw317> anyone familiar with alex?
05:35:32 <SamB_XP> kw317: some people are, yes
05:35:41 <SamB_XP> did you have some sort of question?
05:36:06 <kw317> yeah, I'm playing with the examples and I'm not sure what's going on with haskell.x
05:36:26 <Veinor> alex is a pretty cool guy, I'm surprised you iknow him
05:36:27 <kw317> the lexer it generates returns lexical error for all input strings I try
05:36:32 <SamB_XP> kw317: huh
05:36:36 <SamB_XP> link ?
05:36:53 <kw317> hold on..
05:37:26 <kw317> http://darcs.haskell.org/alex/examples/haskell.x
05:37:48 <SamB_XP> I'm guessing it's some kind of bitrot ...
05:39:19 <kw317> bitrot?
05:39:49 <Axman6> hasn't been updated for a while
05:40:58 <kw317> ah
05:43:22 <SamB_XP> bitrot is what makes unmaintained software stop working ;-)
05:43:53 <kw317> do you know of any good working examploes of using alex?
05:44:10 <SamB_XP> well, GHC actually uses it for it's Haskell lexer ...
05:44:16 <ivanm> Axman6: what area is ANU in? (having a quick browse of property prices, etc.)
05:44:18 <SamB_XP> er. its.
05:44:50 <SamB_XP> and that one is regularly tested, unlike this one
05:45:22 <morganson> Axman6 hello! =)
05:45:48 <Baughn> kw317: So, download ghc source, then find . -name *.x
05:45:49 <morganson> 1.5 hours? nice
05:45:52 <Axman6> ivanm: Acton. it's right next to Civic
05:46:02 <SamB_XP> Baughn: surely that's not necessary ;-P
05:46:31 <Baughn> SamB_XP: No, but it's faster than looking only in the logical places.
05:46:52 <SamB_XP> the downloading is a bit slow ...
05:47:05 <ivanm> Axman6: any idea what prices are like around there?
05:47:06 <Baughn> Eh? haskell.org regularly pegs my net connection
05:47:14 <Baughn> It should be just half a minute
05:47:15 <SamB_XP> % find -name '*.x'
05:47:15 <SamB_XP> ./utils/genprimopcode/Lexer.x
05:47:15 <SamB_XP> ./compiler/parser/Lexer.x
05:47:15 <SamB_XP> ./compiler/parser/HaddockLex.x
05:47:15 <SamB_XP> ./compiler/cmm/CmmLex.x
05:47:16 <Axman6> ivanm: probably pretty high
05:47:29 <SamB_XP> Baughn: well, I guess it depends on how fast your connection can go ;-P
05:47:29 <Baughn> SamB_XP: ..well, I was assuming he didn't already have a copy
05:47:34 <SamB_XP> I have lowish end broadband
05:47:35 <Axman6> civic is the center of town
05:47:40 <ivanm> Axman6: :(
05:47:45 <Baughn> So do I..?
05:47:52 <Baughn> Oh, right. Different countries. ^^;
05:47:59 <SamB_XP> yeah, I'm in the US
05:48:01 <ivanm> Axman6: what kind of areas would you recommend then?
05:48:01 <Axman6> ivanm: check out belconnen (that's where I am)
05:48:08 <SamB_XP> low-end is a little low here!
05:48:21 <Baughn> Low-end here means <10Mb/s
05:48:52 <SamB_XP> I think I can get 100kB/s
05:49:08 <SamB_XP> maybe
05:50:16 <ivanm> Axman6: hmmm... i shtere bushland between belconnen and canberra proper?
05:50:24 <ivanm> (is that where the fires were a few years ago?)
05:50:26 <SamB_XP> http://darcs.haskell.org/ghc/compiler/parser/Lexer.x
05:50:43 <SamB_XP> of course, that imports a bunch of stuff ...
05:51:51 <Axman6> ivanm: the fires were down south. Canberra's split up into 'towns', Belconnen, the city, woden, tuggeranong, and gungahlin (the newest), and they al have bushland between them
05:52:25 <ivanm> Axman6: *nod*
05:52:57 <ivanm> Axman6: what town is ADFA in? city?
05:53:26 * SamB_XP wishes mozilla had a saner way to pick an application to open something in ...
05:53:42 <Axman6> sort of... think it's kind of between the city and fyshwick (where the fireworks used to be, and all the sex shops still are ;))
05:53:46 <SamB_XP> ... what ... it *does* have a saner way?
05:53:52 <SamB_XP> well, here on windows it does ...
05:54:11 <ivanm> Axman6: :/
05:54:13 <Axman6> ivanm: it's near the airport
05:54:13 <Baughn> You mean, "hand everything off to windows"?
05:54:21 <ivanm> Axman6: I know _that_ much :p
05:54:27 <ivanm> (I've been to canberra all of once...)
05:54:31 <Axman6> heh
05:54:32 <SamB_XP> Baughn: I mean for once it shows me a dialog box with a list of applications
05:54:42 <SamB_XP> I don't think it's ever done that before though
05:54:52 <ivanm> bugger, it appears that the only apartments I can find in a quick look even in belconnen < $300k are 1 bedroom only :s
05:54:58 <Baughn> SamB_XP: Oh, it does that here on linux too. It's just that the "applications" are every. single. file. in /usr/bin.
05:55:16 <SamB_XP> Baughn: uh huh, I read you ;-)
05:55:24 <Baughn> Doesn't help that Linux doesn't really have a notion of "applications"
05:55:32 <SamB_XP> for me, it usually just opens up a file open dialog box ...
05:55:49 <Baughn> Right
05:56:16 * Axman6 notes that Applications and their capabilities being known to the OS is something OS X gets very right
05:57:00 * Baughn notes that there's no particular reason the app bundle system couldn't be replicated in linux
05:57:08 <Axman6> indeed
05:57:27 <SamB_XP> we just don't have a big enough stick ;-P
05:57:43 <Baughn> We could threate to withdraw linux support for haskell?
05:57:58 <Axman6> yes please
05:58:00 <CalJohn> Baughn: it's a job for gnome
05:58:00 <SamB_XP> Baughn: what would be *left*?
05:58:11 <Baughn> SamB_XP: Um.. OS X.
05:58:14 <CalJohn> i haven't used gnome recently though, so maybe it does it already?
05:58:14 <SamB_XP> CalJohn: what about, uh, KDE?
05:58:23 <Baughn> CalJohn: What about xmonad? Or xfce?
05:58:28 <CalJohn> kde doesn't use firefox
05:58:34 <Baughn> KDE users do
05:58:44 <CalJohn> what i mean to say is that this is a job for desktop environments
05:58:45 <SamB_XP> whoops
05:58:56 <Baughn> At any rate, app bundle support needs to be a generalized library that can be used by all the environments
05:59:16 <Baughn> ..preferably including the ones that don't support it
05:59:18 <CalJohn> mmm, I'm not sure
05:59:22 <Axman6> holy crap. been building qt4 for like 4 hours now
05:59:25 <SamB_XP> wouldn't it involve changes to exec()?
05:59:43 <Baughn> Doesn't have to. You'd have to stop using exec(), instead.
05:59:45 <SamB_XP> Axman6: well, there's an awful lot of Qt4 ....
05:59:54 <SamB_XP> Baughn: oh really?
05:59:58 <SamB_XP> that's so going to happen!
06:00:02 <Baughn> There can be a script in /usr/bin for compatibility
06:00:12 <Baughn> So if you aren't appbundle-aware, you exec /that/
06:00:28 <SamB_XP> because we can really put shabang lines on directories
06:00:31 <Baughn> If you are, you delegate application startup and shutdown to the app-bundle service
06:01:15 <Baughn> SamB_XP: There's no reason applications should be trying to exec /Applications/Foo.app under any circumstances
06:01:24 <CalJohn> Baughn, i think for your idea to happen, all of the unix community would be required to all agree and co-operate all at once.  it's more likely that gnome will decide to do it one way (if they don't do it now, and i think they might).  kde already does this, and a lot of the minority window managers can do whatever
06:01:29 <Twey> dbus-heavy project development cycle: 1) Google for usable Haskell dbus bindings. 2) Find none; ask #haskell. 3) Find none; consider writing some. 4) Flee in terror. 5) Wait a month.  6) Repeat.
06:01:30 <Baughn> Heck, call the script /Applications/Foo instead..
06:02:11 <CalJohn> "app bundles" break the whole idea and point of having distributions, also
06:02:11 <Baughn> CalJohn: That /is/ the problem with proposing large changes, yes.
06:02:28 <Baughn> ..I don't see how
06:02:51 <SamB_XP> Twey: the existing ones are unusable?
06:03:10 <CalJohn> most distributions consider it entirely their job (and only their job) to make everything glue together.
06:03:24 <Baughn> CalJohn: Oh, that. I *want* to break that.
06:03:37 <Baughn> It makes it utterly impossible to distribute binary software, as they all do it slightly differently.
06:03:37 <SamB_XP> I don't think Debian actually enjoys having to do that?
06:03:38 <CalJohn> well, i don't agree, i like that aspect of free unix
06:03:56 <CalJohn> meh, i think debian _exists_ to do that
06:04:53 <Twey> Oooh… Dafydd Harries' is now on Hackage.  How come that didn't show up on Google?
06:06:38 <Twey> I take it back.  Dafydd++.
06:09:14 <Twey> Oh, it's not on AUR yet?  o.@
06:09:48 <Axman6> < dforsyth> captains log: 10/10/09
06:09:49 <Axman6> < dforsyth> today firefox continued its campaign against RAM
06:11:12 <Twey> Heh.
06:11:58 <Makoryu> @pl \ws -> fst ws : stuff (snd ws)
06:11:59 <lambdabot> liftM2 (:) fst (stuff . snd)
06:13:11 <Makoryu> @pl \ws -> uncurry (:) . second stuff $ ws
06:13:11 <lambdabot> uncurry (:) . second stuff
06:16:07 <Makoryu> :t let f p xs = case dropWhile p xs of { [] -> []; s' -> uncurry (:) . second (f p) $ s'; } in f
06:16:08 <lambdabot>     Couldn't match expected type `(a1, [a])'
06:16:08 <lambdabot>            against inferred type `[a]'
06:16:08 <lambdabot>     In the second argument of `($)', namely `s''
06:16:36 <Makoryu> :t let f p xs = case dropWhile p xs of { [] -> []; s' -> uncurry (:) . second (f p) $ break p s'; } in f
06:16:37 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
06:17:32 <Makoryu> ^ Any name recommendations? I'm thinking breaksBy
06:18:06 <Makoryu> Actually I should probably hoogle that first
06:18:18 <Makoryu> @hoogle (a -> Bool) -> [a] -> [[a]]
06:18:18 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
06:18:18 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
06:18:18 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
06:18:35 <Makoryu> @hoogle a -> [a] -> [[a]]
06:18:35 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:18:35 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
06:18:35 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:28:18 <cocon> hi
06:28:27 <cocon> is there a 'flip' on the type-level?
06:28:57 <cocon> I want to make (f : * -> * -> *) an instance of Functor, but mapping over the first argument
06:29:01 <cocon> (it's not a bifunctor)
06:32:05 <Axman6> cocon: type Foo a b c = b -> a -> c?
06:32:15 <Axman6> or summat...
06:34:14 <ivanm> Axman6: well, this place looks suspiciously cheap, considering that most places around there seem to want $400k+ :s http://www.independent.com.au/buy/44968?search[BathRoomCount]=&search[CarSpaceCount]=1&search[DistrictName]=&search[PropertyType]=Unit&search[RoomCount]=2&search[pricerange_high]=400000&search[pricerange_low]=
06:34:23 <ivanm> gah, URL spam :s
06:34:53 <Axman6> on northbourne... heh
06:35:09 <ivanm> why, what's with northbourne?
06:35:25 <Axman6> that's the main road through civic. the federal highway makes up the other end of it
06:35:38 <ivanm> so a lot of traffic?
06:35:52 <ivanm> and as such probably not a good place to live?
06:36:03 <Axman6> nah, should be fine
06:36:23 <Axman6> you won't get much loud traffic (trucks don't go through the city generally)
06:36:30 <ivanm> unfortunately, as it's a hotel as well it's a bit hard to find residential recommendations, etc. for that place :s
06:36:38 <ivanm> (more importantly: internet! :p )
06:37:00 <Axman6> looks alright though
06:37:15 <cocon> Axman6: seems like partial application on type synonyms is not allowed
06:37:41 <ivanm> Axman6: yeah
06:37:47 <ivanm> cocon: I think they are...
06:37:53 <ivanm> type Mb = Maybe
06:38:01 <ivanm> pretty sure hlint has told me to do that before...
06:38:02 <Axman6> ivanm: anyway, if worst comes to worst, you can come stay with us for a little while :P
06:38:09 <ivanm> Axman6: heh
06:38:12 <ivanm> your folks won't mind?
06:38:25 <cocon> type Flip f a b = f b a
06:38:26 * ivanm hopes that situation doesn't come to pass
06:38:46 <cocon> instance Functor (Flip MyType a) where ...
06:38:47 <EvilRanter> cocon, you can only partially apply a type synonym as far back as it was partially applied when you defined it
06:38:52 <Axman6> ivanm: not if you're well behaved and cleanish :P
06:39:08 <EvilRanter> cocon, so you can partially apply "type List = []", but not "type List a = [a]"
06:39:21 <cocon> I see, so this doesn't work for what I want to do
06:39:23 <ivanm> Axman6: :(
06:39:49 <Axman6> heh, that place is walking distance from ANU
06:39:51 <cocon> I want to map over the first argument of (f : * -> * -> *) using Functor
06:39:52 <EvilRanter> cocon, indeed not - it would make type inferrence ambiguous
06:39:57 <Axman6> http://tinyurl.com/yg527rm
06:40:11 <EvilRanter> cocon, consider "type Id a = a; instance Functor Id where fmap = id"
06:40:37 <cocon> so is there no way to do this?
06:40:39 <EvilRanter> cocon, which Functor instance would be used for the type "Id [a]", seeing as it's also "[a]"?
06:41:10 <EvilRanter> newtype-wrapping is the usual way, i believe
06:41:18 <cocon> I can see that this would lead to problems
06:41:45 <cocon> but maybe there's another trick to map over the first argument of a * -> * -> * type using Functor+
06:41:46 <cocon> ?
06:41:50 <EvilRanter> "newtype Flip f a b = Flip { unFlip :: f b a }; instance Functor (Flip Foo a) where ..."
06:42:00 <ivanm> Axman6: yeah, I've found it on the map
06:42:07 <ivanm> which is why I found the price to be rather small :s
06:42:33 <cocon> doesn't that force us to write fmap f (Flip ...) every time we use it?
06:42:34 <Axman6> well, it's an apartment...
06:42:41 <EvilRanter> cocon, yes =/
06:42:48 <cocon> :(
06:43:04 <Axman6> cocon: just write a mapFoo function for your type
06:43:42 <ivanm> Axman6: yes, and most such apartments (even around where you live) are much dearer
06:43:49 <ivanm> so there has to be _something_ wrong with it!
06:44:02 <EvilRanter> ?type mapState
06:44:03 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
06:44:26 <Twey> 14:39:48 < Axman6> ivanm: not if you're well behaved and cleanish :P
06:44:27 <Twey> 14:40:18 < ivanm> Axman6: :(
06:44:31 <Axman6> ivanm: could always try talking to the ANU student accomodation people
06:44:37 <Twey> Ergo, ivanm is neither well-behaved nor cleanish.
06:44:52 <Twey> :þ
06:45:35 * Axman6 only waid cleanish because he's certainly not very clean
06:45:39 <ivanm> Axman6: yeah, couldn't seem to find much info on the site though
06:46:00 <ivanm> Axman6: and I'm currently procrastinating rather than bothering to write up the necessary items for the application :s
06:46:15 <Axman6> heh
06:47:00 * ivanm hits the sack
06:47:03 <ivanm> g'night all
06:47:09 <Axman6> night
06:51:32 <en0th> @quote
06:51:32 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
06:51:49 <Axman6> heh
06:52:01 <skorpan> as if ruby syntax is not ugly
06:52:02 <Twey> I'm tempted to switch the two language names in that quote… :þ
06:52:14 <en0th> yea
06:52:15 <skorpan> ruby has macros?
06:52:26 <Twey> skorpan: Kind of.
06:52:28 <harrison> so if i want to read an int (or float) from a string, and return it and the rest of the string, what function(s) should i be looking at?
06:52:40 <ray> lispers looove macros in the same way java and c++ programmers looooove classes
06:52:44 <skorpan> harrison: head
06:52:45 <Twey> harrison: reads
06:52:55 <Twey> :t reads
06:52:55 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:52:57 <Zao> ray: And Haskell programmers love types.
06:53:00 <ray> yes
06:53:07 <skorpan> > reads "1ahhaha"
06:53:07 <ray> we are all blub programmers
06:53:07 <lambdabot>   []
06:53:13 <skorpan> :|
06:53:22 <en0th> giev types!
06:53:22 <Axman6> > reads "1.234 hello" :: [(Double,String)]
06:53:23 <lambdabot>   [(1.234," hello")]
06:53:26 <Twey> > reads "1ahhahaha" :: [(Int, String)]
06:53:27 <lambdabot>   [(1,"ahhahaha")]
06:53:32 <skorpan> oh, of course
06:53:35 <harrison> sweet, thanks
06:53:39 <skorpan> haskell is so stupid yeah
06:53:46 <ray> lispers are the worst blub programmers though
06:53:46 <Twey> Haha
06:53:56 <ray> it probably defaulted to () or something
06:54:08 <ray> > reads "()()()"
06:54:09 <lambdabot>   [((),"()()")]
06:54:14 <Twey> ray: Yes, it does
06:54:24 <Twey> :t read "hello"
06:54:25 <lambdabot> forall a. (Read a) => a
06:54:29 <Twey> Hmph
06:54:53 <ray> and the reason lispers are the worst is because they're so smug they coin things like "the blub paradox"
06:55:14 <Twey> But it's true.
06:55:23 <ray> but not in the way it was intended
06:55:40 <skorpan> what is the blub paradox?
06:55:40 <Twey> The way it was intended being ‘everybody who doesn't use Lisp is a loser’?
06:55:44 <ray> yeah
06:55:54 <Twey> skorpan: http://www.paulgraham.com/avg.html
06:56:08 <ray> paul graham implicitly disallows anything above lisp
06:56:14 <Makoryu> I've been kicked out of IRC channels often enough for not paying Lisp enough respect...
06:56:18 <ray> unless he's such a genius that he deliberately made his own article an example
06:56:31 <Makoryu> ray: :D
06:56:37 <Twey> ray: I don't think he does
06:56:50 <Twey> He's just giving Lisp as an example of a language that is above the Blub norm
06:57:19 <Twey> He doesn't exactly pay much attention to other potential languages that could be so, but neither does he explicitly disallow them
06:58:21 <Makoryu> In other words........ (Do I really have to say it?)
06:58:27 <harrison> lisp is fun stuff. common lisp rubs me the wrong way, though.
06:58:46 <ray> common lisp is a lot like selling out
06:59:16 <Makoryu> harrison: You mean seeing DEFUN all over the place doesn't get your blood boiling and make you want to bash some heads in with parentheses? ;)
06:59:20 <ray> everyone uses it and no one likes it
06:59:29 <skorpan> common lisp is a programming language. it can neither rub anyone nor sell out.
07:00:05 <Makoryu> The thing that baffles me most about CL is that it's the canonical Lisp in so many people's minds
07:00:40 <Axman6> because it's common, duh
07:01:06 <Makoryu> I guess :/
07:01:50 <seanmcl> have named instances been considered for ghc?
07:01:55 <harrison> scheme was the first real language i used (first language was java). that one is good stuff. clojure is good stuff too
07:02:53 <hackagebot> Vec-Boolean 1.0.0 - Provides Boolean instances for the Vec package (TobiasBexelius)
07:16:45 <dhun> for fun I just combined the new haskell logo with a red start, the result looks a bit like the logo of the former german terrorist group called RAF
07:16:55 <dhun> red star
07:18:17 <Zao> dhun: Like Haskell, they are underdogs too :)
07:18:29 <Zao> They probably also subscribed to "avoid success at all costs"
07:20:13 <en0th> monads make me want to
07:20:16 <en0th> @quote
07:20:17 <lambdabot> pkhuong says: [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
07:20:19 <Twey> Yet there are way more people in #haskell than in #ruby, which subscribes to ‘chase success at all costs’
07:20:41 <aavogt> @faq is Haskell like a terrorist organization?
07:20:42 <lambdabot> The answer is: Yes! Haskell can do that.
07:21:10 <Makoryu> Twey: Y'know, I actually never saw that attitude among non-Rails rubyists while I walked among them.
07:21:34 <dhun> so I will get myself a tshirt with it
07:21:34 <Twey> But aren't the majority Rails Rubyists?
07:21:44 <Makoryu> Twey: It was more like, "I'm doin' fine, 'cause Ruby is pretty neat."
07:21:50 <Twey> Haha
07:21:51 <en0th> hehe
07:21:52 <Makoryu> Twey: Maybe now they are.....
07:22:29 <Makoryu> Ruby had a community for years before Rails was released
07:22:39 <Raynes> Twey: I'm a Rubyist. I've never used Rails, and never intend to. :>
07:22:59 * Axman6 didn't like rails
07:23:54 <dhun> I put the file here it is SVG! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10590#a10590
07:25:47 <Makoryu> Yeah, the Ruby community always had a bit of a schism between Ruby programmers (people who would get along with _why) and Rails programmers (people who wouldn't get along with anybody, especially each other)
07:25:54 <Twey> Haha.
07:28:39 <Makoryu> As supporting evidence, I cite all the huge fights that have erupted... They were all directly related to Rails.
07:29:09 <Axman6> hey have fights? o.O
07:29:16 <Twey> There's a minor Python vs. Ruby crusade, too
07:31:04 <Nafai> I learned Python first and never saw a reason to learn Ruby
07:31:06 <Raynes> Python sucks, Ruby rules!
07:31:08 <Makoryu> Axman6: Two words. Zed Shaw.
07:31:13 * Raynes dons his armor.
07:31:25 <Nafai> Starting to prefer Haskell though :)
07:31:25 <skorpan> ruby is basically python done wrong
07:31:27 <Axman6> tat man has the most awesome blog design i think i've ever seen
07:31:55 <Makoryu> Twey: That's died down somewhat, probably because one of the main points of contention was functional programming, and many of the rubyists flying that particular flag have jumped ship for Haskell ;)
07:32:07 <Twey> Most of the Pythonistas, too :þ
07:32:09 <Makoryu> (And Scala and Clojure and some other stuff)
07:32:13 <medfly> :))
07:32:13 <Nafai> Twey: Yes :)
07:32:35 <Nafai> It's funny, now that I'm finally doing Python full-time for pay, I'm liking it less and less and wanting Haskell
07:32:36 <skorpan> isn't the big deal about haskell its purity though?  i know of no other near-mainstream language to have that
07:33:23 <Axman6> there's lots of things imo
07:33:29 <Saizan> it's not like you can have a referentially transparent imperative language, or can you?
07:34:00 <harrison> clojure has sort-of purity. it's pure except when it isn't.
07:34:00 <Twey> Saizan: Sure you can
07:34:08 <Twey> Referential transparency isn't a problem for imperative languages
07:34:17 <Saizan> how so?
07:34:24 <harrison> yes it is, they just don't know it :V
07:34:28 <Makoryu> But imperative languages have HASH TABLES!!11!11!1!
07:34:37 <Axman6> heh
07:34:38 <Raynes> Clojure makes you jump through hoops to do any mutation.
07:34:46 <Makoryu> On that note, I saw Jon Harrop fighting Slava Pestov on reddit >_>
07:34:48 <Twey> You just restrict IO operations
07:34:48 <Saizan> i mean, i can never substitute 'x' for its definition
07:34:54 <Saizan> because there isn't a real definition for x like in let x = expr, there's only a current value of x
07:34:54 <McManiaC> how do i tell ghc again, module X is my main?
07:35:11 <McManiaC> ghc --make --main Foo.hs or sth
07:35:13 <Twey> Saizan: It's no more difficult than doing the same with, say, the Maybe monad in Haskell
07:35:14 <Axman6> Makoryu: oh really? (don't know who slava is, but i've heard the name)
07:35:16 <Twey> Or State
07:35:18 <Saizan> so the parts where you can apply equational reasoning are quite restricted
07:35:19 <Makoryu> Raynes: Similar hoops to the ones you have to jump through in Haskell to use STM :p
07:35:27 <Axman6> McManiaC: main-is i think
07:35:32 <Axman6> man ghc :)
07:35:38 <McManiaC> No manual entry for ghc
07:35:39 <McManiaC> ^^
07:35:45 <Axman6> :\
07:35:46 <skorpan> arch linux eh?
07:35:55 <McManiaC> yeh
07:35:57 <Axman6> well, you should have a manpage
07:35:59 <Makoryu> Axman6: He's the author of Factor (and jEdit, but nobody cares about that)
07:36:03 <skorpan> Axman6: not in arch linux -_-
07:36:12 <harrison> clojure also has the "sneak out into java" hoop.
07:36:13 <Axman6> skorpan: bah, why not?
07:36:24 * Raynes kind of likes Ruby. ._.
07:36:24 * Raynes feels dirty.
07:36:26 <skorpan> Axman6: don't know. there was some rationale that i heard about, but i forgot.
07:36:42 <Axman6> skorpan: is this in arch in general? or just for ghc?
07:36:59 <Raynes> Nobody cares about Factor either.
07:36:59 <skorpan> Axman6: i don't know, but it seems like some packages come with man-pages and some just don't.
07:36:59 <Makoryu> Axman6: He's also a major evangelist for platform-agnostic standard libraries, and pervasive Unicode-safe string handling
07:37:14 <McManiaC> hmmm
07:37:20 <Saizan> Twey: right, when i do x <- m; .. in the State monad i don't have a definition for 'x' to use, though it's still bettere than "x := <expr>" since in haskell x can never change again
07:37:25 <Axman6> Makoryu: got a link to this fight?
07:37:51 <Makoryu> Axman6: Don't remember where it was. Probably somewhere in the recent proliferation of OCaml threads on proggit
07:37:57 <Saizan> Twey: mh, well the value of 'x' in imperative languages won't change either i guess, maybe the problem is the ubiquituous use of references
07:39:13 <Saizan> ,,no, it'll change.
07:39:14 <lunabot>  luna: parse error on input `no'
07:39:23 <Saizan> man, i've forgot how they work!
07:39:24 <FunctorSalad_> how do I get ghc's CPP to concat a string with a variable?
07:39:44 <FunctorSalad_> #define MAKECAT(X) X_Cat
07:39:47 <FunctorSalad_> doesn't expand
07:40:10 <kpreid> cpp in general, X#_Cat, dunno about ghc
07:40:16 <kpreid> er, X##_Cat
07:40:50 <FunctorSalad_> kpreid: doesn't seem to be supported :(
07:41:34 <Axman6> Makoryu: is he jdh30?
07:41:39 <Makoryu> Axman6: Yeah
07:41:48 * Axman6 has awesome google foo
07:41:51 <Axman6> fu too
07:42:09 <mmorrow> hmm, say you're trying to classify primops for some compiler, and you have (among others) categories [Pure,Effects]. what of those two categories would you associate (the equivalents of) readFooOffAddr# and reallyUnsafePtrEquality# ?
07:42:19 <Makoryu> Axman6: http://www.reddit.com/r/programming/comments/9s3jk/2nd_release_of_jane_streets_core_library_ocaml/c0e7k4s
07:42:34 <Axman6> http://www.reddit.com/user/jdh30/ reading part of that now :P
07:42:58 <mmorrow> dereferencing a ptr seems like it isn't quite an Effect, and kind of not technically impure (??)
07:43:16 <mmorrow> i feel like a need another category
07:43:33 <mmorrow> but what?!
07:44:14 <mmorrow> kpreid: ghc disables stringification since it interacts badly with some haskell syntax
07:44:28 <mmorrow> err, stringification and ##
07:44:52 <olsner> mmorrow: you mean that modifying a pointer is more impure than just reading it?
07:44:56 <mmorrow> (or some rationale along those lines)
07:44:56 * Axman6 throws a coisohohomomomorphic category at mmorrow 
07:45:28 <conal> hrmf.  finicky internet connection this morning.
07:45:28 <mmorrow> olsner: it depends on context
07:45:41 <mmorrow> , 4 {- derefencing a ptr -}
07:45:42 <lunabot>  4
07:45:53 <mmorrow> , peek nullPtr {-dereferencing a ptr-}
07:45:55 <lunabot>  luna: Not in scope: `peek'
07:45:55 <conal> i'm unclear on what could prevent an imperative language from being RT.
07:46:07 <olsner> Axman6: omnomnomnomorphic?
07:46:13 <conal> Saizan: ^^
07:46:43 <Makoryu> conal: Real-time?
07:46:46 * Axman6 is looking forward to applying an omnomnomnomorphism to his breakfast in the morning
07:46:56 <Makoryu> Oh, referentially transparent
07:46:57 <conal> Makoryu:  referentially transparent
07:46:59 <conal> yeah
07:47:17 <Axman6> hmm, LLVM's IR should be RT right?
07:47:25 <Axman6> since it uses SSA
07:47:33 <mmorrow> i'm gonna not put peek in the Effects category i think, since duplicating a ptr deref is ok.. err, but only if it's a valid ptr, gah!
07:47:45 <[UP]XamreX> HI, If someone wanna win IPOD on LOCKERZ just PM me :)
07:47:50 <olsner> hmm, the issue is perhaps whether dereferencing twice can produce different values
07:47:52 <Axman6> @where ops
07:47:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:48:01 --- mode: ChanServ set +o dcoutts
07:48:06 --- kick: [UP]XamreX was kicked by dcoutts (dcoutts)
07:48:17 <Axman6> damn, we do have plenty of ops in here don't we
07:48:23 <dcoutts> @yarr!
07:48:24 <lambdabot> Arr! Me ship be the biggest brig in the port!
07:48:27 --- mode: ChanServ set -o dcoutts
07:48:31 <Saizan> conal: i'm unclear on how you apply RT to imperative programs
07:48:32 <dcoutts> lambdabot: yep, thanks
07:48:43 <Philippa> someone might want to correct my nick in that
07:48:52 <Philippa> Philippa, not Phillipa
07:49:02 <Saizan> conal: or can you apply it only to function definition?
07:49:12 <Jaak_> hmm, is there any way to make lhs2tex play well with unicode? for example if i have unicode in comments it currently just filters those symbols out
07:49:16 <Makoryu> conal: If you can restrict the imperative language to using only single assignment semantics, and make a few other guarantees about what kind of mutation can happen, you can get RT code in an imperative language. Of course, this means you're effectively implementing Haskell's notion of purity ;)
07:49:19 <dcoutts> Philippa: mm, perhaps gwern can do it
07:49:38 <conal> Saizan: that's my lineo of thinking also.  as much as RT has to do with definitions, and imperative languages don't use definitions, maybe imperative languages have an easier time being RT.
07:49:45 <mmorrow> olsner: right, but i'm more aiming this at the level of low-level code gen, e.g. say during register allocation you have to decide if you can push an op down into all branches of a switch, since that'll help with register pressure
07:50:00 <conal> perhaps imperative languages are RT.  as long as one doesn't confuse definition & assignment. and where definitions are used, they can be substituted without semantic change.
07:50:06 <Saizan> dcoutts, Philippa: anyone can overwrite it with @where+, i think
07:50:11 <mmorrow> olsner: hmm, actually that is relevant yeah.
07:50:20 <dcoutts> Saizan: ah, good point
07:50:30 <mmorrow> olsner: ok, gonna put it in Effect to be safe
07:50:33 <Axman6> @whe
07:50:34 <lambdabot> Maybe you meant: where where+ ghc thx what wn
07:50:56 <Saizan> conal: yeah, the problem is that definitions are much less common in imperative languages
07:51:04 <Axman6> @help thx
07:51:05 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,19)-(43,48): Non-exhaustive patterns in case
07:51:10 <Axman6> @thx
07:51:11 <lambdabot> you are welcome
07:51:16 <conal> Saizan: which makes RT easier and less interesting.
07:51:22 <dcoutts> @where+ shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:51:22 <lambdabot> Done.
07:51:33 <Axman6> @where ops
07:51:33 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:51:43 <dcoutts> doh!
07:51:46 <Axman6> dcoutts: heh
07:51:47 <dcoutts> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:51:48 <lambdabot> I will never forget.
07:51:52 <Axman6> @where ops
07:51:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:51:58 <dcoutts> ok :-)
07:51:58 <Axman6> hoorah!
07:52:03 <Makoryu> @where shapr
07:52:03 <lambdabot> Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:52:07 <Makoryu> <_<
07:52:21 <dcoutts> now how do I unset that...
07:52:26 <Saizan> @where- shapr
07:52:26 <lambdabot> Maybe you meant: where where+
07:52:52 <mmorrow> olsner: i think the root of what i'm trying to figure out actually is, do the categories Pure and Effect partition the space of possibilities?
07:52:54 <aug_triad> How could I use a string contained in a variable in quotation marks, e.g. match = x =~ "(variable$)" :: String ?
07:52:59 <Saizan> conal: yeah, maybe i should have said that talking about RT in imperative languages feels almost vacuous to me
07:53:08 <mmorrow> olsner: partition in the math sense
07:53:18 <dcoutts> @where+ shapr
07:53:18 <lambdabot> Done.
07:53:57 <Axman6> @where shapr
07:54:29 <mmorrow> or another way, does (Pure <==> Not Effect) ?
07:55:01 <Axman6> aug_triad: match = x ~= ( "(" ++ show variable ++ ")" )?
07:55:29 * Philippa just fixed a really subtle goof in her code
07:55:42 <Axman6> hooray
07:55:43 <Philippa> I'd got a 'generic' base type and a type synonym for a more specific use with one less type variable
07:55:43 <Makoryu> aug_triad: If explicit string appending doesn't satisfy you, give printf a shot
07:55:47 <mmorrow> hmm, would people call reallyUnsafePtrEquality# an effect?
07:55:54 <Philippa> only, er, I'd defined the base in terms of the synonym when it recursed. Whoops.
07:56:18 <Philippa> for bonus points, this means code recursing on it is suddenly doing polymorphic recursion and you lose principal types
07:56:18 * mmorrow is realizing he needs to define "effect" to answer his questions
07:56:21 <Axman6> :t printf
07:56:22 <lambdabot> forall r. (PrintfType r) => String -> r
07:56:40 <Axman6> @instances PrintfType
07:56:40 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
07:56:46 <Axman6> @hoogle PrintfType
07:56:47 <lambdabot> Text.Printf class PrintfType t
07:56:47 <lambdabot> Text.Printf class HPrintfType t
07:56:48 <Makoryu> > printf "(%s)" "pizza" :: String
07:56:49 <lambdabot>   "(pizza)"
07:56:51 <Philippa> needless to say, my WTF/min was a bit high there, especially when I first found I wasn't getting principal types
07:57:28 <aug_triad> Axmann6: Thank you!
07:57:35 * mmorrow takes the easy way out and defines Pure as not Effect
07:57:39 <Axman6> does printf have something that'll let you say something like: printf "%z" x, where x is a Show instance?
07:57:53 <Axman6> because, it'd be damn useful if it did
07:57:56 <mauke> I don't think that's possible in H98
07:58:22 <Philippa> mmorrow: I'd generally consider reads of stateful variables impure, because it's no longer a pure function of the variable's location
07:58:36 <Makoryu> Axman6: I think you can instantiate PrintfArg
07:58:47 <Philippa> where "pure function" means mathematical function
07:59:06 <Philippa> mmorrow: of course, that means you need compiler prims for other kinds of variable
07:59:09 <mauke> Axman6: requires existentials and overlapping instances
07:59:18 <Axman6> hmm
07:59:31 <mauke> and possibly incoherent instances
07:59:44 * Axman6 notices the printf-mauke package on hackage
07:59:56 <mauke> workaround is printf "%s" (show x)
08:00:14 <olsner> mmorrow: hmm, I don't think pointer equality is *necessarily* in conflict with purity, just that they're difficult to combine
08:01:02 <mmorrow> olsner: i think i'm going to classify that one as Pure, and assume the user knows what she's doing
08:01:26 <mmorrow> Philippa: yeah, i think you're right
08:01:51 <Philippa> olsner: you can pick up (sometimes) cycles that can't be detected purely
08:02:20 <Philippa> GHC puts its version in the IO monad and makes you unsafePerformIO it, IIRC
08:03:02 <Philippa> mmorrow: the user may know what they're doing in using it to crack a system...
08:03:27 <Axman6> ok, sleep time. night all
08:03:29 <Philippa> at least, if there's any but an exceedingly tiny range of ops possible on pointers
08:03:34 <Makoryu> Axman6: Happy coma
08:03:34 <mmorrow> Philippa: enter the Unsafe category! ;)
08:03:35 <Philippa> (are they ordered?)
08:03:52 <olsner> wouldn't it be possible to do something crazy like make all function applications memoized, and thus get pure pointer equality?
08:04:22 <mmorrow> Philippa: err, right that's a distinction i should've made. the ptr equality is on gc-followed ptrs, which aren't ordered. but the Addr type *is* ordered (and presumably only for non-gc-followed ptrs)
08:05:34 <Twey> @index forever
08:05:34 <lambdabot> bzzt
08:05:40 <Twey> ☹
08:06:09 <jfredett> bah, I hate it when things don't work
08:06:21 <jfredett> noone has gotten HWN, right?
08:07:44 <harrison> what's the haskell name for reduce? i'm trying to cat a list of strings together. or is there a better way of going about that?
08:07:52 <mauke> :t concat
08:07:53 <lambdabot> forall a. [[a]] -> [a]
08:07:58 <Makoryu> harrison: foldr (or foldl)
08:08:02 <mauke> @src concat
08:08:03 <lambdabot> concat = foldr (++) []
08:08:20 <Makoryu> @src (++)
08:08:21 <lambdabot> []     ++ ys = ys
08:08:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:08:21 <lambdabot> -- OR
08:08:21 <lambdabot> xs ++ ys = foldr (:) ys xs
08:09:51 <olsner> @ty foldr (flip (foldr (:))) []
08:09:52 <lambdabot> forall a. [[a]] -> [a]
08:09:56 <Berengal> jfredett, I got a mail this morning
08:10:17 <jfredett> Berengal: did it have anything in it? eg, what went wrong this week... :)
08:11:04 <Berengal> jfredett, far as a I can see, nothing. I could mail it back to you
08:11:14 <jfredett> Berengal: please do.
08:11:34 <Makoryu> @pl foldr (flip (foldr (:))) []
08:11:34 <lambdabot> foldr (flip (foldr (:))) []
08:12:46 <jfredett> my test emails had content... but maybe something screwy occured
08:13:17 <jfredett> hmm, looks fine...
08:13:23 <jfredett> maybe... nothing went wrong?
08:14:09 <jfredett> ahh- these emails are about the sequence.complete.org stuff
08:14:21 <Berengal> jfredett, it lists haskell@ and haskell-cafe@ as the recipients, so I guess it worked
08:14:28 <olsner> but there's no HWN at planet haskell?
08:14:44 <jfredett> olsner: not yet, byorgey needs to show me how to post it
08:14:56 <jfredett> now that I have an account
08:16:45 <jfredett> olsner: in the future, this wont occur, but I wanted to test my sendout script... :)
08:17:10 <pikkolo> sera
08:22:47 <SimonRC> :-(
08:23:01 <SimonRC> I just found out that my rather nice datastructure is rather useless too
08:23:40 <SimonRC> I created an infinite heap, each item of which can undergo modify+re-insert (yielding a value)
08:24:07 <SimonRC> I found that someone else had done the same thing using a lazy list and a finite heap
08:24:15 <gwern> @quote blum
08:24:16 <lambdabot> Baughn says: Blum Blum Shub, a PRNG derived from poking around R'Lyeh.
08:24:24 <SimonRC> and theirs compares thing less often, so it is stricter
08:24:27 <gwern> @quote warm.*and
08:24:28 <lambdabot> cjeris says: vincenz: no, on a 286 GHC feels warm, like a little fire you can warm your hands at.  wait, that smells funny.  wait, that was my CPU.
08:24:31 <gwern> @quote warm.*and
08:24:32 <lambdabot> ksf says: * lambdabot locks up ksf in a Monad <ksf> mmmmh it's warm and fuzzy in here.
08:24:42 <gwern> @quote immerse
08:24:42 <lambdabot> monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
08:24:52 <gwern> @quote inevitable
08:24:52 <lambdabot> chak says: ... In other words, FP is inevitable.
08:25:06 <gwern> @quote your.*base
08:25:06 <lambdabot> robreim says: I'm in your base hacking all your lambdas
08:25:21 <gwern> @quote swap
08:25:21 <lambdabot> skew says: Swapping is just a constant factor
08:25:41 <mauke> preflex: quote
08:25:42 <preflex>  <foone> ASEXUAL IS NOT A GREAT NEW WAY TO FUCK PEOPLE
08:26:20 <gwern> @quote ramdisk
08:26:20 <lambdabot> idnar says:  <stepcut> gwern: RAM is overrated, swap is where it's at ;) <idnar> swap to a ramdisk! ;P
08:26:30 <gwern> @flush
08:26:35 <olsner> hoho, ramdisk
08:26:40 <gwern> at least lambdabot's uptime seems to be better these days
08:27:10 <mauke> @uptime
08:27:10 <lambdabot> uptime: 7d 6h 5m 14s, longest uptime: 1m 10d 23h 44m 29s
08:27:35 <jfredett> ... hmm, I think I'm going to try to post the s.c.org HWN on my own... :)
08:27:48 <jfredett> hoorah for not knowing what I'm doing!
08:28:34 <gwern> jfredett: I noticed only the email worked
08:30:34 <jfredett> gwern: right, the s.c.o is not up yet, because I don't know (or didn't know) how to upload it on my own. (brent's been uploading it for me because I didn't have an account.
08:41:40 <jfredett> HWN should be up on s.c.o w/o issue...
08:45:35 <daf> Twey: yeah, I finally got around to it
08:46:08 <Twey> daf: Sweet.  ☺
08:46:32 <deech`> Hi all, is there some way to load individual functions into GHCI? Actually is it possible for GHCI to keep its old set of bindings a loaded file runs into a compiler error?
08:48:15 <Berengal> deech`, afraid not
08:48:25 <Twey> WRT the former, use ‘let’
08:48:43 <Berengal> Twey, doesn't load the function though
08:48:59 <Twey> What do you mean?
08:49:10 <Twey> You can do ‘let f x = x * 3’ and then later on ‘f 2’
08:49:21 <Berengal> You can't load the function definition from a file
08:49:33 <Twey> Oh, I see
08:49:44 <Twey> No, because functions in a file may depend on other functions in a file
08:50:06 <Berengal> And those other functions might not depend on functions that fail to compile
08:50:18 <Berengal> It's something I've missed as well
08:51:37 <Twey> daf: Does Network.DBus have a facility to request a well-known name?
08:52:21 <hackagebot> pisigma 0.1.0.1 - dependently typed core language (AndresLoeh)
08:53:01 <Twey> Heh, ‘hasExcessiveNesting’
08:55:49 <daf> Twey: no, not yet
08:56:09 <daf> Twey: my plans are to make an ErrorT wrapper
08:56:21 <daf> Twey: and then use that to wrap the bus service
08:56:26 <Twey> Oh ah
08:56:28 <daf> Twey: but also to write a binding generator
08:56:46 <Twey> *nod*
09:00:39 <daf> Twey: I actually have an ErrorT wrapper lying around if you're interested
09:01:06 <daf> I just haven't committed it yet
09:01:26 <Twey> I'd like to see it, if you don't mind
09:03:35 <daf> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10592#a10592
09:04:15 <Twey> Thanks
09:04:20 <Twey> Ouch
09:04:29 <Twey> Method0 … Method4 :-\
09:04:30 <daf> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10593#a10593
09:04:39 <daf> Twey: heh, yeah
09:04:40 <Twey> There's got to be some typeclass hackery for that
09:04:56 <daf> yeah, probably
09:05:10 <daf> you could have a class Method which had instances for various numbers of arguments
09:06:02 <daf> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10593#a10594
09:07:20 <daf> perhaps I should overload string literals for DString
09:11:45 <Baughn> deech`: It looks to me like making GHCi abort without resetting to Prelude if :reload fails should be pretty simple. I'll try fixing this..
09:29:57 * Twey cannot for the life of him figure out how one is meant to listen for messages using HDBus.
09:34:25 <Twey> Oh
09:34:29 <Twey> I think I have it!  Woohoo!
09:39:18 <SimonRC> Twey: ??
09:42:38 <Philonous> #join #haskell.de
09:42:45 <Philonous> cripes
09:43:14 <kakeman> join #haskell.fi
09:46:29 <tibbe> awfully quiet here today
09:48:18 <SimonRC> did I already say I found out my library sucked more than I suspected?
09:49:07 <toyvo> Hi. I'm trying to `foreign export ccal incr :: CInt -> IO CInt`, build a DLL and call this from C. It works so long as `incr` is pure, but when I add a bit of IO, I get a segfault. I'm totally puzzled. Any hints?
09:50:30 <toyvo> For example, `incr x = withCString "foo" $ \s -> return ()` >> return (x + 1)` fails with a segfault, but if the `withCString` part is removed, it seems to work.
09:51:03 <Baughn> toyvo: Do you initialize the runtime system before calling incr? How does the program start?
09:52:11 <toyvo> Baughn: the C program links against a shared object produced by GHC. The shared object is linked with a C file that initializes the runtime in `library_init`..
09:52:15 * SimonRC goes
09:52:49 <toyvo> I actually get a trace from it, so I am sure hs_init gets called.
09:53:58 <Baughn> toyvo: And also hs_add_root?
09:54:45 <toyvo> Baughn: hm, I missed this. Looking into it. Thanks.
09:54:53 <Baughn> toyvo: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html <-- Right. Read carefully.
09:55:31 <toyvo> thanks
10:14:59 <fooman> are there any Haskell HTTP servers that support SSL?
10:23:37 <joevandyk> are the c9 functional programming videos worth watching?  http://channel9.msdn.com/tags/C9+Lectures/
10:34:09 <stanv_> length x > 0 -- will calculate full list length, or just see not empty ?
10:34:49 <mauke> full list length
10:35:00 <mmorrow> , null [0..]
10:35:00 <mauke> you want 'not (null x)'
10:35:02 <lunabot>  False
10:36:15 <mmorrow> @let shorterThan n = (> n) . length . take n
10:36:17 <lambdabot>  Defined.
10:36:28 <mauke> > shorterThan 0 []
10:36:29 <lambdabot>   False
10:36:47 <mauke> > shorterThan 1 []
10:36:48 <Makoryu> > 1 `shorterThan` []
10:36:48 <lambdabot>   False
10:36:49 <lambdabot>   False
10:36:52 <mauke> fail
10:36:53 <mmorrow> grrr
10:37:06 <Makoryu> > 0 `shorterThan` "infinity"
10:37:08 <lambdabot>   False
10:37:10 <kau> hello! how to clear the console?
10:37:12 <mmorrow> @undefined
10:37:13 <mmorrow> @undefine
10:37:16 <mmorrow> oops
10:37:20 <Makoryu> @undef
10:37:25 <mmorrow> @let shorterThan n = (n >) . length . take n
10:37:26 <lambdabot>  Defined.
10:37:38 * mmorrow pretends that nevar happened
10:37:50 <mmorrow> > shorterThan 1 []
10:37:51 <lambdabot>   True
10:38:01 <Makoryu> kau: :reload?
10:38:14 <mmorrow> kau: :!reset
10:38:30 <kau> Makoryu: in an haskell console program
10:38:38 <mmorrow> ah
10:38:59 <mmorrow> find out what the `clear' program prints, and print that
10:39:31 <mmorrow> clear | ghc -e 'print =<< getContents'
10:39:46 <mmorrow> "\ESC[H\ESC[2J"
10:39:48 <mmorrow> apparently
10:40:00 <mauke> and that depends on your terminal
10:40:14 <mmorrow> fun
10:41:15 <mmorrow> , text "\ESC[H\ESC[2J"
10:41:15 <byorgey> preflex: seen jfredett
10:41:15 <preflex>  jfredett was last seen on #haskell 1 hour, 59 minutes and 35 seconds ago, saying: HWN should be up on s.c.o w/o issue...
10:41:17 <lunabot>  [H[2J
10:41:30 <mmorrow> useless
10:41:50 * mmorrow wonders if he cleared anyone's terminal
10:42:38 <mauke> +c should filter the escapes
10:42:41 <byorgey> jfredett: I think you forgot to check "promote to front page" when you published the HWN on s.c.o
10:42:50 <mmorrow> mauke: aww
10:42:59 <Zao> Saw no escapes here at least.
10:43:01 <Zao> Which is good.
10:43:07 <byorgey> if I go to "recent stories" the new HWN is there, but if you just go to s.c.o it shows the one from last week.
10:43:24 <mmorrow> oh right, lunabot filters out all control chars too
10:47:21 <flazz> anyone konw the status of 64 bit ghc for snow leopard?
10:47:50 <Alpounet> flazz, I'm pretty sure it's been asked on Haskell-cafe recently, check it out there may be some informations.
10:48:41 <Baughn> flazz: tl;dr: Some people are working on it, it's not ready for use yet
10:49:28 <flazz> Baughn: thanks, but i can compile 32 bit code all day long?
10:49:58 <Lycurgus> ??
10:50:24 <Baughn> flazz: Probably not. In my experience, compiling every compilable package on hackage only takes about twenty hours.
10:50:49 <Saizan> you could compile them again.
10:51:17 <flazz> what is the difference between haskell platform and ghc? i'm upgrading from 6.10.1 ro 6.10.4
10:51:49 <Saizan> more libraries and cabal-install
10:52:03 <flazz> sweet
10:52:09 <Baughn> GHC is the compiler. Haskell-platform is what you program against.
10:52:31 <Baughn> Basically, you can (should be able to) rely on haskell-platform being installed
10:52:56 <Baughn> (Though since it includes cabal-install, anything on hackage is fair game)
10:53:12 <flazz> should i have to remove 6.10.1 first?
10:54:09 <_Ray_> Are there any builtin tools to do Int -> [Int], 124 -> [1, 2, 4]?
10:54:28 <Cale> flazz: Though, there's not much difference between installing the platform from just installing GHC and cabal-install, since the latter will let you easily install any libraries you need.
10:54:58 <Cale> flazz: So, unless there's a binary package of the Platform for your OS, it's probably not worth the trouble to build it.
10:55:33 <Saizan> flazz: i've no problem with several versions of ghc installed on linux
10:56:41 <Cale> _Ray_: I would just  reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)
10:57:09 <_Ray_> I was going to use log or something, but if that works xD Thanks.
10:57:25 <Cale> log?
10:57:50 <kau> thanks mmorrow it worked!
10:58:00 <davidL> > map digitToInt . show $ 124
10:58:01 <lambdabot>   [1,2,4]
10:58:02 <_Ray_> Logarithm, to get the number of digits in base 10, and go dividing and subtracting.
10:58:25 <Cale> Oh, to go from the opposite end, I see.
11:00:15 <mmorrow> kau: heh, nice
11:02:15 <en0th> Cale and mmorrow: thanks for the monad tips
11:02:23 <mmorrow> en0th: no problem
11:02:33 <en0th> today i feel stronger hehe
11:02:37 <mmorrow> heh
11:03:58 <Cale> http://blog.desudesudesu.org/wp-content/uploads/2009/02/27dcd29da9440ccf385d601ad5ea6ae0c9033f4a.jpg
11:04:33 <Makoryu> Is that a tsundere Haskell-tan? o_o
11:05:26 <Alpounet> Cale, no better score than yours until 4000 IIRC.
11:06:13 <Cale> Alpounet: Yeah, I'm starting to think it really may be maximal.
11:06:33 <Alpounet> heh
11:06:46 <Makoryu> > [| 0foo |]
11:06:47 <lambdabot>   <no location info>: parse error on input `|'
11:07:08 <Makoryu> > let 0foo = "bar" in "whoops"
11:07:09 <lambdabot>   <no location info>: Parse error in pattern
11:07:10 <Cale> There's a very good explanation as to why exp(pi sqrt(163)) is particularly close to an integer
11:07:27 <Makoryu> > sqrt 163
11:07:28 <lambdabot>   12.767145334803704
11:08:11 <Makoryu> It's a shame we can't write 1_000_000 for 1000000
11:09:06 <kau> Could you try  sequence $ repeat $ (getChar >> getCurrentTime)?  it displays nothing. Why isn't sequence lazy?
11:09:38 <mauke> why isn't >> lazy?
11:10:13 <FunctorSalad_> doesn't regex-base have substitution?
11:10:35 <Saizan> the standard behaviour of the IO monad is to sequence the side effects
11:11:04 <Saizan> so that action can't return until it completes its own
11:11:09 <hackagebot> usb 0.2.0.1 - Communicate with USB devices (BasVanDijk)
11:11:19 <olsner> Makoryu: like in Ada? :D
11:11:24 <Saizan> ones
11:11:28 <Makoryu> olsner: Yep!
11:11:36 <gwern> 'You know what's more awesome than spending my Saturday afternoon learning Haskell by hacking away at a few Project Euler problems? Fuck, ANYTHING.'
11:11:36 <Makoryu> olsner: And Perl, and Ruby, and...
11:11:41 <gwern> http://teddziuba.com/2009/10/i-dont-code-in-my-free-time.html
11:11:53 <en0th> "a0cd0" >>= (\x -> if (x=='0') then [Nothing] else [Just x]) doesn't look a proper application for a monad.
11:11:58 <stanv_> vim doesn't higlithg `otherwise' keyword :(
11:12:07 <olsner> Makoryu: I wonder why you're only listing languages I dislike :P
11:12:21 <en0th> > "a0cd0" >>= (\x -> if (x=='0') then [Nothing] else [Just x])
11:12:22 <lambdabot>   [Just 'a',Nothing,Just 'c',Just 'd',Nothing]
11:12:26 <Makoryu> stanv_: Doesn't it? It does for me. Update your syntax file!
11:12:37 <Makoryu> stanv_: Or use a different color scheme
11:13:03 <stanv_> Makoryu: ok
11:13:20 <Makoryu> olsner: Because I'm grumpy that it doesn't work in Haskell. Instead, _000 gets tokenized as a VarId :(
11:13:57 <monochrom> I don't code in my free time. That is why I play with haskell in my free time, it is no longer code.
11:14:32 <monochrom> On the other hand, I agree that Project Euler is a global waste of time.
11:16:37 <FunctorSalad_> is there any way to do regex substitution in haskell? ;)
11:17:12 <olsner> monochrom: it's not a waste of time if you have fun doing it
11:17:17 <monochrom> The regex libs can.
11:17:41 <FunctorSalad_> monochrom: I looked through them and can't find any substitution functions
11:19:02 <monochrom> Text.Regex.subRegex is a good first attempt.
11:20:14 <en0th> @quote
11:20:14 <lambdabot> tristes_tigres says: thinks that programming languages can be divided into two broad classes: functional and dysfunctional
11:22:24 <FunctorSalad_> monochrom: thanks, didn't find that
11:32:24 <mreh> @faq I can generates Haskell doc with cabal?
11:32:25 <lambdabot> The answer is: Yes! Haskell can do that.
11:32:47 <mreh> has this been implemented yet?
11:33:19 <en0th> @faq can haskell do time-warp?
11:33:19 <lambdabot> The answer is: Yes! Haskell can do that.
11:33:28 <gwern> mreh: cabal already does haddock generation
11:33:31 <gwern> what more do you want?
11:33:50 <mreh> I dont know how to do it! :..(
11:34:08 <gwern> ha ha!
11:34:19 <gwern> you don't know how to enable haddocks
11:34:26 <gwern> everybody, let's point and haw haw at mreh!
11:34:32 <mreh> right, i've found out
11:36:58 <Cale> http://www.reddit.com/r/programming/comments/9ss7n/haskell%E3%82%BF%E3%83%B3_%E7%B5%B5/ -- hehe, submitted it to programming reddit
11:38:22 <mreh> the cabal directory structure confuses and enrages morbo
11:38:29 <Makoryu> Cale: oh god
11:38:46 <Makoryu> Cale: Well maybe someone will comment on it with a translation of the text...
11:38:58 <luite> what does it say?
11:39:11 <Makoryu> luite: No idea!
11:39:18 <Makoryu> ¯\O_o/¯
11:39:26 <Makoryu> I'd like to know, though.
11:40:32 <gwern> Cale: oh lord. I dread the imminent haskell hentai
11:40:43 <gwern> dildos labeled 'unsafePerformSex'?
11:41:27 <idnar> why would a dildo be unsafe?
11:41:28 <mreh> that's just bad sexual practice general knowledge
11:41:28 <Makoryu> gwern: I take it you've never visited /prog/?
11:41:35 <mreh> idnar: exactly
11:41:39 <gwern> idnar: having sex is not pure
11:41:57 <gwern> haskell is pure; therefore, we must violate her referential hymen with unsafePerformSex
11:42:12 <mreh> how many beers have you had tonight gwern?
11:42:16 <mreh> too many?
11:42:29 <gwern> too few
11:42:43 <mreh> well let us know when you're ready
11:42:49 <gwern> elephants never forget; that's why we drink so much
11:42:49 <Baughn> http://www.reddit.com/r/programming/comments/9ss7n/haskell%E3%82%BF%E3%83%B3_%E7%B5%B5/ <-- Right, here's the official haskell-tan.
11:43:14 <Baughn> ..cale already posted it. Well, now there's a translated version. :)
11:43:20 <gwern> 'secretly very lazy' <-- win
11:46:17 <_Ray_> How would I check if an Int foo is in a given [Int] bar?
11:46:44 <gwern> @hoogle a -> [a] -> Bool
11:46:44 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:46:44 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
11:46:44 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
11:46:46 <luite> _Ray_: foo `elem` bar
11:46:50 <Makoryu> > 3 `elem` [1..10]
11:46:51 <lambdabot>   True
11:46:53 <_Ray_> Thanks :)
11:47:00 <Makoryu> > 9000 `elem` [1..10]
11:47:01 <lambdabot>   False
11:47:38 <Makoryu> > zipWith elem [3,9,12] (repeat [1..10])
11:47:39 <lambdabot>   [True,True,False]
11:48:30 <en0th> is everything i find in hoogle already available in a fresh ghc installation?
11:49:10 <gwern> should be, I think; it doesn't cover hackage libs
11:49:11 <Cale> en0th: Not necessarily
11:49:27 <Cale> Er
11:49:37 <Cale> Doesn't it cover some extra libraries?
11:49:58 <luite> > (`elem` [1..10]) <$> [3,9,12]
11:49:59 <lambdabot>   [True,True,False]
11:50:05 <en0th> for example i cannot load Network.HTTP module, so i assume it's an extra lib
11:51:38 <byorgey> en0th: yes, it is.
11:51:58 <byorgey> en0th: I think pretty much everything you find in hoogle is availble in a fresh Haskell Platform installation.
11:52:55 <Baughn> en0th: Network.HTTP, in particular, is in  the http package
11:53:51 <en0th> ok, and to install extra packages, i assume i'll need cabal. right? i'm on arch linux..
11:55:08 <byorgey> en0th: cabal is the easiest way, yes.
11:56:13 <byorgey> en0th: just pacman -S cabal-install
11:56:45 <en0th> okay, many thanks
11:58:02 <byorgey> then 'cabal update' to get the latest package list, then 'cabal install foo' to install package foo
11:58:30 <byorgey> I don't know what version is in arch, so you might want to 'cabal install cabal-install' to make it upgrade itself first =)
12:00:37 <en0th> mm, everything seems ok
12:07:35 <rmoss> i'm working on my homework for my adv fp class, I've been staring at this code for hours and can't figure it out http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10598#a10598 what i'm trying to do is change the return type of eval to Maybe Val using the <*> operator where necessary.  I've trying making small modifications then using ghci to see how it complains and incrementally fix all error that arise - but I'm getting nowhere as I can'
12:07:36 <rmoss> t even tell when i'm doing something right or wrong - please help
12:11:03 <Raevel> to do that i might put the new signature on eval, and then checking where errors arise, you could replace any function body with undefined and just change the types until it compiles, then dig into the function bodies
12:12:08 <rmoss> yeah, not a bad idea - having a chain of errors is driving me nuts
12:12:34 <mmorrow> en0th: here's a stack-machine State monad thing that our earlier conversation prompted http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10599
12:15:38 <en0th> I cannot thank you enough. I would never came up with that alone. I will study it deeply.
12:16:44 <mmorrow> no problem :)
12:32:32 <Fredderf> @pl (\x -> map (x:) rest)
12:32:32 <lambdabot> flip map rest . (:)
12:33:21 <_Ray_> Hey, I'm having some typing issues, I've pasted the relevant code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10600 . I'm trying to do some automatic memoization of my code, using the "map" trick I found online. However, GHC keeps saying "ouldn't match expected type `Int' against inferred type `[Int]'". What am I doing wrong? (The function is supposed to be [Int] -> [Int])
12:33:25 <Fredderf> Is there a standard libary function that does (\x -> map (x:) rest) ?
12:34:07 <olsner> @pl (\x -> map (x:) rest)
12:34:07 <lambdabot> flip map rest . (:)
12:34:49 <byorgey> Fredderf: no.
12:35:28 <Makoryu> @pl \x rest -> map (x:) rest
12:35:28 <lambdabot> map . (:)
12:35:30 <byorgey> @type (!!)
12:35:32 <lambdabot> forall a. [a] -> Int -> a
12:35:39 <byorgey> _Ray_: !! takes an Int as a second argument.
12:35:47 <Makoryu> :t map . (:)
12:35:48 <lambdabot> forall a. a -> [[a]] -> [[a]]
12:35:58 <byorgey> _Ray_: something of the form  (foo !!)  can't possibly have type  [Int] -> [Int].
12:36:14 <byorgey> _Ray_: maybe you mean  map (foo !!)  ?
12:36:39 <byorgey> i.e. makeChain = map ((map makeChain' [ ... ]) !!)
12:36:40 <Twey> Still can't…
12:36:43 <_Ray_> Ah...that sucks then :s I honestly don't *know* what I mean, I was just looking for a cheap way to memoize an [Int] -> [Int] functin
12:36:46 <Twey> Oh, sorry, can.
12:37:02 <_Ray_> *function.
12:37:58 <byorgey> _Ray_: have you looked at the data-memocombinators library?
12:38:19 <_Ray_> byorgery, nope, but I'll google it :)
12:39:02 <byorgey> _Ray_: http://hackage.haskell.org/package/data-memocombinators
12:39:32 <Makoryu> > "pizza" !! 3
12:39:33 <lambdabot>   'z'
12:40:01 <Zao> My pizza is () :(
12:40:07 <Makoryu> :(
12:44:04 <byorgey> > map ("pizza" !!) [2,3,3,2,3,2,2,2,3,3,2]
12:44:05 <lambdabot>   "zzzzzzzzzzz"
12:53:50 <_Ray_> byorgey, I'm apparently too stupid to even use the package right... I again get a type error, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10600#a10601 (second paste) . "Couldn't match expected type `a -> r' against inferred type `[Int]'". I don't know why it thinks (does it?) that makeChain' is an [Int]...the example in the package page is simple: "  fib = Memo.integral fib'  ".
12:55:18 <byorgey> _Ray_: if you look at the type of Memo.integral, it is   integral :: Integral a => Memo a
12:55:31 <byorgey> however, the type of Memo.list is list :: Memo a -> Memo [a]
12:55:45 <byorgey> that is, list is a higher-order memo combinator, you have to give it another combinator as an argument.
12:55:53 <byorgey> In this case I think you would want  Memo.list Memo.integral
12:55:59 <byorgey> since you want to memoize a function from [Int].
12:56:23 <_Ray_> Oh....jesus....I'd have never figured that - I'm still pretty new in Haskell type signatures...thanks :)
12:56:35 <byorgey> _Ray_: no problem, you'll learn =)
12:56:57 <byorgey> _Ray_: trying to grok type signatures is always worth it.
13:11:42 <SimonRC> ouch netwibble
13:31:34 <Jonathan_Poulter> Hello :) I have a question, if anyone's able to answer it (I have the question regardless I guess :P )
13:31:57 <Jonathan_Poulter> foldr takes a -> a -> a
13:32:08 <Jonathan_Poulter> filter takes a -> a -> Bool
13:32:10 <monochrom> No, foldr1 takes a->a->a
13:32:15 <Jonathan_Poulter> Ah yea
13:32:17 <SimonRC> monochrom: yeah
13:32:20 <Jonathan_Poulter> foldr1
13:32:54 <SimonRC> and filter takes a -> Bool not a -> a -> Bool
13:33:22 <SimonRC> Jonathan_Poulter: anyway, what was the question?
13:33:25 <Jonathan_Poulter> Okay fail all around...
13:34:43 <solidsnack> So I am looking at EnumMap and it seems it uses `fromEnum :: (Enum k) => k -> Int` all over this place.
13:35:03 <solidsnack> What this says to me is that using EnumMap with Word64 is setting myself up the bomb.
13:35:30 <Jonathan_Poulter> fA ::  a -> a -> a
13:35:31 <Jonathan_Poulter> fA d1 d2
13:35:33 <Jonathan_Poulter>     | d1 > d2 = d1
13:35:34 <Jonathan_Poulter>     | otherwise = d2
13:35:36 <Jonathan_Poulter> fB :: a -> a -> Bool
13:35:37 <Jonathan_Poulter> fB d1 d2
13:35:39 <Jonathan_Poulter>       | d1 == f d1 d2 = True
13:35:40 <Jonathan_Poulter>       | otherwise = False
13:35:42 <Jonathan_Poulter> Is it usual practice in Haskell to write fB as I have? Using fA or would I rewrite all the logic which decides which of d1 or d2 is better (currently in fA).
13:36:11 <Jonathan_Poulter>  | d1 == fA d1 d2 = True *
13:36:22 <Vanadium_> @src max
13:36:22 <lambdabot> max x y = if x <= y then y else x
13:37:35 <Vanadium_> is fB not just d1 >= d2?
13:38:40 <Jonathan_Poulter> Max won't cut it as there's another argument involved, which changes d1>d2 but all my logic within fA produces, which is bigger? d1 or d2.
13:39:27 <Jonathan_Poulter> fA returns the bigger of the two, fB should return True if d1 > d2.
13:42:52 <solidsnack> It makes me so unhappy that, under the hood, EnumMap is just IntMap.
13:43:15 <solidsnack> Int is the worst index type ever.
13:43:22 <Berengal> solidsnack, why?
13:43:51 <solidsnack> Berengal: Indices into arrays, collections of persons, &c. are generally positive.
13:44:04 <solidsnack> I don't want to lose half of them.
13:44:16 <solidsnack> Also, compound indices really need all the space you can give them.
13:44:36 <solidsnack> The fact that Haskell arrays are all backed with Int leads to a lot of the same problems.
13:44:43 <monochrom> Jonathan_Poulter: This is an aside. If you use < inside fA, the type of fA can't be a->a->a. It is (Ord a)=>a->a->a
13:46:06 <Jonathan_Poulter> Yea, I've just generalised code I have, (badly it seems)...
13:46:11 <Berengal> solidsnack, depends on how you look at it, I guess. I don't use Int for numbers (Integer is so much better), so I tend to see them as a simple collection of 2^64 distinct values
13:46:38 <monochrom> Also Vanadium_ is right unless you have strange, axiom-violating implementations of < and ==
13:46:40 <solidsnack> Berengal: Well, `Int` is only 2^32 distinct values.
13:47:00 <solidsnack> Berengal: If it were 2^64, there's no way I'd have a problem with it.
13:47:02 <Berengal> solidsnack, on a 32 bit machine... it's 2^word-size values
13:47:54 <Berengal> > maxBound :: Int
13:47:55 <lambdabot>   9223372036854775807
13:48:05 <Berengal> > 2^63
13:48:06 <lambdabot>   9223372036854775808
13:48:26 <solidsnack> Berengal: Plenty of us are on those machines; had the implementer of the varied array types specified a 64 bit representation we'd all be better off as far as correctness is concerned.
13:49:32 <monochrom> lambdabot is on a 64-bit platform.
13:50:38 <solidsnack> Also, your use of `Integer` is just not germane to issues of array and map indexing. The efficient maps are not backed with `Integer`.
13:50:40 <monochrom> Having diversified platforms in production use is good because programmers no longer have excuses to make unwarrant assumptions.
13:51:39 <Berengal> solidsnack, don't these support negative indices?
13:51:56 <solidsnack> No, you can't index backwards in an array.
13:52:21 <solidsnack> You can perform subtraction on indices, sure; but negative array indices don't make any sense.
13:53:09 <Fragsworth> Is there some kind of help function in haskell similar to python's help() that displays docstrings from an interpreter
13:53:12 <morganson> howdy
13:53:16 <Berengal> I was hoping the array implementation would map the integers to words under the hood
13:53:19 <solidsnack> Fragsworth: No.
13:53:27 <solidsnack> Berengal: It's the other way :(
13:53:31 <ddarius> There are no docstrings.
13:53:42 <Berengal> Fragsworth, :t does display the type, which is usually good enough for me
13:53:43 <Fragsworth> If I want to see documentation on a function, what's the simplest way?
13:53:43 <solidsnack> Fragsworth: Try Hayoo!
13:53:44 <ddarius> You could make them though...
13:54:18 <Berengal> solidsnack, sad... IntMap surely must support them though
13:54:24 <Jonathan_Poulter> which is better? Hoogle or hayoo?
13:54:41 <solidsnack> Jonathan_Poulter: I've come to prefer Hayoo.
13:54:59 <solidsnack> Jonathan_Poulter: The easiest way to figure that out, though, is to try them both.
13:55:08 <SimonRC> we need Hogpile, which would delegate to both
13:55:23 <Jonathan_Poulter> :P
13:55:30 <solidsnack> Berengal: It's true that `IntMap` does support negative indices as it supports any integer index.
13:55:36 <SimonRC> (ah, those were the days, when there was actual competition in the search-engine market)
13:56:36 <SimonRC> (rather than one search engine, one portal, one microsoft default, a few specialists, and the occasional fraud)
13:57:19 <Berengal> solidsnack, so you could map your enums to the whole range of Ints and have no issue with EnumMap using Int instead of Word
13:58:00 <solidsnack> Berengal: For Word32, yeah -- I hope I can do so in a way that satisfies the invariants for Enum.
13:58:14 <Twey> SimonRC: There's not much use for competition — unlike some people we could name, Google doesn't seem to slip into complacency and stop updating its products when it has no competition.
13:58:15 <solidsnack> For Word64, no, not on many of the machines that will be used with this code.
13:59:10 <SimonRC> Twey: it is nice to have a company that are (relatively) obsessed with making the tech world love them
13:59:13 <Berengal> solidsnack, why not? For Word64, the ints would be Int64 anyway
13:59:15 <Twey> Indeed
13:59:40 <Jonathan_Poulter> People often don't like people who try too hard though...
13:59:59 <Twey> Jonathan_Poulter: But who's to blame, eh?  Who's to blame?
14:00:00 <Berengal> Jonathan_Poulter, it helps when they succeed
14:01:07 <Jonathan_Poulter> First people are awefilled, then get itchy and kinda distrustful... Google Latitude anyone (?!).
14:01:25 <solidsnack> Berengal: Only on 64 bit machines.
14:01:25 <ksf> So, who's going to coauthor "Category theory for Hackers"
14:01:44 <Twey> Hahaha
14:01:58 <luite> teach yourself category theory in 24 hours?
14:02:14 <Vanadium_> Real World Category Theory?
14:02:15 <Twey> The Google Latitude intro picture places one of my three ‘friends’ in the English Channel.
14:02:31 <Jonathan_Poulter> Unlucky guy...
14:02:38 <Twey> Vanadium_: Heh, isn't that a contradiction in terms?
14:02:43 <ksf> take category-extras, ban proofs from the texts, limiting them to exercises...
14:02:46 <solidsnack> Berengal: So I can't do it; `fromEnum :: (Enum n) => n -> Int` takes that "local int". So if I use `Word` then I'd get 64 bits and machines where the `Int`s are 64 bits; but I wouldn't want to specify a mapping that causes a runtime error on 32 bit machines.
14:03:17 <ksf> yep the Enum class is borked.
14:03:36 <solidsnack> ksf: Really, the problem is arrays and EnumMap and such.
14:03:39 <solidsnack> And lists.
14:03:51 <solidsnack> `Int` is not an index type but everyone builds indices off of it.
14:04:11 <Fragsworth> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v%3Ainteract - why when I use this function (interact) in the interpreter, it doesn't block and wait for input?
14:04:46 <Fragsworth> shouldn't it wait for input until EOF?
14:04:47 <Berengal> solidsnack, Int32 and Word32 are trivially mapped to Int64 and Word64
14:04:53 <ksf> an IntMap doesn't really differ from an IntegerMap... it's bitmangling in both cases, and the Bits instance and ghc magic hides all differences.
14:05:28 <solidsnack> Berengal: It's the other way around that is the problem.
14:05:38 <morganson> what is the best way to debug in haskell. Is there even really a need for a debugger? (I'm a beginner)
14:05:38 <Berengal> solidsnack, so don't
14:05:44 <ksf> fromEnum :: (Enum n, Natural i) => n -> i
14:05:50 <Berengal> morganson, do you have a need for one?
14:05:54 <solidsnack> Berengal: I fear we are talking at cross purposes.
14:06:26 <solidsnack> The problem is, to work with these collections I have to shoehorn my data into `Int`; on 32 bit machines, that imposes a certain restriction.
14:06:30 <Berengal> morganson, typically, I just poke around in ghci and stare code into confessing the bugs
14:06:46 <ksf> Vanadium_, luite, Twey, http://www.reddit.com/r/haskell/comments/9ski4/a_more_approachable_approach_to_category_theory/
14:06:51 <morganson> I havn't got the need for one so far. but I've just began using haskell. wonderful language by the way. =)
14:07:06 <solidsnack> Were the collections more liberal -- or sensible -- in their selection of the underlying index, I wouldn't have this problem.
14:07:17 <morganson> allright
14:07:23 <ksf> CT is enticing, but every single text about it sucks if you don't happen to crave proofs.
14:07:36 <solidsnack> ksf: I'm not sure what you're saying -- don't Integer map and IntMap have really different representations, the latter in terms of special trees?
14:08:15 <ksf> IntMap is a fingertree branching on longest bit-prefixes. you can do the exact same thing for Integers.
14:08:43 <Berengal> solidsnack, on 32 bit machines you can't really have more than 2^32 known indices into a collection anyway, and that's what you get with Int and IntMap
14:08:48 <ksf> ...with essentially the same code, as you're using Data.Bits, anyway.
14:08:55 <luite> ksf: unfortunately the server doesn't seem to respond
14:09:09 <ksf> Berengal, that doesn't account for sparse maps, though.
14:09:20 <ksf> If my indices were consecutive I'd use an array.
14:09:37 <ksf> luite, yeah, reddit's quite slow sometims.
14:09:47 <solidsnack> Yeah, and it's a sparse map that I'm building.
14:10:05 <morganson> what is polymorphism and how does the polymorphic types look like? [a] -> [b] ??
14:10:08 <luite> ksf: I mean the server with the original article (at utwente.nl)
14:10:14 <Berengal> ksf, I specified known indices. Unknown indice types requires trie-like things
14:10:17 <ksf> oh.
14:10:34 <ksf> but that's not as important as the discussion and mutual ignorance going on, anyway.
14:10:53 <Fragsworth> how do you indicate EOF on stdin when using ghci
14:11:01 <Berengal> ^D
14:11:03 <solidsnack> Fragsworth: ^D ?
14:11:09 <Fragsworth> hmm.. doesn't seem to work
14:11:09 <mmorrow> solidsnack: why not (\i x -> IM.insert ((fromIntegral :: Word -> Int) i) x) ?
14:11:10 <ksf> at least on unix, that is.
14:11:22 <Berengal> ksf, windows too, last I checked (yesterday)
14:11:32 <mmorrow> solidsnack: 32bit Int (and 32bit machines) for that matter do suck though
14:11:46 <ddarius> If you don't like proving things, don't do math.
14:11:54 <Fragsworth> I'm using the "interact" function - is this different somehow?
14:11:55 <solidsnack> I second ddarius
14:12:22 <Berengal> Fragsworth, interact in ghci is a bad idea
14:12:56 <solidsnack> mmorrow: So how will I find the index later? I just need to change all my indexes to be `Int`s.
14:13:09 <ksf> there's a gmap successor btw that typomagically chooses implementaitons based on key type, so we don't really need to care about maps anymore.
14:13:10 <Fragsworth> Berengal: I guess ghci is a bad idea in general if I'm trying to learn?
14:13:21 <ksf> forgot the name of the beast, though.
14:13:29 <mmorrow> convert from Word to Int on insert and lookup
14:13:37 <Berengal> Fragsworth, not at all. ghci is great for poking around in
14:13:44 <ksf> ghci is great if you like repls.
14:13:56 <mmorrow> solidsnack: (also IntMap could be made WordMap with probably 10 lines of changes)
14:13:59 <ksf> or need a decent desk calculator.
14:14:00 <Berengal> But keep a file with definitions handy as well
14:14:11 <morganson> Fragsworth: I am using ghci and I'm a beginner. But there is also an alternative called HUGS.
14:14:21 <mmorrow> solidsnack: is the the issue that the key type is Int as opposed to Word, or something else?
14:14:38 <Fragsworth> I've just noticed that so many things seem to work fine if I compile/execute but if I try it in the interpreter it blows up
14:14:51 <ksf> but hugs doesn't come with a savant compiler.
14:14:53 <luite> ksf: I'm still waiting for the mathematica-like ghci shell with interactive graphical objects :p
14:15:05 <ddarius> luite: Make it.
14:15:06 <morganson> ksf allright
14:15:19 <ddarius> luite: Or look at Vital.
14:15:22 <luite> ddarius: yeah I was afraid of that answer ;)
14:15:29 <morganson> I prefer ghci! =)
14:16:00 <ddarius> @where vital
14:16:00 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
14:16:03 <ksf> Fragsworth, ghci isn't really tuned towards bug-free handling of IO.
14:16:25 <ksf> supposedly it's meant to be used to try out pure functions.
14:16:40 <luite> ddarius: ah looks interesting
14:17:42 <gwern> indeed. it's not hard to segfault ghci when doing graphics stuff, for example
14:17:56 <sappho> Hey. I'm trying to install SDL on windows but upon running "runghc Setup.lhs configure" on the command prompt I get a "SDL not found" message. Anyone got any ideas?
14:18:04 <mmorrow> speaking of somewhat related things.. it's appalling that the on x86_64 you have 256bit %ymmN regs that you can't use (yet), and even more that you can only get at 64bits of the 128bit %xmm regs with any compiler i know of (err, does this need OS support? is it even supported yet?)
14:18:46 * mmorrow wants 256bit/2x128bit/4x64bit/8x32bit floats
14:19:05 <ksf> yep those'd rock for dph
14:19:19 <ksf> they're doing all that fancy stuff and I can't use it on my single core.
14:19:28 <mmorrow> multiply 8 floats with 8 floats in a single cycle! (i think a single cycle)
14:19:48 <Berengal> I want 240x64bit floats for my GPU...
14:19:58 <solidsnack> mmorrow: I have several issues with `Int` as an index type.
14:20:02 <ksf> gpgpu stuff that doesn't need cuda, too.
14:20:15 <sappho> I already have MinGW and Msys installed.
14:20:17 <ksf> ...my geforce is gpgpu capable, but you have to use glsl
14:20:18 <mmorrow> solidsnack: but as opposed to Word, or as opposed to _?
14:20:37 <solidsnack> Once upon a time, I wanted to make an evil bit array of 2^32 bits using Haskell arrays -- if it had been Word, that would have been better.
14:20:49 <solidsnack> So yeah, Word would be great.
14:21:06 <mmorrow> solidsnack: ok, we need a WordMap then.
14:21:14 <mmorrow> (i'd find that handay too)
14:21:21 <solidsnack> mmorrow: Well, actually shouldn
14:21:28 <solidsnack> 't EnumMap do this already?
14:21:32 <mmorrow> i've been meaning to make an MD5Map lately too
14:21:47 <solidsnack> It would, except Enum has Int baked in!
14:21:48 <ksf> sse can do shuffles by mask, can't it?
14:21:48 <mmorrow> solidsnack: i think that just converts to/from Int
14:22:05 <solidsnack> mmorrow: Right, that's all it does. Yuck.
14:22:15 <mmorrow> solidsnack: what you get with a monomorphic key-type is the keys unpacked into the constructors
14:22:29 <ksf> solidsnack, do a BitsMap
14:22:38 <ksf> ...for all types having a Bits instance.
14:22:50 <solidsnack> ksf: So maybe it's backed with a Trie?
14:23:04 <ksf> it's a fingertree
14:23:16 <solidsnack> That would be the right way, yeah.
14:23:16 <ksf> ...at least last time I looked. or the gmap one.
14:23:20 <ksf> or something like that.
14:23:26 <mmorrow> hmm, i wonder if you could make a DoubleMap and just do bitops on Word64s that are coerced Doubles (i.e. is the bit stuff that IntMap does inherently tied to the as-a-number ordering of the key type?)
14:23:39 <mmorrow> i don't recall
14:24:08 <ksf> branch on longest bit prefix makes a lot of sense for many data types.
14:24:19 <solidsnack> I think, yeah, that's right on.
14:24:37 <solidsnack> Though it'd end up being longest byte prefixes, really.
14:24:40 <ksf> it's actually the same beast as a trie of strings, just that those use prefixes that are a multiple of the char width.
14:25:11 <ksf> solidsnack, I don't think so.
14:25:15 <solidsnack> No?
14:25:58 <ksf> the fun thing is that finding the longest prefix is an insert operation, and lookup becomes virtually O(1)
14:25:58 <mmorrow> it's not quite a fingertree, but a bit trie
14:26:31 <mmorrow> (w/ an efficient representation of a bit)
14:27:10 <solidsnack> mmorrow: What would that be? Don't I have to allocate a Word for it no matter what?
14:27:52 <ksf> depends on architecture.
14:28:25 <ksf> generally, reserving a single bit doesnt' make any sense on an architecture that filles cache lines in say .5k-blocks.
14:28:35 <ksf> ...or anything else bigger than a single bit.
14:29:19 <mmorrow> solidsnack: right, but you can put 64bits in a Word
14:29:31 <ksf> and if you're map is getting dense enough to have a significant memory overhead you should be using more arrays, anyway.
14:29:50 <ksf> plus, in the end there's no data structure that fits every usage scheme perfectly.
14:29:57 <mmorrow> (compared to e.g.  type Bit = Bool, or type Bit = Int {-0=0,1=1-})
14:30:47 <solidsnack> mmorrow: What is the latter syntax? Is  that actually Haskell or is it Agda or ... ?
14:30:59 <mmorrow> a comment :)
14:31:11 <ksf> that's design by wishful thinking.
14:31:14 <solidsnack> :(
14:31:18 <ksf> it's a sicp technique.
14:31:25 <solidsnack> LOLz
14:31:31 <mauke> ah, so that's what it's called
14:41:20 <ksf> @hoogle ByteString -> [Integer] -> [ByteString]
14:41:21 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:41:21 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:41:21 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
14:51:06 <dmwit> Is there a way to find out which (not yet installed) package provides a particular module?
14:51:16 <dmwit> Say, restricting ourselves to things found on Hackage?
14:53:18 <sproingie> hoogle or hayoo?
14:53:26 <sproingie> i think hayoo has more stuff
14:54:59 <dmwit> Hoogle doesn't have it, and Hayoo seems down.  But the README said more, so I feel pretty silly now. =)
14:55:37 <sproingie> hayoo's working, it's just slow
14:55:52 <ksf> waaagh parsing.
14:56:17 <sproingie> waaaaugh!
14:56:27 <sproingie> we'll make it orky!
14:56:38 <ksf> It figures I can make a lot of assumption about the data and be reasonably sure that they're met, but I need to have backups in case these assumptions don't hold.
14:57:26 <ksf> ...which imposes questions like whether it makes sense to check whether a list is sorted if instead of just sorting it.
14:58:45 <ksf> ...as it appears, mkv seek information isn't specced to have ever increasing indices, but all mkvs seem to do it in exactly that way.
14:58:49 <morganson> > :t fold
14:58:50 <lambdabot>   <no location info>: parse error on input `:'
14:58:58 <ksf> s/ever/always/
14:59:03 <morganson> > :i fold
14:59:04 <lambdabot>   <no location info>: parse error on input `:'
14:59:27 <ksf> there don't seem to be specs on seek information being complete, either.
15:00:49 <ksf> ...not to mention that writing seeking information that refers to the transport layer into the data layer is a blatant layering violation, but there's a sane way to have clean code anyways.
15:01:57 <ksf> ("here's a thingy that has a tag in front. you can have the whole bytestring, the bytestring interpreted as a container, or you can specify indices to get you such a container and hope that stuff won't blow up)
15:03:30 <ksf> ...let's have a look at the error recovery support of that uu parsing lib.
15:10:02 <majoh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4337  Will that thing keep the whole input in memory?
15:11:22 <dmwit> no
15:11:52 <Saizan> it'll initially read the whole line in memory
15:12:17 <majoh> okey, which is it? :-)
15:12:19 <dmwit> Are you sure?
15:12:22 <dmwit> Don't we have lazy IO?
15:12:24 <Saizan> but then the line can be gargage collected incrementally as soon as the elements are consumed
15:12:33 <Saizan> not for getLine, fortunately
15:12:45 <majoh> should i look into getcontents instead?
15:13:00 <Saizan> majoh: however i suspect the space leak is cause by your lazy acc, rather than the string
15:13:11 <majoh> oh?
15:13:44 <dmwit> Huh, I did not know that.
15:13:48 <majoh> how come/
15:13:55 <Saizan> since you never pattern match against acc in your "expected" function then the operations on it don't get evaluated step by step
15:14:02 <majoh> oh
15:14:08 <majoh> should i put a seq in there maybe?
15:14:15 <Saizan> yeah
15:14:27 <majoh> thanks, gonna try that :-)
15:14:30 <Saizan> the easiest way is to enable BangPatterns and use !
15:14:44 <majoh> never heard of those...
15:14:49 <dmwit> expected h $! acc + v * 0.5^h $ r -- should work, too
15:15:09 <Saizan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4337#a4338 <- like this
15:15:37 <Saizan> foo !x = .. is translated to the equivalent of foo x = x `seq` ..
15:15:45 <skorpan> (.) binds tighter than (>>=) right?
15:16:28 <Baughn> Feels that way
15:16:30 <Saizan> dmwit: you'd need "(expected h $! acc + v * 0.5^h) $ r" because $! and $ are right associative
15:16:44 <Baughn> skorpan: ghci :info'd tell you for sure. ;)
15:16:53 <skorpan> :info (>>=)
15:17:04 <Baughn> ghci.
15:17:12 <skorpan> yeah, i just figured maybe lambdabot had that already
15:17:19 <skorpan> anyways, >>= is way looser than .
15:17:21 <Baughn> Pity, but not
15:17:53 <dmwit> urk, yes
15:17:55 <skorpan> >>= is just a tad looser than $
15:18:02 <dmwit> My Haskell-fu is weak, I haven't coded in a while.
15:34:03 <sinelaw> General question regarding DSLs: If I want my DSL to take full advantage of Haskell's type system, meaning I want to rely on the type system for type safety in the DSL - does this mean that I can't modify a DSL syntax structure in runtime? (without using a run-time haskell compiler)
15:36:41 --- mode: irc.freenode.net set +o ChanServ
15:37:34 <skorpan> why is the body of Network.HTTP.Base.Request polymorphic? i would expect the body to always be a string?
15:37:40 <Saizan> it can be a [Lazy.]ByteString too
15:37:49 <skorpan> i see, and that's about it?
15:38:18 <skorpan> can bytestrings represent utf-8?
15:38:21 <Cale> Maybe the Text datatype?
15:38:39 <sinelaw> Saizan, my DSL uses Haskell types
15:38:43 <Saizan> i don't remember the name of the class, but there's one there
15:39:28 <Saizan> HStream
15:39:48 <Saizan> and it only has the ones i listed as instances
15:40:05 <Saizan> skorpan: a bytestring is just bytes, you'd have to decode it yourself
15:40:16 <Veinor> o/
15:40:41 <Saizan> sinelaw: yes, that much was clear
15:41:27 <Saizan> sinelaw: can you elaborate on what you mean by "modify a DSL syntax structure at runtime"?
15:46:53 <O_4> Why does "12::Int < 2^32" evaluate to False?
15:47:11 <skorpan> > 12 :: Int < 2^32
15:47:12 <lambdabot>   Only unit numeric type pattern is validOnly unit numeric type pattern is va...
15:47:12 <tommd> > 2^32 :: Int
15:47:13 <lambdabot>   4294967296
15:47:24 <tommd> > 2 :: Int < 2^32
15:47:25 <lambdabot>   Only unit numeric type pattern is validOnly unit numeric type pattern is va...
15:47:35 <skorpan> what the heck is that error message all about?
15:47:38 <tommd> > (12 :: Int) < 2^32
15:47:39 <lambdabot>   True
15:47:43 <ksf> > (2 :: Int) < 2^32
15:47:44 <lambdabot>   True
15:47:48 <tommd> O_4: I think you have issues.
15:47:56 <mauke> > 1 :: 2
15:47:57 <lambdabot>   Only unit numeric type pattern is valid
15:47:58 <tommd> O_4: What architecture and compiler?
15:48:12 <Berengal> > (12 :: Int) < 2^64
15:48:13 <lambdabot>   False
15:48:14 <mauke> O_4: because you're on a 32-bit system and 2^32 is 0
15:48:43 <O_4> Intel OS X, ghc 6.10.3
15:48:56 <ksf> > (2 :: Word64) < 2^32
15:48:57 <lambdabot>   True
15:49:00 <ksf> > (2 :: Word32) < 2^32
15:49:01 <lambdabot>   False
15:49:08 <O_4> mauke: ah, that makes more sense
15:49:11 <tommd> O_4: That isn't a full architecture, but I'm guessing mauke has it and your running 32 bit.
15:49:23 <Berengal> > (2^32) :: Word32
15:49:24 <lambdabot>   0
15:49:28 <skorpan> is there any web template system for haskell, like jinja?
15:49:41 <ksf> happstack has templating
15:49:47 <solidsnack> > 1 :: 1
15:49:48 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
15:49:48 <lambdabot>    arising from the literal...
15:49:53 <ksf> and there's gazillion of xslt libs you could use
15:50:00 <burp> > (2^32 - 1) :: Word32
15:50:01 <lambdabot>   4294967295
15:50:02 <skorpan> happs-tutorial failed to install on both vista and arch linux, for different reasons, so i'm not touching that at the moment
15:50:06 <solidsnack> oh, how interesting...
15:50:09 <ksf> ...though using xslt is insanity if you've got haskell.
15:50:22 <ksf> ...use happstack, not happs.
15:50:44 <Berengal> ksf, happs-tutorial is still the name of the happstack tutorial
15:51:21 <Berengal> skorpan, I've written webpages using Text.XHtml and making templates simple functions
15:51:23 <ksf> well but you could use the template engine.
15:51:25 <luite> skorpan: it's not difficult to fix it on windows, there is a a package that depends on posix, you can make it depend on posix-compat with some minor changes
15:51:38 * ksf uses IxSet without bothering about the rest
15:52:54 <skorpan> i'm trying to write a small application which is basically "match against the request URI, call the correct (Request a -> Response String) function and return its results"
15:53:15 * ksf loves uu-parsinglib, even though I don't really know it, yet.
15:53:24 <burp> try hstringtemplate
15:53:31 <ksf> It's obviously based on applicatives, monads being an afterthought.
15:53:49 <burp> it's quite good
15:53:51 <skorpan> ksf: uu-parsinglib or hstringtemplate?
15:53:59 <ksf> uu-parsinglib
15:54:30 <burp> well thats not for templating
15:55:00 <ksf> ...my intuition tells me that I want something more full-featured than polyparse, and I can't use parsec as it's strict in its input.
15:56:16 <skorpan> hstringtemplate looks really nice
15:57:28 <burp> and you're compatible with java stringtemplate, in case you want to go enterprise ;-)
15:57:28 <Rotaerk> hmm trying to decide between bazaar and fossil
15:57:33 <Rotaerk> for version control
15:57:50 <ksf> there's git and there's darcs.
15:58:00 <solidsnack> > Unit :: 1
15:58:01 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
15:58:01 <lambdabot>    arising from a use of ...
15:58:15 <solidsnack> @type Unit :: 1
15:58:16 <lambdabot> Unit
15:58:20 <Rotaerk> hmm could also use darcs I guess, hadn't heard of that
15:58:36 <CalJohn> if you're doing haskell, almost certainly use darcs
15:58:44 <Rotaerk> why?
15:58:46 <ksf> git has the advantange of having a gui
15:58:48 <CalJohn> i think almost all haskell code uses darcs
15:58:59 <ksf> ...which is very useful for visualizing history etc.
15:59:02 <burp> I ♥ git
15:59:04 <ksf> ...and the rest uses git.
15:59:13 <Zao> <- svn
15:59:15 <skorpan> i like the cherry-picking in darcs, but the slowness not so much
15:59:29 <burp> wow svn, you could even use cvs already :P
15:59:34 <solidsnack> I use Git for all my Haskell.
15:59:44 <burp> jk
15:59:52 <solidsnack> Basically so I can use GitHub.
16:00:01 <Zao> burp: I don't branch, I don't backport, I'm in small groups of developers, I have a reliable server on a fat pipe.
16:00:02 <Rotaerk> darcs is the only one written in haskell, that I know of
16:00:04 <skorpan> burp: still works for emacs ;P  although they're switching to bazaar iirc
16:00:15 <Rotaerk> though that offers no advantage for the user
16:00:18 <Zao> burp: SVN does everything I want, and every time I try git, I mess up good.
16:00:20 <ksf> well but git is written by linus.
16:00:34 <ksf> and I trust linus' C more than the haskell of many others.
16:00:35 <Zao> ksf: That's a con.
16:00:53 <CalJohn> linus is a personality cult
16:00:55 <burp> git is so wonderful flexible
16:01:02 <Rotaerk> bazaar is based on git
16:01:03 <burp> and fast
16:01:08 <fynn> Yo.
16:01:08 <Rotaerk> though it lacks a gui
16:01:08 <fynn> What's the best way to install latest GHC for production use on a CentOS 5 server?
16:01:21 <Zao> I still haven't found proper documentation on how to support a SVN-like work process with git.
16:01:32 <solidsnack> fynn: Download the binary from haskell.org
16:01:34 <Zao> Any attempts at remote "server" repositories has failed horribly.
16:01:56 <fynn> solidsnack: mhm, shouldn't I compile it myself, seeing that it's for production and that?
16:01:59 <burp> its no problem
16:02:04 <solidsnack> fynn: No.
16:02:14 <solidsnack> fynn: Why would you compile it yourself?
16:02:21 <Zao> fynn: I'd rather rely on tried and tested binaries than the current moon phase.
16:02:27 <solidsnack> Indeed.
16:02:29 <Rotaerk> I'm thinking about using fossil; bazaar doesn't have a smart server yet, so it just uses FTP to handle access to the repo
16:02:30 <fynn> solidsnack: extra optimizations at the compilation level?
16:02:37 <burp> espeially git's interactive rebase
16:02:40 <burp> is awesome
16:02:42 <SamB_XP_> fynn: extra for WHAT?
16:02:52 <Zao> Many thousands of people are running the binary packages, and I'm sure that they are built with sane optimization settings.
16:02:58 <solidsnack> fynn: I don't think you'll be able to tune it much without extreme wizardry.
16:03:06 <solidsnack> It'll take wizardry to even compile it.
16:03:23 <burp> Zao: http://reinh.com/blog/2009/03/02/a-git-workflow-for-agile-teams.html give it a try
16:03:28 <solidsnack> fynn: For production Gentoo systems, you should compile it yourself.
16:03:38 <burp> once you're really into git
16:03:43 <solidsnack> For CentOS, not so much :)
16:03:46 <burp> you will regret using svn so long ;)
16:03:55 <Rotaerk> ur a git if u use git
16:03:56 <fynn> solidsnack: hm, what's the difference with Gentoo in that regard?
16:03:57 <Rotaerk> </original>
16:04:09 <CalJohn> fynn: you are being quite silly, the binaries already have all the nice optimisations already.  the gentoo mantra of "more speed" is badly mistaken
16:04:20 <ksf> that's no mantra.
16:04:30 <ksf> the mantra of gento is "be a meta-distribution"
16:04:54 <solidsnack> fynn: I was teasing. I've used Gentoo for a long time; if you're used to it, go ahead and use the eBuild and compile all the stuff (their GHC eBuild downloads GHC and then rebuilds it).
16:04:59 <CalJohn> yes, well that may be the case now, but it wasn't originally
16:05:00 <Zao> burp: That doc reeks of "miss one step and you'll probably hose your working copy and possibly the remote repos hard, have fun picking up the pieces"
16:05:23 <fynn> CalJohn: not sure how wanting to serve requests to users faster is silly
16:05:29 <burp> you basically can't break anything
16:05:34 <fynn> solidsnack: this is the package I should install, right?  ghc-6.10.4-x86_64-unknown-linux-n.tar.bz2
16:05:40 <Zao> burp: My previous attempts begs to differ :P
16:05:45 <ksf> Zao, you're not being productive, your being paranoid-cynical.
16:05:45 <solidsnack> fynn: Yes.
16:05:45 <jmillikin> Is there any flag to make Cabal run preprocessors before building the sdist tarball?
16:05:48 <fynn> (yes, this is a 64bit server)
16:06:03 <fynn> solidsnack: cool, thanks. btw, I thought you died in the last game.
16:06:13 <fynn> guess maybe we're on a prequel now.
16:06:22 <Zao> ksf: When I want to be productive, I use tools I know instead of sinking days into things that might bite me hard in the posterior when the time really isn't right.
16:06:22 <burp> well, I don't need to convince people of git, I'm fine with it
16:06:27 <CalJohn> fynn: it's not your intention, it's your conclusion that i think is silly.  compiling yourself won't increase ghc's compilation speed at all, and won't increase speed of normal software much at all
16:06:37 <jmillikin> I'm running my sources through a preprocessor to build .hs files, which works fine with hookedPreProcessors in "cabal build" but not with "cabal sdist"
16:06:54 <ksf> Zao, yep. me too. that's why I'm going to stick with turbo pascal 4.0 for the rest of my life.
16:06:58 <luite> hmm, git gui thinks my .hs files are java...
16:07:03 <Zao> Excellent choice :)
16:07:20 <fynn> CalJohn: maybe it's my old fashioned C background, but compiled binaries are usually less aggressively optimized than what you can get on your own.
16:07:53 <fynn> ofc, I'm a relative newbie to GHC, which is why I asked rather than stated that compiling myself would yield better perforamnce.
16:07:55 <Zao> I trust the packagers to know more about what to do than some end user on Gentoo with mad CFLAGS.
16:08:38 <CalJohn> fynn: i think it might be.  that was the case once upon a time with C, back when low level optimisations where significant and when the intel instruction set was expanding and there where gains, but it hasn't been valid reasoning for about a decade
16:08:55 <ksf> ...one of the reasons why gentoo makes a hell a lot of sense is code robustness. the sources are compiled under a hell a lot of configurations and not just on max. 10 build servers (one for each distro), so you don't get incesteous bugs.
16:09:16 <Rotaerk> -+
16:09:20 <ksf> Zao, so all gentoo users have mad CFLAGS?
16:09:21 <Rotaerk> whoops
16:09:25 <Zao> ksf: Where most of the configurations run in assorted states of gimpedness :)
16:09:30 <CalJohn> ksf: and yet gentoo is well known to have the worst Q&A process of almost any distro
16:09:38 <Zao> ksf: No. I just say that people who like optimizing the crap out of things rarely have the competence to.
16:09:40 <burp> gentoo is redundant ;)
16:09:46 <ksf> is CFLAGS="-march=k8 -pipe -O2" madness?
16:09:48 <Zao> In any way, time to go home and be productive.
16:09:51 <burp> and energy waste :P
16:09:52 <Zao> ksf: Depends on what you build.
16:09:58 <CalJohn> fynn: even debian compile with -O2 and -march=whatnot, so thinking you'll notice much comparative difference by hand is a mistake
16:10:26 <ksf> I don't use gentoo for speed advantages.
16:10:36 <Zao> ksf: I'm talking about the kinds of people who -fomit-frame-pointer in the global flags.
16:10:36 <ksf> I use it because it's the bleeding best distro around.
16:10:47 <skorpan> ksf: what's so great about it?
16:10:53 <fynn> CalJohn: quite possibly you're right, thanks. I'm just used to compile most C/++ libraries I use in production, which is why I asked.
16:10:57 <ksf> you won't get help on both forums and the bug tracker when you rice.
16:11:15 <solidsnack> fynn: No, I almost took my life as I feared I harboured a contagion; however, it turns out this was not the case.
16:11:27 <ksf> skorpan, the way the system and packages are managed.
16:11:46 <ksf> ... I won't really tell you all those small bits that make gentoo the gem it is.
16:11:57 <Zao> You mean the bits it explodes into? :D
16:12:08 <ksf> small bits like a fully dependency-based init system.
16:12:13 <fynn> solidsnack: it would totally rock if this was a prequel in which SS discovered the joys of Haskell and how much better they are than espionage.
16:12:14 <skorpan> i tried gentoo but didn't find the superiority in it that you describe... i'm on arch linux now which sucks sometimes, but pacman is great.
16:12:16 <burp> ksandstr: has debian too
16:12:19 <ksf> ...which means that stuff _won't_ blow up.
16:12:37 <CalJohn> IMO, the most valid reason to use gentoo are "i possibly want to do unusual things that other people make difficult"
16:12:49 <ksf> that, too.
16:12:56 <burp> ksf I mean
16:13:12 <ksf> burp, not when I switched to gentoo.
16:13:18 <solidsnack> CalJohn: Another reason is, everything is nicely set up and the devs exhibit good taste in any manner where they have discretion.
16:13:21 <burp> it's quite new
16:13:24 <ksf> maybe then stole it...
16:13:27 <burp> LOL
16:13:40 <CalJohn> solidsnack: yes, if their taste is to your taste, then that is also true
16:14:05 <ksf> software availability is a big plus.
16:14:18 <cpettitt> Wow... a 70 page, gentle introduction to Category Theory. I'm excited! :)
16:14:36 <ksf> ...as in you can easily get the latest version of virtually anything, if you want to, e.g. because upstream fixed some bug.
16:14:52 <solidsnack> ksf:  It's true.
16:14:57 <burp> archlinux
16:14:59 <CalJohn> gobo linux is nice in that respect as well, ksf
16:15:00 <solidsnack> cpettitt: Who is the author?
16:15:01 <ksf> doing such a thing in a binary distro usually amounts to wading through walls of red tape
16:15:29 <cpettitt> Maarten M. Fokkinga
16:15:49 <skorpan> fuckin 'a
16:15:54 <cpettitt> lol
16:16:19 <cpettitt> that may be how I feel after 70 pages of category theory ;)
16:16:31 <ksf> and unstable packages won't run on your stable system because of some lib incompabilities and stuff.
16:16:42 <ksf> _that's_ what source building is useful for.
16:16:57 <burp> I can accept that
16:17:13 <burp> making this in a binary distro results in hell
16:17:27 <burp> when you're not backporting stuff
16:17:35 <burp> which isn't very comfortable
16:17:37 <skorpan> i wish there was something in arch linux which allowed me to upgrade to stuff that are known to be working for one week or more.  way too often does something break which i can't be bothered fixing.
16:17:41 <ksf> ...and gentoo knows of binary packages, btw.
16:17:59 <dcoutts> jmillikin: there's a bug which means "cabal sdist" does not run your custom pre-processors, but "runghc Setup sdist" does.
16:18:03 <ksf> if you've got say 20 pcs to manage, you can build once (with distcc parallely on all of them), then install the binaries.
16:18:21 <burp> skorpan: that's the price of using arch
16:18:28 <skorpan> burp: indeed
16:18:56 <hackagebot> bindings-sqlite3 1.0 - Low level bindings to sqlite3. (MauricioAntunes)
16:19:12 <jmillikin> dcoutts: Thanks, that's working well.
16:21:25 <ksf> @where+ parsing http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
16:21:26 <lambdabot> I will never forget.
16:21:33 <ksf> that's a hell of a good tutorial paper
16:37:55 <skorpan> how do web apps written using happstack scale?
16:38:47 <skorpan> never mind, google helped
16:38:59 <c_wraith> I've got to imagine they scale well, just due to architectural help from the base language.
16:39:12 <c_wraith> But I have no experience to back that up
16:39:53 <aavogt> well, it only supports multi-master, not sharding afaik
16:40:21 <aavogt> so you can't use multiple machines to handle a bigger data set
16:42:23 <ksf> sharding is the bane of mmorpg's.
16:42:27 <burp> yes, but you could use a rdbms anyway
16:42:36 <ksf> ouch.
16:42:41 <idnar> haha
16:42:54 <ksf> and their windoze-based sql systems are the bane of eve online.
16:43:01 <burp> windoze, sql?
16:43:10 <burp> not talking about that
16:43:15 <ksf> dunno exactly what they're using, but it's m$.
16:43:21 <Zao> .k ksf M$
16:43:25 <Zao> Bah, wrong channel.
16:43:28 <burp> I'm using happstack with takusen/postgresql
16:43:30 <Zao> But still, seriously.
16:43:55 <ksf> ...well, they have a hell a lot of problems with it.
16:44:09 <ksf> still, they're somewhat clustering gurus
16:44:31 <ksf> seems legacy is the only possible explanation
16:44:40 <burp> and happstack state, ixsets can't replace a full rdbms
16:44:43 <ve> Would it be worthwhile to buy the CLR Introduction to Algorithms 3rd edition for a university course and for later reference, or one of the alternatives like the Algorithm Design Manual, Algorithm Design, Algorithms: A Functional Programming Approach, or more than a single book on that?
16:45:56 <c_wraith> 3rd edition?  Hmm.  What color is this one?
16:46:01 <ksf> dunno whether they managed to run a solar system on multiple cores, yet, but at least they managed to get load balancing right.
16:46:13 <c_wraith> Anyway, I used CLR 1st edition way back when, and I really liked it.
16:46:44 <ksf> ...while yita always needs a core on its own, most of the universe doesn't. but it _does_ if a fleet happens to jump through it.
16:48:09 <ddarius> "A Core of My Own: The Coming of Age Story of a Thread"
16:48:11 <ve> c_wraith: blue-white-ish apparently
16:48:32 <c_wraith> First edition was white, second was a light green.
16:48:42 <c_wraith> So this one must be light blue
16:49:07 <ddarius> When does it start going into the ultraviolet?
16:50:36 <c_wraith> I think the black body catastrophe indicates it won't.
16:51:15 <c_wraith> Anyway.  CLR is rather abstract, but that's good for isolating instruction about algorithms from instruction about programming languages.
16:51:20 <c_wraith> I think it's a good book.
16:51:34 <SamB_XP_> c_wraith: there *is* no catastrophe
16:52:08 <SamB_XP_> that's, like, the one thing I remember from Modern Physics ;-P
16:52:26 <c_wraith> I know, I'm stuck in classical physics. :)
16:52:33 <burp> thats true ;)
16:52:40 <burp> plack was 1900 :P
16:52:47 <burp> planck
16:56:49 <Rotaerk> the fact that git has tortoisegit makes it a promising option
16:56:57 <Rotaerk> tortoisebzr is crap last i checked
16:57:06 <Rotaerk> and I don't think there's a GUI for fossil
17:16:02 <ksf> git comes with gitk
17:16:25 <ksf> ...and there's gitit and I guess you can also grab the source of github or something similar
17:16:51 <ksf> ...at least I've seen the interface of repo.or.cz at least in one other place.
17:17:30 <ksf> what's utterly lacking is windoze support and I guess also stuff like mature eclipse integration
17:18:10 * nominolo used git on Windows
17:24:04 <malouin> > reverse "الجبر"
17:24:04 <lambdabot>   "\1585\1576\1580\1604\1575"
17:24:17 <chessguy> 'evening ya'all
17:24:22 <EvilRanter> > text $ reverse "الجبر"
17:24:23 <lambdabot>   ربجلا
17:24:35 <Poulter> Is there any notion of nested guard in Haskell?
17:24:42 <Poulter> Evenin'
17:25:27 <malouin> EvilRanter: 谢谢
17:25:27 <Alpounet> @type guard
17:25:28 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:25:37 <aavogt> Poulter: have you seen what you can do with -XPatternGuards?
17:25:42 <EvilRanter> malouin, that doesn't show up in my font
17:25:54 <Poulter> I haven't
17:25:56 <malouin> it's thanks in unicode chinese.
17:26:07 <malouin> (xiexie)
17:26:12 <Poulter> I'll check it out
17:26:14 <aavogt> well maybe that is what you are asking for
17:27:27 <aavogt> > case () of _ | 1 == 2 = "a" | Just x <- Nothing = "b" | otherwise = "c"
17:27:28 <lambdabot>   <no location info>: parse error on input `='
17:27:39 <aavogt> > case () of _ | 1 == 2 = "a" | otherwise = "c"
17:27:40 <lambdabot>   <no location info>: parse error on input `='
17:27:57 <aavogt> > case () of _ | 1 == 2 = "a"; | otherwise = "c"
17:27:58 <lambdabot>   <no location info>: parse error on input `='
17:28:15 <aavogt> > case () of _ | 1 == 2 -> "a" | Just x <- Nothing -> "b" | otherwise -> "c"
17:28:16 <lambdabot>   "c"
17:28:23 <aavogt> \o/
17:28:37 <Poulter> :P
17:28:49 <Poulter> Not sure I get what you've done but well done :P
17:29:29 <malouin> wait a minute... where does that text function come from?
17:29:43 <malouin> lambdabot is entirely too intelligent.
17:29:44 <aavogt> well, you can put pattern guards in the options of a case expression
17:29:46 <c_wraith> the text package
17:29:51 <aavogt> @index text
17:29:51 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
17:29:53 <monochrom> Text.PrettyPrint.txt
17:30:39 <aavogt> Poulter: it is a bit more clear when you line up the `|'
17:30:39 <malouin> ok, thanks.
17:31:22 <Berengal> Doesn't pattern guards also allow multiple booleans/patterns in each guard?
17:31:29 <aavogt> yes
17:31:34 <aavogt> with commas
17:31:54 <Berengal> Thought so
17:31:54 <Poulter> I've seen that Just keyword around, no quite sure what it means
17:32:02 <Berengal> I use guard a bit too seldom...
17:32:10 <aavogt> Poulter: Just is a constructor
17:32:12 <Berengal> Poulter, not a keyword. It's a constructor
17:32:13 <Poulter> I think I'm over my head here ;)
17:32:20 <aavogt> > Just 1
17:32:21 <lambdabot>   Just 1
17:32:43 <Poulter> Constructor for?
17:32:47 <Berengal> > (+) <$> Just 1 <*> Just 4
17:32:48 <lambdabot>   Just 5
17:32:50 <Berengal> > (+) <$> Just 1 <*> Nothing
17:32:51 <lambdabot>   Nothing
17:32:54 <aavogt> for Maybe
17:35:24 <aavogt> but even standard haskell 98 case expressions + pattern guards are usually expressive enough
17:35:31 <aavogt> (so learn those first)
17:35:41 <Poulter> :) thanks
17:41:27 <Warrigal> How standard is it to make all LHSs the same width?
17:41:37 <dolio> I like it.
17:42:06 <Warrigal> Do you count the = or :: as part of the LHS or the RHS?
17:42:46 <Cale> I don't line up the :: with anything in the rest of the definition
17:42:52 <dolio> I like to line up the start of matches on the same variable with each other, and line up the =.
17:42:53 <dolio> I don't worry about the ::
17:42:55 <byorgey> Warrigal: I usually line up all the =
17:42:57 <ksf> I sometimes line up all bindings and =s, but neven ::
17:43:03 * Warrigal nods.
17:43:53 <ksf> especially if patterns on the left side of other patterns vary greatly in length
17:44:11 <Warrigal> @docs
17:44:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:44:37 <Warrigal> Hmm, I'm thinking that naming a module "Network" may be unwise.
17:44:49 * Warrigal prefixes everything with "Klps".
17:44:51 <ksf> e.g. I don't bother to do it unless it's getting hard to parse. foo a [] = ... ; foo a (x:xs) = ... is perfectly parsable without aligning.
17:45:45 <Warrigal> Is it, though? If I have a file called network.hs, and all of my files say "import Network", what will happen?
17:46:04 <ksf> that's a name clash with the library one.
17:46:07 <Warrigal> The behavior is I want is one file importing the standard Network module, and all the others importing my file.
17:46:27 <aavogt> you need to call it Network.hs unless you have a case-insensitive filesystem
17:46:29 <ksf> you _can_ do that by using different -package flags for different files
17:46:42 <ksf> ...but I don't think it's a wise thing to do that.
17:47:18 <aavogt> it might work correctly if your Network.hs is the one that imports Network
17:47:26 <ksf> prefixing all the modules of an app is common usage.
17:47:27 <Warrigal> Well, this is probably going to be an entirely standalone program, so I can probably get away with naming these files something like "Main", "Client", "Server", and "Protocol" rather than "Main", "KlpsClient", "KlpsServer", and "KlpsProtocol", aye?
17:47:47 * Warrigal decides to play it safe and use Klps.
17:47:59 * ksf would go for Klps.Network
17:48:17 <Warrigal> How would that work, exactly?
17:48:30 <ksf> you make a directory Klps and put Network.hs in there.
17:49:10 <ksf> ...and then do multiple Main modules, named klps.hs, klps-info.hs etc.
17:49:47 <ksf> basically, treat all of your source as a library and have small main modules that don't do anything themselves.
17:50:12 <ksf> kind of like main = defaultMain $ defaultConfig { foo = "bar" }
17:50:50 <Warrigal> And what would my main Main module do?
17:51:38 <ksf> at the utmost, parsing arguments, calling a repl and such.
17:51:39 <tommd> Does HP include profiling libraries?
17:52:13 <Warrigal> I guess you'll have to explain further.
17:53:09 <Warrigal> Would I have files Klps/Client.hs, Klps/Server.hs, Klps/Protocol.hs, and ./Main.hs?
17:53:20 <ksf> yep.
17:53:32 <ksf> ...though I usually don't call the main module main.
17:53:44 <ksf> but name it after the executable.
17:54:06 <Warrigal> Would you also recommend having a Klps/Main.hs and having ./Main.hs that does nothing but call it?
17:54:40 <ksf> so you might have Klps/Types.hs Klps/Server.hs Klps/Client.hs and ./klpsd.hs and ./klpsc
17:54:42 <gwern> I'd call it Klaatu.Barada.Nikto
17:54:48 <ksf> nope
17:54:53 <gwern> factor it all out into a nice hierarchy
17:55:09 <Warrigal> But my application isn't going to be called Klaatu Barada Nikto; it's going to be called Kallipolis. :-P
17:55:35 <gwern> my genius goes unappreciated yet again!
17:55:38 <ksf> like, a city of scribes with decipherable handwriting?
17:55:50 <Warrigal> Is that what "kallipolis" means?
17:56:05 <gwern> kallisto
17:56:11 <ksf> well kalli -> kalligraphy and polis -> city was my association
17:56:24 <ksf> er calligraphy I guess.
17:56:51 <ksf> so, unless you're german or have another excuse to use k, you've got to make it a kde app.
17:57:38 <Warrigal> Wikipedia says "Kallipolis" more than "Callipolis", I think.
17:58:17 <Warrigal> I really don't know why Plato used the word Kallipolis.
17:58:26 <Warrigal> But, anyway...
18:00:01 <Warrigal> It sounds like I'm going to have Kallipolis/Client.hs containing client functionality, Kallipolis/Server.hs containing server/peer functionality, Kallipolis/Protocol.hs containing network stuff, and ./kallipolis.hs containing user interface stuff.
18:00:08 <ksf> but back to the main.hs issue: you might want to share parts of your options handling etc. for both client and server, so you can have a Klps/Options.hs and have klpsd look something like main = parseArgs descr >>= serverMain {-defined in Klps/Server.hs-} where descr = [(...,...),...]
18:00:39 <Warrigal> I might not have the client and server be separate executables. >.>
18:00:52 <ksf> well then don't. or do both.
18:01:16 <ksf> if the source is organized in the right way, the difference is a few keystrokes.
18:02:08 <Warrigal> I think it would be easier to have them be one executable, as I might well have a hybrid mode.
18:02:33 <Warrigal> And it's going to be a relatively small app anyway. So yeah.
18:03:08 <ksf> well main = args <- parseArgs descr, if isServer args then serverMain args else clientMain args
18:03:22 <ksf> that'd be the third executable.
18:04:23 <Warrigal> Do you think there would be any downsides to having only one executable?
18:04:32 <ksf> not really.
18:04:55 * Warrigal nods.
18:05:16 <ksf> well if your server would e.g. bind to a system port, having it in /usr/bin isn't as nice as being able to put a daemon-only version in /usr/sbin
18:05:36 <ksf> also, your users might have a different taste that you.
18:06:14 <ksf> some might want to run the client on their toaster, which doesn't have enough room for the server. so they might want to have a client-only exec.
18:06:26 <ksf> some use their toaster as a server, and don't care for the client.
18:07:17 <ksf> otoh, if they want to run both server and client on their toaster, a single exec will take up less space
18:08:04 <aavogt> but you can give cabal flags for producing all of the above!
18:08:40 <ksf> in general, in app design one should just be as flexible as humanely feasible. saves work big-time and is a good exercise in encapsulation + app design.
18:10:01 <ksf> xmonad, for example, is usually used as a library, with a user-written custom main doing all kind of really, really fancy configuration, but there's a dumbed-down main executable that parses a non-turing complete config file, too.
18:10:18 <ksf> (for those that don't want to pull a 200m-dependency called ghc)
18:11:23 <Warrigal> Well, as I said, I plan to be small. Around a megabyte, maybe.
18:11:41 <ksf> think big.
18:12:24 <ksf> why use string if you can get rope for free?
18:12:44 <sjanssen> dcoutts++ fighting the good fight on reddit
18:12:56 <gwern> ?
18:13:06 <sjanssen> http://www.reddit.com/r/programming/comments/9spu1/optimizing_listmap_in_ocaml/c0e981g
18:13:37 <sjanssen> I was just glad to see somebody point that out.  I want to see the benefits of laziness expounded more frequently
18:14:31 <Warrigal> Well, here's an honest question, not a rhetorical one: when is a few hundred kilobytes a problem?
18:14:55 <gwern> Warrigal: when it's nuclear bomb plans?
18:16:03 * gwern ponders this pandoc stuff. you know, it would be a lot easier if pandoc were less typeful - there's something to be said about everything being just String and not Block or [Inline] or whatever
18:16:32 <aavogt> well, ghc's hello world is 596k here (x86_64)
18:16:40 <sjanssen> gwern: you prefer tcl?
18:16:55 <gwern> sjanssen: it would make gitit plugins easier to write, certainly...
18:17:57 <Warrigal> Hmm, maybe I should use GHC's small mode. :-P
18:22:14 <Warrigal> Hmm, I suppose I should put stuff like type declarations in yet another module.
18:22:24 <Warrigal> Or I could just stuff them in with Protocol.hs.
18:22:42 <Warrigal> Actually, I'm going to be importing these.
18:24:04 <gwern> argh... so filestore will give me a String which is an article, and I can use readMarkdown to String -> Pandoc, but I need to return Inline, which is *2* levels down the type hierarchy
18:25:13 <sjanssen> gwern: syb?
18:25:15 <gwern> Pandoc is defined as Pandoc Meta [Block], so I *could* extract the [Block], but the only Inline constructor accepting [Block] is... 'footnote or endnote'
18:25:20 <gwern> wtf
18:25:42 <gwern> I don't want to do transclusion as footnote! I want the link replaced by the named article!
18:25:47 <gwern> arrgh
18:25:51 * Warrigal raises an eyebrow.
18:27:28 <gwern> oh, and it doesn't help that the getFileStore function I need to even get access to the wiki repo, john conveniently forgot to export
18:27:43 <gwern> so I couldn't even compile my plugin even if I did figure it out
18:28:23 <gwern> now, see, this is the sort of thing I mean by haskell not being great in the initial stages of hacking, but great once things are polished and finished
18:28:25 <Warrigal> Hmm. A Metamath proof verifier of 500 lines of code has been written. Hmm, the Haskell Metamath proof verifier, is around 25 kilobytes. I suppose that could easily be about the same size.
18:29:06 <Gracenotes> Warrigal: the compiled binary is 25 KB?
18:30:12 <Warrigal> No, the source is 25 KB.
18:30:33 <Warrigal> I'd hate to count the number of lines of code in a compiled binary.
18:30:45 <byorgey> > 25 * 1024 `div` 80
18:30:46 <lambdabot>   320
18:31:03 <byorgey> yeah, 25KB == 500 LOC sounds about right.
18:32:04 <Warrigal> Anyway, it seems that the simplest possible proof verifier would be an implementation of the Hindley-Milner type inference algorithm.
18:32:38 <Berengal> HM is restricted in the proofs it can verify though
18:32:53 <Berengal> Compared to e.g. Haskell or Agda
18:33:04 <Rotaerk> hmm... what's the meaning of "| m -> p" in: class Monad m => MonadPrompt p m | m -> p where
18:33:22 <sjanssen> Rotaerk: that's called a "functional dependency", or "fundep"
18:33:26 <Berengal> Rotaerk, "m decides p". It's a functional dependency
18:33:30 <Rotaerk> ah thanks
18:33:52 <Berengal> It means that if you know m, you know p.
18:36:49 <Warrigal> Couldn't a finite state automaton convert arbitrary first-order logic statements into HM types?
18:37:16 <Warrigal> Hmm, maybe it couldn't.
18:37:20 <Warrigal> (No pun intended. :-P)
18:38:16 <dolio> Isn't "(forall a. P a) -> P y" first-order?
18:38:56 <Warrigal> It's not HM, though. HM would call that "P a -> P a".
18:39:11 <dolio> Well, that isn't the same type.
18:39:24 <SamB_XP_> pretty sure that's second-order
18:39:29 <dolio> HM types are a subset of System F2 types.
18:39:49 <Warrigal> Well, every proof of "(forall a. P a) -> P y" is also a proof of some statement in propositional logic, no?
18:39:58 <dolio> Or maybe Fw, depending on the other parts of your system.
18:40:01 <_roconnor> > 1.062711 * 81
18:40:02 <lambdabot>   86.079591
18:40:16 <ksf> Rotaerk, if you're digging into fundeps now, you should have a look at type families, too, otherwise you might needlessly end up in -XUndecidableInstances hell.
18:40:16 <Berengal> I love types
18:40:32 <Warrigal> Anyway, now I remember what the claim I really wanted to make was, and this isn't it.
18:40:34 <Rotaerk> hmm, k thanks
18:40:52 * ksf thinks the paper was called "fun with type functions".
18:40:55 <ksf> spj and oleg
18:41:02 <Berengal> Type families have the bonus of not cluttering up your class parameters with parameters that aren't
18:41:16 <ksf> it's a good read, and quite mind-blowing if you've never seen type magic before.
18:41:31 <dolio> Anyhow, just amend my example to '(forall a. P a) -> P y /\ P z' :)
18:41:35 <gwern> 'transformBlock (Para ((Link ((Str ref):_) ('!':'s':'u':'b':'s':'t':[], _)):_)) = do fs ←  getFileStore'
18:41:35 <Berengal> Today I learned Scala has type families
18:41:38 <gwern> kill me now
18:42:11 * ksf started to read programming scala but found it to be too slow-paced.
18:42:13 <dolio> "!subst"
18:42:15 <Warrigal> The simplest possible proof verifier might be one that executes specified operations on SKI expressions.
18:42:21 <Axman6> gwern: "!stubst"?
18:42:33 <gwern> Azstal: no, !subst
18:42:40 <gwern> er, Axman6
18:42:45 <Axman6> er, yeah
18:42:49 <ksf> Warrigal, well, you can also express your proofs in bf.
18:42:55 <Axman6> anyway... why split it up?
18:42:55 <aavogt> > case "hello" of "hello" -> 1
18:42:56 <lambdabot>   1
18:42:59 <cpettitt> is there any trick to find the source for Functor IO using Hoogle?
18:43:17 <Warrigal> Since every statement of provability is equivalent to a statement of equivalence of SKI expressions.
18:43:49 * Axman6 saw an interesting talk recently talking about how SKI could be improved upon
18:43:50 <gwern> Axman6: what do you mean?
18:44:19 <Axman6> gwern: well, '!':'s':'u':'b':'s':'t':[] == "!subst"
18:44:23 <gwern> putting the case into the patternmatch like that means my second transformBlock definition is just x = return x
18:44:36 <gwern> Axman6: so far as I know, that doesn't compile
18:44:39 <sjanssen> gwern: why not use string syntax in your pattern?
18:44:58 <dolio> You should try it. Then you'll know that it does. :)
18:45:13 <Berengal> > case "abcd" of "abc" -> True; _ -> false;
18:45:14 <lambdabot>   Not in scope: `false'
18:45:14 <sjanssen> gwern: you're also using too many parens
18:45:16 <gwern> huh. I could've sworn it didn't work
18:45:18 <Vanadium_> cpettitt: Search for "io", get the "data IO a" definition in the prelude, click on "Source"
18:45:19 <Berengal> > case "abcd" of "abc" -> True; _ -> False;
18:45:20 <lambdabot>   False
18:45:24 <gwern> sjanssen: I'm pretty sure I'm not
18:45:28 <Axman6> you're allowed to match on whole strings :)
18:45:32 <Vanadium_> cpettitt: Receive the GHC.IOBase.html source where it says    fmap f x = x >>= (return . f)
18:45:34 <bogner> is it possible/reasonable to write a function in IO that will make an IORef the first time it's called, but re-use that same IORef in future calls? Something like a function-local static variable in C
18:45:35 <cpettitt> Cool, that worked. Thanks Vanadium_
18:45:46 <sjanssen> gwern: "((Str ref):_)" is "Str ref : _"
18:46:14 <Axman6> > '!':'s':'u':'b':'s':'t':[] == "!subst"
18:46:15 <lambdabot>   True
18:46:21 <Axman6> > '!':'s':'u':'b':'s':'t':[]
18:46:21 <lambdabot>   "!subst"
18:46:25 <sjanssen> gwern: erm, put parens around the latter
18:46:32 <Vanadium_> bogner: Store the IORef in a global IORef?
18:46:51 <Axman6> > case '!':'s':'u':'b':'s':'t':[] of "!subst" -> "Hoorah"
18:46:52 <lambdabot>   "Hoorah"
18:46:54 <gwern> that's all great, but it's still 'transformBlock (Para ((Link (Str ref:_) ("!subst", _)):_)) = do fs ←  getFileStore', which isn't great
18:46:57 <aavogt> bogner: make the ioref at top level with unsafePerformIO, but have it start off storing Nothing
18:47:16 <Warrigal> QtPlaty[1ireMe]: still looking for a job, eh?
18:47:32 <bogner> Vanadium_, aavogt: yes, I suppose that would do it. thanks
18:47:41 <aavogt> @leet FireMe
18:47:41 <lambdabot>   Parse error: SemiColon
18:47:56 <aavogt> @leet "FireMe"
18:47:56 <lambdabot>   Parse error: SemiColon
18:48:00 <Axman6> :o
18:48:05 <aavogt> huh?
18:48:10 <bogner> @leet ;
18:48:11 <lambdabot>  Defined.
18:48:20 <sjanssen> gwern: the tuple component in Link is weird, but that's probably a design issue with pandoc
18:48:24 <aavogt> I see
18:48:29 <bogner> interesting...
18:48:38 <aavogt> @elite
18:48:38 <lambdabot> Say again?
18:48:41 <aavogt> @elite
18:48:42 <lambdabot> Say again?
18:48:49 <Berengal> @elite asdf
18:48:49 <lambdabot> 4sDF
18:48:50 <Axman6> @elite yo
18:48:50 <lambdabot> YO
18:48:53 <_Ray_> Small question. We're learning Haskell in class, and we're doing some easy functions. This means, however, we can't most of Haskell's built-in functions, since they'd simplify things too much. The task is to make an f :: [Integer] -> Bool that returns True if and only if every element in the list is distinct. I did a simple recursive one using `notElem`...is there an more trivial example, without using a builtin function?
18:48:59 <Warrigal> @elite Fir
18:48:59 <lambdabot> phIr
18:49:04 <Warrigal> @leet eme
18:49:04 <lambdabot>   Parse error: SemiColon
18:49:22 <Warrigal> @elite FireMe
18:49:22 <lambdabot> firEMe
18:49:27 <gwern> sjanssen: 'Link [Inline] Target', so I think 'Link (Str ref:_)' parses as 'Link [(Str ref) _]', if you follow
18:49:28 <ksf> @leet fun = fix error
18:49:29 <lambdabot>  Defined.
18:49:45 <Berengal> _Ray_, all ((==1).length) . group . sort
18:49:48 <Warrigal> I'm using @leet from now on.
18:49:57 <sjanssen> gwern: (Para (Link (Str ref:_) ("!subst", _) : _ ))
18:50:01 <gwern> sjanssen: I omit the Target, though
18:50:04 <Berengal> Those built-in functions should be easy enough to implement yourself
18:50:05 <Axman6> Berengal: heh
18:50:07 <_Ray_> Berengal, if I can't use `elem`, I definitely can't use group and sort =p
18:50:18 <_roconnor> > 248 * 327
18:50:19 <lambdabot>   81096
18:50:30 <gwern> since the Str construactor *should* bind more tightly than ':', right?
18:51:12 <Berengal> _Ray_, sort is way easy to do in haskell, even if the simplest ones may be lacking in time and space complexity
18:51:19 <sjanssen> gwern: I'm fairly certain what I just pasted is the same, but you should double check
18:51:30 <Berengal> group may be a bit harder, but still shouldn't be hard to do with just simple recursion and pattern-matching
18:51:37 <gwern> sjanssen: I'm looking
18:51:52 <_Ray_> Berengal, I understand that, and being a programmer already, I'd know how to implement a sort (and group if I learn Haskell's data structures) - this is, however, an exercise about pure recursion, without using many helper functions.
18:52:25 <sjanssen> gwern: I don't really know what you mean by "(Str ref) _", but "Link (Str ref:_)" will match "Link [Str ref, foo, bar, baz, etc]"
18:52:31 <gwern> sjanssen: any reason it's subst", _) : _, and not '):_' ?
18:52:36 <Axman6> _Ray_: i assume you're allowed to define your own helper functions?
18:52:40 <ksf> you should tell your instructor to implement them, to exercise mutual recursion.
18:52:44 <_Ray_> Consider the difficulty of the previous exercise - construct a function that returns True if and only if every element in the list is the same.
18:53:01 <_Ray_> Axman6, yes, but I doubt I need to at this stage...look at the difficulty of the exercise before :s
18:53:08 <gwern> _Ray_: oh, that's easy enough; but that's quite different
18:53:12 <sjanssen> gwern: I find a space there more appealing
18:53:14 <_Ray_> Yes, indeed.
18:53:19 <gwern> _Ray_: are you allowed to assume the list is sorted or something?
18:53:24 <_Ray_> Nope.
18:53:28 <Berengal> _Ray_, it can also be done as a simple fold, which isn't that hard to expand to explicit recursion
18:53:30 <Axman6> well, all i was going to say is write your own `all` function
18:53:36 <Warrigal> In "module Foo(bar(baz), quux)", what is baz?
18:53:40 <Vanadium_> Sort it then, there is quicksort in haskell all over the internet~
18:53:47 <_Ray_> Serengal, we'll never be allowed to use first order functions. Yes, it's a travesti.
18:53:48 <ksf> Warrigal, a constructor.
18:54:02 <ksf> It's going to have a a capital first letter, though.
18:54:10 * Warrigal nods.
18:54:12 <ksf> oh. or a class method.
18:54:19 <_Ray_> So the concensus is the simplest way there is is with `notElem`?
18:54:25 <ksf> you can use Foo(..) to export all of them
18:54:39 <gwern> hm. how about 'foo y = all $ map (\x -> not $ any x y) y'? inefficientalicious
18:54:40 <Warrigal> Are classes in the same namespace as types?
18:54:42 <Berengal> _Ray_, if you can use notElem, then it's trivial
18:54:44 <aavogt> @leet (..) = (.)
18:54:44 <lambdabot>   Parse error: DotDot
18:54:53 <gwern> er, elem, not any
18:54:53 <ksf> Warrigal, nope
18:54:57 <Axman6> _Ray_: define: myAll p (x:xs) = p x && myAll p xs; myAll _ [] = True
18:54:59 <_Ray_> Berengal, it's supposed to be trivial anyway :p
18:55:05 <ksf> er well at least they can't be intermingled.
18:55:15 <ksf> dunno if they can overlap, never tried.
18:55:36 <_Ray_> Axman6, that's using first order functions :)
18:55:36 * Berengal ponders a pure fix + lambdas implementation
18:55:38 <Veinor> http://blog.desudesudesu.org/wp-content/uploads/2009/02/27dcd29da9440ccf385d601ad5ea6ae0c9033f4a.jpg
18:55:57 <gwern> Veinor: yeah, we saw it - and the translation
18:56:14 <Warrigal> What if I want to export a type Foo, a data constructor Bar, a class Baz, and a constant quux? Would that be module Whatever(Foo(Bar), Baz, quux)?
18:56:14 <Axman6> _Ray_: define: myAll y (x:xs) = y /= x && myAll p xs; myAll _ [] = True :P
18:56:24 <Veinor> Bah.
18:56:27 <_Ray_> O.o What's /=?
18:56:28 <Veinor> What's the translation for 4?
18:56:42 <ksf> > 6 /= 4
18:56:43 <lambdabot>   True
18:56:43 <gwern> Veinor: iirc, 'secretly, very lazy'
18:56:43 <Axman6> _Ray_: then you can use: allUniq (x:xs) = myAll x xs && myAll xs; myAll [] = True
18:56:44 <sjanssen> I'm not sure if I can live with ghci 6.10 not supporting vi mode
18:56:46 <ksf> > 6 /= 6
18:56:47 <lambdabot>   False
18:56:52 <_Ray_> Ah, interesting.
18:56:55 <Axman6> @src Eq
18:56:55 <lambdabot> class  Eq a  where
18:56:55 <lambdabot>     (==), (/=)   :: a -> a -> Bool
18:57:00 <Veinor> Haha.
18:57:04 <Axman6> @src (==)
18:57:04 <lambdabot> x == y = not (x /= y)
18:57:07 <Axman6> @src (/=)
18:57:08 <lambdabot> x /= y = not (x == y)
18:57:10 <Axman6> >_>
18:57:29 <Fragsworth> Is it typical for most things in haskell to be just a line or two?
18:57:35 <Fragsworth> I mean once it's abstracted
18:57:39 <aavogt> sjanssen: don't the haskelline versions (something like 6.10.3 and up) support a vi mode?
18:57:39 <gwern> haskell-tan is very tsundere
18:57:40 <Axman6> Fragsworth: depends on the thing
18:58:02 <gwern> as opposed to C, which is yandere
18:58:07 <sjanssen> aavogt: oh, maybe.  I'll research, thanks
18:58:09 <Berengal> Fragsworth, it's not too uncommon that something can be *reduced* to just a line or two
18:58:11 <ksf> there's a difference between conciseness and line-noise.
18:58:33 <gwern> Berengal: but only if haskell-tan is feeling -dere when you're writing it
18:58:44 <Axman6> Fragsworth: in my code, i aim for readability above brevity
18:58:45 <sjanssen> the dependencies list on @hackage haskeline is lol-worthy
18:59:10 <Berengal> > (sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails)) [True, False, True, True, True, False, True]
18:59:11 <lambdabot>   138
18:59:22 <Veinor> Berengal: what's that do?
18:59:47 <camio> Fragsworth: If a function I write in haskell is long I usually treat that as a sign that there may be something simpler and more composable that I haven't seen yet.
18:59:59 <ksf> erm left-factoring?
19:00:04 <Berengal> Veinor, True = heads, False = tails. It calculates the average number of coin tosses you need to do to get the input sequence
19:00:12 <Veinor> @_@
19:00:38 <sjanssen> aavogt: ah yes, it works.  k/j don't navigate history though, might have to make a patch
19:00:48 <dolio> FileNotFound = landed on the side?
19:00:50 <Veinor> the fact that that's a one-liner says many things.
19:00:54 <Axman6> _Ray_: so, did that help?
19:01:05 <Veinor> @unpl (sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails))
19:01:05 <lambdabot> (\ i -> sum (map (\ o -> 2 ^ (length o)) (filter and (map (((\ c d -> d c) <*> (map (zipWith (==)))) (init (tails i)))))))
19:01:11 <_Ray_> Axman6, yeah, isn't that just implementing `notElem` though?
19:01:14 <Axman6> _Ray_: (i should also note that myAll == notElem)
19:01:17 <_Ray_> :)
19:01:18 <Axman6> heh
19:01:31 <aavogt> sjanssen: did you see this page: http://trac.haskell.org/haskeline/wiki/ViModeCompatibility
19:01:41 <sjanssen> aavogt: yeah, just saw the "done in head" comment :)
19:01:46 <Berengal> Heh, unpl actually made sort of sense
19:01:49 <_Ray_> (Thanks!)
19:01:51 <ksf> the only evil pl-thing I can spot in there is the map flip ($) thing
19:01:59 <sjanssen> haskeline++
19:02:07 <gwern> bah. I'll just dump the subst into BlockQuote
19:02:17 <Berengal> ksf, it took quite a bit of thinking to figure that one out, combined with <*>
19:02:19 <gwern> so I can email john and essentially tell him 'make pandoc & gitit suck less'
19:02:42 <Vanadium_> @unpl really needs to come up with neat names for variables
19:02:42 <lambdabot> really needs to come up with neat names for variables
19:02:48 <Veinor> lol
19:03:00 <ksf> ...it's definitely evil enough for me to avoid thinking about it, right now.
19:03:10 <Berengal> The thing about point-free code is that not only is it usually harder to read than pointed code, but it's harder to write than read as well
19:03:14 <ksf> gotta watch my ram or I start thrashing.
19:03:29 <sjanssen> we should have an alpha-rename that converts any code sample into a string of curses
19:03:45 <Axman6> ksf: epilepsy?
19:04:23 <ksf> erm no. past-burnout induced painful awareness of the slowness of swapin.
19:04:36 <_Ray_> Oh, and question. If I'm defining a function inside a 'where', is there a way to add type annotations to it?
19:04:40 <aavogt> Berengal: but naming variables is sooo difficult
19:05:04 <gwern> _Ray_: sure. where foo :: bar\nfoo = stuff
19:05:13 <sjanssen> _Ray_: yes, in the same way you add them to top-level annotations, just with more indentation
19:05:15 <_Ray_> ah, d'oh :)
19:05:22 <Axman6> _Ray_: yep, just do it like you'd normally do, indented to align with the function
19:05:39 <ksf> making the usual random remarks in #irc takes constant space, but parsing pl code...
19:05:45 <Berengal> aavogt, I know! Sometimes I can spend five minutes, or even go for a break, just because I got stuck on a name
19:06:17 <ksf> if you don't know how to name something, use a metasyntactic variable name.
19:06:57 <ksf> ...even if that means that you're working with types Foo and Bar months after you last touched their definitions.
19:07:36 <Berengal> Heh, I just had a discussion with someone where I argued that x, y and z were the most used metasyntactic variables in haskell, and that foo and bar were relegated to meta-metasyntactic variables
19:08:14 <ksf> f is used more often than z. not sure about y.
19:08:52 <sjanssen> Berengal: those variables are used too frequently in real code to be useful as metasyntax, IMO
19:08:56 <Berengal> Yeah, usually when you've got a z it can be pointlessed
19:09:07 <sjanssen> "f x y" is not unreasonable Haskell code
19:09:08 <Berengal> sjanssen, which, foo or x?
19:09:22 <sjanssen> Berengal: f, x, y, et.
19:09:33 <ksf> foo = f x y where f = ; ...
19:10:20 <sjanssen> "foo bar baz" is not typical Haskell code, but I'd be tickled to see it in production source
19:10:25 <ksf> is there "to fooificate"?
19:10:26 <Fragsworth> I'm learning haskell and trying to understand monads. Would monads still be useful if Haskell wasn't strongly typed?
19:10:29 <Berengal> sjanssen, a metasyntactic variable is a variable with no attached meaning. x, to me, has no meaning, and usually doesn't semantically either
19:10:46 <ksf> fooificated? fooification? fooified?
19:11:00 <aavogt> @fooify
19:11:00 <lambdabot> Unknown command, try @list
19:11:17 <aavogt> @version
19:11:17 <lambdabot> lambdabot 4.2.2.1
19:11:17 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:11:19 <Berengal> Fragsworth, unlikely. They can still be used, but it requires more boilerplate and hand-holding
19:11:30 <Berengal> And they'd be more restricted
19:11:35 <sjanssen> Fragsworth: monads have been ported to other languages, but strong static typing helps you program with them without losing your mind
19:11:39 <ksf> "x" has the meaning "isn't a function"
19:11:44 <ksf> foo doen't have that.
19:12:01 <Berengal> ksf, x usually has type 'a', which could be a function
19:12:18 <ksf> well then "x isn't used as a function"
19:12:38 <Berengal> If I'm implementing 'map', I'm going to name my list elements x, even though they could just as well be functions
19:12:38 <ksf> as in "x is treated as a value"
19:12:58 <sjanssen> "x" has the meaning "local parameter/let/where-bound variable"
19:13:27 <ksf> ...the point I'm trying to make here is that "f" and "x" have different semantic domains. foo and bar don't.
19:15:17 <Berengal> I still think it's awesome that parameters don't need names...
19:16:38 <aavogt> > let x f g = f * g in 2 `x` 2 -- take that!
19:16:39 <lambdabot>   4
19:16:55 <Berengal> Man, I've been programming in haskell for over a year now, but I still can't get over how awesome it is
19:17:33 <Axman6> heh
19:18:08 <_Ray_> Is it common practice to have more than one 'where' in a function? (As in, nested 'where's)
19:18:32 <Axman6> not really, but there's nothing wrong with it
19:18:45 <ksf> consider moving the top-level fun into its ow module.
19:18:53 <ksf> ...and collapsing the where.
19:19:23 <ksf> you can still re-export the definition, for sanity's sake.
19:23:32 <Rotaerk> hmm yesterday, it was suggested to me to make my game functions operate on type (MonadGame g) => g a, instead of directly on Game a
19:23:43 <Rotaerk> though I'm not too clear on what that abstraction offers
19:24:10 <ksf> more than one game monad.
19:24:35 <ksf> e.g. you might want to have a sub-monad that only works on units, and one that works on buildings.
19:24:55 <ksf> chp uses it to provide looping and forking monads
19:25:16 <sjanssen> or perhaps one game monad that plays the game locally, and one that sends moves to a server
19:25:23 <ksf> yep.
19:25:29 <ksf> perfect example.
19:25:38 <Rotaerk> so I'd have a class (MonadGame g) => MonadGameBuildings g for "sub-monads"?
19:26:12 <sjanssen> Rotaerk: you'd probably just have a data type GameBuildings that is an instance of MonadGame
19:26:13 <ksf> ...which provides you with special operations on buildings, but not on units, but still provides common operations.
19:26:42 <Rotaerk> hmm k
19:26:53 <ksf> or differentiating between your application monad and the monad responsible for game state.
19:27:05 <ksf> i.e. screen size has nothing to do with hitpoints.
19:27:18 <Axman6> http://www.focalprice.com/HT225S/B501_Dagger_Knife_Silver.html
19:27:42 <Rotaerk> heh, the way I was planning was ALL state goes into one overall-state type
19:28:04 <ksf> but you might want to write another game!
19:28:39 <ksf> e.g. both cut-throat and ninja poker.
19:28:57 <ksf> in which case you'd be sharing much more than screen size.
19:28:59 <SamB_XP_> ninja poker ?
19:29:08 <SamB_XP_> hmm ... how about ninja strip poker ?
19:29:41 <_Ray_> Hrmph. It seems I can't use nested 'where's (or I'm using them wrong), this gives a syntax error at the second 'where': http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10606#a10606
19:30:12 <ksf> haskell card deck, anyone? with colours lambdas, pis, sums and units?
19:31:03 <Rotaerk> ksf, well the "overall state" would have subcomponents (fields) of other types (such as CharacterTable, PartyTable).  these types could be reused in a new overall-state type for the next game
19:31:09 <c_wraith> church numerals on the non-facecards
19:31:27 <SamB_XP_> c_wraith: would get a bit long, I think ...
19:31:36 <c_wraith> small font.  it's ok.
19:31:41 <ksf> make that prime factored numerals
19:32:15 <c_wraith> you don't want church numerals on the ace?
19:32:31 <ksf> there's no ace. there's only oleg.
19:32:32 <FunctorSalad_> . o O ( ghc error message deck )
19:34:18 <sjanssen> perhaps one church-encodes decks entirely?  \ace jack king queen spade club heart diamond -> ace heart
19:35:04 <ksf> so a category beats a monoid beats a bottom?
19:35:33 <Axman6> oh my :o
19:35:42 <SamB_XP_> but bottom beats a category?
19:36:23 <_Ray_> Oh, 'where' can only go in its own line if it's the first one
19:36:29 <ksf> only when you play http://en.wikipedia.org/wiki/Skat_(card_game)#Ramsch
19:36:37 <_Ray_> After that it has to come after some code
19:37:20 <sjanssen> _Ray_: that's not quite right.  You're probably having some indentation trouble
19:37:36 <_Ray_> sjanssen, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10606#a10606
19:37:51 <_Ray_> Moving the 'where' to the end of the line above that makes it work
19:38:02 <gwern> let's all just play Mao. it'd make as muchsense
19:41:42 <Fragsworth> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4339#a4339 -- I don't understand the output I'm getting for this. It seems to display each line as I type it, which doesn't seem to be what the documentation for "interact" says it does
19:42:36 <sjanssen> Fragsworth: welcome to the magical land of lazy IO
19:43:14 <Fragsworth> sjanssen: I am new to haskell, so I haven't gotten my brain around how all this lazy stuff happens
19:43:30 <Fragsworth> sjanssen: can you help?
19:44:05 <sjanssen> _Ray_: indent the second where one more space
19:44:32 <sjanssen> Fragsworth: usually laziness and IO don't mix, but Haskell provides a couple functions where they do
19:44:53 <_Ray_> sjanssen, why do I need to put one more space? Isn't the first 'where' indented at 'where the code starts'?
19:45:35 <sjanssen> Fragsworth: so what happens is that getContents will output the characters as soon as they become available (ignoring any buffering that's going on)
19:45:50 <sjanssen> erm, I mean interact will output the characters
19:46:49 <dcsobral> Anyone mind a newbie question?
19:46:50 <sjanssen> Fragsworth: and interact will supply characters to your function as soon as those characters are available
19:47:07 <sjanssen> meaning that "interact id" turns into an interactive "cat"
19:47:17 <sjanssen> dcsobral: more than welcome
19:47:28 <Berengal> Fragsworth, interact is, confusingly enough, not meant for interactive programs. It's mostly useful for writing short filters, like the unix sort and wc programs
19:47:32 <dcsobral> Ok. I'm reading http://www.cs.tufts.edu/~nr/comp150fp/archive/richard-bird/sudoku.pdf
19:47:47 <dcsobral> And I'm having trouble understanding how the definition of "cols" work.
19:48:31 <sjanssen> dcsobral: where starts a new block, so it needs to be indented at more than the previous block
19:48:49 <Fragsworth> Ah, so it's meant to be able to receive input and then output as soon as possible
19:48:53 <sjanssen> sorry, I mean _Ray_ there, was confused for a moment
19:48:57 <dcsobral> Hehhe.
19:49:01 <sjanssen> Fragsworth: yes, exactly
19:49:04 * BMeph thinks sjanssen meant that last to go to _Ray_...
19:49:07 <_Ray_> sjanssen, ah, k :)
19:49:14 <_Ray_> (Thanks!)
19:49:14 <Rotaerk> sjanssen, hrm, interact gets s from the input then returns:  putStr (f s)
19:49:21 <dcsobral> In particular, I don't understand when the first definition is used, and when the second is used.
19:49:22 * sjanssen only has so many cores in his brain
19:49:27 <dcsobral> cols [xs] = [[x] | x ?xs]
19:49:31 <Fragsworth> The fact that it is outputting each line is because of that first "x" in my function, right?
19:49:33 <dcsobral> cols (xs : xss) = zipWith (:) xs (cols xss)
19:49:42 <sjanssen> Rotaerk: yes, putStr . f =<< getContents
19:49:53 <Rotaerk> I'd expect the execution of putStr to force (f s) to resolve, because its value is needed
19:50:06 <BMeph> That's "cols [xs] = [[x] | x <- xs]"
19:50:08 <Rotaerk> and to evaluate that, requires concatenating x with x
19:50:14 <Rotaerk> but it doesn't...
19:50:15 <dcsobral> Oh, duh. I think I get it.
19:50:29 <dcsobral> That's a list with just one element, right?
19:50:42 <BMeph> dcsobral: Correct. :)
19:52:52 <Rotaerk> sjanssen, main = do putStr ("x" ++ "x")   results in xx being displayed, so apparently putStr *should* force the concatenation
19:53:03 * BMeph thinks the following definition is much clearer...
19:53:20 <BMeph> dcsobral: Better yet: > cols                  =  transpose
19:54:42 <BMeph> dcsobral: That's from Graham Hutton's write-up based on that paper -- http://cs.nott.ac.uk/~gmh/sudoku.lhs
19:55:59 <Rotaerk> interesting
19:56:55 <Rotaerk> Fragsworth, it appears when you do "s <- getContents", s can only be used once
19:57:40 <Rotaerk> Fragsworth, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4340#a4340
19:57:50 <Rotaerk> results in s only being output once
19:58:44 <ksf> Rotaerk, putString doesn't force, it's lazy.
19:59:02 <ksf> ...you have to force the () it produces to make it do anything.
19:59:23 <ksf> ...which IO's bind does, as it's strict in its first argument.
20:00:17 <Rotaerk> hmm
20:00:41 <ksf> Rotaerk, I don't believe that only outputs once. sure you didn't overwrite your input with the shell prompt by missing out a \n?
20:01:02 <ksf> also, you might have terminated the process instead of sending an EOF
20:01:27 <ksf> ...as, and that's for shure, both outputs won't be intertwined.
20:02:51 <Saizan_> ksf: main = putStr "foo" will print foo even if you're never using IO's bind
20:03:07 <Rotaerk> ksf, I load that into GHCi, run "> main", and then start entering text, then press enter
20:03:13 <Rotaerk> and then it echos it back to me once
20:03:28 <ksf> Saizan_, but the rts forces the ().
20:03:35 <Saizan_> Rotaerk: getContents is supposed to read the whole input until the end of the file
20:03:46 <ksf> ...and bind takes care that first its rhs, then its lhs is forced.
20:03:56 <Rotaerk> Saizan_, ahh
20:04:08 <Rotaerk> that explains it all then
20:04:10 <Saizan_> Rotaerk: so, if you never feed it EOF then the first putStr is still waiting for more input
20:04:14 <Rotaerk> right
20:04:21 <ksf> er first the lhs then the rhs
20:04:28 <Saizan_> ksf: i don't think it's useful to explain IO in terms of GHC's internals
20:04:50 <ksf> erm I only said the least thing possible.
20:05:01 <ksf> ...that the rts forces the (). nothing more.
20:05:03 <Saizan_> IO actions that don't use unsafeInterleaveIO are strict in their effects
20:05:14 <Saizan_> it has nothing to do with evaluation.
20:05:41 <ksf> if you don't force their result, they won't be evaluated.
20:05:44 <Saizan_> rather, their effects can trigger evaluation, but are not triggered by it.
20:05:49 <Saizan_> yes they would.
20:05:53 <ksf> and they won't have any effect.
20:06:04 <Saizan_> it just has to be a part of the main action
20:06:19 <ksf> ...which is the root of all forcing that's going on.
20:06:40 <ksf> the rts forces the (), then bind and whatnot goes on to decide what happens.
20:06:44 <Rotaerk> so with Fragsworth's original code, what it would do if you kept pushing enter between words, would be to spit back each word as you supply it, then after you send EOF, it'd repeat everything that was entered
20:06:48 <Saizan_> again, it's misleading to talk about forcing, that's just a particular implementation
20:07:14 <ksf> well ok then "the rts depends on the () of main :: IO ()"
20:07:26 <Saizan_> why ()?
20:07:35 <ksf> because main has type IO ()
20:07:59 <Saizan_> it just interprets the IO action, we don't need to know that it requires anything from its value
20:08:14 <Saizan_> in fact it doesn't force the result at all
20:08:26 <ksf> now "interpret" is way more operational than "force"
20:08:30 <Saizan_> try main = return (undefined :: ()), does it return an error?
20:08:40 <ksf> you're describing the compiler, not the evaluation model.
20:09:10 <Saizan_> by interpret i mean it executes the effects so that they are visible on the machine
20:09:48 <ksf> my model of monads doesn't include any effects
20:09:48 <Saizan_> Rotaerk: which was Fragsworth example?
20:10:05 <Rotaerk> interact (\x -> x ++ x)
20:10:20 <Saizan_> Rotaerk: yeah, it would do that then
20:10:49 <ksf> actually, that main = return (undefined:: ()) should be considered as a bug.
20:10:57 <Saizan_> why?
20:11:00 <ksf> ...it _should_ crash.
20:11:27 <Saizan_> also, IO's bind doesn't force the result of the action you pass to it
20:11:28 <ksf> as there's no way to match against that without crashing, unless you're the rts.
20:11:46 <Saizan_> in fact the rts doesn't match on the result
20:12:08 <ksf> but it forces the lhs before passing anything to the rhs.
20:12:18 <Saizan_> it forces only the effects
20:12:35 <ksf> have a look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
20:12:49 <ksf> (though it's arguably quite implementation-dependent)
20:12:49 <Saizan_> "main = return (undefined :: ()) >>= \_ -> return ()" <- does it crash?
20:13:06 <Fragsworth> Saizan_: my original example was here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4339#a4339
20:13:35 <ksf> erm yes you're right. bind forces its lhs, not the result.
20:13:45 <Rotaerk> Fragsworth, do you understand Saizan_'s explanation?
20:14:14 <ksf> so the rts calls main like init = main >>= undefined
20:14:25 <Fragsworth> Not really, I'm kidn of new so it's a bit over my head
20:14:42 <Rotaerk> Fragsworth, pressing enter just inserts a \n into the input, it doesn't end the input
20:15:16 <Saizan_> Fragsworth: to end the input you use ^D (Ctrl+d) in most terminals
20:15:29 <Fragsworth> I guess my intuition is telling me 'interact' is grabbing each line for some reason instead of buffering it
20:15:36 <Rotaerk> Fragsworth, getContents (used in interact) gets the entire input, not just one line, and it can't concatenate x to x until x has been completed
20:15:37 <ksf> use ctrl+d to do that, which works or not, depending on whether you're using ghci or not.
20:15:46 <ksf> ...and the current moon phase etc.
20:15:58 <Fragsworth> but yes, I understand how the entire contents of standard input is read
20:16:00 <ksf> the safest bet is to pipe a file into it.
20:16:19 <Saizan_> Fragsworth: there is buffering that makes getContents see the lines in blocks, though the function you pass to interact is not applied to each line separately
20:16:27 <Saizan_> Fragsworth: it's applied to the whole input at once
20:16:31 <ksf> I think the default buffering is line.
20:16:48 <ksf> you can use hSetBuffering to change that
20:16:56 <Saizan_> Fragsworth: to process each line separately you've to do "interact (unlines . f . lines)"
20:17:05 <monochrom> default buffering is unix default buffering. line if tty, block if file.
20:17:18 <ksf> makes sense.
20:18:08 <danco> i want to be able to do like 'sortBy . comparing $ drop 2 . words' on a file in a haskell unix shell
20:18:42 <danco> is that just a Pipe dream
20:18:45 <Saizan_> ?type \words' -> sortBy . comparing $ drop 2 . words
20:18:46 <lambdabot> forall t. t -> [String] -> [String]
20:19:27 <Saizan_> danco: ghci works for that to some extent
20:19:55 <danco> hm
20:20:22 <Saizan_> the HSH makes more pleasant to run processes, also
20:20:28 <Saizan_> HSH package
20:20:32 <sohum> :t uncurry
20:20:33 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:22:00 <Rotaerk> I'm still getting over the fact that you can have values (not just parameters) whose types are generic
20:22:06 <Rotaerk> such as:  5 :: (Num t) => t
20:22:34 <monochrom> heh heh heh
20:22:40 <FunctorSal> :o
20:23:21 <danco> :t onFile n f = BS.readFile n >>= BS.writeFile n . f
20:23:22 <lambdabot> parse error on input `='
20:23:28 <Makoryu> Rotaerk: Pretty cool, huh? <_<
20:23:31 <monochrom> It is due to an artificial distinction between "functions" and "constant basic values".
20:23:43 <Rotaerk> monochrom, yea
20:23:48 <FunctorSal> artificial?
20:24:48 <FunctorSal> however that may be, (Num t => t) desugars to a function afaik (namely NumDict t -> t)
20:25:23 <FunctorSal> \dict{toInteger=f} -> f 5
20:25:47 <FunctorSal> *fromInteger
20:29:45 <FunctorSal> should I report it as bugs if template haskell's pprint outputs illegal code?
20:30:15 <FunctorSal> (that sounds dangerous)
20:30:35 <SamB_XP_> FunctorSal: why should you not
20:30:36 <SamB_XP_> ?
20:31:22 <FunctorSal> SamB_XP_: I feel like a bit of a nitpicker for reporting stuff like "empty data decls are wrongly prettyprinted with trailing '='"
20:31:36 <SamB_XP_> FunctorSal: don't!
20:31:39 <FunctorSal> but the point is that I'd like the pprint output to re-parse
20:31:53 <SamB_XP_> yes, that is a very valid desire
20:31:58 <SamB_XP_> just report away
20:32:06 <SamB_XP_> don't be so hesitant!
20:32:10 <FunctorSal> ok
20:32:25 <SamB_XP_> ... of course, do look for existing reports when you go to report a bug ;-)
20:36:19 <Saizan_> you could send a patch too, the code is simple, even if weird
20:36:59 <Saizan_> it actually matches on the list of contructors to tell if it's empty, and then goes printing '=' anyway.
20:38:28 <FunctorSal> Saizan_: point :) so do I attach a darcs patch to the report or?
20:38:58 <Saizan_> you can attach a patch to the ticket, yeah
20:39:58 <Saizan_> if it's easy for the maintainer to see that it's correct it's likely that it'll just get applied
20:40:41 <harrison> so i'm kindof a noob at this whole haskell thing. i just wrote a program that removes perfect squares from lines of numbers, but it doesn't seem very elegant. any suggestions? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4341#a4341
20:41:11 <ddarius> ksf: The type of main is forall a. IO a, so the only meaningful thing the RTS can do with the result (without going supra-Haskell which it well could) is discard it.
20:43:23 * SamB_XP_ thinks the compiler may well try to typecheck it's use of main more than one way
20:43:35 <_Ray_> Maybe I'm forgetting something - is there a trivial (ie. less than 10 readable lines) way to, using no functions (and no first order functions), just recursion, eliminate lists that are subsets of another list, not regarding permutation? What I mean is "foo ['a', 'c'] ['a', 'c', 'a', 'd', 'c', 'a']"  outputting ['a', 'd'], since both ['a', 'c'] and ['c', 'a'] are permutations of ['a', 'c'] and get removed.
20:43:54 <_Ray_> By "using no functions" I mean no built-in haskell functions.
20:44:37 <SamB_XP_> all the functions have to be higher-order ?
20:44:48 <_Ray_> Define 'higher-order'?
20:45:00 <_Ray_> Actually, don't, I'll wiki :)
20:45:11 <_Ray_> No, not outputting a function.
20:45:24 <_Ray_> Nor receiving ones.
20:45:25 <ddarius> I think SamB_XP_ is indirectly trying to get you to define what you mean by "first order functions"
20:45:36 * ddarius thinks "first class functions" may have been meant.
20:45:42 <_Ray_> Yes, that may well be :)
20:45:48 <ivanm> ddarius: functions of the first order, duh :p
20:45:53 <harrison> seems a little tricky, since haskell functions are curried :V
20:45:56 <Saizan_> higher order functions are those that take a function as one of their arguments, btw
20:46:10 <_Ray_> Right, none of those.
20:46:12 <ivanm> Saizan_: that take or can take?
20:46:12 <ddarius> Saizan_: Or return one.
20:46:12 <SamB_XP_> first-order functions are basically the opposite of functions that use first-class functions ;-P
20:46:30 <ksf> ddarius, well, now you mention it... it _could_, in the case of a num type, return that to the shell.
20:46:49 <_Ray_> This is one of the first problems in an "intro to functional programming" section of an algorithms & data structures course, but every way I think of doing this is FAR too complicated...
20:47:00 <SamB_XP_> ksf: unlikely
20:47:11 <SamB_XP_> @hoogle ExitSuccess
20:47:11 <lambdabot> System.Exit ExitSuccess :: ExitCode
20:47:11 <lambdabot> System.Exit exitSuccess :: IO a
20:47:41 <Saizan_> ddarius: really? so (+) is an higher order function in haskell, or do you mean something like Foo -> Maybe (Bar -> Baz) ?
20:47:42 <ksf> it also _could_, should the type be [String] -> a, pass in the arguments.
20:48:40 <ksf> which would mean that main = print would have a very cool behaviour.
20:48:56 <ksf> most likely too perly for most peoples tastes, though.
20:49:09 <SamB_XP_> it also *could*, should the type be Porn -> IO Expr, create a computer virus fueled by porn ...
20:49:46 <ksf> SamB_XP_, unlikely.
20:49:59 <ksf> you're talking code inference, I'm talking type inference.
20:50:11 <harrison> _Ray_: are you just removing all elements of one list from the other? since a single element is a subset?
20:50:12 <ksf> (and type matching)
20:50:24 <SamB_XP_> ksf: what I say could also be done!
20:50:33 <FunctorSal> SamB_XP_: I thought higher-order meant "functions on the left of an arrow"
20:50:34 <_Ray_> harrison, no, since that wouldn't leave ['a', 'd'] but just ['d']
20:50:38 * Saizan_ always counted the order of functions by how many left-nested (->) there were in their types
20:50:41 <ksf> it _could_, though, should the type be Porn -> IO Expr, pass in some porn from 4chan and exectute the exprs.
20:50:43 <SamB_XP_> note that the Expr would determine what the payload of the virus would be
20:50:44 <_Ray_> Oh, and I can't use lists by comprehensions either :(
20:50:47 <FunctorSal> but I keep confusing order and rank
20:50:56 <ksf> ...but I'm afraid you're going to have to write the virusgen, yourself.
20:51:05 <SamB_XP_> ksf: I was figuring that it would work something like that, yes
20:51:25 <FunctorSal> Saizan_: misread your statement about (+)
20:51:29 <SamB_XP_> but ... I also figured the code to infect other executables would come from the RTS ;-P
20:52:40 <harrison> _Ray_: so you want to remove any permutation of the entire second list, yes? there's always the brute force approach. start at the head, check permutations, then repeat on the tail. i'm still not sure i understand the problem, though.
20:52:49 <gwern> @wn conceit
20:52:52 <lambdabot> *** "conceit" wn "WordNet (r) 2.0"
20:52:52 <lambdabot> conceit
20:52:52 <lambdabot>      n 1: feelings of excessive pride [syn: {amour propre}, {self-love},
20:52:52 <lambdabot>            {vanity}]
20:52:52 <lambdabot>      2: the trait of being vain and conceited [syn: {vanity}]
20:53:07 <Saizan_> _Ray_: the functions i'd use from Data.List are not hard or long to redefine in your program with explicit recursion, i hope you're still allowed to split the problem in subparts
20:53:11 <_Ray_> harrison, that's why I put an example :) --> What I mean is "foo ['a', 'c'] ['a', 'c', 'a', 'd', 'c', 'a']"  outputting ['a', 'd'], since both ['a', 'c'] and ['c', 'a'] are permutations of ['a', 'c'] and get removed.
20:53:35 <ksf> "vaniy" is one of the wistest word enlish has to offer.
20:53:48 <ksf> ...well, at least if it's properly related to "vain"
20:54:43 <_Ray_> If one were to only specify this function for the case of the first list having length 2, it'd be just going from i = 0; i <= length(second)-2; i++, and checking second[i..i+2] to see if it == first, and in that case, remove from second.
20:54:43 <FunctorSal> ? ;)
20:54:58 <_Ray_> I'm even having trouble thinking about it in a procedural language, let alone a functional one :s
20:55:24 <ksf> what you want is greedy parsing.
20:55:46 <ksf> ...and returning everything that fails.
20:56:00 <ksf> I might be biased right now, though, I just read the uu-parsinglib tutorial.
20:56:15 <_Ray_> Basically, yes. Can that be done in about 10 lines, without using lists by comprehension, higher order functions or built-in Haskell functions?
20:56:37 <ksf> a parser library?
20:56:48 * ksf hides under a lambda
20:56:51 <_Ray_> No, this particular task =p
20:57:16 * ivanm passes a value to the lambda, thus revealing the cowering ksf hiding underneath
20:57:58 <Saizan_> ?src delete
20:57:58 <lambdabot> delete = deleteBy (==)
20:57:59 <ksf> well, do the brute force thing: a) get all permutations (peek at the internets), b) take the tails of the list (peek at the internets) c) combine d) drink a beer
20:58:12 <ksf> I'm a const!
20:58:25 <ksf> returning fixed lambdas.
20:58:39 <danco> > permutations "lol"
20:58:40 <lambdabot>   ["lol","oll","lol","oll","llo","llo"]
20:58:54 <_Ray_> Hrmph. K...*will try*
20:58:55 <ksf> I'm an infinite recursion of contentlessness.
20:58:58 <Saizan_> i'm not sure how generating all the permutations actually help, i'd stick with delete
20:59:08 <monochrom> what happens to foo ['a','b'] ['a','b','c','b','a'] and why?
20:59:26 <_Ray_> the second one gets searched for permutations of the first one, which are removed
20:59:27 <monochrom> err nevermind, easy example.
20:59:30 <ksf> the only information that you can get out of me that there might be, in theory, be an end to all that senseless information.
20:59:39 <danco> f p l = l without any subsequence that is a permutation of p?
20:59:43 <_Ray_> so ['c']
21:00:08 <_Ray_> danco, yup, without altering the order of the things in l, of course
21:00:09 <Axman6> > nub . permutations $ "lol"
21:00:10 <lambdabot>   ["lol","oll","llo"]
21:00:29 <monochrom> Here is the one I want. foo ['a','b','c'] ['a','b','c','b','a']
21:00:50 <danco> that's [] right8?
21:00:59 <_Ray_> I'd assume so - the example I posted is the only one I'm given.
21:01:13 <_Ray_> (Which is why I dislike this exercise very, very much)
21:01:21 <Saizan_> [] wouldn't really be consistent with the given example
21:01:22 <ksf> er no. I guess it's "ba" as the "abc" already has been consumed.
21:01:25 <monochrom> I don't know. That is why I think up interesting examples. My thesis is the question is undefined.
21:01:26 <danco> any element which is part of any subsequence which is a permutation of p goes
21:01:31 <Saizan_> which keeps ['a','d'] in the output
21:01:31 <ksf> ...at least that's how I understood the first example.
21:01:34 <danco> i think it's well defined
21:01:54 <Saizan_> despite the prefix ['a','c','a',..
21:02:37 <Saizan_> ['a','c','a'] contains two overlapping permutations of ['a','c']
21:02:55 <ksf> ...just dropping all the elements of the first ones from the second is easy, just generalize filter.
21:02:57 <Saizan_> but only ['a','c'] got removed
21:02:58 <monochrom> Is there any reason the answer is not allowed to be ['a','b'] because I delete ['c','b','a'] because it is a permutation of ['a','b','c']?
21:03:12 <danco> i would just go thru every permutation, and mark elements for each way it can exist as a subseq, then at end kill all marked elems.  then cry at how slow it is.
21:03:23 <jfredett> ... Parsec + Template Haskell = Match Made in Haskell Heaven.
21:03:42 <danco> Saizan_: oh ok so it's not what i thought it was
21:04:12 * danco wonders if there is really a place in heaven for TH
21:04:15 <ksf> why do you guys keep on writing Strings as [Char]s?
21:04:16 <_Ray_> Eh, I'll just skip the exercise and mark it as "poorly defined" :(
21:04:22 <Saizan_> jfredett: from what are you generating those parsers?
21:04:27 <Axman6> yeah, i've been wondering that too
21:04:29 <danco> :t "lol"
21:04:29 <lambdabot> [Char]
21:04:32 <danco> that's why!
21:04:45 <Axman6> > ['a','b']
21:04:46 <lambdabot>   "ab"
21:05:07 <ksf> my comment transcended type noninference.
21:05:14 <jfredett> Saizan_: I just started working a bit more on my nonstandard email parser (forked off from hsemail) -- I'm trying to make it a little more exensible to ease the additon of nonstandard fields to the main datatype
21:05:26 <Axman6> > (length "['a','b']", length "ab")
21:05:27 <lambdabot>   (9,2)
21:05:46 <jfredett> so I'm rewriting the datatype to be generated by TH. along with parsers for individual fields + the datatype as a whole.
21:06:05 <jfredett> as of right now, there is about 300-350 oneliner parsers for each field
21:06:07 <Saizan_> yeah, i paid for extra characters to freenode that i've never used, so i guessed i could take advantage of them now
21:06:12 <ksf> so if I use your email client, to match a custom header I have to recompile the app?
21:06:24 <monochrom> I can't write a list of booleans as a string.
21:06:37 <jfredett> ksf: well the idea isn't for _you_ to use the custom header additions, but _me_ to use them.
21:06:53 <danco> monochrom: show?
21:07:04 <ksf> jfredett, no offense, but you email client sucks.
21:07:27 <Axman6> > read "[True, False]" :: [Bool]
21:07:29 <lambdabot>   [True,False]
21:07:37 <jfredett> ksf: it does now. :p
21:07:41 * gwern snickers
21:07:42 <monochrom> I mean [True] is not a string.
21:07:55 <gwern> monochrom: all I'm seeing is a string on my screen!
21:08:01 <gwern> I can copy and paste it, and everything
21:08:02 <jfredett> ksf: but it's also not really an email client yet.
21:08:02 <monochrom> ['t'] is a string but [True] is not.
21:08:02 <ivanm> monochrom: map (toChar . fromEnum) ?
21:08:14 <ivanm> with toChar having 0 -> '0', 1 -> '1'
21:08:17 <ivanm> ;-)
21:08:34 <aavogt> > map (toChar . fromEnum)
21:08:34 <lambdabot>   Not in scope: `toChar'
21:08:40 <ivanm> aavogt: I made toChar up
21:08:44 <ksf> ...well, my point is that while it's a good idea to have standard and semi-standard headers predefined, matching any should be done, too.
21:08:45 <jfredett> ksf: it didn't really have a place in the world till recently, when I determined _exactly_ how I want to use it.
21:08:46 <aavogt> > map (toEnum . fromEnum)
21:08:47 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
21:08:48 <ivanm> since AFAIK the only option is char...
21:08:55 <ivanm> @hoogle Int -> Char
21:08:55 <lambdabot> Data.Char chr :: Int -> Char
21:08:56 <lambdabot> Data.Char intToDigit :: Int -> Char
21:08:56 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
21:09:04 <ivanm> oh, intToDigit... that's what I was after!
21:09:13 <Axman6> > intToDigit 10
21:09:14 <lambdabot>   'a'
21:09:15 <ksf> data Header = StandardHeader | CommonHeader | String
21:09:15 <jfredett> ksf: of course
21:09:17 <Axman6> > intToDigit 9
21:09:18 <lambdabot>   '9'
21:09:22 <ivanm> Axman6: bah
21:09:26 <aavogt> > intToDigit 100
21:09:27 <lambdabot>   * Exception: Char.intToDigit: not a digit 100
21:09:31 <Axman6> > map intToDigit [0..]
21:09:32 <lambdabot>   "0123456789abcdef* Exception: Char.intToDigit: not a digit 16
21:09:35 <ivanm> @type map (intToDigit . fromEnum)
21:09:36 <lambdabot> forall a. (Enum a) => [a] -> [Char]
21:09:58 <ksf> ...if it's just to parse the custom headers the user entered against the standard one and correct his spealing.
21:10:00 <jfredett> ksf: right. I have it designed so that each header will have a field with it's "Standardness"
21:11:42 <jfredett> ksf: the overall idea is to make the current peice of code I have (which is looking more and more like it needs to be rewritten) which sorts email to have a more powerful method for sorting email
21:12:00 <jfredett> this in turn makes it easier to handle the load of email that I have to parse through for HWN easier.
21:12:04 <danco> intToDigit is weird..
21:12:15 <Axman6> > map (digitToInt . intToDigit) [0..]
21:12:16 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,* Exception: Char.intToDigit: not a ...
21:12:20 <ivanm> danco: in what way?
21:12:23 <ivanm> Axman6: :o
21:12:28 <jfredett> at least, thats my hope.
21:12:28 <ivanm> > intToDigit 16
21:12:29 <lambdabot>   * Exception: Char.intToDigit: not a digit 16
21:12:30 <danco> hexadecimal being implied..
21:12:32 <Axman6> laziness++
21:12:34 <ivanm> ahhh, yeah
21:12:37 <ivanm> Axman6: heh
21:12:53 <ksf> there's no standard mapping beyond hex.
21:13:29 <jokerGTA> can anyone try to help me with this showString function
21:13:35 <jfredett> ksf: as of now, the hwn tools scrape the gmane blogs for the -cafe and -general lists... my goal is to set up a dummy account to collect email and have this code sort out the stuff for me. :)
21:13:39 <jfredett> jokerGTA: hm?
21:13:48 <jokerGTA> instance Show MyType where 	show (My(a, b))            = showString (My(a,b))
21:13:50 <ksf> and passing anything bigger than hex is a bug in an overwhelming majority of cases, so... bleeding write your own version if you need it.
21:13:58 <jfredett> ksf: I effectively am aiming to put myself out of a job. :)
21:14:03 <jfredett> @where paste
21:14:03 <lambdabot> http://hpaste.org/new
21:14:13 <danco> it's poorly named
21:14:15 <jfredett> jokerGTA: put it there. I can't read it here...
21:14:34 <jfredett> :t showString
21:14:34 <lambdabot> String -> String -> String
21:14:48 <jokerGTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10607#a10607
21:14:53 <ksf> yep it could be called toHexDigit and fromHexDigit
21:15:12 <ksf> but then some nuab would come along and ask for a decimal version
21:15:20 <jfredett> jokerGTA: okay.
21:15:27 <jfredett> jokerGTA: whats the issue?
21:15:43 <jokerGTA> it gives me errors which i cant really understand at my level
21:15:46 <ksf> maybe there should just be a tr
21:15:47 <jfredett> dright.
21:15:51 <jokerGTA> i am just trying to print something to the screen
21:15:52 <jfredett> so think about this.
21:15:57 <jfredett> what is the type of "show"?
21:16:06 <Axman6> :t show
21:16:07 <jokerGTA> my type is instrance of class Show
21:16:07 <lambdabot> forall a. (Show a) => a -> String
21:16:13 <Axman6> @instances Show
21:16:13 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
21:16:14 <ksf> jokerGTA, which error?
21:16:19 <ksf> I don't see any.
21:16:20 <jfredett> jokerGTA: right, that means you have to provide a function
21:16:25 <Axman6> [a] will be the one giving you errors i bet
21:16:26 <jfredett> that has the same type as show
21:16:38 <ksf> (and I'm not going to suffer the agony of creating a file etc)
21:16:47 <jfredett> so - newtype Foo = Foo Int is an instance of show
21:16:49 <jokerGTA> is there any example online i cant look at that you know of
21:16:54 <jfredett> with show (Foo i) = show i
21:17:08 <jfredett> hmm, let me see. hang on.
21:17:18 <jokerGTA> thanks jfredett
21:17:41 <ivanm> Axman6: overlapping instances?
21:17:47 <Axman6> i believe so
21:17:53 <ksf> jokerGTA, you might also want to try data Foo = ... deriving Show
21:18:59 <jfredett> jokerGTA: hang on, I'll just cook one up...
21:19:04 <jokerGTA> deriving (Show,Eq)
21:19:06 <jokerGTA> thanks man
21:19:23 <Axman6> > fix show
21:19:24 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:19:35 <performance> @ seen jfredett
21:19:38 <performance> @seen jfredett
21:19:39 <lambdabot> Unknown command, try @list
21:19:46 <ksf> preflex, seen @seen
21:19:46 <preflex>  Sorry, I haven't seen @seen
21:20:30 <performance> any one know what the seocnd arg to HWN sender should be?
21:21:15 <performance> http://www.reddit.com/r/EnHaskell/  second post by jfredett
21:22:12 <Saizan_> En?
21:22:39 <performance> En as in EnPassant
21:25:28 <monochrom> If the second arg starts with 't' or 'T', the email is sent to jfredett himself; otherwise, the email is sent to the mailing list.
21:26:51 <jfredett> jokerGTA: check your hpaste post, I added an explanation to it
21:27:32 <jfredett> whose looking for me?
21:27:46 <jfredett> performance: yah, it's just a test thing
21:27:48 <jokerGTA> thanks so much jfredett
21:27:55 <jfredett> jokerGTA: does that make sense?
21:28:08 <jfredett> type classes can be a bit confusing till you get used to them
21:28:11 <jokerGTA> yeah i am reading it now
21:28:13 <performance> ah, thanks jfredett for the script and monochrom for the explanation, i re-read the comment after reading your explanation and now it makes sense
21:28:21 <jfredett> I find it helps to think of them as proofs.... :)
21:28:21 <jokerGTA> i am few weeks into haskell only
21:28:53 <jfredett> performance: that whole script is a lovely kludge. :)
21:29:30 <jfredett> eventually that will be built in (nicely) to HWN2, as well as (I hope) s.c.o submission and reddit submission.
21:30:03 <performance> jfredett:  i get an error about not finding openFile
21:30:10 <performance> although you used readFile in there
21:30:20 <ivanm> performance: of course, jfredett should be using something a bit smarter than a string and checking the first char...
21:30:24 <jfredett> performance: hmm. thats odd... it works for me... :)
21:30:33 <jfredett> ivanm: yes, I should
21:30:52 <jfredett> really I should have test-mode be the default mose
21:30:54 <jfredett> mode*
21:31:04 <performance> $ runhaskell --version
21:31:06 <performance> runghc 6.10.3
21:31:17 <jfredett> and then provide a "send" option using something like CmdArgs, and make it really robust.
21:31:24 <jfredett> but mostly, I just wanted to send an email. :)
21:31:27 <performance> oh and if i dont give a second param
21:31:39 <jfredett> it fails, I know
21:31:46 <performance> $ runhaskell sm.hs  flc.csv
21:31:47 <performance> sm.hs: user error (Pattern match failure in do expression at sm.hs:15:8-16)
21:31:50 <jfredett> I just pass it "send" and "test". :)
21:32:07 <jfredett> like I said, the code is kludgy.
21:32:33 <performance> found the  problem :)
21:32:42 <jfredett> I wonder if there's a sendmail wrapper in haskell... there must be, Darcs uses sendmail to send patches, I can't imagine they do that via system.cmd.
21:32:50 <jfredett> @where darcs
21:32:50 <lambdabot> http://darcs.net/
21:34:22 <performance> jfredett: by the way im fpisfun on reddit. Thanks a lot for volunteering ot be a mod :)
21:34:30 <jfredett> darcs is all in .lhs in latex? way cool
21:34:45 <jfredett> performance: it makes me feel powerful, so it's no worries. I am king of geeks!
21:36:05 <performance> :)
21:37:20 <FunctorSal> is the rule that tycons starting with a colon always have to be put in parens when used as prefix operators?
21:37:36 <FunctorSal> (still trying to fix the prettyprinter)
21:37:48 <Saizan_> well, yes, since they are operators
21:38:05 <Saizan_> afaiu
21:38:14 <jfredett> wow. Darcs is really confusing...
21:38:29 <jfredett> the source code, not the user-end.
21:38:47 <jfredett> I'll just put all that back in it's black box... :)
21:39:19 <Makoryu> FunctorSal: Infix operator syntax is designed for infix operators >_>
21:39:21 <ivanm> preflex: seen kowey
21:39:21 <preflex>  kowey was last seen on #haskell 3 days, 15 hours, 59 minutes and 2 seconds ago, saying: email it is, thanks!
21:39:32 <ivanm> jfredett: ^^ maybe try asking kowey?
21:39:42 <Makoryu> :t (`flip`)
21:39:43 <lambdabot> parse error on input `)'
21:40:06 <jfredett> ivanm: it's not that important, it appears that they have some sort of homebrew wrapper for command-line interaction.
21:40:28 <ivanm> ahhhh
21:40:28 <FunctorSal> Makoryu: putting parens around them and printing as prefix sounds way easier
21:40:30 <jfredett> not a specific use of a sendmail wrapper.
21:40:44 <jfredett> ivanm: at least, thats what I gather from 'twixt the mountains of source...
21:40:45 <jfredett> :)
21:40:56 <FunctorSal> (and there is no "InfixT" constructor that would tell you whether the input was infix)
21:41:04 <ivanm> jfredett: heh
21:41:27 <FunctorSal> currently they're printed prefix without parens, which is illegal
21:42:33 <jfredett> meh.. enough hacking for today. my head hurts. gnite haskellers.
21:42:40 <mistermatt> how is this translated after :t (==)
21:42:42 <mistermatt> (==) :: (Eq a) => a -> a -> Bool
21:43:04 <ivanm> cya jfredett
21:43:27 <monochrom> (Today has barely started...)
21:43:34 <ivanm> mistermatt: given a type that has an Eq instance (i.e. a value that you can test for equality), == takes two values of that types and returns a boolean
21:43:36 <ivanm> @time
21:43:37 <lambdabot> Local time for ivanm is Sun Oct 11 14:43:36
21:43:41 <ivanm> monochrom: I beg to differ
21:43:42 <ivanm> ;-)
21:44:13 <danco> @time monochrom
21:44:14 <lambdabot> Local time for monochrom is Sun Oct 11 00:44:13
21:44:15 <monochrom> Yes, that is an instance of barely started. For example wake up at noon, have lunch from 1pm to 2pm!
21:45:19 <ivanm> monochrom: technically, it would be breakfast still if it's your first meanl
21:45:21 <ivanm> *meal
21:45:47 <monochrom> My friend and I were like "beautiful day today, starts at 4pm" when we were both in grad school.
21:46:10 <mistermatt> ivanm, I'm just confused about the type variable in the class constraint
21:46:30 <monochrom> We had dinner together at 2am.
21:46:36 <ivanm> mistermatt: OK, so (Eq a) means that values of type a must have equality defined upon them
21:46:42 <ivanm> @src Eq
21:46:42 <lambdabot> class  Eq a  where
21:46:42 <lambdabot>     (==), (/=)   :: a -> a -> Bool
21:46:43 <FunctorSal> monochrom: sounds like me, I feel bad about it though :-(
21:47:09 <FunctorSal> and I'm haskelling instead of advancing school, too
22:04:44 <mistermatt> ivanm, cool, thanks
22:05:03 <ivanm> no worries
22:05:18 <ivanm> preflex: seen Axman6
22:05:18 <preflex>  Axman6 was last seen on #haskell 45 minutes and 55 seconds ago, saying: > fix show
22:15:06 <Axman6> ivanm: ?
22:15:48 <ivanm> Axman6: are you in belconnen belconnen, or just within the general district of belconnen?
22:16:21 <Axman6> well, the town of belconnen. just accross the lake from the mall
22:17:27 <ivanm> *nod*
22:18:03 <ivanm> wikipedia implies that its public transport isn't as good because belconnen (the district) was designed around private transport
22:18:05 <ivanm> is that true?
22:18:51 <Axman6> i wouldn't say so
22:19:11 <ivanm> good-o
22:19:26 <Axman6> there are laws saying that in residential areas, all houses must be no more than 10 mins walking distance from a busstop i believe
22:19:29 <ivanm> Axman6: also, why did you go to ANU if UC is in Belconnen? reputation, what you wanted to study, etc.?
22:19:35 <ivanm> Axman6: nice! :D
22:19:38 <Axman6> both
22:20:16 <ivanm> heh, same with me and going to UQ and Griffith University (which is up the road from my place)
22:21:29 <Axman6> i didn't know what i would learn at ANU, but i was pretty sure it would be more interesting than UC (ad turns out i was very right... hence me being here :))
22:22:32 <ivanm> heh
22:22:47 <ivanm> here, griffith == hippy central :p
22:23:12 <Axman6> apparently UC's not bad for law (what my gf's doing there)
22:23:28 <ivanm> *nod*
22:24:27 <Axman6> there are things it's good at, but IT isn't one of them, and i don't think they even have an engineering course
22:26:19 <iaefai> I have installed the haskell platform on windows xp, but when I go to install SDL with cabal, it gives errors that I am not sure describe the problem to me: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10610#a10610  Any help would be appreciated.
22:27:42 <Axman6> do you have SDL installed? (that doesn;t look like it's your problem though)
22:27:52 <ksf> runGenProcess?
22:28:22 <iaefai> Axman6: The technical answer is not really. I have a dll hanging around that I built, but it wouldn't know about it
22:28:42 <ivanm> old cabal I think...
22:28:44 <ivanm> or something
22:29:17 <ivanm> hmmmm, that's the latest version
22:29:17 <iaefai> I did a cabal update
22:29:25 <ivanm> and hackage says it built with 6.10 ...
22:29:42 <ksf> there's some win32 docs in the tarball
22:29:51 <ivanm> @hoogle runGenProcess
22:29:51 <lambdabot> No results found
22:29:53 <iaefai> Would putting the sdl.dll in with ghc's directory be enough?
22:29:55 <ksf> ...which mentions messing with the .cabal
22:30:53 <ksf> ... the .cabal and configure.ac don't contain anything windoze-specific, so I guess it's not supposed to be used there.
22:30:57 <ivanm> iaefai: download the tarball, unpack it, follow the directions in the WIN32 file there, and run "cabal install" in that directory
22:31:16 <iaefai> ok, will do
22:31:33 <iaefai> Is this really the only way this package could have been done?
22:31:44 <ivanm> iaefai: *shrug*
22:32:19 <ksf> there's going to be no painless windoze packages when no windoze users provide them.
22:33:19 <iaefai> The best install I have ever seen for packages for a system are python's exe packages that find the right python automatically. But some how I doubt it would be that easy here.
22:34:23 <sproingie> actually those are really crappy to deal with
22:34:52 <sproingie> but they are convenient
22:35:33 <ksf> they should port portage to windoze. I might refrain from talking badly about it for a short while, then.
22:36:24 <ivanm> ksf: can't you do some stuff using gentoo/alt ?
22:36:39 <ivanm> s/alt/prefix/
22:36:48 <sproingie> technically pkgsrc supports windows with SFU installed
22:36:58 <ksf> dunno. I just think all those windoze users should switch to a standard os.
22:37:11 <ksf> how can one possibly use a non-posix system?
22:37:47 <sproingie> posix can bite me.  how many years have they screwed up defining basic async i/o?
22:39:06 <ksf> at least they _do_ define.
22:39:15 <ksf> ...actually, standardize.
22:39:18 <sproingie> yes and if it sucks, it's worse than nothing
22:40:35 <ksf> so you say the only reason we're hearing people complain about stuff not working on windoze, but no freebsd'lers complaining that there just aren't any of the latter?
22:40:41 <sproingie> linux and freebsd just go do their own thing
22:41:04 <ksf> well so what. Informally, that's posix to me.
22:41:26 <sproingie> linux is something of a de facto standard itself, yes
22:41:35 <hiredman> :(
22:41:45 <ksf> ...with solaris and freebsd having linux emu layers, yes.
22:41:56 <sproingie> just userland tho
22:42:00 <hiredman> makes a bitch on non linux unix systems
22:42:10 <sproingie> you don't automatically get, say, epoll
22:42:44 <sproingie> there's libraries that paper over differences with epoll and kqueue and such, but that's the sort of thing posix should be doing
22:43:03 <sproingie> capturing established best practices instead of defining half-assed minimal ones
22:43:07 <iaefai> with runghc Setup.lhs build   is there a way to have it output the commands it is running? It doesn't want to open sdl.h and generates an error, but everything should be fine
22:43:38 <ksf> but you get kqueue and /dev/poll
22:43:49 <sproingie> eh, /dev/poll is a nasty hack
22:44:01 <sproingie> kqueue is bsd only (and nice)
22:44:01 <ksf> well I never used it nor looked at the docs.
22:44:14 <sproingie> oh read the docs for it sometime, you'll see
22:44:23 <ksf> but user-level instead of kernel-level standards aren't bad, either.
22:44:55 <ksf> but, you see, all these systems have fork().
22:45:00 <ksf> which windoze doesn't.
22:45:02 <sproingie> well posix is 99% a user-level standard
22:45:25 <sproingie> fork is almost always followed by exec which makes it a total waste to fork
22:45:40 <ksf> that's what copy-on-write is for.
22:46:02 <sproingie> sure, a workaround for what you didn't need in the first place
22:46:03 <mistermatt> is pattern matching in functions more widely used than conditional blocks?
22:46:17 <sproingie> that's why posix defined posix_spawn
22:46:43 <mistermatt> or is it a 'what are yo more in the mood for' kind of deal?
22:47:14 <monochrom> None of the above. Determined by the task instead.
22:47:22 <sproingie> mistermatt: depends on what you're doing.  pattern matching switches based on the structure of the args, while guards match on some predicate
22:47:45 <ksf> ...they say they defined it because they want to run on platforms with insufficient adressing units.
22:47:46 <sproingie> they actually go nicely together
22:48:38 <mistermatt> I'll do some more reading
22:48:40 <iaefai> I read somewhere that C# 4 is implementing STM, does it seem like all the new language features are being stolen from haskell?
22:48:41 <mistermatt> thanks guys
22:49:03 <sproingie> i think it's a great sign when they steal from haskell
22:49:04 <ksf> afaik, windoze doesn't run on mmu-less processors (anymore), either.
22:49:24 <monochrom> They are not stealing. We are penetrating.
22:49:31 <sproingie> not having a mmu makes fork a real pain.  in fact you usually end up only with vfork or something like that
22:49:53 <ksf> iaefai, we stole atomically from java and gratiously added orElse and retry
22:50:24 <sproingie> STM's already hitting java in third party libs, not to mention clojure
22:50:26 <ksf> erm yes but tell me about a mmu-less cpu I'd want to use.
22:50:45 <sproingie> nothing you'd want to run unix on
22:50:48 <ivanm> iaefai: Haskell (more specifically GHC) is partially a language research platform
22:50:50 <ksf> ...exactly.
22:51:02 <ivanm> IIUC, GHC wasn't the first implementation of STM, but it _did_ popularise it
22:51:05 <ksf> so unix doesn't need to abandon fork
22:51:09 <ivanm> since SPJ added the atomically constraint to it
22:51:29 <ksf> no the atomically came from some java researcher.
22:51:30 <sproingie> abandon, heck no.  fork's useful when you want it.
22:51:43 <ivanm> ksf: :o
22:51:50 <monochrom> Java 8 will have GADT. C# 6 will have type families. Python 4 will have static type inference.
22:51:52 <sproingie> when you don't, it's kind of a pain shutting down extra fd's
22:52:09 <ksf> ...spj implemented stm in haskell and noticed because of all that missing clutter that orElse and retry are the thing that actually make it powerful, and went on adding them.
22:52:11 <sproingie> i suspect C# will get type families long before then
22:52:17 <ksf> it's gone full circle.
22:52:52 <ksf> and perl7 will have a parsable syntax.
22:53:04 <sproingie> now that's just crazy talk
22:53:59 <ksf> lisp 2020 is going to have syntax
22:54:19 <sproingie> lisp has oodles of syntax.  have you seen how many reader macros CL has?
22:54:22 <ksf> the next freepascal version is going to implement goto.
22:54:48 <mistermatt> what is stm
22:54:58 <sproingie> mistermatt: software transactional memory
22:55:00 <hiredman> algol style styntax on a lisp, people have been talking about it for over 30 years now
22:55:01 <thoughtpolice> the .NET STM stuff is really awesome work, although clojure I believe has a better implementation because it does no copying, i.e. it expects all stm-ref's will be immutable structures in the first place
22:55:02 <ksf> the next nfunge version will have black holes and implement string theory
22:55:46 <ivanm> thoughtpolice: so clojure have their own independent STM implementation on top of .Net?
22:55:46 <thoughtpolice> and clojure embodies persistent data structures so it works out, .NET not so much
22:55:47 <sproingie> the next malbolge will be bootstrapped
22:56:00 <sproingie> ivanm: clojure is java
22:56:02 <thoughtpolice> ivanm: no
22:56:07 <hiredman> there is a .net port
22:56:09 <ivanm> sproingie: oh... thought it was .Net
22:56:10 <ksf> agda 3 will come with a keyboard.
22:56:10 <ivanm> :s
22:56:16 <ivanm> ksf: we get the point
22:56:16 <sproingie> they have a .net port yes, it's their own homegrown implementation
22:56:17 <thoughtpolice> there is work on clojure for .net however
22:56:20 <ivanm> you can shut up now ;-)
22:56:28 <BMeph> "<hiredman> algol style styntax on a lisp" <-- isn't that javascript? ;p
22:56:36 <thoughtpolice> i believe it's pretty up-to date with the current clojure impl (as far as 1.0 and beyond)
22:56:56 <sproingie> actually lisp was conceived to have an algolish syntax from the start.  it predates algol so of course it didn't use the term
22:57:01 <thoughtpolice> they're trying to do clojure-in-clojure however, which will lead to really neat bootstrapping possibilities
22:57:07 <sproingie> it was called M-Expressions.  S-Expressions stuck tho.
22:57:14 <hiredman> erm
22:57:18 <Gracenotes> no one used M-expressions -_-
22:57:28 <hiredman> where mexpressions really all that algol-ish?
22:57:43 <hiredman> my impression was just flip the function to the outside and use square brackets
22:57:45 <sproingie> closer to it anyway
22:58:19 <sproingie> i believe mexps intended to support infix too
22:58:58 <sproingie> was meant to be more fortranish
22:59:11 <thoughtpolice> ivanm: so yeah, the clojure impl of STM is pretty efficient because by design most of the data structures are immutable. i welcome the inclusion of STM into .NET too - I do concurrent code @ work, and believe me, an STM would be really nice to have :)
22:59:28 * hiredman spent a good chunk of last weekend reading Evolution of Lisp
23:00:33 <ivanm> hiredman: any good?
23:00:36 <ivanm> thoughtpolice: *nod*
23:00:42 <hiredman> yes
23:00:47 <thoughtpolice> ivanm: at lunch this week for example we were talking about needing a queue but said queue needed to be accessed concurrently. when the discussion on 'how to do this' really went somewhere, I had to quote SPJ and say "there are entire research papers dedicated to this topic of concurrent lock-based queues)
23:00:54 * ksf wants a 64-core arm on his desk.
23:00:54 <hiredman> if you are interested in the history of lisp, of course
23:01:02 <thoughtpolice> * "
23:01:06 <ivanm> hiredman: heh
23:01:49 <sproingie> my favorite lisp is still emacs lisp just because of the environment
23:01:50 <hiredman> I had no idea scheme started off as an experiment in the actor model of computation
23:01:51 <thoughtpolice> ivanm: to which everybody responded "... *sigh* yeah" and we kind of went back to step 1 on the matter and discussed other options :P
23:01:55 <monochrom> There are also entire papers on concurrent lock-free queues. Perhaps even more.
23:02:13 <sproingie> schemer, the sequel to planner, no?
23:02:16 <ivanm> thoughtpolice: heh
23:02:22 <hiredman> sproingie: yeah
23:02:50 <hiredman> but the system they developed on only supported a certain length of file names so the r got dropped
23:03:07 <sproingie> i thought it was to differentiate the language from the app
23:03:23 <ksf> that's kind of like the history of guybrush threepwood.
23:03:34 <hiredman> that is according to the evolution of lisp
23:03:35 <thoughtpolice> ivanm: most of my coworkers are very very smart however (2 out of the 4 developers sans me actually write/research haskell,) and I think they all knew something like STM would be very effective for this situation
23:04:04 <ksf> in the beginning, he hadn't a name, but a sprite file, and that was called guy.brush
23:04:06 <ivanm> so are you using it? or are you currently stuck with .Net without STM support?
23:05:09 <thoughtpolice> ivanm: our software is written in C++ and java, so maybe if I had enough of a 'tech > politics' stance I could convince our boss of using clojure if we needed simple, efficient concurrency
23:05:30 <ksf> ...you see, game creators are an uncreative lot.
23:05:32 <sproingie> F# seems to be getting a lot more mention lately too
23:05:36 <thoughtpolice> because honestly we're all aware that multithreaded programming with locks is a bitch and it takes time and effort to get right.
23:06:08 <ivanm> *nod*
23:06:12 <thoughtpolice> a simpler, easier solution (that happens to retain efficiency) would be very welcome, and I think that our dev team is small enough it could happen because everybody is smart enough, but now is not the best time
23:06:42 <thoughtpolice> maybe in the future I could push clojure for some things but right now that's not what's necessary :p
23:18:45 <bos> @src gcd
23:18:45 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
23:18:45 <lambdabot> gcd x y = gcd' (abs x) (abs y)
23:18:45 <lambdabot>    where gcd' a 0  =  a
23:18:45 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
23:19:20 <iaefai> If I try to have an SDL program compile and it gives a whole bunch of linking errors, does that mean I have to add an additional parameter to ghc?
23:19:50 <iaefai> foo.o:fake:(.text+0x193): undefined reference to `SDLzm0zi5zi5_GraphicsziUIziSDL ziEvents_waitEvent_closure'
23:20:15 <stanv_> is there function for leave only unique elements of list with `by' function ?
23:20:26 <Lemmih> iaefai: Try --make.
23:20:26 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
23:21:04 <iaefai> awesome,thanx
23:21:33 <iaefai> and - it works :p
23:21:41 <iaefai> Now coding on a netbook sucks
23:21:58 <iaefai> my imac will likely be much more friendly tomorrow when I get back home
23:22:53 <SmurfOR> is coding on a netbook that bad?
23:23:19 <SmurfOR> i was thinking of getting one, upping the ram to 2gb and running linux on it with xmonad i didn't think it'd be _that_ bad
23:23:52 <stanv_> :))) In case your hands fill on keyboard :)
23:24:04 <SmurfOR> :/ i do kind of have chubby fingers
23:24:11 <SmurfOR> i <3 my model m too
23:25:05 <porges> stanv_: nubBy
23:25:19 <hiredman> I love my wind
23:25:21 <porges> @hoogle nubBy'
23:25:21 <lambdabot> No results found
23:25:25 <porges> @hoogle nubBy
23:25:26 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
23:25:47 <stanv_> porges: thanks!
23:27:10 <iaefai> SmurfOR: The problem is the tight keyboard
23:27:14 <iaefai> I am sure others would be fine
23:28:56 <mreh> i've found documentation for the cabal tool set, but I can't find any for the actual command line tool "cabal" itself
23:29:14 <mreh> and the cabal --help isn't descriptive enough for me
23:29:35 <mreh> even when i dig down into cabal COMMAND --help
23:30:12 <ksf> mhhh can we afford not going a bit oop with h'?
23:30:43 <SmurfOR> iaefai, hmmm i'll have to try some at the store first then.  i don't mind laptop keyboards but i <3 my buckling springs
23:30:45 <ksf> I mean the smalltalk/scala sense of oop.
23:31:01 <ksf> (or, actually, the oohaskell sense, but tightly integrated)
23:32:04 * ksf can't decide between "every object is a function" and "every function is an object"
23:32:39 <SmurfOR> iaefai, if you don't mind me asking what netbook do you specifically own?
23:34:03 <porges> mreh: the tool is called "cabal-install"
23:34:03 <porges> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
23:34:40 <mreh> cabal is just an architecture then
23:34:44 <mreh> thx
23:39:51 <hackagebot> bencode 0.4 - Parser and printer for bencoded data. (DavidHimmelstrup)
23:42:12 <bos> @src even
23:42:12 <lambdabot> even n = n `rem` 2 == 0
23:47:10 <ivanm> bos: really, you couldn't guess that? ;-)
23:47:40 <mistermatt> whew, I have a lot of syntax to master
23:47:52 <tiri> hi guys i am a just starting to learn programming but i am interested in learning either lisp or haskell--- does anyone use both and can you tell me the advantages of one over the other?
23:48:13 <bos> ivanm: i'm a rank newbie, didn't you know?
23:48:18 <ivanm> heh
23:48:22 <ivanm> tiri: I have used scheme... Haskell's syntax is generally cleaner
23:48:35 <bos> huh?
23:48:37 <ivanm> also, Haskell is much stricter (which is usually a good thing, as it stops you from doing stupid things)
23:48:49 <ivanm> bos: no parentheses everywhere ;-)
23:49:02 <bos> funny definition of "cleaner", that
23:50:05 <ivanm> bos: when I learnt scheme at uni, most people immediately hated it because of the parentheses
23:50:09 <ivanm> without even considering the language
23:51:26 <tiri> i keep hearing about the benefits of macros is there an equivalent or even the need for an eqivalent in haskell?
23:51:42 <ivanm> when a package has "parsec" as a dep, does it mean parsec-2?
23:51:51 <mreh> ivanm, scheme isn't human readable
23:51:53 <ivanm> tiri: not as much
23:52:01 <ivanm> mreh: yes it is, you just have to get used to it
23:52:04 <Veinor> ksf: I like 'every function is an object'
23:52:10 <Veinor> it's cool to play around with in python
23:52:21 <mreh> i think i've touched a raw nerve
23:52:29 <ivanm> mreh: not really
23:52:43 <ivanm> it's just stupid IMHO to automatically dismiss things like that
23:52:53 <Veinor> for that matter in python everything is an object
23:53:09 <Veinor> well, most things are
23:53:12 <porges> tiri: template haskell
23:53:25 <mreh> Veinor: you get nice algebraic properties to play around with when functions are first class
23:54:05 <Veinor> I'm not sure what that means, but cool :D
23:54:10 <mreh> me neither
23:54:19 <Veinor> I got the second half
23:54:59 <ksf> well right now we have every object is an adt
23:56:04 <ksf> ...but one could (just a thought), treat an object as a function that can be passed some other object and results in the combined object.
23:56:11 <ksf> but I guess that's meaningless sugar.
23:56:45 <Veinor> I'm just used to OOP I guess
23:56:51 <ksf> ...and, in fact, every haskell function is an object. you can define methods on (->)
23:57:07 <Veinor> cause I cut my teeth on python
23:57:16 <ksf> it's just that there's no root object
23:57:31 <ksf> ...which, tbh, is a good idea.
23:58:14 <ksf> the utmost thing that every type could sanely satisfy is typeable, but even with that it's good to have explicit class contexts.
23:59:09 <ksf> anyway, the trick is to combine records and type classes.
