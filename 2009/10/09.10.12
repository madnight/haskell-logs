00:32:09 <sinelaw> what's Data.Dynamic for?
00:32:33 <sinelaw> and when should i use it, vs. hlists and existential types?
00:33:30 <ivanm> you shouldn't use hlists at all
00:33:41 <ivanm> and should probably try avoiding Data.Dynamic as well
00:33:52 <ivanm> existential types are probably a no-no as well in most situations
00:34:00 <sinelaw> heh
00:34:02 <aavogt> so that leaves explicit sum types?
00:34:35 <FunctorSalad> <ivanm> you shouldn't use hlists at all  <--- ?
00:34:47 <ivanm> hlists are heterogenous lists, aren't they?
00:34:53 <FunctorSalad> yes
00:34:55 <ivanm> i.e. [1, 'a', Maybe 3], etc.
00:35:08 <ivanm> why would you want to use them?
00:35:18 <ivanm> creating explicit sum types are probably a much better solution
00:35:20 <aavogt> in the same cases where you use records
00:35:35 <Lemmih> More like (1, ('a', (Maybe 3, ()))).
00:35:49 <ivanm> Lemmih: well, syntax aside
00:35:59 <ivanm> aavogt: what do records have to do with it?
00:36:08 <ivanm> records are getter/setter functions for data structures...
00:36:16 <aavogt> ivanm: hlist does some record style things apparently
00:36:21 <sinelaw> What i need to do: create a graph-like structure where each "node" has several ports, and nodes can only connect through ports with matching types. Each node's type is characterized by the ports' types
00:36:24 <Lemmih> ivanm: Some people get disappointed when they realize hlists are just tuples.
00:36:27 <ivanm> aavogt: ahhh
00:36:35 <Veinor> hsakell has hlists?
00:36:35 <sinelaw> and the number of ports per node is unlimited
00:36:41 <ivanm> Lemmih: *shrug* isn't that why lisp can get away with it?
00:36:43 <FunctorSalad> I guess the point is that they come with a library
00:36:45 <ivanm> Veinor: there's a package on hackage
00:36:47 <dolio> HList is really an extensible records system, miraculously implemented using not-that-many extentions to the Haskell type system.
00:36:52 <Veinor> ah.
00:37:00 <FunctorSalad> (for type-level list operations)
00:37:23 <ivanm> sinelaw: so you have clever constructor functions, etc. and use a sum type
00:38:18 <sinelaw> ivanm, but there's an infinity of types in the sum? number/type of ports are unlimited and not known in advance
00:38:41 <ivanm> sinelaw: maybe if you described your problem better...
00:38:48 <sinelaw> if the ports were all the same type, i could use regular lists
00:39:20 <FunctorSalad> anyone want to take a guess why ghc eats all my memory on this program, then dies? http://code.haskell.org/~daniels/Bug2.hs
00:39:38 <FunctorSalad> (the huge functor by itself does compile)
00:39:53 <sinelaw> i need something equivalent to this: data Node as bs = Node as bs, where 'as' and 'bs are heterogenous lists, but i'm shying away from hlists due to warnings (and the fact i don't understand them)
00:39:54 <ivanm> FunctorSalad: I'm hoping that that's auto-generated code...
00:40:06 <FunctorSalad> ivanm: well yes ;)
00:40:17 <ivanm> *phew*
00:40:20 <FunctorSalad> it is about the ghc api but doesn't have anything to do with it
00:40:30 <ivanm> sinelaw: ummmm.... and what does that mean?
00:40:48 <ivanm> FunctorSalad: I'm scared to even look closely at that code...
00:40:51 <FunctorSalad> (it's a multirec instance for the haskell AST)
00:41:13 <FunctorSalad> ivanm: I was hoping someone could tell the performance problem by looking just at the form
00:41:18 <FunctorSalad> not the meaning
00:41:33 <FunctorSalad> (compile-time peformance, i.e. runs out of memory)
00:41:43 <ivanm> FunctorSalad: too many large data structures?
00:42:04 <sinelaw> ivanm, i'm a little new to haskell, so i'll tell you what i did (a while back) in C++: I had these "ports" defined as subclasses of something, and Node had a vector<PortBaseClass * >, and then i used run time type information to make sure you can only connect matching ports (i don't remember exactly how i did it actually)
00:42:09 <ivanm> I haven't looked at memory usage, but when I have very large data structures they take a lot longer to compile...
00:42:14 <Lemmih> FunctorSalad: Those huge type synonyms look scary.
00:42:18 <ivanm> sinelaw: never used C++ ;-)
00:42:24 <dolio> That type is ginormous.
00:42:28 <ivanm> and I still don't follow what you're actually trying to do
00:42:29 <wharrgarble> hello, does anyone know which is the C# room?
00:42:35 <FunctorSalad> Lemmih: the GhcApiPatternFunctor by itself compiles quickly
00:42:40 <sinelaw> wharrgarble, try #mono
00:42:40 <FunctorSalad> must be the to/from stuff
00:42:52 <ivanm> wharrgarble: #csharp ?
00:43:10 <Adamant> wharrgarble++
00:43:14 <dolio> FunctorSalad: Does it compile quickly if you have a function that uses GhcApiPatternFunctor?
00:43:18 <wharrgarble> ivanm: you got it, thanks much.
00:43:25 <ivanm> no worries
00:43:25 <Adamant> just for the name, not the line of questioning :P
00:43:36 <ivanm> Adamant: about to say...
00:43:45 <Adamant> ivanm: ever see that jpg?
00:43:51 <FunctorSalad> dolio: I don't think I could write a manual test case ;)
00:44:00 <ivanm> Adamant: don't think so...
00:44:02 <FunctorSalad> (the pattern functor is for multirec, which needs the other stuff too)
00:44:11 <sinelaw> ok ivanm i'll try to explain the actual problem again. I'm trying to build a library of function-like objects that can be composed by a gui at runtime
00:44:13 <dolio> FunctorSalad: Like 'test :: GhcApiPatternFunctor -> GhcApiPatternFunctor ; test x = x'.
00:44:19 <ivanm> sinelaw: why at runtime?
00:44:28 <FunctorSalad> dolio: will try
00:44:38 <ivanm> sinelaw: and that sounds like something you'd use a class for
00:44:39 <sinelaw> because i want the user to edit code of this language using this gui
00:44:49 <ivanm> so you're making an AST...
00:44:54 <ivanm> use classes and sum types then
00:44:57 <ivanm> *shrug*
00:44:58 <sinelaw> ivanm, in a way, yes. more like a DAG
00:45:06 <FunctorSalad> (FWIW the PatternFunctor is essentially the Haskell AST translated to sum-of-products form with explicit recursion)
00:45:30 <sinelaw> how do classes help me here?
00:45:31 <FunctorSalad> sum of (sum-of-products for each type in the family), actually
00:45:34 <Adamant> ivanm: http://ihasahotdog.files.wordpress.com/2008/01/funny-dog-pictures-loldogs-wharrgarbl.jpg
00:45:59 <ivanm> sinelaw: by providing polymorphism for choosing stuff at "run-time"
00:46:06 <ivanm> Adamant: heh
00:46:36 <Adamant> ivanm: cat person, eh :P
00:46:46 <ivanm> Adamant: computer person :p
00:46:53 <Adamant> fair enough :P
00:46:53 <ivanm> well, right now, dinner person...
00:46:57 <_Ray_> damn...installing hat is impossible...
00:49:08 <dolio> FunctorSalad: I mean, you can start doing 'f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1' and it starts getting noticeable at f4.
00:49:33 <dolio> > 2^8
00:49:34 <lambdabot>   256
00:49:42 <dolio> Your type might be bigger than f4.
00:49:55 <dolio> f5 makes my computer start swapping.
00:50:03 <FunctorSalad> dolio: how is composition related to it?
00:51:08 <dolio> The size of the resulting type gets squared at each iteration.
00:51:37 <dolio> I think that's right.
00:52:41 <FunctorSalad> dolio: tried "test x = x", works
00:52:48 <dolio> I guess that's not it, then.
00:53:25 <FunctorSalad> maybe it's the "instance Fam GhcApiFamily"?
00:53:50 <FunctorSalad> which translates from/to: ghc-api types <--> PatternFunctor
00:54:34 <dolio> > 2^(2^4)
00:54:35 <lambdabot>   65536
00:55:00 <dolio> That's f4, I guess. Not 256.
00:55:11 <dolio> > 2^(2^5)
00:55:12 <lambdabot>   4294967296
00:55:17 <FunctorSalad> why squared at each step?
00:55:44 <dolio> You take each x in the resulting tuple and replace it with the whole tuple.
00:55:58 <FunctorSalad> @let f0 x = (x,x)
00:55:59 <lambdabot>  Defined.
00:56:04 <FunctorSalad> @let f1 = f0 . f0
00:56:04 <lambdabot>  Defined.
00:56:06 <FunctorSalad> @type f1
00:56:07 <lambdabot> forall t. t -> ((t, t), (t, t))
00:56:13 <FunctorSalad> @type f1.f1
00:56:13 <lambdabot> forall t. t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
00:56:25 <FunctorSalad> :)
00:58:24 <FunctorSalad> oh well maybe multirec isn't the tool for the job
00:58:35 <FunctorSalad> it seems nicer than syb in that it doesn't do any casts though
00:58:57 <FunctorSalad> and defining a generic function is quite straightforward (induction on the pattern functor)
00:59:36 <dolio> In your test case, did you have all the small instances?
00:59:55 <dolio> I seem to recall dons & co. having trouble with ballooning numbers of instances with their adaptive containers.
01:00:29 <FunctorSalad> yes, I just cut out everything after the PF
01:00:42 <FunctorSalad> maybe "test x = x" isn't enough to "Inspect" the PF though
01:05:13 <pozic> FunctorSalad: using multirec is much fun, isn't it?
01:06:17 <FunctorSalad> pozic: I find the basic idea quite elegant
01:06:24 <FunctorSalad> but not sure it's appropriate for such huge families now...
01:06:48 <pozic> FunctorSalad: yes, elegant, but not integrated in the language.
01:09:00 <dreixel> FunctorSalad: how big is the family?
01:09:19 <FunctorSalad> dreixel: http://code.haskell.org/~daniels/Bug2.hs
01:10:05 <dreixel> ahm.
01:10:12 <dreixel> this doesn't work, right?
01:10:29 <FunctorSalad> dreixel: ghc runs out of memory
01:11:22 <pozic> FunctorSalad: there is nothing there
01:11:47 <dreixel> FunctorSalad: are you using a balanced encoding of sums, or is it right-nested? it's not easy to see this from the code :p
01:12:00 <FunctorSalad> dreixel: right-nested
01:12:16 <dreixel> is this the code generated from the TH code that comes with multirec?
01:13:28 <FunctorSalad> dreixel: I had to rewrite that code to deal with arbitrary kind-* types like (HsExpr A), rather than just names
01:13:58 <FunctorSalad> (and to drop the requirement that proof name = type name)
01:14:30 <dreixel> I see
01:14:46 <dreixel> well, you could try using a balanced view...
01:15:03 <dreixel> the file opens here on ghci, but I'm assuming it runs out of memory when you try to do "something real", right?
01:15:32 <FunctorSalad> dreixel: doesn't load in ghci here
01:15:40 <FunctorSalad> (6.10.4?)
01:15:52 <dreixel> yeah, 6.10.4
01:16:01 <dreixel> loading was no problem.
01:16:16 <dreixel> ah, no, wait, sorry.
01:16:39 <dreixel> it doesn't load.
01:17:12 <dreixel> I would try a balanced encoding... but this could just be a sign that GHC isn't optimized to work with such long types
01:17:38 <FunctorSalad> *nod*
01:31:04 <pozic> Is there a way to start the debugger when I press C-c C-c to see which code it was executing?
01:33:44 <sinelaw> ivanm, when you're back to being computer man, can you explain how to use classes to dynamically build that AST?
01:45:12 <ivanm> sinelaw: no idea ;-)
01:45:23 <ivanm> I've never done something like that
01:45:52 <sinelaw> ivanm, heh, i'm only asking you because that's what you suggested as a solution to my problem earlier
01:46:13 <ivanm> sinelaw: I also don't have that much of an understanding of what you're doing
01:46:51 <Saizan> FunctorSalad: congrats, that's the longest type declaration i've ever seen :)
01:47:49 <ivanm> Saizan: so we're now going to have a competition?
01:47:58 <ivanm> ;-)
01:48:57 <sinelaw> what's so bad about HList?
01:49:28 <ivanm> IIUC, it's there as an example of what _not_ to do
01:50:10 <c_wraith> @hoogle RandomGen g => [a] -> g -> ([a], g)
01:50:11 <lambdabot> No results found
01:50:25 <c_wraith> @hoogle RandomGen g => g -> [a] -> ([a], g)
01:50:26 <lambdabot> No results found
01:50:35 <c_wraith> @hoogle shuffle
01:50:36 <lambdabot> No results found
01:50:38 <c_wraith> huh
01:50:48 <c_wraith> You wouldn't think I'd be the first person to want that.
01:50:54 <ivanm> c_wraith: there's a shuffle package on hackage
01:54:23 <ksf> ...I don't suppose cabal-install works with 6.12, yet?
01:54:37 <ivanm> ksf: as in to compile it with 6.12?
01:54:42 <ivanm> or just to use it?
01:54:53 <ksf> well 6.12 comes with cabal 1.8
01:54:56 <ivanm> I think either would work; there's no new base package, etc.
01:54:58 <ivanm> ksf: oh, yeah
01:55:07 <ksf> ...and the current cabal-install on hackage has a <1.7 restraint
01:55:09 <ivanm> well, if you have cabal-install already installed, then you have nothing to worry about anyway
01:55:14 <dcoutts> ksf: right, I've not updated it yet
01:55:16 <ivanm> thanks to the magic of static linking
01:55:17 <ivanm> ;-)
01:55:26 <ksf> ...well, it doesn't work.
01:55:35 <pozic> FunctorSalad: now I have seen it, I agree with Saizan.
01:55:37 <Saizan> ivanm: apart from incompatible changes in ghc
01:55:38 <ksf> the output format of ghc-pkg seems to have changed
01:55:44 <dcoutts> ivanm: Cabal-1.6 doesn't grok ghc-6.12's new ghc-pkg dump output
01:56:04 <ivanm> Saizan: for packages that use the ghc-api you mean?
01:56:05 <ksf> also, I'd like to use shared libs, and old cabal-install won't grok those flags
01:56:11 <ksf> (hopefully the new one does)
01:56:14 <ivanm> dcoutts: oh :(
01:56:32 <pozic> Do dynamic libraries work on Windows and Linux already?
01:56:44 <ksf> on linux, partly on windoze.
01:57:01 <pozic> What do you mean by partly?
01:57:02 <ksf> ...that is, you can do dlls, but not have your packages be dlls.
01:57:12 <ivanm> ksf: I'm not a fan of microsoft either, but you do realise that calling it "windoze" just makes you look childish and immature?
01:57:19 <ivanm> s/you do/do you/
01:57:39 <ksf> too late to break that habit.
01:57:51 <pozic> I think people can call Windows whatever they like.
01:57:54 <ivanm> not really.... I used to do the same
01:57:55 <c_wraith> argh.
01:58:04 <ivanm> c_wraith: what?
01:58:08 <c_wraith> The random shuffle package is pretty bad.
01:58:13 <ivanm> in what way?
01:58:18 <c_wraith> It doesn't return the randomgen after its modification
01:58:36 <c_wraith> well, it doesn't return the new one at the end.
01:58:52 <Saizan> split it before
01:58:52 <ivanm> c_wraith: here, I'll give you my version that does
01:58:55 <Saizan> ?type split
01:58:57 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
01:58:59 <c_wraith> I already wrote one
01:59:02 <ivanm> Saizan: haven't you seen the bug about split?
01:59:05 <c_wraith> It's just O(n^2)
01:59:19 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10632#a10632
01:59:27 <pozic> c_wraith: Oleg wrote a n log n shuffle, but O(n) should also be possible.
01:59:46 <Saizan> O(n) is possible only with mutation, afaiu
01:59:49 <ivanm> pozic: it should?
01:59:50 <pozic> IMHO, anything above O(n) should not be in a public library.
01:59:54 <ivanm> Saizan: yeah, that's what I thought
02:00:14 <Saizan> maybe we could use ST here
02:00:34 <ivanm> hmmm...
02:00:42 <ivanm> Saizan: it'd need an array though rather than a list, won't it?
02:00:43 <c_wraith> Admittedly, I'm just shuffling decks of cards.
02:00:56 <c_wraith> O(n^2) doesn't kill me
02:01:00 <Saizan> flushing the list into an array and back should still be O(n)
02:01:02 <ivanm> c_wraith: and you need your computer to do that for you _why_?
02:01:06 <ivanm> Saizan: true
02:01:13 <quicksilver> FunctorSalad: worth a bug report IMO
02:01:30 <c_wraith> ivanm:  There are many card games.  Helps to have some randomization.
02:01:54 <ivanm> anyway, the haskell reddit has a link to the bug report on why split is bad
02:02:03 <ivanm> as it doesnt' actually result in random goodness
02:06:28 <c_wraith> Is that because states get reused if you split it and aren't very careful how you use them?
02:07:50 <ivanm> nope
02:07:58 <ivanm> the actual way they split it isn't that good apparently
02:08:02 <c_wraith> Oh.
02:08:13 <ivanm> though part of the problem is too much usage of split rather than randoms, etc.
02:08:24 <ivanm> http://hackage.haskell.org/trac/ghc/ticket/3575
02:08:29 <c_wraith> Also, that implementation appears to be O(n lg n) ?
02:08:45 <ivanm> c_wraith: which one?
02:08:55 <c_wraith> The one you provided.
02:09:03 <c_wraith> It's structurally a mergesort.
02:09:11 <ivanm> nope, it'd be O(n^2) AFAIK
02:09:18 <dolio> Oh man, finally tuple sections.
02:09:27 <ivanm> dolio: so you can die happy now? :p
02:09:41 <dolio> I can live happy, at least. :)
02:10:01 <dolio> Sectioning tuples all over the place.
02:10:48 <ivanm> I admit I don't mind something like ((,) foo), but (flip (,) foo) is a right royal PITA
02:11:19 <dolio> Ooo, GADT records, too.
02:11:52 <Twey> I like (flip (,) foo) better than ((,) foo)
02:12:05 <Twey> Something in me protests at the apparently-redundant bracketing
02:12:07 <ivanm> Twey: :o
02:12:14 <ivanm> Twey: well, for when you're doing a map
02:12:23 <Twey> Aye
02:12:28 <ivanm> "map (,) foo as" doesn't really typecheck too well ;-)
02:12:32 <Saizan> Twey: same for ((-) 1) then?
02:12:32 <Twey> Heh.
02:12:38 <Twey> 's just the syntax.
02:12:44 <c_wraith> my own O(n^2) implementation, is probably somewhat abusive:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10633#a10633
02:12:45 <Twey> Saizan: I don't use - in sections.  Ever.
02:12:51 <c_wraith> If for nothing else, because of the lack of comments.
02:13:40 <c_wraith> > map (5 -) [1..10]
02:13:41 <lambdabot>   [4,3,2,1,0,-1,-2,-3,-4,-5]
02:14:13 * Twey considers the current behaviour of - horribly broken.
02:14:51 <ivanm> Twey: what would you do? make it part of the number?
02:14:58 <Saizan> i'd use Data.Sequence for a O(n log n) sort, probably
02:15:01 <ivanm> in which case -a won't be the same as negate a
02:15:23 <Twey> ivanm: That's fine with me
02:15:36 <Twey> Or at least vastly preferable
02:15:50 <ivanm> *shrug* I don't really have a problem with it
02:15:56 <ivanm> because I don't use it ;-)
02:15:58 <Twey> Although, you could expand -a to negate a
02:16:04 <Twey> Heh.
02:16:12 <ivanm> Twey: but still, (-5) isn't a valid section still
02:16:20 <ivanm> which means people will still be pissed off
02:16:25 <Saizan> ivanm: but (- 5) would
02:16:46 <ivanm> Saizan: aren't sections normally done without spaces?
02:17:13 <Saizan> i'd require spaces between identifiers and operators everywhere
02:17:38 <Saizan> so we could use agda's mixfix "operators"
02:18:13 <Twey> Aye, that's my preferred solution
02:18:39 <dolio> I'm going to have to update all my packages to add NoNPlusKPatterns. :)
02:19:39 <opqdonut> hehe
02:19:53 <Twey> Also, I want more complex sections, like (`flip (flip `bar`)` x)
02:20:00 <Twey> And a pony.
02:20:19 <ivanm> dolio: why?
02:20:30 <ivanm> Twey: get the pony package on hackage then ;-)
02:20:35 <Twey> Heheh.
02:20:47 <Twey> Saizan: What would you do about mixfix sections?
02:20:52 <Saizan> and you'll be given an unicorn :\
02:21:04 <Twey> A unicorn?  Of my very own?
02:21:12 <dolio> ivanm: To build evidence for use against Richard O'Keefe in an argument where he contends that n+k patterns should be kept around.
02:21:23 <Twey> Hahaha, nice.
02:21:29 <Twey> dolio: xD
02:21:31 <Saizan> Twey: that's a good question
02:21:40 <ivanm> dolio: ahhh
02:21:52 <ivanm> I thought the problem with n+k patterns is that they're inefficient...
02:22:52 <Twey> Saizan: A friend of mine suggested using something like #<number>
02:22:53 <dolio> The bigger problem (if you ask me) is that they're semantically kind of weird.
02:23:21 <Twey> So (foo #2 bar #1) is a mixfix section of two arguments
02:24:00 <Saizan> how would that translate to a lambda?
02:24:09 <dolio> Because a match of 'm' against 'n + k' means that n = fromInteger . (-k) . toInteger $ m, if m >= k, or something like that.
02:24:15 <Twey> Saizan: \one two -> foo two bar one
02:25:21 <Twey> dolio: Well… the result is certainly weird, but I'd argue that the weirdness is more to do with the integers than the patterns…
02:26:31 <Saizan> well, it's like being able to use ++ in list patterns
02:26:44 <ivanm> you can do that? :o
02:26:49 <Twey> ivanm: No :þ
02:26:53 <ivanm> *phew*
02:27:05 <ivanm> because + is the only non-constructor allowed in patterns?
02:27:11 <ivanm> well, non-constructor function
02:27:16 <Saizan> a prefix view would be nice, though.
02:27:20 <Twey> Yeah… more weirdness
02:27:23 <Twey> Saizan: *nod*
02:27:31 <Twey> Well
02:27:47 <Twey> View patterns pretty much obsolete all this anyway
02:28:05 <ivanm> _if_ they become part of haskell' ?
02:28:27 <Twey> Is there seriously opposition to that?
02:29:38 <ivanm> Twey: no idea; my point was that you can't say that it makes everything else obsolete until it is actually part of the standard
02:30:22 <Twey> Okay, s/obsolete/would obsolete/
02:31:01 <ivanm> right
02:34:50 <Twey> Hmn
02:35:13 <Twey> @hoogle k -> Map k a -> (a, Map k a)
02:35:13 <lambdabot> Data.Map mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
02:35:14 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
02:35:33 <Twey> @hoogle k -> Map k a -> (Maybe a, Map k a)
02:35:34 <lambdabot> Data.Map updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
02:35:34 <lambdabot> Data.Map insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
02:37:13 <pozic> What I absolutely hate about ghci/ghc is that when you have introduced an infinite loop, it is not possible to easily track it down.
02:37:46 <Twey> Debug.Trace helps
02:37:59 <Twey> There's that step-by-step debugger, too
02:38:02 <Twey> What was it called?  Hat?
02:38:20 <dolio> There's one built in to ghci now.
02:38:20 <sinelaw> what's the syntax for multiple constraints?
02:38:34 <pozic> Twey: I use some stuff I wrote myself based on Debug.Trace, but you have to basically start from the start from the program to find it.
02:38:36 <dolio> (C1 a, C2 b, ...) =>
02:38:37 <sinelaw> f :: Ord a, Show b => a -> b -> c?
02:38:42 <sinelaw> dolio, thanks
02:38:48 <pozic> Twey: binary searching the program is rather hard.
02:38:50 <dolio> Needs parens.
02:39:05 <pozic> Twey: and Hat is not maintained.
02:39:25 <Twey> 10:39:17 < dolio> There's one built in to ghci now.
02:40:00 <pozic> Twey: yes, and it is useless.
02:40:10 <Twey> Oh?
02:40:19 <pozic> Twey: I probably used it more than most people in this channel.
02:40:34 <Twey> My.
02:40:42 <pozic> It is on the level of "a first hack", not a real debugger.
02:41:03 <ilid> has the ghci debugger been improved in 6.12?
02:42:22 <pozic> I don't know. Probably, not.
02:45:23 <Twey>     fromMaybe (return ()) $ modifyMVar (return . (\(a, b) -> (b, a)) $ M.updateLookupWithKey (\_ _ -> Nothing)) pending
02:45:28 * Twey eyes this dubiously.
02:46:02 <Twey> Any cleanup tips?
02:46:06 <pozic> swap?
02:46:07 <Twey> Asides from adding in the key :þ
02:46:11 <Twey> :t swap
02:46:12 <lambdabot> Not in scope: `swap'
02:46:14 <pozic> const2
02:46:19 <ivanm> @hoogle updateLookupWithKey
02:46:19 <lambdabot> Data.IntMap updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
02:46:19 <lambdabot> Data.Map updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
02:46:21 <Twey> :t const2
02:46:22 <lambdabot> Not in scope: `const2'
02:46:26 <ivanm> @pl \ a b -> Nothing
02:46:26 <lambdabot> const (const Nothing)
02:46:30 <Twey> @index const2
02:46:31 <lambdabot> bzzt
02:46:34 <Twey> @index swap
02:46:34 <lambdabot> bzzt
02:46:40 <ivanm> @type const . const Nothing
02:46:40 * Twey shrugs.
02:46:41 <lambdabot> forall b a b1. b1 -> b -> Maybe a
02:46:44 <ivanm> Twey: ^^
02:46:48 <pozic> Twey: swap does the obvious thing
02:46:48 <ivanm> *shrug*
02:46:59 <Twey> pozic: Yeah… but it's not pre-defined?
02:47:00 <ivanm> pozic: and it really should be in the prelude...
02:47:07 <ivanm> @pl \(a,b) -> (b,a)
02:47:08 <lambdabot> uncurry (flip (,))
02:47:09 <pozic> Twey: no
02:47:20 <Twey> Oh, you're just suggesting that I extract it from my line?  Good idea
02:47:22 <pozic> ivanm: it is in my Util library. I think everyone has it.
02:47:36 <ivanm> pozic: agreed, but we shouldn't need to re-implement it all the time
02:47:42 <Saizan_> ?type snd *** fst
02:47:43 <lambdabot> forall a c a1 b. ((a, c), (a1, b)) -> (c, a1)
02:47:45 <pozic> ivanm: I agree with that too.
02:47:58 <pozic> ivanm: but communicating these things takes longer than defining it.
02:48:00 <ilid> @type mempty :: Monoid c => a -> b -> Maybe c
02:48:01 <lambdabot> forall a b c. (Monoid c) => a -> b -> Maybe c
02:48:03 <ilid> > mempty 1 2 :: Maybe ()
02:48:04 <lambdabot>   Nothing
02:48:07 <Twey> :t snd &&& fst
02:48:08 <ivanm> pozic: heh
02:48:08 <lambdabot> forall a c. (a, c) -> (c, a)
02:48:17 <ivanm> Twey: oohhhh..... nice!
02:48:23 <Saizan_> Twey: yeah, oops
02:48:25 <pozic> ivanm: people publishing their Util libraries could work as a start on hackage.
02:48:29 <Twey> ☺
02:48:29 <pozic> ivanm: some already did.
02:49:04 <pozic> Another idiom I use is <foo>M.
02:49:15 <pozic> Which is basically liftM foo.
02:49:35 <ilid> pozic: not fooA ? :(
02:49:57 <pozic> ilid: You are right, there is no need for that.
02:50:27 <pozic> ilid: I never consciously think I need an applicative.
02:50:43 <pozic> ilid: and as long as I can implement everything I want, why bother?>
02:55:29 * pozic doesn't like idioms, though. It would be better to generate code instead of typing it by hand.
02:59:08 <pozic> Which Color Theme (Emacs) are you using for Haskell?
03:01:51 <mdiin> I believe I use the default theme - haven't changed it anyway
03:03:18 <Twey> I use the default on the console and ZenBurn on X11.
03:04:31 <c_wraith> Are there any haskell idioms for locating configuration/data files for an app?
03:05:02 <Saizan_> for data files there's cabal support
03:05:52 <c_wraith> I don't think that's what I'm looking for, but I'm curious to know more about it anyway.
03:06:01 <pozic> I switched to http://b.pengdeng.com/2008/11/my-emacs-color-theme.html . I will see whether I like it more than the default white one.
03:06:22 <Twey> Ooh.
03:06:31 <Twey> I just used ‘join’ in a real application for the first time.
03:06:43 <Saizan_> c_wraith: check the Cabal manual on the site
03:07:20 <pozic> Twey: what are you building?
03:07:56 <Twey> A DBus binding
03:08:21 <Twey> (this being a yak-shaving exercise for an app that actually uses DBus)
03:08:52 <SmurfOR> pozic, light text on black is the way to go
03:10:02 <c_wraith> Ah.  That looks useful, but it's not what I need here.
03:10:42 <pozic> SmurfOR: then http://b.pengdeng.com/2008/11/my-emacs-color-theme.html should be fine, no?
03:11:01 <pozic> Twey: I meant the application.
03:11:32 <Saizan_> c_wraith: i think that it makes more sense to follow platform conventions rather than language ones when we're talking about applications
03:12:00 <Twey> The application is an IRC bot
03:12:37 <c_wraith> platform conventions on linux are something of a mess, sadly.  The main one is "compile the data file location in during the ./configure step"
03:13:05 <Twey> It was meant to be a tiny project using sockets and line-based communication, and then I discovered DBus and it all went (down|up)-hill from there
03:13:58 <quicksilver> crosshill
03:14:04 <Twey> Several months later, I find myself with some free time and an acceptably complete, if low-level, DBus binding (dbus-core)
03:14:07 <Twey> Haha
03:14:33 <sinelaw> i'm really stuck here trying to re-model my C++ program in Haskell...
03:15:10 <quicksilver> or maybe 'wronghill'
03:15:17 <Twey> sinelaw: I think it's generally best to start from scratch…
03:15:22 <quicksilver> still, live for the journey, right?
03:15:28 <sinelaw> Twey, i don't know how to solve this in haskell
03:15:28 <Twey> Heheh.
03:15:36 <Twey> sinelaw: What's the problem?
03:15:56 <pozic> sinelaw: implement C++ interpeter in Haskell and you are done. - Simple -.
03:16:01 <Twey> Haha.
03:16:08 <sinelaw> I want to model a structure of elements that pass data between them, a data stream graph
03:16:16 <sinelaw> that the user can edit in runtime
03:17:10 <Twey> Well, sounds like a job for Control.Concurrent
03:17:12 <sinelaw> if a->b , the output type of 'a' must match the input type of 'b', and elements may have many inputs/outputs
03:17:28 <Twey> See also ‘Eros’
03:17:40 <Twey> Not quite the same as what you're doing, but you might be able to get some ideas from it
03:17:44 <sinelaw> Twey, you are talking about the operational model, i'm interested in how to model the data structure
03:18:05 <Twey> Hm
03:18:21 <Twey> Isn't it just a sort of graph?
03:18:30 <sinelaw> Eros looks interesting though.
03:18:50 <sinelaw> Twey, yes, it is a sort of graph, but with heterogeneous types
03:18:59 <pozic> sinelaw: If you first write down _exactly_ what you want, then you can probably solve it much quicker.
03:19:54 <sinelaw> pozic, i pretty much know what i want. a "graph" of heterogeneous nodes where each nodes type is determined by the number and types of its input and outputs
03:20:06 <pozic> sinelaw: for example, do you want an acyclic graph?
03:20:13 <Twey> data Element a b = Element a b; data Connection a b = Connection (Element a b) (Element b a); data Graph = [Connection]
03:20:18 <sinelaw> pozic, yes, a DAG
03:20:26 <Twey> Oh, it's directional
03:20:28 <Twey> Hm
03:20:55 <sinelaw> Twey, the directionality is in whether the connection is from/to the input/output port
03:20:58 <pozic> Twey: that won't work.
03:21:12 <pozic> Twey: all the connections would have the same type.
03:21:30 <pozic> sinelaw: you need to use some kind of rank n polymorphism for this. Have fun.
03:21:30 <Twey> Oh, yeah.  :-\
03:21:35 <Twey> Yeah, I think so.
03:21:44 <Twey> Existential types, I guess.
03:21:56 <pozic> Yes, same thing.
03:22:04 <sinelaw> pozic, yeah i've been playing with those and also HLists
03:22:23 <Twey> I thought that existential types were an application of rank-n polymorphism?
03:22:32 <pozic> Twey: yes, you can implement them with rank-2.
03:22:45 <Twey> *nod*
03:24:05 <sinelaw> Conal's DataDriven seems relevant: http://www.haskell.org/haskellwiki/DataDriven
03:24:54 <sinelaw> that's funny. I started this whole thing as an alternative approach than Reactive.
03:24:57 <pozic> Hmm, I never use this syntax, but should case foo of Bar{} -> | bool = True work?
03:25:05 <pozic> shouldn't*
03:25:08 <sinelaw> And the first line of that page says:
03:25:11 <sinelaw> "I recommend Reactive rather than DataDriven"
03:25:13 <sinelaw> :)
03:27:31 <dolio> You need to put the guard before the ->
03:27:51 <dolio> And no =
03:29:26 <sinelaw> sigh, DataDriven is not what i want.
03:30:19 <pozic> dolio: so case foo of | bool -> if foo == Bar{} then True .. ? That seems inconvenient.
03:31:05 <dolio> No, 'case foo of Bar{} | bool -> True'
03:33:00 <pozic> Ok, thanks.
03:50:16 <FunctorSalad> sorry I was afk
03:56:10 <ivanm> what is an "unlifted type"? Int#, etc.?
03:57:36 <ivanm> "The flag +RTS -N now automatically determines how many threads to use, based on the number of CPUs in your machine." \o/
03:58:19 <byorgey> ivanm: a "lifted type" is one that has bottom as an element.
03:58:31 <ivanm> byorgey: right... so which ones don't?
03:58:40 <FunctorSalad> ivanm: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType#Classifyingtypes
03:58:49 <ivanm> byorgey: oh, and with you taking over TMR... are you planning on dumping it for HCAR in a couple of years? :p
03:59:26 <ivanm> OK, so datatypes with a # aren't lifted because they're memory-based, etc.?
03:59:47 <byorgey> ivanm: heh, no, I'm not planning on it...
03:59:48 <pozic> I want to use the FFI to send a list to C. What's the easiest way to do that?
04:00:10 <pozic> It's basically a list of Stuff containing a few alternatives.
04:00:19 <Axman6> pozic: sec
04:00:29 <ivanm> ooohhhh..... ghc-pkg dot sounds cool! :D
04:00:47 * ivanm might have to do a prettified wrapper around it using graphviz to add pretty colours, etc. ... >_>
04:01:27 <pozic> ivanm: I saw the output from your tool. Impressive (Quake 3 voice)
04:01:31 <Axman6> pozic: http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
04:01:35 <ivanm> pozic: heh
04:01:37 <ivanm> thanks!
04:02:01 <eevar2> ^^ i hope the threadcount is #cpus * 2 or something along those lines
04:02:01 <pozic> ivanm: I haven't _used_ it, though.
04:02:11 <ivanm> heh
04:02:26 <ivanm> pozic: well, apparently the darcs source is too big for dot to handle... :s
04:04:38 <ivanm> what does the ghc user guide mean by packedstring no longer being a boot package?
04:04:42 <ivanm> it no longer comes with ghc?
04:05:39 <byorgey> I... think so
04:05:56 <byorgey> IIRC packedstring is obsolete and no longer needed
04:06:08 <byorgey> it was just being used in some TH-related something, but has now been removed.
04:06:15 <ivanm> *nod*
04:06:28 <ivanm> OK, with the new build system, does that make a difference for people actually building GHC?
04:06:43 * byorgey downloads ghc 6.12.1rc1!
04:06:53 <pozic> Axman6: I think I need foreign export to do that, which is not used there.
04:06:59 <ivanm> a quick glance makes it look the same...
04:07:05 <byorgey> ivanm: I think it mostly makes a difference if you are doing GHC development.
04:07:10 <ivanm> *nod*
04:07:21 <ivanm> good-o, we don't have to change the ebuilds then! \o/
04:07:22 <pozic> Axman6: I want to be able to call Haskell from C.
04:07:30 <Axman6> oh, sorry
04:07:35 <byorgey> ivanm: well, don't take my word for it, but hopefully not =)
04:07:38 <ivanm> heh
04:08:02 <ivanm> Axman6: would you know any good sites for buying property, etc. in canberra?
04:08:21 <Axman6> not really :\
04:08:44 <ivanm> I've tried google, and got the stock standard realty companies :s
04:08:45 <FunctorSalad> haha it actually errors out after 10 min: Bug2.hs:2186:36:
04:08:45 <FunctorSalad>     GADT pattern match in non-rigid context for `Tag'
04:08:53 <ivanm> FunctorSalad: heh
04:09:03 <FunctorSalad> (ghc doesn't seem to outofmemory as opposed to ghci)
04:10:27 <FunctorSalad> so the prob is in the typechecker?
04:14:53 <FunctorSalad> how can a typeclass method instance fail to be in a rigid context? D:
04:15:52 <dolio> What's the type look like?
04:16:00 <FunctorSalad> oh must be because 'Tag' is enclosed in a constructor of a polymorphic type (:+:)
04:16:14 <FunctorSalad> dolio: this line:           to (Prf_Maybe_Fixity) (L (Tag (L (C (U))))) = Nothing
04:19:00 <FunctorSalad> weird, presumably the original multirec deriver should produce valid code
04:19:05 <FunctorSalad> and I don't think I broke it ;)
04:21:16 <FunctorSalad> or maybe my generalization did break the context rigidity somehow
04:21:47 <byorgey> uh-oh, cabal install fails with "failed to parse output of 'ghc-pkg dump'"
04:22:07 <Raynes> Oh noes.
04:23:29 <byorgey> preflex: seen dcoutts
04:23:30 <preflex>  dcoutts was last seen on #haskell 2 hours, 27 minutes and 45 seconds ago, saying: ivanm: Cabal-1.6 doesn't grok ghc-6.12's new ghc-pkg dump output
04:23:37 <byorgey> hahaha
04:23:45 <dcoutts> :-)
04:24:03 <byorgey> but I have cabal-install 0.7 using Cabal-1.7.3
04:24:25 <byorgey> dcoutts: also, did you see my cabal init patch?
04:25:00 <dcoutts> byorgey: I've not looked yet
04:25:12 <byorgey> ok, no rush =)
04:25:15 <dcoutts> byorgey: that Cabal version is too old
04:25:38 <dcoutts> byorgey: too old to grok the ghc-6.12 ghc-pkg output anyway
04:25:50 <byorgey> dcoutts: also also, does the cabal-install HEAD build with the Cabal HEAD yet?
04:26:01 <byorgey> I think that's why my version of Cabal is too old
04:26:01 <dcoutts> byorgey: no, that's the main issue
04:26:07 <dcoutts> right
04:27:17 <byorgey> so there is no version of cabal-install in the world that can grok ghc-6.12's new ghc-pkg dump output?
04:28:22 <dcoutts> byorgey: correct
04:28:40 <byorgey> heh, ok =)
04:34:27 <ivanm> byorgey: so you got both answers you wanted from preflex? :p
04:35:56 <FunctorSalad> how about adding an option to ghc-pkg: --old-dump
04:36:20 <FunctorSalad> and Cabal would just add that option when the plain call do ghc-pkg dump fails
04:36:41 <ivanm> FunctorSalad: it sounds like they've completely re-written their package.conf system
04:36:48 <ivanm> so --old-dump mightn't be that easy to implement
04:36:53 <dcoutts> FunctorSalad: that's not the problem
04:37:04 <dcoutts> Cabal-1.8 understands ghc-pkg dump
04:38:13 <ivanm> dcoutts: so when can we expect a compatible cabal-install?
04:38:49 <dcoutts> ivanm: whenever I or someone else does the work
04:38:59 <ivanm> heh
04:39:37 * dcoutts has a deadline this coming Friday
04:40:08 <ivanm> well, get to it!
05:26:55 <trzkril> @pl \c f -> f <$ choice . map string $ c
05:26:55 <lambdabot> flip (<$ choice . map string)
05:27:11 <trzkril> @pl \f c -> f <$ choice . map string $ c
05:27:11 <lambdabot> (<$ choice . map string)
05:28:52 <ivanm> preflex: seen shapr
05:28:53 <preflex>  shapr was last seen on #haskell-blah 6 days, 13 hours, 34 minutes and 30 seconds ago, saying: Gonna move in the next day or two.
05:29:29 <trzkril> @pl \f c -> g (f <$ choice . map string $ c)
05:29:29 <lambdabot> (g .) . (<$ choice . map string)
05:29:37 <trzkril> @pl \f c -> g (f <$ choice . map string $ c) b
05:29:37 <lambdabot> flip flip b . (g .) . (<$ choice . map string)
05:37:01 <ilid> @type (<$ ?choice . map ?string $ ?c)
05:37:02 <lambdabot>     The operator `<$' [infixl 4] of a section
05:37:02 <lambdabot>         must have lower precedence than that of the operand,
05:37:02 <lambdabot>           namely `$' [infixr 0]
05:37:16 <ilid> @type (<$ ?choice . map ?string)
05:37:17 <lambdabot> forall a b a1 b1. (?choice::[b1] -> b, ?string::a1 -> b1) => a -> [a1] -> a
05:39:24 <ivanm> @ask shapr any chance of you updating your FermatsLastMargin program, since happs is replaced with happstack?
05:39:24 <lambdabot> Consider it noted.
05:41:13 <hackagebot> ghc-events 0.1 - Library and tool for parsing .eventlog files from GHC (SimonMarlow)
05:41:48 <ivanm> I take it that that's for RC users to test?
05:48:20 <stanv_> @src (++)
05:48:21 <lambdabot> []     ++ ys = ys
05:48:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:48:21 <lambdabot> -- OR
05:48:21 <lambdabot> xs ++ ys = foldr (:) ys xs
05:52:27 <kosmic> this doesn't  seem to work, wh http://pastie.org/private/c9frmnbe89ja3ypvqhzmhq
05:52:29 <kosmic> why?
05:53:26 <Axman6> "doesn't seem to work" you need to explain what you mean
05:53:28 <ivanm> kosmic: error message?
05:53:33 <kosmic> right.
05:53:39 <ivanm> that looks right, as long as n >= 0
05:53:40 <kosmic> lol.hs:1:0: The function `main' is not defined in module `Main'
05:53:50 <kosmic> hm
05:53:51 <ivanm> kosmic: oh, it's not a stand-alone program as it is
05:53:53 <Axman6> kosmic: what were you trying to do?
05:54:05 <kosmic> trying to get it to spit out numbers
05:54:10 <Axman6> how
05:54:11 <ivanm> and pastie doesn't seem to have a "modify" option...
05:54:31 <kosmic> if you are up for it you can copy and repase it
05:54:33 <Axman6> pastie--
05:54:37 <kosmic> ;(
05:54:47 <Axman6> kosmic: what did you run to produce that error
05:54:57 <ivanm> @type getArgs
05:54:58 <lambdabot> Not in scope: `getArgs'
05:55:02 <ivanm> @hoogle getArgs
05:55:02 <lambdabot> System.Environment getArgs :: IO [String]
05:55:05 <kosmic> axman6, ghc thepaste.hs
05:55:25 <Axman6> well, that's not going to work is it. you don't have a program yet ;)
05:55:34 <Axman6> try ghci lol.hs
05:55:40 <kosmic> heh
05:55:41 <kosmic> ok
05:55:43 <Axman6> then run fib 10
05:55:51 <kosmic> hm it wors
05:55:53 <Axman6> should work fine
05:55:55 <kosmic> works. how odd
05:55:55 <Axman6> yes
05:55:57 <kosmic> thanks thoguh.
05:55:58 <kosmic> ;)
05:56:05 <Axman6> well, no, it's not odd at all :P
05:56:25 <ivanm> kosmic: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10640#a10640
05:56:26 <Axman6> ghci is an interpreter. where as ghc is a compiler, and to compile the code, you need to have a main function
05:56:36 <kosmic> oh i see
05:56:43 <kosmic> thanks ivanm
05:56:51 <ivanm> no guarantees that it type-checks, let alone works ;-)
05:56:59 <ivanm> and, of course, that fib function is horribly inefficient
05:57:10 <ivanm> (the fact that it uses Integer rather than Int doens't help)
05:57:19 <Axman6> yeah, it's certainly not a great fib function :P
05:57:30 <ivanm> Axman6: who did the different fib functions? dons?
05:57:31 <HugoDaniel> hi
05:57:40 <HugoDaniel> is there any way to specify incomplete types ?
05:57:47 <ivanm> HugoDaniel: example?
05:57:47 <Axman6> it's on the haskell wiki, not sure who wrote them
05:58:01 <ivanm> Axman6: IIRC, dons did a blog post about parallelising, etc. fibonacci
05:58:04 <quicksilver> only by trickery, HugoDaniel
05:58:14 <HugoDaniel> like for instance, if i have a function that takes 6 args, but i want the compiler to infer the last 4 of them, how can i specify only the first two ?
05:58:30 <Axman6> ivanm: oh, yeah, well, it's faster if you just do it linrarly anyway :P
05:58:37 <ivanm> HugoDaniel: oh, implicit params?
05:58:45 <ivanm> you can kinda fudge it with a record type with default params...
05:58:49 <ivanm> Axman6: yeah
05:58:58 <quicksilver> no, not implicit params.
05:59:01 <ivanm> Axman6: linearly even ;-)
05:59:02 <yitz> ivanm: i think he means optional args, not implicit params
05:59:03 <kosmic> hm, a.out got up to 700kb
05:59:05 <quicksilver> he just wants to annotate only part of a type.
05:59:05 <Esteth> Hey everyone. I've written haskell types and a function to transition between them that works like a finite state machine. I'd like to be able to use it interactively, so I'll probably have a recursing function that gets an input symbol, executes the transition function with the input symbol, and so on. My question is, how do I keep track of state over this interactive session? I need to store the current state, essentially. I un
05:59:11 <HugoDaniel> yes quicksilver
05:59:12 <quicksilver> no, he doesn't mean optional arguments.
05:59:13 <Esteth> I can here, since it's not one computation, but many
05:59:18 <quicksilver> he just wants to only annotate part of a type.
05:59:20 <ivanm> yitz: well, optional args means default values, does it not?
05:59:23 <Axman6> ivanm: no linrarly! more piraty
05:59:23 <quicksilver> as I said, only by tricker.
05:59:24 <yitz> oh ok
05:59:28 <ivanm> and that's what I understand implicit parameters to be...
05:59:41 <Axman6> kosmic: haskell has a whole runtime compiled along with it
05:59:42 <ivanm> kosmic: your ghc produces an a.out file? what version is it?
05:59:50 <Axman6> kosmic: or do you mean memory usage?
05:59:51 <HugoDaniel> oh :/
05:59:51 <quicksilver> you can annotate subexpressions
05:59:52 <HugoDaniel> ok
05:59:53 <ivanm> I thought all new ones produced an app based on the file name...
06:00:11 <quicksilver> and you can set up carefully chosen partially polymorphic functions
06:00:12 <kosmic> hm the output file ghc produces
06:00:13 <quicksilver> and unify them, etc.
06:00:16 <kosmic> but yeah. it is runtime i guess
06:00:21 <quicksilver> trickery as I say.
06:00:22 <kosmic> let me check the version
06:01:10 <kosmic> 3it is 6.10.3
06:01:17 <Axman6> hmm
06:01:25 <Axman6> kosmic: did you use ghc --make lol.hs?
06:01:35 <Axman6> (it said it in the paste ivanm posted)
06:01:57 <ivanm> Axman6: heh, nice file name ;-)
06:02:11 <Axman6> i didn't make it up, i got it from the error message :P
06:03:21 <ivanm> Axman6: there's an error message? :o
06:03:30 <Axman6> he pasted one
06:03:42 <ivanm> oh, didn't see that paste
06:07:25 <kosmic> axman6,  heh, no i did not use --make
06:07:33 <kosmic> thought that would not produce a file
06:07:57 <yitz> Esteth: here are 3 ideas, depending on more of the details of what you are doing:
06:08:09 <Axman6> kosmic: general rule of thumb, you want to use ghc --make when compiling anything (when you've used more haskell, someone can explain to you why :))
06:08:34 <kosmic> the difference is in the linking from what i can tell
06:08:41 <Axman6> yeah
06:08:43 <yitz> Esteth: 1. define a type that holds the state, and pass it as a parameter on each recursive call
06:08:51 <kosmic> 703K 2009-10-12 15:08 lol
06:08:57 <Axman6> --make will include all packages you need automatically
06:09:03 <kosmic> oh,
06:09:07 <yitz> Esteth: 2. Use a State monad (essentially equivalent to (1))
06:09:10 <kosmic> well, that's good.
06:09:15 <ivanm> kosmic: you need --make to do the linking
06:09:42 <yitz> Esteth: 3. Use an IORef to keep the current state (a more imperative-style idiom).
06:09:51 <Axman6> kosmic: it's sort of like -L and -I for C, in a way
06:10:01 <kosmic> Yeah
06:10:06 <kosmic> but easier ;)
06:10:21 <Axman6> (though, in haskell, you'd have --package array --package blah)
06:10:29 <kosmic> oh
06:11:27 <Axman6> so, --make is sort of like --package <for all packages you need>
06:12:29 <kosmic> there is a much faster way to produce fibannaci
06:12:47 <kosmic> let fix f = x where x  = f x
06:12:59 <kosmic> fix ((0:) . scanl (+) 1)
06:13:06 <kosmic> that is incredibly fast
06:13:08 <Axman6> there's constant time version... but it's messed up
06:13:12 <ivanm> kosmic: ummm..... that first one doesn't work...
06:13:14 <Axman6> kosmic: not really
06:13:17 <ivanm> and I prefer this version:
06:13:20 <kosmic> axman6, what do you
06:13:23 <kosmic> mean, it fails?
06:13:32 <Axman6> it's not very fast
06:13:34 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:13:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:13:39 <kosmic> have you run it?
06:13:45 <Axman6> i can tell it's not
06:13:48 <ivanm> > fix ((0:) . scanl (+) 1)
06:13:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:13:58 <Axman6> this one should be faster, and use a lot less space:
06:14:19 <Axman6> > let fib x y = x : fib y (x+y) in fib 0 1
06:14:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:14:26 <Axman6> > let fib x y = x : fib y (x+y) in fib 0 1 !! 1000
06:14:27 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
06:14:29 <Axman6> > let fib x y = x : fib y (x+y) in fib 0 1 !! 10000
06:14:30 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
06:14:33 <Axman6> > let fib x y = x : fib y (x+y) in fib 0 1 !! 100000
06:14:36 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
06:14:51 <ivanm> Axman6: you should use a take rather than !!
06:14:55 <kosmic> hm ;)
06:14:55 <Axman6> > let fib x y = x : fib y (x+y) in length . show $ (fib 0 1 !! 100000)
06:14:58 <lambdabot>   20899
06:15:06 <kosmic> ooh
06:15:31 <ivanm> Axman6: isn't there also one with an explicit pair being passed around?
06:15:47 <kosmic> how the hell does haskell do that
06:15:53 <Axman6> kosmic: do what?
06:16:03 <pozic> Does c2hs also help with haskell to C?
06:16:06 <ivanm> and then rather than a list, you just do it for so many terms and take the first element of the pair or something...
06:16:08 <kosmic> well, all the other fib examples i've tried are a lot slower
06:16:12 <ivanm> pozic: I think not
06:16:22 <kosmic> brb phone
06:16:23 <ivanm> kosmic: it's hard to tell how fast they are here ;-)
06:16:33 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100000
06:16:35 <lambdabot>   420269270299515438631900510129391513177391570263223450330471608719833573145...
06:16:51 <pozic> ivanm: so hsc2hs and c2hs do not do the same? I.e. c2hs does not dominate hsc2hs?
06:16:53 <ivanm> oh, Axman6 started with 0...
06:16:56 <Axman6> kosmic: well, the fib n = fub (n-1) + fib (n-2) one is rediculously inefficient
06:17:03 <ivanm> pozic: never used either one tbh
06:17:14 <ivanm> but AFAIK they're for helping you write wrappers for C code
06:17:15 <pozic> tbh?
06:17:20 <ivanm> to be honest
06:17:22 <Axman6> ivanm: yeah, i caved and started defining fibs starting at 0
06:17:38 <pozic> Wrapping C code is really popular, the other way around, not so.
06:17:58 <pozic> All the useful code is written in C :P
06:17:58 <ivanm> Axman6: blasphemer!
06:18:02 <ivanm> heretic!
06:18:14 <ivanm> pozic: not quite
06:18:27 <ivanm> we'll happily take their goodness, but if they want ours they have to join us!
06:18:31 <ivanm> like the borg! :p
06:18:36 <Axman6> pozic: but going the other way implies most of your code is C, and that's yuck :(
06:18:46 <ivanm> exactly
06:18:47 <ivanm> !
06:18:52 <pozic> ivanm: no, it doesn't.
06:19:03 <ivanm> well, something like that, anyway...
06:19:05 <tuukkah> @type zip4
06:19:06 <lambdabot> forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
06:19:25 <pozic> It only means that the main thread is started from C.
06:19:26 <tuukkah> where's the uncurry4 to go with that?
06:19:32 <HugoDaniel> i keep getting *** Exception: readUTF8Char: illegal UTF-8 character 252
06:19:36 <ivanm> tuukkah: waiting for you to write it? :p
06:19:38 <pozic> It might or might not do lots of interesting stuff.
06:19:41 <HugoDaniel> how can i solve it ? (in a query of takusen)
06:20:02 <ivanm> tuukkah: you probably want zipWith4 anyway
06:20:30 <Esteth> yitz: Thanks :)
06:20:35 * ivanm is trying to write up a research proposal for a PhD application.... so far, it has a title of "PhD Research Proposal" and that's it :s
06:20:45 <tuukkah> ivanm, thanks, good point :-)
06:21:42 <Axman6> ivanm: if you take something good i could be doing, i'll be pissed :P
06:22:00 <ivanm> Axman6: combinatorial algorithms?
06:22:07 <Axman6> not interested
06:22:31 <Axman6> parallelism and high performance is more the sort of stuff i'm interested in
06:22:54 <ivanm> so, we're not in competition then
06:23:02 <ivanm> (though I'll gladly use the result of your research :p )
06:23:02 <Axman6> :)
06:23:07 <Axman6> heh
06:23:23 <Axman6> well, you'll probably be finished your PhD before i ever get anywhere near doing one
06:23:44 <Axman6> anyway, if you want to stuff with haskell at ANU, i'd talk to Clem
06:24:06 <ivanm> Axman6: I'll (hopefully) be using Haskell, not doing research with it
06:24:14 <ivanm> Axman6: when would you finish your undergrad?
06:24:22 <Axman6> three more years
06:24:29 <HugoDaniel> i really dislike utf-8
06:24:29 <ivanm> ahhhhh
06:24:33 <Axman6> plus like 5 weeks
06:24:37 <HugoDaniel> it only gives me trouble :/
06:24:37 <ivanm> HugoDaniel: the package or the encoding?
06:24:40 <ivanm> Axman6: heh
06:24:41 <HugoDaniel> both
06:25:59 <HugoDaniel> how can i make it to ignore ?
06:26:15 <HugoDaniel> is there any exceptionIgnoreAllUTF8 ?
06:28:17 <ivanm> Axman6: anyway, my problem with writing my proposal is that basically my current research project is "muck around with combinatorial algorithms" :s
06:28:34 <Axman6> for what purpose?
06:28:49 <Axman6> what does muching around with them achieve?
06:29:00 <ivanm> well, it helps me achieve a PhD! :p
06:29:23 <ivanm> ultimately, it's to test/develop/implement new algorithms
06:29:48 <Axman6> and who would use these algorithms?
06:30:04 <ivanm> people who need them? *shrug*
06:30:07 <HugoDaniel> db access in haskell is such a pain :/
06:30:17 <ivanm> I've basically been told by my future supervisor that we'd sort it out when I get there :s
06:30:23 <Axman6> ivanm: think of who these people are specifically
06:30:29 <Axman6> heh
06:30:33 <Axman6> who's the supervisor?
06:30:39 <HugoDaniel> even takusen messes it up preatty bad
06:30:40 <ivanm> Brendan McKay
06:31:08 * Axman6 thinks that maybe it'd be fun to implement vector types for GHC, that get compiled to SIMD code as a PhD project... maybeh
06:31:21 <Axman6> yeah i've heard the name before. no idea who he is though
06:31:34 <ivanm> Axman6: big guy in the combinatorial algorithm field
06:31:52 <ivanm> implemented pretty much _the_ canonical graph isomorphism/automorphism app
06:31:55 * Axman6 doesn't even know what a combinatorial algorithm is
06:31:58 <HugoDaniel> how is it possible to avoid repeating this whole code in takusen ? (since the type sig for the iter function keeps changing each query...) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10643#a10643
06:32:33 <ivanm> Axman6: you know what combinatorics is?
06:32:42 <Axman6> nope
06:32:42 <HugoDaniel> and how do i avoid messing around with iterators when i just want the first result ?
06:32:53 <Axman6> well, possibly, but i'll say no
06:33:48 <ivanm> Axman6: OK, you know what a graph data structure is?
06:36:30 <Esteth> can anyone look at my code here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10644#a10644 and tell me if there's a simple way to change the main function to update s with the result of the iteration everyime time through the "loop"? It strikes me that this should be simple, but I can't get my head around it :S
06:37:12 <ivanm> @hoogle iterateM
06:37:12 <lambdabot> No results found
06:38:09 <Axman6> ivanm: yep
06:38:38 <ivanm> Axman6: OK, well graphs (the mathematical structure which graph data structures are based on) are sub-branch of combinatorics
06:40:05 <Axman6> "A Study into Combinatorial Algorithms for the Advancement of Combinatorics" >_>
06:40:18 <ivanm> heh
06:40:44 <ivanm> I have a specific paper describing an algorithm that brendan says I can start with by implementing; and then do other stuff :s
06:41:12 <Axman6> heh
06:41:27 <Axman6> what's actually involved in getting a PhD?
06:41:43 <ivanm> "Actually it is not very important as the topic you finally write a thesis on can be chosen later. The proposal is just to establish that you have ideas for
06:41:44 <ivanm> research that are sufficient to take your application seriously."
06:41:54 <ivanm> gah, thought I got rid of all the newlines...
06:42:10 <ivanm> Axman6: if you have a 1st class honours, CECS at ANU says you're guaranteed to get in + funding
06:42:22 <Axman6> like, what do you have to do to start one, what work do you need to do, and what eeds to be actually handed in at the end i guess
06:42:28 <ivanm> ahhh
06:42:35 <Axman6> hmmm... well, no chance of me getting that
06:42:52 <ivanm> you need a research proposal + supervisor to start, regular reports + papers and a thesis at the end
06:43:01 <ivanm> Axman6: AFAICT, if you have even a high second class honours, you're pretty much guaranteed a spot, and almost guaranteed an APA
06:43:19 <Axman6> i'm very good at things i like, but if something doesn't interest me, i can't focus enough to do well in it (part of my ADD), so, yeah, no honours for me
06:43:28 <Beelsebob> Axman6: the basic premise is that you utterly utterly destroy your soul and your mind, and when you can take no more, you write a few hundred pages on what broke you
06:43:43 <Axman6> sounds good
06:43:47 <Axman6> :P
06:43:55 <ivanm> Axman6: heh, I just scraped by to get my first class honours, because I took a 4th year comp phys subject as an elective and failed the final exam :s
06:44:06 <ivanm> (stupid bloody lecturers who have no idea what they're doing...)
06:44:07 <Axman6> nice :P
06:44:23 <ivanm> Beelsebob: only a few hundred pages? I thought they expected more than that...
06:44:38 <ivanm> how is that going to be enough to keep someone going throughout a cold winter? :p
06:44:47 <Beelsebob> ivanm: my thesis was 160 pages, though I do have a bit more to write
06:44:54 <ivanm> *nod*
06:45:06 <Axman6> Beelsebob: you a doctor yet?
06:45:12 <Beelsebob> not yet, no
06:45:15 <Beelsebob> not sure I will in the end
06:45:25 <Beelsebob> can't get enough motivation to do my corrections :/
06:45:31 <Axman6> :(
06:45:49 <Axman6> but, i'll give you a hug/won't give you a hug, if you do them :)
06:45:53 <ivanm> my honours (in maths) thesis was 84 pages... I figured it'd be short compared to others since most of my work was programming, but I had the second or third longest math thesis that year (out of 9)
06:46:07 <benmachine> I will mail you a hug
06:46:16 <ivanm> and a larger bibliography (mainly referencing which libraries I used, etc.) than people that actually did research :s
06:46:21 <benmachine> I will hug an envelope and then send it to you?
06:46:25 <ivanm> benmachine: heh
06:46:36 <ivanm> benmachine: you need to hug the inside fo the envelope
06:46:47 <ivanm> so that when Beelsebob opens it, it unfolds and hugs him!
06:46:52 <benmachine> yes!
06:46:59 <Beelsebob> hehe, that would be awesome
06:47:43 <Axman6> so, gogogo! :P
06:47:51 <Beelsebob> meh
06:47:55 <Beelsebob> too busy writing iPhone games
06:48:13 <Axman6> heh
06:48:31 <ivanm> Beelsebob: they've finished porting GHC to ARM, have they?
06:48:42 <Beelsebob> nope, not using Haskell :(
06:48:55 <Beelsebob> would need a cross compiler to be able to submit for the app store anyway
06:48:56 <ivanm> Beelsebob: heretic!
06:50:31 <Jafet> "I'd shoot you in the foot, but unfortunately I'm using Haskell."
06:50:52 <Beelsebob> hahaha
06:50:54 <Beelsebob> Objective-C with manual memory management is enough to shoot myself thank you
06:51:13 <Axman6> there's no GC on iPhone?
06:51:13 <FunctorSalad> unsafePerformIO (shoot foot) -- shoot self in foot zero, one or any number of times, depending on evaluation order
06:51:27 <FunctorSalad> (haskellwiki :))
06:53:08 <ivanm> preflex: seen gwern
06:53:09 <preflex>  gwern was last seen on #haskell 12 hours, 31 minutes and 27 seconds ago, saying: and his programmer didn't understand conditions well enough to handle it
06:56:31 <etpace_> university gets in the way of haskell :(
06:56:56 <Beelsebob> etpace_: depends on the university
06:57:36 <Axman6> etpace_: yeah :(
06:57:38 <etpace_> I guess
06:57:53 <etpace_> atleast ML is getting in the way of haskell, rather than Java ;)
06:58:29 <earthy> etpace: university provides understandig (hopefully) understanding begets better haskell code, ergo university helps haskell.
06:58:52 <hackagebot> hoauth 0.1.5 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
06:59:39 <etpace_> well sure, but i'm young, everything is about right now!
06:59:53 <hackagebot> loli 2009.10.13 - A minimum web dev DSL in Haskell (JinjingWang)
07:00:32 <earthy> you're conflating 'young' with 'impatient'
07:00:41 <etpace_> sure
07:01:49 <cocon> how can Rational be made usable with printf?
07:03:07 <Esteth> How, in haskell, does one have a "loop" getting a line from the user, perform action, altering a state, getting another line, performing an action, altering a state, getting another line, and so on?
07:03:25 <quicksilver> foo = do getLine; performAction; changeStuff; foo
07:03:29 <quicksilver> Esteth: like that.
07:05:11 <pozic> hsc2hs seems to be broken :(
07:05:39 <ilid> Esteth: here's a brute-force way: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10644#a10645
07:06:36 <ilid> Esteth: you could alternatively store your state in an IORef and use forever
07:06:40 <benmachine> cocon: I don't think the library exposes the necessary stuff; you'll have to use %s and show I suppose
07:06:54 <Esteth> quicksilver: Thanks, looking into trying to do it that way :)
07:07:27 <benmachine> cocon: it looks like making things an instance of PrintfArg is how it is done, but I think not all the types involved in doing so are exported
07:08:30 <pozic> Also broken on hackage build machine: http://hackage.haskell.org/packages/archive/hsc2hs/0.67.20061107/logs/failure/ghc-6.10
07:08:51 <Esteth> ilid: IORefs seem like overkill for this, but your brute-force method seems perfect, in honesty. Thanks :)
07:08:53 <pozic> And appears to be in that state for at least 6 months.
07:09:07 <ilid> Esteth: no problem. the 'brute force' way is the way i'd do it too ;-)
07:10:02 <ilid> it slightly surprises me that there doesn't appear to be a standard combinator for what you're doing...
07:12:47 <ilid> @type execStateT . forever . StateT . (fmap.fmap) ((,) undefined)
07:12:48 <lambdabot> forall s (m :: * -> *). (Monad m, Functor m) => (s -> m s) -> s -> m s
07:13:02 <ziman> Esteth, or: forever (getLine >>= performAction)
07:13:10 <ziman> ah, state
07:19:27 <cocon> When printf'ing 12.34 with "%.3g" Haskell gives 12.340, and C gives 12.3
07:19:34 <cocon> aren't they supposed to be compatible?
07:23:18 <benmachine> sounds like a bug
07:23:38 <ilid> printf is an evil hack anyway ;-)
07:23:51 <pozic> Trac dead?
07:24:40 <benmachine> printf is a delightful hack
07:24:42 <Draconx> cocon, seems like the implementors forgot that the precision argument means different things for %f and %g.
07:25:09 <amaron> hmmmm, is everything ok with hackage or it's just me who cannot reach it?
07:27:00 <wdonnelly> looks down from here too
07:27:01 <quicksilver> printf is designed to be admired not used :)
07:27:35 * ilid once wrote a function 'list' which worked as [a], a -> [a], a -> a -> [a], ... using the printf trick
07:28:11 <FunctorSalad> $(printf) ftw
07:28:24 <FunctorSalad> runtime formatstring errors ftl
07:28:39 <pozic> How should one get a [Stuff] where data Stuff = A Field1 Field2| B Field3 Field4 from Haskell to C?
07:28:44 <ilid> FunctorSalad: runtime l10n ftw
07:28:51 <FunctorSalad> ilid: ;)
07:29:01 <pozic> Everyone talks about getting C libraries to Haskell, but not the other way around.
07:29:13 <FunctorSalad> $(printf) could generate something using I10n too
07:29:43 <Saizan> pozic: define a tagged union on the C side?
07:29:59 <Saizan> assuming you've to inspect the values
07:30:10 <pozic> Saizan: Mostly, I don't really know what type to give it.
07:30:22 <ilid> pozic: what interface do you want it to have on the C side?
07:30:37 <pozic> Saizan: you cannot just put a Haskell type signature in an export declaration.
07:31:29 <ilid> pozic: decide on the C interface, write wrapper functions to provide that interface, and export them, i guess
07:31:31 <pozic> ilid: an array of struct Stuff.
07:31:32 <Saizan> pozic: i'd define suitable types in C and marshal
07:32:03 <pozic> Saizan: with c2hs?
07:32:30 <pozic> Since that appears to be the only tool which has survived the bitrot.
07:32:39 <Saizan> pozic: that would help writing the Storable instance, yeah
07:33:30 <Saizan> hsc2hs works too afaik, it comes with ghc
07:35:02 <deech`> Hi all, Hackage appears to be down. I can't even ping it.
07:37:51 <ilid> http://downforeveryoneorjustme.com/hackage.haskell.org
07:38:10 <ilid> looks like it's down
07:38:26 <pozic> Long live central systems!
07:38:39 <pozic> centralized*
07:39:41 <Ferdirand> the name bothers me. That site should be called "fix (\n -> "downfor"++n++"orjustme")
07:41:11 <ilid> i don't think even IDNA allows domain names with self-reference.
07:44:04 <ziman> oh, it took me quite a while do get that remark, cool :)
07:45:31 <ilid> you could call it 'dfdojm.com', which would stand for 'down for dfdojm.com or just me'
07:45:57 <byorgey> hmm, hackage is down again?
07:46:08 <byorgey> oh, yes, ilid just said that
07:46:10 <amaron> yes
07:46:14 <MyCatVerbs> Like a whore's drawers.
07:46:25 * byorgey wails with anguish
07:46:32 <byorgey> I don't know what to do without hackage!
07:46:43 <byorgey> I just sit and stare blankly at my monitor
07:46:50 <MyCatVerbs> The same thing we do every night, byorgey.
07:46:54 <amaron> make distributed repository
07:47:03 <MyCatVerbs> Try to TAKE OVER THE W-oh, no, wrong one.
07:47:07 <MyCatVerbs> Cyanide pill.
07:47:21 <byorgey> MyCatVerbs: but where are we going to find lederhosen in our size?
07:47:43 * ilid ponders running a hackage backup server on control.monad.st
07:47:55 <MyCatVerbs> Nah, we're bailing on that plan and going for the cyanide pills instead.
07:48:08 <MyCatVerbs> ilid: that would make you a) popular b) geeky c) awesome.
07:48:23 * byorgey agrees
07:48:37 <ilid> right then :)
07:48:49 <byorgey> I wonder if the new hackage server code will have a nice mechanism set up for running hackage mirrors
07:49:02 <byorgey> that would be nifty =)
07:49:02 <ilid> @brain Should I run a hackage mirror on control.monad.st?
07:49:02 <lambdabot> It must be inordinately taxing to be such a boob.
07:49:13 <flazz> what is the spj paper on IO? defending something?
07:49:26 <ilid> flazz: defeating the awkward squad?
07:49:27 <byorgey> flazz: tackling the awkward squad?
07:49:32 <ivanm> byorgey: hmmmm....
07:49:35 <ilid> yeah, thatsounds more likely :)
07:49:37 <flazz> yes!, thanks
07:49:48 <ivanm> byorgey: I know they're going to make it easier for people to run their own hackages...
07:49:50 * byorgey really ought to read that paper =)
07:49:57 <ivanm> heh, same
07:54:26 <jinjing> seems hackage is down?
07:55:42 <ilid> if only we had as much redundancy for hackage as we have for people complaining that it's down ;-)
07:55:48 <byorgey> jinjing: yep.
07:56:14 <absentia> is hackage unreachable for anyone else?
07:56:15 <jinjing> byorgey: cool, thought i had to setup tor ><
07:56:30 <byorgey> heh, someone ought to change the topic =)
07:56:37 * absentia loves being a statistic.
07:58:05 <tediosu> hi all
07:59:55 <tediosu> heh, this is kinda embarrassing... but how do i import an additional module on Hugs?
08:00:38 <tediosu> i've tried :m +module but it didn't work
08:04:37 <tediosu> ah, never mind... i just figured out
08:04:41 <absentia> whois zinc
08:07:12 <HugoDaniel> :(
08:07:17 <HugoDaniel> can someone help me out with takusen ?
08:08:00 <HugoDaniel> i want to do the java equivalent of setting properties in a connection, so that i can set it to be UTF-8
08:08:09 <HugoDaniel> also, im trying out collation in the queries
08:08:23 <HugoDaniel> but its not working (praise m$ for their mssql 2000 server i guess)...
08:08:36 <HugoDaniel> this is really boring :/
08:12:45 * SamB_XP wonders if it's possible to associate no-extension files to an app in windows ...
08:14:16 <jinjing> cool, hackage working again
08:16:06 <benjamin`> does anyone have any suggestions for an interesting programming task to try to tackle with haskell?
08:16:18 <absentia> anything.. useful?
08:16:52 <benjamin`> i'm not really sure what i mean, haha
08:17:07 <benjamin`> i'm new to the language and i'm struggling to come up with ideas of what i can do with it
08:17:13 <ksf> go throught the java standard lib, compare it to hackage, hack away on what's missing
08:17:47 <ziman> benjamin`, have you tried Project Euler (projecteuler.net) ?
08:18:00 <ksf> euler is very mathematic.
08:18:11 <benjamin`> ooh this is just the sort of thing i'm looking for
08:18:18 <benjamin`> anything math is a plus
08:18:36 <absentia> hahaha
08:18:52 <absentia> did you see the slashdot quote recently 'bout that?
08:19:24 <benjamin`> what was that?
08:19:41 <absentia> And he wouldn't want to work for a company that doesn't hire those who don't code in their spare time. 'You know what's more awesome than spending my Saturday afternoon learning Haskell by hacking away at a few Project Euler problems?' asks Dziuba. 'F***, ANYTHING.'"
08:20:08 <MyCatVerbs> Learning Perl by hacking away at a few Project Euler problems, perhaps?
08:20:24 <ksf> ah. so slashdot is copying from reddit
08:20:31 <yitz> absentia: i was thinking of linking that on reddit :)
08:20:51 <yitz> ksf: oh, it was on reddit?
08:21:08 <akappa> ziman, project euler is more about mathematical reasoning than designing and programming
08:21:14 <ksf> the discussion that inspired that blog, yes.
08:21:38 <yitz> where?
08:22:00 <ksf> on the proggit
08:22:33 <yitz> akappa: you're right. many people don't realize that, and spend hours trying to use programming techniques to get their code to run faster instead of just doing the math.
08:22:47 <ksf> http://www.reddit.com/r/programming/comments/9s3ww/would_you_hire_a_programmer_that_does_not_write/
08:23:14 <yitz> ksf: the haskell comment is in there?
08:23:24 <FunctorSalad> can I fix a "no rigid context" GADT pattern matching error with a pattern signature?
08:23:30 <akappa> yitz, THE solution is trivially from an implementation PoV ;)
08:23:31 <FunctorSalad> asking before I try to fix the code generator ;)
08:23:34 <akappa> (often)
08:23:44 <yitz> yes
08:23:58 <yitz> but even then, much nicer in Haskell
08:24:32 <akappa> I want to learn the functional programming way, but I'm not yet decided between haskell and ocaml
08:24:44 <burp> of course haskell =)
08:24:48 <Raevel> choose haskell!
08:25:00 <burp> you want pureness and lazyness
08:25:25 <yitz> @faq can haskell teach akappa the functional programming way?
08:25:26 <lambdabot> The answer is: Yes! Haskell can do that.
08:25:40 <burp> haskell can teach?
08:25:57 <Raevel> @faq can haskell teach?
08:25:57 <lambdabot> The answer is: Yes! Haskell can do that.
08:25:59 <FunctorSalad> choose haskell. choose life.
08:26:16 <yitz> @vixen teach akappa the functional programming way.
08:26:16 <lambdabot> what's a program?
08:26:18 <burp> choose haskell or choose life :D
08:26:39 <akappa> it seems that ocaml is more flexible and fast, but haskell is more beauty :)
08:27:04 <burp> you might be right
08:27:07 <yitz> akappa: haskell often beats ocaml on the language shootout
08:27:13 <akappa> really?
08:27:26 <hackagebot> ghc-events 0.1.0.1 - Library and tool for parsing .eventlog files from GHC (SimonMarlow)
08:27:49 <yitz> akappa: it all comes down to how hard you work on optimizing
08:28:19 <FunctorSalad> doesn't that apply to the shootout too? (not saying haskell put more effort in than ocaml, mind you)
08:28:32 <FunctorSalad> just thinking about the shootout in general..
08:29:23 <yitz> imho the advantage of haskell is in the usual unoptimized case: better code, easier to write and read
08:29:32 <yitz> FunctorSalad: yeah, up to a point
08:29:34 <FunctorSalad> akappa: but generally speaking haskell has quite some optimization potential because purity lets you do rather free equational reasoning
08:30:19 <yitz> FunctorSalad: you can work very hard on VBA running in Word, but there's a limit
08:30:21 <akappa> FunctorSalad, thanks for the rationale :)
08:31:12 <FunctorSalad> and the type system has no runtime overhead, types are erased during compilation
08:31:25 <FunctorSalad> (class dictionaries may not be, though)
08:33:48 <jmcarthur> akappa: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ocaml&box=1
08:34:26 <jmcarthur> akappa: so it appears, at least on the shootout, haskell is typically about the same speed as ocaml, if not a little faster
08:34:27 <FunctorSalad> now what does *this* error mean? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10648#a10648
08:34:46 <FunctorSalad> the pattern sig fixed the lack of rigid context, but now it complains about lack of rigid return type
08:35:33 <Cale> FunctorSalad: Add a type signature for foo as a whole
08:35:55 <Cale> It's generally impossible to write functions over GADTs without providing full type signatures for them.
08:36:08 <FunctorSalad> Cale: in my real problem, foo is a class method, so I'm puzzled about the rigidity error in the first place
08:37:22 <absentia> > Error: Target org.macports.fetch returned: ghc is not yet supported on Mac OS X 10.6.x (SnowLeopard)
08:37:23 <lambdabot>   Not in scope: data constructor `Error'Not in scope: data constructor `Targe...
08:37:25 <absentia> hahaha
08:37:31 <FunctorSalad> maybe this is the "GADT and classes mess" Philippa had been hinting at :)
08:41:25 <FunctorSalad> should I write "instance X Y where foo = (( \x -> ... ) :: Sig)"?
08:41:35 <FunctorSalad> since sig decls are illegal in an instance decl
08:41:53 <kowey> absentia: Gregory Wright recently mentioned that he was working on it http://trac.macports.org/ticket/20132
08:42:10 <djsiegel> Hi, I am writing my first cabal file for a little pastebin tool I am working on, and cabal sdist makes a tarball but leaves all source files but Main.hs out -- how do I make it include all the necessary source files? extra-source-files and list all source files?
08:42:14 <kowey> I just used the Haskell Platform binary (and not having one of those fancy 64 bit machines, everything just worked)
08:42:24 <Cale> absentia: There seem to be more details about the problem here: http://hackage.haskell.org/trac/ghc/ticket/3400
08:42:51 <dcoutts> djsiegel: you're supposed to list all the modules. See the other-modules field.
08:43:15 <djsiegel> dcoutts: ah, ok, great
08:44:06 <absentia> thanks!
08:45:50 <benjamin`> project euler is great
08:51:29 <ksf> "You could have googled that and looked smarter."
08:51:49 * ksf fears I'm going to be quoted on that, spawning YCHGTALS
08:53:15 <yitz> @google ychgtals
08:53:16 <lambdabot> No Result Found.
08:54:11 <ilid> FunctorSalad: i'd try: fooY :: Sig; fooY x = ...; instance X Y where foo = fooY
08:54:12 <ksf> there's already http://lmgtfy.com/ , though.
08:54:27 <ksf> ...which is equally embarrassing.
08:57:54 <FunctorSalad> ilid: good idea
08:58:11 <ilid> FunctorSalad: if that works i'd make sure there's a bug on the GHC trac...
08:58:33 <FunctorSalad> I'm already trying the transformation to (\x -> case x of ...) right now though
09:16:51 <hackagebot> AspectAG 0.1.3 - Attribute Grammars in the form of an EDSL (MarcosViera)
09:32:22 * ksf is wondering whether it'd be a smart move to compile to forth
09:33:29 <quicksilver> ksf: depends how good your forth compiler is? ;)
09:34:15 <ksf> well I'm not a forth guru (having only used it on my palm105), but they're known to be at least one of a) ultra portable c) faster than c
09:34:19 <ilid> compiler? you mean you don't have a CPU which can run forth directly yet?
09:34:24 <ksf> ...and of course d) interactive
09:34:47 <ksf> I don't. except if you see x87 as a bogged-down forth
09:35:15 <quicksilver> faster than c?
09:35:19 <quicksilver> are you confusing it with fortran?
09:35:20 <ksf> faster than c.
09:35:41 <ksf> well fortran's known to be faster than c, too.
09:35:59 <ilid> b) ?
09:36:23 <ksf> I don't know whether b is faster than c.
09:36:30 <quicksilver> I've not heard claims that forth is faster than in general faster than C
09:36:36 <quicksilver> I can't really see why you'd expect it to be
09:36:42 <ksf> but you shouldn't call a language c if you want people to not mess up their lists.
09:36:45 <MyCatVerbs> ilid: There's no optimizing B compiler in existence to the best of my knowledge, so probably no. :)
09:37:02 <absentia> really.. few people write in forth.. for a reason.
09:37:15 <MyCatVerbs> ksf: Fortran's speed advantages pretty much all go away with proper application of the "restrict" keyword, AFAIK.
09:37:26 <ksf> forth gives you more stack control, and really cheap abstraction
09:37:30 <absentia> why compile down to it, why not just go straight to the machine code.. since compiling forth is trivial?
09:37:43 <ksf> portability?
09:37:52 <MyCatVerbs> ksf: and, for us Haskell weenies, appropriate applications of __attribute__((pure)) and __attribute__((const)) ;)
09:38:00 <absentia> but you're adding an entire layer of dependency for that "portability"
09:38:21 <ksf> well let's say I don't feel like implementing a register allocator.
09:38:25 <absentia> my: explain...   att pure/const = amazing speedups ?
09:40:03 <ksf> I'm not really wondering about whether one would choose forth over a native codegen, but forth over c.
09:40:10 <MyCatVerbs> absentia: Little bits here and there. :)
09:40:16 <ksf> (cf. evil mangler)
09:40:53 <MyCatVerbs> absentia: the "restrict" keyword tells the compiler that two given pointers will always be distinct, so that it doesn't need to worry about writes through one clobbering values read through the other.
09:41:33 <ilid> is "restrict" manual uniqueness typing for pointers?
09:41:49 <MyCatVerbs> absentia: gcc implements an annotation mechanism called __attribute__(()). The "pure" attribute tells gcc that the function writes no memory and has no side effects. The "const" attribute tells gcc that the given function reads no memory other than its formal parameters, either. :)
09:41:56 <MyCatVerbs> ilid: Yep.
09:42:25 <ilid> seems ugly to have a keyword for something the compiler could in principle deduce
09:42:53 <ilid> especially when getting it wrong means your program has undefined behaviour, and getting it right has no impact on your program's semantics
09:42:57 <BackInAcTion> MyCatVerbs: is Haskell's const keyword like Java's final keyword?
09:42:59 <loop> ilid: seems necessary if the compiler in practice can't
09:43:27 <ksf> everything in haskell is "final"
09:43:28 <ilid> loop: my worldview doesn't cast necessary and ugly as mutually exclusive ;-)
09:43:42 <MyCatVerbs> BackInAcTion: Haskell has a const keyword? :)
09:44:03 <ilid> BackInAcTion: haskell's const function is nothing like java's final keyword :)
09:44:07 <ilid> > const 4 2
09:44:08 <lambdabot>   4
09:44:50 <MyCatVerbs> BackInAcTion: if you're asking about the const keyword in C, then no. C's const keyword doesn't give you the guarantees that final does in Java.
09:45:08 <MyCatVerbs> BackInAcTion: you can cast away constness in C, so the compiler can't use it as an optimization hint.
09:47:21 <ilid> don't know about C, but at least in C++ there are certain optimizations you can do with const values.
09:47:59 <MyCatVerbs> ilid: const_cast<>.
09:48:01 <ilid> const_casting and modifying a value which was defined as const leads to undefind behaviour
09:48:36 <ilid> i believe the intention is that implementations are permitted to put const globals into ROM
09:48:51 <BackInAcTion> ilid: ok, does this const function return the higher or highest of two or more values?
09:49:03 <MyCatVerbs> ilid: ah. Learn something new every day. :)
09:49:10 <ilid> BackInAcTion: no, it returns the first one.
09:49:11 <ilid> @src const
09:49:12 <lambdabot> const x _ = x
09:49:29 <BackInAcTion> Ohh...I get it
09:49:39 <ilid> MyCatVerbs: could be the case in C, though. a lot of the stuff which c took from c++ is subtly incompatible :)
09:50:51 <BackInAcTion> ilid: the '_' meaning that that function ignores it's second parameter, right?
09:51:23 <MyCatVerbs> BackInAcTion: Yep.
09:51:40 <MyCatVerbs> BackInAcTion: _ matches anything, and discards the result.
09:51:54 <ilid> BackInAcTion: yes. '_' is just like you'd used a new variable name for that argument which isn't mentioned anywhere else
09:52:03 <benmachine> I am kind of confused by haskell-cafe
09:52:08 <ilid> BackInAcTion: so it's just like: const x y = x
09:52:25 <benmachine> I sent a message to it and I looked in the archives and it wasn't there, but there were two messages in the archives that I hadn't got
09:52:32 * benmachine hmms
09:52:35 <BackInAcTion> wow...
09:52:36 <benmachine> I will wait
09:53:04 <BackInAcTion> so, this const function works on lists of Chars, or [Char]s, too
09:53:45 <benmachine> it works on everything
09:53:46 <benmachine> like id
09:54:07 <aavogt> > const const 1 2 3
09:54:08 <lambdabot>   2
09:54:22 <benmachine> :t const const
09:54:23 <lambdabot> forall a b b1. b1 -> a -> b -> a
09:54:24 <benmachine> :t const . const
09:54:25 <lambdabot> forall b a b1. a -> b -> b1 -> a
09:54:32 <darrint> Is there a way to pass compilation options (to T.R.Posix) using only =~ in the regix lib?
09:56:07 <BackInAcTion> @src (+)
09:56:07 <lambdabot> Source not found. Take a stress pill and think things over.
09:57:07 <BackInAcTion> ok, using postfix notation for adding two numbers together is, quite frankly, a bit confusing to me...
09:57:19 <BackInAcTion> opps, I meant 3 or more numbers
09:57:40 <BackInAcTion> > (+) (+) 2 3 6
09:57:41 <lambdabot>   No instance for (GHC.Num.Num (a -> a -> a))
09:57:41 <HugoDaniel> can anyone help me out with takusen ?
09:57:41 <lambdabot>    arising from the literal `2'...
09:58:31 <aavogt> > (+) ((+) 2 3) 6 -- BackInAcTion
09:58:32 <lambdabot>   11
09:58:42 <ilid> > (+) 2 $ (+) 3 6
09:58:43 <lambdabot>   11
09:58:59 <ilid> > sum [2,3,6]
09:59:00 <lambdabot>   11
09:59:22 <BackInAcTion> I get it now...I wasn't associating properly
09:59:48 <aavogt> and what you were using is prefix notation
10:00:06 <aavogt> > 2 + 3 + 6
10:00:07 <lambdabot>   11
10:01:12 <ilid> > (flip.flip id)  1 2 (+)
10:01:13 <lambdabot>   3
10:04:33 <HugoDaniel> what about takusen, anyone ? :)
10:04:51 * BackInAcTion is thoroughly confused
10:05:04 <HugoDaniel> :(
10:05:11 <HugoDaniel> im planing on ditching haskell for java...
10:05:17 <HugoDaniel> all because of this mssql server 2000
10:05:30 <Twey> What *about* Takusen?
10:05:50 <HugoDaniel> *** Exception: readUTF8Char: illegal UTF-8 character 252
10:05:52 <HugoDaniel> ;)
10:06:09 <HugoDaniel> ive tried it with collation on the query... and nothing
10:06:14 <Twey> Okay?
10:06:24 <Twey> Sounds like the database encoding you're using is not UTF-8
10:06:34 <HugoDaniel> Twey: mssql server 2000 uses utf-16
10:06:44 <Twey> Well, make it use UTF-8
10:06:48 <HugoDaniel> i can't
10:06:53 <Twey> It's probably an option on the table
10:06:56 <HugoDaniel> this is the "real world"
10:06:57 <HugoDaniel> i cant
10:07:14 <Twey> And what are you doing when this error occurs?
10:07:54 <HugoDaniel> http://pastebin.com/m4b8cd3f7
10:07:58 <HugoDaniel> this...
10:08:22 <Twey> I meant on the Haskell side of things.
10:08:27 <HugoDaniel> the usual
10:09:13 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10656#a10656
10:11:01 <ilid> what's a good coordinate system to use for representing points within a hyperbolic space?
10:12:15 <HugoDaniel> anyway... this means java for me :(
10:12:43 <HugoDaniel> and that preaty much resumes my haskell experience "in the real world"...
10:12:53 <medfly> very newbie question here...
10:13:01 <FunctorSalad> :)
10:13:07 <HugoDaniel> sure, its a very good language, with a great flow... but no usable sql package
10:13:14 <medfly> I'm trying to use Maybe, and I'd like to do one thing if it's Nothing, and another thing to x if it's Just x...
10:13:19 <medfly> I'm not so sure how to do that :p
10:13:45 <FunctorSalad> > maybe "no" show (Just 10)
10:13:46 <lambdabot>   "10"
10:13:50 <FunctorSalad> > maybe "no" show Nothing
10:13:51 <lambdabot>   "no"
10:14:19 <medfly> uh...
10:14:47 <ilid> medfly: maybe (what to do if it's Nothing) (\x -> what to do if it's Just x) (your value :: Maybe a)
10:14:54 <ilid> @type maybe
10:14:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:14:59 <Twey> HugoDaniel: ‘I've tied my hands behind my back, and now I can't eat soup!  This spoon is rubbish!’
10:15:17 <medfly> oh... okay, thanks
10:15:30 <HugoDaniel> Twey: actually is more like "the spoon has no way to grab!"
10:15:30 * medfly continues writing the world's ugliest function
10:15:46 <Twey> medfly: If you don't want to transform the Just value, try fromMaybe
10:15:49 <HugoDaniel> Twey: btw, im not sure ive read your sollution on the problem ? ;)
10:16:08 <FunctorSalad> I think I received that award here for using unsafePerformIO, CPP and printf in one line
10:16:08 <hackagebot> serialport 0.2.0 - Cross platform serial port library. (JorisPutcuyps)
10:16:34 <tommd> FunctorSalad: What?  The most python like award?
10:16:51 <FunctorSalad> tommd: ;) ugliest function
10:17:00 <FunctorSalad> but it was just for tracing
10:17:11 <Twey> HugoDaniel: I don't actually know Takusen.  I suspect there is a way to do what you ask of it, but I would in no way consider it Takusen's fault if there weren't.  This is not something that the database bindings should have to worry about.
10:17:42 <HugoDaniel> so lets change all the mssql servers in the world...
10:17:51 <Twey> The database is responsible for the encoding of data, and the driver for transforming them on the fly (if the situation is so badly formed as to require that).
10:17:58 <HugoDaniel> nice vision of "real world haskell" :)
10:18:28 <Twey> If you've limited yourself such that you can't configure either, then you're in trouble, on the whole
10:19:21 <Twey> I'm 95% certain that MSSQL does not, by design, limit its output only to UTF-16.
10:19:29 <Twey> That would be a monumentally stupid thing to do, even by Microsoft standards.
10:19:50 <FunctorSalad> surely there's some way to parse utf16 in haskell
10:19:56 <Twey> FunctorSalad: There is
10:20:02 <Twey> There are several, actually
10:20:05 <_Ray_> Hrmph. What would be a simple way to, without using any builtin Haskell functions, higher order functions, or lists by comprehension, remove all occurances of a string in another? I'm having an issue with things like removing "cab" from "ccabab" - I remove the middle 'cab', but the result is, then, 'cab'. Is there a default algorithm for this?
10:20:20 <Twey> The problem is that Takusen is attempting to interpret it as UTF-8, before it reaches the user
10:20:38 <Twey> So there's no chance (that I can see) to transform it before that happens
10:21:16 <arcatan> _Ray_: apply the function until f x == x
10:21:17 <HugoDaniel> in java this is done with put("CHARSET","UTF-8"); in a property of the odbc connection
10:21:24 <Twey> _Ray_: You want to do it recursively?
10:21:24 <HugoDaniel> ive looked for a similar thing in takusen
10:21:26 <HugoDaniel> and there isn't
10:21:32 <_Ray_> That would be a way, yeah...
10:21:34 <FunctorSalad> hack takusen?
10:21:36 <medfly> thanks guys :)
10:21:43 <_Ray_> (Yeah, we can only use plain-old recursion here)
10:21:52 <Twey> You just keep applying it, starting from the beginning each time, until there are no more ‘cab’s
10:21:55 <_Ray_> Yeah, I guess I'll just recurse until the result is the same
10:21:59 <_Ray_> Thanks :)
10:22:15 <HugoDaniel> Twey: you can change the output from utf16 to other things, by using collation on the queries... but the version of mssql server im using doesnt support it
10:22:44 <_zenon_> _Ray_: That's called a fixpoint; http://en.wikipedia.org/wiki/Fixed_point_(mathematics)
10:22:45 <Twey> HugoDaniel: And what version might that be?
10:22:49 <HugoDaniel> mssql server 2000
10:22:53 <tibbe> I found this hilarious quote in the statistics package:
10:23:08 <tibbe> "Thanks to Duncan Coutts for finding the pattern below for strong-arming GHC 6.10's inliner into behaving itself."
10:23:20 * tibbe pictures dcoutts wrestling with GHC
10:23:20 <HugoDaniel> and this is not my choice, im accessing a database of a proprietary program our university uses
10:23:22 <_Ray_> _zenon_, ah, thanks :) *reads*
10:23:27 <HugoDaniel> and i also can't change the tables because of that :P
10:23:34 <HugoDaniel> its a live server
10:23:36 <_zenon_> tibbe: with or without shirt?
10:23:39 <FunctorSalad> sounds easier to adjust the haskell side HugoDaniel
10:23:44 <FunctorSalad> but I've never seen takusen
10:23:51 <tibbe> _zenon_: I was trying to get rid of that mental image!
10:24:46 <_zenon_> heh
10:24:52 <HugoDaniel> yes FunctorSalad
10:25:01 <Twey> HugoDaniel: Google says yes.
10:25:18 <HugoDaniel> Twey: yes to what ?!
10:25:23 <Twey> tibbe: Hahaha :-D
10:25:26 <HugoDaniel> now the next thing on my "real world haskell" book would be to delete packages installed by cabal
10:25:33 <FunctorSalad> HugoDaniel: AFAIK ghc 6.12 comes with an overhaul of the encodings system
10:25:37 <Twey> HugoDaniel: ‘Yes, it does support collation’
10:25:42 <FunctorSalad> so maybe don't dump haskell just yet ;)
10:25:45 <amz> inside a "do" block in an "IO Bool" function, is this illegal? continue <- case e of { Quit -> False; otherwise -> True }
10:25:55 <Twey> Yeah, it does — you can change the default encoding 'n' stuff
10:26:00 <Twey> I don't know if that applies here, though
10:26:04 <HugoDaniel> Twey: then the guys that wrote the software and the db probably removed it
10:26:13 <tommd> Any change in default code generator with 6.12?  Native generator vs via-c?
10:26:24 <tibbe> amz: no, you want let =
10:26:25 <Twey> HugoDaniel: Ha!
10:26:35 <amz> ah, I see, thanks
10:26:38 <tibbe> amz: and otherwise doesn't do what you think here
10:26:40 <HugoDaniel> my point is that i can't do it, because ive tried
10:26:41 <HugoDaniel> :P
10:26:41 * amz feels dumb now
10:26:48 <amz> sorry, Haskell noob :)
10:26:50 <HugoDaniel> not that i can't do it because its no possible
10:26:54 <tibbe> amz: (or perhaps it does what you want)
10:26:59 <dcoutts> tommd: no change, still using -fasm by default.
10:27:00 <tibbe> amz: I would do _ -> True
10:27:06 <ilid> tibbe: it does what you want but for entirely the wrong reasons ;-)
10:27:16 <MacCoaster> hi guys. im reading about type synonyms and am trying to figure out how to type'def' Macros to something like [Macro a], i.e. a list of Macros
10:27:19 <tibbe> amz: to indicate that you don't use the result. otherwise is mostly used in guards
10:27:21 <amz> no, I really did want "let"
10:27:24 <MacCoaster> can anyone explain to me more clearly how that ca be done?
10:27:25 <MacCoaster> can
10:27:26 <tibbe> ilid: right
10:27:28 <amz> this solved it, thanks
10:27:28 <BackInAcTion> I am thinking I got postfix notation all figured out right now...
10:27:28 <tommd> Isn't the -fvia-c path going to die away some day?  I recall some discussion about that on the ML.
10:27:43 <HugoDaniel> oh well, im really in a bad mood today... now let me try to see if i can change takusen
10:27:44 <usrgentoo2390> hi i need a mega dict of 10gb or more help!
10:28:00 <Twey> ilid: I can't see how that would be the case…
10:28:03 <tibbe> amz: you're welcome. the reason you don't need <- is that you don't perform any side effects (in IO) to produce the result
10:28:05 <_zenon_> Been a while since I was hanging around here; does lambdabot still have pointless reduction?
10:28:13 <tibbe> amz: it's an entirely pure computation
10:28:21 <aavogt> @pl \x -> yes x
10:28:21 <lambdabot> yes
10:28:24 <amz> yeah, I remembered that as soon as you mentioned "let"
10:28:26 <Twey> ilid: Wouldn't using ‘otherwise’ require that e be of type ‘Bool’ (which it clearly isn't, due to the ‘Quit’)?
10:28:33 <Twey> I'd think it would just produce a type error.
10:28:39 <amz> which is why I said I felt dumb ^_^"
10:29:02 <ilid> > let f n = case even n of True -> "even"; otherwise | n == 1 -> "one" | otherwise -> "not one" in map f [1..5]
10:29:03 <lambdabot>   ["one","even","* Exception: <interactive>:1:155-237: Non-exhaustive pattern...
10:29:05 <FunctorSalad> "otherwise" is a variable in a case statement
10:29:11 <ilid> Twey: nope, it'd bind otherwise as a variable name
10:29:13 <usrgentoo2390> hi i need a mega dict of 10gb or more for hacking blind serv
10:29:15 <Twey> usrgentoo2390: The O.E.D. is about that size
10:29:26 <usrgentoo2390> ok
10:29:29 <BackInAcTion> > (+) ((+) 4 8) ((+) 2 6) / 2
10:29:29 <lambdabot>   10.0
10:29:31 <ilid> Twey: which'd work fine except if you use 'otherwise' within that lexical scope :)
10:29:32 <Twey> ilid: Oh, right, yeah.
10:29:35 <Twey> Heh.
10:29:36 <BackInAcTion> yay!
10:29:54 <Twey> No pattern variables… no pattern variables… bad Erlang…
10:29:55 <ilid> Twey: sounds like a good idea for an obfuscated haskell contest though
10:30:02 <Twey> Haha, truly
10:30:24 <ilid> "here we secretly bind 'otherwise' to False, and here we say | otherwise = ..."
10:30:33 <Twey> :-D
10:30:45 <BackInAcTion> LOL
10:30:49 <ilid> or better "here we secretly bind 'otherwise' to Just 42 and here we ..."
10:30:55 <Twey> Heheh.
10:32:21 <Tabemasu1000> Hey guys, is there any way to print a string and then get user input on the same line?
10:32:55 <Twey> Tabemasu1000: Turn off buffering on output, then just putStr your string and readLine the response
10:33:07 <Tabemasu1000> Ok, thanks
10:33:21 <FunctorSalad> or maybe hFlush stdout
10:33:35 <Twey> Oh, yeah, that might be better.
10:33:42 <Twey> I always forget about hFlush.
10:34:20 <ksf> you know, in scheme you'd actually write that
10:34:50 <Twey> (I (always forget) (about hFlush))?
10:34:55 <ksf> > let (+) = sum in (/) ((+) [4,8,2,6]) 2
10:34:56 <lambdabot>   10.0
10:35:08 <Twey> Oh, right, BackInAcTion's Schemism.
10:35:11 <ksf> they may use prefix notation, but aren't masochists.
10:35:15 <Twey> That makes more sense.
10:35:36 <ksf> especially as you write (+ 4 8 2 6)
10:35:53 <HugoDaniel> is there a simple way to remove a package installed from cabal ?
10:36:06 <ksf> ghc-pkg unregister
10:36:20 <ksf> ...that won't delete the data, but it comes close.
10:36:32 <ksf> you can use ghc-pkg hide, too.
10:36:44 <Twey> HugoDaniel: I'm pretty sure you can unregister it and then delete it straight out of the packages store.
10:36:55 <usrgentoo2390> where is download?
10:36:58 <HugoDaniel> takusen seems to have utf-16 support in the darcs version, im going to try it out
10:37:04 <BackInAcTion> Twey: I've never programmed in Scheme before, I've only really ever programmed in Bash...
10:37:26 <hackagebot> reactive 0.11.2 - Push-pull functional reactive programming (ConalElliott)
10:37:28 <hackagebot> bla 2009.10.13 - a stupid cron (JinjingWang)
10:37:30 <hackagebot> reactive 0.11.3 - Push-pull functional reactive programming (ConalElliott)
10:37:32 <ksf> ...and /me wants to have cabal-install for 6.12. I'm not going to try out compiling anything with it if I have to install all my dependencies manually.
10:37:39 <ksf> w000t!
10:37:52 <usrgentoo2390> stupid noobs
10:38:00 <ilid> > let f $ 0 = 0; f $ 1 = 1; f $ n = (f $ (n-1)) + (f $ (n-2)) in 4 + const $ 6
10:38:01 <lambdabot>   12
10:38:14 <ksf> usrgentoo2390, what do you want to download?
10:38:27 <Twey> usrgentoo2390: http://oed.com/subscribe/
10:39:03 <Twey> ksf: What was the w000t for?
10:39:16 <ksf> reactive
10:39:21 <Twey> Ah ☺
10:39:52 <BackInAcTion> Yes, this is a lot of work: let a = ['H', 'e', 'l', 'l', 'o', ', ' ', '
10:40:23 <ilid> BackInAcTion: let a = "Hello, ..." would work just as well
10:40:31 <ilid> > ['H','e','l','l','o']
10:40:32 <lambdabot>   "Hello"
10:40:32 <BackInAcTion> ilid: I know...
10:41:22 <BackInAcTion> ilid: I was just following along with a back breaking example on how Strings are really just lists of the type Char, or [Char]
10:42:01 <BackInAcTion> ['H', 'e', 'l', 'l', 'p
10:42:14 <BackInAcTion> ['H', 'e', 'l', 'l', 'o'] == "Hello"
10:42:19 <BackInAcTion> > ['H', 'e', 'l', 'l', 'o'] == "Hello"
10:42:20 <lambdabot>   True
10:42:22 <Twey> > show ("Hello" :: [Char])
10:42:23 <lambdabot>   "\"Hello\""
10:42:28 <Twey> Boo.
10:42:37 <MyCatVerbs> BackInAcTion: You call that a lot of work? Hah! Now this is a lot of work!
10:43:27 <FunctorSalad> , listE (replicate 10 [| 'f' |])
10:43:28 <hackagebot> extcore 0.5 - Libraries for processing GHC Core (TimChevalier)
10:43:30 <lunabot>  ListE [LitE (CharL 'f'),LitE (CharL 'f'),LitE (CharL 'f'),LitE (CharL 'f'...
10:43:36 * MyCatVerbs pulls 'H':('e':('l':('l':('o':(' ':('w':('o':('r':('l':('d':('.':([])))))))))))) -- out of his boot.
10:43:38 <FunctorSalad> , pprint (listE (replicate 10 [| 'f' |]))
10:43:40 <lunabot>  luna: Not in scope: `pprint'
10:43:48 <FunctorSalad> , prettyPrint (listE (replicate 10 [| 'f' |]))
10:43:50 <lunabot>  luna: Not in scope: `prettyPrint'
10:43:52 <MyCatVerbs> , 'H':('e':('l':('l':('o':(' ':('w':('o':('r':('l':('d':('.':([]))))))))))))
10:43:53 <lunabot>  "Hello world."
10:44:03 <FunctorSalad> sigh
10:44:03 <MyCatVerbs> Hah! I actually got the parens right. :)
10:44:07 <FunctorSalad> , ppr (listE (replicate 10 [| 'f' |]))
10:44:08 <lunabot>  luna: Not in scope: `ppr'
10:44:09 <Twey> Heheh.
10:44:17 <BackInAcTion> dang...
10:44:18 <FunctorSalad> , Language.Haskell.TH.Ppr.pprint (listE (replicate 10 [| 'f' |]))
10:44:20 <lunabot>  luna: Not in scope: `Language.Haskell.TH.Ppr.pprint'
10:44:27 <FunctorSalad> meh
10:44:40 * MyCatVerbs comforts FunctorSalad with cookie.
10:44:47 <FunctorSalad> nomnomnom
10:44:52 <ilid> , $( ListE [LitE (CharL 'H'),LitE (CharL 'i')] )
10:44:54 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
10:45:14 <FunctorSalad> , $( return $ ListE [LitE (CharL 'H'),LitE (CharL 'i')] )
10:45:16 <lunabot>  "Hi"
10:45:53 <FunctorSalad> , $( listE (replicate 10 [| 'f' |]) )
10:45:54 <BackInAcTion> MyCatVerbs: did you actually concatenate a element with another element of a single item list?
10:45:55 <lunabot>  "ffffffffff"
10:46:21 <ilid> , $(return . ListE . map (LitE.CharL) $ "Hello")
10:46:22 <lunabot>  luna: Not in scope: data constructor `LitE.CharL'
10:46:27 <ilid> , $(return . ListE . map (LitE . CharL) $ "Hello")
10:46:29 <lunabot>  "Hello"
10:46:41 <FunctorSalad> we do need the prettyprinter to get a char-list
10:47:02 <sw17ch> hi all
10:48:17 <tommd> hello sw17ch
10:48:34 <sw17ch> i was wondering, what's the status of view patterns in Haskell'
10:48:38 <_Ray_> Hrmph. Without using native haskell functions, lists by comprehension or higher order functions, is this the "right" way to trim the beginning of a list http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10657#a10657 ? By this I mean, if I have "foo" "foobar", I want to return "bar", but if I have "foo" barfoobar", I just return "barfoobar", since I'm only trimming at the beginning.
10:48:49 <ilid> is 'default' a keyword?
10:49:12 <tommd> sw17ch: They are easy and useful
10:49:28 <tommd> sw17ch: What is the question exactly?  I've used them in a number of programs.
10:49:30 <sw17ch> tommd: yes, i'd heard a rumor they were getting dropped
10:49:32 <hackagebot> linkcore 0.3 - Combines multiple GHC Core modules into a single module (TimChevalier)
10:49:32 <mauke> > let default = () in ()
10:49:33 <lambdabot>   <no location info>: parse error on input `default'
10:49:34 <tommd> What?
10:49:35 <tommd> Damn!
10:49:36 <Botje> _Ray_: why the buffer?
10:49:37 <mauke> ilid: yes
10:49:39 <sw17ch> tommd: from the Haskell' standard
10:49:46 <sw17ch> though, i don't know where i saw that
10:49:49 <_Ray_> Botje, I couldn't think of any other way
10:49:56 <ilid> mauke: oh, of course it is. i'd completely forgotten!
10:50:01 <tommd> Oh, well - that doesn't mean too much.  Haskell' will recur every year.  GHC will probably keep them.
10:50:04 <_Ray_> Because if I have "fooo" and my string is "foobar", it won't match, but it'll have to backtrack
10:50:10 <ilid> probably the single least-used of all keywords
10:50:16 <Botje> oh, right.
10:50:30 <Botje> _Ray_: still, you could check with isPrefixOf, first
10:50:54 <_Ray_> Yeah, then get the last (length - n) chars
10:51:16 <_Ray_> (I'd have to implement isPrefixOf, however :) )
10:51:40 <aavogt> _Ray_: you can get rid of one case for trimBeginning' by putting a    trimBeginning' [] y _ = y -- case last
10:52:03 <aavogt> since `y' matches the empty list
10:52:20 <sw17ch> tommd: i can't find it, so i may be spreading FUD unnecessarily
10:52:34 <_Ray_> Am I getting rid of it, or just moving it down?
10:54:15 <aavogt> _Ray_: the      trimBeginning' [] y _ = y
10:54:25 <aavogt> case does the same as      trimBeginning' _ [] _ = []
10:55:09 <_Ray_> It does? What about the case [1,2] []?
10:55:17 <aavogt> so you can get rid of line 6, and move line 5 as the last case
10:55:18 <_Ray_> (well, [1,2] [] [])
10:55:31 <_Ray_> it won't match the first one, but it will match the second one
10:55:33 <tommd> sw17ch: Humm, it still says "status: none"  Was it ever actually accepted?  They want to be "conservative" for this first iteration so I wouldn't expect too much that isn't already used to get in.
10:56:42 <sw17ch> mmm
10:57:00 <sw17ch> tommd: i was under the impression that "they" had decided not to pursue implementation
10:57:04 <sw17ch> for Haskell'
10:57:16 <sw17ch> I'd be happy if GHC can let me use them without warning me about overlapping patterns :)
10:57:19 <McManiaC> does haskell have scintifc numbers like 5e-9 ?
10:57:28 <McManiaC> scientific/whatever
10:57:29 <sproingie> > 5e-9
10:57:30 <lambdabot>   5.0e-9
10:57:33 <sw17ch> > 5e-9 :: Double
10:57:34 <lambdabot>   5.0e-9
10:57:42 <mauke> > 5e-9 :: Rational
10:57:43 <lambdabot>   1 % 200000000
10:57:43 <McManiaC> oh
10:57:50 <McManiaC> ok
10:57:50 <McManiaC> ^^
10:57:51 <camio> @faq
10:57:52 <lambdabot> The answer is: Yes! Haskell can do that.
10:57:52 <sproingie> McManiaC: try stuff out with ghci, it's handy
10:57:57 <sw17ch> > round 5e-9
10:57:58 <lambdabot>   0
10:58:05 <ksf>     Couldn't match expected type `GLsizei'
10:58:06 <ksf>            against inferred type `GLint'
10:58:07 <ksf> ugh
10:58:07 <sw17ch> > ciel 5e-9
10:58:08 <lambdabot>   Not in scope: `ciel'
10:58:11 <aavogt> _Ray_: I think I was unclear: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10657#a10658
10:58:12 <sw17ch> > ceil 5e-9
10:58:13 <tommd> > sharpen 5e-9
10:58:13 <lambdabot>   Not in scope: `ceil'
10:58:14 <lambdabot>   Not in scope: `sharpen'
10:58:16 <tommd> damn, had to try
10:58:19 <sw17ch> heh
10:58:21 <McManiaC> ive been using 5e(-9)
10:58:21 <McManiaC> ^^
10:58:26 <sw17ch> hehe
10:58:39 <sw17ch> > 0.00000000000000005
10:58:40 <lambdabot>   5.0e-17
10:58:57 <sproingie> > 0.0000000000000000000000000000000000000000000000000005
10:58:58 <lambdabot>   5.0e-52
10:59:03 <sproingie> yay arbitrary precision
10:59:07 <Cale> > 5e-100000
10:59:08 <_Ray_> aavogt, hrm. I'll try to think about it for a while, see why it works. Thanks :)
10:59:08 <lambdabot>   0.0
10:59:11 <Cale> > 5e-10000000
10:59:16 <lambdabot>   mueval-core: Time limit exceeded
10:59:20 <tommd> > 5e-10000000 :: Rational
10:59:21 <sproingie> aw.  not enough zeros
10:59:25 <lambdabot>   mueval-core: Time limit exceeded
10:59:27 <Cale> ^^ this is cute: it has to convert from Rational
10:59:29 <tommd> > 5e-100000 :: Rational
10:59:33 <lambdabot>   mueval-core: Time limit exceeded
10:59:36 <tommd> damn
10:59:53 <Cale> It takes a long time to construct such a large rational.
11:00:06 <Cale> (well, a Rational with such a large denominator)
11:00:24 <tommd>  Evidently - I just did it locally and it was a irrationally large rational.
11:00:27 <tommd> s/a/an
11:00:36 <PeakerWork> why does it take long to construct a rational with a large denominator?
11:01:07 <aavogt> > 5e10000
11:01:08 <lambdabot>   Infinity
11:01:11 <Cale> because 5e-10000000 means  fromRational (5/(10^10000000))
11:01:14 <tommd> Well... the IO took a while itself...
11:01:26 <_Ray_> aavogt, you're right - if it didn't match the first one, it means the second or first param is [], both of which cases I return [] :)
11:02:08 <PeakerWork> @src (^)
11:02:09 <lambdabot> x ^ 0            =  1
11:02:09 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:02:09 <lambdabot>   where f _ 0 y = y
11:02:09 <lambdabot>         f x n y = g x n
11:02:09 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:02:10 <aavogt> _Ray_: consider the case where y is longer than x though...
11:02:11 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:02:13 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:03:04 <Cale> PeakerWork: Well, I'm not sure it actually translates it in terms of ^
11:03:37 <_Ray_> aavogt, ? It already works with "foo" "foobar"
11:03:47 <Cale> The floating point literal f is equivalent to fromRational (n Ratio.% d), where fromRational is a method in class Fractional and Ratio.% constructs a rational from two integers, as defined in the Ratio library. The integers n and d are chosen so that n/d = f.
11:05:09 <ilid> > 1e-10000 :: Rational
11:05:13 <lambdabot>   1 % 10000000000000000000000000000000000000000000000000000000000000000000000...
11:05:25 <ilid> > 2e-10000 :: Rational
11:05:26 <lambdabot>   1 % 50000000000000000000000000000000000000000000000000000000000000000000000...
11:05:35 <aavogt> _Ray_: yeah, but this version has non-ehaustive patterns though: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10657#a10659 (I'm not sure if you suggested that this version would work)
11:06:06 <ilid> > 1099511627776e-40 :: Rational
11:06:07 <lambdabot>   1 % 9094947017729282379150390625
11:06:16 <aavogt> if you load the file with -Wall (in ghci), then you get warnings about non-ehaustive patterns (and it tells you which ones aren't matched)
11:06:19 <_Ray_> nope, shouldn't work
11:06:24 <_Ray_> ahh
11:06:29 * _Ray_ didn't know that
11:08:31 <en0th> mmorrow: that machine you wrote.. it's *so* dense
11:08:48 <aavogt> > (x + y)^3 :: Expr
11:08:49 <lambdabot>   (x + y) * (x + y) * (x + y)
11:09:04 <aavogt> aww, it doesn't fully expand
11:09:43 <int-e> it can't.
11:10:13 <idnar> "fully"?
11:10:28 <aavogt> idnar: I mean to apply some distributive properties
11:11:02 <int-e> > let x = 0.1; y = 0.2 in (x + y)^3 == x*x*x + x*x*y + x*y*x + x*y*y + y*x*x + y*x*y + y*y*x + y*y*y
11:11:03 <lambdabot>   False
11:11:14 <aavogt> so that I end up with   x^3 + 3x^2y + 3xy^2 + y^3
11:11:21 <en0th> "Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?"
11:11:40 <int-e> (said the economist?)
11:11:55 <aavogt> int-e: I'm not using floats!
11:12:04 --- mode: ChanServ set +o monochrom
11:12:09 --- mode: monochrom set -b *!*@c-24-91-98-29.hsd1.ma.comcast.net
11:12:13 --- mode: monochrom set -o monochrom
11:12:52 <ksf> waaagh
11:12:55 <int-e> aavogt: I know. But Expr is meant to reflect Haskell's actual evaluations. So when I said "it can't" I really meant the compiler.
11:13:15 <ksf> opengl changed floats to glfloats and the type mismatches are now leaking into vector-space
11:14:44 <pumpkin_> bos, dons: there seems to be some GHCI errors in your RWH online version
11:14:57 <pumpkin_> in the bloom filter section (http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html) the little code box contains ghci error messages instead of te intended output
11:15:36 <pumpkin> I guess dons is gone
11:16:23 <aavogt> int-e: I see
11:18:18 <nominolo> pumpkin: bos is asking people to send emails instead for such issues.  irc is too volatile
11:18:38 <en0th> mmorrow: ping
11:18:58 <pumpkin> nominolo: just his regular email address? or is there a special book email address?
11:19:05 <bos> just to me
11:19:12 <pumpkin> aha :)
11:19:29 <monochrom> (Have you told anyone else? Thanks, don't tell anyone else.)
11:19:42 <bos> i don't have the capacity to keep up with irc, in general
11:21:46 <pumpkin> sent :)
11:22:23 <tehgeekmeister> which linux distro has best support for haskell development?  i hear a lot of buzz about arch having a lot of haskell packages, and i'm about to install on a machine whose primary purpose will be haskell development.  any opinions?  does it not matter at all?
11:23:30 <ddarius> tehgeekmeister: If you use cabal install, it doesn't matter too much.  The only significant thing is whether your distribution has recent packages of GHC and keeps them recent, unless you are willing to install that separately as well.
11:24:01 <Cale> tehgeekmeister: I just get the generic linux binary of GHC and then build my own cabal-install anyway, so it doesn't matter all that much.
11:24:18 <tehgeekmeister> ddarius: then which distros are best at staying up to date on ghc releases?
11:24:30 <ddarius> tehgeekmeister: Not Ubuntu.
11:24:46 <Cale> Ubuntu is particularly terrible about keeping up to date with GHC and Haskell related stuff, but I like it for everything else.
11:25:28 <tehgeekmeister> debian?  arch?  gentoo?  i'm not picky about distros as long as they're decent, i just don't want to have to fuss with not having haskell stuffs i want, and having them quickly available.
11:25:42 <aavogt> tehgeekmeister: arch doesn't help you with rebuilding stuff when you update a library that others depend on
11:25:55 <aavogt> but you could just use cabal-install on any distro
11:26:04 <monochrom> arch is best because dons uses it
11:26:27 <monochrom> Just wait til dons switches to Mac too. :)
11:26:33 <tehgeekmeister> understood, i just want my ghc to stay up to date and not have to use anything but the package manager to keep it up to date.
11:26:44 <tehgeekmeister> i use mac myself, but this is for a cloud server
11:28:20 <monochrom> "As Fate has it, in 2014 dons finally switches to Mac. By 2015 mailing lists and IRC channels are filled with 'so, does GHC work on linux yet?' "
11:28:35 <pumpkin> lol
11:28:43 <pumpkin> tehgeekmeister: zomg teh cloud
11:29:19 <tehgeekmeister> pumpkin: cheap root access ftw.
11:30:15 <PeakerWork> ddarius: why not Ubuntu?  Just install the platform or ghc binaries+cabal install on Ubuntu and its fine
11:30:29 <PeakerWork> I ignore Ubuntu's haskell (lack of) support
11:30:39 <pumpkin> you can do that with any other distro
11:31:13 <dmead> is cabal a cpan clone yet?
11:31:22 <pumpkin> dmead: not yet!
11:31:29 <dmead> will it be?
11:31:46 <dmead> or rather
11:31:49 <int-e> hackage might be
11:31:49 <dcoutts> dmead: what is missing to make it a cpan clone?
11:31:50 * dcoutts has never used cpan
11:31:51 <dmead> is it supposed to be?
11:32:06 <dmead> i've never really used cabal
11:32:12 <_zenon_> cpan is quite nice.
11:32:18 <pumpkin> you should. it makes life as a haskeller very pleasant
11:32:22 <dcoutts> dmead: I guess it's hard for us to compare features then :-)
11:32:27 <aavogt> well, cpan is bigger, no?
11:32:32 <dmead> cpan is old and huge
11:32:41 <pumpkin> the huge bit is what I was referring to with the "not yet"
11:32:55 <dmead> i'm just saying that on modern distros, cpan tends to conflict with the package manager
11:32:58 <tommd> Thank goodness
11:33:17 <dmead> like on gentoo, if you need some perl libs you're supposed to install via portage
11:33:34 <dmead> but perl looks at locations for cpan packages
11:33:51 <dmead> so you have sort of a conflict there, the os putting language specific packages in one place
11:33:57 <monochrom> Why must we clone. Our tools exceed cpan.
11:34:11 <dcoutts> dmead: the package registration mechanism is the same between distro and cabal-install
11:34:12 <dmead> and the language tools putting files in another
11:34:25 <dmead> dcoutts, oh?
11:34:34 <dcoutts> dmead: they both use ghc-pkg
11:35:01 <dcoutts> dmead: so there's no difficulty with packages installed by cabal-install depending on packages provided by your distro
11:35:09 <dmead> i wonder if it would be a good idea for cabal to write to portage/apt/etc and vis versa
11:35:15 <dcoutts> I think not
11:35:25 <dmead> no?
11:35:44 <dmead> if you install a package in cabal, why shouldn't it get marked as installed in your PM?
11:35:53 <dcoutts> because it'd be a different thing
11:35:59 <Nafai> dmead: Because it isn't managed by your package manager
11:36:02 <dcoutts> and to pretend otherwise would be wrong
11:36:18 <dmead> shouldn't it be the same thing?
11:36:21 <dcoutts> dmead: some integration might be possible but that's not the right level for it
11:36:29 <dcoutts> dmead: there's no guarantee of it
11:36:29 <dmead> hmm yea
11:36:53 <pumpkin> does anyone have a succinct defintion of parametricity?
11:36:54 <dmead> well you're gonna end up with the same problems as cpan/portage then
11:37:03 <dcoutts> dmead: I don't see why
11:37:15 <dcoutts> pumpkin: see Phil's paper on theorms for free
11:37:38 <ddarius> pumpkin: Parametricity: Naturality.
11:37:40 <dcoutts> dmead: there's an open ticket on getting cabal-install to suggest installing distro packages instead.
11:37:49 <pumpkin> ddarius: wow, pretty succinct :)
11:38:22 <dmead> IMHO, cabal should only be used to install packages that don't exist in the package manager
11:38:28 <dmead> or if there isn't a package manager
11:38:31 <ddarius> Peaker: I use Ubuntu, but it's release cycle is the worst-case scenario for GHC releases.
11:38:32 <dcoutts> dmead: that's not a bad principle
11:38:43 <pumpkin> dmead: why should it even be aware of the package manager?
11:38:58 <dcoutts> dmead: however in practise it's tricky because we install packages as user but distro packages usually require root.
11:39:02 <ksf> reactive has become more responsive. With the example that worked before, that is, the other one still hangs it.
11:39:12 <PeakerWork> ddarius: you don't have to use its package manager for ghc
11:39:24 <dmead> pumpkin, because in gentoo all the packages in cpan also exist in portage and you have to install things twice to get everything to see it
11:39:30 <monochrom> cabal can be told to install files in home directory instead of system directory. IIRC this is even the default. This will not interfere with OS package manager.
11:39:30 <ksf> ...and I'm getting about 100fps @ 26%cpu for a fps display...
11:40:07 <pumpkin> dmead: but the registration process for cabal packages should prevent that in haskell
11:40:17 <dmead> pumpkin, and because if cabal aims to be a package manager then it should defer to the system's native pm
11:40:18 <ddarius> Peaker: I don't when I want the latest GHC, but the requirement was for someone who wants to be able to use the package manager.
11:40:27 <dcoutts> dmead: that's only because gentoo and cpan disagree. By contrast gentoo and cabal/hackage agree nicely.
11:40:41 <ksf> we should have the platform in the distro, and assume $HOME/.cabal is sufficient for the rest.
11:40:42 <monochrom> ghc is aware of both libs in system directory and libs in home directory. ghc does a union of both.
11:40:47 <dmead> dcoutts, sure but thats because of good maintainers
11:40:55 <dmead> it should be automated is all i'm saying
11:41:00 <dcoutts> dmead: no, it's because there's one correct way to do it.
11:41:08 <monochrom> "cabal is a package manager" is just word mincing.
11:41:11 <dmead> dcoutts, eh?
11:41:12 <dcoutts> dmead: distros would have to work pretty hard to get it wrong.
11:41:26 <ksf> ...distros can then pack up extra libs as they need them if they want to package up an app. there's no need for them to go full hackage.
11:41:45 <dcoutts> dmead: with perl they have multiple lib dirs and they don't agree on the same one. We do not have that problem.
11:41:53 <dmead> ah
11:41:56 <dmead> well thats good
11:42:37 <dcoutts> dmead: so cabal-install will not (usually) re-install packages that your distro already installed
11:42:42 <dcoutts> because it can see them
11:42:46 <ksf> does cpan even distinguish between installing a package and fetching it from cpan?
11:42:53 <pumpkin> "If t is a closed term of type T, then (t, t) is a member of the relation corresponding to the type T"
11:43:08 <dcoutts> pumpkin: yeah, wonderfully abstract :-)
11:43:09 <ddarius> Hapexamendios
11:43:29 <dcoutts> pumpkin: took me quite a while to connect that definition to my previous intuition.
11:43:41 <pumpkin> hmm
11:44:02 <dcoutts> pumpkin: work through a couple free theorem examples from Phil's paper.
11:44:22 <pumpkin> it seems obvious but maybe I'm missing something, or have been exposed to it without knowing its name
11:44:27 <pumpkin> I'll try that, thanks
11:44:35 <dcoutts> expanding (t,t) `elem` T to get the free theorem
11:44:47 <dcoutts> according to the structure of the relation T
11:48:45 <PeakerWork> @index Word16
11:48:46 <lambdabot> Data.Word, Foreign
11:49:27 <ksf> zomg. on the first runs, it worked, now it gobbles memory.
11:49:41 <ksf> ...without me changing a thing. maybe the X state, but not more
11:50:00 <ksf> preflex, seen conal
11:50:00 <preflex>  conal was last seen on #haskell 2 days, 3 hours, 58 minutes and 44 seconds ago, saying: Saizan: which makes RT easier and less interesting.
11:51:42 <c_wraith> so, what is the preferred way to deal with code that can have exceptional conditions ("not allowed to do that in this state") and errors ("you called this with an illegal argument")
11:52:01 <tuukkah> hey bos, did you get my message?
11:52:13 <Baughn> c_wraith: Depends. How probably are the conditions, and what shoudl be done if they occur?
11:52:21 <bos> tuukkah: i did, thanks. will take a look tonight or tomorrow.
11:52:22 <pumpkin> c_wraith: encode your requirements in types (if necessary use agda for this) and never throw any errors, but require proofs that the exceptional conditions are not present
11:52:36 <pumpkin> c_wraith: just kidding, by the way :P but only partially
11:52:37 <danco> lol
11:52:39 <Baughn> c_wraith: ..well, either exceptions or returning Maybe/Either
11:53:13 <c_wraith> This is for a client/server thing.  Exceptions should be reported to the client.  Errors indicate that I screwed up my code, and should be logged.
11:53:31 <tuukkah> bos, ok, cool. i was just wondering if it's a completely wrong approach to implement this or something
11:53:35 <c_wraith> Exceptions indicate that the client asked for something illegal.
11:53:44 <danco> pumpkin: would the client stream the proof over to the server?
11:53:58 <pumpkin> danco: certainly! a client that asks for something impossible cannot exist
11:54:03 <PeakerWork> After running "cabal install" in the SDL-gfx package source successfully,  ghci fails to import any of its modules with the error "module `Graphics.UI.SDL.Primitives' is not loaded" or any other module I try. Any idea?
11:54:13 <bos> tuukkah: i'll let you know when i look :-)
11:54:15 <danco> the client is always (proved) correct
11:54:20 <pumpkin> yep
11:54:22 <tuukkah> bos :-)
11:54:44 <SamB_XP> what happens if something changes?
11:54:44 <Baughn> PeakerWork: And if you try to import Graphics.UI.SDL.Primitives?
11:54:56 <PeakerWork> Baughn: that's what I try
11:55:01 <FunctorSalad> PeakerWork: start ghci in a different directory than SDL-gfx's one?
11:55:02 <SamB_XP> i.e., one of the assumptions on which the proof was based goes 404?
11:55:14 <PeakerWork> FunctorSalad: oh, thanks!
11:55:19 <Baughn> c_wraith: I'd probably invent a ClientError type, throw whenever I feel like it, and add a catch at the low-level i/o level
11:55:24 <danco> i think we've proven that total languages are practical
11:55:26 <pumpkin> SamB_XP: nothing changes
11:55:38 <dcoutts> PeakerWork: change directory, you've got the files locally.
11:55:39 <PeakerWork> heh, why does it fail when in that directory? It should work when importing from there too
11:55:50 <PeakerWork> dcoutts: thanks, why wouldn't the local files work though?
11:56:02 <dcoutts> PeakerWork: because local files take precedence over ones from packages.
11:56:03 <danco> is anyone working on total IO?
11:56:05 <FunctorSalad> PeakerWork: yes the error message is slightly obscure :D
11:56:13 <dcoutts> PeakerWork: and you don't have the local files loaded.
11:56:21 <SamB_XP> danco: yes, I've nearly finished my library for inputting the entire world
11:56:25 <ksf> probably because the Primitives are a generated .hs file, and thus ghci can't find it because it doesn't exist.
11:56:26 <PeakerWork> dcoutts: what does "loaded" mean?
11:56:27 <SamB_XP> I just need some more RAM
11:56:35 <PeakerWork> dcoutts: why can't ghci load it when I import?
11:56:37 <Baughn> dcoutts: Shouldn't it act as if you haven't installed it at all, then?
11:56:47 <pumpkin> SamB_XP: will the RAM contain itself?
11:56:49 <dcoutts> PeakerWork: the way you normally load files in ghci, using :l
11:56:52 <FunctorSalad> dcoutts: I used to interpret it as "tried to load it, but failed"
11:56:57 <Baughn> pumpkin: That's where tying the knot comes in handy
11:56:59 <SamB_XP> pumpkin: okay, I need a *lot* more RAM!
11:57:00 <danco> SamB_XP: just connect it to the semantic web, what could possibly go wrong
11:57:08 <pumpkin> oh, Baughn does have a point
11:57:09 <PeakerWork> dcoutts: oh, and every installed package is automagically loaded?
11:57:12 <pumpkin> it can refer to itself :)
11:57:17 <pumpkin>  without containing itself
11:57:23 <SamB_XP> danco: the URIs involved could become intractibly large ...
11:57:26 <ksf> tying the knot can refer to itself?
11:57:30 <Baughn> Sure
11:57:35 <dcoutts> PeakerWork: yes, that's why you can switch to them using :module without having :load ed them first
11:57:43 <pumpkin> ksf: that's what knot-tying is for!
11:57:51 <PeakerWork> dcoutts: aha, great. Can go on wrapping more SDL functions then
11:58:08 <ksf> so how can I tie a know, when the instructions say that I should tie a knot?
11:58:30 <danco> tongue tied
11:58:52 <dcoutts> FunctorSalad: it's more like, "I can't switch to that module because the source file isn't loaded (and I'm ignoring the module of the same name because the local file takes precedence)".
11:58:59 <SamB_XP> ksf: "tying the knot" usually refers to a way of introducing circularity while avoiding _|_
11:59:20 <dcoutts> Baughn: actually that's exactly how it is acting.
11:59:24 <Baughn> ksf: You can look up how to tie a knot in the book of knot-tying instructions, which you write using the information yo just looked up
11:59:32 <SamB_XP> it may be a section heading or the title of a paper
12:00:06 <Baughn> > fix (const "knot")
12:00:07 <lambdabot>   "knot"
12:00:55 <ksf> > fix . fix . const $ "knot"
12:00:56 * danco hates when the cleanest solution to a problem involves "undefined"
12:00:56 <lambdabot>   Couldn't match expected type `a -> a'
12:00:56 <lambdabot>         against inferred type `[GHC.T...
12:01:01 <danco> maybe i'll get used to it
12:01:13 <ksf> see? tying the knot can't refer to tying the knot.
12:01:22 <Cale> danco: Like what?
12:01:40 <opqdonut> tying the knot is pretty clean
12:01:48 <pumpkin> tying the knot is awesome
12:02:16 <opqdonut> i still can't see it as someting nontrivial
12:02:37 <danco> Cale: like making a Map of (a -> _|_) out of a Set so that you can Map.difference.  well i guess you could use () there
12:02:47 * danco rethinks life
12:02:51 <opqdonut> well er, it is nontrivial, but somehow i feel giving it a name makes it bigger than it ought to
12:03:23 <Cale> danco: yeah, use ()
12:03:23 <opqdonut> the cool thing is that let is recursive, ttk is just a side effect
12:03:32 <Asztal> if I have a graph where the recursion is explicit (IORefs) is it possible to turn it into a purely-recursive structure?
12:03:42 <Cale> danco: that seems awkward...
12:04:01 <Cale> danco: Why not use set difference?
12:04:18 <Cale> :t Data.Set.difference
12:04:19 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
12:04:40 <pumpkin> Asztal: yep
12:05:38 <Baughn> Asztal: Normally. However, /modifying/ such a structure is hard.
12:05:46 <Asztal> pumpkin: The graph isn't stored in node/edge form, though, which probably doesn't help.
12:06:15 <pumpkin> Baughn: even iterating over it can be difficult, unless you secretly keep stablenames around to prevent yourself from looping infinitely
12:06:33 <Baughn> pumpkin: Now, now. That's what reallyUnsafePointerEquality# is for.
12:06:39 <pumpkin> lol
12:06:47 <opqdonut> :D
12:06:51 <Baughn> It's perfectly safe if you disable the GC first. :PO
12:07:10 <pumpkin> Asztal: so how are you storing your graph?
12:07:29 <danco> Cale: i can't find the irc log but once someone wanted to remove all instances of anything in some Set from a MultiSet
12:07:38 <Cale> ah
12:07:51 <danco> my solution was to convert to a map using undefined
12:08:09 <Cale> Yeah, and you would need undefined there to get the right kind of polymorphism
12:08:15 <danco> ya that was it
12:08:31 <danco> and i didn't know if i should feel ashamed or awesome about that
12:08:37 <pumpkin> undefined is also a nice way of showing that "you should definitely not be looking at this"
12:08:46 <pumpkin> as a form of implicit documentation
12:08:47 <ddarius> The interaction of call-by-name (v. call-by-need or call-by-value) and mutation is interesting.
12:09:00 <opqdonut> () is a nice way of showing "you'll just get bored if you look at this"
12:09:29 <ddarius> opqdonut: () is the Sierpinski space!
12:09:40 <danco> spindoctor
12:10:00 <Baughn> newBlackHole radius = EventHorizon radius (Core undefined)
12:10:58 <Rwerwe> who know how we can bypassing DEP in vista ?
12:12:07 <danco> hacking in haskell
12:12:48 * ksf prefers bypassing vista entirely
12:12:49 <flazz> how can i convert a string to a [Word8] i'm assuming there is something to convert a Char to Word8, then i can map something. am i on the right track?
12:13:01 <pumpkin> flazz: yep
12:13:06 <pumpkin> flazz: note that it's lossy
12:13:23 <pumpkin> (as a map)
12:13:38 <Baughn> flazz: What are you trying to do, exactly? Why a [Word8]?
12:13:40 <monochrom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4351#a4351  shows an example of tying the knot
12:13:40 <danco> you could utf8 encode (or other encodings) losslessly
12:13:42 <Berengal_> You can use ord to convert to an Integer, and then convert the Integer into a [Word8] and concatenate those
12:13:48 <ksf> > map (fromIntegral.ord) "foo"
12:13:49 <lambdabot>   [102,111,111]
12:13:50 <flazz> i'm trying to md5 and sha1 stuff
12:13:51 <pumpkin> danco: yeah, but that'd be a concatmap
12:13:53 <Baughn> flazz: You'd normally use a bytestring
12:14:15 <ksf> ord converts to an int
12:14:25 <ksf> it's fromEnum specialized to chars
12:14:43 <Baughn> > chr 24000
12:14:44 <lambdabot>   '\24000'
12:14:47 <Baughn> ..yeah.
12:15:08 <ksf> there's Data.Text, too.
12:15:10 <Berengal_> Well, converting Int to [Word8] is even easier
12:15:39 <ksf> ...which uses a Word16 bytestring, iirc.
12:15:49 <flazz> i think my problem lies in that i want to use interact . mySha1Func
12:16:05 <ksf> you can use Bytestring's interact.
12:16:09 <pumpkin> not sure you want to compose tem
12:16:51 <Baughn> flazz: I don't think you want that. For sha-1, you'll want binary input.
12:17:09 <Baughn> flazz: Try Data.ByteString.Lazy.interact
12:17:27 <ksf> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.5/doc/html/Data-ByteString-Lazy.html#v%3Ainteract
12:17:29 <ksf> that one.
12:17:41 <brad_larsen> I'm preparing to release my first Hackage package, a pure priority queue.
12:17:49 <brad_larsen> A couple questions:
12:18:05 <flazz> bytestream seems to be a C-like array underneath, is that true, close to true?
12:18:20 <nominolo> flazz: true
12:18:20 <ksf> yep.... but a lazy one is chunked.
12:18:33 <brad_larsen> (1) How should I integrate my QuickCheck test program with the cabal package?
12:18:33 <ksf> so you get buffered I/O for free.
12:18:52 <Baughn> flazz: A strict bytestring is an array. A lazy bytestring is a list of strict bytestrings, basically.
12:18:53 <brad_larsen> (2) suggestions for naming the package?  Data.PriorityQueue is already taken, and I don't want a namespace conflict.
12:19:04 <ksf> right now, I'd recommend a separate package.
12:19:06 <pumpkin> brad_larsen: a common approach I've seen is to take a flag that enables the quickcheck properties (and adds quickcheck as a dependency, which you don't normally want)
12:19:26 <ksf> well if it does essentially the same you can take that name, as long as you use a different package name
12:19:30 <brad_larsen> pumpkin: exactly.  quickcheck shouldn't be a dependency, unless one wants to run the tests
12:19:38 <danco> how do i figure out why base is hidden (i need Data.Data) even though build-depends has base in it?
12:19:40 <pumpkin> check out cabal flags
12:20:07 <Baughn> danco: Which base?
12:20:13 <brad_larsen> ksf: yeah, but that makes it impossible to use both packages in the same module, no?
12:20:20 <Baughn> danco: Cabal defaults to base-3, you may want to say base >= 4
12:20:25 <ksf> brad_larsen, yep.
12:20:26 <brad_larsen> ksf: not that I am expecting someone to do that :-)
12:20:40 <danco> Baughn: ok, but isn't it weird that the error message is that base is hidden?
12:20:59 <hackagebot> hpage 0.2.2 - A scrapbook for Haskell developers (FernandoBenavides)
12:20:59 <Baughn> danco: Yes, that's a wart, if that in fact is the problem.
12:20:59 <danco> that's a separate bug?
12:21:02 <danco> ok
12:21:59 <dcoutts> danco: no, it's because there is both base 3 and 4 installed.
12:22:22 <dcoutts> danco: when you're using base 3, then base 4 is hidden. The hidden one contains the module you're trying to use.
12:22:49 <danco> it seems like the error message should disambiguate then
12:22:50 <Baughn> It's still a bug of sorts. Cabal should say something like "that module is in base-4, but you have requested base-3"
12:22:56 <conal> anyone here use swik.net?  i'm trying to fix a typo, but I don't see an "edit" button and can't find how to register.
12:23:23 <dcoutts> Baughn: yep, that's fair enough. Feel free to file a bug (against ghc).
12:23:51 <Baughn> Roger roger
12:25:52 <mmorrow> en0th: pong
12:26:23 <pumpkin> conal: not really sure what it is even, except that it pollutes my search results a lot and I hate it
12:26:45 <ddarius> pumpkin: Burn it to the ground
12:26:57 <aavogt> @hoogle setEnvironment
12:26:57 <lambdabot> No results found
12:27:14 <conal> pumpkin: i guess that description captures my relationship with swik also.
12:27:28 <FunctorSalad> haha thirded
12:27:35 <aavogt> is there some way to set the environment that a command is run in, or to set an environment variable?
12:27:43 <FunctorSalad> but to be fair sometimes the result was helpful
12:27:57 <Rwerwe> who know buffer overflow exploitation?
12:28:08 <aavogt> ah, there's System.Posix.Env
12:28:12 <Rwerwe> please help me
12:28:25 <PeakerWork> Rwerwe: what does that have to do with Haskell?
12:28:35 <aavogt> > cycle [] -- like this?
12:28:36 <lambdabot>   * Exception: Prelude.cycle: empty list
12:28:45 <aavogt> > repeat [] -- like this?
12:28:46 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
12:28:55 <aavogt> see, it "overflowed"
12:29:13 <Rwerwe> yes
12:29:32 <Rwerwe> but do yu know how we can exploiting overflow in new platform?
12:29:46 <Rwerwe> such as vista sp2 , win 7 ....
12:29:47 <pumpkin> Rwerwe: I think #scriptkiddie will be more useful than this channel
12:29:49 <PeakerWork> Rwerwe: why are you asking #haskell ?
12:30:08 <Baughn> Rwerwe: Haskell doesn't even allow overflows, never mind exploiting them
12:30:42 <aavogt> Baughn: there is the FFI though...
12:30:48 <ksf> if http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10667#a10667 first works (albeit with qute high usage) and ceases to work after I do XHB stuff, It can't really be reactive that's messing up. I hope so.
12:30:56 <aavogt> but that's beside the point
12:31:24 <Baughn> aavogt: Somewhat. The point is, of course, that code that could potentially cause overflows is /extraordinary/ in haskell, and can thus be graned the depth of inspection it deserves.
12:32:31 <ksf> but it's still strange, as everything else continues to work like usual. and GLUT shouldn't be confused by X.
12:33:04 <Baughn> ksf: Oh, you're using Reactive? Don't use Reactive.
12:33:16 <Baughn> ksf: I'm pretty sure you're running into bugs, there.
12:33:25 <ksf> I know.
12:33:37 <pumpkin> Rwerwe: how did you choose #haskell and #haskell-overflow? did you just see the word "overflow" in /list and join that, and then join the other channel with a word in common with your overflow channel?
12:33:52 <PeakerWork> pumpkin: interesting theory :)
12:34:11 <ksf> the point is that I was glad that I got constant, instead of jiggery fps with the new reactive, but now it stopped working.
12:34:36 <Rwerwe> <pumpkin>  : how we can find channel that dicussion about overflow ?
12:35:12 <pumpkin> Rwerwe: your best bet might be #openrce or #assembly but they aren't very talkative channels in general.
12:36:01 <Rwerwe> Tnx pumpkin
12:36:06 <pumpkin> Rwerwe: but keep in mind that if your goal is "I want to hack" you're starting out wrong
12:36:37 <Rwerwe> why?
12:37:20 <ksf> http://catb.org/~esr/faqs/hacker-howto.html
12:38:11 <PeakerWork> ksf: intentionally misleading him into a better path? :)
12:38:31 <pumpkin> You need a lot of background knowledge on how systems work before you can reasonably start "hacking" things in that sense. "I want to make words appear on my friend's computer screen so he's like, WTF" is doomed to failure ;)
12:38:35 <ksf> well he can still become a black-hat.
12:39:14 <ksf> becoming a hacker gives him a choice, staying a script kiddie doesn't.
12:39:20 <Rwerwe> look man .
12:39:31 <Rwerwe> is ask the question for
12:39:38 <Rwerwe> know is there any hacker?
12:39:43 <Rwerwe> that's all
12:39:49 <ksf> there are plenty of those here.
12:40:07 <Rwerwe> for example?
12:40:33 <burp> lol I like this
12:40:54 <Baughn> Heh. I suspect my attempts at implementing FRP counts as a hack. :P
12:41:08 * ksf hacked reactive until it broke
12:41:22 <ksf> I just hacked fieldtrip to run with the new opengl, too.
12:41:33 <pumpkin> Rwerwe: I doubt you'll find many "black-hat" hackers in here. That's why we told you this was the wrong place
12:41:37 <ksf> ...which reminds me...
12:41:43 <ksf> conal, do you want to have some fixes?
12:42:04 <ksf> ...or any hats, for that matter.
12:42:17 <pumpkin> I'm a hat
12:42:21 <Zao> My hat is green. What does that make me?
12:42:21 <pumpkin> not sure what color it is
12:42:31 <pumpkin> probably orange, I'd guess
12:42:40 <Rwerwe> :)))
12:45:50 <ksf> but... but... I really want to use frp.
12:46:11 <ksf> I'm sick of imagining ways to do push-based stuff using stm.
12:46:39 <idnar> yeah, I want FRP too :/
12:46:46 <pumpkin> don't we all!
12:46:49 <idnar> except I'm not even at FP yet
12:46:51 <pumpkin> except maybe Rwerwe
12:47:23 <idnar> I'm sure FRP is great for implementing buffer overflow exploits ;)
12:47:42 <opqdonut> :D
12:48:36 <ksf> mhhh laser chicken
12:49:48 <ksf> hacking food is an invaluable skill, btw.
12:49:54 * ddarius doesn't wear hats.
12:50:16 <pumpkin> clearly you aren't a hax0r
12:50:55 <aavogt> @unelite hax0r
12:50:55 <lambdabot> HAX0r
12:51:04 <ksf> hey I'm using sharp knives!
12:51:14 <pumpkin> @@ @unelite @elite @vixen
12:51:15 <lambdabot> Plugin `compose' failed with: Unknown command: "unelite"
12:51:17 <FunctorSalad> @hoogle HAXml
12:51:17 <lambdabot> No results found
12:51:19 <pumpkin> oh
12:51:55 <aavogt> @commands
12:51:55 <lambdabot> Unknown command, try @list
12:51:57 <aavogt> @list
12:51:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:52:32 <ksf> who claimed that you can't do buffer overflows, btw?
12:52:33 <Baughn> @@ unelite elite Howdy, neighbour
12:52:33 <lambdabot>  unelite elite Howdy, neighbour
12:52:41 <Baughn> @. unelite elite Howdy, neighbour
12:52:42 <lambdabot> Plugin `compose' failed with: Unknown command: "unelite"
12:52:43 <Cale> Is laser chicken a game of daring played by photons to see which one has better nerves?
12:53:01 <ksf> with a sufficiently unsafe combination of Ptrs and run-time code generation that's very well possible.
12:53:06 <aavogt> @. @vixen @nixon
12:53:06 <lambdabot> Plugin `compose' failed with: Unknown command: "@vixen"
12:53:18 <Baughn> @. pl . pl pl \x -> x + 1
12:53:18 <lambdabot> (1 +)
12:53:23 * ddarius doesn't think "colliding" with another photon would be particularly scary for a photon.
12:53:24 <FunctorSalad> ksf: unsafeCoerce?
12:53:37 <pumpkin> ksf: sure, if you do impure stuff, you can get overflows
12:53:45 <pumpkin> I don't think anyone's denying that :P
12:53:47 <Baughn> ddarius: "Another" photon?
12:53:57 <ksf> http://www.jargon.net/jargonfile/l/laserchicken.html
12:54:08 <ksf> but mine's not traditional, it's indian.
12:55:35 * ddarius is a shrimp more than a chicken guy.
12:56:01 <en0th> mmorrow! i cannot even understand the first line!
12:56:40 <monochrom> laser shrimp
12:57:11 <FunctorSalad> plankton with LASERS mounted ...
12:58:13 <newsham> i remember some talk about possibly targetting haskell->JVM.   is there anything public and usable?
12:59:16 <HugoDaniel> takusen + mssql = :(
12:59:35 <pumpkin> newsham: lambdavm, but I think it bitrotted
13:00:01 <pumpkin> newsham: it might get a lot more pleasant with 1.7 though, since they're rumored to support tail calls
13:01:11 <HugoDaniel> mssql = :( :(
13:01:13 <HugoDaniel> takusen = :)
13:01:21 <HugoDaniel> takusen + mssql = :(
13:01:23 <ksf> haskell on the jvm would safe me from learning scala
13:01:47 * ddarius hopes to never deal with Java or the JVM ever again.
13:01:56 <ksf> is smiley arithmetic formally defined?
13:02:29 <newsham> I dont suppose there's a dalvik target ;-)
13:02:41 <pumpkin> I doubt it
13:03:05 <newsham> its not a stack machine, so that might be an easier target
13:03:56 <ksf> data Num = :) Num | :| | :( Num
13:04:37 <newsham> :) :) :( :|
13:05:01 <FunctorSalad> ksf: not legal haskell :(
13:05:24 <Peaker> ddarius, what's so bad about the JVM? (I don't know the JVM, just asking)
13:05:59 <ketil> Hmm.. darcs 2.3.0 insists on _darcs/pristine, but all I have is _darcs/current.  Is renaming safe, is there a compatibility option, or do I have to dig up an older darcs?
13:06:10 <ddarius> Peaker: It was made in 1995 (or earlier) and hasn't been significantly changed since and it wasn't that great to begin with.
13:06:22 * ketil is unburying old repos today.
13:06:26 <ksf> :/ is.
13:06:35 <newsham> when was the typed lambda calculus made?
13:06:46 <FunctorSalad> :/ no way.
13:06:48 <ddarius> 1920's or 30's
13:06:52 <Peaker> ddarius, well, it did supposedly change, optimization wise
13:07:15 <Peaker> yeah, something holding for a while should be a good sign of its quality :)
13:07:17 <ksf> untyped was 32
13:07:59 <ksf> there's been a lot changes to the back-end side, like jit and stuff
13:08:07 <ksf> the bytecode's a mess, though.
13:08:21 <ksf> its a sligtly less awkward syntax for java.
13:08:53 <FunctorSalad> typed is older than untyped?
13:09:00 <ksf> untyped is older
13:09:21 <ksf> because typed isn't trivially turing complete, I guess.
13:09:39 <FunctorSalad> http://www-maths.swan.ac.uk/staff/jrh/papers/JRHHislamWeb.pdf
13:10:04 <ddarius> The notion of "Turing-completeness" didn't exist at that time.
13:10:26 <ksf> ...but church wanted to do the same thing as turing.
13:10:34 <FunctorSalad> aiui untyped lc was devised as a model for computability
13:10:36 <FunctorSalad> yes
13:10:37 <ksf> ...so they ended up with equivalent expressive systems.
13:10:43 <newsham> hrmm, apparently there's this CAL thing which is "haskell-like" and does jvm
13:10:50 <ddarius> ksf: No he didn't.  He wanted a system for logic and he was upset when he discovered Y.
13:11:22 <ksf> ...but in the context of computation?
13:11:24 <ddarius> (Well, depending on what you intended Turing's goal was)
13:11:46 <ddarius> Church invented the typed lambda calculus to exorcise Y.
13:11:50 <ksf> turing was concerned with theoretical aspects of equivalence of expressive power.
13:11:59 <sproingie> what did he hate about Y?
13:12:13 <ksf> Y Y isn't strongly normalizing.
13:12:23 <SamB_XP_> it makes the logic unsound?
13:12:27 <ksf> ...well, the whole calculus isn't.
13:12:38 <newsham> samb: the equivalence to logic wasnt yet explored, was it?
13:12:39 <ilid> anyone got any thoughts on a good way to represent coordinates in 3D hyperbolic space?
13:13:44 <ksf> most things that claim to be haskell-like aren't lazy and pure.
13:13:57 <FunctorSalad> "Around 1928 he began to build a formal system with the aim of providing a foundation for logic which would be more natural than Russell’s type theory or Zermelo’s set theory, and would not contain free variables ..."
13:14:08 <newsham> cal claims to be "the java framework for lazy functional programming"
13:14:13 <FunctorSalad> (so ddarius was right..)
13:14:25 <pumpkin> ddarius is always right
13:14:32 <FunctorSalad> nop
13:14:40 <newsham> ddarius' irc client typehcecks before sending
13:14:46 <FunctorSalad> but how does set theory contain free variables anymore than lc?
13:15:46 <newsham> is it talking about SK?
13:16:29 <ksf> SK is quite recent, compared to lc
13:16:46 <FunctorSalad> newsham: no it talks about combinatory logic before that
13:17:11 <newsham> no free points for me
13:17:25 <FunctorSalad> ksf: what? 1924
13:17:44 <absentia> what's the easiest.. slowest.. most gentle introduction to haskell (ebook/tutorial, etc) ...
13:17:56 <newsham> absentia: i like two-dozen short lessons
13:18:12 <ksf> ...then it's the mapping that's quite recent
13:18:17 <newsham> http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
13:18:33 <absentia> hey tim
13:18:36 <newsham> hi
13:18:51 * absentia is bored out of his mind.
13:19:08 <newsham> have you read all of conal and sigfpe's blogs yet?
13:19:09 <pumpkin> absentia: #haskell is the easiest way
13:20:30 <absentia> no
13:20:52 * tommd1 nickserv ghost tommd mynameistom
13:20:56 <tommd1> oops
13:21:04 <en0th> mmorrow: QQ
13:21:12 <mmorrow> en0th: :)
13:21:35 <aavogt> so, you name is tom?
13:21:46 <copumpkin> that's a pretty epic password
13:21:49 <tommd1> yep
13:21:50 <copumpkin> you need a monic one though
13:21:51 <mmorrow> gah, hpaste needs recaptcha
13:21:57 <copumpkin> mmorrow: yep
13:22:03 <Twey> absentia: Probably http://www.learnyouahaskell.com/
13:22:06 <Twey> It has elephants.
13:22:15 <en0th> mmorrow: woot! you defined S (s -> (a,s)) here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4356#a4356
13:22:20 <mmorrow> en0th: do you see how pop/push work?
13:22:37 <en0th> i'm still at type def, dont bash me :(
13:22:43 <absentia> ya, I have learn me up.. and real world.. and etuff...
13:22:47 * Twey chuckles.
13:23:18 <mmorrow> en0th: :) not bashing, just attacking the root of the issue
13:23:24 <newsham> two dozen short lessons is definitely slower and gentler.
13:24:15 <en0th> mmorrow: yeah. i understand globally what it's supposed to do, but i'd like  to watch carefully the monadic thing
13:24:21 <mmorrow> en0th: that entire module basically builds on top of pop and push, so if you really understand what those are doing/how they're doing it, that'd half the battle
13:24:42 <mmorrow> right, so say for pop
13:25:07 <mmorrow> pop = do x:s <- gets stack; modify(\e->e{stack = s}); return x
13:25:15 <mmorrow> with
13:25:21 <mmorrow> data Mach a = Mach {stack  :: [a]}
13:25:59 <mmorrow> well, backing up, the constructor in the State monad is kind of confusing at first
13:26:39 <mmorrow> what'd really happening is you're building a new function closure every time you get/gets/set/(>>=)/etc
13:26:42 <mmorrow> *what's
13:26:59 <mmorrow> and you're just pretending you have the `s'
13:27:16 <mmorrow> by doing, every expression,  foo = \s -> ....
13:27:30 <mmorrow> foo >>= bar
13:28:09 <mmorrow> \s -> let (a,s2) = foo s in let (b,s3) = bar s2 in ((a,b),s3)
13:28:41 <mmorrow> so you keep making functions that expect some `s' as an arg when they eventually get run
13:29:18 <mmorrow> and you compose them by feeding the `s' that somebody hands to you, after you've had your way with it, to the next function
13:29:27 <sproingie> it's kinda like a pipe
13:29:35 <mmorrow> get = \s -> (s,s)
13:29:42 <mmorrow> set s = \_ -> ((),s)
13:29:51 <mmorrow> gets f = \s -> (f s,s)
13:29:52 <en0th> why you need a function to a tuple s -> (a,s)  ?
13:30:09 <sproingie> you need a function to do anything
13:30:15 <mmorrow> the `a' if for the result of that step, and the `s' is for the modified state
13:30:19 <mmorrow> s/if/is/
13:30:37 <mmorrow> @type State next
13:30:38 <lambdabot> forall s. (RandomGen s) => State s Int
13:30:46 <sproingie> ?
13:30:49 <mmorrow> > next (mkStdGen 949754)
13:30:50 <lambdabot>   (1496235307,1496275999 40692)
13:31:14 <aavogt> en0th: you have to get the state from the previous computation (or however you supply the initial state)
13:31:36 <mmorrow> > let g = mkStdGen 93284 in let (r,g') = next g in let (r',g'') = next g' in ((r',r'),g'')
13:31:37 <lambdabot>   ((1359838345,1359838345),868193647 1655838864)
13:31:44 <mmorrow> is the basic pattern
13:32:25 <sproingie> might be easier to grok CPS, then you see it as simply sending the state to the next continuation
13:32:58 <mmorrow> en0th: the key thing is though, by always building a function like (\s -> .....) you're essentially saying "assuming that someone gives me a state argument, i'll doing ..... with it"
13:33:26 <mmorrow> and if every function assumes that, then you know how to compose them
13:34:12 <mmorrow> so     pop = \(Mach (x:stack) asdf) -> (x, Mach stack asdf)
13:35:15 <mmorrow> push x = \(Mach stack asdf) -> ((),Mach (x:stack) asdf)
13:35:36 <en0th> mm ok i understand the pattern. Probably the problem is that i cannot read haskell so naturally, and i have always to go back
13:36:51 <en0th> like, this one is confusing: get = S (\s -> (s,s))
13:37:04 <en0th> is it somewhat higher order?
13:37:35 <aavogt> S wraps the function
13:37:40 <mmorrow> en0th: yeah, it took me about 8 months of using haskell constantly before i could do something useful without having to be making random guesses, look stuff up, and battle with type errors
13:37:55 <mmorrow> @type Just (\s -> (s,s))
13:37:55 <lambdabot> forall t. Maybe (t -> (t, t))
13:37:59 <MacCoaster> how can i apply type aliasing with a list of generic 'Macro'.. like i have data (eq a, Show a) => SExpr a = ... | ... | Macro a (SExpr a) deriving (Eq, Show)... i try type Macros a = [Macro a] but the compiler doesnt like it?
13:38:00 <mmorrow> @type State (\s -> (s,s))
13:38:01 <lambdabot> forall s. State s s
13:38:10 <CalJohn> mmorrow: you saying that makes me feel better
13:38:10 <mmorrow> @type [\s -> (s,s)]
13:38:11 <lambdabot> forall t. [t -> (t, t)]
13:38:24 <CalJohn> (as a late beginner)
13:38:37 <en0th> okay, a list of functions from t to t,t
13:38:41 <mmorrow> CalJohn: :)
13:39:42 <mmorrow> en0th: so the S constructor is just a box for the function, for convenience (and since class instances can't overlap, if you made the type (s -> (a,s)) and instance of Monad, you'd immediately be in overlap error hell)
13:40:33 <aavogt> and you want to make the use of State explicit
13:40:41 <mmorrow> instance Monad (s -> (a,s)) where return a = \s -> (a,s); g >>= k = \s -> case g s of (a,s') -> k a s'
13:42:05 <mmorrow> pop >>= push ===>  (\(x:stack) -> (x,stack)) >>= (\x -> (\stack -> ((),x:stack)))
13:42:49 <aavogt> otherwise:   get 'x' = ('x','x') -- which is made more explicit by the runState
13:42:59 <mmorrow> \stack -> case (\(x:s)->(x,s)) stack of (x,s) -> (\x s -> ((),x:s)) x s
13:43:31 <mmorrow> (\(x:s) -> ((),x:s)) stack
13:43:42 <mmorrow> (\s -> ((),s)) stack
13:43:47 <mmorrow> ((),stack)
13:43:49 <mmorrow> :)
13:44:08 <monochrom> Let the symbols do the work.
13:44:19 <mmorrow> (not that that you're explicitly imagining that or anything of course)
13:44:27 <mmorrow> (while using the monad)
13:44:40 <mmorrow> which is the whole point/convenience of the monad
13:45:45 <mmorrow> err, that really should've been
13:45:51 <mmorrow> \stack -> ((),stack)
13:45:56 <en0th> i misread everything. I thought that S was some kind of data.
13:46:02 * jmcarthur discovered that the reader monad can be used to implement a kind of stack
13:46:45 <jmcarthur> i had never used the local function before yesterday
13:47:06 <aavogt> @type local
13:47:07 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
13:47:44 <jmcarthur> i'm using it to implement a transformation matrix stack
13:47:47 <aavogt> jmcarthur: so the only difference is that there isn't a built in way to get the final stack out?
13:47:53 <jmcarthur> basically
13:48:12 <jmcarthur> and the stack must be identical entering and leaving a call to local, of course
13:48:27 <jmcarthur> it's not really like a state monad
13:49:04 <mmorrow> jmcarthur: it can be if you never leave local ;)
13:49:09 <jmcarthur> heh
13:49:14 <mmorrow> cps
13:49:20 <jmcarthur> i bet some weird things could be done with continuations, to
13:49:22 <jmcarthur> *too
13:49:23 <jmcarthur> yeah
13:49:51 <mmorrow> @unmtl StateT s (Cont o) a
13:49:52 <lambdabot> s -> (a -> s -> o) -> o
13:49:54 <aavogt> @type local ?f (liftM2 (,) ?computation ask)
13:49:55 <lambdabot> forall r a1 (m :: * -> *). (MonadReader r m, ?computation::m a1, ?f::r -> r) => m (a1, r)
13:50:02 <mmorrow> @unmtl ContT o (Reader s) a
13:50:02 <lambdabot> (a -> s -> o) -> s -> o
13:50:25 <jmcarthur> i was disappointed to see that monadLib's local takes a value rather than a function
13:50:36 <jmcarthur> i kind of prefer the mtl version
13:51:18 <en0th> i've always supposed that you form a monad with value data types.
13:51:19 <mmorrow> en0th: @unmtl is handy imo for seeing what the various monads (especially combinations of them) really are without the noise
13:51:27 <mmorrow> @unmtl State s a
13:51:28 <lambdabot> s -> (a, s)
13:51:51 <sproingie> @unmtl Maybe a
13:51:52 <lambdabot> Maybe a
13:51:55 <sproingie> yay
13:51:58 <en0th> hehe
13:52:07 <mmorrow> @unmtl ContT o (ReaderT r (ContT x (State s))) a
13:52:07 <lambdabot> (a -> r -> (o -> s -> (x, s)) -> s -> (x, s)) -> r -> (o -> s -> (x, s)) -> s -> (x, s)
13:52:15 <sproingie> alphabet soup, yummy
13:52:35 <mmorrow> @unmtl Cont o a
13:52:35 <lambdabot> (a -> o) -> o
13:52:38 <fergie> I have a program that compiles on one machine, but when I try it on another I get a UTF-Decoding error. It is something to with a "£" symbol. What is the easiest way to fix this?
13:52:40 <aavogt> @unwtf ReaderT r (WriterT w (StateT s)) a
13:52:40 <lambdabot> Maybe you meant: unmtl unpf
13:52:50 <aavogt> :(
13:53:44 <Baughn> @unmtl ReaderT r (WriterT w (StateT s)) a
13:53:44 <lambdabot> err: `StateT s (a, w)' is not applied to enough arguments.
13:53:46 <camio> fergie, Well, probably the easiest would be to remove that symbol, but I assume you mean easiest aside from that.
13:53:51 <Baughn> @unmtl ReaderT r (WriterT w (StateT s a))
13:53:51 <lambdabot> err: `ReaderT r (WriterT w (StateT s a))' is not applied to enough arguments, giving `/\A. r -> s -> a (A, w, s)'
13:53:58 <Baughn> @unmtl ReaderT r (WriterT w (StateT s a)) b
13:53:58 <lambdabot> r -> s -> a (b, w, s)
13:54:13 <fergie> camio: if possible yes. If the other way is a big ballache I might remove it
13:54:36 <camio> fergie: What format is the source file? UTF-8?
13:55:51 <fergie> unsure. The "£" symbol appears in the source file without looking weird so I think it is utf-8
13:56:19 <camio> does that symbol appear within a literal?
13:56:46 <fergie> it is part of a string
13:57:13 <camio> fergie, you could try replacing it with the backslash code for that character.
13:58:07 <fergie> camio: thanks I'll find that out and try it
13:58:23 <en0th> \163 for "£"
14:07:27 <en0th> > [\s -> (s,s)] <*> "what"
14:07:28 <lambdabot>   [('w','w'),('h','h'),('a','a'),('t','t')]
14:07:39 <jmcarthur> Help me! I can't stop myself from turning a real-world project into a research project!
14:08:09 <danco> switch to perl
14:08:16 <jmcarthur> genius!
14:08:24 <Botje> careful, you might get stuff done.
14:08:44 <Botje> better switch to java so you can spend hours arguing about how many factoryfactoryfactoryfactories you'll need.
14:08:47 <danco> no, nongenius, that's the point
14:08:52 <jmcarthur> I think a major disadvantage of working with an advanced language is the tempting, untread territory that's lurking so near.
14:08:53 <yitz> jmcarthur: meeting requirements defines the beauty of a real project.
14:09:16 <aug_triad_> Hi. I'm going to use neural nets with Haskell, do any of you know a good library to use? I have been looking at this one: http://hackage.haskell.org/package/hfann
14:09:26 <danco> just force yourself to do more hacks
14:09:29 <yitz> that involves beauty of the code as well, but it's only one small component
14:10:03 <en0th> :t pure
14:10:04 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:10:04 <fergie> en0th, camio: it compiles not. Just need to check the output looks right
14:10:40 <hackagebot> haste 0.1 - A universal pastebin tool, written in Haskell. (DavidSiegel)
14:11:10 <Peaker> Botje, heh, as bad as Java is, it probably is far less interesting to talk about Java than to code in it, whereas with Haskell that is not always the case :)
14:11:24 <Botje> :)
14:11:34 <sinelaw> hey Peaker
14:11:38 <Botje> the haskell platform should have a "dangerously addictive" sticker on it
14:11:49 <Peaker> sinelaw, hey
14:12:56 <fergie> en0th, camio: looks good. Thank you
14:13:17 <en0th> :) that's camio
14:13:54 <yitz> > "\163"
14:13:55 <lambdabot>   "\163"
14:14:13 <dixie> [6~[6~[6~[6~[6~[6~
14:14:21 <dixie> oops.
14:14:35 <yitz> > text "\163"
14:14:36 <lambdabot>   £
14:23:43 <hackagebot> haste 0.1.1 - A universal pastebin tool, written in Haskell. (DavidSiegel)
14:24:07 <M4NN4> http://hiphoprising.blogspot.com/
14:27:03 <HugoDaniel> so... now what ?
14:27:43 <Peaker> would be nice if hackagebot put a URL for the package too
14:28:57 <aug_triad_> Hi. I'm going to use neural nets with Haskell, do any of you know a good library to use? I have been looking at this one: http://hackage.haskell.org/package/hfann
14:29:49 <ivanm> so, haste == wgetpaste?
14:30:34 * ksf also tends to use neural nets with haskell. I use hardware ones, though.
14:31:10 <sm> Peaker: the anti-link folks were more vocal
14:31:36 <sm> if you convince them, I'll make it so
14:32:07 <ksf> shouldn't @hackage suffice?
14:32:37 <ksf> I'd take links to release notes, but hackage doesn't know about such a thing.
14:32:46 <ksf> changelog support would be cool, though.
14:33:05 <ksf> (and if it's just to nudge people towards writing any kind of log, at all)
14:33:46 <hackagebot> pure-priority-queue 0.1 - A pure priority queue. (BradLarsen)
14:33:57 <brad_larsen> there we go.  yay!
14:34:28 <sm> yay brad_larsen
14:34:29 <Peaker> sm, why did anyone not want links?
14:34:48 <ksf> too much noise, especially with long descriptions?
14:34:49 <ivanm> Peaker: presumably because it would be easy enough to use @hackage or something to look it up yourself
14:35:02 <Peaker> ivanm, that's not a reason not to have links...
14:35:14 <Peaker> I think encouraging people to see these new things is a slight advantage
14:35:20 <Peaker> which could be nice
14:35:22 <ivanm> Peaker: it's the only possible "reason" I can think of ;-)
14:35:44 <Peaker> they can poll the hackage feed, they don't need hackagebot at all
14:35:53 <Berengal_> Speaking of bots and links, what happened to \b posting the titles of links?
14:36:08 <sm> now *that* was annoying :)
14:36:28 <Berengal_> I sort of liked it. Better than parsing urls
14:36:44 <Berengal_> But should probably blacklist some sites, like hackage and hpaste
14:37:22 <ira_> I use perl's pack("w"...) a lot to convert between integer lists and a compact string of bytes representing base-127 integers, and I'd like to do the same in haskell. Does a library exist for this yet, or should I go ahead and write it?
14:37:51 <Berengal_> Then again, you can't please everyone... I should just write an embedded irc client in yi and implement my own plugins
14:38:47 <aavogt> ira_: this one at least: http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Codec-Utils.html
14:39:39 <Peaker> is yi pretty usable by now?
14:39:45 <Peaker> and how about leksah?
14:40:17 <Berengal_> I haven't checked in on leksah in a while... I liked it, but it didn't have emacs keybindings last I checked
14:40:26 <sm> I found leksah's loading of lib info to be flaky.. when it worked it was great
14:40:27 <Berengal_> I use yi for my day-to-day haskell hacking now
14:40:52 <camio> Berengal_, does it have any advantages over vim+haskell plugin?
14:41:06 <Berengal_> camio, wouldn't know, as I haven't used vim at all
14:41:39 <camio> Berengal_, what do you like about it? Aside from it being written in haskell, that is.
14:41:50 <Berengal_> Overall, yi's pretty decent, I think. It's a little slow on large files/long ghci sessions
14:42:02 <ira_> aavogt: thank you!
14:42:24 <Berengal_> camio, better haskell integration than emacs + haskell-mode, for one
14:42:50 <Berengal_> Much easier to extend, since I don't know lisp well, or elisp at all
14:43:25 <camio> Berengal_, what kind of extentions have you made?
14:43:53 <HugoDaniel> are there any alternatives to takusen and hdbc ?
14:43:58 <Berengal_> camio, type-inference and insertion of top-level declarations and module-browsing
14:44:25 <camio> nice
14:44:39 <Berengal_> camio, both just offloading to ghci and pasting the results in a buffer, but still pretty handy I think
14:46:16 <Peaker> Berengal_, I know elisp but I think it sucks, I wish I could use Haskell for extensions instead. I tried yi though and I didn't like it way back then..
14:47:45 <sproingie> yi won't compile from cabal for me
14:47:57 <Berengal_> Peaker, it's not emacs, that's true. I'm not a pr0-el33t emacs hacker, but I still think it's better for anything but haskell. Still, yi does good on haskell
14:48:05 <ivanm> Berengal_: agreed about the link titles; the tinyurls pissed me off though
14:48:43 <Berengal_> sproingie, I use HEAD, mostly. When I remember to pull
14:55:10 <benmachine> haskell-cafe-owner rejected my message :(
14:55:16 <ivanm> benmachine: heh
14:55:20 <benmachine> I think I am doing it wrong
14:55:39 <benmachine> I assumed that being able to get things from == being able to post things to
14:55:42 <benmachine> was this incorrect
14:56:32 <HugoDaniel> someone should take out those ghc 610 macros on the typeable instances of the hdbc and convertible pkgs
14:58:58 <ivanm> benmachine: it's correct AFAIK...
14:59:40 <benmachine> ivanm: well, something doesn't like me
15:00:04 <ivanm> benmachine: email too big?
15:00:27 <Peaker> damn, linking setup.hs is utterly killing this 0.5GB ram laptop
15:00:28 <benmachine> ivanm: uhh, severely doubt it
15:00:32 <Saizan_> HugoDaniel: you made CosmicRay quit!
15:00:58 <HugoDaniel> Saizan_: because of my bad mood today ? :/
15:01:55 <ivanm> you mean CosmicRay was actually here for once? :o
15:02:04 <Saizan_> the nick was
15:02:14 <ivanm> heh
15:02:36 <HugoDaniel> oh well
15:02:41 <HugoDaniel> sleep time for me
15:03:29 <HugoDaniel> i hope that i dont think  bad things about haskell, and that tomorrow ill be able to solve this ugly utf-16/ucs-2 thing :/
15:08:27 <ksf> lamdbda calculus : ski :: frp : ??
15:09:30 <ksf> "Multiple question marks", he went on, shakin his head, "are a sure sign of utter naivite."
15:13:27 <medfly> how do I load another Haskell file from my file?
15:13:49 <Peaker> medfly, import?
15:13:53 <medfly> oh... okay
15:13:55 <medfly> thanks! :-D
15:16:52 * byorgey makes cream of lambda soup
15:17:18 <ivanm> byorgey: fresh, canned, dried or powdered lambda?
15:17:22 <Peaker> Lemmih, you there?
15:17:31 <ivanm> preflex: seen Lemmih
15:17:32 <preflex>  Lemmih was last seen on #haskell 14 hours, 35 minutes and 17 seconds ago, saying: FunctorSalad: Those huge type synonyms look scary.
15:22:42 <byorgey> ivanm: fresh, of course!
15:36:50 <ivanm> byorgey: where do you source your fresh lambdas from?
15:36:58 <ivanm> I'm having trouble finding any around here... >_>
15:44:05 <hackagebot> pure-priority-queue 0.11 - A pure priority queue. (BradLarsen)
15:44:17 <sinelaw> brad_larsen, don't work too hard!
15:44:34 <brad_larsen> sinelaw: don't worry, I took a break for a while ;-)
15:44:54 <brad_larsen> my first release didn't include the tests I wrote
15:45:14 <brad_larsen> but this second release now has QuickCheck, test-framework, etc as dependencies---no good.
15:46:14 <Peaker> brad_larsen, maybe a pure-priority-queue-tests package?
15:47:03 <brad_larsen> Peaker: hmm, could do that.  ideally cabal is changed so that including tests is easier ;-)
15:47:21 <dcoutts> it's on the Cabal TODO list
15:47:45 <dcoutts> I wouldn't recommend going and making separate test packages at this stage
15:47:53 <dcoutts> just before we do tests properly in Cabal
15:48:01 <dcoutts> which will be within the package, not external
15:50:59 <c_wraith> it would be nice if you could specify test dependencies separately from package dependencies.
15:52:06 <Peaker> why is it better for Cabal to support it rather than have a convention for  <package>-test names?
15:52:08 <brad_larsen> c_wraith: yeah, that's the problem I have now.  I included an optional `test' executable, but now all its dependencies get added to the package dependencies
15:52:30 <dcoutts> c_wraith: right, exactly. That's part of the new design.
15:52:34 <Peaker> It sounds like using a separate -test package is significantly simpler..?
15:53:05 <dcoutts> Peaker: there's more than that anyway, you want a way to run the tests and see if they work and then report the results.
15:53:35 <dcoutts> brad_larsen: we changed the behaviour of that for Cabal-1.8+ so that it does not include deps of components that are not built.
15:54:01 <dcoutts> however packages need to opt-in to the new behaviour
15:54:17 <dcoutts> otherwise old stuff will break
15:55:23 <dcoutts> see http://hackage.haskell.org/trac/hackage/ticket/215#comment:2
15:57:52 <Peaker> dcoutts, all this could be achieved by a conventional <package>-test of same version, couldn't it?
15:58:00 <dcoutts> Peaker: no
15:58:02 <Peaker> (if this convention is instituted)
15:58:13 <dcoutts> not the gathering test results bit
15:58:23 <dcoutts> and having separate packages is a pain
15:58:31 <Peaker> why not? Have a command that tries to find and execute <package>-test
15:58:46 <dcoutts> I don't want to install all the test programs
15:58:57 <dcoutts> I want to run the tests then install just the lib/prog
15:59:17 <dcoutts> and I want to be able to test my package directly in the build tree
15:59:18 <c_wraith> Heck, I don't want to install the main program half the time, if I'm working with my own package.
15:59:23 <Peaker> well, it could install the -test package, run that, uninstall it, no?
15:59:28 <dcoutts> bleugh
16:00:24 <dcoutts> Peaker: doing it properly isn't that much harder
16:01:00 <dcoutts> the usual problem is not the technical difficulty of the design or coding, but finding the time to do it
16:01:09 <Peaker> dcoutts, I see
16:06:32 <byorgey> dcoutts: FYI, my mail to cabal-devel with the cabal init patch got put in the moderation queue because it was too big
16:06:47 <dcoutts> byorgey: oh right ok
16:06:47 <byorgey> I could resend it just to you if you want
16:07:15 <byorgey> again, no rush, I know you're a busy man =)
16:07:30 <byorgey> just so you don't wonder where the email is.
16:08:05 * dcoutts lets it through
16:08:15 <hackagebot> pure-priority-queue 0.12 - A pure priority queue. (BradLarsen)
16:09:04 <brad_larsen> there, i split the tests into a separate package
16:09:16 <hackagebot> pure-priority-queue-tests 0.12 - Tests for the pure-priority-queue package (BradLarsen)
16:09:24 <dcoutts> sigh
16:09:38 <brad_larsen> sinelaw: and that's enough for tonight.  ;-)
16:09:54 <sinelaw> brad_larsen :)
16:12:15 <sinelaw> conal, how does Eros handle constructing arbitrarily typed structures? If at all
16:15:00 <sinelaw> conal, in fact, how does Eros show only the appropriately typed things you can connect?
16:27:42 <LucasPires> oi to all
16:27:48 <LucasPires> *hello
16:28:27 <LucasPires> does anyone here have hlint?
16:31:04 <Peaker> LucasPires, sure
16:31:08 <andrewsw-afk> I'm stumped by a type inference problem using hmatrix and multiplying a double and a vector
16:32:04 <andrewsw> if I have an hmatrix vector v, in ghci: 2.0 * v works just fine
16:32:05 <LucasPires> Peaker: can you evalute to me something I have for school?
16:32:05 <Peaker> LucasPires, just cabal install it?
16:32:14 <andrewsw> but if I pass an argument of type Double and do the multiplication, if won't compile
16:32:17 <andrewsw> grrr
16:32:49 <LucasPires> For what I hear the install is not friendly in Ubuntu
16:33:46 <Peaker> LucasPires, don't install any Ubuntu packages
16:33:52 <Peaker> LucasPires, just install ghc from binaries
16:33:55 <Peaker> LucasPires, and cabal-install
16:34:02 <Peaker> LucasPires, and then install everything else with cabal-install
16:34:08 <Peaker> andrewsw, what is the error?
16:34:42 <andrewsw> couldn't match expected type Double against inferred type Vector Double in second argument of (*)
16:35:24 <Peaker> andrewsw, in ghci, what does :t (*)  tell you after  2.0 * v  works?
16:35:49 <Peaker> andrewsw, oh wait, I think I see. maybe you forced 2.0's type to be Double in the compiled one, and it became Vector using some dubious Vector Num instance in ghci?
16:36:10 <andrewsw> (*) :: (Num a) => a -> a -> a
16:36:21 <BMeph> andrewsw: Quick answer to your problem: "These aren't the Droids you're looking for..." ;)
16:36:32 <andrewsw> Peaker: hmmm.. not sure.
16:36:47 <andrewsw> Move along... /me wanders off confused
16:37:05 <sh10151> I've got a question on some code I wrote to challenge myself: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4358#a4358
16:37:15 <BMeph> andrewsw: Welcome to Haskell, where we not only overload operators, but we overload constants! :)
16:37:26 <andrewsw> BMeph: so I have to write my own double * vector function?
16:37:38 <sh10151> spec is: take a command line argument which is a regular expression, randomly capitalize all matches found on stdin
16:37:44 <c_wraith> > maxBound::Int
16:37:45 <lambdabot>   9223372036854775807
16:37:47 <andrewsw> BMeph: heh... oh yeah, I know it. It's fun...
16:37:49 <c_wraith> > maxBound::Double
16:37:50 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
16:37:50 <lambdabot>    arising from a use o...
16:37:54 <c_wraith> > maxBound::Char
16:37:55 <lambdabot>   '\1114111'
16:38:04 <Peaker> andrewsw, in ghci, what does   :t 2.0 * v    tell you?
16:38:07 <sh10151> It seem to me that the applyToMatch and applyToMatches should be pure and take a function
16:38:21 <andrewsw> Peaker: :) it's VEctor Double
16:38:29 <sh10151> but I can't figure out how to lift them to use the randomCaps function
16:38:38 <andrewsw> as is :t v
16:38:44 <Peaker> @type 2.0
16:38:45 <lambdabot> forall t. (Fractional t) => t
16:38:53 <BMeph> andrewsw: You're thinking too small. Don't write your own double * vector function; write your own converter of "2.0" into a vector! =8*O
16:38:56 <Peaker> @type fromDouble
16:38:57 <lambdabot> Not in scope: `fromDouble'
16:39:07 <Peaker> @hoogle Fractional t => Double -> t
16:39:07 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
16:39:07 <lambdabot> Prelude recip :: Fractional a => a -> a
16:39:07 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
16:39:18 <Peaker> andrewsw, so Vector Double has a Fractional instance, and its using the literal-to-fractional function on it
16:39:37 <andrewsw> ah ha! That looks like what I need.
16:40:01 <BMeph> andrewsw: Do ya feel what we're Force-projecting at ya? ;)
16:40:04 <andrewsw> sweet! That works!
16:40:20 <Peaker> what does Haskell use to convert fractional literals as opposed to fromInteger?
16:40:32 <byorgey> sh10151: I'm taking a look at it.
16:40:50 <ivanm> Peaker: you mean to or from fractional?
16:40:56 <Peaker> ivanm, to
16:41:02 <andrewsw> BMeph: oh yes I do!
16:41:03 <Peaker> ivanm, you type some literal like 3.4
16:41:13 <sh10151> byorgey: thanks, it might be that I'm wrong about keeping applyToMatches pure. I was able to write a program to do this, but I'm trying to practice separating pure and monadic code
16:41:15 <Peaker> ivanm, how is it converted to any Fractional instance?
16:41:29 <byorgey> sh10151: yes, that is a good approach in general.
16:41:42 <Nafai> byorgey!
16:42:06 <ivanm> Peaker: *shrug* clever stuff? :p
16:42:06 <andrewsw> BMeph, Peaker : thanks guys, I knew I was after something like that. realToFrac does it.
16:42:10 <byorgey> hi Nafai!
16:42:28 <Peaker> @type realToFrac
16:42:29 <byorgey> sh10151: well, applyToMatches can't take a pure function if you want that function to do something random.
16:42:29 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
16:42:35 <Peaker> @hoogle Real a => Double -> a
16:42:35 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
16:42:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:42:35 <lambdabot> Prelude id :: a -> a
16:42:38 <byorgey> sh10151: pure functions always return the same results for the same inputs.
16:43:01 <LucasPires> Peaker: I am now installing Haskell Platform
16:43:01 <SmurfOR> anyone here from Portland?  I'm thinking about attending the FuncPDX usergroup tonight but I'm a bit worried cause I'm really new to Haskell and don't want to be "the odd noob out"
16:43:33 <byorgey> SmurfOR: I am not from Portland, but you should definitely go. =)
16:43:39 <c_wraith> SmurfOR:  I'm in Portland, though I'm not going tonight.  But lots of good Portland people.  Don't worry about it.
16:43:45 <LucasPires> Peaker: there should be a talk between Haskell Platform people and Ubuntu people to provide good Haskell things.
16:43:58 <andrewsw> SmurfOR: I'd go if I were there, and I can't even convert Doubles to Fractionals!
16:44:04 <Peaker> LucasPires, slow Ubuntu release cycle...
16:44:35 <sh10151> byorgey: OK, so what would be the best way to write applyToMatches that it could take, say, either a pure function or a function with a monad?
16:44:44 <sh10151> two functions, applyToMatches and applyToMatchesM? :)
16:45:00 <BMeph> When faced with a square peg and a round hole, some languages get you to shave the peg, and others want you to shave the hole. Haskell gets you to figure out the transformation to the metric tensor, so that square holes match up to round holes. ;p
16:45:06 <SmurfOR> c_wraith, andrewsw, byorgey, I guess I have no choice then to go now :)
16:45:15 <sh10151> since my original challenge was to just capitalize everything, but then I wanted to teach myself monads
16:45:21 <Zao> BMeph: And magically transform the peg into a hole.
16:45:23 <BMeph> Err, round *pegs.
16:45:41 <byorgey> sh10151: sure, and you could implement the pure applyToMatches by calling applyToMatchesM using the Identity monad.
16:45:46 <ivanm> BMeph: oh, I thought Haskell wanted you to supply a geometry transformation function to make your square peg round...
16:45:54 <codnik> LucasPires: did you manage to install the Haskell Platform on Ubuntu?\
16:46:02 <sh10151> byorgey: that sounds promising
16:46:11 <sh10151> byorgey: thanks!
16:46:14 <BMeph> Dang it, I meant square **pegs... :\
16:46:19 <byorgey> sh10151: sure! looks like you're doing pretty well to me.
16:46:24 <Zao> BMeph: You could use a good type checker.
16:46:29 <Zao> Or typo checker.
16:46:32 <LucasPires> codnik: It is downloading the pacotes. I am following the tutorial.
16:46:48 <BMeph> Zao: My type checker needs a type checker. ;)
16:46:58 <LucasPires> codnik: http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html
16:47:00 <sh10151> to tell the truth this is the fourth or fifth time I have really worked at haskell in as many years
16:47:03 <codnik> LucasPires: packages. are you from BR?
16:47:13 <LucasPires> codnik: sim
16:47:17 <LucasPires> codnik: yes
16:47:19 <sh10151> I actually interviewed for a job programming haskell right out of college
16:47:36 <codnik> LucasPires: I was unable to install that on Ubuntu. Maybe you should just ignore that and go with cabal install...
16:47:39 <sh10151> but I had never used the language
16:47:43 <codnik> and GHC
16:47:45 <byorgey> sh10151: haha!
16:47:50 <BMeph> ivanm: I think Haskell wants you to bend the space between the peg and the hole, so that the parts that need to "match up". ;)
16:48:06 <ivanm> BMeph: that's what I was getting at
16:48:20 <byorgey> sh10151: so did you get the job? ;-)
16:48:24 <codnik> LucasPires: hmm.. are you on Jaunty? I couldn't do it on Karmic
16:48:30 <LucasPires> codnik: Is there a tutorial to do that? I am stupid.
16:48:37 <LucasPires> Yes, I am using Jaunty.
16:48:51 <sh10151> hah, no, they're a startup and had trouble funding a position when I actually needed the job
16:49:22 <sh10151> played phone/email tag for years, by the time they wanted me to come in again I was happily(?) working for a bank
16:49:27 <sh10151> writing zipWith in perl
16:49:29 <sh10151> :-P
16:49:38 <codnik> LucasPires: there's a difference between being stupid and being a noob. don't think you're stupid just because you don't know your way around.
16:50:32 <sh10151> after getting the RWH book I decided to finally turn monads into something more than just objects of profanity and incomprehension
16:50:34 <BMeph> ivanm: Then GHC uses the RTS to apply your transformation to a mini-black hole, to warp space to your specification. It's Deep Science, it just looks like magic! ;)
16:50:35 <sinelaw> where does lookupLTrees come from?
16:50:41 <sinelaw> @list
16:50:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:50:49 <ivanm> BMeph: \o/
16:50:49 <sh10151> hence the crazy exercises for myself
16:50:51 <codnik> LucasPires: you can download it here http://haskell.org/cabal/download.html
16:51:03 <c_wraith> @hoogle lookupLTrees
16:51:03 <lambdabot> No results found
16:51:08 <sinelaw> @where lookupLTrees
16:51:08 <codnik> LucasPires: get the cabal-install-0.6.2.tar.gz and install that.
16:51:09 <lambdabot> I know nothing about lookupltrees.
16:51:51 <byorgey> sh10151: excellent =)
16:52:06 * BMeph wants to go down to a make-your-own-T-shirt shop and copy xkcd's "SCIENCE" shirt idea for Haskell...
16:52:09 <codnik> LucasPires: and get GHC's latest version from http://www.haskell.org/ghc/download_ghc_6_10_4.html
16:53:33 <LucasPires> codnik: There is Haskell Platform for windows. I can install hlint in Windows?
16:53:43 <ivanm> LucasPires: should be able to AFAIK
16:55:14 <codnik> LucasPires: I don't really recommend using Windows for this if you can go with Linux...
16:56:08 <Peaker> LucasPires, if you just uninstall all Haskell packages in Ubuntu, and then just install ghc binaries from haskell.org and cabal-install's package, you're good to go
16:56:30 * BMeph gets so tired of packages that depend on "unix" that he someimes considers making a package that depends on Mac OS to run...
16:56:42 <Peaker> LucasPires, to install ghc binaries you just use something like:  ./configure --prefix=/usr/local && make && sudo make install     and to install the cabal-install package you use something like:  ./bootstrap.sh   and then set your PATH env var to point at ~/.cabal/bin
16:58:08 <BMeph> ...then cut off a chicken's head, and circle three times around your computer, making a circle with the dripping blood, chanting, "Ooga-BOOGA!" ;p
17:00:01 <codnik> BMeph: don't be a meanie now...
17:00:17 <sinelaw> @where All
17:00:17 <lambdabot> I know nothing about all.
17:00:18 <sinelaw> @hoogle All
17:00:18 <lambdabot> Data.Monoid newtype All
17:00:18 <lambdabot> Data.Monoid All :: Bool -> All
17:00:18 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:01:40 <BMeph> codnik: You're right. The chanting does nothing, only the chicken blood is important... ;p
17:02:26 <codnik> BMeph: I meant the "making a package that depends on Mac OS to run" part.
17:03:02 <Saizan> unix doesn't install on mac os?
17:04:12 <LucasPires> http://packages.debian.org/source/sid/hlint
17:04:21 <LucasPires> there is hlint for debian
17:04:31 * jvoorhis is making a package that runs on Mac OS only :)
17:04:41 <ivanm> wtf? it depends on debian-specific packages? :s
17:05:20 <ivanm> jvoorhis: why, it uses cocoa or something?
17:05:26 <jvoorhis> CoreAudio bindings
17:11:33 <LucasPires> I have question
17:12:11 <LucasPires> addDigit x y = 10 * x + y
17:12:20 <LucasPires> x and y are Integral
17:12:46 <LucasPires> addDigit :: (Integral a) => a -> a -> a
17:13:19 <LucasPires> but if I throw x as Int and y as Integer, it doesn't work
17:13:46 <wdonnelly> the 'a' is like a variable in mathematics, it has to be the same in every occurence
17:13:47 <LucasPires> vice-versa too
17:14:03 <wdonnelly> Int and Integer are different types, so you get a type error
17:14:03 <LucasPires> addDigit (12::Integer) (1::Int)
17:14:14 <LucasPires> but they are Integral
17:14:32 <c_wraith> Integral isn't actually a type.
17:14:52 <jvoorhis> LucasPires: the (Integral a) => part is called the context, and requires that `a' is always bound to the same type
17:15:01 <wdonnelly> if you really want the 'addDigit' function to take any integral type, you could use 'fromIntegral'
17:15:05 <wdonnelly> as in 'addDigit x y = 10 * (fromIntegral x) + (fromIntegral y)'
17:15:25 <ddarius> :t let addDigit x y = 10 * fromIntegral x + fromIntegral y
17:15:26 <lambdabot> <no location info>:
17:15:26 <lambdabot>     not an expression: `let addDigit x y = 10 * fromIntegral x + fromIntegral y'
17:15:27 <jvoorhis> exactly lke wdonnelly said
17:15:31 <ddarius> :t let addDigit x y = 10 * fromIntegral x + fromIntegral y in addDigit
17:15:32 <lambdabot> forall a a1 t. (Integral a1, Integral a, Num t) => a -> a1 -> t
17:15:37 <jvoorhis> and your type signature could read like this
17:16:10 <jvoorhis> actually, nevermind :) i'm not sure what it would be
17:16:28 <Peaker> :t let addDigit x y = 10 * x + y in addDigit `on` fromIntegral
17:16:29 <lambdabot> forall b a. (Num b, Integral a) => a -> a -> b
17:16:31 <jvoorhis> other than maybe addDigit :: (Integral a, Integral b, Integral c) => a -> b -> c
17:17:30 <jvoorhis> :t \x y -> fromIntegral x + fromIntegral y
17:17:31 <lambdabot> forall a b a1. (Integral a, Num b, Integral a1) => a -> a1 -> b
17:17:41 <jvoorhis> close :)
17:18:44 <jvoorhis> LucasPires: one thing to keep in mind is that while Int and Integer are both instances of Integral, they aren't *subtypes* of Integral as in an OO language
17:21:51 <LucasPires> jvoorhis: Haskell is so hard.
17:22:50 <jvoorhis> LucasPires: it has a real learning curve :) learning it has been on my backburner for a couple years and i've only recently started feeling comfortable with it
17:22:52 <Peaker> jvoorhis, its not like OO inheritance is really about sub-typing in practice
17:24:27 <jvoorhis> Peaker: no, but if Int and Integer are subclasses of Integral, they could satisfy Integral-typed parameters in e.g. java
17:25:00 <jethr0> to do inheritance right one has to think more about the semantics involved than many OO programmers do
17:25:01 <jvoorhis> or an Integral interface
17:26:35 <jvoorhis> point being, an intuition about interfaces and inheritance isn't always helpful when dealing with typeclasses :)
17:26:36 <ddarius> jethr0: If you get rid of mutation it becomes quite a bit easier.
17:26:53 <jethr0> mutation?
17:26:57 <ddarius> jvoorhis: It's not helpful at all.  Type classes are rather different things.
17:27:18 <ddarius> jethr0: Mutable variables.  The ability to change a field.
17:27:23 <jvoorhis> ddarius: there is some overlap between typeclasses and interfaces, though they're hardly the same thing
17:27:32 <ddarius> jvoorhis: Almost none.
17:27:53 <jvoorhis> right!
17:28:16 <jethr0> ddarius: i was even thinking of 'fragile base class' type of problems where changing class-private functionality will break daughter-classes. a lot of implicit assumptions are made when subclassing, usually
17:30:00 <sinelaw> jvoorhis, ddarius can you give an example difference between interfaces and type classes?
17:30:36 <jvoorhis> sinelaw: the above example with addDigit is a good one
17:31:09 <ddarius> sinelaw: Interfaces are types, type classes are not.  They are not even the same kind of thing.
17:31:57 <ddarius> C++ was considering adding a feature inspired by type classes and they weren't going to do away with abstract base classes because of it.
17:32:35 <LucasPires> hlint is weird
17:32:44 <LucasPires> does not like point-free
17:32:45 <ddarius> I highly recommend reading "class" in "type class" as the set theoretic notion of class, i.e. for our purposes essentially a set of types.
17:32:49 <ddarius> a collection
17:33:48 <LucasPires> isNonWhite = \ c -> notElem c " \t\n\r\f" -> HLINT -> isNonWhite c = notElem c " \t\n\r\f
17:34:04 <kpreid> I think type classes ~ interfaces is more enlightening than not
17:34:07 <LucasPires> crap, it is not point free
17:34:25 <ddarius> From that perspective, a class declaration just names a new class, instance declarations assert types are elements of the named class, and class constraints such as "(Num a) => ..." read as "if a is an element of Num then ..."
17:34:55 <kpreid> a type like "(Num a) => a" is basically the same as a Java interface
17:35:20 <sinelaw> ddarius, ok, i know more about type classes than about interfaces but its still good to know :)
17:35:22 <ddarius> kpreid: I think it is much more misleading than helpful, especially as most people using Haskell already have different intuitions from OO languages.
17:35:25 <ksf> http://www.reddit.com/r/programming/comments/9sv86/abstract_absurdities_how_to_teach_category_theory/c0ecio5
17:35:29 <ksf> someone correct me?
17:35:30 <kpreid> though with more must-be-instantiated-the-same constraints
17:36:14 <kpreid> (e.g. in Java interface Foo { Foo bar() } is a weaker constraint on bar than class Foo a where bar :: a -> a)
17:36:14 <ddarius> kpreid: Now make me a list of Nums.
17:36:30 <kpreid> right, that's the same sort of thing I was just talking about
17:36:39 <mrsolo> couple published papers stating that locking free STM implementation generally scale better .. pretty nice to know
17:36:55 * ksf reads => as "implements"
17:37:00 <ddarius> kpreid: The key to subclassing/interface implementation in OO is the existential in such constructs.  Haskell completely lacks that.
17:37:17 <ksf> more or less. the syntax doesn't really allow it.
17:37:18 <ddarius> ksf: So "Num a => a" means "Num a implements a" ?
17:37:31 <ksf> a where a implements Num
17:37:46 <Rotaerk_> I read it as "Given Num a, a"
17:37:58 <kpreid> ddarius: They have different constraints, of course, but I argue that type classes have the same *role* in Haskell that interfaces do in Java.
17:38:15 <ksf> or a where a has to satisfy Num
17:38:52 <ddarius> kpreid: I completely disagree.  I do not use type classes the same way as I use interfaces.
17:38:52 <ksf> I usually don't see it as a witness that's passed but a constraint.
17:38:55 <ddarius> I would say records of functions or modules are closest to serving the same role as interfaces in OO.
17:39:54 <Rotaerk_> the way I use interfaces in OO code is to abstract the details of a part of some module.  it's a way of letting the user of that module inject the details of that part
17:40:02 <ksf> records are quite like classes, just without self.
17:40:16 <ksf> it's all vain, because I've never seen any serious oo code in haskell.
17:40:55 <Rotaerk_> another way to put it is that it's a way to create a fixed set of semantically loaded operations for which you can implement in any number of data models
17:40:58 <ddarius> Good OO design using interfaces will not map to even workable design if you map interfaces to type classes.
17:41:02 <Rotaerk_> -for
17:41:03 <ksf> ...but it'd be fun to implement /truly/ oo lists in haskell.
17:41:56 <Rotaerk_> and that's really the same as type classes
17:42:09 <Rotaerk_> though one may be able to draw distinctions between the two as well
17:43:39 <ksf> though I'd probably do it with classes, anyway. instance List Nil where head = undefined; length = 0, tail = undefined; instance (List xs) -> List (Cons x xs) where head (cons x _) = x; length (cons _ xs)= 1 + length xs;...
17:44:50 <sproingie> *some* interfaces map to typeclasses.  Comparable for instances
17:44:55 <sproingie> s/s$//
17:45:50 <Rotaerk_> sproingie, could you describe an interface that doesn't map to typeclasses?
17:45:58 <Rotaerk_> err provide an example of*
17:46:04 <ksf> hmm. translating all those patterns might actually be a very useful exercise for the community.
17:46:24 <sproingie> well i could take a cheap shot and say Serializable, but lemme try a real interface
17:46:50 <Rotaerk_> well consider Serializable then
17:47:00 <Rotaerk_> how could you not have a serializable type class?
17:47:08 <ksf> ...not only to give converts something to hold on to (and lead them to the true way by pointing out why foo sucks), but also to develop a better understanding of what corners of the abstraction space aren't properly covered yet.
17:48:05 <sproingie> Serializable is just a tag interface in java
17:48:13 <ksf> uhm well java has a toString for every object.
17:48:18 <Rotaerk_> I've never used java
17:48:25 <sproingie> java interfaces tend to be more coarse grained.  Collection for example
17:48:33 <Rotaerk_> but I would expect a "Serializable" interface to have a "Serialize" method
17:48:33 <ddarius> sproingie: Actually, type classes are much better for that, i.e. Ord.  This is an example where interfaces are being abused.
17:48:59 <Rotaerk_> java isn't the model for OO so I wouldn't blame any antipatterns in its design on OO
17:49:17 <ksf> you end up in casting hell if you inherit from an object to implement an interface.
17:49:27 <ddarius> Eq for example, makes a lot more sense as a type class as opposed to an interface.
17:49:32 <sproingie> serialization's actually built in to java, Serializable just activates the capability on a class
17:50:03 <ksf> that's nice. If we had some standard bytecode we could do that, too.
17:50:12 <Rotaerk_> ksf, all that says is that interfaces are more syntactically cumbersome
17:50:46 <ksf> we'd have to separate IO into platform specific and platform independent, too, which would be GREAT
17:51:06 <ksf> ...casts are actually a thing of the type system.
17:51:14 <Rotaerk_> sproingie, yea that's not how interfaces are supposed to work, so definitely not a good example :P
17:51:23 <ksf> but you're right, member-based inheritance doesn't have that problem.
17:51:28 <Rotaerk_> hmm sounds a bit like how Attributes work in C# though
17:52:16 <sproingie> java probably would have done it with annotations if it had them from the start
17:53:42 <Rotaerk_> ddarius, howso?
17:53:55 <ksf> java would have probably looked better if it had been designed, at all.
17:54:12 <Rotaerk_> I mean doing equality via interfaces seems perfectly reasonable, if they hadn't chosen to ingrain it into the Object ubiquitous base class
17:54:15 <ksf> ...they bleeding took a toy language and bought large billboards for it.
17:54:28 <ddarius> Rotaerk_: It's called the binary method problem.
17:54:42 <sproingie> java was largely hacked together in a short time in a desperate side project to keep NeWS relevant
17:54:42 <Rotaerk_> oh multiple dispatch
17:55:01 <Rotaerk_> yea C++, C#, and java don't really have an answer for that
17:55:06 <ddarius> It only really makes sense to talk about equality between things of the same type which is not what you'd get with interfaces.
17:55:13 <ksf> the big difference is that if you've got a common object.equals(otherobject), you can compare for equality across type boundaries.
17:55:26 <Rotaerk_> ddarius, eh, you can use runtime type identification to handle that
17:55:27 <Jedi_Stannis> is there a readLn like function that can handle backspace, arrows, etc?
17:55:31 <LucasPires> meu deus
17:55:40 <ksf> ...we have to pack stuff up into a sum type.
17:55:42 <LucasPires> I had to come to haskell for everyone to talk on java
17:55:44 <ddarius> Rotaerk_: Thanks for arguing my point.
17:55:54 <Rotaerk_> if(typeof(o) != this.GetType()) return false; else { cast and compare }
17:55:59 <LucasPires> I am cursed
17:56:22 <ksf> ...sum types are runtime type checks. we do it all the time.
17:56:52 <ddarius> ksf: They aren't run-time -type- checks.  Left and Right aren't different types, nor True and False.  Do you consider every conditional a type check?
17:57:06 <Rotaerk_> ddarius, there's nothing inherently wrong with downcasting
17:57:17 <ddarius> Also, given an Either A B I have two options, not an unknown infinity.
17:57:33 <Rotaerk_> the only problem with it is if you're doing a switch on a set of possible downcast types, such that you'd have to modify that switch every time a new type was added
17:57:36 <ksf> a and b in Either a b are (or at least can be) different types. that's the same as having an object check in it's equality method what kind of object has been passed.
17:57:47 <ksf> ddarius, yep.
17:57:48 <Rotaerk_> and in the case of equality, that's not the case
17:57:52 <ksf> that's why I said sum types.
17:58:02 <ksf> you could use existentials to generalise it.
17:58:15 <ksf> ...or type magic and nested eithers.
17:58:56 <ddarius> Rotaerk_: There are several things wrong with that.  1) RTTI breaks parametricity which seems unreasonable just to compare for equality, 2) "foo".Equals(2) ~> false doesn't seem very sensical.  Arguably, equality comparisons aren't even meaningful between different types.  3) You have to write this code to have it "be right," it shouldn't require irrelevant ceremony to do the right thing.
17:59:29 <ddarius> ksf: Existentials do generalize.  When you use existentials you are getting very close to OO objects.
18:00:27 <ddarius> ksf: The issue is static knowledge and exhaustivity/closedness v. dynamic knowledge and openness.
18:01:12 <ksf> and it's certainly a Good Idea to do stuff static.
18:01:43 <ddarius> At any rate, it seems pretty clear that the Eq type class is an elegant and effective solution to that particular problem and the Equals method (or a separate interface) is definitely hacky.
18:02:20 <ksf> class GenericEQ a where geq :: Typeable b => a -> b -> Bool
18:02:36 <Rotaerk_> ddarius, I don't disagree with that.  I think type classes are superior to interfaces, but interfaces are still the OO analog of typeclases
18:03:14 <Rotaerk_> they're just a bit less nice, like everything else about C# and Java compared to haskell's type system
18:03:26 <m3ga> people, transformers vs mtl? which should be used and why?
18:03:29 <ddarius> Rotaerk_: Again, I disagree.  If you take good design with type classes and try to map them to interfaces you'll get not even a workable design.
18:03:43 <ddarius> Type classes and interfaces are different things.  This is why C++ was considering having both.
18:04:12 <ksf> having both leads to shizophrenia.
18:04:19 <ksf> you'd never know how to do stuff.
18:04:23 <ksf> ...and end up like perl.
18:04:27 <ddarius> Type classes are not better than interfaces.  They are just different.  There are things I do in OO that would be really nice to do in Haskell.
18:04:54 <ddarius> ksf: Yes you would because there is very little overlap in what you would want to use type classes for and what you'd want an interface for.
18:04:56 <ddarius> This is my point.
18:05:24 <ksf> well what you'd want and what you could are two different things
18:05:31 <Peaker> ddarius, If you put the result of your type-class method in IO, and use some MVar around the first argument, you get something like an interface, no?
18:05:39 <ksf> ...and one doesn't always know the former one.
18:05:48 <ddarius> Peaker: No.  Mutation is an orthogonal concern.
18:06:18 <ddarius> ksf: I believe if you are familiar with both, it will be pretty clear in most cases.
18:06:31 <sproingie> if you're against perl'
18:06:53 <sproingie> if you're against perl's philosophy of TMTOWTDI, haskell is probably out too
18:06:58 <Peaker> ddarius, if you ignore mutation, then how are type-classes not a superset of interfaces in terms of power?
18:07:01 <dolio> You get something like an interface by existentially quantifying around a type class context.
18:07:21 <ddarius> Peaker: Type classes aren't types.  They aren't even the same thing, let alone a superset.
18:07:25 * ksf tends to agree with Peaker, intuitively.
18:07:37 <Peaker> ddarius, interfaces aren't types too, in e.g: Java, no?
18:07:38 <ddarius> dolio: Yes, but it's the -existential- -type- that is like an interface.
18:07:39 <Rotaerk_> (SomeClass a) => a
18:07:40 <ksf> not on theoretical grounds, but code design space.
18:07:53 <Rotaerk_> seems pretty close to "SomeInterface a;"
18:07:57 <dolio> ddarius: Right. The class is just the list of methods.
18:08:00 <ddarius> Peaker: I can have a variable that is typed as an interface.  I can't instantiate an interface.
18:08:17 <idnar> Rotaerk_: (SomeClass a) => a is forall a. (SomeClass a) => a
18:08:26 <Rotaerk_> idnar, I know
18:08:30 <ddarius> dolio: Indeed.  And I believe that an explicit record type wrapped by an existential is actually even closer than using a type class for those.
18:08:35 <idnar> Rotaerk_: SomeInterface a; is exists a. (SomeInterface a) => a
18:08:38 <ksf> both are layers over data. that in oop all data has methods doesn't matter.
18:08:38 <idnar> (more or less)
18:09:03 <dolio> Could be. I haven't really thought about it much, since I never do it. :)
18:09:08 <Peaker> ddarius, well, that's really just a matter of perspective, IMO.  I'd interpret the syntax IBlah blah   to mean:  (forall a. IBlah a => a) but IBlah itself to basically be the IBlah type-class
18:09:20 <Peaker> ddarius, s/a/blah there
18:09:56 <ddarius> The reason I'm so opinionated about this is not some technical definition (though I have those too), it's, as I said above, the operational aspect, how you actually design using these things, is -totally- different.  If you try to treat one as the other you will create unworkable designs.
18:10:54 * ksf thinks we need some definition of pure objects, even without inheritance to get down to the matter.
18:11:00 <ksf> ...self references, that is.
18:11:11 <Peaker> ddarius, I think the main reasons for the unworkable results are: A) mutation-based design vs functional one  B) Type-classes afford more power with which you usually want a different design
18:11:26 <Peaker> ddarius, not because interfaces are not a subset of type-classes
18:11:44 <Peaker> or, a subset of type-classes + existential quantifications of variables
18:12:05 <ksf> but existentials imply run-time typing
18:12:10 <ksf> even if it's statically safe.
18:12:20 <Peaker> ksf, just like interfaces?
18:12:21 <ksf> (which oop does, too)
18:12:23 <ddarius> ksf: They don't imply run-time typing.
18:12:45 <ksf> well, if you want to _use_ existentially quantified values, that is.
18:12:48 <ddarius> Peaker: It has nothing to do with mutation.  The Eq/Equals example does not involve mutation.  Going the other way, IList is a nice C# interface that wouldn't be the same as a type class.
18:12:56 <ksf> ...and not use faith and unsafeCoerce
18:13:03 <ddarius> ksf: Still not true.
18:13:09 <dolio> You don't need any runtime typing to use exists 'a. (a, a -> a, a -> Int, a -> String)' or some such.
18:13:12 <Peaker> ddarius, I wasn't here early enough to see the Eq/Equals example.  What's IList?
18:13:33 <ddarius> ksf: You'd only need run-time typing if you wanted to try to recover the hidden type.  The idea, with an existential, is that you don't care.
18:13:52 <Rotaerk_> hmm IList, iirc, is a terrible designed interface
18:14:02 <ksf> I've never seen them used without typable.
18:14:17 <ddarius> Rotaerk_: The idea of it isn't bad, and doesn't map to anything in Haskell.
18:14:28 <ksf> I've tried to do some existential stuff myself where I wouldn't have used typeable, but it figured I didn't need them.
18:14:40 <ddarius> Rotaerk_: It would be very nice to have a list of IList things where I don't have to care what particular implementations I'm given.
18:14:44 <Rotaerk_> at one point I decided I didn't like the choice of methods in IList
18:14:51 <Rotaerk_> though can't recall why
18:14:51 <Peaker> ddarius, what methods does IList have?
18:15:02 <ksf> Rotaerk_, that works. we just don't have it.
18:15:32 <ddarius> Peaker: Not particularly relevant.  It's an interface to list-like data structures.  It lets you traverse, add, and remove elements.
18:15:34 <ksf> a start would be to make viewL a class.
18:15:46 <Peaker> ddarius, why wouldn't it work for Haskell?
18:15:58 <ksf> (and support specifying a default view pattern for a data type)
18:16:16 <Peaker> ddarius, sounds to me like it wouldn't make much sense in Haskell due to mutation-based vs. functional concerns
18:16:33 <ddarius> Peaker: It doesn't matter if its implement imperatively or functionally.
18:17:00 <ddarius> Peaker: I want to be able to take arbitrary types that support the interface, not choose a single undetermined type.  I could map such an interface to a record or existential, but not too a type class.
18:17:51 <ddarius> The usual list of IDrawables is a good example.  Its more or less sensible OO design and doesn't map to type classes in Haskell.
18:17:53 <m3ga> people, transformers vs mtl? which should be used and why?
18:18:17 <ksf> m3ga, if you don't know why you should use something else, use mtl
18:18:22 <Peaker> ddarius, the variables "typed like" an interface are existentials, I think everyone agreed on that.  Do you object to:  Interface as subset of Type-class  +  Interface-typed-variables as Existentially quantified variables of instance types?
18:18:53 <ksf> there's currently bikeshedding going on in the field of transformers, and it's unclear who's going to be the winner.
18:19:29 <idnar> THERE CAN BE ONLY ONE
18:19:41 * idnar draws his sword and runs around decapitating transformer libraries
18:19:46 <Rotaerk_> ddarius, I had to refresh my memory on existentially qualified types.  one of the examples they give is heterogeneous lists... isn't that "a list of IList things where I don't have to care about particular implementations I'm given"
18:19:48 <ddarius> Peaker: That's a potential encoding of interfaces, but you aren't gaining much from using a type class.
18:20:00 <ddarius> Rotaerk_: That is indeed an example.
18:20:21 <Rotaerk_> data IList = forall l. List l => IList l
18:20:25 <ddarius> Peaker: The magic there for the encoding is the existential, not the type class.
18:20:27 <Peaker> ddarius, I'm gaining the ability to use instance types with such functions without manually selecting a record, just like in OO the vtable is passed implicitly
18:20:37 <Peaker> ddarius, the magic of the vtable choosing is in the type-class, though
18:20:43 <Peaker> btw, Haskell list type-class: http://hackage.haskell.org/packages/archive/List/0.2/doc/html/Data-List-Class.html
18:21:41 <ksf> how are dicts for existentials passed, anyway?
18:21:59 <ksf> a traditional vtable lookup? could be any of umpteen types, after all.
18:22:03 <Peaker> ksf, Same way as ever?
18:22:10 <m3ga> ksf: thanks. i've got a problem in that i want to use two different hackage packages. one uses mtl and one uses transformers. is there a solution?
18:22:30 <ddarius> Peaker: The choosing is done by making a tag type, whereas using a record, say, instead of a type class, I can use the same record type with different records.  Type classes are compile-time, type associated entities, vtables are run-time value associated entities.
18:22:35 <Peaker> ksf, If you have:  data Blah = forall a. Ord a => Blah a ; then I'd guess it translates Blah to contain a tuple of the Ord dict and a
18:23:16 <ksf> erm there's no "the ord dict" afaiu
18:23:23 <ksf> there's a's ord dict.
18:23:26 <ksf> and b's ord dict
18:23:29 <ksf> and c's ord dict.
18:23:32 <ksf> ...which are open.
18:23:42 <Peaker> ksf, Blah containers a reference to some such dict
18:23:43 <ksf> (er the list is open, not the dicts
18:24:01 <Peaker> ddarius, if you allow for the same record type with different types you still need to pass the record explicitly with the value, no?
18:24:16 <ksf> point being, if you use an existential, you've got to pass a hell a lot of dicts (in whatever way), and can't elide them.
18:24:46 <ddarius> Peaker: The record -is- the value.
18:25:24 <Saizan> m3ga: there's an "hack" in ghc that let you choose the package name when you import a module, check the user manual
18:25:28 <Peaker> ddarius, and in this record, you have both the value's data, and the interface's functions to operate on that data?
18:25:36 <LucasPires> ronc5 = let xs = tail [0,1,2,3]; ys = init "abcd" in zip xs ys
18:25:51 <LucasPires> Warning: the Monomorphism Restriction applies to the binding for `xs'
18:26:00 <LucasPires> what is the meaning this warning?
18:26:01 <LucasPires> of
18:26:09 <ddarius> Peaker: Yes.  The existential is, effectively, quantifying over the "state" of the object.
18:26:09 <mmorrow> ghc does data OrdD a = OrdD (a -> a -> Ordering); data Blah = forall a. Blah (OrdD a) a
18:26:51 <ksf> the monomorphism restriction warns you that you're defining a function with a class-constraint type instead of a concrete type.
18:26:57 <Peaker> ddarius, I see what you're saying, but it seems to go back to quicksilver's point: use records instead of type-classes (and I guess he means whenever its not really overloading of common names that you want)
18:26:59 <ksf> it's vastly unloved and some say it should be burned.
18:27:13 <Peaker> ddarius, Indeed whether you use a record or a type-class is less relevant than the existential quantification
18:27:50 <mmorrow> Peaker: ghc translates typeclasses literally into records
18:27:59 <Peaker> ddarius, But I'd say that OO in general is about existential quantification of all variables, and then interfaces can be encoded as either records or type-classes (which is unsurprising as you can encode pretty much all uses of type-classes as records)
18:28:01 <ddarius> Peaker: I agree with that last statement completely, and said part of it before.  (I thought I had said almost exactly that before, but I don't see it.)
18:28:05 <Peaker> mmorrow, I know
18:28:44 <mmorrow> Peaker: the extent to which it's expressible in plain haskell i find more surprising every day
18:29:26 <Peaker> mmorrow, I too translated some type-classes to records to find that aside for a few syntactic annoyances (Can't have: { blah x = ... }  only { blah = \x -> ... }  it wasn't bad at all
18:29:30 <mmorrow> classes are pretty much just syntactic sugar
18:29:52 <ksf> mmorrow, what's with their interplay with e.g. existentials?
18:29:53 <Peaker> mmorrow, until you get to type-families, mptc/fundeps, etc
18:29:56 <mmorrow> Peaker: if you have a program generating code though
18:30:00 <Peaker> ksf, even then
18:30:16 <mmorrow> Peaker: well right, the typechecking is on you
18:30:29 <ksf> does the record analogy hold then, too, and does ghc really pass 100000 records around for every Show a => a existential?
18:30:39 <Peaker> mmorrow, oh, also type-classes give you some extra invariant guarantees
18:30:49 <mmorrow> ksf: ghc just sticks the dictionary (:= record of functions) inside existential constructors
18:30:50 <Peaker> mmorrow, (e.g The Ord in Map guaranteed to be the same each time)
18:31:11 <mmorrow> Peaker: sure, but just because ghc passes it
18:31:11 <dolio> Why would it pass 100,000 records when you only specify that 1 is available?
18:31:26 <ksf> ...so it's the values that are wrapped up.
18:31:44 <Peaker> mmorrow, Yeah, what I meant to say that in this sense, record passing is more powerful than type-classes, and loses some useful guarantees about what it can't do
18:31:47 <ksf> which is counterintuitive. existentials are quite naked, compared to other types.
18:32:05 <mmorrow> data DMonad m = data DMonad (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
18:32:25 <mmorrow> data M a = forall m. Monad m => M (m a)
18:32:35 <mmorrow> gets translated (literally) to
18:32:38 <ksf> wait existentials are just syntactic sugar for dynamic?
18:32:51 <mmorrow> data M a = forall m. M (DMonad m) (m a)
18:33:02 <ddarius> Peaker: That's true because record passing is a value-level, run-time thing.
18:33:13 <ddarius> ksf: No.
18:33:22 <Peaker> ksf, If you think of   (Blah a => ....)  as (Blah a, ....) then  (Eq a => a -> a -> Bool) becomes (Eq a, a) -> a -> Bool   (which is ugly, but fine) and   Blah = forall a. Eq a => Blah a   becomes  Blah = forall a. Blah (Eq a, a)   which is also fine
18:34:00 <mmorrow> it becomes Blah = forall a. Blah (a -> a -> Bool) a
18:34:17 <mmorrow> that is, it just sticks the functions inside the package with the value
18:34:19 <Peaker> mmorrow, well, Eq a   in my example is a record containing   (a -> a -> Bool)
18:34:33 <mmorrow> Peaker: right, i just wanted to be explicit
18:34:55 <Peaker> mmorrow, btw: I tried this approach in C, too, and its not that bad :)
18:35:00 <Peaker> (except for a lot of void* casting)
18:35:02 <mmorrow> every function with a class constraint gets an additional arg for each class constraint as well
18:35:29 <Peaker> Passing the vtables as args instead of storing them in objects as conventionally done in OOP-style C, is even nice in C
18:35:49 <Peaker> (I know there's some weird objection to the use of "vtable" instead of "record of functions" but I'm not sure why :)
18:36:26 <Peaker> Me and a friend wanted to try a little C-with-typeclasses language
18:37:03 <ksf> remind me to do that should I take up a C job. I love to scare people.
18:37:21 <mmorrow> it looks like \dict x y -> case dict of DRealFloat a b c d e f g h i j k l m atan2 -> atan2 x y
18:38:02 <Peaker> mmorrow, heh, or:  \DRealFloat { atan2 = atan2 } x y -> atan2 x y
18:38:17 <Peaker> (or using the getters)
18:38:30 <mmorrow> or just   32(%rax)
18:38:33 <ksf> \DRealFloat { ... } x y -> atan2 x y
18:38:35 <Peaker> hehe
18:38:59 <ksf> haven't tried it yet, but saw it in the docs.
18:39:03 <Peaker> if you have  Eq a => Eq (Blah a)  then you don't have a dictionary of functions, but a function from one dict to another
18:39:19 <Peaker> well, you have the other when you give it the first :)
18:39:45 <ksf> that's a functor.
18:40:19 <ksf> instance Functor ((=>)a) where cmap ...
18:46:05 <mmorrow> Peaker: "record passing is more powerful than type-classes,"   right, i'm talking about the large-scale generation of haskell code that constructs an equivalent/similar knot of records as type-classes, and adds them as args to functions, etc
18:47:34 <mmorrow> it wouldn't be that difficult or technically challenging/whatever either
18:47:50 <mmorrow> purely mechanical
18:50:41 <mmorrow> , ppDoc <$> (do x <- newName "x"; lamE [tupP (replicate 10 wildP ++ [varP x] ++ replicate 3 wildP)] (varE x))
18:50:43 <lunabot>  \(_, _, _, _, _, _, _, _, _, _, x_0, _, _, _) -> x_0
18:52:52 * ksf tries to find something on http://en.wikipedia.org/wiki/Design_pattern_(computer_science)  that is'nt trivial in haskell.
18:52:59 <mmorrow> if you have some sort of fancy type system/etc is where any difficulty/challenge would come in
18:53:04 <ksf> maybe I'm missing the patterns for the simple examples.
18:53:32 <ksf> or my definition of trivial is sufficiently different from oop coders
18:54:39 <m3ga> @hoogle openFd
18:54:40 <lambdabot> No results found
18:54:59 <ksf> @hoogle openFile
18:54:59 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
18:55:19 <ksf> there's some low level functions somewhere hidden in the libs, though.
18:55:54 <m3ga> in aware of openFile. i have some code that uses openFd and i'm trying to figure out where it comes from.
18:55:55 <ksf> ...most likely tagged with "posix", as e.g. windoze doesn't have fd's.
18:56:28 <ddarius> ksf: Many of those examples would be comparably difficult in Haskell as compared to C#.  The things that Haskell would do bad at (that OO languages would be better at) would be considered trivial in OO languages and thus wouldn't have patterns.
18:56:30 <m3ga> windows does have fds, just that they aren't as fully featured as posix ones
18:56:58 <ksf> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#v%3AopenFd
18:59:08 <dipponaught> n00b ?: why does filter (<100) (filter even fib) crash?
18:59:36 <dipponaught> lol google wont site search on tunes.org/~nef/logs/haskell/
18:59:40 <ivanm> dipponaught: in what sense?
18:59:45 <ksf> what does your fib look like?
18:59:54 <jfredett> ddarius: diagrams are not scary anymore, thanks for the explanation... for some reason it never clicked before then.
19:00:02 <dipponaught> fib is an infinite list
19:00:04 <ivanm> ksf: especially if he's trying to force the whole list...
19:00:12 <ivanm> dipponaught: what are you doing with that infinite list?
19:00:24 <ivanm> dipponaught: note that filter doesn't know that it gets above 100 and stays there
19:00:32 <ivanm> maybe you want takeWhile (<100) rather than filter
19:00:45 <ksf> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in filter ((<100).even) fibs
19:00:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
19:00:46 <lambdabot>    arising from the literal `10...
19:01:05 <ksf> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in filter (<100) . filter (even) $ fibs
19:01:09 <lambdabot>   mueval-core: Time limit exceeded
19:01:15 <dipponaught> let me check to make sure im logging this... :)
19:01:17 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<100) $ filter even fibs
19:01:17 <ksf> @src filter
19:01:17 <lambdabot> filter _ []     = []
19:01:17 <lambdabot> filter p (x:xs)
19:01:17 <lambdabot>     | p x       = x : filter p xs
19:01:17 <lambdabot>     | otherwise = filter p xs
19:01:18 <lambdabot>   [2,8,34]
19:01:23 <ivanm> dipponaught: ^^
19:01:38 <mmorrow> , (let fib !m !n = m : fib n (m+n) in fib 0 1) !! 100000
19:01:41 <lunabot>  2597406934722172416615503402127591541488048538651769658472477070395253454...
19:02:03 <mmorrow> , takeWhile (< 100) (let fib !m !n = m : fib n (m+n) in fib 0 1)
19:02:05 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89]
19:02:16 <mmorrow> , (filter even . takeWhile (< 100)) (let fib !m !n = m : fib n (m+n) in fib 0 1)
19:02:17 <lunabot>  [0,2,8,34]
19:02:18 <ivanm> mmorrow: banging them? :o
19:02:23 <dipponaught> ok, let me digest all this...
19:02:27 <ksf> erm still, it should start to print stuff.
19:02:29 * dipponaught is digesting what was said
19:02:31 <ivanm> 0 is not part of the fibonacci sequence! ;-)
19:02:47 <ddarius> jfredett: Your class is broken since the transformation should exist for every type given for 'a'.  Also, there is more than one natural transformation between two given functors (usually).
19:02:50 <dolio> It's the 0th element.
19:02:52 <mmorrow> 0 1 1 2 3 5 8 ...
19:02:56 <ivanm> ksf: since you're using a let, it's probably keeping it in memory or something...
19:03:06 <ivanm> mmorrow: but you can't have 0 rabbits!
19:03:10 <ddarius> (So your class would end up with the same problem as Monoid where you'd need wrapper types like Product and Sum.)
19:03:17 <ddarius> ivanm: Sure you can.
19:03:18 <medfly> thanks guys, I just needed to remember which is one of the functions you just used! :-D
19:03:26 <ddarius> They just don't make more, but neither does one.
19:03:30 <ivanm> oh, wait, it appears Fibonacci actually used 0...
19:03:38 <mmorrow> ivanm: that's called extinction
19:04:10 <ksf> > filter (<100) . filter (even) . fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:04:10 * mmorrow waves at the 0 pterodactyls flying overhead
19:04:11 <lambdabot>   No instance for (GHC.Num.Num [a])
19:04:11 <lambdabot>    arising from the literal `1' at <inter...
19:04:18 * ddarius imagines an xkcd comic with a step graph going up in Fibonacci steps and then "busting" a la the bust-boom graph.
19:04:34 * ddarius always waves at all Pterodactyls.
19:04:51 <ksf> huh?
19:04:59 <jfredett> ddarius: that makes sense
19:05:10 <ksf> :t (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:05:11 <lambdabot> forall a. (Num a) => [a] -> [a]
19:05:20 <ksf> :t fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:05:21 <lambdabot> forall a. (Num a) => [a]
19:05:29 <ksf> > fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:05:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:05:47 <ksf> > filter (<100) $ fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:05:51 <lambdabot>   mueval-core: Time limit exceeded
19:05:53 <mmorrow> > fix (\k m n -> m : k n (m+n)) 0 1
19:05:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:06:25 <mmorrow> , fix ((0:) . scanl (+) 1)
19:06:26 * ksf is stumped
19:06:27 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
19:07:26 <jfredett> @pl fix ((0:) . scanl (+) 1)
19:07:26 <lambdabot> fix ((0 :) . scanl (+) 1)
19:07:28 <mmorrow> , fmap (uncurry (/) . fromIntegral) . (zip`ap`tail) $ fix ((0:) . scanl (+) 1)
19:07:30 <lunabot>  luna: No instances for (GHC.Real.Integral (a1, a1), GHC.Num.Num (a, a))
19:07:35 <jfredett> thats as pl as it gets, I guess...
19:07:42 <dolio> ksf: Your expression produces a list of numbers up to 100, consed onto _|_.
19:07:57 <ddarius> @pl map f . map g
19:07:57 <lambdabot> map (f . g)
19:07:58 <ksf> ...but it's lazy.
19:08:04 <mmorrow> , fmap (uncurry (/)) . (zip`ap`tail) . fmap fromIntegral $ fix ((0:) . scanl (+) 1)
19:08:06 <lunabot>  [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.6190476190...
19:08:15 <ksf> and filter is a foldr
19:08:18 <ddarius> jfredett: Modulo some "optimizations" like the above, you need to have variables for pl to do anything.
19:08:30 <jfredett> ddarius: ah. i see.
19:08:35 <dolio> What is the value of 'filter (const False) [1..]'?
19:09:10 <mmorrow> , fmap (\x -> abs (x - (1 + sqrt 5)/2)) . fmap (uncurry (/)) . (zip`ap`tail) . fmap fromIntegral $ fix ((0:) . scanl (+) 1)
19:09:12 <lunabot>  [1.618033988749895,0.6180339887498949,1.118033988749895,0.951367322083228...
19:09:14 <ksf> but there _are_ numbers < 100 and it should print them.
19:09:45 <ksf> not using filter doesn't make the list less infinite.
19:09:46 <dolio> Lambdabot forces the whole string before printing anything.
19:09:50 <ksf> @unlet filter
19:09:50 <lambdabot>   Parse error: SemiColon
19:09:57 <ksf> @undef filter
19:10:02 <ksf> > filter (<100) $ fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:10:06 <lambdabot>   mueval-core: Time limit exceeded
19:10:18 <ksf> then why does
19:10:23 <ksf> > fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:10:24 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:10:28 <ksf> print stuff?
19:10:31 <mmorrow> , dropWhile ((> 0.01) . snd) . zip [0..] . fmap (\x -> abs (x - (1 + sqrt 5)/2)) . fmap (uncurry (/)) . (zip`ap`tail) . fmap fromIntegral $ fix ((0:) . scanl (+) 1)
19:10:32 <lunabot>  [(1477,NaN),(1478,NaN),(1479,NaN),(1480,NaN),(1481,NaN),(1482,NaN),(1483,...
19:10:39 <mmorrow> awesome
19:10:40 <ivanm> @quote zip`ap`tail
19:10:41 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:10:54 <ksf> or does lamdabot do a take on the list?
19:11:25 <dolio> Because it only takes a few tens of characters to print to the screen.
19:11:29 <dolio> Then forces that.
19:11:30 <ksf> > filter (<10000) $ fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:11:31 <dolio> Then prints it.
19:11:34 <lambdabot>   mueval-core: Time limit exceeded
19:11:46 <ksf> > filter (<100000000) $ fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:11:49 <lambdabot>   mueval-core: Time limit exceeded
19:12:02 <ksf> > filter (<10000000000000000000000000000) $ fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:12:03 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:12:08 <ksf> gosh.
19:12:39 <dipponaught> if fib is an inf list why wouldnt "(filter (<100) (filter even fib))" not just return an inf list?
19:12:50 <ksf> it does.
19:12:51 <dolio> Maybe it's a little less lenient than I was describing. But that's the idea.
19:12:54 <mmorrow> , (filter even . takeWhile (< 100)) (let fib !m !n = m : fib n (m+n) in fib 0 1)
19:12:56 <lunabot>  [0,2,8,34]
19:13:04 <mmorrow> there are only 4 such numbers
19:13:09 <ddarius> dipponaught: There aren't an infinite number of numbers less than 100.
19:13:10 <ksf> it's the outputting that messes stuff up.
19:13:25 <dipponaught> ksf: ahhhhhhhhhh
19:13:33 <ddarius> It returns a list of the items less than 100 and then it takes forever to determine if there should be another element or not.
19:13:43 <ksf> so, yes, it returns an infinite list, but you're going to have to wait infinitely for the next element.
19:14:12 <ksf> and dumb lambdabot messes up printing of the first elements.
19:14:26 <ksf> @botsmack
19:14:26 <lambdabot> :)
19:14:27 <lunabot>  :o
19:14:42 <dipponaught> makes sense
19:14:54 <dolio> There is no next element.
19:15:09 <ksf> in theory, there is.
19:15:19 <ddarius> ksf: In theory, we know there isn't.
19:15:20 <dolio> No, there isn't.
19:15:21 <dipponaught> whoever runs tunes.org/~nef/ should get it in the google index...
19:15:23 <ksf> in practice, though, theory differs from practice.
19:15:33 <ksf> it's still codata.
19:16:03 <ksf> ddarius, but only if we're smarter than haskell.
19:16:06 <ddarius> ksf: filter is a catamorphism, a foldr like you said.  You can't safely apply a catamorphism to codata.
19:16:28 <ksf> it's a hylo.
19:16:34 <ddarius> This example is an example why.
19:16:40 <ksf> ...using a foldr in contrast to a foldl
19:16:43 <mmorrow> , vacuum (fix (0:))
19:16:45 <dolio> No, filter is a cata.
19:16:46 <lunabot>  [(0,[1,0]),(1,[])]
19:16:53 <ksf> which makes it safe for codata, if you don't mess up.
19:17:13 <ddarius> ksf: hylos are compositions of catas and anas, but hylos are Turing-complete.
19:17:53 <ksf> ...erm my point was that the cata can return useful partial data.
19:18:11 <ddarius> It does, the first few elements.
19:18:36 <ddarius> But that's not a general property as filter (< (-1)) would show.
19:18:50 <ksf> sure
19:19:05 <ksf> let's say potentially safe.
19:19:33 <ksf> in as a foldr would'nt fuck up as sure as a foldl.
19:20:15 <ksf> (which is why I looked at the source)
19:20:20 <monochrom> That whole "in theory... in practice" is dumb. In which theory, in whose theory? There are multiple theories. Your theory differs from practice? Then use a more realistic theory. People love that dumb saying because of sour grape, not because it is correct.
19:20:47 <ksf> in theory, theory doesn't differ from practice.
19:20:59 <ksf> because in theory theory is practice.
19:21:30 <ivanm> ksf: >_>
19:21:37 <ksf> I'd rather call it a universial wisdom.
19:21:38 <monochrom> In your theory, your theory is the same as practice. In practice, your theory differs from practice. It is your problem and your choice. You choose the wrong tool, don't blame the tool.
19:21:48 <ksf> ...realizing that there just might be no theory of everything.
19:22:00 <ksf> (at least one one usable for practical means)
19:22:25 <ksf> s/one/none
19:23:34 <monochrom> As a counterexample, in my theory, all theories already differ from practice.
19:23:56 <ksf> so you can't apply any of them.
19:24:11 <ddarius> monochrom: Over his head monochrom.
19:24:31 <bcw> ksf: bend to fit, paint to match ;)
19:25:21 <monochrom> For each theory, I know in which way it matches practice and in which way it differs from practice, and I use that particular theory accordingly. I can apply it alright.
19:26:02 <ksf> see you have to map theory and practice 1:1 to use it, but in fact that's impossible. that's the dichtonomy. whether or not your theory includes that doesn't matter, it's a mental, not a metaphysical question.
19:26:29 <monochrom> No.
19:26:37 <ksf> you can't know whether it matches practice because all your experience about practice is merlely theory.
19:27:04 <ksf> see, there's a limit to perception.
19:27:08 <ksf> cf. kant.
19:28:07 <ksf> which is not only rooted in quantum-mechanical observer influences the observed stuff, but also in the simple fact that the thing you percieve isn't your perception of the thing.
19:29:17 <ksf> as the buddhists like to ask "who is the master that makes the grass green?"
19:29:56 <ksf> the moon on the sea image is about the same stuff, btw.
19:30:18 <bcw> ksf, ever heard of a model?  a theory doesn't have to be 100% accurate to use it (although when it becomes very inaccurate, using it doesn't work well)
19:30:35 <ksf> sure.
19:31:08 <ksf> but if it's not 100% accurate you're bound to say "gosh, in practice, theory differs from practice"
19:31:33 <ksf> ...I'm just defending that alledgedly cynistic saying.
19:31:44 <Saizan> i guess you just have to postulate that only what has an observable effect has a chance to affect you, then you care only on differences from practice that only matter in practice
19:32:05 <bcw> ksf, no you're not.  if it works for what you're trying to do (e.g. the critical assumptions are valid), you don't run into the cases where it's wrong and you're not bound to say anything
19:32:22 <ksf> then I don't.
19:32:32 <bcw> unless someone tries to use it in a way that isn't valid
19:32:37 <ksf> but I reserve the right to do if the theory hits the fan.
19:33:12 <Saizan> (bah, that sentence is screwed)
19:33:48 <ksf> swearing is one of the most basic and most important aspects of mastering any human language.
19:33:49 <ksf> cherish it.
19:34:15 <jfredett> ksf: damnit.
19:34:42 <ksf> it fullfills a quite similar role to laughter.
19:34:55 <ksf> as laughter.
19:35:03 <ksf> my english deteriorates all the time.
19:35:17 <ddarius> Speaking is overrated.
19:35:26 <ksf> mu
19:36:51 * ksf gives up on those patterns
19:39:28 <ksf> mhhh is there a design doc for yi?
20:06:06 * ksf sets out to read the yi source alphabetically and hopes something's gonna stick.
20:16:01 <aavogt> ksf: there's a paper from 2005 on yi: http://www.cse.unsw.edu.au/~dons/papers/SC05.html
20:16:23 <aavogt> but I think that it has probably changed quite a bit since then
20:46:41 <Person_> Hey all!n
20:46:56 <Person_> Has anyone ever seen the error: cannot find -lgmp?
20:48:43 <ivanm> Person_: do you have the GMP libraries installed?
20:49:37 <Person_> I'm SSHing into a university machine
20:49:50 <ivanm> well, does that machine have the GMP library?
20:50:08 <ivanm> when I say "you", I mean "that computer that is having that problem" ;-)
20:50:10 <c_wraith> also, if it's debian or debian based, it needs the -dev package.
20:50:26 <Person_> I assume so
20:50:52 <c_wraith> it's quite likely it's a debian based machine with the lib package, but not the -dev package.
20:52:15 * ivanm has never understood that split setup of debian and fedora based distros...
20:55:58 <m3ga> ivanm: its so that non-developer machines do not need to install headers, static libraries etc to get the library itself.
20:56:25 <ivanm> and? does that really provide that much of a benefit?
20:57:36 <m3ga> yes, when you consider gnome which uses well over 100 libraries, the headers, devel docs, static librarys etc will be > 1 Gig.
20:57:53 <m3ga> for embedded systems of client desktops, that is significant.
20:57:59 <m3ga> s/of/or/
20:58:28 <ivanm> OK, I suppose it makes sense for embedded or old machines
20:58:41 <ivanm> (but in that case, why are they using gnome rather than something lighter?)
21:00:58 <m3ga> something lighter will still use a truckload of libraries.
21:01:34 <m3ga> if you replace gnome with lxe or whatever, the vast majority of the gnome libs will still be needed because of user apps
21:01:52 <m3ga> the exact same goes for KDE/QT
21:02:32 <ivanm> well, it depends on what user apps you use
21:02:34 <Draconx> I think the invention of the 1 gigabyte hard disk has made it pretty pointless to not install header files, which rarely amount to more than a few kilobytes.  Static libraries and docs are a different matter.
21:02:54 <Draconx> maybe for packages that have megabytes of headers, the split makes sense.
21:03:52 * pumpkin moos loudly
21:05:02 <ivanm> pumpkin: no, I'm not going to milk you
21:05:06 <pumpkin> damn
21:05:07 <ivanm> keep your fetishes elsewhere!
21:05:08 <m3ga> Draconx: wouldn't you find it annoying is some lib packages installed headers and others did not? as it is there is a simple rule; if you want the headers for libfoo, install libfoo-(dev|devel).
21:05:29 <ivanm> m3ga: yes, but how many people know to do that when they're building custom software or something?
21:05:46 <Draconx> m3ga, it'd be great except that all too often, incompetent admins forget to install -dev packages.
21:05:47 <sproingie> people building software?  most of them.
21:06:23 <m3ga> the devs who don't know and new to linux, learn it once and never forget.
21:06:29 <m3ga> s/and/are/
21:07:12 <Person_> Haskell is a real headscratcher
21:07:20 <Person_> How did you guys get interested in it? If I may ask
21:07:25 <pumpkin> Person_: do you enjoy scratching your heads?
21:07:28 <pumpkin> oh wait, you only have one
21:07:30 <pumpkin> sorry :)
21:07:34 <Person_> Well, two
21:07:35 <pumpkin> oh
21:07:38 <pumpkin> ouch
21:07:38 <Person_> There's the head on the shaft
21:07:40 <sproingie> Person_: malbolge was too easy
21:08:08 <pumpkin> Person_: my girlfriend was taking a course on it and it looked interesting, so I took a closer look and got sucked in
21:08:09 <m3ga> Person_: i found it via ocaml which i found because i was looking for a compiled langauge with strict static type checking.
21:08:19 <Draconx> m3ga, Though I think systems with such small storage devices that header size is significant generally don't run ubuntu/fedora/whatever.
21:08:46 <Draconx> e.g. I don't run ubuntu on my mips machine that has 4 megabytes of non-volatile memory.
21:09:00 <Person_> LOL mips
21:09:05 <m3ga> netbooks? recent laptops with flash drives/
21:09:16 <Person_> I took a class on MIPS architecture and assembly
21:09:23 <BMeph> Also remember: most of these rules about the -dev file split were made over fifteen years ago.
21:09:25 <Person_> Interesting, interesting class :)
21:09:39 <Person_> Hey guys, what's the difference between jump, and jump and link?
21:09:43 <pumpkin> Person_: so are you enjoying haskell?
21:09:53 <m3ga> BMeph: and there has been no good reason the change them :-)
21:09:53 <pumpkin> one saves where you were before jumping
21:10:04 <sproingie> i discovered haskell through ocaml too, discovered ocaml because i discovered some software in it and got intrigued
21:10:13 <Person_> pumpkin: I was kidding, it was a question asked in my discussion section, haha
21:10:15 <Person_> pumpkin: I feel like a child again...
21:10:17 <pumpkin> :)
21:10:18 <p_l> Person_: you meant jump vs. subroutine call?
21:10:22 <Person_> I started with Java at 15, in AP Computer Science
21:10:29 <Person_> I have not been this confused with a programming language in... 6 years
21:10:31 <Draconx> m3ga, netbooks and recent laptops have several gigabytes of storage, do they not?
21:10:32 <pumpkin> on many archs it's called jump/branch + link
21:10:33 <sproingie> i'd have stuck with ocaml except i just can't take the syntax
21:10:43 <pumpkin> or mips and arm at least
21:11:15 <BMeph> m3ga: Not so much a good reason to change, as no compelling reason to do so.
21:11:16 <p_l> pumpkin: at least on mips and arm it should have normal semantics... (like dump PC on stack, jump to target)
21:11:31 <pumpkin> on arm it actually stores the old place in a register
21:11:33 <sproingie> Person_: the great thing about haskell is there's always something more to learn
21:11:42 <m3ga> like BMeph the -dev split was decided on > 10 years ago, and there has not yet been a compelling enough reason to break it.
21:11:43 <p_l> pumpkin: but there's no register stack, right?
21:11:56 <pumpkin> p_l: nope, so you usually stick that register on the stack before a function call
21:12:16 <Draconx> m3ga, my main complaint is that new systems copy this idea.
21:12:16 <p_l> heh. MMIX doesn't have memory-backed stack xD
21:12:29 <sproingie> MIX and MMIX are gratuitously weird
21:12:41 <p_l> sproingie: MMIX outside of linking isn't that weird...
21:12:43 <m3ga> there are a bunch of devices where i can happily do without the -dev packages if i can get more music storage.
21:12:47 <p_l> MIX I heard was much weirder
21:13:00 <Person_> My linux printer driver belongs in Special Ed, lol
21:13:09 <Person_> It spools up, prints one page, cools down
21:13:12 <Person_> Prints another page, etc.
21:13:13 <sproingie> MIX is extremely weird, yes
21:13:23 <sproingie> it's basically what turned me off of AoCP
21:13:31 <m3ga> 1 Gig is well over 10 albums worth of music
21:13:41 <sproingie> it felt more like i was solving knuth's puzzle rather than actually learning
21:13:43 <p_l> When I described MMIX subroutine calls to a certain friend, he responded "looks like SBCL's calling convention"
21:13:45 * ksf chose haskell by comparing the advancedness of the top scorers at the shootout.
21:14:03 <pumpkin> ooh ksf is a performance whore
21:14:05 <ksf> ocaml was close, but failed due to being insufficiently pure.
21:14:15 <ksf> not nescessarily.
21:14:22 <sproingie> some of that shootout sample code is highly unidiomatic
21:14:26 <pumpkin> ksf: you're barsoap on reddit, right?
21:14:36 <ksf> ...but why code in ruby if your program could finish to run in this millennium.
21:14:39 <ksf> yep.
21:15:03 <Boney> m3ga: Are you going to LCA2010?
21:15:18 * arcatan read about functional programming and Haskell when he was 15 and is still here
21:15:18 <Boney> m3ga: I'm writing a proposal for the multicore miniconf.
21:15:20 <ksf> did I do anything bad?
21:15:23 <arcatan> it's been 5 years!
21:15:28 <pumpkin> ksf: nope, just curious :)
21:15:47 <BMeph> I think I discovered Haskell through slava and Factor. I'm and old (!) Forth hacker, and Haskell seemed completely unlike anything else I'd seen before. Especially, it is Totally unlike Java (not that there's anything wrong with that... ;).
21:16:12 <aavogt> slava?
21:16:17 <pumpkin> mr factor
21:16:44 <aavogt> @google slava
21:16:45 <lambdabot> http://en.wikipedia.org/wiki/Slava
21:16:45 <m3ga> Boney: not 100% sure. bought a house last 15 months ago and didn't get expected pay rise due to GFC. cash is still a little tight :-)
21:16:46 <lambdabot> Title: Slava - Wikipedia, the free encyclopedia
21:16:54 <ksf> well I'm doing a lot of unqualified talking about CT there, atm.
21:16:55 <sproingie> @google slava pestov
21:16:56 <lambdabot> http://en.wikipedia.org/wiki/Slava_Pestov
21:16:56 <lambdabot> Title: Slava Pestov - Wikipedia, the free encyclopedia
21:17:25 <ksf> ...so if you feel like it, correct me on http://www.reddit.com/r/programming/comments/9sv86/abstract_absurdities_how_to_teach_category_theory/c0ecio5
21:17:37 * pumpkin is a CT noob :)
21:18:30 <dolio> You're barsoap?
21:18:36 <Boney> m3ga: I understand.
21:18:49 <ksf> I was intrigued by the possibility to explain what a cat is by limiting oop classes.
21:18:52 <ksf> dolio, yes
21:18:54 <Boney> m3ga: likewise, I'm pretty sure that I'll go but don't know.
21:19:04 <Boney> m3ga: I'll lookout for you though.
21:19:04 <pumpkin> ksf: wow, you actually got zahlman to stop being caustic! congratulations
21:19:13 <m3ga> i;ve only missed 3, ever :-)
21:19:22 <Boney> oh nice.
21:19:23 <pumpkin> it's amazing how unpleasant people on the internet can be
21:19:27 <ksf> such is the power of guidance of our lady.
21:19:30 <Boney> my frist one was 2007, I missed 2009;
21:20:05 <m3ga> missed 1999, missed 2003 (daughter was born 2 weeks earlier) and missed last year
21:20:16 <Boney> ah,
21:20:35 <m3ga> it would be great to catch up with a bunch of FP people at lca. will try to make it.
21:20:57 <m3ga> we've been having fp-syd here in sydney and its been really greate
21:21:04 <ksf> well, they're yining from the world, so they're yanging into the internets.
21:23:27 * BMeph prefers the term "teh intarwebs"
21:24:00 <fnord123> Is this some kind of croatian haskell library: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/usage.html#id274283
21:24:03 <dolio> ksf: Well, what you describe probably follows the category laws, so it qualifies.
21:24:30 <pumpkin> but don't show ksf the proof cause he doesn't like proofs ;)
21:24:42 <dolio> Right.
21:26:06 <ksf> mathematicians never heard of the concept of "rough consensus and running code", did they?
21:26:33 <pumpkin> they call it statistics
21:26:44 <pumpkin> by the way, are there any interesting applications of CT to statistics?
21:26:51 <dolio> I'm not sure whether it's appropriate to say that the class forms a category. But that's just a question of definitions of words.
21:35:24 <c_wraith> Wow.  I solved a kind error for the first time ever!
21:35:48 <pumpkin> yay
21:36:06 <c_wraith> Of course...  I feel like I've got an incorrect mental model
21:36:14 <pumpkin>  kinds are pretty simple
21:36:30 <ksf> kinds are the type of types.
21:36:37 <ksf> and sorts are the types of kinds.
21:37:00 <ksf> then theres' thingies, fuzzies, sweets, booms, pungents, and prickles.
21:37:41 <c_wraith> type WrappedGame = ExceptionalT GameError (RWS GameEnv Logger GameState) ()
21:37:45 <pumpkin> boomclasses sound fun
21:37:46 <c_wraith> Seems wrong to me.
21:38:00 <c_wraith> ooh, I know.  I need something like GameM
21:38:00 <ksf> ...not to forget orange. but it's patron is present so I shouldn't mention it.
21:38:06 <c_wraith> And that would just be GameM ()
21:39:21 <pumpkin> :O
21:39:29 <c_wraith> yes, that's much better.  Now I can have return types like GameM Int, if it makes sense
21:39:44 <ksf> or are you an impostor?
21:39:55 <pumpkin> I'm pretty orange
21:40:33 <ksf> mhhh but your eyes are void. that doesn't fit well with sight.
21:58:26 <ddarius> @google boom heirarchy
21:58:33 <lambdabot> http://citeseer.ist.psu.edu/182279.html
22:00:28 <jfredett> okay, quick MTL question--
22:00:42 <jfredett> :t runReaderT (lift . flip $ runStateT)
22:00:43 <lambdabot> forall b (m :: * -> *) a r. r -> b -> StateT b m a -> m (a, b)
22:00:55 <jfredett> the first argument is the reader context
22:01:02 <jfredett> the second is the initial state
22:01:11 <jfredett> the third is the stateT monad actons
22:01:23 <jfredett> the result is the result action.
22:01:25 <jfredett> right?
22:05:36 <ddarius> jfredett: Yes, question++
22:05:55 <jfredett> ... MTLs are confusing... :/
22:06:11 <ddarius> Just follow the types.
22:06:19 <jfredett> I'm trying to wrap up the various run-things into one function...
22:06:29 <jfredett> ddarius: yeh...
22:07:30 <jfredett> ooh, I have a kind problem... hmm
22:08:57 <Axman6> better than a mean one
22:13:51 <pumpkin> jfredett: what is it?
22:14:04 <jfredett> pumpkin: I fixed it, just missed a type variable on a function
22:14:45 <jfredett> Now I'm just trying to understand the types. I have a ReaderT `on` StateT `on` IO.
22:14:50 <jfredett> (pardon the pun...)
22:15:16 <jfredett> So I'm just trying to wrap the "run" function into one big bad runFilter
22:15:26 <jfredett> I'm redesigning some old code to be a bit nicer...
22:15:38 <jfredett> so I have to relearn some stuff.. :)
22:22:29 <Person_> I'm having a bit of difficulty with some IO, does anyone know how to convert an IO String to a String
22:22:36 <Person_> Or at the very least, return a String
22:22:46 <jfredett> Person_: you don't "Convert" to a string
22:22:48 <Person_> The best I could think of is makeString:: IO[String] -> String makeString a = return a
22:23:03 <jfredett> you can pull the stuff from the IO String temporarily and mess with it
22:23:18 <Person_>  Ah, any advice on pulling from the IO String?
22:23:31 <jfredett> so, for instance, `do {a <- return "foo" ; putStrLn a}`
22:23:59 <jfredett> will pull the string "foo" from the function "return" (which is just a placeholder for any function of type "... -> IO String"
22:24:03 <Person_> OK, I tried z <- putStrLn y, where y is from a readfile
22:24:13 <jfredett> and then prints it to stdout via putStrLn
22:24:27 <jfredett> sure, and thats in a `do` bracket, right?
22:24:46 <Person_> yes
22:24:47 <jfredett> eg `do {file <- readFile "foo" ; putStrLn file`
22:24:49 <pumpkin> Person_: one important point is that once you're "in" IO, you can never escape with impunity
22:24:50 <Person_> That is incredible
22:24:57 <Person_> z <- return y, works
22:25:09 <pumpkin> Person_: z <- return y === let z = y
22:25:12 <jfredett> mhm. return wraps it's argument in a monad.
22:25:25 <Person_> This makes sense now... I haven't converted anything!
22:25:34 <Person_> I have just scraped the text value
22:25:35 <jfredett> actually, you can just do `let z = y` -- or is that what you're saying. ? :)
22:25:36 <pumpkin> Person_: you're wrapping it and unwrapping it immediately when you do z <- return y
22:27:10 <jfredett> pumpkin: I suppose you could use it as a poor-mans 'let', eg: do {y <- foo; z <- (return $ bar y)} is roughly the same as do{y <- foo; let z = bar y}
22:27:29 <pumpkin> yeah, but why do that when you can just use the rich man's let :P
22:28:03 <jfredett> Person_: You can kind of think of the IO monad as a tag that values carry with them that marks them as "tainted", using `<-` is pointing at them and calling them dirty, dirty values.
22:28:12 <pumpkin> lol
22:28:26 <pumpkin> except the arrow is pointing away from the tainted values!
22:28:30 <pumpkin> towards the pure ones
22:28:34 <jfredett> You're not a pure String, you're a very naughty boy!
22:28:52 <jfredett> pumpkin: shh. don't mess with my joke... :)
22:29:00 * pumpkin shuts up :)
22:29:21 <Person_> Interesting
22:29:22 <jfredett> or, alternatly, imagine '<' is the palm of the hand pointing. I leave the rest of this metaphor to the reader.
22:29:46 <jfredett> Person_: the punchline is that IO tags the values as being impure, so that you can control where they are in your program.
22:30:07 <Person_> alright, so i have...
22:30:08 <Person_> y<-readFile "File.txt"
22:30:13 <Person_> z <- return y
22:30:16 <jfredett> I know that -- as far as I'm concerned, all the side-effecty functions will always have a IO tag with them.
22:30:18 <Person_> putStr z
22:30:21 <Person_> and it prints properly
22:30:26 <jfredett> you don't need z<-return y
22:30:42 <jfredett> putStr y ought to work too.
22:30:46 <Person_> I want to manipulate the string referenced by z
22:30:51 <jfredett> okay.
22:30:51 <pumpkin> :t putStr <=< readFile
22:30:52 <lambdabot> FilePath -> IO ()
22:31:14 <jfredett> Person_: so -- once you get the value from readfile, it's pure.
22:31:25 <jfredett> so you can pass y to any function expecting a string.
22:31:38 <jfredett> so long as you save it somewhere. so for instance:
22:31:56 <jfredett> do { y <- readFile "foo" ; let z = y ++ y ; putStrLn z }
22:32:12 <jfredett> gets the content of a file, concatenates it with itself and stores it in z
22:32:15 <jfredett> and then prints it
22:32:34 <jfredett> you don't _have_ to store it, you could do `putStrLn (y ++ y)`
22:32:43 <jfredett> since
22:32:46 <jfredett> :t putStrLn
22:32:47 <lambdabot> String -> IO ()
22:32:55 <jfredett> putStrLn expects a pure string.
22:33:08 <Person_> That's what I was missing...
22:33:58 <ivanm> jfredett: I'm sorry to dissapoint you, but I don't think I'll have any releases this week :p
22:34:08 <jfredett> ivanm: hehe.
22:34:20 <jfredett> 4 week run? That wasn't too shabby.
22:34:28 <ivanm> well, I could if I wanted to
22:34:32 <Person_> I think I'm doing something wrong here though,
22:34:35 <ivanm> I figured I'd just give you a week off :p
22:34:41 <Person_> I might be abusing 'let' to write C-Type statements
22:34:58 <jfredett> ivanm: lol. It only takes me 3-4 hours to put the whole thing together, and thats when I'm lazy...
22:35:13 <jfredett> Person_: hmm, why don't you paste what you have...
22:35:16 <jfredett> @where hpaste
22:35:16 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
22:35:19 <Person_> Sure
22:35:25 <jfredett> the former, not the latter.
22:37:34 <pumpkin> I wonder if bos is someone's boss
22:38:12 <absentia> xnoh sh!t ..
22:38:14 * absentia gets back to work.
22:38:35 <jfredett> hrm... can djinn derive functions for types with MTs in them? Hmm
22:38:46 <jfredett> @djinn StateT s m a -> s -> m (a,s)
22:38:46 <lambdabot> Error: Undefined type StateT
22:38:50 <jfredett> damn...
22:38:52 <bos> pumpkin: i am, and they call me "bos"
22:38:55 <fnord123> does anyone know of a tutorial for c2hs that makes any sense? The stuff on the official site makes no sense at all
22:39:00 <pumpkin> bos: sweet!
22:39:36 <jfredett> lol, I have a MT type `ReaderT Email (StateT Bool IO) a`
22:40:02 <jfredett> so I need to get the `m` in the signature of runReaderT to be the StateT thing...
22:40:17 <pumpkin> tie that typeknot
22:40:17 <jfredett> wait... do I runReaderT first?
22:40:21 <Person_> HOLY SHIT
22:40:25 <Person_> My program worked...
22:40:27 <pumpkin> nice!
22:40:32 <jfredett> Person_: good feeling, isn't it? :)
22:40:37 <absentia> ship it!
22:40:42 <Person_> LOL
22:40:44 <Person_> It's due on wednesday
22:40:59 <jfredett> Person_: Oh, whats the project?
22:41:04 <Person_> It's a homework assignment
22:41:09 <jfredett> I figured it was homework.
22:41:21 <Person_> Does anyone here live in the bay area?
22:41:26 <pumpkin> I wish
22:41:28 <jfredett> it had the Homeworkian smell to it.
22:41:36 <jfredett> Pshaw, Worcester, MA.
22:41:47 <pumpkin> Wooster!
22:41:48 <jfredett> Home of Candlepin Bowling, the Diner, and Evil.
22:41:53 <Person_> damn...
22:42:09 <Person_> I'm taking a class on programming languages, and we're learning Haskell
22:42:15 <Person_> I would recommend people stop by
22:42:18 <jfredett> pumpkin: Woostah... :0
22:42:25 <pumpkin> Person_: I was at stanford a few months ago though! you should've called me then :P
22:42:27 <pumpkin> tsk tsk
22:42:31 <jfredett> also, go sox. :)
22:42:36 <pumpkin> failsox
22:42:56 <Person_> pumpkin: I go to stanford
22:42:59 <Person_> :)
22:42:59 <pumpkin> I know :P
22:43:00 <jfredett> pumpkin: you must be talking about the whitesox.
22:43:06 <Person_> pumpkin: How'd you know?
22:43:13 <pumpkin> Person_: /whois yourself :P
22:43:20 <jfredett> because there is no way one could describe my sox as 'fail'
22:43:24 <augur> so
22:43:24 <Person_> ...
22:43:25 <augur> guys
22:43:27 <pumpkin> jfredett: I'm talking about all sox, I'm a flipflopz dude
22:43:28 <augur> how are things
22:43:35 <Person_> I guess webchat Isn't that anonymous
22:43:52 <Gracenotes> just your IP address
22:44:18 <Person_> haha, this is nifty
22:44:21 <Person_> O
22:44:33 <Person_> I'll pasted up what worked, vs what failed... big difference
22:45:16 <pumpkin> Person_: your secret is out!
22:45:41 <Person_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4360#a4360
22:46:02 <Person_> There's a 10-20% chance my TA's or Profs lurk here
22:46:10 <Person_> They're gung-ho about haskell
22:46:15 <pumpkin> your FAIL is fail because let x = y (without an "in" afterwards) only works in do blocks
22:46:17 <chid> haha
22:46:20 <chid> moonpatio?
22:46:33 <pumpkin> chid: that's mmorrow's secret lair
22:46:51 <Person_> I understand what's going on... a bit more now
22:46:53 <chid> Okay
22:47:04 <Person_> In the fail: I was abusing let, to try and work on c syntax
22:47:14 <pumpkin> Person_: most people who have taken the time to learn haskell are pretty gung ho about it (with varying levels of obnoxiousness)
22:47:16 <Person_> Or c-type stored-value programming
22:47:17 <chid> Person_, 12chan.org/girl/ 30-40% chance your Profs or TA's lurk here
22:47:20 <chid> even post
22:47:29 <chid> Oh
22:47:34 <pumpkin> Person_: yeah. you can write pretty imperative programs inside a do block :)
22:47:35 <medfly> why would they, apparently profs can just get sexual favours from students
22:47:38 <Person_> I once had a professor pronounce 'fortran' as 'fourchan'
22:47:46 <pumpkin> Person_: or do crazy stuff
22:47:46 <chid> medfly, and get caught
22:47:47 <Person_> Well, a lecturer, not a prof
22:47:52 <pumpkin> pff titles
22:49:01 <jfredett> pumpkin: *points at augustss' C DSL* some _really_ imperative programs. :)
22:49:08 <pumpkin> oh yeah :)
22:49:11 <pumpkin> or his basic one
22:49:13 <Person_> Ha Ha! This works...
22:49:41 <jfredett> ... MTs make my head hurt... I just want to run the thing... :/
22:49:50 <pumpkin> Person_: you'll be written supergolfed fibonaccis and primes in no time!
22:50:17 <Person_> If I say
22:50:25 <Person_> x <- getArgs
22:50:38 <Person_> And I want to grab the first element as a string to process as a file path
22:50:44 <Person_> Is it appropriate to later write:
22:50:49 <Person_> convert:: [String] -> FilePath
22:50:53 <Person_> convert a = head a
22:50:54 <pumpkin> (x : _) <- getArgs
22:50:58 <pumpkin> or that
22:51:25 <pumpkin> kind of weird that you're switching between String and FilePath though. They happen to be the same thing but it's best to be consistent
22:51:55 <pumpkin> or (first : rest) <- getArgs
22:52:13 <pumpkin> but if you have no args it'll spit out an error, obviously
22:53:13 <Person_> Of course, but we're learning basic haskell
22:53:23 <Person_> I don't think file sanitization is our highest priority
22:53:32 <Person_> or rather, input checking
22:53:36 <pumpkin>  pattern matching is as basic as it gets :)
22:53:41 <pumpkin> yep
22:54:30 <Person_> For shame, that was my last coding submission
22:56:28 <pumpkin> but I bet you want to do more just cause it's fun!
22:56:49 <Person_> I do...
22:57:03 <pumpkin> > scanl1 (+) [1,3..]
22:57:04 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
22:57:06 <pumpkin> whee!
22:57:18 <Person_> I'm pretty resistant to change though
22:57:56 <Person_> I quote from my freshman year: "Why would you want to use recursion? This is an insane way to deal with datasets. Iteration debugs easier, and is more flexible"
22:58:01 <jfredett> scanl1 (+) (scanl1 (+) [1,3..])
22:58:06 <pumpkin> Person_: :)
22:58:08 <jfredett> > scanl1 (+) (scanl1 (+) [1,3..])
22:58:08 <lambdabot>   [1,5,14,30,55,91,140,204,285,385,506,650,819,1015,1240,1496,1785,2109,2470,...
22:58:13 <Person_> Also:
22:58:19 <Person_> "Recursion is a massive ponsi scheme"
22:58:27 <medfly> o.O
22:58:30 <Person_> And I still have much to learn, haha
22:58:40 <jfredett> > scanl1 (-) (scanl1 (+) [1,3..])
22:58:41 <lambdabot>   [1,-3,-12,-28,-53,-89,-138,-202,-283,-383,-504,-648,-817,-1013,-1238,-1494,...
22:58:57 <jfredett> > scanl1 (*) (scanl1 (+) [1,3..])
22:58:58 <lambdabot>   [1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,15...
22:59:02 <sohum> :info ($)
22:59:05 <jfredett> fun...
22:59:09 <sohum> @info ($)
22:59:09 <lambdabot> ($)
22:59:16 <sohum> that's not fun
22:59:18 <pumpkin> > fix ((0:) . scanl (+) 1)
22:59:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:59:26 <ddarius> Let's iterate over a tree.
22:59:30 <sohum> infixr 0, right
22:59:32 <Person_> > putStr "KNOCK IT OFF PUMPKIN"
22:59:33 <lambdabot>   <IO ()>
22:59:33 <jfredett> ddarius: lets!
22:59:38 <Person_> damn
22:59:42 <medfly> :)
22:59:45 <Person_> > putStrLn "KNOCK IT OFF PUMPKIN"
22:59:46 <lambdabot>   <IO ()>
22:59:49 <Person_> DAMN!
22:59:51 <medfly> > "KNOCK IT OFF!"
22:59:52 <jfredett> > "No IO For you, Person_"
22:59:53 <lambdabot>   "KNOCK IT OFF!"
22:59:53 <lambdabot>   "No IO For you, Person_"
22:59:55 <pumpkin> > text "KNOCK IT OFF PUMPKIN"
22:59:56 <lambdabot>   KNOCK IT OFF PUMPKIN
22:59:57 <jfredett> :)
23:00:01 <sohum> Person_: lambdabot doesn't execute IO actions, just returns them
23:00:12 <pumpkin> > nubBy isMultipleOf [2..]
23:00:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:00:17 <jfredett> Person_: that way, you can't do naughty things..
23:00:26 <Person_> > map (+ 1 )[1,2,3,4,5]
23:00:27 <lambdabot>   [2,3,4,5,6]
23:00:37 <Person_> I still have much to learn re: lambda calculus
23:00:40 <jfredett> > even 2
23:00:41 <lambdabot>   True
23:00:44 <Person_> map . map, etc.
23:00:44 <ddarius> "To iterate is illiterate, to recurse worse, to avoid this trap see, instructions for mapc."
23:01:11 <jfredett> > foldr (&&) (map even [1..])
23:01:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:01:12 <lambdabot>         against inferred type ...
23:01:15 <sohum> how does haskell expand (+2)-like sections, btw?
23:01:26 <jfredett> > foldr1 (&&) (map even [1..])
23:01:26 <lambdabot>   False
23:01:27 <ddarius> @where onlinereport
23:01:27 <lambdabot> I know nothing about onlinereport.
23:01:32 <ddarius> @where report
23:01:33 <lambdabot> http://www.haskell.org/onlinereport/
23:01:39 <jfredett> > foldr1 (&&) (map (<100) [1..])
23:01:40 <lambdabot>   False
23:01:43 <sohum> danke, ddarius
23:01:54 <jfredett> huzzah for compactness!
23:02:00 * BMeph prefers nubBy (((>1).).gcd) to the mod/multiples thing
23:02:28 <jfredett> @pl (\x y z -> x y (z y))
23:02:28 <lambdabot> (`ap` flip id) . ((.) .)
23:02:52 <jfredett> @pl (\x y z -> x y (y z))
23:02:52 <lambdabot> ((.) =<<)
23:02:59 <jfredett> thats interesting...
23:03:16 <jfredett> @pl (\x y -> x y (y x))
23:03:16 <lambdabot> ap ap (flip id)
23:03:27 <sohum> ah, so it does construct a new variable
23:03:30 <BMeph> @pl \x y z -> x z (y z)
23:03:30 <lambdabot> ap
23:03:51 <sohum> :t ap
23:03:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:04:17 <jfredett> ... *is going to try to find the function which makes \bot say 'ap ap ap'...*
23:04:19 <ddarius> > (`or`) []
23:04:19 <jfredett> :t ap ap ap
23:04:20 <lambdabot>   <no location info>: parse error on input `)'
23:04:21 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
23:04:21 <lambdabot>     Probable cause: `ap' is applied to too few arguments
23:04:21 <lambdabot>     In the second argument of `ap', namely `ap'
23:04:44 <jfredett> aww... it won't wokr.
23:04:47 <jfredett> work even.
23:04:50 <sohum> :t ap ap
23:04:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m (a -> b) -> m a) -> m (a -> b) -> m b
23:04:54 <ddarius> jfredett: @pl doesn't type check
23:05:00 <BMeph> @pl \x y z -> x (y z) z
23:05:00 <lambdabot> flip flip id . liftM2
23:05:00 <jfredett> oh? hmm.
23:05:04 <jfredett> there is hope.
23:05:27 <jfredett> @pl \x y z -> (x y) y (y x)
23:05:28 <lambdabot> (const .) . liftM2 ap join (flip id)
23:05:46 <jfredett> pl = fun.
23:07:37 <jfredett> Hah! it works...
23:07:40 <BMeph> @pl \x y z -> y (x z) z
23:07:40 <lambdabot> flip flip id . (ap .) . flip (.)
23:07:48 <jfredett> that has got to be the ugliest function I've ever written...
23:07:53 <jfredett> time to clean it up.
23:08:00 <jfredett> HLint to the rescue!
23:09:14 <jfredett> okay, that wasn't much help...
23:09:57 <jfredett> @pl \f s em -> (\(x,y) -> (y,x)) (flip (runStateT $ lift (runReaderT em)) s f)
23:09:57 <lambdabot> ((uncurry (flip (,)) .) .) . flip . flip (runStateT . lift . runReaderT)
23:10:15 <jfredett> .... hmm, that runState.lift.runReaderT looks nice...
23:10:27 <ddarius> jfredett: You shouldn't need lift just to run a computation.
23:10:31 <jfredett> @pl \f s em -> (flip (runStateT $ lift (runReaderT em)) s f)
23:10:31 <lambdabot> flip . flip (runStateT . lift . runReaderT)
23:10:48 <jfredett> ddarius: I just did what I had to to get the right type.
23:11:21 <aavogt> @type lift . flip runReaderT
23:11:21 <lambdabot> forall (t :: (* -> *) -> * -> *) b (m :: * -> *) a. (MonadTrans t) => b -> t ((->) (ReaderT b m a)) (m a)
23:11:38 <jfredett> oh, wait...
23:11:43 <jfredett> thats the wrong type... shit.
23:11:55 * jfredett returns to square 1.
23:11:58 <ddarius> :t \r s m -> runStateT (runReaderT m r) s
23:11:59 <lambdabot> forall r s (m :: * -> *) a. r -> s -> ReaderT r (StateT s m) a -> m (a, s)
23:12:10 <ddarius> @pl \r s m -> runStateT (runReaderT m r) s
23:12:10 <lambdabot> flip . (runStateT .) . flip runReaderT
23:12:55 <ddarius> @pl \f g x -> f x (g x)
23:12:55 <lambdabot> ap
23:12:58 <aavogt> say you wanted to run one of the monad transformers in the middle of the stack, you would use lift then?
23:13:53 <ddarius> @pl \x y -> x y (\z -> x z (y z))
23:13:53 <lambdabot> ap ap ap
23:14:11 <jfredett> ddarius: yay!
23:14:58 <c_wraith> why is module imports forming a cycle bad, if every definition is well-founded?
23:15:21 <ddarius> It's not bad for a technical reason.
23:15:35 <c_wraith> In that case, is there a ghc flag to allow it? >_>
23:15:54 <ddarius> c_wraith: Read the User Guide.  It takes more than a flag.
23:16:09 <dolio> GHC needs help figuring it out.
23:17:43 <Person_> Alright, thanks for your help guys
23:17:53 <Person_> Off to sleep, I'll definitely be bugging you much more in the near future :)
23:17:55 <c_wraith> holy crap, that's complicated
23:18:01 <ddarius> I usually recommend breaking mutually recursive imports other ways.
23:18:21 <c_wraith> I guess I can do it by moving all the functions associated with this type into a different file.
23:18:27 <c_wraith> But that kinda hurts.
23:19:01 <c_wraith> Maybe completely reorganize into "data structures" and "functions"
23:19:12 <c_wraith> Instead of modules that are one data structure and associated functions
23:19:16 <ddarius> There's a few ways of doing it: 1) combine files, 2) pull out the parts causing recursion into a separate file, 3) program to interfaces so that the recursion is broken
23:20:30 <c_wraith> Hmm.  I can reorganize.
23:25:14 <ijnek> is hackage.haskell.org down?
23:25:19 <tomoj> I've got a Data.Digest.SHA1.Word160 from the crypto library. what's the general idea for turning this into a hex string?
23:26:26 <blackh> c_wraith: Sometimes (IMHO) it is not possible to break cyclic module dependencies.  It's perfectly possible to do it in GHC - you just have to follow the instructions in the user's guide.
23:26:50 <tomoj> I can pattern match against Word160 to pull out 5 individual Word32's and then do bit manipulation on them
23:27:11 <c_wraith> I can reorganize this well-enough.
23:27:35 <c_wraith> It's not a worse organization than I started with.  It is a sweeping change, but at least the codebase is small right now.
23:35:45 <stanv_> where is it possible see rules for double queue (deque) in general, not for haskell
23:35:49 <stanv_> ?
23:43:10 <BMeph> tomoj: Numeric.showHex, perhaps? ;)
23:43:33 <BMeph> stanv_ Try Wikipedia, that's what it's for. :)
23:45:37 <tomoj> BMeph: great, thanks
