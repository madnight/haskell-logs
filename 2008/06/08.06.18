00:01:20 <bos> the dependencies that are listed for packages on hackage are pretty loopy.
00:15:03 <chylli> when I install alex, I got error: Setup.lhs:30:43: Not in scope: `buildVerbose'
00:15:04 <chylli>  
00:21:29 <sjanssen> chylli: evidence of a Cabal version mismatch
00:21:46 <sjanssen> chylli: ghc-pkg list Cabal?
00:21:56 <chylli> root@arch:/home/chylli# cabal --version
00:21:56 <chylli> cabal-install version 0.4.6
00:21:56 <chylli> using version 1.5.1 of the Cabal library
00:21:56 <chylli>  
00:22:09 <chylli> root@arch:/home/chylli# ghc-pkg list Cabal
00:22:09 <chylli> /usr/lib/ghc-6.8.2/package.conf:
00:22:09 <chylli>     Cabal-1.2.3.0, Cabal-1.5.1
00:22:12 <chylli>  
00:26:28 <chylli> sjanssen: how to tell cabal to using the old Cabal pachakge ?
00:30:06 <sjanssen> chylli: you can ghc-pkg hide Cabal-1.5.1
00:30:40 <chylli> sjanssen: I'm using cabal install alex --cabal-lib-version=1.2.3.0
00:30:56 <chylli> sjanssen: and get :
00:30:58 <chylli> Linking dist/setup/setup ...
00:30:58 <chylli> setup: Unrecognised flags:
00:30:58 <chylli>  --constraint=array ==0.1.0.0
00:31:00 <chylli>  --constraint=base ==3.0.1.0
00:31:02 <jbapple> Does anyone have any insight on why "> let x = x" then "> x" does nothing in ghci, but, after ^c, "> x"  then notes: "*** Exception: stack overflow"
00:31:03 <chylli>  
00:31:06 <chylli> now
00:31:33 <sjanssen> chylli: you need Cabal 1.4.x
00:31:43 <sjanssen> this is the version you're supposed to use with cabal-install
00:32:08 <bos> jbapple: doesn't happen to me.
00:32:37 <jbapple> bos: you don't see
00:32:37 <jbapple> Prelude> let x = x
00:32:37 <jbapple> Prelude> x
00:32:37 <jbapple> Interrupted.
00:32:37 <jbapple> Prelude> x
00:32:38 <jbapple> *** Exception: stack overflow
00:32:43 <chylli> sjanssen: faint. why so many version problem
00:32:49 <chylli> sjanssen: thanks
00:33:00 <bos> jbapple: i get the overflow without a need for ^C
00:33:09 <sjanssen> jbapple: some weirdness with the thunk updates, I suppose
00:33:21 <sjanssen> jbapple: semantically the results are the same
00:33:38 <chylli> sjanssen: can I install 1.4.x directly by cabal-install , not download from hackage by hand ?
00:34:00 <vixey> jbapple, your blog is awesome
00:34:01 <vixey> :)
00:34:04 <sjanssen> bos: sometimes I get stack overflow immediately, sometimes I get a hang
00:34:07 <bos> jbapple: it could be ghc's black hole detection playing silly buggers.
00:34:18 <sjanssen> chylli: I'm not sure
00:34:47 <jbapple> sjanssen: my next question is
00:34:47 <jbapple> Prelude> :m + Control.Exception
00:34:47 <jbapple> Prelude> :m + Control.Exception
00:34:47 <jbapple> Prelude Control.Exception> evaluate (let z = z in z) `Control.Exception.catch` \e -> case e of (AsyncException StackOverflow) -> return "foo"; _ -> return "bar"
00:34:47 <jbapple> "bar"
00:34:54 <jbapple> (I pressed ^c there)
00:35:21 <jbapple> vixey: thanks! :-) I've been meaning to post a few more entries, but I haven't gotten around to it lately
00:35:40 <sjanssen> jbapple: what exception is actually returned?
00:36:06 <jbapple> sjanssen: Good question. Checking.
00:36:36 <jbapple> Prelude Control.Exception> evaluate (let z = z in z) `Control.Exception.catch` \e -> case e of (AsyncException StackOverflow) -> return "foo"; _ -> print e >> return "bar"
00:36:36 <jbapple> exception :: GhcException
00:36:36 <jbapple> "bar"
00:37:38 <mmorrow> awesome
00:37:38 <bos> that probably is ghc's black holing.
00:37:39 <mmorrow> > fix ((0:) . scanl (+) 1)
00:37:54 <lambdabot>  thread killed
00:38:13 <mmorrow> um
00:38:35 <mmorrow> > fix(:0)
00:38:36 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
00:38:36 <lambdabot>       Expected...
00:38:39 <mmorrow> > fix(0:)
00:38:40 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
00:38:40 <sjanssen> jbapple: I think you need to ask glasgow-haskell-users@haskell.org
00:38:45 <mmorrow> > fix ((0:) . scanl (+) 1)
00:38:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:39:05 <sjanssen> jbapple: there are probably only a few people that can really answer your question, and they'll pay attention there :)
00:39:08 <jbapple> sjanssen: but #haskell is *instant gratification* :-)
00:39:30 <jbapple> Thanks for the leads, y'all
00:39:42 <jbapple> I'll be around for a bit if anyone has any other ideas
00:40:16 <jbapple> bos: BTW, what's your setup? I'm 6.8.2 linux i368
00:43:24 <vixey> monochrom, ddarius, ?
00:44:11 <vixey> for the earlier problem, f . g = id -> f' . g' = id -> f . f' . g' . g = id is quite simply provable, but the proof of map (uncurry replicate) . map (length &&& head) is not going to happen
00:44:34 <vixey> it's actually false statement I think
00:44:41 <mmorrow> > length . show . (!!10000) $ fix ((0:) . scanl (+) 1)
00:44:42 <lambdabot>  2090
00:44:49 <mmorrow> > length . show . (!!50000) $ fix ((0:) . scanl (+) 1)
00:44:51 <lambdabot>  10450
00:44:56 <vixey> since there is no restriction of the groups being as they should,
00:45:02 <mmorrow> > length . show . (!!100000) $ fix ((0:) . scanl (+) 1)
00:45:06 <lambdabot> Terminated
00:45:12 <vixey> > map (uncurry replicate) . map (length &&& head) $ ["aaa","aaa","bb"]
00:45:14 <lambdabot>  ["aaa","aaa","bb"]
00:45:15 <mmorrow> > length . show . (!!80000) $ fix ((0:) . scanl (+) 1)
00:45:18 <lambdabot> Terminated
00:45:30 <vixey> > map (uncurry replicate) . map (length &&& head) $ ["aaa","","aaa","bb"]
00:45:31 <lambdabot>  ["aaa","","aaa","bb"]
00:45:33 <mmorrow> > length . show . (!!60000) $ fix ((0:) . scanl (+) 1)
00:45:36 <lambdabot>  12539
00:46:28 <vixey> (actuall I guess it's though the middle the problem happens)
00:48:49 <mmorrow> >  map (head . uncurry replicate) . map (length &&& id) $ ["aaa","","aaa","bb"]
00:48:50 <lambdabot>  ["aaa","Exception: Prelude.head: empty list
00:49:07 <mmorrow> >  map (head . uncurry replicate) . map ((+1) . length) &&& id) $ ["aaa","","aaa","bb"]
00:49:08 <lambdabot> Unbalanced parentheses
00:49:10 <vixey> oh
00:49:13 <mmorrow> >  map (head . uncurry replicate) . map (((+1) . length) &&& id) $ ["aaa","","aaa","bb"]
00:49:14 <lambdabot>  ["aaa","","aaa","bb"]
00:49:21 <sjanssen> hmm, are the haskell.org mailing lists stuck?  I haven't received any messages since this afternoon
00:49:22 <vixey> >  map (head . uncurry replicate . (length &&& id)) $ ["aaa","","aaa","bb"]
00:49:23 <lambdabot>  ["aaa","Exception: Prelude.head: empty list
00:49:32 <vixey> >  map (head . uncurry replicate . (length &&& id)) $ ["aaa","aaa","bb"]
00:49:34 <lambdabot>  ["aaa","aaa","bb"]
00:49:49 <mmorrow> >  map (((+1) . length) &&& id) $ ["aaa","","aaa","bb"]
00:49:50 <lambdabot>  [(4,"aaa"),(1,""),(4,"aaa"),(3,"bb")]
00:50:18 <mmorrow> >  map (head . uncurry replicate) . map (((min 1) . length) &&& id) $ ["aaa","","aaa","bb"]
00:50:20 <lambdabot>  ["aaa","Exception: Prelude.head: empty list
00:50:26 <mmorrow> >  map (head . uncurry replicate) . map (((max 1) . length) &&& id) $ ["aaa","","aaa","bb"]
00:50:28 <lambdabot>  ["aaa","","aaa","bb"]
00:54:38 <Axman6> mmorrow: trying to find the most complicated id you can?
00:55:30 <mmorrow> Axman6: always!
00:55:38 <Axman6> good luck :)
00:55:47 <mmorrow> Axman6: :)
00:56:07 <Axman6> i'd like to see the proof for that being id.
00:56:19 <Axman6> i think my lecturer may get off on doing that
00:56:37 <vixey> yeah but I think you can have trouble proving it
00:57:04 <Axman6> just need a base case, and a step case
00:57:09 <Axman6> or, a few probably
00:58:04 <vixey> Axman6: The challenge is to prove that rle and unrle work
00:58:18 <Axman6> rle?
00:58:36 <vixey> run length encode
00:59:06 <dolio> map (length &&& head) isn't the definition of RLE.
00:59:18 <ski_> > map head (map (head . uncurry replicate) . map (((max 1) . length) &&& id) $ [0:undefined])
00:59:20 <lambdabot>  [Exception: Prelude.undefined
00:59:20 <dolio> It needs group, which never produces empty lists.
00:59:34 <vixey> we realized that unrle = g . g' and rle = f' . f, so proving unrle . rle = id is pretty trivial if you have proofs of g . f = id and g' . f' = id
00:59:39 <dolio> Or, empty lists as elements of the overall list.
01:00:59 <vixey> the problem with that method is that .. the lemma is not provable :p
01:01:12 <BeelsebobWork> @hoogle [Maybe a] -> [a]
01:01:13 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
01:01:37 <ski_> (`map (head . uncurry replicate) . map (((max 1) . length) &&& id)' is not `id', either ..)
01:02:28 <vixey> rle = map (head &&& length) . group ; unrle = concat . (uncurry replicate)
01:02:31 <vixey> something like that
01:02:40 <vixey> concat . group = id
01:03:06 <vixey> oh it should be map (uncurry replicate)
01:03:48 <Axman6> where do group and &&& come from?
01:03:54 <Axman6> ghci doesn't seem to like them
01:04:11 <vixey> group "foobaaaar" ~> ["f","oo","b","aaaa","r"]
01:04:26 <vixey> (f &&& g) x = (f x, g x)
01:04:53 <dolio> So you only need to prove (strictly speaking), forall xss. all (\xs -> not (null xs)) -> xss = map (uncurry replicate) . map (length &&& head) $ xss
01:05:02 <dolio> Assuming you can make use of that.
01:05:14 <vixey> mm
01:05:20 <vixey> I think map fusion could be useful, maybe
01:05:34 <dolio> Oh, and the lists are guaranteed to have all elements be the same.
01:05:58 <ski_> s/->/xss ->/
01:06:35 <vixey> I think I will take another (7th ~_~) appemt
01:07:08 <Axman6> ah, now i see the point of group
01:07:35 <Axman6> kind of like what huffman(sp?) encoding does?
01:07:38 <Axman6> well part of it
01:07:44 <vixey> huffman is a lot more complex
01:08:07 <Axman6> yeah, but still
01:08:16 <vixey> well I don't think it's anything like huffman coding
01:08:32 <Axman6> ok, well, it's like something. :)
01:09:01 <Axman6> could be used for some kind of compression
01:09:27 <vixey> yes
01:09:33 <dolio> Huffman does what, counts all the blocks and then uses a priority queue to build a tree?
01:10:04 <vixey> the simplest huffman is you have a frequency count of every byte, then you make a tree such that large frequencies are at the top
01:10:33 <vixey> so you just end up using fewer bits for common bytes
01:10:41 <dolio> Right.
01:10:46 <Axman6> ah yes, getting it mixed up with something else
01:11:13 <vixey> the biggest limitation of huffman is that you always get an integral number of bits to represent a byte
01:12:26 <sjanssen> well, you can't really use half a bit, can you?
01:12:33 <vixey> yes you could
01:12:40 <vixey> (not with huffman coding though)
01:13:32 <dolio> Huh, â‹‹ for lambda...
01:24:00 <mwc> anybody have a patch to fix Haddock 2.1.0 compilation with GHC 6.8.3?
01:35:28 <chylli>   package ghc-6.8.2 requires Cabal-1.2.3.0
01:35:29 <chylli>   package yi-0.4 requires Cabal-1.5.2
01:35:29 <chylli>  
01:35:33 <chylli> faint
01:35:45 <hpaste>  morrow pasted "misc proof" at http://hpaste.org/8394
01:35:47 <chylli> this problem again and again.
01:35:53 <mmorrow> vixey: i started thinking about how to structure a proof for something like that and had a try
01:36:02 <chylli> anyone help me to install Yi ?
01:36:20 <vixey> mmorrow: I can't look... I'm trying myself :)
01:36:43 <mmorrow> vixey: :)
01:38:12 <Saizan_> chylli: where did you get the Yi package?
01:38:20 <chylli> Saizan_: from darcs
01:40:25 <quicksilver> it shuldn't matter should it chylli ?
01:40:28 <quicksilver> just install the new cabal
01:40:36 <quicksilver> it doesn't matter that ghc wants the old one
01:40:38 <quicksilver> as far as I know
01:41:04 <chylli> quicksilver: root@arch:/tmp/ghc-6.8.3# ghc-pkg list Cabal
01:41:04 <chylli> /usr/lib/ghc-6.8.2/package.conf:
01:41:04 <chylli>     Cabal-1.2.3.0, Cabal-1.4.0.1, (Cabal-1.5.1), Cabal-1.5.2
01:41:04 <chylli>  
01:42:00 <chylli> headacke
01:42:05 <chylli> headache
01:42:21 <PHO_> wait, you are using ghc-6.8.3 but "package ghc-6.8.2 requires Cabal-1.2.3.0"
01:42:34 <chylli> no non no
01:42:40 <chylli> i'm using ghc 6.8.2
01:42:43 <PHO_> ah, ok
01:42:52 <chylli> the ghc-6.8.3 is just an dir
01:42:58 <chylli> I just want to upgrade ghc
01:45:48 <chylli> anyone give me more advice ? I will remove ghc and reinstall it totally.
01:45:56 <Saizan_> chylli: try reconfiguring with configure --flags="-shim"
01:46:14 <chylli> Saizan_: let me try
01:46:18 <Saizan_> reinstalling ghc won't help
01:46:27 <Saizan_> imo
01:47:27 <chylli> Saizan_: not only reinstall ghc, I think the relationship of packages has been in disorder.
01:48:07 <Saizan_> byt that message it seems you'd have to recompile the ghc package i.e. the GHC-API against Cabal-1.5.2
01:48:37 <chylli> Saizan_: so I decide to reinstall all of ghc thins.
01:53:06 <GrayShade> would someone try to help me with this? http://hpaste.org/8395
01:55:42 <quicksilver> holy type errors, batman!
01:55:56 <quicksilver> GrayShade: I think you might get some better errors if you annotated your top level types :)
01:57:32 <quicksilver> I would try to force all those arrays to the same type for example
01:57:38 <quicksilver> unless you really need that generality
01:58:36 <dcoutts> chylli: is that the latest version of cabal-install that gives you that message?
01:59:59 <chylli> dcoutts: no
02:00:21 <chylli> dcoutts: just now I want to upgrade to latest cabal-install but failed
02:00:37 <chylli> because of package dependence
02:00:53 <Botje> hello people
02:01:01 <Botje> which impossible feat are we going to pull today?
02:01:04 <quicksilver> GrayShade: still the answer to your question is that 'compile' has type m1 (m Value)
02:01:12 <quicksilver> GrayShade: so r has type (m Value)
02:01:26 <quicksilver> GrayShade: and then you pass 'r' to runtimeSet...
02:02:26 <GrayShade> quicksilver: d'oh. sure. i'll try to fix it
02:03:09 <opqdonut> is the author of lambdafeed here?
02:04:01 <vixey> mmorrow, hm
02:05:05 <GrayShade> quicksilver: thanks
02:05:15 <mmorrow> vixey: how did it go?
02:05:25 <vixey> I'm really stuck :(
02:05:42 <quicksilver> GrayShade: your types look somewhere been mildly insane and proof positive of head having exploded.
02:05:53 <quicksilver> GrayShade: rein in that polymorphism to something you really need :)
02:05:59 <mmorrow> vixey: uhroh
02:06:03 <quicksilver> GrayShade: and are you sure the nested monads are sensible? ;
02:06:04 <quicksilver> 0
02:06:16 <dcoutts> chylli: so what happens when you $ cabal install cabal-install-0.5.1
02:06:33 <GrayShade> quicksilver: i sure hope so
02:06:37 <dcoutts> chylli: that of course does not run into the problem with yi and the ghc api package
02:06:43 <dcoutts> bos, dons: using cabal configurations in the way we do for the base split thing is a bit of an embarrassment really.
02:06:51 <chylli> dcoutts: has lost that error msg. now reinstalling ghc and packages
02:06:52 <quicksilver> GrayShade: the nested arrays also look suspect.
02:07:07 <quicksilver> GrayShade: and so does the mixture of arrays and maps :)
02:07:10 <quicksilver> why not just use maps?
02:07:18 <dcoutts> bos, dons: it was really designed for features, like: if flag(gui) { build-depends: gtk }
02:07:28 <dcoutts> chylli: I really don't think that's necessary
02:08:04 <mmorrow> vixey: which one in particular are you trying to prove?
02:08:08 <dcoutts> bos, dons: but because of the relational semantics, how it does a search for the flag assignment that works, it can be used for the purpose to which we often put it.
02:08:26 <chylli> dcoutts: but now I has done :p. so please give me some advice when there are still errors
02:08:35 <GrayShade> quicksilver: i'm trying to compile an AST to use an array of arrays of values instead of a map from the symbol name to the values
02:08:50 <vixey> mmorrow: I think it's essential to have group :: [a] -> [[a]] also  suggest that each group has elements which are equial
02:08:55 <dcoutts> bos, dons: we have a proposal for some syntactic sugar for that case: if package(base >= 3) { build-depends: directory, pretty, ... etc }
02:09:14 <dcoutts> chylli: ok
02:09:35 <vixey> I can't prove uncurry replicate . (head &&& length) = id
02:09:40 <GrayShade> quicksilver: so i use a map when compiling to assign positions in those arrays to the symbols and the arrays for evaluating
02:09:42 <vixey> specifically since it's not
02:09:56 <vixey> but if you knew that all elements of the list are equal, then it is
02:10:04 <quicksilver> GrayShade: well, I'm sure it's an interesting excercise. I doubt it's actuall much faster :)
02:10:09 <quicksilver> GrayShade: but compilation is always fun.
02:10:47 <GrayShade> quicksilver: someone told me he got a more that 3x speedup on the dumb fib test
02:11:07 <mmorrow> ahh, i see why the "aaa" "bb" was there...
02:11:10 <vixey> I need to encode that somehow
02:11:22 <GrayShade> quicksilver: i also had problems before with a huge number of allocations when using Data.Map
02:11:24 <quicksilver> GrayShade: I'd be surprised. However, if he did, I imagine his array was much bigger than yours are going to be.
02:11:27 * quicksilver nods
02:12:44 <GrayShade> quicksilver: speed-up when using arrays instead of maps, not instead of lists
02:13:39 <mmorrow> vixey: it seems that you get that property of group :: [a] -> [[a]] by definition
02:13:56 <mmorrow> since group = groupBy (==)
02:14:56 <quicksilver> GrayShade: Yes. I stand by my comment.
02:17:36 <smg> hello
02:18:14 <smg> how would i sort [[("a"), (3)], [("x", (1)]] by the second component? i.e. 3 and 1=
02:18:26 <smg> ?
02:18:28 <mmorrow> :t on
02:18:30 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:18:40 <mmorrow> :t sortBy
02:18:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:19:07 <quicksilver> > sortBy (compare `on` snd) [("a",3),("x",1)]
02:19:08 <mm_freak_work> > sortBy (compare `on` head) [[("a"), (3)], [("x", (1)]]
02:19:09 <lambdabot> Unbalanced parentheses
02:19:10 <lambdabot>  [("x",1),("a",3)]
02:19:28 <mm_freak_work> > sortBy (compare `on` (head . tail)) [[("a"), (3)], [("x", (1)]]
02:19:28 <lambdabot> Unbalanced parentheses
02:19:52 <smg> ty
02:19:53 <vixey> mmorrow: I defined an ad-hoc relation
02:20:08 <Botje> I generally write comparing f a b = f a `compare` f b
02:20:10 <vixey> data Homogenous [a] where
02:20:12 <mm_freak_work> d'oh
02:20:16 * Axman6 senses the assignment is being worked out here...
02:20:18 <vixey>  HNil : Homogenous []
02:20:25 <vixey>  HCon : x -> Homogenous [x]
02:20:30 <smg> quicksilver: `on` ?
02:20:40 <mmorrow> vixey: ad-hoc is nice
02:20:41 <vixey>  HCons : x -> xs -> Homogenous (x:xs) -> Homogenous (x:x:xs)
02:20:53 <Botje> :t equating `on` fst
02:20:54 <vixey> and instead of proving the impossible statement, I proved this
02:20:54 <lambdabot> Not in scope: `equating'
02:20:58 <Botje> doh
02:21:02 <vixey> forall x, Homogenous a x -> stretch (crush x) = x.
02:21:06 <Botje> :t (==) `on` fst
02:21:09 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
02:21:11 <Botje> neat!
02:21:14 <vixey> but I have to make group discharge a 'Homogenous' for me
02:21:20 <smg> what is `on` ?
02:21:24 <smg> btw where is it?
02:21:25 <vixey> :D
02:21:52 <quicksilver> @src on
02:21:52 <lambdabot> (*) `on` f = \x y -> f x * f y
02:22:00 <mmorrow> vixey: (stretch . crush)
02:22:07 <mmorrow> vixey: great name combo
02:22:11 <vixey> :))
02:22:14 <vixey> I am having fun
02:22:14 <mmorrow> :)
02:22:52 <Axman6> @src *
02:22:52 <lambdabot> Source not found. There are some things that I just don't know.
02:23:02 <smg> is there no other way? i don't have that `on` hting...
02:23:06 <Axman6> ok, what is *
02:23:13 <vixey> smg: use the source code
02:23:44 <Axman6> @type *
02:23:45 <lambdabot> parse error on input `*'
02:23:49 <quicksilver> smg: you can just enter the definition from source there
02:23:53 <quicksilver> Axman6: just a variable
02:23:57 <quicksilver> Axman6: like f
02:23:58 <smg> isn't there another good way?
02:24:01 <smg> seems hacky that `on`
02:24:02 <mmorrow> smg: (on) is in Data.Function in 6.8+
02:24:04 <quicksilver> smg: that is the good way.
02:24:08 <mmorrow> smg: lol
02:24:09 <quicksilver> smg: it's not hacky, it's beautiful.
02:24:11 <smg> k
02:24:37 <quicksilver> yes, there is another way (comparing snd) == (compare `on` snd)
02:24:38 <Axman6> how does (*) `on` f = \x y -> f x * f y work then?
02:24:42 <quicksilver> but comparing is deprecated.
02:24:54 <quicksilver> Axman6: it defines "on" as a function which takes two parameters
02:24:58 <quicksilver> Axman6: it names them * and f
02:25:06 <Axman6> ah
02:25:13 <Axman6> and the x and y?
02:25:26 <quicksilver> well they're parameters of that lambda expression
02:25:49 <vixey> group :: [a] -> (lists : [[a]] , all Homogenous lists)
02:25:57 <mmorrow> @pl \(*) f = \x y -> f x * f y
02:25:58 <lambdabot> (line 1, column 3):
02:25:58 <lambdabot> unexpected "*"
02:25:58 <lambdabot> expecting pattern
02:26:08 <mmorrow> @pl \o f = \x y -> f x `o` f y
02:26:08 <lambdabot> (line 1, column 6):
02:26:08 <lambdabot> unexpected "="
02:26:08 <lambdabot> expecting pattern or "->"
02:26:16 <mmorrow> @pl \(*) f -> \x y -> f x * f y
02:26:16 <lambdabot> (line 1, column 3):
02:26:16 <lambdabot> unexpected "*"
02:26:16 <lambdabot> expecting pattern
02:26:33 <dcoutts> gwern: re, the comment on reddit, you do not need to wrap the install commands etc, you just need to use the ~/.cabal/config file
02:26:34 <mmorrow> @pl \o f -> \x y -> o (f x) (f y)
02:26:34 <lambdabot> join . ((flip . ((.) .)) .) . (.)
02:26:54 <Axman6> ...wow
02:27:03 <Axman6> is that supposed to be unreadable?
02:27:20 <mmorrow> that's the awesomest @pl i've ever seen
02:27:26 <quicksilver> @pl makes no claim to preduce readable code :)
02:27:26 <lambdabot> (line 1, column 42):
02:27:26 <lambdabot> unexpected ")"
02:27:26 <lambdabot> expecting white space or simple term
02:28:59 <mmorrow> > let on = join . ((flip . ((.) .)) .) . (.) in sortBy (compare `on` snd) [("a",2),("b",1)]
02:29:00 <lambdabot>  [("b",1),("a",2)]
02:29:47 <mmorrow> :t flip . ((.) .)
02:29:49 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a -> a1 -> b) -> f a1 -> a -> f b
02:30:21 <mmorrow> :t let g.f=\x->g(f(x)) in flip . ((.) .)
02:30:22 <lambdabot> parse error on input `->'
02:30:39 <mmorrow> :t let (.) g f=\x->g(f(x)) in flip . ((.) .)
02:30:40 <lambdabot> parse error on input `->'
02:31:52 <mmorrow> :t flip . ((.) .) :: (Functor f) => (a -> b -> c) -> f b -> a -> f c
02:31:54 <lambdabot> forall a b c (f :: * -> *). (Functor f) => (a -> b -> c) -> f b -> a -> f c
02:32:32 <mmorrow> :t ((.) .)
02:32:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
02:32:41 <mmorrow> :t (. (.))
02:32:43 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => ((f a -> f b1) -> b) -> (a -> b1) -> b
02:33:01 <mmorrow> :t ((.).(.))
02:33:03 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
02:34:10 <mmorrow> :t flip ((.) .)
02:34:11 <lambdabot> forall a b (f :: * -> *) b1. (Functor f) => b1 -> (b1 -> a -> b) -> f a -> f b
02:35:29 <mmorrow> :t (. id)
02:35:31 <lambdabot> forall b a. (a -> b) -> a -> b
02:35:39 <dibblego> why aren't there lots of functions written over Traversable or am I not looking in the right place?
02:35:39 <mmorrow> :t (id .)
02:35:41 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
02:35:48 <rwbarton> :t (Prelude..)
02:35:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:36:08 <mmorrow> :t (id `fmap`)
02:36:10 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
02:39:12 <Axman6> @type groupBy
02:39:14 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
02:39:24 <rwbarton> :t lift
02:39:26 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
02:39:29 <Axman6> @src groupBy
02:39:29 <lambdabot> groupBy _  []       =  []
02:39:29 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
02:39:29 <lambdabot>     where (ys,zs) = span (eq x) xs
02:41:00 <hansfbaier> wrdlbrmfd
02:41:32 <quicksilver> dibblego: it's relatively new and relatively underused
02:41:42 <dibblego> quicksilver, fair enough, thanks
02:41:45 <quicksilver> dibblego: I mainly end up using Traversable and Foldable when I use Sequence
02:41:58 <quicksilver> dibblego: (because Sequence deliberately doesn't define the generic stuff you can get from T + F )
02:42:04 <dibblego> Sequence?
02:42:08 <quicksilver> Data.Sequence
02:42:15 <dibblego> oh right
02:43:44 <vixey> no I didn't get far with my AdHoc thingaeo
02:46:43 <Axman6> hmm, how would i get ghci to understand groupBy? i can't seem to get it to use let for more than one definition of it
02:46:52 <dibblego> :m + Data.List
02:46:56 <mmorrow> :t \o -> \x y -> o ((o x) (o y))
02:46:58 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
02:46:58 <lambdabot>     Probable cause: `o' is applied to too few arguments
02:46:58 <lambdabot>     In the first argument of `(o x)', namely `(o y)'
02:47:48 <Axman6> i've been using:
02:47:52 <Axman6> let groupBy _  []       =  []
02:47:52 <Axman6> :{
02:47:52 <Axman6> let groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs where (ys,zs) = span (eq x) xs
02:47:54 <mmorrow> :t \o f -> \x y -> f(o (f x) (f y)))
02:47:55 <Axman6> :}
02:47:56 <lambdabot> parse error on input `)'
02:47:59 <mmorrow> :t \o f -> \x y -> f(o (f x) (f y))
02:48:01 <lambdabot> forall t t1. (t -> t -> t1) -> (t1 -> t) -> t1 -> t1 -> t
02:48:13 <mmorrow> @pl \o f -> \x y -> f(o (f x) (f y))
02:48:14 <lambdabot> liftM2 (.) (.) . join . ((flip . ((.) .)) .) . (.)
02:48:24 <dibblego> Axman6, groupBy is a library function; just load the Data.List module
02:48:25 <maltem> Axman6: Load the module that contains it, or load the file that contains the definition, or use "let" in ghci (but then, put everything on one single line)
02:48:25 <smg> > 2*3
02:48:27 <lambdabot>  6
02:48:34 <Axman6> ah, thanks
02:48:43 <dibblego> :m + Data.List
02:49:02 <mmorrow> @pl (\o f -> \x y -> o (f x) (f y))
02:49:02 <lambdabot> join . ((flip . ((.) .)) .) . (.)
02:49:15 <mmorrow> @pl liftM2 (.) (.) . (\o f -> \x y -> o (f x) (f y))
02:49:16 <lambdabot> liftM2 (.) (.) . join . ((flip . ((.) .)) .) . (.)
02:49:29 <Axman6> sorry dibblego, didn't realise that was for me the first time
02:51:38 <Axman6> @src span
02:51:38 <lambdabot> Source not found.
02:52:47 <MatthiasB_> Axman6: span p xs is equivalent to (takeWhile p xs, dropWhile p xs)
02:53:06 <Axman6> ah, ok
02:54:28 <hansfbaier> @src findMe
02:54:28 <lambdabot> Source not found. I am sorry.
02:54:44 <ski_> @scheck \p xs -> span p xs == (takeWhile p xs :: [Int], dropWhile p xs)
02:54:55 <lambdabot> Done.
02:55:01 <hansfbaier> lambdabot: thank you anyway.
02:55:09 <hansfbaier> :)
02:56:03 <ski_> @botsnack
02:56:03 <lambdabot> :)
03:00:53 <PHO_> @karma lambdabot
03:00:53 <lambdabot> lambdabot has a karma of 3
03:01:10 <PHO_> isn't that too few?
03:01:12 <PHO_> lambdabot++
03:01:26 <PHO_> @karma lambdabot
03:01:26 <lambdabot> lambdabot has a karma of 4
03:01:42 <mmorrow> lambdabot++--++
03:01:48 <mmorrow> @karma lambdabot
03:01:48 <lambdabot> lambdabot has a karma of 4
03:01:52 <mmorrow> lambdabot++
03:01:54 <mmorrow> @karma lambdabot
03:01:54 <lambdabot> lambdabot has a karma of 5
03:02:12 <hansfbaier> @version
03:02:12 <lambdabot> lambdabot 4p664, GHC 6.8.2 (Linux i686 2.40GHz)
03:02:12 <lambdabot> darcs get http://code.haskell.org/lambdabot
03:02:15 <RayNbow> lambdabot++
03:03:23 <chylli> I has installed Yi, but how to start it ? no Yi command ?
03:04:02 <Saizan_> chylli: with lowercase y?
03:04:25 <PHO_> chylli: I think you have to install either yi-gtk or yi-vty
03:04:41 <chylli> Saizan_: still no such command
03:04:50 <chylli> PHO_: how to ? where can I find it ?
03:04:59 <PHO_> they're in the hackage
03:05:04 <Saizan_> PHO_: no, it's in one single package now
03:05:10 <PHO_> oops
03:05:35 <Saizan_> chylli: look in ~/.cabal/bin
03:05:35 <chylli> Saizan_: then what should I do ?
03:06:06 <chylli> Saizan_: no such direcotry.
03:06:45 <Saizan_> chylli: which command have you used to install it?
03:07:12 <chylli> Saizan_: cabal configure , cabal build, cabal install --only
03:07:51 <chylli> dcoutts teached me
03:08:32 <Saizan_> chylli: cabal install should have printed something like Installing: /usr/local/bin
03:08:57 <Saizan_> chylli: the executable should be in that directory
03:10:04 <hansfbaier> @src map
03:10:04 <lambdabot> map _ []     = []
03:10:04 <lambdabot> map f (x:xs) = f x : map f xs
03:10:19 <tarantella> sera
03:10:22 <tarantella> !list
03:10:24 <hansfbaier> @src mapM
03:10:24 <lambdabot> mapM f as = sequence (map f as)
03:11:37 <hansfbaier> @src sequence
03:11:37 <lambdabot> sequence []     = return []
03:11:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:11:37 <lambdabot> --OR
03:11:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:12:02 <Gilly> is there a recommended linear algebra package for haskell?
03:12:59 <Gilly> well i guess i'll go for hmatrix
03:14:24 <chylli> Saizan: it just print :
03:14:25 <chylli> root@arch:/home/chylli/study/yi# cabal install --only
03:14:25 <chylli> Installing: /usr/local/lib/yi-0.4/ghc-6.8.2
03:14:25 <chylli> Registering yi-0.4...
03:14:28 <chylli> Reading package info from "dist/installed-pkg-config" ... done.
03:14:30 <chylli> Saving old package config file... done.
03:14:33 <chylli> Writing new package config file... done.
03:14:36 <chylli>  
03:14:46 <chylli> no info about path
03:14:57 <hansfbaier> dds hjuopo;l                 ll';llkkk
03:15:04 <chylli> Saizan: what's the program name ? yi ?
03:15:12 <hansfbaier> sorry, my daughter....
03:15:59 <sjanssen> chylli: look for /usr/local/bin/yi
03:16:27 <chylli> sjanssen: no such file :(
03:16:31 <sjanssen> chylli: actually, what did you use to configure?
03:16:42 <chylli> sjanssen: cabal configure
03:16:43 <chylli> just that
03:16:54 <Saizan> chylli: that looks like it's only installing the library and not the executable
03:17:16 <maltem> chylli: Btw, what does --only do?
03:17:29 <sjanssen> chylli: as root?
03:17:50 <Saizan> chylli: do you have one of gtk or vty installed?
03:18:29 <Saizan> maltem: undocumented feature :)
03:18:48 <chylli> sjanssen: root
03:18:52 <sjanssen> chylli: in that case, look for ~root/.cabal/bin/yi
03:19:01 <chylli> maltem: --only let cabal only install, dont compile
03:19:21 <chylli> Saizan: i think vty has been installed because of dependence.
03:19:32 <maltem> I didn't know that was possible :)
03:19:34 <chylli> sjanssen: no /root/.cabal/bin dir
03:19:54 <Saizan> chylli: does "ghc-pkg list vty" agree?
03:20:18 <chylli> Saizan: get empty result
03:20:40 <chylli> Saizan: then should I isntall vty and recompile yi ?
03:20:49 <chylli> Saizan: or gtk ?
03:21:07 <Saizan> chylli: one of the two, it depends if you want the terminal or graphic frontend
03:21:29 <chylli> Saizan: need recompile yi ?
03:22:31 <Saizan> chylli: yeah, you've to restart from configure for yi once you've installed one of those packages
03:22:47 <chylli> Saizan: what's the gtk name ? cabal install gtk failed
03:23:41 <Saizan> chylli: http://downloads.sourceforge.net/gtk2hs/gtk2hs-0.9.12.1.tar.gz <- it's not a cabalized package
03:23:43 <dcoutts> gtk2hs is not yet on hackage, has to be installed separately
03:24:00 <chylli> ok, thanks
03:24:13 <Saizan> dcoutts: maybe cabal should print something when an executable is not buildable?
03:24:38 <dcoutts> Saizan: it's not clear what buildable: False means
03:24:49 <dcoutts> Saizan: originally it meant, don't install this bit
03:24:53 <dcoutts> rather than fail
03:25:10 <dcoutts> yi is using it in the latter meaning
03:25:30 <Saizan> it still installs the library
03:25:39 <dcoutts> that's because it is buildable I suppose
03:26:05 <dcoutts> it was to allow people to disable components, like test progs etc
03:26:09 <chylli> dcoutts: a qustion about .cabal/config user-install: False
03:26:24 <chylli> I know there are two value: False and Just True
03:26:36 <Saizan> however with the presence of configurations one can direct if something becomes buildable or not, so it might be nice to be informed up front
03:26:42 <dcoutts> chylli: Just True? really, shouldn't be any Just
03:26:46 <chylli> why not Just False and Just True ? or Nothing and Just true?
03:27:01 <dcoutts> chylli: there was a bug in that area a while ago but I don't think it expects Just anymore
03:27:13 <dcoutts> should be True or False
03:27:16 <chylli> dcoutts: ok. thanks
03:28:09 <Saizan> dcoutts: i mean something like gtk2hs configure that reports which components will be installed
03:28:46 <dcoutts> Saizan: but the intention of buildable: False was not for optional components
03:29:44 * Baughn has been reduced to finding memory leaks by divide and conquer. :'(
03:34:10 <chylli> any super man can make a pkgbuild for ghc 6.8.3? :p
03:36:03 <sjanssen> I imagine s/6.8.2/6.8.3/g on the old one is about 50% of the work :)
03:45:55 <chylli> Saizan: compile gtk2hs failed
03:46:43 <matthew-_> has haskell.org collapsed under the strain?
03:47:11 <dcoutts> chylli: how so?
03:49:43 <chylli> dcoutts: c2hsLocal: Error in C header file.
03:49:43 <chylli>  
03:49:43 <chylli> <built-in>:1: (column 0) [FATAL]
03:49:43 <chylli>  
03:49:52 <chylli>   >>> Lexical error!
03:49:53 <chylli>   The character '#' does not fit here.
03:49:53 <chylli>  
03:50:02 <lilachaze> > fix (putStrLn "Hello World">>)
03:50:02 <chylli> let me paste the error message
03:50:04 <lambdabot>  Add a type signature
03:50:09 <dcoutts> hmm
03:50:24 <dcoutts> chylli: try using the posix/C locale
03:50:39 <chylli> ok
03:50:51 <dcoutts> chylli: that's my guess, if you're using a locale like es or something
03:51:15 <swiert> @seen mattam
03:51:15 <lambdabot> mattam is in ##logic and #haskell. I last heard mattam speak 22h 18m 2s ago.
03:51:31 <chylli> dcoutts: using zh_CN.UTF8
03:53:08 <mauke> what does cabal-install actually do?
03:53:27 <dcoutts> mauke: it's the command line interface to Cabal/hackage
03:53:39 <dcoutts> so it does all that runghc Setup.hs does
03:53:45 <mauke> I see it's supposed to fetch and install packages, but where does it put them?
03:53:50 <mauke> and which configure options does it use?
03:53:51 <Baughn> ~/.ghc, usually
03:53:51 <Cheiron2> Unknown command, try @list
03:54:11 <Baughn> ..I'm going to have to find something even less likely, I see.
03:54:17 <dcoutts> mauke: the default is user installs in ~/.cabal, but it's configurable and it takes all the ordinary --prefix etc flags
03:54:44 <mauke> installs or sources?
03:54:54 <dcoutts> mauke: the install command takes all the configure options too, and you can set defaults in ~/.cabal/config
03:55:17 <dcoutts> mauke: downloads sources, configures, builds and installs.
03:55:36 <mauke> do sources go in ~/.cabal?
03:55:43 <dcoutts> mauke: yes
03:55:45 <mauke> where is ~/.cabal/config documented?
03:56:10 <dcoutts> mauke: nowhere (except the source), eventually it'll be documented in ~/.cabal/config
03:56:28 <mauke> :-/
03:57:21 <dcoutts> mauke: it's a question of priorities and whether it is worth delaying the release for extra features or not
03:57:48 <mauke> what features? I just want to know what this thing actually does
03:57:54 <ndm> does GHC 6.8.3 come with cabal-install?
03:58:02 <mauke> and if I can trust it enough to blindly use it
03:58:14 <dcoutts> ndm: of course not :-)
03:58:26 <ndm> :(
03:58:29 <dcoutts> ndm: it's only bug fixes on 6.8.2
03:58:31 * ndm decides not to upgrade
03:58:48 <ndm> (at least on this machine, and for the moment)
03:58:49 <dcoutts> cabal-install has two extra deps that are not core packages, so we cannot do it anyway
03:59:00 <mauke> let me guess, HTTP and zlib
03:59:11 <dcoutts> yes
03:59:12 <ndm> dcoutts, even as a lovely little binary in the windows installer?
03:59:28 <mauke> I just installed them :-)
03:59:41 <dcoutts> ndm: I might make a cabal.exe
04:00:06 <dcoutts> ndm: though it cannot upgrade itself yet on windows which is a bit of a problem.
04:00:13 <ndm> dcoutts, any reason not to bundle it with the GHC installer?
04:00:33 <dcoutts> ndm: false hope?
04:00:41 <ndm> ???
04:00:47 <dcoutts> ndm: I dunno, I don't do anything with the ghc windows installer
04:00:59 <dcoutts> ndm: it'd be safer if it were upgradable
04:01:32 <ndm> true, perhaps wait for 6.10, but still a disappointment
04:02:30 <dcoutts> ndm: it'd have to have been included into the ghc build process weeks ago
04:02:36 <dcoutts> and it was only released the other day
04:03:25 <ndm> dcoutts, i've emailed the simons for 6.10 priorities
04:03:58 <chylli> dcoutts: yeah, succeed , thanks. but why ?
04:04:22 <chylli> dcoutts: I didnt encounter things like this before.
04:04:27 <dcoutts> chylli: problem with the c2hs C parser I guess
04:06:25 <chylli> need I report this as a bug ?
04:07:21 <MyCatVerbs> chylli: very definately yes.
04:08:02 <chylli> MyCatVerbs: but where should I report to ? :(
04:09:15 <MyCatVerbs> chylli: http://hackage.haskell.org/trac/ghc/newticket?type=bug
04:09:45 <MyCatVerbs> chylli: since it's a problem with GHC rather than with what you were compiling (I think).
04:10:04 <chylli> thanks
04:11:18 <MyCatVerbs> No worries.
04:12:54 <chylli> MyCatVerbs: I has no permission to create a new bug
04:13:26 <chylli> dcoutts: seems yi donese't accept chinese character inputed by xim
04:14:52 <mauke> you can create bugs as "guest"
04:14:57 <mauke> I think you have to enable cookies, though
04:15:50 <dcoutts> chylli: report that to the yi devs.
04:17:26 <chylli> mauke: I'm sure enabled cookies, but still cant create but.
04:17:27 <chylli> bug
04:25:30 <matthew-_> checking for path to top of build tree... pwd: timer_create: Invalid argument
04:25:58 <matthew-_> and then blow up. this is for ./configure on 6.8.3 with the x86_64 binary package
04:26:00 <matthew-_> any ideas?
04:30:27 <dblhelix> is haskell.org down or just slow?
04:30:32 <matthew-_> just slow
04:31:46 <dblhelix> matthew-_:  tnx
04:34:57 <Baughn> Cale: Obviously I'm going to have to run a longer-duration test, but I /think/ I've found the memory leak. It's in Seen.hs. Somewhere.
04:35:19 <Baughn> Given the general messiness of that module, it needed rewriting anyway
04:35:48 <quicksilver> Baughn: is there a magic URL somewhere on code.h.o so I can look at Seen.hs without downloading a whole source tree?
04:36:02 <Baughn> Well, it's a darc repo, so yes. Let's see..
04:36:15 <hpaste>  azib pasted "xmonad.hs" at http://hpaste.org/8396
04:36:51 <Baughn> quicksilver: http://code.haskell.org/lambdabot/Plugin/
04:36:51 <lambdabot> Title: Index of /lambdabot/Plugin
04:37:27 <Baughn> ..I'm not convinced that's the /only/ memory leak, though
04:40:27 * Baughn wonders if anyone is working on making profiling work with -threaded
04:41:47 <quicksilver> Baughn: funny you should say that.
04:41:55 <quicksilver> Baughn: take a look at the release notes for 6.8.3 ;)
04:42:03 * quicksilver curses the cargo-culted return $!
04:42:14 <Baughn> Having fun with Seen?
04:42:38 <quicksilver> yup
04:42:45 <mauke> how do I set build options for ghc when compiling from source?
04:42:49 <quicksilver> Baughn: the first thing I'd change is this:
04:42:52 <Baughn> 6.8.3 is out? Whee!
04:42:59 <quicksilver> type SeenState = (MaxMap, SeenMap)
04:42:59 <matthew-_> mauke look at mk/build.mk
04:43:02 <Baughn> ...why is june 17 such a release day?
04:43:14 <quicksilver> Baughn: try data SeenState = SeenState !MaxMap !SeenMap
04:43:16 <Baughn> quicksilver: Don't tell me, just fix it. ;)
04:43:26 <Baughn> quicksilver: I'm not intending to fix Seen. Diagnosis is quite enough.
04:43:39 * quicksilver shrugs
04:43:50 <mauke> matthew-_: doesn't exist
04:44:01 <quicksilver> you're the one with the working test setup and the empirical environment which proved the problem
04:44:08 <quicksilver> it would be simplest for you to check if that fixes it :)
04:44:16 <quicksilver> but if you don't have time/inclination that's fair enough.
04:44:21 <matthew-_> mauke: copy the .sample
04:44:26 <Baughn> Also, it's still leaking. Yay for lazy evaluation.. time for more testing
04:44:36 <Baughn> quicksilver: I might, later. I still haven'T found all the leaks.
04:44:39 <sjanssen> Baughn: I'm willing to wager that the leaks are in the elements of the maps
04:44:43 <mauke> matthew-_: the sample doesn't tell me what the options do
04:45:13 <sjanssen> Baughn: try rnf'ing the map on each modification
04:45:47 <mauke> e.g. what effect does 'GhcLibHcOpts =' have?
04:46:17 <Baughn> sjanssen: Seen.hs is /broken/. It doesn't seem to work across reboots, and breaks extremely easily if anything crashes.
04:46:27 <Baughn> sjanssen: If I do fix it, it'll be by way of rewriting
04:47:41 <Baughn> quicksilver: Incidentally, will the RTS auto-tune the number of GC generations when RSS increases? Or do two generations work just as well with 5GB as with 3MB?
04:48:09 <quicksilver> there is no auto-tuning
04:48:23 <quicksilver> I believe it wasn't clear the best way to do it automatically
04:48:32 <quicksilver> easy enoguh to tune manually though.
04:49:12 <Baughn> Any guides to same?
04:53:05 * Baughn notes that building lambdabot without the OfflineRC module is still pointless
04:55:20 <quicksilver> Baughn: -g3 is it? it's in the GHC manual.
04:55:39 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc
04:55:39 <lambdabot> Title: 5.14. Running a compiled program, http://tinyurl.com/d7dj4
04:55:52 <Baughn> quicksilver: Ah, no. I meant /when/ increasing the number of generations would be useful
04:55:56 <Baughn> Well, I suppose experimentation works
04:56:06 <quicksilver> oh, I see :)
04:56:11 <quicksilver> yes, experimentation works.
04:56:29 <quicksilver> -G2 seems to be a pretty good sweet spot
04:56:42 <quicksilver> I imagine very long running programs might benefit from G3 though?
04:59:02 <povman> is anyone here making a mac/ppc build of ghc 6.8.3?
05:00:27 <Baughn> &url-off
05:00:32 <Cheiron2> Url disabled
05:00:48 <mauke> Cheiron2: @seen me
05:01:16 <Baughn> mauke: @ won't work, and seen won't work
05:26:44 <Baughn> &print-logs
05:26:44 <Cheiron2> Unknown command, try @list
05:27:10 <mauke> &e
05:27:10 <Cheiron2> Maybe you meant: easton echo elements elite eval . ? @ v
05:27:19 <Baughn> ^ 2+2
05:27:21 <Cheiron2>  4
05:30:56 <Baughn> @hoogle modifyMS
05:30:57 <lambdabot> No matches found
05:32:26 <mauke> Setup: Haddock's internal GHC version must match the configured GHC version
05:32:26 <mauke> make[1]: *** [doc.library.base] Error 1
05:32:26 <mauke> make[1]: Leaving directory `/home/mauke/src/ghc-6.8.3/libraries'
05:32:34 <mauke> how did I break the 6.8.3 build?
05:34:28 <Baughn> "modifyMS (M.adjust (\(CS hdl ds his) -> CS hdl ds (his ++ [e])) c)" <-- I found this line in Log.hs, appending events every time someone talks. Now, I could be wrong, but I don't see anything similarily /removing/ events
05:35:37 <dcoutts> mauke: to be honest, I'd suggest using haddock-0.9 rather than 2.x
05:38:29 <mauke> dcoutts: how do I tell configure to use a different haddock?
05:38:41 <dcoutts> --with-haddock=
05:38:52 <mauke> doesn't work
05:39:17 <dcoutts> mauke: in what way does it not work?
05:39:48 <mauke> checking for haddock
05:39:49 <mauke> found /home/mauke/usr/local/bin/haddock
05:39:55 <mauke> completely ignoring the command line arg
05:40:01 <dcoutts> hmm
05:41:04 * dcoutts tries
05:41:05 <Baughn> @hoogle trace
05:41:05 <lambdabot> Debug.Trace.trace :: String -> a -> a
05:41:05 <lambdabot> Debug.Trace :: module
05:41:05 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
05:41:20 <dcoutts> mauke: what versions of Cabal lib and cabal-install?
05:41:47 <dcoutts> mauke: wait, you mean building ghc?
05:42:19 <dcoutts> --with-haddock is a cabal command, I've no idea about how to get ghc to use a different prog except playing with the $PATH
05:51:19 <Baughn> ..yep, that seems to be it. There's nothing stopping the logger from keeping an arbitrary amount of log data in core.
05:51:33 * Baughn fixes that. Now, then..
05:56:21 <Baughn> 1
05:56:22 <Baughn> 2
05:56:22 <Baughn> 3
05:56:23 <Baughn> 4
05:56:40 <matthew-_> 5
05:56:53 <Baughn> &last #haskell
05:56:53 <Cheiron2> No module "#haskell" loaded
05:57:10 <Vq^> 10
05:57:29 <Baughn> &last
05:57:30 <Cheiron2> http://code.haskell.org/lambdabot/COMMANDS
05:57:59 <Baughn> ..why does it even bother to keep an internal log, if it's not going to show it to me?
05:58:45 <Baughn> Well, never mind. Fixed is fixed.
06:05:59 <mauke> dcoutts: ah, you have to set HaddockCmd in the environment
06:23:01 <mauke> dcoutts: using haddock-0.8 didn't make a difference
06:23:10 <mm_freak_work> > fix (^0)
06:23:16 <lambdabot>  1
06:23:40 <dcoutts_> mauke: you mean it failed in the same way?
06:23:50 <mauke> yes
06:23:51 <dcoutts_> mauke: if so it's because it's still using haddock-2.x
06:24:02 <dcoutts_> mauke: 0.9 does not have that failure mode
06:24:13 <mauke> ah, I see it just calls cd base && setup/Setup haddock --html-location='../$pkg'
06:24:21 <mauke> er, wait
06:24:26 <dcoutts_> mauke: it'll probably be because the ghc build system does not pass the location of haddock on to cabal
06:24:39 <dcoutts_> so cabal just picks it up from the path again
06:24:53 <mauke> argh
06:25:19 <dcoutts_> mauke: change the configure step to pass the haddock location found by ./configure
06:25:35 <mauke> how?
06:26:25 <dcoutts_> mauke: I'm not overly familiar with the ghc build system either
06:26:37 <dcoutts_> mauke: my point is that at some point it configures each lib
06:26:52 <dcoutts_> then later does setup/Setup haddock
06:27:16 <dcoutts_> so at the configure phase it should pass --with-haddock=$(HaddockCmd)
06:27:20 <JaffaCake> possibly we should pass the value of $(HADDOCK) to Cabal
06:27:28 <dcoutts_> JaffaCake: right
06:27:44 <mauke> yes, or make it work with newer haddocks
06:28:02 <dcoutts_> mauke: it'll work with a newer haddock if that haddock is also built with ghc-6.8.3
06:28:03 <JaffaCake> mauke: we're working on that
06:28:16 <dcoutts_> but that doesn't help you much if you're upgrading from 6.8.2
06:28:47 <dcoutts_> JaffaCake: though I'm not sure what --with-haddock=$(HaddockCmd) would do if HaddockCmd is empty
06:29:02 <JaffaCake> ah yes
06:29:18 <Baughn> > 3223552 / 4095
06:29:19 <Baughn> > 3223552 / 4096
06:29:20 <lambdabot>  787.1921855921856
06:29:21 <lambdabot>  787.0
06:29:39 <dcoutts_> JaffaCake: needs $(add-prefix --with-haddock=, $(HaddockCmd)) or something like that
06:30:10 <mauke> I don't see where it configures cabal
06:30:39 <JaffaCake> mauke: libraries/Makefile
06:31:50 <mauke> wow, lots of spelling errors
06:34:07 <chylli> Yi open Chinese utf8 file failed, any advice ?
06:34:17 <dcoutts_> chylli: ask the yi devs
06:35:16 <mauke> I so need a ghc build cache
06:37:36 <ivanm> dcoutts_: that should be added to the /topic or something... I seem to recall you using that response rather regularly lately :p
06:38:10 <dcoutts_> ivanm: mostly to the same person each time however :-)
06:38:16 <ivanm> ahhhh
06:38:42 <ivanm> maybe you should just set it up as an autocorrect or something in your IRC client to make it easier for you :p
06:40:11 * quicksilver is pleased the -cafe backed him up for defending the PHP guy.
06:41:27 <chylli> dcoutts_: ok , asked in googlegropus
06:44:55 <dcoutts_> chylli: great. I sent them some patches too.
06:45:18 <chylli> dcoutts_: has read that.
06:45:34 <ivanm> dcoutts_: btw, congrats on getting a release of cabal-install out
06:45:42 <DRMacIver> quicksilver: Well, you were clearly in the right. I mean I happen to agree with the "PHP? Eww, no!" sentiment, but I wouldn't say it on the list. :)
06:45:49 <dcoutts_> ivanm: thanks :-)
06:45:54 <ivanm> though I must ask, if cabal-1.4 is nothing new, why have a new major version number for it?
06:46:04 <DRMacIver> (Um, and the latest message in that thread is off the deep end)
06:48:38 * quicksilver shrugs
06:48:51 <quicksilver> the correspondant in question often posts messages which appear to be unstable.
06:49:06 <quicksilver> I just wanted to make sure it wasn't misunderstood that his opinion represented teh body of the list
06:49:15 <quicksilver> I got slapped down in my first week or two on the -cafe
06:49:27 <quicksilver> and as a result I came to appreciate what a remarkably friendly forum it is.
06:50:01 <ivanm> quicksilver: _you_ got slapped down? what for?
06:50:52 <quicksilver> I don't recall. Being needlessly abrasive.
06:50:56 <ivanm> hhh
06:58:40 <matthew-_> so, I have a really simple program. 2 threads, one Chan between them. One thread is a producer, the other a consumer.
06:58:55 <matthew-_> compiling with -threaded and then -N1 is really fast
06:59:01 <matthew-_> -N2 is well over 10 times slower
06:59:22 <matthew-_> in fact, the slowness seems related to the number of values sent from the producer
06:59:22 <Baughn> matthew-_: What's the memory use like?
06:59:30 <matthew-_> stable, I think
06:59:37 <matthew-_> but only one cpu core is ever in use
06:59:39 <mm_freak_work> matthew-_: that's because switching between lightweight threads is much cheaper
06:59:52 <matthew-_> but there should be work for them both to do
07:00:07 <Baughn> How much work does the thread do per element?
07:00:13 <matthew-_> one comparison
07:00:13 <Baughn> If it's spending most of its time waiting for the Chan..
07:00:37 <Baughn> Then synchronization costs are hundreds or thousands times more expensive than the comparison
07:00:50 <Saizan> matthew-_: do you reduce the values to normal form before sending them on the Chan?
07:01:01 <matthew-_> the values sent are simply Ints
07:01:31 <matthew-_> the synchronization shouldn't have to go out to main RAM as these are dual core opterons, so it should just sit in the L2 cache
07:01:37 <Baughn> matthew-_: Your program amounts to a benchmark of Chan. And yes, Chan is faster without OS threads.
07:01:54 <Baughn> Even on a dual-core machine, it still has to lock the bus (I.. think)
07:02:14 <mauke> matthew-_: but are they thunks or real Ints?
07:02:26 <Baughn> (Just in case some /other/ device in the system cares about the value, they have to be written out to main memory immediately too)
07:02:31 <matthew-_> mauke: I'm not making any effort to stop them being thunks
07:02:40 <quicksilver> matthew-_: just because they're simply Ints doesn't make them in normal form...
07:02:45 <quicksilver> right, what mauke said.
07:03:06 <Baughn> matthew-_: You could throw in an evaluate call before putting them in the Chan. How much work does the /producer/ do per int?
07:03:12 <matthew-_> Baughn: wouldn't that only be the case if the memory was declared as being shared?
07:03:23 <quicksilver> you often want to force things before posting them in chans
07:03:24 <matthew-_> the producer similarly does one comparision
07:04:16 <matthew-_> so what - a strictness annotation (bang pattern) or a seq ?
07:04:40 <Baughn> matthew-_: Checking
07:04:56 <mauke> put chan $! val
07:05:56 <mm_freak_work> hmmâ€¦  is (Chan !Int) a valid type?
07:06:05 <quicksilver> no
07:06:24 <quicksilver> you can't put strictness annotations onto parameters of parametric types
07:06:31 <quicksilver> only onto actual field declarations
07:07:03 <mm_freak_work> and there is no StrictChan ?
07:07:09 <Baughn> matthew-_: It Depends (tm) - on how GHC implements synchronization
07:07:35 <quicksilver> mm_freak_work: http://hackage.haskell.org/packages/archive/strict-concurrency/0.2/doc/html/Control-Concurrent-Chan-Strict.html
07:07:36 <lambdabot> http://tinyurl.com/6npred
07:07:43 <mauke> Igloo++  # fixing my bugs
07:08:00 <Baughn> matthew-_: Modern CPUs do have instructions that allows CPU-local synchronization, but if you don't specify that - if you use plain old 486 lock instructions - you get to lock the entire memory bus and immediately write back to main memory
07:08:24 * Igloo wonders what bug he fixed
07:08:24 <matthew-_> Baughn: right.
07:09:08 <mauke> Igloo: ghc bugs 230[2-4] are mine; you fixed 3 and 4
07:09:20 <mm_freak_work> when should i care about WHNF with Chan?  I've used lazy Chans quite often and never had problems with them
07:09:50 <quicksilver> yes, they're fine in many cases
07:10:00 <quicksilver> but if the intention of your concurrency was to do some work in worker threads
07:10:09 <Baughn> mm_freak_work: When you want to make sure both threads actually do work, and the consumer doesn't just end up dethunking thunks the producer made
07:10:16 <Igloo> mauke: Ah, right  :-)
07:10:18 <Zao> mm_freak_work: If you're too lazy, any computations you intended to run in a worker thread may not be done until the result is required, and will then be evaluated in the consumer's thread.
07:10:22 <quicksilver> then failing to force the thunk before sending it back can mean the work gets unexpectedly done in the consumer instead.
07:10:32 <quicksilver> stereo!
07:10:41 <Baughn> Trio
07:11:11 <Baughn> matthew-_: And if you wait a bit, I'll check exactly how ghc /does/ do it
07:11:47 <matthew-_> Baughn: I'm sitting comfortably ;)
07:11:56 <mm_freak_work> so i only need to care, if i use threading to distribute work?
07:12:18 <matthew-_> which seems a fairly likely use of the contents of Control.Concurrency
07:12:57 <Baughn> mm_freak_work: Yep. If it's as a control structure (to wait on multiple handles, say) there's no issue.
07:13:31 <mm_freak_work> ok, thanks
07:14:17 <matthew-_> yikes, bang patterns made quite a difference
07:14:47 <Baughn> How much?
07:15:48 <quicksilver> program now runs so much faster that matthew-_ has been teleported back in time
07:16:21 <Baughn> Oh, that's not good. He might step on a butterfly and cause GHC never to be developed
07:17:08 <matthew-_> ok, let me paste some code
07:17:50 <Baughn> matthew-_: Remember, if you're doing /that/ little computation per element (one comparison, you said) then you're really just benchmarking the Chan
07:18:39 <hpaste>  matthew-_ pasted "speed testing chans vs session types" at http://hpaste.org/8397
07:19:09 <matthew-_> Baughn: yeah, which is weird as Chans are just made up of MVars and my session types just use chains of MVars
07:19:30 <quicksilver> Chans are a slightly inefficient structure
07:19:32 <matthew-_> but nevertheless, they thoroughly out perform the Chans and get > 100% CPU use
07:19:34 <quicksilver> lots of MVars
07:19:44 <quicksilver> the upside here is the dupChan facility
07:19:56 <quicksilver> if you weren't trying to support dupChan there is a simpler structure I believe.
07:20:00 <matthew-_> yep
07:20:01 <Baughn> quicksilver: Mm. I'm just trying to make the point that, in real life, you'll almost never care about the speed of the synchronization primitive.
07:20:04 <Baughn> Er, matthew-_
07:20:13 <quicksilver> I think it's a fair point Baughn.
07:20:20 <quicksilver> beyond a certain threshold at least :)
07:20:27 <quicksilver> if it took 10 minutes that would be annoying.
07:20:30 <Baughn> That Chans are slow? Oh yes
07:20:35 <matthew-_> hey, I'm not setting any store by these results. I just find it curious
07:22:25 <kalven_> what does -N2 mean? start two os threads?
07:22:29 <matthew-_> ja
07:24:03 <kalven_> does that mean that the thread-ring benchmark would slow down a lot if it actually used more than one os thread?
07:24:35 <Baughn> Almost certainly. IME, synchronization is /always/ slower with more than one thread
07:25:05 <Baughn> And for GHC, the non-threaded code doesn't use any cpu-level synchronization at all. ;)
07:26:08 <matthew-_> Baughn: right, so all I was really trying to demonstrate is that my sessions stuff doesn't introduce any further runtime overhead
07:26:11 <kalven_> seems a bit dishonest then
07:26:16 <mauke> oh man, I <3 my generic cabal Makefile
07:26:43 <dcoutts_> mauke: what does it do?
07:28:37 <mauke> http://mauke.ath.cx/stuff/haskell/Makefile
07:28:54 <mauke> I can just unpack a package and say 'make install'
07:29:39 <mauke> it's also nice for development because 'make' triggers appropriate recompilation actions
07:31:50 <mauke> hmm, now I just need to figure out how to make cabal use an installation prefix
07:31:55 <mm_freak_work> about the rebuildingâ€¦  it would be nice, if cabal could generate proper Makefiles
07:32:21 <puusorsa> and if generating documentation worked with cabal isntall
07:32:36 <dcoutts_> puusorsa: there's an open bug on that if you want to hack
07:32:36 <puusorsa> havent tried in a while though maybe it does now
07:32:40 <Saizan_> proper makefiles for?
07:33:01 <dcoutts_> mm_freak_work: or better yet, have cabal do dependency rebuilding, like what Saizan is hacking on
07:33:11 <dcoutts_> mauke: --prefix=?
07:33:13 <mm_freak_work> Saizan: calling 'Setup.lhs build' in the right directory
07:33:57 <mm_freak_work> currently i need to write my own Makefiles, so i can use the 'make' support of my editor
07:34:20 <Saizan> ah, just as an interface
07:34:25 <mm_freak_work> yes
07:34:30 <mauke> dcoutts_: I mean ~/.cabal/config
07:34:41 <Saizan> or to handle recompilation between packages?
07:35:02 <dcoutts_> mauke: oh, right, user-prefix, global-prefix. But you're not using cabal-install at all in that makefile so it will not help.
07:35:17 <quicksilver> win 20
07:35:36 <mauke> dcoutts_: this is just what I've used for installing cabal-install and its dependencies
07:35:49 <mauke> (after upgrading ghc)
07:35:51 <mm_freak_work> Saizan: just a call to 'build' would suffice for me
07:36:25 <mauke> Warning: The package list does not exist. Run 'cabal update' to download it.
07:36:38 <mauke> how about downloading it for me?
07:37:14 <dcoutts_> mauke: perhaps, or perhaps it's important for users to know that it's a thing that needs to be done
07:37:41 <dcoutts_> since we do not update the list later unless the user says to do it
07:38:12 <Baughn> matthew-_: Well, lockClosure uses xchg. Given what it then goes on to do, it might possibly get higher performance with cmpxchg, but there's nothing obviously horrible here.
07:38:13 <dcoutts_> mauke: doing the whole thing automatically would be better, but it's not clear how to do it, eg when is it ok to go use the network?
07:38:19 <mauke> I see
07:38:31 <mm_freak_work> and i'd like cabal to recall 'config' automatically if 'build' finds that things have changed
07:38:34 <mauke> cabal-install++  # remarkably painless once it works
07:38:35 <dcoutts_> mauke: do file a feature request saying what you want it to do.
07:38:49 <mm_freak_work> just like the GNU build tools recall aclocal/autoconf/automake
07:39:02 <dcoutts_> mm_freak_work: yes, so would I. Please file a feature request.
07:39:34 <mauke> mm_freak_work: that sounds exactly like what my Makefile does
07:39:45 <dcoutts_> mauke: yep, pretty much.
07:39:50 <mm_freak_work> dcoutts_: where does it belong to?  is there a cabal team?
07:40:10 <dcoutts_> mm_freak_work: http://hackage.haskell.org/trac/hackage/
07:40:11 <lambdabot> Title: Hackage - Trac
07:40:11 <mm_freak_work> mauke: yeah
07:41:00 <mauke> can cabal resolve module names to packages?
07:41:31 <dcoutts_> mauke: no
07:41:31 <dcoutts_> not yet
07:41:31 <dcoutts_> mm_freak_work: give the use case and what it should do in various circumstances. Eg we'd want it to configure using the same config flags as was used previously.
07:43:03 <dcoutts_> mauke: it's something we might be able to do after Saizan's GSoC project
07:43:05 <mauke> I love the automatic dependency resolution
07:43:51 <dcoutts_> mauke: yeah, I'm pretty pleased with that. Though it's not perfect yet.
07:44:13 <dcoutts_> I'll blog about how it works
07:44:21 <mauke> good enough for rebuilding stuff with ghc-6.8.3
07:45:03 <Baughn> "modifyMS (M.adjust (\(CS hdl ds his) -> CS hdl ds (take numLastLines (e : his))) c)" <-- From Log.hs; I'm pretty sure this (despite the take) builds up an infinite chain of thunks representing channel logs. How should I go about constricting it?
07:46:14 <quicksilver> it looks to me like it will build up very long (not infinite!) thunk of the form
07:46:17 <Baughn> It's adjusting a Map to add a line. There's nothing reading the map.. except, it's modifyMS - module state, that is. Shouldn't LB be flushing that to disk on a regular basis?
07:46:30 <Baughn> Why not infinite?
07:46:38 <quicksilver> take n ( e : (take n ( e' : (take n ( e' : (take n ....
07:46:45 <dcoutts_> Baughn: are you sure that adjust actually forces the value in the map?
07:46:46 <Baughn> Okay. Arbitrarily large.
07:46:52 <quicksilver> because last I checked no IRC channels had an infinite amoung of conversation in ;)
07:47:12 <mm_freak_work> dcoutts_: ok, i'm writing a feature request right now
07:47:15 <Baughn> It's definitely one of the memory leaks, anyhow
07:47:22 <dcoutts_> mm_freak_work: thanks
07:47:29 <nominolo> @seen swiert
07:47:30 <lambdabot> swiert is in #haskell. I last heard swiert speak 3h 56m 14s ago.
07:47:30 <Baughn> dcoutts_: I see no reason it should
07:47:32 <quicksilver> let newhis = take numLastLines (e : his) in newhis `rnf` ....
07:47:48 <quicksilver> would be a start.
07:47:59 <quicksilver> Or, instead of using a list use something strict by default like Data.Sequence
07:48:03 <quicksilver> and just make the field strict
07:48:07 <quicksilver> which might "look" nicer
07:48:16 <quicksilver> (As well as performing better, asymptotically)
07:49:23 <quicksilver> however that won't solve it if adjust is also building deep thunks
07:49:52 <ventonegro> coloquei no reddit
07:49:53 <Baughn> Indeed not. No, I'll throw in an rnf
07:49:54 <ventonegro> http://www.reddit.com/r/programming/info/6nwmf/comments/
07:49:57 <lambdabot> Title: programming: Is the Lisp community really the culprit?
07:49:58 <dcoutts_> Baughn: from reading Data/Map.hs it does not look like adjust can ever force the value.
07:50:00 <ventonegro> oops, sorry
07:50:05 <ventonegro> wrong channel
07:50:10 <mauke> 'cabal install haddock' fails
07:50:21 <quicksilver> looks like we need a strict Data.Map.adjust then.
07:50:25 <mauke> is this caused by my upgrade to 6.8.3?
07:50:38 <PHO_> mauke: seems like so
07:50:39 <dcoutts_> quicksilver: or use update which returns Just
07:51:07 <dcoutts_> quicksilver: that gives you something to attach a seq to, since it does force the value to Just or Nothing
07:51:16 <PHO_> mauke: haddock looks broken due to API change of GHC
07:51:42 <mauke> I need to wait for a new haddock release, I gues
07:51:42 <quicksilver> dcoutts_: clever. but slightly evil.
07:51:52 <dcoutts_> quicksilver: ;-)
07:52:03 <quicksilver> dcoutts_: I think this is quite a good example of how lazy by default can be a pain :(
07:52:48 <dcoutts_> quicksilver: though so is the opposite. Neither is recoverable from the other.
07:53:10 <quicksilver> dcoutts_: Oh, I don't deny that.
07:53:17 <quicksilver> dcoutts_: most of the time I find laziness saves me time and effort.
07:53:33 <quicksilver> dcoutts_: but I think these memory leaks in LB are a rather good example of the worse case.
07:53:42 <dcoutts_> true true
07:54:12 <PHO_> true, but such leaking can be detected using heap profiler
07:54:31 <quicksilver> adjust' f k m = update (\x -> Just $! f x) k m
07:54:34 <quicksilver> ^^ is that right?
07:54:45 <dcoutts_> I think so
07:55:00 <dcoutts_> modifyMS (M.adjust (\(CS hdl ds his) -> CS hdl ds (take numLastLines (e : his))) c
07:55:21 <dcoutts_> Baughn: so yes, you'd need to use adjust' and also make sure that the take there is forced
07:55:43 <dcoutts_> Baughn: and/or use a queue type, since taking all the time is slow
07:55:59 <quicksilver> dcoutts_: Data.Sequence should fix that with minimal changes.
07:56:02 <dcoutts_> yep
07:56:32 <dcoutts_> and if CS is strict in the his :: Sequence then it'll be easy
07:56:32 <quicksilver> modifyMS (adjust' (\(CS hdl ds his) -> let his' = take numLastLines (e:his) in his' `rnf` CS hdl ds his')
07:56:46 <quicksilver> but we also need to make modifyMS strict, if I remember the code
07:57:08 <mauke> what's rnf?
07:57:22 <quicksilver> from Control.Parallel.Strategies
07:57:25 <quicksilver> it's basially deepSeq
07:57:28 <mauke> ah
07:57:32 <quicksilver> it is predefined for basic types
07:57:34 <quicksilver> including lists
07:57:37 <quicksilver> which is why we need it here.
07:58:04 <quicksilver> actually this is another place you could use $!
07:58:08 <quicksilver> since it happens to be last parameter
07:58:12 <maltem> what is it an abbrev. for, "reduce to normal form"?
07:58:17 <Frederick> folks can you suggesta good book in algorithms to have at home as reference?
07:58:20 <quicksilver> CS hdl ds $! take ...
07:58:23 <quicksilver> maltem: yes
07:58:31 <maltem> right
07:58:33 <quicksilver> maltem: or "recursive normal form"
07:58:34 <quicksilver> I'm not sure :)
07:58:40 <quicksilver> it's defined by recursion over types
07:58:44 <quicksilver> so it might be the latter.
07:58:58 <quicksilver> it's not full normal form, it doesn't go under lambdas of course.
07:59:00 <maltem> ah, compared to whnf, "recursive" sounds better
07:59:02 <PHO_> and rwhnf is hard to remember unless you know it's Reduce to Weak Head Normal Form
07:59:02 <quicksilver> (can't do that in haskell)
07:59:43 <osfameron> byorgey: thanks -- you're right, I don't know why I had a $ there, I must have thought I needed it in an earlier refactoring of the code...
07:59:51 <MyCatVerbs> PHO_: "RAWR! WE HAFF NO FOLLICLES!"
07:59:52 <maltem> PHO_: I couldn't even remember whnf
07:59:57 <PHO_> lol
08:00:08 <MyCatVerbs> There you go. Now you have a mnemonic.
08:00:21 <dcoutts_> quicksilver: you don't need rnf
08:00:36 <quicksilver> dcoutts_: no? I need something to force a list of strings dont' I?
08:00:42 <byorgey> osfameron: sure, you're welcome.  cool post though!  that is some very elegant code.
08:00:54 <dcoutts_> quicksilver: just make CS strict in the history and make the history a Sequence
08:00:56 * byorgey adds it to the HWN
08:01:01 <quicksilver> dcoutts_: oh, yes, agreed.
08:01:12 <quicksilver> dcoutts_: I was proposing what you'd need to do without changing the types.
08:01:25 <dcoutts_> quicksilver: even then, you'd only need seq
08:02:05 <dcoutts_> and seq the length of the list
08:02:12 <sayaaan> does anyone knows about lava here?
08:02:39 <dcoutts_> quicksilver: which is like rnf of course, though without traversing into the elements
08:03:07 <PHO_> lava? which flows from the volcano?
08:03:43 <quicksilver> dcoutts_: true enough, but for some reason length xs `seq` has always felt like a worse hack than rnf :)
08:04:03 <byorgey> I assume sayaaan means lava the hardware description DSL =)
08:04:11 <sayaaan> yep
08:04:13 <sayaaan> :P
08:04:27 <dcoutts_> quicksilver: heh yes I know what you mean. We want something like foldr seq id
08:04:42 <sayaaan> byorgey, right dude!
08:05:08 <byorgey> sayaaan: I don't know much about it beyond what it is, unfortunately
08:05:09 <osfameron> byorgey: thanks, I'm pleased with how it came out.  Got lots of help from #haskell and lambdabot's @pl of course :-)
08:05:17 <byorgey> of course =)
08:06:01 <sayaaan> byorgey,  i cant install lava here... i compiled ghc 6.8.2 but when i build my lava dont works :/
08:06:21 <mauke> deepSeq x = length (show x) `seq` x
08:06:36 <sayaaan> byorgey, dist/build/Lava.o: file not recognized: File format not recognized  =(
08:07:16 <PHO_> I have recently wrote a program which heavily updates maps, and I found rnf'ing large maps frequently makes the program very slow
08:07:34 <ndm> sayaaan, check you have enough disk space, then runhaskell Setup clean and try again
08:08:18 <quicksilver> PHO_: yes, rnf'ing them frequently would be repeatedly doing unnecessary work.
08:08:53 <quicksilver> PHO_: better just to get correct strictness on your update operations.
08:09:00 <quicksilver> (note that maps are spine-strict anyway)
08:09:12 <PHO_> quicksilver: that's exactly what I concluded
08:10:08 <dcoutts_> quicksilver: actually you want seqList xs a = foldl' const a xs
08:10:26 <sayaaan> ndm, runhaskell setup clean and then try again... its works!! o/
08:10:48 <ndm> :) - computers are a bit funny sometimes
08:10:55 <sayaaan> yeah :P
08:11:12 <sayaaan> ty for help guys... know ill code! :D
08:11:16 <sayaaan> now
08:11:16 <sayaaan> =p
08:11:23 <dcoutts_> quicksilver: though as you say, just use the right ops in the first place
08:11:30 <sayaaan> brb
08:15:39 <fons> cdcpb
08:16:46 <mauke> how did you get that backwards d?
08:17:31 <fons> I'm curious about something. How is it possible to declare (at least in GHC):
08:17:40 <fons> infixl 5 `negate`
08:18:04 <fons> negate is not an operator ...
08:18:10 <mauke> but `negate` is
08:18:32 <scook0> surrounding an identifier with `` turns it into an infix operator
08:18:58 <fons> scook0: right, but it only takes an argument
08:19:04 <Deewiant> > (5 `negate`)
08:19:20 <lambdabot>  thread killed
08:19:21 <mauke> *> 2 `negate` 3
08:19:22 <mauke> -2
08:19:35 <Deewiant> > negate 2 3
08:19:36 <lambdabot>   add an instance declaration for (Num (t -> a))
08:19:56 <Deewiant> > 2 `negate` 3
08:19:57 <lambdabot>   add an instance declaration for (Num (t -> a))
08:20:01 <Deewiant> > (2 `negate`)
08:20:03 <lambdabot>  -2
08:20:06 <mauke> Deewiant: you need http://mauke.ath.cx/stuff/haskell/fun.hs :-)
08:20:12 <scook0> looks like GHC's "postfix operators" extension then
08:21:17 <scook0> > let ($) = (++" dollars") . show in (5 $)
08:21:18 <lambdabot>  "5 dollars"
08:21:36 <mauke> > (â‚¬)
08:21:36 <lambdabot>  Illegal character ''\130''
08:21:36 <lambdabot>  at "‚¬)" (column 3)
08:22:14 <scook0> you can use a unary operator as a left section (which, as you probably know, would normally be illegal)
08:22:18 <fons> OK, strange, but I guess that explains it ...
08:23:02 <fons> *> (`negate` 5)
08:23:15 <mmorrow> > let (!) s = s++"!" in (! "asdf")
08:23:16 <lambdabot>  Couldn't match expected type `[Char] -> t'
08:23:31 <mauke> fons: <fun>
08:23:37 <mmorrow> > let (!) s = s++"!" in ("asdf" !)
08:23:38 <lambdabot>  "asdf!"
08:23:46 <mmorrow> "my other left"
08:24:35 <fons> ok, thanks guys
08:42:41 <mm_freak_work> dcoutts_: "Assign to:"?
08:42:58 <dcoutts_> mm_freak_work: lave that blank
08:43:51 <mm_freak_work> which version should i select?  HEAD?
08:44:07 <mm_freak_work> and which milestone?  âŠ¥?
09:00:31 * byorgey sets out a bowl of cheesy lambdas
09:02:57 <Feuerbach> I'm sure I've seen rotate (e.g. [1,2,3]->[3,1,2]) function somewhere in Data.List, but can't find it. Am I wrong?
09:03:28 <Deewiant> I think you are
09:03:44 <mauke> :t (uncurry (flip (++)) .) . splitAt
09:03:47 <lambdabot> forall a. Int -> [a] -> [a]
09:04:08 <Saizan> > take 3 . drop 2 . cycle $ [1,2,3]
09:04:09 <lambdabot>  [3,1,2]
09:04:51 <mauke> > ((uncurry (flip (++)) .) . splitAt) 2 [1,2,3]
09:04:53 <lambdabot>  [3,1,2]
09:05:23 <quicksilver> > uncurry (:) . (last &&& init) $ [1,2,3]
09:05:24 <lambdabot>  [3,1,2]
09:06:07 <Feuerbach> Ok, thanks :)
09:07:51 <Socrates`> @check (\xs -> ((uncurry (flip (++)) .) . splitAt) 3 xs == id xs)
09:07:53 <lambdabot>  OK, passed 500 tests.
09:08:05 <byorgey> random question inspired by Feuerbach's question: how would one design a functional data structure which stores linearly ordered homogeneous elements, supporting O(n) traversal and O(1) rotate?  discuss.
09:08:24 <quicksilver> byorgey: answer : by asking okasaki?
09:08:31 <byorgey> hehe
09:08:49 <opqdonut> byorgey: circular list?
09:08:51 <quicksilver> I think you can do that with a thin wrapper over Data.Sequence
09:09:00 <lilachaze> byorgey: an Array and an Int?
09:09:03 <byorgey> opqdonut: yes, but how would you do that functionally?
09:09:16 <quicksilver> or you can just use the standard pair of lists reversing when one empties
09:09:28 <opqdonut> quicksilver: a zipper, almost
09:09:30 <lilachaze> a circular list doesn't give O(1) rotate, does it?
09:09:42 <byorgey> ah, good one quicksilver.  so that supports O(1) amortized rotate.
09:09:43 <opqdonut> lilachaze: yes it does, we just grab another element as the "start"
09:10:21 <quicksilver> byorgey: a pair of lists is basically inferior to Data.Sequence in every way though I think.
09:10:23 <ahunter_> Do we want O(1) "rotate one unit left or right", or O(1) "rotate any number of elements"?
09:10:42 <quicksilver> byorgey: with the possible exception of 'slightly lower constant factor for the O(1) operations"
09:10:50 <Feuerbach> ahunter_: former, I think
09:11:07 <byorgey> ahunter_: well, interesting question.  can one be supported more efficiently/elegantly than the other?
09:11:29 <ahunter_> byorgey: well, Data.Sequence gives you trivial amortized O(1) rotate single unit, of course.
09:11:43 <ahunter_> byorgey: I'm unsure whether or not you can efficiently do the second.
09:14:38 <quicksilver> take n is O(log n) on Data.Sequence
09:14:48 <quicksilver> independent of the total length of the Sequence
09:14:49 <dcoutts_> quicksilver: ah but you can do better
09:14:52 <quicksilver> this is, basically, the clever bit.
09:14:59 <dcoutts_> since you know the sequence size
09:15:11 <dcoutts_> and you know that at most you want to drop one element
09:15:17 <dcoutts_> since you're only adding one element
09:15:25 <quicksilver> well we were talking about arbitrary n-rotations
09:15:30 <quicksilver> just now ;)
09:15:32 <dcoutts_> oh ok
09:15:37 <quicksilver> 1-rotations is indeed fast.
09:17:34 <mmorrow> i think it comes down to whether the list implem has O(1) cons,snoc,tail,init (like Data.Sequence)
09:18:25 <quicksilver> unless there is a cleverer way to do it :)
09:18:28 <quicksilver> where you defer the rotation
09:18:32 <quicksilver> and somehow amortize it and win.
09:18:46 <quicksilver> the hard bit is the lastbit :)
09:19:04 <mmorrow> um i meant cons,snoc,head,last,tail,init
09:19:19 <int-e> you can build a random access 'array' on top of a data structure that supports cons, tail, head and arbitrarily far rotates.
09:20:23 <mmorrow> ah, i was assuming rotating by one in either direction
09:20:29 <Baughn> @tell Cale http://brage.info/~svein/cale <-- Memory leak in Log plugged, leak in Seen "fixed" by disabling Seen. Also, +RTS -c might be a good idea for a memory-constrained machine
09:20:30 <lambdabot> Consider it noted.
09:22:30 <mmorrow> int-e: which interestingly Data.Sequence does, where it's split function corresponds to your "arbitrarily far rotates"
09:22:40 <mmorrow> s/it's/its/
09:23:44 <mmorrow> int-e: but when indexing i think it does the direct route and achieves O(lg(min(i,n-1)))
09:24:09 <mmorrow> s/does/goes/
09:26:08 <mm_freak> dcoutts_:
09:26:09 <mm_freak> 318 174352 <mm_freak_work> which version should i select?  HEAD?
09:26:11 <mm_freak> 318 174407 <mm_freak_work> and which milestone?  âŠ¥?
09:26:37 <dcoutts_> mm_freak: leave them blank
09:26:49 <quicksilver> Baughn: Writer.Strict to impose strictness?
09:27:02 <quicksilver> Baughn: interesting approach...
09:27:26 <mm_freak> ok, submitted
09:27:52 <yav> does anyone know how to create a common index for the documentation of a collection of packages?
09:27:53 <Baughn> quicksilver: I have no idea what withMS really is based on. Plus, it /doesn't work/, so..
09:28:09 <dcoutts_> yav: there's some incantation to haddock
09:28:10 <Baughn> quicksilver: I just disabled appendEvent, since all the code that /reads/ the state has been disabled a long time now
09:28:13 <yav> i mean haddock documentation
09:28:28 <mmorrow> int-e: actually, i believe my "direct route" is equivalent to split which is equivalent to your "arbitrarily far rotates"
09:28:48 <smg> hello
09:28:53 <yav> yeah i tried gen-index and gen-content, with the list of interface files
09:28:55 <Baughn> quicksilver: Doing this stops LB leaking, but someone better with the language will have to actually /fix/ it
09:29:11 <dcoutts_> yav: and no joy?
09:29:14 <yav> it seems that the links are wrong though, so i must be doing something wrong
09:29:15 <int-e> mmorrow: I just tried to convince myself that with O(1) cons, tail and head, an O(1) rotate isn't possible.
09:29:44 <mmorrow> int-e: did it work?
09:29:45 <dcoutts_> yav: when you specify the .haddock interface file you also give the path/uri for links
09:29:50 <smg> i have something like that -/-//----\/\\\ and i need to make a context free gramma out of it
09:29:54 <smg> means that there is the same amount of "/" and "\" in it
09:29:56 <smg> and - is optional..
09:29:58 <smg> but my gramma fails
09:30:19 <dcoutts_> yav: check the haddock manual but I think it's something like --read-interface=FILE,URI
09:30:47 <yav> oh i see, i'll take a look---i just gave it the iface file.  thanks!
09:31:14 <quicksilver> Baughn: Oh, I see. ;)
09:31:15 <byorgey> smg: you need some nonterminals to introduce pairs of /\ or \/ at the same time (with stuff optionally in between them)
09:31:45 <byorgey> smg: why don't you paste what you have so far somewhere?
09:31:56 <dcoutts_> yav: --use-package= may also work, it's equivalent to --read-interface=FILE,URI but it gets both values from ghc-pkg
09:33:16 <yav> docutts_: that would be simpler. i'll give it a try
09:33:21 <smg> i know
09:33:25 <smg> byorgey: may you look at it?
09:35:39 <byorgey> smg: sure
09:37:17 <osfameron> are there any FP conferences coming up this year in Europe?
09:37:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8398
09:37:26 <smg> http://hpaste.org/8398 there is the paste byorgey
09:38:04 <osfameron> aha, icfp is europe on odd-numbered years
09:38:22 <osfameron> anyway, that's a bit high-brow for me  (Though I guess there aren't really any low-brow FP events are there?)
09:38:27 <ddarius> Are there really 15 whining emails on Haskell-Cafe?
09:38:34 <byorgey> smg: with that grammar, you can only ever have / on the left and \ on the right
09:38:58 <ddarius> osfameron: There are certainly more informal FP events.
09:39:21 <byorgey> smg: you also can't have - at the ends of strings
09:39:31 <smg> damn :|
09:39:36 <osfameron> gosh, the poor PHP dev got a rather frosty reception
09:40:14 <smg> byorgey: do you have improvement suggestions?
09:41:04 <EvilTerran> ?where cafe
09:41:04 <lambdabot> I know nothing about cafe.
09:41:21 <HunterXHunterX> ?seen vagabond
09:41:21 <lambdabot> I haven't seen vagabond.
09:41:33 <byorgey> smg: you can probably fix it just by adding some extra productions to the definition of Gramma.  one allowing Down then Up, and one allowing Straight after Gramma.
09:42:31 <ddarius> osfameron: Not really.  There was only one person, I think, that was unreasonably negative.
09:42:40 <byorgey> smg: also, I don't think you need separate productions for Up and Down.  you can handle the recursion within the definition of Gramma itself, you don't need Up and Down to include Gramma also
09:42:42 <quicksilver> osfameron: I tried to rebuff the frost, but I fear I made things worse, nett.
09:42:57 <osfameron> ah well
09:43:36 <smg> byorgey: should we discuss that in private message to not annoy the channel?
09:43:41 <smg> byorgey: or is this okay in here?
09:43:57 <byorgey> smg: sure, we can discuss it in a private msg
09:44:35 <Associat0r> any F# guys around here?
09:45:37 <ddarius> This isn't the F# channel.
09:45:59 <Associat0r> I know
09:47:05 <yav> Associat0r, if you have a general FP question we may be able to help.  many of us know more than one FP language, although I have not used F#
09:47:53 <Associat0r> I wanted to know if polymorphic variants are considered for F#
09:48:17 <Associat0r> but dons seems not around right now
09:48:22 <ddarius> Try asking on an F# channel/forum/mailing list.
09:48:29 <ddarius> dons is not Don Syme.
09:49:00 <Associat0r> are you sure?
09:49:03 <ddarius> Yes.
09:49:07 <ddarius> He's Don Stewart.
09:49:18 <quicksilver> is dons like a side-effect free version of Don Syme?
09:49:32 <yav> :)
09:49:49 <EvilTerran> "safe with most medications"
09:50:09 <quicksilver> "F# - Possible side-effects include Death"
09:50:13 <Associat0r> I don't believe it
09:50:44 <yav> Associat0r: it's true :) he sits across from me at work
09:51:10 <Associat0r> you guys are kidding me
09:51:15 <Associat0r> right?
09:51:22 <quicksilver> which part?
09:51:33 <quicksilver> dons really is Don Stewart
09:51:34 <Associat0r> all parts
09:51:40 <quicksilver> who is genuinely different from Don Symes
09:51:47 <quicksilver> although they are both well known in the community
09:51:59 <quicksilver> I daresay we could even find someone who has seen them in the same room.
09:52:07 <mjrosenb> anyone know the easiest way of getting ghc for ppc osx?
09:52:17 <yav> well, if they were the same person that would not be a problem :)
09:52:19 <quicksilver> mjrosenb: macports used to work for me.
09:52:26 <puusorsa> mjrosenb, the precompiled installer or ports
09:52:51 <mjrosenb> precompiled installer sound like it won't involve compiling gcc
09:53:03 <quicksilver> you will need gcc to use ghc
09:53:13 <quicksilver> you need to install XCode
09:53:18 <quicksilver> to do any useful development on a mac
09:53:19 <puusorsa> you don't need to compile gcc though
09:53:25 <quicksilver> no, you don't need to compile it
09:53:25 <mjrosenb> presumably there's a precompiled whatnot for gcc
09:53:27 <puusorsa> just isntalling will do
09:53:31 <quicksilver> apple helpfully put it on the OSX DVD
09:53:37 <quicksilver> you just need to double click the installer
09:53:40 <puusorsa> mjrosenb, developer.apple.com for the latest version
09:54:12 <mjrosenb> so, i'm borrowing a laptop from a friend, since i can theoretically do my work on this, and they can't
09:54:22 <mjrosenb> and i've never actually used osx before
09:55:00 <quicksilver> the version on developer.apple.com is Leopard only
09:55:11 <quicksilver> if you have an older version of the OS you want the version on your install DVD
09:55:19 <quicksilver> maybe your friend has already installed it
09:55:32 <mjrosenb> install dvd, it would be awesome ifi had one of those
09:55:33 <Baughn> http://developer.apple.com/tools/download/ <-- No, this has both the tiger and leopard versions
09:55:33 <lambdabot> Title: Tools - Downloads
09:55:37 <Baughn> 2.5 is for tiger
09:55:39 <puusorsa> there are older versions on apple site too
09:55:52 <puusorsa> if you've lost the dvd
09:55:54 <quicksilver> ah good spot
09:56:00 <quicksilver> last time I looked I couldn't see them
09:56:02 <quicksilver> no idea why not :)
09:56:08 * quicksilver must be blind
09:56:14 <puusorsa> or put it 'somewhere safe' -> takes more time to find it than download
09:56:19 * Baughn used the power of google
09:56:46 <ahunter_> @seen dons
09:56:47 <lambdabot> dons is in #arch-haskell, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 10h 10m 33s ago.
09:57:53 <quicksilver> I think it's almost time to add a @pr to lambdabot
09:58:01 <quicksilver> like protontorpedo
09:58:20 <quicksilver> "I'm getting sick of you hypocrites who allow yourselves the audacity to attack me, totally gratuitously, yet when I try to defend myself you take the moral high ground"
09:58:45 <ahunter_> quicksilver: what would pr do exactly?
09:58:52 <quicksilver> @protontorpedo
09:58:52 <lambdabot> why haskell over lisp?
09:59:02 <quicksilver> it would record some of his quotes for posterity.
09:59:03 <mjrosenb> wtf, ineed anapple dceveloper account
09:59:11 <quicksilver> I'm not serious, btw.
09:59:14 <Baughn> mjrosenb: Yeah. They're free.
09:59:19 <quicksilver> I don't really approve of taking mockery that far.
09:59:25 <quicksilver> I'm just letting off steam.
10:00:02 <Apocalisp> about whom are you talking?
10:00:46 * Baughn makes delicious pancakes. You can't have any.
10:01:31 <quicksilver> Apocalisp: http://www.nabble.com/Re%3A-Lambda-and-closures-in-PHP----could-someone-please-comment--p17987219.html
10:01:33 <lambdabot> Title: Nabble - Re: Lambda and closures in PHP -- could someone please comment?, http://tinyurl.com/59v72m
10:01:35 <quicksilver> Baughn: :(
10:01:51 <Baughn> quicksilver: If you fix Log for me, I'll consider it
10:01:52 <yav> dcoutts_: any ideas how haddock chooses which package.conf to use?
10:02:16 <dcoutts_> yav: usign ghc-pkg on the $PATH, and ghc-pkg knows which package.conf it uses
10:03:09 <yav> hmm... my ghc-pkg is called something else...
10:09:10 <yav> docoutts_: a bit of makefile hackery did it. thanks!
10:13:56 <Gilly> would anyone have a gauss-jordan in haskell lying around somewhere?
10:14:09 <Gilly> i can't find it in those ready made linearalgebra packages :/
10:14:37 <Gilly> i'd need the actual matrix + augmented vector
10:17:11 <DRMacIver> This blow up on the cafe really is pretty astonishing.
10:17:36 * DRMacIver has sortof assumed that non-trivial levels of Haskell in the bloodstream made everyone polite.
10:19:53 <thetallguy> Bonsoir, conal!
10:19:53 <malcolmw> what blow-up?  I don't follow the cafe too closely
10:20:14 <DRMacIver> "Lambda and Closures in PHP"
10:20:31 <DRMacIver> Specifically PR Stanley's emails
10:21:05 <dons> DRMacIver: blow up? oh. yes.
10:21:09 <dons> that was unwelcome.
10:21:33 <dons> the original poster was politely asking in here for a careful eye to look over the PHP spec for closures
10:21:42 <dons> and we directed him to -cafe@, perhaps unwisely
10:21:55 <thetallguy> I almost replied to his very first message, asking him to keep it polite...
10:22:00 <Nafai> Lemme guess, people ripped PHP apart? :)
10:22:10 <thetallguy> Guess I should have acted on that.
10:22:22 <DRMacIver> It seemed a little inappropriate for the cafe to me, but I didn't really care. The angry response however seemed a lot inappropriate.
10:22:39 <thetallguy> conal: where's my chip with mayo?
10:23:27 <dons> conal: i've moved most of your packages into Arch Linux, except things that need wxHaskell, which isn't building for me yet
10:23:28 <dcoutts_> dons: here's a nice bug, related to X11's use of LDFLAGS
10:23:28 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/295
10:23:31 <lambdabot> Title: #295 (ld-options parsing treats , as separator) - Hackage - Trac
10:23:38 <dons> oh.
10:23:49 <mauke> I wish my mail client had an interface like /ignore
10:24:04 <dcoutts_> dons: btw, why does it put LDFLAGS into ld-options? was there a specific need? should we do it more generally?
10:24:17 <dons> hmm
10:24:25 <DRMacIver> mauke: Don't most mail clients have some sort of kill file capability?
10:24:35 <dons> ah, due to OpenBSD,
10:24:36 <dons> $ echo $LDFLAGS
10:24:37 <dons> -L/usr/local/lib
10:24:43 <dons> that's one way to find stuff
10:24:50 <dcoutts_> dons: ah, so we have a way to do that now
10:24:52 <dons> still, X11 is never likely to be in LDFLAGS
10:25:31 <dcoutts_> dons: the user can configure with --extra-library-dirs=/usr/local/lib
10:25:49 <dcoutts_> dons: or would LDFLAGS have -L/usr/local/lib in it by default on bsd?
10:26:09 <dons> ah great
10:26:20 <dons> hmm. i'm not sure how wide spread LDFLAGS is
10:26:25 <dcoutts_> ie would looking at LDFLAGS make it work "out of the box" or would users still be setting LDFLAGS manually anyway?
10:26:41 <dcoutts_> dons: gentoo users use some pretty crazy ld flags, I would prefer to ignore them :-)
10:26:49 <dcoutts_> hia ivanm ;-)
10:27:02 <dons> dcoutts_: oh, optimisations and the like?
10:27:02 <hpaste>  morrow pasted "mallocForeignPtrBytes misc" at http://hpaste.org/8400
10:27:09 <dcoutts_> dons: apparently
10:27:25 <dcoutts_> dons: so for gentoo we'll have to patch X11.buildinfo.in to remove LDFLAGS
10:27:40 <dons> hmm
10:27:54 <dons> so maybe its best to just remove LDFLAGS support
10:27:56 <dcoutts_> otherwise we hit this cabal bug when users use crazy ld flags
10:28:28 <dcoutts_> I mean obviously it's a bug that needs to be fixed, but I was just wondering what we should be doing with LDFLAGS generally
10:28:42 <dcoutts_> adding it for just one package doesn't seem the right way to go
10:29:10 <dcoutts_> we should do it for all or none, or find a better way of solving the problem that the LDFLAGS thing was for
10:30:28 <dcoutts_> dons: one reason I worry is that it means putting all the flags into the package registration file too
10:30:44 <dcoutts_> and I worry that we'll end up with weird stuff in there and people will not realise how it got there
10:31:12 <dcoutts_> the difference when building a C package is that the flags typically only get used at build time
10:31:33 <dcoutts_> and not stashed away in a package registration file to use on every subsequent use
10:32:10 <dcoutts_> we'd also get horrendous duplication
10:33:06 <dcoutts_> if every registered package contained all of ivanm's silly LDFLAGS. He means to use those flags once on each link, not N times where N is the number of packages being linked together to make a program.
10:33:25 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8401
10:34:37 <luxid> ï»¿ï»¿ oggi Ã¨ il download day! aiuta firefox ad entrare nel guinnes dei primati con il massimo numero di download in 24 ore! http://www.spreadfirefox.com/it/worldrecord entro le 20 di oggi
10:34:50 <lambdabot> Title: Spread Firefox | Download Day 2008
10:36:02 <mjrosenb> well that was interesting
10:36:02 <Zao> Isn't he a bit behind?
10:36:09 <mjrosenb> he is
10:38:46 <dons> ok, -cafe@ has gone crazy.
10:38:53 <dons> i'm moderating PR Stanley till he calms down.
10:40:01 <byorgey> should I put this in the HWN? ;)
10:40:35 <dons> no !
10:42:27 <byorgey> dons: hehe, I know
10:43:51 <dolio> What did he do this time?
10:44:07 <dolio> Compare PHP to neurotoxin or something?
10:47:47 <byorgey> dolio: that wasn't the problem, the problem was when he started calling people assholes, comparing them to Hilter, etc etc... =P
10:47:53 <byorgey> er, Hitler
10:48:02 <dolio> Wow.
10:48:10 <dolio> I didn't really bother to read that thread. :)
10:48:19 <Spark> how cliched
10:48:21 <byorgey> I don't recommend it
10:49:10 <mauke> (I don't read PR Stanley anyway because of his dysfunctional quoting style)
10:50:23 <dons> mauke: i think he uses a terminal reader (he's vision impaired, iirc)
10:50:27 <dons> not sure if that matters or not
10:51:01 <pafcu> So Mr. Hilter has abandonded his plans to annex Poland to Bridgewater, Sommerset and spends his time arguing on haskell-cafe instead? http://www.youtube.com/watch?v=vlmGknvr_Pg
10:51:02 <lambdabot> Title: YouTube - Monty Python - Mr. Hilter
10:51:03 <Spark> he probably doesn't like hearing "greater than blah blah greater than blah blah"
10:53:01 <dons> wow, he totally blew off my little email to ask him to be civil. hmm
10:55:31 <Apocalisp> if . is fmap for (b->), what's bind?
10:55:33 <int-e> dons: (Re: broken packages on hackage) do you have easy access to build logs for the broken packages?
10:55:46 <dons> int-e: i can construct them, yes.
10:55:52 <dolio> @src (->) (>>=)
10:55:52 <lambdabot> f >>= k = \ r -> k (f r) r
10:55:54 <dons> i'll do another sweep, it only takes an hour or so
10:55:56 <dons> then post the logs
10:56:04 <dolio> bind = S . flip
10:56:06 <dons> dcoutts_ also has logs from cabal's build reporting
10:56:22 <dcoutts_> ah yes, I'll post those
10:56:23 <byorgey> mauke: yeah, he's vision-impaired, so I imagine you need to quote things like that so that when it reads the emails to you, it says the name of who's talking before reading each quoted part
10:56:39 <byorgey> hard to convey indentation in a screen reader.
10:56:48 <dcoutts_> int-e: not build logs yet. I've only implemented anonymous reporting in cabal-install so far.
10:57:02 <mauke> byorgey: why?
10:57:17 <Apocalisp> @pl \ r -> k (f r) r
10:57:17 <lambdabot> k =<< f
10:57:19 <mauke> it could use different voices or use explicit "start indent", "stop indent" markers
10:57:26 <Apocalisp> cool! Thanks
10:57:34 <dcoutts_> int-e: of course for a one off I can just log the whole thing, but not broken down logs by package.
10:57:37 <fophillips> If I have the function â€œx =~ y :: Stringâ€ how would I map that to a list xs to match against y?
10:57:41 <int-e> dons: meh, never mind, found my mistake.
10:58:22 <Baughn> fophillips: Insufficient information. map?
10:58:34 <yrlnry_> I had this idea that if I have a monad that's also a functor, I should be able to build >>= in terms of fmap.  So far I haven't been successful.  Is there a solution, or am I barking up the wrong tree?
10:58:54 <mauke> yrlnry_: you need join
10:58:55 <fophillips> Baughn: I thought â€œmap ((=~) y) xs :: Stringâ€ would work, if thatâ€™s any help.
10:58:57 <fons> is anyone familiar with text.PrettyPrint.HughesPJ?
10:59:10 <yrlnry_> mauke: yes, but join is defined in terms of >>=, and there doesn't seem to be any way around that.
10:59:18 <mauke> yrlnry_: ... which is defined in terms of >>=, so you're probably better off defining fmap in terms of >>=
10:59:21 <fons> I don't understand why this expression isn't broken in multiple lines
10:59:22 <mauke> exactly
10:59:27 <Baughn> fophillips: Well, no. y is supposed to be the /second/ parameter to =~, right?
10:59:36 <Baughn> fophillips: So "map (=~ y) xs" might do it
10:59:36 <ventonegro> I guess I shouldn't have sent my last reply. oh well.
10:59:37 <fons> > let foos = replicate 10 $ text "foo" in renderStyle style{lineLength=10} $ hsep foos
10:59:37 <sm>  dcoutts et al: cabal-install is great, thanks a lot
10:59:38 <lambdabot>  "foo foo foo foo foo foo foo foo foo foo"
11:00:13 <Baughn> fophillips: Using (=~) turns it into an ordinary (prefix) function
11:00:27 <yrlnry_> So there's no way to make >>= from just fmap, without using join also?
11:00:40 <fophillips> Baughn: I get an â€œNo instance for (RegexContext Regex Char target)â€ for that.
11:00:43 <dons> dcoutts_: i propose we have once weekly build summaries from hackage
11:00:45 <yrlnry_> And there's no way to make join without using >>=?
11:00:50 <dons> publicised.
11:01:10 <dcoutts_> dons: we'll want to set up a cabal-install style build-bot
11:01:17 <dons> yep
11:01:31 <dcoutts_> dons: and for that we want build logs, not just the minimal info we want for anonymous reports
11:01:33 <mauke> yrlnry_: depending on the monad you can do it "manually"
11:01:41 <Baughn> fophillips: That's odd. If x =~ y works, then map (=~ y) [x] should work as well.
11:01:54 <Baughn> fophillips: Check the types on that
11:02:03 <yrlnry_> For this monad I can define >>= easily, but it is very similar to the definition for fmap, so I thought maybe I could get it from fmap.
11:02:13 <dcoutts_> dons: in theory, if the data is high enough quality (not dieing due to spurious errors) then we can email maintainers directly.
11:02:15 <yrlnry_> It's essentially Maybe.
11:02:18 <fophillips> Baughn: â€œx =~ yâ€ requires explicit declaration of the type.
11:02:21 <mauke> instance Functor M where fmap = liftM  -- works for any monad
11:02:39 <dcoutts_> dons: eg the current logs are fine, but they're not good quality. eg diamond dep errors, lack of C libs etc.
11:02:48 <fophillips> Baughn:  â€œx =~ y :: Stringâ€ would work, â€œx =~ yâ€ would not.
11:02:58 <dcoutts_> dons: anything that's fully automated like that has the same problem.
11:03:09 <Baughn> fophillips: Well, it'd work if you then proceed to use the value in a context that needs it to be String
11:03:14 <dcoutts_> dons: it's one advantage of using real build reports from real users.
11:03:19 <dons> dcoutts_: right, you need an exception list for things we don't expect to work.
11:03:25 <Baughn> fophillips: That aside, the map variant would just have to be constrained to [String]
11:03:26 <dcoutts_> dons: though then the data is obviously more noisy.
11:03:27 <dons> i've also found it useful to update cabal and bytestring first.
11:03:30 <dons> then do the run
11:03:38 <dons> also, incrementally add C libs as they fail
11:03:47 <dons> so now i'm only missing half a dozen C libs hackage needs
11:03:56 <dons> wx is still not working though.
11:03:56 <fophillips> Baughn: â€œmap (=~ y) xs :: Stringâ€ gives the same error.
11:04:04 <Baughn> fophillips: I said, [String]
11:04:15 <dcoutts_> dons: aye, distro packages can specify C lib deps which makes things easier.
11:04:25 <fophillips> Baughn: Yeah, typo. Same error.
11:04:34 <dons> yep
11:04:40 <Baughn> fophillips: ..can you paste your code?
11:04:42 <dcoutts_> dons: or if cabal checked for C libs at configure time then we could see that more clearly in the build failures.
11:04:47 <dons> yep
11:06:26 <fophillips> Baughn: Wait, Iâ€™ve fixed it :)
11:06:36 <int-e> dcoutts_: uhm, shouldn't cabal translate most Extensions: flags to -fglasgow-exts for ghc 6.6.1?
11:06:46 <fophillips> Baughn: For some reason xs wasnâ€™t actually a list.
11:06:47 <dcoutts_> int-e: yes
11:07:06 <fophillips> Baughn: Ah, I used '' instead of ""
11:07:07 <dcoutts_> int-e: afaik it does, unless 6.6.1 does not support the extension at all
11:07:14 <yrlnry_> oh, fmap f x   is just x >>= (return . f)
11:07:19 <yrlnry_> I bet it says that in the report somewhere.
11:07:28 <mauke> @src liftM
11:07:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:07:34 <dcoutts_> int-e: perhaps we're missing some though, which one were you thinking of?
11:07:58 <mauke> I don't know if it actually requires fmap == liftM
11:08:36 <int-e> dcoutts_: argh, it was me being stupid again, my package has both an executable and a library stanca, and I need to name the extensions for both. interestingly, specifying the dependencies only once seems to work. oh well.
11:09:02 <dcoutts_> int-e: yeah, that's a bug really, that we use the union of the depends
11:09:12 <yrlnry_> "Instances of both Monad and Functor should additionally satisfy the law:
11:09:12 <yrlnry_> fmap f xs	=	xs >>= return . f"
11:09:15 <yrlnry_> Yep.
11:09:37 <yrlnry_> Thanks.
11:09:49 <byorgey> http://jdfrens.blogspot.com/2008/06/pe-problem-1-in-haskell.html
11:09:49 <lambdabot> Title: Programming During Recess: PE Problem #1 in Haskell
11:09:57 <yrlnry_> BTW, Haskell sucks because GHCI didn't work after I spilled hot cocoa into my keyboard.
11:10:07 <mauke> btw, did you know that fmap = (.) for the ((->) e) monad?
11:10:08 <byorgey> someone ought to invite this guy to the IRC channel =)
11:10:46 <Baughn> yrlnry_: Wait, your keyboard can't handle hot cocoa?
11:11:20 <gwern> yrlnry_: but - but - but simon fixed it in teh HEAD!
11:11:22 <Deewiant> Baughn: of course it can. Didn't you hear? GHCi broke, not the keyboard.
11:11:25 <yrlnry_> My keyboard handles it just fine.  It's Haskell that is at fault here!
11:11:58 <Baughn> yrlnry_: That's your own fault for not applying the anti-cocoa patch, then.
11:12:05 <yrlnry_> mauke: I did not know that.  Thanks.
11:12:10 <yrlnry_> Baughn: sure, blame the victim.
11:12:38 <mauke> > toUpper . "surprise"
11:12:39 <lambdabot>  "SURPRISE"
11:13:28 <gwern> mauke: is that one of Cale's extensions?
11:13:35 <yrlnry_> wait, what just happened there?
11:13:40 <mauke> haha
11:13:42 <Deewiant> in Caleskell, (.) = fmap
11:13:42 <mauke> gwern: yes
11:13:48 <orbitz> :t toUpper
11:13:49 <lambdabot> Char -> Char
11:13:57 <Deewiant> @src (.)
11:13:58 <lambdabot> (f . g) x = f (g x)
11:13:58 <lambdabot> -- In lambdabot, it's been generalised to:
11:13:58 <lambdabot> (.) = fmap
11:14:07 * gwern thought it was, 'cause I'm used to seeing map toUpper
11:14:12 <orbitz> :t fmap
11:14:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:15:20 <yrlnry_> :t litfM2
11:15:22 <lambdabot> Not in scope: `litfM2'
11:15:31 <yrlnry_> see, Haskell sucks, like I said!
11:15:36 <yrlnry_> :t liftM2
11:15:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:15:55 <yrlnry_> OK, I promise not to make this stale joke again.
11:16:24 <mauke> > liftM2 (*) negate sqrt 2
11:16:26 <lambdabot>  -2.8284271247461903
11:16:57 <mauke> > return (*) `ap` negate `ap` sqrt `ap` 2
11:16:58 <lambdabot>        add an instance declaration for
11:16:58 <lambdabot>       (Num ((a -> b) -> a), Floating (...
11:17:06 <mauke> :-(
11:17:32 <mauke> > (return (*) `ap` negate `ap` sqrt ) 2
11:17:34 <lambdabot>  -2.8284271247461903
11:19:12 <Deewiant> > ($"O") . liftM2 flip [(++)] ["M NOM NOM NOM", " RLY?"]
11:19:13 <lambdabot>  ["OM NOM NOM NOM","O RLY?"]
11:21:06 <dons> "Ok, not that different. But with Haskell you often expect to get very
11:21:06 <dons> slow code compared to an implementation in C.
11:21:11 <dons> And I am surprised, that the Haskell is fast _and_ nice to read"
11:21:12 <dons> hehe
11:24:00 <int-e> dons: ok, hs-pgms should now build fine. thanks for your work :)
11:24:10 <dons> great, int-e !
11:28:27 <audreyt> class C a b | a -> b, b -> a where f :: a -> b
11:28:36 <audreyt> what's the idiomatic way of translating it to type families?
11:29:07 <dons> hmm, we need a AT -> TF transltor
11:29:20 <audreyt> FD -> TF?
11:29:49 <audreyt> actually, a translation to associated type synonyms is what I'm looking for
11:29:55 <audreyt> as well
11:32:48 <audreyt> an obvious translation is
11:33:16 <audreyt> class (A a ~ b, B b ~ a) => C a b where { type A a; type B b; f :: a -> b }
11:33:32 <audreyt> but declaring an instance for it is clunky... is there a more natural way?
11:38:29 <fophillips> Is there a nicer way of doing this: subRegex (mkRegex "(< |>)") (concatMap (=~ "<..+>") ["00:00:00 < someuser> test"]) "" :: String
11:53:34 * MoonPatrol points at dobblego
11:53:42 <mmorrow> does anyone know what the situation is with sending txt messages to (us) cellphones from an arbitrary script with internet access?
11:53:45 <MoonPatrol> im ready for round 2.  the first round gave me a stomach ulcer and i've been out for a week.
11:54:49 <byorgey> MoonPatrol: round 2 of what?
11:54:52 <audreyt> answering my own question 20 minutes ago, it's better written as:
11:54:56 <audreyt> type family B a; type family A b; class A (B a) ~ a => C a where f :: a -> B a
11:55:06 <mrd> mmorrow: you spammer!
11:55:15 <MoonPatrol> byorgey, oh, just discussing random stuff about programming, i don't actually remember what..... but it was interesting nonetheless
11:55:17 <mrd> mmorrow: but yea, most cell phone companies have some kind of email access to txt
11:55:25 <byorgey> MoonPatrol: ah, well, welcome back =)
11:55:51 <mmorrow> mrd: hehe, don't call out my evil plans!
11:56:53 <mmorrow> mrd: yeah, i guess i can just send email to whatever's at the other end via runInteracriveProcess sendmail, but i was wondering about txt messages in particular?
11:57:31 <mrd> it's a gateway to txt msgs
11:58:29 <mmorrow> mrd: i'm not sure i follow. do you mean email is a gatewat to txt msgs? what if a phone can recieve txt and not email?
11:58:49 <mmorrow> mrd: (or do phone companies handle that transformation)
12:00:04 <mmorrow> mrd: ok, i think you mean the email will (usually) show up as a txt on a phone which doesn't have separate email and txt designations.
12:00:12 <mmorrow> ?
12:01:27 <mmorrow> whatever, i'll assume that all phones support receiving email and call it good
12:01:37 <mmorrow> problem solved!
12:01:55 <Botje> assume a spherical cow of uniform density ..
12:03:12 <mrd> for example, i just sent a text to mynumber@txt.att.net and it shows up as a text message on my phone
12:03:18 <mrd> sent an email*
12:03:43 <mrd> verizon is @vtext.com. i don't know the others.
12:03:47 <Centrinia> Botje, you can use the Banach-Tarski paradox to get two spherical cows of uniform density...
12:03:57 <Botje> :D
12:04:07 <Deewiant> only if you believe in the axiom of choice
12:04:15 <lament> Choose to believe!
12:04:23 <mmorrow> mrd: cool, so i'll assume that email is equiv to txt when that email addr is a phone.
12:04:24 <Centrinia> I choose to believe the Axiom of Choice.
12:04:26 <Baughn> Centrinia: That is not a paradox of any kind
12:04:37 <Baughn> Sadly, the axiom of choice does not work in this reality. :P
12:04:51 <Botje> and if we let their hair grow, we can comb them and find a bald spot!
12:04:52 <lament> sure it does
12:04:55 <mmorrow> Baugn: what reality is that?
12:05:15 <Baughn> lament: Not if spacetime is discrete, it doesn't
12:05:23 <byorgey> @seen Saizan
12:05:23 <lambdabot> Saizan is in #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 28m 5s ago.
12:05:33 <Baughn> @seen cal
12:05:33 <lambdabot> I haven't seen cal.
12:05:35 <Baughn> @seen cale
12:05:35 <lambdabot> cale is in #haskell-overflow, #ghc and #haskell. I last heard cale speak 16h 52m 36s ago.
12:05:47 <Baughn> Hm. It /is/ useful.
12:05:54 <Baughn> Pity we'll have to remove it. :?
12:05:55 <lament> Baughn: what does a of choice have to do with discreteness of spacetime? It just makes the banach-tarsky paradox inapplicable for other reasons
12:05:57 <hansfbaier> @seen las
12:05:57 <lambdabot> I haven't seen las.
12:06:10 <byorgey> Baughn: what? remove it!?
12:06:19 <Baughn> byorgey: It's got a memory leak. Or three.
12:06:22 <mmorrow> Baugn: oh, *that* world
12:06:23 <Baughn> If you want to keep it, fix it. :P
12:06:38 <mauke> (in the meantime, you can use preflex)
12:06:39 * byorgey clings, sobbing, to @seen
12:06:48 <byorgey> oh.
12:07:00 * byorgey straightens, somewhat embarrassed
12:07:23 * mmorrow pretends he didn't see
12:07:25 <byorgey> @seen nominolo
12:07:25 <lambdabot> nominolo is in #haskell-soc, #haskell.se, #ghc, #haskell-hac4 and #haskell. I don't know when nominolo last spoke.
12:07:25 <mauke> preflex: seen cale
12:07:25 <preflex>  cale was last seen on #haskell 16 hours, 54 minutes and 35 seconds ago, saying: greeg: This channel is about the Haskell programming language.
12:07:46 <mauke> preflex: seen nominolo
12:07:46 <preflex>  nominolo was last seen on #haskell 4 hours, 20 minutes and 17 seconds ago, saying: @seen swiert
12:08:02 <mmorrow> preflex: @seen preflex
12:08:10 <mmorrow> preflex: seen preflex
12:08:10 <preflex>  Sorry, I haven't seen preflex
12:08:18 <mmorrow> liar!
12:08:29 <mauke> it can't see itself
12:08:47 <Baughn> ..soon this channel will consist of nothing but people asking the bots [repeat "when they last asked the bots "]
12:08:58 <mrd> @seen Baughn
12:08:58 <lambdabot> Baughn is in #haskell. I last heard Baughn speak 11s ago.
12:09:23 <mrd> @unseen Baughn
12:09:23 <lambdabot> Baughn is in #haskell. I last heard Baughn speak 36s ago.
12:09:49 <Centrinia> @seen lambdabot
12:09:50 <lambdabot> Yes, I'm here. I'm in #arch-haskell, #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.cz, #haskell.dut, #haskell.de, #haskell.es, #haskell.
12:09:50 <lambdabot> fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #
12:09:50 <lambdabot> parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
12:10:03 <Centrinia> Wow.
12:10:30 <mmorrow> mauke: :)
12:13:14 <Centrinia> Why is lambdabot in #unicycling?
12:13:27 <Valodim> ...because she likes to unicycle?
12:13:44 <dons> shapr's doing.
12:13:48 <dons> long time unicycling fan
12:13:58 <mauke> @msg #haskell test
12:13:59 <lambdabot> Not enough privileges
12:14:01 <Centrinia> Oh.
12:14:01 <mauke> aww
12:14:11 <mrd> hmph, multicycling is the next big thing
12:14:21 <mrd> that's where haskell will shine
12:14:50 <Centrinia> I have a motorized quadcycle. :)
12:15:04 <Centrinia> I want to install Haskell in it.
12:15:33 <Valodim> how can you install haskell
12:15:40 <Valodim> it's a language
12:15:49 <chessguy> @go ghc haskell
12:15:49 <mrd> you can install Haskell in your brain
12:15:50 <lambdabot> http://www.haskell.org/ghc/
12:15:50 <lambdabot> Title: The Glasgow Haskell Compiler
12:15:59 <Centrinia> Sorry, a Haskell compiler.
12:16:32 <roconnor> @seen Binkley
12:16:32 <lambdabot> I haven't seen Binkley.
12:18:45 <mauke> @msg #haskell test
12:18:45 <lambdabot> test
12:19:49 <chessguy> @msg #haskell me too?
12:19:50 <lambdabot> Not enough privileges
12:19:53 * chessguy cries
12:19:54 <HunterXHunter> @msg #haskell i can has cheezbrgr
12:19:55 <lambdabot> Not enough privileges
12:20:08 <mauke> hack it yourself!
12:20:15 <HunterXHunter> @msg #haskell "i can has cheezbrgr"
12:20:15 <lambdabot> Not enough privileges
12:20:43 <sclv_> so I've got an interesting gripe with hxt -- the listArrow implementation doesn't distinguish between arrows guaranteed to return at most one, always one, or many results.
12:21:03 <dcoutts> Saizan: are you in #haskell-soc? byorgey is asking about projects
12:21:04 <sclv_> This makes it rather harder to think about complex parsers than it needs to be.
12:21:10 <sclv_> anyone else run into this?
12:22:31 <mauke> I don't know, lambdabot's security model just seems fundamentally broken
12:24:18 <roconnor> what is the security model
12:24:56 <mauke> certain nicks have admin privileges
12:25:16 <roconnor> why is that broken?
12:25:35 <mauke> because I just granted myself admin access
12:25:54 <Baughn> It doesn't check whether the nick is IDed?
12:25:59 <mauke> of course not
12:26:03 <Baughn> Yay.
12:26:24 <roconnor> oh you did it secretly.
12:27:10 <jadrian> is there some sort of && operator for boolean functions?
12:27:13 <jadrian> andf p q x = p x && q x
12:27:18 <dibblego> ?type (&&)
12:27:20 <lambdabot> Bool -> Bool -> Bool
12:27:35 <jadrian> no dibblego, for functions
12:27:41 <jadrian> as I defined it above...
12:27:48 <mauke> jadrian: liftM2 (&&)
12:27:50 <jadrian> I think that exists already... I remember using it
12:28:01 <dibblego> you want to lift
12:28:13 <jadrian> hmm yeap that would do...
12:28:22 <Deewiant> ?type liftM2 (&&) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
12:28:23 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
12:28:30 <jadrian> I was almost sure it was not the one I used though...
12:28:39 <mauke> :t And
12:28:41 <lambdabot> Not in scope: data constructor `And'
12:29:02 <jadrian> and is for lists of booleans
12:29:19 <dibblego> :type and
12:29:29 <dibblego> ?type all
12:29:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:29:34 <dibblego> ?type and
12:29:35 <lambdabot> [Bool] -> Bool
12:29:39 <mauke> :t All
12:29:40 <lambdabot> Bool -> All
12:30:15 <jadrian> mauke: what is that? All
12:30:22 <Deewiant> ?ty flip (all . flip id)
12:30:23 <ToRA> > getAny . mconcat . map Any $ [False, False, True]
12:30:24 <lambdabot> forall a. [a -> Bool] -> a -> Bool
12:30:25 <lambdabot>  True
12:30:44 <ToRA> jadrian: Any and All are ctrs in Data.Monoid for monoid instances of Bool
12:31:09 <jadrian> ctrs?
12:31:15 <ToRA> data constructors / types
12:31:21 <jadrian> oh
12:31:23 <Deewiant> > flip (all . flip id) [even, (> 20), (== 6) . (`mod` 7)] 34
12:31:24 <lambdabot>  True
12:31:36 <jadrian> I'll have to check Data.Monoid
12:33:02 <jadrian> oh wait I think instead of liftM2 && I was using some Arrows stuff
12:33:16 <jadrian> need to check it
12:40:17 <mwc> Hey, I patched haddock (latest darcs source) in order to convince it to compile against GHC 6.8.3. Here's the patch: http://pastebin.com/f30f8bcd5. This seem to be alright? I couldn't find the GHC api docs, so I'm sort of shooting in the dark
12:48:09 <dcoutts> mwc: email them to the haddock maintainer or add it in a ticket in the haddock trac
12:48:23 <mwc> dcoutts: I did that, along with an email asking if it's sane
12:48:29 <dcoutts> great
12:48:54 <mwc> dcoutts: any idea if it's sane?
12:51:15 <bos> mwc: it looks sane, but it won't help necessarily.
12:51:46 <bos> mwc: oh never mind, i see that you're trying to build haddock with ghc, not the other way around.
12:52:45 <dons> who's the haddock-2.0 maintainer?
12:52:52 <dcoutts> waern
12:53:39 <dcoutts> dons: btw, yes you should integrate mkcabal into cabal-install. There's an open ticket on the issue.
12:53:49 <dcoutts> cabal init or something
12:53:56 <dons> dcoutts: yes, i agree.
12:54:09 <dons> i'll just populate a default PackageDescription
12:54:18 <dons> we can write those out, can't we?
12:54:19 <bos> when does cabal profit ship?
12:54:27 <dcoutts> hah hah
12:54:29 <bos> wasn't that step 3?
12:54:34 <dons> i was impressed to see cabal upload integrated
12:54:47 <bos> yes, that was a good step.
12:54:48 <dons> cabal unrecord python
12:54:57 <mwc> so was there any progress on integrating haddock into the GHC tree?
12:54:57 <dons> cabal obliterate ruby
12:55:02 <bos> it does increase the pressure to be able to deprecate and remove packages, though :-)
12:55:04 <dcoutts> dons: I'm not sure actually. I think it might be somewhat partial.
12:55:18 <dcoutts> dons: but it should be completed so you can use it for that purpose
12:55:18 <dons> bos, yeah, we'd want to mark broken, then remove things from hackage.
12:55:29 <dcoutts> no, mark broken and never remove things
12:55:36 <dcoutts> it's a permanent persistent archive
12:55:41 <dcoutts> we just need to adjust the UI
12:55:41 <dons> well, hide from the default view
12:55:44 <dcoutts> right
12:55:48 <dons> immutableness is good though, i agree
12:55:58 <dcoutts> right, perfect http caching
12:56:50 <dcoutts> Lemmih: we should get on to doing that hackage-server prototype in HAppS :-)
12:56:59 <dcoutts> we've got lots of features we want to add
12:56:59 <fons> can anyone tell me what the heck does ribbonsPerLine mean in Text.PrettyPrint.HughesPJ
12:57:01 <fons> ?
12:57:15 <mwc> well, ribbons make things pretty
12:57:31 <dons> gwern: hey,what're all these new collections things? did you talk to Ashley?
12:57:40 <dons> sorry, Adrian
12:57:48 <mwc> so I can only conclude it's a measure of either a) how many ribbons would be required to make that linke of code look pretty, or b) how many ribbons in pretty-equivalent that line is ;)
12:57:55 <fons> > renderStyle style{lineLength=10, ribbonsPerLine=1} $ sep [text "foo" ,text "bar"]
12:57:59 <lambdabot>  "foo bar"
12:58:10 <fons> > renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep [text "foo" ,text "bar"]
12:58:11 <lambdabot>  "foo\nbar"
12:58:28 <fons> ok, somehow it affects the line width ...
12:59:06 <fons> can anyone provide a specific explanation of what ribbonsPerLine means?
13:00:02 <byorgey> fons: I can't explain it, all I know is that you must set it to 1 or else it does bizarre things =P
13:00:18 <fons> hahah, ok
13:00:30 <fons> byorgey: that's funny considering its default value is 1.5
13:00:36 <byorgey> if you set it to 1 then lineLength means what you think it should
13:00:40 <byorgey> fons: EXACTLY
13:01:09 <fons> byorgey: I'm not a native English speaker
13:01:35 <fons> but I expected "ribbons per line" to actually mean something in typesettin terminology
13:01:40 <fons> typesetting*
13:01:46 <byorgey> fons: well, it probably does
13:01:53 <byorgey> I just don't know what it is =)
13:02:58 <Baughn> I figured it might be columns per page or some such
13:03:06 <Baughn> But then I see code setting it to 1.5. >_<
13:03:32 <fons> I'll ask in haskell-cafe let's see if we can get a justified answer
13:04:03 <Baughn> renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep $ replicate 5 [text "foo",text "bar"]
13:04:06 <AtnNn> in the source, ribbon_width = round (fromIntegral line_length / ribbons_per_line)
13:04:06 <Baughn> > renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep $ replicate 5 [text "foo",text "bar"]
13:04:07 <lambdabot>  Couldn't match expected type `Doc' against inferred type `[a]'
13:04:19 <Baughn> > renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep $ concat $ replicate 5 [text "foo",text "bar"]
13:04:23 <lambdabot>  "foo\nbar\nfoo\nbar\nfoo\nbar\nfoo\nbar\nfoo\nbar"
13:04:53 <Baughn> > renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep $ concat $ map (text.show) [1..13]
13:04:54 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Doc'
13:05:09 <Baughn> > renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep $ map (text.show) [1..13]
13:05:10 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:05:22 <Baughn> > renderStyle style{lineLength=10, ribbonsPerLine=1} $ sep $ map (text.show) [1..13]
13:05:24 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:05:33 <Baughn> ..oh, wonderful
13:05:42 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=1} $ sep $ map (text.show) [1..13]
13:05:43 <lambdabot>  "1 2 3 4 5 6 7 8 9 10 11 12 13"
13:05:48 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=maxBound} $ sep $ map (text.show) [1..13]
13:05:48 <lambdabot>   add an instance declaration for (Bounded Float)
13:05:49 <lambdabot>     In the `ribbonsPerLine'...
13:05:55 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=1000} $ sep $ map (text.show) [1..13]
13:05:56 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:05:57 <Baughn> > renderStyle style{lineLength=10, ribbonsPerLine=100} $ sep $ map (text.show) [1..13]
13:05:59 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:06:20 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=1.1} $ sep $ map (text.show) [1..13]
13:06:21 <lambdabot>  "1 2 3 4 5 6 7 8 9 10 11 12 13"
13:06:26 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=1.5} $ sep $ map (text.show) [1..13]
13:06:27 <lambdabot>  "1 2 3 4 5 6 7 8 9 10 11 12 13"
13:06:32 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=2} $ sep $ map (text.show) [1..13]
13:06:33 <lambdabot>  "1 2 3 4 5 6 7 8 9 10 11 12 13"
13:06:40 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=2000} $ sep $ map (text.show) [1..13]
13:06:41 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:06:42 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=10} $ sep $ map (text.show) [1..13]
13:06:43 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:06:49 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=9.999} $ sep $ map (text.show) [1..13]
13:06:50 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:06:55 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=9} $ sep $ map (text.show) [1..13]
13:06:56 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:07:00 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=3} $ sep $ map (text.show) [1..13]
13:07:02 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:07:05 <mmorrow> > renderStyle style{lineLength=10, ribbonsPerLine=2} $ sep $ map (text.show) [1..13]
13:07:07 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:07:09 <mrd> err
13:07:13 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=10} $ sep $ map (text.show) [1..13]
13:07:14 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:07:17 <mrd> you can privmsg lambdabot too
13:07:20 <Baughn> > renderStyle style{lineLength=100, ribbonsPerLine=5} $ sep $ map (text.show) [1..13]
13:07:21 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13"
13:07:29 <olsner> wow, look at the wonderful \bot spam
13:07:42 <sclv_> oh, please, do go on. this is fascinating!
13:07:44 <Zao> @botsnack
13:07:44 <lambdabot> :)
13:07:45 <Apocalisp> > repeat "spam"
13:07:46 <lambdabot>  ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","spam...
13:07:49 * Heffalump growls at mmorrow and Baughn
13:08:01 <mmorrow> > fix ("spam":)
13:08:02 <lambdabot>  ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","spam...
13:08:37 <Baughn> You weren't using the channel, though..
13:08:40 <Baughn> This makes no sense. :/
13:08:49 <tchakkazulu> The smiley makes it evil ;)
13:09:01 <tchakkazulu> (the smiley at the end of "spam":) )
13:09:10 <mmorrow> totally, it's probably just a (unsafePerformIO randomIO) behind the scenes, just to mess with people
13:09:43 <mmorrow> @src renderStyle
13:09:44 <lambdabot> Source not found. Take a stress pill and think things over.
13:10:41 <sclv_> reading code is overrated. I much prefer guessing.
13:10:45 <jadrian> the monoids Any, All, Sum, Product... are they there just because they are obvious simple monoids
13:10:55 <jadrian> or do they have some practical use that I am missing
13:11:51 <HunterXHunter> ?src fix
13:11:51 <lambdabot> fix f = let x = f x in x
13:11:59 <HunterXHunter> ?src repeat
13:11:59 <lambdabot> repeat x = xs where xs = x : xs
13:12:00 <byorgey> jadrian: both =)
13:12:08 <sclv_> jadrian: the simple monoids become much more useful when used with the reader monoid.
13:12:08 <Heffalump> jadrian: I used Any the other day
13:12:16 <dons> gwern: i see adrian's mail now. it is simply not OK to upload his packages, under new names. cordering and avltree are there, the others aren't tested. this doesn't help the project.
13:12:23 <olsner> you could put a Sum in a Writer to produce the sum of logged items rather than the list of logged items, for example
13:12:27 <Heffalump> I was doing some optimisation and I wanted to flag when I'd actually applied a change
13:12:50 <jadrian> ah I see
13:12:51 <jadrian> ok
13:13:04 <Heffalump> So I put Any in the Writer monad. Made for nice idiomatic code, because I could when running it say something like "Any change"
13:13:16 <jadrian> yeap get it
13:13:29 <marcot> Good afternoon.
13:13:43 <mmorrow> ribbonsPerLine :: Float    -- ^ Ratio of ribbon length to line length
13:14:23 <Apocalisp> Can lambdabot store state?
13:14:30 <mmorrow> ribbon_length = round (fromIntegral line_length / ribbons_per_line)
13:15:36 <byorgey> hi marcot
13:15:49 <mmorrow> display mode page_width ribbon_width txt end doc
13:15:49 <mmorrow>   = case page_width - ribbon_width of { gap_width ->
13:15:49 <mmorrow>     case gap_width `quot` 2 of { shift ->
13:16:12 <Botje> mmorrow: please put that code on hpaste
13:16:27 <mmorrow> display is called with (ribbon_width := ribbon_length) from fullRender
13:16:29 <Botje> (unless that was all)
13:16:41 <Botje> is there a good reason you're not using lets?
13:16:46 <mmorrow> Botje: great idea
13:17:00 <mmorrow> that's not my code, it's in HughesPJ.hs
13:18:06 <mmorrow> no need to paste: http://haskell.org/ghc/docs/latest/html/libraries/pretty/src/Text-PrettyPrint-HughesPJ.html
13:19:10 <Botje> oh
13:19:19 <fons> mmorrow: thanks for checking it
13:19:23 <jadrian> hmm where is the source code for the Monad instance of ((->) a)
13:19:25 <mmorrow> :)
13:19:31 <Botje> jadrian: Control.Monad.Reader
13:19:35 <jadrian> it's not in the source code for Control Monad
13:19:37 <jadrian> oh
13:19:37 <fons> I had a look but I was too lazy to go throughout the whole code
13:19:39 <jadrian> thanks Botje
13:19:49 <Botje> mmorrow: oh.
13:20:26 <mmorrow> Botje: :)
13:20:42 <reilly> Does anybody know what I need to do to compile haddock with 6.8.3?
13:23:21 <Apocalisp> How do you lift a lambdabot command to the list monad? :)
13:23:30 <jadrian> Botje: sure? can't find it there
13:23:34 <Apocalisp> ?choice-add
13:23:34 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
13:23:39 <Botje> hmm
13:23:44 <jadrian> Botje: just the MonadReader instance
13:23:45 <Botje> Control.Monad.Instances, then?
13:23:50 <jadrian> that exists
13:23:51 <jadrian> ?
13:23:54 <jadrian> let me see
13:24:04 <fons> > text "foo foo" <+> nest 2 "bar bar"
13:24:04 <lambdabot> Terminated
13:24:19 <fons> > text "foo foo" <+> nest 2 "bar bar"
13:24:20 <lambdabot> Terminated
13:24:28 <fons> > text "foo foo"
13:24:28 <Botje> yeah, looks like it's there
13:24:29 <lambdabot>  foo foo
13:24:49 <jadrian> Botje: yeap... I don't remember ever seeing that
13:25:06 <fons> > text "foo foo" <+> nest 2 (text "bar bar")
13:25:06 <jadrian> Botje: then again haven't used haskell for a while so maybe Monad.Instances is new...
13:25:07 <lambdabot> Terminated
13:25:26 <fons> what the heck ...
13:25:33 <fons> > text "foo foo" <+> nest 2 (text "bar bar")
13:25:34 <lambdabot> Terminated
13:25:37 <fons> ???
13:25:57 <tromp> :t text
13:25:59 <lambdabot> String -> Doc
13:26:07 <fons> lambdabot: what's wrong with you
13:26:11 <fons> :P
13:26:16 <mehrheit> > 1
13:26:17 <lambdabot>  1
13:26:30 <tromp> > nest 2 (text "bar bar")
13:26:30 <fons> :t nest
13:26:31 <lambdabot>    bar bar
13:26:32 <lambdabot> Int -> Doc -> Doc
13:26:41 <mauke> @undefine
13:26:42 <lambdabot> Undefined.
13:26:49 <mauke> > text "foo foo" <+> nest 2 (text "bar bar")
13:26:49 <lambdabot> Terminated
13:26:53 <mauke> :t (<+>)
13:26:55 <lambdabot>     Ambiguous occurrence `<+>'
13:26:55 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/imports.h:59:0-33
13:26:55 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/imports.h:67:0-46
13:27:00 <fons> ok here we go
13:27:01 <mauke> gotcha
13:27:02 <tromp> :t <+>
13:27:03 <lambdabot> parse error on input `<+>'
13:27:27 <tromp> :t Text.PrettyPrint.HughesPJ.<+>
13:27:29 <lambdabot> parse error on input `Text.PrettyPrint.HughesPJ.<+>'
13:27:30 <fons> > text "foo foo" Text.PrettyPrint.HughesPJ.<+> nest 2 (text "bar bar")
13:27:34 <lambdabot>  foo foo bar bar
13:27:49 <tromp> :t (Text.PrettyPrint.HughesPJ.<+>)
13:27:51 <lambdabot> Doc -> Doc -> Doc
13:27:56 <fons> tromp you're missing the enclosing parenthesis
13:28:08 <fons> ok, now my question ...
13:28:27 <fons> what happened with the two nesting spaces?
13:28:49 <tromp> > text "foo foo" Text.PrettyPrint.HughesPJ.<+> nest 1 (text "bar bar")
13:28:51 <lambdabot>  foo foo bar bar
13:29:21 <fons> > text "foo foo" Text.PrettyPrint.HughesPJ.<+> nest 23 (text "bar bar")
13:29:22 <lambdabot>  foo foo bar bar
13:29:46 <fons> what happens with the trailing spaces?
13:29:59 <fons> (23 in last case)
13:30:02 <glguy> @seen bos
13:30:02 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 35m ago.
13:35:56 <twobitwork> so, if I'm in the IO monad, can I drop into a nested "do" to process a Maybe?
13:36:26 <mauke> no, but yes
13:36:46 <twobitwork> i.e. "do x <- someIO; z <- (do y <- someMaybe x; return y); putStrLn z"
13:36:58 <mauke> no
13:37:04 <Heffalump> twobitwork: no, but you could use let z = ...
13:37:21 <twobitwork> and have the do in there?
13:37:26 <Heffalump> yes
13:37:30 <mauke> you can have 'do' anywhere
13:37:34 <fons> > text "foo foo" Text.PrettyPrint.HughesPJ.<+> nest 23 (text "bar bar" $+$ text "bar bar")
13:37:35 <lambdabot>  foo foo bar bar
13:37:35 <lambdabot>         bar bar
13:37:40 <Heffalump> the point is that from the point of view of IO, the inner do is a pure value
13:37:51 <fons> > style
13:37:52 <twobitwork> right, I see
13:37:53 <lambdabot>   add an instance declaration for (Show Style)
13:38:05 <fons> > lineLength style
13:38:06 <lambdabot>  100
13:38:14 <twobitwork> :t style
13:38:16 <lambdabot> Style
13:38:54 <dons> sjanssen: ah, i think i've spotted the GLUT problem
13:38:58 <dons> thanks for hinting
13:39:51 <fons> > hang (text "foo foo") 5 (text "bar bar" $+$ text "bar bar")
13:39:52 <lambdabot>  foo foo
13:39:52 <lambdabot>      bar bar
13:39:52 <lambdabot>      bar bar
13:40:11 <yrlnry__> It seems like there ought to be some principle analogous to Curry-Howard that would allow one to show that fmap can be defined in terms of bind, but not vice versa.
13:40:18 <yrlnry__> Is there one?
13:41:46 <leoncamel> how can I convert a float to Integer ?
13:42:07 <leoncamel> > round 3.4
13:42:09 <lambdabot>  3
13:42:15 <leoncamel> OK. got it.
13:42:25 <Socrates`> > floor 2.2312
13:42:26 <lambdabot>  2
13:42:37 <yrlnry__> > truncate 3.4
13:42:39 <lambdabot>  3
13:42:41 <loop> any difference between floor and truncate?
13:42:43 <mauke> > truncate (-1.7)
13:42:44 <lambdabot>  -1
13:42:47 <mauke> > floor (-1.7)
13:42:49 <lambdabot>  -2
13:42:53 <loop> oh :-)
13:42:56 <Socrates`> @check (\x -> truncate x == floor x)
13:43:02 <lambdabot>  Falsifiable, after 2 tests: -1.5
13:43:21 <yrlnry__> truncate truncates the fraction part.  floor is the largest integer less than the argument.
13:43:21 <leoncamel> > round (-1.7)
13:43:22 <lambdabot>  -2
13:43:47 <leoncamel> any difference between floor and truncate ?
13:44:00 <mauke> ...
13:44:10 * wolverian wonders if leoncamel is feeling well
13:44:33 <monochrom> good afternoon
13:44:41 <yrlnry__> how does @check work?
13:45:02 <mauke> it calls quickcheck
13:45:13 <yrlnry__> how does it select the arguments?
13:45:17 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
13:45:20 <lambdabot> http://tinyurl.com/6nf83l
13:45:27 <mauke> magic (typeclasses)
13:45:55 <Socrates`> "A large number of randomly generated cases"
13:45:58 <leoncamel> oh.. got it ..:)
13:46:25 <yrlnry__> Oh, I guess in this case we could expect it to falsify the result after two random selections.
13:46:29 <yrlnry__> Okay.
13:48:02 <mmorrow> whoa:
13:48:06 <mmorrow> "" 	
13:48:06 <mmorrow> Here are 2 excellent sparklines from Robert Sedgewick, Algorithms in C (1998).
13:48:06 <mmorrow> Sparklines and sparkline-like graphs can also move within complex multivariate spaces, as in these 9-step sequential results (reading down the columns) in merge-sorting 5 different types of input files. Four variables and 18,000 numbers are depicted in these small multiples.
13:48:06 <mmorrow> Here are the results of 7 sequential passes to sort a 200 element file in bottom-up merge sort:
13:48:11 <mmorrow> oops
13:48:21 <mmorrow> "" Here are the results of 7 sequential passes to sort a 200 element file in bottom-up merge sort: "
13:48:26 <mmorrow> http://www.edwardtufte.com/bboard/images/00027o-2540.jpg
13:49:05 <mmorrow> pretty powerful image
13:49:08 <Socrates`> Thats a pretty picture
13:49:14 <luite> nice visualization
13:50:09 <mmorrow> original context: http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR&topic_id=1
13:50:10 <lambdabot> Title: Ask E.T.: Sparklines: theory and practice, http://tinyurl.com/6bbkw
13:50:41 <bos> woot: http://accu.org/index.php/accu_branches/accu_usa/upcoming
13:50:43 <lambdabot> Title: ACCU :: Professionalism in Programming
13:50:52 <bos> glguy: what's up?
13:55:08 <Maciej_> Is there a module like Language.Haskell.Parser, providing functions to parse components of a Haskell module?
13:55:41 <Maciej_> e.g. parseHSDecl, ...
13:58:33 <mmorrow> Maciej_: take the Decl/Exp/whatever as String input, wrap it appropriately (e.g. \s -> concat ["module Main where","f = "++s]), parse that with parseHsModule, get the HsModule back, then pick it apart by pattern matching to get at the pieces your interested in and return those.
13:59:10 <mmorrow> :t HsDecl
13:59:12 <lambdabot> Not in scope: data constructor `HsDecl'
13:59:14 <mmorrow> aww
14:00:15 <Maciej_> mmorrow: I'd like to avoid that overhead if possible.
14:00:26 <mmorrow> Maciej_: also, use Language.Haskell.Exts
14:00:40 <roconnor> > 0 < 2^2^32
14:00:54 <mauke>  Yes
14:00:55 <lambdabot> Terminated
14:01:16 <roconnor> @type Yes
14:01:18 <lambdabot> Not in scope: data constructor `Yes'
14:01:52 <Maciej_> mmorrow: You mean Language.Haskell.Extension?
14:02:50 <Maciej_> mmorrow: Oh, I see, it's a different package.
14:04:03 <dons> HWN, http://www.reddit.com/info/6nyrq/comyments/
14:04:04 <dons> byorgey++
14:04:18 <bos> @seen glguy
14:04:18 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
14:04:26 <bos> lambdabot lies!
14:04:54 <mauke> there is no y in comments
14:05:11 <byorgey> there is a y in comyments, though
14:05:20 <u_quark> I there a way to do event-based in ghc like in erlang ?
14:05:20 * dolio wonders if he got gwern in trouble.
14:05:22 <mauke> byorygey
14:05:39 <glguy> bos: I was wondering if that bootstraping method Igloo mentioned for GHC 6.8.3 + haddock 2 was feasible for FEdora
14:05:58 <glguy> or if the srpms needed to be able to build without such special restrictions..
14:06:29 <leoncamel> how can I write a big number in haskell. I mean, something like "12971237918273L" in python
14:06:50 <dolio> > 12971237918273
14:06:51 <lambdabot>  12971237918273
14:06:59 <byorgey> > 39^58
14:07:00 <lambdabot>  1913142006512828705226913241501822969169782476196489889739409270581324730830...
14:07:08 <noecksit> hello, there is something i have a hard time understanding as far as Applicative goes
14:07:25 <byorgey> leoncamel: Haskell has an arbitrary-precision Integer type
14:07:31 <noecksit> what is the difference between f (a->b) and f a -> f b?
14:07:57 <byorgey> noecksit: the first is some kind of functor (think container) which contains functions of type a -> b
14:08:00 <dolio> f (a -> b) is a fancy function from as to bs, f a -> f b is a function from fancy as to fancy bs.
14:08:16 <byorgey> the second is a function which takes a container of as and gives you a container of bs.
14:08:28 <leoncamel> but, this can't work in ghci :  [ n | n <-[1..600851475143], is_prime n ]
14:08:28 <b_jonas> unless the -> is in an expression, for a lambda or case
14:08:30 <bos> glguy: i didn't see what igloo mentioned, but i've got haddock 0.9 all ready to ship again.
14:08:43 <glguy> Oh, cool
14:08:51 <byorgey> leoncamel: that should work fine.  what is the type of is_prime?
14:08:51 <mm_freak> leoncamel: it can, it just takes a lot of time
14:09:00 <glguy> His reply on that ticket was t build 6.8.3 without docs, build haddock, and then build ghc 6.8.3 with docs
14:09:02 <bos> glguy: so once i get that package into the fedora tree, i have a 6.8.3 package ready to build.
14:09:11 <glguy> bos: sounds good :)
14:09:13 <bos> yeah, that's unworkable.
14:09:15 <leoncamel> byorgey, is_prime :: Int -> Bool
14:09:21 <mauke> well, duh
14:09:24 <leoncamel> byorgey, is_prime n = not (any (\x -> n `mod` x == 0) [2..n-1])
14:09:28 <byorgey> leoncamel: ok, that's why, it should be  Integer -> Bool
14:09:31 <mm_freak> leoncamel: should work fineâ€¦  just try with a smaller range
14:09:33 <noecksit> so i guess f (a -> b) is a container of a "function" not a value?
14:09:43 <mauke> functions are values
14:09:45 <chessguy> @pl \x -> n `mod` x == 0
14:09:45 <lambdabot> (0 ==) . (n `mod`)
14:09:55 <leoncamel> byorgey, OH ? Int is different from Integer ?
14:09:58 <byorgey> leoncamel: Integer is the arbitrary-precision integer type,  Int is machine-sized integers (like the 'int' type in C)
14:10:01 <bos> glguy: it will probably be some time next week before 6.8.3 gets pushed out, but i'll blog when there are downloadable packages up to test.
14:10:09 <leoncamel> byorgey, OK. thanks.
14:10:20 <mauke> is marc weber on irc?
14:10:20 <glguy> bos: URL to blog?
14:10:34 <noecksit> well, it contains a mapping rather than an explicit value
14:10:38 <byorgey> leoncamel: the only reason to ever use Int is if you need your program to run particularly fast
14:10:43 <byorgey> IMO
14:11:08 <mm_freak> byorgey: Integer is usually not much slower than Int, if the values are small
14:11:18 <mm_freak> i guess, short integer code is used for them
14:11:26 <leoncamel> byorgey, Int is a 32bits integer ?
14:11:30 <byorgey> ok, well, then there's even less of a reason to use Int
14:11:44 <mauke> leoncamel: in ghc on 32 bit platforms, yes
14:11:47 <byorgey> leoncamel: it depends on the platform, but probably 32 bits is the most common
14:11:48 <rwbarton> mm_freak: true, but the compiler can sometimes unbox Ints
14:12:00 <leoncamel> OK. thanks, you all :)
14:12:04 <mm_freak> leoncamel: no, Int is "some integer type with a range of at least [-(2^29) .. 2^29 - 1]"
14:12:28 <byorgey> right, that's what is specified in the standard
14:12:37 <mm_freak> leoncamel: usually of machine word size, so 32 bits for 32 bits architectures, 64 bits for 64 bits architectures
14:13:04 <Baughn> There's also Word32, which might be handy if you need exactly 32 bits
14:13:13 <leoncamel> mm_freak, OK..
14:13:18 <mm_freak> yeah, or Int32 for the signed version
14:13:52 <Baughn> Portable code would use those. Unless your desire is just "a small integer". ;)
14:14:27 <byorgey> leoncamel's stated desire is for large integers. =)
14:14:30 <Baughn> Of course Int32 won't be as fast as Int if Int happens to be less than 32 bits.. but then, if you're after speed you're probably using GHC anyway
14:14:36 <nominolo> byorgey: pong
14:14:37 <Baughn> Well, Int1024 then
14:14:47 <byorgey> hi nominolo
14:15:00 <mm_freak> Baughn: i doubt that Int1024 is much faster than Integer
14:15:09 <mm_freak> at least as long as GHC still uses GMP
14:15:18 <byorgey> nominolo: I was going to ask if you could give me a few sentences describing your progress in your GSoC project, for inclusion in the HWN
14:15:23 <byorgey> but it's too late now ;)
14:15:29 <leoncamel> BTW, Int1024 is a build-in type in haskell ? something like Int ?
14:15:29 <byorgey> next wekk
14:15:32 <byorgey> *week
14:15:39 <nominolo> byorgey: k
14:15:56 <Baughn> leoncamel: Ah, no. I made it up.
14:16:04 <mm_freak> leoncamel: no, it's not even in the base libsâ€¦  you'll need a third-party package for it
14:16:17 <Baughn> leoncamel: You can make up your own, if you like - mine is based on Integer, for obvious reasons
14:16:17 <leoncamel> Baughn, ok
14:16:24 <mm_freak> actually i don't even know Int1024, i know Word1024
14:18:11 <dolio> Int64 is the biggest in the standard libraries, I think.
14:18:18 <Maciej_> What does "\&" mean in string literals?
14:18:24 <dolio> Word1024 and such are in some crypto library.
14:18:56 <hpaste>  morrow pasted "HsParse" at http://hpaste.org/8402
14:19:06 <Maciej_> It seems to have no effect.
14:19:33 <hpaste>  morrow annotated "HsParse" with "{-# LANGUAGE UndecidableInstances #-} isn't necessary (forgot to delete)" at http://hpaste.org/8402#a1
14:19:53 <byorgey> Maciej_: nothing special, as far as I know.
14:19:57 <mmorrow> Maciej_: http://hpaste.org/8402
14:20:21 <stepcut> is there a LANGUAGE extension for unboxed values, like (# 1#, 2# #) ? Or just -fglasgow-exts ?
14:20:43 <dolio> MagicHash for foo#
14:20:50 <dolio> UnboxedTuples for (# ... #)
14:20:53 <stepcut> ah
14:21:03 <stepcut> I tried UnboxedTuples, but MagicHash did not mean anything to me
14:21:08 <shapr> @yow !
14:21:09 <lambdabot> Couldn't find fortune file
14:21:11 <shapr> aww
14:21:16 <stepcut> @shapr
14:21:23 <shapr> What?
14:21:28 * lambdabot beats up
14:21:31 <stepcut> :(
14:21:59 <Maciej_> mmorrow: Wow, thanks a lot!
14:23:07 <mmorrow> Maciej_: heh noprob (already had it written, just had to extract it from a jumbled mess of another module) :)
14:25:35 <shapr> byorgey: I like the Community News section.
14:25:57 <byorgey> shapr: thanks! =)
14:26:40 <monochrom> Woah? Haskell Hourly News strikes again?  <duck>
14:27:02 <shapr> byorgey: Nice issue!
14:27:42 <dons> yeah, the community news is a great improvement
14:27:43 <dolio> That doesn't begin with a W.
14:27:48 <shapr> Is there any general solution for reading binary file formats with Haskell?
14:28:00 <Baughn> Several. Parsec, Binary if you're lucky..
14:28:01 <dons> Data.Binary is fairly general
14:28:12 <shapr> dons: Does it generalize to parsing binary network protocols as well?
14:28:19 <Baughn> Yes
14:28:20 <dons> yeah
14:28:23 <shapr> cool!
14:28:24 <dons> that was the goal
14:28:50 <dons> you'll be using Put and Get directly, rather than the Binary class
14:28:52 <Baughn> Binary does assume your data stream can be parsed without lookahead, but it's very good at that, and every binary format I've seen can be
14:28:53 <dons> unless you're sneaky
14:29:01 <dons> network protocols in particular
14:29:02 <hpaste>  toyvo pasted "countables" at http://hpaste.org/8403
14:29:13 <shapr> Didn't the ParsecT project from the previous SoC have the goal to do Parsec on top of Binary or Bytestring?
14:29:42 <shapr> I'm just curious whether I can do something like a Parsec parser for a file/protocol.
14:30:17 <shapr> dons, Baughn: thanks!
14:30:18 <Baughn> Oh, you can parse arbitrary thingies with Parsec as it is. Bytes work fine.
14:30:18 <Botje> shapr: parsec 3 Just Works (tm) with Bytestrings
14:30:24 <shapr> yay!
14:30:27 <Botje> i've used it for my compiler
14:30:29 <Baughn> It'll just be /lists/ of bytes, which isn't as efficient as bytestring
14:30:30 <shapr> Awesome!
14:30:32 <Botje> wasn't necessary, but still fun
14:30:59 <Baughn> And parsec will never (right, probably ^_^) be as fast as Binary in the cases where Binary works at all. Though there's no fundamental reason it can't be, Binary gets more optimization.
14:31:12 <leoncamel> how can I convert a Integer into Float ?
14:31:21 <Baughn> :t fromInteger
14:31:22 <lambdabot> forall a. (Num a) => Integer -> a
14:31:29 <monochrom> Hahaha, nice quote from ddarius about Haskell and OO. :)
14:31:48 <monochrom> @unseen ddarius
14:31:48 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 4h 8m 26s ago, and .
14:31:54 <roconnor> @quote ddarius
14:31:54 <lambdabot> ddarius says: You need to spawn children to wash your dishes in parallel.
14:31:55 <leoncamel> Baughn, OK. thanks
14:31:57 <Botje> heh
14:32:04 <roconnor> @quote ddarius OO
14:32:04 <lambdabot> ddarius says: Here's the short guide to Haskell for OO programmers: Haskell isn't at all an OO language.
14:32:08 <Botje> @unlaunch missiles
14:32:08 <lambdabot> Unknown command, try @list
14:32:13 <monochrom> Yes, that one.
14:32:28 <Botje> there should be something in response to @unlaunch :)
14:32:36 <roconnor> I've glanced through Oleg's paper
14:32:40 <roconnor> Haskell looks OO to me.
14:32:43 <Baughn> Botje: Why?
14:33:04 <Botje> @unlaunch missiles? :)
14:33:05 <lambdabot> Unknown command, try @list
14:33:05 <Baughn> Botje: If it worked, it'd work by discarding the current state of the world and going back to an earlier one. No response would be expected, seen, or needed. ^_^
14:33:07 <OceanSpray> roconnor, explain plz
14:33:08 <lament> roconnor: what are you smoking... oh, Oleg's paper :)
14:33:14 <monochrom> "I'm sorry I launched the missiles. I take them back." ?  :)
14:33:15 <lament> that's some good shit man
14:33:36 <Botje> heh
14:33:36 <roconnor> OceanSpray: an object is just an HList
14:33:47 <Botje> drug users pass around needles, haskell users pass around Oleg papers
14:33:49 <OceanSpray> what's a HList?
14:33:52 <roconnor> and a class is function that creates objects
14:33:59 <roconnor> @what HList
14:34:00 <lambdabot> http://homepages.cwi.nl/~ralf/HList
14:35:16 <roconnor> He has a nice trick using mfix to pass the reference to the allocated object back to itself.
14:35:28 <monochrom> @quote Botje drug users pass around needles, haskell users pass around Oleg papers
14:35:28 <lambdabot> No quotes match. There are some things that I just don't know.
14:35:34 <monochrom> @remember Botje drug users pass around needles, haskell users pass around Oleg papers
14:35:35 <lambdabot> Okay.
14:35:36 <roconnor> essentionally new = mfix
14:35:41 <Botje> :)
14:35:47 * roconnor needs his mfix
14:35:56 * Botje giggles
14:36:09 <roconnor> aaaaaaaaaahhhhhhhhhhhhhhhhh......
14:36:14 <Botje> mfix is too hard for me atm
14:36:20 <toyvo> Interesting. Oleg is amazing :)
14:36:20 <Botje> i'll need a few more stepstones before I get to it
14:36:32 <dibblego> @type mfix
14:36:34 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:36:50 <Botje> euch
14:36:54 <Botje> that's a scary type
14:36:59 <roconnor> yep
14:37:01 <Botje> it's not much better than Cont, actually
14:37:04 <Botje> @type runCont
14:37:06 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
14:37:07 <dibblego> it's obvious, new = mfix! (after you've said it of course)
14:37:29 <toyvo> hmm.. a mfix - a fixpoint involved here?
14:37:32 <roconnor> a class is a function from self to the new object
14:37:45 <dibblego> did Oleg show that new = nfix?
14:37:46 <dibblego> *mfix
14:37:47 <roconnor> then "new class" returns a new object
14:37:55 <u_quark> I there a way to wait for some network input and a MVar at the same time ?
14:38:02 <roconnor> http://homepages.cwi.nl/~ralf/OOHaskell/
14:38:02 <lambdabot> Title: Haskell's overlooked object system
14:38:38 <roconnor> -- Construct objects
14:38:38 <roconnor> s1 <- mfix (rectangle (10::Int) (20::Int) 5 6)
14:38:40 <roconnor> s2 <- mfix (circle (15::Int) 25 8)
14:38:41 <Botje> u_quark: assuming they contain the same type, have a different thread read from them and write to a Control.Concurrent.Chan ?
14:38:59 <wbaety> orElse, maybe? :)
14:39:00 <roconnor> he doesn't actually define new to be mfix, but I would.
14:39:57 <dibblego> ?index mfix
14:39:58 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:40:09 <monochrom> There is much hidden fixed points in OOP.
14:40:14 <u_quark> not necessarily
14:41:01 <roconnor> circle newx newy newradius self
14:41:01 <roconnor>  = do
14:41:03 <roconnor>       super <- shape newx newy self
14:41:03 <roconnor>       ...
14:41:03 <roconnor>       returnIO ... .*. super
14:41:05 <dons> really cool Luke Palmer got a haskell job.
14:41:21 <toyvo> Thanks, diblego, I didn't know about "? index" comand, this helps
14:41:30 <dons> luqui++
14:41:56 <thetallguy> where?
14:42:08 <roconnor> It took me hours to understand mfix last year
14:42:09 <monochrom> For example, suppose you write like "class X { public X method1(X x1) ...}". That already involves a fixed point, since class members and the class itself are defined by each other.
14:43:08 <toyvo> let mfix f = mfix f >>= f
14:43:12 <toyvo> can I define it like this?
14:43:23 <monochrom> likely unproductive.
14:43:42 <monochrom> usually you define mfix tailor-made to the concrete monad.
14:43:56 <monochrom> some monads cannot have mfix.
14:44:08 <Botje> we call these monads "recovering monads"
14:44:15 <Botje> or "cold turkey monads"
14:44:53 <Cale> The intention is that mfix f will only have the effects of the result of f occur once.
14:44:54 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:45:07 <toyvo> I just did mfix (\x -> [x]) to get stack overflow. Is [] cold turkey?
14:45:19 <monochrom> Anyway, some of the fixed-point-ness of OOP is exposed in OCaml.
14:45:47 <Cale> Botje: I've never heard that term :)
14:46:07 <roconnor> toyvo: \x -> [x] is too strict
14:46:09 <toyvo> thanks, monochrom, I'll look it up. So far my OCaml is rudimentary
14:46:10 <rwbarton> mfix (\x -> [x]
14:46:17 <rwbarton> is mfix return
14:46:20 <rwbarton> which is like fix id
14:46:25 <Botje> Cale: 10 minutes ago we were comparing haskell to a drug
14:46:35 <mmorrow> :t mfix return
14:46:37 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
14:46:43 <Botje> so yes, i'm not making much sense if you didn't read that
14:46:44 <mmorrow> :t return . fix $ id
14:46:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
14:46:47 * wbaety thinks he'll subtitle that Ralf&Oleg paper as "LAMBDA: The Ultimate Object"
14:46:50 <Botje> (or, really, any time in particular)
14:46:54 <u_quark> Botje: when listening from the network for some replay, the thread may be notified that something occurred ... how can I implement that ?
14:47:01 <roconnor> > mfix (if x > 2 then [] else [x+1..2])
14:47:03 <Cale> map take 5 $ mfix (\x -> [1:x, 2:x])
14:47:04 <lambdabot>  Couldn't match expected type `a -> m a'
14:47:05 <Cale> > map take 5 $ mfix (\x -> [1:x, 2:x])
14:47:06 <lambdabot>   add an instance declaration for (Num ([[t]] -> Int))
14:47:20 <Cale> > map (take 5) $ mfix (\x -> [1:x, 2:x])
14:47:21 <lambdabot>  [[1,1,1,1,1],[2,2,2,2,2]]
14:47:22 <roconnor> > mfix (\x -> if x > 2 then [] else [x+1..2])
14:47:23 <lambdabot>  Exception: stack overflow
14:47:35 <roconnor> bah
14:47:37 <roconnor> listen to Cale
14:48:40 <Botje> u_quark: i wouldn't know, I've used the Chan solution but also got stuck on interrupting blocking threads
14:48:54 <Botje> sorry, perhaps someone else knows an answer and is willing to share :)
14:49:05 <toyvo> Cale: thanks! trying to understand that example...
14:49:55 <u_quark> exactly: how can i interrupt a thread with a signal like POSIX kill ?
14:50:03 <roconnor> @src mfix []
14:50:03 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:50:14 <roconnor> @src [] mfix
14:50:14 <lambdabot> mfix f = case fix (f . head) of
14:50:14 <lambdabot>            []    -> []
14:50:14 <lambdabot>            (x:_) -> x : mfix (tail . f)
14:50:37 <mmorrow> u_quark: (just a thought) you could have the waiting thread be waiting on a (Chan (Chan msg)), so notification then become receiving the Chan msg to begin communicating on..
14:51:03 <Cale> > map ($ 5) $ mfix (\f -> [\n -> if n == 0 then 1 else n * f (n-1), \n -> if n < 2 then n else f (n-1) + f (n-2)])
14:51:04 * roconnor doesn't know what mfix for lists is supposed to do
14:51:05 <lambdabot>  [120,5]
14:51:22 <mauke> @let loeb x = let y = fmap ($ y) x in y
14:51:23 <lambdabot> Defined.
14:51:25 <mauke> :t loeb
14:51:27 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
14:51:35 <mauke> hmm
14:51:39 <Cale> That's a more interesting operation.
14:51:44 <mmorrow> > mfix (:[])
14:51:45 <lambdabot>  [Exception: stack overflow
14:51:57 <roconnor> I figured you get [[1...], [2,1...],[2,2,1111] ...]
14:51:58 <mauke> @undefine
14:51:59 <lambdabot> Undefined.
14:52:13 <Cale> > loeb [const 1, const 2, (!! 0) + (!! 1), (!! 2) + (!! 2)]
14:52:14 <lambdabot>   Not in scope: `loeb'
14:52:33 <Cale> @let loeb x = let y = fmap ($ y) x in y
14:52:34 <lambdabot> Defined.
14:52:37 <Cale> > loeb [const 1, const 2, (!! 0) + (!! 1), (!! 2) + (!! 2)]
14:52:37 <lambdabot>   add an instance declaration for (Num ([a] -> a))
14:52:40 <Cale> oh
14:52:43 <mauke> that's not loeb
14:52:45 <mmorrow> > mfix ((0:) . (:[]))
14:52:46 <lambdabot>  [0,Exception: stack overflow
14:52:48 <Cale> @undefined
14:52:48 <mauke> look at the type
14:52:49 <lambdabot> Undefined.
14:52:51 <Cale> yeah
14:52:57 <dons> dcoutts: how much of hackage are you able to build automatically?
14:53:07 <u_quark> mmorrow: events don't came with a specific order
14:53:07 <Cale> @let loeb x = fmap (\a -> a (loeb x)) x
14:53:08 <lambdabot> Defined.
14:53:11 <Cale> > loeb [const 1, const 2, (!! 0) + (!! 1), (!! 2) + (!! 2)]
14:53:12 <lambdabot>   add an instance declaration for (Num ([a] -> a))
14:53:15 <Cale> huh
14:53:17 <Cale> @undefine
14:53:18 <lambdabot> Undefined.
14:53:44 <Saizan> don't you've to liftM2 those (+) ?
14:53:55 <mauke> wait
14:54:04 <mauke> d'oh
14:54:18 <mmorrow> u_quark: hmm, you could have a bunch of threads waiting on a single Chan and they'll take em as they come, dispatch them, return to waiting...
14:54:29 <Cale> @let loeb x = fmap ($ loeb x) x
14:54:30 <lambdabot> Defined.
14:54:34 <dcoutts> dons: iirc, about 560 in my install plan, and about 150 failures
14:54:41 <mmorrow> u_quark: but i've completely lost sight of what you're trying to do, so...
14:54:49 <dcoutts> dons: so I had to exclude ~20 to make a valid install plan
14:54:49 <mauke> looks like my original version was correct :/
14:54:50 <dons> ok. i get 168 here, atm, including wx and its children
14:54:53 <Cale> > loeb [const 1, const 2, liftM2 (+) (!! 0) (!! 1), liftM2 (+) (!! 2) (!! 2)]
14:54:54 <lambdabot>  [1,2,3,6]
14:54:55 <dons> so about 150 assuming i can get wx working
14:55:06 <ddarius> :t loeb
14:55:08 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
14:55:11 <Cale> yeah, the problem was the type of the list :)
14:55:15 <dcoutts> dons: you're using arch to build right? not cabal-install, so we cannot compare build logs.
14:55:16 <mauke> > let loeb x = {let y = fmap ($ y) x in y} in loeb [const 1, const 2, liftM2 (+) (!! 0) (!! 1), liftM2 (+) (!! 2) (!! 2)]
14:55:17 <lambdabot>  Parse error at "{let" (column 14)
14:55:25 <dons> dcoutts: indeed.
14:55:37 <dons> i cabal update, unpack the index, and recurse over it running cabal2arch
14:55:41 <dons> then using the native package manager
14:55:51 <ddarius> mauke: The {}'s aren't necessary and they are in the wrong place
14:55:52 <dons> so with the native packager i can get 168 failures, atm
14:56:00 <dcoutts> dons: so you're generating those packages fully automatically atm then
14:56:03 <dons> yes.
14:56:04 <mauke> > let loeb x = let {y = fmap ($ y) x} in y in loeb [const 1, const 2, liftM2 (+) (!! 0) (!! 1), liftM2 (+) (!! 2) (!! 2)]
14:56:05 <lambdabot>  [1,2,3,6]
14:56:06 <u_quark> mmorrow: it's ok :)
14:56:12 <Cale> The loeb function ought to be in the libraries somewhere.
14:56:17 <mauke> yay, I'm not entirely stupid
14:56:22 <dcoutts> dons: great. We still have to do some manual tweaking. I was just talking to kolmodin about that.
14:56:25 <dons> and tuning the tool based on looking at the logs, until more work automatically
14:56:33 <dcoutts> dons: right.
14:56:33 <dons> yeah, it is totally doable
14:56:44 <mmorrow> loeb (repeat (concat . (0:)))
14:56:45 <ddarius> Cale: I'm sure newbies will have fun figuring out what the heck it is for.
14:56:46 <mmorrow> > loeb (repeat (concat . (0:)))
14:56:47 <lambdabot>   add an instance declaration for (Num [a])
14:56:50 <dons> code.haskell.org/arc/x86_64 is a fully automated overlay
14:56:55 <dons> code.haskell.org/arch/
14:56:58 <mmorrow> > loeb (repeat (concat . ([0]:)))
14:56:59 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:57:04 <dcoutts> dons: does arch's build tool do parallel builds?
14:57:10 <dons> no, sadly.
14:57:14 <dons> there is a global database lock
14:57:17 <dcoutts> dons: I've been thinking of making cabal-install do that
14:57:27 <Cale> We could call it something enterprisey like 'spreadsheet'
14:57:29 <dons> that'd be nice
14:57:33 <dcoutts> dons: and generating a full log for each package separately
14:57:36 <dons> presumably i could in fact build in parallel
14:57:40 <dons> and only register sequentially
14:57:47 <dons> actually, ghc-pkg has a race   condition there
14:57:57 <dibblego> i like maths to
14:58:00 <dcoutts> dons: yes
14:58:00 <dons> you can write two packages simultaneously, corruping the package.conf
14:58:00 <mauke> Cale: http://dis.4chan.org/read/prog/1213796871/1-40
14:58:05 <lambdabot> Title: 4chan BBS - The EXPERT /prog/ Flame Thread
14:58:19 <dcoutts> dons: well, no. but you can loose one of the two
14:58:53 <dcoutts> dons: ie no corruption, but it reads, modifies and writes, so it could easily loose one of the updates
14:59:12 <dibblego> > 8+8
14:59:13 <lambdabot>  16
14:59:28 <dcoutts> dons: using a dir of packages would work better there
14:59:47 <dons> Igloo: the linux/ghc generic binary has a glibc 2.7 dependency that is undocumented
14:59:55 <dons> we hit it running on a debian/xen thingy
15:00:12 <dibblego> > 4+5-9
15:00:13 <lambdabot>  0
15:00:24 <gubagem> > 0-9
15:00:25 <lambdabot>  -9
15:00:32 <mmorrow> > -9
15:00:32 <gubagem> > (-9)
15:00:34 <lambdabot>  -9
15:00:35 <lambdabot>  -9
15:00:41 <gubagem> oh look a way to save a keystrike
15:00:45 <mmorrow> > (*1) - 9
15:00:45 <lambdabot>   add an instance declaration for (Num (a -> a))
15:00:52 <mauke> > 4:+5
15:00:54 <lambdabot>  4.0 :+ 5.0
15:00:55 <dibblego> >8+9-3
15:01:07 <twobitsprite> is it just me, or is it hard to deal with nested monads? like IO (Maybe a)
15:01:10 <mmorrow> 100^100
15:01:10 <dibblego> > 8+9-3
15:01:10 <gubagem> > (* 1) - 9
15:01:12 <lambdabot>  14
15:01:12 <lambdabot>   add an instance declaration for (Num (a -> a))
15:01:12 <mmorrow> > 100^100
15:01:13 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
15:01:21 <mmorrow> > length . show $ 100^100
15:01:23 <lambdabot>  201
15:01:24 <mauke> twobitsprite: it's you, how are you gentlemen, etc
15:01:35 <monochrom> It was not hard for me.
15:01:50 <twobitsprite> mauke, eh?
15:02:04 <dibblego> > 48+59
15:02:05 <lambdabot>  107
15:02:07 <Baughn> Cale: So I've run LB through a bunch of simulated irc data, and it's stable at 10m. It seems that without Seen or the bad parts of Log, it's not leaking.
15:02:13 <Saizan> twobitsprite: it might be nicer with MaybeT IO
15:02:18 <Cale> mauke: you have no chance to survive make your time?
15:02:28 <mauke> ha ha ha
15:02:39 <Cale> Baughn: yeah, I ended up disabling the seen plugin in mbot for that reason
15:02:44 <dibblego> > 45+62-1
15:02:46 <lambdabot>  106
15:02:46 <twobitsprite> Saizan, well... the function I have at hand returns IO (Maybe a)
15:02:49 <Cale> Baughn: but it seems that people use it a lot here
15:02:56 <dcoutts> Baughn: well done!
15:03:01 <Cale> Baughn: It would be nice if someone were to rewrite it :)
15:03:05 <mauke> they should just switch to preflex
15:03:07 <Baughn> Cale: As mauke pointed out, preflex already has it
15:03:14 <dcoutts> seen is pretty useful
15:03:24 <Baughn> As for the log bit, it was storing data that it proceeded to never use
15:03:33 <dibblego> > 49+99-99
15:03:35 <lambdabot>  49
15:03:59 <gubagem> > pi
15:04:00 <lambdabot>  3.141592653589793
15:04:20 <mmorrow> > fromInteger . read . reverse . show $ 9000000001
15:04:21 <lambdabot>  1000000009
15:04:24 <gubagem> my girlfriend cant do algebra, but she can memorize a decent chunk of pi
15:04:27 <dibblego> @check \x -> 49+x-x == 49
15:04:29 <lambdabot>  OK, passed 500 tests.
15:04:29 <mmorrow> > read . reverse . show $ 9000000001
15:04:31 <lambdabot>  Exception: Prelude.read: no parse
15:04:45 <mauke> > pie
15:04:45 <ddarius> gubagem: So?
15:04:46 <lambdabot>  I LIEK PIE
15:04:56 <Baughn> @check \x -> 49.0+x-x == 49.0
15:04:58 <lambdabot>  OK, passed 500 tests.
15:05:16 <Baughn> @check \x -> (49.0+x)-x == 49.0
15:05:17 <lambdabot>  OK, passed 500 tests.
15:05:21 <mmorrow> > (-pi) . (+pi) . read . reverse . show $ 9000000001
15:05:22 <lambdabot>   add an instance declaration for (Floating (a -> b))
15:05:32 <mmorrow> > (+(-pi)) . (+pi) . read . reverse . show $ 9000000001
15:05:33 <lambdabot>  1.000000009e9
15:05:54 <ziman> @yarr pie
15:05:54 <lambdabot> Shiver me timbers!
15:05:54 <dibblego> @check \adamsNumber -> adamsNumber + 0 == adamsNumber
15:05:55 <lambdabot>  OK, passed 500 tests.
15:06:08 <mmorrow> :t check
15:06:10 <lambdabot> forall a. (Testable a) => Config -> a -> IO ()
15:06:22 <mmorrow> @src Config
15:06:22 <lambdabot> Source not found. Just try something else.
15:06:40 <dibblego> > 99+69-36
15:06:41 <lambdabot>  132
15:06:46 <Cale> gubagem: My girlfriend is almost certainly better at algebra than I am. :)
15:07:07 <dibblego> > 99+99-99
15:07:08 <lambdabot>  99
15:07:25 <Cale> (She's a combinatorialist, and has had to deal with some rather insane manipulations, due to her supervisor being insane :)
15:07:30 <Baughn> Cale: ..hang on, are you telling me you /already knew/ Seen was leaking? >_<
15:07:39 <Cale> Baughn: I knew it was buggy.
15:07:45 <dibblego> > 23+65-99
15:07:46 <lambdabot>  -11
15:07:48 <Cale> Baughn: I had no idea what was wrong with it.
15:08:11 <Baughn> Cale: Plenty of other bugs. Oh, but fine - I'll go ahead and rewrite it. It can't possibly take as much code as it's using now.
15:08:14 <Cale> Baughn: Other than that it leaves a blank 'seen' file in State/ and if that's not deleted before lambdabot is restarted, the plugin doesn't work.
15:11:15 <Baughn> Cale: As for Log - it's probably obvious, but the disabled code leaves a Giant Chain o' Thunks. Should be easily fixable, if someone wants to use it.
15:14:12 <toyvo> >  loeb [const 1, (!!3), const 2, head, const 3]
15:14:14 <lambdabot>  [1,1,2,1,3]
15:15:01 <roconnor> I wonder if I should sumbit my paper on plotting continuous functions in Coq to "Graphics" in the arXiv.
15:15:20 <mauke> > loeb [const 1, (!!3), (!!4), head, show]
15:15:21 <lambdabot>   add an instance declaration for (Num String)
15:15:24 <roconnor> Does software for a "graphing calculator" count as graphics?
15:15:30 <ddarius> No
15:15:32 <toyvo> Cale, guys, loeb does stretch a newbie's mind. any background on this?
15:15:37 <Baughn> roconnor: I have it on very good authority that there are no continuous functions
15:15:44 <ddarius> @google loeb sigfpe
15:15:45 <lambdabot> No Result Found.
15:15:48 <Baughn> I also have it on good authority that there are no discontinuous ones
15:15:48 <toyvo> thx
15:15:52 <roconnor> Baughn: uniformly continuous functions
15:16:03 <ddarius> uniformly discontinuous functions
15:16:07 <mauke> http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
15:16:08 <lambdabot> Title: A Neighborhood of Infinity: From L&ouml;b's Theorem to Spreadsheet Evaluation, http://tinyurl.com/22eoxu
15:16:22 <Cale> toyvo: Think of how you might solve a spreadsheet. loeb captures that idea and generalises it
15:16:45 <toyvo> like mutual fixpoint?
15:16:51 <Cale> yeah.
15:16:57 <mmorrow> > check defaultConfig (\n -> let xs = take 1000 $ randoms (mkStdGen n) ::[Int] in (<3) . length . filter (==True) . zipWith (==) xs . sort $ xs)
15:16:58 <Zao> http://www.haskell.org/ghc/download.html  <- Why isn't 6.8.3 on that page?
15:16:58 <lambdabot> Title: The Glasgow Haskell Compiler
15:16:59 <lambdabot>  <IO ()>
15:17:03 <toyvo> good. well i'll go read the article(s)
15:17:05 <monochrom> The world is full of fixed points!
15:17:11 <mmorrow> @check (\n -> let xs = take 1000 $ randoms (mkStdGen n) ::[Int] in (<3) . length . filter (==True) . zipWith (==) xs . sort $ xs)
15:17:13 <lambdabot>  Falsifiable, after 148 tests: 36
15:17:17 <mmorrow> @check (\n -> let xs = take 1000 $ randoms (mkStdGen n) ::[Int] in (<3) . length . filter (==True) . zipWith (==) xs . sort $ xs)
15:17:19 <lambdabot>  Falsifiable, after 97 tests: 21
15:17:22 <ddarius> The world is full of sharp points as well.
15:17:26 <mmorrow> @check (\n -> let xs = take 1000 $ randoms (mkStdGen n) ::[Int] in (<5) . length . filter (==True) . zipWith (==) xs . sort $ xs)
15:17:29 <lambdabot>  Falsifiable, after 214 tests: 36
15:17:35 <mmorrow> @check (\n -> let xs = take 1000 $ randoms (mkStdGen n) ::[Int] in (<10) . length . filter (==True) . zipWith (==) xs . sort $ xs)
15:17:40 <lambdabot>  OK, passed 500 tests.
15:18:04 <roconnor> ah Graphics covers all aspects of computer graphics. Roughly includes material in all of ACM Subject Class I.3, except that I.3.5 is is likely to have Computational Geometry as the primary subject area.
15:19:01 <marcot> http://www.gtk.org/language-bindings.html
15:19:01 <lambdabot> Title: GTK+ - Language Bindings
15:19:05 <marcot> I thought gtk2hs was complete.
15:20:01 <roconnor> Graphics data structures and data types
15:20:16 <roconnor> Display algorithms
15:20:17 <marcot> What is missing in it?
15:20:25 <roconnor> Line and curve generation
15:20:33 <roconnor> I think my work counts as graphic
15:20:33 <roconnor> s
15:24:09 <toyvo> reading through sigfpe's Lob theorem page and it's very gratifying! Thanks a lot for the pointer. Time to go offline though. later.
15:26:01 <ziman> @check const True
15:26:02 <lambdabot>  OK, passed 500 tests.
15:27:06 <ziman> @check (> 1.0e12)
15:27:08 <lambdabot>  Falsifiable, after 0 tests: 0.0
15:28:01 <ziman> > (> 1.0e12) 0.0
15:28:02 <lambdabot>  False
15:28:15 <Botje> hmm
15:28:25 <Botje> the HList presentation has something about "extensible records"
15:28:39 <Botje> are they a solution to many of the problems i hear about records?
15:29:36 <Botje> oh, but you can't do pattern matching on them :[
15:36:55 <roconnor> Oh, has check been updated?
15:37:06 <roconnor> @check id === not . not
15:37:06 <lambdabot>   Not in scope: `==='
15:37:35 <roconnor> oh right
15:37:37 <roconnor> nevermind
15:38:03 <mauke> @let a === b = cast a == Just b
15:38:04 <lambdabot> Defined.
15:38:21 <mauke> where is your god now?
15:42:58 <mmorrow> :t cast
15:42:59 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
15:43:14 <mmorrow> :t (===)
15:43:15 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
15:43:35 <mmorrow> 3 === "3"
15:43:40 <mmorrow> > 3 === "3"
15:43:41 <lambdabot>  False
15:43:55 <mmorrow> > cast "3" :: Maybe Int
15:43:57 <lambdabot>  Nothing
15:44:03 <mmorrow> > cast 4 :: Maybe Int
15:44:05 <lambdabot>  Nothing
15:44:23 <mmorrow> > typeOf 3
15:44:24 <lambdabot>  Integer
15:44:37 <mmorrow> > cast (4::Integer) :: Maybe Int
15:44:38 <lambdabot>  Nothing
15:44:45 <mmorrow> > cast (4::Int) :: Maybe Integer
15:44:46 <lambdabot>  Nothing
15:45:01 <mauke> > 3 === 1+2
15:45:03 <lambdabot>   add an instance declaration for (Num Bool)
15:45:05 <mauke> heh
15:45:09 <mauke> > 3 === (1+2)
15:45:10 <lambdabot>  True
15:45:21 <mmorrow> um
15:45:35 <mmorrow> oh, i see
15:46:04 <thetallgu1> ?seen conal
15:46:04 <lambdabot> I saw conal leaving #haskell and #ghc 45m 54s ago, and .
16:24:11 <dancor> what is the best way to debug issues with expected type `bytestring-0.9.0.1:Data.ByteString.Internal.ByteString' inferred type `ByteString'
16:24:24 <dancor> i've already tried cleaning
16:24:42 <dancor> i usually end up unregister-ing one of them
16:25:00 <dancor> and then i get errors still but they tell me what to recompile
16:25:10 <dancor> and after much wasted time, it does work
16:34:29 <dancor> lambdabot> > print "hi" fd:6: hClose: resource vanished (Broken pipe)
16:42:54 <Botje> what's with the nick changes?
16:56:52 <Botje>    If you are still stuck in the dark ages of runhaskell Setup configure
16:56:53 <Botje>    blah blah, then the imperative monkeys have already won.
16:56:55 * Botje giggles
16:57:35 <monochrom> What do you suggest?
16:57:42 * dolio is confused.
16:57:59 <monochrom> I hope you don't suggest "double click the icon" as a replacement.
16:58:09 <PHO_> use cabal-install
17:00:25 <augur> wheres conal when i need him?!
17:00:29 <augur> >.<
17:01:00 <dobblego> is Conor McBride in this channel?
17:01:52 <thetallgu1> not that I know of.
17:03:36 <dolio> He's too busy meditating on type theory to hang out with us common folk.
17:04:39 <augur> no but connor mcleod is! :O
17:05:54 <thetallgu1> He never logs on twice, though.
17:06:01 <osfameron> @source tails
17:06:01 <lambdabot> tails not available
17:06:09 <dolio> At least one of his cohorts is occasionally here, though.
17:07:52 <Botje> monochrom: it's an excerpt from HWN
17:08:08 <Botje> in context:
17:08:10 <Botje> cabal-install. Duncan Coutts announced the release of cabal-install-0.5, along with the release of Cabal-1.4 to support it.  It features an improved command line interface, smarter upgrading, and is made of win. If you are still stuck in the dark ages of runhaskell Setup configure blah blah, then the imperative monkeys have already won.
17:08:45 <monochrom> Is cabal-install easy to install now?
17:08:59 <Baughn> Sure, just cabal install cabal-install
17:08:59 <dolio> You can install it using cabal-install.
17:09:00 <Botje> it's as easy as cabal install cabal-install! *runs*
17:09:15 <Botje> hehehe :p
17:09:23 <Botje> monochrom: it builds from source pretty easily, too
17:09:37 <Botje> .oO(perhaps it should have a sort of bootstrap feature)
17:09:57 <dolio> I don't remember it being that hard in the past, either.
17:10:05 <dolio> You just have to install like 2 or 3 packages manually.
17:10:20 <monochrom> Sounds good then.
17:11:10 <dobblego> ?type (<*>)
17:11:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:11:19 <Baughn> Three, including cabal-install
17:11:37 <Baughn> Or you can download a binary. It works fine with no support.
17:11:54 * Botje has just found out he has an exam in 10 hours
17:11:56 <Botje> goodie!
17:11:59 <Botje> THE TIME FOR SLEEP IS SOON
17:13:02 <kscaldef> osfameron: you seem to have forgotten to mention in your blog whether the ST actually is faster
17:14:01 <Botje> hmm
17:14:14 <Botje> upgrading stuff before I have to demo it is probably a bad thing
17:14:22 <Botje> but what can go wrong with haskell :o)
17:14:52 <TomMD> Interestingly, my password was rounding rejected by nickserve, just a warning not to trust what "TomMD" says for now.
17:15:00 <mjrosenb> ok, random question.  ijust installed a ghc binary for ppc using the tarball provided on haskell.org
17:15:07 <mjrosenb> is there any way to remove it?
17:16:16 <Botje> use rm?
17:17:51 <monochrom> Yes, rm. Find out what files are in the tarball. rm them.
17:18:23 <mjrosenb> monochrom: do you know how the tarball works?
17:19:15 <monochrom> A tarball is a gzip'ed file of a tar'ed file.
17:19:23 <Botje> hackage people: is it normal that I cannot see parsec on the pkg-list page but can search for it?
17:19:42 <proq> mjrosenb: fseventer will also tell you where the files were installed. run fseventer and reinstall and it will show you
17:20:15 <monochrom> It is a popular archive format. You just unpack lots of files from it. You can also list files inside it.
17:20:34 <proq> mjrosenb: just be sure you don't delete files you *need*
17:20:48 <mjrosenb> monochrom: this is true, but you untar the file, then run ./configure && make install just like on any other unix platform
17:21:23 <mjrosenb> monochrom: removing all of the files that the tarball put there would do... nothing useful
17:21:55 <monochrom> Ah, that just copies files and sets up some symlinks.  Look for stuff in /usr/local
17:22:09 <monochrom> Actually...
17:22:41 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b  may be useful information
17:22:43 <lambdabot> Title: GHC install prefix and upgrades - comp.lang.haskell | Google Groups, http://tinyurl.com/6lvgao
17:29:51 <Botje> WTF
17:29:58 <Botje> ghci can compile my program but ghc can't
17:30:01 <Botje> that's weird
17:30:43 <ivanm> Botje: old .hi files or something?
17:30:49 <Botje> i did clean
17:31:05 <ivanm> weird
17:31:09 <ivanm> what does ghc bork at?
17:31:15 <Botje>     No instance for (Stream B.ByteString Identity Char)
17:31:40 <Botje> where ghci says the instance exists
17:31:43 <monochrom> --make
17:31:48 <Botje> i'm using cabal :)
17:32:10 <monochrom> explicitly list packages you want
17:32:13 <ivanm> dodgy .cabal file?
17:32:19 <Botje> okay
17:32:21 <Botje> this is even worse
17:32:28 <Botje> when I do ghc --make on my Main.hs
17:32:31 <Botje> it just compiles :[
17:32:39 <monochrom> Yes.
17:33:03 <Botje> okay, so what should I look for in the .cabal file?
17:33:04 <monochrom> cabal does the opposite of --make to alert authors of package dependency.
17:33:12 <hpaste>  marcot pasted "/proc/interrupts" at http://hpaste.org/8404
17:33:22 <marcot> sorry..
17:33:28 <marcot> I didn't want to announce.
17:33:30 <hpaste>  Botje pasted "cabal file" at http://hpaste.org/8406
17:33:54 <monochrom> build-Depends: ...
17:34:01 <Botje> just remove that?
17:34:07 <monochrom> add things to that.
17:34:27 <monochrom> cabal tells ghc to use only packages listed there.
17:35:10 <Botje> I checked with Setup.hs build -v
17:35:20 <Botje> it's including all the packages I need
17:35:43 <monochrom> Which package provides "Stream"?
17:35:47 <Botje> parsec 3
17:36:03 <Botje> if I remove all the package cruft from the commandline, it builds
17:36:19 <monochrom> That is a mystery.
17:36:43 <dancor> it is really wise to upgrade cabal over what comes with ghc 6.8.3
17:37:00 <Botje> I did a cabal upgrade just half an hour ago
17:37:40 <Botje> uh oh
17:37:47 <Botje> it appears it installed some stuff as user
17:37:57 <dolio> What version comes with 6.8.3?
17:38:06 <Botje> i'm running 6.8.2, actually
17:38:22 <dancor> Cabal-1.2.3.0
17:38:31 <dancor> oh i'm 6.8.2 too
17:38:32 <dancor> heh
17:38:37 <dolio> cabal-install installs everything as user by default.
17:38:37 <Botje> okay
17:38:38 <Botje> cool
17:38:46 <Botje> it builds if i remove my user-specific packages
17:38:50 <Botje> (which it wasn't using anyway)
17:40:07 <Botje> okay
17:40:19 <Botje> turns out my .cabal/config had compiler: GHC and so it decided to ignore the whole file
17:40:28 * Botje upgrades again
17:40:42 <dancor> once you go bleeding edge you never (can) go back
17:40:57 <monochrom> format the disk
17:41:04 <Botje> i'm going to bleed a LOT if i don't get this fixed in 9 hours
17:41:21 <dancor> give us the disk and we'll give you your life back
17:41:22 <dolio> Is this required for your exam or something?
17:41:26 <Botje> yes :)
17:41:33 <Botje> okay, all compiles now
17:41:39 * Botje is a happy lambdacamel
17:42:00 <monochrom> "Final Exam. Q1: install cabal. (100%)"
17:42:03 <Botje> :)
17:42:16 <Botje> I have to defend my ML compiler, actually
17:42:23 <Botje> and the guy is probably going to want to see it in action
17:42:41 <monochrom> and you haven't probably tested it in action
17:42:42 <Botje> but since the uni servers kind of suck at keeping ghc up to date, i'm going to demo on my desktop at home
17:42:49 <Botje> i have, actually
17:42:55 <monochrom> ok, just kidding
17:42:58 <Botje> ;)
17:43:35 <Botje> brilliant
17:43:39 <Botje> all my tests compile without a hitch
17:43:42 <Botje> i can sleep safely now :)
17:43:55 <SamB> what if your tests are not exhuastive?
17:44:02 <Botje> they're not meant to be
17:44:05 <SamB> have you PROVED that your compiler is correct?
17:44:15 <Botje> i'm only compiling a small subset of ML that computes a number and prints it
17:44:28 <SamB> that should make it easier to prove correct
17:44:29 <Botje> don't have a typesystem or side effects
17:44:52 <SamB> but harder to justify calling ML
17:45:02 <Botje> it /looks/ like ML :)
17:45:24 <monochrom> everything looks like ML
17:45:47 <SamB> monochrom: that's only because the LISP goggles are broken
17:45:50 <dancor> you look like ML (burn)
17:46:05 <dolio> It's ugly like ML, but without the type system. :)
17:46:07 <Botje> okay
17:46:08 <Botje> SLEEPYTIME
17:46:17 <Botje> dolio: I only found out an hour ago the exam is tomorrow
17:46:28 <Botje> I had tomorrow planned for adding the type system :(
17:46:31 <dolio> Good luck.
17:46:40 <monochrom> This can be good press for Haskell.
17:46:44 <Botje> I still have an hour before the exam
17:46:45 <dolio> Heh. One day for the type system.
17:46:47 <Botje> maybe i'll take a gander
17:46:57 <SamB> hah
17:46:59 <Botje> dolio: it looks pretty easy, to be honest
17:47:09 <SamB> if you knock a typesystem out in an hour, that'll be really impressive
17:47:13 <Botje> alpharename all variables, use writer to get the equations, solve them
17:47:17 <mjrosenb> monochrom: where did you say the files were?
17:47:25 <monochrom> /usr/local
17:47:31 <Botje> if it fails, just exit
17:47:47 <Botje> i'm not going to bother adding /where/ it errors ;)
17:47:52 <SamB> Botje: huh
17:47:56 <Botje> i'll keep you guys posted if I can pull it off *G*
17:48:18 <SamB> the last time I wrote anything even slightly reminiscent of an ML compiler, that was ALL it did...
17:48:22 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b  has details
17:48:23 <lambdabot> Title: GHC install prefix and upgrades - comp.lang.haskell | Google Groups, http://tinyurl.com/6lvgao
17:48:56 <Botje> SamB: i'm generating C code :)
17:48:58 <SamB> -- point out the source(s) of type errors
17:49:00 <mjrosenb> sorry for bothering you again, i can't scroll up to read what you said before
17:49:10 <SamB> I don't remember how well it continued after finding one
17:49:59 <SamB> (it was for RML, since the UM-based interpreter used WAY too much heap before reporting errors...)
17:50:15 <dancor> irc logs ftw
17:50:46 <Botje> grrr
17:50:47 <Botje> silly darcs
17:50:57 <Botje> if i'm pushing, of course there's going to be conflicts!
17:53:20 <Botje> anyway
17:53:22 <Botje> i'm going to bed
17:53:35 <Botje> if you're interested in seeing my tiny compiler: darcs get http://infogroep.be/~dharnie/milc
17:53:37 <lambdabot> Title: Index of /~dharnie/milc
17:54:42 <SamB> Botje: you aren't supposed to push when there are conflicts
17:55:08 <Botje> SamB: but there aren't any :(
17:55:17 <SamB> what?
17:55:20 <Botje> yeah
17:55:25 <Botje> I checked beforehand
17:55:31 <Botje> darcs diff shows nothing
17:55:31 <SamB> and the problem is?
17:55:40 <Botje> darcs changes shows the last commit i pushe
17:55:48 <Botje> when i push it says there are conflicts
17:55:56 <Botje> and aborts
17:55:58 <SamB> what happens when you pull?
17:56:42 <Botje> "no remote changes to pull in"
17:56:47 <Botje> which is logicla, because this side is newer
18:02:56 <Socrates`> What's the purpose of the signum method of Num?
18:03:13 <monochrom> > map signum [-2, 0, 2]
18:03:19 <byorgey> Socrates`: what does it do, or what is its purpose?
18:03:21 <lambdabot>  [-1,0,1]
18:03:28 <Socrates`> Hmm, both I guess
18:03:33 <SamB> Socrates`: well, it's called signum ... look it up
18:03:34 <mwc> Socrates`: its purpose is to give you the sign of a number
18:03:34 <monochrom> try other +ve and -ve numbers.
18:03:45 <mwc> sign-number = signmum
18:03:51 <Socrates`> Ahh, I see.
18:03:52 <Socrates`> Thanks.
18:04:02 <byorgey> no, that's what it does.  it's purpose is to screw up the Num class. =P
18:04:02 <mwc> @quickcheck \n -> signum n * abs n == n
18:04:02 <lambdabot> Unknown command, try @list
18:04:04 <dolio> It's slightly more interesting with complex numbers.
18:04:09 <mwc> @list
18:04:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:04:10 <dolio> Although it, at the same time, totally ruins them.
18:04:14 <monochrom> haha
18:04:17 <mwc> @qc \n -> signum n * abs n == n
18:04:18 <lambdabot> Not enough privileges
18:04:23 <dancor> isn't it kind of sloppy that signum doesn't -> to an Ordering-like type
18:04:24 <SamB> dolio: it does?
18:04:27 <byorgey> mwc: @check
18:04:31 <SamB> dancor: no!
18:04:31 <mwc> @check \n -> signum n * abs n == n
18:04:34 <lambdabot>  OK, passed 500 tests.
18:04:35 <mwc> byorgey: thanks
18:04:45 <dolio> SamB: Well, it prevents Gaussian integers from fitting in the existing hierarchy.
18:04:46 <mwc> Socrates`: that was a demonstration of an identity signum holds
18:04:54 <monochrom> > signum (1 :+ (-1))
18:04:56 <lambdabot>  0.7071067811865475 :+ (-0.7071067811865475)
18:04:57 <dolio> Just as a for-instance.
18:05:03 <monochrom> hahahaha
18:05:50 <mwc> dancor: no, it's not. Often times you want to multiply an expression by signmum's result
18:05:51 <SamB> dolio: that doesn't ruin complex numbers -- that's just a flaw of the hierarchy ...
18:05:58 <mwc> or at least, that's what I use it for when I use it
18:06:31 <mwc> dolio: well, actually, projection onto the unit circle is the definition of signum for complex numbers
18:07:09 <dolio> I know. The problem is that the only way you're allowed to declare something a ring is if it supports signum.
18:07:17 <dolio> And so on.
18:08:07 <SamB> haskell doesn't support rings
18:08:29 <dolio> So the only way Complex a is a Num is if A is Floating or something along those lines.
18:08:52 <dancor> fork Num
18:09:07 <dolio> It's been done.
18:09:18 <dancor> what is the new Num
18:09:51 <dolio> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude
18:09:54 <lambdabot> http://tinyurl.com/5nu5yc
18:09:55 <dancor> where can i get sum
18:09:56 <dancor> nice
18:10:46 <monochrom> philosophie monadis principia haskella
18:11:01 <monochrom> oops, typo
18:11:12 <monochrom> philosophae monadis principia haskella
18:11:24 <monochrom> there may be more typos I don't know of
18:11:39 <dolio> Although that goes the route of naming things like 'Foo.Bar.Baz.C' and 'Foo.Bar.Baz.T'.
18:11:50 <dolio> Of which I'm not a fan.
18:14:54 <dolio> Perhaps I would be if I were more of an ML programmer.
18:15:51 <dancor> i don't see any haskell' plan for revamping Num at all
18:16:44 <dancor> that would be the right way to do it right?
18:17:04 <dancor> unless the fork idea is sustainable
18:17:09 <dolio> I don't know. People seem to be against making significant library revisions in H'.
18:17:22 <dolio> Or, revisions that would break lots of things, that is.
18:17:36 <dolio> Although maybe Num is in bad enough shape to override that.
18:17:53 <bos> Num will not be touched. Num is here to stay, as it is.
18:18:12 <bos> changes to it would probably break every haskell package.
18:20:31 <dolio> You'd probably need class aliases getting accepted to get people to fix the numeric stuff in Haskell.
18:20:46 <dolio> I'm not sure if there's even a ticket for those.
18:21:06 <dolio> And no one's implemented them, to my knowledge.
18:22:16 <dons> 353 binary packages in the overlay, dcoutts. automated. does arch win "haskell platform" support now? :)
18:22:22 <dons> though cabal-install isn't in the core system yet.
18:22:30 <bos> dons: nice.
18:22:56 <dons> want to install and play monaius? "pacman -S monadius". done. opengl haskell games ftw.
18:23:09 <dons> want some category theory? pacman -S category-extras
18:23:13 <dons> and your brain will melt
18:23:24 <monochrom> pacman?!
18:23:34 <dons> pac[kage]man[ager], yeah
18:23:40 <dancor> lal
18:24:03 <dons> i should write a review of some of these little known hackage libs and apps
18:24:14 <dons> feed-cli is a good one, monadius is awesome. hsparklines rocks.
18:24:24 <dons> hback is lots of fun.
18:24:44 <chessguy> what is monadius?
18:25:13 <dons> an arcade game in haskell, using opengl. a bit like hmm, asteroids or something.
18:25:21 <dons> it is much fun.
18:25:23 <monochrom> "Normally dependencies chase after pacman. But after pacman eats dons's special pill, it chases after dependencies for a while."
18:25:39 <dons> pacman is the arch equivalent of aptitude
18:25:52 <dons> and there's a tool to translate hackage's .cabal files into package specs for pacman.
18:26:04 <dons> then pacman does indeed chase your C and Haskell deps for you
18:27:26 <dons> having complete coverage in the major distos is key to adoption.it noramlises haskell as a language you expect to have on your box
18:27:51 <dons> making it a *lot* cheaper to develop and distribute haskell stuff, and helping suck in more devs, as users start using different haskell things
18:28:18 <dons> one more step to avoid success.
18:28:24 <dons> or avoid avoiding it
18:29:37 <monochrom> Next decade we will talk of "haskell monkeys", like we talk of "imperative monkeys now". We ourselves will be doing adga or something.
18:29:56 <monochrom> s/ now"/" now/
18:30:04 <dolio> Agda?
18:30:10 <monochrom> yeah agda
18:30:16 <dolio> You're going to be an instensional type theory monkey?
18:30:17 <bos> agda4, or whatever it will then be.
18:30:18 <dons> i just want there to be no special burden to taking and trying out some new haskell software, beyond what you would do for some python or C code.
18:30:27 <dolio> Too many 's's in there.
18:30:28 <dons> the distros should fully support, out of the box,whatever we need
18:30:48 <dons> hand out haskell access like candy, as audreyt might say
18:31:12 <dons> how they got ruby into the base macosx bundle, i'd love to know
18:31:13 <dons> ah well
18:31:52 <bos> well, ruby is all shiny, and so is OS X.
18:32:05 <dolio> Got an arrogant jerk to write a web framework in it and then said that anyone who doesn't use OS X like him is a moron?
18:32:12 <monochrom> "hai! we luv agda newbies! delicious! have you read 'yet another curry-howard tutorial'?"
18:32:36 <dons> dolio: maybe that would work.
18:32:46 <dons> we need more jerks!
18:33:05 <dolio> Weren't you just censoring one earlier today? :)
18:33:16 <dons> true enough
18:34:23 <dolio> Are you actually using Arch now? I though you were an OpenBSD man.
18:34:42 <monochrom> Eh? I love jerks! Who did dons censor? :)
18:34:45 <dons> i have fully and completely migrated to arch
18:35:11 <dons> back to linux for the first time in 7 years or so
18:35:19 <dons> i see some work has been done :)
18:35:22 <monochrom> Or rather, was it in this channel? When? I can find it in the logs.
18:35:29 <dons> nah, -cafe flame insanity
18:35:30 <dolio> No, it was on haskell-cafe.
18:35:41 <monochrom> Alrighty, I can find it there. Thanks.
18:35:43 <dolio> Check the PHP thread.
18:36:51 <dons> or better yet, don't. it doesn't make any sense. it does not make sense.
18:37:11 <dolio> Yeah, that's probably better advice.
18:37:27 <dolio> I only skimmed enough to see the word "Hitler".
18:37:39 <TeteTTetT> How do I know if something is in list?
18:38:12 <TeteTTetT> Oh, nvm
18:38:17 <dons> `elem`
18:38:27 <dons> Cale, maybe some help for this guy, http://codeflow.wordpress.com/2008/06/18/haskell-a-grain-of-python/
18:38:28 <lambdabot> Title: Haskell + a grain of Python « Open game programming, http://tinyurl.com/59k9fz
18:40:37 <dons> @tell Feuerbach some screenshots of the DPH stuff as you work on it would be great. really enhace the blog
18:40:37 <lambdabot> Consider it noted.
18:41:21 <bos> what blog?
18:42:01 <dons> http://physics-dph.blogspot.com/
18:42:02 <lambdabot> Title: Building physics engine in Data Parallel Haskell
18:42:33 <dons> Roman hanging out in the Ukraine, hacking DPH physics engines for SoC. fun!
18:43:03 <petekaz> Quick question: is this code snippet "ugly" in terms of haskell coding style?  http://hpaste.org/8407
18:43:45 <newsham> does DPH work on MMX/XMM or any gpus?
18:44:20 <chessguy> "case undefined"?
18:44:22 <dons> ghc generates parallel array code, using forkIO.
18:44:22 <bos> petekaz: it's a bit difficult to read because of the indirection.
18:44:39 <petekaz> bos: yeah, that's why I was asking.
18:44:57 <monochrom> hehehe, someone is trying to detect non-halting programs :)
18:45:04 <bos> chessguy: that's not unusual. it's how you simulate a switch statement in haskell.
18:45:28 <monochrom> Anyway, style. I think it's ok.
18:45:35 <petekaz> I thought the indirection would let the reader see some simple names for what the checks are doing though, is it an empty line, is it a continuation line, is it a header line vs the detail.
18:45:43 <bos> petekaz: i'd usually expect the actual expressions to be in each guard, not a variable that refers to an expression that's nearly as concise.
18:51:42 <petekaz> I'm excited as I wrote a simple imap client without monads, then added a state monad to make things nicer, then added errort to make things even better, and this is the first time I've used monads!  And now I can write little imap snippets to do things like check the headers of my inbox etc ... Progress with Haskell for me!!
18:52:13 <petekaz> Thanks to RWH chapters on monads!
18:52:22 <papermachine> RWH?
18:52:31 <bos> i'm glad it helped!
18:52:38 <petekaz> real world haskell.
18:52:49 <petekaz> bos: are those your chapters?
18:52:50 <bos> that makes me very happy.
18:52:52 <bos> yes.
18:53:06 <petekaz> nice.  I flooded the programming with monads chapters with comments.
18:53:17 <bos> i saw, though i haven't had a chance to read them yet.
18:53:34 <bos> i have about 1.3 chapters to finish off, then go on vacation, then it's time to start editing.
18:53:48 <petekaz> keep up the great work.
18:54:02 <petekaz> I took your chapters while on vacation 2 weeks ago!
18:54:04 <bos> :-) thanks
18:54:10 <newsham> will it be under the tree by christmas?
18:55:15 <bos> newsham: i bloody well hope so :-)
18:55:57 <bos> oh god. IFIP conference on DSLs.
18:56:54 <byorgey> bos: what's wrong with that?
18:57:36 <bos> much ado about not very much?
18:57:38 <chessguy> it's just a buzzword
18:57:52 <monochrom> I'm using ADSL.
18:57:56 <monochrom> <duck> :)
18:58:00 <byorgey> yeah, ok
18:58:11 <chessguy> i have a cable modem myself
18:58:38 <dancor> i'm not getting something..  why does cabal-install install to .cabal/bin
18:58:49 <byorgey> that's just the default
18:59:02 <byorgey> you can change it by giving a --prefix= option
18:59:05 <dancor> how do i find out the relevant config var
18:59:10 <byorgey> you can even put it in a config file, I think
19:00:37 <hpaste>  morrow pasted "cabal_do.sh" at http://hpaste.org/8408
19:02:31 <dancor> byorgey: i have a cabal wrapper
19:02:40 <dancor> but not a cabal-install one
19:02:57 <dancor> and prefix: in my config silently failed
19:03:09 <dancor> failed to change anythig
19:03:23 <byorgey> I don't know how the config works
19:03:39 <dancor> time to go code-diving i suppose
19:04:40 <chessguy> dancor:  make sure you document whatever you find - you won't be the last to ask it
19:06:28 <dancor> simultaneousquestion: where do i start figuring out why lambabot hates me: lambdabot> > "hi" fd:6: hClose: resource vanished (Broken pipe)
19:06:41 <dancor> reinstalled from cabal-install but no change
19:08:04 <dancor> does anyone have lbot working?  from cabal-install?
19:08:52 <dobblego> dancor, yes, but it was a mission
19:08:53 <dancor> other commands work (like bot and pl)
19:09:03 <dobblego> dancor, and in fact, not all commands work
19:09:13 <dancor> > is the only one i know of that hates me
19:09:13 <lambdabot>  Parse error at "of" (column 24)
19:11:29 <dobblego> how do you explain to someone that the "zero" of a monoid is not necessarily the numeric value 0?
19:11:31 <dancor> ok actually, lambdabot> djinn f ? a -> a
19:11:31 <dancor> Plugin `djinn' failed with: Prelude.init: empty list
19:12:00 <dancor> dobblego: you can't, they'll just throw an isomorphism in your face
19:12:00 <dolio> Call it an identity instead?
19:12:40 <dancor> a counter-example (e.g. multiplication) should help..
19:13:16 <dancor> @djinn f ? a -> (a, a)
19:13:17 <lambdabot> Cannot parse command
19:14:00 <dancor> @djinn a -> a
19:14:00 <lambdabot> f a = a
19:14:16 <dancor> well same error for that locally
19:16:05 <dobblego> dancor, then I am told that the name "zero" is meaningless and only conventional
19:16:50 <dancor> answer to my question about .cabal/config prefix: you can't do it (data SavedConfig doesn't have any field)
19:17:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8409
19:18:10 <SamB> dobblego: isn't it?
19:18:26 <SamB> actually I think it's the same with all words
19:18:54 <hpaste>  (anonymous) annotated "(no title)" with "Lambdabot..." at http://hpaste.org/8409#a1
19:19:12 <dobblego> SamB, the concept of zero to mean means the same as identity
19:19:16 <dobblego> (to me
19:19:50 <SamB> it is conventionally used to refer to an additive identity or a multiplicative I-wish-I-knew-the-name-for-this
19:19:56 <SamB> true
19:20:26 <solrize> :t MaybeT
19:20:28 <lambdabot> Not in scope: data constructor `MaybeT'
19:20:33 <solrize> :t ListT
19:20:35 <lambdabot> Not in scope: data constructor `ListT'
19:20:54 <solrize> :t lift
19:20:56 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
19:21:57 <solrize> :t Just
19:21:59 <lambdabot> forall a. a -> Maybe a
19:22:41 <EvilTerran> SamB, i think the term for 0 wrt multiplication (ie an element x s.t. forall y. x * y = y * x = x) is a, er, "zero"
19:22:56 <SamB> EvilTerran: that's ... strange.
19:23:06 <SamB> too multiplication-specific
19:23:09 <koninkje> SamB: why?
19:23:47 <EvilTerran> which'd make the identity 1, which makes more sense from a etymylogical point of view
19:23:55 <koninkje> a "zero" of any function f is the element x s.t. f x = x
19:24:28 <EvilTerran> so presumably a 2-ary function could have a left zero and a right zero
19:24:31 <SamB> I was under the impression that was called the fixed-point
19:24:39 <SamB> not the zero
19:24:59 <EvilTerran> ... wait, he has a point
19:25:08 <koninkje> EvilTerran: there can be indeed (though for the binops people usually talk about they're the same)
19:25:12 <EvilTerran> (indeed, he has a fixed point *badum-chh*)
19:25:49 <SamB> anyway, in MY axiomatization, I'm calling them Annihilators for lack of a more attractive term
19:25:49 <koninkje> a zero is a fixed point...
19:25:57 <ddarius> multiplicative zeor
19:26:01 <EvilTerran> SamB, i can't think of any readily-accessible examples of that behaviour other than multiplicative zero
19:26:02 <ddarius> s/zeor/zero
19:26:14 <SamB> well, take ||
19:26:25 <SamB> you going to call True a zero of ||?
19:26:27 <EvilTerran> true. && also.
19:26:45 <SamB> hmm.
19:26:55 <SamB> maybe I should look the name of that property up
19:26:56 <koninkje> False is the zero of &&
19:27:10 <EvilTerran> ... would it be too weird to call it the left-/right-fixedpoint?
19:27:16 <SamB> probably has a conventional name ...
19:27:46 <koninkje> EvilTerran: why? it's conventionally called the "zero", a function can have more than one fixed point...
19:28:11 <EvilTerran> well, it'd require a suitable definition of left-/right-fixedpoin
19:28:21 <koninkje> (hence why people usually talk about the "*least* fixed point" of a function)
19:28:28 <SamB> the name is much harder than the definition, to be sure
19:28:32 <EvilTerran> ah, never mind
19:28:41 <SamB> I already wrote a definition I'm happy with ;-)
19:29:06 <SamB> koninkje: what about the identity function?
19:29:12 <SamB> on the integers?
19:29:14 <koninkje> what about it?
19:29:18 <SamB> what's the least fixed point?
19:29:29 <koninkje> there isn't one
19:29:34 <SamB> right you are
19:29:53 <EvilTerran> _|_ is at the bottom of the relevant ordering
19:30:13 <SamB> EvilTerran: er, _|_ is not an integer
19:30:34 <koninkje> but it is an Integer ;)
19:30:53 <SamB> yes but I used the lowercase, see?
19:31:01 <EvilTerran> i thought you were just being lazy :P
19:31:15 <SamB> no, I'm in total mode
19:31:19 <EvilTerran> i tend to leave out case all over the place when it doesn't really matter
19:31:32 <EvilTerran> i see
19:31:54 <EvilTerran> in total mode, surely the usual ordering used in the definition of "least fixed point" doesn't really make sense?
19:31:55 <SamB> I usually use the nats but obviously the identity function HAS a least fixed point on nats..
19:32:23 <SamB> EvilTerran: oh, well, I dunno. who talks about fixed points?
19:32:45 <edwardk> who doesn't?
19:33:15 <dolio> All naturals are equally defined if you're in total mode.
19:33:19 <SamB> in particular, I don't imagine engineers are familiar with this ordering for the most part...
19:34:40 <dolio> So there is no unique least fixed point of the identity on naturals.
19:34:49 <dolio> Correct me if I'm wrong.
19:35:04 <EvilTerran> dolio, isn't it more that they're neither more nor less defined, not that they're equally defined? seeing as the ordering isn't antisymmetric an' all...
19:35:06 <dolio> At least, in the usual sense that 'least' is meant.
19:35:10 <SamB> okay, so well, I dunno why anyone brought up the least fixed point
19:35:27 <atp> because it's cool, probably
19:36:04 <SamB> EvilTerran: what do you mean it isn't antisymmetric?
19:36:05 <koninkje> because there was a debate about identities vs zeros (on semi-rings)
19:36:23 <SamB> koninkje: identities vs zeros?
19:36:28 <byorgey> any ideas why I would suddenly start getting a segmentation fault every time I try to use openURL from Text.HTML.Download?
19:36:37 <EvilTerran> in the ordering of definedness, !(!(x < y) && !(x > y) => x = y)
19:36:43 <byorgey> it was working just earlier today, and now... segmentation faults =P
19:36:55 <byorgey> very bizarre
19:37:21 <koninkje> 0 is the identity of + and the zero of *, 1 is the identity of *... to pick a semiring
19:37:23 <ddarius> EvilTerran: It's antisymmetric, it just doesn't satisfy trichotomy.
19:37:25 <EvilTerran> well, i guess that's more co-antisymmetric
19:38:01 <EvilTerran> "if a is (not) related to b and b is (not) related to a, then a = b" - leave out the "not"s for antisymmetric
19:38:18 <SamB> EvilTerran: which relation are you claiming to be what?
19:38:58 <EvilTerran> i was trying to say that "!(x < y) && !(x > y) => x = y" did not apply to the relation conventionally used for the meaning of "least fixed point"
19:39:18 <EvilTerran> so, although no one integer would be above or below another, that doesn't mean they're all equal
19:39:30 <SamB> so you say that
19:39:30 <EvilTerran> not that interesting, really :P
19:39:36 <ddarius> EvilTerran: That's a round-about way of stating the trichotomy law.
19:40:27 <EvilTerran> ddarius, so i see, now i've looked it up. good to know.
19:40:42 <SamB> "~((x â‰¥ y) -> (x â‰¤ y) -> (x = y))"?
19:40:43 <EvilTerran> although i did quite like "co-antisymmetric" :P
19:41:12 <EvilTerran> SamB, no, >= is distinct from !< in this situation
19:41:22 <SamB> EvilTerran: how come?
19:41:38 <EvilTerran> because two values can be indistinguishable under the relation and yet not equal
19:41:51 <SamB> oh.
19:42:00 <EvilTerran> unicode has a codepoint for "not less than, equal to, or greater than" for a reason, i guess :P
19:42:16 <SamB> you mean = is leibnitz?
19:42:44 <EvilTerran> (although it also has one for "not greater than, equal to, or less than", which is just getting carried away)
19:42:49 <EvilTerran> leibnitz?
19:42:55 <mmorrow> hypnotic: $ watch -n 0.1 'cat /dev/urandom | od -a | head -22'
19:43:27 <SamB> EvilTerran: apparantly leibnitz equality is the term used for the finest-grained equality available in a system
19:43:38 <EvilTerran> aha. in that case, yes
19:43:42 <SamB> typically, this is defined like this:
19:44:04 <EvilTerran> i guess i can see why you'd prefer to define (x=y) as just !(x<y || x>y)
19:44:17 <EvilTerran> but i find the distinction makes things more interesting
19:44:32 <lumi> GHC just told me to panic
19:45:25 <SamB> data _==_ : Set -> Set -> Set where ==-refl : forall {a} -> a == a
19:47:01 <SamB> hmm.
19:47:13 <SamB> I think I messed it up
19:47:19 <SamB> yeah, definately
19:47:29 <SamB> there's supposed to be an A in there or something ...
19:55:12 <dobblego> Applicative + Monoid -> Monad?
19:56:11 <dobblego> dcoutts, in the Applicative paper, there is a mention of some unpublished work by you regarding Applicative over accumulating errors; is there a reference for that?
19:59:51 <ddarius> dobblego: That's not even kind correct.
20:00:07 <dobblego> ddarius, that's why I am asking
20:00:38 <dons> anyone played topkata?
20:00:42 <dons> http://home.arcor.de/chr_bauer/topkata.html
20:00:43 <lambdabot> Title: Topkata
20:01:25 <EvilTerran> dobblego, a few monoids fall naturally out of the monad laws, i think that's the point
20:01:47 <mmorrow> > let cycle = fix . (tail .) .  (++) in take 20 $ cycle [0..3]
20:01:49 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2]
20:02:00 <EvilTerran> (>=>) and return, for starters.
20:02:11 <mar77a> >=>?
20:02:16 <EvilTerran> ?src >=>
20:02:16 <lambdabot> Source not found. Sorry.
20:02:30 <EvilTerran> (f >=> g) x = f x >>= g
20:02:34 <dobblego> I am referring specifically to this sentence in 'Applicative Programming with Effects':    We began this section by observing that Accy o is not a monad. However, given Monoid o, it can be defined as the composition of two applicative functors derived from monadsâ€”which two, we leave as an exercise.
20:02:37 <EvilTerran> (f <=< g) x = f =<< g x
20:02:49 <mmorrow> > let cycleFrom n = fix . ((foldl (.) id . replicate n $ tail) .) . (++) . fix . (++) in take 7 . fmap (take 4 . flip cycleFrom [0..2]) $ [0..]
20:02:50 <lambdabot>  [[0,1,2,0],[1,2,0,1],[2,0,1,2],[0,1,2,0],[1,2,0,1],[2,0,1,2],[0,1,2,0]]
20:03:02 <ddarius> (>=>) and return form a whole category
20:03:04 <dobblego> it is true that not all Applicatives are Monads (but all Monads are Applicative), however, my impression is that you can somehow go from Applicative to Monad with a Monoid somehow
20:03:22 <EvilTerran> mmorrow, going a bit over-board with the pointsfree there, aren't you?
20:03:44 <EvilTerran> what is Accy?
20:03:45 <mmorrow> hehe
20:03:49 <dolio> You get there with bind or join.
20:04:08 <dobblego> EvilTerran, an example type in the paper
20:04:11 <mmorrow> @pl \n -> fix . ((foldl (.) id . replicate n $ tail) .) . (++) . fix . (++)
20:04:12 <lambdabot> (fix .) . (. ((++) . fix . (++))) . (.) . flip (foldl (.) id .) tail . replicate
20:04:32 <dobblego> newtype Accy o a = Acc{acc :: o }
20:05:29 <ddarius> dobblego: That's presumably like the Writer monad.  It's not the monad that's a "Monoid"
20:05:39 <dobblego> dolio, I can't see how you can go from Applicative to Monad with bind/join, since you don't have a Monad (I've also read something by Luc Dupncheel that with a Monoid you can get to Monad too)
20:06:04 <mmorrow> :t (++) . fix . (++)
20:06:06 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:06:20 <dolio> The extra operation that Monads suppor that Applicatives don't is bind/join.
20:06:28 <mmorrow> > let (<>) = (++) . fix . (++) in [] <> []
20:06:33 <bos> what does the -B option to ghc do? it's not documented.
20:06:44 <lambdabot>  thread killed
20:07:07 <dobblego> dolio, sure, but Applicative supports something that with a bit of help, could be bind
20:07:15 <dobblego> ddarius, ok thanks
20:07:16 <bos> oh crumbs, it uses the same topdir for both aux binaries and libraries.
20:08:31 <mmorrow> > let (<>) = (++) . fix . (++) in zipWith (==) (fix (():)) ([()] <> undefined)
20:08:32 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
20:08:48 <mmorrow> :t (fix .)
20:08:50 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
20:08:52 <dolio> I'm afraid I'm not sure what that sentence means.
20:08:56 <mmorrow> :t (. fix)
20:08:58 <lambdabot> forall b a. (a -> b) -> (a -> a) -> b
20:09:53 <dobblego> perhaps I have misread
20:10:12 <mmorrow> :t flip (. fix)
20:10:13 <lambdabot> forall c a. (a -> a) -> (a -> c) -> c
20:10:30 <EvilTerran> instance Monoid o => Monad (Accy o) where return = Acc mzero; Acc o >>= f = o `mplus` f ... - it doesn't work =/
20:11:39 <mmorrow> :t flip id
20:11:40 <lambdabot> forall b c. b -> (b -> c) -> c
20:11:43 <gwern> woot, I finally get a darcs repo for mueval, and I discover somewhere along the way rsync nuked half my patches and my repo is irretreviably corrupt
20:12:07 <ivanm> heh
20:12:15 <ddarius> EvilTerran: mempty mappend
20:12:57 <mmorrow> > let f = flip (. fix) in f (const 4) (*2)
20:12:58 <lambdabot>  8
20:13:19 <newsham> anyone here know gtkhs ?
20:13:36 <newsham> i'm trying to get a GC from a widget.  in other languages I get it from the widget's style
20:13:43 <newsham> but here I only see the sytle giving me colors
20:13:46 <newsham> not GC's
20:13:48 <mmorrow> :t flip (. fix) . const
20:13:52 <lambdabot> forall c a. a -> (a -> c) -> c
20:14:26 <mmorrow> return for Cont!
20:14:43 <mmorrow> :t flip id
20:14:45 <lambdabot> forall b c. b -> (b -> c) -> c
20:14:57 <EvilTerran> ddarius, true
20:15:57 <ddarius> It's the composition of the Writer and Constant monads/applicative functors.
20:15:58 <EvilTerran> ?unpl flip (. fix) . const
20:15:58 <lambdabot> (\ h c -> c (fix (\ _ -> h)))
20:16:23 <mmorrow> :t flip . const
20:16:24 <lambdabot> forall a b c. (b -> c) -> b -> a -> c
20:16:31 <ddarius> fix . const == id
20:16:33 <mmorrow> :t fix . const
20:16:35 <lambdabot> forall a. a -> a
20:17:00 <EvilTerran> ddarius, you mean data Const a = Const; instance Monad Const where return _ = Const; _ >>= _ = Const ?
20:17:48 <EvilTerran> that's even more boring than the Identity monad :P
20:18:44 <gwern> > 50 `div` 4
20:18:46 <lambdabot>  12
20:18:50 <ddarius> EvilTerran: Yes, that's what I mean.  It's not a "notion of computation" a la Moggi though.
20:20:03 <mmorrow> @pl fix . const
20:20:03 <lambdabot> id
20:20:07 <mmorrow> :)
20:20:15 <newsham> ?seen dcoutts
20:20:15 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 5h 9m 30s ago.
20:20:24 <mmorrow> @pl flip (. fix) . const
20:20:24 <lambdabot> flip (. fix) . const
20:20:38 <mmorrow> @pl flip (flip (. fix) . const)
20:20:38 <lambdabot> (. const) . (. fix)
20:20:51 <mmorrow> :t flip . flip $ id
20:20:53 <lambdabot> forall b c. (b -> c) -> b -> c
20:21:40 <mmorrow> :t fix (flip . flip $ id)
20:21:42 <lambdabot> forall b c. b -> c
20:21:51 <ivanm> I'm applying for a code.haskell.org account, and when I'm copying my ssh key from ~/.ssh/id_dsa.pub , what do I put in? if it's of the form "ssh-dss ..... username@host", do I just paste the stuff in between?
20:22:15 <mar77a> is it possibly to have more than one argument to a lambda function?
20:22:24 <ivanm> > \ x y -> x + y
20:22:26 <lambdabot>  <Integer -> Integer -> Integer>
20:22:27 <mmorrow> :t (. const) . (. fix)
20:22:29 <lambdabot> forall b a. (a -> b) -> a -> b
20:22:37 <ivanm> mar77a: ^^
20:22:43 <mmorrow> @pl fix (flip . flip $ id)
20:22:44 <lambdabot> fix id
20:22:49 <mar77a> ty
20:26:07 <mmorrow> ivanm: just paste it all. if you haven't submitted it already, generate an rsa instead because i was informed that's better
20:26:54 <ivanm> mmorrow: that's what I was thinking, except the web page says dsa :s
20:27:06 <ivanm> and it says not to use a passphrase... isn't that rather risky?
20:27:12 <mmorrow> yeah, they've since started accepting both dsa and rsa
20:27:19 <ivanm> *nod*
20:27:39 <ivanm> just "ssh-keygen -t rsa" ?
20:30:03 <ddarius> instance Monoid () where mempty = (); mappend x y = x `seq` y
20:30:11 <ddarius> (The true Monoid instance of ().)
20:31:20 <SamB> @src groupBy
20:31:21 <lambdabot> groupBy _  []       =  []
20:31:21 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:31:21 <lambdabot>     where (ys,zs) = span (eq x) xs
20:31:41 <ddarius> ivanm: It doesn't tell you to, it merely states that it is not necessary.
20:31:46 <solrize> ivanm use a passphrase on your local pc to protect the private key.  when they say don't use a passphrase they mean don't use a passphrase to authenticate between the local box and the code server (i.e. use a public key instead)
20:32:02 <ivanm> solrize: ahhh
20:32:11 * ivanm hasn't had much to do with ssh keys, etc.
20:32:22 <ivanm> so the passphrase is only used by me on my box?
20:32:26 <solrize> yes
20:32:39 <solrize> it protects the secret bits on your hard drive in case someone manages to read them
20:32:47 <ivanm> just so I know, if I want to access my code.haskell.org account on another machine, I'd have to have my ssh keys on that machine as well?
20:33:32 <solrize> you could either have the same secret key on both machines, or have separate keypairs and put both public keys on code.haskell.org
20:33:47 <ivanm> *nod*
20:34:05 <ivanm> so I copy the entire line from my .pub file into the box when applying for an account?
20:34:12 <solrize> yeah
20:34:33 <solrize> you can put multiple lines into authorized_keys
20:34:37 <ivanm> *nod*
20:34:46 <Riastradh> Generally one shouldn't move private keys from machine to machine.  It is safer not to transmit them at all over the internet, and easier to selectively revoke access in case of individually compromised machines if you just use one key pair per machine.
20:34:54 <solrize> right
20:35:41 <ivanm> Riastradh: I didn't mean via the net (e.g. using a USB key from one home computer to another)
20:35:47 <ivanm> I'm not _that_ stupid :p
20:35:49 * ivanm hopes
20:36:24 <solrize> treat secret keys as if they were radioactive waste
20:36:49 <mmorrow> hide them in new mexico?!?@
20:36:53 <solrize> :)
20:36:55 <ivanm> you mean bury them in a geologically stable area for 4000 years?
20:37:03 <solrize> i just mean avoid spilling them
20:37:03 <ivanm> mmorrow: dammit, you beat me to it! ;-)
20:37:12 <ivanm> solrize: or wrap them in a monad ala the wikibook?
20:37:14 <mmorrow> ;)
20:37:17 <Riastradh> USB flash drives are sketchy, too.  Because they have limited erasure capacity, most drivers for them will prefer to fill them up before erasing anything on them.
20:37:20 <solrize> ivanm right the usb monad :)
20:37:24 <ivanm> heh
20:37:33 <ivanm> Riastradh: hmmm.....
20:37:34 <solrize> seriously, use a long and very random passphrase if you're going to transport them
20:37:46 <Riastradh> So, just don't transmit keys.  Generate new ones.
20:37:58 <solrize> like, take two or three dollar bills and use their complete serial numbers as the passphrase
20:38:02 * ivanm prints off his key, types it in letter-by-letter onto the new machine, shreds the paper and then burns the shreds
20:38:08 <solrize> but it's preferable to use separate keys on each client machine
20:38:13 <Riastradh> There's no cost to generating new ones.  It's not a bad idea to do it every <insert time duration> anyway.
20:38:14 <solrize> so each secret key lives in exactly one place
20:38:33 <ivanm> solrize: I'd like to point out that we use _coins_ as our $1 and $2 units of currency here down under...
20:38:35 <ivanm> ;-)
20:38:37 <solrize> hehe
20:38:49 <SamB> I wish we did
20:39:04 <ivanm> don't blame me, blame your government!
20:39:07 <SamB> well, we don't have $2 currency
20:39:15 <ivanm> really, using plain old paper for notes? shocking!
20:39:45 <ivanm> then again, Hong Kong still lets every single bank print its own notes off, so there's not much standardisation AFAICT...
20:39:45 <SamB> we have $1 coins, but for some reason they aren't terribly popular?
20:39:45 <mmorrow> you could just use luks on the usb key, and keep your keys encrypted with all your other stuff
20:39:46 <solrize> the u.s. has $2 bills but they are rather rare
20:39:47 <SamB> I'd like more, but when I get change it's usually in bills
20:39:59 <SamB> solrize: those are a collector's item at this point
20:40:08 <ddarius> SamB: Why the heck would you want more coins?
20:40:14 <SamB> solrize: I mean, *I'd* never spend one
20:40:14 <ivanm> SamB: $2 coins are handy, especially for young vandals who glue two 5c coins together to fool vending machines into thinking they're inserting a $2 coin... not that I've done anything like that! :p
20:40:26 <SamB> ddarius: bad billfeeds on vending machines is why
20:40:28 <solrize> hehe i never heard of that
20:40:39 <solrize> anyway i gotta go, laterz all
20:40:44 <ivanm> cya solrize
20:41:07 <SamB> ddarius: understood?
20:42:04 <marcot> What do you think is a better (more elegant) code:
20:42:32 <ddarius> SamB: So you want better billfeeds, not more coins.
20:42:49 <SamB> ddarius: well, also bills tend to get really wrinkly
20:43:08 <ddarius> SamB: ... so?
20:43:26 <SamB> and sometimes I don't blame the billfeeds for rejecting them
20:43:46 <ddarius> So you use a different one.
20:44:35 <hpaste>  marcot pasted "Styles" at http://hpaste.org/8410
20:52:29 <codetoad> I'm reading http://book.realworldhaskell.org/beta/monadtrans.html right now - do we have to liftIO when in, say, WriterT [(FilePath, Int)] IO () and use an IO function?
20:52:31 <lambdabot> Title: ChapterÂ 17.Â Monad transformers
20:52:54 <codetoad> I guess the types are different
21:03:18 <bos> codetoad: if you've just got one transformer on top of IO, you can use lift or liftIO.
21:03:20 <mmorrow> @pl \a -> unF (k (f a)) a
21:03:21 <lambdabot> unF =<< k . f
21:04:58 <mar77a> @src map
21:04:59 <lambdabot> map _ []     = []
21:04:59 <lambdabot> map f (x:xs) = f x : map f xs
21:05:06 <mar77a> bah
21:05:30 <mar77a> myMap was something like: map f xs = foldr ((:).f) [] xs
21:05:42 <mar77a> isn't that much more concise
21:05:50 <mar77a> or is there any problem with it?
21:06:46 <bos> is there a clean way to build a profiled cabal package with -prof -auto-all that doesn't also cause the regular build to get -prof -auto-all?
21:07:47 <dons> ghc-prof-options: -prof -auto-all
21:08:24 <bos> oh, that must be newish! sweet!
21:08:59 <dons> i'm not sure why it isn't the default. -p should imply -auto-all
21:16:34 <hpaste>  dolio pasted "unboxing" at http://hpaste.org/8411
21:20:52 <hpaste>  dolio annotated "unboxing" with "core" at http://hpaste.org/8411#a1
21:21:19 <mar77a> :t forever
21:21:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
21:21:27 <mar77a> @src forever
21:21:28 <lambdabot> Source not found. That's something I cannot allow to happen.
21:21:35 <mar77a> where is forever defined?
21:21:44 <dolio> @index forever
21:21:45 <lambdabot> bzzt
21:21:47 <mar77a> i imported all the modules in http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot but ghci still wouldn't find it
21:21:50 <dolio> Control.Monad, I suspect.
21:21:51 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
21:22:39 <dolio> That tutorial actually defines its own forever, but starting in 6.8 (I think), it should be in Control.Monad.
21:23:05 <mar77a> oh yeah i just saw
21:23:11 <dolio> @hoogle forever
21:23:12 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
21:24:01 <dolio> dons: ping
21:25:05 <bd_> > runCont (callCC (forever . join id)) `seq` ()
21:25:05 <lambdabot>  Couldn't match expected type `() -> Cont r b'
21:25:17 <bd_> > runCont (callCC (forever . join id)) () `seq` ()
21:25:17 <lambdabot>  Couldn't match expected type `() -> Cont r b'
21:25:21 <bd_> er
21:25:28 <bd_> > runCont (callCC (forever . join id)) id `seq` ()
21:25:28 <lambdabot>  Couldn't match expected type `() -> Cont r b'
21:25:31 <bd_> :|
21:26:14 <dolio> You were hoping for an infinite type instead?
21:26:16 <adu> hi
21:26:30 <bd_> dolio: I thought join f x = f x x?
21:26:42 <dolio> Yeah.
21:26:43 <bd_> therefore join id x = x x
21:26:46 <bd_> whichi... oh
21:26:50 <bd_> :|
21:26:51 <adu> I have a question about GHC-2.x
21:27:03 <SamB> adu: ... ?
21:27:07 <SamB> you have GHC-2.x?
21:27:11 <SamB> where did you find it?
21:27:24 <SamB> that is ....
21:27:28 <SamB> what, older than me?
21:27:32 <bd_> > runCont (callCC (forever . flip id ())) id `seq` ()
21:27:33 <lambdabot>  ()
21:27:44 <adu> at some point Data.FiniteMap was deprecated in favor of Data.Map and I'm porting HOC (Haskell-ObjC binding) to use Data.Map and I'm having problems
21:28:03 <adu> so I replaced plusFM_C with unionWith and GHC-6.8.2 is complaining
21:28:22 <SamB> adu: I'm fairly certain that Data.FiniteMap was removed during the 6.x era ;-)
21:28:34 <adu> SamB: ok
21:28:48 <dolio> I'd guess 6.4, just as something to throw out there.
21:28:56 <SamB> ... since I remember Data.FiniteMap, but not GHC 5.x
21:29:14 <SamB> I think I started with GHC 6.2.x
21:29:51 <adu> let me paste
21:30:17 <hpaste>  adu pasted "porting HOC" at http://hpaste.org/8412
21:32:19 <adu> where you see "unionWith" in that part used to be "plusFM_C"
21:32:35 <SamB> it seems to be complaining about M.map's argument...
21:32:40 <adu> oh
21:32:49 <adu> maybe thats Prelude.map then...
21:32:54 <adu> heh
21:33:10 <SamB> huh
21:33:28 <SamB> usually I import *Data.Map* qualified as M
21:33:42 <SamB> (I wish I could write it in that order in code!)
21:33:51 <SamB> (well, almost)
21:33:56 <adu> yes me too
21:34:10 <hpaste>  adu annotated "porting HOC" with "more" at http://hpaste.org/8412#a1
21:34:14 <SamB> I guess I wish I could write it that way and have it transformed to the other way
21:34:22 <adu> this is the import section
21:34:53 <SamB> that *is* Data.Map
21:34:59 <adu> yes
21:35:20 <adu> I'm thinking maybe the author intended Prelude.map
21:35:22 <SamB> hmm.
21:35:29 <SamB> adu: no ...
21:35:42 <SamB> perhaps mapWithKey?
21:36:26 <dolio> @type callCC (\k -> k k)
21:36:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
21:36:28 <lambdabot>     Probable cause: `k' is applied to too few arguments
21:36:28 <lambdabot>     In the first argument of `k', namely `k'
21:36:34 <mar77a> !uptime
21:36:34 <czakey>  has been up for:
21:36:34 <czakey> []
21:36:35 <SamB> or ... just remove the "sel" argument?
21:36:42 <SamB> since it doesn't seem to be used
21:37:06 <adu> YES! thats it!
21:37:08 <adu> it compiled :)
21:37:19 <adu> I replaced M.map with mapWithKey
21:37:29 <adu> thanks :)
21:37:49 <SamB> okay, but note that it seems not to USE the key
21:37:59 <adu> hmm
21:38:05 <SamB> so you could just delete the word "sel" and go back to M.map
21:38:22 <adu> that also compiles
21:38:46 <SamB> but if you run into the same thing again you'll remember to use mapWithKey if it actually uses the key, won't you?
21:38:51 <adu> yes
21:39:41 <adu> Data.FiniteMap.mapFM == Data.Map.mapWithKey
21:41:54 <mmorrow> @pl  \f -> return . fix $ (flip runCont id . f)
21:41:54 <lambdabot> return . fix . (flip runCont id .)
21:43:31 <bos> huh, module re-export behaves weirdly in the presence of qualified import.
21:43:55 <bos> if i import qualified FooBar as F, i cannot list either "module FooBar" or "module F" in the export list.
21:44:11 <SamB_XP_> bos: what the heck?
21:44:23 <bos> i kid you not.
21:44:31 <SamB_XP_> I was sure you could list module F then...
21:44:41 <bos> if i try "module F", ghc says "Warning: The export item `module BloomFilter' exports nothing"
21:44:59 <SamB_XP_> hmm.
21:45:01 <bos> er, edit the message and get the idea.
21:45:12 <SamB_XP_> oh, oh
21:45:14 <bos> looks like a bug to me.
21:45:33 <SamB_XP_> it only exports names that are in scope
21:45:42 <SamB_XP_> when you do it that way
21:45:58 <bos> it does? ugh.
21:46:01 <SamB_XP_> so there are no names in scope that have that prefix associated with them...
21:46:52 <SamB_XP_> do you often desire to export several conflicting definitions of the same name?
21:47:31 <bos> well, i'm trying to find the smallest number of hoops i can jump through.
21:47:43 <SamB_XP_> I'd get rid of the qualified
21:48:13 <bos> that just adds other fugliness.
21:48:18 <SamB_XP_> such as?
21:48:28 <bos> i then need to explicitly import the Prelude so i can use Prelude.length
21:48:41 <bos> (the module i import defines length and elem)
21:49:11 <SamB_XP_> and that's really too ugly for you?
21:49:28 <SamB_XP_> > P.map 1 [2,3]
21:49:29 <lambdabot>   add an instance declaration for (Num (a -> b))
21:49:38 <SamB_XP_> > P.map - [b,a]
21:49:38 <lambdabot>  Couldn't match expected type `(a -> b) -> [a] -> [b]'
21:49:59 <SamB_XP_> > P.map negate [a,b]
21:50:00 <lambdabot>  [negate a,negate b]
21:50:09 <SamB_XP_> hmm.
21:50:24 <SamB_XP_> > negate
21:50:26 <lambdabot>  <Integer -> Integer>
21:50:33 <SamB_XP_> :t a
21:50:35 <lambdabot> Expr
21:50:45 <SamB_XP_> > negate : Expr -> Expr
21:50:45 <lambdabot>  Parse error at "->" (column 15)
21:50:49 <SamB_XP_> > negate :: Expr -> Expr
21:50:50 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
21:51:11 * SamB_XP_ mocks haskell for using the wrong symbol for type signatures
21:54:29 <bos> SamB_XP_: actually, not only is it too ugly for me, it doesn't work.
21:54:48 <SamB_XP_> bos: what happens?
21:55:05 <bos> it seems i have to list the names i'm re-exporting explicitly. it's not enough that i import them explicitly. if they're not used in the module, they don't get re-exported.
21:55:26 <SamB_XP_> ????
21:55:30 <SamB_XP_> what?
21:55:38 <bos> i'm just reporting what i see happening.
21:55:57 <pragma_> what you think you see, anyway.
21:56:16 <bos> no, i'm pretty clear on what i'm seeing.
21:56:48 * bos does a clean build.
21:58:26 <bos> ok, better.
21:58:40 <bos> i still can't get exactly what i want, but oh well.
21:59:45 <Heffalump> so the basic problem is that you can't re-export modules after importing them qualified?
22:01:32 <mmorrow> :t runCont (callCC mfix)
22:01:35 <lambdabot> forall a r. (MonadFix (Cont r)) => (a -> r) -> r
22:02:09 <mmorrow> :t let mfix = reset . return . fix . (flip runCont id .) in runCont (callCC mfix)
22:02:11 <lambdabot> Not in scope: `reset'
22:02:32 <mmorrow> :t let reset = Cont . flip id . flip runCont id; mfix = reset . return . fix . (flip runCont id .) in runCont (callCC mfix)
22:02:34 <lambdabot> forall a. (a -> a) -> a
22:02:52 <mmorrow> :t let fix = let reset = Cont . flip id . flip runCont id; mfix = reset . return . fix . (flip runCont id .) in runCont (callCC mfix) in fix (0:)
22:02:53 <lambdabot> forall t. (Num t) => [t]
22:02:58 <mmorrow> > let fix = let reset = Cont . flip id . flip runCont id; mfix = reset . return . fix . (flip runCont id .) in runCont (callCC mfix) in fix (0:)
22:02:59 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
22:03:30 <mmorrow> :t let reset = Cont . flip id . flip runCont id; mfix = reset . return . fix . (flip runCont id .) in mfix
22:03:31 <lambdabot> forall a r. (a -> Cont a a) -> Cont r a
22:03:45 <mmorrow> :t let reset = Cont . flip id . flip runCont id; mfix = reset . return . fix . (flip runCont id .) in Cont mfix
22:03:47 <lambdabot> forall a. Cont (Cont a a) a
22:04:02 <bos> mmorrow: augh, privmsg lambdabot instead of spamming us please
22:04:33 <mmorrow> i never thought of that
22:04:39 <mmorrow> surely
22:05:23 <Heffalump> didn't someone suggest it yesterday?
22:05:45 <mjrosenb> mmorrow: do you not have ghc installed?
22:06:05 <mmorrow> okok no more spam
22:06:47 <mmorrow> Heffalump: not that i'm aware of, but possibly.
22:12:44 <bos> the output of ghc profiling is 140 columns wide. how am i supposed to fold, spindle, and mutilate that to fit into a narrow little book page?
22:13:02 <bos> time for some surgery with emacs.
22:13:15 <PHO_> @pl sameType a b = cuType a == cuType b
22:13:15 <lambdabot> sameType = (. cuType) . (==) . cuType
22:13:30 <bos> M-x kill-rectangle to the rescue!
22:13:47 <Riastradh> M-x set-variable RET truncate-partial-width-windows RET t RET?
22:14:19 <bos> Riastradh: the issue isn't fitting it onto my screen, it's not losing the useful info when i typeset the output.
22:14:26 <Riastradh> OK.
22:14:39 <bos> @seen dons
22:14:39 <lambdabot> dons is in #arch-haskell, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 1h 5m 40s ago.
22:15:06 <SamB_XP_> bos: you could do what Knuth did ...
22:15:27 <SamB_XP_> use a REALLY DAMN WIDE page
22:15:30 <mmorrow> bos: sparklines look extremely useful: http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR&topic_id=1
22:15:32 <lambdabot> Title: Ask E.T.: Sparklines: theory and practice, http://tinyurl.com/6bbkw
22:15:33 <Heffalump> print it sideways :-)
22:15:46 <SamB_XP_> or that, if it fits
22:15:53 <SamB_XP_> sideways is good
22:16:02 * Heffalump wasn't serious, it'd be horribl
22:16:03 <Heffalump> e
22:16:11 <SamB_XP_> Heffalump: what?
22:16:15 <Heffalump> printing it sideways
22:16:20 <SamB_XP_> how come?
22:16:28 <Heffalump> it'd be far too hard to read given that the rest of the book would be vertical
22:16:37 <SamB_XP_> it'd be a figure...
22:16:58 <bos> mmorrow: sparklines aren't suited to tabular data.
22:17:10 <SamB_XP_> aren't sideways figures well-established?
22:17:41 <mjrosenb> small font?
22:17:58 <adu> hmm...
22:18:07 <mmorrow> bos: hmm, i guess it depends on the relationship of elts across lines/and/or/cols
22:18:39 <sjanssen> @tell gwern mueval -e "Foreign.unsafePerformIO (readFile \"/etc/passwd\")"
22:18:39 <lambdabot> Consider it noted.
22:18:49 <NewBy> hola
22:19:10 <sjanssen> > Foreign.unsafePerformIO (readFile "/etc/passwd") `seq` ()
22:19:10 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
22:19:16 <adu> so the tool that converts ObjC => Haskell compiled, but then when it ran it made this error:
22:19:20 <SamB_XP_> sparklines are only suited to time-varying numeric data
22:19:21 <adu> ifgen: user error (Pattern match failure in do expression at PrepareDeclarations.hs:135:16-22)
22:19:39 <adu> and when I look in that part of the file I see:
22:19:41 <adu> Just ci <- HashTable.lookup inInfos name
22:19:59 <adu> does this mean that the HashTable is returning Nothing?
22:20:01 <sjanssen> yes
22:20:01 <geezusfreeek> bos: how many characters wide are the normal text lines in the book?
22:20:22 <bos> geezusfreeek: for fixed-width text, about 74 is the max before you run out of space.
22:20:25 <mmorrow> SamB_XP: why would you restrict yourself to only time?
22:20:40 <SamB_XP_> mmorrow: well, okay, but it has to be a numeric axis
22:20:43 <geezusfreeek> bos: can the tabulated data not be split up across two adjacent pages?
22:21:00 <bos> geezusfreeek: not without everyone in layout and writing land having nightmares.
22:21:07 <SamB_XP_> for instance, "cost center" doesn't make much sense
22:21:10 <bos> i'm just trimming a bunch of crap from the profiling output.
22:21:16 <geezusfreeek> sounds like it's a nightmare already :\
22:21:28 <SamB_XP_> bos: and you can't have a foldout?
22:21:33 <mmorrow> SamB_XP: meaning an ordering on both dims. not necessarily, but then you'd have to make up for that with (e.g. some kind of labeling)
22:21:54 <bos> SamB_XP_: nope.
22:22:00 <SamB_XP_> mmorrow: it doesn't make sense to call it a sparkline if it isn't numeric both ways...
22:22:15 <SamB_XP_> bos: what are you trimming?
22:22:32 <mmorrow> SamB_XP: oh, i immediately left the topic of "sparklines"...
22:22:35 <SamB_XP_> isn't there a mode where GHC produces thinner output to start with?
22:22:50 <bos> SamB_XP_: whitespace and inherited numbers.
22:22:54 <mmorrow> SamB_XP: well not *topic*, but you know
22:22:58 <bos> that gets me down to ~70 columns.
22:26:14 <tieTYT2> hi
22:26:33 <tieTYT2> i just learned about (.).  From what I can tell, it just saves you a bunch of parans.  Am I wrong?
22:26:44 <tieTYT2> parameters i mean
22:26:59 <SamB_XP_> eh?
22:27:08 <SamB_XP_> it saves brainpower
22:27:22 <tieTYT2> the brain power of matching up parens?
22:27:24 <geezusfreeek> well, yes, but more importantly, it allows you to think about programming in a more... err... compositional way
22:27:26 <tieTYT2> oh i didn't mean parameters
22:27:29 <tieTYT2> i meant parenthesis
22:28:30 <geezusfreeek> it allows you to think more in terms of verbs and less in terms of nouns
22:28:35 <dobblego> tieTYT2, not really related to that of the parentheses more than it is more concise; function composition is one of the most basic tenets of applicative programming
22:29:15 <geezusfreeek> verbs are easier to grok than nouns more often than not
22:29:18 <dobblego> tieTYT2, consider \x -> f(g(x)) which seems to emphasis x and the result of f(g(x)), however, the real meaning can be found in the composition of f and g (f . g)
22:29:52 <hpaste>  rwbarton pasted "background computation" at http://hpaste.org/8413
22:29:54 <adu> geezusfreeek: except in Latin
22:30:11 <rwbarton> why does the program I pasted work in ghci but not when compiled with ghc --make?
22:30:17 <geezusfreeek> adu: syntax issues aside :P
22:30:29 <geezusfreeek> (i don't know enough latin to say much about it though)
22:30:32 <rwbarton> oh wait I know why
22:30:34 <adu> o I have no idea what you're talking about
22:30:47 <dolio> There's no main?
22:30:56 <adu> go, going, went
22:30:57 <rwbarton> Er, main = test
22:31:12 <rwbarton> The reason is buffered output
22:31:32 <adu> (Latin has similar tenses, only a few dozen of them)
22:32:46 <hpaste>  rwbarton annotated "background computation" with "(no title)" at http://hpaste.org/8413#a1
22:33:12 <rwbarton> So my real question is, can I make it work without calling yield explicitly?
22:33:30 <rwbarton> Here work means that about half the list gets printed after 3 seconds and then the rest is printed as it gets computed.
22:34:13 <rwbarton> I understand that the issue is that the forkIO'd thread doesn't do any memory allocation and thus doesn't get preempted,
22:34:49 <SamB_XP_> rwbarton: liberal application of blows to the GHC maintainers?
22:35:01 <rwbarton> I guess I'm wondering whether I can tell ghc to run this code using real OS threads.
22:35:02 <SamB_XP_> i.e. beat up simons
22:35:10 <atp> you can
22:35:14 <atp> use forkOS
22:35:23 <SamB_XP_> I still say "beat up simons" is the answer!
22:35:35 <atp> (i missed the beginning of this convo, so if that's not appropriate or has been covered already, my bad)
22:35:55 <rwbarton> I thought forkOS would work to, but it doesn't seem to
22:36:10 <SamB_XP_> (with the goal of getting them to make preemption happen even without allocation)
22:36:11 <atp> are you compiling with -threaded and everything?
22:36:21 <rwbarton> Yeah
22:36:24 <atp> hm
22:36:30 <atp> i'm not sure then.
22:36:45 <rwbarton> Hmm, I can try -N2
22:36:53 <SamB_XP_> honestly, the only real solution is to get preemption to happen even without allocation
22:36:59 <rwbarton> ah, that did it!
22:37:04 <rwbarton> SamB_XP_: I agree
22:37:14 <atp> SamB is just the man to add that feature
22:37:17 <SamB_XP_> the best technique *I* can come up with is beating up on simons, have you got a better ?
22:37:38 <atp> i could hold him
22:37:58 <SamB_XP_> unfortunately I have school through august
22:38:12 <SamB_XP_> so I won't have time to fly out to the UK for the purpose
22:38:18 <atp> hm
22:38:28 <geezusfreeek> ow my head http://www.haskell.org/pipermail/haskell-cafe/2008-June/044491.html
22:38:28 <lambdabot> Title: [Haskell-cafe] message passing style like in Haskell?, http://tinyurl.com/6hdld6
22:38:39 <rwbarton> Well, it seems like -threaded and +N2 do what I want, so really I just need the ability to spawn new real threads at runtime
22:38:47 <SamB_XP_> I suggest appointing someone who already lives in the region
22:39:01 <atp> unfortunately the UK is largely devoid of sentient life
22:39:25 <SamB_XP_> aren't there any others at MSR we could get to do it?
22:39:48 <atp> i think they're all in cahoots really
22:40:28 <sjanssen> rwbarton: I'm fairly certain that the forkIO'd function will do memory allocation
22:40:31 <adu> Mountain Safety Research?
22:40:45 <SamB_XP_> adu: MicroSoft
22:40:45 <sjanssen> rwbarton: note that d :: [Integer]
22:40:51 <adu> SamB_XP_: o
22:41:06 <SamB_XP_> the Simons work at MSR
22:41:06 <rwbarton> sjanssen: Hmm, that's true
22:41:54 <rwbarton> sjanssen: I thought I was able to make it work in the single-OS-threaded model by fiddling with 'force' to make it do memory allocation
22:42:01 <rwbarton> Let me experiment
22:43:17 <sjanssen> rwbarton: what symptom were you observing?
22:43:35 <rwbarton> All the output appeared at once
22:43:47 <rwbarton> I assume because the main thread didn't get to run until the other thread had finished
22:44:05 <rwbarton> Let me paste my current code
22:44:53 <sjanssen> rwbarton: the hangs you are observing are probably GMP calls that take a very long time
22:45:31 <hpaste>  rwbarton pasted "background computation 2" at http://hpaste.org/8414
22:48:07 <sjanssen> rwbarton: rather than using a lazy list, perhaps you should write each result to a Chan?
22:49:48 <dancor> so cabal install won't install libraries directly?
22:49:59 <dancor> i want to install the deps of lambdabot and play with the source
22:49:59 <rwbarton> for my intended application, the +RTS -N2 version is good enough, and it's ridiculously simple from my point of view as a programmer.
22:50:20 <sjanssen> dancor: yes, it installs libraries
22:50:40 <sjanssen> 'cabal install X11', for example
22:50:46 <rwbarton> But I'm a little confused about why it doesn't work without +RTS -N2, since you're surely right about memory allocation
22:51:10 <dancor> sjanssen: i did arrows, it says nothing, then i got to manually cabal build lambdabot and it says arrows -any is missing
22:51:27 <sjanssen> dancor: configure lambdabot with --user
22:51:40 <adu> speaking of GMP, are there any haskell bindings to mpf_t?
22:51:58 <sjanssen> dancor: cabal-install installs as a user by default, and you need to tell Cabal when it is okay to use user installations for dependencies
22:53:00 <sjanssen> rwbarton: this might be worth an email to glasgow-haskell-users
22:55:29 <dancor> sjanssen: i did (try to..) install lambdabot to the machine by doing it as root with --prefix=/usr/local
22:55:57 <dancor> sjanssen: that still installs the libraries per-user?  how do i install them to the box
22:56:31 <sjanssen> dancor: cabal install installs libraries as per-user.
22:57:27 <dancor> sjanssen: ok, i changed root's .cabal/config to user-install: False
22:57:33 <dancor> i think i can get what i want now
23:01:30 <dons> everyone loves cabal install
23:02:01 <SamB_XP_> what's not to love?
23:02:01 <dolio> dons: Thoughts? http://hpaste.org/8411
23:02:30 <dolio> Specifically, is that the kind of thing that'd be a problem if it got called... 40 million times over the course of a program?
23:03:25 <dons> i'd use a real data type , specialised, instead of :*;
23:03:31 <dons> since then you'll get register returns
23:03:46 <dons> rather than (# State# RealWorld, Int #)
23:04:05 <dolio> So, the problem is the return type of iter?
23:04:13 <bos> yes, try (Bool, Int)
23:04:32 <bos> CPR should catch it.
23:04:37 <dons> i'd just directly use data P = P !Bool !Int -funbox-strict-fields
23:04:39 <dons> leave no doubt.
23:04:56 <dons> the $! should be enough for (,) though
23:05:29 <dons> you have to convince ghc the pair that returns is strict in constructor and fields
23:05:38 <dons> so it isn't nested anymore
23:06:08 <bos> blergh. what's the usual term you use for a phantom argument that fixes a type?
23:06:17 <bos> my memory is coming up short.
23:06:23 <sjanssen> bos: witness
23:06:29 <bos> sjanssen: thanks! duh.
23:06:30 <sjanssen> or proxy
23:06:34 <dolio> Still looks boxed with (Bool, Int)
23:06:50 <SamB_XP_> and here I thought a witness demonstrated that a type was inhabited
23:07:07 <dons> and with the 'data' variant? data P = P {-# UNPACK #-} !Int {-# UNPACK #-} !Bool ?
23:07:19 <dolio> Typing...
23:07:20 <dons> unambiguously registerised
23:07:49 * SamB_XP_ really needs to go to bed...
23:07:56 <dons> return $! P b k'
23:09:31 <dolio> Nope, even with 'return $! P b k'' the worker for whileLoop returns a boxed Int that's immediately destructed in the inlined max.
23:09:38 <dons> hmm
23:09:41 <vy> Hi! Would anybody show me how one can transform (iterate (for elt in list-of-lists) (finding elt maximizing (length elt))) lisp expression into its haskell form?
23:10:19 <sjanssen> vy: what does that do?
23:10:33 <sjanssen> vy: returns the longest list?
23:10:47 <vy> sjanssen: It returns the longest list in the list-of-lists.
23:10:50 <sjanssen> the longest list in a list of lists, to be more exact
23:10:52 <dons> dolio: oh, is it the return from whileLoop ?
23:10:55 <sjanssen> yep, this is pretty easy
23:11:07 <dolio> dons: Yes.
23:11:16 <SamB_XP_> @hoogle comparing
23:11:16 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
23:11:22 <dons> hm
23:11:48 <sjanssen> @type maximumBy (comparing length)
23:11:50 <lambdabot> forall a. [[a]] -> [a]
23:11:53 <dolio> "k' <- whileLoop e0 ; return $! max k k'" is the offending code, more or less.
23:13:15 <dolio> That gets inlined to more or less 'case go 0# k# s of (# s, k' #) -> case k' of I# k'# -> case <# k# k'# of ...'
23:13:35 <sjanssen> @type map snd . maximumBy (comparing fst) . map (length &&& id) -- slightly more efficient
23:13:37 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
23:13:37 <lambdabot>       Expected type: [[a1]] -> [(Int, (a, b))]
23:13:37 <lambdabot>       Inferred type: [[a1]] -> [(Int, [a1])]
23:14:03 <geezusfreeek> > let longest = maximumBy (comparing length) in longest ["foo", "bar", "wibble", "this should win", "a"]
23:14:04 <lambdabot>  "this should win"
23:14:29 <dolio> Where, I think, you wouldn't want that extra 'case k' of I# k'#' in there. go could just return (# State# s, Int# #).
23:16:54 <adu> vy: good example
23:20:19 <bos> i want to marry quickcheck.
23:20:30 <adu> i want to marry Yi
23:20:35 <bos> it found a wonderful bug for me.
23:20:43 <dancor> i hope to some day be leet enough to marry yi
23:21:15 <adu> dancor: I'd like to make installers so you don't have to be leet :)
23:21:34 <dancor> yes!
23:22:32 <sjanssen> bos: do you really want to marry something that is so good at finding faults in things?
23:22:59 <adu> sjanssen: what do you think marriage is all about? lol
23:23:05 <bos> sjanssen: i already did :-)
23:23:56 <adu> i wonder if HOC is working...
23:24:30 <adu> its currently parsing over 300 headers, without a progress bar
23:24:58 <adu> so it could be 90% or 1% done, i wish i knew...
23:26:39 * mjrosenb should try yi
23:26:42 * adu imagines the day: I do, I do, you may now kiss the editor
23:26:47 <mjrosenb> too bad it's hard masked in gentoo
23:26:55 <adu> masked?
23:27:35 <mjrosenb> yeah, portage does'nt want me to install in
23:28:34 <Smokey`> so unmask it.
23:29:18 <Smokey`> add the package name to etc/portage/packages.unmask (or something like that - has been a while since I used gentoo)
23:29:26 <mjrosenb> that would take effort and as of this week, i haven't seen any spectacular reason to
23:29:50 * sjanssen bets it is hardmasked for a reason
23:30:21 <mjrosenb> that too
23:31:33 <adu> its /etc/portage/package.unmask (no s)
23:31:51 <mjrosenb> adu: sort of
23:32:27 <adu> thats what http://gentoo-wiki.com/Masked says
23:32:28 <lambdabot> Title: TIP Dealing with masked packages - Gentoo Linux Wiki
23:32:59 <mjrosenb> adu: so it can be either a file or a directory
23:33:09 <mjrosenb> adu: on my box, it's a directory
23:33:19 <mjrosenb> so editing that 'file' won't do much good
23:33:35 <adu> wierd
23:33:53 <duckfoot> Is it possible to restrict a type variable to instances of a particular class in a type synonym declaration?
23:35:03 <mjrosenb> duckfoot: iirc, type synonnyms are kinda useless
23:35:11 <adu> duckfoot: type (Class a) => C = C2 a ? maybe?
23:35:37 <mjrosenb> duckfoot: what if you stuck it inside of a class
23:35:58 <mjrosenb> class foo a => bar where bar = a
23:36:12 <mjrosenb> err
23:36:17 <mjrosenb> wow that made no sense
23:36:27 <adu> lol
23:36:35 <duckfoot> =)
23:37:23 <bos> offtopic movie moment: http://www.the-editing-room.com/indianajones4.html
23:37:24 <lambdabot> Title: Indiana Jones and the Kingdom of the Crystal Skull: The Abridged Script | The Ed ...
23:37:25 <mjrosenb> class Foo a => Bar a where type Baz a = a
23:37:35 <mjrosenb> there we go...
23:37:47 <osfameron> kscaldef: good point -- I don't really know the benchmarking tools in haskell, suppose I could have used the unix 'time' command
23:38:08 <quicksilver> duckfoot: the answer is no.
23:38:29 <osfameron> It didn't "feel" any faster in my case, I guess it's a question of how expensive the transformation is
23:38:30 <quicksilver> duckfoot: it's often helpful to pretend that, in haskell's type system, the classes aren't really part of the 'type'.
23:38:58 <quicksilver> duckfoot: so Num a => [a] isn't a type. [a] is a type and Num a is a constraint.
23:39:17 <quicksilver> duckfoot: taking that view, type synonyms only work on the [a] part.
23:39:48 <duckfoot> thanks quicksilver, makes sense now why it works with data/newtype since those define type constructors
23:40:26 <quicksilver> it doesn't work very well with data/newtype in haskell98
23:40:35 <quicksilver> it doesn't give you the context back when you deconstruct.
23:40:46 <quicksilver> it works better in GHC with appropriate options
23:40:52 <quicksilver> (I think GADTs unlocks it)
23:41:07 <ivanm> have people seen this? http://lwn.net/Articles/285332/
23:41:07 <lambdabot> Title: Implications of pure and constant functions [LWN.net]
23:41:14 <ivanm> someone advocating purity in C...
23:41:15 <adu> I'm so confused about GADTs
23:41:58 <adu> Most definitions of GADTs fall into one of two categories: (1) its a syntax (2) its a datatype
23:42:03 <adu> which is it?
23:42:32 <araujo> bos, saw it two days ago
23:43:00 <bos> adu: it's a floor wax.
23:43:05 <adu> lol
23:44:43 <dancor> anyone know where in the source lambdabot does its "> .." evaluation
23:48:12 <quicksilver> dancor: runplugs / hs-plugins
23:52:44 <osfameron> @pl sortST cmp f = map fst . sortBy (cmp snd) . map (id &&& f)
23:52:45 <lambdabot> sortST = ((map fst .) .) . (. (map . (id &&&))) . (.) . sortBy . ($ snd)
23:54:03 <roconnor> gcc has a pure annotation?
23:54:17 <dolio> Man, GHC's optimizer does some wild stuff sometimes.
23:54:51 <adu> gcc?
23:56:34 <adu> roconnor: are you talking about attribute((pure))?
23:56:36 <ivanm> roconnor: looks like it
