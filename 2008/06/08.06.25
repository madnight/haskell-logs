00:00:14 <fons> Does anyone know about a platform independent mktemp implementaioin for Haskell?
00:03:41 <adu> Yi.MkTemp
00:08:30 <hpaste>  morrow pasted "Text.Regex.PCRE.QQ" at http://hpaste.org/8525
00:11:29 <rwbarton> does anyone ever use the HEAD branch snapshots?
00:11:49 <mmorrow> rwbarton: i'm gonna try to see if i can fix the pattern context problem, we'll see how it goes...
00:12:15 <mmorrow> rwbarton: no, just darcs (me personally)
00:12:37 <mmorrow> rwbarton: are you on linux?
00:12:41 <rwbarton> Yes
00:12:58 <mmorrow> what distro?
00:13:11 <rwbarton> debian
00:14:00 <rwbarton> recent HEAD snapshots don't build for me because the configure script runs a 64-bit executable file that's included in the tarball
00:14:22 <mmorrow> hmm, do you think a ghc binary built on fedora would run ok on debian?
00:14:41 <mmorrow> if so, i have
00:15:17 <mmorrow> well, a month and a half old
00:15:19 <mmorrow> The Glorious Glasgow Haskell Compilation System, version 6.9.20080504
00:15:42 <rwbarton> maybe I can darcs get the version you have?
00:16:00 <mmorrow> cool, i'll put it somewhere, gimme a sec
00:16:17 <rwbarton> Ah, I just meant get a specific revision from the darcs repository
00:16:40 <mmorrow> oh. i'm not sure how but probably
00:17:42 <rwbarton> I'll try current darcs once more for good luck
00:17:56 <rwbarton> Maybe my problem was that I ran out of disk space in /tmp halfway through the build
00:18:44 <mmorrow> it's a monster unpacked
00:37:05 <rwbarton> So I found out that PCRE supports "named substrings", i.e., you can give a name to the contents of a (...).
00:46:15 * codacola give shaskell a bigger hug everyday
00:50:04 <hpaste>  rwbarton pasted "matching against regular expressions" at http://hpaste.org/8526
00:50:53 <rwbarton> @tell mmorrow take a look at http://hpaste.org/8526 for matching against regular expressions
00:50:57 <rwbarton> argh
00:52:03 <povman> >3
00:52:19 * codacola curses his haskell book for lying
00:52:33 <povman> codacola: ...
00:53:56 <codacola> povman, "one of the distinvy features of a functional programming language is the list comprehension notation, which has no parallels in other paradigms"
00:54:12 <codacola> now i find out its implemented in python and c#
00:54:38 <povman> list comprehension has nothing to do with fp... it's sugar
00:54:57 <povman> which book?
00:55:22 <codacola> haskell: the craft of functional programming
01:02:01 <Bourbaki> hello
01:02:35 <povman> hi
01:04:24 <Bourbaki> if you have a graph with three nodes and three edges the nodes beeing types, node1: Inputtype* x Outputtype*, node2: Inputtype* x Outputtype*, node3: Outputtype2, edge1: node1 -> node2, edge2: node2 -> node1, edge3: node2 -> node3
01:04:41 <Bourbaki> now i want to model recursion in that graph in the following way
01:04:44 <solrize> lol
01:05:24 <Bourbaki> the token at node1 is fed to edge1 and it will do something with one of the input elements and process it and put it onto the output section
01:05:41 <Bourbaki> then it gets fed back to node1 from node2 via edge2
01:06:17 <Bourbaki> once the input is empty in the inputsection in node2 edge3 will be used to put everything together
01:06:34 <adu> Bourbaki: are you one or many?
01:06:49 <Bourbaki> :)
01:06:56 <Bourbaki> can you model something like that with arrows?
01:09:18 <povman> you should be able to model it using haskell functions and recursion o_O
01:10:18 <Bourbaki> well i try to "fold" this kind of structure because i try to model recursion in this way in a coloured petri net like way
01:12:13 <povman> :t arr
01:12:18 <povman> arg
01:12:22 <Bourbaki> ?
01:14:57 <povman> i understandn't arrows
01:16:18 <hpaste>  morrow annotated "matching against regular expressions" with "awesome" at http://hpaste.org/8526#a1
01:18:15 <povman> Bourbaki: have you looked at Data.Graph?
01:18:38 <Bourbaki> povman : nope
01:19:02 <Bourbaki> its more of a general question i guess if this is in the model you get with arrows
01:20:19 <Bourbaki> i guess it would be something like (pseudoly speaking) edge1 >> (if (nil,*) then edge3 else (edge2 >> edge1))* or so
01:36:18 <vixey> ?docks QQ
01:36:27 <vixey> ?docs QQ
01:36:33 <vixey> `__`
01:36:37 <povman> lb is pwnt
01:37:08 <mauke> preflex: seen lambdabot
01:37:08 <preflex>  lambdabot was last seen on #haskell-blah 2 hours, 19 minutes and 47 seconds ago, saying: Title: YouTube - MC Hawking - A Brief History of Rhyme Commercial
01:37:18 <vixey> @docs QuasiQuotes
01:37:47 <vixey> can you nest QuasiQuotes?
01:38:31 <povman> vixey: can you imagine the semantics for that?
01:39:07 <quicksilver> it depends on the kind of QQ, surely.
01:39:16 <quicksilver> if the QQ itself embeds haskell fragments
01:39:32 <quicksilver> then those fragments might themself embed QQs in the same or even a different language.
01:39:41 <quicksilver> what are you trygint to acheive, vixey?
01:41:07 <vixey> well I couldn't find any documentation for QQ
01:42:51 <quicksilver> vixey: http://www.haskell.org/haskellwiki/Quasiquotation
01:45:29 <thoughtpolice> @seen gwern
01:45:43 <thoughtpolice> lambdabot is sick again?
01:45:53 <mauke> preflex: seen gwern
01:45:53 <preflex>  gwern was last seen on #haskell 5 hours, 14 minutes and 22 seconds ago, saying: @quote cabal
01:51:50 <mmorrow> vixey: you can certainly nest quasiquotes...but your parser attached to the quasiquotes would have to implem that, since ghc just hands your quote(Exp|Pat)Q a String
01:54:12 <mmorrow> ah, i see quicksilver beat me to it
01:55:35 <jfredett> ... I'm trying to compile lambdabot, it's complaining about array-0.1.0.0 being hidden, but I'm positive it's not (i've downloaded, recompiled and installed, and ghc-pkg expose'd it.)
01:55:48 <jfredett> is this a known issue, or have I broke something?
01:56:10 <maltem> jfredett: Check the build-depends field in the .cabal file
01:56:13 <quicksilver> that means the cabal file doesn't expose it.
01:56:24 <quicksilver> are you sure you're using the most recent lambdabot?
01:56:31 <jfredett> i darcs-got it
01:56:38 <jfredett> so I'm assuming yes
01:56:44 <mauke> from where?
01:56:44 <quicksilver> from which repo?
01:56:53 <jfredett> code.haskell.org, i think
01:57:02 <jfredett> tbh, i didnt check.
01:57:06 <jfredett> hang on
01:57:38 <jfredett> yes, i got it from code.haskell.org
01:59:16 <jfredett> shoot, I'm talking about hs-plugins, not \bot, I'm a moron
01:59:32 <jfredett> i got lost for a second
01:59:43 <jfredett> hs-plugins is giving me crap, \bot is not.
01:59:52 <jfredett> that I got from darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins there
02:00:10 <jfredett> perhaps thats on code... hmm
02:00:35 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
02:00:45 <quicksilver> @where hs-plugins
02:01:00 <quicksilver> jfredett: as I recall, that is the wrong site.
02:01:07 <quicksilver> the correct hs-plugins repo is on code.haskell.org
02:01:14 <jfredett> which would explain my issues... :)
02:01:24 <quicksilver> ah yes, visible at the url mauke posted
02:01:41 <quicksilver> dons: could I recommend you offline the unsw/~dons copy of hs-plugins?
02:01:52 <quicksilver> dons: loads of people appear to download it by mistake instead of the up-to-date one.
02:03:33 <jfredett> hang on... can i cabal install this? (with that nifty command line thing?)
02:04:52 <sjanssen> jfredett: yes
02:04:55 <jfredett> hmm, it seems to say there is no hs-plugins package.
02:04:59 <sjanssen> 'cabal install plugins' will dtrt
02:05:02 <jfredett> ahhh
02:05:34 <jfredett> I love this tool.
02:12:55 <povman> >34
02:13:03 <cjs> Oh dear. My first use of unsafePerformIO.
02:13:54 <maltem> jfredett: You can even try to cabal install lambdabot, 4.1 is quite recent
02:14:04 <quicksilver> bad cjs!
02:14:27 <jfredett> maltem: I want to mess around w/ the source, actually
02:14:44 <jfredett> does cabal install the source somewhere hackable, too?
02:15:02 <mauke> unsafePerformIO is the goto of Haskell
02:15:11 <jfredett> also, where is this elusive lambdabot.cabal.plugins thing I'm supposed to copy to the main cabal file?
02:15:40 <maltem> jfredett: Well it copies source distributions into .cabal/packages
02:15:42 <solrize> more like the self-modifying code ;)
02:16:01 <jfredett> hmm
02:16:29 <maltem> jfredett: Not very helpful anymore if you already darcs-got the package in question :)
02:16:38 <jfredett> yah
02:17:11 <dblhelix> cjs: don't you feel dirty? :-)
02:17:29 <hpaste>  cjs pasted "parse options for a filter program" at http://hpaste.org/8527
02:17:48 <cjs> It depends. Is what I just posted clever or stupid?
02:18:00 <cjs> (The way I deal with options that must be specified.)
02:18:20 <cjs> Actually, the unsafePerformIO doesn't make me feel so bad; it's just for a unit test.
02:18:29 <jfredett> so- if I compile \bot will it compile in the hs-plugin support?
02:18:30 <dblhelix> cjs: I see
02:18:50 <jfredett> i can't find lambdabot.cabal.plugins
02:18:53 <jfredett> :/
02:18:53 <cjs> I mean, if everything's working, there's no problem with it, and if everything's not, well, the test explodes as it should anyway.
02:21:24 <quicksilver> cjs: to me it seems strange that parseArgs is in IO at all.
02:21:32 <quicksilver> cjs: argument parsing sounds like a pure operation.
02:22:19 <quicksilver> cjs: the source of the problem is "optSource :: IO String", of course
02:22:27 <quicksilver> but why do you have optSource :: IO String?
02:22:51 <quicksilver> the only thing you appear to ever put it in it "return s"
02:27:23 <cjs> Because then you get a usage message if the optSource wasn't specified.
02:27:27 <cjs> "Automagically."
02:27:34 <therp> can someone tell me why Linux scheduling is SO broken? starving my emacs to death while ghc-6.8.2 runs with almost 100% cpu, so I can't even C-c it in the ghci buffer of emacs?
02:27:49 <cjs> It started out as undefined, but that just caused an explosion.
02:28:13 <cjs> My other option is to make it a Maybe String and have a special check for it, but this seemed like it might be cleaner.
02:28:24 <cjs> Like I said, I'm not sure if this is cool or stupid.
02:28:48 <slarba> therp: I think it's an emacs problem
02:29:11 <slarba> therp: you can go and pkill ghci from another terminal
02:29:12 <quicksilver> cjs: if you think IO String is cleaner than Maybe String then you have a totally broken definition of clean.
02:29:12 <maltem> therp: Not being able to C-c in ghci (or when running a ghc-compiled program) is something I experience independently of emacs or linux scheduling
02:29:25 <EvilTerran> cjs, i'd do that in the (Either String) monad, so my code was pure, and then have a trivial wrapper that translated Lefts to ioErrors
02:29:26 <cjs> Well....
02:29:27 <quicksilver> therp: that has nothing to do with linux scheduling, don't throw FUD around
02:29:52 <slarba> it happens sometimes on OSX too
02:29:52 <cjs> EvilTerran: Ah, that's better, isn't it!
02:29:58 <therp> slarba: not really. my whole desktop dies when ghc runs. xmonad takes about 30 seconds to switch to another terminal (which I blame on xmonad btw) however, linux scheduling does the wrong thing for ghc here
02:30:12 * EvilTerran finds sometimes ^C doesn't work at all, in ghci on windows.
02:30:18 <EvilTerran> but then usually ^break works
02:30:24 <therp> quicksilver: see above
02:30:27 <quicksilver> therp: when that has happened to me personally it's because emacs is waiting for a prompt string it isn't getting.
02:30:32 <slarba> therp: try to re-nice ghci process to lower priority
02:30:35 <slarba> ;)
02:30:36 <therp> it's not an emacs issue.
02:30:45 <rtra> quicksilver: C-c C-c ?
02:30:53 <quicksilver> rtra: no, emacs is waiting for a prompt string.
02:31:00 <quicksilver> this is not a subprocess interrupt issue.
02:31:13 <quicksilver> it's something of a deficiency in comint, or whatever it's called.
02:31:30 <quicksilver> that's the only time I've seen it.
02:31:47 <quicksilver> if I just get ghci to run at 100% by typing, for example, "last [1..]" I have no problem
02:32:00 <quicksilver> I can happily interrupt it in emacs, or outside of emacs, on linux or on OSX.
02:32:21 <quicksilver> if I run something memory leaking and start to use up all available memory that's much more painful.
02:32:30 <quicksilver> no OS I'm aware of handles out of memory gracefully.
02:32:46 <slarba> therp: and you can try to ulimit max. stack size
02:32:49 <therp> I guess it's eating memory at a high rate
02:32:58 <therp> still, I want to be able to stop that
02:33:01 <slarba> or max. size of a process
02:33:16 <quicksilver> OK, that's not linux's scheduler at fault.
02:33:20 <therp> there is no excuse for not allowing the user to kill processes that do the wrong thing
02:33:21 <quicksilver> that linux's VM system at fault.
02:33:31 <quicksilver> but like I say, I don't know of any OS which does it better.
02:33:35 <quicksilver> not much of an excuse.
02:33:45 <slarba> or... swapoff ;)
02:33:46 <quicksilver> all modern OSes collapse into a puddle if you stress the VM system.
02:33:57 <hpaste>  solrize pasted "how would you code this in haskell?" at http://hpaste.org/8528
02:33:57 <therp> I wouldn't call them modern then
02:34:04 <quicksilver> well they are modern.
02:34:09 <quicksilver> because they were recently released.
02:34:14 <quicksilver> that's all modern means :P
02:34:28 <solrize> yeah, linux is easier to wedge than old-time BSD systems were
02:34:41 <therp> however, it's a scheduler issue simply because I'm using hard disk encryption, hence swapping causes cpu load. in combination with ghc eating memory and CPU -> disaster
02:34:49 <povman> >3
02:34:53 <povman> AAAAA
02:35:15 <quicksilver> if you're running hard disk encryption then I suggest you set some rlimits.
02:35:40 <povman> quicksilver: karma++ yourself when lambdabot gets back, kthx
02:35:42 <povman> :)
02:36:05 <therp> quicksilver: that might work in practice however that's the wrong approach in my opinion.
02:36:26 <quicksilver> I agree a VM system which dealt more gracefully with a single process eating loads of memory woudl be nice.
02:36:31 <quicksilver> feel free to go write one
02:36:33 <therp> the problem is with not properly scheduling IO combined with the lack of CPU time.
02:36:38 <quicksilver> better men than me have tried and failed.
02:36:50 <solrize> i don't understand what was wrong with vax bsd
02:45:30 <jfredett> when trying to use > evaluation in \bot, I get a broken pipe error, is there instructions somewhere on how to deal with that (I'm concurrently trolling the provided docs.
02:46:02 <mm_freak_work> what's the topic?  recent linux kernels have good I/O schedulers and pretty fast crypto implementations
02:48:17 <Saizan> > 1
02:49:22 <jfredett> not this \bot, this \bot is dead
02:49:44 <jfredett> my local lambdabot, she's in blah if you want to see for yourself
02:49:49 <solrize> so is it a mistake for me to use mmap to jump around in a file that's bigger than memory?
02:50:02 <jfredett> i didnt want to spam any semi-active channels with join/parts
02:50:45 <mapreduce> > 1
02:50:47 <lambdac>  1
02:50:55 <jfredett> hmm
02:51:10 <solrize> i think there are so many join/parts on this channel that a few more won't make any difference.  we are all either used to it or have turned off the messages (like i did)
02:51:45 <mapreduce> lambdac is dobblego's, let me, Apocalisp or him know if you want it removed, and are not an op. :)
02:52:04 <mm_freak_work> solrize: it's a mistake to jump at all…  if you can, read a file sequentially…  if you can't, jump as seldomly as possible
02:52:22 <mm_freak_work> use seeking to jump, not mmap, because then you can control, where and when you jump
02:52:55 <quicksilver> mm_freak_work: therp's claim is that the behaviour of a process which is very rapidly requesting more memory is suboptimal; he uses hard disk encryption on his swap partition, so the rapid paging creates CPU demand and he can't successfully kill the process
02:53:56 <mm_freak_work> quicksilver: a process doing that would be killed without problems…  it would need to actually use the memory, otherwise it's not allocated, but just committed
02:54:01 <mapreduce> I find that on Windows when using Scala.  Stream from 1 find (_==-1) is quite hard to kill.
02:54:02 <solrize> mm_freq i have to jump, and i also have to munch on lots of little segments of the file simultaneously, which means if i don't use mmap then i may have to duplicate file descriptors all over the place
02:54:50 <quicksilver> mm_freak_work: yes, it's actually using the memory
02:54:59 <quicksilver> mm_freak_work: it's a runaway haskell program with a rapid memory leak, say.
02:55:14 <quicksilver> mm_freak_work: anything talk to therp about it, I'm only relayign what he said :)
02:55:19 <quicksilver> solrize: does not compute.
02:55:25 <mm_freak_work> solrize: then at least jump only forward and never backward…  or reconsider your file format design
02:55:37 <quicksilver> solrize: I see no connection between not using mmap and need duplicate file descriptors.
02:56:18 <solrize> well let's say there are several runs of data in distinct places in the file, and i want to merge them or lazily zip them or something like that
02:56:42 <solrize> yeah i guess i could share an fd between the lazy streams somehow
02:56:46 <solrize> doesn't seem functional :)
02:56:50 <quicksilver> eh
02:56:57 <quicksilver> lazily zip + IO ?
02:57:02 <quicksilver> sounds like a terrible idea.
02:57:06 <quicksilver> laziness and IO are poor bedfellows.
02:57:13 <quicksilver> think carefully before making a plan like that ;)
02:57:35 <quicksilver> laziness and IO which is jumping all around over a file sounds like even worse than usual...
02:57:48 <solrize> thus mmap looks attractive :)
02:58:37 <quicksilver> yes :)
02:58:51 <solrize> i guess i could simulate laziness with some state monads or so...
02:59:45 <mm_freak_work> you really don't want laziness at all…  you want imperative code here
03:00:09 <solrize> i mean the program just starts looking like a c program if i do that, with some buffers and pointers moving through them, blech
03:01:08 <solrize> it works out fairly nicely with python streams
03:01:16 <solrize> so i'd have expected it to be even better in haskell
03:01:24 <solrize> but my understanding is not up to it
03:02:15 <solrize> i also couldn't figure out a clean way to have an if..elif..elif chain with i/o actions in the branches.  is there a standard way to do that?
03:02:48 <Saizan> use guards
03:03:20 <mm_freak_work> solrize: yes, and that's exactly what you want here…  if not, drop the file format and make a better one
03:04:03 <mm_freak_work> about the if/elif…  i just use 'case'
03:04:45 <solrize> but can you have    a <- foo   in the case branches?
03:05:28 <Deewiant> ?ty \qux bar foo -> case qux of bar -> do a <- foo; print a
03:05:30 <lambdac> forall t t1 t2. (Show t2) => t -> t1 -> IO t2 -> IO ()
03:05:43 <solrize> hmm
03:06:05 <solrize> thanks i'll see if i can do that
03:08:40 <solrize> i end up with ugly nested case expressions
03:08:46 <solrize> but i guess it's workable
03:08:53 <quicksilver> solrize: you can have <- anywaher you can have an expression.
03:09:05 <quicksilver> since you can put a do block anywhere you can put an expression.
03:09:22 <quicksilver> as mm_freak_work says, trygin to get the resource usage right in a program like this is probably an imperative problem solving exercise
03:09:31 <quicksilver> however it's normally easy to get the haskell looking much nicer than the python
03:09:31 <solrize> ic, i didn't realize the lambda binding would persist through the rest of the expression
03:09:45 <quicksilver> the powerful abstraction features are still a win.
03:09:52 <quicksilver> and so are custom monads, sometimes.
03:10:37 <solrize> yeah, i spent a couple days coding this in haskell, a long hard slog til i got stuck with the file i/o stuff, switched to python and got that working (but dog slow), now want to go back to haskell
03:10:55 <solrize> seeking takes about 70 microseconds even when the file is completely cached in ram
03:11:02 <solrize> because of the system call
03:11:32 <mm_freak_work> solrize: y <- case x of _ -> return 3
03:12:14 <solrize> i figure each user query will need a few dozen seeks, which is tolerable
03:12:38 <mm_freak_work> what is it?  a database file?
03:12:45 <solrize> yeah sorta
03:13:16 <mm_freak_work> a static one?
03:13:33 <solrize> the file is built by a huge java program, so yeah, static as far as i'm concerned
03:15:59 <chylli`> where is 'sleep' in haskell ?
03:16:13 <chylli`> and how to find something in haskell lib ?
03:16:20 <solrize> @hoogle sleep
03:16:21 <lambdac> A Hoogle error occured.
03:16:25 <jfredett> hoogle
03:16:30 <chylli`> solrize: find nothing
03:16:35 <lomeo> @hoogle delay
03:16:36 <lambdac> A Hoogle error occured.
03:16:42 <solrize> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
03:16:43 <jfredett> I think it's haskellwiki.com/hoogle
03:16:44 <jfredett> or something
03:16:44 <lambdac> http://tinyurl.com/2rgl8s
03:16:50 <mapreduce> @hoogle map
03:16:51 <lambdac> A Hoogle error occured.
03:16:53 <mapreduce> Ah.
03:17:08 <solrize> finds several sleeps
03:17:08 <jfredett> google it, you should find it
03:18:49 <mm_freak_work> @type threadDelay
03:18:51 <lambdac> Not in scope: `threadDelay'
03:18:56 <mm_freak_work> @hoogle threadDelay
03:18:57 <lambdac> A Hoogle error occured.
03:19:06 <mm_freak_work> @go haskell threadDelay
03:19:09 <lambdac> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
03:19:43 <mm_freak_work> solrize: if it's static, i'd build a lookup table, maybe as a binary tree
03:20:03 <mm_freak_work> if that's already there, consider splitting it up into multiple files
03:20:23 <chylli`> solrize: I find nothing
03:20:24 <solrize> i don't see how multiple files help unless i can get some more machines
03:20:42 <solrize> the amount of data is substantially bigger than available ram
03:20:49 <mm_freak_work> it helps in that the OS scheduler does a much better work
03:21:11 <solrize> you mean to have separate file handles on the different segments?
03:21:28 <quicksilver> @go hoogle
03:21:30 <lambdac> http://www.haskell.org/hoogle/
03:21:30 <lambdac> Title: Hoogle
03:21:34 <quicksilver> that's where hogle is
03:21:50 <solrize> chylli` http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Unistd.html#v%3Ausleep
03:21:52 <lambdac> http://tinyurl.com/4y6alz
03:22:43 <mm_freak_work> solrize: multiple file handles to the same file is a lot different from multiple file handles into multiple files
03:22:43 <quicksilver> chylli`: POSIX sleep is not idiomatic though
03:22:45 <quicksilver> use threadDelay.
03:22:58 <solrize> mm_freak_work hmm, that hadn't occurred to me
03:23:19 <solrize> multiple handles to the same file is worse?
03:23:35 <chylli`> quicksilver: ok, thanks. but why so many functions with same function ?
03:23:51 <mm_freak_work> solrize: yes
03:23:57 <quicksilver> chylli`: one is a concurrent haskell function which is cross platform and appropriate for haskell use.
03:23:59 <solrize> if i get really serious about this i want to use AIO
03:24:04 <quicksilver> the other is an import of a POSIX api
03:24:14 <chylli`> quicksilver: thanks
03:24:48 <solrize> but seeking on multiple file handles will do for the moment :)
03:24:58 <solrize> what if i have concurrent threads?
03:25:22 <mm_freak_work> solrize: if your OS is fully busy with I/O, it handles the case best, where one file is read sequentially, and the case worst, where one file is read backwards…  reading multiple files sequentially works much better than jumping around in a single file
03:25:38 <mm_freak_work> seeking forward is also ok, but never backward
03:26:01 <mapreduce> Why not backward?
03:26:12 <solrize> OS probably does some predictive readahead
03:26:24 <solrize> mm_freak_work that sounds reasonable
03:26:27 <chylli`> quicksilver: is thread in haskell same as process in unix or same as thread in unix ?
03:26:32 <quicksilver> chylli`: No.
03:26:38 <quicksilver> chylli`: haskell threads are lightweight.
03:26:42 <mm_freak_work> mapreduce: because disks are supposed to give the best performance, when read sector by sector in a forward direction, and so is the OS
03:26:43 <solrize> chylli` lightweight userspace threads, you can have millions of them
03:27:18 <chylli`> quicksilver: solrize: ok, I need read some docs. thanks.
03:27:21 <mm_freak_work> solrize: threads won't change much…  you're just semi-parallelizing a task, which is sequential anyway
03:27:39 <mapreduce> ok, thanks.
03:27:43 <solrize> i think i really can't avoid doing multiple reads from different parts of the same file
03:28:02 <solrize> but i could arrange to do them in increasing order i guess
03:28:16 <solrize> it looks like the largest blocks are a few dozen MB
03:28:18 <chylli`> quicksilver: can u give some article url about haskell concurrency ?
03:28:18 <quicksilver> be aware that whilst mm_freak_work's advice is very accurate
03:28:23 <quicksilver> it's also micro-optimisation.
03:28:24 <Armored_Azrae1> Hey, I suppose this isn't the exact place for it, but do you guys know anyone I could talk to about syntax design? I'm trying my hand at making a language for fun.
03:28:41 <quicksilver> it's not going to make the blindest bit of difference unless your app is actually IO bound in practice
03:28:42 <Armored_Azrae1> I can express syntax, but without copying someone else's, I don't know how to make a good syntax
03:29:06 <solrize> the app is extremely io bound at the moment but with this new setup i hope it will be less so
03:29:08 <quicksilver> chylli`: http://www.haskell.org/haskellwiki/GHC/Concurrency
03:29:09 <lambdac> Title: GHC/Concurrency - HaskellWiki
03:29:15 <quicksilver> solrize: ah fair enough :)
03:29:17 <mapreduce> Armored_Azrae1: I don't know where to talk about it but I'd probably start by playing with lisp macros, or forth.
03:29:23 <quicksilver> in that case mm_freak_work's advice is extremely relevant.
03:29:37 <solrize> well it's io bound now because it does 1000's of seeks :(
03:30:31 <solrize> i think the new setup will do on the order of 1-2 dozen seeks, and some large reads with each seek
03:30:53 <cjs> What's the generic way to do this on a list of os: return defaultOptions >>= (os!!0) >>= (os!!1)
03:30:56 <solrize> and i had the idea of doing those reads lazily but i have enough ram to hold all the data from the reads
03:31:01 <solrize> in most cases, i think
03:31:14 <quicksilver> :t foldM
03:31:16 <lambdac> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:31:27 <cjs> Ah, I thought that might be it.
03:31:42 <nornagon> :t sequence
03:31:44 <lambdac> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:31:56 <quicksilver> nornagon: sequence doesn't pipe the values form one to next
03:32:01 <nornagon> ah, right
03:32:10 <cjs> And the function is (flip id), but I'm not entirely clear on that....
03:32:55 <mm_freak_work> Armored_Azrae1: well, there isn't much to invent left…  it's not a bad thing to copy from others
03:33:41 <mmorrow> > let f = flip id in 8 `f` (*2)
03:33:43 <lambdac>  16
03:34:02 <mmorrow> > let ($) = (flip . flip) id in (*2) $ 8
03:34:06 <lambdac>  16
03:34:25 <Armored_Azrae1> mm_freak_work: I'm not trying to be too inventive with the syntax (the main thing I'm playing with is ways to mix pure and impure code), it's just that flat taking syntax seems kind of silly
03:34:44 <cjs> Hm. But flip takes an (a -> b -> c) and id is only an (a -> a).
03:35:12 <mmorrow> but (flip . flip) id /= id
03:35:19 <mmorrow> :t id
03:35:21 <lambdac> forall a. a -> a
03:35:22 <mmorrow> :t flip id
03:35:24 <lambdac> forall b c. b -> (b -> c) -> c
03:35:29 <mmorrow> :t (flip . flip) id
03:35:31 <lambdac> forall b c. (b -> c) -> b -> c
03:35:35 <mmorrow> :t fix
03:35:37 <lambdac> forall a. (a -> a) -> a
03:35:38 <mmorrow> :t flip fix
03:35:41 <lambdac> forall b c. b -> ((b -> c) -> b -> c) -> c
03:35:43 <mmorrow> :t (flip . flip) fix
03:35:46 <lambdac> forall b c. ((b -> c) -> b -> c) -> b -> c
03:35:51 <mm_freak_work> Armored_Azrae1: mixing pure with impure code…  well, that sounds like monads or what the Clean language calls
03:35:55 <cjs> I can see that flip id is the right type, but I'm not clear on how id got flipped.
03:35:55 <mm_freak_work> 'uniqueness types'
03:37:41 <mmorrow> cjs: yeah, it's weird
03:38:54 <cjs> Well, we are applying id to a function, so maybe there's something going on there.
03:38:54 <Armored_Azrae1> mm_freak_work: General idea is that the only difference is you declare one pure in the type signature, it can only call pure functions, so in the engine portion of the application you get nice typesafety and other such things, and might be evaluated with a different engine, and then the input/output communication stuff is done outside of pure land entirely, allowing you to keep application state and similar easily.
03:39:29 <mapreduce> > flip id
03:39:31 <lambdac>  Add a type signature
03:39:38 <siponen> Locky yous . I wont have holiays... :( I'm stuck here at tyrennean coast all summer
03:39:41 <mapreduce> > flip id :: Integer -> Integer
03:39:43 <lambdac>  Couldn't match expected type `Integer'
03:39:56 <hpaste>  solrize annotated "how would you code this in haskell?" with "i guess this isn't too bad" at http://hpaste.org/8528#a1
03:40:04 <mm_freak_work> Armored_Azrae1: i'm not sure, but that might defeat a lot of the flexibility of being able to mix both worlds in a functional way
03:40:31 <mmorrow> so working in reverse, flip id ==> b -> (b -> c) -> c ==> a in id::a->a was inferred as (b->c), and since (b->c)->(b->c) == (b->c)->b->c, flip that is b -> (b->c) -> c
03:40:47 <mm_freak_work> Armored_Azrae1: for example, with monads i can easily create a statusbar, which shows the progress of indexing a list
03:40:48 <mmorrow> s/inferred/unified/
03:41:51 <mmorrow> the tricky part is how the a expands to (b->c)
03:42:33 <mmorrow> i didn't understand how ghc was doing what it does with flip id until i wrote a unifier myself
03:42:42 <mmorrow> then i was like ohhhhh
03:43:28 * cjs is thinking heavily.
03:44:27 <cjs> Ahgh. I see the problem. The parens in the type definition of flip don't matter!
03:44:48 <mm_freak_work> cjs: if a = b -> c, then a -> a = (b -> c) -> b -> c
03:44:53 <siponen> IOops.
03:44:58 <ziman> -> is right-associative
03:45:20 <mm_freak_work> so you can flip the identity of functions
03:45:52 <mmorrow> cjs: kinda. that's the other tricky part with flip id=> going from (b->c)->(b->c) to (b->c)->b->c so i know what you are talking about, but i'm not sure if the way you phrased it is correct
03:47:11 <mmorrow> (a -> b -> c) -> (b -> a -> c) does indeed equal (a -> b -> c) -> b -> a -> c
03:47:22 <mm_freak_work> :t flip id (sin)
03:47:24 <lambdac> forall c a. (Floating a) => ((a -> a) -> c) -> c
03:48:19 <cjs> No, I'm still confused.
03:48:59 <cjs> Because they do matter to the degree that flip is not a -> b -> c -> b -> a -> c, right?
03:50:35 <mmorrow> cjs: that's the part that i had issue with what you said, i though you might have meant that. so yes to "Because they do matter to the degree that flip is not a -> b -> c -> b -> a -> c, right?"
03:51:12 <audreyt> dons: is there a reason why pcre-light wants to -fvia-C? GHC 6.8.3 on macintel fails in .Base with via-C but compiling with -O2 is fine
03:51:19 <audreyt> @seen dons
03:51:20 <lambdac> dons is in #haskell. I don't know when dons last spoke.
03:51:27 <audreyt> @tell dons is there a reason why pcre-light wants to -fvia-C? GHC 6.8.3 on macintel fails in .Base with via-C but compiling with -O2 is fine
03:51:27 <lambdac> Consider it noted.
03:51:50 <mm_freak_work> :t flip id id
03:51:51 <lambdac> forall c a. ((a -> a) -> c) -> c
03:52:11 <mercury^> @tell mercury blah
03:52:13 <mm_freak_work> :t flip id id id
03:52:13 <Saizan> (->) is right associative, so a -> b -> c -> d == a -> (b -> (c -> d)), but different from (((a -> b) -> c) -> d)
03:52:13 <lambdac> forall a. a -> a
03:52:14 <lambdac> Consider it noted.
03:52:18 <mm_freak_work> :t flip id id id 0
03:52:20 <lambdac> forall a. (Num a) => a
03:52:23 <mm_freak_work> > flip id id id 0
03:52:25 <lambdac>  0
03:52:30 <mercury^> argh, wrong nick
03:53:35 <audreyt> mmorrow: thanks for beating me to it re regexqq :)
03:53:37 <mm_freak_work> > flip id id (const sin) 1
03:53:37 <lambdac>  0.8414709848078965
03:53:42 <audreyt> mmorrow: now if only you can do a haskellqq...
03:53:53 <mmorrow> audreyt: :)
03:54:09 <mmorrow> audreyt: your patch is great!
03:54:10 <audreyt> (involves a simple translation of haskell-src-exts's HsExp -> ExpQ)
03:54:16 <audreyt> thanks! :D
03:54:41 <mmorrow> audreyt: audreyt, it's funny you meantion that. i've been working on a haskell qq for a few weeks off and on.
03:55:04 <audreyt> oh joy
03:55:05 <mmorrow> i've got about 70% of haskell-src-exts -> TH.Syntax done :)
03:55:12 <audreyt> I have about 7%
03:55:17 <mmorrow> hehe
03:55:24 <audreyt> so I'll simply wait for your hackage relase
03:55:26 <audreyt> mmorrow++
03:55:31 <mmorrow> :)
03:55:31 <Baughn> A StorableArray claims to be slower than a normal Array. Why is this?
03:56:10 <cjs> Gah. I'm going to give up on this flip id thing and try again later.
03:56:21 <cjs> For now, this is yet more Haskell magic.
03:56:45 <Baughn> The Storable constraint for elements requiring it to (de)serialize elements on every access? I suppose that would do it..
03:57:23 <mm_freak_work> cjs: it's not that magic
03:57:36 <cjs> Makes my head hurt!
03:57:40 <mm_freak_work> just that it isn't extremely useful =)
03:57:52 <mm_freak_work> :t flip id
03:57:54 <lambdac> forall b c. b -> (b -> c) -> c
03:58:29 <idnar> :t id
03:58:31 <lambdac> forall a. a -> a
03:58:33 <mm_freak_work> a must be the same as b -> c, so the type of 'flip' becomes:  a -> a = (b -> c) -> (b -> c)
03:58:41 <idnar> :t id :: (a -> b) -> (a -> b)
03:58:43 <lambdac> forall a b. (a -> b) -> a -> b
03:59:02 <mm_freak_work> a function mapping a function to a function, or in other words:  a function with two parameters
03:59:14 <mm_freak_work> (b -> c) -> b -> c
03:59:37 <mm_freak_work> 'flip' flips the arguments of that function:  b -> (b -> c) -> c
03:59:44 <cjs> Oh!
04:00:00 * cjs feels a lightbulb turn on above his head.
04:00:01 <mm_freak_work> 'id' is restricted to the identity of functions here
04:00:14 <cjs> " a must be the same as b -> c" was what did it for me. Thanks.
04:00:39 <cjs> you just do that substitution on the type signature of flip and it becomes obvious.
04:00:50 <mm_freak_work> yes
04:00:59 <mmorrow> cjs: yay!
04:01:03 <solrize> oh cool, i never really understood that before either
04:01:42 <Deewiant> I was just thinking this morning about how 'flip id' and 'uncurry id' are actually pretty cool :-)
04:01:55 <cjs> Or you can say that c must be the same as a -> b.
04:02:07 <Baughn> @type flip id
04:02:09 <lambdac> forall b c. b -> (b -> c) -> c
04:02:14 <cjs> Agh! "uncurry id"? Not another one!
04:02:35 <Baughn> cjs: Don't worry. You can use uncurry ($) instead.
04:03:17 <mmorrow> or of course,
04:03:20 <mmorrow> :t uncurry ((flip . flip) id)
04:03:22 <lambdac> forall b c. (b -> c, b) -> c
04:04:05 <Baughn> ..wait, what
04:04:19 <mmorrow> > let ($) = (flip . flip) id in (*2) $ 8
04:04:21 <lambdac>  16
04:04:34 <Baughn> > (uncurry ((flip.flip) id) \x -> ('a',x)
04:04:35 <lambdac> Unbalanced parentheses
04:04:55 <cjs> Agh!
04:06:56 <mm_freak_work> > flip id 3 sin
04:06:56 <lambdac>  0.1411200080598672
04:06:56 <Baughn> > (uncurry ((flip.flip) id)) \x -> ('a',x)
04:06:56 <lambdac>  Parse error at "\x" (column 28)
04:06:56 * cjs 's head explodes.
04:06:56 <mm_freak_work> > uncurry id (3,4)
04:06:56 <mmorrow> > (uncurry ((flip.flip) id)) (\x -> ('a',x)) 9
04:06:56 <lambdac>   add an instance declaration for (Num (b -> c))
04:06:56 <lambdac>      The lambda expression `\ x -> ...' has one argument,
04:06:56 <lambdac>     but its type `(...
04:06:56 <Baughn> > (uncurry ((flip.flip) id)) \x -> ('a',x)
04:06:56 <lambdac>  Parse error at "\x" (column 28)
04:06:56 <mm_freak_work> :t uncurry
04:06:56 <lambdac> forall a b c. (a -> b -> c) -> (a, b) -> c
04:06:56 <cjs> But yeah, I still have a lot of trouble with a type "a" that's actually a function type.
04:06:56 <Baughn> > (uncurry ((flip.flip) id)) \foo -> ('a',foo)
04:06:56 <lambdac>  Parse error at "\foo" (column 28)
04:06:56 <Baughn> ..what's with this thing?
04:06:56 <Baughn> Hang on, lambdac?
04:06:56 <mmorrow> > (uncurry $ (flip.flip) id) (\x -> ('a',x),9)
04:06:56 <lambdac>  ('a',9)
04:06:56 <Saizan> cjs: 'a' is a variable, it can become anything
04:06:56 <mm_freak_work> cjs: nothing troublesome actually, since it's simple algebra =)
04:06:56 <cjs> Yeah, but it rarely occurs to me to do it.
04:07:52 <mmorrow> whoa, would this be the id "lense"?
04:07:55 <mmorrow> :t :t flip (uncurry ((flip . flip) id) . swap)
04:07:57 <lambdac> parse error on input `:'
04:07:58 <mmorrow> :t flip (uncurry ((flip . flip) id) . swap)
04:08:00 <lambdac> Not in scope: `swap'
04:08:17 <mmorrow> :t let swap = (\(a,b)->(b,a)) in flip (uncurry ((flip . flip) id) . swap)
04:08:19 <lambdac> forall b b1 c. b1 -> (b, b -> b1 -> c) -> c
04:08:39 <mmorrow> :t let swap = (\(a,b)->(b,a)) in flip (uncurry ((flip . flip) id) . swap) :: a -> (b, b -> a) -> a
04:08:41 <lambdac>     Occurs check: cannot construct the infinite type: a = a -> a
04:09:04 <mm_freak_work> :t flip (flip id)
04:09:06 <lambdac> forall a c. (a -> c) -> a -> c
04:09:10 <mmorrow> umm, now i confused myself
04:09:17 <mm_freak_work> > flip (flip id) sin 3
04:09:18 <lambdac>  0.1411200080598672
04:09:43 <mmorrow> uh, i think a lense is actually  a -> (b, b -> a)
04:10:47 <mmorrow> @pl \(a,b)->(b,a)
04:10:48 <lambdac> uncurry (flip (,))
04:11:07 <mm_freak_work> it's often useful to reverse things
04:11:14 <mm_freak_work> :t curry . uncurry $ id
04:11:16 <lambdac> forall b c. (b -> c) -> b -> c
04:11:38 <mm_freak_work> it gives proper restrictions
04:12:09 <mm_freak_work> :t uncurry id (sin, 3)
04:12:11 <lambdac> forall b. (Floating b) => b
04:12:13 <mm_freak_work> > uncurry id (sin, 3)
04:12:15 <lambdac>  0.1411200080598672
04:13:21 <mm_freak_work> > uncurry (flip id) (3, sin)
04:13:22 <lambdac>  0.1411200080598672
04:14:34 <mm_freak_work> 'id' is being the identity on functions again, uncurry makes a tuple out of the two arguments (the function and its argument)
04:15:32 <mm_freak_work> (id sin) 3 = id sin 3, so uncurried, the two arguments become a tuple:  uncurry id (sin, 3)
04:15:35 <mmorrow> i think this is equiv to flip itself:
04:15:38 <mmorrow> :t let flip3 f = \a c b -> f a b c  in (flip3 . flip . flip3) (curry (flip uncurry))
04:15:40 <lambdac> forall a b c. (a -> b -> c) -> b -> a -> c
04:15:43 <mmorrow> :t flip
04:15:45 <lambdac> forall a b c. (a -> b -> c) -> b -> a -> c
04:16:20 <Deewiant> @check \f x y -> let flip3 g = \a c b -> g a b c in (flip3.flip.flip3) (curry (flip uncurry)) f x y
04:16:21 <lambdac>  Add a type signature
04:16:36 <Deewiant> @check \f x y -> let flip3 g = \a c b -> g a b c in (flip3.flip.flip3) (curry (flip uncurry)) f (x :: Int) (y :: Int) == flip f x y
04:16:38 <lambdac>  OK, passed 500 tests.
04:16:44 <Deewiant> @scheck \f x y -> let flip3 g = \a c b -> g a b c in (flip3.flip.flip3) (curry (flip uncurry)) f (x :: Int) (y :: Int) == flip f x y
04:16:55 <lambdac>   Completed 169 test(s) without failure.
04:17:06 <mmorrow> oh yeah!
04:17:34 <mmorrow> @pl \f a c b -> f a b c
04:17:34 <lambdac> (flip .)
04:17:37 <mmorrow> haha
04:17:56 <mmorrow> :t ((flip .) . flip . (flip .)) (curry (flip uncurry))
04:17:58 <lambdac> forall a b c. (a -> b -> c) -> b -> a -> c
04:18:03 <mmorrow> @pl ((flip .) . flip . (flip .)) (curry (flip uncurry))
04:18:04 <lambdac> flip . flip (flip . curry (flip uncurry))
04:18:45 <mmorrow> little does @pl know...(evil laughter)
04:18:59 <Saizan> you didn't have to use @check, there's only one total function of that type :)
04:19:27 <mmorrow> Saizan: that does actually make perfect sense.
04:19:44 <mmorrow> Saizan: i've never thought about it that way
04:20:24 <mm_freak_work> @help @check
04:20:24 <lambdac> help <command>. Ask for help for <command>. Try 'list' for all commands
04:20:26 <mm_freak_work> @help check
04:20:27 <lambdac> check <expr>
04:20:27 <lambdac> You have QuickCheck and 3 seconds. Prove something.
04:20:41 <Saizan> prametricity gives you some guarantees, like naturality in CT
04:20:59 <mm_freak_work> @check id
04:21:01 <lambdac>  Arguments exhausted after 0 tests.
04:21:06 <Saizan> @go theorems for free
04:21:08 <atsampson> surely you can't prove anything with QuickCheck; only disprove things...
04:21:09 <lambdac> http://citeseer.ist.psu.edu/wadler89theorems.html
04:21:10 <lambdac> Title: Theorems for Free! - Wadler (ResearchIndex)
04:21:28 <jbapple> @help ft
04:21:29 <lambdac> ft <ident>. Generate theorems for free
04:22:04 <jbapple> @ft ﻿(a -> b -> c) -> b -> a -> c
04:22:06 <lambdac>  fd:15: hClose: resource vanished (Broken pipe)
04:22:30 <jbapple> Ceci n'est pas use theorem.
04:22:35 <jbapple> *une
04:23:31 <mmorrow> atsampson: except in the case of where one test passing implies that all tests will pass
04:23:56 <mmorrow> (and likewise one failure implies all will fail)
04:24:10 <solrize> if i have   newtype Foo = Foo { unFoo :: Bar }     then does ghc sensibly turn "map unFoo" into a no-op ?
04:24:13 <jbapple> mmorrow: What does _|_ have to say about that?
04:24:18 <quicksilver> solrize: yes.
04:24:20 <mmorrow> but in those cases, quickcheck wouldn't really be a necessity i guess
04:24:24 <solrize> cool :)
04:24:27 <quicksilver> solrize: only, no.
04:24:28 <quicksilver> ;)
04:24:28 <jbapple> @go fast and loose reasoning is morally correct
04:24:31 <mmorrow> jbapple: hmm
04:24:31 <lambdac> http://citeseer.ist.psu.edu/733155.html
04:24:32 <lambdac> Title: Fast and Loose Reasoning is Morally Correct - Danielsson, Hughes, Jansson, Gibbo ...
04:24:40 <solrize> oh :(
04:24:41 <quicksilver> solrize: it's a no-op as long as it fuses with something else.
04:24:46 <jbapple> @go free theorems in the presence of seq
04:24:47 <quicksilver> in isolation it's like (map id)
04:24:49 <lambdac> http://citeseer.ist.psu.edu/660356.html
04:24:49 <lambdac> Title: Free Theorems in the Presence of seq - Johann, Voigtlander (ResearchIndex)
04:24:54 <quicksilver> and (map id) still creates a new list.
04:25:10 <quicksilver> but if there is something else for it to fuse with, it's free.
04:25:19 <solrize> hmm
04:25:23 <EvilTerran> need a {-# RULE map id = id #-} (or whatever the syntax is)
04:25:43 <mmorrow> jbapple: i think then you'd have to take into account undefined and a nonundefined value
04:25:45 <solrize> seems sort of silly, is it just something that ought to get fixed sooner or later?
04:25:53 <quicksilver> solrize: No, not really.
04:26:03 <quicksilver> it doesn't matter in practice.
04:26:11 <quicksilver> in practice it fuses.
04:26:12 <EvilTerran> expression equivalence is undecidable, so that can't be done in general
04:26:31 <quicksilver> it can't be done at the core level, because at the core level it *isn't* id.
04:26:37 <quicksilver> at core level, the types are distinct.
04:26:46 <quicksilver> it has to be done at code-gen.
04:26:48 <jbapple> mmorrow: I don't know the details, but the citeseer papers above do
04:27:24 <solrize> hmm ok i haven't thought about what it might fuse with but it sounds plausible
04:27:35 <mmorrow> jbapple: looking at the ps now..
04:28:29 <mmorrow> haha, just saw this "@go fast and loose reasoning is morally correct"
04:28:59 <EvilTerran> solrize, if you're that bothered, you could add {-# RULES
04:29:00 <EvilTerran>  "map unFoo" map unFoo = unsafeCoerce #-} or something
04:29:08 <EvilTerran> er, random linebreak
04:29:32 <quicksilver> but it's a strange thing to worry about.
04:29:34 <quicksilver> in isolation.
04:29:36 <EvilTerran> indeed
04:29:45 <quicksilver> maybe that's a quirk of mine; I find it hard to worrya bout things in isolation.
04:30:04 <solrize> evilterran i think i don't really care for the time being, it will be pretty fast even if it conses a list
04:30:06 <quicksilver> Give me a practical program in which it actually matters and I'll either suggest another approach or agree it genuinely is a problem :)
04:30:10 <EvilTerran> no, that makes sense. gotta profile in context before you start doing exotic optimisations
04:30:49 <solrize> it just seemed like something the compiler could easily do by noticing that unFoo is a no-op
04:31:00 <quicksilver> FSOV of "easily", yes.
04:31:11 <quicksilver> but you appreciate this can't happen in the typed language, because it's a type violation.
04:31:19 <quicksilver> it's got to wait until types have been erased.
04:31:35 <quicksilver> however it it fuses with something else before then it all becomes moot anyway
04:32:22 <solrize> if i have just (unFoo x) instead of map unFoo, it's different?
04:32:33 <quicksilver> (unFoo x) still exists in core
04:32:39 <quicksilver> but doesn't actually generate any code
04:32:44 <quicksilver> there is nothing to do.
04:33:06 <quicksilver> because core is typed, it exists in core for the same reason it exists in haskell.
04:33:32 <solrize> so codegen removes it
04:34:04 <solrize> hmm
04:36:20 <Saizan> this reminds me of the bug with newtype deriving + type families sorear found
04:36:31 <solrize> what was that?
04:36:46 <cjs> Ah, "uncurry id" is cool.
04:36:57 <cjs> Anyway, time for dinner. Ciao!
04:37:14 <EvilTerran> @unpl uncurry id
04:37:15 <lambdac> uncurry (\ a -> a)
04:37:21 <EvilTerran> hmpf
04:37:21 <quicksilver> solrize: I woudln't say codegen removes it.
04:37:27 <quicksilver> solrize: it isn't there to start with.
04:37:28 <EvilTerran> ?type uncurry id
04:37:30 <lambdac> forall b c. (b -> c, b) -> c
04:37:42 <EvilTerran> ah... so, uncurry ($), then. that makes more sense
04:37:44 <quicksilver> solrize: codegen generates no code for it.
04:38:02 <EvilTerran> codegen has no code to generate for it
04:38:05 <solrize> well how is it that map (no code) = code?
04:38:07 <quicksilver> exactly.
04:38:18 <EvilTerran> map is code
04:38:19 <quicksilver> map (id) is code as well
04:38:21 <quicksilver> although id is no code.
04:38:27 <quicksilver> this is not a contradiction.
04:38:44 <solrize> right that just seems like a simple optimization
04:42:25 <Baughn> Well, how often do you map over a list and then proceed to do nothing with the result? If you /do/ do something, it'll probably fuse
04:42:34 <Baughn> And if you don't, lazyness gets rid of it
04:43:13 <Baughn> So it might be a simple optimization that has no actual value
04:45:15 <solrize> yeah, I guess it should fuse.  Bar is actually Char, so map unFoo makes a string
04:45:49 <solrize> maybe i should try to keep it in bytestrings however most of these strings should be pretty short
04:46:23 <Baughn> Bytestrings are handy. It's not as if you can output utf-8 without feeding it through a library /anyway/.
04:47:22 <solrize> so B.pack (map unFoo x) may be the easiest approach
04:47:23 <MarcWeber> How to rewrite do let a = 7 \n print a    with { and ; so that it fits into one line? (of course I can use let a ... in ) but why doesn't do { let a = 7; print a } work?
04:47:50 <solrize> as opposed to trying to assemble a byte string in a single action
04:48:14 <Saizan> ?ty do  let {a = 7}; print a
04:48:14 <solrize> will that (above) fuse?
04:48:15 <lambdac> IO ()
04:48:47 <solrize> > do { let a=7; print a }
04:48:48 <lambdac>  Parse error at "}" (column 23)
04:48:50 <smg> hello.
04:48:52 <smg> byorgey: hi
04:49:03 <TSC> do { let { a = 7 } ; print a }
04:49:05 <TSC> is what you want
04:49:12 <MarcWeber> Thanks Saizan
04:49:28 <Baughn> solrize: It would not at all surprise me. The bytestring authors have spent quite some time explicitly working on fusion.
04:49:31 <MarcWeber> Wow lambdaBot upgrade ? I thought she was ill again
04:50:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8529
04:50:14 <Baughn> solrize: ..well, I thought they had. The Fusion module is empty.
04:50:18 <smg> http://hpaste.org/8529 <-- i have that grammar and i need to translate it to use Parsec
04:50:20 <solrize> my python progam just finished after about 2.5 hours.  i'm sure ghc -O2 will be under 10 minutes even if map unFoo doesn't fuse ;)
04:50:25 <smg> ist that difficult? maybe someone has a hint for me
04:51:46 <atsampson> smg: doesn't look difficult; "Z | Z P" is "Z >> optional P"
04:51:49 <Baughn> solrize: There is no rule for it, leaving it to the general optimizer. Which means it depends on whether pack is inlined or not
04:51:58 <MarcWeber> solrize: Have you tried psyco?
04:52:07 <solrize> marcweber not recently
04:52:26 <Saizan> smg: that looks like an LL(1) grammar, so it should be straightforward
04:52:29 <solrize> it probably would help a lot for this
04:52:33 <solrize> hmm
04:52:34 <smg> Saizan: yeah it is.
04:52:40 <smg> but i don't know how to start Saizan
04:52:41 <MarcWeber> It's unfair to compare python against ghc.. Comparing python against ghci would be :-) @ solrize
04:53:18 <solrize> marcweber, for most of this stuff i've been doing, python is faster than ghc because ghc's libraries (written in haskell) are slower than python's (which are generally C wrappers)
04:53:42 <quicksilver> MarcWeber: it's not unfair.
04:53:51 <quicksilver> MarcWeber: python and ghc are both used in the real world to solve real problems.
04:53:54 <smg> can you give me some example how i would start, i completly miss the goal :<
04:53:58 <solrize> so when it works out the other way i'm ok still comparing :)
04:53:58 <quicksilver> you can compare their ability to solve those problems.
04:54:00 <Baughn> solrize: Aand.. yes, ghc considers pack as a candidate for inlining.
04:54:05 <solrize> cool
04:54:17 <Baughn> To be sure, you'd have to read core. ;P
04:54:54 <Saizan> smg: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
04:55:33 <MarcWeber> quicksilver Yeah, I mean it's not fair to compare compiled code against interpreted :-) (I should have said "solrize, do you mind trying psyco? I'd be interested if ghc is still much faster than"
04:55:55 <solrize> is there a ubuntu package for psyco?
04:55:57 <Vq^> psyco is neat
04:56:05 <Vq^> however it's not always safe
04:56:08 <audreyt> @tell mmorrow in regexqq.txt, perhaps add a line of ":set -XQuasiQuotes" before ":m + Text.Regex.PCRE.QQ"
04:56:09 <lambdac> Consider it noted.
04:56:34 <MarcWeber> solrize: I've never used ubuntu. All I remember is that all you havo to do is adding an import statement or such
04:56:39 <Baughn> solrize: I'm not sure it can, though. For one thing, pack reads the string /twice/ - once to find the length - I suppose it /could/ fuse with the first
04:57:12 <solrize> marcweber i'd have to find where psyco is, install it, etc. but i might try that if i get tired of trying to code this in haskell
04:57:54 <solrize> i'm cringing at the idea of passing around file handles in haskell, since they are so mutable
04:58:41 <solrize> most of these strings will be 5-10 bytes but a few might be in the kilobyte range
04:58:48 <solrize> chars
04:59:27 <smg> Saizan: i am there :)
04:59:59 <mmorrow> audreyt: good idea, doing it now.
05:00:00 <lambdac> mmorrow: You have 1 new message. '/msg lambdac @messages' to read it.
05:00:38 <pejo> Vq, is psyco the partial evaluator for python?
05:00:39 <Baughn> solrize: What does your program do, anyway?
05:00:54 <Baughn> solrize: Will you be accessing the strings enough for bytestrings to help?
05:01:17 <mmorrow> audreyt: done.
05:01:27 <MarcWeber> solrize http://psyco.sourceforge.net/psycoguide/node8.html and http://packages.ubuntu.com/de/hardy/python-psyco
05:01:28 <lambdac> Title: 2.1 Quick examples
05:01:30 <solrize> i think probably not accessing them all that much, just consing a lot of them and releasing them
05:02:05 <solrize> marcweber i probably can clean up a few horrendous bottlenecks from the python code too
05:02:21 <Baughn> solrize: Could you arrange to read the data in as bytestrings in the first place, saving the (expensive, really) conversion?
05:02:21 <MarcWeber> You don't have to do it But if you do let me know about your results. The Psyco page claims that speedups 2x - 4x are normal. Then only 30min vs 10 min are left.
05:02:38 <MarcWeber> solrize :-) Yeah, but this will propably take longer, right?
05:02:50 <solrize> baughn, that's what i was wondering about
05:02:58 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8530
05:03:01 <solrize> i.e. that's why i was asking what map unfoo did
05:03:09 <smg> http://hpaste.org/8530 <-- that somehow fails, someone has an idea why this is wrong?
05:03:35 <Baughn> smg: "Somehow fails" is a very bad error message
05:03:42 <mmorrow> @tell audreyt done.
05:03:43 <lambdac> Consider it noted.
05:03:45 <idnar> psyco has fairly limited applicability, anyhow
05:04:05 <atsampson> smg: in "doZ <|> (doZ >> doP)", the first branch will always be taken
05:04:08 <earthy> smg: it having Parser () at all levels feels icky at the very least
05:04:44 <TSC> atsampson: I think you want a try
05:04:53 <TSC> (try doZ) <|> (doZ >> doP)
05:04:59 <atsampson> TSC: I have a try, but I think smg wants one ;)
05:05:05 <TSC> Err, sorry
05:05:10 <TSC> Let's all have a try!
05:05:16 <smg> mh
05:05:23 <quicksilver> smg: your problem is a type problem
05:05:27 <smg> try = backtracking?
05:05:29 <quicksilver> smg: char foo is a Parser Char
05:05:32 <quicksilver> not a Parser ()
05:05:49 <quicksilver> you need some ; return () after the productions which otherwise end in a char
05:06:01 <quicksilver> but PLEASE always tell us the error message fi there is one
05:06:09 <smg> okay
05:06:22 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8531
05:06:30 <smg> you can see at the paste the error message
05:06:41 <earthy> smg: what quicksilver said
05:07:09 <quicksilver> right.
05:07:10 <earthy> more generally: keep in mind what the types are of all parsers
05:07:14 <quicksilver> I already divined that error :)
05:07:27 <quicksilver> I find the type of "char" annoying, actually.
05:07:37 <quicksilver> if I know what char I want, I know what the return value is :P
05:07:41 <quicksilver> but occasonally you want it.
05:07:56 <solrize> checking out psyco from svn
05:08:01 <atsampson> smg: yes, "try x" will attempt to match x, and not consume anything from the input if it fails
05:08:22 <quicksilver> solrize: will be curious to hear results.
05:08:28 <smg> mh
05:08:29 * earthy likes the <$ $> <* and *> combinators for writing parsers
05:08:47 <smg> somehow it still fails
05:09:01 <earthy> 'fails'? :)
05:09:02 <solrize> installer spews millions of gcc warning messages :(
05:09:22 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8532
05:09:31 <smg> i pasted it at hpaste.org for you
05:10:04 <solrize> and some errors
05:10:16 <solrize> looks to me like psyco is busted
05:10:20 <atsampson> smg, you need to look at what other people said -- your types are wrong
05:11:17 <smg> ah i figured out thank you
05:13:16 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8533
05:13:24 <smg> someone may look at that paste
05:13:28 <smg> another strange error? :|
05:14:13 <MarcWeber> solrize: If it had worked out of the box it would have been interesting to compare against ghc
05:14:51 <ziman> smg, (Parser a) is not a function that can be directly applied to a string
05:14:56 <solrize> well i'd expect psyco to come out a lot worse because i use a bunch of nested classes in python, that would all melt away with type erasure in ghc
05:15:07 <ziman> it's just a parser
05:15:10 <smg> ziman: ah okay
05:15:24 <smg> ziman: so i need to do what exactly?
05:15:47 <ziman> smg, you can parse strings using the `parse' function: parse parseit "descriptive freeform string" "/\\"
05:16:06 <smg> ah
05:16:18 <smg>  No instance for (Show ([Char] -> Either ParseError String))
05:18:24 <mapreduce> Oleg says here: http://okmij.org/ftp/Computation/Subtyping/ - "[some code] implements a purely functional OO system. It supports objects with an identity, state and behavior, inheritance and polymorphism. Everything in that system is immutable. And yet it is possible to define something like a BagV, and derive SetV from it by overriding a put message handler. Acting this way is bad and invites trouble as this breaks the LSP as shown
05:18:24 <mapreduce> earlier. Yet it is possible. This example shows that immutability per se does not turn object derivation into subtyping."
05:18:26 <lambdac> Title: Subtyping, Subclassing, and Trouble with OOP
05:18:54 <mapreduce> So subtyping doesn't exist without mutation?  Or what does he mean there?
05:19:08 <hpaste>  ziman annotated "(no title)" with "calling the parse function" at http://hpaste.org/8533#a1
05:19:23 <ziman> smg, ^^
05:19:23 <smg> ziman: ah thank you
05:19:31 <smg> ziman: btw my parser fails on "/\\"
05:19:55 <ziman> smg, then it'll return (Left some_error_value)
05:20:10 <ziman> the error value can be shown using show
05:20:12 <maltem> mapreduce: I don't understand most of that, but he surely doesn't say that
05:23:33 <earthy> no, oleg states that subclassing is not subtyping
05:23:45 <earthy> and should not imply subtyping, not even in immutable contexts
05:23:59 <earthy> his previous examples were in a mutable context
05:24:31 <earthy> I've toyed with the idea of explaining this to first year students, but decided against it, ultimately.
05:26:18 <ziman> @hoogle (m a->b->c) -> (m a) -> (m b) -> (m c)
05:26:18 <lambdac> A Hoogle error occured.
05:26:35 <mapreduce> earthy: Ok, thanks.
05:27:24 <smg> ziman: still in?
05:27:31 <ziman> smg, yes
05:27:44 <mmorrow> just got splicing of QuasiQuotes into pattern context working and put the updated patched ghc at: http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.2.tar.bz2
05:27:47 <lambdac> http://tinyurl.com/5m2grk
05:27:55 <mmorrow> @yow!
05:27:55 <lambdac> Couldn't find fortune file
05:27:58 <ziman> @pl \f p q -> f >>= \g -> (liftM2 g) p q
05:27:59 <lambdac> (. (flip . flip liftM2)) . (.) . (>>=)
05:29:19 <pejo> earthy, what's the definition of subclassing? (classes = typeclasses?)
05:29:34 <hpaste>  morrow annotated "panic with regex pattern" with "fixed!" at http://hpaste.org/8520#a1
05:30:33 <hpaste>  morrow pasted "QuasiQuote pattern splices now work" at http://hpaste.org/8534
05:31:11 <earthy> pejo: the oleg-term 'object derivation' is nicer
05:33:08 <earthy> read http://okmij.org/ftp/Computation/Subtyping/#Problem for the exact issues... the code, once you understand it, makes thing quite clear
05:33:09 <lambdac> Title: Subtyping, Subclassing, and Trouble with OOP
05:34:27 <smg> ziman: i got it
05:34:39 <ziman> smg, great
05:34:56 <smg> do you want to see it?
05:35:19 <ziman> smg, show me ;)
05:35:29 <smg> no wait it works
05:35:32 <smg> i have another task hehe
05:35:44 <smg> ziman: if you don't mind i will show you that
05:36:19 <ziman> ok :)
05:38:31 <gwern> so my fulsomely fine functional friends, what are the haps?
05:39:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8535
05:39:22 <smg> ziman: look at the paset and tell me if that is difficult please
05:39:30 <mm_freak_work> there are no haps
05:39:39 <mm_freak_work> we're functional!
05:40:01 <telemach> hello
05:40:07 <ddarius> earthy: Are you teaching these first-years OO?
05:40:11 <gwern> there must be haps. there is always something happening; ergo, there is at least one hap
05:40:34 <povman> telemach: h'ro
05:40:47 <ddarius> gwern: Not if there is no time, thene exists t. hap(t) can be false.
05:41:14 <mm_freak_work> gwern: in a bunch of declarations, there are no haps
05:41:25 <mm_freak_work> we need non-functional people to actually run us
05:41:57 <gwern> ddarius: no way. this is an a priori situation  - the act of asking about haps requires there to be haps, cogito ergo sum etc
05:42:48 <pejo> earthy, I'm not sure I get it - is the problem that Set and Bag aren't the same, yet the programmer has declared them related through the type system?
05:43:09 <mm_freak_work> interesting thought actually…  there must be side effects for side effects to happen
05:44:21 <smg> what do you think ziman ?
05:44:22 <ziman> smg, that's quite easy. however, be aware that direct transcription of a CFG into Parsec will often not work because parsec does not backtrack by default; you need to factor the rules a bit
05:44:22 <gwern> side effects are tautological? egads
05:44:39 <smg> ziman: you mean with that try () thing?
05:44:47 <gwern> but does the converse hold? are tautologies side effects? a = a hum
05:45:58 <ziman> smg, yes. but `try', albeit useful in lexing, is not recommended at syntax level
05:46:06 <mm_freak_work> gwern: nope, but they require themselves
05:47:30 <smg> ziman: so in general i do it the same way i did before?
05:47:37 <Baughn> mm_freak_work: There must be side effects for _anything_ to happen. And if this universe is running haskell, we'll stop existing the moment the administrator loses interest in us - unless he looks back later.
05:47:45 <smg> but i somehow need to generate that Tree instance ziman
05:48:32 <povman> Baughn: side effects are just functions on time
05:48:36 <mm_freak_work> Baughn: about the latter, i think that's a matter of interpretation…  we may just as well exist as long as we're defined, or we're just an infinitely small moment embedded in another universe =)
05:48:44 <povman> and the real world
05:48:45 <mm_freak_work> povman: functions on state
05:48:53 <povman> state and time :)
05:48:58 <mm_freak_work> time is state
05:49:06 * povman shuts up
05:49:07 <mm_freak_work> part of it =)
05:49:13 <Baughn> povman: No, you see, I'm taking "type IO = RealWorld -> RealWorld" quite seriously.
05:49:26 <mm_freak_work> i view a haskell program as a function of the state of the known universe
05:49:36 <mm_freak_work> where "known" is a lot more restricted here than what is really known =)
05:50:08 <ddarius> ziman: There's nothing wrong with try at the grammar level, you just don't want to have large (namely recursive) parsers under it.
05:50:28 <povman> mm_freak_work: that's not quite right, a haskell program returns a function on state (a procedure)
05:50:46 <mm_freak_work> which is the same
05:52:51 <hackage> New hackage package: regexqq 0.6
05:52:51 <hackage> New hackage package: regexqq 0.5
05:53:28 <solrize> one thing i like about python is that every value has its own namespace for methods.  haskell's record syntax requires making up a new name for EVERY accessor function, different types can't re-use the names :-P
05:55:20 <Baughn> solrize: That's only partially true, in GHC. It has a couple extensions that, among other things, allows you to use ambiguous accessor names so long as the type is known
05:55:26 <smg> sound
05:55:39 <ddarius> Haskell separates namespace management from data declaration, however its namespace management is overly weak.
05:55:44 <Baughn> Presumably something like that will eventually make its way into haskell-in-general
05:56:35 <quicksilver> I'm not sure the ambiguous accessor stuff really reaches int o the heart of the problem
05:56:44 <quicksilver> it's just a neat hack for a particular circumstance.
05:57:05 <solrize> i mean it could be done with a type class...
05:57:06 <Baughn> I'm sure it doesn't, and I wouldn't want it standardized as-is. It shows that people are thinking about it, though
05:57:26 <solrize> i guess it could also be done with a gadt
05:58:09 <quicksilver> I tend to just prefix record fields with a two-or-three letter abbreviation
05:58:21 <quicksilver> that seems to be good enough in small-medium programs
05:58:28 <ddarius> A simple, but orthogonal solution would be local modules.
05:58:29 <quicksilver> it's slightly ugly but doesn't bother me too much.
05:58:35 <telemach> i do it that way, too.
05:58:39 <quicksilver> the class solution feels a bit heavyweight
05:58:44 <solrize> baughn, hmm, i didn't know about the extension
05:58:57 <solrize> yeah i wish there were local modules, i think the haskell standard even allows them
05:58:59 <quicksilver> I don't really like the idea of each record field generating a class.
05:59:00 <Baughn> solrize: It has lots of extensions. Figuring them all out is.. brain-expanding. :P
05:59:08 <povman> quicksilver: wasn't there an article saying that was the ultimate method of program safety?
05:59:17 <hpaste>  ziman annotated "(no title)" with "how i'd write it" at http://hpaste.org/8535#a1
05:59:21 <quicksilver> povman: which?
05:59:30 <povman> variable prefixes
05:59:49 * ddarius should hack GHC to add local modules.
06:00:06 <quicksilver> ddarius: how would they work? roughly?
06:00:35 <telemach> module Mod1 where module Mod 2 where [...] ?
06:00:58 <ddarius> quicksilver: Pretty much like nested namespaces in C++.  You'd just be able to declare a module within another one.  I don't think anything particularly surprising would come up.
06:01:39 <ddarius> It would also be nice to more conveniently declare abstract types.
06:01:40 <telemach> how do you access these?
06:01:43 <quicksilver> ddarius: either a hack to try that out, or a written up proposal, would be great.
06:01:44 <ziman> smg, notice that i've merged common prefix of `leaf' and `tree' into one rule and that branching occurs when it's clear from the next character which rule should be applied
06:02:03 <ddarius> telemach: Mod2.f
06:02:21 <solrize> if they're nested how would you tell where they start and end?
06:02:23 <telemach> but what about Module1.Module2.anyFunc?
06:02:26 <solrize> or anyway where they end
06:02:43 <ddarius> solrize: modules are already delimited.  The where at the end of the declaration starts a block of layout.
06:02:57 <telemach> that has already a meaning.
06:02:59 <solrize> yeah, but where does it stop?
06:03:14 <solrize> most modules are written unindented
06:03:42 <ddarius> solrize: Yes, nested ones would obviously be indented (both necessarily and any sane programmer would anyway)
06:04:13 <ddarius> solrize: If you write (now): module F where\n   foo = 1\nbar = 2, you'll get a syntax errer.
06:04:19 <ddarius> s/errer/error
06:05:00 <quicksilver> in fact, kuribas's emacs mode wants me to indent my top level code cos its in a top level module
06:05:03 <quicksilver> annoys me :)
06:05:04 <solrize> i think i usually wouldn't want to nest them.  i'd just want a bunch in one file
06:05:17 <solrize> even if nested i'd want a bunch of consecutive ones to be at the same nesting level
06:05:38 <solrize> module Foo (Bar) where { ... }  ?
06:05:57 <ddarius> solrize: If nested modules were allowed, nothing would keep you from having more than one at a level (other than the top-level)
06:06:09 <kebeku-jin> Hello! How can I define a data type that would look like data Val = Vfun ([a]->b)? I don't quite understand how it works hehe
06:06:40 <solrize> how do you know where one ends?
06:07:00 <ddarius> solrize: The same way you know where any block ends, there is -nothing- special about modules.
06:07:05 <SamB_XP_> solrize: well, the indentation
06:07:32 <ddarius> telemach: That would be one problem, but I don't think it would be a big one and shadowing would be the correct solution.
06:07:33 <quicksilver> kebeku-jin: that syntax looks fine, yes.
06:07:47 <SamB_XP_> solrize: ... somehow
06:07:48 <kebeku-jin> does it? Hugs complains about it... :(
06:07:51 <Baughn> kebeku-jin: With a and b being type variables, you have to tell it what they are somehow. Normally that's done by making them parameters to Val, making Val a type constructor
06:07:55 <solrize> i think other blocks don't export symbols to the rest of that level
06:08:00 <quicksilver> oh yes
06:08:01 <quicksilver> doh.
06:08:07 <quicksilver> data Val a b = Vfun ([a] -> b)
06:08:11 <povman> haha
06:08:12 <quicksilver> is what you probably mean.
06:08:23 <quicksilver> solrize: yes they do.
06:08:28 <quicksilver> solrize: a = 5; b = a;
06:08:36 <Baughn> kebeku-jin: Mm. There /is/ another way of doing it, but you really don't want to touch existensials yet. ;)
06:08:42 <quicksilver> solrize: two blocks at the same level. Clearly a "exported a symbol" to b.
06:08:43 <kebeku-jin> hehe ok
06:08:51 <povman> Baughn: or unsafePerformIO :p
06:09:06 <solrize> those blocks don't get to span multiple lines without using indentation
06:09:22 <Baughn> povman: I don't see how that would "help"
06:09:23 <ddarius> solrize: What are you talking about?
06:09:35 <kebeku-jin> Baughn, quicksilver, I tried also to define data Val a b = Vfun ([a] -> b) but I still get an error from hugs... :(
06:09:50 <solrize> a = b +\n3   doesn't parse
06:09:53 <kebeku-jin> (illegal type in Class constraint)
06:10:12 <Baughn> kebeku-jin: Oh yeah. Another problem.. I don't know about hugs, but interpreters (ghci, anyhow) often don't let you define types on the command line
06:10:15 <ddarius> solrize: It depends, but you can always use explicit brackets.
06:10:19 <quicksilver> solrize: indeed
06:10:26 <quicksilver> solrize: and these proposed modules would also nee dindentation
06:10:26 <Baughn> kebeku-jin: So you'd have to write it in a file, then load the file. Which is more convenient anyhow.
06:10:32 <quicksilver> solrize: to span separate litbes.
06:10:37 <kebeku-jin> Baughn, ok, well thats exactly what i did hehe
06:10:50 <solrize> i wonder how ML does it
06:10:55 <quicksilver> solrize: module Mod1 where\n  a = 1\nmodule Mod2 where\n  b = 1
06:10:58 <ddarius> solrize: Already, if any implementation allowed it, you could put multiple modules in a single file.
06:11:03 <quicksilver> I don't really understand your objection.
06:11:11 <Baughn> kebeku-jin: Please paste the exact code. You should not be getting any class constraint errors /without a class constraint/.
06:11:29 <ddarius> solrize: The Report doesn't talk about "source files" at all.
06:11:30 <kebeku-jin> ok 2 secs
06:11:46 <kebeku-jin> what is the usual pastebin used for haskell code?
06:11:51 <ddarius> !paste
06:11:51 <Baughn> !hpaste
06:11:52 <hpaste> Haskell paste bin: http://hpaste.org/
06:11:57 <kebeku-jin> thx :)
06:12:27 <Baughn> !hpaste
06:12:38 <Baughn> -- I was wondering which one triggered it
06:12:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8536
06:12:54 <kebeku-jin> Baughn, http://hpaste.org/8536
06:12:54 <povman> how many bots are in here?
06:13:41 <Baughn> kebeku-jin: That code would work. There must be something else..
06:13:49 <kebeku-jin> hmm
06:13:52 <solrize> i guess you'd have to use import statements within files, hmm
06:14:08 <solrize> i gotta take off in a minute, bbl
06:14:11 <povman> i actually don't see a problem with namespaces
06:14:21 <povman> as they are
06:14:34 <quicksilver> kebeku-jin: indeed that code works fine here :)
06:14:48 <povman> 'accessor functions' are really just functions, and should be named after what they do
06:15:37 <hpaste>  kebekku-jin pasted "data type problem?" at http://hpaste.org/8537
06:15:55 <kebeku-jin> I pasted the entire file
06:16:03 <Baughn> povman: Except they're used in a number of syntactic extensions, and saying "fooGetSacrilegeLevel = 42" is awkward
06:16:15 <kebeku-jin> of cource, eval is incomplete
06:16:21 <quicksilver> kebeku-jin: the problem is here "instance Show Val"
06:16:24 <quicksilver> Val is not a type.
06:16:30 <quicksilver> "Val a b" is a type.
06:16:31 <kebeku-jin> ahhh....
06:16:46 <quicksilver> there is another similar problem in the type sig for eval
06:17:07 <kebeku-jin> ok ok
06:17:27 <kebeku-jin> thx! ill fix that up! :) thx again!
06:17:38 <Baughn> kebeku-jin: Oh, and you might want to install ghc as well. Not only is it a better compiler, the error messages are.. different; that helps, sometimes.
06:18:19 <Baughn> Though half the time it suggests turning on extensions that it thinks might help but wouldn't, really
06:18:28 <kebeku-jin> Baughn, ok thx for the tip! I actually already have it installed so Ill use it instead ;)
06:21:45 <povman> is there a good reason why record selectors can't be equivalent to pattern matching, for existentials?
06:22:02 <povman> to eliminate Cannot use record selector `build' as a function due to escaped type variables
06:22:31 <quicksilver> well they don't have a type.
06:22:34 <quicksilver> that's the problem.
06:22:59 <povman> ?
06:24:37 * Dae is yet another newb haskelleer who doesn't quite get how to use the state monad. Could someone point him in the right direction?
06:25:23 <Twinside> --->
06:25:40 <mm_freak_work> ↑
06:25:48 <Baughn> Dae: get when you like, put when you like, runState to get back into pure code/provide initial state/run the little DSL program. Any particular questions?
06:26:24 <Baughn> Dae: It's just an imperative language with mutable variables built on top of haskell
06:26:25 <Dae> Baughn: All of the above?
06:26:37 <mmorrow> > runState (let go = get >>= \n -> if n < 100 then (modify (+1) >> go) else return n in go) 0
06:26:39 <lambdac>  (100,100)
06:26:40 <povman> Dae: http://en.wikibooks.org/wiki/Haskell/Understanding_monads
06:27:12 <Dae> actually... I guess my main problem is how I use it with non-monadic code
06:27:16 <Baughn> Dae: State is one of the very simplest monads. If you're having problems with it, you should indeed be studying monads, not State. ;)
06:27:37 <EvilTerran> ?go you could have invented monads
06:27:40 <lambdac> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
06:27:40 <lambdac> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
06:27:40 <zeno__> mmorrow: why is that not just 100?
06:27:44 <Baughn> Dae: Implementing State for yourself is a common monad exercise, after all. That will show you how it works
06:27:47 <EvilTerran> Dae, i find that one particularly worthwhile
06:27:53 <mmorrow> :t runState
06:27:55 <lambdac> forall s a. State s a -> s -> (a, s)
06:28:08 <EvilTerran> runState returns (returned value, final state)
06:28:10 <mmorrow> the s is from put _ and the a is what you return
06:28:44 <EvilTerran> @@ evalState, execState :: (@type evalState), (@type execState)
06:28:48 <lambdac>  evalState, execState :: forall s a. State s a -> s -> a, forall s a. State s a -> s -> s
06:28:54 <mmorrow> > evalState (let go = get >>= \n -> if n < 100 then (modify (+1) >> go) else put "asdf" in go) 0
06:28:56 <lambdac>   add an instance declaration for (Num [Char])
06:29:05 <mmorrow> > evalState (let go = get >>= \n -> if n < 100 then (modify (+1) >> go) else return "asdf" in go) 0
06:29:07 <lambdac>  "asdf"
06:29:11 <mmorrow> > execState (let go = get >>= \n -> if n < 100 then (modify (+1) >> go) else return "asdf" in go) 0
06:29:13 <lambdac>  100
06:29:17 <mmorrow> > runState (let go = get >>= \n -> if n < 100 then (modify (+1) >> go) else return "asdf" in go) 0
06:29:19 <lambdac>  ("asdf",100)
06:30:28 <zeno__> mmorrow: got it thanks
06:30:35 <Baughn> > runState (let go = get >>= \(a,b) -> if a < 700000 then (modify (fmap (+1)) >> go) else return b in go) 0
06:30:36 <lambdac>   add an instance declaration for (Num (t, a))
06:30:38 <mmorrow> zeno__: :)
06:30:55 <Baughn> > runState (let go = get >>= \(a,b) -> if a < 700000 then (modify (fmap (+1)) >> go) else return b in go) (0,0)
06:31:23 <zeno__> @src fmap
06:31:30 <Dae> Ok, I'll probably be back when I get stuck ;p Thanks
06:31:32 <Baughn> Oops?
06:31:47 <zeno__> Baughn: you killed the bot :?)
06:31:53 <mmorrow> zeno__: speaking of fmap, these are nice identities:
06:32:08 <Baughn> zeno__: ..it's supposed to handle that. Anyway, that should've given a near-instant stack overflow, not... oh.
06:32:15 <mmorrow> > (*2) `fmap` Just 8
06:32:19 <Baughn> This isn't lambdabot, I guess
06:32:22 <mmorrow> > return . (*2) =<< Just 8
06:32:47 <mmorrow> > (*2) `liftM` Just 8
06:32:59 <Baughn> @botsnack
06:33:14 <mmorrow> uhoh, the bot has died!
06:33:42 <Baughn> Wedged right good, unless it's dead and doesn't know it yet
06:33:47 <Baughn> Whose bot is that?
06:33:54 <lambdac>  thread killed
06:34:03 <mmorrow> haha
06:34:06 <zeno__> no botsnacks for you
06:34:19 <zeno__> > (*2) `fmap` Just 8
06:34:47 <mmorrow> > do { x <- Just 8 ; return (x*2) }
06:34:55 <lambdac> Source not found. stty: unknown mode: doofus
06:34:59 <lambdac> :)
06:35:02 <zeno__> odd lambdabots in #obama but not #haskell
06:35:09 * Baughn cries over the limp, comatose corpse of the bot
06:35:10 <lambdac>  thread killed
06:35:14 <lambdac>  thread killed
06:35:15 <lambdac>  thread killed
06:35:15 <lambdac>  thread killed
06:35:15 <lambdac>  thread killed
06:35:39 <mmorrow> poor bot corpse
06:35:53 <SamB_XP_> > last [1..]
06:35:57 <Baughn> Actually, that last murder streak makes it look more like a zombie to me
06:36:03 <Baughn> SamB_XP_: ....evil
06:36:08 <lambdac>  thread killed
06:36:12 <mmorrow> zombie scum!
06:36:20 <zeno__> lambdac: stop ripping off your clothes!
06:36:26 <SamB_XP_> > 1
06:36:37 <mmorrow> > foldl (.) id (repeat read) $ fix show
06:36:41 <gwern> well, I'll be. pugs now installs for me
06:36:42 <lambdac>  thread killed
06:36:53 <lambdac>  thread killed
06:36:57 * gwern wonders what the hell to do with pugs now that it is installed
06:37:13 <paolino> @go pugs
06:37:16 <dmwit> lambdac: @part #haskell
06:37:21 <gwern> so does anyone have a perl6 snippet handy so I can see whether it works?
06:37:32 <vixey> say 'hello'
06:37:33 <dmwit> heh heh
06:37:38 <lambdac> Plugin `search' failed with: thread killed
06:37:59 <gwern> eery. it looks almost exactly like ghci
06:38:11 <mmorrow> i've always meant to learn perl6, but then i learned about haskell and haven't gotten around to it
06:38:14 <mapreduce> dmwit: Do you want it gone?
06:38:37 <vixey> perl6 is so cool
06:38:51 <mmorrow> vixey, show us some one liners
06:38:59 <mmorrow> "a taste"
06:39:02 <SamB_XP_> mapreduce: it doesn't seem very useful
06:39:03 <dmwit> mapreduce: Nope, it was a misnick.
06:39:18 <dmwit> mapreduce: I was aiming it at lambda/povman as a joke, sorry. =P
06:39:31 <vixey> uh... [+] <1 2 3>
06:39:35 <mapreduce> SamB_XP_: It was earlier.  I expect it's just overloaded.
06:39:51 <povman> :p
06:40:18 <mapreduce> @part #haskell
06:40:31 <mapreduce> and wait a while first
06:40:32 <povman> lol
06:40:36 <SamB_XP_> greenrd, thoughtpolice: not you!
06:40:39 <mmorrow> vixey: what would (\f->map f [0..9]) be in perl6
06:40:44 <povman> now we see who are bots
06:41:15 <zeno__> mmorrow: %^@B09!V~
06:41:18 <gwern> [+] <1 2 3> evaluates to 6.0? eh
06:41:38 <SamB_XP_> gwern: yucky .0!
06:41:49 <mmorrow> zeno__: hmm
06:41:58 <mm_freak_work> > [+] <1 2 3>
06:42:06 <mm_freak_work> no =)
06:42:18 <gwern> zeno__: that doesn't seem to work
06:42:26 <gwern> ' Unexpected "^@"'
06:42:28 <mmorrow> vixey: what i really mean is what's the syntax for   \x -> e
06:43:12 * mmorrow internet searches
06:47:15 <mmorrow> http://dev.perl.org/perl6/doc/design/syn/S06.html
06:47:24 <mmorrow> perl6 looks pretty sweet
07:07:12 * mejja laughs cruelly
07:07:52 <vixey> mejja o_o
07:10:27 <zeno__> > repeat 10000 @botsnack :(
07:10:45 <mrd> @@ @run repeat 1000 @botsnack
07:11:09 <zeno__> i think ill download lambdabot to run locally
07:23:04 <vixey> > (liftM2 (,)) [1,2,3] [66,99]
07:23:57 <vixey> [(1,66),(1,99),(2,66),(2,99),(3,66),(3,99)]
07:27:49 <Apocalisp> @bot
07:27:49 <lambdac> :)
07:28:08 <vixey> > (liftM2 (,)) [1,2,3] [66,99]
07:28:09 <lambdac>  [(1,66),(1,99),(2,66),(2,99),(3,66),(3,99)]
07:28:37 <zeno__> > (liftM2 (,)) (Just 1) (Just 9)
07:28:38 <lambdac>  Just (1,9)
07:28:45 <zeno__> neat :)
07:29:36 <vixey> > (liftM2 (,)) (Just (Just (Just (Just 1)))) (Just (Just (Just (Just 9))))
07:29:37 <lambdac>  Just (Just (Just (Just 1)),Just (Just (Just 9)))
07:30:01 <xif> why does Oleg's website refer to itself as "This FTP site"?
07:30:21 <RayNbow> > orderPizza
07:30:22 <lambdac>   Not in scope: `orderPizza'
07:30:31 <chessguy> bummer
07:30:42 <chessguy> @quote pizza
07:30:42 <lambdac> No quotes match. Have you considered trying to match wits with a rutabaga?
07:30:44 <maltem> > (,) <$> Just 1 <*> Just 9
07:30:46 <lambdac>  Just (1,9)
07:31:04 <RayNbow> > orderPizza
07:31:06 <lambdac>  Pepperoni-lambda, coming up!
07:31:19 <zeno__> hmmm does lambdac not respond to queries?
07:31:21 <vixey> @quote
07:31:22 <lambdac> ralflammel says: I am confident about my admiration for Haskell
07:31:33 <vixey> @quote
07:31:33 <lambdac> br1 says: <br1> un banana me abrio la puerta en la cara y me rompio un pedal de la bici :(
07:31:42 <Dae> weird little question: is there any easy way to get a state monad with more than one state variable? Would I have to tuple them or?
07:32:00 <vixey> Dae: seems like the same thing to me
07:32:01 <Baughn> Dae: STRef
07:32:16 <chessguy> data MyState = MyState { a :: Type1, b :: Type2}
07:32:21 <Baughn> Tuples or maps work fine in some cases, but STRef is O(1) - just like any other variable
07:32:34 <Baughn> I don't know if the optimizer would do the same with a tuple.
07:33:44 <Maciej> What are these record style data constructors A { a :: Int } called in Haskell?
07:34:00 <vixey> records
07:34:11 <Baughn> Dae: You also have IORef, which is exactly the same thing for IO. Not strictly necessary, as you /could/ use StateT IO, but rather handy
07:34:38 <Dae> Baughn: Ok, I think that was what I was looking for
07:35:01 <Maciej> vixey: I thought real records are a missing feature of Haskell?
07:35:39 <Baughn> Dae: But see, this is one of the things I like best about haskell. It isn't "missing" variables or mutability; it's /free/ of mutability, unless you choose to introduce it yourself, in which case it does it very well indeed.
07:38:34 <quicksilver> the interesting thing about STRef/IORef is that it lets you create new references at runtime
07:38:43 <quicksilver> otherwise it's cleaner IMO to have a record-type State
07:39:25 <Baughn> I'd have to agree. If the optimizer can't handle that, it's time to fix the optimizer
07:39:38 <Baughn> What pass should I be dumping to find out, by the way?
07:40:33 <quicksilver> I'm not sure really.
07:40:54 <Baughn> Then I'll experiment. Learning to read those will be useful at some point, I bet.
07:46:47 <ski_> Maciej : yes
07:47:48 <quicksilver> Maciej: that depends what you think a 'real record' is
07:47:55 <quicksilver> the xisting system certainly works.
07:48:03 <quicksilver> but there are some limitations to it
07:49:03 <Maciej> quicksilver: There where some discussions on haskell-cafe about a record implementation.
07:49:20 <quicksilver> indeed.
07:49:28 <quicksilver> I read some of them :)
07:49:37 <quicksilver> it seems to be hard to agree what is the right answer.
07:49:46 <quicksilver> in fact, I think it's hard to agree even what the right question is.
07:50:06 <Maciej> So I thought these current records are not called records.
07:50:36 <quicksilver> they are called records.
07:50:44 <quicksilver> it's just that some p[eople aren't happy with them.
07:51:41 <Maciej> I see
08:02:02 <EvilTerran> i thought everyone quite liked the extensible records proposal using row types or whatever the term was
08:08:54 <dcoutts_> @seen dons
08:08:54 <lambdac> dons is in #haskell. I don't know when dons last spoke.
08:09:08 <osfameron> yay!  local library confirmed they've ordered TaPL on my recommendation!
08:09:16 * Baughn wonders if seen is still leaking
08:09:30 <dcoutts_> @localtime dons
08:09:32 <lambdac> Local time for dons is Wed Jun 25 08:09:31 2008
08:09:48 <dcoutts_> @tell dons I've got some good news. ping me when you wake up :-)
08:09:48 <lambdac> Consider it noted.
08:12:42 <BMeph> dcoutts_: Did you save money on car insurance? ;)
08:13:01 <quicksilver> EvilTerran: which one?
08:13:09 <Dae> ok, maybe I'm being dumb..... but how do I use STRefs in other functions than the one that generated the STRef with NewSTRef?
08:13:23 <mauke> you just do it
08:13:38 <quicksilver> Dae: you pass it around like a value
08:13:40 <quicksilver> (which it is)
08:13:44 <dcoutts_> BMeph: much better :-)
08:14:04 <quicksilver> Dae: the STRef itself rather than its contents, I am referring ot.
08:14:54 <Dae> quicksilver: Right... I feared that was what I might need to do... whole point in using ST was not to bring a ton of variables around everywhere :S
08:16:13 <mauke> huh?
08:16:22 <mauke> the point of ST is that it lets you create variables
08:16:30 <mauke> why use it if you don't want them?
08:16:33 <Baughn> I think he wants global variables
08:18:29 <Baughn> Hm. There was a blog entry somewhere showing how, instead of passing values through functions, you could gain by passing them to the ones that would actually /use/ them and then pass that partially applied function instead
08:18:40 <EvilTerran> quicksilver, hang on, i'll dig around for the paper
08:18:42 <Baughn> Using cabal as an example. Anyone remember where that was?
08:19:36 * BMeph works next to a GEICO call center
08:19:43 <earthy> Baughn: I do recall that...
08:19:51 <Baughn> http://blog.well-typed.com/2008/05/information-plumbing/ <-- google reader to the rescue
08:19:53 <lambdac> Title: blog.well-typed.com  Blog Archive  Information plumbing
08:19:54 <Dae> mauke: I guess what I want is global variables.....
08:20:07 <dcoutts_> Baughn: oh, that was me. I wasn't sure what you were referring to :-)
08:20:08 <Baughn> Dae: I think you'd benefit from reading that blog
08:20:33 <Baughn> Dae: It is, of course, generally accepted that you *don't* want global variables. And haskell has no way of making them either. ;)
08:20:50 <dcoutts_> Dae: anyway there's no such thing as a global variable
08:21:12 <dcoutts_> all scopes are bounded by something, often it's a process or a file system namespace
08:21:27 <BMeph> dcoutts_: Although, Erlang's trying hard to implement them... ;)
08:21:48 <dcoutts_> BMeph: global as in per-universe scope?
08:21:50 <Dae> Baughn: Right....ok...but let's say... in theory... I have this array, I want to update. Now, if I keep two arrays updated, I can update the first array in O(N^2) time.....
08:22:08 <Baughn> dcoutts_: Well, amazon s3 or similar services?
08:22:35 <dcoutts_> Baughn: ok, yes, that's fairly wide
08:22:37 <Baughn> Dae: No. If you have an algorithm that requires array updates, you do two things:
08:23:11 <Baughn> Dae: First, try to do without mutation. You can tie the knot on Arrays - that only lets you write to each position once, but often that's quite enough
08:23:26 <Baughn> Dae: If that doesn't work, look at ST(U)Array
08:23:50 <EvilTerran> quicksilver, i think i was thinking of http://web.cecs.pdx.edu/~mpj/pubs/recpro.ps.gz
08:23:53 <Baughn> Dae: (That's in Data.Array.ST)
08:25:00 <EvilTerran> quicksilver, no, wait, my google-fu is failing me. http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf seems much more familiar to me.
08:25:03 <lambdac> http://tinyurl.com/392r4k
08:25:12 <EvilTerran> quicksilver, but i guess my confusion illustrates your point admirably :P
08:28:12 <BMeph> dcoutts_: :)
08:28:20 <mar77a> does [f,g] <- getArgs desugar (the guard part)?
08:28:41 <mar77a> er, is desugared*
08:29:03 <Dae> Baugh: let me rephrase my question problem: I have a function (IArray a) => a -> a -> a-> a. Only the first and the last array are important to anyone but the function itself, but the two middlearrays are needed for performance. Does that make sense?
08:30:02 * Baughn has gone missing, sorry
08:31:53 <quicksilver> mar77a: getArgs >>= \xs -> case xs of [f,g]  -> ... rest of function ... | _ -> fail "pattern match"
08:32:27 <mar77a> @hoogle finally
08:32:28 <lambdac> A Hoogle error occured.
08:32:34 <mar77a> ok
08:33:10 <quicksilver> Dae: you make the function a -> m a
08:33:22 <quicksilver> Dae: and you "hide" the other two "as" which are just used as caches or whatever, inside the 'm'
08:33:33 <quicksilver> state monad or reader monad or a combinatior of the both
08:35:05 <Dae> quicksilver: But won't I loose them later? These two caches are gonna be needed the next time I call the function again? Or will reader allow me to "save" them? I guess I'm being a little hindered by having learned OOP...
08:35:48 <quicksilver> Dae: you end up stringing together the actions in a way which preserves the caches
08:35:59 <quicksilver> mostly "behind the scenes" but ther is a little bit of plumbing to make it work.
08:36:42 <Dae> quicksilver: ok.... I think I get the idea... can't look worse than my none-monadic version ;) Thanks
08:36:43 <earthy> plumbing to put them 'inside' the m in the first place
08:36:54 <earthy> and plumbing to get them 'out' of the m when you need to get at them. :)
08:37:41 <mauke> you can just ask nicely
08:38:03 <quicksilver> Dae: it takes a little getting used to
08:38:12 <quicksilver> Dae: but then global variables are also very easy to get wrong
08:38:12 <mauke> :t ask
08:38:14 <lambdac> forall (m :: * -> *) r. (MonadReader r m) => m r
08:38:24 <quicksilver> overall I prefer the haskell way. It forces you to "think" slightly harder about your global vars.
08:38:54 <earthy> mauke: asking counts as plumbing. :)
08:39:15 <sayaaan> does anyone knows about lava here? :)
08:39:40 <Dae> quicksilver: Not a fan of global vars, just couldn't see a better way of doing it
08:49:02 <BMeph> mmorrow: ping
08:50:17 <mmorrow> BMeph: pong
08:54:33 <dcoutts_> @seen pgavin
08:54:34 <lambdac> pgavin has changed nick to pgavin-away.
08:54:34 <lambdac> I saw pgavin-away leaving #haskell 50m 50s ago, and .
08:55:05 <mmorrow> sayaan: other than probide you with a few links about lava, i don't know much. how much do you already know?
08:55:17 <mmorrow> sayaaan:
08:55:33 <mmorrow> s/probide/provide/
08:55:57 <sayaaan> mmorrow, yes?
08:56:00 <dcoutts_> @tell pgavin yay, the installer works! One thing, it lets me proceed even when I don't have ghc-6.8.3 installed. Is this what you intended? Previously it only let you carry on for the dll search path problem, since there's some chance of fixing that up manually, where as it needs ghc-6.8.3 just to register etc.
08:56:01 <lambdac> Consider it noted.
08:56:26 <mmorrow> sayaaan: how much do you already know about lava?
08:57:04 <sayaaan> mmorrow, im trying to put  a example to run here... but there are only bad news :S
08:57:34 <tusho> mmorrow: it's hot
08:58:30 <sayaaan> mmorrow, i think the imports not work very well
08:58:40 <mmorrow> sayaaan: http://www.cs.chalmers.se/~koen/Lava/papers.html
08:58:41 <mmorrow> http://raintown.org/lava/
08:58:42 <lambdac> Title: The Lava Homepage: Papers
08:58:43 <lambdac> Title: The Lava Hardware Description Language
08:58:45 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/reduceron2/
08:58:47 <lambdac> Title: The Reduceron
08:58:51 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/reduceron/
08:58:53 <lambdac> Title: The Reduceron (Old)
08:59:04 <mmorrow> that's my collection of lava links, other than that i'm useless :)
08:59:16 <sayaaan> mmorrow, ty a lot :)
08:59:25 <mmorrow> tusho: if james bond knew you knew that, he'd have to kill you
08:59:32 <mmorrow> sayaaan: :)
09:38:27 <pete2> why the Functor instance definition for touple is like
09:38:27 <pete2> instance Functor ((,) a) where
09:38:27 <pete2> 	fmap f (x,y) = (x, f y)
09:38:27 <pete2> instead of
09:38:27 <pete2> instance Functor ((,) a) where
09:38:28 <pete2> 	fmap f (x,y) = (f x, f y)
09:38:46 * Baughn blinks
09:38:52 <Baughn> > fmap (+1) (1,3)
09:38:54 <lambdac>  (1,4)
09:39:03 <Lemmih> pete2: x and y aren't necessarily of the same type.
09:39:16 <pete2> ach right; thanks
09:39:26 <pete2> me stupid :)
09:39:35 <Baughn> That would do it. Oh dear, and that means my earlier LB invocation was an infinite loop
09:40:46 <quicksilver> pete2: (a,a) is a functor in the obvious way.
09:40:55 <quicksilver> pete2: but (a,a) is the wrong kind to be a haskell Functor
09:40:57 <Saizan> (,) by itself is a bifunctor
09:40:59 <quicksilver> you'd have to newtype it.
09:41:23 <quicksilver> newtype Pair a = (a,a) -- instance of Functor, Traversable, Foldable, etc.
09:42:32 <pete2> quicksilver: yes, I see, I just somehow expected that it would work directly with touple but it cannot since types can be different; I was surprised that that it looks differently from fmap on list
09:42:48 <Lemmih> quicksilver: Would it be pedantic to point out that what you posted is not valid Haskell?
09:43:47 <quicksilver> Lemmih: I always forget my constructors. So sue me )
09:44:53 <pete2> quicksilver: is Bifunctor class already defined somewhere? hoogle cannot find it
09:45:20 <pete2> quicksilver: I'm not going to use it; just curious ...
09:46:11 <quicksilver> probably in edwardk's mad category extras pacakge
09:46:23 <pete2> :)
09:46:38 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
09:46:40 <lambdac> http://tinyurl.com/5leenf
09:47:14 <quicksilver> http://hackage.haskell.org/packages/archive/category-extras/0.53.4/doc/html/Control-Functor.html#t%3ABifunctor
09:47:16 <lambdac> http://tinyurl.com/66thr7
09:47:26 <quicksilver> "class (PFunctor p r t, QFunctor p s t) => Bifunctor p r s t | p r -> s t, p s -> r t, p t -> r s where"
09:50:07 <pete2> ok; thanks
09:52:54 <hackage> New hackage package: Stream 0.2.5
09:53:09 <byorgey> oooh, Stream!
09:54:12 * byorgey munches on baked lambdas with hummus
09:54:46 <ptolomy2> Can I assume that someone has implemented this in a very clever way in Haskell already?: http://wordaligned.org/articles/running-sums-in-python
09:54:47 <lambdac> Title: Running Sums in Python
09:55:57 <byorgey> ptolomy2: sure, that's pretty easy to do just by sticking together some prelude functions
09:56:00 <byorgey> let's see...
09:56:31 <joey__> > scanl1 (+) [1..10]
09:56:33 <lambdac>  [1,3,6,10,15,21,28,36,45,55]
09:56:39 <joey__> Looks to be the right general area
09:56:50 <byorgey> joey__: yup, that works for n=2
09:57:08 <byorgey> @let runningSums n = map (sum . take n) . tails
09:57:09 <lambdac> Defined.
09:57:13 <ptolomy2> Yeah, scanl (+) was my first try.
09:57:19 <byorgey> > runningSums 2 [0..5]
09:57:20 <lambdac>  [1,3,5,7,9,5,0]
09:57:41 <byorgey> oh, well, modulo the end there
09:57:52 * ptolomy2 ended up with a 11-line monstrosity in the interest of properly dealing with the end.
09:58:05 <ptolomy2> Or, if 'tryTake' is a library function, a 3 line monstrosity.
09:58:14 <byorgey> ptolomy2: well, let's think, there must be a better way =)
09:58:39 <byorgey> I mean, you could just do  (sum . filter ((==n) . length) . take n)
09:58:53 <byorgey> it's short although perhaps not as elegant as one might like
09:59:08 <ptolomy2> I'm using.. (*gasp*) explicit recursion.
09:59:17 <vixey> > map (sum . take 5) . iterate (drop 1) $ [0..5]
09:59:18 <lambdac>  [10,15,14,12,9,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:59:19 <byorgey> @let runningSums n = map (sum . filter ((==n) . length) . take n) . tails
09:59:20 <lambdac> <local>:5:0:     Warning: Pattern match(es) are overlapped              In th...
09:59:29 <byorgey> @let runningSums' n = map (sum . filter ((==n) . length) . take n) . tails
09:59:30 <lambdac> Defined.
09:59:36 <byorgey> > runningSums 2 [0..5]
09:59:37 <lambdac>  [1,3,5,7,9,5,0]
09:59:41 <byorgey> > runningSums' 2 [0..5]
09:59:42 <ptolomy2> the use of tails is helpful.
09:59:42 <lambdac>   add an instance declaration for (Enum [a], Num [a])
09:59:48 <vixey> > map (sum . take 2) . iterate (drop 1) $ [0..5]
09:59:50 <lambdac>  [1,3,5,7,9,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:59:53 <byorgey> argh
09:59:54 <Baughn> > (\n -> map (sum . take n . reverse . drop 2 . reverse) . tails) 2 [0..5]
09:59:56 <lambdac>  [1,3,5,3,0,0,0]
09:59:57 <ptolomy2> I'm also confused about why the example output on the original site doesn't have a '9' at the end.
10:00:21 <Baughn> ..wrong order, but that'd work
10:00:22 <vixey> > map (sum . take 2) . takeWhile (not null) . iterate (drop 1) $ [0..5]
10:00:23 <lambdac>  Couldn't match expected type `Bool'
10:00:35 <byorgey> ptolomy2: yeah, that seems to be a mistake...
10:00:51 <Baughn> > (\n -> map (reverse . drop 2 . reverse . sum . take n) . tails) 2 [0..5]
10:00:53 <lambdac>   add an instance declaration for (Enum [a], Num [a])
10:00:56 <vixey> > map (sum . take 2) . takeWhile (not.null) . iterate (drop 1) $ [0..5]
10:00:58 <lambdac>  [1,3,5,7,9,5]
10:01:01 <Baughn> ..what'd I do?
10:01:26 <byorgey> Baughn: I dunno, I got the same error earlier
10:01:27 <vixey> > map (sum . take 2) . takeWhile ((==2) . length) . iterate (drop 1) $ [0..5]
10:01:28 <lambdac>  []
10:01:48 <vixey> :(
10:01:56 <Baughn> > (\n -> reverse.take 2.reverse.map (sum . take n) . tails) 2 [0..5]
10:01:56 <vixey> > map (sum . take 2) . takeWhile ((>=2) . length) . iterate (drop 1) $ [0..5]
10:02:47 --- mode: irc.freenode.net set +o ChanServ
10:03:08 <vixey> why are we doing this? :)
10:03:08 <xd> to prove haskell is better than python of course
10:03:34 <vixey> I thought that was obvious..
10:04:23 <vixey> I would write this using a cyclic linked list and state
10:04:33 <Baughn> > mapM sum (tails [0..5])
10:04:34 <lambdac>        add an instance declaration for (Enum (m b), Num (m b))
10:04:36 <byorgey> > let inn = (++(repeat Nothing)) . map Just ; out = catMaybes ; runningSums n = out . map (sequence . take n) . tails . inn  in runningSums 2 [0..5]
10:05:02 <lambdac>  thread killed
10:05:32 <Valodim> ok that's it
10:05:38 <byorgey> > let inn = (++(repeat Nothing)) . map Just ; out = catMaybes ; runningSums n = out . takeWhile (isJust) . map (sequence . take n) . tails . inn  in runningSums 2 [0..5]
10:05:38 <Valodim> this is getting really, really annoying
10:06:09 <byorgey> I wonder what Valodim meant?
10:06:10 <lambdac>  [[0,1],[1,2],[2,3],[3,4],[4,5]]
10:06:24 <byorgey> oops, forgot the sum =)
10:06:30 <Baughn> > do a <- [0,1]; b <- [1,2]; return (a+b)
10:06:31 <lambdac>  [1,2,2,3]
10:06:58 <byorgey> > let inn = (++(repeat Nothing)) . map Just ; out = catMaybes ; runningSums n = out . map sum . takeWhile (isJust) . map (sequence . take n) . tails . inn  in runningSums 2 [0..5]
10:07:01 <lambdac>  Couldn't match expected type `[Maybe a]'
10:07:05 <ski_> (byorgey : netsplit ?)
10:07:15 <byorgey> > let inn = (++(repeat Nothing)) . map Just ; out = catMaybes ; runningSums n = map sum . out . takeWhile (isJust) . map (sequence . take n) . tails . inn  in runningSums 2 [0..5]
10:07:17 <lambdac>  [1,3,5,7,9]
10:07:21 <byorgey> > let inn = (++(repeat Nothing)) . map Just ; out = catMaybes ; runningSums n = map sum . out . takeWhile (isJust) . map (sequence . take n) . tails . inn  in runningSums 3 [0..5]
10:07:24 <lambdac>  [3,6,9,12]
10:07:26 <byorgey> huzzah!
10:07:37 <byorgey> ski_: yeah, I guess so
10:07:43 <byorgey> there have been a lot of those today...
10:07:57 <Kamina> 2/names
10:07:59 <ptolomy2> My favorite solution assumes the existence of filtMap ((a -> Maybe b) -> [a] -> [b]) and tryTake (Int -> [a] -> Maybe [a]).. do such things exist?
10:08:30 <byorgey> ptolomy2: filtMap you can easily make by composing map with catMaybes
10:08:49 <byorgey> @type \f -> catMaybes . map f
10:08:51 <lambdac> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
10:09:07 <byorgey> tryTake doesn't really exist, though
10:09:17 <BMeph> So, how come no one's made one using loeb yet? ;)
10:09:21 <byorgey> but it's easy to write and a nice general function
10:09:27 <byorgey> @type loeb
10:09:29 <lambdac> Not in scope: `loeb'
10:09:35 <byorgey> BMeph: what's loeb again?
10:10:02 <BMeph> loeb :: f(f b -> b) -> f b
10:10:27 <ptolomy2> byorgey: Well, I made it by other means (my heart feels like (assuming no fusion magic) the intermediate lists in using catMaybes are inefficient).. I think tryTake really should exist.. it sometimes trips me up that 'take' means 'take at most'.
10:10:53 <byorgey> ptolomy2: yeah, tryTake is a nice function
10:11:03 * ptolomy2 really needs to start using his own personal prelude instead of whining and rewriting the same ones over and over.
10:11:05 <byorgey> ptolomy2: you should code it up and submit it for inclusion in the standard libraries! =D
10:11:43 <byorgey> ptolomy2: I wouldn't worry about the intermediate lists.  Most of the time it really doesn't make a difference, and anyway, there IS fusion magic =)
10:12:07 <BMeph> @let loeb xs = fmap (\f -> f (loeb xs)) xs
10:12:08 <lambdac> Defined.
10:12:16 <BMeph> ?type loeb
10:12:18 <lambdac> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
10:12:24 <byorgey> ptolomy2: if you really care about little performance issues like that when writing things like 'runningSum', then you should be coding in C, not Haskell. ;)
10:12:34 <ptolomy2> Probably.
10:12:34 <BMeph> Yay, remembered it! :)
10:12:51 <ptolomy2> But when I'm golfing for the best implementation of something, I like to take performance into consideration. :)
10:13:31 <byorgey> ptolomy2: well, if you're talking about asymptotic time complexity, then I agree with you.
10:13:41 <BMeph> byorgey: Except, Haskell is much more satisfying, reassuring for problem-set coverage, and just plain fun. :)
10:14:00 <byorgey> but in this case we're just talking about an intermediate list structure.
10:14:33 <byorgey> BMeph: heh, I don't need any convincing. =)
10:16:03 <hpaste>  ptolomy2 pasted "runningSum.. verbose-style" at http://hpaste.org/8538
10:18:48 <vixey> > let q n l = q' (sum (take n l)) (l,drop n l) ; q' _ (_,[]) = [] ; q' t (l:ls,r:rs) = t : q' (t-l+r) (ls,rs) in q 2 [1..10]
10:18:50 <ptolomy2> oh. stupid me. 'mapMaybe' exists.
10:18:59 <vixey> :t mapMaybe
10:19:14 <lambdac>  thread killed
10:19:17 <damkor> Hi
10:19:18 <lambdac> thread killed
10:19:22 <vixey> > let q n l = q' (sum (take n l)) (l,drop n l) ; q' _ (_,[]) = [] ; q' t (l:ls,r:rs) = t : q' (t-l+r) (ls,rs) in q 2 [1..10]
10:19:26 <EvilTerran> ?hoogle mapMaybe
10:19:28 <lambdac> A Hoogle error occured.
10:19:33 <vixey> why is my thread killed
10:19:34 <EvilTerran> fail
10:19:34 <lambdac>  [3,5,7,9,11,13,15,17]
10:19:37 <vixey> hi damkor
10:19:48 <ddarius> vixey: Because
10:19:49 <vixey> q is the stateful version
10:20:02 <BMeph> Hi damkor
10:20:08 <Baughn> vixey: Because lambdabot leaks memory like a sieve
10:20:22 <ddarius> vixey: You have a space leak too.
10:20:24 <damkor> I need to define the types of some constructions derived from grammar productions, and I'm looking for some formalism that will allow me to define regular parametric data types
10:20:31 <ddarius> (Though that's not why)
10:20:43 <byorgey> ptolomy2: I would write tryTake just with type  :: Int -> [a] -> Maybe [a]
10:20:48 <byorgey> ptolomy2: instead of using fail
10:20:50 <damkor> that doesn't fall into some kind of undecibility problem
10:21:15 <Baughn> damkor: Not really enough information there, but.. have you looked at GADTs?
10:21:15 <dons> ?yow!
10:21:16 <lambdac> Couldn't find fortune file
10:21:18 <damkor> ok, but what types theory should I use?
10:21:19 <byorgey> ptolomy2: the problem is that for some monads, 'fail' actually just throws an error, so the function can possibly crash.
10:21:20 * ptolomy2 still clings to 'NtoJustMaybe'
10:21:21 <dons> bah!
10:21:21 <lambdac> dons: You have 2 new messages. '/msg lambdac @messages' to read them.
10:21:56 <dons> dcoutts: you pinged?
10:22:03 <ddarius> dons: The problems with NotJustMaybe that I've heard, are problems of the Monad type class, not the idiom.
10:22:16 <dons> ddarius: wrong nick?
10:22:17 <vixey> damkor: do you have an example of the sort of thing you're encoding?
10:22:18 <byorgey> ptolomy2: that's a nice solution though
10:22:47 * vixey wonders if anyone understood 'q'?
10:22:50 <byorgey> what's NotJustMaybe?
10:22:58 <BMeph> ddarius: Idiom, like the functor, or idiom like the metaphor? :)
10:23:59 * byorgey goes off to prepare the HWN
10:24:10 <snhmib> ptolomy2: i made this one http://rafb.net/p/0KKWxC10.html
10:24:11 <lambdac> Title: Nopaste - runningsum.hs
10:24:25 <snhmib> there's not a way to get rid of fs++[l] right? :(
10:24:32 <snhmib> on line 13
10:24:38 <damkor> well, what I really need is a type system that allows me to define types equivalent to the haskell types "data Something a = Something (SomethingElse a) \n data SomethingElse a = SomethingElse (Something a) [(a,a)]" in the worst case scenario, everything else will be simpler than that
10:24:40 <vixey> snhmiib: Maybe you could do l:fs
10:24:43 <twobitwork> how to you map something which returns IO Whatever over a list?
10:25:23 <BMeph> twobitwork: lift, maybe? :)
10:25:37 <twobitwork> as in liftM?
10:25:39 <damkor> but I don't want to code things using haskell directly because then I'll have to ensure that there's no name clashing in the names I generate for each terminal symbol and each constrcutor
10:26:03 <vixey> name clashes are easy to avoid
10:26:05 <snhmib> vixey: but then i have to get the end of the list everytime i think :(
10:26:06 <vixey> haskell has a module system
10:26:51 <vixey> damkor: it looks like this kind of thing http://blog.jbapple.com/2008/02/name-that-type-nested-types-edition.html
10:26:53 <damkor> vixey: yes, but I just want to write the translation into types before and, in a different chapter, tell how those types can be written in haskell
10:26:55 <lambdac> Title: Everyone Else is Crazy: Name that type! (nested types edition), http://tinyurl.com/5p7chm
10:27:08 <BMeph> One thing I wondered about the blog entry: shouldn't there have been one more value on the end, than he showed?
10:28:57 <BMeph> I.e., running_sum([0, 1, 2, 3, 4, 5], 2)
10:28:57 <BMeph> [1, 3, 5, 7] -- shouldn't 9 be at the end of this?
10:28:57 <BMeph>  
10:29:08 <ddarius> BMeph: This is python, the implementation is the specification!
10:29:10 <vixey> > let q n l = q' (sum (take n l)) (l,drop n l) ; q' _ (_,[]) = [] ; q' t (l:ls,r:rs) = t : q' (t-l+r) (ls,rs) in q 2 [1..5]
10:29:11 <lambdac>  [3,5,7]
10:31:19 <damkor> Baughn: I just found something about GADTs, and it definitely looks like something much more powerful than what I need
10:31:55 <Baughn> damkor: That's good, I assume. I recall it being used for what you suggested in the /tutorials/, so..
10:35:10 <litb> hello there
10:35:35 <litb> awesame: hey i got an idea: you may grey out the "Run it" button, if the user choose "Plain Text" format
10:48:35 <proq> @src liftM2
10:48:36 <lambdac> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:48:52 <vixey> > (liftM2 (,)) [1,2,3] [66,99]
10:48:53 <lambdac>  [(1,66),(1,99),(2,66),(2,99),(3,66),(3,99)]
10:55:07 <vixey> Delivering input terms for an interpreter to evaluate is a problem in any lambda-calculator: one has to step out of the box and introduce some sort of OS interface. In our case, the g++ compiler itself acts like a lambda-interpreter: Template (i.e., polymorphic) classes and functions are playing the role of abstractions, template instantiations are applications, and type inference is tantamount to evaluation. Therefore all the input data have to be del
10:55:08 <vixey> ivered to the compiler; a -D compiler option is one way to do that.
10:55:23 <lilachaze> @hoogle memo
10:55:24 <lambdac> A Hoogle error occured.
10:55:30 <EvilTerran> vixey, O.o
10:58:00 <EvilTerran> vixey, evidently, someone must write a yhc backend for C++ templates :P
10:59:02 <lilachaze> @hoogle Ord a => (a -> b) -> (a -> b)
10:59:03 <lambdac> A Hoogle error occured.
10:59:19 <EvilTerran> lilachaze, such a function does not exist
10:59:24 <EvilTerran> (aside from id)
10:59:43 <EvilTerran> i believe the idea is that it is better to tailor your memoisation to each individual situation
10:59:58 <EvilTerran> also, that kind of memoising function wouldn't do anything to recursive calls within the parameter
11:00:12 <EvilTerran> ?type fix
11:00:14 <lambdac> forall a. (a -> a) -> a
11:00:33 <twobitwork> lambdabot became lambdat?
11:00:34 <EvilTerran> better would be memoFix :: Ord a => ((a -> b) -> a -> b) -> a -> b
11:00:59 <vixey> :t runCont
11:01:01 <lambdac> forall r a. Cont r a -> (a -> r) -> r
11:01:18 <lilachaze> EvilTerran: how would such a thing be used?
11:02:13 <EvilTerran> instead of writing "foo x = ...", write "foo foo x = ..." - the parameter foo masks the function foo within the body of the definition
11:02:15 <lilachaze> EvilTerran: nm, i get it
11:02:22 <EvilTerran> then, fix foo will do the same as the original foo
11:02:37 <lilachaze> EvilTerran: it's like recursion in lambda calculus
11:02:41 <EvilTerran> and memoFix foo will do likewise, but memoising. presumably it'd use some kind of lazy map under the hood
11:03:15 <EvilTerran> (Data.Map wouldn't be suitable, i think, because its tree is strict)
11:03:20 <vixey> did anyone code the strong normalization proof from TAPL?
11:03:46 <lilachaze> EvilTerran: Data.Map plus unsafePerformIO could work, though, i think
11:04:30 <EvilTerran> yes; that's what the problem is, actually - you can't get a complete domain out of just an Ord constraint, so you couldn't use an immutable map, even if you built it lazily
11:05:10 <lilachaze> i'm happy using unsafePerformIO here, i think; it should still be referentially-transparent
11:05:23 <EvilTerran> yep, it should be
11:05:43 <EvilTerran> that is a technically correct use of unsafePerformIO :)
11:06:47 <lilachaze> is there any guarantee that my IOVar would actually be the same across multiple calls?
11:06:51 <lilachaze> i'm guessing not
11:07:23 <EvilTerran> the other alternative would be sth like "class Finite a where enumerate :: [a]" and then having memoFix :: (Finite a, Ord a) => ...
11:07:40 <EvilTerran> but then you would be limited to finite domains
11:08:20 <EvilTerran> lilachaze, i don't know - you're in bat country now, all the semantics will go funny
11:09:10 <lilachaze> EvilTerran: good old abstractions, eh?
11:09:15 <vixey> :D
11:10:38 <twobitwork> I can't figure out how Random is intended to be used... I want to essentially map a function over some number of random numbers
11:10:42 <EvilTerran> "we can't inline here, this is unsafePerformIO country!"
11:12:09 <twobitwork> just when you think you understand monads...
11:13:41 <Saizan> ?type randomRs
11:13:43 <lambdac> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
11:14:09 <snhmib> EvilTerran: unsafeInterlave is even more fun!
11:14:22 <Saizan> > map (>5) $ randomRs (0,10) (mkStdGen 42)
11:14:23 <lambdac>  [False,True,False,False,False,True,True,False,False,True,False,True,True,Fal...
11:16:35 <twobitwork> I see
11:16:51 <twobitwork> I was looking that the functions with IO in their types
11:17:35 <twobitwork> wait... doesn't getStdRandom break referential transperancy?
11:17:53 <mar77a> monads
11:18:03 <twobitwork> ohh, of course
11:18:09 <mar77a> ...right?
11:18:17 <twobitwork> yeah, it's an IO
11:18:22 <twobitwork> didn't see that at first
11:18:49 <twobitwork> so, I'll have to pass a generator into my function... unless there's a way to use IO stuff outside of the IO monad...
11:21:00 <lilachaze> twobitwork: not a way we like to talk about :)
11:21:12 <twobitwork> right...
11:22:39 <twobitwork> ok... so the docs say "different results on each run by using the system-initialised generator" ... is that the one returned by getStrGen?
11:22:50 <twobitwork> s/Str/Std
11:23:19 <twobitwork> (ohh... wait, are regex's allowed here? because they modify the state of the backlog :P)
11:23:38 <dolio> FYI: You might want to use one of the mersenne twister packages on Hackage (the pure one, probably).
11:23:51 <dolio> They're way faster than the standard library random generators.
11:23:59 <tromp> @let sa = [(8,"MN"),(4,"AIW"),(3,"CO"),(2,"KSTV"),(1,"DFGHLPRU")]
11:24:02 <lambdac> Defined.
11:24:44 <tromp> > sum . map (\(n,s) -> n * length s) $ sa
11:24:46 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:25:06 <vixey> @let length [] = 0 ; length (_:xs) = 1+length xs
11:25:07 <lambdac> <local>:1:38:     Ambiguous occurrence `length'     It could refer to either ...
11:25:18 <vixey> @let length' [] = 0 ; length' (_:xs) = 1+length' xs
11:25:19 <lambdac> Defined.
11:25:30 <tromp> > sum . map (\(n,s) -> n * Data.List.length s) $ sa
11:25:31 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:25:50 <tromp> :t (\(n,s) -> n * length s)
11:25:52 <lambdac> forall a. (Int, [a]) -> Int
11:25:59 <tromp> :t sa
11:26:01 <lambdac> forall t. (Num t) => [(t, [Char])]
11:26:25 <twobitwork> the mersenne-random package says something about "It is designed to be fast when it runs on 128-bit SIMD"
11:26:26 <vixey> > sum . map (\(n,s) -> n * length' s) $ sa
11:26:27 <lambdac>  50
11:26:28 <twobitwork> what does that mean?
11:26:39 <vixey> tromp: that's why I defined length'
11:26:47 <tromp> :t Data.List.length
11:26:49 <lambdac> forall a. [a] -> Int
11:27:09 <tromp> why doesn't Data.List.length work?
11:27:09 <vixey> :t 1
11:27:11 <lambdac> forall t. (Num t) => t
11:27:25 <vixey> tromp: it's a type error
11:27:42 <tromp> where does it infer Integer?
11:27:49 <vixey> :t as
11:27:51 <lambdac> Not in scope: `as'
11:27:51 <dolio> SIMD is a set of extra instructions for fast computing on, like, vectors of floats or some such.
11:27:55 <vixey> :t sa
11:27:57 <lambdac> forall t. (Num t) => [(t, [Char])]
11:28:10 <vixey> :t sum
11:28:11 <lambdac> forall a. (Num a) => [a] -> a
11:28:19 <vixey> :t (*)
11:28:20 <tromp> should all be happy as Int
11:28:20 <dolio> Most x86-type processors these days have them, I imagine.
11:28:21 <lambdac> forall a. (Num a) => a -> a -> a
11:28:25 <Zao> Short for Single Instruction Multiple Data.
11:28:44 <Zao> The x86 implementation of assorted such instructions is SSE and its successors.
11:28:50 <Zao> PPCs have Altivec.
11:28:53 <tromp> :t length
11:28:55 <lambdac> forall a. [a] -> Int
11:29:20 <tromp> :t  sum . map (\(n,s) -> n * Data.List.length s) $ sa
11:29:23 <lambdac> Int
11:29:35 <dolio> Ah, yeah. I was thinking SSE specifically for some reason.
11:29:43 <tromp> >  sum . map (\(n,s) -> n * Data.List.length s) $ sa
11:29:44 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:29:48 <tromp> ?????
11:30:06 <Deewiant> > map (\(n,s) -> n * length s) sa
11:30:06 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:30:13 <vixey> > sum . map (\(n,s) -> n * Data.List.length s) $ sa :: Int
11:30:14 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:30:20 <Deewiant> > map (\(n,s) -> n * genericLength s) sa
11:30:22 <lambdac>  [16,12,6,8,8]
11:30:42 <vixey> :t (\(n,s) -> n * length s)
11:30:44 <lambdac> forall a. (Int, [a]) -> Int
11:30:46 <vixey> :t (\(n,s) -> length s)
11:30:48 <lambdac> forall t a. (t, [a]) -> Int
11:30:54 <vixey> :t (\(n,s) -> n)
11:30:56 <lambdac> forall t t1. (t, t1) -> t
11:31:13 <tromp> there's a bug somewhere...
11:32:39 <tromp> > map (\(n,s) -> n * length s) []
11:32:40 <lambdac>  []
11:32:47 <tromp> > map (\(n,s) -> n * length s) [(1,"HI")]
11:32:49 <lambdac>  [2]
11:32:53 <tromp> > map (\(n,s) -> n * length s) sa
11:32:54 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:33:03 <Deewiant> monomorphism restriction?
11:33:09 <vixey> :t [(1,"HI")]
11:33:10 <vixey> :t sa
11:33:11 <lambdac> forall t. (Num t) => [(t, [Char])]
11:33:12 <lambdac> forall t. (Num t) => [(t, [Char])]
11:33:26 <Deewiant> shrug
11:33:35 <vixey> @let x = 1
11:33:36 <lambdac> Defined.
11:33:48 <vixey> > (1::Int) + x
11:33:49 <lambdac> Terminated
11:33:53 <vixey> > (1::Int) + 1
11:33:54 <vixey> > (1::Int) + x
11:33:54 <lambdac>  2
11:33:55 <lambdac> Terminated
11:34:07 <vixey> @let x' = 1
11:34:08 <lambdac> Defined.
11:34:08 <vixey> > (1::Int) + x'
11:34:09 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:34:33 <vixey> > x'::Int
11:34:34 <lambdac>  Couldn't match expected type `Int' against inferred type `Integer'
11:34:38 <mar77a> http://en.wikipedia.org/wiki/Incest_between_twins
11:34:48 <mar77a> ehm
11:34:51 <mar77a> why no tinyurl
11:35:14 <Deewiant> lambdac doesn't do tinyurl?
11:35:32 <Deewiant> it's a pretty useless feature anyways, I find it annoying
11:54:49 <rtra> (,\ _ -> "this syntax would be way cooler")
11:55:22 <vixey> [$lam|(λu.uu)(λu.uu)|]
11:58:47 <prb__> Anyone else being bitten by what are apparently subtle API changes in ByteString between 6.8.2 and 6.8.3?
11:59:23 <prb__> e.g., pureMD5 0.2.3 won't build against my 6.8.3 install.
12:11:36 <bitrot> anyone know how to get tell cabal-install that I've got C-headers in /usr/local/include?
12:12:56 <prb__> bitrot: Same way you'd tell gcc to look there.
12:13:10 * prb__ would have to RTFM to remember the environment...
12:13:21 <dcoutts> bitrot: cabal configure --extra-include-dirs
12:13:32 <dcoutts> prb: so not the same way actually
12:13:41 <bitrot> yeah, it didn't like CFLAGS
12:13:57 <dcoutts> bitrot: no, it doesn't look at any env vars
12:14:17 <dcoutts> there's --extra-lib-dirs= and --extra-include-dirs=
12:14:35 <dcoutts> which apply to the configure and install commands
12:21:09 <bitrot> dcoutts: thanks
12:22:16 <prb__> dcoutts: Interesting; seems to find my libs/includes OK, but that must be due to some other coincidence, then.
12:22:36 <prb__> dcoutts: I've got a cabal question for you as well.
12:22:38 * bitrot finally notices cabal COMMAND --help
12:23:08 <dcoutts> bitrot: check out the bash command line completion too :-)
12:23:25 <prb__> dcoutts; I just fired that up last night; very nice.
12:23:35 <dcoutts> prb__: if ghc/gcc knows about those include dirs then nothing further is needed
12:24:00 <dcoutts> gcc has a built-in include search path
12:24:27 <dcoutts> prb__: you had another cabal question?
12:24:38 <prb__> dcoutts: I'm getting blocked by bytestring-0.9.1 versus bytestring 0.9.0.1.1 where thing were worked under 6.8.2 with older Cabal and now failing under 6.8.3 with newer Cabal and cabal-install.
12:24:50 <dcoutts> 'k
12:25:11 <dcoutts> so what's going on specifically?
12:25:40 <prb__> pureMD5 is a good example.  Won't build for me currently.
12:26:02 <prb__> I've tried locking the bytestring version up to 0.9.1, but it still complains about an API issue with 0.9.0.1.1...
12:26:21 <prb__> This may well be an API hygiene issue with bytestring, but cabal isn't helping me find out.
12:26:52 <dcoutts> prb__: perhaps you can use hpaste to show me the output of cabal install pureMD5
12:27:33 <hpaste>  prb pasted "cabal install pureMD5" at http://hpaste.org/8539
12:28:17 <hpaste>  prb pasted "ghc-pkg list" at http://hpaste.org/8540
12:28:23 <dcoutts> prb__: hmm, that's odd. What version of cabal-install is that?
12:28:42 <prb__> 0.5.1 of cabal-install, 1.4.0.1 of Cabal
12:29:31 <dcoutts> prb__: can you do it again with -v? I want to see how it's configuring the package, what versions of things its choosing.
12:30:09 <dcoutts> prb__: cabal-install is specifically supposed to avoid ending up using two versions of the same package
12:30:17 <dcoutts> but that's what seems to be happening
12:30:28 <hpaste>  prb__ pasted "cabal install -v pureMD5" at http://hpaste.org/8541
12:30:53 <prb__> dcoutts: Which then causes ghci to abort... :)
12:33:08 <dcoutts> prb__: what does this report: $ ghc-pkg field binary depends
12:33:27 <dcoutts> prb__: I suspect binary-0.4.2 was built against bytestring-0.9.0.1.1
12:34:08 <hpaste>  prb__ pasted "ghc-pkg field binary depends" at http://hpaste.org/8542
12:34:30 <prb__> I'll unregister the one that's based on the earlier bytestring.
12:34:38 <dcoutts> prb__: wait a sec
12:34:59 <dcoutts> prb__: so what is really confusing me is that this doesn't trigger an error in cabal first.
12:35:19 <dcoutts> prb__: what versions of binary do you have installed?
12:35:30 <dcoutts> what does ghc-pkg list binary report?
12:35:47 <dcoutts> is the same version of binary registered in both the global and user package dbs?
12:35:59 <prb__> 0.4.2 in both global and user space.
12:36:04 <dcoutts> that might be the source of our problem. Perhaps cabal isn't understanding that correctly
12:36:33 <dcoutts> so it's looking at the version of binary that's built against bytestring-0.9.1.0
12:36:46 <dcoutts> but the one we're actually using is the version of binary that's built against bytestring-0.9.0.1.1
12:37:03 <prb__> I guess ghc is resolving the dependency differently?
12:37:07 <dcoutts> so cabal thinks there's no problem because it's looking at the wrong one
12:37:21 <dcoutts> I bet it's because cabal thinks global packages override user ones
12:37:26 <dcoutts> but it's actually the other way around
12:37:44 <dcoutts> it uses map union and I bet I've got that the wrong way round
12:38:27 <prb__> If you tell me which file, I can try it.
12:38:28 <dcoutts> prb__: thanks. I'll investigate this. And yes the solution should be to unregister the user one. Then it should work.
12:38:45 <dcoutts> prb__: oh, you want to test a fix to cabal-install? that'd be even better
12:38:50 <esteth> I've read that Text.Regex.Posix's =~ is supposed to be able to give me a [String] back if i specify that i want one, but whenever i do so, i just get a type error, as if i had used any other unsupported type, does anyone know if I've been misinformed, or if there's something wrong with my environment?
12:39:03 <dcoutts> prb__: in that case don't touch ghc-pkg yet, we'll use it as the test case
12:39:48 <prb__> dcoutts: I just unregistered it, but I can put it back.
12:40:09 <prb__> dcoutts: After ghc-pkg --user unregister binary, pureMD5 builds OK.
12:40:39 <dcoutts> prb__: ok. Right so for the test case it'd have to be the binary-0.4.2 built against bytestring-0.9.0.1.1
12:40:51 <dcoutts> and registered in the user db
12:41:17 <prb__> dcoutts: Right.
12:41:21 <dcoutts> prb__: have you got the darcs repo for cabal-install?
12:41:36 <prb__> Not at present; I can get it.
12:42:05 <dcoutts> prb__: oh, we might need the Cabal-1.4 darcs repo too actually
12:42:27 <prb__> dcoutts: There's more similar fun to be had with parsec, btw.
12:42:43 <prb__> I have some bits that require parsec 2.1... and some that require parsec 3.0...
12:44:12 <hpaste>  prb__ pasted "cabal configure --prefix=/Users/prb/opt/local" at http://hpaste.org/8543
12:44:51 <dcoutts> prb__: cabal configure actually doesn't yet use the same clever dep resolution algorithm to choose which versions of deps to use.
12:47:58 <prb__> dcoutts: Looks like I've got some sorting to do, since hxt 8.1 doesn't like parsec 3.
12:49:11 <prb__> dcoutts: And while I'm at it, why does cabal keep rebuilding network-2.2.0.0?
12:49:33 <dcoutts> prb__: you've not set cabal to do global installs have you? in the ~/.cabal/config?
12:49:58 <prb__> dcoutts: It's running as local installs.
12:50:11 <prb__> dcoutts: But network-2.2.0.0 is already in user package space.
12:50:20 <prb__> dcoutts: cabal keeps rebuilding it.
12:50:38 <dcoutts> prb__: so your ~/.cabal/config says user-install: True  right?
12:51:01 <prb__> Yes.
12:51:05 <dcoutts> ok
12:51:13 <dcoutts> there goes that theory :-)
12:52:03 <rwbarton> Has anyone gotten a recent ghc HEAD from darcs to build and install?
12:53:20 <dolio> The Glorious Glasgow Haskell Compilation System, version 6.9.20080619
12:54:14 <dolio> 6 days old is pretty recent.
12:54:29 <rwbarton> It builds successfully for me, but then I get linker errors when I try to 'sudo make install'.
12:54:47 <dolio> Hmm, I didn't see that.
12:55:10 <dolio> Compiling did segfault once for me, but I figured that was just my machine flaking out.
12:55:30 <dolio> Since restarting make completed successfully.
12:55:44 <rwbarton> How can I tell darcs to check out a specific version?
12:56:05 <rwbarton> (I suspect I'm doing something wrong, so I want to rule out the possibility that the repository is just broken)
12:59:02 <prb__> dcoutts: Looks like hxt-8's dislike of parsec-3 was the issue.  Hopefully the next version of Text.XML.Light is usable.
12:59:22 <dcoutts> prb__: yes parsec-3 is quite different
13:00:25 <BMeph> Is there anyone that specializes in making Darcs work on Windows? :)
13:00:56 <BMeph> (Since making Windows work would be asking a bit much... ;)
13:07:16 <LordBrain> dons, you here?
13:07:38 <LordBrain> Do you still have that shell script which automates adding type signatures in vim?
13:09:25 <proq> BMeph: there must be: darcs on windows worked fine for me, though I don't use it anymore
13:09:50 <proq> @src loeb
13:09:52 <lambdac> Source not found. Sorry about this, I know it's a bit silly.
13:13:33 <MyCatVerbs> proq: loeb x = fmap (\a -> a (loeb x)) x
13:14:05 <proq> MyCatVerbs: thanks
13:14:26 <MyCatVerbs> No worries. Blog post about it is here, by the way: http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
13:14:27 <lambdac> Title: A Neighborhood of Infinity: Tying Knots Generically
13:14:49 <MyCatVerbs> @let loeb x = fmap (\a -> a (loeb x)) x
13:14:50 <lambdac> <local>:12:0:     Multiple declarations of `L.loeb'     Declared at: <local>:...
13:15:50 <MyCatVerbs> Looks like someone already put it in.
13:16:16 <BMeph> proq: Oh, it usually works fine for me, but I'm getting odd permission errors now, and was hoping that a "resident genius" could give a quick diagnosis/solution to the issue. :)
13:17:13 <MyCatVerbs> > loeb [const 40,length]
13:17:14 <lambdac>  [40,2]
13:17:43 <BMeph> Back onto topic, but is there an equivalent to Loeb's theorem (or at least the function) that works with the "conventional" monad form?
13:18:02 <byorgey> > loeb [const 1, (+2) . head, (+1) . head . tail]
13:18:04 <lambdac>  [1,3,4]
13:18:10 <byorgey> AMAZING
13:18:39 <joey__> > loeb (Just fromJust)
13:18:47 <lambdac>  Just Exception: Time limit exceeded
13:18:51 <BMeph> > loeb [const 1, (+2) . head, (+1) . head . tail, (!!1) + (!!0)]
13:18:52 <lambdac>   add an instance declaration for (Num ([a] -> a))
13:19:18 <byorgey> try liftM2 (+) (!!1) (!!0)
13:19:55 <BMeph>  loeb [const 1, (+2) . head, (+1) . head . tail, liftM2 (+) (!!1) (!!0)]
13:20:23 <joey__> Missing the ">"
13:20:24 <BMeph> >  loeb [const 1, (+2) . head, (+1) . head . tail, liftM2 (+) (!!1)
13:20:24 <BMeph> 	(!!0)]
13:20:24 <lambdac>  Parse error at end of input
13:20:59 <joey__> > loeb (1, fst)
13:21:01 <lambdac>  (1,1)
13:21:33 <MyCatVerbs> BMeph: you mean a loebM?
13:21:41 <Cale> >  loeb [const 1, (+2) . head, (+1) . head . tail, liftM2 (+) (!!1) (!!0)]
13:21:42 <lambdac>  [1,3,4,4]
13:22:10 <BMeph> MyCatVerbs: No, more like a "dual" to loeb.
13:22:31 <MyCatVerbs> Oh, k.
13:22:33 <BMeph> BTW, thx for the clean-up, Cale. :)
13:22:53 <Cale> :t loeb
13:22:56 <lambdac> Not in scope: `loeb'
13:23:04 <Cale> hmm
13:23:20 <Cale> >  loeb [const 1, (+2) . head, (+1) . head . tail, liftM2 (+) (!!1) (!!0)]
13:23:21 <lambdac>  [1,3,4,4]
13:23:29 <BMeph> MyCatVerbs: I.e., something with a signature:: m(a -> m a) -> m a, or something similar
13:23:39 <Cale> oh, we have a different lambdabot...
13:24:12 <BMeph> :t L.loeb
13:24:14 <lambdac>     attempting to use module `L' (L.hs) which is not loaded
13:24:26 <BMeph> Bah. :p
13:24:31 <BMeph> :P
13:24:33 <MyCatVerbs> BMeph: er, well. Monad m implies Functor m too.
13:24:51 <Cale> @let loeb x = fmap (\a -> a (loeb x)) x
13:24:52 <MyCatVerbs> BMeph: since fmap == (return .)
13:24:53 <lambdac> <local>:12:0:     Multiple declarations of `L.loeb'     Declared at: <local>:...
13:25:01 <lambdabot> Defined.
13:25:02 <MyCatVerbs> :t loeb
13:25:04 <lambdac> Not in scope: `loeb'
13:25:11 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
13:25:29 <Cale> lambdac: @part #haskell
13:25:30 <lambdac> Not enough privileges
13:25:31 <MyCatVerbs> Yay, \bot's back!
13:25:37 <BMeph> MyCatVerbs: Fine, change the "m"'s to "f"'s, if it floats your boat. I was just using "m" for the type var for familiarity (on my part). :)
13:25:39 <Cale> People should tell me if it dies.
13:26:22 <Cale> Who is running lambdac?
13:26:33 <MyCatVerbs> BMeph: right, m'just saying, f (f x -> x) -> f x, is just as good as m (m x -> m) -> m x. Slightly better, in fact. ^^
13:26:33 <BMeph> Cale: I suspect she didn't so much die, as get killed... o.O
13:26:41 <Cale> BMeph: right.
13:27:15 <Cale> BMeph: Well, actually it looks like it got disconnected from the network in some way that failed to be detected.
13:27:25 <Cale> It was still running, actually.
13:28:00 <BMeph> Cale: Hmm... I suspect Foul Play! >;)
13:28:14 --- mode: ChanServ set +o Cale
13:28:18 --- kick: lambdac was kicked by Cale (Cale)
13:28:22 --- mode: Cale set -o Cale
13:28:45 <MyCatVerbs> As Cale demonstrates: when in doubt, apply brute force.
13:29:10 <BMeph> MyCatVerbs: Okay, so do you know of a function signature of (Functor f) => f (b -> f b) -> f b?
13:29:40 <BMeph> Or even (Functor f) => f b -> f (b -> f b)? :)
13:29:42 <MyCatVerbs> BMeph: oh, oops. Looks like I've read you wrong.
13:29:54 <Cale> MyCatVerbs: A friend of mine used to say that violence is the solution to any problem. If the problem isn't going away, you're probably just not using enough of it.
13:30:35 <BMeph> Cale, MyCatVerbs: I prefer "Knowledge is half the battle. The other half is Violence!" ;)
13:31:40 <MyCatVerbs> BMeph: "There is no such thing as 'overkill'. There is only 'open fire!' and 'I need to reload. :/'"
13:32:31 <vixey> you know
13:32:31 <Japsu> One does not simply "open fire!" into Mordor.
13:32:36 <vixey> case foo of
13:32:44 <vixey>  <pattern> -> ...
13:32:44 <MyCatVerbs> :t fmap (\a -> let x = fmap a x)
13:32:46 <lambdabot> parse error on input `)'
13:32:49 <Japsu> Neither does one simply pattern match into Mordor.
13:32:51 <MyCatVerbs> :t fmap (\a -> let x = fmap a x in x)
13:32:53 <Cale> :t \x -> const x . x
13:32:53 <lambdabot> forall b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (b -> b) -> f1 (f b)
13:32:55 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (f a)
13:33:02 <vixey> the pattern could bind some variables, for the ...
13:33:05 <MyCatVerbs> Buggery, that's wrong.
13:33:12 <vixey> is a good name for that the pattern clouser?
13:33:15 <vixey> pattern closure*
13:33:18 <vixey> or something else?
13:33:57 <Cale> vixey: A case expression? I'm not sure what you mean :)
13:34:05 <vixey> e.g.  Left (x,y) -> x + y, can be written Left (x,y) -> (\x y -> x + y) x y
13:34:11 <vixey> what's a good name for (\x y -> x + y)
13:34:22 <bd_> vixey: (+)
13:35:13 <Cale> hmmm
13:35:33 <EvilTerran> ?type \x -> fmap (\_ y -> fmap (const y) x) x
13:35:35 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f a1 -> f (a -> f a)
13:35:49 <MyCatVerbs> ...can you write join in terms of fmap, without needing >>=?
13:35:56 <EvilTerran> mmm, close
13:36:00 <Cale> MyCatVerbs: no
13:36:03 <EvilTerran> MyCatVerbs, don't think so
13:36:11 <MyCatVerbs> Ah, right. Buggery.
13:36:16 <bd_> MyCatVerbs: no. You can make join/return/fmap from return/>>=, or vice versa, but you need all of the bits from one or the other
13:37:04 <MyCatVerbs> Thanks.
13:37:44 <tusho> MyCatVerbs: think about it
13:37:45 <tusho> x >>= id
13:37:55 <tusho> it needs to be able to return m b
13:47:51 <BMeph> Cale: Not as easy as you'd think, eh? :)
13:59:07 <vixey> :t (+++)
13:59:09 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
13:59:10 <vixey> :t (***)
13:59:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:01:57 <djsiegel> Does anyone know of any Haskell bindings for Clutter (http://clutter-project.org/)?
14:08:41 <wgw> beginner problem: when I type into ghci "data Pair = a b" I get an error message: <interactive>:1:0: parse error on input `data'
14:08:59 <vixey> wgw: You should put this into a file foo.hs
14:08:59 <mrd> can't
14:09:05 <mrd> what vixey said
14:09:11 <vixey> wgw: once you have done that, then you can load definitions with :l foo
14:09:27 <wgw> wow! simple answer
14:09:30 <rwbarton> wgw: You need to choose a data constructor name, like "data Pair = PairCon a b"
14:09:43 <wgw> So the interpreter does not take that kind of declaration?
14:09:52 <vixey> no it does not
14:09:58 <rwbarton> (Unless there is some kind of default?)
14:10:19 <wgw> Ok: I will try loading it from a file.
14:10:48 <wgw> (I'm working through YAHT; there was no mention of that problem)
14:10:59 <frwmanners> wgw: btw, Pair a b = PairCon a b
14:11:07 <rwbarton> I guess "a b" is a placeholder for something else, probably
14:11:10 <wgw> Yes: I will do that as well
14:11:14 <rwbarton> ?
14:11:18 <vixey> solve one problem at a time
14:11:24 <wgw> ok
14:11:39 <LordBrain> hey... i'm trying to build hadock, i haven't compiled a cabal package before... i tried ./Setup.lhs configure etc... and it doesn't seem to do anything
14:12:07 <byorgey> LordBrain: what do you mean, 'doesn't do anything'? what are you expecting it to do?
14:12:19 <LordBrain> run the compiler for one
14:12:21 <rwbarton> ./Setup.lhs won't work, try runhaskell Setup.lhs?
14:12:25 <LordBrain> yes
14:12:27 <LordBrain> i tried that
14:12:28 <joey__> LordBrain: Try > runghc Setup.lhs configure
14:12:35 <wgw> thanks all for the quick fix
14:12:51 <LordBrain> joey__, same results...
14:12:58 <LordBrain> nothing
14:13:04 <LordBrain> no output at all
14:13:09 <rwbarton> Maybe that means it worked.
14:13:15 <rwbarton> Have you tried runghc Setup.lhs build next?
14:13:23 <LordBrain> yes
14:13:30 <LordBrain> i did
14:13:35 <LordBrain> no output
14:13:52 <byorgey> no output, meaning, you just get back another prompt immediately?
14:13:58 <LordBrain> yes
14:14:08 <dons> http://www.reddit.com/info/6ozb1/comments/
14:14:09 <lambdabot> Title: reddit.com: Haskell Weekly News: Summer of Code, HAppS, SoCal user group, new Pu ...
14:14:12 <dons> byorgey++ go go go!
14:14:19 <LordBrain> shouldn't I expect to see like compiler messages?
14:14:37 <LordBrain> i'm  not getting any feedback
14:14:50 <byorgey> LordBrain: yes, this is very strange
14:15:01 <byorgey> it is most likely caused by devious chipmunks
14:15:14 <LordBrain> damn it i got to go
14:15:19 <LordBrain> i'm on mac os x
14:15:29 <LordBrain> dont know if that would make any difference
14:15:53 <LordBrain> i'll try again later...
14:15:56 <LordBrain> see you
14:15:56 <byorgey> dons: thanks for posting that =)
14:16:04 <byorgey> later LordBrain
14:16:45 <byorgey> dons: btw, in the hwn README there is something about emailing the HWN to lwn@lwn.net, is that still applicable?  what is lwn.net?
14:17:17 <dons> linux weekly news
14:17:23 <dons> they put the HWN into a section
14:17:27 <dons> yes, that's still  relelvant
14:17:34 <dons> just a quick email with a one line summary and a link
14:17:45 <dons> they include the email verbatim in the linux weekly news
14:19:16 <byorgey> ok, cool
14:24:49 <pgavin> omg, this space leak is driving me nuts
14:25:44 <dons> come on, they're easy. compile the code with optimisations. if that doesn't fix it, compile with -prof -auto-all and look at the top allocator on the call stack
14:26:06 <dons> then have a think particularly about data structure updates, and lazy parameters in tight loops
14:26:29 <pgavin> dons: it actually turns out that the top allocator isn't where the leak is
14:26:43 <pgavin> I've added bangs everywhere I can think of
14:27:09 <dons> well, you're profiling? try using cost centres on expressoins to narrow down to the subexpression what the cost is
14:27:37 <pgavin> dons: it's in a CAF
14:27:52 <pgavin> and I've stuck scc pragmas all over
14:27:55 <pgavin> still no luch
14:27:59 <pgavin> luck*
14:28:02 <dons> are you updating a top level structure?
14:28:27 <pgavin> sorta
14:28:43 <pgavin> its a structure of recursively nested functions and data
14:29:00 <geezusfreeek> exit
14:29:03 <geezusfreeek> oops
14:29:05 <geezusfreeek> wrong window
14:29:13 <pgavin> eg, the structures embed functions that close around other data
14:29:32 <dons> i'd think about te strictness of updates in that structure perhaps
14:29:35 <pgavin> all the changes are local to the embedded functions
14:29:47 <pgavin> there's only 3 fields, all of them are strict
14:30:27 <pgavin> I'm using arrows, which doesn't help any
14:31:06 <pgavin> and I need ghc-6.9 for type families
14:31:40 <pgavin> and whenever I use +RTS -hr -RTS it crashes soon after it starts running
14:32:02 <dons> please report crashes
14:32:04 <dons> ?bug
14:32:04 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:32:31 <pgavin> I need to whittle down a test case I can submit first
14:40:07 <dons> dcoutts: http://timemaychangeme.com/?p=16
14:40:08 <lambdabot> Title: 8 Oxford 2 : 1 12 Time may change me 34
14:40:16 <dons> "We took a look at Haskell, a rarely
14:40:17 <dons> used programming language that Oxford undergradates used"
14:40:20 <dons> boo!
14:40:49 <vixey> those Oxford undergradates.. taking all the credit
14:41:53 <sek> imperial teaches haskell as the first language too!
14:41:56 * BMeph wonders how they explain the name "GHC"...
14:42:33 <monochrom> haha
14:42:57 <sek> and Bristol CS demonstrates the same example on open days
14:48:00 <solrize> how much type system hackery do they end up teaching in those courses?
14:48:36 <monochrom> None. They teach program derivations, e.g., those of Bird's.
14:49:02 <solrize> i'm not sure what that means
14:49:31 <vixey> that would be great
14:50:05 <Cale> solrize: Start with a simple, but inefficient specification of what the program should do, and use algebraic transformations to get an efficient program (for instance).
14:50:12 <monochrom> It means for example transforming one fib formula to another using algebraic laws. Hopefully you end up with a fast formula.
14:50:26 <solrize> right, i just wonder how much the type system comes into play
14:50:34 <monochrom> None.
14:50:45 <Cale> Other than that things have to be well-typed, not at all.
14:50:51 <vixey> ?go algebra of programming with dependent types
14:50:53 <lambdabot> http://www.iis.sinica.edu.tw/~scm/pub/mpc08.pdf
14:50:59 <vixey> it's possible to machine check all this of course
14:51:03 <monochrom> None other than making sure that whenever you write "f . g" the domains and co-domains match up.
14:51:06 <vixey> just very unusual and recent
14:51:16 <solrize> so they could in principle do the same stuff with scheme?
14:51:46 <monochrom> Yes.
14:51:48 <dons> hard to teach ADTs
14:51:50 <Cale> solrize: Except that scheme is effectful, so it's harder to use algebraic transformations (because fewer transformations are valid)
14:52:12 <solrize> well, scheme admits an effectful style but you can also write pure functional code in it
14:52:23 <monochrom> The pure subset of scheme, yes.
14:52:34 <Cale> Right, if you assume that functions are pure, then you can pretty much do the same thing.
14:52:44 <monochrom> Bird himself used to use his own little pet called "squiggol".
14:52:59 <tromp> you can write pure code in almost any language:)
14:53:13 <solrize> i remembered the term squiggol but associated it with type system hackery
14:53:20 <monochrom> Need higher-order functions to fly.
14:54:04 <monochrom> There is no type system hackery in squiggol.
14:54:12 <vixey> if the category theory side was just a bit easier to understand.. :(
14:54:43 <monochrom> You could do without category theory.
14:56:04 <Cale> Has anyone written down a category-theoretic formulation of the Bird-Meertens formalism?
14:57:35 <monochrom> Yes. See the third book in http://www.vex.net/~trebla/weblog/fpbooks.xhtml
14:57:55 <monochrom> Or generally most of Bird's papers.
14:58:37 <monochrom> Oops, 5th book (counting top-down on the text side)
14:59:11 <monochrom> Perhaps I should just spell it out.  "Algebra of Programming" by Bird and de Moor.
14:59:55 <vixey> yeah that is the book I'm reading
15:00:13 <BMeph> tromp: It's tough writing pure Forth, though. :)
15:00:58 * BMeph wishes someone would tell his IT dept, that (many) CWI sites, are in fact, not full of porn. :|
15:01:31 <monochrom> sexy math theories are porn.
15:01:55 <monochrom> Bird is a sexy pornographer.  *duck*
15:02:28 <lament> "Group theory"?
15:03:01 <Cale> Continuous group action
15:04:28 <vixey> hey..
15:04:38 <vixey> you could have strong sum types in a language like haskell couldn't you?
15:04:48 <vixey> (for a new module system)
15:05:03 <vixey> without having to take stuff like ∏ along as well
15:06:06 <monochrom> Is a strong sum type like "Either x y"?
15:06:56 <vixey> ∑x:A.B
15:07:16 <vixey> it's basically the type (A,B) but B could depend on A
15:07:29 <ddarius> It's strong because the sigma is all grown up.
15:07:55 <ddarius> Usually one just says dependent sum.
15:08:01 <vixey> well you can take both projections
15:08:09 <monochrom> Then Haskell doesn't have it.
15:08:10 <vixey> (I think that's why it's called strong, maybe)
15:12:35 <povman> @bot
15:12:36 <lambdabot> :)
15:12:44 <povman> quicksilver++
15:13:59 <vixey> maybe it would not make sense in haskell
15:18:36 <dcoutts> dons: heh, I was running that open day today demoing haskell stuff :-)
15:18:44 <dons> hehe
15:18:48 <dcoutts> though I wasn't giving the talk
15:18:55 <dons> they were high school students?
15:18:59 <dcoutts> right
15:19:05 <dcoutts> just showing off cool 3d wizzy things
15:19:09 <dons> everyone's got a blog these days
15:19:27 <dcoutts> they'll be applying this autumn for entry the following autumn
15:33:19 <BMeph> dcoutts: Goslings? ;)
15:33:31 <dcoutts> heh
15:43:32 <dons> mm HStringTemplate's pretty good
15:45:43 <RayNbow> hmm, which known algorithms do not translate well to a functional equivalent?
15:46:15 <mauke> splay tree search?
15:46:40 <dons> purely functional equivalent? things that rely heavily on heavy non-local pointer manipulation
15:46:46 * RayNbow doesn't know anything about splay trees :p
15:46:59 <mauke> splay trees rebalance themselves on each operation
15:47:10 <mauke> e.g. after a search the found element will be at the root
15:47:54 <RayNbow> the question then is, does it matter that some algorithms do not translate well?
15:48:20 <RayNbow> (because often there are also other alternative algorithms)
15:52:16 <Cale> RayNbow: It seems in general that you only take a logarithmic hit in complexity, if you use appropriate datastructures. (and whether that logarithmic factor really counts is questionable, because pointers would also get larger as n grows without bound)
15:53:30 <Cale> (it's just that people don't usually consider pointer manipulation to be O(log n))
15:54:49 <RayNbow> Cale: that's probably because pointers are usually limited to the computer's word size
15:55:11 <RayNbow> (but then again, everything's limited by the address space :p)
15:55:15 <monochrom> and therefore sorting is O(1) on such a computer.
15:55:29 <Cale> monochrom: right :P
15:56:14 <monochrom> Hell, P=NP on such a computer. Proof: P = O(1), NP = O(1).
15:56:34 <Cale> Heh, so P = NP in practice ;)
15:56:43 <monochrom> Either O is meaningless, or such a computer is meaningless, or... I don't know.
15:57:37 <Riastradh> ...or the size of the address space is not the only relevant consideration.
15:58:02 <dcoutts> prb__: I've tried to reproduce your cabal-install problem with clashing versions of binary and bytestring but I cannot. In what appears to be the same circumstance here cabal-install just does the right thing rather that compiling pureMD5 and failing.
15:58:29 <dcoutts> prb__: for me, it decides to re-compile binary against a different version of bytestring and then pureMD5 works fine
15:58:30 <Cale> It's interesting that you have functions which are in any given complexity class which are only bounded by a constant multiple of that function for values larger than Graham's number (or pick your favourite large constant)
15:58:56 <Cale> So big O notation is in a sense inherently impractical.
15:59:15 <Riastradh> It is only theoretically impractical.
16:01:11 <sutats> Is length $ show the best way to find how many digits are in an Int?
16:01:33 <dobblego> length . show
16:01:34 <Cale> length . show, you mean :)  length $ show is a type error :)
16:02:06 <ziman> > ceiling . logBase 10 $ 12345
16:02:08 <lambdabot>  5
16:02:18 <RayNbow> > let ($) = (.)   in (length $ show) 123
16:02:19 <lambdabot>  3
16:02:25 <RayNbow> > let ($) = (.)   in (length $ show) -123
16:02:26 <lambdabot>   add an instance declaration for (Num (a -> Int))
16:02:29 <RayNbow> > let ($) = (.)   in (length $ show) (-123)
16:02:31 <lambdabot>  4
16:02:40 <dcoutts> prb__: can you check something for me, I want to know if I'm reproducing your setup correctly.
16:02:44 <gwern> I am astonished. byorgey seems to actually be keeping the HWN weekly
16:02:44 <sutats> Ah, I meant "length $ show int"
16:02:51 <RayNbow> that minus sign keeps biting me, even though I know about it :p
16:02:59 <gwern> @karma +1 byorgey
16:02:59 <lambdabot> +1 has a karma of 0
16:03:12 <Saizan> byorgey++
16:03:18 <RayNbow> ++byorgey
16:03:41 <ziman> @karma+ byorgey
16:03:41 <lambdabot> byorgey's karma raised to 16.
16:03:55 <dcoutts> prb__: if you do ghc-pkg describe binary, it should list both the one in the global and user dbs. Can you tell me what version of bytestring the one in the global and user dbs are using? I need to know which way round it is.
16:04:30 <mauke> preflex: karma byorgey
16:04:30 <preflex>  karma for byorgey: 16
16:05:31 <RayNbow> ziman
16:05:32 <RayNbow> > ceiling . logBase 10 $ (-12345)
16:05:34 <lambdabot>  2696539702293473861593957786183537100426965468413459859101451217365990137082...
16:05:38 <RayNbow> is that correct?
16:05:45 <RayNbow> :p
16:06:01 <gwern> (that reminds me, why are we using that syntax anyway?...)
16:06:02 <MyCatVerbs> RayNbow: what did you DO!?
16:06:06 <mauke> > ceiling (0/0)
16:06:07 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
16:06:22 * MyCatVerbs picks up mauke and slaps RayNbow with him.
16:06:25 <lament> what
16:06:30 <MyCatVerbs> Stop abusing IEEE754!
16:06:36 <mauke> archimedes refuted, floating point WINS
16:07:06 <pjdelport> exponentiality
16:07:13 <MyCatVerbs> It's delicate! And fragile! Dammit, the whole discipline of numerical computing revolves specifically around not doing what you just did!
16:07:57 <lament> haha
16:08:00 * MyCatVerbs curls up in a corner and cries. "Oh, the poor bastards' mantissas..."
16:08:00 <lament> FORBIDDEN MAGIC
16:08:08 <ziman> > ceiling . logBase 10 . abs $ -12345
16:08:09 <lambdabot>  5
16:08:12 <Riastradh> RayNbow, what is the `ceiling' of a complex number?
16:08:32 <mauke> > ceiling . logBase 10 . abs $ 0.5
16:08:33 <lambdabot>  0
16:08:34 <Riastradh> (or, of not a number?)
16:08:39 * gwern senses a disturbance in the matrix... as if a million engineers cried out in horror and were suddenly overflowed
16:09:03 <mauke> > length . filter isDigit . show $ 0.5
16:09:04 <lambdabot>  2
16:09:05 <RayNbow> > ceiling $ sqrt (-1)  -- Riastradh? (yes, I know this is wrong :p)
16:09:07 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
16:09:10 <mauke> THERE ARE TWO DIGITS!
16:09:20 <mauke> > length . filter isDigit . show $ sqrt (-1)
16:09:22 <lambdabot>  0
16:09:30 <gwern> 'GHC API. Thomas Schilling (nominolo) is supposedly working on improvements to the GHC API. However, officials at HWN headquarters have begun privately speculating that Thomas does not, in fact, exist.'
16:09:52 <mauke> preflex: seen nominolo
16:09:52 <preflex>  nominolo was last seen on #ghc 5 days, 9 hours, 45 minutes and 39 seconds ago, saying: i see
16:10:01 <MyCatVerbs> gwern: think less "overflow" and more "NaN".
16:10:05 <ziman> mauke, the question concerned Int expressly ;)
16:10:19 <MyCatVerbs> Why the Hell is (ceiling NaN) defined to such a crazy value, anyway?
16:10:19 <ziman> 0.5 is not an Int ;)
16:10:40 <gwern> ziman: and the engineers were suddenly NaE?
16:11:30 <mauke> ungineer
16:11:59 <mauke> suddenly! it occurs to me that "number" means "more numb"
16:12:18 <dolio> It's an oversight in decodeFloat. It doesn't look for exceptional IEEE values.
16:13:29 * gwern feels number when it's cold out than not
16:13:59 <gwern> incidentally everyone, Monadius and Shu-thing have darcs repos now - code.haskell.org/monadius and shu-thing
16:18:48 <pjdelport> > decodeFloat (0/0)
16:18:49 <lambdabot>  (-6755399441055744,972)
16:19:23 <pjdelport> (-6755399441055744) * 2^972
16:19:25 <pjdelport> > (-6755399441055744) * 2^972
16:19:26 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
16:19:34 <pjdelport> MyCatVerbs: -^
16:20:21 <Botje> infinity sure is big!
16:20:46 <dolio> That's actually NaN.
16:20:57 <dolio> > ceiling (1/0)
16:20:58 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
16:21:09 <dolio> > ceiling (-1/0)
16:21:10 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
16:22:03 <dolio> NaN is actually a larger negative number than -Infinity. :)
16:22:22 <RayNbow> > orderPizza
16:22:24 <lambdabot>  Pepperoni-lambda, coming up!
16:22:34 <gwern> dolio: not smaller?
16:22:36 <RayNbow> ah, the definition is still in lambdabot :)
16:22:57 <MyCatVerbs> dolio: but applying ceiling breaks the invariant that forall a, (a <= Inf) == True, no?
16:23:03 <dolio> gwern: Larger absolute value.
16:23:55 * gwern will never understand floating point stuff, 'tis obvious
16:23:57 <dolio> I'm not sure that holds for IEEE floating point anyway.
16:24:06 <dolio> > (0/0 <= 1/0)
16:24:07 <lambdabot>  False
16:24:26 <dolio> NaN `comparison` Whatever == False
16:24:29 <MyCatVerbs> > ((<) `on` ceiling) (logBase 10 (-12345)) (1/0)
16:24:30 <lambdabot>  False
16:24:40 <MyCatVerbs> > ((>) `on` ceiling) (logBase 10 (-12345)) (1/0)
16:24:41 <lambdabot>  True
16:25:04 <MyCatVerbs> Right, so ceiling Inf > ceiling NaN.
16:25:32 <dolio> Yes.
16:25:32 <MyCatVerbs> Of course, that's merely one of the many possible values of NaN, but let's not go into that too deeply, aye?
16:26:06 <dolio> Yeah, I'm not familiar enough with IEEE to know how many representations of infinity/NaN there are.
16:26:25 <MyCatVerbs> There's one each for [+-] Inf, and an awwwwwwful lot for NaN.
16:26:41 <dolio> Anyhow, arguably, ceiling should be :: RealFrac -> Maybe Integral.
16:26:54 <dolio> Or should turn Infinity/NaN into bottom.
16:26:58 <dolio> But, that isn't done.
16:27:09 <MyCatVerbs> Eh. Enforcing that it's only given sane values is a numerical programmer's job.
16:27:50 <dolio> The Maybe option probably doesn't make much sense, since you could have a RealFrac type that doesn't have such exceptional values.
16:28:00 <dolio> Plus, it'd be a pain to use.
16:28:02 <MyCatVerbs> Which has to be done -anyway-, to avoid things blowing up on machine epsilons and so on. Making them pattern match away a whole bunch of Justs is probably pointless.
16:28:41 <MyCatVerbs> (Well, of course, you would write the whole thing in the Maybe monad, but it's not usually acceptable to ever get back the value Nothing anyway.)
16:28:54 <MyCatVerbs> I mean, but even then it's not...
16:30:52 <dolio> Yeah, calling error in those cases might be acceptable.
16:33:01 <dolio> > uncurry encodeFloat . decodeFloat $ 0/0
16:33:02 <lambdabot>  -Infinity
16:44:23 <prb__> dcoutts: You still around?
16:44:51 <prb__> dcoutts: The original paste from my ghc-pkg has the versions; I'll grab it.
16:45:25 <dcoutts> prb__: it does, but it's not clear if which one is coming from the global or user package db
16:45:41 <dcoutts> and I think that's important in this problem
16:46:40 <prb__> dcoutts: You want paste http://hpaste.org/8540
16:47:19 <prb__> dcoutts: I see.  I don't know whether the binary in the global was built with the bytestring from the user or from the global.
16:47:21 <dcoutts> prb__: but I need to know which one is built against which versions of bytestring
16:47:29 <dcoutts> prb__: exactly
16:47:31 <prb__> Any way to tell from the lib?
16:47:42 <dcoutts> ghc-pkg describe binary will tell you
16:48:11 <dcoutts> because you can match up the one that has paths to files in your home dir vs to /usr/whatever
16:48:42 <prb__> I have the same behavior on another machine; I'll check it tonight and email you.
16:48:58 <prb__> dcoutts: I'm happy to have found a corner case for you. :)
16:49:39 <dcoutts> :-)
16:55:25 <BMeph> dcoutts: Could you remind me, what do you need, and need to do, to register a package?
16:56:25 <dcoutts> BMeph: you mean to upload a package to hackage?
16:57:19 <BMeph> dcoutts: No, to get cabal to play nice with a 6.9 build.
16:57:51 <rwbarton> I did this: ghc-pkg describe unix-2.2 | ghc-pkg register --user -
16:59:53 <BMeph> rwbarton: Wicked, that worked like a charm! :)
16:59:58 <BMeph> rwbarton++
17:03:20 <BMeph> Oh well, time to crawl back in my hole (i.e., go to my 'Net-less home.
17:03:21 <BMeph> TTFN
17:03:58 <monochrom> I remember Net-less home. Or practically Net-less. The days of 24kbps modem.
17:30:43 <orzo> hello
17:30:58 <orzo> i'm trying to use ghci and i have a .so file with c modules linked in
17:31:16 <orzo> when i use ghci, it is complaining about missing symbols even though i know the symbols are in the so file i provided at the command line
17:36:31 <dmwit> Mmmm, yummy FFI.
17:37:18 <orzo> how do i use ghci with foriegn code?
17:37:34 <orzo> i can compile, but i would like to be able to use the interpreter
17:37:52 <orzo> i thought i could provide the objets in a shared lib
17:38:01 <orzo> but its not working
17:41:46 <Draconx> orzo, dunno about shared objects, but it works fine here when I pass ghci a relocatable object on the command line.
17:43:55 <marcot> Good evening.
17:46:04 <LordBrain> ok
17:46:23 <LordBrain> who wants to help me solve the mystery of why i can't build haddock
17:47:06 <LordBrain> i try "runhaskell Setup.lhs build" and i get no output
17:48:36 <rwbarton> can you runhaskell anything?
17:49:05 <LordBrain> well i tried with runghci or runghc also
17:49:16 <LordBrain> but ok.. i'll check that
17:49:36 <dmwit> Have you runhaskell Setup.lhs configure yet?
17:49:55 <jdrake> Can one make a list comprehension that references the list so far already created? (in a conditional section)
17:50:06 <dmwit> jdrake: name it
17:50:27 <dmwit> jdrake: But you have to be careful to only use the part of the list that's already constructed.
17:50:43 <jdrake> I am specifically interested in the ones that have been created before
17:50:57 <dmwit> Yes, but you need to do that management yourself.
17:51:05 <LordBrain> dmwit, yes
17:51:10 <LordBrain> it also gave no output
17:51:38 <dmwit> Does Setup.lhs have anything in it? =P
17:51:49 <jdrake> I will have to try something, then enquire further.
17:53:06 <dmwit> > let primes = 2:[p | p <- [3..], all ((/= 0) . (p `mod`)) $ takeWhile (\n -> n * n < p) primes] in primes
17:53:07 <lambdabot>  [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,...
17:53:35 <dmwit> jdrake: There's an (albeit buggy) example.
17:53:46 <dmwit> > let primes = 2:3:[p | p <- [3..], all ((/= 0) . (p `mod`)) $ takeWhile (\n -> n * n <= p) primes] in primes
17:53:47 <lambdabot>  [2,3,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,10...
17:54:11 <jdrake> dmwit, you quite did what I was going to do
17:54:17 <jdrake> Not quite so complete mind you
17:54:22 <jdrake> But I can work with it :-)
17:54:30 <dmwit> jdrake: But usually you can do better than that.
17:55:04 <dmwit> > nubBy (\m -> (== 0) . (`mod` m)) [2..]
17:55:05 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:55:09 <orzo> i need to pass -framework to ghci
17:55:11 <LordBrain> hmmmm
17:55:12 <orzo> in mac osx
17:55:22 <orzo> is there a way to let linker options through?
17:55:24 <jdrake> I think I have to decode that a little bit, it is about as readable as lisp
17:55:45 <LordBrain> i have runghc and runhaskell, but whenever i use them, there is nothing visible on the standard out... even when i give it main =putStrLn "Hello World!"
17:56:01 <dmwit> LordBrain: whence -v runhaskell
17:57:18 <dmwit> whence -vs for the real answer, probably
17:57:24 <rwbarton> whence is a zshism
17:57:26 <LordBrain> runhaskell -v test.hs gives me something to look at
17:57:29 <rwbarton> I think
17:57:34 <dmwit> rwbarton: Oh, whoops, that might be right.
17:57:40 <LordBrain> but there is no error messages or anything in it
17:57:44 <LordBrain> are
17:58:35 <LordBrain> i have no program called whence if that is what you meant
17:58:51 <dmwit> Yeah, sorry, zsh-only.
17:59:08 <LordBrain> bash here
17:59:15 <dmwit> And it looks like bash's which doesn't support -s...
17:59:16 * dmwit sighs
18:00:44 <rwbarton> LordBrain: what happens if you run runhaskell with no arguments?
18:01:14 <LordBrain> runhaskell: syntax: runghc [-f GHC-PATH | --] [GHC-ARGS] [--] FILE ARG...
18:01:22 <rwbarton> Hmm, so that's right.
18:01:45 <LordBrain> the machine is remote, so i can't tell if it's working
18:01:53 <LordBrain> no hard drive noise
18:02:00 <LordBrain> or anything
18:02:26 * dmwit suggests compiling Setup.lhs
18:02:33 <dmwit> I mean, why not?
18:02:41 <dmwit> It's a bit of a dead-chicken, but hey...
18:02:42 <LordBrain> you mean so i can install haddock?
18:02:50 <dmwit> sure
18:02:53 <LordBrain> yeah....
18:03:02 <monochrom> I always ghc --make Setup.lhs
18:03:10 <LordBrain> i would like to understand this tho
18:03:17 <LordBrain> ok..
18:03:48 <monochrom> I run Setup.lhs at least four times. It pays.
18:08:29 <LordBrain> compiling Setup.lhs seems to work
18:08:40 <dmwit> weird
18:08:54 <dmwit> I wonder what's up with runghc?
18:09:15 <monochrom> there is a scenerio of version mismatch between "ghc" and "runghc".
18:09:25 <LordBrain> hmmm
18:13:03 <LordBrain> well i have ghc 6.8.2   i'm not sure how to check on the runghc version, i listed the libraries it links against using mac os x's otool program, but that didn't seem so informative...
18:15:15 <LordBrain> otool says the compatibility version for two of the libraries is lower than the current version on the system, but i'm not sure thats a problem if we assume backward compatability in the libraries... libgmp 8.0.0 vs 8.2.0  and libSystem.B (1.0.0 vs 111.0.0)
18:15:22 <orzo> i'm getting undefined symbol ___dso_handle
18:15:36 <petekaz> with cabal-install, is it possible to install a specific version of a library?  I can't seem to install the 'gd' library and wanted to know if I have the same issue with all versions of it.
18:17:22 <petekaz> I'm dying to try dons latest blog post out, but am stuck installing 'gd'.
18:18:17 <Axman6> petekaz: link?
18:18:45 <petekaz> http://www.cse.unsw.edu.au/~dons/blog/2008/06/24#daily-haskell-one
18:18:48 <lambdabot> Title: Haskell hacking, http://tinyurl.com/6dhftc
18:19:17 <petekaz> Axman6: it's the post on sparklines.
18:19:25 <Axman6> yep
18:26:52 <roconnor> is there a top-notch automatic-differntiation library on hackage?
18:28:18 <tieTYT> if I use haskell, are quicksort and mergesort still relevant algorithms?
18:28:30 <dolio> Sorting what?
18:28:45 <tieTYT> i donno
18:28:50 <tieTYT> you decide
18:28:54 <dmwit> yes
18:28:56 <tieTYT> there's nothing to sort in haskell?
18:29:04 <tieTYT> ok that being said
18:29:05 <roconnor> mergesort is for lists
18:29:09 <dolio> Mergesort is good for lists.
18:29:24 <dolio> If you're sorting mutable arrays of some kind, it's the same as any other language.
18:29:27 <roconnor> quicksort or heapsort for arrays
18:29:27 <tieTYT> i asked an interview question: if you had a list that's so huge it can't fit in ram, would you use quicksort or mergesort?
18:29:42 <tieTYT> i felt the answer was merge sort, as that's what gnu sort uses
18:30:00 <tieTYT> but i'm not so sure why quicksort is bad for this
18:34:47 <ziman> tieTYT, because mergesort uses only sequential read/writes while quicksort needs random access
18:34:59 <tieTYT> why does it need random access?
18:35:28 <atp> it's based on partitioning the array around a pivot point
18:35:32 <luite> if you don't sort in-place (well, quicksort is not really in-place anyway) you only 'need' it to find the pivot
18:35:42 <tieTYT> yeah but you could do it in a way that is not in place
18:36:03 <hpaste>  LordBrain pasted "haddock fails on simple program... why?" at http://hpaste.org/8545
18:36:09 <atp> that increases, not decreases, the space complexity of the algorithm iirc
18:36:38 <tieTYT> atp: i don't know what "that" is
18:36:45 <atp> doing it not in place
18:37:00 <tieTYT> well of course
18:37:31 <tieTYT> well anyway, here's how I think you could do it: always use an early element as the pivot point then sequentally read the list.  Put < in one file and > in another
18:37:44 <LordBrain> why can't haddock figure out where my libs are the same way ghc does?
18:38:55 <hpaste>  (anonymous) annotated "haddock fails on simple program... why?" with "(no title)" at http://hpaste.org/8545#a1
18:39:16 <LordBrain> i just edited it
18:39:34 <LordBrain> anyone here experienced with haddock?
18:39:34 <dolio> So, use O(n log n) files?
18:39:35 <solrize> tieTYT for your interview question i think they wanted you to say either: 1) chop the file into memory-sized runs, sort each run in ram and then merge the runs; or, 2) sort the array in virtual memory with quicksort, which has much more locality than merge sort so you won't take as many page faults.
18:40:02 <tieTYT> so, one could justify it either way
18:40:12 <tieTYT> but the candidate didn't justify it
18:41:09 <dolio> Actually n log n might not be the right figure there.
18:44:06 <gwern> LordBrain: no ghc libdir? I'd say you have a bad haddock/ghc install
18:44:09 <ziman> hm, indeed, i can't see why the not-in-place quicksort would perform worse (except the worst-case thing) as an external sort
18:44:11 <dolio> sum(1, D, 2^n), where D is the depth of the recursion, more of less.
18:44:17 <gwern> LordBrain: out of curisoity, what does 'ghc --print-libdir' say?
18:44:22 <jcd1> solrize: when you say quicksort will do better than mergesort in 2), you mean better than mergesort with virtual memory, right?  1) is better than both of those
18:44:42 <solrize> jcdl yes
18:45:08 <LordBrain> gwern, /opt/local/lib/ghc-6.8.2
18:45:27 <LordBrain> i installed haddock myself but i may have done it wrong
18:46:00 <jcd1> ziman: when you do external mergesort, you can do a more-than-2-way merge
18:46:01 <gwern> entirely possible. I've seen a fair bit of chatter lately about haddock install problems
18:46:20 <gwern> happens every release of ghc. apparently haddock is tricky in special ways
18:47:01 <dolio> Haddock 2+ uses the ghc api for parsing all the ghc extensions.
18:47:13 <ziman> true ;)
18:47:13 <dolio> So any changes to it potentially break haddock, I suppose.
18:48:12 <LordBrain> i have 2.1.0
18:48:45 <LordBrain> ghc 6.8.2
18:50:30 <adu> hi
18:50:34 <LordBrain> i can't build the examples that came with haddock either, seems it expects a different directory structure or something
18:50:45 <LordBrain> the makefile is broken
18:52:06 <gwern> @hoogle Integer -> Float
18:52:06 <lambdabot> No matches, try a more general search
18:57:51 <gwern> > let rick = forever (loving you) >> (\y -> [giveUp y, letDown y, runAround y, desert y] you
18:57:51 <lambdabot> Unbalanced parentheses
18:58:03 <gwern> > let rick = forever (loving you) >> (\y -> [giveUp y, letDown y, runAround y, desert y]) you
18:58:03 <lambdabot>  Parse error at end of input
18:58:50 <atp> what's the syntax for an operator imported as qualified?
18:59:11 <atp> A.(++)?
18:59:13 <atp> A.++ ?
19:00:23 <rwbarton> A.++ or (A.++) for the prefix version
19:00:45 <vixey> > [] P.++ []
19:00:47 <lambdabot>  []
19:01:15 <adu> hi vixey
19:01:32 <vixey> hk
19:01:34 <atp> thanks rwbarton, vixey
19:01:38 <vixey> hi
19:02:32 <adu> I've been thinking about libraries other than the "Cocoa" libraries, and how they might be integrated in the heirarchical libraries
19:02:48 <adu> for example, instead of "Quartz", using "Graphics.Rendering.Mac.Quartz"
19:03:22 <adu> and instead of "AppKit", using "Graphics.UI.Mac.AppKit"
19:03:33 <adu> is this appropriate?
19:03:48 <vixey> I think it's unnatural
19:04:00 <vixey> there is only one namespace for classes in objc
19:04:21 <byorgey> adu: sounds good to me.
19:04:51 <adu> it follows the convention set by gtk2hs
19:05:00 <byorgey> I mean, whether vixey likes it or not, that seems to be the de factor Haskell standard for that sort of thing =)
19:05:06 <byorgey> *de facto
19:05:14 <adu> byorgey: ya, thats what I was thinking
19:05:28 * vixey guesses byorgey uses linux .. not mac ?
19:05:41 <geezusfreeek> i use os x and prefer real namespaces
19:05:47 <SamB> I think the namespace should be mechanically derived from the information available
19:05:49 <byorgey> vixey: how did you know? =)
19:05:53 <SamB> not made up by people
19:05:57 <byorgey> ok, bedtime for me
19:06:11 <SamB> i.e. ObjC.FrameworkName.ClassName
19:06:16 <adu> SamB: then how do you distinguish between Graphics.UI and Graphics.Rendering?
19:06:35 <adu> SamB: or it could all be under "System.Mac.*"
19:07:02 <SamB> adu: if these are just autogenerated interfaces, I think they should just mirror the things they are interfaces for...
19:08:50 <adu> SamB: they are autogenerated, but I'm currently refactoring the autogen tool so that you can set a "Graphics" prefix or a "System" prefix if you wanted it
19:11:23 <adu> SamB: plus, I'd like to have meta-packages for Quartz for example, since the "natural" mac interfaces for Quartz are actually scattered across several frameworks, including Quartz, QuartzCore, ApplicationServices, CoreGraphics, and ImageIO frameworks
19:11:29 <vixey> adu: did you get c2hs working? or find some other way to get bindings to the structs in /usr/include/objc ?
19:11:38 <adu> vixey: I never touched c2hs
19:12:11 <adu> HOC already has a nice objc=>hs tool, which works very well, my problems now are with cabal
19:14:14 <vixey> oh right
19:14:24 <vixey> HOCs written in C and and haskell
19:15:33 <adu> SamB: you are right, but I think the autogeneration should be used on a per-framework level. For example all of Foundation.framework should go under "System.Mac.Foundation" and all of AppKit.framework should go under "Graphics.UI.Mac.AppKit", in which case it will mirror what it is an interface for exactly
19:16:05 <adu> SamB: this reduces the problem to deciding which framework will go under which namespace
19:17:23 <adu> this has motivated me to rename the objc=>hs tool (currently called "ifgen") to "fw2hs" to reflect this per-framework aspect
19:17:50 <atp> @hoogle (a, b) -> (b, a)
19:17:51 <lambdabot> No matches, try a more general search
19:18:04 <atp> what?
19:18:19 <adu> @hoogle (a, b) -> (c, d)
19:18:19 <lambdabot> No matches, try a more general search
19:18:35 <atp> there's only one total function with that type i think
19:18:41 <atp> @djinn (a, b) -> (b, a)
19:18:42 <lambdabot> f (a, b) = (b, a)
19:19:11 <adu> atp: what would it be called?
19:19:20 <atp> i don't know, swap
19:19:39 <atp> it just seems like such a common function that it ought to be in the standard library
19:20:43 <rwbarton> :t snd (&&&) fst
19:20:45 <lambdabot>     Couldn't match expected type `(a, b)'
19:20:45 <lambdabot>            against inferred type `a1 b1 c -> a1 b1 c' -> a1 b1 (c, c')'
19:20:45 <lambdabot>     In the first argument of `snd', namely `(&&&)'
19:20:56 <rwbarton> :t snd &&& fst
19:20:58 <lambdabot> forall a b. (a, b) -> (b, a)
19:21:06 <atp> yeah
19:21:09 <atp> sigh
19:21:19 <atp> (&&&) does lazy pattern matching though iirc
19:21:26 <atp> @src (&&&)
19:21:26 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
19:21:37 <atp> @src (>>>)
19:21:37 <lambdabot> Source not found. There are some things that I just don't know.
19:21:43 <rwbarton> @src (->) (>>>)
19:21:44 <lambdabot> f >>> g = g . f
19:21:48 <atp> hm
19:21:48 <rwbarton> @src (->) (***)
19:21:48 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
19:21:52 <rwbarton> yep
19:21:58 <atp> ah, right.
19:24:40 <deli2323> does anyone use vim for haskell?
19:24:46 <Cale> I do.
19:25:50 <ddarius> Many people do.
19:26:27 <Cale> I'm mostly happy with any editor which will syntax colour, and which can convert tabs into spaces.
19:28:21 <dons> deli2323: yeah, lots of people.
19:30:15 <adu> deli2323: I use Yi :)
19:30:34 <dons> adu, really/
19:30:36 <dons> ?
19:31:20 <deli2323> dons, how is yi coming?  Is it packaged for debian? I would gladly use yi.
19:31:23 <adu> dons: ya, about the only keys that work are C-f and C-s, thats enough to open and save... lol
19:33:29 <dons> deli2323: i don't develop yi, but last i saw it was working rather well as an emacs clone
19:33:37 <SamB> adu: hmm, what you describe does seem reasonable to me
19:34:43 <geezusfreeek> i love the idea of using haskell to program my text editor (as opposed to emacs lisp) but i just can't be convinced to learn the API to do it yet
19:34:58 <adu> SamB: :)
19:35:14 <SamB> geezusfreeek: I'm not so sure I want to do that
19:35:45 <adu> geezusfreeek: maybe by the next time you try Yi, perhaps C-h (help) will be implemented...
19:35:46 <SamB> I mean, emacs lisp may suck, but I think Haskell is a bit TOO static for the job
19:36:19 <atp> emacs lisp is sort of lisp without any of the benefits :/
19:36:41 <SamB> what were the benefits of Lisp supposed to be again?
19:36:43 <geezusfreeek> i dunno, feed emacs crap, emacs craps. feed Yi crap, it says no
19:36:44 <marcot> So something like type X = Eq a => a is not allowed.
19:36:49 <marcot> How can I do something like this?
19:36:53 <geezusfreeek> i assume, anyway?
19:37:01 <SamB> I can never remember anymore now that I've learned Haskell
19:37:10 <marcot> I just want a type synonym to avoid writing WidgetClass widget => (GObject -> widget) -> String -> IO widget all the time.
19:37:59 <adu> marcot: you would just have to add "Eq a => " to everything you might have to use X in
19:38:07 <geezusfreeek> marcot: type X a = (GObject -> a) -> String -> IO a ... and then use WidgetClass a => X a
19:38:20 <marcot> Hum, thanks.
19:38:35 <adu> marcot: you can combine type classes tho
19:38:35 <geezusfreeek> but you will still have to specify WidgetClass every time
19:38:43 <marcot> This is already better than writing everything.  Even being worse then what I first tried..
19:38:49 <mar77a> @src last
19:38:49 <lambdabot> last [x]    = x
19:38:49 <lambdabot> last (_:xs) = last xs
19:38:49 <lambdabot> last []     = undefined
19:39:19 <mar77a> @src head
19:39:19 <lambdabot> head (x:_) = x
19:39:19 <lambdabot> head []    = undefined
19:39:30 <deli2323> anyone interested in prime numbers?
19:39:34 <adu> marcot: or you can make a shortcut, like "class WidgetClass c => WC c"
19:39:35 <deli2323> haskell and prime numbers..
19:39:45 <mar77a> > let last = head . reverse in last [1..10]
19:39:47 <lambdabot>  10
19:39:55 <marcot> adu: yes, this is a good tip too.
19:41:41 <ddarius> atp: emacs lisp is worse than lisp without any of the benefits
19:41:52 <atp> ddarius: how is that possible?
19:42:07 <ddarius> Modern lisps are lexically scoped.
19:42:14 <ddarius> (by default)
19:43:17 <atp> a benefit, wouldn't you say?
19:43:20 <atp> :p
19:43:27 <SamB> for variables without names of this *extra-special* form
19:43:31 <SamB> at least
19:45:08 <vixey> *...* is just a convention
19:45:35 <SamB> vixey: what in the world can you mean?
19:46:42 <vixey> you seemed to imply that any variable with *'s around its name is dynamic scoped
19:47:09 <solrize> does it become dynamically scoped if you define it with defvar?
19:47:28 <ddarius> solrize: Yes.
19:48:17 <solrize> ic, so the convention is to put *'s around defvar symbols
19:49:15 <dolio> The advantage of Lisp is that you get to act like a smug know-it-all, and talk about how every new language is just approximating what Lisp did 40 years ago.
19:49:45 <vixey> dolio: ... and it's got a good macro system
19:49:56 <solrize> lol
19:51:28 <zachk1> i like scheme, but haskell is way easier to read
19:54:01 <marcot> I think I'm getting some problem about the monomorphism restriction..
19:54:53 <marcot> windowBasic getWidget cast windowName destroyName =do {window  <- getWidget cast windowName; destroy <- getWidget castToButton destroyName; ...}
19:55:38 <marcot> getWidget is xmlGetWidget "somefile.glade"
19:58:33 <marcot> Ok, I think this example is too complicated, I'm trying to do something similar:
19:59:15 <dons> dolio: i've never met a lisper like that. some shy scheme programmers, but i'm not sure these arrogant lispers really exist now
19:59:36 <dolio> :)
19:59:46 <dolio> In comp.lang.lisp maybe.
19:59:55 <atp> hey, k is const, y is fix, what's s?
20:00:02 <atp> do we have an s?
20:00:07 <dolio> ap
20:00:14 <atp> i thought ap was for monads
20:00:28 <dolio> (->) r is a monad.
20:00:55 <ddarius> Indeed, hang out in c.l.l
20:00:55 <atp> hmm
20:01:06 <dolio> ap :: (r -> a -> b) -> (r -> a) -> r -> b
20:01:16 <Korollary> I get a lot of viagra ads in c.l.l
20:01:27 <atp> they need it
20:01:29 <ddarius> Anyway, whatever it is, there's something amiss with the CL community.
20:01:36 <atp> how so?
20:01:45 <Korollary> the good guys are quiet
20:01:47 <atp> i've always been more partial to scheme than cl
20:01:54 <SamB> @localtime mattam
20:01:55 <lambdabot> Local time for mattam is Thu Jun 26 05:00:17 2008
20:02:05 <SamB> hmm, probably sleeping then ;-)
20:02:19 <marcot> I think what I want to do is similar to:
20:02:32 <marcot> > let m f = f (f 'a' 'b') (f 'a' 'b') in m (==)
20:02:33 <lambdabot>  Couldn't match expected type `Char' against inferred type `Bool'
20:03:06 <marcot> I want to receive a generic function as a parameter and then use it to 2 different data types.
20:03:11 <dolio> You need rank-2 polymorphism for that.
20:03:12 <SamB> what did lisp do 40 years ago?
20:03:20 <SamB> and why the heck doesn't it still do that?
20:03:30 <marcot> dolio: is this a GHC extension?
20:03:41 <dolio> SamB: Everything good ever done in a programming language. :)
20:03:46 <dolio> Yes, it's an extension.
20:04:09 <SamB> rank-n polymorphism would also work in a pinch
20:04:20 <atp> SamB: to be fair to lisp, many of the features non-academic programmers are just starting to get in enterprise were in lisp 40 years ago
20:04:37 <atp> not all, however
20:04:44 <atp> despite claims to the contrary
20:04:44 <dolio> Well, any rank greater than 1 will do. But that particular function is only rank-2.
20:05:00 <TomMD> If LISPers were as accepting of extentions as Glasgow Haskell is then GHC would be called GLC.
20:05:26 <SamB> TomMD: how so?
20:05:26 <atp> these days calling it LISP will draw the ire of the lisp community
20:05:31 <Pseudonym> LISPers don't extend, they fork.
20:05:31 <atp> of course, most things will
20:05:43 <ddarius> atp: What?! The only features added that weren't in LISP 40 years ago have to do with static typing and that's -obviously- the Wrong Thing.
20:05:56 <Pseudonym> How else do you explain Scheme, ELisp, Arc etc?
20:05:57 <atp> ddarius: haha
20:05:57 <SamB> wasn't it only called LISP because lowercase hadn't yet been invented?
20:06:21 <atp> SamB: that and because it's a sort of acronym... LISt Processing or something
20:06:24 <Pseudonym> SamB: Yeah, "Lisp" was too hard to do in punched paper tape.
20:06:27 <TomMD> My impression of LISPers (old college room mate in mind here) are people who prefer a language to be more static and work to be in the libraries.  Though I did know a typical lispers.
20:06:28 <dolio> Static typing is just a special case of macros anyway. *waves hands*
20:06:40 <TomMD> Pseudonym: Yes, that is a good way to say it.
20:06:56 <SamB> dolio: what the what now?
20:06:58 <atp> wow, there's a lot of anti-lisp sentiment in Haskell :)
20:07:02 <atp> err #haskell
20:07:06 <jdrake> Hpaste doesn't display alpha properly for me... http://hpaste.org/8547
20:07:17 <Pseudonym> atp: I think you'll find that the people here aren't anti-Lisp in general.
20:07:18 <SamB> atp: we aren't so much anti-lisp as "eh, what's so great about lisp?"
20:07:20 <ddarius> atp: Not at all.
20:07:21 <Pseudonym> And especially not anti-Scheme.
20:07:34 <Pseudonym> But Lisp culture is disturbing.
20:07:41 <atp> i find the lisp community to be somewhat boring, but the language itself is pretty much as good as it gets on the dynamic side, i think
20:07:45 <SamB> yeah, and that
20:07:45 <Pseudonym> ?quote VerityStob
20:07:45 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
20:07:52 <TomMD> atp: No no, I'm not anti-lisp, just observing that the few I've known preferred the language to not change much.  Compare this with the Haskell users who are already using type families.
20:08:04 <atp> or at least, has the never-ending but somehow never realized potential to be...
20:08:22 <SamB> does that mean that Haskell isn't a blub language?
20:08:33 <atp> well, paul graham is and has always been a tool
20:08:34 <adu> does "./Setup.hs" require #!runhaskell at the top?
20:08:38 <Korollary> It is possible that various type extensions to haskell lead nowhere either
20:08:48 <SamB> Korollary: yeah
20:08:53 <TomMD> adu: Can Setup.hs work when its not literate?
20:08:56 <Pseudonym> I also think it's remarkable that such a good language as Lisp is implementable on a 1960s computer.
20:08:59 <dolio> SamB: If you're going for the proverbial smug lisp guy, macros are the go-to for any feature that Lisp doesn't clearly have.
20:09:07 <SamB> but we're going to keep trying anyway
20:09:10 <Korollary> Pseudonym: also valid for Prolog
20:09:17 <atp> although macros do win over template haskell
20:09:18 <Pseudonym> Korollary: Indeed.
20:09:26 <Pseudonym> However, Prolog culture is even scarier in some respects.
20:09:29 <SamB> macros don't provide static typing
20:09:35 <atp> the main problem with macros is that they require homoiconic syntax
20:09:49 <SamB> homoiconic?
20:10:12 <ddarius> atp: No they don't.
20:10:18 <TomMD> @quote work
20:10:18 <lambdabot> LoganCapaldo says: Start with a Haskell compiler // I'm a big believer in working your way down
20:10:20 <Pseudonym> OK, maybe not scarier.  Logic programmers are many things, but they have an inferiority complex, not a superiority complex.
20:10:33 <SamB> you mean like ⚢ or ⚣ ?
20:10:40 <marcot> So I should use {-# OPTIONS_GHC -XRank2Types #-} or is there a better way to require language extensions?
20:10:42 <Pseudonym> If you just UNDERSTOOD, you'd use Prolog too.
20:10:50 <Pseudonym> Or something.
20:11:05 <TomMD> marcot: Use {-# LANGUAGE Rand2Types #-}
20:11:09 <dolio> SamB: Just write a macro (typecheck <your code goes here>) that type checks your code. :)
20:11:18 <marcot> Thanks.
20:11:22 <adu> TomMD: or "./Setup.lhs" or whatever
20:11:26 <SamB> dolio: oh, sure, like THAT's going to work...
20:11:36 <SamB> it'd be just about as easy to do it with a function ;-P
20:11:50 <TomMD> adu: Yeah, I just didn't realize you could use non-literate haskell in script style, ./Setup.hs etc.
20:12:05 <ddarius> dolio: Just write #C[ <C code here> ] and CL will be able to do anything C does
20:12:38 <Pseudonym> I thought the Lisp answer to type checking was: Well, you've got to write tests anyway, so type declarations are clearly superfluous.
20:12:50 <hpaste>  (anonymous) pasted "imgs in dir -> html" at http://hpaste.org/8548
20:12:50 <dolio> Is that the syntax for a reader macro (I've not done much Lisp)?
20:12:54 <marcot> Do you think it's a problem to use haskell extesions?
20:13:06 <marcot> Specially from a portability point of view..
20:13:15 <Pseudonym> marcot: It depends what you mean by "problem", and it depends which extensions.
20:13:17 <TomMD> marcot: Most anything practical uses atleast a couple extentions.
20:13:17 <ddarius> Pseudonym: Also, "Types -restrict- me." and "I don't want to have to write type annotations."
20:13:32 <Pseudonym> Generally speaking, if it works in the latest GHC and the latest Hugs, it's portable.
20:13:44 <marcot> hum...
20:13:48 <Pseudonym> But if in doubt, check out haskell-prime.
20:13:51 <marcot> Or maybe only in the latest GHC.
20:13:59 <Pseudonym> If it's going into haskell-prime, then it's portable.
20:14:12 <Korollary> ddarius: and they're not dynaymic. They "walk away" from the battlefield at runtime.
20:14:13 <SamB> marcot: that's NOT portable
20:14:20 <adu> ddarius: theres always Dynamic
20:14:39 <SamB> after all, *base* works with the latest GHC
20:14:43 <SamB> and it certainly isn't portable
20:14:44 <TomMD> For some definition of portable.  I've not found a stable and supported Haskell compiler for ARM or one that takes advantage of Cell SPEs.
20:14:55 <marcot> SamB: does base works with Hugs?
20:15:10 <SamB> TomMD: the latter is rather tricky
20:15:17 <TomMD> Not arguing.
20:15:25 <SamB> marcot: only thanks to an assload of #ifdefs
20:15:43 <marcot> hum..
20:15:55 <marcot> Pseudonym: how do I know if it's going to be in Haskell Prime?
20:15:56 <TomMD> It would be interesting to know the ifdef per kloc in GHC.
20:16:08 <TomMD> @where haskell'
20:16:08 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
20:16:24 <Pseudonym> Yes, that.
20:16:35 <Pseudonym> And I'm aware that this isn't exactly a good answer.
20:17:10 <marcot> So it seems that Rank2Types is in Haskell'
20:17:31 <Pseudonym> Yes.
20:17:31 <dolio> Huh, really? I wouldn't have guessed that.
20:17:59 <ddarius> dolio: Why not?
20:18:15 <ddarius> dolio: runST, for example, requires them and they are very useful and widely implemented.
20:18:47 <dolio> I had the impression they weren't widely implemented, I guess.
20:18:58 <dolio> I need to get out more, I guess.
20:19:30 <ddarius> GHC, hbc, and Hugs support them.  I think JHC does as well.  I don't know about nhc/yhc.
20:20:41 <SamB> I can't imagine JHC not supporting rank two types...
20:20:42 <marcot> I'm trying to search about it in the Haskell' report, but I can't find it explicity.
20:21:07 <dolio> Seems likely.
20:21:16 <SamB> marcot: look up "forall" in the index
20:21:37 <SamB> I think JHC has foldr/build fusion, for one...
20:21:38 <ddarius> SamB: Me neither.
20:23:24 <hpaste>  wackyvorlon pasted "(no title)" at http://hpaste.org/8549
20:23:41 <dmwit> Waugh!
20:23:45 <dmwit> C!
20:23:51 <dmwit> ...++
20:24:00 <marcot> SamB: http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/prelude-index.html
20:24:01 <marcot> here?
20:24:01 <lambdabot> Title: Haskell 98 Prelude Index, http://tinyurl.com/5uf3sb
20:24:01 <jdrake> My apologies, my friend did that. I will chastize him
20:24:28 <marcot> Here it says: Adopt: probably yes.
20:24:29 <marcot> http://hackage.haskell.org/trac/haskell-prime/ticket/60
20:24:30 <lambdabot> Title: #60 (add RankNTypes or Rank2Types) - Haskell Prime - Trac
20:24:30 <solrize> hah, a c++ fizzbuzz sorta
20:24:45 <dmwit> > sum [i | i <- [1..1000], i % 3 > 0 && i % 5 > 0]
20:24:46 <lambdabot>  500500
20:25:09 <dmwit> um
20:25:19 <dmwit> > 1000 * 1001 `div` 2
20:25:20 <lambdabot>  500500
20:25:31 <dolio> You want == 0, no?
20:25:37 <rwbarton> You want `mod`
20:25:44 <dolio> Yeah, that too.
20:25:46 <dmwit> Oy, thanks rwbarton.
20:25:49 <SamB> marcot: huh, it seems to not have a full index...
20:26:07 <solrize> > [1..5]
20:26:08 <lambdabot>  [1,2,3,4,5]
20:26:14 <dmwit> > sum [i | i <- [1..1000], i `mod` 3 > 0 && i `mod` 5 > 0]
20:26:15 <lambdabot>  266332
20:26:47 <dmwit> > 1000 `div` 15
20:26:49 <lambdabot>  66
20:26:49 <jdrake> dmwit: there you go
20:27:05 <dmwit> > 1000 * 1001 `div` 2 - 15 * 66 * 67 `div` 2
20:27:06 <lambdabot>  467335
20:27:10 <jdrake> > 999 * 1000 `div` 2
20:27:12 <lambdabot>  499500
20:27:21 <jdrake> > 999 * (1000 `div` 2)
20:27:22 <lambdabot>  499500
20:27:33 <solrize> > 500500 - (sum [i | i <- [1..1000], i `mod` 3 == 0 && i `mod` 5== 0])
20:27:35 <lambdabot>  467335
20:27:37 <jdrake> That was stupid of me, ignore that I even did that
20:27:53 <dmwit> oh
20:27:57 <dmwit> I get it. =)
20:28:02 <solrize> > 500500 - (sum [i | i <- [1..1000], i `mod` 3 == 0 || i `mod` 5== 0])
20:28:03 <lambdabot>  266332
20:28:07 <dmwit> yep
20:30:45 <jdrake> > 999 * (1001 `div` 3)
20:30:46 <lambdabot>  332667
20:32:46 <dmwit> > let arithSum s e = let e' = e `div` s in s * e' * (e' + 1) `div` 2 in arithSum 1 1000
20:32:47 <lambdabot>  500500
20:33:02 <dmwit> > let arithSum s e = let e' = e `div` s in s * e' * (e' + 1) `div` 2 in arithSum 1 1000 - arithSum 3 1000 - arithSum 5 1000 + arithSum 15 1000
20:33:03 <lambdabot>  266332
20:33:08 <dmwit> yay!
20:34:23 <dmwit> > let arithSum s e = let e' = e `div` s in s * e' * (e' + 1) `div` 2 in (\[a,b,c,d] -> a + b - c - d) $ sequence (map arithSum [1,15,3,5]) 1000
20:34:25 <lambdabot>  266332
20:37:36 <SamB> atp: hmm, how come nobody ever elaborated on homoiconic syntax?
20:37:42 <SamB> or groaned at my stupid pun
20:38:03 <SamB> (which was "you mean like ⚢ or ⚣ ?")
20:38:20 * dmwit groans
20:40:06 <atp> SamB: oh, sorry.  it basically means that the language's syntax doesn't have any "special" features
20:40:26 <atp> that it's completely regular, doesn't have any exceptions that aren't just sugar
20:40:32 <atp> ie, s-expressios
20:40:34 <atp> s-expressions
20:40:43 <atp> at least, that's what i interpret it to mean
20:40:55 <atp> i've never actually looked it up, i've just heard lispers throw the term around
20:40:59 <atp> ddarius, am i correct?
20:41:06 <vixey> Prolog Lisp and TCL are 3 examples
20:41:21 <atp> yeah, there are s-expressions, m-expressions... and another?
20:41:43 <vixey> it's more than syntax
20:42:07 <atp> it allows data & code to live in the same space
20:42:34 <dolio> Wikipedia says that homoiconicity is defined as the primary representation of a program being a data structure built into the language.
20:42:50 <atp> that's a nice way to say it
20:42:52 <SamB> that sounds about right
20:42:54 * atp jots that down.
20:42:58 <vixey> wikipedia doesn't have a good definition at all
20:43:05 <SamB> vixey: oh?
20:43:09 * atp waits for vixey to elaborate
20:43:19 <SamB> what do you understand it to mean?
20:43:57 <SamB> whatever it is, Coq obviously hasn't got it ;-P
20:44:13 <vixey> Coq has quote
20:44:22 <ddarius> SamB: Don't worry.  It is completely irrelevant.
20:44:41 <SamB> vixey: and that probably only works on gallina, am I right or am I right?
20:44:52 <vixey> actually Coq is very lispy to me
20:44:55 <SamB> gallina is only a very small part of Coq
20:44:57 <atp> ddarius: how can you have macros a la lisp without homoiconicity?
20:45:14 <vixey> #define
20:45:18 <SamB> incidentally, how does one use quote?
20:45:23 <ddarius> atp: The way many other languages do, e.g. camlp4.
20:45:24 <SamB> vixey: those are NOT ala lisp
20:45:27 <vixey> quote <ident>.
20:45:35 <atp> ddarius: don't speak it... could you give an example?
20:45:38 <SamB> vixey: what language is that ?
20:45:56 <SamB> Probably tactic?
20:47:01 <ddarius> atp: You just have to write a parser.  The -only- thing homoiconicity gives you is that you are saved having to write a parser (assuming the syntax of the language is acceptable to you), and even that is moot is lisps as read is a standard function.
20:47:53 <SamB> ddarius: read can usefully be a standard function only because of homoiconicity...
20:48:21 <ddarius> SamB: read is just an S-expression parser, you could have it be a standard Haskell function.  There is nothing special about it.
20:48:35 <atp> hm, but requiring that a parser be written sort of makes writing macros ungainly, wouldn't it?  i understand perl6 does this too by exposing the parse tree to the programmer
20:48:44 <atp> it might be possible but it wouldn't be convenient
20:48:46 <SamB> ddarius: well, I mean, Language.Haskell doesn't work very well for parsing random Haskell code
20:49:02 <SamB> since it tends not to support the extensions used by that code
20:49:03 <ddarius> SamB: Mainly because random Haskell code isn't Haskell 98.
20:49:15 <SamB> read works on ANY lisp code
20:49:31 <SamB> (as long as the needed reader macros are in place)
20:50:11 <SamB> granted, it will only read it for YOUR implementation...
20:50:20 <SamB> but that's generally what you want ;-)
20:50:24 <ddarius> atp: I can easily (and have repeatedly) write an S-expression parser and you can use that for your macros and you'll have all the benefits of Lisp-style macros.
20:50:44 <SamB> ddarius: what does it DO?
20:51:54 <ddarius> SamB: I'm not saying having regular syntax isn't beneficial, but there is nowhere near the benefit of having language and data structure syntax match that some Lispers (and non-Lispers) attribute to it.
20:53:40 <atp> well, i think it's clear that the "macros solve world hunger" attitude that lisp-weenies have is way off the mark
20:53:48 <atp> but having said that, they are exceptionally useful
20:54:22 <vixey> where are all these 'lisp-weenies' I keep hearing about
20:54:25 <vixey> I never heard one..
20:54:34 <vixey> (brucio blog is a joke by the way..)
20:54:53 <atp> and while your point that homoiconicity is not actually a prerequisite for lisp-style macros is well taken, it still seems to me that it is required to make the use of macros truly convenient
20:55:16 <atp> but i'm open to seeing example code proving the contrary if you have any lying about
20:56:08 <atp> vixey: lisp-weenies is just a generic term for annoyingly smug lisp enthusiasts.  see also haskell weenies :)
20:56:41 <vixey> I know what the term menas
20:56:48 <SamB> how many haskell weenies are there?
20:57:00 <atp> i probably qualify
20:57:02 <atp> :)
20:57:03 <SamB> do we have a list?
20:57:09 <vixey> it's used a lot here and there's a lot of people bashing lispers but I never heard of anyone who actually talks like that
20:57:20 <lament> vixey: join #lisp
20:57:26 <lament> you soon will
20:57:33 <atp> yeah, actually vixey, i really like lisp, but they have that rep for a reason
20:57:44 <vixey> what reason?
20:57:54 <atp> as lament said, join #lisp, or hang out on c.l.l
20:58:02 <SamB> vixey: the community is dominated by them?
20:59:07 <SamB> atp: so are you actually smug
20:59:11 <ddarius> atp: Macros are useful for macro expressible things (see "On the expressive power of programming languages").  For things that aren't macro-expressible, while there are some benefits of a Lisp-style macro system, they aren't all that great.
20:59:24 <atp> SamB: i try not to let it show
20:59:29 <atp> :p
20:59:51 <atp> what annoys me most about lispers really is their hostility to newbies
20:59:52 <SamB> atp: how can you be annoyingly smug if you don't let it show?
21:00:08 <atp> i want to be a smug haskell weenie, ok?
21:00:08 <SamB> atp: that should be included in the definition of "lisp weenie"
21:00:10 <atp> god!
21:00:18 <atp> :p
21:00:33 <SamB> and no, you aren't allowed to stay here if you become one of them
21:00:46 <SamB> we kickban them!
21:00:56 <atp> has that actually happened?
21:00:56 <SamB> notably... Smerdyakov...
21:01:00 <atp> ah
21:01:20 <SamB> though apparantly he has some kind of psychological issues?
21:01:34 <ddarius> SamB: Many people here have some kind of psychological issue...
21:01:57 <SamB> ddarius: some particular kind that prevents him from understanding why we didn't like the way he was asking?
21:02:03 <SamB> er.
21:02:07 <SamB> *acting
21:02:09 <atp> hm
21:02:12 <atp> i don't like if
21:02:32 <atp> we're lazy, why is if built into the language?
21:02:41 <SamB> I haven't a clue
21:02:46 <SamB> does anyone actually use it?
21:02:49 <vixey> yeah just use .. mixfix ...
21:02:52 <vixey> which Haskell has
21:02:56 <atp> mixfix?
21:03:04 <ddarius> atp: Look at camlp4 examples, the syntax macros paper on Haskell, the quasiquoting support in GHC, bigwig, intentional programming, the FOG C++ compiler.
21:03:12 <vixey> atp: How could you define if _ then _ else _ if it wasn't built in?
21:03:35 <atp> p True x _ = x ; p False _ y = y ?
21:03:39 <SamB> vixey: itym Agda
21:03:42 <vixey> that's 'p'
21:03:47 <ddarius> SamB: I use it occasionally, but I would more often prefer an if function.
21:04:03 <atp> vixey: oh, you mean you like the syntax?
21:04:10 <atp> that's sort of what i'm complaining about
21:04:19 <atp> is there a function like p in the standard libs?
21:04:24 <vixey> I don't care about they syntax, I'm just trying to outline this is why it's built in
21:04:39 * SamB has often wondered why Haskell has if syntax and not an if function in Prelude
21:04:44 <atp> yeah
21:04:56 <atp> i just think it would be nicer if if were a function that can be composed like other functions
21:05:12 <SamB> I mean, we already had case syntax *and* guards *and* pattern matching on left-hand sides
21:05:28 <SamB> what did we need yet ANOTHER way to case over a Bool for?
21:05:29 <vixey> yeah there are many possible modifications to haskell which doesn't really make any important difference in the long run
21:05:43 <atp> there have been many times when a functional if would allow a really nice, concise point free definition of a function
21:06:00 <vixey> :t if'
21:06:02 <lambdabot> Not in scope: `if''
21:06:07 <atp> and i have been thwarted by there not being one
21:06:11 <vixey> pl knows about it anyway
21:06:12 <SamB> well, if you wanted to add an if function to the libraries, the accepted name is if'
21:06:20 <atp> if' exists?
21:06:22 <SamB> which is to say, @pl uses that
21:06:24 <atp> in what lib?
21:06:26 <vixey> it doesn't matter if it exists
21:06:27 <SamB> atp: in @pl's mind
21:06:31 <atp> it does!
21:06:34 <vixey> atp: you already showed how to define it
21:06:56 <SamB> ath: it doesn't really help much unless it's in the "standard library"
21:07:07 <atp> vixey: that's not the point.  if i have to define the function, i might as well just use a where clause
21:07:16 <vixey> no
21:07:17 <atp> it would be clearer anyway (but not as sexy)
21:07:52 <SamB> otherwise it would be far easier to just put it in an app/lib-specific util module than to depend on the library it was in
21:08:00 <SamB> unless that library was missingh or something...
21:10:21 <hpaste>  rwbarton pasted "weird view pattern warning" at http://hpaste.org/8550
21:10:31 <rwbarton> anyone here use view patterns?
21:10:50 <rwbarton> How can there be overlapping patterns when there's only one pattern?
21:11:03 <SamB> rwbarton: hmm?
21:11:12 <rwbarton> See http://hpaste.org/8550
21:15:55 <SamB> rwbarton: not a clue
21:15:59 <adu> 400!
21:16:37 <SamB> that part of GHC has long been known to be rather in need of an overhaul (the case coverage analysis)... though I'm not certain the overhaul isn't supposed to have happened...
21:33:44 <atp> ok, i've got it!
21:33:49 <atp> if' = (flip (.) (((flip (.) (:[])) . (:)))) . ((.) . (flip (!!) . fromEnum))
21:33:53 <atp> woohoo
21:33:55 <atp> now i can go to bed
21:35:14 <rwbarton> > (flip (.) (((flip (.) (:[])) . (:)))) . ((.) . (flip (!!) . fromEnum)) True 3 5
21:35:15 <lambdabot>        add an instance declaration for (Num (t -> [f ((a -> [a]) -> b)]))
21:35:29 <rwbarton> > ((flip (.) (((flip (.) (:[])) . (:)))) . ((.) . (flip (!!) . fromEnum))) True 3 5
21:35:30 <lambdabot>  5
21:35:35 <rwbarton> > ((flip (.) (((flip (.) (:[])) . (:)))) . ((.) . (flip (!!) . fromEnum))) False 3 5
21:35:36 <b7j0c> i think cabal-installs install of bytestring may be interfering with my local ghc version (???) : "GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_minimum whilst processing object file /home/brad/.cabal/lib/bytestring-0.9.1.0/ghc-6.8.2/HSbytestring-0.9.1.0.o"
21:35:36 <lambdabot>  3
21:35:39 <b7j0c> any ideas?
21:37:49 <atp> hm, did i reverse the args?
21:37:52 <atp> oh well
21:37:56 <atp> maybe i'll fix it later :)
21:38:13 <atp> it's just a point free version of \b x y -> [x, y] !! fromEnum b
21:38:21 <atp> but i guess it ought to be [y, x] !! fromEnum b
21:38:32 <atp> that actually probably simplifies it somewhat
21:39:37 <atp> night all
21:39:50 <Cale> @pl \b x y -> (x : y : []) !! fromEnum b
21:39:50 <lambdabot> flip (flip . ((!!) .) . (. return) . (:)) . fromEnum
21:40:12 <Cale> @pl \b x y -> (y : x : []) !! fromEnum b
21:40:12 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
21:41:43 <adu> I like the case analysis algorithms in Mathematica
21:42:03 <atp> return?
21:42:50 <atp> pl is a cool tool but i actually like deriving point-free expressions myself
21:42:50 <Cale> return in the list monad is just (\x -> [x])
21:43:00 <atp> oh, right.
21:43:10 <atp> i like (:[]) better.
21:43:15 <atp> (in this case)
21:43:30 <Pseudonym> robot ninja monkey operator
21:44:13 <povman> (\\) emo hair operator
21:44:18 <povman> is there a compendium of these?
21:44:54 <Eldanen> lol
21:47:29 <adu> what about the Flying Spaghetti Monster operator?
21:47:38 <povman> (&&) ?
21:48:00 <adu> (&/\/&) ?
21:48:32 <bd_> (~&~)?
21:48:42 <Pseudonym> You wouldn't laugh if you'd ever been Touched by His Noodly Appendage.
21:48:43 <Eldanen> ^loaded butthole operator.
21:51:25 <adu> lol
21:54:11 <adu> Mathematica's case analysis can also be weird sometimes...
21:54:26 <adu> f[2, _] = 2; f[_, 3] = 3; f[2, 3] gives 2 and
21:54:29 <adu> f[_, 3] = 3; f[2, _] = 2; f[2, 3] gives 3
21:56:34 <Cale> adu: That's similar to Haskell...
21:56:52 <Cale> > let f 2 _ = 2; f _ 3 = 3 in f 2 3
21:56:53 <lambdabot>  2
21:57:02 <Cale> > let f _ 3 = 3; f 2 _ = 2 in f 2 3
21:57:03 <lambdabot>  3
21:57:07 <adu> huh
21:57:30 <Cale> It tries the patterns in order.
21:57:39 <adu> at least they're consistent...
21:58:53 <b7j0c> to answer my own question: i needed to use cabal-install to update MissingH and rebuild its deps
21:59:42 <b7j0c> in case anyone is wondering what i am on about, my original problem was a ghci error of "I found a duplicate definition for symbol fps_minimum"
22:01:50 <b7j0c> WOW cutting hxt out of a program and replacing it with Text.XML.Light cut 5mb off my executable size....
22:02:01 <b7j0c> and to boot, Text.XML.Light is easier to use
22:06:04 <Heffalump> what package is that in?
22:06:41 <b7j0c> xml
22:07:00 <b7j0c> p.s. ghc apparently like to core whilst building my program...
22:07:07 <b7j0c> :(
22:07:14 <Heffalump> 6.8.3?
22:07:19 <b7j0c> 6.8.2
22:07:22 <b7j0c> freebsd7
22:07:29 <b7j0c> sometimes it cores, sometimes not
22:07:31 <Heffalump> try 6.8.3, if it still happens submit a bug report
22:07:46 <b7j0c> will do, thats exactly what it told me to do too!
22:08:06 * Heffalump thinks there's a GC bug lurking somewhere, I've run into the same thing but for complicated reasons I'm using an early 6.9 so can't be sure that there's a bug in anything up to date
22:08:29 <Heffalump> I've found that +RTS -G1 -RTS works round it when it does happen
22:08:34 <b7j0c> you may be on to something: "internal error: task 0x286040e0: main thread 1 has been GC'd"
22:09:29 <Heffalump> I usually get an evacuated object being entered.
22:10:30 <b7j0c> and by the way heffalump are "+RTS -G1 -RTS" ghc build flags?
22:11:10 <Heffalump> they're flags to the GHC runtime system, which can be used with any ghc-compiled executable, including ghc itself
22:12:20 <b7j0c> hmm, thanks. not sure how i would have found out about those otherwise!
22:13:17 <Heffalump> they are documented but of course you have to know to look
22:15:22 <b7j0c> well heffalump, thanks for your help and have a great night
23:52:55 <chylli> one thread will be terminated after finish his action ?
23:53:30 <chylli> or we must terminated by something,like exitWith Success ?
23:55:33 <quicksilver> chylli: threads terminate when they finish, yes.
23:56:56 <chylli> quicksilver: seems that I call exitWith in a thread, the whole program will be terminated
23:58:13 <rwbarton> exitWith probably means "terminate this process", not "terminate this thread"
23:58:43 <quicksilver> chylli: indeed.
23:58:53 <quicksilver> chylli: if you don't want that, don't do it :)
23:59:00 <chylli> thanks
23:59:07 <quicksilver> the simplest way to terminate a thread is just to let it finishs.
23:59:14 <chylli> i'm just not sure how to terminated one thread.
23:59:15 <chylli> ok
23:59:16 <chylli> thanks
