00:03:06 <solrize> opportunistic encryption, freeswan was supposed ot do that
00:03:11 <solrize> is this one written in haskell?
00:03:20 <nus> Nice scheme, though, as the FAQ mentions, MiM forgery is possible.
00:04:07 <pejo> What is the BSD3/BSD4 license tag in the license-field in Cabal? (Which is the new BSD-license?)
00:04:22 <Saizan_> pejo: BSD3
00:04:51 <pejo> Saizan, thank you.
00:05:02 <solrize> it's unauthenticated?  blecch
00:05:28 <nus> and, if your data is sensible, you'd better be using IPSEC anyway.
00:05:45 <solrize> zomg it's done as linux kernel patches
00:06:24 <dons> pejo: BSD3.
00:06:31 <dons> clauses are being removed over time :)
00:10:24 <nus> doh, @type works and :t breaks the pipe to ghci in the latest lambdabot
00:11:55 <pejo> Oh, perfect - people are awake. Anyone has any suggestions of where the Adaptive (Incremental computations in Haskell) library should live in the module space?
00:13:32 <mmorrow> heh, http://hpaste.org/8280
00:13:38 <mmorrow> call :: (FunPtr a -> IO b) -> [Word8] -> IO b
00:13:48 <mmorrow> unsafeCall :: (FunPtr a -> b) -> [Word8] -> b
00:14:26 <mmorrow> helloWorld :: [Word8]
00:14:26 <mmorrow> helloWorld =
00:14:26 <mmorrow>   [232,14,0,0,0,72,101,108,108,111
00:14:26 <mmorrow>   ,44,32,119,111,114,108,100,33,10
00:14:26 <mmorrow>   ,186,14,0,0,0,89,187,1,0,0,0,184
00:14:27 <mmorrow>   ,4,0,0,0,205,128,49,192,195]
00:21:00 <quicksilver> pejo: what does it do?
00:22:46 <pejo> quicksilver, google for "magnus carlsson adaptive ogi" and check the cache of the first hit. :-)
00:27:53 <quicksilver> Data.Adaptive or Control.Monad.Adaptive
00:27:56 <quicksilver> would be my guesses
00:28:10 <quicksilver> depending how 'central' the monad is to the design.
00:29:09 <pejo> I haven't looked that much at the Haskell library, but the concept is that you're carrying around some hidden state.
00:31:25 <pejo> quicksilver, thanks.
00:31:35 <quicksilver> sounds fairly monadic to me.
00:50:55 <fishmacs> dfd
00:51:43 <fishmacs> I got problem installing HSQL and haskellDB under GHC6.8.2
00:52:55 <opqdonut> which unicode lambda for lambda abstraction?
00:53:21 <opqdonut> U+03BB ?
00:53:52 <fishmacs> runghc Setup.lhs build
00:54:00 <fishmacs> Database/HSQL/Types.hs:134:18: Not in scope: type variable `forall'
00:54:00 <fishmacs>  
00:54:00 <fishmacs> Database/HSQL/Types.hs:134:25: Not in scope: type variable `a'
00:54:00 <fishmacs>  
00:54:03 <fishmacs> Database/HSQL/Types.hs:134:27:
00:54:07 <fishmacs>     Illegal operator `.' in type `forall a . (Int
00:54:11 <fishmacs>                                               -> FieldDef
00:54:14 <fishmacs>                                                  -> (FieldDef -> CString -> Int -> IO a) -> IO a)'
00:54:17 <fishmacs>       (Use -XTypeOperators to allow operators in types)
00:54:39 <fishmacs> and runghc -- -XTypeOperators -- Setup.lhs build
00:54:44 <fishmacs> the result is same
00:54:47 <osfameron> fishmacs: you might prefer to use http://hpaste.org  as quoted in the topic
00:55:12 <fishmacs> thanks, osfameron
01:02:59 * Syzygy|de reads the quotes in the HWN
01:03:06 <Syzygy|de> How DO you use zip `ap` tail?
01:03:58 <olsner> ah, that's just zip xs (tail xs)
01:03:58 <mauke> :t zip`ap`tail
01:04:00 <Deewiant> > (zip `ap` tail) [1..]
01:04:04 <lambdabot> forall b. [b] -> [(b, b)]
01:04:06 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:04:15 <Syzygy|de> Oh.
01:04:21 <olsner> @pl \xs -> zip xs (tail xs)
01:04:21 <lambdabot> ap zip tail
01:04:44 <Syzygy|de> In my GHCi session I got     No instance for (Monad ((->) [a]))
01:04:55 <olsner> yeah, you need Control.Monad.Instances
01:04:59 <olsner> to get the function monad
01:05:08 <Deewiant> > fix ((0:) . (1:) . (zipWith (+) `ap` tail))
01:05:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:05:23 <Syzygy|de> Ok
01:05:28 <olsner> > fix ((0:) . (1:) . (zipWith (-) `ap` tail))
01:05:29 <lambdabot>  [0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-6...
01:06:00 <Syzygy|de> > map (uncurry +) . zip`ap`tail $ [1..]
01:06:01 <lambdabot>      precedence parsing error
01:06:01 <lambdabot>         cannot mix `(.)' [infixr 9] and `ap' [i...
01:06:09 <Syzygy|de> > map (uncurry +) . (zip`ap`tail) $ [1..]
01:06:17 <lambdabot>  Couldn't match expected type `(a -> b -> c) -> (a, b) -> c'
01:06:22 <Deewiant> > map fst . (zip `ap` tail) $ fix ((0:) . (1:) . (zipWith (+) `ap` tail))
01:06:36 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:08:40 <Saizan_> fishmacs: add RankNTypes in the extensions field in the hsql.cabal file
01:12:27 <fishmacs> too early, few people woken
01:18:26 <fishmacs> Thanks Saizan, I tried, but time is: Database/HSQL/Types.hs:66:0:
01:18:26 <fishmacs>     Can't make a derived instance of `Typeable SqlError'
01:18:26 <fishmacs>       (You need -XDeriveDataTypeable to derive an instance for this class)
01:18:26 <fishmacs>     In the data type declaration for `SqlError'
01:18:29 <fishmacs>  
01:19:05 <quicksilver> add DeriveDataTypeable to the cabal field now :)
01:20:03 <fishmacs> That works!
01:20:11 <fishmacs> Thanks a lot!
01:20:38 <fishmacs> But I'm wandering why "runghc -- -X..." does not work?
01:20:53 <quicksilver> because it's not Setup.lhs which needs the extension.
01:21:00 <quicksilver> (which is what runghc is running)
01:21:02 <dcoutts> fishmacs: obviously the general pattern is when ghc says it needs flag -XFoo for extension Foo then you add that extension Foo to the .cabal file
01:21:15 <quicksilver> it's Database/HSQL/Types.hs
01:21:22 <quicksilver> which is part of the project proper
01:21:27 <fishmacs> ok
01:21:37 <quicksilver> you should drop a note to the hsql maintainer
01:21:44 <quicksilver> tell him his cabal needs updating for 6.8.2
01:22:08 <dcoutts> fishmacs: right, it's Setup that is itself calling ghc (with lots and lots of flags) and so that needs to know what extensions the package uses
01:22:22 <fishmacs> en, I think it's pretty old, no update since 2005
01:22:39 <dcoutts> yes, it needs a new maintainer who will do actual releases
01:24:24 <fishmacs> -XTypeOperator <-> RankNTypes
01:24:46 <fishmacs> the name is not same,
01:25:00 <quicksilver> maybe hdbc is better maintained than hsql these days.
01:25:15 <Saizan_> TypeOperator is just a wrong guess from GHC
01:26:27 <fishmacs> I'm a newbie, don't know much about them, hsql, hdbc, haskellDB, etc...just select the most simple one, I think
01:27:40 <fishmacs> And, haskellDB also need to modified for ghc 6.8.2
01:28:34 <quicksilver> I think hdbc probably is the most simple of them from one perspective.
01:28:43 <quicksilver> it's the most like db libraries in other languages
01:29:30 <dcoutts> and it has a maintainer
01:29:45 <quicksilver> who is writing a book on real world haskell use :)
01:29:48 <fishmacs> Ok, I'll check hdbc
01:30:01 <quicksilver> even if I have disagreed with his eager use of lazy IO semantics in the past.
01:30:02 <fishmacs> which book?
01:30:08 <quicksilver> "Real World Haskell"
01:30:26 <quicksilver> http://book.realworldhaskell.org/
01:30:27 <lambdabot> Title: Real World Haskell
01:32:11 <fishmacs> seems that book is practical
01:33:02 <fishmacs> which is best Haskell book, do you think?
01:33:38 <fishmacs> I'm reading YAHT, some part is not very comprehensable, to me
01:34:16 <quicksilver> hutton is popular
01:34:18 <quicksilver> so is hudak
01:34:29 <nornagon> woah check out book.realworldhaskell.com
01:35:57 <fishmacs> hudak is "The Haskell School of Expression"?
01:36:09 <opqdonut> yeah
01:37:28 <fishmacs> It is said that "Programming in Haskell" is too theorical
01:37:59 <fishmacs> quicksilver, so you agree use of lazy IO now?
01:38:30 <quicksilver> I doubt programming in haskell is too theoretical.
01:38:41 <quicksilver> A little theory is rather helpful. I can't believe it has much.
01:39:02 <fishmacs> I agree
01:39:24 <dcoutts> I don't think "Programming in Haskell" is too theoretical
01:39:25 <quicksilver> fishmacs: I disagree violently with the use of "lazy IO" as a default, and I worry that it undermines the message about haskell as a referentially transparent language.
01:39:57 <dcoutts> quicksilver: I recently switched Cabal from using lazy IO for reading files, sortof
01:40:09 <quicksilver> I think it's surprising that the Prelude specifies "Special-case" behaviour for hGetContents and a couple of other things which there are no primitives to recreate in other circumstances.
01:40:12 <opqdonut> the only problem with haskell is that it turns most coders into type system junkies
01:40:15 <dcoutts> quicksilver: what I use now is withFileContents
01:40:20 <quicksilver> dcoutts: much better.
01:40:21 <opqdonut> and then they start talking about isorecursive types or something
01:40:49 <the_green_frog> what a nice place
01:40:57 <quicksilver> fishmacs: I also disagree with the use of the phrase 'lazy IO' but that battle is already lost.
01:41:16 <quicksilver> I think it muddies the water because we're talking about something qualitatively different from standard lazy evaluation
01:41:17 <dcoutts> quicksilver: however withFileContents still uses lazy IO, but if you don't consume the contents in the scope of the block then the contents is just truncated. So it's lazy io and still convenient but its safe.
01:41:24 <quicksilver> (which is referentially transparent)
01:41:37 <quicksilver> dcoutts: yes, it's a much neater abstraction.
01:42:05 <the_green_frog> hey guys  I have a question
01:42:13 <quicksilver> you're in luck, we have answers!
01:42:15 <the_green_frog> could someone help me?
01:42:20 <quicksilver> @faq Can someone help the_green_frog ?
01:42:20 <lambdabot> The answer is: Yes! Haskell can do that.
01:42:22 <the_green_frog> ok
01:42:26 <the_green_frog> thanks
01:42:28 <dcoutts> quicksilver: we were getting problems (especially on windows) about files still open and not being able to be moved/deleted
01:42:34 <Itkovian> vincenz: Did you change jobs?
01:42:39 <quicksilver> dcoutts: *nod* I followed a bit of the conversation.
01:42:44 <quicksilver> dcoutts: classic lazy IO bug :)
01:42:59 <dcoutts> afraid so
01:43:01 <quicksilver> dcoutts: happens to be less painful with unix semantics so unix programmers notice it less.
01:43:06 <dcoutts> right
01:43:06 <the_green_frog> my question is about types in haskell
01:43:41 <dcoutts> quicksilver: other change I made was to always use atomic file writing.
01:44:33 <the_green_frog> map _ [] = []
01:45:33 <fishmacs> quicksilver, I think your point is "lazy IO" is not very same with lazy evaluation?
01:45:53 <the_green_frog> map f (h:t) = f h : (map f t)
01:45:53 <the_green_frog> could someone tell me what its type is?
01:46:52 <tensh> the_green_frog: just load it in an interpreter and let haskell find that out for you
01:47:13 <the_green_frog> is it possible?
01:47:15 <the_green_frog> how?
01:47:22 <tensh> :t
01:47:23 <tensh> :)
01:47:41 <BeelsebobWork> @hoogle Eq a => [a] -> a -> [[a]]
01:47:41 <lambdabot> No matches, try a more general search
01:47:47 <fishmacs> use ghci
01:47:57 <the_green_frog> ah!
01:48:03 <BeelsebobWork> @hoogle Eq a => [a] -> [a] -> [[a]]
01:48:04 <lambdabot> No matches, try a more general search
01:48:04 <the_green_frog> thanks tensh
01:48:07 <BeelsebobWork> bugger
01:48:37 <quicksilver> fishmacs: right.
01:49:11 <fishmacs> So what do the phrase should be?
01:49:54 <dibblego> @type map _ [] = []; map f (h:t) = f h : (map f t) in map -- the_green_frog like this
01:49:55 <BeelsebobWork> @hoogle [a] -> (a -> Bool) -> [[a]]
01:49:55 <lambdabot> parse error on input `='
01:49:56 <lambdabot> Distribution.Simple.Utils.breaks :: (a -> Bool) -> [a] -> [[a]]
01:50:04 <dibblego> @type let map _ [] = []; map f (h:t) = f h : (map f t) in map -- the_green_frog like this, or this :)
01:50:06 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
01:50:07 <BeelsebobWork> interesting
01:51:23 <the_green_frog> hummmm
01:51:56 <fishmacs> hey, gurus, are you all Ph.
01:52:00 <fishmacs> D?
01:52:12 <solrize> quicksilver what's the alternative to lazy io?
01:53:57 <solrize> the king of the gurus (SPJ) doesn't have a phd
01:54:55 <fishmacs> really? King does not need phd
01:55:22 <solrize> he supervises phd dissertations though
01:56:11 <fishmacs> not surprised
01:56:26 <solrize> @go evolution of a haskell programmer
01:56:27 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
01:56:27 <lambdabot> Title: The Evolution of a Haskell Programmer
01:57:43 <fishmacs> @abc
01:57:43 <lambdabot> Maybe you meant: arr ask bf ghc rc src
01:58:10 <fishmacs> @haskelldb
01:58:10 <lambdabot> Unknown command, try @list
01:58:25 <solrize> dcoutts still here?
01:58:30 <dcoutts_> @arr!
01:58:30 <lambdabot> I'll crush ye barnacles!
01:58:36 <solrize> :)
01:58:41 <dcoutts_> ;-)
01:58:53 <dcoutts_> solrize: ask, I'll get coffee
01:59:18 <solrize> i have a complicated file that i want to read with data.binary
01:59:31 <solrize> it has a lot of arrays of structures
01:59:51 <solrize> and i'm wondering if there's some reasonable way to automatically generate the code
02:00:50 <dcoutts_> solrize: are you defining the format or is it externally defined?
02:00:54 <solrize> externally defined
02:01:11 <solrize> http://hpaste.org/8282
02:01:26 <dcoutts_> solrize: 'k, so don't use the Binary class, that's point 1. That's for serialising haskell structures.
02:01:35 <solrize> hmm
02:01:49 <solrize> first thing i did was transliterated the file spec into haskell structures
02:01:59 <quicksilver> solrize: the alternative is not using lazy io.
02:02:12 <quicksilver> solrize: which has never given me any problems :)
02:02:33 <dcoutts_> solrize: that's fine, you want an internal type that maps closely to the external
02:03:03 <solrize> ok
02:03:04 <dcoutts_> solrize: the point is the instances for Binary for the standard types (maybe, list etc) are for Haskell types, eg length prefixed lists etc etc.
02:03:50 <dcoutts_> solrize: so sure, the structure will be similar and you'll have functions for serialising each type that calls the ones for the other types etc
02:04:10 <solrize> yeah, it's not idiomatic to make a specialized Get for the particular structures?
02:04:18 <solrize> hmm
02:04:40 <fishmacs> quicksilver, you said hdbc is most simple, then which is best DB solution?
02:05:19 <solrize> i guess i could write out all the functions by hand
02:05:24 <dcoutts_> solrize: a specialised Get monad? or instances of the Binary class?
02:05:38 <solrize> specialized Get
02:05:38 <dcoutts_> solrize: Binary is like Read/Show really
02:05:53 <solrize> i better look at the data.binary docs again
02:05:58 <dcoutts_> solrize: oh, what would you need a specialised Get for?
02:06:25 <Saizan_> you want a specialized parser in the Get monad written by hand if you've an external format
02:06:26 <solrize> no wait, i think i mean a binary isntance where i write a get function
02:06:48 <BeelsebobWork> @pl \x -> (x==y) || (x == z)
02:06:48 <lambdabot> liftM2 (||) (y ==) (z ==)
02:06:57 <dcoutts_> solrize: there are two layers, the Get/Put monads, low layer. The other layer is for serialising haskell types, like Read/Show but for binary. That's the Binary class.
02:07:15 <dcoutts_> solrize: so for an external format you have to work with the Get/Put layer directly
02:07:23 <solrize> i see
02:07:38 <solrize> i just see a lot of repetitive coding if i write out a Get for each type
02:08:09 <quicksilver> we have this tool to avoid repetition.
02:08:13 <quicksilver> We use named values and functions
02:08:14 <solrize> SYB?
02:08:17 <quicksilver> and only write the code once.
02:08:17 <solrize> oh
02:08:17 <quicksilver> :P
02:08:47 <dcoutts_> solrize: if your external format is pretty close to something you could derive from your haskell types then you could derive Binary instances using drift and then edit them (and rename them to functions rather than binary instances)
02:09:26 <solrize> hmmm, that might save some work but it seems really ugly
02:09:34 <solrize> drift is the SYB script?
02:09:56 <dcoutts_> drift is a program, there's also a TH function somewhere for spitting out source code
02:10:02 <Saizan_> it would be nice to have a declarative DSL for binary formats from which you can extract parsers
02:10:08 <dcoutts_> SYB will not help if you need to edit the stuff
02:10:38 <vixey> I saw a nice one in some dependently typed setting
02:10:40 <solrize> i was thinking of BinaryDerive.hs
02:10:48 <solrize> vixey yeah i saw that "power of pi" paper
02:10:55 <vixey> ah that was it then
02:11:00 <quicksilver> I have thought aout a declarative DSL for binary formats.
02:11:08 <quicksilver> solrize: the problem is we don't get know enough about your problem.
02:11:15 <solrize> quicksilver, see the paste
02:11:17 <quicksilver> ah
02:11:21 <solrize> http://hpaste.org/8282
02:11:30 <mmorrow> i pulled that new squirrelmonkey js interp src out of the apple webkit src and darcsified + hscolourized all the (relevant) src
02:11:39 <solrize> VIint is a DER-like variable length int
02:11:41 <sjanssen> @keal
02:11:42 <lambdabot> ghc need to have plugin that allow copy paste in xp
02:11:42 <mmorrow> repo is at http://code.haskell.org/~morrow/code/js/squirrelfish/
02:11:42 <lambdabot> Title: Index of /~morrow/code/js/squirrelfish
02:11:55 <mmorrow> actual new code is in http://code.haskell.org/~morrow/code/js/squirrelfish/VM/
02:11:56 <lambdabot> Title: Index of /~morrow/code/js/squirrelfish/VM
02:12:09 <solrize> squirrelmonkey is a js written in C?
02:12:12 <mmorrow> http://code.haskell.org/~morrow/code/js/squirrelfish/VM/RegisterFile.h.html
02:12:13 <lambdabot> http://tinyurl.com/6ltmzk
02:12:13 <quicksilver> solrize: are all the things you've labelled as "lists" and "tuples" handled consistently?
02:12:27 <solrize> yeah i think so, they're just concatenated
02:12:36 <solrize> TermFreq shouldn't be a tuple i should fix that
02:12:36 <quicksilver> lists must have some kind of length indicator
02:12:37 <mmorrow> solrize: it's a new js interpreter and it's supposedly *fast*
02:12:47 <mmorrow> (unfortunately it's in c++)
02:13:01 <mmorrow> it's uses a register based vm instead of a stack based
02:13:12 <quicksilver> solrize: well I can see two solutions.
02:13:25 <quicksilver> (1) define your own type class which is "like binary but my version"
02:13:32 <quicksilver> then you can write your own instances for tuples and lists.
02:13:35 <quicksilver> (once only)
02:13:41 <quicksilver> and there won't be much duplication.
02:13:45 <solrize> oh!  yeah of course
02:13:51 <quicksilver> (2) newtype those lists and tuples.
02:14:04 <tibbe> mmorrow: I've been reading through the SquirrelFish code a lot lately
02:14:04 <quicksilver> and then use Binary itself.
02:14:19 <quicksilver> (1) feels cleaner to me.
02:14:23 <solrize> so instead of [x] I'd have Mylist x  ?
02:14:25 <tibbe> mmorrow: writing my own direct threaded, register based VM
02:14:29 <mmorrow> tibbe: nice, i got it the other day, but just started looking through it 30min ago
02:14:33 <quicksilver> solrize: yeah, that's solution (2).
02:14:35 <mmorrow> tibbe: nice!
02:14:37 <tibbe> mmorrow: is that just a copy of the repo?
02:14:42 <quicksilver> solrize: I think (1) feels more right though.
02:14:53 <quicksilver> solrize: you might have a few other things you want to attach to your typeclass.
02:14:57 <mmorrow> i pulled out the VM, kjs, wtf subdirs of the JavaScriptCore dir
02:14:58 <tibbe> mmorrow: if I ever finish I'll post a link to my repo on -cafe
02:15:02 <quicksilver> or a few other special cases to handle consistently.
02:15:08 <mmorrow> HsColour -html all the src files
02:15:20 <solrize> quicksilver, i'll see if i can figure out how to write that
02:15:22 <tibbe> mmorrow: the C++ code suffers a bit from the Java syndrom. It's quite hard to follow
02:15:24 <mmorrow> e.g. http://code.haskell.org/~morrow/code/js/squirrelfish/VM/RegisterFile.h.html
02:15:25 <lambdabot> http://tinyurl.com/6ltmzk
02:15:45 <solrize> by seeing how Binary is implemented in terms of Get (I don't care about writing these files right now, just reading them)
02:15:47 <mmorrow> tibbe: totally! i was reading through it going oh nooooo
02:16:10 <solrize> actually i will need to write some similar files too, but new structures that the java prog doesn't use
02:16:58 <mmorrow> tibbe: what lang is your interp for?
02:17:35 <solrize> why not use harpy and make code directly?
02:17:50 <mmorrow> solrize: totally
02:18:36 <mmorrow> solrize: http://code.haskell.org/~morrow/code/haskell/misc/Call.html
02:19:11 <solrize> gak :)
02:19:17 <mmorrow> hehe
02:20:17 <quicksilver> solrize: because that makes it x86 only? :)
02:20:55 <solrize> heh,  maybe that's a temporary limitation
02:21:08 <tibbe> mmorrow: my own lang of course! :)
02:21:17 <mmorrow> tibbe: heh
02:21:20 <tibbe> mmorrow: strict functional language ;)
02:21:22 <solrize> there's also llvm bindings for haskell
02:21:25 <tibbe> mmorrow: statically typed
02:21:30 <solrize> tibbe, cool!
02:21:39 <tibbe> mmorrow: sorry, I mean dynamically typed
02:21:46 <solrize> i like hedgehog lisp and there's been some interest in adding static types to it
02:21:56 <tibbe> currently I'm debugging a seg fault :p
02:21:59 <mmorrow> tibbe: sweet! link to your repo somewhere when you're ready to. i wanna see it!
02:22:14 <tibbe> but I think I got most things in the interpreter itself down now, I still need to write the code gen
02:22:19 <tibbe> mmorrow: sure
02:22:30 <mmorrow> nice
02:22:56 <solrize> quicksilver what do i do about a type like Foo Bar Baz Blech  ?
02:24:09 <quicksilver> either turn in into (Bar,Baz,Blech) so your default instance for 3-tuples kicks in
02:24:18 <solrize> yeah
02:24:22 <quicksilver> or a little bit of SYB-stuff to magic that.
02:24:34 <quicksilver> mind you, how hard is:
02:24:53 <solrize> wait how do i make an instance for arbitrary 3-tuples?  can i dooooo that?
02:25:07 <quicksilver> instance MyBinary (a,b,c)
02:25:23 <quicksilver> where get = (,,) <$> get <*> get <*> get
02:25:24 <quicksilver> probably
02:25:33 <solrize> oh!  i didn't realize those could be polymorphic like that
02:25:51 <solrize> :t <*>
02:25:53 <lambdabot> parse error on input `<*>'
02:25:57 <solrize> :t (<*>)
02:25:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:26:28 <solrize> wowwww
02:26:30 <mbz> hi
02:26:35 <solrize> hi mbz
02:28:24 <solrize> :t x <*> y <*> z
02:28:26 <lambdabot>     Couldn't match expected type `f (a1 -> a -> b)'
02:28:26 <lambdabot>            against inferred type `Expr'
02:28:26 <lambdabot>     In the first argument of `(<*>)', namely `x'
02:28:58 <solrize> @src (<*>)
02:28:58 <lambdabot> Source not found. There are some things that I just don't know.
02:31:21 <quicksilver> solrize: f <$> a <*> b <*> c
02:31:24 <solrize> ic, <*> is like <<= or so
02:31:29 <solrize> for monads
02:31:30 <quicksilver> is a nicer way to write liftM3 f a b c
02:31:50 <solrize> hmm
02:31:54 <vixey> :t (<<=)
02:31:55 <lambdabot> Not in scope: `<<='
02:31:56 <quicksilver> or do { av <- a; bv <- b; cv <- c; return (f av bv cv) }
02:32:06 <solrize> yeah
02:32:43 <solrize> there's all these layers of haskell evolution
02:33:18 <solrize> anyway <*> runs the surrounding actions sequentially
02:33:26 <quicksilver> yes
02:34:29 <solrize> i'm looking at the control.applicative docs
02:34:46 <solrize> this is kind of brain expanding
02:35:57 <quicksilver> applicative is a simpler interface to the most common used parts of monad
02:36:18 <Deewiant> <*> for Monads is ap
02:36:22 <quicksilver> monads have the ability to alter later actions ('effects') based on the return value of earlier ones
02:36:26 <solrize> anyway thanks very much, i think i can make some progress and get something a lot cleaner than a cut and paste handwritten parser
02:36:29 <quicksilver> but that is actually not something you need to do very oftn.
02:36:52 <quicksilver> most often, you just run a bunch of actions and then collect the results with a pure function
02:36:55 <quicksilver> (often a constructor)
02:37:06 <quicksilver> in particular most sensible grammars in parsing monads are like this.
02:37:29 <quicksilver> applicative is this 'simpler' subset of Monad which doesn't need to be able to make later actions dependent on the results of earlier ones.
02:37:38 <quicksilver> and you can use a simpler/nicer API for it.
02:37:40 <solrize> aha
02:38:01 <solrize> it still has to sequence
02:38:13 <solrize> which is done in monads by threading values through the bind operation
02:38:30 <quicksilver> yes, it "only" has sequence, in a sense.
02:38:37 <solrize> >> without >>=
02:38:39 <quicksilver> applicatives are defined by return and sequence.
02:38:41 <quicksilver> yes.
02:38:48 <quicksilver> although not really just >>
02:38:54 <quicksilver> >> throws away the result
02:39:00 <quicksilver> sequence collects results
02:39:10 <quicksilver> (but doesn't let you use them to influence later effects)
02:39:12 <quicksilver> :t sequence
02:39:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:39:50 <solrize> > (,,) [1,2,3]
02:39:51 <lambdabot>  Add a type signature
02:39:55 <solrize> > (,,) [1,2,3.0]
02:39:56 <lambdabot>  Add a type signature
02:40:12 <solrize> > (,,) [1,2,3] :: (Int,Int,Int)
02:40:13 <lambdabot>  Couldn't match expected type `(Int, Int, Int)'
02:40:21 <solrize> > (,,) 1 2 3 :: (Int,Int,Int)
02:40:22 <lambdabot>  (1,2,3)
02:42:08 <frevidar> lets say I have y_list = map f1 (map f2 (map f3 x_list))
02:42:26 <frevidar> is there a way to evaluate y_list in parallel?
02:42:49 <vixey> in parallel with ..?
02:43:01 <frevidar> as in, using multiple threads?
02:43:09 <Deewiant> @hoogle parMap
02:43:09 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
02:43:24 <frevidar> would I have to replace the map's on the RHS?
02:43:31 <frevidar> with parMap?
02:43:38 <vixey> I guess you mean each element of it
02:43:57 <frevidar> vixey: sorry, yes, thats what I mean
02:44:04 <Deewiant> it might be easier to replace the whole thing with map (f1.f2.f3) anyway
02:44:21 <solrize> i think the idea is to run f1, f2 ,and f3 in separate threads?
02:44:26 <frevidar> (I'm not looking for details of how to do things yet, just roughly what can be done)
02:44:35 <solrize> i.e. pipeline on multiple cpu's
02:44:57 <frevidar> solrize: I could do that as well, I guess
02:45:04 <solrize> that's not what you're asking?
02:45:14 <solrize> if the functions aren't complicate the ipc overhead would probably kill you
02:45:25 <solrize> better to chop x_list into pieces and map (f1.f2.f3) over them and merge
02:45:30 <maltem> frevidar: That would be useful if f1, f2, f3 are each _very_ expensive
02:45:45 <quicksilver> parMap (f1.f2.f3) is the simple answer
02:45:48 <frevidar> f1 f2 f3 are actually fairly cheap
02:45:55 <frevidar> not super cheap though
02:46:19 <maltem> (And only if their laziness has very good timing)
02:46:39 <frevidar> maltem: what do you mean?
02:46:40 <solrize> all the x86 locking primitives use 100 cycles or more
02:47:07 <opqdonut> wow?
02:47:17 <frevidar> anyway, I guess here's the structure I've got
02:47:23 <frevidar> I'm basically doing this:
02:47:56 <maltem> frevidar: Suppose f1 needs the value of its argument right at the beginning of its computation. (This actually to be supposed if you're doing a map.) f1's process will sit idle until f2's result is available
02:48:27 <quicksilver> surely it's much more interesting to parallelise over the items of x_list
02:48:37 <frevidar> y_list = map a1 (map a2 (map a3 (f (map b3 (map b2 (map b1 x_list))))))
02:48:51 <quicksilver> I'm not really sure why we got distracted in talking about trying to paralellisse f1 f2 and f3
02:48:54 <frevidar> thats basically what the structure of my program is
02:48:59 <frevidar> well, not exactly
02:49:06 <frevidar> there's actually two lists involved
02:49:10 <frevidar> but roughly that
02:49:18 <frevidar> not the f is without a map on purpose
02:49:23 <maltem> quicksilver: Once it was mentioned, I was going to refute the idea ;)
02:49:46 <frevidar> f traverses forward through the list and then traverses backwards through the list to get a result
02:49:50 <solrize> quicksilver it was b/c i misunderstood the original question
02:50:08 <solrize> or rather it was the first parallelization strategy that i thought of
02:50:11 <frevidar> as in, f xn depends on f (xn - 1)
02:50:48 <frevidar> f is "http://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm" btw, so its not really paralisible, but I think the rest is
02:52:33 <frevidar> so lets say if I start up a1, a2, a3, f, b3, b2, b1 in separate threads, would that work ok?
02:52:53 <frevidar> I guess noting that a3 can't start til f is complete
02:53:14 <frevidar> but b1, b2, b3 can run at the same time, and a3, a2, a1 can run at the same time also
02:53:39 <quicksilver> why do you think b1 b2 and b3 can run at the same time?
02:53:47 <quicksilver> b2's input is b1's output
02:54:00 <quicksilver> b2 can't start until b1 is finished.
02:54:04 <frevidar> quicksilver: I was kind of thinking of them running like a pipeline
02:54:15 <quicksilver> wrong way to think.
02:54:22 <quicksilver> if b2 and b1 are well designed
02:54:29 <frevidar> b2 can start on the first element of the list when b1 is finished with the first element
02:54:43 <quicksilver> ah well now you're saying something very different.
02:54:46 <frevidar> so b1 can be working on element two whilst b2 is working on element one
02:54:47 <frevidar> and so on
02:54:49 <maltem> frevidar: Distributing cheap functions over seperate threads won't gain much, you're more likely to want to distributing the maps. And actually, for the matrix part, I'd even consider to use an Array, because you know that you'll use every list element (and how many there are) anyway
02:54:54 <vixey> I think you should be explicit about 'b1' vs 'map b1'
02:54:58 <quicksilver> you're saying "map b2" and "map p1" in parallel
02:55:01 <quicksilver> that's quite different
02:55:20 <vixey> also
02:55:21 <vixey> y_list = map a1 (map a2 (map a3 (f (map b3 (map b2 (map b1 x_list))))))
02:55:21 <maltem> ah, indeed
02:55:22 <quicksilver> b1 and b2 operate on single elements they can't useful go in paralellel.
02:55:22 <vixey> is written
02:55:27 <frevidar> quicksilver: sorry, yes
02:55:36 <vixey> y_list = map a1 . map a2 . map a3 . f . map b3 . map b2 . map b1 $ x_list
02:55:42 <quicksilver> the simplest thing to try is to do the elements of the list in parallel.
02:55:59 <quicksilver> parMap (a1.a2.a3) . f . parMap (b3 . b2 . b 1)
02:56:05 <quicksilver> that's the first thing I'd rty
02:56:11 <quicksilver> (assuming you have multiple cores)
02:57:09 <frevidar> quicksilver: so what happens if I do "z_list = parMap id y_list"
02:57:23 <frevidar> will those threads actually go into the evaluation of y_list?
02:58:16 <frevidar> if you know what I mean?
02:58:51 <maltem> (Scratch out the Array discussion for now, btw, I missed the tridiagonal part)
02:59:58 <frevidar> I was thinking "start thread to evaluate first element of z_list, thread goes: need to evaluate first element of y_list, not evaluated yet, so do a1 of ..., ... not evaluated yet, so do a2 of etc
03:00:37 <frevidar> maltem: the tridiagonal part currently uses four input arrays, one output array and two temp arrays
03:01:08 <frevidar> maltem: but I was thinking of converting to "http://www.cse.unsw.edu.au/~dons/streams.html"
03:01:09 <lambdabot> Title: Data.List.Stream
03:01:36 <frevidar> because I often don't actually need the arrays because I only access them once
03:01:50 <frevidar> hence I was thinking about doing this with lists
03:15:42 <maltem> right...
03:17:06 <mxc_> is haskell on cocoa a dead project?
03:18:51 <maltem> mxc_: I never even stepped on it; I guess currently the best pathway to GUIs on OSX is to use wxhaskell
03:19:20 <mxc_> probably
03:19:33 <mxc_> also gives you platform independence
03:20:22 <EvilTerran> doesn't gtk2hs work on OSX?
03:20:30 <dcoutts_> should do
03:20:43 <vixey> I think the problem is gtk, not gtk2hs
03:20:52 * EvilTerran wonders if dcoutts has a beep set up for the word "gtk2hs" or something :P
03:21:00 <dcoutts_> ;-)
03:21:20 <pejo> Normal gtk apps through X11 works like a charm for me. I haven't tried gtk2hs.
03:21:27 <uccus> just seen the "click your heals..." quote on HWN... hillarious
03:22:02 <quicksilver> gtk2hs works on OSX, yes.
03:22:10 <quicksilver> I have heard success reports.
03:22:18 <quicksilver> I used wx for a very small app, it was fine.
03:22:38 <quicksilver> I think thre is a not-completely-dead haskell cocoa binding, I'm sure I heard something relatively recent.
03:22:50 * mxc_ cries a little on the inside that his lambdabot quote never made it to the quote list
03:24:20 <mxc_> looks like hoc was last updated 4 years ago
03:24:32 <mxc_> not really a huge deal, was just curious
03:29:05 <fishmacs> q
03:31:22 <Saizan_> it always surprises me that we have very few truly monadic combinators, like e.g. a shortcutting andM :: (a -> m Bool) -> [a] -> M Bool
03:33:22 <FordCortina> @pl \f g h i a b w x ->  (w b) . (w a) . h . g . f . (w i) $ x
03:33:23 <lambdabot> ((((((flip (ap . ((.) .) . flip id) .) . flip (ap . ((.) .) . flip id)) .) .) . flip ((.) . (.) . (.))) .) . flip ((.) . (.) . (.)) . (. flip id) . (.) . (.)
03:33:32 <FordCortina> lol
03:34:40 <FordCortina> looks like lisp from hell
03:36:21 <maltem> @type liftM and . sequence
03:36:23 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
03:36:51 <solrize> wow, drift looks great!  i hadn't looked at it before.
03:40:02 <Saizan_> maltem: yeah, that's the applicative version
03:40:23 <Saizan_> maltem: where you don't short-cut on the side effects
03:40:54 <maltem> d'oh, right
03:47:17 <mxc_> solrize - have you also looked at data.derive?
03:48:23 <Saizan_> is there an algebraic structure with a binary operation and an annihilator for it? i.e. like (N,*,0),(Bool,and,False)..
03:49:12 <quicksilver> not a well-known one, as far as I know.
03:49:23 <quicksilver> "group with a zero" ?
03:51:01 <mattam> Almost like an algebraic bounded semi-lattice ?
03:52:56 <quicksilver> ah yes, lattice theory would be one place to look.
03:53:36 <Saizan_> uhm yeah, it's like having a bottom
03:54:10 <mattam> Well, it's not exactly that because of idempotency.
03:58:43 <solrize> mxc_ no haven't looked at data.derive
03:58:55 <mxc_> same idea, little different implementation
03:59:23 <solrize> looking now
03:59:55 <solrize> hackage?
04:00:06 <mxc_> i think its on ndm's homepage
04:00:11 <mxc_> just
04:00:16 <mxc_> @google data derive haskell
04:00:17 <lambdabot> http://www.cs.york.ac.uk/fp/haddock/derive/
04:01:08 <mxc_> the only thing is, the code it generates creates a lot of non-exhaustive pattern matches (i use -W) so i put it in a separate file with a file specific no warn for those
04:02:50 <solrize> looks semi-undocumented
04:03:02 <mxc_> less so than drive
04:03:04 <mxc_> drift
04:04:04 <mauke> http://www.cs.york.ac.uk/fp/haddock/derive/Data-DeriveTH.html
04:05:01 <solrize> drift has a nice manual
04:06:40 <mauke> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
04:06:41 <lambdabot> Title: Data.Derive: A User Manual
04:10:01 <cnwdup> I think I have a last problem getting my irc bot running: http://hpaste.org/8283
04:11:04 <mauke> I think your Plugin class is broken
04:11:07 <cnwdup> I want to plugin class' functions of type IRC (Maybe a), though I cannot declare them as IRC () since that Monad is defined in Bot.hs which includes Plugin.hs. So, including that in Plugin.hs would result in an unsolvable include circle.
04:11:17 <FordCortina> @hoohle (Num a, Functor b) => b a -> a
04:11:18 <lambdabot> Prelude.id :: a -> a
04:11:18 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
04:11:18 <lambdabot> Data.Function.id :: a -> a
04:11:47 <cnwdup> So how can I solve that? Do I have to make the IRC monad of some class or something? I thought it was a member of the monad class automatically.
04:11:55 <cnwdup> mauke: Why do you think that?
04:12:08 <mauke> because the type signature of ircRaw doesn't make much sense
04:12:22 <cnwdup> Why not?
04:12:36 <mauke> it says ircRaw has to work in any monad
04:12:37 <FordCortina> is there a class of object that permit folding?
04:12:54 <vixey> @src Foldable
04:12:55 <lambdabot> Source not found. Where did you learn to type?
04:13:01 <FordCortina> @hoohle (Num a, b) => b a -> a
04:13:01 <lambdabot> Prelude.id :: a -> a
04:13:01 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
04:13:01 <lambdabot> Data.Function.id :: a -> a
04:13:04 <cnwdup> mauke: It would be enough if it was working in the IRC monad. But what's wrong with that working in any monad?
04:13:12 <mauke> cnwdup: well, it doesn't
04:13:19 <mauke> that's why the compiler complains
04:13:26 <mauke> sendRaw is restricted to a particular monad
04:13:39 <mauke> which is apparently Bot.IRC
04:13:46 <cnwdup> mauke: To which monad? How is this determined?
04:13:58 <cnwdup> Yeah. But I am only using functions from the IRC monad.
04:14:02 <mauke> yes
04:14:13 <mauke> so it doesn't work in e.g. Maybe
04:14:31 <mauke> or []
04:14:59 <mauke> therefore Pong can't implement the interface required by Plugin
04:15:21 <cnwdup> But other IRC (Maybe a) functions work well, which are located in Main.hs, for instance.
04:15:39 <mauke> er, we're talking about ircRaw here
04:15:59 <mauke> and its type clearly says every instance of ircRaw has to work in any monad
04:17:07 <cnwdup> Ah, ok. So what should I do now? I cannot say IRC (Maybe a) there because of the import circle.
04:18:06 <mauke> why does the definition of IRC require Plugin?
04:18:17 <mauke> if it doesn't, you can just move it to a third module
04:19:06 <cnwdup> mauke: It requires Plugin being included because I define the IRC monad's state and environment there which are of type PluginT.
04:20:08 <mauke> you can either define Plugin and IRC in the same file or live with the cyclic dependency
04:20:31 <cnwdup> mauke: How can I live with it? Isn't it a fatal compiling error?
04:20:47 <mauke> no, Haskell allows cyclic imports
04:20:54 <mauke> ghc requires manual help, though
04:20:59 <mauke> you need to write a .hs-boot file
04:21:16 <cnwdup> Ok. I'll read that up. Thank you.
04:22:34 <mauke> http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
04:22:35 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/2y3hr6
04:22:41 <cnwdup> Thanks. (-:
04:43:13 <mjk> i am learning haskell, have a question: how to delete the space of a string?
04:43:35 <sieni> what do you mean by "the space of a string"
04:43:45 <cnwdup> mjk: I suppose you could use filter (/=' ') string
04:43:57 <sieni> ah
04:43:58 <tibbe> > filter (/=' ') "hi there"
04:43:59 <lambdabot>  "hithere"
04:44:44 <mjk> thanks
04:46:04 <hukolele> how can I change the colors in the haskell mode for emacs?... im a lot lost
05:04:43 <petekaz> If a top level function's type signature contains type variables, and the function contains a where clause with another function defined, do I need to do something special when writing that type signature which should contain the same type variable as the top level function?  Right now I get a rigid variable error, but if I remove the type sig on the where clause, it compiles fine.
05:04:50 <TSC> hukolele: You could try M-x customize-face
05:06:07 <petekaz> Here is the snippet of code in question http://hpaste.org/8284  See the type sig on response' defined in the where clause of response.
05:08:05 <mauke> petekaz: you can't express the type of the local functions in H98
05:08:24 <int-e> hmm why did cmeme get banned?
05:08:52 <int-e> TSC: ping
05:08:59 <mauke> > 524278/3600
05:09:01 <lambdabot>  145.6327777777778
05:09:05 <mauke> > 524278/3600/24
05:09:06 <lambdabot>  6.068032407407408
05:12:15 <int-e> (cmeme is the ircbrowse.com log bot. - oh it seems to have reconnected every 5 minutes a week ago. I see.)
05:14:03 <petekaz> mauke: ok, so best practice is just to not put type sigs on those functions?
05:15:04 <mauke> that's what I do
05:15:21 <petekaz> I'm a newbie and I've been explicit with my type defs as I learn.
05:15:48 <petekaz> Thanks.
05:19:16 <FordCortina> :pl \ f g h -> f . h . g
05:19:22 <FordCortina> @pl \ f g h -> f . h . g
05:19:23 <lambdabot> (. flip (.)) . (.) . (.)
05:29:00 <kandinski> buenas
05:32:51 <gwern> that was a long night, but I'm glad I got the GetOpt stuff working
05:33:20 <gwern> (I'm not happy with the getopt lib - it looks way too readonly for what it's doing, but it works and is standard, so...)
05:35:07 <mauke> preflex: + mmgc Massively Multiplayer Garbage Collection
05:43:13 <gwern> mauke: incidentally, would you be interested in adapting preflex to evaluate haskell expressions through mueval, if I ever get it to a releasable state?
05:43:30 <mauke> hmm, yes
05:44:00 <mauke> I've thought about making it run code, but it sounds like work and lambdabot exists
05:44:14 <mauke> if I can just call an external utility, on the other hand ...
05:51:14 <gwern> yes, that's the dream. split the safe-eval functionality out into something else...
05:51:14 <gwern> I actually hope the end result will be even more secure than lambdabot, as I use all the rlimits ( lambdabot has only a few), and a few other tricks (forking off the eval thread, nicing and cd'ing, etc.)
05:51:14 <gwern> I'm not quite there yet - you can still import Foreign and unsafePerformIO and run IO stuff, since I haven't done any whitelisting yet
05:51:15 <gwern> http://haskell.org/haskellwiki/Resource_limits <-- wow, I completely forgot I was writing this back when I was first hacking on lambdabot
05:51:18 <gwern> the really annoying thing is that contained all the info I knew I would need again later, and I did, but I forgot I had written it up :(
05:51:20 <lambdabot> Title: Resource limits - HaskellWiki
05:52:45 <mauke> :-D
05:55:42 * gwern thanks the gwern stuck in the past for being so thoughtful
05:56:52 * gwern accepts the thanks. pshaw, you would've done the same thing
06:19:53 <mjk> i want to get the index of array is even, eg. [1..10]=>[2,4,6,8,10], how to do?
06:20:09 <mauke> index or elements?
06:20:40 <mauke> your code says elements
06:21:07 <osfameron> well, indices would also be true (for 1-based indices) :-)
06:21:09 <tromp> indices start from 0
06:21:12 <TSC> int-e: pong -- you are the author of hs-pgms, is that right?
06:21:26 <mjk> elements
06:21:32 <tromp> filter even
06:21:34 <mjk> mauke: elements
06:21:39 <mauke> > filter even [1..10]
06:21:40 <lambdabot>  [2,4,6,8,10]
06:22:17 <mjk> thank you
06:22:40 <mjk> further, i get the elements of a array randly, how do it?
06:22:47 <Zao> let f x = (snd.unzip) $ filter (even.fst) $ zip [0..] x
06:22:49 <int-e> TSC: yes.
06:23:27 <Zao> (snd.unzip) $ filter (even.fst) $ zip [0..] [1.0,1.1..2.0]
06:23:29 <Zao> > (snd.unzip) $ filter (even.fst) $ zip [0..] [1.0,1.1..2.0]
06:23:30 <lambdabot>  [1.0,1.2000000000000002,1.4000000000000004,1.6000000000000005,1.800000000000...
06:24:09 <pjdelport> if you actually want the indexes, you can use findIndices
06:24:12 <pjdelport> :t findIndices
06:24:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
06:24:53 <TSC> int-e: Great; it's really cool, thanks for making it
06:25:25 <mjk> can't find findIndices
06:25:35 <int-e> nice :) thanks for the thanks, and you're welcome
06:25:41 <pjdelport> mjk: it's in Data.List
06:25:45 <TSC> I've written a strategy which is reasonably good for beginner and intermediate
06:25:46 <pjdelport> you have to import that
06:25:57 <pjdelport> mjk: you can access random elements of lists with !!
06:26:21 <mjk> i try it
06:26:41 <pjdelport> > ['a'..'z'] !! 6
06:26:41 <int-e> TSC: I'll happily include further strategies. Just mail me and tell me whom to credit (if you're happy with the BSD3 license) :)
06:26:42 <lambdabot>  'g'
06:27:18 <pjdelport> mjk: Haskell lists aren't really optimized for random access, though
06:27:38 <pjdelport> getting an element walks the whole list up to that point
06:27:47 <TSC> int-e: Sure; I'll try to improve it a little bit more first (:
06:28:01 <pjdelport> if you need index-based access, it's better to use a real array
06:28:19 <mjk> ah
06:28:42 * int-e should implement hs-plugins support for that program, hmm. but it's a rather low priority todo on my list.
06:28:55 <TSC> I'd like to beat the "Mio equation strategy" on expert that John Ramsdell talks about
06:29:21 <sioraiocht> @seen dcoutts_
06:29:21 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 3h 8m 21s ago.
06:29:26 <sioraiocht> @seen dcoutts
06:29:26 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 4h 45m 45s ago.
06:29:30 <sioraiocht> @seen dcoutts__
06:29:31 <lambdabot> I haven't seen dcoutts__.
06:29:36 <sioraiocht> how unusual...
06:29:38 <TSC> On that note, I still don't know how MonadPrompt works, but it was easy to write a strategy despite that
06:30:24 <int-e> that's good - monadprompt is really designed to implement easy to use embedded languages.
06:31:19 <sioraiocht> does anyone know of an implementation of ropes in haskell?
06:32:28 <mjk> another, i want to calculate some elements, when the sum great than a value, calculate is stop, and then output the sum, how to do, does it need a temporary value?
06:32:58 <sheyll> hi
06:33:40 <sheyll> does anyone know the paper about Arrows from John Hughes from 1998?
06:33:59 <TSC> sheyll: "Generalising monads to arrows", or something like that?
06:34:12 <sheyll> yeah
06:34:18 <sheyll>  I think...
06:34:37 <Saizan_> mjk: you can write that with scanl
06:34:43 <TSC> I think a few people around here would know it (I've read it, at least)
06:35:13 <sheyll> ok it contains an example of an interpreter build with arrows
06:35:58 <sheyll> he compares a monadic interpreter with an arrowtic interpreter
06:36:11 <Saizan_> mjk: head (dropWhile (< somevalue) (scanl (+) 0 elements)) <-- something like this
06:37:53 <mjk> cool
06:39:36 <sheyll> when introducing "if" in the interpreter he shows a way to integrate this "if" into the interpreter that he doesnt like ...
06:40:16 <FordCortina> @hoogle [a] -> [IO ()]
06:40:16 <lambdabot> No matches, try a more general search
06:40:28 <FordCortina> @hoogle print list
06:40:28 <lambdabot> Did you mean: Print List
06:40:29 <lambdabot> Prelude.undefined :: a
06:40:29 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
06:40:39 <FordCortina> @hoogle printList
06:40:39 <lambdabot> No matches found
06:41:02 <FordCortina> @hoogle putStrList
06:41:02 <lambdabot> No matches found
06:41:54 <FordCortina> > print [1,2,3]
06:41:56 <lambdabot>  <IO ()>
06:42:52 <sheyll> it looks like that: 'http://hpaste.org/8286'
06:43:27 <FordCortina> is there a pretty printing library that's particularly easy to pick up?
06:43:56 <sheyll> I dont understand why one couldn simply wrute sth. like this: 'http://hpaste.org/8287'  and be happy
06:46:47 <sheyll> is this impossible because of the type system?
06:48:22 <TSC> That's probably part of the reason; the one you gave isn't the right type
06:49:11 <EvilTerran> sheyll, btw, could you stop putting urls in ''s? it seems to confuse the link highlighting in xchat, and i'm lazy enough to find copy-and-pasting irritating :P
06:51:00 <int-e> sheyll: you can write that, but you can't run the resulting ('inner') arrow within the 'outer' arrow's computation without additional structure
06:52:21 <int-e> The 'additional' structure is basically ArrowApply, which turns an Arrow into a Monad (in disguise). Or, if you restrict yourself to ifs, ArrowChoice will do.
06:54:37 <maltem> @tell conal I cannot get phooey 2.0 to really work with wxwidgets 2.8.7 on OS X (code compiles, but samples crash). Are those problems expected to be common?
06:54:37 <lambdabot> Consider it noted.
06:54:53 <FordCortina> is there a guide to the Text.PrettyPrint library? The current library is supposed to be "heavily modified" w.r.t the John Hughes paper.
06:56:15 <mjk> how to use temporary value?
06:57:31 <int-e> mjk: hmm? f a = let b = 2*a in b + 1 -- is b a temporary value?
07:00:10 <mjk> int-e: like this expr, map (\x->x>3,          calculate a temporary value, eg., the sum of x>3) [1..10]
07:00:28 <mar77a> :t (<-)
07:00:30 <lambdabot> parse error on input `<-'
07:00:32 <mjk> and save the sum to a value
07:01:05 <int-e> mjk: ah, that's just not possible. you need a different function instead of map, a fold.
07:01:10 <int-e> @type foldl
07:01:11 <mar77a> is there a way to make <- prefix, something like (<-) buff getLine
07:01:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:01:54 <int-e> mjk: the "temporary" value becomes an explicit argument to the function that you pass to  foldl
07:02:24 <maltem> mar77a: No, (<-) is special syntax for do notation.
07:02:33 <int-e> mjk: if you want the result to be a list, look at scanl. and ... of course ... there's always the option to do your own explicit recursion.
07:02:38 <mar77a> is there a function that does the same?
07:02:40 <byorgey> mjk: I don't understand what you are trying to do.... find the sum of all values in a list which are greater than 3?
07:02:41 <Saizan_> mar77a: no, but remember that do x <- m; ... == m >>= \x -> ...
07:02:41 <mjk> int-e: i will try it, maybe i can't descript the meaning
07:02:53 <mar77a> mm
07:03:26 <byorgey> mar77a: so in a sense, (>>=) is a function which does 'morally' the same thing =)
07:03:33 <mjk> sorry!my english is poor
07:03:40 <byorgey> mjk: that's ok =)
07:03:41 <conal> maltem: sigh.  i hoped wxwidgets/wxhaskell would work consistently on all the major platforms.  apparently not.
07:03:41 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
07:04:06 <maltem> conal: heh, something will always go wrong
07:04:13 <byorgey> mjk: I'm just trying to make sure I understand what you want to do
07:05:28 <mjk> i can't still descript
07:05:45 <byorgey> mjk: can you give an example?  like, what is the input and what is the output?
07:05:49 <ddarius> "describe"
07:06:06 <mjk> byorgey: i finded a article at one time, i am searching it
07:06:20 <byorgey> mjk: ok
07:06:26 <mar77a> ah, i started reading about (>>) and (>>=) yesterday...gonna have to re-read
07:06:37 <mjk> byorgey: thank you very much
07:08:57 <mjk> byorgey: searched, let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l
07:09:27 <mjk> in Yet Another Haskell Tutorial
07:09:57 <byorgey> > let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l  in count2 (>3) [1..10]
07:09:58 <lambdabot>  7
07:10:43 <Minstrell__> > sum $ filter (>3) [1..10]
07:10:44 <lambdabot>  49
07:11:10 <byorgey> > filter (>3) [1..10]
07:11:11 <lambdabot>  [4,5,6,7,8,9,10]
07:11:15 <byorgey> > length $ filter (>3) [1..10]
07:11:17 <lambdabot>  7
07:11:37 <byorgey> > let count1 p l = length $ filter p l  in count1 (>3) [1..10]
07:11:38 <lambdabot>  7
07:13:14 <Minstrell__> 'count2 p l = length $ filter p l' ? )
07:13:47 <int-e> count2 = (length .) . filter   ;-)
07:14:13 <Minstrell__> )
07:14:35 <Minstrell__> but the latter is harder to read
07:14:39 <int-e> beware the dreaded monomorphism restriction
07:14:59 <int-e> Minstrell__: I'd probably write  count2 p = length . filter p   in actual code
07:15:12 * int-e doesn't like slicing .
07:15:16 <Minstrell__> thanks, I'm a newbie in Haskell...
07:16:31 <int-e> Minstrell__: but  count2 p l = length $ filter p l  is perfectly fine
07:20:01 <Minstrell__> http://hpaste.org/8288 how to rewrite the last three functions in a monad? I'm suspecting that both the maxValue and ptsMap from a state.
07:20:09 <Minstrell__> *form
07:20:49 <dcoutts_> sioraiocht: yo
07:21:06 <dcoutts_> sioraiocht: how's it going?
07:23:56 <byorgey> Minstrell__: if it were me, I would make a new data type for the state, containing those three elements, instead of using a triple
07:25:25 <byorgey> that certainly wouldn't make things any shorter, but it might make it easier to read
07:26:14 <Minstrell__> I think that a state monad will make it shorter...
07:26:58 <mar77a> WHY CANT I THINK THE HASKELL WAY
07:27:14 <Valodim> alcohol?
07:27:16 <Minstrell__> cause the need to pass all the stuff through the several functions will be avoided...
07:28:47 <mar77a> ok how do i count the different elements in a list
07:29:00 <mar77a> how many times does each unique element appear in a list
07:29:11 <byorgey> mar77a: length . nub
07:29:16 <mar77a> :t nub
07:29:18 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:29:30 <mar77a> but without knowing the element
07:29:41 <int-e> is sorting an option?
07:29:42 <byorgey> mar77a: what do you mean?
07:29:51 <mar77a> like, auto self-count
07:29:57 <byorgey> yeah, if you have Ord, you can do it more efficiently with  length . group . sort
07:30:10 <int-e> > map (head &&& length) . group . sort $ [1,2,3,4,2,1,3,5,6,7]
07:30:11 <lambdabot>  [(1,2),(2,2),(3,2),(4,1),(5,1),(6,1),(7,1)]
07:30:20 <byorgey> mar77a: can you give an example?  I'm not sure what 'auto self-count' means
07:30:21 <mar77a> say i have a list ["a","a","b"] , this function would return [("a",2),("b",1)]
07:30:33 <byorgey> ah, see int-e's code above =)
07:30:48 <mar77a> don't get it
07:30:55 <mar77a> group is the key i guess
07:30:57 <mar77a> :t group
07:30:58 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
07:31:05 <int-e> > group . sort $ [1,2,3,4,2,1,3,5,6,7]
07:31:06 <lambdabot>  [[1,1],[2,2],[3,3],[4],[5],[6],[7]]
07:31:06 <byorgey> > group [1,1,1,2,3,2,2,3,3]
07:31:08 <lambdabot>  [[1,1,1],[2],[3],[2,2],[3,3]]
07:31:08 <pjdelport> > fromListWith (+) . (`zip` repeat 1) $ "abracadabra"
07:31:08 <lambdabot>   Not in scope: `fromListWith'
07:31:21 <pjdelport> > Data.Map.fromListWith (+) . (`zip` repeat 1) $ "abracadabra"
07:31:22 <lambdabot>   Not in scope: `Data.Map.fromListWith'
07:31:29 <byorgey> pjdelport: try M.
07:31:32 <mar77a> where is group defined?
07:31:33 <int-e> mar77a: the sort brings equal elements together. group puts spans of equal elements into a single list each
07:31:35 <pjdelport> > M.fromListWith (+) . (`zip` repeat 1) $ "abracadabra"
07:31:36 <lambdabot>  fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
07:31:37 <byorgey> mar77a: Data.List
07:31:40 <mar77a> ok ty
07:31:41 <pjdelport> byorgey: thangs
07:31:43 <pjdelport> thanks, even
07:31:46 <byorgey> hehe
07:31:47 <mar77a> will it work with stringed elements
07:32:07 <pjdelport> :t M.fromListWith (+) . (`zip` repeat 1)
07:32:08 <lambdabot> forall a a1. (Ord a1, Num a) => [a1] -> M.Map a1 a
07:32:11 <int-e> mar77a: sure. String is an instance of both Ord and Eq, so sort and group will work.
07:32:17 <pjdelport> it will work with any Ord instance
07:32:28 <mar77a> yeah stupid question
07:32:50 <byorgey> now, will it work with stringed instruments?  that is a more interesting question ;)
07:33:01 <int-e> byorgey: are they an instance of Ord? :)
07:33:23 <int-e> I suspect they are, but people disagree about the precise ordering being used ...
07:33:32 <int-e> s/being/to be/
07:33:35 <mar77a> ok so if i do: map length (group list) i get the counts but i don't know what the count is of
07:33:39 <byorgey> int-e: yes, of course.  Piano > Cello > ..... > Bagpipe
07:33:57 <int-e> byorgey: heh. I think I'd reverse the first two :)
07:34:10 <mikem> hi
07:34:10 <int-e> byorgey: and bagpipes aren't stringed :)
07:34:26 <mikem> what's this room?
07:34:33 <byorgey> int-e: ah, you've never heard a stringed bagpipe?  they sound HORRIBLE
07:34:40 <byorgey> hi mikem!
07:34:44 <atsampson> byorgey: it's sort of hard to tell, really
07:34:45 <int-e> byorgey: nope.
07:34:49 <mikem> hi byorgey
07:34:54 <byorgey> mikem: this is a chat for the functional programming language Haskell
07:35:02 <mikem> k
07:35:04 <byorgey> mikem: it's the best programming language ever.
07:35:12 <mikem> ic
07:35:13 <byorgey> mikem: www.haskell.org
07:35:20 <int-e> mar77a: right. map head ...  gives you the elements without the count.
07:35:23 <mikem> check it ou
07:35:28 <mar77a> o_o
07:35:37 <int-e> mar77a: map (\xs -> (head xs, length xs)) ... gives you both
07:35:38 <mikem> hope it is open source
07:35:47 <mar77a> ahh
07:35:49 <byorgey> mikem: of course
07:35:52 <mar77a> that's what the (&&&) is all about?
07:35:58 <int-e> mar77a: (head &&& length) is a slightly obscure way to write  (\xs -> (head xs, length xs))
07:36:00 <byorgey> mar77a: right!
07:36:05 <mikem> thanks ...
07:36:08 <mar77a> go easy on this newbie
07:36:10 <byorgey> mar77a: (f &&& g) x = (f x, g x)
07:36:18 <mikem> brb
07:36:19 <mikem> bye
07:36:23 <byorgey> [well, for the (->) instance of Arrow at least ;)
07:36:25 <int-e> mar77a: (it belongs to the Arrow abstraction, using the (->) Arrow)
07:36:37 <int-e> @type (&&&)
07:36:38 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:36:43 <int-e> which is why this type looks scary.
07:36:52 <mar77a> not scary at all
07:37:03 <mar77a> please don't do that ever again or i will slit my wrists
07:37:06 <int-e> Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
07:37:32 <mar77a> BRING THEM MONOIDS BRING THEM FUNCTORS I AM NOT AFRAID I HAVE PYTHONG INSTALLED TOO
07:37:37 <int-e> it's a bit more readable written that way.
07:37:40 <mar77a> eh always that g...
07:37:42 <mar77a> ok lets see
07:37:52 <int-e> and in our case, ~> is really ->
07:38:34 <Valodim> pythong?
07:38:36 <Valodim> haha
07:39:07 <Gwern-away> 'As far as I know, hs-plugins works by taking an expression, writing it to a file, calling GHC to parse it, transform it to Core, optimise it, transform it to STG, optimise it, transform it to C--, optimise it, transform it to ANSI C, optimise it, pass it to GCC, compile it, link  it, and *then* using the GHC runtime linker to load the generated object code into memory, type-check it, and, finally, execute it.'
07:40:00 <int-e> Gwern-away: hehe. and you can skip the first three steps by using ghc-api directly :)
07:40:15 <mar77a> wait what's wrong with: map (\xs -> (length . head) xs) ((group . sort) list)
07:40:47 <int-e> mar77a: that will give you the length of the words ...
07:41:18 <mar77a> (head . length)?
07:41:18 <Deewiant> > let list = ["foo","bar","baz","quux"] in map (\xs -> (length . head) xs) ((group . sort) list)
07:41:20 <lambdabot>  [3,3,3,4]
07:41:32 <byorgey> mar77a: (length . head) xs means, the length of the first element of the list xs
07:41:37 <int-e> Gwern-away: but it's not entirely accurate. hs-plugin allows you to skip most of the steps and just link (so does ghc-api) ... you just lose a lot of type safety.
07:41:38 <Deewiant> > let list = ["foo","bar","foo","quux"] in map (\xs -> (length . head) xs) ((group . sort) list)
07:41:39 <lambdabot>  [3,3,4]
07:41:50 <Gwern-away> 'Don't forget the Evil Mangler, which optimises the compiled assembly!'
07:41:55 <int-e> :)
07:41:55 <Gwern-away> he he
07:42:01 <mar77a> argh the hell am i doing
07:42:03 <Deewiant> > let list = ["foo","bar","foo","quux"] in map (\xs -> (id &&& (length . head)) xs) ((group . sort) list)
07:42:04 <lambdabot>  [(["bar"],3),(["foo","foo"],3),(["quux"],4)]
07:42:25 <mar77a> ahhh
07:42:30 <int-e> mar77a: you're a bit confused about (.) ... it'll pass :)
07:42:38 <mar77a> i know i KNOW
07:43:01 <Cale> (\x -> f x) is usually the same as f, btw.
07:43:21 <mar77a> amazing now i got it
07:43:39 <mar77a> i wanted both head and length of the xs in a tuple..not compo..sited
07:44:02 <Cale> > let list = ["foo","bar","foo","quux"] in map (id &&& (length . head)) ((group . sort) list)
07:44:03 <lambdabot>  [(["bar"],3),(["foo","foo"],3),(["quux"],4)]
07:44:18 <Cale> > let list = ["foo","bar","foo","quux"] in map (length &&& head) ((group . sort) list)
07:44:19 <lambdabot>  [(1,"bar"),(2,"foo"),(1,"quux")]
07:44:44 <Cale> > let list = ["foo","bar","foo","quux"] in map (length . head) ((group . sort) list)
07:44:45 <lambdabot>  [3,3,4]
07:44:46 <mar77a> > map (\xs -> (head xs, length xs)) ((group . sort) ["foo","bar","foo"])
07:44:47 <lambdabot>  [("bar",1),("foo",2)]
07:44:52 <mar77a> ^__^
07:45:34 <Cale> > map (\xs -> (head xs, length xs)) . group . sort $ ["foo","bar","foo"]
07:45:36 <lambdabot>  [("bar",1),("foo",2)]
07:45:44 <mar77a> details
07:45:53 <mar77a> psh
07:46:02 <Cale> > map (head &&& length) . group . sort $ ["foo","bar","foo"]
07:46:03 <mar77a> haskell makes me hungry
07:46:03 <lambdabot>  [("bar",1),("foo",2)]
07:47:49 <stevan> is it possible to override the default instance of Eq for standard data types?
07:49:54 <maltem> stevan: Alas, there's no such thing as proper instance "management". So the best thing to suggest is a newtype
07:50:43 <stevan> ok, thanks.
08:00:03 <xif> So basically, the Google team won the last two ICFP contests?
08:01:58 <skorpan> debugging django is a real bitch
08:03:14 <tusho> skorpan: Use Hasko.
08:03:23 <tusho> Hjaskngello.
08:03:47 <skorpan> tusho: i start work on monday, i'm going to be using django
08:03:57 <tusho> skorpan: Hjaskngello is obviously superior.
08:04:14 <skorpan> never heard of it, but you convinced me
08:04:21 <tusho> I just made it up.
08:04:29 <tusho> :D
08:04:29 <skorpan> still convinced :)
08:04:30 <tusho> Hjaskngello is a totally awesome name though.
08:04:35 <skorpan> at least this isn't php...
08:04:44 <tusho> HJASKNGELLO: It's goddamn rapid, you idiot.
08:04:50 <tusho> we're as good as 1.0
08:05:08 <skorpan> i think i hang on /b/ too much, i read "rapid" as "rape-id"
08:06:58 <tusho> skorpan: oh my
08:07:00 <tusho> that would work too I guess
08:09:06 <mauke> preflex: remember skorpan i think i hang on /b/ too much, i read "rapid" as "rape-id"
08:09:16 <BeelsebobWork> hmm, this isn't really a Haskell question, but some people in here may be able to help with it
08:09:35 <BeelsebobWork> I've been writing a type checker, it has support for various fun things including parametric polymorphism
08:09:51 <BeelsebobWork> what I'm working on is automatically anotating the polymorphism, like Haskell does
08:10:02 <skorpan> mauke: what was that?
08:10:04 <mar77a> @hoogle System.Directory
08:10:05 <lambdabot> No matches, try a more general search
08:10:23 <mauke> preflex: quote skorpan
08:10:23 <preflex>  <skorpan> i think i hang on /b/ too much, i read "rapid" as "rape-id"
08:10:26 <BeelsebobWork> so that if I said "ifthenelse True x y" it automatically rewrites to "ifthenelse[type of x and hopefully y too] True x y"
08:10:37 <skorpan> right..
08:11:01 <ziman> is there a downloadable version of GHC Hierarchical Libraries documentation or may i mirror it using wget?
08:11:26 <Deewiant> it comes with GHC
08:11:27 <BeelsebobWork> but, in the example "let r = ifthenelse True r 0", we can infer the type of r, find that it's 'a', and rewrite to "let r = ifthenelse[a] True r 0"
08:11:28 <mar77a> i have logSp <- logSplit "log.txt"
08:11:32 <mar77a> logSplit returns a list
08:11:35 <Zao> ziman: http://haskell.org/haskellwiki/GHC
08:11:39 <BeelsebobWork> but that's not very useful -- I need to do the application to Int, not a
08:11:42 <lambdabot> Title: GHC - HaskellWiki
08:11:48 <Zao> There seems to be a tarball of HTML there.
08:11:50 <mar77a> how would i concat all lists generated by using logSplit on all files in the current dir
08:11:55 <BeelsebobWork> how do I go about finding out what should be applied?
08:12:03 <mar77a> with say System.Directory.getDirectoryContents "."
08:12:28 <ziman> Zao, thanks
08:22:41 <quicksilver> mar77a: files <-  System.Directory.getDirectoryContents "."; results <- mapM logSplit files; return (concat results)
08:22:44 <quicksilver> mar77a: perhaps?
08:23:44 <vincenz> @tell Itkovian yes I did
08:23:45 <lambdabot> Consider it noted.
08:23:57 <vincenz> @tell Itkovian I take it you went to visit IMEC?
08:23:57 <lambdabot> Consider it noted.
08:29:22 <chris____> yo yo yo
08:29:43 <byorgey> hi chris____
08:29:45 <chris____> blagh it didn't announce my paste
08:29:48 <chris____> http://hpaste.org/8292
08:30:01 <chris____> any nice way to express this "remove" function?
08:30:26 <chris____> remove items from a list that match a predicate, and return the new list, and a Bool to say if any items were indeed removed
08:32:10 <tusho> @remember skorpan i think i hang on /b/ too much, i read "rapid" as "rape-id"
08:32:10 <lambdabot> It is stored.
08:32:16 <tusho> (can't let mauke let his bot get all the quotes)
08:32:57 <chris____> ignore my isAnagram function. I'll write that faster later
08:33:24 <chris____> it would be awesome if lambdabot could load code in from hpaste, ha ha ha
08:33:27 <dmwit> chris____: Do you know about filter?
08:33:35 <chris____> dmwit: mhm
08:33:54 <dmwit> I suggest it. =)
08:34:08 <byorgey> but chris____ wants a Bool saying whether anything got filtered or not
08:34:09 <chris____> dmwit: I considered filter, but I didn't want to have to inspect the list to see if it had changed which would be slower than simply being told, if you follow me
08:34:43 <dmwit> (filter p xs, null . filter (not . p) $ xs)
08:34:43 <quicksilver> that sounds like an un-necessary optimisation.
08:34:59 <byorgey> ah, dmwit, good call
08:35:01 <quicksilver> :t partition
08:35:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:35:07 <dmwit> Or yeah, partition.
08:35:24 <dmwit> (second null .) . partition
08:35:27 <quicksilver> let (ins,outs) = partition p xs in (outs,null ins)
08:35:42 <tusho> chris____: it won't examine the whole list
08:35:42 <chris____> ah good one! :D
08:35:43 <quicksilver> but personally I'd go for the more idiomatic approach
08:35:45 <tusho> if you just check for emptiness
08:35:46 <tusho> Lazines..
08:35:48 <byorgey> (fst &&& (not . null . snd)) . partition
08:35:48 <tusho> *laziness
08:36:00 <chris____> partition is lovely
08:36:08 <dmwit> byorgey: second is nicer. ;-)
08:36:10 <quicksilver> (filter (not p) xs,any (not p) xs)
08:36:19 <byorgey> dmwit: ah! indeed.
08:36:26 <quicksilver> (filter p xs,any p xs)
08:36:27 <quicksilver> rather
08:36:33 <quicksilver> bah
08:36:34 <chris____> quicksilver: isn't that doing more processing than necessary, though?
08:36:37 <quicksilver> (filter p xs,any (not p) xs)
08:36:42 <quicksilver> chris____: yes, slightly.
08:36:48 <byorgey> not asymptotically.
08:36:49 <quicksilver> but it's easier to read
08:37:10 <quicksilver> byorgey: well it's still O(n) but it's also O(n) worse.
08:37:22 <byorgey> quicksilver: in the worst case it is.
08:37:24 <quicksilver> things can be in the same complexity class and still asymptotically worse.
08:37:29 <tusho> hmmm:
08:37:29 <tusho> (filter p xs,any (not p) xs)
08:37:30 <quicksilver> yeah, in the worst case
08:37:35 <tusho> surely that could be optimised
08:37:38 <tusho> in the same way as multiple maps
08:38:07 <quicksilver> tusho: unless you think your list is thousands of items long I wouldn't worry much about one extra traversal :)
08:38:25 <quicksilver> if your list is millions of items long and you're trying to stream it, it's worth worrying for sure.
08:38:25 <tusho> quicksilver: I'm just saying, it could be something to put in ghc.
08:38:30 <chris____> well my list is only about a thousand
08:38:30 <tusho> Because of its nice rule thingy.
08:38:37 <tusho> oh
08:38:38 <tusho> a thousand
08:38:42 <tusho> then that IS a problem, kinda.
08:38:48 <tusho> i'd say.
08:39:25 <dmwit> You know what they say about premature optimization.
08:39:28 <chris____> the problem's a bit contrived so it's hard to know how much OMG OPTIMISE needs to be done
08:39:38 <quicksilver> @quote premature
08:39:38 <lambdabot> pcrs says: Premature carriage ret
08:39:46 <quicksilver> chris____: then don't do any until you've finished.
08:39:48 <dmwit> And I doubt your custom iterator will be faster than GHC's partition.
08:39:52 <quicksilver> chris____: and then decide if it's too slow.
08:40:10 <chris____> dmwit: nah me neither. I didn't notice partition
08:40:11 <cnwdup> http://hpaste.org/8293 Can anyone tell me what's wrong with that?
08:40:20 <chris____> quicksilver: sure
08:40:35 <chris____> `readWords' made me laugh. so concise
08:41:03 <_gort> chris____: why not just sort (the letters in) each word, and look for unique elements?
08:41:12 <dmwit> cnwdup: Is that the whole source?
08:41:49 <chris____> _gort: you mean (==) `on` sort ?
08:41:50 <cnwdup> dmwit: Not really. But it's what I think is the relevant part. Am I missing something? The error is actually arising elsewhere. I'll upload a more complete source, mom.
08:42:01 <chris____> _gort: that would probably be quite nice, my main man
08:42:45 <mauke> cnwdup: the error is from Plugin Pong
08:42:53 <mauke> which should be Plugin (Pong i)
08:43:12 <chris____> > ((==) `on` sort) "coat" "taco"
08:43:13 <lambdabot>  True
08:43:29 <cnwdup> mauke: Ah, thanks! I thought there was something wrong with the instance declaration. Sure. Thank you! (-:
08:44:03 <twobitwork> @hoogle on
08:44:04 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:44:04 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
08:44:04 <lambdabot> Data.Function :: module
08:44:25 <chris____> > ((==) `on` (sort . map toLower)) "coat" "TACO"
08:44:27 <lambdabot>  True
08:44:40 <bugQ> I want a taco coat!
08:44:53 <chris____> hahaha
08:45:00 <twobitwork> ?src on
08:45:01 <lambdabot> (*) `on` f = \x y -> f x * f y
08:45:03 <chris____> parens probably aren't necessary
08:45:08 <dmwit> http://icanhascheezburger.com/2007/11/12/tacocat-is-a-palindrome/
08:45:13 <lambdabot> Title: TACOCAT IS A  Lolcats &#8216;n&#8217; Funny Pictures of Cats - I Can Has Cheezb ...
08:45:15 <chris____> > (==) `on` sort . map toLower "coat" "TACO"
08:45:16 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:45:22 <chris____> > ((==) `on` sort . map toLower) "coat" "TACO"
08:45:24 <lambdabot>  True
08:45:26 <chris____> ja
08:45:51 <chris____> dmwit: haha :-D
08:46:04 <twobitwork> > (==) `on` sort . map toLower $ "coat" "TACO"
08:46:05 <lambdabot>      precedence parsing error
08:46:05 <lambdabot>         cannot mix `on' [infixl 0] and `($)' [i...
08:46:22 <twobitwork> doh
08:46:42 <tusho> dmwit: Tautologicalcat is tautological.
08:47:17 <chris____> isAnagram = (==) `on` sort . map toLower
08:47:21 <chris____> om nom nom ^_^
08:47:40 <_gort> :)
08:49:38 <_gort> chris____: one n^2 down, one to go...
08:50:20 <chris____> hehe
08:55:14 <chris____> http://hpaste.org/8292#a1
08:55:29 <chris____> takes pretty much the same amount of time, between 9-10 seconds each time
08:55:31 <frevidar> is the plan that ghc.PArr will be http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell/Package_NDP eventually?
08:55:37 <lambdabot> Title: GHC/Data Parallel Haskell/Package NDP - HaskellWiki, http://tinyurl.com/5fpqfu
08:56:49 <dmwit> chris____: Store the words in a Map, keyed by their sort?
08:57:29 <chris____> dmwit: by their sort? you mean sort them and then create a map fromList?
08:57:52 <_gort> chris____: if you try a list of 10 1000-letter words, it should be faster now :)
08:58:08 <chris____> _gort: hehe
08:58:10 <dmwit> fold (\map word -> insertWith (sort word) (word:) map)
08:58:15 <_gort> chris____: basically use "acot" as the key for TACO and CoAT
08:58:15 <mauke> canonize = sort . map toLower
08:58:26 <chris____> ahhh
08:59:00 <dmwit> That isn't really right, but maybe you get the idea.
08:59:10 <chris____> ah sure do, boss
09:01:58 <adiM> I am using Data.Tree to create a prefix Tree. Here is the code: http://hpaste.org/8294 This works, but I am wondering if I can do this in a more compact way using Applicative or Traversable?
09:03:03 <quicksilver> adiM: well you don't need those two cases for prefixTree'
09:03:12 <quicksilver> adiM: the latter subsumes the former
09:03:42 <chris____> dmwit: so something like, insert words into the map, then take from the map all items which contain only one word?
09:03:54 <mauke> apparently "supersume" is not a word
09:03:55 <adiM> Ah, I did not realize that map f [] = []. Thanks quicksilver
09:04:11 <quicksilver> mauke: it is now.
09:04:22 <chris____> yay language evolution
09:04:29 <dmwit> chris____: Yeah.
09:04:41 <quicksilver> adiM: once you've done that it's already rather compact
09:04:46 <quicksilver> adiM: I'm not sure how you could make it bette r:)
09:05:05 <quicksilver> for example loquacracy didn't used to be a word. But it is now.
09:05:07 <chris____> dmwit: is that actually faster than my current implementatioN?
09:05:22 * dmwit looks again
09:06:45 <chris____> hmm partition probably does more work because it has to observe the remaining list each time
09:07:12 <dmwit> Your algorithm looks to be O(n^2).
09:07:21 <dmwit> Using a map it ought to be O(n*log n).
09:07:26 <adiM> quicksilver: This was a simple example. I have lot of functions which use recursion like this. I was thinking that there must be a general way to do such things.
09:07:40 <dmwit> Of course, you have to mind the constant factors, as always, but Data.Map is pretty darned fast.
09:08:39 <chris____> dmwit: yeah. disregarding Data.Map's look up speed for a moment, first you have to traverse the whole list to insert them into the map, then again to build the final ananagrams list
09:08:40 <Raspberry6252> Could anyone please help me with an assigment I have, I've never used Haskell before?
09:09:19 <quicksilver> adiM: yes, there are.
09:09:34 <dmwit> chris____: Two traversals, yes.  But you're doing O(n) traversals right now, so...
09:09:49 <quicksilver> adiM: but what you're doing isn't quite a simple "fmap"
09:09:56 <quicksilver> adiM: "fmap" would do the same thing at each level.
09:10:05 <quicksilver> adiM: you're doing different things as you ripple down the tree
09:10:08 <chris____> dmwit: yeah, that's why I was wondering if it's the same speed?
09:10:13 <quicksilver> (prepending the 'local prefix')
09:10:29 <quicksilver> adiM: there is a name for this recursion pattern but I don't know what it is.
09:10:54 <quicksilver> some people around here (edwardk is one, I think) delight in naming the obscure recursion patterns.
09:11:00 <quicksilver> hylomorphism anyone?
09:11:17 <quicksilver> Raspberry6252: people will help, but not until you ask your question ;)
09:11:30 <Deewiant> how about a zygohistomorphic prepromorphism
09:11:35 <chris____> dmwit: I'll implement that as anagrams' and compare speeds =o
09:11:36 <quicksilver> Raspberry6252: we're a friendly bunch although we probably won't write your homework for you...
09:11:38 <Syzygy|de> ...
09:11:46 <Deewiant> (http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms for anybody who missed it earlier)
09:11:47 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
09:12:01 <geezusfreeek> oh the useful haskell snippet
09:12:02 <Syzygy|de> Raspberry6252: And if we end up doing, your prof probably won't, in the end, believe you wrote it yourself: golfing is popular in here...
09:12:02 <chris____> uhm, anangrams'
09:12:24 <BMeph> quicksilver: Like "yoyomorphism" for operations that go up and down a structure? ;p
09:12:52 <quicksilver> ;)
09:12:53 <Syzygy|de> quicksilver: Did you see the guy whose prof wouldn't accept his homework solution because it was too pointless and elegant, so the prof didn't understand it?
09:12:58 <adiM> quicksilve: I have separated out the recursion into a function modifyTree. http://hpaste.org/8294#a1  Is there no buildin function in Data.Tree which does the same work as modityTree?
09:13:08 <quicksilver> Syzygy|de: I hear such stories certainly.
09:13:08 <Deewiant> Syzygy|de: O_o
09:13:28 <geezusfreeek> there is a difference between the way we usually golf and the way perl programmers golf though... we usually try to keep the end result as readable or maybe even more readable than the original :)
09:13:35 <quicksilver> adiM: No.
09:13:57 <Syzygy|de> quicksilver: A couple of days ago. Task: count repeated words. Solution: > ex1 = any ((>1).length) . group . words
09:14:01 <Syzygy|de> (iirc)
09:14:02 <quicksilver> adiM: in words I'd say it's a bit like "scanL" downwards whilst being a simple "fmap" breadthwards.
09:14:12 <quicksilver> > scanl (++) "abcde"
09:14:13 <lambdabot>  <[[Char]] -> [[Char]]>
09:14:18 <quicksilver> > scanl (++) "" "abcde"
09:14:19 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
09:14:21 <Syzygy|de> :t any ((>1).length) . group . words
09:14:23 <lambdabot> String -> Bool
09:14:34 <chris____> what's this < > stuff?
09:14:36 <quicksilver> > scanl (++) "" ["a","b","c","d","e"]
09:14:37 <lambdabot>  ["","a","ab","abc","abcd","abcde"]
09:14:42 <quicksilver> chris____: types.
09:14:43 <adiM> Yes, I was thinking of this as a way to understand applicative or traversable,...
09:14:45 <chris____>   <[[Char]] -> [[Char]]>
09:14:51 <quicksilver> chris____: if LB can't evaluation the think you've given it completely
09:14:56 <quicksilver> chris____: it shows you its type instead
09:14:56 <chris____> ah right
09:15:00 <chris____> :)
09:15:09 <mauke> evaluation is now a verb
09:15:16 <quicksilver> adiM: it's certainly not a simple case of applicative or traversable, no.
09:15:16 <chris____> yay
09:15:36 <quicksilver> adiM: because it's behaving differently "vertically" than "breadthwise"
09:15:42 <quicksilver> adiM: (did you see my point about scanl)
09:15:54 <quicksilver> mauke: yeah my typing is bad, I broaden the language very rapidly ;P
09:16:16 <mauke> quicksilver embiggens the english language
09:16:18 <chris____> orbitz is already in his own language
09:16:28 <adiM> quicksilver: Yes, I do understan scanl, I am just surprised that Haskell doesn't have a Class that captures this type of recursion
09:16:38 <geezusfreeek> :t scanl
09:16:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:16:57 <geezusfreeek> Foldable or Traversable doesn't?
09:17:05 <geezusfreeek> err, don't?
09:17:07 <dmwit> > scanl (flip (:)) "" "hey"
09:17:08 <lambdabot>  ["","h","eh","yeh"]
09:17:33 <geezusfreeek> hmm, don't know the right way to say it with that "or" there. if it was "and" than i know it would be "don't"
09:18:04 <geezusfreeek> i say they both work. i will embiggen the english language yet more
09:18:25 <vixey> @w80 embiggen
09:18:26 <lambdabot> No match for "embiggen".
09:18:31 <Tigran`> > scanl1 (+) [1,4..]
09:18:32 <lambdabot>  [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,7...
09:18:36 <Tigran`> > scanl1 (+) [1,4..]
09:18:38 <lambdabot>  [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,7...
09:18:40 <Tigran`> > scanl1 (+) [1,3..]
09:18:41 <dmwit> geezusfreeek: Neither Foldable nor Traversable work?
09:18:41 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
09:18:42 <Tigran`> Arg.
09:19:12 <dmwit> geezusfreeek: (Negatives often use different connectors.)
09:19:19 <Tigran`> Apologies for the spam, wrong paste.
09:19:19 <quicksilver> adiM: it's pretty specific for trees.
09:19:25 <geezusfreeek> dmwit: i suppose that is a way to get around it
09:19:40 <quicksilver> geezusfreeek: foldable and traversable both have a distinctly linear feel to them.
09:19:44 <geezusfreeek> i was trying to make it such that it was more parallel with the question though
09:19:48 <quicksilver> they process the items from beginning to end in a fixed order.
09:19:58 <adiM> quicksilver: Ok, I will just define it in my local module, and use it
09:20:01 <quicksilver> adiM: *nod*
09:20:14 <geezusfreeek> oh, this is not supposed to be linear? scanl is linear though, isn't it?
09:20:15 <quicksilver> adiM: It's not immediately clear to me it generalises to an obvious more general notion
09:20:26 <quicksilver> geezusfreeek: this is scanl'ing down the tree
09:20:33 <quicksilver> geezusfreeek: but plain mapping across the width
09:20:34 <orbitz> chris____: i'm everywhere
09:20:43 <geezusfreeek> oh, depth first scanning?
09:20:51 <quicksilver> building up prefixes.
09:21:02 <quicksilver> go from prefix tree to fully-laid-out tree
09:21:04 <quicksilver> e.g.
09:21:18 <adiM> geezusfreek: Actually for some applications, I need breadth first scanning.
09:21:36 <quicksilver> breadth-first scanning is a Foldable notion
09:21:43 <quicksilver> but it's not the default Foldable instance for Trees
09:21:45 <geezusfreeek> quicksilver: oh i think i see. it needs to be scanning but with some notion of backtracking
09:21:54 <quicksilver> geezusfreeek: that is one way of looking at it, yes
09:22:04 <quicksilver> depth first scanning with backtracking.
09:22:25 <adiM> quicksilver: Cannot generating a prefixtree done in a breadth-first manner?
09:25:39 <mauke> I'm honestly not sure how serious "Zygohistomorphic prepromorphisms" is
09:25:47 <geezusfreeek> for some reason i am having trouble thinking of this in a way that is not imperative
09:25:58 <geezusfreeek> mauke: edwardk has said it was a joke
09:26:17 <vixey> It's real
09:26:32 <geezusfreeek> vixey: well, a real thing, but as a joke about it being useful
09:26:54 <quicksilver> adiM: not very naturally, no
09:26:57 <quicksilver> adiM: of course it can be
09:27:04 <mauke> I'll use it for good (= trolling)
09:27:11 <quicksilver> adiM: but you'd build up at each level a whole list of current partial prefixes.
09:27:26 <sclv> on the other hand, one can further abstract modifyTree if you note that the "context" is just the previous path.
09:27:36 <quicksilver> sclv: right
09:27:50 <tusho> mauke: it's serious in a 'hmm interestingly category theoretical!' way
09:27:56 <tusho> not in a 'this will help me write an mp3 player' way
09:28:01 <quicksilver> sclv: but then to think of a more general notion of path
09:28:10 <quicksilver> sclv: you end up with a more general notion of traversal
09:28:10 <adiM> sclv: I do not understand. Can you please explain?
09:28:13 <sclv> so instead of passing around a growing string, you pass around the previous path, and you've got a sort of zipper transformation.
09:28:23 <quicksilver> sclv: however, if you think hard about that "more general notion of traversal"
09:28:24 <chris____> orbitz: so is she
09:28:35 <quicksilver> I think you pretty much come back to thinking really you've just described trees.
09:28:48 <quicksilver> basically at each point you have a path "up until now", and you have some options.
09:28:58 <quicksilver> you pursue each of those options appending one thing to the path
09:29:02 <quicksilver> well, really that's just trees.
09:29:13 <quicksilver> I'm not immediately seeing a more general family of structures supporting this.
09:29:34 <Saizan_> all ADTs are just trees anyhow :)
09:30:10 <sclv> quicksilver: Well, maybe, but the recursion pattern itself can be more abstracted I mean, not necessarily the underlying structure.
09:30:38 <sclv> You're really working in the zipper comonad, I think.
09:31:23 <sclv> I actually have a piece of code that I'm was working on that does the same thing, but for a more complex case, and was thinking about how to abstract it better, even though its sort of hairy and probably better to leave it lie.
09:32:00 <tusho> hmmmmm
09:32:05 <tusho> haskell irc bots are the new thing now
09:32:08 <tusho> guess i'd better write my own
09:32:10 <sclv> adiM: anyway, my point was that instead of having modifyTree pass around an a, you can have it pass around [Node] which is the list of all previous nodes
09:32:45 <sclv> and instead of an f that is a scanl, you can have an f that turns a [Node] into a single value.
09:32:55 <adiM> sclv: Thanks, I will try that (My actual code is obviously more complicated).
09:32:56 <sclv> which is somewhat more general.
09:33:09 <quicksilver> sclv: which you then optionally condense as a monoid.
09:33:11 <quicksilver> or something.
09:33:34 <sclv> quicksilver: exactly, but you can also do other stuff to it, like take alternate bits of it, or whatever you want.
09:33:39 <quicksilver> yup
09:33:52 <quicksilver> I agree that's a better abstraction of this lgorithm
09:33:58 <quicksilver> I'm not sure it generalises beyond trees though
09:34:15 <quicksilver> although it does generalise to "tree-shaped paths through other structures"
09:34:15 <tusho> hmm
09:34:19 <quicksilver> which is maybe interesting
09:34:21 <tusho> YAHB doesn't roll off the tounge.
09:34:27 <quicksilver> you could run it on the spanning tree of a graph.
09:34:27 <tusho> [yet another haskell bot]
09:34:57 <sclv> and to make it more general you can make the f also take the subtrees, so you really have a function that transforms each node based on the path to it and the path from it. Which is comonadic.
09:35:02 <Tigran`> Yahircb is slightly better.
09:35:22 <sclv> although introducing an actual comonad class would make my head hurt here.
09:35:23 <tusho> Tigran`: but unweildy
09:35:38 <tusho> hm. donswit. maule. :-P
09:35:44 <tusho> no, wait, that'd be Maule.
09:35:48 <adiM> sclv: For large trees, does carrying around the list of nodes incur a heavy performance penalty? That is would the list have to created multiple times, or is Haskell smart enough to keep the sublists common.
09:35:51 <sclv> quicksilver: I think trees are known to be the free comonad, right, so they're the fullest generalization of this pattern?
09:37:04 <tusho> hehehehe.. I like 'Maule'
09:37:10 <sclv> adiM: if you create a list with (x:xs), then you're only adding the cost of the (x:). If you create it with (xs ++ [x]) then you're adding the cost of all the xs again, plus a performance hit for traversing them.
09:37:12 <tusho> or .. lamflex
09:37:25 <chris____> dmwit: yay. http://hpaste.org/8292#a2 works it out in less than a second, hahaha
09:37:32 <vixey> adiM: If you made a tree with fringe [a, b, c], then made a new tree by joining both them together (the fringe would be [a, b, c, a, b, c]) that entire list of the fringe would have to be calculated from the start
09:37:34 <dmwit> =)
09:37:49 <sclv> So the standard pattern for adding to the end of a list is to use a difference list if you're fancy, or if you want to keep it simple, just cons to the front and reverse when you want to take use it.
09:38:06 <vixey> adiM: not both, I meant joining the tree it itself
09:39:12 <adiM> Ok, I will try to generalize this patten, so that I can use a general function on list of nodes.
09:39:19 <sclv> edwardk or ddarius or whatever would probably have my head for my handwavy sorta-understanding of cat theory here.
09:39:29 <cnwdup> Any suggestions why that piece of code sometimes yields Prelude.undefined? http://hpaste.org/8295 Or how I can investage that further is also appreciated.
09:39:56 <vixey> cnwdup: which code?
09:40:12 <cnwdup> vixey: The code being pasted on hpaste. I sent the url.
09:40:33 <vixey> cnwdup: processPlugins, runPlugin, or ..?
09:41:00 <cnwdup> vixey: If I comment out the line put st { plugins = M.fromList pl }, everything works fine. I think the error occurs in runPlugin. Especially in the maybe a id a' part.
09:41:02 <chris____> cheers dmwit, quicksilver.
09:41:49 <cnwdup> But I just can't see what's wrong with that.
09:42:17 <mauke> nothing, except that it can be written as fromMaybe
09:42:46 <cnwdup> mauke: Yeah. That's right.
09:42:57 <bos> @seen dons
09:42:57 <lambdabot> dons is in #arch-haskell, #ghc, #haskell-soc, #xmonad and #haskell. I don't know when dons last spoke.
09:43:09 <mauke> preflex: seen dons
09:43:09 <preflex>  dons was last seen on #haskell 9 hours, 36 minutes and 37 seconds ago, saying: clauses are being removed over time :)
09:43:38 <mauke> @msg #haskell test
09:43:38 <lambdabot> test
09:46:25 <sclv> ?hoogle Calendartime
09:46:26 <lambdabot> System.Time.CalendarTime :: data CalendarTime
09:46:26 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
09:46:26 <lambdabot> System.Time.calendarTimeToString :: CalendarTime -> String
09:46:30 <sclv> ?hoogle clocktime
09:46:30 <lambdabot> System.Time.ClockTime :: data ClockTime
09:46:30 <lambdabot> System.Time.getClockTime :: IO ClockTime
09:46:30 <lambdabot> System.Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
09:46:41 <sclv> I forget -- is system.time old-time or newtime?
09:46:43 <mauke> hammertime
09:47:06 <eu-prleu-peupeu> hello
09:47:13 <sclv> haskell's time libs are such a pain.
09:47:17 <eu-prleu-peupeu> is there any way to produce MSIL code from haskell code ?
09:47:23 <twobitwork> old-time vs newtime?
09:47:26 <sclv> of course they have nothing on java... but i already went through the pain of learning those.
09:47:27 <mauke> % ghc-pkg describe old-time | grep exposed-modules
09:47:27 <mauke> exposed-modules: System.Time
09:47:40 <sclv> bah. HDBC only has old-time instances.
09:48:23 <twobitwork> % cat /etc/issue
09:48:56 <twobitwork> ohh... I was thinking lambdabot was going to respond to that :P
09:50:07 <quicksilver> sclv: good answer. (Tree is the free comonad)
09:50:14 <quicksilver> sclv: I guess that gets to the heart of it.
09:50:28 <sclv> hey, I has a learning curve!
09:51:37 <sclv> These sorts of recursion patterns are actually a nice way of showing how this cat-theory stuff actually matters.
09:52:52 <adiM> sclv, quicksilver: Here is the implementation using node lists. http://hpaste.org/8294#a2 .
09:53:30 <geezusfreeek> adiM: here is a quickie i made: prefixTree (Node r s) = Node r $ map (fmap (mappend r) . prefixTree) s
09:53:34 <geezusfreeek> not very general though
09:54:14 <sclv> adiM: nice.
09:54:15 <bugQ> cat theory, eh?  I can has Freud?
09:54:21 <Begedin> hey all
09:54:25 <Begedin> can i aks for a favor
09:54:38 <Zao> No, but you may ask.
09:54:45 <Begedin> i.ve been trying to download ghc the whole day
09:54:48 <twobitwork> > i can has cheezburger
09:54:49 <lambdabot>   Not in scope: `cheezburger'
09:54:54 <twobitwork> > i can has cheez burger
09:54:54 <Begedin> but im on crappy dialup
09:54:55 <lambdabot>   Not in scope: `burger'
09:55:02 <Begedin> and it keeps disconnecting
09:55:11 <Begedin> the thing is
09:55:15 <twobitwork> I thought that was defined in \bot
09:55:18 <Zao> Begedin: So you want a mirror? And type longer lines :)
09:55:23 <geezusfreeek> @faq i can haz haskl burger?
09:55:23 <lambdabot> The answer is: Yes! Haskell can do that.
09:55:30 <Begedin> no mirror----
09:55:43 <Begedin> i have connection problems regardless of donload
09:56:07 <Zao> Begedin: Doesn't your download manager support resuming then?
09:56:11 <geezusfreeek> Begedin: so you just need a good way to automatically continue the download when your connection comes back up?
09:56:18 <eu-prleu-peupeu> hey guys, is there any way to generate .net code with haskell ?
09:56:24 <Begedin> not really
09:56:29 <geezusfreeek> Begedin: i tend to go for wget if i need reliable downloading
09:56:33 <Begedin> bear with me , this will be a long line
09:56:43 <Zao> eu-prleu-peupeu: Isn't there a reasonably stale Visual Haskell somewhere?
09:56:43 <Begedin> btw i use microsoft :-(
09:56:51 <Zao> Begedin: There's wget ports for windows.
09:57:03 <Begedin> anyway i need to write a simple function for my assignment tomorrow
09:57:09 <Zao> http://users.ugent.be/~bpuype/wget/
09:57:11 <lambdabot> Title: WGET 1.10.2 for Windows (win32)
09:57:13 <sclv> Any recommendations on if its worth it to switch everything to Data.Time or if old-tiime is suitable enough for most purposes?
09:57:18 <eu-prleu-peupeu> Zao: i dont know...
09:57:26 <Begedin> one that returns the number of elements greater than a given number from an integer list
09:57:35 <Begedin> can anyone help me with this
09:57:39 <Begedin> it should be a quickie
09:57:51 <Zao> Begedin: Use length and filter.
09:57:56 <Begedin> this is my first time with haskell or any function language for that mather
09:57:56 <byorgey> Begedin: do you have anything so far?
09:58:07 <Begedin> i have nothing cause i cant download ghc
09:58:10 <Zao> You should be able to look up the signatures of those on hoogle.
09:58:11 <byorgey> Begedin: note you can try things out with lambdabot here, or on codepad.org
09:58:14 <mrd> Begedin: you can use lambdabot to test things
09:58:20 <byorgey> > sum [1,2,5,6]
09:58:21 <lambdabot>  14
09:58:24 <mrd> > length [1,2,3]
09:58:25 <lambdabot>  3
09:58:27 <twobitwork> Begedin: so, you're given a list, and an item, and you need to return all the ones for which (i > n) is True?
09:58:28 <mauke> Begedin: you could get hugs
09:58:37 <geezusfreeek> Begedin: how about http://codepad.org/
09:58:39 <geezusfreeek> :)
09:58:41 <Begedin> and i must be even to
09:59:12 <Begedin> i mean n must be even
09:59:18 <Begedin> im openning codepad.org now
09:59:26 <Begedin> it will take a few minutes :-(
09:59:38 <geezusfreeek> wow you really are on a bad connection then
09:59:46 <Begedin> i think something is broken
09:59:54 <Begedin> cause i get static when talking on the phone
10:00:05 <Begedin> i called my phone provider
10:00:15 <Begedin> but out here it could take a few weeks
10:00:38 <Begedin> still opening
10:00:54 <mrd> > filter even [1 .. 10]
10:00:56 <lambdabot>  [2,4,6,8,10]
10:00:56 <geezusfreeek> please try not to flood the channel
10:01:01 <twobitwork> mrd: shhh
10:01:06 <mrd> you can message lambdabot too
10:01:23 <mauke> can you use torrents?
10:01:30 <Begedin> anyway to put it short, i need a function that returns the number of even elements greater than the parameter from an integer list
10:01:37 <Begedin> and i cant use built in functions
10:01:41 <Begedin> only my own helper functions
10:01:43 <twobitwork> no built-ins?
10:01:47 <geezusfreeek> Begedin: umm, any built in functions?
10:01:53 <Zao> I assume you're allowed to use (>) :)
10:01:55 <Begedin> wait let me check
10:01:55 <geezusfreeek> that is probably nearly impossible to avoid
10:02:05 <sclv> > No instance for (Typeable CalendarTime)
10:02:05 <lambdabot>  Parse error at "insta..." (column 4)
10:02:08 <Begedin> yeah, those are allowed :-)
10:02:08 <sclv> gah!
10:02:18 <Zao> Otherwise it's Peano time :)
10:02:19 <Toxaris> Begedin: you cannot use integer without using builtin functions
10:02:22 <tusho> why is #haskell now #domyhomeworkforme :(
10:02:26 <Begedin> but nothing fromy any "aditional libraries" :-)
10:02:28 <mauke> just write your own number type
10:02:39 <Zao> tusho: It's "hint people into getting started"
10:02:48 <sclv> wai basic data types not having basic instances!?
10:02:54 <cnwdup> begedin: Prelude isn't aditional, is it?
10:02:54 <Zao> I wonder if the Prelude is considered "additional"
10:02:56 <mrd> no one's doing his homework.  we're trying to help him get access to a haskell interpreter.
10:02:58 <tusho> Zao: but that's not how they specify their questions!
10:03:02 <Tigran`> Peano is archaic
10:03:05 <Tigran`> You need triano
10:03:13 <Zao> tusho: Fuzzy matching.
10:03:21 <Begedin> you got me in the dark here
10:03:21 <Tigran`> data Triano = Zero | S Triano | FourtySeven
10:03:29 <tusho> Zao: i guess so, they could just ask their questions better
10:03:34 <Begedin> i dont know what prelude is cause i havent used haskell at all
10:03:36 <Zao> I assume the intent of the assignment is to introduce recursion and pattern matchning, not filter.
10:03:45 <Begedin> it just something our proffesor tought of randomly
10:03:48 <tusho> I imagine so, zao.
10:03:56 <Zao> Begedin: So you have an assignment due tomorrow and you haven't paid any attention in class?
10:03:56 <Begedin> like "hey, write something in lets say haskell"
10:04:01 <twobitwork> Begedin: you're in a class which is asking you to do an assignment in haskell, but they haven't taught you any haskell?
10:04:06 <geezusfreeek> my only complaint about homework problems in here is that it seems to take the joy out of using haskell. most of the homework questions are from people that are only learning haskell to get the grade, not for any intellectually stimulating reason
10:04:07 <Begedin> yep
10:04:28 <Begedin> its called "programming paradigmes and languages"
10:04:33 <Zao> geezusfreeek: I'm doing Euler problems at the moment and ask annoying questions, do I count?
10:04:34 <Begedin> so its pretty random
10:04:36 <quicksilver> I would imagine the purpose of the question is to force you to install a haskell implementation and find a simple tutorial.
10:04:52 <quicksilver> I.e. it's an initiative test to get you going.
10:04:52 <Toxaris> Begedin: prelude is the non-additional library which contains both very basic things like the > operator and somewhat advanced things like everything you need to solve your problem in a single line of code
10:04:59 <Begedin> yes it is, and i would have done that ages ago, if my connection wasnt killing me
10:05:06 <geezusfreeek> Zao: the key part is that you are doing it for the enjoyment and learning experience
10:05:07 <Deewiant> Zao: Euler is intellectually stimulating unless you're doing it because your teacher/professor is forcing you to :-P
10:05:13 <Toxaris> Begedin: it is always available without importing anything, so it's not an additional library.
10:05:18 <Zao> Begedin: I assume you do not have access to any unix system with a working GHC?
10:05:26 <Begedin> he said to use ghc, so if it uses prelude, i quess prelude is allowed
10:05:34 <Begedin> nope
10:05:49 <Zao> Deewiant: I find it stimulating to construct as naive solutions as possible :)
10:05:49 <Begedin> all i have is vista :( and 36.6k dialup
10:06:03 <Begedin> btw codepad.org timed out again - that happens these days
10:06:17 <Deewiant> Zao: and watch them run for weeks on end? ;-)
10:06:18 <geezusfreeek> Begedin: codepad will not be a good option for you if you can't load the page
10:06:24 <geezusfreeek> to use it would require loading it many many times
10:06:27 <Begedin> i think nothing is a good option
10:06:55 <Begedin> how long is the solution of the problem i have? in term of lines?
10:07:01 <cnwdup> begedin: 1
10:07:02 <mauke> Begedin: does bittorrent work for you?
10:07:08 <Toxaris> Begedin: there used to be a hugs distribution with "only" 1.4 MB download size
10:07:09 <Begedin> nothing works for me
10:07:11 <Zao> Begedin: Depends on verbosity and solution, but less than 10.
10:07:14 <Begedin> im getting desperate
10:07:16 <mauke> Begedin: IRC does
10:07:20 <Tigran`> Begedin: Use lambdabot through private message
10:07:20 <Begedin> o yeah
10:07:24 <Begedin> however
10:07:40 <Begedin> im getting like 5 or 6 lines of thxt at once every 20 seconds or so
10:07:54 <Begedin> so that doesnt work to good either
10:08:01 <geezusfreeek> Begedin: i would suggest traveling to a place that has better internet
10:08:06 <Begedin> yeah
10:08:10 <Begedin> good luck with that
10:08:21 <twobitwork> codepad doesn't seem to like [1..10]
10:08:27 <geezusfreeek> i assume this is for a university course?
10:08:30 <Begedin> the problem is i need to turn in a print of the solution by tomorrow
10:08:31 <Begedin> yep
10:08:40 <Begedin> just the printed solution, nothing else
10:08:40 <geezusfreeek> twobitwork: codepad does full source files only, i think
10:08:55 <geezusfreeek> Begedin: you can't just use a lab computer there?
10:08:59 <Zao> Lambdabot sounds like the best solution.
10:09:05 <Tigran`> Does your university not provide unix machines or something you can ssh into?
10:09:18 <Begedin> someone is sendimg mi something thats blocked, wait for me to unblock it
10:09:30 <Begedin> i missed the extension, what is it?
10:09:36 <rawicki> Hello. Is anyone using Debian here?
10:09:43 <mauke> Begedin: that was me
10:09:43 <Zao> rawicki: Likely.
10:09:55 <geezusfreeek> twobitwork: http://codepad.org/6TNb37z1
10:09:56 <rawicki> When I'm trying to import Control.Monad.Error into my programs I'm getting linker error.
10:10:09 <twobitwork> geezusfreeek: ahh
10:10:09 <rawicki> I wonder if any package on my computer is missing, but I wasn't be able to localize it in the repository.
10:10:12 <int-e> rawicki: use ghc --make or ghc -package mtl
10:10:14 <Zao> Time to boot the debian VM then.
10:10:35 <mauke> Begedin: it's a minimal hugs package for windows
10:10:40 <rawicki> int-e: thanks!
10:10:47 <Begedin> oh.
10:10:52 <Begedin> you can try again mauke
10:11:00 <Begedin> but i doubt i will be able to receive it
10:11:07 <Begedin> cause im constantly getting timeouts
10:11:14 <cnwdup> func :: Plugin -> IRC (Maybe Plugin), *can* it be that this function does not return a valid Maybe type sind Plugin is an existential type?
10:11:23 <cnwdup> begedin: Why are you not trying it with lambdabot?
10:11:43 <byorgey> rawicki: if you don't have the mtl, you may need to install libghc6-mtl-dev
10:12:00 <cnwdup> s/sind/since/
10:12:08 <Begedin> cause i pretty much cant acces anything besided irc
10:12:13 <Begedin> everything timeouts
10:12:18 <Begedin> i havent tried telnet :-)
10:12:22 <cnwdup> begedin: Yeah. So you can use lambdabot via IRC.
10:12:25 <Tigran`> ./q lambdabot > 1 + 1
10:12:27 <twobitwork> > print "use me"
10:12:27 <chr1s> dons: are there any more packages going to be released anytime soon from Galois?
10:12:28 <lambdabot>  <IO ()>
10:12:33 <twobitwork> er... :P
10:12:35 <Begedin> i didnt know that works
10:12:43 <Tigran`> > "Use me."
10:12:45 <lambdabot>  "Use me."
10:12:45 <cnwdup> Type > followed by a haskell expression.
10:12:49 <cnwdup> > 1+1
10:12:50 <lambdabot>  2
10:12:59 <cnwdup> Lambdabot will evaluate that giving you the result.
10:13:02 <dons> chr1s: one for opml.
10:13:09 <cnwdup> You can toy around with possible solutions for your program that way.
10:13:10 <Begedin> ./ lambdadot > 1 + 1
10:13:12 <dons> maybe webdav if someone complains a lot
10:13:17 <Begedin> ./q lambdadot > 1 + 1
10:13:18 <cnwdup> Use > instead oder ./, begedin.
10:13:22 <Begedin> oh
10:13:25 <cnwdup> Or open a query.
10:13:26 <chr1s> dons: nice!
10:13:36 <Begedin> ./> lambdadot > 1 + 1
10:13:36 <Tigran`> Remove the "."; Begedin
10:13:37 <chr1s> dons: do you guys also have a database library?
10:13:39 <Begedin> oh
10:13:40 <Begedin> lol
10:13:41 <Begedin> sorry
10:13:44 <Begedin> im new to this
10:13:53 <chr1s> because I still feel that's something that's really lacking in Haskell
10:13:54 <dons> chr1s: the sqlite one on hackage
10:14:02 <wjt> Begedin: enter the command '/q lambdabot > 1 + 1' to send the message '> 1 + 1' to the user 'lambdabot' in a new window
10:14:03 <chr1s> a database-library on a higher level
10:14:03 <Begedin> > lambdadot > 1 + 1
10:14:04 <lambdabot>   Not in scope: `lambdadot'
10:14:12 <dons> no, not releasable anyway
10:14:15 <cnwdup> begedin: Just > 1+1
10:14:16 <dons> hdbc is ok for this.
10:14:20 <dons> takusen's also very high level
10:14:22 <Begedin> > 1 + 1
10:14:23 <lambdabot>  2
10:14:27 <Zao> Huzzah!
10:14:28 <cnwdup> begedin: But as you're going to write many messages to lambdabot, please open a query.
10:14:30 <Begedin> now im getting it
10:14:33 <Begedin> however
10:14:34 <cnwdup> /query lambdabot
10:14:35 <Tigran`> By George, I think he's got it!
10:14:40 <Begedin> this doesnt change the fact
10:14:40 <dcoutts_> dons: is it? I thought it was just SQL strings
10:14:43 <cnwdup> Then you can write those "> " expressions tere.
10:14:46 <cnwdup> begedin: Which fact?
10:14:48 <adiM> sclv: found a zipper for Data.Tree http://code.haskell.org/yi/Data/Tree/Zipper.hs Does not exactly implement what I want, but it is an interesting direction.
10:14:49 <dons> dcoutts_: well, it's typed.
10:14:50 <chr1s> I think so too
10:14:54 <Begedin> that i dont know anything about haskell or any function language for that mather
10:15:08 <geezusfreeek> i think HaskellDB is the DSL, right?
10:15:13 <chr1s> HaskellDB is more like what I mean, but that's virtually impossible to compile
10:15:14 <Begedin> and i cant really acces any online tutorials
10:15:17 <Deewiant> one would assume they taught you something during the course
10:15:25 <dons> dcoutts_: are there general traversals for CondTree's  in cabal?
10:15:33 <mauke> Begedin: then you're screwed
10:15:35 <dons> say, i want to pull out all required haskell and C deps from a .cabal ?
10:15:39 <dcoutts_> dons: some, but not exposed it seems
10:15:42 <Begedin> im telling you, nothing
10:15:47 <geezusfreeek> Begedin: is it unreasonable to use a lab computer?
10:15:50 <Begedin> it was like 10 minutes of basic lambda calculus
10:15:52 <dons> dcoutts_: so best to walk it by hand?
10:15:56 <Begedin> and then we moved on to xml schema
10:16:00 <Begedin> for about half an hour
10:16:06 <Begedin> and ended the class with xaml
10:16:15 <dcoutts_> dons: well, it depends what you really mean. What does it mean to get "all required haskell and C deps"
10:16:15 <dons> dcoutts_: fwiw, http://code.haskell.org/~dons/code/cabal2arch/Main.hs
10:16:21 <Deewiant> and you have haskell homework based on just that lesson? O_o
10:16:24 <Begedin> its like all a bunch of theory form different areas of programming
10:16:38 <Begedin> jep
10:16:42 <Begedin> i know its stupid
10:16:47 <dons> well, i want to get all build-depends that are on if the default flags are True
10:16:50 <dcoutts_> dons: since you're making a specific binary package then you probably want to pick a specific set of configuration flags
10:17:08 <Begedin> thats why i was hoping that the function i need is something simple that someone here could help me solve in a short time
10:17:12 <Begedin> but i guess its not
10:17:14 <geezusfreeek> Begedin: if that is true then i would drop the course if i could still get my money back and not have it show on transcript at this point
10:17:16 <dcoutts_> dons: but you don't want the default True flags, you want the right flags to make it work
10:17:30 <dcoutts_> dons: so you want to use finalisePackageDescription
10:17:39 <dons> oh, interesting.
10:17:45 <Begedin> to late for that, this is the end of the course, the first half was actually usefull
10:17:45 <geezusfreeek> Begedin: it is, but we can't just teach you haskell from scratch here, and we certainly will not do your homework for you :(
10:17:55 <dcoutts_> dons: and for it to make a sensible decision it wants to know what other packages you expect to have available
10:17:58 <geezusfreeek> Begedin: oh, i was under the impression somehow that this was the beginning of it
10:17:59 <dons> do you know how "automatic" the other cabal 2 native conversion tools arE?
10:18:21 <dcoutts_> dons: you mean the cabal-rpm and debian and gentoo ones?
10:18:21 <dons> are there any that can handle a good percent of the packages on hackage, including ones with multiple stanzas ?
10:18:25 <dons> yeah
10:18:28 <geezusfreeek> Begedin: you still have not answered my question about using a lab computer
10:18:36 <Begedin> i understand you wont do my homework, and im not asking that, as i said i was just hoping its somethins simple
10:18:43 <dcoutts_> dons: I had this discussion about finalisePackageDescription with bos the other day
10:18:50 <dons> ok. i'll check that
10:18:52 <Begedin> currently my lab computer is about 30 miles away from me
10:18:53 <dcoutts_> dons: so I suspect cabal-rpm is doing it right now
10:18:57 <bos> we who what?
10:19:02 <Begedin> i travel to college every day
10:19:05 <geezusfreeek> Begedin: i think a 30 mile drive would be worth it
10:19:10 <bos> oh.
10:19:18 <Begedin> i dont think so
10:19:22 <dcoutts_> dons: and the gentoo one is right I think, but it's source based so we don't need to pick a specific configuration at the time we generate a native package description
10:19:28 <Begedin> since its like just a 1% of my grade
10:19:28 <geezusfreeek> Begedin: hey, it's your grade
10:19:38 <Begedin> not even worth the gas money
10:19:52 <geezusfreeek> i'd just give up then with such a screwy connection ;)
10:19:59 <Begedin> i probalby will to
10:20:05 <dcoutts_> dons: see the issue is that to know what configuration to pick we need to know what other packages (inc versions) are available
10:20:10 <Begedin> i just need to bitch about it for a while :-)
10:20:12 <sclv_> I've given up far more with less cause :-)
10:20:18 <dons> dcoutts_: yeah, at least I know.
10:20:26 <geezusfreeek> Begedin: in #haskell-blah i hope ;)
10:20:46 <Zao> I'm out of channels, I can't join -blah :(
10:20:50 <dcoutts_> dons: so in your case we want to know the full set of packages that you intend to package for arch, then those are the available ones and finalisePackageDescription can figure out a configuration that works.
10:21:03 <dons> hmm.
10:21:27 <dcoutts_> dons: obviously technically we don't need to know all of them, but we'd like to know for all the ones this package could ever depend on what versions are available
10:21:33 <dons> yep
10:21:59 <dcoutts_> dons: and you can find out all the ones it could ever possibly depend on using flattenPackageDescription
10:22:08 <dons> mm. cool
10:22:17 <chr1s> does anybody now if there is an IMAP package available for Haskell?
10:22:17 <dcoutts_> since that collapses each side of conditionals
10:22:50 <chr1s> one that actually works?
10:22:54 <dcoutts_> dons: but do not use the result of flattenPackageDescription as if it were a valid configuration because it's not. It includes things which may actually be mutually exclusive.
10:23:04 <dons> ok
10:23:12 <dcoutts_> dons: it's the union of everything
10:23:31 <dcoutts_> dons: so probably you do not need any other functions for traversing cond trees
10:23:50 <laz0r> anyone in here experienced with using opengl vbos together with interleaved vertex arrays?
10:23:50 <dons> so this is the current state of things, if i point it at a .cabal in a directory or on the web, http://hpaste.org/8297
10:24:21 <dons> the main left overs now are extracting the right haskell and C dependencies, and not generating the register hooks for executable-only installs
10:24:44 <dcoutts_> dons: looks ok, you'll want to translate the license names to the native names, nobody uses BSD3 as the real name
10:24:48 <dons> is the --gen-script still the preferred mechanism for post-install registering?
10:25:09 <dcoutts_> dons: depends on who you talk to. I wouldn't use it but apparently Igloo would.
10:25:19 <dons> what's the alternative?
10:25:43 <dons> oh, also note md5s and shas would be useful on hackage :)
10:25:56 <dcoutts_> aye
10:26:16 <dcoutts_> dons: you can generate the ghc package registration files and call ghc-pkg register
10:26:24 <dons> oh, by hand?
10:26:28 <dcoutts_> right
10:26:42 <dcoutts_> personally I think it's simpler and safer
10:26:53 <laz0r> quicksilver: you there? you once told me you had a working vbo implementation in haskell that you could show me; did you use interleaved arrays by any chance?
10:27:25 <dcoutts_> dons: so for C libs you want to look at the extra-libraries: field and find the corresponding arch packages that provide those C lib names
10:27:34 <geezusfreeek> i prefer the --gen-script method
10:27:36 <dons> yep
10:28:03 <dcoutts_> dons: like "extra-libraries: z" -> /usr/lib/libz.so -> zlib arch package
10:28:20 <dons> yeah. i might be able to compute them, or else keep a cache of names
10:28:38 <dcoutts_> if you can query the package manager to find the name of a package the provides a file
10:28:48 <dons> yeah, that's a good idea.
10:29:04 <dcoutts_> so I suggest going via the actual file name /usr/lib/libz.so
10:29:33 <dcoutts_> which means doing the same search that the linker does
10:29:38 <dons> bos, does your rpm tool handle cabal files with multiple executable and library stanzas?
10:29:43 <dons> dcoutts_: yeah, good idea.
10:29:48 <dons> i'll find out how to do that on arch
10:30:01 <dcoutts_> dons: there really should be code we can share on this
10:30:09 <dcoutts_> dons: like the C lib name search
10:30:14 <dons> yeah.
10:30:23 <dons> computing the "default" dependencies
10:30:26 <RayNbow> are there any indepth resources about quantifiers/existential types? (I've read the hawiki, but I still don't quite grok the \forall <--> \exists equivalence)
10:30:29 <dcoutts_> dons: the distro-specific bit is FilePath -> NaitivePackageName
10:30:36 <dons> parsing. generating the register hooks
10:30:44 <bos> dons: i think so. those packages are rare, so i haven't covered that terribly heavily.
10:30:58 <mauke> RayNbow: me neither, but I know how to use it :-)
10:30:59 <dons> ok. cool.
10:31:01 <dcoutts_> dons: I think the debian people do handle it
10:31:21 <dons> yeah, seems not too hard.
10:31:21 <dcoutts_> dons: for gentoo we just make one package rather than splitting them out
10:31:25 <RayNbow> mauke: yeah, I understand how to use it... but I'd to get a better understanding :)
10:31:26 <dons> just have to query the CondTree
10:31:36 <dons> right, i want to have one package per cabal file
10:31:47 <dons> each logical hackage unit should correspond to a single arch package
10:31:49 <dcoutts_> dons: no :-) just have to look at the PackageDescription, no need to look at the cond tree
10:32:18 <dcoutts_> dons: after you've finalised the thing you get a PackageDescription which has Maybe Library and [Executable]
10:32:19 <RayNbow> http://citeseer.ist.psu.edu/kieburtz99codata.html <-- this paper slightly touches on the existential types
10:32:19 <lambdabot> Title: Codata and Comonads in Haskell - Kieburtz (ResearchIndex)
10:32:31 <dons> right, so the key is to finalise it eh?
10:32:35 <dcoutts_> yes
10:32:43 <dons> ok. i'll look at that.
10:33:10 <RayNbow> (page 3, left column)
10:33:29 <dcoutts_> dons: if you supply a package index then if finalise works then you know the thing can actually be configured
10:33:46 <dons> right, so we just need an index of available packages.
10:33:51 <dcoutts_> dons: if you supply Nothing for the package index then it just assumes that everything is available
10:33:57 <dons> ok. cool
10:34:11 <dcoutts_> but that obviously gives you the wrong results since not everything is available
10:34:30 <dcoutts_> like base-2.0 :-)
10:34:46 <dons> it's a start though.
10:34:55 <dons> now, you're just not allowed to change any apis
10:35:12 <dcoutts_> hah
10:35:31 <dcoutts_> dons: depend on Cabal >= 1.4 && < 1.5 and you'll be ok
10:35:37 <dons> am i using anything dodgy in  http://code.haskell.org/~dons/code/cabal2arch/Main.hs
10:35:53 <dons> i've Cabal >= 1.3.11 currently, fwiw
10:36:07 <dcoutts_> dons: ok, just put the upper bound on too
10:36:11 <dcoutts_> or it will break
10:36:16 <dons> ok.
10:39:46 <bos> this mapreduce example is turning out nicely. i can get 1.8x speedups on my dual core laptop.
10:40:18 <dcoutts_> dons: btw, you should be able to use the die from the Cabal lib
10:40:47 <bos> heh, there's no instance of NFData for ByteStrings.
10:40:49 <dcoutts_> dons: and the process reading code
10:40:53 <chr1s> bos: you are doing mapreduce in haskell?
10:41:11 <bos> chr1s: yep, not the big googly distributed kind, just an example for the book.
10:41:33 <bos> chr1s: but the point is that it's easy to write and gives good performance.
10:41:36 <seanmce> dons: how did you find out about the Ruby Code Jam? You put that in the events right?
10:41:39 <chr1s> nice!
10:41:47 <tusho> do any members of le haskell community object to using git for a vcs?
10:41:52 <tusho> i know you all love darcs; but i like git.
10:41:55 <dcoutts_> dons: and perhaps withTempDirectory might mean you don't need to call mktmp at all
10:41:56 <chr1s> bos: I was just trying to locate the latest version of the book, is it still online?
10:41:56 <dons> seanmce: yeah, came up in my rss feed
10:41:58 <tusho> will it reduce the people who want to contribute?
10:41:59 * cjb uses git.
10:42:04 <bos> chr1s: sure is.
10:42:18 <dons> bos, a null instance should be ok
10:42:25 <bos> dons: i know, yeah.
10:42:27 <chr1s> at book.realworldhaskell.org? that hostname seems to be broken here, but maybe that's just me.
10:42:33 <dons> tusho: git is also nice
10:42:44 <dons> dcoutts_: ok. good advice.
10:42:52 <dons> chr1s: server upgrades, iirc
10:42:53 <seanmce> just curious, I was supriesed to see it last night during the discussion.
10:42:58 <dons> :)
10:43:03 <tusho> dons: yeah, I'm just worried about people going "gah, why do you use git why not darcs :(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((99999999999999999(("
10:43:11 <dons> seanmce: oh, it came up live during the talk?
10:43:35 <seanmce> dons: yes, I went to the haskell.org homepage and there it was.
10:43:41 <dons> tusho: some haskell things are in git, it's not illegal :)
10:43:44 <dons> seanmce: awesome :)
10:43:52 <tusho> dons: i've seen people complain before is all
10:44:01 <dcoutts_> dons: something we do in hackport is if the user asks for "foo" rather than http://blah/foo.cabal then we look up foo in the hackage package index.
10:44:03 <tusho> specifically, if it'll decrease the people willing to contribute to it in a big way, that'd be bad
10:44:05 <dons> hpaste.org is hosted in git, fwiw
10:44:19 <tusho> (contribute to it in a big way), not (decrease people willing to (...) in a big way)
10:44:25 <dons> dcoutts_: ah ok. so i want to do that too
10:44:27 <tusho> (just making sure you all parsed that right.)
10:44:27 <dcoutts_> dons: so you may like to borrow the code from hackport that manages the hackage package index.
10:44:29 <dons> handle local packages, and remote ones
10:44:35 <bos> we should build a twitter in haskell. the performance problems they're having are utterly baffling.
10:44:47 <dons> bos, hehe. its a source of much amusement here
10:44:55 <Zao> It's Ruby, isn't it?
10:44:56 <dcoutts_> dons: in fact we have code to diff a local native package archive with hackage so we can see which packages we're missing or are out of date.
10:45:02 <matthew-_> there's just been a large thread on erlang-questions about an open source twitter replacement
10:45:08 <bos> Zao: it's this awful combination of rails and jabber.
10:45:16 <tusho> a twitter clone is interesting, I might give that a try sometime.
10:45:18 <Zao> eeee
10:45:35 <dons> bos, did you see agl's ObfuscatedTCP kernel patches? (do you know agl?)
10:45:51 <BMeph> Wasn't a twitter-esque project mentioned in the HWN?
10:45:55 <dcoutts_> dons: mm, in fact there does end up with a lot of infrastructure that we should be able to share between the various cabal->native package converters
10:45:56 <dons> i was surprised to see that, but he is a kickarse haskell network hacker too, so i guess not too surprising
10:46:01 <bos> dons: don't know if i know agl, but i was aware of the patches.
10:46:19 <dons> adam langely (binary-strict, minihttp, network-* et al)
10:46:26 <bos> oh, right.
10:46:28 <dons> wrote the bitsyntax library on hackage
10:46:31 <bos> yes, adam's sharp.
10:46:50 <tusho> Hmm. Blohsom was a good name when it was a blosxom clone, but now I'm thinking more of a hobix clone (hobix is a clone + rethink of blosxom though... but it's sufficiently seperate so)
10:46:53 <dcoutts_> dons: ok, that's it for my code review for the moment :-)
10:46:58 * tusho ponders
10:46:58 <matthew-_> bos: he's ex imperial
10:47:02 <dons> ok. great, dcoutts_. lots of good stuff
10:47:03 <matthew-_> I was at college with him
10:47:09 <dons> matthew-_: ah, so he'd know ross too?
10:47:14 <matthew-_> no
10:47:17 <matthew-_> ross is as city
10:47:18 <dons> oh no. ross was at city college
10:47:35 <dons> matthew-_: agl is at google now?
10:47:38 <matthew-_> yep
10:47:41 <matthew-_> .la
10:47:53 <matthew-_> runs imperialviolet.org
10:47:55 <bos> i found myself wanting a bytestring unsnoc this morning.
10:48:08 <dons> we should have recruited him, ah well
10:48:09 <dcoutts_> bos: ah, like uncons but from the back?
10:48:13 <bos> right.
10:48:17 <dons> heh. unsnoc eh
10:48:21 <ziman> does hGetContents automatically close files when it's no longer needed?
10:48:26 <bos> ziman: eventually.
10:48:27 <quicksilver> Woo. A DSL for rendering shiny metallica networks of pipes.
10:48:37 <quicksilver> I bet that's not a very common sort of DSL.
10:48:41 <dcoutts_> ziman: and if you consume all the input then it closes immediately.
10:48:45 <dons> quicksilver: :)
10:48:48 <quicksilver> s/metallica/metallic/
10:48:52 <ziman> bos, dcoutts_, thanks
10:48:54 <quicksilver> although I wonder what the other would mean.
10:49:12 <tusho> who wants to name it ;)
10:50:07 <geezusfreeek> the internet is a series of metallica pipes
10:50:51 <quicksilver> http://roobarb.jellybean.co.uk/~jules/Picture%20140.png
10:51:17 <Japsu> no, some of them are plastic
10:51:33 <Japsu> or polycarbonate
10:51:38 <dons> quicksilver: cute
10:52:48 <cnwdup> Could [(k, Plugin)] wich plugin being a existential type provoke crashing the program with Prelude.undefined? I am still looking for my Maybe error and have no clue.
10:53:10 <byorgey> quicksilver: that sounds... useful ;)
10:53:27 <quicksilver> byorgey: ;)
10:54:22 <laz0r> quicksilver: did you get my message? could i take a look at your haskell vbo implementation?
10:55:02 <quicksilver> cnwdup: Prelude.undefined only comes from use of 'undefined'.
10:55:10 <quicksilver> byorgey: "useful" is such a relative concept, don't you think?
10:55:21 <byorgey> quicksilver: indeed!
10:55:32 <cnwdup> quicksilver: Well, I haven't ever used undefined. \-: Still I get the error when I check with fromMaybe against the type Maybe Plugin.
10:56:08 <quicksilver> cnwdup: you must be using a (buggy) library with "undefined" in. Or something is very odd.
10:56:23 <quicksilver> error: Prelude.undefined can only come from that one source
10:56:31 <quicksilver> laz0r: no, I didn't. Yes, you can.
10:56:49 <quicksilver> laz0r: I didn' tuse interleaved arrays, though
10:56:49 <dcoutts_> bos, dons: do you think it'd make any sense to have a single shared program cabal2native or whatever that just has different modes for the different package systems. It'd be one way of sharing/saving work.
10:56:51 <cnwdup> quicksilver: Might is be triggered by weird type conversion which aren't detected at compile time or something? I am using only standard libraries, I think.
10:56:59 <quicksilver> laz0r: they're deprecated as far as I know.
10:57:12 <cnwdup> quicksilver: Do you have an idea how I can investigate this further? I *really* want to get rid of this error as I can't even find a work-around.
10:57:23 <quicksilver> laz0r: ah well it depends what you meant, actually :)
10:57:34 <quicksilver> laz0r: interleaving with strides is encouraged.
10:57:41 <quicksilver> glInterleavedArrays is deprecated.
10:57:50 <quicksilver> (because it doesn't support multiple tex coords and stuff)
10:57:53 <bos> dcoutts_: it might do. there's certainly a lot of common needed functionality.
10:58:03 <laz0r> quicksilver: deprecated? they seemed to be the most elegant way to handle all these array pointers
10:58:04 <quicksilver> laz0r: but anyway, no, I didn't. I used separate VBOs I think.
10:58:15 <quicksilver> laz0r: yes, I mis-spoke somewhat.
10:58:28 <quicksilver> the notion of interleaving is OK. glInterleavedArrays with its fixed setup options is.
10:58:34 <quicksilver> ..deprecated.
10:58:50 <bos> i wish ghci didn't randomly misbehave at times.
10:58:59 <quicksilver> cnwdup: 'undefined = error "Prelude.undefined"' is literally part of the prelude
10:59:09 <quicksilver> cnwdup: its' not (supposed) to be possible to get that error any other way.
10:59:13 <laz0r> i use one seperate vbo for every object, but I specify my vertices, the normals and the texcoords as one big list
10:59:18 <dcoutts_> bos: eg each distro has a notion of a native package and a notion of a collection of packages. There's common stuff in managing the hackage index and comparing the native and hackage archives to see what is out of date.
10:59:19 <quicksilver> cnwdup: are you sure it doesn't exist anywhere in your code?
10:59:38 <cnwdup> quicksilver: I have never ever written undefined in my source. I'll run grep over it, though. But I am pretty sure.
10:59:39 <laz0r> which i upload into a vbo, then i try to draw that
10:59:41 <dcoutts_> bos: and it'd make it easier for us to keep an eye on what each other are doing and do code review.
11:00:07 * quicksilver tries to remember hwat hpaste's limits are
11:00:08 <dcoutts_> bos: and for upstream cabal devs to submit patches to make it work when cabal changes.
11:00:27 <bos> dcoutts_: right.
11:00:33 <cnwdup> quicksilver: Nope. I only have used it once in a commect, commenting that actual error.
11:01:30 <quicksilver> laz0r: pastedmy code. what part fails for you though?
11:01:34 <quicksilver> cnwdup: paste maybe?
11:01:40 <quicksilver> cnwdup: http://hpaste.org/8298
11:01:50 <quicksilver> eh
11:01:52 <cnwdup> quicksilver: I'll try to isolate the program and past the code then.
11:01:57 <laz0r> when i just create a list that consists only of Vertex3's, then everything is fine, but as soon as i change that to be only three GLfloats, only weird stuff gets drawn
11:01:58 <quicksilver> that paste was for laz0r : http://hpaste.org/8298
11:01:58 <quicksilver> ;)
11:02:32 <quicksilver> why would you wish to use GLfloats not Vertex3s?
11:02:34 <byorgey> cnwdup: see if you can pare your code down to the smallest possible example which still exhibits the behavior you're seeing
11:02:45 <cnwdup> byorgey: Jep. I am trying.
11:03:02 <laz0r> which makes wonder, because the example (VArray.hs) explicitly states that i should be able to create an array that only consists of GLfloats
11:03:16 <laz0r> quicksilver: thanks, i'll take a look
11:03:35 <quicksilver> laz0r: sounds like you're miscalculating the stride or element size or something.
11:03:55 <dons> dcoutts_, Igloo, can either of you create new lists on haskell.org's mailman?
11:04:00 <dons> seems my perms aren't quite up to it.
11:04:12 <laz0r> i thought so too, but i checked, and even tried other values
11:04:12 <dcoutts_> dons: I've never tried so probably not
11:04:40 <laz0r> and the thing works as long as i use a list of Vertex3
11:05:14 <dons> dcoutts_: what did you say flattenPackageDescription is good for?
11:05:35 <dcoutts_> dons: finding out anything the package could ever possibly depend on
11:05:44 <dons> ah, all possible options, i see.
11:05:53 <dons> i suppose that's a safe default.
11:06:08 <dons> you just can't require them all :)
11:06:15 <dcoutts_> dons: it's not a valid configuration though
11:06:39 <dcoutts_> if condition; build-depends: foo > 1; else; build-depends: foo < 1
11:07:00 <dcoutts_> dons: on that condition, flatten would give us: build-depends: foo > 1, foo < 1
11:07:04 <dcoutts_> which is obviously impossible
11:08:08 <quicksilver> laz0r: supposeing 3 v-coords, 3 n-coords and 2 t-coords, I think it shuold be VertexArrayDescriptor 3 Float (8 * fromIntegral (sizeOf 0::GLfloat)) nullPtr
11:08:11 <quicksilver> for the vertices
11:08:58 <dcoutts_> dons: so as you can see it's suitable for checking if the package might possibly depend on foo >1 but as a configuration it is unsatisfiable and invalid in the sense that no flag assignment gives that configuration.
11:09:00 <quicksilver> VertexArrayDescriptor 3 Float (8 * fromIntegral (sizeOf 0::GLfloat)) (nullPtr `plusPtr` 3) for the norms
11:09:12 <quicksilver> gah
11:09:18 <quicksilver> not 3 at the end there.
11:09:28 <quicksilver> (3 * sizeOf (0::Glfloat))
11:10:21 <laz0r> quicksilver: i used interleavedArrays T2fN3fV3f 0
11:10:24 <quicksilver> laz0	is that eanything like what you tried?
11:10:34 <dcoutts_> dons: so if you're looking for a first approximation, use flatten with Nothing for the package index.
11:10:44 <quicksilver> laz0r: Hmm I don't believe interleaveArrays is supposed to work with VBOs.
11:10:50 <quicksilver> I know it's deprecated with them.
11:10:52 <laz0r> mmh
11:11:07 <laz0r> ok, then that would explain why it fails
11:11:10 <quicksilver> I think you're supposed to call arrayPointer 3 times
11:11:18 <laz0r> i'll try to setup my pointers manually....
11:11:29 <quicksilver> (but they can all be offests into the same VBO that's fine)
11:11:47 <quicksilver> interleaving is allowed, just not specifically using the call.
11:13:22 <mapreduce> bos: Apparently you're doing me in Haskell.
11:13:48 <bos> mapreduce: it's all pure. i promise it won't hurt.
11:14:16 <mmorrow> omggo: http://decodeunicode.org/en/mathematical_operators
11:14:18 <lambdabot> Title: decodeunicode.org . Unicode Blocks . Mathematical Operators
11:14:36 <cjb> mmorrow: my kingdom for a lambda..
11:14:39 <mmorrow> http://decodeunicode.org/en/arrows
11:14:40 <lambdabot> Title: decodeunicode.org . Unicode Blocks . Arrows
11:14:48 <mmorrow> cjb: heh
11:16:38 <mmorrow> bos: did you rename to fmapfold??
11:16:44 <mmorrow> mapreduce: :)
11:16:51 <cubix> this works as I expect: sumXY xs ys = sum $ zipWith (*) xs ys  ..but shouldn't I be able to compose it like: sumXY  = sum . zipWith (*)  ..how come the latter isn't accepted?
11:17:26 <Zao> cubix: Spray more parens?
11:17:31 <mapreduce> I have a plan to implement Map/Reduce in JavaScript, put it on a site that many people look at and sell the CPU time.
11:17:32 <mauke> cubix: because if you expand the definition of ., you get \x -> sum (zipWith (*) x)
11:17:59 <Deewiant> @pl \x y -> (sum (zipWith (*) x) y)
11:18:00 <lambdabot> sum . zipWith (*)
11:18:08 <Deewiant> @pl \x y -> sum (zipWith (*) x y)
11:18:08 <lambdabot> (sum .) . zipWith (*)
11:18:09 <mauke> which is the same as \xs ys -> sum (zipWith (*) xs) ys
11:19:07 <cubix> ok, I see now.. thanks
11:19:13 <blsecres> cubix: tried the pointfree application?  useful for looking up stuff like that without coming onto irc to ask lambdabot
11:19:15 <Deewiant> @unpl ((.).(.)) sum (zipWith (*))
11:19:15 <lambdabot> (\ c f -> sum (zipWith (*) c f))
11:19:20 <mmorrow> cjb: teh : http://decodeunicode.org/en/u+03bb
11:19:22 <lambdabot> Title: decodeunicode.org . decode . GREEK SMALL LETTER LAMDA
11:19:43 <cjb> mmorrow: because it's in the Greek alphabet, we can't reserve it as a keyword in GHC
11:19:57 <augustss> We need a second lambda!
11:20:08 <cjb> yeah, math lambda
11:20:16 <cubix> blsecres: no..?
11:21:00 <blsecres> cubix: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
11:21:02 <lambdabot> http://tinyurl.com/6r2qvo
11:21:26 <mmorrow> cjb: oh. never thought about that
11:21:44 <mmorrow> blsecres: lol
11:21:50 <cubix> blsecres: thanks.. I'll check it out..
11:22:47 <mmorrow> blsecres: oh, i thought you were trying to say something about the need for  by posting that link...
11:26:51 <blsecres> nah. although I'd love it if we could use more than just ASCII for identifiers  [1,2,3] or map (  x y -> x  y ) ...
11:27:32 <bos> you can.
11:27:53 <bos> but you can't use  in place of \ because it's a letter.
11:28:07 <animesh1977> anything like R coded in haskell_
11:28:12 <animesh1977> ?
11:28:30 <laz0r> quicksilver: ok, just tried setting up the pointers manually and it didn't fix the problem
11:28:31 <bos> there are various bits of stats packages, but nothing as comprehensive as R.
11:28:54 <animesh1977> which one is most used?
11:29:04 <laz0r> quicksilver: i don't think i have to set the stride to something else than 0, since i store the data consecutivly
11:29:05 <bos> no idea.
11:29:12 <animesh1977> ok
11:29:45 <laz0r> quicksilver: still, i just wanted to thank you again for showing your code, and i think i will eventually figure something out
11:29:57 <Cale> Aside from commercial software, I don't think there's anything like R at all.
11:30:26 <Cale> I could be wrong about that, but I haven't seen anything.
11:30:56 <animesh1977> neither me
11:31:09 <animesh1977> any book on haskell which has algorithmic approach, something like 'algorithms in haskell'
11:31:15 <Cale> In Haskell, there were some libraries a while back for manipulating probability distributions, that would be the closest thing, I suspect.
11:31:21 <tusho> OK, Hobix is a totally dead end. Bring on ... uh ... Haskellix!
11:31:23 <vincenz> animesh1977: okasaki's purely functional data structures
11:31:24 <vincenz> ?
11:31:26 <tusho> Yeah, as soon as I figure out a name..
11:31:26 <mrd> animesh1977: purely functional data structures
11:31:33 <vincenz> mrd: beep
11:31:33 <tusho> Suggestions welcome :-P
11:31:37 <mrd> boop
11:31:39 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/probability
11:31:40 <lambdabot> http://tinyurl.com/5jrxmr
11:31:43 <animesh1977> not just data structure
11:32:31 <Cale> oh, but it's maintained by Henning Thielemann, so you can expect strange conventions...
11:32:44 <mauke> heh. who is that?
11:32:55 <animesh1977> thx for the link, it is interesting but minimal
11:33:53 <dons> dcoutts_: aweseom, got finalizePackageDesc working nicely now
11:33:58 <dons> no need for CondTree hackign
11:34:03 <dons> cabal++
11:34:04 <dcoutts_> great
11:34:06 <dcoutts_> :-)
11:34:11 <tusho> Nobody? :P
11:34:21 <dons> so all the deps are looking reasonable
11:34:28 <Cale> mauke: Henning?
11:34:41 <mauke> yeah
11:34:45 * dcoutts_ kolmodin and kosmikus do the final smoke testing of Cabal-1.4.0.0 and cabal-install-0.5.0...
11:34:53 <dons> go go go!
11:35:06 <Cale> mauke: He's always backing these strange ultra-minimalist syntax proposals, and he uses weird conventions in his code like calling every type T (but putting them in different modules)
11:35:16 <dcoutts_> working on windows...
11:35:22 <BONUS> lol
11:35:23 <mauke> ah, ocaml style
11:35:33 <tusho> Cale: WTF?
11:35:37 <dcoutts_> so many packages fail on windows sadly
11:35:46 <tusho> Someone should slap him :|
11:35:54 <dcoutts_> network-2.1.0.0 failed during the configure step. The exception was:
11:35:54 <dcoutts_> sh: runProcess: does not exist (No such file or directory)
11:35:54 <tusho> Cale: Link to a ultra-minimalist syntax proposal?
11:36:00 <tusho> (& T-in-module source?)
11:36:19 <Cale> tusho: Well, for example, he wanted to remove if-then-else syntax.
11:36:31 <mauke> Cale: not a bad idea
11:36:35 <Cale> tusho: I don't know where a link is... it was quite a while ago.
11:36:36 <tusho> Cale: that's not too egregious
11:36:45 <tusho> if/then/else triggers my 'REFACTOR!' alarm
11:36:56 <Cale> It seems okay to me.
11:37:05 <mauke> 'if' could be much nicer as a function
11:37:20 <Cale> How so?
11:37:35 <Cale> You lose the then and else as nice delimiters to guide the eye.
11:37:42 <int-e> if ... then ... else ...   can be prettier than if (...) (...) (...)
11:37:49 <mauke> but you could use it with all the standard combinators
11:37:58 <tusho> mauke: it's not that useful in practice
11:38:01 <tusho> and it's called if'
11:38:07 <mauke> except if' doesn't exist
11:38:08 <tusho> but, yeah, i'd be for eliminating 'if'
11:38:16 <Cale> I'd call it bool, in analogy with maybe and either
11:38:49 <tusho> Cale: Ah, yes, I'd support that.
11:38:52 <mauke> Cale: yes! and make if :: Boolean b => b -> a -> a -> a
11:39:00 <tusho> mauke: please no.
11:39:02 <mauke> and generalize && and ||
11:39:05 <tusho> no no no no no
11:39:07 <mauke> what
11:39:09 <tusho> that's awful
11:39:17 <mauke> it works great in perl
11:39:28 <tusho> yeah
11:39:29 <tusho> in Perl.
11:39:38 <int-e> perl has side effects.
11:39:47 <Cale> mauke: What else would be in the Boolean class? Other lattices?
11:39:55 <int-e> oh you want the implict (==0) and the like
11:39:58 <Cale> I don't understand what your generalised if would do.
11:40:06 <int-e> (/=0) really
11:40:08 <mauke> [] and Maybe
11:40:15 <mauke> I'm not sure about numbers
11:40:18 <int-e> anyway, yuck
11:40:29 <Cale> Ah, I wouldn't pick that generalisation.
11:40:35 <jdrake> Any idea why hpaste doesn't remember username put into it?
11:40:51 <dolio> What about (Monad m) => m Bool?
11:40:56 <Cale> jdrake: It doesn't remember my settings either.
11:41:17 <Cale> jdrake: I think it's just broken in that regard. The author doesn't have access to the machine it's running on to fix it either.
11:41:50 <dolio> I guess that doesn't make sense with 'b -> a -> a -> a' though.
11:41:51 <jdrake> At least it is faster than lisppaste, which seems to have taken over freenode :p
11:41:51 <Cale> If I was going to generalise Bool, && and ||, I'd probably generalise to lattices.
11:41:53 <byorgey> dolio: what about (Applicative m) => m Bool?
11:41:58 <smg> hi Cale how are you :)
11:42:03 <Cale> smg: I'm well.
11:42:13 <thetallguy> any TH'ers around?
11:42:15 <smg> Cale: that's good. :]
11:42:23 <mauke> Cale: how does that work?
11:42:29 <lilachaze> Cale: class Boolean b where toBool :: b -> Bool; if = if' . toBool
11:42:34 <jdrake> I have done a question in Programming in Haskell, and I could use opinions on its expression: http://hpaste.org/8299
11:42:48 <lilachaze> Cale: i think the generalization would just be implicit conversion to bool
11:42:58 <thetallguy> I'm looking for tips on viewing what TH is up to
11:43:05 <Cale> jdrake: You should not use == to check if a list is empty
11:43:11 <tchakkazulu> jdrake: Use pattern matching instead of (==[])
11:43:15 <mauke> jdrake: '== []' requires Eq on the list elements
11:43:15 <Cale> jdrake: Either use pattern matching or null
11:43:26 <tchakkazulu> Ah, yeah. null works well.
11:43:30 <jdrake> Cale: pattern matching is in there too
11:43:41 <Cale> yeah, I see that :)
11:43:52 <tchakkazulu> jdrake: Ah, yes. And the extra remark mentions "null".
11:43:56 <Cale> But == will cause your functions to not quite have the right type.
11:44:03 <jdrake> I noticed that, but no explanation
11:44:31 <byorgey> > null []
11:44:32 <lambdabot>  True
11:44:37 <byorgey> > null [1,2,3]
11:44:37 <Cale> Well, in order to use (==), there must be an instance of Eq for the type you're testing for equality
11:44:38 <lambdabot>  False
11:44:44 <geezusfreeek> :t null
11:44:46 <lambdabot> forall a. [a] -> Bool
11:44:48 <geezusfreeek> :t (==[])
11:44:50 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:44:54 <Cale> and in order for there to be an instance of Eq for [a], there must be an instance of Eq for a
11:44:56 <jdrake> I see the change in types
11:45:21 <dcoutts_> oh noes! xmonad doesn't build on windows!!111
11:45:21 <tchakkazulu> > null ([] :: [Int -> Int])
11:45:22 <lambdabot>  True
11:45:29 <Cale> But you don't need to be able to test for equality of elements to check if a list is empty, which is what null does.
11:45:32 <tchakkazulu> > ([] :: [Int -> Int]) == []
11:45:32 <lambdabot>   add an instance declaration for (Eq (Int -> Int))
11:45:32 <lambdabot>     In the expression: ([...
11:45:38 <dons> dcoutts_: shouldn't the 'unix' dep prevent that?    :)
11:45:51 <dcoutts_> dons: well, the unix dep fails to build yes
11:45:56 <Cale> More gravely, you should avoid using length xs == 0
11:46:12 <dons> does 'unix' have the correct deps set then ? :)
11:46:16 <Cale> Because that will fail to terminate in the infinite case, and in the finite case will traverse the whole list.
11:46:25 <Deewiant> there should really be a length' :: [a] -> ChurchInt
11:46:33 <dmwit> :t genericLength
11:46:35 <lambdabot> forall b i. (Num i) => [b] -> i
11:46:50 <dmwit> Deewiant: Now just make an instance Num ChurchInt
11:46:51 <dons> dcoutts_: is there some neat way to flatten intersection/union depends to something sensible?
11:47:08 <dons> binary has some complicated deps, that i want to 'first orderify'
11:47:18 <Deewiant> dmwit: too much work, it's easier to write length' :-)
11:47:22 <geezusfreeek> Num is silly
11:47:22 <dcoutts_> dons: in a sense, yes. There's nothing that says that it will not build on a system though. One could add: if os(windows) { buildable: False }  I suppose.
11:48:00 <dcoutts_> dons: I'm not sure I grok what you're asking
11:48:03 <Deewiant> dmwit: e.g. I have little interest in defining negate for church numerals
11:48:27 <dmwit> You probably don't need to, if all you're doing is using it for genericLength.
11:48:29 <dmwit> ?src genericLength
11:48:30 <lambdabot> genericLength []    = 0
11:48:30 <lambdabot> genericLength (_:l) = 1 + genericLength l
11:48:32 <dons> well, typical package systems don't support specifying these intersection and union depencencies directly, so we need to pick on set that works.
11:48:45 <dcoutts_> dons: ah, you're talking about VersionRange
11:48:46 <Deewiant> dmwit: sure, no, but then I have a crap instance of Num.
11:48:46 <dons> so maybe if I can set up a packageIndex with the current base>=3, that'll resolve most of the issues
11:49:04 <dcoutts_> dons: I'm sure it would
11:49:05 <dons> yeah, sorry, complicated VersionRanges.
11:49:21 <Deewiant> dmwit: I'd rather have a specialized function. (Or then the type subclass -whateveryoucallit extension where I could define only Plus ChurchInt and Zero ChurchInt or whatever.)
11:49:21 <tromp> :t succ
11:49:22 <lambdabot> forall a. (Enum a) => a -> a
11:49:23 <dons> since that's one constant: we know ghc >= 6.8.2
11:49:26 <dcoutts_> dons: but if you use a package index then you have to make sure everything needed is there
11:49:47 <dons> well, i just want to fix the base version.
11:49:54 <bos> wow, the haskell version of this example completely creams the shell pipeline for performance.
11:50:00 <dons> bos, hah
11:50:06 <dcoutts_> dons: can't do that without fixing them all at the moment.
11:50:06 <geezusfreeek> as it should
11:50:09 <dons> performance comparisons you don't see everyday
11:50:10 <bos> i'm a bit surprised by that.
11:50:14 <dcoutts_> dons: it's an api limitation
11:50:32 <dcoutts_> dons: so yes, the cabal version range is more general than what most distros support, but you can extract the subset that does map to distro syntax.
11:50:34 <dons> dcoutts_: can i specify an additional constraint?
11:50:38 <dcoutts_> dons: yes
11:50:50 <dons> so that's where i'd put the base>=3 limit
11:50:56 <dcoutts_> dons: yep, that'd work.
11:51:28 <dcoutts_> dons: I realised after that the constraints and package index is really redundant info. It's all just a way of specifying constraints and we should do it more generally and simply.
11:51:48 <dcoutts_> dons: so we'll probably simplify that in Cabal-1.5.x at some point
11:52:42 <quicksilver> laz0r: you do have to set the stride to something other than 0
11:52:48 <quicksilver> laz0r: if you are interleaving.
11:52:52 <cnwdup> quicksilver: Parsec does not call undefined, does it?
11:52:58 <quicksilver> laz0r: each thing has to stride over the other things
11:53:02 <quicksilver> cnwdup: I would hope not.
11:53:16 * quicksilver adds T-junctions to the DSL
11:53:41 <byorgey> quicksilver: what are you making this DSL for?
11:54:10 <Saul_> With parsec, how do I make sure that the remainder of the string must be empty after my parse is successful?
11:54:53 <Saul_> so parsing say (char 'a') should not successfully parse "ab"
11:55:18 <Deewiant> char 'a' >> eof
11:55:19 <Deewiant> IIRC
11:56:12 <Saul_> Deewiant: That did the trick, thanks
11:56:14 <bos> ouch. unfortunately, the python version of the example is nearly twice as fast as the haskell, even though it uses only one core and the haskell one uses two.
11:56:57 <jdrake> I have another function that works, but for one detail. It is to split a list in half, but it is supposed to be for even lists, but I don't know a proper way to determine that.    http://hpaste.org/8299#a1
11:57:17 <dons> forall python programs . there exists a faster haskell implementation of the same program
11:57:26 <dons> as a general rule :)
11:58:27 <byorgey> jdavis: that looks fine, but won't reject odd-length lists of course
11:58:39 <byorgey> er, s/jdavis/jdrake
11:58:43 <byorgey> darn tab completion =P
11:58:51 <jdrake> byorgey: must watch that :-)
11:59:35 <RayNbow> dons: I've encountered a Python version that was as fast as the Haskell version :)
11:59:50 <byorgey> jdrake: also, as an aside, note that splitAt n xs === (take n xs, drop n xs)
11:59:51 <RayNbow> (but the bottleneck was libgmp :p)
11:59:56 <byorgey> > splitAt 3 [1..10]
11:59:57 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
12:00:23 <jdrake> byorgey: nice
12:00:29 <byorgey> jdrake: if you want to reject odd-length lists, you will have to (1) change the type of your function, and (2) add a clause to check the length of the list first
12:00:32 <jdrake> Well, I must run to work. Thank you all.
12:00:41 <cjb> > splitAt 3 [1,2,3,1,2,3,1]
12:00:43 <lambdabot>  ([1,2,3],[1,2,3,1])
12:00:51 <cjb> aw, only one split
12:01:03 <Zao> cjb: Index, not value.
12:01:08 <cjb> oh!
12:01:13 <cjb> oops :)
12:01:33 <Zao> > splitAt 5 "omgwtfbbq"
12:01:34 <lambdabot>  ("omgwt","fbbq")
12:02:45 <Saul_> cjb:  You could probably easily write one that does multiple splits
12:09:10 <lilachaze> > unfoldr (\(ss,as) -> case ss of (s:st) -> Just (second ((,) st) (splitAt s as)); [] -> Nothing) ([1,2,3,4], "Foo, bar, baz")
12:09:11 <lambdabot>  ["F","oo",", b","ar, "]
12:10:16 <bos> dons: i think i'm being bitten by the crummy implementation of comparison on ByteStrings in GHC 6.8.2
12:10:45 <lilachaze> @hoogle [a] -> Maybe (a, [a])
12:10:46 <lambdabot> No matches, try a more general search
12:14:02 <laz0r> quicksilver: http://lazor.de/hooray.png
12:14:26 <laz0r> quicksilver: i figured it out, i made a stupid mistake at somewhere else
12:15:51 <laz0r> quicksilver: your code actually helped me discover it, because you make sure that all your indices fit the vertices as well as the normals and texcoords, and i did something similar, but my code wasn't as elegant as yours
12:16:32 <laz0r> quicksilver: so i thought, 'maybe i can make more like this guys code' ... and then i discovered that i actually screwed the indices
12:16:59 <laz0r> quicksilver: and of course opengl can't render stuff correctly when all indices are screwed up
12:19:06 <tusho> Anyone?
12:19:27 <Zao> tusho: I can't see you in the scrollback.
12:19:35 <byorgey> tusho: ?
12:19:46 <tusho> Zao: Heh. Ok. I was just inquiring about how interested people would be in a project.
12:19:58 <tusho> Specifically, a hobix (http://hobix.com) clone in Haskell (since hobix development is DEEEADDD).
12:19:58 <lambdabot> Title: hobix&you!! feel yeah!!
12:20:06 <tusho> And also asking for any name ideas, because, yeah. I can't think of any.
12:20:46 <quicksilver> laz0r: yay ;)
12:21:57 <quicksilver> laz0r: yeah I was quite pleased with my vertex fitting code ;)
12:24:02 <tusho> So, yeah.
12:29:22 <cnwdup> It is not ok for a function of type IRC (Maybe a) to return IRC (), is it?
12:29:31 <cnwdup> :t liftIO
12:29:32 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:29:34 <cnwdup> :t printf
12:29:36 <lambdabot> forall r. (PrintfType r) => String -> r
12:29:53 * edwardk waves hello.
12:33:19 <tusho> Anyone?
12:33:23 <byorgey> cnwdup: nope.  how about returning Nothing instead of () ?
12:33:27 <byorgey> hi edwardk
12:34:31 <cnwdup> byorgey: Yeah. But I think I've got a function which passes the type system but doesn't actually return Maybe. Give me a second, please. Then I can ask a more concrete question. (-:
12:34:52 <tusho> cnwdup: Do show it.
12:34:55 <byorgey> tusho: do the interwebs really need one more blog platform? =)
12:35:05 <tusho> byorgey: hobix is not a blog platform
12:35:22 <byorgey> well, what is it then?
12:35:29 <Zao> Some kind of game.
12:35:34 <tusho> And, yes. Hobix does static html generation _right_.
12:35:43 <tusho> byorgey: It's a pseudo-blog platform.
12:35:48 <tusho> byorgey: It can handle perfectly ordinary websites too.
12:35:53 <tusho> e.g. hobix.com is a hobix site
12:36:00 <tusho> it has a news area, but it also has documentation, and other stuff
12:36:05 <Zao> Ah, misunderstood it all.
12:36:09 <byorgey> ok, so it's a sort of combination blog/cms kind of thing.
12:36:10 <tusho> It could be customized to do just about anything.
12:36:13 <Zao> Must've confused it with the VBO talk.
12:36:21 <tusho> Also, it's one of the nicest blog platforms to use when you use it for that.
12:36:30 <tusho> You can just edit files and run a program to sync it up.
12:36:34 <tusho> You can revision control your files, too.
12:36:45 <Zao> That sounds amazingly like a file system and scripts :P
12:36:47 <tusho> And even though it generates static html, you can make it do comments.
12:36:55 <byorgey> tusho: well, if you want to write a hobix clone in Haskell, you don't need our permission =)
12:37:01 <tusho> Zao: Snarky comments without having used software are .. not very helpful
12:37:22 <tusho> byorgey: I was asking if anyone had a good name for it, actually.
12:37:24 <tusho> I am already coding it.
12:37:38 <byorgey> tusho: ah, sorry, I thought you were asking if anyone was interested in working on it.
12:37:41 <tusho> (I am only coding it out of necessity. hobix hasn't been updated since 2005, and it doesn't even run nowadays)
12:37:49 <tusho> byorgey: Well, that was a side-thing too, if anyone was.
12:37:54 <Zao> hsobix?
12:38:05 <byorgey> habix?
12:38:08 <tusho> Zao: That was pretty much my first thought, but try and pronounce that.
12:38:09 <Zao> Bonus points if you manage to pronounce it.
12:38:22 <tusho> Anyway, I don't want to stay too close to the name 'hobix'. It feels a bit infringing.
12:38:32 <byorgey> xiboh? ;)
12:38:33 <tusho> After all, _why still uses hobix for hackety.org though how he got it to run is a mystery
12:38:44 <Zao> It's kind of hard to find alternatives since it doesn't mean anything (to my knowledge)
12:38:58 <tusho> Zao: Yeah, I was thinking more along the lines of: '
12:39:01 <monochrom> <3 you
12:39:09 <tusho> 'Anyone have a silly name?'
12:39:15 <byorgey> <3 you too, monochrom
12:39:49 <Zao> Then I suggest "grmbhl", easy to pronounce and all.
12:41:21 <tusho> Zao: How about 'zrzirzirizirzrinziwjrfo'
12:42:43 <monochrom> glwynglwynglwynglwynllywh  (welsh version)
12:43:04 <tusho> Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.
12:44:28 <Deewiant> Fordinchuarlikomfterrablaxxuuuuuchh'chh'chh-pt.
12:44:50 <tusho> UntitledDocument1.
12:45:22 <Deewiant> NullPointerException
12:45:45 <tusho> Deewiant: Hah.
12:46:11 <sclv_> the generalized bool I'd like to see: http://hpaste.org/8300
12:46:33 <sclv_> hmm wait, I just realized I don't even need the data type, just the type class. hang on...
12:46:38 <tusho> sclv_: Eww.
12:46:43 <tusho> Don't really like that.
12:47:29 <sclv_> Cleaning it up as we speak. :-)
12:47:48 <mauke> zrzirzirizirzrinziwjrfo = \.r.ri.r\in.wjrfo
12:48:04 <edwardk> why not just instance CBool Bool?
12:48:14 <edwardk> GBool doesn't add any value does it?
12:48:23 <edwardk> @src Bool
12:48:23 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:48:28 <sclv_> edwardk: right, I just realized that.
12:48:37 <sclv_> that's what I get for coding first and thinking later.
12:48:43 <edwardk> heh
12:50:09 <sclv_> http://hpaste.org/8300#a1
12:50:12 <sclv_> there we go.
12:50:35 <edwardk> @type (&&)
12:50:37 <lambdabot> Bool -> Bool -> Bool
12:50:50 <edwardk> how about instance CBool Bool where (<&&>) = (&&); ...
12:50:54 <cnwdup> http://hpaste.org/8301 Sorry that I can't shorten this further. I tried it but then it was just working. However the function sendRaw is triggered when both the RawMessages are processed. It doesn't seem to actually return IRC (Maybe a) since I forgot the >> return Nothing. So after the second call of put st in line 58 fails since bogus data has been stored in the data map. At least to my understanding. I don't know if that's of interest, so here it is i
12:51:03 <dcoutts_> dons: want to try: $ cabal install cabal-install
12:51:12 <dcoutts_> dons: erm, cabal update first
12:51:16 <sclv_> edwardk: yeah. now that I've fixed up the other stuff, I can do that too.. but you get the idea.
12:51:21 <Deewiant> cnwdup: message got cut after "so here it is i"
12:51:36 <edwardk> @pl \x y a -> x a <&&> y a
12:51:36 <cnwdup> Sorry.  so here it is if someone's interested.
12:51:36 <lambdabot> liftM2 (<&&>)
12:52:06 <sclv_> generalizing && and || and friends like this in the base libs would be sort of nice though, I think.
12:52:46 <edwardk> yeah my kata definition makes && and || into functors, and tears them down with an initial "Boolean" algebra
12:53:18 <sclv_> I write stuff all the time where this would be useful, maybe for haskell prime? (fingers crossed)
12:53:20 <edwardk> mainly because i like the idea of being able to use them for general meet and join operations, etc.
12:53:43 <byorgey> cnwdup: aha, it seems the Printf library has undefined in it =)
12:53:45 <sclv_> edwardk: which file is that in?
12:53:53 <sclv_> oh, wait, right kata is your toy language.
12:53:58 <edwardk> sclv: yeah, not haskell =)
12:54:13 * dcoutts_ invites everyone to $ cabal update && cabal install cabal-install-0.5.0
12:54:28 <cnwdup> byorgey: Ok. Good to know. (-: Though I find it a little confusing that the type checker doesn't notice the malformed type. But I don't understand printf's type at all.
12:54:28 <edwardk> sclv: i need to fix my implementation. i ripped it all apart trying to get a nice version of wadlers arrow calculus in it, and i never recovered
12:54:39 <byorgey> cnwdup: it isn't a malformed type, that's the thing
12:54:48 <cnwdup> Yeah.
12:55:14 <byorgey> IO (Maybe a)  is a valid return type for printf.
12:55:14 <cnwdup> Is there a nicer way to do the thing in line 25, btw?
12:55:29 <byorgey> but the instance for IO  does some stuff and then 'return undefined' =P
12:55:29 <cnwdup> It seems ugly as hell to me.
12:55:58 <byorgey> cnwdup: why use printf at all?
12:56:11 <thetallguy> dcoutts: is there a summary of the updates?
12:56:28 <byorgey> cnwdup: just 'putStr $ concat [ ">> ", s, "\r\n" ]'  or so
12:56:38 <cnwdup> byorgey: Mh, is isn't *really* useful for my app. That's right.
12:56:47 <dcoutts_> thetallguy: http://haskell.org/cabal/release/latest/ changelog and releaseNotes
12:56:47 <lambdabot> Title: Index of /cabal/release/latest
12:57:01 <dcoutts_> thetallguy: and also user guide and api reference
12:57:15 <cnwdup> I'll consider that. (-: The a little messier syntax is a good trade for spending the whole afternoon finding that printf error. \-:
12:57:30 <byorgey> cnwdup: as for line 25, let me see
12:57:37 <sclv_> dolio: nice generalization!
12:57:47 <dcoutts_> thetallguy: oh, you were asking about fetch. I'm not sure you were doing the easiest thing. Remind me what you were trying to do exactly?
12:57:58 <sclv_> its obvious in retrospect, but that lets all sorts of neat things happen.
12:58:32 <dcoutts_> thetallguy: were you just getting the tarballs? they get downloaded to a standard location so you can fetch and then just go to where they get downloaded to (which itself is a configurable location)
12:59:43 <byorgey> cnwdup: http://hpaste.org/8301#a1
12:59:46 <thetallguy> dcoutts: cabal update >>= cabal list >>= mapM (cabal fetch) >>= mapM cabal2Debian
12:59:53 <byorgey> cnwdup: untested, I might have made a mistake, but that's the idea
13:00:03 <cnwdup> byorgey: Ok. Thank you very much. (-:
13:00:15 <thetallguy> dcoutts_: You've just stated  one of my hugest peeves
13:00:17 <byorgey> cnwdup: note that  \x -> foo $ blah x  === foo . blah
13:00:45 <dcoutts_> thetallguy: you want to steal the code from hackport which is the gentoo cabal->native tool. It has code to download the index and the tarballs etc.
13:00:56 <dcoutts_> thetallguy: what peeve?
13:01:02 <thetallguy> dcoutts_: that tools written in a purely functional language modify state in an implicit location and return ()
13:01:05 <byorgey> cnwdup: also,  foo >>= return . blah  === blah `liftM` foo
13:01:13 <dcoutts_> thetallguy: heh :-)
13:01:34 <dcoutts_> thetallguy: I'm not sure what else we'd do. We have to cache the tarballs.
13:01:48 <thetallguy> dcoutts_: but you DO cache the tarballs
13:01:57 <cnwdup> byorgey: Yeah. I have to internalize (.) and liftM. I only use them ocassionally (and mostly by try and error with ghci).
13:02:00 <thetallguy> all you have to do is say where
13:02:42 <byorgey> cnwdup: heh, you'll get there.  well, a good place to start is to work through each line of my derivation and make sure you understand it (assuming I didn't make a mistake =)
13:02:51 <thetallguy> but odn't worry, I'll just publish how I want it fixed. ;-)
13:03:08 <thetallguy> I had all the library code laid out, ready to reassemble
13:03:21 <dcoutts_> thetallguy: I would not be confident in being able to parse the text output of cabal except where we've made a deliberate interface, like list --simple-output. Otherwise it's for human consumption and subject to change.
13:03:37 <cnwdup> byorgey: I'll do that. But for now I am too exited that my code is working. So I'll toy around with my bot a little and then do that. (-:
13:03:37 <thetallguy> and then I realized 'cabal fetch' would do everything I needed.
13:03:39 <dons> $ cabal install cabal-install
13:03:46 <thetallguy> dcoutts_: another huge peeve
13:03:53 <byorgey> cnwdup: hehe, I totally understand =)
13:04:09 <dcoutts_> thetallguy: if you want something with a programmatic interface, there is code to manage the hackage index and do downloads.
13:04:13 <thetallguy> All of these things could use Read and Show
13:04:34 <dcoutts_> thetallguy: which things?
13:04:47 <thetallguy> well, the result of 'cabal fetch', for one...
13:04:56 <dons> Done.
13:05:02 <dons> dcoutts_: seems to work.
13:05:05 <dons> well done!
13:05:16 <dons> where can i buy my 'there is no cabal' tshirt?
13:05:21 <MyCatVerbs> @pl \n -> ndn (nup 1 n) n
13:05:22 <lambdabot> ndn =<< nup 1
13:05:32 <dcoutts_> dons: heh
13:05:35 <MyCatVerbs> Ohhh, nice.
13:05:41 <thetallguy> dcoutts_: don't worry about it.  I'll make my arguments more completely in a paper and then proselytize
13:05:49 <dcoutts_> thetallguy: heh, ok
13:05:53 <MyCatVerbs> @pl \n -> ndn n (nup 1 n)
13:05:53 <lambdabot> ap ndn (nup 1)
13:06:01 <MyCatVerbs> @pl \n -> ndn n (nup n 1)
13:06:02 <lambdabot> ap ndn (flip nup 1)
13:06:17 <MyCatVerbs> :t ap
13:06:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:06:24 <dcoutts_> thetallguy: the cabal-install tool has loads of useful code which is not yet in the form of a nice lib. But many of the internal interfaces are designed with that in mind.
13:06:56 <sclv_> oooh -- cabal list is fancier now
13:06:56 <dcoutts_> thetallguy: and since you're writing a haskell prog is seems better to use an interface like that than a command line interface.
13:07:06 <thetallguy> dcoutts_: yes, that's clear and that's what I wa stealing at first
13:07:15 <byorgey> dcoutts++
13:07:18 <dons> dcoutts_: release happening today?
13:07:24 <dcoutts_> dons: it's done
13:07:34 <dons> and an announce?
13:07:37 <thetallguy> but since I had a shell interface, I saw a quick path to composing those functions together
13:08:12 <dcoutts_> dons: feh :-) I'm going to a bonfire. I'll announce when I hear a few more success reports :-) so I know I don't need a .0.1 release ;-)
13:08:26 <dons> ok ok.
13:09:19 <dcoutts_> thetallguy: we've all got these cabal->native conversion tools now, we should seriously look at sharing code. Between the distro tools and with cabal-install too.
13:09:23 <thetallguy> dcoutts_: re: command line interface, I agree, more or less.  you get to the crux of my argument.  I think we need an interactive shell that speaks haskell.
13:09:35 <dcoutts_> ghci? :-)
13:09:44 <thetallguy> dcoutts_: our cabal-debian is swiped from cabal-rpm
13:09:58 <thetallguy> dcoutts_: ghci is a good start
13:10:00 <dcoutts_> thetallguy: right, there's a lot of copy'n'paste going on
13:10:39 <dcoutts_> thetallguy: we can do better and benefit from each others features and code review and support from upstream Cabal devs
13:10:55 <thetallguy> dcoutts_: I feel I"m always forced into copy and paste because we still don't have a really great systems interface
13:11:20 <dcoutts_> designing interfaces is hard
13:11:27 <thetallguy> dcoutts_: yup, that's why I'm trying to send this small patch upstream to see if you guys like the direction
13:11:34 <thetallguy> dcoutts_: indeed
13:11:36 <dcoutts_> you sometimes have to see a few examples first before you see the right way to factor things
13:12:03 <Gilly> Hm, when I'm using Data.Binary and calling decodeFile to load some stuff from a file and then try to save modified stuff to the same file i get problems because the file is still open. Any ideas?
13:12:04 <dcoutts_> thetallguy: we've not received any patch yet btw (unless it was within the last few hours)
13:12:13 <dcoutts_> thetallguy: perhaps you're not subscribed to cabal-devel
13:12:19 <Gilly> (saving using encodeFile)
13:12:33 <thetallguy> dcoutts_: no still making sure it does what I want
13:12:50 <dcoutts_> thetallguy: ok, we are always welcoming of patches :-)
13:12:50 <thetallguy> dcoutts_: and of course, there's the UEFA tournament...
13:12:54 <dcoutts_> heh
13:13:05 * dcoutts_ heads off to his bonfire party
13:15:13 <gubagem> ok
13:15:18 <gubagem> how is selector not in scope
13:15:19 <gubagem> miniBash selector=State (location state2) (Map.insert (self room) (room {selector=(not (selector room))}) (table state2))
13:16:02 <monochrom> you have two selector's, and one shadows the other.
13:16:15 <gubagem> how do i have two??
13:16:17 <Saizan_> gubagem: you can't pass field names as parameters like that.
13:16:28 <gubagem> oh someone said i could
13:16:37 <monochrom> miniBash selector=...  this is one.
13:16:38 <Saizan_> only if you use them as accessors
13:16:50 <monochrom> room {selector=...  this is another.
13:16:56 <gubagem> do i need to explicityl reconstruct the data structure?
13:17:27 <gubagem> i just want to make one small change to the data structure
13:17:32 <monochrom> Alright, I see, it is not shadowing, it is because the record doesn't have that field label.
13:18:09 <gubagem> it cant use a variable like that for the room {selector=newVal} ? where i pass selector in
13:19:32 <sclv_> nope, I don't think.
13:19:47 <sclv_> you want functional references, but we don't have those by default yet.
13:19:51 <Saizan_> no, record syntax is limited like that
13:20:15 <Saizan_> you can pass an updating function though
13:22:26 <gubagem> an updating function?
13:30:15 <monochrom> For each field f, you have to write a separate function (\r x -> r{f=x}). There is no unifying way.
13:31:38 <Heffalump> except template haskell
13:31:41 <Zao> Can one abuse template haskell somehow?
13:31:54 <Heffalump> the data-accessor package on hackage does that
13:32:17 <Heffalump> however, TH splices really mess up dependency analysis, so IME it's not very easy to use
13:33:25 <sclv_> one can also abuse generics.
13:33:31 <sclv_> seriously abuse.
13:34:06 <sclv_> http://www.haskell.org/pipermail/haskell-cafe/attachments/20080426/20054ce2/GenericFRef-0001.obj
13:34:11 <gubagem> monochrom: why cant that f of {f=x} be a record accesor
13:34:42 <monochrom> perhaps because haskell sucks?
13:35:04 <lambdabot> http://tinyurl.com/6l68ya
13:35:09 <maltem> Haskell records suck, definitely.
13:35:24 <sclv_> gubagem: because record accessors when they're passed are functions, and the curly-braces record syntax is just sugar for anonymous updater functions, not first-class.
13:35:45 <monochrom> I mean, it's like asking "why can't I write (+ 1 1) in haskell".  The language is defined that way, for better or worse.
13:36:03 <Botje> i've been thinking about haskell records
13:36:04 <gubagem> would i be better off using associated lists
13:36:35 <monochrom> No, because each field content is of a different type.
13:36:51 <Botje> instead of explicitly typing accessors like name :: Person -> String, why not have name :: (HasName a) => a -> String ?
13:37:12 <gubagem> huh
13:37:16 <Botje> (or even make the String another variable)
13:37:25 <monochrom> An association list requires [(k1, v1), (k2, v2), ...]  all of v1, v2, ... are the same type.
13:37:38 <gubagem> i just want to flip a boolean value that is stored in 6 different locations in a record called Room
13:38:11 <mauke> why is it stored 6 times?
13:38:12 <gubagem> i could just make all of v1 and v2::String
13:38:21 <gubagem> east,north,west,south,up,down
13:39:01 <Heffalump> andyjgill: did you get anywhere with your huge dictionaries problem?
13:39:07 <monochrom> If all fields are of the same type, an array or an association list or a Data.Map is a viable option.
13:39:42 <gubagem> well i also have two strings, title and description, and im gonna eventually want a Set||List for room contents
13:39:44 <maltem> gubagem: In such cases you just have to flip each and every value, verbosely, for better or for worse.
13:39:50 * Heffalump has a similar looking problem which he doesn't really understand
13:40:02 <jamii> Cant install and of the last 6 days worth of GHC snapshots.
13:40:03 <jamii> installPackage: Saved package config file seems to be corrupt. Try re-running
13:40:03 <jamii> the 'configure' command.
13:40:22 <monochrom> Then perhaps a record having: a field for title, a field for description, a field for array of bools.
13:40:49 <gubagem> good idea, how do i make arrays in haskell
13:41:14 <monochrom> My tutorial on arrays is not yet written. Maybe next year.
13:41:20 <gubagem> okie
13:41:26 * gubagem slams his head against the wall
13:41:37 <monochrom> I hope you can find some.
13:41:42 <mauke> Data.Array.*
13:42:02 <maltem> > listArray (0,5) (cycle [True,False])
13:42:05 <lambdabot>  array (0,5) [(0,True),(1,False),(2,True),(3,False),(4,True),(5,False)]
13:42:10 <gubagem> so i basically need to write mutators like i do in java
13:43:17 <goran> hey, would someone be so kind to write a function in haskell for my college assignment. i'm a newbie at haskell and i don't know where to start. plz :)
13:43:32 <gubagem> here ya go
13:43:34 <mauke> f () = ((), ())
13:43:34 <goran> it sounds rather easy :P
13:43:39 <mauke> there
13:43:40 <gubagem> oh that is nice
13:43:45 <gubagem> or
13:43:48 <gubagem> f 1=1
13:43:53 <goran> :))) not that easy
13:43:58 <mauke> it is!
13:43:59 <monochrom> I have a simpler function than mauke's. g x = x.
13:44:02 <goran> :D
13:44:10 <gubagem> how about just
13:44:14 <mauke> g _ = ()
13:44:14 <goran> it's like this... In Haskell programming language, create a function that returns the count of even elements of some list, where list is specified in an argument. Test the function with the lists of integers. It is allowed to use additional functions, but you can not use already created functions in additional libraries.
13:44:25 <gubagem> a=1 thats technically a function right
13:44:38 <mauke> gubagem: no, unless you instance Num (a -> b)
13:44:56 <gubagem> mmm
13:45:03 <Zao> goran: Shouldn't be that hard then, if you know how to map something over a list, or write a recursive function that eats the head of a list.
13:45:06 <Heffalump> Haskell makes no real semantic difference between functions and values
13:45:11 <mauke> Begedin again?
13:45:16 <Heffalump> except perhaps in the behaviour of seq
13:45:28 <Zao> mauke: Indeed is.
13:45:32 <mauke> asshat
13:45:34 <gubagem> you just want to count the even number elements in a list?
13:45:44 <goran> yes, just count
13:45:45 <Zao> goran: So, why the nick and IRC client/host change?
13:45:55 <goran> didn't change anything
13:46:10 <gubagem> goran: gimme a minute ill figure it out for ya
13:46:13 <monochrom> goran: you can easily write your own recursion.  f [] = 0.  f (x:xs) = ... examine x, there are two cases, then recursion on xs.
13:46:15 <Zao> mauke: Or there's a surprising amount of hungarians around tonight.
13:46:17 <Botje> goran: what have you tried so far?
13:46:24 <gubagem> you dont even need recursion
13:46:40 <sclv_> goran: how's your connection.
13:46:41 <mauke> preflex: ? .hr
13:46:41 <preflex>  Croatia
13:46:48 <bos> dons: the bytestring comparison was indeed at fault.
13:46:48 <Zao> Oh well, close enough.
13:47:05 <goran> hey
13:47:18 <bos> dons: with bytestring from ghc 6.8.2, my code ran in 4.2 seconds. with 0.9.1.0, 1.7 seconds.
13:47:22 <goran> i forgot to translate few words from the question
13:47:31 <goran> this is final question text:_ In Haskell programming language, create a function that returns the count of even elements of some list that are bigger than some value specified by parameter. List is specified in an argument. Test the function with the lists of integers. It is allowed to use additional functions, but you can not use already created functions in additional libraries.
13:47:44 <bos> compared to python, at 5.7 seconds, that's pretty good.
13:47:58 <Zao> goran: Sounds straightforward enough.
13:48:05 <goran> :)
13:48:31 <goran> i work with C#/SQL mostly, haskell is new for me, and i don't have enough time to learn haskell from scratch
13:48:38 <mauke> <Begedin> anyway to put it short, i need a function that returns the number of even elements greater than the parameter from an integer list <Begedin> and i cant use built in functions
13:49:28 <sclv_> > filter (\x -> x == 5) [1,2,3,4,5,6,5,4,3,4,5]
13:49:29 <lambdabot>  [5,5,5]
13:49:38 <dons> bos, great.
13:49:46 <dons> what an interesting performance issue that turned out to be.
13:49:48 <monochrom> Oh God, the question gets more complicated :)
13:49:48 <sclv_> ^^ filter is your first friend. you might need to write your own though.
13:49:49 <dons> just a little bit of bad inlining
13:50:01 <bos> dons: yes, and hard to spot unless you use maps.
13:50:06 <dons> yeah.
13:50:10 <dons> which show up when racing python.
13:50:12 <newsham> i really wish the std libs had a "guarded function" function
13:50:15 <bos> since maps are about the most comparison-heavy data structure we have.
13:50:19 <dons> ah well, 6.10 is due out in a couple of months
13:50:23 <gubagem> goran and others: i came up with: Prelude> let evenCount list=let len=length list in if (even len) then (len / 2)
13:50:23 <gubagem> else ((len - 1) / 2)
13:50:29 <gubagem> but it doesnt work
13:50:35 <newsham> ie  \p f x -> guard (p x) >> f x
13:50:37 <goran> :D why doesn't it work
13:50:40 <gubagem> eww that was an ugly paste
13:50:44 <edwardk> bos: did your blog reset a couple of months or something?
13:50:47 <gubagem> something about fractional int
13:50:59 <Botje> goran: have you _TRIED_ to learn haskell?
13:51:00 <bos> edwardk: yes
13:51:06 <monochrom> replace / by `div`.  E.g., len `div` 2.
13:51:12 <goran> botje: nope :)
13:51:12 <edwardk> bos: whew, was worried i was stuck in a time machine again.
13:51:14 <bos> edwardk: server died, so i had to restore from a backup that was a few weeks old.
13:51:18 <Zao> > let evengt = filter . (`ap` even) . ((&&) .) . flip (>) in evengt 5 [1..10]
13:51:20 <lambdabot>  [6,8,10]
13:51:24 <gubagem> monochrom: why div
13:51:26 <Botje> goran: then you shall get no help from me.
13:51:36 <monochrom> because it stays within integers.
13:51:39 <goran> Botje: well that sounds fair
13:51:44 <gubagem> okie
13:51:47 <Botje> but since other people are handing out fish, you'll get away with it I guess.
13:52:01 <goran> maybe i will
13:52:01 <gubagem> it will hurt him in the long run though
13:52:21 <goran> there will be time to learn haskell... now i'm currently stuck with other chores
13:52:33 <sclv_> nothing is more important than learning haskell.
13:52:35 <oklopol> >0
13:52:37 <oklopol> > 0
13:52:37 <sclv_> except using it.
13:52:38 <monochrom> Too many people are giving out fish. I'd be wasting my time if I did otherwise.
13:52:40 <goran> :)
13:53:04 <gubagem> @let evenCount list=let len=length list in if (even len) then (len `div` 2) else ((len - 1) `div` 2)
13:53:14 <goran> does that work?
13:53:20 <Zao> Seems like lambdabot kind of keeled over.
13:53:25 <gubagem> > evenCount [1..10]
13:53:26 <sclv_> ><((((>`..`..`...><((((>
13:53:38 * Zao whistles innocently at the @pl in queries.
13:53:43 <mauke> haha
13:53:47 <monochrom> As usual, the minority is always right, the majority is always wrong, but the majority dominates. Tyranny of majority.
13:54:00 <goran> gubagem: thanks. does that work correctly?
13:54:10 <Zao> goran: Pick it apart and see?
13:54:10 <gubagem> i dont know let me paste it to my ghci
13:54:54 <gubagem> goran: yea it works, do you even have haskell installed?
13:55:13 <goran> gubagem: not really, i'll install it some time this night and figure it out.
13:55:31 <gubagem> goran: go download ghc http://haskell.org like right now
13:55:34 <goran> gubagem: thank you very much, you saved my ass and i might as well say you brought me some grades
13:55:36 <goran> :)
13:55:52 <gubagem> is like the first assignment?
13:55:55 <gubagem> is this
13:55:59 <tobias_tud> has anyone experience with the installation of ghc in gentoo?
13:56:10 <mauke> yes (as in 'emerge ghc')
13:56:21 <Zao> tobias_tud: Poke portage, grab coffee, enjoy?
13:56:22 <tobias_tud> that fails
13:56:27 <mauke> how?
13:56:40 <tobias_tud> ehm, it needs cabal
13:56:44 <goran> gubagem: it's the 3rd laboratory excersise in "Programming paradigms and languages" course at Faculty of E.E. and Computing, Zagreb, Croatia
13:57:00 <gubagem> where the first 2 in haskell?
13:57:08 <gubagem> s/where/were
13:57:15 <goran> first two are OO programming, programming paradigms and stuff
13:57:16 * gubagem slams his head against the wall again
13:57:27 <mauke> goran: do you know one "Nikola Begedin"?
13:57:30 <goran> the third is XML, lambda expressions, LINQ/.NET, ....
13:57:43 <goran> mauke: nikola is a friend of mine, he's at the same course
13:58:01 <goran> apparently he got the same question, we get our questions on random basis from web portal of faculty
13:58:14 <Zao> Ah, they zerg.
13:58:46 <Socrates> Zao: A modern day computer science degree measures how hard you can "do the google"!
13:59:10 <goran> gubagem: & others... thank you very much, i appriciate the help :)
14:00:20 <lambdabot> Title: Haskell - HaskellWiki
14:00:21 <lambdabot>  0
14:00:22 <lambdabot>   Not in scope: `evenCount'
14:00:24 <lambdabot> Defined.
14:00:36 <Zao> Now that was lazy evaluation.
14:00:40 <Gilly> :)
14:01:23 <monochrom> Don't laugh. Googling is a non-trivial and valuable skill too.
14:01:54 <monochrom> You'd be surprised how many askers in #math (and even some in #haskell) plainly fails to even google.
14:02:09 <Gilly> that's true
14:02:52 <Gilly> i wonder how thankful this guy is gonna be after gubagem's "advice" :P
14:03:10 <Gilly> i mean after he returns it :P
14:03:25 <Heffalump> :-)
14:03:34 <Socrates> He reminded me of several people I used to know on my course
14:03:46 <Socrates> "used to" being the operative phrase
14:04:06 <Gilly> *g*
14:04:21 <monochrom> Hrm, gubagem's function does something different from what the question specifies... :)
14:04:22 <mauke> ah, Socrates would be opposed to feeding people canned answers, of course
14:04:42 <Heffalump> monochrom: sad, that.
14:04:47 <Gilly> monochrom: exactly :) and it even gives the same answer for trivial inputs (of form [1..x]) :)
14:04:57 <Heffalump> I don't think he even realised that Zao posted the correct answer.
14:04:59 <Gilly> though it didn't have that limit part of the question at all
14:05:08 <Socrates> Radical thinking, I know, mauke
14:05:17 <Gilly> zao's wasn't correct - question demanded "no library functions"
14:05:20 <monochrom> Does Socrates oppose feeding people canned squid? I mean under the context that the asker asks for canned fish... :)
14:06:14 <Socrates> I suppose I can't really complain
14:06:20 <monochrom> haha
14:06:39 <sclv_> [[ >()))> ]]
14:06:49 <monochrom> hehe
14:07:01 <geezusfreeek> gosh "I have a college assignment I don't want to do because I am too lazy to learn the material. Would somebody here do it for me????????"
14:07:13 <Socrates> By comparison
14:07:15 <dmwit> Maybe for big tall moneys.
14:07:18 <geezusfreeek> should track down his college and report that
14:07:22 <geezusfreeek> :P
14:07:56 <geezusfreeek> but that would be a douchebag thing to do
14:08:43 <Socrates> Meh, probably save him some money, get him kicked out in the first year, rather than failing the 3rd :P
14:10:35 <geezusfreeek> somehow these people have an affinity for scraping by and making it into the work force
14:11:10 <geezusfreeek> i guess by cheating :(
14:11:15 <Socrates> I 'spose they're at least serving some use there; making the average look above average
14:11:17 <FordCortina> @pl (\x y -> abs $ (x-y))
14:11:18 <lambdabot> (abs .) . (-)
14:11:34 <geezusfreeek> what, that's not average?
14:11:52 <Socrates> Good point
14:12:15 <Socrates> In that case, pulling the average down
14:12:17 <monochrom> This is the "joe programmer".
14:12:52 <gubagem> i know a guy who couldnt understand linked lists in C and is now writing Java code for the United States Air Force
14:13:17 <monochrom> Does he understand linked lists in Java? That would do.
14:13:27 <elliottt> heh
14:13:33 <monochrom> And oh, China would love to hear that. :)
14:13:38 <lament> I never used a linked list in an actual program
14:13:57 <geezusfreeek> you don't use haskell lists?
14:14:09 <lament> well, i mean i didn't implement them
14:14:17 <lament> although in a way you do implement haskell lists each time you use them
14:14:26 <mrd> linked lists were my favorite thing to build in C
14:14:31 <FordCortina> :t abs . (-)
14:14:32 <Socrates> Hm, I know a soon to be 3rd year UG that doesn't understand Regex.
14:14:33 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a -> a
14:14:46 <FordCortina> :t (abs .) . (-)
14:14:48 <lambdabot> forall a. (Num a) => a -> a -> a
14:14:50 <geezusfreeek> i know a grad student who doesn't know what a data structure is
14:14:57 <gubagem> regEx's can be horribly nasty, at what i remember about them in perl
14:15:02 <lament> i know a nobel prize winner who can't count to 10!
14:15:05 <gubagem> geezusfreeek: SERIOUSLY?
14:15:09 <geezusfreeek> yes
14:15:16 <gubagem> a grad student in comp sci?
14:15:21 <geezusfreeek> he was in my join UG/G computer graphics class
14:15:24 <geezusfreeek> yeah, comp sci
14:15:33 <gubagem> thats crazy
14:15:43 <mrd> you can be a comp sci grad student and never write a program
14:15:48 <Apocalisp> how's that possible?
14:15:59 <FordCortina> maybe he didnt do compsci as an undergrad
14:16:04 <eu-prleu-peupeu> i dont know regexp... nobody really knows if you guys think about it...
14:16:14 <geezusfreeek> this seems to be the norm here :(
14:16:27 <geezusfreeek> well, below average at least
14:16:28 <Apocalisp> what school?
14:16:33 <mrd> lots of CS work was done prior to the first electronic computer even existing
14:16:57 <FordCortina> :t abs
14:16:58 <lambdabot> forall a. (Num a) => a -> a
14:17:17 <monochrom> Yeah, test of your "understanding" of regex (the posix one, e.g.): write one that matches prime numbers (decimal, say).
14:17:25 <FordCortina> :t abs .
14:17:27 <lambdabot> parse error (possibly incorrect indentation)
14:17:33 <FordCortina> :t (abs .)
14:17:35 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
14:17:36 <Socrates> Ok, let me be a bit clearer.
14:17:39 <geezusfreeek> Apocalisp: www.uah.edu
14:17:42 <mauke> monochrom: is that possible?
14:17:48 <geezusfreeek> Apocalisp: oh and btw, compare that site to www.brown.edu
14:17:56 <Socrates> He has *no* understanding of even basic regex after taking at least two modules involving them
14:17:57 <monochrom> Yes, because there is enough memory availed by \1, \2, etc.
14:18:08 <geezusfreeek> it's a great engineering school, but a sucky comp sci school
14:18:12 <mrd> back-references aren't regular
14:18:20 <geezusfreeek> i don't even understand how there can be so much difference
14:18:22 <Apocalisp> geezusfreeek: The other one's... brown.
14:18:22 <monochrom> right, but I said posix.
14:18:23 <gubagem> i used to live in huntsville alabama when my dad was in the army
14:18:29 <FordCortina> :t (-)
14:18:30 <lambdabot> forall a. (Num a) => a -> a -> a
14:18:33 <geezusfreeek> gubagem: i grew up here
14:19:15 <monochrom> Would you like to write a blog with headline "posix regex is not regular"? :)
14:19:23 <mrd> been done
14:19:50 <monochrom> reddit it, and start a flame war :)
14:20:03 <mrd> someone showed it was NP-hard
14:20:12 <mrd> by encoding graph coloring
14:20:31 <geezusfreeek> the other difference between the two is that brown.edu is 235KB and uah.edu is 1.36MB :\
14:20:45 <monochrom> Oh neato :)
14:22:19 <mrd> http://perl.plover.com/NPC/
14:22:20 <lambdabot> Title: Perl Regular Expression Matching is NP-Hard
14:22:36 <gubagem> can i do pattern matches against functions  say f->do this stuff
14:22:47 <gubagem> in a case statement
14:22:54 <ddarius> Isn't it Turing-complete?
14:23:00 <ddarius> No.
14:23:06 <geezusfreeek> gubagem: if you want to do something like that you want a GADT with an interpreter
14:23:21 <gubagem> whats a GADT
14:23:30 <Socrates> Generalised Abstract Data Type?
14:23:37 <mauke> Algebraic
14:23:40 <shapr> GHC Advanced Data Type?
14:23:42 <sieni> or Algebraic?
14:23:42 <gubagem> so i cant do that in normal compiled ghc?
14:23:43 * shapr is joking
14:23:47 <Socrates> Algebraic indeed
14:23:50 <geezusfreeek> ?where GADT
14:23:50 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
14:24:00 <gubagem> server down
14:24:04 <RayNbow> GADT = GHC is an Awesome Dev Tool
14:24:06 <RayNbow> duh ;)
14:24:07 <geezusfreeek> oh
14:24:09 <geezusfreeek> suck
14:24:39 <geezusfreeek> GADT = GADTs Are Delicious and Tasty
14:24:55 <geezusfreeek> recursive _and_ redundant
14:26:10 <geezusfreeek> or Ground Air Defense Threat, according to wikipedia...
14:26:34 <gubagem> GADT=George and Dick Think
14:27:11 <Socrates> > let gadt = gadt ++ "Are Delicious and Tasty" in gadt
14:27:26 <lambdabot>  thread killed
14:27:55 <Socrates> I think I need to eliminate left recursion in that grammar to allow LL(1) parsing.
14:31:24 <TomMD> > map succ "You do not have any messages"
14:31:25 <lambdabot>  "Zpv!ep!opu!ibwf!boz!nfttbhft"
14:31:35 <TomMD> Just making sure it wasn't a hidden message.
14:32:53 <shapr> hah
14:33:17 <FordCortina> is this a bit complicated for a function that find the difference between terms in a list? diff xs = map (\(x,y) -> abs (x-y)) (zip xs (0:xs))
14:33:34 <sfultong> hey, is there any secret to building darcs yi?
14:34:28 <mrd> incantations
14:34:36 <mrd> lambda sacrifice
14:34:39 <sfultong> if by incantations, you mean curses...
14:34:57 <FordCortina> i got darcs yi to build once
14:35:08 <FordCortina> but that was some months ago
14:35:11 <sfultong> actually, I did, too... but now I can't build it
14:35:29 <FordCortina> yeh my subsequent attempts have always ended in failure :(
14:35:31 <mrd> i did once too, but the configuration broke
14:35:56 <monochrom> FordCortina: It's fine. You may also like zipWith (\x y -> abs(x-y)) xs (0:xs).
14:36:30 <FordCortina> thanks monochrom
14:37:19 <sfultong> I just don't seem to be getting a binary
14:37:29 <sfultong> so... maybe it's not linking?  and if so, I dunno why
14:39:15 <FordCortina> sfultong: now i remember
14:39:20 <FordCortina> on osx
14:39:21 <dons> @seen tibbe
14:39:22 <lambdabot> I saw tibbe leaving #haskell-soc, #xmonad, #ghc and #haskell 2h 46m 25s ago, and .
14:39:25 <dons> doh
14:39:29 <FordCortina> i ld would link the binary for some reason
14:39:37 <FordCortina> wouldnt*
14:39:46 <FordCortina> sry that doesnt help :(
14:40:22 <sfultong> ok, so at least we have the same problem :)
14:40:35 <dons> vincenz: hey, what would you recommend as the most fun stuff in the office to havE?
14:40:40 <dons> in zurich, i mean
14:40:56 <sfultong> FordCortina: I think that decreases our shared risk of incompetence, at least :-P
14:43:32 <vincenz> dons: good food?
14:43:58 <dons> galois' moving to a shiny new office, and we're thinking about what kind of recreation stuff to get. pooltable, foosball, et al.
14:44:12 <dons> i was wondering if the legendary zurich guys had recommendations.
14:44:26 <monochrom> Go.
14:44:30 <vincenz> dons: hmm, pool table, game room with xbox, fussbal, all great things
14:44:47 <monochrom> Have a large garden full of Go tables cast in stone.
14:44:54 <dons> monochrom: Go is already required, for the last few years
14:44:58 <vincenz> dons: decent coffee machine
14:45:15 <dons> yeah, our new italian espresso is plugged into the water mains. its a serious machine
14:45:16 <lament> wow, you have go in the office?
14:45:26 <dons> we have go in the old office.
14:45:31 <dons> people play the bos.
14:45:32 <dons> people play the boss
14:45:47 <lament> sounds dangerous
14:45:49 <lament> what if they win?
14:46:02 <dons> i don't know if that's happened.
14:46:09 <monochrom> A world-class auditorium (world-class acoustics) full of serious music instruments.
14:46:09 <dons> though simon marlow is pretty good, from what i hear
14:46:13 <lament> do they become the new boss? :)
14:46:29 <monochrom> Hell, build a cathedral next to the office building :)
14:46:30 <lament> monochrom: an organ!
14:46:32 <lament> yes
14:46:36 <dons> thanks monochrom
14:46:59 <monochrom> Invite Knuth to play the new organ at the opening ceremony. :)
14:47:00 <newsham> ?let unfoldrp p f = unfoldr (\x -> guard (p x) >> Just (f x))
14:47:01 <lambdabot> Defined.
14:47:06 <newsham> > unfoldrp (not.null) (splitAt 5) "this is a test"
14:47:07 <lambdabot>  ["this ","is a ","test"]
14:47:24 <monochrom> (As a side effect (heh heh), convert Knuth into FP. :) )
14:48:09 * sfultong wonders what music without side-effects would sound like
14:48:20 <monochrom> pure sine waves
14:49:05 <sclv_> anyone here have experience using HDBC with binary blobs in postgres databaes?
14:49:05 <lament> TAoFP
14:49:07 <sclv_> It looks broke.
14:49:52 <newsham> > unfoldrp (/= 0) ((\(a,b)->(b,a)).(`divMod` 10)) 12345
14:49:54 <lambdabot>  [5,4,3,2,1]
14:50:07 <newsham> ?hoogle (a,b) -> (b,a)
14:50:07 <lambdabot> No matches, try a more general search
14:50:42 <mauke> :t snd &&& fst
14:50:53 <lambdabot> forall a b. (a, b) -> (b, a)
14:51:08 <newsham> > unfoldrp (/= 0) ((snd&&fst).(`divMod` 10)) 12345
14:51:09 <lambdabot>  Couldn't match expected type `Bool'
14:51:18 <newsham> > unfoldrp (/= 0) ((snd&&&fst).(`divMod` 10)) 12345
14:51:19 <lambdabot>  [5,4,3,2,1]
14:51:41 <mauke> :t uncurry (flip (,))
14:51:49 <lambdabot> forall b a. (a, b) -> (b, a)
14:51:49 <newsham> > unfoldrp (/= 0) (`mod` 10 &&& `div` 10) 12345
14:51:51 <lambdabot>  Parse error at "`div`" (column 31)
14:52:01 <mrd> > map fst $ iterate (\ (a,b) -> (a+b,a)) (1,0)
14:52:03 <newsham> > unfoldrp (/= 0) ((`mod` 10) &&& (`div` 10)) 12345
14:52:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:52:12 <lambdabot>  [5,4,3,2,1]
15:01:58 <bos> andyjgill: how's kansas?
15:02:15 <andyjgill> Actually, not that flat.
15:02:23 <dons> hah
15:02:25 <Sadache> hello
15:02:48 <andyjgill> Real storms here, though.
15:02:54 <Sadache> I have a question about concurrent channels
15:03:22 <bos> Sadache: ok
15:03:23 <dons> andyjgill: yeah, i hear they have weather there, not just mist.
15:03:35 <dons> andyjgill: photos on the blog plz? :)
15:03:40 <andyjgill> dons: :-)
15:03:55 <andyjgill> Sure. I got snow in yellowstone.
15:04:10 <Sadache> I saw an example of using them in Hudak's book, and I had the impression that concurrent processes share mutable state
15:04:14 <Sadache> am i right?
15:04:43 <Socrates> http://xkcd.com/
15:04:43 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
15:04:55 <Socrates> I think computer science runs parallel to that line
15:05:21 <Sadache> when tow forked processers share a first class channel, they are sharing a kind of mutable state?
15:05:29 <Itkovian> Socrates: yeah ;-)
15:08:06 <Sadache> because a channel in that example is a queue that one processor adds to and the other reads from
15:08:39 <Sadache> sorry I meant process instead of processor
15:10:27 <Sadache> or is it like a lazy stream shared between processes?
15:12:43 <Sadache> ok seems no one got an answer, or someone is having lunch :)
15:14:17 <marcot> Hello there.
15:14:27 <marcot> Is there a package of ghc 6.8.2 for etch?
15:18:48 <Baughn> marcot: Debian? No.
15:18:55 <Baughn> marcot: Get the generic binary
15:19:11 <MyCatVerbs> marcot: http://www.nabble.com/Any-Debian-Etch-packages-for-GHC-6.8.2--td14676806.html <-- there's this, but it sounds like a lot of hassle.
15:19:14 <lambdabot> Title: Nabble - Haskell - Glasgow-haskell-users - Any Debian Etch packages for GHC 6.8. ..., http://tinyurl.com/6s63er
15:19:26 <marcot> I think I'll have to use lenny.
15:19:47 <marcot> MyCatVerbs: I've seen this thread, thanks.
15:19:52 <MyCatVerbs> marcot: if you have a reasonably fast machine and can afford to burn some CPU time, it's pretty easy to build yourself a copy of 6.8 from the sources provided you already have on of the 6.x line handy.
15:19:52 <Baughn> Installing things in /usr/local doesn't hurt
15:20:04 <MyCatVerbs> marcot: much easier than that thread sounds like, anyway.
15:20:17 <Baughn> marcot: Plus, debian tends to, er, put their own "spin" on things. Occasionally this breaks things.
15:20:27 <marcot> Yes..
15:20:29 <marcot> That's the problem.
15:20:43 <MyCatVerbs> marcot: if you don't want to build it yourself, I'd strongly advise you to use the generic binary off haskell.org - it should be completely hassle free.
15:20:45 <marcot> I think if I build it from source, or get the binary, I'll not be able to use other debian packages.
15:20:50 <marcot> I'll have to build it all...
15:21:30 <MyCatVerbs> marcot: AFAIK, Debian's packaging isn't particularly more convenient than building Cabal-ised libraries by hand anyway. Ubuntu's isn't, I can tell you.
15:21:48 <Baughn> marcot: That is not much of a problem these days, what with cabal-install
15:22:05 <marcot> MyCatVerbs: I think it depends on the package.. Some packages like gtk2hs take a long time to build.
15:22:08 <Baughn> marcot: And the debian packages are old enough that you won't be able to install anything /but/ the debian packages. Still, your choice
15:22:13 <marcot> Not to mention GHC itself.
15:22:28 <marcot> you're right.
15:22:39 <MyCatVerbs> marcot: none of them take more than a couple of hours on my machine (a cheap C2D with a lot of RAM).
15:23:14 <Baughn> That despite cabal not doing parallel builds. Got to fix that..
15:24:13 <MyCatVerbs> marcot: if you have anything with more than, say, a gig of RAM and an Opteron/Athlon or a Core/Core2 chip, then it shouldn't take more than an afternoon to build GHC and gtk2hs. The long parts you can just fire and forget anyway, go read slashdot while waiting, etc.
15:24:42 <marcot> Maybe it's a good idea to do this then.
15:25:49 <MyCatVerbs> Unless you really, really hate compiling things... I mean, I certainly would do it, but admittedly I'm a freak.
15:26:14 <Sadache> anyone can answer me a question about concurrent channels? I can reask the question...
15:27:04 <bos> Sadache: if threads share a Chan, yes, that's mutable.
15:27:14 <MyCatVerbs> Sadache: channels are FIFOs. Yes, they're mutable.
15:27:16 <monochrom> Yes, a channel is mutable state.
15:27:33 <Sadache> doesnt that violate the language?
15:27:35 <MyCatVerbs> Sadache: pretty much anything that needs to be in the IO monad is mutable, generally.
15:27:55 <monochrom> The channel operations are implemented so that sharing is safe.
15:28:01 <Baughn> Sadache: A Chan isn't itself mutable, but it contains a reference to something that, via the magic of functions in IO, mutates.
15:28:11 <Baughn> Sadache: And, No. IO is part of the language.
15:28:13 <MyCatVerbs> Sadache: no, not at all. It's kept in the IO monad, so it won't blow up pure computations, and all the operations on them are atomic.
15:28:46 <Baughn> Sadache: Though if you're stuck on how IO works, you probably shouldn't be touching impure threading yet
15:28:50 <Sadache> i know how monad works not to violate pure functions, but I couldnt figure out how channels and processes do
15:29:06 <Baughn> Well, how could they?
15:29:22 <MyCatVerbs> Sadache: because doing things to channels and processes are IO actions.
15:29:50 <MyCatVerbs> Sadache: think of Chans and MVars as descriptors.
15:30:23 <Sadache> ok I imagine IO monads as a discription, a kind of dsl that describe something to br executed later
15:30:30 <Baughn> Sadache: BEcause processes only communicate via IO, and are otherwise conceptually separate. (Not physically - GHC does some magic to let them share data/computations of pure functions)
15:30:50 <MyCatVerbs> @where awkward squad
15:30:50 <lambdabot> I know nothing about awkward.
15:31:13 <Sadache> i see
15:31:15 <MyCatVerbs> Sadache: SPJ gave a really good presentation on this. I'll dig it up for you.
15:31:22 <RayNbow> @pl (\f xs -> c (m f xs))
15:31:23 <lambdabot> (c .) . m
15:31:25 <Sadache> thank you for the answer
15:31:26 <MyCatVerbs> Sadache: http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:31:26 <Baughn> Sadache: That's one way. In fact, GHC has something a lot like "data IO a = IO (World -> (World, a))" in the code somewhere
15:31:26 <lambdabot> Title: Simon Peyton Jones: papers
15:31:59 <Baughn> Sadache: ..if it makes you feel better, you can imagine it doesn't. It doesn't /change/ anything.
15:32:03 <Botje> I assume goran got his free fish ?
15:32:06 <Sadache> ok, i guess that is exactly what i need
15:32:09 <MyCatVerbs> Sadache: it's about 60 pages, written in a fairly light style, not too dense. I'd advise you to read it, it makes things pretty clear.
15:32:25 <Sadache> actually I need conceptually to grasp all IO magic
15:32:40 <Sadache> so that I can think and build on it
15:32:56 <Sadache> I absolutely will
15:33:25 <Baughn> Sadache: The magic here is that IO "actions" are in fact impure functions, and the compiler is written very carefully so they never get executed out of order, or the wrong number of times
15:33:38 <Sadache> I like PSJ presentations by the way, I interviewed him in london in it was a pleasure
15:33:48 <monochrom> Botje: goran asked for free fish and got free starfish. he didn't seem to know the difference. :)
15:34:20 <Baughn> Sadache: The IO type not being exported then means you can't decompose it, so you can't get the functions out of the monad. But that's one way; building up a description of a program and feeding it to an interpreter is just as valid and, with some optimization, equivalent.
15:34:23 <Botje> one is yummy and the other has no central nervous system? :p
15:34:25 <vixey> Sadache: I was showed a very nice thing about IO
15:35:31 <Baughn> Sadache: The "World" type is a phantom, of course, but its existence forces a dependency that ensures the two properties I mentioned first - so long as the optimizer doesn't get /too/ clever. Lacking information about how "main" is used, it can't.
15:36:24 <Sadache> so the IO type doesnt carry any interesting information? or does it?
15:36:31 <Baughn> Reading about IO feels a bit like reading about why time travel doesn't work, to me. There's nothing /explicitly/ stopping it from working, but every time you propose a way to break the laws, some obscure rule gangs up on you and stops you
15:36:37 <vixey> Sadache: http://thepastesiteat.endoftheinternet.org:8080/paste/5 ~ you can think of the data IO, instance Mond IO, putChar and putString as the implementation of IO in a library,.. and the runIO as part of the compiler/interpreter that runs haskell
15:37:03 <MyCatVerbs> Sadache: it forces proper sequencing, though whether or not it contains any really juicy information is up to the compiler.
15:37:24 <MyCatVerbs> vixey: ooh, nice. And an interpreter is just: runIO main
15:37:26 <vixey> (implementing unsafePerformIO is left as an excersize...)
15:37:42 <vixey> MyCatVerbs: yes, it's brilliant because IO is just data, everything is pure :)
15:37:52 <Baughn> Sadache: As I said, it's "data IO a = IO (World -> (World,a))". The "World" type contains no data, since you have rather too little memory for that; a is of course the result of the action, and the /action/ itself is the (impure!) ->.
15:38:18 <Sadache> aha
15:38:27 <Baughn> Sadache: But that's an implementation detail. It's not exactly how it works, probably; it's not how it works at /all/ in other implementations; and you don't really need to know.
15:38:29 <MyCatVerbs> vixey: I can't quite figure out why, but it sort of vaguely -annoys- me that that works.
15:38:39 <vixey> hehehe
15:38:45 <Sadache> so IO can have so information that represent the state ?
15:38:56 <Baughn> It could.
15:39:08 <Baughn> Come to think of it, to implement something like IORef you could just stick a Map inside World
15:39:18 <Baughn> ..probably that's not what it does, but it /could/
15:39:26 <Sadache> ok ok
15:40:31 <MyCatVerbs> vixey: possibly because it's so beautiful, it had already occurred to me a while back, but I'd never thought to actually try formalising it.
15:40:31 <Baughn> The problem is for functions like getChar. The optimizer thinks it's a function of World; it doesn't know what World /is/, and has to pass it in to get the right value back out; but of course getChar doesn't actually read World, which is probably something like type World = ()
15:40:37 <Sadache> so can in large imagine a haskell program as a function that takes some parameters and returns actions(database or command output)?
15:40:52 <Baughn> Sure
15:41:18 <Baughn> That's one way IO could work. That's exactly the way many other monads /do/ work, like (I think!) Parsec
15:42:07 <Baughn> It certainly is how the opengl shader monad would work, assuming someone writes one. And that's very much IO.
15:43:42 <Sadache> does the compiler turn what is in the /do/ into a one expression?
15:44:51 <Sadache> what i mean is does the compiler (or runtime) fill fields and bound variables all in once?
15:44:51 <vixey> Sadache: do is like >>= or >>
15:45:04 <Baughn> @undo do { a <- foo; b <- bar; return $ baz a b } -- That'S a yes
15:45:04 <lambdabot> foo >>= \ a -> bar >>= \ b -> return $ baz a b
15:45:18 <Baughn> The above is then left to the optimizer to.. optimize
15:46:15 <Baughn> Sadache: It doesn't do anything that's in IO out of order, if that's what you're asking. That would be missing the point.
15:46:34 <Baughn> Sadache: If you have intensive calculations that would benefit from such.. move them into pure code.
15:46:54 <Sadache> but just curious, if I imagine a debugger, and I am testing what is inside a /do/
15:47:27 <Sadache> will the debugger stop on each step or does it stop on the expression as a whole
15:47:46 <Baughn> Each step. A haskell debugger that doesn't handle subexpressions would be useless.
15:48:06 <Sadache> in other words, does what is inside the /do/ only look imperative, or is it really imperative?
15:48:30 <Baughn> ..both?
15:48:30 <vixey> that's sort of hard to answer
15:48:39 <Baughn> A lot of the compiler doesn't know nor care that it's imperative
15:48:40 <vixey> I think that it really depends on what you see
15:48:57 <Baughn> It /ends up/ being imperative, but the debugger might not see it that way
15:49:05 <povman> I like to think that a Haskell program (main) is just a value, the same as 5 or "abc", and that once the program has returned, the IO value is then executed by the VM
15:49:15 <chessguy> 'evening
15:49:17 <Sadache> good that anwers my question
15:49:28 <vixey> povman: I like that view yes
15:49:33 <Baughn> povman: You'd be wrong, at least in the case of GHC
15:49:36 <Baughn> Good view, though
15:49:42 <Sadache> and you answered all my questions
15:49:49 <vixey> oh of course implementation is different
15:50:00 <vixey> It's a good abstraction though
15:50:18 <Sadache> you are amazing guys, I ve never got to such a nice community before
15:51:40 <Sadache> (I meant about the debugger you answered my question Baughn)
15:51:42 <povman> Baughn: I presume it would be lazier in reality?
15:52:46 <Baughn> povman: No, it's more imperative in reality. There is no VM; GHC uses impure functions and type tricks to keep IO behaving.
15:53:12 <Sadache> cant we instead of using concurrent magic channels between processes use lazy streams?
15:54:03 <Baughn> Yes
15:54:37 <Baughn> Chans can be more convenient, in that there can be multiple readers and writers, and you can check for emptiness
15:54:56 <Baughn> But yes, streams work. You can even build streams on top of Chans.
15:56:39 <Sadache> ah ok, and and does the process wait for the channel to be filled? like in lazy streams? I should try it maybe, tou couple to streams with one channel, one process adds and ther other retrieves
15:56:59 <Baughn> Sadache: Read the documentation. ;)
15:57:10 <Sadache> ok, I guess I asked too much questions, i am going to read SPJ paper
15:57:16 <Baughn> Chan documentation?
15:57:34 <Sadache> yes I will
15:57:39 <Baughn> Sadache: Certainly, reading an empty chan will block until it's nonempty, unless you used one of the actions that explicitly doesn't
15:57:43 <Sadache> thanks Baughn
15:57:53 <Baughn> Sadache: Writing to a full chan /doesn't/. Or rather, there aren't any full chans; they're unbounded.
15:58:08 <Sadache> great, i see why it can be more concinient than streams
15:58:17 <Baughn> Sadache: If that's a problem - to avoid infinite memory use, say - use MVars. In fact, if you don't know, use an MVar.
15:58:52 <Sadache> is it for mutable variable?
15:59:10 <Baughn> Nah, probably mutex'd variable or something
15:59:15 <Sadache> *concinient
15:59:28 <Baughn> ..convenient?
15:59:48 <Baughn> OTOH, you can use lazy streams in pure code. Don't forget that.
16:00:03 <Sadache> convenient
16:01:13 <Sadache> I tried to implement lazy streams and lazy pattern matching in C# but didnt completly succeed
16:01:37 <vixey> Sadache: I have implemented lazy pattern matching
16:01:49 <Sadache> I could calculate the fibs but it was not performant at all
16:01:54 <vixey> ah ok
16:01:57 <vixey> I have the same problem
16:02:01 <Baughn> Laziness is quite slow, yes
16:02:03 <Sadache> have you, do u have a link?
16:02:06 <Baughn> GHC does its very best to avoid it. ;)
16:02:09 <vixey> did you rewrite substitutions in your code?
16:02:16 <vixey> this is the reason mine is slow
16:02:31 <vixey> http://thepastesiteat.endoftheinternet.org:8080/paste/4
16:02:56 <vixey> the definition, whnf env (Case t ((p,t'):pts)) ... is the relevant one
16:03:02 <MyCatVerbs> Sadache: laziness is really _really_ slow if your optimizer can't see through it. GHC's can, because it's designed around being able to do optimizations in the presence of laziness. Implementations in other languages often don't.
16:03:19 <vixey> the rewrite is very slow I think
16:03:39 <vixey> if one could annotate the AST with substititions rather than rewriting I think it would give a big boost
16:03:44 <vixey> I haven't tried it though
16:04:01 <Sadache> I used the lazy lambda expressions in LinQ but it is not usable anyway
16:04:18 <Sadache> vixey: I agree
16:04:27 <Sadache> I ve got to go now
16:04:35 <mauke> BISMILLAH
16:04:39 <Sadache> thanks really
16:06:12 <vixey> that's a nice word
16:06:39 <dmwit> The paste site at the end of the universe is SLOW.
16:06:49 <dmwit> s/universe/internet/
16:08:28 <povman> anyone know when ghc 6.8.3 is meant to be released?
16:08:28 <dmwit> > ['0'..'9']
16:08:30 <lambdabot>  "0123456789"
16:09:02 <Baughn> > "0..9" -- I hope not
16:09:03 <lambdabot>  "0..9"
16:09:25 <dmwit> > zip (iterate (\s -> "s(" ++ s ++ ")") "z") ['0'..'9']
16:09:27 <lambdabot>  [("z",'0'),("s(z)",'1'),("s(s(z))",'2'),("s(s(s(z)))",'3'),("s(s(s(s(z))))",...
16:09:45 <dmwit> > zip (iterate (\s -> "s(" ++ s ++ ")") "z") ['0'..] -- vixey
16:09:46 <lambdabot>  [("z",'0'),("s(z)",'1'),("s(s(z))",'2'),("s(s(s(z)))",'3'),("s(s(s(s(z))))",...
16:09:54 <vixey> huh
16:10:49 <bos> povman: it was going to be "in a few days" two weeks ago. so ... soonish?
16:11:02 <Botje> > zip (iterate s z) [0..] :: [(Expr, Int)]
16:11:02 <lambdabot>  Couldn't match expected type `Expr -> Expr'
16:11:09 <Botje> > zip (iterate f z) [0..] :: [(Expr, Int)]
16:11:10 <povman> right
16:11:11 <lambdabot>  [(z,0),(f z,1),(f (f z),2),(f (f (f z)),3),(f (f (f (f z))),4),(f (f (f (f (...
16:11:23 <povman> > s
16:11:24 <lambdabot>  s
16:11:30 <povman> :t s
16:11:32 <lambdabot> Expr
16:11:39 <povman> ;-;
16:11:47 <Baughn> > iterate f s
16:11:48 <lambdabot>  [s,f s,f (f s),f (f (f s)),f (f (f (f s))),f (f (f (f (f s)))),f (f (f (f (f...
16:12:01 <Baughn> :t f
16:12:02 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:12:55 <povman> what's fromexpr?
16:13:47 <povman> and expr
16:14:01 <Baughn> class FromExpr a where fromExpr :: Expr -> a
16:14:04 <Botje> @where simplereflect
16:14:04 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
16:14:26 <Botje> it's an ingenious abuse of typeclasses
16:14:42 <Baughn> Now, now. I wouldn't call it "abuse"
16:17:27 <povman> > g
16:17:28 <lambdabot>  Add a type signature
16:17:32 <Baughn> :t g
16:17:33 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:17:37 <povman> aha
16:17:39 <Baughn> > fromExpr g
16:17:40 <lambdabot>   Not in scope: `fromExpr'
16:17:53 <povman> > print g
16:17:54 <lambdabot>  Add a type signature
16:17:57 <Baughn> > g :: Expr
16:17:58 <lambdabot>  g
16:18:16 <povman> ok that is scary
16:18:24 <Baughn> > g :: (Expr -> Expr)
16:18:25 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
16:18:28 <Botje> > foldr1 f [1..5] :: Expr
16:18:29 <lambdabot>  f 1 (f 2 (f 3 (f 4 5)))
16:18:38 <Botje> > foldl1 f [1..5] :: Expr
16:18:45 <lambdabot>  f (f (f (f 1 2) 3) 4) 5
16:18:45 <Baughn> :t f
16:18:45 <Botje> yay for practical value!
16:18:46 <Baughn> :t f 1
16:18:50 <lambdabot> forall t t1. (SimpleReflect.FromExpr (t -> t1), Num t) => t1
16:18:50 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:19:18 <mauke> > foldr1 f [1..5]
16:19:19 <lambdabot>  Add a type signature
16:19:30 <Baughn> Okay. So, neglecting that it's out of order, f 1 works because the intersection of FromExpr and Num is small enough to let it default
16:19:47 <Baughn> ..GHC is scarily smart at times
16:19:48 <povman> :t fun
16:19:50 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
16:20:01 <roconnor> > zygohistomorphic_prepromorphism f
16:20:02 <lambdabot>   Not in scope: `zygohistomorphic_prepromorphism'
16:20:03 <Baughn> > fun "fo" $ 4
16:20:04 <lambdabot>  Add a type signature
16:20:08 <Baughn> > fun "fo" $ 4 :: Expr
16:20:10 <lambdabot>  fo 4
16:21:07 <Baughn> :t f
16:21:09 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:21:11 <Baughn> :t fun "f"
16:21:13 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:21:17 <Baughn> > f
16:21:18 <lambdabot>  Add a type signature
16:21:18 <Baughn> > f 4
16:21:19 <lambdabot>  Add a type signature
16:21:31 <Baughn> ..didn't that work two minutes ago?
16:21:41 <vixey> > f x
16:21:41 <Baughn> Oh. No. I used :t.
16:21:42 <lambdabot>  Add a type signature
16:21:46 <vixey> > f x  :: Expr
16:21:47 <lambdabot>  f x
16:21:50 <mauke> > f ()
16:21:51 <lambdabot>  Add a type signature
16:21:55 <mauke> I see
16:22:01 <mauke> > f () "" 42 :: Expr
16:22:02 <lambdabot>  f () "" 42
16:22:16 <Maciej> > sum [1..5]
16:22:17 <lambdabot>  15
16:22:25 <Baughn> It doesn't know how many arguments f takes until you tell it, I guess. :P
16:22:25 <Maciej> > sum [1..5] :: Expr
16:22:26 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
16:22:33 <fUD> hey
16:23:03 <vixey> > sum . map product $ iterate (drop 1) [1..]
16:23:03 <Baughn> mauke: Is that the same trick printf uses?
16:23:13 <mauke> Baughn: I think so
16:23:15 <lambdabot> Terminated
16:23:34 <mauke> > tails [1..]
16:23:35 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:23:45 <mauke> > tails "[1..]"
16:23:47 <lambdabot>  ["[1..]","1..]","..]",".]","]",""]
16:24:04 <povman> why do people keep putting things in ""
16:24:23 <mauke> because [1..] isn't instructive
16:24:24 <dmwit> For the halibut.
16:24:54 <shapr> FUNCTIONAL FISK!
16:24:59 <Baughn> For small yet tenous justice?
16:25:09 <shapr> tenuous?
16:25:09 <dancor> it seems like you "should" be able to write  memoize :: (a -> b) -> a -> b
16:25:22 <mauke> dancor: and how do you compare arbitrary a?
16:25:39 <vixey> dancor: I don't think that's possible (without using unsafePerformIO)
16:25:44 <dancor> mauke: ok maybe Eq a too
16:25:48 <vixey> and demanding Eq on a or something like that as well
16:25:52 <povman> dancor: it would need to have side effects
16:25:53 <mauke> you want at least Ord
16:25:56 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
16:25:59 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:26:04 <dancor> povman: yeah but they are like "internal" side effects, you know
16:26:04 <dmwit> See memofix there.
16:26:08 <Baughn> dancor: That isn't possible in any language
16:26:12 <povman> oic
16:26:20 <ricky_clarkson> @hoogle uniq
16:26:20 <lambdabot> Language.Haskell.TH.Syntax.Uniq :: type Uniq
16:26:20 <lambdabot> Data.Unique :: module
16:26:20 <lambdabot> Data.Unique.Unique :: data Unique
16:26:28 <Baughn> dancor: Consider just how little information that type signature gives. You need at least /some/ constraints, or you can't store data to recover later
16:26:34 <ricky_clarkson> How would you remove duplicates from a list?
16:26:40 <mauke> nub
16:26:42 <shapr> @users
16:26:42 <lambdabot> Maximum users seen in #haskell: 452, currently: 426 (94.2%), active: 21 (4.9%)
16:26:50 <Baughn> ricky_clarkson: How large is the list?
16:26:59 <ricky_clarkson> length xs
16:27:03 <Baughn> ricky_clarkson: nub is possible. Piping through Set is faster, especially for large lists
16:27:16 <mauke> > nub [1..]
16:27:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:27:19 <vixey> ?yow
16:27:19 <lambdabot> On the road, ZIPPY is a pinhead without a purpose, but never without a POINT.
16:27:30 <mauke> Baughn: make that faster with Set :-)
16:27:33 <ricky_clarkson> :t nub
16:27:35 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:27:37 <Baughn> ricky_clarkson: ..but as mauke points out, nub works on more types
16:27:48 <mauke> ... types?!
16:27:49 <ricky_clarkson> > nub [1,1..]
16:27:51 <dmwit> s/types/values/
16:27:53 <lambdabot>  [1
16:28:10 <ricky_clarkson> > nub [1,1,1,1,2]
16:28:12 <lambdabot>  [1,2]
16:28:16 <ricky_clarkson> @src nub
16:28:16 <lambdabot> nub = nubBy (==)
16:28:22 <ricky_clarkson> @src nubBy
16:28:23 <lambdabot> nubBy eq []             =  []
16:28:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:28:34 <ricky_clarkson> Is that n^2 in memory?
16:28:40 <vixey> yes
16:28:49 <Baughn> @msg cale Lambdabot's odd unreliability is starting to bug me - I think it's my fault. Could I get SSH access to the machine it's on to experiment a bit?
16:28:49 <lambdabot> Not enough privileges
16:28:51 <vixey> oh wait no
16:29:05 <vixey> it's n^2 in time, n in sapce
16:29:05 <ricky_clarkson> Baughn: How would you write the version that pipes through a Set?
16:29:14 <dmwit> toList . fromList
16:29:15 <dancor> i guess the real big problem is that memoize has to peak inside the function f and change when it calls itself
16:29:15 <Baughn> ricky_clarkson: (toList.fromList)
16:29:20 <povman> shouldn't GHC be able to calculate nub [1,1..] through induction?
16:29:23 <Baughn> dancor: That too
16:29:35 <dancor> that seems like the biggest deal-breaker
16:29:39 <Baughn> dancor: That, and it has to store the values and look them up later, which at least requires Eq a - more likely Ord
16:29:40 <dmwit> povman: There is no requirement that 1 == 1.
16:29:51 <vixey> povman: [1,1..] is no different to [1,1,1,1,1,1,1]++[1,1,..] or any other computation which produces the same
16:30:11 <dancor> Baughn: yeah i don't really care what constraints we need for a
16:30:17 <povman> i meant a special case for that syntax
16:30:26 <Baughn> povman: GHC isn't meant to solve that sort of thing. There are a million special cases to deal with, and the implementors would rather deal with things that have real-life meaning
16:30:47 <vixey> special cases are nasty.
16:30:52 <povman> Baughn: oh yeah, reality ...
16:30:52 <Baughn> dancor: Then, a bit of unsafePerformIO will do you good. It's perfectly safe, used right.
16:30:55 <MyCatVerbs> dmwit: uh, instances of Eq *are* required to satisfy (\f -> f == f) equivalent to (\f -> f `seq` True)
16:31:12 <dmwit> > (1 / 0) == (1 / 0)
16:31:14 <lambdabot>  True
16:31:25 <mauke> > (\f -> f == f) (0/0)
16:31:27 <lambdabot>  False
16:31:38 <Cale> > (\f -> f `seq` True) (0/0)
16:31:39 <lambdabot>  True
16:31:39 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:31:52 <MyCatVerbs> mauke: NaN is a widely known degenerate case. ;P
16:32:03 <Baughn> povman: Think about it this way. nub [1,1..] fails, but instead ghc can run infinite loops in two seconds flat and compete with C on inner-loop speed.
16:32:13 <Cale> Baughn: It's not my machine... uh... who knows how to give someone an account on code.haskell.org?
16:32:15 <MyCatVerbs> mauke: excusable because, from a numerical processing perspective, NaN is _|_. So there. ;P
16:32:50 <povman> Baughn: nub [1,1..] is an infinite loop :p
16:32:55 <Cale> Perhaps dcoutts or dons can?
16:33:04 <Baughn> Cale: I /could/ use the one you're using, though I'll understand if you don't want to risk that. It's probably an ulimit thing.
16:33:11 <Cale> > head (nub [1,1..])
16:33:13 <lambdabot>  1
16:33:19 <Cale> povman: not quite :)
16:33:27 <Baughn> povman: Yes, and lambdabot just ran it in two seconds flat. ;)
16:33:27 <augustss> MyCatVerbs: where does it say that instances of Eq have to satisfy that property?
16:33:37 <povman> > nub [1,1..]
16:33:39 <lambdabot>  [1
16:33:43 <povman> ahem.
16:33:49 <Baughn> What? It finished. Fast.
16:34:09 <Cale> Wait, that was the code.h.o lambdabot?
16:34:25 <MyCatVerbs> augustss: everywhere where a formal definition of equality is defined? It's a pretty common assumption in mathematics.
16:34:28 <Baughn> Also, note how it's leaving empty space in your irc log to fill in lazily at a later date.
16:34:56 <eu-prleu-peupeu> is there any way to generate java bytecode from haskell ?
16:35:02 <MyCatVerbs> augustss: it's certainly required by the definition of an equivalence relation, which equality is conventionally assumed to be.
16:35:02 <Baughn> Cale: ..wherever it's running, I want to fix it. The code obviously makes erronous assumptions somewhere, and it works perfectly on my machine.
16:35:11 <augustss> MyCatVerbs: Sematic equality has to satisfy some laws, but the is the Haskell Eq class.
16:35:12 <povman> ych?
16:35:21 <povman> yhc
16:35:35 <roconnor> > compare (1/0) (1/0)
16:35:36 <lambdabot>  EQ
16:35:38 <vixey> eu-prleu-peupeu: Lambda vm says it can do that
16:35:45 <roconnor> > compare (0/0) (0/0)
16:35:46 <lambdabot>  GT
16:35:58 <augustss> MyCatVerbs: I'd argue that a congruence relation is better than an equivalence relation, but that's beside the point.
16:36:06 <Cale> eu-prleu-peupeu: Not as far as I know, at the moment.
16:36:11 <Cale> er...
16:36:39 <dmwit> > undefined == undefined :: ()
16:36:39 <lambdabot>  Couldn't match expected type `()' against inferred type `Bool'
16:36:44 <dmwit> > undefined == (undefined :: ())
16:36:45 <lambdabot>  Exception: Prelude.undefined
16:36:46 <aCiD2> Hi there, I'm a bit new to Haskell and learning it for project Euler (great fun!) - but I'm struggling to understand the cause of this error: http://paste.lisp.org/display/62147
16:36:47 <dmwit> dang
16:36:53 <FordCortina> is there a way to use the function "iterate", but only take up to a point where the difference between successive values has dropped beneath a certain threshold?
16:37:02 <eu-prleu-peupeu> hmm
16:37:06 <aCiD2> Any ideas? I assume the ambiguity is between Integral and RealFrac, but I don't understand why it's ambiguous
16:37:07 <Cale> FordCortina: yes.
16:37:09 <Baughn> > let a = undefined :: () in a == a
16:37:10 <lambdabot>  Exception: Prelude.undefined
16:37:14 <FordCortina> ordinarily I'd use takeWhile
16:37:16 <FordCortina> but
16:37:19 <augustss> FordCortina: No super easy way
16:37:24 <FordCortina> that only works for one value
16:37:37 <FordCortina> not adjacent value
16:37:41 <Cale> FordCortina: zip the list with the list of differences of successive elements
16:37:42 <dmwit> aCiD2: Choose an instance of Integral and RealFrac, if you can find one.
16:37:57 <vixey> aCiD2: I think you could remove round and use `div` instead of /
16:38:01 <dmwit> aCiD2: Otherwise, fix your function to not use (/).
16:38:10 <Cale> FordCortina: and then use takeWhile :)
16:38:12 <aCiD2> Ok, thanks :)
16:38:20 <vixey> although you might get rounder erros..
16:38:43 <augustss> FordCortina: Or zip the list with itself, but the first element removed
16:38:58 <aCiD2> I'm just playing around to see if this ratio does work out - it "sort of" works on paper, hoping computing it will help me understand if I'm going the wrong way
16:39:02 <aCiD2> anayway, thanks for the pointers
16:39:03 <aCiD2> !
16:39:10 <FordCortina> augustss: I have been trying that
16:39:19 <povman> you can simulate pointers with IORef
16:39:21 <dmwit> > let roundDiv a b = (a + b `div` 2) `div` b in 1 `roundDiv` 3
16:39:22 <lambdabot>  0
16:39:23 <Cale> aCiD2: Integers don't support /
16:39:27 <dmwit> > let roundDiv a b = (a + b `div` 2) `div` b in 2 `roundDiv` 3
16:39:28 <lambdabot>  1
16:39:49 <Cale> aCiD2: Yeah, you need to use div or quot, or convert to a fractional type of number and use / then
16:39:51 <dmwit> aCiD2: Yep, you should use integer arithmetic the whole time.  There's an example if you really need "round" instead of "floor".
16:40:14 <aCiD2> Thanks, I didn't know about the integer arithmetic functions, going to search about them now
16:40:36 <FordCortina> part of the problem is that its not just a simple list
16:40:37 <augustss> FordCortina: \ xs -> map snd $ takeWhile (not . uncurry approxEq) $ zip xs (tail xs)
16:41:12 <FordCortina> but a list of maps and its the differences between intersecting values in the map which cause termination
16:41:12 <dmwit> map snd . takeWhile (not . uncurry approxEq) . ap zip tail
16:50:51 <FordCortina> ah i seem to have got it. even with my wierd data struture :)
16:52:54 <augustss> It shouldn't really matter what you compare
16:58:53 <MyCatVerbs> @pl \f -> \l -> zipWith f l (tail l)
16:58:53 <lambdabot> (`ap` tail) . zipWith
16:59:07 <MyCatVerbs> @pl \l -> zipWith f l (tail l)
16:59:07 <lambdabot> ap (zipWith f) tail
16:59:40 <MyCatVerbs> Lambdabot -really- seems to like that ol' ((->) a) monad.
17:00:00 <tusho> I don't get the ((->) t) monad.
17:00:02 <tusho> I mean.
17:00:13 <tusho> I get it.
17:00:13 <tusho> But how is it Reader?
17:00:13 <mauke> how is it not?
17:00:15 <mauke> @src Reader
17:00:15 <lambdabot> Source not found. You untyped fool!
17:00:15 <tusho> @src read
17:00:15 <lambdabot> read s = either error id (readEither s)
17:00:18 <tusho> err.
17:00:20 <tusho> @src ask
17:00:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:00:32 <mauke> newtype Reader e a = Reader { runReader :: e -> a }
17:00:36 <dmwit> ask = id
17:00:47 <mauke> therefore Reader = (->)
17:01:26 <tusho> meh, ok
17:01:28 <tusho> :P
17:08:19 <dmwit> Huh, I've never had to pronounce the '`' character.
17:08:26 <povman> tick
17:08:29 <dmwit> I guess I would say "lower-case tilda"?
17:08:35 <mauke> backtick
17:08:36 <Draconx> grave, backquote...
17:08:37 <augustss> backquote
17:08:39 <povman> or backtick
17:08:53 <dmwit> backquote/backtick sound nice
17:08:56 <mauke> "qx"
17:08:57 <monochrom> Do not try to pronounce haskell code. You are not a modem.
17:09:13 <mauke> preflex: remember monochrom Do not try to pronounce haskell code. You are not a modem.
17:09:19 <monochrom> hehe
17:09:35 <povman> what.
17:09:44 <dmwit> preflex: be monochrom
17:09:44 <preflex>  Do not try to pronounce haskell code. You are not a modem.
17:09:51 <povman> haha
17:10:08 <mauke> preflex: quote
17:10:08 <preflex>  <zhivago> what terrible attrocity against logic are you committing today?
17:10:44 <Saizan> preflex: quote
17:10:44 <preflex>  <cale> Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together.
17:11:32 <augustss> preflex?
17:11:53 <mauke> my bot
17:12:27 <augustss> ah
17:12:41 <augustss> but that doesn't explain the name
17:13:18 <mauke> markov generator + /usr/share/dict/words
17:13:39 <dmwit> nice
17:14:01 <augustss> heh
17:14:01 <dmwit> + mauke's taste in names, I guess ;-)
17:14:39 <mauke> "carnary" is also good
17:16:43 <MarcWeber> Is anyone using hdbc-odbc ?
17:17:02 <MarcWeber> I've trouble setting up a connection. isql <conn name > works fine
17:17:42 <MarcWeber> Which is the ocnnection string to pass?
17:27:30 <Elly> how does one invoke cabal? I installed haskell-devscripts and ghc6 from apt (the only packages that match a search for cabal), but I have nothing called cabal in my path
17:28:30 <MarcWeber> You don't invoke Cabal. CAbal is a library used to compile the Setup.[l]hs file shipping with the lib/ executable you'd like to compile.
17:28:41 <mauke> there's also a cabal executable
17:28:41 <MarcWeber> ghc --make -o setup Setup./.[l]hs.
17:28:49 <mauke> why -o setup?
17:29:01 <Elly> MarcWeber: ahh
17:29:03 <mauke> ghc --make Setup
17:29:18 <Elly> MarcWeber: I thought it operated like apt :P (I was trying 'cabal install quickcheck')
17:29:22 <MarcWeber> mauke: Why not? ./setup is more convinient to type than ./Setup :-)
17:29:53 <povman> i usually do: runhaskell Setup.lhs
17:29:53 <MarcWeber> That's what cabal-install should do
17:30:08 <mauke> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
17:30:08 <Elly> I have nothing starting with 'cabal'
17:30:10 <lambdabot> Title: CabalInstall - Hackage - Trac
17:30:18 * Elly is trying to build darcs 2.0.0
17:30:37 <mauke> I can give you a generic cabal Makefile :-)
17:30:44 <Elly> I'm missing deps though
17:30:53 <Elly> I'm finding them out one by one and installing them with apt
17:31:14 <mauke> http://mauke.ath.cx/stuff/haskell/Makefile
17:31:35 <mauke> makes installing a downloaded library as easy as 'make install'
17:39:24 <Elly> hm...darcs still won't make
17:39:31 <Elly> now it dies building the documentation
17:39:59 <povman> \help leave
17:40:07 <povman> bah
17:40:15 <povman> too much \LaTeX
17:48:20 <mxc_> interesting, if massively off topic http://blogs.sun.com/jonathan/entry/not_a_flash_in_the
17:49:39 <Elly> "Its price sits squarely between DRAM and traditional disk drives. But unlike either alternative, Flash requires no power to remember data."
17:49:42 <Elly> ...?
17:49:57 <Elly> I've distinctly unplugged a traditional hard disk before, and it still had data on it afterwards...
17:50:07 <mxc_> i think he means while mounted but not in use
17:50:16 <Elly> again...
17:50:25 <SamB> mxc_: disks need to spin up
17:50:27 <SamB> er.
17:50:29 <SamB> elliottt:
17:50:29 <mxc_> exactly
17:50:32 <SamB> er. Elly
17:50:35 <mauke> tabwned
17:51:00 <mxc_> i'm pretty sure they need to be constantly spinning in most servers, even if only being accessed 10% of the time
17:51:25 <SamB> they'll certainly tend to be
17:51:35 <Elly> oh, I see what he means then
17:51:59 <Elly> I read this entire essay as "Oh god, won't somebody please use ZFS? Please?"
17:52:07 <mxc_> elly> to be fair, you're right, its not what he wrote explicitly, but i'm taking a leap of faith that he knows the basic mechanics of a hard drive
17:52:15 <mxc_> i thought ZFS was supposed to be pretty good
17:52:23 <SamB> doesn't stop him from having a thinko
17:52:34 <Elly> I also hear nice things about zfs
17:53:19 <mxc_> did they take the "murders your wife" feature out of http://en.wikipedia.org/wiki/Comparison_of_file_systems?
17:53:23 <mxc_> http://en.wikipedia.org/wiki/Comparison_of_file_systems
17:53:25 <mxc_> looks like it
17:53:31 <Elly> it's still in the history somewhere
17:53:41 <SamB> heh
17:54:24 <Elly> what does Sun actually sell now? all their software seems to be open-source
17:54:32 <mxc_> http://en.wikipedia.org/w/index.php?title=Comparison_of_file_systems&oldid=218189512
17:54:32 <bd_> mxc_: http://en.wikipedia.org/w/index.php?title=Comparison_of_file_systems&oldid=218243338
17:54:33 <lambdabot> http://tinyurl.com/5bubut
17:54:33 <lambdabot> http://tinyurl.com/67722s
17:54:46 <mxc_> elly - i was wondering the exact same thing. how do they make money?
17:54:52 <bd_> HFS+: Partial XD
17:54:55 <Elly> maybe they do consulting or still sell hardware
17:55:45 <Elly> *do* they still sell hardware? o_O
17:55:52 <Elly> all the sun boxes we have at work are old
17:56:03 <mxc_> elly? i'm pretty sure they *want* to sell it
17:56:11 <mxc_> s/?//
17:56:16 <MyCatVerbs> Elly: Sun sells hardware.
17:56:20 <Elly> ah, okay
17:56:32 <MyCatVerbs> Elly: they've all those T1 chips, an awful lot of servers.
17:56:44 <MyCatVerbs> Elly: they're still (!) selling UltraSPARCs, though I don't think very many.
17:57:04 <Elly> man
17:57:06 <MyCatVerbs> Elly: I think they also sell some software, around Solaris development, but I might be wrong.
17:57:14 <Elly> if Intel tried to sell machines that old, they'd get laughed out of the market
17:57:24 <MyCatVerbs> Elly: uh.
17:57:40 <MyCatVerbs> Elly: these are updated UltraSPARC designs. Pretty quick.
17:58:03 <Elly> oh, that makes way more sense
17:58:14 <Elly> I was thinking they were still selling UltraSPARC Is or something
17:58:18 <MyCatVerbs> On modern silicon, etc. Just not as quick as, say, current POWER or x86 chips.
17:58:31 <MyCatVerbs> Hahaha, no. They're up to something like... lemme check.
17:59:24 <MyCatVerbs> UltraSPARC III is on its way out, UltraSPARC IV is on its way in, more or less.
18:00:13 <MyCatVerbs> Anyway. Like a lot of companies now, they've shifted into what you might call the "whole enterprise systems" if you worked in marketing.
18:00:27 <Elly> fortunately for me, I don't
18:00:47 <MyCatVerbs> That is, they sell to big customers (governments, etc) a whole pile of everything, from the hardware up to bespoke software.
18:01:03 <Elly> "vertical integration"
18:01:19 <MyCatVerbs> Okay, -that- is a proper marketroid term. ;)
18:02:03 <MyCatVerbs> They might not always sell the -whole- stack in every case, but they are selling software development, systems analysists, etc. Lotta consultingware and support revenue.
18:02:18 <Elly> yeah
18:02:29 <Elly> I had a company that does that try to hire me at a school career fair thing
18:02:42 <Elly> they were like "We sell integrated supply chain management software" and I started to walk away
18:02:54 <MyCatVerbs> Same business IBM and I think HP are mostly in these days.
18:02:56 <Elly> and they shouted, as if it was a huge selling point: "It's in our own language! It's a mix of C and PL/SQL!"
18:03:08 <MyCatVerbs> Ohhh... heh.
18:03:11 <ddarius> And you started running?
18:03:20 <Elly> by then I was hiding behind the general dynamics booth
18:03:24 <MyCatVerbs> Hahahaha.
18:03:36 <shapr> haha
18:03:37 <Elly> I only talked to them in the first place because they looked lonely and were giving out trinkets
18:03:42 * shapr laughs more
18:04:47 <MyCatVerbs> You realize that running like that probably wounded their egos even deeper? ;)
18:04:56 <Elly> I didn't feel bad about it any more
18:04:58 <MyCatVerbs> Or was that the goal? I will be impressed if it was. :D
18:05:07 * MyCatVerbs nearly falls off his chair.
18:05:19 <Elly> anyone who would spend 25 years of their life buying supply-chain management software and gluing it together for sale
18:05:22 <Elly> has no soul left anyway
18:05:29 <Elly> so I have a karmic get-out-of-jail-free card
18:05:45 <MyCatVerbs> Wait, _buying_.
18:05:51 <Elly> ya
18:05:55 <Elly> they bought other people's software
18:05:59 <MyCatVerbs> Now, developing large chunks of the chain, that I could see as a pretty decent business.
18:06:01 <Elly> and glued it together in "C+PL/SQL"
18:06:03 <Elly> then sold it
18:06:16 <Elly> it sounded like the most miserable possible business
18:06:19 <MyCatVerbs> Just buying it up and sticking it all together... not so much of a value-add there.
18:06:23 <Elly> and they were based in wisconsin or something
18:06:36 <MyCatVerbs> What's the issue with Wisconsin?
18:06:54 <Elly> nothing, it's just not as nice of a place as the other places :P
18:07:04 * MyCatVerbs is on the wrong side of the Pond to know why that should be a good or bad thing.
18:07:04 <ddarius> Why would you use "C+PL/SQL" to do that anyway?
18:07:12 <Elly> I've never actually been to wisconsin, but I'd be surprised if it's nicer than santa barbara
18:07:18 <Elly> ddarius: I don't know!
18:07:46 <MyCatVerbs> Elly: because you need it to be just as fast as PL/SQL, but you really need the flexibility and programmer-friendliness of C?
18:08:00 <MyCatVerbs> Er, meant to aim that at ddarius, sorry.
18:08:08 <shapr> I spent a week in Wisconsin. It's not that bad.
18:08:24 <shapr> Admittedly, I've never been to Santa Barbara.
18:08:36 <Elly> santa barbara is a town on the beach in california
18:08:42 <Elly> it has been 75F for the entire two weeks I've been here
18:08:45 <Elly> and sunny
18:08:55 <Elly> http://www.redprairie.com/technology.aspx?lid=1 <--- this is them
18:08:57 <shapr> Yeah, I know where it is :-)
18:09:34 <Elly> this job is ridiculously sweet :P
18:09:35 <ddarius> 75 is the low where I am.
18:09:46 <Elly> ddarius: 75 is the temperature here
18:09:47 <shapr> I lived in CA for six months.
18:11:30 <nus> I wouldn't be surprised to find that some companies still sell Cobol+PL/I "integration" [-:
18:11:40 <shapr> Wouldn't be surprised if they make money too.
18:11:53 <SamB> I wouldn't be surprised if it was still useful
18:12:10 <marko> hi all
18:12:25 <SamB> all doesn't seem to be here right now
18:12:29 <ddarius> Ask Ralf Laemmel
18:12:29 <nus> SamB, of course it's useful "Just think of RoI" [[-:
18:12:34 <vixey> I am here
18:12:55 <mar77a> aw no one answered my question
18:12:58 <mar77a> time to reformulate
18:13:10 <mar77a> wait
18:13:12 <shapr> Hiya marko
18:13:13 <mar77a> hah i think i solved it
18:13:22 <mar77a> sec!
18:13:30 <mar77a> oh nvm i didn't
18:13:45 <mar77a> so i have a ascii file parsing function of the form f <filename> that returns a list
18:13:57 <mar77a> it literally returns it
18:14:14 <mauke> f :: String -> IO [a]
18:14:17 <mar77a> so, i want to work with multiple files, specifically all say, *.txt files from the current working directory
18:14:21 <mar77a> exactly
18:14:50 <mauke> getTextFiles :: String -> IO [String]
18:15:14 <vixey> :t mapM
18:15:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:15:18 <mar77a> i'm just worried my line of thinking is too imperative and i can't see the haskell way
18:15:19 <mauke> mapM f (getTextFiles ".")
18:15:38 <mar77a> how'd that work?
18:15:42 <mar77a> ah
18:15:46 <mar77a> it'd return multiple lists
18:15:52 <mar77a> what i'd like to do is join them afterwards
18:15:55 <mar77a> ++ perhaps?
18:16:00 <mauke> :t concatMapM
18:16:02 <lambdabot> Not in scope: `concatMapM'
18:16:13 <mauke> liftM concat (mapM f (getTextFiles "."))
18:16:28 <mar77a> liftM strikes again and i still have no clue what it does
18:16:36 <vixey> :t liftM
18:16:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:16:38 <dobblego> do you know what fmap does?
18:16:43 <mar77a> neither
18:16:45 <mauke> do you know what map does?
18:16:48 <mar77a> yes
18:16:54 <vixey> look at the type
18:16:57 <mauke> fmap is a generalization of map
18:17:03 <mauke> :t map
18:17:05 <dobblego> ?type map
18:17:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:17:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:17:12 <mauke> hargh
18:17:13 <EvilTerran> doh!
18:17:13 <dobblego> ?type map :: (a -> b) -> [a] -> [b]
18:17:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:17:18 <mauke> :t P.map
18:17:18 <SamB> Cale: you've made your point!
18:17:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:17:21 <vixey> @quote fugue
18:17:21 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:17:26 <dobblego> ?type fmap :: (a -> b) -> f a -> f b
18:17:27 <lambdabot>     Could not deduce (Functor f) from the context ()
18:17:27 <lambdabot>       arising from a use of `fmap' at <interactive>:1:0-3
18:17:27 <lambdabot>     Possible fix:
18:17:48 <mauke> mar77a: so anyway, map takes a function and a list of args, and returns a list of results
18:17:48 <Cale> SamB: What point?
18:17:52 <dobblego> ?type map :: (a -> b) -> [] a -> [] b
18:17:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:17:57 <SamB> Cale: with map
18:17:58 <mar77a> right
18:17:59 <SamB> and (.)
18:18:09 <mauke> mar77a: fmap allows other data structures than lists
18:18:12 <Cale> Huh?
18:18:24 <mauke> > fmap (* 2) (Just 21)
18:18:25 <lambdabot>  Just 42
18:18:27 <SamB> Cale: the funky types are getting in our way again
18:18:35 <dobblego> mauke, we have a beginner who understands map, but not fmap; and we are trying to explain the distinction
18:18:49 <mauke> dobblego: hi!
18:18:51 <vixey> they need to look at the type of liftM
18:18:55 <dobblego> hello mauke :)
18:19:00 <vixey> not map on lists
18:19:00 <vixey> a
18:19:15 <mauke> mar77a: you with me?
18:19:28 <Cale> :t Prelude.map
18:19:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:19:30 <mar77a> the code i have so far is http://alb.u13.net/~mar77a/hs/hparse/hparse.hs as you can see i can parse a single file there ..but
18:19:41 <vixey> > (liftM (+1)) [1,2,3]
18:19:42 <lambdabot>  [2,3,4]
18:19:47 <vixey> > (liftM (+1)) (Just 3)
18:19:48 <lambdabot>  Just 4
18:19:59 <edward1> ddarius: i was wrong the other day w.r.t the correct representation for for the final dialgebra with respect to the dianamorphism stuff. the version i came up exists because you can compose with a particular f,g-dialgebra-homomorphism, but its doesn't describe a final f,g-dialgebra. 'strip' is still a useful operation but its not the final dialgebra.
18:20:01 <mar77a> i'm missing something important here
18:20:14 <vixey> mar77a: Do you get the type of liftM?
18:20:24 <mar77a> not really
18:20:41 <vixey> I look at it like this: (a -> b) -> (m a -> m b)
18:21:01 <vixey> m could be []'s Maybe's, or anything like that
18:21:06 <edward1> a final f,g-dialgebra would look like: out :: f (Nu f g) -> g (Nu f g), which clearly cannot exist in general for all f and g
18:21:29 <mar77a> argh
18:21:32 <mar77a> gotta run
18:21:48 <mar77a> i'll ttyl vixey ..possibly tomorrow if you're around
18:21:49 <mar77a> ty
18:21:58 <edward1> so it has to be specialized into a typeclass somehow or passed around as an argument.
18:23:39 <ddarius> edward1: Or potentially you could restrict f and g enough such that it always exists, though that would probably be more restrictive.
18:24:51 <edward1> that said, while i may not be able to construct the final dialgebra, but I _can_ always define the output as if you had pre or post-composed with the unique f,g-dialgebra homomorphism to the non-constructible final f,g-dialgebra
18:25:37 <edward1> i.e. postFinal f = fmap (NuD f) . f -- where data NuD f g = forall a. NuD (f a -> g a) -> a
18:26:45 <edward1> so thats defined even if i can't define the actual final dialgebra strangely enough
18:27:39 <ddarius> The type of postFinal is?
18:28:01 <edward1> postFinal :: (f a -> g a) -> g a -> g (Nu f g)
18:28:15 <edward1> er -> f a -> g (Nu f g)
18:29:07 <mauke> can I pronounce 'Nu (f a) g' as 'newfag'?
18:29:31 <edward1> mauke: if it makes it worse, I usually write Nu there as NuD. and prounounce it as nude
18:30:43 <edward1> anyways the strip operator from the other day works much like the above operator
18:31:15 <vixey> ?hoogle (a -> b) -> (b -> a)
18:31:16 <lambdabot> No matches, try a more general search
18:31:20 <vixey> ?hoogle (a -> b) -> (b -> [a])
18:31:21 <lambdabot> No matches, try a more general search
18:31:33 <vixey> that could have come in useful..
18:31:33 <vixey> a
18:33:02 <edward1> it just adds some noise by mapping a seed over the colimit of a functor before running that functor through the dialgebra, and then through the fmapped dialgebra homomorphism. it can be defined in terms of postFinal.
18:34:21 <dancor> @src fix
18:34:22 <lambdabot> fix f = let x = f x in x
18:34:42 <dancor> why isn't it just  fix f = f (fix f)
18:34:57 <edward1> dancor: sharing
18:35:15 <dancor> edward1: ?
18:35:31 <Cale> You want to share the result of fix f with the parameter to f, so things don't get recomputed.
18:35:43 <edward1> dancor: the let version creates a thunk, then passes the thunk into f, and gives you out a reference to the same thunk. your version would create a new thunk each time through
18:36:11 <edward1> you'd get the same answer (modulo unsafePerformIO) but your version would use a lot more memory in many cases.
18:36:24 <edward1> > fix (1:)
18:36:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:36:57 <ddarius> vixey: There aren't many useful functions of that type.  Presumably you want something like an Enum instance on a?
18:38:24 <EvilTerran> ?type let backwards :: (Enum a, Enum b) => (a -> b) -> b -> a; backwards = toEnum.fromEnum in backwards
18:38:25 <Elly> mmm, Enums
18:38:25 <lambdabot>     Could not deduce (Enum (b -> a)) from the context (Enum a, Enum b)
18:38:25 <lambdabot>       arising from a use of `toEnum' at <interactive>:1:69-74
18:38:25 <lambdabot>     Possible fix:
18:38:44 <EvilTerran> ?type let backwards :: (Enum a, Enum b) => (a -> b) -> b -> a; backwards = const (toEnum.fromEnum) in backwards
18:38:45 <lambdabot> forall a b. (Enum a, Enum b) => (a -> b) -> b -> a
18:39:53 <EvilTerran> yay for type inference
18:41:26 <vixey> mmm
18:45:46 <vixey> I am still not sure what to code at this point
18:46:12 <ddarius> When I'm not sure what to code, I don't code anything.
18:47:59 <mauke> I just mash the keys
18:48:10 <mauke> then I try to analyze the code to find out what it does
18:48:19 <TomMD> You should spend that time improving the Crypto package!
18:48:55 <mauke> like commenting out the calls for gathering entropy
18:50:17 <dancor> just code the thing with the earliest expected completion time on your list-of-things-you-want-to-code
18:50:17 <TSC> Check upstream first
18:50:31 <Cale> mauke: Are your programs written in the SK calculus?
18:50:47 <mauke> I can never be sure
18:51:35 <Elly> hehe
19:05:15 <jamii> Hmmm. Normally specialise pragma makes things go faster...
19:54:51 <mmorrow> this is classic:
19:54:56 <mmorrow> Title: Pulldown Menu
19:55:02 <mmorrow> Details: 1.23 KB * Uploaded June 21 1997
19:55:08 <mmorrow> Description: Use JavaScript to help your visitors dynamically 'surf' your page. They simply use the pulldown menu to select a destination and then click Go! and they're there! This script also supports an endless number of destinations. Just copy the template and fill it in accordingly.
19:55:24 <vixey> wiked!
19:55:27 <sclv_> wao! i'm working on a site that could use that! link plz!
19:55:38 <mmorrow> http://javascript.internet.com/buttons/
19:55:41 <lambdabot> Title: JavaScript Buttons | The JavaScript Source
19:55:46 <mmorrow> i love how "surf" is in quotes
19:55:59 <sclv_> i love how we used to talk about surfing the web.
19:56:02 <mmorrow> (that script is from 1997 btw)
19:56:09 <sclv_> and the information superhighway.
19:56:12 <mmorrow> we live in amazing times
19:56:34 <sclv_> mmorrow: that's fine, my target audience all use Netscape 6 anyway.
19:56:39 <TomMD> What do we call it now? "The information back county road"?
19:56:47 <sclv_> inter-tubes.
19:57:14 * mmorrow queue the beach boys
19:57:21 <Korollary> the intarweb
19:57:35 <TomMD> bz2web
19:57:49 <sclv_> information lolercoaster.
20:00:11 <mmorrow>  This script also supports an endless number of destinations!
20:01:39 <edwardk> ddarius: hrmm, for that matter it would appear i can't seem to derive any final dialgebras that don't involve Identity, just like the problem i was having with dyads.
20:02:40 <mmorrow> Title: Subject E-Mail
20:02:41 <mmorrow> Details: 0.57 * Uploaded December 4 1997
20:02:41 <mmorrow> Description: Let your visitors send you e-mail with a predetermined subject!
20:05:28 <edwardk> ddarius: some exist if you allow for functors from categories other than Hask, thats no problem, but for f,g :: Hask -> Hask, where both f,g are not isomorphic to Identity or the Trivial functor which maps everything to a single element/identity arrow in Hask, there don't appear to be any final dialgebras.
20:06:04 <edwardk> so while diana exists, she's kinda useless ;)
20:06:26 <Korollary> no stripping?
20:06:35 <edwardk> you can strip her, but you can't do much else with her ;)
20:10:04 <sclv_> "Description: This script simply flashes (hence the name) a message on and off on your statusbar."
20:11:23 <sclv_> Sometimes you need to display an information box. Copy this script into your document and you will have a button alert.
20:11:52 <mmorrow> tuBULUAR!
20:12:37 <nus> did somebody ever think of writing something like Slime's swank for ghc? (I hate how haskell-mode uses comint)
20:23:05 <osfameron> ooo, the Continuation monad is much easier to understand than Reader
20:23:18 <roconnor> ?
20:23:24 <vixey> really :S
20:23:26 <roconnor> osfameron: you are joking
20:23:36 <osfameron> well, I have nfi how Reader works
20:23:51 <vixey> Reader is trivial
20:23:53 <osfameron> whereas Cont just takes a lambda reference
20:24:08 <roconnor> reader is just about the nicest monad possible, next to the identity monad.
20:24:12 <osfameron> I'll have to try to implement it, it really makes no sense
20:24:56 <edwardk> osfameron: a reader just 'adds an extra parameter'. if you think about it a function of the form a -> m b is called a Kleisli arrow if m is a monad. for the reader monad (->)e, we can read that as a -> e -> b
20:25:35 <edwardk> so (>>=) takes m a -> (a -> m b) -> m b = (e -> a) -> (a -> e -> b) -> e -> b
20:25:42 <edwardk> which you can figure out quite easily
20:25:46 <osfameron> I kinda get what it's supposed to do, just not how it actually works
20:25:57 <vixey> ?djin (e -> a) -> (a -> e -> b) -> e -> b
20:25:58 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
20:26:00 <vixey> ?djinn (e -> a) -> (a -> e -> b) -> e -> b
20:26:00 <lambdabot> f a b c = b (a c) c
20:26:14 <edwardk> and return just has to ignore this extra argument
20:26:24 <edwardk> ?djinn a -> (e -> a)
20:26:24 <lambdabot> f a _ = a
20:27:46 <osfameron> hmmm I get type blindness looking at those ;-)
20:27:50 <edwardk> i find reader easier to understand as an arrow or a comonad first, coz the representations of both just uncurrying that kleisli arrow.
20:28:08 <osfameron> I don't know what arrows or comonads are
20:28:31 <vixey> osfameron: well you should know that
20:28:34 <vixey> a -> b -> c
20:28:35 <vixey> is the same as
20:28:38 <vixey> a -> (b -> c)
20:29:40 <edwardk> so if we look at (e -> a) -> (a -> e -> b) -> e -> b, we see that we want to take two functions and a value and return a value. so we give them names
20:30:00 <edwardk> lets call x :: (e -> a), and y :: (a -> e -> b), and z :: e
20:30:17 <edwardk> then we can apply x to z to get a value of type a.
20:30:34 <osfameron> I'd maybe understand a concrete example better
20:30:37 <edwardk> so we can feed that into y to get a function from e -> b
20:30:46 <osfameron> I'm finding the one in Meet the Monads a bit involved ( http://www.haskell.org/all_about_monads/html/readermonad.html )
20:30:47 <lambdabot> Title: The Reader monad
20:31:02 <edwardk> then we only have one candidate value of type e to feed to that function to get our b, and we want a b as a result, so we're done.
20:31:59 <edwardk> > join (*) 2
20:32:01 <lambdabot>  4
20:32:06 <edwardk> > join (+) 5
20:32:08 <lambdabot>  10
20:32:21 <edwardk> > join (++) [1,2]
20:32:22 <lambdabot>  [1,2,1,2]
20:32:28 <edwardk> @type join
20:32:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:32:53 <edwardk> so read m as (e ->) and you get (e -> (e -> a)) -> e -> a
20:33:18 <edwardk> it takes a function of two arguments and returns one of one argument, when used with m = (e ->), the anonymous reader monad.
20:33:47 <osfameron> thanks for taking the time to explain -- but I'm not really taking it in
20:34:06 <edwardk> no problem, just throwing examples out until one clicks ;)
20:34:07 <osfameron> if you have a simple code example that would be very helpful
20:34:08 <vixey> do you understand type operators?
20:34:16 <vixey> like Maybe (Maybe Bool) ?
20:34:39 <vixey> inhabitants are, Nothing, Just Nothing, Just (Just True), Just (Just False)
20:34:54 <osfameron> vixey: not really no
20:34:59 <edwardk> ah
20:35:13 <vixey> well if you get Maybe, then the monad stuff will be really simple I think
20:35:15 <vixey> so,
20:35:16 <vixey> @src Maybe
20:35:16 <lambdabot> data Maybe a = Nothing | Just a
20:35:18 <osfameron> oh, well no, that does make sense
20:35:20 <edwardk> vixey: good catch
20:35:34 <osfameron> I get Maybe up to a point
20:35:44 <vixey> here, 'Maybe a' is a type, a being a variable,  'Nothing' is data, 'Just' is data and 'a' is a type there
20:36:25 <osfameron> right
20:37:02 <vixey> at the value level, you have things like Left, Right, Just... but you could also use f so f 3 might be Left 3, or Right 3, and so on
20:37:12 <vixey> that's just what m (m a) -> m a means
20:37:21 <vixey> m could be [] or Maybe, or (->e)
20:37:25 <osfameron> yeah I get that much in theory
20:37:35 <osfameron> but I can't read a long string of them easily
20:37:43 <vixey> > join [[1,2,3],[4,5,6]]
20:37:44 <lambdabot>  [1,2,3,4,5,6]
20:38:45 <dmwit> osfameron: I can give you an example I use all the time.
20:39:09 <dmwit> > liftM2 (||) even odd 37
20:39:10 <lambdabot>  True
20:39:20 <dmwit> osfameron: Let's take a look at that.
20:39:48 <osfameron> ok
20:39:50 <dmwit> osfameron: I'm sure you have heard the conceptual explanation of Reader: there's some "environment" which each monadic action implicitly has access to.
20:40:24 <osfameron> dmwit: yes, I think I get the use case for Reader
20:40:28 <dmwit> But they have access to it basically as their first parameter... that is, they're just functions.
20:40:42 <dmwit> So "even" is a monadic action that has an Integral environment, and yields a Bool.
20:40:54 <dmwit> > runReader (Reader even) 37
20:40:56 <lambdabot>  False
20:41:02 <dmwit> > even 37 -- basically the same
20:41:04 <lambdabot>  False
20:41:18 <dmwit> "odd" is also a monadic action (i.e. an "m Bool").
20:41:19 <osfameron> hang on - what's runReader ?
20:41:26 <dmwit> oh
20:41:28 <edwardk> @type runReader
20:41:30 <lambdabot> forall r a. Reader r a -> r -> a
20:41:32 <vixey> @src Reader
20:41:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:41:44 <dmwit> osfameron: Have you played with State or Parsec or so?
20:41:45 <osfameron> the simple do blocks (Maybe, List, etc.) don't have run{Monad}
20:42:07 <dmwit> osfameron: Monads typically have a "runMonad" function that has type (roughly) "m a -> a".
20:42:15 <edwardk> there are a couple of different 'Reader' monads. there is the 'anonymous reader' monad that i've been using that says, well, EVERY function can be treated as a monad!, and the 'Reader' monad that gives it a nice named wrapper to indicate the intent.
20:42:16 <osfameron> dmwit: nope, I'm at Maybe/List stage, and (as I started out) I think I understand Cont, though I haven't played with it enough to check
20:42:35 * vixey doesn't understand Cont :p
20:42:36 <osfameron> dmwit: oh, ok, to avoid having to put the value in a do { } to use it
20:42:47 <dmwit> osfameron: Something like that, yeah.
20:42:50 <dmwit> err...
20:42:50 <dmwit> no
20:43:07 <osfameron> heh
20:43:11 <dmwit> =P
20:43:26 <dmwit> So you know the famous problem with monads: once you get into them, you can't get out.
20:43:36 <osfameron> yeah
20:43:45 <dmwit> So the Reader monad provides a function that lets you out of the monad.  But you have to tell it what the "environment" is.
20:43:47 <dmwit> In this type:
20:43:49 <dmwit> :t runReader
20:43:51 <lambdabot> forall r a. Reader r a -> r -> a
20:44:00 <dmwit> (Reader r a) is the monadic action (m a).
20:44:01 <vixey> :t Reader
20:44:02 <lambdabot> forall r a. (r -> a) -> Reader r a
20:44:09 <dmwit> "r" is the "environment".
20:44:10 <dmwit> ok?
20:44:32 <edwardk> > runReader (do x <- ask; return (x,x)) 10
20:44:33 <lambdabot>  (10,10)
20:44:37 <dmwit> runReader :: m a -> r -> a -- where (m a) must be the Reader monad
20:44:39 <osfameron> er, I'm not sure what types r and a are
20:44:44 <edwardk> @type (do x <- ask; return (x,x))
20:44:46 <lambdabot> forall (t :: * -> *) t1. (MonadReader t1 t) => t (t1, t1)
20:44:56 <dmwit> osfameron: "r" is the type of the environment; "a" is the type of the computation that results.
20:45:31 <osfameron> so how do I actually instantiate a Reader?
20:45:37 <dmwit> osfameron: For example, suppose we're in a game that is counting the number of animation frames since the beginning of the game.
20:45:39 <edwardk> er scary type there, but it basically should read Reader t (t,t) -- if you ignore the extra stuff
20:45:46 <vixey> What does instantiate mean?
20:45:53 <osfameron> like in the (Reader even) above, where did the environment come from?
20:46:04 <edwardk> osfameron: thats what i did with the do notation above. i created a Reader, and then i told it to run with runReader
20:46:13 <dmwit> osfameron: From the "37" at the end.
20:46:45 <edwardk> osfameron: recall there are two types of reader, the anonymous one, and the Reader with a capital R that you have to runReader on to apply to a value.
20:46:49 <dmwit> osfameron: So, game example, counting frames.  We're going to use a Reader monad for some of the calculations, and the environment will be the number of frames.
20:47:18 <dmwit> osfameron: So the monadic action (m a) will actually be of concrete type (Reader Int a), meaning the environment is an Int.
20:48:00 <dmwit> Let's say we want something to happen on every other frame of the game.
20:48:13 <dmwit> So, we want an action (m Bool) that tells if it should happen this frame.
20:48:19 <osfameron> edwardk: I don't think I get what the anonymous reader is :-(
20:48:22 <dmwit> Good so far?
20:48:32 <osfameron> dmwit: ok
20:48:54 <osfameron> dmwit: that implies we'll be updating the environment though?
20:49:09 <dmwit> osfameron: No, we only want to know if it should happen.  We won't actually do it.
20:49:19 <dmwit> osfameron: So, no changes to the environment allowed.
20:49:23 <edwardk> osfameron, then ignore that i mentioned it and we'll make sure the examples use the explicit one
20:49:48 <dmwit> osfameron: Now, Reader has a primitive action called "ask" that returns the environment.
20:50:01 <dmwit> osfameron: So, for us, (ask :: m Int).
20:50:09 <edwardk> > runReader ask 2
20:50:10 <lambdabot>  2
20:50:30 <dmwit> do { frameNumber <- ask; {- code using frameNumber -} }
20:50:38 <dmwit> okay?
20:50:49 <edwardk> > runReader (do x <- even; y <- ask; return (x,y)) 2
20:50:50 <lambdabot>  Couldn't match expected type `Reader r t'
20:50:59 <edwardk> er
20:51:03 <dmwit> braces
20:51:22 <dmwit> oh
20:51:24 <dmwit> Reader even
20:51:41 <dmwit> or
20:51:43 <dmwit> asks even
20:51:57 <dmwit> > runReader (do x <- asks even; y <- ask; return (x, y)) 2
20:51:58 <lambdabot>  (True,2)
20:52:07 <dmwit> osfameron: Anyway, are you with me up to ask?
20:52:35 <edwardk> > runReader (Reader even >>= \x -> do { y <- ask; return (x,y) }) 2
20:52:36 <lambdabot>  (True,2)
20:52:46 <edwardk> ah someone beat me to it, i always forget asks ;)
20:52:51 <osfameron> edwardk: thanks, I was wondering what the desugaring was
20:53:24 <edwardk> @undo do x <- asks even; y <- ask; return (x, y)
20:53:24 <lambdabot> asks even >>= \ x -> ask >>= \ y -> return (x, y)
20:53:30 <osfameron> so "asks even" is what creates the reader function?
20:53:38 <dmwit> Yep!
20:54:00 <osfameron> is 'ask' just 'asks id' ?
20:54:07 <dmwit> osfameron: And, for the icing on the cake, there's a Reader monad that just drops the "asks" and "runReader" as if they were implicit.
20:54:09 <dmwit> osfameron: yes
20:55:10 <dmwit> So, "runReader (do x <- asks even; y <- asks (+1); return (x, y))" would become just "do x <- even; y <- (+1); return (x, y)".
20:56:20 <osfameron> oh, is that the function monad then?
20:56:29 <dmwit> That's it.
20:56:53 <osfameron> and where would that get its environment from?
20:57:10 <dmwit> You have to supply it at the end like so:
20:57:28 <dmwit> > (do { x <- even; y <- (+1); return (x, y) }) 37
20:57:29 <lambdabot>  (False,38)
20:57:58 <cpfr> hey, is it safe to rely on lazy IO for processing a 2.2 GB file
20:58:14 <cpfr> if i dont want ghc to load it all into memory
20:59:06 <osfameron> dmwit: ok, same as runReader in fact
20:59:14 <dmwit> osfameron: exactly
20:59:18 <bos> cpfr: absolutely.
20:59:49 <bos> cpfr: in fact, if you can process it using lazy bytestrings, your code will end up as fast as, or faster than, C.
21:00:31 <osfameron> edwardk, vixey, dmwit: thanks I think that makes more sense
21:00:44 <vixey> I hope so :)a
21:00:47 <cpfr> bos done and done :)
21:00:56 <bos> cpfr: final step: profit!
21:01:00 <osfameron> my problem with it (and State moreso) is that the monadic value is higher order, which is rather different than Maybe etc.
21:01:02 <vixey> cpfr!
21:01:11 <osfameron> (well, s/is/was/ hopefully)
21:01:46 <vixey> @keal
21:01:46 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
21:01:58 <cpfr> are lazy bytestrings part of ghc now?
21:02:47 <bos> cpfr: they've been shipped with ghc for a few years.
21:02:47 * osfameron wonders whether to try to go back to sleep or just give up and get up at this point
21:03:00 <cpfr> bos: score!
21:03:15 <vixey> osfameron: no sleeping
21:03:56 <osfameron> hmmm, maybe a bath then
21:03:58 * osfameron heads off
21:08:48 <mxc_> @src asks
21:08:48 <lambdabot> asks f = do
21:08:48 <lambdabot>     r <- ask
21:08:48 <lambdabot>     return (f r)
21:09:13 <mxc_> oh, thats nice
21:30:32 <dobblego> foldl/foldr is to Foldable as scanr/scanl is to ?
21:31:02 <SamB> @src scanr
21:31:02 <lambdabot> scanr _ q0 []     =  [q0]
21:31:02 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
21:31:02 <lambdabot>     where qs@(q:_) = scanr f q0 xs
21:31:03 <SamB> hmm
21:31:12 <SamB> that's not very pretty
21:31:42 <dobblego> maybe using unfoldr?
21:31:45 <dobblego> ?type unfoldr
21:31:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:32:26 <SamB> @src scanr1
21:32:26 <lambdabot> scanr1 f []     = []
21:32:26 <lambdabot> scanr1 f [x]    = [x]
21:32:26 <lambdabot> scanr1 f (x:xs) = f x q : qs where qs@(q:_) = scanr1 f xs
21:32:33 <SamB> @type scanr
21:32:34 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
21:41:57 <dobblego> perhaps scanr can be written with foldr
21:42:57 <vixey> would like to see that
21:43:13 <dobblego> maybe I am lying :)
21:44:30 <dobblego> with a paramorphism?
21:46:42 <mrd> > foldr (\ x (a:as) -> (+) x a:a:as) [0] [1..4]
21:46:43 <lambdabot>  [10,9,7,4,0]
21:46:53 <mrd> > scanr (+) 0 [1..4]
21:46:55 <lambdabot>  [10,9,7,4,0]
21:47:19 <ddarius> > let scanr f q0 xs = foldr (\x xs q0 -> let qs@(q:_) = xs q0 in f x q : qs) (\q0 -> [q0]) xs q0 in scanr (+) 0 [1..10]
21:47:21 <lambdabot>  [55,54,52,49,45,40,34,27,19,10,0]
21:47:35 <ddarius> > scanr (+) 0 [1..10]
21:47:36 <lambdabot>  [55,54,52,49,45,40,34,27,19,10,0]
21:51:04 <dobblego> thanks; I was thinking more in terms of Data.Foldable.foldr
21:51:40 <vixey> :t Data.Foldable.foldr
21:51:42 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
21:52:16 <vixey> @instances Foldable
21:52:16 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
22:02:57 <dons> TomMD: http://aur.archlinux.org/packages.php?ID=17458 its in arch now.
22:02:58 <lambdabot> Title: AUR (en) - haskell-puremd5
22:03:10 <dons> TomMD: since cabal2arch depends on it.
22:09:29 <bos> i hate it when code gets slower just due to a reorg.
22:10:30 <bos> i moved some code around to make it more modular, and it cost me 25% of performance.
22:10:31 <Korollary> it's quantum mechanics
22:13:29 <dobblego> is it possible to write a function like (T t, U u) => t -> u ?
22:14:31 <dobblego> gah, I've forgotten my Haskell
22:21:08 <dobblego> I think this is where I encoded my type classes in data types
22:28:11 <Cale> dobblego: It depends on what operations the classes T and U support.
22:28:46 <dobblego> ah yes, I guess U could support a function a => u
22:29:46 <dobblego> http://hpaste.org/8306
22:31:44 <bos> @seen dons
22:31:44 <lambdabot> dons is in #arch-haskell, #ghc, #haskell-soc, #xmonad and #haskell. I last heard dons speak 2m 31s ago.
22:31:59 <Cale> dobblego: actually that's roughly how the dictionary implementation of typeclasses works
22:32:25 <bos> here's something peculiar. if i use record syntax, ghc emits accessor functions that it then doesn't inline, even if they're not exported from a module.
22:33:02 <bos> and i can't figure out where to put an INLINE annotation to say "inline this accessor".
22:33:20 <bos> the compiler stoutly rejects all of my attempts.
22:33:41 <Cale> curious
22:34:15 <dobblego> Cale, are you suggesting that I am not helping anything by doing so? if so, can a function be written (Ord a, Eq b) => a -> b ?
22:34:56 <Cale> dobblego: Such a function would take any Ord type and produce any Eq type whatsoever -- are you sure that's what you want?
22:35:15 <dobblego> only for the purposes of an example
22:35:23 <Cale> Well, what would it do?
22:35:30 <dobblego> I am more interesting in deriving instances of a general type-class from a more specific one
22:35:46 <dobblego> the same as I have done in the code sample using data types
22:36:18 <Cale> Ah, so you want to write an instance Ord a => Eq a where x == y = compare x y == EQ
22:36:43 <dobblego> right
22:36:55 <dobblego> just as an experiment of the possibility of doing so
22:36:59 <Cale> The trouble with such an instance is that due to the way that typeclass selection works, such an instance overlaps with everything.
22:37:35 <Cale> (Even in cases where the type 'a' is not *yet* an instance of Ord, there's no way for the compiler to know that it won't be in a future module.)
22:38:23 <mmorrow> dobble: i wish the (=>) was implication also
22:38:28 <dobblego> so then, is this approach reasonable?
22:38:28 <mmorrow> dobblego:
22:39:05 <Cale> Yes, I suppose it would, if you otherwise would badly need such an instance.
22:39:21 <Cale> Another option is to use a newtype to select the generic instance.
22:40:24 <Cale> newtype OrdEq a = OrdEq a; instance Ord a => Eq (OrdEq a) where OrdEq x == OrdEq y = compare x y == EQ
22:40:43 <dobblego> ah yes, thanks
22:42:24 <mmorrow> Cale: ooo that's gives me ideas
22:42:38 <mmorrow> (i don't know what yet)
22:42:52 <Cale> newtypes are also generally a useful trick when you have multiple possibly-desirable instances that you'd like to provide for a given type.
22:42:59 <Cale> (and you can't choose which one)
22:43:25 <frevidar> is there a way to populate an array without creating an intermediate list?
22:43:34 <frevidar> or is the list optimized away in any case?
22:43:57 <dobblego> I need -fallow-undecidable-instances for this?
22:44:05 <lament> the list _should_ (in theory anyway) be optimized away
22:44:42 <frevidar> lament: cool. And there's no way to populate one without the list?
22:45:21 <Cale> I tend to think of the list as equivalent to the loop which would be used to populate the array in a typical imperative language.
22:45:25 <lament> frevidar: lists are haskell jargon for for loops
22:46:25 <Korollary> Cale: C has array constructor syntax
22:46:50 <Korollary> C++ doesn't have a vector constructor syntax, tho. It blows, really.
22:48:20 <frevidar> lament: I guess that relates to another question I had... I was wondering if haskell had a "stream" type? For example if you do while (stream >> x) { .. } there's no allocations for each element. Is it reasonable to assume a Haskell list will work in the same fashion if I only access the elements once?
22:48:57 <frevidar> lament: I guess, like a for loop?
22:49:11 <lament> frevidar: that's exactly how most list-processing functions work
22:49:18 <parag1> frevidar: I think haskell has a stream type -similar to infinite list
22:49:25 <Cale> frevidar: To be honest about it, the optimisations which remove lists are not as complete as they could be at the moment (though there's a new stream-fusion for lists which ought to be in the next GHC).
22:49:45 <lament> Cale: map is not optimized?
22:50:14 <Cale> lament: There are handful of things which fuse. It's foldr/build fusion.
22:50:36 <Cale> If you want to know whether it's happening, there's a flag you can pass to GHC to make it print out which rules apply.
22:50:52 <parag1> is it possible to do logic programming (similar to Prolog) in Haskell ?
22:50:58 <Cale> But even if it's not happening, GHC is rather good at cleaning up short-lived garbage.
22:51:17 <dobblego> Cale, your example gives me a compile-time error: "Ambiguous constraint `Ord a'..."
22:51:18 <Cale> parag1: In some sense.
22:51:31 <Korollary> typically literals in the source code don't cause performance issues because they're rather small in size as the programmers type them in by hand usually
22:51:32 <Cale> dobblego: Which one?
22:51:42 <dobblego> newtype OrdEq a = OrdEq a; instance Ord a => Eq (OrdEq a) where OrdEq x == OrdEq y = compare x y == EQ
22:51:46 <Cale> hmm
22:52:14 <Cale> dobblego: Works for me?
22:52:46 <dobblego> hrm, I shall play spot the difference, sorry
22:53:15 <parag1> Cale: can you elaborate a little? What kind of logic programming is possible in Haskell?
22:53:21 <frevidar> so, I've got a function that generates a known size list/array, where each element depends on the previous and some other data, and then generates a known size list/array, where each element depends on the just generated list and the element after it (essentially, the final structure is built backwards).
22:53:30 <frevidar> should I be using lists or arrays here?
22:53:48 <frevidar> I know thats kinda an open question, but pros/cons maybe?
22:54:52 <Cale> parag1: Well, lazy evaluation and the list monad make searching for things easy -- you can think of the list monad as giving you nondeterminism. However, it's not quite the sort of multi-way nondeterminism that you get in Prolog.
22:55:16 <parag1> Cale thanks
22:55:22 <sclv_> frevidar: lists sound reasonable here -- if all the context is local, you might get a bunch out of fusion/gc
22:55:26 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
22:55:27 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
22:56:03 <Cale> > do x <- [1,2,3]; y <- [4,5]; guard (even (x+y)); z <- [6,7,8]; return (x,y,z)
22:56:04 <lambdabot>  [(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(3,5,6),(3,5,7),(3,5,8)]
22:56:34 <frevidar> sclv_: well, I think the lists still need to be generated, because the second process goes through the first list backwards
22:56:45 <Cale> parag1: For more sophisticated (but still not quite prolog) traversals, there's a nice LogicT which you can get from Hackage.
22:56:58 <frevidar> sclv_: so I was thinking an array would be better here as it doesn't have the overhead of the list links
22:56:58 <Deewiant> > [ (x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8], even (x+y) ]
22:56:59 <lambdabot>  [(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(3,5,6),(3,5,7),(3,5,8)]
22:57:05 <dobblego> Cale, found it, my mistake (transcription error), sorry
22:57:22 <frevidar> maybe?
22:57:42 <parag1> has anybody tried Curry? Cale I have read that Curry supports logic programming and it is built on Haskell
22:57:52 <sclv_> ah, gotcha, so the first element of the final list depends, in the long run, on every element of the previous one. (because each depends on the previous)
22:58:24 <Cale> parag1: Yeah, I don't know how well-maintained it is, but it's a neat idea.
22:58:51 <Cale> parag1: There's also Mercury, and a few others, iirc.
23:04:16 <quicksilver> frevidar: I'd be fairly suprised if saving one pointer per node made much of a difference
23:04:19 <quicksilver> frevidar: but it might
23:05:03 <parag1> Cale what is iirc?
23:05:11 <dobblego> if I remember correctly
23:05:15 <Cale> parag1: if I recall correctly
23:05:18 <parag1> thanks
23:09:53 <mattr__> sorry to bug you guys, but it is quiet over in #darcs
23:10:07 <mattr__> Today I was stuck working off yesterday's backup because of a hard drive problem and now I want to get today's work off the backup machine
23:10:18 <mattr__> I thought I could darcs send patchX patchY....
23:10:30 <mattr__> but it seems darcs needs to inspect the target repo for itself
23:10:40 <mattr__> problem is the target repo for me is this repo in the state it was early this morning
23:10:49 <mattr__> any ideas?
23:11:35 <Cale> mattr__: Can't you let it inspect the backup copy?
23:11:58 <mattr__> the backup is the one I have been working on
23:12:01 <mattr__> so it is edited
23:12:13 <mattr__> the hard-drive is at home up and running again
23:12:23 <Baughn> mattr__: Hang on. You don't want to merge it back into the main repo?
23:12:29 <mattr__> and so I want to take today's work home
23:12:31 <mattr__> sure do
23:12:39 <Baughn> Then, isn't /that/ the target repo?
23:12:44 <mattr__> yep
23:12:48 <mattr__> but this computer will never see that one
23:12:59 <Baughn> Oh, I see. No network connection. Let's see..
23:12:59 <mattr__> they are seperated by time and space and one is not on any network
23:13:17 <Baughn> Well, if it's just patches today, try this:
23:13:17 <mattr__> i know exactly which patches I want
23:13:38 <Baughn> Clone the repo with darcs get, unpull the patches you want from the new one, then darcs send to the new
23:13:46 <mattr__> ha!
23:13:50 <Baughn> I was going to say "filter by date". That would also work.
23:13:56 <mattr__> I guess that will work
23:14:04 <mattr__> but is that really the best way?
23:14:08 <Baughn> Yes
23:14:16 <mattr__> hooley dooley
23:14:25 <mattr__> I love darcs, but that is terrible
23:14:33 <Baughn> Darcs needs to know what it's patching against to produce a patch
23:14:44 <Baughn> It should still be applicable at home, but..
23:14:44 <Cale> MOAR TUBES!
23:14:50 <Baughn> You were supposed to branch it /before/ editing
23:15:10 <Baughn> If you want automation, filter on the date instead. :P
23:15:11 <mattr__> indeed
23:15:26 <mattr__> so, the patches that get recorded
23:15:28 <nus> why don't you clone and pull directly, why send?
23:15:45 <mattr__> are not exactly the same as the ones it will send
23:16:03 <mattr__> it generates seperate patches for each "record" I did depending on the target repo?
23:16:19 <mattr__> I figured each patch I recorded would just be sent and applied
23:16:32 <mattr__> and the only thing darcs needed to know is which are already on the target
23:16:37 <Baughn> mattr__: Well, no. It just uses... hang on
23:16:54 <Baughn> mattr__: Actually, you could create an empty repo and send to /that/. That will consider all patches applicable for sending
23:17:17 <mattr__> then just apply the ones I want at the other end?
23:17:19 <mattr__> nice idea
23:17:35 <mattr__> still, this is dodgy stuff
23:17:38 <Baughn> But in the future, clone the repo before you start doing things. Havin darcs automate the patch selection makes rather more sense.
23:17:49 <mattr__> perhaps when they wake up at #darcs I will quiz them more
23:17:55 <mattr__> you are a legend
23:17:55 <Baughn> mattr__: No, not really. And no, darcs on either side will only ask you about the patches it doesn't already have
23:18:03 <Baughn> mattr__: The algebra of patches thingy makes this clear
23:18:13 <mattr__> I read that once
23:18:26 <mattr__> which I why I thought I could just take out a patch
23:18:31 <mattr__> take it to another repo
23:18:34 <mattr__> and try to apply it
23:18:37 <Baughn> You /can/
23:18:42 <mattr__> no I can't
23:18:48 <mattr__> that is exactly what I am doing here
23:18:51 <mattr__> trying to do here
23:18:58 <Baughn> The only problem here is that darcs doesn't know which ones you want, and it quite naturally assumes you don't want to bring the entire repo
23:19:16 <mattr__> but why can't I *tell it* which ones I want?
23:19:21 <Baughn> If you're okay with bringing the whole thing.. why not do just that? And then pull from it when you get home?
23:19:29 <mattr__> I will
23:19:46 <mattr__> but I feel a deep need to understand why the nicer option is not available :)
23:19:49 <nus> Baughn, exactly
23:20:52 <nus> mathrick, what part of pull in the changes to target repo isn't nice?
23:21:20 <Baughn> mattr__: You'd have to ask #darcs
23:21:32 <Baughn> mattr__: It's probably because, if you do it right, your problem never happens
23:21:59 <Baughn> mattr__: Also, how come you don't have a http server somewhere you can stick the repo on? Not having network access to your stuff in this day and age is.. odd
23:22:00 <mattr__> Baughn: but svns are there to get me out of situations where something went wrong :)
23:22:19 <Baughn> mattr__: Which it's doing. It just takes a little more effort.
23:22:37 <Baughn> mattr__: "clone repo; filter out patches made today; send to cloned repo" isn't really a large script
23:22:48 <mattr__> Baughn: i see you are more pragmatic than I am :)
23:22:59 <mattr__> perhaps it is svn cruft left in my brain
23:23:49 <frevidar> is there a way in haskell to make a data structure that acts like a list?
23:23:53 <mattr__> as for being off the net, a computer with no net access is a major productivity tool for me
23:23:54 <frevidar> but isn't a list?
23:24:00 <mattr__> major == powerful
23:24:04 <Baughn> frevidar: Define "acts like a list"
23:24:15 <mattr__> frevidar: many, more info :)
23:24:40 <Cale> frevidar: data List a = Nil | Cons a (List a)  ?
23:24:46 <Baughn> frevidar: data List a = Nonempty a (List a) | Empty
23:25:13 <Baughn> ..aha! Lispisms!
23:25:36 <frevidar> lets say I have f :: Int -> Int. I want it pass it to a function which wants a [Int]. I want f 0 to be the first element, f 1 to be the second element and so on.
23:25:44 <frevidar> but I don't actually want to generate the list
23:26:01 <Cale> g (map f [0..])
23:26:04 <Baughn> frevidar: Um.. lazy evaluation? Or.. I don't really get it
23:26:22 <mattr__> sounds exactly like lazy evaluation
23:26:25 <Baughn> frevidar: If you've got something that wants a list, then you really do have to pass it one
23:26:37 <frevidar> so there's no List class?
23:26:41 <Baughn> No
23:26:56 <mattr__> now we need a space leak question to balance out the universe
23:26:57 <frevidar> Like, if something wants a Num, I can pass it any instance that conforms to Num
23:27:00 <Baughn> You could make one, but something that wants [Int] would want the primitive list type, not just anything in the class
23:27:09 <Baughn> frevidar: Well, there's no need for one
23:27:30 <Baughn> frevidar: There /is/ the Seq class, which is probably what you're looking for, but lots of functions don't just work with any arbitrary Seq
23:27:40 <Cale> Baughn: ?
23:27:47 <Cale> Do you mean Foldable?
23:27:58 * Baughn blinks
23:28:00 <Beelsebob> he could also mean Functor
23:28:26 <Cale> The only Seq class I can think of is the one which used to have seq in it.
23:28:32 <Baughn> Yeah, Foldable. Whoops..
23:28:40 <Baughn> Sq was something quite different
23:28:40 <quicksilver> frevidar: basically there is no need for a list class, in a sense.
23:28:48 <quicksilver> because lists are just as good.
23:29:03 <quicksilver> why bother with a class, just use actual lists and lazy evaluation.
23:29:08 <quicksilver> it amounts to the same thing.
23:29:15 <quicksilver> (in another sense, Foldable is the list class)
23:29:17 <Baughn> frevidar: Put another way - how could you reimplement lists to get useful behaviour that they don't already have?
23:30:26 <Beelsebob> Baughn: how about the lists that were recently linked on the mailing list that have O(1) insertion and head/tail, but O(log n) lookup
23:30:26 <frevidar> baughn: I guess so... you cant make a foldable from a foldable can you?
23:30:28 <Cale> Baughn: Well, Int -> Int has an efficient indexing operation ;)
23:30:32 <frevidar> like you can a list with map?
23:30:58 <Baughn> Beelsebob: I'm not sure I'd call that a /list/, but by all means put it in Foldable
23:30:58 <Beelsebob> Cale: depends how you construct the "list" in a function
23:31:15 <Baughn> Beelsebob: It's just that, when you say "list", I assume certain algorithmic complexities as well
23:31:18 <quicksilver> frevidar: no, you need traversable to make another one.
23:31:23 <Beelsebob> Baughn: it behaves like a list when you look at it from the outside, so why is it not a list?
23:31:57 <Baughn> Beelsebob: Well, it doesn't really. Lookups are too fast.
23:32:16 <frevidar> quicksilver: ah, thats what I'm looking for. Are lists instances of traversable?
23:32:47 <quicksilver> yes
23:33:09 <Beelsebob> Baughn: so if you refactor a module to have the same interface, but different complexities, you have to rename it because it no longer uses the same internal representation?
23:33:15 <Beelsebob> hence breaking your whole program?
23:33:25 <Baughn> Beelsebob: See, now you're getting it.
23:33:41 <Beelsebob> sounds like a really silly plan to me
23:34:09 <Beelsebob> the whole point of having the module in the first place was that I could do a refactoring, and have it "just work" in the rest of the program
23:34:17 <Beelsebob> I don't want to run around renaming everything afterwards
23:34:52 <Baughn> But that's what the compiler has to do
23:35:07 <Baughn> Do you consider yourself above the compiler? Is it merely a servant to you?
23:35:23 <Beelsebob> you want the compiler to optimise all your bad algorithms into good ones?
23:35:25 <Beelsebob> o.O
23:35:30 <Beelsebob> that's some pretty special compiler
23:35:54 <Beelsebob> I'd even argue that it's incorrect
23:36:02 <Beelsebob> a compiler shouldn't be fidling with the algorithm at all
23:36:12 <Beelsebob> only how fast it's implementation of it on the low level is
23:36:24 <Beelsebob> s/low level/low level hardware/
23:36:35 <Cale> I don't mind if the compiler improves the complexity of the algorithm I give it.
23:36:51 <Baughn> ..my tongue is so far in cheek, it hurts
23:37:07 <Beelsebob> I think it would be a fun tool to have Cale -- but certainly not something to turn on by default
23:37:21 <Beelsebob> after all -- I may be using said compiler to study algorithmic complexity
23:37:46 <Cale> heh, turn optimisations off then :)
23:38:58 <Beelsebob> and last but not least -- on a purely semantic and petty level -- that's not a compiler
23:39:16 <Cale> Hm?
23:39:18 <Beelsebob> a tool that does static optimisation on algorithmic levels is a neat idea
23:39:21 <Beelsebob> but it's not a compiler
23:39:24 <Cale> Oh?
23:39:42 <Cale> A compiler is a semantics-preserving transformation from one language to another.
23:39:43 <nus> Beelsebob, are you talking about deques
23:40:41 <Beelsebob> Cale: yep, and that doesn't preserve semantics if you consider how long certain things take relative to each other to be part of the semantics
23:40:49 <Cale> Yeah, but you usually don't.
23:41:01 <Beelsebob> oh?
23:41:18 <Beelsebob> you don't modify your code based on how fast the result ran?
23:41:30 <Beelsebob> I'd argue most programmers look very carefully at that behavior
23:41:35 <Cale> Most semantics for programming languages are about the values of programs, not how long those values take to compute.
23:41:55 <Beelsebob> yep, doesn't mean those are the only semantics the programmer cares about
23:42:20 <Beelsebob> this is why real time systems guys have lots of tools for computing maximum run time bounds
23:43:04 <Cale> I wouldn't consider preserving any kind of performance model as a key part of the definition of a compiler.
23:43:19 <Cale> Termination behaviour, sure.
23:43:41 <Beelsebob> I would -- otherwise you can't easily improve your code
23:44:07 <Cale> So some compilers just aren't good for people who want to improve their code, it doesn't make them not-compilers.
23:44:08 <Beelsebob> it's possible that if you realise part of your code is slow, you may optimise it *and do a better job than our imaginary compiler*
23:44:29 <Beelsebob> true dat
23:45:00 <Cale> Suppose you had a compiler which preserved a performance model in that it never made programs run slower than they otherwise would, but would speed them up.
23:45:07 <Beelsebob> so conclusion -- *if* you consider run time behaviour to be part of your semantics, then it's not a compiler
23:45:25 <Beelsebob> running*
23:45:51 <Beelsebob> Cale: hehe, I'd love to see that compiler, even for low level optimisations
23:48:02 <quicksilver> compiler shouldn't be fiddling with the algorithm at all?
23:48:08 <quicksilver> well that rules out gcc and ghc as compilers then.
23:48:11 <quicksilver> what are they?
23:48:22 <Cale> I'm sure that you can prove that lots of transformations won't do harm to the performance of the code.
23:48:49 <Cale> (at least with respect to some reasonable model)
23:48:51 <quicksilver> Cale: actually the thing that scares me about the GHC optimisations which improve complexity classes is that they are less compositional than haskell.
23:49:02 <Beelsebob> sure, but I'm also sure that you can demonstrate that most of those implemented in modern compilers *do* do damage in some corner cases
23:49:08 <quicksilver> Cale: so you can no longer reason about performance compositionally.
23:49:14 <Beelsebob> in the mean time, I've got to run off to work
23:52:01 <SamB_XP_> quicksilver: we could do that before?
23:52:32 <quicksilver> to a larger extent, at least.
23:52:49 <quicksilver> for example certain "Safe" refactorings which are semantically irrelevant
23:52:58 <quicksilver> will kill an inlining and stop a RULE firing
23:53:05 <quicksilver> and thus drop you a complxicty class
23:54:41 <SamB_XP_> I think thats a bit harder with the stream fusion?
