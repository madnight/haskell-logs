00:00:00 <mmmdonuts> dons, thanks, but probably not - I'm getting segfaults with that version on debian 64 bit, and before I go into crazy debug mode, I thought I'd try the later version.
00:00:00 <ivanm> wtf?
00:00:06 <ivanm> that's just weird...
00:00:17 <mmmdonuts> (it works on 32 bit)
00:00:26 <dons> mmmdonuts: hmm, hunting...
00:00:52 <ivanm> I'm sure I managed to build atlas fine when I used it on a laptop with throttling enabled...
00:00:56 <dons> that's annyong.
00:01:12 <ivanm> dons: you trying to build atlas yourself or use an arch package?
00:01:30 <dons> "Most OSes (including Linux) now turn on CPU throttling for power managment
00:01:30 <dons> **even if you are using a desktop**.  CPU throttling makes pretty much all
00:01:30 <dons> timings completely random, and so any ATLAS install will be junk.  Therefore,
00:01:30 <dons> before installing ATLAS, turn off CPU throttling. "
00:01:34 <dons> ivanm: from the arch package
00:01:42 <solrize> latest archive.org crawl is from august 27 2007
00:01:59 <dons> ah, -Si cputhrchk 0
00:02:39 <solrize> http://web.archive.org/web/20070827220211rn_1/hackage.haskell.org/packages/hackage.html
00:04:50 <ivanm> solrize: does that even archive the packages themselves? :o
00:05:27 <solrize> in principle it should, but they're way old
00:05:37 <solrize> it would be good if hackage was mirrored in a few places
00:05:41 <solrize> on general principles
00:05:44 <dons> we'll have a mirror set up after this. having a single provider for hackage is not a good model now
00:06:16 <dons> i suggest using code.haskell.org, and a machine at chalmers as backups.
00:06:20 <solrize> yeah, i guess this is a pretty new thing
00:06:39 <dons> yep, 1st year of hackage. first time we've lost access for any significant period
00:07:14 <sjanssen> dons: what happened?
00:07:23 * sjanssen is not caught up on his Haskell mail
00:07:53 <solrize> also haskell itself is on an exponential growth spike, there just hasn't been that much activity before, so outages were less of a problem
00:08:04 <glguy> Galois moved offices and hackage is hosted by Galois
00:08:17 <sjanssen> oh, so this is planned downtime
00:08:19 <dons> oh, galois has moved into downtown portland. our entire setup has physically moved.
00:08:27 <glguy> If it makes the downtime any easier to take, the new office is wonderful
00:08:36 <dons> and bandwidth is much better.
00:08:40 <sjanssen> glguy: no consolation for me :)
00:08:44 <sjanssen> more bandwidth is good
00:08:59 <dons> glguy: i want to go into work tomorrow, just cause its such a nice place to hang out
00:09:17 <glguy> I know... I was trying to figure out how to justify needing to go in
00:09:18 <dons> drink espresso, sit in the sun, hack. mm.
00:09:27 <dons> hehe
00:09:50 * dons expects some earlier starts this summer
00:09:59 <solrize> sounds nice
00:10:08 <ivanm> dons: you like hanging around at work? :o
00:10:09 <dolio> dons: Compiling with -funbox-strict-fields -O2 -fvia-c -optc-O3 speeds it up some, but it's still pretty slow.
00:10:14 <ivanm> I thought you didnt' work at google! :p
00:10:17 <dons> i'll take some photos of west coast haskell HQ next week :)
00:10:35 <dons> ivanm: yeah, well, we're getting a pooltable. so google might have to work a bit harder.. :)
00:10:42 <ivanm> heh
00:10:53 <ivanm> dons: but google has slides (at least in europe)!!!
00:10:57 <solrize> :t State
00:10:58 <mmmdonuts> Does it have a ball pit?
00:11:00 <lambdabot> forall s a. (s -> (a, s)) -> State s a
00:11:07 <dons> we actually took some ideas from google zurich for the fun stuff
00:11:17 <ivanm> except not the slide? :(
00:11:24 <dons> ivanm: yeah, no slides. fire excapes though!
00:11:27 <ivanm> lol
00:11:28 <glguy> We only have one floor to work with
00:11:51 <ivanm> you mean like the ubiquitous fire escapes american apartments have in US movies/TV?
00:11:59 <dons> the very same.
00:12:11 <glguy> fire escapes are an American thing?
00:12:13 <ivanm> which either feature as an alternative living area or else a way of breaking your legs when chasing after a suspect?
00:12:18 <solrize> @src State
00:12:18 <lambdabot> Source not found. My brain just exploded
00:12:29 <ivanm> glguy: how the yanks use them in their media seems to be!
00:12:29 <dons> glguy: yeah, i think it was some new york ordinance after a big fire? and they kind of spread from there.
00:12:44 <dons> external ones in older buildings
00:12:46 <solrize> you don't have them in .au or wherever you guys are???
00:12:49 <glguy> Europeans just jump into trampolines?
00:12:53 <dons> not external ones.
00:13:01 <ivanm> solrize: most people don't live in apartments here...
00:13:08 <solrize> do they just give everyone a parachute?
00:13:15 <dons> probably the US had highrises before they decided that internal escapes were a good idea
00:13:26 <dons> so they had to bolt them on the outside, like external plumbing
00:13:31 <ivanm> and most buildings have normal stairs that serve as fire escapes, rather than just lifts!
00:13:39 <solrize> hmm
00:13:49 <ivanm> dons: after all, we have these cool things called "elevators"... who needs stairs! :p
00:14:21 <dons> "The invention of these exterior steel staircases is widely credited to Anna Connelly who first registered a patent for a fire escape in the USA in 1887."
00:14:34 <dons> "all new construction above a certain number of stories was required to have external fire escapes throughout much of the 20th century"
00:14:38 <solrize> i guess i mostly see external escapes on smaller buildings, high rises you're left with the stairwell
00:14:50 <mmmdonuts> ivanm, have you ever seen "Towering Inferno" ?
00:14:54 <ivanm> nope
00:15:11 <solrize> :k State
00:15:12 <lambdabot> * -> * -> *
00:15:14 <mmmdonuts> You wouldn't be so blase about your elevators and internal stairs then...
00:15:24 <dons> huh, the wikipedia page *only* talks about US fire escapes, http://en.wikipedia.org/wiki/Fire_escape
00:15:37 <ivanm> mmmdonuts: I live in a 2-storey building, and at uni I normally use the stairs anyway
00:15:50 <ivanm> dons: because no-one else has dedicated ones, is my guess
00:16:20 <mapreduce> Some buildings in the UK have them, but they tend to be old buildings.
00:16:33 <solrize> Today, external fire escapes are rarely part of new construction.
00:16:36 <solrize> wow i didn' tknow that
00:16:43 <mapreduce> I've used them more in video games than in real life.
00:16:44 <solrize> i'm in a 4 or 5 story bldg with external escapes
00:16:56 <solrize> every now and then they get after us to clear the crap off that people leave out on them
00:17:01 <glguy> mapreduce: escaping burning buildings has come up much for you?
00:17:18 <ivanm> is there a version of iterate that lets me define a function like (a -> (b,a)) ?
00:17:29 <dons> dolio: so hmatrix conflicts with blas :)
00:17:42 <dons> since both require different versions of the lapack and blas bindings
00:17:46 <dolio> dons: Huge heap allocation.
00:17:52 <dons> too many libraries
00:18:12 <dolio> That program gives me 6.3 gigs of heap allocation.
00:18:16 <dons> lovely
00:18:22 <dolio> That is, the loop version I wrote.
00:18:38 <int-e> @type unfoldr
00:18:40 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:18:41 <dons> curious.
00:18:42 <int-e> ivanm: this?
00:18:54 <dons> ok, i've got it built now.
00:19:10 <ivanm> int-e: hmmmm..... that looks like it!
00:19:15 <ivanm> and it stops when it hits Nothing?
00:19:27 <dolio> I think at least. Let me make sure I didn't do something bad here.
00:19:48 <int-e> ivanm: yep
00:20:17 <ivanm> yay, that looks a lot better than what I've got atm with a dummy variable + iterate + takeWhile!
00:20:23 <ivanm> thanks int-e!
00:21:05 <Bourbaki> moin
00:21:26 <dolio> dons: Looking at the core, for instance: '$sunsafeGetDot1_r1fz :: ... -> IO Double'.
00:21:28 <dons> dolio: just reproducing his replicateM_ ?
00:21:37 <dolio> dons: Call that 10-million times in a loop.
00:21:44 <dons> yeah, that ffi stuff isn't going to flly.
00:21:57 <dons> i remember ndm complaining about similar things.
00:22:13 <dolio> dons: That needs that unboxing on returns from loops optimization.
00:22:22 <mapreduce> So how do you guys test IO actions?  E.g., something that renames a file.
00:22:33 <roconnor> @check \f x -> length (scanl1 f x) == length x
00:22:35 <lambdabot>  OK, passed 500 tests.
00:22:45 <roconnor> @check \f x a -> length (scanl f a x) == length x
00:22:46 <lambdabot>  Falsifiable, after 0 tests: <() -> () -> ()>, [()], ()
00:22:47 <dons> looks like the blas stuff could do with some inlining too
00:23:24 <roconnor> scanl1 is much nicer than foldr1
00:23:41 <dons> this is a big library.
00:23:57 <dolio> dons: Well, I marked all the relevant functions inline and recompiled and it didn't seem to get much better, but it may be a good idea anyway.
00:25:58 <dolio> Without the inlining, it's 4.1 gigabytes of heap allocation, but that's still bad.
00:26:28 <dons> well, i got replicateM_ getVec 25% faster with inlining, so it could float the constants out.
00:26:34 <dons> there's a bit to work on here.
00:27:24 <dons> i'm just using his replicateM_ example
00:28:52 <dons> dolio: note no unpacking in any blas data types
00:29:18 <ivanm> int-e: seems it doesn't work the same :s
00:29:48 <roconnor> is hackageDB down?
00:29:52 <ivanm> (as what I originally had)
00:29:54 <ivanm> roconnor: /topic
00:30:09 <dolio> dons: Yeah. I put -funbox-strict-fields in the cabal file. That should do it, no?
00:30:26 <dons> yeah
00:30:31 <roconnor> no cairo for me
00:30:33 <dons> getting there, $sunsafeGetDot1_r136 :: Addr#
00:30:33 <dons>                         -> ForeignPtrContents
00:30:33 <dons>                         -> Int#
00:30:33 <dons>                         -> Int#
00:30:35 <dons>                         -> Int#
00:30:37 <int-e> > unfoldr (\n -> Just (show n, n+1)) 0
00:30:38 <dons>                         -> Data.Vector.Dense.Internal.DVector
00:30:39 <lambdabot>  ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",...
00:30:40 <dons>                              BLAS.Access.Mut Int Double
00:30:43 <dons>                         -> IO Double
00:30:45 <dons> still got some Double returns though :(
00:31:25 <dolio> Yeah, those are probably pretty killer.
00:33:08 <int-e> ivanm: unfoldr (\xs -> case xs of (x : xs) -> Just (x, xs); [] -> Nothing) === id   pretty much defines unfoldr. (that's the counterpart to  foldr (:) [] === id)
00:33:30 <dons> still getting faster though
00:34:09 <dons> some fancy rewrite rules in there.
00:34:15 <int-e> ivanm: what did your function do?
00:34:47 <solrize> :t hRead
00:34:49 <lambdabot> Not in scope: `hRead'
00:37:31 <dons> dolio: interestin,
00:37:32 <dons> /tmp/ghc19688_0/ghc19688_0.hc:8619:0: error: incompatible type for argument 11 of â€˜cblas_zher2kâ€™
00:37:54 <cjs> Hm. So when I've got an app leaking memory by building up too many thunks, what's the best way to figure out what to try to evaluate strictly?
00:38:26 <solrize> profile?
00:38:26 <dons> profile, look at what's allocating, do heap profiling, to see what's being held where
00:39:16 <hpaste>  ivanm pasted "Wanting a cleaner version of componentsOf" at http://hpaste.org/8599
00:39:21 <ivanm> int-e: ^^
00:41:58 <Apocalisp> > (\x -> (`fmap` x) . (*) =<< x) [1,2,3]
00:41:59 <lambdabot>  [1,2,3,2,4,6,3,6,9]
00:42:01 <cjs> Yeah, I pretty much know exactly what's allocating, so off we go to heap profiling, I suppose.
00:42:04 <Apocalisp> @pl (\x -> (`fmap` x) . (*) =<< x) [1,2,3]
00:42:05 <lambdabot> (`fmap` [1, 2, 3]) . (*) =<< [1, 2, 3]
00:42:20 <Apocalisp> @pl (\x -> (`fmap` x) . (*) =<< x)
00:42:20 <lambdabot> (=<<) =<< (. (*)) . flip fmap
00:42:34 <Apocalisp> @unpl (=<<) =<< (. (*)) . flip fmap
00:42:34 <lambdabot> (\ g -> ((\ a p -> a ((*) p)) >>= \ i j -> j >>= i) (\ d -> fmap d g))
00:42:40 <solrize> :k Monad
00:42:41 <lambdabot> Class `Monad' used as a type
00:42:41 <Apocalisp> gah!
00:42:56 <solrize> :k List
00:42:58 <lambdabot> Not in scope: type constructor or class `List'
00:43:06 <solrize> :k Maybe
00:43:07 <lambdabot> * -> *
00:43:16 <Apocalisp> :k []
00:43:18 <lambdabot> * -> *
00:43:28 <solrize> :k StateT
00:43:29 <lambdabot> * -> (* -> *) -> * -> *
00:44:21 <Apocalisp> @unpl `fmap` x)
00:44:21 <lambdabot> Unbalanced parentheses
00:44:24 <Apocalisp> @unpl `fmap` x
00:44:24 <lambdabot> (\ a -> fmap a x)
00:44:35 <Apocalisp> clever syntax
00:45:23 <int-e> ivanm: hmm, your unfoldr version stops one step too early, I guess? try  componentsOf = unfoldr (\g -> if isEmpty g then Nothing else Just (splitComponent g))
00:45:44 <ivanm> k
00:46:36 <ivanm> thanks int-e! I didn't think about that :s
00:47:31 <solrize> hmm i thought it was usual to use a monad to attach a piece of extra data to an arbitrary type?
00:47:46 <solrize> how do i get back the extra piece when writing the return function?
00:48:31 <hpaste>  solrize pasted "silly monad" at http://hpaste.org/8600
00:48:32 <rwbarton> well, for example State s a = { runState :: s -> (a, s) } and return a = \s -> (a, s)
00:48:53 <solrize> hmm lemme see if i can do it that way
00:48:56 <int-e> ivanm: np
00:49:26 <hpaste>  solrize annotated "silly monad" with "(no title)" at http://hpaste.org/8600#a1
00:51:09 <solrize> is    return a = \s->(a,s)     the same as    return a s = (a,s)   ?
00:51:23 <solrize> return = (,)
00:51:28 <dolio> Huh, I'm suddenly getting all sorts of 'undefined reference to ...' messages on linking.
00:51:30 <solrize> :t (,)
00:51:32 <lambdabot> forall a b. a -> b -> (a, b)
00:51:38 <solrize> :t \s->(a,s)
00:51:39 <lambdabot> forall t. t -> (Expr, t)
00:51:56 <rwbarton> @src State return
00:51:56 <lambdabot> Source not found. You untyped fool!
00:52:18 <dolio> Never mind, I'm an idiot.
00:52:23 <dolio> I need to get sleep.
00:52:26 <rwbarton> Anyways, I think so.
00:53:04 <rwbarton> @src (State s) return
00:53:05 <lambdabot> Source not found. You speak an infinite deal of nothing
00:53:33 <solrize> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html#State
00:53:34 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
00:53:42 <rwbarton> Well not quite because I forgot about the constructor.
00:54:05 <solrize> right
00:54:26 <rwbarton> It may be that ReaderT Handle IO is what you want
00:54:40 <solrize> the \s is inside the constructor
00:56:21 <solrize> hmm
00:57:24 <solrize> ok i guess i have to read up on that
00:58:30 <solrize> i just didn't see an analogue to how State works
01:01:06 <solrize> thanks i'm getting sleepy but i think there is a clean answer to this so i'll keep looking for it
01:03:26 <hpaste>  cjs pasted "stack buster" at http://hpaste.org/8601
01:03:41 <Mr_Awesome> bah, i havent been able to connect to the hackage server all day
01:03:52 <cjs> I think I'm just dense here, but when I change the "if timeout" to "if _timeout", I blow up my stack.
01:03:54 <solrize> mr_awesome see the topic
01:04:05 <cjs> I can't seem to figure out why that is.
01:04:42 <Mr_Awesome> aha
01:06:26 <solrize> well _timeout is a let binding
01:06:41 <cjs> Indeed. How is that different?
01:06:43 <ivanm> http://humani.st/why-make-erlang-a-functional-language/ <--erlang syntax apparently comes from prolog and also derives from FP... wtf? isn't prolog logical?
01:06:44 <lambdabot> Title: Humanist &rarr; Why Make Erlang a Functional Language?
01:07:07 <cjs> Actually, if I replace, in the let binding, "tsSeconds ts" with "tsSeconds (time mkt)" it's ok.
01:10:37 <solrize> :t time
01:10:39 <lambdabot> Not in scope: `time'
01:10:52 <cjs> That's an accessor for my market data structure.
01:10:59 <cjs> This is really mysterious.
01:11:35 <solrize> try reading the core?  i forget how to access it though
01:11:53 <cjs> My brain is probably not up to that right now.
01:12:24 <cjs> Weird thing is, almost the exact same code is working elsewhere....
01:12:36 <mapreduce> ivanm: Declarative is the word.  I think functional and declarative are just two views of the same thing.
01:13:28 <PaulAJ> Is hackage down?  I don't seem able to get through
01:13:48 <PaulAJ> Sorry, ignore that, I just saw the MOTD.
01:14:34 <ivanm> mapreduce: hmmm.... he mentions more in the comments, where all he really meant that its syntax was "different"
01:16:24 <mapreduce> I didn't look; I was basing my answer on what you said here.
01:16:43 <roconnor> cjs: does timeout = _timeout?
01:16:48 <cjs> It's like using ts breaks tail recursion or something.
01:16:54 <cjs> Lemmie give you a new example.
01:17:30 <hpaste>  cjs annotated "stack buster" with "simple change" at http://hpaste.org/8601#a1
01:17:53 <cjs> So in that version, changing the (time mkt) to ts, where that comment is, is the thing that blows it up.
01:18:07 <roconnor> cjs: does the value of timout change as well?
01:18:33 <cjs> In that new version? I'm not sure I understand the question.
01:18:52 <roconnor> cjs: you are changing the code, causing a stack overflow
01:19:16 <roconnor> cjs: but I can't tell if your change affects the which branch of the if statement is executed.
01:19:49 <cjs> Oh. (time mkt) is the ts from the previous loop.
01:20:22 <cjs> updateMarket just plops it in there.
01:22:04 <roconnor> does processMarket h !mkt stop = ... make a difference?
01:22:47 <gwern> my god, hackage is still down?
01:23:01 <gwern> wasn't it supposed to be back up yesterday morn?
01:23:03 <cjs> Is there an option I have to turn on for that? I get "parse error in pattern" when I put a bang in front of mkt.
01:23:43 <roconnor> cjs: there is,  Not sure what it is off the top of my  head
01:23:52 <gwern> if course. LANGUAGE BangPatterns
01:24:14 <roconnor> -fglasgow-exts
01:24:31 <roconnor> I'm not sure the bang will help
01:25:05 <cjs> Yeah. It's not a space leak, after all (though I have that, too), it's a stack overflow.
01:25:22 <gwern> bang patterns can be tricky. I think there's software on hackage to just randomly add bang patterns until you get better performance
01:25:40 <roconnor> cjs: I assume you get the stack overflow later, when processing mkt
01:26:10 <roconnor> I think that maybe a space leak couls cause a stack overflow
01:26:16 <roconnor> could
01:26:23 <cjs> Really? I wonder how?
01:26:24 <roconnor> but I'm a little dubious
01:26:47 <roconnor> cjs: if updateMarket does (+) or(*) somewhere
01:26:59 <roconnor> cjs: when you eventually evaluate the final markets
01:27:07 <roconnor> it has to recurse a lot
01:27:13 <roconnor> and overflows the stack
01:27:19 <roconnor> ... possibly
01:27:25 * roconnor isn't sure
01:27:47 <roconnor> ... else mkt' `seq` processMarket h mkt' stop
01:27:49 <cjs> -XBangPatterns is the option, BTW.
01:27:54 <roconnor> if you don't want to use bang patterns
01:28:11 <cjs> Holy crud. !mkt fixes it!
01:28:32 <roconnor> cjs: ah good, It seems was right.
01:28:47 <cjs> And completely fixes the space leak.
01:28:59 <cjs> Wow. Well that's interesting to know.
01:29:13 <roconnor> I hate using seq
01:29:18 <cjs> And I wish I'd discovered -XBangPatterns a lot earlier. :-)
01:29:23 <roconnor> there must be some way of making things lazier
01:29:29 <Saizan_> cjs: http://www.haskell.org/haskellwiki/Stack_overflow
01:29:30 <lambdabot> Title: Stack overflow - HaskellWiki
01:29:41 <cjs> Yeah, I'm using seq elsewhere, but I bet I can get rid of that and use a bang pattern instead.
01:30:04 <cjs> (Well, `demanding`, actually.)
01:31:24 <roconnor> cjs: what the difference between processNextMessage and updateMarket?
01:32:24 <cjs> Oh, they're the same, actually. That function was just at the point where it had gotten so small it was about to disappear.
01:32:54 <roconnor> so processNextMessage doesn't do any IO?
01:33:31 <cjs> No.
01:34:50 <cjs> All right. That completely got rid of my `demanding` elsewhere in the code, too. Good trick!
01:38:39 <cjs> Ok, so it was blowing up the stack because it used as many stack frames as I had thunks when evaluating the thunks?
01:39:22 <Saizan_> yes, since you had a composition of strict functions in those thunks
01:40:21 <Saizan_> in general when you're using tail recursion with an accumulator it's better to make that accumulator evaluate at each recursion step
01:40:30 <roconnor> poor Haskell.  Not so good with accumulating parameters
01:46:32 <osfameron> accumulating parameters as in fold with a [] stack ?
01:47:54 * osfameron wonders if it's worth getting "Programming Haskell" if I already have SOE?  Meh, I'd like to, but I do have a budget on books, perhaps I'll just wait for RWH
01:49:56 <solrize> RWH really seems better than anything previously out there
01:52:08 <osfameron> I love the way it is being written -- mix of cathedral/bazaar
01:53:01 <Saizan_> is there a chapter on the risks of tail recursion?:)
01:53:38 <osfameron> though the last time I followed a book while it was being written (Higher Order Perl) I bought it immediately it came out and have still never read it cover to cover (because some chapters I'd already read drafts of I suppose)
01:53:57 <osfameron> what are the risks in haskell?
01:55:06 * osfameron pops over to a Doctor Who channel and misreads a comment about "The Recursion of the Daleks"
01:56:12 <Saizan_> what happened to cjs, having an huge thunk in an accumulating parameter that gets forced all at once at the end causing a stack overflow
01:57:19 <osfameron> ah I didn't read enough of the scrollback, sorry
01:57:30 <osfameron> yeah, that sounds like a good topic for a chapter
01:57:40 <osfameron> optimizing haskell in general kind of scares me :-)
02:00:31 <Saul_> When I use Data.Binary, there seem to be a lot of '\NUL' chars in there, can I get rid of those somehow?
02:03:46 <RayNbow> @seen bos
02:03:46 <lambdabot> I haven't seen bos.
02:04:04 <Saul_> Because at this point I might as well use show instead
02:07:33 <sjanssen> Saul_: what type are you serializing?
02:08:55 <hpaste>  Saul_ pasted "Serializing a list of these" at http://hpaste.org/8602
02:09:04 <Saul_> sjanssen: This one
02:09:10 <Saul_> A list of them
02:09:39 <sjanssen> oh, so you've derived the binary instance with some separate tool?
02:09:51 <Saul_> no I wrote instances myself
02:10:17 <Saul_> Following the example in http://code.haskell.org/binary/
02:10:17 <sjanssen> so wouldn't it be your fault if there is a \NUL? :P
02:10:18 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
02:10:41 <Saul_> I guess, but I'm not sure how to remove them
02:10:52 <sjanssen> well, they're probably important
02:11:29 <Saul_> I use a word8 for the choice of constructors in specifics, so I could probably make that a word1 or something
02:11:40 <sjanssen> there isn't such a thing
02:12:17 <Saul_> but the others I think are inserted by the default instances (like Int, List and String)
02:12:22 <Saul_> :(
02:12:32 <quicksilver> why are you so upset about NULs?
02:12:35 <quicksilver> what's wrong with them?
02:12:49 <sjanssen> yes, Strings are length prefixed with 8 bytes
02:12:54 <sjanssen> Int is also 8 bytes
02:13:04 <quicksilver> the list instance, IIRC, outputs the length first as an 8-byte constant
02:13:10 <quicksilver> if your lists are short, that's 7 NULs
02:13:24 <Saul_> ok I see
02:13:44 <quicksilver> Data.Binary chose speed over space, in this particular facet
02:13:51 <quicksilver> mind you it's a pretty small space penalty.
02:14:10 <quicksilver> if you're super-concerend about detailed data packing then you should use Get and Put directly
02:14:14 <quicksilver> and choose your own format.
02:14:31 <quicksilver> the Binary class is an efficient overall general purpose encoding.
02:14:31 <Saul_> But is there a way to instead of using a word8 for 3 choices, to use 2 bits?
02:14:40 <quicksilver> No.
02:14:43 <sjanssen> if all else fails, run it through gzip :)
02:14:48 <quicksilver> bit access is pretty inefficient.
02:14:55 <sjanssen> Saul_: binary is strictly byte aligned
02:15:10 <Saul_> Ok I get it
02:15:13 <quicksilver> the payoff (code complexity vs space savings) wasn't considered worth it.
02:15:33 <quicksilver> gzippig the output is almost certainly more effective than designing your own bit-packed format ;)
02:15:36 <Saul_> I'll use it as is then
02:15:48 <Saul_> quicksilver: I'll keep that in mind
02:15:50 <quicksilver> gzip can spot + compress patterns you may not be aware of.
02:16:03 <sjanssen> you might be able to be clever in a few places.  For example, what is the range of a RevNr?
02:16:53 <Saul_> sjanssen: It's from 1 to the length of the list of changes
02:17:07 <sjanssen> so no bound, really
02:17:21 <sjanssen> that doesn't help
02:17:27 <Saul_> not a constant one at least :)
02:18:54 <Saul_> sjanssen and quicksilver: thanks for the help
02:19:14 <Saul_> I'll just use it like it is, and gzip if necessary
02:30:55 <bauchus> is hackage.haskell.org  down?
02:33:09 <dibblego> bauchus, /topic
02:33:18 <quicksilver> although
02:33:21 <osfameron> is there a list-compare?  e.s. [1,2] == [1.2] ?
02:33:28 <quicksilver> according to my topic estimate it might be expected to be back up :)
02:33:31 <quicksilver> > [1,2] == [1,2]
02:33:36 <lambdabot>  True
02:33:49 <quicksilver> evidently galois downtime was slightly longer than originally expected.
02:33:59 <osfameron> ah... I just tried that in ghci but apparently I misspelt "," ;-)
02:34:04 <quicksilver> ;)
02:34:04 <osfameron> ta
02:34:08 <quicksilver> it's a tricky one to spell
02:34:10 <quicksilver> admittedly
02:34:11 <osfameron> yeah
02:34:28 <osfameron> ; before , except after .
02:34:59 <maltem> quicksilver: It's interesting that whoever set the topic specified UTC without giving an hour estimate
02:35:23 <maltem> quicksilver: oh, I realize that was you :)
02:37:40 <bauchus> thanks for the info
02:39:13 <bauchus> another question: is it possible to compile Haskell/OpenAL under windows?
02:39:47 <bauchus> I had no luck with it. There was a message like 'Your system is not supported'.
03:11:06 <quicksilver> UTC without an hour means mdinight :P
03:11:10 <quicksilver> btu I was clearly wrong
03:20:13 <adept> hi there. Could anyone enlighten me on why parsec-3 seems to be SO SLOW compared to 2.1.0? (up to 10x on my code)
03:22:07 <adept> is it added flexibility taking it's toll or am I missing something obvious?
03:25:01 <solrize> i've also heard it's slow
03:26:44 <adept> solrize: I took some not-so-sophisticated grammar and implemented it in Parsec, Polyparse and Alex+Happy
03:26:58 <adept> solrize: Polyparse code being 99% copypaste from Parsec
03:27:25 <adept> solrize: and time it. Polyparse came in first, Alex+Happy second and Parsec last
03:28:09 <adept> if we take Polyparse as 100%, then Alex+Happy was about 110-120% than time, and Parsec about 1800-2000%(!)
03:28:33 <adept> recompiling with parsec-2.1.0 dropped Parsec timings to 120-130% of Polyparse
03:29:22 <adept> With parsec 3.0, profiling shows that code spends around 10% time in the (<|>), which dominates profiling listing. Which is not right IMO
03:32:07 <solrize> i don't know about polyparse but i always heard happy was faster than parsec
03:32:41 <solrize> are you saying parsec2 is only 2x slower than happy?
03:33:01 <adept> solrize: not 2x, about 10-20% slower
03:33:16 <solrize> wow
03:33:28 <adept> solrize: like, 7sec Polyparse, 10s Happy, 12s Parsec2
03:33:58 <solrize> either parsec2 is impressive or happy isn't as fast as i'd thought i'd heard
03:34:11 <adept> solrize: and I tried Alex and Happy with wide variety of option - about 18 different variations of them
03:35:15 <solrize> i dunno i haven't used either
03:36:28 <Saizan_> adept: parsec3 has never been tuned for performance
03:39:41 <solrize> anyone used the packrat parser package?
03:40:16 <ivanm> is there a simple data type that _isn't_ an instance of Eq?
03:40:47 <quicksilver> ivanm: "data" tends to be natural instance of Eq.
03:40:52 <quicksilver> ivanm: (->) isn't
03:40:53 <ivanm> I'm just wondering why ghci isn't complaining about a function I wrote where I use elem, but haven't specified that a is an instance of Eq :s
03:40:57 <ivanm> quicksilver: *nod*
03:41:24 <quicksilver> it either propagated the constraint, or defaulted it
03:41:28 * ivanm quickly defines a single-constructor type that doesn't instantiate eq
03:41:39 <ivanm> oh, wait, functions, yeah...
03:41:45 <ivanm> misread that arrow...
03:41:55 <quicksilver> maybe it defaulted to Integer or ()
03:42:00 <quicksilver> depending if you have extended defaulting
03:43:46 <ivanm> oh, wait, duh.... FGL is using Ints as nodes
03:43:50 <ivanm> so it doesn't matter
03:45:10 <ivanm> hmmm... is there a way of joining two lists so that duplicates are removed? or is it just nub . (++) ?
03:48:06 <solrize> nub is quadratic time...
03:48:24 <mapreduce> I imagine that is easier if they're sorted.
03:48:39 <ivanm> solrize: yeah :s
03:48:47 <ivanm> oh well, the lists are probably both short anyway
03:50:59 <Saizan_> ?type S.toList . uncurry S.union . join S.fromList -- i wonder if this fuses somehow
03:51:01 <Deewiant> \a b -> (a ++ b) \\ (intersect a b) might be quicker?
03:51:01 <lambdabot>     Couldn't match expected type `(->) [a]'
03:51:01 <lambdabot>            against inferred type `S.Set'
03:51:01 <lambdabot>     Probable cause: `S.fromList' is applied to too many arguments
03:52:17 <Deewiant> > (\a b -> (a ++ b) \\ (intersect a b)) [5,4,3,1,2] [3,5,6,7]
03:52:20 <lambdabot>  [4,1,2,3,5,6,7]
03:52:50 <HunterXHunter2> @pl (\a b -> (a ++ b) \\ (intersect a b))
03:52:51 <lambdabot> (line 1, column 19):
03:52:51 <lambdabot> unexpected "\\"
03:52:51 <lambdabot> expecting variable, "(", operator or ")"
03:53:13 <HunterXHunter2> @pl \a b -> (a ++ b) \\ (intersect a b)
03:53:13 <lambdabot> (line 1, column 18):
03:53:13 <lambdabot> unexpected "\\"
03:53:13 <lambdabot> expecting variable, "(", operator or end of input
03:53:17 <Deewiant> @pl (\a b -> f (a ++ b) (intersect a b))
03:53:17 <lambdabot> ap (ap . (f .) . (++)) intersect
03:54:01 <mapreduce> @pl (\a b f -> f a b a b)
03:54:01 <lambdabot> join . (flip .) . (flip =<< (flip .) . flip . flip id)
03:54:22 <Deewiant> @pl (\a b f -> f (g a b) (h a b))
03:54:22 <lambdabot> ap (ap . ((flip . flip id) .) . g) h
03:54:49 <Deewiant> @pl (\f a b -> f (g a b) (h a b))
03:54:49 <lambdabot> (`ap` h) . (ap .) . (. g) . (.)
03:56:27 <nornagon> :t (.).(.).(.).(.)
03:56:29 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
03:56:53 <Smokey`> when I compile a program with GHC, does it embed the haskell runtime files into it?  or do I need to ship some GHC runtime libraries with the application?
03:57:03 <RayNbow> @pl f x = x x
03:57:03 <lambdabot> f = join id
03:57:05 <nornagon> the RTS gets embedded.
03:57:09 <RayNbow> :t join id
03:57:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
03:57:11 <lambdabot>     Probable cause: `id' is applied to too many arguments
03:57:11 <lambdabot>     In the first argument of `join', namely `id'
03:57:15 <Deewiant> (hence the binaries are so big)
03:57:30 <ivanm> GHC apps are build once, function everywhere!
03:57:36 <Smokey`> okey doke, thanks for that :)
03:57:48 <nornagon> well
03:57:53 <nornagon> everywhere on that architecture.
03:57:59 <Smokey`> yah :P
03:57:59 <nornagon> with that operating system.
03:58:39 <ivanm> nornagon: mere technicalities!
04:04:08 <Saizan_> and with libgmp installed
04:04:21 <maltem> still a dynamically-linked RTS would often be more fun
04:07:14 <ivanm> is gmp still required? :o
04:07:44 <ivanm> would it be bundled on windows builds?
04:08:28 <quicksilver> windows builds bundle everything, I think.
04:08:34 <quicksilver> linux builds tend to dynamically link to gmp
04:08:41 <quicksilver> OSX builds can do either.
04:09:07 <ivanm> quicksilver: linux distros tend to dynamically link to everything in general ;-)
04:09:41 <Saizan_> i think there's a flag like -static
04:13:45 <HunterXHunter2> @pl xx
04:13:45 <lambdabot> xx
04:14:01 <HunterXHunter2> @pl \f x -> x x
04:14:01 <lambdabot> const (join id)
04:14:13 <HunterXHunter2> @pl \f x -> x x x
04:14:13 <lambdabot> const (join (join id))
04:14:34 <HunterXHunter2> @pl \f x -> g y -> x y
04:14:34 <lambdabot> (line 1, column 13):
04:14:34 <lambdabot> unexpected ">" or "-"
04:14:34 <lambdabot> expecting variable, "(", operator or end of input
04:14:47 <HunterXHunter2> @pl \f x -> \g y -> x y
04:14:47 <lambdabot> const const
04:15:02 <HunterXHunter2> @pl \f x -> \g y -> x y  x y
04:15:02 <lambdabot> const (const . join . join flip)
04:16:10 <olsner> @ty \f x -> x x
04:16:12 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
04:16:12 <lambdabot>     Probable cause: `x' is applied to too many arguments
04:16:12 <lambdabot>     In the expression: x x
04:16:17 <nornagon> @ty \x -> x x
04:16:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
04:16:19 <lambdabot>     Probable cause: `x' is applied to too many arguments
04:16:19 <lambdabot>     In the expression: x x
04:16:27 <nornagon> darnit, olsner beat me.
04:18:49 <HairyDude> "hackage.haskell.org down until approx 2008.06.28 UTC" - errm, I think there's a time missing there?!
04:25:11 <adept> Saizan_: (re parsec3 not being tuned) sounds almost like GSoC project, but it's too narrow :(
04:25:46 <adept> Saizan_: it's a pity, though. Hope that parsec3 would not supercede 2.1.0 branch anytime soon as a "default parsec:
04:26:17 <Deewiant> can anything else parse bytestrings directly?
04:26:51 <Saizan_> adept: it was one of the ideas on the trac for this year soc
04:55:15 <telemach> @quote
04:55:15 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
04:55:34 <telemach> @quote
04:55:34 <lambdabot> DanPiponi says: Writing introductions to monads seems to have developed into an industry
04:55:54 <gwern> and hackage is still down?
04:56:03 <gwern> guess I won't be uploading darcs any-time soon
04:56:17 <mauke> preflex: quote
04:56:17 <preflex>  <pizza> back when we had only 1 bit of memory we never had these organizational problems
04:57:26 <telemach> :)
04:58:40 <telemach> hackage... where art thou...
04:59:12 <telemach> we need 20 mirrors like e. g. ubuntu.
04:59:33 <telemach> has hackage ever been slashdotted?
05:00:01 <gwern> don't think so
05:00:10 <gwern> and mirrors wuld only be read-noly, I want to write
05:02:15 <telemach> "mirrors" wasn't the right word.
05:02:36 <telemach> i thought of some distributed architecture.
05:02:40 <gwern> telemach: I mean, what would slashdot hackage? the most popular stuff for haskell are darcs & ghc, which aren't on hackage. and people aren't going to stampede there for xmonad (and xmonad is small anyway)
05:03:31 <telemach> how about darcs.haskell.org/yaht/yaht.pdf ?
05:03:47 <gwern> dunno. when'd that ever get slashdotted?
05:04:08 <telemach> yaht might draw quite some attention if linked on slashdot.
05:05:56 <telemach> anyway, was just a thought.
05:24:38 <alios> is there a problem with darcs.haskell.org?
05:34:25 <HairyDude> alios: see topic
05:35:08 <HairyDude> still think there's a time missing there though
05:46:41 <alios> HairyDude: 25x80 terminals didn't had that much chars on it like xterms today :) thnx
05:51:31 <solrize> is there something like replicateM' ?
05:52:14 <hpaste>  solrize pasted "stack overflow" at http://hpaste.org/8603
05:52:45 <RayNbow> solrize, yes
05:52:50 <RayNbow> @inedx replicateM
05:52:50 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:53:00 <EvilTerran> solrize, you could probably do it manually with foldl'
05:53:03 <solrize> hmm
05:53:13 <RayNbow> wow, lambdabot accepts the misspelled command @inedx O_O
05:53:21 <EvilTerran> not sure where you want the strictness to be exactly
05:53:35 <solrize> i'm not sure either, i just don't want a stack overflow :)
05:53:39 <nornagon> lambdabot checks hamming distance to known commands, i think.
05:53:45 <solrize> kewl
05:53:48 <nornagon> c.f:
05:53:52 <nornagon> @botslap
05:53:52 <lambdabot> Unknown command, try @list
05:53:55 <nornagon> aw
05:53:59 <nornagon> @botsmack
05:53:59 <lambdabot> :)
05:54:10 <RayNbow> @tyep \x -> x x
05:54:11 <lambdabot> Maybe you meant: temp type
05:54:17 <RayNbow> ah
05:54:19 <solrize> :t foldM
05:54:23 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:55:02 <EvilTerran> @goooogle
05:55:02 <lambdabot> Empty search.
05:55:26 <HunterXHunter2> @g
05:55:26 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . ? @ v
05:55:32 <HunterXHunter2> @go
05:55:32 <lambdabot> Empty search.
05:56:00 <EvilTerran> @no
05:56:00 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc undo v wn yow
06:04:03 <HairyDude> foldM looks like it's really foldlM
06:04:15 <HairyDude> which I guess makes sense
06:04:37 <hcube> hi
06:04:46 <HairyDude> if you want for example a [IO a] to be consumed from left to right
06:05:14 <HairyDude> sorry, a [a]
06:05:45 <solrize> hmm forM_ seems to have done it
06:05:56 <hcube> i did a bullet physiscs engine wrapper for haskell and also an example for it. how can i release it (maybe it will useful for somebody)
06:07:44 <hcube> when will hackage.haskell.org operate normally ?
06:08:42 <paolino> topic says tomorrow
06:09:15 <hcube> ok :p
06:09:45 <paolino> what's a bullet phiysics wrapper ?
06:10:23 <EvilTerran> "aerodynamics, yo"
06:10:29 <EvilTerran> no, wait, that's be "rapper". never mind.
06:11:19 <paolino> I thought balistics
06:12:02 <hcube> no. bullet is a zlbib/png licensed open source rigid and softbody physics library
06:12:37 <hcube> see: http://www.bulletphysics.com/Bullet/wordpress/bullet
06:12:39 <lambdabot> Title: Physics Simulation Forum » Bullet
06:13:44 <hcube> in my example is a box stack scene
06:15:30 <solrize> :t eval
06:15:31 <hcube> it can be useful for make games in haskell or for setup virtual environment for AI
06:15:32 <lambdabot> Not in scope: `eval'
06:16:52 <paolino> hcube: indeed
06:17:28 <hcube> but where can i send it? its my first haskell program :)
06:18:02 <BONUS> how come i can do instance (Num a) => Foo [a] where foo z = "WHATEVER"
06:18:03 <BONUS> but i cant do
06:18:14 <BONUS> instance (Num a) => Foo a where foo z = "WHATEVER"
06:18:28 <solrize>   forM_ a $ \x-> do {print x; Prelude.putStrLn ""}
06:18:43 <solrize> that seems to kill the stack overflow because printing x forces all its fields?
06:18:55 <EvilTerran> BONUS, because an instance head has to be of the form "Class (Constructor param param ...)"
06:19:08 <EvilTerran> unless you use extensions
06:19:16 <BONUS> aha
06:19:27 <EvilTerran> and, not only will you need -XFlexibleInstances, you'll need -XUndecidableInstances there too
06:19:33 <BONUS> oh my
06:19:59 <EvilTerran> because the inferrer will go "can i find an instance for (Foo a)? well, that would require an instance for (Num a), which is the same size. oh noes."
06:20:06 <BONUS> hmm
06:20:18 <BONUS> so theres no way i can make all types that are an instance of Num be an instance of some Foo
06:20:26 <BONUS> unless i use extensions
06:20:29 <EvilTerran> because the restrictions used to keep instances decidable work on a per-instance basis
06:20:47 <EvilTerran> and, if you had that instance, and, elsewhere, "instance Foo a => Num a", you'd get a loop
06:20:58 <EvilTerran> indeed
06:20:58 <BONUS> hmm
06:21:17 <EvilTerran> also, you'd need -XOverlappingInstances if you want to have any more instances of Foo
06:21:29 <BONUS> wow i see
06:21:30 <BONUS> thanks
06:21:32 <EvilTerran> because (Foo a) will overlap any other (Foo ...)
06:21:55 <EvilTerran> as it doesn't take the class context (on the left of the =>) into account when determining overlap
06:22:32 <BONUS> aha
06:22:34 <BONUS> interesting
06:22:50 <ddmnshs> @where hosting
06:22:50 <lambdabot> I know nothing about hosting.
06:23:04 <EvilTerran> BONUS, the usual trick is to add a newtype around things
06:23:20 <BONUS> yeah i was just about to do that
06:23:34 <BONUS> newtype (Num a) => N a = N a
06:23:35 <BONUS> like that?
06:23:35 <EvilTerran> like the "instance Monad m => Functor (WrappedMonad m)" in Control.Monad
06:24:12 <EvilTerran> you don't put class contexts on newtypes
06:24:20 <BONUS> oh you dont?
06:24:33 <EvilTerran> just newtype N a = N { unN :: a } or something
06:24:54 <BONUS> aha and then i add the class context on the instance declaration?
06:25:45 <BONUS> hey jfredett_
06:26:25 <EvilTerran> BONUS, exactly
06:26:41 <solrize> :k Put
06:26:42 <lambdabot> Not in scope: type constructor or class `Put'
06:26:46 <solrize> :k Data.Binary.Put
06:26:48 <lambdabot> *
06:26:49 <BONUS> kewl :]
06:43:01 <hcube> is there any 3d engine written in haskell ?
06:43:24 <HunterXHunter2> hopengl ?
06:43:29 <RayNbow> @check \x y -> y == 0 || (div x y == quot x y)
06:43:31 <lambdabot>  Falsifiable, after 0 tests: -3, 2
06:44:01 <hcube> hopengl is not an engine :) i've found a scene graph library
06:44:17 <HunterXHunter2> what is it called?
06:44:47 <hcube> http://www.haskell.org/haskellwiki/SceneGraph
06:44:48 <lambdabot> Title: SceneGraph - HaskellWiki
06:44:49 <hcube> :D
06:46:01 <Dewi> I am trying to build a package, hpodder, under debian etch
06:46:08 <Dewi> the makefile runs './setup configure', which fails with:
06:46:13 <Dewi> setup: Warning: Unknown field 'build-type'
06:46:13 <Dewi> setup: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly
06:46:44 <Dewi> I think a tool is too old, or I'm missing a dependancy, but can anyone suggest what it might be?
06:47:23 <hcube> unfortunatly i cant download the scene graph lib because hackage is down now :(
06:48:24 <Peaker> Does Haskell note that: f x y = if x == 0 then [] else (x:f x y)   is equivalent to:  f x y = let result = if x == 0 then [] else (x:result) in result  ?
06:48:29 <Peaker> s/Haskell/ghc
06:49:05 <Saizan_> Peaker: no
06:49:26 <Peaker> Saizan_, why, isn't it a trivial optimization?
06:49:48 <Peaker> (the use of the entire f x y as an expression is equivalent to calling f x y, given referential transparency)
06:50:49 <Saizan_> that kind of transformation is not always a win
06:51:30 <Saizan_> because sometimes keeping the old value around is more costly than recomputing it
06:52:27 <Peaker> Saizan_, but there are various optimizations that are done for which it is also true?
06:53:51 <Peaker> btw: It could be nice if a runtime environment kept statistics about how long it took to compute something, and could weigh that against how much it keeps in memory
06:53:52 <Saizan_> i think optimizations enabled with -O or -O2 are supposed to be safe in this regard
06:54:47 <maltem> Peaker: imagine to keep such statistics about any expression involved in a program :)
06:54:48 <Peaker> Ofcourse it would need feedback from the OS about how costly memory is now vs CPU time, but according to that information it could trade one off for the other automatically (something no other language can do)
06:55:48 <Peaker> maltem, I could "compress" that -- and for expressions whose computation time is extremely cheap, or whose memory requirements are lower than the overhead itself, keep just 2 bits specifying Avoid-Mechanism, and Keep/Recompute
06:55:57 <Saizan_> http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
06:56:00 <lambdabot> Title: GHC/FAQ - HaskellWiki, http://tinyurl.com/ywxcqq
06:56:06 <Peaker> I mean compress here as in keep a couple of bits only for very small objects
06:57:59 <Saizan_> what you describe would be handy as a profiling tool, or even to guide garbage collection in successive runs
06:58:08 <joby> DCC SEND startkeylogger 0 0 0
06:58:27 <Peaker> Saizan_, why not use that profiling information to make smart decisions about memory/cpu use on the fly?
06:58:54 <Peaker> Saizan_, forcing the developer to make that decision will necessarily make wrong decisions because cpu/memory costs are dynamic, depending on which is currently in need
06:58:59 <Saizan_> Peaker: it depends on the overhead/gain ratio i guess
06:59:25 <hcube> my physics wrapper and example consits of 2 files, and uses hopengl and haskell glut. how can i put it to the official haskell page, wiki or other ?  whats the procwedure of this ?
06:59:38 <hcube> *procedure
07:01:03 <maltem> hcube: the wiki is just a wiki, I don't think there's a procedure for it other than a click on "edit"
07:01:32 <maltem> oh, and signing up with a user name beforehand
07:02:19 <hcube> maltem: ok, then i'm going to make a wiki page for that stuff, but where can i put the two files ?
07:04:14 <maltem> hcube: wiki file upload maybe
07:04:41 <Saizan_> try to make a cabal file, so it's easier to build
07:04:44 <Peaker> ghc generates an imperative description of how to run the functional program.  Does ghci do the exact same thing (sharing code), only generating that description in the form of an IO monad value?
07:04:50 <Saizan_> s/file/package/
07:06:09 <dcoutts> Peaker: yeah it shares most code but instead of converting Core to C or to assembly it converts it to bytecode
07:06:46 <Peaker> dcoutts, "Core" is a semantic description of the program?
07:06:47 <dcoutts> Saizan_: btw, do you have some time this weekend to show me what's working so far?
07:07:28 <dcoutts> Peaker: Core is a simple typed functional language that ghc uses as an internal representation
07:08:17 <dcoutts> Peaker: it transforms Core down to a subset of Core (with additional annotations) called STG. STG has both a functional and an imperative operational semantics.
07:08:52 <Peaker> does that mean that STG specifies exactly how evaluation order should apply?
07:08:58 <dcoutts> yep
07:09:41 <Saizan_> dcoutts: yeah, did you look at the example rules?
07:09:42 <Peaker> Why are the ghc sources full of C code?
07:09:46 <dcoutts> Peaker: though obviously much of the evaluation order is data-dependent
07:10:02 <dcoutts> Saizan_: I've not yet. lemme darcs pull...
07:10:05 <Peaker> so ghc does:  Text->Desugaring->AST->Core->STG->ASM/C/Bytecode ?
07:11:16 <dcoutts> Peaker: something like that yes.
07:12:07 <dcoutts> Peaker: it's actually Text->AST->Core->STG->Cmm->ASM/C/ByteCode
07:12:18 <dcoutts> and STG is really just a kind of Core
07:12:24 <Peaker> Cmm?
07:12:35 <dcoutts> and there's a Cmm/C-- representation used between STG and final form
07:12:36 <Peaker> what are the benefits of Bytecode over simple values of (IO a) type (e.g interpreting it directly)?
07:12:57 <solrize> is c-- typed?
07:13:11 <dcoutts> solrize: weakly typed with machine level types, yes.
07:13:15 <EvilTerran> C is barely typed
07:13:34 <dcoutts> c-- has types like 8bit word, 16bit word etc
07:13:38 <solrize> ic
07:13:41 <solrize> thanx
07:13:42 * shapr yawns
07:14:02 <dcoutts> Peaker: you mean directly interpreting the STG abstract syntax tree? I guess bytecode is faster.
07:14:47 <Peaker> dcoutts, Well, bytecode seems to me as a serialization of (IO a) values.  Useful if you have to write it to a file or socket, but if you hold it in memory, you could just hold (IO a) values?
07:15:14 <dcoutts> Saizan_: could you checkpoint your cabal repo?
07:15:49 <dcoutts> Saizan_: darcs optimize --checkpoint  in the repo on the server side
07:16:50 <Saizan_> dcoutts: i thought i did that, or do you mean i should add a checkpoint?
07:17:07 <Saizan_> dcoutts: optimized now, however
07:17:09 <dcoutts> Saizan_: hmm, I'd have thought there'd be checkpoint already
07:17:18 <dcoutts> Saizan_: ok, lemme try again
07:18:37 <dcoutts> Saizan_: oops, my fault. I'd forgotten the --partial :-) now getting 119 patches rather than >1000 :-)
07:20:10 <dcoutts> Peaker: thing is, you start with a representation of the program. If one was writing an interpreter in Haskell then yes one could translate the STG into IO actions and use the host runtime to evaluate that. So it's not that it serialises IO actions, they never started as IO actions.
07:20:37 <shapr> Does darcs 2 have way to go from a partial to full repo?
07:22:02 <Saizan_> shapr: --lazy is supposed to download the missing parts if it needs them
07:22:06 <SamB> shapr: first of all, don't use --partial
07:22:11 <shapr> Saizan_: oh cool!
07:22:16 <SamB> that is, use --hashed
07:24:31 <hpaste>  desp pasted "Better way to write this?" at http://hpaste.org/8605
07:26:02 <desp> I.e. matching four prefixes of a string and chopping them off.
07:27:14 <hcube> here is my physics stuff: http://www.haskell.org/haskellwiki/Bullet
07:27:15 <lambdabot> Title: Bullet - HaskellWiki
07:28:45 <hpaste>  PaulAJ pasted "Help with GADTs and type arithmetic" at http://hpaste.org/8606
07:29:14 <PaulAJ> Hi.  I'm looking for help with type hacking
07:30:10 <PaulAJ> I'm trying to define a list that has its length encoded in its type.  Head, tail and cons work, but I can't figure out how to write the type signature for concat.
07:30:44 <dogbite> hi all -- is hackage.haskell.org down?
07:30:50 <PaulAJ> Yes
07:31:00 <PaulAJ> See the MOTD
07:31:12 <dogbite> sorry -- newbie.  how do i do that?
07:31:25 <desp> The topic, actually.
07:31:30 <PaulAJ> Me newbie too.  I saw it when I logged in.
07:31:32 <desp> "/topic"
07:32:02 <vixey> PaulAJ: what's the problem?
07:32:21 <dogbite> desp: thanks -- thanks PaulAJ too
07:32:27 <PaulAJ> Can you see my code on the pastebin?
07:32:33 <vixey> yes
07:32:43 <chr1s> PaulAJ: what does your Add look like?
07:33:30 <PaulAJ> GHC complains that it couldn't deduce Add n21 n2 n1 in pConcat, which is not surprising.  I'm trying to figure out what it ought to be.
07:33:43 <PaulAJ> ch1s: you should be able to see it.
07:34:06 <swiert> PaulAJ: I think the problem is in the Succ case for Add.
07:34:06 <chr1s> PaulAJ: there's no "class Add where"
07:34:28 <chr1s> swiert: hi!
07:34:42 <SamB> chr1s: maybe that's the problem ;-P
07:34:52 <swiert> PaulAJ: try something like: Add n1 n2 t => Add (S n1) n2 (S t)
07:34:59 <PaulAJ> I copied Add off the wiki.
07:35:00 <swiert> chr1s: hiya.
07:35:20 <PaulAJ> http://www.haskell.org/haskellwiki/Type_arithmetic
07:35:21 <lambdabot> Title: Type arithmetic - HaskellWiki
07:35:52 <nus> dcoutts, uhh, is cmm actually always involved in final translations?
07:36:34 <dcoutts> nus: I'm not sure about the bytecode one actually. Perhaps the bytecode is direct from stg.
07:37:03 <dcoutts> nus: but certainly the C and native assembler routes go via Cmm
07:37:51 <nus> dcoutts, what VM do bytecode ops implement?
07:38:31 <nus> like implement STG?
07:38:44 <dcoutts> nus: I'm not sure actually.
07:39:57 <vixey> PaulAJ: I don't think it's possible in haskell
07:51:08 <HairyDude> is there a standard implementation of balanced binary trees?
07:52:27 <dcoutts> HairyDude: not exactly. There are Set and Map data types which use balanced binary trees internally.
07:52:50 <HairyDude> dcoutts: I want the actual tree though.
07:53:01 <HairyDude> seems like a glaring omission to me
07:53:29 <dcoutts> HairyDude: not really. The standard libs mostly provide abstract data types, not so much concrete ones.
07:53:33 <therp> @go AVLTree hackage
07:53:34 <lambdabot> No Result Found.
07:53:36 <vixey> HairyDude: The source code is available
07:53:37 <HairyDude> hmm
07:53:40 <Saizan_> HairyDude: there are some on hackage.. not like it's very helpful atm..
07:53:46 <dcoutts> HairyDude: there's an avl tree package which gives you access to the internals
07:54:19 <Vq^> HairyDude: what do you want to do?
07:54:21 <HairyDude> dcoutts: sadly hackage is down atm :)
07:54:43 <dcoutts> aye, it's moving to a faster net connection
07:54:44 <HairyDude> Vq^: efficiently generating a random permutation of a list
07:55:45 <HairyDude> dcoutts: oh is that what's happening
07:57:36 <sw17ch> is darcs.haskell.org down for any one else?
07:58:08 <dcoutts> sw17ch: that's what we were just saying. Galois is moving to new offices with a faster net connection.
07:58:29 <HairyDude> dcoutts: to be fair, we were talking about hackage :)
07:58:34 <dcoutts> see also the topic
07:58:42 <HairyDude> but yes, RTFT ;)
07:58:43 <sw17ch> well, since darcs and hackage are on the same machine... :)
07:59:28 <HairyDude> it would have been nice if someone had set up a temporary home with just a web page saying "darcs and hackage are moving, back soon"
07:59:32 <sw17ch> monk.galois.com...
07:59:36 <Vq^> HairyDude: i guess you want a fully balanced tree for that
07:59:41 <HairyDude> Vq^: yes
08:00:15 <Vq^> HairyDude: the standard set/map trees actually allows for unusually inbalanced balanced trees
08:00:16 <sw17ch> i'm always somewhat curious why galois.com uses apache
08:00:25 <sw17ch> unless it's wrapping a haskell CGI app :)
08:00:46 <zachk> if something is type constrained as (Monad t) can I feed it any monad?
08:01:12 <HairyDude> sw17ch: because most websites on the net do?
08:01:51 <HairyDude> zachk: Monad t => <something containing t>, means t can be anything as long as it has a Monad instance. (in short, yes)
08:02:25 <zachk> ty HairyDude
08:02:43 <dcoutts> sw17ch: hackage is a haskell cgi app
08:02:53 <sw17ch> mm... alright
08:03:02 <sw17ch> now that i think about it, are there stand alone web servers yet?
08:03:11 <dcoutts> happs?
08:03:18 <dcoutts> and several other simpler ones
08:03:20 <sw17ch> mm... there we go
08:03:25 <sw17ch> well, wife is calling... back later
08:04:53 <RayNbow> http://www.reddit.com/r/programming/info/6pdlc/comments/ "Just what the funk is a Functor anyway? (blog.tmorris.net)"
08:04:54 <lambdabot> Title: programming: Just what the funk is a Functor anyway?
08:06:42 <zachk> > let t2 l1 l2=do {x<-l1;y<-l2;return (x+y)}
08:06:42 <lambdabot>  Parse error at end of input
08:06:55 <iamabarnacle> hello all
08:06:58 <zachk> hi
08:07:03 <iamabarnacle> have a newbie performance question here
08:07:13 <shapr> hi zachk
08:07:42 <iamabarnacle> in http://hpaste.org/8607, are both cases equivalent to each other in terms of efficiency is space consumption?
08:08:15 <iamabarnacle> i.e., does the first case allocate new space for xs?
08:08:44 <iamabarnacle> btw, using control.monad.state
08:09:08 <iamabarnacle> forgot to put it in the snippet -_-,
08:10:09 <kpreid> new...space?
08:10:15 <kpreid> this is a reference graph, not C
08:10:39 <kpreid> if there is any difference, it is in time, in that the second case executes get and tail
08:10:43 <iamabarnacle> um, sorry, i'm new to fp
08:11:17 <iamabarnacle> oh so pointers just get switched around, so to speak?
08:12:04 <kpreid> yes
08:12:17 <iamabarnacle> ok, got it
08:12:22 <iamabarnacle> thanks a bunch :D
08:13:13 <EvilTerran> iamabarnacle, head, tail etc are O(1) memory and time
08:13:52 <EvilTerran> two lists with common tails semantically will have common tails in implementation too
08:14:12 <EvilTerran> (well, in most sane implementations. the spec doesn't talk about implementation)
08:14:47 <Peaker> given the servers that are down, where can I read about Data.Stream?
08:16:18 <iamabarnacle> EvilTerran, thanks for elaborating. using ghc.  should be sane eh? :)
08:16:52 <EvilTerran> yeah, ghc is sane in this regard
08:16:57 <EvilTerran> so are hugs and yhc, i believe
08:17:26 <EvilTerran> it's like the report only specifies non-strict semantics, not lazy evaluation
08:17:46 <EvilTerran> but lazy evaluation is the sanest implementation of non-strict semantics
08:18:18 <Peaker> dcoutts, btw: I forgot to say thanks for all the explanations about ghc...
08:18:37 <dcoutts> Peaker: np
08:21:38 <iamabarnacle> just curious, what other implementations of non-strict semantics are there?
08:21:42 <Peaker> EvilTerran, what other implementations could there be of non-strict semantics?
08:21:48 <Peaker> heh
08:22:05 <dcoutts> call by name
08:22:06 <iamabarnacle> :P
08:22:08 <EvilTerran> well, a certain amount of pre-emptive parallelisation would be possible
08:22:23 <EvilTerran> ?src (&&)
08:22:23 <lambdabot> True  && x = x
08:22:23 <lambdabot> False && _ = False
08:22:54 <EvilTerran> start evaluating x in a seperate thread, but hold onto any exceptions that get thrown during the evaluation 'til we know if we need 'em
08:25:48 <iamabarnacle> i see, execute on the side and then dispose if not needed after all.  as opposed to execute only when needed
08:26:36 <iamabarnacle> what about call by name?
08:26:48 <Peaker> that sounds pretty sane to me, though
08:27:09 <Peaker> If you have some CPU cores lying around without any tasks, to try to evaluate things you'll potentially need
08:27:14 <iamabarnacle> Peaker, only if you have the cpu time to spare though, i think
08:27:18 <iamabarnacle> heh
08:28:28 <solrize> is there a way in IO to completely force some value without doing something like printing it?
08:28:52 <dcoutts> solrize: see 'evaluate'
08:29:06 <solrize> i tried that, i still get a stack overflow
08:29:14 <solrize> but the stack overflow goes away if i print the value
08:29:18 <dcoutts> solrize: though it only forces to weak head normal form, not normal form.
08:29:26 <solrize> right
08:29:42 <kpreid> solrize: evaluate . length . show comes to mind
08:29:43 <dcoutts> solrize: but the combination of rnf and evaluate will do the trick
08:29:51 <kpreid> rnf?
08:30:10 <solrize> kpreid yeah i guess that would work, but show is ultra slow
08:30:22 <dcoutts> see Control.Parallel.Strategies
08:30:30 <solrize> looking
08:31:00 <solrize> will try rnf
08:31:03 <dcoutts> kpreid: rnf is a generalisation of deepSeq
08:31:08 <kpreid> ah, that's just the thing, I see
08:31:24 <dcoutts> and more aimed at doing parallel evaluation, but it also provides simple serial evaluation
08:31:37 <kpreid> I also thought of using Data.Generics to walk the value
08:31:58 <kpreid> but rnf does no more work than necessary
08:32:01 <solrize>     No instance for (NFData FieldInfo)
08:32:01 <solrize>       arising from a use of `rnf' at fdt.hs:68:33-37
08:32:01 <solrize>     Possible fix: add an instance declaration for (NFData FieldInfo)
08:32:35 <dcoutts> solrize: ghc gives you a good suggestion
08:32:36 <solrize> hmm it's something like Show, where i have to write a class instance for every type i evaluate with it?
08:33:12 <kpreid> solrize: yes. http://haskell.org/ghc/docs/latest/html/libraries/parallel/src/Control-Parallel-Strategies.html contains instances (near the end) you can use for examples
08:33:13 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5paxso
08:33:14 <solrize> hmm that compiled
08:33:29 <solrize> stack overflow :(
08:33:30 <dcoutts> solrize: I think the derive tool can make NFData instances
08:33:45 <kpreid> solrize: does your instance do what it should?
08:33:55 <solrize> kpreid i added an empty instance declaration
08:34:01 <solrize> now i gotta look at the docs :)
08:37:07 <solrize> oh i see, i gotta spell it all out with seq
08:38:21 <solrize> hmm i added some !'s on the data constructor and ... whoops stack overflow
08:38:27 <solrize> but it took longer than before
08:43:46 <Peaker> what's a weak IORef?  Is that anything like weak refs in other languages?
08:45:02 <Peaker> is it a GHC extension? (GHC.Weak module..)
08:45:16 <EvilTerran> Peaker, i believe it's like weak refs in other languages, yes
08:46:37 <solrize> no stack overflow now, just seems to be leaing space
08:46:40 <solrize> leaking
08:47:06 <solrize> not responding to ctrl-C
08:47:23 <solrize> killed externally.
08:48:17 <solrize> welll thanks folks i gotta take off, i'll wrestle with this more later
08:48:21 <HairyDude> solrize: try ctrl-\ to kill something if it doesn't respond to ctrl-c
08:48:25 <solrize> hmm
08:48:29 <solrize> well too late now
08:48:35 <solrize> thanks tho
08:51:49 <pastorn> hackage still down?
08:52:05 <pastorn> oh, right, topic
08:52:09 <Peaker> yeah its apparently being carried to a new physical location by some 100-yo turtles
08:52:17 <pastorn> heh
08:52:50 <Zao> Some lazyness escaped from the servers and infected the turtles.
08:53:27 <Spark> you are all fired
08:54:47 <HunterXHunter2> 100 yo turtle is equivilent to a 10 yo human
09:00:31 <vixey> hehe
09:00:37 <vixey> "this * : * lark can't go on"
09:00:38 <Peaker> HunterXHunter2, do turtles live to the age of ~770?
09:03:13 <HunterXHunter2> they live to about 200 something
09:24:14 <vixey> :t foldr
09:24:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:27:53 <vixey> yeah editline is not quite perfect
09:32:18 <vixey> @pl \(x,y) -> P (Q x) y
09:32:18 <lambdabot> uncurry (P . Q)
09:32:34 <vixey> @pl \(x ::: y) -> P (Q x) y
09:32:34 <lambdabot> (line 1, column 6):
09:32:34 <lambdabot> unexpected ":"
09:32:34 <lambdabot> expecting "()", natural, identifier, "_" or "("
09:36:09 <edwardk> heya chessguy: yeah i have a few i suppose.
09:38:23 <chessguy_> edwardk: should probably discuss it in -blah, i guess
09:38:41 <chessguy_> or, for more fun, in #csharp :)
09:40:44 <vixey> in something like,
09:40:52 <vixey> data List a = Nil | Cons a (List a)
09:40:56 <vixey> what is 'List' called?
09:41:24 <ziman> a ttype constructor
09:41:54 <vixey> bleh haskell syntax sucks
09:42:01 <vixey> I can't name variables "type" or "in"
09:42:15 <mrd> or let, if, then, else
09:42:50 <chessguy> that's true for most languages
09:43:16 <vixey> not the kind I use
09:43:29 <mrd> lisp?
09:44:10 <Beelsebob> vixey: I've hit both of those problems before
09:44:20 <kryptiskt> algol-68 allowed whitespace in variable names. thats cool
09:44:21 <Beelsebob> the annoying this is that you get *really* confusing error messages when you forget
09:44:58 <ziman> tcl allows that too, doesn't it?
09:46:41 <dons> woot, hackage is up
09:47:18 <vixey> I am tired of writing
09:47:19 <vixey> import Prelude hiding (length)
09:47:19 <vixey> length = foldr (const (+1)) 0
09:47:45 <vixey> but I don't have enough ideas for a new Prelude
09:48:10 <mrd> why would you do that?
09:51:03 <xci> hey btw guys, what editors do you use when you type haskell? I just got curious as emacs is usually said to have done its haskell support better, but vim-users have their own nice plugins too, so, what do you prefer?
09:51:16 <mrd> i use either emacs or vim
09:51:57 <dons> vim, emacs largely
09:51:57 <mrd> really the difference is: do you want a ghci shell inside your editor, or do you prefer vim style?  reinke's vim bindings have all kinds of neat lookup tools and error-goto etc
09:52:51 <kryptiskt> vim or kate
09:56:05 <dolio> kate lacks good indenting for Haskell, which is a pain.
09:56:17 * edwardk just realized he is the only person in the blogosphere talking about recursion schemes.
09:56:33 <geezusfreeek> edwardk: visionary
09:56:52 <dolio> I don't think that's surprising.
09:57:00 <edwardk> geezusfreeek: nah, i'm a derivative hack, but it was amusing. its like everyone else realized they are useless and i'm the sole person slogging through them ;)
09:57:13 <geezusfreeek> i don't think they are useless
09:59:20 <dolio> Some of them are kind of practically useless.
09:59:38 <dolio> Like the memoizing ones that memoize into a list.
09:59:49 <dolio> (More or less)
09:59:50 <edwardk> well, you memoize into whatever structure you want
09:59:55 <geezusfreeek> well, i don't think _all_ of them are useless
09:59:59 <edwardk> thats what distHisto is for =)
10:00:41 <edwardk> but i'll agree that the memoizing ones are a bit 'stretched'. i keep meaning to write up a memoizing hylomorphism variant that doesn't suck.
10:01:22 <edwardk> anyways off to food
10:01:24 <geezusfreeek> i can't wait to learn all these, actually
10:01:28 <dolio> Yeah. They get you the big-O reduction you want, but actually using the memoized structures is less efficient than could be.
10:01:44 <dolio> If you did knot tying, for instance.
10:01:59 * dolio gets food, too.
10:03:33 <vixey> that's better
10:03:36 <vixey> cat > .ghci
10:03:38 <vixey> :set -XOverlappingInstances -XIncoherentInstances -XUndecidableInstances -XArrows -XForeignFunctionInterface -XGenerics -XImplicitParams -XNoImplicitPrelude -XNoMonomorphismRestriction -XNoMonoPatBinds -XRelaxedPolyRec -XExtendedDefaultRules -XOverloadedStrings -XGADTs -XTypeFamilies -XScopedTypeVariables -XTemplateHaskell -XBangPatterns -XCPP -XPatternGuards -XUnicodeSyntax -XMagicHash -XPolymorphicComponents -XRank2Types -XRankNTypes -XExistentialQua
10:03:38 <vixey> ntification -XKindSignatures -XPatternSignatures -XEmptyDataDecls -XParallelListComp -XUnliftedFFITypes -XLiberalTypeSynonyms -XTypeOperators -XRecursiveDo -XPArr -XRecordWildCards -XRecordPuns -XDisambiguateRecordFields -XUnboxedTuples -XStandaloneDeriving -XDeriveDataTypeable -XGeneralizedNewtypeDeriving -XTypeSynonymInstances -XFlexibleContexts -XFlexibleInstances -XConstrainedClassMethods -XMultiParamTypeClasses -XFunctionalDependencies
10:04:06 <Deewiant> what's wrong with "-fglasgow-exts -fth"
10:04:23 <vixey> I don't know
10:04:44 <vixey> does that do the same as mine?
10:05:01 <Deewiant> probably, at least mostly
10:05:19 <idnar> -XXX
10:07:42 <Baughn> ..why is it that every channel I switch to, I get to stare a giant wall of copy-paste in the face?
10:07:51 <dons> vixey: that's wacky.
10:08:09 <hpaste>  desp pasted "Can this be simplified by some magical deriving incantation?" at http://hpaste.org/8608
10:08:13 <dons> turning on all those things will just lead to unportable code, quickly.
10:08:46 <geezusfreeek> yay hackage!!!
10:09:22 <geezusfreeek> despite the thankfulness for patience on the mailing list, i was merely _quietly_ impatient ;)
10:09:33 <dons> heh
10:09:50 <vixey> I still don't have anything to write that anybody will use :/
10:10:13 <dons> time to cabal update
10:10:14 <geezusfreeek> me either unless somebody want to use a half-written, space-leaking FRP library
10:10:15 <desp> In C, I'd just use an int instead of defining my own type, and define rotateR as increment by 1 modulo 4... But Haskell makes me desire proper ADTs.
10:10:15 <int-e> desp: maybe derive Enum, then rotateR x = toEnum ((fromEnum x + 1) `mod` 4).
10:10:24 <desp> int-e: aha!!
10:10:42 <psyklops> vixey: do you have anything to write that nobody will use/
10:10:48 <desp> int-e: you rock.
10:11:47 <hpaste>  leoncamel pasted "myFoldl" at http://hpaste.org/8609
10:12:18 <leoncamel> almost become crazy about this code.
10:12:51 <dons> oh, you implemented foldl with foldr?
10:13:00 <leoncamel> dons: yes.
10:13:14 <dons> its a nice trick, the early build/foldr paper has a similar example
10:13:20 --- mode: ChanServ set +o dcoutts
10:13:24 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/", "{hackage,darcs}.haskell.org now back up"]' by dcoutts
10:13:28 --- mode: ChanServ set -o dcoutts
10:13:30 <leoncamel> dons: I read this code from book. But, I am not clear about it .
10:15:01 <leoncamel> dons: step id xs z = xs (f z id) ?
10:15:48 <leoncamel> dons: according to code ..
10:16:31 <dons> what are the types of id and xs?
10:16:58 <leoncamel> dons: list , I think. because of the first line
10:17:26 <dons> xs would have to be a function for that to make sense though
10:17:49 <leoncamel> dons: yes. I also think so. :). but, it seems ok on GHCI
10:18:52 <Deewiant> ?ty \step id xs z -> xs (f z id)
10:18:54 <lambdabot> forall t t1 t2 t3 t4. (SimpleReflect.FromExpr (t2 -> t1 -> t3)) => t -> t1 -> (t3 -> t4) -> t2 -> t4
10:18:59 <Deewiant> ;-)
10:19:31 <desp> int-e: thanks, this allowed me to simplify quite a bit.
10:20:01 <leoncamel> Deewiant: what does that mean ?
10:21:13 <Deewiant> it's the type of the step function... modulo the fact that it's using a definition of 'f' which probably isn't the same as in your case (and that I typoed and included step as a parameter)
10:21:43 <zachk> @source 'mod'
10:21:43 <lambdabot> 'mod' not available
10:21:49 <zachk> whats modulo in haskell
10:22:02 <Deewiant> ?ty mod
10:22:04 <lambdabot> forall a. (Integral a) => a -> a -> a
10:22:30 <desp> zachk: n `mod` k
10:22:31 <mrd> @src mod
10:22:31 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:23:45 <HairyDude> heh, by chance I checked hackage again just now, less than 10 mins after it came back up
10:27:10 <leoncamel> Deewiant: but I am not clear, about http://hpaste.org/8609, the step should be "a->b->b" .. right ?
10:27:20 <leoncamel> Deewiant: or I missed something ...
10:28:03 <zachk> just as Hell is a real place, so is Haskell http://www.cityofhaskell.org/
10:28:03 <lambdabot> Title: City of Haskell, Haskell Arkansas
10:28:40 <roconnor> where do I get Graphics.Rendering.Cairo?
10:29:11 <thoughtpolice> roconnor: it's part of gtk2hs
10:29:20 <thoughtpolice> roconnor: just build and make sure you --enable-cairo
10:29:35 <Deewiant> ?ty \f x g a -> g (f a x)
10:29:36 <lambdabot> forall t t1 t2 t3. (t1 -> t -> t2) -> t -> (t2 -> t3) -> t1 -> t3
10:29:52 <roconnor> oh right, maybe I don't have gtk2hs installed at the moment.
10:31:39 <Peaker> hey, would it be misleading to say that arrows are non-opaque functions?  A composed Haskell function can only be called, but an arrow composition can be a usable data structure
10:33:35 <nus> @src (.)
10:33:35 <lambdabot> (f . g) x = f (g x)
10:33:35 <lambdabot> -- In lambdabot, it's been generalised to:
10:33:35 <lambdabot> (.) = fmap
10:33:36 <ziman> isn't a function a data structure?
10:33:55 <nus> "code is data"
10:35:02 <vixey> functions are not data
10:35:14 <nus> vixey, how come?
10:35:21 <HairyDude> functions are codata
10:35:24 <HairyDude> ;)
10:35:32 <HunterXHunter2> what is a codata?
10:35:45 <Peaker> The only thing you can do to a function is apply it
10:35:48 * HairyDude can't be bothered to explain
10:36:01 <HunterXHunter2> ok
10:36:01 <Peaker> An arrow lets you do other things with the composition
10:36:15 * roconnor wonders if HairyDude even knows
10:36:19 <vixey> functions aren't codata
10:36:30 <Peaker> I don't think we have to resort to mathematical name calling to explain these things :)
10:36:48 <HairyDude> you can represent certain functions as terminal coalgebras, so they effectively are
10:37:03 <roconnor> HairyDude: ah cool.
10:37:15 <HairyDude> it's one way of doing memoization
10:37:21 <vixey> HairyDude: You can represent functions as infinite sets of pairs but that's not how it is in haskell
10:37:28 <HairyDude> yes
10:37:36 <erwin> hello
10:37:36 <HairyDude> they're isomorphic to codata, then ;)
10:38:08 <roconnor> are functions of functions data again?
10:38:26 <vixey> hi erwin
10:38:28 <HairyDude> ro: err, no, the approach only works for first order functions.
10:38:52 <roconnor> HairyDude: huh?
10:38:59 <vixey> almost no functions in haskell are first order
10:39:06 <nus> it's as much data as your language is reflective
10:39:16 <roconnor> HairyDude: you mean that functions being codata only applies to first-order functions?
10:39:19 <HairyDude> vixey: in the sense that curried functions are higherorder, I guess
10:39:24 <HairyDude> roconnor: yeah
10:39:33 <roconnor> HairyDude: which means that functions of functions might be data :)
10:39:52 <vixey> HairyDude: and any polymorphic function has implicit foralls in its type
10:39:56 <HairyDude> nah, it would be one step beyond codata, whatever the hell that means :)
10:40:33 <roconnor> HairyDude: co-codata
10:40:40 <roconnor> which is isomorphic to data :P
10:40:48 <HairyDude> roconnor: ah, I see what you mean :)
10:40:57 <HairyDude> hmm, are the computable functions countable?
10:41:21 <int-e> HairyDude: sure. turing machines are countable.
10:41:24 <roconnor> HairyDude: nat has decidable equality
10:41:24 <HairyDude> ah yeah
10:41:30 <roconnor> HairyDude: nat -> has no decidable equality
10:41:37 <roconnor> HairyDude: nat -> nat has no decidable equality
10:41:47 <roconnor> HairyDude: (nat -> nat) -> nat has decidable equality again
10:42:01 <HairyDude> really?
10:42:29 <vixey> roconnor: equality? what's that :)
10:42:44 <HairyDude> roconnor: how do you define equality on (nat -> nat) -> nat then?
10:42:51 <roconnor> HairyDude: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:42:53 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs, http://tinyurl.com/2umqwh
10:42:57 <roconnor> HairyDude: extensional equality
10:42:59 <HairyDude> oh yeah, I vaguely remember that
10:43:24 <HairyDude> coincidentally you cite my supervisor there :)
10:43:28 <roconnor> I don't know if this decidable equality thing is related to being data or codata or not.
10:43:38 <roconnor> HairyDude: Escardo?
10:43:42 <HairyDude> roconnor: Berger
10:44:35 <roconnor> oh wait
10:44:38 <roconnor> maybe I lied
10:44:51 <roconnor> (nat -> bool) -> bool has decidable equality
10:44:59 <roconnor> not sure about (nat -> nat) -> nat
10:45:01 <HairyDude> heh
10:45:06 <roconnor> ... I guess probably not :(
10:45:32 <vixey> bool -> bool has decideable equality
10:45:41 <roconnor> yep
10:45:59 <roconnor> but bool -> bool is data, despite what HairyDude might say.
10:46:25 <HairyDude> <pedantic> isomorphic to data </pedantic>
10:46:30 <roconnor> :)
10:46:31 <HairyDude> depends how you define data I guess
10:46:53 <roconnor> finite types are isomorphic to both data and codata I suppose.
10:48:00 <HairyDude> there are only 4 total functions bool -> bool, right? (id, not, const true, const false)
10:48:13 <int-e> right, you can either define them by their constructors (inductive, data) or by their destructors (case analys, coinductive, codata)
10:48:20 <roconnor> assuming we are talking about extensional equality.
10:48:22 <int-e> alalysis.
10:48:25 <vixey> > liftM2 (,) [True,False] [True,False]
10:48:26 <lambdabot>  [(True,True),(True,False),(False,True),(False,False)]
10:48:35 <mattam> roconnor: (bool -> nat) -> bool may be decidable?
10:49:03 <roconnor> mattam: that is isomorphic to nat -> bool
10:50:56 <HairyDude> roconnor: via a suitable embedding of (bool -> nat) -> nat
10:51:16 <HairyDude> since bool -> nat is basically pairs of nats
10:51:35 <mattam> So that's not decidable, only semi-decidable?
10:51:54 <roconnor> right
10:52:34 <HairyDude> (nat -> bool) -> bool maybe
10:52:46 <joey_> I figure someone in here should know
10:52:48 <HairyDude> ah, like roconnor said
10:52:48 <int-e> roconnor may be after this, http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:52:49 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs, http://tinyurl.com/2umqwh
10:53:05 <joey_> Is {}* == epsilon?
10:53:15 <joey_> That's the kleene star of the empty set
10:53:28 <HairyDude> int-e: he mentioned that already ;)
10:53:38 <int-e> oh.
10:53:44 * int-e feels superfluous :)
10:54:06 <int-e> joey_: {epsilon}. epsilon is always a member of X* for any X.
10:54:43 <joey_> int-e: Thanks.
10:56:40 <HairyDude> hmm, if Cantor -> Bool has decidable equality, do we get decidable equality on real numbers represented as Rational x (Cantor -> Bool) as well? or is it not possible to represent the reals like that?
10:57:18 <desp> @pl f (a, b) (c, d) = (a + c, b + d)
10:57:19 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:57:34 <desp> Really?
10:57:59 <HairyDude> point free style is not always sensible
10:57:59 <Peaker> wow, worst @pl ever
10:58:31 <desp> Is there maybe a magic way to do tuple sums?
10:58:58 <opqdonut> > let f = (***) &&& (***) in f (1,2) (10,20)
10:58:58 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
10:59:11 <opqdonut> ah
10:59:23 <opqdonut> > let f = (+) *** (+) in f (1,2) (10,20) -- what was i thinking
10:59:24 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
10:59:49 <Deewiant> > let f = uncurry ((+) *** (+)) in f (1,2) (10,20)
10:59:50 <lambdabot>  Couldn't match expected type `b -> c'
10:59:50 <HairyDude> isn't it helpful that lambdabot gives you the inferred type too
10:59:54 <Deewiant> d'oh
11:00:26 <opqdonut> mm yeah, binary
11:00:49 <Deewiant> > let f (a,b) = (+a) *** (+b) in f (1,2) (10,20)
11:00:50 <lambdabot>  (11,22)
11:00:51 <Deewiant> :-P
11:00:58 <Deewiant> @pl f (a,b) = (+a) *** (+b)
11:00:58 <lambdabot> f = uncurry ((. (+)) . (***) . (+))
11:00:59 <desp> Haha.
11:01:03 <Deewiant> ah, so that's what we wanted
11:01:05 <int-e> HairyDude: You can't represent them like that, I believe. The caveat is that the (Cantor -> y) functions must be total, which means that any particular such function can only query finitely many positions of its argument.
11:01:06 <Deewiant> of /course/
11:02:08 <paolino> anyone has an algorithm to index hexagons on an hexagonal tiled board  and a integer function distance on them ?
11:02:44 <Deewiant> amit does, somewhere at http://www-cs-students.stanford.edu/~amitp/gameprog.html#hex
11:02:45 <lambdabot> Title: Amitâ€™s Game Programming Information
11:02:53 <HairyDude> you can represent the reals as Rational x (Nat -> 3) (where 3 is a 3-element set)
11:05:22 <dons> ?users
11:05:22 <lambdabot> Maximum users seen in #haskell: 469, currently: 453 (96.6%), active: 17 (3.8%)
11:05:25 <HairyDude> the Nat -> 3 is a fast Cauchy sequence on the compact interval [-1,1], then the role of the Rational is to pin it down somewhere on the real line.
11:05:58 <HairyDude> dons: is that an all time maximum?
11:06:59 <Peaker> "active" in the last how long?
11:08:14 <OceanSpray> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . fix $ show
11:08:23 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
11:08:38 <OceanSpray> oh good lord.
11:09:09 <Deewiant> >  map (2^) [1..]
11:09:10 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
11:09:50 <chessguy> Deewiant:you party-pooper
11:10:13 <HairyDude> hehe
11:10:45 <ddarius> HairyDude: The all time maximum is like 480 some
11:11:08 <HairyDude> hmm
11:11:09 <HairyDude> > fix show
11:11:10 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
11:11:20 <HairyDude> oh, that's clever
11:11:26 <ddarius> There seems to be a bug in Haddock's display of data types containing functions: http://hackage.haskell.org/packages/archive/reactive/0.5/doc/html/Data-Fun.html
11:11:28 <lambdabot> http://tinyurl.com/5hqsvh
11:11:44 <Deewiant> > map length . group . fix $ show
11:11:54 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
11:12:34 <vixey> :t breakBy
11:12:36 <lambdabot> Not in scope: `breakBy'
11:12:40 <vixey> @src break
11:12:41 <lambdabot> break p =  span (not . p)
11:13:32 <HairyDude> ddarius: that should be "Fun (t -> a)" right?
11:13:38 <ddarius> Yes.
11:15:47 <int-e> > fix ((1:) . intersperse 1 . map (1+))
11:16:02 <lambdabot>  thread killed
11:16:23 <int-e> > let intersperse' x [] = []; intersperse' x (y:ys) = y : (ys >>= (x:) . (:[])) in  fix ((1:) . intersperse' 1 . map (1+))
11:16:24 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
11:17:04 <int-e> Data.List.intersperse is a little bit more strict than necessary.
11:17:58 <Deewiant> @src intersperse
11:17:58 <lambdabot> intersperse _   []     = []
11:17:58 <lambdabot> intersperse _   [x]    = [x]
11:17:58 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
11:18:10 <vixey> > let (x:xs)`interleave`ys = x:(ys`interleave`xs) in foldr interleave [] (map repeat [1..])
11:18:14 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
11:20:39 <vixey> > describeSequence (let (x:xs)`interleave`ys = x:(ys`interleave`xs) in foldr interleave [] (map repeat [1..]))
11:20:55 <lambdabot>  thread killed
11:21:08 <vixey> @oies 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5
11:21:08 <lambdabot> The ruler function: 2^a(n) divides 2n. Or, a(n) = 2-adic valuation of 2n.
11:21:08 <lambdabot> [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,...
11:21:30 <vixey> what's a?
11:21:43 <int-e> "the sequence"
11:22:27 <int-e> (http://www.research.att.com/~njas/sequences/A001511)
11:22:28 <lambdabot> Title: id:A001511 - OEIS Search Results
11:22:36 <vixey> > zipWith rem [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1] [1..]
11:22:37 <lambdabot>  [0,0,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1]
11:22:41 <vixey> > zipWith rem [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1] [0..]
11:22:42 <lambdabot>  [Exception: divide by zero
11:23:49 <OceanSpray> The Haskell 98 Language and Library Reports were published in February 1999
11:24:03 <scodil> a peanut is neither a pea, nor a nut
11:24:11 <OceanSpray> So is the Haskell' report expected in february next year?
11:25:22 <vixey> > (10000000000000%)
11:25:23 <lambdabot>  <Integer -> Ratio Integer>
11:25:51 <int-e> > zipWith (\n t -> n `mod` 2^(t-1) == 0 && odd (n `div` 2^(t-1))) [1..] [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1]
11:25:52 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
11:26:29 <vixey> oh.
11:27:19 <int-e> or better, n `mod` 2^t /= 0  for the second condition.
11:27:36 <vixey> @let let dr n=(!!0)$filter((==0).(n`mod`))[2..n] in facs 1=[];facs n=dr n:facs(n`div`dr n)
11:27:36 <lambdabot>  Parse error
11:27:46 <vixey> @let  dr n=(!!0)$filter((==0).(n`mod`))[2..n] ; facs 1=[];facs n=dr n:facs(n`div`dr n)
11:27:46 <lambdabot> Defined.
11:27:58 <vixey> > map (last.facs) [1..]
11:27:59 <lambdabot>  [Exception: Prelude.last: empty list
11:28:03 <vixey> > map (last.facs) [2..]
11:28:04 <lambdabot>  [2,3,2,5,3,7,2,3,5,11,3,13,7,5,2,17,3,19,5,7,11,23,3,5,13,3,7,29,5,31,2,11,1...
11:28:09 <marcot> Haddock is consuming 700M+ in gtk2hs compilation.
11:28:13 <marcot> Is this expected?
11:28:30 <vixey> > map (last.facs.(2^)) [2..]
11:28:32 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
11:28:48 <vixey> how do you generate the sequecne?
11:30:12 <vixey> > map (length.facs.(2^)) [2..]
11:30:15 <int-e> > map (\n -> length $ takeWhile (\t -> n `mod` 2^t == 0) [0..]) [1..]
11:30:16 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
11:30:18 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
11:30:38 <int-e> that's the naive way
11:30:55 <vixey> > map (\n -> takeWhile (\t -> n `mod` 2^t == 0) [0..]) [1..]
11:30:56 <lambdabot>  [[0],[0,1],[0],[0,1,2],[0],[0,1],[0],[0,1,2,3],[0],[0,1],[0],[0,1,2],[0],[0,...
11:32:31 <Peaker> I am thinking about a function composition library that lets you write functions that process changing values, where the actual work behind the scenes is done on changes, and not on the values themselves..
11:32:37 <int-e> > map ((1+) . length . filter (==2) . facs) [1..]
11:32:38 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
11:32:46 <Peaker> Example:   changingSet >>> deltaSort >>> deltaDropWhile (<5) -- When changingSet gets new elements, modifications, or deletions, deltaSort does not resort the entire thing, but only the change. sort will then generate a delta too, and deltaDropWhile will act similarly.
11:32:46 <int-e> vixey: or that.
11:32:54 <vixey> oh cool
11:33:11 <Peaker> what could the type of deltaSort be? How would I represent a "changingValue"?
11:34:10 <Peaker> one possibility is perhaps: deltaSort :: Stream [Change a] -> Stream [Change a] (where a is the sorted type)
11:34:25 <Peaker> does anyone have any ideas or pointers to related work?
11:34:39 <vixey> it sounds like FRP
11:35:19 <Peaker> Does FRP do its computations differentially? Is there a differential sort, for example?
11:36:21 <Peaker> FRP does have a Signal/Behavior - but its not differential
11:37:12 <Peaker> In Conal's work, you could even use "fmap sort" on the Behavior - and that would be totally non-differential
11:37:40 <Peaker> In Yampa, I am not sure, but it does use arrows, so I wonder what kind of things you'd be allowed to do with "pure"
11:38:11 <int-e> @type pure sort
11:38:13 <lambdabot> forall a (f :: * -> *). (Applicative f, Ord a) => f ([a] -> [a])
11:38:35 <int-e> @type arr sort
11:38:37 <lambdabot> forall a (a1 :: * -> * -> *). (Arrow a1, Ord a) => a1 [a] [a]
11:38:51 <Peaker> Yampa supposedly does not give you access to signals, so maybe you're not supposed/capable of actually using pure, despite its use of arrows
11:39:00 <Peaker> oops, I meant "arr" there :)
11:39:04 <Peaker> s/pure/arr everywhere
11:39:29 <Peaker> those it does sound like the distinction is an accident
11:39:37 <idnar> @type pure
11:39:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
11:39:52 <Peaker> @src Arrow
11:39:53 <lambdabot> class Arrow a where
11:39:53 <lambdabot>     arr, pure   :: (b -> c) -> a b c
11:39:53 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
11:39:53 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
11:39:53 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
11:39:55 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
11:39:57 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
11:40:03 <Peaker> not a subclass of Applicative
11:40:14 <int-e> Peaker: but afair FRP also came with integrators, which would have to be implemented incrementally.
11:40:26 <int-e> of course not, arrows take two type arguments, applicative has only one
11:40:30 <Peaker> int-e, integrators as in the function "integral"?
11:40:35 <int-e> yeah
11:41:27 <Peaker> pure is an alias for arr?
11:41:44 <idnar> @type arr
11:41:45 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
11:41:48 <dmwit> Peaker: yes
11:42:07 <int-e> @src Applicative
11:42:07 <lambdabot> class Functor f => Applicative f where
11:42:07 <lambdabot>     pure  :: a -> f a
11:42:07 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:43:04 <int-e> lambdabot does  import Control.Arrow hiding (pure)
11:43:52 <Peaker> int-e, so maybe an incremental sort is also possible?
11:44:10 <vixey> incremental ?..
11:44:15 <vixey> don't you mean insertion sort
11:44:18 <roconnor> Prelude> :m + Graphics.Rendering.Chart
11:44:18 <roconnor> module main:Graphics.Rendering.Chart is not loaded
11:44:23 <roconnor> what does this error mean?
11:44:35 <Peaker> vixey, yes - operating on deltas, and generating deltas
11:44:53 <Deewiant> roconnor: it means load it instead, use :l
11:45:22 <roconnor> I've never used :l in my life
11:45:26 <Peaker> int-e, Actually, integral is not really differential - as it does not take a delta and generate a delta. It takes the (oldState, newValue) and generates a newState
11:45:33 <Deewiant> I didn't either, until I got said message
11:46:05 <roconnor> Deewiant: :)
11:46:59 <Deewiant> well, if it says "foo is not loaded" and there's a command "load" then what'cha gonna do :-P
11:50:22 <paolino> is it possible to read a number written in base 2 ?
11:50:31 <Peaker> How would an FRP implementation of an IRC client display the history-lines?  You need a (Behavior [String]) for the widget displaying the text lines, which is inherently terrible when appends take place (having to recompute everything. e.g filter by ignore list)
11:50:49 <roconnor> @seen twd
11:50:49 <lambdabot> I haven't seen twd.
11:51:09 <paolino> with read :: String -> Int
11:51:24 <ddarius> @hoogle readBase
11:51:24 <lambdabot> No matches found
11:51:31 <roconnor> Does Tim Docker hang out here?
11:51:48 <paolino> :t readBase
11:51:49 <Peaker> > let fromBase base digits = sum $ zipWith (*) digits (map (base^) [0..]) in fromBase 2 [1,0,1,1]
11:51:51 <lambdabot> Not in scope: `readBase'
11:51:52 <lambdabot>  13
11:51:54 <Deewiant> > readInt 2 (`elem` "01") (\s -> ord s - ord '0') "010101"
11:51:55 <lambdabot>  [(21,"")]
11:52:26 <ddarius> :t Text.Read.Lex.readIntP
11:52:28 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> Text.ParserCombinators.ReadP.ReadP a
11:52:33 <Deewiant> :t readInt
11:52:34 <roconnor> > readInt 2 (`elem` "01") readDigit "010101"
11:52:35 <lambdabot>   Not in scope: `readDigit'
11:52:35 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
11:52:44 <Peaker> @hoogle digit
11:52:44 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
11:52:44 <lambdabot> Data.Char.digitToInt :: Char -> Int
11:52:44 <lambdabot> Data.Char.isDigit :: Char -> Bool
11:52:55 <roconnor> > readInt 2 (`elem` "01") digitToInt "010101"
11:52:56 <lambdabot>  [(21,"")]
11:53:14 <Peaker> @type readInt
11:53:16 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
11:53:22 <Deewiant> I always forget the name of digitToInt and never bother to look for it :-)
11:53:34 <ddarius> @hoogle Char -> Int
11:53:35 <lambdabot> Data.Char.digitToInt :: Char -> Int
11:53:35 <lambdabot> Data.Char.ord :: Char -> Int
11:53:35 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
11:53:41 <Peaker> I think its silly that it does the (map digitToInt string) for you
11:54:11 <Peaker> it doesn't make the code any shorter, but it takes away a useful freedom from the caller, and seems less modular
11:54:17 <Peaker> s/any/much
11:55:17 <paolino> @hoogle readInt
11:55:17 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
11:55:17 <lambdabot> Data.ByteString.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
11:55:17 <lambdabot> Data.ByteString.Lazy.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
11:59:16 <Peaker> @seen conal
11:59:17 <lambdabot> I saw conal leaving #haskell and #ghc 1d 2h 8m 33s ago, and .
12:04:56 <mdmkolbe|work> Is there some documentation on how to use Data.Sequence (i.e. ViewL and ViewR)?
12:05:04 <Athas> comp.lang.functional doesn't seem very active. What's the most active Haskell newsgroup or mailing list?
12:05:12 <dons> mmm! i've an idea!
12:05:26 <dons> summer travel coming up, we should put out a list of top 10 haskell papers to read while travelling.
12:06:05 <Deewiant> Athas: gmane.comp.lang.haskell.*
12:06:11 <vixey> dons: I like universality of fold
12:06:41 <Saizan_> Athas: http://www.haskell.org/haskellwiki/Mailing_lists
12:06:41 <lambdabot> Title: Mailing lists - HaskellWiki
12:08:05 <Athas> I may have to figure out how to access gmane groups via my newsreader.
12:08:24 <dolio> Just point it at nntp.gmane.org
12:09:46 <dons> pgavin-away: any chance to get some quick screenshots into your gtk2hs blog announce?
12:09:49 <dons> dcoutts: ^ ?
12:09:55 <dons> a couple of images would really enhance it :)
12:10:01 <dons> for public consumption.
12:12:20 <dons> http://www.reddit.com/info/6pew9/comments/
12:12:20 <lambdabot> Title: reddit.com: gtk2hs: rich GUIs for Haskell: now with Gnome VFS, GStreamer and imp ...
12:12:22 <dons> go gtk2hs team!
12:14:02 <nus> ehm, what's fa.haskell and is it related to c.l.h. ?
12:14:35 <SamB> I always wonder about that myself
12:14:43 <SamB> it is certainly about Haskell...
12:15:00 <SamB> but what in the world is it called fa.haskell for?
12:15:08 * SamB wonders if anyone has told him already
12:15:15 <nus> now, don't even tell me they're co-rellated :-P (-;
12:16:13 <Deewiant> it's a two-week backlog of haskell-cafe with very few posts of its own, AFAICT
12:16:30 <Deewiant> hence I unsubscribed from it a month or so ago
12:16:34 <dolio> fa.haskell is a mirror of haskell-cafe. c.l.h is a relatively recent newsgroup.
12:16:51 <nus> aha
12:17:31 <dolio> Before c.l.h Haskell newsgroup traffic was mainly in c.l.functional.
12:19:47 <dons> dcoutts: you should block about hback, the first implementation of the double n-back memory protocol
12:19:53 <dons> which just happens to use gtk2hs
12:20:16 <dolio> "Strict by default and lazy by annotation, as in SML/NJ, is now understood as the preferred choice for almost all applications."
12:21:11 <dons> that's interesting. where's that from?
12:21:21 <dolio> comp.lang.functional
12:21:23 <dons> if only languages had good annotations for lazy structures :(
12:21:35 <dons> data T = T a ~(T a) -- i'd use ML then :)
12:21:49 <ddarius> I'd still not use ML.
12:21:50 <dolio> I wouldn't. :)
12:21:56 <dons> well, they'd have to add purity too
12:21:59 <dons> and type classes
12:22:04 <dons> and syntax
12:22:04 <mrd> functors
12:22:12 <int-e> maybe you want a strict haskell?
12:23:06 <dons> as long as lazy annotations were as cheap as strict ones, i'd be fine with that.
12:24:02 <vixey> haha
12:24:56 * matthew_- returns from Prague (TiC 2008)
12:25:42 <chessguy> TiC?
12:25:51 <chessguy> Thinking in Closures?
12:26:01 <matthew_-> chessguy: not quite! http://web.mac.com/vitekj/TiC/Welcome.html
12:26:02 <lambdabot> Title: Second International School on Trends in Concurrency
12:26:21 <chessguy> Truly inappropriate CPS?
12:26:23 <chessguy> oh, ok
12:26:25 <chessguy> :)
12:26:48 <chessguy> so what are the big trends in concurrency?
12:27:07 <geezusfreeek> more things at once
12:27:21 <matthew_-> geezusfreeek: odd you should mention that ;)
12:28:07 <dolio> I wasn't aware that it had been Decided that strictness with lazy annotations is inherently superior/better performing than the opposite.
12:28:24 <geezusfreeek> who said that?
12:28:27 <dolio> I guess I haven't been reading the right stuff.
12:28:39 <Korollary> Some people contend that it's the saner default
12:28:42 <dolio> Random comp.lang.functional people.
12:28:50 <geezusfreeek> ugh
12:29:29 <vixey> the real solution is to have multiple languages which try different things
12:29:32 <chessguy> hm, i've never seen lazy  annotations before
12:29:48 <matthew_-> chessguy: there are/will be in fortress
12:29:55 <dolio> "Haskell has been a wonderful research language, doing such things as kinda forcing people to properly understand monads. That said, that 'lazy loses' has been another research result."
12:30:33 <geezusfreeek> D has them
12:30:35 <dons> the shootout does well with some lazy programs, sum-file and binary-trees in particular
12:30:38 <geezusfreeek> lazy keyword
12:31:00 <dons> so i think that "loses" is not correct. but the key benefits come from mixed lazy/strict structures
12:31:01 <chessguy> C# added lazy iteratons
12:31:04 <chessguy> s/n/r
12:31:18 <dons> and everyone's got lazy lists now, so it can't be too bad
12:32:06 <Korollary> explicit laziness has been around for a long time. Laziness by default is their concern.
12:33:56 <dons> yeah, you need good strictness inference and user annotations to make it fly. we all love control.
12:34:15 <SamB> lazy annotations
12:34:18 <ddarius> I think one thing that has been decided is that it's highly beneficial to support both.
12:34:23 <SamB> that sounds really hard to get right
12:34:34 <ddarius> @google how to be lazy without even being odd
12:34:35 <lambdabot> http://citeseer.ist.psu.edu/102172.html
12:34:40 <ddarius> SamB: Read that.
12:34:56 <ddarius> @index forever
12:34:56 <lambdabot> bzzt
12:35:00 <ddarius> @hoogle forever
12:35:09 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
12:35:16 <dons> yeah, it'd suck if you have only strict, or only lazy. user access to fine grained mixing is too much fun
12:35:30 <SamB> ddarius: that is SUCH a BAD PUN
12:35:39 <SamB> also that URL is not working atm
12:35:44 <SamB> do you have a CiteSeerX URL?
12:36:08 <ddarius> SamB: That's a Wadler paper.
12:36:15 <SamB> oh, I'll just borrow the google query instead
12:36:42 <dolio> Man, citeseer's been slacking lately.
12:36:48 <SamB> it's SUCH a bad pun that I got it in stages
12:36:49 <Korollary> citation needed
12:37:09 <Korollary> it's a slow release pun
12:37:18 <SamB> i.e. the first part I got was "odd is a kind of lazy"
12:37:24 <SamB> then I got the rest of it
12:37:40 <geezusfreeek> oh jeez
12:37:45 <geezusfreeek> it took me forever to get it
12:37:47 <SamB> what I don't get is the meaning of the title ;-P
12:38:10 <Korollary> iirc even & odd were also functions in the paper
12:38:22 <ddarius> SamB: Read it, it makes sense.
12:39:12 <int-e> Peaker: re: incremental calculations, I agree that behaviours are the wrong abstraction, I was thinking about the event abstraction of FRP and its stream- or continuation-based implementation. on that level, I believe incremental sorting fits well into the 'FRP' picture.
12:39:54 <int-e> Peaker: that being said, my knowledge of FRP is superficious, I've skimmed a few papers for inspiration, but never used it.
12:39:55 <SamB> ddarius: yes, puns that become puzzles when you get them and just sound funny when you don't are a great hook
12:40:06 <int-e> superficial.
12:40:08 <vixey> hey edwardk?
12:40:46 <Peaker> int-e, I am trying to get a handle on FRP too.  I am turned off by conal's Reactive library (the explicit thread forking is the turnoff) and Yampa's "tutorial" seems like thesis instead of a tutorial
12:41:12 <geezusfreeek> Peaker: i have been working on an implementation of Reactive that doesn't rely on the forking
12:41:18 <vixey> edwardk: you know how something like fold exists for every datatype, and something a dependently typed fold can be a proof by induction... does every recursion operator correspond to some class of theorems as folds do?
12:41:19 <Peaker> geezusfreeek, cool!
12:41:28 <Peaker> int-e, Also I don't understand why conal needs to race two threads against each other when computing min of two future values
12:41:32 <geezusfreeek> it still leaks, but once it's a bit more polished it should be better
12:41:43 <Peaker> geezusfreeek, what kind of leaks?
12:41:47 <geezusfreeek> space leak
12:41:50 <Peaker> geezusfreeek, what are you doing with the library as a test case?
12:42:07 <geezusfreeek> well, i will be making a little game once i have enough written
12:42:13 <geezusfreeek> i have been through many many rewrites already though
12:42:17 <geezusfreeek> trying to get it right
12:42:25 <geezusfreeek> it's more difficult than i thought it would be
12:42:44 <dolio> vixey: A fair amount of recursion combinators rely on the types being both inductive and coinductive.
12:43:00 <geezusfreeek> and when i started i didn't like conal's, but now that i have written so any implementations i see that his is not so bad either
12:43:04 <Peaker> geezusfreeek, Have you read our discussion above about differential computations and Behaviors?
12:43:07 <vixey> dolio: that sounds terribly confusing
12:43:09 <geezusfreeek> (although i still think the forking could be done away with)
12:43:23 <dolio> vixey: That's how things are in Haskell.
12:43:24 <geezusfreeek> was that earlier today? i have been in and out
12:43:45 <Beelsebob> geezusfreeek: forking could be done away with in what?
12:44:10 <dolio> Initial algebras are final coalgebras and vice versa. That's what you need for hylomorphisms, for instance.
12:44:13 <chessguy> anybody know what the deadline for team registration for the ICFP contest is going to be?
12:44:15 <Peaker> geezusfreeek, I was thinking that maybe "Behavior a" is not good enough abstraction - if you want to be able to do something like differential function application that can transparently and efficiently process input deltas into output deltas, instead of input values (and optionally the old result) to output values
12:44:22 <Beelsebob> in reactive?
12:44:22 <geezusfreeek> Beelsebob: conal forks two thread to race futures in *ahem*pure*cough* code
12:44:29 <vixey> dolio: I think I've ever written something that acts simultaneously on data and codata, only things which are valid for each separately
12:44:38 <Beelsebob> geezusfreeek: the point is that it's a new primative
12:44:39 <vixey> dolio: I don't think I've ever*
12:44:53 <geezusfreeek> Beelsebob: right, but not a seemingly efficient one
12:44:59 <geezusfreeek> as implemented, at least
12:45:02 <Beelsebob> why is it not efficient?
12:45:11 <Peaker> geezusfreeek, couldn't he just ask if something would block, instead of racing that way?
12:45:28 <dolio> And a lot of the more advanced combinators are hylomorphisms that have extra information at each step and so on.
12:45:39 <geezusfreeek> Peaker: it's due to the data structures he is using
12:45:43 <dolio> More or less.
12:45:49 <Beelsebob> I think actually the racing is probably the most interesting and unique contribution of that whole paper
12:46:02 <geezusfreeek> it is undeniably an interesting primitive
12:46:20 <dolio> vixey: You've never done a 'fold . ... . unfold'?
12:46:32 <vixey> I don't think so
12:46:37 <dolio> 'sum . ... $ [1..n]'
12:46:50 <SamB> asking if something would block is like asking "will this halt"
12:47:01 <dolio> Actually, I suppose [1..n] is inductive on n. But [1..] is an unfold.
12:47:05 <Peaker> Beelsebob, its surely interesting, but it is inherently unoptimal and in my opinion inelegant
12:47:14 <geezusfreeek> Peaker: why do you think Behavior a can't process deltas rather than direct values?
12:47:18 <Beelsebob> what's inherantly unoptimal about it?
12:47:35 <Beelsebob> you haven't explained it's inefficiency at all
12:47:54 <Peaker> SamB, the computation is finite - I can just run it and see if it blocks, which is basically what conal does. But instead of doing it in a thread, I could use peekMVar instead of readMVar or so
12:48:13 <Beelsebob> Peaker: no, not at all
12:48:19 <Beelsebob> computation is not necessarily finite
12:48:34 <Beelsebob> and what he does is asks what terminates *first*
12:48:39 <Peaker> geezusfreeek, because of the ability to use fmap to lift normal value functions to apply to the behavior, for example
12:48:40 <Beelsebob> because he can guarentee that one terminates
12:48:46 <Beelsebob> but he can't guarentee that both do
12:48:55 <SamB> Peaker: you clearly didn't read that fun blog post about topology
12:49:18 <Peaker> SamB, Beelsebob: Ok, I take it back (I did add the disclaimer more above that I did not fully understand why it was done)
12:49:27 <zachk> SamB whats the url/link to that fun blog about topology
12:49:34 <SamB> I'm trying to find it now ;-)
12:49:43 <Beelsebob> Peaker: I think actually it's a decidedly elegant solution -- unfortunately, it doesn't work
12:49:44 <geezusfreeek> Peaker: couldn't this be solved by a newtype around Behavior that makes fmap do the desired thing?
12:49:51 <Beelsebob> the concept certainly works
12:49:57 <Beelsebob> but the implementation doesnt
12:50:27 <SamB> Beelsebob: that stupid "schedular only runs on allocation" issue?
12:50:30 <Peaker> geezusfreeek, what's the desired thing?  if you lift a pure function of values, how can it efficiently process deltas instead?
12:51:01 <Beelsebob> SamB: no -- there's an interation (we think at the moment, because we haven't found exactly the bug yet), between unsafePerformIO and mVars
12:51:09 <Beelsebob> that can cuase a race condition
12:51:16 <SamB> Beelsebob: which unsafePerformIO?
12:51:25 <SamB> Beelsebob: you should make sure you are using the unshared version
12:51:28 <ddarius> Peaker: What's the "delta" of a value of type Int -> Int?
12:51:44 <Beelsebob> SamB: in order to identify his new primative, conal uses unsafePerformIO to lift it into the pure functional world
12:52:03 <SamB> Beelsebob: no, I meant, there are now TWO unsafePerformIO primitives
12:52:05 <Peaker> ddarius, I don't know, maybe only instances of some class have deltas
12:52:22 <Beelsebob> SamB: oh? can you explain further?  This may help with finding the bug
12:52:44 <SamB> he'd better use the one that uses strict blackholing
12:53:02 <Beelsebob> can you explain what the two are, and what the difference is?
12:53:26 <ddarius> Peaker: Indeed.  So you can easily make an Event that produces deltas and produce deltas from those and/or do effectively a scan over the input deltas to get input values and do whatever with them.
12:55:00 <Peaker> ddarius, I'd probably want a newtype around   Delta a => (Event a),  that lets me apply delta-processors on them as if they were continuous functions
12:55:10 <SamB> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#unsafePerformIO
12:55:11 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yuvzp2
12:55:24 <SamB> hmm, I guess it's the right one
12:55:29 <SamB> which is good
12:55:45 <ddarius> Peaker: That's fine.  Alternatively you could make combinators that handle the details.  The point is the "deltas" of the values are just reactive values themselves.
12:56:11 <Beelsebob> SamB: that's interesting -- that was actually the thought process we were heading down
12:56:16 <Peaker> ddarius, reactive values? Not just values contained in events?
12:56:23 <Beelsebob> but it appears that unsafePerformIO deals with what we were pondering if the bug was
12:56:45 <SamB> well, in that case, did you at least follow all the cautions given in the documentation for unsafePerformIO?
12:57:01 <int-e> Beelsebob: how does the bug manifest itself?
12:57:09 <ddarius> Peaker: They're normal values, but presumably to you want a "stream" of them.
12:57:09 <Beelsebob> can you point me at them, so I can check we followed all of them SamB?
12:57:20 <psyklops> ;
12:57:24 <SamB> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html#v%3AunsafePerformIO
12:57:25 <Beelsebob> int-e: there's a race condition, which arbitrarily results in the program blackholing
12:57:25 <lambdabot> http://tinyurl.com/2akd4n
12:57:37 <Peaker> ddarius, Could be very cool if instances of a Processor class could apply to both Behaviors and to DeltaBehaviors, so that you can apply a "sort" on some reactive value (whether it is a Behavior or DeltaBehavior and it will use deltas if possible, or the full value if not)
12:57:56 <Peaker> geezusfreeek, is there anything initial you have going that I can play with?
12:57:59 <SamB> Beelsebob: wasn't there supposed to be a race condition though?
12:58:19 <vixey> @go -XUnicodeSyntax
12:58:20 <lambdabot> No Result Found.
12:58:28 <vixey> @google -XUnicodeSyntax
12:58:28 <lambdabot> No Result Found.
12:58:29 <SamB> wonder if GHC has an option to turn off lazy blackholing
12:58:32 <Peaker> ddarius, I think it could very useful in a GUI - where you want to display changes, and not just the "current state"
12:58:32 <Beelsebob> SamB: yes -- there's another one that we don't want
12:59:03 <Beelsebob> SamB: that's interesting -- there's a couple of them that we're certainly not following, I'll try throwing them at it on monday morning
12:59:39 <SamB> you should always read the documentation for something named "unsafe", and if that doesn't work you should read the source ;-)
12:59:46 <Beelsebob> hehe
13:00:10 <Beelsebob> yep, I thought I know why unsafePerformIO was unsafe -- but that points out another couple of reasons
13:00:10 <SamB> (in case, for instance, there might be comments there that were not included in the documentation)
13:00:19 <zachk> you dont have to worry about "unsafe" code if you are married to it though
13:00:33 <zachk> unless the code is unfaithful
13:00:40 <SamB> oh....
13:00:46 <SamB> a PUN
13:00:54 <SamB> I was going to ask what the heck you meant
13:00:58 <Peaker> ddarius, anyhow, thanks for the insight about how to represent a stream of deltas, it really helps :)
13:01:19 <dolio> vixey: Alternately, you'd have to ask if you've ever written anything general recursive.
13:01:22 <Beelsebob> SamB: in the mean time, can we rename fromJust to unsafePerformMaybe?
13:01:27 <dolio> Strictly general recursive, that is.
13:01:36 <zachk> fromJust is unsafe?
13:01:41 <SamB> well, yes
13:01:45 <Beelsebob> well, in that it can cause program crashes
13:01:53 <Beelsebob> fromJust: Nothing
13:01:55 <SamB> but fromJust should be fairly obviously unsafe if you aren't sure you have a Just
13:01:58 <Peaker> Every time I used fromJust (both times! :-) the use disappeared after I refactored the code into nicer form
13:02:12 <zachk> is there a safer way of doing fromJust then?
13:02:18 <SamB> no
13:02:22 <Beelsebob> yes and no
13:02:24 <Peaker> zachk, why is it that you are sure you don't have a Nothing?
13:02:29 <SamB> it's not a safe thing to do ;-)
13:02:31 <Beelsebob> yes in that you can make the error message better
13:02:43 <zachk> cause I checked to see if it was Nothing first
13:02:48 <Beelsebob> case a of Just x -> x; Nothing -> error "bettor error message"
13:03:06 <paolino> :t maybe
13:03:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:03:08 <Beelsebob> zachk: but wouldn't it be nice if the compiler checked if your logic was correct
13:03:20 <zachk> that would be golden
13:03:23 <Beelsebob> exactly
13:03:25 <Beelsebob> so it's unsafe
13:04:44 <dolio> It's not unsafe in the same way as unsafePerformIO, of course.
13:04:55 <SamB> it's only unsafe because it doesn't have type âˆ€a. Ï€mx:Maybe a. mx /= Nothing -> a
13:05:00 * vixey laughs at "bettor"
13:05:03 <Beelsebob> well it is -- unsafePerformIO is unsafe because the compiler can't guarentee that your program won't crash
13:05:07 <Beelsebob> same for fromJust
13:05:16 <Beelsebob> just unsafePerformIO has more failure modes than fromJust
13:05:40 <SamB> and unsafePerformIO tends to fail in silent-but-deadly ways
13:05:41 <vixey> fromJust is perfectly safe
13:05:49 <Beelsebob> SamB: this is true
13:05:59 <Peaker> zachk, if you checked it - then you already have the just via pattern matching?
13:05:59 <dolio> fromJust doesn't allow you to defeat the type system.
13:06:04 <SamB> whereas fromJust merely leaves you wondering which call-site is failing
13:06:10 * Beelsebob ponders if it should be named stinkyPerformIO -- because it performs SBDs
13:06:12 <Peaker> zachk, case blah of Nothing -> .. ; Just x -> ...
13:06:16 <SamB> dolio: depends on what the type system is supposed to be doing
13:06:20 <vixey> > map (fromJust.filter isJust) (Nothing : map Just [1..])
13:06:20 <lambdabot>  Couldn't match expected type `Maybe a'
13:06:33 <vixey> > map fromJust . filter isJust $ (Nothing : map Just [1..])
13:06:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:06:50 <Beelsebob> vixey: you aren't convincing me that fromJust is safe here
13:06:51 <SamB> In Haskell, it doesn't. In Coq, it doesn't validate at that type.
13:06:58 <Peaker> @hoogle maybeToList
13:06:58 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
13:06:59 <Beelsebob> you're merely convincing me that there are safe uses of it
13:07:15 <SamB> which is also true of unsafePerformIO
13:07:24 <SamB> it's just a lot harder to be confident that you HAVE one
13:07:24 <Beelsebob> indeed
13:07:25 <vixey> fromJust is a total function
13:07:44 <SamB> vixey: not with the Haskell type it isn't
13:07:46 <Beelsebob> depends if you count "error" to be a result or not
13:07:56 <Peaker> zachk, what do you have in your example?
13:08:06 <vixey> given the input is in the form (Just <value>)
13:08:16 <vixey> only on that post condition
13:08:23 <SamB> that's a precondition
13:08:32 <vixey> there will always be lots of conditions flying around in your code which are not expressed in types
13:08:33 <Beelsebob> vixey: right -- so you need to provide preconditions for it to be safe
13:08:36 <vixey> that's why fromJust is ok
13:08:38 <Beelsebob> sounds like it's unsafe to me
13:08:47 <SamB> vixey: well.
13:08:47 <Beelsebob> given that the compiler does not check that precondition
13:08:57 <vixey> Beelsebob: no you never provide them
13:09:04 <vixey> Beelsebob: They just exist in your mind when you write the code
13:09:11 <Beelsebob> vixey: exactly
13:09:24 <vixey> i.e. I write a program that does recursion, only in my mind did I verify the recursion is well founded
13:09:25 <SamB> I think a function that only gives you a value for some of the values in it's domain is not considered total ;-)
13:09:34 <vixey> I never actually put the ad-hoc size measure I thought about into my code
13:09:34 <Beelsebob> similarly, the precondition that unsafePerformIO must be called on something which will not violate type safety exists in your mind
13:09:58 <SamB> Beelsebob: typesafety is generally the easiest thing
13:10:05 <dolio> SamB: It's supposed to be making sure that, say, you don't apply a function that expects an Int to a Float. unsafePerformIO lets you do that.
13:10:10 <Beelsebob> SamB: indeed -- I was just giving an example
13:10:37 <SamB> the fact that unsafePerformIO lets you write unsafeCoerce is the least of the issues it has
13:10:47 <vixey> How do I write a pretty show instance for my AST?
13:11:24 <SamB> keeping the compilers assumption of referential transparency from breaking your code is a much more interesting problem
13:11:37 <SamB> where by interesting, I mean frustrating
13:11:45 <dolio> Heh.
13:12:22 <vixey> does anyone have an example ?
13:12:42 <SamB> vixey: you shouldn't use Show for that
13:12:57 <SamB> use a Pretty class
13:13:22 <vixey> I want to use Show
13:13:47 <SamB> when you pull your hair out because you can't see what constructor is being used...
13:13:52 <SamB> you'll be sorry!
13:14:01 <SamB> also a Pretty class is needed anyway
13:14:11 <SamB> since you'll no doubt want sensible indentation
13:14:18 <vixey> ok but since it's a GADT and features function types and I'm going to be dealing with it within GHCI it seemed like a good idea
13:14:19 <Beelsebob> vixey: in general pretty printing ASTs is a difficult problem -- you might want to look at Olaf Chitil's papers on CPS pretty printers
13:14:37 <SamB> oh you just wanted to do it because GHC can't?
13:14:51 <SamB> the word "pretty" threw me off
13:15:11 <vixey> I want to print things like Lambda Nothing (\x -> Var x :$: Var x) as \g1 -> g1 g1
13:15:28 <SamB> that's not trivial
13:15:40 <SamB> you will need deep typeclass magic, probably ;-P
13:16:14 <SamB> well, SOME kind of magic
13:16:18 <vixey> Beelsebob: I can't find any
13:17:42 <Beelsebob> vixey: http://www.cs.kent.ac.uk/pubs/2005/2366/index.html
13:17:43 <lambdabot> Title: Computer Science: Publication: Pretty Printing with Partial Continuations
13:17:55 <vixey> thanks
13:17:57 <Peaker> in FRP, Reactive values are Behaviors that are not really continuous, but only depend on events, right? (Essentially combinations of steppers only)
13:18:48 <Beelsebob> Peaker: watch out, you'll be buying conal lunch soon
13:19:01 <Peaker> Beelsebob, We're thousands of miles apart :)
13:19:10 <Beelsebob> he's made rules that people who talk about discrete things, or impossible things buy him lunch
13:19:13 <Peaker> Beelsebob, But I'd love to do that :)
13:19:16 <SamB> Peaker: you could buy it online
13:19:53 <SamB> Beelsebob: hmm?
13:19:56 <vixey> does actually have any useful content though
13:19:57 <Beelsebob> Peaker: where are you?
13:20:00 <Peaker> Beelsebob, Israel
13:20:05 <vixey> It's just a 2 page abstract
13:20:07 * Beelsebob gets out google maps
13:20:14 <SamB> Beelsebob: does he pay for the plane ticket so that he can actually eat the lunch?
13:20:23 <roconnor> is Data.Time more or less a replacement for System.Time?
13:20:58 <mrd> i think so
13:21:01 <SamB> I wouldn't trust any package called Data.Time
13:21:10 <mrd> well it's more than a replacement
13:21:17 <roconnor> SamB, why do you say that?
13:21:22 <mrd> there is Data.Time.Posix with similar functions
13:21:23 <SamB> (I'd expect it to be based on an out-of-date calendar)
13:21:46 <SamB> well, really it's that I don't trust lawmakers to leave well enough alone and so forth
13:21:58 <mrd> Data.Time could read zoneinfo
13:22:10 <SamB> and I'd expect Data.Time to stay well away from the OS
13:22:15 <Beelsebob> Peaker: I'd put you at about 1500 miles, so not thousands plural at least
13:22:17 <mrd> but I think it punts on the matter
13:22:23 <Peaker> Beelsebob, he's not in the US?
13:22:29 <Beelsebob> not just now, no
13:22:30 <mrd> with a generic "time zone" datatype
13:22:35 <Beelsebob> .be
13:22:55 <roconnor> I think Date.Time does stay mostly away from the OS.
13:23:05 <Peaker> Beelsebob, just visiting?
13:23:11 <Beelsebob> for a few months
13:23:17 <mrd> System.Time doesn't offer anything better regarding timezones
13:23:24 <Peaker> Beelsebob, family and all?
13:23:30 <Beelsebob> Peaker: no, work
13:23:41 <Beelsebob> oh, you mean are they here too?
13:23:49 <Beelsebob> Holly is, I don't think anyone else is
13:23:52 <roconnor> mrd, right.  I guess I mean Data.Time is a conceptual replacement for System.Time as opposed to a drop-in replacement.
13:24:12 <Peaker> Beelsebob, so reactive Values are just discrete steppers between values upon events, right?
13:24:24 <vixey> It's very boring to write show instances
13:24:25 <mrd> conceptual.  the names are different.  Data.Time.Clock.Posix gives you access to the system clock
13:24:26 <Beelsebob> now you're deffinaely buying him lunch
13:24:31 <mrd> based on the Posix epoch
13:24:34 <roconnor> I sent Tim Dockers a patch replacing System.Time.ClockTime with Data.Time.LocalTime in his autoTimeAxis function.
13:24:46 <Peaker> Beelsebob, sure thing, just answer already :)
13:24:48 <roconnor> but I'm not sure how to justify the patch.
13:24:53 <roconnor> :)
13:24:57 <roconnor> It feels right.
13:25:02 <Peaker> Beelsebob, I can also recommend good Tel Aviv restaurants :)
13:25:04 <glguy> not being complicated enough isn't a problem that Data.Time has
13:25:16 <roconnor> glguy: :D
13:26:03 <roconnor> Data.Time.TAI.utcToTAITime :: LeapSecondTable -> UTCTime -> AbsoluteTime
13:26:17 <zachk> > 5^5^5^5^5
13:26:27 <SamB> glguy: you sure about that?
13:26:29 <lambdabot> Terminated
13:26:40 <roconnor> Data.Time.TAI.parseTAIUTCDATFile :: String -> LeapSecondTable
13:26:43 <zachk> is that going to take hours to computer?
13:26:47 <SamB> I mean, it has to be complicated enough that it actually solves the problem it is meant to solve
13:27:05 <SamB> zachk: probably takes more space than we are sure exists
13:27:06 <roconnor> zachk: and it will swallow up the whole universe while it is at it.
13:27:08 <glguy> SamB: have you looked at this library yet or are you still basing these questions on the namespace?
13:27:51 <zachk> ty SamB and roconnor
13:27:52 <SamB> well, okay, if it solves the problem, then I'll have to agree that not being complicated enough is not a problem it has
13:28:01 <mrd> time isn't exactly a simple thing
13:28:19 <roconnor> SamB: there is LocalTime ZonedTime UTCTime UniversalTime DiffTime NominalDiffTime AbsoluteTime
13:28:25 <SamB> I was basing the question on a knowledge that time is a really damn complicated subject actually ;-)
13:28:29 <roconnor> SamB: ... I might be missing some.
13:28:39 <SamB> roconnor: hmm.
13:28:49 <roconnor> oh, Day TimeOf Day ...
13:28:54 <roconnor> oh, Day TimeOfDay ...
13:28:55 <vininim> > 2^2^(5+1)
13:28:56 <lambdabot>  18446744073709551616
13:29:02 <SamB> I am not qualified to say if that solves the problem or not
13:29:04 <vininim> mmm quite fail
13:29:05 <roconnor> what else
13:29:35 <vixey> guh
13:29:52 <SamB> what would a plot of TimeOfDay vs. UTCTime look like on a day (night?) where DST kicks in/out
13:30:04 <vixey> there should be a totally general way of doing this
13:30:21 <SamB> vixey: you could fix GHC
13:30:22 <mrd> vixey: deriving Show?
13:30:22 <vininim> > 2^(2^(9))+ 1
13:30:24 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
13:30:27 <SamB> mrd: doesn't work
13:30:31 <mrd> gadt?
13:30:36 <roconnor> oh apparently there is POSIXTime
13:30:37 <SamB> oh, but that wouldn't help with the functions would it
13:30:39 <vixey> GHC isn't broken
13:30:47 <vixey> I don't want deriving Show
13:30:48 <vininim> > isPrime (2^(2^(9))+ 1)
13:30:48 <lambdabot>   Not in scope: `isPrime'
13:30:49 <mrd> roconnor: Data.Time.Clock.Posix
13:30:50 <SamB> vixey: it can't derive show for GADTs
13:30:55 <SamB> that isn't broken?
13:31:04 <vixey> I know that and I don't care
13:31:11 <vixey> I don't want to derive Show for GADTs
13:31:21 <SamB> well, I say it's broken but realized just after suggisting it that that would not help ;-)
13:31:56 <vixey> pretty printing an AST which has infix and binding operators
13:32:01 <vixey> that's all
13:32:16 <vixey> it should be possible to do it in a totally generic way shouldn't it ?
13:32:25 <roconnor> SamB: I haven't yet seen anything that is affected by DST.  CDT and CST are simply two different time zones as far as I can tell at the momment
13:32:28 <SamB> the lambdas make this difficult
13:32:32 <roconnor> SamB: but it is a big library
13:32:33 <vixey> I mean avoiding name classes, removing extraneous parenthesis... and so on
13:32:36 <SamB> roconnor: oh
13:33:13 <mrd> kind of like an Unparsec
13:33:21 <vixey> mrd: yeah
13:33:30 <vixey> I think I will try it
13:33:38 <SamB> there might be some code in JHC you could rip off
13:33:44 * Toxaris dreams of a single EDSL which specifies Parser, Pretty Printing and AST in one go
13:33:47 <roconnor> SamB: TimeZone has a timeZoneSummerOnly :: Bool field
13:34:01 <SamB> ISTR there being some in the "C-printing" code, at least
13:34:08 <vixey> actually I need a parser too
13:34:19 <vixey> it would be nice to derive them based on the same information
13:34:36 <SamB> that's a can of worms I'd suggest not opening while you actually are trying to do something else that is useful
13:34:38 <roconnor> SamB: but I haven't seen anything yet that supports a table of when DST kicks in.
13:34:47 <vixey> I'm not sure how to handle the " " infix operator
13:34:56 <vixey> > f x
13:34:56 <lambdabot>  Add a type signature
13:35:01 <roconnor> SamB: I suppose that will have to be built on top of Data.Time
13:35:03 <SamB> vixey: give it the highest damn binding strength possible
13:35:15 <vixey> SamB: Have you tried something along these lines?
13:35:46 <vixey> I've written invertible parsers in Prolog before
13:36:54 <SamB> I guess what I mean is that trying to figure out how to write invertible parsers sounds like a very large tangent
13:37:11 <Toxaris> Yeah that's clearly a project in its own right
13:38:14 <Toxaris> but a sensible first step is to define sensible abstractions for the job at hand
13:39:48 <Toxaris> and name them alike, similiar to Text.PrettyPrinting.HughesPJ.parens and Text.ParserCombinators.Parsec.parens
13:40:04 <Peaker> can one derive a show'er from Parsec definitions?
13:41:01 <roconnor> @type zip `ap` tail
13:41:03 <lambdabot> forall b. [b] -> [(b, b)]
13:41:18 <roconnor> @type \f -> zipWith f `ap` tail
13:41:20 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
13:41:28 <desp> Any fellow Google Code Jammers?
13:41:58 <Toxaris> Peaker: enumerate strings until you find one which parses to the term you want to pretty print?
13:42:29 <Peaker> Toxaris, :-)
13:43:05 <vixey> @src Num
13:43:05 <lambdabot> class  (Eq a, Show a) => Num a  where
13:43:05 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:43:05 <lambdabot>     negate, abs, signum     :: a -> a
13:43:05 <lambdabot>     fromInteger             :: Integer -> a
13:43:37 <vixey> :/
13:43:44 <vixey> why I have Eq and Show
13:45:03 <Toxaris> Peaker: consider the parsec parser (many (satisfy somePredicate) >> return True) <|> return False. now prettyprint the AST True. Since somePredicate is a Haskell function you have no structural information about, I think you have to enumerate strings
13:46:09 <ddarius> Is there a cabal command to rebuild all previously installed package or all packages you have downloaded?
13:46:21 <Toxaris> Peaker: so it isn't enough to undo the parsing, you have to undo general Haskell functions, too.
13:46:57 <ddarius> cabal upgrade is close enough I guess
13:47:45 <Toxaris> Peaker: I think you need a less expressive parser combinator library for that job, or a more expressive one where you actually specify for each Haskell function how to undo it.
13:47:53 <Peaker> Toxaris, I see. There's the arrow-based parser which is meant to be able to build a deterministic finite state machine from the grammar - so maybe that one can?
13:49:09 <Toxaris> well, you still have arr
13:50:33 <telemach> gn8 everyone
13:50:35 <Peaker> I think we need arrows that don't have arr
13:51:29 <Toxaris> but what is the result of the parsing process then? just accepted/not accepted?
13:51:57 <Peaker> no, for each "supported" Haskell function there would be a semantic-equivalent to (arr func) in the library
13:52:18 <Peaker> if the supported set is turing complete, you're theoretically ok. If its complete enough, you might not even be in the Turing tarpit
13:52:57 <Peaker> this is generally equivalent to the more expressive solution you suggested, except the reverse of existing supported functions is already specified
13:53:01 <Toxaris> or we need arr' of type InvertibleArrow (~>) => (a -> b) -> (b -> a) -> (a ~> b)
13:53:19 <vixey> it's a tabulated allegory!
13:53:29 <Toxaris> :)
13:54:10 <vixey> oh perhaps that would be (a -> [b]) -> (b -> [a]) -> (a ~> b)
13:54:21 <Peaker> Toxaris, InvertibleArrows could be nice
13:54:35 <desp> How would you format an Array into rows of values?
13:54:43 <Peaker> useful for encoding/decoding libraries too, probably
13:54:45 <vixey> How much of your Haskell code are bijective functions?
13:54:48 <vixey> I'd say 0%
13:54:59 <Peaker> vixey, well, adapters and encoders/decoders are
13:55:00 <vixey> or maybe a little bit more.. but in that realm
13:55:22 <Toxaris> I'm currently writing a translator between two concrete syntaxes of FOmega.
13:55:25 <Toxaris> :)
13:55:43 <Peaker> vixey, also, a parser usually discards information but it can explicitly note that as not important (printing back a differently formatted text, for example)
13:55:49 <vixey> Toxaris: would you show me your AST ?
13:56:18 <roconnor> how much of your Haskell code are adjuctions?
13:56:22 <vixey> Peaker: yeah so mostly it's relations, not bijective functions
13:56:23 <Toxaris> vixey: one side is super simple, just data Term = Var String | Const String | Lambda String Term Term | ... and so on
13:57:09 <Toxaris> vixey: the other side is more like data Expr v = Var v | Lambda Type (Context v Expr) | ...
13:57:26 <roconnor> data Term a = Var a | Const String | Lambda (Term (Maybe a)) ...
13:58:04 <vixey> Lambda :: (Term x -> Term y) -> Term (x -> y)
13:58:19 <Toxaris> Peaker, vixey: isn't a "throws information away but is still sensible"-relation an adjunction?
14:00:47 <Toxaris> vixey: my idea is to define important functions (like subst) via type classes, with hand-made instances for Context and Var, and generic instances for other types
14:01:39 <Toxaris> vixey: so the programmer writes data Untyped v = Var (Var v) | Lambda (Context Untyped v) | App (Untyped v) (Untyped v)
14:03:02 <Toxaris> vixey: and gets substitution, converting from and to de-bruijn indexed form, alpha-equivalence etc. for free. but it is far from working, and I decided to concentrate on the task at hand now, and improve my general ideas when I write my next AST-handling program
14:03:15 <dons> i'm not seeing any new libraries on hackage yet. did no one do any work while hackage was down?!
14:03:41 <ddarius> dons: They couldn't get support packages to test their code!
14:03:48 <dons> yeah :(
14:04:03 <dons> we'll set up a mirror during the week.
14:04:18 <dons> ?bug
14:04:18 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:04:28 <dons> yep, services look back to normal now
14:05:30 <vixey> Toxaris: THat sounds pretty neat
14:05:56 <vixey> Toxaris: I am thinking I can handle a lot with data Classification a = Constant String | Infix Fixity Level a a
14:06:22 <vixey> given data Fixity = FX String | XFY String ... | FXFY String String | ...
14:07:02 <vixey> so e.g.
14:07:04 <vixey>   classify (Num i) = Constant (show i)
14:07:04 <vixey>   classify (x `Add` y) = Infix (XFY "+") 6 x y
14:07:21 <dons> glguy: hot out there?
14:07:23 <vixey> it's not generic enough for unparsing and parsing though..
14:08:41 <Toxaris> vixey: really? looks like it should be enough for unparsing given some SYB for the recursion. of course, it will not be pretty printing, just printing. (e.g. no line break hints)
14:09:27 <Toxaris> vixey: oh I just see that the result of classify contains the children, so you actually have some small SYB like thing there
14:09:46 <edwardk> vixey: the recursion schemes exist for the same reasons that folds do, so the same reasoning should work
14:10:19 <conal> Peaker: i just scanned through today's #haskell transcript and saw some Reactive chat.  You're right about the "Reactive" type being discrete.  It's part of a refactoring of (continuous) reactive behaviors.
14:12:25 <conal> Peaker: also, the threading and imperative stuff in Reactive will be packaged up separately from the functional interface and will be exposed only for connecting Reactive to a new means of gathering input and rendering output.
14:14:42 <Toxaris> vixey: but is this classify so much easier then just to write the pretty printer, with the help of some sensible abstractions, e.g. xfx f p p' n x y = (if p < p' then parens else id) (f p' x <+> text n <+> f p' y)
14:15:22 <Toxaris> vixey: so you can say pretty p (x `Add` y) = xfx pretty p 8 "+" x y
14:15:43 <vixey> That's pretty good but I want parsers too
14:16:19 <Toxaris> but how does classify help you with parsers?
14:16:22 <vixey> specifically, I want printers and parsers to be derived together so that they always work
14:16:38 <vixey> It doesn't, I don't know how to do this yet but I'm trying things out
14:16:58 <Toxaris> yeah, we want unparse x >>> parse x == returnA
14:17:23 <Toxaris> to return needlessly into arrow notation
14:17:23 <vixey> if 'Representation's were composable too it might be useful
14:20:07 <Toxaris> lets say xfx were ad-hoc polymorph (e.g., a typeclass member), so that it could mean "build a parser", "build a pretty printer" or "build a datatype constructor for some Either, (,) construct" dependent on it's return type
14:20:45 <roconnor> @where Expr
14:20:45 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
14:21:01 <roconnor> is Expr in Hackage?
14:22:15 <Toxaris> vixey: if that helps you, I intend to follow this idea further, after my trip into the land of obscure lambda calculi.
14:23:11 <vixey> Toxaris: I think that could definitely work well
14:24:53 <dons> roconnor: i think so, in the numbers library?
14:24:57 <Toxaris> sad thing is, the more I try to simplify my code by using great abstractions and clever tricks, my coworkers talk about unneeded obfuscation :(
14:25:19 <lament> geez, i wonder why
14:25:24 <dons> oh, maybe not, http://hackage.haskell.org/packages/archive/numbers/2008.4.20/doc/html/Data-Number-Symbolic.html ?
14:25:25 <lambdabot> http://tinyurl.com/67aufo
14:26:29 <roconnor> dons: that kinda looks like what I want
14:26:46 <sm> Toxaris: a no-easy-win situation eh
14:26:52 <roconnor> dons: should I patch Charts to depend on this, or should I make my own package that depends on charts and numbers?
14:26:55 <chessguy__> anybody seen this? parsec in C# ftw! http://blogs.msdn.com/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
14:26:57 <lambdabot> Title: LukeH's WebLog : Monadic Parser Combinators using C# 3.0, http://tinyurl.com/2srswy
14:27:08 <dons> roconnor: hmm, do you maintain Charts?
14:27:14 <ddarius> @seen conal
14:27:14 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 14m 49s ago.
14:27:29 <roconnor> dons: nope
14:27:29 <dons> roconnor: if not, i'd wrap them.
14:27:35 <dons> since depending on other libs is cheap now
14:29:08 <atp> hey, has anyone ever thought of introducing a Forceable typeclass?  you know, one that has a force function that forces the entire evaluation of its argument, instead of just to WHNF as seq does
14:29:17 <atp> by which i mean, introducing one into the standard libs
14:29:44 <ddarius> atp: There is one in the standard libs.
14:29:55 <atp> ddarius: ooh, i never knew.  what's it called?
14:29:57 <roconnor> dons: if depending on other libs is cheap, why not patch charts?
14:30:01 <ddarius> atp: NFData
14:30:11 <atp> ddarius: i'll check it out.  thanks!
14:30:12 <roconnor> my main concern was adding more dependencies
14:30:15 <chessguy__> roconnor:  adding new libraries to hackage is the "cool thing" to do these days
14:32:28 <dons> you'll be able to maintain your code without negotiating with others. however, feel free to submit a patch to Charts and help coordinate a release there.
14:35:40 <roconnor> dons: okay.  I'll try patching first
14:35:49 <roconnor> ... actually I'll try writing the code first
14:39:31 <ddarius> conal: is 'sortEvent p evt = do value <- evt; if p value then return (return value, mempty) else return (mempty, return value)' which should satisfy 'forall p evt. uncurry mappend <$> sortEvent p evt === evt' a sensible/useful function?
14:40:33 <vixey> how can I make \x -> (x,x) at the type level?
14:40:42 <vixey> I don't like newtype Make2Tuple x = Tup2 (x,x)
14:40:46 <vixey> since I have to put Tup2
14:40:48 <vixey> everywhere...
14:40:55 <vixey> is there any way to do it more naturally?
14:41:51 <ddarius> No
14:43:53 <dons> use data
14:43:59 <vixey> I am now
14:44:06 <dons> data Pair x = Pair !x !x -- even
14:44:09 <vixey> since I want Tup2 x x instead of \x -> (x,x)
14:44:54 <vixey> what are these ! for?
14:46:03 <mattam> Strictness?
14:46:20 <ddarius> @hoogle isPrefixOf
14:46:21 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:46:21 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
14:46:21 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
14:47:03 <dons> vixey: i just assume you probably don't really want element-lazy pairs
14:47:20 <vixey> dons: I don't know what the difference is
14:47:48 <dons> well, lazy ones can potentially contain infinite structures
14:48:05 <dons> but pairs are mostly for storing simple atomic types, so may as well make them strict
14:48:08 <vixey> I wont ever have infinite structures in mine
14:48:46 <dons> i think its a good habit to get into when defining data types. if you can say "these things will be small, simple types" then make them strict at the outset
14:49:09 <dons> if they're going to be some complicated tree or list type, that you know you won't always need, then leave it lazy
14:49:29 <dons> making your code a bit more efficient, day be day.
14:51:53 <ddarius> conal: nevermind
14:52:32 <SamB> @tell zachk cool topology post is at: http://sigfpe.blogspot.com/2008/01/what-does-topology-have-to-do-with.html
14:52:32 <lambdabot> Consider it noted.
14:52:51 <SamB> Peaker: you should also check it out
14:56:29 <nominolo> @seen swiert
14:56:30 <lambdabot> I saw swiert leaving #haskell 3h 26m 25s ago, and .
15:02:00 <hpaste>  chase bankone annotated "matching against regular expressions" with "apply card credit mail online" at http://hpaste.org/8526#a2
15:05:04 <ziman> heh, spambots on hpaste :)
15:05:25 <twanvl> What category should I put SimpleReflect in on hackage?
15:05:38 <roconnor> how do I allow "instance PlotArg (Sym Double -> Sym Double)"
15:06:04 <roconnor> twanvl: what is the difference between SimpleReflect and Data.Number.Symbolic?
15:06:21 <twanvl> roconnor: I'm not sure
15:06:57 <sclv>  
15:07:14 <sclv>   +
15:07:38 <sclv> gah, spare keystroke. sorry.
15:12:20 <Peaker> SamB, thanks
15:13:34 <Peaker> conal, ah, great. I couldn't wrap my head around all the fork-followed-by-obscure-letter notations :)
15:13:48 <monochrom> <3 lambdabot
15:13:49 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
15:14:03 <Peaker> hehe
15:14:34 <Peaker> conal, Did you read the differential computation stuff?  I think that has a place in FRP (Perhaps its an abstraction that's completely on top of FRP though)
15:16:45 <Peaker> oh damn
15:18:17 <roconnor> awww
15:18:27 <roconnor> Prelude Graphics.Rendering.Chart.Simple Data.Number.Symbolic> plotWindow [0,0.1..2.9] (sin::Sym Double -> Sym Double)
15:18:31 <roconnor> that works fine
15:18:38 <roconnor> but plotWindow [0,0.1..2.9] (sin)
15:18:48 <roconnor> gives     No instance for (Graphics.Rendering.Chart.Simple.PlotArg (a -> a))
15:19:04 <roconnor> that's too bad
15:19:41 <roconnor> no one wants to write out a type signature
15:19:42 <SamB> roconnor: change the defaults?
15:19:49 <roconnor> to get a label
15:19:58 <roconnor> SamB: hmm
15:20:11 <vixey> What is the type of plotWindow?
15:20:13 <roconnor> SamB: what is the scope of defaults?
15:20:20 <SamB> don't know
15:20:25 <SamB> :-(
15:20:38 <roconnor> vixey: it uses a type classe hack to have variable arguments
15:20:47 <roconnor> plotWindow :: PlotWindowType a => a
15:20:47 <vixey> oh that's ridiculous
15:20:57 <vixey> why are people doing this in real programs
15:21:18 <roconnor> I'm not sure that Graphics.Rendering.Chart.Simple is a real program
15:21:21 <roconnor> maybe, maybe not
15:22:06 <SamB> vixey: the lack of dependant types?
15:23:20 <vixey> SamB: I think lack of TCL could be it also
15:24:33 <roconnor> can I even set defaults in ghci?
15:24:33 <SamB> TCL?
15:33:47 <roconnor> bah
15:33:57 <roconnor> I'm not sure this will work even with defaulting
15:40:39 <noecksit> has anyone had trouble with the cairo binding and scaling as far as patternExtend goes
15:41:12 <noecksit> i get a blank white screen where the image is supposed to be
15:43:32 <SamB> oh oops
15:44:00 <SamB> Peaker: I seem to have linked to the wrong blog post... http://sigfpe.blogspot.com/2008/02/what-is-topology.html is the one I was actually thinking of
15:44:01 <lambdabot> Title: A Neighborhood of Infinity: What is Topology?
15:44:30 <Peaker> SamB, that was interesting too
15:44:52 <SamB> yes but this is the one I really meant
15:46:51 <roconnor> I think if this is going to work I'm going to have to make the code more Haskell 98ish
15:47:08 <guenni> hi
15:47:35 <guenni> what does one use for writing windows GUIs?
15:48:39 <roconnor> I totally don't understand the difference between :m and :l
15:48:50 <roconnor> guenni: simple or complex GUIs?
15:49:14 <noecksit> compared to C?
15:49:22 <noecksit> oh sorry
15:49:47 <sclv> anyone played much with concurrency on multicore 64 bit systems (i.e. intel quads, etc)?
15:49:50 <sclv> I think I'
15:50:01 <sclv> m running into some rts bugs that only hit on 64 bits...
15:50:40 <guenni> roconnor not too complex
15:52:34 <roconnor> guenni: for very simple GUIs I use GuiTV. ... I must admit at the momment it is a pain to install
15:52:51 <roconnor> well, last time I checked it was painful to install
15:53:29 <roconnor> my very simple gui has a drop down box, a slider, and two output boxes.
15:53:46 <roconnor> It's not pretty, but it was very easy to write
15:54:09 <RayNbow> roconnor, what part of GuiTV is hard to install?
15:54:18 <roconnor> RayNbow: wxHaskell
15:54:20 <RayNbow> ah
15:54:31 * dmwit nods agreement
15:54:42 <Peaker> roconnor, was painful for me too, but now that I know how, its not painful anymore (On Ubuntu, at least)
15:54:52 <roconnor> guenni: gtk2hs will give you a very familear low level gui interface.
15:55:05 <Peaker> roconnor, just need to cabal install wx as a superuser (with --global), with the wx2.6-dev package installed, but without the wx2.8-dev packages installed
15:55:11 <RayNbow> http://www.reddit.com/info/6of7m/comments/c04g0jc <-- wxHaskell binaries for GHC 6.8.2 I made a half year ago :p
15:55:12 <lambdabot> Title: reddit.com: Real World Haskell: ten new draft chapters - GUIs, concurrency, web  ...
15:55:24 <guenni> roconnor: thx, so I'll give GUITV a try
15:55:25 <roconnor> RayNbow: sounds like things are getting better
15:55:27 <sclv> anyway, yeah, I just submitted two bugs. if anyone with a similar processor setup wants to try to reproduce, I'd be much obliged
15:55:36 <Peaker> guenni, if you're on an Ubuntu system, note my comments about how to install wx
15:55:38 <vixey> How do you do a HOAS version of untyped lambda calculus ?
15:55:39 <sclv> http://hackage.haskell.org/trac/ghc/ticket/2401 and http://hackage.haskell.org/trac/ghc/ticket/2398
15:55:41 <lambdabot> Title: #2401 (unsafeIOToSTM hangs with 64 bit multicore.) - GHC - Trac
15:55:45 <guenni> roconnor: any experience with wxhaskell?
15:55:50 <RayNbow> roconnor: good to hear... I still have to clean up my GHC installation and upgrade to 6.8.3 and get cabal-install
15:56:03 <guenni> roconnor: no such luck gotta do windows
15:56:09 <roconnor> guenni: I'm not sure how well GuiTV is documented.  I got help from conal when making my little app
15:56:34 <guenni> roconnor: got some screen shots?
15:56:36 <joey_> Hmm, just used Parsec for the first time today
15:56:38 <joey_> It's fantastic.
15:56:42 <roconnor> guenni: I've installed wxhaskell on Ubuntu, that was enough to get GuiTV working.
15:56:48 <joey_> I feel like a muppet these last few months trying to hard code parser
15:56:50 <joey_> Or use Happy.
15:56:51 <kryptiskt> guenni: gtk2hs is very easy to install on windows, it's very extensive too
15:56:52 <roconnor> guenni: GuiTV is a lib on top of wxHaskell
15:57:00 <roconnor> guenni: so I don't need to know wxHaskell
15:57:03 <guenni> roconnor: ic
15:57:19 <RayNbow> guenni: the Haskell wiki has a few (very) small examples
15:57:40 <guenni> kryptiskt: maybe so, but it's so dead ugly
15:58:26 <RayNbow> guenni, http://www.haskell.org/haskellwiki/TV
15:58:29 <lambdabot> Title: Tangible Value - HaskellWiki
15:59:39 <guenni> thx everyone
16:00:42 <roconnor> guenni: good luck.  Let us know if you have and troubles
16:00:52 <kryptiskt> guenni: you could do a native app, there's a "hello, world" included in WinHugs. It's not that horrible :-)
16:05:44 <vixey> > "hello, world"
16:05:45 <lambdabot>  "hello, world"
16:06:18 <guenni> kryptiskt: didn't know that, certainly good news
16:14:23 <atp> out of curiosity, why is there an unfoldr but no unfoldl ?
16:14:40 <vixey> :t unfoldr
16:14:44 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:14:46 <vixey> :t foldl
16:14:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:15:36 <atp> i'm sorry, am i supposed to glean something from this?
16:15:51 * atp is confused...
16:16:36 <mmorrow> has anyone had any experience with yhc javascript?
16:17:09 <mmorrow> in particular, i can build all the examples from http://www.haskell.org/haskellwiki/Haskell_in_web_browser , but the ones that make use of JSThreads simeply dont work
16:17:10 <lambdabot> Title: Haskell in web browser - HaskellWiki
16:17:25 <mmorrow> (everything is shown/rendered though on screen)
16:17:32 <ziman> @pl f s = g =<< h s
16:17:32 <lambdabot> f = (g =<<) . h
16:18:28 <mmorrow> (and the examples that come with yhcjs work perfectly)
16:20:55 <roconnor> ugh, my little project is failing
16:21:32 <mmorrow> ruhroh, which project is that?
16:21:44 <roconnor> I need more Oleg
16:21:56 <mmorrow> oh dear
16:22:56 <roconnor> mmorrow: see http://dockerz.net/twd/HaskellCharts#line-61
16:22:57 <lambdabot> Title: HaskellCharts - twd
16:23:23 <roconnor> I want to change the lib so the graph is produced with a little "sin x" in the legend
16:23:41 <roconnor> with the same function call
16:24:37 <SamB_XP_> roconnor: how many milli-olegs have you used thus far?
16:24:59 <roconnor> SamB_XP_: 50
16:25:49 <mmorrow> roconnor: nice, those look pretty good
16:26:03 <roconnor> mmorrow: Tim wrote it
16:26:30 <mmorrow> roconnor: i might have to start using it
16:26:34 <roconnor> WWOD
16:26:35 <mmorrow> roconnor: Tim....?
16:26:44 <roconnor> Tim Docker
16:26:50 <mmorrow> ah
16:27:22 <roconnor> I guess David Roundy wrote the simple interfrace that I'm trying to hack.
16:28:42 <roconnor> I think what I want to do is impossible.
16:29:01 <roconnor> there is no way to change the defaulting in GHCi I guess
16:29:07 <mmorrow> roconnor: have you ever looked at some R graphics? if i were writing the kind of thing you are currently i would definitely look there for some (awesome) examples
16:29:23 <roconnor> mmorrow: is R free?
16:29:33 <mmorrow> yesh
16:29:47 <mmorrow> it's an open source "rewrite" of S
16:29:48 <mmorrow> http://addictedtor.free.fr/graphiques/
16:29:49 <lambdabot> Title: R Graph Gallery :: Home
16:29:51 <roconnor> ok
16:30:05 <mmorrow> check out that webpage, you'll be BLOWN away
16:30:10 <roconnor> I looked a gnuplot, and hated it.
16:30:32 <mmorrow> yeah, some gnuplot stuff is ugly
16:30:43 <SamB> gnuplot is truly horrendous (to use)
16:30:51 <mmorrow> totally, that too
16:31:18 <roconnor> so.  I might just end up using R instead of writing my own in Haskell?
16:31:28 <mmorrow> heh
16:31:30 <SamB> there are TeX macro packages that are more usable!
16:32:05 <mmorrow> that's what i do. R is just unbeatable by anything i've seen wrt graph/plot/chart graphics
16:32:21 <mmorrow> (whatever you want to call it)
16:32:21 <roconnor> aww
16:32:31 <roconnor> that sounds harder to beat than gnuplot
16:32:52 <roconnor> I though R was just for reasoning about stats
16:32:57 <roconnor> apparently not
16:33:03 <mmorrow> it's actually a functional language too
16:33:47 <mmorrow> unfortunately it's kinda a pain to interface with it if you don't wanna write R code to get the graphics
16:35:09 <roconnor> Haskell's defaulting rules confuse me
16:37:05 <mmorrow> i love heatmaps: http://addictedtor.free.fr/graphiques/RGraphGallery.php?graph=66
16:37:06 <lambdabot> Title: R Graph Gallery (66) heatmap
16:37:18 <mmorrow> so much "bang for your buck"
16:37:34 <roconnor> ah the original "plotWindow [0,0.1..2.9] sin" only works at GHCi
16:37:58 <roconnor> it doesn't work in a file
16:38:09 <roconnor> Ambiguous type variable `t' in the constraints:
16:38:35 <mjk> i want to get all files in a directory, what package to used?
16:40:21 <kryptiskt> getDirectoryContents
16:40:31 <roconnor> ah the `Graphics.Rendering.Chart.Simple.IsPlot t' constraint means that it cannot be defaulted
16:40:40 <kryptiskt> in System.Directory
16:40:45 <roconnor> because it isn't a Prelude class
16:41:28 <mjk> thx
16:41:58 <SamB> roconnor: you need to use that "aggressive defaulting" extension
16:42:03 <vininim> R lacks in usability as much as gnuplot.
16:42:31 <SamB> I doubt that VERY MUCH
16:42:38 <SamB> gnuplot is not a programming language...
16:42:49 <vininim> well, for the intersection of what they are able to do.
16:43:02 <SamB> that's a VERY odd restriction
16:43:03 <RayNbow> ooo, nice charts package, roconnor
16:43:04 <mmorrow> vininim: ha, i totally agree, but because the graphics are so pretty i can't resist
16:43:11 <roconnor> RayNbow: It's not mine
16:43:18 <roconnor> RayNbow: It's Tim's
16:43:23 <roconnor> RayNbow: It's Tim Docker's
16:43:42 <RayNbow> roconnor: still, it's a nice package :p
16:43:58 <roconnor> SamB: gnuplot is arguable not a plotting program either.
16:44:10 <SamB> what IS it, then?
16:44:16 <mmorrow> the gnuplot manual make my eyes bleed
16:44:17 <SamB> a PITA?
16:44:24 <roconnor> SamB: useless
16:44:35 <roconnor> well almost useless
16:45:32 <roconnor> RayNbow: Charts would be even nicer if we could automagically label graphs :D
16:46:27 <RayNbow> roconnor: you mean by just plotting a given function, derive the textual representation of it?
16:46:45 <roconnor> RayNbow: yes
16:47:10 <roconnor> RayNbow: granted what I'm asking for is a little obscene.  But only a little.
16:47:14 <vininim> My pov is very constrained and possibly not fair to R. If you want to simply plot some scatter/lines with error/simple regressions graphs from a dataset file, both gnuplot and R have usability errors.
16:47:42 <RayNbow> roconnor: adding that feature... would it involve using Expr?
16:48:02 <roconnor> RayNbow: yes, but I'm using Data.Number.Symbolic
16:48:14 <roconnor> > sin x
16:48:15 <lambdabot>  sin x
16:48:19 <RayNbow> :t sin x
16:48:21 <lambdabot> Expr
16:49:02 <vininim> R is of course way more powerfull, specially if you can bother to learn the language and all the needed modules.
16:50:06 <mmorrow> vininim: yeah, for simple things it's way overkill, but for anything involving expressing information through graphics that's at least somewhat complex and up it's (the end product, not the pain of getting it to work) amazing
16:50:30 <SamB> vininim: I expect R at least makes it reasonably easy to make multiple variants of the same graph, for instance in black&white or in color
16:51:28 <mmorrow> SamB: oh yes, and *way* more
16:51:52 <SamB> things like that are what I mean when I speak of usability ;-)
16:51:54 <vininim> it is, but well it's language+environment, not a program. =)
16:52:10 <mmorrow> SamB: well, not necessarily *easy*, but possible nonetheless
16:52:26 <SamB> mmorrow: what makes you think it wouldn't be easy?
16:52:30 <mmorrow> yeah, R and gnuplot aren't really even comparable
16:52:30 <vininim> it isn't
16:52:36 <mmorrow> it isn't
16:52:43 <SamB> how come?
16:52:52 <vininim> you have a module that does scatterplot in a very specific way, if you want to vary it, you have to deal with all low-level graphic manipulation.
16:53:08 <SamB> no options ???
16:53:11 <mmorrow> there are *SO* many options that finding the combo of ones you want is hard
16:53:14 <vininim> ^
16:54:14 <roconnor> :type maybe
16:54:27 <roconnor> :t maybe
16:54:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:55:30 <SamB> so... are you saying it might be better to use mathematica?
16:56:04 <mmorrow> um, i've never really used mathematica, but i'd still feel confident in saying NO
16:56:06 <vininim> SamB: plotting two datas in the same graph with different colours and two y axis of different scales is 8 lines of R languages, iirc.
16:56:21 <vininim> *R language commands
16:57:05 <mmorrow> SamB: we're being slightly overdramatic in describing some possible pain-in-the-ass of using R, but it's actually not bad at all imo
16:57:50 <SamB> unfortunately it and mathematica share a certain fatal flaw:
16:58:01 <SamB> I can't use them when assigned to use MATLAB :-(
16:58:09 <vininim> heh
16:58:11 <roconnor> @hoogle Maybe a -> [a]
16:58:13 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
16:58:20 <mmorrow> SamB: pretty much, the quality of the output product of R is so high that i'm willing to go through *whatever* it takes to get it
16:58:22 <roconnor> @src maybeToList
16:58:22 <lambdabot> maybeToList  Nothing   = []
16:58:23 <lambdabot> maybeToList  (Just x)  = [x]
16:58:23 <newsham> i keep trying to get my matlab friend to switch to haskell
16:58:56 <SamB> yeah, matlab output ... is slightly better than excel, I guess...
16:59:04 <mmorrow> haha, not much
16:59:26 <SamB> and it has more different types of plots available
16:59:52 <ddarius> newsham: Why would he want to use Haskell?
17:00:11 <newsham> he doesnt.
17:00:12 <SamB> but ... Mathematica is actually some fun, and the results are often not ugly
17:00:14 <newsham> i want him to :)
17:00:25 <mmorrow> newsham: tell him hmatrix'll cover a bunch of the functionality of matlab
17:00:45 <SamB> newsham: until you come up with some reasons why he actually might want to, he probably won't listen to you ;-)
17:01:04 <mmorrow> newsham: because without that, if he's using matlab for what it's good at, he'll gain nothing and lose everything switchihng to haskell
17:01:10 <roconnor> what's the pragma for turing on aggressive defaulting?
17:01:19 <roconnor> in GHC 6.6
17:01:29 <vininim> mmorrow: just because we still don't have a haskell "Sage" =P
17:01:52 <geezusfreeek> to those who were trying to talk to me earlier, i'm sorry i cut out. my power went out :(
17:01:53 <mmorrow> vininim: oooh, that would be sweet
17:01:59 <SamB> roconnor: -fglasgow-exts???
17:02:23 <mmorrow> newsham: and the new blas package as well
17:02:30 <roconnor> seems not
17:02:55 <SamB> {-# LANGUAGE ExtendedDefautlRules #-} ?
17:03:21 <SamB> er, spelled a bit better than that
17:03:42 <roconnor> 6.6 doesn't support LANGUAGE :(
17:04:15 <mmorrow> newsham: if you can't convince him to use haskell, at least get him to use octave instead of matlab ;)
17:04:40 <roconnor> -fextended-default-rules
17:05:24 <SamB> roconnor: WTH are you still using 6.6 then?
17:05:42 <mmorrow>  BUSTED!
17:06:00 <mmorrow> :)
17:06:13 <roconnor> SamB: because I heard the latest Ubuntu has issues
17:07:45 * vixey needs something more interesting to do ~_~
17:07:58 <SamB> roconnor: well, WTH are you still using ... then?
17:08:04 <leoncamel> morning, all
17:08:08 <SamB> fill in as needed
17:08:31 <roconnor> SamB: because I heard the latest Ubuntu has issues
17:08:35 <mmorrow> fedora is nice
17:08:42 <roconnor> oh
17:08:43 <roconnor> heh
17:08:54 <SamB> vixey: prove that we were all wrong about logic such that the halting problem can be solved
17:09:29 <vixey> that's like proving Z = S Z
17:09:45 <SamB> well, you can start there I guess
17:10:09 <Associat0r> newsham : or VSLab
17:10:13 <SamB> you could implement abstract stone duality
17:10:26 <SamB> thereby making it concrete and ruining the name
17:10:36 <vixey> haha
17:11:15 <SamB> (which I only thought of after suggesting you implement it ;-)
17:11:23 <atp> performance question: how well does GHC handle typeclass polymorphism?  if i have a typeclass Foo t and I want write an instance for (Num t, Bounded t) => Foo t, will the code that GHC produces be as efficient as it would be if I wrote an instance for just, eg, Int64?
17:11:49 <atp> what overhead (if any) would there be?
17:11:49 <SamB> it depends on how much inlining happens
17:12:02 <SamB> if you want to mitigate any overhead, you can specialize things
17:12:13 <SamB> look up SPECIALIZE in GHC's manual
17:12:25 <atp> right, i've seen the specialize pragma....
17:12:34 <atp> never used it though
17:13:15 <SamB> basically it would make it so that code that used your code at for Int64 wouldn't see a hit
17:13:42 <SamB> (monomorphic code)
17:17:02 * SamB wonders how you render piecewise continuous functions computable again
17:17:08 <noecksit> hello, i am having trouble with gtk2hs-0.9.12.1 and i was wondering whether 0.9.13 is in portage yet on gentoo?
17:17:56 * SamB also wonders how you replace the unit step function in a computable world
17:20:34 <SamB> seen http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/?
17:20:36 <lambdabot> Title: Mathematics and Computation » Sometimes all functions are continuous, http://tinyurl.com/5ofwd3
17:22:09 <roconnor> what do you need a unit step function for?
17:22:40 <SamB> well, it's used as a model...
17:22:42 <vincenz> roconnor: signal processing
17:23:07 <roconnor> more specifically?
17:23:09 <SamB> we clearly can't make actual continuous signals with it in...
17:23:23 <SamB> roconnor: what the heck do you mean, more specifically ? it's in CHAPTER ONE of the book
17:23:25 <roconnor> I have a theory of step functions for integration purposes
17:23:39 <vincenz> roconnor: been a while
17:23:41 <roconnor> if you want to integerate step functions, that is no problem
17:23:55 <roconnor> you just cannot coeherently evaluate them
17:24:09 <roconnor> but there are still a lot of intresting things you can do with them
17:24:24 <roconnor> these step functions are not "functions" in the A -> B sense
17:24:32 <roconnor> more like A ~> B
17:24:46 <roconnor> (no pure, so I guess it isn't a arrow)
17:25:11 <SamB> why wouldn't there be a pure?
17:25:33 * roconnor ponders that
17:25:38 <SamB> surely you can embed the computable functions in your theory
17:25:40 <roconnor> Maybe there is a pure
17:25:58 <roconnor> hmm
17:26:02 <SamB> I mean, in an extended version of your theory ;-)
17:26:12 <roconnor> hard to say
17:26:23 <roconnor> looks more promising than I originally thought.
17:26:27 <SamB> at least the ones that Coq will believe are computable
17:27:20 <vixey> what about Epigram!
17:27:47 <vixey> I want to try the Cont Monad laws in OTT...
17:28:27 <SamB> another thing we like to do with the unit step function is multiply other signals by it pointwise, to make them "causal"
17:28:49 <jre2> is it recommended to generalize error reporting with fail (so someone can use Either or Maybe)?
17:29:01 <vixey> jre2: no
17:29:04 <vixey> :t mzero
17:29:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
17:29:14 <vixey> jre2: sometimes you could use that
17:29:16 <SamB> jre2: yes ;-P
17:29:52 <roconnor> SamB: my step functions form a ring
17:30:04 * SamB forgets what noise a monad makes
17:30:39 <roconnor> And presumably can be convolved
17:31:06 <roconnor> but I haven't written that
17:31:36 <SamB> roconnor: yes, but can you compute any values at all?
17:31:45 <roconnor> I can integrate it
17:31:55 <SamB> at least a little bit?
17:32:25 <monochrom> A monad makes a binding noise.
17:33:35 <vixey> I can't build agda with GHC 6.9 :[
17:33:40 <SamB> jre2: btw, I was saying that I think you should use fail
17:33:52 <SamB> but you should also constrain your function to MonadPlus
17:34:09 <roconnor> SamB: integrable functions are only defined upto changes by measure 0
17:34:13 <SamB> (which is where fail should have been in the first place)
17:34:20 <roconnor> SamB: evaluation at a point doesn't make any sense
17:34:35 <SamB> roconnor: how about evaluation between two points?
17:34:38 <SamB> can you do that?
17:34:41 <vixey> @instances MonadPlus
17:34:48 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:34:59 <ddarius> @instances MonadError
17:34:59 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
17:35:03 <roconnor> SamB: I can integrate over a non-trivial compact interval.
17:35:18 <roconnor> SamB: a small one if you want
17:35:28 <SamB> so, you could graph the function, yes?
17:35:33 <roconnor> SamB: I might be able to take the limit as the interval goes to 0.
17:35:35 <roconnor> not sure
17:35:39 <roconnor> if that limit converges
17:35:48 <SamB> generally graphs are done at finite resolution ;-)
17:36:16 <roconnor> SamB: I could integrate the function of a series of small intervals (call them pixels)
17:36:31 <SamB> can you find minimums and maximums over a non-trivial compact interval?
17:37:10 <roconnor> If you use Linfinity instead of L1 the integral becomes the sup
17:37:33 <roconnor> you have an injection from Linfinity to L1, but not the other way.
17:38:03 <SamB> the minimum and the maximum would probably be more what EEs would be interested in seeing on a plot anyway
17:38:37 <SamB> roconnor: I don't know if that means yes or "not possible" :-(
17:38:58 <roconnor> roconnor: yes in many situations.
17:39:06 <SamB> I ... am not roconnor ;-)
17:39:20 <roconnor> But one needs to distiguish between L1 and Linf functions.
17:39:32 <SamB> oh.
17:39:41 <roconnor> Presumbably you are asking for a sup in the context when it makes sense
17:39:53 <roconnor> so you will probably have an Linf function at the time
17:39:54 <SamB> I suppose the Dirac Delta function would throw a wrench in the works :-(
17:40:19 <roconnor> SamB: If you use the dirac cumlative distribtion, that is not a problem.
17:40:49 <SamB> I really only am familiar with Dirac's definition of the delta function
17:40:50 <augustss> roconnor: is this your constructive analysis stuff?
17:40:52 <roconnor> SamB: I was writing a Reimann integral, but I ended up with a Stiltjes (sp?) integral for free.
17:41:01 <roconnor> augustss: yes
17:41:16 <roconnor> Riemann
17:41:20 <SamB> which even those classical-logic people don't think rigerous
17:41:40 <roconnor> Stieltjes
17:41:52 <roconnor> SamB: what do you mean?
17:42:30 <SamB> roconnor: well, he was apparantly a physicist ...
17:42:34 <roconnor> (actually my integral doesn't seem quite as general as Stieltjes's, but it is very close)
17:42:43 <vixey> Riemann was the first to define integration rigerously
17:42:52 <roconnor> Riemann integration is well understood.
17:43:00 <ddarius> roconnor: Have you looked at the Daniell integral?
17:43:19 <roconnor> ddarius: possibly
17:43:34 <SamB> I guess we've call complaining about how little reimann integration can do -- it's a pretty decent first try ;-)
17:43:44 <SamB> +no
17:43:50 <SamB> we've no call
17:44:41 <SamB> roconnor: well, basically it goes like this
17:45:16 <SamB> Î´(t) = 0 when t â‰  0
17:46:00 <SamB> âˆ«_{-âˆž}^âˆž Î´(t) dt = 1
17:46:19 <roconnor> Stieltjes's integral can integrate with respect to a dirac "measure"
17:46:48 <EvilTerran> "{-âˆž}^âˆž"? O.o
17:47:03 <Zao> That's an awfully wide range.
17:47:07 <ddarius> EvilTerran: From negative infinity to positive infinity.
17:47:10 <roconnor> EvilTerran: lower and upper bound of integration
17:47:23 <SamB> EvilTerran: I can't do sub/superscripts in IRC
17:47:24 <EvilTerran> oh, i see. that makes more sense than what i parsed it as.
17:47:40 * vixey found some PHD thesis to read
17:47:46 <EvilTerran> it'd be an awfully odd value if you took it as a term on its own :P
17:47:53 <ddarius> vixey: There are lots of those.
17:48:10 <SamB> EvilTerran: I wouldn't have the remotest idea where it lay
17:48:11 <vixey> ddarius: most of them don't make any sense
17:48:13 <vixey> a
17:48:22 <SamB> not a clue in what direction it was from the origin
17:48:39 <vixey> ddarius: hey I am wondering if you have a repo/darcs thing online if you are still working on a linear logic language?
17:48:41 <dolio> I've been collecting theses that I'll probably never read for a while.
17:48:59 <EvilTerran> i think its signum is undefined, even tho its modulus is defined at âˆž
17:49:16 <ddarius> vixey: I don't have a repo online.  I'm still working on it per se.  I just haven't been in the mood or have been distracted by other things, but I do intend to get it somewhere.
17:49:25 <SamB> EvilTerran: 'sokay
17:49:31 <SamB> signum isn't computable anyway
17:49:38 <EvilTerran> yay
17:49:50 <SamB> http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
17:49:52 <lambdabot> Title: Mathematics and Computation » Sometimes all functions are continuous, http://tinyurl.com/5sr6e8
17:50:03 <roconnor> anyhow, one can probably constructively do all this integration and signal processing stuff, so long as one does not always use "A -> B" to represent "functions"
17:51:11 <SamB> and of course my teacher probably won't understand what I mean if I tell him that signum isn't computable ;-P
17:51:30 <SamB> since obviously matlab has no problem with it, right?
17:52:12 <vixey> oh interesting point yes
17:52:18 <vixey> I'd never thought of that
17:52:41 <SamB> he does of course know that it is not realizable ;-)
17:54:22 <SamB> I mean, parasitic capacitance and line resistance ensure THAT
17:54:43 <SamB> (parasitic may be the wrong word)
17:54:52 <roconnor> > signum (2 - sum [2^n | n<-[0..], not (oddPerfectNumber n)])
17:54:52 <lambdabot>   Not in scope: `oddPerfectNumber'
17:55:10 <roconnor> ask matlab to compute that
17:55:28 <roconnor> what, matlab can't take limits?
17:55:30 <roconnor> lame
17:55:39 <SamB> heh
17:55:51 <SamB> it really can only handle numerical stuff...
17:56:17 <roconnor> sooo, rational numbers then
17:56:46 <SamB> typically represented in IEEE floating point
17:56:48 <roconnor> > toRational pi
17:56:49 <lambdabot>  884279719003555%281474976710656
17:57:14 <SamB> Mathematica is much better
17:57:41 <roconnor> > toRational (pi::CReal)
17:57:42 <SamB> ... unless of course you wanted to manipulate huge arrays
17:57:42 <lambdabot>  Exception: CReal.toRational
17:57:51 <roconnor> :)
17:58:03 <SamB> heh
17:58:12 <roconnor> not an unreasonable answer
17:58:13 <SamB> they forgot to implement it, eh?
17:58:51 <vixey>   22%7
18:00:14 <roconnor> augustss: It's hard to get sin to default to (Sym Double -> Sym Double) in ghci
18:04:21 <dolio> Is 'f x | x < 0 = -1 | otherwise = 1 ' also not computable?
18:04:51 <vixey> x < 0 isn't computable
18:05:23 <roconnor> > 0 < (0::CReal)
18:05:24 <lambdabot>  False
18:05:33 <roconnor> :/
18:05:40 <roconnor> stupid CReal
18:05:45 <vixey> > pi < (pi::CReal)
18:05:46 <lambdabot>  False
18:05:50 <vixey> oh
18:06:07 <roconnor> > 2^(-1024) < (0::CReal)
18:06:09 <lambdabot>  Exception: Prelude.^: negative exponent
18:06:25 <roconnor> > 0 < (2^^(-1024)::CReal)
18:06:26 <lambdabot>  False
18:06:34 <roconnor> > 0 < (2^^(-1024))
18:06:35 <lambdabot>  False
18:06:48 <roconnor> all lies!
18:06:56 <roconnor> lambdabot: why do you lie to me?
18:07:09 <EvilTerran> @vixen why did you lie to roconnor?
18:07:09 <lambdabot> why not?
18:07:18 <roconnor> touche
18:07:20 <SamB> > 0 < (2^^(-1024)::Rational)
18:07:21 <lambdabot>  True
18:07:26 <vixey> hehe
18:07:30 <SamB> you did not ask in the correct way
18:07:30 <EvilTerran> ah, she's a good little psychopath
18:08:07 <roconnor> so the lesson is that you can compute x < 0, if you are willing to get the wrong answer.
18:08:36 <vixey> lol
18:09:59 <dolio> Kind of depends on your representation, doesn't it?
18:10:45 <dolio> If my reals (say (-1,1)) are 'data Real = Positive (Stream Digit) | Negative (Stream Digit)' then I can decide right away.
18:10:52 <dolio> But then addition isn't computable.
18:11:02 <vixey> true, true
18:11:44 <dolio> I suppose that's the same problem, really. It just shows up in a different 'function'.
18:11:48 <roconnor> doilo how do you represent 0?
18:13:58 <dolio> 'data Real = ... | Negative (Sigma (s : Stream Digit) (Exists (i : Nat) (s[i] /= 0)))'
18:14:46 <vixey> ..we're not in kansas anymore
18:14:59 <dolio> 0 = Positive (repeat 0)
18:15:35 <roconnor> dolio: what is Negative (repeat 0) ?
18:15:53 <dolio> Not a valid Real.
18:15:55 <vixey> it look like a type error
18:16:00 <dolio> Yeah.
18:16:08 <vixey> do not ask me how  the typechecker would figure that out
18:16:33 <dolio> You wouldn't be able to provide a proof for the second component of the sigma type.
18:16:41 <dolio> Presumably.
18:19:21 <dolio> I'm not sure what the definition of 'continuous' for that data type is, though.
18:20:58 <noecksit> is there any way to use function composition without wrapping the functions in parenthesis? it seems that the second function always gets evaluated before the (.) function
18:21:20 <roconnor> dolio: Scott topology
18:21:21 <vixey> noecksit: can you make an example to be clearer?
18:22:44 <noecksit> (+4).(*2) 3 does not evaluate properly but ((+4).(*2)) 3 does
18:22:52 <vixey> you must use $
18:23:00 <vixey> > (+4) . (*2) $ 3
18:23:02 <lambdabot>  10
18:23:10 <EvilTerran> (+4).(*2) 3 = (+4).((*2) 3)
18:23:10 <vixey> > (*77) . (+4) . (*2) $ 3
18:23:11 <lambdabot>  770
18:23:40 <idnar> (+4) $ (*2) $ 3
18:23:40 <roconnor> noecksit: $ is the same as whitespace, but at a different precidence
18:23:42 <idnar> > (+4) $ (*2) $ 3
18:23:43 <lambdabot>  10
18:24:03 <noecksit> yeah, so thats it, huh, i want to get rid of some ugly parenthesis :)
18:24:06 <EvilTerran> in general, (w x & y z) = (w x) & (y z)
18:24:17 <EvilTerran> regardless of what operator & may be
18:24:51 <noecksit> :t (&)
18:24:52 <lambdabot> Not in scope: `&'
18:25:16 <noecksit> EvilTerran : thats just an example
18:25:37 <EvilTerran> i mean, function application (the " " in "f x") binds tighter than any operator
18:25:56 <EvilTerran> & was just a placeholder, it could just as well be + or * or . or whatever
18:26:21 <EvilTerran> well, not whatever, `whatever` :P
18:26:21 <noecksit> ok, it would seem that (.) is a function also and i thought the compiler read from left to right
18:26:27 <dolio> Or, suppose you use the simpler Real type, and your function is: 'f (_ digits) | all (==0) (take 1000 digits) = 1 | otherwise = 0'
18:26:36 <roconnor> @index (.)
18:26:37 <lambdabot> Prelude
18:26:39 <EvilTerran> yes, (.) is an operator like any other ,defined in the prelude
18:26:41 <roconnor> er
18:26:42 <EvilTerran> ?src (.)
18:26:42 <lambdabot> (f . g) x = f (g x)
18:26:42 <lambdabot> -- In lambdabot, it's been generalised to:
18:26:42 <lambdabot> (.) = fmap
18:26:54 <roconnor> @fixity (.)
18:26:54 <lambdabot> Unknown command, try @list
18:27:11 <EvilTerran> infixr 9, i think
18:27:15 <noecksit> so it would first evalute (*77) then (*2), rather than first (*2) 3, as i would imagine
18:27:21 <roconnor> Prelude> :i (.)
18:27:21 <roconnor> (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in GHC.Base
18:27:21 <roconnor> infixr 9 .
18:27:37 <roconnor> level 9
18:27:39 <vixey> noecksit: No the evaluation order is not what's going on
18:27:58 <EvilTerran> it's precedence and fixity. parsing, not evaluation
18:28:36 <roconnor> a + b * c = a + (b * c), while a * b + c = (a * b) + c
18:28:44 <dolio> That would appear to be a definition of |x| < 10^-1000, and it's still addition that's not computable.
18:28:46 <roconnor> same idea with .
18:29:16 <noecksit> oh, so a direct function has higher precedence than (.), i see
18:29:25 <EvilTerran> exactly
18:29:44 <EvilTerran> a direct function has higher precedence than *any* operator. (.) is just an example
18:29:54 <EvilTerran> and :: has lower precedence than any operator
18:30:44 <EvilTerran> and the bodies of "\ ... ->"s and "let ... in"s extend as far as possible
18:30:50 <dolio> Or, I suppose it isn't, because f ((replicate 1000 0) ++ repeate 9) == 0, so 10^-1000 technically has two values, so it's not a function.
18:31:54 <dolio> Or, perhaps strictly speaking, its not a proper representation of real numbers.
18:34:55 <roconnor> it is essentially impossible to have a proper representation of the reals
18:35:28 <roconnor> but when we talk about there being no discontinuous functions, we are always talking about the Scott topology of the representatives
18:35:53 <roconnor> which might be different from the topology of the Setoid.
18:36:22 <ddarius> @seen conal
18:36:23 <lambdabot> I saw conal leaving #haskell and #ghc 3h 19m 50s ago, and .
18:36:26 <dolio> Yeah.
18:41:05 <vixey> when they start representing families of logic formala using ... and vertical ... that is when I get confused
18:44:03 <ddarius> Joy.  I could write this as return . return . return . ... for three different monads.
18:44:29 <ddarius> vixey: ? Natural deduction diagrams?
18:44:31 <dolio> Great.
18:44:58 <vixey> yes
18:46:24 <roconnor> @type formatTime
18:46:25 <lambdabot> Not in scope: `formatTime'
18:46:32 <roconnor> @hoogle formatTime
18:46:32 <lambdabot> Data.Time.Format.formatTime :: FormatTime t => TimeLocale -> String -> t -> String
18:46:32 <lambdabot> Data.Time.Format.FormatTime :: class FormatTime t
18:46:32 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
18:46:45 <roconnor> @hoogle TimeLocale
18:46:46 <lambdabot> System.Locale.TimeLocale :: data TimeLocale
18:46:46 <lambdabot> System.Locale.TimeLocale :: [(String, String)] -> [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> TimeLocale
18:46:46 <lambdabot> System.Locale.defaultTimeLocale :: TimeLocale
18:47:07 <roconnor> I don't quite understand why formatTime requires a TimeLocale
18:47:41 <Zao> roconnor: Timezone and whatnot?
18:49:15 <roconnor> I suppose some of the % stuff requires the locale
18:49:35 <mmorrow> i don't get that link about all functions being continuous
18:50:07 <mmorrow> a function is continuous if under it the inverse img of open sets are open
18:50:23 <mmorrow> (in the given topology)
18:51:13 <mmorrow> so if one's not speaking about morphism in Top, then a "continuous" function has no meaning
18:51:34 <mmorrow> i
18:51:59 <roconnor> mmorrow: Scott topology
18:52:16 <mmorrow> what is that?
18:52:28 <roconnor> @google Scott topology
18:52:29 <lambdabot> http://en.wikipedia.org/wiki/Glossary_of_order_theory
18:52:31 <mmorrow> did i miss that in my haste?
18:52:35 <roconnor> no
18:52:44 <mmorrow> heh, good
18:52:45 <roconnor> people tend to omit mentioning it for some reason
18:53:32 <roconnor> http://en.wikipedia.org/wiki/Scott-continuous
18:53:57 <roconnor> in our case the PO is the DCPO that we know and love from Haskell's semantics
18:55:21 <mmorrow> ah, so "Scott-continuous" is just saying "a functor that maps terminal object to terminal object"
18:56:59 <mmorrow> (in less general language)
18:58:39 <dolio> That's less general?
18:58:39 <mmorrow> (or replace terminal object with the appropriate colimit depending on how you categorify the situation)
18:58:52 <mmorrow> dolio: heh, i meant the opposite way you're thinking
18:58:52 <dolio> What did wikipedia give it in terms of? Kan extensions?
18:59:01 <dons> http://www.reddit.com/info/6pfvy/comments/
18:59:01 <lambdabot> Title: reddit.com: Data structures with holes: a blessed man's formula for holey contai ...
18:59:32 <mmorrow> i originally said that as "(in more general language)" but then thought that that wasn't correct
18:59:41 <mmorrow> i find that interesting for some reason
19:01:07 <mmorrow> i guess given the original sentence, "less general" would be the correct way to say it, but at first glance it seems to be the opposite
19:01:44 <mmorrow> (i'm just talking about the sentence and not about the math)
19:02:29 <mmorrow> </rambling>
19:03:07 <vixey> that was cool dons
19:08:10 <mmorrow> dons: did you ever look into Oleg's NewerCGI.hs, FastCGI.hsc ?
19:10:24 <mmorrow> dons: if you're still interested in things *CGI, mohws also has a CGI implem
19:10:47 <mmorrow> dons: which is one of it's "modules"
19:11:38 <mmorrow> dons: i use (fast)cgi a bunch so am very interested in other implementations...
19:16:44 <dons> yeah, we use fastcgi a lot at work, so i'm interested in anything in this area
19:18:30 <mmorrow> cool, being reminded of NewerCGI makes me want to give another go at trying to get it to work
19:20:53 <mmorrow> (and his FastCGI even more so)
19:35:21 <nottha_k> any yi users here? I succefully built yi for the first time ever today. now I'm stuck here: http://pastebin.com/m4a776403
19:35:36 <nottha_k> that appears in some dialog window after launching it for the first time
19:37:12 <golubovsky> @seen mmorrow
19:37:12 <lambdabot> mmorrow is in #haskell and #ghc. I last heard mmorrow speak 16m 19s ago.
19:37:30 <golubovsky> mmorrow:  ping
19:43:33 <golubovsky> Hi everybody, Dimitry here.
19:45:08 <vixey> hi
19:45:11 <mmorrow> golubovsky: exactly the person i wanted to see :)
19:45:29 <golubovsky> mmorrow: I saw you asked about yhcjs
19:45:44 <mmorrow> golubovsky: yes
19:46:11 <golubovsky> mmorrow: so, what exactly you tried and were unsuccessful with?
19:46:24 <mmorrow> so, i can build the examples from the tutorial, and they all display stuff properly, but the stuff in volving the JThreads doesn't seem to be working
19:47:01 <mmorrow> my guess was that i'm not having the correct entry point jumped to in the onload=expEval(...) atrrib of the body
19:47:12 <golubovsky> mmorrow: can you paste the example to the pastebin (one at www.golubovsky.org)?
19:47:25 <mmorrow> because i had to mess with that in the makefile/buiildscript to make it diff from that in the programmers guide
19:47:27 <mmorrow> yes
19:50:14 <hpaste>  morrow pasted "mkHs2Js.sh" at http://hpaste.org/8615
19:50:35 <mmorrow> ok
19:50:51 <mmorrow> ohhh, oops
19:51:01 <mmorrow> wrong pastebin
19:51:09 <mmorrow> repasting
19:53:16 <golubovsky> mmorrow: if you use Yhc Web Service, it will build the stuff for you ;) You only need to specify the "main" function in the module you are submitting.
19:53:17 <mmorrow> golubovsky: oh, i see. my example is a shell script that i'm using as a Makefile
19:53:34 <mmorrow> the yhcjs haskell code examples were from your tutorial
19:53:56 <mmorrow> i couldn't get the ones from 3+ working
19:54:10 <mmorrow> (at least the JSThreads msg passing code)
19:54:18 <golubovsky> Basically that was the reason I am running this service to make people's life easier wrt build scripts: had enough pain with them myself :)
19:54:21 <mmorrow> they displayed perfectly though
19:54:46 <mmorrow> golubovsky: i pasted that script here: http://hpaste.org/8615
19:55:30 <mmorrow> could it be that my options to pgbuild are what's causing it not to work?
19:55:48 <golubovsky> mmorrow: did you try to paste your Haskell code here: http://www.golubovsky.org:5984/static/yhcws/MainGUI.html
19:56:01 <mmorrow> i will
19:56:10 <mmorrow> (but it's *your* haskell code)
19:57:25 <golubovsky> mmorrow: why mine? if you wrote it?
19:57:34 <mmorrow> i didn't write it
19:57:49 <mmorrow> i was trying to get your examples in the tutorial to run
19:58:14 <mmorrow> and having trouble with, for example, example 3
19:59:33 <mmorrow> it works on your pastebin (just pasted and tried)
20:00:33 <mmorrow> the code that controls the js event handling part is not working for me, but the two textboxes are drawn ok
20:00:47 <golubovsky> mmorrow: firefox or msie?
20:00:50 <mmorrow> firefox
20:01:02 <mmorrow> i have NoScript installed
20:01:02 * codacola loves this language more and more everyday
20:01:14 <mmorrow> but have it set to allow fil:///...
20:01:19 <mmorrow> file:///...
20:01:32 <mmorrow> (if that could be it?)
20:01:44 <mmorrow> i don't think it can though
20:02:09 <golubovsky> if you type something in the left box, does anything appear at the right?
20:02:22 <mmorrow> no. this is the exact problem
20:02:29 <mmorrow> i can't figure it out
20:02:55 <golubovsky> why did you mention file : / /?
20:03:57 <mmorrow> not important, i have a plugin for my browser that blocks javascript on sites unless i allow them, and i allowed file:/// so i don't think it's this plugin that's causing the error
20:04:36 <mmorrow> is there a way that i could try to figure out why?
20:05:34 <mmorrow> oh, golubovsky, it work perfectly for me on your site, but on my computer it isn't working
20:05:43 <golubovsky> In fact, if JS was blocked completely, you wouldn't even see the boxes.
20:05:51 <mmorrow> true
20:06:15 <jre2> is there a more general function like this one:
20:06:36 <jre2> swapInside m f = case m of Right x -> return $ f x; Left e -> fail e
20:06:37 <mmorrow> but it is drawing the boxes on when i compile it myself, just not catching keystrokes
20:08:10 <kpreid> je: is the return type Either?
20:08:17 <jre2> swapInside :: (MonadPlus m) => Either String a -> (a -> b) -> m b
20:08:41 <mmorrow> golubovsky: is this correct:   pgbuild ..... --onload="exprEval(funIdx['main'])"        ?
20:09:22 <kpreid> jre2: well, I'd decompose it into fmap and an eitherToMonadFail
20:09:41 <golubovsky> funIdx["TutEx3;main"] = F_c2; </script></head> <body onload="exprEval(funIdx['TutEx3\;main'])"> </body> </html>
20:10:07 <mmorrow> excellent, i will try that now
20:10:41 <golubovsky> this was taken from the compiled html. I think, you used a bit outdated docs. Sorry, I did not update them because I believed that the web service will save people from dealing with this.
20:11:14 <golubovsky> BTW you can import modules, only they have to be visible on internet (like with searchpath)
20:11:47 <jre2> kpreid: thanks
20:17:15 <mmorrow> golubovsky: that didn't work for me either
20:17:23 <mmorrow> golubovsky: i love your webservice!
20:18:18 <golubovsky> mmorrow: OK let me get this: you submit the code to the webservice, it compiles, and boxes interact as expected? You compile the same code offline, and it doesn't work?
20:18:54 <mmorrow> yeah, i can't figure out *what* i must be doing wrong
20:19:46 <mmorrow> ok, i'll compare the js source compiled on you site to the js compiled on my computer, and maybe that'll help me figure it out. thanks for the help.
20:20:01 <mmorrow> i'll let you know how it turns out with @tell :)
20:20:26 <golubovsky> mmorrow: I have to disconnect, send me e-mail to golubovsky at gmail dot com.
20:20:35 <mmorrow> will do, thanks ;)
20:20:36 <golubovsky> Bye
20:24:26 <jre2> :q
20:24:54 <mmorrow> :!sudo shutdown -hf now
20:26:19 <roconnor> is there a wikipage about variable number parameters?
20:27:31 <shapr> glguy: hpaste needs searching.
20:29:23 <mmorrow> roconnor: this paper is good and may be directly related to your question: http://research.microsoft.com/%7Esimonpj/papers/eval%2Dapply/
20:29:23 <lambdabot> Title: How to make a fast curry
20:30:13 <roconnor> mmorrow: not quite what I'm looking for
20:30:15 <roconnor> thanks
20:31:01 * dmwit suggests http://www.bigoven.com/83670-Fast-Chicken-Curry-recipe.html
20:31:01 <lambdabot> Title: Recipe Software and Food Social Network
20:31:22 <dmwit> That's a fast curry!
20:32:16 <mar77a> @where curry
20:32:16 <roconnor> @quote calculator
20:32:16 <lambdabot> http://www.informatik.uni-kiel.de/~mh/curry/
20:32:17 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
20:32:22 <roconnor> @quote calculator
20:32:22 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
20:32:28 <mar77a> @quote mar77a
20:32:28 <lambdabot> No quotes match. :(
20:32:31 <mar77a> phew
20:33:15 <roconnor> where is Cale's RPN calculator?
20:33:29 <Cale> I have an RPN calculator?
20:33:37 <roconnor> I thought you did
20:33:42 <dmwit> ?quote rpn
20:33:42 <lambdabot> No quotes match. Just what do you think you're doing Dave?
20:33:45 <roconnor> start bla bla bla end
20:33:50 <dmwit> ?where stack-calculator
20:33:50 <lambdabot> I know nothing about stack-calculator.
20:33:54 <dmwit> ?quote stack
20:33:54 <lambdabot> ghc says: GHC stack-space overflow
20:33:57 <dmwit> ?quote stack
20:33:58 <lambdabot> ghc says: Use -fcontext-stack20 to increase stack size to (e.g.) 20
20:34:35 <roconnor> ?quote start
20:34:36 <lambdabot> sfultong says: I need to start thinking more lazily
20:34:42 <roconnor> ?quote end
20:34:43 <lambdabot> scodil says: dcoutts: rad. i'm actually using gtk2hs quite a bit now. its one of those deals where I'm writing prototype software for people who aren't really paying for it, so it will end up being
20:34:43 <lambdabot> the production software, so you'll probably be getting emails in 5 years asking "what is haskell and how do I install it?"
20:34:48 <roconnor> :(
20:34:50 <shapr> @quote
20:34:50 <lambdabot> araujo says: Feel free to stop by and drop in some words if you like :-)
20:35:08 <shapr> @quote seafood
20:35:08 <lambdabot> No quotes match. My brain just exploded
20:35:10 <shapr> aww
20:35:14 <shapr> @quote
20:35:14 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
20:35:22 * shapr snickers
20:35:25 <shapr> @quote
20:35:25 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
20:37:39 <vixey> @quote
20:37:39 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexadecimal.
20:37:46 <vixey> @quote
20:37:46 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
20:37:57 <vixey> ?localtime shapr
20:37:57 <lambdabot> Local time for shapr is Sat Jun 28 23:37:57 2008
20:38:13 <dolio> @quote qwe1234
20:38:13 <lambdabot> qwe1234 says: lol, 'free university of amsterdam'.
20:38:17 <shapr> I'm tired.
20:38:22 <shapr> Went to the gym today...
20:38:22 <vixey> I'm a bit tired too
20:38:29 <shapr> @localtime vixey
20:38:29 <lambdabot> Local time for vixey is Sun Jun 29 04:38:29
20:38:33 <shapr> Um, I can see why.
20:38:48 <shapr> @quote dolio
20:38:48 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
20:38:59 <shapr> @quote
20:38:59 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
20:39:05 <shapr> @quote
20:39:05 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
20:39:14 * shapr grins
20:39:21 <parag1> @quote
20:39:21 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
20:39:34 <vixey> @qeal
20:39:34 <lambdabot> just seeing how offtopic i could get everyone
20:39:36 <vixey> @qeal
20:39:37 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
20:40:05 <parag1> @quote lambdabot
20:40:05 <lambdabot> lambdabot says: ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
20:40:20 <shapr> I didn't kick keal off #haskell, even after he was here for days... because I thought he was an intermediate quality markov bot.
20:41:00 <shapr> About a week later I asked dons why he'd banned that almost-funny bot...
20:41:10 <dolio> Heh.
20:41:14 <shapr> keal failed his turing test.
20:41:43 <vixey> :p
20:41:49 <vixey> @brain
20:41:49 <lambdabot> Wuh, I think so, Brain, but burlap chafes me so.
20:42:04 <shapr> @quote dons
20:42:04 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
20:44:19 <shapr> @quote
20:44:19 <lambdabot> Botje says: unlike bridges, tentacles work just fine in programming
20:45:32 <roconnor> how does that calculuator work again
20:45:37 <roconnor> something about continuations
20:45:53 <roconnor> and polymorphism
20:47:48 <shapr> g'day blackdog
20:48:20 <blackdog> sup, shapr
20:48:22 <blackdog> long time no talk
20:48:34 <shapr> Yeah, how's life?
20:48:40 <blackdog> working for a telco
20:48:42 <blackdog> on the weekend
20:48:48 <blackdog> launching in a month
20:49:04 <shapr> cool
20:49:04 <blackdog> hacking perl mostly
20:49:10 <shapr> I'm not surprised :-)
20:49:19 <blackdog> doing my very best to functionalise things :)
20:49:38 <blackdog> how about you?
20:50:06 <dino-> blackdog: Wow, that sounds like my life. I work for AT&T at the moment. Also loads of Perl. And I try to build on Language::Functional as much as I can.
20:50:19 <blackdog> (parenthetically: perl is actually quite amenable to being used functionally. think of it as a scheme with a bit of weirdness as far as argument passing goes)
20:50:28 <shapr> Writing C# in Boston. When are you coming to visit? :-)
20:50:36 <blackdog> dino-: oh, cool :) what's language::functional?
20:50:39 * blackdog checks cpan
20:50:39 <shapr> hey dino- !
20:50:48 <blackdog> shapr: after launch, perhaps :)
20:50:55 <shapr> Good idea!
20:50:56 <blackdog> when are you coming to sydney? we have better beaches
20:51:08 <shapr> When I have vacation time and can afford a flight :-)
20:51:21 <shapr> I'll try to show up during winter here.
20:51:22 <dino-> blackdog: It's a module with a huge block of stuff from the Prelude implemented in Perl. Including infinite lists of a limited set of things like integers and functions that can use them.
20:51:44 <blackdog> oh, i'm gonna make my colleagues miserable with this :)
20:51:47 <dino-> Seems kind of cut loose and no longer maintained, but it's useful.
20:52:02 <dino-> blackdog: haha, awesome. I try to do that too.
20:52:13 <blackdog> been reading Mark-Jason dominus's "Higher Order Perl"
20:52:17 <blackdog> it's sort of comforting
20:52:18 <blackdog> :)
20:52:32 <dino-> I actually am in another situation where I'm very close to talking people into letting me rewrite some things in actual Haskell. Have to see, it's all happening right now.
20:52:46 <blackdog> actually, it's funny - the two guys i work closely with have sort of reached a similar sort of style organically
20:53:06 <blackdog> both are old-school perl guys, but coderefs go flying everywhere...
20:53:38 <blackdog> dino-: but yeah, that's pretty cool. people tend to get worried that they can't get hackers for it, i guess.
20:53:43 <blackdog> that was the worry on my current project
20:53:55 <dino-> But honestly I feel like Perl is a dead-end this way. Building functional stuff with it is only staving off the real solution: not using it
20:53:55 <blackdog> so they started off trying to do it in java rather than perl
20:53:59 <vixey> can't just have them learn a new language?
20:54:24 <newsham> gwern/cale around?
20:54:30 <newsham> is lambdabot code in flux right now?
20:54:38 <Cale> newsham: um...
20:54:50 <Cale> newsham: Not really...
20:54:58 <blackdog> dino-: have mixed feelings. i'd rather write in haskell than perl, but it's miles better than hacking java
20:55:19 <dino-> I see. I'm kind of the most experienced Perl person in my group. With a lot of crabby hostility as I try to make them do any unit testing, etc.
20:55:30 <blackdog> i think anything you can do in haskell you can translate more or less one-to-one into perl. you just don't have the safety.
20:55:36 <blackdog> dino-: oh, ouch.
20:55:38 <dolio> I think gwern is trying to make it use as many external libraries as possible.
20:55:40 <dino-> yera
20:55:40 <dino-> yeah
20:55:42 <dino-> bleh
20:55:44 <blackdog> that's not a language thing then - that's culture
20:55:49 <dolio> Instead of having, say, its own copy of quickcheck.
20:56:10 <blackdog> dino-: am using LectroTest now - perl version of quickcheck
20:56:26 <hpaste>  newsham pasted "lambdabot build error?" at http://hpaste.org/8616
20:56:30 <dino-> Well, I feel that it's of critical important when you have the situation we do: A) we have NO QA dept at all, we do all of our own testing, B) Perl has no type system, no compiler really.
20:56:35 <blackdog> soon as you get that culture in that code without unit tests is worthless you're ok...
20:56:42 <dino-> To me that means: unit test or be screwed
20:56:46 <blackdog> hell yes
20:56:52 <blackdog> but i think haskell needs unit tests too
20:57:00 <dino-> s/important/importance/
20:57:06 <blackdog> you just get to skip a few of the more basic "am i getting a number back?" ones
20:57:21 <blackdog> we have a large QA department
20:57:24 <blackdog> but none of them code
20:57:30 <dino-> blackdog: Wow, I didn't know that existed, that QC for Perl
20:57:48 <newsham> cale: any ideas on the hpaste?
20:57:56 <blackdog> so we get a bunch of guys sitting on their hands, complaining that they don't have a web interface to poke at
20:58:01 <blackdog> frustrating
20:58:19 <Cale> newsham: I'm not sure...
20:58:22 <blackdog> dino-: yeah. lectrotest is nice. maybe not as nice as quickcheck, but you take what you can get.
20:58:45 <Cale> newsham: It could be someone removed -fglasgow-exts, and forgot to add appropriate language options.
20:58:47 <newsham> (also seems odd that State/* is in darcs, since its bound to have conflicts)
20:58:56 <dino-> Interesting. I wasn't sure it really works in things without the type system. The QC way of programming test-building code.
20:59:48 <blackdog> dino-: you get a bit of support from the type system, but that's mostly from the generator side of things.
21:00:28 <Cale> sigh...
21:00:35 <blackdog> effectively with perl you have scalars, arrays, hashes and refs, so it's not too hard to come up with generators that work for those
21:00:39 <Cale> Why does code.h.o still have darcs 1.0?
21:01:28 <dino-> blackdog: I will check this out. Thank you.
21:01:34 <dino-> shapr: Hey, how are things?
21:01:46 <blackdog> shapr: we're in the heart of winter her, and it's flat-out beautiful. sun is blazing, slight breeze... :)
21:01:55 <shapr> dino-: Too much microsoft.
21:02:14 <dino-> yeah, one thing I do like about all of my last 6 bad jobs: no Microsoft period.
21:02:16 <shapr> blackdog: Thus my interest in showing up when it's winter, and Boston is covered in deep snow.
21:02:16 <vixey> I think Bill Gates quit microsoft today
21:02:27 <shapr> vixey: I think it was Friday.
21:02:30 <vixey> oh
21:02:37 <vixey> shapr take over!!
21:02:45 <shapr> No way
21:02:45 <newsham> cale: any idea who to ask?  gwern?
21:03:04 <blackdog> vixey: i keep seeing your name as 'vixen', and wondering whether my bot got a whole lot smarter :)
21:03:14 <Cale> newsham: There are some patches which I got a few days ago and am in the process of applying just now.
21:03:14 <dons> we sometimes get requests to provide an online forum, a la http://www.lispforum.com/
21:03:15 <lambdabot> Title: LispForum &bull; Index page
21:03:28 <dons> does anyone think this is useful or feasible?
21:03:40 <vixey> blackdog: people think I'm a bot sometimes.. sometimes I wonder
21:03:46 <Cale> newsham: They claim to fix some build things. You might want to wait for them and try that... if it's still acting up then, it should be easy to fix.
21:04:02 <shapr> dons: Does gmane allow web access to haskell and haskell-cafe?
21:04:03 <vixey> dons: I don't since there is the newsgroups on nabble
21:04:03 <newsham> yah, i'll wait
21:04:21 <dons> so it'd be for complete newbies to internet culture, i guess
21:04:44 <dmwit> "doomed to popularity"
21:04:50 <blackdog> dons: we want them?? :)
21:05:49 <dons> well, i'm not sure, i just wonder if there's a segment of the user base we're not serving
21:06:30 <shapr> dons: Almost everything is worth trying once.
21:06:50 <dino-> shapr: Any chance of even using F# with that CLR work? I don't know much about it but I can appreciate the effort on their part to work on something far more FP than C#
21:07:19 <shapr> dino-: Nah, I don't even have chance to use VS2008 yet.
21:07:40 <newsham> cale: aprox when do you expect to have the patches applied, few hrs, tomorow, few days?
21:08:35 <Cale> newsham: I'm just trying to install darcs 2 in my user account on code right now, since darcs 1 (which is mysteriously what's installed on code) is giving me problems pulling patches.
21:25:44 <Cale> Well, that's not helping, probably because the repo's still in the old format. I suppose I'll just let it work.
21:27:26 <newsham> how would I list the patches that are in my local repo but not in some other repo?
21:32:41 <Cale> I think it might be the whatsnew command
21:34:51 <Dewi> is there a quick way to fetch and install cabal / GHC dependancies?
21:34:59 <newsham> i just did "darcs changes --repo <url> > ch1; darcs changes > ch2; diff ch1 ch2"
21:35:04 <newsham> (changes is not quite what i meant)
21:36:06 <newsham> err.. "whatsnew" is not quite what i meant, rather
21:39:11 <^Someone^> Dewi: Perhaps http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
21:39:13 <lambdabot> Title: CabalInstall - Hackage - Trac
21:39:26 <Dewi> ^Someone^: is that... ready to use yet?
21:39:52 <^Someone^> "There is also an experimental command-line tool that will make this easier."
21:39:54 <^Someone^> :)
21:40:09 <Dewi> well, I'll try it... if I can figure out how to install *it* :)
21:40:23 <vixey> @quote
21:40:23 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
21:40:26 <vixey> @quote
21:40:26 <lambdabot> inv2004 says: lambdabot: monads ?
21:40:26 <newsham> just CabalInstall CabalInstall.
21:40:36 <vixey> lambdabot: monads ?
21:40:43 <lament> @quote
21:40:43 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
21:40:43 <lambdabot> arithmetic in Roman numerals.
21:40:46 <Dewi> newsham: are you serious?
21:40:50 <^Someone^> I'll also try installing it now :)
21:40:55 <newsham> dewi: i must be.
21:41:18 <newsham> (but, no, I'm not)
21:41:37 <mmorrow> yhcjs problem solved. !!!
21:42:31 <mmorrow> (the unicode tables and printing js functions weren't being included in the js compiler/whatever output)
21:42:45 <Dewi> I can't even figure out how to download the cabal-install since it's not in a tarball...
21:42:56 <newsham> do you have darcs?
21:43:18 <Dewi> nope, do I use it to do a checkout a la svn?
21:43:18 <newsham> "darcs get http://darcs.haskell.org/cabal-install/"
21:43:22 <lambdabot> Title: Index of /cabal-install
21:43:23 <Dewi> thanks
21:43:32 <mmorrow> darcs get --partial http://......
21:43:46 <Dewi> is darcs a haskell thing or a general thing?
21:43:59 <dons> Dewi: there's a tarball on hackage.haskell.org
21:44:00 <mmorrow> both but the former much more than the latter
21:44:04 <newsham> its a distributed rev control system written in haskell but not specifically for haskell
21:44:06 <dons> and no, darcs is a general thing. we like it though.
21:44:30 * Dewi tries the version in apt, it looks nice and free of crazy deps
21:44:43 * Dewi has been wrestling with the dependancy hell that is GCQ on debian stable...
21:44:52 <Dewi> so bear with me, I'm pretty hopelessly confused :)
21:46:14 <Dewi> er I meant ghc
21:46:30 * Dewi mashes random three-letter-acronyms (TLAs) into the keyboard...
21:47:50 <^Someone^>  <dons> Dewi: there's a tarball on hackage.haskell.org
21:48:12 <^Someone^> Oh nice, I'm just about done downloading each file manually :|
21:49:07 <dons> seriously?
21:49:10 <^Someone^> Yes
21:49:19 <dons> you're doing it wrong :)
21:49:30 <^Someone^> Well it's done now
21:49:31 <^Someone^> Lol
21:49:32 <Dewi> dons: I actually thought you meant darcs. heh.
21:49:33 <newsham> > let choose xs = xs !! fst (randomR (0,lenght xs - 1) (mkStdGen 1)); ls=['A'..'Z'] in choose [[a,b,c] | a<-ls, b<-ls, c<-ls]
21:49:35 <lambdabot>  ghc-6.8.2: unknown package: oeis
21:49:51 <dons> http://hackage.haskell.org/packages/archive/cabal-install/0.4.0/cabal-install-0.4.0.tar.gz
21:49:53 <lambdabot> http://tinyurl.com/6aqmbh
21:49:53 <vixey> > ()
21:49:53 <lambdabot>  ghc-6.8.2: unknown package: oeis
21:50:01 <vixey> @oeis ()
21:50:02 <dons> lambdabot's not happy, cabal install oeis
21:50:02 <lambdabot> The prime numbers.
21:50:02 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
21:53:49 <vixey> @undef
21:53:49 <lambdabot> imports.h:40:0:     Failed to load interface for `Data.Number.Symbolic':       Use -v to see a list of the files searched for.
21:55:00 <Dewi> I assume that to get cabal install working I need to run through download/configure/make/install steps for: Cabal, network, HTTP, zlib ?
21:55:04 <Dewi> manually...
21:55:34 <Dewi> or am I making work for myself again?
21:55:37 <mmorrow> dewi, i'll paste a handy script i use like 100 times a day
21:55:47 <mmorrow> wait, are you on a unix?
21:55:50 <Dewi> sure
21:55:52 <Dewi> debian stable
21:55:52 <mmorrow> ok
21:55:55 <mmorrow> hold on
21:56:01 <mmorrow> oh yeah, apt...
21:56:07 <Dewi> (with my own ghc-6.8)
21:56:15 <Dewi> (so I am trying to avoid apt)
21:56:21 <^Someone^> If you were on Windows, I'd paste a batch file :)
21:56:36 <Dewi> I tried to patch ghc-6.8 into apt and it turned into a massive dependancy hell
21:56:40 <mmorrow> oh i was just saying i could have deduced that by you talking about using apt
21:56:43 <Dewi> so I'm just working out of /opt now
21:57:56 <hpaste>  morrow pasted "cabal_do.sh" at http://hpaste.org/8617
21:58:04 <mmorrow> Dewi: ^
21:59:19 <hpaste>  morrow annotated "cabal_do.sh" with "full version with doc-building and putting on local apache" at http://hpaste.org/8617#a1
22:00:26 <mmorrow> the second version is really nice because it ensures you have a haddock docdir for *every* cabalized package you build+install
22:00:39 <mmorrow> wherever you choose to dump the docs
22:00:50 <Dewi> thanks
22:00:54 <mmorrow> :)
22:12:10 <lorne> t/
22:16:26 <hpaste>  morrow pasted "a working yhcjs (.hs -> .{js,html}) build  script" at http://hpaste.org/8618
22:36:20 <Cale> hmm
22:41:39 <Cale> perhaps the lambdabot build script should be updated to use cabal install.
22:54:13 <roconnor> how does R compare to octave?
22:58:55 * Cale does it. The lambdabot build script now just uses cabal install, which makes things a good bit simpler.
23:00:07 <Cale> roconnor: R is more geared to statistical computation... if octave is a matlab clone, R is a clone of S.
23:00:26 <roconnor> hmm
23:01:21 <mmorrow> roconnor: a question i've thought about. in my mind, to the extent that both have to do matrixy-linearalgebra stuff *fast*, they are similar, but R is more statistics leaning while matlab is more numerical analysis leaning
23:02:00 <roconnor> mmorrow: do you have any opinion about their plotting interfaces. :)
23:02:47 <mmorrow> oh man, R is so far beyond matlab in terms of both capability and pretty
23:03:07 <mmorrow> but with that come complexity (which is worth the effort in my opinion)
23:03:25 <mmorrow> comes
23:04:56 <mmorrow> also, a plus, the R language is SO much more enjoyable to program in than matlab, especially if you're a functional programmer (probably only if as well ;))
23:05:28 <roconnor> mmorrow: so unless I have a reason to use octive, R should be my default.
23:05:45 <mmorrow> wrt making pretty graphical visualizations it should
23:06:12 <mmorrow> but beyond that, it would have to depend on what you're doing for me to know which to use
23:06:38 <roconnor> mmorrow: I want to plot my profit over time for my investments ....
23:06:48 <mmorrow> or whichever you feel like using i guess
23:06:56 <mmorrow> roconnor: *perfect* intro to R
23:07:31 <roconnor> I wonder if R has better automaticlogarithmic axis than my Charts implementation.
23:07:45 <mmorrow> simple enough to do without a lot of trouble and it's immediately useful
23:08:11 <roconnor> I wasn't happy with my Chart's auto log axis, but it seemed to be much better than any of the other systems that I tried
23:08:24 <roconnor> is there an ubuntu package for R?
23:08:44 <mmorrow> hmm, it would depend on what kind of plot you're using
23:08:54 <mmorrow> roconnor: i'm sure there is.
23:08:56 <roconnor> ... I'm scared of trying to search for R
23:09:08 <mmorrow> roconnor: and if not, it's pretty easy to build yourself
23:09:10 <roconnor> I guess it ought to be catagorized
23:09:20 <mmorrow> haha
23:09:43 <roconnor> maybe there is something I can learn from R for charts
23:09:49 <mmorrow> if i were you, i'd just get the tarball and ./configure && make && sudo make install
23:10:37 <mmorrow> got it
23:10:38 <mmorrow> http://cran.cnr.berkeley.edu/src/base/R-2/R-2.7.1.tar.gz
23:10:48 <roconnor> there is r-recommended
23:11:11 <mmorrow> arrrgyle socks
23:11:21 <mmorrow> (a pirates favorite)
23:11:28 <roconnor> oh god
23:11:36 <roconnor> I'm going to install gfortran
23:11:41 <mmorrow> LEET
23:11:59 <roconnor> R must be a quality product
23:12:16 <mmorrow> isn't everything that uses fortran??
23:12:28 <roconnor> who need recursion anyways
23:12:34 <codacola> me
23:12:39 <roconnor> recursion is lame
23:12:44 <codacola> fun
23:12:46 <roconnor> stacks are lame
23:12:56 <codacola> fun
23:12:58 <roconnor> IEEE is lame
23:13:23 <roconnor> scopes are lame
23:13:27 <codacola> youre lame
23:13:42 <roconnor> touche
23:13:48 <mmorrow> fortran rulZ
23:14:04 <roconnor> @. leet quote fortran
23:14:04 <lambdabot> Plugin `compose' failed with: Unknown command: "leet"
23:14:14 <mmorrow> haha
23:14:18 <roconnor> @. eleet quote fortran
23:14:18 <lambdabot> Plugin `compose' failed with: Unknown command: "eleet"
23:14:23 <roconnor> @. elite quote fortran
23:14:23 <lambdabot> (|-|RISKUk1ewI(s $4YS: AR3 T|-|Er3 1iTT13 kNOWN |-|4$xE11 iDIom5 ph0r Doin9 /\/\aTH? Iz0rz TheRE an UNdo(UmENT3D -FuNLe4SH-phOrTRan p4R4m3t3r?
23:14:52 <roconnor> phOrTRan
23:14:53 <vininim> omg
23:15:41 <mmorrow> hahaha phOrTRan rOOlZ
23:16:12 <mmorrow> (UmENT3D -FuNLe4SH-phOrTRan p4R4m3t3r?
23:16:17 <mmorrow> lol
23:25:20 <newsham> cale: build should also use --docdir=`pwd`/doc
23:25:34 <Cale> newsham: good point
23:26:28 <Cale> newsham: has that helped make the build work at all?
23:26:29 <vininim> damn citeseerx is lame, and citerseer is down :/
23:27:11 <newsham> cale: will know in a few mins
23:28:26 <newsham> blah, I have conflicts in "build", how do I revert my changes out without reverting the newly pulled changes?
23:29:05 <Cale> mm... you can just copy from the _darcs/pristine directory, I would think.
23:29:28 <newsham> that seems to have the pre-pull src
23:29:43 <Cale> oh
23:30:10 <Cale> hmm
23:30:38 <newsham> nevermind, i looked up the original on code.haskell.org and manually fixed the conflict in my local
23:31:05 <Cale> okay
23:31:07 <newsham> oh, I know what my problem is.  I recorded a change to build
23:31:13 <newsham> i should unrecord that back out
23:31:13 <Cale> ah
23:33:09 <mmorrow> roconnor: i put some example R (put through HsColour ;)) at the following link that i used to plot this insurance companies "territories" (collections of zip code) in diff states. also in that dir is a imagemagicked montage view of thumbnails of illinois and a fullres pdf of a territory
23:33:11 <mmorrow> http://code.haskell.org/~morrow/code/R/
23:33:11 <lambdabot> Title: Index of /~morrow/code/R
23:33:19 <newsham> so, um... what is the "cabal" command :)
23:34:07 <mmorrow> i haven't used that code in a while, no it prob won't run without tweaking (and the source data...) but it's an example nonetheless
23:34:13 <mmorrow> s/no/so/
23:34:29 <mmorrow> look at how pretty the R graphics are
23:34:46 <mmorrow> (the zipcode polygon data i got the uscensus.gov or whatever)
23:34:56 <newsham> i have Cabal-1.2.3.0 installed but no cabal command.  is it part of 1.4.0.0?
23:35:11 <Cale> newsham: it's a separate program
23:35:24 <Cale> newsham: it's in the cabal-install package on hackage
23:35:26 <mmorrow> that code there doesn't even have the zipcode drawing stuff i see...
23:35:39 <newsham> danke
23:35:44 <mmorrow> oh no it does
23:36:06 <Cale> newsham: It has a few deps, but it's usually the first thing I install, since it makes installing everything else so much easier.
23:36:35 <newsham> will cabal-install compile Setup.hs to a binary or will it use runhaskell?
23:36:52 <newsham> (runhaskell doesnt always work properly since my ghci sometimes fails... amd64 stuff)
23:36:53 <Cale> I'm not sure.
23:39:01 <mmorrow> roconnor: as you can see, other than the most basic plotting is very much a manual affair (manual wrt extensive option setting), but that's because you pretty much have complete control
23:41:10 <mmorrow> http://code.haskell.org/~morrow/code/R/territories.gif
23:42:02 <newsham> build progressed much further.  but:  Plugin/OEIS.hs:18:42: Not in scope: `lookupOEIS'
23:43:23 <newsham> (I have oeis-0.1, no version listed in cabal file.. perhaps I need newer version?)
23:43:38 <newsham> will try upgrade to 0.2
23:46:32 <newsham> ok, I dont get this one.  docs say lookupOEIS is in Math.OEIS which is imported
23:49:33 <newsham> oops, cabal install didnt make it global.  my bad
23:50:07 <newsham> is there a flag to make installation site-global when using 'cabal' cmd line?
23:51:44 <newsham> its definitely oeis 0.1 vs oeis 0.2.  the lambabot.cabal should probably specify version.
23:52:41 <newsham> after upgrading oeis everything else builds perfectly.
23:54:42 <OceanSpray> Guys, I've been pondering.
23:54:54 <OceanSpray> Haskell a very nice type system.
23:55:07 <OceanSpray> Simple and easy to understand if you go by the report, yes?
23:55:25 <OceanSpray> GHC adds TONS of features on top of it.
23:55:40 <OceanSpray> making it a lot more complicated.
23:55:59 <Adamant> don't use the features if you don't want too?
23:56:05 <Adamant> *to
23:56:29 <OceanSpray> now there's a quote somewhere about adding features to a language.
23:57:04 <mmorrow> i see it as adding features to a compiler
23:57:18 <OceanSpray> it goes something like "languages shouldn't be designed by piling feature upon feature, but by eliminating those limitations that make those features seem necessary."
23:57:35 <OceanSpray> well, I was wondering.
23:57:37 <mmorrow> although i agree with that quote
23:57:53 <mmorrow> because it sounds so "oh nicely put"
23:58:01 <OceanSpray> what is the "limitation" that makes ghc's extensions "seems necessary"?
23:58:10 <OceanSpray> I'm not saying they're useless.
23:58:36 <OceanSpray> I'm just asking whether there is some abstraction out there, a SINGLE property that can be added to the type system,
23:58:44 <mmorrow> i don't think it's necessarily about any perceived limitation, but about wanting to explore ways to do things
23:59:06 <OceanSpray> that would give the power of GADTs, multi-parameter type-classes, and so on.
23:59:14 <mmorrow> that would be awesome
23:59:31 <mmorrow> that seems like the goal to me
23:59:46 <OceanSpray> hmm, yes.
23:59:50 <OceanSpray> a very noble goal.
