00:00:09 <edwardk> build up better primitives, bake in a library for paxos, bake in a library for sharing linear bloom filters of information between processes so you don't have to share all the data, etc.
00:01:28 <edwardk> I am very intrigued by the idea sending pages of memory to a paxos cluster as a poor man's venti store at the object level.
00:02:58 <Korollary> All that would help.
00:03:53 <edwardk> the other thing i noted earlier today was that you can take a wait-free algorithm and build an impure lazy algorithm out of it because you can execute its inner loop lazily and it'll still get done
00:04:00 <newsham> mmm venti
00:04:13 <edwardk> lock-free algorithms also should work for all practical intents and purposes.
00:04:44 <edwardk> in this environment with one process (like this) those algorithms don't have to use atomic CAS, they can just use CAS, so no synchronization overhead
00:04:47 <newsham> why not use stm?
00:05:33 <Korollary> Take a look at Dryad
00:05:41 <mxc> @hoogle toChunks
00:05:42 <jsnx> newsham: is it on one machine only?
00:05:42 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
00:05:42 <lambdabot> Data.ByteString.Lazy.Char8.toChunks :: ByteString -> [ByteString]
00:05:44 <edwardk> STM is fine, but its and its usually built over atomic CAS. synchronizing with yourself can be done with just normal cas.
00:05:49 <edwardk> Korollary: I have quite a bit
00:05:53 <gwern> @pl λx → liftM (filter $ isInfixOf x) readHistoryIO
00:05:53 <lambdabot> (line 1, column 2):
00:05:53 <lambdabot> unexpected "\187"
00:05:53 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
00:05:58 <Korollary> If you just want to get something done, you can do it already. This is not people are complaining about.
00:06:03 <gwern> @pl \x -> liftM (filter $ isInfixOf x) readHistoryIO
00:06:03 <lambdabot> flip fmap readHistoryIO . filter . isInfixOf
00:07:05 <edwardk> newsham: and i can't use STM typically between a few hundred machines over the network =)
00:07:34 <edwardk> Korollary: dryad is fine as far as it goes for establishing pipelines of processes, but it tackles a different set of issues than i'm trying to go for here.
00:08:05 <edwardk> Mostly just looking for issues in a novel corner of the design space
00:08:38 <gwern> @pl do (hist,_) <- readHistory
00:08:38 <lambdabot> (line 1, column 9):
00:08:38 <lambdabot> unexpected ","
00:08:38 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
00:08:44 <edwardk> its really not all that novel i guess, but still =)
00:09:05 <gwern> @undo do (hist,_) <- readHistory; return $ map command_history hist
00:09:05 <lambdabot> readHistory >>= \ (hist, _) -> return $ map command_history hist
00:09:34 <edwardk> I think its mostly that the lock-free/distributed folks and the functional folks aren't usually on speaking terms
00:39:50 <edwardk> or because I'm a crackpot ;)
00:41:34 * ivanm passes edwardk a patch kit to cover up the cracks
00:41:43 <edwardk> ah thats what i was missing
00:45:15 <eu-prleu-peupeu> hello
00:45:36 <mxc> weird
00:45:36 <eu-prleu-peupeu> this guys at the yaht use a lot of point free programming style... is it any good ?
00:45:43 <mxc> yeah
00:45:44 <mxc> i like it
00:45:55 <eu-prleu-peupeu> i kind of prefer the normal style... its more verbose :/
00:46:03 <mxc> although, apparently, in ocaml it can interfere with some compiler opimizations
00:46:11 <mxc> not sure if thats the case in haskell
00:46:24 <mxc> question about ReaderT
00:46:25 <dolio> Nope.
00:46:47 <mxc> say I have a type: type OptReader  = ReaderT [OptionFlags] IO
00:47:03 <dmwit> eu-prleu-peupeu: If you think about your function as the composition of several other functions, write at is a composition (i.e. points-free).
00:47:06 <dmwit> Otherwise don't.
00:47:19 <sarehu_> in some sense plain old IO statements like (print 3 >> print 4) are in point free style
00:47:36 <mxc> then any function f :: OptReader () is should be the same type as f :: [OptionFlags] -> IO t right?
00:48:11 <sarehu_> mxc: no
00:48:17 <eu-prleu-peupeu> okey
00:48:26 <eu-prleu-peupeu> ill try to think of my functions that way
00:48:29 <mxc> oops, i meant -> IO ()
00:48:35 <sarehu_> sure
00:48:36 <eu-prleu-peupeu> yes, it makes sense then... thanks
00:48:37 <sarehu_> either way, no
00:48:43 <sarehu_> it's not the same 'type', but the implementation's the same
00:49:01 <mxc> getting this compilation error:
00:49:06 <mxc>     Couldn't match expected type `[OptionFlags] -> IO t'
00:49:06 <mxc>            against inferred type `OptRunner ()'
00:49:29 <dmwit> ?unmtl ReaderT [OptionFlags] IO
00:49:30 <lambdabot> err: `ReaderT [OptionFlags] IO' is not applied to enough arguments, giving `/\A. [OptionFlags] -> IO A'
00:49:34 <dmwit> ?unmtl ReaderT [OptionFlags] IO ()
00:49:34 <lambdabot> [OptionFlags] -> IO ()
00:49:50 <sarehu_> (ReaderT r m a) puts the function r -> m a inside a newtype wrapping
00:49:54 <mxc> @hoogle umntl
00:49:54 <lambdabot> No matches found
00:50:08 <sarehu_> unmtl is a lambdabot tool
00:50:23 <ivanm> how do I force a function to evaluate in ghc without printing its value so that I can read the trace output?
00:50:32 <dmwit> seq?
00:50:38 <dmwit> f x `seq` ()
00:50:47 <ivanm> OK, I'll try that
00:50:59 * ivanm tried let foo = seq bar, and it didn't work :s
00:51:16 <ivanm> probably because I only gave it one argument :s
00:51:30 <ivanm> thanks dmwit
00:51:52 <ivanm> hmmm... that gives me less trace output than it did when the normal output was mixed in with it :s
00:52:05 <dmwit> It only evaluates to the top-level constructor.
00:52:15 <dmwit> i.e. weak-head normal form
00:52:16 <ivanm> ahhh
00:52:26 <ivanm> OK, it's only generating the head of the list...
00:52:34 <dmwit> Why not actually :trace it?
00:52:36 <ivanm> any way I can force it to generate the entire list?
00:52:44 <dmwit> deepSeq
00:52:45 <ivanm> ummm..... cos I didn't know about :trace?
00:52:48 <dmwit> ?index deepSeq
00:52:48 <lambdabot> bzzt
00:52:50 <sarehu_> try   length (show (f x)) `seq` ()
00:53:07 <mxc> sarehu_ one more followup, in that case how could I call a OptRunner action from main?
00:53:07 <dmwit> Yep, or (f x == f x) `seq` ()
00:53:12 <ivanm> thanks sarehu_
00:53:26 <ivanm> dmwit: which of course only works if f x is in Eq :p
00:53:30 <ivanm> (which it is)
00:53:34 <ivanm> sarehu_++
00:53:45 <dmwit> Right, and the other one only works if f x is in Show.
00:53:48 <dmwit> Take your pick. =)
00:54:06 <ivanm> actually, I just did length (f x)
00:54:07 * dmwit actually has both in module Dmwit.
00:54:19 <sarehu> :t runReaderT
00:54:20 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
00:54:24 <ivanm> since it produces a list, but seq by itself only produces the head of the list
00:54:30 * mxc slaps self
00:54:32 <mxc> ty
00:54:45 <dmwit> ivanm: That will generate the spine, but not necessarily the values in the list.
00:54:55 <sarehu> yeah go with dmwit's
00:54:57 <ivanm> *nod*
00:54:58 <mxc> thanks
00:55:15 <sarehu> only not with (f x == f x) since you'll probably have each message doubled
00:55:16 <ivanm> sarehu: ummm, why? length (f x) worked!
00:55:24 <dmwit> join (==) (f x)
00:55:28 <ivanm> heh
00:56:43 <sarehu> yeah, it's hard for length (f x) not to work for most plain types
00:57:20 <sarehu> or length (show (f x)) even... but you might get a different order of traces with join (==)
00:58:01 <dmwit> join (==) should compare the elements in order, no?
00:58:26 <sarehu> maybe not the same order they get shown in
00:58:27 <ivanm> I would think so...
00:58:33 <dmwit> sarehu: Why not?
00:58:41 <sarehu> well if it's implemented so that it's not
00:58:49 <dmwit> Also (length (f x)) could easily fail.
00:59:02 <dmwit> Consider map f [1..5], where f is the one with Debug.Trace in it.
00:59:04 <edwardk> hrmm does anyone know of an ml variant with rank-2 polymorphism support?
00:59:17 <sarehu> oh, well i wasn't thinking that (f x) was a list, I was talking about (length (f x))
00:59:21 <sarehu> er, (show (f x))
00:59:47 <dmwit> hum
00:59:49 <dmwit> Well, anyway.
01:00:06 <ivanm> dammit, I've found a bug in the code I wrote over 12 months ago :@
01:02:14 <augur> :o
01:02:37 <augur> i just implemented the magic non-deterministic filter thingy in javascript and it gave me the powersets!
01:02:38 <augur> :o
01:02:41 <augur> <3
01:03:07 <dmwit> Yay! =)
01:03:19 <ski_> using list monad ?
01:03:28 <augur> uh.. in havascript? :P
01:03:38 <augur> javascript*
01:04:08 <ski_> or how did you implement the nondeterminism ?
01:04:22 <augur> well actually
01:04:36 <eu-prleu-peupeu> ivanm: was it haskell code ?
01:04:41 <augur> what i did was for the value [true,false]
01:04:43 <ski_> i don't recall javascript to have reifiable continuations
01:05:06 <augur> what i did was i just copied all the valid filters up to the current element being tested
01:05:26 <augur> in the copies i added the element being tested, and in the originals i didn't add them
01:05:36 <augur> then i merged the two sets into a new set of valid filters
01:05:40 <ivanm> eu-prleu-peupeu: yeah
01:05:46 <augur> half have the current item being tested, the other half dont
01:05:54 <ivanm> slight logic bug, which skipped a check because I thought it wasn't needed
01:06:12 <ski_> so what did you mean by "magic non-deterministic filter" ?
01:06:18 <Ivatar> ot
01:06:20 <Ivatar> gah
01:06:26 <augur> well, haskell's magic non-deterministic filter
01:06:26 <ivanm> and thus produced invalid results (not that many though... for the order 3 case, it produced 7 invalid out of 90 valid)
01:06:42 <ski_> @hoogle filterM
01:06:42 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
01:06:45 <ski_> that one ?
01:06:49 <augur> yeah
01:06:56 <augur> which i suppose is also non-deterministic in JavaScript as well, since it returns multiple equally valid filters, none of which are the _only_ filter
01:07:05 <augur> it takes multiple paths, so to speak
01:07:20 <augur> sort of like a non-deterministic parser simultaneously handling multiple parse paths
01:07:26 <ski_> `filterM' in this case uses the list monad
01:07:36 <augur> yeah well, thats magic in haskell ;p
01:07:45 <ski_> not in particular
01:07:49 <augur> js has to make do
01:07:59 <ski_> monadic reflection would be more "magic", i'd say
01:08:06 <augur> but im just happy that i understand the haskellian powerset thing
01:08:09 <augur> :)
01:08:42 <Cale> augur: did you see http://cale.yi.org/autoshare/filterM.png ?
01:08:49 <augur> my next task will be to implement real live functors in javascript! :O
01:09:01 <augur> every time i try to view it, cale, the server times out
01:09:04 <augur> but now it works
01:09:28 <Cale> augur: The problem before was that my IP did not match what cale.yi.org pointed at
01:09:34 <augur> oh i see :)
01:09:54 <augur> do you know how the interpreter handles such cases of nondeterminism?
01:10:37 <ski_> it's just lazy lists
01:11:03 <augur> well, i mean, somehow it has to know that when the predicate returns [True,False] it needs to branch
01:11:16 <augur> and then combine together the results of each branch
01:11:17 <Cale> augur: It's not magic at all.
01:11:25 <augur> monads are magic to me
01:11:31 <Cale> augur: It comes from the implementation of >>= for the list monad
01:11:39 <Cale> xs >>= f = concat (map f xs)
01:11:46 <augur> sure but the branching! :o
01:12:30 <augur> anyway, i'll never understand haskell, i can only grope at bits and pieces and try to hack together something in JS that i can understand thats roughly, but stuntedly, equivalent to the haskell version
01:13:04 <ski_> filterM (const [True,False]) [1,2,3]  =  const [True,False] 1 >>= \b -> if b then (1 :) `liftM` filterM (const [True,False]) [2,3] else filterM (const [True,False]) [2,3]
01:13:28 <Cale> and:  filterM p [] = []; filterM p (x:xs) = p x >>= (\b -> filterM p xs >>= (\ys -> [if b then (x:ys) else ys]))
01:13:37 <Cale> Or, to put that in do-notation
01:13:42 <augur> right but
01:13:50 <augur> b is true AND false!
01:13:53 <ski_>   =  ((1 :) `liftM` filterM (const [True,False]) [2,3]) ++ (filterM (const [True,False]) [2,3])
01:13:59 <augur> so the interpreter branches there?
01:14:05 <Cale> filterM p (x:xs) = do b <- p x; ys <- filterM p xs; return (if b then (x:ys) else ys)
01:14:19 <Cale> augur: it's a concatMap, remember
01:14:34 <augur> right but i mean
01:14:47 <augur> the if...else itself has to do _both_ paths
01:14:53 <Cale> > [1,2,3] >>= \x -> [x, 10*x]
01:14:54 <lambdabot>  [1,10,2,20,3,30]
01:15:08 <augur> thats not what im asking about :p
01:15:12 <Cale> > map (\x -> [x, 10*x]) [1,2,3]
01:15:13 <lambdabot>  [[1,10],[2,20],[3,30]]
01:15:17 <Cale> > concat (map (\x -> [x, 10*x]) [1,2,3])
01:15:18 <lambdabot>  [1,10,2,20,3,30]
01:15:34 <Cale> So the "branching" is handled by map (and concat)
01:15:41 <augur> i dont see how
01:15:50 <augur> i only see an if...else that gets [True,False]
01:16:03 <augur> oh!
01:16:04 <augur> no
01:16:05 <augur> i see
01:16:07 <augur> yes
01:16:09 <augur> hot
01:16:17 <Cale> You're mapping a function over the list [True,False]
01:16:24 <Cale> and then concatenating the results
01:16:34 <augur> oh you devilish haskellians!
01:16:37 <augur> you're DEVIOUS!
01:16:53 <ski_> it just tries both paths
01:17:16 <ski_> collecting up the lists of solutions from both paths with `concat' into a single list
01:17:17 <Cale> ski_: I think he understands that, he just wants to know how it works.
01:17:27 <augur> now i see
01:17:39 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
01:17:40 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
01:17:44 <augur> const [True,False] 1 == [True,False]
01:17:55 <Cale> yep
01:17:58 <augur> which gets mapped by the right hand side of >>=
01:18:04 <augur> oh thats EVIL
01:18:04 <augur> :o
01:18:10 <Cale> [True,False] >>= \b -> ...
01:18:21 <Cale> which is the same as  concat (map (\b -> ...))
01:18:23 <augur> that is reeeeaaaally sexy
01:18:30 <Cale> er..
01:18:34 <Cale> which is the same as  concat (map (\b -> ...) [True, False])
01:18:42 <augur> yeah :P
01:18:44 <augur> oh man
01:18:48 <augur> thats hot
01:18:55 <Cale> Yeah, so there's no real magic.
01:18:59 <augur> i know
01:19:05 <augur> which IS the real magic! :o
01:19:12 <Cale> heh, I suppose yeah :)
01:19:27 <augur> whats the code for List >>= again?
01:19:29 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
01:19:30 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
01:19:37 <ski_> @src [] >>=
01:19:37 <lambdabot> Source not found. You type like i drive.
01:19:40 <ski_> @src [] (>>=)
01:19:41 <lambdabot> xs >>= f     = concatMap f xs
01:19:47 <ski_> heh
01:19:52 <ski_> @src concatMap
01:19:52 <lambdabot> concatMap f = foldr ((++) . f) []
01:19:56 <augur> its so simple
01:19:58 <augur> :o
01:20:00 <Cale> heh
01:20:18 <Cale> concatMap f xs = concat (map f xs) -- probably the more useful equation :)
01:20:23 <ski_> where's me simple direct recurtsive `concatMap', when i ask for it ?
01:20:45 <Cale> @src foldr
01:20:45 <lambdabot> foldr f z []     = z
01:20:45 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:20:53 <Cale> ski_: there it is ;)
01:21:13 <augur> @src [] filterM
01:21:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:21:17 <augur> :(
01:21:19 <Cale> @src filterM
01:21:19 <lambdabot> Source not found.
01:21:22 <Cale> huh
01:21:30 <ski_> @source Control.Monad
01:21:30 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
01:21:31 <Cale> filterM p [] = return []
01:21:56 <Cale> filterM p (x:xs) = do b <- p x; ys <- filterM p xs; return (if b then (x:ys) else ys)
01:22:38 <augur> er
01:22:43 <augur> is there a bind notation instead of do?
01:22:49 <Cale> sure
01:22:54 <Cale> @undo do b <- p x; ys <- filterM p xs; return (if b then (x:ys) else ys)
01:22:54 <lambdabot> p x >>= \ b -> filterM p xs >>= \ ys -> return (if b then (x : ys) else ys)
01:23:12 <Cale> and for the list monad,  return x = [x]
01:23:12 <augur> much easier to read
01:23:24 <Cale> Really?
01:23:30 <augur> yeah man
01:23:37 <augur> spaceships!
01:23:38 <augur> er
01:23:40 <augur> stations
01:23:54 <Cale> I find the do-notation easier to read, actually.  You think of  b <- p x  as selecting b from the list of choices p x
01:24:12 <augur> maybe. ill try to get used to it
01:24:17 <augur> for you :p
01:24:30 <Cale> and then  ys <- filterM p xs  selects  ys  from the list of choices produced by filterM p xs
01:24:57 <augur> is it (p x >>= \b -> filterM p xs) >>= ...
01:24:58 <koninkje> and of course the do notation on lists converts trivially to list comprehensions
01:25:05 <HunterXHunter> is haskell related to paskell (pascal)?
01:25:11 <Cale> HunterXHunter: no
01:25:20 <Cale> It's not related to Pascal.
01:25:20 <augur> or p x >>= \b -> (filterM p xs >>= ...)
01:25:21 <augur> ?
01:25:33 <astrolabe> Unless you count '>' as a relation ;)
01:25:35 <HunterXHunter> im am playing around :P
01:25:39 <Cale> Apart from the fact that they're both programming languages, they could not be more different.
01:26:09 <Cale> augur: lambdas extend as far to the right as possible
01:26:28 <augur> ok
01:26:31 <augur> so the latter
01:26:34 <Cale> yeah
01:27:13 <ski_> augur : btw, i assume you've seen prolog ?
01:27:15 <augur> oh that makes so much sense
01:27:18 <augur> yeah i have
01:27:31 <augur> i could implement a janky prolog in JS XD
01:27:39 <ski_> "janky" ?
01:27:45 <augur> well
01:27:48 <augur> its not real prolog
01:27:54 <augur> its a sketchy pseudoprolog
01:28:01 <augur> actually i tried to model MQL
01:28:08 <augur> which is very prologish
01:28:38 <solrize> does chris smith ever come here?  his website is gone
01:28:49 <augur> oh man
01:28:54 <augur> i need to get to bed but tomorrow...
01:28:55 <augur> :D
01:29:03 <ski_> "Molecular Query Language" ?
01:29:09 <augur> metaweb*
01:29:15 <Cale> solrize: I think I've seen a cdsmith, if I'm not mistaken.
01:29:16 <HunterXHunter> monad query language !
01:29:28 <augur> comonad coquery colanguage
01:29:36 <Cale> http://cdsmith.wordpress.com/
01:29:36 <solrize> @seen cdsmith
01:29:36 <lambdabot> I haven't seen cdsmith.
01:29:37 <lambdabot> Title: Sententia cdsmithus
01:29:39 <HunterXHunter> CCCP
01:29:41 <augur> its basically a way of searching through a schema-less DB
01:29:45 <Cale> yes, indeed I have :)
01:29:51 <ski_> HunterXHunter : `P' ?
01:30:01 <HunterXHunter> P = republik :P
01:30:02 <augur> its really cool, ski_
01:30:09 <augur> you can do crazy searches for stuff like
01:30:12 <ski_> which ?
01:30:30 <augur> MQL
01:30:54 <ski_> is it treating molecular composition as a logic ?
01:31:08 <augur> metaweb query language not molecular :p
01:31:26 <ski_> oh
01:31:40 <augur> "all female CEO's who work at companies within their HQs 5 miles of shipping centers that have other branches near a major airport in idaho"
01:31:54 <augur> or any arbitrarily deep and absurd query like that
01:32:12 <augur> s/within/with
01:32:26 <augur> s/of/from
01:32:26 <augur> :P
01:32:56 <augur> its all prolog-ish logic on a database
01:33:01 <augur> and its cool
01:33:40 <augur> anyway
01:33:41 <augur> i need sleep
01:33:42 <augur> night guys
01:33:44 <augur> thanks
01:33:45 <augur> :D
01:33:52 <ski_> deductive database ?
01:34:51 <ski_> augur : you need to continue your #chomskyan-intro lecture sometime ..
01:39:16 <augur> ey?
01:39:25 <augur> i had such a thing?
01:40:19 <augur> do you mean
01:40:22 <augur> #intro-func
01:40:26 <augur> or whatever it was?
01:40:46 <augur> or did i do something else.. hm.
01:40:47 <ski_> you appear to have the same domain name now
01:41:06 <augur> its entirely possible i did such a thing and dont remember ;)
01:41:15 <augur> im gettin old! i'm 22!
01:41:17 <augur> get off my lawn!
01:41:40 <augur> oh i did.. lookit that
01:41:46 <ski_> about 21 May, my log tells me
01:42:27 <augur> ok yeah
01:42:37 <ski_> you were trying to explain the basics of chomskian grammar stuff
01:42:46 <augur> yeah
01:42:48 <augur> of minimalism
01:42:57 <augur> sure, remind me tomorrow :)
01:43:00 <augur> night :D
01:45:45 <Lemmih> Are there any working dbus bindings? I can't get DBus or hdbus to compile.
01:47:14 <Lemmih> Hm, they might be one and the same.
01:50:20 <dolio> Where's consultant_barbie in the "Math Notation is Terrible" story on reddit?
01:51:48 <augur[sleep]> ok i have to tell you guys before i go to sleep, i've just had an idea for a parody of the awesomeness that is haskell as the most brilliantly cool way of doing anything you could ever want to do in a programming language
01:52:22 <augur[sleep]> sort of along the lines of "haskell can do everything, only better, and you dont even have to write hardly any code!"
01:53:14 <augur[sleep]> so its simon peyton jones giving an intro talk on haskell, explaining pattern matching, and someone in the audience points out that something should be slightly different in the ordering of the pattern
01:53:44 <augur[sleep]> and spj says, "ohh goodness you're right", points his laser pointer at the one line, and moves it up where it should be as if by magic
01:53:59 <augur[sleep]> someone in the audiences asks "Whered you get that pointer pen?!"
01:55:02 <augur[sleep]> spj responds, "oh, i just asked my haskell prompt, and it build it for me! when you get good with haskell you can start to just ask it to solve your problems for you and it produces the right program"
01:55:36 <augur[sleep]> "and when you get really good, and become a master haskell user, you'll develop a symbiotic relationship with haskell where it produces the program you need before you even know you need it!"
01:55:44 <augur[sleep]> someone asks, "my goodness! how does that work?!"
01:55:57 <dolio> This had better not be building up to a pun.
01:55:58 <augur[sleep]> spj: "oh it's easy, you just use the Telepethy monad"
01:56:13 <augur[sleep]> night ::runs::
01:56:23 <augur[sleep]> :X
01:57:32 <augur[sleep]> i think we should actually get actual simon peyton-jones to act it out
01:57:37 <augur[sleep]> ok seriously goodnight
02:04:40 <dmwit> augur-- most anticlimactic ending everrrr
02:05:00 <dolio> @karma augur
02:05:00 <lambdabot> augur has a karma of -1
02:05:05 <dolio> Oh snap!
02:05:53 <dmwit> Though I guess an auger is a bore. ;-)
02:06:11 <dolio> Now that was a pun.
02:10:41 <Saizan> http://xkcd.com/410/
02:10:41 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:11:05 * dolio needs to renew his math license.
02:19:57 <solrize> @seen cdsmithus
02:19:57 <lambdabot> I saw cdsmithus leaving #haskell 7h 53m 27s ago, and .
02:20:01 <solrize> aha
02:20:28 <solrize> @tell cdsmithus hi i managed to find your new web site but osdesign.html is gone?
02:20:28 <lambdabot> Consider it noted.
02:52:39 <RayNbow> hmm, reddit users don't like my submissions :p
02:53:23 <EvilTerran> rddit users hate everything. including freedom and piles of kittens.
02:53:39 <RayNbow> do they even hate lambda kittens?
02:56:36 <ilyak> By the way?
02:57:01 <ilyak> Which characters are considered operator chars, and which aren't?
02:57:07 <ilyak> ' and _ are not, which else?
02:57:39 <dolio> letters and numbers aren't.
02:57:57 <dolio> ' and _ are the notable exceptions.
02:58:13 <RayNbow> http://www.haskell.org/onlinereport/syntax-iso.html
02:58:13 <lambdabot> Title: Haskell 98 Syntax
02:58:27 <RayNbow> look for the ascSymbol production
02:59:30 <dmwit> > let a +"+ b = a ++ b in "hey " +"+ "there"
02:59:30 <lambdabot>  Parse error at end of input
02:59:33 <RayNbow> http://www.haskell.org/onlinereport/lexemes.html#sect2.4 <-- reserved operators are here
02:59:34 <lambdabot> Title: Haskell 98 Lexical Structure
02:59:46 <dmwit> I guess " probably isn't.
03:00:33 <dmwit> > let d +: b = d :+ b in 1 +: 2
03:00:37 <lambdabot>  1.0 :+ 2.0
03:00:48 <ilyak> Can one have unicode identifiers?
03:00:58 <dmwit> According to the standard, yes.
03:01:03 <dmwit> Up until GHC 6.9, no.
03:01:04 <ilyak> I wonder if one can make a (peace symbol) operator
03:01:10 <ilyak> That would be cool.
03:01:28 <ilyak> Because, as far as I see, haskell suffers from namespace depletion
03:02:51 <RayNbow> however, how does one input unicode characters?
03:03:03 <dmwit> UTF-8?
03:03:09 <RayNbow> that's the encoding :p
03:03:14 <dmwit> Or did you mean how do you type them on the keyboard?
03:03:17 <wjt> SCIM's LaTeX table, and <compose> sequences!
03:03:18 <RayNbow> yeah :p
03:03:31 <dmwit> copy-paste from a handy document ;-)
03:03:32 <Saizan> or tex mode for emacs
03:03:32 <RayNbow> and no, I'm not going to memorize character codes :p
03:03:49 <RayNbow> Saizan: I'm not an emacs user unfortunately :p
03:03:57 <dmwit> XIM, then?
03:03:59 * RayNbow wonders if someone made a Math IME or something
03:04:31 <dolio> scim is all right.
03:04:35 <Saizan> however i've found that it's quite slow to use latex names for symbols..
03:04:42 <dolio> Although it makes things crash a lot more often, in my experience.
03:04:44 <RayNbow> the Windows' Japanese IME works nice, I wouldn't mind having an IME for math and other symbols
03:04:46 <ilyak> That syntax-iso is all greek to me
03:05:02 <ilyak> I mean, it looks impressive but I can't extract any facts from it
03:05:47 <dolio> And, yeah, using latex names is often a pain. I usually end up defining new sequences for stuff I use frequently in Agda.
03:05:48 * maltem always uses those Unicode-identifier debates to vote for full-blown math syntax for Haskell! Subscript, superscript, sidescript, bars and arrows, matrices, ...
03:06:22 <dmwit> sidescript?
03:06:25 <dolio> I've been typing \triangleright a lot lately.
03:06:39 <dmwit> \newcommand
03:06:40 <maltem> (You just have to agree what signs are operators and what signs are parts of names)
03:06:44 <dmwit> Learn it, love it. =)
03:07:12 * RayNbow also loves \renewcommand in LaTeX :p
03:07:17 <maltem> dmwit: Hm, I was thinking of the multiple positions they use around symbols of chemical elements
03:07:42 <dmwit> RayNbow: Well, yeah, whichever one works.  I think it's kind of dumb that they work in mutually exclusive situations and yet weren't merged.
03:07:54 <RayNbow> {}^{side}_{script}symbol?
03:08:02 <maltem> like, {}_1^2 X_3^4
03:08:11 <dmwit> maltem: Ah, you mean, like, on top and bottom?
03:08:12 <maltem> RayNbow, right
03:08:18 <maltem> right
03:08:22 <dolio> Unicode seems to lack a lot of sub/superscript stuff. At least if the emacs unicode input is any indication.
03:08:25 <dmwit> Oh, on the left side.
03:09:00 <Baughn> So, is 4² 4^2 r 4**2?
03:09:01 <maltem> dolio: well Unicode is for symbols, not so much for placement
03:09:10 <dmwit> Baughn: In TeX, or what?
03:09:14 <Baughn> dmwit: In haskell
03:09:20 <dmwit> Baughn: mu
03:09:49 <dmwit> (^), (**), (^^) each exist for different purposes.
03:09:53 <dmwit> This should not be news.
03:09:54 <maltem> Baughn: now that's a subject for meditation
03:10:07 <Baughn> @type (^^)
03:10:21 <dolio> Yeah, but you have to pick which one you want to not be ugly. :)
03:10:22 <lambdabot> thread killed
03:10:27 <Baughn> lambdabot:
03:10:29 <Baughn> @type (^^)
03:10:31 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
03:10:48 <dmwit> > (3%8) ^^ 5 -- potentially exactly correct
03:10:48 <Baughn> Hm. They all have different types, though - why not a typeclass?
03:10:49 <lambdabot>  243%32768
03:11:01 <dmwit> Baughn: They behave differently.
03:11:13 <dmwit> :t (**)
03:11:14 <lambdabot> forall a. (Floating a) => a -> a -> a
03:11:19 <Baughn> dmwit: And?
03:11:32 <maltem> > 2 ^ (-2)
03:11:34 <lambdabot>  Exception: Prelude.^: negative exponent
03:11:34 <dmwit> Baughn: ...and each of the behaviors is desirable in some cases?
03:11:41 <dolio> Type class for what?
03:11:57 <dmwit> Yeah, I'm a bit confused.
03:12:01 <maltem> Baughn: You'd need a Natural type to forbid the above
03:12:34 <Baughn> Superscript. I don't know. It just seems a bit odd that a simple mathematical operation *has* to involve three different functions
03:12:34 <maltem> Baughn: On the other hand, if you rely on type annotations...
03:12:52 <Baughn> None of which works with complex numbers
03:13:07 <dmwit> Baughn: It's weird because computers' representations of numbers are so weird.
03:13:15 <dmwit> > (3 :+ 8) ^^ 2
03:13:17 <lambdabot>  (-55.0) :+ 48.0
03:13:25 <dmwit> Baughn: What's that about complex numbers?
03:13:30 <mapreduce> And that's what we call abstraction, ladies and gentlemen.
03:14:17 <dmwit> Or did you mean in the exponent?
03:15:11 <Baughn> The exponent?
03:15:17 <maltem> (Actually, you might want literal exponantiation to support iterated function application, too...)
03:15:40 <opqdonut> mhmm
03:16:22 <zx]treads> what is the difference between ^ and ^^ ?
03:16:23 <opqdonut> we should have choosable instances and (^) :: Monoid a -> a -> Integer -> a
03:16:39 <opqdonut> and it would handle iterated function application too
03:17:11 <maltem> zx]treads: ^^ allows a negative exponents (and thus, a fractional result)
03:19:07 <zx]treads> 3 ^^ (-2)
03:19:09 <maltem> opqdonut, monoid is a funny idea. however, we would then have (Sum 5)^2 vs. (Product 5)^2 ?
03:19:26 <zx]treads> ok understood
03:19:45 <mapreduce> What's the importance of the identity and composition constraints on a Functor?
03:20:00 <mxc> not that anyone else should care, but I finally get monad transformers.. time to transition from exclusively learning to 90% learning, 10% getting sh1t done
03:20:04 <mxc> woohoo, champagne time
03:20:16 <mxc> drinks on me if any of you are in singpore
03:20:18 <ilyak> By the way, I wanted to ask
03:20:18 <mxc> singapore
03:20:35 <mxc> again, thanks to everyone in this channel, this community is really incredible
03:20:51 <ilyak> How is the problem that a lot of standard functions call error is solved in big programs that shouldn't really fail?
03:21:12 <ilyak> s/either one of 'is'//
03:21:30 <Saizan> mapreduce: well because those are the principal properties of a category
03:21:32 <mapreduce> ilyak: Only the second should be removed.
03:21:45 <ilyak> mapreduce: I'll trust you.
03:21:48 <mapreduce> Saizan: Ah, finally a straight answer.  Thanks :)
03:21:52 <Baughn> ilyak: Check the preconditions before calling them?
03:22:08 <RayNbow> mxc: Singapore is far away... like 12 hours by plane or something like that :p
03:22:43 <ilyak> Baughn: Are there any more generic ways which are widely used?
03:22:44 <mapreduce> ilyak: Presumably you could wrap them all up in things that return Maybes or Eithers, but I think you'd be adding error handling for errors that a) can never happen b) can't be usefully dealt with.
03:22:53 <maltem> mapreduce: Those properties are intrinsic of a functor, so if a Functor instance does not obey them, that Functor is not a functor :)
03:23:11 <mapreduce> maltem: That's a non-straight answer.  Circular reasoning.
03:23:18 <ilyak> mapreduce: Well, how would you wrap them, with catch?
03:23:34 <ilyak> I want to know how people do that actually, not how it could be done
03:23:42 <ilyak> Do in, say, darcs or xmonad
03:23:48 <Baughn> ilyak: There's always the option of writing wrappers that throw dynamic exceptions, but then you have the problem of doing something reasonable to recover
03:23:50 <mapreduce> ilyak: if (precondition) then Just (f x) else None
03:24:02 <Baughn> *Nothing
03:24:10 <mapreduce> ETOO_MUCH_SCALA
03:24:49 <ilyak> Well, so I think they should insteat have type something -> m a instead of something -> a and error'ing
03:25:06 <maltem> mapreduce: Not circular, but not very helpful either, because I just made the connection between functors and the Functor type class
03:25:08 <ilyak> and identity monad should be introduced into core library
03:25:20 <ilyak> Which will have fail s = error s
03:25:33 <mapreduce> ilyak: Except then you have to use a Maybe when you *know* it will never be Nothing.
03:25:52 <ilyak> mapreduce: Well, use Identity then
03:25:53 <mapreduce> @hoogle head
03:25:53 <lambdabot> Prelude.head :: [a] -> a
03:25:53 <lambdabot> Data.List.head :: [a] -> a
03:25:53 <lambdabot> Data.ByteString.head :: ByteString -> Word8
03:26:03 <mapreduce> ilyak: I don't know Identity.
03:26:11 <Baughn> ilyak: Checking preconditions too often /will/ kill performance. At some point you have to trust your own code
03:26:11 <ilyak> Tho I still don't know how it would be the best way to unwrap Identity
03:26:16 <mapreduce> @quote posh
03:26:16 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
03:26:17 <ilyak> It shouldn't be noisy
03:26:19 <mapreduce> ^^that's me
03:26:24 <maltem> ilyak: Actually, fail should be moved out of Monad, but that's another topic again
03:26:31 <ilyak> maltem: Where?
03:27:05 <maltem> ilyak: Where what?
03:27:06 <mapreduce> ilyak: Consider head [].  You know it will fail so you never call it on an empty list.
03:27:14 <ilyak> mapreduce: Where should it be moved to?
03:27:22 <ilyak> maltem: I mean
03:27:29 <mapreduce> ilyak: It would be better(tm) if head took a NonEmptyList, but that would be inconvenient.
03:27:50 <maltem> ilyak: class MonadFail where fail msg ... -- I guess
03:28:10 <ilyak> maltem: How would that be better?
03:28:21 <dmwit> No, you want it in class MonadZero.
03:28:29 <ilyak> mapreduce: http://www.haskell.org/all_about_monads/html/identitymonad.html
03:28:30 <lambdabot> Title: The Identity monad
03:28:34 <mapreduce> ilyak: If you had typing such that you could statically guarantee success then there'd be no need for 'error' in those functions.
03:28:37 <ilyak> But, this one is *very* noisy
03:28:40 <dmwit> There used to be separate MonadZero and MonadPlus classes.
03:28:49 <ilyak> We should make it as less noisy as possible
03:29:03 <maltem> ilyak: It wouldn't impose a fail operation on any Monad, considering that the mathematical definition of a monad doesn't know anything about fail
03:29:18 <ilyak> mapreduce: Well, if you guarantee there would be no error, make fail = error
03:29:26 <maltem> ilyak: Which means that fail does not make sense for every monad
03:29:36 <Saizan> ilyak: what are you trying to buy from using the identity monad everywhere?
03:29:53 <ilyak> maltem: Well, any monad should know about fail because it will make using a lot of functions which can fail possible with this monad
03:30:00 <ilyak> like Map.lookup
03:30:05 <maltem> ilyak: And fail = error is cheating, because that's like instance Num Natural where negate = undefined
03:30:08 <mapreduce> ilyak: You're adding code to deal with 'errors' that can't/shouldn't happen.
03:30:09 <ilyak> you can lookup into any monad
03:30:40 <ilyak> mapreduce: Well, they can anyway, because there are infinite possible functions for this monad which can fail
03:30:43 <mapreduce> ilyak: He who calls head is responsible for making sure it's not empty.  If you don't like that, write and use headMaybe.
03:30:58 <dmwit> ?quote sprynge
03:30:58 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
03:31:07 <maltem> ilyak: You would have MonadZero instead of Monad, then.
03:31:13 <opqdonut> maltem: that's why i said "choosable instances"
03:31:19 <ilyak> maltem: Why?
03:31:25 <opqdonut> tho it's not clear how those would be best implemented
03:31:34 <Saizan> i don't get how erroring in any monad gets you anything, unless that monad has a sensibile representation of errors..
03:32:13 <maltem> opqdonut: Ah, I didn't realize "choosable instances" was a concept
03:32:20 <ilyak> Saizan: Well, it either have one, or errors
03:32:39 <maltem> ilyak: Well if fail is in MonadZero instead of Monad, then you need a MonadZero constraint on lookup
03:33:11 <ilyak> maltem: Yeah, maybe
03:33:29 <dabd> hi all
03:33:38 <ilyak> I can't really name a monad which shouldn't be MonadZero
03:33:45 <dabd> what is the most popular haskell ide/editor
03:33:51 <ilyak> dabd: vim?
03:33:55 <Baughn> dabd: ed
03:34:09 <mapreduce> dabd: #haskell
03:34:35 <dabd> anyone using emacs and haskell-mode ?
03:34:36 <opqdonut> maltem: yeah, Ord and Monoid are the prime examples
03:35:01 <ilyak> I like how four standard monads implement all the useful error handling strategies.
03:35:06 <ilyak> I think this is a way to go
03:36:02 <maltem> opqdonut: ah I see, on a certain type, different orderings and different monoids exist
03:36:18 <maltem> s/different/several/g
03:37:08 <Saizan> ilyak: Identity? State? Reader? Writer?
03:37:41 <Saizan> i mean, the ones i just listed can't sensibly be MonadZero
03:37:47 <opqdonut> maltem: yeah
03:38:06 <ilyak> Saizan: Identity, IO, Maybe, []
03:38:35 <ilyak> If identity can't be MonadZero then we want fail in Monad
03:38:37 <Saizan> ilyak: crashing your program doesn't seem a "useful error handling strategy"
03:38:50 <ilyak> Saizan: Well, why, it's recognised
03:39:00 <ilyak> It's called "fail early"
03:40:29 <maltem> ilyak: Better fail at compile time than at run-time, even if early
03:40:41 <Saizan> it doesn't give the caller of the function the opportunity to react to the error, just printing "Prelude.head: empty list" is not even a sensibile error message
03:41:08 <ilyak> Saizan: Well, if caller should react then it shouldn't be in Identity monad
03:41:17 <ilyak> It should be inside Maybe or [] monad
03:41:33 <maltem> ilyak: "This type does not support fail" is better than "Error: Failed!"
03:41:46 <Saizan> and yeah, if functions that can fail carry a MonadZero contraint you have more guarantees at the type level
03:41:46 <ilyak> maltem: Well, what if it should?
03:41:58 <ilyak> It doesn't support, but it should because it would be convenient
03:42:57 <ilyak> Any function that have a return type and does error under some consequences should really return m a and use fail
03:43:03 <ilyak> I think.
03:43:21 <ilyak> Just stick it into identity monad if you want error
03:43:31 <maltem> ilyak: Unrecoverable errors are not really convenient. They break the function abstraction, and they feel like a segmentation fault when encountered
03:44:23 <maltem> ilyak: The other point is that the word "monad" does not mean "may fail"
03:45:02 <ilyak> Well, unrecoverable errors are very useful with erlang-style message passing
03:45:10 <ilyak> when they kill only the current LWP
03:45:20 <ilyak> with appropriate crash message
03:46:10 <UtopiahGHML> hi #haskell
03:46:33 <maltem> right, but in Haskell they kill the whole process immediately
03:46:58 <dibblego> Soliah, yes?
03:47:21 <Soliah> Could we talk in the #scala? :)
03:47:30 <dibblego> Soliah, sure
03:47:48 <ilyak> maltem: Well, that's another thing we should fix
03:50:07 <maltem> ilyak: Of course, if you change the semantics of an "unrecoverable error", making it less unrecoverable, ...
03:57:14 <lilachaze> i want a monad like WriterT [a], where the a's are added to the list as soon as they're produced (ie, in nondeterministic order). is this possible? (if so, how?)
03:57:45 <ilyak> maltem: Modern language can't have unrecoverable error
03:57:47 <ilyak> Just can't.
03:57:58 <ilyak> It can be 'unrecoverable by default', tho
03:58:10 <xerox> lilachaze: that's the default behaviour of writer, you tell out, and it logs, lazily
03:58:19 <lilachaze> xerox: no...
03:58:36 <opqdonut> you want something like putting Debug.trace in your code?
03:58:41 <lilachaze> xerox: the default behaviour produces the list in the order implied by the >>= operators
03:58:47 <lilachaze> opqdonut: exactly.
03:58:58 <opqdonut> lilachaze: you can't have anything else than the >>=-enforced version
03:58:59 <opqdonut> it's a monad
03:59:10 <Philippa_> lilachaze: that's also "as soon as they're produced"
03:59:19 <Philippa_> because that's what >>= /means/
03:59:23 <opqdonut> yeah
03:59:29 <lilachaze> opqdonut: i could make it work by using unsafePerformIO, but i'd rather keep the production and consumption separate
03:59:31 <opqdonut> but i think he wants evaluation order
03:59:47 <Philippa_> which does require unsafePerformIO where the monad doesn't fix it
04:00:37 <opqdonut> mhmm
04:00:48 <opqdonut> lilachaze: why do you want that anyway?
04:01:11 <lilachaze> opqdonut: for a compiler. i issue diagnostic messages, and i want them to appear as soon as they can.
04:01:33 <lilachaze> opqdonut: for instance, i have a preprocessing step of type Char -> WithDiagnostics Char
04:01:45 <lilachaze> opqdonut: sorry, [Char] -> WithDiagnostics [Char]
04:02:00 <Philippa_> you can demand any errors first and the Char itself second
04:02:08 <lilachaze> Philippa_: massive space leak?
04:03:07 <Philippa_> I wouldn't have thought so, so long as it's one immediately after the other
04:06:23 <lilachaze> I'm also not sure on how I'd use the result of such a thing anyway. Ultimately, I'm going to be performing two IO operations: writing the diagnostics and writing the program output.
04:07:39 <lilachaze> If I write the diagnostics first, I'll presumably get quite a large space leak as lots of thunks get left behind. If I write the program output first, then I don't get my "as soon as possible" diagnostics. If I interleave them, I get an arbitrary mix of the two previous behaviours.
04:08:48 <lilachaze> I think I need my preprocessing step to be [Char] -> [WithDiagnostics Char], and I need to make WithDiagnostics strict
04:09:21 <lilachaze> Then asking for the diagnostics should presumably perform my compilation, leaving no thunks behind. Does that sound about right?
04:18:26 <maltem> lilachaze: Isn't one thread for each output channel an option?
04:21:55 <lilachaze> maltem: yes, and that's what I'm doing now. but i'm concerned that if one thread gets ahead of the other one, i'll get a space leak
04:22:18 <lilachaze> @hoogle (Monad m) => a -> m [a] -> m [a]
04:22:19 <lambdabot> No matches, try a more general search
04:22:21 <maltem> ah ok
04:24:46 <lilachaze> @djinn (Monad m) => (a -> m b -> m c) -> m a -> m b -> m c
04:24:59 <lilachaze> @hoogle (Monad m) => (a -> m b -> m c) -> m a -> m b -> m c
04:24:59 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
04:25:00 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
04:25:00 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:28:59 <lilachaze> > foldlM (:) 'x' (Just "foo")
04:28:59 <lambdabot>   Not in scope: `foldlM'
04:32:21 <EvilTerran> > foldM (:) 'x' (Just "foo") -- is this what you meant?
04:32:21 <lambdabot>  Couldn't match expected type `[[Char]]'
04:32:58 <EvilTerran> ?type fmap . (:)
04:32:59 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
04:33:15 <EvilTerran> > (fmap . (:)) 1 (Just [2,3,4])
04:33:16 <lambdabot>  Just [1,2,3,4]
04:33:21 <EvilTerran> > (fmap . (:)) 1 Nothing
04:33:22 <lambdabot>  Nothing
04:34:01 <EvilTerran> un-pointsfreeing that, you'd get "fmap (1:) (Just [2,3,4])" or whatever
04:37:03 <ilyak> Why ,s are messed up in /topic?
04:37:13 <ilyak> They should be after space not before
04:37:31 <ilyak> oh, before not after
04:37:40 * ilyak shakes his head
04:45:24 <lilachaze> EvilTerran: what i want is:  a <<: b = return.(a:) =<< b
04:46:08 <wjt> lilachaze: (a:) `fmap` b
04:46:43 <lilachaze> > let a <<: b = return.(a:) =<< b in map (uncurry (<<:)) [('a', Just "foo"), ('b', Nothing)]
04:46:44 <lambdabot>  [Just "afoo",Nothing]
04:48:25 <lilachaze> wjt: thanks, perfect
04:48:44 <wjt> so I guess (<<:)
04:49:37 <wjt> so I guess (<<:) = fmap . (:)
04:57:24 <caw> quit
05:08:31 <lilachaze> @type (unwrapMonad .) . (. WrapMonad) . fmap . (:)
05:08:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m [a] -> m [a]
05:09:25 <lilachaze> @pl \a b -> return.(a:) =<< b
05:09:25 <lambdabot> fmap . (:)
05:09:48 <lilachaze> has lambdabot got a non-standard fmap?
05:10:17 <lilachaze> or an instance Monad m => Functor m perhaps?
05:17:12 <lilachaze> @type liftM . (:)
05:17:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m [a] -> m [a]
05:18:02 <wjt> lambdabot has a non-standard .
05:18:06 <wjt> @type (.)
05:18:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:19:48 <lilachaze> @type fmap.(:)
05:19:52 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
05:22:16 <wjt> @type fmap Prelude.. (:)
05:22:18 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
05:32:25 <augustss__> @seen conal
05:32:25 <lambdabot> I saw conal leaving #haskell and #ghc 9m 30s ago, and .
05:54:47 <audreyt> @pl \cs -> satisfy (\c -> elem c cs)
05:54:48 <lambdabot> satisfy . flip elem
06:02:38 <lilachaze> What does "illegal polymorphic or qualified type" mean?
06:03:12 <lilachaze> I get that message from: type RunCompiler a = forall st . ((Diagnostic, st) -> st) -> st -> (st, a)
06:07:25 <mjk> i want to export Text.Regex function to dll file, can't export, why
06:07:46 <mjk> the platform is win32
06:08:17 <dcoutts> mjk: you can use ffi export and then build your library into a dll
06:08:26 <dcoutts> but it's not very easy to do the latter
06:08:37 <mjk> yes
06:10:01 <mjk> i write some code in .hs file, and use ghc to compile it, when don't use import Text.Regex.Base, can export the function to dll file
06:10:09 <cinimod> @seen dons
06:10:09 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 10h 16m 27s ago.
06:10:56 <dcoutts> mjk: see http://www.haskell.org/ghc/docs/latest/html/users_guide/win32-dlls.html
06:10:57 <lambdabot> Title: 12.6. Building and using Win32 DLLs, http://tinyurl.com/yhf3e2
06:11:21 <mjk> but if i export the function, it includes =~ , the function can't exported
06:13:08 <dcoutts> mjk: you can only export functions with simple types (and returning in IO I think)
06:13:29 <dcoutts> so that means no type class contexts
06:13:47 <dcoutts> only monomorphic functions with primitive FFI types
06:13:50 <mjk> dcoutts: yes
06:16:13 <mjk> module First where
06:16:24 <mjk> import Text.Regex.posix
06:16:32 <mjk> import Text.Regex.Base
06:16:55 <mjk> regExpress :: String -> String -> [(Int, Int)[
06:17:05 <mjk> regExpress a b =
06:17:37 <mjk> return (a =~ b :: [(MatchOffset, MatchLength)])
06:18:20 <mjk> foreign export stdcall regExpress :: String -> String ->([Int, Int)]
06:19:24 <mjk> the description on http://tinyurl.com/yhf3e2 can't resolve this problem
06:19:25 <lambdabot> Title: 12.6. Building and using Win32 DLLs
06:20:23 <mjk> lambdabot: thx, if no "import Text.Regex.Posix", can't export the base type, like Int
06:20:40 <mjk> if no "import Text.Regex.Posix", can export the base type, like Int
06:21:27 <dcoutts> mjk: right so you cannot FFI export types like String and [(Int, Int)]
06:21:31 <dcoutts> they're not primitive
06:21:42 <dcoutts> they have no simple corresponding C types
06:21:59 <dcoutts> you'd have to map that to things like char * for String
06:22:05 <dcoutts> and an array of ints
06:22:20 <dcoutts> see an FFI tutorial on how to do that kind of marshaling
06:24:20 <mjk> when create dll file, it raises the error:First.o(.text+0x46):fake: undefined reference to `regexzmbasezm0zi72zi0zi1_Textz iRegexziBaseziContext_zdf4_closure'
06:24:54 <mjk> i have not to call dll file
06:25:26 <dcoutts> mjk: are you linking the thing using all the right -package flags? like -package regex-base
06:26:20 <mjk> dcoutts: i want to use =~ to find the pattern position
06:26:26 <mjk> no
06:26:44 <mjk> i try it
06:26:50 <dcoutts> mjk: so when you make the dll you have to link to all the haskell packages that you're using
06:27:05 <dcoutts> or you'll get linker errors about missing symbols
06:27:13 <henr_k>  /ignore #haskell mode joins quits parts
06:27:21 <henr_k> hups, sorry!
06:30:08 <mjk> dcoutts: in ghc -c First.hs -fglasgow-exts -package regex-base?
06:30:24 <dcoutts> mjk: and any other packages you need
06:30:33 <dcoutts> mjk: eg regex-compat or whatever
07:02:53 <bauchus> with which package could I play sound in an haskell-opengl game?
07:06:44 <Lemmih> bauchus: openal or sdl-mixer, perhaps.
07:10:19 <bauchus> ok, i'll look into openal first
07:12:52 * dcoutts makes cabal install xmonad 60% quicker
07:13:00 <dcoutts> erm --dry-run
07:13:12 <dcoutts> just the dep resolution, not the actuall compilation :-)
07:27:26 <ivanm> is there a ternary equivalent of Maybe? i.e. something like Nothing | ID | Just a ?
07:28:22 <audreyt> Maybe (Maybe a)?
07:28:33 <ivanm> yeah, except that starts to look rather ugly :s
07:28:50 <audreyt> define it yourself then
07:29:07 <ivanm> yeah, just wanted to check if there already was something like that that I wasn't aware of
07:29:11 <Lemmih> dcoutts: Was dep resolution significantly expensive?
07:29:35 <dcoutts> Lemmih: no, but reading the package index is slooooow
07:29:51 <dcoutts> 90% of the time to construct the plan is spent reading the indexes
07:29:56 <ivanm> dcoutts: maybe you need to get dons to suggest speed-ups for you :p
07:29:57 <dcoutts> ie parsing text files
07:31:58 <dcoutts> Lemmih: http://hackage.haskell.org/trac/hackage/ticket/288
07:31:59 <lambdabot> Title: #288 (the package indexes are very slow) - Hackage - Trac
07:32:30 <dcoutts> ivanm: perhaps dons will suggest using a binary index instead :-)
07:32:36 <ivanm> heh
07:32:45 <ivanm> so you already know what you need to do! :p
07:32:56 <dcoutts> easier said than done of course
07:33:11 <ivanm> pffft, that's just an implementation problem :p
07:33:18 <dcoutts> it's not so bad now though, I've just added a patch so that we don't have to read the whole index every time
07:33:27 <dcoutts> just if we have to inspect the whole index
07:33:35 <dcoutts> ie if you want to install every package
07:35:32 <pejo> Having human-readable indices is really nice.
07:35:56 <dcoutts> pejo: we could have both
07:36:06 <dcoutts> we already have the tarball of .cabal files
07:36:21 <dcoutts> we could just keep additionally a binary index of some subset of that info
07:37:34 <dcoutts> actually if it's a sufficiently small subset of the info then it wouldn't even have to be binary to be a lot faster
07:37:37 <vincenz> @seen jedbrown
07:37:37 <lambdabot> I haven't seen jedbrown.
07:37:41 <pejo> dcoutts, yeah, just need to make sure there aren't inconsistencies due to creative users.
07:37:47 <dcoutts> right
07:51:57 <Armored_Azrael> Is there any way to catch the error due to head and other similar functions failing without using the IO monad?
07:52:23 <Saizan> no
07:52:26 <Armored_Azrael> ok
07:52:27 <Armored_Azrael> thanks
07:54:55 <Armored_Azrael> Is there a way to get ghc to validate the grammar of the code, but not try to compile or typecheck?
07:56:39 <slarba> Armored_Azrael: that should be simple using the parser that comes as a library with ghc
07:57:06 <slarba> Language.Haskell.Parser that is
08:01:07 <pejo> Armored_Azrael, catch can find those kind of errors, but it's for H98 iirc.
08:02:00 <Armored_Azrael> pejo: It's fine, I'm just validating the code with that parser before doing transforms on it.
08:02:15 <Armored_Azrael> My transforms don't fail unless fed invalid code, so I'm just stopping it before then.
08:03:12 <Armored_Azrael> Urgh. I wish shared object was mainlined already so I didn't have to manually load all the libraries :P
08:03:13 <TomM1> My transforms correct invalid code, producing the code that performs the intended operation.
08:04:58 <hpaste>  slarba pasted "simple syntax checker" at http://hpaste.org/8170
08:10:13 <lilachaze> What can I do about an "Illegal polymorphic or qualified type" error?
08:22:46 <vixey> lilachaze: I don't know
08:22:52 <vixey> lilachaze: ,but how did you get the error?
08:26:57 <lilachaze> vixey: data Compiler a = Compiler { runCompiler :: forall st . (Diagnostic -> st -> st) -> st -> (st, a) }
08:28:10 <vixey> ok.. I think it's too advanced for me
08:28:32 <vixey> just curious why do you not use data Compiler a st = ..., instead of having it forall st. ?
08:30:26 <lilachaze> that would involve changing a fair amount of existing code, coupling that existing code to an implementation detail of this monad, and making said code polymorphic (well, i suppose what i have now is secretly polymorphic too).
08:30:29 <ttt--> can i load a lhs file in ghci?
08:30:58 <Lemmih> ttt--: Yes.
08:31:49 <ttt--> i get "test.lhs line 178: unlit: No definitions in file (perhaps you forgot the '>'s?)
08:31:50 <ttt--> phase `Literate pre-processor' failed (exitcode = 1)
08:31:50 <ttt--> "
08:32:29 <Lemmih> ttt--: The file has to be valid.
08:32:29 <lilachaze> ttt--: are there any definitions in the file?
08:34:39 <ttt--> lilachaze, that was the error. there was no module line, thanks
08:36:29 * vixey wonders if an associated type/family thing would let you have st implicit like this
08:41:00 <chessguy> 'morning
08:42:01 <vixey> hi
08:42:47 <vixey> chessguy: You are using genetic algorithms to create chess playing algorithms?
08:43:01 <chessguy> more or less
08:43:37 <Botje> anyone here knowledgeable about closure conversion? I'm having an annoying scoping problem
08:43:47 <vixey> cool :)
08:44:14 <dcoutts> Lemmih: I thought I might spend the rest of day playing with HAppS with the view to making a demo hackage-server
08:44:41 <dcoutts> Lemmih: I'm using the HAppS-* components from hackage, any other pointers for where I should start?
08:45:35 <vixey> Botje: does closure conversion mean something different in haskell than scheme?
08:45:49 <vixey> (if not I think it's very simple)
08:46:09 <Botje> vixey: i'm actually doing it for ML, but yeah. same thing
08:46:23 <Botje> i'm still following the compiling with continuations book
08:46:39 <vixey> what is the scope problem?
08:46:47 <Botje> hang on, i'll hpaste it
08:47:25 <hpaste>  Botje pasted "CPS for fac" at http://hpaste.org/8172
08:47:51 <Botje> so I determined which functions needed closures and modified calls to them accordingly
08:48:14 <Botje> the only probleme there is the @clos_1 closure
08:48:31 <Botje> $CPS12 uses it to do a call to fact
08:48:39 <Botje> but @clos_1 is not in scope there
08:49:03 <Botje> and I can't lift the record that defines @clos_1 above my toplevel fix, because it depends on $CPS4, which is defined inside :(
08:52:02 <vixey> what does this mean?
08:52:04 <vixey> record [CPSLabel "$CPS4"] => "@clos_1"
08:52:20 <Botje> make a record containing the a pointer to CPS4 and bind it to @clos_1
08:52:33 <Botje> then continue to the next line
08:56:20 <vixey> this line
08:56:21 <vixey>                   {apply label fact [CPSVar "@clos_1", CPSVar "$CPS15", CPSVar "@clos_3"]}),
08:56:24 <vixey> is the problem?
08:56:37 <Botje> yes
08:56:57 <vixey> why doesn't
08:56:58 <vixey> apply label $CPS12 [CPSInt 0, CPSVar ":VAR1", CPSVar "$CPS6"]
08:57:00 <vixey> look more like
08:57:16 <vixey> apply label $CPS12 [CPSVar "@clos", CPSInt 0, CPSVar ":VAR1", CPSVar "$CPS6"]
08:57:58 <vixey> (and the line after it)
08:58:48 <Botje> because the book is _REALLY_ spotty on deciding if a function needs a closure
08:59:03 <Botje> and the monster i hacked up decided CPS12 didn't need a closur
08:59:12 <tsuwabuk_> > fix
08:59:13 <lambdabot>  Add a type signature
08:59:15 <vixey> well I think it does
08:59:29 <Botje> which is true, because CPS12 is never stored, it's only called
09:00:36 <vixey> but CPS12 needs access to @clos
09:00:45 <vixey> so anything that calls CPS12 should be passing it the closure, shouldn't it?
09:00:45 <Botje> yup
09:00:59 <Botje> indeed
09:01:26 <Botje> that's because i add free variables to the argument list first, and _THEN_ do the closure transform
09:01:40 <Botje> *sigh* :(
09:01:45 <vixey> that sounds correct to me
09:02:09 <Botje> maybe i'll take a peek at the SML compiler
09:02:22 <vixey> You could look at marc feeleys presentation
09:02:40 <Botje> the scheme to C in XX minutes one?
09:02:46 <vixey> yeah
09:03:09 <Botje> i will :)
09:03:10 <Botje> thanks!
09:16:40 <dogbite> hi, i'm trying to understand randomizing lists, and i have read both
09:16:42 <dogbite> http://www.drmaciver.com/2008/04/monadic-card-shuffling/
09:16:43 <lambdabot> Title: David R. MacIver  Blog Archive  Monadic card shuffling
09:16:44 <dogbite> and
09:16:49 <dogbite> http://hpaste.org/4216#a1
09:17:03 <dogbite> but i'm still a little confused, in particular
09:17:13 <dogbite> about creating multiple randomized lists
09:17:31 <dogbite> i don't see how to pass the StdGen around
09:18:09 <Botje> do you have code to show?
09:18:16 <sclv> ?hoogle split
09:18:16 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
09:18:16 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
09:18:16 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
09:18:24 <sclv> bleh
09:18:31 <Botje> that's probably easiest to help with
09:19:38 <sclv> ?ty Random.split
09:19:40 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
09:20:06 <Botje> for example, in that hpaste snippet you could have knuthShuffle' return the new generator
09:20:18 <Botje> pick it up in listShuffle and use it to shuffle another array
09:20:47 <sclv> dogbite: http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html -- I find that if one looks at the docs most things become clear
09:20:48 <lambdabot> http://tinyurl.com/2xxbhl
09:22:16 <sclv> if you want say, n infinite lists, you split the generator n times, and then call randoms or randomRs over each generator.
09:22:23 <sclv> (for example)
09:25:23 <dogbite> okay, let me look.
09:32:05 <hpaste>  mqtt pasted "(no title)" at http://hpaste.org/8173
09:36:02 <dogbite> okay, i think i see what to do now.  i didn't notice the split function before and
09:36:31 <dogbite> i see how i could modify the listShuffle method in the hpaste
09:59:58 <smg> hi
10:01:01 <conal> hi smg
10:02:40 <smg> someone has examples for cantor's diagonal theorem?
10:02:54 <Cale> Examples?
10:03:11 <smg> yes
10:03:16 <smg> i don't understand it from wikipedia
10:04:01 <Cale> You mean the theorem that the real numbers are not countable?
10:04:37 <SamB> oh is that what it's for
10:04:42 <SamB> it does that well ;-)
10:05:09 <smg> Cale: yeah i need it in haskell in list comrpehensions
10:05:19 <smg> but i don't get it from wikipedia, because there is no single example only "blabla"
10:05:20 <smg> :|
10:05:37 <Cale> Wait, what?
10:05:42 <SamB> you can't write that in Haskell
10:05:52 <SamB> at least, not meaningfully
10:06:01 <Draconx> smg, you should be able to find examples in a first year algebra textbook.
10:06:32 <augur> dmwit: thats auger with an e. i'm augur with a u. two u's actually.
10:06:56 <smg> Draconx: mh
10:07:08 <smg> nothing in the net? :)
10:07:16 <Cale> smg: Cantor's diagonalisation argument shows that something *doesn't* exist. I don't see what you mean by an example.
10:07:33 <Draconx> I think he's looking for an example of a diagonalisation argument.
10:09:16 <smg> Cale: :)
10:09:30 <Armored_Azrael> Hey, question on openFile. If I pass a filename to it, for some reason I get:
10:09:30 <Armored_Azrael> hsExec: /tmp/foo: openFile: inappropriate type (Not a directory)
10:09:30 <Armored_Azrael> but if I try a directory I instead get
10:09:30 <Armored_Azrael> hsExec: /tmp/: openFile: inappropriate type (Is a directory)
10:09:30 <Armored_Azrael> Ideas?
10:09:36 <smg> xs= [(5*a, 2*b+1) | s <- [0..], a <- [0..s], let b = s - a] -- cantor diagonalization? but i don't know what i am doing here
10:09:45 <smg> Draconx, Cale: look at that
10:09:58 <Cale> smg: That has nothing to do with Cantor.
10:10:09 <smg> whats that then? :P
10:10:13 <smg> i don't know
10:10:14 <Cale> At least as far as I know.
10:10:27 <smg> someone told me that was cantor diagonalization
10:10:40 <smg> respectively parallel list comprehension
10:10:42 <wjt> Maybe you're confusing Cantor's argument with the enumeration used to show that the rationals are countable?
10:10:49 <Cale> Well, I wonder. It might be due to him, but I've never heard it connected with his name.
10:11:08 <smg> xs= [(5*a, 2*b+1) | a <- [0..], b <- [0..]]
10:11:11 <Codex_> Cant you do diagonalisation by triple composite: diag . index . not, where diag :: X->(X,X), index :: (X,X)->Y, not :: Y->Y, and it gives you diag . index . not :: X->Y ? :)
10:11:16 <smg> that won't terminate for (20,5) `elem` xs
10:11:28 <smg> i need examples not theory stuff :P
10:11:33 <smg> because i don't understand that
10:11:47 <smg> xs= [(5*a, 2*b+1) | s <- [0..], a <- [0..s], let b = s - a] will terminate
10:12:02 <Cale> Armored_Azrael: What kind of file is /tmp/foo ?
10:12:49 <Armored_Azrael> I just ran
10:12:50 <Armored_Azrael> touch /tmp/foo
10:12:53 <Armored_Azrael> where prior there was no file
10:12:57 <Cale> okay
10:12:58 <Armored_Azrael> so it should be a normal file
10:13:05 <Cale> and you're opening it in ReadMode?
10:13:09 <Armored_Azrael> Yes.
10:13:15 <Cale> That ought to work.
10:13:20 <Armored_Azrael> ﻿Cale: If you don't know anything, don't think too hard--I'm doing some fancy linking, and it's possible I somehow mismatched closures
10:13:41 <Armored_Azrael> Though this would make me sad, as it means that something nasty is going on that will take a while to fix.
10:13:56 <Cale> smg: Well, it never finishes enumerating the elements where a = 0
10:14:53 <smg> Cale: this i know
10:15:13 <smg> Cale: but what does exactly the expression let b = s - a etc? i need to undertand how to form the 2nd expression which WILL terminate
10:15:18 <smg> i.e. it's a fair order
10:15:22 <smg> but i don't know how to do that
10:15:46 <wjt> @let xs= [(5*a, 2*b+1) | s <- [0..], a <- [0..s], let b = s - a]
10:15:48 <lambdabot> Defined.
10:15:54 <Cale> Well, you pick the sum s, and enumerate the pairs (a,b) for which a+b = s
10:16:02 <wjt> > (20,5) `elem` xs
10:16:02 <Cale> of which there are only finitely many for each s
10:16:15 <lambdabot>  True
10:16:51 <sclv> ?seen conal
10:16:52 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 15m 50s ago.
10:17:00 <conal> sclv: hi there
10:17:11 <smg> so let s = a +b would be better?
10:17:17 <Armored_Azrael> Urgh. Looks like this is going to be annoying. I changed a few things around and now the process is terminating on illegal instruction. Something is most definitely mislinked.
10:17:26 <sclv> conal: as someone who's not a ghc-guru, I'm curious what keeps you from using specialize pragmas to get what you want?
10:17:47 <sclv> an exponential explosion of them?
10:18:53 <conal> sclv: i hadn't considered specialize.  i don't know how it would apply.
10:18:53 <Cale> smg: that doesn't work :)
10:19:03 <Cale> smg: the idea is to pick s first
10:19:14 <Cale> smg: and then once you pick a, you know which b you have
10:19:54 <conal> sclv: perhaps more optimizations would go through if specific dictionaries were inlined?
10:20:13 <conal> sclv: even if the optimizations don't depend on those dictionaries.
10:20:22 <sclv> right -- that's the notion. but I'm not sure how it maps onto your model.
10:21:01 <hpaste>  vicky pasted "diagonalization for smg" at http://hpaste.org/8174
10:22:02 <conal> sclv: maybe.  i'll keep that idea in mind if i get stuck again.  as you said though, it's not an ideal solution, since it wires in performance only for some types.
10:22:04 <sclv> it works for your toy example, but for your real one I fear a huge blowup in the specializations you need to make.
10:22:06 <vixey> > [(x,y) | x <- [0..] , y <- [0..] ]
10:22:21 <sclv> conal: so you're unstuck at the moment then? good news!
10:22:21 <lambdabot>  thread killed
10:22:32 <vixey> > [(x,y) | sum <- [0..] , x <- [0..sum] , let y = sum - x ]
10:22:44 <conal> sclv: yeah.  phew!  lennart's suggestion for -fno-method-sharing worked.
10:22:47 <lambdabot>  thread killed
10:22:53 <sclv> awseome
10:22:59 <vixey> thank you lambdabot..
10:23:05 <chessguy> @hoogle IO [String]
10:23:09 <lambdabot> GHC.Environment.getFullArgs :: IO [String]
10:23:09 <lambdabot> System.Environment.getArgs :: IO [String]
10:23:16 <smg> vincenz: interesting :D
10:23:17 <vixey> smg: Did you see the paste though?
10:23:26 <smg> vixey: i look at paste atm yes
10:23:30 <vixey> > [(x,y) | x <- [0..] , y <- [0..] ]
10:23:32 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(...
10:23:34 <vixey> > [(x,y) | sum <- [0..] , x <- [0..sum] , let y = sum - x ]
10:23:35 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
10:23:47 <DRMacIver> I wonder if I should count that primes thing on the list of lies people tell about Haskell...
10:23:47 <vixey> this the haskell code for A and B in that pasted
10:23:53 <smg> yeah i know that
10:23:57 <DRMacIver> (that and quicksort)
10:24:03 <smg> but i don't see how i can get from A to B :|
10:24:12 <vixey> don't go from A to B
10:24:12 <smg> is that _always_ that style?
10:24:15 <smg> let y = sum -x ?
10:24:24 <vixey> no not at all
10:24:30 <smg> ah :|
10:24:57 <vixey> smg: no this is a good thing
10:25:15 <vixey> smg: there are lots of ways to solve the problem, it keeps it interesting
10:25:20 <smg> :|
10:25:32 <smg> vixey: maybe you have some resource where i can learn to figure out the sum?
10:28:10 <vixey> > let return = (:[]) ; (>>=) = flip concatMap in [0..] >>= \x -> [0..] >>= \y -> return (x,y)
10:28:11 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(...
10:28:26 <smg> for me? :D
10:28:42 <sclv> haha wow that no-method-sharing flag is some real black magic there
10:28:54 <smg> vixey: ?
10:29:08 <conal> sclv:  i don't know if i'd have ever found that flag on my own.
10:29:15 <vixey> "?" is not a question I know how to answer
10:29:29 <smg> maybe you have some resource where i can learn to figure out the sum?
10:29:30 <sclv> sure enough though, its hidden on the haskellwiki under "Using Rules" http://www.haskell.org/haskellwiki/GHC/Using_rules
10:29:31 <lambdabot> Title: GHC/Using rules - HaskellWiki
10:30:15 <vixey> > let return = (:[]) ; (x:xs) >>= f = f x `interleave` (xs >>= f) ; (x:xs)`interleave`(y:ys) = x:y:(xs`interleave`ys) in [0..] >>= \x -> [0..] >>= \y -> return (x,y)
10:30:18 <lambdabot> Terminated
10:30:25 <conal> sclv: oh, wow.  i'd found that page, too.  i'll reread it much more carefully.  thanks!
10:35:43 <Botje> :t fmap . fmap
10:35:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:37:02 <conal> :t fmap . second . fmap . first
10:37:05 <lambdabot> forall (f :: * -> *) d (f1 :: * -> *) b c d1. (Functor f1, Functor f) => (b -> c) -> f (d, f1 (b, d1)) -> f (d, f1 (c, d1))
10:37:42 <Botje> woah.
10:38:14 <vixey> hmm
10:38:16 <vixey> > let return = (:[]) ; (x:xs) >>= f = f x `interleave` (xs >>= f) ; []`interleave`ys = ys ; (x:xs)`interleave`ys = x:(ys`interleave`xs) in [0..] >>= \x -> [0..] >>= \y -> return (x,y)
10:38:23 <lambdabot>  [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0,...
10:38:57 <vixey> > let return = (:[]) ; (x:xs) >>= f = f x `interleave` (xs >>= f) ; []`interleave`ys = ys ; (x:xs)`interleave`ys = x:(ys`interleave`xs) in [0..] >>= \x -> [0..] >>= \y -> return (x+y)
10:38:58 <lambdabot>  [0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16,9,...
10:39:03 <conal> :t (.) . second . (.) . first
10:39:06 <lambdabot> forall (f :: * -> *) d (f1 :: * -> *) b c d1. (Functor f1, Functor f) => (b -> c) -> f (d, f1 (b, d1)) -> f (d, f1 (c, d1))
10:39:16 <conal> oh, yeah.  lambdabot (.)
10:39:43 <ddarius> @let result = (P..)
10:39:43 <lambdabot> Defined.
10:39:47 <gubagem1> @hoogle Data.Map
10:39:48 <lambdabot> No matches, try a more general search
10:39:54 <gubagem1> :-/
10:41:18 <ddarius> :t result . second . result . first
10:41:20 <lambdabot> forall a d a1 b c d1. (b -> c) -> (a -> (d, a1 -> (b, d1))) -> a -> (d, a1 -> (c, d1))
10:41:28 <vixey> huh I always thought ml in caml stood for meta language
10:41:43 <ddarius> Categorical Abstract Machine Language
10:41:46 <conal> ddarius: "result" is the name i prefer also
10:41:55 <ddarius> conal: Well I did steal it from you.
10:42:30 <conal> ddarius: oh!  i'd totally forgotten about the CAML.  I was at CMU when Huet was working it out.  Maybe that's where i got the DeepArrow algebra but i forgot.
10:43:18 <chessguy> @hoogle IO a -> IO ()
10:43:19 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
10:43:19 <lambdabot> Foreign.C.Error.throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
10:43:19 <lambdabot> Foreign.C.Error.throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
10:43:38 <vixey> I just found a compiler from miniML to caml
10:45:51 <vixey> "The first Caml implementation in Lisp was nicknamed "Heavy CAML" because of its memory and CPU requirements"
10:48:42 <vixey> does anyone know a decent text describing CAM?
10:48:51 <chessguy> @undo do fe <- r "p"; f fe >>= re ()
10:48:51 <lambdabot> r "p" >>= \ fe -> f fe >>= re ()
10:48:56 <ddarius> vixey: Just ask google.
10:50:53 <Armored_Azrael> ﻿Does anyone know an extant SQL string escape implementation in haskell?
10:52:11 <vixey> I don't think Science of Computer Programming is available online
10:53:25 <hpaste>  chessguy pasted "Why do I still feel like this could be cleaner?" at http://hpaste.org/8175
10:54:29 <conal> chessguy: mabye the mixture of imperative and functional
10:54:48 <ddarius> vixey: Try this perhaps: http://www.cs.uni-bonn.de/~ralf/publications/IAI-TR-92-1.ps.gz
10:55:30 <chessguy> conal:  indeed. got any suggestions?
10:55:44 <conal> chessguy: let's see runTestTT
10:55:49 <ddarius> chessguy: Why do you have return ()?
10:55:53 <chessguy> conal:  library function
10:56:04 <conal> chessguy: oh.  what library?
10:56:05 <chessguy> ddarius:  runTestTT :: IO Count
10:56:11 <chessguy> HUnit
10:56:31 <conal> chessguy: what does it do?  why IO?
10:56:56 <chessguy> conal:  it runs all the tests, spits out some info about it, and returns the count information
10:57:22 <conal> chessguy: have you looked at TV?  it's a discipline for keeping functional & I/O together but separable.  together for convenience/tangibility and separable for composability.
10:57:42 <ddarius> chessguy: Is there a problem with main' returning the count?
10:57:59 <conal> chessguy: ok.  what's the IO part about of runTestTT?
10:58:06 <chessguy> ddarius:  well, yeah, its type is IO ()
10:58:18 <ddarius> chessguy: Why does it need to be IO ()?
10:58:36 <chessguy> ddarius:  because i want to be able to run it as main
10:58:41 <gubagem1> how would I "import qualified Data.Map as Map" in ghci?
10:58:42 <ddarius> main :: IO a
10:59:03 <chessguy> what?
10:59:06 <chessguy> i thought main was IO ()
10:59:10 <ddarius> No.
10:59:56 <chessguy> conal:  i have heard of it, but never really understood what it was about
11:00:21 <chessguy> conal:  as for the IO part of runTestTT, it prints output to stdio
11:00:27 <chessguy> err, stdout
11:00:47 <conal> chessguy: maybe runTestTT is unnecessarily imperative then.
11:01:22 <chessguy> conal:  i wondered about that, it seemd odd to me. the docs say that it needs to be in IO to test code that runs IO computations
11:01:26 <ddarius> conal: Often the tests are IO actions themselves.
11:02:17 <conal> chessguy: have you seen my google tech talk "Tangible Functional Programming: a modern marriage of usability and composability"?  TV is the programmatic form of that idea, while Eros is the gestural form.
11:02:42 <chessguy> conal:  can't say i have
11:03:16 <conal> chessguy: http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
11:03:17 <lambdabot> Title: Conal Elliott  Blog Archive  Tangible Functional Programming: a modern marriag ..., http://tinyurl.com/5vrmhu
11:03:37 * chessguy fires it up
11:03:58 <conal> chessguy: for instance, with TV, in this example you might have something like 'olambda (readFile "perftsuite.epd") runTestTT' as the interface and 'TestList . map createTest . lines' as the functionality.
11:04:52 <conal> chessguy: though i'd really want to dissect runTestTT to separate out the functionality from the interface (I/O).
11:05:00 <chessguy> conal:  agreed
11:05:23 <chessguy> conal:  though i can sort of see where they're coming from in that tests can be IO computations too
11:05:35 <conal> chessguy: monadic IO makes it convenient to mix I/O and functionality, but in doing so, a whole lot of composability is lost.
11:07:19 <conal> chessguy: sure.  it's easy to throw stuff in IO ("the sin bin") rather than figuring out how to program functionally.
11:07:30 <chessguy> lol
11:10:12 * Zao notes that conal subscribes to the "bearded people are good programmers" camp.
11:10:47 * dcoutts too!
11:10:51 <chessguy> haha
11:11:06 <dcoutts> though clearly Igloo is a better programmer than me
11:11:37 <chessguy> wow, i guessed where conal was going before he went there :)
11:11:41 <olsner> but bearded people *are* better programmers :P
11:11:48 <gubagem1> i have a beard
11:11:58 <gubagem1> maybe its more of just rough scruff
11:13:59 <vixey> I'm really confused .. how do you even state that two programs in two languages have the same meaning if the programs might never terminate?
11:14:26 <dcoutts> vixey: if they both never terminate that's easy
11:14:30 <dcoutts> _|_ = _|_
11:14:40 <vixey> yes but ..
11:14:48 <ddarius> There's also bisimulation.
11:14:56 <vixey> main = print "hello" >> main is different to 10 print "bye" 20 goto 10
11:15:02 <Philippa_> dcoutts: missile control systems and let ones = 1:ones in ones are equivalent?
11:15:32 <dcoutts> ah, well I think you need a slightly different way of looking at interactive systems
11:15:57 <vixey> I understand correctness of say arithmetic evaluator and compiler as in mcarthys text
11:16:05 <dcoutts> they're not pure non-terminating computations, they're a sequence of terminating computations and interactions
11:16:14 <ddarius> vixey: Look up bisimulation.
11:16:22 <vixey> I am reading about it now
11:17:20 <ddarius> vixey: This leads back to coinduction mind you.
11:17:33 <vixey> I had a feeling it would
11:17:54 <vixey> coinduction is becoming unavoidable for me
11:22:33 <vixey> what are the state transitions in something like haskell?
11:22:46 <vixey> could it be taking the WHNF of some thunk?
11:23:02 <vixey> since really all the evaluation comes down to a sequence of these
11:23:29 <vixey> (things like IO are happening when certain thunks WHNF is taken right?, this is how a monad sequences IO?)
11:24:44 <conal> vixey: for a functional style (rather than state transitions), see FRP.
11:26:47 <bd_> vixey: The implementation of IO is undefined :)
11:27:27 <vixey> then there is abosultely no way to know what a haskell program that uses IO does
11:27:33 <bd_> I believe in the past, before the IO monad was invented, there was a crazy design involving an infinite list of output actions being produced from an infinite list of input results, triggered by requests on the output stream...
11:27:40 <bd_> vixey: the implementation is undefined, the semantics are defined
11:28:01 <bd_> however it's undefined whether putStrLn "foo" >> putStrLn "bar" uses `seq` to order the two actions, or something else
11:28:08 <vixey> I am just thinking about semantics
11:28:31 <vixey> @src (>>)
11:28:32 <lambdabot> m >> k      = m >>= \_ -> k
11:28:39 <bd_> >>= depends on the monad :)
11:28:46 <vixey> I would have thought that it's more ilke  m >>= \() -> k
11:28:55 <bd_> vixey: no, >> just throws away the result
11:28:59 <vixey> and pattern matching on () requires taking 'putStrLn "foo"' into WHNF
11:29:10 <bd_> otherwise if you wanted to ignore the result, you'd have to do _ <- somethingWhoseResultYouDontCareAbout
11:29:20 <bd_> vixey: nope. because putStrLn "foo" is IO ()
11:29:28 <vixey> which means that putStrLn "foo" >> putStrLn "bar" should certainly not print "foo"
11:29:29 <bd_> so the >>= has already taken care of (somehow!) ordering the operations
11:29:43 <ddarius> vixey: If you wanted to compare programs in different languages (including IO) it would be best to compare their input output behaviour with bisimulation.
11:29:52 <bd_> If you want to know how GHC does it:
11:29:55 <bd_> @src (>>=) IO
11:29:55 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:29:58 <bd_> @src IO (>>=)
11:29:59 <lambdabot> m >>= k     = bindIO m k
11:30:03 <bd_> @src bindIO
11:30:03 <lambdabot> bindIO (IO m) k = IO ( \ s ->
11:30:04 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
11:30:05 <SamB> taking an IO () to WHNF should not run it...
11:30:11 <bd_> ^^^ there's more than one way to do it though
11:30:18 <bd_> and this is just GHC's particular implementation
11:30:29 <SamB> ... otherwise how would you run it again?
11:31:07 <conal> moreover, the world-transformer semantic model doesn't work for concurrency, iiuc
11:31:42 <SamB> conal: no, but it does a good job of coaxing the compiler to do the right thing ;-)
11:31:43 <ddarius> conal: It doesn't fit well, but I think you can conceptually have it "work"
11:31:58 <ddarius> SamB: CPS does a better job.
11:32:26 <SamB> ddarius: oh?
11:32:36 <conal> ddarius: i imagine the semantic model would have to be changed to sets of possible world-state transition sequences.
11:32:45 <vixey> this is totally mind boggling :p
11:32:49 <conal> ddarius: for nondeterministic interleaving
11:33:10 <bd_> vixey: the theory behind GHC's implementation is that your program is a function which maps from one Real World to another :)
11:33:11 <ddarius> conal: If you wanted to get something from the state passing model yes, but conceptually that isn't necessary.
11:33:38 <SamB> ddarius: how would you model concurrency in semantics, then?
11:33:48 <conal> ddarius: i don't like the state passing ah.  i just don't know a simpler denotational model for IO.  which is why i don't like IO.
11:33:51 <bd_> vixey: therefore, IO is a state monad, and all IO primitives take a real world, and produce a new one. By hiding the implementation, you avoid messy things like having two worlds.
11:33:54 <SamB> bd_: that's not a theory
11:33:58 <SamB> that's a trick they play on GHC]
11:34:01 <bd_> SamB: really? hm.
11:34:13 <bd_> Well anyway, in the end, the realworld state parameter is silently dropped in code generation
11:34:28 <bd_> but it serves to ensure ordering (ofc it's not the only way to get the right semantics)
11:34:41 <SamB> yeah, not everyone uses that way
11:35:07 <vixey> :t putChar
11:35:09 <lambdabot> Char -> IO ()
11:35:28 <bd_> @src IO
11:35:28 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:35:28 <vixey> I wish it simple
11:35:52 <conal> anyway, this kind of semantic complexity makes purely functional programming appealing to me.  i see IO as just a stopgap tool to be replaced when we understand how to think and program more functionally.
11:36:07 <ddarius> SamB: I'm not sure what your question is in response to.
11:36:23 <SamB> <ddarius> conal: If you wanted to get something from the state passing model yes, but conceptually that isn't necessary.
11:37:01 <ddarius> SamB: Conceptually the thing that chooses which "non-deterministic" execution will also be part of the "state of the world".
11:37:07 <vixey> there was the beauty in the beast approach where they implement IO
11:37:11 <vixey> oops
11:37:15 <ddarius> SamB: Which is, admittedly, useless for any kind of reasoning.
11:37:31 <vixey> where they implement the subset of IO they use in a pure way to reason about programs in IO
11:38:23 <SamB> ddarius: what sort of model can you use that doesn't involve a ... collection of possible ways that execution could proceed?
11:39:33 <vixey> even evaluation is nondeterministic
11:40:10 <SamB> vixey: what about church-rosser or however it's spelt
11:40:18 <vixey> that means it's ok to be nondet.
11:40:34 <SamB> that means the nondeterminism in evaluation is not really very interesting
11:41:03 <vixey> I don't think haskell is church-rosser though
11:41:04 <conal> vixey: IO is not church-rosser
11:41:16 <SamB> conal: IO isn't "evaluation"
11:41:33 <vixey> maybe IO was a really bad example for me to bring up
11:42:04 <conal> SamB: i though vixey was saying CR means IO's nondeterminism is benign
11:42:58 <conal> CR means that the operational nondeterminism of rewriting leads to semantic determinism.
11:43:16 <ddarius> SamB: What does that question have to do with what I've said.
11:43:16 <ddarius> }
11:43:16 <ddarius> ?
11:43:17 <vixey> I was thinking about a + b
11:43:17 <vixey> you don't know if a or b will be evaluated first (but it's ok)
11:43:17 <SamB> no, I was saying that CR means that nondeterminism in the non-IO evaluation is boring
11:43:17 <SamB> so you don't really need to model it
11:43:17 <SamB> does that make sense?
11:43:41 <conal> SamB: i agree.
11:43:49 <vixey> the problem I have is much more general than just IO though
11:43:57 <vixey> I was really just using IO as one example
11:44:00 <SamB> conal: you basically just said what I meant ;-)
11:45:02 <vixey> I have got program A in haskell, program B in STG or CAM or something
11:45:30 <vixey> and I guess that what I would do is model the semantics as (codata) streams and then show they are bisimilar?
11:45:36 * SamB wonders what kinds of things you'd want to prove about programs that are non-deterministic due to use of threading
11:46:06 <Baughn> SamB: That they can't get into deadlocks, for one
11:46:24 <conal> SamB: that they perform the task or compute the value you want
11:46:31 <Baughn> Or that they're equivalent to some serial program you provide
11:46:32 <Philippa_> that various sequences of operations are equivalent (for various values of 'equivalent'), for another
11:46:42 <Baughn> Which might be a lot easier than proving that they do what you want. SHould be, really
11:46:46 <dons> ?bug
11:46:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:46:51 <SamB> Baughn: yes
11:47:01 <SamB> it's hard to figure out what you want sometimes
11:47:42 * Baughn has no problems making a haskell program use all four cores with no threading issues whatsoever, though. I love this language. :D
11:47:47 <ddarius> vixey: You provide a semantics to each using the same methodology (e.g. algebraic, denotation, operational) and you compare them.
11:47:49 <conal> SamB: yep.  sometimes answers arrive before clear questions (or implementations before semantics).
11:48:50 <vixey> I used denotation semantics for an arithemetic thing, that's quite simple.. but as soon you want to think about non-terminating programs, I can't use this approach
11:49:16 <vixey> sorry not 'non-terminating programs' but programs that may or may not terminate
11:49:26 <ddarius> Sure you can.  You just have to refine the semantics.
11:49:30 <Baughn> vixey: Well, a process that "terminates" by reducing itself to a known, easy to reason about state every so often?
11:49:32 <conal> vixey: see FRP.  simple denotational semantics for interactive, non-terminating programs.
11:50:02 <conal> vixey: for a modern formulation of the semantics (and more), try http://conal.net/blog/posts/simply-efficient-functional-reactivity/
11:50:03 <lambdabot> Title: Conal Elliott  Blog Archive  Simply efficient functional reactivity, http://tinyurl.com/6ma42k
11:50:19 <Baughn> If the program is purposely looping, then you just have to prove that each iteration of the loop does what you want
11:50:46 <vixey> thank you
11:51:19 <conal> Baughn: though that perspective may be limited to imperative programs
11:51:30 <conal> Baughn: since functional programs don't do anything
11:52:19 <Baughn> conal: That's what IO is for
11:52:57 <conal> Baughn: not necessarily.  sometimes an alternative is to rethink things functionally.
11:53:16 <Baughn> conal: When you can, yes
11:53:31 <Baughn> I've found myself having to reimplement lazy evaluation lately.. in haskell.
11:53:33 <conal> i think IO is for when we don't yet know to think of something functionally.
11:53:43 <geezusfreeek> heh, at least when you can do it without creating a CAF like i seem to be doing :(
11:53:44 <Baughn> It doesn't let me serialize thunks. Any solutions to that? :/
11:54:28 <conal> geezusfreeek: have you looked at the core?  i'm learning to now and getting some very helpful info.
11:54:39 <conal> Baughn: serialize thunks??
11:55:15 <chessguy> conal:  this is awesome stuff
11:55:19 <vixey> wm
11:55:25 <Baughn> conal: I'm writing a game. A *really huge* game, that depends on being able to offload data to disk and un-evaluate thunks at times
11:55:30 <conal> chessguy: :)
11:55:31 <vixey> the CAM actually looks very much like a lisp evaluator to me
11:55:43 <vixey> the way to handle environments and so on
11:55:47 <conal> Baughn: neat!
11:55:50 <Baughn> conal: So I've been doing a lot of very interesting stuff, but it's still annoyingly hard. It'd be downright impossible in any other language, granted
11:55:57 <vixey> I guess that's just a natural occurence
11:56:00 <geezusfreeek> conal: i have. i am still learning…
11:56:09 <Baughn> conal: (For "huge" - think "2x1x1 meter resolution of Earth"
11:56:10 <geezusfreeek> conal: do you know of a decent guide to Core anywhere?
11:56:12 <conal> Baughn: that's the kind of thing that a functional language and runtime *could* do but don't.
11:56:17 <geezusfreeek> i have looked and haven't been able to find
11:56:45 <Baughn> conal: I did hack ghc to let me copy thunks without evaluating them. Seems to be working..
11:56:51 <Baughn> That was the one primitive I missed most, really
11:57:04 <geezusfreeek> Baughn: this is to save memory?
11:57:11 <Baughn> geezusfreeek: Yes
11:57:17 <conal> Baughn: are you into research & publication?  i'd love to see haskell move in the direction of managing computation and memory in more sophisticated ways.  another example is managing video memory well.
11:57:43 <Baughn> conal: I probably should be. I've got a master's thesis to write next year, so.. yes, I'll try to write something up eventually, I guess
11:58:31 <chessguy> conal:  i like what it says about simple UIs, though i'm not sure the world is ready to hear it yet
11:58:33 <mmorrow> Baughn: how did you hack ghc to do that??
11:59:02 <Baughn> mmorrow: By studying how seq works. :P
11:59:04 <conal> Baughn: in addition to hacking around the limitation of language and runtime, i hope you think & write about how to evolve the language and runtime, so you can elimate your app-specific mechanisms.
11:59:39 <Baughn> mmorrow: It isn't really all that hard. I allocate some memory for the thunk, then memcpy it in; it /seems/ to be working, but I can't be /sure/
11:59:50 <Baughn> Well, I could. I just haven't put in the effort yet. That's for tomorrow.
12:00:16 <geezusfreeek> i think the most interesting thing would be devising ways for the compiler or runtime to see when it would be beneficial to rethunk data
12:00:17 <Baughn> conal: Oh, I'll be submitting this as a patch once I'm sure it works well enough
12:00:24 <conal> chessguy: thanks.  i haven't pursued that exploration yet (identifying API design and UI design).
12:00:31 <conal> Baughn: awesome.  thanks!
12:00:52 <Baughn> geezusfreeek: The discussion yesterday seemed to end with "when the user says it's okay"
12:00:56 <conal> Baughn: you're hacking inside ghc, rather than on top?
12:01:01 <Baughn> Maybe some LRU thing..
12:01:14 <Baughn> conal: Yes. It's very much a primitive; there's no way to do it from inside haskell
12:01:21 <Baughn> It's a very /simple/ primitive, however
12:01:30 <geezusfreeek> that would definitely be good enough for a start
12:01:50 <conal> Baughn: cool.  i couldn't see a way to un-evaluate on top either.
12:02:13 <Baughn> There's a natural connection to weak references, too, but implementing those would require me to delve into the GC
12:02:16 * Baughn gulps
12:02:29 <conal> Baughn: ghc already does weak references.
12:02:56 <conal> Baughn: described in "stretching the storage manager"
12:03:14 <Baughn> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC <-- *sigh*
12:03:17 <lambdabot> http://tinyurl.com/5nhkkf
12:03:19 <mmorrow> Baughn: did you say this lets you serialize thunks to disk (and then pull them back off at a possibly arbitrary later time)?
12:03:19 <conal> Baughn: which grew out of an earlier (broken) data-driven FRP implementation.
12:03:24 <Baughn> mmorrow: No.
12:03:33 <mmorrow> oh, i was like holy crap
12:03:56 <Baughn> mmorrow: That would also be doable, but it'd require some serious work to handle loading them in a /separate program/ (or just an update of the same one)
12:04:20 <Baughn> Oh, it does?
12:04:23 <Baughn> Lucky
12:04:35 <Baughn> conal: Copy thunk, evaluate one thunk, then at some point drop the first, evaluated reference
12:04:48 <Baughn> The GC will remove all the data. Evaluate thunk again to get it back.
12:05:10 <Baughn> lambdabot: Slowbot
12:05:31 <conal> Baughn: sounds nice & simple, as you said.
12:05:36 <Baughn> mmorrow: Although, enabling you to serialize and load thunks in the /same program/ would take considerably less code
12:06:19 <mmorrow> Baughn: i can see that. the general case seems to me the most interesting though.
12:06:35 <Baughn> mmorrow: In the chinese sense.
12:06:39 <mmorrow> Baughn: "i can see that" as in that makes sense
12:07:00 <Baughn> mmorrow: I'd be able to piggyback it on dynamic library code, so I'll wait for that. Then we'll see.
12:07:32 <geezusfreeek> would be cool to send thunks over the wire, so to speak
12:08:25 <vixey> Oz lets you do this
12:10:23 <Baughn> geezusfreeek: Oh gods..
12:10:40 <Baughn> Well, that's actually the same scenario as deserializing it into a different program. Ask me about that later.
12:10:54 <geezusfreeek> right, that's why i brought it up ;)
12:11:13 <Baughn> A thunk is a function pointer, plus parameters to pass it. To make it loadable in a different program..
12:11:25 <Baughn> Just look up the function by symbol instead. Simple! :D
12:12:04 <Baughn> Large burden on the programmer there, but he's a haskell programmer; he'll be fine. You can build something more elaborate on top of that.
12:12:12 <mmorrow> mmorrow: dynamic lib support seems like it'll open the door to really cool "hackish-oh-wait-thats-really-useful-i-take-back-that-its-hackish" things
12:12:12 <Baughn> Right, I'm going to try it
12:12:31 <Baughn> Dynamic lib support wouldn't actually help me at all
12:12:32 <mmorrow> um, s/mmorrow/Baughn/
12:12:46 <gwern> @seen dcoutts_
12:12:46 <lambdabot> dcoutts_ is in #ghc, #haskell-overflow, #haskell and #gentoo-haskell. I don't know when dcoutts_ last spoke.
12:12:51 <dcoutts> hia gweiqi
12:12:53 <dcoutts> oops
12:12:56 <dcoutts> hia gwern
12:13:03 <Baughn> mmorrow: I know. Anyway.. all I need is the symbol table. Should be simple.
12:13:18 <Baughn> It's good I spend a lot of time in ##C, though. :P
12:13:30 <gwern> dcoutts: hi. I was wondering: in cabal, '--user' is not used by default right?
12:13:55 <dcoutts> gwern: not in runghc Setup no, but cabal-install does use --user by default
12:14:32 <gwern> dcoutts: why is that? seems to me that it makes perfect sense to use local installations and fallthrough to the global installations
12:14:48 * Baughn notes that serializing one thunk would most definitely not be an O(1) operation
12:15:28 <vixey> I think SBCL has serializable closures now
12:15:41 <vixey> I'm not sure but probably Oz does
12:15:42 <dcoutts> gwern: the default for rungh Setup.hs has been that way for ever. I'm a bit nervous of changing that. However for the new command line user interface I think you're right that it makes sense to use --user by default. So that's why they're different.
12:15:56 <conal> btw, http://www.macs.hw.ac.uk/~dsg/gdh/
12:15:58 <lambdabot> Title: Glasgow Distributed Haskell
12:16:46 <dcoutts> gwern: the one change I did make is that with runghc Setup --user, that does now change the default --prefix
12:16:49 <gwern> dcoutts: well, alright - but what could break for runhaskell? wouldn't it only be situations where you want to use the global version preferentially to local? (in which case I'd think adding a --global would override a defaulted --user, no?)
12:17:20 <dcoutts> gwern: if you did --user --prefix=/usr/local say then it'll break horribly
12:17:42 <vixey> how could you model haskell as a state transition system?
12:18:02 <conal> vixey: which haskell?  functional or imperative?
12:18:18 <gwern> dcoutts: wait, it will break horribly or it did before you changed --prefix?
12:18:45 <dcoutts> gwern: the point is you cannot install something into the global package db if it depends on things in the user package db
12:18:48 <vixey> I guess a state would be a graph
12:18:56 <dcoutts> gweiqi: you'll end up with missing deps
12:19:21 <dcoutts> gwern: sorry, I keep getting the wrong nick completion
12:19:46 <dcoutts> gwern: if you did --user --prefix=/usr/local then it'll work for you and not for any other users
12:19:56 <vixey> conal: I only know one haskell
12:19:59 <gwern> dcoutts: ok then. I asked because I've noticed not a few new xmonaders had trouble knowing when if to use --user
12:20:11 <gwern> perhaps they should be using cabal-install, but for most xmonaders that's not an option
12:20:37 <dcoutts> gwern: if they want to install into their home dir then yes, --user, if they want to install globally then --global
12:20:44 <conal> vixey: the answer would differ a lot between pure functional vs IO (imperative).
12:21:38 <dcoutts> gwern: if they want to install globally but they have dependencies that are installed per-user and not globally then they're stuffed, they'll have to install the deps globally too
12:21:59 <vixey> conal: I would like to model both (all of haskell) in one uniform way if possible
12:22:13 <dcoutts> gwern: hopefully in the future the install method will be simply $ cabal install xmonad
12:22:22 <dcoutts> once we've got cabal-install widely deployed
12:22:40 <gwern> dcoutts: yes, but until it's widely deployed... and even then there will be distro lag
12:22:55 <dcoutts> once you've got one version you're ok
12:23:02 <dcoutts> since you can $ cabal install cabal-install :-)
12:23:23 <conal> vixey: as *values* IO would fit in fine, but if you want to also model IO *execution*, it might look different.
12:23:35 <conal> vixey: besides, IO is just one data type out of many.
12:24:17 <dcoutts> @seen Igloo
12:24:18 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 20h 43m 16s ago.
12:24:20 <gwern> dcoutts: actually, I found it necessary to wrap 'cabal install' in 'function cabal-install () { cabal install --user -p --enable-executable-profiling --prefix=$HOME/bin "$@"' }'
12:24:38 <gwern> no config ability nor was it smart enough to turn on profiling etc. on its own
12:24:57 <dcoutts> gwern: all those defaults can be put in the ~/.cabal/config
12:25:23 <gwern> the what?
12:25:24 <dcoutts> --user is default already, --prefix defaults to $HOME/.cabal
12:25:31 <vixey> this is so hard ~_~
12:26:08 <conal> vixey: so a clearer way to ask "which haskell" might be: do you want to model just the semantics of Haskell, or of the IO also?  and maybe other some other data types as well.
12:26:25 <vixey> conal: I don't think IO should be special
12:26:40 <vixey> thinks like putChar would be primitves but other than that, no
12:26:56 <vixey> (I think I better prototype this idea..)
12:27:03 <conal> vixey: so you wouldn't model the semantics of IO?  that'd make things much simpler.
12:27:08 <vixey> probably iron out some confusion
12:27:21 <conal> vixey: but then why would you want to use state transitions instead of denotational semantics?
12:27:37 <dcoutts> Igloo: I recall you didn't like using ~/bin as the default for cabal-install, what was the reason again? I'm tempted to change it to ~/bin by default (you can change the bindir location in ~/.cabal/config)
12:27:39 <ddarius> vixey: Why do you want this?
12:27:48 <conal> vixey: nevermind my questions, if they're not helpful.
12:28:06 <vixey> conal: I don't think I can compare denotational semantics of two programs unless I know that they terminate
12:28:09 <Igloo> dcoutts: I think it might stomp on unsuspecting users' installations
12:28:18 <gwern> dcoutts: probably because not everyone wants a toplevel ~/bin
12:28:48 <gwern> .cabal is a reasonable solution, although I am a little perplexed as to how stuff in it is supposed to get into one's $PATH :)
12:28:48 <ddarius> vixey: Again.  Sure you can.
12:29:15 <conal> vixey: oh, back to that issue.  if you look at FRP, you may change your mind.
12:29:39 <vixey> I've looked at FRP, I'm not sure I get it
12:30:11 <vixey> I thought it was for modelling processes, like animation or interaction, I can't really see how to apply it to a language
12:30:11 <conal> vixey: besides, if you use an imperative approach to interaction, you'll probably want IO semantics, not Haskell semantics.
12:30:14 <dcoutts> gwern: well exactly, that's the issue. Most people have ~/bin in their $PATH so that's the obvious place to put things
12:30:48 <vixey> did my message got lost?
12:30:49 <geezusfreeek> good grief freenode!
12:30:58 * vixey just said "I thought it was for modelling processes, like animation or interaction, I can't really see how to apply it to a language"
12:31:33 <conal> vixey: languages have semantics, but so do data types.  FRP defines data types for non-terminating, interacting behaviors, with simple functional semantics.
12:31:44 <smg> hello.
12:31:47 <dcoutts> Igloo: so if we could be sure we were not stomping on user's stuff in ~/bin then it'd be ok do you think?
12:31:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8177
12:31:54 <conal> vixey: the language semantics and the data type semantics compose.
12:32:16 <dcoutts> Igloo: eg if we install to ~/.cabal/bin and then symlink into ~/bin so long as it doesn't already exist there
12:32:30 <smg> http://hpaste.org/8177 <-- the Bound Variables in this let expressions are: {u,a,w,x,f,b,a} Yes [ ] No [ ]
12:32:32 <smg> pelase answer :)
12:32:38 <gwern> but if you won't overwrite, then you forfeit being able to update any binaries in ~/bin
12:32:44 <Zao> print $ length allprimes -- gee I wonder why this didn't terminate...
12:33:07 <dcoutts> gwern: we know if it's one of ours if it's a symlink into ~/.cabal/bin
12:33:19 <dcoutts> gwern: and therefore it's ok to overwrite
12:33:24 <Zao> Wherever you put stuff, make it configurable. My multi-arch NFS home will be angry otherwise.
12:34:40 <smg> can someone look at that? i would be glad, vixey you maybe? :)
12:36:05 <smg> :(
12:36:15 <gubagem1> smg: i looked at it and became lost
12:36:18 <smg> :D
12:36:25 <smg> you don't need the calculation
12:36:35 <gubagem1> whats it calculate?
12:36:36 <smg> just think about the let expression and tell me the bound variables
12:36:44 <smg> bound variables :)
12:36:49 * gubagem1 is really bad with let 
12:36:50 <smg>  {u,a,w,x,f,b,a} should it be
12:37:43 <vixey> conal, does this approach seem sensible: define semantics of a mini-haskell using FRP and again for some kind of stack language (like an assembly or something similar) and given a program in each show they are bisimilar (to prove they are the same program)
12:38:14 <gubagem1> so if i want some sort of State in my haskell programs i need the State Monad or Im gonna have to keep passing the State "variable" around from function to function?
12:38:16 <gwern> dcoutts: take a look at http://hpaste.org/8176 - could one install into /usr/local/lib/X11-1.4.2/ghc-6.6.1
12:38:24 <gwern> and only have it show up in the per-user database?
12:38:32 <smg> i need vixey, he is the one and only :]
12:38:37 <ddarius> vixey: You could just use the denotational semantics of each.  No need to use bisimilarity there.
12:38:38 <dcoutts> gwern: you could do but it's a bad idea
12:38:43 <ddarius> smg: he is a she.
12:38:54 <smg> oh
12:39:00 <smg> i am sorry then
12:39:00 <smg> :|
12:39:22 <conal> vixey: i'd keep the mini-haskell and FRP semantics separate and composable.
12:39:33 <dcoutts> gwern: I'm not sure why you'd want to do that
12:39:44 <gwern> dcoutts: well I am asking if it's possible because this user's problems confuse me
12:39:45 <smg> ddarius: maybe you can figure out?
12:40:02 <geezusfreeek> dang i hate the tendency people have (i have it to) to assume there are no girls on the internet
12:40:07 <Armored_Azrael> smg: Sorry that I'm useless, but is that some kind of automated theorem prover for bound variables? (curiosity)
12:40:10 <geezusfreeek> *have it too
12:40:17 <dcoutts> gwern: oh you're trying to work out how a user got themselves into a mess?
12:40:30 <gwern> yeah, over in #xmonad
12:40:49 <smg> Armored_Azrael: i don't know i need to train that stuff on my own :D
12:40:52 * conal just used "--" as a comment in emacs lisp
12:41:06 <smg> Armored_Azrael: i can show free vars with ghci but not bound
12:41:31 <Igloo> dcoutts: Sounds OK to me
12:41:39 <dcoutts> Igloo: 'k
12:41:50 <dcoutts> @seen sjanssen
12:41:50 <lambdabot> sjanssen is in #gentoo-haskell, #haskell-blah, #xmonad and #haskell. I don't know when sjanssen last spoke.
12:42:26 <conal> vixey: i'm off to lunch.  will be back in a while if you'd like to continue.
12:42:52 <vixey> conal, thank you, I'm going to get a bit more familiar with FRP in the meantime
12:43:15 <smg> vixey: can you spend some time to me, it would be appreciated much
12:43:42 <vixey> smg: GHC will list all the free variables for you, you can use that to check your answers
12:43:52 <smg> yeah
12:43:58 <smg> but i need to calculate bound variables
12:44:11 <roconnor> > 65 + 38
12:44:12 <lambdabot>  103
12:44:13 <smg> http://hpaste.org/8177 my bound variables are:  {u,a,w,x,f,b,a}
12:44:25 <vixey> smg: list every variable, list every free variable
12:44:38 <smg> vixey: and then?
12:44:44 <smg> every variable \ { free_variables }
12:44:44 <vixey> smg: bound variables are the ones that occur in the list of every but do not occur in the list of free variables
12:44:44 <smg> ?
12:45:04 <smg> but look at the let expression there is u one time bound and one time not bound :)
12:45:07 <smg> is that possible?
12:45:45 <smg> vixey: u is free but also bound?
12:45:45 <vixey> then u is not a bound variable
12:45:53 <smg> it is not?
12:46:02 <smg> so c,g,u is free variables
12:46:09 <smg> that is true already, i verified with ghci
12:46:25 <smg> but now i have {u,a,w,x,f,b,a} and u is also bound in (\u -> u)
12:47:13 <vixey> what is '{u,a,w,x,f,b,a}'?
12:47:28 <smg> bound variables
12:47:34 <vixey> no it's not, u is free
12:47:43 <smg> i don't understand mh
12:47:56 <smg> (\u -> u) x
12:47:59 <smg> so u is not bound?
12:49:44 <smg> vixey: can you clarify this?
12:51:56 <botte> I had an evil idea.
12:52:08 <botte> JSP/PSP/ERB/PHP-style haskell.
12:52:12 <botte> Case in point:
12:52:21 <botte> <% flip concatMap [1,2,3] $ \i -> %>
12:52:27 <botte> Number <%= show i %>!
12:52:29 <botte> <% end %>
12:52:54 <therp> in 2 years we will have to send a terminator back into the past.
12:54:08 <smg> vixey: did you write something, bad netsplits
12:55:40 <ddarius> @where hsp
12:55:40 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
12:55:49 <ddarius> botte: ^
12:56:12 <gubagem1> where you go
12:56:21 <botte> ddarius: I hate humanity.
12:59:27 <izzy> hello, how can i see the source after TH macros are processed?
13:08:58 <FordCortina> @hoogle (Floating a) Rational -> a
13:08:58 <lambdabot> hoogle: src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
13:08:58 <lambdabot>  
13:09:09 <FordCortina> @hoogle (Floating a) => Rational -> a
13:09:10 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
13:09:10 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
13:09:17 <FordCortina> :)
13:09:34 <FordCortina> @botsnack
13:09:34 <lambdabot> :)
13:15:37 <ecks> hello, has anyone here worked with gtk2hs? im trying to add a popup menu to a tree view and all i could find is a little example in C
13:16:13 <dmwit> Well... the functions have very similar names.
13:16:20 <dmwit> Have you tried gtk2hoogle?
13:16:44 <gubagem1> are my "record accesors" in the same "namespace" as my variables and functions
13:16:47 <dcoutts> ecks: yeah, doing the equivalent of the C version should work
13:16:53 <kpreid> gubagem1: yes
13:17:13 <gubagem1> thank you kpreid
13:17:34 <dmwit> http://haskell.org/hoogle/?package=gtk
13:17:35 <lambdabot> Title: Hoogle
13:17:41 <Cale> gubagem1: Yeah, the record syntax is just sugar for defining those accessors, and allowing for some convenient pattern matching and update syntax.
13:17:48 <ecks> yes, i think i need a connect function that is supposed to be in System.Glib.Signals, but all they have is disconnect
13:26:15 <ecks> whoa, sorry
13:26:22 <dmwit> You're forgiven.
13:26:39 <dmwit> What did you do to cause that netsplit, though? ;-)
13:27:20 <glguy> maybe if we ban him the netsplits will stop
13:27:20 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:27:20 <ecks> i think my parents are watching streaming video
13:27:25 <heavensrevenge> hmm
13:27:48 <glguy> ?seen davidl
13:27:48 <lambdabot> davidl is in ##logic, #xmonad, #haskell-blah, #darcs and #haskell. I last heard davidl speak 16h 41m 45s ago.
13:27:49 <ecks> dmwit: ure probably right about that function though
13:27:50 <heavensrevenge> ive got stormy weather here
13:28:47 <davidL> glguy: hi
13:31:43 <ecks> what could the parameter for (event -> IO Bool) be though?
13:32:24 <ecks> oh, thats the function that we want called
13:32:30 <dmwit> yep, it's a callback
13:32:51 <dmwit> It returns True if it handled the event, or False if the event should be propogated to widgets hidden underneath the current one.
13:50:32 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html#v%3Aixmap
13:50:33 <lambdabot> http://tinyurl.com/5q8qp6
13:50:49 <Zao> The signature of ixmap doesn't look quite right, unless Haskell has magical function reversal functionality.
13:52:00 <opqdonut> Zao: you see it transforms the "incoming" index
13:52:43 <opqdonut> so you can give an i and it transforms it to j and gives the corresponding elem from the a j e
13:53:09 <Zao> Oh. Now I get it.
13:53:17 * Zao smacks his head gently.
13:53:39 <jaredj> is there a more haskellish way to store relational data than HDBC?
13:54:36 <dons> takusen?
13:54:48 <dons> there's many database bindings now, some higher, some lower level
13:55:35 <jaredj> is there, say, something to pickle maps?
13:55:51 <dmwit> show?
13:55:52 <dmwit> ;-)
13:55:57 <jaredj> -_-
13:56:03 <vixey> :t toList
13:56:04 <jaredj> k, yeah
13:56:05 <lambdabot> Not in scope: `toList'
13:56:46 <dmwit> jaredj: Is your Map gigabytes big, or going over a wire?
13:56:50 <jaredj> nope
13:57:03 <dmwit> I recommend show, then.
13:57:32 <dmwit> If it's gigabytes big, or going over a wire, *maybe* show + gzip. ;-)
13:58:21 <mmorrow> shogunzip!
13:58:33 <sjanssen> jaredj: you might also use binary if speed/compactness is required
13:58:33 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
14:03:35 <dcoutts> @seen bringert
14:03:36 <lambdabot> I saw bringert leaving #haskell-hac4, #ghc, #haskell.se and #haskell 1d 9h 48m 2s ago, and .
14:05:31 <RayNbow> that Wadler guy is awesome...
14:05:41 <RayNbow> I Google for "proofs are programs"
14:05:44 <RayNbow> http://homepages.inf.ed.ac.uk/wadler/papers/frege/frege.pdf <-- and I get this :)
14:08:10 <opqdonut> :)
14:08:27 <RayNbow> is it netsplits weekend? :p
14:08:33 <Valodim_> damn
14:08:55 <Valodim_> I wish all netsplits were ice cream
14:09:18 <RayNbow> Valodim_: that would be an awful lot of calories :p
14:09:22 <RayNbow> be careful ;)
14:18:33 <geezusfreeek> i'm thinking about logging off irc just because these netsplits are so annoying
14:19:36 <shachaf> geezusfreeek: Why not just ignore them?
14:19:50 <geezusfreeek>  /ignore netsplits?
14:19:55 <shachaf> (You are logging off and back onto IRC all the time, by the way. :-) )
14:20:42 <hjon> /ignore #haskell JOINS PARTS QUITS, if you're using irssi
14:21:42 <geezusfreeek> we'll see if that worked
14:21:57 <geezusfreeek> thanks
14:23:24 <GrayShade> where does Cabal take its default prefix path from on Windows?
14:25:54 <matthew_-> so if you differentiate a running program, I believe you should get the source code and maybe also the input to the program
14:26:11 <gubagem1> would it be to hard to ask for comma-less record syntax definitions using data
14:26:12 <dmwit> That statement is ?keal-worthy.
14:26:26 <dmwit> gubagem1: It's easy to ask for them. ;-)
14:26:34 <matthew_-> but this seems confused, because that means that integration of a source program is a running program
14:26:41 <matthew_-> but I don't see where the missing constant is
14:26:47 <opqdonut> matthew_-: input?
14:26:54 <matthew_-> or is it the schedular
14:27:28 <matthew_-> opqdonut: any input to the running program
14:27:40 <matthew_-> or are you saying that's the c too?
14:27:45 <ddarius> matthew-_: What are you talking about?
14:28:26 <dcoutts> GrayShade: the default prefix is built-in, cabal-install has a config file
14:28:27 <matthew_-> ddarius: the differentiation and integration of computer programs
14:28:58 <dmwit> ?remember matthew_- so if you differentiate a running program, I believe you should get the source code and maybe also the input to the program
14:28:58 <lambdabot> I will remember.
14:29:01 <dmwit> Liar!
14:29:51 <SamB> matthew-_: what makes you think this?
14:29:56 <GrayShade> dcoutts: i remember i could use the register option of cabal without specifying a prefix directory even if i did not have ghc installed to the default one. now it doesn't seem to work anymore even if i provide it
14:30:00 <matthew_-> SamB: a heavy cold
14:31:28 <dcoutts> GrayShade: I'm not quite sure what you mean
14:31:37 <opqdonut> i once had a very high fever
14:31:52 <opqdonut> and i thought i was the Z/Z8 ring
14:31:56 <dcoutts> GrayShade: you can optionally specify a --prefix at configure time and a --user/--global flag
14:32:21 <gubagem> opqdonut: is that a ring modulo 8?
14:32:23 <matthew_-> opqdonut: you're sure you hadn't just taken LSD?
14:32:38 * gubagem chuckles at matthew_
14:32:38 <opqdonut> gubagem: yeah
14:32:46 <matthew_-> and happened to be doing revision on cryptography at the time?
14:33:16 <GrayShade> dcoutts: http://monoport.com/17026
14:33:18 <opqdonut> i had actually been attending a Galois theory course
14:33:19 <lambdabot> Title: mono pastebin
14:33:26 <opqdonut> that's where i think it came from
14:34:15 <matthew_-> is calculus defined for set theory?
14:34:37 <gubagem> if you have a continous set it might be
14:34:45 <ddarius> The standard differential and integral calculus is defined over continuous functions.
14:34:52 <gubagem> though isnt calculus just functions that take functions and return functions
14:35:04 <Cale> matthew_-: in what sense?
14:35:18 <Cale> Which calculus? :)
14:35:25 <matthew_-> Newtonian
14:35:27 <SamB> gubagem: they have to be continuous, more or less
14:36:23 <Cale> Well, the usual calculus is built in terms of set theory in some sense, but you need more structure than just an arbitrary set of values in order to define things like the derivative.
14:36:42 <matthew_-> right
14:37:09 <Cale> even to discuss limits alone takes some notion of what it means to be close to a point
14:37:10 <vixey> stuff like there exists a lub is all set theory
14:37:11 <dcoutts> GrayShade: it looks like you're registering the package without having first installed it
14:37:31 <matthew_-> so are there requirements basically analogous to well formedness?
14:37:31 <vixey> at least I think it is
14:37:33 <hpaste>  gubagem pasted "whats the proper thing if I want a Map from Data.Map in a "data" structure" at http://hpaste.org/8179
14:37:37 <dcoutts> GrayShade: so ghc-pkg does indeed complain that the files don't exist
14:37:39 <matthew_-> that you don't define an inconsistent system?
14:37:45 <ddarius> vixey: least already requires a notion of ordering in addition to just a set of values
14:38:05 <GrayShade> dcoutts: aargh. i forgot about the install option (:
14:38:23 <GrayShade> thanks
14:38:24 <Cale> matthew_-: Well, even to write down definitions which you can say are analogues of the usual definitions in calculus on the real line, you need to make additional assumptions, so that you can talk about certain things.
14:38:32 <dcoutts> GrayShade: right, runhaskell setup install copies the files and registers all in one go
14:38:59 <dcoutts> GrayShade: so as far as I know none of this stuff has changed, or do you think it has?
14:39:30 <Cale> matthew_-: The appropriate generalisations include things like metric spaces, topological spaces, normed vector spaces, and so on.
14:39:39 <GrayShade> dcoutts: i don't remember in installing the files in the wrong folder, but i assume it always did that
14:39:52 <matthew_-> Cale: ok, and for example Conor's differentiation of zippers (type of a one hole context) do this stuff?
14:39:55 <Cale> (and for integration, measure spaces)
14:40:10 <Cale> Oh, that's an altogether different kind of derivative :)
14:40:20 <GrayShade> dcoutts: 'wrong' in the sense of "why does it insist to use c:\program files when it knows ghc is located somewhere else?"
14:40:25 <Cale> Yeah, I forgot to mention that sort of thing.
14:40:38 <matthew_-> feel free to educate me :)
14:40:54 <dcoutts> GrayShade: the place where it installs haskell libs and progs is unrelated to where ghc is installed
14:41:24 <ecks> hello, is there a way to map over tuples?
14:41:31 <ddarius> No
14:42:13 <Cale> Well, it's sort of a generalisation in terms of the algebra rather than in terms of the analytic properties (distance and so on)
14:42:33 <dcoutts> GrayShade: the default is deliberately the windows "standard place" for installing software rather than wherever one happened to install ghc, you can of course tell it to put stuff in the same dir as where ghc lives though I'm not sure it's a good idea
14:42:41 <ecks> oh ok
14:42:45 <GrayShade> @src bimap
14:42:45 <lambdabot> Source not found. :(
14:42:49 <matthew_-> Cale: right, so it follows the same general rules and seems to be roughly analagous
14:42:51 <ddarius> http://en.wikipedia.org/wiki/Derivation_(abstract_algebra)
14:42:58 <dcoutts> GrayShade: btw, if you're a windows and a cabal user we'd really appreciate any testing of the new cabal-install on windows
14:43:05 <Cale> matthew_-: yeah
14:43:13 <grahamhutton> ecks: yes, but not in a generic way, which is I guess what you mean.
14:43:19 <matthew_-> ddarius: tnx
14:43:34 <grahamhutton> e.g. map for pairs is defined as map f (x,y) = (f x, f y)
14:44:01 <RayNbow> hmm... why aren't tuples instances of Functor?
14:44:12 <Cale> Another fun kind of differentiation on the natural numbers defines the derivative of a prime to be 1, and the derivative of a composite number xy to be D(xy) = xD(y) + D(x)y
14:44:31 <dcoutts> RayNbow: which part would they be a functor in? fst or snd?
14:44:53 <Cale> (and D(0) = 0)
14:45:03 <matthew_-> so you get the number of prime factors?
14:45:04 <RayNbow> oh right
14:45:07 <Cale> not quite
14:45:12 <RayNbow> dcoutts: I see the problem :)
14:45:54 <Cale> It matters what those factors are as well.
14:46:05 <Cale> For example, in the case of a product of two primes
14:46:12 <Cale> D(pq) = p + q
14:46:31 <matthew_-> yep
14:47:17 <Cale> http://cale.yi.org/index.php/Arithmetic_Derivative
14:47:19 <lambdabot> Title: Arithmetic Derivative - CaleWiki
14:47:39 <matthew_-> ok, so a) my maths sucks and b) I'm ill. What do you do in this case if the number is a composite xyz or greater?
14:48:03 <Cale> Well, you split it up in any way that you like :)
14:48:04 <eu-prleu-peupeu> hello
14:48:47 <matthew_-> so you have multiple solutions?
14:48:55 <Cale> Nope, they all give the same result.
14:49:14 <matthew_-> oh yeah. Oops.
14:49:57 <Cale> D((xy)z) = D(xy) z + x y D(z) = (D(x) y + x D(y)) z + x y D(z) = D(x) y z + x D(y) z + x y D(z)
14:50:11 <Cale> and D(x(yz)) ends up the same way
14:51:10 <matthew_-> yep yep. As in fact is stated on the wiki page ddarius linked to
14:53:40 <matthew_-> ok, I need to sleep. thanks for your help
14:54:29 <gubagem> how do i redirect console output to a file under windows XP commandline?
14:54:42 <GrayShade> gubagem: use command > filename
14:54:53 <gubagem> k
14:55:28 <gubagem> didnt work
14:55:58 <GrayShade> gubagem: "yourprogram > filename" ?
14:56:05 <GrayShade> gubagem: without quotes
14:56:54 <GrayShade> gubagem: if the output still shows up in the cmd window, it's writing to stderr so you must use "yourprogram 2> filename"
15:00:18 <hpaste>  morrow pasted "*so* epic" at http://hpaste.org/8180
15:09:11 <GrayShade> dcoutts: i can't compile cabal-install because it depends on a cabal version older than mine and i can't compile an older cabal because of a strange error about not finding the SHGetFolderPathA@20 in an import library
15:22:34 <hpaste>  morrow annotated "*so* epic" with "are these equivalent (or which is better?)" at http://hpaste.org/8180#a2
15:23:58 <hpaste>  morrow annotated "*so* epic" with "ppr'ed view" at http://hpaste.org/8180#a3
15:25:54 <smg> vixey: hey! are you in? i managed it
15:25:58 <mmorrow> does anyone have thoughts as to which is "better" here: http://hpaste.org/8180#a2 ??
15:28:56 <mm_freak> @src (>>=) :: a -> (a -> State s a) -> State s a
15:28:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:29:00 <smg> hello Cale :)
15:29:11 <mm_freak> @src Control.Monad.State.(>>=)
15:29:12 <lambdabot> Source not found. :(
15:29:13 <smg> Cale: if you are in, may you answer me, i need to ask you something ;)
15:29:27 <mmorrow> long story short...    ListP []       vs.      ConP GHC.Base.[] []
15:29:40 <GrayShade> mmorrow: they're probably the same
15:29:47 <mmorrow> i suppose it has to do with rebindable syntax, but i thought you can't redefine []?
15:30:39 <Saizan_> no, you can't
15:31:01 <mmorrow> GrayShade: cool, that's how i feel too.
15:31:15 <mmorrow> Saizan_: any thoughts on why th says  ConP GHC.Base.[] []?
15:31:46 <GrayShade> mmorrow: if you look at the core generated from something like 1 : [] you'll see it uses GHC.Base.[] too
15:32:07 <Saizan_> mmorrow: because they didn't special cased [] in the quoter i guess
15:32:37 <mmorrow> ahhh, makes sense, since i *did* special case it
15:32:40 <mmorrow> thx
15:34:21 <Saizan_> maybe ConE GHC.Base.() should be TupE [] then
15:34:44 <tusho> HASKELL
15:35:27 <mmorrow> good point, consistency is underrated
15:36:48 <cjb> b
15:36:50 <cjb> oops
15:40:57 <mmorrow> GrayShade: were you refering to in pattern context, expression context, or both?
15:42:12 <GrayShade> mmorrow: i think Saizan_ was right and it's just a special casing issue
15:43:36 <mmorrow> yeah, me too. i was just curious about what you meant about it being GHC.Base.[] in the core. i think i see what you meant though.
15:52:18 <leoncamel> is there any good books for newbies ? currently, I am reading the book from wikibooks. But, I can't catch the whole grammar structure of haskell. is there any suggestion ?
15:54:12 <atp> you want a book?
15:54:26 <atp> there's one on-line that is currently being developed by dons & co
15:54:33 <vixey> ?where report
15:54:33 <lambdabot> http://www.haskell.org/onlinereport/
15:54:39 <vixey> the whole syntax of haskell is described there
15:54:46 <atp> vixey: he asked for a book for newbies
15:55:01 <atp> on top of it, english is clearly not his first language
15:55:08 <atp> you're not helping
15:55:43 <audreyt> leoncamel: http://book.realworldhaskell.org/beta/
15:55:44 <lambdabot> Title: Real World Haskell
15:56:38 <leoncamel> OK, thanks you all, :)
15:56:41 <atp> audreyt: thanks
15:56:46 <vixey> atp: I don't tend to think other people than me are less capable
15:56:51 <atp> leoncamel: the book audrey suggested is the one i was thinking
15:57:07 <vixey> atp: it *is* a good resource
15:57:19 <atp> vixey: it is indeed, but not if you're a newbie
15:57:59 <leoncamel> vixey, yes, but there are few chapters which are not finished now.. :)
15:58:50 <atp> leoncamel: i think there are japanese language haskell resources too
15:59:42 <leoncamel> atp, Aha, but, I need a English one.
16:00:26 <Armored_Azrael> leoncamel: Try this one http://www.haskell.org/tutorial/
16:00:26 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
16:00:54 <Armored_Azrael> leoncamel: I learned from that one, then followed up with the haskell report to learn the rest of what the specification was and fill in the gaps.
16:01:10 <atp> the gentle introduction to haskell is not bad, especially if you have functional language experience
16:01:17 <atp> i learned haskell from that
16:01:34 <atp> but i've heard people who have no functional language experience describe it as difficult
16:01:45 <atp> another popular one is yaht
16:02:17 <atp> i think yaht isn't bad, and it describes IO early on, which makes it fairly distinctive
16:02:37 <atp> lambdabot: yaht?
16:02:42 <atp> hm
16:02:46 * atp pokes lambdabot.
16:03:09 <atp> http://darcs.haskell.org/yaht/yaht.pdf
16:04:08 <atp> ?where yaht
16:04:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:04:10 <atp> ah
16:08:10 <leoncamel> ok, thanks.
16:21:59 <nus> first time I tried to read the gentle introduction, it was like "good, aha.. yep... stop! WTF is going on?! why the hassle" am reading Cardelli papers now (-:
16:25:01 <ecks> actually, the haskell for C programmers one was good when i had no idea what fp was
16:25:18 <ecks> ?where Haskell for C Programmers
16:25:18 <lambdabot> http://haskell.org/
16:25:19 <Smokey`> is there a 'haskell for C++ programmers'?
16:25:33 <lament> i'm not sure who the intended audience for the gentle introduction are
16:26:03 <lament> i think, by this point, anybody in this intended audience already knows haskell (as opposed to, say, Miranda), and so the whole document can be just taken down and shot.
16:26:11 <nus> lament, fellow typed fp'ers, namely ML-aware people, it seems
16:26:30 <Smokey`> I've used Haskell up to the point of being able to write a ray tracer - a very slow one at that ;) - but there were still many MANY things I didn't understand about Haskell (Monads, and creating a 'class' in C++ terms)
16:26:40 <Armored_Azrael> lament: Quite frankly, I would have had a problem reading the report cold, but reading the introduction allowed me to read the report.
16:27:02 <vixey> yes, knowing haskell and being able to write useful/cool programs in it are two totally separate things
16:27:09 <Smokey`> indeed.
16:27:10 <dons> Smokey`: why was your ray tracer slow?
16:27:12 <vixey> mostly because of the type system
16:27:32 <dons> nah, useful haskell these days is just gluing together hackage packages.
16:27:35 <vixey> ghc says, "no that's not quite right, try this instead.."
16:27:51 <dons> read the types, they go together only a few sensible ways, glue code guided by types.
16:27:55 <Smokey`> dons: I had no idea the difference between boxed and unboxed types at the time, as such I was using quite a lot of slow list/aray types.  in some places I was lazily calling functions I shouldn't have been, etc
16:28:23 <dons> using lists as arrays is a typical scenario for new users complaining about speed
16:28:25 <ecks> i think of data types more as classes in terms of C++ or java
16:28:50 <Smokey`> this was over a year ago, I haven't touched Haskell since - although recently my interest has picked back up again...
16:29:03 <ecks> since u have constructors and accessors
16:29:06 <Armored_Azrael> Smokey`: DiffArray is an awesome thing for writing any kind of graphics processing
16:29:10 <dons> also, forgetting to compile the code, and forgetting to turn on -O
16:29:17 <dons> Armored_Azrael: have you found that?
16:29:29 <dons> i've not heard of any diff arrays good news stories for a long time.
16:29:39 <Armored_Azrael> dons: Yes. I wrote a basic polygon renderer with gourad and phong shading.
16:29:58 <dons> cool. you should stick it on hackage. diff arrays examples are useful
16:30:06 <Armored_Azrael> dons: Using diffarrays over normal arrays gave me a huge speedup without having to sacrifice the ability to use old copies of the arrays, for example for doing phong calculations
16:30:18 <dons> that's great.
16:30:42 <Armored_Azrael> dons: I will, but I can't until the end of the summer--it's technically for a class, and if I put it online beforehand, I'll have to go through the whole rigamarole with demonstrating the guy on the internet is me.
16:30:57 <lament> not sure how appropriate it is to think of anything in haskell as C++ or Java classes
16:31:08 <SamB_XP> Armored_Azrael: not everything graphics involves mutation
16:31:39 <Smokey`> lament: are you saying Haskell doesn't support OOP?
16:31:48 <lament> Smokey`: well, yes.
16:31:58 <lament> it doesn't.
16:32:00 <SamB_XP> Smokey`: is that a problem?
16:32:37 <leoncamel> ok. here is a stupid question. "myfunc :: a -> b" is same with "myfunc :: some_type_a -> some_type_b" ?
16:32:51 <ecks> i read somewhere that fp is the opposite of oop
16:33:14 <SamB_XP> ecks: I doubt it
16:33:28 <SamB_XP> I think if that were so, OOP would be more clearly understood ;-)
16:33:33 <Saizan_> leoncamel: yes, lower case identifiers are variables
16:33:42 <SamB_XP> also we use the word "dual", not "opposite"
16:33:46 <Smokey`> SamB_XP: it can be, at least for my purposes.
16:34:15 <dons> interrresting, http://www.reddit.com/info/6mgfr/comments/
16:34:16 <lambdabot> Title: reddit.com: JavaScript with Arrows (and Monads) :: PDF
16:34:31 <Armored_Azrael> http://mirrors.matthewmaurer.org/FrozenRender-0.1.tar.gz has some bugs still, but should demonstrate some basic concepts.
16:34:35 <leoncamel> Saizan_, thanks .. :)
16:34:38 <lament> SamB_XP: but we OOP programmers use "opposite" :)
16:34:48 <Armored_Azrael> (I can put it there, because that server is rather obviously under my control for purposes of proving to my prof that it is actually my stuff)
16:34:55 <Armored_Azrael> If you want to extract any snippets, that's cool
16:39:14 <SamB_XP> Armored_Azrael: you ... don't have a name ?
16:41:34 <Armored_Azrael> SamB_XP: I do have a name. I suppose that this might work. I also am slightly embarrassed by it, as it is nowhere near quality :P (I'm mostly just making excuses so that I don't permanently publish some of my work that's not particularly good)
16:41:53 <Smokey`> :)
16:42:02 <SamB_XP> Armored_Azrael: fair enough ;-)
16:52:51 <Armored_Azrael> SamB_XP: My latest code is actually more kludgy than that stuff, but has some reason due to needing to be embedded inside postgres :P
17:00:02 <atp> how much fold fusion does ghc do these days
17:00:27 <atp> will it rewrite a map f (reverse xs) into a single catamorphism, or will i incur two list traversals?
17:01:15 <atp> since in general it seems that map f (reverse xs) = foldl ((.f) . (flip (:))) xs
17:01:21 <vixey> atp: I don't know if that'll be done but you can add such rules as pragmas if you want
17:01:32 <dolio> That probably doesn't fuse.
17:01:44 <atp> this is a fairly simple example but it seems that it should be pretty trivial to write a general case if you have two left folds
17:01:56 <atp> map is implemented as foldr, but could be either
17:02:05 <atp> so the compiler would have to know that
17:02:10 <dolio> ghc does foldr/build fusion currently.
17:02:34 <atp> oh, you mean like hylomorphisms?
17:02:37 <dolio> And I doubt reverse goes through build.
17:02:44 <atp> i'm not sure what you mean by build
17:02:51 <dolio> No, not hylo fusion.
17:02:55 <dolio> @type build
17:03:06 <atp> :t build
17:03:12 <atp> hm
17:03:15 <lambdabot> Not in scope: `build'
17:03:20 <atp> where is it defined
17:03:44 <dolio> GHC.List, I think.
17:03:47 <dmwit> ?index build
17:03:47 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.Exts
17:03:55 <dmwit> :t GHC.Exts.build
17:03:57 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
17:04:03 <dmwit> That looks like it.
17:04:08 <dolio> There you go.
17:04:46 <dolio> Anyhow, 'foldr g z (build k) == k g z' or something like that.
17:04:48 <dmwit> That looks magical.
17:04:52 <atp> hm
17:04:55 <dmwit> ?src build
17:04:55 <lambdabot> build g = g (:) []
17:05:17 <atp> ah.
17:05:42 <dmwit> oh
17:05:46 <dmwit> interesting
17:05:50 <atp> that's a bit less sexy than generic fold fusion...
17:06:11 <dolio> So, things taht can be implemented in terms of build are good producers, and if they're followed by good consumers, you can deforest them.
17:06:37 <dolio> Good consumers being foldrs.
17:07:22 <atp> it seems like it should be generally possible to do fairly extreme fold fusion though in a pure context at any rate
17:07:29 <dolio> There may be slightly more to it than that, but I'm not sure.
17:07:54 <dolio> Yeah, well, if you want state of the art, there's a package on hackage that has stream fusion for lists.
17:08:09 <atp> perhaps that's what i'd seen
17:08:16 <dolio> But it hasn't been rolled into GHC yet.
17:08:26 <atp> there are plans to put it in though?
17:08:51 <dolio> There were. It was supposed to go in in 6.8 and then 6.10, but now dons is saying it's not going in there, either.
17:09:06 <atp> did he write it?
17:09:10 <atp> concerns, perhaps?
17:09:18 <dolio> Him and dcoutts, I think.
17:09:23 <atp> ah
17:10:05 <atp> it certainly would be nice to be able to generically string together opaque library functions and have the compiler automatically minimize the number of list traversals
17:10:12 <atp> improves code reuse
17:10:53 <atp> and unlike other sufficiently smart compiler wishlist-type features, this one doesn't seem, at least naively, to be too far beyond our current abilities
17:11:15 <atp> but i'll admit that i know too little about the implementation issues to say that with any certainty
17:11:23 <dolio> Yeah, well, dons also has a new array library, uvector, with stream fusion.
17:11:37 <atp> yeah, i've seen him playing with that.  apparently quite fast.
17:11:42 <dolio> Currently it's pretty much exclusively a means of operating on streams.
17:11:50 <atp> nod
17:12:16 <dolio> So it's essentially the same as what I'd expect that list library to be (although it may have less constraints on the strictness of certain functions).
17:12:27 <atp> interesting
17:13:14 <dolio> Of course, in the future there will be actual immutable arrays to work with (it currently doesn't export an interface for that).
17:13:21 <dolio> @hackage stream-fusion
17:13:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion
17:13:24 <atp> as i see it haskell's great strength (as a result of its functional purity) is not so much how well it parallelizes (although that too is neat) but rather in the ability the compiler has to rewrite your code algebraically
17:13:33 <atp> at least theoretically
17:13:45 <atp> it allows amazing code reuse
17:13:46 <dolio> That's the list one. You should be able to drop that in and get speed boosts for list code.
17:13:53 <atp> i'll take a look at it
17:13:57 <atp> thanks much dolio
17:14:05 <dolio> No problem.
17:15:41 <ddarius> The issue with stream fusion is that it doesn't handle nested concatMaps as well as the current fusion stuff.
17:16:19 <ddarius> atp: As others have said, you can add your own rewrite rules (in GHC) to express specific rewrites you want.
17:16:29 <atp> ddarius: yeah, i know that.
17:16:45 <atp> ddarius: in this case i'll just manually fuse the folds, though.
17:22:34 <ecks> has anyone had problems running the opengl demo at http://darcs.haskell.org/gtk2hs/demo/opengl/?
17:22:36 <lambdabot> Title: Index of /gtk2hs/demo/opengl
17:23:11 <ecks> opengl seems to work with everything else though
17:28:05 <dolio> @type \f l -> GHC.Exts.build (\c z -> foldr (c . f) z l)
17:28:06 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
17:35:15 <mar77a> @src (++)
17:35:15 <lambdabot> []     ++ ys = ys
17:35:15 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:35:15 <lambdabot> -- OR
17:35:15 <lambdabot> xs ++ ys = foldr (:) ys xs
17:35:15 <lambdabot> -- In lambdabot, this is generalised to:
17:35:17 <lambdabot> (++) = mappend
17:36:16 <dolio> @type GHC.Exts.augment
17:36:18 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
17:37:47 <dolio> @type \l -> augment (\(:) z -> foldr (:) z l)
17:37:49 <lambdabot> Not in scope: `augment'
17:38:06 <dolio> @type \l -> GHC.Exts.augment (\(:) z -> foldr (:) z l)
17:38:08 <lambdabot>     Couldn't match expected type `a -> b -> b'
17:38:08 <lambdabot>            against inferred type `[a1]'
17:38:08 <lambdabot>     In the pattern: :
17:39:39 <Saizan_> ?ty GHC.Exts.build
17:39:40 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
17:40:08 <dolio> @type \l -> GHC.Exts.augment (\c z -> foldr c z l)
17:40:10 <lambdabot> forall a. [a] -> [a] -> [a]
17:40:30 <ddarius> @src Num
17:40:31 <lambdabot> class  (Eq a, Show a) => Num a  where
17:40:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:40:31 <lambdabot>     negate, abs, signum     :: a -> a
17:40:31 <lambdabot>     fromInteger             :: Integer -> a
17:40:49 <dolio> > (\l -> GHC.Exts.augment (\c z -> foldr c z l)) [1..5] [6..10]
17:40:50 <lambdabot>   Not in scope: `GHC.Exts.augment'
17:42:11 <ddarius> @src Fractional
17:42:11 <lambdabot> class  (Num a) => Fractional a  where
17:42:11 <lambdabot>     (/)             :: a -> a -> a
17:42:11 <lambdabot>     recip           :: a -> a
17:42:11 <lambdabot>     fromRational    :: Rational -> a
17:45:35 <nus-> ehm, is referential transparency about functors not being functions?
17:46:21 <vixey> referetial transparency means the return value of a function only depends on its input
17:46:43 <ddarius> Referential transparency just means if a = b then everywhere there is an a you can replace it with b without changing the meaning of the program.
17:46:48 <mar77a> > [0..] !! 520163
17:46:50 <lambdabot>  520163
17:46:56 <mar77a> gives stack overflow for me
17:46:59 <mar77a> :[
17:47:06 <ddarius> mar77a: Compile with optimizations.
17:47:14 <mar77a> ghci
17:47:43 <ddarius> mar77a: Many definitions in GHC require strictness analysis to work properly.
17:48:42 <nus-> ddarius, so, given monads, functions became objects, right?
17:49:08 <ddarius> nus-: Where are you getting this idea?
17:49:32 <nus-> or am I talking about state monads?
17:50:28 <nus-> ddarius, nowhere particular, just discovered there's distinction 'tween functors in category theory and in CS
17:54:47 <ddarius> Functors in Haskell are pretty much a special case of functors from category theory.
17:55:08 <ddarius> Neither of them mean anything remotely like the term "functor" as used in the OO community.
17:57:26 <nus-> ddarius, yep, that much I figured
17:59:19 <nus-> okay, this seems to be a right direction http://lucacardelli.name/Slides/1997-06%20Everything%20is%20an%20Object%20(ECOOP%20Prototypes%20Workshop).pdf
17:59:21 <lambdabot> http://tinyurl.com/6ojqpx
18:03:10 <pjdelport> what's a good example of using intercalate with non-strings?
18:04:16 <ddarius> > intercalate (' ':) $ map shows [1..10] $ []
18:04:17 <lambdabot>  Couldn't match expected type `[a]'
18:04:25 <ddarius> > (intercalate (' ':) $ map shows [1..10]) []
18:04:26 <lambdabot>  Couldn't match expected type `[a]'
18:04:31 <ddarius> :t intercalate
18:04:33 <lambdabot> forall a. [a] -> [[a]] -> [a]
18:04:46 * ddarius was thinking of the mconcat . intersperse
18:04:48 <pjdelport> nus-: it might be useful to think of FP as "value-oriented programming"
18:06:52 <nus-> pjdelport, "there's no spoon^W FP..."
18:09:16 <nus-> a freaking set of applicative [[:greek-alphabet:]]-calculus interpretations
18:09:32 <pjdelport> nus-: ?
18:09:43 <nus-> FPLs, I mean
18:10:26 <ddarius> FP handles the π and σ calculi poorly
18:15:33 <SamB_XP> ddarius: no kidding
18:16:05 <SamB_XP> ... my question to you is: what doesn't?
18:17:05 * vixey can't see those symbols..
18:17:21 <SamB_XP> pi and sigma
18:17:26 <SamB_XP> lowercase both
18:17:34 <vixey> oh I never heard of sigma-calc
18:17:41 <ddarius> SamB_XP: A concurrent object language should be able to handle both reasonbly nicely.
18:18:09 <nus-> SamB_XP, CLOS?
18:18:12 <SamB_XP> ddarius: are there any theorem provers that do?
18:18:45 <nus-> for varios definitions of "poorly"
18:18:46 <SamB_XP> nus-: an OO library isn't going to help with concurrency
18:19:24 <nus-> SamB, you mean the π-one?
18:19:31 <ddarius> SamB_XP: Theorem provers that use π or σ as the proof language?
18:19:49 <SamB_XP> ddarius: that handle them well, I make no restrictions on the proof language
18:20:04 <ddarius> So just a theorem proving system that can handle them well?
18:20:12 <SamB_XP> uh huh
18:20:32 <vixey> SamB: you seem very interested in proofs wrt concurrency..
18:20:36 <ddarius> In that case, there isn't an implementation, but the CLF can do π well with no problem.
18:20:55 <vixey> did you have something in mind?
18:21:06 <SamB_XP> vixey: I just know it's hard
18:21:29 <ddarius> There are probably some specific systems to handle modeling the π calculus.
18:21:32 <SamB_XP> and important
18:21:43 <ddarius> I don't think the σ calculus ever went anywhere.
18:22:11 <SamB_XP> to be able to prove things about concurrent systems, I mean
18:22:22 <ddarius> SamB_XP: You've looked at CLF?
18:22:31 <SamB_XP> nope
18:22:41 <ddarius> @google "Concurrent Logical Framework"
18:22:43 <lambdabot> http://www.cs.princeton.edu/~dpw/talks/CLF.ppt
18:22:51 <SamB_XP> I've barely even looked at LF
18:23:38 <SamB_XP> that powerpoint file will be quite useful </sarcasm>
18:27:32 <nus-> so far all "soundness" talk I've been able to follow (not much), quickly degraded to philosophy and consequences of the Goedel theorem
18:27:36 <ddarius> http://citeseer.ist.psu.edu/watkins03concurrent.html
18:27:37 <lambdabot> Title: A concurrent logical framework I: Judgments and properties - Watkins, Cervesato, ...
18:28:08 <vixey> nus-: 'degraded'..? that stuff is relevant
18:29:00 <ddarius> All the soundness stuff I've followed recently has quickly degraded into morasses of proofs.
18:29:53 * lament understands nus- 
18:30:33 <lament> people should be prohibited from mentioning godel's theorem outside math courses :)
18:30:55 <ddarius> lament: He's looking at the soundness of stuff that doesn't have much to do with programming
18:31:33 <nus-> ddarius, define 'programming'
18:31:41 <QtPlatypus> lament: Can Comp Sci people talk about it in terms of a concequence of the undecidability of the halting problem? (THough by that point your comp sci course is very much a math cause).
18:32:12 <lament> one of my favourite university moments was when on a probability lecture (fairly easy math course so full of econ/arts people), after the prof explained iirc Bayes, somebody fully seriously asked the prof what are the consequences of godel's theorem to this
18:32:48 <lament> QtPlatypus: they can talk about it. They perhaps shouldn't talk about the "philosophical consequences"
18:33:34 <nus-> programming as in making computers do what they supposedly meant to?
18:33:40 <ddarius> lament: The Bayesian perspective tends to be that probability is a reflection of what we know and as such Goedel's incompleteness theorem may bring up some interesting aspects, though aspects that don't matter in any real applications.
18:33:58 <lament> ddarius: no it may not! argh. et tu ddarius.
18:34:27 <SamB_XP> ddarius: how are they interesting if they never ever ever ever ever ... matter?
18:34:35 <lament> (besides, he wasn't talking about bayesian stats, just the bayes theorem in the context of an introductory probability course)
18:34:48 <ddarius> SamB_XP: They never matter -in practice-.
18:34:51 <psygnisfive> bwahaha!
18:34:57 <lament> ddarius: bayesian stats has nothing to do with godel.
18:35:00 <mmorrow> @src levels
18:35:00 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:35:05 <mmorrow> :t levels
18:35:05 <lament> "what we know" has nothing to do with godel.
18:35:06 <lambdabot> forall a. Tree a -> [[a]]
18:35:07 <psygnisfive> i just implemented haskell's list monad's >>= and filterM in JS
18:35:07 <psygnisfive> :D
18:35:12 <SamB_XP> ddarius: if they never matter in practice, they never matter in theory
18:35:15 <mmorrow> @src Tree
18:35:16 <lambdabot> Source not found. Wrong!  You cheating scum!
18:35:19 <psygnisfive> and return
18:35:20 <psygnisfive> :D
18:35:24 <psygnisfive> its brilliant :D
18:35:28 <SamB_XP> at least, in theory that is practical
18:35:28 <ddarius> SamB_XP: Tell the theorists that.
18:35:31 <lament> ddarius: in fact, nothing has anything to do with godel, except a bunch of related theorems like the halting problem.
18:35:56 <lament> there are no philosophical consequences. There're only mathematical consequences and they're all fairly straightforwadrd.
18:36:00 <SamB_XP> if things that never matter in practice matter in theory, the theory is wrong. or the people who said never shouldn't have done.
18:36:00 <lament> -d
18:36:18 <lament> so shut up and calculate :)
18:36:31 <psygnisfive> lament: stop ripping off feynman
18:36:41 <lament> ("Shut up and program?" - a guide to Haskell)
18:36:50 <psygnisfive> :)
18:37:46 <pjdelport> "Shut up and type"
18:38:35 <TomMD> What is the smart way to poke a bytestring?  I am looking for an efficient functional equiv of "pokeArray ptr (B.unpack bs)".  Which I use in FFI marshalling to C structs that have byte arrays.
18:39:33 <bd_> TomMD: Doing so breaks referential transparency ... so I'd argue it's fundamentally not smart :)
18:39:39 <TomMD> Perhaps I should instead ask how is best to peek/poke byte arrays.  I know of the [unsafe]useAsCString[Len] functions, but those aren't useful inside a storable instance (e.g, inside poke).
18:39:49 <QtPlatypus> psygnisfive: If your going to rip off from someone, at least you should rip off from the best.
18:39:59 <psygnisfive> true enough :D
18:40:00 <bd_> TomMD: There's the Data.Array.Storable stuff...
18:44:47 <sjanssen> TomMD: a combination of withForeignPtr and memcpy, I suppose
18:45:06 <TomMD> Lets put it this way, I have a data type "data Foo = Foo { x :: Word64, y :: ByteString, z :: ByteString }", so 'y' lives on the Haskell stack and has no real reason to be copied.  I have a function '''foreign import ccall unsafe "hdr.h operateFoo" operateFoo :: Ptr Foo -> IO CInt'''.
18:45:50 <TomMD> Can I do this without copying 'y', which I know won't be touched by operateFoo, but peeking 'z' back into the Haskell stack?
18:46:37 <bd_> peeking z back?
18:46:43 <bd_> what do you mean?
18:47:22 <TomMD> The higher level function that uses 'operateFoo' would, in part, perform "with fooInstance $ \fooPtr -> operateFoo >>= peek fooPtr"
18:48:06 <sjanssen> TomMD: unsafeUseAsCStringLen won't require any copying
18:48:17 <bd_> TomMD: what's the semantics of operateFoo?
18:48:34 <TomMD> But I can't just throw that into a poke (instance Storable a where).
18:48:55 <sjanssen> TomMD: why not?
18:49:17 <bd_> TomMD: the thing is, you can't modify the memory pointed to by the bytestring,as something else might have a pointer to it
18:49:21 <TomMD> because once outside of the scope of unsafeUseAsCStringLen the ptr is worthless (GC)
18:50:16 <sjanssen> well, you can't poke anything into a Ptr if it must be garbage collected
18:50:26 <TomMD> bd_: Yes, so to answer your question.  operateFoo(uint64_t x, char *y, char *z) won't modify y but will modify z.
18:50:31 <TomMD> oops
18:50:38 <bd_> okay, so you'll need to copy z first
18:50:38 <TomMD> not 3 args, one arg in a struct.
18:51:05 <mmorrow> :t readInt32OffPtr
18:51:06 <lambdabot> Not in scope: `readInt32OffPtr'
18:51:13 <sjanssen> TomMD: do you need to use Storable?
18:51:25 <sjanssen> you can just provide a 'withFoo' operator
18:51:31 <mmorrow> readInt32OffPtr :: GHC.Ptr.Ptr GHC.Int.Int32 -> Int -> IO GHC.Int.Int32
18:51:35 <mmorrow> in GHC.Storable
18:51:37 <TomMD> sjanssen: I thought it would help, but that was probably a bad assumption.
18:51:41 <mmorrow> (for what its worth)
18:52:01 <mmorrow> you prob want readWideCharOffPtr
18:52:17 <sjanssen> no, you almost certainly don't.
18:52:17 <mmorrow> (there's no Word8)
18:52:38 <mmorrow> i *said* for what it's worth...
18:52:45 <sjanssen> mmorrow: not very much :)
18:52:53 <mmorrow> what i figured :)
18:52:54 <sjanssen> char /= a wide char
18:53:16 <mmorrow> oh. i thought you meant using any of the read*OffPtr funcs
18:53:42 <mmorrow> yeah, i'm just looking through the :browse GHC.Storable and took a (bad) guess
18:54:27 <mmorrow> it doesn't look like there's any way to read a Word8 off a ptr...
18:54:39 <mmorrow> ??
18:54:43 <Cale> what?
18:54:48 <Cale> Word8 is Storable
18:55:08 <mmorrow> i guess i should've wualified that with "in the GHC.Storable module"
18:55:09 <TomMD> I've decided making c bindings (and marshalling code) is rather boring and less helpful to people (read: the Haskell community) than pure Haskell.
18:56:33 <mmorrow> i an idiot: readWord8OffPtr ::
18:56:34 <mmorrow>   GHC.Ptr.Ptr GHC.Word.Word8 -> Int -> IO GHC.Word.Word8
18:57:44 <TomMD> mmorrow: Is that the same as peekByteOff (castPtr ptr)?
18:57:52 <TomMD> @src readWord8OffPtr
18:57:53 <lambdabot> Source not found. That's something I cannot allow to happen.
18:58:03 <mmorrow> TomMD: probably
18:58:04 <Cale> (even without the castPtr)
18:58:23 <TomMD> Good point, forgot that the offset functions make life easier like that.
18:58:28 <ecks> how would u be able to check whether a Fractional number is a whole number?
18:58:29 <Cale> peekElemOff
18:58:40 <Cale> > denominator (3/2)
18:58:42 <lambdabot>  2
18:58:50 <Cale> > denominator (6/3)
18:58:52 <lambdabot>  1
18:59:01 <Cale> :t denominator
18:59:03 <lambdabot> forall a. (Integral a) => Ratio a -> a
18:59:13 <Cale> So that only works for rationals.
18:59:18 <TomMD> > denominator (23/7)
18:59:19 <lambdabot>  7
18:59:36 <hpaste>  morrow pasted "GHC.Storable" at http://hpaste.org/8184
18:59:53 <Cale> You probably need at least RealFrac
19:00:07 <hpaste>  morrow annotated "GHC.Storable" with "rest" at http://hpaste.org/8184#a1
19:00:08 <Cale> You could round the number and see if it comes out to the same value.
19:00:46 <Cale> > let isInteger x = round x == x in map isInteger [3/2, 6/3, 3/6]
19:00:47 <lambdabot>  Add a type signature
19:00:54 <mmorrow> readWord8OffPtr (Ptr a) (I# i)
19:00:54 <mmorrow>   = IO $ \s -> case readWord8OffAddr# a i s     of (# s2, x #) -> (# s2, W8# x #)
19:00:57 <Cale> > let isInteger x = round x == x in map isInteger [3/2, 6/3, 3/6 :: Double]
19:00:58 <lambdabot>   add an instance declaration for (Integral Double)
19:01:09 <Cale> sigh :)
19:01:24 <Cale> > let isInteger x = ceiling x == floor x in map isInteger [3/2, 6/3, 3/6 :: Double]
19:01:26 <lambdabot>  [False,True,False]
19:02:07 <abuiles> Hi, a litle question, for use "fromInt" what library have i to import?
19:02:17 <ecks> well, i think i can work with rationals, it doesnt matter i think
19:02:19 <Cale> > let isInteger = (== 0) . snd . properFraction in map isInteger [3/2, 6/3, 3/6 :: Double]
19:02:20 <atp> == on certain kinds of Fractional may be problematic
19:02:20 <lambdabot>  [False,True,False]
19:02:20 <ddarius> Use fromIntegral
19:02:39 <abuiles> thanks
19:02:55 <ecks> let me see
19:03:03 <abuiles> It works!
19:03:33 <atp> > (fromIntegral -8) :: Word
19:03:34 <lambdabot>  Couldn't match expected type `Word' against inferred type `a -> b'
19:03:51 <atp> > fromIntegral -8
19:03:51 <lambdabot>   add an instance declaration for (Num (a -> b))
19:03:57 <atp> > fromIntegral (-8)
19:03:58 <lambdabot>  -8
19:04:01 <atp> i hate that
19:04:16 <atp> why oh why didn't the haskell designers make the negation operator something other than -
19:04:22 <atp> like ~ or something
19:04:35 <abuiles> the thing is because just "fromInt" did't work, I mean, Is that incorrect?
19:04:39 <roconnor> > negate 8
19:04:41 <lambdabot>  -8
19:04:53 <atp> > (fromIntegral (-8)) :: Word
19:04:54 <lambdabot>  4294967288
19:04:58 <atp> heh
19:05:02 <atp> so much for safety
19:05:23 <atp> abuiles: fromInt doesn't exist
19:05:33 <atp> @type fromIntegral
19:05:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
19:05:37 <hpaste>  sjanssen pasted "TomMD's function (untested, may segfault)" at http://hpaste.org/8185
19:05:40 <dolio> Someone posted a library to hackage that throws exceptions on overflow.
19:05:45 <dolio> Recently.
19:05:49 <atp> exceptions are lame though...
19:05:50 <abuiles> oh  ok,thanks,, I thought that it exist..
19:06:16 <hexpuem> what options are there for versioning off code for different OSes ?
19:06:17 <atp> still, better than nothing
19:06:18 <abuiles> ok. thanks <atp>
19:06:24 <sjanssen> TomMD: my paste can be simplified with some use of the hsc preprocessor
19:07:17 <atp> while we're on the subject of things i dislike intensely, what's up with all the use of Int in the prelude
19:07:28 <Riastradh> Performance hack.
19:07:47 <atp> i doubt it was done for performance reasons...
19:08:13 <dolio> It was.
19:08:23 <atp> why not just use Integral?
19:09:03 <dolio> There's genericFoo for arbitrary Num use.
19:09:24 <dolio> But, of course, it'd be nice if they switched to foo and intFoo.
19:09:34 <sjanssen> atp: why not use Integral?  Performance reasons.
19:09:50 <sjanssen> atp: overloading is expensive if your compiler isn't sufficiently smart
19:10:20 * ddarius needs the Ackermann function to succintly describe the length of his lists.
19:10:24 <atp> sigh
19:10:30 <atp> ddarius: ha
19:14:42 <atp> dolio: also, there's no generic fromEnum that i'm aware of...
19:17:55 <sclv> if you're enums have more than maxSize :: Int members then, uh...  whoa
19:18:03 <sclv> s/you're/your/
19:18:17 <roconnor> @type fromEnum
19:18:19 <lambdabot> forall a. (Enum a) => a -> Int
19:20:00 <atp> sclv: they don't need to
19:20:26 <atp> sclv: the use of Int can cause the type system to assume that a bunch of nums are ints
19:20:47 <sclv> defaulting ftl
19:20:48 <atp> sclv: and you don't notice that you've got a possible error until you get integer overflow
19:21:11 <atp> once you notice, you just make it fromIntegral . fromEnum
19:21:14 <atp> but it's still a pain
19:21:28 <atp> (in this case, i was multiplying repeatedly)
19:21:38 <sclv> i think, by the way, that even though defaulting lets you do it, relying on default integers is a terrible terrible idea.
19:21:49 <atp> why is that?
19:22:03 <atp> not all of us are trying to write fast code
19:22:33 <atp> in this case speed is not an issue, because it's just an exploration of mathematical concepts
19:22:35 <sclv> defaulting makes things easy to get started with, relatively, but as soon as things get more complex, you get taken by painful surprise early on in your haskell-life, and even folks that know what they're doing, when they rely on it, get bitten by e.g. what you describe.
19:22:47 <sclv> atp: its not defaulting to Integers per se -- its defaulting at all.
19:23:02 <atp> how do you mean?
19:23:06 <atp> i'm not sure i follow.
19:23:07 <dolio> Yeah, I don't know why Enum uses Ints.
19:23:31 <sclv> atp: I just mean that defaulting adds another layer of mystery and arbitraryness to things that should be neither.
19:23:32 <bd_> Because when haskell was drafted we didn't have all these fancy optimizations :)
19:23:44 <atp> when you say defaulting, what do you mean?
19:23:44 <bd_> Enum should use Integral types, with Int specializations, really
19:23:54 <sclv> also now that we're ditching monomorphism it gets worse
19:24:02 <dolio> Num doesn't use Ints as a base. It uses Integer.
19:24:24 <dolio> Of course, you can easily write numeric literals bigger than maxBound :: Int.
19:24:33 <atp> if you mean not using type annotations, i was using type annotations... it's just that the function was non-trivial
19:25:00 <sclv> atp: defaulting is when you write "1" the compiler, if no other information is given, will specialize it to Integer eventually.
19:25:12 <atp> oh, i see what you're saying.
19:25:15 <solrize_> Int should be abolished, or at least made to trap overfllow
19:25:27 <sclv> we have safeInts now on hackage!
19:25:34 <solrize_> sclv oh cool
19:25:35 <atp> i'm not a big fan of int... i understand the need for it in high-speed situations, but it should never ever be default
19:25:45 <atp> (imho)
19:25:46 <solrize_> :t length
19:25:48 <lambdabot>     Ambiguous occurrence `length'
19:25:48 <lambdabot>     It could refer to either `L.length', defined at <local>:2:0
19:25:48 <lambdabot>                           or `Data.List.length', imported from Data.List at State/imports.h:22:0-33
19:25:55 <solrize_> bah :)
19:25:57 <atp> there's genericLength
19:25:59 <solrize_> :t Prelude.length
19:26:01 <lambdabot> forall a. [a] -> Int
19:26:02 <dolio> @undefine
19:26:06 <dolio> :t length
19:26:07 <sclv> atp: right. I'm arguing for no defaults. i.e. you need to specify it for yourself.
19:26:09 <lambdabot> Undefined.
19:26:10 <lambdabot> forall a. [a] -> Int
19:26:26 <atp> sclv: i don't think it's a problem to have defaults as long as you can reliably override.
19:26:40 <sclv> yeah, but it'll surprise you still..
19:26:57 <sclv> especially with haskell' ditching the monomorphism restriction.
19:27:05 <atp> sclv: in this case, i wasn't bitten by defaults.  i was bitten by the fact that a fromEnum set all my internal calculations to Int instead of Integer, which was then fed into show, so my top-level type annotation never caught it
19:27:27 <atp> i'm glad they're getting rid of the monomorphism restriction
19:27:33 <atp> never did like that blasted thing
19:27:48 <sclv> atp: right, but without defaulting you would never have assumed they're integer to begin with.
19:27:55 <atp> might not be bad to be able to turn it on with an option though, instead of currently requiring that you turn it off
19:28:19 <sclv> atp: supposedly, you'll be able to ask for warnings regarding it, which seems appropriate.
19:28:39 <sclv> there's plenty of times where its been helpful to realize that I was being more polymorphic than I wanted.
19:28:44 <atp> sclv: i see what you're saying about defaulting.  so in your no-defaulting world, the compiler would complain that the type is ambiguous?
19:29:04 <sclv> yep -- something like that.
19:29:22 <sclv> (only on the show of course)
19:29:32 <atp> in this case, it would not have complained, because it wasn't ambiguous... but i suppose if i were used to a default-less haskell, i would have seen that the tye was ambiguous and specified it
19:29:38 <atp> s/tye/type
19:29:38 <ecks> :t toDouble
19:29:40 <lambdabot> Not in scope: `toDouble'
19:29:49 <sclv> atp: exactly.
19:29:54 <dolio> If you had a calculation where it internally used int due to fromEnum, and your annotations didn't catch that Int was being used, then replacing Int with Integral i would already be ambiguous, I think.
19:30:21 <atp> yeah, it's ambiguous now.  but because of defaulting, ambiguous == Integer, which is what i want in this case.
19:30:24 <dolio> It's like 'show . read'
19:30:26 <atp> nod.
19:30:37 <dolio> No, it won't default.
19:30:42 <dolio> @type show . read
19:30:48 <lambdabot> String -> String
19:30:49 <solrize_> but there's all these functions like length, that are explicitly Int
19:31:04 <dolio> Hmm..
19:31:05 <Cale> > show . read $ ()
19:31:07 <lambdabot>  Couldn't match expected type `String' against inferred type `()'
19:31:11 <dolio> > (show . read) "()"
19:31:13 <Cale> > show . read $ "()"
19:31:20 <lambdabot>  ghc: failed with error code 15
19:31:24 <Cale> ?
19:31:26 <lambdabot>  "()"
19:31:32 <solrize_> :t ()
19:31:34 <lambdabot> ()
19:31:35 <dolio> Huh, well, that's odd.
19:31:39 <Cale> huh, must have been intermittent flakiness
19:31:46 <atp> i understand what you mean though.
19:31:57 <Cale> It's using the extended defaulting rules
19:32:03 <dolio> Ah.
19:32:05 <sclv> > read . show $ 12
19:32:10 <lambdabot>  Exception: Prelude.read: no parse
19:32:19 <atp> show . read
19:32:33 <sclv> > show . read $ "12"
19:32:34 <lambdabot>  "Exception: Prelude.read: no parse
19:32:37 <atp> hm
19:32:40 <sclv> huh!
19:32:47 <sclv> > show . read $ "12" :: Int
19:32:48 <lambdabot>  Couldn't match expected type `Int' against inferred type `String'
19:32:53 <atp> "12" :: Int ?
19:32:54 <atp> hehe
19:33:01 * atp bops sclv on the head.
19:33:07 <sclv> gah
19:33:16 <atp> bad cop no donut
19:33:17 <dolio> H98-wise, I'm pretty sure that won't work.
19:33:20 <sclv> show (read "12" :: Int)
19:33:23 <sclv> > show (read "12" :: Int)
19:33:24 <lambdabot>  "12"
19:33:32 <sclv> > show (read "12" :: Double)
19:33:33 <lambdabot>  "12.0"
19:33:50 <sclv> > show . read $ "\"asdf\""
19:33:52 <lambdabot>  "Exception: Prelude.read: no parse
19:33:57 <sclv> :t read . show
19:33:59 <lambdabot> forall a a1. (Show a1, Read a) => a1 -> a
19:34:29 <dolio> Because defaults only work on expressions that are bound to names or some such.
19:35:16 <atp> i still think my single biggest gripe about haskell though is (-) ambiguity
19:35:40 <dolio> So toEnum . fromEnum would fail similarly if it were generalized to Integral i instead of Int or Integer.
19:36:30 <atp> i think in that case (if those were Integral i as stated) the compiler should use Integer and issue a warning
19:36:53 <dolio> (which, incidentally, gets used in every derived instance for Enum, more or less)
19:46:34 <ddarius> :t Map.insert
19:46:36 <lambdabot> Couldn't find qualified module.
19:46:42 <ddarius> :t M.insert
19:46:44 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
19:51:14 <hexpuem> how do you go about doing a platform-conditional import?
19:52:02 * ddarius tries to decide if he needs to be able to quantify over type constructors.
19:52:24 <thoughtpolice> hexpuem: you can use the CPP extension and then provide things on the command line, i.e. `ghc --make -DUSING_WIN32 file.hs'
19:52:55 <thoughtpolice> in the source file it's just like a regular C #ifdef-#endif
19:53:13 <hexpuem> thanks
20:06:43 <ddarius> Hmm, LolliMon's type checker can't hack it.
20:11:17 <roconnor> today is much happer
20:11:33 <roconnor> I think I can imagine the posibility of Coq being fixed.
20:33:16 <Zao> Woohoo, the impossible just happened :)
20:34:25 <mar77a> got laid?
20:34:35 <Zao> Nah, just ghci blowing up :(
20:34:36 <mar77a> found the end of [1..]?
20:35:33 <ivanm> mar77a: what type is [1..]? if it's [Int], then it does have an end...
20:35:55 <ivanm> > let xs = [1..] :: [Int] in last xs
20:36:08 <lambdabot>  Exception: Time limit exceeded
20:36:13 <ivanm> heh
20:36:20 <ivanm> well, it _should_ have an end...
20:38:15 <ivanm> > last ([1..] :: xs)
20:38:16 <lambdabot>  : xs)'
20:38:16 <lambdabot>     In the expression: last ([1 .. ] :: xs)
20:38:16 <lambdabot>     In the definition of ...
20:38:32 <ivanm> > last ([1..] :: [Int]) -- that's better
20:38:42 <lambdabot>  Exception: Time limit exceeded
20:38:53 <mar77a> > (head . reverse) [1..]
20:38:55 <lambdabot> Terminated
20:39:06 <ivanm> OK, it does have an end but it still takes ages (and a lot of RAM!)
20:39:21 <ivanm> mar77a: note the difference... I was using Int, which is finite
20:39:32 <mar77a> depends on the implementation?
20:39:38 <ivanm> if unspecified, ghc defaults to Integer which is limited solely by how much RAM you have
20:39:42 <Saizan_> last ([1..] :: Int) probably works in constant space
20:39:54 <ivanm> Saizan_: yes, but it still seems to take too long
20:40:05 <ecks> @whereis chessguy
20:40:05 <lambdabot> Maybe you meant: where where+
20:40:11 <ivanm> @seen chessguy
20:40:12 <lambdabot> chessguy is in #haskell. I don't know when chessguy last spoke.
20:40:17 * chessguy is right here
20:40:19 <ivanm> ecks: that what you wanted?
20:40:25 <ivanm> or /whois chessguy ?
20:40:34 <ivanm> chessguy: stop lying! :p
20:41:04 <ecks> chessguy: hey chessguy, i remember looking at your repository a long time ago for some ideas about board data types
20:41:20 <ecks> where was it, i forgot sorry
20:41:20 <mar77a> so, how long will > last ([1..] :: [Int]) take?
20:41:41 <ivanm> @hoogle max
20:41:41 <lambdabot> Prelude.max :: Ord a => a -> a -> a
20:41:41 <lambdabot> Data.Ord.max :: Ord a => a -> a -> a
20:41:41 <lambdabot> Prelude.maxBound :: Bounded a => a
20:41:45 <ivanm> @hoogle maxbound
20:41:45 <lambdabot> Prelude.maxBound :: Bounded a => a
20:41:50 <chessguy> ecks:  http://code.haskell.org/ChessLibrary or something
20:41:50 <lambdabot> Title: Index of /ChessLibrary
20:41:55 <ivanm> > maxBound :: Int
20:41:56 <lambdabot>  2147483647
20:41:57 <ecks> ah, thats it, thanx
20:42:07 <mar77a> hop
20:42:08 <mar77a> just finished
20:42:27 <ivanm> mar77a: so it will still probably take a while
20:42:39 <ivanm> especially if you interpret it
20:42:40 <mar77a> took a minute or so
20:42:44 <ivanm> oh?
20:42:52 <mar77a> yeah
20:43:08 * ivanm didn't try it with the constant space at home, just with the other list which took too much RAM :s
20:43:11 <chessguy> ecks:  it's still changing a lot, of course
20:43:18 <ivanm> the fact that I'm rebuilding some packages probably doesn't help either ;-)
20:44:13 <mar77a> Prelude> last([1..] :: [Int]) == (maxBound :: Int)
20:44:14 <mar77a> True
20:44:40 <ivanm> well, yes, that makes sense...
20:44:56 <ivanm> since [x..] is just syntactic sugar for enumFrom
20:45:00 <ivanm> @src enumFrom
20:45:00 <lambdabot> Source not found. Take a stress pill and think things over.
20:45:12 <ivanm> hmmm... that's the right function, isn't it? or is it an inbuilt?
20:45:16 <ivanm> @hoogle enumFrom
20:45:16 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
20:45:16 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
20:45:16 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
20:45:26 <ivanm> yup, it is... must be inbuilt
20:45:26 <dolio> @src Int enumFrom
20:45:26 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:45:30 <ecks> chessguy : thats fine, i just want to get ideas, im trying to use a go board but its similar
20:45:46 <ivanm> dolio: I thought it would have been generic to Enums...
20:46:02 <dolio> It's a type class method. You have to specify which instance for it to show.
20:46:14 <dolio> @src Enum
20:46:15 <lambdabot> class  Enum a   where
20:46:15 <lambdabot>     succ                     :: a -> a
20:46:15 <lambdabot>     pred                     :: a -> a
20:46:15 <lambdabot>     toEnum                   :: Int -> a
20:46:15 <lambdabot>     fromEnum                 :: a -> Int
20:46:17 <lambdabot> [3 @more lines]
20:46:21 <dolio> @more
20:46:21 <lambdabot>     enumFrom                 :: a -> [a]
20:46:21 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
20:46:23 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
20:46:34 <chessguy> ecks:  well, my idea for this was to write a class so that people could use whatever data structure they wanted for the actual board
20:46:42 <ivanm> dolio: ahhh, rather than being defined _using_ the typeclass?
20:46:46 <dolio> And even then, it might not be in @src.
20:46:57 <ivanm> *nod*
21:14:44 <chessguy> @pl makeMove (Move from to _) c = setPiece from Nothing (setPiece to (getPiece from c))
21:14:44 <lambdabot> (line 1, column 24):
21:14:44 <lambdabot> unexpected "_"
21:14:44 <lambdabot> expecting variable, "(", operator or ")"
21:15:30 <chessguy> @pl makeMove c = setPiece from Nothing (setPiece to (getPiece from c))
21:15:30 <lambdabot> makeMove = setPiece from Nothing . setPiece to . getPiece from
21:19:02 <chessguy> pl makeMove c = setPiece from Nothing (setPiece to (getPiece from c) c)
21:19:23 <chessguy> @pl makeMove c = setPiece from Nothing (setPiece to (getPiece from c) c)
21:19:23 <lambdabot> makeMove = setPiece from Nothing . (setPiece to =<< getPiece from)
21:20:30 <ddarius> Hmm, I may start using that idiom...
21:20:40 <chessguy> i take it that's the Reader monad
21:20:51 <ddarius> Yes.
21:23:11 <ivanm> which idiom is this?
21:24:04 <EvilTerran> looks like using (=<<) being (flip S) in the reader monad
21:24:52 <ivanm> hmmm...
21:25:00 <ivanm> with S being?
21:25:12 <ivanm> or do you mean S =<< == flip S ?
21:25:25 <EvilTerran> S combinator. \f g x -> f x (g x)
21:25:34 <ivanm> ahhh
21:25:41 <ivanm> isn't that ap or liftM2 or something?
21:25:47 <EvilTerran> (ap = S) in Reader
21:25:52 <ivanm> ahhhhh
21:25:58 <EvilTerran> but ((=<<) = flip S), too
21:26:02 <gubagem> do i need a monad here?
21:26:05 <hpaste>  gubagem pasted "do i need a monad here?" at http://hpaste.org/8187
21:26:11 <EvilTerran> or something like flip S
21:26:24 <EvilTerran> ?type (id.) . (=<<)
21:26:25 <ivanm> apart from IO (), do you ever really _need_ a monad?
21:26:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:26:32 <EvilTerran> ?type (id.) . ap
21:26:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:26:49 <EvilTerran> hm. thought those (id.)s would force it into Reader. must've not used enough .s
21:27:55 <ddarius> ivanm: There's ST and STM as well.
21:29:10 <ivanm> stop confusing me! :s
21:32:07 <chessguy> @pl g s c = l s (f c)
21:32:08 <lambdabot> g = (. f) . l
21:35:58 <dolio> @type let s f g x = f x (g x) in s . flip
21:36:00 <lambdabot> forall a b c. (a -> b -> c) -> (b -> a) -> b -> c
21:36:08 <Saizan_> ?ty (=<<) `asTypeOf` (ap . flip)
21:36:10 <lambdabot> forall a b c. (a -> b -> c) -> (b -> a) -> b -> c
21:55:48 <gubagem> @hoogle Data.Map.lookup
21:55:48 <lambdabot> No matches, try a more general search
21:55:52 <gubagem> :(
21:56:28 <mrd> @hoogle lookup
21:56:29 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:56:29 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:56:29 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
21:56:56 <mrd> lookup :: Monad m => a -> Map a b -> m b
21:58:31 <gubagem> mrd: how do i get that b out of that m
21:58:58 <mrd> however you want, so long as its a monad
21:59:24 <mrd> you could use Maybe
21:59:35 <mrd> ?src Maybe (>>=)
21:59:36 <lambdabot> (Just x) >>= k      = k x
21:59:36 <lambdabot> Nothing  >>= _      = Nothing
21:59:37 <Smokey`> Has there been much research done into Haskell and JIT compilation?
22:00:16 <mmorrow> :t insertWith
22:00:18 <lambdabot> Not in scope: `insertWith'
22:00:37 <sclv> Smokey`: not really a good idiom match?
22:00:42 <ddarius> Smokey`: No.  There isn't much of an impetuous to.
22:00:45 <mmorrow> dang Data.Map isn't in scope!
22:00:47 <mrd> mmorrow: takes an "a -> a -> a" function first
22:01:07 <ddarius> :t M.insertWith
22:01:09 <mmorrow> > foldl' (\m i -> insertWith (const (+1)) i 1 m) mempty . take 10000 . randomRs (0::Int,2) $ (mkStdGen 0)
22:01:09 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
22:01:15 <sclv> the emphasis goes on improving static compilation and having a very lightweight runtime.
22:01:21 <lambdabot>   Not in scope: `insertWith'
22:01:41 <Saizan_> > foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty . take 10000 . randomRs (0::Int,2) $ (mkStdGen 0)
22:01:47 <mrd> ddarius: ghc is impetuous?
22:01:47 <lambdabot>  fromList [(0,3333),(1,3306),(2,3361)]
22:01:48 <mmorrow> sclv: ah, that makes sense
22:01:59 <mmorrow> Saizan_: nice!
22:02:33 <mmorrow> > fmap (foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty . take 10000 . randomRs (0::Int,2) . mkStdGen) [0..2]
22:02:35 <lambdabot>  [fromList [(0,3333),(1,3306),(2,3361)],fromList [(0,3341),(1,3302),(2,3357)]...
22:02:39 <mrd> > M.lookup 1 (M.fromList [(1,'a')]
22:02:40 <lambdabot> Unbalanced parentheses
22:02:43 <mrd> > M.lookup 1 (M.fromList [(1,'a')])
22:02:44 <lambdabot>   add an instance declaration for (Show (m Char))
22:02:48 <mrd> > M.lookup 1 (M.fromList [(1,'a')]) :: Maybe Char
22:02:50 <lambdabot>  Just 'a'
22:03:12 <mrd> > do x <- M.lookup 1 (M.fromList [(1,'a')]); return (succ x)
22:03:13 <lambdabot>   add an instance declaration for (Show (t Char))
22:03:17 <mrd> > do x <- M.lookup 1 (M.fromList [(1,'a')]); return (succ x) :: Maybe Char
22:03:19 <lambdabot>  Just 'b'
22:03:44 <mmorrow> ddarius: ah, just saw yer response.
22:03:45 <mrd> > do x <- M.lookup 1 (M.fromList [(1,'a')]); return (succ x) :: [Char]
22:03:47 <lambdabot>  "b"
22:04:33 <chessguy> > liftM succ (M.lookup 1 (M.fromList [(1,'a')])) :: Maybe Char
22:04:34 <lambdabot>  Just 'b'
22:08:37 <TomMD> I am starting to think that hackage should have a "sort by maintainer" ability.  I only have four and am starting to doubt people with a dozen+ actually remember all the packages they have.
22:12:10 <Smokey`> hmmm nevermind, it seems there are already JIT features inside haskell, they're just not optimized (or maybe they are?) - and other people are looking into it, and byte code compilation/etc... for optimizations such as case prediction and elimination...
22:15:43 <ivanm> TomMD: hackage needs a _lot_ of features that it's currently missing
22:16:15 <Saizan_> Smokey`: where? yhc?
22:16:33 <dmwit> Smokey`: JIT?  Most implementations I know are completely compiled...
22:18:50 <Smokey`> Saizan_: Microsoft has done some stuff with Haskell.NET, and apparently JIT compiled haskell can be achieved by (mmm, I've lost the link sorrry - someone making a javascript interpreter on http://comonad.com/ was doing JIT compiled stuff for their ecmascript/javascript interpreter)
22:19:01 <lambdabot> Title: The Comonad.Reader
22:19:11 <bd_> Haskell.NET?
22:19:26 <Smokey`> a Microsoft research project, been going on for years now
22:19:40 <Smokey`> most of the R&D has been adopted into F# though
22:20:11 <shapr> comonad.com is edwardk
22:21:42 <Smokey`> http://comonad.com/reader/wiki;mode=category&item=Haskell
22:21:49 <lambdabot> Title: The Comonad.Reader  Wiki
22:22:04 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..9]
22:22:05 <lambdabot>  fromList [(0,3353.2),(1,3305.9),(2,3340.9)]
22:22:12 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..19]
22:22:14 <lambdabot>  fromList [(0,3357.85),(1,3317.0),(2,3325.15)]
22:22:29 <mmorrow> i wonder how many before the 3 seconds?
22:22:36 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..40]
22:22:38 <lambdabot>  fromList [(0,3357.8048780487807),(1,3316.1463414634145),(2,3326.048780487805)]
22:22:41 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..99]
22:22:45 <lambdabot>  fromList [(0,3344.67),(1,3329.38),(2,3325.95)]
22:22:49 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..500]
22:22:53 <lambdabot>  fromList
22:22:57 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..400]
22:23:01 <lambdabot>  fromList
22:23:10 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..150]
22:23:14 <lambdabot>  fromList [(0,
22:23:21 <mmorrow> oooh
22:23:25 <shapr> um
22:23:34 <mmorrow> sorry
22:23:38 <shapr> no worries
22:23:48 <mmorrow> :)
22:24:24 <mmorrow> > let  counts = foldl' (\m i -> M.insertWith (const (+1)) i 1 m) mempty; f xs = let len = fromIntegral . length $ xs in M.map (/len) . M.unionsWith (+) .  fmap (counts . take 10000 . randomRs (0::Int,2) . mkStdGen) $ xs in f [0..140]
22:24:29 <lambdabot>  fromList [(0,3340.425531914894),(1,3330.31914893617),(2,3329.255319148936)]
22:24:34 <mmorrow> i couldn't resist
22:24:54 <mmorrow> somwhere 141-149 is max in 3 seconds...
22:29:01 <dmwit> ?index comparing
22:29:02 <lambdabot> bzzt
22:43:01 <chessguy> > 85 / 126
22:43:02 <lambdabot>  0.6746031746031746
22:43:25 <chessguy> woot! over 2/3 correct in generating the number of 1-ply moves!
22:43:31 <ivanm> heh
22:47:02 <TomMD> Given the build troubles with GHC 6.8.3, it sounds like more build bots are necessary.  Is this observation/conclusion correct?
22:47:33 <roconnor> > logBase 2 1152921504606846976
22:47:34 <lambdabot>  60.0
22:47:51 <roconnor> > 2^60*10^15
22:47:52 <lambdabot>  1152921504606846976000000000000000
22:48:04 <roconnor> 1152921504606846976000000000000000
22:49:54 <dmwit> ?src tails
22:49:55 <lambdabot> tails []         = [[]]
22:49:55 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
22:51:04 <dolio> @yow
22:51:04 <lambdabot> Four thousand different MAGNATES, MOGULS & NABOBS are romping in my
22:51:04 <lambdabot> gothic solarium!!
22:51:34 <P_D> http://hpaste.org/8188 - my lexer is consuming 150MB or so on a 1MB input file.  profiled, but I'm not much closer to understanding what's going on.
22:53:30 <P_D> oh, I did try making alex_scan_tkn strict in the "len" argument, which made a significant difference.
22:53:36 * dolio wishes emacs didn't suck so much.
22:54:01 <P_D> do I need to hand write bits of the lexer, and if so, how would I go about doing that?
22:54:04 <dmwit> ?instances-importing Text.ParserCombinators.Parsec MonadPlus
22:54:04 <lambdabot> Either e, ErrorT e m, GenParser tok st, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:56:38 <dmwit> Is there a convenient Parsec parser for unsigned ints?
22:56:38 <mmorrow> P_D: my guess is it's from unpacking the bytestrings to strings
22:57:39 <mmorrow> P_D: i'd try changing to TString AlexPosn ByteString
22:57:50 <mmorrow> P_D: if it's not that then i can't see what
22:58:32 <chessguy> > (126-29)/126
22:58:34 <lambdabot>  0.7698412698412699
22:59:33 <P_D> mmorrow:  TString is probably ok, that doesn't show up much- but the file is almost entirely TKwd/TSym's, which I unpack...
22:59:43 <P_D> mmorrow: I'll try converting all three
23:00:10 <mmorrow> definitely
23:00:21 * edwardk looks up and notes someone mentioned something about his old javascript stuff.
23:01:42 <edwardk> woot. i finally got all the prepro and postpromorphism stuff and all of the other (para, histo, zygo, whatever)-(pre|post)promorphic variants into category-extras.
23:03:14 <mmorrow> i've gotta start playing with that...
23:03:16 <psygnisfive> so im watching Harvey's SICP and hes talking about streams/lazy-lists
23:03:29 <psygnisfive> and he just imlemented [1...]
23:03:37 <psygnisfive> which reminds me why i love haskell
23:03:41 <psygnisfive> <3 <3 <3
23:03:43 <chessguy> > 103/126
23:03:44 <lambdabot>  0.8174603174603174
23:04:00 <edwardk> now i need to figure out if there is a meaningful hybrid prepro/postpro ala hylo
23:04:08 <edwardk> my first attempt failed miserably =)
23:06:22 <mmorrow> sounds like the kinda stuff they probably do on the spacestation all day
23:06:46 <edwardk> mmorrow: ?
23:06:59 <mmorrow> i dunno, random.. :)
23:07:36 <chessguy> > 118/126
23:07:37 <lambdabot>  0.9365079365079365
23:07:38 <mmorrow> those names just looked spaceish
23:07:56 <edwardk> I started to look up prepromorphisms on the internet then i realized that the highest ranked results were from me talking to dolio here on channel about them.
23:08:06 <mmorrow> lol
23:08:10 <dolio> Hahaha.
23:08:16 <edwardk> fortunately what i said back when i first thought about them was insightful enough to help me finish them =)
23:08:52 <mmorrow> that'd be great if the only result was your current search
23:09:11 <edwardk> i find the idea of generalized prepro histomorphisms kinda rough i'll admit, but i can see what they do at least =)
23:09:34 <ddarius> @hoogle natural
23:09:35 <lambdabot> Text.ParserCombinators.Parsec.Token.natural :: TokenParser st -> CharParser st Integer
23:09:35 <lambdabot> Text.ParserCombinators.Parsec.Token.naturalOrFloat :: TokenParser st -> CharParser st (Either Integer Double)
23:10:07 <edwardk> i'm mostly just building a set of combinators for building distributive laws for various monads/comonads over certain other functors that can be used in a lot of generalized recursion schemes. the names matter very little
23:10:25 <edwardk> and mostly serve as a scare factor
23:11:07 <P_D> Fixing TKwd made no difference to allocation behavior - but it did shave about 5% speed
23:11:17 <kiris> hey. there's a program I want to use from a Haskell program with a pipe. it only outputs the information I want when Ctrl-q is pressed (EOF?), how can I simualte that in Haskell and get the data? anybody used pipes like this before?
23:11:41 <mmorrow> edwardk: love the names
23:11:41 <dmwit> :t (<$)
23:11:43 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
23:12:04 <dmwit> kiris: hClose the handle of its input, maybe?
23:12:09 <ikeda> edwardk are you a researcher?
23:12:33 <dmwit> kiris: But ^q doesn't sound like EOF, it's usually ^d on *nix and ^z on doze.
23:12:36 <kiris> dmwit: I tried that but I get an EOF error when trying to read the output handle
23:13:01 <P_D> try printing chr 0x11
23:13:01 <dmwit> kiris: I recommend hPutStr'ing a ^q character. ;-)
23:13:17 <edwardk> ikeda: depends on your definition. practically i'm just a guy who likes this stuff. I code c# during the day. ;)
23:13:20 <mmorrow> i think ^d is EOF...
23:13:32 <kiris> P_D: I'll try that
23:14:53 <ikeda> well your closer than me to using this stuff in your day job. I program in C. :-)
23:15:12 <mmorrow> my favorite C program:  main(){while(1) printf("\a");}
23:15:20 <edwardk> ikeda: that said i think i've probably now generated a good dozen extensions of the existing themes that haven't appeared before now in literature, so I guess I do research.
23:15:30 <ddarius> prepostimorphism
23:15:32 <mrd> co-research
23:15:41 <chessguy> shaZAM
23:15:44 <kiris> I write my text, followed by newline and \0x11 and then try hGetLine and get an "end of file" exception. (same for \0xFF)
23:15:44 * chessguy reaches 100%
23:15:54 <ikeda> haha
23:16:22 <kiris> should I send some signal to the process?
23:16:41 <dmwit> No, just check your buffering.
23:16:58 <dmwit> The ^q probably just isn't sent yet.
23:17:06 <edwardk> ddarius: i've yet to figure out what a good name would be for a hybrid pre/postpromorphism. repro, bipro, wrapro, ...? =)
23:17:23 <chessguy> > (756-630)/756
23:17:24 <lambdabot>  0.16666666666666666
23:17:33 <chessguy> the next level :)
23:17:42 <edwardk> it basically bakes a generalized 'iterate' into the signature
23:17:50 <mmorrow> edwardk: you need to write a prog to gen these names for you
23:17:53 <P_D> prepopro?
23:18:38 <mmorrow> edwardk: then you get naming consistency for free
23:19:04 <edwardk> mmorrow: heh, mostly i don't use names for the combinators, i just provide a basic set of combinators for putting them together, then you glue your own whatever-morphism by giving the more general construction the distributive laws you want
23:19:09 <chessguy> @pl \x -> (x, f x)
23:19:09 <lambdabot> ap (,) f
23:19:14 <ikeda_> cool. you give an engineer an arcane subject that is useful and he figures out how to extend it. thus giving the researchers back somethiing new to them.
23:20:49 <kiris> dmwit: ah! I have it functioning. with hClose, too, instead of manually writing \0xFF. it seems that a final \n character before closing the file causes the program to exit without bothering to write anything. is this standard? it could perhaps be an issue with the program
23:21:03 <kiris> s/file/input handle
23:21:28 <dmwit> I don't know.
23:21:30 <edwardk> I.e. if you need history, you use distHisto. if you need to also use mutual recursion you blend it using distZygoT, if all of that is going into just unfolding something you get g_cata (distZygoT mysecondaryalgebra (distHisto id)) myprimaryalgebra
23:21:47 * kiris tries it with grep
23:22:31 <psygnisfive> with list comprehensions in haskell, can you make _denials_ about things?
23:22:32 <psygnisfive> e.g.
23:22:35 <edwardk> if you need to build something up in order to unfold it that way you g_hylo  and provide a distributive law for the fold as well. if you don't need one, you can just use the base distAna, and lift the algebra to the generalized scheme
23:22:47 <psygnisfive> i know you can say stuff like [ x | x <- [1,2,3] ] or something like that right
23:23:06 <edwardk> I'll admit I'm half tempted to go through and try to figure out 'natural sounding' names for all of this crap to stop scaring people
23:23:17 <psygnisfive> but can you say [ x | !(x <- [1,2,3]) ] and get the infinite list of integers, minus 1, 2, and 3?
23:23:29 <Saizan_> no
23:23:33 <psygnisfive> :(
23:23:42 <dmwit> What would the first element be?
23:23:43 <edwardk> 'Zygo' is so much scarier than 'WithHelperFunction' or something =)
23:23:55 <mmorrow> edwardk: you could map ([],"co") into [("pre","post"),([],"un"),([],"re"),...], then something something mkName -> uncopreparaenmorphism (or something)
23:24:07 <mmorrow> edwark: at the very least it would be comical
23:24:16 <Saizan_> edwardk: without the scary names you lose all the mathy audience
23:24:16 <psygnisfive> well, i guess i'd need to add x <- Integers to define the background
23:24:19 <kiris> dmwit: well, it doesn't do it with grep, so I suppose it must be a bug with the program I was using. thanks for your help :)
23:24:20 <psygnisfive> thatd work right?
23:24:31 <edwardk> mmorrow: have you looked at the names in Control.Morphism.* ? =) thats not all that far from the existing names there ;)
23:24:35 <dmwit> psygnisfive: Again, what would the first element be?
23:24:38 <psygnisfive> [ x | x <- Integers, x !<- [1,2,3] ]
23:24:46 <mmorrow> edwardk: ha
23:24:48 <dmwit> psygnisfive: You can do this:
23:24:48 <psygnisfive> er.. 4?
23:24:51 <edwardk> Saizan_: heh true nuff
23:24:56 <dmwit> psygnisfive: Not 0?  Maybe -3?
23:25:02 <psygnisfive> er..
23:25:03 <Saizan_> > [y | x <- [0..], x `notElem` [1,2,3] ]
23:25:11 <dmwit> [x | x <- [0..], x `notElem` [1..3]]
23:25:12 <lambdabot>  [y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y...
23:25:18 <Saizan_> heh
23:25:25 <psygnisfive> er
23:25:26 <Saizan_> > [x | x <- [0..], x `notElem` [1,2,3] ]
23:25:27 <lambdabot>  [0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
23:25:33 <psygnisfive> awesome :)
23:26:00 <Saizan_> not very efficient
23:26:05 <psygnisfive> oh who cares :p
23:26:10 <dmwit> > drop 3 [1..]
23:26:11 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
23:26:14 <edwardk> mmorrow: and if you look everywhere else in the package there are a ton of [ x ++ y ++ z | x <- ["","un"], y <- ["","co"], z <- concepts]] style function names. I think i have a co everywhere I can make it make sense ;)
23:26:27 <dmwit> > [4..]
23:26:29 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
23:26:40 <edwardk> though whenever the un = co, i just have "" and "co" rather than both mixed.
23:26:42 <psygnisfive> i wasn't asking really for this thing, i just wanted to know if it was possible in principle
23:27:18 <dmwit> What's the name for a '.' in regexes?  How would I pronounce it?
23:27:23 <dmwit> dot?
23:27:42 <edwardk> anyways the prepro stuff worked out very cleanly once i generalized it all the same generic tools for generalized ana/cata/hylo works perfectly for generalized prepro/postpro.
23:27:50 <mmorrow> edwardk: i'm totally for the consitent use of co- for dual-whatevers rather than some wrt language opposite word
23:28:32 <edwardk> mmorrow: i'm almost there. i still use extend, extract, and duplicate because i find them sufficiently evocative and most people lack an intuition for comonads.
23:28:50 <kiris> "dot" or "any character"
23:29:03 <edwardk> mmorrow: but for basically everything else i try to consistently use co-whatever
23:29:14 <mmorrow> edwardk: yeah, i agree someplaces it does seem like forcing the co when it would be better to not...
23:29:20 <chessguy> @pl \c -> (c, map (flip makeMove c) (legal_moves c))
23:29:20 <lambdabot> ap (,) (ap (map . flip makeMove) legal_moves)
23:29:40 <edwardk> dolio: btw- i think i found the origin of your coextend comment, an early post by dave menendez did use that convention
23:30:06 <Saizan_> coextend?
23:30:43 <edwardk> For some reason I do find signatures like: g_prepro_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> (f :~> f) -> FixF f -> a -- amusing to no end.
23:31:11 <neon2323> http://www.metacafe.com/fplayer/1370978/amazing_balance_of_coins.swf   o_O
23:31:11 <neon2323> http://www.metacafe.com/fplayer/1370978/amazing_balance_of_coins.swf   o_O
23:31:12 <lambdabot> http://tinyurl.com/5uer3l
23:31:12 <lambdabot> http://tinyurl.com/5uer3l
23:31:25 <edwardk> saizan: well, if you decide to call flip (>>=) extend, then what i can 'extend' in Control.Comonad is 'coextend' ;)
23:32:20 <Saizan_> hah, namespace pollution :)
23:32:33 <edwardk> yeah
23:34:30 <chessguy> (252-36)/252
23:34:43 <chessguy> > (252-36)/252
23:34:44 <lambdabot>  0.8571428571428571
23:35:06 <ivanm> chessguy: don't you have any calculator software installed? :p
23:35:11 <mmorrow> P_D: is your lexer better?
23:35:24 <chessguy> yup
23:39:10 <edwardk> alright climbing into bed. i'll see about posting up explanations about (pre|post)promorphisms tomorrow
23:39:31 <mmorrow> night
23:39:37 <edwardk> night all
23:40:14 <dmwit> ?src show
23:40:14 <lambdabot> show x = shows x ""
23:41:17 <dmwit> ?src Show
23:41:17 <lambdabot> class  Show a  where
23:41:17 <lambdabot>     showsPrec :: Int -> a -> ShowS
23:41:17 <lambdabot>     show      :: a   -> String
23:41:17 <lambdabot>     showList  :: [a] -> ShowS
23:41:17 <dmwit> ?src shows
23:41:17 <lambdabot> Source not found. I feel much better now.
23:44:16 <chessguy> @pl makeMove c = setToMoveColor (switchColor (toMoveColor c)) $ setPiece from Nothing (setPiece to (getPiece from c) c)
23:44:16 <lambdabot> makeMove = ap (setToMoveColor . switchColor . toMoveColor) (setPiece from Nothing . (setPiece to =<< getPiece from))
23:44:47 <chessguy> @type ap
23:44:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:46:08 <chessguy> @pl makeMove c = setPiece to Nothing $ setToMoveColor (switchColor (toMoveColor c)) $ setPiece from Nothing (setPiece to (getPiece from c) c)
23:46:09 <lambdabot> makeMove = setPiece to Nothing . ap (setToMoveColor . switchColor . toMoveColor) (setPiece from Nothing . (setPiece to =<< getPiece from))
23:46:31 <chessguy> hrm
23:51:05 <dmwit> Dang it!
23:52:58 <ddarius> That parser change was almost too easy
23:58:46 <dmwit> Posix regex bracket expressions are complicated. =/
