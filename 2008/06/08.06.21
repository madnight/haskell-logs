00:00:05 <vixey`> you have an infinite set of types
00:00:33 <mmorrow> vixey`: are you trying to prove something about such a system or implement one?
00:00:45 <mmorrow> (or both)
00:00:51 <vixey`> not yet :)
00:01:16 <mmorrow> i guess i mean, in what sense are you saying it's hard?
00:01:36 <vixey`> well in the paper they don't handle polymorphism
00:01:51 * mmorrow looks at paper
00:01:57 <dolio> It's simple. Just take your lambda cube interpreter and tweak part of it. :)
00:02:13 <vixey`> it's not a 'without loss of generality thing'
00:02:23 <vixey`> because you actually lose a lot if you skip out polymorphism
00:04:00 <mmorrow> vixey`: ooh, interesting looking paper...
00:04:12 <vixey`> yes
00:08:43 <roconnor> @src any
00:08:43 <lambdabot> any p =  or . map p
00:08:48 <roconnor> @src some
00:08:49 <lambdabot> some v = some_v
00:08:49 <lambdabot>   where many_v = some_v <|> pure []
00:08:49 <lambdabot>         some_v = (:) <$> v <*> many_v
00:09:03 <vixey`> :t some
00:09:04 <roconnor> @src many
00:09:04 <lambdabot> Source not found. Sorry.
00:09:15 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
00:34:30 <vixey`> "Needless to say, the main recursive splay function is a bit of a killer. It is pretty complicated code, especially when you don't use C-isms, like break from inside of nested conditionals in a loop. After unrolling the code, I was relived to have a proof (well, eventually) that I had gotten it right. Actually, I didn't --- I confess to having introduced some bugs. The cool things was that as I was discharging proof obligations, I reached something th
00:34:30 <vixey`> at I could not prove, and the problem was clear. Not only that, the structure of the proof obligation essentially told me what I had messed up, and how to fix it. That was really nice."
00:34:37 <vixey`> oops that was a bit long...
00:47:07 <audreyt> Distribution quality errors:
00:47:07 <audreyt> Unknown extensions: PArr
00:47:08 <audreyt> :/
00:58:31 <solrize_> vixey where's that from?
00:58:37 <dolio> What version? 6.8.3?
00:59:06 <vixey`> random info http://www.eecs.harvard.edu/~shinnar/ynot-squad/
00:59:07 <lambdabot> Title: Ynot: Reasoning with the Awkward Squad
01:00:20 <solrize_> vixey thanks
01:22:58 <dancor> haskell.org dead?
01:23:11 <Vq^> no
01:23:20 <dancor> infinite wait to start wget http://www.haskell.org/ghc/dist/6.8.3/ghc-6.8.3-i386-unknown-linux.tar.bz2
01:23:21 <lambdabot> http://tinyurl.com/668geq
01:28:45 <pengrate> So, Erlang? Maybe not the best language to write a monadic combinator parser in.
01:28:51 <pengrate> Just letting you guys know.
01:29:23 <vixey`> pengrate: Did you try this and fail?
01:29:30 <pengrate> I tried it and it works
01:29:34 <pengrate> But it looks horrible
01:30:07 * dancor plays games and prays for ghc
01:30:14 <sjanssen> does Erlang have infix functions?
01:31:14 <pengrate> No.
01:31:24 <pengrate> At least, it better not after what I've just done.
01:32:34 * sjanssen wants to see a snippet
01:43:03 <hpaste>  pengrate pasted "Erlang Monads" at http://hpaste.org/8450
01:43:31 <dolio> Heh.
01:44:57 <dolio> Lambda is pretty heavy in Erlang.
01:46:32 <pengrate> Yeah, it is
01:46:55 <mc__> Could anyone recommend me a Erlan IDE for mac?
01:47:11 <vixey`> maybe #erlang
01:47:13 <vixey`> I don't know
01:47:50 <mc__> ehm, I meant an Haskell IDE
01:48:01 <vixey`> well I just use a text editor and ghci
01:48:19 <mc__> alrigh
01:48:47 <dolio> Emacs?
01:49:36 <vixey`> http://homepage.mac.com/zenitani/emacs-e.html
01:49:37 <lambdabot> Title: Carbon Emacs Package
01:49:48 <mc__> is haskell-mode decent?
01:49:55 <vixey`> haskell-mode is decent
01:50:30 <vixey`> (in that it syntax colores and tab does the right thing)
01:50:58 <dolio> Yeah, although I prefer replacing the indentation with kuribas' version.
01:51:09 <vixey`> oh where's that?
01:51:12 <vixey`> I would try it
01:51:26 <dolio> http://kuribas.hcoop.net/haskell-indentation.el
01:51:37 <vixey`> cool
01:51:55 <mc__> thanks, I'll try it out
01:52:01 <dolio> If you notice any problems you can send him a mail. It's still a work in progress, I think.
01:52:56 <vixey`> how is it different from usual?
01:53:22 <dolio> Well, mainly you use tab for indent and backspace for unindent.
01:53:26 <dolio> Instead of cycling.
01:54:03 <dolio> And it picks the usually right indentation right off the bat, instead of being the third in the cycle like the one included with haskell-mode. :)
01:57:03 * vixey` finds a bug already...
01:57:41 <vixey`> the doc says (add-hook haskell-mode-hook 'turn-on-haskell-indentation)
01:57:59 <vixey`> but that does nothing and the symbol turn-on-haskell-indentation doesn't exist, it should be haskell-indentation-mode
02:14:48 <paolino> does exist an equilater triangle with (integer,integer) coordinates of the 3 vertex?
02:15:47 <vixey`> paolino: can you rephrase that? I don't understand
02:16:01 <rwbarton> paolino: no
02:16:27 <vixey`> oh I think I understand
02:17:41 <paolino> rwbarton: which way to demonstrate that ?
02:17:56 <osfameron> heh, trying to implement monadic do in Perl is just leading to layer upon layer of pure evil
02:18:09 <rwbarton> paolino: this is kind of overkill, but the area of an equilateral triangle of side length s is sqrt(3) s^2 / 4
02:18:42 <rwbarton> paolino: if a triangle has integer vertices, the square of its side lengths are integers, so if it's equilateral its area has the form sqrt(3) * n / 4
02:18:53 <rwbarton> paolino: but, the area of any polygon with lattice point vertices is half an integer
02:19:57 <astrolabe> smart
02:20:04 <vixey`> rwbarton++
02:20:20 <rwbarton> I'm sure there's a more straightforward proof, but I can't give it offhand
02:21:09 <paolino> yeah, probably with sin (pi/3)
02:21:15 <paolino> nice anyway
02:22:56 <paolino> they should have mentioned it in the google jam code training problem
02:23:23 <paolino> they just say there are no isosceles in the test cases :d
02:23:36 <paolino> ehm equilaters
02:24:13 <rwbarton> Hey, I was just looking at the google code jam site for no reason.  Is there something happening with that currently?
02:27:51 <dancor> is there a haskell.org mirror from which i can grab http://www.haskell.org/ghc/dist/6.8.3/ghc-6.8.3-i386-unknown-linux.tar.bz2
02:27:52 <lambdabot> http://tinyurl.com/668geq
02:28:14 <paolino> rwbarton: I've just entered it for the first time
02:35:28 <dancor> jackpot: wget http://www.mirrorservice.org/sites/www.haskell.org/ghc/dist/6.8.3/ghc-6.8.3-i386-unknown-linux.tar.bz2
02:35:29 <lambdabot> http://tinyurl.com/6dvbpm
02:41:30 <mercury^> that tinyurl feature of lambdabot seems pretty useless and annoying to me
02:56:45 <vixey`> :t \p n -> n (p,p) (n p)
02:56:49 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
02:56:49 <lambdabot>     Probable cause: `n' is applied to too many arguments
02:56:49 <lambdabot>     In the expression: n (p, p) (n p)
02:57:47 <Deewiant> ?ty \p n -> n (p,p) (n (p,p) p)
02:57:49 <lambdabot> forall t. t -> ((t, t) -> t -> t) -> t
02:59:05 <vixey`> ahhh
02:59:32 <vixey`> the notation is confusing, when someone writes  x^n to mean x has type n and they write n^n somewhere else meaning exponentiation
03:02:36 <ibid> where is ^ used to indicate type?
03:03:00 <ibid> or do you mean just superscripting?
03:03:40 <vixey`> yes
03:03:58 <dancor> mercury^: yeah..
03:19:40 <maltem> I noticed that ghc-pkg mentions a local haddock-html directory for every package, but that directory is usually empty or non-existant.  Is there a way to get cabal-install to put the Haddocks there automatically? (Or only in a recent version?)
03:30:58 <dcoutts> mattam: when installing whole stacks of packages, cabal-install doesn't yet have a flag to say to build the docs too
03:31:27 <dcoutts> but if you do the manual steps, cabal configure; cabal build; cabal haddock; cabal install then it does install them
03:31:41 <dcoutts> oops, maltem not mattam
03:32:01 <dcoutts> maltem: there's a open feature request on the docs issue if you want to hack on it
03:32:12 <maltem> ah ok
03:33:03 <maltem> so it's just a matter of some flag passing that is not implemented yet
03:56:35 <vixey`> why must (*,*) occur is any reasonable PTS?
03:59:21 <Botje> because it looks like an owl!
03:59:38 <Botje> also, is there a drop-in strict replacement for pairs?
04:00:39 <Botje> because using pairs made my program suck ram :(
04:10:50 <audreyt> Botje: http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/Data-Strict-Tuple.html
04:10:52 <lambdabot> http://tinyurl.com/6euguc
04:12:21 <Botje> audreyt: ah, that's cool
04:13:26 <Botje> i'll keep that in mind
04:13:33 <Botje> had to resort to C yesterday :(
04:14:43 <audreyt> ugh :/
04:16:45 <RayNbow> hmm, anyone ever tried getting HGL to work under Windows?
04:17:03 <RayNbow> I built and installed it, but in ghci I get the following message:
04:17:07 <RayNbow> Prelude> import Graphics.HGL
04:17:07 <RayNbow> module main:Graphics.HGL is not loaded
04:17:25 <Botje> hmm
04:17:30 <Botje> i generally do :m +Graphics.HGL
04:17:42 <RayNbow> same message
04:17:42 <Botje> but that shouldn't make a difference
04:17:53 <Deewiant> :l Graphics.HGL
04:18:23 <RayNbow> ah
04:18:29 <RayNbow> Graphics/HGL/Key.hs:52:1: lexical error at character 'i'
04:18:49 * Botje does not know the diff between :l and :m
04:18:53 <Botje> aside from the changed search path
04:22:36 <RayNbow> oh lol
04:22:50 <RayNbow> anyone want to guess what went wrong? :P
04:23:50 * RayNbow ran ghci from HGL-3.2.0.0 directory... :p
04:33:56 <vixey`> this looks wrong http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus
04:34:09 <vixey`> rule 1 of Church-style typing
04:34:20 <vixey`> shouldn't it have Gamma before x : t?
04:34:30 <vixey`> *before x : sigma?
04:35:01 <RayNbow> x : \sigma \in \Gamma \vdash x : \sigma
04:35:06 <RayNbow> ?
04:35:11 <vixey`> o_o
04:35:48 <audreyt> is there a #define I can probe to determine whether this module is being loaded under GHCi?
04:37:02 <Saizan> vixey`: i think x : \sigma is to be interpreted as a singleton \Gamma
04:37:24 <vixey`> I think the rule should be
04:37:29 <vixey`> Gamma,x : t |- x : t
04:37:36 <vixey`> they have written x : t |- x : t
04:38:59 <RayNbow> http://www.cse.iitb.ac.in/~as/fpcourse/church.ps.Z <-- page 4
04:39:50 <RayNbow> (x:A) \in \Gamma \Rightarrow \Gamma \vdash x : A;
04:42:22 <piluex> Hi, I'm trying to compile an example that uses Data.Set
04:42:43 <piluex> using ghc 6.8.2 from ubuntu
04:42:48 <int-e> vixey`: you can extend Gamma by the second rule
04:43:03 <piluex> and it doesn't link =(
04:43:10 <piluex> help?
04:43:20 <int-e> vixey`: or rather, the context, not Gamma.
04:45:36 <piluex> nobody using ghc in ubuntu linux?
04:45:36 <RayNbow> vixey`, the Wiki entry refers to ftp://ftp.cs.ru.nl/pub/CompMath.Found/HBK.ps , which contains the Church typing rules on page 44 (printed page number is 43)
04:47:22 <vixey`> are they right though ?
04:48:35 <cadr> piluex: I'm using ghc/ubuntu, but I don't know how much help I can be :)
04:48:50 <piluex> Try to compile this:
04:48:54 <piluex> import Data.Set
04:48:58 <piluex> main = do
04:49:08 <piluex>    let a = fromList([1,2])
04:49:15 <piluex>   print (toList a)
04:49:56 <piluex> (command line: ghc yourfile.hs -o yourbinary
04:50:28 <piluex> I simply can't compile this =/
04:50:32 <piluex> *that
04:51:20 <cadr> Lots of stuff about undefined reference?
04:51:38 <cadr> It's happy in GHCi
04:53:41 <cadr> piluex: do you need a "--make" in there?
04:53:51 <mbz> @yarr
04:53:51 <lambdabot> Smartly me lass
04:54:37 <cadr> piluex: try this at the command lline: ghc --make yourfile.hs -o yourbinary
04:55:34 <piluex> snif
04:55:44 <piluex> the tutorial miss that
04:55:46 <piluex> thx
04:56:14 <cadr> no worries - took me a minute because I almost always use ghci in emacs so far
04:56:21 <cadr> you might look here:  http://en.wikibooks.org/wiki/Haskell/YAHT/Getting_started
04:56:43 <piluex> I was reading about String I/O
04:59:53 <cadr> piluex: how is that going?
05:02:40 <piluex> fine, learning a little about I/O
05:04:51 <piluex> because I get bored of recompiling my programs :P
05:07:47 <piluex> This is my second day with haskell
05:08:44 <vixey`> piluex: have you tried ghci?
05:08:52 <vixey`> you can load programs into it and the interact with them
05:09:07 <vixey`> (so there is not a recompile just to test things)
05:09:20 <piluex> how can I load a program?
05:09:41 <piluex> by now I've only one program
05:09:44 <vixey`> :load <filename>.hs
05:09:54 <vixey`> lots of commands starting with : are in :help
05:10:17 <cadr> also, if you know emacs at all, the integration is fun.  You just do ctrl-c ctrl-l and it sends the buffer to ghci
05:10:39 <piluex> ^^ it finds gcd between 2 polynoms
05:10:48 <vixey`> cool
05:11:49 <piluex> Andd I was trying to made a file with a lot of polynoms and compare the results to found bugs
05:13:28 <piluex> *sorry for my english, my grammar sucks by now
05:16:35 <piluex> How can I hide the imported libraries from the prompt?
05:16:59 <piluex> done
05:17:17 <piluex> :set prompt ^^
05:39:29 <OXIj> is there anything like `poll` for Socket's in Haskell?
05:39:58 <OXIj> making fork's are not good enougth for me
05:43:44 <mux> OXIj: usually you use threads to manage this kind of things
05:46:31 <OXIj> mux, well yes. and then IO makes select to multiplex my blocked calls
05:46:59 <OXIj> but now i want pure code with explicit polling
05:47:30 <mux> I'm saying that we don't usse select nor poll in haskell to do that at all, threads alone are sufficient
05:48:15 <OXIj> they are not if you have 15000 connections
05:48:54 <Lemmih_> OXIj: Sure they are.
05:50:58 <OXIj> well... for example. i have 15000 clients (IRC) and one core thread
05:53:16 <Lemmih_> OXIj: 15000 threads really isn't that much.
05:53:18 <OXIj> core have STMs to client threads. and one STM is from all clients to core
05:53:22 <mux> GHC can create a million threads without problems
05:53:41 <OXIj> hm
05:53:46 <mux> haskell threads are very cheap, not like a pthread_create()
05:54:13 <OXIj> and how cheap is multitasking?
05:54:31 <OXIj> i mean O(?)
05:54:40 <OXIj> N, log N, ... ?
05:54:49 <mauke> who cares as long as it's fast enough?
05:54:53 <mux> multitasking is too vague a term to answer that question
05:55:02 <mux> you're not referring to any algorithm in particular
05:55:29 <OXIj> im reffering to algo used by ghc
05:55:40 <mux> okay, then what algo?
05:55:49 <OXIj> i dunno
05:55:54 <mux> heh well
05:56:08 <mux> give threads a try, chances are that they'll be just what you need here
05:56:11 <OXIj> thats why im interested
05:56:58 <OXIj> ok. i will. but i want poll in any case :)
05:57:15 <mux> there is no such thing
05:57:26 <OXIj> :(
05:57:56 <mux> you have threads, and if you need synchronization you have MVar's and Chan's
06:01:19 <MyCatVerbs> OXIj: task switching, which is probably the quickest thing to go kaboom in a naïve implementation, is AFAIK either O(1), or so very very close to O(1) that you will never notice the difference.
06:06:46 <hkBst> anyone used Haskell for Monte Carlo simulations (of say the Ising model)?
06:14:55 <cadr> Does anyone know of any simple exercises on writing monads?
06:15:33 <vixey`> I think writing them is the easy bit.. isn't it?
06:15:47 <vixey`> the hard part being discovering if something is a monad in the first place
06:16:02 <cadr> Depends how new you are to Haskell :)
06:17:29 <vixey`> Is there something you are trying to do but don't know how to write ?
06:17:56 <cadr> I'm working on a problem for a study group I'm in (now implement this as a monad), and I'm having trouble getting my head around it, so I was hoping to find some simpler exercises to bang my head against
06:18:36 <vixey`> what problem?
06:20:05 <cadr> It defines a database and you are to write functions to query out of it.
06:20:09 <cadr> Did that part.
06:20:30 <cadr> The second part is to construct query as a monad.
06:20:45 <cadr> We went over it in the group a bit the other night, but it didn't really sink in at the time.
06:20:58 <vixey`> hm
06:21:21 <vixey`> there are two ways to define a monad, (or more I guess I don't know them though)
06:21:42 <vixey`> using return and bind, or fmap join return
06:22:14 <vixey`> maybe you could take the types of these down and try to find functions in your code with these types
06:22:21 <vixey`> i.e. return :: a -> Query a
06:22:48 <vixey`> if you have functions like that, you know one of them should be return
06:25:37 <cadr> Yeah, I have a general idea of where I should go with this, but it doesn't really 'click' in my head.  Which is why I was looking for some simpler exercises :)
06:26:09 <vixey`> what doesn't make sense?
06:27:56 <cadr> Ok, we have our Query defined like this:
06:27:57 <cadr> http://en.wikibooks.org/wiki/Haskell/YAHT/Getting_started
06:28:00 <cadr> no, not like that
06:28:12 <cadr> data Query db a = Query { runQuery :: db -> [a] }
06:28:15 <cadr> like that
06:28:20 <vixey`> ok
06:28:43 <vixey`> Query :: * -> * -> *
06:29:06 <vixey`> :t return
06:29:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:29:17 <vixey`> A monad has got to be * -> *
06:29:21 <vixey`> so Query can't be one
06:29:34 <cadr> ok, this is sounding familiar now
06:29:36 <cadr> :)
06:32:20 <cadr> I'm thinking they might have wrapped Query in something
06:33:38 <cadr> And I need to run off for a bit.  Thanks for the help!
06:36:30 <sbahra> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html
06:36:31 <sbahra> wow
06:36:31 <lambdabot> Title: 8.17. Concurrent and Parallel Haskell, http://tinyurl.com/25eyfl
06:51:16 <henrylaxen> Is there a simple way to inspect the source code from a library.
06:51:16 <henrylaxen>              For example, I am trying to figure out how to use happs, and
06:51:16 <henrylaxen>              would love to be able to view the source of a particular function
06:51:16 <henrylaxen>              while I'm in emacs.  Has anyone written such a beast?
06:53:39 <maltem> Not sure about emacs, but haddock documentation, if generated with the appropriate option, includes source links
06:54:20 <ToRA> my general approach to that problem is to download the library source, run hasktags over it, and then use the tags functionality in my editor (which in my case is vim, but exists in emacs too)
06:55:28 <vixey`> mmm watching things typecheck in slow motion is relaxing
06:55:44 <henrylaxen> I guess I'm being lazy, but since I'm using cabal install ... and everything gets loaded into my .cabal directory, I was hoping someone had written a little script that grabs all the .gz source files, generates tags.. etc.
06:56:56 <ToRA> i'm fairly sure you could have moved, unzipped and tagged the stuff in less characters than it would have taken you to explain you're being lazy ;)
07:00:17 <luite> do I need some special ghc or library to build lambdabot-utils? I get this error when building it:
07:00:21 <luite> Lambdabot/Regex.hs:48:42:
07:00:24 <luite>     Couldn't match expected type `bytestring-0.9.0.1.1:Data.ByteString.Internal.ByteString'
07:00:28 <luite>            against inferred type `ByteString'
07:01:10 <paolino> with StateT s []  the state is rollbacked with the return [] ?
07:01:15 <Snark> hmmm... how can I type accents in my strings and have them look like this in ghci?
07:01:34 <Snark> :t "éê"
07:01:34 <Snark> "��" :: [Char]
07:01:36 <lambdabot> [Char]
07:01:41 <Snark> this looks like this currently...
07:02:14 <ToRA> paolino: StateT s [] has a seperate state per item in the underlying [] (so yes in theory).  ListT State would have one global state across all items in the list
07:02:27 <mauke> luite: this sounds like things were built against differenct versions of bytestring on your system
07:03:11 <paolino> ToRA: so ListT State is suitable for a cut in depth search ?
07:03:15 <mauke> Snark: sounds like bug http://hackage.haskell.org/trac/ghc/ticket/2302
07:03:17 <lambdabot> Title: #2302 (error messages mangle unicode characters) - GHC - Trac
07:03:40 <ToRA> paolino: eek, erm let me think
07:03:51 <ToRA> yes, you could encode cut like that
07:06:40 <paolino> something like stop when searching deeper then the shortest solution found
07:08:07 <paolino> should be StateT [a] (ListT  State Int) [[a]], which is scary
07:08:57 <paolino> lost ...
07:09:53 <paolino> now, without cut it's search :: Prices -> StateT (Set String) [] [String]
07:10:25 <Snark> mauke, thanks
07:11:03 <paolino> I use the Set for other means, but it's ok to measure depth
07:16:06 <maltem> Snark: There is whole set of utf-8-related tickets in the ghc bug tracker
07:18:06 <maltem> Snark: fwiw ghci 6.8.2 will not try to print Unicode characters in that case, and just print the Unicode code points: "\233\234"
07:28:51 <paolino> where can I learn to use ListT ?
07:29:49 <pgavin> poolino: check wikibooks
07:29:52 <ToRA> > flip runState False . runListT (do { x <- ListT $ return [1,2,3] ; return x*2 })
07:29:54 <lambdabot>   Not in scope: data constructor `ListT'
07:30:16 <ToRA> that's the general idiom for turning a list into a ListT computation
07:30:26 <ToRA> though apparantly there are things wrong with the current ListT impl
07:30:37 <pgavin> paolino: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
07:31:15 <Saizan> ListT m is not a monad in general
07:32:17 <SamB> has anyone done a proof that ListT is a monad given certain constraints on the underlying monad?
07:32:34 <SamB> mattam: for instance, have you?
07:33:04 <SamB> mattam: I should grab your library with Monad and so forth for Coq...
07:33:23 <mattam> Nope, I'd like to.
07:33:30 <vixey`> SamB: I have [] Maybe and Either, would like to know how to add -> and such..
07:34:07 <vixey`> (and transformers I think have the same problem as ->.. not sure)
07:34:25 <SamB> vixey`: well, -> is not a type constructor in Coq...
07:34:35 <mattam> Yes, well it's not in a compilable state right now, but if you want to work on it I'd be glad to help.
07:34:37 <SamB> it is a primitive operator...
07:34:38 <mar77a> okay i'm back with my split function which splits a string by a string token and returns a list of the splitted strings
07:34:47 <paolino> ToRA: please write a working example :d
07:34:49 <mar77a> i have NO IDEA how to do this, after many failed attempts
07:34:52 <SamB> or, well, sugar for another one
07:35:15 <mattam> arrow A B := A -> B is
07:35:28 <vixey`> I was using -> shorthand for what mattam says
07:35:31 <paolino> ToRA: No instance for (Num (ListT (State Bool) a))
07:35:31 <paolino>       arising from a use of `*' at <interactive>:1:68-77
07:35:38 <SamB> vixey`: ah
07:36:02 <SamB> mattam: yes, I was just saying that one would need to make something like that first ;-)
07:38:06 <Snark> hmmm... is there some kind of split functions which would look like a  (a -> Bool) -> [a] -> ([a],[a]) -- ie split a single list into the list of elements which match a condition and those that don't ?
07:38:23 <Snark> it's easy to write, but if it's already there the better
07:38:27 <conal> :type partition
07:38:52 <paolino> ToRA: got it, thanks
07:38:58 <SamB> Snark: yes, it is called partition
07:39:02 <conal> @type partition
07:39:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:39:11 <Snark> conal, SamB : wonderful!
07:39:13 <Snark> thanks
07:39:18 <SamB> conal: huh, apparantly it only works with :t
07:39:21 <SamB> :t partition
07:39:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:39:24 <conal> oh!  :P
07:39:29 <SamB> heh
07:39:35 <conal> oh -- one is for ghci and one for lambdabot?
07:39:44 <vixey`> :t ?works
07:39:45 <lambdabot> forall t. (?works::t) => t
07:39:57 <conal> weird
07:40:01 <vixey`> It's just that lambdabot is really buggy
07:40:18 <SamB> conal: they are both for lambdabot in this context...
07:40:26 <SamB> (:t and @type, that is)
07:40:40 <SamB> :t is in immitation of what many type in GHCi
07:40:42 <lambdabot> parse error on input `in'
07:41:02 <vixey`> :type does this work too?
07:41:09 <SamB> because it lets you abbreviate a command to an unambiguous prefex
07:41:23 <SamB> but lambdabot only supports ":t"
07:42:13 <SamB> (actually, ghci also lets you abbreviate to an ambiguous prefix, but typically it will then do the thing you didn't want...)
07:42:37 <SamB> (for instance, :b now expands to ":break")
07:42:47 <SamB> (not ":browse")
07:45:57 <mar77a> what was the @thingy to use in (x:xs)?
07:46:06 <vixey`> xxs@(x:xs)
07:46:28 <mar77a> split str str'@(x:xs) = (takeWhile (not $ isPrefixOf str str') str') : split str xs
07:46:47 <mar77a> i don't understand the type mismatches error
07:47:07 <mar77a> Char -> Bool instead of Bool
07:47:08 <mrd> takeWhile expects a function
07:47:33 <ToRA> SamB: :def b (const $ return ":browse")
07:47:35 <mrd> (not $ isPrefixOf str str') :: Bool
07:47:47 <mar77a> why?
07:48:06 <mrd> mar77a: because it takes ... while ... the function returns true
07:48:24 <mar77a> and isPrefixOf returns a Bool
07:48:36 <mrd> and
07:48:38 <SamB> ToRA: well, yes, I have an equivalent definition in my ~/.ghci file
07:48:41 <mrd> you need a Char -> Bool there
07:48:53 <mar77a> ah
07:49:12 <mar77a> yeah i get it now
07:49:21 <mar77a> but i have no idea how to write what i really wanted :|
07:49:47 <joey__> Try removing the "str'" in isPrefixOf str str'
07:50:11 <vixey`> :t nat
07:50:12 <mrd> (not . isPrefixOf str)
07:50:13 <lambdabot> Not in scope: `nat'
07:50:16 <vixey`> :t not
07:50:18 <lambdabot> Bool -> Bool
07:50:21 <vixey`> :t isPrefixOf
07:50:22 <mrd> that would be a String -> Bool
07:50:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:50:25 <vixey`> :t isPrefixOf ?x
07:50:27 <lambdabot> forall a. (Eq a, ?x::[a]) => [a] -> Bool
07:50:34 <joey__> In fact, that won't work either
07:50:36 <mrd> what are you trying to do?
07:50:36 <vixey`> :t not . isPrefixOf ?x
07:50:38 <lambdabot> forall a. (Eq a, ?x::[a]) => [a] -> Bool
07:50:41 <mar77a> my problem's i'm working with a list of lists
07:50:55 <mar77a> need to work with more than one element at a time
07:51:15 <mar77a> finding a string inside a string and return a list of strings
07:51:27 <mrd> which strings do you return
07:51:32 <joey__> vixey`: What's the ?var notation?
07:51:42 <vixey`> :t ?x
07:51:43 <mar77a> the ones seperated by an arbitrary string
07:51:44 <vixey`> :t x
07:51:48 <lambdabot> Expr
07:51:48 <lambdabot> forall t. (?x::t) => t
07:52:27 <vixey`> joey: it's a syntax for undefined
07:52:31 <mrd> > filter ("abc"`isPrefixOf`) ["abcdef","xyzdef","abcxyz"]
07:52:31 <joey__> Oh, is that a lambdabot plugin or GHCi?
07:52:46 <lambdabot>  thread killed
07:52:47 <mrd> @botsnack
07:52:47 <lambdabot> :)
07:52:59 <mar77a> nono, something like: split "," "1,2,3" == ["1","2","3"]
07:53:17 <vixey`> mar77a; I think you should write a function that does this  chomp "<>" "aaa<>bbb<>ccc" ~> ["aaa","bbb<>ccc"] first
07:53:17 <mrd> @go haskell split string
07:53:18 <lambdabot> No Result Found.
07:53:41 <vixey`> mar77a; once that existed, writing the string splitter will be very easy
07:53:42 <vixey`> oh
07:53:52 <vixey`> I really meantchomp "<>" "aaa<>bbb<>ccc" ~> ("aaa","bbb<>ccc")
07:54:02 <mar77a> what's with the ~>?
07:54:06 <mrd> evals to
07:54:10 <mar77a> k
08:01:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8452
08:02:07 <mar77a> my brain is broken
08:02:13 <mar77a> help, vixey` :<
08:02:30 <mrd> wouldn't you want it to be isPrefixOf
08:02:37 <mrd> it's always going to be isInfixOf
08:02:44 <mar77a> oh yeah
08:02:46 <mar77a> prefix
08:03:09 <mrd> do you really want to return str when you find it?
08:04:24 <mar77a> ops
08:04:32 <mar77a> i want to return all the x's so far
08:04:32 <mrd> is the result of "chomp str xs" going to be sufficient to answer the question of "chomp str (x:xs)"?
08:04:53 <mrd> what do you need to do after you do the recursion
08:05:05 <mar77a> sec
08:05:16 <mar77a> how do i return a list of all the x's so far?
08:05:58 <vixey`> mar77a: there are two cases to consider
08:05:58 <mrd> read my 3rd question
08:06:07 <mar77a> i don't really get it
08:06:21 <vixey`> mar777a: the cases are:
08:06:29 <vixey`> chomp "<>" "aaa<>bbb<>ccc"
08:06:30 <vixey`> chomp "<>" "<>bbb<>ccc"
08:06:37 <vixey`> the second one is easy
08:06:44 <maltem> mar77a: I'd worry about a logical error in your code. You rip off x, not the prefix you found
08:06:53 <vixey`> so can you write the second one?
08:07:08 <mar77a> not really :x
08:07:28 <mrd> can you say what the result should be
08:07:44 <mrd> chomp "<>" "<>bbb<>ccc" ~> what?
08:07:51 <vixey`> chomp delimiter string | delimiter `isPrefixOf` chomp = _
08:07:51 <vixey`>                        | otherwise                    = _
08:08:01 <vixey`> :S
08:08:05 <vixey`> I wrote chomp but I mean string
08:08:38 <mar77a> gah
08:09:05 <mar77a> someone give me my loops back pls
08:09:07 <vixey`> answering mrds question will get you there
08:09:17 <mar77a> the last one?
08:09:23 <vixey`> mar77a: Don't use a loop yet
08:09:28 <vixey`> mar77a: do the base case first
08:09:29 <mar77a> it'd be ("","bbb<>ccc")
08:09:35 <vixey`> ok great
08:09:36 <vixey`> so
08:09:51 <vixey`> ("", drop (length delimiter) string)
08:10:04 <vixey`> right?
08:10:06 <mar77a> sec
08:10:37 <mar77a> ok
08:10:43 <vixey`> now you have
08:10:44 <vixey`> chomp delimiter string | delimiter `isPrefixOf` chomp = ("", drop (length delimiter) string)
08:10:44 <vixey`>                        | otherwise                    = _
08:10:59 <vixey`> so what to think about, to figure out the recursive case is:
08:11:15 <mar77a> er
08:11:24 <vixey`> given that: chomp "aa<>bbb<>ccc" ~> ("aa", "bbb<>ccc")
08:11:25 <mar77a> chomp delimiter string | delimiter `isPrefixOf` chomp <-- string??
08:11:49 <vixey`> what is chomp "aaa<>bbb<>ccc"? i.e. how do you combine 'a' with ("aa", "bbb<>ccc") to get the right result
08:12:03 <vixey`> mar77a: yeah that should be string not chomp like I said earlier
08:12:06 <mar77a> waittttttt wait
08:12:26 <vixey`> do you know proof by induction?
08:12:33 <mar77a> maybe
08:12:48 <vixey`> it will be quite hard to program if you don't know it..
08:12:58 <mar77a> probably don't know it by its name
08:13:32 <maltem> sure you can understand structural recursion without knowing proof by induction
08:13:51 <mrd> but then you do understand proof by induction :)
08:13:56 <maltem> right :)
08:13:59 <vixey`> mar77a: say you have a property you wanted to prove for every number, 0, 1, 2, 3, ..., well if you proved it for 0, and you assumed it for n and proved it for n+1, then it's true for all n right?
08:14:16 <mar77a> yeah
08:14:21 <vixey`> mar77a: You use exactly the same thought process when you program recursive functions on recursive data structures like lists
08:15:09 <vixey`> so you can just now (that we've got the base case), assume the function works for the tail of the input
08:15:18 <vixey`> now how do you define it for head:tail?
08:15:43 <mar77a> that's what i have no idea how to
08:15:49 <vixey`> in the example "aaa<>bbb<>ccc" you've got the result  ("aa", "bbb<>ccc") by recursion
08:15:52 <mar77a> cause i usually process and store one element at a time
08:15:54 <vixey`> and the head of the list is 'a'
08:16:06 <maltem> mar77a: Maybe, let's take the standard numeric example: fac 0 = 1; fac n = n * fac (n - 1).  It is important to note that in each recursive step, n becomes smaller, so we'll eventually reach the base case (fac 0).
08:16:16 <mar77a> yeah i understand that
08:16:25 <vixey`> what should chomp "aaa<>bbb<>ccc" be? and how do you get that by combining ("aa", "bbb<>ccc") with 'a'?
08:16:49 <vixey`> once you can do that with these concrete data, the next step is to write it out in terms of variables
08:16:55 <maltem> mar77a: With recursion on lists, by the same argument, it is important that the length of the list becomes smaller in each recursive step
08:17:21 <mar77a> it'd be ("aaa", "bbb<>ccc")
08:17:37 <mar77a> and to combine those two...
08:17:43 * mar77a explodes
08:17:45 <vixey`> > let (p,q) = ("aa","bbb<>ccc") in ('a':p,q)
08:17:46 <lambdabot>  ("aaa","bbb<>ccc")
08:18:15 <mar77a> mm
08:18:21 <vixey`> > ((:'a') &&& id) ("aa","bbb<>ccc")
08:18:21 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Char'
08:18:27 <vixey`> > (('a':) &&& id) ("aa","bbb<>ccc")
08:18:28 <lambdabot>  Couldn't match expected type `[Char]'
08:18:32 <vixey`> hmm
08:18:33 <mrd> |||
08:18:37 <vixey`> > (('a':) ||| id) ("aa","bbb<>ccc")
08:18:38 <lambdabot>  Couldn't match expected type `Either [Char] [Char]'
08:18:39 <vixey`> ok cool D
08:18:41 <mrd> er
08:18:45 <mrd> whatever the operator is
08:18:46 <mrd> *** ?
08:18:48 <vixey`> yeah
08:18:52 <vixey`> > (('a':) *** id) ("aa","bbb<>ccc")
08:18:53 <lambdabot>  ("aaa","bbb<>ccc")
08:19:10 <ToRA> first ('a':) ("aa", "bbb<>ccc")
08:19:12 <ToRA> > first ('a':) ("aa", "bbb<>ccc")
08:19:13 <lambdabot>  ("aaa","bbb<>ccc")
08:19:16 <mrd> that too
08:19:35 <mar77a> :/
08:20:04 <ToRA> this split problem, what's it supposed to do on split "<>" "1<><>2" ? ["1","2"] or ["1","","2"] ?
08:20:15 <mar77a> 2nd one
08:20:22 <maltem> mar77a: Arrow combinators are only important when you start to get cool ;)
08:20:40 <ToRA> 'k
08:22:16 <ToRA> ok, so how not to solve the split problem (since i've just spent 10 mins working this out)...
08:22:19 <ToRA> > let foo = fix (\f sep xs -> maybe [xs] (\(l,r) -> (l:f sep (drop (length sep) r))) . listToMaybe . snd . break ((sep `isPrefixOf`) . snd) $ zip (inits xs) (tails xs)) in foo "<>" "1<>2<><>3"
08:22:20 <lambdabot>  ["1","2","","3"]
08:23:31 <mar77a> chomp delim string | delim `isPrefixOf` string = ("", drop (length delim) string) | otherwise = t = takeWhile (not $ delim `isPrefixOf` string in (t, drop (length t) string)
08:24:08 <vixey`> > let split delim "" = [] ; split delim string = let (h,t) = chomp delim string in h : split delim t in split "<>" "aaa<>bbb<>ccc"
08:24:09 <lambdabot>  ["aaa","bbb","ccc"]
08:25:05 <ToRA> where did chomp come from?
08:25:08 <vixey`> mar77a: the recursive case should be much simpler than that
08:25:14 <mar77a> >:
08:25:20 <vixey`> ToRA: mar77a is writing it :)
08:25:29 <mar77a> ; ;
08:25:39 <vixey`> just generalize let (p,q) = ("aa","bbb<>ccc") in ('a':p,q)
08:25:46 <ToRA> heh
08:26:23 <vixey`> (notice that doesn't use takeWhile or isPrefixOf at all)
08:27:19 <mar77a> :///
08:27:31 <mar77a> how does that fit in the otherwise
08:27:38 <vixey`> that's it
08:28:40 <maltem> mar77a: You've put the base case again into the otherwise case, instead of recursing
08:28:56 <mar77a> i've put the brain case
08:29:13 <mar77a> but apparently it doesn't work :(
08:30:03 <mar77a> i give up, i'll try to solve this again in 5 months or so
08:30:26 <vixey`> mar77a: Why don't you look at the version I'll write and try to understand it?
08:30:36 <mar77a> that's cheating
08:30:55 <vixey`> you're trying to learn here, not beat someone :)
08:31:06 <mar77a> myself
08:31:12 <mar77a> can't find it scrolling up
08:31:14 <mar77a> mind pasting it?
08:32:21 <vixey`> chomp _ [] = ([],[])
08:32:21 <vixey`> chomp del (x:xs) | del`isPrefixOf`(x:xs) = ("",drop (length del) (x:xs))
08:32:21 <vixey`>                  |       otherwise       = let (h,t) = (chomp del xs) in (x:h,t)
08:32:21 <vixey`> split delim "" = []
08:32:22 <vixey`> split delim string = let (h,t) = chomp delim string in h : split delim t
08:35:42 <mar77a> i don't get the let bits
08:35:59 <vixey`> > let (h,t) = ("foo","bar") in (t,h)
08:36:00 <lambdabot>  ("bar","foo")
08:36:14 <monochrom> good morning
08:36:15 <mar77a> well not that exactly, the concatenation part
08:36:21 <vixey`> > let (h,t) = chom "," "foo,bar" in (t,h)
08:36:22 <lambdabot>   Not in scope: `chom'
08:36:25 <vixey`> > let (h,t) = chomp "," "foo,bar" in (t,h)
08:36:26 <lambdabot>  ("bar","foo")
08:36:30 <vixey`> hi monochrom
08:37:07 <DRMacIver> Why are green thread systems like GHC's or Erlang's able to scale so much more than kernel threads? Is there some major difference in the approaches / something that kernel threads do better / something else ?
08:37:19 <mar77a> ok i get it now
08:37:22 <mar77a> vixey`++
08:37:22 <mar77a> vixey`++
08:37:23 <mar77a> vixey`++
08:37:28 <vixey`> :D
08:37:32 <mar77a> thanks for your time
08:38:07 <mrd> DRMacIver: less overhead, no context switching?
08:38:09 <monochrom> DRMacIver: First of all, green threads skip the user-space-kernel-space switching.
08:38:22 <vixey`> mar77a: just ask me if you want a recursive problem to try to solve in the same way by yourself
08:39:09 <mar77a> you have to admit this problem is a bit complicated for a newbie like me :<
08:39:58 <mrd> it's not terribly complicated once you carefully break it down into small pieces
08:40:07 <vixey`> mar77a: I think if you're used to writing loops you've had your brain trampled on s,i,n,g,l,e,s,t,e,p,t,h,i,n,k,i,n,g and it's hard to get out of it
08:40:13 <mrd> it just seems that way if you let yourself become overwhelmed
08:40:29 <monochrom> recursion skill = divide and conquer skill
08:40:30 <mar77a> i had never used this multi-part approach
08:40:37 <vixey`> mar77a: when you read a program that loops, the only way to understand it is by actually executing the program in your head
08:40:42 <mar77a> er with the whole list in list thingy
08:41:42 <vixey`> mar77a: but when you read a recursive definition, you have like monochrom just said, a problem divided into individual cases which can be thought about seperately
08:41:59 <mar77a> i had no idea how to divide it into smaller problems
08:42:09 <DRMacIver> mrd: Ok, but why less overhead?
08:42:22 <vixey`> mar77a: the secret is induction on the datatype
08:42:24 <vixey`> @src []
08:42:24 <lambdabot> data [] a = [] | a : [a]
08:42:28 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059
08:42:29 <lambdabot> Title: local variables don&#39;t cause side effects - comp.lang.functional | Google Gro ..., http://tinyurl.com/5brrqc
08:42:30 <DRMacIver> And I'm not sure I follow why user level task switching should be that much lower cost than kernel level.
08:42:40 <vixey`> mar77a: list has [] and (:), so you write a base case for [], and you write a recursive case of (:)
08:43:02 <vixey`> map f [] = []; map f (x:xs) = f x : map f xs -- do you see it?
08:43:06 <mar77a> yes
08:43:07 <DRMacIver> But that's probably a lack of OS knowledge.
08:43:12 <monochrom> DRMacIver: green thread goes through one task switching, OS thread goes through two.
08:43:29 <mrd> DRMacIver: the green threads just need a stack and a little book-keeping data
08:43:38 <monochrom> green thread: task0 -> task1.  OS thread: task0 -> kernel -> task1
08:44:13 <DRMacIver> monochrom: Ok. That explains a factor of 2. Now what explains the remaining factor of hundreds? :)
08:44:48 <DRMacIver> mrd: What do kernel threads need other than that?
08:44:52 <monochrom> alright, old kernels sucked, too. that was long known and long unsolved. :)
08:45:18 <mrd> all those crazy process and memory management structures
08:45:41 <mrd> there's no universal reason kernel threads have to be slower, it's just linux/unix design
08:45:41 <mar77a> how can i safely perform a tails on a list using catch instead of length >1
08:46:07 <mrd> mar77a: why are you using tail?
08:46:14 <mrd> use pattern matching
08:46:15 <mar77a> to get the last element of a list
08:46:23 <vixey`> > last [1,2,3,4,5]
08:46:23 <mar77a> which might be empty
08:46:23 <mrd> > last [1..3]
08:46:24 <lambdabot>  5
08:46:25 <lambdabot>  3
08:46:33 <vixey`> what should last [] be?
08:46:35 <ToRA> > drop 1 [1,2,3]
08:46:36 <lambdabot>  [2,3]
08:46:38 <ToRA> > drop 1 []
08:46:39 <mar77a> wait
08:46:39 <lambdabot>  []
08:46:45 <mar77a> > last []
08:46:46 <lambdabot>  Exception: Prelude.last: empty list
08:46:47 <DRMacIver> mrd: And windows design. And... well, are there any examples where they don't?
08:46:50 <mar77a> last, not tail
08:46:55 <vixey`> mar77a: I think having last [] crash and explode is just fine
08:47:08 <mar77a> o_o
08:47:17 <mar77a> i'll just write a safe_last
08:47:22 <monochrom> green threads are probably switched out at only convenient points where there also happens to be less data to save and restore.  OS threads switch at anywhere and you have to save full state.
08:47:23 <vixey`> mar77a: You are never ever going to write total program in haskell
08:47:30 <mar77a> whaaaaat
08:47:51 <mrd> mar77a: safeLast [] = Nothing; safeLast l = Just (last l)
08:47:51 <vixey`> total programs*
08:48:04 <ToRA> > listToMaybe . reverse $ []
08:48:05 <lambdabot>  Nothing
08:48:14 <vixey`> s/Nothing*Just/mzero*return/
08:48:15 <ToRA> > listToMaybe . reverse $ [1,2,3]
08:48:16 <lambdabot>  Just 3
08:48:30 <mrd> ok fine use mzero and return
08:48:33 <DRMacIver> monochrom: Not sure that's a viable explanation. Erlang used a single OS thread for a long time, so if it did that then it would have had to potentially leave processes waiting on other processes to be at a convenient place for al ong time
08:48:37 <vixey`> hehe
08:48:55 <ToRA> > take 1 . reverse $ []
08:48:56 <lambdabot>  []
08:49:03 <ToRA> depending on how you model failure
08:49:13 <SamB> DRMacIver: eh?
08:49:26 <monochrom> Erlang has access to deep magic.  <duck>
08:49:29 <SamB> monochrom: eh to you too
08:49:44 <SamB> what do you mean by "convenient points"
08:49:52 <monochrom> SamB: eh!
08:49:55 <DRMacIver> SamB: The suggestion was that green threads only get switched when it was convenient. I'm demonstrating why I don't think that can be the case.
08:50:26 <monochrom> For example ghc switches green threads at only ________________ (5 marks)
08:50:33 <vixey`> how come these 7 axioms are so hard to program :/
08:50:55 <monochrom> which 7 axioms? I love axioms!
08:51:12 <vixey`> Ax, Var, Prod, Abs, App, Weak, Conv :)
08:51:16 <vixey`> I hate them :[
08:51:22 <monochrom> Lovely. :)
08:51:31 <SamB> well, I think the other thing about green threads is that they don't need OS-level thread switches
08:51:40 <SamB> and don't entail a context switch to kernelspace
08:51:42 <Saizan> DRMacIver: afaiu OS threads are generally designed to be switched with threads of other processes, so you've also the virtual memory mechanism as an overhead for example
08:52:46 <SamB> vixey`: axioms of what?
08:52:50 <vixey`> PTS
08:53:40 <vixey`> it seems to be impossible for me to write a working typechecker for anything with (★,▢) :/
08:53:50 <monochrom> If you give it a good data structure, it is easier to program.
08:53:50 <DRMacIver> SamB: Ah.
08:54:09 <gubagem> but bad data structures make you become more creative
08:54:15 <gubagem> er code more creatively
08:54:23 <SamB> vixey`: are you using Coq or Haskell?
08:54:40 <SamB> gubagem: or just make your theorems unmanagable
08:54:44 <vixey`> I've written this (wrong about 8 times in Haskell) and this is my second attempt in Prolog
08:54:57 <gubagem> SamB: thats always fun
08:55:40 <monochrom> I don't believe in creativity anyway.
08:58:03 <vixey`> what I don't understand, and I would really like to... is why it's so hard
09:02:34 <Saizan> vixey`: do you get wrong results or nothing at all?
09:03:06 <monochrom> I can't explain why something is hard.
09:03:18 <vixey`> just things not typechecking which should, like id$bool$true should be type bool, but it doesn't
09:03:30 * vixey` takes a blank page and tries again..
09:07:19 <mrd> use twelf
09:07:38 <vixey`> ok, if this doesn't work I'll try twelf
09:07:55 <edwardk> vixey: what are you hacking up?
09:08:20 <vixey`> I am just trying to write a typechecker for PTSs, it looks so simple but it turned out not to be
09:08:39 <mrd> twelf is designed for this kind of thing
09:08:45 <edwardk> ah
09:08:51 <edwardk> using haskell?
09:09:06 <edwardk> twelf can be a royal pain in the keyster ;)
09:09:16 <vixey`> I've tried it 8 times in Haskell... and now I'm trying in Prolog (for a second time)
09:09:37 <vixey`> I am thinking that I must have some massive fundamental misunderstanding of PTSs or something
09:09:49 <edwardk> what representation did  you use in Haskell? hoas, debruijn, etc.
09:10:15 <vixey`> I tried the basic syntax with strings for variables and De Brujin
09:10:20 <edwardk> ah
09:10:31 <edwardk> did you check out lennart's simple lambda cube?
09:10:32 <vixey`> I've never actually used HOAS for anything
09:10:48 <vixey`> yeah I had a look
09:10:51 <edwardk> i also have one lying around here somewhere
09:11:01 <vixey`> oh, I would really like to see it also
09:11:13 <shapr> yarr
09:11:25 <edwardk> i'll see if i can dig it up and get back to you with it
09:11:47 <vixey`> ty :)
09:12:03 <edwardk> i beat my head on various hoas representations trying to use the boxes go bananas approach, but iirc i decided you can't make that rep work for a dependently typed language
09:12:38 <vixey`> that seems likely, I guess.. you would maybe have to use dependent HOAS to do it
09:12:59 <mrd> yea you'd need a new subst theorem
09:13:07 <edwardk> that said i should have a good dozen different PTS variations lying about from back when I was banging on the code to Nuel.
09:13:35 <vixey`> what is Nuel?
09:15:03 <edwardk> Nuel was a toy language that I was obsessed with a couple of years back, basically when I was looking very heavily into substructural type systems. I'd gone through and figured out how to integrate linear, relevant, affine and uniqueness typing in one type system using Nuel Belnap's display logic as the basic logic for the language (through the Curry-Howard correspondence)
09:15:17 <vixey`> wow!
09:15:25 <edwardk> Unfortunately the resulting language is just too ugly to survive =)
09:15:32 <vixey`> yeah it sounds quite terrific
09:15:36 <vixey`> in a scary way
09:16:00 <edwardk> Anyways Ben Lippmeier came along with DDC, so I felt no real need to carry on in that direction.
09:16:31 <edwardk> I do like the idea of using display logic as the base logic for a language though, it leads to very clean semantics.
09:24:09 <ilyak_> I can't find where the Monad class is declared
09:24:11 <ilyak_> In GHC source
09:24:14 <ilyak_> Any hints?
09:24:30 <monochrom> Control.Monad
09:24:44 <monochrom> or I may be wrong.
09:25:01 <noecksit> hello, ive been looking at Control.Applicative it is seems very interesting
09:25:03 <ilyak_> There's a MonadPlus there
09:25:06 <ilyak_> No Monad
09:25:51 <wjt> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html
09:25:52 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2c5ecq
09:26:03 <noecksit> but i have one request that i havent seen yet, maybe its already implemented, just I havent found it yet, is it possible to make the "zip" function work on any Applicative functor?
09:26:23 <lostplan> I don't suppose anyone can recommend anywhere I can go in search of Haskelly job opportunities?
09:26:37 <noecksit> such as "pure zip <*> Just 1 <*> Just 2"
09:26:54 <noecksit> would return "Just (1,2)"
09:27:28 <ilyak_> wjt: Well, it isn't declared there
09:27:59 <wjt> oh, you're right.  it may be in GHC.Base
09:28:17 <ilyak_> Oh, really
09:28:29 <wjt> yeah, it is.
09:28:33 <ilyak_> Thanks
09:28:48 <noecksit> of course i could have "pure (\a b -> (a,b)) <*> Just 1 <*> Just 2" but there might be an better way
09:28:52 <mar77a> > 24*7
09:28:53 <lambdabot>  168
09:29:00 <vixey`> (\a b -> (a,b)) = (,)
09:29:16 <Schmallon> I'm new to haskell and I'm currently trying to implement a audio-sampler using the jack bindings.
09:29:23 <Schmallon> Everything is working to far but it's extremely slow. The profiler shows me, that most time + allocations are spent in a function which fetches the current sample from an array.
09:29:29 <Schmallon> The functions does nothing but "samples ! floor position" where samples is an UArray and position a Float.
09:29:34 <Saizan> noecksit: maybe you're thinking of liftA2 (,) ?
09:29:37 <Schmallon> What exactly does "!" do on an UArray? Doesn't it just read from memory and that's it?
09:29:55 <monochrom> some bounds checking
09:30:27 <Saizan> > liftA2 (,) (Just 1) (Just 2)
09:30:32 <lambdabot>  Just (1,2)
09:30:33 <Schmallon> any idea what makes it so much slower than let's say an array access in C?
09:31:18 <Igloo> The bounds checking
09:31:22 <noecksit> > pure (,) <*> Just 1 <*> Just 2
09:31:24 <lambdabot>  Just (1,2)
09:31:30 <noecksit> cool
09:31:51 <Igloo> And also, working out the real offset
09:32:02 <noecksit> i can rid of that ugly lambda thing
09:33:07 <Schmallon> That's enough to make it multiple times slower?
09:46:01 <smg> !seen byorgey
09:58:18 <smg> someone can help me with left/right derivation?
09:58:52 <parag1> smg: what problem are you having?
09:59:32 <smg> i somehow fail to do it. :(
09:59:37 <mapreduce> :t pure
09:59:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:00:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8453
10:00:16 <smg> parag1: it's in the paste
10:00:46 <parag1> smg: sorry I cannot help
10:01:04 <smg> :P
10:06:53 <vixey`> oh I think my checker works now!
10:07:37 <vixey`> I should probably get a better test succ (succ (succ zero)) :: nat
10:07:44 <vixey`> than*
10:09:22 <smg> hrhr
10:20:32 <vixey`> so in something like lambda Pi
10:20:55 <vixey`> since you don't have pattern matching .. you couldn't actually define the fold on natural numbers
10:21:34 <vixey`> all these need to be built in?
10:23:29 <RayNbow> "Setup.hs: The program haddock is required but it could not be found" <-- hmm, odd...
10:26:59 <smg> @seen byorgey
10:26:59 <lambdabot> I saw byorgey leaving #haskell-blah, #xmonad and #haskell 4h 58m 33s ago, and .
10:27:02 <smg> :(
10:27:05 <smg> i need help
10:38:51 <vixey`> how do you define = as a lambda term?
10:40:01 <vixey`> (it could be λ(a:★, λ(x:a, λ(y:a, λ(p:π(x:a, ★), π(g:p$x, p$y))))) )
10:40:28 <vixey`> maybe...
10:40:36 <gubagem> vixey`: how do i type lambda symbols and stars?
10:40:46 <vixey`> gubagem: I have no idea
10:40:55 <vixey`> gubagem: you could do what I do and just copy/paste them
10:41:06 <gubagem> mmm
10:41:27 <Saizan> gubagem: SCIM, or emacs tex mode
10:42:11 <vixey`> I like how my code is actually 5 lines, other than alpha/beta stuff
10:42:25 <vixey`> it's just a shame how many hours to took to write them ~_~
10:43:13 <RayNbow> gubagem, ★ <-- in Windows, if you have Microsoft's Japanese IME, you could type "hoshi[space][space][enter]"
10:43:52 <RayNbow> λ <-- ramuda
10:44:53 * ziman uses a custom xkb map and types RAlt+l for λ, RAlt+> for →, and so on
10:44:56 <RayNbow> (now, if only there was an IME that was tailored for mathematical symbols)
10:46:11 <vixey`> is there a nice symbol people use for Prop?
10:46:16 <vixey`> I don't want to use the word itsself
10:49:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8454
10:49:47 <smg> http://hpaste.org/8454
10:49:52 <smg> is my left derivation true for that CFG?
10:54:57 <monochrom> scim has a latex plugin, is an ime for math symbols.  windows? what is windows?
10:56:00 <monochrom> Blessed are those who are naive about the real world, for they don't have to suffer windows.
11:00:22 <monochrom> smg: I am a bit concerned with G* -> SG*.
11:00:56 <smg> mh? :|
11:03:34 <monochrom> G* is different from G.
11:06:33 <shapr> yarr
11:06:35 <shapr> @yow !
11:06:35 <lambdabot> Couldn't find fortune file
11:06:37 <shapr> aww
11:06:56 <smg> monochrom: do you think it's wrong?
11:07:37 <monochrom> Yes, it is wrong.
11:07:57 <smg> oh, can you be my teacher and help me? :)
11:09:20 <monochrom> To see why, rewrite the grammar so that it doesn't use *. For example, introduce a new non-terminal symbol H. Replace all occurrences of G* by H. Add a rule H ::= empty | GH.
11:09:36 <monochrom> Then see that H -> SH is impossible.
11:10:08 <smg> so is the grammar wrong or the derivation? :|
11:10:25 <monochrom> ::= is grammar. -> is derivation.
11:26:06 <vixey`> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
11:26:25 <vixey`> a bit delayed :P
11:32:47 <MyCatVerbs> Personally, I find Zippy to be the most boring section of the fortune pages - and that's including all the helpful hints in FreeBSD about how to make good use of tcsh. :P
11:35:18 <Vq^> "YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN DOLLHOUSE you can find!!  An make it SNAPPY!!"
11:35:22 <Vq^> :o)
11:35:54 <Japsu> pinkness is overrated
11:36:00 <mauke> Nullum magnum ingenium sine mixtura dementiae fuit.
11:36:06 <vixey`> I disagree
11:37:01 <Japsu> Lorem ipsum dolor sit segmentation fault.
11:41:27 <RayNbow> mauke, my Latin is a bit rusty :p
11:42:06 <RayNbow> although I get the gist of it
11:58:46 <Cheery> I have a trouble with DFA -operations
11:59:12 <mmorrow> oh yay dead languages
11:59:17 <mmorrow> segfault αειδε, ϴϵα
12:00:33 <Cheery> you know, if you use a simple way to join two DFAs, the complement of that DFA is different, compared to a bit more complex DFA joiner, that cuts out the dead paths for instance
12:04:28 <Schmallo1> Just to let you know: A few hours ago I asked why "a ! floor p" (a being an UArray and p a Float) is so slow. It turns out that it is not the array access but "floor" which makes it slow.
12:33:51 <byorgey> @seen smg
12:33:51 <lambdabot> smg is in #gentoo-haskell, #ghc and #haskell. I last heard smg speak 1h 23m 43s ago.
12:33:56 <byorgey> smg: looking for me?
12:36:56 <Deewiant> dons: ach, I did a 'reply' instead of 'reply all' so I ended up multi-posting - one to you and one to -cafe (re: Pipe), sorry 'bout that
12:42:58 <byorgey> Deewiant: oh, 'Pipe' is yours?
12:43:02 <byorgey> looks neat!
12:43:38 <Deewiant> aye, it's mine
12:45:13 <Deewiant> don't know if it's of that much practical use in programs though, I was hard pressed thinking of a decent example since everything's in a library somewhere :-)
12:46:04 <Deewiant> I guess that any use it'll see will be mostly in short scripts
12:50:27 <byorgey> yeah, I can see it being nice for quick little one-off scripts
12:50:49 <byorgey> it makes Haskell even more attractive as a script/glue language for system tasks
12:51:28 <Deewiant> it actually began its life as part of the make-replacement I'm writing
12:51:33 <litb> :)
12:51:36 <litb> hi there
12:51:45 <chessguy_> hi litb
12:51:46 <Deewiant> but I decided I'd make it a library of its own some time this week
13:01:34 <henrylaxen> I'm trying to build sqlite, but when I run runghc Setup.hs configure it says that I'm missing "utf8-string -any", however utf8-string is installed.  After doing a "locate utf8-string" I see that it is at /usr/local/lib/utf8-string-0.2/ghc-6.8.2 as well as /home/henry/.cabal/lib/utf8-string-0.3.1/ghc-6.8.2. Is there a way to perhaps specify the one in my .cabal directory, which is the right version, over the one in /usr/loca
13:01:34 <henrylaxen> Thanks.
13:01:41 <Beelsebob> @seen dons
13:01:41 <lambdabot> dons is in #haskell, #xmonad, #ghc, #arch-haskell and #haskell-soc. I don't know when dons last spoke.
13:07:00 <Saizan> henrylaxen: configure should be able to find at least one of them
13:07:21 <Saizan> henrylaxen: do you have multiple ghc installed perhaps?
13:08:29 <henrylaxen> No, just ghc6.8.2.  I install the utf8-string-0.3.1 via cabal install.  I don't know where the utf8-string-0.2 came from.  Is it kosher to just delete it?
13:09:15 <Saizan> henrylaxen: you can use ghc-pkg unregister on it
13:09:42 <Saizan> also, ghc-pkg list utf8-string should tell you if ghc sees the package
13:12:35 <henrylaxen> ghc-pkg list | grep utf shows utf8-string-0.3.1, no mention of utf8-string-0.2.  So probably that is not the problem with sqlite.  However when I run "runghc Setup.hs configure" I get: "Setup.hs: At least the following dependencies are missing: utf8-string -any"
13:13:10 <rwbarton> Does ghc-pkg list show utf8-string among the global packages, or your user-specific packages?
13:13:38 <henrylaxen> It is in the local packages, "/home/henry/.ghc/x86_64-linux-6.8.2/package.conf"
13:13:57 <rwbarton> Then cabal will only let you configure sqlite as a user package
13:14:14 <rwbarton> runghc Setup.hs configure --user   (and you might want --prefix=$HOME)
13:14:41 <henrylaxen> Where can I read about this cabal package managment?  I would love to really understand it.
13:17:13 <dons> henrylaxen: missing --user ?
13:17:28 <dons> cabal --help is a start.
13:17:45 <dons> but we surely have a thorough, documented guide on haskell.org/cabal , dcoutts ?
13:18:39 <Heffalump> hmm. I appear to have accidentally volunteered to give a 10 minute talk on a "technical topic related to Haskell and/or Haskell+Erlang" on Thursday. Any ideas...?
13:18:44 <Beelsebob> ah, a dons
13:18:44 <henrylaxen> Thank you guys, time for some reading.
13:19:20 <Beelsebob> dons: I found an interesting bug in LocH -- because it's just tokenising and not parsing, the preprocessor generates garbage if you do import Maybe (fromJust)
13:19:28 <Beelsebob> because it annotates the fromJust in the import line
13:19:58 <Beelsebob> Heffalump: what kind of audience?
13:21:15 <Heffalump> not entirely sure. This event: http://skillsmatter.com/event/erlang/erlang-exchange-2008-ug-sessions
13:21:17 <lambdabot> Title: Skills Matter : Erlang, http://tinyurl.com/64cg6x
13:22:07 <Beelsebob> hmm, so "come preach to some erlang guys about haskell so we can have a sacraficial pig"?
13:22:09 <Beelsebob> :D
13:22:20 <Heffalump> that is a slight concern, yes ;-)
13:22:28 * Beelsebob ponders what interesting things Haskell does that erlang doesn't easily
13:22:37 <Heffalump> types.
13:22:41 <Beelsebob> yes
13:22:48 <mauke> does erlang do unicode?
13:22:58 <Heffalump> I don't know anything about unicode, so I can't really talk about it.
13:23:04 <Beelsebob> not sure you could make a talk about it either
13:23:15 <Beelsebob> "Haskell does unicode" is about all you can say
13:23:20 <Beelsebob> which isn't a very informative argument
13:23:52 <mauke> > "haskell does unicode\0⁰"
13:23:53 <lambdabot>  ghc-6.8.2: panic! (the 'impossible' happened)
13:23:53 <lambdabot>   (GHC version 6.8.2 for i386-...
13:23:56 <Saizan> ession types? :)
13:24:00 <Saizan> *session
13:25:20 <Heffalump> hmm, that might be good. I don't know anything about them either, but I know people who do..
13:26:06 <lament> mauke: wow
13:26:11 <Beelsebob> maybe you could deliberately leap into the sacrafice pit and confuse them
13:26:19 <Beelsebob> do a talk on why paralelisation in Haskell sucks
13:26:24 <Beelsebob> and invite lots of comments on how to improve
13:27:01 <Heffalump> An overview of the parallelisation options sounds good, actually.
13:28:37 <lament> Haskell vs Erlang: Why Your Language Sucks And How My Language Is Better
13:28:47 <Beelsebob> lol
13:44:51 <hpaste>  rwbarton pasted "lazy pipe" at http://hpaste.org/8455
13:47:00 <rwbarton> Deewiant: ^^ you could make your pipe function lazy in the input string (though whether this works well depends on the program you run)
13:57:30 <adu> hey
13:57:39 <adu> why is HOC not compiling?
13:59:15 <adu> both hoc-0.7 and hoc-cvs eventually choke on HOC/HOC/Arguments.hs in the definition of declareStorableObjCArgument
14:00:01 <adu> at first I thought it was the ''ObjCArgument notation, but after I changed this to (mkName "ObjCArgument") it still didn't compile
14:04:00 <edwardk> ok, random question, (should be directed to #scheme, but no one there seems interested in talking about anything other than beer). Does anyone know anything about the status of stalin scheme?
14:04:56 <povman> adu: hoc hasn't been updated in a long time afaik
14:05:10 <adu> well, can I update it?
14:05:33 <povman> its latest feature is "ghc 6.2 support"
14:06:09 <SamB> someone was around here asking for help unbitrotting it...
14:06:20 <SamB> was it adu ?
14:06:30 <povman> i'd like that too
14:06:34 <adu> SamB: ya, hehe that was me
14:06:56 <povman> is there anyone actually maintaining it or what?
14:07:03 <adu> I was porting the 0.7 release to use Data.Map instead of Data.FiniteMap
14:07:03 <SamB> adu: can you provide some information regarding the complaint?
14:07:06 <byorgey> if it hasn't been updated in that long, it probably means no one would mind if you took over maintenance of it, adu
14:07:06 <povman> imo first thing to do is move it onto c.h.o
14:07:21 <adu> ok :)
14:07:58 <povman> adu: i'll help if you want
14:08:45 <adu> povman: help to move to code.haskell.org?
14:08:58 <povman> with unbitrotting it
14:09:06 <dons> adu, is hoc the obj-c binding?
14:09:12 <adu> dons: yes
14:09:23 <dons> i was talking to ozone yesterday, he'd love to see someone maintain it
14:09:31 <adu> dons: I will
14:09:35 <dons> get it on code.haskell.org, get it working again.
14:09:44 <dons> and there's a *lot* more mac users now then there used to be
14:09:49 <adu> ya
14:09:50 <dons> so build a community
14:10:10 <dons> we've python, perl , C , C++ bridges. why not obj-C!
14:10:11 <adu> but I have secret motives to see a mac-native version of Yi
14:11:23 <SamB> adu: not if I tell that to libraries@, you don't!
14:11:24 <povman> plus the advantage of having all of cocoa, ib etc available
14:11:39 <adu> lol
14:12:01 <adu> povman: right, then you can make screensavers, and quicktime extensions... etc
14:12:13 <povman> :D
14:13:22 <vixey> adu, have you thought about garbage collector interaction?
14:13:41 <vixey> (this is totally optional though)
14:13:56 <adu> vixey: nope, but thats a good point
14:14:34 <adu> how does one move to code.haskell.org?
14:26:52 <lokathor> question: I got "Occurs check: cannot construct the infinite type: a = [a]   When generalising the type(s) for `spl'"
14:26:59 <lokathor> what did i accidentally try to do?
14:27:10 <chessguy> @pastew
14:27:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:27:15 <chessguy> lokathor:  ^^
14:27:43 <hpaste>  loathor pasted "split" at http://hpaste.org/8456
14:28:02 <lokathor> silly me, forgot about pastebin
14:28:43 <lokathor> i'm trying to write a generic function for splitting lists on some kind of element; mostly for strings, but other lists would be nice too
14:29:03 <ddarius> :t span
14:29:06 <ddarius> @src words
14:29:06 <lambdabot> words s = case dropWhile isSpace s of
14:29:07 <lambdabot>     "" -> []
14:29:07 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:29:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:29:16 <mar77a> heh, vixey
14:29:18 <povman> it might be ((head remain):(head work)):work
14:29:18 <mar77a> ^
14:29:35 <povman> lokathor: try ((head remain):(head work):work)
14:30:01 <povman> wait i'm just a noob
14:30:04 <lokathor> hmm, ghc says no
14:30:38 <ilyak_> haskell examples where s, s', s'' represent different steps are especially brain-exploding
14:31:08 <povman> lokathor: comment out the type decs, ghc gives you a better error
14:31:12 <lokathor> so basically, words does it and you'd just need a version where you pass in any (a->Bool) ?
14:32:17 <lokathor> it gave a longer error, but in this case not a very much better error, it's still fixed upon the "cannot construct the infinate type" bit
14:33:22 <hpaste>  povman annotated "split" with "it needed more parentheses" at http://hpaste.org/8456#a1
14:33:57 <povman> lokathor: notice it gave you an exact location of the error though
14:34:03 <lokathor> ah ha! double parens!
14:34:16 <byorgey> lokathor: function application has higher precedence than anything else.  so (foo bar x:y)  parses as (foo bar x):y, not foo bar (x:y)
14:35:15 <lokathor> ah hmm, and : is right associative
14:35:19 <lokathor> which caused problems
14:35:54 <byorgey> adu: first you need to get an account, go to community.haskell.org to request one
14:36:02 <adu> ok
14:36:25 <byorgey> adu: then you can request a project from the same page, to get a directory like code.haskell.org/hoc
14:36:45 <adu> byorgey: also, I just emailed the ppl in hoc.sourceforge.org
14:36:50 <byorgey> cool
14:39:52 <adu> ok done
14:45:22 <adu> also I was wondering if the package-conf fileformat has changed between GHC-6.2 and GHC-6.8?
14:46:31 <adu> because hoc-0.7 uses a "[ Package { name = Thing }]" format and hoc-cvs uses "name: Thing"
14:46:46 <adu> is there a place where I can find documentation of this format?
14:57:41 <povman> which file?
14:59:31 <OceanSpray> What does it mean to box or unbox a tuple?
15:00:25 <SamB> OceanSpray: avoid allocating it on the heap
15:00:43 <pgavin> @seen dcoutts
15:00:43 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #xmonad. I last heard dcoutts speak 11h 28m 42s ago.
15:01:20 <OceanSpray> SamB, I still don't understand.
15:02:28 <povman> OceanSpray: in haskell, everything is a pointer
15:02:36 <povman> OceanSpray: unless it is unboxed
15:03:00 <SamB> OceanSpray: unboxed tuples are only allowed on the right of the function arrow
15:03:31 <SamB> they allow a function to return several values at one time, with no overhead
15:04:37 <ddarius> > let f (# x , y #) = I# (x + y) in f (# 3#, 4# #)
15:04:37 <lambdabot>  Parse error at "," (column 12)
15:05:37 <bos> and unboxing is GHC-specific.
15:05:42 <bos> not a haskell feature.
15:06:25 <SamB> they COULD be allowed on the left, but wouldn't really add anything
15:06:35 <vixey> ~(x,y)
15:06:51 <SamB> (I mean, you could just use two arguments instead ;-)
15:07:32 <OceanSpray> huh.
15:10:18 <povman> OceanSpray: (1,2) represents a pointer to a tuple, (#1,2#) represents two pointers to numbers
15:10:54 <povman> it saves you a pointer dereference
15:12:56 <rwbarton> So with unboxing you can write  (iterate (\(x,y) -> (y,x+y)) (0,1)) !! 100  and it'll only ever allocate one or two tuple objects in the heap?
15:16:58 <olsner> that's not so much an unboxing thing as a laziness thing
15:18:11 <olsner> but since (xs !! 100) has the only reference to the list, list cells that !! have already gone past can be garbage collected as you go
15:18:32 <rwbarton> Well, it still has to compose the function (\(x,y) -> (y,x+y)) with itself 100 times
15:18:36 <Botje> also, since you're unboxing, you don't get laziness and don't produce thunks
15:24:25 <mmorrow> Botje: just the person i wanted to see. i'm trying out milc and keep getting (as in always) "Prelude.undefined" error. I tracked it to (universeBi ast) called w/in the various transformations done in TransformAST.transformations. Why do you think this is?
15:27:00 <mmorrow> so, directly phrasing it (for the 01_helloworld.ml, 02_fac.ml tests at least), universeBi ast returns undefined
15:46:18 <siponen> Hi! Has anyone tried bootstrapping GHC on the xandros on an eeepc?
15:47:58 <Botje> mmorrow: hmmm
15:48:00 <Botje> that's weird
15:48:14 <Botje> mmorrow: how are you invoking it?
15:49:18 <Botje> mmorrow: also, what version of ghc are you using?
15:49:50 <Botje> what does ./Setup.lhs configure -v output?
15:51:55 <Botje> only thing I can see that would cause that is ast becoming undefined
15:53:35 <vincenz> heh.
15:58:37 <MyCatVerbs> siponen: oO
15:59:24 <sw17ch> before i start treading through this, i just want to make sure that no one's already tried :)
15:59:30 <sw17ch> is there a binding for ASound yet?
15:59:32 <MyCatVerbs> siponen: that would take quite a while, with the EEE's RAM and CPU. Not to mention space (and wear, more worryingly) on the flash drive.
15:59:39 <sw17ch> i didn't find anything but alsa-midi in hackage
16:00:26 <MyCatVerbs> siponen: a build of GHC HEAD, including darcs repos, costs about a gigabyte of disk space. (Actually, come to think of it, I would've expected it to be bigger...)
16:00:56 <parag1> has anybody tried logic programming languages like Curry and Mercury or Oz ?
16:01:10 <MyCatVerbs> siponen: (the sources and repos alone eat up 370MB.) The sources alone take... 20 megs. :)
16:01:17 <vixey> parag1: lots of people
16:01:32 <siponen> MyCatVerbs: I don't see a binary package yet, so somehow I'd need to get it running.
16:01:46 <MyCatVerbs> siponen: it's just an x86.
16:01:49 <siponen> The diskspace shouldn't be a problem.
16:01:57 <monochrom> can you use the x86 binary
16:02:01 <MyCatVerbs> siponen: the generic binary will work fine.
16:02:13 <parag1> vixey: how do these languages compare? what is the best? It seems haskell is the best of functional paradigm. How about logic programming?
16:02:20 <monochrom> otoh no one needs the whole repo to build ghc.
16:02:22 <siponen> Ok, thanks.
16:02:40 <vixey> parag1: I don't like curry
16:03:08 <MyCatVerbs> vixey: you don't like Curry compared to...? Other LP languages?
16:03:16 <ddarius> parag1: It depends on what you are looking for.  Prolog is about the only logic language with very significant traction.
16:03:47 <parag1> how about Oz? it claims to offer better approaches than Prolog.
16:03:48 <MyCatVerbs> ddarius: Prolog? Significant traction? From what I've seen, only for insignificant values of "significant". ;P
16:03:52 <vixey> MyCatVerbs: 99% of what I do in Prolog is just impossible in Prolog
16:03:54 <vixey> op
16:03:56 <MyCatVerbs> siponen: other than that, you could always slap Debian or something on there. :D
16:03:59 <vixey> MyCatVerbs: 99% of what I do in Prolog is just impossible in Curry*
16:04:01 <MyCatVerbs> vixey: uh.
16:04:09 <MyCatVerbs> vixey: oh, right. Huh.
16:04:15 <ddarius> Oz is a significantly multiparadigm language.
16:04:19 <MyCatVerbs> vixey: is Curry meant to be much faster or something?
16:04:28 <MyCatVerbs> vixey: like, no metaprogramming, or...?
16:04:33 <ddarius> In particular, Oz is not especially a logic language.
16:04:52 <povman> isn't there a logic monad for haskell?
16:04:56 <vixey> parag1: You should get the book The Reasoned Schemer if you are interested in Logic Programming beyond Prolog
16:04:59 <ddarius> MyCatVerbs: Curry is a functional logic language.
16:05:32 <siponen> MyCatVerbs: I'w read reports that the 900-series doesn't like some driver code in common kernels :(
16:05:35 <MyCatVerbs> ddarius: ...uhh, please elaborate?
16:05:40 <vixey> MyCatVerbs: yeah, basically it lacks macros and it's more verbose than Prolog
16:05:47 <monochrom> ma curry tasty est.
16:05:58 <ddarius> MyCatVerbs: If Prolog's traction is insignificant (which it is not, but it's not very significant), then other (pure) LP languages are non-existent (which is more or less accurate).
16:06:06 <parag1> vixey: it probably uses Scheme. I was more interested in something like Curry or Mercury which has foundation in Haskell
16:06:12 <MyCatVerbs> ddarius: given the only logic language I know is Prolog, so I kinda assume that all LP languages look at least a little like it...
16:06:25 <ddarius> MyCatVerbs: It's one thing you would get when you combine FP and LP.  It's a Haskell like language with narrowing.
16:06:25 <vixey> parag1: Mercury has no foundation in haskell
16:07:02 <MyCatVerbs> parag1: you can straightforwardly translate (almost) all Scheme into Haskell anyway, though. At the very least, all Scheme that doesn't use eval.
16:07:22 <MyCatVerbs> ddarius: oh. I'd always thought an LP-FP fusion would go the other way.
16:07:22 <ddarius> Most Scheme doesn't use eval.
16:07:33 <ddarius> MyCatVerbs: There are ones that go the other way.
16:07:39 <vixey> MyCatVerbs: actually yes, kanren was prototyped in haskell
16:07:50 <vixey> MyCatVerbs: and this is where LogicT comes from, for example
16:08:01 <MyCatVerbs> ddarius: start with Prolog, then use Haskell (or something very much like it) for "A is ..." expressions. Ideal, since the Haskell code will never have side effects. ^^
16:08:27 <MyCatVerbs> Would fit Prolog's semantics pretty much perfectly, even.
16:08:56 <MyCatVerbs> (Even takes advantage of the one-way nature of the "X is..." form.)
16:09:01 <ddarius> MyCatVerbs: That would be a boring integration and Prolog semantics are crap anyway.
16:10:09 <vixey> I was kind of interested in Typol
16:10:17 <vixey> but I couldn't find any implementations around
16:10:19 <MyCatVerbs> ddarius: boring from the Haskeller's point of view, sure. From the Prolog hacker's point of view, less so I think.
16:11:35 <ddarius> MyCatVerbs: Boring from everyone's point of view and anyway, if nothing else it would be more boring from a Prolog users point of view than a Haskellers as it doesn't add any expressiveness for them.
16:12:04 <cjay> somehow doing IO in prolog always feels dirty for me, I wish there would be monads in prolog
16:12:21 <vixey> cjay: Mercury uses IO monad
16:13:44 <cjay> vixey: how powerful is Mercurcy's logic stuff? because you said "99% of what I do in Prolog is just impossible in Curry"
16:13:54 <ddarius> Mercury /= Curry
16:13:56 <vixey> cjay: curry is nothing like mercury
16:14:22 <monochrom> mercurry
16:14:24 <cjay> yeah, Imean can you do more stuff in Mercury than in Curry?
16:14:25 <vixey> mercury looks good and really efficient, I don't use it though
16:14:35 <adu> hi vixey
16:14:40 <vixey> hey adu :)
16:15:00 <parag1> So, vixey what is your favourite logic programming lang? Prolog ??
16:16:14 <adu> parag1: my favorite logic PL is meta
16:17:15 <parag1> adu: in what ways do you find Meta better than Prolog?
16:17:33 <adu> parag1: its got a gui? i dunno
16:17:57 <adu> just wanted to throw that name around, thats all
16:18:02 <cjay> uhm. Meta is a really bad name for googling
16:18:10 <adu> yes, try "ASF SDF"
16:18:25 <adu> thats a much better google term
16:18:28 <cjay> haha
16:19:05 <cjay> oh, you were not kidding :)
16:19:15 <adu> yes, i was serious
16:20:34 <parag1> So, it seems FP-LP fusion is not in good stable state. So, use Prolog or similar for LP and use Haskell for FP ?? Is that what most people do?
16:20:59 <vixey> parag1: I don't understand what you are trying to figure out, what's your goal?
16:21:02 <adu> parag1: most people have never heard of FP/LP
16:21:53 <nus> FP is an offspring of the first attempt to do LP (-:
16:22:15 <adu> I thought it goes all the way back to Turing and Church
16:22:24 <nus> right, Church
16:22:32 <adu> Turing was like "it all be state changes!"
16:22:43 <adu> Church was like "it all be lambda calculus!"
16:22:53 <parag1> vixey: based on what I read about Curry and Mercury it seemed very interesting idea to be able to combine both declarative styles (declarative logic and declarative functional style)
16:22:53 <adu> and the world has been arguing ever since...
16:23:29 <nus> adu, actually he was all as "Foundation of Logic"
16:23:51 <adu> nus: apologies
16:23:56 <vixey> so was Martin-Lof
16:24:34 <nus> so far they found logic is inconsistent (-:
16:24:49 <MyCatVerbs> adu: er, more like "it all be reduction!"
16:25:01 <MyCatVerbs> adu: reduction to a fixpoint, no less. ^^
16:25:58 <adu> reduction ad nausea?
16:26:23 <adu> oops nauseam
16:28:19 <cjay> parag1: it makes me wonder why there aren't more widely used FP/LP languages, too. maybe it isn't as cool as it looks.
16:28:29 <adu> Oz is cool
16:28:32 <vixey> what I found most interesting about Oz was the way they implemented the logic programming portion of the language in terms of the constraint system
16:28:55 <adu> and one could consider Haskell type classes to be a form of LP
16:29:46 <parag1> I just saw a paper by Peter Van Roy that claims Prolog approach to logic programming is outdated and Oz offers better LP than Prolog
16:30:34 <MyCatVerbs> parag1: Oz gives you some control over the search strategy, right?
16:30:46 <adu> MyCatVerbs: yes it does
16:30:47 <parag1> something like that
16:31:43 <adu> I think it has builtins for enumerative / procedural
16:31:47 <vixey> adu: how come you aren't in #oz :)
16:31:54 <adu> vixey: i dunno
16:33:17 <parag1> Here is the paper I just mentioned : http://www.ps.uni-sb.de/PapersOz/Others/LogicProgrammingOzExperience.pdf
16:34:37 <parag1> vixey you are one of the few in #oz :)
16:35:07 <parag1> actually more like one of the 2
16:38:29 <bos> @seen dons
16:38:29 <lambdabot> dons is in #haskell, #xmonad, #ghc, #arch-haskell and #haskell-soc. I last heard dons speak 3m 34s ago.
16:39:46 <dons> bos, yo.
16:39:51 <bos> hey.
16:40:06 <dons> ah, got mail. reading.
16:41:38 <vixey> parag1: http://akira.ruc.dk/~henning/publications/UnknownPolish2001.pdf
16:42:42 <dons> bos, btw, i've an x61.
16:42:52 <dons> 3 months after i got it, under warranty, i had to get it cleaned out
16:42:55 <dons> since it was overheating.
16:43:05 <dons> hit 100 deg C after one particularly aggressive build
16:43:11 <dons> now it sits around 55 or so.
16:43:18 <dons> the fan was gummed up.
16:43:34 <dons> certainly hotter than my old x31
16:44:01 <dons> we had similar issues with 2 other x6* machines at work
16:44:37 <parag1> vixey: thanks. What do you prefer: Prolog or Oz?
16:47:27 <cjay> dons: too much dust at work? ;)
16:47:52 <dons> environmental dust, anyway. and overworking the laptop as a build farm...
16:47:57 <dons> we need ghc -power-save
16:48:04 <dons> ghc --not-so-bloody-hot
16:48:36 <sw17ch> does hsc2hs take care of Enumerations and constant definitions?
16:48:44 <jsnx> wouldn't CPU thottling be enough?
16:49:07 <dons> jsnx: in practice, yes.
16:49:19 <dons> sw17ch: yeah. see #enum
16:52:42 <dons> http://www.reddit.com/info/6oeob/comments/
16:52:43 <lambdabot> Title: reddit.com: Recursion with boxes in a dependently typed language
16:53:56 <dons> byorgey: there's some rss error in your latest post, no link to the original article
16:54:00 <dons> using the feed-cli client?
16:54:10 <byorgey> dons: huh? weird
16:54:19 <byorgey> dons: my post on byorgey.wordpress.com you mean?
16:54:26 <dons> well, as found from p.h.o
16:54:32 <byorgey> right
16:54:50 <byorgey> no, I'm not using feed-cli, it's just a vanilla blog hosted on wordpress.com
16:54:59 <dons> ah ok.
16:55:13 <byorgey> guess wordpress.com is having issues
16:55:38 <dons> what's the best way to publish the weekly hackage new/updated list, do you think?
16:56:28 <dons> i'm thinking a script that runs on wednesday, computes the new and updated list, in the form of the list on the front page of haskell.org
16:56:31 <dons> and sends that to the list.
16:56:42 <byorgey> dons: sure, I think that's a good idea
16:56:45 <dons> separating new and updated packages, with their synopsis attached
16:56:56 <dons> and drops an rss feed somewhere.
16:57:16 <dons> openbsd does this, Putting together an issue requires gathering information from a number of different sources, summarizing and compiling the information into a consistent, standard layout, and finally publishing the issue in s
16:57:20 <dons> grr.
16:57:21 <byorgey> now that it's not in the HWN, it would be good to have a bit more visibility than just being available as an rss feed
16:57:22 <dons> http://undeadly.org/cgi?action=article&sid=20080615153458
16:57:25 <lambdabot> Title: [c2k8]: New Ports of the Week #24 (June 14)
16:57:29 <dons> byorgey: right.
16:58:06 <adu> is there any way to disable PostScript in wxHaskell?
16:58:12 <byorgey> dons: hmm, about that rss error, it's weird... in my feed reader, it works just fine -- my post got cut off (which is weird) but there's a link to the original
16:58:33 <byorgey> but if I go to the planet haskell site, there's no link to the original, just a link back to planet haskell
16:58:34 <dons> adu, you were able to build wxhaskell?
16:58:41 <adu> nope
16:58:49 <dons> neither.
16:58:56 <hpaste>  adu pasted "wxHaskell make" at http://hpaste.org/8457
16:59:13 <dons> i strongly recommend gtk2hs if you want users, since no one can build wxHaskell, and its in few distros
16:59:28 <dons> until wxHaskell gets some maintainance
16:59:47 <adu> i would much rather maintain wxHaskell than HOC
17:00:20 <adu> both are essential core packages
17:00:20 <dons> well, bindings to the mac gui stuff, via HOC, are also critical
17:00:26 <dons> agreed.
17:00:36 <adu> I'm disappointed that both are broken
17:00:39 <dons> gtk2hs is the only thing well maintained currently
17:00:43 <adu> ic
17:00:49 <dons> but the community is a lot bigger than it used to be
17:00:56 <dons> so there's room to build groups to maintain things like this.
17:00:58 <vixey> oh
17:01:05 <dons> surely there's 3 or 4 mac users interested in HOC
17:01:25 <dons> i mean, there's 12 people in #arch-haskell, so i'm sure we can scrape together 6 mac users ....
17:01:37 <vixey> I can help with HOC if people get problems
17:01:59 <dons> adu, a start would be a HOC wiki page with the current status, goals, and what steps to take
17:03:03 * Nafai is a Mac user
17:03:10 <Nafai> But not much of a Haskell'er
17:03:57 <adu> Nafai: do you use either vim or emacs?
17:04:16 <Nafai> Both, but primarily Emacs
17:04:32 <adu> Nafai: then you'd probably like Yi
17:04:51 <adu> Nafai: its not much now, but it has Emacs bindings by default
17:04:57 <Nafai> I've played with Yi a bit a while back
17:05:18 <adu> I also made some pics for Yi:
17:05:20 <adu> http://tetration.itgo.com/up/art2.zip
17:05:32 <vixey> I wanted to write this geometry program in haskell but I couldn't get wx or gtx
17:05:43 <vixey> so.. hoc would be fine, I could use that if it worked
17:07:21 <Axman6> vixey: would a nice OpenGL interface be good?
17:07:36 <Axman6> if so, check out ANUplot... pretty sure you can download it
17:07:40 <adu> HOpenGL works well
17:07:40 <vixey> I would not use OpenGL but that would still be a good thing
17:07:46 <adu> I've used it to make rectangles
17:08:41 <adu> there are a few things that could use wrapping in HOC, like NSComparison => Ordering
17:09:38 <dons> yeah, all the opengl games seem to work quite fine.
17:09:42 <kiris> http://dis.4chan.org/read/prog/1213738601/l19 -- Do I know what I'm talking about? Discuss.
17:09:45 <lambdabot> Title: 4chan BBS - Haskell is
17:10:45 <TomMD> Yay, pureMD5 now performs 9% better.
17:11:37 <kiris> TomMD: nice :-]
17:11:53 <MyCatVerbs> adu: uhhhh. I could see Yi as a VI replacement, given some time, but Yi as an Emacs replacement? Nahhh, couldn't be.
17:12:34 <MyCatVerbs> adu: most of the whole point of Emacs is the enoooooormous quantity of elisp code freely available, and peoples' enourmously customized installs.
17:12:34 <hpaste>  adu pasted "dsview" at http://hpaste.org/8458
17:12:46 <kiris> ah, crap. I forgot about Real World Haskell. I'll just link him to that
17:13:07 <adu> MyCatVerbs: true, i agree
17:19:54 * byorgey cooks steamed lambdas in a peanut-Curry sauce
17:20:34 <adu> lol
17:21:27 <dons> kiris: i'm not sure its worth investing time in 4chan.
17:21:40 <dons> there are more productive thiings you can do.
17:24:27 <MyCatVerbs> dons: I find it implausible that investing time in reddit is productive either. ;)
17:24:41 <MyCatVerbs> dons: (and yet I still do. To heck with me.)
17:25:33 <dons> it's not very productive. writing articles that do well on reddit is worthwhile , however, (imo)
17:25:46 <dons> and carefully, calmly addressing misconceptions in public
17:26:00 <dons> we can't let our enemies define us.
17:27:49 <kiris> I think a few people have got into haskell thanks to /prog/ on 4chan
17:27:59 <kiris> true, though, there are certainly more interesting things to be doing
17:29:31 <adu> you know what would really put haskell on the map...
17:30:12 <adu> submiting Haskell demos at Assembly
17:30:24 <dons> is that a conference?
17:30:27 <adu> http://en.wikipedia.org/wiki/Assembly_(demo_party)
17:30:43 <dons> there's a lot of user outreach like that we can do.
17:30:59 <adu> I already know OpenGL :)
17:31:44 <adu> although I don't think you're allowed to use OpenGL for the 64k demos
17:33:38 <siponen> You can do it as a wild entry.
17:33:58 <siponen> You just need to add nudity and bathroom-humor
17:34:17 <kiris> I wrote a big-ass post about using Haskell to write a web interface to jbofihe: http://chrisdone.com/blog/2008/06/10/jbofihe-and-haskell/ but I don't really work on particularly interesting stuff so I don't make a good Haskell advocate, probably the opposite ;-o
17:35:50 <siponen> A nice web-gadget-library might bring in web-gadget-programmers. There is a lot of them.
17:36:20 <siponen> I think the majority of programmers write them.
17:36:57 <hpaste>  morrow pasted "milc biplate troubles" at http://hpaste.org/8459
17:38:09 <mmorrow> Botje: i was away from internet, but saw your reponse in the logs. here is the issue: http://hpaste.org/8459
17:38:28 * Botje looks
17:39:26 <Botje> mmorrow: hmm. to be honest, that looks like a GHC issue
17:39:47 <SamB> how do you prove coreturn =>> x == id x
17:40:21 <Botje> mmorrow: can you try universeBi $ ASTFunction "main" [(ASTPVar "_",ASTLit (ASTLitString "hello world!"))]
17:40:22 <mmorrow> hmm, i was thinking it might be something with my uniplate package, since i just installed the darcs version a few days ago. maybe something has changed?
17:40:32 <mmorrow> Botje: i'll try...
17:40:33 <Botje> (without the [], that is)
17:40:53 <Botje> i'm on 6.8.2 and it works fine for me
17:41:23 <Botje> so either uniplate is somehow broken with 6.9, or data/typeable deriving is wonky on 6.9
17:41:27 <kiris> siponen: sure. it's probably just missing the niceities, really.
17:41:47 <Botje> of course if i'm to blame i'll happily take my lashes :P
17:42:29 <mar77a-> parse cmd h | cmd == "pause_" = return (send h "/pause")
17:42:29 <mar77a->             | otherwise = (return ())
17:42:36 <mar77a-> what's wrong with the otherwise o_O
17:42:37 <mmorrow> Botje: oh yeah it might very well be something having to do with 6.8 to 6.9
17:42:45 <mmorrow> Botje: about to try that....
17:43:15 <Botje> if you know SYB, you can try that too
17:43:24 <Botje> else i'll try to concoct something :)
17:44:17 <hpaste>  morrow annotated "milc biplate troubles" with "same" at http://hpaste.org/8459#a1
17:44:28 <kiris> mar77a-: what's the given error?
17:44:45 <mmorrow> Botje: i know syb somewhat, but haven't used uniplate (but have meant to get to know it for some time), so i guess now's the time. I'll mess with it and see what I can do...
17:44:49 <mar77a-> couldn't match expected type "()" against inferred type "IO ()"
17:44:54 <mar77a-> the other way round actually
17:45:15 <Botje> mmorrow: you are a braver person than I am. good luck! :)
17:45:18 <kiris> ah
17:45:22 <kiris> it's the first one
17:45:32 <kiris> you don't need `return' on the first case
17:45:37 <mmorrow> Botje: milc is awesome :)
17:45:43 <mar77a-> truee
17:45:47 <kiris> it should be: cmd == "pause_" = send h "/pause"
17:45:49 <kiris> I think
17:45:51 <SamB> edwardk: have you found the coffee comonad yet?
17:46:42 <Botje> mmorrow: thanks :)
17:46:54 <ddarius> edwardk: Here's a short little paper vaguely related to that: http://www.numdam.org/numdam-bin/fitem?id=CTGDC_1986__27_1_81_0
17:46:54 <vixey> SamB: I did Reader btw (not sure, it's maybe not useful to you.. can't encode Cont in my current formalizm either)
17:46:55 <Botje> I plan on hacking in a type system tomorrow :)
17:46:58 <mmorrow> Botje: also, i added a library section to milc.cabal with an exposed-modules list so i could :m + Milc._ in ghci, i'll paste it if you're interested
17:47:15 <Botje> ooh
17:47:16 <Botje> shiny!
17:47:25 <Botje> I just do :l Milc.Parser
17:47:35 <Botje> (or whatever module I want to load)
17:47:42 <Botje> but :m support is cool
17:47:50 <mmorrow> i was doing that, but got fed up with losing all my interactively defined vars across reloads
17:47:51 <kiris> mar77a-: am I right?
17:47:56 <vixey> Botje: that'll be really neat having types
17:47:57 <mar77a-> correcto
17:48:01 <kiris> yay
17:49:00 <mmorrow> Botje: pasted
17:49:06 <hpaste>  morrow annotated "milc biplate troubles" with "milc.cabal with added library section" at http://hpaste.org/8459#a2
17:49:35 <Botje> you can split up a cabal file into executable and library?
17:49:39 <Botje> cabal++
17:49:44 * Botje is overwhelmed with cool today.
17:49:47 <mmorrow> oh yesh
17:50:07 <Botje> mmorrow++ # cool stuff!
17:50:13 <mmorrow> :)
17:53:35 <bos> dons: that's a shame about the x61
17:54:25 <mar77a-> how can i apply a function after 'extracting' the value off an IO action and before storing
17:54:28 <kiris> does ghci support sending code to it from say emacs (e.g. just compiling one function) like in SLIME? I seem to recall?
17:54:45 <mar77a-> something like: txt <- words getLine
17:54:49 <mar77a-> or well
17:54:53 <mar77a-> txt words <- getLine
17:55:14 <kiris> getLine >>= return . words, perhaps, or liftM?
17:55:23 <vixey> Botje: ohhh you are doing a compilers course,
17:55:36 <kiris> uh
17:55:59 <mrd> kiris: haskell-mode?
17:56:10 <kiris> txt <- liftM words $ getLine
17:56:12 <kiris> mrd: yeah
17:56:37 <mar77a-> buff <- (recv h >>= (\x -> (return . trim) x))
17:56:40 <mar77a-> hehe
17:56:47 <mrd> @go haskell-mode for emacs
17:56:48 <lambdabot> http://www.haskell.org/haskell-mode/
17:56:48 <lambdabot> Title: Haskell Mode for Emacs
17:56:54 <mar77a-> @src liftM
17:56:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:57:07 <kiris> my internet is going amazing slow right now
17:58:27 <Botje> vixey: yeah, I defended it thursday
17:58:38 <Botje> the guy who teaches it is a die hard C++ fan
17:58:45 <Botje> he didn't "get" monads
17:58:50 <Botje> I persuaded him to try again
17:59:01 <Botje> "ooh, this parsec thing looks handy, i'll give it another shot"
17:59:40 <mar77a-> er
17:59:45 <mar77a-> is there a sleep function somewhere?
17:59:48 <mar77a-> @hoogle sleep
17:59:49 <lambdabot> No matches found
17:59:50 <kiris> mrd: ah it does loading whole buffers. well, unless you know of any way that I can do it, I'll hack on this code to send sections of code to the ghci process
18:00:04 <mrd> i have some code to do that
18:00:20 <kiris> mrd: oh cool. link? =o
18:00:26 <mrd> its kinda hacky, because defns in ghci require 'let'
18:00:47 <kiris> mrd: yeah
18:00:51 <vixey> Botje: that's cool, I had some algorithms class before (in java) but my teacher was one of the parallel-ghc hackers
18:01:02 <Botje> hehe
18:01:21 <Botje> there's no functional programming presence at my uni, though
18:01:22 <Botje> bit of a shame
18:01:24 <kiris> mrd: but useful for maintaining your current test data and experimenting with some code
18:01:33 <kiris> mrd: could you paste it please?
18:01:44 <rwbarton> @hoogle threadDelay
18:01:44 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
18:01:44 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
18:01:47 <hpaste>  mrd pasted "inferior-haskell-send-region" at http://hpaste.org/8460
18:01:56 <kiris> thankies
18:02:31 <kiris> `char-bag', hehehe
18:02:41 <mar77a-> looks like the closes i have is timeout
18:02:43 <mar77a-> :t timeout
18:02:45 <lambdabot> Not in scope: `timeout'
18:02:48 <mrd> modelled after CL fwiw
18:02:51 <mar77a-> :t System.timeout
18:02:53 <lambdabot> Not in scope: `System.timeout'
18:03:01 <mar77a-> o_O
18:03:07 <kiris> mrd: yeah
18:04:07 <rwbarton> mar77a-: the threadDelay thing was for you (should have been clearer)
18:07:39 <mar77a-> yeah, thanks
18:08:38 <kiris> mrd: ahh it works. I think I'll mod it to open up an inferior haskell if one isn't already open
18:08:41 <kiris> mrd: cheers
18:08:47 <rwbarton> Oh, there is also System.Posix.Unistd.sleep
18:12:39 <mmorrow> excellent ccall+x86(32bit) reference:  http://www.caldera.com/developers/devspecs/abi386-4.pdf
18:14:02 <mmorrow> (+(dynamic) linking, elf, etc)
18:36:30 <Axman6> yahooooo == wahooooo?
18:36:47 <Axman6> yes
18:37:19 <mar77a-> > a == a
18:37:21 <lambdabot>  True
18:37:24 <mar77a-> :t a
18:37:26 <lambdabot> Expr
18:39:06 <monochrom> heh
18:39:45 <Axman6> > yahooooo == wahooooo
18:39:46 <lambdabot>   Not in scope: `wahooooo'
18:41:47 <Axman6> > lambdabot == haskell
18:41:47 <lambdabot>   Not in scope: `haskell'
18:41:51 <osfameron> dammit why isn't '' a synonym for []::String ?
18:42:10 <Axman6> :t ""
18:42:12 <vixey> that would not make sense
18:42:13 <lambdabot> [Char]
18:42:19 <Axman6> :t ''
18:42:21 <lambdabot> lexical error in string/character literal at character '\''
18:42:38 <osfameron> ah yes
18:42:41 <osfameron> ta
18:51:13 <Axman6> :t ' '
18:51:14 <lambdabot> Char
18:51:48 <vixey> :t (return,flip concatMap)
18:51:50 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> m a, [a1] -> (a1 -> [b]) -> [b])
18:54:41 <vixey> :t Mu
18:54:43 <lambdabot> Not in scope: data constructor `Mu'
18:56:44 <ddarius> Cale: Add data Fix f = Fix { unFix :: f (Fix f) } to lambdabot.
18:56:59 <Cale> :t in
18:56:59 <monochrom> Eh? Someone wants Mu? I can provide one. :)
18:57:00 <lambdabot> parse error on input `in'
18:57:02 <Cale> :t In
18:57:04 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
18:57:04 <Cale> :t out
18:57:06 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
18:57:10 <ddarius> Cale: Ah, you did.
18:57:10 <monochrom> Onoes!
18:57:33 <monochrom> Also, newtype is preferred to data for this.
18:57:39 <vixey> hehehe
18:57:57 <monochrom> We need to cabalise Cale.
18:58:12 <monochrom> Of course, I mean cabalise CaleExtension.
18:58:25 <vixey> brians~~
18:58:26 <EvilTerran> -XCaleskell
18:58:35 <vixey> brain* :S
18:58:43 <monochrom> "CaleExtension has everything conceivable. You can't outsmart CaleExtension."
18:58:58 <vixey> Mu (a,) = [a]
18:59:07 <vixey> Mu (Either ()) = N
18:59:24 <Axman6> o.O
18:59:30 <vixey> :k Mu Mu
18:59:32 <lambdabot>     Kind mis-match
18:59:32 <lambdabot>     Expected kind `* -> *', but `Mu' has kind `(* -> *) -> *'
18:59:38 <ddarius> Mu Maybe
18:59:54 <EvilTerran> isn't it [a] ~~ Mu (Maybe `O` (,) a)
18:59:56 <EvilTerran> ?
18:59:59 <monochrom> No, Mu (a,) cannot be [a]. Unless you restrict to infinite lists.
19:00:11 <EvilTerran> hence my maybe :)
19:00:47 <ddarius> We need a whole panoply of type level combinators.  B, C, W, S, K, I, Y.
19:00:50 <vixey> oh .. yes
19:01:00 <EvilTerran> ddarius, and X
19:02:56 <EvilTerran> but then what would we do with them?
19:03:02 <monochrom> GCC = Glorious Caleskell Compiler
19:03:13 <ddarius> EvilTerran: Be able to define any type we want without data statements.
19:03:32 <monochrom> "GCC 7.1 will have kind-level lambdas!"
19:03:56 <ddarius> @pl \f a -> Mu (\x -> Either a (f a))
19:03:56 <lambdabot> ((Mu . const) .) . ap Either
19:04:01 <EvilTerran> actually, i guess the answer is "we don't *do* anything - that's the whole point of pure functional programming. we just... *are*"
19:04:15 <vixey> yes!
19:04:25 <ddarius> type FreeMonad = B (B (B Mu K)) (S Either)
19:04:58 <ddarius> Or I guess we can replace Mu with Y.  B(B(B Y K))(S Either)
19:05:01 <monochrom> haha
19:07:13 <ddarius> Oops.
19:07:22 <ddarius> @pl \f a -> Mu (\x -> Either a (f x))
19:07:22 <lambdabot> (Mu .) . flip ((.) . Either)
19:08:29 <ddarius> type FreeMonad = B (B Y) (C (B B Either))
19:11:10 <EvilTerran> <vixey> Mu (Either ()) = N  <- you forget Either () = Maybe
19:12:45 <vixey> Mu, (), Either, (,) is all I need :p
19:21:24 <vixey> I can't figure what to do now :S
19:21:48 <vixey> was expecting to be debugging still ..
19:25:07 <Axman6> vixey: optimise?
19:29:53 <dons> check out the hackage monthly sparkline on http://haskell.org/
19:29:55 <lambdabot> Title: Haskell - HaskellWiki
19:29:59 <dons> shows library updates per day
19:32:38 <byorgey> @let cata phi = phi . fmap (cata phi) . out
19:32:39 <lambdabot> Defined.
19:32:50 <byorgey> @type cata (maybe 0 (1+))
19:32:52 <lambdabot> forall t. (Num t) => Mu Maybe -> t
19:32:58 <byorgey> =D
19:33:13 <vixey> oh wow nice
19:33:17 <vixey> :t phi
19:33:19 <lambdabot> Not in scope: `phi'
19:33:24 <vixey> bah
19:34:24 <vixey> @type cata (either (Right ()) (Left ()))
19:34:25 <lambdabot>     Couldn't match expected type `a -> c'
19:34:25 <lambdabot>            against inferred type `Either a1 ()'
19:34:25 <lambdabot>     In the first argument of `either', namely `(Right ())'
19:34:33 <byorgey> > cata (maybe 0 (1+)) (In (Just (In (Just (In Nothing)))))
19:34:35 <lambdabot>  2
19:35:15 <vixey> @type cata (either (const (Right ())) (const (Left ())))
19:35:17 <lambdabot> forall a. Mu (Either a) -> Either () ()
19:38:42 <byorgey> > cata (maybe 1 (2*)) (In . Just . In . Just . In . Just . In $ Nothing)
19:38:43 <lambdabot>  8
19:39:12 <byorgey> dons: nice
19:40:29 <dons> another example of how haskell these days is just glue for hackage.
19:40:41 <dons> the script is 10 lines that glues hsparklines, tagsoup, parsetime and filepath together
19:41:01 <dons> i should do a series of 'Daily Haskell' posts, with these little 10 line glue programs
19:41:10 <dons> using hackage to get things done.
19:42:04 <dons> wow, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Pugs-6.2.13.2
19:42:07 <lambdabot> http://tinyurl.com/6rptj2
19:42:11 <dons> audreyt++
19:42:30 <dons> i wonder if cabal install Pugs works...
19:42:34 <dons> dcoutts: ^^
19:42:55 <dons> byorgey: there's some news for ya.
19:43:29 <byorgey> yeah, audreyt has been going crazy with the package uploads recently =)
19:43:38 <dons> great to see.
19:43:43 <dons> but pugs on hackage, that's huge.
19:43:58 <byorgey> dons: ok, I'll be sure to put that in!
19:44:19 <byorgey> dons: I think some posts showing ten-line scripts getting things done with tools on hackage is an excellent idea.
19:44:52 <dons> yeah, if i give them a common name, e.g. 'Daily Haskell' , they'd build into a fairly good wander over hackage, i reckonn
19:45:43 <ddarius> byorgey: Good job on that monoid action post.  That's much of the stuff I wanted to write but was too lazy to (and it looks like it worked out for the best anyway)
19:46:18 <byorgey> ddarius: thanks =)
19:46:34 <Botje> h0t (monoid `mappend` monoid) action?
19:46:49 <byorgey> ddarius: yeah, making me work it out for myself was way better than reading something you wrote about it would have been
19:49:22 <byorgey> Botje: hehe =)
19:50:47 <Botje> allright
19:50:48 <Botje> 5am
19:50:51 <Botje> time to go sleep
19:51:42 <byorgey> night Botje
20:00:22 <vixey> how do you get argc and argv?
20:00:28 <ddarius> getArgs
20:00:33 <ddarius> @hoogle getArgs
20:00:34 <lambdabot> System.Environment.getArgs :: IO [String]
20:00:49 <vixey> is it possible to get them as int and char**
20:01:13 <dons> umm...
20:01:23 <dons> :t length `fmap` getArgs
20:01:25 <lambdabot> Not in scope: `getArgs'
20:01:26 <Axman6> char**?
20:01:29 <Axman6> in haskell?
20:01:31 <dons> :t length `fmap` System.Environment.getArgs
20:01:33 <lambdabot> IO Int
20:01:36 <dons> [String] == char**
20:01:42 <dons> argc <- length `fmap` System.Environment.getArgs
20:01:50 <Axman6> i huess
20:01:52 <Axman6> guess even
20:03:46 <Botje> (argc, argv) <- (length &&& id) `liftM` gerArgs
20:03:49 <Botje> (argc, argv) <- (length &&& id) `liftM` getArgs
20:04:02 <Botje> there you go
20:04:35 <dons> :t first length `liftM` System.Environment.getArgs
20:04:37 <lambdabot>     Couldn't match expected type `([a], d)'
20:04:37 <lambdabot>            against inferred type `[String]'
20:04:37 <lambdabot>       Expected type: IO ([a], d)
20:04:44 <dons> bah
20:04:45 <dons> :t first
20:04:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
20:04:53 <dons> oh, not what i thought.
20:04:59 <vixey> thank you everyone :)
20:05:18 <dons> audreyt: cabal2arch-ified pugs! ( on the first attempt)
20:05:31 <eu-prleu-peupe1> hi
20:05:45 <dons> audreyt: freaking awesome.
20:05:47 <Axman6> o/
20:06:03 <dons> http://aur.archlinux.org/packages.php?ID=17958
20:06:04 <lambdabot> Title: AUR (en) - pugs
20:08:44 <mar77a-> http://devs.soldat.pl/wiki/index.php/HRemote
20:08:46 <lambdabot> Title: HRemote - #soldat.devs Wiki
20:08:48 <mar77a-> weee
20:09:07 <byorgey> hi eu-prleu-peupe1
20:09:30 <byorgey> mar77a-: what's that?
20:09:50 <mar77a-> my 2nd port from an application i had in some other language
20:10:49 <mar77a-> i wanted to see what sockets were like in hs
20:11:03 <mar77a-> based the code on that irc bot tutorial which i think dons wrote
20:12:21 <mar77a-> ok i have to study, later
20:14:02 <vixey> so is this good?
20:14:04 <vixey> (it does work)
20:14:05 <vixey> foreign import ccall unsafe "NSApplicationMain" nsApplicationMain :: CInt -> Ptr CString -> IO CInt
20:14:05 <vixey> main = do (argc, argv) <- (length &&& id) `liftM` getArgs
20:14:05 <vixey>           argv' <- mapM newCString argv
20:14:05 <vixey>           argv'' <- newArray argv'
20:14:05 <vixey>           nsApplicationMain argc argv''
20:14:17 <vixey> but just wondering if that's definitely the right way
20:14:59 <vixey> (to get CInt and Ptr CString from the env)
20:27:24 <newsham> (length &&& id) <$> getArgs
20:27:47 <Axman6> > (length &&& id) <$> getArgs
20:27:48 <lambdabot>   Not in scope: `getArgs'
20:27:52 <Axman6> lame
20:28:12 <Axman6> > (length &&& id) <$> System.Environment.getArgs
20:28:13 <lambdabot>   Not in scope: `System.Environment.getArgs'
20:28:24 <vixey> do I really have to define myself,
20:28:33 <byorgey> @type (length &&& id) <$> System.Environment.getArgs
20:28:34 <lambdabot> IO (Int, [String])
20:28:44 <vixey> isNullPtr p = minupsPtr p nullPtr == 0
20:28:47 <vixey> ?
20:28:50 <Axman6> :t <$>
20:28:52 <lambdabot> parse error on input `<$>'
20:28:58 <Axman6>  <$>
20:29:02 <byorgey> Axman6: put it in parentheses
20:29:08 <Axman6> @src (<$>)
20:29:08 <lambdabot> f <$> a = fmap f a
20:29:21 <Axman6> @src fmap
20:29:22 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:29:31 <byorgey> fmap is a method of the Functor class
20:29:38 <dibblego> method?
20:29:39 <byorgey> it's different for every Functor
20:29:52 <byorgey> dibblego: er, you know what I mean =)
20:30:02 <byorgey> what are the thingys in type classes called?
20:30:07 <dibblego> functions
20:30:16 <dibblego> fmap also has two laws; identity and composition
20:30:16 <Axman6> haskell is a puerly methodical language no?
20:30:18 <Axman6> :P
20:30:33 <dolio> They're also called methods.
20:30:35 <byorgey> there's got to be another name for functions which happen to be members of a type class
20:30:40 <dolio> Which probably confuses the issue with OOP even more.
20:31:11 <Axman6> is there such thing as a functional OO language?
20:31:17 <Axman6> i guess ruby could be called that
20:31:23 <dolio> OCaml?
20:31:25 <dibblego> Scala
20:31:30 <dolio> There are plenty.
20:31:39 <Axman6> OCaml seems to have very ugly syntax
20:31:47 <dibblego> it really depends on what you mean by 'OO'
20:31:57 <dibblego> as Oleg (I think?) has shown, Haskell can be OO too
20:31:57 <Axman6> like, @ to concatenate lists :s
20:32:16 <vixey> Axman6: It's not the most important thing about a programming language
20:32:22 <vixey> by a long way :p
20:32:32 <Axman6> what isn't?
20:32:47 <ddarius> byorgey: They are called methods.
20:32:49 <Axman6> its syntax?
20:32:58 <byorgey> see, I knew they were called methods!
20:33:02 <ddarius> (that is the term used in the Haskell 98 Report)
20:33:08 <byorgey> dibblego was trying to confuse me =P
20:33:09 <dibblego> byorgey, tricked ya! (didn't know that)
20:33:45 <ddarius> vixey: I don't use the ML family languages primarily due to syntax.
20:33:54 <byorgey> I must admit to feeling slightly icky every time I use the word 'method' to describe something like fmap
20:34:33 <ddarius> Axman6: Needle was a very pretty one that unfortunately was abandoned early in its life.
20:34:42 <atp> i think a lot of the terms that haskell reuses that mean something relatively different in other contexts (class, method, return) are sort of annoying
20:35:09 <vixey> atp, this is common in programming, names don't have much meaning yet since we're so early into it
20:35:32 <ddarius> atp: We should get rid of those other contexts.
20:35:52 <Axman6> while i remember, i was reading that there's only one possible function which can have the type f :: a -> a
20:36:02 <Axman6> has that been proved?
20:36:03 <mmorrow> "<dons> check out the hackage monthly sparkline on http://haskell.org/"
20:36:03 <lambdabot> Title: Haskell - HaskellWiki
20:36:05 <vixey> :t undefined :: a -> a
20:36:06 <mmorrow> looks good
20:36:07 <lambdabot> forall a. a -> a
20:36:11 <vixey> :t (\x -> x) :: a -> a
20:36:13 <lambdabot> forall a. a -> a
20:36:14 <ddarius> Axman6: That's not true in Haskell.
20:36:16 <vixey> :t (\x -> undefined) :: a -> a
20:36:17 <lambdabot> forall a. a -> a
20:36:19 <vixey> :t (\x -> undefined $ x) :: a -> a
20:36:20 <lambdabot> forall a. a -> a
20:36:24 <vixey> etc etc..
20:36:27 <atp> ddarius: i concur :)
20:36:33 <Axman6> heh, ok
20:36:36 <atp> ddarius: although i have to say, i think unit would have been better than return
20:36:50 <atp> but i don' t lose sleep over it
20:36:56 <ddarius> atp: I like return and I'm pretty sure it was an intentional decision.
20:37:00 <dolio> Class in Haskell seems closer to the definition you might find in a dictionary to me than the way it's used in many OOP languages.
20:37:50 <newsham> OO I did it again.
20:37:55 <ddarius> vixey, Axman6: There are only three distinct values of type a -> a in Haskell.  vixey listed four, but the last one is the same as the one before it.
20:37:57 <atp> ddarius: i'm sure it was intentional
20:38:35 <ddarius> dolio: "class" in Haskell is much closer to the use of "class" in set theory/logic.
20:38:43 <Axman6> there's also f a = a, or does that count as  \x -> x?
20:39:03 <dolio> ddarius: Agreed.
20:39:14 <SamB> atp: the use of method is a pun
20:39:14 <dibblego> Axman6, there is only value in a terminating subset of Haskell
20:39:25 <mmorrow> that hsparklines package on hackage is pretty cool.
20:39:26 <ddarius> Axman6: That's the same as \x -> x, yes.
20:39:27 <Axman6> and now you've lost me
20:39:32 <newsham> ?djinn a -> a
20:39:32 <Axman6> ok
20:39:34 <lambdabot> f a = a
20:39:41 <vixey> with the haskell FFI, can I define and use structs (I don't need to pass them around as values just put things in and take things out of them)
20:39:43 <dibblego> Axman6, consider that the other two definitions use 'undefined'
20:39:54 <vixey> or.. do I have to implement this myself in terms of peek/poke
20:40:01 <ddarius> Axman6: There are infinitely many expressions for any function.
20:40:11 <SamB> we figure since the operations an OO class has are called methods, we might as well call the things our classes have the same thing
20:40:21 <vixey> and .. calculate the fields layouts of structs myself
20:40:26 <Axman6> ok, guess the guy was full of crap
20:40:28 <dibblego> Axman6, consider another example, forall a. forall b. a -> b
20:40:51 <SamB> atp: make sense?
20:40:57 <newsham> vixey: I think if you're passing them to native code and inserting and extracting fields, you want to make it Storable (peek/poke)
20:40:58 <dibblego> Axman6, the guy was probably not referring to Haskell
20:41:07 <ddarius> vixey: No, the FFI doesn't do structs.  You can use peek/poke (or preferably a Storable instance over it), or you can pass pointers and have the C side deal with doing it.
20:41:12 <newsham> which I think you normally do manually (some preprocessors do this for you?)
20:41:14 <atp> Axman6: the issue is this: every single type in haskell includes a special value called bottom, which represents non-termination
20:41:16 <Axman6> i'm pretty sure he was
20:41:16 <ddarius> vixey: There are also tools that will do this.
20:41:22 <ddarius> @where c2hs
20:41:22 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
20:41:25 <dibblego> Axman6, where did you read it?
20:41:32 <Axman6> something on reddit
20:41:41 <Axman6> not a site i often browse
20:41:48 <vixey> ok great, thank you
20:42:26 <atp> Axman6: the reason thinking about bottom is important is because no matter what the return type of a function is, it can always return bottom
20:42:42 <Axman6> http://www.reddit.com/r/programming/info/6o4yi/comments/
20:42:44 <lambdabot> Title: programming: "GHC doesn't even break a sweat with a million threads"
20:42:44 <atp> Axman6: therefore, it is always possible for a function of type a -> a to return bottom (ie, never return)
20:43:05 * Axman6 must find out what bottum is
20:43:07 <atp> Axman6: if however you require that the function returns, there is only one function with type a -> a : id
20:43:17 <dibblego> Axman6, I see no such comment
20:43:26 <atp> Axman6: bottom is just a way of thinking about the return value of a function that never actually returns
20:43:28 <paczesiowa> if I use almost all "ugly" ghc switches and type checker goes into infinite loop, does it continue to eat more and more of ram (and crash eventually) or can it go forever with cosntant memory?
20:43:42 <Axman6> maybe it wasn't that thread
20:43:45 <atp> ddarius: please correct me if i'm wrong here
20:44:06 <dibblego> 'bottom' represents 'the absurd' or that which does not terminate, but without it (in a terminating subset), forall a. a -> a is inhabited once
20:44:17 <atp> Axman6: do you understand what i mean?
20:44:19 <dibblego> (by the way, forall a. forall b. a -> b is uninhabited)
20:44:36 <Axman6> atp: not with the amount of sleep i've had, no :)
20:45:20 <atp> Axman6: ok, think about it this way.  What supposing that x is an integer, what is the type signature of f x = 1 + f x ?
20:45:28 <vixey> dibblego: what do you mean uninhabited?
20:45:32 <atp> Axman6: Integer -> ?
20:45:35 <vixey> oh
20:45:44 <vixey> in a total subset
20:45:47 <Axman6> ouch, yes, ok
20:45:51 <dibblego> vixey, there is no implementation (terminating) that satisfies it
20:46:08 <Axman6> >f x = 1 + f x in f 1
20:46:13 <atp> Axman6: if you think about it, the type must be Integer
20:46:18 <Axman6> yeah
20:46:21 <atp> Axman6: but clearly, that function never terminates
20:46:28 <atp> Axman6: it'll just loop forever
20:46:37 <Axman6> yep
20:46:53 <atp> Axman6: so in order to account for this, each Haskell type contains a special value we call bottom
20:47:05 <atp> Axman6: so Integer for example contains all the integers, plus one extra value, called bottom
20:47:22 <Axman6> ah ha
20:47:34 <atp> Axman6: you never actually see this value
20:47:41 <atp> Axman6: but it's useful from a theoretic perspective
20:47:46 <Axman6> http://www.reddit.com/info/6lx36/comments/c048oh1 was the link btw
20:47:46 <lambdabot> Title: reddit.com: Haskell as fast as C: working at a high altitude for low level perfo ...
20:47:48 <atp> Axman6: bottom just means "never returns"
20:47:59 <SamB> > error "never see me, you say?"
20:48:01 <lambdabot>  Exception: never see me, you say?
20:48:12 <Axman6> > f x = 1 + f x in f 1
20:48:13 <lambdabot>  Parse error at "=" (column 5)
20:48:13 <atp> Axman6: right, ok, i lied a bit as SamB is noticing
20:48:21 <vixey> 325
20:48:29 <Axman6> hmm?
20:48:38 <Axman6> > let f x = 1 + f x in f 1
20:48:42 <vixey> stop thinking about bottoms when programming!
20:48:45 <atp> Axman6: bottom is not just for non-termination, but also for exceptions and such... but in a way i was telling the truth, because when a function throws an exception, it isn't really ever returning either
20:48:48 <vixey> http://www.cs.nott.ac.uk/~txa/talks/bctcs06.pdf
20:48:49 <dibblego> Axman6, he is right; he is not referring to Haskell, but 'that which exists in this universe' and bottom represents something outside of it 'the absurd'
20:48:53 <lambdabot>  thread killed
20:49:16 <SamB> @google a semantics for imprecise exceptions
20:49:18 <Axman6> ha ha, i see
20:49:19 <lambdabot> http://citeseer.ist.psu.edu/peytonjones99semantics.html
20:49:23 <atp> Axman6: so for example, undefined is a haskell function that always returns bottom in the sense that it never actually returns
20:49:26 <atp> > undefined
20:49:27 <lambdabot>  Exception: Prelude.undefined
20:49:27 <SamB> atp: oh, sure, a pure function never sees it
20:49:35 <Axman6> see, this is why Haskell is awesome, it's like phylosophy in programming
20:50:04 <SamB> Axman6: you should try Coq sometime
20:50:14 <SamB> they have fun stuff like Universe Inconsistancies
20:50:20 <atp> it's actually quite important conceptually though.  in an eagerly evaluating language like Scheme, Java, or C, for all functions f, f of bottom is bottom
20:50:21 <SamB> (oh no! you'll kill us all!)
20:50:22 <dons> Axman6: you certainly can see the foundations of our discipline a little clearer
20:50:31 <atp> but in Haskell it can quite often be the case that f of bottom is not bottom
20:50:43 <atp> for example, let f x = 5.  then f undefined will still evaluate to 5
20:50:43 <dons> many concepts that are confused in other languages become quite clear and precise in haskell, for some reason.
20:50:47 <atp> > let f x = 5 in f undefined
20:50:49 <lambdabot>  5
20:51:10 <SamB> dons: because we have no other choice?
20:51:30 <atp> haskell is great.  you'll love how safe it is. :)
20:52:10 <SamB> dons: there is a large class of compromises we can't afford to make
20:52:18 <Axman6> i have been using it for the last 6 months
20:52:23 <newsham> atp: http://codepad.org/Q8cgS6x8
20:52:39 <SamB> with "let's just use impure functions for IO" right at the top of the pile
20:53:10 <vixey> Applying patch 107 of 325... Unapplicable patch:
20:53:10 <vixey> Wed May 18 08:42:11 BST 2005  chak@cse.unsw.edu.au
20:53:10 <vixey>   * rearranging darcs repo
20:53:10 <vixey> darcs failed:  Error applying hunk to file ./base/todo
20:53:13 <vixey> c2hs ...
20:53:14 <atp> Axman6: actually it was a reference to that lisperati comic :p
20:53:39 <Axman6> hmm?
20:54:41 <atp> landoflisp i think it was called
20:54:54 <atp> http://lisperati.com/landoflisp/
20:54:58 <atp> it's silly :p
20:55:04 <atp> it's especially amusing if you code both haskell & lisp
20:58:18 <vixey> :?
20:58:27 <vixey> c2hs doesn't document the chs file format
20:59:00 <newsham> gtk2hs src has lots of chs files
20:59:23 <vixey> I'm supposed to use computer software by guessing how it works based on tests :S
21:00:37 <newsham> works for nasa?
21:02:02 <ddarius> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/
21:02:04 <lambdabot> Title: The Binding Generator C➔Haskell
21:04:24 <newsham> what happened to fluffles?
21:04:59 <dancor> haskell.org is still dead
21:06:05 <ddarius> dancor: Works for me.
21:06:42 <dancor> ddarius: does 'cabal update' work for you?
21:08:12 <ddarius> It does seem to be taking a while, but hackage.haskell.org works in a browser.
21:08:28 <ddarius> Looks like it worked.
21:08:49 * ddarius should cabal install cabal-install.
21:09:04 <vixey> hm /usr/include/objc/objc-api.h:23: (column 0) [FATAL]  >>> Syntax error! The symbol `/' does not fit here.
21:09:39 <Axman6> you on a mac?
21:09:59 <dons> dancor: it is fine.
21:10:12 <vixey> that line is // Copyright 1988-1996 NeXT Software, Inc.
21:10:57 <Axman6> how odd
21:11:12 <vixey> do I have to sed out single line comments to use c2hs?
21:11:28 <mmorrow> lol
21:11:29 <mmorrow> http://lisperati.com/landoflisp/panel60.html
21:11:51 <ddarius> vixey: Possibly.  They weren't added until C99.
21:12:47 <ddarius> vixey: You could probably patch c2hs to handle them easily enough, if it doesn't.
21:13:07 <vixey> yeah, that's what I'm trying to do
21:15:43 <solrize_> wheee
21:16:44 <Nafai> What's the best way to access sqlite from Haskell?
21:17:04 <Nafai> I see many options on Hackage
21:17:31 <dons> Nafai: depends on whether you want high or low level access
21:17:43 <dons> sqlite , if you're comfortable with the C api, takusen or hdbc-sqlite3 for higher level stuff
21:18:05 <Nafai> Probably would prefer something higher level
21:18:43 <dons> hdbc or takusen then, depending on your comfort level
21:18:45 <dons> i'd say hdbc
21:20:20 <vixey> if only cpp removed comments :/
21:20:48 * Nafai looks
21:21:28 * Nafai reads the chapter in RWH
21:27:20 <vixey> did anyone use c2hs other than the authors?
21:27:48 <vixey> I just added \/\/$anyButNL*$eol		        ; to the lexer
21:28:07 <vixey> so it can skip // comments, now it's not able to handle indented ifdefs
21:28:38 <vixey> maybe you are meant to extract fragments of the C headers and give only that to c2hs..?
21:28:58 <dons> vixey: yeah, it is fairly widely used.
21:29:04 <dons> in some key systems, like c2hs
21:29:07 <dons> sorry, gtk2hs
21:29:24 <vixey> I see
21:36:09 <bos> oh yeah, baby - it's saturday night, and you know you want to vote for http://www.reddit.com/info/6of7m/comments/
21:36:10 <lambdabot> Title: reddit.com: Real World Haskell: ten new draft chapters - GUIs, concurrency, web  ...
21:39:10 <solrize_> yayyyy
21:39:48 <vixey> I can't use c2hs
21:40:08 <vixey> it just syntax errors all the time
21:40:33 <bos> we've nearly got this big albatross hefted from around our necks :-)
21:44:48 <Nafai> bos: I hope to have it under my Christmas Tree :)
21:45:22 <bos> boy, youtube is just awash in spore penis creatures and porn.
21:45:56 <solrize_> i can't wait for albatross volume ii ;)
21:48:12 <solrize_> bos it looks like the new json chapter duplicates a lot of stuff about newtype vs data from an earlier chapter
21:48:52 <bos> solrize_: please mention that in the comments, and we'll fix it up.
21:49:02 <solrize_> no wait, this IS the chapter i read earlier, it must not be one of the new ones.  no wonder it seemed familiar
21:49:31 <solrize_> is chapter 8 new?  typeclasses at work, making json easier to use
21:49:43 <mar77a> myReverse :: [a] -> [a]
21:49:47 <mar77a> why does that give me an error
21:49:51 <mar77a> :t reverse
21:49:54 <lambdabot> forall a. [a] -> [a]
21:50:12 <mar77a> "cannot construct the infinite type blah blah"
21:51:02 <dons> solrize_: an earlier chapter was split in two
21:51:15 <solrize_> oh
21:51:19 <solrize_> ok
21:51:31 <solrize_> that explains
21:51:33 <ddarius> mar77a: Your code is wrong.
21:51:36 <mar77a> ouch
21:52:13 <mar77a> myReverse :: [a] -> [a]
21:52:13 <mar77a> myReverse [] = []
21:52:13 <mar77a> myReverse [x] = [x]
21:52:13 <mar77a> myReverse (x:xs) = myReverse xs : x
21:52:30 <mar77a> what am i doing wrong?
21:52:31 <TSC> You can't add an element to the end of the list with (:) like that
21:52:37 <vixey> mar77a: Do you know what (:) can't tell which way around it is
21:52:53 <solrize_> myreverse (x:xs) = myreverse xs : [x]
21:52:58 <vixey> no
21:53:02 <vixey> ++ [x]
21:53:09 <solrize_> right
21:53:11 <mar77a> mm
21:53:28 <mar77a> ya that makes sense, ty
21:53:49 <solrize_> you don't need the myreverse [x] case
21:53:59 <dons> bos, nice work on that announce.
21:54:48 <bos> thanks :-)
21:55:16 <dons> when do you fly out? tuesday evening or so?
21:58:18 <mar77a> how can i insert nothing in a list?
21:58:26 <mar77a> > ():[]
21:58:27 <lambdabot>  [()]
21:58:33 <mar77a> eh
21:58:36 <vixey> you cannot
21:58:41 <mar77a> poo
21:58:41 <vixey> > id []
21:58:44 <lambdabot>  []
21:58:44 <bd_> > [Nothing]
21:58:49 <lambdabot>  [Nothing]
21:58:53 <bd_> :D
21:59:01 * vixey gives up on ffi.. maybe adu will have more luck
21:59:02 <bd_> > [Just Nothing]
21:59:04 <lambdabot>  [Just Nothing]
21:59:19 <mar77a> group [] = []
21:59:19 <mar77a> group (x:xs) = x : (if x == xs then -nothing- else xs) : group xs
21:59:26 <mar77a> trying to write ...compress i think it's called?
21:59:51 <atp> how can x == xs?
21:59:54 <bd_> mar77a: group (x:xs) = x : (if x == xs then group xs else xs:group xs) ?
21:59:56 <bd_> or
22:00:01 <Axman6> if x == []
22:00:04 <mar77a> eh
22:00:09 <bd_> mar77a: group (x:xs) = x : ((if x == xs then id else (xs:)) group xs)
22:00:23 <atp> x == xs?  type error
22:00:24 <bd_> let group (x:xs) = x : ((if x == xs then id else (xs:)) group xs) in group [1,1,2,3]
22:00:27 <bd_> > let group (x:xs) = x : ((if x == xs then id else (xs:)) group xs) in group [1,1,2,3]
22:00:28 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
22:00:28 <lambdabot>       Expected...
22:00:30 <bd_> hmmmm
22:00:34 <mar77a> x == head xs
22:00:34 <ddarius> > let f (x:xs) = x == xs in f
22:00:35 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
22:00:35 <lambdabot>       Expected...
22:00:43 <bd_> > let group [] = []; group (x:xs) = x : ((if x == head xs then id else (xs:)) group xs) in group [1,1,2,3]
22:00:44 <lambdabot>  Couldn't match expected type `t1 -> [t]'
22:00:50 <Axman6> atp: could work, if like i said, x == [], and you're at the end of the list
22:00:54 <bd_> > let group [] = []; group (x:xs) = x : ((if x == head xs then id else (xs:)) (group xs)) in group [1,1,2,3]
22:00:55 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
22:00:55 <lambdabot>       Expected...
22:00:58 <bd_> :|
22:01:03 <ddarius> Axman6: Things with different types are never equal.
22:01:15 <Axman6> ok, well then i guess not
22:01:21 <bd_> > let group [] = []; group (x:xs) = x : ((if x == head xs then id else (x:)) (group xs)) in group [1,1,2,3]
22:01:23 <lambdabot>  [1,1,1,2,2,3Exception: Prelude.head: empty list
22:01:26 <bd_> x not xs :|
22:01:42 <hpaste>   cjs pasted "listen error" at http://hpaste.org/8462
22:01:44 <ddarius> :t \(x:xs) -> (x,xs)
22:01:45 <bd_> hmm
22:01:46 <lambdabot> forall t. [t] -> (t, [t])
22:01:56 <cjs_> Can anybody tell me what I'm doing wrong in http://hpaste.org/8462 ?
22:02:02 <bd_> actually
22:02:32 <atp> Axman6: the thing to realize is that the head of a list and its tail are never the same type, unless you have an infinite type (which haskell's type system does not allow)
22:02:40 <cjs_> It's the listen, BTW, not the accept, that's the issue here.
22:03:05 <atp> Axman6: if xs :: [a], then head xs :: a, but tail xs :: [a], and a and [a] are not the same unless a == [a], which would be an infinite recurrence
22:03:12 <bd_> > let group [] = []; group (x:xs) = let (m, n) = partition (== x) xs in (x:m):(group n) in group [1,1,2,1,3,3]
22:03:13 <lambdabot>  [[1,1,1],[2],[3,3]]
22:03:19 <bd_> mar77a: ^^^
22:03:30 <mar77a> eee
22:03:31 <Axman6> ok
22:04:10 <bd_> oh, that might not be exactly what you want, though
22:04:18 <bd_> @hoogle (a -> Bool) -> [a] -> ([a],[a])
22:04:19 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
22:04:19 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
22:04:19 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
22:04:20 <atp> Axman6: it's important to remember that a list in haskell isn't like an array in other languages, and that [] is not haskell's equivalent of the null terminator or whatever
22:04:28 <atp> Axman6: a list in haskell is actually a linked list
22:04:38 <Axman6> righto
22:04:43 <atp> ok, just making sure :)
22:04:45 <vixey> [] is exactly the null terminator
22:04:46 <bd_> > let group [] = []; group (x:xs) = let (m, n) = break (/= x) xs in (x:m):(group n) in group [1,1,2,1,3,3]
22:04:47 <lambdabot>  [[1,1],[2],[1],[3,3]]
22:04:52 <bd_> mar77a: ^^ :)
22:05:09 <atp> vixey: of a linked list, sure, but not of an array, which is how Axman6 seemed to be interpreting it in his code
22:05:47 <ddarius> Arrays don't have "null terminators"
22:06:02 <Axman6> shit, just realised GHC is _still_ compiling
22:06:05 <atp> ddarius: not intrinsically no, but in many programming languages they are implemented that way.
22:08:19 <mar77a> stack overflow on compile
22:08:43 <cjs_> Gah, it's a bug in GHC 6.8.2 on NetBSD. And 6.8.3 just came out without the fix....
22:08:45 <hpaste>  mar77a pasted "whaaaaaaaa" at http://hpaste.org/8463
22:09:55 <bd_> mar77a: combinators are your friend - take a look at takeWhile and dropUntil (break combines both)
22:10:08 <mar77a> o_O
22:10:10 <hackage> New package: rss2irc 0.1
22:10:10 <hackage> New package: hackage-sparks 0.1
22:10:10 <hackage> New package: Pugs 6.2.13.2
22:10:11 <hackage> New package: pugs-compat 0.0.3
22:10:11 <dons> quickie hackage bot:
22:10:13 <hackage> New package: MetaObject 0.0.4
22:10:25 <dons> announces new hackage packages once an hour.
22:10:40 <mar77a> found the problem
22:10:47 <mar77a> nvm, not
22:10:52 <TomMD> ?BOT
22:10:53 <lambdabot> Unknown command, try @list
22:10:55 <bd_> mar77a: so, what is it intended to do? :)
22:10:56 <TomMD> ?bot
22:10:56 <lambdabot> :)
22:11:04 <TomMD> hackage bot isn't honest.
22:11:08 <dons> TomMD: it doesn't understand any commands.
22:11:11 <TomMD> ok
22:11:14 <mar77a> compress a list... [1,1,2,2,3] ~> [1,2,3]
22:11:23 <dons> it's really just an rss -> irc gateway
22:11:27 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rss2irc-0.1
22:11:27 <hpaste>  (anonymous) annotated "whaaaaaaaa" with "(no title)" at http://hpaste.org/8463#a1
22:11:29 <lambdabot> http://tinyurl.com/6kax8x
22:11:31 <vixey> map head . group
22:11:38 <mar77a> no fun if i use group
22:11:42 <vixey> nub
22:11:48 <TomMD> So I could upload a "Hello #haskell" package, hummm...
22:11:58 <dons> TomMD: heh
22:12:06 <bd_> mar77a: what about [1,1,2,1] ?
22:12:09 <vixey> mar77a: where's this from?
22:12:13 <mar77a> [1,2,1]
22:12:15 <bd_> hmmm
22:12:18 <mar77a> where's what from vixey?
22:12:19 <dons> i could imagine subscribing the channel to planet haskell too
22:12:27 <vixey> mar77a: the programs you are writing
22:12:33 <mar77a> http://www.haskell.org/haskellwiki/99_questions/1_to_10
22:12:34 <lambdabot> Title: 99 questions/1 to 10 - HaskellWiki
22:12:45 <hpaste>  morrow pasted "trees" at http://hpaste.org/8464
22:12:53 <Axman6> f (x:x2:xs) | x == x2 = f (x2:xs) | otherwise = x : f(x2:xs)
22:12:56 <Axman6> yes?
22:13:12 <Axman6> > let f (x:x2:xs) | x == x2 = f (x2:xs) | otherwise = x : f(x2:xs) in [1,2,3,3,4,5]
22:13:13 <lambdabot>  [1,2,3,3,4,5]
22:13:18 <Axman6> or not
22:13:31 <dons> anyone else tried:  cabal install pugs ?
22:13:55 <Axman6> what's pugs do?
22:14:07 <vixey> mar77a: try this one:  data Expr = Num Integer | Add Expr Expr | Mul Expr Expr | Div Expr Expr | Sub Expr Expr
22:14:21 <mar77a> what's a
22:14:22 <mar77a> whaaat
22:14:31 <dons> Axman6: it is a perl compiler
22:14:32 <cjb> bos, dons: http://book.realworldhaskell.org/beta/hs.web.comment.html#hs.web.comment.name has been 404 for a long time :)
22:14:36 <lambdabot> http://tinyurl.com/6lpbxd
22:14:41 <Axman6> ah, ok
22:14:41 <rwbarton> Axman6: You left out f on the right
22:14:46 <vixey> mar77a: write a function eval :: Expr -> Integer which evaluates an expression, like eval (Add (Num 7) (Mul (Num 2) (Num 3))) ~> 13
22:14:55 <mar77a> oh please
22:14:59 <Axman6> > let f (x:x2:xs) | x == x2 = f (x2:xs) | otherwise = x : f (x2:xs) in [1,2,3,3,4,5]
22:15:00 <lambdabot>  [1,2,3,3,4,5]
22:15:01 <mar77a> let me write the prelude first
22:15:02 <bd_> > (foldr1 (\(a:_) l2@(b:_) -> if (a == b) then l2 else a:l2) . map (:[])) [1,1,2,3,3,4,1,2,2,5]
22:15:03 <lambdabot>  [1,2,3,4,1,2,5]
22:15:13 <vixey> mar77a: no, try this, it's more interesting, and it's easy anyway
22:15:21 <mar77a> rrrr
22:15:32 <vixey> mar77a: Just do exactly what we did with the chomp and split thing, except with this data instead
22:15:45 <rwbarton> > let f (x:x2:xs) | x == x2 = f (x2:xs) | otherwise = x : f (x2:xs) in f [1,2,3,3,4,5]
22:15:46 <vixey> (actually it's a lot simpler than chomp/split)
22:15:47 <lambdabot>   Non-exhaustive patterns in function f
22:16:11 <bos> cjb: where's that link come from?
22:16:13 <ddarius> :t local
22:16:18 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:16:29 <Axman6> oh, heh, thanks rwbarton
22:16:37 <Axman6> and the base case of course
22:16:49 <cjb> bos: the "help" and "required so we can give you credit" links on the comment form
22:18:38 <mar77a> i'm still afraid of 'data'
22:19:05 <vixey> @src []
22:19:05 <lambdabot> data [] a = [] | a : [a]
22:19:08 <vixey> take that :P
22:19:22 <dons> mar77a: think of it as 'struct' , but with a lot more fun added.
22:19:29 <mar77a> yeah i know the theory
22:19:39 <mar77a> i'll get to it eventually
22:19:46 <ddarius> Then why would you be afraid of it?
22:19:47 <bos> cjb: fixed, thanks. might take a few minutes before it "takes".
22:19:48 <mar77a> right now i'm amazing myself with these problems (the solutions rather)
22:20:02 <vixey> mar77a: You should my problem though ..
22:20:10 <vixey> mar77a: It should help (that was the idea)
22:20:38 <mar77a> i'll take it into account, thanks
22:25:02 <mmorrow> let data Z = Z Integer | F (Z -> Z); eval _ (Z n) = n ; eval n (F f) = f n in iterate (flip eval (F (*2))) 1
22:25:17 <mmorrow> mar77a: data just lets you wrap stuff in a nice little package
22:25:28 <mmorrow> mar77a: so you can focus
22:25:51 <mmorrow> [1,2,4,8,16,32...
22:26:12 <mmorrow> oops
22:26:42 <mar77a> case x of is somewhat like switch statements in C, right?
22:26:47 <mmorrow> eval _ (Z n) = n ; eval n (F f) = eval <soimethigns> f (Z n)
22:27:23 <mmorrow> mar77a: exactly, except in case stmts you get to pattern match arbitrarily complex patterns
22:27:43 <mmorrow> (or trivially simple ones)
22:27:59 <TomMD> dons: Didn't know pugs was on hackage. It installed fine for me if that is why you were asking.
22:28:13 <dons> TomMD: sweet. yeah, audreyt uploaded it today.
22:28:26 <TomMD> Is there a cabal install flag to use N processors?
22:35:09 <dons> TomMD: to have cabal-install use N processors?
22:35:30 <vixey> :(
22:35:31 <vixey> cabal: At least the following dependencies are missing:
22:35:31 <vixey>     MetaObject >=0.0.4, pugs-compat >=0.0.3, stringtable-atom >=0.0.4
22:35:31 <vixey> cabal: Error: some packages failed to install:
22:35:31 <vixey>   Pugs-6.2.13.2
22:35:31 <vixey>   pugs-compat-0.0.3
22:35:33 <vixey>   MetaObject-0.0.4
22:35:35 <vixey>   stringtable-atom-0.0.4
22:35:42 <vixey> what does this mean
22:35:44 <dons> vixey: cabal update
22:35:45 <TomMD> Yes, that is what I mean.  I'm guessing no
22:35:51 <vixey> ok
22:35:58 <dons> TomMD: well, it is single threaded, afaik.
22:36:00 <vixey> I did do that just before installing but I'll try again
22:36:04 <dons> but dcoutts is interested in that.
22:36:11 <dons> vixey: you're using: cabal install pugs
22:36:11 <dons> ?
22:36:17 <vixey> yes
22:36:25 <dons> with a modern cabal-install?
22:36:34 <TomMD> cabal install cabal?
22:36:39 <TomMD> ;-)
22:36:46 <vixey> is this modern? cabal-install version 0.4.3
22:36:46 <vixey> using version 1.3.5 of the Cabal library
22:36:47 <ddarius> cabal install cabal-install
22:36:56 <dons> vixey: ah no.
22:37:01 <dons> you want cabal 1.4 and cabal-install 0.5
22:37:08 <dons> cabal install Cabal
22:37:11 <dons> cabal install cabal-install
22:37:36 <dons> > cycle "cabal install "
22:37:37 <lambdabot>  "cabal install cabal install cabal install cabal install cabal install cabal...
22:37:43 <vixey> lol
22:40:51 <roconnor> > fix (++"install cabal")
22:41:02 <vixey> should this matter?
22:41:03 <vixey> src/Pugs/Parser/Types.hs:230:12:
22:41:03 <vixey>     Overlapping instances for MonadState
22:41:03 <vixey>                                 RuleState (Text.Parsec.Prim.ParsecT [Char] RuleState Identity)
22:41:06 <lambdabot>  thread killed
22:41:11 <vixey> it just went, cabal: Error: some packages failed to install:
22:41:12 <vixey> Pugs-6.2.13.2 failed during the building phase. The exception was:
22:41:12 <vixey> exit: ExitFailure 1
22:41:15 <vixey> right after that error
22:41:36 <Axman6> [a..]
22:41:40 <Axman6> > [a..]
22:41:41 <lambdabot>  [Exception: not a number
22:41:46 <Axman6> hmm
22:41:48 <dons> vixey: so you updated to the latest cabal and cabal-install?
22:41:51 <vixey> yes
22:41:51 <Axman6> > [0.1..]
22:41:53 <lambdabot>  [0.1,1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1,...
22:42:03 <vixey> dons I'm having really bad luck today :S
22:42:04 <Axman6> > [0.1, 0.2..]
22:42:06 <lambdabot>  [0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.8999999999...
22:42:12 <Axman6> how fun
22:42:28 <Axman6> > [0.1, 0.2, 0.3..]
22:42:28 <lambdabot>  Parse error at "..]" (column 15)
22:42:43 <vixey> oh it looks like I have to update cabal install then cabal
22:42:48 <vixey> (I did the other order)
22:43:14 <vixey> > [0.1, 0.2..]::CReal
22:43:15 <lambdabot>  Couldn't match expected type `CReal' against inferred type `[a]'
22:43:19 <vixey> > [0.1, 0.2..]::[CReal]
22:43:27 <lambdabot>  [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9...
22:48:14 <Axman6> does compiling with profiling support have any performance impact when running without profiling?
22:48:48 <paczesiowa> @src <$>
22:48:48 <lambdabot> f <$> a = fmap f a
22:49:27 <scodil> Axman6: in my experience yes. Fewer things are inlined. At least if you use -auto-all
22:49:56 <Axman6> ok, thanks
22:50:24 <scodil> but i don't really know the interaction
22:50:42 <scodil> between optimization and profiling
22:52:23 <vixey> Now I've got
22:52:23 <vixey> cabal-install version 0.5.1
22:52:24 <vixey> using version 1.4.0.1 of the Cabal library
22:52:45 <vixey> but I still have this src/Pugs/Parser/Types.hs:230:12: Overlapping instances for MonadState which causes the package to fail
22:53:09 <vixey> maybe ghc-6.8.2 is too old?
22:54:13 <vixey> I'll just get 6.8.3 and see what happens
22:54:18 <scodil> is there anyway to get ghc to tell you when its deciding to inline or not based on function size?
22:58:48 <mmorrow> vixey: you should get head from darcs and build that (make -j10 makes the dagger just a bid needle:))
22:59:20 <mmorrow> darcs get --partial http://darcs.haskell.org/ghc
22:59:22 <lambdabot> Title: Index of /ghc
22:59:40 <vixey> cool ok I will
22:59:56 <mmorrow> yay
23:02:02 <gwern> @seen byorgey
23:02:02 <lambdabot> byorgey is in #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 2h 28m 8s ago.
23:02:35 <mmorrow> chmod 700 darcs-all && ./darcs-all get && sh boot && DIR=/usr/local/ghc-`date +%y%m%d` && sudo mkdir $DIR && ./configure --prefix=$DIR && make -j10 && echo 'sudo make install!!'
23:03:35 <gwern> @ask byorgey is there any particular reason you seem to have a fork of http://www.cse.unsw.edu.au/~dons/code/hwn ? is the http://code.haskell.org/~byorgey/code/hwn the new canonical location?
23:03:35 <lambdabot> Consider it noted.
23:04:36 <dons> gwern: correct. i will redirect http://www.cse.unsw.edu.au/~dons/code/hwn
23:04:38 <lambdabot> Title: Index of /~dons/code/hwn
23:04:49 <dons> gwern:  in fact, it has been living at code.haskell.org/~dons/code/hwn for the past 8 months
23:17:13 <gwern> dons: 'k thnx
23:17:50 <gwern> dons: incidentally, I've sent in my replies on library if you want to read'em
23:22:50 <hpaste>  morrow pasted "one command ghc-HEAD get/config/build/install" at http://hpaste.org/8465
23:24:44 <hpaste>  morrow annotated "one command ghc-HEAD get/config/build/install" with "forgot a backslash" at http://hpaste.org/8465#a1
23:24:57 <dons> gwern: yep, looks good.
23:25:21 <dons> gwern: the hackage extensions we're working on at galois will let you mark things orphaned, lock down who can upload things, etc.
23:25:24 <dons> so should solve some of the issues
23:26:41 <hpaste>  morrow annotated "one command ghc-HEAD get/config/build/install" with "forgot --extra" at http://hpaste.org/8465#a2
23:28:58 <hpaste>  mmorrow annotated "one command ghc-HEAD get/config/build/install" with "final correction (and most critical)" at http://hpaste.org/8465#a3
23:33:26 <scodil> if you increase the unfolding threshold, and the compiler takes longer, that means its actually doing something, right? Or does it just spin its wheels and eventually produce the same code?
23:34:05 <dons> well, look at the simplifier stats
23:34:12 <dons> you'll see if things get smaller or bigger
23:34:46 <scodil> no that's my problem. I've increased the unfolding threshold an now ghc doesn't stop. I don't know whether to wait longer or just assume I've struck a nerve and sent it into a loop
23:35:12 <scodil> its running out of ram
23:35:14 <scodil> 1G
23:35:30 <mmorrow> is the code example small enough to paste?
23:35:37 <scodil> no
23:36:01 <mmorrow> i bet it's fine (but 1G holy crap)
23:36:22 <scodil> what do you mean its fine? If I let it run it will eventually give me a program?
23:36:44 <dancor> is there any reasonable way to translate a .y yacc file into code for a native haskell parser (like parsec, or any other one)
23:36:46 <mmorrow> more a "umm kill it now or watch it die or maybe work"
23:37:56 <GrayShade> quicksilver: about that compilation technique which uses arrays instead of maps, it's a bit faster and i even got it to run faster than similar OCaml code (but the code looks terrible)
23:41:12 <gwern> mmorrow: one gig? hah. if you were using jhc, you'd be saying *only* one-gig?
23:41:56 <mmorrow> gwern: sounds breathtaking
23:42:41 <gwern> dons: that sounds good, but I still think that unmaintained should be the default. otherwise, we have some sort of weird tri-valued variable: unmaintained, maintained by foo, and neither.
23:43:05 <gwern> mmorrow: on the other hand, as people say, the binaries are tiny and blazing fast
23:43:13 <gwern> (when you can compile them, that is)
23:43:36 <mmorrow> really. hmm
23:44:17 <mmorrow> i've never had *any* contact with jhc
23:44:27 <mmorrow> ghc and yhc only
23:44:28 <gwern> if we could compile the shootout entries with jhc, I would not be surprised if haskell moved up to 2 or 3. on the other hand, I remember jhc having very few libraries supported, so we can't
23:44:51 <mmorrow> does it at least have hierarchical libs?
23:45:10 <gwern> don't remember. but I think so
23:45:16 <mmorrow> cool
23:46:59 <gwern> it'd definitely be worth hacking on, if you need a project
23:47:32 <mmorrow> i'm definitely gonna check it out, thx
23:49:22 <gwern> jhc has an odd structure of nested repos, so be sure to read the webpage instructions carefully
23:49:45 <gwern> (it's like ghc, but doesn't provide a script for downloading the other repos into the right place)
23:50:59 <vixey> dons, what is the recursion with boxes thing about?
23:51:01 <mmorrow> looking at http://repetae.net/computer/jhc/ now
23:51:02 <lambdabot> Title: jhc
23:53:20 <dolio> "A Core Language for Dependently Typed Programming" clearly.
23:54:46 <dolio> I guess that was just a link in that article.
23:55:26 <mmorrow> a nice pdf: http://repetae.net/computer/jhc/big-picture.pdf
23:56:01 <dolio> It was about the recent issue in Coq/Agda with coinductive types and how it would (should) work in their formalism
