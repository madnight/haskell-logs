00:06:56 <Cale> @bot
00:06:56 <lambdabot> :)
00:07:23 <Cale> Where does lambdabot look for fortunes?
00:08:05 <vixey`> hey Cale
00:08:11 <Cale> hi
00:08:12 <vixey`> why not add Mu to lambdabot?
00:08:22 <vixey`> data Mu a = Mu { roll :: a (Mu a) } or whatever
00:09:35 <Cale> vixey`: I could, sure.
00:09:57 <vixey`> cool :D
00:10:15 <vixey`> I am not sure if it should be roll or unroll
00:10:25 <Cale> @undefine
00:10:27 <lambdabot> Undefined.
00:10:33 <Cale> :t In
00:10:34 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
00:10:35 <Cale> :t out
00:10:37 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
00:11:11 <Cale> (\f -> (\x -> f (out x x)) (In (\x -> f (out x x)))) (\f n -> if n == 0 then 1 else n * f (n-1)) 5
00:11:16 <Cale> > (\f -> (\x -> f (out x x)) (In (\x -> f (out x x)))) (\f n -> if n == 0 then 1 else n * f (n-1)) 5
00:11:18 <lambdabot>      Occurs check: cannot construct the infinite type: f = (->) (Mu f)
00:11:18 <lambdabot>     Pr...
00:11:21 <Cale> hmm
00:11:53 <Cale> oh, right
00:12:00 <vixey`> :t let z = In (Left ()) ; s x = In (Right x) in s (s (s (s z)))
00:12:02 <lambdabot> Mu (Either ())
00:12:05 <Cale> Different one than I was thinking of :)
00:13:16 <vixey`> :t let z = In (Left ()) ; s x = In (Right x) ; ch (In (Left ())) = 0 ; ch (In (Right n)) = 1 + (ch n) in ch (s (s (s (s z))))
00:13:17 <lambdabot> forall t. (Num t) => t
00:13:21 <vixey`> > let z = In (Left ()) ; s x = In (Right x) ; ch (In (Left ())) = 0 ; ch (In (Right n)) = 1 + (ch n) in ch (s (s (s (s z))))
00:13:22 <lambdabot>  4
00:14:36 <vixey`> :t (Mu ((,) Integer))
00:14:37 <lambdabot> Not in scope: data constructor `Mu'
00:14:37 <lambdabot> Not in scope: data constructor `Integer'
00:14:41 <vixey`> :k (Mu ((,) Integer))
00:14:43 <lambdabot> *
00:14:55 <Cale> @undefined
00:14:56 <lambdabot> Undefined.
00:15:07 <Cale> > (\f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))) (\f n -> if n == 0 then 1 else n * f (n-1)) 5
00:15:14 <lambdabot>  120
00:15:22 <Cale> :t InR
00:15:23 <lambdabot> forall a. (Rec a -> a) -> Rec a
00:15:28 <Cale> :t OutR
00:15:29 <lambdabot> Not in scope: data constructor `OutR'
00:15:30 <vixey`> hmm
00:15:32 <Cale> :t outR
00:15:33 <vixey`> what's this?
00:15:34 <lambdabot> forall a. Rec a -> Rec a -> a
00:15:55 <vixey`> :t fix
00:15:57 <lambdabot> forall a. (a -> a) -> a
00:15:57 <Cale> It's useful for embedding terms from the untyped lambda calculus.
00:15:57 <vixey`> :t ($)
00:15:59 <lambdabot> forall a b. (a -> b) -> a -> b
00:16:05 <Cale> :t (\f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))))
00:16:07 <lambdabot> forall a. (a -> a) -> a
00:16:15 <vixey`> cool
00:16:20 <Cale> (that's the usual Y combinator)
00:17:45 <Cale> Now, fortune doesn't seem to be installed on c.h.o, so I have no idea where I should tell it to look for fortune files...
00:18:59 <Cale> I suppose I could copy over the fortune files from my machine...
00:19:07 <Cale> @yow
00:19:07 <lambdabot> Couldn't find fortune file
00:21:29 <Saizan> 2
00:28:28 <dolio> Everybody gets free BORSCHT!
00:30:36 <rwbarton> @undo do { x <- f ; g ; return x }
00:30:36 <lambdabot> f >>= \ x -> g >> return x
00:30:56 <rwbarton> @pl  \f g -> f >>= \ x -> g >> return x
00:30:57 <lambdabot> (. ((. return) . (>>))) . (>>=)
00:31:12 <rwbarton> is there a name for that?  I write it a lot
00:31:13 <curry> >read ("a16") :: [(Char,Int)]
00:31:28 <vixey`> rwbarton: just choose a name
00:31:32 <vixey`> > let f n k = if k <= n then n else f (f (n+1) k) k in liftM2 f [1..5] [1..5]
00:31:34 <lambdabot>  [1,2,3,4,5,2,2,3,4,5,3,3,3,4,5,4,4,4,4,5,5,5,5,5,5]
00:34:43 <vixey`> let f `mSeq` g = do x <- f ; g ; return x
00:35:43 <Japsu> @oeis 1 2 3 4 5 2 2 3
00:35:44 <lambdabot> Smallest number of pentagonal numbers which sum to n.
00:35:44 <lambdabot> [0,1,2,3,4,1,2,3,4,5,2,3,1,2,3,3,4,2,3,4,4,5,1,2,2,3,4,2,3,3,4,5,3,4,2,1,2,3,...
00:36:04 <vixey`> > let f n k = if k <= n then n else f (f (n+1) k) k in liftM2 f [1..7] [1..7]
00:36:05 <lambdabot>  [1,2,3,4,5,6,7,2,2,3,4,5,6,7,3,3,3,4,5,6,7,4,4,4,4,5,6,7,5,5,5,5,5,6,7,6,6,6...
00:36:15 <vixey`> It's really a 2D thing
00:37:28 <mmorrow> > take 8 . nub . sort . take 100 . randomRs (0::Int,24) . mkStdGen $ 0
00:37:29 <lambdabot>  [0,1,2,3,4,5,6,7]
00:37:44 <mmorrow> > take 10 . randomRs (0::Int,24) . mkStdGen $ 0
00:37:46 <lambdabot>  [20,5,0,0,12,24,18,13,23,23]
00:38:17 <mmorrow> @oeis 0 5 13 18 20 23
00:38:18 <lambdabot> Sequence not found.
00:38:22 <mmorrow> @oeis 5 13 18 20 23
00:38:22 <lambdabot> Sequence not found.
00:42:13 <turingbot> @oeis1,4,6,13
00:42:13 <lambdabot> Unknown command, try @list
00:42:17 <turingbot> @oei s1,4,6,13
00:42:17 <lambdabot> Sequence not found.
00:42:20 <turingbot> @oeis 1,4,6,13
00:42:20 <lambdabot> Busy Beaver sequence, or Rado's sigma function: maximum number of 1's that an...
00:42:20 <lambdabot> [0,1,4,6,13]
00:44:43 <Saizan> rwbarton: (<*) from Control.Applicative
00:44:48 <Saizan> ?ty (<*)
00:44:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
00:45:33 <solrize> wow, ghc 6.8.3 is released, could someone put that in the channel topic?
00:48:01 <hpaste>  (anonymous) annotated "Lychrel" with "(no title)" at http://hpaste.org/3336#a1
00:48:55 <jansz> @pl unfoldr (\z -> Just (z,2*z)) 1
00:48:55 <lambdabot> unfoldr (Just . ap (,) (2 *)) 1
00:49:23 <vixey`> > iterate (2*) 1
00:49:24 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:49:25 <vixey`> > unfoldr (\z -> Just (z,2*z)) 1
00:49:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:49:46 <vixey`> @src unfoldr
00:49:46 <lambdabot> unfoldr f b  = case f b of
00:49:46 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
00:49:46 <lambdabot>    Nothing        -> []
00:49:50 <vixey`> @src iterate
00:49:50 <lambdabot> iterate f x =  x : iterate f (f x)
00:50:03 <rwbarton> Saizan: unfortunately, it seems Parser is not an instance of Applicative
00:50:41 <vixey`> looks like a problem for agda coindution
00:50:55 <Saizan> rwbarton: it's easy to fix if you want, pure = return; (<*>) = ap
00:51:07 <dolio> Eh?
00:57:53 <BeelsebobWork> @hoogle Char -> Word8
00:57:54 <lambdabot> Data.ByteString.Internal.c2w :: Char -> Word8
00:58:00 <BeelsebobWork> :/
00:58:41 <BeelsebobWork> @hoogle String -> [Word8]
00:58:42 <lambdabot> No matches, try a more general search
00:59:01 <Saizan> :t fromIntegral . ord
00:59:02 <lambdabot> forall b. (Num b) => Char -> b
00:59:58 <mmorrow> http://www.irisa.fr/prive/talpin/papers/ic97.pdf
01:00:49 <idnar> :t map (fromIntegral . ord)
01:00:52 <lambdabot> forall b (f :: * -> *). (Functor f, Num b) => f Char -> f b
01:01:17 <BeelsebobWork> cheers Saizan probably not the most efficient way of emulating PackedString, but hey, it'll work for now
01:02:05 <idnar> :t map (fromIntegral . ord) :: String -> [Word8]
01:02:07 <lambdabot> String -> [Word8]
01:03:02 <Saizan> ?ty Data.ByteString.pack -- ?
01:03:03 <lambdabot> [Word8] -> BSC.ByteString
01:03:19 <Saizan> ?ty Data.ByteString.Char8.pack
01:03:21 <lambdabot> String -> BSC.ByteString
01:03:45 <BeelsebobWork> ah, cheers Saizan
01:03:47 <BeelsebobWork> useful
01:04:20 <ivanm> Saizan: are you thanking ByteString there? :p
01:04:42 <Saizan> thanking?
01:04:48 <BeelsebobWork> ty
01:05:03 <ivanm> at least _someone_ got it ;-)
01:05:16 <Saizan> heh :)
01:05:41 <Saizan> :t doesn't work in query so i got that habit
01:05:42 <lambdabot> parse error on input `in'
01:11:14 <Saizan> in ML you write (a typecon) instead of (typecon a), right?
01:15:53 <vixey`> Saizan: yes
01:18:56 <mmorrow> http://rtportal.upv.es/rtmalloc/files/MRBC_2008.pdf
01:28:31 <vixey`> "we know that primitive recursion together with higher order functions give us a way to express all provably (in Peano's arithemtic) total functions"
01:28:34 <vixey`> do we? :S
01:28:57 <vixey`> what is the proof of this?
01:31:01 <dolio> I think A Tutorial on the Universality ... of Fold shows how to express the Ackermann function in terms of fold.
01:31:04 <dolio> So that's evidence, I guess.
01:53:26 <dcoutts> bos: ah yes, I found the bug in Cabal-1.2 where it discards the ghc-prof-options. The unionBuildInfo function was discarding it.
01:53:26 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:55:01 <dcoutts> @seen thetallguy
01:55:01 <lambdabot> thetallguy is in #haskell. I don't know when thetallguy last spoke.
01:55:25 <dcoutts> @tell thetallguy I've not seen those cabal-install patches arrive yet.
01:55:26 <lambdabot> Consider it noted.
02:00:32 <igli> meh sorear not about?
02:00:55 <dolio> He isn't much these days.
02:01:22 <igli> ah well nm :) only really came into watch nice code dolio ;)
02:03:10 <igli> @yarr
02:03:10 <lambdabot> Aye
02:10:17 * Baughn notes that LB is /still/ leaking memory. Very, very slowly, but...
02:10:28 <Baughn> Time to see if the 6.8.3 profiler works any better.
02:13:32 <Axman6> while you're at it, would you be able to tell me how to use the profiler? i wasn;t aware there was one. would be quite helpful
02:14:29 <Baughn> Axman6: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
02:14:37 <Axman6> cheers :)
02:15:45 <Baughn> GHC has probably the most aqdvanced profiler of any compiler |'ve seen - when it deigns to work.
02:15:50 <Baughn> The thing is, we need it. :/
02:19:36 <dancor> how does @dice work
02:20:02 <Baughn> Through the awesome power of statistics
02:20:19 <Baughn> http://code.haskell.org/lambdabot/Plugin/ <-- Here, see for yourself
02:20:25 <dancor> i'm trying
02:20:30 <dancor> 3d6+2 == wtf
02:22:05 <Japsu> dancor: "roll three six-sided dice and add 2 to the result"
02:22:23 <dancor> @dice 3d6+2
02:22:23 <lambdabot> 3d6+2 => 12
02:22:24 <dancor> @dice 3d6+2
02:22:25 <lambdabot> 3d6+2 => 13
02:22:32 <Baughn> @dice @dice 50000000000d2
02:22:32 <lambdabot> unexpected "@": expecting number
02:22:36 <Baughn> @dice 50000000000d2
02:22:36 <lambdabot> 50000000000d2 => 75000049049
02:22:38 <dancor> it should be called dicesum
02:22:41 <igli> i know this doesn't work i'd like to know how to make it do so:
02:22:45 <Japsu> no, it shouldn't
02:22:45 <igli> > data Tree = Leaf a | Bin (Tree a) (Tree a)
02:22:46 <lambdabot>  Parse error at "data" (column 1)
02:22:46 <dancor> what's the point of summing them
02:22:49 <Baughn> dancor: It's standard dice notation
02:22:55 <igli> yer AD&D
02:23:04 <Japsu> that notation has been used for dice rolls since the 80's
02:23:10 <Baughn> A lot more than just AD&D, I"d say
02:23:23 <igli> Runequest was good ;)
02:23:28 <vixey`> igli: data Tree a = Leaf a | Bin (Tree a) (Tree a)
02:23:28 <Baughn> But when you ask it to roll 50 milliard dice and it still returns immediately..
02:23:58 <igli> ah thanks vixey` :)
02:24:04 <igli> > data Tree a = Leaf a | Bin (Tree a) (Tree a)
02:24:05 <lambdabot>  Parse error at "data" (column 1)
02:24:48 <igli> hmm was thinking same type but it doesn't like data apparently
02:25:00 <dancor> has anyone every used lb's @dice to you know.. do anything
02:25:05 <vixey`> igli: what is 'it'?
02:25:14 <Axman6> bleh, how do i install a downloaded haskell module again? i installed the OpenGL one before, and now can't remember how to do it
02:25:15 <vixey`> dancor: yes
02:25:55 <Baughn> Axman6: ghc --make Setup && ./Setup configure-build-install
02:26:03 <Axman6> cheers
02:26:09 <Baughn> Axman6: Or, well, cabal install OpenGL
02:26:18 <igli> vixey`: tbh i'm taking this code from a book that i've always wanted to play with; i've never been able to get lambdabot to do anything with it tho
02:27:06 <vixey`> igli: yeah lambdabot will not do it, you will need ghc locially
02:27:14 <igli> ah ok cool
02:28:03 <tobias_tud> hi, i have a case x of in a do statement and in one case, nothing should happens, how can i realize this behaviour?
02:28:28 <Baughn> tobias_tud: "return ()", perhaps?
02:28:42 <Baughn> Just guessing here (that your case returns monadic values)
02:28:54 <tobias_tud> yes, IO
02:30:17 <tobias_tud> cool, it works
02:30:24 <jansz> @pl map (\ (f,m) -> zipWith (^) (repeat f) [0..m])
02:30:24 <lambdabot> map (uncurry ((. enumFromTo 0) . zipWith (^) . repeat))
02:30:26 <tobias_tud> thanks, Baughn
02:31:04 <vixey`> zipWith f (repeat x) = map (f x)
02:45:09 <Axman6> hmm
02:46:51 <Axman6> running my program that i compiled with -prof -auto-all, and then ./Mail +RTS -p does produce a Main.prof file, but it's empty
02:49:34 <Baughn> Axman6: Try Main.hp
02:49:57 <Baughn> Or.. hmm
02:50:14 <Baughn> Axman6: How fast does your program run?
02:50:23 <Axman6> not that fast
02:50:32 <Baughn> Axman6: It's a statistical profiler, so something that finishes /too/ fast.. well, okay
02:50:33 <Axman6> well, it's continuous
02:50:51 <Axman6> it's a cellular automata thing
02:51:15 <Baughn> ..I don't know. What GHC version are you using?
02:51:42 <Axman6> The Glorious Glasgow Haskell Compilation System, version 6.8.2
02:52:12 <Baughn> Try 6.8.3. I don't know if there are any specific bugs in 6.8.2, but its profiler /has/ been giving me trouble, and there /are/ fixes for it in 6.8.3
02:54:28 <Axman6> hmm, macports doesn't have 6.8.3 yet
02:54:37 <Baughn> Don't worry. It compiles fine.
02:54:43 <Axman6> i'll install by hand i guess
02:56:15 <Axman6> where can i get it from? the ghc sites seems to only have 6.8.2, or 6.9.xxx which would be nightly dev builds only right?
02:56:30 <Axman6> ah, dw
02:57:24 <Axman6> what's in the extralibs?
02:57:45 <Baughn> ..various stuff that you can also install via cabal-install
03:01:26 <Axman6> i guess i should install cabal then
03:01:52 <dcoutts> indeed!
03:04:33 <osfameron> heh, I was reading about the Scala type system being complicated by Haskell standards.  Anyone here played with scala much?
03:10:04 <povman> there appears to be a hole where haskell persistence should be
03:10:23 <quicksilver> Data.Binary? happs?
03:10:58 <povman> data.binary still needs to be written to disk all in one go afaict
03:12:05 <povman> and happs seems to require an enormous amount of other libraries to work
03:13:09 <hansfbaier> haskelldb?
03:13:29 <povman> haskelldb doesn't compile with ghc 6.8
03:13:38 <povman> hasn't been updated in forever
03:16:05 <Axman6> rawr, ghc takes forever to compile
03:16:18 <povman> i just read a nice paper.... http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.1560
03:16:19 <lambdabot> Title: A Persistence Library for Haskell - CiteSeerX
03:16:33 <dancor> what is the point of the lambdabot prefix fuzzing, just to make @losers work for @users? :)
03:16:38 <dancor> @losers
03:16:38 <lambdabot> Maximum users seen in #haskell: 426, currently: 424 (99.5%), active: 12 (2.8%)
03:18:29 <povman> @scisers
03:18:29 <lambdabot> Unknown command, try @list
03:18:32 <povman> doh
03:19:04 <hansfbaier> there seems to be a group of haskell users that rather likes writing papers than programs...
03:19:18 <Axman6> like my lecturer
03:19:34 <Axman6> he's written quite a few papers on various haskell topics
03:19:56 <Axman6> http://cs.anu.edu.au/~Clem.Baker-Finch/Research/
03:19:57 <lambdabot> Title: Clem Baker-Finch's Research Papers
03:20:09 <povman> Axman6: you're at anu too??
03:20:15 <Axman6> aye
03:20:25 <Axman6> G'day
03:20:26 <povman> what year¿
03:20:29 <Axman6> first
03:20:34 <povman> aha
03:20:41 <povman> and already on #haskell! well done.
03:20:42 <Axman6> you?
03:20:45 <povman> 5th
03:20:45 <Axman6> :)
03:20:48 <Axman6> nice
03:20:58 <Axman6> i've been on irc for a loonngg time
03:21:08 <Axman6> i'm one of the ops of #macosx
03:21:32 <Axman6> what degree are you doing?
03:21:36 <povman> software eng
03:21:42 <Axman6> nice
03:21:45 <HunterXHunter> @g'day
03:21:45 <lambdabot> Unknown command, try @list
03:22:00 <HunterXHunter> @lusers
03:22:01 <lambdabot> Maximum users seen in #haskell: 426, currently: 423 (99.3%), active: 13 (3.1%)
03:22:03 <Axman6> thinking of changing into that. i'm doing engineering/IT right now
03:22:13 <Axman6> final exam for the semester this morning
03:22:23 <povman> awwesome.
03:22:45 <Axman6> i'm probably going to get about 95% for COMP1100
03:22:54 <HunterXHunter> well done
03:22:58 <Axman6> so, i think it mat kind of be my thing  ;)
03:24:00 <Axman6> may be*
03:24:57 <Axman6> uh, may*
03:26:09 <povman> the main topic of interest of #macosx seems to be grains and cerials
03:26:27 <Axman6> indeed
03:26:34 <Axman6> that's how we power our macs
03:26:42 <Axman6> but shh, no one's supposed to know
03:27:04 <ibid> food is always on topic
03:27:09 <ibid> oops. wrong channel'
03:27:10 <ibid> :
03:27:11 <ibid> )
03:29:09 <BeelsebobWork> dons: you happen to be about?
03:29:48 <Axman6> i don't remember ghc taking this long to compile -_-
03:30:05 <BeelsebobWork> ghc takes ages to compile... unless you have a MacPro >.<
03:30:15 <BeelsebobWork> took 20 minutes on this machine
03:30:48 <Axman6> well my MBP isn't too shabby, but urgh
03:31:03 <Axman6> LLVM takes a damn long time too
03:31:06 <BeelsebobWork> has anyone here played with LocH?
03:36:21 <Axman6> there seems to be quite an active australian academic haskell community
03:38:19 <quicksilver> Yup.
03:38:23 <quicksilver> unsw is a hotbed ;)
03:43:34 <BeelsebobWork> @tell dons I've found a bug in LocH, do you have a sensible way to report such things?
03:43:35 <lambdabot> Consider it noted.
03:44:25 <povman> what i'd _like_ to see is some way of playing with instances of Binary so that only updates are written to disk
03:44:53 <povman> not necessarily Binary
03:45:49 <nornagon> yay unsw :)
03:46:11 <nornagon> i seem to have narrowly missed (re-)learning haskell in first semester, so instead they taught C.
03:46:32 <nornagon> of course, having been a programmer for about six years now ... i wasn't going to learn anything either way.
03:46:44 <nornagon> But next year they'll probably be teaching haskell again in first year :)
03:50:54 <Axman6> nornagon: i've got a friend at unsw doing engineering/IT i think. he was doing C too
03:51:27 <shapr> Hey look, we have a good reputation - http://www.cs.kuleuven.ac.be/~dtai/projects/ALP//newsletter/dec07/content/Articles/tom/content.html
03:51:29 <lambdabot> Title: Wake up call, http://tinyurl.com/3p3zvk
03:52:56 <vixey`> Tom Schrijvers has done work in GHC and stuff though
04:00:54 <Baughn> What would be the sanest way to render mathml in haskell? Any libraries there already? C libraries I should look at? (Standalone programs?)
04:01:29 <Axman6> urgh, wtf?
04:02:03 <Axman6> just installed ghc 6.8.3, and now trying to install GLUT which worked fine under 6.8.2, but now i get:
04:02:06 <Axman6> Setup: At least the following dependencies are missing: OpenGL >=2.2
04:02:25 <Baughn> You need to upgrade opengl before glut
04:02:27 <Axman6> i don't even thing that OpenGL 2.2 exists yet
04:02:32 <Axman6> hmm
04:02:34 <Baughn> OpenGL-2.2.1.1
04:02:46 <Baughn> That's what comes with ghc 6.8.3, assuming you get the extra libraries
04:03:06 <Axman6> ah, i should get that then
04:03:14 <Baughn> cabal-install will, of course, do this automatically. ;)
04:03:25 <Axman6> haven't installed cabal yet
04:03:34 <Baughn> cabal-install, I said
04:03:41 <Axman6> or that
04:03:45 <Baughn> And that should be the first thing you do. Install it, then keep a binary around for later use.
04:07:10 <Baughn> Axman6: Oh, and the opengl library version isn't synced to the opengl specification version, in case that's what worries you
04:07:21 <Axman6> yeah, figured that
04:09:12 <Axman6> Setup: At least the following dependencies are missing:
04:09:12 <Axman6> HTTP >=3000 && <3002, network >=1 && <3, zlib >=0.4
04:09:14 <Axman6> -_-
04:09:45 <Axman6> this is for cabal-install
04:09:48 <Baughn> Yes
04:09:57 <Baughn> Look at it this way. You only have to install it once.
04:10:06 <Axman6> heh, ok
04:10:17 <Baughn> Once you have the cabal-install binary, it is perfectly capable of reinstalling cabal-install the next time you delete all your libraries/upgrade ghc.
04:10:43 <Baughn> (Just make sure to copy it from ~/.cabal/bin to somewhere safe. :P)
04:14:31 <paolino> @src scanl
04:14:31 <lambdabot> scanl f q ls = q : case ls of
04:14:31 <lambdabot>     []   -> []
04:14:31 <lambdabot>     x:xs -> scanl f (f q x) xs
04:15:07 <paolino> @src foldr
04:15:07 <lambdabot> foldr f z []     = z
04:15:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:15:19 <Baughn> > scanl (+1) 0 [1..5]
04:15:20 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
04:15:20 <lambdabot>     Probabl...
04:15:41 <Baughn> > scanl (+) 2 [1..5]
04:15:42 <lambdabot>  [2,3,5,8,12,17]
04:16:01 <paolino> scanl works on infinite lists like foldr ?
04:16:12 <quicksilver> yes.
04:16:25 <quicksilver> > scanl (+) 0 [0..]
04:16:27 <lambdabot>  [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253...
04:16:54 <paolino> ok, then left and right are just lik politics
04:17:19 <Baughn> > scanl f a [b,c]
04:17:21 <int-e> > fix (scanl (+) 0 . (1:))
04:17:22 <lambdabot>  [a,f a b,f (f a b) c]
04:17:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:17:42 <Baughn> > scanr (+) 2 [1..5]
04:17:43 <lambdabot>  [17,16,14,11,7,2]
04:17:47 <Baughn> > scanr f a [b,c]
04:17:48 <lambdabot>  [f b (f c a),f c a,a]
04:19:50 <paolino> int-e: what's the fix there for ?
04:21:18 <int-e> paolino: to tie a knot. I could write  let fibs = scanl (+) 0 (1 : fibs) in fibs  instead
04:23:28 <paolino> is that what fix was created for ?
04:27:52 <Axman6> ok, finally got cabal-install installed
04:28:34 <dancor> @quote dons
04:28:35 <lambdabot> dons says: devils are angry, noisy mini-Russel Crowes. Who wouldn't want those roamin the bush?
04:30:37 <dcoutts_> @seen mnislaih
04:30:37 <lambdabot> I haven't seen mnislaih.
04:32:09 <paolino> @src fix
04:32:09 <lambdabot> fix f = let x = f x in x
04:33:04 <Axman6> bleh, after all that, profiling still doesn't work
04:39:08 <Axman6> anyone got any tips for making profiling work? from what i can tell, i compile my program with -prof -auto-all, and then run it with +RTS -p, and i should get a main.prof file. i get the file, but it's empty
04:41:56 <paolino> did you force sources recompilation?
04:42:08 <Axman6> i believe so
04:42:23 <Axman6> but let's assume i didn't, and don't know how to
04:42:39 <paolino> delete *.o
04:42:44 <paolino> or touch *.hs
04:43:08 <Axman6> there's a few dirs of stuff, so i'll use finder
04:46:13 <Saizan> you can pass -fforce-recomp
04:46:23 <Saizan> to ghc
04:48:53 <Axman6> still getting empty .prof files
04:49:08 <Axman6> well, file
04:53:15 <dieJana> can the arity of a predicate be interpreted as the type of that predicate?
04:56:20 <Axman6> no one? :\
04:56:24 <Saizan> Axman6: does your program terminate cleanly?
04:56:58 <Axman6> well, it creates a window, and i end the program by quitting it like any OS X app
04:59:29 <Axman6> i tried "/Main +RTS -p && echo 1" and it does echo 1, so i assume it's exiting cleanly
05:01:57 <quicksilver> Axman6: I suspect your reasoning is false.
05:02:09 <quicksilver> Axman6: I suspect selecting quit isn't a clean exit from the GHC rts.
05:02:17 <quicksilver> Axman6: what's running your main loop? GLUT by any chance?
05:02:17 <Axman6> hmm
05:02:25 <Axman6> i believe so
05:02:29 <quicksilver> yes.
05:02:37 <quicksilver> I have reason to believe GLUT>Quit is not a clean exit
05:02:40 <quicksilver> I don't understand the details
05:02:51 <quicksilver> try explicitly calling exitWith ExitSuccess
05:02:51 <Axman6> hmm, that sucks
05:02:54 <quicksilver> from some point in your code
05:03:19 <Axman6> ok
05:05:04 <Axman6> quicksilver: would that run under a do construct?
05:05:34 <mauke> do is irrelevant
05:06:25 <Axman6> well, i'm not sure how to run it in my code
05:07:42 <Axman6> the main function calls a another function straight away
05:08:56 <Axman6> which runs the simulation
05:09:31 <Axman6> would something like 'myExit exitWith ExitSuccess
05:09:34 <Axman6> bleh
05:10:08 <Axman6> 'myExit _ = exitWith ExitSuccess' called on a function run the function argument?
05:10:24 <quicksilver> well exitWith lives in IO
05:10:30 <quicksilver> so ultimately you have to call it from IO yes
05:11:39 <Axman6> MainLinked.hs:38:11: Not in scope: `exitWith'
05:11:40 <Axman6> MainLinked.hs:38:20: Not in scope: data constructor `ExitSuccess'
05:12:17 <laz0r> mmh, i think there is an error in the imlib2 binding thats available on hackage
05:12:49 <laz0r> on several occasions, it uses something like [w,h] <- replicateM 4 malloc
05:13:01 <laz0r> which leads to a pattern matching error
05:14:17 <EvilTerran> ?hoogle exitWith
05:14:17 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
05:14:43 <EvilTerran> hooray for our Fine Manual being indexed :)
05:14:53 <mauke> @index exitWith
05:14:53 <lambdabot> System.Exit
05:14:54 <Cale> laz0r: that sounds likely. I haven't really tested or examined that code carefully.
05:16:26 <Cale> laz0r: I wrote it in one or two sessions back when I was learning the FFI and decided to release it anyway more recently without really looking at it too closely.
05:18:27 <Axman6> urgh
05:18:40 <byorgey> morning, #haskell!
05:18:43 <Axman6> now the program just exits without running
05:19:52 <byorgey> Axman6: which program is this? (sorry, I just came in)
05:20:00 <quicksilver> Axman6: yes well you don't want to exit at the beginning!
05:20:02 <Cale> Axman6: hmm, how are you compiling the program?
05:20:02 <Axman6> my program
05:20:10 <quicksilver> Axman6: you want to exist at some sensible point
05:20:15 <quicksilver> after you've done some work which you want to do.
05:20:18 <Cale> oh, I just saw that message up there
05:20:24 <Cale> huh
05:20:27 <byorgey> exiting at a sensible point is good too.  ;)
05:20:51 <quicksilver> background for Cale + byorgey : profiling isn't working for Axman6. My suggestion is that GLUT's quit functionality (brought on by selecting Quit from a menu) bypasses the GHC RTS shutdown procedure.
05:20:56 <laz0r> Cale: ok, so far everything i used worked as expected, just the getTextSize and the getTextAdvance functions didn't work
05:20:57 <Cale> compiling with -prof -auto-all and running with +RTS -p usually produces a sensible .prof even if the program dies with an exception.
05:21:08 <quicksilver> so Axman6 should instead of using Quit, exit explicitly.
05:21:14 <byorgey> ah, I see
05:21:16 <laz0r> there may be others i haven't used yet that have the same problem
05:22:32 <Cale> okay
05:22:59 <Cale> I'll check it out when I wake up. Just going to get a few hours sleep.
05:23:54 <dcoutts_> quick #haskell poll: here's some new suggested Cabal version syntax. Tell me what you think it means by giving a translation into existing syntax:
05:23:56 <dcoutts_> build-depends: foo ~1.2.3+
05:24:02 <laz0r> Cale: i just remembered, i had problems loading bitmaps, but i had blamed that on me not really knowing how to use the imlib2 correctly
05:24:15 <laz0r> anyways, good night
05:24:43 <tromp> it could also be called Word1
05:24:44 <mauke> <1.2.3
05:25:59 <Axman6> urgh
05:26:26 <dcoutts_> mauke: you mean build-depends: foo <1.2.3 ?
05:26:35 <jnordenberg> anyone got some insights on DDC and how it would fit in a language like Scala?
05:26:45 <mauke> dcoutts_: well, I don't really know the existing syntax :-)
05:26:59 <dcoutts_> :-)
05:27:01 <EvilTerran> i read it as "not at least 1.2.3"
05:27:16 <EvilTerran> so, yes, "less than 1.2.3"
05:27:59 <dcoutts_> EvilTerran: oh you read ~ as not. Hmm,
05:28:10 <mauke> of course
05:28:15 <mauke> what else?
05:28:18 <EvilTerran> ... what's it *meant* to mean?
05:28:35 <dcoutts_> I want more volunteers first :-) then I'll say
05:28:45 <mauke> "approximately"
05:29:07 <quicksilver> "ends in 1.2.3" ;)
05:29:19 <EvilTerran> 1.2.3+, but match it irrefutably, and fail lazily later on if needs be?
05:29:19 <Zao> I'd interpret it as either negation thanks to ~ being bitwise negation, or as "new syntax indicator"
05:29:27 <mauke> ">=1.2.3, but lazily"
05:30:01 * EvilTerran is just trying to think of every use of ~ he's seen
05:30:18 <mauke> regex match
05:30:21 <dcoutts_> ok, so we're proposing two new version range syntaxes:
05:30:33 <dcoutts_> foo ~ 1.2.*  which means  foo >= 1.2 && < 1.3
05:30:35 <mauke> so '1', any character, '2', any character, then 1 or more '3'
05:30:43 <EvilTerran> mauke, i was thinking 1.2.3's ok, as is 1.2.33, 1.2.333...
05:30:54 <mauke> that would be 1\.2\.3+
05:30:55 <dcoutts_> and we're less sure about the other one which is:
05:31:14 <EvilTerran> mauke, well, i covered a subset of the possibilities :P
05:31:15 <dcoutts_> foo ~ 1.2.1+  which means foo >= 1.2.1 && < 1.3
05:31:50 <dcoutts_> so yes, we were intending ~ to means "in the range of", elem, approx, something like that.
05:31:52 <EvilTerran> ... not so sure about that last one. bit confusing.
05:32:05 <byorgey> agree.
05:32:05 <EvilTerran> i'd rather write 1.2.(>1)
05:32:18 <nominolo> dcoutts_: do we need the "~" ?
05:32:25 <dcoutts_> nominolo: yes
05:32:34 <dcoutts_> well, we need something I think
05:32:43 <dcoutts_> it's a binary operator
05:33:00 <EvilTerran> ... it is?
05:33:01 <nus> dcoutts, isn't '=' enough for that?
05:33:04 <dcoutts_> build-depends: foo 1.2.*  ?
05:33:06 <EvilTerran> oh, i see
05:33:13 <nominolo> we have foo ==1.2, foo >= 1.3, foo <= 1.2
05:33:13 <dcoutts_> nus: but = means equals, not element of this range
05:33:26 <mauke> ∈
05:33:28 <EvilTerran> i like using ~~ for "matches"
05:33:32 <dcoutts_> mauke: yeah, right :-)
05:33:34 <EvilTerran> as in perl 6
05:33:40 <mauke> =~
05:33:43 <dcoutts_> EvilTerran: it's not a regexp
05:33:51 <EvilTerran> mauke, eew, even perlers agree that one's ugly :P
05:33:56 <mauke> dcoutts_: ~~ isn't for regexps either :-)
05:33:59 <EvilTerran> dcoutts_, it's not just used for regexps in perl6 iirc
05:34:00 <mauke> it's a "smart match" operator
05:34:06 <mauke> EvilTerran: ~~ is in 5.10.0
05:34:09 <EvilTerran> $needle ~~ @haystack
05:34:29 <dcoutts_> so, build-depends: foo ~~ 1.2.*
05:34:48 <EvilTerran> strange how an extra ~ can make all the difference :P
05:34:50 <dcoutts_> or, build-depends: foo ~~ 1.2.* && > 1.2.1
05:35:08 <dcoutts_> which is another way of writing our other proposed syntax
05:35:15 <EvilTerran> ... don't you need to mention foo againbefore the > ?
05:35:45 <dcoutts_> no
05:35:45 <dcoutts_> current syntax is build-depends: foo >= 1.1 && < 2  for example
05:35:52 <dcoutts_> can use, &&, ||
05:36:08 <nominolo> dcoutts_: but, atm, you can use && or || only once
05:36:11 <dcoutts_> though interestingly cannot use ()'s
05:36:14 <EvilTerran> oh right. so ~~, <, > etc are only *kinda* infix operators in this syntax
05:36:23 <dcoutts_> EvilTerran: right
05:36:30 <EvilTerran> given that you miss off their left parameter in some circumstances. how odd.
05:36:40 <dcoutts_> with the 'foo' as implicit left arg
05:37:05 <nominolo> they are partially applied comparision functions to yield a range ;)
05:37:07 <dcoutts_> so I guess they're really all prefix unary operators
05:37:43 <dcoutts_> right and && lifted to functions :-)
05:38:06 <EvilTerran> and lots of implicit parentheses
05:38:09 <dcoutts_> EvilTerran: so you think the ~~ is much clearer than the single ~ ?
05:38:14 <mauke> ≅
05:38:22 <EvilTerran> i do, personally, but i'm weird like that
05:38:42 <EvilTerran> something like :- would also work
05:38:43 <mauke> I agree with EvilTerran for no particular reason
05:38:45 <EvilTerran> `elem` :P
05:38:46 <dcoutts_> mauke: actually we can use unicode in .cabal files :-)  (however I'm not proposing we actually do)
05:39:02 <EvilTerran> mauke, :D
05:39:07 <mauke> maybe it's the perl
05:39:11 <dcoutts_> mauke: but if we did then ∈ would definitely be best :-)
05:39:28 <EvilTerran> i think most people are just used to thinking "binary negation" for ~, and we're used to thinking either that or "irrefutable match"
05:39:53 <mauke> or "masked" (gentoo)
05:39:57 <EvilTerran> but i think the only use of ~~ i've seen is as a smart match operator
05:40:11 <mauke> EvilTerran: or golfed scalar context :-)
05:40:12 <dcoutts_> mauke: foo ∈ [1.1..2), or foo ∈ [1.1..]
05:40:13 <nus> dcsouts, "particular version of the package is distinguished by a version number, consisting of a sequence of one or more integers separated by dots" (don't see what prevents making this working with '=') -- so you prefer leaving '=' strict, and introduce another operator, right?
05:40:29 <EvilTerran> mauke, i have no idea what that means
05:40:42 <EvilTerran> oh, wait, yes i do. ignore me.
05:40:47 * EvilTerran requires tea...
05:41:21 <EvilTerran> that's numeric context, though, isn't it? bit more specific than scalar?
05:41:42 <dcoutts_> nus: sure it's distinguishable syntactically but it offends the mathematically minded round here to overload = to mean member of, element of, in the range of
05:41:54 <mauke> EvilTerran: works for integers and strings
05:42:22 <mauke> dcoutts_: "f = O(n)"
05:42:40 <nus> dcoutts, right, but that's already de-facto standard (at least rpm, dpkg, ebuild come to the mind)
05:43:10 <dcoutts_> mauke: yeah but we all know that's evil because O(n) /= f
05:43:28 <dcoutts_> nus: sure sure, but they're wrong!! ;-)
05:44:21 <mauke> .oO( ghc -fﬃ )
05:44:26 <dcoutts_> nus: gentoo has particularly braindamaged * syntax. They've got foo = 1.2* which matches 1.2, 1.20 but not 1.12 :-)
05:45:00 <dcoutts_> mauke: heh heh
05:45:05 <HunterXHunter> f = O(1) !!!
05:46:26 <nus> dcoutts, but.. but it's 'usual WILDCARD semantics'?-)
05:46:38 <EvilTerran> mauke, weird
05:46:43 <dcoutts_> nus: yes, which for version numbers is borked
05:46:52 * EvilTerran has returned with tea! c\_/
05:47:10 <olsner> kind of makes sense for versioning schemes that treat the part after the dot kind of like decimals
05:47:41 <olsner> like, the first patch release of Opera 9.5 will be 9.51
05:47:42 <dcoutts_> olsner: if it were 1.2.* that'd be ok, but it's because gentoo uses 1.2* that it's so broken
05:47:56 <dcoutts_> olsner: oh, well that's just a bonkers versioning scheme :-)
05:48:38 <mm_freak_work> are the values of IORefs and STRefs unboxed?
05:48:39 <nus> dcoutts, what about 1.2cvsYYMMDDHHSS ?-)
05:49:14 <dcoutts_> nus: that's ok, I just choose not to believe such things exist, despite the evidence :-)
05:49:29 <olsner> yeah, 9.5 to 9.51 is a 46 version upgrade in my world
05:49:39 <Baughn> mm_freak_work: Not a chance
05:49:57 <dcoutts_> nus: that's why we're more strict with haskell version numbers, it's just a list of digits and compared by the normal Ord
05:50:13 <mm_freak_work> Baughn: so i have to write "x `seq` writeSomeRef ref x"?
05:50:25 <mauke> writeSomeRef ref $! x
05:50:36 <hpaste>  eks pasted "(no title)" at http://hpaste.org/8438
05:50:36 <EvilTerran> mm_freak_work, no, that won't work either
05:50:41 <mm_freak_work> uhm yeah…  somehow i always forget that ($!) exists
05:50:43 <mauke> dcoutts_: more strict? haskell? :-)
05:50:51 <nus> dcoutts, oh, that's fine policy with me (-:
05:50:56 <mm_freak_work> EvilTerran: how else?
05:51:00 <dcoutts_> mauke: in the sense of typing not evaluation
05:51:03 <EvilTerran> i'm afraid refs just don't work like that. the machinery's too complicated.
05:51:16 <mauke> I know
05:51:16 <EvilTerran> AFAIK, anyway.
05:51:23 <dcoutts_> EvilTerran: what's wrong with writeSomeRef ref $! x
05:51:24 <mauke> EvilTerran: seems to work here
05:51:47 <mm_freak_work> EvilTerran: but if i force the value of x right there, how can its evaluation be delayed?
05:52:28 <Axman6> finally! got exitWith to work in my app!
05:52:33 <Axman6> thanks quicksilver
05:52:38 <Axman6> and profiling works
05:52:45 <quicksilver> ;)
05:52:47 <quicksilver> good.
05:53:32 <Axman6> would you like to take a look at the app? it's kind of fun
05:54:01 <Axman6> ended up having to change my tutorer's code quite a bit, but i can now press p to quit it
05:54:04 <Axman6> should make that q...
05:56:25 <joey_> Mornin' all.
05:56:45 <chessguy> hi joey_
05:57:23 <paolino> ping Cale
05:58:02 <mauke> preflex: seen cale
05:58:02 <preflex>  cale was last seen on #haskell 35 minutes and 2 seconds ago, saying: I'll check it out when I wake up. Just going to get a few hours sleep.
05:58:09 <tobias_tud> is there a nice possibility to debug IOArrays? i'd like to know when exactly there is an error in array index
05:59:20 <tobias_tud> exactly means in whc
05:59:27 <tobias_tud> ich function the exception is
05:59:27 <chessguy> @bot
05:59:27 <lambdabot> :)
06:00:14 <paolino> thanks mauke
06:00:22 <EvilTerran> mm_freak_work, you asked if refs were unboxed, not if they could be made strict
06:00:27 <EvilTerran> it's an important distinction
06:00:45 <mm_freak_work> EvilTerran: aren't unboxed values strict by nature?
06:00:52 <EvilTerran> yes, but not vice-versa
06:01:26 <mm_freak_work> well…  i'm asking for unboxedness, because for most of my applications, performance is important
06:01:43 <mauke> making the ref itself unboxed doesn't affect its contents
06:01:59 <EvilTerran> mm_freak_work, ok. have you profiled a prototype?
06:03:34 <mm_freak_work> mauke: i'm meaning the value 'inside' of the ref
06:03:44 <quicksilver> mm_freak_work: a IOUArray of size one is an unboxed ref
06:03:56 <quicksilver> I'm not sure if that would perform well.
06:03:57 <mm_freak_work> EvilTerran: nope, currently i'm just experimenting, and right now just making design decisions
06:04:00 <EvilTerran> if not, worrying about unboxing is massive premature optimisation. might wanna bear that in mind.
06:04:18 <quicksilver> remember, premature evil is the root of all optimsation
06:04:26 <mauke> I always compile with ghc -omg-optimized
06:04:35 <mm_freak_work> quicksilver: i guess, the bounds check isn't much faster than the NF-check
06:04:58 <mauke> preflex: remember quicksilver remember, premature evil is the root of all optimisation
06:06:35 <nus> uhh, how comprehensive is the wiki page on the implementations?
06:07:55 <nus> http://www.haskell.org/haskellwiki/Implementations
06:07:55 <lambdabot> Title: Implementations - HaskellWiki
06:08:28 <quicksilver> nus: looks like it has the main suspects to me
06:08:33 <quicksilver> do you think there is something missing?
06:09:39 <nus> quicksilver, well, at least I've read some mentions of HS to Poplog somewhere
06:09:45 <Axman6> how nice, my program is spending 75% of it's time in the one exact function i thought it would
06:09:57 <Axman6> though that's not really a good thing
06:11:14 <Axman6> can anyone think of a faster way of doing this? http://pastie.textmate.org/private/fulqry3ej9g7h5dbl4x3ia
06:11:15 <lambdabot> Title: Private Paste - Pastie
06:11:43 <Axman6> or better yet, http://pastie.textmate.org/218794
06:11:43 <lambdabot> Title: #218794 by Alex Mason (Axman) - Pastie
06:11:49 <mauke> bonus points for correct use of "radii"
06:11:55 <Axman6> ;)
06:12:16 <vixey`> Axman: sqrt (a ^ 2 + b ^ 2) < x
06:12:21 <quicksilver> nus: I have never heard of poplog/haskell
06:12:22 <vixey`> Axman: a ^ 2 + b ^ 2 < x ^ x
06:12:34 <quicksilver> nus: although google search throws up a few.
06:12:36 <mauke> Axman6: (x) is x
06:12:50 <Axman6> :|
06:12:55 <vixey`> you don't have to do the expensive square root
06:12:58 <vixey`> do you understand why not?
06:13:03 <mauke> what square root?
06:13:06 <quicksilver> I think x*x is faster than x^2 as well
06:13:12 <HunterXHunter> > printf "%d" 12
06:13:13 <lambdabot>  Add a type signature
06:13:13 <Axman6> vixey`: did you see my second post?
06:13:24 <SamB_XP_> vixey`: why x ^ x?
06:13:40 <vixey`> SamB: oh, just a typo
06:13:45 <vixey`> Axman: ok
06:13:50 <HunterXHunter> whats printf in haskell?
06:13:58 <mauke> HunterXHunter: a function
06:14:01 <chessguy> @hoogle printf
06:14:01 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
06:14:01 <lambdabot> Text.Printf :: module
06:14:01 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
06:14:05 <mauke> > printf "%d" 12 :: String
06:14:07 <lambdabot>  "12"
06:14:10 <HunterXHunter> oh
06:14:22 <Axman6> > printf "%d" 12 :: Int
06:14:23 <lambdabot>   add an instance declaration for (PrintfType Int)
06:14:23 <lambdabot>     In the expression: pri...
06:14:34 <mm_freak_work> quicksilver: x*x is the same as x^2 for GMP
06:14:42 <quicksilver> Axman6: you might improve things slightly by unboxing.
06:14:44 <mauke> Axman6: you can only use String and IO a
06:14:47 <SamB_XP_> HunterXHunter: type-level prolog is such a fun game ;-)
06:15:00 <Axman6> quicksilver: hmm?
06:15:01 <quicksilver> mm_freak_work: (a) I don't think haskell uses GMP's power routine (b) this presumably is FPU not GMP.
06:15:15 <mm_freak_work> oh, right, sorry
06:15:16 <quicksilver> Axman6: change your cell type so that x and y are separate fields
06:15:19 <SamB_XP_> heheh
06:15:22 <quicksilver> (not in a tuple)
06:15:27 <quicksilver> Axman6: and make them strict.
06:15:39 <Axman6> doesn't GHC basically do that for you?
06:15:43 <quicksilver> no.
06:15:46 <Axman6> seem to remember reading something like that
06:15:54 <Axman6> ok, i'll try that
06:15:56 <SamB_XP_> quicksilver: hmm, a quick RULE could fix (a) ... couldn't it?
06:15:57 <quicksilver> you may have read something "like" it, but it wasn't that.
06:16:00 <SamB_XP_> @type (^)
06:16:02 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:16:04 <nus> quicksilver, nm, looks like he never finished the implementation
06:16:07 <quicksilver> SamB_XP_: yes, and maybe I was wrong anyway.
06:16:28 <quicksilver> Axman6: care to show us the definition of 'Cell' ?
06:17:11 <SamB_XP_> well, only if your b turned out to be Integer
06:17:48 <Axman6> http://pastie.textmate.org/218799
06:17:49 <lambdabot> Title: #218799 by Alex Mason (Axman) - Pastie
06:18:01 <chr1s> > printf "%d" (12 :: Int)
06:18:02 <lambdabot>  Add a type signature
06:19:21 <chr1s> ah, that's it
06:19:29 <chr1s> > printf "%d" 12 :: String
06:19:30 <lambdabot>  "12"
06:20:08 <Axman6> > printf "%d" 12 :: Char
06:20:08 <lambdabot>   add an instance declaration for (PrintfType Char)
06:20:08 <lambdabot>     In the expression: pr...
06:20:14 <Axman6> > printf "%d" 12 :: [Char]
06:20:15 <lambdabot>  "12"
06:20:18 <chr1s> basically, printf in Haskell is a big hack, not type-safe and definitely doesn't conform to "well typed programs don't go wrong"
06:20:30 <Axman6> heh
06:20:43 <chr1s> http://en.wikipedia.org/wiki/Cayenne_(programming_language)
06:20:48 <SamB_XP_> that one, anyway
06:20:51 <chr1s> now there's a nice printf
06:20:58 <vixey`> chr1s: there's a much better one
06:21:01 <mauke> we also have a printf in TH
06:21:15 <vixey`> ?go delimited continations Coq
06:21:15 <lambdabot> No Result Found.
06:21:19 <SamB_XP_> yeah, that one is typesafe ;-)
06:21:23 <vixey`> ?go printf delimited continations
06:21:24 <lambdabot> No Result Found.
06:21:27 <SamB_XP_> the TH one...
06:21:35 <mercury^> vixey`: continuations
06:21:41 <chr1s> Yeah, TH... sigh. ;)
06:21:53 <vixey`> chr1s: http://www.lri.fr/perso/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
06:21:55 <lambdabot> Title: GenuineShiftReset, http://tinyurl.com/2ywh6h
06:22:59 <chr1s> vixey`: nice!
06:23:28 <vixey`> "Find the type error in the following Haskell expression:. if null xs then tail xs else xs"
06:24:01 <mercury^> vixey`: no haskell type error in it
06:24:07 <mauke> xs is an Int
06:24:16 <mercury^> just a runtime exception
06:24:40 <chr1s> well, tail should be [a] -> Maybe a
06:24:43 <chr1s> err
06:24:47 <chr1s> [a] -> Maybe [a]
06:24:56 <Japsu> no it shouldn't >_>
06:24:56 <mauke> just use drop 1 instead
06:25:29 <mercury^> if anything it should be [a] -> [a] -> [a]
06:25:32 <mercury^> :>
06:25:44 <chr1s> mercury^: why?
06:25:54 <vixey`> :t head
06:25:56 <lambdabot> forall a. [a] -> a
06:26:02 <EvilTerran> tail should be :: (a -> b) -> b -> [a] -> b  :P
06:26:03 <mercury^> chr1s: so that you can provide a default in case the argument is null
06:26:07 <vixey`> safeHead :: List+ a -> a
06:26:11 <vixey`> data List+ where
06:26:13 <EvilTerran> er, ([a] -> ...)...
06:26:17 <vixey`>  End :: a -> List+
06:26:25 <vixey`>  Cons :: a -> List+ -> List+
06:26:27 <chr1s> mercury^: why not use Data.Maybe.maybe?
06:26:33 <EvilTerran> CPS FTW :)
06:26:54 <quicksilver> EvilTerran: ([a] -> b) -> b -> [a] -> b
06:26:54 <EvilTerran> mercury^, that's normally achieved using a combination of listToMaybe and fromMaybe/maybe
06:26:55 <mercury^> chr1s: because then the result is a Maybe List
06:27:02 <mercury^> ah
06:27:06 <EvilTerran> quicksilver, exactly. i did correct myself.
06:27:08 <vixey`> safeHead' :: (x :: [a]) -> a \/ x = []
06:27:15 <mauke> b -> (a -> [a] -> b) -> [a] -> b
06:27:42 <vixey`> unsafePerformHead (x:xs) = x
06:27:45 <quicksilver> EvilTerran: ah yes sorry
06:27:46 <EvilTerran> mauke: yay! i like that function
06:27:50 <chr1s> vixey`: exactly!
06:27:56 <vixey`> lel
06:27:58 <mauke> EvilTerran: woot
06:28:07 <EvilTerran> although i usually flip the first two parameters to be in line with the folds and scans
06:28:14 <mauke> the folds are wrong
06:28:18 <EvilTerran> meh
06:28:25 <EvilTerran> they're wrong, but they're standard
06:29:00 * EvilTerran struggles to not make a dirty joke about "unsafePerformHead"
06:29:31 <Japsu> unsafePerformDance
06:29:32 <mauke> import Protection
06:29:47 <EvilTerran> (:) could be called GiveHead :D
06:29:48 <vixey`> chr1s: You've seen the partiality and non-termination monads?
06:30:04 <SamB_XP_> tail should be : forall A (x : A) (xs xs' : list A) (xs = x :: xs'), A
06:30:05 <EvilTerran> vixey`, now that sounds interesting
06:30:17 <EvilTerran> SamB_XP_, what is that, Agda?
06:30:21 <SamB_XP_> Coq
06:30:22 <vixey`> EvilTerran: the math is *hard* but it's fantastically interesting
06:30:35 <EvilTerran> that's my favourite kind of math!
06:30:47 <EvilTerran> ...
06:30:47 <chr1s> vixey`: no, don't have time to delve in to it right now.
06:30:53 * EvilTerran just had a worrying thought
06:31:01 <chr1s> I've got to do my Generic Programming homework =)
06:31:11 <vixey`> SamB: hmmm
06:31:12 <EvilTerran> the idea "class Djinn a where djinn :: a" just popped into my head O.o
06:31:17 <vixey`> SamB: It's practically const
06:31:27 <EvilTerran> i have no idea of the practicality of that, but the very concept disturbs me
06:31:32 <vixey`> EvilTerran: I think Oleg DID that
06:31:42 <EvilTerran> ah. trust oleg.
06:31:51 <quicksilver> well, class Default a where default :: a is quite useful.
06:32:00 <EvilTerran> i could imagine that coming in quite useful, tho
06:32:03 <quicksilver> with a few TH rules to derive instances like
06:32:08 <vixey`> a nice one is class Inhabitants a where inhabitants :: [a]
06:32:09 <EvilTerran> swap :: (a,b) -> (b,a); swap = djinn
06:32:11 <SamB_XP_> vixey`: I realized as I was writing the type that the function was indeed pointless
06:32:19 <SamB_XP_> since you might as well just use "x"
06:32:21 <quicksilver> Default a, Default b => Default (a,b)
06:32:23 <mauke> quicksilver: that's a syntax error :-)
06:32:26 <SamB_XP_> if you already know all that
06:32:41 <mauke> EvilTerran: http://okmij.org/ftp/Haskell/types.html#de-typechecker
06:32:42 <lambdabot> Title: Haskell Programming: Types
06:32:43 <vixey`> SamB: I've been using this:
06:32:43 <vixey`>   Inductive listP : Type :=
06:32:43 <vixey`>   | nilP : A -> listP
06:32:43 <vixey`>   | consP : A -> listP -> listP.
06:32:46 <quicksilver> mauke: it was a shorthand :)
06:32:56 <vixey`> which makes things a lot easier
06:33:02 <vixey`> (in some cases)
06:33:04 <SamB_XP_> what the heck?
06:33:18 <SamB_XP_> oh, that's got Variable A : Type in it's section, right?
06:33:20 <mauke> http://hackage.haskell.org/packages/archive/data-default/0.2/doc/html/Data-Default.html
06:33:21 <vixey`> yes
06:33:22 <lambdabot> http://tinyurl.com/5bxgjp
06:33:36 <EvilTerran> @remember Oleg Essentially we turn a type into a logical program -- a set of Horn clauses -- which we then solve by SLD resolution. It is gratifying to see that Haskell typeclasses are up to that task.
06:33:36 <lambdabot> Done.
06:33:42 <SamB_XP_> I think you should have un-sectioned it for this audience ;-)
06:33:50 <EvilTerran> mauke, it's madness! madness, i tell you!
06:34:22 <SamB_XP_> EvilTerran: yes, it's wonderful the madness oleg is capable of
06:34:29 <SamB_XP_> that's what we keep him around for
06:34:38 <Axman6> hmm, i don't like that the java version of my app runs faster than haskell :\
06:35:36 * EvilTerran aspires to do stuff like that
06:35:51 <EvilTerran> "I made a sudoku solver in CPP macros!"
06:36:13 <EvilTerran> "... the haskell typesystem!" "... BF!" etcetc
06:36:13 <mauke> that's nothing, someone wrote a text adventure in CPP error directives
06:36:40 <quicksilver> I think compile-time sudoku solver in C++ templates is probably a better challenge.
06:37:00 <EvilTerran> quicksilver, yes, but then you have to use C++ templates. CPP macros are painful enough, thanks. :P
06:37:03 <mauke> should be easy
06:37:14 <quicksilver> TeX macros which both solve sudoku and generate an animation of the solution?
06:37:14 <jnordenberg> shouldnt be to hard if you use MPL library for example
06:37:22 <EvilTerran> i forget, can templates be parameterised by values as well as types?
06:37:25 <mauke> C++ templates even let you use ints directly
06:37:39 <quicksilver> yes EvilTerran
06:37:40 <EvilTerran> ah, that's a doddle, then
06:37:50 <mauke> so no need for S< S< S< Z > > >
06:38:55 <Axman6> i was going to try and write a sudoku solver in C or C++ i think. ended up trying to use a 9x9x9 array
06:39:30 <vixey`> shouldn't it be 3x3x3x3
06:39:49 <vixey`> > (9*9*9, 3*3*3*3)
06:39:49 * EvilTerran is always tempted to sit down sometime and draw as many symmetries out of it as he can
06:39:51 <lambdabot>  (729,81)
06:40:04 <EvilTerran> i suspect i may end up with a very multidimensional array of booleans
06:40:20 <Axman6> heh
06:40:31 <mauke> std::vector< std::vector< std::vector< bool > > >
06:41:06 <EvilTerran> my nearest-to-completed solver starts with "type Triple a = (a,a,a); type Box a = Triple (Triple a); type Board a = Box (Box a)"
06:41:22 <Axman6> vixey`: the way i was doing it was 3D, with a 9x9 array for each number 1-9
06:41:25 <EvilTerran> and then uses various transpose-esque functions to exploit the symmetries between boxes, rows, and columns
06:41:28 <Axman6> it didn't get very far
06:41:39 <EvilTerran> but i suspect there's also symmetries between those and, well, digits
06:41:43 <ziman> hmm :)
06:41:45 <vixey`> I had a great idea for a 4D version, but it turns out sudoku doesn't work that way
06:41:50 <ziman> sudoku solver in c++ templates?
06:42:03 <ziman> are they so powerful?
06:42:13 <EvilTerran> they're easily TC, from what i recall
06:42:27 <mauke> you get conditionals and recursion
06:43:07 <ziman> it'd be a challenge to write a compiler into c++ templates :)
06:43:35 <vixey`> isn't that what they're actually for?
06:43:48 <vixey`> (I haven't written C++ in years.)
06:43:50 <quicksilver> no compilers compiler *from* c++ templates
06:43:52 <quicksilver> not *to* them ;)
06:43:56 <quicksilver> generally.
06:44:01 <vixey`> oh I see
06:44:19 <jnordenberg> check out http://www.boost.org/doc/libs/1_35_0/libs/mpl/doc/index.html
06:44:20 <lambdabot> Title: Boost C++ Libraries - THE BOOST MPL LIBRARY
06:44:30 <jnordenberg> for some funky C++ template programming
06:45:55 <EvilTerran> quick, someone evil, write a YHC backend for C++ templates
06:46:27 * EvilTerran looks at his nick
06:46:31 <EvilTerran> darn, i guess that's my job
06:48:52 <Axman6> hmm, this should be a bug. something that compiles fine with ghc, but ghci gives a parse error
06:49:14 <EvilTerran> Axman6, bear in mind that ghci only does expressions, not declerations
06:49:38 <Axman6> it also didn't have an error in ghc 6.8.2
06:49:48 <joey_> Axman6: What're you trying to do?
06:49:50 <quicksilver> copy paste the code/error to hpaste
06:50:08 <curry> whats better for performance (i will be both indexing and copying alot), arrays or lists?
06:50:14 <Axman6> it's just one line: Graphics/Plot/BMP.hs:118:6: parse error on input `transColor'
06:51:08 <quicksilver> we need to see the code :P
06:51:16 <quicksilver> probably screwed up indentation
06:51:18 <quicksilver> or brackets
06:51:44 <Axman6> http://pastie.textmate.org/218822
06:51:45 <lambdabot> Title: #218822 by Alex Mason (Axman) - Pastie
06:51:48 <quicksilver> curry: indexing into a large list is slow, use array or Data.Sequence or Data.Map
06:52:07 <quicksilver> Axman6: implicit parameters are extremely evil.
06:52:17 <Axman6> not my code
06:52:18 <quicksilver> Axman6: your teacher is a bad, bad person.
06:52:28 <Axman6> he writes for GHC...
06:52:32 <quicksilver> its possible your own soul is in danger.
06:52:35 <Axman6> /codes
06:53:01 <vixey`> what's wrong with them?
06:53:09 <quicksilver> I imagine the error is just that implicit parameters are not enabled
06:53:14 <quicksilver> with is a flag or a LANGUAGE pragma
06:53:15 <vixey`> I didn't know they existed
06:53:26 <vixey`> how are the values aquired?
06:53:39 <curry> quicksilver: they lists would be small, just alot of them created, would indexing speed still matter?
06:53:59 <quicksilver> curry: it would matter much less.
06:54:04 <quicksilver> indexing very small lists is pretty fast.
06:54:16 <EvilTerran> curry, if the lengths of your lists are O(1), indexing is likewise :P
06:54:38 <quicksilver> vixey`: it's like a curioius kind of dynamic scoping.
06:54:44 <quicksilver> vixey`: there should be a section on it in the GHC manual.
06:55:00 <curry> EvilTerran: ah thanks, and yeah they never get bigger than 361 :)
06:55:07 <quicksilver> but they are mostly considered a failed experiment.
06:55:11 <jbapple> I had some trouble recently with a shell-like script I wrote in Haskell, and I think it was because of lazy file reads. Is there a standard way to read from files strictly?
06:55:26 <quicksilver> jbapple: no, and this is a very bad thing :(
06:55:27 <jbapple> EvilTerran: My computer is O(1) :-)
06:55:37 <quicksilver> jbapple: strict bytestring is probably the simplest hack
06:55:59 <curry> jbapple: make it print it all! jk :)
06:56:27 <jbapple> quicksilver: Will just using strict bytestring make file reads strict, or do I have to use evil deepSeq magic or something?
06:56:33 <Axman6> damn, i have wayyy too many tabs open
06:57:05 <quicksilver> jbapple: "readFile" from strict bystering is a strict read
06:57:14 <quicksilver> jbapple: so is getContents
06:57:20 <MoonPatrol> I think God hates me.
06:57:25 <Axman6> 64 bytes from 72.14.207.99: icmp_seq=0 ttl=234 time=3259.098 ms
06:57:25 <Axman6> 64 bytes from 72.14.207.99: icmp_seq=1 ttl=234 time=3793.908 ms
06:57:27 <Axman6> not cool
06:57:29 <jbapple> quicksilver: Thanks
06:59:08 <jbapple> Well, strict file read is my answer to http://shae.livejournal.com/46033.html
06:59:09 <lambdabot> Title: shae: Missing Haskell Libraries?
06:59:45 <jbapple> But I don't feel like registering for Yet Another Useless Account, so I'm not going to post a comment to that effect.
07:00:33 <nus> @hoogle bytex
07:00:34 <lambdabot> No matches found
07:03:56 <Saizan> dcoutts_: http://vezzosi.blogspot.com/2008/06/my-summer-of-code-project-dependency.html
07:03:57 <lambdabot> Title: Impredicative Graph: a dependency analysis framework for Cabal, http://tinyurl.com/6xqhah
07:04:08 <dcoutts_> @yarr!
07:04:08 <lambdabot> Prepare to be boarded!
07:06:21 <Saizan> tell me if it's readable :)
07:06:32 <dcoutts_> yeah it is readable :-)
07:06:39 <dcoutts_> but then I know what you're talking about
07:07:23 <dcoutts_> Saizan: hmm, the trace1 is empty
07:10:00 <jconnolly> Hi all, I don't know if this is common knowledge already, but seth kurtzberg (sethk) has passed away early this month.
07:10:14 <jconnolly> I know he was a regular in this channel and I thought I'd let the interested parties know.
07:10:38 <Zao> :(
07:10:49 <quicksilver> :(
07:10:51 <Saizan> dcoutts_: fixed, my emacs buffer wasn't in sync with the file system :)
07:10:58 <dcoutts_> :-)
07:11:43 <jconnolly> Yeah it's bad news.  He was a coworker of mine at buglabs (#buglabs) and we're planning something to do something in memoriam.
07:20:11 <nus> Saizan, the nodes in the DAG present exactly what?
07:20:55 <MoonPatrol> :-/
07:21:10 <MoonPatrol> I'd give my first born if any of you could tell me the name of a program to just browse all the memory on my computer.
07:21:27 <MoonPatrol> Not that anyone would WANT my first born...
07:21:38 <Axman6> cat /dev/mem
07:21:51 <Axman6> cat /dev/mem|less
07:22:00 <MoonPatrol> Axman6, haha, would be nice...... but think Microsoft.
07:22:09 <Axman6> i'd rather not
07:22:26 <MoonPatrol> Its the cruel world I am part of.
07:22:48 <Axman6> fight back
07:22:51 <Axman6> get a mac
07:22:52 <Axman6> >_>
07:22:59 <Saizan> nus: in general all the intermediate values needed to build the final targets
07:23:00 <mileswu2> # Appears as ANNA
07:23:24 <Axman6> ?
07:23:28 <xd> lol comic chat
07:23:47 <mileswu2> (#G010E010M1) indeed
07:23:58 <saml> MoonPatrol: i bet OS shoudl provide such functionality. userland programs probably can't picture entire memory.
07:24:34 <lilachaze> mileswu2: there's an option in the configuration somewhere to turn off the 'microsoft extensions'.
07:24:45 <MoonPatrol> Hmm, its not very clear to me then where this functionality is hidden
07:25:23 <lilachaze> mileswu2: View -> Options -> Settings -> Don't send Microsoft Chat specific information
07:25:56 <mileswu2> lilachze: oh yeah. got it. thanks
07:27:44 <saml> give us a haskell puzzle to spend a few minutes
07:28:15 <Axman6> saml: browse the contents of memory on windows
07:28:25 <quicksilver> that's not a haskell puzzle.
07:28:30 <quicksilver> It's a win32 API puzzle.
07:28:36 <vixey`> saml: generate pangrams from a dictionary
07:28:42 <Axman6> ah, but you need to turn it into one!
07:28:55 <MoonPatrol> hahahahhaa
07:29:12 <dcoutts_> Saizan: you should ask ibid about getting your blog on planet haskell
07:29:21 <lilachaze> saml: pick a puzzle from here and solve it: http://www.chiark.greenend.org.uk/~sgtatham/puzzles/
07:29:24 <lambdabot> Title: Simon Tatham's Portable Puzzle Collection
07:30:27 <lilachaze> for added fun, many of them are NP-complete
07:31:22 <saml> hrm panagrams seems hard. it should be well formed english sentence. though meaning can be awkward
07:33:06 <byorgey> dcoutts_: where's Saizan's blog?
07:33:32 <dcoutts_> byorgey: http://vezzosi.blogspot.com/
07:33:33 <lambdabot> Title: Impredicative Graph
07:33:39 <byorgey> cool, thanks
07:36:26 <Saizan> @seen ibid
07:36:26 <lambdabot> ibid is in #haskell. I last heard ibid speak 4h 9m 15s ago.
07:37:29 <BMeph> @seen Jesus
07:37:30 <lambdabot> I haven't seen Jesus.
07:37:38 <BMeph> Amen, sister. ;)
07:37:48 <ibid> Saizan: ?
07:38:52 <Saizan> ibid: i've started my blog on my gsoc project http://vezzosi.blogspot.com/
07:38:53 <lambdabot> Title: Impredicative Graph
07:39:15 <Saizan> ibid: can it be added to planet haskell?
07:40:48 <MoonPatrol> can i has cake
07:41:10 <ibid> Saizan: read the link in the sidebar
07:42:08 <ibid> Saizan: if you request by irc i'll just forget, so use email
07:43:27 <byorgey> @faq can i has cake
07:43:27 <lambdabot> The answer is: Yes! Haskell can do that.
07:43:27 <Saizan> ibid: ok, thanks :)
07:44:20 <MoonPatrol> @faq can haskell commit suicide and catch its own head in its hands?
07:44:21 <lambdabot> The answer is: Yes! Haskell can do that.
07:44:46 <byorgey> Saizan: wow, your GSoC project sounds really cool =)
07:45:12 <dcoutts_> byorgey: yes it is :-)
07:46:23 <Saizan> it is, but it's easy to get "distracted" by papers :)
07:48:00 * quicksilver waves a tempting treatise on unification under Saizan's nose and runs off cackling.
07:49:15 <HunterXHunter> @f can haskell fly to the moon?
07:49:15 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber figlet figlet' flush foldoc forecast forget fortune fptools free freshname ft . ? @ bf v
07:49:19 * Saizan holds tightly on his darcs repo to resist..
07:49:24 <HunterXHunter> @fag can haskell fly to the moon?
07:49:25 <lambdabot> The answer is: Yes! Haskell can do that.
07:49:54 <byorgey> Saizan: hehe, I totally understand =)
07:50:12 <MoonPatrol> @floopydoopydooo can haskell eat poo?
07:50:13 <lambdabot> Unknown command, try @list
07:50:25 <MoonPatrol> :-(
07:50:51 <HunterXHunter> @faggot can haskell make faggots?
07:50:51 <lambdabot> Unknown command, try @list
07:50:54 <HunterXHunter> :(
07:50:55 <byorgey> MoonPatrol: it corrects command names that are within an edit distance of 3
07:51:12 <MoonPatrol> oh okay
07:53:46 <dcoutts_> hia pgavin
07:53:50 <pgavin> dcoutts_: hi
07:54:18 <dcoutts_> pgavin: sorry about sending you a pile of patches just before you release. Feel free to ignore them 'til after the release.
07:54:41 <dcoutts_> or select the ones you want or whatever
07:55:55 <pgavin> dcoutts_: eh, no biggie, they're not big ones
07:56:17 <dcoutts_> pgavin: did you see the pic of the transparent clock? it's rather nice :-)
07:56:36 <noecksit> does anyone know if "readTChan" from Control.Concurrent.STM.TChan blocks when there is nothing on the channel?
07:56:51 <pgavin> dcoutts_: no, not yet, is there a screenshot somewhere?
07:56:55 <dcoutts_> pgavin: or if you're running a composite manager you can try it yourself
07:57:06 <pgavin> dcoutts_: ah, ok
07:57:20 <dcoutts_> pgavin: here: http://haskell.org/~duncan/gtk2hs/Clock.png
07:58:03 <pgavin> dcoutts_: nice :)
07:58:42 <pgavin> dcoutts_: is the clock face just an svg?
07:59:16 <dcoutts_> pgavin: notice how it's not just a simple circle, but there is actually a drop shadow. So it's translucency not just a shaped window.
07:59:19 <dcoutts_> though for control purposes I should also set a mask so that clicks outside the clock (but within the bounding box and drop shadow) go to the window behind
07:59:45 <pgavin> right
08:00:09 <joey_> I'm surprised you're bothered about aesthetics with a desktop like that :P
08:00:17 <dcoutts_> pgavin: it's rendered using cairo
08:00:25 <dcoutts_> pgavin: so it's all haskell code, no svg
08:00:32 <dcoutts_> joey_: heh
08:00:32 <pgavin> dcoutts_: ok
08:01:16 <dcoutts_> joey_: you don't think I use that clock myself do you? it's just for showing off. ;-)
08:01:22 <joey_> Hehe
08:01:44 <joey_> It's very pretty.
08:02:47 <Saizan> noecksit: yes, in particular it calls retry
08:06:27 <litb> hello all
08:06:35 <mar77a> greetings
08:07:00 <pgavin> dcoutts_: so there's really no problem with xulrunner, then, right?
08:07:14 <dcoutts_> pgavin: not as far as I'm aware
08:07:30 <dcoutts_> pgavin: but I've not tried building it with ff3 or the new xulrunner release
08:07:35 <pgavin> dcoutts_: ok, just wanted to make sure
08:07:46 <pgavin> dcoutts_: I've built with older xulrunners
08:07:50 <dcoutts_> pgavin: aye
08:07:50 <pgavin> but not ff3 either
08:08:23 <pgavin> but I thought the point of xulrunner was because they were dropping supprt in firefox?
08:08:28 <pgavin> or something like that
08:12:20 <dcoutts_> pgavin: yeah I think that's right. On the other hand they've improved the support for xulrunner. there's a xulrunner 1.9 release out which is basically the FF3 code as I understand it.
08:12:50 <pgavin> ah, ok
08:13:07 <byorgey> hi litb, long time no see =)
08:13:07 <pgavin> well, I'll try and test against that before the release
08:14:46 <litb> =) ya!
08:16:31 <marcot> dcoutts_: I've built a new debian package for gtk2hs, but I can't get the fastdraw example to run, and I don't know if it's a problem in the package.  I get:
08:16:39 <marcot> fastDraw: gtk/Graphics/UI/Gtk/Gdk/PixbufData.hs.pp:58:0: No instance nor default method for class operation Data.Array.Base.getNumElements
08:16:47 <marcot> I compile it ok, but get this message in execution.
08:17:35 <dcoutts_> marcot: yep, that was a bug in the 0.9.12 release. I'm pretty sure it's fixed in the current version.
08:17:48 <dcoutts_> marcot: so it should be in the release that pgavin is working on.
08:18:00 <marcot> dcoutts_: ok. =)
08:18:18 <dcoutts_> marcot: so you might want to hold on a day or so until the new release
08:19:18 <marcot> dcoutts_: ok, the package is done, so I think it worth uploading.  When the next version is released I can work on it too.
08:20:15 <dcoutts_> marcot: 'k
08:22:03 <marcot> dcoutts_: Is there a repeated example?  graphic seems to be the same as cairo/Drawing.hs
08:22:03 <nus> Saizan, care to elaborate how do you break cycles in targets?
08:23:44 <dcoutts_> marcot: they are implemented differently. It shows the same visual output but they're examples of the different drawing APIs underneath.
08:24:25 <dcoutts_> nus: I'm not aware that we need to break cycles. So long as we can detect cycles and report the error that's ok.
08:25:10 <dcoutts_> nus: there are no genuine cycles in any valid system afaik, not even with cyclic module deps
08:25:16 <marcot> ok..
08:26:20 <paolino> Saizan, I don't see the multistate rules in the project , are you planning to not have them ?
08:26:49 <nus> dcoutts_, uhmm, I know near nothing about Haskell modules, but weren't they allowed to import one another?
08:27:03 <dcoutts_> nus: yes.
08:28:01 <dcoutts_> nus: but look at what the implementations do, for jhc it takes all the modules in one go. So no cycled there. hugs and nhc do not support module cycles. GHC allows cycles with .hs-boot files, so again, no cycles in build actions.
08:28:54 <malcolmw> nhc98 supports module cycles, with a hand-written .hi file to bootstrap
08:29:18 <malcolmw> almost exactly like ghc's .hs-boot files
08:29:36 <nus> oh, right, no directed cycles.
08:30:02 <dcoutts_> malcolmw: oh, my mistake
08:30:04 <quicksilver> I remain unconvinced that module cycles represent a useful place in the design space.
08:30:19 <marcot> dcoutts_: Bad news, it seems that it's searching for libxul.so in the wrong place.
08:30:20 <dcoutts_> quicksilver: it'd be ok if they were a bit easier to use
08:30:34 <malcolmw> hhc, also known as Freja, allows cyclic modules provided they live in the same file
08:30:37 <marcot> ./testembedmoz: error while loading shared libraries: libxul.so: cannot open shared object file: No such file or directory
08:30:54 <marcot> It's at /usr/lib/xulrunner-1.9/libxul.so
08:30:58 <dcoutts_> marcot: check what pkg-config --libc reports for xulrunner
08:31:03 <dcoutts_> erm --libs
08:31:48 <marcot> For xulrunner nothing.  For libxul:
08:31:52 <marcot> -L/usr/lib/xulrunner-devel-1.9/lib -lxpcomglue_s -lxul -lxpcom -lplds4 -lplc4 -lnspr4 -lpthread -ldl
08:32:31 <dcoutts_> marcot: if /usr/lib/xulrunner-1.9 is not on the standard linker path (and it almost certainly is not) then pkg-config --libs xulrunner-gtkmozembed should report -rpath /usr/lib/xulrunner-1.9
08:33:14 <marcot> -L/usr/lib/xulrunner-devel-1.9/lib -lxpcomglue_s -lxul -lxpcom -lplds4 -lplc4 -lnspr4 -lpthread -ldl
08:33:19 <quicksilver> dcoutts_: that's not really my point.
08:33:21 <marcot> This is what mozilla-gtkmozembed returns.
08:33:29 <quicksilver> dcoutts_: I don't have a strong opinion in whether they should be hard to use.
08:33:37 <dcoutts_> marcot: if not it's borken. The expectation with pkg-config is that for a C prog you can do: gcc `pkg-config --cflags --libs pkg` foo.c && ./foo and expect to have it work. If not it's the package fault, not our fault.
08:33:41 <quicksilver> dcoutts_: irrespective of that I'm not sure they *should* be used.
08:34:58 <marcot> dcoutts_: I'm build the package with --enable-mozilla, not --enable-xulrunner.  Hum, but I think the problem is with rpath.
08:35:12 <dcoutts_> marcot: if pkg-config does not tell us the right flags to be able to use the package, then there's not a lot we can do. We can hardly go around guessing where things might be. That's the whole point of pkg-config, so that build systems don't have to do hacky stuff and have lots of system-specfic knowledge..
08:35:46 <marcot> http://lists.debian.org/debian-release/2008/05/msg00009.html
08:35:48 <lambdabot> Title: Status update for xulrunner 1.9 - maintainers, we need you
08:35:48 <dcoutts_> marcot: ok, pkg-config --cflags --libs mozilla-gtkmozembed then
08:35:49 <paolino> Saizan: without multistate rules , it will be hard to rollback the graph per rule
08:36:16 <marcot> This is about the new xulrunner-dev package in debian, it says that people should not use rpath with it.
08:36:52 <marcot> -fshort-wchar -I/usr/include/xulrunner-1.9/unstable -I/usr/include/nspr  -L/usr/lib/xulrunner-devel-1.9/lib -lxpcomglue_s -lxul -lxpcom -lplds4 -lplc4 -lnspr4 -lpthread -ldl
08:38:41 <dcoutts_> marcot: I see. Well we need to know how it's expected to work in that case.
08:39:36 <dcoutts_> marcot: it also says you should be using mozilla-gtkmozembed-embedding.pc
08:40:10 <marcot> dcoutts_: Sorry, I haven't seen this.
08:40:11 <marcot> Thanks.
08:40:50 <dcoutts_> marcot: I've no idea how they expect it to work without using rpath or the path being on the standard linker path
08:41:14 <dcoutts_> do they think everything has to use wrapper scripts? if so how are they supposed to find the path to use?
08:42:03 <marcot> dcoutts_: if I started using libxul-embedding.pc or mozilla-gtkmozembed-embedding.pc won't it work?
08:42:42 <dcoutts_> marcot: I doubt it. If none of them are using rpath I can't see how it can work.
08:42:49 <marcot> I'm sorry, I don't know a lot of linking/autoconf stuff.
08:43:47 <orzo> hello
08:44:11 <orzo> I want a bit array data structure that is run-length compressed
08:44:14 <orzo> is there one?
08:44:54 <dcoutts_> marcot: the key test case is the C mozembed test prog. If it works to: gcc `pkg-config --cflags --libs mozilla-gtkmozembed-embedding` gtkmozembed-test.c -o gtkmozembed-test && ./ gtkmozembed-test  then the gtk2hs component will also work. If that does not work then the gtk2hs stuff will also not work.
08:45:21 <dcoutts_> marcot: the thing you need to find out from the debian packagers is, if the above does not work, how are we expected to make stuff work?
08:45:29 <marcot> dcoutts_: where can I get this test?
08:49:30 <mc__> is TDD a common haskell practice?
08:51:38 <Taggnostr> is there a way to execute one or more haskell commands from the console doing something like "haskell -something 'commands here'" ?
08:53:04 <mjrosenb> Taggnostr: echo 'commands' | ghci
08:53:23 * mjrosenb guesses there's a prettier way to do that
08:53:36 <paolino> ghci -E ?
08:55:15 <Taggnostr> nice
08:55:24 <Taggnostr> now I just have to install ghci :D
08:56:17 <Deewiant> it's ghc -e actually
08:56:22 <paolino> mmhh , and read the manual the -E is wrong
08:56:26 <mjrosenb> mine works with hugs :-p
08:58:59 <dcoutts_> marcot: http://hpaste.org/8439
08:59:19 <Taggnostr> which version do I have to install among these: http://www.haskell.org/ghc/download_ghc_641.html#x86linux ? I have ubuntu
08:59:19 <lambdabot> Title: GHC: Download version 6.4.1
09:00:10 <Taggnostr> I usually use apt-get but I can't find ghc there
09:00:19 <dcoutts_> marcot: that's the test case. So the xulrunner packaging people need to tell us what to do. As far as I am concerned we're using the system in the way it was designed to work.
09:01:04 <byorgey> Taggnostr: you can apt-get install ghc6 to get version 6.6; however, I would recommend getting version 6.8.2
09:01:15 <marcot> dcoutts_: I'll lunch, and then I'll try to build it.  Thanks for the help.
09:01:26 <byorgey> 6.4.1 is quite old at this point
09:01:47 <Taggnostr> is there an easy way to install 6.8.2?
09:02:37 <byorgey> sure, there are actually debian/ubuntu packages somewhere, just a second and I can give you a link
09:04:45 <byorgey> hmm, I know someone had made them...
09:05:05 <maltem> Doesn't latest Ubuntu have ghc 6.8.something in its repositories?
09:05:21 <Taggnostr> is there a way to check?
09:05:44 <byorgey> maltem: oh, maybe in a cutting-edge version
09:05:58 <Taggnostr> from add/remove application I wasn't able to find anything related to haskell or ghc
09:06:03 <byorgey> Taggnostr: you can also just download a binary from http://www.haskell.org/ghc/download_ghc_682.html#binaries
09:06:04 <lambdabot> Title: GHC: Download version 6.8.2
09:06:20 <byorgey> Taggnostr: do you have the universe repository enabled?
09:06:22 <Axman6> my uni is still using 6.4.1
09:06:35 <byorgey> Axman6: yeesh, sorry to hear that =P
09:06:37 <Taggnostr> byorgey, I don't know
09:06:45 <byorgey> Taggnostr: if you don't know then you probably don't =)
09:06:47 <Axman6> luckily i do all my work on my laptop
09:06:50 <mjrosenb> and 6.8.3 is out :-)
09:06:58 <Axman6> i know, i have it installed :)
09:07:02 <maltem> Taggnostr: http://packages.ubuntu.com/hardy/ghc6 -- 6.8.2 is in Hardy
09:07:03 <lambdabot> Title: Ubuntu -- Details of package ghc6 in hardy
09:07:42 <maltem> byorgey: Well in the latest LTS version
09:07:51 <Taggnostr> with ghc6 I've found something, but I don't know the version
09:08:55 <byorgey> maltem: ah, cool
09:09:00 <byorgey> I haven't upgraded yet
09:09:43 <byorgey> Taggnostr: if you have hardy, ghc6 will be 6.8.2, otherwise it is probably 6.6.1
09:09:55 <byorgey> either is fine if you are just learning Haskell
09:10:24 <Taggnostr> I'll try to install it and see, probably it's not a big problem if I don't have the latest version
09:10:31 <byorgey> yeah, it should be fine
09:10:43 <byorgey> you can always upgrade later if you want =)
09:11:16 <Taggnostr> 6.8.2
09:11:28 <byorgey> excellent =)
09:12:26 <Gwern-away> hee hee. another cabal thread where I've already filed the bug report/feature request
09:12:39 <byorgey> gwern: hm?
09:12:50 <dcoutts_> gwern: heh, which one this time?
09:13:01 <dcoutts_> gwern: it's a useful way to figure out which are the important ones :-)
09:13:27 <gwern> dcoutts_: distcheck
09:14:59 <dcoutts_> gwern: ah yes, that would be useful
09:15:08 * gwern supplied my full set of shell functions/aliases this time, for posterity
09:17:04 <maltem> I've been wondering, would the GHC api, at least in theory, be usable for writing a Haddock variant that is aware of function types?
09:20:23 <Taggnostr> why ghci -e 'do { 3*3 }' doesn't work?
09:20:42 <gwern> > 4 * 7
09:20:45 <lambdabot>  28
09:20:57 <Taggnostr> > do { 3*3 }
09:20:58 <lambdabot>   add an instance declaration for (Num (t t1))
09:21:06 <gwern> Taggnostr: because your request is totally messed up and misunderstands what ghci does, imo
09:21:54 <Taggnostr> probably, but I'm trying to do something like that function of lambdabot
09:21:56 <maltem> Taggnostr: because 3*3 cannot appear as a line in a do-block
09:22:55 <gwern> Taggnostr: in that case, do 'ghci -e "3*3"'
09:23:01 <Taggnostr> with print works
09:23:08 <gwern> or ghc -e, it's more or less the same in that circumstance
09:23:45 <Taggnostr> ok
09:23:57 <mc__> is TDD common in haskell land?
09:24:20 <gwern> mc__: we go in more for TDD, that is, Type Driven Development :)
09:24:40 <gwern> although folk like dons are fond of defining their types and then writing a bunch of QuickCheck properties, 'tis true
09:24:49 <maltem> or property-driven development a la quickcheck, smallcheck
09:25:04 <dcoutts_> mc__: yes, both type driven and test drive, but we more often call it property driven or specification driven.
09:25:24 <mc__> thanks for your answers
09:25:51 <dcoutts_> mc__: instead of laboriously writing lots of tests it's better to write an executable specification and use that to generate test cases.
09:27:50 <maltem> @check \x -> (x :: Integer) == negate (negate x)
09:27:52 <lambdabot>  OK, passed 500 tests.
09:28:36 <maltem> (We really need type annotations in patterns for @check)
09:29:05 <Taggnostr> what is the right way to do something like "do { let f n = n*2; f 5; }" ?
09:29:39 <maltem> Taggnostr: throwing "do" away
09:29:46 <ddarius> Taggnostr: Why do you want to write 'do' around everything?
09:29:48 <maltem> and use let ... in ...
09:30:54 <Taggnostr> because let f n = n*2; f 5; complains about a ;, and I thought that do {} is used to group several ;-delimited expressions
09:31:08 <Taggnostr> > let f n = n*2; f 5;
09:31:09 <lambdabot>  Parse error at ";" (column 19)
09:31:15 <ddarius> Taggnostr: No, that is not what 'do' is for.
09:31:21 <dcoutts_> Taggnostr: you're not running commands, you're evaluating expressions
09:31:23 <maltem> Taggnostr: again, use let ... in ...
09:31:35 <Taggnostr> > let f n = n*2 in f 5
09:31:36 <lambdabot>  10
09:31:55 <Taggnostr> ok, this make sense
09:32:08 <Taggnostr> what if I want to call f several times?
09:32:15 <Taggnostr> > let f n = n*2 in f 5; f 15
09:32:15 <lambdabot>  Parse error at ";" (column 21)
09:32:32 <quicksilver> "call f several times" doesn't make any sense
09:32:34 <quicksilver> why would you do that?
09:32:35 <dcoutts_> Taggnostr: remember you're constructing a result, not just calling things
09:32:42 <quicksilver> what is the point of the first call to f.
09:32:54 <Taggnostr> indeed
09:33:01 <quicksilver> let f n = n * 2 ; im_not_going_to_use_this = f 5 in f 15
09:33:05 <quicksilver> is sort-of what you want
09:33:12 <quicksilver> but the 'f 5' won't actually ever get called
09:33:14 <quicksilver> because there is no point.
09:33:41 <dcoutts_> Taggnostr: if you want to construct a pair as a result you can do that:
09:33:41 <dcoutts_> > let f n = n*2 in (f 5, f 15)
09:33:43 <lambdabot>  (10,30)
09:34:07 <quicksilver> or indeed a list.
09:34:17 <quicksilver> or add them together, or do mostly anything :)
09:34:30 <dcoutts_> that's just one way of combining the two values. there are many others and which one depends on what result you want.
09:35:20 <dcoutts_> Taggnostr: point is, it's "value oriented" programming, not sequences of instructions. You're constructing some result value. That's what the whole program is.
09:35:22 <Taggnostr> ok, now is working, I just forgot to switch my mind to functional programming :P
09:36:56 <marcot> dcoutts_: I got the same error message with the C test.
09:37:07 <dcoutts_> marcot: right.
09:37:08 <osfameron> Set phasers to 'Monad'
09:37:16 <marcot> dcoutts_: I'll try to get in touch with the xulrunner-dev maintainer.
09:37:21 <dcoutts_> marcot: thanks
09:38:44 <pjdelport> set IOs to "unsafePerform"
09:39:26 <osfameron> pjdelport: heh, that's better
09:40:33 <Taggnostr> I did let fact 0 = 1; fact n = n * fact (n-1) in fact 10 \o/
09:41:13 <saml> or, product 10
09:41:19 <saml> > product 10
09:41:20 <lambdabot>   add an instance declaration for (Num [a])
09:41:42 <saml> > product [1..10]
09:41:43 <lambdabot>  3628800
09:45:13 <Taggnostr> let fact [x] = x; fact (x:xs) = x * fact xs in fact [1..10]
09:45:24 <nolrai_> @hoogle [a] -> bool
09:45:25 <lambdabot> Did you mean: [a] -> Bool
09:45:25 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
09:45:25 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
09:45:32 <nolrai_> @hoogle [a] -> Bool
09:45:33 <lambdabot> Prelude.null :: [a] -> Bool
09:45:33 <lambdabot> Data.List.null :: [a] -> Bool
09:45:33 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
09:45:42 <vixey`> hi monochrom
09:45:48 <monochrom> hi vixey`
09:47:25 <Taggnostr> why let n = [1..n]; fact [x] = x; fact (x:xs) = x * fact xs in fact (n 10) doesn't work?
09:47:53 <monochrom> n = [1..n]  is very confused
09:48:05 <vixey`> Taggnostr: what does 'doesn't work' mean?
09:48:13 <Taggnostr> ops, I forgot a part
09:48:36 <Taggnostr> n x = [1..x]
09:48:51 <Taggnostr> (even if doesn't really make sense, I'm just playing around)
09:49:09 <monochrom> n x = [1..x] is good.
09:49:50 <monochrom> > let {n x = [1..x]; fact [x] = x; fact (x:xs) = x * fact xs} in fact (n 10)
09:49:51 <lambdabot>  3628800
09:49:54 <monochrom> works
09:50:08 <vixey`> > product [1..10]
09:50:10 <lambdabot>  3628800
09:50:48 <byorgey> > product [1..100]
09:50:49 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
09:50:50 <Axman6> ompetition time: who can create the most convoluted factorial function.
09:50:56 * byorgey hugs Integer
09:51:01 <vixey`> Axman6: I can!
09:51:08 <Axman6> go for it
09:51:19 <mc__> > product [1..31234234234234]
09:51:21 <pjdelport> @go evolution of a haskell programmer
09:51:22 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
09:51:22 <lambdabot> Title: The Evolution of a Haskell Programmer
09:51:28 <pjdelport> Axman6: -^
09:51:32 <lambdabot> Terminated
09:51:38 <byorgey> > let fact n = fix ((1:) . scanl (*) 1) !! n  in n 10
09:51:39 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Expr'
09:51:54 <byorgey> > let fact n = fix ((1:) . scanl (*) 1) !! n  in fact 10
09:51:55 <lambdabot>  1
09:52:00 <byorgey> heh, oops =)
09:52:08 <vixey`> Axman6: http://thepastesiteat.endoftheinternet.org:8080/paste/3
09:52:23 <byorgey> > let fact n = fix ((1:) . scanl (*) 2) !! n  in fact 10
09:52:24 <lambdabot>  36028797018963968
09:52:25 <Taggnostr> yep, I saw the evolution of the haskell programmer :P
09:52:40 <nolrai_> type system factorials ftw!
09:52:49 <vixey`> umm
09:52:59 <byorgey> > let fact n = fix ((1:) . scanl1 (*)) !! n  in fact 10
09:53:00 <lambdabot>  1
09:53:01 * vixey` just realized that code actually does fibs not factorial....
09:53:25 <vixey`> in any case, it's convoluted enough that nobody would have noticed :)
09:54:35 <nolrai_> throwError "error" `mplus` return 2
09:54:38 <nolrai_> > throwError "error" `mplus` return 2
09:54:39 <lambdabot>   add an instance declaration for (MonadError [Char] m)
09:55:01 <nolrai_> > throwError "error" `mplus` return 2 :: Either String Int
09:55:03 <lambdabot>  Right 2
09:55:10 <nolrai_> nice
09:57:34 <Axman6> vixey`: wow.. that's.. i want to go home now
09:57:47 <vixey`> "go home" means what?
09:58:04 <vixey`> (where are you now?)
09:58:10 <byorgey> go home and learn more Haskell? =D
09:58:14 <vixey`> hehe
09:58:36 <vixey`> (the code exists because I was testing some ideas I had about lazy io...)
09:58:39 <Axman6> i'm home, luckily
09:58:55 <vixey`> I don't know this term of phrase
09:59:46 <vininim> something related to cartman from southpark? "Screw you guys, I'm going home"
10:00:26 <Axman6> oh, i meant it to mean something like "i don't like this game anymore, i don't want to play"
10:00:37 <vixey`> ahh
10:00:41 <vininim> exactly.
10:00:47 <vixey`> sorry :P
10:01:03 <vixey`> Axman: if it helps I ended up with something simpler, inspired by Cale
10:01:24 <vixey`> -- <Cale>   ReturnIO :: a -> IO a
10:01:24 <vixey`> -- <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
10:01:24 <vixey`> -- <Cale>   GetChar :: IO Char
10:01:24 <vixey`> -- <Cale>   PutChar :: Char -> IO ()
10:01:24 <vixey`> -- <Cale>   ForkIO :: IO a -> IO ThreadID
10:01:28 <vixey`> that's all you really need
10:01:52 <vixey`> (pure) data which has the same signatures as IO primitives
10:02:15 <Axman6> what's Cale?
10:02:18 <Axman6> or who...
10:02:47 <vixey`> :t (.)
10:02:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:03:35 <ziman> Cale is the one who defined (.) as fmap :P
10:04:21 <Axman6> i should go to bed, it's 3am
10:06:23 <Taggnostr> > :t (.)
10:06:24 <lambdabot>   parse error on input `:'
10:06:46 <Taggnostr> why here I get (.) :: (b -> c) -> (a -> b) -> a -> c ?
10:07:00 <vixey`> Taggnostry: you have a different definition of (.)
10:07:10 <Taggnostr> :O!
10:07:23 <ziman> @src (.)
10:07:23 <lambdabot> (f . g) x = f (g x)
10:07:23 <lambdabot> -- In lambdabot, it's been generalised to:
10:07:23 <lambdabot> (.) = fmap
10:07:27 <vixey`> > (+1) . Just 3
10:07:30 <lambdabot>  Just 4
10:07:43 <vixey`> that's the kind of thing . = fmap gives you
10:07:46 <ziman> Taggnostr, it's lambdabot's specialty
10:07:58 <vixey`> ziman: anyone can use it.. I use it sometimes..
10:08:09 <sjanssen> it is EEVIL!
10:08:49 <ziman> vixey`, i mean it's not in the standard libs that way (or is it?)
10:08:57 <vixey`> not in the standard li
10:09:13 <Taggnostr> is @src (.) a special function? can I do it from ghci?
10:09:25 <vixey`> install lambdabot hten you can
10:09:29 <vixey`> ?where lambdabot
10:09:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:09:38 <vixey`> it's called ghci on acid or something
10:10:00 <yav> you can also use :list in ghci
10:10:51 <psnively> Testing...
10:10:54 <Axman6> eh, another unsw project
10:11:08 <sjanssen> vixey`: don't recommend that newbies install lambdabot -- it is a major pain even for those that know their way around the Haskell toolchain :)
10:12:21 <vixey`> hi psnively!
10:12:37 <vixey`> sjanssens: you know that's weird I heard a lot of people say that but for me lambdabot was easy to install
10:12:58 <vixey`> (of course there's been things which were easy for everyone except me to install..)
10:13:12 <psnively> Hi Vixey. Thanks for the response. :-)
10:13:21 <vixey`> psnively, I suggest you bin colloquy :P
10:13:25 <sclv_> wao. just built ghc in ~35 minutes or less with my new 4 core box.
10:13:37 <psnively> Vixey, what do you like better?
10:13:54 <Axman6> "cpuperf toggle the cpu frequency on OpenBSD systems between 0 and 100%."
10:14:00 <Axman6> i'm not sure i want that :|
10:14:03 <Axman6> psnively: irssi
10:14:05 <vixey`> psnively, xchat isn't very good but I think it has less bugs.. so that's what I use
10:14:12 <Axman6> colloquy is fail
10:14:27 <Axman6> webkit is awesome, but not for something as simple as IRC
10:15:31 <Taggnostr> so, I did the factorial in 3-4 different ways, what's next?
10:15:39 <psnively> Irrsi, hmmm.
10:15:54 <paolino> Taggnostr: fibonacci
10:15:54 <Axman6> gui irc clients ftl
10:16:12 <Axman6> Taggnostr: then fast fourier transform
10:16:22 <rumbleca> project euler>
10:16:23 <gwern> vixey`: don't recommend GOA. it is broken, and has been for something on the timescale of years now
10:16:33 <Taggnostr> :\
10:16:45 <rumbleca> Taggnostr: look at project euler
10:16:46 <gwern> Axman6: cpuperf is interesting for its sudo monad
10:16:58 <vixey`> gwern: :(
10:17:02 <gwern> it's not a secure sudo monad, alas, but it's an interesting monad example
10:17:04 <Taggnostr> yes, I know it, I could try it
10:17:13 <vixey`> gwern: I think the bits should be added to ghci..
10:17:29 <vixey`> (Possibly fixed first)
10:17:43 <gwern> vixey`: so study it and send patches, don't ensnare noobs
10:18:03 <vixey`> you they actually take patches from me though?
10:18:35 <Axman6> Taggnostr: you could write a function that calculates where f(x) crosses y=0 using newton's method
10:18:43 <Axman6> that would be a fun one
10:18:46 <gwern> vixey`: if the patches are good, why not? did you molest their text editor or something?
10:18:59 <Taggnostr> if only I knew math good enough
10:19:35 <Axman6> x1 = x0 - f(x0)/f'(x0)
10:19:39 <Axman6> i hope...
10:19:47 <Axman6> if not, i screwed up my exam today
10:20:17 <Axman6> hmm, the hard part woud be finding f'(x)
10:20:44 <Axman6> i guess you could have it take x f f'
10:21:14 <vixey`> anyway I stilled installed lambdabot with no trouble at all and it works fine...
10:21:15 <Axman6> and you do that until it eqlaus 0
10:22:14 <gwern> vixey`: a recent lambdabot?
10:22:19 <gwern> there've been quite a few patches in the last few weeks
10:22:32 <vixey`> no it was about a month or something
10:22:39 <vixey`> I just wanted to test a plugin I wrote for it
10:23:19 <gwern> plugins, eh
10:23:34 * gwern begins writing some XMC extensions to make xmonad work as an IRC bot
10:24:10 <byorgey> @go haskell automatic differentiation
10:24:11 <lambdabot> No Result Found.
10:24:17 <byorgey> @go automatic differentiation
10:24:18 <lambdabot> http://en.wikipedia.org/wiki/Automatic_differentiation
10:26:35 <Axman6> or you could use that
10:29:27 <chessguy_> @go conal differentiation
10:29:28 <lambdabot> http://conal.net/blog/posts/beautiful-differentiation/
10:29:28 <lambdabot> Title: Conal Elliott  Blog Archive  Beautiful differentiation
10:30:06 <sjanssen> @quote qwe1234
10:30:06 <lambdabot> qwe1234 says: oh come on, what do 'functional languages' have to do with lambda calculus?
10:30:08 <sjanssen> @quote qwe1234
10:30:09 <lambdabot> qwe1234 says: i know and program in more languages than can fit in your short-term memory, ok?
10:30:13 <sjanssen> @quote qwe1234
10:30:13 <lambdabot> qwe1234 says: check out 'complexity theory', it's all there.
10:30:15 <sjanssen> @quote qwe1234
10:30:16 <lambdabot> qwe1234 says: good developers will write good code in absolutely any language, while bad developers will develop crap no matter the tools they use.
10:30:16 <byorgey> http://www.haskell.org/haskellwiki/Functional_differentiation
10:30:17 <lambdabot> Title: Functional differentiation - HaskellWiki
10:30:55 <ziman> is qwe1234 real or fictitious? :)
10:31:13 <Korollary> real
10:31:21 <Korollary> painfully
10:31:29 <sjanssen> ziman: http://www.reddit.com/info/6o4yi/comments/c04f1nl real sighting in the wild
10:31:29 <lambdabot> Title: reddit.com: "GHC doesn't even break a sweat with a million threads"
10:34:03 <Axman6> ice
10:34:07 <Axman6> nice even
10:34:07 <myname_> hello!
10:34:20 <Axman6> how's that copmpare to erlang?
10:34:49 <psnively> qwe1234 knows a lot and understands nothing, as far as I can tell.
10:35:04 <gmosx> I am a newbie, may I ask a question?
10:35:20 <sjanssen> gmosx: we insist you ask a question!
10:35:27 <gmosx> sjanssen: thanks...
10:35:38 <ziman> :)
10:35:43 <chessguy> newbies are our friends!
10:35:45 <sjanssen> psnively: this is a good description
10:35:52 <gmosx> I want to create a UTCTime value from an Int representing a time from epoch
10:36:00 <gmosx> but I cannot find a suitable constructor
10:36:03 <psnively> sjanssen: thank you. :-D
10:36:04 <gmosx> any idea?
10:36:18 <chessguy> gmosx:  sorry, that's not newbie enough :)
10:36:21 <saml> @hoogle UTCTime
10:36:22 <lambdabot> Data.Time.Clock.UTCTime :: data UTCTime
10:36:22 <lambdabot> Data.Time.Clock.UTCTime :: Day -> DiffTime -> UTCTime
10:36:22 <lambdabot> Data.Time.Clock.POSIX.utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
10:36:49 <gmosx> chessguy: still this is my question ;-)
10:37:24 <gmosx> I am using HDBC to select a date column, it returns the date in seconds from epoch, I need a UTCTime value.
10:38:39 <ToRA> secondsToDiffTime, then create a UTCTime representing epoch and add them?
10:38:40 <gmosx> in fact HDBC returns SqlEpochTime a
10:39:05 <audreyt> extremely simple cabal question. suppose I have library Text.Foo under package "foo" and an executable "runfoo".
10:39:16 <audreyt> is there a way in .cabal to specify that runfoo is to be linked with the freshly-built foo package
10:39:27 <sjanssen> audreyt: nope
10:39:29 <audreyt> instead of having it recompile Text.Foo?
10:39:29 <byorgey> audreyt: sadly, no =(
10:39:30 <gmosx> ToRA: I understand Data.Time is the suggested package instead of System.Time and/or NewTime, am I right?
10:39:50 <gmosx> ToRA: how can I create an UTCTime representing epoch?
10:39:55 <audreyt> slightly less simple cabal question. where do I hack to make that happen?
10:40:02 <saml> gmosx: UTCTime (ModifiedJulianDay 23) (secondsToDiffTime 32)   ?
10:40:19 <audreyt> (or link to ticket#, etc.)
10:40:34 <saml> i'm probably wrong. i just tracked down type dependencies
10:40:34 <BMeph> Nice intro from Dcoutts: "You're being rude and you don't know what you're talking about. Not a good combination."
10:41:05 <astrolabe> BMeph: What's that from?
10:41:07 <sjanssen> gmosx: perhaps use posixSecondsToUTCTime?
10:41:19 <BMeph> astrolabe: The reddit reference, above.
10:41:21 <MyCatVerbs> saml: I hate time, very very much. :(
10:41:31 <astrolabe> thanks
10:41:35 <gmosx> saml: you mean UTCTime (ModifiedJulianDay 0) (secondsToDiffTime epoch) ?
10:41:54 <sjanssen> gmosx: and the docs recommend using realToFrac to convert into a POSIXTime
10:42:21 <sjanssen> gmosx: so what type are you starting with?
10:42:42 <gmosx> I am starting with (SqlEpochTime a)
10:42:45 <saml> gmosx: i'm not sure about UTC time or epoch. i just noticed type of UTCTime and ModifiedJulianDay and secondsToDiffTime and combined them.
10:42:48 <gmosx> returned from HDBC
10:42:58 <sjanssen> hmm, what is a SqlEpochTime?
10:43:07 <hpaste>  lilachaze pasted "Convoluted factorial (woo prime factorization)" at http://hpaste.org/8440
10:43:21 <gmosx> seems to be the time in secs from epoch wrapped as an SqlValue (HDBC)
10:43:28 <BMeph> gmosx: secondsToDiffTime . toInteger, though, since it takes an Integer argument. :)
10:43:38 <gmosx> here is my code:
10:43:43 <BMeph> !hpaste
10:43:46 <lilachaze> Axman6: there you go :)
10:43:48 <gmosx> stmt <- DB.prepare conn "SELECT date FROM my_table ORDER BY date DESC
10:43:49 <gmosx> LIMIT 1"
10:43:49 <gmosx> DB.execute stmt []
10:43:49 <gmosx> DB.commit conn
10:43:49 <gmosx> rows <- fetchAllRows' stmt
10:43:51 <gmosx> let ((d:_):_) = rows
10:43:55 <BMeph> @hpaste
10:43:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:44:06 <BMeph> Hpaste is your friend. :)
10:44:07 <sjanssen> gmosx: next time use a pastebin rather than dump in channel
10:44:08 <gmosx> oops sorry... I will use hpaset.org
10:44:11 <Axman6> lilachaze: ?
10:44:12 <gmosx> from now on...
10:44:13 <sclv_> oh no. the hackage is broek.
10:44:18 <lilachaze> Axman6: re "competition time"
10:44:26 <gmosx> sorry, I apologize, I am an IRC newbie as well...
10:44:31 <Axman6> oh, link?
10:44:54 <hpaste>  gmosx pasted "(no title)" at http://hpaste.org/8441
10:45:16 <gmosx> I used hpaste
10:45:24 <BMeph> lilachaze: "convoluted," indeed.
10:45:37 <gmosx> I want to create the d value to an UTCTime
10:45:55 <audreyt> interestingly, it seems that having Setup.hs to invent a "foo-bin" package that gets configure+installed right after "foo" is installed, can be made to work.
10:46:09 <Axman6> lilachaze: did you see vixey`'s?
10:46:52 <dons> hey audreyt.
10:46:55 <dons> how's code?
10:47:12 <audreyt> dons: code's great. trying to contract out some work to haskell hackers.
10:47:18 * SamB wonders what kind of code-complexity metrics would be interesting in Haskell...
10:47:21 <audreyt> in particular, looking for HPDF hackers, not very successfully though.
10:47:31 <Axman6> lilachaze: http://thepastesiteat.endoftheinternet.org:8080/paste/3
10:47:36 <SamB> function order histograms?
10:48:02 <hpaste>  sjanssen annotated "(no title)" with "this should work, I think" at http://hpaste.org/8441#a1
10:48:05 <Axman6> dons: were you at UNSW?
10:48:09 <chessguy> HPDF? what's that?
10:48:16 <sjanssen> gmosx: see the annotation (not actually tested)
10:48:22 <audreyt> dons: did you see my @tell about http://openafp.org/dist/SQLite.hs with createFunction and createAggregate hacked ine ?
10:48:36 <lilachaze> Axman6: technically that computes fibs not factorial :)
10:48:50 <Axman6> lilachaze: well, not my code
10:48:53 <audreyt> chessguy: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HPDF
10:48:54 <lilachaze> Axman6: but still, that's certainly... excessive... :)
10:48:59 <Axman6> and i didn't check it
10:49:20 <Axman6> i think vixey` may have a screw or two loose
10:49:21 <dons> audreyt: oh, did that get lost in my inbox?
10:49:23 <dons> Axman6: yes!
10:50:02 <audreyt> dons: possibly :) would be lovely if you can take a look and roll it into your darcs repo -- release is not neccessary, just want some cursory review
10:50:08 <lilachaze> Axman6: i'd imagine the use of peano arithmetic makes it kinda slow, too :)
10:50:13 <dons> audreyt: ok. noted.
10:50:19 <audreyt> thanks
10:50:25 <Axman6> dons: nice. i'm at ANU right now, been learning haskell there. ever heard of clem baker-finch?
10:50:51 <dons> Axman6: sure!
10:50:59 <Axman6> ha, cool :)
10:51:21 <gmosx> sjanssen: it works THANK you!
10:51:29 <dons> great guy. do you know Ben Lippmeier?
10:51:32 <Axman6> he was teaching us haskell, and java (reluctantly) this semester
10:51:39 <dons> he's one of Clem's phd students at ANU, haskell hacker.
10:51:45 <Axman6> i think he may be my lecturer lext semester
10:51:50 <Axman6> or something
10:51:55 <Axman6> the name's familiar
10:52:03 <vixey`> lilachaze: that's not why it's slow
10:52:08 <gmosx> btw is UTCTime the best type to use for dates in my program?
10:52:51 <Axman6> ah, maybe not
10:53:04 <Axman6> i've seen the name beofre though
10:53:33 <chessguy> audreyt:  looks cool
10:53:51 <chessguy> audreyt:  what are you looking to do with it?
10:56:29 <Axman6> dons: heh, i found ben's site at anu, and i looks like they're using something he did as an assignment for the comp2300 course, which my friend's in: http://cs.anu.edu.au/people/Ben.Lippmeier/project/disciple/styrene.png
10:56:30 <lambdabot> http://tinyurl.com/57xk84
10:58:07 <audreyt> chessguy: I'd like to find someone familiar with PDF to help me writing a OpenAFP->HPDF converter
10:58:13 <audreyt> (OpenAFP is also on hackage.)
11:00:03 <sclv_> stm question -- if I'm crashing at "stg_atomically_frame_info" with a kernel trap, there's no possible way that I could have caused that, no?
11:07:44 <dons> sclv_: it is a ghc bug, no matter what.
11:08:08 <sclv_> I think its actually still the takeMvar bug that bos found (I hope)
11:08:24 <sclv_> trying to get up and running with 6.8.3 now.
11:09:08 <gmosx> I have another small question: Is System.Time deprecated in favour of Data.Time ?
11:09:37 <dons> gmosx: somewhat, yes.
11:09:47 <dons> both will be around for ages
11:10:01 <gmosx> but Data.Time is the suggested Module?
11:10:13 <dons> if you want to learn one, learn Data.Tiem
11:10:17 <gmosx> OK
11:10:58 <BMeph> gmosx: That'll help, since the Data.Time function uses Integer - thus, no need to (.fromInteger) your value.. :)
11:11:17 <sclv_> ghc built cleanly actually, but hackage is crawling so its taking forever to cabal install all the bits I need
11:13:49 <gmosx> BMeph: hmm...
11:17:25 <gmosx> btw, this works as well:
11:17:28 <gmosx> UTCTime (ModifiedJulianDay 0) (secondsToDiffTime d)
11:17:51 <gmosx> as suggested by someone earlier...
11:23:56 <gmosx> goodbye everyone, thanks for the help.
11:29:21 <dons> audreyt: wow, OpenAFP is big. 230 modules. go go go!
11:30:16 <dons> http://haskell.org/haskellwiki/Simon_Has_Fun
11:30:17 <dons> wow
11:30:17 <lambdabot> Title: Simon Has Fun - HaskellWiki
11:30:20 <dons> looks like WG2.8
11:32:26 <MyCatVerbs> So. I'm in two minds about this.
11:32:40 <MyCatVerbs> Y'know how Haskell has, so far, avoided success at all costs?
11:33:01 <dons> that was the old policy, yeah.
11:33:05 <mar77a> damn it i'm stuck again
11:33:31 <audreyt> dons: :) 200 of them are generated by a perl script though -- that was before TH was usable
11:33:36 <MyCatVerbs> Well, we probably -could- make it more successful by stealing SPJ's razors, so that over time he'll grow a massive Unix beard and hence the laws of programming language dynamics will allow Haskell to spread its reach far and wide.
11:33:53 <dons> audreyt: that's fine :)
11:34:05 <MyCatVerbs> But on the other hand, the old policy wasn't such a bad idea, in many ways. Would that really be a good thing?
11:34:11 <dons> audreyt: http://aur.archlinux.org/packages.php?ID=17925
11:34:12 <lambdabot> Title: AUR (en) - haskell-openafp
11:34:38 <audreyt> dons: instant cabal2arch eh?
11:34:46 <dons> yeah
11:34:55 <dons> every distro should have one.
11:35:10 <dons> and a wiki-like free-for-all package upload process
11:37:38 * audreyt mumbles something about N*M package format converters
11:37:55 <dons> presumably they can share the same cabal parsing frontend
11:38:05 <dons> just need different pretty printers.
11:38:14 <audreyt> *nod*
11:38:20 <dons> if only there was a standard "package" format
11:38:26 <audreyt> N->1->M
11:38:45 <MyCatVerbs> dons: what about a cabal-to-autoconf-alike? Most distros already have autoconf-to-package as a single step.
11:38:57 <dcoutts> MyCatVerbs: no they don't
11:39:01 <dons> MyCatVerbs: they don't determined dependencies automatically
11:39:06 <dcoutts> you cannot extract dependencies from autoconf
11:39:07 <MyCatVerbs> dcoutts: don't they? Arch does.
11:39:15 <mrd> only in-so-far as they can do configure ; make ; make install
11:39:19 <MyCatVerbs> Oh, right.
11:39:20 <dons> they're jus black box wrappers over some dynamic initialisation code provided by autoconf
11:39:31 <mrd> but actually understanding what autoconf is doing? no. they don't do that.
11:39:36 <mrd> nobody can do that.
11:39:46 <Saul_> Does anyone here have experience with Generic Haskell?
11:40:17 <MyCatVerbs> mrd: can't you parse configure.ac and look for the .h files asked for, then query your package manager as to who owns those headers?
11:40:38 <mrd> maybe for some C programs
11:40:38 <dcoutts> MyCatVerbs: heh, not reliably
11:40:53 <MyCatVerbs> Right, fair enough.
11:41:12 <hesselink> Saul_: sure, a bit
11:41:14 <MyCatVerbs> Well. autoconf+manual dependency checking-to-package is a pretty decent compromise, no?
11:41:18 <dcoutts> MyCatVerbs: in general you'd have to run it, because it can have arbitrarily complex logic to decide which headers or libs it'll look for
11:41:34 <dcoutts> MyCatVerbs: right, that's what everyone has to do, manual checking of deps + testing. It's very time consuming.
11:41:44 <Saul_> I have this set of exercises about it that is due in 3 hours
11:41:51 <MyCatVerbs> dcoutts: right, except that you don't know whether it might ask for a completely different set if run on a different machine or during a full moon or whatever...
11:42:00 <dcoutts> MyCatVerbs: and that's why before Cabal there were only like 5 haskell packages in most distros.
11:42:08 <dcoutts> MyCatVerbs: that too
11:42:13 <audreyt> Cabal 1.4.0: Warning: 'license: GPL3' is not a recognised license.
11:42:15 <Saul_> I've been working on it for ages, but I have only been able to answer a little less than half of the questions
11:42:25 <hesselink> Saul_: are you a Utrecht student by any chance?
11:42:25 <audreyt> surely it should be there somewhere?
11:42:29 <dcoutts> audreyt: not yet no.
11:42:33 <Saul_> hesselink: Yes
11:42:50 <hesselink> Saul_: heh, me too. GP class?
11:43:04 <dcoutts> audreyt: I've added support for version numbers on the GPL and LGPL licenses but we've not enabled yet it because it'd break the parsers of existing deployments
11:43:11 <Saul_> hesselink: Ah Erik
11:43:18 <audreyt> dcoutts: coincidentally the only two licenses I use nowadays, "MIT" and "GPL3", aren't parsed
11:43:21 <Saul_> Yup, I'm Paul
11:43:27 <dcoutts> audreyt: the syntax is GPL-3, but as I say, you'll not be able to upload to hackage
11:44:00 <dcoutts> audreyt: yes, I added MIT too, but same problem
11:44:00 <audreyt> dcoutts: ah, I see. but surely the dash can be made optional?
11:44:00 <dcoutts> audreyt: that's not the problem
11:44:00 <audreyt> the problem is the existing deployments are not liberal
11:44:00 <audreyt> I do get that.
11:44:27 <MyCatVerbs> dcoutts: whereas Cabal actually specifies the dependencies... but does it (can it?) specify the dependencies on things like C libraries?
11:44:31 <dcoutts> audreyt: right, so Cabal-1.4 recognises GPL-3 and MIT, but we don't allow distribution like that yet. But once we do then Cabal-1.4 clients will be ok.
11:44:42 <audreyt> License: BSD3
11:44:46 <audreyt> License-really-is: MIT
11:44:47 <audreyt> ;)
11:45:00 <dcoutts> audreyt: they're pretty similar, yes. It's like a 2-clause BSD
11:45:12 <dcoutts> MyCatVerbs: yes, extra-libraries: blah
11:45:17 <MyCatVerbs> dcoutts: e.g. editline requires libedit as well as base.
11:45:22 <MyCatVerbs> dcoutts: oooh, nice.
11:45:23 <audreyt> no, I'm referring to a bad idea that take advantage of the fact that Cabal allows unrecognised field
11:45:30 <dcoutts> audreyt: you can of course use other and point to the license file
11:45:42 <audreyt> k.
11:46:31 <dcoutts> audreyt: aye, but if you were doing that, you could just put it in as a comment
11:46:53 <dcoutts> License: OtherLicens
11:46:57 <dcoutts> -- really is MIT
11:47:01 <audreyt> though the idea is that Cabal1.4+ would parse the License-really-is field
11:47:08 <dcoutts> heh
11:47:09 <audreyt> which wouldnt really be named that
11:47:23 <audreyt> again, bad idea, nevermind.
11:47:49 <dcoutts> audreyt: once the clients with the fragile parsers become the minority we can do better
11:48:10 <audreyt> k
11:48:39 <mrd> shouldn't they be using cabal as the parser?
11:49:14 <dcoutts> mrd: that's the thing, the original parser in the Cabal lib used Read/Show in places and was thus very fragile.
11:49:23 <mrd> h
11:49:24 <mrd> ah
11:50:57 <dons> anyone see the new quant/haskell job on -cafe@
11:51:00 <dons> cool stuff
11:51:55 <dons> byorgey: should go in hwn jobs section.
11:52:05 <byorgey> dons: yup, saw that
11:53:50 <mahound> hello
11:54:02 <mahound> does anybody know a good resource to learn about coiteration?
11:55:44 <dons> Lemmih: does HAppS-* on hackage really not work with new haxml
11:55:45 <dons> ?
11:55:49 <bos> video of my concurrent/parallel haskell talk from last month: http://www.realworldhaskell.org/blog/2008/06/20/video-of-my-concurrentmulticore-haskell-talk-is-up/
11:55:49 <dons> i should try.
11:55:51 <lambdabot> Title: Real World Haskell  Blog Archive  Video of my concurrent/multicore Haskell tal ..., http://tinyurl.com/68wtr6
11:56:19 <bos> oh, and reddit link for teh voterz: http://www.reddit.com/info/6o9tm/comments/c04f8pp
11:56:19 <lambdabot> Title: reddit.com: Video of BayFP concurrent/multicore Haskell talk
11:56:28 <dcoutts> dons: though technically speaking that is the current stable version of haxml
11:57:17 <dons> dcoutts: 0.19.x is on hackage.
11:57:32 <dons> or are odd numbers significant in haxml?
11:57:59 <dcoutts> dons: nothing since 1.13 has been a stable release
11:58:14 <dons> ah
11:58:14 <mahound> oops... coiteration... i mean "corecursion"
11:58:15 <mahound> lol
11:58:22 <dcoutts> dons: there's no numbering convention, it's just what malcolmw declares.
11:58:45 <dcoutts> these are the tricky ones, where there is some major new version of a package that's incompatible and partitions the package collection
11:59:11 <dcoutts> dons: those are the cases where haskell packaging people need to go round sorting things out
11:59:23 <dcoutts> dons: it's a bit like the role of distro maintainers
11:59:31 <dons> hmm
12:00:04 <dcoutts> dons: parsec-3 is the other example and regex-*-0.7x vs 0.9x
12:00:16 <dons> yeah. all yuck
12:00:27 <dons> i'll send out another build failure list today
12:00:34 <dcoutts> dons: this is where a platform helps
12:00:35 <dons> since that cleaned up 5 or so last time
12:00:45 <dcoutts> it allows us to declare one version or the other as standard
12:00:52 <dons> parsec3 should have beenn called something else
12:01:05 <dons> parsec3-0.1 perhaps
12:01:19 <dons> so we can distinguish true parsec from the fork
12:01:21 <dcoutts> dons: or we need a way on hackage to say, prefer some version other than the latest
12:01:28 <dons> yeah
12:01:32 <bos> there's a fork of parsec3?
12:01:45 <dcoutts> preferring the "latest" version is only a default policy
12:01:51 <dons> well, parsec-3.x is a fork of parsec
12:01:52 <dons> they're quite different
12:01:54 <bos> oh right.
12:02:00 <dons> to the point i'd call parsec-3 something else
12:02:06 <bos> "slowparsec".
12:02:24 <dcoutts> dons: it's ok so long as we can distinguish them, and majro version is fine
12:02:56 <dcoutts> dons: want to file a feature request?
12:03:13 <dons> off to lunch
12:03:14 <dcoutts> it needs more meta data on hackage and for cabal-install to take that into account in its package planning
12:03:18 <dons> yeah
12:03:48 <dcoutts> dons: distros do pretty similar things, packages start of unstable and get promoted to stable
12:09:38 <Deewiant> anybody feel like knowing why I get link errors of the form "libHSghc.a(SysTools.o)(.text+offset):fake: undefined reference to `processzm1zi0zi0zi1_SystemziProcess_stuff`"?
12:10:14 <Deewiant> context is building a hack-fixed version of haddock-2.1 on GHC-6.8.3 on Windows, http://www.haskell.org/pipermail/haskell-cafe/2008-June/044557.html
12:10:15 <lambdabot> Title: [Haskell-cafe] Re: Haddock compilation problem, http://tinyurl.com/67qufo
12:10:35 <audreyt> Deewiant: -package process-1.0.0.1 ?
12:11:35 <audreyt> or rather, add "process" to build-depends in the .cabal file?
12:13:00 <Deewiant> seems to have done it, thanks
12:13:04 <audreyt> np :)
12:13:09 <Deewiant> wonder why it needs it for linking but not compilation
12:14:13 <Deewiant> build-depends wasn't enough, by the way
12:18:01 <Deewiant> aw, now it built but it doesn't work
12:18:03 <Deewiant> Segmentation fault/access violation in generated code :-)
12:20:25 <Deewiant> hmm, there's no "cabal uninstall"?
12:20:37 <dcoutts> Deewiant: not yet, no
12:20:57 <dcoutts> Deewiant: if you want to help implement it then I can give you some pointers on where to start
12:20:59 <Deewiant> I suppose the manual method is ghc-pkg unregister followed by deleting it?
12:21:21 <dcoutts> yep
12:22:09 <Deewiant> also, can an install or upgrade be forced?
12:22:43 <visq> dcoutts: do you have time for a question concerning c2hs ?
12:22:56 <dcoutts> visq: sure
12:23:09 <dcoutts> Deewiant: you mean a re-install of the same version?
12:23:12 <Deewiant> yes
12:23:22 <dcoutts> Deewiant: file a feature request :-)
12:23:27 <Deewiant> :-)
12:23:30 <visq> in the original code, there were LOT of monads, from Manuels toolkit. PreCST, State, ...
12:23:46 <visq> And then the ParserMonad you wrote
12:23:48 <dcoutts> Deewiant: no, really :-) http://hackage.haskell.org/trac/hackage/wiki
12:23:50 <lambdabot> Title: Hackage - Trac
12:24:03 <dcoutts> visq: right, all the old CTK stuff
12:24:09 <Deewiant> and a more general question: how should one figure out the most general 'build-depends'
12:24:19 <dcoutts> visq: I tried once to convert it to mtl, ugg. It's all so interconnected.
12:24:36 <visq> Well, I'm now moving the analysis code from c2hs to Language.C
12:24:39 <Deewiant> I mean, I know it compiles and appears to run with exactly the versions I have installed, but beyond that?
12:24:46 <mc__> I want to get started with haskell. What would you recommend as a development enviromnent on the mac?
12:24:49 <visq> I discussed with Iavor, and he was rather not in favour of mtl
12:25:08 <dcoutts> Deewiant: there's nothing automatic at the moment. A good default is the major version you know it happens to work with and put and upper bound of the next major version.
12:25:25 <visq> But I do not want to keep the old toolkit stuff, UNames neither.
12:25:39 <dcoutts> visq: right, I would not suggest keeping it
12:25:53 <dcoutts> visq: besides presumably you're working with a quite different C AST right/
12:26:01 <Deewiant> so "base >= 3.0, base < 4.0" for base, for instance?
12:26:05 <dcoutts> Deewiant: right
12:26:13 <visq> Better to write another monad (State + Error) for analyzing, traversal, or use mtl ?
12:26:20 <dcoutts> Deewiant: which can be written base >= 3 && < 4
12:26:29 <visq> no, for now the AST stayed quite the same. I just added features.
12:26:31 <Deewiant> ah, cool, thanks
12:26:52 <visq> Especially for attributes (the parse handles now the full gcc __attribute__ syntax)
12:26:58 <dcoutts> visq: great
12:27:25 <visq> the cc-wrapper idea was fantastic btw. Saved me a lot of troubles.
12:27:34 <dcoutts> visq: btw, did William Harrison get in touch with you about your project?
12:27:58 <visq> I wrote a mail to iavor
12:28:23 <dcoutts> visq: if you're making a new monad for the analysis then I don't think it matters much if you roll your own or build one using mtl.
12:28:49 <bos> visq: just don't pull in a dependency on monadLib if you can help it.
12:28:53 <dcoutts> visq: the main thing I'd recommend against is trying to do a 1-1 translation of the existing c2hs code into mtl
12:29:08 <visq> bos: :)
12:29:11 <dcoutts> bos: why is ath ooi?
12:29:16 <dcoutts> ath/that
12:29:31 <bos> dcoutts: dependency creep avoidance.
12:29:47 <bos> nothing against monadLib, it's actually nice.
12:29:49 <dcoutts> bah, deps are now easy :-)
12:30:13 <bos> heh.
12:30:36 <visq> dcoutts: ok thanks. I was just wondering if you kept PreCST and Co on purpose when I started reading the code.
12:30:59 <dcoutts> visq: no, I've been trying hard to get rid of them
12:31:17 <visq> iavor is btw. the author of monadLib, so
12:31:49 <visq> ok, I'll start with a mtl prototype (State + Error), and then maybe use a customized monad later on
12:32:27 <dcoutts> visq: I'm actually not at all familiar with what the c2hs C analysis phase does
12:32:57 <dcoutts> besides the C parser I've really only done performance hacking on c2hs and general refactoring
12:33:07 <dcoutts> visq: I don't understand half the code :-)
12:33:30 <visq> :) some of the code is scary indeed
12:33:37 <bos> it's no fun hacking on something if you understand it all.
12:33:44 <dcoutts> heh heh
12:34:03 <visq> performance is not too great either, 25KLoc on my system
12:34:15 <visq> but that's propably ok
12:34:22 <dcoutts> visq: I'm trying to make it more hackable, bring it up to modern Haskell
12:34:35 <dcoutts> using libs people are familiar with
12:35:13 <visq> Thats encouraging, thanks. I was afraid to throw away all that beautiful code from 96'
12:35:28 <dcoutts> visq: last time I looked, the time was fairly evenly divided between the lexer, parser and analysis phases
12:35:39 <dcoutts> visq: heh
12:36:23 * dcoutts wants to halve the number of parser and lexer styles used in c2hs
12:36:34 <visq> dcoutts: ok interesting. I wanted to switch to bytestrings for lexing, but in this case ...
12:36:57 <dcoutts> visq: aye, alex can lex from bytestrings
12:37:27 <dcoutts> visq: there's another lexer in c2hs, the one for lexing .chs files. That uses the CTK lexer rather than alex. I'd convert it.
12:38:21 <visq> dcoutts: Until now I didn't look to much into the non-C part of c2hs
12:38:27 <visq> but I want to
12:38:55 <dcoutts> visq: btw, I just pushed a bunch of changes to c2hs, to rearrange the layout of the source tree
12:39:03 <visq> and also work on regression tests for marhsalling
12:39:13 <dcoutts> right, sizes of structs etc
12:39:18 <visq> right
12:39:25 <dcoutts> visq: for gtk2hs we'd like to extend the marshaling features
12:39:35 <dcoutts> visq: eg to let us declare default marshalers
12:40:24 <visq> default haskell - c mappings ?
12:40:59 <dcoutts> visq: right, for example for a GObject C type we'd like to say to use withGObject as the marshaling function
12:41:06 <dcoutts> so we don't have to write that everywhere
12:41:22 <visq> yes, that would be a nice feature
12:41:35 <dcoutts> visq: {# fun #} hooks have a mechanism like this already but only with a fixed list of default marshalers
12:41:45 <dcoutts> so you have to specify the marshaler every time
12:44:13 <dcoutts> audreyt: oooh, uconv
12:44:22 * dcoutts checks out the API
12:45:01 <visq> dcoutts: i see. I'll now try to work on the analysis stuff, and then I'll start with c2hs. thanks for your help.
12:45:01 * dcoutts wonders where the UConvertible is defined/documented
12:45:55 <dcoutts> visq: if you want to get patches into c2hs I should warn you I've just pushed some changes that are very likely to conflict
12:46:06 <dcoutts> so you might want to update before hacking on patches for c2hs
12:46:23 <seanmce> doAction :: MonadCGI m => String -> m CGIResult
12:46:23 <seanmce> amap = [("test", doAction), ("show", doAction)] -- Ambiguous type variable `m' in the constraint:    `MonadCGI m'
12:46:35 <seanmce> how can I do this?
12:46:40 <dcoutts> audreyt: so presumably convert must be strict, so it can return an error or the result
12:52:22 <enzo_>  show $ print 1
12:52:34 <enzo_> > show $ print 1
12:52:38 <lambdabot>  "<IO ()>"
12:53:07 <enzo_> how can I show something from IO?
12:53:20 <roconnor> lambdabot doesn't do IO
12:53:25 <Deewiant> fmap show
12:54:38 <enzo_> fmap show (print 1) does not return "1"
12:54:53 <Deewiant> you are correct, it doesn't
12:55:01 <Deewiant> that's because print 1 doesn't return 1
12:55:06 <pjdelport> enzo_: print returns IO ()
12:56:25 <pjdelport> you could do fmap show getLine, for example
12:56:51 <pjdelport> a.k.a. show <$> getLine
12:57:09 <Deewiant> a.k.a. liftM show getLine
12:57:20 * roconnor is very confused as to what enzo_ is trying to do
12:57:43 <visq> dcoutts : I'm subscribed to the c2hs mailing list and saw the patches. Thx for the hint
12:58:35 <hpaste>  enzo_ pasted "How can I get around useing unsafePerformIO?" at http://hpaste.org/8442
12:59:20 <roconnor> @hoogle httpGet
12:59:20 <lambdabot> No matches found
13:00:03 <roconnor> enzo_: you can just write getHtml "http://www.google.com" at the GHCi prompt
13:00:03 <lambdabot> Title: Google
13:00:11 <Deewiant> enzo_: fmap show should work there
13:01:06 <enzo_> but I need it to return a string
13:01:27 <roconnor> or if you really want to convert the Maybe String into a String by quoting it, doing fmap show $ getHtml "http://www.google.com", as Deewiant will work
13:01:29 <pjdelport> enzo_: you need it to return an IO String :)
13:01:58 <roconnor> or fmap fromJust $ ... to extract the string from the Maybe.
13:02:19 <roconnor> enzo_: why do you think you need a String, rather than an IO String?
13:02:31 <enzo_> OMG it works!
13:02:45 <enzo_> =] =] =] YAY
13:03:24 <enzo_> oh shoot
13:03:44 <enzo_> I do need type String not IO String
13:04:17 <Deewiant> http://arcanux.org/lambdacats/io-monad.jpg
13:04:38 <enzo_> hahahhahahahahah!
13:05:01 <pjdelport> http://arcanux.org/lambdacats/unsafeperformio.jpg
13:05:05 <Deewiant> now is the time to read a monad or IO tutorial
13:05:35 <int-e> that cat still has a lot to learn - you have to attack the human, not the door ;)
13:05:37 <Taggnostr> if I write an haskell program can I use it to create a dll/so?
13:06:00 <Deewiant> yes
13:06:03 <Deewiant> http://haskell.org/ghc/docs/latest/html/users_guide/win32-dlls.html
13:06:03 <lambdabot> Title: 12.6. Building and using Win32 DLLs, http://tinyurl.com/6dds3d
13:06:54 <enzo_> is unsafePerfomIO the only way to get getHtml to return something of type String?
13:07:05 <rwbarton> enzo_: if you're trying to read a page and then do some processing of the result, write a separate function processPage :: String -> Whatever
13:07:08 <Deewiant> yes, or unsafeCoerce if you want to crash your program
13:07:18 <int-e> > const "<HTML>" undefined
13:07:19 <rwbarton> and then bind them later using (getHtml "google.com") >>= processPage
13:07:19 <lambdabot>  "<HTML>"
13:07:34 <Taggnostr> thanks Deewiant
13:07:54 <roconnor> enzo_: you don't really want a String.  You want an IO String.  Then you use bind to pass an IO String as an argument to a function taking a String.
13:08:03 <hpaste>  Saul_ pasted "Some subtle hints please" at http://hpaste.org/8443
13:08:05 <roconnor> like rwbarton says
13:08:06 <Deewiant> enzo_: you don't want it to return String - seriously, read some monad/IO tutorial, say http://www.haskell.org/tutorial/io.html
13:08:07 <lambdabot> Title: A Gentle Introduction to Haskell: IO
13:08:12 <monochrom> ("bind" means >>= or the do notation)
13:08:23 <Deewiant> or http://www.haskell.org/haskellwiki/IO_inside
13:08:23 <lambdabot> Title: IO inside - HaskellWiki
13:08:31 <Saul_> Can anyone help me with my homework exercise (pasted a few lines above this one)?
13:08:48 <pjdelport> enzo_: unsafePerfomIO doesn't really do that
13:08:58 <enzo_> ok I'll try using the bind operator
13:09:52 <pjdelport> enzo_: to a first approximation, it breaks your program, hence the name :)
13:09:53 <monochrom> Saul_: interesting exercise.
13:10:45 <int-e> Saul_: that gives a kind error as stated
13:10:45 <Saul_> monochrom: It actually took me a while to get to this point, it's only a fifth of a seventh of the complete assignment :)
13:10:46 <pjdelport> enzo_: the IO monad is how you keep track of effects, or actions, in Haskell
13:10:46 * int-e wonders
13:11:51 <pjdelport> enzo_: so think of getHtml's type of IO String as not just the string, but the *action* to fetch that string
13:12:29 <Saul_> int-e: You're right, any suggestions on how to fix the type signature?
13:14:24 <Saul_> bimap :: EP (f n m) (g n m) -> EP a b -> EP (HFix f a) (HFix g b) This at least compiles, so that's probably what I need
13:15:15 <rwbarton> Saul_: You probably need (forall n m. EP (f n m) (g n m)) -> EP a b -> EP (HFix f a) (HFix g b) to actually write the function, no?
13:15:28 <int-e> looks sensible to me
13:15:31 <pjdelport> enzo_: fmap, bind, and so on are among the various ways Haskell has of combining normal pure functions with such actions (and their side effects)
13:15:38 <monochrom> eek, 2nd-rank
13:16:08 <Saul_> monochrom: http://www.cs.uu.nl/wiki/pub/GP/CourseAssignments/set2.pdf contains all the exercises if you're bored
13:16:30 <pjdelport> enzo_: you'll probably be reading about do notation, which resembles imperative programming languages
13:16:30 <int-e> monochrom: and n is a type constructor (kind * -> *), not a type.
13:16:46 <Saul_> monochrom: They're pretty interesting, but a bit more help wouldn't have hurt
13:20:06 <enzo_> pjdelport, IO is a bit confusing.. and Haskell is the only programming language I know... The only thing I can do is write haskell webapps for my site http://www.inputyourdata.com
13:20:58 <enzo_> i need to make my search engine work though. That's what I'm working on
13:21:25 <pjdelport> enzo_: have you read http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output ?
13:22:56 <enzo_> no, but I've read a similar tutorial
13:23:45 <int-e> Saul_: you also need a (bi?)functor structure for f and g.
13:24:20 <SamB> enzo_: I find your situation humorous
13:24:47 <Saul_> int-e: I'm not sure what that question means, but isn't that what the first argument provides?
13:24:48 <pjdelport> enzo_: working through the above should put you on solid footing to write IO-using code
13:24:49 <SamB> mostly because the idea that someone would (a) have Haskell as their only language and (b) only know how to write webapps ... really strange
13:25:46 <int-e> Saul_: no. given an EP a b, you need to construct an EP (f n a) (g n b). and something similar for the first argument (n).
13:26:31 <Saul_> int-e: That is very possible
13:26:32 <enzo_> I'm a strange person and if you check out http://www.inputyourdata.com/mathematics.html you'll see I write some pretty good web apps
13:26:44 <int-e> Saul_: sorry. EP (f n a) (f n b)
13:26:48 <Saul_> int-e: I frankly don't really know what I'm doing :)
13:28:26 <Saul_> int-e: But I guess that might be a good start
13:32:43 <Saul_> int-e: Do you have any suggestions on how to do that?
13:35:39 <rwbarton> Saul_: I think int-e means the functor instance for f and g needs to be provided for you.
13:36:37 * Cale wonders if there's anyone who would really use a web application to compute dot products.
13:38:29 <Cale> I suppose it's okay as an illustration :)
13:39:43 <Saul_> rwbarton: As in (Functor (f n), Functor (g n)) => ...?
13:40:46 <SamB> Cale: I think javascript is more traditional
13:41:03 <SamB> (for educational purposes only)
13:42:19 <rwbarton> Saul_: I think that's right.
13:42:40 <mar77a> i'm stuck again guys, i want to learn and use haskell but i've no clue what to do
13:42:42 <rwbarton> Saul_: Maybe it's a good idea to try to write bimap as the composition of two functions, one that handles a change in the 'a' variable, and one that handles a change in the 'f' variable.
13:43:01 <smtms> mar77a, start reading, and playing, and asking *smart* questions
13:43:01 <mar77a> i've read most tutorials already but i'm more of a learn-by-practice type (who isn't?)
13:43:37 <mar77a> i don't want a language to 'play with' i want to write applications
13:44:05 <mar77a> there's something about haskell's smell that just does me
13:44:17 <mauke> I recommend playing with stuff
13:44:23 <mmorrow> i hate mysql aaggghhhh!@#$
13:44:25 <mauke> you'll learn a lot along the way
13:45:06 <Saul_> rwbarton: That might be a good idea
13:45:20 <Saul_> rwbarton: But instead I think I'll just give up
13:46:05 <Saul_> rwbarton: The question is only like a 30th of my final grade and the deadline is coming uo
13:46:06 <Saul_> p
13:46:18 <rwbarton> Saul_: right
13:46:40 <Saul_> and I've been working on this all day already
13:47:08 <Saul_> rwbarton: Thanks for your help though
13:47:38 <Saul_> Maybe I'll try it again in a few weeks, when schoolwork has died down a bit
13:48:36 <Cale> enzo_: There's something strange about your Wronskian calculator.
13:49:37 <mmorrow> so i'm gonna store a list of unisgned ints as a csv-formatted string since unfortunately it's mysql, anyone have a better way?
13:49:51 <enzo_> cale, I know, It has problems combining like terms. I haven't really figured out how to do that yet
13:50:36 <Cale> Also, it doesn't reduce log(e) to 1.
13:50:44 <Cale> er, or in your notation ln(e)
13:51:04 <mmorrow> heh i was about to sticklerificate
13:51:24 <Cale> The only logarithm is the natural one ;)
13:51:43 <SamB> programmers should use the free logarithm
13:51:57 <SamB> (which is a logarithm having the same unspecified base as exp)
13:52:12 <Cale> for 1,x,x^2,x^3,x^4 it gives a very large expression that I'm not entirely certain how it got, which involves many logarithms
13:52:27 <Cale> It does actually reduce to the correct result though, which is 288
13:52:30 <SamB> it avoids failures relating to incorrect assumptions regarding the base of logarithms
13:53:27 <Cale> I think log and exp should just always refer to the natural ones.
13:53:40 <mmorrow> i like the system: lg := log_2 , ln := log_e , log := log_10
13:54:02 <Cale> In fact, I don't really like the idea of a logarithm to another base. We don't need extra notation just for scaling factors.
13:54:26 <byorgey> mar77a: I suggest finding an existing project that you can contribute some code to.
13:54:28 <SamB> well, ln and log_n
13:54:30 <SamB> are good enough
13:54:31 <Cale> I'm happy to write log(x)/log(2) if I want a base 2 logarithm ;)
13:54:33 <mmorrow> i never use any base other than (2,e,10), and if anyone has a need for another log base then they surely know how to calculate it
13:54:47 <byorgey> mar77a: that's a great way to get some practical experience without being overwhelmed by building an application from scratch.
13:55:15 <SamB> Cale: lg is REALLY damn handy
13:55:23 <Cale> SamB: possibly.
13:55:36 <SamB> and not based on mere biological facts
13:55:59 <Cale> I agree that if you're going to use a log to any base other than e, you might as well choose 2
13:56:02 <SamB> binary is intrinsicly the simplest base to use in computers
13:56:28 <mar77a> it's the only base computers can 'use' isn't it
13:56:31 * byorgey prefers log base phi
13:56:32 <Cale> The fact that there are so many base 10 logs used in science is irritating.
13:56:46 <mmorrow> i *hate* base 10 logs
13:56:47 <SamB> mar77a: you could create a computer that used a different base
13:56:48 <Cale> mar77a: Actually, computers usually compute the natural logarithm.
13:56:50 <enzo_> cale, that is because the program thinks x^2 is really (f(x))^(g(x)). You'll find, if you do the simplification that the answer is 100% correct. I agree with what your saying about log and ln, I'll will def change that
13:56:57 <SamB> but the electronics would be much harder
13:57:07 <mar77a> yeah different voltages for different states?
13:57:08 <SamB> it would waste so much silicon
13:57:12 <mar77a> or something like that
13:57:24 <SamB> since you'd have to detect "middle" states
13:57:29 * roconnor thinks ln for complex number shouldn't take a numeric parameter, rather it should take a curve [0,1]->C
13:57:53 <roconnor> well ->C/{0}
13:57:57 <SamB> with binary, you can just saturate
13:58:05 <rwbarton> a curve starting at 1, presumably
13:58:18 <SamB> roconnor: a curve?
13:58:24 <SamB> why ?
13:58:27 <Cale> SamB: To disambiguate.
13:58:36 <roconnor> rwbarton: not necessarily starting at 1, but I'm not opposed to that constraint either.
13:58:53 <SamB> starting at one sounds like the right thing to me
13:58:57 <roconnor> SamB: so you know which way to wrap around 0 and how many times.
13:58:59 <rwbarton> Well, you should fix some starting point, otherwise you're no better off than you were originally
13:59:04 <SamB> roconnor: oh
13:59:16 <Cale> SamB: Normally, the complex log is a selected branch of the relational inverse of the exponential function.
13:59:30 <roconnor> SamB: you can always rotate and (radially) scale the curve so that it starts at 1.
13:59:32 <SamB> I can't see how the curve could start anywhere else
13:59:43 <roconnor> stupid branch cuts.
13:59:54 <SamB> this is a logarithm, not a difference of logarithms or a logarithm of a fraction
14:00:00 <rwbarton> roconnor: Oh, you mean you're defining log(w) - log(z) for a curve from z to w.  Sure
14:00:21 <SamB> branch cuts can actually be quite pretty
14:00:32 <SamB> see any book of pretty fractals
14:00:34 <Cale> SamB: He's saying that if your curve-eating log can just take the curve f that it's given and divide through by f(0)
14:00:45 <roconnor> SamB: every logarithm I've encountered in physics is the ratio of two logorithms.
14:00:46 <Cale> er, -if
14:01:39 <SamB> roconnor: the only ones that have units that physicists actually understand are, yes
14:01:40 <Cale> log(x)/log(e) ;)
14:01:42 <SamB> namely, "1"
14:01:43 <mmorrow> yeah, but physicists are silly people
14:02:21 <roconnor> mmorrow: they are wiser than you think. ... well they aren't wiser, but nature is wiser.
14:02:24 <SamB> well, I guess it wouldn't be too hard to teach them log units
14:02:35 <SamB> but we'd have to first write it up for ourselves
14:03:44 <SamB> speaking of logarthmic units, does anyone have any insight into why neutral solutions have a pH of 7.00 ?
14:03:54 <SamB> there is no normalization in the formula for pH!
14:03:55 <mmorrow> roconnor: true. i just like giving them a hard time, it's fun
14:04:50 <rwbarton> SamB: I think the (constant) value of [H+][OH-] in (room temperature, etc.) water just happens to be about 10^-14 M^2
14:05:08 <mmorrow> SamB: because it's half of 14? (i'm kidding)
14:05:39 <SamB> rwbarton: well, yes, but how the heck did that happen!
14:06:00 <rwbarton> SamB: Sure. :)
14:06:04 <SamB> did the way they picked units make this happen? is metric God's system of measurement?
14:06:16 <mmorrow> why do we have 10 fingers?
14:06:35 <SamB> well, it's a multiple of 2
14:06:43 <mmorrow> exactly!
14:06:44 <byorgey> it's also half of 20
14:07:03 <mmorrow> i think it's a result of using base 10
14:07:13 <mmorrow> (...or is that the other way around)
14:07:46 <SamB> byorgey: I think that's related to the fact that 20 is 2*2* something
14:07:53 <byorgey> and if you add up the numeric values of the letters in the word 'finger', you get...
14:07:54 <Cale> SamB: no, that would be Planck units
14:07:56 <byorgey> > sum . map ((subtract (ord 'a')) . ord) $ "finger"
14:07:58 <lambdabot>  53
14:08:00 <SamB> Cale: supposedly
14:08:12 <SamB> but those numbers are extremely unwieldy
14:08:15 <byorgey> ...fifty-three, and 5+3 is 8, plus two for good luck makes 10
14:08:20 <byorgey> see, it's obvious
14:08:36 <Cale> SamB: Of course, those depend on our particular formalisation of things.
14:08:45 <mmorrow> byorgey: geniush
14:08:59 <roconnor> "Neutral pH at 25 °C is not exactly 7. pH is an experimental value, so it has an associated error. Since the dissociation constant of water is (1.011 ± 0.005) × 10−14, pH of water at 25 °C would be 6.998 ± 0.001.
14:09:36 <Cale> I kind of like the idea of all speeds being between 0 and 1
14:09:37 <roconnor> according to wikipedia
14:10:11 <SamB> oh.
14:10:32 <SamB> I thought the standard temp was 30 degrees?
14:10:41 <SamB> am I just being forgetful?
14:11:59 <Cale> Heh, if you use Planck units, then instead of E = m c^2, you have E = m
14:12:33 <SamB> now THAT *is* appealing
14:13:27 <Cale> and instead of E = 1/(4 pi ε_0) (q_1 q_2)/r^2, Coulomb's law becomes E = (q_1 q_2)/r^2
14:13:37 <SamB> if we used planck units, how many of the constants could we rip out of our modern physics books?
14:13:44 <monochrom> the standard temperature is 30 in hot places like Brazil :)
14:13:44 <Cale> Lots of them.
14:13:48 <dons> interesting, dcoutts, NetBSD is now recommending a BSD-2 license
14:13:52 <dons> no more endorsement clause
14:14:07 <roconnor> SamB: The pH of water gets smaller with higher temperatures.
14:14:10 <SamB> yeah, I did always think that that clause was screwy
14:14:15 <Cale> Er, that should be F, not E
14:14:17 <SamB> roconnor: oh.
14:14:20 <dcoutts> dons: is that any different from MIT then?
14:14:30 <Cale> (and instead of F = 1/(4 pi ε_0) (q_1 q_2)/r^2, Coulomb's law becomes F = (q_1 q_2)/r^2)
14:14:31 <dons> let me put it up.
14:14:37 <dcoutts> dons: I thought MIT = 2-clause BSD license
14:14:54 <roconnor> An example is acid mine runoff, with a pH = –3.6.
14:14:54 <roconnor> wow
14:14:56 <SamB> dcoutts: maybe MIT license has different 2 clauses?
14:14:57 <roconnor> ouch
14:15:06 <hpaste>  dons pasted "BSD2" at http://hpaste.org/8444
14:15:16 <dons> dcoutts: can we get BSD2 in the cabal list then?
14:15:22 <dons> i'll probably move to it now
14:15:36 <SamB> roconnor: I've seen negative pH values before, but that's extreme. I don't think I've ever actually encountered anything with negative pH in real life, though...
14:15:45 <dcoutts> dons: not yet, for the same reasons we can't put MIT and GPL-3
14:16:04 <SamB> dcoutts: which is?
14:16:25 <dcoutts> SamB: such packages will break for people with Cabal-1.2.x
14:16:39 <SamB> dcoutts: so you add it to the list but disable hackage uploads
14:17:00 <SamB> also why wasn't MIT in there from the start?
14:17:05 <dcoutts> SamB: yes
14:17:08 <dcoutts> SamB: no idea
14:17:14 <SamB> good answer
14:18:01 <sutats> Does Haskell have anything which makes it easy to read a file in a bit at a time?
14:18:11 <SamB> sutats: yeah
14:18:12 <SamB> readFile
14:18:14 <dons> sutats: lazy IO, yes.
14:18:26 <quicksilver> roconner: "The conventional definition of pH based on the former National Bureau of Standards criteria and defined buffer systems limits the range of definable and measurable pH values to that of 1 to 13. Outside this range, the concept and measurement of pH are difficult at best"
14:18:40 <SamB> sutats: unfortunately it's a bit dangerous
14:18:40 <dons> sutats: you can also write a loop that waits on EOF
14:19:02 <roconnor> quicksilver: okay, I'm just quoting wikipedia.  I'm not a chemist.
14:19:05 <TomMD> @where parallel
14:19:05 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
14:19:11 <quicksilver> ;)
14:19:21 <sutats> SamB, dons: Thanks. Is readFile lazy?
14:19:22 <twobitwork> ?src mzero IO
14:19:22 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:19:24 <SamB> quicksilver: well, that's not the same pH I'm talking about
14:19:34 <twobitwork> ?src mzero Maybe
14:19:34 <lambdabot> Source not found. My brain just exploded
14:19:42 <twobitwork> ?src Maybe mzero
14:19:42 <lambdabot> mzero = Nothing
14:19:46 <twobitwork> ?src IO mzero
14:19:46 <lambdabot> mzero       = ioError (userError "mzero")
14:19:46 * roconnor watchers Bryan's video
14:20:20 <SamB> the pH I'm talking about is defined, not in terms of buffer systems, but as the negative log_10 of the molarity of free hydrogens
14:20:30 <twobitwork> sorry, I should have /msg'd those
14:20:59 <SamB> twobitwork: you are apologizing for interrupting our chemistry discussion?
14:21:01 <twobitwork> ohh... nm, its all off-topic stuff anyways :P
14:21:05 <twobitwork> SamB: hehe
14:21:28 <dcoutts> dons: I can't find a comparison of the MIT and BSD licenses apart from noting the thing about not using the names of the authors
14:21:29 <quicksilver> SamB: my understanding is that molarity is a crude approximation and pH is actually about *activity* not just concentration.
14:21:41 <quicksilver> however my days as a chemist are very long past.
14:21:50 <SamB> quicksilver: hmm, well, I'm not a chemist
14:21:54 <SamB> so I guess I wouldn't know
14:22:01 <SamB> but that does sorta make sense
14:22:48 <twobitwork> dcoutts: my understanding is that there is very little functional difference between them
14:23:23 <TomMD> ﻿If I understand bos's post correctly, he said the example "let x = 5 + 5 ... x `seq` x" doesn't do anything.  This is because seq evaluates things to WHNF, right?  Or does it actually eval to HNF and I missed something?
14:24:02 <Cale> TomMD: right
14:24:03 <Heffalump> this is because seq only evaluates anything when it itself is evaluated
14:24:16 <Heffalump> x `seq` x is always equal to x
14:24:21 <bos> it's because x `seq` x has no effect until ... ok, other typists win :-)
14:24:31 <TomMD> thanks
14:24:46 <Cale> If it evaluated things to HNF, then the result would be a value which, when evaluated, would evaluate x to HNF before matching.
14:25:15 <twobitwork> WHNF/HNF?
14:25:22 <Heffalump> which is what deepSeq does (assuming a proper implementation)
14:25:24 <TomMD> weak head normal form
14:25:36 <Heffalump> HNF = evaluated to a normal form, even under lambdas
14:25:37 <Cale> Er, NF would be more interesting
14:25:47 <twobitwork> ahh
14:25:49 <TomMD> Heffalump: Why do you add on the caveat?  Is GHCs implementation incorrect?
14:26:02 <Heffalump> so 3, \x -> x + x are all normal forms, because no further reduction is possible
14:26:03 <SamB_XP_> x`seq`x just says "when my value is demanded, demand x and x and return x
14:26:10 <Cale> twobitwork: WHNF is roughly the least amount of evaluation you can do to determine the top-level constructor.
14:26:12 <Heffalump> TomMD: because deepSeq is implemented by the user in type classes
14:26:14 <quicksilver> the remarkable think about #haskell is that, on absolutely any subject, there is always someone who knows more than you.
14:26:19 <Cale> twobitwork: and you do nothing to lambdas
14:26:27 <Heffalump> WHNF is like HNF, but there's no reduction under lambdas required
14:26:32 <TomMD> ah, makes sense.
14:26:34 <Heffalump> so \x -> 5 + 5 is in WHNF, but not HNF
14:26:54 <twobitwork> because it doesn't use its argument?
14:27:11 <Heffalump> no, it's in WHNF because it's a lambda
14:27:14 <Cale> twobitwork: it's not in HNF because to put it in HNF, you'd have to reduce the 5 + 5 to 10
14:27:16 <twobitwork> ahh
14:27:16 <Heffalump> and any lambda is in WHNF
14:27:25 <twobitwork> I see
14:27:26 <dcoutts> dons: got a one line description of BSD2 for the haddock docs in Distribution.License?
14:27:47 <quicksilver> what do you call what deepSeq/rnf does?
14:28:01 <Cale> quicksilver: Normal form.
14:28:09 <quicksilver> but it doesn't go under lambdas.
14:28:16 <dcoutts> dons: hmm, I'm not sure if I should add it. I don't see it on the OSI list
14:28:19 <dons> dcoutts: the standard BSD license without the advertising and endorsement clauses
14:28:20 <roconnor> wow.  I didn't realize threads were so cheap in GHC.
14:28:22 <Cale> mm, that's true, but there's no instance for functions
14:28:28 <SamB_XP_> Cale: how come nobody mentioned other constructors ?
14:28:37 <dcoutts> dons: except apparently it's not the standard BSD license
14:28:38 <quicksilver> ah, so it's NF restricted to data.
14:28:41 <SamB_XP_> evaluating to WHNF doesn't evaluate under any constructor
14:28:44 <quicksilver> hence the alternative name NFData ;)
14:28:45 <Cale> yeah
14:28:50 <dons> dcoutts: no, it is new. NetBSD switched to it today
14:28:52 <TomMD> roconnor: I eat them like candy.  Which is why I get mad when people make too many c lib bindings and return an Errno to me!
14:28:57 <quicksilver> :t rnf
14:28:59 <lambdabot> forall a. (NFData a) => a -> Done
14:29:03 <SamB_XP_> dcoutts: why should it be on the OSI list?
14:29:05 <quicksilver> makes sense now.
14:29:12 <SamB_XP_> apparantly the OSI is not to be trusted anymore
14:29:23 <roconnor> I should use threads more in GHC.
14:29:28 <roconnor> I should use threads in GHC.
14:29:33 <dcoutts> SamB_XP_: otherwise we have to argue about it ourselves and that's too boring.
14:30:07 <dcoutts> dons: I'll hold off adding it 'til it's on the OSI recommended list. You'll have to use OtherLicense for now.
14:31:23 <SamB_XP_> dcoutts: you could just see how the argument goes on debian-legal
14:31:46 <dcoutts> aye
14:32:00 <glguy> dcoutts: is the OSI recommended list a subset of OSI approved licenses?
14:32:00 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:33:26 <roconnor> hmm a `seq` a
14:33:34 <roconnor> didn't ndm complain about this recently
14:34:15 <quicksilver> according to the definiton of seq, a `seq` a should be indistinguishable from a, no?
14:34:42 <roconnor> I hope Bryan isn't in charge of the seq chapter in RWH
14:34:44 <roconnor> :)
14:34:52 <dcoutts> glguy: yep
14:35:00 <byorgey> quicksilver: indeed.
14:35:01 <quicksilver> why what did he say/do?
14:35:09 <TomMD> x `seq` x
14:35:10 <mmorrow> quicksilver: i believe it essentially says "evaluate a before evaluating a"
14:35:12 <dcoutts> glguy: see http://www.opensource.org/licenses/category
14:35:14 <lambdabot> Title: Open Source Licenses by Category | Open Source Initiative
14:35:20 <SamB_XP_> mmorrow: when
14:35:22 <SamB_XP_> not before
14:35:23 <TomMD> which, when I asked about it (look up), spawned this conversation.
14:35:30 <roconnor> quicksilver: he is demoing a simple example of `seq`
14:35:40 <roconnor> in his concurent haskell video
14:35:42 <byorgey> more accurately, it says "when you need to evaluate a, evaluate a first"
14:35:47 <TomMD> Great talk, btw
14:35:48 <roconnor> ... a little too simple.
14:35:49 <TomMD> You should see it
14:35:54 <SamB_XP_> byorgey: not that it must happen first
14:36:02 <roconnor> I'm watching it now.
14:36:16 <SamB_XP_> there is no time involved in seq
14:36:18 <mmorrow> SamB_XP_: i believe it's *before*, but in this case before==when
14:36:29 <glguy> dcoutts: and MIT license is in the same category as GPL, right?
14:36:35 <glguy> (or is that not what we're talking about)
14:36:36 <roconnor> But this `seq` example makes me uncomfortable.
14:36:46 <quicksilver> SamB_XP_: well there is time in a sense.
14:36:53 <SamB_XP_> not really
14:37:10 <quicksilver> the sense is, that, in a `seq` b, a is evaluated 'before' the value of b can be inspected
14:37:11 * roconnor cries
14:37:12 <mmorrow> SamB_XP_: oh i see how you meant when
14:37:15 <quicksilver> that is a kind of time.
14:37:22 <sutats> What's the recommended library for GUI work in Haskell?
14:37:24 <SamB_XP_> it's about whether or not the expression as a whole has a non-bottom value
14:37:29 <bos> sutats: gtk2hs
14:37:34 <sutats> bos: Thanks.
14:37:50 <quicksilver> yes but the only way to check if its not-bottom is to evaluate it to whnf
14:37:56 <quicksilver> and that takes time, being a computation.
14:38:02 <SamB_XP_> a `seq` a ==> _|_ when a ==> _|_ or a ==> _|_
14:38:07 <quicksilver> and that time is taken before the value of b can be inspected.
14:38:09 <mmorrow> SamB_XP_: of course the first argument to seq is only evaluated when the second arg is evaluted
14:38:40 <quicksilver> there is a reason that 'seq' is short for sequence, and sequencing is meant in the sense of time.
14:38:47 <SamB_XP_> more generally...
14:38:55 <SamB_XP_> a `seq` b ==> _|_ when a ==> _|_ or b ==> _|_
14:38:58 <dons> sutats: gtk2hs
14:39:01 <TomMD> > let a = 5 in let b = undefined in let c = b `seq` a in c
14:39:03 <SamB_XP_> that's ALL seq means
14:39:03 <lambdabot>  Exception: Prelude.undefined
14:39:35 <SamB_XP_> (unless you want to differentiate between different _|_ values)
14:39:36 <quicksilver> SamB_XP_: that's the semantics of seq, sure.
14:39:55 <quicksilver> SamB_XP_: but the only possible operational definition is to evaluate a first.
14:40:02 <quicksilver> therefore there is a sense of time.
14:40:09 <SamB_XP_> quicksilver: not nessarily
14:40:15 <quicksilver> yes, necessarily.
14:40:20 <quicksilver> because of the halting problem.
14:40:32 <quicksilver> the only way to establish if a is non-bottom is to run the program.
14:40:40 <SamB_XP_> compilers can do things sometimes that they can't always do
14:40:43 <mmorrow> SamB_XP_: using unsafePerformIO and mvars w/in externally pure functions requires the use of seq in such a way that it ensured evaluation of certain expression *before* others (so you don't ever end up takeMVaring an empty mvar)
14:41:10 <quicksilver> compilers respect a stronger definition of seq :)
14:41:17 <SamB_XP_> perhaps so
14:41:22 <quicksilver> the definition of seq respected by compilers is very much the sequencing one.
14:41:49 <quicksilver> (something very slow to compute) `seq` 0
14:41:54 <SamB_XP_> I think that depends on whether they see wwhat it does or not
14:41:59 <quicksilver> will compute the slow thing before the 0 can be inspected.
14:42:34 <SamB_XP_> and also you've forgotten the possibility of cyclic seqs
14:43:21 <ddarius> quicksilver: It would be perfectly legal to evaluate a then b in b `seq` a.
14:43:43 <quicksilver> ddarius: as long as b gets evaluated before a can be inspected by the caller.
14:43:55 <quicksilver> ddarius: the point is not the time-ordering of the evaluation of a and b
14:44:15 <quicksilver> ddarius: the point is the time ordeing of the evaluation of b and the inspection of a.
14:45:28 <quicksilver> that is the sense in which seq is about time.
14:45:36 <quicksilver> and whilst I agree it is a weaker one that sometimes assumed
14:45:44 <quicksilver> I maintain there is still a notion of time.
14:45:51 <quicksilver> evaluation of one before inspection of the other.
14:46:45 <mmorrow> i agree
14:46:45 <luite> I just compiled GHC 6.8.3 and tried import Text.Regex, but it cannot find it. do I need another package (extralibs?) for this?
14:47:18 <quicksilver> correct.
14:47:20 <quicksilver> extralibs.
14:47:29 <quicksilver> if you compile a "bare" GHC you get very few libraries.
14:47:39 <quicksilver> the big bundle binary packages traditionally include many more.
14:47:43 <luite> ok, thanks
14:48:09 <roconnor> oh noes
14:48:15 <luite> yes, I always used binaries but decided I wanted to build it from source this time :)
14:48:28 <roconnor> Bryan also gets the defintion of weak head normal form and head normal form wrong.
14:48:52 <ddarius> quicksilver: I think what you are saying is pretty trivial and still false, although not false in practice.
14:48:54 <bos> i do?
14:49:19 <roconnor> bos = bryan?
14:49:29 <ddarius> Bryan also makes fun of little girls.
14:49:39 <quicksilver> ddarius: how is it false?
14:49:49 <bos> roconnor: what did i say?
14:49:57 <ddarius> quicksilver: b need not be evaluated at all if the compiler knows it's non-bottom.
14:49:59 <quicksilver> and what on earth does "false although not false in practice" mean?
14:50:39 <ddarius> quicksilver: It means there exists implementations of seq that wouldn't would make it false, but none of them are used in practice.
14:50:40 <roconnor> bos: normal form is when an expression is completely evaluated.  ie there are no redexes.
14:51:09 <bos> roconnor: i know what they are, i just don't know what i *said*.
14:52:01 <roconnor> bos: From what you say in your video, you are describing normal form when you talk about head normal form.
14:52:16 <roconnor> and you are describing head normal form when you talk about weak head normal form.
14:52:29 <roconnor> or at least that is how it sounds to me.
14:52:29 <bos> roconnor: ah. presumably a braino.
14:53:03 <quicksilver> ddarius: well it depends what you think "evaluated" means.
14:53:08 <roconnor> bos: oh good.  I figured you didn't know the definitions.  The distinctions can be subtle and techinical.
14:53:26 <quicksilver> ddarius: if you think "evaluated" means "reduced to WHNF" then you are of course correct, since the haskell report does not mention WHNF when defining seq.
14:53:33 <roconnor> there is only a difference between WHNF and HNF for lambda expressions.
14:53:42 <roconnor> otherwise they are the same.
14:53:46 <quicksilver> ddarius: if you think "evaluated" means "proved to be non-bottom" then I was right in what I said.
14:54:05 <roconnor> and typically we use seq etc on inductive types where WHNF and HNF are the same.
14:54:20 <SamB> quicksilver: it would be hard to justify such a definition of "evaluated"
14:54:28 <quicksilver> ddarius: and the two are closely related since for total functions, strict or lazy is a compiler choice with no semantics consequences.
14:54:38 <bos> roconnor: right.
14:55:00 <Korollary> bos on video?
14:55:26 <roconnor> bos: I'm really enjoying your video
14:55:27 <quicksilver> ddarius: however there is no denying that the haskell report, whilst giving the weak formal definition, has accompanying text which strongly hints they wanted slightly more.
14:55:29 <SamB> and actually the compiler could get away with proving that the other expression will bot be bottom unless *this* one is, too
14:55:34 <roconnor> bos: even if I am nit picking.
14:55:36 <quicksilver> "Sometimes it is desirable to force the evaluation of a value, using the seq function"
14:56:09 <bos> roconnor: i don't mind making mistakes, i'd be a pretty unhappy person if they bothered me much given their frequency :-)
14:56:40 <SamB> quicksilver: well, I think generally what's wanted there is to get rid of heap clutter from unevaluated thunks
14:56:48 <roconnor> bos: I guess ndm told you about a `seq` a already then. :)
14:57:13 <Korollary> bos: we all know that you're still haunted by forgetting where your remote was ten months ago.
14:59:49 <RayNbow> the world needs more Haskell related videos :p
15:00:04 <RayNbow> or at least FP related
15:03:20 <roconnor> Hmm, I wonder if these data dependencies comes from the compiler not knowing which operations are associative.
15:03:24 <sutats> If I do "main = interact (take 5)" I'm getting the first 5 bytes from stdin, right?
15:05:19 <RayNbow> sutats: well, sort of
15:05:30 <RayNbow> it depends on your definition of "getting"
15:05:46 <sutats> RayNbow: Could you elaborate on that?
15:06:47 <rwbarton> sutats: yes, you wrote 'head --bytes=5'
15:06:57 <RayNbow> well, "main = interact (take 5)" does display the first 5 characters from stdin to stdout
15:08:38 <rwbarton> I was expecting it to actually display the first 5 Unicode characters, but I tested it and it only wrote the first 5 bytes
15:09:08 <RayNbow> rwbarton: that's probably because String = [Char] and Char is most likely defined to be a single byte
15:09:09 <roconnor> rwbarton: IO in ghc is broken for non-ascii characters
15:09:28 <sutats> Ah, interesting.
15:09:44 <rwbarton> > maxBound :: Char
15:09:45 <lambdabot>  '\1114111'
15:09:49 <RayNbow> hmm
15:09:56 <RayNbow> then I'm wrong :p
15:09:56 <SamB_XP_> nobody has exactly figured out what it should work like yet though
15:10:05 <sutats> Now is it possible to specify the number of bits I read in?
15:10:32 <RayNbow> well, the problem of handling unicode I/O is that you don't know the encoding
15:10:36 <roconnor> knowing your input character encoding seems to be a somewhat difficult problem.
15:10:58 <rwbarton> I see.  Fair enough
15:11:08 * RayNbow pokes cmd.exe
15:11:14 <roconnor> rwbarton: sorry :(
15:11:24 * SamB_XP_ looks longingly at plan9
15:11:25 <RayNbow> I have no idea what encoding Windows' command line uses
15:11:34 <SamB_XP_> I think it uses UTF-16
15:11:45 <RayNbow> SamB_XP_: it doesn't like Japanese characters
15:11:48 <SamB_XP_> I'm not kidding
15:12:16 <bd_> RayNbow: it might be the non-unicode charset, which depends on your locale
15:12:18 <SamB_XP_> but programs that use A routines for I/O won't get any of this functionality
15:12:26 <bd_> default english would be ISO-8859-1 probably
15:12:43 <SamB_XP_> the MS version of that, anyway
15:13:01 <SamB_XP_> which they never claim to actually be that
15:13:05 <RayNbow> bd_: probably, because cmd.exe here does support characters with accents
15:13:15 <RayNbow> stuff like "ë"
15:13:25 <SamB_XP_> oh, I might actually be talking about csrss rather than cmd.exe
15:13:45 <SamB_XP_> csrss apparantly being the program that actually implements the terminal windows
15:14:18 <BMeph> Windows uses code page 1251, normally, I believe.
15:14:43 <BMeph> For you, though, RayNbow, yeah - it's anyone's guess.
15:15:15 <RayNbow> hmm, I wonder what would happen if I run cmd.exe using Microsoft AppLocale :p
15:15:42 <BMeph> In fact, that may be the latest project they have Simon, or maybe Erik Meijer, working on. ;p
15:17:43 * RayNbow switches from bitmap fonts to TrueType fonts
15:17:53 <sutats> Is it possible to specify the number of bits to read in with readFile?
15:18:07 <RayNbow> bits?
15:18:07 <rwbarton> sutats: what does it even mean to read in 3 bits?
15:18:57 <sutats> rwbarton: I'm not really sure, to be honest. How do bitstreams works?
15:18:59 <sutats> *work
15:19:38 <rwbarton> Up to you, you're the one asking the question :)
15:19:54 <rwbarton> But a file is really a sequence of numbers from 0 to 255.
15:20:36 <rwbarton> do you have some particular format you're trying to read that talks about sequences of bits?
15:20:40 <BMeph> (After reading up on AppLocale...) Ah, CP-1252 is US. Close, but no banana. :)
15:21:45 <sutats> rwbarton: Not in particular, I'm reading up on bitstreams and was just curious if it could be implemented in Haskell.
15:22:27 * monochrom revisits bananas, wiretaps, etc.  oops s/wiretaps/barbed wires/
15:22:27 <roconnor> @faq can Haskell do bitstreams
15:22:28 <lambdabot> The answer is: Yes! Haskell can do that.
15:22:35 <roconnor> :)
15:22:43 <sutats> roconnor: Haha, that answers my question then.
15:23:10 <roconnor> sutats: have you seen Data.Binary ?
15:23:48 <rwbarton> You could write unpackByte :: Word8 -> [Bit] and then use concatMap unpackByte . readFile
15:24:02 <sutats> roconnor: No, I haven't.
15:24:23 <sutats> rwbarton: Would that be in the Data.Binary library that roconnor just mentioned?
15:24:26 <jadrian> getting back to speed with haskell is kind of weird...
15:24:50 <roconnor> UArray Bool is nice because it is bit packed
15:24:51 <jadrian> some obvious details are not obvious anymore...
15:24:53 <jadrian> for instance
15:25:20 <jadrian> why is the type of foldr
15:25:24 <jadrian>    foldr :: (a -> b -> b) -> b -> [a] -> b
15:25:26 <jadrian> and not
15:25:34 <jadrian>    foldr :: (a -> b -> b) -> [a] -> b -> b
15:25:53 <RayNbow> arbitrary choice? :p
15:25:59 <roconnor> jadrian: because (a -> b -> b) and b correspond to the two constructors for lists
15:26:04 <roconnor> so they are together
15:26:28 <BMeph> jadrian: That's easy! Because you "want" to specify the null condition first, beffore you give it a list to work on.
15:27:25 <RayNbow> @pl foldr' f xs z = foldr f z xs
15:27:26 <lambdabot> foldr' = flip . foldr
15:27:43 <jadrian> BMeph: not so sure about that... but I agree by that line of reasoning, foldl and foldr should have the same type
15:27:54 <jadrian> BMeph: so my argument wouldn't make sense anymore
15:28:05 <BMeph> jadrian: A better question is, "why is the type of foldr not
15:28:09 <BMeph>  foldr :: b -> (a -> b -> b) -> [a] -> b
15:28:19 <jadrian> roconnor: not sure if I understood that one
15:28:29 <RayNbow> :t (:)
15:28:31 <lambdabot> forall a. a -> [a] -> [a]
15:28:38 <RayNbow> :t []
15:28:40 <lambdabot> forall a. [a]
15:28:55 <jadrian> roconnor: ah wait got it
15:28:56 <RayNbow> substitute b for [a]
15:29:09 <jadrian> roconnor: makes sense indeed
15:29:24 <jadrian> BMeph: well for me that was kind of obvious
15:29:35 <jadrian> BMeph: if you visualise how it works you get
15:30:14 <BMeph> I'd recommend Cale's diagrams for foldr on his wiki. Also, check the library definition of "fold" in Data.Foldable.
15:30:42 <jadrian> BMeph: a1 * (...  *(an * b) ...)
15:30:43 <BMeph> jadrian: Hmm, I guess it ought to be:
15:30:59 <monochrom> foldr's parameters are arranged in that order so that you can write map f = foldr ((:) . f) [].  Imagine how you would write it with some other parameter order.
15:31:01 <jadrian> BMeph:  with the a's on the left and the b on the right
15:31:19 <BMeph>          foldr :: a -> (b -> a -> a) -> [b] -> a
15:31:33 <ddarius> monochrom: foldr [] ((:) . f)
15:31:36 <jadrian> monochrom: yeap got it, you're all right
15:31:46 <dolio> No, don't do that. It's bad enough that foldl does that.
15:32:16 <dolio> Although I guess if they both did it, it'd be less confusing.
15:32:19 <BMeph> dolio: does what? Or is that which? :)
15:32:24 * monochrom blinks
15:32:28 <monochrom> @type foldr
15:32:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:32:42 <jadrian> I started thinking about it because it seemed like it would make sense to have foldr  taking a function
15:32:56 <jadrian> (a->b->b)
15:32:59 <jadrian> and making it
15:33:06 <jadrian> ([a]->b->b)
15:33:07 <dolio> BMeph: In foldr, the as and bs are the opposite types from foldl.
15:33:18 <hpaste>  morrow pasted "js trees" at http://hpaste.org/8445
15:33:18 <jadrian> which would be consistent with what foldl does
15:33:32 <jadrian> but yeap, I can see the point now
15:33:35 <dolio> monochrom: A better example is (++) = foldr (:)
15:33:53 <monochrom> nice
15:35:33 <jadrian> I wish we were using unicode by now and had some nice compact simbols for all these operations
15:35:37 <dolio> jadrian: The general answer is that foldr/l have their arguments in the order in which they're most likely to be partially applied, which conserves flips/lambda expressions.
15:35:42 <jadrian> including fliping
15:36:19 <mmorrow> > foldl (flip (:)) [] $ "asdf"
15:36:21 <lambdabot>  "fdsa"
15:36:31 <jadrian> dolio: yeap, I understand that, I was just trying to think how that reasoning lead to this decision
15:36:35 <loop> jadrian: you can easily make emacs replace "map" etc. with some nice unicode symbol ;)
15:36:36 <edwardk> ddarius: can you think of any references that make heavy use of comma categories?
15:37:43 <dolio> I have some paper that orders them differently to emphasize the lifting aspect of the function.
15:37:47 <jadrian> loop: not so sure about easily... I looked at the x-symbol thing before
15:37:59 <jadrian> loop: writing a grammar for it would take time
15:38:17 <dolio> reducer :: (a -> b -> b) -> [a] -> b -> b, reducel :: (b -> a -> b) -> b -> [a] -> b
15:38:23 <jadrian> loop: but yeah it would be nice to have something like proof general for haskell
15:38:35 <ddarius> edwardk: Yes, with some effort.
15:39:36 <edwardk> ddarius: in particular i'm curious if you can think of anything that uses them with identity functors on one side or the other where the other is _not_ a selection functor.
15:40:21 <ddarius> I don't know what you mean by "selection" functor, but there are plenty of examples of comma categories with Id on one side or the other.  That is intimately related to adjunctions.
15:40:51 <ddarius> Lawvere uses them in one of his papers on direct categorical axiomitization of CT.
15:41:18 <loop> jadrian: there are some solutions
15:41:19 <edwardk> ddarius: In the sense of http://en.wikipedia.org/wiki/Comma_category, where a selection functor is just a functor from the discrete category that picks out some object of the target category (used in slice and coslice categories to fix one end of an arrow)
15:41:22 <loop> jadrian: http://mult.ifario.us/p/emacs-haskell-mode-unicode-cuteness
15:41:23 <lambdabot> Title: emacs-haskell-mode-unicode-cuteness
15:41:59 <loop> some regexp-based stuff exists also
15:49:43 <ddarius> edwardk: Read the early chapters of http://tac.mta.ca/tac/reprints/articles/5/tr5abs.html (there is some commentary at the beginning)
15:49:44 <lambdabot> Title: Functorial Semantics of Algebraic Theories
15:51:16 <jadrian> loop: thanks!
15:52:05 <jadrian> loop: pretty cool didn't know that
15:53:29 <loop> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Unicodifying_symbols_.28Pretty_Lambda_for_Haskell-mode.29 there's another approach
15:53:31 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/yyqy4v
15:53:40 <solrize> :t Data.Map.lookup
15:53:42 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
15:56:52 <dolio> @seen dons
15:56:52 <lambdabot> dons is in #arch-haskell, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 1h 17m 54s ago.
15:57:04 <edwardk> ddarius thanks
15:58:50 <dolio> @tell dons FYI: uvector doesn't currently build on 6.9 "A newtype constructor cannot have a strictness annotation,but `MUARatio' does" etc.
15:58:51 <lambdabot> Consider it noted.
16:00:30 <jadrian> loop: ah cool
16:06:43 <monochrom> @pl \a xs -> j (c a xs)
16:06:43 <lambdabot> (j .) . c
16:07:04 <monochrom> @pl \xs -> j (c a xs)
16:07:04 <lambdabot> j . c a
16:10:25 <dolio> dons: Removing all the strictness annotations fixes it (no other errors).
16:14:23 * byorgey watches bos's talk
16:14:58 <bos> byorgey: your challenge is to find a novel mistake that hasn't been reported by someone else in #haskell :-)
16:15:17 <byorgey> hehe, ok, let's see...
16:15:29 <byorgey> hmm, looks like your fly was unzipped
16:16:17 <bos> that's just the camera's face recognition.
16:18:08 <solrize> @hoogle ByteString -> String
16:18:09 <lambdabot> No matches, try a more general search
16:18:44 <byorgey> I think that function is called 'unpack'
16:19:08 <solrize> unpack makes a [Word8]
16:19:23 <mauke> not the one in .Char8
16:19:44 <solrize> hmm ok
16:20:05 <solrize> thanks, i guess i have to convert all these bytestrings to bytestring.char8's
16:20:46 <mauke> just change the import line
16:21:08 <solrize> yeah, i had to do it in a few files
16:21:30 <mauke> do they all use unpack?
16:22:22 <edwardk> ddarius: that helped quite a bit, thanks
16:22:24 <solrize> i pass bytestring values between functions that are in different files
16:22:35 <solrize> so they have to agree w/each other
16:22:39 <mauke> they do
16:22:41 <mauke> it's the same type
16:22:50 <solrize> hmm
16:22:59 <solrize> and the stuff in the file is a mixture of ascii and unicode
16:23:10 <solrize> and binary
16:31:49 <pgavin> @seen dcoutts_
16:31:49 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 6h 13m 31s ago.
16:38:18 <dcoutts> hia pgavin
16:40:45 <dcoutts> pgavin: catch me in the morning, I'm off to bed.
16:42:13 <MyCatVerbs> Am I the only one who finds that vim's indentation for Haskell sucks?
16:42:45 <cremetorte> hi i try to get Lambdabot to join my irc but i cant even get it isntalled on my server. anyone here with experience topic.lambdabot
16:45:53 <MyCatVerbs> @index finally
16:45:53 <lambdabot> Control.Exception, Distribution.Compat.Exception
16:46:38 <Cale> MyCatVerbs: I find it tolerable.
16:47:05 <Cale> MyCatVerbs: But I have low standards. If the indenter puts the cursor in the same column as the last line started on, I'm happy.
16:47:06 <mar77a> is it common practice to use a single space instead of tab?
16:47:22 <Cale> mar77a: It's common practice never to include tab characters in source files.
16:47:29 <SamB> mar77a: what do you mean "instead of tab"?
16:47:38 <Cale> mar77a: Have your editor convert them, since alignment matters, and tab screws with that.
16:47:45 <SamB> why would you have used tab in the first place?
16:47:57 <mauke> for flexible indentation!
16:48:01 <mar77a> instead of hitting TAB
16:48:04 <mar77a> using the space bar
16:48:12 <SamB> eh?
16:48:18 <SamB> you mean in key bindings?
16:48:18 <mauke> who hits TAB anyway?
16:48:20 <Cale> mar77a: oh, usually I press the tab key in order to insert a bunch of spaces.
16:48:33 <mauke> tab is for completing identifiers
16:48:37 <Cale> mauke: hehe
16:48:42 <byorgey> mar77a: what editor are you using?
16:48:52 * Cale is more interested in mauke's editor :)
16:49:01 <mauke> vim
16:49:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8446
16:49:08 <byorgey> in emacs + haskell-mode, the tab key just deals with indentation, but it actually inserts spaces.
16:49:12 <mar77a> notepad++ and nano
16:49:15 <Cale> mauke: Is your configuration available anywhere?
16:49:17 <mar77a> but i mean like this: http://hpaste.org/8446
16:49:37 <Cale> mar77a: Nobody cares how much you indent things, so long as they line up correctly.
16:49:51 <mar77a> perfect
16:49:57 <mauke> Cale: hmm, parts of it are at http://mauke.ath.cx/stuff/vim/
16:49:58 <lambdabot> Title: Index of /stuff/vim
16:49:59 <mar77a> why bother using the TAB key or character at all
16:50:03 <Cale> That second example, I would normally write 'stuff' after the 'do', and line things up with that.
16:50:31 <solrize> is there a way in the ghci debugger (or elsewhere) that i can find out the type of a local expression inside a function?
16:50:42 <shachaf> mauke: Is it "smart" completion of some sort or just ^P?
16:50:49 <mauke> shachaf: smart
16:51:13 <hpaste>  Cale annotated "(no title)" with "like this" at http://hpaste.org/8446#a1
16:51:33 <mar77a> ah but then you gotta rape the spacebar
16:51:43 <mar77a> unless the editor auto-detects
16:51:47 <hpaste>  Cale annotated "(no title)" with "or potentially like this" at http://hpaste.org/8446#a2
16:51:50 <mauke> you mean the tab key
16:52:25 * Cale wants type and syntax sensitive completion :)
16:52:38 <mar77a> @hoogle getCurrentDirectory
16:52:39 <lambdabot> System.Directory.getCurrentDirectory :: IO FilePath
16:52:54 <SamB> Cale: that sounds hard
16:53:09 <mauke> heh, with djinn integration
16:53:18 <mauke> you write a type signature and it completes the implementation for you
16:53:22 <cremetorte> 87-79-70-140
16:53:23 <Cale> :)
16:53:35 <SamB> that would require the editor to determine what all types could be potentially interconverted with it's concept of the calling context!
16:53:57 <SamB> and plus what if you were going to type an infix operator afterwards?
16:55:07 * BMeph hugs his shiny new GHC 6.8.3 with Cabal 1.4
16:55:36 <SamB> that's nuthin
16:55:48 <SamB> I got me a GHC 6.8.2 with a cabal 1.5.1
16:56:16 <mauke> when will haddock be updated?
16:56:51 * roconnor kicks his rusty GHC 6.61 with Cabal 1.1.6.2
16:56:55 <roconnor> 6.6.1
16:57:10 <hpaste>  morrow pasted "seq-related" at http://hpaste.org/8447
16:57:27 <BMeph> SamB: I finagled Cabal 1.4 out while 1.5.1 was HEAD, but 1.2 was still "the official" version. It's a sentimental attachment. :)
16:57:29 <SamB> BMeph: cabal install cabal-install
16:58:24 * BMeph watches Cabal 1.4.0.1 now install on the system
16:58:26 <hpaste>  morrow annotated "seq-related" with "(no title)" at http://hpaste.org/8447#a1
16:58:32 <mar77a> > let fac n = if n < 0 then error "Undefined" else (if n == 0 then 1 else n * fac (n-1)) in fac 2.5
16:58:33 <lambdabot>  Exception: Undefined
16:58:33 <SamB> BMeph: what?
16:58:41 <SamB> did they unrelease 1.5.1?
16:58:44 <mar77a> why does it give undefined on floating point input?
16:58:49 <SamB> or did you forget to update the listing from hackage?
16:59:01 <mar77a> ah got it nvm
16:59:05 <mauke> mar77a: because you told it to
16:59:16 <mar77a> x)
16:59:40 <mar77a> at one point it's doing .something -1 which makes the n < 0 bit true
16:59:52 * BMeph waits patiently for the "unsafePerformSeqs" jokes to appear...
17:00:18 <SamB> BMeph: I don't get it
17:00:18 <SamB> what would that function really do?
17:00:50 <BMeph> SamB: Geez, dude, I updated yesterday. You didn't say to update again... ;p
17:01:04 <BMeph> ...
17:01:33 <MyCatVerbs> Ack, damn thing. Anyone have any idea why openFile might be refusing outright to touch a FIFO?
17:01:37 <cremetorte> is it even possible to get Lambdabot for my own irc ?
17:01:40 <BMeph> SamB: It performs seqs, unsafely, of course. ;)
17:01:45 <SamB> BMeph: huh!
17:01:53 <SamB> did they pull it ???
17:02:35 * BMeph decides to update again, "just in case"...
17:02:35 <MyCatVerbs> cremetorte: it's an IRC bot. It's a program that you run on any computer you like, and it logs onto an IRC server.
17:03:00 <MyCatVerbs> cremetorte: the answer, unfortunately, is "maybe not", because even though you can have the source code and everything quite happily, it's quite difficult to set up.
17:03:20 <cremetorte> k
17:03:21 <MyCatVerbs> cremetorte: (lambdabot is quite difficult to get set up, I mean. Most IRC bots aren't so painful.)
17:03:51 <cremetorte> so i just let it be ;)
17:04:10 <SamB> cremetorte: and unfortunately we can't just give you a binary since you need to rebuild after changing the configuration...
17:04:50 <SamB> perhaps it should be turned into a library instead of an application?
17:05:39 <cremetorte> i dont think that many people wants Lambdabot for their own ircd 's.. so its not really necessairy to think about it
17:05:53 <Guest11180> evening
17:05:59 <Guest11180> bah
17:06:09 <michie1> anyone familiar with building gtk2hs?
17:06:27 <michie1> it's throwing up a "Failed to load interface for `System.Glib.UTFString'"
17:06:38 <SamB> try cleaning?
17:06:46 <michie1> and a google search turns up sources that suggest it's something that was fixed in 2006
17:07:26 <michie1> (ghc 6.8.2, gtk2hs 0.9.12.1)
17:07:40 <michie1> SamB: make clean doesn't change it, unfortunately
17:09:48 <cremetorte> foldr (+) 0 [1..20]
17:09:56 <BMeph> I'd prefer having unpl w/o having to host/reference lambdabot, though. :)
17:11:02 <mmorrow> > foldr (+) 0 [0..1000000]
17:11:04 <lambdabot>  Exception: stack overflow
17:11:08 <mmorrow> > foldl (+) 0 [0..1000000]
17:11:10 <lambdabot>  500000500000
17:11:14 <mmorrow> > foldl' (+) 0 [0..1000000]
17:11:15 <lambdabot>  500000500000
17:12:09 <mar77a> > foldr (/) 0 [1..10]
17:12:10 <lambdabot>  0.0
17:12:14 <mar77a> > foldl (/) 0 [1..10]
17:12:15 <lambdabot>  0.0
17:12:18 <mar77a> o_O
17:12:49 <mar77a> isn't on of those two supposed to do a (/0) at one point
17:13:49 <mmorrow> > foldr (/) 1 [1..10]
17:13:50 <lambdabot>  0.24609375
17:13:56 <rwbarton> The left-to-right order of the arguments is always preserved
17:14:19 <Saizan> > foldl f z [1,2,3]
17:14:20 <lambdabot>  f (f (f z 1) 2) 3
17:14:27 <Saizan> > foldr f z [1,2,3]
17:14:28 <lambdabot>  f 1 (f 2 (f 3 z))
17:14:33 <mar77a> there
17:14:41 <rwbarton> oops I lied
17:14:52 <mmorrow> yeah i dunno whats going on with the foldr
17:14:55 <rwbarton> > 1/(2/0)
17:14:56 <lambdabot>  0.0
17:15:02 <rwbarton> > 2/0
17:15:03 <lambdabot>  Infinity
17:15:17 <mmorrow> oh, of course
17:15:37 <ddarius> > foldr div 0 [1..10]
17:15:38 <lambdabot>  Exception: divide by zero
17:15:41 <Saizan> > foldr (/) 0 [1..9]
17:15:42 <lambdabot>  Infinity
17:15:55 <mmorrow> > foldr (/) 0 [1..10]
17:15:56 <lambdabot>  0.0
17:16:02 <mar77a> is it because haskell knows limits
17:16:12 <ddarius> No.
17:16:13 <mar77a> and if you divid something by something that is infinity it's zero?
17:16:17 <ddarius> It's IEEE754
17:16:29 <mauke> > foldr (/) 0 [1..10] :: Rational
17:16:30 <lambdabot>  Exception: Ratio.%: zero denominator
17:16:36 <mar77a> re
17:17:35 <mmorrow> @src Num Int
17:17:36 <lambdabot> Source not found. It can only be attributed to human error.
17:17:40 <mmorrow> @src Num
17:17:40 <lambdabot> class  (Eq a, Show a) => Num a  where
17:17:40 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:17:40 <lambdabot>     negate, abs, signum     :: a -> a
17:17:40 <lambdabot>     fromInteger             :: Integer -> a
17:19:30 <mmorrow> ahh, look at the default for (/)
17:19:32 <mmorrow>     x / y               = x * recip y
17:19:59 <mmorrow> recip (1/0)
17:20:01 <mmorrow> > recip (1/0)
17:20:02 <lambdabot>  0.0
17:20:15 <mmorrow> > let a = 1/0 in recip a
17:20:16 <lambdabot>  0.0
17:20:30 <mmorrow> > let a = 1/0 in a `seq` recip a
17:20:32 <lambdabot>  0.0
17:20:35 <mmorrow> > 1/0
17:20:36 <lambdabot>  Infinity
17:20:48 <mmorrow> crap, my theory is wrong
17:20:52 <Botje> mmorrow: not really
17:21:10 <Botje> :t (recip, (/))
17:21:11 <lambdabot> forall a a1. (Fractional a1, Fractional a) => (a -> a, a1 -> a1 -> a1)
17:21:25 <mmorrow> i've confused myself multiple times over about what's really happening
17:21:35 <Saizan> mmorrow: Infinity is a proper value for IEEE754
17:21:58 <Botje> mmorrow: the constructor for fract is really just a pair
17:21:59 <mmorrow> but why :
17:22:01 <mmorrow> > foldr (/) 0 [1..9]
17:22:02 <lambdabot>  Infinity
17:22:05 <mmorrow> > foldr (/) 0 [1..10]
17:22:07 <lambdabot>  0.0
17:22:16 <mmorrow> *this* is what i'm having trouble with
17:22:16 <Saizan> > 1/0
17:22:18 <lambdabot>  Infinity
17:22:18 <Botje> O_O
17:22:19 <rwbarton> iterate (1/) 0
17:22:22 <Botje> that's creepy.
17:22:23 <rwbarton> > iterate (1/) 0
17:22:24 <lambdabot>  [0.0,Infinity,0.0,Infinity,0.0,Infinity,0.0,Infinity,0.0,Infinity,0.0,Infini...
17:22:48 <mmorrow> oh, 1/infinity is being mapped to 0
17:24:14 <mmorrow> > fmap (foldr (/) 0 [1..n]) [9..]
17:24:15 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
17:24:24 <mmorrow> > fmap (\n -> foldr (/) 0 [1..n]) [9..]
17:24:25 <lambdabot>  [Infinity,0.0,Infinity,0.0,Infinity,0.0,Infinity,0.0,Infinity,0.0,Infinity,0...
17:25:10 <mmorrow> > let isEven n = foldr (/) 0 [1..n] == 0 in isEven 9876234
17:25:15 <lambdabot>  Exception: stack overflow
17:25:20 <mmorrow> > let isEven n = foldr (/) 0 [1..n] == 0 in isEven 984
17:25:22 <lambdabot>  True
17:36:13 <hansfbaier> @src mapM_
17:36:13 <lambdabot> mapM_ f as = sequence_ (map f as)
17:36:20 <hansfbaier> @src sequence_
17:36:20 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:37:05 <hansfbaier> @src foldr
17:37:05 <lambdabot> foldr f z []     = z
17:37:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:38:17 <hansfbaier> @src sequence
17:38:17 <lambdabot> sequence []     = return []
17:38:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:38:17 <lambdabot> --OR
17:38:17 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:38:22 <byorgey> sequence_ [m1, m2, ... mn] = m1 >> m2 >> ... >> mn >> return ()
17:40:15 <edwardk> neat: http://www.lri.fr/~sozeau/research/publications/First-Class%20Type%20Classes.pdf
17:40:17 <lambdabot> http://tinyurl.com/5omheq
17:43:58 <joey_> "has met an important success" hmm.
17:43:59 <edwardk> that paper leads to coq that is actually downright readable: http://www.lri.fr/~sozeau/repos/coq/monads/Monad.v
17:49:06 <rwbarton> Are there any computer algebra systems that use type classes?
17:50:13 * rwbarton wants sage in haskell
17:53:01 <edwardk> @seen mattam
17:53:01 <lambdabot> mattam is in ##logic and #haskell. I don't know when mattam last spoke.
17:53:07 <roconnor> ah, krita is driving me insane.
17:59:51 <solrize> :t hTell
17:59:52 <lambdabot> Not in scope: `hTell'
17:59:58 <solrize> :t IO.hTell
18:00:04 <lambdabot> Not in scope: `IO.hTell'
18:00:10 <solrize> why is that missing?  it's in the manual
18:00:16 <mar77a> hSeek?
18:00:19 <solrize> hTell
18:00:20 <mrd> haskell doesn't hKiss and hTell
18:01:42 <solrize> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Handle.html#hTell    it's scary too
18:01:43 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6ktv8e
18:03:00 <mar77a> @hoogle hTell
18:03:01 <lambdabot> System.IO.hTell :: Handle -> IO Integer
18:03:25 <mar77a> :t System.IO.hTell
18:03:27 <lambdabot> GHC.IOBase.Handle -> IO Integer
18:03:50 <solrize> http://www.haskell.org/ghc/docs/6.8.2/html/libraries/haskell98/IO.html  zomg, it's new for 6.8.3
18:03:51 <lambdabot> http://tinyurl.com/5g77gp
18:04:20 <solrize> :t evalGet
18:04:22 <lambdabot> Not in scope: `evalGet'
18:53:08 <mjk> how to get the repeat elements of a list?
18:54:26 <rwbarton> > let x = "hello world" in nub(x \\ nub x)
18:54:28 <lambdabot>  "lo"
18:55:38 <_JFT_> mjk: cycle
18:55:56 <_JFT_> mjk: if I understood you :)
18:57:45 <_JFT_> @hoogle cycle
18:57:45 <lambdabot> Prelude.cycle :: [a] -> [a]
18:57:45 <lambdabot> Data.List.cycle :: [a] -> [a]
18:57:45 <lambdabot> Data.ByteString.Lazy.cycle :: ByteString -> ByteString
18:58:04 <mjk> _JFT_: use cycle can't get them, like cycle [1,2,3,3,4] ,to get [3,3]
18:58:30 <_JFT_> mjk: sorry I misunderstood what you meant :(
18:59:19 <dolio> Is Isabelle not dependently typed or something?
19:00:40 <_JFT_> mjk:  head $ dropWhile (uncurry (/=)) $ c2 [1,2,3,3,4]
19:00:52 <_JFT_> let different = fst $  head $ dropWhile (uncurry (/=)) $ c2 [1,2,3,3,4]
19:01:31 <_JFT_> let different = fst $  head $ dropWhile (uncurry (/=)) $ ( \l -> zip l (tail l))  [1,2,3,3,4]
19:03:27 <_JFT_> let different = fst $ head $ dropWhile (uncurry (/=)) $ (\lst -> zip l
19:03:27 <_JFT_> st (tail lst)) [1,2,3,3,4]
19:03:36 <_JFT_> let different = fst $ head $ dropWhile (uncurry (/=)) $ (\lst -> zip lst (tail lst)) [1,2,3,3,4]
19:04:07 <_JFT_> mjk: well seems like I have issue with copy paste but the line does it :P (I'm sure there are nicer ways to write that and shorter too)
19:04:41 <roconnor> > let different = fst $ head $ dropWhile (uncurry (/=)) $ (\lst -> zip lst (tail lst)) [1,2,3,3,4]
19:04:41 <lambdabot>  Parse error at end of input
19:04:52 <roconnor> > let different = fst $ head $ dropWhile (uncurry (/=)) $ (\lst -> zip lst (tail lst)) in different [1,2,3,3,4]
19:04:52 <lambdabot>      The lambda expression `\ lst -> zip lst (tail lst)'
19:04:53 <lambdabot>     has one argument...
19:05:14 <roconnor> > fst $ head $ dropWhile (uncurry (/=)) $ (\lst -> zip lst (tail lst)) [1,2,3,3,4]
19:05:15 <lambdabot>  3
19:05:21 <_JFT_> roconnor: thanks :)
19:05:33 <mjk> thanks
19:05:34 <dolio> rwbarton: DoCon is some kind of symbolic algebra library written in Haskell.
19:05:49 <roconnor> > find (uncurry (==)) $ zip `ap` tail $ [1,2,3,3,4]
19:05:50 <lambdabot>  Just (3,3)
19:06:00 <dolio> Not that I've ever looked at it closely.
19:06:09 <roconnor> > fmap fst $ find (uncurry (==)) $ zip `ap` tail $ [1,2,3,3,4]
19:06:10 <lambdabot>  Just 3
19:06:22 <roconnor> @quote zip tail
19:06:22 <lambdabot> No quotes for this person. Do you think like you type?
19:06:24 <_JFT_> rconnor thanks for the `ap` trick I didn't knew that one
19:06:29 <roconnor> @quote zip
19:06:29 <lambdabot> lament says: Bullies at school used to tease little Huet: "Hey fool, your zipper's undone and the monad's sticking out!"
19:06:35 <roconnor> @quote tail
19:06:36 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:08:19 <kpreid> @type zip`ap`tail
19:08:21 <lambdabot> forall b. [b] -> [(b, b)]
19:08:33 <roconnor> requires Control.Monad.Reader
19:23:34 <mar77a> @hoogle trim
19:23:34 <lambdabot> Data.ByteString.Internal.createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
19:23:34 <lambdabot> Data.ByteString.Internal.createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
19:27:53 <noecksit> it seems so far that git is better than darcs at branching
19:30:11 <mar77a> can anyone think of a way to improve this trim function (Which gets rid of leading and suffixing whitespaces):
19:30:14 <mar77a> trim = reverse . dropSpaces . reverse . dropSpaces
19:30:17 <mar77a> dropSpaces = dropWhile isSpace
19:32:29 <rwbarton> Seems reasonably short, clear, and efficient
19:32:45 <mar77a> i thought reversing a list took a lot of time
19:32:55 <mar77a> or is it just some pointer tricks
19:33:04 <rwbarton> Well, so does traversing the list to get rid of stuff at the end
19:33:30 <rwbarton> (I meant reasonably short, reasonably clear, and reasonably efficient :)
19:34:23 <rwbarton> If you're willing to mess with internal whitespace some, consider unwords . words
19:34:54 <gubagem> which makes whitespace nonimportant, a feature of alot of languages
19:35:17 <rwbarton> (of course, if you wanted to do that, you probably wouldn't want the unwords anyways)
19:36:19 <noecksit> mar77a: how about "filter (not . isSpace)"
19:36:41 <Draconx> noecksit, that'd delete spaces in the middle.
19:37:22 <noecksit> oh true
19:45:44 <mar77a> @src (>>)
19:45:44 <lambdabot> m >> k      = m >>= \_ -> k
19:45:47 <mar77a> @src (>>=)
19:45:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:47:48 <dolio> That depends on the type.
19:47:54 <dolio> @src [] (>>=)
19:47:54 <lambdabot> xs >>= f     = concatMap f xs
19:48:40 <Axman6> how handeh
19:51:45 <mar77a> ehm
19:51:52 <mar77a> hGetLine failed (no error)
19:54:15 <hpaste>  rwbarton pasted "dropWhileFromEnd" at http://hpaste.org/8448
19:54:35 <rwbarton> ^^ That's a more lazy solution
19:59:58 <mar77a> ok i have logs in which chat is logged in the following way:
20:00:02 <mar77a> [nickname] text
20:00:18 <mar77a> i'm thinking of a way to extract the text
20:00:33 <mar77a> even if the nickname contains different combinations of "]" or "["
20:01:00 <Draconx> can the nickname contain spaces?
20:01:07 <mar77a> yes
20:01:07 <monochrom> For example "[mono[hrom] hai I <3 haskell" ?
20:01:18 <mar77a> yes
20:01:21 <monochrom> This is nasty.
20:01:26 <Draconx> mar77a, you have a difficult task ahead of you.
20:01:27 <gubagem> use a regex, or gasp perl could work really good
20:01:29 <rwbarton> presumably the text can also contain ], so this isn't possible
20:01:35 * gubagem recants of heresy
20:01:47 <mar77a> i know that the nick length is capped
20:01:51 <mar77a> 15 chars max i think
20:01:54 <monochrom> "[mono[hrom] hai I <3 haskell 8] haskell is cool" ?
20:02:04 <monochrom> It is ambiguous.
20:02:18 <gubagem> mar77a:  they are all [string] space text correct?
20:02:28 <mar77a> yes
20:02:41 <Draconx> mar77a, consider the following line: [zomg ] foo] says hi
20:02:48 <monochrom> or mine
20:02:52 <mar77a> can't tell really
20:02:58 <Axman6> @src split
20:02:58 <lambdabot> Source not found. My mind is going. I can feel it.
20:03:01 <mar77a> max nickname length is 24 characters
20:03:02 <Axman6> @src splitAt
20:03:02 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
20:03:18 <monochrom> I suggest doing something random in case of ambiguity.
20:03:23 <Draconx> mar77a, without more information, you cannot determine whether the nick is "zomg " or "zomg ] foo"
20:03:25 <Axman6> wouldn't you use something like splitAt (/= ' ') xs?
20:03:39 <mar77a> lol monochrom
20:03:55 <monochrom> (Whoever invented this stupid log format deserves getting a random treatment.)
20:04:10 <mar77a> www.soldat.pl
20:04:57 <mar77a> through scripting you have the posibility to write custom logs
20:05:11 <mar77a> but i'm parsing the default logging way since i'm connected to the admin thread
20:05:46 <monochrom> This is why we should limit programming and scripting to PhDs.  <duck>
20:06:55 <Axman6> mar77a: did you see what i said?
20:07:04 <mar77a> i did
20:07:17 <Axman6> can nicks have spaces in them?
20:07:27 <mar77a> yes
20:07:42 <Axman6> well that's just silly :)
20:09:52 <monochrom> If this is log of a shooting game, perhaps you can assume they don't actually go "[zomg ] 8] I rock!"
20:11:51 <Axman6> is there any restriction on the characters in the nick?
20:12:54 <Draconx> monochrom, I wouldn't put anything past some of the people who play that sort of game.
20:45:18 <adu> hi
20:46:55 <mar77a> ok guys
20:47:01 <adu> ya?
20:47:16 <mar77a> i found a good way to parse commands
20:47:29 <mar77a> commands which are of the form !<text>
20:47:38 <mar77a> i just search for the last "] !"
20:48:10 <Axman6> that's better
20:48:44 <mar77a> now i need to put it down to code
20:48:45 <Axman6> reverse the list, and find the first ! ] might be easier
20:48:46 <mar77a> 8)
20:49:40 <mar77a> is there a std lib function that works like PHP's explode?
20:49:56 <Axman6> what's explode do?
20:50:46 <mar77a> in practice: $a = explode("|", "1|2|3"); $a[0] = "1"; $[1] = "2"; ...
20:50:49 <rwbarton> mar77a: is words good enough?
20:51:02 <mar77a> mmm nope
20:51:30 <koninkje_away> @src intercalate
20:51:30 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
20:51:51 * koninkje_away doens't know the inverse of it off hand
20:52:02 <dolio> There isn't one, currently.
20:52:16 <mar77a> ok, time to write one then
20:52:22 <ddarius> You can use the Regex libraries to do it though.
20:52:38 <mar77a> nah, waste of program time and space
20:52:43 <mar77a> and i'd rather code it myself to learn
20:52:53 <mar77a> i remember it was a challenge coding it in c++ using vectors
20:53:25 <koninkje> If it's :: Char -> String -> [String] that makes it a lot easier ;)
20:53:51 <mar77a> [Char] -> [Char] -> [[Char]]
20:53:53 <koninkje> though less useful
20:54:12 <rwbarton> there should really be a version of isInfixOf of type Eq a => [a] -> [a] -> Maybe ([a], [a]) -- part before and after the match
20:54:27 <rwbarton> sort of like python's partition
20:54:36 <koninkje> or Perl's split
20:54:37 <mar77a> i think an explode port should be there
20:54:49 <mar77a> er, PHP's
20:54:54 <dolio> Why on earth is it called explode?
20:54:59 <mar77a> no idea
20:55:03 <mar77a> the opposite is called implode
20:55:20 <mar77a> http://www.php.net/explode
20:55:21 <lambdabot> Title: PHP: explode - Manual
20:55:23 <adu> http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html
20:55:25 <lambdabot> Title: The Julipedia: A split function in Haskell, http://tinyurl.com/fhss7
20:55:59 <adu> kinda like words and unwords
20:56:06 <adu> ?type words
20:56:08 <lambdabot> String -> [String]
20:56:40 <koninkje> > words "hello    world"
20:56:40 <lambdabot>  ["hello","world"]
20:57:01 <koninkje> mar77a: for bonus points you should see if you can make a ByteString version
20:58:33 <Axman6> @src words
20:58:33 <lambdabot> words s = case dropWhile isSpace s of
20:58:33 <lambdabot>     "" -> []
20:58:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
20:58:35 <mar77a> can i trade bonus points for euros?
20:59:00 * koninkje can't verify the exchange rate
20:59:12 <mar77a> 1:5000 ofc
21:00:26 <chessguy> hmm, that split function does appear to be approvable
21:00:30 <adu> hmm
21:00:32 <chessguy> er, improvable
21:00:41 <adu> I almost hhave a short version of split
21:00:49 <adu> groupBy (const (/=' '))
21:01:13 <dolio> That version of words duplicates work, I think.
21:01:20 <chessguy> @type groupBy (const (/=' '))
21:01:23 <dolio> ndm optimized it a while back.
21:01:23 <lambdabot> [Char] -> [[Char]]
21:01:58 <chessguy> adu:  you're forgetting, it needs to allow for an arbitrary delimiter
21:02:50 <adu> chessguy: no I'm not, the /=' ' could be replaced by /=','
21:03:01 <mofmog> so i've been boning up on my C skills
21:03:16 <mofmog> boy... that sure was different
21:03:25 <chessguy> @pl \delim -> groupBy (const (/= delim))
21:03:25 <lambdabot> groupBy . const . (/=)
21:03:50 <chessguy> adu:  i suspect this is what you mean then
21:03:56 <adu> chessguy: almost
21:04:09 <adu> > groupBy (const (==' ')) "Hello Cruel World"
21:04:11 <lambdabot>  ["H","e","l","l","o ","C","r","u","e","l ","W","o","r","l","d"]
21:04:29 <adu> > groupBy (const (/=' ')) "Hello Cruel World"
21:04:30 <mofmog> so... you can write an OS in haskell correct?
21:04:30 <lambdabot>  ["Hello"," Cruel"," World"]
21:04:40 <adu> the problem is that it keeps the spaces at the beginning
21:04:46 <dolio> @type let breaks p l = case dropWhile p l of [] -> [] ; (h:t) -> let (i, t') = break p t in (h:i) : breaks t' in breaks
21:04:49 <mofmog> so in a perfect world where everyone loved functional programming, you could have haskell in place of C right?
21:04:49 <lambdabot>     Couldn't match expected type `[a]'
21:04:49 <lambdabot>            against inferred type `a -> Bool'
21:04:49 <lambdabot>     Probable cause: `breaks' is applied to too few arguments
21:05:04 <ivanm> mofmog: except that ghc uses C...
21:05:07 <mofmog> good point
21:05:15 <mofmog> but you could write ghc in assembly
21:05:16 <adu> mofmog: yes, see the "House" project
21:05:49 <adu> mofmog: yes, since haskell is compiled
21:07:03 <adu> @pl \c str -> map tail $ groupBy (const (/=' ')) ([c] ++ str)
21:07:03 <lambdabot> ((map tail . groupBy (const (' ' /=))) .) . (:)
21:07:25 <adu> @pl \c str -> map tail $ groupBy (const (/=c)) ([c] ++ str)
21:07:25 <lambdabot> (map tail .) . ap ((.) . groupBy . const . (/=)) (:)
21:07:32 <chessguy> @type \d -> groupBy (const (/=d)) (dropWhile ((==)' ')
21:07:34 <lambdabot> parse error (possibly incorrect indentation)
21:07:52 <Axman6> mofmog: device drivers would be a little hard in haskell
21:08:00 <koninkje> @where house
21:08:01 <lambdabot> http://programatica.cs.pdx.edu/House/
21:08:10 <adu> > explode "Hello Curel World" where explode = (map tail .) . ap ((.) . groupBy . const . (/=)) (:)
21:08:11 <lambdabot>  Parse error at "where" (column 29)
21:08:13 <chessguy> @type \d s -> groupBy (const (/=d)) (dropWhile ((==)' ') s)
21:08:14 <lambdabot> Char -> [Char] -> [[Char]]
21:08:18 <dolio> > let breaks p l = case dropWhile p l of [] -> [] ; (h:t) -> let (i, t') = break p t in (h:i) : breaks p t' in breaks (=='|') "a|b|c"
21:08:19 <lambdabot>  ["a","b","c"]
21:08:36 <chessguy> @pl \d s -> groupBy (const (/=d)) (dropWhile ((==)' ') s)
21:08:37 <lambdabot> (. dropWhile (' ' ==)) . groupBy . const . (/=)
21:08:38 <koninkje> They do still trap out to C/asm for some driver stuff
21:08:44 <mofmog> well if you thought of a device in monad terms
21:08:51 <mofmog> and had a suitable wrapper or something
21:08:57 <adu> @src ap
21:08:58 <lambdabot> ap = liftM2 id
21:09:32 <koninkje> mofmog: They do, but Haskell has no direct mechanism for fiddling registers and such, hence the trap out to asm
21:09:58 <koninkje> it's mostly all haskell IIRC however
21:10:18 <dolio> There's no reason in principle that you couldn't write that into a compiler for a Haskell-like language.
21:10:28 <koninkje> sure.
21:10:52 <dolio> The question is if you'd want to bother writing the compiler that translates something that looks like haskell into appropriate machine code instead of just using assembly.
21:10:56 <adu> @type \d s -> groupBy (const (/=d)) (dropWhile (==d) s)
21:10:58 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
21:11:37 <chessguy> @pl \d s -> groupBy (const (/=d)) (dropWhile (==d) s)
21:11:38 <lambdabot> ap ((.) . groupBy . const . (/=)) (dropWhile . (==))
21:13:40 <chessguy> anyway, fun stuff
21:13:52 <chessguy> 'night all
21:17:06 <adu> > let explode x xs = map tail $ groupBy (const (/=x)) ([x] ++ xs) in explode ' ' "Hello Curel World"
21:17:07 <lambdabot>  ["Hello","Curel","World"]
21:17:22 <adu> let explode x xs = map tail $ groupBy (const (/=x)) ([x] ++ xs) in explode 0 [52, 123, 7, 4, 8, 0, 23, 4, 6]
21:17:36 <adu> > let explode x xs = map tail $ groupBy (const (/=x)) ([x] ++ xs) in explode 0 [52, 123, 7, 4, 8, 0, 23, 4, 6]
21:17:37 <lambdabot>  [[52,123,7,4,8],[23,4,6]]
21:29:16 <mar77a> split _ "" = [""]
21:29:16 <mar77a> split "" _ = [""]
21:29:16 <mar77a> split str (x:xs) = (if str `isPrefixOf` (x:xs) then x:[]:[xs] else (:x)) : split str xs
21:29:20 <mar77a> that's how far i got
21:29:27 <mar77a> i'll continue tomorrow or something
21:30:18 <koninkje> mar77a: the trick is to keep from traversing the list repeatedly (as isPrefixOf will)
21:38:12 <newsham> "to iterate is illiterate / to recurse is worse"
21:41:01 <ivanm> newsham: wtf? how else are we meant to loop then? :o
21:41:33 <sjanssen> foldr!
21:41:53 <sjanssen> ivanm: we give patterns of recursion names, and then use those instead :)
21:44:10 <newsham> ivanm: something that rhymes, preferentially.
21:52:11 <dolio> > subsequences [1..3]
21:52:11 <lambdabot>   Not in scope: `subsequences'
21:53:09 <bd_> > nub . concatMap tails . heads $ [1..3]
21:53:10 <lambdabot>   Not in scope: `heads'
21:53:17 <bd_> > nub . concatMap tails . inits $ [1..3]
21:53:18 <lambdabot>  [[],[1],[1,2],[2],[1,2,3],[2,3],[3]]
21:53:37 <adu> is that the powerset?
21:54:25 <bd_> no, it's contiguous subsequences
21:54:35 <adu> ah, so more like powerlist
21:54:58 <dolio> subsequences appears to be powerset.
21:55:02 <adu> i see [1,3] isn't in there
21:55:09 <dolio> (From Data.List in 6.9)
21:55:11 <bd_> > map concat . mapM (\e -> [[], [e]]) $ [1..3]
21:55:12 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
21:55:23 <adu> [1,3] is in that one
21:55:23 <bd_> powerset
21:55:51 <koninkje> > filterM (const [True,False]) [1..3]
21:55:52 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:56:06 <koninkje> > filterM (const [False,True]) [1..3]
21:56:07 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
21:56:22 <adu> interesting
21:58:00 <dolio> subsequences xs = [] : nonEmptySubsequences xs
21:58:24 <sjanssen> dolio: subsequences and powerset aren't exactly the same -- remember that a list isn't necessarily a set
21:58:29 <sjanssen> and order matters
21:58:30 <dolio> nonEmptySubsequences (x:xs) = [x] : foldr f [] (nonEmptySubsequences xs) where f ys r = ys : (x:ys) : r
21:58:58 <roconnor> fold and recursion!
21:59:05 <roconnor> O_o
22:00:48 <dolio> Ah, well, true. It's more like power-multiset, with duplicates.
22:01:34 <sjanssen> no, it's more like subsequences :)
22:01:53 <adu> but thats a good point, the the [1..3] case the powerlist is smaller than the powerset, but there are also cases where the powerlist is larger than the powerset
22:02:43 <koninkje> > nub $ filterM (const [True,False]) [1..3,1..3,1..3]
22:02:43 <lambdabot>  Parse error at ",1..3..." (column 41)
22:02:59 <sjanssen> don't invent terms -- subsequences is a well accepted term http://en.wikipedia.org/wiki/Subsequence
22:03:14 <mrd> you created that page a moment ago!
22:03:35 <sjanssen> mrd: in December 2004, no less :)
22:15:56 <solrize_> @seen dsfox
22:15:56 <lambdabot> I haven't seen dsfox.
22:16:32 <^Someone^> > 2^3-1
22:16:33 <lambdabot>  7
22:17:02 <^Someone^> 2^2^3-1
22:17:09 <^Someone^> > 2^2^3-1
22:17:11 <lambdabot>  255
22:17:33 <^Someone^> > 2^(2^3)-1
22:17:34 <lambdabot>  255
22:18:00 <adu> > 2^2^2^2
22:18:01 <lambdabot>  65536
22:18:37 <^Someone^> > 2^3^5-2^3+1
22:18:38 <lambdabot>  14134776518227074636666380005943348126619871175004951664972849610340958201
22:18:55 <^Someone^> > 2^3^5-(2^3)+1
22:18:56 <lambdabot>  14134776518227074636666380005943348126619871175004951664972849610340958201
22:25:58 <Apocalisp> How can I apply a functor inside a functor?
22:26:14 <byorgey> fmap . fmap ?
22:26:27 <byorgey> @type fmap (fmap f)
22:26:29 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, SimpleReflect.FromExpr b, Show a) => f1 (f a) -> f1 (f b)
22:26:38 <byorgey> @type fmap . fmap
22:26:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:26:50 <byorgey> is that what you want?
22:27:19 <Apocalisp> I want (f1 a -> f1 b) -> f1 (f2 a) -> f1 (f2 b)
22:27:56 <Apocalisp> seems like fmap is applying a functor inside the -> monad
22:28:20 <Apocalisp> is there a general way to do that for _any_ monad?
22:28:47 <Apocalisp> ?type fmap
22:28:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:29:26 <byorgey> Apocalisp: hm, I'm not sure you can do that
22:30:03 <Apocalisp> so... a b c -> a (f b) (f c)
22:30:25 <Apocalisp> ?hoogle (Arrow a, Functor f) => a b c -> a (f b) (f c)
22:30:26 <lambdabot> Prelude.id :: a -> a
22:30:26 <lambdabot> Data.Function.id :: a -> a
22:30:26 <lambdabot> GHC.Exts.breakpoint :: a -> a
22:30:34 <Apocalisp> :(
22:31:43 <dolio> @type \f -> Data.Traversable.sequenceA . fmap f . Data.Traversable.sequenceA
22:31:45 <lambdabot> forall (f :: * -> *) a (t :: * -> *) (f1 :: * -> *) a1. (Data.Traversable.Traversable t, Applicative f1, Applicative f, Data.Traversable.Traversable f1) => (t a1 -> f a) -> t (f1 a1) -> f (f1 a)
22:36:02 <Apocalisp> dolio: Thanks, that's what I want
22:36:56 <Apocalisp> ?doc Data.Traversable
22:36:57 <lambdabot> Data.Traversable not available
22:38:42 <byorgey> aha, I figured it had something to do with Traversable
22:39:00 <byorgey> @type Data.Traversable.sequenceA
22:39:02 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
22:39:34 <rwbarton> Is Data.Foldable morally different from  class Foldable' t where toList :: t a -> [a] ?
22:39:56 <byorgey> since it lets you commute functors like that
22:40:15 <sjanssen> rwbarton: yes
22:41:05 <sjanssen> rwbarton: for example, you can use foldMap to expose underlying structure
22:41:18 <Apocalisp> ?type (fmap .)
22:41:20 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
22:41:55 <Apocalisp> I came that close, but I couldn't figure out how to distribute f1 over both sides of the arrow
22:41:57 <byorgey> sjanssen: how's that?
22:42:09 <Apocalisp> ?type ap
22:42:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:42:51 <byorgey> @type Data.Foldable.foldMap
22:42:52 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
22:43:37 <byorgey> oh, is it because the Monoid need not be associative?
22:43:41 <sjanssen> right
22:43:44 <byorgey> got it
22:44:38 <rwbarton> Oh.
22:44:48 <rwbarton> I think that falls under the "morally" proviso
22:45:21 <sjanssen> left and right folds also might have different strictness depending on the direction of the structure
22:45:22 <Apocalisp> ?type ap . (fmap .)
22:45:23 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, Monad f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
22:45:47 <byorgey> rwbarton: I think the answer is 'for associative Monoids, yes'
22:45:51 <Apocalisp> hah. Now how do I distribute f1 over the domain function?
22:45:55 <rwbarton> monoids are associative.
22:46:10 <rwbarton> (otherwise they're called "unital magmas")
22:46:18 <byorgey> oh, right, I guess they are supposed to be, aren't they
22:46:38 <rwbarton> sjanssen: I guess that makes sense.  I could define a "possibly rightwardly infinite list" type
22:46:39 <byorgey> but haskell has no way of enforcing that
22:47:05 <hpaste>  morrow pasted "adjunction" at http://hpaste.org/8449
22:48:10 <byorgey> Apocalisp: you actually want to 'un-distribute' it, which you can't do in general
22:48:46 <byorgey> since it is in a negative position
22:49:36 <byorgey> Apocalisp: and btw you only need Applicative for ap (use <*> instead of ap)
22:49:55 <Apocalisp> yes, good point
22:50:08 <hpaste>  morrow annotated "adjunction" with "nitpicking" at http://hpaste.org/8449#a1
22:50:13 <byorgey> but I'm pretty sure you do need Traversable
22:50:29 <Apocalisp> I think you're right. I'm just trying to understand it.
22:50:31 <byorgey> but don't ask me to prove it, it's late =)
22:50:43 <byorgey> sure
22:51:16 <byorgey> did you understand what I was saying above about 'un-distributing'?  I realize I may not have worded it very well
22:52:01 <adu> hi byorgey
22:52:47 <byorgey> hi adu
22:53:05 <adu> how's it going?
22:53:20 <byorgey> pretty good, you?
22:53:28 <adu> hung over
22:53:35 <byorgey> hehe
22:53:37 <adu> and trying to get HOC to compile
22:53:44 <byorgey> what's HOC?
22:53:51 <byorgey> higher-order C?
22:53:51 <adu> Haskell-ObjC binding
22:53:53 * byorgey shudders
22:54:19 <byorgey> that... doesn't really sound any better to me ;)
22:54:34 <adu> I'm really not interested in HOC for its own sake, I'm interested in it for Yi
22:54:49 <byorgey> what could HOC possibly have to do with Yi?
22:55:11 <adu> but the advantages of using HOC do not seem to outway the advantages of writing a wxHaskell front-end instead...
22:55:30 <byorgey> I see
22:55:39 <adu> i just want nice menus
22:55:50 <adu> like the macosx version of Emacs.app
22:56:56 <adu> Yi already has a Cocoa front-end (written on HOC), but I can't use it because HOC won't compile
22:57:06 <adu> :(
22:57:17 <byorgey> ah, *that's* what HOC has to do with Yi =)
22:57:19 <hpaste>  morrow annotated "adjunction" with "weird....but not?" at http://hpaste.org/8449#a3
22:57:34 <adu> yup
22:58:12 <lament> i think haskell has tk bindings
22:58:15 <electronx> hello can someone explain to me why i cannot get the string component of IO String
22:58:19 <lament> tk has native widgets on OS X
22:58:20 <adu> but my goal (nice menus) could be accomplished with either wxHaskell or HOC as far as I can tell...
22:58:32 <electronx> this is pissing me off to no end
22:58:41 <lament> electronx: hah!
22:58:47 <adu> electronx: yes
22:58:55 <lament> electronx: it's a feature.
22:59:00 <electronx> omg
22:59:12 * koninkje would be in favor of the HOC/Cocoa approach 
22:59:13 <adu> electronx: you just do this: str <- somethingThatMakesIOString
22:59:15 <electronx> what do i do with it then
22:59:24 <byorgey> electronx: you *can* get the String component; you just must be inside a do-block
22:59:31 <electronx> x <- unIO blah ????
22:59:38 <lament> no
22:59:40 <lament> x <- blah
22:59:56 <lament> now x is your string, enjoy
22:59:57 <electronx> wait i did file <- readFile blah
23:00:04 <electronx> file is not string
23:00:08 <koninkje> which is just sugar for "blah >>= \x -> ..."
23:00:10 <lament> :t readFile
23:00:12 <lambdabot> FilePath -> IO String
23:00:16 <lament> yes, file is string.
23:00:19 <byorgey> do { file <- readFile blah ; print (someFunction file) }
23:00:28 <byorgey> someFunction :: String -> String
23:00:32 <electronx> no for me file is IO String
23:00:35 <koninkje> @undo do { file <- readFile blah ; print (someFunction file) }
23:00:35 <lambdabot> readFile blah >>= \ file -> print (someFunction file)
23:00:55 <adu> electronx: could you give us some of your code?
23:00:57 <byorgey> electronx: why don't you paste your code on hpaste.org?
23:01:22 <byorgey> readFile blah >>= print . someFunction
23:01:39 <lament> i'm not sure if electronx is ready to be confused by >>= notation
23:01:41 <electronx> its simple its do file <- readFile "blah" y <- map fromIntegral file
23:01:56 <electronx> then print y
23:02:00 <electronx> or putStr y
23:02:04 <koninkje_away> "confused"?
23:02:06 <adu> electronx: uhm, you need some ";" in there somewhere
23:02:17 <electronx> adu its not on one line in file
23:02:23 <lament> electronx: map fromIntegral file is not an IO value
23:02:25 <adu> o ok
23:02:29 <lament> electronx: so you don't need <-
23:02:30 <rwbarton> "y <- " should be "let y = "
23:02:30 <koninkje_away> Knowing the functional paradigm behind the sugar makes a lot of things make more sense, IMO
23:02:41 <electronx> i see
23:02:54 <electronx> that could be the problem
23:03:00 <electronx> why can i do y =
23:03:04 <electronx> why let y =
23:03:13 <adu> koninkje_away: it also confuses beginners
23:03:18 <lament> electronx: have you ever actually tried reading some haskell tutorial, or learning haskell some other way?
23:03:27 <byorgey> it depends on the beginner.
23:03:35 <rwbarton> electronx: you're asking why the "let" is required?
23:03:38 <electronx> lament i'm reading a book atm
23:03:44 <lament> electronx: which book?
23:03:46 <electronx> yes in the do notation
23:03:59 <adu> koninkje_away: I've made several IO-based programs, and I still have no idea what ">>=" does
23:04:00 <electronx> in where
23:04:05 <electronx> i don't need let
23:04:19 <byorgey> adu: well, there's no time like the present! =D
23:04:24 <byorgey> @type (>>=)
23:04:25 <electronx> nvm i skimmed most of the book :)
23:04:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:04:40 <lament> electronx: perhaps that was the problem. You're starting with the hard stuff.
23:04:49 <electronx> i will sit down and read it properly after my exams
23:05:14 <electronx> lament: your correct but Monads are the interesting stuff
23:05:22 <adu> byorgey: I know, its just not intuitive
23:05:36 <electronx> anyway thank for the help
23:05:48 <lament> electronx: i absolutely agree! but to understand monads, you first need a good understanding of types, type classes, pure functions, lazy evaluation.
23:06:03 <rwbarton> electronx: It's just the way they chose the syntax.  Bindings are introduced by a keyword (either let or where)
23:06:08 <electronx> lament: i understand those things
23:06:11 <byorgey> adu: yeah, it takes a while.  what really made it intuitive for me was thinking of monads in terms of fmap, return, and join  instead of return and (>>=)
23:06:17 <adu> is lazy evaluation really neccessary?
23:06:36 <electronx> I just havn't learnt all the syntax
23:06:43 <electronx> and sugar
23:06:44 <adu> byorgey: ya, join is intuitive
23:06:47 <lament> adu: if you want to have some kind of a loop, yes
23:07:06 <lament> otherwise i suppose you can ignore it
23:07:10 <rwbarton> I find join is intuitive for [], Maybe, less so for IO
23:07:20 <electronx> will be creating a distributed computing client in haskell :)
23:07:22 <lament> very few things are intuitive for IO
23:07:35 <electronx> should be fun
23:07:40 <lament> electronx: besides. Monads are interesting but IO is practically the most odd/confusing one
23:07:52 <byorgey> adu: so here's what (>>=) does.  You take your  x :: m a  and your  f :: a -> m b,  and then fmap f x gives you m (m b). (i.e. it applies f 'inside' the m).
23:07:54 <lament> electronx: because what it wraps around / encapsulates is _the universe_
23:08:02 <byorgey> adu: and then you do a join to get from m (m b) to m b.
23:08:04 <electronx> lament: i don't find io confusing :)
23:08:26 <electronx> lament: maybe a bit
23:08:30 <lament> electronx: the io monad, not io :)
23:08:47 <byorgey> i.e.  x >>= f  = join (fmap f x)
23:09:13 <electronx> anyway back to work cya
23:09:42 <adu> byorgey: so (>>=) = join . fmap ?
23:10:02 <adu> that kinda makes sense
23:10:04 <byorgey> adu: not quite, it's (join .) . fmap if you want to write it pointsfree
23:10:16 <adu> o
23:10:25 <byorgey> x >>= f = join (fmap f x)  is easier to read.
23:11:03 <adu> so its actually (join .) . (flip fmap)
23:11:17 <byorgey> oh, yes, actually, you're right
23:11:22 <adu> :)
23:11:28 <byorgey> =)
23:12:31 <adu> lament: not the universe, just the part that changes
23:12:34 <byorgey> ok, to bed with me
23:12:37 <byorgey> night all
23:12:39 <adu> byorgey: night
23:13:16 <lament> adu: the universe, because you can't tell what changes and what doesn't!
23:13:28 <lament> it's all together in one blob
23:14:08 <adu> just take the derivative of it!
23:14:25 <adu> then the integral of that is what changes...
23:18:27 <vixey`> http://wiki.digitalgrammars.com/wiki/CS_Classics_Course
23:18:28 <lambdabot> Title: CS Classics Course - Digital Grammars Wiki
23:19:51 <hpaste>  morrow annotated "adjunction" with "(no title)" at http://hpaste.org/8449#a5
23:20:12 <adu> @pl (>>=)
23:20:12 <lambdabot> (>>=)
23:20:29 <adu> @pl (join .) . (flip fmap)
23:20:29 <lambdabot> (join .) . flip fmap
23:20:48 <adu> @pl \x f -> join (fmap f x)
23:20:48 <lambdabot> (join .) . flip fmap
23:21:33 <vixey`> mmorrow is up to some black magic
23:23:23 <adu> thats alot of segfaults
23:23:27 <mmorrow> hehh
23:24:09 <adu> next time I need a segfault I know who to ask!
23:24:37 <mmorrow> i think whether it crashes or not has to do with if whether fix applied to the func f2 takes would produce any values
23:25:06 <mmorrow> so, whether it can immediately produce a val
23:25:31 <mmorrow> or there is only one val of a type or something...
23:26:18 <adu> what does this mean "type family"?
23:26:21 <mmorrow> adu: thats alot of unsafeCoerces
23:26:30 <adu> yes, that too
23:27:08 <mmorrow> adu: it's new! check it out in the ghc docs + the haskell wiki (not sure where the most up-to-date info is)
23:27:52 <mmorrow> http://haskell.org/haskellwiki/GHC/Type_families
23:27:53 <lambdabot> Title: GHC/Type families - HaskellWiki
23:28:56 <adu> hmm
23:30:10 <vixey`> "Conventional Programming Languages: Fat and Flabby"
23:36:19 <vixey`> I want to write a connection machine emulator
23:36:34 <vixey`> I couldn't find any docs about the hardware though, so I guess I can't
23:37:12 <sjanssen> mmorrow: you aren't allowed to complain when unsafeCoerce produces segfaults :)
23:44:09 <mmorrow> sjanssen: not complaining, just observing :)
23:44:55 <mmorrow> vixey`: whats a connection machine?
23:45:31 <vixey`> it's this supercomputer which is made of thousands of 1 bit CPUs
23:45:58 <mmorrow> 1 bit CPU??!
23:46:07 <mmorrow> i dont follow
23:46:33 <mmorrow> oh, like a brain type thing
23:46:34 <mmorrow> ?
23:47:49 <dfranke> *mutter*.  Another massive flock of Ruby vulnerabilites.  I should rewrite my spam-crawler trap in Haskell.
23:53:59 <mmorrow> lol
23:54:02 <mmorrow> ghci> unsafeCoerce id () :: Either [a] ()
23:54:02 <mmorrow> Left Segmentation fault
23:55:12 <olsner> :) otoh, unsafeCoerce is cheating
23:55:32 <hpaste>  morrow annotated "adjunction" with "interesting" at http://hpaste.org/8449#a6
23:56:32 <mmorrow> olsner: in the same way that stealing from toddler is easy
23:56:44 <mmorrow> s/toddler/toddlers/
23:56:50 <vixey`> you know "A Type-Preserving Compiler in Haskell", is there a version that does polymorphism too?
23:57:15 <dolio> Left Segmentation fault seems like the expected result to me.
23:58:25 <mmorrow> so classic. "what type is that function???"..."Either (Segmentation fault) a"
23:59:08 <olsner> \fault -> Segmentation fault
23:59:29 <vixey`> how hard is polymorphism?
23:59:35 <vixey`> it seems like a really troublesome thing
23:59:45 <vixey`> since no longer does a function have a single known type
