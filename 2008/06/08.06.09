00:07:49 <mmorrow> s/instances/families/
00:12:24 <Saizan_> mmorrow: now parametrize on the prime :)
00:22:23 <mmorrow> Saizan_: i did (at the meta level)
00:23:25 <mmorrow> Saizan_: i should clean those functions up and put em into a module...
00:39:14 <bos> @hoogle numCapabilities
00:39:28 <lambdabot> GHC.Conc.numCapabilities :: Int
00:41:40 * vixey tries to figure out what to do :`
00:41:51 <dcoutts> dons: afaik touch# has 0 runtime cost
00:41:52 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
00:47:15 <dcoutts> @Seen gwern
00:47:15 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 4h 53m 12s ago.
00:51:32 <dons> dcoutts: interesting to see unsafePerformIO strike again, ruining a good CPR return (in the hmatrix code)
00:51:57 <dons> optimiser poison
00:52:18 <dcoutts> heh
00:52:47 <dcoutts> yes, unsafePerformIO has a heavy cost at runtime and compile time
00:53:15 <dcoutts> in extra jumps at runtime and lost opportunities at compile time
00:54:09 <dons> ah laziness. like the three bears, you want not too much, and not too little.
01:01:18 <vixey> what's the name of that binay encoding
01:01:54 <vixey> it's like each chunk only differs by one bit or something.. so you can do error recovery on it
01:02:30 <vixey> oh it was hamming
01:06:04 <dolio> > 38.5 * 9 / 5 + 32
01:06:09 <lambdabot>  101.3
01:12:05 <^Someone^> > 38.5/5
01:12:07 <lambdabot>  7.7
01:18:01 <vixey> I'm trying to figure out what to do with this book (other than just read it) purely functional data structures
01:18:28 <dolio> You could use it to balance a wobbly table.
01:18:33 <osfameron> yeah, it's not really thick enough to use to prop up your monitor
01:18:39 <vixey> If only I had a wobbly table !
01:18:43 <ilyak> Hi *!
01:21:27 <Vq^> and nothing beats the ELFA catalogue for proping the monitor :)
01:26:19 <osfameron> vixey: I found the first chapter readable and informative.  The next one (on Red Black Trees) I found immensely difficult but useful.  I think I'll work up to the rest of the book...
01:27:19 <vixey> what are you using red black trees for? or what have you used from the chapter?
01:30:34 <mmorrow> vixey: i found chapters 9-11 to be the most useful/interesting
01:31:30 <quicksilver> well, whilst most people don't have to write a self balancing tree on their own
01:31:43 <quicksilver> it's still quite enlightening to spend some time thinking about how they work.
01:32:03 <quicksilver> I wrote a B*-tree
01:33:31 <mmorrow> most definitely, but automatically-by-design self-balancing trees via polymorphic recursion is the l33t3st!
01:39:23 <mmorrow> (see section 10.1.1 pp 143-144)
01:42:51 <mmorrow> fingertrees (a special case of which Data.Sequence is) are a generalization/extension to the various "CatenableDequeues" in chapter 11
01:44:52 <mmorrow> the thing i liked the most about his code is that not one of his modules were more than say 100 lines, with most being around (i'm guessing by sight) 30-50 lines
01:45:25 <mmorrow> one-two knockout
02:24:42 <mauke> :t ap id id
02:24:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
02:24:45 <lambdabot>     Probable cause: `id' is applied to too few arguments
02:24:45 <lambdabot>     In the second argument of `ap', namely `id'
02:29:29 <frevidar> if "a" is the name of a field of a record x, is there a way to do this: a = x.a
02:29:57 <frevidar> . being the c++ version, not the haskell version here
02:30:05 <mauke> huh?
02:30:18 <quicksilver> frevidar: did you mean y.a = x.a ?
02:30:24 <frevidar> well, I want to do something like this
02:30:24 <quicksilver> otherwise I'm not sure what your'e saying.
02:30:29 <frevidar> a = a x
02:30:37 <frevidar> but presumably that will fail
02:30:50 <quicksilver> no, it won't fail, but it might be confusing.
02:31:01 <quicksilver> you'd be defining a fresh 'a' containin gthe 'a' field from 'x'.
02:31:02 <frevidar> quicksilver: oh, really?
02:31:08 <mauke> :t let a = a x in a
02:31:10 <lambdabot>     Occurs check: cannot construct the infinite type: t = Expr -> t
02:31:10 <lambdabot>     Probable cause: `a' is applied to too many arguments
02:31:10 <lambdabot>     In the expression: a x
02:31:17 <quicksilver> which would shadow the old 'a' (the selector function)
02:31:25 <mauke> quicksilver: let = letrec
02:31:32 <quicksilver> ah, it does fail with let because lets are rcursive
02:31:33 <quicksilver> doh.
02:32:09 <ski_> @type \a -> head $ do a <- [a x]; return a
02:32:09 <frevidar> I'm trying to use a record to buddle up arguments to a function
02:32:10 <lambdabot> forall a. (Expr -> a) -> a
02:32:29 <frevidar> it has 6 arguments, in this case one of which is optional
02:33:43 <frevidar> and in the function, I want to extract them out of the record for readabilities sake
02:33:47 <frevidar> but I don't want to rename them
02:34:06 <mauke> hmm
02:34:09 <Saizan_> Record{a=x}
02:34:12 <Saizan_> err
02:34:14 <Saizan_> Record{a=a}
02:34:19 <mauke> does that work?
02:34:22 <Saizan_> in a pattern
02:34:26 <quicksilver> yes.
02:34:28 <Saizan_> yes
02:34:32 <quicksilver> in a pattern you can reuse the name
02:34:39 <quicksilver> myself I think it's pretty poor style :)
02:35:02 <quicksilver> I don't much like shadowing things with things of different types.
02:35:06 <frevidar> ah, ok
02:35:28 <frevidar> so I'd do f (Record {a=a, b=b... })
02:35:34 <quicksilver> yes.
02:35:37 <frevidar> and they'll all be extracted and ready to roll?
02:35:40 <frevidar> cool
02:35:44 <quicksilver> GHC has some extensions to do this automatically
02:35:52 <frevidar> quicksilver: really?
02:35:55 <frevidar> such as?
02:35:57 <quicksilver> well, it makes a,b,c shorthand for a=a,b=b,c=c IIRC
02:36:00 <quicksilver> -XRecordPuns
02:36:03 <quicksilver> I think.
02:36:07 <quicksilver> somethign like that.
02:36:16 <frevidar> quicksilver: I'll check that out
02:36:19 <frevidar> thanks
02:36:29 <mauke> http://linux.die.net/man/1/ghc :-)
02:36:30 <lambdabot> Title: 31 ghc(1): Glasgow Haskell Compiler - Linux man page 9
02:39:07 <frevidar> quicksilver: do you have a link?
02:39:21 <frevidar> do the description of the option and how to use it?
02:39:45 <mauke> {-# LANGUAGE RecordPuns #-}
02:41:09 <quicksilver> frevidar: I could find the chapter in the manual but I'm sure you could as well :P
02:41:24 <kiris> is there a way, in type annotations to say e.g. a is "(String,Integer,Char)" now I want a -> a -> a?
02:41:41 <mauke> type A = (String,Integer,Char)
02:41:48 <frevidar> quicksilver: can't find it here: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
02:41:48 <mauke> A -> A -> A
02:41:49 <lambdabot> Title: Chapter 8. GHC Language Features, http://tinyurl.com/kf2g3
02:42:11 <frevidar> I can't find anything about "puns"
02:42:27 <kiris> umkay
02:42:30 <mauke> it's listed in http://haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
02:42:31 <lambdabot> Title: 5.17. Flag reference, http://tinyurl.com/yod3gf
02:42:34 <mauke> with no explanation
02:44:00 <frevidar> is there an explanation anywhere?
02:44:41 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/users_guide/syntax-extns.html
02:44:41 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/3dsua3
02:44:46 <quicksilver> 8.3.10
02:44:50 <quicksilver> Recoprd puns
04:14:31 <mm_freak> does 'darcs get' over HTTP work in a way that i can just upload a repository?
04:15:27 <Itkovian> mm_freak: I think you mean 'put', no?
04:16:21 <mm_freak> no, i mean get‚Ä¶  does it work in a way that i don't need any special darcs-specific server extensions?
04:16:59 <Saizan_> mm_freak: it does
04:17:05 <Saizan_> you just need a webserver
04:17:29 <mm_freak> great, thanks
04:18:07 <Saizan_> to push there is another matter
04:19:41 <mm_freak> hmm‚Ä¶  darcs is only sparsely documented =/
04:20:45 <mauke> .oO( lazy documentation‚Ä¶ ‚Äúforce‚Äù the developer to write docs )
04:23:20 <mm_freak> hehe
04:23:33 <mm_freak> well‚Ä¶  what do i need to 'put'?
04:24:35 <Saizan_> darcs can push over ssh
04:25:09 <Itkovian> mm_freak: ssh access does the trick.
04:25:16 <hukolele> why "len n [] = n; len n (_:xs) = len (n+1) xs in len 0 [1..1000000]" runs out of memory, isn't it tail recursive?
04:25:21 <mm_freak> ok, so 'put' is for creating and 'push' is for getting, as far as i've understood, and the requirements are the same
04:25:42 <mm_freak> but what do i need, if i don't want to give people SSH access?
04:26:18 <Saizan_> nono
04:26:43 <Cale> hukolele: it's tail recursive, but it builds up a large expression
04:26:44 <dancor> mm_freak: are you saying you want ppl to be able to anonymously modify your repo?
04:26:44 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
04:27:09 <mm_freak> dancor: no, but i don't want to give them SSH access
04:27:09 <Dzlk> mm_freak: send?
04:27:23 <mm_freak> still some unattended way
04:27:26 <Cale> len 0 [1,2,3] = len (0+1) [2,3] = len ((0+1)+1) [3] = len (((0+1)+1)+1) [] = ((0+1)+1)+1
04:27:44 <Dzlk> maybe you could have an auto-apply procmail recipie.
04:27:54 <mm_freak> > let len n [] = n; len !n (_:xs) = len (n+1) xs in len 0 [1..1000000]
04:27:54 <lambdabot>  Parse error in pattern at "in" (column 48)
04:27:55 <Cale> which will, if the expression is large enough, cause a stack overflow
04:28:14 <mm_freak> > let len n [] = n; len n (_:xs) = n `seq` len (n+1) xs in len 0 [1..1000000]
04:28:18 <lambdabot>  1000000
04:29:37 <hukolele> isn't it work of the gc going freeing the mem?
04:30:22 <mm_freak> hukolele: no, because the expression chain is actually needed
04:30:43 <RayNbow> mm_freak's solution uses seq to force the evaluation of n
04:31:00 <RayNbow> preventing the expression for n to become large
04:31:06 <RayNbow> @src length
04:31:06 <lambdabot> Source not found. stty: unknown mode: doofus
04:31:10 <hukolele> is it the same to use seq than !?
04:31:43 <RayNbow> you mean strictness annotation for the arguments?
04:31:53 <hukolele> yes
04:31:58 <quicksilver> ! is really sugar for seq
04:32:07 <quicksilver> so yes, you can often use ! in arguments instead
04:32:22 <maltem> f !x = T means f x = x `seq` T
04:32:28 <RayNbow> or you can use guards on n
04:32:39 <RayNbow> which is what GHC's implementation of length uses, I think
04:33:11 <RayNbow> oh, nope :p
04:33:16 <hukolele> which guards?
04:33:25 <RayNbow> GHC's version of length uses unboxed stuff
04:34:44 <Cale> Or of course, you can compile with -O or -O2, which should work okay.
04:34:45 <RayNbow> foo arg1 | arg1 == arg1  = someexpression -- this is another way of forcing the evaluation of an argument
04:35:00 <RayNbow> but it requires arg1's type to be in Eq
04:35:01 <Botje> RayNbow: that puts an Eq constraint on arg1 though *runs*
04:35:04 <Botje> doh :p
04:35:08 <RayNbow> Botje: I was about to type that :p
04:35:11 <Botje> :)
04:35:12 <Cale> > let len n [] = n; len n (x:xs) = len (n+1) xs in len [1..1000000]
04:35:12 <lambdabot>   add an instance declaration for (Num [t])
04:35:16 <Cale> > let len n [] = n; len n (x:xs) = len (n+1) xs in len 0 [1..1000000]
04:35:18 <Botje> foo arg1 | arg1 `seq` True = ...
04:35:18 <lambdabot>  1000000
04:35:21 <Cale> > let len n [] = n; len n (x:xs) = len (n+1) xs in len 0 [1..10000000]
04:35:25 <lambdabot> Terminated
04:35:31 <Cale> well, it works, anyway :)
04:35:40 <mm_freak> hukolele: it's easiest to try to resolve your function yourself:  len 0 [1..10] = len (0+1) [2..10] = len (0+1+1) [3..10] = ‚Ä¶ = len (0+1+1+1+1+1+1+1+1+1+1) []
04:35:41 <Botje> anyone familiar with c--: are there bindings for it somewhere,
04:35:57 <Botje> I know GHC uses it but i'd rather not rip those files out :)
04:36:06 <mm_freak> finally, outside of the invocation of 'len', the result is actually demanded and thus calculated
04:36:19 <mm_freak> what 'seq' does is to demand the result at each step
04:36:57 <hukolele> so seq can make haskell strict at any situation?
04:37:05 <mm_freak> yes
04:37:21 <hukolele> cool, thanks
04:37:25 <quicksilver> strict up to the first constructor, at least.
04:37:32 <quicksilver> which is the same thiing for numbers
04:37:37 <quicksilver> (but not, e.g. for lists)
04:37:59 <mm_freak> actually if 'seq' is never called, your program wouldn't do anything‚Ä¶  there are a lot of implicit seqs throughout your program
04:38:12 <osfameron> how odd, as "Seq" is iirc the *lazy* version of lists in F# :-)
04:38:32 <luite> @src seq
04:38:33 <lambdabot> Source not found. Just try something else.
04:39:05 <mm_freak> luite: seq a b = b
04:39:26 <osfameron> it's just flip const ?
04:39:26 <quicksilver> luite: seq can't have source, it's primitive.
04:39:46 <quicksilver> mm_freak: that's a strange view. I don't consider a function call or an application of case an implicit seq.
04:40:01 <quicksilver> (I might be persauded that seq was an implicit case)
04:40:12 <mm_freak> quicksilver: case is strict?
04:40:19 <quicksilver> yes.
04:40:33 <mm_freak> oh, then sorry
04:40:40 <ToRA> i think seq a b translates to case a of DEFAULT -> b in ghc core
04:40:50 <ToRA> (where case in core is always strict)
04:40:58 <quicksilver> ToRA: that's potentially confusing because core case is not haskell case.
04:41:02 <quicksilver> ToRA: right :)
04:41:10 <ToRA> quicksilver: yup
04:41:51 <mm_freak> quicksilver: but isn't case only strict in its variable?  i mean, if the value of the entire case is never demanded, then nothing is calculated, isn't that right?
04:42:14 <quicksilver> mm_freak: that is also true of seq
04:42:22 <quicksilver> mm_freak: and, by inference it's true of everything :)
04:42:43 <ToRA> > let x = undefined `seq` False in case x of _ -> True
04:42:44 <lambdabot>  True
04:42:47 <quicksilver> if the value of the entire "foorble" is never demanded then none of the strictness of "foorble" will case any effect.
04:42:50 <mm_freak> true =)
04:43:05 <quicksilver> this is true for all wellformed haskell sub-programs
04:43:44 <mm_freak> and i'm saying that at least in the invocation of 'main' (by running the program), there is an implicit seq
04:44:22 <mm_freak> otherwise a long chain of computations would be built and would go to‚Ä¶  well‚Ä¶  somewhere =)
04:46:52 <mm_freak> though maybe strictness and demand is not exactly the same
04:47:41 <Saizan_> demand comes from IO
04:48:17 <mbz> hiya
04:50:01 <FordCortina> @hoogle Int -> Integer
04:50:01 <lambdabot> No matches, try a more general search
04:50:24 <FordCortina> :(
04:50:40 <mm_freak> @type fromIntegral
04:50:42 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:51:02 <mm_freak> > (3::Integer) + fromIntegral (4::Int)
04:51:03 <lambdabot>  7
04:51:15 <FordCortina> thanks mm_freak
04:51:25 <mm_freak> you're welcome
05:04:46 <mm_freak> what's a good place to run a blog about haskell?
05:04:59 <mm_freak> or functional languages in general
05:08:22 <ivanm> mm_freak: you talking about code formatting in posts?
05:08:52 <ivanm> last I checked, wordpress doesn't have syntax highlighting but it's possible to write code without it getting munged
05:10:40 <opqdonut> wordpress is just horrible
05:11:16 <ketil> any better alternative?
05:11:59 <opqdonut> nanoblogger, ikiwiki
05:14:33 <mm_freak> actually i'm not talking about software, but about a service
05:14:56 <mm_freak> haskell.org doesn't provide such a thing?
05:15:36 <ivanm> nope
05:15:41 <ivanm> and wordpress.com == service
05:16:09 <ivanm> (which is actually what I was talking about, since IIRC there is a plugin for wordpress the software that supports haskell)
05:19:03 <mm_freak> hmm
05:19:19 <mm_freak> in other words, it's going to be best to run my own
05:20:17 <ivanm> mm_freak: if you want to do anything fancy, then probably
05:20:23 <mm_freak> k
05:21:48 <RayNbow> http://www.reddit.com/r/programming/info/6mlfq/comments/ <-- Concurrent tree-rewriting language, Aardappel
05:21:49 <lambdabot> Title: programming: The Aardappel Programming Language (visual programming, concurrency ...
05:41:21 <Botje> i like kartoffel better
05:44:30 <tibbe> how much sharing do you get in a Map?
05:45:01 <mm_freak> i like √§pfel and birnen
05:49:19 <gwern> I wonder how hard it would be to write a library to exhaustively enumerate haskell programs and see whether they  meet some properties
05:49:41 <ddarius> tibbe: I imagine typically an insertion will only change O(log n) nodes on average.
05:49:50 <wolverian> gwern, well, you can just use it to generate itself.
05:50:07 <gwern> wolverian: :) sounds like a bootstrap issue
05:51:06 <ddarius> gwern: Such an approach is unlikely to be useful.
05:51:34 <gwern> too many syntactically wrong or illtyped programs?
05:51:52 <ddarius> Too many programs period.
05:52:07 <ddarius> Anyway, you can definitely only generate syntactically correct programs.
05:52:24 <ddarius> I believe it wouldn't be too hard to generate only well-typed programs of a given type.
05:52:26 <Gilly> Any ideas how to do something like this nicely: I have input coming to server from clients, each client should be in some stage but I can't block. I'd like to continue from where I left when data arrives.
05:52:41 <ddarius> gwern: You'd also have to time-limit the execution of each program.
05:52:47 <gwern> ddarius: well, I was lazily thinking 'eh, just ask the list monad for all Strings'
05:53:31 <Gilly> Pseudo-code: do name <- rd ; pass <- rd ; if check name pass then ... should translate to something like \name -> (\pass -> if check name pass then
05:53:39 <tibbe> ddarius: so basically you can't share nodes that are children of the changed node?
05:53:44 <gwern> ddarius: you know of any previous work in haskell? it'd be interesting to be able to say 'give me everyting which is :: Int'
05:53:57 <Gilly> I also would need to be able to do some loops where there's just some simple process function called after each data <- rd
05:55:05 <ToRA> gwern: arn't you asking for something like what smallcheck does?
05:55:51 <ddarius> gwern: Well djinn is an example, albeit it does more which makes it more restricted.  For any type there are infinitely many programs albeit it's possible that all but finitely many are semantically equivalent.
05:55:53 <Gilly> The thing is that i'd rather use something more dynamic than bring in tons of stage flags
05:56:05 <hpaste>  hkBst pasted "comments on the main function anyone?" at http://hpaste.org/8211
05:56:08 <gwern> ToRA: I don't think I am, since smallcheck requires you to have a written functions to test propreties of, right, while I am interested in searching the space of possible functions for those which meet a given property
05:56:17 <gwern> sort of the inverse, perhaps in a way
05:56:40 <Gilly> I'm not sure if continuation monad would help since I'm running this inside IO and would have to escape the monad between continuations.
05:56:53 <ddarius> tibbe: You can't share the changed node.  You obviously can share children; the root always changes and everything is a child of the root.
05:57:11 <ToRA> gwern: if a smallcheck property requires an argument :: Int -> String, then it has to generate functions of that type no?
05:57:39 <ddarius> ToRA: It has to generate functions, but not programs.
05:57:43 <quicksilver> Gilly: well I'd definiltely use threads fo each client.
05:57:54 <tibbe> ddarius: hmm, right
05:58:07 <ToRA> gwern: and it only makes sense to generate a restricted subset of all possible functions of that form, since the family [(const "hi"), id (const "hi"), id (id (const "hi")).. ] isn't that interesting...
05:58:09 <quicksilver> Gilly: and as for how you store client state, in simple cases I often just 'store' the state in the first parameter of the function.
05:58:12 <tibbe> ddarius: so everything from the root to the child then
05:58:17 <Gilly> quicksilver: i already do but then i just throw the data over chan to the main thread since the clients have to get aware of each other
05:58:20 <tibbe> ddarius: since pointers need to be changed
05:58:45 <quicksilver> Gilly: that sounds like a bad idea.
05:58:57 <ToRA> ddarius: what's the difference?
05:59:00 <quicksilver> Gilly: it's quite possible to make the clietns aware of each other without throwing all the data over to the main thread.
05:59:00 <ddarius> tibbe: Modulo rebalancing, yes, those are the only nodes that wouldn't be shared.
05:59:03 <ski_> @scheck \f -> f True
05:59:05 <lambdabot> Add a type signature
05:59:13 <ski_> @scheck \f -> f True :: Bool
05:59:14 <lambdabot>   Failed test no. 3. Test values follow.: {True->False;False->True}
05:59:18 <Gilly> quicksilver: i think i haven't explained enough :) I'm coding a MUD and my idea is that every client is always inside some "environment" (Login, character creation, main environment)
05:59:28 <quicksilver> Gilly: Yes
05:59:35 <quicksilver> Gilly: client state, I would call that.
05:59:39 <ddarius> ToRA: Many programs correspond to a function and you can get a function from a program (by interpretation).  Given a function you can't get the program.
05:59:41 <Gilly> yes
05:59:54 <quicksilver> Gilly: I have written programs liek that. And I did it the way I just described.
06:00:02 * ski_ wonders how `scheck' represents/handles functions ..
06:00:15 <Gilly> now to represent that state it would be really nice if the state was just a function which took a string of input and returned a new state function
06:00:34 <nolrai_> :t (lift . ListT . return)
06:00:35 <lambdabot> Not in scope: data constructor `ListT'
06:00:48 <Gilly> but that quickly leads to problems with infinite types etc.
06:01:06 <quicksilver> Gilly: I would just use recursion and store the state in the first paremeter.
06:01:11 <quicksilver> Gilly: at least in the simple case
06:01:16 <nolrai_> :t (lift . Control.Monad.List.ListT . return)
06:01:18 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a. (Monad m, MonadTrans t) => [a] -> t (Control.Monad.List.ListT m) a
06:01:30 <quicksilver> handleInput Login ... = ...; handleInput Creation ... = ...;
06:02:20 <nolrai_> :t (lift . Control.Monad.List.ListT . return) [] :: ListT (State s) t
06:02:22 <lambdabot> Not in scope: type constructor or class `ListT'
06:02:38 <nolrai_> :t (lift . Control.Monad.List.ListT . return) [] :: Control.Monad.List.ListT (State s) t
06:02:39 <Gilly> yea but then along that information you'll have to carry other information as well
06:02:39 <lambdabot>     Couldn't match expected type `State s'
06:02:40 <lambdabot>            against inferred type `Control.Monad.List.ListT m'
06:02:40 <lambdabot>       Expected type: m [a] -> State s t
06:02:50 <Gilly> like when in login stage the user has already given the username but not password
06:02:59 <nolrai_> :t (lift . Control.Monad.List.ListT . return) [] :: Control.Monad.List.ListT (Control.Monad.State.State s) t
06:03:01 <lambdabot>     Couldn't match expected type `State s'
06:03:01 <lambdabot>            against inferred type `Control.Monad.List.ListT m'
06:03:01 <lambdabot>       Expected type: m [a] -> State s t
06:03:23 <nolrai_> :t (Control.Monad.List.ListT . return) [] :: Control.Monad.List.ListT (Control.Monad.State.State s) t
06:03:25 <lambdabot> forall s t. Control.Monad.List.ListT (State s) t
06:03:41 <Gilly> but yea, if i gave client threads more control i could at least in login and character creation make blocking calls
06:03:42 <Peaker_> how come the cabal and cabal-install darcs repositories are not in sync?  The version of cabal is 1.5.2 but cabal-install wants cabal <= 1.5
06:05:28 <quicksilver> Gilly: well yes you use blocking calls when you can, it's much simpler.
06:06:08 <gwern> ToRA: oh, I didn't know smallcheck could do that. I sort of thought it was just a non-random quickcheck
06:07:06 <gwern> ToRA: but anyway, I thought about the tautology problem and concluded that that was why a depth-first search would be terrible, but a breadth-first one would get around the "only investigating dumb functions" problem
06:07:07 <Gilly> yep, i've been just trying to find out if it's possible to make some kind of "blocking" calls without making threads, like have a piece of code waiting for execution until it's 'feed' with data
06:07:58 <quicksilver> Gilly: the way to make blocking calls is to use threads.
06:08:09 <quicksilver> Gilly: threads are the right way.
06:08:23 <Gilly> right :)
06:08:32 <quicksilver> Gilly: there is an abstraction we use for blokcing calls: it's called threads :)
06:08:33 <ToRA> gwern: in reality you probably want to use iterative deepening (emulate breadth-first using depth first), but don't under-estimate how big your search space is going to get
06:08:56 <Gilly> quicksilver: ouch :) though that's reasonable now that you state it that way...
06:09:07 <Gilly> i guess i got to redesign this now
06:09:14 <quicksilver> Gilly: if you think throught your suggested alternative
06:09:17 <ToRA> gwern: a while ago i did some work on generating featherweight java programs to test java compilers which is in a similar ball-park to what you're talking about
06:09:24 <quicksilver> I'm failry sure you'd find it was more complex.
06:09:47 <ToRA> gwern: the upshot was there are more programs than you can imagine, and basically none of them type check
06:09:48 <Gilly> yea i'm afraid it's gonna be...
06:09:57 <Gilly> thanks for opening my eyes :)
06:10:12 <gwern> ToRA: featherweight?
06:10:45 <ddarius> Gilly: Event-based programming and threading are dual.
06:10:49 <ToRA> a "minimal core calculus" that represents an abstraction of java
06:11:10 <gwern> ah
06:12:06 <gwern> (so maybe a pointless/combinator approach would be better, then - if I am interested in :: [Int]s, then make a list of all the math and useful control operators, and begin going through the combos...)
06:13:21 <Peaker_> Given a darcs repo of cabal, how can I revert back to its revision that was still version 1.5?
06:13:26 <Peaker_> <1.5 that is
06:14:05 <ivanm> Peaker_: there's a seperate repo for the 1.3 (which will be released as 1.4) branch
06:14:06 <ToRA> gwern: if you're doing stuff with control operators, you risk generating equivalent functions through different programs though
06:14:17 <Peaker_> ivanm: The "ghc-bound" one?
06:14:18 <gwern> Peaker_: lazily, I would go rollback and keep hitting the appropriate key
06:14:27 <ivanm> Peaker_: ummm.... not sure what you mean
06:14:50 <ivanm> you meant the one that's packaged with ghc-6.8? (i.e. cabal 1.2.x)
06:15:03 <ivanm> it has its own repo
06:15:09 <gwern> ToRA: well, my thinking is, instead of 'string' length, we use token length - if I use a whitelist of 100 math and control operators, and I specify a depth of 1, then there's only 100 programs to check
06:15:10 <ivanm> they branch off a new one for each release, I believe
06:15:14 <ivanm> @seen dcoutts
06:15:14 <lambdabot> dcoutts is in #xmonad, #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 3h 36m 44s ago.
06:15:32 <Peaker_> ivanm: do you have the URL of the 1.3 one?
06:15:52 <ToRA> gwern: yup
06:16:03 <ivanm> http://darcs.haskell.org/cabal-branches/cabal-1.4
06:16:04 <lambdabot> Title: Index of /cabal-branches/cabal-1.4
06:16:32 <ToRA> gwern: ideally you could add information so that when you go to depth 3 or 4, you don't end up pointlessly commuting commutative operators etc.
06:16:38 <Peaker_> ivanm: thanks
06:16:50 <ivanm> no problems!
06:17:47 <quicksilver> Gilly: in terms of your point about the state parameter getting fairly complex
06:17:55 <quicksilver> Gilly: well, yes, it does in a complex system.
06:18:10 <quicksilver> it's a fact of complex networked apps that the client state is rather large
06:18:15 <gwern> ToRA: well, I'm not sure how you could do that. one way would be to define rewrite rules - 'replace all instances of "id . foo" with  "foo"', but for short functions any comprehensive analysis would probably take way longer than just testing it!
06:18:23 <quicksilver> but it's nicer to have client state being rather large and explicitl,
06:18:33 <quicksilver> than rather large and implicitly spread among a bunch of global variables
06:18:42 <gwern> I'm tempted to say 'just don't have id in the whitelist', but I think there are actual needs for things like id and const
06:18:44 <quicksilver> as would generally be the case in a natural imperative solution.
06:18:55 <gwern> and that wouldn't help for multiple term expressions which cancel out
06:20:09 <ToRA> yup
06:21:20 * ToRA wonders if it's provably impossible to take a turing complete language and to have a strategy that enumerates all non-isomorphic programs in finite time
06:21:43 <Sam__> of course it is
06:21:46 <Peaker_> aren't there infinite non-isomorphic programs?
06:22:07 <Sam__> you can't enumerate all terminating programs even
06:22:25 <ToRA> yes, but you can have a strategy that enumerates every element of an infinite set in finite time
06:22:40 <ToRA> Sam__: yeah, i think that's what it boils down to
06:23:05 <Sam__> and adding in the "non-isomorphic" doesn't seem likely to make it any easier ;-)
06:23:25 <ToRA> Sam__: since you only want to enumerate one non-terminating program (all other non-terminating programs are isomorphic to it)
06:25:51 <dcoutts_> ivanm: pong
06:26:38 <ivanm> I didn't even ping you! :o
06:26:44 <dcoutts_> Peaker_: did you get it worted?
06:26:53 <Peaker_> doesHalt program = program `elem` enumerateAllHaltingPrograms
06:26:55 <dcoutts_> erm worted/sorted
06:26:56 <ivanm> just seeing if you're around to help Peaker_'s search for the cabal darcs repo
06:27:07 <Peaker_> dcoutts_: Yeah, got the cabal from the 1.4 branch and now it works, thanks
06:27:08 <dcoutts_> ivanm: though I see you found it
06:27:18 <gwern> enumerate every element of an infinite set in finite time?.... o.0 what, like [0,1,0,1...] could be enumerated as (0,1)?
06:27:31 <ivanm> dcoutts_: yup... hacking the cabal-darcs-1.4_alpha ebuild was useful for something! :p
06:27:37 <dcoutts_> :-)
06:27:41 <Sam__> gwern: I think he means that each element would be reached in some finite time
06:27:44 <dcoutts_> Peaker_: great
06:27:53 <Sam__> not that the time would be the same for all elements
06:28:07 <ToRA> gwern: what Sam__ said :)
06:28:13 <Peaker_> Sam__: and thus my doesHalt function would work! :)
06:28:40 <dcoutts_> gwern: btw, about the debian/copyright bug... (thanks for reporting it btw).
06:28:48 <Sam__> Peaker_: ... it doesn't work for EVERY set
06:29:01 <Peaker_> Sam__: It wouldn't work here, or it'd solve the halting problem :)
06:29:05 <gwern> dcoutts_: oh, did you fix it?
06:29:12 <dcoutts_> gwern: I think the right behaviour is to copy debian/copyright to $docdir/ rather than to $docdir/debian/ . Seem sensible?
06:29:52 <dcoutts_> gwern: so the fix is just to use docdir </> takeFileName licenseFile rather than docdir </> licenseFile
06:30:10 <gwern> dcoutts_: yes; I was sort of thinking that it ought to accept the link but copy it into the right directory as the basename not the full literal
06:30:19 <dcoutts_> gwern: right. I'll apply that fix.
06:30:53 <dcoutts_> gwern: so the license file can be anywhere in the source tree but always gets copied direct to the $docdir
06:31:32 <gwern> dcoutts_: that'll be good for all the repos supporting debian (ie most of the seereason and jpgoerzen repos, for starters)
06:31:54 <dcoutts_> gwern: right, I'll get the fix into 1.4
07:01:16 <tobi_tud> hi
07:01:39 <tobi_tud> is there a way to convert [IO a] -> IO [a] ?
07:01:44 <wjt> @ty sequence
07:01:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:02:16 <tobi_tud> hm, thx
07:10:57 <RayNbow> @pl (\xs -> foldr (liftM2 (:)) (return []) xs)
07:10:57 <lambdabot> foldr (liftM2 (:)) (return [])
07:11:08 <hpaste>  paolino pasted "naive google treasure hunt robot" at http://hpaste.org/8213
07:11:09 <RayNbow> oh right
07:11:42 <paolino> anyone can help me to find out why that is so slow ?
07:14:54 <Lemmih> paolino: What does it do?
07:14:57 <paolino> the problem is counting unique paths from corner to corner in a rectangular grid, easy to solve with a tartaglia triangular
07:15:47 <luite> oh pascal's triangle
07:16:15 <paolino> pascal ? can be :)
07:16:50 <paolino> it takes ages with a 20x20
07:16:59 <luite> yes, that's how I know it, the wikipedia page mentions this: Finally, in Italy, it is referred to as "Tartaglia's triangle", named for the Italian algebraist NiccolÚ Fontana Tartaglia who lived a century before Pascal (1500-1577);
07:19:03 <paolino> the code gives right results but has an exponential behave which I can't understand
07:20:19 <quicksilver> paolino: it's wasteful to call member and then !
07:20:25 <quicksilver> paolino: better just to call lookup
07:20:53 <quicksilver> paolino: however that's not going to make exponential.
07:20:55 <paolino> right, but that is not exponential
07:21:01 <quicksilver> paolino: deps looks suspect
07:21:15 <paolino> uh, not only ugly
07:22:15 <quicksilver> paolino: ah
07:22:19 <quicksilver> paolino: stupid state monad error :)
07:22:23 <quicksilver> paolino: you re-use 'c'
07:22:37 <quicksilver> paolino: thus wasting the benefit of the recurse calls to valuate
07:22:56 <paolino> eh
07:22:57 <quicksilver> paolino: the mantra to avoid this bug is "never use put, always use modify"
07:23:11 <quicksilver> modify (Map.insert i r')
07:24:49 <paolino> ok, I should be fired for that :)
07:24:50 <sieni> ~2
07:25:29 <quicksilver> paolino: it's the most common state monad error. I have made it myself several times that's why I recognised it
07:25:36 <quicksilver> paolino: it's best to try quite hard to avoid naming the state.
07:25:51 <quicksilver> name the state and you're almost guaranteed to accidentally make use of an old version :)
07:26:03 <quicksilver> paolino: that error once let to a bug in a GHC optimsation :)
07:26:48 <paolino> ok
07:27:19 <RayNbow> roconnor, thank you for frying my mind... [ http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms ]
07:27:20 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
07:27:42 <EvilTerran> good lord!
07:28:24 * EvilTerran drops his monocle
07:30:03 <Spark> is this the sort of paper that starts with "Assume a conjunctive hyperwart... "
07:31:50 <vixey> you should see a doctor about that
07:32:02 <mapreduce> A co-doctor.
07:32:24 <paolino> doctor Zigovago
07:36:35 <paolino> quicksilver: how deps should be written instead ?
07:36:54 <quicksilver> paolino: I think it's fine.
07:37:30 <quicksilver> paolino: I misread it :)
07:37:59 <paolino> I think it's awful
07:38:25 <paolino> (that's why you misread it :) )
07:39:12 <quicksilver> I thought you were recursing under ++
07:39:15 <quicksilver> which is a bad plan
07:39:26 <quicksilver> but it's actually just a simple maximum 2 element list
07:39:31 <quicksilver> so I think it's fine :)
07:40:04 <saml> [1,2,3,3,3,2,0] ==> [[1],[2],[3,3,3],[2],[0]]   how do I do this? split a list according to contiguous region
07:40:10 <quicksilver> group
07:40:17 <quicksilver> > group [1,2,3,3,3,2,0]
07:40:20 <lambdabot>  [[1],[2],[3,3,3],[2],[0]]
07:40:25 <saml> quicksilver: thanks!!!
07:40:50 <paolino> is that an unfold ?
07:41:18 <Lemmih> I wonder if we could write some tool similar to Hoogle for answering questions like that.
07:41:59 <vixey> I think the haskell report is fine
07:42:07 <flux> djinn with steroids ;)
07:42:26 <flux> well, I suppose it'd be a bit different still
07:43:12 <jkff> I think a hoogle on the expected type is enough
07:43:54 <Lemmih> Yeah, we don't want computers competing with us for jobs.
07:43:59 <flux> perhaps a simple version would just infer the types of the expressions, and feed them back to hoogle - I guess this is what lemmih was thinking?
07:44:29 * vixey laughs at http://en.wikipedia.org/wiki/Operator-precedence_parser#Alternatives_to_Dijkstra.27s_Algorithm
07:44:30 <lambdabot> http://tinyurl.com/28srjk
07:44:34 <flux> actuall, after you get that list of functions, you could just brute force your way through to find the appropriate one
07:45:05 <flux> so simpler than one might after all
07:45:44 <tchakkazulu> ?. hoogle type \[1,2,3,3,3,2,0] -> [[1],[2],[3,3,3],[2],[0]]
07:45:44 <lambdabot> Did you mean: forall t t1. (Num t1, Num t) => [t] -> [[T1]]
07:45:44 <lambdabot> Data.List.inits :: [a] -> [[a]]
07:45:44 <lambdabot> Data.List.tails :: [a] -> [[a]]
07:45:51 <vixey> @hoogle+
07:45:52 <tchakkazulu> Awww... works in theory, though :P
07:45:56 <Lemmih> flux: It would be interesting if it could recognize subproblems and solve them by combining functions.
07:46:19 <flux> lemmih, indeed, white-paper-level interesting :)
07:46:53 <flux> but perhaps some path finding algorithm for types could be feasible for simple problems
07:47:04 <flux> and then, after finding appropriate combinations, bruteforce that
07:47:14 <saml> @pl (map (\x -> [f x, g x]))
07:47:14 <lambdabot> map (liftM2 (:) f (return . g))
07:47:22 <kamaji> there's part of a function i'm looking at, "expsum _ 0 = 1", what does the underscore mean?
07:47:43 <vixey> kamaji: it's exactly the same as expsum x 0 = 1
07:47:53 <vixey> kamaji: and f _ _ = 3 is the same as f x y = 1
07:48:03 <kamaji> so it basically means "ignore whatever's there"?
07:48:07 <r3m0t> @pl (\(x,y) -> (y,x))
07:48:08 <lambdabot> uncurry (flip (,))
07:48:10 <vixey> kamaji: yes, _ is a don't-care variable name
07:48:15 <kamaji> awesome, thanks much
07:48:18 <vixey> r3m0t: swap
07:48:27 <r3m0t> vixey: thanks
07:48:50 <osfameron> though you can't use the value of _ so it's not a variable in the same way
07:49:04 <r3m0t> vixey: wait, what?
07:49:09 <r3m0t> vixey: http://www.haskell.org/hoogle/?q=(a%2Cb)+-%3E+(b%2Ca)
07:49:11 <twanvl> flux: I have seen some papers about this
07:49:11 <lambdabot> Title: (a,b) -> (b,a - Hoogle
07:49:30 <paolino> @hoogle swap
07:49:31 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
07:49:31 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
07:51:30 <EvilTerran> swap = uncurry (flip (,)) would be nice
07:51:44 <EvilTerran> maybe we could get it in Data.Tuple for the next version
07:51:59 <EvilTerran> or we could at least add it to Caleskell
07:52:14 <vixey> is it better than swap (x,y) = (y,x)? for lazyness maybe
07:52:28 <quicksilver> EvilTerran: I think it's already in the next Data.Tuple
07:52:44 <EvilTerran> vixey, actually, i think the thing to write would be "swap ~(x,y) = (y,x)"
07:53:12 <EvilTerran> quicksilver, yay! :D
07:53:23 <EvilTerran> ?src uncurry
07:53:23 <lambdabot> uncurry f p = f (fst p) (snd p)
07:53:31 <EvilTerran> ?src fst
07:53:31 <lambdabot> fst (x,_) =  x
07:53:36 <r3m0t> ~ ?
07:54:15 <saml> > 2 ^ 300
07:54:16 <lambdabot>  2037035976334486086268445688409378161051468393665936250636140449354381299763...
07:54:29 <EvilTerran> hm. distinct lack of ~s. i guess it still makes the act of entering uncurry happen before the pattern-match anyway, that being the point
07:54:47 <EvilTerran> r3m0t, it makes a pattern unconditional
07:54:59 <r3m0t> but (x,y) is already unconditional
07:55:11 <EvilTerran> this means it'll act like it always matches, but, if it didn't really, you get an error when you try to force one of the variables in the pattern
07:55:22 <tchakkazulu> > let f (x,y) = 0 in f undefined
07:55:23 <lambdabot>  Exception: Prelude.undefined
07:55:30 <tchakkazulu> >let f ~(x,y) = 0 in f undefined
07:55:34 <tchakkazulu> > let f ~(x,y) = 0 in f undefined
07:55:35 <lambdabot>  0
07:55:35 <vixey> > fix (\(x,y)->(0:y,1:x))
07:55:38 <vixey> > fix ~(\(x,y)->(0:y,1:x))
07:55:38 <lambdabot>  Parse error in expression at end of input
07:55:44 <EvilTerran> so the part of the case-ee that's matched inside the ~ doesn't get forced at the time of the pattern-match
07:55:45 <vixey> > fix (\~(x,y)->(0:y,1:x))
07:55:45 <lambdabot>  Parse error at "->(0:..." (column 13)
07:55:51 <lambdabot>  thread killed
07:55:54 <vixey> > fix (\ ~(x,y) -> (0:y,1:x))
07:55:57 <lambdabot>  ([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
07:56:00 <vixey> > fix (\ (x,y) -> (0:y,1:x))
07:56:04 <vixey> there is an example
07:56:16 <lambdabot>  thread killed
07:56:45 <EvilTerran> oh, hey r3m0t. you managed to completely confuse me about which IRC tab i'm in there
07:56:50 <r3m0t> sorry
07:57:44 <EvilTerran> r3m0t, but do you see the point of ~ now?
07:58:20 <EvilTerran> makes things lazier
07:59:19 <r3m0t> not really
07:59:25 <r3m0t> but I'm not fussing about it atm
07:59:40 <r3m0t> I just remembered there was a nice way to write swap without pattern-matching, so I came here
07:59:48 <EvilTerran> it's not really that nice
07:59:54 <vixey> I don't like it
07:59:55 <vixey> :P
08:00:09 <vixey> I need to parse infixy stuff
08:00:14 <EvilTerran> i'd just go for defining "swap ~(x,y) = (y,x)" in the utility functions bit of my .hs file
08:00:28 <r3m0t> yeah ok
08:00:32 <tchakkazulu> ?type snd &&& fst
08:00:34 <lambdabot> forall a b. (a, b) -> (b, a)
08:00:46 <r3m0t> ?type &&&
08:00:47 <dolio> > let tl = snd . foldr (\e ~(t,t') -> (e:t, t)) ([], error "tail of empty list") in tl [1..]
08:00:49 <lambdabot> parse error on input `&&&'
08:00:49 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
08:00:52 <r3m0t> ?type (&&&)
08:00:52 <dolio> > let tl = snd . foldr (\e (t,t') -> (e:t, t)) ([], error "tail of empty list") in tl [1..]
08:00:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:00:56 <lambdabot>  Exception: stack overflow
08:01:41 <EvilTerran> r3m0t, if it helps, read "a b c" as "(->) b c" (and hence "(b -> c)"
08:01:58 <vixey> oh yes
08:02:05 <tchakkazulu> Yeah, the whole Arrow abstraction makes those types a hell to read.
08:02:11 <EvilTerran> Arrows are a general abstraction including functions
08:02:13 <vixey> forall (a :: * -> * -> *) b c c'. (Arrow (~>)) => b ~> c -> b ~> c' -> b ~> (c, c')
08:02:22 <vixey> with ~> binding tighter than ->
08:02:25 <EvilTerran> ?instances-importing Control.Arrow Arrow
08:02:26 <lambdabot> (->), Kleisli m
08:02:58 <EvilTerran> if it weren't for the class constraint on the keys of Maps, you could have instance Arrow Map, too (i think)
08:03:21 <EvilTerran> seeing as a Map is basically a more concrete representation of a function
08:03:48 <tchakkazulu> Sure. Just use "lookup", and a Kleisli Maybe.
08:04:15 <tchakkazulu> (at least, those'd be the semantics. Actual implementation may be different)
08:04:39 <Saizan_> EvilTerran: uhm, not so directly, how do you write arr?
08:04:52 <EvilTerran> ah, yes. the troublesome "arr"
08:04:54 <tchakkazulu> Oh, yes. "arr".
08:05:02 <dolio> arr = buildInfiniteMap :)
08:05:04 <EvilTerran> make it a Control.Category, then, i guess?
08:06:27 <dolio> Or, I suppose it might not be infinite.
08:07:16 <Saizan_> the problem is that you've to enumerate the domain
08:07:32 <dolio> You could go with 'arr f = map (id &&& f) $ enumerateDomain'
08:07:33 <vixey> Does anyone know of some examples of deriving parsers and unparsers simultaneously?
08:07:51 <EvilTerran> i guess you could do it with some further constraint on the domain and a sufficiently lazy memoising structure
08:07:59 <dolio> Er, fromList.
08:09:32 <EvilTerran> some kind of self-balancing tree, if you feel like doing cheeky mutation under the hood
08:10:19 <saml> > let morris l = foldl (\li (x,y) -> x:y:li) [] (map (\x -> (length x, head x)) (group l)) in (length (iterate morris [1] !! 300)) -- make it run fast
08:10:23 <lambdabot>  out of memory (requested 1048576 bytes)
08:11:46 <quicksilver> EvilTerran: more concrete rep. of function are precisely what arrows are not.
08:11:59 <quicksilver> EvilTerran: arrows are a more abstract rep of a function :)
08:13:12 <vixey> unparsing is not injective :/
08:13:41 <vixey> actually that's not what I mean
08:13:45 <vixey> It's not a function
08:15:07 <vixey> this is ridiculous.. http://www.codeproject.com/KB/recipes/FastMathParser.aspx
08:15:09 <lambdabot> Title: CodeProject: Fast mathematical expressions parser. Free source code and programm ...
08:15:42 <sieni> vixey: I guess you can still do pretty printing
08:17:57 <RayNbow> vixey: why would one need a math parser when people can use Haskell? :p
08:18:22 <vixey> that is exactly what I was thinking RayNbow :)
08:19:19 <Armored_Azrael> Hey, out of curiosity, why doesn't read dump also the text it was trying to parse when it failed? I've got a wrapper that does that in a program I'm writing, and am confused as to why this is not default behavior.
08:19:44 <vixey> "dump" meaning..?
08:19:51 <Armored_Azrael> out to stderr
08:19:58 <Armored_Azrael> i.e. right now if you have a read error, you get
08:20:13 <Armored_Azrael> Prelude.read: no parse
08:20:14 <Lemmih> Armored_Azrael: It can't.
08:20:15 <quicksilver> Armored_Azrael: because read is a simplistic toy.
08:20:20 <Armored_Azrael> OK
08:20:29 <vixey> I think would be a really bad idea ....
08:20:35 <vixey> what if the text you are reading from is infinite
08:20:43 <Armored_Azrael> I suppose that's true.
08:20:47 <quicksilver> you'd just display the first 70 chars
08:20:53 <quicksilver> it's not rocket science :P
08:21:16 <quicksilver> but read is not designed to be the building block for a robust parser with good error reporting
08:21:25 <quicksilver> it's a handy tool for simplistic data (de)serialisation
08:21:51 <Armored_Azrael> Yes. This is what I'm using it for. Unfortunately, occasionally one of my functions does something I don't expect.
08:22:00 <RayNbow> <quicksilver> you'd just display the first 70 chars <-- but what if you want to know the 71st character? :p
08:22:05 <Armored_Azrael> (I'm ferrying data along pipes)
08:22:10 <quicksilver> RayNbow: then you'd be no worse off than you are now.
08:22:15 <RayNbow> :p
08:22:17 <quicksilver> Armored_Azrael: use reads, not read.
08:25:58 <EvilTerran> quicksilver, i mean Maps are
08:27:53 <quicksilver> EvilTerran: Maps are a kind of concrete function, yes
08:28:02 <quicksilver> EvilTerran: as such they are not arrows therefore.
08:30:19 <EvilTerran> er, words?
08:30:20 <quark> can anyone answer a GHC compilation question?  i want to build GHC from source so that it cretes binarues which dynamically load libgmp, on Mac OS X.  is there a "configure" flag that I need to give to tell it to do that?
08:31:29 <quicksilver> if only it was that simple quark
08:31:35 <saml> i bet ghc only lnks statically
08:31:50 <quicksilver> you bet wrong.
08:31:58 <saml> i should never go to las vegas
08:32:04 <quicksilver> quark: you may find some enlightenment in this ticket, quark http://hackage.haskell.org/trac/ghc/ticket/1540
08:32:05 <lambdabot> Title: #1540 (GHC on Macs) - GHC - Trac
08:32:12 <quicksilver> quark: but I must tell you that I've never got it worked out myself.
08:33:24 <quicksilver> saml: GHC uses static linking for stuff it compiles itself, including libraries used by haskell code, but it may dynamic link the core deps of teh RTS
08:33:31 <quicksilver> saml: i.e. libc and ligmp, on most OSes.
08:34:40 <saml> @where RTS
08:34:40 <lambdabot> I know nothing about rts.
08:35:09 <saml> i think it makes sense.
08:37:54 <Armored_Azrael> quicksilver: Though you can convert to a shared object if you trick GHC during compilation and have it compile all the libraries with -fPIC
08:38:16 <Armored_Azrael> quicksilver: Then afterwards you can link things up as shared objects via manual linking.
08:42:19 <dotsintacks> I need help with terminology. I have a list of functions (f1, f2, f3, f4). What is the operation that makes f1(f2(f3(f4())))?
08:43:16 <vixey> first of all (f1, f2, f3, f4) is not a list
08:43:21 <vixey> [f1, f2, f3, f4] is
08:43:28 <dotsintacks> I'm not speaking in haskell syntax, specifically.
08:43:31 <dotsintacks> :) but okay...
08:43:42 <vixey> what syntax are you using?
08:44:08 <dotsintacks> um. blub
08:45:07 <Armored_Azrael> You seem to be looking for:
08:45:07 <Armored_Azrael> foldr (.) id
08:45:24 <EvilTerran> ?type foldr ($) () -- this?
08:45:32 <dotsintacks> okay, so a fold from the right.
08:45:39 <lambdabot> thread killed
08:45:39 <EvilTerran> yes
08:45:42 <EvilTerran> ?bot
08:45:42 <lambdabot> :)
08:45:42 <dotsintacks> I thought that was about it. I'm writing some python and just needed a name ;)
08:45:54 <EvilTerran> > foldr ($) x [f,g,h] :: Expr
08:46:05 * EvilTerran pokes lambdabot
08:46:09 <lambdabot>  thread killed
08:46:16 <EvilTerran> > foldr ($) x [f,g,h] :: Expr -- let's try this again
08:46:18 <twanvl> I believe python calls foldl 'reduce'
08:46:30 <lambdabot>  thread killed
08:46:33 <dotsintacks> well in my specific case I needed foldr :)
08:46:33 <Armored_Azrael> ?type foldr1 (.)
08:46:35 <lambdabot> forall a. [a -> a] -> a -> a
08:46:36 <EvilTerran> > 1 + 2
08:46:50 <lambdabot>  3
08:46:50 <Syzygy-> > foldr ($) x [f, g, h]
08:46:53 <lambdabot>  f (g (h x))
08:47:07 <EvilTerran> ... Cale's lambdabot's owner, isn't he? might be good to look into what's making @run be so slow
08:47:10 <Syzygy-> EvilTerran: If you just skip that type declaration, she does the right thing. :P
08:47:20 <EvilTerran> ... weird
08:47:38 <EvilTerran> > foldr ($) x [f,g,h] -- or maybe she just doesn't like me
08:47:39 <Cale> EvilTerran: I can't look into that, since I'm not the owner of the machine on which lambdabot is running.
08:47:39 <lambdabot>  f (g (h x))
08:47:56 <Syzygy-> Cale: Is it dons? dcoutts?
08:47:59 <EvilTerran> ah
08:48:02 <Cale> EvilTerran: That machine has been randomly flaky lately.
08:48:25 <dcoutts_> lambdabot runs on code.h.o right?
08:48:32 <quicksilver> random flakiness is a very valuable property
08:48:38 <quicksilver> if you can harness that to make chocolate
08:48:43 <quicksilver> you will become rich!
08:48:47 <Deewiant> erm
08:48:51 <Deewiant> what?
08:48:55 <dcoutts_> or to generate good random numbers
08:49:02 <EvilTerran> quicksilver++ for teh randoms
08:49:30 <EvilTerran> (i lol'd)
08:49:49 <dcoutts_> Cale: so what kind of flakeyness? it's uptime seems to be pretty good? is connectivity intermittent or something?
08:50:06 <dcoutts_> Cale: or does lambdabot just inspire the wrath of the out-of-memory killer?
08:50:26 <Cale> dcoutts_: Something was randomly firing TERM signals at my darcs processes the other day.
08:50:41 <dcoutts_> Cale: probably the OOM killer :-)
08:51:48 <dcoutts_> apparently we have ~590Mb ram on code.h.o
08:52:24 <dcoutts_> Cale: you've got 11 runplugs instances running
08:52:43 <dcoutts_> each taking ~17Mb resident memory
08:52:56 <Cale> dcoutts_: oh? that's interesting
08:53:06 <quicksilver> 17M resident not virtual?
08:53:09 <quicksilver> thats rather a lot.
08:53:13 <dcoutts_> yep, resident
08:53:22 <dcoutts_> Cale: and lambdabot is taking 157m resident
08:53:47 <Cale> They're all zombies
08:53:50 <dcoutts_> ah, now all the runplugs are defunct
08:53:50 <quicksilver> my ghci-6.6.1 has 63M resident for comparison.
08:54:04 <quicksilver> defunct processes don't really take up memory
08:54:10 <dcoutts_> Cale: yes, they are now, there were not a min ago
08:54:12 <quicksilver> they just haunt the process table.
08:54:16 <dcoutts_> quicksilver: I know
08:54:19 <quark> hi quicksilver, sorry I was captured by a coworker there.  ... i'm not sure i follow why that URL is relevant to me; i have GHC running on my mac, i'm just worried that programs i compile have libgmp statically linked in them.  is there a unix command which will inspect a binary and tell me?
08:54:22 <dcoutts_> I was not counting the defunct ones
08:54:43 <quicksilver> quark: that link explains some of the issues which I don't understand and therefore can't explain myself :)
08:54:50 <quicksilver> quark: otool -L will show you
08:55:34 <quicksilver> dcoutts_: 590M is really not very much RAM. Is it possible to arrange for RAM donations? I'm sure people would stump up.
08:55:47 <RayNbow> @pl (\x -> if x < 0 then (-x) else x)
08:55:56 <lambdabot> join (liftM2 if' (< 0) negate)
08:55:58 <quark> quicksilver: and if libgmp is in that list, then it's being dynamically loaded?
08:56:04 <dcoutts_> quicksilver: it's a cheap virtual host paid for out of haskell.org's GSoC funding
08:56:14 <dcoutts_> Cale: perhaps we could run lambdabot with profiling and see what's leaking
08:57:02 <RayNbow> what is if'?
08:57:07 <RayNbow> @src if'
08:57:07 <lambdabot> Source not found. Wrong!  You cheating scum!
08:58:34 <tchakkazulu> RayNbow: if' p x y = if p then x else y
08:59:00 <tchakkazulu> Not sure if it's defined anywhere, other than in countless utility modules that people write for themselves.
08:59:25 <quicksilver> quark: correct.
08:59:32 <RayNbow> tchakkazulu: ah
08:59:34 <RayNbow> thx
08:59:49 <quicksilver> I've actually never used if'
08:59:54 <quicksilver> it sounds like a nice idea in principle.
09:00:03 <quicksilver> but doesn't actually seem to be necessary (to me)
09:00:21 <quicksilver> dcoutts_: I would think that haskell.org could afford 40UKP/month for a dedicated server.
09:00:26 <quark> quicksilver: well then, it appears I don't have a problem!  libgmp is expected.
09:00:32 <quicksilver> quark: ;)
09:00:38 <dcoutts_> quicksilver: we may well get one
09:01:13 <quicksilver> dcoutts_: I appreciate that running LB may not seem like an exceptionally good reason though :)
09:01:21 <quicksilver> it is a rather useful tool.
09:01:23 <dcoutts_> quicksilver: heh :-)
09:01:23 <Deewiant> @pl if'' f g p x y = if p then f x else g y
09:01:23 <lambdabot> if'' = flip . ((flip . ((.) .)) .) . flip ((.) . if')
09:01:49 <jamii> @seen dons
09:01:50 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 53s ago.
09:02:08 <jamii> Excellent. Don?
09:02:20 <dons> yo.
09:02:33 <dcoutts_> quicksilver: there are plans for a much more beefy machine but no announcements yet
09:02:45 <dons> dcoutts_: have you seen the Arch Linux wiki? for every app they have, there's pretty much a wiki page with a standard format on how to install and use it.
09:02:56 <dons> i'd love to have, for each hackage package, a similar wiki page
09:03:09 <dons> so users can fill out standard examples and instructions for everything.
09:03:10 <dcoutts_> dons: but why would you need one when it's the same for each package?
09:03:14 <dons> say, under haskellwiki/Packages/*
09:03:17 <jamii> Hi. Does Data.Binary perform any compression or bitpacking after converting to ints?
09:03:24 <dons> dcoutts_: no, so just a blurb with how to install it, and any wibbles, then examples
09:03:40 <dons> its about having a standard place for people to put package-related snippets
09:03:41 <dcoutts_> jamii: no, but you can use compression afterwards yourself, eg with the zlib package
09:04:14 <jamii> So each constructor gets its own machine word in the output?
09:04:14 <dons> i'll create some pages today, and see what it looks like. i bet if i can get a few together, we'll be in business.
09:04:22 <dons> then just tweak hackage to link to the wiki page for each package
09:04:27 <oldsalt> can someone give me a little push on io? http://hpaste.org/8214
09:04:45 <dcoutts_> dons: mm, I can see the advantage for some projects, but many already have their own pages, we're not trying to steal everyone's websites
09:05:08 <dolio> @pl \f g p x y -> either f g (boolToEither p x y)
09:05:08 <lambdabot> flip flip boolToEither . (((.) . (.) . (.)) .) . either
09:05:11 <dons> right. same as for arch linux. this is haskell specific stuff, and most importantly, user contributed.
09:05:15 <dcoutts_> dons: a link to a wiki is fine of course, we already have the homepage url in the .cabal files
09:05:18 <dons> take advantage of all those users.
09:05:54 <dons> i just noticed that every question i had about arch, there was a wiki page already, with examples and advice.
09:06:08 <dons> the best way to take advantage of the hive mind :)
09:06:11 <dcoutts_> dons: as you know I'm also a tad nervous about piling on the features when we've got no solid foundation for the hackage website
09:06:25 <dcoutts_> dons: I started looking at HAppS at the weekend
09:06:48 <kpreid> oldsalt: what's the problem?
09:07:08 <kpreid> oldsalt: (btw, "x <- return 1" can be written as "let x = 1")
09:07:09 <dcoutts_> dons: so I absolutely believe in taking advantage of the distributed user base, build reporting, user contributed package info etc, I just want to do it right
09:07:16 <oldsalt> it always fails with*** Exception: /tmp/foo.bin: openBinaryFile: resource busy (file is locked)
09:07:32 <wjt> kpreid: does the latter desugar to the former, out of interest?
09:07:34 <oldsalt> kpreid: yeah, it was not about winning a haskell beauty contest, i know ;)
09:07:40 <kpreid> wjt: no
09:07:41 <dons> dcoutts_: right.
09:07:55 <dons> the user base is how we win. whoever best leverages that.
09:07:58 <kpreid> oldsalt: hm, I don't know.
09:07:59 <wjt> oh, i guess it doesn't have to because do { let foo = bar; q } can become let foo = bar in q
09:08:09 <dcoutts_> dons: perhaps what we do want is a wiki page per package, we could do that with the existing haskell wiki right?
09:08:20 <dons> i think this is why arch is doing so well, fwiw, its wiki-like for package contributions (a la hackage), and wiki like for the entire documentation
09:08:26 <kpreid> wjt: just so
09:08:28 <dons> right, that's exactly what i want
09:08:36 <dons> a package template, and wiki page per package
09:08:49 <dons> then users put up and link to snippets, advice, blogs, etc.
09:09:13 <dons> ideally you'd have a trac page per package too, to track issues.
09:09:27 <dons> but the wiki is ready to go. we did this for xmonad, so i've got an idea on how to set up a nice template
09:09:28 <dcoutts_> dons: ok, so how about http://haskell.org/haskellwiki/Packages/$pkgname ?
09:09:29 <lambdabot> Title: Packages/$pkgname - HaskellWiki
09:09:41 <dons> yep, exactly
09:09:52 <quicksilver> wjt: that desugaring might occur with particular monads
09:10:06 <quicksilver> wjt: if the monad is statically known at compile time, and the definition of 'return' is inlined.
09:10:14 <quicksilver> wjt: then you might expect it to vanish.
09:10:15 <dons> makes the 'commit bit' for contributing back docs and examples really really cheap
09:10:29 <dcoutts_> dons: we cannot have a trac per package since people really have their own bug trackers, they'd be annoyed if we made another. But links to existing bug trackers is obviously fine.
09:10:30 <wjt> quicksilver: let would be desugared to return in that case?
09:10:37 <quicksilver> not that a <- return b is not quite the same as let a = b if "a" is a failable pattern.
09:10:45 <quicksilver> wjt: no, return would inline to let
09:10:53 <wjt> right, i thought you might mean the opposite desugaring
09:11:01 <dons> yep. the wiki page gives us an easy extensible hackage page, basically
09:11:09 <wjt> i was (wrongly) thinking that let would desugar to some do notation, which would be foolish :)
09:11:30 <dcoutts_> dons: perhaps what we want is a bug reporting url in the .cabal file, like homepage, so you can put a trac http address or an email address.
09:12:08 <dons> yeah, the project stuff elliottt is working on is like this. you can add new fields to the project pages.
09:12:40 <quicksilver> wjt: e.g. in the maybe monad
09:13:27 <dcoutts_> dons: I don't see it? I go to an arch package page but the wiki link goes to the general wiki
09:13:37 <quicksilver> wjt: "a <- return 1 ; f a" --> "Just 1 >>= \a -> f a" --> "case (Just 1) of Just x -> f x" --> f 1
09:13:54 <quicksilver> wjt: if everything is visible you might imagine all that can happen at compile time.
09:13:59 <quicksilver> Im not sure how much will in practice.
09:14:03 <wjt> hmm, right
09:14:15 <dons> yeah, under the general wiki, so, if you say, google 'arch linux firefox' , you get http://wiki.archlinux.org/index.php/Firefox
09:14:16 <lambdabot> Title: ArchWiki :: Firefox - ArchWiki
09:14:31 <dons> or 'arch linux xmonad' etc.
09:15:02 <Gilly> quicksilver: this mud is getting tricky, now i'm wondering about the way to represent the world. Problems arise when for example there would be some items in some room. If the room stores the items in it then every time an item is dropped to the room the room has to be updated (a new room has to be made) and at the same time every other room has to have its links updated to this room.
09:15:31 <dcoutts_> dons: ok, so we can do better by linking directly from individual package pages to their corresponding wiki page
09:15:32 <dons> i found this reliably useful, as an outsider coming to the platform. can't help but think this would benefit us too, if the first search for say, 'haskell rss' turned up the wiki page for the package,with advice and instructions
09:15:36 <dons> yep.
09:15:42 <dons> we can definitely integrate better
09:16:01 <dons> a standard template too, and categorisation, on the wiki
09:16:12 <dcoutts_> dons: I've got reporting half done btw, cabal-install now generates build reports but there's nowhere to send them yet
09:16:21 <dons> awesome!
09:16:26 <quicksilver> Gilly: you will want to use IDs.
09:16:27 <dons> your email address, perhaps ?:)
09:16:30 <dcoutts_> hah
09:16:42 <quicksilver> Gilly: which is in a sense a safe manual form of the pointers you would use in C++ or Java.
09:16:58 <Gilly> quicksilver: you mean every item has an ID that tells the room it's in?
09:17:10 <quicksilver> Gilly: well taking the case of rooms and room linking first.
09:17:15 <quicksilver> every room has an ID
09:17:36 <quicksilver> rooms don't directly contain their neighbours (as values fo type Room)
09:17:42 <quicksilver> for that way leads cyclicity and madness.
09:17:44 <Gilly> ahh :) yea i get it
09:17:49 <dons> dcoutts_: btw, i really like hmatrix. its very much bytestring in style. but with a seriously fast C lib underneath. there's something evilly fun about specifying -lgfortran in a .cabal file :)
09:17:55 <Gilly> and then i have a huge map ID -> room somewhere?
09:18:02 <dcoutts_> dons: heh heh
09:18:02 <quicksilver> instead, rooms just contain the IDs of their neighbours.
09:18:09 <quicksilver> Gilly: right.
09:18:24 <Gilly> yea, this fixes the problem
09:18:43 <Gilly> i'm also still wondering about your suggestion to keep lots of stuff in the client threads
09:18:59 <dcoutts_> dons: so actually the hard part about build reporting is doing anything useful with the reports
09:19:10 <Gilly> it's a bit tricky when external events (someone hits you) occur and the client (player) state would have to be altered
09:19:58 <dons> dcoutts_: so at a minimum we just have to log all relevant info to a file
09:20:00 <dcoutts_> dons: since it's multi-dimensional data and full of randomness. You need some serious stats to extract useful info like "does it work with ghc-6.8"
09:20:09 <dons> statistics is left as a later effort
09:20:15 <quicksilver> Gilly: I didn't say it was forbidden for other threads to change the state
09:20:24 <quicksilver> Gilly: that might be sane, depending on your model.
09:20:27 <dons> you think there'll be lots of noise, dcoutts_ ?
09:20:32 <quicksilver> Gilly: just wrap it in an MVar in that case.
09:20:39 <dcoutts_> dons: well ok, so getting a massive data set collected on the hackage server is not so hard, but that's not yet useful
09:20:45 <Gilly> oh, i see
09:20:50 <Gilly> up to this point i've been using only chans
09:21:40 <dcoutts_> dons: well, it's not that so much, but if a report says that foo-1.0 failed and it was using ghc-6.8, does that mean that it doesn't work with ghc-6.8 even though we have 100 other reports that it does work with ghc-6.8, or do we blame the failure on the fact that they were building on windows?
09:22:04 <dcoutts_> dons: that's the issue with it being mulit-dimensional, failure in any dimension gives us failure overall.
09:22:12 <Igloo> dcoutts_: Debian's popcon generates a random number when you install it (or it might be a hash of things like MAC addresses, not sure), and sends that with each report so that you can do some comparisons. Does your stuff do that?
09:22:29 <dcoutts_> Igloo: no
09:22:37 <Igloo> OK, I think it would be worth adding, then
09:22:39 <dcoutts_> Igloo: and that doesn't make people nervous?
09:22:46 <dcoutts_> from a privacy pov?
09:22:49 <dons> Igloo: btw, looks like popcon hasn't updated in a week or two
09:22:58 <Igloo> Because then you can understand what 5 failures of installing foo followed by a success means
09:23:07 <dcoutts_> Igloo: true true
09:23:20 <Igloo> dcoutts_: It's not really a privacy issue, I don't think
09:23:43 <Igloo> You still don't know that 4f6e is me, you just know that it's the same person that it was yesterday
09:24:49 <quicksilver> Gilly: altering player state 'asychronoously' like that can be surprising though
09:25:03 <ddarius> Gilly: Using STM may be preferable.
09:25:06 <quicksilver> Gilly: most games I'm familiar with have some notion of 'turn' or 'tick' during which things actually happen.
09:25:06 <Igloo> dons: Ta
09:26:50 <Gilly> hmm, well, basically i have these two options: 1) store each state in its own thread - this can be cool if you get it to usable state 2) store each state in the main thread and operate from there - needs to send all text from clients to the main thread
09:27:14 <Gilly> ddarius: what goodies does STM have?
09:28:10 <bd_> Gilly: Safe multithreading without locks
09:28:34 <bd_> also a really nice way to wait for an event to occur
09:28:56 <bd_> guard (any boolean expression) becomes a blocking wait :)
09:28:56 <Gilly> mm - sounds nice
09:29:15 <quicksilver> Gilly: this is a false dichotomy really
09:29:22 <quicksilver> Gilly: values don't really belong to threads.
09:29:26 <quicksilver> I mean, I have been talking as if they do
09:29:39 <quicksilver> because it often keeps you sane to assign some notion of ownership
09:29:53 <quicksilver> but in fact values are just values, accessible to all threads if you want them to be.
09:30:11 <Gilly> oh yea i know :) but the thing is that you got to keep references around
09:30:23 <dcoutts_> Igloo: so how might we do that then, perhaps first time the config is created we make a hash and store it in ~/.cabal/config
09:30:39 <dcoutts_> Igloo: so people are free to change it of course
09:31:09 <quicksilver> it's not clear to me immediately what the advantage of STM is to the kind of game system Gilly is proposing
09:31:18 <Igloo> dcoutts_: Sounds good
09:31:19 <quicksilver> it's definitely neat stuff
09:32:23 <dcoutts_> Igloo: if we do that kind of tracking we'd have to make it opt-in rather than opt-out. I'm kind of hoping we make it so obviously anonymous and tell people we're doing it that we could make it opt-out rather than opt-in.
09:32:57 <dcoutts_> Igloo: so not even tracking related bundles of reports, or ips or timestamps
09:34:11 <DRMacIver> Idle curiousity: Why isn't planet haskell listed on the "also powers" section of planet planet?
09:34:38 <dcoutts_> DRMacIver: ask ibid
09:34:51 <cjay> has anyone successfully used the HsOpenSSL library lately? My simple test program uses withOpenSSL, but it looks like is is never executed, the program behaves as if SSL_library_init is never called.
09:35:23 <dcoutts_> cjay: use ltrace, check if it is ever called
09:35:41 <DRMacIver> @message ibid Is there any particular reason planet haskell isn't listed on planet planet's "And now also powers" sidebar?
09:35:41 <lambdabot> Maybe you meant: messages messages?
09:35:45 <DRMacIver> Oops
09:35:55 <dcoutts_>  @tell $name $message
09:36:03 <dcoutts_> or @ask
09:36:19 <DRMacIver> @ask ibid Is there any particular reason planet haskell isn't listed on planet planet's "And now also powers" sidebar?
09:36:19 <lambdabot> Consider it noted.
09:36:27 <DRMacIver> Thanks. I don't use lambdabot often enough to remember its commands. :)
09:39:42 <cjay> dcoutts_: in fact, ltrace shows it is not called. I have even modified withOpenSSL to do some putStrLn, and it shows no output although withOpenSSL is called at the beginning of my main
09:40:03 <cjay> this is really weird, could it be a ghc bug?
09:40:43 <ddarius> quicksilver: STM is likely to perform better.
09:40:47 <dcoutts_> cjay: so you mean the putStrLn doesn't give you any output? are you outputting to the terminal or a file/pipe?
09:40:57 <cjay> terminal
09:41:55 <mxc> @hoogle forkIO
09:41:59 <dcoutts_> cjay: perhaps you can @hpaste an example prog that goes wrong
09:42:06 <cjay> ok
09:42:48 <quicksilver> ddarius: I think that's a meaningless observation.
09:43:12 <jjido> ghc is too lazy to put the string :)
09:43:33 <quicksilver> ddarius: stm lends itself to different algorithm expression than, say, mvars.
09:43:52 <quicksilver> ddarius: you need to compare specific algorithms which actually solve specific problems.
09:45:13 <ddarius> quicksilver: From what I've heard, just using TChans as a drop-in replacement for Chans is a plus.
09:45:17 <hpaste>  cjay pasted "HsOpenSSL problem" at http://hpaste.org/8215
09:45:36 <cjay> with an unmodified HsOpenSSL this just segfaulted
09:45:57 <sclv> stm is good for many readers few writers in particular.
09:46:02 <sclv> (or cheap writers)
09:47:01 <cjay> dcoutts_: i found out SSL_CTX_new returned a null pointer, so I inserted another check.. but let's see if someone can reproduce the segfault first
09:47:37 <frevidar> lets say I have something like "sum (map f (map g (map h [1..1000000])))" would ghc with optimisation turned on actually generate the lists?
09:47:45 <dcoutts_> cjay: sounds like you want to send patches to the HsOpenSSL maintainers
09:47:54 <frevidar> as in, allocate and deallocate nodes as they're not needed anymore?
09:48:21 <cjay> dcoutts_: if I manage to fix it and it's not my system's fault, yes
09:48:24 <frevidar> or would it treat [1..1000000] like an iterater instead?
09:48:39 <ddarius> frevidar: It will fuse the maps but not the sum, I'm pretty sure.  Check the core to be sure.
09:49:03 <frevidar> ddarius: fuse meaning?
09:49:14 <dcoutts_> cjay: even if it's your systems fault HsOpenSSL should still check if SSL_CTX_new is returning NULL and fail with an exception rather than a segfault.
09:49:34 <ddarius> frevidar: If you used the stream fusion list library everything would fuse, albeit you'd need to use an explicit enumeration function for [1..] (meaning simply a stream enumFromTo)
09:49:50 <ddarius> frevidar: It will turn map f . map g into map (f . g)
09:49:51 <cjay> dcoutts_: right, I†should inform the author
09:50:25 <cjay> after inserting the null pointer check, the program fails with:
09:50:26 <cjay> ssl-test.hs: user error (error:140A90A1:SSL routines:SSL_CTX_new:library has no ciphers)
09:50:48 <cjay> that's clearly because the init function is not called
09:50:52 <mix25> I have this: f :: Int -> [[Int]], f1 :: Int-> Int->Int->[[Int]] ; f1 1 3 1 = [[1],[2,3],[4,5,6]], how to make f ...... = [[1,2,3],[1,2,4],[1,2,5],[1,2,6],[2,3,4],[2,3,5],[2,3,6],[1,3,4],[1,3,5],[1,3,6]] ?
09:51:00 <frevidar> ddarius: would it still make [1..1000000]?
09:51:12 <cjay> i could reproduce that with a simle C program that does the same without calling the init function
09:51:27 <vixey> > sequence [[1],[2,3],[4,5,6]]
09:51:51 <ddarius> frevidar: No, but it will make a list [1..1000000] with f, g and h applied to each element and then sum that.
09:52:07 <cjay> if somewone with HsOpenSSL wants to try out, the check should be in Session.hsc, line 71, ctx <- _ssl_method >>= _ssl_ctx_new >>= failIfNull
09:52:11 <ddarius> frevidar: The stream fusion system should result in no list being generated.
09:52:24 <frevidar> ddarius: ah, ok, I see
09:52:58 <cjay> hmm.. maybe irc is the wrong place for this problem
09:53:08 <ddarius> frevidar: You should end up with sum (loop 1) where loop i | i <= 1000000 = f (g (h i)) : loop (i+1) | []
09:53:21 <dcoutts_> cjay: are you supposed to call the init yourself from your app code, or do you expect the binding to always call it first?
09:54:10 <vixey> mix25: what is that first [1,2,3] for?
09:54:28 <cjay> dcoutts_: the HsOpenSSL documentation says I should always wrap ssl stuff in withOpenSSL, and that thing cleary calls the init function
09:54:37 <mix25> doesnt matter the order
09:54:41 <dcoutts_> cjay: I see
09:55:18 <mix25> i wrote this like i can write this [1,2,4],[1,2,5]..... [4,5,6]
09:55:22 <ddarius> With stream fusion you'd end up with loop 1 0 where loop i !acc | i <= 1000000 = loop (i+1) $ acc + f (g (h i)) | otherwise = acc
09:55:24 <frevidar> ddarius: is this with http://www.cse.unsw.edu.au/~dons/streams.html?
09:55:35 <vixey> > sequence [[1],[2,3],[4,5,6]]
09:55:49 <ddarius> frevidar: Yes.
10:00:08 <Apocalisp> What's a general way of optimizing a cartesian of a list and itself, discarding the inverse products?
10:00:41 <vixey> what's an inverse product?
10:01:19 <Apocalisp> Keeping (a, b), but discarding (b, a).
10:01:36 <Apocalisp> or the other way around
10:02:12 * cjay should probaby write to haskell-cafe, irc scrolls to fast for stuff like that
10:02:40 <vixey> yeah
10:02:46 <vixey> maye like: map (zip list) (tails list)
10:02:51 <dcoutts_> anyone use haddock-2.x? does it have the --hoogle flag?
10:03:02 <vixey> zip list =<< tails list
10:03:07 <Apocalisp> ?type map (zip list) (tails list)
10:03:18 <Apocalisp> ?type map (zip []) (tails [])
10:03:22 <vixey> not that
10:03:23 <vixey> zip list =<< tails list
10:03:24 <vixey> this
10:04:16 <vixey> you know how like
10:04:29 <Apocalisp> thanks vixey, that makes sense
10:04:30 <Cale> > let pairs xs = [(x,y) | (x:ys) <- tails xs, y <- ys] in pairs [1..5]
10:04:51 <vixey> zip "foobar" "baz" ~> [('f','b'),('o','a'),('o','z')]
10:04:59 <vixey> it stops at the shortest list
10:05:29 <Cale> > let pairs xs = [(x,y) | (x:ys) <- tails xs, y <- ys] in pairs [1..5]
10:05:37 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
10:06:19 <Apocalisp> yea, list comprehension makes it easy
10:06:27 <vixey> > let prog list = zip list =<< tails list in prog [1..5]
10:06:28 <tromp> :t inits
10:06:33 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(1,2),(2,3),(3,4),(4,5),(1,3),(2,4),(3,5),(1,...
10:06:39 <lambdabot> forall a. [a] -> [[a]]
10:07:12 <tromp> > tail "hi"
10:07:17 <mm_freak> Cale's version seems to be the most efficient
10:07:21 <lambdabot>  "i"
10:07:26 <tromp> > tails "hi"
10:07:33 <lambdabot>  ["hi","i",""]
10:07:35 <vixey> mm_freak: out of ..?
10:07:55 <mm_freak> vixey: generally
10:12:11 <frevidar> ddarius: I've been reading up on these stream fusion lists
10:12:26 <frevidar> it seems as though in the worse case, they fall back to normal lists
10:12:43 <frevidar> but they can often eliminate intermediate lists
10:13:29 <frevidar> and you can use the same syntax
10:13:36 <frevidar> is there anything bad about them?
10:15:05 <Cale> frevidar: Well, they're still bad at various things which lists in general are the wrong structure for, like random access.
10:15:27 <frevidar> cale: of course
10:15:54 <frevidar> I've been using arrays for some processing
10:16:02 <frevidar> but I was thinking, I don't really need arrays
10:16:08 <frevidar> because I'm not doing random access
10:16:27 <frevidar> the most I need to do is access the previous element
10:16:40 <Apocalisp> how do you pronouce =<<
10:16:48 <vixey> dnib
10:17:06 <Apocalisp> in English
10:17:18 <vixey> (that was a joke..)
10:17:22 <Apocalisp> I know :)
10:17:39 <vixey> personally, I don't pronounce it .. I just read it as a symbol
10:17:44 <Apocalisp> If >>= is "bind", what's =<< ?
10:17:48 <opqdonut> bind
10:17:51 <Apocalisp> grr
10:17:58 <sieni> vixey: you are not the first one to call it "dnib" :-)
10:18:04 <tromp> :t (=<<)
10:18:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:18:08 <Deewiant> if f >>= x is bind f to x, x =<< f is bind f to x ;-)
10:18:10 * dolio has heard extend.
10:18:21 <Apocalisp> Actually, dnib sounds good. :)
10:18:29 <dolio> But some people refer to the comonadic equivalent of bind as extend.
10:19:18 <dolio> And the latter may be more common (as common as it can get, at least), I'm not sure.
10:19:34 <maltem> you may want the couple of "bind" and "bound (to/from)", but then which is which?
10:20:03 <sieni> also "snoc" has been used for the opposite of "cons"
10:20:54 <maltem> sieni: cons is a non-word already, so snoc is alright to accompany it
10:21:22 <vixey> I thought cons was short for construct
10:21:32 <sieni> me too
10:21:32 <maltem> I thought so, too
10:21:38 <Cale> it is.
10:38:44 <dons> ah, those were the days, http://cooking-with-lisp.blogspot.com/2005/04/haskell-and-perl-community.html
10:38:46 <lambdabot> Title: Cooking with Lisp: Haskell and the Perl Community, http://tinyurl.com/7l9xb
10:42:51 <vixey> hehe 'Autrijus: Sure. Haskell has very robust inferencing, pattern matching, and sexy types. Which I'm trying to inflict on luqui to improve Perl 6's design.'
11:00:31 <dons> ?userrs
11:00:32 <lambdabot> Maximum users seen in #haskell: 465, currently: 447 (96.1%), active: 11 (2.5%)
11:00:37 <dons> let's take over the world today!
11:00:46 * dons boings
11:00:57 <dons> new AI libraries. our first one on hackage. woot
11:01:56 <vixey> cool is it the vision stuff
11:03:05 <davidL> @seen glguy
11:03:06 <lambdabot> I saw glguy leaving #haskell 4d 23h 15m 1s ago, and .
11:03:15 <dons> he's on vacation, davidL
11:03:22 <davidL> aw
11:04:04 <davidL> well is hpaste2 running anywhere?
11:04:16 <dons> at galois, not on the interwebs, though, afaik
11:05:59 <dolio> It used to be running on glguy's laptop.
11:08:58 <chessguy> vixey:  it's Neural Network stuff
11:09:16 <davidL> if anyone has commit access to the hpaste2 git, can they change hpaste.cabal to depend on the newer cgi-3001.1.6.0?
11:10:04 <davidL> (cgi-3001.1.5.1 doesn't have getInputsFPS)
11:11:54 <mmorrow> davidL: i got hpaste2 running on my laptop. it's not that bad to get going.
11:12:13 <mmorrow> dons: love hpaste2
11:12:24 <mmorrow> (especially the highlighting)
11:12:38 <dolio> That'll come in handy when you need to share code with yourself. :)
11:12:43 <chessguy> haha
11:12:46 <mmorrow> exactly!
11:13:10 <chessguy> @remember dolio [on getting hpaste2 running locally] That'll come in handy when you need to share code with yourself
11:13:10 <lambdabot> Good to know.
11:13:21 <jamii> How do I tell the haskell build system to build profiling libraries? Im currently just using defaultMain
11:13:32 <davidL> mmorrow: using apache?
11:13:34 <mmorrow> i use it to take notes, outline topics in conference calls, save code, all kinds of stuff
11:13:40 <mmorrow> davidL: yeah apache
11:14:26 <dons> mmorrow: oh, good to know.
11:14:41 <mmorrow> davidL: there were a few slightly tricky steps (i'm running 6.9.20080504), but not *too* bad...
11:14:58 <jamii> I guess I could just stick -prof in the ghc options, but that doesnt seem very clean
11:15:38 <davidL> mmorrow: the only problem I'm having is on the lighttpd end, I hate webserver stuff
11:16:33 <mmorrow> davidL: so you've already got Takusen and hpaste2 built??
11:16:40 <davidL> mmorrow: yeah
11:16:55 <mmorrow> davidL: nice! you're in the clear
11:17:48 <mmorrow> davidL: i had to chown daemon: both the hpaste.db sqlite3 file *and* the directory it was in (if i recall) + possibly other annoyances
11:18:28 <mmorrow> davidL: did you edit Config.hs appropriately and build with your edited version?
11:19:17 <davidL> oh, hah
11:19:39 <mmorrow> and get that highlister python package + chmod 555 it
11:19:46 <mmorrow> highlighter
11:20:02 <davidL> forgot to edit Config.hs, thanks ;)
11:20:07 <mmorrow> nice
11:21:50 <davidL> mmorrow: paths are relative to hpaste.fcgi yes?
11:22:29 <IanXX> hhello guys
11:22:38 <mmorrow> what i meant by "(especially the higlighting)" was the ability to highlight (in yellow) lines by giving a line no., not syntax highlighting
11:22:57 <mmorrow> davidL: don't remember, lemme check...
11:23:39 <davidL> the syntax highlighting is neat too, using pygments, too bad there isn't a haskell version ;)
11:23:51 <vixey> I wrote a pastesite
11:24:03 <vixey> I talk to emacs to do syntax coloring
11:24:03 <Saizan_> jamii: configure with -p
11:24:12 <mmorrow> definitely, the support for pretty much every lang is *key*
11:24:34 <vixey> since emacs can syntax color anything it's pretty good
11:24:40 <davidL> vixey: interesting
11:24:44 <vixey> I only needed like 3 languages though
11:24:48 <mmorrow> davidL: yeah, relative to hpaste.fcgi
11:25:10 <davidL> alright, I'll give it another go, thanks
11:25:14 <mmorrow> vixey: hpaste2 is a webpastebin++ though
11:26:22 <vixey> but does it do unicode? :p
11:26:34 <mmorrow> i'll check
11:26:59 <vixey> (I'm sure it does, it's just really odd that hpaste 1 doesn't)
11:28:20 <mmorrow> vixey: oh yesh unicode works
11:28:44 <mmorrow> vixey: i think it's to do with the javascript syntax highlighter?
11:29:05 <Saizan_> the syntax highlight is from hscolour
11:29:16 <mmorrow> oh. then i dunno
11:30:46 <mmorrow> davidL: oh, i was looking at not-the-Config.hs-i'm-using and I'm using full paths in the one that works, so I know full paths work, not sure about rels
11:49:28 * byorgey waves
11:50:17 <vixey> hi
11:52:40 <vincenz> hey byorgey
11:54:21 <hpaste>  morrow pasted "hi.js" at http://hpaste.org/8216
11:54:33 <byorgey> hi vincenz
11:54:39 <byorgey> hi vixey
11:54:43 <vincenz> byorgey: happene to look at your tools?
11:54:53 <byorgey> vincenz: no, not yet, sorry
11:55:57 <mmorrow> Saizan_: this is what i was thinking of (pasted for no reason in partic other than that i'm trying to become proficient at js, and now it's easily referenced)
11:56:04 <mmorrow> http://hpaste.org/8216#a0
11:56:14 <mmorrow> (this is from hpaste)
11:56:22 <mmorrow> (hpaste1)
11:56:55 <vincenz> byorgey: just a quick ghc-pkg list dump would be good
11:56:59 <vincenz> byorgey: what platf?
11:57:13 <byorgey> vincenz: my ghc-pkg list is a mess =)
11:57:28 <vincenz> byorgey: ghcpkg list | gvim - "dddddd:wq"
11:57:30 <byorgey> vincenz: ubuntu
11:57:39 <vincenz> byorgey: 32 or 64bit?
11:57:42 <vincenz> byorgey: hary?
11:57:45 <vincenz> +d
11:57:45 <byorgey> 32
11:58:00 <hpaste>  morrow annotated "hi.js" with "context" at http://hpaste.org/8216#a1
11:58:08 <byorgey> actually still gutsy
11:58:22 <vincenz> hardy ships with 6.8.2
11:58:26 <byorgey> but I plan to upgrade at some point and I could do so before ICFP if there was a reason to
11:58:35 <byorgey> well, I've got 6.8.2 installed anyway
11:59:24 <vincenz> alex?
11:59:29 <vincenz> happy?
12:11:30 <vixey> Is there an emacs interaction for haskell?
12:11:48 <dons> ruby group discussing haskell this week, http://www.rubycodejam.com/?p=17
12:11:49 <lambdabot> Title: Ruby Code Jam ª Blog Archive ª Ruby Code Jam this Wednesday June 11th
12:11:51 <dons> anyone in the Charlottesville area?
12:11:51 <vixey> I guess that if I wanted to make an emacs interface to some haskell program I'd actually have to write a lot of elisp..
12:11:54 <dons> byorgey: is that near you?
12:15:39 <byorgey> dons: not particularly
12:19:10 <vixey> @quote mish
12:19:10 <lambdabot> No quotes match. Where did you learn to type?
12:19:13 <vixey> @keal
12:19:14 <lambdabot> pork steaks taste like dick
12:19:53 <vixey> @quote mash
12:19:53 <lambdabot> No quotes match. Do you think like you type?
12:19:58 <mrd> vixey: haskell-mode ?
12:22:49 <Baughn> GHC just threw a "too many specializations for one function" error. It's still building, though, so that's not fatal? Right?
12:23:35 <vixey> I meant that I want to use emacs to provide a text/gui to a haskell program, but I think I should look for another way since I don't want to write more elisp
12:23:39 <conal> Baughn: wow -- i wonder why there's a limit.  what are you doing that you'd push the limit?
12:23:47 <Baughn> conal: Compiling GHC
12:23:53 <conal> oh
12:23:54 <Baughn> Specifically, Bytestring-lazy
12:24:35 <Baughn> There's also an option to set the limit, apparently. I suppose they're afraid to build an executable consisting solely of specializations of head, or something
12:26:28 <vincenz> dons: did ou see the webblog dissing on haskell speed?
12:26:36 <vincenz> a whole bunch of FUD
12:26:58 <Baughn> vincenz: Which one?
12:27:06 <vincenz> one posted on proggit today
12:30:32 <sjanssen> vincenz: link?
12:30:38 <vincenz> sjanssen: trying to locate it
12:32:54 <conal> vincenz: hey -- pretty new blog.  i just left you a comment on infinite arrays.
12:33:09 <vincenz> conal: thanks :)
12:34:14 * vincenz doesn't seem to be able to find it
12:35:40 <sclv> so anyone here have much experience with the various xml libs? any general thoughts -- pros, cons?
12:36:20 <sclv> The specific project involves reading a rather ugly large set of interrelated dtds and then processing the resultant structure into something slimmer and nicer to be navigated through.
12:36:52 <Baughn> @hoogle Int -> Bool
12:36:53 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
12:36:54 <lambdabot> Data.IntSet.notMember :: Int -> IntSet -> Bool
12:36:59 <vincenz> sjanssen: can't' seem to locate it at the moment, sadly I was looking at it with another computer..
12:37:03 <Baughn> @hoogle Integral a => a -> Bool
12:37:04 <lambdabot> Prelude.even :: Integral a => a -> Bool
12:37:04 <lambdabot> Prelude.odd :: Integral a => a -> Bool
12:37:04 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
12:37:36 <sclv> > toEnum 0 :: Bool
12:37:37 <lambdabot>  False
12:43:49 <Apocalisp> what was that lambdabot command that identified sequences?
12:44:11 <byorgey> @oeis 1,2,5,14
12:44:11 <vixey> > describeSequence [1,1]
12:44:11 <lambdabot> Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called ...
12:44:11 <lambdabot> [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
12:44:13 <lambdabot>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
12:44:46 <Apocalisp> cool!
12:46:42 <ziman> > extendSequence [1, 1]
12:46:44 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:47:14 <vixey> > last . extendSequence $ [2,3,5,7]
12:47:15 <lambdabot>  271
12:47:24 <ziman> wow
12:47:29 <vixey> > describeSequence $ [2,3,5,7]
12:47:31 <lambdabot>  Just "The prime numbers."
12:47:58 <xerox> Ah.. the last prime number.
12:48:02 <ziman> length . extendSequence $ [2, 3, 5, 7]
12:48:08 <vixey> :p
12:48:30 <ziman> @hello
12:48:31 <lambdabot> Maybe you meant: help tell
12:48:38 <vixey> @unhello
12:48:39 <lambdabot> Unknown command, try @list
12:48:52 <ziman> @ping
12:48:53 <lambdabot> pong
12:49:03 <vixey> @keal
12:49:04 <lambdabot> bot defective
12:49:07 <vixey> @keal
12:49:07 <lambdabot> #haskell needs to take its meds
12:49:22 <byorgey> xerox: hehe, it only has as much data as is on OEIS.
12:49:48 <byorgey> having it actually query OEIS for an *algorithm* for generating infinite lists is planned for version 37.6. ;)
12:50:03 <xerox> ...and what version is ours? (-:
12:53:18 <Heffalump> why doesn't OEIS have algorithms?
12:53:36 <Japsu> it does
13:00:48 <slavik> how can I access specific elements in a list?
13:00:55 <slavik> is that not possible?
13:01:41 <tibbe> are there any less expensive alternatives to lambda lifting for compiling a strict functional language? iIt's O(n^3) and I have an application where I want to optimize for short "compile" times (in a bytecode interpreter)
13:01:47 <tibbe> I read some papers on lambda lifiting
13:02:06 <Riastradh> For what purpose do you want to lambda-lift?
13:02:34 <tibbe> eliminate local function definitions
13:02:58 <Botje> tibbe: I saw a paper that promised a quadratic-time lambda lift
13:02:59 <tibbe> I don't know how applicative LL is to my case though since I don't run on a STG machine
13:03:14 <Heffalump> you need lambda-lifting for speed, or to implement closures?
13:03:15 <tibbe> Botje: the paper I read said O(n^2) set operations
13:03:16 <Vulpyne> slarba: Use !! to index elements of a list.
13:03:21 <Vulpyne> Er, slavik that is.
13:03:23 <tibbe> Heffalump: implement closures
13:03:39 <slavik> ahh
13:03:41 <slavik> right
13:03:45 <Vulpyne> slavik: But lists are not random access structures.
13:03:51 <Riastradh> tibbe, do you need to lambda-lift, or would it suffice just to use vanilla nested lexical environments?
13:03:54 <Heffalump> is it really O(n^3) in practice?
13:03:57 <Vulpyne> So it will have to traverse the list up to the element you want.
13:03:59 <Heffalump> and yes, what Riastradh said
13:04:03 <slavik> I see
13:04:04 <tibbe> Heffalump: no
13:04:11 <Vulpyne> May want to use an array or something if you are doing a lot of random access.
13:04:12 <tibbe> Heffalump: but I want to do one pass
13:04:13 <slavik> I only need to access the 1st and second items
13:04:31 <Heffalump> how about defunctionalisation?
13:04:43 <Japsu> slavik: use pattern matching
13:04:45 <ziman> > extendSequence [1, 6, 21, 107]
13:04:47 <lambdabot>  [1,6,21,107]
13:04:54 <tibbe> Riastradh: nested lexical environments might work, I'm writing my interpreter in C (for fun mainly) so if you have any good examples of where it has been done it would be greatly appreciated
13:04:59 <Japsu> foo (x:y:_) = nowDoSomethingWith x y
13:05:03 <slavik> x:xs?
13:05:06 * Heffalump has no real experience of implementing functional languages so is just guessing
13:05:06 <slavik> ahh
13:05:14 <Japsu> slavik: yes, you can chain (:) in patterns
13:05:37 <slavik> I am trying to figure out the best way to do memoization ...
13:05:55 <tibbe> is there a big overlap between implementing strict and lazy functional languages? I only find examples of lazy ones
13:09:01 <jamii> Saizan: Missed that reply. Cheers anyway
13:12:57 <Heffalump> 'lo
13:14:37 <byorgey> hi Heffalump
13:24:44 <Heffalump> byorgey++ # HWN
13:27:48 <dons> vincenz: no? doesn't seem to be on reddit?
13:34:18 <roconnor> Ha, the Coq developers knew they Coq didn't have subject-reduction for the last 15 years.
13:35:17 <vixey> ?users
13:35:17 <lambdabot> Maximum users seen in #haskell: 465, currently: 451 (97.0%), active: 9 (2.0%)
13:36:00 <vixey> @users
13:36:01 <lambdabot> Maximum users seen in #haskell: 465, currently: 451 (97.0%), active: 7 (1.6%)
13:36:04 <vixey> :(
13:38:11 <roconnor> @losers
13:38:12 <lambdabot> Maximum users seen in #haskell: 465, currently: 451 (97.0%), active: 6 (1.3%)
13:38:58 <slavik> :(
13:39:00 <slavik> @losers
13:39:00 <lambdabot> Maximum users seen in #haskell: 465, currently: 451 (97.0%), active: 7 (1.6%)
13:39:04 <slavik> there :)
13:39:16 <ohub> me too
13:39:25 <ohub> lurking in background ;)
13:40:03 <quark> i can say something, if that helps bring the active number up :)
13:43:07 <dolio> @losers
13:43:07 <lambdabot> Maximum users seen in #haskell: 465, currently: 451 (97.0%), active: 10 (2.2%)
13:43:27 <vixey> lol
13:43:42 <vixey> grr
13:43:45 <vixey> I want 500
13:45:20 <Riastradh> Why not 512?
13:45:48 <dolio> vixey is part of the conspiracy to short change you on hard drive capacity.
13:50:30 <dmwit> 500 active users is a long way off.  But hey, if you dream, why not dream big?  512 seems good.
13:50:43 <shachaf> vixey: So you're the one behind it!
13:54:33 <dons> well, we've made 480, but seem to have plateaued of late
13:55:36 <vixey> IRC is really quiet today though
13:55:41 <sclv> summer -- less students
13:55:44 <vixey>  or maybe I am imagining it?
13:56:23 <Spark> fewer students
13:56:24 <roconnor> I also feel haskell research has slowed
13:56:43 <chr1s> vixey: maybe it's the european championships (soccer) ;)
13:56:43 <vixey> oh I got a really tricky binding problem
13:56:45 <roconnor> news is no longer weekly :)
13:56:55 <vixey> chr1s: ah I had no idea, I don't follow sport
13:57:43 <chr1s> dons: I had some trouble compiling pcre-light, I had to include "include-dirs" and "lib-dirs" in the cabal file
13:57:54 <chr1s> it's probably more of a cabal-issue though.
13:57:56 <dons> oh, your pcre.h is somewhere funky?
13:58:00 <dons> or an old cabal ?
13:58:10 <chr1s> 1.3.3
13:58:24 <chr1s> but those libraries are in my fink-dir (I'm on a Mac)
13:58:36 <dons> yeah, ./configure mightn't find them
13:59:05 <dons> try setting CPPFLAGS and LDFLAGS in the environment
13:59:06 <chr1s> exactly. would there have been another way to fix it?
13:59:09 <chr1s> ah
13:59:14 <chr1s> ok, I'll delve into that
14:01:56 <chr1s> dons: also, I get a message like ""/tmp/ghc-core-XXXX35959.hcr" may be a binary file.  See it anyway?" when using ghc-core.
14:02:21 <chr1s> Of course it works fine if you press yes (thanks for that), but I was wondering if we could find a way to get rid of the warning.
14:02:22 <dons> ah yes. i want to fix that now.
14:02:33 <dons> pass -f to less
14:03:07 <chr1s> I still get the message
14:03:27 <dons> did you modify ghc-core.hs to pass -f to less already?
14:03:46 <dons> if i set: PAGER="less -f"
14:03:48 <dons> then ti works
14:03:48 <chr1s> no, I only did ghc-core Test.hs | less -f
14:04:17 <chr1s> nice!
14:04:27 <chr1s> that works perfectly!
14:04:29 <sjanssen> dons: the configure script isn't marked as executable in the pcre-light tarball
14:04:34 <dons> sjanssen: ah!
14:04:49 <chr1s> sjanssen: yes, I forgot to mention that, thanks!
14:05:44 <dons> ok. i'll fix that, and detect 'less' and pass -f to it.
14:06:17 * olsner explodes his brain... http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
14:06:18 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
14:06:31 <dcoutts> chr1s, dons: the latest cabal supports the configure flags --extra-include-dirs  --extra-lib-dirs for exactly this purpose
14:06:39 <roconnor> olsner: :)
14:06:51 <dcoutts> chr1s, dons: for when C libs are installed in non-standard locations
14:07:00 <chr1s> dons: and maybe update the webpage to something like "if you have trouble compiling when you are sure the right libs are there, use these flags"
14:07:02 <dons> dcoutts: cool.
14:07:07 <chr1s> dcoutts: that's great!
14:07:18 <roconnor> olsner: you need to read chapter 9 of Real World #haskell
14:07:19 <dons> dcoutts: i've been using CPPFLAGS and LDFLAGS to set this stuff in buildinfo files
14:07:53 <olsner> the one about *morphisms being scary names for everyday functions?
14:07:55 <thetallguy> ?seen igloo
14:07:56 <lambdabot> igloo is in #darcs, #ghc and #haskell. I don't know when igloo last spoke.
14:08:06 <dcoutts> dons: the other thing we want to do is allow per-package config in ~/.cabal/config so people can put things like those extra lib & include dirs in there
14:08:14 <roconnor> olsner: Chapter 9. What To Do When People Are Talking About  Zygohistomorphic Prepromorphisms  And You Are All Like WTF!?
14:08:23 <roconnor> @wiki Real World
14:08:23 <lambdabot> http://www.haskell.org/haskellwiki/Real_World
14:08:41 <dcoutts> dons: you mean using a configure script to stash those env vars into .buildinfo files?
14:08:56 <olsner> roconnor: lol
14:09:03 <vixey> ?where Real World
14:09:04 <lambdabot> I know nothing about real.
14:10:25 <dons> dcoutts: yeah CPPFLAGS and LDFLAGS are pretty standard
14:10:28 <mmorrow> ?where everything
14:10:28 <lambdabot> I know nothing about everything.
14:10:41 <dons> so i just use a configure script which takes them, and puts them in the buildinfo file
14:11:09 <dcoutts> dons: right, there was a reason we don't look at CPPFLAGS and LDFLAGS but I don't now recall
14:11:27 <dons> mm
14:13:18 <roconnor> @ask edwardk should there be a functor constraint or something for f in the zygohistomorphic_prepromorphism?
14:13:18 <lambdabot> Consider it noted.
14:14:33 <mmorrow> oh the analogies: http://covector.blogspot.com/2005/08/hola.html
14:14:33 <lambdabot> Title: vanishing points: strange loop
14:31:22 <gwern> neat, I can remove the oeis functionality from lambdabot because byorgey put it on hackage
14:31:28 <gwern> good
14:32:06 <gwern> @seen Cale
14:32:07 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
14:33:53 <smg> hello.
14:33:55 <sjanssen> gwern: hmm, didn't I already do that?
14:33:59 <shapr> hi
14:33:59 <dmwit> Hiya, smg!
14:34:07 <sjanssen> gwern: or maybe I didn't finish
14:34:07 <smg> i have a stupid quesiton
14:34:17 <dmwit> No worries, I have a stupid answer.
14:34:36 <gwern> sjanssen: in the darcs repo, oeis is still determinedly there. maybe you're thinking of ft?
14:34:37 <sjanssen> gwern: ah yes, lambdabot has a few extra functions that aren't in the upsteram oeis
14:34:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8217
14:34:51 <sjanssen> gwern: I was doing it, but then I hit that snag
14:34:58 <gwern> sjanssen: yes, but it looks like only one is actually used
14:35:01 <smg> http://hpaste.org/8217
14:35:01 <dcoutts> g'evening JaffaCake
14:35:07 <smg> what are the FREE variables in that paste?
14:35:09 <smg> it is c,g,u ?
14:35:15 <smg> dmwit: maybe you can answer .)
14:35:18 <gwern> searchSequence_IO, specifically
14:35:27 * gwern is being lazy and copying that into Plugins/OEIS.hs for now
14:35:31 <dmwit> smg: That isn't meant to be a well-formed Haskell program, then?
14:35:35 <vixey> smg: don't know how to figure it out...?
14:35:41 <smg> vixey: i do
14:35:46 <smg> but a friend is confusing me
14:35:49 <vixey> ignore them
14:35:54 <smg> my calculation returns c,g,u is free
14:36:26 <dmwit> Your calculation sounds correct.
14:36:27 <vixey> smg: Your calculation is correct
14:36:35 <vixey> as it has been for the last week ..
14:36:37 <dmwit> 20 is also unbound. ;-)
14:36:55 <smg> vixey: hehe
14:37:19 <smg> yeah people are confusing me
14:37:28 <smg> i don't know i should trust my calculations
14:37:39 <gwern> still, some of lambdabot is weird
14:37:40 <vixey> you should
14:37:47 <gwern> for example, why is its state gzipped?
14:38:07 <gwern> what is the point of gzipping the 'fact' file when it only has like 100 lines?
14:38:20 <dmwit> To save space!
14:38:25 <opqdonut> :D
14:38:39 <opqdonut> brought to you by the department of obviosity
14:38:50 <dmwit> And hey, it might even be faster to gunzip a small file than to spend all that disk-read time to read the uncompressed version... ;-)
14:38:52 <dons> gwern: in general, the bot gzips state files
14:38:55 <Saizan_> gwern: most of lambdabot is how it is "because we can" afaiu
14:39:00 <gwern> -_- yes because every kilobyte counts
14:39:06 <gwern> (every sperm is sacred...)
14:39:14 <smg> vixey: thank you
14:39:54 <gwern> dons: but what's the point? even the largest, the quotes and haddocks, wouldn't be too hurt by a normal text file format, and they'd be easier to edit and maintain
14:40:16 <sjanssen> gwern: I tend to agree
14:40:19 <dons> it was noticeably faster to load, and led to a smaller footprint
14:40:32 <sjanssen> I think dons wanted to play with the new zlib/ByteString toys :)
14:40:33 <dons> as rarely used modules, like vixen, would only be uncompressed, lazily, on demand
14:40:49 <dons> i was playing with reducing memory consumption, many moons ago, yes.
14:40:59 <gwern> dons: was this pre-bytestring?
14:41:01 <dons> but the bots a leviathan now. it needs rewriting from scratch
14:41:11 * dmwit is playing with writing a new bot
14:41:25 <dons> i'm uninterested in further adding to it, and it only seems to be getting more unstable
14:41:46 <gwern> dmwit: what a coincidence. I've been editing lambdabot in preparation for writing my own...
14:41:49 <dons> time for a bright young spark to write a new better bot, stealing all the good ideas from the lambdabot experiement
14:41:53 <vixey> yes rewrite!
14:41:59 <dons> where's our new young turks, to take over the  world!!?
14:42:03 <sjanssen> what about mauke's preflex?
14:42:08 * dmwit is also in the middle of finals week + moving across the country
14:42:08 <dons> yeah, go mauke!
14:42:16 <dmwit> mauke++
14:42:18 <sjanssen> mauke: would preflex be a good host for all of lambdabot's plugins?
14:42:21 <opqdonut> :)
14:42:25 <gwern> (since obviously the more functionality is split out to libraries on hackage, the easier it is)
14:42:27 <dmwit> gwern: We should all have a competition. =)
14:42:28 <dons> just needs the top 10 or so, sjanssen
14:42:33 <dons> and do rss for everything else
14:42:35 <sjanssen> really, lambdabot's plugins are the only things that matter
14:42:37 <dons> a lot of lambdabot is waste now
14:42:41 <sjanssen> rss?
14:42:46 <gwern> what is mauke preflex?
14:42:52 <dmwit> preflex: seen gwern
14:42:52 <preflex>  gwern was last seen on #haskell 6 seconds ago, saying: what is mauke preflex?
14:42:53 <sjanssen> preflex: seen gwern
14:42:53 <preflex>  gwern was last seen on #haskell 7 seconds ago, saying: what is mauke preflex?
14:42:55 <vixey> preflex: calc 999999999999999+1
14:42:56 <preflex>  1000000000000000
14:43:01 <dons> many of the plugins could be replaced with a generic rss subscriptionn/ event poll plugin
14:43:02 <sjanssen> preflex: source
14:43:23 <gwern> hm. so preflex is an independent irc bot, not another installation of lambdabot?
14:43:29 <sjanssen> gwern: yeah
14:43:31 <dmwit> dons: Like which ones?  ?ask/?tell, or are you thinking of something else?
14:43:35 <sjanssen> preflex: help
14:43:35 <preflex>  try 'help help' or see 'list' for available commands
14:43:38 <sjanssen> preflex: list
14:43:38 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma]; Nickometer: [nickometer]; Seen: [seen]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]
14:43:43 <sjanssen> preflex: version
14:43:43 <preflex>  9.628
14:43:45 <gwern> (also, on a side note, I was amazed to see how long the quotes file is in lambdabot. very entertaining but occasionally redundant reading)
14:44:07 <dons> also, just use bytestrings for everything, and stm for the thread model
14:44:19 <dons> and do checkpointed state, a la happs
14:44:27 <dmwit> yeah
14:44:34 <sjanssen> @ask mauke what is the URL for preflex?
14:44:34 <lambdabot> Consider it noted.
14:44:48 <dmwit> preflex: version
14:44:48 <preflex>  0.309
14:44:54 <dmwit> Uh, what?
14:45:00 <dmwit> preflex: version
14:45:00 <preflex>  3.760
14:45:03 <dcoutts> dons: or do it with happs :-)
14:45:04 <dmwit> indeed...
14:45:05 <sjanssen> obviously a joke
14:45:07 * dcoutts runs away
14:45:24 <sjanssen> dcoutts: have you tried to build HAppS lately?  The thing is a behemoth
14:45:25 <dons> we could reuse the macid layer of happs
14:45:29 <dons> its probably in its own library
14:45:32 <dcoutts> sjanssen: the one on hackage works
14:45:37 * vixey has tried to build happs lots of times :/
14:45:40 <sclv> or just sqlite
14:45:41 <vixey> never managed
14:45:45 <dons> and seems to be pretty solid -- hpaste.org goes down less often than lambdabot, by a wide wide margin
14:45:46 <dcoutts> dons: yes, happs-data I think
14:45:56 <sjanssen> dcoutts: sure, it will build, but it is still a behemoth :)
14:46:03 <gwern> I'm not sure preflex has an url; googling isn't turning out anything but #haskell
14:46:12 <sjanssen> dons: hpaste is also much simpler
14:46:23 <dons> at least it stays on the network :)
14:46:25 <dcoutts> sjanssen: it's not monolithic though, you can get a simple instance without waiting too long
14:46:34 <dons> but yes, the complexity is much of the problem
14:46:46 <dons> and rot, due to reimplementing on our own libraries that now exist separately
14:46:50 <sjanssen> gwern: mauke showed me a darcs repo once, can't find it anymore
14:47:13 <dcoutts> dons: isn't half the problem that memory use grows too much, Cale restarted lambdabot earlier when it was at ~170Mb
14:47:14 <dons> chr1s: uploaded ghc-core 0.3
14:47:23 <dons> yeah, there's  a leak in the inner loop
14:47:31 <dons> something to do with IORefs i don't care about
14:47:41 <dons> shows up in busy channels
14:47:44 <dcoutts> and it had a half dozen runplugs instances hanging around taking up ~17Mb each (not counting all other other defunct runplugs instances)
14:47:53 <dons> oh, zombies are bad. that shouldn't happen
14:48:02 <dcoutts> worse than zombies
14:48:03 <sjanssen> does lambdabot still support dynamic reloading?
14:48:04 <dons> its a ball of stickytape, wire and glue
14:48:21 <dmwit> Is dynamic reloading actually useful?
14:48:22 <dcoutts> zombies take no memory, only a process table slot
14:48:22 <dons> sjanssen: yeah, would be pretty much unchanged
14:48:28 <dons> but with stable plugins, it hardly matters now
14:48:35 <dons> it used to matter when we had 50 patches a day landing
14:48:40 <dons> and no state saving
14:48:43 <sjanssen> dons: I wasn't sure if that had bitrotted
14:48:44 <dcoutts> and the code.h.o machine only has ~500Mb ram so lambdabot leaks get noticed early
14:48:57 <dons> but if you can serialise state, dynamic loading isn't needed we know now.
14:48:58 <sjanssen> it might be nice to try xmonad style dynamic reloading with lambdabot
14:48:58 * dmwit blinks
14:49:08 <dmwit> It's amazing that 512MB RAM is small these days.
14:49:09 <dons> sjanssen: yeah. that's how i'd do it now
14:49:29 <ddarius> dmwit: Indeed ...
14:49:35 <dcoutts> dmwit: it's a cheap virtual host, that much is just fine for file serving + darcs, but not for lambdabot :-)
14:49:48 <gwern> dmwit: tell me about it. I recently started using my 512mb laptop with ubuntu hardy, and it's painful
14:49:54 <dmwit> =(
14:49:57 <sjanssen> dcoutts: 512 MB is occasionally not enough for darcs :(
14:50:04 <dons> there's really no need for lambdabot to be so crappy
14:50:05 <dmwit> I've been using my 512MB laptop just fine for four years...
14:50:10 <sjanssen> but probably not for the cases we see on code.h.o
14:50:18 <dcoutts> sjanssen: right
14:51:01 <vixey> any ideas for now lambdabot plugins?
14:51:13 <dcoutts> @seen Lemmih
14:51:13 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
14:51:33 <davidL> vixey: is there one that announces darcs patches?
14:51:40 * ddarius wonders if suspending and/or hibernating his laptop compacts the memory
14:52:02 <dmwit> davidL: No, but to which project would you want that?
14:52:06 <Lemmih> dcoutts: Yo.
14:52:13 <dmwit> davidL: (i.e. which project should it announce patches for?)
14:52:15 <ddarius> davidL: lambdabot was used in #perl6 to announce patches
14:52:21 <vixey> oh like hackage addition
14:52:26 <davidL> dmwit: might be neat for certain projects, maybe xmonad?
14:52:28 <vixey> kind of like the cpan thing in #perl
14:52:47 <gwern> sjanssen: you were right. I actually had to move over 19 types or functions from Lib/OEIS to Plugin/
14:53:20 <ddarius> (Or maybe something else announced it and lambdabot just read those announcements...)
14:53:23 <sjanssen> gwern: so how about we don't do that
14:53:29 <davidL> vixey: better yet, a @restart command or similar that rebuilds and rejoins lambdabot, like xmonad mod-q
14:54:06 * dmwit is considering some novel administrator rights policies
14:54:07 <ddarius> davidL: lambdabot at one point had support for dynamically (re)loading plugins.
14:54:25 <sjanssen> gwern: IMO, it doesn't do any good to merely transplant code from Lib/OEIS to Plugin/ -- sending patches upstream is much better
14:54:27 <gwern> sjanssen: well, I'm going to move it other but surround it on comments. then I can remove the main Lib/oeis thing. after that, I'll edit byorgey's oeis hackage release (since there is no darcs repo?) and then when he re-uploads, we can clean up Plugins/
14:54:32 <davidL> ddarius: it doesn't work any more?
14:54:43 <sjanssen> gwern: what is the advantage to doing that?
14:54:47 <dmwit> davidL: Sure it does.
14:54:47 <ddarius> davidL: I'm not sure what's up with it.
14:54:58 <dmwit> davidL: Or at least, dons was just saying that it was.
14:55:06 <gwern> sjanssen: it satisfies my impatience, it gets the ball rolling
14:55:16 <sjanssen> gwern: also, DON'T MAKE HACKAGE RELEASES THAT DON'T EXIST IN SOURCE CONTROL
14:55:19 <sjanssen> seriously.
14:55:35 <gwern> if you wait on other people in OSS, nothing will get done
14:55:38 <gwern> sjanssen: I never said I would upload it
14:55:48 <sjanssen> gwern: oh, that is not so bad then :)
14:55:52 <gwern> sjanssen: if byorgey doesn't have a public oeis, what can I do but send him diffs of the hackage package?
14:55:55 <davidL> dmwit: how's it work?
14:56:15 <sjanssen> gwern: sorry, forget my yelling
14:56:29 <gwern> I can hardly say "hey, byorgey, why don't you take the stuff in Plugins and add it to oeis? obviously I won't pay you, and I'll nag you until you do it"
14:56:37 <sjanssen> gwern: http://code.haskell.org/oeis/
14:56:38 <lambdabot> Title: Index of /oeis
14:56:56 <dmwit> davidL: Dunno, but I guess its operation is restricted to the person who's administrating \bot.
14:56:58 <gwern> oh. great
14:57:14 * gwern resolves the first edit will add in the darcs repo location :)
14:58:00 * gwern goes to have dinner first, tho
14:58:26 <davidL> dmwit: neat, I'll look into it
15:02:02 <chr1s> dons: great, thanks.
15:02:07 <dcoutts> Lemmih: hia, I've been looking into using happs for a hackage-server rewrite prototype
15:02:11 <hpaste>  therp pasted "early fail with f10exp 4?" at http://hpaste.org/8218
15:02:45 <dcoutts> Lemmih: and I'd like to talk to you a bit about architecture and just some simple stuff about where I should start etc
15:02:47 <therp> does someone have a hint why this program fails so early with f10exp 4? stack overflow. but I don't see what could be the cause
15:02:54 <therp> (see hpaste)
15:04:19 <ziman> therp, foldr is lazy and non-tail-recursive; in this case, foldl' should do the work
15:05:30 <ziman> > foldr (+) 1 [1..1000000]
15:05:32 <lambdabot>  Exception: stack overflow
15:05:36 <ziman> > foldl' (+) 1 [1..1000000]
15:05:38 <lambdabot>  500000500001
15:05:49 <ziman> foldl' is in Data.List
15:05:51 <therp> hmm thanks
15:05:56 <therp> ziman: thanks works :)
15:06:00 <ziman> yw ;)
15:06:39 <dcoutts> Lemmih: perhaps I can quiz you :-) -> #haskell-overflow
15:06:48 <Lemmih> dcoutts: Excellent. Let's talk tomorrow. I'm about to go unconscious for a couple of hours.
15:06:55 <dcoutts> Lemmih: ok, cool
15:07:18 * shapr waves at Lemmih
15:07:40 <Lemmih> shapr: Hiya.
15:08:53 <davidL> why does the ghc linker use so much memory?
15:09:34 <monochrom> perhaps ghc uses so much memory anyway.
15:11:06 <davidL> ghc takes up all the swap when it links an HAppS app on my 256slice (256MB memory)
15:13:07 <dons> davidL: the gnu linker, you mean?
15:13:13 <dons> likely due to split objs
15:14:54 <dcoutts> davidL: what version of gnu bunitils?
15:15:31 <dcoutts> bunitils/binutils
15:15:55 <dons> what are these bunutils you speak of?
15:16:01 <dons> strawberry jam and cream?
15:16:07 <davidL> GNU ld version 2.17 Debian GNU/Linux
15:16:18 <solrize> @seen cdsmithus
15:16:18 <lambdabot> I saw cdsmithus leaving #haskell 5d 4h 19m 38s ago, and .
15:16:27 <dcoutts> davidL: hmm, that should have the ld optimisation that makes it not need so much memory
15:16:31 <ivanm> dons: no, it's the knife, spoon and plate that lets you put strawberry jam and cream on the buns!
15:16:53 <dcoutts> davidL: mind you perhaps that just means it doesn't take >500mb any more :-)
15:17:24 <davidL> dcoutts: maybe, I'll try it in a VM with 512 MB
15:17:52 <dcoutts> davidL: and build without split-objs if you were previously doing so
15:18:29 <davidL> thanks
15:30:23 <therp> > (mod 162495 10^2, mod 162495 100)
15:30:25 <lambdabot>  (25,95)
15:30:26 <therp> erm huch?
15:30:35 <therp> > 10^2
15:30:36 <lambdabot>  100
15:30:49 <therp> oh, it's the precedence.. sorry
15:34:01 <gwern> man, this business of debian/ubuntu of providing separate package package-prof package-doc is stupid
15:34:27 <shapr> Did you talk to the maintainer?
15:35:09 <gwern> what would I say? "This tri-part package business is stupid. They're all stupid. You're stupid! I'm gonna go start my own distro, with blackjack and hookers..."
15:36:00 <shapr> um
15:36:17 <shapr> Perhaps ask the reasoning behind the decision to split the packages?
15:37:33 <opqdonut> well the rationale is that only developers will need -dev and -prof
15:37:53 <opqdonut> and not everyone wants -doc of all their packages, and the documentation can be quite large
15:38:46 <dmwit> Yeah, I don't think the split is ridiculous.
15:39:11 <opqdonut> well -dev and -prof could really be bundled together
15:39:14 <sjanssen> it would be nicer if one could set a configuration flag to automatically install those -dev -prof and -doc packages
15:39:16 <opqdonut> possibly with -dbg too
15:40:10 <dolio> There aren't many haskell packages that get installed for user-level stuff, from what I can see.
15:40:39 <sjanssen> dolio: this is because GHC statically links libraries
15:40:48 <dolio> Right.
15:41:53 <dolio> Haskell libraries seem to be the only ones with separate -prof packages, too.
15:44:25 <gwern> @oeis foo
15:44:25 <lambdabot> Number of simple gatomorphisms of type B.
15:44:25 <lambdabot> [0,1,0,3,1,0,2,2,1,0,7,3,3,1,0,8,4,2,3,1,0,6,6,8,2,3,1,0,4,5,7,7,2,3,1,0,5,7,...
15:44:42 <ddarius> *blink* *blink*
15:44:43 <vixey> ... ?
15:44:49 <opqdonut> :D
15:44:56 <vixey> @oies bar
15:44:57 <lambdabot> Number of "lit bars" needed to represent the number 'n' in a digital readout ...
15:44:57 <lambdabot> [6,2,5,5,4,5,5,3,7,5,8,4,7,7,6,7,7,5,9,7,11,7,10,10,9,10,10,8,12,10,11,7,10,1...
15:44:58 <hukolele> how can I cast from Int to Floating?
15:45:00 <gwern> @oeis bar
15:45:00 <lambdabot> Number of "lit bars" needed to represent the number 'n' in a digital readout ...
15:45:00 <lambdabot> [6,2,5,5,4,5,5,3,7,5,8,4,7,7,6,7,7,5,9,7,11,7,10,10,9,10,10,8,12,10,11,7,10,1...
15:45:14 <gwern> @oeis quux
15:45:14 <vixey> hukolele: there is no cast, but fromIntegral converts
15:45:14 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
15:45:23 <dons> Cale, here's one for you. explain why the type system makes refactoring mechanical, http://lucinda-b.livejournal.com/204011.html?mode=reply
15:45:24 <lambdabot> Title: Post Comment
15:45:30 <dons> Cale, here's one for you. explain why the type system makes refactoring mechanical, http://lucinda-b.livejournal.com/204011.html i mean
15:45:30 <lambdabot> Title: lucinda_b: Interesting evening. Managed to fix lots
15:45:37 <hukolele> > fromIntegral (1::Int)
15:45:52 <lambdabot>  thread killed
15:46:17 <dmwit> vixey: It is not, strictly speaking, true that there is no cast from Floating to Int (or vice versa).
15:46:32 <sjanssen> unsafeCoerce#!
15:46:34 <dmwit> vixey: Should you ever need such a thing, the incantation will be revealed to you at the proper time. ;-)
15:46:41 <dmwit> sjanssen: Aw, man, you ruined it!
15:46:50 <dmwit> =P
15:46:53 <vixey> I don't think unsafeCoerce will work
15:47:53 <ddarius> It will work for some value of "work"
15:49:04 <dcoutts> dons: ah but he's not doing refactoring by hand, he's writing a refactorer so yeah he does need to grok the whole language design
15:49:26 <dcoutts> and at the surface syntax level not just something simple like core
15:50:37 <dons> oh, i see. so sure, the syntax is more complex than erlang.
15:50:48 <dons> not the monads or partial applications, just the number of syntactic forms
15:51:19 <gwern> @tell byorgey I'm sending you patches for oeis; I'd appreciate it if you could apply them soon; even better would be uploading another oeis release, so lambdabot can scrap most of the redundant oeis code
15:51:20 <lambdabot> Consider it noted.
15:51:42 <dcoutts> dons: right
15:51:45 <thetallguy> Is there a nice one liner implementing partitionM?
15:52:01 <hukolele> how can I cast back from Floating to Int??
15:52:13 <thetallguy> or grouM
15:52:16 <thetallguy> groupM
15:52:22 <vixey> :t realToFrac :: Double -> Int
15:52:23 <dcoutts> hukolele: round or ceil or floor
15:52:23 <ddarius> @src Floating
15:52:23 <lambdabot> class  (Fractional a) => Floating a  where
15:52:23 <lambdabot>     pi                                                      :: a
15:52:23 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:52:23 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:52:23 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:52:25 <lambdabot>     No instance for (Fractional Int)
15:52:27 <lambdabot>       arising from a use of `realToFrac' at <interactive>:1:0-9
15:52:29 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
15:52:30 <ddarius> @src RealFrac
15:52:31 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
15:52:33 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
15:52:35 <dmwit> thetallguy: Not really, no.
15:52:36 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
15:52:38 <ddarius> There we go
15:53:14 <thetallguy> dmwit: good, cause I didn't come up with one
15:53:19 <thetallguy> dmwit: thanks.
15:53:20 <dmwit> thetallguy: There are always ugly one-liners. ;-)
15:53:47 <thetallguy> dmwit: yeah, trying to avoid those flip flip . permutations
15:54:12 <dmwit> ?pl \a b c d -> f c d b a
15:54:13 <lambdabot> flip (flip . (flip .) . flip (flip . f))
15:54:18 <thetallguy> dmwit: just wondering if I'd missed something with liftMx or something
15:54:20 <dmwit> Perfectly readable, I don't know what you're complaining about.
15:54:34 <thetallguy> point and readability free
15:54:37 <dmwit> :t foldM
15:54:39 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:55:14 <dmwit> thetallguy: You can probably do something interesting with foldM, but it won't be "nice", probably. =)
15:55:39 <thetallguy> dmwit: yeah, I saw that but it didn't look promising
15:55:58 <thetallguy> I forked a copy of filterM in about 30 seconds and will stick with that
15:56:17 <dmwit> :t \p -> foldM (\a b -> (if p b then first else second) (b:)) ([], [])
15:56:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a]) -> ([a], [a])
15:56:48 <dmwit> :t \p -> foldM (\a b -> (if p b then first else second) (return . (b:))) ([], [])
15:56:50 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
15:56:50 <lambdabot>       Expected type: [b] -> b
15:56:50 <lambdabot>       Inferred type: [b] -> [b]
15:57:01 <dmwit> Oh, right.
15:57:02 <thetallguy> Needs to support a -> IO BOol
15:57:33 <dmwit> :t \p -> foldM (\a b -> return ((if p b then first else second) (b:) a)) ([], [])
15:57:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> [a] -> m ([a], [a])
15:57:57 <dmwit> Now...
15:58:42 <dmwit> :t group
15:58:44 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:58:57 <dmwit> eugh
15:58:58 <thetallguy> still not there
15:59:04 <thetallguy> need a -> m Bool
15:59:08 <dmwit> Oh, okay!
15:59:15 <dmwit> No problem.
16:00:00 <gwern> @seen byorgey
16:00:00 <lambdabot> byorgey is in ##logic, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 2h 45m 23s ago.
16:00:31 <dmwit> :t foldM
16:00:33 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:01:26 <dmwit> :t \p -> foldM (\a b -> p b >>= \x -> return ((if x then first else second) (b:) a)) ([], [])
16:01:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [a] -> m ([a], [a])
16:02:19 <dmwit> ?pl \x -> return ((if x then first else second) (b:) a)
16:02:19 <lambdabot> return . flip (flip (flip (flip if' first) second) (b :)) a
16:02:25 <dmwit> ?yow!
16:02:26 <lambdabot> It don't mean a THING if you ain't got that SWING!!
16:02:36 <gwern> @tell Cale I've moved all the OEIS functionality in lambdabot out to the OEIS library, but I'm going to hold off on sending those patches until byorgey accepts/rejects the OEIS additions
16:02:36 <lambdabot> Consider it noted.
16:02:39 <shapr> @quote
16:02:39 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
16:02:45 <shapr> hiya jewel!
16:03:23 <vixey> @quute
16:03:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:03:27 <vixey> :(
16:03:39 <sjanssen> hmm
16:03:50 <sjanssen> why is quote failing all of a sudden?
16:03:56 <dons> it does that.
16:04:06 <dons> its a really weird bug
16:04:11 <roconnor> sjanssen: because it is written in Haskell :P
16:04:25 <dons> roconnor writes proofs, not software
16:04:36 <roconnor> dons: they are the same
16:04:50 <dons> write my an irc bot then :)
16:05:12 <dons> they are the same, just one is 10x more expensive
16:05:14 <roconnor> dons: IO is a research problem.
16:05:19 <roconnor> yep
16:05:25 <vixey> how is it such a problem?
16:05:46 <thetallguy> dmwit: thanks, that was fun.
16:05:49 <roconnor> vixey: well, Haskell 98 doesn't even have formal specification for IO
16:05:59 <vixey> ok
16:06:08 <vixey> I really have to try out my idea for implementing IO
16:06:31 <dmwit> thetallguy: Note that the lists will come out reversed...
16:06:34 <roconnor> granted quote ought to be mostly pure.
16:06:49 <roconnor> well
16:06:58 <roconnor> I guess it needs a database backend.
16:08:29 <roconnor> I'd fix lambdabot but I hear she is impossible to build.
16:08:40 <dmwit> Oh boy, more competitors!
16:08:52 <dmwit> It's a race to see who can make the least vaporware!
16:08:57 <vixey> no lambdabot is really easy to build
16:09:08 <vixey> and easy to add stuff too
16:09:13 <dons> no, lambdabot doesn't need fixing. we need a new bot built with modern libraries and techniques
16:09:52 <dons> lambdabot is from before: the libraries for: HTTP, IRC, bytestring, utf8, STM, -threaded, RSS, Feed, XML.
16:10:03 <roconnor> oh
16:10:06 <roconnor> good idea
16:10:16 <dons> seriously, none of those existed when it was written, so it is a big pile of glue and duplication
16:10:27 <dmwit> XML/
16:10:35 <dons> you could do it in 1/10th the code just by gluing modern libraries together
16:10:35 <roconnor> dons: think we can get an informal list of requirements for a lambdabot
16:10:36 <dmwit> Why would XML be good?
16:10:41 <dons> dmwit: oh, rss feeds?
16:10:47 <gwern> roconnor: well, there's still work to be done on lambdabot. I've been hacking on it to split things out to libraries - thus far I've done unlambda, brainfuck, & OEIS
16:10:50 <dmwit> oh
16:10:57 * dmwit still doesn't see the RSS feeds thing
16:11:01 <thetallguy> dmwit: noted
16:11:14 <roconnor> maybe we should just build a new bot
16:11:20 <roconnor> and add features slowly
16:11:44 <dmwit> roconnor: I guess the biggest features are: >, ?quote, ?karma, ?tell.
16:12:00 <vixey> and I like @src
16:12:09 <gwern> > is easy, use the GHC api
16:12:09 <roconnor> and hoogle
16:12:19 <vixey> is there a new hoogle?
16:12:24 <lambdabot>  thread killed
16:12:24 <gwern> roconnor: but hoogle just calls out to the hoogle binary
16:12:33 <dmwit> Yeah, probably the best thing is to grep the logs for each plugin's popularity, and go by that.
16:12:35 <gwern> heh
16:12:37 <roconnor> sure, hopefull it is easy
16:13:01 <vixey> is djinn with typeclasses decideable?
16:13:11 <dcoutts> gwern: > isn't that easy, you have to account for security and resource limits
16:13:26 <roconnor> I suppose pl is moderatley popular
16:13:33 <hpaste>  therp pasted "GHC bug?" at http://hpaste.org/8219
16:13:42 <therp> I guess this is not supposed to happen..
16:13:45 <dons> yeah, we need a better term rewriter than @pl though
16:13:51 <dons> one with an extensible rules list
16:13:56 <therp> can someone verify that problem?
16:14:01 <gwern> dcoutts: that's just a wrapper though - the hardest part of going through the GHC api would probably be whitelisting modules
16:14:39 <gwern> dcoutts: and I'm not sure that's a problem, because I think the Strings that GHC interperts aren't allowed to be meta constructs like :m - all the api code I've seen has to load modules through different functions
16:14:42 <vixey> therp what is the bug
16:15:08 <ddarius> The GHC API didn't exist when lambdabot was created.  lambdabot pioneered the dynamic code loading stuff.
16:15:18 <dcoutts> gwern: it still has to be out-of-process etc
16:15:18 <therp> vixey: the first map expression should not contain anything but zero. but it does
16:15:34 <dmwit> therp: Not a bug, it's using Int.
16:15:37 <vixey> what's the type of prec?
16:15:54 <dmwit> > 10^19 :: Int
16:15:55 <lambdabot>  -1981284352
16:16:01 <therp> dmwit: ah ok, so I should prec :: Integer?
16:16:05 <dcoutts> gwern: I'm sure it'd be simpler now though compared to first time round
16:16:33 <therp> vixey: Int.. hm, I guess that's the problem
16:16:33 <vixey> is there an IRC parser you will use?
16:16:38 <gwern> dcoutts: so, you spawn a process or call a lambdabot-eval and pass it a string. you spawn it as a process (first layer of protection), do it niced (second layer), have it call the same rlimit code as lambdabot does now (third layer), etc.
16:16:42 <vixey> therp: yeah Int is bounded
16:16:51 <gwern> and then it passes back the answer as a string
16:16:52 <therp> hmm.. this is an annoying default
16:17:01 <vixey> :t 43
16:17:03 <lambdabot> forall t. (Num t) => t
16:17:09 <vixey> I don't think it's a deafault
16:17:10 <dcoutts> gwern: right
16:17:26 <gwern> this way, the main bot doesn't loop, and the evaluator can cd somewhere safe, and you can add some very restrictive limits - ie, no file io of any kind
16:17:26 <therp> vixey: that's the every global symbol must have a proper type restriction..
16:17:41 <vixey> I don't know what you mean
16:17:48 <vixey> is that in ghci only?
16:18:07 <vixey> @hackage IRC
16:18:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/IRC
16:18:33 <dmwit> therp: The default for Num is Integer.
16:18:36 <gwern> vixey: I haven't looked hard enough at IRC to know whether it's useful
16:18:47 <dmwit> therp: So something else you are doing is restricting prec to Int.
16:19:04 <dcoutts> gwern: it'd be nice to be able to run a haskell process in the limited kernel mode where you can only read/write existing open file descriptors
16:19:07 <dmwit> vixey: 404'd
16:19:19 <vixey> I noticed
16:19:35 <dcoutts> gwern: sadly I think all haskell processes have to fiddle with timers and signal handlers all the time, even once they've initialised
16:19:41 <dmwit> ?hackage irc
16:19:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
16:19:52 <gwern> dcoutts: doesn't ulimit let you do that? '-n     open file descriptors'
16:19:52 <dmwit> fix'd
16:20:05 <ivanm> that's because @hackage only appends what you give it to that URL
16:20:16 <ivanm> doesn't mean that IRC is an actual library...
16:20:22 <ivanm> @where IRC
16:20:23 <lambdabot> I know nothing about irc.
16:20:37 <gwern> dcoutts: well, I remember I was once experimenting with adding more limits to lambdabot and I think I could in fact set file descriptors to 0 and get one evaluation
16:20:41 <therp> vixey: probably I'm wrong about that
16:20:43 <gwern> and then ghci would crash on me :)
16:20:47 <dcoutts> gwern: there's this linux kernel feature "seccomp" where you can put a process into a mode where it's only allowed read/write syscalls, anything else will make the kernel kill the process.
16:20:50 <gwern> there is an irc library
16:20:59 <vixey> therp: about what?
16:21:04 <gwern> interesting, but sounds hardly portable
16:21:24 <gwern> 'Arcangeli's CPUShare is the only service that makes use of this feature as of April 2006, and seccomp has been criticised ([1] Ingo Molnar's critique on linux-kernel mailing list) for being bound to a service (CPUShare) that is burdened with patents that aim to restrict the freedoms of grid computing service providers.'
16:21:40 <therp> vixey: about that there is some kind off restriction for top level symbols.. I vaguely remember the "default" directive from the haskell report
16:21:59 <therp> dmwit: hmm indeed it's my fault. I'm using "replicate"
16:22:20 <dons> dcoutts++ cabal only installing haskell == less shell scripts, more  haskell scripts!
16:22:44 <dcoutts> dons: hmm?
16:22:59 <dcoutts> dons: you mean it being hard to install shell scripts is a feature? :-)
16:23:16 <dcoutts> gwern: oh sure, not at all portable
16:23:28 <dons> IT IS A GOOD THING. :)
16:23:34 <gwern> dcoutts: yeah, it forces people to wear the haskell hair shirt
16:23:44 <sjanssen> gwern, dcoutts: what's wrong with making '>' safe via the type system?
16:23:49 <dons> makes me write little things like hackage2hwn in haskell, just to get easy distribution
16:24:11 <gwern> sjanssen: too hard. Let's go shopping instead
16:24:14 <dcoutts> sjanssen: time and space usage is important too
16:24:42 <gwern> sjanssen: also, I am not sure how one could do that, and there are ways around haskell's type system and the performance requirements on such a bot
16:24:43 <sjanssen> dcoutts: right, type system + the rlimit stuff we currently use
16:25:00 <gwern> (the security page for lambdabot is fairly impressively lengthy)
16:25:20 <dcoutts> sjanssen: and import restrictions to avoid unsafe*
16:25:59 <vixey> roconnor: How would one give a formal specification for IO? I'm guessing that coinductive trees would not be at home in a standard
16:26:13 <vixey> (only proofs, but maybe I'm wrong?)
16:27:12 <dcoutts> sjanssen: I'm not saying don't do it via types etc, I like that approach and it's much more general and portable.
16:27:33 <dcoutts> sjanssen: just that using OS features gives you some pretty good guarantees
16:28:08 <dcoutts> if a process can only read()/write() and exit() then you've got some pretty strong guarantees
16:28:26 <dcoutts> the whole thing then becomes a pure function :-)
16:28:26 <sjanssen> true
16:31:24 <roconnor> vixey: I'm no expert, buy I'd be included to try something like http://luqui.org/blog/archives/2008/03/29/io-monad-the-continuation-presentation/
16:31:25 <lambdabot> Title: IO Monad: The Continuation Presentation @ The dreams that stuff is made of, http://tinyurl.com/5dbq4p
16:31:36 <roconnor> vixey: except I would make IOTree a little less silly.
16:32:08 <roconnor> newtype IO a = IO { runIO :: (a -> IOTree) -> IOTree } looks good for some definition of IOTree
16:34:49 <vixey> @src o
16:34:49 <lambdabot> Source not found. My brain just exploded
16:34:50 <vixey> @src on
16:34:50 <lambdabot> (*) `on` f = \x y -> f x * f y
16:38:08 <dmwit> For those of you harping on about OS limits:
16:38:32 <dmwit> Is there any reason to think that "forkIO >> sleep 3 >> kill" would not work?
16:38:45 <sjanssen> yes
16:39:00 * dmwit grunts
16:39:01 <dons> sleep won't.
16:39:03 <sjanssen> you can't kill threads that are in tight loops
16:39:18 <dmwit> Oh, well then.
16:39:25 <dons> you need to use OS limits, afaik
16:39:25 <dmwit> forkOS >> sleep 3 >> kill
16:39:37 <dons> forkOS isn't what you think it is :)
16:40:24 <dmwit> "forkOS uses operating system-supplied multithreading support to create a new operating system thread"
16:40:33 <jamii_> dons: Lazy bytestring seems to use 64 byte chunks. Does this mean that using the standard interface, every bytestring is at least 64B?
16:40:36 <dons> ah, that's what you want to do? fork another os thread? not a process?
16:40:49 <dons> jamii_: nope.
16:40:51 <dmwit> err... oh.
16:40:53 <dons> it'll be less if the file is shorter.
16:41:17 <dmwit> It should be obvious by now that I haven't done much threading/processing in Haskell (or any other language). =P
16:41:36 <jamii_> Ok. Thanks. Seems that tries over bytestrings might work nicely then
16:41:37 <dons> forkOS is used to bind a haskell thread to a real os thread, so that foreign libraries can get thread local storage of the sort  they expect
16:42:19 <dmwit> Okay, when I finally get the right function call, will it work? =P
16:42:27 <dons> jamii_: for very short strings, sa, < 15 chars, bytestrings can have more overhead
16:42:39 <dmwit> Last try: runInteractiveProcess >> sleep 3 >> terminateProcess
16:42:39 <dons> but you'll have to benchmark to know for suree
16:44:12 <sjanssen> dmwit: should work, but resource limits will be more accurate
16:44:25 <sjanssen> plus you've also got to watch memory use
16:44:33 <dmwit> sjanssen: *nod*
16:44:42 <dmwit> Okay, thanks for bearing with me.
16:44:54 <jamii_> Im actually hoping to use them for general serialisation, not strings particularly. I guess I can use the internals with a smaller chunk size to reduce the space overhead.
16:45:36 <dons> yeah, that might work
16:45:44 <jamii_> Cool. Thanks
16:54:52 <hpaste>  cnwdup pasted "illegal polymorphic type" at http://hpaste.org/8220
16:55:11 <cnwdup> What's wrong with that? All I found with Google was about a ghc bug which should be fixed, though.
16:55:45 <dons> we should look at getting haskell on the iphone
16:56:44 <dmwit> cnwdup: type IRC a b = ...
16:57:07 <dmwit> cnwdup: And it is usually preferred to drop the (Plugin b =>) context entirely.
16:57:18 <dmwit> (I'm not even sure if it's legal in type declarations.)
16:57:25 <cnwdup> How should I drop it?
16:57:39 <dmwit> type IRC a b = StateT (IRCState b) (ReaderT IRCConfig IO) a
16:58:14 <monochrom> I don't think Plugin b => StateT (IRCState b) (ReaderT IRCConfig IO) a makes sense anyway.
16:58:33 <dmwit> Yeah, probably not.
16:58:42 <Cale> Don't forget to newtype!
16:58:42 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
16:58:43 <dmwit> monochrom: If the names actually reflect the meanings. ;-)
16:59:27 <monochrom> I am relying on little more than StateT, ReaderT, and IO.
17:00:10 <dmwit> Hmm, really?
17:00:10 <monochrom> Simply put, "type Blah a = forall b. State b a" makes no sense.
17:00:36 <dmwit> No, but type Blah a b = State b a could certainly make sense.
17:01:23 <monochrom> Yes, or type Blah a = State (forall b. .... b) a
17:05:11 <roconnor> @type return :: forall b. State b a
17:05:13 <lambdabot> Not in scope: type variable `a'
17:05:21 <roconnor> @type return :: a -> forall b. State b a
17:05:22 <lambdabot>     Inferred type is less polymorphic than expected
17:05:22 <lambdabot>       Quantified type variable `b' escapes
17:05:22 <lambdabot>       Expected type: a -> forall b1. State b1 a
17:06:25 <edwardk> Heh, I think I found out why http://citeseer.ist.psu.edu/fokkinga93dyads.html never had much in the way of follow up papers written about dyads.
17:06:26 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:26 <lambdabot> Title: Dyads, a Generalisation of Monads (ResearchIndex)
17:06:38 <edwardk> As near as I can tell there aren't any interesting dyads in Haskell
17:06:53 <cnwdup> Thanks for your help. (-:
17:07:58 <edwardk> The distributivity requirement as a natural isomorphism is too strong =(
17:08:57 <edwardk> @seen roconnor
17:08:57 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 3m 36s ago.
17:09:05 <edwardk> roconnor: yeah Functor f =>
17:09:14 <shapr> edwardk: Hey, got a sec on -blah ?
17:09:21 <byorgey> @seen gwern
17:09:22 <lambdabot> gwern is in #xmonad, #darcs and #haskell. I last heard gwern speak 44m 21s ago.
17:12:29 <edwardk> Anyways, can anyone think of a valid dyad that doesn't have an Identity (co)monad floating on one side or the other?
17:12:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8221
17:12:40 <edwardk> I beat my head on it for about an hour
17:12:47 <shapr> I helped!
17:12:52 <shapr> Sort of...
17:12:53 <cnwdup> dmwit: Now I have to carry Plugin b => ‚Ä¶ IO a b around in every function which seems a bit odd to. Can't I say in one place that b is always a member of the Plugin class instead of saying that in every function in the IRC monad?
17:13:05 <edwardk> heh
17:13:11 <edwardk> shapr was great moral support
17:13:38 <dmwit> cnwdup: Yes, it's possible.  Just not recommended.
17:14:00 <dmwit> cnwdup: Having (Plugin b =>) on the appropriate functions is a nice bit of documentation.
17:14:18 <dmwit> cnwdup: And I assume if you're giving explicit type signatures that you're kind of into self-documentation anyway, so... ;-)
17:15:11 <cnwdup> dmwit: Hum, explicit type signatures seem to be a matter of good style while having (Plugin b) => seems pretty redundant to me.
17:15:33 <cnwdup> Why is it recommended?
17:15:46 <gwern> byorgey: yes?
17:15:59 <cnwdup> (Oh, and btw. giving explicit type signatures is helping myself a lot. :-D)
17:16:32 <dmwit> You might get a little surprise at how much you can do with IRC a b without the Plugin b restriction. ;-)
17:16:47 <dmwit> ...and that is why it is recommended.
17:17:00 <cnwdup> Hum, ok. I'll try to get used to it.
17:17:02 <dmwit> So that you can sort out exactly which things actually require a Plugin and which don't.
17:17:18 <dmwit> See Data.Map for example.  There's actually quite a lot of things you can do without an Ord instance.
17:17:37 <cnwdup> But doesn't according to that type of IRC every function in the IRC monad require a Plugin and every function not in that monad does not?
17:17:55 <dmwit> Which type?
17:18:24 <cnwdup> The IRC type: type IRC a b = StateT (IRCState b) (ReaderT IRCConfig IO) a
17:18:58 <cnwdup> Yeah, but in the Data.Map module I understand why Ord k => is useful. Concerning my definition I do not.
17:19:06 <dmwit> Why would that state that every function in the IRC monad required a Plugin restriction?
17:19:24 <edwardk> shapr: find me a dyad! =)
17:19:27 <dmwit> cnwdup: No, it's not the Ord k => that's useful.  It's the functions that *don't* have Ord k => that are interesting.
17:19:49 <shapr> edwardk: We already looked! I'm busy building emacs for my XO, sorry.
17:19:53 <cnwdup> dmwit: I'll take a look at them.
17:20:20 <edwardk> shapr: ok then prove they don't exist ;)
17:20:44 <shapr> edwardk: You started out with the simple (e,a) <-> e -> a, is there anything else that's pretty much that simple?
17:20:57 <cnwdup> dmwit: If I have a function operating in the IRC monad, I have to declare IRC a b. And b is always of class Plugin. I have no other data structure (so far) which would fit there. At least I can't think of any.
17:21:01 <edwardk> (e -> a, a) -> e -> a
17:21:06 <edwardk> the other was too simple
17:21:15 <shapr> I hypothesize that all dyads will require an output type where there's no input type, that little e hanging off to the right.
17:21:22 <shapr> oh right
17:22:36 * edwardk is stuck compiler-less and is going through withdrawal
17:23:01 <ddarius> edwardk: Implement a compiler in lambdabot.
17:23:17 <edwardk> hard to fit it into the line limit
17:23:26 <shapr> edwardk: If you give me your public key...
17:23:32 <ddarius> Just use @let
17:23:39 <edwardk> aha!
17:23:47 <shapr> But I don't have 6.9
17:24:05 <gwern> power failure, heh
17:24:12 <gwern> so byorgey, what were you going to say?
17:24:13 <shapr> edwardk: Ya know, you could always host that little green Linux box over here.
17:24:40 <edwardk> @let lam e env x = e (x, env)
17:24:41 <lambdabot> Defined.
17:24:55 <edwardk> @let app f x env = (f env) (x env)
17:24:56 <lambdabot> Defined.
17:25:32 <dmwit> :t app
17:25:34 <lambdabot>     Ambiguous occurrence `app'
17:25:34 <lambdabot>     It could refer to either `L.app', defined at <local>:3:0
17:25:34 <lambdabot>                           or `Control.Arrow.app', imported from Control.Arrow at State/imports.h:59:0-33
17:25:34 <edwardk> @let bool (b :: Bool) env = b
17:25:35 <lambdabot>  Parse error in pattern
17:25:40 <dmwit> :t L.app
17:25:41 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
17:25:51 <dmwit> :t ap :: (t -> t1 -> t2) -> (t -> t1) -> t -> t2
17:25:53 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
17:25:58 <edwardk> @let vz = fst
17:25:59 <lambdabot> Defined.
17:26:11 <edwardk> @let vs vp env = vp (snd env)
17:26:12 <lambdabot> Defined.
17:28:27 * ddarius wonders how hard it would be to write a source to source translator that would "flatten" a Haskell program to the expression language accepted by lambdabot.
17:29:29 <dmwit> Pretty hard, since (main :: IO ()).
17:29:32 <edwardk> @let literal = const
17:29:33 <lambdabot> Defined.
17:30:14 <ddarius> dmwit: It wouldn't accept -every- Haskell program, but it should accept the entire pure subset ideally.
17:30:36 <dmwit> I'm just saying, how do you isolate the expression you want it to flatten?
17:30:39 <edwardk> L.app (L.lam vz) (L.literal True) []
17:30:42 <edwardk> er
17:30:46 <dmwit> Suppose you've got a nice big file with lots of function definitions.
17:30:50 <edwardk> > L.app (L.lam vz) (L.literal True) []
17:30:51 <lambdabot>  True
17:30:53 <vixey> what is going on here.. "Non-exhaustive patterns in function isIn"
17:31:03 <ddarius> dmwit: It would be a whole file, there's no need to isolate anything.
17:31:04 <gwern> @seen byorgey
17:31:04 <lambdabot> byorgey is in ##logic, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 21m 43s ago.
17:31:14 <dmwit> ddarius: There's no (obvious) distinguished value in there to choose as the final "in" clause.
17:31:33 <dmwit> vixey: You've written a partial function.
17:31:42 <ddarius> dmwit: It wouldn't make an expression, it would make a series of @let commands
17:31:46 <dmwit> vixey: Match on all the constructors instead of just some of them.
17:31:51 <dmwit> ddarius: Oh, okay.
17:31:57 <ddarius> vixey: Shame on you.
17:32:06 <vixey> but look: data Pattern = PatVar Name | PatCtr Name [Pattern]
17:32:15 <vixey> & my function is
17:32:15 <vixey> v `isIn` PatVar p    = v == p
17:32:15 <vixey> v `inIn` PatCtr c ps = (v`isIn`)`any`ps
17:32:20 <vixey> so how could this happen?
17:32:34 <dmwit> vixey: You misspelled isIn.
17:32:45 <vixey> oh my ...
17:32:52 <edwardk> @ddarius: i was able to get an interpreter, does that count? =)
17:32:53 <lambdabot> Unknown command, try @list
17:32:53 <vixey> wow thanks,
17:32:56 <edwardk> er ddarius:
17:33:10 <ddarius> vixey: Adding -W should warn against such errors.
17:35:56 <dons> dcoutts: does cabal-install respect -ffoo flags?
17:36:12 <dcoutts> dons: should do, might not at the moment
17:36:22 <dons> using the Cabal-1.3.11 snapshot, i'm not getting them picked up with cabal-install
17:36:30 <dcoutts> dons: I probably didn't do that bit yet with the new dep resolver
17:36:41 <dons> ah ok.
17:36:51 <dcoutts> shouldn't be hard
17:36:58 <dcoutts> dons: it'll work with configure of course
17:37:04 <dons> yep, it does.
17:37:13 <dons> but who uses that anymore? :)
17:37:20 <dcoutts> heh, quite
17:38:08 <vixey> @index mappend
17:38:09 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
17:38:26 <vixey> :t (++)
17:38:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:38:29 <vixey> :t mappend
17:38:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
17:41:28 <vixey> I found a case where mappend doesn't replace ++
17:42:38 <vixey> @pl (\(x,y) -> (`aaa`f x y))
17:42:38 <lambdabot> uncurry ((flip aaa .) . f)
17:43:29 <dmwit> vixey: What do you mean?
17:43:47 <vixey> where you get type errors replacing ++ with mappend
17:44:01 <ddarius> vixey: That's easy to do.
17:44:19 <dmwit> ?instances Monoid
17:44:24 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:44:34 <dmwit> vixey: Do tell.
17:47:35 <dons> ?yow
17:47:36 <lambdabot> ONE:    I will donate my entire "BABY HUEY" comic book collection to
17:47:36 <lambdabot> 	the downtown PLASMA CENTER ...
17:47:36 <lambdabot> TWO:	I won't START a BAND called "KHADAFY & THE HIT SQUAD" ...
17:47:36 <lambdabot> THREE:	I won't ever TUMBLE DRY my FOX TERRIER again!!
17:47:40 <dons> hah
17:50:29 <vixey> actually I must have had some other mistake I cant reproduce it
17:51:00 <sutats> Am I correct in assuming that tail is the same as drop 1?
17:51:06 <wjt> @src tail
17:51:06 <lambdabot> tail (_:xs) = xs
17:51:06 <lambdabot> tail []     = undefined
17:51:15 <wjt> @src drop
17:51:15 <lambdabot> drop n xs     | n <= 0 =  xs
17:51:15 <lambdabot> drop _ []              =  []
17:51:15 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
17:51:25 <Cale> > tail []
17:51:25 <wjt> so, no.
17:51:26 <lambdabot>  Exception: Prelude.tail: empty list
17:51:29 <Cale> > drop 1 []
17:51:31 <lambdabot>  []
17:51:57 <sutats> Okay, good to know. Assuming the list is long enough, that would be the case then, right?
17:52:02 <Cale> yeah
17:52:10 <Cale> > tail "hello"
17:52:15 <Cale> > drop 1 "hello"
17:52:17 <lambdabot>  "ello"
17:52:18 <lambdabot>  "ello"
17:52:46 <roconnor> edwardk: fixed
17:54:56 <dmwit> ?check \xs -> not (null xs) ==> tail xs == drop 1 xs -- yes, the same for non-empty lists
17:54:58 <lambdabot>  OK, passed 500 tests.
18:01:56 <gwern> neat. lambdabot has a full copy of smallcheck inside it
18:02:00 <gwern> one more file I can remove!
18:02:36 <dmwit> heh
18:02:55 <marko> hi all
18:02:55 <dons> there was no cabal when lambdabot was born. in the age before hackage, when great titans roamed the earth
18:02:58 <gwern> now my high score is definitely over a thousand
18:03:07 <dmwit> marko: Hiya!
18:03:16 <gwern> dons: I'm not criticizing you, I'm just pleased because it means less code to deal with later
18:03:28 <marko> hi dmwit.
18:03:34 <ddarius> dons didn't make lambdabot
18:04:01 <dolio> @fact Pseudonym
18:04:01 <lambdabot> pseudonym: My initial creator.
18:05:41 <vixey>                    App (App (Var "cons") (App (Var "succ") (Var "zero")))
18:05:41 <vixey>                        (App (App (Var "cons") (App (Var "succ") (Var "zero")))
18:05:41 <vixey>                             (App (App (App (Var "zipWith") (Var "add")) (Var "fibs")) (App (Var "tail") (Var "fibs"))))
18:05:56 <Pseudonym> @vixen So how much of my code are you still running?
18:05:57 <lambdabot> i truely am
18:06:09 <gwern> dons: but what's with this perl timein script?
18:08:29 <vixey> :t writeChar
18:08:31 <lambdabot> Not in scope: `writeChar'
18:08:35 <vixey> :t puhChar
18:08:37 <vixey> :t putChar
18:08:37 <lambdabot> Not in scope: `puhChar'
18:08:39 <lambdabot> Char -> IO ()
18:09:01 <vixey> why not have %putChar :: Char -> ()
18:09:08 <vixey> then define the IO Monad around it
18:11:09 <Pseudonym> That's kind of the point.
18:11:36 <Pseudonym> It's possible that you might be able to implement the IO monad in terms of primitives like that.
18:11:42 <Pseudonym> But there's no way you'd ever expose it.
18:12:19 <vixey> and I could give a completely precise definition of IO if only relying on non-strictness
18:12:38 <vixey> I mean not even requiring lazyness, is that possible?
18:14:10 <Cale> vixey: You know about my idea of specifying IO as a GADT right?
18:14:25 <vixey> I don't think so
18:14:49 <Cale> Well, the IO datatype doesn't really need to have anything impure in it.
18:14:50 <Pseudonym> Cale: You mena the way that... I think it was Yale did it.
18:14:58 <Cale> data IO a where
18:15:01 <Pseudonym> That runs into the expression problem, surely?
18:15:11 <Cale> Which expression problem?
18:15:13 <Pseudonym> And doesn't play with FFI.
18:15:31 <Cale> Well, yeah, for FFI you'd need an open datatype.
18:15:33 <Pseudonym> The expression problem is the problem of adding new constructors to a type.
18:15:34 <Pseudonym> Yes.
18:15:44 <vixey> was that i?
18:15:46 <vixey> empty
18:15:58 <Cale> vixey: no
18:16:08 <Cale> I just stopped to answer Pseudonym
18:16:16 <Cale>   ReturnIO :: a -> IO a
18:16:24 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
18:16:32 <Cale>   GetChar :: IO Char
18:16:39 <Cale>   PutChar :: Char -> IO ()
18:16:50 <Cale>   ForkIO :: IO a -> IO ThreadID
18:16:53 <Cale> and so on.
18:17:03 <Cale> You make all the primitives into constructors.
18:17:32 <Cale> and then the Haskell runtime just examines this data structure and carries out the actual actions
18:17:43 <vixey> I like that
18:18:03 <SamB> Cale: what about the FFI?
18:18:15 <Cale> SamB: For FFI, you'd need it to be an open GADT.
18:18:25 <roman> hello there
18:18:33 <Cale> roman: hello
18:18:57 <Pseudonym> Here's it for State.  Note that this was before I knew the syntax for GADTs.
18:19:00 <Pseudonym> http://osdir.com/ml/lang.haskell.cafe/2005-01/msg00028.html
18:19:01 <lambdabot> Title: Re: Re: Typed Lambda-Expressions withOUT GADTs: msg#00028
18:19:34 <Pseudonym> And not to be outdone, Oleg translated it into typeclass form.
18:19:37 <Pseudonym> http://osdir.com/ml/lang.haskell.cafe/2005-01/msg00031.html
18:19:37 <lambdabot> Title: Initial (term) algebra for a state monad: msg#00031
18:20:08 <roman> may someone please explain to me which is the diference between "import" and "import qualified"
18:20:45 <gwern> @hoogle cmd
18:20:46 <lambdabot> System.Cmd :: module
18:20:46 <lambdabot> Distribution.Simple.Setup.ConfigCmd :: ConfigFlags -> Action
18:20:46 <lambdabot> Distribution.Simple.Setup.BuildCmd :: Action
18:20:54 <SamB> roman: the report would do it well
18:22:37 <Cale> roman: Basically, import qualified means that the names from that module are imported in such a way that you must include the module prefix to refer to them
18:22:49 <roman> Thanks Sam, have searched in google (site:) and it took me to the modules chapter, also... is there an easy way to understand when the people use $ in a sequence? like in the line 23 of this source code: http://hrnjad.net/src/s/Scaffolding.hs.html
18:22:50 <lambdabot> Title: ~/src/haskell/normal-strings/Scaffolding.hs.html
18:22:59 <Cale> That is,  Data.Char.ord  rather than just  ord
18:23:04 <roman> Thanks Cale
18:23:21 <Cale> $ is just function application
18:23:25 <Cale> f $ x = f x
18:23:41 <roman> is like the id function?
18:23:45 <Cale> yeah
18:23:48 <roman> ohhh ok
18:23:50 <Cale> But it binds very weakly
18:24:04 <vixey> what's >> called?
18:24:06 <Cale> So, for instance, if you have:
18:24:14 <dobblego> I use "anonymous bind"
18:24:24 <Cale> f . g . h $ k x y
18:24:29 <Cale> then that's like:
18:24:36 <Cale> (f . g . h) (k x y)
18:25:01 <vixey> *LazyIO> whnf code (Case (PutChar 'x') [(PatVar "_", Ctr "OK" [])])
18:25:01 <vixey> OK
18:25:01 <vixey> *LazyIO> whnf code (Case (PutChar 'x') [(PatCtr "()" [], Ctr "OK" [])])
18:25:01 <vixey> xOK
18:25:03 <roman> oh ok
18:25:04 <Cale> vixey: I call it 'then', sometimes.
18:25:07 <vixey> Cale: like this sort of thing?
18:25:20 <vixey> (I am testing out this idea)
18:25:29 <roman> thanks Cale
18:25:42 <Cale> vixey: Nothing should happen on evaluation of values of type IO a
18:25:54 <Cale> (just like nothing currently happens when such values are evaluated)
18:26:13 <vixey> but then how does IO ever happen?
18:26:15 <Cale> It's only when they're actually executed that effects occur.
18:26:43 <Cale> The runtime system can be thought of as a (side-effecting) interpreter.
18:26:50 <roman> nice... got the idea experimenting with ghci... thanks a lot Cale, that are the kind of small bits that couldn't find quickly
18:27:10 <Cale> roman: Let us know if you have any other problems. :)
18:27:58 <Cale> roman: Note that some people like to write things like  f $ g $ h $ x, but I recommend against that style, since it doesn't refactor as cleanly as using function composition:  f . g . h $ x
18:28:18 <Cale> Note that g . h is going to be a well-typed function, but g $ h on its own is meaningless.
18:28:36 <vixey> when does the runtime perform side effects
18:29:10 <roman> As far as I did understand you are changing the surrounding () for $
18:29:17 <roman> is that correct?
18:29:37 <Cale> vixey: Well, it recursively pattern matches on main, causing constructors in that to be evaluated until it gets to a primitive that represents an action it can carry out.
18:29:40 <roman> so f $ g $ h $ x would be equal to (f(g(h(x)))
18:29:47 <SamB> vixey: when it encounters them in traversing the IO value
18:29:48 <roman> )
18:29:58 <Cale> roman: With the current associativity, yes.
18:30:10 <vixey> I see
18:30:40 <Cale> roman: ($) is defined to be right associative, which is a bit strange, since function application normally associates to the left (and indeed, the left associative version of ($) would be more useful)
18:33:24 <SamB> especially $!
18:35:00 <roman> Cale: but for that kind of declartion, probably is better to use function composition... is more elegant as I see...
18:35:05 <Cale> yeah
18:35:17 <Cale> exactly :)
18:38:01 <gwern> Cale...
18:38:05 <gwern> I have patches for you!
18:38:09 <gwern> (bwa ha ha ha)
18:38:13 <Cale> great :)
18:38:31 <gwern> 31...
18:38:40 <byorgey> gwern: I got the oeis patches, thanks
18:38:41 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
18:38:53 <gwern> byorgey: you apply'em?
18:38:58 <roman> Cale: another question that probably you should know, i'm learning about the zipWith function on the Data.List module, I was doing crazy stuff with function composition just for fun, and I got an error that don't know exactly how to solve... the thing is that when invoke something like zipWith ((^2) . (+)) [1..3] [1..3]
18:39:05 <byorgey> gwern: I will apply them and upload a new version to hackage, as soon as my password gets reset on c.h.o
18:39:16 <gwern> hum
18:39:34 <roman> it throws an error "Possible fix: add an instance declaration for (Num (a -> a))"... but when using another function like map
18:39:36 <dcoutts> @type ((^2) . (+))
18:39:38 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a -> a
18:39:47 <dcoutts> roman: ^^
18:39:53 <ddarius> @unpl (^2) . (+)
18:39:54 <lambdabot> (\ d -> ((+) d) ^ 2)
18:39:57 <Cale> roman: well, if that was well typed, then the first element of the resulting list would look like  ((^2) . (+)) 1 1
18:40:02 <byorgey> Isaac Potoczny-Jones = syntaxninja, right?
18:40:09 <dcoutts> byorgey: yep
18:40:11 <Cale> which is the same as:
18:40:15 <byorgey> @seen SyntaxNinja
18:40:15 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. I don't know when SyntaxNinja last spoke.
18:40:21 * byorgey pokes SyntaxNinja 
18:40:46 * byorgey pokes dons 
18:40:56 <SyntaxNinja> hi byorgey
18:40:59 <Cale> ((^2) ((+) 1)) 1
18:41:03 <byorgey> hey SyntaxNinja
18:41:12 <Cale> which is probably not what you want.
18:41:23 <byorgey> just a friendly reminder to reset my password on c.h.o =)
18:41:37 <Cale> The trouble being that you'd need to know how to raise the function ((+) 1) to the power of 2 ;)
18:42:06 <Cale> and that's what it's complaining about -- it's saying "You haven't told me how to treat functions as numbers"
18:42:10 <dcoutts> byorgey: what's your c.h.o username?
18:42:10 <SyntaxNinja> byorgey: hm. no one has done that yet?  Can you ping dons about that?
18:42:16 <SyntaxNinja> or dcoutts :)
18:42:28 <byorgey> dcoutts: byorgey
18:42:35 <roman> i would like something like:
18:42:40 <Cale> (f . g) x y
18:42:40 <gwern> Cale: the patches are sent
18:42:42 <roman> "zipWith (\x -> \y -> (x + y) ^ 2) [1..3] [1..3]" but with function composition
18:42:45 <dcoutts> byorgey: oh, I don't see any ticket from you
18:42:46 <Cale> = ((f . g) x) y
18:42:56 <Cale> = (f (g x)) y
18:43:02 <Cale> = f (g x) y
18:43:07 <byorgey> hm, no one told me I had to make a ticket
18:43:14 <gwern> Cale: my next set of patches will probably be me trying to make an executable/library split
18:43:28 <byorgey> this is all due to the ssh vulnerability
18:43:34 <denbuen_> Are there no nested bullets in haddock?
18:43:38 <byorgey> my ssh key was blacklisted and I don't know the password
18:43:39 <dcoutts> byorgey: email support @ c.h.o with your new ssh public key
18:43:47 <byorgey> ok, will do
18:43:54 <Cale> roman: well, that'd be ((^2) .) . (+)
18:44:04 <Cale> roman: though that's not terribly easy to read
18:44:16 <Cale> (it's probably best to stick with a lambda here)
18:44:35 <byorgey> sent
18:44:38 <Cale> (((^2) .) . (+)) x y
18:45:05 <Cale> = ((^2) .) ((+) x) y
18:45:05 <vixey> @src divMod
18:45:05 <lambdabot> Source not found. Are you on drugs?
18:45:12 <byorgey> dcoutts: uh, I got a delivery failure
18:45:15 <Cale> = ((^2) . (+) x) y
18:45:22 <Cale> = (^2) ((+) x y)
18:45:30 <Cale> = (x + y)^2
18:45:54 <dcoutts> byorgey: sorry I was ambiguous, community.h.o
18:46:02 <byorgey> oh, hehe, ok =)
18:46:29 <roman> ok... have to check out this a little bit more... got confused with the (.) constructs
18:46:36 <ddarius> @pl \x y -> (x + y) ^ 2
18:46:36 <lambdabot> flip flip 2 . ((^) .) . (+)
18:46:38 <byorgey> ok, sent =)
18:46:50 <roman> thank you very much... I was feeling frustrated
18:49:23 <Cale> roman: Note that it's an operator section... you could also write it as ((.) (^2)) . (+)
18:49:29 <sutats> What's going on with the first . in "((^) .) . (+)"?
18:49:36 * dcoutts wonders if roconnor and sclv are making fun of us...
18:49:37 <dcoutts> http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
18:49:38 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
18:49:48 <Cale> sutats: It's the same as the + in (5 +)
18:49:55 <Cale> > map (5 +) [1..10]
18:49:56 <lambdabot>  [6,7,8,9,10,11,12,13,14,15]
18:50:10 <sutats> Ah, interesting
18:50:48 <shapr> dcoutts: Actually, I heard about those today at work.
18:50:50 <dcoutts> I see your hylomorphism and I raise you one zygohistomorphic prepromorphism!!
18:50:58 <roconnor> dcoutts: we are just documenting edwardk's wisdom.
18:51:08 <roconnor> and making fun of us
18:51:10 <roconnor> 2 for 1
18:51:12 <shapr> Rumor has it that they were nearly called wrapromorphisms.
18:51:24 <dcoutts> shapr: oh the python guys are into categories now eh? :-)
18:51:36 <amishdude01> Fill out surveys and get paid!!!! no joke!! go to  http://www.getpaidto.com/?ref=6966
18:51:37 <amishdude01> Fill out surveys and get paid!!!! no joke!! go to  http://www.getpaidto.com/?ref=6966
18:51:50 <dolio> @yow!
18:51:50 <lambdabot> My life is a patio of fun!
18:51:59 --- mode: ChanServ set +o dons
18:52:02 --- mode: dons set +b *!*=amishdud@*.pitbpa.fios.verizon.net
18:52:02 --- kick: amishdude01 was kicked by dons (dons)
18:52:06 --- mode: ChanServ set -o dons
18:52:18 <dons> good thing it wasn't a joke
18:52:20 <edwardk> roconnor: =P
18:52:27 <byorgey> http://haskell.org/haskellwiki/Real_World
18:52:27 <lambdabot> Title: Real World - HaskellWiki
18:52:37 <shapr> dons: thank you.
18:52:39 <shapr> I was too slow :-(
18:53:02 <shapr> dcoutts: Nah, I just work with edwardk.
18:53:13 <dcoutts> shapr: :-)
18:53:31 <shapr> dcoutts: Have you ever visited the OLPC offices? You'd enjoy it if you haven't.
18:53:47 <dcoutts> shapr: I haven't, they're in the US right?
18:53:49 <cjb> oh, dcoutts is in the US?
18:53:55 <dcoutts> cjb: UK
18:54:00 <cjb> thought so.
18:54:18 <edwardk> I had hoped to actually write up an article explaining the relationships between the various recursion schemes and the distributive law combinators today, but server is still down
18:54:37 <shapr> Since I'm the size of at least two children, I have a second XO showing up soon.
18:55:00 <edwardk> shapr: the wrapromorphisms or amphipromorphisms are something else, they just don't seem to work yet =)
18:55:21 <shapr> Oooh, I haven't heard about the second flavor!
18:55:27 <shapr> Still full of pizza? ;-)
18:55:32 <edwardk> yeah
18:55:35 <shapr> ah well
18:55:54 <uebayasi> someone(tm) should sell OLPC in .jp...
18:56:08 <shapr> uebayasi: The G1G1 program is coming back in August.
18:56:22 <edwardk> amphipro was the other name for prepro and postpro i was playing with, since amphi is 'both sides' or 'around'
18:56:45 <Cale> I just completed my project to give a laptop to every child on the moon!
18:56:47 <shapr> Prepostro-morphisms are just hard to believe, yeah?
18:56:57 <edwardk> =)
18:57:10 <gwern> Cale: Huge success!
18:57:15 <gwern> cake for everyone
18:57:23 <edwardk> The cake is a lie!
18:57:33 <shapr> The owls are not what they seem!
18:57:39 <Cale> My cake has fish shaped candies on it!
18:57:54 <monochrom> My cake is fish cake.
18:57:55 <gwern> how is the cakes, twisp?
18:58:39 <Staz> Hi, we are learning about standard semantics at uni -- Can anybody point me to a great resource that has info about Continuations/Stores/Locations/Environment etc.. ?
18:58:49 <Staz> at the moment it all confuses the hell out of me
18:59:13 <Cale> also, fish shaped ethylbenzene
19:02:45 <gwern> Cale: why haven't you applied my patches?
19:02:49 <gwern> apply my patches, Cale
19:02:54 <Cale> okay
19:03:00 <gwern> Dave, I cannot allow you to not do that
19:04:03 <Cale> Should I just apply the last set of patches, or should I grab all the ones from the other emails at the same time?
19:04:25 <gwern> Cale: I believe the last set includes all the foregoing
19:05:38 <ddarius> Staz: There are a few online books on semantics that cover that, but then that stuff is what you are being taught so...
19:06:42 <shapr> Cale: Ethylbenzene is a styrofoam intermediate compound, yeah?
19:07:06 <Cale> yeah
19:07:28 <shapr> Styrofoam Fish?
19:07:28 <Cale> I'm just taking ingredients from the cake recipe in Portal :)
19:07:30 <shapr> oh!
19:07:31 <Staz> ddarius : Can you recommend one? The lecturer give us very basic notes but a book would be much better.
19:08:57 <Cale> http://uk.youtube.com/watch?v=P9R4rsWNk6s
19:08:58 <lambdabot> Title: YouTube - Portal Blue GLaDOS Eye Speech
19:13:15 <dolio> Sound like good cookies.
19:13:37 <vixey> @hoogle flush
19:13:37 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
19:13:38 <lambdabot> System.IO.hFlush :: Handle -> IO ()
19:13:52 <dolio> Too much rhubarb, maybe.
19:14:08 <roman> Cale thanks for all your feedback, probably would check :type of compositions before trying to do anything :-D, nice guidance
19:14:12 <vixey> how do you flush output?
19:14:13 <roman> gotta go
19:14:56 <Cale> roman: you're quite welcome, see you around!
19:15:10 <Cale> dolio: It's a cake :)
19:15:27 <ddarius> Staz: http://www.cs.uiowa.edu/~slonnegr/
19:15:28 <lambdabot> Title: Ken Slonneger
19:15:29 <dolio> Ah. I was confused by the chocolate chips.
19:15:32 <vixey> well I got lazy IO to work
19:15:50 <geezusfreeek> deep penetration asians?!
19:16:11 <vixey> http://thepastesiteat.endoftheinternet.org:8080/paste/4
19:16:31 <vixey> that's certainly the longest program I wrote to just print out fibs...
19:17:15 <vixey> anyway it seems like you can do predictable IO in a lazy language just by having %putChar :: Char -> (), side effect, when the WHNF of () is taken
19:17:35 <vixey> (and implementing monads in terms of that I guess I will have to try next :))
19:17:38 <dons> yeah, use `seq` to order computations :)
19:17:56 <dons> basically, boil things down to a series of 'case' ?
19:18:00 <vixey> yes
19:18:04 <dons> case putChar of () -> ...
19:18:10 <vixey> (at least that's what I did here)
19:19:11 <ddarius> You can have predictable IO just so long as you manually translate your code to a strict language.
19:19:25 <vixey> I still have lazy evaluation though
19:19:47 <ddarius> If you didn't you wouldn't have to manually translate.
19:20:35 * Cale waits for new release of oeis
19:21:26 <vixey> my code is so so inefficient though, I need to figure out how to write a lazy eval that doesn't do rewriting
19:21:27 <Cale> byorgey: are you applying gwern's patch to the hackage version?
19:23:01 * vixey needs to stop saying 'though' :/
19:25:42 <ddarius> vixey: Compile to combinators and give the combinators a graph reductions semantics.  Each of those steps is pretty simple and the result is a reasonably efficient interpreter for the given effort.
19:28:01 <jre2> does haskell have something similiar to python's docstring?
19:28:32 <Cale> jre2: Haddock?
19:28:34 <vixey> hmmmm
19:28:52 <vixey> I think the GADT idea is much simpler
19:29:02 <vixey> since there really are no side effects
19:29:31 <jre2> er, I meant for use as a literal string (with the escaping and newlines etc)
19:30:51 <vixey> Cale have you implemented it?
19:30:54 <NameAlreadyInUse> this is going to seem like a really stupid question, but is it actually possible to define a function like this: http://codepad.org/PdOLcMK0 ?
19:30:58 <vixey> (or has anyone)
19:31:07 <Cale> vixey: no.
19:31:35 <vixey> NameAlreadyInUSe: square x = do print "Computing square" ; return $ x * x
19:31:40 <Cale> NameAlreadyInUse: square x = putStrLn "Computing Square" >> return (x*x)
19:31:52 <NameAlreadyInUse> ok, great
19:32:00 <NameAlreadyInUse> i knew it was something along those lines but.. =\
19:32:04 <bd_> vixey: print will add extra quotes to that
19:32:05 <Cale> NameAlreadyInUse: Note that it doesn't have the same type as a function which simply computes the square of x
19:32:25 <ddarius> square = (putStrLn "Computing Square" >>) . join (*)
19:32:34 <ddarius> crap
19:32:36 <NameAlreadyInUse> Cale: how is that? :S
19:32:37 <ddarius> square = (putStrLn "Computing Square" >>) . return . join (*)
19:32:42 <Cale> NameAlreadyInUse: Because instead of producing a number, it produces an action which prints stuff on the screen before giving the square.
19:33:12 <Cale> NameAlreadyInUse: That action is itself a value, and evaluation alone doesn't cause the action to execute.
19:33:48 <NameAlreadyInUse> ah, so i would not be able to do: print (square 5)
19:34:07 <Cale> right, you'd have to use  square 5 >>= print
19:34:20 <NameAlreadyInUse> how does that >>= work?
19:34:22 <Cale> or  print =<< square 5
19:34:41 <awesame> I don't understand why >>= seems to be more popular than =<<
19:34:45 <Cale> If x is an action, and f is a function from results of that action to further actions
19:34:53 <awesame> =<< looks more like normal function application
19:34:57 <ddarius> awesame: Because English reads left to right
19:35:00 <augur> namealreadyinuse: >>= is sexy omg
19:35:04 <Cale> then x >>= f is an action which carries out x, and passed the result to f, then carries out the result of that
19:35:10 <Cale> passes*
19:35:19 <roconnor> >>= illustrates the way the effects are performed
19:35:23 <augur> >>= is basically just flatten the results of mapping the left hand side with the function on the right hand side
19:35:28 <roconnor> first >>= second
19:35:35 <awesame> I guess that makes sense
19:35:40 <augur> but thats over simplified, because each type of data defines its own implementation of >>=
19:35:45 <roconnor> second =<< first is arguably confusing
19:35:46 <awesame> but it doesn't match function application
19:35:53 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:35:54 <awesame> or composition
19:35:54 <lambdabot> Title: Introduction to IO - HaskellWiki
19:36:15 <bd_> =<< can be useful if you are writing something that looks like (or combines) function composition, to make the flow of data more obvious
19:36:26 <Cale> There's a short note about how IO works in Haskell which will explain it more coherently at first than we'll manage in IRC :)
19:36:42 <Cale> (but feel free to ask questions about it :)
19:36:47 <NameAlreadyInUse> ok, thanks. a lot of this is very new to me
19:36:58 <awesame> (f . g) is a lot like (f =<< g)
19:37:29 <awesame> are there standard names for flipped . and $ operators?
19:37:49 <Cale> awesame: not quite...
19:38:07 <Cale> awesame: the analogue of composition is Kleisli composition... I forget if that has a name in the libraries yet.
19:38:20 <Cale> oh, it does :)
19:38:27 <Cale> :t (<=<)
19:38:29 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:38:36 <Cale> :t (.)
19:38:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:38:45 <Cale> :t (Prelude..)
19:38:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:39:07 <bd_> (.) really shouldn't be generalized in lambdabot :|
19:39:16 <Cale> bd_: why not?
19:39:31 <bd_> Cale: confusing when trying to teach newbies :)
19:39:53 <monochrom> I love [to eat] newbies.
19:39:55 <bd_> make a nice GeneralPrelude cabal library, sure, but opt-in, and for advanced users who know they're deviating from 'standard' haskell
19:40:04 <Cale> I'm happy to explain it if anyone wants :)
19:40:17 <monochrom> haskell is confusing to newbies.
19:40:25 <awesame> :t (=<<)
19:40:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:40:33 <vixey> monochrom well put :D
19:40:52 <bd_> monochrom: yes, no need to make the learning curve any steeper :)
19:40:54 <monochrom> should make haskell look like scheme for newbies. then provide a RealHaskell module for opt-in.
19:41:02 <ddarius> Programming is confusing to newbies.
19:41:10 <Cale> We should have a Dr. Scheme for Haskell. :)
19:41:15 <ddarius> Professional dirt bike racing is confusing to newbies.
19:41:19 <awesame> well, that explains why =<< reminds me of fmap
19:41:29 <bd_> Cale: disable all of IO, and anonymous functions at the start? :)
19:41:42 <awesame> I see the difference now
19:41:46 <dobblego> I went dirt bike riding all weekend :)
19:42:50 <vixey> what would Dr. Haskell do?
19:43:07 <ddarius> State and prove theorems of combinatory logic.
19:43:09 <vixey> I'm not sure what more anyone would want than ghc actually
19:43:12 <vixey> lol
19:43:22 <dons> you're all alone on the (.) issue in lambdbot, now, Cale. hint hint
19:43:24 <NameAlreadyInUse> an IDE would be nice, while i am learning
19:43:31 <vixey> I like . = fmap
19:43:37 <Cale> dons: I disagree, there are others who like it :)
19:43:40 <vixey> I'm no one though
19:43:45 <monochrom> I like (.) = fmap.
19:44:03 <dons> for the programs you write in irc?
19:44:10 * gwern pulls from lambdabot 
19:44:14 <gwern> excellent
19:44:30 <awesame> (.) = fmap helped me understand some important things about haskell, with Cale's help
19:44:37 <Cale> gwern: It's unbuildable until byorgey gets those patches into oeis though.
19:44:41 <monochrom> I like (.) = fmap for everything.
19:45:05 <gwern> Cale: yeah, but that'll happen as asoon as he gets his password
19:45:19 <gwern> and honestly, how many people are going to try to pull and build between now and then?
19:45:21 <dons> i'll reiterate how annoying and pointless it is to use super-haskell in here, when no newbie can actually run those programs on their own.
19:45:21 <vixey> can I repeat myself since there's people around now...
19:45:46 <vixey> Does anybody know of some examples of deriving a parser and unparser simultaneously?
19:46:10 <ddarius> Yes.
19:46:25 <ddarius> Hinze (I think) derives LR parses by inverting a pretty printer.
19:46:28 <monochrom> > fmap sin arcsin 0
19:46:29 <lambdabot>   Not in scope: `arcsin'
19:46:34 <monochrom> > fmap sin asin 0
19:46:35 <lambdabot>  0.0
19:46:40 <monochrom> You can still do that.
19:46:46 <ddarius> There are other libraries for combinatorial combining parsers and unparsers.
19:46:52 <sjanssen> (.) = fmap isn't even the best abstraction, IMO
19:47:04 <Cale> sjanssen: hm?
19:47:12 <ddarius> http://www.informatik.uni-bonn.de/~ralf/publications/TypedLR.pdf
19:47:15 <sjanssen> Cale: I prefer Control.Category
19:47:28 <Cale> sjanssen: But there are fewer instances for Control.Category
19:47:55 <vixey> coool ddarius thanks
19:48:16 <ddarius> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
19:48:20 <Cale> sjanssen: My argument against stealing (.) for Control.Category is that functor application is common, whereas composition in a category enriched over Hask isn't as common.
19:48:36 <sclv> oh right, picklers all in general follow that principle, no?
19:48:47 <Cale> (and common things should get the best syntax)
19:49:13 <sclv> Cale: except that if we want to standardize on FRefs (which I think we should) then it will be, at least for a limited case, common.
19:49:23 <ddarius> vixey: The language now known as Boomerang is presumably also relevant.
19:49:47 <vixey> I looked at boomerang but I couldn't really see how to apply the ideasa
19:50:43 <monochrom> Newbies of C++ do not mind << being both bit shift and output. Newbies of Haskell should not mind . being both composition and fmap, which is actually less dissonant than the << example of C++.
19:51:06 <Cale> monochrom: especially as it has a coherent and satisfying explanation behind it
19:51:07 <sclv> hxt users pickler combinators, no?
19:51:36 <Cale> (whereas there's no connection between bitshifting and output in the C++ example)
19:52:19 <monochrom> Everyone already embraces operator overloading from their C++, Python, Ruby, ... backgrounds before coming to Haskell. Their a priori knowledge should be capitalized on, not suppressed.
19:52:40 <hpaste>  morrow pasted "towards hm unification" at http://hpaste.org/8222
19:53:13 <sclv> but cale, seriously, don't you want a lightweight syntax for frefs?
19:53:37 <Cale> I've never used FRefs myself.
19:53:59 <dolio> What's the ref syntax?
19:54:01 <noecksit> is there a way to call functions of an instance of a class without manually having to typecast it?
19:54:12 <Cale> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details -- I assume we're talking about this
19:54:13 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
19:54:15 <sjanssen> Cale: my line of thinking is that (.) is, first and foremost, the function composition operator.  Category has more to do with composition than Functor does
19:54:53 <Cale> sjanssen: Well, we don't quite adopt mathematical syntax all the time :)
19:55:11 <vixey> mmorow: Are you implementing hoogle 3 or something? (or what's this for?)
19:55:13 <Cale> I wouldn't mind using (<<<) and (>>>) for Control.Category
19:55:53 <sclv> Cale, yeah, that and related. i'd really like to see FRefs become part of standard records, and it would be very nice to keep the . for composition of them.
19:55:59 <dolio> The thing about having (.) and (<<<) is that they're both useful.
19:56:02 <dolio> Due to fixity differences.
19:56:04 <Cale> It is possible to do both generalisations at once, however, the typeclasses get a bit fancier.
19:56:08 <sclv> since it also resembles oo syntax so nicely.
19:56:09 <sjanssen> (also, I note that the mere fact that this is controversial is a good argument against changing it in lambdabot without the blessing of a standardization process)
19:56:23 <noecksit> since my class definition is "Class MyClass a where .." and my instance is "instance MyClass MyInstance where .."
19:56:42 * Cale doesn't care much for standards :)
19:56:45 <dolio> At least, when you're working in the function arrow.
19:57:00 <sclv> cale: you sure you wouldn't end up with some incoherent instances if you tried to do both at once?
19:57:05 <noecksit> when i have a function inside the instance and I need to call it, i always need to typecast it "function :: MyInstance"
19:57:20 <Cale> In fact, I'm actually pretty sure that I agree with the idea of moving the libraries completely out of the Haskell standard.
19:57:28 <dolio> I suppose if they were both category combinators, they'd be useful in general categories (however often that comes up).
19:57:38 <sjanssen> Cale: I think that is abundantly stupid
19:57:40 <gwern> oh no, does that mean we'd go down the scheme road?
19:57:40 <Cale> sclv: You have to generalise the Functor class.
19:57:51 <gubagem> scheme major lacks some nice libraries
19:57:52 <noecksit> i understand why thats happening, it doesnt know the the instance is in fact part of the class, but i was wondering if there was a way to do it without it
19:57:52 <vixey> what do would the haskell standard be..?
19:58:01 <Cale> sjanssen: It depends on what your goals are :)
19:58:06 * sclv isn't sure what it means to generalise functor
19:58:25 <sjanssen> Cale: #ifdef GHC_PRELUDE ... #ifdef HUGS_PRELUDE ... #ifdef GHC_NEW_PRELUDE -- imagine these lines in every program you ever write
19:58:30 <gubagem> r6rs is supposed to include a module system and bit level operations (for scheme) so even they are started to see the light of day with needing some basic libraries
19:58:39 <Cale> sjanssen: I'd be happy writing programs just for GHC
19:58:42 <dolio> Are refs a category? I guess they are.
19:58:58 <Cale> sjanssen: after all, it's basically what most people are doing right now
19:59:01 <mmorrow> vixey: learning hm unification by implementing it, just building infrastructure so far
19:59:04 <vixey> Cale: What would you leave in if you were writing a haskell standard?
19:59:07 <sclv> noecksit: not sure exactly what you're saying. paste?
19:59:24 <Cale> vixey: The syntax and semantics of the language itself.
19:59:33 <vixey> mmorrow: oh cool
19:59:40 <sjanssen> Cale: but isn't that a step backwards?  Why eliminate competitors before they even have a chance?
20:00:25 <vixey> sjanssen: you don't have #ifdef... You just have import MyPrelude
20:00:29 <ddarius> Cale: If you are writing just for GHC, what do you need a standard for?
20:00:45 <vixey> MyPrelude is a different library (or it could even be the exact same code if it's pure haskell) for each implementation
20:00:45 <Cale> sjanssen: Well, ideally, things would be standardised enough that the various available base packages would be portable.
20:00:58 <monochrom> You need standard for slowly eliminating it.
20:01:30 <sjanssen> vixey: where MyPrelude is full of ifdefs?  Or do you recommend that it contains an implementation of every function your particular project needs?
20:01:36 <Cale> sjanssen: But the contents of those packages would not be standardised.
20:02:05 <mmorrow> vixey: :)
20:02:15 <hpaste>  noecksit pasted "class ques" at http://hpaste.org/8223
20:03:17 <vixey> noecksit: wouldn't you rather.. type Square = (Int,Int) ?
20:03:44 <Cale> That's going to be one hell of a datatype to pattern match against.
20:03:51 <noecksit> i want to call "emtpyBoard 1" but I can't do that since it says that it has Ambiguos type variables, so i need to do "emtpyBoard 1 :: Board"
20:04:15 <Cale> noecksit: Well, of course.
20:04:21 <sclv> noecksit: ah, gotcha. you'll need to specify which instance eventually somewhere.
20:04:28 <noecksit> well, i wanted to use Map so I can easily find pieces
20:04:29 <gubagem> you arent trying to make a competitive chess engine, are you?
20:04:33 <Cale> noecksit: There's no way that it can tell from emptyBoard 1 what type of thing you want.
20:04:44 <Cale> This is clearly Go.
20:04:56 <Cale> :)
20:05:01 <sclv> but if you perform ops on the returned board that aren't agnostic on the specific instance, then that might eventually happen "for free"
20:05:01 <gubagem> oh my so it is
20:05:07 <dolio> Were you tipped off by "GoBoard"? :)
20:05:10 <joed> dibblego: We all are atheist in one culture or another some are just one god ahead. - From where?
20:05:16 * gubagem hides in the corner
20:05:19 <noecksit> its chessguys modified code actually
20:05:23 <Cale> dolio: I was initially tipped off by T19
20:05:26 <edwardk> @type \f g -> curry (f . (uncurry g))
20:05:27 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b -> c1) -> a -> b -> c
20:05:37 <awesame> hm, why does importing Control.Applicative, even qualified, seem to make (.) = fmap work?
20:05:46 <sclv> my advice is to leave in the typesig for now and eventually you might not need it...
20:06:03 <Cale> awesame: becaue you get the appropriate instance, I suppose.
20:06:10 <awesame> if I don't import it, and then define (.) = fmap, I get an error trying to use it
20:06:16 <noecksit> Cale: ah ok, so i need to typecast it every time, that sux
20:06:33 <awesame> I didn't realize that qualified imports could pull in instances in a way that works unqualified
20:06:39 <Cale> awesame: Right, because you need an instance of Functor for ((->) e)
20:06:47 <awesame> that makes sense
20:06:49 <sclv> awesame: right, you need the instance of unwrapped reader that eventually comes from Control.Monad.Reader
20:07:04 <Cale> Instances are always exported, and they're always imported from any modules you import, qualified or not.
20:07:12 <Zao> Argh. I've wasted an hour writing a string permuter when all I needed was a string rotater.
20:07:14 <sclv> instances are viral, once there's one in anything your tree of imports touches, its in your code.
20:07:16 <Zao> Now I feel silly.
20:08:02 <Cale> Since instances don't have names, qualified imports can't possibly make a difference.
20:08:06 <awesame> what happens if two modules define the same instance two different ways?
20:08:15 <Cale> awesame: You get a compile error.
20:08:26 <vixey> > iterate (liftM2 (++) (drop 1) (take 1)) "whirl"
20:08:28 <lambdabot>  ["whirl","hirlw","irlwh","rlwhi","lwhir","whirl","hirlw","irlwh","rlwhi","lw...
20:08:52 <dolio> No, that should only be if you import two conflicting instances.
20:08:59 <Cale> right.
20:09:01 <dolio> Not the same instance two ways.
20:09:03 <noecksit> sclv: thats the first time ive seen the word agnostic in a non-religious context
20:09:08 <Cale> er...
20:09:32 <Cale> dolio: It can't prove that the two instances are equivalent
20:09:36 <awesame> dolio: wait, what's the difference?
20:09:55 <dolio> I thought he meant 'A -> B -> D and A -> C -> D'.
20:10:07 <awesame> an instance includes a function definition, so it seems like any two instances potentially define different functions...
20:10:11 <dolio> Instance in A, imported through B and C.
20:10:23 <gwern> @seen malcolmw
20:10:23 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 5d 10h 1m 49s ago, and .
20:10:26 <sclv> if you have the same instance declared in two places than errortime, if you have the same instance imported through different routes, 'sall good
20:10:27 <awesame> oh, I see
20:10:28 <Cale> Oh, yeah, that's not a problem. I don't think that's what he meant though.
20:10:53 <dolio> Ah.
20:11:04 <awesame> yeah I meant "two different ways" as in "two different definitions making the same type and instance of a given class"
20:11:20 <awesame> s/and/an/
20:11:24 <gwern> @ask malcolmw hey, does the hackage version of haxml work with the latest hackage version of bytestring? I think I ran into an issue with join or intercalate no longer being defined under that name
20:11:25 <lambdabot> Consider it noted.
20:11:34 <sclv> although with a suitable degree of ugly flags -incoherent-instances and the like, you can defer the error to runtime.
20:11:59 <dolio> It won't actually complain unless you use the class directly, either.
20:12:10 <awesame> that behavior is suprising
20:12:25 <Cale> awesame: Why?
20:12:30 <awesame> I guess it's not often a problem
20:12:53 <dolio> If A and B have instances for the same type, and use their own instance, then importing A and B into D, then it won't complain if you call functions that internally use A and B instances.
20:13:12 <Cale> If you need to define an instance in more than one way, you should newtype the datatype that you're using, and use the newtypes to select the instance.
20:13:18 <awesame> I expected "import qualified" to protect me from and behavior changes that weren't introduced by some kind of qualified identifier
20:13:42 <awesame> right, the newtype idea makes sense
20:13:46 <sclv> you can't control instances though -- no way to specify which you want.
20:13:56 <Cale> Ah, but that's the thing, the way that typeclasses work makes it impossible for the behaviour to actually change.
20:14:07 <Cale> If the program compiles, it'll run the same way.
20:14:10 <awesame> but still, I could have problems if I were using two libraries that both set up an instance, even ones with indentical behavior
20:14:13 <awesame> right?
20:14:16 <Cale> right.
20:14:27 <Cale> So you have to be careful where instances get defined.
20:15:49 <awesame> that's an interesting point that runtime behavior can't actually change
20:16:07 <awesame> I was surprised that compile-time behavior changed, but that's not so bad
20:21:27 <sjanssen> awesame: a good rule is to always write your instances in one of two places: in the module where the type is defined, or the module where the class is defined
20:25:28 <Cale> (or in a separate module just for instances)
20:27:03 <sjanssen> Cale: I think those can cause problems
20:28:13 <sjanssen> it is best to catch clashing instances as soon as possible -- and the best way to make sure of that is to guarantee that the instance is in scope when the class and the type are in scope
20:28:14 <ddarius> Isn't the crucial rule, not to define instances of other people's classes for other people's types (where the "other people" may or may not be two different parties)
20:28:46 <SamB> which is a really nasty restriction...
20:29:02 <ddarius> (At least for library code; for application code do what you will)
20:29:25 <SamB> well, you might want to libraryize the instances themselves...
20:29:39 <SamB> just being careful to isolate them from anything else
20:30:26 <geezusfreeek> edwardk: ping?
20:30:37 <ddarius> To be safest taking that approach, you'd have to put each instance into it's own module.
20:30:43 * gwern sends Cale a patch removing some dead code in lambdabot 
20:31:09 <sjanssen> gwern: do you have a code.h.o account?
20:31:56 <geezusfreeek> ah nevermind
20:39:32 <augur> does haskell have a reverse let, where like... (f x where x = 5) instead of (let x = 5 in f x)?
20:40:04 <dobblego> augur, 'where'
20:40:05 <dmwit> yes
20:40:08 <augur> hahaha :)
20:40:10 <dmwit> You even wrote it correctly.
20:40:37 <augur> <3haskell
20:40:42 <augur> its intuitive :D
20:40:54 <augur> are there advantages of one over the other or is it just stylistics?
20:41:12 <hpaste>  dogdrool pasted "function to find all "straights" in a list of cards" at http://hpaste.org/8225
20:41:26 <dmwit> augur: Let clauses can appear in do blocks.
20:41:36 <augur> ah
20:41:39 <dogbite> hello.  can anybody suggest a better way to find all "straights"
20:41:48 <dogbite> ignore cards -- can talk about it as a list of integers
20:41:50 <augur> dont go to a gay bar, i'd imagine
20:41:54 <dogbite> it's like run length encoding
20:42:02 <dogbite> but not
20:42:41 <sjanssen> augur: where bindings scope over guards
20:42:42 <dogbite> that function i wrote is atrocious
20:42:48 <augur> i see
20:43:04 <dmwit> > map (take 4) . tails . nub . sort $ [1,3,5,6,7,8]
20:43:05 <lambdabot>  [[1,3,5,6],[3,5,6,7],[5,6,7,8],[6,7,8],[7,8],[8],[]]
20:43:13 <dogbite> augur: oh i got it!
20:43:25 <dogbite> augur: i assumed i missed some thread, ha
20:43:26 <dmwit> > takeWhile ((== 4) . length) . map (take 4) . tails . nub . sort $ [1,3,5,6,7,8]
20:43:27 <lambdabot>  [[1,3,5,6],[3,5,6,7],[5,6,7,8]]
20:44:11 <dmwit> dogbite: Can you give a sample input/output pair?
20:44:22 <dogbite> okay
20:45:07 <gwern> sjanssen: I may. I may not. I forget
20:45:14 <gwern> 'night everyone
20:45:21 <dogbite> if the input were [1,2,3] the output would be
20:45:36 <dogbite> [(3,3), (2,2), (1,1)]
20:45:46 <dmwit> > span (\(x, y) -> y == succ x) . ap zip tail $ [1,2,3]
20:45:48 <lambdabot>  ([(1,2),(2,3)],[])
20:46:00 <sjanssen> gwern: we give you commit access to lambdabot if you do
20:46:01 <dogbite> if it were [1,2,4] we would have [(4,1),(2,2),(1,1)]
20:46:07 <sjanssen> erm, we can
20:46:16 <dmwit> dogbite: Okay.
20:46:53 <dogbite> @type span
20:46:55 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:47:05 <dmwit> dogbite: You wouldn't want it to be just [(4, 1), (2, 2)]?
20:48:12 <dogbite> dwit: well, i don't care too strongly
20:48:37 <dogbite> dwit: my main goal is just to find the best straight -- so i was finding all of them and then doing a maximumBy
20:49:13 <dmwit> > let f = ((fst . last) &&& length) . fst . span (\(x, y) -> y == succ x) . ap zip tail in f [1..3]
20:49:14 <lambdabot>  (2,2)
20:49:25 <dmwit> > let f = ((fst . last) &&& length) . fst . span (\(x, y) -> y == succ x) . ap zip tail in f [2,4]
20:49:26 <lambdabot>  (Exception: Prelude.last: empty list
20:50:19 <dogbite> dmwit: sorry was spelling your name wrong!
20:50:24 <dmwit> 'sok
20:52:09 <dmwit> > let ensure p x = guard (p x) >> return x; f xs = do { a <- tails xs; let x = fst . span (\(x, y) -> y == succ x) . ap zip tail $ a; ensure (not . null) (((fst . last) &&& length) x) in f [1..3]
20:52:09 <lambdabot>  Parse error at "in" (column 183)
20:52:27 <dmwit> > let ensure p x = guard (p x) >> return x; f xs = do { a <- tails xs; x <- return . fst . span (\(x, y) -> y == succ x) . ap zip tail $ a; ensure (not . null) (((fst . last) &&& length) x) in f [1..3]
20:52:27 <lambdabot>  Parse error at "in" (column 189)
20:52:38 <dogbite> dmwit: that is an absolute beast you're composing there. haha.
20:52:44 <dmwit> > let ensure p x = guard (p x) >> return x; f xs = do { a <- tails xs; x <- return . fst . span (\(x, y) -> y == succ x) . ap zip tail $ a; ensure (not . null) (((fst . last) &&& length) x)} in f [1..3]
20:52:46 <lambdabot>  Couldn't match expected type `[a]'
20:52:48 <dmwit> bah
20:55:49 <dmwit> It's a bad approach.
20:56:07 <dmwit> Workable, but awkward.
20:56:10 <dmwit> Let's see...
20:56:44 <dogbite> frankly, i can't understand it at all, but i'm a novice so don't let that deter you
20:59:31 <dmwit> ?let isRun = all (\(x, y) -> y == succ x) . ap zip tail
20:59:32 <lambdabot> <local>:7:29:     Ambiguous type variable `b' in the constraints:       `Enum...
20:59:43 <gubagem> im gonna guess my present program wont compile.mmmmmmmm
20:59:51 <dmwit> ?let isRun = all (\(x, y) -> y == succ x) . ap zip tail :: (Enum a, Eq a) => [a] -> Bool
20:59:51 <lambdabot> Ambiguous type variable `a' in the constraints
21:00:15 <dmwit> lambdabot: Give me my polymorphism!
21:00:17 <dolio> Monomorphism restriction.
21:00:26 <dmwit> But I have a type signature!
21:00:37 <dolio> Not for isRun.
21:00:39 <dmwit> ?let isRun xs = all (\(x, y) -> y == succ x) . ap zip tail $ xs
21:00:40 <lambdabot> Defined.
21:00:43 <dmwit> fine
21:01:05 <dmwit> ?let subsequences xs = tails xs >>= inits
21:01:06 <lambdabot> Defined.
21:01:15 <dolio> @let idL :: [a] -> [a] ; idL = foldr (:) []
21:01:16 <lambdabot> Defined.
21:01:20 <dolio> @type idL
21:01:22 <lambdabot> forall a. [a] -> [a]
21:01:27 <dmwit> > map (last &&& length) . filter (not . null) . filter isRun . sequences $ [1..3]
21:01:28 <lambdabot>   Not in scope: `sequences'
21:01:33 <dmwit> > map (last &&& length) . filter (not . null) . filter isRun . subsequences $ [1..3]
21:01:34 <lambdabot>  [(1,1),(2,2),(3,3),(2,1),(3,2),(3,1)]
21:01:42 <dmwit> dogbite: ?
21:01:48 <dogbite> i'm here
21:01:53 <dmwit> > map (last &&& length) . filter (not . null) . filter isRun . subsequences $ [1..3] ++ [5..7]
21:01:55 <lambdabot>  [(1,1),(2,2),(3,3),(2,1),(3,2),(3,1),(5,1),(6,2),(7,3),(6,1),(7,2),(7,1)]
21:01:55 <dogbite> trying to follow along
21:02:37 <dmwit> dogbite: Let's start with isRun.
21:02:45 <dogbite> dmwit: okay
21:02:59 <dmwit> isRun :: (Enum a, Eq a) => [a] -> Bool
21:03:11 <dmwit> Tests whether a list is of the form [a, succ a..b]
21:03:18 <dmwit> To do that:
21:03:27 <dmwit> It first forms the list of pairs of adjacent guys in the list.
21:03:32 <dmwit> That's the "ap zip tail" bit:
21:03:37 <dmwit> > ap zip tail [1..5]
21:03:38 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
21:03:47 <dogbite> what's 'ap'?
21:03:53 <dogbite> is that ($)
21:03:54 <dogbite> ?
21:03:57 <dmwit> It's just a handy shorthand.
21:04:00 <dmwit> It's the S combinator.
21:04:04 <dmwit> :t ap
21:04:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:04:10 <rms> :S
21:04:15 <dogbite> okay got it
21:04:38 <dogbite> okay i have isRun
21:04:41 <Cale> When m = ((->) e), you have  (e -> a -> b) -> (e -> a) -> e -> b
21:04:42 <dmwit> good
21:05:05 <dmwit> Now, subsequences :: [a] -> [[a]] pulls out all the sequences from a list.
21:05:09 <dmwit> > subsequences [1..3]
21:05:10 <lambdabot>  [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
21:05:29 <dogbite> it's like a list comprehension?
21:05:40 <dmwit> Yep, it could be written as a comprehension like this:
21:06:01 <dmwit> subsequences xs = [middles | ends <- tails xs, middles <- inits ends]
21:06:40 <dogbite> dmwit: okay... i basically understand that.
21:06:48 <dogbite> we can move on
21:06:48 <dmwit> It takes each possible start point and each possible end point in the list.  Then it forms the sublist for that start and end point.
21:06:57 <dmwit> ok
21:07:17 <dmwit> Now, we take the non-null runs from the list of subsequences.
21:07:25 <dmwit> Those are the "straights".
21:07:33 <dmwit> The last step is to characterize the straight.
21:07:49 <dmwit> (last &&& length) :: [a] -> (a, Int)
21:08:04 <dmwit> > (last &&& length) [1..5]
21:08:05 <lambdabot>  (5,5)
21:08:09 <dmwit> Well, bad example.
21:08:17 <dmwit> > (last &&& length) [1,5]
21:08:18 <lambdabot>  (5,2)
21:08:31 <dogbite> hmm
21:08:37 <dmwit> (&&&) takes two functions and returns their results in a tuple.  (In the function Arrow.)
21:08:56 <dogbite> k
21:08:59 <dmwit> So it applies "last" to [1,5], returning 5, and applies "length" to [1,5], returning 2.
21:09:06 <dogbite> i know that one from the run length encoding meme
21:09:10 <dmwit> right
21:09:26 <dmwit> So, the high-level strategy is:
21:09:31 <dogbite> okay so i have isRun
21:09:31 <dmwit> * take all the possible sublists
21:09:37 <dmwit> * filter out the uninteresting ones
21:09:40 <dogbite> i have the middles
21:09:42 <dmwit> * characterize what's left
21:09:56 <dogbite> got it
21:10:14 <dmwit> Horribly inefficient, but it's kind of pretty. =)
21:10:27 <dogbite> idL
21:10:31 <dogbite> what does that stand for
21:10:50 <dmwit> idL is the identity on lists.
21:10:55 <dmwit> It's totally unrelated.
21:11:05 <dogbite> got it.  well that is pretty sweet.
21:11:08 <dmwit> Well, not totally.
21:11:15 <dmwit> I think dolio was trying to make a point about the MR.
21:11:18 <dmwit> But whatever.
21:11:28 <dogbite> regarding the efficiency -- i had an earlier definition
21:11:35 <dogbite> and it wasn't too efficient
21:11:44 <dogbite> showed up as the top function in the profiler
21:12:03 <dmwit> Oh, is this in a critical path?
21:12:03 <dogbite> which caused me to dive back in ... i think the one i wrote
21:12:03 <dogbite> is strong in terms of efficiency
21:12:06 <dmwit> Okay, you might want something more clever, then.
21:12:10 <dogbite> well i'm testing zillions of hands
21:12:16 <dolio> Huh? My main point was that you can stick a top level type declaration in @let with a semicolon.
21:12:19 <dmwit> Okay.  Let's be more clever.
21:12:38 <dmwit> dolio: Oh, that's convenient.
21:12:45 <dolio> Or you can bug Cale to turn on -XNoMonomorphismRestriction or something.
21:13:47 <dogbite> dmwit: what's the main weakness besides ugliness in the function i have?
21:14:07 <dmwit> dogbite: Is it weak, other than ugliness?
21:14:23 <dmwit> If rank is a cheap function call, I don't think it's anything other than ugliness.
21:14:25 <dogbite> dmwit: weak?
21:14:44 <dmwit> dogbite: your word, not mine
21:14:48 <dogbite> dmwit: rank is an accessor function from my datatype
21:14:59 <dmwit> Pretty cheap then, yeah.
21:15:44 <dogbite> okay.  well i'm going to sleep on the solution you came up with.  i like it a lot.
21:16:01 <dmwit> dogbite: Give me another chance, I have an idea for a much more efficient version. =)
21:16:14 <dmwit> Your thing is basically a fold, which is nice.
21:16:17 <dogbite> dmwit: okay, shoot
21:16:25 <dmwit> I'm playing in GHCi first. =)
21:17:09 <dogbite> dmwit: okay i might drift off -- haskell keeps me up late!
21:20:16 <dmwit> ?let accum :: Num a => a -> [(a, a)] -> [(a, a)]
21:20:17 <lambdabot> <local>:10:0:     Misplaced type signature:     accum :: (Num a) => a -> [(a,...
21:21:07 <dmwit> ?let accum :: Num a => a -> [(a, a)] -> [(a, a)]; accum m [] = [(1, m)]; accum m ((h, n):ss) = if m == n - h then (h + 1, n):ss else (1, m):(h, n):ss
21:21:08 <lambdabot> Defined.
21:21:18 <dmwit> > foldr accum [] $ [1..4] ++ [7..9]
21:21:19 <lambdabot> Terminated
21:21:21 <dmwit> > foldr accum [] $ [1..4] ++ [7..9]
21:21:22 <lambdabot> Terminated
21:21:24 <dmwit> what
21:21:28 <dmwit> ?undefine
21:21:29 <lambdabot> Undefined.
21:21:59 <dmwit> > let accum m [] = [(1, m)]; accum m ((h, n):ss) = if m == n - h then (h + 1, n):ss else (1, m):(h, n):ss in foldr accum [] $ [1..4] ++ [7..9]
21:22:01 <lambdabot>  [(4,4),(3,9)]
21:22:05 <dmwit> Beautiful!
21:22:26 <dogbite> hmm
21:22:38 <dmwit> It helps to see accum written out in layout.
21:23:09 <dmwit> Actually, not much. =P
21:23:14 <dogbite> ha
21:23:21 <dmwit> The idea of accum is:
21:23:33 <dmwit> Keep a running list of the straights and their lengths.
21:23:44 <dmwit> The first one on the list is the currently "growing" one.
21:23:58 <dogbite> oh i think i get it!
21:24:05 <dmwit> nice!
21:24:12 <dogbite> wow that's pretty tight
21:24:30 <dogbite> i'll give that one a whirl in terms of cards tomorrow
21:24:33 <dmwit> Shorter *and* faster. =)
21:24:37 <dogbite> thanks a lot -- that was fun
21:24:58 <dogbite> and pedantic
21:25:02 <dmwit> heh
21:29:07 <dobblego> ?type guard . not -- is this function in the library?
21:29:09 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:29:44 <dmwit> no
21:30:13 <SamB_XP> what would that be called? bait?
21:30:27 <dmwit> prevent
21:30:39 <dmwit> Not really, though.
21:30:47 <dobblego> unguard?
21:31:03 <Cale> prevent is good.
21:31:13 <SamB_XP> well, my thinking was that the usual reason for specifically leaving something unguarded is if you are using it to bait a trap ;-)
21:33:01 <dmwit> Oooh, "trap" is not bad.
21:34:03 <OceanSpray> I herd type inference and dependent types are incompatible to a degree.
21:34:07 <OceanSpray> What's up with that?
21:34:17 <dmwit> Dependent types are code.
21:34:26 <dmwit> You can't infer code, what's up with that?
21:34:32 <SamB_XP> OceanSpray: well, when your types can be the most complicated part of the program, that tends to happen
21:34:45 <SamB_XP> and you can infer code sometimes
21:34:56 <dmwit> Right, and you can infer dependent types... sometimes.
21:35:00 <dmwit> Just saying.
21:35:09 <OceanSpray> hm
21:35:11 <SamB_XP> yeah
21:35:55 <SamB_XP> and the best part is you don't have to figure out which is which ;-)
21:39:54 <psygnisfive> who was it the other day telling me about functional reactive programming?
21:40:10 <ddarius> I'm not sure, but conal is the person you'd want to talk to.
21:40:23 <psygnisfive> yes! thats him
21:40:40 <psygnisfive> bastard isnt here :(
21:40:49 <psygnisfive> well, anyone else know about reactive programming?
21:41:10 <dmwit> Maybe try asking your question.
21:41:13 <SamB_XP> you'd best just either read some stuff on his website or wait for him to show up ;-)
21:41:35 <OceanSpray> I keep searching for the Holy Grail, but all I find is elusion.
21:41:37 <dmwit> If it's something we can answer, we will; otherwise, yeah, wait for the expert. =)
21:41:57 <dmwit> OceanSpray: You probably want "illusion" in that spot.
21:42:20 <psygnisfive> dmwit: no question, just wanna talk. :)
21:42:38 <geezusfreeek> :t (<*>)
21:42:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:42:41 <OceanSpray> Really?
21:42:41 <OceanSpray> Tell me,
21:43:05 <OceanSpray> do you know of a language with Lisp's metaprogramming, Coq's dependent types, and Haskell's pure laziness?
21:43:31 <OceanSpray> Its apparition haunts my dreams.
21:43:45 <OceanSpray> Its absence is my nightmare.
21:43:47 <SamB_XP> OceanSpray: what does it look like?
21:43:51 <geezusfreeek> anything that is a Monad is also Applicative. is there an equivalent for comonads?
21:44:01 <OceanSpray> Lots of Insipid Stupid Parentheses.
21:44:06 <geezusfreeek> i believe it has been brought up before
21:44:08 <OceanSpray> That's what it looks like.
21:45:34 <thetallguy> any cabal-install experts around?
21:45:44 <geezusfreeek> not expert, but i use it
21:45:59 <thetallguy> Ever see a funny entry in 'cabal list'?
21:46:02 <thetallguy> Hexdump, Support for Word128, Word192 and Word256 and Beyond, PKCS5
21:46:02 <thetallguy> Padding, Various Encryption Modes e.g. Cipher Block Chaining all in one package.
21:46:48 <thetallguy> That shows up in the middle of the output.  Hexdump doesn't appear in the hackage tar index in my .cabal directory
21:47:00 <thetallguy> Any speculation on where it might have come from?
21:47:08 <geezusfreeek> hmm
21:47:32 <dons> thetallguy: hmm. from the crypto package
21:47:39 <dons> those Word* types are in crypto
21:48:11 <thetallguy> oh, I see, it's wrapping
21:48:24 <thetallguy> Crypto [3.0.3, 4.1.0]              DES, Blowfish, AES, TEA, SHA1, MD5, RSA, BubbleBabble,
21:48:24 <thetallguy> Hexdump, Support for Word128, Word192 and Word256 and Beyond, PKCS5
21:48:24 <thetallguy> Padding, Various Encryption Modes e.g. Cipher Block Chaining all in one package.
21:48:30 <geezusfreeek> or there is a newline in there
21:48:41 <geezusfreeek> or two
21:48:46 <thetallguy> Does printf insert newlines?
21:49:30 <geezusfreeek> Synopsis:        DES, Blowfish, AES, TEA, SHA1, MD5, RSA, BubbleBabble,
21:49:31 <geezusfreeek>                  Hexdump, Support for Word128, Word192 and Word256 and Beyond, PKCS5
21:49:31 <geezusfreeek>                  Padding, Various Encryption Modes e.g. Cipher Block Chaining all in one package.
21:49:45 <geezusfreeek> apparently cabal-install is not killing the newlines
21:49:56 <monochrom> printf doesn't insert newlines unless you make \n explicit
21:50:00 <thetallguy>     putStrLn
21:50:00 <thetallguy>       . unlines
21:50:00 <thetallguy>       . map (showPkgVersions . map (packageDescription . pkgDesc))
21:50:00 <thetallguy>       . groupBy sameName
21:50:00 <thetallguy>       . sortBy (comparing nameAndVersion)
21:50:39 <thetallguy> geezusfreeek: ah, very good.  It's in the source file.
21:51:13 <geezusfreeek> it would be nice if it did kill the newlines
21:51:18 <geezusfreeek> more grepable and understandable
21:51:30 <thetallguy> I've had it with ad-hoc formatting
22:10:24 <ivanm> are what this guy says about functional languages right? http://www.atalasoft.com/cs/blogs/rickm/archive/2008/06/06/why-are-our-programs-still-represented-by-flat-files.aspx
22:10:25 <lambdabot> Title: Rick Minerich's Development Wonderland : Why Are Our Programs Still Represented  ..., http://tinyurl.com/6rydx5
22:10:38 <ivanm> (in the first few paragraphs)
22:11:09 <dons> no?
22:12:14 <ivanm> it sounds wrong to me...
22:13:17 <cjb> I'd agree that Haskell has "very little structure built in" to modules.
22:13:30 <cjb> but the rest seems kind of krak.
22:13:48 <ivanm> yes, they're more organisational units to group similar functions together (and hide helper functions)
22:14:42 <dons> algebraic data types, type classes, monads. abstractions and structure is all we have.
22:14:43 <cjb> The post asserts that we're storing code in files because we always have, and then mumbles about a database, and then finishes.
22:15:26 <ivanm> yeah
22:16:03 <thetallguy> I agree with him.
22:16:13 <ivanm> the only time I have problems with writing code in files is when I'm working on the function level and shifting code blocks around, etc.
22:16:27 <thetallguy> We do lots of inefficient things because we always have.
22:16:29 <cjb> For it to be interesting, you'd need to specify *what* advantages using a database is supposed to confer.  And then you write a patch that shows it off.
22:16:59 <cjb> thetallguy: then propose something better, don't just say "hey, look, we type on keyboards, but that's only because we always have!"
22:17:00 <ivanm> biggest advantage of flat files: you can code on them _anywhere_, even on a system that doesn't have the language installed
22:17:15 <ivanm> even write the code on a typewriter and then use OCR to scan it in :p
22:17:17 <thetallguy> cjb: no, that's what would be needed to make a good presentation of his argument. ;-)
22:17:30 <thetallguy> Doesn't mean it isn't interesting. ;-)
22:17:44 <thetallguy> cjb: I have and I continue to work on it.
22:17:51 <ivanm> cjb: I thought we still typed on keyboards because typing on mice doesn't seem to work... :p
22:18:04 <ddarius> cjb: The ML family has a rich module system.
22:18:05 <cjb> ivanm: I type on my mouse every day.  :)
22:18:12 <cjb> (multitouch Touchstream keyboard)
22:18:13 <ddarius> Alice ML in particular
22:18:29 <thetallguy> cjb: unfortunate example.  I happen to think keyboards are highly efficient.
22:18:31 <ivanm> cjb: oh? never heard of it...
22:18:34 <ivanm> link?
22:18:38 <ddarius> @google "Source Code in Database"
22:18:40 <lambdabot> http://en.wikipedia.org/wiki/Source_Code_in_Database
22:19:12 <cjb> ivanm: http://www.extremetech.com/article2/0,1697,1039254,00.asp
22:19:15 <lambdabot> Title: Keyboard Kraziness & Mouse Madness - Review: Typing With Gestures on the TouchSt ...
22:19:20 <Heffalump> Intentional Programming had its own format for storing source
22:19:26 <ddarius> http://mindprod.com/project/scid.html
22:19:27 <lambdabot> Title: SCID
22:19:46 <ddarius> This idea has come up again and again throughout the history of CS.
22:22:08 <ivanm> cjb: from the looks of it, I think it'd be more correct that you move the cursor using your keyboard :p
22:23:55 <cjb> ivanm: yeah :)
22:24:12 <cjb> but when the same surface is both, am I typing on my mouse or pointing on my keyboard?
22:24:32 <ivanm> heh
22:24:40 <ivanm> well, it has a picture of a keyboard on it
22:24:44 <ivanm> ergo, it's a keyboard :p
22:24:53 <ivanm> http://theunixgeek.blogspot.com/2008/06/programming-salaries.html <-- Haskell is worth the least of all langs? :o
22:24:54 <lambdabot> Title: The Unix Geek: Programming Salaries
22:26:08 <psygnisfive> its not worth the least
22:26:13 <psygnisfive> you probably have the highest salaries
22:26:29 <ivanm> it's average apparently...
22:26:30 <psygnisfive> but because haskell programs are so much smaller and more efficient, you only spend a fraction of the time coding it
22:26:39 <psygnisfive> so your yearly salary is less :p
22:26:48 <psygnisfive> but hourly its more!
22:26:48 <ivanm> lol.... $/SLOC? :p
22:26:49 <psygnisfive> ;P
22:27:09 <dons> the salary details are incorrect on that page
22:27:14 <psygnisfive> :P
22:27:15 <dons> haskell is a boutique language like erlang.
22:27:29 <dons> however, 'haskell city' messes up the search results
22:27:33 <ivanm> well, erlang's is rather high...
22:27:34 <ivanm> ahhh
22:27:35 <psygnisfive> and yet erlangers get 99k
22:27:49 <psygnisfive> HAH! that explains it
22:27:51 <psygnisfive> haskell city
22:27:51 <psygnisfive> lol
22:27:54 <dons> try searching for 'haskell programmer'
22:27:55 <dons>  http://www.indeed.com/salary?q1=haskell+programmer&l1=&tm=1
22:27:56 <lambdabot> Title: haskell programmer Salaries - Free Salary Search
22:28:09 <dons> which is more typical, from what i hear.
22:28:20 <ivanm> I figured haskell would be higher cos of its usage in the finance market with galois, etc.
22:28:33 <ivanm> and don't financial houses pay rather well?
22:29:11 <dons> hopefully he updates the page, since this question has come up several times.
22:29:14 <psygnisfive> nevermind all those haskell co. results
22:29:18 <roconnor> I want a 198K job!
22:29:25 <ivanm> roconnor: don't we all?
22:29:33 <dons> it's kind of obvious haskell wouldn't be the cheapest skill set around.
22:29:46 <ivanm> roconnor: how bout going somewhere like Japan, where the value of an individual unit of currency is rather low?
22:30:14 <geezusfreeek> i want a haskell job
22:30:21 <geezusfreeek> i don't even care if it's so great paying
22:30:40 <psygnisfive> ivanm: well, you might as well say the same about the US then
22:30:49 <psygnisfive> since we have individual currency units that are rather low
22:30:50 <dons> work hard. make sure haskell's more and more viable for more and more tasks. use it whenever you can.
22:30:52 <psygnisfive> i.e. the penny
22:30:56 <ivanm> dons: heh, now I see your comment there :p
22:30:57 <roconnor> haskell only gets 47K
22:31:01 * ivanm didn't bother reading down that far
22:31:07 <shachaf> psygnisfive: And the dollar. :-)
22:31:15 <psygnisfive> :P
22:31:21 <ivanm> psygnisfive: isn't the dollar the standard US currency unit?
22:31:34 <psygnisfive> yeah, but so what?
22:31:46 <ivanm> dons: or did you just post that comment now? :p
22:31:51 <psygnisfive> if we decided tomorrow the standard unit was pennies, that changes nothing
22:32:05 <dons> ivanm, a little while ago
22:32:29 <ivanm> OK, so I wasn't the first to pick that up :p
22:33:04 <ivanm> now, how was I supposed to know that the people in the US love the haskell language so much that they named a town after it? :p
22:33:28 <dons> well, the author of the post didn't think about the numbers much either.
22:33:46 <ivanm> nope
22:33:49 <dons> since it wouldn't take much to realise erlang and haskell are going to be in the same ballpark.
22:33:53 <ivanm> must be a C programmer :p
22:34:02 <dons> i guess neither was in his original list, so he didn't know much about them
22:34:39 <ivanm> looks like Haskell was in the original list, since he didn't say something about adding it later
22:35:30 <dons> no, it wasn't in the original list 2 days ago
22:35:42 <dons> he added it sometime today
22:35:47 <dons> or late yesterday
22:36:03 <ivanm> ahhh
22:36:09 <dons> http://www.indeed.com/salary?q1=haskell+programmer gives a different result
22:36:10 <lambdabot> Title: haskell programmer Salaries - Free Salary Search
22:36:14 <kayess> I think I don't understand the type system. why does the type of the return of sqrt "leak" out? -- filter (\x -> x < sqrt 100) [1..20]
22:36:25 <dons> ah, limiting it to just job titles.
22:36:59 <dons> http://www.reddit.com/info/6mq00/comments/
22:37:00 <lambdabot> Title: reddit.com: The real reason people like programming in Haskell
22:37:08 <shachaf> I was disappointed when most of the talks at LFNW were in the "Haskell" building, but it turned out to be the wrong Haskell.
22:37:12 <dons> there, i'm being a bit cheeky :)
22:37:35 <mmorrow> @pl zipWith (\(t,vs) (t',vs') -> ((t,t'),(vs\\vs',vs'\\vs)))
22:37:36 <lambdabot> (line 1, column 37):
22:37:36 <lambdabot> unexpected ","
22:37:36 <lambdabot> expecting variable, "(", operator or ")"
22:37:44 <mmorrow> @pl \x y zipWith (\(t,vs) (t',vs') -> ((t,t'),(vs\\vs',vs'\\vs))) x y
22:37:44 <lambdabot> (line 1, column 15):
22:37:44 <lambdabot> unexpected "\\"
22:37:44 <lambdabot> expecting pattern
22:37:50 <ivanm> shachaf: lol.... but what does LFNW stand for?
22:37:50 <mmorrow> @pl \x y -> zipWith (\(t,vs) (t',vs') -> ((t,t'),(vs\\vs',vs'\\vs))) x y
22:37:51 <lambdabot> (line 1, column 45):
22:37:51 <lambdabot> unexpected ","
22:37:51 <lambdabot> expecting variable, "(", operator or ")"
22:38:09 <shachaf> ivanm: http://linuxfestnorthwest.org/
22:38:10 <lambdabot> Title: LinuxFest Northwest 2009
22:38:42 <mmorrow> @pl  \(t,vs) (t',vs') -> ((t,t'),(vs\\vs',vs'\\vs))
22:38:43 <lambdabot> (line 1, column 28):
22:38:43 <lambdabot> unexpected ","
22:38:43 <lambdabot> expecting variable, "(", operator or ")"
22:38:44 <obk> shachaf: You sure it is the wrong Haskell?
22:38:54 <mmorrow> @pl  \(t,vs) (t',vs') -> ((t,t'),(vs+vs',vs'+vs))
22:38:55 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ap (ap . ((,) .) . (+)) (+)) . flip . (((.) . (,)) .) . (,))
22:38:55 <shachaf> obk: Yes, I looked.
22:39:01 <ivanm> shachaf: NW USA I presume?
22:39:07 <obk> Who knew there were two of them :-)
22:39:17 <shachaf> It's some "Red" Haskell or other.
22:39:52 <dons> boutique programming languages are fun
22:40:05 <dons> catering to programmers of discriminating taste.
22:40:52 <dons> so who's writing the next killer haskell app?
22:40:59 <dons> byorgey: released any libraries this week?!
22:41:10 <dons> roconnor: 'bout time you uploaded some new stuff to hackage!
22:41:26 <dons> can't let edwardk have all the parazygohistomorphism fun
22:41:41 <dons> how about an isabelle interface, or hook up to one of the ocaml solvers
22:42:01 * thetallguy raises his hand
22:42:03 <dons> more libraries, peoples!!
22:42:07 <thetallguy> ooh ooh ooh!
22:42:20 <dons> go thetallguy !!
22:43:31 <thetallguy> actually, we have about fifty of them.  Pretty soon we're oging to have to choose...
22:43:45 <roconnor> nah, I just sumbit patches to existing code.
22:43:53 <dons> thetallguy: 50 new killer apps?
22:44:01 <roconnor> hm
22:44:16 <thetallguy> 50 candidates for the job...
22:44:19 <roconnor> although I still want to write a Clifford Algebra implemenation.
22:44:30 * dons imagines a grassroots social networking campaign, obama style, to get more haskell libraries written
22:44:33 <dons> thetallguy: oh, goodie!
22:44:42 <ivanm> lol
22:44:46 <roconnor> although I sort of think I ought to use template haskell for that.
22:45:15 <dons> life's short, time for more code!
22:45:24 <thetallguy> if we get 1/50, I'll be happy
22:45:31 <ivanm> dons: yeah, after my exams are done next week I should start work on my honours project... hopefully I'll be able to have a bare-bones enough implementation to release something by friday fortnight
22:45:35 <ivanm> good enough for you? :p
22:45:40 <dons> woot!
22:45:43 * roconnor plans to live for 500 billion years
22:45:45 <thetallguy> by the way, any debian users about?
22:46:09 <thetallguy> roconnor:  amoeba years?
22:46:28 <roconnor> thetallguy: the usual years
22:46:33 <ivanm> thetallguy: he said years, not generations.
22:46:39 <ivanm> mercury years? :p
22:46:50 <roconnor> so many transtions between hyperfine whatever.
22:46:52 <thetallguy> ivanm: ever hear of dog years?
22:46:55 <roconnor> cesium
22:47:03 <thetallguy> Or did I get that inverted?
22:47:15 <ivanm> thetallguy: yes, but that's a load of bunkum
22:47:19 <ivanm> roconnor: I meant mercury the planet
22:47:29 <roconnor> :)
22:47:44 <thetallguy> ivanm: but living to be 500 billion is not?
22:47:54 <ivanm> thetallguy: depends on your baseline.
22:47:57 <roconnor> I meant 500 billion years as expended into SI seconds
22:48:14 <thetallguy> No debian users?
22:48:14 <roconnor> obviously I won't stay here for all those years
22:48:15 <ivanm> roconnor: but which years?
22:48:24 <dmwit> thetallguy: Debian/Ubuntu, what's up?
22:48:31 <thetallguy> you're all BSDer's?
22:48:32 <ivanm> roconnor: here == earth or #haskell?
22:48:36 <dobblego> has anyone written a library that follows the MonadPlus reform proposal?
22:48:38 <thetallguy> Ah, one.
22:48:40 <ivanm> thetallguy: or else other linuxes...
22:48:45 <roconnor> here as in earth
22:48:58 * roconnor plans to live for 1.5778463 √ó 1019 seconds
22:49:02 <thetallguy> David Fox just posted to debian-haskell about some of his recent work on packaging
22:49:05 <ivanm> you're going to colonise another planet, are you?
22:49:05 <roconnor> 10^19
22:49:09 <ivanm> heh
22:49:18 <thetallguy> we've now got a cabal-debian tool
22:49:18 <roconnor> ivanm: not sure yet
22:49:23 <ivanm> using the current definition of "second"
22:49:24 <ivanm> ?
22:49:28 <roconnor> yes
22:51:22 <roconnor> I don't mean this as an upper bound
22:51:22 <thetallguy> and a repository where we've built a whole bunch of cabal packages, all using haddock 2.0...
22:51:22 <ivanm> roconnor: so it it's not earth and not another planet.... live on a spaceship/spacestation?
22:51:22 <dmwit> thetallguy: neat
22:51:22 <ivanm> become a being of pure intelligence ala asimov's entropy story?
22:51:22 <kayess> How do I convert a RealFrac to an integer?
22:51:22 <roconnor> ivanm: I haven't decided yet.
22:51:22 <thetallguy> I'm working on cabal-install to get it to give me all the packages in a repository...
22:51:22 <thetallguy> so pretty soon, we should have all of hackage built for sid and hardy heron...
22:51:22 <ivanm> roconnor: oh, OK
22:51:22 <ivanm> let us know when you do (assuming we're still here, that is)
22:51:35 <Saizan_> kayess: round/floor/ceiling ..
22:51:43 <dobblego> is http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal on hackage somewhere?
22:51:44 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
22:52:19 <dons> kayess: fromIntegral . truncate?
22:52:24 <thetallguy> The really nice part of this is that we can deploy a server using debian tools and the latest haskell tools...
22:52:37 <roconnor> ivanm: how old are you?
22:52:48 <ivanm> one score and two
22:53:00 <roconnor> you'll be around too.
22:53:05 <dons> awesome, thetallguy
22:53:12 <ivanm> or, work it out yourself... I was born on the same day as the world's current worst civilian nuclear distaster :p
22:53:16 <ivanm> roconnor: O RLY?
22:53:24 <thetallguy> roconnor: what units are these again?
22:53:26 * ivanm goes off to slash his wrists just to prove roconnor wrong
22:53:41 <thetallguy> dons: thanks.  Hope it pays off.
22:53:44 <roconnor> ivanm: well, I'm not certain
22:54:05 <kayess> Saizan_, dons - thanks. I've tried floor already and was still having trouble. Maybe I was doing it wrong. Will try again
22:54:07 <roconnor> ivanm: true, sucide is your biggest challenge.
22:54:17 <roconnor> ivanm: Try to avoid it.
22:54:17 <ivanm> or accidents
22:54:24 <ivanm> awwwww.... spoilsport :@
22:54:28 <roconnor> ivanm: meh, accidents are pretty rare.
22:54:54 <ivanm> depends on how well the people in your area drive...
22:55:28 <roconnor> ivanm: I'd worry more about sucide if I were you.
22:55:39 <ivanm> since that's easier to avoid?
22:55:49 <roconnor> since it is more common.
22:56:14 <ivanm> you must have a lot of emos in your area if there are more deaths due to suicide than accidents...
22:56:16 <roconnor> for someone your age.
22:56:37 <ivanm> or does death due to drink driving count as suicide?
22:57:11 <roconnor> I can't think of anyone I know who has died in a car accident
22:57:23 <roconnor> I can think of 1 or 2 people who killed themselves
22:58:26 <ivanm> btw, monotonically increasing == can't skip a number (i.e. 1, 2, 3, 4 as opposed to 1, 3, 4)?
22:59:27 <thetallguy> ivanm: that's not the usual definition...
22:59:37 <ivanm> oh? what is then?
22:59:41 * ivanm can't recall it atm :s
22:59:54 <thetallguy> ivanm: never decreases
22:59:55 <Riastradh> Usually a function f is monotonically increasing if x > y implies f(x) > f(y).
23:00:05 <ivanm> ahhh
23:00:06 <Riastradh> That or f(x) >= f(y).
23:00:33 <ivanm> what should I use to describe a sequence of integers which is increasing and can't skip a number?
23:00:40 <Riastradh> Some people write `strictly increasing' to mean that x > y implies f(x) > f(y), and allow f(x) >= f(y) for just `increasing'.  Others say `nondecreasing' for f(x) >= f(y), and use the simpler `increasing' for f(x) > f(y).
23:00:47 <roconnor> f is monotinically increasing means if x <= y then f(x) <= f(y)
23:00:47 <thetallguy> I forget if it's > or >=
23:00:57 <roconnor> f is strictly monotinically increasing means if x < y then f(x) < f(y)
23:01:07 <thetallguy> that's right.
23:01:27 <Riastradh> Terminology varies; good authors will state what they mean before using any of these terms.
23:01:34 <thetallguy> except for the spelling monotonically
23:01:42 <roconnor> :P
23:02:08 <Riastradh> Some authors are also lazy and just write `monotone' even for the adverb.
23:02:56 <dons> jdh30 ephiphany, Heffalump , "Outside that remit, OCaml is no longer significantly better than alternatives like Haskell."
23:03:03 <roconnor> I would say f is monotone, and leave out the increasing
23:03:05 <ivanm> so what _do_ I call it when I want 1, 2, 3, 4 but not 1, 3, 4 ? (i.e. can't skip a number)
23:03:20 <ivanm> dons: which remit is this?
23:03:21 <Riastradh> ivanm, contiguous.
23:03:21 <roconnor> If I wanted monotonically decreasing, I'd say f is antitone
23:03:30 <ivanm> Riastradh: *nod*
23:03:30 <thetallguy> really?
23:03:35 <roconnor> ivanm: consecutive
23:03:48 <Riastradh> See, no shortage of choices for terminology!
23:04:12 <ivanm> "contiguously increasing" sounds better than "consecutively increasing" :p
23:04:29 <ivanm> anyway, it's just comments for my code that will probably never be read anyway *shrug*
23:04:32 <roconnor> @wn contiguous
23:04:33 <lambdabot> *** "contiguous" wn "WordNet (r) 2.0"
23:04:33 <lambdabot> contiguous
23:04:33 <lambdabot>      adj 1: very close or connected in space or time; "contiguous
23:04:33 <lambdabot>             events"; "immediate contact"; "the immediate
23:04:33 <lambdabot>             vicinity"; "the immediate past" [syn: {immediate}]
23:04:35 <lambdabot> [9 @more lines]
23:05:05 <thetallguy> roconnor: thanks, antitone is going into my binary word search file
23:05:29 <roconnor> thetallguy: I got it from wikipedia last year.
23:06:05 <roconnor> @wn antitone
23:06:05 <lambdabot> No match for "antitone".
23:06:09 <roconnor> :/
23:06:59 <thetallguy> it's not in merriam-webster
23:07:31 <thetallguy> too specialized or too new, I guess
23:07:45 <ivanm> antitone == antimatter equivalent of a sound quality? :p
23:07:54 <dons> new haskell company slipped under my radar, "Tupil is a Dutch company that builds software for clients, written in Haskell. Tupil uses Haskell for the speed in development and resulting software quality. The company is founded by Chris Eidhof and Eelco Lempsink."
23:07:59 <roconnor> I got it from wikipedia so it must be the concensus word for it :P
23:08:28 <roconnor> dons: I read that as "Tulip"
23:08:46 <ivanm> or else should it be "Tuple"?
23:12:06 <thetallguy> dons:  see?  They just come along quietly...
23:12:07 <dons> Chris Eidhof added the entry 7 days ago
23:12:16 <dons> thetallguy: they do. one here, one there.
23:12:29 <ivanm> suddenly we'll be inundated with Haskell companies.
23:12:31 <dons> actually, we had people from Antiope visiting Galois today
23:12:43 <dons> the wireless chips + haskell guys
23:12:50 <ivanm> and then we'll need to invent a new language just so that we can be cool for using a boutique language :p
23:13:04 <dons> i think coq or isabelle are the new boutique languages
23:13:06 <shachaf> dons: That's the chr1s in this channel, yes?
23:13:21 <ivanm> dons: coq is a language? I thought it was just a theorem prover.... :o
23:13:25 <Saizan_> slightly OT, what's a good paper that describes ML functors?
23:13:54 <dons> shachaf: i think so.
23:15:30 <shachaf> There seem to be several Haskell-related things going on around uu.nl.
23:15:52 <thetallguy> shachaf: that's a given
23:17:05 <roconnor> I'm not sure that isabelle counts.
23:17:09 <roconnor> I could be wrong
23:17:29 <dons> galois hires isabelle people
23:17:32 <dons> nicta too.
23:17:53 <roconnor> dons: isabelle is useful, but is it programming?
23:17:59 <roconnor> do they support evaluation?
23:18:03 <ivanm> what's isabelle?
23:18:04 * roconnor doesn't know.
23:18:28 <dons> theorem proving + extraction
23:18:33 <roconnor> I thought it has axioms that would get in the way.
23:18:38 <ivanm> doesn't sound like programming to me...
23:18:47 <roconnor> hmm
23:19:07 <ivanm> sounds like a maths application rather than an actual programming language
23:19:13 <ivanm> isn't coq meant to be something similar?
23:19:35 <roconnor> ivanm: that is unclear
23:19:45 <roconnor> but coq certainly supports evaluation.
23:21:03 <ivanm> OK, what is coq meant to be then?
23:21:58 <roconnor> ivanm: I'm not sure
23:22:13 <roconnor> they call it a proof assistant, if that helps
23:22:31 <ivanm> I thought you used it though :s
23:22:37 <roconnor> I do
23:22:46 <ivanm> and you don't even know what it does? :o
23:23:00 <roconnor> but what I use it for may be different than what the people who wrote it intended it for.
23:23:07 <ivanm> ahhhh
23:23:28 <ivanm> you mean like how the way Steve Ballmer uses chairs might not be the way the manufacturers intended for them to be use? :p
23:23:36 <ivanm> *used
23:24:02 <quicksilver> it's like one of those verbal reasoning tests
23:24:08 <quicksilver> chair is to ballmer as coq is to roconnor
23:24:16 <ivanm> lol
23:24:41 <^Someone^> > 2**3
23:24:43 <lambdabot>  8.0
23:24:55 <^Someone^> > 2**32582657 - 1
23:24:56 <lambdabot>  Infinity
23:25:13 <^Someone^> Infinity is prime :D
23:25:31 <ivanm> ^Someone^: the mersenne test isn't perfect...
23:25:47 * ivanm should know what the actual criteria is.... he's having an exam that might feature that next week :s
23:25:54 <roconnor> > 2^32582657 - 1
23:25:55 <^Someone^> Okay
23:26:06 <lambdabot> Terminated
23:26:15 <^Someone^> > 1^2
23:26:16 <lambdabot>  1
23:26:16 <roconnor> ^Someone^: you are using the wrong operation
23:26:21 <roconnor> you want ^
23:26:22 <^Someone^> > 2^2
23:26:24 <lambdabot>  4
23:26:26 <^Someone^> I don' think so
23:26:32 <^Someone^> Hmmm
23:26:42 <ivanm> otherwise you use logarithms to perform the power calculation
23:26:46 <^Someone^> Is this just a lambdabot thing?
23:26:54 <ivanm> no...
23:27:03 <^Someone^> > 3^2
23:27:04 <lambdabot>  9
23:27:12 <roconnor> lambdabot is simply to impatient to evalutate 2^32582657 - 1
23:27:17 <roconnor> ghc will
23:27:22 <ivanm> I can't think of a single language that doesn't use logs for floating point power calculations
23:27:23 <roconnor> ... eventually
23:27:26 <ivanm> heh
23:27:32 <ivanm> roconnor: given enough RAM...
23:27:36 <roconnor> if your computer is big enough
23:28:00 <ivanm> like that new hybrid cell-based supercomputer that's the new world's fastest?
23:28:08 <ivanm> BlueGene-P or something..
23:28:09 <quicksilver> 32 million bits is about 4M
23:28:12 <roconnor> I was thinking that a logic developed by an ultrafinitist might have an intersting CH intepretation.
23:28:16 <dmwit> It doesn't take that long to tsart printing on my machine.
23:28:26 <roconnor> it may guarentee not out of memory errors.
23:28:27 <quicksilver> so storing the answer as a gmp number is only about 4M
23:28:29 <ivanm> oh? lambdabot's machine must be pretty slow then...
23:28:46 <quicksilver> not sure how much memory it would take overall
23:28:59 <dmwit> Where "not that long" means ~5s.
23:29:16 <ivanm> dmwit: ahhh
23:29:18 <dmwit> Safely out of \bot's limits, anyway.
23:29:34 <quicksilver> my machine takes 10-15 seconds to start printing anything
23:29:35 <ivanm> "not that long" depends on your variant of "long" :p
23:29:57 <^Someone^> ghci handled it quite well
23:30:02 <quicksilver> I suppose the answer is fully evaluated in memory by then
23:30:12 <quicksilver> then just remains the time to convert it to [Char]
23:30:18 <ivanm> quicksilver: yes, but dmwit is preventing the NSA from scanning the internet for terrorism by solving that expression :p
23:30:21 <quicksilver> which is slower than the initial calculation I suspect.
23:30:25 <dmwit> *Main> timeEquality (2^32582657 - 1)
23:30:29 <dmwit> 3.278987s
23:30:37 <ivanm> @hoogle timeEquality
23:30:38 <lambdabot> No matches found
23:30:43 <ivanm> what's timeEquality?
23:30:55 <dmwit> timeEquality = timePrint . join (==)
23:31:10 <ivanm> ahhh
23:31:27 <dmwit> timePrint's source is 4 lines long, but not hard to guess.
23:31:36 <roconnor> {- REWRITE join (==) = const True
23:31:41 <roconnor> er
23:31:43 <roconnor> RULE
23:31:51 <dmwit> roconnor: That's cheating. =)
23:31:57 <ivanm> heh
23:32:09 <ivanm> dmwit: not for types that aren't an instance of Eq! :p
23:32:15 <roconnor> dmwit: I don't care about preserving bottom
23:32:23 <opqdonut> well you can force the typesig
23:32:36 <opqdonut> const True :: Eq a => a -> Bool
23:33:22 <dmwit> roconnor: Since (join (==)) is such a rare operation, I would think that using is itself a documentation that something weird is going on.
23:33:30 <dmwit> Hence I would be fine with leaving out that rewrite rule.
23:33:46 <roconnor> dmwit: why not evaluate >=> timePrint
23:33:58 <dmwit> :t evaluate
23:34:00 <lambdabot> forall a. (Testable a) => a -> Gen Result
23:34:12 <roconnor> @hoogle evaluate
23:34:13 <lambdabot> Control.Exception.evaluate :: a -> IO a
23:34:13 <dmwit> Because I know nothing about evaluate?
23:34:22 <dmwit> Does it do better than WHNF?
23:34:33 <roconnor> oh
23:34:35 <roconnor> no
23:34:40 <roconnor> that's a good reason
23:34:42 <dmwit> yeah
23:34:52 <sjanssen> > join (==) $ sqrt (-1)
23:34:53 <roconnor> well
23:34:53 <lambdabot>  False
23:34:54 <roconnor> goodish
23:35:14 <roconnor> yeah
23:35:16 <dmwit> sjanssen: yikes
23:35:18 <roconnor> not sure how I feel about the IEEE
23:35:26 <opqdonut> heh
23:35:45 <roconnor> maybe we should consider == a PER
23:36:05 <roconnor> it wouldn't be so unreasonable
23:37:06 <roconnor> > compare $ sqrt (-1)
23:37:07 <lambdabot>  <Double -> Ordering>
23:37:14 <roconnor> > join compare $ sqrt (-1)
23:37:15 <lambdabot>  GT
23:37:20 <roconnor> that is more of an issue
23:37:59 <dmwit> ?check \x y -> compare (x :: Double) y == EQ ==> x == y
23:38:02 <lambdabot>  Arguments exhausted after 65 tests.
23:38:41 <dmwit> ?check join (==) :: Double -> Bool
23:38:43 <lambdabot>  OK, passed 500 tests.
23:38:59 <dmwit> ?scheck join (==) :: Double -> Bool
23:39:01 <lambdabot>   Completed 79 test(s) without failure.
23:39:03 <dmwit> Too bad.
23:46:46 <^Someone^> Anyone know how I can make a DOS batch file take the filename of an executable as argument and then execute it?
23:47:35 <smtms> %1
23:47:43 <smtms> should be enough :-)
23:47:59 <smtms> I haven't used DOS since ages
23:48:10 <^Someone^> Thanks :)
23:48:35 <smtms> %1, %2, etc are the arguments to the batch file
23:48:45 <^Someone^> Ah
23:48:50 <dmwit> %* to use all the arguments
23:48:51 <smtms> you use them where the command name would be and it gets substituted
23:48:54 <dmwit> shift is also useful
23:49:01 <^Someone^> shift?
23:49:09 <dmwit> shift drops each argument down one
23:49:13 <dmwit> It's like
23:49:30 <smtms> it's like shift in the Unix shells
23:49:31 <dmwit> set %1=%2; set %2=%3; ...
23:49:41 <dmwit> set %9=%MAGICAL
23:49:48 <dmwit> (Because there's no %10.)
23:49:48 <^Someone^> Ah
23:49:51 <newsham> http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages
23:49:52 <lambdabot> Title: Topics:SICP in other languages - CTMWiki, http://tinyurl.com/yvqsht
23:49:52 <smtms> dmwit, I expected you'd show a Haskell expression :-)
23:50:02 <newsham> looks like the first few chapters were done in haskell but not more
23:50:08 <dmwit> smtms: Okay, it's like %*=tail %*
23:50:09 <dmwit> =)
23:50:59 <^Someone^> It works!
23:51:01 <^Someone^> Thanks!
23:51:10 <dmwit> Oh, I'm sorry.
23:51:28 <dmwit> Poor guy came here for help, and now he's got a working DOS script. =/
23:52:00 <^Someone^> I'm trying to capture the output of  the executables generated by ghc in my editor
23:53:12 <smtms> ^Someone^, you should really embrace the power of Unix, and not play with the toy that DOS is
23:53:30 <dmwit> ^Someone^: Which editor?
23:53:36 <^Someone^> Crimson Editor
23:53:39 <dmwit> If it's vim or emacs, you can do better than DOS scripting.
23:53:39 <dmwit> oh
23:53:48 <mmorrow> > (!!13) $ let abc = fmap (:[]) ['a'..'z'] in scanl (zipWith (++)) abc (repeat abc) -- generate vars!
23:53:51 <lambdabot>  ["aaaaaaaaaaaaaa","bbbbbbbbbbbbbb","cccccccccccccc","dddddddddddddd","eeeeee...
23:54:17 <smtms> vim and emacs on DOS/Windows? :-) I bet Windows users don't know they exist
23:54:25 <mmorrow> > concat $ let abc = fmap (:[]) ['a'..'z'] in scanl (zipWith (++)) abc (repeat abc)
23:54:26 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
23:54:45 <dmwit> > replicateM 13 ['a'..'z']
23:54:46 <lambdabot>  ["aaaaaaaaaaaaa","aaaaaaaaaaaab","aaaaaaaaaaaac","aaaaaaaaaaaad","aaaaaaaaaa...
23:55:07 <mmorrow> (non-uglified-by-_numbers vars)
23:55:17 <dmwit> > [1..] >>= flip replicateM ['a'..'z']
23:55:18 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
23:55:53 <mmorrow> > [1..] >>= flip replicateM (fmap (:[]) ['a'..'z'])
23:55:55 <lambdabot>  [["a"],["b"],["c"],["d"],["e"],["f"],["g"],["h"],["i"],["j"],["k"],["l"],["m...
23:56:11 <newsham> > map (filter isAlpha) $ replicateM 4 " abc"
23:56:12 <mmorrow> hmm
23:56:13 <lambdabot>  ["","a","b","c","a","aa","ab","ac","b","ba","bb","bc","c","ca","cb","cc","a"...
23:56:21 <dmwit> > [1..] >>= flip replicateM ['a'..'c']
23:56:22 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
23:57:21 <roconnor> > [0..] >>= flip replicateM ['a'..'c']
23:57:23 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
23:57:41 <newsham> > unwords $ map (filter isAlpha) $ replicateM 4 " abc"
23:57:42 <lambdabot>  " a b c a aa ab ac b ba bb bc c ca cb cc a aa ab ac aa aaa aab aac ab aba ab...
23:57:42 <mmorrow> i like the a-z, aa-zz, ... since it minimizes length
23:57:59 <dmwit> mmorrow: What do you mean?
23:58:32 <dmwit> > liftM2 replicate [1..] ['a'..'c']
23:58:33 * Lycurgus goes "Lady Bracknell" on #haskell
23:58:33 <lambdabot>  ["a","b","c","aa","bb","cc","aaa","bbb","ccc","aaaa","bbbb","cccc","aaaaa","...
23:58:38 <dmwit> mmorrow: Like that?
23:58:41 <mmorrow> to generate unique variable name to un-uglify the a_1321435, b_2, c_029, etc. for pretty printing
23:58:49 <mmorrow> s/name/names/
23:59:24 <mmorrow> but i have to replace uniques with uniques
23:59:47 <mmorrow> (obviously)
