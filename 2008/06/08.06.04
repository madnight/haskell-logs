00:00:06 <dmwit> Well, filter or partition work better for that purpose, anyway. =)
00:03:37 <dmwit> What regex packages are recommended?
00:03:49 <dmwit> (Hoogle lists no results for "regex".)
00:04:18 <asmanian> or: "has a common divisor with" (not counting 1 naturally)
00:05:06 <dmwit> There's like 15 regex packages on Hackage... =/
00:05:11 <dmwit> Too many choices!
00:05:42 <Elly> dmwit: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
00:05:43 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
00:06:15 <dmwit> Oh good, I was hoping for something built-in.
00:06:26 <Elly> hah, lambdabot made the title longer by truncating it
00:06:35 * Elly -> sleep
00:06:47 <dmwit> Though it does seem a bit under-capable.
00:06:51 <jkff> Also consider looking at the 'regular expressions' chapter of Real World Haskell
00:07:33 <hpaste>  tieTYT pasted "(no title)" at http://hpaste.org/8085
00:07:39 <tieTYT2> why won't this compile?
00:07:41 <jkff> http://book.realworldhaskell.org/beta/glob.html
00:07:42 <lambdabot> Title: ChapterÂ 10.Â Case study: regular expressions and file name matching
00:07:54 <tieTYT2> i get: myGroupBy.hs:1:0: parse error on input `:'
00:08:27 <jkff> Remove the :
00:08:36 <jkff> import Data.List
00:08:54 <tieTYT2> i got lots of :
00:08:57 <jkff> :module is an instruction for the interactive interpreter
00:09:01 <jkff> No, I mean just change the first line
00:09:22 <jkff> It should say import Data.List
00:09:25 <tieTYT2> ok thanks
00:09:40 <dmwit> (a : (b : [])) ++ bs === a:b:bs
00:09:49 <dmwit> (a : []) ++ (b:bs) === a:b:bs
00:10:07 <tieTYT2> doi
00:10:07 <tieTYT2> ok
00:10:08 <dmwit> Just so you know. ;-)
00:11:28 <jkff> Also a:b:[] is the same as [a,b]
00:11:49 <Nyenburgh> jkff - i saw that they were also going to do PCRE for the FFI example
00:13:24 <jkff> Yes, I'm looking forward for that chapter :)
00:20:22 <dmwit> True or false: a graph is cyclic iff it has a self loop or it has any non-singleton strongly-connected component.
00:20:37 <dmwit> I want this to be true, and I feel it to be true, but...
00:22:15 <dmwit> Okay, never mind, I think I can prove it now.
00:22:30 <opqdonut> yes
00:22:32 <opqdonut> that is true
00:22:32 <tieTYT2> dmwit: do you think you'll get a job using a functional programming language?
00:22:45 <dmwit> opqdonut: thanks
00:23:01 <dmwit> tieTYT2: I plan on going into academia.  So... yes, I do think so.
00:23:14 <tieTYT2> ok
00:23:16 <dmwit> But it hardly counts. =)
00:23:31 <BeelsebobWork> tieTYT: why wouldn't you?
00:23:39 <BeelsebobWork> or anyone
00:24:11 <opqdonut> i'm doing my software engineering project course in lisp, it seems
00:24:36 <opqdonut> the course involves executing "real" development in a group of about 8 for a real customer
00:24:45 <opqdonut> people usually end up coding java or php
00:25:18 <BeelsebobWork> so a bunch of students settle into a familiar language when asked to do something quickly
00:25:22 <BeelsebobWork> no surprises there
00:25:35 <tieTYT2> Beelsebob: perhaps OO languages are more marketable, i donno
00:25:42 <tieTYT2> i know java, and i'm learning haskell
00:25:48 <tieTYT2> so for me it's very hard
00:26:06 <BeelsebobWork> yeh -- but I still don't get why you're saying you can't get a job writing functional programs
00:26:10 <BeelsebobWork> I after all, have such a job
00:26:22 <opqdonut> BeelsebobWork: well it's mostly the customers that dictate the environment and language
00:26:28 <tieTYT2> Beelsebob: nobody said that
00:28:42 <jsnx> BeelsebobWork: well, i'm sure you are aware of how lucky you are to have that job
00:29:08 <dmwit> "The NUL character is not special in message framing, and basically could end up inside a parameter, but as it would cause extra complexities in normal C string handling, NUL is not allowed within messages."
00:29:26 <BeelsebobWork> jsnx: yeh, fair point
00:29:28 <dmwit> And so C's horrible string semantics infect *every other language* that could be used in this problem domain. =/
00:29:35 <BeelsebobWork> doesn't mean they're impossible to find though
00:29:58 <jsnx> which domain is that?
00:30:03 <dmwit> IRC
00:30:21 <dmwit> I wonder...
00:30:29 <dmwit> > fun $ expr "a\NULb"
00:30:31 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Char]'
00:30:31 <jsnx> waht?
00:30:40 <dmwit> > expr $ fun "a\NULb"
00:30:41 <lambdabot>  a
00:30:48 <opqdonut> heh
00:31:11 <jsnx> > expr $ fun "ab"
00:31:13 <lambdabot>  ab
00:31:19 <ziman> > expr $ fun "a\x01b"
00:31:21 <lambdabot>  a
00:31:36 <dmwit> > expr $ fun "a\x01\&b"
00:31:37 <lambdabot>  ab
00:31:45 <jsnx> my eyes!
00:31:52 <BeelsebobWork> > expr $ fun "a\x00\&b"
00:31:54 <lambdabot>  a
00:32:03 <dmwit> \x00\& === \NUL
00:32:38 <dmwit> I guess only one '=' was really necessary there.
00:33:06 <BeelsebobWork> I wanted another 5 actually
00:33:22 <dmwit> \x00\& ======== \NUL
00:33:29 <dmwit> ========)
00:33:30 <BeelsebobWork> :) much better
00:33:43 <ziman> > expr $ fun "a\x02\&b\x03\&c"
00:33:44 <lambdabot>  abc
00:33:50 * ziman gives up :)
00:34:04 <dmwit> \bot may be filtering some characters out. =)
00:42:30 <dmwit> > expr $ fun "a\rb"
00:42:31 <lambdabot>  ab
00:42:39 * dmwit grunts
00:43:31 <pejo> MOA MOA MOA!
00:43:36 <pejo> Doh!
00:43:55 <pejo> Wrong window. :-)
00:44:26 <osfameron> maybe you meant: MONAD MONAD MONAD!
00:44:27 <osfameron> ?
00:45:04 <pejo> Yes! It's a bit early in the morning, so I missed out a couple of letters.
01:38:51 <osfameron> dammit I have to work and I want to play with monads!
01:40:36 <quicksilver> cmeme: what's with the incessant quit messages? :)
01:42:18 <osfameron> probably caused by incessant quitting
01:43:59 <yitz> quicksilver: maybe cmeme is using Windows and it keeps restarting.
01:44:01 <vixey> isn't cmeme the channel logger
01:44:55 <clad|away> I am looking to create a function that takes no arguments and returns a Int, in order to generate a series of unique numeric identifiers.  I think I have to use the State monad for this, but I'm not entirely sure where to start.
01:45:06 <dcoutts> bensonk: you can contributes fixes to the ebuilds in the haskell overlay via darcs record + darcs send
01:45:17 <vixey> :t modify (+1)
01:45:18 <dmwit> cladhaire: Yep, that sounds like a State Int Int variable.
01:45:19 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => m ()
01:45:37 <dcoutts> bensonk: though do talk to us in #gentoo-haskell too :-)
01:45:42 <dmwit> :t get <* modify (+1)
01:45:44 <lambdabot> forall (f :: * -> *) s. (Num s, MonadState s f, Applicative f) => f s
01:46:02 <cladhaire> dmwit: Any idea where I can start looking for more information how to use it?  I haven't had any experience with monads so far :P
01:46:02 <dmwit> :t modify succ >> get -- many ways to do it
01:46:04 <lambdabot> forall (m :: * -> *) b. (Enum b, MonadState b m) => m b
01:46:11 <dmwit> ?go meet the monads
01:46:12 <lambdabot> http://www.haskell.org/all_about_monads/html/meet.html
01:46:12 <lambdabot> Title: Meet the Monads
01:46:16 <dmwit> cladhaire: ^^
01:46:20 <osfameron> ooo, I think I know how to write a naive version of STM
01:46:23 <cladhaire> thanks
01:46:31 <osfameron> except for the rolling back and committing of things other than basic state :-)
01:47:41 <yitz> cladhaire: Data.Unique may also interest you
01:47:49 <quicksilver> cladhaire: I would personally store an infinite list in your State Monad
01:47:55 <quicksilver> cladhaire: you can populate it with [0..]
01:47:59 <cladhaire> *nod*
01:48:00 <quicksilver> or whatever infinite list you choose :)
01:48:13 <cladhaire> that was my plan, it's just figuring out the other bits that Im' working on
01:48:22 <opqdonut> or use MonadSupply
01:49:48 <dmwit> :t State (splitAt 1)
01:49:49 <lambdabot> forall a. State [a] [a]
01:49:56 <dmwit> beautiful
01:50:39 <dmwit> :t State (head &&& tail)
01:50:41 <lambdabot> forall a. State [a] a
01:52:18 <yitz> how about just:
01:52:29 <yitz> @type State $ id &&& (+1)
01:52:30 <lambdabot> forall s. (Num s) => State s s
01:52:53 <dmwit> yitz: That has also been suggested.
01:53:09 <vixey> withGensyms freshVariables = flip evalState freshVariables
01:53:10 <dmwit> yitz: (Though in the more State-monad-y way of (modify (+1) >> get).)
01:53:16 <vixey> gensym = what dmwit wrote
01:53:36 * yitz nods
02:01:17 <vixey> @quote Monad Transformers
02:01:17 <lambdabot> No quotes for this person.
02:01:21 <vixey> @quote Oleg
02:01:21 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
02:01:24 <vixey> @quote Oleg
02:01:24 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
02:01:27 <vixey> @quote Oleg
02:01:27 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
02:01:30 <vixey> ... :(
02:03:04 <vixey> @die 3d3
02:03:04 <lambdabot> 3d3 => 6
02:04:29 * shepheb 's headache and tiredness is suddenly explained when he realizes he hasn't eaten in 30 hours
02:05:00 <vixey> shepheb: Why didn't you eat in 30 hours?
02:05:35 <shepheb> vixey: well, I usually operate on an "eat when hungry" policy. I never got hungry. I'm not hungry now, but it's time to eat something
02:06:56 <yitz> shepheb: "eat when hungry" is not a good policy
02:07:02 <yitz> @go hacker's diet
02:07:04 <lambdabot> http://www.fourmilab.ch/hackdiet/www/hackdiet.html
02:07:04 <lambdabot> Title: The Hacker's Diet
02:08:50 <dmwit> > { instance Ord Char where { x < y = ord x < ord y }; 'a' < 'b' }
02:08:50 <lambdabot>  Parse error at "{" (column 1)
02:09:06 <AllNight^> morning all :)
02:09:54 <dolio> dmwit fails to hack the Gibson.
02:10:22 <dmwit> I was just reading through past successful hacks of \bot, and it mentioned "malicious instances" of classes.
02:10:28 <mrchebas> @seen dblhelix
02:10:28 <lambdabot> I saw dblhelix leaving #haskell 1d 13h 33m 2s ago, and .
02:10:36 <dmwit> I was wondering how to make an instance in \bot.
02:10:46 <dmwit> I guess I didn't find it yet (or it's no longer possible). =)
02:10:59 <shepheb> yitz: looks like an interesting read.
02:11:51 <dolio> Just adding a { } in the middle of a module doesn't seem to be valid syntax at all.
02:11:52 <yitz> shepheb: yeah it's fun. a bit dated. but it works.
02:12:50 <shepheb> actually, mod3 is empty by default. I have Alt_R bound to it.
02:12:54 <shepheb> mischan
02:13:59 <dolio> > instance Ord Char where { x < y = ord x < ord y }
02:13:59 <lambdabot>  Parse error at "insta..." (column 1)
02:16:45 <dolio> > f 'c' 'd' ; f c d = ord c + ord d
02:16:45 <lambdabot>  Parse error at ";" (column 11)
02:20:13 <luqui> > let f c d = ord c + ord d in f 'c' 'd'
02:20:14 <lambdabot>  199
02:20:40 <vixey> > ((+)`on`ord) 'c' 'd'
02:20:41 <lambdabot>  199
02:22:03 * luqui wonders if @pl knows about on...
02:22:07 <luqui> @pl \c d -
02:22:07 <lambdabot> (line 1, column 6):
02:22:07 <lambdabot> unexpected end of input
02:22:07 <lambdabot> expecting "->"
02:22:11 <luqui> @pl \c d -> ord c + ord d
02:22:11 <lambdabot> (. ord) . (+) . ord
02:22:24 <dmwit> > 'c' < 'd' where { instance Ord Char where x < y = ord x < ord y }
02:22:24 <lambdabot>  Parse error at "where" (column 11)
02:22:26 <luqui> sadness
02:22:56 <dmwit> I can't imagine instance declarations are valid in a "let" clause.
02:23:01 <BeelsebobWork> indeed, that's one of the few pieces of pointless code I've seen that are actually nice
02:23:11 <dolio> @let instance (Num n) => Num (Monad n) where { (+) = liftM2 (+) ; (-) = liftM2 (-) ; (*) = liftM2 (*) ; abs = liftM abs ; signum = liftM signum }
02:23:12 <lambdabot> Invalid declaration
02:23:42 <luqui> dmwit, sadly no, however that is how they are often formalized
02:24:06 <yitz> dmwit: people have been proposing that for years. haskell' and long before.
02:24:31 <quicksilver> there are pretty serious reasons why instances are global and unique.
02:24:36 <quicksilver> it's not a mere lexical change :)
02:24:41 <dmwit> No, I understand.
02:24:43 <yitz> there are some semantic issues to decide, but personally I think it is a good idea.
02:24:47 <dmwit> I'm not asking for it to be valid.
02:24:57 <luqui> BeelsebobWork, as soon as (.) sections start appearing, my brain turns off
02:25:01 <dolio> People who propose that want first class modules. :)
02:25:06 <BeelsebobWork> luqui: exactly
02:26:19 <yitz> dolio: not really. modules are global namespaces. we have local binding already.
02:26:49 <yitz> can we please ban cmeme? this is getting tiresome.
02:26:51 <luqui> dolio, who doesn't?
02:27:13 <dibblego> cmeme, can you please fix your temperamental IRC connection?
02:27:14 <dolio> luqui: I don't know.
02:27:36 --- mode: ChanServ set +o quicksilver
02:27:39 --- kick: cmeme was kicked by quicksilver (quicksilver)
02:27:45 <quicksilver> let's see if that's enough
02:28:17 <quicksilver> good, he's not auto-join-after-kick.
02:28:20 <quicksilver> I didn't need to ban.
02:28:23 --- mode: quicksilver set -o quicksilver
02:28:25 <yitz> probably, i seen to recall that cmeme is a person, not a bot. probably some problem with the computer while away
02:28:36 <quicksilver> I /msged him telling him to rejoin at will.
02:28:41 <yitz> ok
02:29:08 <vixey> I think cmeme is the IRC logger
02:29:27 <yitz> vixey: doesn't seem that way from the /whois
02:29:49 <vixey> yes it does
02:29:55 <yitz> b9.com?
02:29:58 <therp> ircbrowse.com looks like..
02:30:02 <dolio> luqui: I don't think they're as handy as type classes, but maybe I haven't used a good implementation of them.
02:30:02 <vixey> look at the channels it's in
02:30:08 <vixey> & the list of channels here http://tunes.org/~nef/logs/
02:30:09 <lambdabot> Title: Index of /~nef/logs
02:30:32 <dolio> I've only used Agda's.
02:30:39 * luqui too
02:31:03 <luqui> I didn't get far enough into Agda to see how they were useful, either
02:31:07 <yitz> logs are still being updated
02:31:13 <yitz> even without cmeme
02:31:19 <quicksilver> I I think vixey is right, actually
02:31:20 <luqui> but generally my answer to the question "should X be first class" is "yes"
02:31:20 <Zao> For being a dedicated logging bot, it has a rather unstable pipe.
02:31:23 <quicksilver> cmeme is ircbrowse's logger
02:31:26 <quicksilver> but
02:31:30 <quicksilver> (a) it's secret
02:31:32 <luqui> (if possible)
02:31:34 <quicksilver> (b) they didn't ask permission
02:31:36 <quicksilver> (c) they lie about it
02:31:40 <quicksilver> so, I don't feel too bad.
02:31:55 <yitz> (d) it seems broken currently
02:31:55 <quicksilver> oh and (d) they don't appear to have a stable bot :)
02:32:00 <yitz> he
02:32:06 <luqui> gasp!
02:32:08 <dcoutts> hah
02:32:09 <yitz> oh oh here it is again
02:32:16 <quicksilver> let's see if it's more stable this time
02:32:48 <quicksilver> that's odd
02:32:55 <quicksilver> I'm not getting a response to "/whois cmeme"
02:33:08 * luqui is
02:33:16 * dmwit is, too
02:33:17 <loufoque> is there an elegant way to stop traversal of some structure with a traversal that takes a function which is applied to every element?
02:33:18 * yitz is too
02:33:20 * dcoutts too
02:33:30 <quicksilver> ah yes.
02:33:32 <quicksilver> silly irssi
02:33:37 <quicksilver> put it in the query window :P
02:33:55 <luqui> loufoque, not sure what you mean...
02:34:29 <quicksilver> hmm
02:34:40 <quicksilver> it doesn't seem to be logging
02:34:53 <quicksilver> loufoque: yes.
02:35:05 <opqdonut> loufoque: do the traversal inside for example the error monad
02:35:19 <quicksilver> loufoque: make your function return a Maybe type and stop when you get Nothing
02:35:34 <quicksilver> which is a simple example of a monad ;)
02:36:23 <solrize_> http://caml.inria.fr
02:36:24 <lambdabot> Title: The Caml language: Home
02:36:26 <solrize_> hmm
02:37:18 <dmwit> *gasp*!
02:37:31 <dmwit> My first reproducible "impossibility"!
02:37:34 <luqui> DESTROY!
02:37:36 <luqui> BAN!
02:37:43 <luqui> EXCOMMUNICATE!
02:38:14 * AllNight^ can almost hear the darlek...
02:39:08 <yitz> opqdonut: use the Exit monad instead of the error monad. same thing, except you don't need an Error instance for the return type.
02:39:27 * luqui finds the exit monad
02:39:35 <loufoque> opqdonut: it's not an error
02:39:41 <quicksilver> loufoque: doesn't really matter.
02:39:48 <quicksilver> it's just an example of flow control :)
02:39:57 <luqui> yitz, where is said Exit monad?
02:40:04 <quicksilver> on the wiki of course
02:40:06 <quicksilver> ;)
02:40:13 <luqui> grr, no hackage package
02:40:14 <loufoque> it does to me. For example, I would strongly be against using exceptions to do such a thing.
02:40:22 <quicksilver> loufoque: well it would not be exceptions.
02:40:26 <yitz> @go MonadExit
02:40:26 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadExit
02:40:26 <lambdabot> Title: New monads/MonadExit - HaskellWiki
02:40:27 <quicksilver> loufoque: so there would be no issue there.
02:40:47 <dmwit> Okay, this says "Please report this as a GHC bug: <url>", but when I visit that URL and click "New Bug", I get an error message.
02:40:50 <yitz> this cmeme thing is happening exactly every 5 minutes
02:40:58 <quicksilver> using Maybe is the same, but Exit lets you carry a return value away from the point where you decide to stop.
02:41:00 <dmwit> Specifically, "TICKET_CREATE privileges are required to perform this operation."
02:41:04 <opqdonut> yitz: true
02:41:08 <quicksilver> dmwit: login as guest guest
02:41:22 <yitz> Maybe with mplus is equivalent to Exit with >>=
02:41:28 <dmwit> quicksilver: Thanks.
02:41:44 <loufoque> quicksilver: the reason is that exceptions are for exceptional situations, ie program errors that shouldn't occur. And so is the error monad. Stopping the traversal at some point will always occur in my program and is the normal execution flow.
02:41:57 <luqui> loufoque, do not be afraid of the suggestive name.
02:42:10 <luqui> or if you must, use the Exit monad if you don't like the name.
02:42:34 <quicksilver> loufoque: you're talking rubbish
02:42:42 <luqui> but using a monad to do such a thing should not be considered a hack by any means.
02:42:47 <luqui> standard practice, nice and elegant.
02:42:49 <quicksilver> loufoque: if you don't like the word exception, rename confabumbulatrixes
02:43:03 <yitz> luqui: it's not just the name, MonadError requires an Error instance on the return type
02:43:08 <quicksilver> loufoque: it's just flow control, and it's precisely the flow control you asked for.
02:43:33 <EvilTerran> loufoque, the Either monad isn't exceptions in the usual sense, it's all implemented as conventional branching and function calls under the hood
02:43:36 <quicksilver> yes, actually using MonadError would be a pain.
02:43:46 <quicksilver> which is why I suggested Maybe.
02:43:48 <yitz> quicksilver: names are important. someday, some human will read that code and misunderstand it. that is a cost.
02:43:52 <luqui> yitz, yeah, that's kind of annoying
02:43:53 <quicksilver> you may want a more complex monad instead.
02:44:14 <quicksilver> depending on what kind of 'return' value you're after from the entire computation.
02:44:25 <yitz> EvilTerran: same comment. the implementation under the hood isn't the issue.
02:45:06 <yitz> The correct monad, classically, is Maybe. It's just that sometimes additive notation can be messy. So then use Exit.
02:45:12 <luqui> or rather Either
02:45:17 <luqui> why isn't Either a monad?
02:45:23 <yitz> lugui: it is
02:45:30 <dibblego> (Either a) is a monad
02:45:42 <luqui> with that stupid Error restriction
02:45:50 <yitz> luqui: right
02:45:53 <dolio> It's because of fail.
02:46:02 <dibblego> fail is fail
02:46:10 <osfameron> what's wrong with fail?
02:46:11 <luqui> ok, one hack breeds another
02:46:20 <osfameron> I like the fact that it abstracts [] vs error vs Nothing
02:46:34 <yitz> fail lived up to the prophecy of its own name
02:46:35 <dolio> It shouldn't be in Monad, it should be in MonadPlus.
02:46:42 <luqui> or MonadFail
02:46:46 <osfameron> ah
02:46:47 * dibblego whispers MonadZero to osfameron
02:47:01 <dolio> Yeah, we got rid of that for some reason, too.
02:47:02 <dibblego> or whatever it is these days
02:47:03 <osfameron> so it's more that it's in the wrong place than that the idea is wrong?
02:47:11 <dolio> Right.
02:47:22 <osfameron> what consequences does having fail in one or two additional monad classes have ?
02:47:37 <dolio> You can't make Either a a monad nicely, for one.
02:48:02 <osfameron> gotcha.  Though I thought Either had a valid fail (generate a Left value) ?
02:48:10 <yitz> osfameron: in monads where fail doesn't really belong, the only way to implement it is with bottom. that introduces a potential runtime crash into every Haskell program
02:48:28 <dolio> It does, but you need a condition on the a to make it a monad.
02:48:40 <dolio> Specifically, that you can generate an a from a String.
02:48:45 <dibblego> @djinn String -> m a
02:48:45 <lambdabot> -- f cannot be realized.
02:48:48 <yitz> dolio: you can. you don't need to require the Error instance.
02:49:09 <quicksilver> require Show instead?
02:49:13 <quicksilver> doesn't sound any better to me :P
02:49:15 <dolio> If you don't, then you just call error, which is even worse.
02:49:27 <dibblego> quicksilver, you mean Read?
02:49:30 <yitz> it's just that they did require it in the library. since you can't stop a library from exporting its class instances, we're now stuck with it.
02:49:37 <dibblego> oh wait, nothing
02:49:52 <quicksilver> dibblego: no, you're right, I did mean read.
02:50:06 <dibblego> quicksilver, I retracted because I know I am fuzzy today :)
02:52:45 <yitz> time for cmeme again
02:52:47 <Saizan> "If you are using CPS or MonadCont only for this purpose, the Exit monad will likely simplify your program considerably.", bold claim.. exit e = Cont (const e)
02:53:46 <yitz> hmm. 5.5 minutes then
02:53:48 <AllNight^> wb cmeme
02:55:13 <yitz> Saizan: conceptually, exit e is far simpler than Cont (const e)
02:55:29 <yitz> you just don't need all that underlying machinery
02:55:49 <dolio> @type Cont (const e)
02:55:51 <lambdabot> forall a. Cont Expr a
02:55:54 <dolio> @type \e -> Cont (const e)
02:55:56 <lambdabot> forall a a1. a -> Cont a a1
02:56:03 <vixey> @src Cont
02:56:03 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
02:56:11 <yitz> @src Cont (>>=)
02:56:11 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
02:59:32 <Saizan> continuations and monads feels very similar to me
03:00:18 <quicksilver> all monads which you can directly implement in a pure language
03:00:22 <quicksilver> are either state or continuation
03:00:40 <quicksilver> I believe.
03:01:15 <dmwit> Well... they're combinations of StateT and ContT, right?
03:01:28 <quicksilver> Right.
03:01:34 <quicksilver> I'm not sure if you ever need multiple layers.
03:01:46 <quicksilver> And I'm not 100% sure that you can't implement State using Cont :)
03:01:50 <yitz> msg cmene help
03:02:02 <dmwit> "sort" is the type of kinds, right?
03:02:08 <yitz> no response. it's not irclogger.
03:02:11 <mornfall> quicksilver: That's starting to give a Turing smell.
03:02:31 <quicksilver> yitz: It is, you can tell from its logs.
03:02:35 <quicksilver> yitz: but it's broken.
03:02:42 <yitz> cmene off
03:03:06 <quicksilver> dmwit: that is a common terminology, yes.
03:03:08 <dmwit> yitz: ...its name is cmeme, not cmene
03:03:16 <yitz> cmeme off
03:03:18 <quicksilver> dmwit: I'm not sure it's universal.
03:03:25 <dmwit> quicksilver: Okay, thanks.
03:03:32 <dmwit> quicksilver: I'm playing with the GHC API. =)
03:04:30 <dmwit> cmeme: lern2ping
03:04:49 <quicksilver> OK, shall I ban it?
03:05:14 <RayNbow> types, kinds, sorts... what's next? :)
03:05:21 <mornfall> metatypes? ;)
03:05:24 <dmwit> supersort
03:05:27 <quicksilver> variety, traditionally.
03:05:28 <AllNight^> universes!
03:05:29 <quicksilver> I believe.
03:05:29 <mornfall> (then metakinds... you get the idea)
03:05:42 <dmwit> superdupersort
03:05:51 <mornfall> But yah, variety sounds about right.
03:06:07 <yitz> these words are all so overloaded.
03:06:12 <quicksilver> but if you're serious about multiple levels you just number them.
03:06:15 <quicksilver> Russell-stylee
03:06:17 <AllNight^> is this related to 'variety' in universal algebra?
03:06:21 <AllNight^> (serious question)
03:06:22 <quicksilver> AllNight^: no.
03:06:29 <mornfall> Well, related.
03:06:34 <mornfall> Define related : - ].
03:06:44 <AllNight^> heh!
03:06:45 <quicksilver> english is a small language and mathematicians generally prefer to reuse words than invent new ones.
03:06:53 <quicksilver> (as distinct from scientists who like to invent words)
03:07:05 <AllNight^> of course - they can cause maximum confusion that way :P (mathematicians)
03:07:06 <adu> except for quandles
03:07:06 <quicksilver> often they reuse words that are, in some way, related.
03:07:19 <ivanm> quicksilver: what's wrong with oxypaloogas? :p
03:07:26 <ivanm> (and yes, I just made that word up)
03:07:27 <yitz> quicksilver: in this case, metametametatype might be better.
03:07:37 <mornfall> meta^ntype
03:07:40 <dolio> > let get = ask ; put s = callCC (\k -> local (const s) (k ())) ; evalState m s = runReader (runContT m return) s in evalState (do s <- get ; put (s+1) ; s' <- get ; return (s,s')) 0
03:07:41 <lambdabot>  (0,1)
03:07:42 <ivanm> yitz: {meta}^{x}type? :p
03:07:43 <quicksilver> yitz: 4th order type or 4th rank type or something.
03:07:47 <quicksilver> yitz: if you use a lot.
03:07:56 <adu> quandles and quasirings and semimodules
03:08:06 <yitz> quicksilver: fine
03:08:12 <quicksilver> dolio: did you just prove state can be implemented with cont?
03:08:18 <AllNight^> actually I have seen the term n-category used
03:08:35 <quicksilver> dolio: hmm. contT reader.
03:08:43 <AllNight^> so a 2-category is a category of 1-categories, which in turn is a category who's objects are not categories
03:09:11 <quicksilver> that's not correct.
03:09:21 <quicksilver> a 2-category is not a category categories.
03:09:25 <quicksilver> +of
03:09:46 <AllNight^> what is it then? (serious question)
03:09:52 <quicksilver> a 2-category is a strict generalisation of categories
03:09:58 * AllNight^ is learning this stuff & trying desperately to grapple with it
03:10:07 <quicksilver> in which there are somethings between the morphisms
03:10:23 <quicksilver> 2-cells, they're called.
03:10:25 <AllNight^> ah.. I've seen those too
03:10:25 <solrize_> allnight see john baez;s article
03:10:37 <quicksilver> (and the morphisms are renamed 1-cells and the objects renamed 0-cells)
03:10:55 <AllNight^> i've definitely seen _something_ that was a 'higher' category in the sense I just meant though - what's that called?
03:10:56 <quicksilver> it's true that under certain assumptions a category of categories is a 2-category
03:11:10 <quicksilver> (with the 2-cells being natural transformations)
03:11:11 <dolio> There's also a hierarchy of categories, where, like Cat is the (large-)category of (small-)categories.
03:11:14 <AllNight^> and solrize_ - I dont know that article! do you ahve a link? :)
03:11:17 <dolio> But that's not a 2-category.
03:11:25 <quicksilver> AllNight^: large and small, generally
03:11:40 <yitz> wikipedia: "In category theory, a 2-category is a category with "morphisms between morphisms"."
03:11:43 <dolio> Like the distinction between sets and proper classes.
03:11:54 <quicksilver> most category theorists have the intuition that issues of largeness and smallness are "not important" if you do "Sensible things"
03:12:10 <quicksilver> that is, there *are* paradoxes if you do really stupid things with *Cat*.
03:12:18 <quicksilver> but if you behave sensibly
03:12:26 <quicksilver> then you don't have to spend much time talking about largeness and smallness
03:12:28 <AllNight^> I assume equivalent to Russel's paradox?
03:12:30 <quicksilver> and you can mostly ignore the issue.
03:12:35 <quicksilver> Exactly equivalent, yes.
03:12:39 <yitz> stupid = self-referential
03:12:53 <adu> So is an N-category a category of (N-1)-morphisms with N-morphisms between them?
03:13:11 <AllNight^> solrize_ - what was that article you referred to?
03:13:11 <quicksilver> adu: an N-category is a family of (0-cells) up to (N-cells)
03:13:12 <yitz> "The category of all categories that are not members of themselves"
03:13:24 <quicksilver> adu: where there are 1-cells between pairs of (0-cells)
03:13:28 <quicksilver> adu: there are 2-cells between 1-cells
03:13:31 <quicksilver> and so on.
03:13:43 <quicksilver> satisfying a positively BOGGLING selection of commutative diagrams.
03:13:49 <quicksilver> Which are all kind of obvious but not quite.
03:13:53 <AllNight^> quicksilver - do you mind if I pm you for a minute? :)
03:14:06 <quicksilver> and a ridiculous array of things which are true "only up to isomorphism"
03:14:15 <solrize_> allnight, hmm, maybe here?  http://math.ucr.edu/home/baez/week73.html
03:14:16 <lambdabot> Title: week73
03:14:23 <quicksilver> and a bunch of theorems which are "obviously" true but turn out to require absurdly large diagrams to prove.
03:14:28 <AllNight^> ty solrize_ :)
03:14:35 <solrize_> that may not be what i was thinkign of
03:14:39 <solrize_> he has written a lot on the subject
03:15:02 <adu> quicksilver: like how I am a torus (up to isomorphism)
03:15:14 <quicksilver> eugenia cheng is one of the relatively few people in the world who understands n-categories and attempts to explain them to other people
03:15:23 <quicksilver> her website might be helpful if you're interested http://cheng.staff.shef.ac.uk/guidebook/index.html
03:15:25 <lambdabot> Title: guidebook
03:15:39 <quicksilver> AllNight^: erm, you're welcome to.
03:16:17 <adu> cool
03:16:31 <adu> but I still think I'm a torus
03:16:53 <quicksilver> adu: to a first approximation you are.
03:17:02 <quicksilver> but that's ignoring nostrils
03:17:11 <adu> lol
03:17:20 <quicksilver> counting nostrils you are a 3-ring.
03:17:28 <quicksilver> And no, I didn't mean isomorphism in that sense.
03:17:40 <dolio> And ears.
03:17:42 <quicksilver> (that's called homotopy IIRC but geometry isn't my field)
03:17:46 <adu> lol
03:17:56 <adu> I suppose that's homeomorphism
03:18:02 <quicksilver> isomorphism is something much much stronger.
03:18:14 <mehrheit> lambdabot needs a @describe-foomorphism command
03:18:18 <quicksilver> isomorphism in a category means it is literaly impossible to distinguish the objects by any categorical method.
03:18:22 <quicksilver> this is a strong property.
03:18:36 <solrize_> http://math.ucr.edu/home/baez/ncat.def.html
03:18:36 <quicksilver> there are lots of ways to distinguish adu from a torus.
03:18:36 <lambdabot> Title: n-Categories - Sketch of a Definition
03:18:37 <quicksilver> ;)
03:18:54 <adu> quicksilver: so 2 = 3?
03:19:05 <solrize_> http://math.ucr.edu/home/baez/week71.html
03:19:05 <lambdabot> Title: week71
03:26:59 <solrize_> http://java.sun.com/javase/6/docs/api/java/io/DataInput.html#modified-utf-8  mutant java utf8, how can i read this crap?
03:27:00 <lambdabot> http://tinyurl.com/6kag3d
03:27:26 <solrize_> data.binary i guess, sigghh
03:27:47 <quicksilver> it's backward compatible with utf8
03:27:52 <quicksilver> except for the surrogate pairs
03:28:00 <quicksilver> which doesn't appear often in practice I would wager
03:28:09 <quicksilver> so, simple answer, pretend it's utf8
03:28:19 <solrize_> hmm
03:28:56 <solrize_> i have a lot of indian script to deal with, is that likely to be outside the BMP?
03:29:20 <solrize_> that would need the surrogate pair stuff, it sounds like
03:29:25 <quicksilver> I didn't think so, no
03:29:41 <quicksilver> the 4-byte stuff is mostly really exotic
03:29:47 <quicksilver> indian should(?) be fine.
03:29:53 <solrize_> oh cool
03:29:56 <quicksilver> try utf8 and see if it works
03:30:05 <solrize_> great, that sounds like a plan, thanks
03:30:47 <lilac> will your string have embedded nulls?
03:31:00 <solrize_> hmm
03:31:14 <solrize_> i don't know
03:32:03 <solrize_> possibly not but i'm hesitant to count on that
03:32:41 <lilac> I would imagine that Data.Char.UTF8 will report an error on a null encoded as two bytes
03:33:29 <yitz> solrize_:  can you just pre-filter for misencoded null bytes?
03:33:38 <lilac> You could repeatedly call decodeOne, checking for nulls yourself
03:35:16 <solrize_> i guess.  i'll see if data.char.utf8 throws any errors
03:37:29 <quicksilver> lilac: why would it?
03:37:44 <quicksilver> lilac: the naive implementation of a UTF8 decode will silently accept that
03:37:48 <quicksilver> lilac: it's extra work to reject it.
03:38:17 <lilac> quicksilver: it's ill-formed, as i recall.
03:38:47 <quicksilver> as I say, the naive decoder will accept it.
03:38:58 <quicksilver> and the 2-byte null is a widely understood hack.
03:39:06 <quicksilver> not only the naive decoder but the *fast* decoder.
03:39:13 <quicksilver> you just want to decode UTF8 using bit operations.
03:39:27 <quicksilver> so, my first guess would be it will accept it :)
03:40:02 <mm_freak_work> quicksilver: the naÃ¯ve decoder must reject that, because it's not only non-standard, it's also a security issue
03:40:12 <quicksilver> mm_freak_work: why?
03:40:30 <mm_freak_work> because characters can be encoded in different ways, if they don't
03:40:39 <quicksilver> and that's a problem why?
03:40:45 <mm_freak_work> so you could encode a null byte without a naÃ¯ve parser detecting that
03:40:58 <quicksilver> well you check for nulls after decoding not before
03:41:06 <quicksilver> doesn't sound like a security risk to me.
03:41:32 <mm_freak_work> terminating strings at unexpected locations or otherwise injecting unwanted characters, because the program checks only for equality, not for equivalence
03:42:00 <quicksilver> bah
03:42:02 <quicksilver> that's daft.
03:42:08 <quicksilver> obviously you do security checks after decoding.
03:42:23 <quicksilver> trying to run any kind of security check on the UTF8 is silly.
03:42:33 <mm_freak_work> let's say you're accepting a string to be sent as part of an SQL query and the attacker could inject quotes and semicolons, because the UTF-8 decoder distinguishes between the different representations
03:42:49 <quicksilver> right.
03:42:51 <lilac> quicksilver: accepting C0 80 for null would be a bug
03:42:52 <quicksilver> and then you check for those
03:42:55 <quicksilver> after decoding
03:42:58 <quicksilver> how hard is that?
03:43:05 <lilac> quicksilver: see RFC 3629, section 3, last paragraph
03:43:07 <quicksilver> you obviously have to check for quotes and semicolons at some time.
03:43:18 <quicksilver> so the time to check is after decoding not before.
03:43:21 <mm_freak_work> so you'd need to decode, check, reencode, and that's crazy
03:43:26 <lilac> "Implementations of the decoding algorithm above MUST protect against decoding invalid sequences."
03:43:27 <mm_freak_work> the implementation should follow the standard
03:43:34 <quicksilver> why would you re-encode?
03:43:35 <mm_freak_work> history has shown that this IS indeed a problem
03:43:44 <quicksilver> lilac: I'm not denying it's in the spec.
03:43:46 <mm_freak_work> maybe because the SQL server expects UTF-8?
03:44:07 <quicksilver> mm_freak_work: well you definitely should never write an algorithm over UTF-8
03:44:10 <quicksilver> it's a transmission format
03:44:14 <quicksilver> not a useful data format.
03:44:20 <mm_freak_work> why so?
03:44:22 <daf> except in practice you don't send user input to the SQL server as SQL; you bind it as parameters
03:44:28 <lilac> quicksilver: so what is, in your mind, a useful data format?
03:44:35 <quicksilver> any internal checks (like injection checks) should be done on a proper char format
03:44:42 <quicksilver> lilac: [Char], or something along those lines
03:44:52 <quicksilver> lilac: something where chars have a natural identity
03:45:01 <mm_freak_work> quicksilver: what if your proper character format _is_ UTF-8?
03:45:03 <lilac> quicksilver: UCS-4 still doesn't encode one character per codepoint, though
03:45:07 <quicksilver> lilac: anyhow, I was saying, I'm not denying it's against spec.
03:45:13 <quicksilver> lilac: I didn't say UCS-4.
03:45:16 <quicksilver> lilac: I said [Char]
03:45:20 <daf> I don't understand why re-encoding is crazy
03:45:29 <solrize_> it sounds like utf8 is supposed to be like DER, where two code sequences are the same iff they encode identical strings
03:45:32 <lilac> quicksilver: Char is UCS-4 (or at least, equivalent to it)
03:45:38 <quicksilver> lilac: no, it's not.
03:45:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8087
03:45:43 <mm_freak_work> quicksilver: you should read the specâ€¦  it goes into some detail with the problems
03:45:44 <quicksilver> lilac: Char is one character by codepoint
03:45:52 <mm_freak_work> anyway, detecting invalid characters is easy
03:46:15 <lilac> quicksilver: how does that differ from UCS-4?
03:46:23 <lilac> quicksilver: other tha that UCS-4 specifies an encoding
03:46:34 <solrize_> well, either data.char.utf8 detects the invalid chars (in which case it breaks on this mutant java stuff) or else it doesn't detect them in which case it's buggy per rfc 3589...
03:47:00 <mm_freak_work> quicksilver: i really don't see why UTF-8 is not a suitable storage formatâ€¦  it's compact, yet supporting about every character used around the world
03:47:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8088
03:47:26 <lilac> quicksilver: ok, when i said UCS-4 still doesn't encode one character per codepoint, i meant one grapheme per codepoint
03:47:35 <solrize_> why is someone pasting these rxvt things?
03:48:09 <mm_freak_work> as a general purpose character coding, the implementation should do the right thing, then you don't risk running into such problems
03:48:12 <lilac> quicksilver: which neither UCS-4/UTF-32 nor Char has. so any text processing needs to handle weird stuffs anyway :)
03:48:36 <mm_freak_work> and you save decoding/reencoding (and possibly losing character information on the way)
03:48:37 <lilac> UTF-8 was designed such that you *can* use it as an internal representation
03:49:29 <quicksilver> lilac: ok, not one grapheme per codepoint. But that just points to unicodes general total brokeness.
03:49:40 <quicksilver> lilac: however for typical text process a Char is a useful unit.
03:50:21 <lilac> sure, there are quite a few algorithms which are more easily expressed over [Char] than over [Word8] in UTF-8
03:50:38 <mm_freak_work> quicksilver: a Char is a waste, if you do a lot of text processing
03:50:39 <chr1s> hey all, anybody familiar with type families?
03:51:03 <lilac> but there's also a couple of good reasons to use UTF-8 internallly rather than UCS-4
03:51:26 <quicksilver> mm_freak_work: I don't really accept that argument.
03:51:37 <lilac> if your inputs and outpus need to be in UTF-8 anyway, it saves you time, and it (almost) always wastes you space.
03:52:02 <quicksilver> mm_freak_work: a slight memory bloat is well worth the pay off of vastly simpler algorithms.
03:52:28 <lilac> quicksilver: i think 'vastly' is an exaggeration.
03:52:32 <mm_freak_work> quicksilver: UTF-8 characters seldomly have more than three characters, and for western character sets, they usually have only one and for some accents two
03:52:35 <quicksilver> consider the case where you have to split a string at word boundaries to wrap it whilst displaying it.
03:52:45 <quicksilver> mm_freak_work: Yes, I know that.
03:53:13 <mm_freak_work> quicksilver: using a proper UTF-8 library, you don't need to care about all that
03:53:20 <lilac> quicksilver: that requires conversion to graphemes, which is, i think, more complex than UTF-8 handling.
03:53:26 <mm_freak_work> you only need to care about the UTF-8-ness, when you compare strings or sort them
03:53:44 <lilac> it also requires grapheme -> glyph conversion to figure out widths.
03:54:09 <solrize_> i think i may also have to convert NKFC to NKFD or vice versa
03:54:26 <solrize_> so i have to decode this crap
03:54:28 <lilac> solrize_: isn't unicode a joy to work with?
03:54:32 <solrize_> but i think there's not likely to be nulls
03:55:03 <quicksilver> mm_freak_work: I want to use generic list algorithms for generic list stuff.
03:55:09 <solrize_> lilac, yecch :)
03:55:11 <quicksilver> mm_freak_work: takeWhile, dropWhile, etc.
03:56:08 <mm_freak_work> quicksilver: i know what you meanâ€¦  you can still convert from [Word8] to String temporarilyâ€¦  haskell's laziness is a virtue for that
03:56:13 <solrize_> i want to use bytestrings for this stuff so i can mmap the file and use the mmap to bytestring module
03:56:21 <mbz> yarr
03:56:23 <quicksilver> but why do it temporarily, I don't see the point?
03:56:35 <quicksilver> [Char] is obviously a better model than UTF8
03:56:43 <quicksilver> I take lilac's point that it isn't perfect
03:56:44 <mm_freak_work> quicksilver: because in haskell (because it's lazy) it's exactly equivalent to interpreting UTF-8
03:57:04 <quicksilver> laziness is really irrelevant here.
03:57:11 <quicksilver> I'm talking about sensible program design.
03:57:14 <lilac> like so many things, it's a compromise. in Haskell, I would never use [Word8] because the list overhead makes it *worse* than [Char]...
03:57:28 <mm_freak_work> it is relevant, because interpreting a UTF-8 string is a matter of a fold
03:57:37 <quicksilver> I would design the core of my program to work on Chars because that's the closest thing we have to a sensible type.
03:57:40 <lilac> never for processing, that is. may as well deocde first.
03:57:50 <quicksilver> Word8 (under UTF8) is not remotely sensible.
03:57:56 <quicksilver> Grapheme or Glyph would be more sensible
03:57:59 <quicksilver> for many cases.
03:58:02 <quicksilver> but we don't have that.
03:58:15 <mm_freak_work> quicksilver: that's ok for most purposes, but your point was that there is no problem with allowing invalid characters, and that's simply not true
03:58:20 <lilac> quicksilver: i completely agree. however, in a C program for a restricted memory environment or a program which handles huge amounts of text, i would consider UTF-8
03:58:38 <quicksilver> lilac: maybe but that's a specific space optimisation.
03:58:45 <quicksilver> lilac: I would not make it prematurely.
03:58:51 <quicksilver> for that would be the root of all evil :)
03:59:07 <lilac> quicksilver: it's not premature if i *know* i'll be handling huge amounts of text
03:59:25 <quicksilver> lilac: it's premature until you've identified that your memory pressure is really a problem in practice.
03:59:41 <quicksilver> lilac: once you've identified that the pressure really is a problem, and that this change is enough to solve it
03:59:44 <quicksilver> you've made your case.
03:59:46 <quicksilver> then sure
03:59:47 <lilac> i disagree
03:59:48 <mm_freak_work> quicksilver: or it's a design decision
04:00:21 <quicksilver> mm_freak_work: the sensible place to impose security restrictions like occurence of nulls or "," or ";" is in a Char-like domain.
04:00:21 <lilac> if I know i need to have 100M characters in memory, and they'll be mostly ASCII, and i need to minimize my memory usage, then UCS-4 is an error
04:00:37 <solrize_> memory pressure is a problem in the real world, this program i'm trying to write is for the purpose of escaping memory pressure in the java app
04:00:39 <lilac> and because i'm talking about C, rewriting to use UTF-8 everywhere will be a very significant cost
04:00:41 <mm_freak_work> as said, even if UTF-8 is your internal storage coding, you can disregard that most of the timeâ€¦  you really only need to take it into account when interpreting (comparing or sorting)
04:00:51 <quicksilver> because that's the language of the security constraint.
04:00:53 <yitz> lilac: if you're sure that your huge amounts of text will be treated as opaque binary data. if you need them interpreted as characters, utf8 is a mistake, i agree with quicksilver.
04:01:14 <lilac> yitz: sometimes other constraints are more important than the elegance of the code
04:01:21 <lilac> like memory usage
04:01:45 <mm_freak_work> quicksilver: a lot of programmers said thatâ€¦  and then unexpected problems appeared with an error-tolerating decoder
04:01:45 <yitz> lilac: it's not just elegance. utf8 is the wrong optimization. most probably.
04:01:47 <lilac> assuming that 'clean code' is the #1 requirement is not valid.
04:02:00 <solrize_> i'd hope that unicodestring would use utf8 under the covers and still be elegant at the higher levels
04:02:19 <mm_freak_work> you have an easier time decoding UTF-8 correctly
04:02:47 <lilac> yitz: ok, that argument i buy. but then one needs to design a new representation, and implement the relevant functionality for it, and so on. and chances are, it won't be any better than utf-8 anyway, since utf-8 is a pretty good representation given its goals.
04:02:51 <quicksilver> solrize_: it could do that, sure. But that's requiring a great deal of complexity of the library.
04:03:05 <quicksilver> solrize_: if the library author does that, and gets it right, then sure, that's a win.
04:03:15 <quicksilver> but the way it would get it right is by exposing an interface that looks like [Char].
04:03:21 <quicksilver> Which means that, in a way, I'm still right :)
04:03:28 <solrize_> well dealing with that complexity is why that project has been cooking for so long, right?
04:03:34 <yitz> lilac: if you can work with your text once small chunk at a time, then you can keep it in utf8 (opaque binary glob), decode and re-encode small chunks. does that fit your model?
04:03:58 <yitz> lilac: or if you are limited only to certain languages, you can use some other existing 8-bit encoding.
04:04:03 <dmwit> Aw, man, comonad.com got reddit-smashed.
04:04:04 <lilac> yitz: that sounds like a good solution, if it's workable in the case of interest. and i'd certainly agree that's better than processing utf-8
04:04:51 <quicksilver> yitz: your chunker needs to be careful of word boundaries (and any other semantically relevant boundaries like graphemes or glyphs)
04:04:59 <quicksilver> yitz: but it certainly can be an optimal approach.
04:05:15 <yitz> quicksilver: yep, so even then utf8 is not trivial.
04:05:24 <quicksilver> if the chunk decoding code is small enough to fit in the instruction cache, and the chunk fits in the data cache, it's a big win.
04:06:08 <lilac> i imagine you'd want to decode UTF-8 -> graphemes, though, not to UCS-4.
04:06:14 <solrize_> i think most of these strings should be pretty short.  in fact what i -really- want is a compression function, that gzips them starting from some fixed compressor state...
04:06:39 <yitz> quicksilver: if the processing can ignore trailing garbage, then the chunker doesn't need to know about character boundaries.
04:07:25 <quicksilver> yitz: you mean the processor returns the garbage back to be added to the next chunk? or remembers it?
04:07:29 <quicksilver> yes, I've written code like that.
04:07:36 <quicksilver> feels like the abstraction is slightly clumsy though.
04:07:50 <yitz> quicksilver: or just tosses it. yeah, something like that.
04:08:28 <yitz> quicksilver: mm, well, it's actually somewhat general. nothing special about utf-8. like solrize_ says, you could also use gzip, for example.
04:08:33 <lilac> yitz: i'm not sure that follows. suppose i have U+2708 (airpane) followed by U+1DC2 (combining snake under), i don't want to process them separately, even if the boundary between them is at the end of a chunk
04:08:44 <quicksilver> lilac: I view the whole grapheme/glyph/codepoint problem as a (huge) problem with unicode.
04:09:07 <quicksilver> lilac: one which doesn't really bother me in the slightest since I only ever use languages where the correspondance is 1-1.
04:09:18 <quicksilver> lilac: which makes my code every bit as unportable as it used to be when I used to use ASCII.
04:09:29 <quicksilver> lilac: so the unicode revolution failed to solve the problem it was supposed to solve :)
04:09:48 <yitz> lilac: true. it would only work if the processing layer is able to recognize those problems, or is independent of them.
04:10:08 <lilac> quicksilver: in many of our day-to-day careers, we do need to deal with unicode, and we need to get it right. so saying "unicode is hard, let's go shopping" isn't really an answer :(
04:10:59 <quicksilver> lilac: that wasn't an answer. it was a statement of a problem.
04:11:26 <yitz> quicksilver: i'd say the "let's go shopping" part was an answer :)
04:11:32 <quicksilver> lilac: I was hopign that the unicode revolution would enable lazy programmers like me used to western european languages to write portable code more easily.
04:11:36 <quicksilver> lilac: epic fail.
04:11:41 <lilac> quicksilver: absolutely.
04:12:15 <lilac> quicksilver: but without combining characters, i think (?) the number of charaters would be insane
04:12:33 <quicksilver> if they forced all java programmers to work exclusively in hindi and sanskrit for 5 years of their career
04:12:39 <quicksilver> maybe we'd see some progress :)
04:12:44 <yitz> quicksilver: i don't think an easy solution is possible. unicode encodes the entire world, which is rather large and complex.
04:13:06 <kalven> aren't a majority of java programmers well versed in hindi these days?
04:13:15 <lilac> kalven: hehe :)
04:13:16 <yitz> kalven: :)
04:13:47 <quicksilver> yitz: a clear acknowledgement of the difference between codepoint, grapheme and glyph and some clear data types which enable programmers who are unused to the issues involved make a decent stab at getting it right, woudl be nice.
04:14:13 <cjs> Hey, are there any Haskell QuickChecks that shrink the test cases to find the minimal failure?
04:14:15 <quicksilver> kalven: I think you'll find a significant number of them have their "hindi literacy" lower than their "english literacy"
04:14:24 <quicksilver> cjs: yes, as of version something recent.
04:14:28 <quicksilver> cjs: v2, maybe?
04:14:35 <quicksilver> kalven: and they tend to program in english
04:14:37 <cjs> There's only a 1.1 on hackage.
04:14:38 <MedeaMelana> Isn't that what SmallCheck is for?
04:14:39 <yitz> quicksilver: so it's a bug in the documentation then
04:14:44 <quicksilver> kalven: so even they often avoid the problem.
04:14:57 <quicksilver> yitz: yes
04:15:00 <kalven> quicksilver: it was (mostly) a joke :)
04:15:04 <quicksilver> yitz: and a deficiency in the common apis
04:15:08 <quicksilver> kalven: interesting point nonetheless
04:15:26 <yitz> quicksilver: yeah, the apis are a mess
04:15:36 <yitz> quicksilver: including Haskell still, unfortunately
04:15:54 <yitz> that one we could fix. hey?
04:16:27 <cjs> MedeaMelana: no, SmallCheck is a bit different.
04:16:31 <quicksilver> sure. I don't know the answers though.
04:16:54 <cjs> I knew a few of the answers, since I do a lot of Japanese stuff, myself.
04:17:17 <quicksilver> I'm an ignorant western programmer, as previously noted.
04:17:29 <MedeaMelana> cjs: ok
04:17:43 <quicksilver> dcoutts , dons : I'm sure one of you pointed me toward minimisation for quickcheck once before.
04:17:52 <quicksilver> cjs: maybe the minimisation is in one of the papers?
04:17:54 <dcoutts> quicksilver: it's in QC2 I think
04:18:05 <cjs> Ah, which is in darcs.
04:18:29 <yitz> cjs: i bump into rtl often enough. with a cjk person, a hindi person, and an rtl person, we've got most of the weird cases covered. we can leave cuneiform hieroglyphics etc. for later
04:22:17 <HunterXHunter> @pl \t a b -> a `div` length b
04:22:17 <lambdabot> const ((. length) . div)
04:22:40 <FordCortina> i'd like a zipWith function but if one list is shorter than the other i'd like to keep the entries in the longer list. is there anything in the standard library that will do this?
04:23:46 <MedeaMelana> FordCortina: no, but you can use this one:
04:23:49 <MedeaMelana> zipWith' :: (a -> a -> a) -> [a] -> [a] -> [a]
04:23:49 <MedeaMelana> zipWith' f = g where
04:23:49 <MedeaMelana>   g (x:xs) (y:ys) = f x y : g xs ys
04:23:49 <MedeaMelana>   g    xs     ys  = xs ++ ys
04:24:25 <FordCortina> thanks
04:29:46 <cjs> Is there a way to get darcs to print dates in ISO format?
04:32:16 <frwmanners> MedeaMelana: Is xs ++ [] efficient, or does it take linear time to reconstruct the list?
04:32:33 <cjs> I think it's linear.
04:33:02 <frwmanners> So if zipWith' cares, it should probably have g xs [] = xs
04:33:10 <cjs> snoc on ByteStrings might be more efficient, if it happens to apply.
04:33:44 <EvilTerran> ?src (++)
04:33:44 <lambdabot> []     ++ ys = ys
04:33:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:33:44 <lambdabot> -- OR
04:33:44 <lambdabot> xs ++ ys = foldr (:) ys xs
04:33:44 <lambdabot> -- In lambdabot, this is generalised to:
04:33:46 <lambdabot> (++) = mappend
04:34:10 <EvilTerran> frwmanners, i think that would make it stricter than the report version. not sure, though
04:34:22 <EvilTerran> adding that special case to (++) definitely would make it too stric
04:35:12 <frwmanners> EvilTerran: In general, sure
04:35:27 <yitz> @src (++)
04:35:28 <lambdabot> []     ++ ys = ys
04:35:28 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:35:28 <lambdabot> -- OR
04:35:28 <lambdabot> xs ++ ys = foldr (:) ys xs
04:35:28 <lambdabot> -- In lambdabot, this is generalised to:
04:35:29 <lambdabot> (++) = mappend
04:35:35 <EvilTerran> yitz, er, i just did that
04:35:49 <yitz> EvilTerran: took my eye off the ball
04:36:16 <MedeaMelana> frwmanners: Adding a special case might be more efficient, but you probably won't notice the difference
04:36:20 <byorgey> frwmanners: xs ++ [] is constant time if you never use the resulting list. =)
04:36:25 <Botje> @src mappend []
04:36:25 <lambdabot> Source not found. Are you on drugs?
04:36:33 <Botje> @src [] mappend
04:36:33 <lambdabot> Source not found. My brain just exploded
04:36:34 <EvilTerran> yitz, ... you read IRC with a ball? what, are you some gypsy psychic using the IP-over-telepathy protocol?
04:36:37 <Botje> *sigh*
04:36:39 <frwmanners> byorgey: true
04:36:47 <EvilTerran> byorgey, the same goes for any expression, though
04:36:51 <yitz> @src Monoid mappend
04:36:52 <lambdabot> Source not found.
04:37:01 <byorgey> well, my point is that it will only add a constant overhead to each element that you examine
04:37:04 <MedeaMelana> frwmanners: traversing the list takes linear time either way
04:37:08 <yitz> @src [] mappend
04:37:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:37:15 <yitz> ok, ok
04:37:19 <cjs> @vixen
04:37:19 <lambdabot> what's the matter?
04:37:25 <EvilTerran> however, yes, (xs ++ []) adds time proportional to how far down the list you traverse, so won't affect the asymptotic complexity if you do it a constant number of times
04:37:33 <cjs> lamdabot's in a bad mood tonight.
04:37:47 <quicksilver> MedeaMelana: yup, but it's still (linear time) worse :)
04:37:47 <yitz> cjs: not as bad as yesterday
04:38:10 <EvilTerran> ?vixen are you sulking?
04:38:10 <lambdabot> i truely am
04:38:11 <cjs> "Broccoli brains"?
04:38:54 <MedeaMelana> If you add an extra case, then it has an extra case to check. Does that matter?
04:39:05 <yitz> is there someone whose job it is to regularly add new insults to LB's patter?
04:39:07 <EvilTerran> only by a constant factor :)
04:39:28 <quicksilver> MedeaMelana: it checks cases in order.
04:39:40 <SamB_XP> MedeaMelana: it's more the fact that it would then need to reduce the second argument to WHNF
04:39:59 <EvilTerran> zipWith has to anyway, so that's no problem
04:40:02 <EvilTerran> but (++) doesn't
04:40:17 <EvilTerran> > take 2 $ [1,2] ++ undefined
04:40:20 <lambdabot>  [1,2]
04:40:27 <EvilTerran> ... why did she CTCP TIME me?
04:40:46 <SamB_XP> EvilTerran: I guess someone asked her to?
04:40:52 <EvilTerran> > let xs ++ [] = xs; xs ++ ys = xs P.++ ys in take 2 $ [1,2] ++ undefined
04:40:53 <lambdabot>  Exception: Prelude.undefined
04:41:04 <yitz> EvilTerran: I did it. "keep your eyes on the ball" is a baseball saying
04:41:10 <SamB_XP> @localtime #haskell
04:41:19 <frwmanners> so the best is g xs _ = xs
04:41:23 <yitz> @localtime lambdabot
04:41:23 <lambdabot> I live on the internet, do you expect me to have a local time?
04:41:30 <MedeaMelana> Ah, interesting
04:41:41 <EvilTerran> yitz, i know. also applies to cricket.
04:41:45 <EvilTerran> yitz, i was being silly
04:41:51 <yitz> EvilTerran: there you go then
04:42:24 <cladhaire> :r
04:42:41 <yitz> how can you keep your eyes on the ball in cricket? everyone is too busy constantly running back and forth
04:43:02 <SamB_XP> yitz: he suggests you are using an IP-over-telepathy protocol, and you wonder where he lives? huh?
04:44:32 <EvilTerran> SamB_XP, well, y'know, in Soviet Russia, the internet sends messages over YOU!
04:45:07 * yitz thinkd EvilTerran has spent too much time reading slashdot
04:45:10 <cjs> Yay! Shrinking!
04:45:43 <yitz> cjs: so how is it done?
04:45:46 <EvilTerran> i never read slashdot
04:45:50 <cjs> I dunno. I learn that tomorrow. :-)
04:47:00 <cjs> But in the general sense, you move integers towards zero, make lists smaller, etc., until you can find the border between where it passes and fails. John Hughes said today that it was based on a similar idea called "delta debugging."
04:47:35 <yitz> cjs: no, I thought found some new feature that automates it
04:47:42 <cjs> It is automated.
04:48:59 <hpaste>  cjs pasted "Sample QuickCheck Shrinkage Output" at http://hpaste.org/8089
04:51:42 <quicksilver> I have written custom shrinkages on my own quickcheck results.
04:51:55 <quicksilver> normally things like : I have [String] but I know only the order + lengths matters
04:52:06 <quicksilver> so I blat them with "1111111" "2222222" etc preserving length.
04:52:10 <quicksilver> and order.
04:53:10 <EvilTerran> > transpose []
04:53:11 <lambdabot>  []
04:56:21 <yitz> ah, I see, the new QC always shrinks automatically. I guess that's good. It could conceivably make it more complicated to write Arbitrary instances though, couldn't it?
04:56:26 <EvilTerran> @check let zipAllWith f _ _ (x:xs) (y:ys) = f x y : zipAllWith xs ys; zipAllWith _ f _ xs [] = map f xs; zipAllWith _ _ f [] ys = map f ys in liftM2 (==) transpose (foldr (zipAllWith (:) return id) []) :: [[Int]] -> Bool
04:56:27 <lambdabot>  Couldn't match expected type `[t]'
04:56:31 <EvilTerran> ...
04:56:46 <vixey> hi cmeme
04:57:06 <EvilTerran> doh
04:57:27 <yitz> get lost cmeme
04:58:19 <EvilTerran> @check let zipAllWith f g h (x:xs) (y:ys) = f x y : zipAllWith f g h xs ys; zipAllWith f g h xs [] = map g xs; zipAllWith f g h [] ys = map h ys in liftM2 (==) transpose (foldr (zipAllWith (:) return id) []) :: [[Int]] -> Bool -- MedeaMelana
04:58:19 <quicksilver> yitz: didn't arbitrary instances always have a notion of 'size' built in?
04:58:22 <lambdabot>  OK, passed 500 tests.
04:58:30 <EvilTerran> there you go, it works :)
04:58:34 <quicksilver> yitz: I assume that's the notion of size it shrinks against.
04:58:42 <MedeaMelana> cool
04:58:49 <Zao> yitz: Conversing with passive bots rarely help.
04:58:59 <vixey> lol
04:59:28 <cjs> Holy crap, LB has QC built in?
04:59:41 <yitz> quicksilver: yeah. it's always been used for growing. will it always be the case that it will work for shrinking also? probably...
04:59:41 <MedeaMelana> Apparently =)
04:59:46 <vixey> @check \quickcheck -> True
04:59:47 <lambdabot>  OK, passed 500 tests.
05:00:23 <MedeaMelana> @check \x y -> const id x y == flip const x y
05:00:24 <lambdabot>  OK, passed 500 tests.
05:00:36 <MedeaMelana> I wonder what types it chose
05:00:45 <yitz> Zao: i wasn't conversing, i was demanding.
05:00:50 <MedeaMelana> @pl \x y -> const id x y == flip const x y
05:00:50 <lambdabot> ap (ap . ((==) .) . const id) (const id)
05:00:59 <MedeaMelana> @src ap
05:00:59 <lambdabot> ap = liftM2 id
05:01:10 <MedeaMelana> @type ap
05:01:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:01:29 <MedeaMelana> @check ap (ap . ((==) .) . const id) (const id)
05:01:30 <lambdabot>  OK, passed 500 tests.
05:04:41 <tibell> anyone know any of any papers on writing a bytecode interpreter for functional languages?
05:05:53 --- mode: ChanServ set +o quicksilver
05:05:56 --- mode: quicksilver set +b *!*n=cmeme@*.b9.com
05:05:56 --- kick: cmeme was kicked by quicksilver (quicksilver)
05:06:02 --- mode: quicksilver set -o quicksilver
05:06:09 <yitz> yay!
05:06:59 <vixey> tibell: There's a haskell -> JVM compiler (lambdavm) and also a haskell interpreter that works via combinators (in the latest Monad Reader)
05:07:29 <cjs> What's up with this cmeme stuff? I didn't see a word....
05:07:41 <quicksilver> you probably have joins/quits hidden then
05:07:59 <cjs> Yes. First thing I turn off when I join a channel. I wish that there were a preference for it.
05:08:17 <tibell> vixey: cool! I'll have a look
05:08:18 <MedeaMelana> How do I turn those off?
05:09:01 <cjs> tibell: Though the JVM one (Jaskell) seems a bit moribund now, and it's just compiling for a bytecode machine, rather than being an interpreter itself.
05:10:04 <quicksilver> tibell: YHC contains such a thing.
05:10:11 <quicksilver> tibell: mabye someone wrote a paper on that?
05:10:25 <quicksilver> malcolmw: did anyone write a paper on the YHC bytecode interpreter?
05:10:35 <cjs> YHC has one?
05:10:44 <quicksilver> that's what I thought.
05:11:54 <cjs> It wasn't my impression. Anyway, you could send a note to Neil Mitchell and ask him; he seems pretty aproachable.
05:12:00 <cjs> s/apr/appr/
05:12:09 <cjs> No, I take that back...
05:12:16 <cjs> ?spell approach
05:12:30 <cjs> @spell approach
05:12:49 <cjs> Lambdabot doesn't help with spelling?
05:12:59 <MedeaMelana> approach is right
05:14:34 <vixey> @w80 reproach
05:14:35 <lambdabot> *** "reproach" wn "WordNet (r) 2.0"
05:14:35 <lambdabot> reproach
05:14:35 <lambdabot>      n 1: a mild rebuke or criticism; "words of reproach"
05:14:35 <lambdabot>      2: disgrace or shame; "he brought reproach upon his family"
05:14:35 <lambdabot>      v : express criticism towards; "The president reproached the
05:14:37 <lambdabot>          general for his irresponsible behavior" [syn: {upbraid}]
05:15:44 <ivanm> is there a function that does something like this? \ f x y -> (f x) == (f y)
05:16:02 <ivanm> the @pl forms are even uglier, but I'd have though that a function like that would be commonly used :s
05:16:19 <MedeaMelana> @src on
05:16:19 <lambdabot> (*) `on` f = \x y -> f x * f y
05:16:29 <MedeaMelana> @src on (==)
05:16:30 <lambdabot> Source not found. Sorry.
05:16:43 <HunterXHunter> @pl  \ f x y -> (f x) == (f y)
05:16:44 <lambdabot> flip =<< (((.) . (==)) .)
05:16:49 <HunterXHunter> wow thats ugly
05:16:50 <MedeaMelana> hehe
05:17:07 <ivanm> that looks like what I want, thanks MedeaMelana!
05:17:38 <ivanm> @hoogle on
05:17:38 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:17:38 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
05:17:38 <lambdabot> Data.Function :: module
05:21:29 <tibell> quicksilver: I'm trying to work a direct threading interpreter in C for a tiny strict functional language, just for fun
05:21:34 <tibell> quicksilver: I started today :)
05:21:47 <vixey> What is direct threading interpreter?
05:22:28 <vixey> :t (=<< (((.) . (==)) .))
05:22:30 <lambdabot> forall b a (f :: * -> *) (f1 :: * -> *). (Functor f1, Eq a, Functor f) => (f1 (f a -> f Bool) -> f1 a -> b) -> f1 a -> b
05:22:51 <vixey> that is one ugly combinator
05:23:42 <malcolmw> quicksilver: there is a chapter in a PhD Thesis about the Yhc bytecode interpreter
05:25:03 <tibell> malcolmw: which thesis?
05:25:31 <tibell> vixey: it's a implementation technique for interpreter to decrease the number of branches
05:25:34 <malcolmw> tibell: there is also a paper on the implementation of Gofer (predecessor to Hugs) by Mark Jones, but I can't remember whether it talks in detail about the bytecode interpreter
05:25:59 <vixey> do you pass continuations around or what?
05:26:04 <malcolmw> tibell: a Thesis that I am examining, so it is not yet published :-)
05:30:52 <gubagem> how do I "catch" exceptions from read someString::Type
05:31:13 <yitz> gubagem: use reads instead of read
05:31:37 <gubagem> yitz: how do i use reads then :-)
05:32:16 <tibell> vixey: me? I will start with a simple strict lambda calculus with integers
05:32:16 <yitz> @type let maybeRead = listToMaybe . map fst . reads in maybeRead
05:32:19 <lambdabot> forall a. (Read a) => String -> Maybe a
05:32:49 <vixey> what is the direct threading though?
05:33:07 <yitz> > reads "42xyz" :: [(Int, String)]
05:33:08 <lambdabot>  [(42,"xyz")]
05:33:43 <yitz> @let maybeRead = listToMaybe . map fst . reads
05:33:44 <lambdabot> <local>:3:36:     Ambiguous type variable `a' in the constraint:       `Read ...
05:34:20 <yitz> @let maybeRead = listToMaybe . map fst . reads :: Read a => String -> Maybe a
05:34:20 <lambdabot> <local>:3:12:     Ambiguous type variable `a' in the constraint:       `Read ...
05:35:30 <yitz> > let maybeRead = listToMaybe . map fst . reads in maybeRead "42" :: Maybe Int
05:35:31 <lambdabot>  Just 42
05:35:38 <yitz> > let maybeRead = listToMaybe . map fst . reads in maybeRead "42xyz" :: Maybe Int
05:35:40 <lambdabot>  Just 42
05:35:47 <yitz> > let maybeRead = listToMaybe . map fst . reads in maybeRead "xyz42" :: Maybe Int
05:35:49 <lambdabot>  Nothing
05:36:04 <gubagem> so i just check for [] being "returned" from reads and that means it "crapped" itself?
05:36:38 <yitz> gubagem: yep
05:38:33 <gubagem> this should all result in loc/2 Java -> Haskell where loc="lines of code"::Integer (i know its not totally right but it gets my point across)
05:44:11 <vincenz> tibell: blocked out my calendar (:
05:44:42 <lilac> > let maybeRead s = listToMaybe $ do (x, rest) <- reads s; guard (rest == ""); return x in maybeRead "123" :: Maybe Int
05:44:43 <lambdabot>  Just 123
05:44:48 <lilac> > let maybeRead s = listToMaybe $ do (x, rest) <- reads s; guard (rest == ""); return x in maybeRead "123hello" :: Maybe Int
05:44:50 <lambdabot>  Nothing
05:45:52 <yitz> > let maybeRead = listToMaybe . map fst . filter (not.null.snd) . reads in maybeRead "42xyz" :: Maybe Int
05:45:53 <lambdabot>  Just 42
05:46:05 <yitz> > let maybeRead = listToMaybe . map fst . filter (null.snd) . reads in maybeRead "42xyz" :: Maybe Int
05:46:06 <lambdabot>  Nothing
05:46:09 <yitz> better
05:46:26 <yitz> > let maybeRead = listToMaybe . map fst . filter (null.snd) . reads in maybeRead "42" :: Maybe Int
05:46:27 <lambdabot>  Just 42
05:47:20 <mm_freak1work> @src listToMaybe
05:47:20 <lambdabot> listToMaybe []        =  Nothing
05:47:21 <lambdabot> listToMaybe (a:_)     =  Just a
05:49:01 <lilac> > let maybeRead s = do [a] <- map fst . filter (null.snd) . reads; return a in maybeRead "42" :: Maybe Int
05:49:02 <lambdabot>  Couldn't match expected type `Maybe Int'
05:50:17 <gubagem> arrrs incorrect indentation :-(
05:52:45 <lilac> > let tryRead s = do [a] <- return . map fst . filter (null.snd) $ reads s; return a in tryRead "42" :: Maybe Int
05:52:46 <lambdabot>  Just 42
05:52:52 <lilac> > let tryRead s = do [a] <- return . map fst . filter (null.snd) $ reads s; return a in tryRead "42" :: Either String Int
05:52:53 <lambdabot>  Right 42
05:54:18 <hpaste>  gubagem pasted "how is this indentation wrong?" at http://hpaste.org/8090
05:54:44 <vixey> don't you need to write let more times/
05:55:03 * gubagem sniffles at sarcasm(?)
05:55:14 <vixey> I mean
05:55:21 <vixey> new itemList args=do let myName=(head args)
05:55:21 <vixey>                      let myPrice=reads (head $ tail args)::[(Double,String)]
05:55:24 <vixey> rather than
05:55:24 <vixey> new itemList args=do let myName=(head args)
05:55:24 <vixey>                          myPrice=reads (head $ tail args)::[(Double,String)]
05:55:26 <hpaste>  yitz annotated "how is this indentation wrong?" with "fixed, I think" at http://hpaste.org/8090#a1
05:56:20 <tibell> vincenz: :)
05:57:04 <hpaste>  yitz annotated "how is this indentation wrong?" with "now maybe fixed" at http://hpaste.org/8090#a2
05:57:20 <lilac> gubagem: your last let lacks an in
05:57:44 <pejo> lilac, he's in a do-block.
05:57:51 <lilac> pejo: good point :)
05:57:52 <yitz> gubagem: "do return foo" is the same as "return foo" if there's nothing else in the do block.
05:59:26 <dbueno> @seen dcoutts_
05:59:26 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 19h 22m 58s ago.
05:59:31 <dbueno> @seen dcoutts
05:59:31 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 11m 1s ago.
05:59:33 <pejo> gubagem, does it work if you move the if's to the same indentation level as the let's?
05:59:48 <ddarius> vixey: No
05:59:53 <dcoutts> hia dbueno
06:00:26 <dbueno> dcoutts, hey.  I'm trying to reduce the size of my test case so I can debug it reasonably.
06:00:35 <dcoutts> dbueno: btw I looked at your code last night, but I was a bit drunk so didn't fully understand it :-)
06:00:44 <ddarius> The if needs to be unindented.
06:00:53 <dbueno> dcoutts: I wish I'd been a bit drunk last night. =]
06:00:59 <dbueno> dcoutts: the package-db flag to cabal doesn't seem to work as I expect.
06:01:11 <dcoutts> dbueno: oh?
06:01:23 <hpaste>  quicksilver annotated "how is this indentation wrong?" with "indentation fixed (no other changes made)" at http://hpaste.org/8090#a3
06:01:29 <dbueno> dcoutts: ghc-pkg list shows two package.confs, one with a lot of packages, and one with three.
06:01:30 <quicksilver> gubagem: that's how you do it.
06:01:51 <quicksilver> gubagem: personally if there is only one real statement in the do, I don't use it
06:01:55 <quicksilver> so I'd use let...in
06:02:04 <dbueno> dcoutts: I told cabal to use the one with three, but it still sees all the packages from the one with a bunch.  I guess that's because the one with many packages includes stuff that comes with ghc, e.g. containers?
06:02:05 <quicksilver> and I'd rather those uses of 'reads' in a friendly wrapper.
06:02:41 <dbueno> I probably should have been better about installing new packages in a local (or at least different) db, instead of into the ghc package.conf
06:02:51 <dcoutts> dbueno: yes you can't easily get away without using the global package db since it includes all the core libs, if you only used the a local one it'd have to include all deps transitively, including base and rts.
06:03:24 <dbueno> dcoutts: Right;  well, crap.  I guess I should remove all the stuff I've installed.
06:03:33 <dcoutts> dbueno: if you're on debian or gentoo you'll find there's a backup global package db that has just the core libs
06:03:50 <dbueno> dcoutts: I'm on OS X.
06:04:00 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8086#a2
06:04:24 <yitz> gubagem: what does "badInput" do? Seems to me it must be just [].
06:04:35 <dbueno> dcoutts: Could I just back up the current package.conf and delete all the entries except the system libs?  or is redundant package info recorded somewhere else?
06:04:50 <dcoutts> dbueno: that'd work
06:04:58 <dbueno> dcoutts: k, I'll do that.
06:05:01 <dcoutts> dbueno: or you could make a fake package index in code
06:05:05 <yitz> gubagem: if so, in that case you are better off using "guard" instead of that whole if-then-else thing.
06:05:19 <dcoutts> dbueno: p1 = emptyInstalledPackageInfo { ... }
06:05:50 <dbueno> dcoutts: I think that's just another possibility for error ... I'll try the other way first.
06:05:59 <gubagem> yitz: i dont know much about guards
06:05:59 <dcoutts> 'k
06:06:25 <yitz> @src guard
06:06:25 <lambdabot> guard True  =  return ()
06:06:25 <lambdabot> guard False =  mzero
06:06:27 <gubagem> yitz: i got it to finally compile (peppered it with "in" and lots of indentation)
06:06:32 <yitz> mzero == []
06:06:39 * gubagem nods
06:06:52 <gubagem> im used to if then's though
06:07:28 <gubagem> reads is throwing junk at me now
06:08:07 <yitz> gubagem: if-then-else often makes things messy, Haskell lets us get rid of them.
06:08:07 <smg> hello.
06:08:17 <smg> how would you remove all "x" out of the string "this is a foobar string and xxx should be remove xxx"
06:08:59 <yitz> smg: filter (/= 'x')
06:09:05 <chessguy> > filter ((/-) x) ""this is a foobar string and xxx should be remove xxx""
06:09:06 <lambdabot>   Not in scope: `xxx'
06:09:23 <smg> does not work
06:09:26 <yitz> > filter (/= 'x') "this is a foobar string and xxx should be remove xxx"
06:09:26 <chessguy> > filter ((/=) 'x') "this is a foobar string and xxx should be remove xxx"
06:09:28 <lambdabot>  "this is a foobar string and  should be remove "
06:09:28 <lambdabot>  "this is a foobar string and  should be remove "
06:09:34 <gubagem> there ya go
06:09:38 <smg> erm
06:09:39 <quicksilver> smg: yes it does :P look, it works twice!
06:09:39 <vixey> filterOutX ('x':xs) = filterOutX xs
06:09:40 <smg> can i filter also both?
06:09:49 <smg> i mean can i have /= 'x' && /= 'a' ?
06:09:55 <ibid> dons: ayh?
06:09:58 <gubagem> sure why not
06:10:05 <vixey> > let filterOutX ('x':xs) = filterOutX xs in filterOutX "this is a foobar string and xxx should be remove xxx"
06:10:06 <lambdabot>   Non-exhaustive patterns in function filterOutX
06:10:12 <vixey> > let filterOutX ('x':xs) = filterOutX xs in filterOutX "this is a foobar string and xxx should be remove xxx" ++ repeat 'e'
06:10:14 <lambdabot>   Non-exhaustive patterns in function filterOutX
06:10:16 <chessguy> vixey:  you forgot []
06:10:16 <smg> yitz: do you know that?
06:10:28 <yitz> > filter (\c -> c/= 'x' && c/='a') "this is a foobar string and xxx should be remove xxx"
06:10:29 <lambdabot>  "this is  foobr string nd  should be remove "
06:10:35 <vixey> > let filterOutX ('x':xs) = filterOutX xs ; filterOutX (y:xs) = y:filterOutX xs in filterOutX "this is a foobar string and xxx should be remove xxx" ++ repeat 'e'
06:10:37 <lambdabot>   Non-exhaustive patterns in function filterOutX
06:10:49 <smg> filter (\x -> x /= 'x' && x /= ',') "foo bar,,,,,,, xxxx"
06:10:50 <vixey> > let filterOutX ('x':xs) = filterOutX xs ; filterOutX (y:xs) = y:filterOutX xs in filterOutX ("this is a foobar string and xxx should be remove xxx" ++ repeat 'e')
06:10:51 <lambdabot>  "this is a foobar string and  should be remove eeeeeeeeeeeeeeeeeeeeeeeeeeeee...
06:10:52 <chessguy> > filter (not . elem "ax") "this is a foobar string and xxx should be remove xxx"
06:10:52 <lambdabot>  Couldn't match expected type `[[Char]]'
06:11:13 <gubagem> oh my i need to extract the data from the return of reads
06:11:46 <chessguy> > filter (not . flip elem "ax") "this is a foobar string and xxx should be remove xxx"
06:11:47 <lambdabot>  "this is  foobr string nd  should be remove "
06:12:04 <quicksilver> gubagem: let maybeRead x = case reads x of [(v,"")] -> Just v | _ -> Nothing
06:12:05 <yitz> gubagem: yeah. that's why quicksilver said it's more convenient to use a nice wrapper. like "maybeRead" we were talking about before.
06:12:34 <smg> is that also with map possible?
06:12:38 <smg>  filter (\x -> x /= 'x' && x /= ',') "foo bar,,,,,,, xxxx"
06:12:40 <smg> it is?
06:12:41 <yitz> > let maybeRead = listToMaybe . map fst . filter (null.snd) . reads in maybeRead "42xyz" :: Maybe Int
06:12:50 <smg> map (\x -> x /= 'x') "foo bar"?
06:12:51 <lambdabot>  Nothing
06:13:39 <smg> map (\x -> if (x /= 'o') then x else ' ') "foo bar"
06:13:40 <yitz> smg: what do you want to do with map?
06:13:42 <smg> why can't i use ' '
06:13:48 <smg> yitz: you see?
06:13:59 <yitz> ah
06:14:08 <smg> i have spaces but i want to "delete" it
06:14:27 <smg> is possible?
06:14:31 <smg> i mean with map
06:14:42 <hpaste>  lilac annotated "how is this indentation wrong?" with "refactor" at http://hpaste.org/8090#a4
06:14:42 <chessguy> > map (\x -> if (x /= 'o') then x else ' ') "foo bar"
06:14:43 <lambdabot>  "f   bar"
06:14:55 <chessguy> smg:  is that what you want?
06:15:08 <quicksilver> yitz: I have to say my version is more pleasant to read than yours :P
06:15:09 <yitz> > let {smg 'o' = ' '; smg c = c} in map smg "foo bar"
06:15:10 <lambdabot>  "f   bar"
06:15:11 <smg> noo
06:15:14 <smg> i have spaces!
06:15:20 <smg> yes bad, there are spaces in it
06:15:25 <quicksilver> smg: map always returns a list of the same length.
06:15:29 <smg> ahh
06:15:30 <quicksilver> smg: that's one of its free theorems.
06:15:34 <smg> that makes things clear
06:15:40 <quicksilver> smg: that's why filter was suggested to you first.
06:15:44 <smg> thank you
06:15:48 <smg> i love you :)
06:15:48 <smg> bye
06:15:55 <quicksilver> I feel the love.
06:16:12 <chessguy> heh
06:16:45 <lilac> gubagem: i've had a go at tidying it up for you, but i'm a beginner, so pinch of salt required...
06:17:48 <chessguy> lilac:  aren't we all?
06:18:34 <lilac> some more than others?
06:18:41 <mm_freak1work> > const 3 undefined
06:18:42 <lambdabot>  3
06:18:57 <yitz> @check \f x -> length x == length (map f x)
06:18:58 <lambdabot>  Add a type signature
06:18:59 <gubagem> lilac: ty that looks interesting
06:19:25 <chessguy> true. Garry Kasparov supposedly said once that everyone sucks at chess, Grandmasters just suck less than others. seems applicable to haskell
06:19:30 <mm_freak1work> > let !x = undefined in const 3 x
06:19:31 <lambdabot>  Parse error at "!x" (column 5)
06:19:45 <quicksilver> lilac: which monad do you believe your 'new' is running in?
06:19:49 <mm_freak1work> > let x = undefined in x `seq` const 3 x
06:19:49 <gubagem> the longer you play chess the more you realize how bad you suck at it
06:19:50 <lambdabot>  Exception: Prelude.undefined
06:19:57 <lilac> gubagem: it doesn't call badInput any more, but it returns (Monad m) => m [Item], so you can use maybe badInput return $ new ...
06:19:58 <yitz> @check \f x -> length x == length (map f x) :: (a -> a) -> [a] -> Bool
06:19:58 <chessguy> gubagem:  indeed
06:19:58 <lambdabot>  Couldn't match expected type `(a -> a) -> [a] -> Bool'
06:20:13 <quicksilver> lilac: a.k.a. what do you think that <- before reads is doing?
06:20:17 * gubagem is scared by too many new ideas so early in the morning 
06:20:42 <chessguy> too many impossible things before breakfast?
06:20:55 * gubagem continues eating his egg sandwich
06:21:02 <Botje> gubagem: that's not egg :o)
06:21:19 <lilac> quicksilver: it should work in any monad. the <- pattern will call fail if it doesn't match.
06:21:23 <gubagem> did you hack the "Matrix" again Botje? ;-)
06:21:37 <Botje> .. no? :)
06:22:04 <lilac> quicksilver: but you're right, those lines are missing a return $
06:22:38 <yitz> @check (\f x -> length x == length (map f x)) :: (a -> a) -> [a] -> Bool
06:22:39 <lambdabot>  OK, passed 500 tests.
06:23:42 * lilac thinks that Haskell would be nicer if "let pattern = f" inside a do were mapped to "pattern <- return $ f"
06:24:41 <Philippa_> lilac: for what reasons? For typing purposes it's a loss
06:24:42 <chessguy> yitz:  seems like this is a case where a different kind of proof would be both easier and more comprehensive
06:24:49 <quicksilver> lilac: no it won't work in any monad.
06:24:57 <quicksilver> lilac: it will *force* the monad to be [].
06:25:14 <yitz> chessguy: :)
06:25:16 <quicksilver> :t do { a <- reads "1234" ; return a }
06:25:18 <lambdabot> forall a. (Read a) => [(a, String)]
06:25:25 <quicksilver> lilac: which is not what you wanted.
06:25:28 <lilac> Philippa_: because there's something more sensible for it to do that a runtime error within a do. <- calls fail; why does let not call fail
06:25:31 <Philippa_> also, there's a subtle semantic difference. Consider this monad:
06:25:36 <lilac> quicksilver: as i said, it is missing a return $
06:26:00 <Philippa_> instance Monad Bottom where {return = undefined; l (>>=) r = undefined;}
06:26:02 <lilac> quicksilver: do [(a, "")] <- return $ reads "123"      is what I meant...
06:26:40 <quicksilver> lilac: right.
06:26:58 <chessguy> hiya edwardk
06:27:06 <osfameron> meh, I don't understand how the Reader monad functions like 'ask' get passed the state to query
06:27:24 <quicksilver> making let inside monads call fail if patter match failure occurs has been discussed before.
06:27:26 <lilac> Philippa_: yes, it's semantically different. my point is that I think the semantics of <- are better than those of let.
06:27:30 <tibell> does foldr make sense in call-by-value languages?
06:27:40 <vixey> yes
06:27:55 <quicksilver> isn't there a subtle gotcha to do with the difference between irrefutable patterns and unfailable patterns? or am I making that up?
06:28:04 <yitz> osfameron: Reader is a read-only State. ask is like get.
06:28:07 <quicksilver> osfameron: same way any function gets passed a parameter.
06:28:15 <quicksilver> osfameron: a Reader monad thing *is* a function.
06:28:24 <quicksilver> osfameron: and what you're calling the state *is* its parameter.
06:28:42 <quicksilver> osfameron: Reader r a is just (r -> a). And runReader is just function application.
06:28:44 <lilac> quicksilver: i do recall reading something about that on haskell-cafe archives a while back.
06:29:05 * yitz guesses that quicksilver is answering osfameron's real question
06:29:50 <yitz> tibell: why not?
06:29:57 <osfameron> quicksilver: but it's not binding a parameter - the examples seem to be like 'foo <- ask field' with no binding to a state
06:30:14 <quicksilver> osfameron: it is binding a parameter. it's just hidden secret magic.
06:30:38 <quicksilver> osfameron: not magic in a bad way, though :)
06:30:46 <quicksilver> osfameron: the way the do notation translates
06:30:52 <quicksilver> osfameron: for this particular monad
06:30:59 <quicksilver> is to bind the parameter.
06:31:01 <yitz> foo <- asks field
06:31:33 <osfameron> hidden secret (but good) magic is nice, but it's a big step from the numpty monads (Id and Maybe) to these ones that have even more magic :-)
06:31:53 <gubagem> can i have an if then that returns a value and an else that calls myMainloop itemList?
06:31:57 <lilac> quicksilver: but given that we can define let in terms of <- and return, it seems simpler to do so. i think the main gotcha would be the difference between let ... and let ... in ... -- "do let ... in return foo" may well not do what people expect
06:32:53 <yitz> gubagem: if the value and the return type of myMainloop itemList are the same
06:33:05 <yitz> same type
06:33:21 <lilac> to be honest, i think the haskell design is a little warty with respect to let, let ... in and where.
06:33:34 <mxc> i know that this is insanely off subject, but can multiple processes on one machine listen to UDP broadcasts on the same port?  IIRC, they cannot
06:33:45 <tibell> yitz: it's usually used when you want laziness
06:33:47 <mxc> (if it counts, its for my haskell project)
06:34:12 <yitz> tibell: in a strict language foldl and foldr are the same
06:34:25 <chessguy> mxc:  not without some magic at least
06:34:27 <lilac> yitz: you assume associativity
06:34:45 <yitz> lilac: up to order of various things :)
06:34:50 <tibell> I did find some good papers on interpreter implementation if anyone is interested: http://citeseer.ist.psu.edu/cache/papers/cs/32018/http:zSzzSzwww.jilp.orgzSzvol5zSzv5paper12.pdf/ertl03structure.pdf http://www.sagecertification.org/events/vee05/full_papers/p153-yunhe.pdf http://www.tecgraf.puc-rio.br/~lhf/ftp/doc/jucs05.pdf
06:34:50 <quicksilver> osfameron: well the only secret is in the defintion of >>=
06:34:51 <lambdabot> http://tinyurl.com/5aaqc5
06:35:05 <quicksilver> osfameron: suppose you have a >>= \x -> b
06:35:23 <quicksilver> osfameron: (b is an expression, it might mention x)
06:35:23 <osfameron> quicksilver: ok
06:35:30 <quicksilver> osfameron: in the reader monad both a and b are functions
06:35:36 <quicksilver> they're both waiting for 1 parameter
06:35:39 <quicksilver> before they can give a result
06:35:50 <osfameron> oh.  a is a function?
06:35:53 <quicksilver> (a >>= \x -> b) is also a reader monad action
06:36:06 <quicksilver> (in the reader monad, an action is a function, yes)
06:36:17 <quicksilver> so (a >>= \x -> b) gets a parameter
06:36:19 <quicksilver> what >>=
06:36:20 <dbueno> dcoutts: Ugh, still to big.  My circuits have 200 nodes.
06:36:27 <quicksilver> does is pass that same parameter to both a and b
06:36:52 <quicksilver> so the binding "strategy" for the reader monad is "send same parameter to both actions"
06:36:55 <osfameron> and that parameter is the state?
06:36:58 <quicksilver> yes
06:37:03 <quicksilver> most people don't call it the state
06:37:06 <quicksilver> because it can't be changed
06:37:11 <quicksilver> commonly it's called the environment
06:37:14 <quicksilver> but, yes, absolutely.
06:37:24 <osfameron> roight
06:37:25 <yitz> "read-only state"
06:37:47 <yitz> Reader is kind of like "const" in C
06:37:49 * yitz ducks
06:37:59 <opqdonut> :D
06:38:21 <osfameron> so 'asks field' is curried and gets passed the final parameter to make it 'asks field env' ?
06:38:35 <lilac> something like: (>>=) a f state = let x = a state in f x state
06:39:10 <chessguy> @src (>>=) Reader
06:39:11 <lambdabot> Source not found. My brain just exploded
06:39:25 <opqdonut> @src (>>=) (->)
06:39:26 <lambdabot> Source not found. That's something I cannot allow to happen.
06:39:30 <opqdonut> @src (>>=) (r->)
06:39:30 <lambdabot> Source not found. It can only be attributed to human error.
06:39:33 <opqdonut> hrmm
06:39:47 <yitz> @src Reader (>>=)
06:39:47 <lambdabot> Source not found. I feel much better now.
06:39:54 <chessguy> @source Reader
06:39:54 <lambdabot> Reader not available
06:40:02 <yitz> @src (->) (>>=)
06:40:02 <lambdabot> f >>= k = \ r -> k (f r) r
06:40:18 <opqdonut> ah, that way around :)
06:40:20 <chessguy> there we go
06:40:36 <quicksilver> osfameron: yes.
06:40:52 <quicksilver> :t asks
06:41:01 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
06:41:04 <quicksilver> :t runReaderT asks
06:41:06 <lambdabot>     Couldn't match expected type `ReaderT r m a'
06:41:06 <lambdabot>            against inferred type `(r1 -> a1) -> m1 a1'
06:41:06 <lambdabot>     In the first argument of `runReaderT', namely `asks'
06:41:16 <quicksilver> :t \field ->runReaderT asks field
06:41:20 <lambdabot>     Couldn't match expected type `ReaderT r m a'
06:41:20 <lambdabot>            against inferred type `(r1 -> a1) -> m1 a1'
06:41:20 <lambdabot>     In the first argument of `runReaderT', namely `asks'
06:41:34 <quicksilver> :t \field -> runReaderT (asks field)
06:41:36 <lambdabot> forall a r (m :: * -> *). (Monad m) => (r -> a) -> r -> m a
06:41:51 <quicksilver> maybe that's not as enlightening as I had hoped.
06:42:01 <quicksilver> was trying to show the 'real' unwrapped type of asks.
06:42:19 <quicksilver> osfameron: your intuition is correct. "asks" is really a curried function and really it takes two parameters not one.
06:42:19 <yitz> :t \field -> runReader (asks field)
06:42:22 <lambdabot> forall a r. (r -> a) -> r -> a
06:43:00 <quicksilver> osfameron: the reader monad represents the common situation where you have a whole bunch of functions all passing the same last parameter around
06:43:08 <quicksilver> osfameron: which is something like 'globalConfig' or similar.
06:43:23 <osfameron> quicksilver: yeah, I still tend to see complex types and go "Eeeek!" rather than "Hmmm, how enlightening" :-)
06:44:06 <hpaste>  gubagem pasted "delicous working spaghetti code, yes it finally works" at http://hpaste.org/8091
06:44:22 <chessguy> @remember osfameron yeah, I still tend to see complex types and go "Eeeek!" rather than "Hmmm, how enlightening" :-)
06:44:22 <lambdabot> Okay.
06:44:23 <osfameron> cool.  I guess I was expecting the global state to be the first parameter (already bound) rather thna being the one passed in last, so was refusing to understand this
06:44:44 <quicksilver> yeah, of course it doesn't matter much which.
06:44:50 <quicksilver> but because of the way haskell syntax works
06:44:55 <quicksilver> "asks field"
06:44:59 <quicksilver> field has to be first parameter
06:45:04 <quicksilver> so the hidden env has to be last.
06:45:12 <osfameron> yeah
06:45:17 <vixey> > ("wobblo"`reverse`)
06:45:31 <lambdabot>  "olbbow"
06:46:08 <yitz> gubagem: nice! but get my point about if-the-else being messy?
06:46:22 * lilac rotates gubagem's head 30 degrees clockwise
06:46:33 <gubagem> yes
06:47:08 <gubagem> im thinking my scheme roots are showing themselves in an ugly way in haskell
06:47:19 <chessguy> gubagem:  something is :)
06:50:09 <quicksilver> gubagem: there is no need to chain the lets like that.
06:50:19 <quicksilver> gubagem: you can just have one big let with 3 assignments in it
06:50:22 <chessguy> @type maye
06:50:26 <lambdabot> Not in scope: `maye'
06:50:26 <chessguy> @type maybe
06:50:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:50:52 <smg> ah
06:50:55 <smg> one more questions
06:51:01 <smg> can i get map(\x -> [ 3*y | y <- x]) [[1,2],[3,6,9],[10]] into a list comprehension?
06:51:17 <EvilTerran> it'd have to be two nested ones
06:51:40 <opqdonut> yeah
06:51:42 <EvilTerran> [[ 3*y | y <- x] | x <- [[1,2],...]]
06:52:01 <EvilTerran> alternatively, (map.map) (3*)
06:52:03 <opqdonut> but if you're just doing that i recommend "map.map (3*)"
06:52:04 <opqdonut> yeah
06:52:13 <quicksilver> > [ 3*y | x <- [[1,2],[3,6,9],[10]] , y <- x]
06:52:16 <opqdonut> EvilTerran: isn't that wrong
06:52:24 <opqdonut> quicksilver: that'll concat them right?
06:52:26 <quicksilver> is not quite the same.
06:52:28 <lambdabot>  thread killed
06:52:29 <quicksilver> but it's interesting :)
06:52:32 <quicksilver> right.
06:52:36 <EvilTerran> no, it's map (map (3*)), not map . map (3*)
06:52:41 <chessguy> @type map.map(3*)
06:52:51 <opqdonut> :t (map.map) (3*)
06:52:56 <lambdabot> thread killed
06:52:56 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Num a, Functor f1, Functor f) => f (f1 a) -> f (f1 a)
06:53:18 <chessguy> eh?
06:53:27 <EvilTerran> :t (P.map P.. P.map) (3*)
06:53:30 <lambdabot> forall a. (Num a) => [[a]] -> [[a]]
06:53:36 <opqdonut> yeah it's (map.map)
06:53:50 <EvilTerran> :t (map map map) -- yay for caleskell
06:53:52 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:54:49 <chessguy> @type map
06:54:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:55:11 <chessguy> why rename fmap to map?
06:55:25 <smg> mh
06:55:31 <smg> i'm stupid
06:55:53 <chessguy> that's just stupid. if i want fmap, i'll just say fmap
06:56:11 <quicksilver> the argument is that fmap is the more useful one and deserves the shorter name,
06:56:21 <quicksilver> keep that other as listMap or List.map if you need it.
06:56:31 <chessguy> bah
06:56:31 <quicksilver> smilarly (.)
06:56:42 <chessguy> @type (.)
06:56:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:56:52 <chessguy> oh, they screwed that one up too
06:57:00 <funktio> > (^ 2) . [1..5]
06:57:06 <lambdabot>  [1,4,9,16,25]
06:57:10 <quicksilver> s/screwed up/generalised/  ;)
06:57:16 <smg> mh
06:57:23 <vixey> you only noticed this now?
06:57:34 <smg> i need to create a list of pairs (a,b) where a is divisible by 5 without remainder and b is a even digit
06:57:37 <chessguy> quicksilver:  it is a screw-up
06:57:37 <smg> infinite list
06:57:48 <smg> [ (x,y) | x <- [5,10..], y <- [2,4..] ]
06:57:49 <smg> i have this
06:57:53 <smg> but that won't terminate it if do
06:57:56 <quicksilver> chessguy: why?
06:57:57 <chessguy> would you rather explain map in terms of higher order functions, or in terms of functors?
06:57:59 <smg> (20,2) `elem` [ (x,y) | x <- [5,10..], y <- [2,4..] ]
06:58:07 <smg> can someone tell me how i can speed up this?
06:58:18 <quicksilver> chessguy: I would explain listMap.
06:58:19 <vixey> um both
06:58:24 <vixey> [] is a functor
06:58:30 <quicksilver> chessguy: and then say "there is a more general concept 'map' which applies to lists and also other cool things"
06:58:37 <yitz> mm - not just that fmap is more useful - the idea is that map *is* fmap specialized, so why waste the simpler name on a specialization?
06:58:55 <smg> somone an idea?
06:58:56 <yitz> but it sure obfuscates the error messages and :t output
06:59:29 <chessguy> because map is widely known as a list version of fmap, and because map as it's typically available will mean the list version, and because it gives newbies less of a headache
06:59:47 <yitz> smg: maybe you meant (x,y) <- zip [5,10..] [2,4..]
07:00:07 <chessguy> the 'simpler name' stuff is just crap. one character difference is irrelevant
07:00:23 <quicksilver> chessguy: well the point of changing it in lambdabot is to investigate the consequences of changing it in an alternative Prelude.
07:00:27 <quicksilver> or, indeed, the real Prelude.
07:00:33 <smg> yitz: no i need a list comprehensioN!
07:00:36 <yitz> chessguy: just repeating back the idea, not convinced by it
07:00:42 <smg> yitz: will your version be faster?
07:00:45 <opqdonut> i kinda like the functor versions of (.) and fmap
07:00:50 <opqdonut> i used not to care
07:00:51 <BMeph> chessguy: Except, fmap works on lists anyway, so why not just use it, and later explain that it works on more things than lists? ;p
07:00:59 <yitz> smg:  i meant inside the comprehension.
07:01:10 <pejo> smg, you need to walk diagonally over it, you're traversing all of [5,10..] with your current code.
07:01:16 <yitz> > zip [5,10..] [2,4..]
07:01:20 <lilac> smg: turning a non-terminating program into a terminating one is not a speedup in the traditional sense :)
07:01:22 <lambdabot>  [(5,2),(10,4),(15,6),(20,8),(25,10),(30,12),(35,14),(40,16),(45,18),(50,20),...
07:01:26 <BMeph> smg: Use a parallel list comp. :)
07:01:30 <chessguy> BMeph:  it's nice if you know what your'e doing, but a headache if you don't
07:01:38 <smg> BMeph: how do i do that? i don't know sorry
07:01:45 <yitz> > [(x,y) | x <- [5,10..], y <- [2,4..]]
07:01:46 <lambdabot>  [(5,2),(5,4),(5,6),(5,8),(5,10),(5,12),(5,14),(5,16),(5,18),(5,20),(5,22),(5...
07:01:53 <smg> yitz: yeah
07:01:54 <BMeph> > [(x,y)|x<-[5,10..]|y<-[2,4..]]
07:01:54 <lambdabot>  Parse error at "|y<-[..." (column 19)
07:02:01 <smg> BMeph: that is?
07:02:09 <chessguy> there are a lot of newbies in #haskell, and now when they ask about doing something to every element in a list, you not only have to explain higher order functions, but what they mean in terms of Functors too
07:02:09 <smg> oh wrong
07:02:33 <smg> BMeph: ?
07:02:40 <smg> is there a site about "parallel" list comp. ?
07:02:59 <BMeph> chessguy: You don't have to explain functors to newbies before they want to - just explain that functors are like lists, but more general.
07:03:04 <yitz> chessguy: or, more simply, explain as usual, but add apologetics about the apparently meaningless type
07:03:28 <BMeph> smg: Hold on, I'm looking up the reference in the GHC online manual. :)
07:03:39 <chessguy> but understanding types is so important to newbies
07:03:52 <chessguy> @type map
07:04:07 <lambdabot> thread killed
07:04:08 <smg> BMeph: ty
07:04:12 <quicksilver> I agree with that disadvantage
07:04:14 <smg> BMeph: maybe you can write it in my PN?
07:04:14 <quicksilver> but that's the only one.
07:04:30 <mehrheit> > let elemT2L a@(b, c) l = a `elem` (takeWhile (\(x,y)-> x < b && y < c) l) in elemT2L (20, 2) [ (x,y) | x <- [5,10..], y <- [2,4..] ]
07:04:31 <lambdabot>  False
07:04:39 <chessguy> you used to be able to do @type map, and explain not only map, but also its type and what that means. now you really don't want to do that for newbies
07:04:45 <pejo> smg, http://web.cecs.pdx.edu/~mpj/afp/ft-two.pdf has a bunch of slides on "Cartesian Product", I'm guessing that is what you're trying to do.
07:04:53 <mehrheit> > let elemT2L a@(b, c) l = a `elem` (takeWhile (\(x,y)-> x < b && y < c) l) in elemT2L (5, 2) [ (x,y) | x <- [5,10..], y <- [2,4..] ] -- smg
07:04:53 <yitz> chessguy: indeed. so LB is not useful for the types in this case, you explain it by hand, and apologize for LB's impolite behavior.
07:04:55 <lambdabot>  False
07:04:56 <chessguy> quicksilver:  that's a big one for #haskell, in my mind
07:05:02 <quicksilver> it is.
07:05:07 <quicksilver> well it's only an experiment.
07:05:20 <quicksilver> It's been going for quite a while yet and I've seen more positive consequences than negative
07:05:28 <mehrheit> smg, oops, s/</<=/ there
07:05:43 <dcoutts> dbueno: with the core packages? I guess that's not surprising, there are 21 core packages. Try something much simpler, make up some packages.
07:05:46 <yitz> @type P.map
07:05:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:05:51 <dcoutts> dbueno: just define them in code
07:05:57 <mm_freak_work> once again, i'm trying to make an RC4 implementation using STUArrayâ€¦  i'd like the key-stream to be an infinite list, but that one needs to be generated from within the ST monad using and manipulating an STUArray at the same time
07:06:01 <mm_freak_work> is this possible?
07:06:02 <chessguy> i suppose i could drag out the old argument for 2 #haskell channels again
07:06:06 <yitz> there, now you only need to apologize for the P.
07:06:06 <dbueno> dcoutts: Okay, I'll try that.
07:06:14 <shapr> chessguy: What?
07:06:25 <BMeph> smg: http://www.google.com/url?sa=t&ct=res&cd=3&url=http%3A%2F%2Fwww.haskell.org%2Fghc%2Fdocs%2Flatest%2Fhtml%2Fusers_guide%2Fsyntax-extns.html&ei=TaFGSJmzHpOEggLbq_zHCQ&usg=AFQjCNGA0NdnAMixE7Y-hAE5Gcr33mcoNA&sig2=XHRqNZz1N-FHgjeAuS8YKA
07:06:26 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/6x5oan
07:06:27 <chessguy> @get-slap
07:06:27 <dbueno> dcoutts: You don't happen to have a quickcheck "packagedb" instance lying around, do you? =]
07:06:28 <lambdabot> shapr!!
07:06:49 <chessguy> 'morning, shapr. What what?
07:06:52 <BMeph> smg: Er, whoops, I'll get the real ref, sorry. :)
07:07:08 <dcoutts> dbueno: sorry, I've made up little special purpose ones for testing various components but I don't have any standard one I keep around
07:07:19 <shapr> chessguy: What's the argument for two #haskell channels?
07:07:24 <dbueno> dcoutts: Okay.
07:07:27 <shapr> Just curious.
07:07:32 <shapr> Good morning chessguy!
07:07:35 <dcoutts> dbueno: or for some tests I use as large ones as possible which doesn't help you
07:07:52 <chessguy> shapr:  keeping more advanced discussions in a separate channel so as not to make newbies heads explode
07:07:53 <BMeph> smg: Okay, this is better: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions
07:07:54 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
07:07:54 <yitz> BMeph: i personally like using zip explicitly better than "parallel list comps."
07:08:10 <shapr> chessguy: Maybe so.. or maybe they get inspired to learn new stuff?
07:08:25 <BMeph> yitz: ...okay, tell it to GHC, I didn't campaign for that extension.
07:08:25 <pejo> BMeph, isn't he trying to do a cartesian product though?
07:08:40 <chessguy> shapr: i would bet the former would be more likely to happen
07:08:53 <yitz> BMeph: I tried that for "pattern guards". Didn't help much. :)
07:08:55 <daf> I like the fact that stuff here goes over my head
07:08:56 <BMeph> yitz: However, since smg asked for that explicit behavior, and GHC lets you use it, I'll point it out. :)
07:08:57 <chessguy> especially in these java developer days
07:09:01 <daf> same with Planet Haskell
07:09:09 <lilac> > (20,2) `elem` concat $ zipWith (zip . reverse) (inits [2,4..]) (inits [5,10..]) -- smg
07:09:10 <lambdabot>  Couldn't match expected type `[(t, t1)]'
07:09:28 <lilac> > (20,2) `elem` (concat $ zipWith (zip . reverse) (inits [2,4..]) (inits [5,10..]))
07:09:34 <lambdabot> Terminated
07:09:35 <chessguy> daf:  i do too, but i would bet that we're the exceptions, and not the rule
07:09:39 <yitz> pejo: he wrote that, but I think he didn't mean that.
07:09:45 <yitz> or she
07:09:49 <shapr> chessguy: I think #haskell members are exceptions in general :-)
07:09:58 <daf> but there's a continuum, not two distinct sets
07:10:06 <daf> there's some stuff that's just a little bit ahead of where I am
07:10:10 <lilac> smg: it's semi-decidable that way, at least :)
07:10:13 <shapr> Hi daf! Are you still in Cambridge?
07:10:19 <daf> but if I wasn't exposed to it I wuoldn't be motivated to find out about it
07:10:20 <mm_freak_work> more generally, i have a recursive function of type (STUArray s Word8 Word8 -> ST s [Word8]), which should return an infinite lazy list through manipulation of the array
07:10:24 <mm_freak_work> does that make sense?
07:10:35 <daf> shapr: I'm in other Cambridge right now
07:10:42 <chessguy> shapr, i guess it's partially a question of whether we want haskell to be mainstream or not. there are indeed arguments for keeping it somewhat elitist
07:10:43 <shapr> Ah, ok.
07:10:45 <daf> shapr: will probably switch again soon
07:10:56 <shapr> daf: Spiffy, would be fun to meet you again.
07:10:58 <mm_freak_work> because currently it doesn't workâ€¦  it just runs and runs, but outputs nothing
07:11:06 <daf> shapr: would be good to get a regular thing going
07:11:11 <shapr> Yes
07:11:16 <daf> maybe some presentations
07:11:22 <shapr> I haven't had much leftover effort to make that happen lately.
07:11:23 <daf> as well as food/beer
07:11:53 <shapr> chessguy: For me, the point of #haskell is to keep people learning new stuff.
07:11:59 <daf> shapr: no worries :)
07:12:15 <edwardk> slakr, organize the CHUG =P
07:12:37 * shapr throws an unnatural transformation at edwardk
07:12:40 <edwardk> will give you something to do from your deathbed there ;)
07:12:46 <shapr> hah
07:12:48 <smg> lilac: its not a list comprenehsion
07:12:52 <smg> i wanted al ist comprehension :D
07:12:54 <shapr> I do wish I weren't so freakin sick.
07:13:09 <edwardk> *cough* doctor *cough*
07:13:21 <shapr> Yeah yeah.. I'll call him today.
07:13:22 <chessguy> shapr:  i agree, it still comes back to whether newbies will see stuff that's over their heads and be inspired or be freaked out
07:13:29 <smg>   [ (a,by) | x <- [5,10..] | y <- [2,4..] ]
07:13:33 <smg> will this it be BMeph ?
07:13:50 <shapr> chessguy: I want #haskell to have the sort that will be inspired.
07:13:51 <lilac> > (20,5) `elem` [ x | y <- zipWith (zip . reverse) (inits [2,4..]) (inits [5,10..]), x <- y ]
07:14:06 <quicksilver> mm_freak_work: can only be done by using unsafeInterleaveIO and unsafeIOtoST, as far as I know.
07:14:06 <lambdabot>  thread killed
07:14:07 <shapr> @users
07:14:07 <lambdabot> Maximum users seen in #haskell: 465, currently: 447 (96.1%), active: 21 (4.7%)
07:14:25 <smg> (20,2) `elem` [ (x,y) | x <- [5,10..] | y <- [2,4..] ]
07:14:25 <lilac> "go to jail. do not write concat as a list comprehension, do not collect $200"
07:14:25 <opqdonut> smg: that'll just give you [(5,2),(5,4),(5,6)...]
07:14:28 <smg> this isn't fast :|
07:14:28 <shapr> chessguy: But I am only one of ~450, so...
07:14:41 <edwardk> well, the type that don't get inspired don't come back so its nicely self-selecting
07:14:43 <chessguy> shapr:  that's all well and good, i'm just saying, it will keep numbers down
07:14:44 <yitz> (20,2) `elem` [pair | pair <- zip [5,10..] [2,4..]]
07:14:46 <lilac> smg: it's worse than slow. it's non-terminating
07:14:51 <smg> hehe
07:14:57 <smg> opqdonut: mh how to do?
07:14:59 <lilac> yitz: tht's not what he wants
07:15:01 <smg> yitz: mh
07:15:09 <lilac> s/he/e/
07:15:25 <smg> lilac: have you another idea?
07:15:31 <shapr> chessguy: But it will keep the signal way above the noise!
07:15:37 <opqdonut> smg: sorry didn't notice the parallelness
07:15:38 <shapr> chessguy: And I think that will keep the numbers up over the long run!
07:15:44 <chessguy> shapr:  perhaps
07:15:52 <lilac> smg: well, my thing above will visit them in a triangular sweep, but it's not 'comprehensiony' enough for you i guess
07:15:59 <lilac> smg: project euler?
07:16:03 <smg> nope
07:16:11 <smg> it's a exercise of my CS studies
07:16:17 <smg> but i'm not able to figure it out
07:16:29 <lilac> ok, well the issue is that if you want termination, you need to order the elements such that each is reached in a finite time.
07:16:31 <yitz> what's the statement of the problem?
07:16:45 <quicksilver> list comprehensions don't work for more than one infinite list
07:16:47 <smg> "construct a infinite list of (a,b) where a is divisable by 5 and b is even" make it fair so it terminates for (20,2) `elem` list_comprehension
07:16:51 <quicksilver> they don't use a fair enumeration.
07:16:59 <quicksilver> I did write a version which does, once.
07:17:05 <quicksilver> maybe it's still on hpaste somewhere.
07:17:06 * BMeph scrolls up to see if lilac did his "diagonal join" more cleverly than BMeph did
07:17:07 <smg> quicksilver: do you know how to do?
07:17:09 <vixey> (x:xs)`interleave`(y:ys) = x:y:(xs`interleave`ys)
07:17:22 <quicksilver> it is.
07:17:23 <quicksilver> http://hpaste.org/annotate/2903
07:17:35 <daf> chessguy: I find Haskell requires a fair bit of persistence from me; I suspect that people who are discouraged easily don't get very far
07:17:41 <lilac> BMeph: i'm not completely sure min'es right :/
07:17:45 <pejo> smg, then look at the slides I pointed you to.
07:18:06 <lilac> BMeph: scratch that, i am now confident it's right.
07:18:28 <int-e> [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),...]
07:18:47 <vixey> > map (uncurry (+)) [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0)]
07:18:48 <lambdabot>  [0,1,1,2,2,2,3]
07:19:53 <lilac> BMeph: concat $ zipWith (zip.reverse) (inits a) (inits b)
07:20:28 <vixey> > [1..]>>=\x -> map (\y->(y,x-y)) [0..x]
07:20:28 <lambdabot>  Parse error at "->" (column 12)
07:20:36 <vixey> > [1..]>>=(\x -> (map (\y->(y,x-y)) [0..x]))
07:20:37 <lambdabot>  [(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,2),(3,...
07:20:49 <yitz> > [(x,y) | theSum <- [0..], x <- [0..theSum], let y = theSum - x]
07:20:50 <mehrheit> smg: that exercise is impossible without shadowing elem, I think
07:20:50 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
07:20:52 <int-e> which reminds me that I miss a library function that has the effect of  map reverse . inits
07:20:53 * BMeph looks at lilac's code, replaces 'concat' with 'join' and gets to scratching...
07:21:23 <smg> shadowing elem?
07:21:25 <int-e> (which would take O(n) time and memory for n reversed initial parts instead of O(n^2))
07:21:27 <smg> pejo: which page exactly?
07:21:34 <mehrheit> [(x*5, x*2) | x <- [1..]] would be a correct comprehension, but it doesn't contain (20, 2), so elem won't terminate
07:22:03 <smg> mehrheit: ahh
07:22:12 <mehrheit> smg: changing the elem function to another
07:22:27 <smg> mh
07:22:39 <smg> my bad :(
07:22:39 <lilac> BMeph: replace concat with join? you golfing this problem?
07:23:11 <vixey> @pl (y,x-y)
07:23:11 <lambdabot> (y, x - y)
07:23:16 <vixey> @pl \x->(y,x-y)
07:23:16 <lambdabot> (,) y . subtract y
07:23:18 <BMeph> mehrheit: The problem is not in elem, but in the form of the list in which elem looks for members.
07:23:28 <vixey> @pl \x y->(y,x-y)
07:23:29 <lambdabot> ap (,) . (-)
07:24:00 <BMeph> lilac: No, I just like tiptoeing in cale's "Functor Madness!" footsteps... ;)
07:24:22 <vixey> > [0..]>>=(\x->map((ap(,).(-))x)[0..x])
07:24:37 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
07:25:38 <yitz> vixey: a comprehension :)
07:25:45 <BMeph> lilac: Besides, if I wanted to play program golf, I'd whip out the driver known as "K". ;p
07:25:49 <vixey> yitz what
07:26:04 <yitz> > [p | p <- [0..]>>=(\x->map((ap(,).(-))x)[0..x])]
07:26:05 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
07:26:22 <yitz> there. the problem says it has to be a comprehension :)
07:26:22 <vixey> [p | p <- x] = x
07:26:27 <lilac> BMeph: the K combinator?
07:26:41 <int-e> @type (tail . scanl (flip (:)) []) >=> \xs -> map ((,) (head xs)) xs
07:26:43 <lambdabot> forall b. [b] -> [(b, b)]
07:26:49 <lilac> BMeph: as in, K = const?
07:26:54 <int-e> > ((tail . scanl (flip (:)) []) >=> \xs -> map ((,) (head xs)) xs) [1..]
07:26:55 <BMeph> lilac: No, the K language. :)
07:26:55 <lambdabot>  [(1,1),(2,2),(2,1),(3,3),(3,2),(3,1),(4,4),(4,3),(4,2),(4,1),(5,5),(5,4),(5,...
07:27:28 <mehrheit> BMeph: wouldn't APL be shorter/unicodescarier?
07:27:32 <int-e> ok, it's just a triangle.
07:27:34 <lilac> BMeph: at least in perl golfing, the language is proscribed :)
07:27:51 <daf> ITYM "prescribed" :)
07:28:07 <vixey> APL would certainly be unicodescarier
07:28:20 <int-e> > let f xs = (tail . scanl (flip (:)) [] xs) >>= zip xs in f [1..]
07:28:21 <lambdabot>  Exception: Prelude.tail: empty list
07:29:20 <int-e> > let f xs = scanl (flip (:)) [] xs >>= zip xs in f [1..]
07:29:21 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
07:29:41 <BMeph> mehrheit: The unicode-scariest! ;)
07:30:07 <mehrheit> :)
07:31:01 <maltem> ahh, Cale's (.) = fmap
07:32:39 <PeakerWork_> BMeph, do you have any idea why K is so successful in the financial sector? Why don't they use some sane FL's? :)
07:32:49 <HunterXHunter> @pl \f a b -> a + b
07:32:49 <lambdabot> const (+)
07:33:07 <BMeph> maltem: Or rather, (.)/'result' is fmap specialized to the Reader monad. ;)
07:33:58 <BMeph> PeakerWork: Um, because it was either that or Excel? :p
07:35:20 <opqdonut> :D
07:36:43 <HunterXHunter> @pl \f a s:d -> foldl a s d
07:36:46 <lambdabot> const ((`ap` tail) . (. head) . foldl)
07:37:12 <HunterXHunter> @pl \f a s:d -> foldr a s d
07:37:13 <lambdabot> const ((`ap` tail) . (. head) . foldr)
07:37:44 <maltem> @type \f a s:d -> foldr a s d
07:37:46 <lambdabot> parse error on input `:'
07:37:59 <maltem> See, I knew something was wrong in there :)
07:38:13 <HunterXHunter> ah
07:38:26 <maltem> Parens missing, I guess
07:39:44 <shapr> HunterXHunter: Are you Thomas Jaeger?
07:39:51 <HunterXHunter> no
07:45:48 <cnwdup> Why are there so many packages on Hackage that fail to build with ghc-6.8?
07:47:11 <yitz> > zip (concat $ inits [0..]) (concat $ reverse $ inits [0..])
07:47:15 <lambdabot> Terminated
07:47:32 <yitz> > zip (concat $ inits [0..]) (concat $ map reverse $ inits [0..])
07:47:33 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
07:47:47 <quicksilver> cnwdup: because the base package was split into many small packages
07:47:54 <quicksilver> cnwdup: and that broke everyone's dependencies.
07:48:21 <cnwdup> quicksilver: Ah, so there's no problem with the source needs to be changed but that you have to install packages that might not be listed as dependencies?
07:48:24 <yitz> yet again
07:49:05 <quicksilver> cnwdup: the source needs to be changed, to list the new dependencies.
07:49:12 <cnwdup> Ok.
07:49:17 <quicksilver> cnwdup: cabal "won't let you" compile against dependencies you don't declare.
07:49:30 <quicksilver> it forces you to compile in a 'clean room' with only the packages you asked for visible.
07:49:44 <quicksilver> it's a one-line fix to the .cabal file typically.
07:49:49 <quicksilver> Of  course there might be more serious problems :)
07:49:54 <quicksilver> btu that's the common one.
07:50:15 <cnwdup> Another question: As far as I can see, I built the hackage package 'plugins' using ghc 6.8.2 though it's marked as failing to build with that version. Is this somehow useful? Can I somehow help someone / something?
07:50:21 <cnwdup> quicksilver: Thanks for explaination so far.
07:50:32 <mm_freak_work> quicksilver: what would be the alternative?  using immutable arrays?
07:51:06 <cnwdup> I didn't test the package in action though. But there's no error during build.
07:51:20 <quicksilver> mm_freak_work: soudns like a fairly sane use of unsafeinterleave but I'm not 100% sure.
07:51:30 <quicksilver> cnwdup: I'm not sure why it's makred as failing.
07:54:55 <mm_freak_work> quicksilver: ah, there is unsafeInterleaveST
07:55:00 <quicksilver> mm_freak_work: *nod*
07:55:09 <mm_freak_work> and it works
07:55:10 <quicksilver> mm_freak_work: I didn't realise that when I answered you the first time.
07:55:13 <quicksilver> but I noticed since.
07:55:57 <LeCamarade> Can anybody explain Markov chains to me with minimal Greek?
07:56:05 <LeCamarade> ~ Confused LeCamarade
07:56:34 <quicksilver> LeCamarade: understand random variables?
07:56:49 <mm_freak_work> quicksilver: â€¦; more <- unsafeInterleaveST (gen arr (i,j)); return (keyByte : more)
07:56:58 <mm_freak_work> this is how i'm currently using itâ€¦  is my idea right?
07:57:02 <opqdonut> LeCamarade: think of a state machine with probabilities associated to each transition
07:57:36 <LeCamarade> Yes, I understand random variables.
07:57:56 <quicksilver> LeCamarade: happy with the notion of a time-dependent random variable?
07:58:01 <LeCamarade> opqdonut: You mean, basically, repeated calls to a rand()?
07:58:05 <quicksilver> LeCamarade: that is, the distribution might change over time
07:58:44 <LeCamarade> quicksilver: Wait. As in, when I check now, it is n, when I check again after time T it is m, where n and m are only randomly related?
07:58:52 <quicksilver> LeCamarade: no.
07:59:05 <quicksilver> LeCamarade: as in, when I check now, it's Gaussian with mean 7
07:59:15 <quicksilver> LeCamarade: and when I check in 5 minutes it might be Gaussian with mean 12.
07:59:26 <quicksilver> random variables never take values, they only take distributions.
07:59:35 <quicksilver> (you have to *sample* a random variable to actualy get a value)
08:00:13 <LeCamarade> Yeah, okay ... So we are talking an IORef Int where the Int is put by calls to randomRIO or something?
08:00:27 <LeCamarade> (Be gentle here, it is where I get lost in the weeds.) :o)
08:00:48 <quicksilver> I think you have too much of a computer scientists view of the word 'random'
08:00:55 <quicksilver> sorry
08:00:57 <quicksilver> not just that word
08:01:01 <quicksilver> actually the word 'variable' too.
08:01:10 <quicksilver> the probabilistic meaning is subtly different.
08:01:14 <EvilTerran> "constants aren't and variables won't"
08:01:26 <quicksilver> a variable (to a probabilist) is not a finite object like an IORef.
08:01:34 <quicksilver> it's something more like a cloud of possibility.
08:01:40 <LeCamarade> Oh.
08:01:52 <yitz> > concat $ zipWith zip `ap` map reverse $ inits [0..]
08:01:52 <EvilTerran> IO Int would be closer
08:01:52 <quicksilver> you can sample it to get a particular value.
08:01:53 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
08:01:57 <EvilTerran> run the action to sample it, kinda thing
08:01:58 <LeCamarade> Ah.
08:02:02 <quicksilver> yes
08:02:15 <quicksilver> anyhow, all the markov bit means
08:02:24 <quicksilver> is that current evolution is based entirely on the *now*
08:02:28 <quicksilver> you can forget abuot the past.
08:02:44 <quicksilver> so a markov chain is a bunch of random variables evolving over time
08:02:53 <quicksilver> with the understanding that you can predict the entire future from any point 'now'.
08:03:04 <LeCamarade> Okay, wait.
08:03:28 <quicksilver> a property shared by most people's intuition of physics and indeed computer programs.
08:03:29 <LeCamarade> I was generating names randomly, but I found that I was forcing them to have a certain sound to them.
08:03:43 <quicksilver> the past doesn't matter (except insofar as it had effects on the present)
08:04:07 <quicksilver> in other words the markov chain assumption is a very plausible assumption to most people.
08:04:23 <LeCamarade> Yes, it seems plausible, even intuitive.
08:04:28 <yitz> the drunk on the pier problem
08:04:31 <quicksilver> now you're going to ask me a totally concrete problem which my airy-fairy part II probability explanation has not helped you with.
08:04:56 <LeCamarade> I thought Markov chains were basically random streams with a predicate, but that seems to have been wrong (as the predicate may never be fulfilled).
08:07:27 <quicksilver> finite probabilistic state machines
08:07:30 <quicksilver> or whatever they're called
08:07:33 <LeCamarade> quicksilver: Meaning I can model them as a pure function?
08:07:34 <opqdonut> yup
08:07:35 <quicksilver> are examples of markov chains
08:07:48 <quicksilver> because their evolution to the next state depends only on the 'now.
08:07:57 <LeCamarade> Yeah, I saw them go by that name somewhere.
08:08:07 <quicksilver> (plain old state machines are very boring examples, because they evolve deterministically)
08:10:35 <LeCamarade> > let makov_eg n = take n $ repeat 'R' in randomRIO (0, 10) >>= markov_eg  -- <-- is that a Markov chain, then?
08:10:36 <lambdabot>   Not in scope: `markov_eg'
08:10:46 <yitz> quicksilver: not my machine
08:10:47 <LeCamarade> > let markov_eg n = take n $ repeat 'R' in randomRIO (0, 10) >>= markov_eg  -- <-- is that a Markov chain, then?
08:10:48 <lambdabot>  Couldn't match expected type `IO b' against inferred type `[Char]'
08:11:22 <mmorrow> @t randomR
08:11:22 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:11:30 <mmorrow> @type randomR
08:11:32 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:13:23 <LeCamarade> > let markov_eg n = take n $ repeat 'R' in randomRIO (0, 10) >>= (return . markov_eg)
08:13:25 <lambdabot>  <IO [Char]>
08:13:58 <quicksilver> LeCamarade: yes but it's not a very interesting one.
08:14:02 <quicksilver> because it doesn't evolve.
08:14:27 <mmorrow> fmap (flip replicate 'R') $ randomR (0, 10) 0
08:14:30 <mmorrow> > fmap (flip replicate 'R') $ randomR (0, 10) 0
08:14:31 <lambdabot>   add an instance declaration for (RandomGen Int)
08:14:34 <quicksilver> an interesting markov chain is data State = State { lots of stuff }
08:14:41 <LeCamarade> Oh. So if I put some logic to twist and turn depending on the initial input, then it is an interesting one.
08:14:45 <mmorrow> > fmap (flip replicate 'R') $ randomR (0::Integer,10) 0
08:14:46 <lambdabot>   add an instance declaration for (RandomGen Int)
08:14:49 <quicksilver> such that each iteration the new state depends (probabilistically) only on the old state.
08:14:55 <mmorrow> > fmap (flip replicate 'R') $ randomR (0::Integer,10) (mkStdGen 0)
08:14:56 <lambdabot>  Couldn't match expected type `Int' against inferred type `StdGen'
08:15:00 <quicksilver> for example, physics models in computer games are normally of that type.
08:15:01 <mmorrow> ahhhhhhhhhhhhhh
08:15:21 <quicksilver> of course that's a discrete one because we're in a computer.
08:15:30 <quicksilver> the continuous ones are more interesting in some ways :)
08:15:36 <quicksilver> but harder to describe 'simply'
08:15:37 <mmorrow> > randomR (0,10) (mkStdGen 0)
08:15:38 <lambdabot>  (0,40014 40692)
08:15:41 <mmorrow> oh
08:15:43 <LeCamarade> I see that. :o)
08:15:48 <mar77a> :t foldr
08:15:49 <mmorrow> > randomRs (0,10) (mkStdGen 0)
08:15:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:15:51 <lambdabot>  [0,3,6,8,7,5,1,8,8,4,2,2,4,5,7,6,9,3,4,9,4,9,0,10,6,6,7,8,8,0,10,3,3,9,10,3,...
08:16:01 <mmorrow> > fmap (flip replicate 'R') $ randomRs (0,10) (mkStdGen 0)
08:16:02 <lambdabot>  ["","RRR","RRRRRR","RRRRRRRR","RRRRRRR","RRRRR","R","RRRRRRRR","RRRRRRRR","R...
08:16:09 <quicksilver> A deep question about the world is whether physics is deterministic, markov, or neither.
08:16:11 <LeCamarade> Let's see ... if I ran, say, Blowfish on it, now that is approaching the "interesting" level, no?
08:16:19 <quicksilver> the classicists thought it was deterministic.
08:16:29 <quicksilver> the quantumicists, broadly, think it's markov.
08:16:42 <LeCamarade> After the 3rd World War we'll thing in is all three. :o)
08:16:55 <LeCamarade> *we'll think it is all three*
08:17:00 <LeCamarade> Horrible spelling, ftw.
08:17:20 <Botje> @pl \l -> zip l $ tail l
08:17:21 <lambdabot> ap zip tail
08:17:48 <quicksilver> Botje: zip`ap`tail the aztec god of consecutive numbers
08:17:58 <Botje> :)
08:18:01 <vixey> :t zip`ap`tail
08:18:01 <opqdonut> :)
08:18:02 <lambdabot> forall b. [b] -> [(b, b)]
08:18:12 <Botje> @remember quicksilver zip`ap`tail the aztec god of consecutive numbers
08:18:13 <lambdabot> I will remember.
08:18:16 <LeCamarade> @remember quicksilver  zip`ap`tail the aztec god of consecutive numbers zip`ap`tail the aztec god of consecutive numbers zip`ap`tail the aztec god of consecutive numbers
08:18:17 <lambdabot> I will remember.
08:18:28 <Botje> heheh
08:18:33 <Botje> QUOTE OVERLOAD
08:18:33 <BillMath> I just read Martin Grabmuller's excellent paper on Monad Transformers Step by Step.  It not only showed be how to use Monad Transformes, but monads in general.  His example was basic - just enough to serve as a meaningful framework to build on .  Can anyone direct me to a similar paper I can use to understand arrows?  I am not a computer scientist.  So the more application oriented the better.
08:18:37 <byorgey> [(b, b)]  <--- it's his evil, demanding consecutive eyes!
08:18:39 <LeCamarade> Gah! Sorry for the horrible tripple clickm by mistake.
08:19:05 <LeCamarade> byorgey: With wide ears to boot. :o)
08:19:11 <byorgey> indeed.
08:19:24 <PeakerWork> how do people generally do binary protocol encoding/decoding with Haskell? parsec?
08:20:12 <byorgey> BillMath: maybe try John Hughes' "Generalizing Monads to Arrows" (linked from here: http://haskell.org/arrows/biblio.html)
08:20:13 <lambdabot> Title: Arrows: bibliography
08:20:33 <byorgey> BillMath: I don't know if it's application oriented enough for you, but it's fairly approachable.
08:20:34 <LeCamarade> quicksilver: So, one last thing: can I make my Markov chain thingy an IO action, so that I have a new random state (IO random) on every time I want to advance?
08:20:47 <LeCamarade> For example, every char being randomly-generated?
08:20:51 <quicksilver> you can
08:20:59 <quicksilver> of course if you use anything else from IO other than random
08:21:00 <BillMath> Thanks
08:21:03 <quicksilver> then it isn't markov any more
08:21:08 <quicksilver> it would be reacting to some environment.
08:21:30 <quicksilver> bearing that in mind it might be more elegant to put it in some other random monad than IO.
08:22:25 <LeCamarade> Okay, so if I use a pure PRNG, like the MT, and so that it is pure, but still random enough, it is still a markov chain (assuming that I seeded the pure PRNG with the initial state).
08:22:48 <quicksilver> markov chains are explicitly allowed to use an RNG
08:22:49 <LeCamarade> And interesting.
08:22:54 <quicksilver> they are after all random variables.
08:22:55 <LeCamarade> And elegant.
08:23:03 <LeCamarade> Wow. Cool.
08:23:15 <quicksilver> they'd be boring markov chains without any randomness
08:23:21 <quicksilver> they'd reduce to state machines again.
08:23:38 <quicksilver> (markov --> reduces to deterministic, in the absence of random choice)
08:24:33 <LeCamarade> So it appears to me that Markov chains are the formal name of, say, unfolding on a random number generator or the like.
08:24:51 <LeCamarade> If that is true, many people are doing them sans knowing it ... ?
08:25:08 <quicksilver> well markov chains aren't "about" rngs
08:25:14 <quicksilver> they're "about" true randomness.
08:25:21 <quicksilver> On a computer, of course, we generally use rngs.
08:25:44 <LeCamarade> Okay, s/random number generator/random.org stream/
08:25:51 <LeCamarade> ^ Bon?
08:25:54 <quicksilver> ;)
08:26:02 <LeCamarade> :o)
08:26:04 <quicksilver> mabye.
08:26:11 <quicksilver> even a random.org stream is discrete.
08:26:17 <quicksilver> markov chains (in general) might be continuous
08:26:25 <quicksilver> not just time-continous but state-continuous too.
08:26:32 <mxc> is anyone familiar with Network.Socket.ByteString?
08:26:44 <mxc> as in, even though its version 0.1.1.2 - is that 'good enough'?
08:26:48 <hpaste>  mix25 pasted "(no title)" at http://hpaste.org/8092
08:26:51 <LeCamarade> I used my girlfriend's moods for a true random stream, for one. Puts random.org to shame.
08:26:59 <LeCamarade> :o)
08:27:06 <mix25> Hello why the func code only delete 1 element ?
08:27:20 <quicksilver> here is the best RNG, of course: http://xkcd.com/221/
08:27:20 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:27:58 <LeCamarade> 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 ...
08:28:16 <byorgey> hehe, someone should make a MonadXKCD
08:28:33 <LeCamarade> mix25: Which function?
08:29:05 <mix25> "func"
08:29:06 <LeCamarade> @let xkcdTruestRandom = return 4 :: IO Int
08:29:06 <lambdabot> Defined.
08:29:18 <mix25> the last in the pasted code.
08:29:30 <byorgey> mix25: your 'borrar' function deletes the first element it finds which is equal to the given element.
08:30:07 <byorgey> mix25: if you want it to delete *all* elements which are equal to the given element, you should say 'if x == y then borrarAux (==) x ys else ...
08:30:08 <mix25> but i call to func recursively
08:30:36 <LeCamarade> mix25: It seems you don't call it after borrar has run.
08:30:58 <mix25> "else func (zss)" =
08:31:01 <mix25> "else func (zss)" ?
08:31:11 <LeCamarade> I'd assume you want something like: func $ borrar ... else func zsss
08:31:32 <LeCamarade> Yes, func zss only goes _if_ nothing was found.
08:31:52 <LeCamarade> But if borrar runs, then something was found (that one element that is deleted is the one that was found).
08:32:05 <mix25> map (interseccion xs) zss) is returning list of list of integer and some these list are null list and i want to remove all null list
08:32:07 <LeCamarade> And after borrar runs, func is not called.
08:32:17 <mix25> aha
08:32:46 <LeCamarade> Yes, you should call func on what borrar returns, or else borrar will only run once, and that is on the first chance it get, _only_.
08:32:48 <mix25> well if i put : "func (zss) = func (zss) " maybe it'll work?
08:33:01 <byorgey> mix25: as an aside, removing things from a list is probably a lot easier (and more efficient) with 'filter' than by making recursive calls to a deletion function
08:33:33 <byorgey> mix25: no, adding that line would have no result.
08:33:44 <mix25> aha
08:33:57 <LeCamarade> mix25: Look. You should also remove the [] from what borrar returns.
08:34:20 <LeCamarade> Otherwise, you'll only remove the first [] that borrar finds, and the removing will end.
08:34:30 <byorgey> mix25: by the way, what exactly is this code supposed to do?
08:34:42 <LeCamarade> Maybe a better name than func would serve to make it clear what is not happening.
08:34:43 <byorgey> mix25: my gut tells me that it can probably be done much more simply.
08:34:58 <mix25> maybe, but i'm amateur in haskell
08:35:00 <mix25> new*
08:35:26 <LeCamarade> byorgey: I'm also convinced of that, but let him first get the recursion braintwist right, then they can rely on dons' code well.
08:35:43 <LeCamarade> mix25: I'll tell you something:
08:35:58 <LeCamarade> Move the call to borrar outside of the if clause, so that you have:
08:36:05 <mix25> the code is "filter" the output of "triangularAux" . If exist null intersections then remove it
08:36:06 <LeCamarade> func [[]] = [[]]
08:36:06 <byorgey> LeCamarade: you're probably right.
08:37:14 <LeCamarade> func (xs:zss) = func $ if any (== []) (map (interseccion xs) zss) then borrar xs (xs:zss) else xss
08:37:43 <LeCamarade> mix25: So, if you rename func to removeAllEmptyLists, it may get clearer what your code is doing.
08:38:11 <LeCamarade> (Or you could call it whatever you call it in Portuguese, as the names seem to be in Portuguese.)
08:38:23 <mix25> Yes you are right. This happend because when i become to write this i don't knew what name asign
08:38:52 <cremetorte> we have to examine type inferenz  of  foldr (:) = id        but thats not possible because   foldr (:) :: [a]->[a]->[a]    and  id :: b->b     id only have 1 argument but foldr (:) 2
08:40:02 <LeCamarade> cremetorte: foldr (:) [] is what you want.
08:40:08 <LeCamarade> :t foldr (:) []
08:40:10 <lambdabot> forall a. [a] -> [a]
08:40:25 <LeCamarade> So it is id only for lists, not really id.
08:40:44 <LeCamarade> (Its types are a subset of id's types.)
08:40:45 <cremetorte> yes  but in my paper is written "examine ....   foldr (:) == id    that means its probably a type error
08:41:19 <LeCamarade> Yes. Was the paper talking about Prelude's id and foldr?
08:42:13 <LeCamarade> print =<< xkcdTruestRandom
08:42:32 <cremetorte> yes it was
08:42:34 <LeCamarade> > print =<< xkcdTruestRandom
08:42:36 <lambdabot>  <IO ()>
08:43:01 * LeCamarade hates how I can't get LB to do safe IO ...
08:43:22 <LeCamarade> Or there is no such thing as "safe IO"?
08:43:39 <cremetorte> i dont think foldr (:) [] and id have same type because  id is defined for all types  and foldr (:) [] only for lists
08:43:52 <lilac> LeCamarade: xkcdTruestRandom isn't in IO anyway
08:44:10 <byorgey> cremetorte: right.
08:44:12 <LeCamarade> Yes. :o) Aint.
08:44:30 <LeCamarade> cremetorte: But if you pass (:) in, you'll end up with a list, come what may.
08:45:03 <cremetorte> that means i have to figure it out somehow with type inference :D
08:46:05 <LeCamarade> I don't think you'll be able to cover all the ground of id, because foldr has a list in there, somewhere, so you'll still be caught in lists. I could be wrong.
08:46:49 <cremetorte> mh yeah
08:47:22 <cremetorte> i just could say  that the task is nonsense becaus foldr (:) == id  is not comparable and type error ;D
08:49:17 <LeCamarade> Yeah. Except if the task was given by an Oleg, in which case the rest of the World is wrong.
08:54:54 <Armored_Azrael> Anyone know how one would go about dereferncing a foreign pointer?
08:54:58 <Armored_Azrael> *dereferencing
08:56:28 <Armored_Azrael> I'm essentially trying to turn a null terminated array into a list upon receiving it haskell side and need to extract the values somehow
08:57:35 <Armored_Azrael> Searching for either Ptr a -> a or Ptr a -> [a] seem to return nothing on hoogle.
08:58:14 <quicksilver> Armored_Azrael: peekArray0
08:58:23 <Armored_Azrael> thanks
08:58:27 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html
08:58:28 <lambdabot> http://tinyurl.com/6mhaa3
08:58:50 <Armored_Azrael> oh, my bad, forgot the IO monad in my search :P
08:59:24 <HunterXHunter> @pl \f a b -> foldr (:) b a
08:59:24 <lambdabot> const (flip (foldr (:)))
09:05:04 <nomeata> Hi. It seems that the data darcswatch wants to handle has finally become too big for naive, unoptimized haskell. Are there some easy tricks to see what parts of the program eat up most of the memory?
09:05:04 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
09:08:18 <BMeph> nomeata: 1) Compile with -prof -auto-all; 2) Run with +RTS -hm -RTS
09:08:56 <BMeph> nomeata: Well, let me check that that is the right heap quality you want to look at. :)
09:10:16 <BMeph> nomeata: Hmm, might want -hc instead; see http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#rts-options-heap-prof for details. :)
09:10:18 <nomeata> hmm. good idea. Also, it seems I understand -hr, as I could improve the memory consumption by a quick "if res == res then res else res"
09:10:18 <lambdabot> Title: 6.4. Profiling memory usage, http://tinyurl.com/ycro5f
09:11:22 <FordCortina> !pastebin
09:11:23 <hpaste> Haskell paste bin: http://hpaste.org/
09:11:47 <BMeph> nomeata: Yeah, if which case, http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#retainer-prof is your reference for help. :)
09:11:47 <lambdabot> Title: 6.4. Profiling memory usage, http://tinyurl.com/ycro5f
09:12:48 <nomeata> But anything else besides these flags that I should look at?
09:13:28 <BMeph> nomeata: Probably, but I think those are right in line with what you are looking to do. :)
09:13:47 <dons> think about what data structure you're using. how big does it have to be. what string representation
09:15:33 <smg> yitz: could you solve it?
09:16:10 <yitz> yes, I think so. Are you still stuck?
09:16:29 <smg> yes i am stuck
09:16:35 <smg> i can't figure out can you help me please :(
09:16:54 <yitz> do you think you're closer than when we first started?
09:17:11 <smg> yeah
09:17:18 <smg> just show me the solution i will figure out then
09:18:15 <Socrates> Any way I can use GHCi or lambdabot to find all the known instances of a class?
09:18:32 <vixey> @instances Applicative
09:18:32 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:18:47 <mxc> is anyone familiar with Network.Socket.ByteString? as in, even though its version 0.1.1.2 - is that 'good enough'?
09:18:51 <Socrates> Thanks vixey
09:18:56 <Socrates> @instances Functor
09:18:57 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:19:03 <ddarius> @instances-importing Control.Applicative Applicative
09:19:04 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
09:19:11 <nomeata> dons: too many strings, too few bytestrings, I know :-)
09:19:29 <mxc> oops, sry about the spamming
09:19:34 <mxc> didn't mean to send that
09:19:48 <smg> yitz: ?
09:20:04 <vixey> smg: What is it you are stuck with
09:20:20 <yitz> smg: i'll almost do that. think of the quarter-infinite plane. you can't just iterate over x and then y - because it goes off forever in the x direction, right?
09:20:58 <yitz> smg: so you'll have to make the list comprehension iterate in a different order. that's the point of the problem. agreed so far?
09:21:41 <smg> yitz: yes
09:23:59 <yitz> smg: ok. in a list comprehension, each thing like "x <- [stuff]," iterates over the stuff, and for each element does what is after the comma. x is in scope to the right of the comma, and also to the left of the bar. now think of how you'd do it in an imperitive language, and try that here. Have you been trying something like that yet?
09:24:17 <hpaste>  FordCortina pasted "Gadt problem" at http://hpaste.org/8093
09:24:19 <smg> mh
09:24:27 <smg> yitz: i understand but i don't know how to do
09:24:33 <FordCortina> is it possible to do what i am trying to do there?
09:24:34 <vixey> thinking in terms of imperative languages is not usually helpful
09:24:43 <vixey> smg: What is it you are stuck with?
09:24:53 <yitz> smg: ok describe what order you want iterate in
09:25:02 <vixey> Not :: Query a -> Query (Query a)
09:25:13 <hpaste>  FordCortina annotated "Gadt problem" with "(no title)" at http://hpaste.org/8093#a1
09:25:28 <FordCortina> ic
09:25:44 <BMeph> FordCortina: vixey's got your back, dog. ;)
09:25:50 <yitz> vixey: smg has been working on this problem long enough. let's get him/her past it, I think then it will click.
09:25:50 <FordCortina> :)
09:25:57 <FordCortina> thanks
09:26:08 <smg> i don't have cartesean product
09:26:10 <vixey> yitz: I don't know what the problem is
09:26:12 <smg> but something more diagonal?
09:26:19 <lilac> smg: is your list allowed to include duplicates?
09:27:29 <Jedai> smg : Are you trying to get a bijection between N and NÂ² ?
09:27:30 <yitz> smg: yes yes!  here's a key hint - in each diagonal, the sum of x and y is constant. so first iterate over that sum, then iterate over x. then say y = s - x.
09:27:51 <smg> mh
09:27:55 <smg> makes my brain die
09:28:10 <ddarius> Draw a picture
09:28:12 <yitz> smg: oh dear
09:28:43 <Jedai> Yeah, a picture is good to understand what's going on, and yitz proposition is pretty clear
09:28:54 <yitz> smg: you've really been working on this too long, you're burning out
09:29:09 <FordCortina> thanks vixey, my gadt works :)
09:29:26 <smg> yeah do you have the code?
09:29:31 <smg> maybe i can figure out it that way
09:29:55 <vixey> smg: Are you able to actually say what it is you are having trouble doing?
09:30:29 <Jedai> [(x,y) | s <- [0..], x <- [0..s], let y = s - x ]
09:30:39 <smg> that's it?
09:30:57 <yitz> > [(x,y) | s <- [0..], x <- [0..s], let y = s - x ]
09:30:57 <lilac> smg: that gives you indices
09:30:57 <smg> now i understand it hehehe :(
09:30:58 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
09:31:02 <Jedai> That's literally what yitz said....
09:31:07 <smg> yep
09:31:09 <smg> i understand
09:31:16 <smg> but now i need to make just one change do i?
09:31:31 <smg> i need (a,b) where a divisable by 5 and b is even
09:31:39 <yitz> smg: draw the picture, it's worth it. this trick is used all the time.
09:31:47 <smg> hehe ok
09:32:02 <lilac> smg: you could filter it, or you could use ([5,10..] !! x, [2,4..] !! y)
09:32:07 <lilac> or something more cunning.
09:32:31 <yitz> > [(x,s-x) | s <- [0..], x <- [0..s]] -- without using "let"
09:32:33 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
09:32:35 <lilac> (5*x, 2*y) is proably as cunning as you need
09:32:39 <smg> mh
09:32:41 <smg> so i would do
09:33:04 <smg> [(5*a,2*b) | s <- [0..], a <- [0..s], let b = s -  ]
09:33:06 <smg> -a
09:33:48 <smg> can you tell me how that type is called?
09:34:03 <smg> i mean the list comprehension style? i want to read something more about that in google or somewhere!
09:35:01 <yitz> smg: the type is [] (list). the syntax is "list comprehension". the trick is "diagonalization".
09:42:40 <hpaste>  tphyahoo pasted "Is there some way to write tablify as a fold? (or an unfold?)" at http://hpaste.org/8094
09:42:45 <paolino> is google down ?
09:42:58 <mrd> > fix $ \ f -> (1,1):concat [ [(i,i+j), (i+j,j)] | (i, j) <- f ]
09:43:00 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(3,2),(2,3),(3,1),(1,4),(4,3),(3,5),(5,2),(2,5),(5,...
09:43:40 <opqdonut> paolino: doesn't seem so
09:44:29 <opqdonut> tphyahoo: yeah that's an unfold
09:45:16 <hpaste>  tphyahoo annotated "Is there some way to write tablify as a fold? (or an unfold?)" with "(no title)" at http://hpaste.org/8094#a1
09:46:01 <opqdonut> > unfoldr (Just . (take 2 &&& drop 2)) [1..]
09:46:03 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,...
09:46:06 <opqdonut> something in that vein
09:46:50 <opqdonut> tphyahoo: you don't need to pass n to f as an argument
09:47:07 <opqdonut> but that would seem correct
09:47:20 <byorgey> paolino: http://downforeveryoneorjustme.com/
09:47:21 <lambdabot> Title: Down for everyone or just me?
09:47:47 <opqdonut> byorgey: heh
09:48:19 <hpaste>  tphyahoo annotated "Is there some way to write tablify as a fold? (or an unfold?)" with "the whole tamale (with verboseCheck)" at http://hpaste.org/8094#a2
09:48:48 <tphyahoo> thanks guys.
09:49:33 <tphyahoo> > unfoldr (Just . (take 2 &&& drop 2)) ['a'..'z']
09:49:34 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz","","","","...
09:49:37 <paolino> byorgey: looks like a lot of sites are unreacheable here
09:50:32 <HunterXHunter> @src Just
09:50:33 <lambdabot> Source not found. There are some things that I just don't know.
09:50:46 <Deewiant> @src Maybe
09:50:46 <lambdabot> data Maybe a = Nothing | Just a
09:51:07 <paolino> :t Just
09:51:08 <lambdabot> forall a. a -> Maybe a
09:51:20 <byorgey> > unfoldr (Just . splitAt 2) ['a'..'z']
09:51:21 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz","","","","...
09:51:49 <byorgey> (take n &&& drop n) === splitAt n
09:52:57 <paolino> @hoogle [a] -> ([a],[a])
09:52:57 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
09:52:58 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
09:52:58 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
09:53:21 <paolino> :t break
09:53:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:53:57 <opqdonut> byorgey: good point
10:01:49 <yitz> > takeWhile (not.null) . evalState $ repeatM (State $ splitAt 2) ['a'..'z']
10:01:50 <lambdabot>   Not in scope: `repeatM'
10:02:06 <yitz> > let repeatM = sequence . repeat in takeWhile (not.null) . evalState $ repeatM (State $ splitAt 2) ['a'..'z']
10:02:07 <lambdabot>  Couldn't match expected type `[[a]]'
10:02:29 <tphyahoo> yeah... it felt to me like this wanted state... but I couldn't figure out how.
10:02:38 <tphyahoo> there's a tie in because unfolds and state isn't there?
10:02:52 <tphyahoo> s/because/between/
10:03:18 <byorgey> @src State
10:03:18 <lambdabot> Source not found. :(
10:03:27 <byorgey> @type State
10:03:29 <lambdabot> forall s a. (s -> (a, s)) -> State s a
10:03:54 <yitz> > let repeatM = sequence . repeat in takeWhile (not.null) $ evalState (repeatM $ State $ splitAt 2) ['a'..'z']
10:03:57 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
10:04:38 <tphyahoo> very nice.
10:05:20 <tphyahoo> I wonder if you could do words/lines using unfoldr and/or state?
10:05:35 <byorgey> sure you could.
10:06:11 <tphyahoo> a parse is a state, right? is a parse then also an unfold?
10:07:08 <byorgey> intuitively it seems like you would only be able to parse certain grammars with an unfold.  in particular you can't do any backtracking.
10:07:18 <BMeph> >  unfoldr (unFFunc (not . null)  splitAt 2) ['a'..'z']
10:07:19 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
10:07:46 <BMeph> > unfoldr (unFFunc (not . null)  (splitAt 2)) ['a'..'z']
10:07:52 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
10:07:56 <chessguy> @hoogle unFFunc
10:07:56 <lambdabot> No matches found
10:08:16 <BMeph> chessguy: unFFunc p f x = guard (p x) >> Just (f x)
10:08:39 <vixey> > transpose [[22,55],[1..10]]
10:08:40 <lambdabot>  [[22,1],[55,2],[3],[4],[5],[6],[7],[8],[9],[10]]
10:08:53 <BMeph> chessguy: It's from my Utility collection. :)
10:09:21 <vixey> > transpose [['a','c'..'z'],['b','d'..]]
10:09:23 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz","|","~","\...
10:11:52 * vixey takes a second attempt at reading http://www.cs.ru.nl/~venanzio/publications/Recursion_Coinductive_LMCS_2005.pdf
10:11:53 <lambdabot> http://tinyurl.com/5tcpja
10:12:01 <hpaste>  FordCortina pasted "is it possible to get simplify to work?" at http://hpaste.org/8095
10:12:20 <BMeph> vixey: Does that paper explain the fold/unfold connection? :)
10:12:28 <vixey> I don't think so
10:12:34 <vixey> I haven't read it yet
10:12:54 <vixey> change your GADT FordCortina
10:12:55 <vixey> Not :: Query a -> Query (Query a)
10:12:56 <vixey> should be
10:12:58 <vixey> Not :: Query a -> Query a
10:13:09 <vixey> Or :: [Query a] -> Query [Query a]
10:13:14 <vixey> should probabylb be
10:13:16 <vixey> Or :: [Query a] -> Query [a]
10:13:17 <tphyahoo> t6 = let repeatM = sequence . repeat in takeWhile (not.null) $ evalState
10:13:17 <tphyahoo>        (repeatM $ State $ splitAt 2) ['a'..'z']
10:13:26 <vixey> stuff like that anway
10:13:31 <byorgey> vixey: wow, that paper looks like fun =)
10:13:32 <tphyahoo> what'm I doing wrong? (from yitz earlier)
10:13:40 <tphyahoo> doesn't compile.
10:13:58 <FordCortina> thanks vixey
10:14:04 <yitz> too many =
10:14:21 <byorgey> tphyahoo: just put the 'repeatM = sequence . repeat' on a separate line
10:14:35 <tphyahoo> :r
10:14:55 <tphyahoo> repeatM not in scope
10:15:21 <tphyahoo> nevah mind
10:15:32 <yitz> That's the problem with lambdabot understanding ":t". now whenever anyone says ":r" I expect lambdabot to reload.
10:16:03 <Baughn> That might actually be a good idea. Get rid of all the @lets..
10:16:16 <lament> :wq
10:16:45 <tphyahoo> :r
10:17:43 <roconnor> In a certain sense, I think it is pretty clear what packages ought to go into core: thoses packages that provide datatypes that are used interface different packages:  List, Maybe, Either, etc.
10:17:45 <yitz> :def hack System.Cmd.system
10:19:10 <Baughn> roconnor: ByteString?
10:19:29 <Baughn> (Which still looks like UArray Word8 to me)
10:20:16 <roconnor> Baughn: sounds reasonable
10:20:30 <roconnor> is ByteString (slated) to be part of core?
10:20:40 <Baughn> No, it just got /removed/ from core. ;)
10:20:46 <roconnor> oh
10:20:50 <roconnor> :/
10:20:55 <roconnor> why is that
10:21:00 <Baughn> The Great Package Split of '.8
10:21:19 <roconnor> maybe my createrion for what should be in core is wrong.
10:21:23 <Baughn> I suppose so it could be updated independently of ghc. Makes sense for me, really..
10:21:34 <roconnor> hmm
10:21:37 <roconnor> interesting
10:21:43 <Baughn> The current criterion seems to be "core = stuff that is integral to ghc"
10:22:02 <roconnor> ok
10:22:08 <roconnor> let's make bytestring internal to GHC
10:22:13 <roconnor> that should be easy
10:22:22 <Baughn> That's not something you /want/
10:22:25 <roconnor> GHC has to parse files after all.
10:22:33 <roconnor> why not?
10:22:36 <Baughn> Packages are in core because you have no choice, not because you feel like it
10:22:45 <Baughn> And bytestring happens to be usable in distributions other than ghc
10:22:45 <roconnor> then everyone who gets GHC will get ByteString
10:22:52 <twanvl> Nothing should be in core
10:23:05 <Baughn> roconnor: ..why do you want to merge packages anyway?
10:23:12 <Baughn> It's generally assumed that smaller packages = better
10:23:17 <nomeata> btw, if I want to use a newer ByteString on an 6.6 installation (with older bytestring in core), how can I do that?
10:23:21 <roconnor> Baughn: I dont' want to merge packages
10:23:34 <yitz> > map (map snd) . groupBy (comparing fst) $ zip (concat . transpose $ replicate 2 [0..]) ['a'..'z']
10:23:35 <lambdabot>  Couldn't match expected type `Bool'
10:23:44 <roconnor> Baughn: but I we need consistent datatypes to interface different packages.
10:23:49 <Baughn> nomeata: You'd have to upgrade ghc, or rename the bytestring modules
10:23:58 <Baughn> nomeata: There are /good reasons/ it was split out.
10:24:07 <yitz> @type comparing
10:24:08 <roconnor> maybe ByteString-core ought to be part of core
10:24:09 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:24:19 <Baughn> roconnor: Well, sure. Multiple packages can use bytestring, they just all depend on it.
10:24:20 <roconnor> I really only care about the datatypes
10:24:32 <Baughn> roconnor: Things don't need to be in core to be used by multiple packages
10:24:36 <roconnor> Baughn: that's great until I fork bytestring
10:24:42 <yitz> > map (map snd) . groupBy ((==) `on` fst) $ zip (concat . transpose $ replicate 2 [0..]) ['a'..'z']
10:24:44 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
10:24:49 <Baughn> roconnor: Why would you do that?
10:24:59 <Baughn> roconnor: And moreover, how on earth is bytestring being in core going to help things?
10:25:00 <roconnor> Baughn: because my ByteString is better.
10:25:23 <Baughn> roconnor: And the current bytestring maintainers won't accept your patches?
10:25:28 <roconnor> Baughn: no one will use my ByteString if it isn't compatable with the one distributed by GHC.
10:25:45 <roconnor> Baughn: yep, for some stupid reason they think my fork is stupid.
10:25:57 <Baughn> roconnor: Well, no. If it's in core it won't be /possible/ to update bytestring without also updating ghc.
10:26:27 <Baughn> roconnor: If they're separate packages.. bytestring1 and bytestring2 had better use different module names, too, or it'll clash
10:26:27 <roconnor> Baughn: so we should put ByteString-core into GHC then?
10:26:36 <Baughn> roconnor: Why?
10:26:55 <cnwdup> :t id
10:26:56 <lambdabot> forall a. a -> a
10:26:59 <roconnor> Baughn: becasue then ByteString can be updated independently of GHC.
10:27:31 <Baughn> roconnor: ..no, that's backwards. If it IS in core then you CAN'T upgrade it independently; if it ISN'T (as now), then you CAN.
10:27:41 <roconnor> Baughn: you make an interesting point about different module names.  I'll have to think about that.
10:28:05 <roconnor> Baughn: but we can put part of bytestring into core.  The part that doesn't change.
10:28:22 <roconnor> maybe I misunderstand what is being updated when bytestrings are updated.
10:28:32 <Baughn> roconnor: Why would you put that in core? It'd make far more sense to just split the bytestring package in two.
10:28:50 <Baughn> roconnor: Also, there is no such part.
10:29:15 <Baughn> I suppose you can write utility functions that act on bytestrings via the existing interface. You can do that /right now/, though - no need for splits.
10:30:44 <vixey> "ï¬lter completion." :S
10:32:11 <lilac> > filter (not.(`elem` ['b','d'..]).(!!0)) $ drop 2 (inits ['a'..'z']) >>= (:[]) . reverse . take 2 . reverse
10:32:12 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
10:33:54 <tphyahoo> on
10:34:08 <tphyahoo> how do I get the def of on?
10:34:16 <mauke> @src on
10:34:16 <lambdabot> (*) `on` f = \x y -> f x * f y
10:39:21 <roconnor> maybe twanvl is right.  There should be no core.
10:46:59 <frwmanners> >  take 13 $ zipWith (\a b -> [a,b]) ['a'..] ['b'..]
10:47:01 <lambdabot>  ["ab","bc","cd","de","ef","fg","gh","hi","ij","jk","kl","lm","mn"]
10:47:15 <frwmanners> >  take 13 $ zipWith (\a b -> [a,b]) ['a','c'..] ['b','d'..]
10:47:16 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
10:47:23 <vixey> > transpose [['a','c'..'z'],['b','d'..]]
10:47:24 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz","|","~","\...
10:51:33 <tieTYT> > ['a'..]
10:51:35 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
10:51:38 <tieTYT> ah
10:52:57 <mrd> > last ['a'..]
10:52:59 <lambdabot>  '\1114111'
10:53:57 <vixey> what is '\1114111'?
10:54:13 <mrd> :t last ['a' ..]
10:54:15 <lambdabot> Char
10:54:22 <shapr> Looks like a unicode char to me.
10:54:23 <int-e> > maxBound :: Char
10:54:24 <lambdabot>  '\1114111'
10:54:40 <vixey> yeah but is it UPSIDE_DOWN_SNOWMAN or something
10:54:41 <int-e> > printf "%x" 1114111
10:54:42 <lambdabot>  Add a type signature
10:54:46 <int-e> > printf "%x" 1114111 :: String
10:54:48 <lambdabot>  "10ffff"
10:55:09 <mrd> > showHex 1114111
10:55:11 <lambdabot>  <[Char] -> [Char]>
10:55:14 <shapr> I like HEAVY_BLACK_HEART myself.
10:55:14 <mrd> > showHex 1114111 ""
10:55:16 <lambdabot>  "10ffff"
10:55:28 <vixey> aww
10:55:28 <mauke> â¤
10:58:24 <dons> so lads, how are we going to take over the world today?
10:58:41 <dibblego> hit the idiot club over the head with a stick
10:58:59 <mrd> wouldn't the idiot club be the stick?
10:59:02 <vixey> hey I am a founder of the idiot club
10:59:47 <dons> that's a private gentleman's club
10:59:54 <dons> invitation only
11:00:34 <Botje> @tell ndm Can you give me a pong when you're here? I've got a question about uniplate.
11:00:34 <lambdabot> Consider it noted.
11:00:49 <Botje> (unless someone here is also familiar with uniplate?)
11:01:50 <vixey> beh...... this maths is too hard I will have to print it out
11:03:09 <hpaste>  Botje pasted "How to do this with descend or descendM?" at http://hpaste.org/8096
11:07:27 <BMeph> "Not only am I the president of the Idiot Club for Men..." ;)
11:09:39 <shapr> dons: Today, we will use adjoint functors.
11:10:30 <dons> awesome.
11:11:23 <shapr> dons: What about tomorrow?
11:12:09 <dons> don't think about tomorrow, we still have so much to accomplish today!
11:12:51 <dons> a lambda for every child! and a free trade of monads agreement to sign with our allies
11:13:16 <Botje> no closure left behind!
11:13:17 * byorgey re-appropriates the OLPC acronym
11:13:23 <dons> Botje: quite so!
11:13:26 <lament> read my lips: no more side effects!
11:13:51 <chr1s> dons: nice article (again).
11:13:59 <chr1s> I enjoyed reading it.
11:14:20 --- mode: ChanServ set +o dons
11:14:29 --- topic: set to '["Read my lips: no more side effects!", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ "]' by dons
11:14:31 <Botje> )
11:14:34 --- mode: ChanServ set -o dons
11:14:34 <dons> chr1s: sure!
11:17:01 <chr1s> do you have more optimization stuff planned for your blog?
11:17:51 <dons> probably, if people are interested
11:18:28 <dons> shapr, man, that obama guy sure gives a good speech. i need to study how he writes so effectively on optimism, change and seizing the moment.
11:18:30 <chr1s> I know a lot of folks here like it (fellow Master students @ Utrecht)
11:18:48 <dons> chr1s: oh awesome. well, if you've suggestions on interesting things to look at, that'd be useful
11:18:55 <dons> i quite enjoy writing about performance stuff
11:21:21 <nomeata> allright, darcswatch uses ByteStrings mostly now, and it did cut the memory consumption a lot, as expected. Too bad that Network.URI does not do bytestrings...
11:23:11 <roconnor> Too bad Obama isn't promoting Haskell.
11:23:19 <thetallguy> dons: I think it's excellent Haskell PR for long-time programmers who require reliable optimizations
11:23:57 <tromp> google has 112000 hits for haskell obama
11:24:07 <dons> ... if we are willing to work for it, and fight for it, and believe
11:24:07 <dons> in it, then I am absolutely certain that generations from now, we
11:24:07 <dons> will be able to look back and tell our children that this was the moment
11:24:07 <dons> when we began to make programming not suck; this was the the moment
11:24:07 <dons> when we stopped accepting flaws, errors and crashes; this was the moment
11:24:10 <dons> we secured our software and restored the image of functional programmin
11:24:12 <dons> gas the last, best hope on Earth. This was the moment -- this was the
11:24:15 <dons> time -- when we came together to remake computer science...
11:24:16 <mauke> aaah
11:24:17 <dons> :)
11:24:34 <thetallguy> dons: source?
11:25:10 <dons> oh, that was the end of obama's speech last night, about how "this was the moment" when we began to change things.
11:25:18 <thetallguy> ah
11:25:30 <byorgey> I'm guessing dons changed a few bits there... =)
11:25:48 <thetallguy> It's odd, isn't it, how many of us programmers think programming sucks?
11:25:57 <dons> yeah. jus tthinking about optimism, and not being satisifed with bugs, errors, and fragility
11:26:31 <dons> thetallguy: ah, you think the blog was useful for old hands?
11:27:40 <pafcu> Did any of you see the Obama interview at Google? He was asked what the fastest way to sort a million 32-bit integers is
11:27:51 <vixey> lol
11:27:56 <thetallguy> dons: well, I have to stop and slow down and read carefully, so I suspect the details may be lost on someone who doesn't know haskell, but the gist is clear as day
11:28:19 <MWumpusZ> what's this paper we're talking about? :)
11:28:55 <thetallguy> dons: and I think it represents the first wire that connects two halves of a bridge
11:29:36 <thetallguy> dons: engineers are skeptical of ``we can do all kinds of automatic optimizations''
11:29:46 <edwardk> pacfu: now the question that will decide the election: did he know the answer? =)
11:30:00 <nomeata> is there a bytestring MD5 module around?
11:30:08 <thetallguy> dons: but show them where the compiler failed and how you could tell it to improve and you beat gcc
11:30:44 <thetallguy> dons: and I can't imagine there won't be some quiet ones who think the time to switch is getting near.
11:31:33 <nomeata> Iâ€™ll try nano-md5
11:31:40 <pafcu> edwardk: He said that you shouldn't use QuickSort for that task.
11:31:47 <thetallguy> dons: after all, at Linspire, we knew all along that we wanted to end up in Haskell, but things just weren't quite there when we started
11:32:15 <edwardk> pacfu: heh
11:32:16 <pafcu> But no specific best implementation was mentioned, so clearly he is unfit for presidency :-)
11:32:35 <thetallguy> dons: it was when you published bytestring and 6.6 had the module system that we felt there was enough in place that we could switch from O'Caml
11:32:39 <edwardk> pacfu: hey a president who knows that quicksort exists is a step in the right direction ;)
11:33:12 <thetallguy> dons: sure enough, the first problem we hit was Parsec not being able to handle a 30MB Debian package index file
11:33:16 <vixey> http://uk.youtube.com/watch?v=k4RRi_ntQc8
11:33:17 <lambdabot> Title: YouTube - Barack Obama - Computer Science Question
11:33:17 <vixey> :D
11:33:48 <thetallguy> dons: but Jeremy basically just forked Parsec and did s/String/ByteString/ and we were rolling again
11:34:34 <thetallguy> dons: so yes, it's valuable.  More lurkers than talkers, I suspect.
11:37:32 <edwardk> bah he only mentioned bubble sort ;)
11:38:58 <tromp> that's not very efficient:(
11:39:26 <nomeata> dons: thx, nano-md5 works fine for me
11:40:03 <byorgey> pafcu: no, he said you shouldn't use *bubble* sort =)
11:40:29 <vixey> I got so stuck reading :(
11:40:57 <byorgey> clearly some google employee tipped him off to the question beforehand, it was pretty funny ;)
11:41:13 <tromp> i cldn't hear it clearly; the audio was very distorted
11:41:18 <edwardk> tromp: well, he said 'i wouldn't use bubblesort' so its classic politician doublespeak. he didn't answer the question, just negated a strawman option that no one would dare seriously propose ;)
11:41:27 <vixey> haha
11:42:48 <dons> thetallguy: great, that's inspiring.
11:42:55 * Philippa_ would bubblesort a 3 item array, but then it does specialise rather nicely
11:43:12 <edwardk> heh
11:43:15 <dons> i really think ocaml's has lost any performance advantage now. we're ahead on the shootout, and things are only getting faster.
11:44:03 <dibblego> dons, shall we send jdh the memo?
11:44:18 <Philippa_> dons: how fast do monad transformer stacks end up these days? How does our continuation monad compare to their call/cc?
11:44:23 <edwardk> Philippa_: yeah the question is do you want to let it run long enough to specialize the million integers he was asked about =)
11:44:26 <shapr> hoi tromp! When will you visit Bostonia?
11:44:50 <shapr> dons: Hah, I love the topic!
11:45:05 * shapr boings cheerfully
11:45:10 <dons> dibblego: oh, jdh sidelined himself by jumping on the F# band wagon.
11:45:19 <yitz> dons: nice blog article. the front page doesn't display right in Safari though.
11:45:28 <edwardk> dons: ?
11:45:32 <dons> Philippa_: i don't know the answer. dcoutts and i were pondering an examination of that stuff
11:45:33 <shapr> I need a non-crappy soldering iron and a solder sucker... and some good way to run Haskell code in 16k of ram on a 8MHz chip.
11:45:44 <dons> yitz: oh interesting.
11:45:55 <dons> i'm thinking its about time i moved the blog somewhere else anyway
11:46:02 <vixey> I'd lend you my solder iron...
11:46:24 <yitz> dons it runs off the right of the window with no horiz. scrollbar. When I click on the article link it's fine.
11:46:27 <shapr> vixey: Where is your soldering iron?
11:46:38 <dons> yitz: interesting.
11:46:41 <vixey> somewhere in my parents house I guess ;p
11:46:48 <dons> yitz: i'll look into where i can move it.
11:47:10 <shapr> vixey: Where's your parents house? Near Boston?
11:47:13 <Philippa_> shapr: I might be tempted to use external core and translate it to a tightly-encoded VM on that kind of kit. Depending on whether you're more worried about clocks or memory
11:47:36 <vixey> a few coutries away I think
11:47:48 <thetallguy> shapr: yhc bytecode
11:47:53 <Philippa_> though if I'm really honest, I wouldn't run Haskell. Which reminds me, I so need to spit out a simple regioned FPL from my lang hackery folder at some point
11:48:19 <shapr> thetallguy: Yeah, good idea.
11:48:32 <thetallguy> shapr: 16K is probably too small
11:48:34 <shapr> vixey: Probably too far for me to go pick it up.
11:48:57 <thetallguy> shapr: I think the runtime is still 100K without gmp
11:49:06 <shapr> thetallguy: Ok, should I go towards the reduceron idea, or should I just go for a strict DSL designed to run programs in 16k or so?
11:49:44 <thetallguy> oog
11:49:47 <thetallguy> dunno
11:49:59 <thetallguy> what's the device?
11:50:05 <shapr> Arduino
11:50:13 <thetallguy> I beg your pardon?
11:50:21 <shapr> http://www.arduino.cc/
11:50:22 <lambdabot> Title: Arduino - HomePage
11:50:35 <jewel> shapr, forth?
11:50:49 <thetallguy> oh, I see.  Sure you can't use a chumby?
11:51:15 <shapr> Currently uses the ATmega 168P, but there are rumors of a 328P version coming soon. The 328P has lots more ram, I forget how much more.
11:51:31 <shapr> thetallguy: I guess I could, but I'm currently interested in the Arduino specifically.
11:51:43 <thetallguy> I guess I would go the DSL route
11:51:51 <shapr> Haskell doesn't really lend itself to embedded development.
11:51:58 <thetallguy> not yet
11:52:41 <thetallguy> on the other hand, I know the Chumby guys...
11:52:51 <shapr> I know one of the Arduino guys.
11:52:57 <shapr> Thus my interest :-)
11:53:00 <thetallguy> Heh.
11:53:21 <shapr> The geek community is strongly connected.
11:53:31 <thetallguy> Well, good luck with 16K
11:53:35 <thetallguy> :-)
11:53:55 <shapr> jewel: I've been writing C programs for it so far.
11:54:02 <shapr> jewel: But something more functional would be preferable.
11:54:58 <shapr> Ah, the 328 has 32k ram instead of 16k.. twice as much!
11:55:38 <yitz> shapr: write a YHC Core backend for the flavor of C that you need for your little board.
11:56:13 <shapr> Sounds like the best approach if I want to run 'real' Haskell on this device.
11:56:19 <augustss> @seen bos
11:56:19 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
11:57:12 <vixey> huh....... http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=3
11:57:12 <proq> it has less ram than a gumstix which has 64MB, but the gumstix is smaller
11:58:17 * shapr compares prices between Arduino and gumstix.
11:59:15 <bos> augustss: hello there
11:59:36 <bos> coolio! i think i'll be giving a haskell talk at this year's supercomputing conference.
11:59:49 <augustss> bos: I've actually been doing some llvm stuff, so I thought we could make a new release soon.
11:59:53 <vixey> hehehe
12:00:00 <bos> augustss: that would be wonderful.
12:00:02 <vixey> unsafeRepeat :: (a -> Either b a) -> a -> b
12:00:10 <bos> augustss: have you solved the phi node problem?
12:00:20 <vixey> unsafeRepeat f a = case f a of Left b -> b ; Right a' -> unsafeRepeat f a'
12:00:22 <augustss> bos: the phi nodes are gone now, they are implicit
12:00:32 <bos> nice.
12:00:50 <shapr> proq: I should have investigated gumstix before, it has an excellent price/performance balance!
12:01:24 <augustss> bos: I'll write some more documentation and make some examples and then we are good to go, i think.
12:02:20 <bos> augustss: sounds good.
12:04:47 <vixey> what's A |--> vX.A + X?
12:04:54 <smg> yitz: thank you
12:05:04 <smg> yitz: are you still in?
12:05:05 <vixey> is |--> lambda ?
12:05:15 <yitz> smg: still here.
12:05:21 <vixey> and I guess vX.A + X is Either?
12:05:32 <vixey> v is mu?
12:05:42 <yitz> yitz: everything else ok w/ hw?
12:05:52 <yitz> smg ^
12:06:17 <b_jonas> wow
12:06:17 <pejo> augustss, "llvm stuff"?
12:06:19 <smg> yitz: is diagonalization something i had to know as haskell beginner/ functional programmer?
12:06:23 <smg> or am i stupid then? :|
12:06:47 <augustss> pejo: yes, improving the llvm bindings
12:06:58 <yitz> smg: it a general computer science thing. often encountered first time in some sneaky hw prob. :)
12:07:09 <dmwit> Diagonalization is a pretty obscure mathematical trick.
12:07:38 <dmwit> Well... obscure isn't the right word.
12:07:41 <vixey> I think it's something from category theory
12:07:53 <dmwit> vixey: diagonalization?
12:07:57 <yitz> smg: when Cantor first thought of it , he proved things which really perplexed people at the time.
12:08:00 <vixey> no
12:08:03 <dmwit> oh
12:08:03 <smg> okay
12:08:12 <smg> yitz: is there a book which covers that? maybe TAPL?
12:08:24 <dmwit> Like the rationals are countably infinite!
12:08:33 <dmwit> There's just as many integers as rationals! O_o
12:08:37 <solrize_> diagonalization?  not TAPL, try an intro set theory book
12:08:41 <solrize_> Enderton's maybe
12:08:46 <yitz> smg: it's not a topic of its own right. its just one little trick that just comes up all the time in math and cs.
12:09:00 <vixey> the more surpising result is that there's more reals than rationals
12:09:04 <smg> solrize_: k maybe i find on the web something?
12:09:07 <dmwit> http://www.mathpages.com/home/kmath371.htm # haven't read it, but...
12:09:08 <lambdabot> Title: Cantor's Diagonal Proof
12:09:08 <thorkilnaur> Diagonalization was used by Cantor to prove that ther are "more" relas between 0 and 1 than integers
12:09:09 <pejo> smg, "Elements of the theory of computation" has a small part of it iirc. But probably a bit overkill unless you want to learn more about complexity classes and turing machines.
12:09:13 <solrize_> smg, wikipedia
12:09:22 <smg> mh not really solrize_ ?
12:09:32 <thorkilnaur> ... there are more reals ...
12:09:40 <smg> i want to learn about diagonalization and free/bound variables :]
12:10:01 <augustss> hmmm, that latter is easier
12:10:08 <solrize_> http://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument
12:10:14 <smg> solrize_: i look ty
12:10:33 <solrize_> diagonaliization and free/bound variables??!!   hmm
12:11:20 <vixey> how do I take the quotient of a Monad with respect to an equivalence relation?
12:11:27 <smg> solrize_: yes
12:11:47 <smg> wikipedia article mh is not really good because it contains "only" mathematical proofs
12:11:51 <smg> i need more easy :|
12:12:13 <vixey> :t (\x -> y (\y -> foo x) (\z -> y x))
12:12:15 <lambdabot> Not in scope: `foo'
12:12:27 <vixey> smg: :t calculate that foo is a free variable
12:12:33 <solrize_> i don't think diagonalization shows up in PL theory very much
12:12:43 <smg> mh
12:12:54 <smg> free and bound variables mh, maybe someone can point out
12:13:15 <vixey> smg: Do you have a definition of bound and free variables?
12:13:18 <smg> there must be something good as the web but i'm unable to find
12:13:22 <smg> vixey: not a good
12:13:27 <vixey> smg: tell me it anyway
12:13:35 <smg> bound var = variable which cannot be substitutet
12:13:44 <smg> free var = variable which can be substituted
12:13:57 <vixey> no
12:13:59 <mauke> a free variable is undefined
12:13:59 <thorkilnaur> solrize_, PL theory ...?
12:14:00 <vixey> that's not really right
12:14:07 <b_jonas> well, there's the diagonalization argument about the halting problem too
12:14:37 <smg> mh i would be very happy if someone can come along with a good webpage with examples + definitions of that bound/free variable thingy
12:14:49 <vixey> smg: We can use some syntax: <term> ::= <variable> | \<variable>-><term> | <term>$<term>
12:15:11 <solrize_> PL = programming language
12:15:28 <vixey> freeVars( v ) = [v]  ( v is any <variable> )
12:15:31 <solrize_> stuff like free and bound variables
12:15:54 <vixey> freeVars( \v->t ) = freeVars( t ) \\ [v]
12:16:05 <vixey> freeVars( t$t' ) = freeVars( t ) ++ freeVars( t' )
12:16:15 <thorkilnaur> solrize_, Oh. In that case, I would repeat what b_jonas already hinted at: The halting problem.
12:16:27 <vixey> smg: And bound variables are the complement of that set wrt all the variables in a terma
12:16:35 <smg> mh
12:16:57 <vixey> smg: You could could try this in Haskell
12:17:05 <vixey> use data instead of ::= etc..
12:17:06 <smg> isn't there a good page about it? :|
12:17:09 <b_jonas> the halting one is mentioned at lots of places in good popular science books,
12:17:16 <solrize_> thorkilnaur, yeah, that's the most obvious use of diagonalization in CS, but that's more computability theory
12:17:19 <vixey> smg: Isn't what I said good enough?
12:17:44 <b_jonas> including Hofstadter; Smullyan; Penrose's the Emperor's new mind etc
12:17:52 <solrize_> PL theory is a fairly narrow CS subtopic but haskell folks study it a lot
12:18:14 <b_jonas> but my favourite explanations on the halting problem aren't those
12:19:09 <b_jonas> there's a fun alternate proof which uses Kolmogorov complexity in the RÃ³nyaiâ€“Ivanyosâ€“SzabÃ³ book
12:19:24 <smg> vixey: no
12:19:30 <vixey> smg: why?
12:19:41 <b_jonas> and there's a proof that is allegedly from PÃ³sa Lajos and I've never seen it written
12:19:45 <smg> i have a rather complex let expression and i need to figure out free/bound variables "VERBOSELY"
12:20:15 <vixey> smg: so add let to the syntax and define freeVars on it
12:20:21 <smg> mh
12:20:22 <thorkilnaur> solrize_, You are right, of course, not exactly programming language theory ...
12:20:33 <smg> vixey: is there nothing on the web? i wanted to read an article
12:20:59 <vixey> smg: you could just paste what I said onto a website.. I don't see the difference it would make though
12:21:10 <smg> mh
12:21:35 <smg> maybe i am too stupid at the moment sorry
12:21:38 <proq> haha
12:21:58 <sclv> http://ebiquity.umbc.edu/blogger/2008/01/19/how-dr-suess-would-prove-the-halting-problem-undecidable/
12:22:05 <vixey> smg: You could just ask about any particular things that don't make sense
12:22:10 <lambdabot> Title: How Dr. Seuss would prove the halting problem undecidable, http://tinyurl.com/25swk4
12:22:20 <proq> smg: I'm laughing at vixey, not you btw
12:23:06 <vixey> at me ?
12:23:55 <smg> mh
12:25:59 <_andre> is there a function that helps in receiving an infinite list l and returning a list of n groups of k elements taken from l?
12:26:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8097
12:26:10 <_andre> i'm doing the recursion manually and using splitAt
12:26:13 <smg> http://hpaste.org/8097
12:26:16 <smg> check the link
12:26:33 <proq> vixey: yes. for some reason people like to believe something because it's an article, whether it's true or not. wikipedia is the most obvious example
12:27:21 <vixey> smg: You need to add let and if _ then _ else to the syntax, and freeVar function
12:27:35 <_andre> (i mean returning a list of n sublists of size k)
12:28:01 <vincenz> @hoogle compileExpr
12:28:01 <lambdabot> No matches found
12:28:07 <vincenz> @index compileExpr
12:28:07 <lambdabot> bzzt
12:28:15 <smg> vixey: mh yes but this should be rather complex
12:28:25 <smg> proq: i don't believe articles
12:28:29 <smg> but i need a good to explain that stuff
12:29:05 <vixey> _andre: I think you could look at it in terms of,  n sublists of size k from the first n*k elements of l, then the same from the first n*k + 1 elements of l, and so on..
12:29:15 <vixey> _andre: does that seem sensible ?
12:29:35 <vixey> smg: that's not true, however complex you want it to be.. it is actually very simple
12:29:47 <smg> yes
12:29:51 <smg> because i have no material which explains
12:29:55 <smg> if i would have i would understand
12:30:14 <vixey> smg: Did you understand what I explained? about v | \v->t | t$t'
12:30:16 <_andre> vixey: well that's what i'm doing. i'm just wondering if there's some kind of "grouping" function that would help with that in the standard libs
12:30:20 <smg> same with diagonalization i don't find good explanations and examples in it
12:30:26 <smg> vixey: no
12:30:37 <_andre> i have a function that works, but maybe i could get rid of the manual recursion
12:31:19 <smg> vixey: maybe you can explain _again_ how i can find out free variables of an let expression
12:31:25 <vixey> _andre: well you want to select out e elements from the first n*k+e elements of l then put it into chunks of k
12:31:43 <vixey> | let v = t in t
12:32:12 <vixey> freeVars( let v = t in t' ) = freeVars( t ) ++ (freeVars( t' ) \\ [v])
12:32:16 <vixey> (btw ++ means union)
12:32:27 <b_jonas> is this still the reverse elements of a list by threes problem?
12:32:30 <vixey> ah actually that's wrong for haskell
12:32:38 <vixey> freeVars( let v = t in t' ) = (freeVars( t ) ++ freeVars( t' )) \\ [v]
12:32:58 <vixey> :t chunks
12:33:00 <lambdabot> Not in scope: `chunks'
12:33:19 <smg> why do you do t => t'
12:33:24 <smg> i don't understand the renaming
12:33:29 <vixey> @let chunk n list = let ch' [] _ k = k [] : [] ; ch' (y:ys) 0 k = k [] : ch' ys (n-1) (y:) ; ch' (y:ys) (c+1) k = ch' ys c (k . (y:)) in case list of { [] -> [] ; (y:ys) -> ch' ys (n-1) (y:) }
12:33:30 <lambdabot>  Parse error in pattern
12:33:43 <smg> vixey: and what means \\ [v] ?
12:33:46 <vixey> smg: they are two different names
12:33:47 <smg> i also don't understand
12:33:52 <smg> and why?
12:33:53 <vixey> > [1,2,3] \\ [2]
12:33:53 <smg> :|
12:33:54 <lambdabot>  [1,3]
12:34:00 <smg> ahh
12:34:01 <vixey> > ["x","y","z"] \\ ["x"]
12:34:02 <lambdabot>  ["y","z"]
12:34:08 <smg> please give me a page where the algorithm to do that is descrieed
12:34:09 <smg> plz
12:34:19 <Cale> @src (\\)
12:34:19 <lambdabot> (\\) = foldl (flip delete)
12:34:26 <Cale> @src delete
12:34:26 <lambdabot> delete = deleteBy (==)
12:34:30 <Cale> @src deleteBy
12:34:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:34:33 <Cale> ...
12:34:35 <Cale> heh
12:34:47 <vincenz> Cale: ping
12:35:03 <Cale> hi
12:35:12 <tchakkazulu> > [1,1,2] \\ [1]
12:35:13 <Cale> http://haskell.org/onlinereport/list.html
12:35:13 <lambdabot>  [1,2]
12:35:13 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
12:35:16 <vincenz> Cale: add oyrself to that page (:
12:39:33 <tieTYT> how could i write a function that takes "abc" and outputs [[a],[b],[c]]?
12:40:11 <tieTYT> does that just turn every x into (x:[]) : xs    recursively?
12:40:23 <vincenz> > map (take 1) . takeWhile (not . null) . iterate ( drop 1) $ "abc"
12:40:24 <lambdabot>  ["a","b","c"]
12:40:25 <Cale> It turns every x into [x]
12:40:28 <Deewiant> > map return "abc"
12:40:33 <lambdabot>   add an instance declaration for (Show (m Char))
12:40:37 <Cale> > map (\x -> [x]) "abc"
12:40:38 <lambdabot>  ["a","b","c"]
12:40:38 <Deewiant> > map return "abc" :: [[Char]]
12:40:41 <lambdabot>  ["a","b","c"]
12:40:44 <vincenz> > map return "abc" :: [String]
12:40:46 <lambdabot>  ["a","b","c"]
12:40:53 <tieTYT> ah
12:40:53 <tieTYT> ok
12:40:55 <tieTYT> thanks
12:41:01 <Cale> @src deleteBy
12:41:01 <Deewiant> > map (:[]) "abc"
12:41:01 <lambdabot> Source not found. stty: unknown mode: doofus
12:41:02 <lambdabot>  ["a","b","c"]
12:41:03 <Cale> hmm
12:41:04 <vincenz> or use the cookie monster
12:41:06 <tieTYT> i'm wondering if that hint will help me write my own groupBy
12:41:15 <vincenz> Cale: will you (:
12:41:31 <mauke> :t ("[" ++) . (++ "]") . intersperse ',' . (\c -> "[" ++ [c] ++ "]")
12:41:33 <Cale> vincenz: I did, just now
12:41:33 <lambdabot> Char -> [Char]
12:41:44 <vincenz> \o
12:41:47 <vincenz> ./
12:42:02 <mauke> :t ("[" ++) . (++ "]") . concat . intersperse "," . map (\c -> "[" ++ [c] ++ "]")
12:42:03 <vincenz> Cale: greatt, same timezone as byorgey (:
12:42:04 <lambdabot> [Char] -> [Char]
12:42:20 <mauke> :t ("[" ++) . (++ "]") . intercalate "," . map (\c -> "[" ++ [c] ++ "]")
12:42:22 <lambdabot> [Char] -> [Char]
12:42:27 <mauke> > ("[" ++) . (++ "]") . intercalate "," . map (\c -> "[" ++ [c] ++ "]") "abc"
12:42:28 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:43:08 <Cale> hmm
12:43:16 <Cale> @dynamic-reload source
12:43:16 <lambdabot> Unknown command, try @list
12:43:32 <Cale> I guess that's not working anymore..
12:45:05 <Cale> lambdabot: @quit
12:45:21 <Cale> @src deleteBy
12:45:28 <lambdabot> deleteBy eq x []        = []
12:45:44 <lambdabot> Plugin `source' failed with: thread killed
12:45:58 <mauke> @src deleteBy
12:46:04 <lambdabot> deleteBy eq x []        = []
12:46:07 <Cale> heh, poor lambdabot, trying to join so many channels while handling requests from us :)
12:46:09 <b_jonas> fun fun fun
12:46:12 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
12:46:24 <mauke> > ("[" ++) . (++ "]") . intercalate "," . map (\c -> "[" ++ [c] ++ "]") $ "abc"
12:46:32 <lambdabot>  "[[a],[b],[c]]"
12:47:10 <b_jonas> so what's that good for?
12:48:38 <Cale> What's what good for?
12:48:56 <Cale> deleteBy?
12:49:25 <vincenz> b_jonas: it only deletes one
12:49:27 <vincenz> unlike filter
12:49:39 <b_jonas> no, not deleteby
12:49:43 <b_jonas> the thing mauke writes
12:50:00 <smg> mh
12:50:48 <smg> vixey:
12:50:50 <smg> still here?
12:50:56 <newsham> Hmm.. building zlib using win32 ghc-6.8.2 is super hard now (was only merely hard in 6.4), and also I'm not sure why, but ghc-6.8.2 on win32 doesnt seem to want to let me access some win32 calls over FFI anymore (ie. building darcs)
12:51:02 <smg> lets say we have let x in (x*2)
12:51:04 <newsham> are these known issues?
12:51:09 <smg> and we have to evaluate the free variables
12:51:23 <vixey> smg: that is syntactically invalid
12:51:35 <smg> let x = 5 in (x*2)
12:51:54 <vixey> so we want
12:51:57 <vixey> freeVars( let x = 5 in (x*2) )
12:51:59 <smg> NO!
12:52:02 <smg> vixey: query pLS
12:52:07 <newsham> the new 6.8.2 gcc is configured very strangely
12:52:17 <mauke> the answer is [] because there are no undefined variables there
12:52:24 <vixey> = (freeVars(5) `union` freeVars(x*2)) \\ [x]
12:52:37 <vixey> = ([] `union` [x]) \\ [x]
12:52:41 <vixey> = []
12:53:17 <hpaste>  andre pasted "n sublists" at http://hpaste.org/8098
12:53:37 <smg> vixey: can you look at your private message?
12:53:45 <dejones> dons: Another great post on optimization and performance with Haskell.  Thank you.  :)  Stream fusion is some cool stuff!
12:54:38 <smg> vixey: ?
12:56:23 * shapr boings cheerfully
12:56:56 <smg> mauke: sure i need the complete evaluation step
12:56:56 <dmwit> :t unfoldr
12:56:58 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:57:14 <vixey> andre: I'd do something like sublists n k l = [n*k..] >>= \l' -> chunks n . takeOut (l'-n*k) . take l' $ l
12:57:24 <mauke> smg: why?
12:57:38 <smg> vixey: if i don't annoy you, you may help me at the private message? would be awesome
12:57:46 <smg> mauke: to learn it
12:58:20 <vixey> smg: Just define a free vars function and keep rewriting it like I showed you
12:58:22 <dmwit> > let chunk k = unfoldr $ Just . splitAt k; sublists n k = take n . chunk k in sublists 3 2 [1]
12:58:23 <lambdabot>  [[1],[],[]]
12:58:30 <dmwit> > let chunk k = unfoldr $ Just . splitAt k; sublists n k = take n . chunk k in sublists 3 2 [1..4]
12:58:31 <smg> vixey: yeah can we do it step by step once?
12:58:31 <lambdabot>  [[1,2],[3,4],[]]
12:58:37 <smg> vixey: did you get my messages?
12:58:39 <vixey> smg: I already did, please scroll up
12:58:51 <hpaste>  dmwit annotated "n sublists" with "shorter, but maybe slower" at http://hpaste.org/8098#a1
12:58:54 <smg> and if i don't understand one step, may i ask you?
12:59:29 <smg> = (freeVars(5) `union` freeVars(x*2)) \\ [x] <-- what are you doing here?
12:59:33 <smg>  = ([] `union` [x]) \\ [x] <--
12:59:38 <smg> freeVars(5) i understand
12:59:46 <vixey> dmwit: is that t -> Int -> [a] -> [[a]] ?
12:59:46 <smg> but not the step from freeVars(x*2) to [x]
12:59:56 <vixey> um,.. Num t =>
13:00:15 <vixey> smg x*2 = ((*)$x)$2
13:00:18 <dmwit> :t let chunk k = unfoldr $ Just . splitAt k; sublists n k = take n . chunk k in sublists
13:00:20 <lambdabot> forall a. Int -> Int -> [a] -> [[a]]
13:00:32 <dmwit> vixey: Even more restricted than that, I'm afraid.
13:00:39 <vixey> oh it's me that misunderstood the problem then
13:00:59 <vixey> dmwit: I thought it was taking every set of n sublists with length k
13:01:13 <vixey> (from an infinite list, so you need to diagonalize)
13:01:38 <dmwit> > let sublists n k l = sublists' n k l []; sublists' 0 k l s = s; sublists' n k l s = let (e, l') = splitAt k l in sublists' (n-1) k l' (e:s) in sublists 3 2 [1..4]
13:01:40 <lambdabot>  [[],[3,4],[1,2]]
13:01:50 <smg> vixey: what's that $x $2 stuff?
13:01:51 <dmwit> Whoops, looks like I got the reverse of what he wanted.
13:02:02 <Deewiant> > (+1) $ 2
13:02:03 <lambdabot>  3
13:02:05 <Deewiant> > (+1) $2
13:02:07 <lambdabot>  3
13:02:18 <smg> mh
13:02:29 <smg> why is x*2 = ((*)$x)$x ?
13:02:39 <Deewiant> x * 2 = (*) x 2
13:02:46 <Deewiant> = ((*) x) $ 2
13:02:46 <smg> this is do understand
13:02:52 <Deewiant> = ((*) $ x) $ 2
13:02:59 <vixey> > let x = 5 in ((*)$x)$2
13:03:01 <lambdabot>  10
13:03:01 <dmwit> On the other hand, mine produces values lazily, which his doesn't.
13:03:07 <vixey> smg: This is, again, haskell
13:03:07 <smg> but how do we reduce ((*)$x)$2 to that [x] ?
13:03:12 <smg> yeah
13:03:14 <vixey> smg: that's not true
13:03:22 <vixey> freeVars( ((*)$x)$2  )
13:03:27 <smg> i don't understand your steps from freeVars(x*2)) \\ [x] to [x]
13:03:43 <vixey> smg: Just apply the definition of freeVars
13:04:12 <smg> m
13:04:12 <smg> mh
13:04:20 <smg> = (freeVars(5) `union` freeVars(x*2)) \\ [x]
13:04:20 <smg> = ([] `union` [x]) \\ [x]
13:04:24 <smg> can this step be more verbose?
13:04:54 <dmwit> freeVars(5) = []
13:05:19 <dmwit> freeVars(x*2) = freeVars(x) `union` freeVars((*)) `union` freeVars(2)
13:05:31 <dmwit> If you assume the numbers and operators are defined, then...
13:05:37 <dmwit> freeVars(x) = [x]
13:05:42 <dmwit> freeVars((*)) = []
13:05:46 <dmwit> freeVars(2) = []
13:05:59 <dmwit> So freeVars(x*2) = [x].
13:06:22 <dmwit> Good or bad?
13:06:45 <vixey> dmwit: great! A+
13:06:46 <vixey> :P
13:06:51 <dmwit> heh
13:07:14 <dmwit> vixey: But smg's opinion matters more than yours just now. =)
13:07:43 <smg> so [x] is the only free var?
13:08:05 <smg> i Mean FreeVars = { x } ?
13:09:53 <dmwit> Well, freeVars(x*2) = { x }, at least.
13:09:58 <vixey> what's 'FreeVars' and what's '{ _ }'
13:10:25 <vixey> you do have a point we probably should have used sets from the start
13:11:55 <vixey> sorry to repeat myself .. but does anyone know what it means to take the quotient of a Monad wrt. an equivalence relation?
13:13:00 <vixey> I found this http://www.dcs.st-and.ac.uk/~eb/partial.php
13:13:02 <lambdabot> Title: SK Combinator Calculus Interpreter
13:13:10 <smg> so the freevars is x ?
13:13:19 <smg> the free variables are only the variable x ?
13:15:49 <vixey> smg: Do you understand what the bound variables are too?
13:16:00 <dmwit> smg: There are no free variables.
13:16:21 <smg> no i don't understand at all
13:16:55 <vixey> bound variables = all variables in term \\ free variables
13:17:46 <blarz> @users
13:17:46 <lambdabot> Maximum users seen in #haskell: 465, currently: 444 (95.5%), active: 19 (4.3%)
13:18:04 <vixey> has anyone else read Partiality is an Effect?
13:18:18 <opqdonut> no, link?
13:18:24 <vixey> it's quite simple but the maths is really really hard :|
13:18:27 <vixey> I mean it's intuitive
13:18:57 <opqdonut> ah found it
13:19:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8099
13:19:08 <smg> http://hpaste.org/8099
13:19:09 <smg> is that okay?
13:19:17 <smg> maybe someone can look at that paste
13:19:25 <vixey> opqdonut: http://cs.ioc.ee/efftt/altenkirch-slides.pdf & http://cs.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf & http://www.cs.ru.nl/~venanzio/publications/Recursion_Coinductive_LMCS_2005.pdf
13:19:31 <smg> vincenz: preferably you :)
13:21:38 <smg> does this look good vixey?
13:21:48 <vixey> smg: no
13:22:13 <vixey> smg: Start with a pseudo BNF of the syntax you are working with, then define the freeVariables operator -then- use it
13:23:15 <dmwit> :t let x = id x in x
13:23:30 <lambdabot> thread killed
13:23:42 <dmwit> It's bottom.
13:23:46 <smg> mh
13:23:52 <smg> i'm annoyed now.....
13:24:20 <roconnor> dmwit: isn't it forall a. a
13:24:25 <dmwit> roconnor: yes
13:24:31 <dmwit> As I said... it's bottom.
13:24:32 <roconnor> that's not bottom
13:24:36 <dmwit> What?
13:24:48 <dmwit> > let x = id x in x
13:24:49 <smg> vixey: this is completely insane to try that without a proper definition
13:24:50 <roconnor> bottom is a value
13:24:50 <hpaste>  jsnx pasted "what's the difference in the end?" at http://hpaste.org/8100
13:24:54 <roconnor> forall a. a is a type
13:24:56 <smg> i'M not able to figure out a good definition on my own
13:25:02 <dmwit> roconnor: Oh, yeah, I know.
13:25:04 <lambdabot>  thread killed
13:25:06 <sclv> ?ty undefined
13:25:08 <lambdabot> forall a. a
13:25:08 <dmwit> roconnor: My "it" was just too ambiguous.
13:25:18 <dmwit> roconnor: I meant "x" was bottom.
13:25:18 <vixey> smg: <term> ::= <variable> | \<variables> -> <term> | ...
13:25:26 <roconnor> why does lambdabot die when you ask for the type?
13:25:27 <vixey> smg: add $ let if/then/else to that
13:25:37 <dmwit> roconnor: \bot has just been having difficulty recently.
13:25:48 <dmwit> roconnor: She's getting on in years, you know.  72 in bot years
13:25:56 <smg> i hate my teacher
13:26:13 <smg> he has NO good book hint where i can read all about that stuff he is doing
13:26:30 <vixey> smg: forget your teacher, the only point in learning things is for yourself
13:26:30 <smg> 2nd) his skriptum is really bad... no definitions for calculating free/boudn vars..
13:26:35 <smg> and i shoud do that...
13:26:44 <smg> i want really to learn that but this teacher...
13:26:48 <lament> skriptum?
13:26:51 <smg> vixey: i guess i need a book
13:27:03 <vixey> smg: Do you know about BNF?
13:27:09 <smg> script
13:27:13 <smg> vixey: i know
13:27:21 <lament> script?
13:27:23 <vixey> smg: Try to complete the BNF then
13:27:26 <lament> handwriting?
13:27:27 <roconnor> dmwit: I guess that the problem with lambdabot is that it is written in a crappy langauge.
13:27:32 <vixey> lol
13:27:42 <vixey> roconnor: yeah, we should rewrite it in C++
13:27:51 <lament> yes please
13:27:56 <roconnor> vixey: maybe then it would work. :)
13:28:07 <lament> how about C++ with embedded perl
13:28:11 <vixey> roconnor: hm.... maybe I should write a bot in Idris
13:28:15 <smg> lament: yes the material for his teaching
13:28:16 <lament> embedded perl for the main loop, C++ for plugins
13:28:24 <smg> vixey: so i need a proper definition then i will do that
13:28:41 <vixey> smg: defintion of what?
13:28:51 <smg> the algorithm to compute free/bound variables
13:28:56 <lament> smg: heh, i still have no idea what that word means
13:28:56 <smg> i guess with that it won't be a problem
13:29:00 <vixey> smg: I already gave you that
13:29:04 <smg> i know
13:29:10 <vixey> smg: why do you need it again?
13:29:11 <smg> vixey: i will make a short break
13:29:21 <vixey> it will be exactly the same
13:29:23 <jsnx> so, reading the core for this, it looks like case is better than guards if you can get it:
13:29:26 <jsnx> http://hpaste.org/8100
13:29:30 <smg> vixey: yeah i need to refresh my brain
13:30:22 <smg> btw a function argument is a bound var?
13:31:22 <smg> vixey: i guess i undertand now
13:31:28 <smg> i will make a EBNF definition and come along
13:31:43 <smg> thank you a thousand times you haven been "insane!" helpful ;) ty.
13:32:22 <smg> vixey: but nevertheless do you know a good book which could cover that? or a book which covers that list comprehension stuff (e.g. diagonalization) then i am a happy man :)
13:32:57 <TomMD> FYI, i've got a list of my fav reading material, mostly Haskell related, at my blog tommd.wordpress.com
13:33:03 <vixey> smg: TAPL as always
13:33:13 <smg> covers both things??
13:33:31 <vixey> smg: no, it's just a really good book
13:33:36 <smg> mh okay
13:33:51 <smg> vixey: okay i annoy you i know sorry :(
13:33:58 <RayNbow> TaPL... I still have to finish reading that book :p
13:34:01 <smg> vixey: but may you have the two links about that list comprehension?
13:34:09 <smg> i somehow lost ist
13:34:21 <vixey> smg: Not really, I just find it weird you ask for a recommendation for the same book over and over..
13:34:47 <smg> true. not very clever
13:34:55 <smg> i will buy it and then i see :)
13:35:05 <smg> jsnx? :)
13:38:00 <vixey> smg, An alternative approach to calculating free variables:
13:38:00 <vixey> Prelude> :t let x = (\u -> u) x ; f b = (\a -> a c) in \w -> if x then g u else w (f 20)
13:38:01 <vixey> <interactive>:1:37: Not in scope: `c'
13:38:01 <vixey> <interactive>:1:59: Not in scope: `g'
13:38:01 <vixey> <interactive>:1:61: Not in scope: `u'
13:38:03 <vixey> :p
13:38:06 <smg> mh that is sad, TAPL does not cover diagonalization and the free/bound variables thing
13:38:13 <smg> interesting
13:38:23 <smg> vixey: thank you
13:38:31 <smg> so i will get TAPL nevertheless
13:38:45 <smg> okay i now shut up sorry
13:39:12 <vixey> don't be sorry
13:39:34 <dons> fibonacci prime 35 == fib (130021)
13:39:36 <Philippa_> smg: I wouldn't expect TAPL to cover how to spot the free variables in a term, it never needs to
13:39:49 <smg> hehe ok
13:39:59 <smg> Philippa_: so you know another resource for that stuff?
13:40:01 <Philippa_> it only has to define freeness and (in the case of HM) keep track of a couple of odd properties
13:40:04 <dons> %CPU:283  %MEM 0.1  TIME+: 29406:53 FPrimes
13:40:05 <jsnx> Philippa_: do you have any ideas about the abstraction penalty of a total guard relative to a case?
13:40:09 <Philippa_> smg: "free" is just "not bound"
13:40:13 <smg> yeah
13:40:51 <smg> and not bound means? is there an _precise_ definition?
13:40:59 <Philippa_> jsnx: "It depends". But guards'll end up desugaring into something in terms of case anyway
13:41:00 <marko> hi all
13:42:01 <Philippa_> smg: the negation of "bound" :-) The rest depends on the precise language you're working in, but assuming lexical scoping it's just "are we inside a binder that binds that variable?"
13:42:06 <marko> can someone help with ArrowList?
13:42:17 <Philippa_> lambdas and lets are the most classic binders
13:42:29 <Philippa_> (\x.x) <- x is bound
13:42:33 <Philippa_> (\x.y) <- y is free
13:42:42 <Philippa_> (\y.(\x.y)) <- y is bound
13:43:20 <marko> I'm looking for a fold over the elements appearing in what's called "non-deterministic" list
13:43:23 <Philippa_> so you can keep track of which variables are bound in a given context easily, and check whether a variable is free in that context
13:43:36 <vixey> marko: Where is it called that?
13:43:48 <marko> vixey: hxt
13:43:49 <smg> mh k k
13:43:56 <smg> Philippa_: and there is really no  material of that?
13:44:04 <smg> where did you learn that stuff you tell me atm from?
13:44:14 <vixey> smg: Perhaps you should write a text on it
13:44:36 <Philippa_> smg: there's plenty for it. So much that it's hard to pick an example, but TAPL effectively covers it
13:45:13 <Philippa_> really you want a thorough treatment of the lambda calculus
13:45:26 <Philippa_> I wouldn't be surprised if wikipedia's article gives a good enough definition
13:45:29 <marko> vixey: any idea?
13:45:38 <vixey> marko: I don't know what hxt is
13:45:54 <marko> vixey: HaskellXMLToolbox
13:46:31 * jao fails to recognise 'TAPL'
13:46:37 <dmwit> marko: I think somebody was in here asking about this the other day.
13:46:39 <dmwit> one sec
13:46:44 <vixey> Types and Programming Languages
13:46:45 <opqdonut> jao: types and programming languages
13:46:51 <opqdonut> hmh
13:46:57 <jao> ah! thanks!
13:47:02 <opqdonut> borrowed my copy to a mathematician
13:47:04 <opqdonut> hasn't returned it
13:47:26 <dmwit> marko: Oh, it was *you*. =P
13:47:31 <marko> dmwit: I was asking related to hxt recently, but not this specific question IIRC
13:47:48 <dmwit> May 29 14:07:54 <marko> dmwit: I tried using `getChildren >>> ...` but `...` is applied to every ch
13:47:48 <dmwit> ild not the list of children
13:48:00 <dmwit> May 29 14:08:40 <Saizan>        marko: there's something like listA which gives you the list
13:48:03 <vixey> opqdonut: those terrible mathematicians!
13:48:09 <opqdonut> vixey: mhmm
13:48:13 <opqdonut> taking our type theory away
13:48:23 <jsnx> Philippa_: well, in the example I post, the guard desugars into *two* case statements
13:48:26 <jsnx> http://hpaste.org/8100
13:48:28 <dmwit> marko: Does listA work for this, too?
13:48:36 <jsnx> very simple ones
13:48:44 <dmwit> i.e. just use the normal list fold?
13:49:07 <marko> dmwit: ok, have to be more precise: I need something like a fold, but something that takes an arrow
13:49:10 <jsnx> whereas the case desugars into a case with some empty __letrec { } stuff that i have no idea what it's there for
13:50:17 <dmwit> marko: Okay, sorry, I don't know, then.
13:51:01 <marko> dmwit: should have been more precise in the first place
13:51:18 <marko> dmwit: _me_, that is
13:52:00 <Igloo> dons: I don't understand what you're trying to say with your zipper mail
13:53:08 <lilac> why would it be a bad idea to use a list as the monoid in the writer monad? what would be better? (reading http://www.haskell.org/all_about_monads/html/writermonad.html)
13:53:08 <lambdabot> Title: The Writer monad
13:53:29 <smg> Philippa_: kk i guessed it was related to lambda calculus
13:53:33 <smg> especially "simple haskell"?
13:53:36 <smg> am i right?
13:53:43 <smg> but our teacher never told us
13:53:50 <smg> he just sayed calculate free and bound variables
13:53:53 <smg> but did not explain
13:53:55 <smg> really bad imho
13:53:56 <dons> Igloo: that the types are derived, while the API on those types isn't.
13:55:50 <Philippa_> smg: it's defined in a good many languages
13:55:52 <Igloo> dons: OK; although is the Data.Tree.Zipper type really what would be mechanically derived?
13:56:10 <Igloo> Maybe it is for a Forest type
13:56:21 <Philippa_> I could define it for C, for example
13:56:41 <dons> Igloo: it'd be interesting to confirm its actually the result you get if you follow conor's paper on this.
13:57:06 <vixey> My guess is that you couldn't syntactically define it for elisp
13:57:29 <vixey> I think its' a runtime thing there
13:57:30 <Igloo> dons: I don't think Conor's paper talks aobut Forests
13:57:40 <Philippa_> vixey: or dynamically-scoped langs in general
13:57:52 <smg> Philippa_: sure but if you don't know it's really hard to figure out
13:58:00 <smg> Philippa_: i never cared about that free/bound stuff
13:58:02 <marko> Hi dons, can you help with ArrowList?
13:58:04 <vixey> Philippa: oh, I guess that's why it's called dynamic scope actually
13:58:11 <smg> i just go my money for coding applications for customers
13:58:11 <dons> Igloo: no, but it gives the algo
13:58:13 <vixey> Philippa: I'd never realized that before
13:58:19 <smg> and not for analysing free/bound vars :)
13:58:22 <dons> marko: hey, no. but ask in the channel
13:58:44 <marko> dons: I have, no success yet
13:59:56 * shapr luvs Haskell
14:00:28 * shapr hugs haskell
14:00:38 * haskell luvs shapr!
14:00:45 * shapr cheers!
14:00:51 <olsner> @seen haskell
14:00:51 <lambdabot> haskell has changed nick to dons.
14:00:51 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 11s ago.
14:01:09 * shapr grins
14:01:12 <olsner> hmm, that didn't turn out as funny as it could have though
14:01:59 <lament> dons is haskell.
14:02:13 <dons> ?seen haskell
14:02:13 <lambdabot> haskell has changed nick to dons.
14:02:13 <lambdabot> You are in #xmonad, #haskell-soc, #ghc and #haskell. I last heard you speak just now.
14:02:17 <dons> hah
14:02:29 <opqdonut> ?unmtl StateT Error
14:02:30 <lambdabot> err: `StateT Error' is not applied to enough arguments, giving `/\A B. Error -> A (B, Error)'
14:02:36 <opqdonut> ?unmtl StateT (Error e)
14:02:36 <lambdabot> err: `StateT (Error e)' is not applied to enough arguments, giving `/\A B. Error e -> A (B, Error e)'
14:02:43 <lament> ?seen gaspar
14:02:43 <lambdabot> gaspar has changed nick to dmwit.
14:02:43 <lambdabot> dmwit is in #xmonad, #haskell-blah and #haskell. I last heard dmwit speak 12m 26s ago.
14:02:48 <opqdonut> ?unmtl StateT s (Error e)
14:02:48 <lambdabot> err: `StateT s (Error e)' is not applied to enough arguments, giving `/\A. s -> Error e (A, s)'
14:02:54 <opqdonut> ?unmtl StateT s (Error e) a
14:02:55 <lambdabot> s -> Error e (a, s)
14:02:56 <opqdonut> gah
14:05:10 <mm_freak> an unboxed array of Bool is technically a bit-field, isn't it?
14:05:35 <dons> "technically"
14:05:50 <bos> "it"
14:05:50 <dons> and by that, i mean "yes"
14:08:17 <olsner> it is exactly a bit-field ... the question is how the bits in this field are packed into memory
14:08:32 <Heffalump> does it look at the word length of the target architecture?
14:08:36 <dons> yep
14:09:14 <dons>     unsafeWrite (STUArray _ _ _ marr#) (I# i#) e = ST $ \s1# ->
14:09:15 <dons>         case bOOL_INDEX i#              of { j# ->
14:09:15 <dons>         case readWordArray# marr# j# s1# of { (# s2#, old# #) ->
14:09:15 <dons>         case if e then old# `or#` bOOL_BIT i#
14:09:15 <dons>              else old# `and#` bOOL_NOT_BIT i# of { e# ->
14:09:17 <dons>         case writeWordArray# marr# j# e# s2# of { s3# ->
14:09:19 <dons>         (# s3#, () #) }}}}
14:09:22 <dons> is the magics
14:09:55 <dons> its a Word array, with bit scaling.
14:10:51 <Heffalump> have you checked out the machine code you get, OOI?
14:11:14 <byorgey> so you're saying an unboxed array of Bools actually uses exactly one bit per element? that's pretty sweet.
14:11:21 <dons> right.
14:11:35 <dons> Heffalump: yeah, i tried to hand optimise it for uvector, but couldn't beat the default instance
14:11:43 <dons> so uvector does the same thing.
14:11:54 <dons> that's why the nsieve-bits sieve is so effective on the shootout
14:12:03 <dons> its identical to what the C guys do here
14:12:13 <Heffalump> uvector?
14:12:53 <dons> new arrays lib.
14:13:24 <Heffalump> ah. What's it do?
14:13:44 <Heffalump> I see you have the top google hit for it, which is a good start :-)
14:13:48 <dons> stream fusible unlifted arrays. supports list like interface
14:13:59 * Heffalump RTFMs
14:13:59 <dons> you should check out the blog posts
14:14:11 <dons> derived from the DPH arrays lib, without the  parallelism
14:14:27 <bos> i found bulat's statements on the list about MutableByteArray# vs ForeignPtr to be mystifying.
14:14:36 <Heffalump> I generally find Bulat mystifying :-)
14:14:41 <dons> he's mystical
14:14:43 <Heffalump> dons: blog posts on what blog?
14:14:47 <bos> afaik, a sufficiently big MutablyByteArray# will be pinned by the GC.
14:14:54 <Heffalump> I don't remember any on planet.haskell, but I generally skim that quite fast.
14:15:01 <dons> main = print . sumU . mapU (`shiftL` 1) $ zipWithU (*) (enumFromToU 1 (100000000 :: Int)) (replicateU (100000000 :: Int) 42)
14:15:13 <dons> is a nice one. the whole thing fuses down to a register-only loop
14:15:24 <dons> the replicate gets constant folded. all good
14:15:52 <dons> Heffalump: http://www.cse.unsw.edu.au/~dons/blog/2008/06/04#fast-fusion
14:15:55 <lambdabot> Title: Haskell hacking
14:15:56 <bos> high wizardry, now in capsule form for easy swallowing.
14:16:00 <Heffalump> I'm not that impressed by that, that code is horrible.
14:16:33 <dons> Heffalump: purely functional array transformers, in combinator form. what's not to like?
14:16:35 <Heffalump> well, horrible is an exaggeration, but it's not pretty
14:16:56 <bos> what's wrong with it?
14:17:28 <Heffalump> (a) it's artifical and (b) it has lots of Us everywhere :-)
14:17:33 <smg> erm.
14:17:34 <dons> Us.
14:17:36 <smg> how do you like that book:
14:17:48 <smg> "the implementation of functional programming languages"
14:17:49 <smg> ?
14:17:52 <dons> its an entirely artificial test to check zipwth fuses, yes, Heffalump
14:18:19 <Heffalump> well, I'm pleased that it does, I just don't like the source :-)
14:18:44 <dons> its less pretty in C.
14:18:46 <Heffalump> anyway. What's needed before the qsort on http://www.haskell.org/haskellwiki/Introduction can turn into the efficient in-place algorithm?
14:18:49 <lambdabot> Title: Introduction - HaskellWiki
14:19:02 <smg> vixey: that book is good
14:19:09 <smg> vixey: it has free/bound var stuff etc :]
14:19:20 <Heffalump> s = 0; for (i = 0; i < 10000000; i++) s += 42*i; <print s>
14:20:09 <hpaste>  dons pasted "zipping arrays" at http://hpaste.org/8101
14:20:13 <TomMD> dons: did you see bos message on ghc-users?
14:20:20 <dons> TomMD: yep.
14:20:22 <bos> TomMD: yes, he did
14:20:34 <vixey> smg: didn't you understand what we tried to explain?
14:20:43 <TomMD> sorry, I wasn't scrolled down, didn't know you were here, bos.
14:21:14 <TomMD> I can't reproduce this segfault you are talking about
14:21:15 <bos> :)
14:21:18 <TomMD> x86_64 only?
14:21:24 <bos> no, i386 too.
14:21:25 <Heffalump> I guess my criticism is founded on the fact that your arrays are completely artificial.
14:21:30 <dons> Heffalump: the main thing is to see how the abstraction is entirely boiled away -- so its fast. and you get a flexible arrays interface.
14:21:49 <dons> Heffalump: what does that mean? they're not organic? :)
14:21:50 <Heffalump> well, that's nice, but work with real arrays. It's much more convincing.
14:21:53 <bos> TomMD: try running with 3 or 4 RTS capabilities.
14:22:02 <dons> Heffalump: sure. its not released yet. i'm just doing benchmarks.
14:22:20 <Heffalump> Why would you introduce arrays as an abstraction in that context? I just can't see what the use case is.
14:22:22 <dons> i'll write you a mandelbrot or matrix transform or something, as a demo
14:22:33 <bos> dons: do you plan to offer multidimensional indexing?
14:22:43 <Heffalump> why does mandelbrot need an array?
14:22:47 <dons> bos, zips work, but 2-d stuff is harder.
14:22:52 <TomMD> bos: I'm sorry, what do you mean by RTS capabilities?  Profiling and -N2 and ? and ?
14:23:20 <bos> TomMD: the GHC RTS calls a capability the thing you use to run on a core.
14:23:23 <dons> Heffalump: arrays have some uses. manipulating them in haskell is currently pitifully painful. a good, efficient interface is needed. i think one based on fusible combinators is the way to go.
14:23:28 <TomMD> ahh, I see.
14:23:29 <bos> er, my wording is screwy.
14:23:49 <Heffalump> dons: Agree, agree, agree. agree. I just hate your example above, that's all :-)
14:23:51 <TomMD> There is the crash :(
14:24:01 <dons> its ok. that's just out of tests/Fusion/zipwith.hs
14:24:05 <bos> TomMD: it's really easy to provoke.
14:24:09 <dons> it illustrates array zipping, something we can't do currently
14:24:18 <bos> TomMD: anything that calls par more than 3 or 4 times will cause it.
14:24:19 <dons> but since you don't care about that, that's fine.
14:24:24 <smg> vixey: sure it did
14:24:32 <vixey> smg: ok I'm glad
14:24:37 <smg> vixey: but it's good to read something more about
14:24:44 <Heffalump> I agree it's an important micro optimisation, and I can imagine that I'd have been pretty pleased if I was hacking on making it work myself. It just doesn't seem at all impressive from this outsider's perspective :-)
14:24:48 <smg> vixey: i guess i will become more familiar if i study that stuff too
14:24:55 <dons> i think the interesting cases will be, say, reading in an image file with Binary
14:24:59 <Heffalump> yeah
14:24:59 <smg> it's good because it's a free pdf so. :)
14:25:05 <dons> filling a uvector with it. transforming it efficiently
14:25:07 <dons> dumping it out.
14:25:12 <Heffalump> that's the kind of thing I think that making streaming code will be really good for
14:25:23 <bos> doing things like image processing would be interesting.
14:25:41 <Heffalump> hmm. You'll need to start thinking about pipelining to get maximum speed, there.
14:25:42 <dons> numeric stuff too, i think
14:25:51 <bos> but to do a lot of image processing work, you need to perform convolutions.
14:25:59 <Heffalump> That's a real pain inside C compilers. Should be a good win for Haskell semantics.
14:26:14 <bos> and to convolve, you really want a zipper in a functional setting.
14:26:30 <bos> and zippers over 2d arrays are useless.
14:26:32 <bos> so.
14:26:46 <bos> plenty of unsolved problems to address for the enterprising haskell hacker.
14:27:02 <dons> mostly, i just wanted to fix the 3 shootout entries that use Foreign.Ptr Double
14:27:06 * Heffalump is a haskell hacker with too little free time :-(
14:27:08 <bos> heheh.
14:27:36 <bos> Heffalump: don't complain, you work for an investment bank. go buy a small island or something :-)
14:27:36 <Heffalump> though my SQL abstraction is making progress. It turns out that trying to use HOAS all the way through an optimiser isn't very efficient, though.
14:27:49 <Heffalump> bos: perhaps once I've been there a tad longer ;-)
14:28:08 <smg> vixey: haha you are all so cool :) thanks
14:28:49 <dons> Heffalump: can you fix up the financial sector, while you're at it. Us tech companies can't do all the hard economic work ;)
14:29:27 <Heffalump> hmm. I'll get back to you on that one.
14:29:57 <smg> vixey: i now understand what bound means
14:34:23 <smg> vixey: still present?
14:34:37 <smg> let us calculate FreeVars of \x -> (f x y)
14:34:45 <smg> FreeVars(\x -> (f x y))
14:35:06 <smg> = FreeVars(f x y)
14:35:15 <vixey> no
14:35:20 <smg> = FreeVars (f x y) \\ {x}
14:35:21 <vixey> yes
14:35:22 <smg> i mean :)
14:35:28 <smg> okay so we have now
14:35:32 <smg> expr expr expr
14:35:34 <smg> which means
14:35:49 <smg> FreeVars(f) ++ FreeVars(x) ++ FreeVars(y) \\ {x}
14:36:09 <smg> => {f,y}
14:36:15 <vixey> that's right
14:36:25 <smg> is there a more verbose step between?
14:36:31 <smg> did i omit some step?
14:37:06 <vixey> yes but it's fine to omit steps
14:37:19 <smg> can you tell me what i omitted?
14:37:26 <smg> because i am NOT allowed to omit anything
14:39:28 <smg> vixey: if you could, you would be the man :]
14:50:46 <lilac> in ghc core, what's the difference between Charzh and Czh?
14:52:31 <sjanssen> @src Char
14:52:32 <lambdabot> data Char = C# Char#
14:53:04 <lilac> ah, makes sense. ta!
14:53:08 <sjanssen> lilac: Charzh is a type (an unboxed character), and Czh is a constructor (takes a Char# and makes a Char)
14:57:08 <lilac> this page: http://www.haskell.org/all_about_monads/html/writermonad.html says it might be a bad idea to use a list as the monoid in the writer monad. why? what would be better?
14:57:08 <lambdabot> Title: The Writer monad
14:57:19 <bos> has the growth in the population of #haskell stalled?
14:57:32 <sjanssen> @users
14:57:33 <Heffalump> lilac: (++) isn't very efficient
14:57:33 <lambdabot> Maximum users seen in #haskell: 465, currently: 433 (93.1%), active: 13 (3.0%)
14:57:42 <byorgey> lilac: appending elements one-by-one to the end of a list has quadratic runtime
14:57:44 <Heffalump> it traverses the entire left-hand list
14:57:52 <bos> that seems about the same size as it's been for the past few months.
14:58:11 <Heffalump> use functions from lists to lists instead, and apply the function to [] when you do runWriter
14:58:12 <sjanssen> but doesn't MonadWriter use the best associativity?
14:58:24 <ddarius> bos: Until this Autumn probably.
14:58:25 <byorgey> lilac: see the DList package
14:58:40 <Heffalump> sjanssen: well, it would if you had a big do-block, because that associates to the right too
14:58:46 <Heffalump> but with nested do-blocks etc, it can't
14:59:05 <sjanssen> true
14:59:09 <bos> according to dons's irc stats, we've leveled off.
14:59:13 <lilac> hmm
14:59:14 <Heffalump> anyway, it only matters if your lists will get reasonably large
14:59:18 <Heffalump> I do it all the time for smallish lists.
14:59:27 <Heffalump> <100 elements I wouldn't worry at all.
14:59:51 <bos> then again, we're 3x bigger than #erlang
14:59:56 <sjanssen> perhaps WriterT could be rewritten to use CPS?
15:00:07 <Heffalump> that seems like overkill
15:00:12 <lilac> ok, so if the list i produce is small, it's OK?
15:00:14 <Heffalump> you could just keep an ADT and reassociate in runWriter, if it mattered
15:00:24 <Heffalump> lilac: yes
15:00:26 <sjanssen> it just makes the DList trick more general
15:00:33 <lilac> excellent, thanks.
15:00:47 <sjanssen> probably you'd want to provide both a direct and CPSed versions available
15:01:25 <sjanssen> bleh
15:05:49 <eu-prleu-peupeu> hello
15:06:03 <eu-prleu-peupeu> what is the best way to represent a 9x9 grid of int's ?
15:06:15 <Socrates`> List of lists?
15:06:17 <dmwit> [[Int]] or Array (Int, Int) Int
15:06:20 <eu-prleu-peupeu> im thinking about using list of lists
15:06:21 <ddarius> It depends on what you are doing.
15:06:37 <eu-prleu-peupeu> im doing a sudoku solver to learn haskell
15:06:57 <dmwit> [[Int]] should be good for that
15:07:02 <dmwit> Especially with transpose.
15:07:16 <dmwit> But you might even want to consider some completely different data structure, depending...
15:07:57 <ddarius> Or just abstract the data structure so you don't need to worry about such issues.
15:09:10 <eu-prleu-peupeu> abstract ?
15:10:50 <ddarius> Use an abstract data type with the operations you think you need and implement it however.  Worry about getting a better implementation later once you actually know which operations you need to be fast.
15:11:10 <ddarius> (and have a correct implementation of the algorithm)
15:12:04 <Socrates`> If you want a good example of a sudoku solver (especially from a beginners points of view), it might be worth taking a look at the solver written by Bird
15:12:10 <Socrates`> Providing I can find it again
15:12:25 <eu-prleu-peupeu> let it be
15:12:38 <vixey> I've seen two good sudoku solvers actually
15:12:47 <Socrates`> eu-prleu-peupeu: http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
15:12:50 <eu-prleu-peupeu> i have to stumble into some sticks and stones, to find the sharp edges of the haskell learning process
15:13:01 <ddarius> The interesting thing about the Bird example isn't the end result, it's the process.
15:13:14 <Socrates`> Precisely ddarius
15:13:45 <vixey> http://www.chargueraud.org/arthur/misc/sudoku/index.php & http://www.cs.kuleuven.be/~dtai/projects/CHR/examples/sudoku_sharir.pl
15:13:46 <lambdabot> Title: Sudoku solver in 13 lines of Caml
15:14:45 <roconnor> @hoogle tranverse
15:14:45 <lambdabot> No matches found
15:14:47 <ddarius> @google sudoku in one sql statement
15:14:49 <roconnor> @hoogle traverse
15:14:50 <lambdabot> http://technology.amis.nl/blog/?p=2066
15:14:50 <lambdabot> Title: AMIS Technology blog » Blog Archive » Solving a Sudoku with 1 SQL-statement: the ...
15:14:50 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:14:50 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:15:09 <roconnor> @hoogle sequence
15:15:09 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
15:15:09 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
15:15:09 <lambdabot> Data.Traversable.sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
15:16:10 <roconnor> I recall Conor telling me about his Sudoku solver.  He defined a Sudoku grid as Triple (Triple (Triple (Triple a)))
15:16:30 <roconnor> then he turned Triple into a Traversable functor
15:16:52 <roconnor> and used sequence to create all the approriate sudoku symetries
15:17:18 <roconnor> and wrote one verifier
15:17:34 <roconnor> and use the symetries to veify all the three different constraints.
15:17:43 * Botje can't help but remember the chicken chicken chicken presentation
15:17:43 <roconnor> or something like that.
15:18:12 <vixey> that's how I looked at sudoku at first but I got annoyed when I realized it's not actually a 4D cube
15:18:16 <roconnor> he may have use an intermediate Square a = Triple (Triple a)
15:18:44 <EvilTerran> roconnor, interesting. that's how i was thinking of solving it
15:18:46 <eu-prleu-peupeu> that is too much l33t for me
15:18:48 <roconnor> vixey: it is, it just doesn't use all the symetries of the 4D cube
15:19:19 <EvilTerran> but then i got to thinking, there's symmetries row:column, column:box, and row:column... "what about <other>:digit?"
15:19:52 * vixey wants to see Conors code ..
15:20:04 <ddarius> Check his blog
15:20:37 <EvilTerran> and then it basically reduced down to a matter of constraint-solving a matrix of booleans, AFAICT
15:20:40 <vixey> where ?
15:20:41 <monochrom> <3 haskell
15:20:52 <roconnor> vixey: he was telling me at dinner, so I don't know if his code was published or not.
15:22:36 <roconnor> EvilTerran: SAT!
15:23:26 <stephano> hello.
15:23:48 <Socrates`> http://www.haskell.org/haskellwiki/Liyang/sudoku.hs That appears to be riddled with Triple and functors and such.
15:23:49 <lambdabot> Title: Liyang/sudoku.hs - HaskellWiki
15:23:58 <lament> lying sudoku :)
15:24:00 <stephano> is it possible to do that with a foldr or foldl: map (\x -> (x > 50)) [1,50,10,51]
15:24:01 <stephano> ?
15:24:04 <monochrom> Triple = Monad?
15:24:11 <vixey> stephano: Do what?
15:24:31 <eu-prleu-peupeu> you guys are nuts!
15:24:32 <stephano> the map expression, you see it?
15:24:41 <stephano>  map (\x -> (x > 50)) [1,50,10,51]
15:24:46 <stephano> with foldr? is this also possible?
15:24:48 <vixey> stephano: oh right yes
15:24:50 <ddarius> roconnor: I remember something like you were describing
15:25:00 <eu-prleu-peupeu> i hope coding in haskell makes me start thinking as you do ...
15:25:09 <vixey> > foldr f z [a,b,c,u,v,w]
15:25:11 <lambdabot>  f a (f b (f c (f u (f v (f w z)))))
15:25:15 <stephano> i tried but foldr (\x y -> (x >50) ++ (y > 50)) True [1,50,51,10] won't work
15:25:28 <vixey> stephano: You can at look at foldr replacing the (:) and [] of a list
15:25:42 <stephano> yeah
15:26:04 <vixey> stephano: and it's probably useful to be aware that foldr (\x ys -> x : ys) [] l = l
15:26:16 <stephano> mh
15:26:17 <roconnor> monochrom: (a,a,a) is a monad.
15:26:30 <stephano> i don't get it into the expression damn
15:26:38 <vixey> stephano: what?
15:26:44 <stephano>  map (\x -> (x > 50)) [1,50,10,51]
15:26:48 <stephano> into a foldr expression
15:27:02 <vixey> stephano:do you know that [1,50,10,51] = 1 : (50 : (10 : (51 : [])))
15:27:03 <monochrom> map f = foldr ((:) . f) []
15:27:06 <Socrates`> Can lambdabot show class instance sources?
15:27:10 <stephano> ah
15:27:12 <Socrates`> @src Monad Maybe
15:27:12 <lambdabot> Source not found. You untyped fool!
15:27:14 <Socrates`> :(
15:27:15 <vixey> @src Monad
15:27:15 <lambdabot> class  Monad m  where
15:27:15 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:27:15 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:27:15 <lambdabot>     return      :: a -> m a
15:27:15 <lambdabot>     fail        :: String -> m a
15:27:16 <monochrom> @pl \x ys -> f x : ys
15:27:17 <lambdabot> (:) . f
15:27:18 <stephano> monochrom: nice
15:27:32 <dmwit> ?index mappend
15:27:32 <Socrates`> vixey: But for a particular instance
15:27:32 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
15:27:44 <monochrom> Inspired by Brahms music.
15:27:51 <vixey> @src >>= Maybe
15:27:51 <lambdabot> Source not found. I feel much better now.
15:27:55 <vixey> @src (>>=) Maybe
15:27:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:27:59 <vixey> @src Maybe (>>=)
15:27:59 <lambdabot> (Just x) >>= k      = k x
15:27:59 <lambdabot> Nothing  >>= _      = Nothing
15:28:06 <Socrates`> Super. Thanks
15:28:10 <roconnor> Socrates`: that looks consistent with what Conor was describing, but I didn't think it would get that complicated.
15:28:21 <stephano> foldr (||) True $ foldr((:) . (>50)) [] [1,2,3,51]
15:28:26 <stephano> can i get this in one?
15:28:35 <vixey> stephano: yes
15:28:38 <Socrates`> roconnor: Aye, it's description afterall: "Liyang wrote some applicative functor porn utilising STM."
15:28:45 <monochrom> w00t, foldr fusion!
15:28:56 <stephano> foldr((||) . (>50)) True [1,2,3,51]
15:28:59 <stephano> i have this
15:29:03 <vixey> > foldr((||) . (>50)) True [1,2,3,51]
15:29:04 <lambdabot>  True
15:29:07 <stephano> does this look good? yes [ ] no [ ] ?
15:29:10 <stephano> vixey: :))
15:29:33 <dmwit> stephano: No, it looks bad to me.
15:29:35 <vixey> how do you prove foldr fusion?
15:29:37 <dmwit> :t all
15:29:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:29:40 <dmwit> :t any
15:29:41 <monochrom> I want a box for "excellent [ ]"
15:29:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:29:46 <stephano> dmwit: why?
15:29:52 <dmwit> stephano: It's always True.
15:30:07 <dmwit> stephano: And it doesn't use one of the built-in "any" or "all" functions. ;-)
15:30:40 <dmwit> > foldr((||) . (>50)) True [1,2,3,4]
15:30:41 <stephano> ahh
15:30:41 <lambdabot>  True
15:30:59 <stephano> it needs to be False
15:31:09 <dmwit> > any (>50) [1..4]
15:31:10 <lambdabot>  False
15:31:15 <dmwit> > any (>50) [1,2,3,51]
15:31:15 <stephano> foldr((||) . (>50)) False [1,2,3,51]
15:31:16 <lambdabot>  True
15:31:23 <monochrom> vixey: A concrete proof uses induction. An abstract proof uses initial algebra, a bit of category theory.
15:31:31 <dmwit> stephano: That would work.  But "any" already does that for you!
15:31:37 <stephano> k
15:31:42 <stephano> good idea
15:31:55 <vixey> monochrom: Do you knock down two birds (inductive and coinductive) with one stone using category theory?
15:32:10 <vixey> I know there is the co-.. thing
15:32:14 <monochrom> Perhaps.
15:32:33 <stephano> good channel!
15:32:33 <monochrom> It can be done but you can also refrain from doing it.
15:32:59 <stephano> cu later folks
15:34:49 <ddarius> vixey: What I remember didn't look anything like Liyang's code.
15:35:26 <vixey> Liyang's code is scary
15:42:09 <lilac> if i have a [ThreadId], is there a way i can wait for those threads to finish?
15:42:41 <ddarius> No.
15:42:42 <roconnor> @hoogle ThreadId -> IO ()
15:42:43 <lambdabot> GHC.Conc.killThread :: ThreadId -> IO ()
15:42:43 <lambdabot> Control.Concurrent.killThread :: ThreadId -> IO ()
15:42:43 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
15:42:57 <tchakkazulu> lilac: There's a trick in the libraries manual to do that with with MVars.
15:43:35 <ddarius> :t forkIO
15:43:37 <lambdabot> Not in scope: `forkIO'
15:43:45 <lilac> :t Control.Concurrent.forkIO
15:43:45 <ddarius> :t Control.Concurrent.forkIO
15:43:47 <lambdabot> IO () -> IO GHC.Conc.ThreadId
15:43:48 <lambdabot> IO () -> IO GHC.Conc.ThreadId
15:45:36 <ddarius> joinableFork f = do { mvar <- newEmptyMVar; threadID <- forkIO (f >> putMVar mvar ()); return (mvar,threadID); }; joinMany = mapM_ takeMVar
15:55:32 <lilac> @karma+ ddarius
15:55:32 <lambdabot> ddarius's karma raised to 9.
15:56:31 <wiredless> hey
15:56:34 <Cale> hello
15:57:19 <wiredless> somebody from another chat room recommend haskell to me instead of java
15:58:02 <dmwit> Hi!
15:58:04 <dobblego> hello wiredless :)
15:58:08 <dmwit> ?where learn
15:58:09 <lambdabot> I know nothing about learn.
15:58:13 <dmwit> ?where learning
15:58:13 <lambdabot> I know nothing about learning.
15:58:14 <wiredless> there he is
15:58:15 <dmwit> hum
15:58:18 <dmwit> ?where tutorial
15:58:18 <lambdabot> http://www.haskell.org/tutorial/
15:58:22 <dmwit> Yikes!
15:58:40 <dobblego> wiredless is currently reading http://en.wikibooks.org/wiki/Haskell/Getting_set_up and hopefully will be getting started soon
15:58:54 <wiredless> yeap
15:59:00 <dmwit> Oh, cool.
15:59:03 <dmwit> http://haskell.org/haskellwiki/Learning_Haskell
15:59:04 <lambdabot> Title: Learning Haskell - HaskellWiki
16:00:02 <dobblego> wiredless, just make sure you ask if you get stuck on something :)
16:00:30 <wiredless> from what i have seen so far it seem very different from java, i will :O), just need to work out how to add this server and room to my irc list
16:00:47 <dobblego> wiredless, yes it is very different from Java, thank goodness :)
16:03:08 <wiredless> ok i will admit this, it is diffcult to go against something i have been taught for a year, i will have to continue java while at uni but if i can learn this in my own time great. but what type of jobs, carreer prospects are there with this language?
16:04:06 <Cale> wiredless: Well, apart from the fact that you should learn it just to give you a better perspective on programming in any language, there are some companies that have started to use Haskell already.
16:04:07 <dobblego> wiredless, learning this language will make you a better Java programmer than using Java will; so even if you only ever use Java, your time is best spent learning advanced programming techniques; the emphasis on programming languages by the industry is just a clever marketing trick
16:04:37 <dobblego> there is also the prospect of using Haskell in your work - which I do and others here do too
16:04:53 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
16:04:54 <lambdabot> Title: Haskell in industry - HaskellWiki
16:05:26 <Cale> A lot of financial applications and high-assurance stuff.
16:05:35 <wiredless> ok they are very vaild opinions thank you
16:06:32 <proq> wiredless: you don't have much of a career prospect if you only know one language
16:06:34 <Cale> Also, Haskell is in a good position to become much more important along with multicore. Intel is talking about 80-core processors in the next few years.
16:07:24 <Cale> Programming without side effects is important if one wants to make use of that much parallelism.
16:08:23 <wiredless> ok ok, i didnt just want to stick with the one language that i am been taught at uni, it seems every one has their views on what is a good language, can be very confussing for a newcomer to the programmming world
16:08:33 <Cale> And various features that the GHC people are working on are directed at really competing well in that area. Specifically the data parallelism which will hopefully make an appearance in GHC 6.10.
16:08:49 <roconnor> nah, they'll just take all the structures that we have worked hard to develop for programming without side effects, and use them.
16:09:19 <Cale> roconnor: Their programming languages will have to change, I think.
16:09:31 <Cale> wiredless: Really, you should learn several.
16:10:00 <wiredless> Cale: i do agree greatly with your statement
16:10:01 <monochrom> You should learn a new language every month.
16:10:13 <roconnor> monochrom: you aren't serious?
16:10:22 <monochrom> They should cause your brain to explode every day. :)
16:10:22 <Cale> That's a little fast.
16:10:27 <proq> monochrom: if only I had that much time!
16:10:39 <wiredless> ok i think my head nearly exploded when you said that lol
16:11:09 <vixey> I think we run out of interesting languages to learn pretty quickly
16:11:12 <Cale> If a programming language can be learned in a month, it may not be different enough from what you already know...
16:11:44 <Cale> But then, you might still pick up some new techniques.
16:11:53 <proq> vixey: yeah. once I get through erlang, lisaac, dylan and eiffel I won't know what to try next
16:11:58 <roconnor> maybe learn a new language every year.
16:12:00 <wiredless> i have only been programming less then a year i started at the beginning of october last year, i do believe i have a high ability in programming as they are my highest marks not 100% but i have improved from 70% to 80% this semester
16:12:03 <roconnor> ... maybe
16:13:00 <jre2> how are we defining "knowing" a language?
16:13:11 <vixey> Implement a new language every 2 months :)
16:14:01 <monochrom> If you have already understood lots of languages, understanding the next one is much faster, not just because you know more. Even if it's completely strange, you have developed enough brain muscle to deal with it.
16:14:09 <Cale> jre2: I think we all might have different opinions on what a 'new' language means.
16:14:40 <monochrom> I.e., if you have seen enough, you're ready to make another generalization leap.
16:14:57 <jre2> Cale: that too ;)
16:15:25 <wiredless> i dont believe i am that far yet. so maybe i have not been corupted yet lol
16:15:28 <wiredless> ;O)
16:15:29 <mar77a> Cale: link to cale wiki or whatever was that site with the nice fold images
16:15:37 <vixey> I tend to focus on one language while writing an actual program in another
16:15:42 <bd_> wiredless: I prefer 'upgraded' ;)
16:16:19 <wiredless> lol
16:16:36 <augustss> @src interact
16:16:36 <lambdabot> interact f = do s <- getContents; putStr (f s)
16:16:48 <monochrom> "cale fold images" into google does wonder :)
16:16:58 <monochrom> Be sure to include "fold" there!
16:17:18 <mar77a> all i see is cale and some hot mexican doing a weird barrel roll position
16:17:26 <mar77a> possibly called "the fold"?
16:18:13 <dobblego> does someone have to have the unicode character for composition handy?
16:19:31 <mattam> âˆ˜
16:19:47 <dobblego> cheers
16:20:08 <wiredless> hmm im reading that tutorial "not another tutorial". i seem to get the structure somewhat, but they keywords. is they a tutorial that explans these and their uses? sorry about this
16:21:08 <monochrom> âŠ› can be called Circ du Soleil  (joke)
16:22:21 <hpaste>  jre2 pasted "hc-build failure" at http://hpaste.org/8106
16:23:04 <jre2> any chance someone knows why I might be having that issue with libreadline when compiling an hc-build?
16:23:24 <jre2> I'm assuming it has something to do with readline,ncurses, or some terminal issue, but I haven't had any luck
16:23:43 <jre2> terminal library*, that is
16:29:07 <monochrom> perhaps mismatched versions of libreadline.
16:29:10 <dmwit> :t \f g -> liftM2 (liftM2 (++)) f g
16:29:12 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m, Monoid a1) => m1 (m a1) -> m1 (m a1) -> m1 (m a1)
16:30:23 <monochrom> Oh, does libreadline use ncurses?
16:31:15 <monochrom> Yes indeed. You probably miss ncurses.
16:31:29 <mar77a> when you go on holidays
16:31:32 <mar77a> and forget to take it with you
16:32:36 <jre2> do you know what the correct way to fix that is for an hc-build?
16:34:14 <jre2> that is, do I need to change configopts in the distrib/hc-build file, or can I just modify CFLAGS?
16:51:07 <vixey> "Semantics is what we have in our heads, as soon as we write it down it's not semantics anymore"
16:51:40 <jre2> what's that from?
16:52:40 <Pseudonym> Because it's wrong.
16:52:50 <Pseudonym> We need to hunt this author down and teach them a lesson.
16:53:38 <Pseudonym> This author doesn't understand the difference between a sentence and an utterance.
16:55:50 <jre2> http://fsl.cs.uiuc.edu/index.php/K:_a_Rewrite-based_Framework_for_Modular_Language_Design%2C_Semantics%2C_Analysis_and_Implementation
16:55:52 <lambdabot> Title: Technical Reports on K - FSL, http://tinyurl.com/6r73ts
16:55:56 <dmwit> ?hoogle ([a], [b]) -> [(a, b)]
16:55:57 <lambdabot> No matches, try a more general search
16:56:12 <dmwit> ?pl \(as, bs) -> liftM2 (,) as bs
16:56:12 <lambdabot> uncurry (liftM2 (,))
16:56:23 <jre2> K being a framework for defining executable semantics for languages
16:56:26 <davidL> Why is it that linking Haskell apps takes up so much memory? I can't link the sample HAppS app without using all the swap on my 256slice.
16:56:39 <Pseudonym> Allow me to demonstrate why semantics are still present in an utterance.
16:56:54 <Pseudonym> Consider the sentence: "Yes, it's been raining quite heavily lately."
16:57:03 <Pseudonym> Anyone want to guess what it means?
16:57:11 <dmwit> ?pl \x -> f . (n1 x *** n2 x)
16:57:11 <lambdabot> (f .) . liftM2 (***) n1 n2
16:58:27 <djsiegel> Is there any f :: String -> IO String that runs a command and returns its output (e.g. readSystem "ls -a" >>= putStrLn)
16:58:51 <Pseudonym> ?hoogle String -> IO String
16:58:52 <lambdabot> System.Environment.getEnv :: String -> IO String
16:58:54 <dmwit> ?hoogle runInteractive
16:58:54 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
16:58:54 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
16:58:54 <jre2> like exec?
16:59:00 <mauke> djsiegel: no
16:59:10 <dmwit> No, you have to write it yourself. =/
16:59:23 <Pseudonym> But if you do write it, please submit it to hackage.
16:59:26 <djsiegel> ok, but I should use ï»¿runInteractiveCommand?
16:59:35 <mauke> unlikely
17:00:13 <jre2> certainly good to look at
17:00:18 <djsiegel> ok, thanks
17:00:26 <Pseudonym> jre2: I can't find the phrase "in our heads" anywhere on that page.  Which document is it in?
17:00:29 * geezusfreeek is playing with markov chains and logs from #haskell
17:00:56 <jre2> oh, I meant that as a counter example to his point
17:01:14 <Pseudonym> Ah.
17:01:36 <jre2> it's a research project at my school
17:01:58 <Pseudonym> Anyway, the sentence "Yes, it's been raining quite heavily lately" means something completely different to the obvious when you hear it in context.
17:02:13 <Pseudonym> Bob, to Alice on the phone: "Eve is a real idiot, isn't she."
17:02:24 <Pseudonym> Alice, in reply: "Yes, it's been raining quite heavily lately."
17:02:31 <Pseudonym> So the sentence actually means "Eve is in the room with me".
17:02:39 <TSC> djsiegel: Have a look at HSH; it can do things like that:  http://hackage.haskell.org/packages/archive/HSH/1.2.5/doc/html/HSH-Command.html
17:02:40 <lambdabot> http://tinyurl.com/5gy4xa
17:02:51 <Pseudonym> It's a standard example, but always a good one.
17:03:20 <dmwit> Pseudonym: cute
17:03:33 <znutar> that's pragmatics, not semantics
17:04:17 <Pseudonym> znutar: Arguably.  It still illustrates the point that meaning can't be separated from context.
17:07:43 <jre2> either way, with K I can write down the semantics of a language and thus have it 'out of my head' (and even become an interpreter for the language at that point) whilst it still remains the semantics for the language
17:07:48 <monochrom> I also think that semantics is in the head. Bite me.
17:09:07 <Pseudonym> monochrom: Did you mean for someone to literally bite you?
17:09:12 <Pseudonym> Just trying to understand your meaning here.
17:09:28 <Pseudonym> And in what sense do you mean "semantics"?
17:09:37 * Pseudonym stops now
17:10:43 <monochrom> Someone has to make the decision what the syntax "bite me" stands for. Thus the semantics is inside that someone.
17:10:51 <djsiegel> Pseudonym, ï»¿dmwit: http://pastebin.com/m216111c9
17:11:01 <znutar> semantics is distinguished from meaning in that semantics is the portion of of the structual basis of meaning that remains when removed from context, though.  In the classical semiotic sense
17:11:50 <dmwit> djsiegel: That suits, though you're never closing the associated handles.
17:11:53 <monochrom> Some computer has to make the decision of what to do with your program written in K. Without that computer your K program is dead. Thus the semantics is in the computer; your code is syntax.
17:11:58 <dmwit> djsiegel: For small programs, that shouldn't be a problem.
17:12:15 <djsiegel> dmwit, good point -- I'm just doing a "shell script"
17:13:12 <Pseudonym> znutar: OK, you have a point, in the sense that pragmatics deals with figurative meanings.  But I disagree that semantics only studies meanings when removed from context.
17:13:23 <tchakkazulu> Discussing the semantics of "semantics". Welcome in #haskell.
17:13:37 <tchakkazulu> >_>
17:13:44 <Pseudonym> So "bite me" in its figurative use is a pragmatic distinction.
17:13:48 <monochrom> It's just semantics.
17:13:48 <mar77a> when learning haskell, didn't any of you had that feeling that you wanted to KNOW HASKELL but had no clue what to do
17:13:55 <mar77a> cause that's exactly how i'm feeling right now
17:14:04 <Cale> djsiegel: If you want something more sophisticated along those lines, you might check out HSH on hackage.
17:14:06 <dobblego> mar77a, just about everyone gets that
17:14:20 <monochrom> I did not have that feeling, mar77a.
17:14:24 <djsiegel> Cale, I looked at that stuff, although I want something as simple as possible and self contained.
17:14:25 <Pseudonym> I did once.
17:14:34 <Pseudonym> And I can tell you exactly how I fixed it, too.
17:14:40 <monochrom> My trick is I did not hold any expectation.
17:14:49 <dmwit> Hey, are functions infixl by default?
17:14:53 <Pseudonym> http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm <- I read this book.
17:14:55 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/yempzk
17:15:03 <Pseudonym> Once I read that, I _understood_.
17:15:10 <Pseudonym> This may not work for everyone, of course.
17:15:21 <mar77a> is that for me, Pseudonym ?
17:15:36 <dmwit> Never mind, I just tried it and yes, they are.
17:15:37 <Pseudonym> mar77a: It's about me, but it's in the context of the discussion that you started.
17:15:42 <Pseudonym> :-)
17:16:00 <monochrom> Yes, one way to learn lazy evaluation is by being extremely imperative, not just joe-programmer imperative.
17:18:06 <mar77a> that's one long book, Pseudonym :<
17:18:19 <Pseudonym> It helpd that the example code was in Miranda, and that's the language I was learning at the time.
17:18:21 <jre2> I think writing languages with different evaluation strategies and paradigms helped the most
17:18:35 <monochrom> Test your imperativeness here!  Test 1: Given 10 lines of Java code, you almost immediately envision what it translates to in assembly.
17:18:59 <monochrom> Test 2: Given 10 lines of Scheme code with call/cc, you almost immediately envision what it translates to in assembly.
17:19:02 <Pseudonym> monochrom: Oh, man, that's hilarious.
17:19:15 <monochrom> Test 3: Given 10 lines of Prolog code, you almost immediately envision what it translates to in assembly.
17:19:19 <Pseudonym> I know the quality of most Java code generators, so yeah, I have a pretty good idea what it'd translate to.
17:19:26 <monochrom> Heh.
17:19:35 <roconnor> ugh
17:19:39 <monochrom> Anyway, if you even pass test 3, nothing will stop you. :)
17:19:41 <jre2> monochrom: the optimal assembly equivlent, or what they actually generate?
17:19:43 <roconnor> people are confusing deriviative and zippers
17:19:49 <roconnor> not the same thing
17:19:59 <monochrom> doesn't matter whether optimal or naive.
17:20:05 <Pseudonym> roconnor: But it's a great piece of intuition.
17:20:08 <roconnor> zippers store things in reverse order from the derivative.
17:20:11 <Pseudonym> Don't you agree?
17:20:27 <roconnor> Pseudonym: Zippers have a formal definition
17:20:41 <jre2> er, I meant, what the java vm would run, or just a solution to the same problem?
17:20:47 <roconnor> Conor gives one in his Clowns paper, rather than in his Derivatives paper.
17:21:30 <roconnor> ah apfelmus has posted a claification
17:22:50 <monochrom> Actually naive is better, so you don't optimize heap accesses away (for example), so you are aware of heap operations and GC.
17:24:55 <monochrom> Translating to JVM's level is sufficient.
17:26:43 <vixey> @remember <tchakkazulu> Discussing the semantics of "semantics". Welcome in #haskell.
17:26:43 <lambdabot> I will never forget.
17:26:54 <vixey> @quote
17:26:54 <lambdabot> swiert says: Of course! Who can live without covariant homfunctors?
17:27:08 <monochrom> You will be delighted to know that those < > hurt.
17:27:11 <monochrom> example
17:27:16 <monochrom> @quote tchakkazulu
17:27:17 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
17:27:22 <monochrom> @quote <tchakkazulu>
17:27:22 <lambdabot> <tchakkazulu> says: Discussing the semantics of "semantics". Welcome in #haskell.
17:27:22 <vixey> oh :(
17:27:27 <monochrom> See, that sucks.
17:27:37 <vixey> I'm blaming lambdabot and not myself though
17:27:52 <dmwit> ?forget <tchakkazulu> Discussing the semantics of "semantics". Welcome in #haskell.
17:27:52 <lambdabot> Done.
17:27:54 <monochrom> That's just semantics.
17:28:03 <vixey> hehe
17:28:04 <dmwit> ?remember tchakkazulu Discussing the semantics of "semantics". Welcome in #haskell.
17:28:04 <lambdabot> Done.
17:28:11 <bd_> < lambdabot> I will never forget. <-- lies :(
17:28:20 <dmwit> yeah =/
17:28:40 <vixey> jre2: On the Algebraic Definition of Programming Languages
17:29:06 <mauke> preflex never forgets :-)
17:29:20 <mauke> preflex: remember tchakkazulu Discussing the semantics of "semantics". Welcome in #haskell.
17:29:41 <vixey> preflex: calc 99999999999+1
17:29:41 <preflex>  100000000000
17:29:45 <lambdabot> preflex: forget tchakkazulu Discussing the semantics of "semantics". Welcome in #haskell.
17:29:56 <mauke> that's cheating :(
17:30:03 <lambdabot> can i has teh powr?
17:30:11 <mauke> good question
17:30:28 <mauke> preflex: quote tchakkazulu
17:30:28 <preflex>  <tchakkazulu> Discussing the semantics of "semantics". Welcome in #haskell.
17:30:32 <monochrom> bot jealousy drama
17:30:41 <mauke> hah!
17:30:46 <lambdabot> It's not like preflex is sentient.
17:30:47 <dmwit> preflex: list
17:30:47 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma]; Nickometer: [nickometer]; Seen: [seen]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]
17:31:03 <dmwit> preflex *has* no forget
17:31:05 <vixey> preflex: nickometer
17:31:05 <preflex>   is 0% lame
17:31:11 <lambdabot> preflex: nickometer lambdabot
17:31:11 <preflex>  lambdabot is 0% lame
17:31:17 <lambdabot> Woo!
17:31:17 <monochrom> preflex: sickometer
17:31:23 <dmwit> preflex: nickometer [234]
17:31:23 <preflex>  [234] is 34% lame
17:31:25 <mauke> dmwit: it does
17:31:31 <mauke> it's just a privileged command
17:31:36 <vixey> preflex: nickometer 100
17:31:36 <preflex>  100 is 56% lame
17:31:47 <dmwit> preflex: nickometer 56
17:31:48 <preflex>  56 is 19% lame
17:31:49 <vixey> preflex: nickometer vixey
17:31:49 <preflex>  vixey is 0% lame
17:31:50 <dmwit> preflex: nickometer 19
17:31:50 <preflex>  19 is 27% lame
17:31:52 <dmwit> preflex: nickometer 27
17:31:53 <preflex>  27 is 19% lame
17:31:54 <dmwit> bah
17:32:02 <vixey> there must be a fixed point!
17:32:04 <Pseudonym> Hey, amicable nicks!
17:32:08 <vixey> preflex: nickometer 34%
17:32:08 <preflex>  34% is 34% lame
17:32:13 <dmwit> yay!
17:32:24 <proq> preflex: nickometer l33t_h4x0r
17:32:24 <preflex>  l33t_h4x0r is 99.914452% lame
17:32:24 <dmwit> Was that just a good guess, or did you look at the source, or what??
17:32:34 <vixey> :P
17:32:36 <proq> ^ real purpose of nickometer
17:32:53 <Pseudonym> preflex: nickometer vixen
17:32:53 <preflex>  vixen is 0% lame
17:32:56 <vixey> I guess I just got lucky
17:33:03 <monochrom> If nickometer is not a continuous function, it may lack fixed points.
17:33:37 <Pseudonym> Who was it who was doing Markov chains on Haskell logs?
17:33:38 <vixey> what about x |--> x+1 ?
17:34:00 <dmwit> vixey: \omega ;-)
17:34:04 <mauke> âŠ¥
17:34:16 <vixey> _|_ doesn't exist
17:34:23 <vixey> It's like that zero myth
17:34:25 <Pseudonym> Ah, yeah, geezusfreak.
17:34:26 <mauke> > fix (+1)
17:34:41 <lambdabot>  thread killed
17:35:00 <Pseudonym> You might be interested: I pulled a few books off Project Gutenberg, and tried a dynamic-length Markov model.  (I removed non-letters and did case folding.)
17:35:11 <Pseudonym> It looks surprisingly like English:
17:35:28 <Pseudonym> BEUTTERSANDYOUHEWILLSAVEDESIRASICANDORATLAREDWARDTHEHALFSMILIAMONGTIMETOWITISINT
17:35:28 <Pseudonym> OTHINGSINDEDEDTOBENDINTHEMODEOFTHEKINGOFMRSDENANDWHICHINGOCCUPYOUAGAINSTANTAGEOM
17:35:33 <mauke> <hobbs> leave it to #haskell to find fixed-points.
17:36:03 <vixey> I wonder if you run markov chains on music
17:36:08 <vixey> what could you gte
17:36:14 <Pseudonym> Good question.
17:36:18 <Pseudonym> Where would you find a good corpus?
17:36:22 <monochrom> A continuous function has fixed points. But this assumes compact space (in the real analysis case) or complete lattice (in the lattice theory case) for the domain and range.
17:36:22 <Pseudonym> Just of melodies, say.
17:37:49 <tchakkazulu> Pseudonym: http://www.musopen.com/ might be worth a try.
17:37:51 <lambdabot> Title: Musopen - Free Public Domain Classical Music
17:38:07 <Pseudonym> What I found the most interesting about dynamic markov chains is the contexts that it finds "interesting".
17:38:08 <tchakkazulu> Though classical music only.
17:38:22 <Pseudonym> A lot of them are words.
17:38:33 <Pseudonym> It found "BETWEEN", for example.
17:38:42 <Pseudonym> Also two-word combinations, like "BESURE".
17:39:06 <lament> oh wow, my quote made it into the topic
17:39:14 <vixey> I wish I had a computer monitor that was like a book
17:39:15 <Pseudonym> And one I found interesting was "BEDSIDET"; apparently in the texts I was using, the word "bedside" is more often than not followed by a word that starts with "t".
17:39:25 <lament> running markov chains on music sounds like a pretty terrible idea without further refinement
17:39:46 <monochrom> Strange. Normal programmers wish for monitors that are like walls.
17:39:50 <lament> it will sound like noise
17:40:04 <tchakkazulu> "To bend in the mode of the king of mrs. Denand."
17:40:12 <vixey> monochrom :))
17:40:14 <lament> if you just do a markov chain on the interval from one note to the next, it'll sound like noise
17:40:23 <lament> you want to make it stay in one key somehow
17:40:33 <Pseudonym> lament: But you want to allow modulation, too.
17:40:39 <lament> right
17:40:45 <lament> if you do, it starts getting complicated
17:40:59 <lament> if you don't, you can just do a markov chain on the scale degree from one note to the next
17:41:05 <Pseudonym> Remember that the Bach C major prelude from the Well-Tempered Klavier (vol 1) uses all 12 notes.
17:41:08 <lament> then it will actually sound music-like
17:41:10 <Pseudonym> And that's just chords.
17:42:08 <lament> but then you need to know what key is the music you feed it
17:42:16 <lament> you need to know the key of each piece
17:42:18 <Pseudonym> Here's a nice context: "DSAIDSCROOG".
17:42:27 <Pseudonym> ("A Christmas Carol" was one of the books I used.)
17:42:28 <dmwit> ?pl \x k -> concat [f x k, g x k, h x k]
17:42:28 <lambdabot> (join .) . ap (ap . ((:) .) . f) (ap (ap . ((:) .) . g) (flip flip [] . ((:) .) . h))
17:42:31 <dmwit> augh!
17:42:41 <vixey> Pseudonym: can we have a few more lines? :)
17:42:48 <Pseudonym> Sure.
17:42:56 <Pseudonym> SEXISTEROVEALWAYSAIDALBERTSSILVERYFROCKLEHURRIEDHIMSELFHADBEENSTOMEETILLTRYTOREM
17:42:56 <Pseudonym> EMBRACCOMPANIAMEVERWHOASKEDINTHEPERSONSAREGOINTWITHTWOMOTEHARDPOMPOISONERTHANENE
17:43:13 <Pseudonym> I don't know what "Albert's Silvery Frockle" is.
17:43:19 <vixey> SEX IS TEROVEAL..
17:43:26 <byorgey> dmwit: hehe
17:43:41 <mauke> :t sequence (map uncurry [?f, ?g, ?h]) . (,)
17:43:43 <lambdabot>     Couldn't match expected type `(a, b)'
17:43:43 <lambdabot>            against inferred type `b1 -> (a1, b1)'
17:43:43 <lambdabot>     Probable cause: `(,)' is applied to too few arguments
17:43:45 <dmwit> It seems like something that could be nicely ?pl'd with the reader monad...
17:43:53 <mauke> :t (sequence (map uncurry [?f, ?g, ?h]) .) . (,)
17:43:55 <lambdabot> forall c a b. (?h::a -> b -> c, ?g::a -> b -> c, ?f::a -> b -> c) => a -> b -> [c]
17:44:05 <dmwit> yay!
17:44:12 <vixey> how could you split it into words..
17:44:20 <byorgey> :t \(x,k) -> concat [f (x,k), g (x,k), h (x,k)]
17:44:22 <lambdabot> forall t t1 a. (SimpleReflect.FromExpr [a], Show t1, Show t) => (t, t1) -> [a]
17:44:24 <Pseudonym> vixey: By not dropping spaces, I guess.
17:44:28 <byorgey> @pl \(x,k) -> concat [f (x,k), g (x,k), h (x,k)]
17:44:29 <lambdabot> uncurry ((join .) . ap (ap . (((:) . f) .) . (,)) (ap (ap . (((:) . g) .) . (,)) (flip flip [] . (((:) . h) .) . (,))))
17:44:30 <Pseudonym> But building the model takes a while.
17:44:36 <byorgey> gaaah
17:44:44 <dmwit> It should know about sequence!
17:44:48 <dmwit> But I bet it doesn't do lists.
17:44:55 <dmwit> I bet it breaks them into (:) and [].
17:45:04 <byorgey> that appears to be what it's doing
17:45:34 <Pseudonym> More lines will be quoted in #haskell-blah to avoid spamming this channel.
17:45:34 <dmwit> :t \f g h -> (concat .) . sequence [f,g,h]
17:45:36 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => f [[a]] -> f [[a]] -> f [[a]] -> f [[a]]
17:45:44 <dmwit> whoops
17:46:39 <dmwit> :t \f g h -> concat . sequence [f, g, h]
17:46:41 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => f [a] -> f [a] -> f [a] -> f [a]
17:46:44 <dmwit> ah
17:47:22 <roconnor> ah the Triple monad is the same as Reader Comparison
17:48:11 <byorgey> roconnor: what's the Triple monad?
17:48:52 <dmwit> Reader Comparison ;-)
17:49:07 * byorgey throws a ping-pong ball at dmwit
17:50:03 <byorgey> Pseudonym: neat
17:50:24 <edwardk> byorgey: data MonadMonadMonad a = MonadMonadMonad a a a =)
17:50:42 <roconnor> roconnor: it is used in Sudoku
17:50:44 <byorgey> um, right =)
17:50:57 <roconnor> Squre a = Triple (Triple a)
17:51:06 <dmwit> * roconnor mumbles something inaudible to himself
17:51:10 <edwardk> of course that seems to make me want to sing that along with the badger badger badger tune.... interspersed with bits about Functors
17:51:16 <roconnor> Grid a = Square (Square a)
17:51:37 <byorgey> badger badger badger badger FUNCTOR FUNCTOR badger badger badger...
17:51:38 <roconnor> Triple a = (a,a,a)
17:51:53 <byorgey> oh, you mean 'monad' instead of 'badger' =)
17:52:01 <edwardk> heh
17:52:02 <augur> lmfao
17:52:03 <shapr> hah
17:52:47 <mauke> data MonadMonadMonad badger = MonadMonadMonad badger badger badger
17:53:06 <mauke> deriving Snake
17:53:09 <dmwit> Ooooo, it's a Snake!
17:53:16 <edwardk> data MonadMonadMonad monad = Functor Functor
17:53:34 <edwardk> ok,
17:53:38 <edwardk> data MonadMonadMonad monad = Functor Functor deriving (Snake)
17:53:40 <eu-prleu-peupeu> is there any way to do a functional pure random ?
17:53:57 <mauke> :t random
17:53:59 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
17:54:02 <monochrom> System.Random does that.
17:54:18 <eu-prleu-peupeu> ok, thanks
17:54:20 <edwardk> eu-prleu-peupeu: not purely functional, coz you need to get a seed from somewhere
17:54:31 <Botje> @pl \(_,b) -> (b, combineFreevars b)
17:54:31 <lambdabot> ap (,) combineFreevars . snd
17:54:57 <eu-prleu-peupeu> ok
17:55:43 <Pseudonym> http://andrew.bromage.org/darcs/dynamicmarkov/
17:55:44 <lambdabot> Title: Index of /darcs/dynamicmarkov
17:56:22 <Pseudonym> That's not including the corpus.
17:56:50 <Pseudonym> http://andrew.bromage.org/corpus.model.bz2
17:56:59 <Pseudonym> But you are encouraged to build your own.
17:58:39 <Pseudonym> BTW, the reason why I built it was not to do generation, but rather to model English.
17:59:01 <Pseudonym> There's a function in Markov.hs called modelText.
17:59:27 <Pseudonym> And what it does is returns the number of base-e bits that would be used to compress a string.
17:59:31 <Pseudonym> Using the Markov model.
17:59:39 <Pseudonym> i.e. it's a measure of how "close" some text is to English.
17:59:48 <Pseudonym> This has interesting cryptographic applications.
18:00:59 <Pseudonym> Anyway, enjoy.
18:23:16 <bwr> i know this is probably simple, but i've looked through the prelude and i am wondering if there is a function that goes from (a,b) to a b  so that i don't need to do (fst x) (snd x)
18:23:35 <vixey> :t uncurry ($)
18:23:37 <Riastradh> uncurry ($)
18:23:41 <lambdabot> forall a b. (a -> b, a) -> b
18:24:01 <bwr> ah, thanks
18:24:16 <bwr> i saw that one, but it didn't stick out to me so i didn't look at it :/
18:25:06 <Riastradh> Why don't you just pattern-match on x, bwr?
18:25:23 <bwr> well, i'm just learning the language so i don't know how to do that
18:25:50 <byorgey> foo (a,b) = f a b
18:26:00 <Riastradh> Presumably you meant:  foo (f, x) = f x
18:26:15 <Riastradh> (you being byorgey)
18:26:33 <byorgey> that's not what I meant.  I guess I am not sure exactly what bwr meant.
18:26:41 <Riastradh> What's f, then, byorgey?
18:26:57 <Riastradh> Perhaps I misunderstood bwr, then.
18:27:04 <Riastradh> I took `a b' to mean `the application of the functiona to b'.
18:27:29 <byorgey> bwr: did you mean you have a tuple with a function and a value, and you want to apply the function (fst x) to the value (snd x)?
18:27:38 <byorgey> or did you just mean you want to take apart a tuple?
18:27:46 <bwr> take apart a tuple
18:27:57 <bwr> i have a function like f x y = ....
18:28:00 <bwr> and i have a tuple
18:28:07 <byorgey> right, ok, that's what I thought you meant =)
18:28:10 <bwr> so i have to do f (fst a) (snd a) to use it
18:28:14 <mauke> uncurry f a
18:28:20 <bwr> ok
18:28:51 <bwr> that works great, thanks a lot
18:30:38 <dmwit> > logBase 2 52
18:30:40 <lambdabot>  5.700439718141093
18:31:27 <vixey> > iterate (logBase 2) 2
18:31:29 <lambdabot>  [2.0,1.0,0.0,-Infinity,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,N...
18:35:28 <TSC> To try out cabal-install, must I get the development version of Cabal too?
18:39:17 <idnar> NaNaNaNa-Na-Na-NaN
18:41:09 <laz0r> just a quick naive question: would it be possible to create a puts for the State Monad?
18:41:39 <laz0r> you know, like gets, so i can specify what i want to update and only that
18:41:56 <byorgey> TSC: I think so
18:42:02 <TSC> Ok, thanks
18:42:11 <dolio> Isn't that modify, more or less?
18:43:15 <laz0r> then i would have to create functions that modify the state accordingly
18:43:33 <laz0r> one function per 'field' in the state for example
18:44:08 <laz0r> i guess thats the best available solution?
18:44:52 <dolio> Yeah, State doesn't turn your immutable data structures into mutable ones.
18:45:12 <laz0r> ah, ok, i guess just a function that pattern matches the state is the best way to write a quick on-the-fly function for modifying the state
18:45:48 <laz0r> like (\(MyState a b c d) -> a (b+1) c d)
18:46:07 <dolio> Yeah, something like that. You could look at work on lenses/functional references if you want something more compositional.
18:46:27 <dolio> But that's independent of state. It'd probably just work nicely in gets/modify.
18:46:35 <mauke> (\x -> x{ foo = foo x + 1 })
18:47:55 <laz0r> uh, even better, thanks mauke
18:51:36 <hpaste>  mattr__ pasted "translated ifl code" at http://hpaste.org/8108
18:51:55 <mattr__> I am ready to feel silly when I find out the answer....
18:52:09 <mattr__> is there a better way to put the pure code in the monadic code?
18:52:32 <mattr__> do I really have to scatter returns everywhere?
18:52:46 <dolio> ... ; let { gamma' = ... ; gamma'' = ... } ; ...
18:53:10 <mattr__> cheers
18:54:10 <dmwit> Looks like you really want a State monad there.
18:54:37 <dmwit> (Not sure about that, but the tuples everywhere suggest it.)
18:57:38 <mattr__> I am coding up a type system from the old implementing functional languages book
18:57:46 <mattr__> it was written in miranda
18:58:22 <mattr__> I just factored out all the supplementary functions that we just used to force Nothing down the line
18:58:31 <mattr__> into the maybe-as-a-monad you see there
18:58:51 <mattr__> I will look into how state-as-a-monad might help :)
18:58:53 <mattr__> cheers
19:16:01 <chessguy> ok, so i've got a master plan for getting a cool software developer job
19:16:11 <bwr> yea?
19:16:36 <chessguy> 1.) convince someone that i know enough java to take an entry level position doing stupid stuff in java
19:16:51 <chessguy> 2.) get enough experience in java that i can find somewhere that's doing cool work, but doing it in java
19:17:12 <mrd> 3.) profit
19:17:18 <bwr> haha
19:17:20 <chessguy> 3.) people doing cool work will be smart enough that i can convince them to do the cool work in a cool language
19:17:34 <bwr> that could work
19:17:48 <chessguy> or get enough experience doing that cool stuff that i can do it somewhere else in a cool language
19:17:52 <bwr> i work at a java development place
19:18:12 <chessguy> developing what?
19:18:35 <bwr> secret stuff... i work on stuff for the DoD
19:18:46 <bwr> well, it isn't so secret but not open knowledge either
19:18:53 <chessguy> is it cool stuff?
19:18:59 <bwr> some of it is cool
19:19:16 <bwr> i got to implement a graph layout algorithm  :)
19:19:22 <chessguy> bwr:  where are you?
19:19:31 <bwr> Joplin, MO
19:19:43 <chessguy> a lot of jobs i'm looking at are DoD contracts
19:20:02 <bwr> ah
19:20:09 <bwr> this is my first job out of college
19:20:21 <chessguy> wow
19:20:37 <chessguy> you must've had a great GPA or a great placement program or something
19:20:44 <bwr> small city
19:20:52 <chessguy> what school?
19:20:55 <bwr> MSSU
19:20:58 <bwr> also in Joplin, MO
19:21:32 <bwr> I think we will be allowed to use Scala for development.. so i'm trying to introduce that
19:21:38 <chessguy> nice
19:21:50 <chessguy> everyone around here wants .Net and Java
19:21:54 <bwr> languages that function well with Java are easy to get in
19:21:56 <chessguy> or at least, they think they do
19:21:59 <bwr> atleast that's my perception
19:22:15 <bwr> i also do small scripts in bash and ruby at work :P
19:22:23 <chessguy> what do you mean, 'function well with Java'
19:22:38 <bwr> like Scala can use java classes and java classes can use scala classes i believe
19:23:04 <bwr> and it is familiar enough that it shouldn't alienate any developers
19:23:14 <chessguy> wow, i didn't know that
19:23:55 <chessguy> so scala compiles to JVM bytecode?
19:23:56 <bwr> there are languages on .Net that are interesting too, like Boo and F#
19:23:58 <bwr> yes
19:24:11 <TSC> Stone the crows! cabal-install worked
19:26:23 <bwr> I've been learning haskell by doing some of the project euler problems in it
19:27:16 <chessguy> bwr:  join the crowd
19:27:20 <bwr> haha
19:27:22 <bwr> everyone does that? :P
19:27:38 <chessguy> yeah
19:27:42 <bwr> i'm pretty sure i got 196
19:27:45 <bwr> but my algorithm is slow
19:27:47 <chessguy> probably the most popular entry point into haskell
19:27:55 <bwr> for good reason
19:28:02 <bwr> it is helping me get up to speed very quickly
19:28:29 <chessguy> my problem with project euler is the math, not the haskell
19:29:50 <shepheb> chessguy: exactly my problem. I'm stalled out on algorithms and math, not Haskell skill.
19:30:12 <bwr> i think the math is what makes it fun :P
19:30:59 <shepheb> well, I learned a lot of cool math. but then I stalled out to the point of taking a couple of weeks per problem
19:31:10 <bwr> ah
19:31:18 <bwr> i just started on them this weekend
19:31:47 <bwr> i solved 3 of them very easily... this is my third day working on 196
19:35:41 <chessguy> looks like an interesting problem. how are you going about it?
19:37:24 <bwr> pretty awkwardly :) so i came up with a formula (f(x,y)) that can get me that value in the triangle... so it goes through the row in question and if that item is prime it checks the surrounding items that are of interest (the ones that are not even) and then ...
19:37:46 <bwr> if there are two in the immediate surrounding area that are prime
19:38:10 <chessguy> > let r n = 1 + sum [1..n-1]
19:38:10 <lambdabot>  Parse error at end of input
19:38:22 <chessguy> > let r n = 1 + sum [1..n-1] in r 3
19:38:25 <lambdabot>  4
19:38:27 <bwr> i add that one in to the sum, if there aren't two in the immediate surrounding area but there are 1 in the surrounding area i check the surroundings of that one
19:38:37 <bwr> it is pretty ugly code
19:38:47 <bwr> i'm really interested in seeing how other people did it
19:39:05 <chessguy> > let r n = 1 + sum [1..n-1] in r 4
19:39:09 <lambdabot>  7
19:40:37 <chessguy> > let r n = 1 + sum [1..n-1] in r 5678027
19:40:42 <lambdabot>  16119992467352
19:41:48 <chessguy> > let r n = 1 + sum [1..n-1] in r 7208785
19:41:54 <lambdabot>  25983286983721
19:41:59 <chessguy> is the complexity in the primality testing or something?
19:42:40 <bwr> well, there is some complexity there but i am just using someone else's function for that ... i had a corrent one but it was way too slow
19:43:19 <chessguy> it seems to me like it's easy to get the numbers for those two rows, and the two rows on either side of each of those
19:43:27 <chessguy> manually filter isPrime
19:43:36 <chessguy> and you're just about done
19:44:13 <bwr> perhaps you should read the problem more thoroughly :P
19:44:32 <bwr> so that would be ridiculously slow
19:45:00 <bwr> and you only want primes that are part of a prime triplet
19:45:14 <bwr> also the beginning of the row doesn't start at 1
19:46:26 <chessguy> oh, maybe i don't get it
19:46:40 <bwr> my implementation takes 25 seconds for row 10000, but has been running for atleast like 30 minutes on the real question
19:48:20 <chessguy> oh, i see now, i misunderstood what they meant by 'prime triplet'. i thought the triplets were only formed vertically and horizontally
19:48:43 <bwr> ah
19:48:50 <chessguy> i know the beginning of the row doesn't start at 1, but my r function calculates the first number in row n
19:49:00 <bwr> oh ok
19:49:19 <bwr> my mistake then
19:49:46 <chessguy> so the numbers in the row would just be [r n .. r n + (n-1)] or something
19:50:15 <bwr> ok
19:50:37 <chessguy> hm, so it's pretty easy to get the indices of the prime numbers in each row
19:51:10 <hpaste>  dino- pasted "ghc 6.8.2 cabal build problems" at http://hpaste.org/8109
19:52:16 <bwr> > let r n = 1 + ((r*(r-1))`div`2) in r 7208785
19:52:17 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
19:52:17 <lambdabot>     Probab...
19:52:22 <bwr> aww
19:52:44 <bwr> oops
19:52:50 <bwr> > let r n = 1 + ((n*(n-1))`div`2) in r 7208785
19:52:52 <lambdabot>  25983286983721
19:53:51 <chessguy> i think i like my definition better :)
19:54:00 <bwr> really?
19:54:37 <chessguy> well, it looks cleaner, i guess it's not faster
19:55:50 <chessguy> i wonder if they count a quadruplet as a triplet
19:56:16 <chessguy> or really, as several triplets
19:56:43 <bwr> not sure
19:56:58 <chessguy> seems a little vague to me
19:59:05 <bwr> i didn't even think about quadruplets
20:03:28 <bwr> chessguy: so do you work as a software developer?
20:04:12 <chessguy> bwr:  i did until about 2 weeks ago. i was laid off
20:04:12 <bwr> ah
20:04:17 <bwr> that sucks
20:05:26 <chessguy> yeah, well, it's a kick in the pants to get a better job :)
20:05:46 <bwr> haha yea
20:10:25 <newsham> ?seen dcoutts
20:10:25 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts last spoke.
20:11:59 <edward1> chessguy: did you find something else yet?
20:12:25 <chessguy> edward1:  not yet, but scroll up for my master plan
20:13:06 <edwardk> i think i rejoined after you posted it. hitting the logs =)
20:13:20 <chessguy> oh
20:13:24 <chessguy> edwardk:  1.) convince someone that i know enough java to take an entry level position doing stupid stuff in java
20:13:24 <chessguy> 2.) get enough experience in java that i can find somewhere that's doing cool work, but doing it in java
20:13:24 <chessguy> 3.) people doing cool work will be smart enough that i can convince them to do the cool work in a cool language
20:13:35 <edwardk> hah
20:14:26 <edwardk> The people doing cool work will be smart enough to say this language has cheap programmers and keep on working in their niche and laugh at you. ;)
20:14:37 <chessguy> lol
20:16:28 <Korollary> chessguy: do you know C++ or C#?
20:16:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8110
20:17:08 <chessguy> Korollary: i know c++, but everyone seems to want experience
20:17:35 <Korollary> chessguy: where are you?
20:17:45 <chessguy> Korollary:  northern virginia
20:18:06 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8111
20:18:17 <chessguy> @pl \n -> s (t (< n) p)
20:18:17 <lambdabot> s . flip t p . flip (<)
20:18:34 <bitrot> chessguy: preventive medicine in Bethesda is playing with Lisp and java...
20:19:54 <Korollary> chessguy: Companies like MS, Google, Oracle, etc. typically don't consider not knowing java a problem at all. It's more of a deal breaker for smaller shops, which are a bit scary. I truly resented the 'hit-the-ground-running' kind of expectations.
20:20:38 <chessguy> it's just dumb because knowledge is cheap. you can google knowledge in 30 seconds flat. it's the ability to acquire and apply knowledge that they should be looking for
20:21:11 <SamB_XP> so what they should do is try to teach you some crazy language, not quiz you on java, eh?
20:21:14 <Korollary> That kind of knowledge is cheap. Sometimes extensive experience in J2EE, etc. is truly needed, but that's also rare.
20:21:35 <edwardk> chessguy: it shows that you've already invested in gaining the knowledge yourself
20:21:52 <edwardk> chessguy: knowledge you have is indicative of the fact that you are capable of obtaining knowledge ;)
20:22:07 <chessguy> edwardk:  it's not the only indicator though
20:22:07 <SamB_XP> edwardk: I fail to see how learning Java unnecessarily is a wise investment
20:22:18 <dobblego> after working on IBM WebSphere Application Server and with Java consultants, I'm still unclear on what "extensive experience in J2EE" means; I think it has something to do with spanking a monkey
20:22:21 <edwardk> chessguy: sure, but in the absence of another indicator...
20:22:54 <chessguy> i've had very few companies ask me to think at all in their interviews, which is what they should be doing
20:23:01 <chessguy> make me think, work something out in front of them
20:23:39 <Korollary> dobblego: large API's turn into little specialization areas. In my group even between fellow developers we have little differences emerging as we deal with different pieces (Oracle, SOAP, etc.)
20:23:43 <edwardk> samb: i'm a much better programmer for my time in Java. I gained a lot of respect for a good VM. I'm a better programmer for my time using C++. I learned a lot about compile time metaprogramming, and to pay a lot of attention to retention and ownership issues. Do I use these skills today? Probably not all that much, but they are life lessons.
20:24:16 <dobblego> a good VM? Java?
20:24:17 <edwardk> I won't hire someone unless they can convince me they can program, and its good to have a common ground to talk about programming with a guy on. I don't care if you are the worlds best brainfuck expert.
20:24:21 <SamB_XP> C++ taught me to value other languages ;-)
20:24:29 <edwardk> dobblego: no, hence why I learned respect for a GOOD VM ;)
20:24:37 <dobblego> edwardk, oh phew :)
20:24:45 <SamB_XP> you know, i'm fairly certain that you can't know BF and nothing else
20:24:45 <chessguy> SamB_XP:  and hate multiple inheritance?
20:24:51 <SamB_XP> chessguy: no!
20:24:54 <edwardk> dobblego: heh, but that said, for its day, it wasn't BAD. It just has an incredibly flawed memory model ;)
20:24:54 <SamB_XP> that was Python
20:24:55 <dobblego> yes, Java is good for learning what-not-to-do in many respects
20:25:22 <edwardk> I love multiple inheritance. Its incredibly elegant.... in Eiffel.
20:25:42 <edwardk> Everywhere else? Generally a nightmare =)
20:25:43 <SamB_XP> leastwise, thinking about python has lead me to the conclusion that MI should be used quite sparingly
20:26:33 <edwardk> In Eiffel it can be an incredibly effective tool for designing mixin functionality and cuts out a lot of boilerplate code without requiring an inefficient structure to be threaded alongside your real data *cough* STL *cough*
20:26:37 <SamB_XP> I never really made it past a Java tutorial
20:26:46 <SamB_XP> I kept getting bored and doing something else instead
20:28:26 <chessguy> @pl nd n = p $ m ((+1).l) (g (pf n))
20:28:26 <lambdabot> nd = p . m ((1 +) . l) . g . pf
20:28:34 <SamB_XP> hmm, you know, Haskell has me happy to use MI without a second thought ;-)
20:28:51 <SamB_XP> I bet it's because typeclasses don't have disinheritance ;-)
20:30:00 <Saizan> in fact MI for interfaces is allowed and doesn't cause problems in java
20:31:56 <edwardk> yeah, but interface MI isn't an issue at all. Bah, give me real manly multiple inheritance, where i can inherit from a list mixin 5 times and specialize and rename the methods keeping the superstructure and bending it to my will ;)
20:31:57 <bwr> what happens in java if you implement two interfaces that have a method with the same signature except for return type?
20:32:13 <dobblego> bwr, compile-time error
20:32:18 <bwr> ok
20:32:25 <bwr> figured that wouldn't be allowed
20:32:32 <edwardk> bwr: in c# you can fix that by implementing the interface in qualified form.
20:32:43 <SamB_XP> edwardk: that reminds me of Algebra.Structures
20:32:50 <bwr> i haven't learned c# yet
20:33:19 <SamB_XP> C#++
20:33:25 <SamB_XP> @karma C#
20:33:25 <lambdabot> C# has a karma of 1
20:33:37 <edwardk> I like c#. I just wish it supported mixins through its generics, you can't use the boilerplate pattern =(
20:33:38 <mauke> preflex: karma C#
20:33:38 <preflex>  karma for C#: 2
20:34:14 <edwardk> Oh and parametric polymorphism would be nice. ooh, and rank-n types.
20:34:51 <edwardk> and extension interfaces, and... ok. well, its still the best tool I can get away with using in most corporate settings ;)
20:34:55 <SamB_XP> I expect they'll add those eventually
20:35:05 <edwardk> yeah
20:35:12 <SamB_XP> the first two, I mean
20:35:20 <SamB_XP> I dunno what "extension interfaces" are
20:35:33 <edwardk> the lambdas basically support that notion they never got around to giving you a way to refer to the types involved though
20:36:06 <edwardk> well, you can implement extension methods in c# which give you methods that look like they are members of a pre-existing class. they resolve 'last' in the dispatch during compilation.
20:36:13 <edwardk> in general its a great way to fix a broken API
20:36:47 <cybereal> or confuse the hell out of someone who didn't want to read all of your code just to understand one bit of it :)
20:36:50 <conal> does anyone know of a guide to reading ghc core?
20:36:55 <edwardk> the problem is since c# uses nominal types you can't just say hey i'll support any class that offers these methods (extension or not), and there is no way to retrofit an interface over existing behavior.
20:37:13 <SamB_XP> edwardk: ah.
20:37:13 <edwardk> cybereal: I've found they _really_ help when working with Sharepoint development. ;)
20:37:28 <SamB_XP> so you want a way to say "this class implements this interface, but doesn't know it"?
20:37:46 <edwardk> SamB_XP: so the idea of an extension interface would be hey look here is an interface, bolt it onto an existing class, yeah
20:38:32 <edwardk> kinda like how you'd like to say hey look every monad is a functor with fmap = liftM even if it doesn't know, but without the defaulting issues
20:38:49 <edwardk> because the methods are already in place (since the namespacing works differently there)
20:41:12 <bwr> hehe my program has been running for over an hour and a half and is less than half way done :/
20:44:08 <newsham> conal: if you find one, I'd love to hear about it.
20:48:26 <chessguy> so check it out, MS is looking at me for this position: http://members.microsoft.com/careers/search/details.aspx?JobID=EB3F5825-F53E-4033-9A38-FB2BF2AE0742&start=1&interval=10&SortCol=DatePosted
20:48:28 <lambdabot> http://tinyurl.com/5omz3s
20:49:23 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8112
20:50:28 <monochrom> You will implement the search utility that will misguide billions of people on Earth?
20:50:37 <chessguy> haha
20:51:59 <Nyenburgh> anyone have a link for a good piece on why FP is important, or what FP/ HM type systems give you for a C++ coder?
20:52:04 <monochrom> Cale is away. Time to be naughty with lambdabot.  Let's go out for a drink!
20:52:13 <mauke> @where why
20:52:14 <lambdabot> I know nothing about why.
20:52:16 <cjb> MyCatVerbs: Why Functional Programming Matters is a good paper.
20:52:19 <cjb> (old)
20:52:35 <dolio> chessguy: Are you sure you qualify? How passionate are you about quality?
20:53:04 <chessguy> i was _the_ person to care about quality in my last position
20:53:16 <monochrom> HM type system is simpler to understand than C++ type system, and is a significant subset.
20:53:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8113
20:54:28 <monochrom> Haskell typeclass is a very nice story for operator overloading. Even C++ now tries to duplicate its success by introducing "concept".
21:13:02 <frevidar> I want to make a type signature for a function that says "this function takes an array-like object as its input, that is, something that has the ! operator"
21:13:20 <frevidar> is there a class that Array belongs to or something that generalises this?
21:13:37 <frevidar> is it the Ix class, or something else?
21:13:44 <mauke> :t (!)
21:13:48 <frevidar> I was thinking Ix was talking about the actual indexes
21:13:51 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
21:13:56 <mauke> :t (Data.Array.IArray.!)
21:14:04 <lambdabot> forall (a :: * -> * -> *) i e. (Ix i, Data.Array.Base.IArray a e) => a i e -> i -> e
21:15:35 <frevidar> ok
21:16:21 <frevidar> so what would be the type signature for a function that takes an array like object as input and outputs a constant 0
21:16:32 <frevidar> ?
21:17:07 <Elly> "array like object" being what type?
21:17:11 <mauke> (Ix i, IArray a e, Num n) => a i e -> n
21:17:15 <rms> mauke: have you read your SICP today?
21:17:50 <mauke> no, but what does the ``r'' in rms stand for?
21:18:16 <frevidar> where are the docs for IArray?
21:18:17 <rms> rms
21:18:49 <frevidar> I can't see IArray in the Array section of the library repory
21:18:55 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/
21:19:00 <bos> isn't there some magic thing one can do to find out how ghci is parsing an expression, i.e. to explicitly put parentheses into an expression that lacks them?
21:19:05 <bos> am i misremembering?
21:19:23 <Saizan> bos: there's a flag to print the parse tree
21:19:53 <Saizan> bos: something that starts with -ddump
21:20:19 <frevidar> so Haskell 98 doesn't have a generic abstract array type?
21:20:37 <frevidar> or, should I say, is IArray the abstract array type/class?
21:20:37 <mauke> haskell98 doesn't have multiparameter type classes
21:20:39 <bos> Saizan: you are the winner! thanks.
21:20:44 <bos> -ddump-parsed
21:20:50 <frevidar> mauke: ah
21:20:52 <frevidar> I see
21:21:06 <frevidar> kind of anyway
21:21:11 <bos> only, uh, it doesn't help.
21:49:29 <hpaste>  frevidar pasted "How should I write this type signature" at http://hpaste.org/8114
21:50:19 <frevidar> if someone could show me how to compile that with a type signature, that would be great?
21:50:45 <Saizan> frevidar: type signatures are part of the code section
21:50:56 <frevidar> particularly, allowing the use of any Array type of a particular typeclass
21:50:58 <Saizan> frevidar: so you need a > for them too
21:51:20 <frevidar> Saizan: I know. What do you mean?
21:51:28 <frevidar> I haven't got a type signature yet
21:51:35 <frevidar> the line without a > is a comment
21:52:32 <Saizan> tried asking ghci first?
21:52:54 <frevidar> saizan: How could I do that?
21:53:04 <Saizan> ":type tridiagonal_solve" at the prompt
21:53:19 <frevidar> after loading the file in ghci?
21:53:55 <Saizan> yes
21:54:19 <Saizan> if you want to use the class you should import Data.Array.IArray rather than Array though
21:56:07 <dmwit> Augh, literal tabs.
21:56:33 <dmwit> Augh!  Literal tabs that are not restricted to the beginning of the line!
21:58:32 <frevidar> Saizan: When I import Data.Array.IArray instead of array it fails to compile
21:58:50 <frevidar> why is that?
21:59:11 <dmwit> What error do you get?
21:59:55 <frevidar> main.lhs:3:15:
21:59:56 <frevidar>     No instance for (Show (a t t1))
21:59:58 <frevidar>       arising from a use of `print' at main.lhs:3:15-25
22:00:00 <frevidar>     Possible fix: add an instance declaration for (Show (a t t1))
22:00:01 <frevidar>     In the expression: print test1
22:00:03 <frevidar>     In the definition of `main': main = print test1
22:01:07 <dmwit> frevidar: At some point, you have to restrict the type to an actual concrete type.
22:01:30 <dmwit> frevidar: Add a type signature to "test1" that chooses an instance of IArray, and you'll be good to go.
22:01:45 <dmwit> ...provided that instance is also an instance of Show. =)
22:03:44 <frevidar> dmwit: ok, like "test1 :: Array Int Double"?
22:03:52 <dmwit> Something like that, yeah.
22:04:25 <frevidar> dmwit: adding that gives a lot of compile errors
22:04:32 <dmwit> heh
22:05:10 <frevidar> main.lhs:8:24:
22:05:12 <frevidar>     No instances for (IArray a1 Double, IArray a Double)
22:05:13 <frevidar>       arising from a use of `tridiagonal_solve'
22:05:14 <dmwit> Well, fix them one error at a time, I guess.
22:05:15 <frevidar>                    at main.lhs:(8,24)-(15,24)
22:05:19 <dmwit> Please don't paste them all here.
22:05:31 <dmwit> ?hpaste
22:05:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:06:53 <hpaste>  frevidar pasted "Code and errors on the end:" at http://hpaste.org/8115
22:07:58 <frevidar> oops, pasted a few of the previous errors as well
22:08:05 <frevidar> no matter
22:08:51 <Saizan> frevidar: since your arrays are all indipendents you'd have to specify a concrete type for each of the arguments in test1
22:09:01 <dmwit> Are you using Double as your index type for your arrays?
22:09:10 <dmwit> That seems like a bad idea.
22:09:22 <Saizan> dmwit: the second parameter is not the index
22:09:54 <dmwit> ah
22:10:07 <frevidar> ok, so listArray, when using Data.Array.IArray produces an abstract type, for want of a better word, yes?
22:10:14 <Saizan> yes
22:10:31 <Saizan> very handwavy
22:11:24 <Saizan> personally i'd comment out main and test1, so you can play with tridiagonal_solve
22:12:16 <Saizan> since if you restrict it type so that it uses the same array type for arguments and result then you'd need far fewer type annotations when using it
22:13:08 <dmwit> (And switch over from tuples to function application while you're at it. ;-)
22:15:03 <frevidar> Saizan: except, I want tridiagonal solve to take different sorts of "Arrays"
22:15:29 <frevidar> for example, I might want to to take an "Array" which is generated by a function on the fly
22:15:59 <Saizan> frevidar: different array types in the same invocation?
22:16:13 <frevidar> Saizan: possibly
22:16:24 <Saizan> ok
22:16:25 <frevidar> one of the rows maybe constant
22:19:13 <Saizan> well then you need to make the typechecker know which concrete type the arguments have, in the case of test1 you need explicit type annotations since there's not enough context to infer them
22:47:51 <Nyenburgh> wow
22:48:18 <mxc> i've never seen an IPV6 address in use before
22:48:38 <dons> heh
22:48:56 <mxc> its shaping up to quite a week
22:49:20 <mxc> obama gets the nomination back home, 3g iphone next monday, and my ipv6 cherry gets popped in the middle
22:49:35 <mxc> sry if thats too graphic
22:50:50 <mxc> sry about that ALC, just curious if it would work
22:53:59 <mxc> dons - any idea what animal will grace the cover of RWH?
22:55:16 <quicksilver> the lambda potato!
22:55:56 <lament> potatos are animals too!!!
22:57:15 <mxc> the world 'llama' kind of sounds like 'lambda'
22:58:00 <lament> anyone knows who's in charge of cmeme?
23:03:11 <quicksilver> lament: ircbrowse.org
23:03:24 <quicksilver> or .com
23:03:28 <quicksilver> whichever they are :)
23:08:52 <mxc> :t liftM
23:08:53 <mxc> :t liftIO
23:08:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:08:59 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:10:00 <Saizan> :t lift
23:10:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
23:10:20 <mxc> @hoogle liftIO
23:10:20 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
23:11:08 <mxc> so liftIO is just a special case of lift?
23:11:43 <mxc> err, no, not really
23:12:40 <mxc> > take 1 ["good boy","bone"]
23:12:41 <lambdabot>  ["good boy"]
23:13:29 <Saizan> mxc: liftIO is a multi-layer lift restricted to IO :)
23:13:42 <mxc> ah
23:16:12 <Saizan> IO liftIO = id, MonadIO m => FooT m  liftIO = lift . liftIO, so e.g. for StateT s (ReaderT r IO) liftIO = lift . lift . id
23:23:26 <quicksilver> liftIO is lift^n where n is enough to find the IO :)
23:29:53 <solrize> mxc, i don't think RWH is an o'really book
23:30:14 <ivanm> ORLY? :p
23:30:31 <solrize> oh wait it is
23:30:32 <solrize> sorry
23:30:39 <solrize> http://book.realworldhaskell.org
23:30:40 <lambdabot> Title: Real World Haskell
23:30:49 <mxc> really?
23:30:51 <mxc> i thought it was
23:30:52 <mxc> oh
23:30:56 <mxc> sorry
23:31:22 <lament> a sloth dammit
23:32:03 <ivanm> they're using a sloth for the cover of RWH? :o
23:32:11 <ivanm> I'm guessing due to the laziness...
23:32:38 <mxc> how about a fat guy on the couch watching tv drinking a beer
23:32:47 <ivanm> heh
23:32:53 <ivanm> that's an animal, isn't it?
23:32:55 <mxc> and the subtitle could be "what if you could harness this"
23:33:00 <ivanm> lol
23:33:28 <ivanm> how about a monitor lizard? normally slow but goes fast when it has to!
23:33:31 <mxc> oh, i didn't realize, one of the RWH troika wrote the mercurial manual
23:33:36 <ivanm> or am I thinking of something else?
23:35:47 <mxc> what would be the biological equivalent of referential transparency?
23:35:49 <quicksilver> ivanm: monitor lizard has been used I'm pretty sure.
23:36:08 <cybereal> hm cicada? :)
23:36:10 <ivanm> awww :(
23:36:15 <cybereal> maybe thats the opposite
23:36:32 <ivanm> mxc: or else static typing...
23:36:33 <quicksilver> ah know, I'm wrong.
23:36:39 <quicksilver> http://oreilly.com/animals.html
23:36:39 <lambdabot> Title: Animal Menagerie
23:37:05 <mxc> static typic coudl apply to ocaml, but I guess that they could just use a camel for ocaml
23:37:34 <quicksilver> the camel belongs to perl.
23:38:26 <cybereal> should use a frog for ocaml
23:38:31 <lament> LOL
23:38:33 <ivanm> cybereal: why a frog?
23:38:33 <mxc> ?
23:38:38 <lament> cybereal++
23:38:41 <ivanm> it jumps around a lot?
23:38:49 <mxc> amphibian - oop + FP?
23:38:54 <mxc> oh
23:38:56 <mxc> french
23:38:59 <mxc> i get it
23:38:59 <cybereal> :)
23:39:25 <lament> oh, is that actually what you meant?
23:39:31 <ivanm> ...that's a _really_ bad joke...
23:39:33 <lament> cybereal-- :(
23:39:35 <cybereal> haha
23:39:50 <mxc> so for haskell - a bottle of scotch?
23:40:07 <mxc> or the really belligerent guy from trainspotting?
23:40:09 <solrize> frog b/c ocaml is french?
23:40:12 <ivanm> lament: what did you think it was?
23:40:16 <ivanm> mxc: lol
23:40:26 <ivanm> so it should be a sheep then!
23:40:37 <ivanm> scots love sheep almost as much as the kiwis do, right?
23:40:51 <solrize> i've heard "O'Caml, the Irish ship of the desert"
23:41:14 <mxc> ?
23:41:38 <solrize> camels = ships of the desert (some old cliche)
23:41:42 <cybereal> hm maybe a kangaroo for haskell
23:41:45 <mxc> oh
23:41:53 <lament> ivanm: flying frog
23:41:54 <ivanm> cybereal: why?
23:41:57 <mxc> what does monad rhyme with?
23:41:59 <ivanm> lament: ahhh...
23:42:00 <mxc> hehe
23:42:00 <cybereal> they way they repreoduce
23:42:06 <cybereal> rather the way the baby develops
23:42:24 <ivanm> cybereal: ummm... in a pouch? why not echidnas then? or any other marsupial?
23:42:50 <cybereal> Sure, but kangaroo was the first to come to mind
23:42:56 <ivanm> heh
23:43:05 <ivanm> platypus? you think "wtf???" :p
23:43:13 <ivanm> cybereal: though how does reproduction come into it?
23:43:56 <cybereal> I don't know, I'm going out on a limb since I don't *quite* know haskell yet (hence being here) but I thought the baby could represent a monad :)
23:44:37 <ivanm> ....maybe...
23:44:45 <ivanm> definitely monad as container :p
23:45:16 <cybereal> but it's already set as a sloth then?
23:45:23 <ivanm> looks like it :s
23:46:58 <mxc> hermit crab
23:47:01 <mxc> herring
23:47:14 <mxc> hen
23:47:18 <ivanm> why herring or hen?
23:47:22 <cybereal> mxc: you can cut down trees with haskell?
23:47:23 <mxc> hawk
23:47:29 <ivanm> I think hermit crab works though... they're reasonably lazy
23:48:26 <mxc> no, just carrying forward the silly 'h' thing
23:48:47 <ivanm> which 'h' think? haskell h?
23:48:57 <mxc> how about an indian or thai chef?
23:49:07 <mxc> (seeing who can figure that out)
23:49:11 * ivanm can't
23:49:16 <ivanm> probably don't want to, either...
23:49:35 <mxc> the tendency to prefix the names of haskell libs with the letter 'h'
23:49:41 <cybereal> mxc: I prefer thai, or japanese
23:49:47 <ivanm> mxc: ahhh
23:49:47 <mxc> here's a hint
23:49:53 <mxc> who is haskell named after?
23:50:06 <ivanm> *groan*
23:50:31 <ilyak_> I wonder if a next generation Prelude library is under active development.
23:50:35 <ilyak_> Are there such projects?
23:51:18 <mxc> ilyak_ - i think most of the current work is focussed on adding fun little features to lambdabot and discussing which animal should go on the cover of a new haskell book
23:53:16 <ilyak_> Well, lambdabot already have some of it in place
23:53:19 <ilyak_> Like, map = fmap
23:53:24 <ivanm> that reminds me... who fixed lambdabot?
23:53:30 <ivanm> @users -- e.g.
23:53:30 <lambdabot> Maximum users seen in -- e.g.: 1, currently: 0 (0.0%), active: 0 (NaN%)
23:53:39 <ivanm> ummm.... maybe not _quite_ fixed :s
23:53:48 <mxc> you know what, a kangaroo does kind of look like a lambda
23:53:49 <ivanm> worked in #gentoo-haskell though :s
23:53:54 <ivanm> mxc: lol
23:53:57 <ivanm> true
23:54:10 <ilyak_> Prelude isn't that big, it should be a quick hack
23:54:21 <ilyak_> And you can use it right away with no-implicit-prelude
23:54:36 * mxc would like to thank ilyak_ for implicitly volunteering to do it in that case 
23:54:46 <mxc> :)
23:54:57 <ivanm> oh, and combine it with the mathematical prelude whilst you're at it
23:55:20 <ilyak_> I would like, but I absolutly lack the quality that lets one to sit down and do it.
23:55:29 <ilyak_> ivanm: Which one is that?
23:55:42 <ivanm> @go mathematical prelude
23:55:44 <lambdabot> http://www.amazon.com/Prelude-Mathematics-W-Sawyer/dp/0486244016
23:55:49 <ivanm> that's not it :p
23:55:50 <ivanm> @go mathematical prelude haskell
23:55:52 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
23:55:52 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki
23:55:59 <ivanm> that page has a link to it
23:56:38 <ilyak_> I'll look at it, thanks
