00:00:00 <newsham> ?type \x y -> x + y
00:00:14 <lambdabot> forall a. (Num a) => a -> a -> a
00:00:22 <EvilTerran> leoncamel, http://www.haskell.org/haskellwiki/Monomorphism_restriction
00:00:22 <lambdabot> Title: Monomorphism restriction - HaskellWiki
00:00:55 <newsham> btw, your code works fine for me in ghci
00:01:20 <leoncamel> newsham, hmm, yes I am checking it...
00:03:16 <leoncamel> newsham, I got it.. it works here. I missed type on my laptop.. :). So, haskell is quite powerfull.. continue learning ... :)
00:03:33 <EvilTerran> leoncamel, basically, it boils down to "use explicit type signatures on parameterless definitions"
00:03:41 <EvilTerran> (it's good practice anyway)
00:04:18 <newsham> g'nite and good luck
00:05:11 <leoncamel> EvilTerran, hmm, what do you mean explicit type signatures exactly ? you mean I add "myadd2 :: [Int] -> [Int]" before I define the function ?
00:05:53 <EvilTerran> leoncamel, exactly. if you do that everywhere, the DMR will never touch you
00:05:54 <monochrom> Yes. But it's myadd2 :: Int -> Int
00:06:09 <EvilTerran> well, not *exactly* exactly (as monochrom says)
00:06:13 <leoncamel> monochrom, :) . aha.. got it ..
00:06:22 <Dzlk> [Int] would be a list of ints.
00:06:48 <EvilTerran> or myAdd2 :: (Num a) => (a -> a)
00:07:27 <EvilTerran> (you don't really need either pair of those (...)s, but i think it makes things clearer)
00:07:28 <dmwit> Or use -fno-monomorphism-restriction
00:07:31 <leoncamel> oh ? Num means Integer ? or any float ?
00:07:37 <EvilTerran> ?instances Num
00:07:37 <lambdabot> Double, Float, Int, Integer
00:07:40 <EvilTerran> ?src Num
00:07:41 <lambdabot> class  (Eq a, Show a) => Num a  where
00:07:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:07:41 <lambdabot>     negate, abs, signum     :: a -> a
00:07:41 <lambdabot>     fromInteger             :: Integer -> a
00:08:36 <Dzlk> Num is the whole class of numeric types.
00:08:40 <EvilTerran> if the class context (the bit to the left of the =>) contains "Num a", that means that, in the type proper (to the right of the =>), "a" can represent any type that implements all those functions (we make an OOP pun here and call functions defined as part of a typeclass "methods")
00:08:55 <EvilTerran> dmwit, shh, that's cheating
00:09:05 <EvilTerran> dmwit, anyway, it should be -XNoMonomorphismRestriction :P
00:09:11 <leoncamel> EvilTerran, oh.. I got it .. thanks ..
00:09:19 <dmwit> EvilTerran: Dunno, I kind of like GHC to infer my types for me.
00:10:30 <EvilTerran> leoncamel, np :) ... that's the type ghc would infer anyway if it wasn't for the DMR - it's the most general type possible for a function which applies (+) (and nothing else) to its parameter
00:10:34 <EvilTerran> ?type (+2)
00:10:36 <lambdabot> forall a. (Num a) => a -> a
00:10:59 <EvilTerran> (ignore the "forall a." bit, that's a GHC extension)
00:14:05 <EvilTerran> (speaking of OOP puns, /me recently defined an "of" method in java (T -> Bool, in an interface Pred<T>), which amused me far more than it should)
00:14:35 <hpaste>  dolio annotated "heinous types" with "better (I think)" at http://hpaste.org/8142#a1
00:16:09 <monochrom> someone should add dependent types to java. that will shock the world.
00:16:29 <dolio> Yeah, it'll be easy.
00:17:16 <EvilTerran> unfortunately, i don't think i can get an out-of-uni academic to supervise my project next year, otherwise i'd see if Oleg was interested in supervising me do that :P
00:17:44 <dolio> It's not like the community moans about every proposed change that's the least bit academic-sounding.
00:18:05 * EvilTerran currently intends to write a graphical proof assistant in Haskell + gtk2hs
00:20:52 <jsnx> :t log
00:20:53 <lambdabot> forall a. (Floating a) => a -> a
00:30:03 <dolio> Anyone know the latex name for the symbol that looks like â‰» but is pointing up?
00:30:35 <ivanm> @go latex symbols
00:30:42 <ivanm> preflex?
00:30:42 <preflex>  
00:30:46 <Zao> dolio: Did you check lshort?
00:30:50 <lambdabot> Plugin `search' failed with: thread killed
00:30:51 <ivanm> no, not the bot preflex...
00:30:58 <ivanm> hmmm.... why can't lambdabot search?
00:31:02 <ivanm> @go latex symbols
00:31:17 <lambdabot> Plugin `search' failed with: thread killed
00:31:35 <ivanm> @go latex math symbols
00:31:37 <lambdabot> http://www.fi.uib.no/Fysisk/Teori/KURS/WRK/TeX/symALL.html
00:31:37 <lambdabot> Title: Latex Math Symbols
00:31:38 <ivanm> let's try that...
00:31:42 <Zao> What's that glyph supposed to be anyway, \succ?
00:31:53 <ivanm> dolio: try that link
00:32:08 * ivanm wonders why "latex math symbols" works, but not "latex symbols"...
00:32:38 <Zao> dolio: \curlywedge, likely.
00:32:53 <Zao> See page 67 of lshort.
00:34:44 <dolio> The one I sent was \succ, yes.
00:35:17 <Zao> curlywedge points upwards, anyway.
00:35:23 <Zao> Learn to love lshort :)
00:35:59 <dolio> I have a 4-page document that lists lots of latex symbols that I've been using, but it occasionally misses some.
00:36:31 <dolio> \curlywedge looks right. Unfortunately my unicode font is lacking, it seems.
00:37:19 <therp> http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf <- my latex symbol reference
00:37:20 <lambdabot> http://tinyurl.com/5583t
00:37:35 <therp> (my!=by me)
00:47:59 <ivanm> just idly wondering... the main point of the RTS is for GC, right? does anyone know of a GC-based language that _doesn't_ require either an interpreter, VM or RTS to run?
00:48:22 <lament> lisp on de lisp machine :)
00:48:34 <quicksilver> ivanm: ghc's RTS does much more than GC. But putting that aside...
00:48:41 <ivanm> lament: lol
00:48:46 <quicksilver> if there wasn't an RTS then what would be doing the GC?
00:48:49 <ivanm> quicksilver: what else does it do then?
00:48:56 <quicksilver> ivanm: threading, IO scheduling
00:49:02 <ivanm> true... forgot about that :s
00:49:08 <quicksilver> STM
00:49:32 <quicksilver> if your OS does GC in some sensible generic way you might not need RTS support.
00:49:40 <ivanm> well, as for the GC... I kind of thought that that was why C-- was used... convert all GC calls to malloc, etc.... or does the RTS act kind of as a library for all malloc, etc. stuff?
00:49:50 <ivanm> anyone know how D does it then?
00:49:59 <lament> C does it
00:50:00 <quicksilver> with an RTS, of course :)
00:50:01 <lament> with Boehm
00:50:06 <jsnx> let's all just use files and let the kernel take care of GC
00:50:31 <quicksilver> malloc is not enough for GC.
00:50:38 <ivanm> lament: Boehm == external library/app?
00:50:46 <lament> it's a library
00:50:47 <quicksilver> GC requires something to scan the heap and find dead data.
00:50:53 <ivanm> quicksilver: well, by malloc I meant manual memory control
00:51:40 <quicksilver> you can't "convert all GC calls to malloc"
00:51:46 <quicksilver> this phrase doesn't make much sense :)
00:51:57 <quicksilver> something has to scan the heap.
00:52:07 <ivanm> no, I know that
00:52:18 <ivanm> I just couldn't think of a better term/phrase for it when I wrote that ;-)
00:52:49 <Dzlk> You'd have the OS's VM system do the GC, maybe?
00:53:12 <ivanm> so there's no way a self-contained app written using GC can do it on its own then?
00:53:16 <jsnx> i'm trying to imagine what that really means
00:53:30 <ivanm> jsnx: what I just said?
00:53:48 <jsnx> Dzlk: if there is a "variable system" in the same way that UNIX has a file system, i suppose you could
00:54:09 <jsnx> ivanm: what is this "do it on it's own" bit? does linking in a library not count?
00:55:01 <jsnx> Dzlk: though i imagine the OS would have to know an awful lot about how you represented your data, so it could find links
00:55:04 <ivanm> jsnx: I meant a statically compiled app, but without something like the RTS (which AFAICT is like a mini-interpreter or bootstrap environment)
00:55:37 <Dzlk> jsnx: Yeah, that's the problem I'm considering.
00:55:38 <jsnx> ivanm: so, it would just have an even more mini interpreter
00:55:53 <jsnx> or a little GC daemon
00:56:32 <jsnx> but it needs to be something that can control execution, so you can move things around without confusing stuff
00:56:50 <ivanm> yeah...
00:57:04 <jsnx> (unless you have a do not move anything and do not compact the heap policy to GC)
00:57:15 <Dzlk> If you didn't mind forcing an allocation API on the compilers your OS supports then I supposse a synthetic filesystem would work.
00:57:34 <jsnx> well, it would be weird
00:57:35 <ivanm> I used to think that the GC stuff in haskell, etc. compiled down to C's manual memory allocation management :s
00:57:54 <jsnx> ivanm: in some cases, but not in general
00:58:41 <jsnx> Dzlk: well, the odd thing is that your lists would be come directories containing a file and a directory containing a file and a directory containing a file and a directory...
00:58:50 <ivanm> jsnx: *nod*
01:00:49 <jsnx> but IPC would be easy
01:01:35 <Dzlk> jsnx: Well, you don't necessarily have to represent the data structure in the filesystem.
01:02:15 <tibbe> is it possible to compile haskell (or other lambda calculus based languages) using a one-pass compiler?
01:02:28 <jsnx> how would the GC system know when the links were dead?
01:02:36 <tibbe> I read that all languages can't be compiled using such a compiler
01:02:46 <Dzlk> You could have something like /proc/<pid>/heap/<oid>. Or for generational GC you could have young/ and old/.
01:03:00 <Dzlk> jsnx: Maybe some sort of map file.
01:11:35 <Baughn> tibbe: Possibly others; I don't see any real problem. Definitely not haskell.
01:12:47 <Baughn> tibbe: I'm not sure I'd claim that haskell is based on lambda calculus, though. No more than C is based on turing machines.
01:15:27 <ivanm> Baughn: how is it not?
01:16:05 <Baughn> ivanm: The people designing haskell didn't explicitly model it after lambda calculus. That would've been silly.
01:17:28 <ivanm> well, not fully, seeing as how lambda calculus is typeless...
01:17:44 <roderyk> I'm still lost: /usr/local/include/SDL/SDL_mixer.h exists and #defines Mix_LoadWAV(file) ; but Loading package SDL-mixer-0.5.2 ... linking ... <interactive>: /usr/local/lib/SDL-mixer-0.5.2/ghc-6.8.2/HSSDL-mixer-0.5.2.o: unknown symbol `Mix_LoadWAV' ==> how can I find where its looking for the headers? and how to change it?
01:17:55 <Baughn>  I was thinking more about its being the moral equivalent of a turing machine. ;)
01:18:05 <Baughn> Though lambda calculus is a lot nicer, granted
01:18:09 <ivanm> roderyk: lib path is wrong?
01:19:31 <roderyk> ivanm: then the package wouldn't build in the first place, right? configure seems to find *something* related to SDL-mixer (this is FreeBSD, btw)
01:19:33 <quicksilver> ivanm: the RTS is nothing like a mini interpreter.
01:20:08 <quicksilver> ivanm: you can choose to view it simply as a library if you prefer.
01:20:13 <ivanm> *nod*
01:20:16 <tibbe> Baughn: I'm a bit confused. Are you saying that Haskell can or can't be compiled in one pass? :)
01:20:27 <quicksilver> ivanm: suggesting it's a mini interpreter suggests that GHC does not compile haskell to native code.
01:20:37 <ivanm> true
01:20:47 <quicksilver> any system which does GC needs a garbage collector.
01:20:58 <quicksilver> You could write a new garbage collector for every project you wrote.
01:21:03 <quicksilver> or you can use one that someone else wrote.
01:21:04 <Baughn> tibbe: I'm saying it most definitely can't
01:21:14 <quicksilver> many big projects in non-GC languages end up writing their own GC
01:21:24 <quicksilver> firefox is one example.
01:21:41 <Baughn> tibbe: For one thing, it allows you to call functions that are defined lower down in the source
01:22:01 <Baughn> tibbe: Although, "one-pass" is a bit vague. Might be better to say "can't be compiled using O(1) memory"
01:23:19 <tibbe> Baughn: ok, how about a dynamically typed language were method resolution is (usually) done using dictionaries. Python can for example refer to function declared later in the source
01:23:51 <ivanm> it just crashes if you try and use it and that function doesn't actually exist? :p
01:23:55 <quicksilver> one pass is very vague.
01:24:06 <Dzlk> Hah, there's a techno musician who goes by "System F".
01:24:12 <quicksilver> apart from anything else it suggests that for some reason it's something to aim for.
01:24:27 <quicksilver> if it's more convenient to code your algorithm in multiple passes, why not do that?
01:24:34 <tibbe> quicksilver: http://en.wikipedia.org/wiki/One-pass_compiler
01:25:09 <quicksilver> frankly that article is full of shit.
01:25:12 <quicksilver> :)
01:25:16 <tibbe> quicksilver: because if you're writing e.g. a javascript interpreter and emitting bytecode you might not want the extra time spent compiling
01:25:30 <tibbe> are there any better GC libraries out there than Boehm's?
01:25:32 <quicksilver> a two pass compiler can be 100x faster than a one pass compiler.
01:25:43 <quicksilver> if each pass in the two pass compiler is 200x the speed
01:25:43 <tibbe> quicksilver: how?
01:25:48 <quicksilver> (obviously)
01:25:59 <quicksilver> as I say, it's a very vague concept.
01:26:03 <quicksilver> I can't really imagine making it precise.
01:26:09 <tibbe> I see
01:26:17 <quicksilver> I don't mean its useless. There is some intuitive value in thinking about doing things in one-pass.
01:26:23 <ilyak_> tibbe: To make a GC "library", that library should be aware of your language's intrisnics
01:26:24 <tibbe> lets define it as not generating a second intermediate format
01:26:27 <quicksilver> but I'm saying it's not really interesting to try to make it precise.
01:26:37 <ilyak_> Or else it wouldn't be better than Boehm
01:26:41 <quicksilver> tibbe: I can conceal an intermediate format by hiding it in registers in memory.
01:26:48 <Baughn> tibbe: The motivation for making a compiler one-pass is (a) so you only have to read the source file from disk once, and (b) so the compiler will use a predictable amount of memory
01:26:50 <quicksilver> tibbe: am I even allowed to generate a symbol table?
01:27:00 <ilyak_> Boehm is non-relocating, right? And you can't use a relocating GC with C and non-tagged memory
01:27:00 <Baughn> tibbe: Neither of those considerations really /apply/ to modern systems
01:27:01 <tibbe> ilyak_: I guess that's neccesary for a good one but I could see a block allocating malloc like GC
01:27:06 <quicksilver> maybe you think my symbol table is a partial intermediate format...
01:27:11 <Baughn> ilyak_: Right, and wrong
01:27:45 <Baughn> ilyak_: YOu most certainly can use a relocating GC with C. It will just break a lot of assumptions users make that aren't actually guaranteed by the C standard.
01:28:25 <tibbe> Baughn: I'm asking this in the light of the new SquirrelFish JavaScript interpreter made for Safari which launched recently which is a one-pass compiler. I also read a bunch of papers on interpreter implementation and they also used a one pass compiler
01:29:03 <tibbe> quicksilver: not really no as you would have a dictionary as your symbol table in a dynamic language
01:29:13 <ilyak_> Baughn: Well, it is going to alter your strings and ints
01:29:13 <quicksilver> tibbe: I think what Im' trying to get across, in a clumsy way, is that it's a statement of intent and a question of degree.
01:29:15 <Baughn> tibbe: One-pass compilers are simpler to reason about, since they have a constant (well, limited) amount of state. That makes them popular with some researchers and for education
01:29:21 <quicksilver> it's not something you can make very precise.
01:29:27 <Baughn> ilyak_: Obviously your compiler has to maintain type information
01:29:30 <ilyak_> If they will happen to match pointers of objects which are being relocated
01:29:44 <quicksilver> if you have an interpreter, it's trivial to make your "compiler" one-pass.
01:29:51 <ilyak_> Well, in C you allocate void *
01:29:53 <quicksilver> You just defer anything which isn't one-pass to the interpretation phase.
01:29:54 <tibbe> quicksilver: I see
01:29:55 <ilyak_> And cast it away
01:30:06 <ilyak_> You can't make assumptions about types of data
01:30:09 <quicksilver> after all a trivial setup would be:
01:30:16 <quicksilver> 1. compiler does nothing except load source into memory
01:30:16 <Baughn> tibbe: It is still the case that, while one-pass compilers /can/ be simple, for any sort of interesting language they typically /won't/ be
01:30:17 <ilyak_> You can only make assumptions about types of variables
01:30:20 <ilyak_> Static typing
01:30:24 <tibbe> quicksilver: I think the example that was given was a type language like fortran that requires you to declare a function before its use.
01:30:24 <quicksilver> 2. interpreter works directly on source
01:30:37 <tibbe> quicksilver: without that declaration you can't write a "one-pass" compiler
01:30:43 <quicksilver> yes you can.
01:30:51 <quicksilver> you write a one-pass compiler that defers symbol errors until the end :P
01:30:56 * quicksilver shrugs
01:31:00 <quicksilver> is that still one-pass? I don't know.
01:31:04 <quicksilver> it's a question of degree.
01:31:09 <quicksilver> the javascript compiler you just described
01:31:14 <quicksilver> defers symbol errors until runtime
01:31:18 <quicksilver> (Which is what javascript does)
01:31:21 <quicksilver> isn't that the same thing?
01:31:22 <tibbe> quicksilver: so the assumption I'm making is that the interpreter uses some common kind of bytecode
01:31:30 <ilyak_> Interpreter is generally one-pass I think
01:31:45 <quicksilver> modern interpreters are almost all compilers.
01:31:54 <quicksilver> They compile to some intermediate form which they then interpret.
01:31:56 <ilyak_> It doesn't need to be more-pass since it doesn't have to check types (speaking of dynamic languages)
01:32:09 <tibbe> quicksilver: right
01:32:18 <quicksilver> (again the difference between an interpreter and a compiler is also a continuum)
01:32:23 <Dzlk> some Forths are arguably native-code interpreters.
01:32:32 <Baughn> quicksilver: No, you really can't. A static language /needs/ functions to be pre-declared to be one-pass, since otherwise it won't be able to generate the call assembly - and you can't defer /anything/ without breaking the "constant amount of memory" rule
01:32:46 <quicksilver> You might try to say this: In a one-pass system, your compiler is only allowed to build up O(1) state as it goes throught he program
01:32:56 <quicksilver> if it builds up O(n) state then it's cheating and really multi-pass.
01:33:00 <Baughn> quicksilver: Parsing the source file first, then doing inference and fixups, then writing out the executable.. is a fine way to write a compiler, but that's ghc, not one-pass. :P
01:33:06 <tibbe> quicksilver: would it be valid to say that as long as you delay symbol lookup error until runtime you can emit bytecode using only one pass?
01:33:21 <tibbe> quicksilver: sounds like a sensible definition
01:33:25 <quicksilver> Baughn: let the linker generate the call assembly?
01:33:26 <Baughn> Mm, yeah. I just said it, at that.
01:33:35 <quicksilver> Baughn: and let the linker emit the type errors?
01:33:38 <Baughn> quicksilver: If you have a separate linker it's two-pass
01:33:45 <quicksilver> maybe, maybe not.
01:33:49 <quicksilver> I'm not trying to be awkward.
01:33:54 <quicksilver> I'm trying to say these definitions are fuzzy.
01:34:01 <quicksilver> they're not meaningless but they are fuzzy.
01:34:15 <tibbe> you're not being awkward :)
01:34:22 <Baughn> Well, I suppose the distinction is between O(1) pass constant space, and O(n) pass/above constant space
01:34:29 <quicksilver> why does the runtime symbol linker in tibbe's JS interpreter not count as a second pass?
01:34:35 <tibbe> I only have a vague idea of what I'm talking about and I'm trying to make it more concrete
01:34:38 <ilyak_> Baughn: Static language doesn't need to generate calls assembly that requires pre-declared functions
01:34:43 <quicksilver> and therefore invalidate their claims that its one-pass?
01:34:48 <ilyak_> It only needs it if you want to do some type-casting
01:34:53 <Baughn> Two-pass is fine, but writing a compiler that may need an arbitrary number of passes is not?
01:34:58 <ilyak_> And you do, because C have so many different-sized ints
01:35:12 <tibbe> quicksilver: you could of course count it as another pass but I'm kinda making the distinction between the compiler / interpreter at the point where the bytecode is created
01:35:23 <ilyak_> If you had a 64bit byte, you can go without pre-declarations and still be fine
01:35:26 <Baughn> ilyak_: How is C going to call int foo(char bar) if you've just said foo(42) and it hasn't seen the declaration yet?
01:35:37 <Baughn> ..
01:35:43 <quicksilver> promotion.
01:35:44 <ilyak_> Baughn: That's what I tell you about: it needs to do some casting
01:35:51 <quicksilver> it calls int(int bar)
01:35:52 <ilyak_> if sizeof(char) == sizeof(int), it could
01:36:05 <ilyak_> Just stick it there and do the call
01:36:08 <Baughn> ilyak_: At runtime?
01:36:12 <quicksilver> old C compilers worked by promotion.
01:36:16 <ilyak_> Baughn: Why, at compile-time
01:36:27 <Baughn> ilyak_: Can't promote it without knowing what it is
01:36:34 <quicksilver> you promote everyting to int.
01:36:48 <Baughn> And what if it's really supposed to be a char?
01:37:00 <quicksilver> then you have to use prototypes, yes :)
01:37:16 <ilyak_> Baughn: If sizeof(char) = sizeof(int) = sizeof(float) = sizeof(void*), you can
01:37:23 <ilyak_> You don't need to cast
01:37:26 <Baughn> ilyak_: You're not allowed to assume that
01:37:31 <ilyak_> Of course
01:38:00 <ilyak_> But if you could, you could compile in one pass without pre-declarations
01:38:01 <luqui> a compiler is allowed to assume that
01:38:27 <ilyak_> Well, that would be a weird compiler
01:38:31 <ilyak_> Operating on weird C
01:38:44 <ilyak_> I guess they will make the byte 64-bits in something like 20 years
01:38:55 <ilyak_> Because that will solve half of low-level pains, forever
01:38:59 <Baughn> Can't. Backwards-compatibility.
01:39:12 <Baughn> We will _never_ be free of ancient broken code
01:39:18 <ilyak_> Baughn: Well, you can compile linux with such compiler, and it will work
01:39:25 <ilyak_> Maybe with some tweaks tho :)
01:39:29 <ilyak_> Not too big.
01:39:39 <ilyak_> And also everything, even legacy, if it's in C
01:40:07 <ilyak_> And you can compile JVM with it, after which you'll get a huge pile of steaming software up and running
01:40:13 <luqui> if it's in *well-written* C
01:40:19 <ilyak_> luqui: yeah.
01:40:23 <Baughn> Thus my claiming it's /broken/ C
01:40:24 <cybereal> Baughn: hypervisors and emulation will easily eliminate that problem
01:40:30 <ilyak_> Might require some tweaks, I say
01:40:47 <Baughn> cybereal: Actually, I'm thinking in 20 years we'd rather fab a couple x86 coprocessors to deal with the problem
01:40:57 <Baughn> Hypervisors are a strictly temporary measure
01:41:00 <tibbe> thanks for the help guys
01:41:03 <tibbe> I'm back to work
01:41:20 <cybereal> Baughn: more likely, just send the x86 programming to one of the 256 programmable SPE's :)
01:41:39 <Baughn> cybereal: *20* *years*. If you think we still won't have nanofactories by then...
01:41:48 <Baughn> Now, in eight years you might have a point
01:42:27 <luqui> *20* *years*, we'll have sucked our own civilization into a black hole in the GREATEST WAY TO GO EXTINCT EVER!
01:42:39 <Baughn> luqui: ..how?
01:42:45 <luqui> international supercollider
01:42:50 <ilyak_> luqui: Well, i doubt, because if it's a way to go, then we're not the first who'll do that
01:42:56 <Baughn> luqui: No such thing. You mean the LHC?
01:43:07 <luqui> yeah
01:43:12 <luqui> haven't really been following it to be honest
01:43:22 <ilyak_> And they will say "Ehh, yet another idiot civilisation screwed up" upon detecting gravity waves
01:43:25 <Baughn> luqui: Sadly, even if everything we know about science is wrong and it manages to create stable black holes, it'll take centuries for it to even become noticable.
01:43:48 <luqui> I just know I would be proud to be a member of a species which causes itself to go extinct because it accidentally created a black hole.
01:43:51 <cybereal> Baughn: pfft like the fearloving human condition will be able to get past unfounded grey goo panic :)
01:43:52 <luqui> you and your "science"!
01:43:59 <Baughn> Which is doubtful, since we've almost certainly already created black holes in the lab. That promptly blew up.
01:44:11 <ilyak_> I guess they can just take that black hole and evacuate it with a rocket
01:44:25 <ilyak_> It wouldn't be that dangerous having same gravity as an apple
01:44:35 <Baughn> ilyak_: Mosquito, at LHC energies
01:44:57 <Dzlk> luqui: Agreed. Of all the ways this species might cause itself to go extinct that one's the most noble by far :)
01:45:17 <Baughn> Essentially no gravity, and small enough it could pass right through a proton without having a significant chance of eating it - never mind that atoms are mostly empty space
01:45:53 <cybereal> yeah totally safe, someday everyone's kid will have his own black hole as a pet, and eventually flush it down the toilet when it gets too large to feed
01:45:57 <ilyak_> If they evaporate, really, then it wouldn't exist
01:45:57 <cybereal> err wait...
01:46:12 <Baughn> Dzlk: No, the price for that has to go to creating a grey goo strangelet (blow up the galaxy, eventually) or getting a vacuum-energy chain-reaction from trying to exploit it (destroy the universe, at the speed of light)
01:46:12 <ilyak_> Because it will have a lifespan much shorter than planck time
01:46:26 <ilyak_> 10^-30 times shorter
01:46:33 <Baughn> ilyak_: They don't evaporate /that/ fast. Do your math.
01:46:42 <ilyak_> Baughn: They do.
01:46:50 <luqui> evolution will take care of grey goo.  It won't blow up the galaxy, it will become an awesome lifeform that thrives...
01:46:58 <ilyak_> You can do the math yourself with octave and some googling
01:47:22 <ilyak_> Life time is ~ m^3
01:47:45 <ilyak_> As mass decreases, life time becomes ridiculously short
01:48:10 <ilyak_> And you need it to be 30grams to live 1 second.
01:48:21 * luqui would do the math, if he knew the math to do...
01:48:24 <Dzlk> Hm. Wasn't there a list of ways to destroy the universe on the web somewhere?
01:48:55 <Botje> somewhere out there is a bottom waiting for us to evaluate it.
01:49:05 <luqui> and by rule 34, there is porn of destroying the universe
01:49:13 <Baughn> ilyak_: So.. if 30 grams means one second.. then how does ~30 times less than that (mosquito) become 10^-30 seconds?
01:49:29 <luqui> there is definitely porn of a bottom waiting to be "evaluated"
01:49:40 <Baughn> Botje: Naked singularity?
01:49:55 <Baughn> I keep thinking there should be "singularity = undefined" in the universe's source code somewhere
01:50:22 <Botje> Baughn: no thanks, it's rather cold :p
01:50:24 <luqui> singularity = error "TODO"
01:51:55 <cybereal> If the singularity ever exists then that disproves time travel implicitly.
01:52:08 <Dzlk> Oh, here we go. http://www.livescience.com/technology/destroy_earth_mp-1.html
01:52:08 <lambdabot> Title: Top 10 Ways to Destroy Earth | LiveScience
01:52:14 <Baughn> cybereal: How, now?
01:52:15 <ilyak_> Baughn: Well, 30 times ^ 3 is a lot
01:52:22 <Baughn> Dzlk: Ah, wrong site. :P
01:52:30 <ilyak_> Also, it can't do one gramm. LHC can't do one gramm in one collision
01:52:36 <ilyak_> It can't even do milligramm
01:52:40 <Baughn> > 30 ^ 3
01:52:42 <lambdabot>  27000
01:52:47 <Baughn> Not that much
01:53:02 <cybereal> Baughn: because clearly it would seek to preemptively stop all the problems it's created to deal with and at some point it'll be smart enough to figure out time travel if it's even possible :)
01:53:05 <Baughn> ilyak_: ALso, I'm almost certain they used "mass-energy of a mosquito" in a quote somewhere
01:53:08 <ilyak_> Baughn: LHC don't have energies to produce 1 gram of matter in one collission
01:53:24 <ilyak_> Baughn: Well, there is an official data on it.
01:53:27 <cybereal> Baughn: I keed of course, I ahve a friend who works for a research group whose primary goal is that singularity :)
01:53:28 <ilyak_> Look it up and do the math
01:53:42 <cybereal> they sell their discoveries as products on the side to fund the research
01:53:43 <Baughn> ilyak_: Even if it's a milligram, it's /still/ ~10^37 times more than a planck second
01:53:49 <ilyak_> It was something like 150 Tev
01:54:09 <ilyak_> > 30000 ^ 3
01:54:10 <lambdabot>  27000000000000
01:54:23 <ilyak_> It should really do sci notation
01:54:29 <Dzlk> Baughn: No, It's the list I remembered, I just misremembered the scope of destruction. ;)
01:54:33 <luqui> > 30000.0 ^ 3
01:54:37 <lambdabot>  2.7e13
01:54:41 <Botje> okay, three hours of sleep is _NOT_ enough to get discussions about high energy physics
01:54:55 * Botje goes back to doing the impossible in haskell
01:55:12 <ilyak_> 14 TeV per collision
01:55:14 <Baughn> Dzlk: http://qntm.org/ <-- Then have a better list
01:55:15 <lambdabot> Title: Main @ Things Of Interest
01:55:32 <ilyak_> That isn't much mass really
01:55:43 <Baughn> Dzlk: Oh, wait. That's still another site.. it just has geocide. And lots of good SF.
01:58:31 <Dzlk> Baughn: Looks interesting nonetheless. I'm poking around in Miscellaneous, Etc.
01:59:31 <Baughn> Dzlk: "Every year one human is struck by lightning and acquires superhuman powers. Each superhuman is twice as strong as the one before. It has now been ten years." <-- This has to rank as among the best opening blurbs yet
01:59:53 <Dzlk> Ooh.
02:00:42 <Baughn> http://qntm.org/?responsibility <-- Or here, a good reason not to build infinitely powerful computers
02:00:43 <lambdabot> Title: I don't know, Timmy, being God is a big responsibility @ Things Of Interest
02:02:33 <Baughn> Or how about a race of radio-sensitive aliens destroying humanity to stop the pollution?
02:04:38 <ilyak_> Baughn: Well, they better hand us some optic cables
02:04:54 <ilyak_> We're doing the translation to them just fine
02:04:58 <Baughn> ilyak_: Actually, they tried. Didn't work.
02:05:08 <Dzlk> It occurs to me that if the universe were deterministic, the universe simulator would necessarily result in an infinite recursion.
02:05:09 <Baughn> We just wound up using optic cables /and/ radio
02:05:32 <Baughn> Dzlk: It's an infinitely powerful computer. It does infinite loops in two seconds flat.
02:05:33 <ilyak_> Baughn: Well, they should hand us mesh radionetworking
02:05:39 <ilyak_> Like metro wi-fi
02:05:53 <ilyak_> Because it is at noise-level when seeing from distance
02:05:57 <Dzlk> Baughn: Oh, it's not necessarily a problem. Just an interesting consequence.
02:06:06 <Baughn> Dzlk: Indeed
02:06:20 <ilyak_> While TV translation towers are bright "lights"
02:06:51 <Baughn> Dzlk: One possibility is that, while the universes appear to become more similar as you walk the chain, /eventually/ something causes one of them to not build the computer. They have infinity to choose from, after all.
02:07:24 <Baughn> Although that would interfere with my preferred solution of building a control panel into the simulation, then setting it to run for an infinite amount of time
02:15:15 <Dzlk> Baughn: I just got to the explanation that the universe is computed lazily. That might make a difference somehow.
02:16:29 <Dzlk> Something external affects the data the next state is computed from, and the change propagates down the chain...
02:21:14 <luqui> Baughn , thanks for sharing that story, very cool
02:21:22 <luqui> though it's possible that not building the computer is inconsistent
02:21:27 <luqui> so there are no models of reality in which that happens
02:21:55 <Baughn> luqui: Inconsistent with what?
02:22:08 <luqui> with itself, the same way exists x. x /= x is inconsistent
02:22:37 <Baughn> Well, I suppose since their universe is supposed to be deterministic - and they know the initial conditions - you may very well be right
02:23:10 <Baughn> The only difference would be the depth of recursion, and they can't tell that before building the computer
02:23:15 <luqui> this got me thinking about set theory again...
02:23:33 <quicksilver> careful. Your head may explode.
02:24:07 <Dzlk> I'd been thinking Russell's paradox might apply somehow. (Speaking of set theory.)
02:24:10 <luqui> so there's an infinite *bidirectional* chain of universes which all converged at that point: you build an ultrafilter to select the ones that are consistent with each other and it chooses "reality"
02:24:41 <luqui> but it's definitely bedtime for me.  I will be dreaming of nonstandard models of reality
02:25:34 <Dzlk> One amusing thought is that if the many-worlds hypothesis is true than there's no such thing as fiction. It's all true.
02:26:09 <Baughn> Sure, but some things are less true than others. Harry potter worlds are few and far between.. and likely to stop working at any moment
02:26:43 <Baughn> That's sort of an amusing thought. They wouldn't know, but by far the most likely outcome at any moment is that suddenly, magic doesn't work anymore
02:29:10 <Dzlk> Another way to deal with it is to say that the universe exists but the fiction is an incomplete or inaccurate description. No matter how implausible the story there's always a universe in which the story can *appear* to be true if you get the right elements "wrong".
02:30:03 <Baughn> Sure. I was thinking along the lines that "magic" can work as a pure result of random chance, but that's not going to last
02:30:38 <Baughn> Ghost in the shell, now.. for anything consistent with the laws of physics, like that, you just have to get it right /once/
02:31:09 <pastorn> > sum [1..] == 15
02:31:14 <lambdabot> Terminated
02:31:18 <pastorn> awww
02:31:48 <Baughn> pastorn: Works fine if you instance Num [a]
02:31:57 <pastorn> ah
02:32:18 <sjanssen> Baughn: hmm?  There is no type error in his example
02:32:30 <sjanssen> @type sum [1 ..] == 15
02:32:33 <lambdabot> Bool
02:32:47 <Baughn> sjanssen: I didn't claim there was
02:33:06 <Baughn> Just that [1..] == (15 :: [a]) might actually finish. :P
02:33:11 <sjanssen> Baughn: ah, I just assumed :).  It still won't work due to:
02:33:13 <sjanssen> @src sum
02:33:14 <lambdabot> sum = foldl (+) 0
02:33:21 <Baughn> Ack
02:33:49 <sjanssen> assuming that [a]'s Enum instance produces an infinite list there
02:34:34 <sjanssen> and pastorn left before we could talk about lazy naturals!
02:36:10 <ziman> lazy naturals? :)
02:46:28 <maltem> ziman: Peano numbers with lazy comparison operators
02:46:38 <Dzlk> Hm, now I sort of want to think up various representations of 0.9 + 0.09 + 0.009 ... and try (== 1) on them :)
02:50:06 <mm_freak_work> [ (x,y) | t <- init (tails something), let x = head t, y <- t ]  -- this is the list of all pairs (a,b) with a <= b from the list 'something'
02:50:13 <mm_freak_work> is there a formula for its length?
02:54:17 <maltem> l (l+1) / 2 ?
02:57:59 <Dzlk> Am I the only being in the universe that doesn't think mercaptans smell like garlic?
03:04:19 <dcoutts> there goes the neighbourhood
03:04:28 <Dzlk> Zoiks.
03:05:30 <ivanm> dcoutts: lol
03:11:06 <kaol> is there a DB client library around that uses bytestrings? I'd like to shove data as directly as possible from the DB to a net socket sometimes, without even touching the data
03:12:53 <quicksilver> kaol: sounds like a security risk to me :)
03:14:27 <kaol> how so? Access control has nothing to do with how I process the results of queries.
03:14:59 <quicksilver> I was joking really.
03:15:13 <quicksilver> but I meant vulnerable to SQL injections and stuff like that.
03:15:48 <kaol> I was talking about the outcoming data, not incoming
03:16:30 <Lemmih> kaol: HDBC has bytestring support, I think.
03:17:43 <ilyak_> How does that bytestring thing play along with UTF-8?
03:18:32 <kaol> if the data was stored as UTF-8, it'll still be UTF-8 when it's in the bytestring. I wasn't going to parse or process it but just pass it along to a client.
03:18:39 <ilyak_> I don't see anything about unicode issues in ByteString docs
03:18:49 <ilyak_> And this rarely means that there are no issues :)
03:18:52 <Lemmih> ilyak_: Data.ByteString doesn't deal with encodings.
03:19:02 <ilyak_> Who does?
03:19:06 <kaol> utf-8 conversions come in picture only when you transform it into String or something
03:19:14 <Lemmih> ilyak_: utf8-string
03:20:19 <ilyak_> kaol: Well, that's what I'm interested in: how does it convert a ByteString in utf-8 to String?
03:20:35 <ilyak_> I guess it gets something wrong
03:21:03 <Zao> Fold over it, maybe?
03:21:54 <ilyak_> If it puts each of utf-8 octets in a separate Char then that sounds 'screwed'
03:21:57 <Lemmih> ilyak_: Data.ByteString.UTF8.{fromString,toString}
03:22:03 <ilyak_> Lemmih: Oh, fine then
03:23:12 <Lemmih> There's also Data.CompactString for other encodings than UTF8.
03:31:48 <wvd`> hello
03:32:27 <Lemmih> wvd`: Hi.
03:40:40 <quicksilver> ilyak_: ByteString doesn't deal with unicode. At all.
03:40:51 <quicksilver> ilyak_: the 'Byte' in bytestring indicates it deals with bytes :)
03:41:16 <quicksilver> ilyak_: if you want to view those bytes as some kind of encoding then another layer for that
03:42:37 <hpaste>  mm_freak pasted "Erroneous BitField instance" at http://hpaste.org/8147
03:42:48 <mm_freak_work> see the hpasteâ€¦  what am i missing here?
03:43:05 <mm_freak_work>     Constraint is no smaller than the instance head
03:43:05 <mm_freak_work>       in the constraint: MArray a Bool m
03:43:40 <mm_freak_work> i see that i can fix it with a command line flag, but i'd like to understand
03:45:54 <quicksilver> that instance isn't guaranteed to terminate.
03:46:17 <quicksilver> The simplistic termination condition is that the generated constraint (the instance head) must be smaller than the thing we're trying to solve.
03:46:27 <quicksilver> that's a simplistic condition which guarantees instance selection terminates.
03:49:34 <Botje> anyone familiar with closure conversion as described in compiling with continuations? (or variants thereof)
03:49:44 <mm_freak_work> quicksilver: i understand only half of itâ€¦  could you provide a pointer?
03:50:26 <mm_freak_work> (it's the first time creating a multi-parameter class myself)
03:51:09 <quicksilver> mm_freak_work: unfortunately I'm not familiar with the details of the instance termination conditions :(
03:51:21 <quicksilver> mm_freak_work: and I'm not sure of anywhere where they are nicely explained.
03:51:28 <Botje> I find I have to create closures for functions that don't need any, I can paste a sample if you want
03:52:24 <mm_freak_work> quicksilver: i don't even know what "instance termination" means?  deciding whether a type matches a particular instance?
03:52:42 <quicksilver> mm_freak_work: basically working out the type for a function.
03:52:54 <quicksilver> the conservative assumptions are there to make sure the type-checker is guaranteed to terminate
03:53:00 <quicksilver> (even in the face of buggy programs)
03:53:07 <quicksilver> there are ways to relax it
03:53:32 <quicksilver> some of those ways mean that whilst the type checker will still terminate for correct programs it may not for (particular) buggy ones.
03:54:03 <quicksilver> people tend to like their compiler to finish in finite time
03:54:04 <mm_freak_work> is there anything you could suggest to fix my code?  maybe the fix explains it a bit
03:55:24 <quicksilver> You're trying to say that a 'BitArray a' is a member of the BitField class over the Monad m
03:55:42 <quicksilver> if a is an MArray over m (with Bool elements)
03:55:48 <quicksilver> to me that seems perfectly reasonable.
03:55:55 <quicksilver> your code doesn't look wrong to me.
03:56:09 <quicksilver> it's just that GHC can't see that instance is definitely decidable.
04:13:52 <RayNbow> hmm, Channel 9 video about parallel stuff for .NET 2008... I wonder what it will entail...
04:14:14 <RayNbow> ( http://channel9.msdn.com/shows/Going+Deep/Inside-Parallel-Extensions-for-NET-2008-CTP-Part-1/ )
04:14:15 <lambdabot> http://tinyurl.com/43t84k
04:37:26 <mm_freak1work> quicksilver: could you give me an example of a situation, where this would lead into an infinite loop in the type checker?
04:39:21 <quicksilver> mm_freak1work: no, because it can't :)
04:39:34 <quicksilver> the restriction is a simplification.
04:39:41 <quicksilver> it rules out some things which are, in fact, perfectly safe.
04:39:47 <quicksilver> it's just hard for GHC to *prove* they are safe.
04:40:00 <quicksilver> people have suggested refinements of the criteria I believe
04:41:15 <dcoutts_> dbueno: I discovered that while my solver is pretty good for planning the latest packages for ghc-6.8, it sucks for planning packages for ghc-6.6
04:43:34 <dcoutts_> dbueno: because I go for the latest versions of stuff by default and do not backtrack, so I end up picking the later versions which then end up depending on base > 3 or whatever
04:44:06 <dcoutts_> dbueno: I think I need to do some more bottom up stuff to make better decisions, currently it's pretty much all top-down
04:44:38 <dcoutts_> not a problem for your approach though I expect
04:55:51 <mm_freak1work> quicksilver: thanks, and sorry for bothering you all the time =)
05:20:22 <Saizan> > [1,1] \\ [1]
05:20:26 <lambdabot>  [1]
05:20:26 <hpaste>  mm_freak pasted "Yet another non-functioning sieve of eratosthenes" at http://hpaste.org/8148
05:20:51 <mm_freak1work> have a look at the hpasteâ€¦  lines 22 and 23 cause compiler errors
05:21:07 <mm_freak1work>     Could not deduce (BitField a b1 m)
05:21:07 <mm_freak1work>       from the context (Monad m, BitField a i m, Ix i, Integral i)
05:21:35 <mm_freak1work> could anyone help me?
05:22:28 <Armored_Azrael> Hey, does anyone know how I can interact with C structs?
05:22:39 <Armored_Azrael> (hoping there's a way to cast between them and records)
05:24:03 <Armored_Azrael> Alternatively, is there at least a way to make a data structure of a set size that I don't interact with to allow for opaque structs which are returned as aggregate?
05:26:22 <pejo> Armored_Azrael, isn't there support for it in the FFI?
05:27:12 <Armored_Azrael> I can't find struct support--the FFI just tels me to instead use a pointer to the struct, and make the thing it points at a meaningless data structure.
05:27:22 <Armored_Azrael> However, I'm interfacing with someone else's code so this isn't an option.
05:27:50 <Armored_Azrael> Looking around, it seems like the typeclass storeable might allow me to make arbitrary sized abstract data structures, but I'm not sure if just declaring an instance and overriding the right methods will work
05:27:54 <Armored_Azrael> Will it?
05:28:30 <quicksilver> there is nothing builtin to the FFI to make structs easy.
05:28:39 <quicksilver> There are some tools which do this to a lesser or greater extent.
05:28:49 <quicksilver> hsc2hs, c2hs
05:28:55 <quicksilver> there may be others.
05:31:41 <Itkovian> Armored_Azrael: Can't you put your own stuff in the middle for which you can use the FFI and then go to the existing lib?
05:33:21 <Armored_Azrael> Itkovian: That is a possibility, but that would take a long time--I'm trying to hook haskell up to the SPI for Postgres
05:33:38 <Armored_Azrael> So I could write a bunch of intermediate functions, but there are a whole lot of them.
05:34:22 <Itkovian> Armored_Azrael: fair enough.
05:35:36 <Armored_Azrael> Still lookin into c2hs, etc, but does anyone know if an unboxed tuple in the correct order could mimic a struct layout?
05:41:32 <Itkovian> Armored_Azrael: No idea mate.
05:42:14 <mm_freak1work> i really don't get why it doesn't work =/
05:47:46 <mmorrow> Armored_Azrael: Allthough some may cringe , (since you considered even for a moment the unboxed tuple idea) it'll probably work to import GHC.Storable, then readInt32OffPtr, castPtr, read_OffPtr, castPtr, etc... but dont messup or segfault citay!
05:48:40 <Itkovian> I'm writing (or at least trying to) a wrapper around the Mollom API (http://mollom.com/api). Given the fact that I need to cache (at least locally, preferably in a database) a list (I acquire from the service) of servers I can use for checking if data can be categorised as SPAM, I'm think of using an IORef to store such a list, but I've the feeling there might be better ways.
05:48:46 <mm_freak1work> clearFieldBit bf (n*0)  -- this works, but if i replace (n*0) by 0, it doesn't work anymore
05:49:16 <mm_freak1work> n is of type: (BitField a i m, Ix i, Integral i, Enum i) => i
05:49:54 <mm_freak1work> and clearFieldBit's second argument is of type: Ix i => i
05:50:17 <mm_freak1work> uhm yeah, that might well explain things
05:50:17 <mmorrow> Armored_Azrael: oh yeah, and then you'd have to consider whether the struct is packed of not...
05:50:46 <mmorrow> Armored_Azrael: i'd only try this route if it was between this and it not working at all
05:51:20 <mm_freak1work> it doesn't =/
05:52:37 <Itkovian> I also suspect the IORef should somehow be maintained in the data structure I'm using when accessing the module functions. Yet, reading the example on monads in the realworldhaskell book makes me think I can place that stuff under the hood, yet I fail to grok how. Any suggestions?
05:52:53 <quicksilver> Itkovian: simplistically, you just pass it everywhere as a parameter.
05:53:01 <quicksilver> Itkovian: that's all the reader and state monads are :)
05:53:09 <quicksilver> they just hide the parameter so it doesn't feel like it.
05:53:11 <Itkovian> quicksilver: yeah, but then it's visible from outside the module, no?
05:53:27 <Armored_Azrael> mmorrow: Yeah. c2hs is having a non-exhaustive patterns error, so I'm going to try the other one, then I'll be looking into whether there's a way I can write some C functions for repackaging tuples and chaining things :(
05:53:46 <Itkovian> My brain seems to be unsuited for this kind of stuff :-)
05:53:55 * Itkovian rereads the text
05:54:04 <Socrates> Hmm, for Text.Regex
05:54:12 <Socrates> How do I escape a character?
05:54:29 <Socrates> So, read + as "+" as opposed to 1 or more
05:54:39 <mmorrow> Armored_Azrael: good luck brave knight!
05:55:51 <Socrates> Ag. Nevermind, need to escape the \ first!
05:57:37 <mmorrow> Itkovian: The idiomatic way of getting a global IORef is:
05:57:38 <mmorrow> counter :: IORef Int
05:57:42 <mmorrow> {-# NOINLINE counter #-}
05:57:46 <mmorrow> counter = unsafePerformIO (newIORef 0)
05:58:14 <mmorrow> Itkovian: If you have multiple threads accessing it, probably use an MVar
05:58:40 <mmorrow> counter = unsafePerformIO (newMVar 0)
05:58:53 <mmorrow> counter :: MVar Int
06:00:12 <mmorrow> Itkovian: (Saying nothing about if this is the best option, or even a good one, for your situation)
06:02:09 <Itkovian> Maybe an IORef is the wrong type, and I should just use a state monad.
06:02:17 * Itkovian thinks on it
06:02:18 <quicksilver> mmorrow: that's idiomatic in the same way that using a nuclear bomb is the idiomatic way to open your front door.
06:02:29 <mmorrow> Itkovian: Damn thing wouldn't open!!
06:02:35 <quicksilver> ;)
06:02:38 <mmorrow> heh
06:02:58 <quicksilver> Itkovian: if you're interleaving your code (as a library) with the users code in IO it may be simplest to use an IORef.
06:03:17 <quicksilver> otherwise a state monad explicit or implicit is neater. IMO.
06:03:25 <Itkovian> Well, the functions I'm using would use the XMLRPC lib, so there' definitely IO going on.
06:10:47 <sclv> eh. I don't mind, e.g., database apis where one has to pass the connection explicitly.
06:11:42 <sclv> you can always just hide the internal bits of the list and force someone to pass an opaque connection around.
06:12:29 <hpaste>  mix25 pasted "Correct order???????" at http://hpaste.org/8149
06:12:41 <mix25> Can someone help me please.
06:13:43 <mix25> ??
06:16:03 <Itkovian> mix25: should you not put the where clause with the function you are using it in?
06:16:23 <Itkovian> mix25: i.e., before the last definition of listaIgualAux
06:16:50 <Itkovian> mix25: Otherwise you cannot use x and y in line 3.
06:16:53 <mix25> i put it because i dont know other form to make what i want
06:17:50 <mix25> How to make this then¿?
06:18:10 <Itkovian> mix25: a where clause must follow the definition immediately, so simply remove line 4 and put it as the last line
06:19:09 <mix25> I continue with errors
06:19:37 <mix25> Syntax error in declaration (unexpected `(') line 5
06:21:21 <Itkovian> mix25: yeah well, replace the == by = I'd think in the where clause
06:21:35 <Itkovian> for starters
06:22:02 <mix25> Error in input, unexpected "="  line 6
06:22:10 <mix25> syntax *
06:24:12 <Itkovian> mix25: I'll paste a correction that at least compiles.
06:24:31 <mix25> Ok, thanks
06:25:14 <hpaste>  Itkovian annotated "Correct order???????" with "(no title)" at http://hpaste.org/8149#a1
06:25:49 <Itkovian> mix25: Make sure you have the indentation correct etc.
06:26:59 <Itkovian> mix25: Also remember that function application actually has high precedence and that nub l:ls is not the same as nub (l:ls)
06:27:13 <mix25> hei but this is the same code i pasted ??
06:27:36 <mix25> o sorry i need to refresh
06:27:36 <Itkovian> read on
06:29:24 <Armored_Azrael> Turns out I'm lucky, all of the things the postgres documentation called structs are actually struct pointers when you read the source, making everything fine.
06:29:30 <Armored_Azrael> Thanks for the help anyways guys.
06:29:46 <mix25> Thanks now compile :)
06:30:18 <hpaste>  BMeph annotated "Correct order???????" with "Put the where at the end of the valid definition" at http://hpaste.org/8149#a2
06:39:26 <mm_freak1work> ok, my idea was to create a class BitField for bit fields, so i have some convenient wrapper functions, and so i can do a very efficient bit field implementation later, without changing the interface
06:39:39 <mm_freak1work> unfortunately exactly this wrapping seems to come with a major speed impact
06:39:59 <mm_freak1work> i'm using GHC 6.8.2, is there any solution to this?
06:40:51 <BMeph> mix25: If you do not have the 'where' at the end of the line, the compiler/interpreter sees that the line is a valid expression, and tries to interpret is. It then fails, because you tell it what (x:xs) and (y:ys) mean, but after the line is done.
06:41:12 <BMeph> mm_freak1work: What does your profiling say? :)
06:41:23 <Saizan> mm_freak1work: maybe use SPECIALIZE and/or INLINE pragmas, there's something in the user manual
06:42:34 <mm_freak1work> BMeph: i haven't done any profiling, but unwrapping makes a speed increase
06:42:40 <BMeph> mm_freak1work: Of course, if we can't see code, we're just guessing at what you're doing... ;)
06:45:35 <hpaste>  mm_freak pasted "Yet another SoE" at http://hpaste.org/8150
06:45:45 <mm_freak1work> there you go =)
06:47:27 <ziman> forM_ [2..m] $ \i -> do
06:47:30 <ziman> awww
06:47:39 <ziman> that looks soooo imperative :)
06:48:06 <mm_freak1work> it is quite imperative, because i want an efficient implementation
06:48:16 <mm_freak1work> and the sieve of eratosthenes is an imperative thing anyway
06:48:45 <mm_freak1work> a declarative description of the SoE is quite obscure
06:52:10 <mm_freak1work> it's curious that (shiftR n 1) is less efficient than (div n 2)
06:56:43 <Saizan> > let sieve (x:xs) = x: sieve (filter (\n -> n `mod` x /= 0) xs) in sieve [2..]
06:56:44 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:56:58 <vixey> > extendSequence [2,3,5,7]
06:57:03 <lambdabot>  Exception: recv: resource vanished (Connection reset by peer)
06:57:07 <mm_freak1work> Saizan: that's not the sieve of eratosthenes
06:57:24 <vixey> > extendSequence [2,3,5,7]
06:57:24 <mm_freak1work> it's actually not a sieve at all =)
06:57:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:57:53 <vixey> looks like a seive to me
06:59:48 <mm_freak1work> vixey: it's a filterâ€¦  the sieve works differently
07:00:17 <mm_freak1work> and i wouldn't expect it to give me the first 100000 primes in less than a second
07:00:21 <mm_freak1work> the sieve does
07:07:21 <tromp> see http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
07:07:21 <lambdabot> Title: [Haskell-cafe] Re: Genuine Eratosthenes sieve [Was: Optimization fun], http://tinyurl.com/yphbu2
07:10:10 <nothingmuch> i am going to give a talk at YAPC::EU::2008
07:10:14 <nothingmuch> "What haskell did to my brain"
07:10:28 <nothingmuch> trying to summarize lessons learned about thinking... "differently", after having learnt haskell
07:10:43 <nothingmuch> anyway, please give me horror stories =)
07:10:48 <nothingmuch> i started taking ritalin
07:10:59 <nothingmuch> audreyt became became a woman
07:11:04 <BMeph> nothingmuch: So, how long is the talk explaining what you did to your brain before Haskell? ;)
07:11:16 <nothingmuch> brief history ;-)
07:11:38 <nothingmuch> how i started programming (javascript on DOM... *shudder*, how i discovered perl, how i discovered SICP)
07:12:00 <nothingmuch> i want a sort of dossier
07:12:03 <nothingmuch> "haskell casualties"
07:13:23 <edwardk> nothingmuch: heh. there are quite a few alternative lifestyles in the Haskell community, but I think its more that people who are more open to alternatives are more open to radically different ways to think about programming.
07:14:32 <qwr> nothingmuch: you skipped C++? ;)
07:14:50 <edwardk> I mean, shapr, a kid from Alabama wound up spending 7 years near the arctic circle in sweden.
07:14:50 <nothingmuch> qwr: i actually got paid to code C++
07:14:54 <nothingmuch> without knowing it
07:14:56 <nothingmuch> oh right
07:15:08 <nothingmuch> and my employer knew I didn't know C++ either
07:15:11 <nothingmuch> strange
07:16:47 * Itkovian fiddles on with his Mollom module.
07:17:16 <nothingmuch> shapr: can I make fun of you in my slides?
07:17:36 <osfameron> I've managed to skip C++ quite successfully so far...
07:18:14 * quicksilver hides some particularly heavy C++ under a temptingly kickable hat and puts it in osfameron's path.
07:18:21 <ivanm> edwardk: but what has that got to do with haskell? he studies in the netherlands?
07:18:26 <osfameron> ooo!  a hat!
07:19:08 <nothingmuch> quicksilver: kudos on your originality, most people would just put in a paper bag on osfameron's door step
07:19:27 <ivanm> osfameron: as have I! \o/
07:19:36 * ivanm is coding in Fortran atm though 
07:20:02 <olsner> if there was a god he'd have deprecated fortran ages ago
07:20:13 <edwardk> ivanm: shapr?
07:20:25 <ivanm> olsner: fortran 90/95/2003 that is
07:20:29 <nothingmuch> i thought shapr was back in US & A
07:20:31 <edwardk> ivanm: he started a little irc channel you might have logged into once or twice
07:20:38 <edwardk> nothingmuch: yeah he's here working for me in boston
07:20:42 <ivanm> IMHO, F90, etc. > C
07:21:00 <ivanm> edwardk: yes, but what has the arctic circle got to do with it? study?
07:21:43 <nothingmuch> ivanm: i think he just liked swedish girls or sth
07:21:49 <ivanm> ahhh
07:22:27 <nothingmuch> and shae is a pretty cool name, you must admit
07:22:29 <ivanm> (as it stands, the only reason I'm coding in Fortran is that ghc doesn't seem to be installed on the SGI supercomputers I'm using to do parallel programming on)
07:22:35 <ivanm> nothingmuch: true
07:22:36 <edwardk> ivanm: i was basically trying to say that the kind of people who are willing to go off and do something very different with their lives tend to be predisposed to strange language features like laziness. ;)
07:22:37 <nothingmuch> plus his blog is scannedinavian
07:22:40 <nothingmuch> awesome pun
07:22:51 <nothingmuch> there's these birds in a scanner
07:23:06 <sclv> hmm.. what's the name for a path/context dependent catamorphism?
07:23:15 <ivanm> edwardk: ahhh.... I thought you might have meant that he went to study at ulrecht or something
07:23:45 <sclv> or is that just a normal one.
07:23:48 <edwardk> path/context dependent? you mean path from the 'inside' or path from the 'outside'?
07:23:53 <nothingmuch> sclv: zipper?
07:23:57 <edwardk> histomorphism and paramorphism are both 'context' dependent
07:24:25 <sclv> not quite sure what inside and outside mean in this context
07:24:39 <edwardk> paramorphism gives you the power to rederive general recursion, because you can 'have your result and eat it too'
07:24:53 <sclv> what if its dependent on both?
07:25:42 <edwardk> sclv: then you need a compsite distributive law and you just have a generalized catamorphism built over a comonad that provides both pieces of functionality
07:25:44 <Itkovian> nothingmuch: shapr's blog moved afaik to http://shae.livejournal.com/
07:26:04 <nothingmuch> that explains why I haven't heard in a long while ;-)
07:26:26 <nothingmuch> oi, /blog now 404s
07:26:27 <sclv> what I have is a "map" dependent on both the path to each leaf plus some of the information in each leaf.
07:26:31 <nothingmuch> my rss client sucks, why didn't it tell me
07:27:04 <monochrom> "hello, new news item today: I suck! :) " ?
07:27:18 <sclv> (and actually there's a context-dependent comonadic bit for the broader context, but i'm passing that in.)
07:27:21 <edwardk> sclv: what you can do is in category-extras terms you can define your whatevermorphism as a paramorphic histomorphism by using the ParaT combinator and the distParaT and distHisto combinators to build up the law
07:27:39 <edwardk> g_cata (distParaT (distHisto id)) would have the properties you want
07:28:28 <sclv> hmm.. I'm just building this up by hand, for the moment. just wanted to generalize what I'm doing in my head a bit. (it's just a frikin menu system for a website! man this stuff comes up everywhere :-))
07:29:34 <monochrom> sclv: don't forget to look at algebraic topology   <duck>
07:30:22 <edwardk> The path to get 'down' to a node is very hard to get access to thinking in this form. maybe what you really want is to turn this inside out and build up an output structure anamorphically...
07:30:26 <edwardk> consuming your existing structure and generating a structure which has the path baked into the anamorphism seed
07:30:31 <monochrom> "sheafification of co-lax functors for web menus"
07:30:49 <EvilTerran> ...what
07:31:04 <sclv> edwardk: I think I'm doing that actually...
07:31:15 <sclv> its a pretty good lightweight real-world example of values in context though, because of course you want to display other portions of the menu, and operate on the path through the menus to where you are, etc.
07:32:00 <edwardk> (heh, i had forgotten that I had written distParaT, its nice when you go 'oh crap I'm going to have write... oh wait there it is...) =)
07:32:17 <sclv> the advantage is you build a single structure that contains both the navigation to an item, and the way to render that navigation, and get everything all in one place.
08:00:47 <mix25> how can i print a partial result of my function ?
08:01:43 <monochrom> sorry, can't be printed in general
08:01:57 <mix25> damn
08:02:00 <byorgey> mix25: depends what you mean
08:02:22 <mix25> I want to see what exactly is doing my function
08:02:38 <tromp> try a debugger
08:02:47 <monochrom> use a logic probe  <duck>
08:02:56 <mix25> huh
08:02:59 <byorgey> mix25: the ghci debugger might be helpful.
08:03:19 <byorgey> @where Monad.Reader
08:03:19 <lambdabot> I know nothing about monad.reader.
08:03:24 <byorgey> @go Monad.Reader
08:03:25 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
08:03:25 <lambdabot> Title: The Monad.Reader - HaskellWiki
08:03:50 <byorgey> mix25: there was a tutorial about getting started using the ghci debugger in the latest issue of the Monad.Reader
08:03:56 <byorgey> see the link above
08:04:18 <mix25> aha thanks
08:05:07 <byorgey> mix25: note, however, that the whole notion of 'stepping' through a function's execution is a bit trickier in Haskell than in an imperative language.
08:05:14 <smg> hello
08:05:21 <byorgey> hey smg
08:05:57 <byorgey> mix25: is your function giving incorrect output and you're not sure why?
08:06:18 <mix25> yes , i'm not sure if recieve correct arguments
08:07:12 <byorgey> mix25: have you been using ghci to test each function in your program by itself?
08:07:26 <mix25> because is returning incorrect values
08:07:28 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8152
08:07:37 <mix25> i'm see the link above
08:07:39 <smg> http://hpaste.org/8152
08:07:42 <mix25> seeing*
08:07:43 <smg> someone look that paste
08:07:47 <smg> c and g are FREE variables
08:07:49 <smg> am i right?
08:07:50 <byorgey> generally, rather than using the debugger, I find it much more effective to make sure my program is broken down into many simple functions, then test each one by itself in ghci
08:08:06 <monochrom> yes smg
08:08:10 <jkff> mix25: have you tried Debug.trace?
08:08:15 <mix25> i'll try
08:08:21 <mix25> still no
08:08:45 <jkff> Well, it's easier to use than the ghci debugger and may turn out to be sufficient, good luck :)
08:09:20 <smg> monochrom: ghci tells me c,g and u is free :|
08:09:59 <byorgey> smg: ah, u is free also
08:10:05 <byorgey> (the u in the third line)
08:10:18 <byorgey> note the u on line three is a completely different one than on line 1
08:10:28 <byorgey> the scope of the u on line 1 is just inside those parentheses
08:11:12 <monochrom> what byorgey says
08:11:24 <smg> byorgey: mh damn
08:11:32 <smg> i have an error in my calculations
08:11:32 <smg> bad :|
08:11:35 <byorgey> hehe
08:17:05 <Maciej> Can anyone tell me how to read data from a handle returned by Graphics.Win32.GDI.Clip.getClipboardData?
08:20:00 <quicksilver> a handle is just a Ptr
08:20:39 <quicksilver> if you think you know what the data is, just read it off the Ptr
08:21:07 <Maciej> It's defined HANDLE = Ptr ().
08:21:21 <quicksilver> Yes, you can cast it to anything else though.
08:21:33 <smg> byorgey: do you want to see?
08:21:39 <quicksilver> use castPtr
08:21:40 <Maciej> But how do I know the size of the data?
08:21:45 <quicksilver> I have no idea
08:21:48 <quicksilver> ask a windows developer?
08:21:51 <byorgey> smg: see what?
08:21:58 <quicksilver> how would the corresponding windows program know the size?
08:22:39 <Maciej> I have no idea, never done something like this.
08:22:57 <quicksilver> You will have to look up the windows documentation
08:23:23 <quicksilver> I'm sure we can help you translate it to haskell when you've looked it up
08:25:11 <Maciej> Okay, I'll have a look to the Win docs.
08:30:15 <dons> i think this is newsworthy, http://reddit.com/info/6maq5/comments/
08:30:16 <lambdabot> Title: reddit.com: BLAS for Haskell: new library for scalars, vectors, matrices and lin ...
08:30:29 <smg> byorgey: calculation :P
08:31:43 <cnwdup> @src isElem
08:31:43 <lambdabot> Source not found. Where did you learn to type?
08:32:39 <cnwdup> :t elem
08:32:41 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:34:43 <byorgey> smg: oh, sure
08:35:50 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8153
08:35:55 <smg> http://hpaste.org/8153 byorgey
08:35:57 <quicksilver> Maciej: it might be more pleasant to use a cross platform library which supports the clipboard
08:36:05 <quicksilver> Maciej: WX and GTK spring to mind,
08:36:06 <smg> maybe it's somehow conflicting at some points because i used no parenthesis
08:37:33 <monochrom> lengthy calculation!
08:38:08 <lilac> what is FV?
08:38:15 <monochrom> "free variables"
08:38:37 <monochrom> FV(\u -> u f o) = what are the free variables of \u -> u f o ?
08:38:55 <tromp> @src elem
08:38:55 <lambdabot> elem x    =  any (== x)
08:39:30 <smg> monochrom: f o
08:39:56 <tromp> i'd write that as elem = any.(==)
08:40:10 <smg> tromp: to make it pointless (free) :)
08:40:10 <tromp> (different section though)
08:40:13 <Deewiant> it would generate different code
08:40:14 <monochrom> You can envision a recursive formula for finding free variables. That's what the paste does.
08:40:34 <Deewiant> which may be the reason why it isn't written such
08:40:43 <BONUS> why does length return an Int by default and not Num a
08:40:58 <tromp> dont see why (==x) is preffered over (x==)
08:40:59 <Deewiant> optimization, probably
08:41:08 <monochrom> because Data.List.genericLength return Integral a.
08:41:18 <BONUS> yeah i know that but like
08:41:18 <Deewiant> I didn't mean that, I meant pointlessness vs. pointyness
08:41:20 <BONUS> why
08:41:40 <Maciej> quicksilver: I think gtk2hs does not support clipboard functions (yet).
08:42:03 <byorgey> BONUS: because it is retarded
08:42:25 <Deewiant> it dates from a time before type classes?
08:42:32 <smg> why you would return Num a?
08:42:39 <Deewiant> (and before Integer, even?)
08:42:39 <smg> can i list have 2.5 elements?
08:42:40 <Saizan> Deewiant: no
08:42:40 <BONUS> ah i see
08:42:41 <smg> no :]
08:42:43 <byorgey> smg: much more general
08:42:52 <smg> but Num is also Fractional?
08:42:57 <monochrom> length should return Monoid a
08:42:59 <byorgey> smg: no
08:43:03 <smg> no?
08:43:08 <smg> Num is not 2.5 for example?
08:43:12 <Deewiant> @ty 2.5
08:43:13 <tromp> the question is why we need length in addition to genericLength
08:43:14 <lambdabot> forall t. (Fractional t) => t
08:43:17 <smg> ah
08:43:20 <smg> @t 2
08:43:20 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:43:24 <smg> @ty 2
08:43:25 <lambdabot> forall t. (Num t) => t
08:43:28 <smg> ahh
08:43:33 <smg> no i'm enlightened
08:43:35 <smg> now.
08:44:03 <monochrom> We don't need anything.
08:44:14 <smg> @ty length
08:44:15 <lambdabot> forall a. [a] -> Int
08:44:17 <byorgey> smg: you're right that Double is an instance of Num, though
08:44:23 <tromp> @src genericLength
08:44:23 <lambdabot> genericLength []    = 0
08:44:23 <lambdabot> genericLength (_:l) = 1 + genericLength l
08:44:23 <Deewiant> @src Fractional
08:44:23 <lambdabot> class  (Num a) => Fractional a  where
08:44:24 <lambdabot>     (/)             :: a -> a -> a
08:44:24 <lambdabot>     recip           :: a -> a
08:44:25 <lambdabot>     fromRational    :: Rational -> a
08:44:31 <byorgey> @type genericLength
08:44:33 <lambdabot> forall b i. (Num i) => [b] -> i
08:45:23 <tromp> @src length
08:45:23 <lambdabot> Source not found. :(
08:47:16 <tromp> @let length = foldr (const (1+)) 0
08:47:17 <lambdabot> Defined.
08:47:34 <tromp> :t length
08:47:35 <lambdabot>     Ambiguous occurrence `length'
08:47:35 <lambdabot>     It could refer to either `L.length', defined at <local>:2:0
08:47:35 <lambdabot>                           or `Data.List.length', imported from Data.List at State/imports.h:22:0-33
08:47:52 <tromp> @src Data.List.length
08:47:52 <lambdabot> Source not found. You type like i drive.
08:47:57 <myxie> :t L.length
08:47:59 <lambdabot> forall a t. (Num t) => [a] -> t
08:52:25 <wolverian> my wish for today: ship cabal-install with ghc 6.10
08:52:43 <quicksilver> dcoutts: is this true? gtk2hs does not support clipboard?
08:52:55 <dcoutts> quicksilver: partial support in the darcs version
08:53:11 * dcoutts pushes a Cabal-1.4 and cabal-install release candidate
08:53:39 <dcoutts> wolverian: perhaps you could help test the RC's, I'll ping you when they're both up
08:54:04 <quicksilver> Maciej: partial support in darcs gtk2hs, apparently. WX supports it.
08:54:38 <dcoutts> it depends what aspect of clipboard you want
08:56:05 <wolverian> dcoutts, gladly
08:56:09 <wolverian> thanks :)
08:57:08 <Maciej> dcoutts: I want to store and read a user defined data.
08:59:23 <dcoutts> Maciej: I see, I don't think we have support for that yet. If you want to use gtk2hs you could bind the functions you need and send us a patch.
09:00:21 <quicksilver> Maciej: what's the point of using the clipboard for a user defined data?
09:00:28 <quicksilver> Maciej: surely no other application will be able to read it?
09:01:22 <rtra_> where can I find detailed doc. on prelude functions?
09:01:26 <Maciej> dcoutts: Does gtk2hs support simple clipboard formats i.e taxt data?
09:01:29 <smg> haskell.org
09:01:47 <rtra_> for instance, I'm surprised that 'max' doesn't apparently work with negative integers
09:01:49 <BONUS> also handy: http://www.haskell.org/onlinereport/standard-prelude.html
09:01:49 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
09:02:04 <ziman> > max (-3) (-5)
09:02:05 <lambdabot>  -3
09:02:14 <rtra_> oh. thanks :-)
09:02:44 <smg> rtra_: is that wrong for you?
09:02:48 <Maciej> quicksilver: I want to read data from a program that has it's own format, modifiy it and store back to the clipboard.
09:02:48 <smg> -3 is greater than 5
09:02:50 <smg> -5
09:02:58 <quicksilver> Maciej: ah, a different program not yours?
09:03:04 <quicksilver> Maciej: this makes more sense :)
09:03:10 <ziman> rtra_, did you run into a precedence problem?
09:03:14 <ziman> > max -3 -5
09:03:14 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
09:03:33 <rtra_> i started reading yaht this afternoon
09:05:22 <dcoutts> Maciej: not at the moment, but it should be trivial to bind gtk_clipboard_set_text if you need it
09:06:53 <byorgey> rtra_: welcome! =)
09:08:37 <smg> haskell ftw :)
09:08:39 <rtra_> byorgey: the haskell community seems to be more productive on practical code than the CL one. I had to see what's going on.
09:08:46 <Maciej> dcoutts: I think simple text would not be sufficient for my problem but I didn't find any clipboard functions in the docs.
09:08:57 <smg> CL?
09:09:01 <rtra_> Common Lisp
09:09:01 <quicksilver> rtra_: ironic that a lisper missed out the parentheses :P
09:09:16 <quicksilver> > ((max (-3) (-5))
09:09:16 <lambdabot> Unbalanced parentheses
09:09:20 <quicksilver> ;)
09:09:31 <smg> haha
09:09:33 <quicksilver> but seriously - is a bit of a wart :(
09:09:38 <smg> wart?
09:09:40 <Swap007> @source map
09:09:40 <lambdabot> map not available
09:09:40 <quicksilver> stupid prefix operator
09:09:45 <quicksilver> in a language full or binary operators
09:10:42 <byorgey> rtra_: for sure.  Hope you'll find some things to interest you.  Feel free to ask in here if you come across any more questions.
09:11:17 <Swap007> > 1+1
09:11:18 <lambdabot>  2
09:11:23 <smg> (+) 1 1
09:11:26 <smg> > (+) 1 1
09:11:27 <lambdabot>  2
09:11:32 <smg> > 1 `plus` 1
09:11:32 <lambdabot>   Not in scope: `plus'
09:11:38 <ziman> > ((+) 1 2)
09:11:39 <lambdabot>  3
09:11:41 <dcoutts> Maciej: it's possible to use (many) standard and custom types, just needs the functions to be bound
09:11:42 <ziman> ;)
09:11:51 <dcoutts> Maciej: we'd want to bind gtk_clipboard_set_with_data
09:11:52 <smg> (+1) 1
09:12:49 <dcoutts> wolverian: would you mind checking http://haskell.org/cabal/release/rc/Cabal-1.3.12.tar.gz and http://haskell.org/cabal/release/cabal-install-0.4.9.tar.gz
09:13:08 <dcoutts> wolverian: if they build for you I'll announce them as release candidates
09:14:10 <wolverian> dcoutts, sure, sec
09:14:13 <byorgey> haha, http://www.lefthandedtoons.com/245/
09:14:15 <lambdabot> Title: Left-Handed Toons (by right-handed people)
09:14:34 <byorgey> now imagine listening to techno... while programming in Haskell!  100x productivity increase, for sure.
09:17:42 <smg> lol
09:17:54 <olsner> otoh, with haskell, you can afford listening to slow music :)
09:21:56 <DRMacIver> I have to admit, I was expecting the BLAS library to be a bit crap, but it actually looks really nice. Has anyone used it?
09:23:48 <wolverian> dcoutts, when building cabal-install: Could not find module `Hackage.Reporting':
09:24:04 <dcoutts> wolverian: doh
09:24:04 <dcoutts> 'k
09:24:14 <wolverian> :)
09:26:36 <mxc> do comments starting with --! have special meaning?
09:26:58 <dcoutts> mxc: not to Haskell, perhaps to some other pre-processor
09:27:04 <dcoutts> wolverian: ok, tarball updated, try it now.
09:27:32 <ddarius> :t let (--!) = (+) in (--!)
09:27:32 <dcoutts> wolverian: thanks for doing the brown paper bag testing :-)
09:27:34 <lambdabot> parse error (possibly incorrect indentation)
09:27:38 <mxc> right, was wondering if they do to ghc, haddock, or any of the common ones
09:28:03 <dcoutts> mxc: oh, ddarius is right, --! is an operator, not a comment
09:29:50 <wolverian> dcoutts, some warnings in build, builds fine though
09:30:17 <wolverian> seems to work
09:30:23 <wolverian> testing installing :)
09:30:36 <Deewiant> > let (--!) = (+) in 1 --! 2
09:30:36 <lambdabot> Unbalanced parentheses
09:32:23 <dcoutts> wolverian: the warnings are ok
09:32:47 <wolverian> dcoutts, installed 'blas' and its dependencies fine ... a test suite would be nice of course :)
09:38:24 <greenrd> conal: I've read your ICFP08 paper on FRP, and some other FRP papers. Any comments on FRP versus other approaches for formally modelling interactive systems, such as TLA+?
09:42:43 <gubagem> isn't return blah an expression?
09:43:06 <gubagem> > return "hello"
09:43:07 <lambdabot>   add an instance declaration for (Show (m [Char]))
09:43:16 * gubagem goes mmmmm
09:45:16 <jcreigh> :t return
09:45:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:45:25 <ziman> > return "hello" :: [[Char]]
09:45:27 <lambdabot>  ["hello"]
09:45:29 <jcreigh> return is a function that lifts a value into a monad.
09:46:10 <smg> interesting
09:46:21 <smg> that monad stuff is quite elegant
09:46:25 <jcreigh> > return 42 :: Maybe Int
09:46:26 <lambdabot>  Just 42
09:46:29 <jcreigh> > return 42 :: [Int]
09:46:31 <lambdabot>  [42]
09:46:47 <smg> return 42,42 :: [[Char]]
09:46:53 <smg> > return 42,42 :: [[Char]]
09:46:54 <lambdabot>   parse error on input `,'
09:47:02 <smg> > return 42 :: [Char]
09:47:02 <lambdabot>   add an instance declaration for (Num Char)
09:47:19 <ziman> smg, 42 has type Num a => a
09:47:33 <smg> :)
09:48:31 <ziman> and you request a monad ([] Char) and return a (Num a => a), so haskell wants to match (Num a => a) against Char
09:50:28 <byorgey> gubagem: to answer your question, yes, return blah is an expression.  Why do you ask? Having trouble with do-notation?
09:53:59 <hpaste>  gubagem pasted "whats wrong with my indentation" at http://hpaste.org/8154
09:54:24 <gubagem> byorgey: yes having problems with do's and indenation
09:54:28 <quicksilver> gubagem: the problem is let and if
09:54:39 <quicksilver> gubagem: you want that if to start 4 spaces to the left
09:54:48 <quicksilver> (it's part of the same block as the let)
09:55:06 <quicksilver> well you have that mistake twice
09:55:13 <quicksilver> because you have two lets and two ifs :)
09:55:27 <quicksilver> gubagem: this is precisely the mistake I corrected you on a couple of days ago! ;)
09:56:19 <Deewiant> vim, at least, indents it like that by default
09:56:28 <Deewiant> which is slightly annoying
09:56:49 <quicksilver> emacs + kuribas indentation for the win!
09:58:35 <ddarius> quicksilver: It's pretty much, if not exactly, the same example
09:59:59 <gubagem> quicksilver: im a slow learner at times
10:00:47 <quicksilver> ;)
10:00:52 <quicksilver> being a slow learner is fine.
10:01:03 <quicksilver> do you understand my explanation though?
10:01:08 <mxc> :t if
10:01:10 <lambdabot> parse error (possibly incorrect indentation)
10:01:12 <quicksilver> you have "let" and "if" in the same do block.
10:01:19 <quicksilver> so they should be at the same indentation as each other.
10:01:22 <gubagem> so i can 'nest' them at the same depth
10:01:23 <mxc> er, nevermind
10:02:19 <ddarius> mxc: if/then/else is syntax, though many people would prefer an 'if' function (at least in addition to if/then/else)
10:02:33 <mxc> yeah
10:02:44 <mxc> if you have a IO Bool its a bit awkawrd
10:02:55 <quicksilver> gubagem: sure. There's no nesting really when they're at the same depth
10:02:56 <quicksilver> but yes
10:03:01 <mxc> isDir <- doesDirectoryExist "dir"
10:03:04 <mxc> if isDir...
10:03:08 <gubagem> well its 'nested' in my head
10:03:19 <mxc> unless there is a better way
10:03:51 <ziman> gubagem, you can still use the let..in notation and then it'll be nested
10:04:28 <gubagem> yea ive done that before but it gets to be like spaghetti after a bit
10:04:30 <ziman> the do-block-specific let-without-in notation is not nested
10:05:07 <mux> ddarius: noone proposed that yet? (I'd call it cond though)
10:07:21 <gubagem> i wouldnt mind a cond construct, though doesnt case..of do about the same thing?
10:09:00 <mux> not quite
10:09:08 <mux> case is about pattern matching, not conditions
10:09:28 <gubagem> is there anything similar to cond other then nesting if's
10:09:41 <ziman> too high amount of lets in a do-block might mean it'd be better to refactor the function and split it into smaller pieces
10:10:10 <mux> I often prefer where to let for aesthetics reasons when possible
10:11:43 <mux> and also, I try to get rid of my if's as much as I can through pattern guards
10:14:12 <Maciej> I once defined a C style if that I prefer to if/then/else: res = p ? x1 % x2
10:14:17 <byorgey> gubagem: yes, guards
10:14:28 <byorgey> foo | cond1  = value1
10:14:33 <byorgey>    | cond2  = value2
10:14:43 <byorgey>     | otherwise = ...
10:14:49 <byorgey> er, those | should be lined up
10:15:13 <byorgey> that assigns one of several values to foo, depending on which of the guard conditions is true
10:15:38 <byorgey> not quite the same thing as case but often can be used in the same way, when you have more than two alternatives you want to distinguish among
10:19:41 <lilac> @pl \p x -> case p x of True -> Just x; False -> Nothing
10:19:42 <lambdabot> (line 1, column 26):
10:19:42 <lambdabot> unexpected ">" or "-"
10:19:42 <lambdabot> expecting variable, "(", operator or end of input
10:19:48 <edwardk> @seen conal
10:19:49 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
10:21:59 <cjay> hmmm.. I have a situation that makes me want to combine Maybe and IO into a new monad, am I doing something wrong?
10:22:30 <edwardk> @where MaybeT
10:22:31 <lambdabot> I know nothing about maybet.
10:22:35 <edwardk> @where+ MaybeT http://www.haskell.org/haskellwiki/New_monads/MaybeT
10:22:36 <lambdabot> I will remember.
10:22:40 <edwardk> check that =)
10:22:42 <olsner> @docs MaybeT
10:22:42 <lambdabot> MaybeT not available
10:22:52 <cjay> thanks :)
10:22:58 <cjay> edwardk++
10:23:01 <edwardk> so, er in short, no you're not crazy =)
10:25:48 <edwardk> Hey has anyone ever seen anything describing any connections between lock-free algorithms and impure lazy algorithms?  I noticed this morning that you should be able to evaluate any lock-free algorithm lazily by its very construction, giving a whole new class of algorithms to play with in a Haskell-like setting.
10:26:08 <RayNbow> the number of up/down votes that reddit reports vary per refresh... lol
10:26:18 <geezusfreeek> edwardk: interesting! and no, i haven't seen anything like that
10:26:27 <edwardk> geezusfreeek: k, then i'll blog about it =)
10:26:44 <edwardk> geezusfreeek: This is sort of a first building block in a much bigger toy =)
10:27:04 <geezusfreeek> edwardk: i look forward to it. i have been working with similar things this week, actually
10:27:09 <edwardk> Anyways, given that if you assume a single processor you can actually change the algorithms, you don't need atomic CAS, just CAS usually.
10:27:42 <edwardk> as because lock cmpxchg is more than you need if you only have a single CPU and laziness causing the 'threading'
10:30:12 <roconnor> okay, now the not only are the programming reddit comments worthless, the sumbissions are heading that way too.
10:30:36 <mrd> i've been reddit-free for over a year
10:30:52 * roconnor refers to "If you're happy and you know it, Syntax error!" being #2
10:31:00 * byorgey has been reddit-free for twenty-six years
10:31:02 <roconnor> mrd: how did you do it?
10:31:42 <mrd> well, every time i thought about looking at reddit, i kicked myself in the nuts instead
10:31:49 <eu-prleu-peupeu> hello
10:32:09 <eu-prleu-peupeu> does "let/in" has the same effect as the where clause ?
10:32:20 <roconnor> mrd: you kicked yourself in the nuts?
10:32:26 <mux> where is syntactic sugar for let
10:32:41 <roconnor> mux: is that really the case?
10:32:54 <roconnor> I mean where and let don't even have the same types.
10:33:03 <mux> where and let have types?
10:33:09 <roconnor> lets produce expressions
10:33:25 <roconnor> and where produce ... what was it ... declarations or something like that.
10:33:40 <mux> as far as I can tell, both forms allow bindings
10:33:42 <roconnor> still
10:33:52 <mrd> i guess i was busy doing homework so i could always find things to do instead of reddit
10:34:17 <mux> I can't say for sure though, you'll have to check the report
10:34:23 <gubagem> > hFlush stdout
10:34:24 <lambdabot>   Not in scope: `stdout'
10:34:43 <roconnor> eu-prleu-peupeu: they have similar effects, but the scopes of the two tend to be mildly different.
10:34:52 <eu-prleu-peupeu> ok
10:35:51 * gubagem learned about Haskell through reddit
10:35:54 <eu-prleu-peupeu> i tend to prefer let, probably because lisp and ocaml, i found myself using it a lot :/
10:36:17 <gubagem> but im trying to kick the habit as well, reddit used to have sweet links, now it's mostly 'garbage
10:36:26 <roconnor> eu-prleu-peupeu: that is understandable combing from those languages.  Some people prefer lets
10:36:37 <roconnor> but I think most people prefer where clauses
10:37:03 <mrd> my main problem with 'let' is that there is no satisfactory way of indenting it
10:37:36 <Socrates> Hmm, lets and wheres seem equivalent to me
10:37:44 <roconnor> where clauses work better in lazy languages than they would in strict languages.
10:37:57 <roconnor> because you don't have to worry about unused declarations being evaluated.
10:38:01 <Socrates> It seems to me you produce "declarations" and expressions from both
10:38:16 <mrd> you almost always end up with a dangling 'in'
10:38:19 <roconnor> Socrates: I don't believe that is the case.
10:38:34 <Socrates> Hmm, how would you categorise something like;
10:38:42 <Socrates> > let fac 0 = 1; fac n = n * fac (n - 1) in fac 10
10:38:44 <lambdabot>  3628800
10:38:47 <mrd> in a language like haskell where so much meaning goes into every line, a whole line devoted to 'in' is in stark contrast
10:39:00 <roconnor> Socrates: lambdabot evaluates expressions
10:39:19 <gubagem> how do I flush stdout?
10:39:25 <roconnor> you cannot put a where clause at the top level for lambdabot input.
10:39:42 <roconnor> but you can put a where clause in the declaration block inside a let expression
10:39:54 <roconnor> > let a = b where b = 3 in a
10:39:55 <lambdabot>  3
10:40:23 <roconnor> > a where a = 3
10:40:23 <lambdabot>  Parse error at "where" (column 3)
10:40:30 <mrd> gubagem: hFlush stdout ?
10:40:34 <mrd> @hoogle hFlush
10:40:35 <lambdabot> System.IO.hFlush :: Handle -> IO ()
10:40:43 <mrd> import System.IO
10:41:06 <roconnor> mrd: I often put a let on one line, and allign the in with the let on the next line
10:41:16 <mux> roconnor: see haskell98 report section 4.4.3.2
10:41:27 <mux> it seems where clauses are indeed rewritten to let clauses
10:41:36 <roconnor> mux: a good
10:41:51 <roconnor> I thought they may still be syntatic sugar
10:42:05 <mux> let isn't syntactic sugar
10:42:10 <roconnor> but because they have different types, I was unclear how they would be translated
10:42:14 <roconnor> oh
10:42:16 <mux> it could be if fix wasn't, but it's the other way around
10:42:39 <mux> I don't think it's correct to say that let and where have any type at all
10:42:49 <mrd> they have a typing rule
10:43:29 <roconnor> mux: I'm sure that if you look inside GHC you will find types for expressions and declarations.
10:43:34 <roconnor> ... I hope
10:44:16 <mux> typing rules yeah, other than that let and where shuold have no business with types
10:44:32 <roconnor> mux: I'm talking about types on the meta level
10:44:47 <mux> types-in-the-ghc-code yeah, most likely
10:45:18 <roconnor> I always try to understand everything in terms of types :)
10:45:51 <gubagem> :t !!
10:45:53 <lambdabot> parse error on input `!!'
10:45:57 <gubagem> mmmm
10:45:59 <mux> :t (!!)
10:46:01 <lambdabot> forall a. [a] -> Int -> a
10:46:12 <gubagem> where do i import !! from?
10:46:21 <mux> you don't, it's in the Prelude
10:46:41 <mux> it's always available
10:46:56 <Deewiant> unless you explicitly import only a part of the Prelude :-)
10:47:08 <Deewiant> (or tell the compiler to not import it implicitly)
10:47:46 <roconnor> eu-prleu-peupeu: the key difference between where and let is that the scope of where include all the guards of a pattern binding
10:47:57 * mux nods
10:48:09 <mux> which is why I only resort to let when I have pattern guards, usually :-)
10:48:21 <smg> hello Caelum
10:48:54 <gubagem> how can reads take [(SomeType,String)]
10:49:08 <BMeph> ?ty reads
10:49:10 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:49:16 <smg> ^^
10:49:22 <smg> BMeph: ! salve
10:49:29 <mux> it *returns* [(a, String)]
10:49:29 <roconnor> eu-prleu-peupeu: as mux pointed to: http://www.haskell.org/onlinereport/decls.html#patbind
10:49:29 <lambdabot> Title: The Haskell 98 Report: Declarations
10:49:32 * BMeph flexes
10:49:38 <mux> and the 'a' type is deduced from the context via  type inference
10:49:41 <mux> if possible
10:49:50 <mux> if not, you'll have to add explicit type signatures
10:50:05 <eu-prleu-peupeu> hmm, i see
10:50:31 <smg> BMeph: :)
10:50:54 <mux> > read . show $ 2
10:50:56 <eu-prleu-peupeu> this is a bit off topic, some guys from this game dev company just called me saying that i can start working on monday with them if i am interested... :/
10:50:56 <lambdabot>  Exception: Prelude.read: no parse
10:51:00 <mux> > read . show $ 2 :: Int
10:51:01 <lambdabot>  2
10:51:09 <mux> mmm, the first one should have failed with ambiguous type variable
10:51:15 * mux shrugs
10:51:21 <smg> the first fails
10:51:27 <smg> i have a question
10:51:41 <mux> maybe it defaulted to something
10:51:51 <Socrates> Defaults to IO I think
10:51:55 <smg> i saw a special ghci on Mac OS i guess, there you can see after evaluation of an expression how much time and space it needed
10:51:58 <smg> do you know that special ghci?
10:51:59 <Socrates> At least, GHCi defaults to IO
10:52:05 <mux> it's nothing special
10:52:09 <BMeph> mux: I think LB makes things default to ()
10:52:19 <smg> mux: no? at my ghci it isnt
10:52:22 <mux> :set +s
10:52:48 <mux> you probably just had a default rc file somewhere that set this automatically
10:52:53 <smg> mux: ahahah nice
10:53:09 <smg> is there manual what do you can set?
10:53:20 <mux> :help is helpful :)
10:53:28 <smg> no.
10:53:36 <mux> it describes +s at least
10:53:48 <smg> ah it does.
10:54:01 <smg> set +t
10:54:04 <mux> BMeph: evil LB
10:54:30 <smg> mux: :set t is also cool
10:54:35 <mux> yup
10:54:40 <mux> I just use :t it though
10:54:51 <mux> having it printed each time is boring
10:55:08 <smg> it is boring indeed
10:55:13 <mux> 'it' is a special binding to the last result
10:55:15 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8155#a1
10:55:25 <smg> mux: haha very ncie
10:55:28 <smg> it = _ ?
10:55:33 <smg> ah no it = it and _ = _
10:55:37 <smg> @type it
10:55:39 <lambdabot> Not in scope: `it'
10:55:45 <smg> @type _
10:55:46 <lambdabot> Pattern syntax in expression context: _
10:56:00 <mux> _ has no type, it's syntax
10:56:08 <smg> k
10:56:16 <smg> mux: you saved my life
10:56:22 <mux> I'm glad :)
10:56:24 <smg> :)
10:56:26 <smg> hehe
10:56:33 <smg> +r is cool and i needed it t
10:56:34 <smg> ty
10:56:57 * mux waves good bye &
11:04:18 <smg> mh
11:04:20 <smg> where is foldl' ?
11:04:31 <smg> Data.List
11:04:31 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8155#a2
11:04:32 <smg> ?
11:04:45 <Deewiant> yep
11:05:10 <smg> ah is foldr preferred for infinite lists?
11:05:41 <Deewiant> it's your only option for infinite lists :-P
11:05:42 <smg> > foldr (||) False (take 1000 $ repeat True)
11:05:42 <Corun> foldl doesn't work for infinite lists?
11:05:43 <lambdabot>  True
11:05:52 <smg> > foldl (||) False (take 1000 $ repeat True)
11:05:53 <lambdabot>  True
11:05:59 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8155#a3
11:06:01 <smg> > foldl (||) False (repeat True)
11:06:02 <Deewiant> > foldl f z [a..]
11:06:08 <lambdabot> Terminated
11:06:09 <Deewiant> > foldr f z [a..]
11:06:11 <lambdabot>  f Exception: not a number
11:06:13 <smg> > foldr (||) False (repeat True)
11:06:15 <lambdabot>  True
11:06:16 <lambdabot>  thread killed
11:06:18 <Deewiant> O_o
11:06:19 <smg> :]
11:06:31 <smg> > foldl' (||) False (repeat True)
11:06:42 <smg> "Thread killed"
11:06:43 <lambdabot> Terminated
11:06:46 <smg> ok
11:07:14 <mmorrow> > or (False:repeat True)
11:07:15 <lambdabot>  True
11:07:24 <smg> hehe
11:07:29 <smg> @implementation or
11:07:29 <lambdabot> Unknown command, try @list
11:07:37 <smg> @src or
11:07:37 <lambdabot> or    =  foldr (||) False
11:07:44 <smg> mmorrow: :]
11:07:47 <mmorrow> :)
11:07:54 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8155#a4
11:08:26 <conal> dons: ping
11:12:49 * dcoutts announces the second release candidate for Cabal-1.4
11:12:54 <dcoutts> http://haskell.org/cabal/download.html
11:12:55 <lambdabot> Title: The Haskell Cabal
11:13:02 <smg> dcoutts: nice
11:13:42 <dcoutts> see the release notes: http://haskell.org/pipermail/haskell-cafe/2008-June/044027.html
11:13:42 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: Cabal-1.4 release candidate
11:14:15 <dons> conal?
11:17:27 <conal> dons: hi.  i have a ghc optimization question.  i want to do 'linear map fusion', which relies on canceling the composition of two methods.  but the methods are getting inlined into dictionary accessors.
11:17:41 <conal> dons: a NOINLINE pragma doesn't seem to help
11:18:01 <dons> maybe a question for SPJ?
11:18:14 <roconnor> @seen spj
11:18:14 <lambdabot> I haven't seen spj.
11:18:19 <roconnor> :)
11:18:29 <conal> dons: good idea.  have you tried controlling inlining of methods?
11:18:48 <dons> do you have a small example?
11:19:46 <conal> dons: yeah.  i'll paste.
11:21:18 <hpaste>  conal pasted "linear map fusion attempt" at http://hpaste.org/8156
11:21:39 <conal> oops -- forgot the rules.  will annotate.
11:22:58 <conal> dons: my internet connection is flaky.  the missing bit is this rule:
11:22:59 <conal> "lapply.linear"   forall f. lapply (linear f) = f
11:24:14 <smg> why is haskell so cool? :)
11:24:34 <Botje> because if it wasn't, everyone would use it
11:25:19 <hpaste>  conal annotated "linear map fusion attempt" with "linear fusion rules" at http://hpaste.org/8156#a1
11:25:47 <roconnor> dons: is BLAS just bindings?
11:28:29 <RayNbow> smg: Haskell is just so more interesting than the boring mainstream languages ;)
11:28:33 <RayNbow> that's why it's cool
11:28:51 <smg> hehe
11:46:34 <seanmce> I unregistered and deleted old-time. Now I can't re-install it because cabal Setup on it.
11:47:38 <dcoutts> seanmce: mm, that's not good. Yeah, the installed Cabal lib depended on old-time. So that and all other packages that depend on old-time are currently broken.
11:47:49 <dcoutts> see $ ghc-pkg check
11:48:00 <seanmce> can I manually install it?
11:48:18 <dcoutts> if you can re-register old-time correctly then it should work
11:48:39 <dcoutts> because presumably you only unregistered it, you didn't actually delete the files that make up the old-time package
11:48:55 <seanmce> no I deleted it too.
11:49:04 <dcoutts> oh, that's bad
11:49:18 <dcoutts> you'll have to rebuild all the packages that depend on old-time
11:49:30 <dcoutts> if you happen to have a setup binary then that'd help
11:49:48 <dcoutts> eg if you did ghc --make Setup in any other package build tree
11:49:52 <seanmce> I use runghc so I don't have setup binaries
11:50:05 <dcoutts> seanmce: you may have to re-install ghc
11:51:08 <seanmce> ï»¿ok, I guess I can manage a reinstall. I wish, the new cabal came with ghc. It would be alot easier then
11:53:41 <tobi_tud> hi everyone! who would me help me on some performance issues?
11:55:00 <Lemmih> tobi_tud: You can find out by asking a question.
11:55:04 <cpfr> hey if i wanted to share code between programs written in haskell and scheme what would be the best way
11:55:30 <cpfr> should i just compile C shared libraries and use FFI?
11:57:09 <thetallguy> Lemmih: a question about HAppS.  If I store two values in the database, say two trees that share a common subtree, is that tree still shared after stopping/restarting?
11:57:17 <nus> cpfr, use ffi from what?
11:57:27 <Lemmih> thetallguy: No.
11:57:28 <nus> cpfr, both?
11:57:53 <cpfr> im not sure
11:58:00 <thetallguy> Lemmih: I figured, but seemed worth asking.  Thanks.
11:58:20 <cpfr> i want to try writing an app partly in haskell and partly in scheme
11:58:31 <cpfr> and have the methods in each call each other
11:58:45 <cpfr> and i am not sure what is the best way to do that
11:58:47 <nus> cpfr, you need scheme syntax or do you have particular libs involved?
11:59:14 <cpfr> nus, a little of both
11:59:18 <Cale> cpfr: Going via C is the basic idea.
12:00:42 <hpaste>  tobi_tub pasted "Performance Issue with Data.Array.Diff." at http://hpaste.org/8158
12:01:51 <cpfr> Cale, so would i just compile both to C?
12:02:09 <dons> tobi_tud: diff arrays are very old, and not optimised
12:02:12 <Cale> cpfr: Well, the Haskell FFI imports and exports things as if they were C functions.
12:02:14 <dons> if performance matters, i would avoid them
12:02:37 <cpfr> ok cool
12:02:58 <Cale> Well, Diff arrays can be good for very specific things, but if you're doing lots of small updates and need access to old versions of the array often, it can be bad.
12:02:59 <cpfr> and scheme side I can just access haskell as a shared library
12:04:53 <tobi_tud> i have two versions of a function: 1) change one element of a data.array.diff. 2) change many elements of a list. im surprised, that if i use the 2) version a runtime explosion from 4seconds to 20seconds. the profiler tells me that another function uses 80% of the time. can any one explains the behaviour? http://hpaste.org/8158#a0
12:06:44 <Cale> tobi_tud: Reading from out of date versions of a diff array becomes slower and slower as more updates are done to the version which is current.
12:08:42 <Cale> When  a // xs  is evaluated for a diff array a, what happens is that the array is mutated, and  a  is relinked to point at a reverse list of changes and a pointer to the more current version.
12:09:28 <Cale> Is this a DiffUArray and a UArray?
12:09:31 <tobi_tud> Cale: i thought, it behaves more like a c array
12:09:49 <tobi_tud> just DiffArray ? imported from Data.Array.Diff
12:09:57 <ziman> Cale, so if i don't need older versions, DiffArray is ok?
12:10:04 <Cale> Try UArray and DiffUArray
12:10:08 <Cale> ziman: right
12:10:41 <Cale> ziman: If, after evaluating a // xs, you never (or only rarely) go back to use a, then it's fine.
12:10:48 <Lemmih> ziman: DiffArrays have a huge constant factor, though.
12:11:21 <Cale> Though, you do still pay a price for building the list of reverse changes.
12:11:57 <tobi_tud> isnt UArray immutable?
12:12:31 <bos> ooh, those BLAS bindinds are pretty cute.
12:12:40 <Cale> tobi_tud: right. But it's unboxed. Actually, it looks like you're storing a more complex datastructure, so you might not be able to use it.
12:12:52 <ziman> Lemmih, huge constant factor of which operations? if i'd implement a stateful algorithm as a tail-recursive function having the state (the array being mutated) in its params, would it be bad?
12:13:27 <Cale> tobi_tud: A UArray of Bool, for example, is stored as a bitfield, and the difference in memory usage can significantly speed things up relative to DiffArray, even if you're doing quite a bit of mutation.
12:13:34 <bos> ziman: yes.
12:13:54 <bos> ziman: the way people work on mutable arrays is via the ST monad.
12:14:39 <Lemmih> ziman: Each lookup and insert requires taking a lock. I seem to recall it being ~300 times slower than accessing elements from a regular array.
12:15:03 <tobi_tud> okay, i'll try it. thank you a lot. one other question: i have a function f and two arguments a and b, so i call it with: f a b. how can i turn off laziness?
12:15:26 <mxc> anyone familiar with how data.derive and DRIFT compare?
12:15:52 <ziman> ah, i see. thanks ;)
12:16:16 <bos> DiffArray is more or less completely useless.
12:16:16 <dbueno> Lemmih: 300 times slower or 300% slower?
12:16:36 <noecksit> hello, could anyone help me out with combining to readerT instances, i have a reader in the beginning for one function, but then that function spawns another function with more information that the other function needs to use, so i have a reader running inside another reader
12:17:01 <bos> noecksit: you need to use lift.
12:17:02 <Lemmih> dbueno: 300 times slower.
12:17:13 <bos> noecksit: that will let you get at the inner monad from the outer one.
12:17:43 <bos> noecksit: at least assuming your type is ReaderT foo (ReaderT bar m a)
12:18:59 <noecksit> bos: so it wouldnt be a problem combining these two readers, right, no weird types or anything like that
12:19:15 <bos> noecksit: definitely not a problem.
12:19:31 <bos> just "lift ask"
12:21:33 <kaol> > $([| \x -> (Just x) |]) 1
12:21:33 <lambdabot>  Parse error at "|" (column 4)
12:23:05 <BMeph> tobi_tud: Why would you want to "turn off" laziness? What if you need to be really lazy in a hurry? ;)
12:23:40 <Apocalisp> tobi_tud: Yea, don't be so eager to turn off laziness.
12:24:00 <Apocalisp> tobi_tud: You don't strictly need to do that, do you?
12:27:48 <maltem> tobi_tud: You can make a function strict by writing f a b = a `seq` b `seq` bla, if that's what you want
12:29:40 <twobitwork> are there any significant disadvantages of compiling with -fvia-c?
12:29:55 <twobitwork> performance or functionality wise?
12:30:06 <bos> twobitwork: it makes compilation much slower, and doesn't often affect runtime performance measurably.
12:30:32 <twobitwork> bos: ok, that's fine
12:30:43 <Lemmih> twobitwork: And God kills a kitten.
12:30:43 <Baughn> twobitwork: The C compiler is traditionally better at optimizing the last few levels of compilation than ghc. "Traditionally" is the significant word here..
12:30:47 <twobitwork> because I'm planning to FFI to some C code which defines macros in the .h
12:31:09 <Baughn> ..that could be a problem
12:31:19 <bos> going through the C compiler won't make any difference to that.
12:31:59 <Baughn> twobitwork: Traditionally, the right thing to do is to write a .c file with wrappers for the macros
12:32:09 <Baughn> twobitwork: Or figure out what the macros do and do without them
12:33:17 * Baughn once saw one nightmare .h file that pretty much implements an FFI of its own. Wrapping /that/ was.. fun.
12:34:19 <noecksit> ok, i have another quest about readers, i have the function "bracket" from Control.Exception, but its types are all IO, so I use liftIO inside my reader monad to transform it, however then the functions that are inside the bracket parameters don't know what to do when I "ask" for an env
12:34:29 <twobitwork> bos: http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Importing_C_functions_that_turn_out_to_be_CPP_macros
12:34:31 <lambdabot> Title: GHC/Using the FFI - HaskellWiki, http://tinyurl.com/6xh6cr
12:35:33 <noecksit> how would i be able to use the bracket function while preserving the functions from the reader monad inside the inner functions?
12:35:41 <bos> noecksit: you'll have to pass whatever you were going to ask into them, or rerun the reader monad inside the bracket call.
12:36:28 <Baughn> Now if only -fvia-c worked on things like "EINTR_CALL(select, sys/select.h, (int,fd_set*,fd_set*,fd_set*,struct timeval))"
12:36:31 <bos> i.e. { foo <- ask; bar <- liftIO (runReaderT myBody foo) }
12:37:32 <Baughn> noecksit: I hear the mtl package has a lot of code dealing with this sort of issue
12:38:12 <noecksit> oh ok, i guess theres no point to doing what i wanted to do, i had a lot of similar env variables and i wanted to combine it into one master reader monad
12:38:49 <bos> Baughn: no, it doesn't.
12:39:40 <noecksit> i thought the called functions inherit the vars from the reader monad
12:39:48 <Baughn> bos: A good reason not to listen to rumor, then
12:40:01 <Baughn> Though it does have code relating to combining monads
12:40:15 <bos> noecksit: once you go inside liftIO, you're not in the reader monad any more, you're in IO. that's the point :-)
12:40:36 <bos> noecksit: but it would be a little unusual to have a substantial body of code in there.
12:40:53 <bos> noecksit: especially anything that needs to interact with the calling monad.
12:40:57 <RayNbow> hmm, has anyone here read http://www.amazon.com/Calculus-Manifolds-Approach-Classical-Theorems/dp/0805390219 ?
12:40:58 <lambdabot> http://tinyurl.com/yusuk8
12:41:43 <noecksit> i wish there was bractetT that would let your functions return whatever u want, not just IO
12:41:52 <geezusfreeek> :t bracket
12:41:54 <lambdabot> Not in scope: `bracket'
12:42:05 <geezusfreeek> @hoogle bracket
12:42:06 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:42:06 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
12:42:06 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:42:51 <Cale> RayNbow: I have.
12:42:54 <geezusfreeek> i think Exception would imply the IO monad anyway
12:43:10 <dmwit> noecksit: What would that mean?
12:43:11 <Cale> RayNbow: It's a good book.
12:43:28 <dmwit> noecksit: There's no equivalent of "catch" generalized to all monads...
12:44:25 <noecksit> yea, i guess so since that is the only monad that could interact with the outside world
12:45:03 <noecksit> so it would be impossible to implement
12:45:25 <RayNbow> Cale: I love good books ^_^
12:45:27 <Cale> bracket uses the interface to exceptions which is built into the IO monad.
12:45:38 <RayNbow> but I need to read faster, because the pile of unfinished books is growing :p
12:45:54 <jao> RayNbow, I agree with Cale
12:46:01 <RayNbow> but Cale, what kind of math level do you need for that book?
12:47:07 <Cale> RayNbow: It's been a while, but I'd say a decent understanding of calculus in one dimension should do.
12:47:44 <RayNbow> ah, so having completed any BSc course would do
12:48:04 <Cale> I also recommend "Calculus" by the same author.
12:48:46 <RayNbow> Cale, in which order would you recommend them?
12:49:20 <Cale> Well, "Calculus" is more elementary, but covers a much broader range of material.
12:49:32 <RayNbow> hmm, might be good for a refreshment :)
12:49:35 <Cale> yeah
12:51:24 <jgrimes> how do you force using a particular class instance?
12:51:52 <Cale> jgrimes: What do you mean force?
12:52:04 <tromp> u dont force, u declare
12:52:08 <JamesIry> Just explicitly type
12:53:20 <tromp> fun :: (Ord a) => a -> a -> a
12:53:28 <jgrimes> Cale: I've got an instance for Ord for a tuple where both of the inner types also have Ord instances, so I get overlapping instance errors because of the Ord a, Ord b => Ord (a,b) instance in Data.Tuple
12:53:53 <Cale> jgrimes: You can't have both, because they overlap.
12:54:07 <Cale> Create a newtype or new data type.
12:54:11 <jgrimes> I don't want both, I'm not sure why the Data.Tuple instance is getting referenced
12:54:44 <tromp> (,) decided it knows what instance is good for you
12:54:59 <Cale> There's nothing you can do about that instance. All you can do is define a new datatype.
12:54:59 <vovik> can someone recommend a gentle introductory text on combinatorial logic and type theory that i can read for fun in my spare time?
12:55:06 <tromp> so if that doesn't do it for you, dont use (,)
12:55:11 <jgrimes> Cale: Aww, ok.
12:55:23 <roconnor> combinatorial logic?
12:55:35 <roconnor> is that like Hilbert style deductions?
12:55:38 <Cale> jgrimes: Which ordering were you going to use? The default one is lexicographic.
12:55:46 <vovik> roconnor: i'm not familiar with either so i don't know
12:56:02 <jgrimes> Cale: I was going to use one that ignored the first element of the tuple
12:56:15 <Cale> roconnor: Probably combinatory logic is meant
12:56:25 <roconnor> oh
12:56:43 <roconnor> Cale: is that like Hilbert style deductions?
12:56:44 <roconnor> :P
12:56:50 <smg> good evening Cale
12:57:02 <Cale> Hi smg
12:57:22 <Cale> jgrimes: Yeah, you're better off just defining a new datatype for that.
12:57:46 <Cale> jgrimes: But be careful, since lots of things expect Ord to give a total ordering.
12:58:39 <vovik> or even a text on lambda calculus
12:58:58 <vovik> i've been trying to read up on the basic but there is just a good amount of background i'm missing
12:59:12 <roconnor> vovik: typed or untyped?
12:59:14 <edwardk> @seen conal
12:59:15 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 1h 36m 15s ago.
12:59:16 <Cale> vovik: Have you tried the Wikipedia article?
12:59:18 <vovik> for some reason we completely skipped that part in my theory of computation class
12:59:26 <vovik> Cale: i have, it's a bit too dense for me
12:59:32 <RayNbow> vovik: BarendregtLambdaCalculusImpactCS.pdf <-- have you tried this one?
12:59:59 <jgrimes> Cale: ok, thanks for the heads up.
13:00:01 <vovik> RayNbow: nope, let me take a look
13:00:04 <conal> edwardk: hi
13:00:14 <vovik> roconnor: untyped probably at first
13:00:35 <RayNbow> vovik: want me to dcc that pdf?
13:00:55 <roconnor> vovik: typed and untyped lambda calculus are almost distict topics :)
13:01:20 <twobitwork> unlambda ftw
13:01:24 <vovik> RayNbow: would you mind emailing it to iamvlad at gmail?
13:01:45 <vovik> RayNbow: i'm at work right now and i don't know how dcc will work
13:01:48 <RayNbow> ah k
13:02:52 <vovik> which would you say is more relevant to haskell, typed or untyped?
13:03:10 <roconnor> typed
13:03:17 <vovik> and to lisp?
13:03:24 <roconnor> untyped
13:03:32 <vovik> alright, well i have no interest in learning lisp so
13:03:36 <vovik> just curious
13:03:37 <RayNbow> vovik: mail sent :)
13:03:40 <roconnor> hmm
13:03:45 <vovik> RayNbow: thx a lot :D
13:04:11 <roconnor> Actually I'm not so sure about haskell
13:04:19 <roconnor> maybed untyped is also relevent for it.
13:04:36 <roconnor> since, as a logic, haskell is inconsistent.
13:04:44 <Cale> Untyped lambda calculus is relevant for understanding typed lambda calculus.
13:04:44 <roconnor> aka it has non-terminating programs
13:04:58 <vovik> right
13:05:01 <roconnor> Cale: you think?
13:05:10 <Cale> roconnor: sure
13:05:25 <smg> Cale: how are you buddy?
13:05:31 <Cale> smg: I'm fine
13:05:32 <vovik> that's what i figured, that's why i was thinking of looking into untyped first because i'm guessing it's simpler
13:05:53 <vovik> also i have zero background in type theory
13:06:13 <vovik> see this is the type of thing i wish i took instead of differential equations and crap like that
13:06:24 <smg> Cale: that makes me happy :)
13:06:36 <RayNbow> hmm, doesn't the TaPL book also start with untyped lambda calculus?
13:06:55 <Cale> There's a sense in which typed lambda calculi can be simpler than the untyped one, but for an initial understanding, I think untyped is easier.
13:07:03 <Cale> RayNbow: yeah, it does
13:07:16 <Cale> newtype Rec a = In { out :: Rec a -> a }
13:07:16 <Cale> y :: (a -> a) -> a
13:07:16 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
13:08:22 <Cale> Recursive types make things interesting :)
13:14:08 <jcreigh> okay, I have "type IPV4Address = Word32
13:14:34 <Cale> For computer science, I suspect the most important mathematics topics are linear algebra, algebraic combinatorics, point-set topology, and order/lattice theory. Maybe something about monoids if you can get it. (A course in group theory wouldn't be a bad start in that direction.)
13:14:38 <jcreigh> and I'm trying to write a show instance for IPV4Address, but GHC doesn't like it because it's just a synonym. Should I use newtype, or is there some better way to do this?
13:14:50 <Cale> jcreigh: newtype
13:15:38 <Cale> jcreigh: Otherwise, there's no way for it to tell whether you want the instance for Word32 or for IPV4Address, since those are the same type.
13:16:39 <Cale> You could also write something like  showIPV4Address :: Word32 -> String
13:17:29 <jcreigh> oh, now I need to learn about newtype-deriving to make IPV4Address an instance of Bits...
13:18:04 <mxc> cale - its not cutting edge, but you could make an argument that the whole thing falls apart without boolean algebra
13:22:36 <blarz> http://cgi.ebay.com/ws/eBayISAPI.dll?ViewItem&item=150256074674&indexURL=1#ebayphotohosting - pdp-10 anyone? ;-)
13:22:37 <lambdabot> Title: pdp-10 KL10 DECSYSTEM 2065 - eBay (item 150256074674 end time Jun-13-08 08:12:11 ..., http://tinyurl.com/6ccuqe
13:23:10 <bos> @hoogle 2c
13:23:10 <lambdabot> Hoogle Error: Parse Error: Unexpected character '2c'
13:23:18 <bos> @hoogle w2c
13:23:19 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
13:27:03 <mmorrow> Cale: I would add (abstract) algebra to that list not so much for the particular details (although they don't hurt), but for way of thinking/point of view overhaul that occurs from being exposed to it.
13:27:14 <reilly> i used to work in the TOPS-20 group at DEC.
13:27:29 <ziman> jcreigh, however, there's a ghc extension -XTypeSynonymInstances if you really really want that
13:27:55 <mmorrow> and you don't even need to know calculus to grok e.g. field-extensions!
13:28:16 <noecksit> i havent been able to find something i could use linear algebra for yet except graphics
13:28:30 <ddarius> noecksit: You haven't been looking then.
13:28:48 <mmorrow> optimization, <insert-a-million-other-things>
13:28:49 <noecksit> i hear its very useful in optimization problems
13:28:52 <mmorrow> heh
13:28:57 <jcreigh> ziman: wait...I don't even understand how that would work. How would GHC know which one to use?
13:29:10 <ddarius> optimization, physical simulation, signal processing
13:29:19 <mmorrow> engineering anything
13:29:30 <ddarius> All three of those are massive fields in and of themselves.
13:30:01 <reilly> blarz: i miss TOPS-20
13:31:20 <blarz> reilly: to be honest I had to google that, I just knew that pdp-10 is a huge computer
13:31:27 <blarz> never got near anything like that
13:32:03 <blarz> so I didn't know what tops-20, that's what I wanted to say :-)
13:32:20 <mmorrow> the derivative and integral are nothing but linear maps of functions...
13:32:39 <ziman> jcreigh, well, i didn't read carefully enough to notice you wanted to create a _Show_ instance. That would not work if Word32 already is a Show instance, i guess
13:33:36 <jcreigh> ziman: oh, I see. It would have to be something that Word32 didn't already have an instance for, then.
13:33:49 <reilly> blarz: they were years ahead of their time.  readline is STILL catching up to the built-in equivalent in TOPS-20
13:34:00 <ziman> jcreigh, yes
13:34:23 <jcreigh> I just think it's funny how GHC errors are often in the form of "What you asking is impossible! Unless you pass in another flag..."
13:34:24 <ziman> i've used it once that way
13:35:00 <ziman> the mighty GHC :>
13:35:36 <blarz> reilly: hehe, I see. Well I read that DEC was really thinking ahead
13:36:47 <cpfr> for haskell ffi, what would i run to compile the ffi-using modules into object files?
13:37:51 <al-maisan> quick question: can I use the Text.Regex.Posix functions along with byte strings?
13:38:16 <gubagem> probably with conversion id think, but i honestly have no idea
13:39:55 <twobitwork> how can you manipulate the stack before calling a foreign function from haskell?
13:40:09 <twobitwork> I'm looking at accessing the Lua API, and it does some stack tricks
13:41:31 <twobitwork> nm... I misread something... they use an internal stack
13:43:43 <mmorrow> "<mmorrow> and you don't even need to know calculus to grok e.g. field-extensions!": as an interesting side point, if one had minimal exposure to galois theory (does x^2+1 have any zeros in R(eals)??) (like know the basic main points, doesn't matter if you can prove anything), adjunctions would be perfectly motivated. (prereqs: basic group theory, rings, some ring stuff, fields (easier than rings) => maybe 1-2 months from zero with
13:43:43 <mmorrow> motivation/interest)
13:45:18 <mmorrow> abstract algebra leads *naturally* to category theory
13:46:19 <jkff> Oh, did I miss something? Are you discussing category theory?
13:46:26 <Cale> mmorrow: I'm not sure that Galois theory alone can motivate adjunctions.
13:46:35 <noecksit> @hoogle parsec
13:46:35 <lambdabot> Text.ParserCombinators.Parsec :: module
13:46:35 <lambdabot> Distribution.Configuration.parseCondition :: ReadP r (Condition ConfVar)
13:46:35 <lambdabot> Distribution.Simple.Setup.parseConfigureArgs :: ProgramConfiguration -> ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
13:47:18 <mmorrow> it would be a "small" generalization to arrive thereat
13:47:24 <Cale> Sure, a Galois connection is a pair of adjoint functors between posets, but without a few other examples, it's not clear that the abstraction has a purpose.
13:47:54 <mmorrow> i suppose, but i'm salespitching!
13:47:55 <jkff> I've seen a very interesting article, though in Russian, about application of Galois theory to data analysis problems
13:48:19 <Cale> It is a good example, I'll admit :)
13:48:20 <jkff> It motivated me to learn something about Galois theory, but not enough to actually start :(
13:48:44 <jkff> What other applications does it have?
13:49:05 <Cale> jkff: In the real world? I'm not sure.
13:49:20 <Cale> I think of it as a beautiful way to understand fields.
13:49:39 <jkff> Hm, does it have less applications in the real world than category theory?
13:49:47 <Cale> Probably.
13:49:57 <mmorrow> ha
13:50:08 <edwardk> jkff: heh
13:51:01 <jkff> What does Galois theory talk about, at all? About galois connections?
13:51:01 <Cale> It's what's used to show that it's not possible to trisect every angle with straightedge and compass, and to show that degree 5 polynomials exist which don't have solutions in terms of nth roots and algebraic operations.
13:51:28 <kscaldef> I'm looking for a function I might call concatMapM :: (a -> m [b]) -> [a] -> m [b], and not finding anything on hoogle.  Any pointers?
13:51:30 <Cale> Galois theory studies the symmetries of field extensions.
13:51:51 <Cale> Do you know what a field is?
13:51:55 <jkff> Yes
13:52:02 <jkff> But I don't know what a field extension is
13:52:06 <Cale> All right.
13:52:31 <idnar> kscaldef: isn't that just liftM.liftM?
13:52:38 <Cale> It's basically just a field with a marked subfield.
13:52:51 <idnar> @type liftM.liftM
13:52:52 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
13:52:58 <Cale> So for example, the complex numbers are a field extension of the reals.
13:53:06 <idnar> hmm, no
13:53:11 * idnar tries to figure out what he meant
13:53:17 <idnar> @type (>>=)
13:53:18 <jkff> Similar to the notion of a subcategory?
13:53:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:53:26 <jkff> Or any subalgebra
13:53:32 <byorgey> @type concat . sequence . map
13:53:33 <lambdabot>     Couldn't match expected type `[[a]]'
13:53:33 <lambdabot>            against inferred type `f a1 -> f b'
13:53:33 <lambdabot>     Probable cause: `map' is applied to too few arguments
13:53:34 <Cale> jkff: Well, a subset which is also a field, and has the same 0 and 1
13:53:37 <idnar> @type liftM . (=<<)
13:53:39 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m1, Monad m) => (a -> m1 b) -> m (m1 a) -> m (m1 b)
13:53:49 <idnar> @type (=<<) . (=<<)
13:53:49 <jkff> Yes, so a subfield
13:53:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m (m a) -> m b
13:53:52 <byorgey> @type ((concat . sequence) .) map
13:53:54 <lambdabot>     Couldn't match expected type `[[a]]'
13:53:54 <lambdabot>            against inferred type `f a1 -> f b'
13:53:54 <lambdabot>     Probable cause: `map' is applied to too few arguments
13:54:02 <idnar> meh
13:54:05 <jkff> ..And what does the theory do with these field extensions?
13:54:43 <tobi_tud> hello, one little question: i round a value with ceiling and i like to have an Int as return type. how to convert to Int?
13:54:43 <Cale> and you study morphisms between extensions of the same field, which are field homomorphisms that keep the base field fixed.
13:54:47 <byorgey> @type \f xs -> (concat . sequence) (map f xs)
13:54:49 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
13:55:19 <mmorrow> ah, there it is. the punchline of galois theory.
13:55:27 <mmorrow> well, partially spoken
13:55:28 <jkff> And what is so interesting about such morphisms?
13:55:30 <byorgey> @type \f xs -> (liftM concat . sequence) (map f xs)
13:55:32 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
13:55:45 <byorgey> ah, there we go =)
13:55:59 <kscaldef> indeed, that looks like it
13:56:11 <byorgey> @type ((liftM concat . sequence) .) . map
13:56:13 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
13:56:21 <kscaldef> now to try to figure out _why_ that's what I want :-)
13:56:28 <byorgey> hehe, indeed =)
13:57:21 <byorgey> @type mapM
13:57:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:57:33 <byorgey> aha!
13:57:53 <byorgey> @type \f xs -> liftM concat . mapM f xs
13:57:54 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f [[a]]) -> [a1] -> f [[a]]
13:58:37 <byorgey> hmm...
13:59:07 <Cale> jkff: Well, the main thing, I think, is to study the group of automorphisms of a field over a base field... that is if L is some field and K a subfield of it, we have Aut(L/K) being the group of all morphisms L -> L which leave K fixed.
13:59:17 <mmorrow> jkff: (sloppily said): these field extensions of a field correspond (inversely) isomorphically to the subgroups of the automorphism group of the larger field
13:59:39 <mmorrow> an adjunction
13:59:49 <Cale> The main theorem of Galois theory is that (provided a few technical points) there's a correspondence of subfields between K and L, and subgroups of that automorphism group.
14:00:20 <mmorrow> the full automorphism group maps to K
14:00:24 <byorgey> Cale: is that the same as the group of automorphisms of the quotient field L/K?  (Does 'quotient field' even make sense?  I forget the exact details...)
14:00:27 <jkff> Hm, that's not so easy to understand at once but I'm giving it a try :)
14:00:28 <mmorrow> the trivial group to L
14:00:31 <Cale> The groups in question here are often finite and easy to study, whereas the fields are usually infinite and more difficult to answer questions about.
14:01:22 <Cale> byorgey: Fields don't really have meaningful quotients.
14:01:36 <byorgey> ok, fair enough.  I couldn't remember.
14:01:41 <jkff> What is 'an automorphism of a field over a base field'?
14:01:44 <Cale> (because their only ideals are the trivial ideal and the whole field)
14:01:55 <jkff> Or does the 'that is' part explain that?
14:02:11 <mmorrow> jkff: it's the auto (self-iso) of the field (with itself) that leaves that particular subfield fixed
14:02:16 <Cale> jkff: the 'that is' part explains
14:02:24 <jkff> Ok, going further...
14:02:52 <Cale> So we're looking at field morphisms f: L -> L such that if x is in K, then f(x) = x
14:03:21 <jkff> For example, take L to be complex and K to be real
14:03:27 <Cale> sure
14:03:29 <jkff> For example, take f to be a polynomial
14:03:33 <jkff> With real coefficients
14:03:35 <Cale> then there are exactly two such morphisms
14:03:36 <mmorrow> for a (commutative with 1) ring R and maximal ideal m, R/m is a field
14:03:43 <Cale> One is the identity map
14:03:54 <jkff> Ah
14:04:00 <jkff> The other is conjugate?
14:04:02 <Cale> The other is conjugation, yes
14:04:42 <mmorrow> prime ideal => maximal ideal
14:04:44 <gubagem> ok I keep running into problems with the whitespace rules
14:05:03 <gubagem> in do blocks
14:05:06 <Maciej> I need an idea for lazily reading data from a pointer. I've got a function :: [A] -> B that reads an unknown number of As from the list, depending on the values of the As. I'd like to apply this function to a list of As stored at a position Ptr A is pointing to. Any hints?
14:05:09 <jkff> Ok, that gets somewhat more clear. So, we study the group of automorphisms. And in case of complexes and reals, the group consists of just two elements, each being its own inverse.
14:06:29 <mmorrow> well, it would need a third then i believe
14:06:52 <mmorrow> since if there are only two, each it's own inverse => they are the same and it in 1
14:06:58 <mmorrow> it is 1
14:07:22 <Cale> Maciej: hmm... that seems impossible without somewhat unsafe tactics :)
14:07:24 <jkff> mmorrow, what does that mean, that main theorem? Could you tell a bit more about that correspondence?
14:07:38 <Cale> Maciej: hmm...
14:07:53 <Cale> actually, I'm not certain that it can be done.
14:07:58 <jkff> Maybe tell which exactly are those two adjoint functors that seem to arise from that correspondence?
14:08:20 <Cale> mmorrow: hm?
14:08:33 <mmorrow> each way of the iso between the extension fields and the subgroups
14:08:35 <geezusfreeek> ds :: forall a_a3Fb b_a3Fc. (Functor (IVar IO (Temporal Int)), Functor (Source IO Int)); ds = \a_a3Fb b_a3Fc -> ... -- this is a CAF?
14:08:51 <geezusfreeek> ^ is from running ghc-core -O2 on my code
14:09:09 <mmorrow> an adjunction between the cat of finite groups and the cat of "field extensions"
14:09:12 <Maciej> Cale: That's bad :-(
14:09:12 <geezusfreeek> i'm not good with Core yet, and i'm not good with CAFs yet
14:09:32 <jkff> So, take K to be the reals. Then there are a lot of extension fields, one of them being the complexes. Take the category of all fields and homomorphisms between them to be C. What are the subgroups?
14:10:04 <Cale> Maciej: I suppose with unsafePerformIO it would be possible...
14:10:11 <mmorrow> that's the content of galois theory now that we have the 20/20 hindsight
14:10:26 <jkff> Hm, I'm asking silly questions, I should just read more attentively
14:10:29 <jkff> Or read a textbook
14:10:49 <jkff> Or have some sleep :)
14:10:52 <hpaste>  gubagem pasted "why am I running out of stack space?" at http://hpaste.org/8160
14:10:55 <Cale> Maciej: you could do something like   let xs = map (unsafePerformIO . peekElemOff ptr) [0..]
14:11:27 <Cale> Maciej: Which would give you an infinite list of values peeked from memory at increasing addresses starting from the ptr.
14:11:41 <Cale> But of course that'll eventually give you garbage.
14:11:53 <Cale> and crashing
14:12:07 <Maciej> Cale: I'll try that.
14:12:15 <Cale> So it's best to know how large the array in memory is beforehand.
14:12:38 <Cale> and then you don't need such hideous tricks
14:12:50 <mmorrow> Cale: i was refereing to "the group consists of just two elements, each being its own inverse." wouldn't that imply that those "two" elements are really the same element which is the identity?
14:12:56 <jkff> OK, thanks for explaining this far, tomorrow I'll find something myself and probably ask some clarifications.
14:12:58 <Cale> mmorrow: no
14:13:00 <geezusfreeek> gubagem: your code seems to be wanting "string" to be mutable, but you are actually defining it recursively
14:13:02 <mmorrow> oops
14:13:11 <jkff> No, not each other's inverse, but each of his own
14:13:13 <mmorrow> oh, it's *own* inverse
14:13:24 <mmorrow> i read each other's...
14:13:30 <geezusfreeek> > let string = string ++ "stuff" in string
14:13:31 <mmorrow> heh
14:13:45 <lambdabot>  thread killed
14:13:48 <cpfr> hey what option do i pass to compile a module into C
14:13:57 <geezusfreeek> gubagem: ^ see?
14:14:00 <cpfr> instead of straight native code
14:14:03 <Cale> jkff: The proper approach to this is to learn some basic field theory first, things about dimensions of fields over one another and polynomials and so on, and then work your way in from there.
14:14:17 <ziman> > let string = "stuff" ++ string in string
14:14:18 <lambdabot>  "stuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuff...
14:14:20 <ziman> ;)
14:14:35 <geezusfreeek> ziman: heh, which i think he still doesn't actually want
14:15:41 <Cale> > let g = ("stuff" ++) . g in g []
14:15:43 <lambdabot>  "stuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuff...
14:15:48 <ziman> geezusfreeek, yeah, i just wanted to test Î»bot's laziness ;)
14:16:52 <jcreigh> cpfr: why do you want to compile a module into C? The code won't be very readable...
14:16:52 <Cale> ^^ good illustration that in  f . g  it's f which is applied first, not g :)
14:17:38 <Maciej> Cale: unsafePerformIO seems to work fine.
14:18:24 <jcreigh> there aren't enough scare quotes in your statement: "seems" to "work" "fine" :)
14:18:57 <cpfr> jcreigh, im trying to access functions in haskell from scheme via an ffi
14:19:33 <hpaste>  byorgey annotated "why am I running out of stack space?" with "how I might do it (untested)" at http://hpaste.org/8160#a1
14:19:34 <jcreigh> you're trying to call Haskell from some other language? Hmm, usually FFI goes the other way...I don't know what the best approach would be in your case.
14:20:09 <byorgey> gubagem: there's an example of doing it in a more functional style
14:20:32 <byorgey> gubagem: also, as an aside, note that you could combine all those lets into a single let
14:20:42 <byorgey> let a = b
14:20:45 <byorgey>     c = d
14:20:50 <byorgey>    ...
14:20:55 <byorgey>  in blah blah
14:22:17 <cpfr> jcreigh, im trying find the nicest way
14:22:24 <pjdelport> let yin = yang
14:22:24 <pjdelport>     yang = yin
14:22:24 <pjdelport>  in yin yang
14:23:05 <dcoutts> dons: oh, so hackage2hwn works with the latest tagsoup now does it? so I'll be able to include it in my testing runs. Previously I had to exclude it since it needed an older tagsoup than all the other packages.
14:23:54 <geezusfreeek> cpfr: you should look into GHC's FFI. there is a way to export haskell functions. GHC creates an object file and a C include file for you
14:25:05 <cpfr> thanks geezusfreeek ill look into it now
14:25:16 <geezusfreeek> cpfr: oh, and you also have to initialize the rts to use to the haskell functions from C
14:25:22 <geezusfreeek> np
14:25:29 <cpfr> rts?
14:25:48 <geezusfreeek> run-time system
14:26:00 <hpaste>  ziman annotated "why am I running out of stack space?" with "a more declarative version" at http://hpaste.org/8160#a2
14:27:48 <cpfr> oh ok
14:35:58 <RayNbow> gubagem: making a MUD?
14:36:04 <RayNbow> or wait
14:36:08 <RayNbow> a text adventure?
14:36:15 <RayNbow> (MUD is multiplayer... :p)
14:37:32 * roconnor looks at ziman's annotation
14:37:52 <cpfr> geezusfreeek, is it possible to print a table of the haskell names vs their c-mangled names
14:38:00 <cpfr> or would that not even be useful
14:39:19 <geezusfreeek> my understanding is that they are not really mangled
14:39:35 <geezusfreeek> i only have done it for a single function in my entire life
14:40:06 <geezusfreeek> i have a function in haskell called hs_main, and it is the same name in the C code
14:41:15 <roconnor> @unpl (($room) . fst)
14:41:16 <lambdabot> (\ d -> fst d room)
14:41:48 <geezusfreeek> cpfr: oh are you trying to use haskell functions within an object file without using GHC's FFI?
14:41:57 <geezusfreeek> cpfr: i've definitely never done that before
14:42:19 <cpfr> geezusfreeek, im willing to use GHC's FFI
14:42:38 <geezusfreeek> cpfr: ah, then there shouldn't be any problem with name mangling then
14:43:03 <cpfr> is there any reason i shouldn't use the ffi?
14:43:10 <geezusfreeek> not that i can think of
14:43:17 <cpfr> excellent
14:43:54 <cpfr> so how would i access haskell functions from a compiled haskell object file
14:45:16 <cpfr> i understand C from Haskell, just not Haskell from C
14:45:58 <geezusfreeek> cpfr: http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C
14:46:01 <lambdabot> Title: GHC/Using the FFI - HaskellWiki, http://tinyurl.com/6xh6cr
14:46:09 <cpfr> thanks
14:46:49 <geezusfreeek> that actually is quite different from what i have done... hmm
14:47:06 <jcreigh> geezusfreeek++ I didn't know the FFI worked the other way too.
14:47:28 <geezusfreeek> here we go, this is what i'm used to seeing http://www.infosun.fim.uni-passau.de/cl/ghc-5.02-usersguide/ffi-ghc.html
14:47:29 <lambdabot> http://tinyurl.com/6zc5l6
14:47:32 <geezusfreeek> cpfr: ^
14:47:38 <cpfr> thanks
14:47:40 <roconnor> this map snd . filter (foo . fst) idiom seems commo
14:47:41 <geezusfreeek> jcreigh: :)
14:47:42 <roconnor> common
14:48:08 <roconnor> I think I'd be inclined to do a list comprehension
14:48:14 <jcreigh> After all, why would you want to call Haskell from C? :)
14:48:40 <geezusfreeek> jcreigh: my only use case so far is to make SDL work properly on OS X (SDL uses its own main function)
14:48:47 <roconnor> [y | (x,y)<-possibleExists, (room x)]
14:48:58 <lament> maybe you're using haskell a scripting language in your c program
14:49:05 <lament> s/a/as a
14:52:03 <ddarius> Good ol' LP semantics with things like: Î“;Î”,A;Î¨ --> S implies Î“;Î”;A,Î¨ --> S
14:58:08 <mmorrow> what is LP?
14:58:55 <RayNbow> @src ([]) (>>=)
14:58:55 <lambdabot> Source not found. Sorry.
14:58:59 <RayNbow> @src ([a]) (>>=)
14:58:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:59:10 <RayNbow> what was the syntax again? :)
14:59:18 <RayNbow> @src [] (>>=)
14:59:18 <lambdabot> xs >>= f     = concatMap f xs
14:59:20 <RayNbow> ah
14:59:23 <luite> tnx
15:00:07 <RayNbow> so luite, @src type func
15:00:12 <ddarius> Logic Programming
15:00:39 <RayNbow> @src Maybe (>>=)
15:00:39 <lambdabot> (Just x) >>= k      = k x
15:00:39 <lambdabot> Nothing  >>= _      = Nothing
15:00:40 <mmorrow> ah (shudder)
15:01:13 <BMeph> ziman: "You are in a room of twisty little expressions, all alike. There is a lambda here." :)
15:01:34 <RayNbow> or luite, instead of relying on @src... memorize http://arcanux.org/lambdacats/concatMap.jpg
15:01:51 <mmorrow> all the links on the whole first page on google assume the reader needs no explanation for that "LP" stands for...
15:02:28 <luite> oh I'd say linear programming :)
15:02:32 <mmorrow> i was like wait, should i know this?
15:02:39 <mmorrow> i didnt
15:04:29 <hpaste>  roconnor annotated "huge proof" with "more" at http://hpaste.org/8161#a2
15:05:07 <hpaste>  roconnor annotated "huge proof" with "more" at http://hpaste.org/8161#a3
15:05:42 <roconnor> oops
15:05:50 <roconnor> sorry didn't mean to announce that here
15:07:55 <mmorrow> http://arcanux.org/lambdacats/concatMap.jpg: hillarious
15:08:44 <RayNbow> roconnor, care to explain your code a bit? :)
15:09:49 <roconnor> RayNbow: it is generated by the lemma at the beginning
15:09:57 <RayNbow> ah
15:10:43 <Feuerbach> How to compare floating point nubers for equality in HUnit?
15:10:50 <Feuerbach> *numbers
15:11:23 <hpaste>  jre2 pasted "hc-build fails with undefined reference to 'base_DataziList_zdsintersperse_info'" at http://hpaste.org/8162
15:11:42 <jre2> don't suppose anyone knows what base_DataziList_zdsintersperse_info is from?
15:14:56 <shapr> @yow !
15:14:56 <lambdabot> PUNK ROCK!!  DISCO DUCK!!  BIRTH CONTROL!!
15:14:59 <shapr> Excitement!
15:15:06 <shapr> nothingmuch: Yes, you can make fun of me in your slides.
15:16:57 <quicksilver> jre2: you failing to link with --make?
15:17:16 <quicksilver> jre2: that's one of the symbols for Data.List.intersperse from teh base library.
15:17:32 <mmorrow> > let fpEq t x y = abs (x-y) < abs t; (=~=) = fpEq 0.001 in 0.00003 =~= 0.0000000001
15:17:33 <lambdabot>  True
15:18:08 <mmorrow> Feuerbach: usually fp nums are judged eq given a threshold (possibly machine eps)
15:18:48 <Feuerbach> mmorrow: yep, I know. Just wondered if there's something in HUnit for that (seems that no)
15:18:55 <mmorrow> oh, :)
15:19:14 <jre2> quicksilver: failing on distrib/hc-build
15:19:21 <mmorrow> well, it's pretty trivial to implement...
15:19:31 <dmwit> jre2: Probably something missing in the .cabal file.
15:19:46 <Feuerbach> mmorrow: no doubt, already did it :)
15:19:51 <mmorrow> :)
15:20:05 <dmwit> jre2: err... hum, maybe not, Data.List is in base
15:20:30 <dmwit> jre2: Does the .cabal have base in the build-depends line?
15:20:47 <jre2> I don't think there is one
15:20:54 <jre2> since it's not using ghc
15:21:03 <jre2> at least, no longer at that point
15:21:32 <dmwit> I've got to go.  Tell people here how you're building it and with what compiler, though.
15:22:01 <jre2> the hc files were made with ghc 6.6.1 on linux2.4
15:22:38 <jre2> after applying the hc files to the target, the distrib/hc-build is run with gcc 3.2? on linux2.4
15:24:34 <nothingmuch> shapr: ta=)
15:34:30 * pjdelport resorts to #haskell
15:34:48 <pjdelport> non-Haskell question:  does any resident wizard know how to see a socket's listen queue size in Linux (Ubuntu), like netstat -L in BSD?
15:37:51 <pjdelport> it must be possible
15:46:10 <noecksit> hello, could someone recommend me some good working gtk2hs project that uses networking?
15:55:35 <gwern> noecksit: barracuda
15:55:36 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:47 <gwern> @messages
15:55:47 <lambdabot> sjanssen asked 13h 16m 41s ago: Why is there a lambdabot release on hackage labeled 4.1, when the darcs is at 4.0? It is very bad to make releases that don't exist in source control ...
15:56:10 * gwern blahs; blas fails because I have QC 2 installed
15:56:37 <gwern> @tell sjanssen I dunno; that was a while ago. maybe the patches never got applied
15:56:38 <lambdabot> Consider it noted.
15:57:43 <nus> pjdelport, though I don't qualify neither as a resident nor wizard, ANK's iproute2 has ss
15:58:31 <nus> (socket state)
15:58:32 <pjdelport> nus: i couldn't find it in ss's output :(
16:00:59 <reilly> anybody know what a good recent date for HEAD is?  I'm on an intel Mac.
16:01:02 <nus> .oO(is triple negation valid English?)
16:01:29 <SamB> nus: of course
16:01:52 <nus> SamB, I felt it somehow (-:
16:02:05 <SamB> why do you smile upside-down?
16:05:41 <nus> SamB, heh, which of 'am living on antipodal latitude' or 'am restoring the global parenthesis balance' do you like better?-)
16:06:28 <SamB> smling with your eyes closed now is it?
16:06:59 <ledbetter> could be a cyclops with no nose
16:07:05 <Apocalisp> ?hoogle (p a -> t a) -> p m a -> p t a
16:07:06 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
16:07:06 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
16:07:06 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:07:22 <Apocalisp> ?hoogle (p a -> t a) -> p m a -> t m a
16:07:23 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:07:23 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
16:07:23 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
16:07:42 <EvilTerran> Apocalisp, that type doesn't make sense
16:08:02 <EvilTerran> ((p :: * -> *) a -> t a) -> (p :: * -> * -> *) m a -> t m a -- kind mismatch
16:08:32 <Apocalisp> hmm
16:10:34 <Apocalisp> How can I promote an (m a -> m a) to (m [a] -> m [a]) ?
16:10:53 <EvilTerran> ?type liftM (\x -> [x])
16:10:55 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
16:11:03 <SamB> uh
16:11:10 <EvilTerran> oh, wait
16:11:18 <SamB> @type mapM
16:11:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:11:22 <Apocalisp> mapM!
16:11:38 <ddarius> Apocalisp: Such a function would have to be non-total
16:11:44 <SamB> er.
16:11:54 <SamB> @type liftM . fmap
16:11:55 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Functor f, Monad m) => (a -> b) -> m (f a) -> m (f b)
16:12:00 <Apocalisp> ddarius: Why?
16:12:07 <SamB> @type liftM . map
16:12:08 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Functor f, Monad m) => (a -> b) -> m (f a) -> m (f b)
16:12:14 <SamB> @type liftM . Prelude.map
16:12:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
16:12:27 <Apocalisp> pretty close
16:13:05 <Botje> dear lambdabot: please implement closure conversion for me. kthx.
16:13:10 <ddarius> Apocalisp: I guess you could write \_ _ -> return []
16:13:16 <opqdonut> Apocalisp: non-total because you'd have to go m [a] -> [m a] -> [m a] -> m [a]
16:13:31 <opqdonut> the last step is sequence
16:13:38 <opqdonut> and the first would have to be "unsequence"
16:14:17 <ddarius> opqdonut: There's no reason to go to [m a].  The issue is you need a function m [a] -> m a
16:14:38 <Apocalisp> opqdonut: I don't follow that very well at all.
16:14:39 <EvilTerran> could you do something ugly with a MonadPlus/Monoid?
16:14:46 <BMeph> Apocalisp: fmap? ;)
16:14:57 <Apocalisp> ?type fmap
16:14:59 <opqdonut> ddarius: oh?
16:14:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:15:25 <opqdonut> :t liftM msum
16:15:27 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 [m a] -> m1 (m a)
16:15:53 <opqdonut> :t liftM mconcat
16:15:55 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid a) => m [a] -> m a
16:16:19 <opqdonut> and something that wouldn't even restrict a:
16:16:21 <opqdonut> :t liftM head
16:16:23 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m a
16:16:26 <BMeph> ?ty ap . Prelude.map
16:16:27 <ddarius> I don't believe there are any total functions that utilize the (m a -> m a) parameter.  There are many that ignore it.
16:16:28 <opqdonut> what am i missing
16:16:29 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[b1]'
16:16:29 <lambdabot>     Probable cause: `P.map' is applied to too many arguments
16:16:29 <lambdabot>     In the second argument of `(.)', namely `P.map'
16:16:36 <EvilTerran> opqdonut, although that's partial again
16:16:45 <opqdonut> EvilTerran: good point
16:17:03 <BMeph>  ?ty (ap .) . Prelude.map
16:17:19 <opqdonut> ddarius: yeah i believe so too
16:17:25 <opqdonut> just wondering about the reason
16:17:38 <RayNbow> :t fmap
16:17:39 <ddarius> Actually, I'm wrong.
16:17:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:17:58 <opqdonut> oh?
16:18:07 <Apocalisp> ?type fmap fmap
16:18:09 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
16:18:28 <ddarius> You could execute the m [a] parameter and pass return elementOfList to the functional parameter.
16:18:28 <opqdonut> yeah
16:19:01 <ddarius> > foo f mxs = do xs <- mxs; mapM f (return xs)
16:19:01 <lambdabot>  Parse error at "=" (column 11)
16:19:11 <opqdonut> and fmap fmap has the right type when we consider the corresponding functor, right?
16:19:17 <opqdonut> no, no
16:19:23 <ddarius> :t \f -> liftM (mapM f)
16:19:25 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m1, Monad m) => (a -> m b) -> m1 [a] -> m1 (m [b])
16:19:38 <Apocalisp> ?type fmap Prelude.map
16:19:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f ([a] -> [b])
16:19:51 <ddarius> :t \f -> (>>= mapM f . return)
16:19:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m [b]
16:20:05 <ddarius> :t \f -> (>>= mapM (f . return))
16:20:07 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m, Monad m1) => (m1 a -> m b) -> m [a] -> m [b]
16:20:22 <ddarius> It's still a more general type...
16:20:29 <opqdonut> hmh
16:20:36 <Apocalisp> ddarius: Ooh, very nice.
16:20:42 <opqdonut> and using return is kinda cheating
16:21:07 <opqdonut> as that's functionally just (a -> m b) -> m [a] -> m [b]
16:21:16 <opqdonut> right?
16:21:31 <Maciej> Say I have a file importing modules M1 and M2 from package P. Is it possible to unload P in GHCi and instead load M1 and M2 from their source location?
16:21:42 <opqdonut> gah it's getting late
16:21:44 <opqdonut> i'm off to bed
16:21:57 <ddarius> It does likely trivialize it.
16:30:54 <Apocalisp> hrm. It seems to me that if I can generalize (f a -> g a) to a monad s, and call it (s a), then all I would need is mapM.
16:32:44 <ddarius> type F a = f a -> g a isn't even a functor unless f is contravariant
16:33:15 <Apocalisp> f is actually product-1 in my case
16:34:59 <Apocalisp> 1-tuple, I mean
16:35:40 <ddarius> Id is not contravariant
16:37:47 <Apocalisp> doh
16:38:27 <EvilTerran> contravariant... that's "the subtyping goes the opposite way in the type parameter to the type overall", right?
16:39:06 <Maciej> Ok, I think I found a way to do it. But GHCi's command line seems not to accept commands with length>255 chars :-(
16:39:15 <ddarius> EvilTerran: It's related to that, yes.
16:39:39 <ddarius> EvilTerran: The type theory community got the term from the categorical community if my sources are correct.
16:40:53 <SamB> hmm.
16:41:06 <SamB> the Java community may need that word too...
16:41:59 <EvilTerran> my OOP lecturer has used it, i believe, when talking about generics in java
16:43:00 <ddarius> It's been established in the OO world for quite some time
16:46:56 <mapreduce> In the typed OO world, I expect.
16:47:15 <mapreduce> I doubt your average Rubyist or Smalltalker knows or cares what contravariance is.
16:47:50 <SamB> I just meant for talking about array indexing/assignment
16:47:55 <SamB> one of those is contravariant
16:49:31 <SamB> mapreduce: don't smalltalkers also learn typed languages?
16:49:47 <SamB> or at least learn about stuff tricky things like that?
16:50:44 <lament> i have no idea what contravariance is
16:50:48 <mapreduce> SamB: I don't know.  I think one of the reasons to use dynamic languages is to avoid learning typed ones.
16:51:34 <SamB> mapreduce: I thought it was just so you wouldn't have to use types if you didn't feel like it
16:51:51 <lament> eh
16:52:02 <lament> it's not like smalltalk is "a typed language with type safety removed"
16:52:09 <lament> it's a very different data model
16:52:27 <lament> a different world so to say
16:52:33 <SamB> lament: you know that subtyping problem with arrays in Java?
16:52:45 <lament> SamB: no
16:53:22 <EvilTerran> or the subtyping of references in the \ref-calculus
16:53:25 <SamB> the one where it really doesn't make total sense to claim that an array type is a subtype of another just because the corresponding element type is ?
16:53:42 <SamB> EvilTerran: same thing
16:53:46 <lament> SamB: oh, right
16:53:54 <SamB> not that I ever heard of the ref calculus before
16:54:01 <SamB> but a reference is just a really tiny array
16:54:04 <vixey> is that defined in TAPL?
16:54:27 <EvilTerran> vixey, yeah
16:54:39 <mapreduce> Object[] fooked = new String[10]; fooked[0] = new File("/usr/messed/up"); compiles, but runs, with an ArrayStoreException.
16:54:41 <SamB> (did you mean Î»ref calculus?)
16:54:49 <EvilTerran> SamB, yes
16:54:51 <EvilTerran> i think the full name is "simply-typed lambda calculus with references"
16:55:03 <SamB> EvilTerran: well yes
16:55:10 <nus> SamB, one of the reasons maybe it's quite easy to make a connection 'tween OO and untyped lambda-calculus, while it's not so for the typed one.
16:55:13 <SamB> that would be a fairly obvious designation ;-)
16:55:30 <EvilTerran> so much for my attempt to save typing it out :P
16:56:15 <SamB> well, you should have typed the lambda properly
16:56:27 <SamB> so I wasn't thinking you were trying to use some TeX syntax
16:56:29 <EvilTerran> that would take longer than just the words
16:56:45 <SamB> Î» doesn't take that long to type!
16:57:05 <SamB> type C-<space> \lambda C-<space>
16:57:18 <SamB> (after appropriately configuring SCIM)
16:57:39 <mrd> lament: contravariance, etc:  http://www.decidable.org/articles/polymorphism-and-subtyping.html
16:57:40 <lambdabot> Title: Polymorphism and Subtyping
16:58:12 <vixey> Î»
16:58:41 <EvilTerran> now i have one to copy-and-paste!
16:59:17 <vixey> @quote
16:59:17 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
16:59:17 <lambdabot> trigger.
16:59:41 <EvilTerran> ...what
16:59:56 <SamB> but you won't bleed to death until you look at your foot
17:00:47 <lament> sounds like a perfect life
17:01:42 <EvilTerran> ah. laziness. i see what you did there.
17:03:32 <shapr> I'm like that with work too.
17:03:45 <shapr> It's like, I see people doing stuff, but I'm lazy, so I just watch.
17:04:06 <lament> oh, i thought you meant you shoot them
17:04:45 <vixey> shapr, I'm like that too :s
17:05:10 * shapr grins
17:06:23 <augur> huh.. powersets ARE sexy :o
17:06:50 <augur> not that this is REALLY the way to do it but
17:08:08 <augur> pset [] = []
17:08:08 <augur> pset x:xs = (map (\y . x ++ y) (pset xs)) ++ (pset xs)
17:08:24 <augur> i just realized that. i have to agree with mxc_: <3powersets
17:08:27 <vixey> what language is that?
17:08:36 <augur> uh.. my attempt at haskell :p
17:08:40 <augur> lol
17:08:45 <vixey> oh. sory
17:08:56 <augur> is it wrong?
17:08:57 <augur> it probably is
17:09:01 <augur> but you get the idea
17:09:07 <augur> thats the important part
17:18:06 <mrd> augur: filterM (const [False ..])
17:18:21 <vixey> @src iterate
17:18:22 <lambdabot> iterate f x =  x : iterate f (f x)
17:19:08 <koninkje> is there a way to tell ghc to do -prof but excluding certain libraries? (i.e. ones you don't have profiling libraries for)
17:19:42 <SamB> koninkje: impossible
17:19:50 <koninkje> alas
17:20:19 <augur> stop it, you're ruining my discovery of how powersets work :P
17:20:38 <augur> i dont understand this filterM junk :P
17:20:50 <EvilTerran> ?src filterM
17:20:50 <lambdabot> Source not found. That's something I cannot allow to happen.
17:21:27 <bogner> anyone know if list comprehensions like [ c:s | c <- ls, s <- lss ] can be done in python? they don't seem to let me do commas in that language
17:21:50 <SamB> I think you use another for
17:22:44 <cjb> >>> [x**y for x in range(0,5) for y in range(1,6)]
17:23:04 <EvilTerran> how would you filter in such a thing?
17:24:16 <SamB> use if
17:24:38 <EvilTerran> cunning
17:25:09 <bogner> ah, thank you
17:25:26 * EvilTerran means to learn python sometime
17:25:54 <ddarius> mapreduce: I think it is more likely a Smalltalker would know what co-/contra-variance is.  It's not well known in the "mainstream programmer" world.
17:25:58 <cjb> python has generator comprehensions too -- if you use () instead of [], it's lazy.
17:26:08 <bogner> EvilTerran: python is interesting, and powerful, but seems very clunky for many things
17:26:22 <ddarius> mapreduce: Also, the issues with co/contravariance apply whether or not you have types.
17:26:43 <SamB> yes, types just make it a heck of a lot easier to see the issue
17:26:48 <mapreduce> ddarius: Absolutely, but the thinking is probably less formalised.
17:27:07 <mapreduce> I knew the issues years before I heard of contravariance.
17:27:52 <SamB> I was aware of the issue for years before I figured out what contravariance was
17:28:39 <ddarius> SamB: Aware that there were some issues or understood them?
17:28:42 <vixey> I never found python the slightest bit interesting actually
17:28:53 <dibblego> my children can tell me the answer to b + a if they know what a + b is, but they don't know what commutativity is
17:29:04 <SamB> ddarius: had understood them while reading a page about it
17:29:40 <SamB> do they know what "the order-doesn't-make-a-difference" property is?
17:29:52 <SamB> er.
17:30:01 <SamB> unbalanced my quotation marks a bit
17:30:06 <vixey> dibblego, hopefully they will know what commutativity is soon
17:30:07 <dibblego> SamB, they'd probably say something like that if I phrased the question right
17:31:44 <bos> covariance and contravariance are enshrined in RFC760: "In general, an implementation should be conservative in its sending behavior, and liberal in its receiving behavior."
17:32:59 <roconnor> isn't that the policy what crippled the Web?
17:33:03 <roconnor> that crippled
17:33:09 <SamB> well, it can be overdone yes
17:33:21 <bos> the web seems to work for me.
17:33:30 <SamB> bos: seems is the operative word
17:33:35 <ddarius> roconnor: It would have been fine if everyone had followed it.
17:33:59 <roconnor> ddarius: I thought the problem was that browsers wer liberal in different ways
17:34:21 <SamB> yes, the trouble is that they forgot the part where "the implementation should whine at those who send it bad data"
17:34:24 <ddarius> roconnor: Yes, and they are that way because people weren't conservative in what they sent.
17:34:37 <roconnor> ddarius: true
17:34:42 <roconnor> but they weren't aware of this.
17:34:44 <jcreigh> but c'mon, people aren't going to learn unless they have to.
17:34:53 <SamB> hence the whining
17:34:56 <vixey> jcreigh: Not true
17:34:56 <SamB> ;-)
17:35:07 <SamB> vixey: it's true of most peopel
17:35:16 <jcreigh> vixey: most people could not care less about web standards. If it looks okay in IE, that's good enough for them.
17:35:16 <SamB> they may not be aware of the issue at all
17:35:38 <jcreigh> (but this is OT)
17:35:51 <SamB> they might think it's like the Y2K issue or something
17:36:17 <SamB> ... and not realize how much work it took to keep things from going crazy
17:36:34 * ddarius wonders if there is some reason the authors use higher-order unification for this code...
17:37:48 <vixey> what code?
17:38:06 * roconnor thinks the web might be a better place if browsers were conservative in what they recieved.
17:38:29 <SamB> roconnor: I still say whining is better
17:38:45 <roconnor> perhaps
17:38:48 <SamB> since the users tend to get pissed if they can't read something just because the author was a doofus
17:38:52 <SamB> including myself
17:39:09 <SamB> (or especially if it wasn't the author but some software...)
17:39:44 <ddarius> vixey: The code in the LolliMon paper, e.g. the new clause of the pi calculus interpretr.
17:40:08 <vixey> I think it uses harrop clauses instead of horn clauses
17:40:33 <ddarius> vixey: That has nothing to do with what I'm talking about.
17:41:46 <ddarius> vixey: They write proc (new (\x. P x)) -o {exists c. proc (P c)} as opposed to proc (new P) -o {exists c. proc (P c)}
17:42:10 <koninkje> ddarius: which lollimon paper? ("Specifying Distributed Trust..."?)
17:42:14 <vixey> oh, I see
17:42:30 <ddarius> koninkje: "Monadic Concurrent Linear Logic Programming"
17:42:57 <koninkje> dankje
17:46:28 <koninkje> at first blush, the difference between those two just looks like eta-expansion (common for easing the readership, I've found)
17:48:33 <ddarius> koninkje: I actually found it very confusing the first time I read the paper as I didn't realize LolliMon used higher-order unification so I didn't know what the heck was going on.  Eventually I assumed that it was "pattern matching" against the function.
17:49:14 <vixey> has anyone implemented Coquands unification algorithm in haskell?
17:50:39 <shapr> Quands and CoQuands?
17:52:51 <vixey> ohh I meant Huet
17:53:44 <vixey> I saw a lisp version and I guess there's one in sml
17:54:00 <ddarius> vixey: Probably.  Heffalump is probably the best to ask.
17:55:18 <ddarius> I'll probably implement Miller's L_Î» unification at some point, though I may start with just first order unification.
17:57:11 <augur> Quands and CoQuands?
17:57:19 <vixey> sounds nic
17:57:20 <vixey> nice
17:57:23 <augur> *sigh* haskell is so full of crazy names
17:57:25 <augur> :P
17:57:27 <vixey> I haven't seen this algorithm
18:00:51 <ddarius> I'll probably also throw in relevant, affine, and ordered implications and modalities as well.  I'm considering having some kind of scheme for having multiple named contexts.
18:01:54 <bd_> @hoogle printf
18:01:55 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
18:01:55 <lambdabot> Text.Printf :: module
18:01:55 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
18:01:59 <bd_> @hoogle sprintf
18:02:00 <lambdabot> No matches found
18:06:04 <mrd> augur: well, in a powerset, for every element x of the original set, half of the powerset contains x and the other half does not, right?
18:06:27 <augur> yes indeed
18:06:31 <vixey> oh so that's how it works!
18:06:54 <augur> and for every set that doesnt contain that element
18:06:59 <mrd> augur: well, filterM (const [False, True]) says that you should filter elements out half the time, and not filter them out the other half
18:07:03 <augur> there is some other element in that set...
18:07:14 <augur> wha wha?
18:07:29 <sclv> how do I force cabal install to update a package?
18:08:15 <mrd> const [False, True] = \ _ -> [False, True]
18:08:18 <mmorrow> âˆ…
18:08:25 <SamB> ghc-pkg unregister foo
18:08:27 <mmorrow> no
18:08:45 <mmorrow> {âˆ…}
18:09:02 <mmorrow> well iguess both
18:09:27 <sclv> bleh. there should be a cabal option
18:09:49 <mrd> @type filterM
18:09:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:09:56 <augur> right, i figured thats what const does
18:10:10 <mrd> specialize that to lists: filterM :: (a -> [Bool]) -> [a] -> [[a]]
18:10:32 <augur> i just dont see how you can filter using that
18:10:47 <mrd> the [Bool] are the many possible answers the filtering function can provide
18:10:47 <ddarius> augur: Do you know Prolog?
18:10:49 <SamB> augur: well, it's in the list monad
18:11:11 <mrd> the list monad gives you non-determinism, which simply means: many answers
18:11:21 <SamB> augur: so under the multiple-worlds interpretation, in half of the worlds the test returns true regardless, and in the other half it returns false regardless
18:11:22 <augur> i kind of know prolog.
18:11:40 <augur> haskell is designed for quantum physics? :p
18:11:53 <SamB> no, that was the many-worlds interpretation of the list monad
18:11:57 <SamB> ;-)
18:12:00 <mrd> this is non-determinism in the sense of a Non Deterministic Turing Machine
18:12:04 <mar77a> import Atom
18:12:16 <mrd> has nothing to do with quantum computation. we think.
18:12:54 <SamB> well. I'm positive there is some kind of relationship...
18:13:03 <augur> i think i'd need a trace to understand how that can filter a list.
18:13:21 <SamB> augur: a trace would be in the shape of a tree
18:13:25 <mrd> > filter (const True) [1..5]
18:13:26 <lambdabot>  [1,2,3,4,5]
18:13:31 <mrd> right?
18:13:42 <mrd> now suppose you could simultaneously answer True and False
18:13:45 <sclv> did anyone ever write up a tutorial for the galois xml module?
18:13:49 <SamB> > filterM (const [True,True]) [1..3]
18:13:50 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
18:14:11 <mrd> > filterM (const [True, False]) [1..3]
18:14:12 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:14:18 <vixey> > do a <- [[],['x']];b <- [[],['y']];c <- [[],['z']]; return . concat $ [a,b,c]
18:14:19 <lambdabot>  ["","z","y","yz","x","xz","xy","xyz"]
18:14:22 <augur> see, that makes no sense to me
18:14:34 <augur> well
18:14:37 <augur> hold on
18:14:43 <mrd> augur: well, a ND Turing Machine's trace is a tree. you can draw it.
18:14:44 <sclv> I need to do some xml processing and I'm not sure whether to go nuts with hxt, or just to use the galois lib...
18:14:55 <Maciej> > filterM (const [True, False]) [1]
18:14:56 <lambdabot>  [[1],[]]
18:15:04 <augur> so does filterM look at the return value [True,False] of the filter function and say
18:15:11 <SamB> > mapM (const "xyz") [1..3]
18:15:12 <augur> aha! its two values, so I should do something special
18:15:12 <lambdabot>  ["xxx","xxy","xxz","xyx","xyy","xyz","xzx","xzy","xzz","yxx","yxy","yxz","yy...
18:15:29 <mrd> augur: it works on any n values
18:15:37 <augur> oh my god... i dont get it :(
18:15:48 <mrd> did you study non-deterministic turing machines?
18:15:56 <SamB> > mapM (const "xyz") [1,2]
18:15:57 <lambdabot>  ["xx","xy","xz","yx","yy","yz","zx","zy","zz"]
18:16:06 <augur> no, man, i'm no good with the machines.
18:16:23 <Saizan> > [True,False] >>= \b -> if b then return 1 else return 2
18:16:24 <lambdabot>  [1,2]
18:16:33 <SamB> anyone have a game tree generator handy?
18:17:00 * ivanm passes SamB some seeds so that he can grow his own tree
18:17:00 <Saizan> > [True,False,True] >>= \b -> if b then return 1 else return 2
18:17:01 <lambdabot>  [1,2,1]
18:17:05 <mrd> augur: well, start drawing a tree.  the branches from the root are as such: the left branch will have sets containing 1.  the right branch will not.  then recursively do this for 2 and 3.
18:17:17 <augur> right
18:17:24 <SamB> too bad I have no mathematica
18:17:31 <SamB> I bet I could do something neat with mathematica
18:17:37 <augur> but then the filterM function has to collect every leaf node
18:17:41 <mrd> right
18:17:44 <augur> and say that THAT is the filter
18:17:47 <Cale> filterM (const [True, False]) reads as "for each element of the list, regardless of the value, either take it, or drop it"
18:17:53 <mrd> those are all of the /many/ answers
18:17:54 <SamB> Cale: do you have a mathematica?
18:17:56 <koninkje> > filterM (const [f, g]) [a, b, c]
18:17:56 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Bool)
18:17:56 <lambdabot>     In t...
18:17:58 <Cale> SamB: yep
18:18:06 <SamB> do you know the sort of thing I refer to?
18:18:14 <vixey> > filterM (const [f, g]) [a, b, c] :: [Expr]
18:18:14 <augur> hm..
18:18:15 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
18:18:23 <vixey> > filterM (const [f, g]) [a, b, c] :: [[Expr]]
18:18:24 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Bool)
18:18:24 <lambdabot>     In t...
18:18:35 <SamB> i.e, can you make a tree that traces the evaluation of this powerset formulation?
18:18:37 <koninkje> > mapM (const [f, g]) [a, b, c]
18:18:38 <lambdabot>  Add a type signature
18:18:39 <augur> ok, i see abstractly how the filterM (const [True,False]) method works
18:18:40 <vixey> > filterM (const [f, g]) ([a, b, c] :: [Expr])
18:18:41 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Bool)
18:18:41 <lambdabot>     In t...
18:18:44 <Cale> SamB: hmm, probably.
18:18:52 <augur> it's just.. i dont see how it would work in implementation
18:18:52 <mrd> augur: you're used to deterministic computation which proceeds linearly
18:18:54 <augur> but thats ok :D
18:19:05 <vixey> augur: (>>=) = flip concatMap
18:19:09 <mrd> augur: it's just maps and concats actually
18:19:10 <augur> the abstraction works better for me
18:19:25 <SamB> mathematica has a nice renderer
18:19:27 <augur> is it mrd?
18:19:28 <augur> hm.
18:20:21 <cjay> omg. System.FilePath.isAbsolute "~cjay"  -->  False
18:20:23 <mrd> augur: haskell isn't going to solve your NP-hard problems in worst-case P-time ... yet
18:20:31 <cjay> so many pitfalls when dealing with paths
18:20:42 <vixey> "the set of all subsets" ~~> "every element on or off" is the interesting bit
18:20:53 <Cale> SamB: well, it would just be a binary tree with the elements of the powerset at the bottom...
18:20:56 <edwardk> mrd: sure it will, all you have to do is prove P = NP first ;)
18:21:03 <mrd> edwardk: yet!!!
18:21:09 <mrd> vixey: just like binary numbers btw :)
18:21:26 <olsner> aww, but the faq says haskell already does that
18:21:30 <augur> mrd: is there anyway to do a trace of the powerset function?
18:21:31 <SamB> Cale: yes, but the branches would have intermediate expressions
18:21:56 <SamB> augur: I'm trying to talk Cale into doing it in Mathematica ;-)
18:22:01 <vixey> look at the source code
18:22:08 <vixey> the trace will appear
18:22:24 <augur> lol
18:22:57 <koninkje> augur: You could always play with <http://antiope.com/downloads.html>
18:22:58 <vixey> I guess ~~> is simple induction on the size of the set
18:24:12 <mar77a> is there something like default parameters when defining a function?
18:24:18 <Cale> I could probably do it in Inkscape more easily than in Mathematica, if you only need it for a small list :)
18:24:23 <ddarius> mar77a: No.
18:24:25 <SamB> Cale: okay, fine ;-)
18:24:42 <SamB> Mathematica almost makes it really simple though ;-)
18:25:33 <mmorrow> isn't there some language pragma for ghc to accept unicode in src e.g. (g âˆ˜ f) :: âˆ€b. (a â†’ b) â†’ b
18:25:43 <mrd> it accepts UTF8
18:25:47 <mmorrow> (ignoring the fact that the forall probably wouldn;t work)
18:26:12 <edwardk> mmorrow: it should be on by default isn't it?
18:26:30 <mmorrow> i dunno, haven't tried...thanks.
18:26:39 <mrd> not sure what it recognizes as "operators" though
18:26:47 <augur> btw, guys, the esolang channel is not considering making an esolang called Mecofrom
18:26:47 <mmorrow> yeah that' really what i mean
18:26:58 <augur> in which everything, _everything_, has a co-version
18:27:10 <augur> co-expressions, co-instructions (which run in co-time, at right angles to normal time)
18:27:11 <edwardk> i thought it at least was lambda and forall
18:27:13 <SamB> are they nsidering it "?
18:27:15 <SamB> er.
18:27:19 <SamB> nsidering it?
18:27:21 <augur> also
18:27:22 <augur> co-cotime == time
18:27:23 <augur> but
18:27:33 <augur> cocoa-time == a cup of hot chocolate for the programmer
18:27:39 <SamB> co-cotime should be -time
18:28:01 <edwardk> augur: heh, just don't tell them that if its both cartesian closed and co-(cartesian closed) it degenerates to a poset and so becomes pretty much uniniteresting if the semantics mean much of anything ;)
18:28:02 <augur> nah, we already decided against co-time being complex time
18:28:03 <mrd> co-co-x = x?
18:28:13 <augur> because that would mean we'd need mplex time as well
18:28:30 <edwardk> mrd: yeah
18:28:39 <augur> indeed, co-co-x = x
18:28:58 <SamB> augur: then how is it at right angles?
18:29:02 <mrd> Cox cable is complemented by X cable?
18:29:08 <augur> just 2 dimensional time, thats all.
18:29:17 <SamB> coax by ax, you mean?
18:29:26 <augur> which is actually a REAL theory in physics :o
18:29:31 <mmorrow> oh hell yesh
18:29:32 <mrd> wouldn't co-time run backwards and not be experienced?
18:29:43 <SamB> mrd: it would be experienced
18:29:48 <mrd> coexperienced
18:29:51 <augur> exactly
18:29:59 <mmorrow> âˆ€, â†’ work...
18:30:01 <SamB> by co- ... er ... anti-people
18:30:04 <Botje> @pl \x -> return (a,b,x)
18:30:04 <lambdabot> return . (,,) a b
18:30:09 <Botje> duh.
18:30:12 <Botje> thanks, lambdabot!
18:30:25 <mrd> if co-eds go to college, then do eds go to llege?
18:30:36 <SamB> probably
18:30:41 <mmorrow> i'd say
18:30:43 <SamB> eds tend to be pretty stupid don't they?
18:30:45 <edwardk> Heh, this channel is starting to read like my blog ;)
18:30:46 <vixey> why is that edwardk?
18:30:55 <SamB> vixey: co co co
18:31:07 <augur> edwardk: does coedwardk also blog there or does he have his own coblog?
18:31:08 <SamB> is blog -- it is the comonad reader, yes?
18:31:09 <vixey> (ccc and co-ccc cancel out to a poset)
18:31:29 <edwardk> augur: yeah but since my blog is the comonad.reader the coblog is kinda boring, its just about monads.
18:31:48 <SamB> is it called the monad reader?
18:31:48 <augur> but what about the comonad.coreader?
18:31:53 <augur> and the monad coreader?
18:31:55 <mmorrow> edwardk: heh, that reminds me, almost spit coffee on the person next to me when i read: "...leads to a bit of absurdity, especially since I'm using it to capture a relationship no one cares about."
18:32:10 <mmorrow> lol
18:32:22 <edwardk> vixey: its a fairly well known result in category theory, you add that much structure and since you have all sorts of laws to comply with they collapse down to having nothing stronger than a poset that can comply with them all
18:32:27 <augur> perhaps co-shouldn't be distributive in which case you'd also have to have the co-(...
18:32:28 <augur> :P
18:32:31 <edwardk> mmorrow: heh
18:32:40 <vixey> I see
18:32:45 <mmorrow> ;)
18:32:48 * olsner suddenly sees meaning in the word coworker
18:33:03 <edwardk> olsner: hah
18:33:12 <vixey> back to powersets http://en.wikipedia.org/wiki/Image:Hasse_diagram_of_powerset_of_3.svg
18:33:13 <lambdabot> http://tinyurl.com/5pc24k
18:33:14 <edwardk> this explains the productivity of the staff around me
18:33:31 <SamB> lol@coworker
18:34:07 <augur> coolsner has a coword-moment
18:34:34 <olsner> my comind has the corresponding realization about the word worker
18:34:40 <olsner> quite amusing
18:34:52 <cjay> I think I found a bug in System.Directory. canonicalizePath "/tmp/~cjay/foo" --> "/crypto/tmp/~cjay"
18:34:57 <augur> we've decided that
18:35:11 <augur> co(X operator Y) == co-X co-operator co-Y
18:35:43 <augur> which looks suspiciously like inversions of the product of a matrix...
18:39:50 <cjay> is there a place to check whether a bug in a base library has already been reported?
18:40:39 <Cale> http://cale.yi.org/autoshare/filterM.png
18:40:43 <Cale> SamB: like that?
18:41:39 <dmwit> ?where bug
18:41:40 <lambdabot> I know nothing about bug.
18:41:53 <dmwit> ?go haskell trac
18:41:55 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/
18:41:55 <lambdabot> Title: Haskell Prime - Trac
18:42:14 <dmwit> ?go ghc trac
18:42:15 <lambdabot> http://hackage.haskell.org/trac/ghc/
18:42:15 <lambdabot> Title: GHC - Trac
18:42:21 <Cale> > filterM (const [True, False]) [1,2,3]
18:42:23 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:42:23 <dmwit> cjay: There, probably.
18:42:35 <dmwit> Cale: Why does your site take so long?
18:42:38 <cjay> ghc trac seems to be for ghc bugs only, nor?
18:42:44 <dmwit> Cale: Torrenting again? =P
18:42:47 <Cale> dmwit: Is it really slow?
18:42:55 <roconnor> > filterM (const [minBound..maxBound]) [1,2,3]
18:42:56 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:42:56 <Cale> I can't think of a good reason...
18:43:03 <dmwit> cjay: Yes, the base libraries are implemented differently for each compiler.
18:43:09 <roconnor> > filterM (const [minBound..]) [1,2,3]
18:43:10 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:43:11 <cjay> oh, ok
18:43:24 <Cale> > filterM (const [False..]) [1,2,3]
18:43:24 <lambdabot>  Parse error at "False..." (column 17)
18:43:27 <Cale> > filterM (const [False ..]) [1,2,3]
18:43:28 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:43:47 <dmwit> cjay: Incidentally, what was the bug?
18:44:04 * Cale grumbles about the module path separator being .
18:44:06 <cjay> dmwit: 03:34 < cjay> I think I found a bug in System.Directory. canonicalizePath "/tmp/~cjay/foo" --> "/crypto/tmp/~cjay"
18:44:07 <augur> afk getting co-icecream
18:44:09 <augur> :d
18:44:16 <augur> or should i say... co-:d
18:44:27 <Cale> augur: Will you be having that on a co-cone?
18:44:55 <cjay> dmwit: it should not cut the /foo
18:45:08 <augur> on a ne?
18:45:11 <augur> maybe! :o
18:45:12 <dmwit> cjay: That's a weird one, what *should* ~cjay expand to?
18:45:33 <SamB> Cale: is your DNS registration up-to-date?
18:45:41 <Cale> SamB: hmm
18:45:58 <Cale> oh, ouch, it's not
18:46:14 <cjay> dmwit: it's a ordinary directory. ~ seems to be special only at the beginning of paths, at least in zsh and bash on linux.
18:46:19 <Cale> 72.141.220.71
18:46:36 <SamB> so you don't have a low TTL on your DNS record?
18:46:45 <dmwit> cjay: Right, I was just wondering if the bug could be that it was incorrectly replacing ~.
18:47:01 <Cale> It should be low, but I still find that sometimes there are problems with caching.
18:47:20 <SamB> Cale: that looks about right
18:49:28 <cjay> dmwit: I looked at the source, it just calls "realpath" via ffi, so cannot be the library's fault
18:50:32 <Botje> @src foldl
18:50:33 <lambdabot> foldl f z []     = z
18:50:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:51:19 <dmwit> cjay: Well, that's both good and bad.
18:51:22 <dmwit> =)
18:51:41 <cjay> the manpage states "Avoid  using  this  function." :/
18:51:42 <dmwit> ?src foldl'
18:51:43 <lambdabot> foldl' f a []     = a
18:51:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:52:18 <dmwit> cjay: Heh, I guess that warning mostly worked.  People failed to use it so much that a bug got through. =P
18:52:28 <cjay> :)
18:58:23 <mar77a> > (:) 4 []
18:58:24 <lambdabot>  [4]
18:58:27 <mar77a> haaa
18:58:33 <mrd> > (:[]) 4
18:58:34 <lambdabot>  [4]
18:58:53 <roconnor> @src [] return
18:58:53 <lambdabot> return x    = [x]
18:58:59 <roconnor> aww
18:59:06 <roconnor> it should be return = (:[])
18:59:52 <tsuwabuki> @print "abc"
18:59:53 <lambdabot> Not enough privileges
19:00:12 <Cale> > "abc"
19:00:13 <lambdabot>  "abc"
19:00:28 <tsuwabuki> > print "abc"
19:00:29 <lambdabot>  <IO ()>
19:01:47 <mar77a> > []:[[]]
19:01:48 <lambdabot>  [[],[]]
19:05:34 <Botje> > ():[()]
19:05:36 <lambdabot>  [(),()]
19:05:45 <mar77a> why isn't something like
19:05:53 <mar77a> nvm
19:06:23 <mar77a> how can i pattern match against a list
19:06:34 <mmorrow> (1) is there any way to get ghci to accept unicode input, and (2) is there a way to assign unicode chars (e.g. âˆŠ,âˆ©,âˆª) to kbd shortcuts??
19:06:35 <mar77a> empty or not
19:06:42 <dmwit> > let f [1, 2] = 3 in f [1, 2] -- ?
19:06:44 <lambdabot>  3
19:07:07 <dmwit> mar77a: f xs = ...
19:07:14 <dolio> There's -XUnicodeSyntax or something.
19:07:15 <mar77a> d'oh
19:07:19 <mar77a> that was retarded
19:07:38 <dmwit> mmorrow: (1) Upgrade to 6.9, probably?  (2) Yes!  Have a look at "man xmodmap".
19:07:45 <mmorrow> dolio: i have 6.9
19:07:51 <mmorrow> i meant dmwit
19:08:03 <dmwit> I don't know how to do it, I just know it's supposed to be possible.
19:09:13 <mmorrow> awesomely, this compiles and works: http://morrow.jypsis.com/a.hs
19:09:35 <mmorrow> but i cant use any of it in ghci
19:09:52 <dmwit> Oh, it might be your term's fault.
19:10:12 <mmorrow> dmwit: nice, xmodmap noted. my xterm accepts them fine, but not while in ghci
19:10:29 <dmwit> ok
19:10:33 * dmwit is stumped again
19:10:37 <mmorrow> dangit
19:10:40 <dmwit> (Did you try dolio's suggestion?)
19:10:54 <mmorrow> lemmesee
19:11:28 <dolio> He must be using that flag if that source file compiles, no?
19:11:50 <mmorrow> i didnt use the flag, i just tried to :set it in ghci to no avail
19:12:08 <mmorrow> (i didn't use the flag while :loading it)
19:12:15 <dmwit> Also, why is that an -X?
19:12:21 <dmwit> It's not a language extension, is it?
19:12:24 <mmorrow> OPTIONS_GHC
19:12:26 <mmorrow> -X
19:12:32 <mmorrow> LANGUAGE
19:12:35 <mmorrow> (not) -X
19:12:45 <mmorrow> oh, i dunno
19:12:46 <dmwit> (i.e. isn't Unicode syntax allowable by H98?)
19:12:52 <dolio> Yes, it is. Or GHC treats it like one, at least.
19:13:05 <mmorrow> i think the problem in ghci cant handle it, everything else seems to work
19:13:42 <mmorrow> s/in/is/
19:13:46 <dmwit> Oh, maybe it's on by default.  ...if it compiled, and mmorrow didn't know about it, that suggests it is default.
19:13:51 <dmwit> That would be ok by me.
19:14:28 <dons> haskell has reached its highest point ever on tiobe's index, 31st. http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
19:14:29 <lambdabot> Title: TIOBE Software: The Coding Standards Company
19:14:33 <mmorrow> dolio: i guess that'd have to be it (in 6.9.20080504 at least)
19:14:35 <dons> climbing from 50th a year ago.
19:14:42 <dons> erlang's also reached its highest point , at  35.
19:15:05 <dmwit> Pascal get's 8 up arrows?
19:15:11 <dons> yeah, tiobe's dodgy
19:15:13 <gwern> lol TIOBE
19:15:22 <dons> i don't think there's been a Pascal community revival... ;0
19:15:45 <dons> note F# doesn't exist at all -- does anyone use it? :)
19:16:06 <gwern> surely it must, else who's buying the book?
19:16:07 <dolio> They must.
19:16:09 <dons> lisp/scheme, some monster language combination, continues to fall
19:16:17 <dolio> It's the only language that will save you from the impending multi-core apocalypse.
19:16:22 <dons> dolio: :)
19:16:29 <dons> because we all know open source won't do it.
19:16:47 <dmwit> I doubt the margin of error on this thing is small enough for it to be very meaningful.
19:17:03 <dons> well, haskell continues its rise. there's an underlying trend i'm happy with
19:17:05 <dmwit> The 21-50 positions are ranked in tenths of a percent.
19:17:06 <dolio> Writing parallel garbage collectors is too hard.
19:17:18 <dmwit> But yeah, nice that we're moving up.
19:17:20 <dons> blogosphere, ftw
19:17:40 <dons> i'd like more companies to announce things, but that's another story
19:18:08 <gwern> dons: you saw o'reilly's book sales survey? haskell increased slightly; (putting it in Minor Languages, although that's better than O'Caml and Irrelevant Languages)
19:18:21 <dons> gwern: wait till the next oreilly book comes out :)
19:18:36 <mrd> o'reilly has a haskell book already?
19:18:44 <mmorrow> my impression from reading ghc's commentary/something-related is that the parallel garbage collector is either completed and in current HEADs or will be completed by 6.10. Is that correct?
19:19:08 <mmorrow> the gc src is the part of ghc i never look at...
19:19:16 <mrd> I have the same impression
19:19:20 <dons> mmorrow: yeah, its in the ghc head branch
19:19:31 <dons> simonm sorted it out in the first quarter of 08.
19:19:36 <mmorrow> l33t, i'm running || gc
19:21:02 <mrd> mind you it's not concurrent gc. world still stops.
19:21:07 <dons> dcoutts: yeah, hackage2hwn is cabal installable now.
19:21:19 <mmorrow> mrd: yeah, baby steps
19:21:23 <dons> mrd, right. bug someone if that hurts you.
19:21:47 <ddarius> mmorrow: Parallel GC is neither here nor there for concurrent GC.
19:21:48 <mrd> the world stops for no one ... but ghc
19:21:55 <mar77a> > let f (x,y) = x ++ "," ++ "y" in f(2,3)
19:21:56 <lambdabot>   add an instance declaration for (Num [Char])
19:21:56 <lambdabot>     In the expression: 2
19:22:01 <gwern> dons: so who's running hwn now?
19:22:17 <mar77a> i don't quite get this
19:22:30 <mar77a> > let f (x,y) = show (x ++ "," ++ "y") in f(2,3)
19:22:31 <lambdabot>   add an instance declaration for (Num [Char])
19:22:31 <lambdabot>     In the expression: 2
19:22:57 <ivanm> mar77a: haskell doesn't automatically convert numbers to strings
19:23:00 <dolio> That simplifies to 2 ++ "," ++ 3
19:23:08 <ivanm> > let f (x,y) = show ((show x) ++ "," ++ "y") in f(2,3)
19:23:09 <lambdabot>  "\"2,y\""
19:23:13 <ivanm> dolio: no it doesn't...
19:23:18 <ivanm> note that it has "y"!
19:23:21 <dons> gwern: no one, but i'm yet to make an announcement. i'm not sure how to manage the news these days -- there's too much going on for manual editing.
19:23:21 <mmorrow> ddarius: rub it in
19:23:24 <dolio> Oh, well, "y", whatever. :)
19:23:30 <ivanm> > let f (x,y) = ((show x) ++ "," ++ "y") in f(2,3)
19:23:32 <lambdabot>  "2,y"
19:23:43 <dons> gwern: i'd like to transition to automated news via rss
19:23:54 <mar77a> ah
19:23:56 <ivanm> dons: :o
19:23:57 <mar77a> one would think it does
19:23:58 <mmorrow> ddarius: seriously though, that's too bad. at the very least, it freshen the gc srcs some...
19:24:07 <dons> do people like the package feed section on haskell.org?
19:24:07 <ivanm> mar77a: why should it? that isn't type safe!
19:24:13 <mar77a> why not?
19:24:15 <dons> i'm quite happy with it. all 10 lines of haskell to generate that.
19:24:19 <mar77a> it should just call show on it
19:24:22 <ivanm> dons: there's a package feed?
19:24:25 <gwern> dons: hm. where would the blog articles and irc quotes fit in?
19:24:28 <dons> http://haskell.org
19:24:29 <lambdabot> Title: Haskell - HaskellWiki
19:24:29 <ivanm> mar77a: how does it know that it's meant to do that?
19:24:36 <ddarius> mmorrow: As I said earlier, there was already an incremental GC made for GHC.
19:24:42 <mar77a> cause you're using the string concat operator
19:24:44 <dons> gwern: blogs to haskell.org/ blog section, with a feed? or via planet haskell?
19:24:47 <dons> or reddit.
19:24:52 <ivanm> ahhh
19:25:04 <ivanm> dons: planet haskell would be my preference...
19:25:15 <gwern> well, I suppose you could set up a haskell subreddit and tell people to subscribe to the rss feed
19:25:16 <dons> there's a link of that on the front page
19:25:34 <dons> gwern: yeah, that might work, for example
19:26:04 <gwern> and then once everything is rss'ified, simply have a master feed.
19:26:27 <mar77a> :t (++)
19:26:29 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:26:33 <mar77a> ze hell
19:26:44 <ivanm> @source (++)
19:26:44 <lambdabot> (++) not available
19:26:44 <mar77a> @src (++)
19:26:45 <lambdabot> []     ++ ys = ys
19:26:45 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:26:45 <lambdabot> -- OR
19:26:45 <lambdabot> xs ++ ys = foldr (:) ys xs
19:26:46 <lambdabot> -- In lambdabot, this is generalised to:
19:26:48 <lambdabot> (++) = mappend
19:27:06 <ivanm> mar77a: it takes two lists of the same type and appends the first to the second
19:27:06 <mar77a> what's the difference between (++) and (:) ?
19:27:14 <mmorrow> ddarius: so are you saying that that was under active development on an ongoing basis, or that the || gc's improvement over this existin gc is marginal at best?
19:27:15 <koninkje> :t (++)
19:27:17 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:27:23 <koninkje> :t (:)
19:27:25 <lambdabot> forall a. a -> [a] -> [a]
19:27:30 * mar77a shrugs
19:27:38 <ivanm> mar77a: (:) takes a value and a list of that same type, and appends the first value to the list
19:27:41 <dolio> : prepends an element, ++ concatenates two lists (monoids).
19:27:48 <koninkje> [a]->[a]->[a] vs a->[a]->[a]
19:27:53 <ivanm> > 1 : [2..5]
19:27:55 <mar77a> what's a monoid?
19:27:55 <lambdabot>  [1,2,3,4,5]
19:28:00 <mar77a> yeah just got it
19:28:02 <ivanm> > [1..3] ++ [4..6]
19:28:03 <lambdabot>  [1,2,3,4,5,6]
19:28:09 <ivanm> mar77a: good question :p
19:28:18 <ivanm> category theory stuff
19:28:32 <koninkje> mar77a: http://en.wikipedia.org/wiki/Monoid
19:28:33 <dolio> A monoid is a set with an associative binary operation and an identity for that operation.
19:28:33 <ivanm> a list is a type of monad, which is a type of monoid IIRC...
19:28:41 <dolio> Algebra stuff, really.
19:28:50 <ivanm> dolio: so half a group? (i.e. no inverse)
19:28:54 <mar77a> i don't want to know now
19:28:55 <mmorrow> ddarius: in other words, I'm trying to extract some nontrivial (in the big picture) gain from this, tell me if my goal is impossible.
19:29:00 <ivanm> mar77a: lol
19:29:13 <dolio> Yeah, a group is a monoid with inverses.
19:29:17 <ivanm> *nod*
19:29:19 <koninkje> in Haskellish terms it's a particular kind of function (i.e. associative and has an identity)
19:29:26 <ddarius> mmorrow: No, the incremental GC died.  It was never in the main branch.  The point is that parallel GC is about performance, incremental GC is about guarantees.  Concurrent/incremental GCs tend to be much slower than non-concurrent ones.
19:29:30 <dibblego> mar77a, interface Monoid<A> { A append(A a1, A a2); A zero(); }
19:29:34 <Socrates`> dolio: Could you give an example set/operation then?
19:29:40 <dibblego> // plus a law or three
19:30:06 <ivanm> dibblego: possibly a partial order function?
19:30:14 <ivanm> s/dibblego/Socrates`/
19:30:29 <mar77a> a monoid is a hybrid between a monkey and a noid
19:30:31 <dolio> Socrates`: lists with append and the empty list, natural numbers with + and 0, natural numbers with * and 1...
19:30:37 <ivanm> e.g. f x y = x <= y, applied to [0..10]
19:30:44 <Socrates`> I see, thanks
19:31:16 <ivanm> wait, forget my example :s
19:31:17 <shachaf> mar77a: A monoid is just an id that only works on a specific type. :-)
19:31:33 <mar77a> hm, is it possible to write a true 'fst' function?
19:31:41 <ivanm> mar77a: in what way?
19:31:43 <ivanm> @src fst
19:31:43 <lambdabot> fst (x,_) =  x
19:31:44 <mar77a> something like: f (x,..) = x
19:31:49 <dibblego> what's a 'true' one look like?
19:31:49 <ivanm> @src head
19:31:50 <lambdabot> head (x:_) = x
19:31:50 <lambdabot> head []    = undefined
19:31:55 <shachaf> With type-classes, sure.
19:32:01 <shachaf> But you'll have to make an instance yourself.
19:32:05 <mar77a> what i mean is
19:32:07 <ivanm> mar77a: not in general for n-tuples
19:32:13 <shachaf> Use lists if you want variable-length, though.
19:32:13 <mar77a> oh ok
19:32:13 <ivanm> because each one has a different type
19:32:27 <mar77a> i thought it was lazy too
19:32:36 <mar77a> who the hell cares how many elements are there and their type!
19:32:37 <ivanm> ummm.... so?
19:32:44 <mar77a> just gimme the first one
19:32:47 <shachaf> A typle is like data (a,b,c) = (a,b,c)
19:32:54 <ivanm> mar77a: no, tuples aren't really lazy in their structure
19:32:57 <koninkje> er, people who care about type safety?
19:33:03 <ivanm> koninkje: lol
19:33:18 <mar77a> who the hell cares about type safety these days..
19:33:18 <mmorrow> ddarius: ah, I didn't understand the full meaning of incremental in my prev stmnts. So then you must be implying that the situation between the || gc and the conc/incr gc is analogous to that between qsort and msort? Ie we simply moved to qsort from isort.
19:33:20 <ivanm> @remember koninkje <mar77a> who the hell cares how many elements are there and their type! <koninkje> er, people who care about type safety?
19:33:20 <lambdabot> It is stored.
19:33:30 <mar77a> int a = "hello world"
19:33:31 <dolio> People who use Haskell?
19:33:37 <ivanm> mar77a: that's kinda the point of using Haskell rather than python...
19:33:48 <mar77a> never heard of python
19:33:50 <mar77a> wink
19:33:52 <ivanm> and it is generally a good thing, otherwise your functions could go belly up
19:33:57 <koninkje> mar77a: people who like to have proofs of correctness of rtheir programs
19:34:10 <koninkje> s/of r/for /
19:34:15 <ivanm> koninkje: no, you got it wrong... people who like their programs to _run_!
19:34:17 <mar77a> i thought haskell was a true communist in its laziness
19:34:23 <koninkje> ivanm: that too
19:34:30 <ivanm> mar77a: wtf has communism got to do with laziness?
19:34:36 <mar77a> nvm
19:34:37 <koninkje> and people who like their programs to run _quickly_
19:34:37 <ivanm> communism = leninism + marxism
19:34:47 <mar77a> that's not type safe
19:34:54 <mar77a> 8)
19:34:54 <ivanm> koninkje: hmmm... how does type safe == fast?
19:35:04 <cjb> I think we don't have to be so over the top
19:35:05 <Adolfo> Hi, someone can explain me, what "srtInts "    means?
19:35:10 <ivanm> cjb: awww
19:35:16 <koninkje> ivanm: comparing to the safer brands of dynamic typing. One could always go the C route I suppose
19:35:17 <dolio> sort ints?
19:35:18 <ivanm> Adolfo: sort a list of integers would be my guess
19:35:22 <dons> Adolfo: static reference table?
19:35:25 <ivanm> koninkje: true
19:35:30 <Adolfo> yes
19:35:34 <cjb> it is neither true that people use Haskell because they fear their functions would otherwise go "belly up" nor that they use Haskell because it's really fast
19:35:46 <petekaz> I'm building ghc for my debian etch box, is head generally stable? or should I pull the 6.8 branch?
19:35:50 <ivanm> cjb: they're just side-benefits! ;-)
19:35:57 <dolio> dons uses Haskell because it's really fast. :)
19:36:02 <dons> i use it because its really fast. i specifically use it for things i want to be fast.
19:36:06 <olsner> heh, side-effects of using haskell ;-)
19:36:12 <ivanm> dolio: but that's only because he writes the code :p
19:36:20 <dolio> :)
19:36:25 <cjb> dons: if that were true, it wouldn't be so surprising that it's fast to warrant an army of blog posts proclaiming it ;-)
19:36:29 <dons> i really do pick it for jobs i want to run quickly.
19:36:30 <ivanm> olsner: that phrase should never be uttered here!
19:36:44 <dons> cjb: well, the knowledge needs to be disseminated.
19:36:47 <ivanm> dons: so what about jobs that you want to be slow?
19:36:52 <dons> we used to think it was slow. and perceptions take time to change
19:37:02 * dons blames hugs
19:37:03 <ddarius> mmorrow: The difference between non-parallel non-incremental GC, parallel GC and incremental GC is the difference between 2 second pause every few minutes and your program taking 10 minutes to run, 1 second pause every few minutes and your program taking 9.5 minutes to run, 0.1 second pause several times a minute and your program taking 20 minutes to run.
19:37:08 <ivanm> dons: it was slow until you wrote your blog posts? :P
19:37:18 <dons> if hbc and ghc had had the spotlight in the 90s, we wouldn't be in this situtation
19:37:57 <dons> anyway, we've had the top 10 of the shootout for 3 years now
19:37:58 <ivanm> that's it, we need to develop a time-machine just to send a ghc-oriented spotlight back to the 90s! :p
19:37:59 <dons> so 'nuff said
19:38:24 <dons> now its down to hearts and minds
19:38:39 <ivanm> if only "nice haskell" (as in the stuff shown in basic textbooks, etc.) => fast haskell :s
19:38:50 <dons> ivanm: show me its not.
19:39:04 <mrd> generational gc is pretty good at getting rid of noticable pauses
19:39:34 <ivanm> dons: well, "mean xs = sum xs / length xs" looks nice, but as you showed it isn't fast ;-)
19:39:41 <dons> that's slow in every language.
19:39:52 <dons> it just fails sooner in most languages
19:40:02 <dons> so actually, haskell does better than most.
19:40:08 <ivanm> true
19:40:19 <dons> naive /= declarative
19:40:23 <dons> naive /= idiomatic
19:40:35 <ivanm> but it would be nice (albeit probably impossible) if the compiler could auto-optimize that for us :p
19:40:37 <dons> we have to get over this idea that naive code is acceptable.
19:40:42 <ivanm> :(
19:41:02 <mmorrow> ddarius: I see. So, as long as you aren't controlling missiles or a breathing machine, and assuming that those categories are mutually exclusive, we're on top of the world. Obviously we're not. So parallel/incremental is the only way to proceed?
19:41:05 <dons> programming is not a field for the naive
19:41:38 <ivanm> obviously in day-to-day stuff, that much efficiency isn't always required so we _can_ use naive definitions
19:42:07 <ivanm> (i.e. if you want to quickly find the average of 10 numbers that naive mean function would be sufficient)
19:42:16 <dons> right. 95% of code doesn't matter performance wise
19:42:41 <dons> talk to the ruby guys. 100% of code doesn't matter there.
19:42:45 <ivanm> lol
19:42:51 <dolio> Heh.
19:42:52 <dons> and half the world writes javascript
19:43:03 <dolio> Slow runtime is an incentive to write better algorithms. :)
19:43:12 <ivanm> dons: you never answered my question from before... if you use haskell for jobs you want to be fast, what do you use for jobs where speed doesn't matter? :p
19:43:25 <ivanm> dolio: I know that the google people generally prefer _small_ algorithms to fast ones
19:43:34 <dons> ivanm: haskell.
19:43:45 <dons> sometimes shell
19:43:45 <ivanm> because people have to download them each time, so run-time is negligible compared to download time
19:43:48 <ivanm> dons: heh
19:44:24 <dons> e.g. here's a little script i wrote today, http://galois.com/~dons/tmp/Main.hs
19:44:32 <dons> convert rss feed on hackage into a wiki markup
19:44:38 <dons> in the old days i'd use shell
19:44:40 <dons> and perl
19:44:44 <dons> now i just glue together hackage libs
19:44:50 <hpaste>  mar77a pasted "is this possible?" at http://hpaste.org/8164
19:44:54 <dons> note ther'es more imports than lines of code
19:45:01 <dons> that's where we're at now
19:45:17 <ivanm> dons: so whereas python is often touted as a nice language to glue together C libs, you claim that haskell is a nice language to glue together haskell libs? :p
19:45:35 <ddarius> mmorrow: In my opinion, real-time GC for Haskell doesn't make much sense.  As for parallel GC, I don't expect a big gain even on computers with multiple cores.
19:45:36 <dons> right. and haskell's a great C wrapper
19:46:42 <ivanm> only thing is, most people still think haskell is useless because there's no great apps written in it...
19:46:44 <ivanm> silly people :p
19:46:52 <dolio> mar77a: Change the =s to ->s
19:46:57 <hpaste>  mar77a annotated "is this possible?" with "que" at http://hpaste.org/8164#a1
19:47:00 <dons> there are no great ruby apps or python apps
19:47:02 <dolio> Oh, wait.
19:47:12 <ivanm> dons: true
19:47:15 <dons> big killer apps don't matter. just the ability to write lots of different things.
19:47:19 <ivanm> but they have more hype
19:47:21 <dons> all the big apps are still written in C.
19:47:22 <dolio> Lists and pairs aren't the same type, so no.
19:47:36 <ivanm> dons: or C++
19:47:40 <mar77a> boooo
19:47:44 <noecksit> mar77a: i dont think thats possible
19:47:44 <dons> the 'killer apps' model is just a stupid way of evaluating languages
19:47:53 <ivanm> *nod*
19:47:59 <dons> and besides, you pick the domain, there's a haskell app there.
19:48:01 <ivanm> because it's self-fulfilling
19:48:11 <mar77a> are lists and tuples instances of any class
19:48:17 <ivanm> there aren't any great apps, so people don't use the language and thus don't write great apps
19:48:19 <mar77a> (at the same time)
19:48:20 <dolio> mar77a: You can do it with Data.Typeable, technically.
19:48:32 * dons thinks xmonad is great
19:48:33 <mar77a> oO
19:48:35 <ivanm> mar77a: Show, Read, etc.... but they're not useful to you atm :s
19:48:47 <dons> darcs is pretty rocking. it decided the future of dvcs
19:48:52 <ivanm> dons: as do I, but some don't think it's big enough (SLOC?) :s
19:48:57 <koninkje> mar77a: if you want heterogeneous lists, why not use existential types?
19:49:00 <ivanm> dons: darcs was first? :o
19:49:04 <dons> yeah, they want a browser and an OS kernel
19:49:17 <dons> to go along with all the ruby, python, erlang and perl browsers and kernels
19:49:19 <mmorrow> ddarius: Hmm. Since I don't know much about garbage collection, I feel I'm missing something huge here. *Is* there a way to proceed, as in has the haskell gc reached the level of the best of its peers and we're all sitting crashed into the ceiling, or is there some other option/type of gc implicit in your stmnts that is clearly better?
19:49:20 <dons> ivanm: yeah
19:49:41 <hpaste>  dolio annotated "is this possible?" with "Data.Typeable" at http://hpaste.org/8164#a2
19:49:54 <ivanm> dons: lol
19:50:28 <ivanm> @remember dons [talking about killer haskell apps] yeah, they want a browser and an OS kernel to go along with all the ruby, python, erlang and perl browsers and kernels
19:50:29 <lambdabot> Done.
19:50:58 <ivanm> dons: though erlang people mainly seem to be pushing it as a concurrent lang rather than a general purpose lang (as we are) AFAICT
19:50:59 <hpaste>  dolio annotated "is this possible?" with "pattern guards?" at http://hpaste.org/8164#a3
19:51:22 <Cale> I'd like to see a web browser in Haskell which was proven correct :)
19:51:30 <ivanm> Cale: not possible
19:51:41 <ivanm> because you have to deal with IE-based web pages :p
19:51:43 <noecksit> if you were to parse a line of text at a time and extract certain words and numbers out of it, would u go about it by using regular experssions or full fledged parser?
19:51:48 <Cale> ivanm: No you don't :)
19:51:52 <ivanm> heh, true
19:52:06 <ivanm> did you see the post on reddit about what happens if you only allow valid XHTML?
19:52:16 <Cale> Nope.
19:52:25 <Cale> What happens?
19:52:34 <Cale> Almost no pages are available?
19:52:35 <dolio> World peace?
19:52:42 <mmorrow> noecksit: what context(s) is/are these words/nums in?
19:52:52 <ivanm> basically, someone posts a comment that isn't valid in your charset or something... so that page is now invalid
19:52:53 <ddarius> mmorrow: What makes you think GHC's GC is bad?
19:52:55 <Nafai> I was attempting to explain to a friend today the benefits of Haskell :)
19:53:03 <ivanm> and because its hosted, you can't get to the db and delete the comment
19:53:09 <ivanm> so that page is no longer visible
19:53:17 <ivanm> dolio: so yes, you eventually get world peace!
19:53:24 <dons> Nafai: how's that go?
19:53:34 <Cale> ivanm: But that means there's a bug in your application.
19:53:38 <ivanm> Cale: http://diveintomark.org/archives/2004/01/14/thought_experiment
19:53:38 <lambdabot> Title: Thought experiment [dive into mark]
19:53:42 <dons> you have to make it sound easier to solve things, cheap to try, and fun.
19:53:48 <ivanm> oohh, that's 4 years old :o
19:53:50 <Nafai> dons: Given I haven't fully groked Haskell yet, not bad :)
19:53:51 <noecksit> mmorrow: its a string of text that I am receiving from a server, and it represents players in a room, so i want to get the name of the first player then the name of the second player
19:53:51 <dolio> mar77a: Are those sufficient?
19:54:10 <mmorrow> ddarius: heh. i'll take that an opportunity to tie the knot and say l33t i'm running || gc.
19:54:11 <Cale> ivanm: How is the user being allowed to post things which are invalid in the given character set?
19:54:24 <mmorrow> ddarius: thx for the info
19:54:25 <mar77a> dolio: probably but i don't get it
19:54:28 <noecksit> back in my python days i used lookahead regular expressions extensively but they seem messy
19:54:31 <ivanm> Cale: I just skimmed the post :p
19:55:13 <mmorrow> noecksit: if it were at all critical that i don't mess up (and the context wan't line noise), i'd' parse it
19:56:48 <dolio> mar77a: If you want me to explain stuff, I will.
19:56:55 <ivanm> mar77a: why are you wanting to do that anyway?
19:57:05 <mar77a> writting a trully polymorphic function
19:57:15 <Cale> The argument on that page is true, but it isn't really an argument for why clients should accept invalid documents, it's an argument for why server-side application correctness is important.
19:57:19 <mar77a> i want to write a function that will get the maximum
19:57:21 <mar77a> off a list
19:57:26 <mar77a> a tuple
19:57:30 <mar77a> arrays, etc too
19:57:32 <noecksit> mmorrow: yeah, thats what ive been doing so far
19:57:36 <ivanm> Cale: *nod*
19:57:43 <Cale> But saying that it's important to get your application right isn't nearly as interesting, apparently.
19:57:56 <koninkje> mar77a: what's the maximum of (1,"hello", Foo (Foo Bar) Bar))?
19:58:04 <mmorrow> noecksit: nice
19:58:08 <ivanm> mar77a: it's going to be truly polymorphic? OK, give me the maximum of a Boolean, or an integer, or something
19:58:17 <ivanm> you can only take polymorphism so far
19:58:41 <SamB> Cale: well, it's not good for them to suddenly stop accepting the documents that they've been accepting for years with no warning, either
19:58:44 <mar77a> well, tuples aren't a good idea actually
19:58:55 <mar77a> since they're just structures from what i've gathered recently
19:59:00 <dolio> @type Data.Foldable.maximum
19:59:01 <SamB> which is why they should give warnings
19:59:02 <lambdabot> forall (t :: * -> *) a. (Ord a, Data.Foldable.Foldable t) => t a -> a
19:59:02 <mar77a> but how about arrays and list
19:59:12 <koninkje> ivanm: well you /could/ take it that far, but you end up running into the multimethod problem
19:59:21 <ivanm> koninkje: and stupidity :p
19:59:45 <dolio> @instances-importing Data.Foldable Foldable
19:59:46 <lambdabot> Maybe, []
19:59:53 <koninkje> ivanm: well we're doing it... Though just for unification where it's sane
20:00:01 <ivanm> *nod*
20:00:02 <dolio> Arrays are Foldable, too, I'm pretty sure.
20:00:23 <dolio> And trees, and sets, probably.
20:00:34 <koninkje> and Sequences
20:00:39 <dolio> Yep.
20:00:41 <mar77a> ..so
20:00:54 <SamB_XP> @instances-importing Data.Foldable Data.Set Data.Map Data.Sequence Data.Array Foldable
20:00:55 <lambdabot> Array i, Map k, Maybe, Seq, Set, ViewL, ViewR, []
20:00:56 <mar77a> what's the one to rule them all?
20:01:16 <SamB_XP> @instances-importing Data.Foldable Data.Set Data.Map Data.Sequence Data.Array Data.Tree Foldable
20:01:16 <ivanm> one what to rule all what?
20:01:17 <lambdabot> Array i, Map k, Maybe, Seq, Set, Tree, ViewL, ViewR, []
20:01:18 <dolio> foldr/foldMap
20:01:26 <koninkje> Data.Foldable.List -- which I'm still writing out
20:01:48 <mar77a> to get the maximum off a list/array/etc with the same function
20:02:00 <koninkje> Data.Foldable.maximum should suffice
20:02:35 <koninkje> Data.Foldable.List is just for providing all the parts of the list interface that Foldable is lacking
20:07:39 <hpaste>  mar77a pasted "something like this!" at http://hpaste.org/8165
20:17:11 <mar77a> @src unlines
20:17:12 <lambdabot> unlines = concatMap (++ "\n")
20:17:21 <mar77a> @src lines
20:17:21 <lambdabot> Source not found. You untyped fool!
20:24:17 <gubagem> i made my evil problems of let go away, using variable<-return(whatIwant)
20:24:54 <koninkje> why not use "let variable = whatIwant"?
20:25:44 <gubagem> i cant figure out the indentation rules
20:26:07 <koninkje> that code indented just like everything else
20:26:30 * gubagem is crazy and lazy
20:27:22 <koninkje> do foo <- bar
20:27:23 <koninkje>    let variable = whatIwant
20:27:29 <koninkje>    zot variable
20:27:39 <gubagem> ?
20:27:48 <koninkje> indentation...
20:28:04 <gubagem> i keep getting it wrong and keep hpasting the same indentation mistakes :-(
20:28:23 <koninkje> it's the same as what you'd have already only using let/= instead of <-/return
20:28:54 <koninkje> the let version is marginally nicer on the GC since you don't allocate a 'return' cell just to strip it off
20:28:58 <gubagem> do i need a let on every line? do i need ins, do i need to indent the "body" of the lets
20:29:12 <gubagem> s/ins/in
20:29:24 <koninkje> for the do-notation you can leave the "in" off and just keep the same indentation
20:30:15 <koninkje> you can keep the "in" if you want, but it has to be indented further and you'll probably need another "do" afterwards; hence the sugar for being able to leave it off
20:30:20 <gubagem> so i can do "do let variable=whatIwant" then how far do i indent the nextline for contiuning lets
20:30:35 <gubagem> so if i dont use in i dont need another do?
20:30:56 <koninkje> all other lines begin at the same indentation as the "let..."
20:31:24 <gubagem> let StartIndentationFromtheFirstCharacterInThisWord (?)
20:32:39 <koninkje> foo = do let this = that
20:32:39 <koninkje>          f this
20:32:39 <koninkje> bar = do let this = that
20:32:40 <koninkje>            in do f this
20:32:59 <byorgey> gubagem: no, the indentation should start from the beginning of the first thing following the 'do'
20:33:11 <byorgey> if that happens to be a let, everything underneath should line up with the 'l' in 'let'
20:33:15 <koninkje> of course for that example, since f is returning something in the monad, we don't need the second do, but if you have something longer you probably will
20:33:54 <hpaste>  koninkje pasted "for gubagem" at http://hpaste.org/8166
20:34:34 <scott_> In reading about Haskell I've seen a number of people who appear to be pretty familiar with the language say "haskell's not very fast." In the computer language benchmarks game it beats java and CL, so it appears to be. Has GHC only recently been very fast, or is the benchmark game just a fluke? I'm trying to understand why these people might have the impression haskell is slow.
20:34:58 <koninkje> old impressions are hard to break
20:35:07 <hpaste>  gubagem pasted "this gives me an error what am I missing some part of some concept" at http://hpaste.org/8167
20:35:11 <scott_> so that's it, GHC is only recently very fast?
20:35:14 <koninkje> early implementations of Lisp were slow, therefore all functional languages "must be slow"
20:35:30 <geezusfreeek> scott_: i think the problem is that we tend to compare it to C/C++
20:36:07 <geezusfreeek> scott_: not that catching up to C/C++ is not a worthy goal, it's just that in doing so we also give a bad impression because the benchmarks will always be behind
20:36:38 <byorgey> scott_: the other thing is that the speed of a Haskell program is harder to predict until you become more familiar with laziness and the execution model.
20:36:40 <geezusfreeek> i personally think it says a lot that we try to compete with C
20:36:56 <geezusfreeek> positive things, i mean
20:36:58 <byorgey> it's not too hard to write a program which unexpectedly takes longer than you think it should
20:37:01 <koninkje> gubagem: each line you're defining things on needs a "let" when you're in the do-notation
20:37:04 <Nafai> Hi byorgey!
20:37:17 * gubagem thanks koninkje
20:37:20 <byorgey> hi Nafai!  long time no see!
20:37:56 <koninkje> gubagem: also, unless you really need to have those definitions within the monadic block, it's better form to push them out to a where clause
20:38:06 <Nafai> byorgey: Yeah, Iv'e been trying to "focus" more lately
20:38:15 <gubagem> they are sequential
20:38:18 <byorgey> Nafai: did it work?
20:39:03 <byorgey> gubagem: when you say 'they are sequential' you mean each one depends on the previous one?
20:39:03 <Nafai> To a degree, checked off every assigned bug to me today.  That was a good feeling.
20:39:05 <koninkje> gubagem: sequentiality only matters if they have side-effects. The "foo <- return bar" pattern is guaranteed not to have side effects, because return has no side effects
20:39:16 <byorgey> Nafai: congrats!  I love that feeling =)
20:39:22 <Nafai> Yeah, it's been a while.
20:39:48 <byorgey> gubagem: you can define things in any order you like, and they will get computed in the correct order based on the data dependencies.
20:39:55 <byorgey> that's laziness in action! =D
20:40:02 <koninkje> gubagem: if by "sequential" you mean there are data dependencies, Haskell will deal with that for you
20:40:40 <gubagem> lazily, and even if put them out of order?
20:40:43 <ddarius> byorgey: That doesn't even have to be laziness, just mutually recursive binding groups.
20:40:47 <koninkje> gubagem: yes
20:41:05 <byorgey> ddarius: true.
20:41:46 <byorgey> > let x = y; y = 3  in x  -- look, out of order!
20:41:48 <lambdabot>  3
20:41:57 <mmorrow> :t scc
20:41:59 <lambdabot> Graph -> Forest Vertex
20:42:12 <mmorrow> :t flatten
20:42:14 <lambdabot> forall a. Tree a -> [a]
20:42:29 <ddarius> > let a = 'a':b; b = 'b':a in a -- look, no way to "order"
20:42:30 <lambdabot>  "abababababababababababababababababababababababababababababababababababababa...
20:42:39 <mmorrow> :t concat . fmap flatten . scc
20:42:41 <lambdabot> Graph -> [Vertex]
20:44:23 <mmorrow> oh, i guess it should be:
20:44:27 <mmorrow> :t fmap flatten . scc
20:44:29 <lambdabot> Graph -> [[Vertex]]
20:44:37 <koninkje> gubagem: why do east, north, west, and south return numbers instead of Bool?
20:49:08 <noecksit> i think i finally have a handle on monads, what else would it be nice for me to learn in order to grasp haskell better?
20:49:14 <noecksit> are arrows important?
20:49:24 <audreyt> learn applicative functors next :)
20:49:35 <dolio> Arrows don't get much use.
20:49:35 <ddarius> noecksit: Write programs
20:49:57 <dolio> Although maybe with Wadler & co.'s new papers on the subject, they'll get renewed interest.
20:50:06 <mmorrow> noecksit: write a lexer/parser/interpreter for some minilang that you'd actually use irl to do something useful
20:50:45 <noecksit> ddarius : yeah, thats what im doing right but i want to expand my knowledge
20:50:55 <SamB_XP> or to practice for the ICFP contest
20:52:38 <hpaste>  mxc pasted "GADT + type class question" at http://hpaste.org/8168
20:53:03 <mxc> having some trouble with getting the instance declaration correct on http://hpaste.org/8168
20:53:40 <mxc> if anyone would like to take a look, wld appreciate it.  its probably a stupid newbie, GADT question though
20:54:40 <SamB_XP> since when do newbs ask about GADTs?
20:55:09 <Saizan> mxc: what's the error?
20:55:14 <mmorrow> yeah
20:55:31 <mmorrow> i dont see it
20:55:32 <dolio> I suspect you'll have a problem returning an arbitrary MsgBody a in get.
20:55:52 <Saizan> ah, right
20:56:07 <mxc> yeah
20:56:08 <mmorrow> whats get's type?
20:56:24 <Saizan> get :: Get a
20:56:38 <mxc> ideally, get :: MsgBody a
20:56:39 <mmorrow> isn't a an instance of binary?
20:56:44 <mxc> yes
20:56:53 <mmorrow> so...i dont get it
20:56:59 <mxc>     Couldn't match expected type `a' against inferred type `String'
20:56:59 <mxc>       `a' is a rigid type variable bound by
20:57:00 <mxc>           the instance declaration at Com/Lambda/Infra/Messaging.hs:101:16
20:57:00 <mxc>       Expected type: MsgBody a
20:57:00 <mxc>       Inferred type: MsgBody String
20:57:00 <mxc>     In the first argument of `return', namely `(MsgHeartbeat hbDtl)'
20:57:02 <mxc>     In the expression: return (MsgHeartbeat hbDtl)
20:57:07 <byorgey> but  return (MsgHeartbeat hbDtl) requires hbDtl :: String
20:57:08 <mxc> oops, shld have been hpasted, sry
20:57:09 <Saizan> yeah, but get :: Get (MsgBody a) promises to be able to give a MsgBody for every a
20:57:19 <mmorrow> oh, it know the only possible type is String
20:57:26 <Saizan> while the implementation can only give MsgBody String
20:57:44 <mmorrow> sly like a fox that ghc
20:58:09 <Saizan> mxc: i think you've to declare an instance Binary (MsgBody String) where.. instead
20:59:47 <byorgey> that, or add another constructor of type  a -> MsgBody a
21:00:24 <Saizan> in that case MsgBody ~ Identity though
21:00:54 <hpaste>  mxc annotated "GADT + type class question" with "(no title)" at http://hpaste.org/8168#a1
21:01:24 * dolio suggests using -XFlexibleInstances. :)
21:01:30 <Saizan> mxc: yeah, you need to add that flag, and remove the Binary a => contexts
21:01:42 <mxc> yeah, i'm just alawys suspicious that i'm doing something wrogn when I need to add flags
21:02:10 <dolio> H98 is pretty conservative with the class definitions.
21:02:18 <Saizan> no, most of them are benign, relaxing some conservative constraints of h98
21:03:16 <byorgey> Saizan: it's still more expressive than identity, since it allows you to act differently on Strings than on anything else
21:04:35 <dolio> Not easily. You'd have to type case on a in get.
21:04:37 <Saizan> byorgey: except for every value produced by get
21:08:03 * dolio is getting consistently bitten by Agda's coinductive folding rules.
21:08:46 <sclv> any recent experience using the xml libs?
21:09:08 <sclv> they all look pretty maintained at the moment.
21:09:44 <SamB_XP> dolio: apparantly they bite a lot
21:10:08 <SamB_XP> dolio: I'd not expect it to work right for a few days
21:10:22 <SamB_XP> though it might not hurt to keep trying
21:10:26 <sclv> I don't think I need performance, just ability to handle some ugly dtds -- any thoughts on whether hxt's learning curve gives a payoff as opposed to the simple galois lib?
21:11:05 <dolio> SamB_XP: Proving anything about coinductive expressions that aren't just twiddling of co-constructors is very difficult/not possible.
21:11:08 <sclv> also any thoughts on whether building a custom unpickler is worth the effort as opposed to simply using generic xml traversal?
21:11:32 <SamB_XP> dolio: well, you might want to mail the list about it... or you might not...
21:11:42 <SamB_XP> it's clear that there are issues ;-)
21:11:47 <dolio> SamB_XP: From the mailing list traffic I've read, it seems like it's a principled decision rather than a bug.
21:12:08 <dolio> Although Conor advocates being less principled for nicer programming, I guess. :)
21:12:34 <SamB_XP> I'd say anything that leads to most proofs being impossible was based on the WRONG principle
21:12:36 <Saizan> sclv: isn't the main point of xml that there are generic parsers for it?
21:13:03 <SamB_XP> Saizan: parsers, yes
21:13:24 <sclv> well, yeah, but all the libs provide different ways to directly unpickle xml into custom haskell types as opposed to generic trees of elements.
21:13:28 <SamB_XP> that doesn't mean you want to use generic XML representations for the data
21:13:35 <sclv> the question is whether the payoff is worth it.
21:14:01 <dolio> I mean, I can understand the guy who said Agda should stick close to the categorical roots, but they seem to be problematic in practice, currently. From my newbness, at least.
21:14:35 <SamB_XP> well, I'm sure they'll figure out how to make it actually possible to use...
21:15:04 <edwardk> dolio: btw- I loved the partiality monad
21:15:05 <sclv> I'm going to need to translate the xml into a custom data structure for traversal anyway... so I guess the question is really on my end -- i.e. is the structure I'm building easy to derive from the unpickler combinators or would a custom traversal be more expressive.
21:15:23 <dolio> Apparently all these proofs have been done in Coq, but looking at it isn't very helpful to me, because they're all magic instructions for the assistant to do automatic stuff. :)
21:15:36 <SamB_XP> dolio: yeah, I hate that
21:15:41 <dolio> That doesn't translate very well to Agda.
21:16:26 <SamB_XP> it would be sweet if you could get Coq to give a sensible term as a result of this process
21:16:42 <SamB_XP> where by sensible, I mean it doesn't look like it was written by a six year old on drugs
21:16:46 <SamB_XP> with fingerpaint
21:18:22 <sclv> alternately, I could use generic traversals instead... so many options.
21:21:10 <sclv> it seems like there's no real advantage to haxml over hxt at this point though?
21:21:43 <mxc> woohoo
21:21:48 <mxc> thanks everyone
21:25:43 <dolio> Anyhow, it seems like with the explicit unfolding Ulf suggested, I can prove the base cases (are those still what they're called with coinduction?) but not the coinductive cases.
21:26:12 <dolio> Not sure if the reverse is true without unfolding.
21:26:57 <dolio> edwardk: Thanks. I'm closing in on the end of General Recursion via Coinductive types. Although the proofs are getting harder due to the above.
21:27:24 <dolio> Actual definitions seem to be fine, though, luckily.
21:27:32 <dolio> So you can use it, just not prove stuff about it. :)
21:35:16 <SamB_XP> dolio: can you prove co-things about it?
21:35:51 <dolio> Divergence is coinductive, but I can't prove that never diverges.
21:36:28 <dolio> At least, not with the definition of divergence in the paper.
21:36:29 <SamB_XP> that ... definately ... does not sound like it works right
21:37:06 <dolio> I added a constructor to divergence, and got an expression that typed, but the expression that typed wasn't even the one I expected to work.
21:37:20 <dolio> Or, co-constructor.
21:37:57 <SamB_XP> I think we just call them construcors
21:38:04 <SamB_XP> or maybe nstructors
21:38:41 <dolio> Formally they're not constructors, though. That's an illusion. :)
21:39:23 <dolio> At least, not constructors for elements of the coinductive type.
21:41:03 <roconnor> are we talking about that issue with reduction not preserving typing?
21:41:21 <dolio> Yes.
21:41:33 * roconnor finds that very worrying
21:42:38 <dolio> It's quite bizarre.
21:43:02 <dolio> For instance, I can construct a term of type 'unfold f \equiv f'
21:44:03 <dolio> And use 'resp : (a : Set) (x y : a) (f : a -> Set) -> x \equiv y -> f x -> f y'...
21:44:38 <dolio> Presumably to get something of type 'g (unfold x) -> g x' or something like that.
21:45:02 <dolio> But when you use it, instead of getting 'g x' back, you get 'g (unfold x)' again, or something like that.
21:45:16 <dolio> At least, I haven't been able to work it out via that avenue.
21:45:41 <roconnor> I haven't followed the details of what is going on.
21:46:58 <dolio> The one puzzling thing to me is that Coq supposedly has the same situation, but the paper I'm looking at is checked in Coq.
21:47:04 <dolio> So there must be some way around it.
21:47:45 <roconnor> Coq seems to have some problem
21:47:55 <roconnor> normalized terms are no longer typechecking.
21:48:02 <dolio> But a list of tactics for each proof doesn't help me do it in Agda (and the fact that I've never really used Coq probably doesn't help either).
21:48:50 <dolio> Is it a new problem?
21:48:55 <dolio> In Coq, that is.
21:49:15 <roconnor> Apparently.  I'm waiting for one of the Coq theory people to chime in.
21:49:36 <dolio> That might explain it, then. Maybe the proofs in the paper don't work anymore.
21:50:19 <SamB_XP> what, you think the nature of type theory has changed recently?
21:50:51 <dolio> The implementation of Coq may have.
21:51:21 <dolio> His proof of the divergence of never does seem to do some kind of explicit unfolding, I think.
21:51:53 <roconnor> Are we talking about Carpetta's work?
21:51:59 <roconnor> Capretta
21:52:10 <dolio> Yes.
21:53:36 <dolio> http://www.cs.ru.nl/~venanzio/publications/rec_coind.v
21:53:41 <roconnor> I haven't used his technique before.
21:53:58 <roconnor> I'm sure his proofs still check.
21:54:12 <roconnor> This problem in Coq seems very freshly discovered.
21:54:27 <roconnor> But it is still early in the discussion.
21:54:32 <roconnor> it seems very worrying.
21:54:37 <roconnor> normalized terms should still typecheck
21:54:44 <roconnor> preferably with the same type.
21:55:07 <dolio> Coinductive types don't see too much use, I guess?
21:55:56 <roconnor> not so much.
21:56:00 <roconnor> I use them a little.
21:57:00 <roconnor> The strange thing is that although there is a coinductive type, there is no cofixpoint.
21:57:25 <dolio> Where?
21:58:04 <roconnor> the the problem with the normalization producing ill-typed values
21:58:32 <dolio> Oh, you mean you can write problems that don't involve cofixpoints.
21:59:25 <roconnor> the problems we are having don't involve cofixpoints
21:59:28 <roconnor> just matches
21:59:35 <dolio> Right.
21:59:57 <roconnor> oh wait
22:00:00 <roconnor> there is a cofixpoint
22:00:01 <dolio> I'm pretty sure the case is the same in Agda.
22:00:04 <roconnor> maybe I was wrong
22:00:28 <roconnor> ah
22:00:46 <roconnor> but Arnaud seems to have refined the example to remove the cofixpoint
22:00:54 <roconnor> I'll try it out
22:06:02 <roconnor> oh Arnaud is talking about something slightly different
22:12:06 <jre2> since when is lambdabot female?
22:12:37 <roconnor> @where lambdabot
22:12:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:13:15 <XGas> lol
22:13:15 <SamB_XP> jre2: since a long time ago
22:13:45 <sclv> @vixen a/s/l
22:13:45 <lambdabot> 19/f/California
22:14:06 <sclv> all you had to do was ask.
22:14:25 <ivanm> hmmm.... is the server actually hosted in california?
22:15:18 <SamB_XP> well she said the same thing when she was hosted in .au
22:15:31 <SamB_XP> so, if so, that's just a coincidence
22:15:33 <sclv> a girl can dream..
22:15:39 <ivanm> lol
22:21:05 <jre2> so what's the status of Lambdabot 2?
22:21:19 <Lemon> I, too, wonder.
22:21:36 <Lemon> Just yesterday, I tried (unsuccessfully) to compile the current lambdabot.
22:22:44 <jre2> really? I just started downloading the 1655 patches (with --partial even) to mess around with it...
22:22:54 <ivanm> Lemon: from darcs or hackage?
22:22:59 <jre2> darcs
22:23:10 <Lemon> the bot itself from darcs,
22:23:16 <Lemon> its dependencies from hackage.
22:23:20 <ivanm> *nod*
22:25:13 <jre2> anyone know a way (through some reflection voodoo) to figure out the possible pattern matches of a function?
22:28:29 <jre2> er, by that I mean, given say f :: State -> Event -> State = f StateFoo EventFoo = StateBar \n f StateFoo EventBar = StateBaz, return (StateFoo, EventFoo) and (StateFoo, EventBar)
22:29:31 <Apocalisp> How would I flatten [Maybe [a]] into [Maybe a] ?
22:29:47 <ddarius> Haskell doesn't really have any "reflection voodoo"
22:30:24 <int-e> @type catMaybes
22:30:25 <SamB_XP> Apocalisp: what?
22:30:26 <lambdabot> forall a. [Maybe a] -> [a]
22:30:32 <int-e> @type concat . catMaybes
22:30:33 <lambdabot> forall a. [Maybe [a]] -> [a]
22:30:48 <int-e> Apocalisp: what do you want to do with the Nothings?
22:31:23 <jre2> well, given data States = StateFoo | StateBar | StateBaz you can use Data.Generics? to get a list of constructors for States. I was curious how much further it goes though
22:31:35 <Apocalisp> int-e: Good point
22:32:50 <Apocalisp> int-e: I suppose, leave them as Nothings in the target list.
22:32:51 <ddarius> Data.Generics is a mild form of introspection supported by compiler generated boilerplate.  All reflection-like mechanisms, except TH, are like that.
22:33:01 <ddarius> (in Haskell)
22:33:53 <int-e> @type (>>= maybe [Nothing] (map Just))
22:33:55 <lambdabot> forall a. [Maybe [a]] -> [Maybe a]
22:34:24 <int-e> (>>=) is concatMap here, of course.
22:34:45 <Apocalisp> right
22:35:41 <Apocalisp> this is probably not what I want to do
22:35:54 <Apocalisp> seems naff now that I think about it
22:38:30 <Apocalisp> may as well have an empty list rather than a long list of Nothing
22:42:04 <edwardk> @type fmap . (,)
22:42:06 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
22:44:52 <dolio> Well, I managed to prove the divergence of never, but it doesn't pass the productivity checker.
22:46:03 <roconnor> this coinductive stuff looks really really bad.
22:46:27 * edwardk is sad. I had such hopes for it
22:46:59 <byorgey> chin up, lads! it'll work out in the end, you'll see =)
22:47:07 <roconnor> doomed
22:47:10 <roconnor> dooooooooooomed
22:47:16 <edwardk> we're all gonna die!
22:47:19 <edwardk> (eventually)
22:47:48 * byorgey plots to write his dissertation on coinductive types
22:47:53 <roconnor> it looks to my non-expert eyes that we need a comatch that returns Coinductive types.
22:48:07 <roconnor> but that makes no sense in the world of dependent types
22:48:07 <edwardk> hrmm
22:48:12 <roconnor> doooomed
22:48:41 <edwardk> heh codata was so much easier in kata. none of those crufty types to muck it up ;)
22:48:57 <roconnor> I mean the whole concept is borked
22:49:09 <edwardk> =/
22:49:14 <roconnor> ones is supposed to iota reduce to 1:ones
22:49:23 <roconnor> "but only sometimes"
22:49:30 <roconnor> I mean, give me a break.
22:50:17 * byorgey gives roconnor a kit-kat
22:50:34 <roconnor> kiti-kata
22:51:10 * byorgey dreams of kitikatamorphisms
22:51:20 <SamB_XP> "only sometimes"?
22:51:36 <roconnor> yep
22:51:54 * edwardk is reminded. i never did get around to adding prepromorphisms
22:52:19 * SamB_XP goes to bed
22:54:14 <roconnor> I wonder if OTT has this problem.
22:54:34 <roconnor> I think that's it's equality for codata is bisimulation
22:54:56 <roconnor> not sure how that fits with canonicity.
22:56:35 <byorgey> what's OTT?
22:57:02 <dolio> Conor McBride's type theory hotness that Epigram 2 is based on.
22:58:17 <byorgey> ah, got it.
22:58:49 <roconnor> this is going to be a disaster.
22:59:25 <edwardk> roconnor: you are a bright shining ray of sunshine today aren't you? =)
22:59:47 <roconnor> edwardk: it's not every day that normalization fails to preserve types.
22:59:53 <edwardk> yeah
22:59:58 <edwardk> i'll admit its pretty messed up
23:00:26 <edwardk> i'm mostly waiting for the dust to settle to see what you guys figure out
23:00:48 <roconnor> Maybe I should actually read the papers on Coinductive types
23:00:52 <edwardk> i mostly wanted codata to be able to encode anamorphisms, etc.
23:00:58 <roconnor> it isn't actually described in the reference manual.
23:01:21 <roconnor> I use streams for my taylor series coefficents.
23:01:40 <dolio> How are you even encoding functor fixed points into Agda?
23:01:56 <edwardk> dolio: i'm not yet
23:02:18 <dolio> I gave it a brief try, but failed because there's no way to specify that a data type accepts only strictly positive type functions.
23:02:30 <edwardk> dolio: i'm just mostly lurking and trying to figure out when it hits the critical mass needed to encode what I want.
23:03:07 <edwardk> I did a quick hack I think with another haskell type theory thing, I think it was Ivor?
23:03:10 <dolio> so 'data Mu (f : Set -> Set) : Set where in : f (Mu f) -> Mu f' is an invalid definition.
23:03:24 <edwardk> *nods*
23:04:08 <edwardk> I think Ivor lacks the positivity condition (its explicitly mentioned in its README)
23:04:16 <edwardk> or in a TODO or something for it
23:04:19 <dolio> Ah.
23:05:09 <dolio> The only thing I could think of was writing a whole custom universe where everything is strictly positive by construction, but that kind of blows.
23:05:34 <edwardk> *nods*
23:06:10 <edwardk> For now, I'll just code these in Kata and *think* really hard about the types i mean ;)
23:06:22 <dolio> Heh.
23:06:57 <edwardk> Of course I still have an issue describing == and some fairly primitive operators like that ;)
23:08:41 <edwardk> Since I'm currently letting you pretty much rip open any type using its constructors and I use a ton of constructors to fake overloading, any notion of equality has to mention what quotient its taking over the types. It is an interesting moment of 'total clarity' I guess to realize that, but its still a little unnatural.
23:09:05 <Saizan> is there any dependent typed language with structural polymorphism? (if that's how it's called) i.e. where the typechecker knows that Either Int Bool is isomorphic to data IntOrBool = I Int | B Bool
23:10:39 <edwardk> I'm also currently gutting the whole thing to see if I can use wadler and company's arrow calculus as the primitive syntax. (i.e. make 'real lambdas and applications' heavyweight, and decorated with symbols, and make the arrow calculus lambda^dot and dotted application the normal notion of lambda and apply
23:11:01 <edwardk> no types means i don't need to change the translation to accomodate their equivalent of arrowapply
23:11:26 <edwardk> Saizan: fraid not
23:11:50 <edwardk> saizan: you might try to use the generating functions for each functor, if your type system does not allow codata.
23:13:30 <edwardk> saizan: if every structure has bounded size then their k-variate generating functions should describe it completely, then isomorphisms exist between any two functors with the same generating function.
23:15:26 <Saizan> edwardk: uhm, now i need to reread your post on generating functions :)
23:16:12 <edwardk> Saizan: heh
23:16:30 <edwardk> Saizan: that was basically the gist of my post ;)
23:20:56 <Saizan> it's very nice how you can derive catalan numbers.. i would have enjoyed my data structures class a lot more :)
23:21:10 <edwardk> =)
23:21:42 <edwardk> I actually came up with that by accident and then afterwards went, oh, yeah, of course they are the Catalan numbers!
23:22:36 <byorgey> which definition of catalan numbers is this?
23:22:56 <Saizan> http://comonad.com/reader/2008/generatingfunctorology/
23:22:59 <lambdabot> Title: The Comonad.Reader » Generatingfunctorology
23:23:08 <newsham> hi
23:23:16 <newsham> what's the comand reader?
23:23:28 <ivanm> your shell?
23:23:36 <hpaste>  newsham pasted "fact" at http://hpaste.org/8169
23:23:39 <ivanm> it reads the commands you give it and does stuff, does it not?
23:23:56 <newsham> oh a blog
23:24:04 <edwardk> newsham: my blog
23:24:51 <byorgey> ah, indeed! I like how if you define some operations on infinite lists as power series, you can define the catalan numbers as  c = 1 : c^2  =)
23:25:18 <byorgey> I first read that in McIlroy's power series stuff
23:25:29 <newsham> mcilroy's "music of streams" is awesome
23:25:48 <newsham> thats actually how I found haskell.
23:26:01 <byorgey> heh, awesome =)
23:26:03 <newsham> was reading pike's earlier paper on power series
23:26:09 <edwardk> generating functions/formal power series always provoke one of two responses. oh my god thats cool, or more commonly, why the hell would I want to use that? =)
23:26:41 <Saizan> i actually have both reactions :)
23:26:50 <edwardk> hah
23:27:08 <edwardk> ok, so it prompts for some superposition of those two responses ;)
23:27:56 <newsham> http://swtch.com/~rsc/thread/squint.pdf
23:30:00 <newsham> cant find pikes slidedeck on the topic
23:30:18 <edwardk> ah i read this once before
23:31:10 <edwardk> back when i was an evil imperative programmer
23:31:32 <edwardk> now that i'm an evil functional programmer it makes perfect sense ;)
23:31:33 <newsham> http://herpolhode.com/rob/lec3.pdf
23:34:17 <edwardk> how bad do you think it would be to have a language that was 'locally call-by-need' within a CPU, but which if you shared a data structure across CPUs that wouldn't share the thunks, you'd be call-by-name acros CPUs to get over that you'd have to use explicit message passing.
23:34:32 <edwardk> er s/.$/?
23:34:43 <Saizan> (too bad i'm working with graphs at the moment and there's not a nice ADT for them, right?)
23:35:01 <edwardk> saizan: sure there is. you just need species ;)
23:35:23 <Soliah> @seen dibblego
23:35:23 <lambdabot> dibblego is in #jtiger, #scala and #haskell. I last heard dibblego speak 2h 20m 39s ago.
23:35:43 <Saizan> hah, i should have imagined :)
23:37:33 <Saizan> so across cpus you don't get sharing unless you explicitly send the value over?
23:37:54 <edwardk> type SimpleGraph = FunctorialCompose (Product E E) (Product E2 E)
23:37:59 <edwardk> saizan: exactly
23:39:49 <edwardk> saizan: but in exchange i promise to use the global address space coherently between processes so that sending it can probably be just mapping the memory page, you'll be able to avoid TLB flushes if they are both running in shared memory and you get a sort of 'virtual isolation' that you can compromise by sharing stuff with a centralized set of processes running a paxos cluster, processes are not asserted to be running on the same machine.
23:41:10 <edwardk> basically i want to cut the cord on coherence between CPUs to the point where you can split over hardware boundaries more cheaply. anything you need to have be coherently ordered or agreed upon can talk to a set of processes running paxos to ensure stability
23:41:44 <edwardk> it also dramatically decreases the need for inter-core synchronization within a physical machine.
23:42:04 <edwardk> but you lose a lot of the easy parallel ghc primitives
23:42:53 <Saizan> and how is message passing going to be expressed in the language?
23:42:56 <edwardk> sparking has to send a message to a waiting process and make sure all of the attendant data is mapped into its address space.
23:43:11 <edwardk> as a straw man lets say they show up as a form of FRP style events
23:43:44 <newsham> are you talking about shared memory system or message passing?
23:44:14 <edwardk> the easier answer would be to say that they occur in an outermost monad directly as the output of a recieve operation whose semantics can be largely ignored for now
23:44:55 <edwardk> newsham: a bit of a bastard child. you have message passing with shared page freezing to send bigger chunks of data. you can only shared memory immutable data.
23:45:31 <newsham> so like a numa system where the systems can access each others memory, but perhaps at higher cost for remote memory?
23:46:39 <edwardk> yeah with coherence enforced by a protocol that says you only can share things that are frozen and immutable, that means no memo-thunking
23:48:37 <mxc> hm, how can you convert between Strict and Lazy bytestrings?
23:48:42 <edwardk> garbage collection can then run 'per process' ala erlang because of the message passing semantics, immutability says frozen pages can only reference frozen pages since we have no memothunking deriving call-by-need
23:48:57 <mxc> since Data.Binary uses lazy and Network.Bytestring uses strict
23:49:02 <edwardk> mxc: go out to a string and come back? =)
23:49:07 <mxc> ugh
23:49:16 <mxc> was hoping to avoid that
23:49:29 <Saizan> mxc: see fromChunks/toChunks and concat
23:49:35 <mxc> ty
23:50:31 <Saizan> edwardk: so programming in it would be somewhat like erlang?
23:50:32 <edwardk> newsham: i'm mostly trying to see if a small single process FRP can be modeled as an erlang style messaging agent and still have overall lazy semantics.
23:50:37 <edwardk> saizan: yeah
23:50:51 <edwardk> saizan: most likely with some sort of FRP sugar over the message passing
23:51:15 <newsham> sounds interesting.  my brain is hurting trying to think it through
23:52:06 <edwardk> it changes the semantics of FRP slightly, you have to kill global time. to get any synchronization you have to use a process or paxos cluster to aggregate and reshare events
23:52:47 <newsham> can you use a fold to convert 1 bytestring to another?
23:52:50 <edwardk> a single process to aggregate events works fine if you don't need reliability, a (fast/etc) paxos cluster ensures robustness in the face of n process failures given 2n+1 processes to run it
23:53:32 <edwardk> keeping in mind that if most processes exist just as message pumps then just like in erlang they will be vanishingly small and able to be run in physically the same address space on the same cpu
23:54:18 <edwardk> kata is basically a lazy erlang with explicit arity constructors replacing erlangs explicit arity functions.
23:54:37 <edwardk> mostly coz i wanted something that felt haskelly =)
23:55:01 <edwardk> so i'm trying to see if i went all the way back and added back in the parallelism aspect is it interesting
23:55:03 <newsham> if you have a 64bit cpu, you can run lots of processes in the same address space
23:55:08 <newsham> 64bits of address space is pretty large
23:55:12 <edwardk> exactly and a 64 bit address space is assumed
23:55:25 <edwardk> Basically this is a distributed SASOS
23:55:39 <edwardk> with paxos taking on orthogonal persistence
23:56:08 <Saizan> i was hoping for something that can fake more closely lazy eval, i.e. a remote thunk appars as a future value on which you can block while the message passing works for you
23:56:18 <edwardk> variations on the paxos theme give you models for disk storage, etc. which if the FRP sugar is thick enough just looks like an event stream
23:57:25 <edwardk> I think the second paragraph of http://blogs.msdn.com/pathelland/archive/2007/05/20/soa-and-newton-s-universe.aspx says more or less what i feel about trying to make distributed programming feel like non-distributed programming =)
23:57:27 <dolio> @yow!
23:57:27 <lambdabot> I wish I was a sex-starved manicurist found dead in the Bronx!!
23:57:28 <lambdabot> Title: PatHelland's WebLog : SOA and Newton's Universe, http://tinyurl.com/5ha2q8
23:57:40 <Korollary> Heh. Pat Helland.
23:58:12 <dolio> Ah, my method causes problems for both termination and productivity.
23:58:13 <edwardk> I think trying to make distributed programming look like non-distributed programming leads to very leaky abstractions
23:59:01 <Saizan> yeah, it can fail in so much more ways
23:59:21 <edwardk> so embrace the domain ;)
23:59:43 <Korollary> What do you embrace?
