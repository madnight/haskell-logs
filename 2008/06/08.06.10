00:00:13 <^Someone^> It works beautifully!!!
00:00:27 <^Someone^> Now I'll be able to get the answer to  2^32582657 - 1
00:00:28 <^Someone^> :D
00:00:37 <mmorrow> actually, a-z,aa-zz,.. doesn't minimize length...
00:01:33 <mmorrow> a-z, [a-z][a-z], .. would i guess
00:02:19 <^Someone^> It's working...
00:02:19 * dmwit feels confused
00:02:27 <sclv> but telling the difference between aaaba and aabaa doesn't seem like much fun.
00:02:49 <^Someone^> Does that output ever stop...
00:02:55 <Saizan_> i think morrow means that with a larger alphabet you get more uniques with the same length
00:02:58 <dmwit> mmorrow: How about (\i -> fmap (!!i) (readFile "/usr/share/dict/words"))? ;-)
00:03:11 <sclv> much better to use a huge list of metasyntactic vars?
00:03:28 <mmorrow> dmwit: me too, i'm doing the nonsense aerobics with my stream of thought
00:03:32 <sclv> or yeah, rather than letters, concat syllables.
00:03:53 <sclv> although there's always the "oops, accidental swear word" problem.
00:03:53 <dmwit> Or maybe \i -> fmap (!! hash i) (readFile dict).
00:04:01 <mmorrow> dmwit: nice. (seriously) that would be an awesome ppr mode for generating unique vars
00:04:56 <mmorrow> callCC :: ((aardvark -> _20-point) -> aardvark) -> aardvark
00:05:02 <mmorrow> lol
00:05:10 <mmorrow> it's as good as done
00:05:33 <dmwit> hehehe
00:07:01 <mmorrow> Saizan_: exactly
00:07:24 <^Someone^> We will soon have the answer to: (((2^32582657)- 1)*((2^30402457) - 1)) = ?
00:07:53 <sclv> maybe use letters for localvars with limited scope, and words for the things that get used all over the place.
00:08:07 <^Someone^> Or not
00:08:38 <^Someone^> ghc fails :(
00:08:54 <dmwit> ?
00:09:18 <^Someone^> The "answer" turned out to be an even number :(
00:09:21 <mmorrow> sclv: in particular i'm generating tyvars for prettyprinting type sigs from e.g. [a_268, b_29, a_29, ...]
00:10:11 <ivanm> ^Someone^: of the multiplication?
00:10:14 <ivanm> can't be...
00:10:14 <dmwit> ^Someone^: ...that doesn't sound right.  Did you restrict it to Int?
00:10:29 <ivanm> 2^x = even, 2^x - 1 = odd, odd * odd = odd
00:10:39 <^Someone^> Indeed
00:10:50 <^Someone^> So that "answer" is not correct
00:10:54 <ivanm> *nod*
00:11:05 <dmwit> (If you restricted it to Int the solution is simple: let it be Integer instead.)
00:11:07 <^Someone^> putStrLn(show(((2^32582657)- 1)*((2^30402457) - 1)))
00:11:24 <ivanm> @src print
00:11:24 <lambdabot> print x = putStrLn (show x)
00:11:38 <ivanm> ^Someone^: print is easer than putStrLn . show :p
00:11:41 <^Someone^> Ty
00:12:25 <^Someone^> That however does not solve the problem of course
00:12:26 <^Someone^> Lol
00:12:35 <mauke> > (2^32582657 - 1) * (2^30402457 - 1)
00:12:49 <lambdabot> Terminated
00:12:49 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
00:13:11 <ivanm> no...
00:13:16 <ivanm> ^Someone^: try doing this:
00:13:30 <mauke> sjanssen: there is no url for preflex
00:13:36 <ivanm> let x :: Integer; x = .... in print x
00:13:46 <ivanm> that will ensure that it's using Integer rather than Int
00:13:58 <^Someone^> Okay
00:15:44 <^Someone^> ivanm: in print x?
00:16:16 <ivanm> ^Someone^: yes
00:16:37 <ivanm> > let x :: Integer; x = (2^32582657 - 1) * (2^30402457 - 1) in print x
00:16:38 <lambdabot>  <IO ()>
00:16:49 <ivanm> > let x :: Integer; x = (2^32582657 - 1) * (2^30402457 - 1) in show x
00:17:02 <lambdabot>  "
00:17:07 <ivanm> heh
00:17:19 <ivanm> > let x :: Integer; x = (2^32582657 - 1) * (2^30402457 - 1) in x
00:17:31 <lambdabot> Terminated
00:17:52 <mauke> > let x :: Double; x = (2^32582657 - 1) * (2^30402457 - 1) in x
00:17:53 <lambdabot>  Infinity
00:17:53 <^Someone^> ivanm: LargePrime.hs:7:11: parse error on input `='
00:18:01 <mauke> > let x :: Int; x = (2^32582657 - 1) * (2^30402457 - 1) in x
00:18:02 <lambdabot>  1
00:18:23 <ivanm> mauke: lol
00:18:32 <ivanm> ^Someone^: hmmm... hpaste it?
00:18:36 <mauke> ergo infinity == 1
00:18:50 <roconnor> > last $ show (((2^32582657)- 1)*((2^30402457) - 1))
00:18:50 <roconnor> '1'
00:18:52 <ivanm> @slap mauke -- don't be silly!
00:18:53 * lambdabot would never hurt mauke -- don't be silly!!
00:18:55 <roconnor> that's what I get
00:18:56 <ivanm> lol
00:19:03 <lambdabot> Terminated
00:19:07 <ivanm> roconnor: ooohhhh....
00:19:22 <ivanm> ^Someone^: looks like it _is_ odd! :D
00:19:31 <roconnor> Prelude> last $ show (((2^32582657)- 1)*((2^30402457) - 1))
00:19:33 <roconnor> '1'
00:19:50 <roconnor> not exactly the quickest way to figureout the last digit
00:20:27 <roconnor> > odd (((2^32582657)- 1)*((2^30402457) - 1))
00:20:40 <lambdabot> Terminated
00:20:40 <dmwit> > let lastDigit m = [2,4,8,6] !! ((2^m) - 1) in lastDigit 32582657 * lastDigit 30402457
00:20:41 <lambdabot>  Exception: Prelude.(!!): negative index
00:20:45 <dmwit> whoops
00:21:12 <roconnor> Prelude> odd (((2^32582657)- 1)*((2^30402457) - 1))
00:21:12 <roconnor> True
00:21:16 <dmwit> > let lastDigit m = [2,4,8,6] `genericIndex` (((2^m) - (1 :: Integer)) `mod` 4) in lastDigit 32582657 * lastDigit 30402457
00:21:26 <lambdabot>  36
00:21:30 <dmwit> hum
00:22:30 <roconnor> mod 4?
00:22:38 <dmwit> yes?
00:22:53 <dmwit> oh
00:22:55 <dmwit> heh
00:23:36 <dmwit> > let lastDigit m = [1,3,7,5] !! (m `mod` 4) in lastDigit 32582657 * lastDigit 30402457
00:23:37 <lambdabot>  9
00:23:44 <dmwit> double hum
00:23:59 <roconnor> off by one
00:24:01 <dmwit> yep
00:24:24 <hpaste>  ^Someone^ pasted "LargePrime" at http://hpaste.org/8226
00:24:49 <dmwit> indent the second line so that the "x"s line up.
00:24:57 <^Someone^> Ah
00:24:58 <^Someone^> Ty
00:25:17 <^Someone^> That works :D
00:26:26 <^Someone^> As in, it compiles
00:27:04 <olsner> that usually means that it works :D
00:27:28 <^Someone^> Usually
00:29:11 <^Someone^> It's working
00:29:17 <^Someone^> ...and working
00:29:21 <^Someone^> ...and working
00:29:26 <dmwit> Yep, it should print a much bigger number this time.
00:29:43 <dmwit> You're dumping about 8M to your console, I hope it can keep up. =)
00:29:49 <dmwit> err...
00:30:00 <dmwit> Quite a bit more than 8M, actually, now that I think about it.
00:30:41 <dmwit> > 8 * logBase 2 5
00:30:42 <lambdabot>  18.575424759098897
00:30:51 <dmwit> Roughly 20M. =P
00:31:04 <^Someone^> Nice
00:31:05 <^Someone^> :|
00:31:18 <dmwit> > 8 * (8 / logBase 2 5)
00:31:20 <lambdabot>  27.563299716697156
00:31:25 <dmwit> Maybe more. =P
00:31:37 <^Someone^> This just gets bigger and bigger
00:31:41 <^Someone^> Like the output :|
00:31:42 <dmwit> I think it's logBase 2 5 "bits" of information per character printed.
00:31:54 <dmwit> And each character printed is 8 full bits.
00:32:09 <dmwit> So each bit of information stored in the number takes (8 / logBase 2 5) "bits" to print.
00:33:13 <^Someone^> Mem usage of LargePrime.exe: 190,424K
00:33:28 <dmwit> huh
00:33:42 <^Someone^> Dunno
00:33:49 <^Someone^> That's from Task Manager
00:34:02 <dmwit> > 30000000 / 8 / 1024
00:34:04 <lambdabot>  3662.109375
00:34:14 <dmwit> That doesn't sound right.
00:34:51 <dmwit> Does that statistic include both physical and virtual memory?
00:35:05 <^Someone^> I don't think so
00:35:08 <dmwit> Oh... 190,000 *K*!
00:35:15 <dmwit> That sounds high, but plausible.
00:35:17 <^Someone^> (total) PF usage: 706 MB
00:35:29 * dmwit is making lots of little mistakes
00:36:01 <dmwit> ^Someone^: It probably creates a whole new Integer for each digit it outputs. =)  Go go garbage collector!
00:36:32 <^Someone^> WOW
00:36:35 <^Someone^> It finally stopped
00:36:40 <^Someone^> But this still doesn't look right
00:36:45 <^Someone^> The last digit is 5 :(
00:37:33 <mauke> > (2^4 - 1) * (2^8 - 1)
00:37:34 <lambdabot>  3825
00:38:57 <^Someone^> Normal PF usage: 300 MB
00:39:10 <^Someone^> GREAT, that output isn't copying right
00:39:28 <^Someone^> dmwit, is there any way I can make it print the output into a file?
00:39:36 <dmwit> Use >?
00:39:39 <^Someone^> Well there is, I meant, what is that way?
00:39:43 <dmwit> ./program >file.out
00:39:49 <^Someone^> (I no almost absolutely 0 Haskell)
00:39:58 <dmwit> That's not even Haskell, just plain shell.
00:40:04 <dmwit> Oh, you're the one in doze, aren't you?
00:40:14 <^Someone^> I am >.>
00:40:16 <dmwit> I wonder if doze does redirection.
00:40:19 <dmwit> Well no matter.
00:40:22 <mauke> IIRC even command.com did
00:40:23 <dibblego> it does
00:40:34 <dmwit> OK, then use that.
00:40:44 <^Someone^> What's the command?
00:40:54 <dmwit> *blink*
00:40:57 <dibblego> foo > output (iirc)
00:42:38 <Saizan_> or just "writeFile "filename" (show val)" in haskell
00:42:51 <^Someone^> Redirection is working!
00:47:13 <^Someone^> Wow, dmwit
00:47:19 <^Someone^> 18 MB file :)
00:47:23 <dmwit> =)
00:47:35 <dmwit> Predict enough numbers, and one of them will be right. =)
00:47:39 <^Someone^> Lol
00:48:55 <dmwit> > (32582657 + 30402457) * (8 / logBase 2 5) / 8 / 1024 / 1024
00:48:56 <lambdabot>  25.869571788196833
00:48:58 <dmwit> huh
00:49:22 <dmwit> > logBase 2 5
00:49:23 <lambdabot>  2.321928094887362
00:49:35 <dmwit> doh!
00:49:40 <dmwit> > (32582657 + 30402457) * (8 / logBase 2 10) / 8 / 1024 / 1024
00:49:41 <lambdabot>  18.08205470496689
00:49:56 <dmwit> ^Someone^: Is it 18.08 MB? =P
00:51:02 <^Someone^> 18960411b
00:51:12 <dmwit> > 18960411 / 1024 / 1024
00:51:13 <lambdabot>  18.082056999206543
00:51:17 <^Someone^> Hehe
00:51:21 <dmwit> That matches pretty darn well...
00:52:22 <^Someone^> Amazing :s
00:52:31 <^Someone^> I haven't opened it though
00:52:40 <^Someone^> 18 MB... what can I open that in?
00:52:50 <^Someone^> Notepad will go *crash*
00:53:01 <dmwit> Any reasonable text editor should be fine.
00:53:22 <mxc_> {/em reasonable}
00:53:50 * ^Someone^ tries wordpad
00:54:24 <^Someone^> It's opening
00:54:27 <^Someone^> ...and opening
00:54:32 <^Someone^> ...and opening
00:54:32 <^Someone^> Hehe
00:54:43 <^Someone^> YAY
00:54:48 <^Someone^> Last few digits: 9556105600368641
00:54:54 <dmwit> yay!
00:55:10 <^Someone^> Although I have no idea whether that looks right, it at least doesn't look wrong
00:58:12 * ^Someone^ uploads it
00:58:35 <dmwit> To where?  And why?
00:58:45 <^Someone^> To some fastupload site
00:59:00 <^Someone^> So people can see it :D
01:12:52 <^Someone^> http://www.quickfilepost.com/download.do?get=a25c394e0934a44736c960334422bf65
01:12:54 <lambdabot> Title: (2^32582657 - 1) * (2^30402457 - 1) = prime.txt, http://tinyurl.com/56e9a8
01:16:09 <HunterXHunter> x * y can never be a prime number right?
01:16:22 <^Someone^> It's not prime
01:16:36 <^Someone^> Darn, named it wrong
01:16:36 <HunterXHunter> what is it then?
01:16:46 <jsnx_> :q
01:16:52 <^Someone^> It's a HUGE number with only two factors
01:17:01 <^Someone^> *Only 4 factors
01:17:02 <^Someone^> Sorry
01:17:05 <HunterXHunter> i see
01:17:15 <^Someone^> Can be used in encryption
01:17:36 <^Someone^> In some manner
01:17:51 <mmorrow> i think i've got hm unification working, put the (small amount) of code in a darcs repo for the interested: http://morrow.jypsis.com/code/hm/ (the haddock docs are in that dir as well as hscolour-generated html of each src file) :)
01:17:52 <lambdabot> Title: Index of /code/hm
01:22:43 <mmorrow> next on the list is type inference for exps
01:25:04 <Lycurgus> are you albertto morrow?
01:27:35 <mmorrow> no, matt morrow
01:44:10 <Gilly> does Data.Binary have any support for adding new stuff to datatypes and still perceiving the ability to load the old ones (with given defaults for the new ones)
01:44:34 <Gilly> or would some other serialization package be more suitable?
01:45:50 <dmwit> I don't know of any suitable serialization package for that.
01:46:34 <Gilly> well the option would be to make the data type dummy - use just a big map
01:46:50 <dmwit> Adding more constructors is generally not a problem (dunno about Data.Binary's stance on this), but adding arguments to a given constructor could be harder.
01:47:13 <dmwit> Gilly: Yes, that is one possibility.  Though it's a bit sad...
01:47:16 <Gilly> yea and my problem is the latter :/
01:47:44 <Gilly> agreed - it's a bit sad... i lose record field syntax + performance
01:48:21 <Gilly> though in this case i doubt the performance would be a problem even if i used a map
01:48:29 <dmwit> ?go partial knowledge monad
01:48:32 <lambdabot> http://byorgey.wordpress.com/2008/04/17/collecting-unstructured-information-with-the-monoid-of-partial-knowledge/
01:48:32 <lambdabot> Title: Collecting unstructured information with the monoid of partial knowledge « blog  ...
01:48:42 <dmwit> Whoops, monoid, not monad.
01:48:55 <Gilly> then there's the third option - use separate tools to update records on disk (load using data.binary - at the same time adding the new fields and save again)
01:49:07 <Gilly> but it's not too nice either and you got to be careful
01:49:32 <Gilly> though after the program is getting more stabilized this shouldn't be needed to be done too often
01:49:33 <dmwit> Gilly: I don't remember *too* well, but that blog post might have something of interest for you.
01:49:40 <Gilly> i'm going to read it
01:49:54 <dmwit> Gilly: If I recall correctly, it turns "adding arguments to a constructor" into "adding constructors".
01:50:19 <Gilly> hm, interesting
02:02:42 <Feuerbach> is there a floating-point infinity in Haskell?
02:03:08 <Feuerbach> i.e. very huge number
02:03:16 <Saizan_> > 1/0
02:03:17 <lambdabot>  Infinity
02:03:56 <dmwit> :t isInfinite
02:03:58 <lambdabot> forall a. (RealFloat a) => a -> Bool
02:04:28 <dmwit> > read "Infinity" :: Double -- hmm...
02:04:38 <lambdabot>  Infinity
02:06:01 <dcoutts> thetallguy: cool!
02:07:00 <dcoutts> thetallguy: if it helps, I've got a list of a subset of the packages on hackage for which it is possible to generate a consistent install plan using cabal-install
02:07:28 <dcoutts> thetallguy: though once the plan is made ~150 of those fail to actually build for one reason or another
02:08:15 <mm_freak_work> > Infinity
02:08:16 <lambdabot>   Not in scope: data constructor `Infinity'
02:09:19 <mm_freak_work> > -1/0
02:09:22 <lambdabot>  -Infinity
02:09:35 <mm_freak_work> > -1/0 * 0
02:09:36 <lambdabot>  NaN
02:10:02 <mm_freak_work> > -1/0 * (1/0)
02:10:04 <lambdabot>  -Infinity
02:10:12 <mm_freak_work> > -1/0 * (-1/0)
02:10:14 <lambdabot>  Infinity
02:10:52 <mm_freak_work> > (-1/0) ** (1/0)
02:10:54 <lambdabot>  Infinity
02:11:01 <mm_freak_work> > (-1/0) ** 0
02:11:02 <lambdabot>  1.0
02:11:13 <mm_freak_work> hmmâ€¦  that looks inconsistent
02:11:48 <dcoutts> thetallguy: in the last couple days I've added a feature to log summary reports of every build
02:12:01 <mm_freak_work> > (0^0, 0**0)
02:12:02 <lambdabot>  (1,1.0)
02:12:17 <dcoutts> @tell thetallguy oh if you could give me the details on that cabal-install list bug, that'd be great.
02:12:17 <lambdabot> Consider it noted.
02:12:21 <HunterXHunter> > Infinity :: Double
02:12:21 <lambdabot>   Not in scope: data constructor `Infinity'
02:17:04 <dcoutts> cool, another efficient SAT solver on hackage :-)
02:20:17 <Feuerbach> dcoutts: link?
02:20:30 <dcoutts> @ask thetallguy hmm, what cabal-install version is that? looks like an old one. We have quite different formatting for cabal list now which I think is not so confusing.
02:20:31 <lambdabot> Consider it noted.
02:20:46 <dcoutts> @hackage funsat
02:20:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/funsat
02:20:59 <dcoutts> Feuerbach: ^^
02:21:31 <dcoutts> http://haskell.org/pipermail/haskell-cafe/2008-June/044135.html
02:21:31 <lambdabot> Title: [Haskell-cafe] ANN: funsat 0.5, a SAT solver written in Haskell
02:28:46 <cjs> Hm.
02:29:46 <cjs> So I have a list of items on which, if it's complete, I need to do some calculations. If it's incomplete, I return Nothing.
02:30:45 <cjs> It feels kinda monadic, what I want to do, e.g., 'do { a <- getThis; b <-getThat; assertListIsNowEmpty; return calc a b }'
02:31:29 <cjs> If getting a or b fails, or if the list isn't empty, the calculation aborts and Nothing comes out, otherwise I get Just (calc a b).
02:31:49 <quicksilver> cjs: yes, that is certainly the behaviour of the Maybe monad you are describing.
02:31:53 <cjs> (getThis and getThat being things that remove what they get from the list passing through.)
02:32:28 <cjs> But the input is a (possibly empty) list, not a Maybe.
02:32:35 <cjs> Is that possible?
02:36:46 <Zao> cjs: Use the State monad maybe?
02:36:56 <quicksilver> cjs: change the input to be Maybe?
02:37:04 <quicksilver> cjs: you haven't explained the problem well enough I'm afraid.
02:37:30 <quicksilver> if you want getThis and getThat to 'implicitly' feed in from the list
02:37:43 <quicksilver> then you probably want MaybeT State [a]
02:37:51 <quicksilver> (unfortunately MaybeT isn't in the standard libs)
02:38:08 <quicksilver> ErrorT String State [a] is a reasonable compromise if you can't be bothered to write maybeT
02:38:26 <quicksilver> basically you're asking for two different kinds of monadic behaviour
02:38:31 <quicksilver> (a) implicit list feeding
02:38:36 <quicksilver> (b) implicit abort
02:38:50 <quicksilver> fortunately monad transformers are here to let us combine things like that :)
02:39:03 <osfameron> they sound very scary
02:39:04 <cjs> Ok, so I have a list of Quotes. I need several particular types to do a calculation. They all have to be at the same strike price, and I need a Call Bid, Call Offer, Put Bid and Put Offer. If I have all four, and no extras, I can produce a result. Otherwise I produce nothing.
02:39:13 <cjs> Yes, it's exactly that: a combination of the two behaviours.
02:39:27 <cjs> Hmmm. Monad transformers. I knew I was going to hit those one day.
02:39:49 <cjs> I'm happy to write MaybeT; I need the experience.
02:40:34 <dolio> @hackage MaybeT
02:40:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
02:40:54 <quicksilver> I think trying to write your own monad transformer is a hard way to learn how monad transformers work :P
02:41:03 <quicksilver> I'd personally use a prepackaged one
02:41:18 <quicksilver> ErrorT is fine : errorT where you ignore the error message is essentially maybeT :)
02:41:48 <dolio> Oh yeah, that package doesn't have a MonadPlus instance.
02:43:24 <quicksilver> if I remember correctly, MaybeT m a isn't MonadPlus ?
02:43:35 <quicksilver> OtherT Maybe a will be.
02:43:50 <cjs> Hm. Ok, ErrorT sounds ok.
02:44:12 <cjs> Though I didn't really learn how Monads work until I wrote my own monadic parser.
02:44:48 <dolio> MaybeT m a is a MonadPlus. But the package says it doesn't have an instance because it's potentially ambiguous with 'MonadPlus m => MaybeT m'.
02:45:37 <dolio> But that's true of all those sort of classes (MonadReader, MonadState, ...).
02:45:40 <vincenz> @babel de en zusatzliche
02:45:40 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
02:45:51 <vincenz> same error here it seems
02:46:00 <vincenz> anyone know the reason for that ?
02:46:31 <quicksilver> :t mplus
02:46:32 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
02:46:50 <vincenz> dons: sorry I couldn't find it again
02:47:26 <quicksilver> ah yes of course
02:49:10 <dcoutts> @tell thetallguy if you just want a complete list of packages, use the latest cabal-install and $ cabal list --simple-output
02:49:10 <lambdabot> Consider it noted.
02:49:42 <dcoutts> @tell thetallguy or grab the package index reading code
02:49:42 <lambdabot> Consider it noted.
02:59:10 <r3m0t> can I have some algorithm help here. I want to find the longest segment of an [Integer] s.t. all elements in the segment are even
02:59:30 <r3m0t> I implemented it in O(n) with a foldr, but the question wants a divide and conquer solution in O(nlogn)
03:00:56 <opqdonut> i doubt your fold is really O(n) :)
03:01:10 <r3m0t> hmm. yes it is
03:01:11 <opqdonut> ah nvm
03:01:15 <opqdonut> misread the problem
03:01:23 <r3m0t> I actually want the length of the longest segment
03:01:34 <opqdonut> i was thinking "longest constant" subsequence
03:02:48 <opqdonut> how about just halving the list and recursing on both pieces
03:02:52 <r3m0t> seg = maximum . foldr f [0] where f a (b:bs) = (if even a then (b + 1):bs else b:bs)
03:03:17 <opqdonut> and then returning the length and whether the segment is in the end
03:03:18 <r3m0t> yeah, then... oh bah
03:03:20 <opqdonut> or beginning
03:03:28 <opqdonut> so you can combine
03:03:47 <r3m0t> no, I need to have how many there are at the beginning *and* at the end
03:04:04 <opqdonut> ah, true, true
03:05:26 <opqdonut> err, does that seg= you pasted even work=
03:05:28 <opqdonut> *?
03:05:39 <opqdonut> you're never inserting a new 0
03:05:48 <r3m0t> oh, I rewrote it into one line
03:05:59 <r3m0t> seg = maximum . foldr f [0] where f a (b:bs) = (if even a then (b + 1):bs else 0:b:bs)
03:06:25 <opqdonut> :)
03:10:57 <r3m0t> but my foldr was so much nicer ;-)
03:14:58 <dolio> > let seg = maximumBy (comparing length) . filter (even . head) . groupBy ((==) `on` even) in seg . take 100 . randomRs (0, 20) $ mkStdGen 385932
03:14:59 <lambdabot>  [14,2,8,4,8,18]
03:15:10 <r3m0t> :|
03:15:30 <dolio> > let seg = maximum . foldr f [0] where f a (b:bs) = (if even a then (b + 1):bs else b:bs) in seg . take 100 . randomRs (0, 20) $ mkStdGen 385932
03:15:32 <lambdabot>  43
03:15:42 <dolio> Well, I'm wrong, it seems.
03:16:23 <dolio> Oh, wait, snagged the wrong one.
03:16:33 <dolio> > let seg = maximum . foldr f [0] where f a (b:bs) = (if even a then (b + 1):bs else 0:b:bs) in seg . take 100 . randomRs (0, 20) $ mkStdGen 385932
03:16:35 <lambdabot>  6
03:16:41 <dolio> There we go.
03:19:47 <mm_freak_work> yes, everything needs to be haskell and such, but it really sucks bad that code.haskell.org delivers *.hs as text/x-haskell
03:20:07 <mm_freak_work> that way i can't view the source code in the browser but have to download it first
03:20:16 <mm_freak_work> that's way unconvenient
03:20:21 <opqdonut> well configure your browser
03:20:22 <dolio> What should it do?
03:20:36 <r3m0t> text/plain?
03:21:39 <quicksilver> what sucks is that gecko browsers have a 15 year old bug they can't fix
03:21:48 <quicksilver> which means that they can't handle text/foo sanely.
03:21:53 <mm_freak_work> opqdonut: how do i configure firefox to do it?
03:22:05 <quicksilver> however, given how pervasive gecko is, many websites work around it.
03:22:09 <quicksilver> mm_freak_work: you can't. It's shit.
03:22:16 <quicksilver> mm_freak_work: there is a plugin though.
03:22:25 <dolio> Heh.
03:22:37 <mm_freak_work> quicksilver: it would be wrong behaviour IMO, if they just regarded text/* as plain-text
03:22:45 <mm_freak_work> most text/* formats aren't plaintext at all
03:22:55 <quicksilver> it would be right behaviour to offer it as an option or a fallback.
03:23:01 <r3m0t> text/x-postscript anyone?
03:23:19 <mm_freak_work> quicksilver: that might confuse users
03:24:12 <mm_freak_work> remember that firefox is for the masses, and stillâ€¦  there is nothing that prevents text/* from being binary
03:26:03 <audreyt> quicksilver: what is that plugin?
03:28:15 <TSC> audreyt: perhaps http://www.spasche.net/mozilla/
03:28:16 <lambdabot> Title: Mozilla stuff
03:31:02 <mm_freak_work> that's quite useful
03:41:09 <mix25> There is some predefined function that cont elements of an list or something like that
03:41:17 <mix25> ?
03:41:53 <Lemmih> mix25: length?
03:42:28 <mix25> no, i explain me wrong.
03:42:29 <BONUS> length and genericLength
03:42:56 <mmorrow> > foldl' (\m x -> M.insertWith (const (+1)) x m) mempty . randomRs (0::Int,9) . mkStdGen $ 42
03:42:57 <lambdabot>      Occurs check: cannot construct the infinite type:
03:42:57 <lambdabot>       a = M.Map b a ->...
03:43:54 <Saizan_> > foldl' (\m x -> M.insertWith (+) x 1 m) M.empty . randomRs (0::Int,9) . mkStdGen $ 42
03:44:08 <lambdabot>  fromList Exception: Time limit exceeded
03:44:29 <mmorrow> > foldl' (\m x -> M.insertWith (+) x 1 m) mempty . randomRs (0::Int,9) . take 100000 . mkStdGen $ 42
03:44:30 <lambdabot>  Couldn't match expected type `[a]' against inferred type `StdGen'
03:44:46 <mmorrow> > foldl' (\m x -> M.insertWith (+) x 1 m) mempty . take 100000 . randomRs (0::Int,9) . mkStdGen $ 42
03:44:47 <lambdabot>  fromList [(0,9925),(1,9848),(2,9942),(3,10198),(4,10032),(5,9811),(6,10081),...
03:44:50 <mix25> function that cont how many times specific element of an list is repeated. [[1,2,3],[2,3,1],[3,4],[4,5]] = [(1,2),(2,2),(3,3),(4,2),(5,1)]
03:44:56 <mix25> something like that
03:46:01 <r3m0t> mix25: no, but to start off, you could use concat to flatten your list
03:46:11 <r3m0t> > concat [[1,2,3],[2,3,1],[3,4],[4,5]]
03:46:13 <lambdabot>  [1,2,3,2,3,1,3,4,4,5]
03:53:23 <quicksilver> > map (head &&& length) . group  . sort . concat $  [[1,2,3],[2,3,1],[3,4],[4,5]]
03:53:25 <lambdabot>  [(1,2),(2,2),(3,3),(4,2),(5,1)]
03:53:44 <r3m0t> well, that's if you can sort them
03:54:04 <r3m0t> > group . sort . concat $  [[1,2,3],[2,3,1],[3,4],[4,5]
03:54:05 <lambdabot>  Parse error at end of input
03:54:09 <r3m0t> > group . sort . concat $  [[1,2,3],[2,3,1],[3,4],[4,5]]
03:54:11 <lambdabot>  [[1,1],[2,2],[3,3,3],[4,4],[5]]
03:54:32 <quicksilver> r3m0t: I just got what mix25 wants a line above yours :P
03:54:41 <r3m0t> I know, I was just looking at it
03:58:47 <mix25> :t &&&
03:58:52 <lambdabot> parse error on input `&&&'
03:58:55 <mix25> :i &&&
03:59:00 <quicksilver> :t (&&&)
03:59:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:59:21 <quicksilver> mix25: in this context, &&& uses the same input for two functions, and puts the answers in a tuple.
03:59:43 <quicksilver> > ((+1) &&& (*2)) 5
03:59:45 <lambdabot>  (6,10)
04:00:13 <mix25> Where is defined &&& ?
04:00:32 <wjt> @index (&&&)
04:00:33 <lambdabot> Control.Arrow
04:01:28 <mix25> thanks
04:24:01 <mix25> @index (>>>)
04:24:01 <lambdabot> Control.Arrow
04:24:08 <r3m0t> :t (>>>)
04:24:11 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
04:24:29 <r3m0t> isn't that composition
04:25:15 <r3m0t> > (  ((*2) . (+1)) 5 , ((*2) >>> (+1)) 5)
04:25:16 <lambdabot>  (12,11)
04:25:44 <r3m0t> > (  ((*2) . (+1)) 20    ,      ((+1) >>> (*2)) 20    )
04:25:46 <lambdabot>  (42,42)
04:25:47 <mix25> But i can't understand where is the definition, in Control.Arrow is only the headline
04:26:40 <r3m0t> it depends on what type of Arrow you have
04:26:52 <r3m0t> look for "instance Arrow (->)"
04:27:03 <r3m0t> that defines how >>> works on functions
04:27:03 <opqdonut> ?src (->) (>>>)
04:27:04 <lambdabot> f >>> g = g . f
04:27:12 <r3m0t> right, there you go
04:27:16 <mix25> ah i see it
04:48:09 <quicksilver> (>>>) is backwards composition, yes.
05:01:01 <maltem_> Did I get this dirty sketch of finger trees about right? http://farm4.static.flickr.com/3099/2567674094_c923a66f77_b.jpg
05:10:01 * dcoutts_ tries to cabal install happs on windows...
05:10:11 <quicksilver> maltem_: I think so.
05:11:46 <maltem_> quicksilver, thx
05:14:40 <Saizan_> dcoutts: it will fail. the .cabal file is patched only in the darcs repo iirc
05:14:59 <dcoutts_> Saizan_: oh? it works on linux at least
05:15:17 <Saizan_> dcoutts_: yeah, i meant on windows
05:15:29 <dcoutts_> ah, it seems to depend on the unix package :-)
05:16:23 <dcoutts_> Saizan_: actually it doesn't really matter, I'm only really testing cabal-install itself on windows
05:16:42 <dcoutts_> I just want complex hierarchies of packages, if some fail, all the better
05:17:06 <Saizan_> ok, then :)
05:19:27 <dcoutts_> hmm, weird
05:19:32 <dcoutts_> registering fails
05:21:24 <hpaste>  dcoutts pasted "registering packages on windows" at http://hpaste.org/8229
05:21:34 <dcoutts_> Igloo: ever seen this ^^
05:22:13 <Igloo> dcoutts_: Nope
05:22:39 <dcoutts_> Igloo: I bet it is because cabal itself reads that file and then it's not closed before ghc-pkg tries to rename the open file
05:22:56 <dcoutts_> Igloo: but it's weird because we should fully read the whole file so it should be closed
05:24:00 <dcoutts_> ahhh
05:24:13 <dcoutts_> case reads content of
05:24:14 <dcoutts_>   [(pkgs, _)] -> return (db, pkgs)
05:24:38 <dcoutts_> that _ means we could have trailing chars and so not consume the whole file and thus close it
05:26:41 <quicksilver> always case reads of [(foo,"")]
05:26:41 <quicksilver> :P
05:26:57 <dcoutts_> well,  case reads of [(foo, s)] | all isSpace s
05:27:19 <Igloo> Or better still, a nice wrapper that give you a Maybe a
05:27:24 <quicksilver> > reads "34   " :: [(Int,String)]
05:27:25 <lambdabot>  [(34,"   ")]
05:27:29 <quicksilver> fair point
05:28:36 <dcoutts_> or withFile to guarantee you thing
05:28:51 <dcoutts_> things, but I can't use that since it's in ghc-6.8 only
05:28:57 <dcoutts_> and Cabal has to build with ghc-6.4
05:29:19 <maltem_> People, call me crazy, but to me, drawing colored graphs is the key step in reading a paper.
05:31:49 <dcoutts_> doh! cabal install cannot install itself on windows
05:32:03 <dcoutts_> because you cannot overwite/replace/rename open files on windows
05:32:14 <dcoutts_> and of course cabal.exe is open when it is running
05:32:26 * dcoutts_ has met this issue before
05:32:30 <Spark> you can move it i think
05:32:34 <dcoutts_> nope
05:32:38 <Spark> think you can
05:32:44 <Spark> as long as it's just a local file system move
05:32:53 <pejo> maltem, working actively with the material is a very good way to improve the understanding of it, atleast if we're to believe the pedagogics researchers.
05:32:54 <Spark> not a copy/delete move
05:34:44 <pejo> dcoutts, is the cabal hacking you're doing somehow included in your thesis, or all in your sparetime?
05:35:16 <dcoutts_> Spark: I stand corrected. I think that must be new in win2k or XP though. I remember having this problem before when I worked at a company on an installer/upgrader that had to be able to upgrade itself
05:35:24 <dcoutts_> pejo: oh, spare time :-)
05:45:19 <maltem_> peho, heh, I think we don't need the pedagogics researchers exactly for that
05:45:25 <maltem_> s/peho/pejo/
05:47:10 <gwern> @seen cale
05:47:11 <lambdabot> I saw cale leaving #ghc, #haskell-overflow and #haskell 2h 17s ago, and .
05:47:24 <gwern> dcoutts_: incidentally, did the debian/ fix make it in yet? you were going to put it in the 1.4 branch iirc
05:47:38 <dcoutts_> gwern: yep
05:50:05 <gwern> great
05:50:09 <gwern> @seen byorgey
05:50:09 <lambdabot> byorgey is in ##logic, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 10h 57m 43s ago.
05:52:08 <hpaste>  dogdrool annotated "function to find all "straights" in a list of cards" with "A version of the straights function that uses foldr." at http://hpaste.org/8225#a1
05:52:42 <dogbite> thanks to dmwit -- was a lot of help last night.
06:02:06 <^Someone^> My friend is having trouble installing lambdabot
06:05:56 <^Someone^> That is to say he has no idea how to install it
06:07:12 <^Someone^> On windows
06:10:09 <ivanm> ^Someone^: it's not the easiest app to install...
06:10:19 <^Someone^> Understood
06:10:40 * ivanm hasn't managed to install in on linux...
06:10:50 <Saizan_> i'm not sure if it works on windows
06:13:32 <^Someone^> I found something but can't make it work: http://www.alpheccar.org/en/posts/show/59
06:13:32 <lambdabot> Title: Colorized lambdabot for Windows
06:18:13 <gwern> ^Someone^: that is not even the right darcs repo for lambdabot, so put very little store by that post
06:18:41 <Zao> Hrm, Opera seems to fail rather spectacularly at navigating to anchors in the haddock docs... http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3AfindIndex
06:18:43 <lambdabot> http://tinyurl.com/yhrw65
06:19:08 <Zao> Navigating to an anchor seems to be a no-op :(
06:19:08 <gwern> ^Someone^: 'we' are sort of trying to replace lambdabot, actually
06:19:58 <^Someone^> Who's we?
06:21:22 <gwern> ^Someone^: well, I'm working on it. another fellow has his own IRC bot which may be suitable for building up into a replacement; and a few others have expressed agreement
06:23:29 <pejo> Zao, tried reporting it to Opera? They're usually quite interested in making things work I think.
06:23:54 <pejo> Zao, (just give a link to something that shows the problem)
06:23:56 <^Someone^> I see
06:27:24 <^Someone^> But meanwhile?
06:28:47 <gwern> meanwhile? you're fubar'd unless you can get it running yourself
06:29:22 * gwern doesn't mean to be discouraging, but better to know upfront than to flail around and wind up blaming haskell for lambdabot's sins
06:29:38 <gwern> (anyway, nap time)
06:30:02 <slavik> where can I read about operators in haskell?
06:30:12 <mauke> the report
06:31:37 <quicksilver> or the library docs
06:31:41 <quicksilver> if you're after particular ones
06:34:44 <slavik> I am looking for the modulo operator
06:34:47 <Zao> pejo: No, not yet. I installed it today, after a period of IE7.
06:34:53 <Zao> :t mod
06:34:55 <lambdabot> forall a. (Integral a) => a -> a -> a
06:35:09 <Zao> > mod 21 4
06:35:10 <slavik> I want to write a function that counts the number of trailing zeroes in a number
06:35:11 <lambdabot>  1
06:35:13 <slavik> ahh
06:35:15 <slavik> ty
06:35:25 <Zao> It has a friend function div, that is integral division.
06:35:45 <Zao> :t divMod -- there's also divMod that does both
06:35:47 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
06:36:19 <Zao> quot, rem and quotRem does the same, but behaves differently with negative numbers.
06:39:06 <slavik> let trailz n = if (mod n 10 == 0) then (trailz n/10) +1 else 0
06:39:15 <slavik> what am I doing wrong with the recursive call?
06:39:51 <slavik> I want to call trailz with (n/10)
06:39:59 <slavik> basically, I am counting trailing zeroes
06:40:39 <conal> slavik: trailz (n/10)
06:41:56 <hpaste>  slavik pasted "trailing zeroes" at http://hpaste.org/8230
06:41:58 <ziman> slavik, and use n `div` 10
06:42:05 <slavik> I see
06:42:10 <ziman> (which is integral division)
06:42:31 <mm_freak> > let tzeroes n = length . takeWhile (== 0) . map (`mod` 10) . iterate (`div` 10) n in tzeroes 23000
06:42:32 <lambdabot>   add an instance declaration for (Integral [a])
06:42:32 <lambdabot>     In the expression:
06:42:32 <lambdabot>      ...
06:42:46 <mm_freak> > let tzeroes = length . takeWhile (== 0) . map (`mod` 10) . iterate (`div` 10) in tzeroes 23000
06:42:48 <lambdabot>  3
06:43:55 <maltem_> slavik: The type error says that ghc does not know what type to choose for 10, because mod and (/) work on integral vs. fractional types
06:45:16 <slavik> I see
06:45:28 <mix25> @index (&&)
06:45:28 <lambdabot> Data.Bool, Prelude
06:45:39 <slavik> can I do (div n 10) ?
06:47:04 <maltem_> @faq Is (div n 10) OK?
06:47:04 <lambdabot> The answer is: Yes! Haskell can do that.
06:48:20 <slavik> the bot is nice
06:48:33 <slavik> mm_freak: could you explain the dot operator?
06:48:44 <mm_freak> slavik: function composition
06:48:55 <Zao> Function composition or duct tape.
06:48:55 <mm_freak> (f . g) x = f (g x)
06:49:03 <mauke> @src (.)
06:49:03 <lambdabot> (f . g) x = f (g x)
06:49:03 <lambdabot> -- In lambdabot, it's been generalised to:
06:49:03 <lambdabot> (.) = fmap
06:49:18 <mauke> oh lambdabot, you silly program
06:49:55 <mm_freak> honestly, i don't like that generalization
06:54:40 <hpaste>  slavik pasted "find factorial with n zeroes" at http://hpaste.org/8231
06:54:49 <slavik> does that paste look alright to anyone?
06:54:55 <ddarius> Amazon is recommending "Toposes and Local Set Theories: An Introduction" to me...
06:55:22 <mauke> slavik: 'x = 1' looks unused
06:55:46 <mauke> slavik: find_fac n x+1 is parsed as (find_fac n x) + 1
06:55:49 <mauke> infinite recursion
06:56:16 <slavik> fixed it, 1 sevc
06:56:26 <hpaste>  slavik pasted "(no title)" at http://hpaste.org/8232
06:56:30 <slavik> there
06:56:41 <slavik> is it really bad code?
06:56:52 <slavik> ghc didn't give any errors
06:57:03 <mauke> try -Wall :-)
06:57:20 <mauke> it's not bad per se; it just looks inefficient
06:57:31 * slavik is a noob
06:57:33 <slavik> :)
06:57:48 <Deewiant> > div n 10
06:57:49 <lambdabot>  n `div` 10
06:57:53 <mauke> is this an euler problem?
06:57:58 <slavik> no
06:58:01 <slavik> don't think so
06:58:25 <slavik> someone is making something like digg meets project euler and I want to try and solve the problems using haskell
06:58:38 <slavik> http://gwybiral.appspot.com/view_challenge?id=830
06:58:38 <lambdabot> Title: Zeros... Part Two
06:58:50 <slavik> this particular problem
06:58:54 <mauke> possibly related: http://www.spoj.pl/problems/FCTRL/
06:58:59 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem FCTRL
06:59:04 <slavik> given x, find n such that n! has x trailing zeroes
06:59:13 <mix25> @help
06:59:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:59:20 <mix25> list
06:59:23 <mix25> @list
06:59:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
06:59:37 <slavik> hmm, speaking of which, this can be done using the set like notation, no?
06:59:43 <mix25> @src (&&&)
06:59:43 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
06:59:50 <mix25> @src (>>>)
06:59:50 <mauke> huhu, I'm still #1 on FCTRL
06:59:50 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:00:04 <mix25> @src (***)
07:00:04 <lambdabot> f *** g = first f >>> second g
07:00:15 <mauke> slavik: how?
07:00:50 <slavik> mauke: isn't it possible in haskell to put the above sentence into a single statement?
07:01:02 <mauke> huh?
07:01:03 <mix25> @index >>>
07:01:03 <lambdabot> Control.Arrow
07:01:28 <mauke> what sentence and what do you mean by statement?
07:01:40 <slavik> "given x, find n such that n! has x trailing zeroes"
07:02:42 <mauke> hmm, you could do something like foo x = head [ n | n <- [1 ..], zeroes (fac n) >= x ]
07:02:47 <mix25> @search (>>>) definition
07:02:47 <lambdabot> Unknown command, try @list
07:03:05 <mix25> @google (>>>) definition
07:03:05 <lambdabot> http://en.wikipedia.org/wiki/Definition
07:03:24 <slavik> @src head
07:03:24 <lambdabot> head (x:_) = x
07:03:24 <lambdabot> head []    = undefined
07:03:36 <mix25> @google definition of (>>>) operator
07:03:37 <lambdabot> http://www.answers.com/topic/operator
07:03:37 <lambdabot> Title: operator: Definition, Synonyms and Much More from Answers.com
07:03:48 <Deewiant> (>>>) = flip (.)
07:03:54 <mix25> omg
07:04:02 <Deewiant> but only for functions ;-P
07:04:12 <Deewiant> @instances Arrow
07:04:12 <lambdabot> (->), Kleisli m
07:04:15 <mix25> i'll try
07:04:33 <Deewiant> @src Kleisli (>>>)
07:04:34 <lambdabot> Source not found. There are some things that I just don't know.
07:04:38 <Deewiant> @src (Kleisli m) (>>>)
07:04:38 <lambdabot> Source not found.
07:05:02 <maltem_> slavik: You may want to do it in a more mathematical way. Think of it: For n! to have one trailing zero, ten must divide n!. 10 = 2 * 5, so n = 5. For n! to have two trailing zeroes, 100 = 2 * 5 * 10 must divide n!, so n = 10.
07:05:40 <Gilly> slavik: you have x trailing zeroes when you have enough of 5s in there... like when n/5 + n/25 + ... + n/5^inf = x = n * (1/5 + ... + 1/5^inf) = n * 1/(1-1/5) = n/(4/5) = 5n/4 = x
07:06:23 <Gilly> actually hmm
07:06:27 <Gilly> you need some floor maybe there
07:06:28 <mix25> @src first
07:06:29 <lambdabot> Source not found.
07:06:40 <Gilly> or technically you'll need, not sure how much we can make out of it then
07:06:50 <slavik> Gilly: I have to find n such that n! has x trailing zeroes
07:07:19 <Gilly> slavik: yes and the number of trailing zeroes is practically the exponent of 5 in the prime factors
07:07:30 <Gilly> since there'll always be enough of 2's
07:07:41 <slavik> I see
07:08:03 <Gilly> so for example 100! has 100 / 5 + 100 / 25 = 20 + 4 = 24 zeroes in the end
07:08:47 <slavik> hmm
07:09:20 <Gilly> basically you want to sum terms of form floor (n / 5^i)
07:09:39 <Gilly> i from 1 to so big that this term starts to go to zero
07:10:04 <ivanm> Gilly: why divide by 25 as well?
07:10:05 <slavik> ... my brain is about to explode :(
07:10:14 <Gilly> ivanm: it has 2 fives in it's factors 5*5
07:10:25 <Gilly> and since by dividing by 5 we only added one of those
07:10:29 <Gilly> we have to add the second one too
07:10:43 <mm_freak> slavik: the usual way to count zeroes is to divide by 10 as long as the least digit is zero
07:11:00 <slavik> mm_freak: that's what my trailz function does
07:11:14 <slavik> recursively
07:11:27 <mm_freak> unless you're doing that for a set of related numbers, this is the way to go
07:12:03 <slavik> I was thinking of just starting at n=1 and going up until I find such number, but I guess that would be impossible
07:12:25 <mm_freak> what do you mean?  what are you trying to find?  (i didn't read the whole backlog)
07:12:49 <slavik> mm_freak: given n and x, find n such that n! has x trailing zeroes
07:12:57 <slavik> the thing is that x is pretty big
07:13:40 <Vq^> how big?
07:13:48 <slavik> in the problem I am trying to solve, x is 3653745647501879210462848183011285400390628
07:13:58 <slavik> maybe there is a mistake in the problem description
07:15:07 <mm_freak> a number has x zeroes if it's a multiple of 10^x
07:15:37 <mm_freak> a factorial with 3653745647501879210462848183011285400390628 zeroes is impossible to find with current technology
07:15:47 <mm_freak> you wouldn't even have enough storage to save it =)
07:15:52 <slavik> figures
07:16:29 <Vq^> but maybe you don't have to find it
07:16:35 <dcoutts_> right
07:16:50 <Vq^> then it becomes quite a bit easier :)
07:16:50 <mm_freak> Vq^: you have to, because we don't know of any shortcut for factorials
07:16:58 <mm_freak> otherwise the factoring problem would be solved
07:17:00 <dcoutts_> people ask the 100! one as an interview question, you do not need to calculate 100! to know the number of trailing 0's
07:17:05 <slavik> for small things, my code works fine though
07:17:17 <slavik> also, is there a way to take commandline arguments?\
07:17:25 <mm_freak> slavik: yes, getArgs
07:17:33 <mm_freak> you can use it in the IO monad
07:17:34 <slavik> @list
07:17:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:19:00 <Vq^> mm_freak: but we know how many fives are among the primefactors
07:19:25 <Vq^> mm_freak: isn't it then possible to calculate how high n needs to be?
07:19:30 <twobitwork> > (25 ^ 15) * (2 ^ 32)
07:19:31 <lambdabot>  4000000000000000000000000000000
07:19:44 <twobitwork> is there some rounding there?
07:19:52 <idnar> @type (^)
07:19:54 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:20:06 <twobitwork> well... I mean, I know it'll be a whole number
07:20:18 <twobitwork> but I'm just surprised that its such a round number
07:20:34 <idnar> heh
07:20:35 <idnar> > 25 ^ 15
07:20:36 <lambdabot>  931322574615478515625
07:20:43 <idnar> > 2 ^ 32
07:20:43 <twobitwork> > 2^32
07:20:45 <lambdabot>  4294967296
07:20:45 <lambdabot>  4294967296
07:20:50 <mm_freak> Vq^: maybe it's possible to find the number
07:20:51 <mauke> is the answer 14614982590007516841851392732045141601562600?
07:20:53 <twobitwork> both very un-round numbers :)
07:21:05 <idnar> twobitwork: well, yeah, but
07:21:07 <Vq^> > takeWhile (<1000) (iterate (*5) 5)
07:21:09 <lambdabot>  [5,25,125,625]
07:21:11 <Zao> Now that's an 'odd' number.
07:21:22 <idnar> twobitwork: 2 ^ 32 == 4 ^ 16
07:21:44 <idnar> twobitwork: 25 ^ 15 * 4 ^ 15 * 4 == (25 * 4) ^ 15 * 4 == 100 ^ 15 * 4
07:22:13 <mm_freak> Vq^: actually it's well possible
07:22:15 <MedeaMelana> @pl \x f y = x ++ [f y]
07:22:15 <lambdabot> (line 1, column 8):
07:22:15 <lambdabot> unexpected "="
07:22:15 <lambdabot> expecting pattern or "->"
07:22:20 <mm_freak> (10^x)! has x zeroes
07:22:23 <MedeaMelana> @pl \x f y -> x ++ [f y]
07:22:24 <twobitwork> I see
07:22:24 <lambdabot> (. flip (flip . ((:) .)) []) . (.) . (++)
07:22:25 <Vq^> > let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 100
07:22:27 <lambdabot>  24
07:22:31 <Vq^> > let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 100000
07:22:32 <lambdabot>  24999
07:22:46 <cjs> Is there a way of saying, e.g., "1 <= n < 100" in Haskell? (Producing a Bool.)
07:22:52 <slavik> maybe the number of trailing zeroes is too big?
07:23:01 <Zao> cjs: 1 <= n && n < 100
07:23:11 <cjs> Yeah, well....
07:23:15 <Zao> :)
07:23:19 <mauke> > inRange (1, 100) 2
07:23:20 <lambdabot>  True
07:23:29 <MedeaMelana> cjs: you could probably come up with your own operators for that
07:23:37 <mauke> > inRange (1, 100) 100
07:23:38 <lambdabot>  True
07:24:08 <cjs> Hm. Yeah. And with some class magic, it would look quite mathematical.
07:24:10 <Zao> > or $ map (==2) [1..100-1]
07:24:11 <lambdabot>  True
07:24:25 <idnar> > 10!
07:24:26 <lambdabot>   parse error on input `}'
07:24:32 <idnar> err heh
07:24:33 <MedeaMelana> > any (== 2) [1..100-1]
07:24:34 <lambdabot>  True
07:24:41 <MedeaMelana> @src any
07:24:42 <lambdabot> any p =  or . map p
07:24:48 <idnar> > foldl' (*) [1..10]
07:24:51 <lambdabot>   add an instance declaration for (Num [t])
07:25:05 <idnar> > foldl' (*) 1 [1..10]
07:25:06 <lambdabot>  3628800
07:25:15 <idnar> > foldl' (*) 1 [1..100]
07:25:17 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
07:25:27 <idnar> mm_freak: I guess you mean "at least x zeroes"?
07:26:41 <mauke> > any (2==) [1..99]
07:26:43 <lambdabot>  True
07:28:58 <mauke> can I submit solutions to this challenge somehow?
07:29:12 <slavik> idnar: the problem doesn't say
07:29:27 <slavik> mauke: you have to register
07:29:48 <mauke>  Challenge-You! uses Google Accounts for Sign In.
07:29:53 <Gilly> slavik: where is this from, projecteuler?
07:30:02 <mauke> then I click on sign in, and it says  BadValueError('Property user is required',)
07:30:11 <slavik> Gilly: no
07:30:26 <Gilly> ah ok
07:30:26 <slavik> http://gwybiral.appspot.com
07:30:27 <lambdabot> Title: Challenge-You!
07:31:02 <mauke> so anyway, my solution runs in no time even without compiling the code
07:31:02 <paolino> mhh is the Want sum problem serious ?
07:31:03 <smg> hello.
07:31:11 <smg> if then else, does this use pattern matching?
07:31:19 <mauke> smg: no
07:31:19 <smg> i think it uses.
07:31:21 <smg> @implementation if
07:31:21 <lambdabot> Unknown command, try @list
07:31:29 <mauke> well, depends
07:31:31 <smg> no?
07:31:35 <smg> so i am allowed to use it?
07:31:37 <smg> k
07:31:37 <mauke> what do you mean? :-)
07:31:45 <smg> mh..
07:31:55 <smg> i need to test if in a list ALL values are above 50
07:32:06 <smg> f2 :: [Integer] -> Bool
07:32:15 <smg> f2 = foldr ((&&) . (>50)) True
07:32:16 <MedeaMelana> f2 = all (> 50)
07:32:19 <smg> i have this
07:32:25 <smg> but on the empty list [] it returns True
07:32:33 <mm_freak> > let tzeroes = length . last . group . show in tzeroes 1000
07:32:34 <lambdabot>  3
07:32:37 <smg> in the exercise is written: you aren't allowed to use pattern matching
07:32:39 <smg> MedeaMelana: i need to use foldr :|
07:32:45 <slavik> is there a book or tutorial that teaches syntax well?
07:32:46 <mm_freak> > let tzeroes = length . last . group . show in tzeroes (product [1..100])
07:32:48 <lambdabot>  24
07:32:50 <mauke> slavik: yes, that's right
07:32:52 <mauke> er
07:32:53 <MedeaMelana> True is the right answer for the empty list, wouldn't you say?
07:32:53 <mauke> smg:
07:33:01 <smg> is there a way to make my f2 = foldr ((&&) . (>50)) True to return False on empty list
07:33:08 <slavik> so far, most of the things I've found teach the concepts, which I understand (or I think I understand)
07:33:09 <mauke> smg: yes, but that would be wrong
07:33:11 <smg> if not i need if, then, else construct
07:33:20 <smg> mauke: how then?
07:33:21 <mauke> it's supposed to return True
07:33:29 <mm_freak> > let tzeroes = length . last . group . show in tzeroes (product [1..(10^(floor $ log 4 / log 10))])
07:33:31 <lambdabot>  1
07:33:38 <smg> mauke: why? if no number in the list it should return False
07:33:43 <mauke> smg: wrong
07:33:43 <smg> or is this true
07:33:49 <smg> mauke: explain...
07:33:55 <smg> empty list means okay?
07:34:07 <mauke> in an empty list, all values are > 50
07:34:13 <ziman> every element from an empty list is greater than 50
07:34:25 <smg> ahhh
07:34:26 <mauke> > all (> 50) [51]
07:34:28 <lambdabot>  True
07:34:29 <mauke> > all (> 50) [50]
07:34:31 <lambdabot>  False
07:34:31 <smg> so my solution is completly valid?
07:34:32 <mauke> > all (> 50) []
07:34:33 <lambdabot>  True
07:34:35 <smg>  f2 = foldr ((&&) . (>50)) True
07:34:46 <mauke> yes
07:34:49 <smg> ah thx
07:34:55 <smg> i thought it should return false on empty list
07:35:04 <Deewiant> > all (const False) []
07:35:05 <lambdabot>  True
07:35:06 <smg> is that also due to mathematical background?
07:35:13 <mauke> yeah
07:35:29 <mauke> > product []  -- related
07:35:30 <lambdabot>  1
07:35:44 <mauke> > sum []
07:35:45 <lambdabot>  0
07:35:53 <mauke> > (and [], or [])
07:35:54 <lambdabot>  (True,False)
07:36:18 <MedeaMelana> The funny thing is, "all p []" is always True, and so "all (not . p) []" is also True
07:36:37 <MedeaMelana> So while all elements in the empty list are >50, it is also true that all elements in the empty list are not >50
07:37:02 <Vq^> MedeaMelana: is that funny?
07:37:22 <MedeaMelana> I can imagine it feels a bit funny to people at first, yes
07:37:32 <idnar> ex falso quodlibet
07:37:40 <idnar> well, not quite the same thing, but related
07:37:48 <mm_freak> Vq^, slavik: that problem is strongly related to the factoring problem
07:37:50 <Vq^> all odd [1,2] == all (not . odd) [1,2]
07:38:04 <mauke> > all (> 50) [0 / 0]
07:38:05 <lambdabot>  False
07:38:08 <mm_freak> i'm afraid, there is no shortcut
07:38:10 <mauke> > all (not . (> 50)) [0 / 0]
07:38:12 <lambdabot>  True
07:38:22 <mauke> > all (<= 50) [0 / 0]
07:38:24 <lambdabot>  False
07:38:43 <smg> mauke: mh
07:38:45 <MedeaMelana> > 0 / 0
07:38:47 <lambdabot>  NaN
07:38:53 <MedeaMelana> > NaN
07:38:54 <lambdabot>   Not in scope: data constructor `NaN'
07:39:05 <MedeaMelana> > (0/0) > 50
07:39:07 <lambdabot>  False
07:39:12 <MedeaMelana> > (0/0) < 50
07:39:13 <lambdabot>  False
07:39:33 <mauke> > 0/0 == 0/0
07:39:34 <lambdabot>  False
07:39:48 <smg> mauke: why would we define that
07:39:49 <mm_freak> Vq^, slavik: you could speed it up a lot using a prime sieve, but for the given x, it's infeasible to solve
07:39:57 <smg> that the empty list has numbers > 50?
07:40:09 <mauke> smg: that's not what we're saying
07:40:17 <mauke> the empty list doesn't have any numbers
07:40:21 <smg> okay
07:40:36 <mauke> all we're saying is: foreach element x of [], p x is true
07:40:37 <smg> and therefore... ?
07:40:51 <smg> yes
07:40:52 * edwardk waves hello.
07:40:52 <mauke> er
07:41:23 <mehrheit> > show (0/0 :: Double)
07:41:25 <lambdabot>  "NaN"
07:41:31 <Vq^> mm_freak: my function could still be useful if im not mistaken
07:41:44 <smg> mauke: but does this make sense?
07:41:52 <mauke> yes :-)
07:42:01 <mauke> @src all
07:42:02 <lambdabot> all p =  and . map p
07:42:11 <smg> mauke: intuitively i would say that in the empty list [] there is NO number >50
07:42:12 <mehrheit> shouldn't all Prelude types' Show instances be defined so that the output can be read back?
07:42:15 <mauke> therefore all p [] == and (map p []) == and []
07:42:29 <mauke> and 'and []' is True
07:42:37 <mauke> smg: right
07:42:42 <MedeaMelana> > read "NaN :: Double
07:42:43 <lambdabot>  Improperly terminated string at ""NaN" (column 6)
07:42:47 <quicksilver> smg: yes. There is NO number > 50.
07:42:52 <quicksilver> smg: and also ALL numbers are > 50
07:43:00 <smg> that tricks my mind
07:43:16 <quicksilver> smg: because there are NO numbers
07:43:17 <Vq^> mm_freak: it's easy to tell if a result from f is above or below the solution, so it's easy to use an approximation search
07:43:18 <quicksilver> so ALL = NO
07:43:21 <quicksilver> in this particular case )
07:43:26 <Deewiant> > read "NaN" :: Double
07:43:27 <lambdabot>  NaN
07:43:31 <mm_freak> Vq^: not for the given xâ€¦  the problem of counting the trailing zeroes of n! without actually calculating n! is directly related to the factoring problem
07:43:36 <quicksilver> > all (>50) []
07:43:38 <lambdabot>  True
07:43:41 <smg> hehe
07:43:42 <quicksilver> > not (any (>50) [])
07:43:44 <lambdabot>  True
07:43:47 <quicksilver> both are true
07:43:47 <smg> quicksilver: tricks my mind still hehe okay
07:43:49 <quicksilver> as you said.
07:44:05 <mauke> smg: [] doesn't contain any number <= 50
07:44:09 <smg> exactly
07:44:11 <mauke> therefore all elements must be > 50
07:44:12 <cjs> Gah, too much Erlang!
07:44:17 <quicksilver> in fact if, for any p, we have (all p []) and also (not (any p []))
07:44:20 <quicksilver> erm
07:44:21 <mauke> (valid proof)
07:44:28 <quicksilver> in fact if, for any p, we have (all p l) and also (not (any p l))
07:44:32 <quicksilver> we can deduce l == []
07:44:44 <cjs> I found myself looking for a function that maps on to number N of a tuple in a list of those tuples.
07:44:45 <Vq^> mm_freak: did my function return the wrong number of number of zeroes?
07:45:12 <Vq^> mm_freak: it easily returned larger numbers than the given x
07:45:46 <smg> mauke: that makes me happy
07:47:19 <mehrheit> then shouldn't all Prelude types' Show instances be defined so that the output string is a valid Haskell expression?
07:47:46 <mauke> > read "NaN" :: Double
07:47:48 <lambdabot>  NaN
07:48:09 <quicksilver> mehrheit: that would be preferred, yes
07:48:25 <quicksilver> mehrheit: it's not unfrotunately written down that it must be so.
07:48:27 <smg> mauke: this is funny proof
07:48:42 <Vq^> slavik: alive?
07:48:46 <Gilly> mauke: what was your implementation for that zeros problem? :) i got mine working
07:48:53 <MedeaMelana> @pl \x y -> return (qunit x y)
07:48:54 <lambdabot> (return .) . qunit
07:49:10 <conal> (fmap.fmap) pure qunit
07:49:43 <mm_freak> Vq^: huh?  maybe i've overlooked it
07:49:53 <mehrheit> quicksilver: I think I saw that assumed in some hs-plugins' function documentation, which is valid only for types with Show/Haskell expression equivalence
07:50:29 <mm_freak> Vq^: let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 100000  -- that one?
07:50:59 <mm_freak> > let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 100000
07:50:59 <Vq^> mm_freak: yeah
07:51:01 <lambdabot>  24999
07:51:16 <mehrheit> "mkHsValues is a helper function for converting Data.Maps of names and values into Haskell code. It relies on the assumption that the passed values' Show instances produce valid Haskell literals (this is true for all prelude types)."
07:51:23 <mehrheit> maybe that should be reported as a bug
07:51:30 <hpaste>  mauke pasted "zeros2.hs" at http://hpaste.org/8234
07:51:53 <smg> mauke:
07:51:53 <mm_freak> > foldl' (\x y -> mod (x*y) 10^24999) [1..100000]
07:51:54 <lambdabot>   add an instance declaration for (Integral [t])
07:52:02 <mm_freak> > foldl' (\x y -> mod (x*y) 10^24999) 1 [1..100000]
07:52:05 <lambdabot>  0
07:52:05 <smg> check if any number in list is > 50
07:52:08 <mauke> Gilly: see paste
07:52:12 <mm_freak> > foldl' (\x y -> mod (x*y) 10^25000) 1 [1..100000]
07:52:14 <smg> i have. f1 = foldr ((||) . (>50)) False
07:52:14 <lambdabot>  0
07:52:26 <mm_freak> > foldl' (\x y -> mod (x*y) 10^25001) 1 [1..100000]
07:52:29 <lambdabot>  0
07:52:29 <smg> returns on empty list False
07:52:34 <MedeaMelana> \x y -> f (g x y)
07:52:36 <smg> is that true, maybe you can formalize a proof again?
07:52:36 <mm_freak> > foldl' (\x y -> mod (x*y) 10^100000) 1 [1..100000]
07:52:39 <lambdabot>  0
07:52:40 <MedeaMelana> @pl \x y -> f (g x y)
07:52:41 <lambdabot> (f .) . g
07:52:45 <mm_freak> d'oh
07:52:49 <MedeaMelana> @pl \x y -> f (g (h x y))
07:52:49 <lambdabot> ((f . g) .) . h
07:52:53 <mm_freak> > foldl' (\x y -> mod (x*y) (10^24999)) 1 [1..100000]
07:52:58 <lambdabot>  0
07:52:58 <smg> mauke: ?
07:52:59 <mauke> smg: well, that's the difference between "any" and "all"
07:53:04 <mm_freak> > foldl' (\x y -> mod (x*y) (10^25000)) 1 [1..100000]
07:53:08 <lambdabot>  6000000000000000000000000000000000000000000000000000000000000000000000000000...
07:53:13 <mauke> smg: "any" requires at least one list element to pass the test
07:53:17 <mm_freak> Vq^: indeed, it seems to be correct
07:53:17 <Deewiant> ((f .) . g) == ((.).(.) f g)
07:53:21 <mehrheit> @localtime dons
07:53:23 <lambdabot> Local time for dons is Tue Jun 10 07:53:22 2008
07:53:28 <mm_freak> > let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 10000000000
07:53:31 <lambdabot>  2499999997
07:53:48 <mm_freak> > let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 100000000000000000000
07:53:50 <lambdabot>  24999999999999999996
07:53:58 <conal> the trick with (.).(.) is generalized in the DeepArrow library and is the basis of tangible functional programming.
07:54:07 <hpaste>  Gilly pasted "zeros by gilly" at http://hpaste.org/8235
07:54:07 <Gilly> mauke: mine is a bit different
07:54:08 <smg> mauke: yeah
07:54:14 <smg> mauke: may i private message you?
07:54:25 <mauke> yes
07:54:36 <smg> ty, appreciated
07:55:03 <MedeaMelana> conal: I was hoping (.).(.) was pretty general already :_P
07:55:10 <paolino> mmhh, why fact 20 has 4 trailing zeros and fact 25 has 6 ?
07:55:16 <slavik> Vq^: I am back
07:55:41 <Gilly> paolino: you mean 20! and 25! ?
07:55:54 <conal> MedeaMelana: with DeepArrow, you can use these "editor combinators" to transform not only functional values, but also GUIs, types, code, etc.
07:55:56 <mm_freak> > let f n = sum . map (div n) . takeWhile (<n) $ iterate (*5) 5 in f 58
07:55:58 <lambdabot>  13
07:56:00 <paolino> Gilly: yes
07:56:08 <Gilly> paolino: it's because 25 gives you two 5's in the product
07:56:27 <paolino> :)
07:56:32 <mm_freak> Vq^: you're exploiting the fact that the exponent of 2 grows much faster than the exponent of 5
07:56:34 <MedeaMelana> conal: mmkay
07:56:37 <Vq^> slavik: half the channel is solving your problem independenlty :)
07:56:42 <Vq^> mm_freak: indeed i am
07:56:43 <slavik> I see that
07:56:45 <Gilly> and to form 10's you need 2's and 5's... basically there'll be a lot of more 2's so you just need the number of 5's to deduce the number of trailing zeros
07:56:49 <slavik> I still don't think that it is doable
07:56:55 <slavik> since it would be a very large number
07:57:01 <mm_freak> hehe
07:57:09 <Gilly> slavik: at least mauke and i posted correct solutions already :)
07:57:09 <mm_freak> but the problem is indeed very interesting
07:57:13 <slavik> and the same guy posted another problem for which he didn't provide a solution (but the solution is 6)
07:57:20 <slavik> wtf?!
07:57:39 <Vq^> slavik: my experimentation shows that it is somewhere in the area of 1/4 of x, not that large
07:58:45 <slavik> the number itself is large
07:59:09 <slavik> I need a tutorial that teaches haskell syntax ...
08:00:07 <Vq^> there is the tour of the haskell syntax
08:00:20 <Vq^> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
08:00:22 <lambdabot> Title: Tour of the Haskell Syntax
08:00:47 <slavik> ty
08:03:26 <MedeaMelana> whoa
08:12:01 <FordCortina> @hoogle a -> b -> (a,b)
08:12:02 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
08:12:02 <lambdabot> Control.Monad.RWS.Strict.execRWS :: RWS r w s a -> r -> s -> (s, w)
08:12:02 <lambdabot> Control.Monad.RWS.Lazy.evalRWS :: RWS r w s a -> r -> s -> (a, w)
08:12:21 <Saizan_> :t (,)
08:12:23 <lambdabot> forall a b. a -> b -> (a, b)
08:12:39 <FordCortina> :t curry $ id
08:12:41 <lambdabot> forall a b. a -> b -> (a, b)
08:12:44 <FordCortina> hehe
08:12:46 <FordCortina> well ok
08:12:48 <FordCortina> thanks
08:17:36 <Vq^> mm_freak: seems to produce the same result as maukes code :)
08:17:49 * Vq^ waves with a little flag
08:19:13 <paolino> it's around 10^44
08:19:52 <mauke> > logBase 10 14614982590007516841851392732045141601562600
08:19:55 <lambdabot>  43.1647983023436
08:20:17 <cremetorte> hi i wanted to write a function which detectes the inputet type like this : http://hpaste.org/8236
08:20:22 <Gilly> mm yet another point of view to this zero problem :)
08:20:26 <cremetorte> but he claims that i define f twice
08:20:45 <Gilly> it's a very good approximation that the number is 4*wanted_zeros
08:20:48 <Gilly> it's gonna be a bit more
08:20:53 <byorgey> cremetorte: you need some indentation
08:20:55 <Gilly> in this case just 4*wanted_zeros + 88
08:21:11 <cremetorte> need what
08:21:15 <hpaste>  byorgey annotated "funtkion" with "indentation is important!" at http://hpaste.org/8236#a1
08:21:29 <luite> when the number goes to infinity it will be exactly 4*
08:21:48 <Gilly> this is because for big numbers we have \sum_i=1^inf n/5^i =~ n/4
08:21:59 <Gilly> luite: exactly
08:22:05 <byorgey> cremetorte: in your original code, since the type signature for f was in the same column as the 'class' declaration, the parser sees them as separate
08:22:16 <byorgey> i.e. an empty class declaration, followed by a type declaration for a function called f
08:22:22 <cremetorte> mh than you
08:22:23 <byorgey> same for the instance declarations
08:22:36 <cremetorte> i didnt know that this is so important
08:22:38 <cremetorte> but thanks
08:22:41 <byorgey> if you don't want to worry about indentation you can use braces { }
08:22:53 <byorgey> like  class F a where { f :: a -> String }
08:23:10 <byorgey> in that example you could put the { f :: a -> String } on the next line in the same column and it would work fine
08:23:15 <hpaste>  Vq pasted "zeros" at http://hpaste.org/8237
08:23:20 <byorgey> indentation is an abbreviation for grouping with { }
08:25:07 <Vq^> is that a good solution for the zeros problem?
08:26:28 <cremetorte> mh he neither can dtermine float nor int ...
08:26:35 <hpaste>  (anonymous) pasted "yetanotherzeros.hs" at http://hpaste.org/8238
08:26:46 <Gilly> there's my last take on this problem
08:26:52 <Gilly> i doubt it'll get significantly shorter :)
08:27:00 <Gilly> and this is still fast
08:27:20 <Vq^> oh, neat
08:28:48 <cremetorte> instance F Char where  f x = "Character"  works  but   instance F Float where f x = "Float"  doesnt.  has this something to do with the num type?
08:29:06 <FordCortina> is it possible to write something like this: \x y -> ((fst x),y) in points-free style?
08:29:31 <Saizan_> ?pl \x y -> ((fst x),y)
08:29:32 <lambdabot> (,) . fst
08:29:42 <quicksilver> cremetorte: what is the error?
08:30:05 <FordCortina> thanks Saizan_ it seems obvious now...
08:30:25 * FordCortina looks at pointless style *really* hard 
08:30:33 <Vq^> Gilly: ah, you use the fact that the solution is close above n*4
08:30:40 <Gilly> Vq^: exactly
08:30:51 <Gilly> in the original example it's just + 88
08:31:05 <Gilly> i've tested this with significantly larger examples and it's still fast :)
08:31:22 <hpaste>  maltem annotated "yetanotherzeros.hs" with "(no title)" at http://hpaste.org/8238#a1
08:31:28 <Vq^> Gilly: does that number grow?
08:31:30 <cremetorte> f 1.2 => Ambiguous type variable 't' in the constraints:  'F t' arising from a use of 'f' at interactive:1:0-4 Fractional t arising from the literal '1.2' at interactive:1:2-4
08:31:53 <wjt> cremetorte: try f (1.2 :: Float)
08:32:02 <quicksilver> cremetorte: your instance is fine.
08:32:05 <Gilly> Vq^: i think a bit but not significantly, since *4 is supposed to be the best bound anyways
08:32:08 <quicksilver> cremetorte: it's just that 1.2 isn't a float.
08:32:13 <quicksilver> (necessarily)
08:32:24 <cremetorte> that means the user has to input (1.2::float)
08:32:33 <quicksilver> the user?
08:32:36 <quicksilver> user of what?
08:32:53 <cremetorte> :) the guy who types "f ...." in the shell
08:33:26 <quicksilver> that's not a user.
08:33:37 <cremetorte> that means there is no possibility to let haskell know that simply   1.2 is a Float
08:33:37 <quicksilver> the shell isn't normally a use case :)
08:33:42 <quicksilver> user cases are programs.
08:33:54 <quicksilver> simply 1.2 is polymorphic in haskell.
08:33:58 <cremetorte> ok
08:34:07 <quicksilver> in real programs there are type signatures elsewhere
08:34:17 <quicksilver> quite often the Float will be pinned down elsewhere.
08:35:22 <cremetorte> ok i have to send the programm to a tutor who controlls the program, so i have to add the note that he shall input  (FLOATNUMBER::Float) and  (INTNUMBER::Int)
08:36:14 <quicksilver> yeah
08:36:24 <cremetorte> k thanks
08:36:27 <quicksilver> or use an intermediate function
08:36:30 <quicksilver> with a type signature.
08:37:20 <Gilly> maltem: hmm, yours and mine give different answers
08:37:32 <maltem> Gilly: yeah mine was wrong
08:46:26 <sergio_> pl \x y -> x y
08:46:34 <mauke> id
08:46:38 <ziman> ($)
08:47:17 <sergio_> pl \x y -> x . f . y
08:48:55 <mauke> (.) . (. f)?
08:49:05 * ziman gives up
08:49:44 <Syzygy-> :t (.) . (.f)
08:49:47 <lambdabot> forall a (f :: * -> *) a1 b. (SimpleReflect.FromExpr a1, Show a, Functor f) => (a1 -> b) -> f a -> f b
08:49:57 <Syzygy-> :t (.) . (.) f
08:49:59 <lambdabot> forall a (f :: * -> *) a1 b. (SimpleReflect.FromExpr b, Show a1, Functor f) => (a -> a1) -> f a -> f b
08:50:09 <wjt> :t (.) . (.) ?f
08:50:11 <lambdabot> forall a (f :: * -> *) a1 b. (?f::a1 -> b, Functor f) => (a -> a1) -> f a -> f b
08:50:28 <mauke> @pl \x y -> x . f . y
08:50:28 <lambdabot> (. (f .)) . (.)
08:50:39 <wjt> :t (Prelude..) Prelude.. (Prelude..) ?f
08:50:40 <lambdabot> forall a b c a1. (?f::b -> c) => (a1 -> b) -> (a -> a1) -> a -> c
08:50:57 <mehrheit> @pl \f -> f f
08:50:57 <lambdabot> join id
08:52:21 <smg> where is the boobie/tittie operator?
08:52:24 <smg> (.) . (.) ?
08:52:43 <Deewiant> nowhere?
08:52:48 <smg> :|
08:52:53 <Deewiant> it's not in any library I'm aware of
08:52:54 <smg> Deewiant: you you know what i mean? :]
08:53:03 <Deewiant> @ty (.).(.)
08:53:05 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
08:53:09 <Deewiant> gah
08:53:14 <Deewiant> @ty (Prelude..).(Prelude..)
08:53:15 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:53:18 <smg> Deewiant: can you give a practical example for (.).(.)
08:53:19 <smg> ?
08:53:25 <Deewiant> @pl \x y -> f x y
08:53:26 <lambdabot> f
08:53:31 <Deewiant> erm
08:53:55 <ziman> smg, it's not an operator on its own; it's a composition of the function composition operator :)
08:54:04 <smg> i know
08:54:05 <mauke> @pl \x y -> f (g x y)
08:54:05 <lambdabot> (f .) . g
08:54:08 <smg> :)
08:54:11 <mauke> @pl \f g x y -> f (g x y)
08:54:11 <smg> is there a usage for it?
08:54:11 <lambdabot> (.) . (.)
08:54:12 <Deewiant> that one
08:54:28 <smg> ah
08:54:45 <Deewiant> so, \x y -> f (g x y) is the same as ((.).(.)) f g
08:54:53 <mauke> > ((.) . (.)) sqrt (*) 3 5
08:54:55 <lambdabot>  3.872983346207417
08:55:10 <FordCortina> nice
08:55:18 <smg> FordCortina: the same came to my mind
08:55:31 <Deewiant> it's sometimes nice to be able to write pointless declarations with it but I don't really feel the need
08:57:53 <quicksilver> if you were inclined to use it, you'd probably give it a name like
08:57:59 <quicksilver> (:.) = (.).(.)
08:58:06 <quicksilver> but that way madness lies
08:58:08 <Deewiant> s/:././
08:58:23 <Deewiant> s;/./;/.:/;
08:58:30 <quicksilver> (there are a whole family of composition operators for nary functions in various positions)
08:58:43 <quicksilver> and you can't possible givem them all memorabl names
08:58:44 <wjt> @let (âˆ´) = (.).(.)
08:58:44 <lambdabot>  Illegal character ''\136''
08:58:48 <wjt> doh :(
08:59:00 <smg> @let (:::) = (.).(.)
08:59:01 <lambdabot> <local>:1:0: Not in scope: data constructor `:::'
08:59:13 <quicksilver> at some point you have to concede taht "expression syntax" is a nice compact way of doing these things
08:59:17 <quicksilver> yeah I meant (.:) actually
08:59:17 <Deewiant> can't start with :
08:59:17 <quicksilver> sorry
08:59:33 <mercury^> shouldn't ghc support unicode?
08:59:38 <quicksilver> it does
08:59:41 <mauke> it does, sort of
08:59:42 <quicksilver> (that was easy!)
08:59:47 <Deewiant> lambdabot is the one that doesn't :-P
09:00:27 <mauke> http://hackage.haskell.org/trac/ghc/ticket/2302 http://hackage.haskell.org/trac/ghc/ticket/2303 http://hackage.haskell.org/trac/ghc/ticket/2304
09:00:29 <lambdabot> Title: #2302 (error messages mangle unicode characters) - GHC - Trac
09:00:49 <BSP_> can Cabal not deal with cyclic package dependencies?
09:01:41 <mauke> > "â‚¬"
09:01:42 <lambdabot>  "\8364"
09:01:53 <mauke> > "\à¹”"
09:01:54 <lambdabot>  Illegal escape sequence at ""\à¹”..." (column 1)
09:02:07 <mauke> "ßŸ"
09:02:09 <mauke> > "ßŸ"
09:02:10 <lambdabot>      lexical error in string/character literal at character '\2015'
09:02:12 <Deewiant> > let (â‚¬) = (+) in 1 â‚¬ 2
09:02:12 <lambdabot>  Illegal character ''\130''
09:02:12 <lambdabot>  at "‚¬)" (column 7)
09:02:28 <mauke> > "\1à¹”"
09:02:29 <lambdabot>  ghc-6.8.2: panic! (the 'impossible' happened)
09:02:29 <lambdabot>   (GHC version 6.8.2 for i386-...
09:02:50 <Deewiant> :-D
09:02:58 <Japsu> lol
09:04:08 <^Someone^> Does anyone know where I can find the proof of the converse of Kleene's theorem in lambda-calculus? The theorem which says that all recursive functions are lambda-definable
09:05:46 <vixey> you already know how to encode numerals
09:06:08 <vixey> succ, add, mult, exp, zero?, and i'th projetion of k arguments, yes?
09:06:09 <quicksilver> BSP_: I woudln't be surprised to hear it can't. Are cyclic package dependencies a good idea?
09:06:34 <^Someone^> Me, vixey?
09:06:45 <BSP_> quicksilver: probably not, but I have an unavoidable one.. i guess i will have to collapse the plugins together
09:06:55 <BSP_> s/plugins/packages
09:07:21 <^Someone^> vixey: Yes
09:08:36 <vixey> assume f(0,n_1, ..., n_m) = g(n_1, ..., n_m)
09:09:02 <vixey>        f(n+1,n_1, ..., n_m) = g(f(n,n_1, ..., n_m), n, ..., n_m)
09:10:08 * ^Someone^ is paying attention :)
09:10:13 <vixey> where g and h are lambda defineable by G and H,
09:10:36 <vixey> let Init = <0, Gx_1, ..., x_m>
09:11:10 <vixey>     Step = \p.<succ(Ï€_1 p), H(Ï€_2 p)(Ï€_1 p)x_1 ... x_m>
09:11:51 <vixey> then f is lambda definable by F = \x x_1 ... x_m.Ï€_2(x Step Init)
09:13:46 <vixey> that is the algorithm, that takes pairs (0,a_0), (1,a_1), .., (n, a_n) where a_0 = g(n_1, ..., g_m), a_i+1 = h(a_i, i, n_1, ..., n_m) to the limit a_n = f(n, n_1, ..., n_m)
09:14:00 <vixey> which is every primitive recursive function
09:14:34 <quicksilver> BSP_: having A depend on B means you need B installed to compile A. And vice versa.
09:14:45 <quicksilver> BSP_: how would you expect the user to bootsrap that
09:14:51 <BSP_> quicksilver: so you would think but i have actually managed to do it
09:14:59 <quicksilver> yes, you can do it, of course.
09:15:04 <quicksilver> you can just compile them itereatively
09:15:08 <quicksilver> but how would the *user* do it?
09:15:14 <BSP_> quicksilver: thats exactly what has happened, iteratively
09:15:21 <quicksilver> is it your intention to produce an escher-esque package that no other user can compile?
09:15:28 <BSP_> :) not quite
09:15:39 <BSP_> see what i did is made ghc depend on hs-plugins iff it is a stage 2 build
09:15:45 <BSP_> but hs-plugins depends on GHC
09:16:02 <BSP_> thats ok since it can use the stage 1 build that doesn't depend on it
09:16:21 <BSP_> so the "escher" stuff is actually happening naturally as a part of GHCs staged build process
09:16:25 * quicksilver nods
09:16:34 * ^Someone^ is trynig to understand the proof
09:16:39 <quicksilver> well at that level of granularity stage1 and stage2 are sort of "not the same package"
09:16:44 <^Someone^> Thanks a whole lot, vixey :)
09:17:06 <BSP_> quicksilver: well, stage2 provides everything stage1 does and more so its ok to let hs-plugins use it
09:17:21 <vixey> that's only primitive recursive functions
09:17:23 <BSP_> and the package names between 1 and 2 happen to be the same
09:17:39 <vixey> partial recursive functions is a little bit tricker but we need that lemma
09:17:54 <BSP_> quicksilver: anyway, i think i'm just going to splice the relevant parts of hs-plugins into GHC and be done with it
09:18:44 <quicksilver> BSP_: sonuds plausible to me, sounds like something to discuss on #ghc
09:18:50 <quicksilver> BSP_: if you want better qualified input :)
09:19:10 <BSP_> yeah, i've already discussed something like this with SPJ, was really after cabal information here :)
09:19:15 <^Someone^> I haven't done partial yet :|
09:20:24 <quicksilver> BSP_: well this is pretty GHC specific and the cabal hackers also hang out on #ghc
09:20:43 <quicksilver> BSP_: I mean, it's specific to the special stage1 stage2 hs-plugins arrangement
09:20:48 <quicksilver> not a likely situation for general packages
09:21:12 <quicksilver> (if there was a general package I would split "ghc" into two packages, boot-ghc, and full-ghc, and have hs-plugins depend on boot-ghc, FWIW)
09:21:26 <BSP_> hmm yeah
09:21:29 <vixey> partial recursive is just the name for the whole bag
09:22:02 <vixey> > filter (\x -> x < 3) [1..]
09:22:13 <lambdabot>  [1,2Exception: Time limit exceeded
09:22:40 <mauke> > takeWhile (< 3) [1..]
09:22:42 <lambdabot>  [1,2]
09:23:17 <Botje> ideally, you'd want the filter on to reduce to the takeWhile when given [1..]
09:23:42 <sclv> ?src guard
09:23:42 <lambdabot> guard True  =  return ()
09:23:42 <lambdabot> guard False =  mzero
09:23:49 <vixey> no I wanted an example of a partial function
09:25:04 <quicksilver> f 0 = "partial"
09:25:08 <quicksilver> that's a partial function :)
09:25:34 <Deewiant> const is partial
09:26:41 <seanmce> In ocaml, XHTML tags are typed, so that for example, a compile time check ensure only a TD or TH go inside a TR. Has this been done in Haskell?
09:27:11 <quicksilver> surely that's not really a property of ocaml
09:27:17 <quicksilver> it's a property of a particular language.
09:27:24 <quicksilver> orry
09:27:31 <seanmce> It's an ocaml library
09:27:31 <quicksilver> particular *library* I meant to type.
09:27:47 <quicksilver> I've not seen a haskell library which translates the XHTML DTD into types, no.
09:28:04 <seanmce> it could be done. Right?
09:28:09 <wjt> i'm sure i saw a paper on this
09:28:11 <vixey> I heard it had been done
09:28:23 <vixey> checking XHTML compliance in the type system
09:28:58 <wjt> http://citeseer.ist.psu.edu/439179.html
09:28:58 <lambdabot> Title: A typed representation for HTML and XML documents in Haskell - Thiemann (Researc ...
09:29:06 <quicksilver> seanmce: the core of ocaml's type system is very similar to the core of haskells
09:29:24 <quicksilver> seanmce: and I'd be surprised if this library was using anything haskell doesn't  have. got a link to it? (the ocaml lib)
09:29:45 <seanmce> http://ocsigen.org/docu/1.0.0/XHTML.M.html
09:30:00 <byorgey> @seen gwern
09:30:00 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 3h 22s ago.
09:30:13 <byorgey> gwern: oeis 0.2 uploaded to hackage!
09:30:42 <byorgey> note I still haven't pushed your patches to the public repo, though, since my password still hasn't been reset
09:30:57 <byorgey> but I applied them locally and uploaded the new version of the package
09:31:01 <seanmce> http://ocsigen.org/tutorial1.0.0-1#p1baseprinciples
09:31:22 <seanmce> wjt: thanks
09:31:28 <Saizan_> seanmce: WASH does that as part of its framwork
09:32:26 <seanmce> Saizan: cool, I'll check that out.
09:33:16 <joey`> Hmm, having trouble building old-time.1.0.0.0 with the error "Could not find module `System.Locale': it was found in multiple packages: old-locale-1.0.0.0 base"
09:33:51 <vixey> (bbl)
09:33:52 <joey`> Can anyone offer any suggestions as to what I'm doing wrong?
09:36:05 <sclv> @yow
09:36:46 <olsner> lambdabot: answer!
09:38:34 <hpaste>  (anonymous) annotated "Perl script without #!" with "(no title)" at http://hpaste.org/8228#a1
09:39:18 <Baughn> Would "import qualified foo" be equivalent to "import foo()"?
09:40:40 <mrd> no
09:43:06 <sclv> sigh. I could swear there was a strongly typed xhtml lib someone was working on that they posted to -cafe about but can't find it.
09:52:11 <Gilly> Vq^: btw, it seems that the distance to 4*n can get arbitrarily large but it will also be 1 infinitely often
09:54:02 * edwardk trolls. Side effects good. Haskell bad. ;)
09:54:59 <dcoutts_> @seen BSP
09:55:18 <sclv> preflex: seen BSP
09:55:18 <preflex>  Sorry, I haven't seen BSP
09:55:39 * sclv bites. why?
09:55:56 <ziman> 18:40:31 -!- BSP_ [n=mbolingb@c161.al.cl.cam.ac.uk] has left #haskell []
09:56:09 <sclv> preflex: seen lambdabot
09:56:09 <preflex>  lambdabot was last seen on #haskell 26 minutes and 9 seconds ago, saying: gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 3h 22s ago.
09:56:36 <hpaste>  gilly annotated "yetanotherzeros.hs" with "bah, couldn't resist to include this version too" at http://hpaste.org/8238#a2
09:56:40 <edwardk> sclv: heh, actually, was mostly trolling coz i was bored, but i'll admit some of the stuff you can do with f# workflows due to side-effect obliviousness is pretty nice.
09:56:47 <dcoutts_> preflex: seen BSP_
09:56:47 <preflex>  BSP_ was last seen on #haskell 35 minutes and 21 seconds ago, saying: hmm yeah
09:58:13 <edwardk> of course you give up a ton of reasoning ability, so its not a great tradeoff, but still
10:27:38 <dons> ?yow
10:27:52 <ndm> hi dons
10:28:33 <dolio> That's not very zippy.
10:29:20 <ndm> code.hoogle.org is also not very zippy :(
10:29:29 <dons> heya ndm
10:29:38 <ndm> i seem to be completely unable to push to it yesterday or today
10:29:46 <dons> code.haskell.org ?
10:29:50 <ndm> and tomorrow i loose ssh for a month, so it would have been nice to sync up!
10:29:51 <geezusfreeek> hoogle.org?
10:30:06 <dons> i can ssh to c.h.o
10:30:12 <ndm> neil@code.haskell.org:/srv/code/hoogle - pushing there is taking forever
10:30:16 <geezusfreeek> 12425 visitors since 1/10/04!
10:30:27 <geezusfreeek> (hoogle.org)
10:30:51 <Igloo> ndm: Seems OK to me
10:30:55 <dons> dcoutts_: looks like its not too hard to automate generation of arch packages from cabal files
10:30:56 <ndm> hmm, weird
10:31:07 <ndm> Igloo: chances that its my machine, darcs, or the server?
10:31:25 <ndm> darcs on my end is at 0% processor
10:32:39 <dcoutts_> dons: good good. That'll be the 5th conversion tool by my counting.
10:33:20 <dons> dcoutts_: so best to ask cabal-the-library to parser .cabal files for me these days?
10:33:22 <dcoutts_> dons: you saw what thetallguy was saying yesterday about generating debian packages
10:33:23 <dons> that api is stable?
10:33:26 <dons> yeah
10:33:48 <dcoutts_> dons: that bit of the api is relatively stable. You certainly do not want to write a duplicate parser.
10:34:05 <ndm> Igloo: seems like i was using the wrong username, and darcs's response to that was to go silent :(O
10:34:09 <dons> right. and then its just pretty printing from there. arch is pretty simple in this regard
10:34:17 <dons> i'll just need to identify some community members to help
10:34:46 <geezusfreeek> converting cabal packages to arch packages?
10:34:52 <dcoutts_> dons: right define a type to represent arch package descriptions, convert and pretty print. That's basically what we do for gentoo.
10:34:57 <Botje> bad
10:35:02 <dons> yep
10:35:08 <Botje> quick c-- is generating horrible code :(
10:35:14 <dons> dcoutts_: and we need register/unregister hooks to be spat out.
10:35:36 <dons> since the packages don't have access to the global package file, till after they're installed
10:35:37 <vixey> hey Botje did you decide what language to target?
10:35:41 <dons> i guess ghc-pkg is still the tool for that
10:35:56 <Botje> vixey: i spent some time yesterday outputting to c--
10:36:08 <Botje> but the reference c-- compiler (quick c--) generates awful code
10:36:13 <smg> hello.
10:36:16 <Botje> i'm not sure if that's my fault or the compiler's
10:36:16 <dcoutts_> dons: so what we have in gentoo is an "eclass" that is basically a library of code that each individual haskell package imports. That means each package description can be really simple as it just calls out to the lib.
10:36:23 <smg> xs = [(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a]
10:36:25 <tusho> hsBlosxom. Who's interested?
10:36:27 <smg> is inperformant.
10:36:29 <smg> can i make it more perfomant?
10:36:44 <dcoutts_> dons: the lib then of course does the stuff like compiling setup.hs and calling configure, build, copy, register etc etc.
10:36:47 <smg> > (4000,5) `elem` [(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a]
10:36:53 <smg> "Thread killed"
10:37:26 <dcoutts_> dons: I do not recommend the registration scripts that cabal can generate. Have cabal generate installed package description files instead and register/unregister those.
10:37:38 <Botje> smg: how are you going to be using that list?
10:37:40 <dons> hmm ok
10:37:53 <smg> it should terminate for nearly all pairs in finite time
10:38:04 <smg> Botje: that list comprehension is already diagonalized?
10:38:12 <tusho> :)
10:38:16 <Igloo> dcoutts_: Huh? Why's that?
10:38:17 <vixey> Prelude> (4000,5)`elem`[(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a]
10:38:17 <vixey> True
10:38:28 <mauke> elem will not terminate for tuples not in the list
10:38:29 <vixey> it returns almost instantly
10:38:34 <smg> sure
10:38:39 <smg> vixey: at my pc not
10:38:40 <dcoutts_> dons: since arch is a binary package you want to include the package registration file into the binary package and then call ghc-pkg update $file as a post-inst action
10:38:46 <dcoutts_> Igloo: well, do you use them?
10:38:49 <vixey> smg: The answer is True
10:38:51 <Igloo> dcoutts_: Yes
10:38:56 <dons> dcoutts_: right.
10:39:00 <smg> 0,51 secs
10:39:09 <dcoutts_> Igloo: and the ghc path on the build machine matches the one on the target?
10:39:11 <smg> try
10:39:22 <smg> (40000,5)`elem`[(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a]
10:39:25 <smg> what about that?
10:39:30 <Igloo> dcoutts_: Yup
10:40:09 <smg> i killed vixey :((
10:40:44 <dcoutts_> Igloo: and you store the register and unregister script in the .deb?
10:41:57 <Igloo> dcoutts_: Yup
10:42:17 <dcoutts_> Igloo: well, great :-)
10:42:30 <Igloo> That's exactly what this functionality was designed for!
10:42:51 <dcoutts_> it seems unnecessarily complex to me
10:42:52 <Igloo> Doing it your way will break if a package needs to do anything odd when registering
10:42:57 <dcoutts_> I don't trust it
10:42:59 <geezusfreeek> i have created arch packages from cabal packages before
10:43:01 <geezusfreeek> it works great
10:43:13 <dcoutts_> Igloo: but they cannot spit anything into the register script anyway
10:43:19 <dcoutts_> and if they can I don't want them to
10:43:21 <geezusfreeek> the way Igloo advocates
10:43:50 <lilachaze> smg: you appear to have found a quadratic time solution to a constant time problem. :)
10:44:06 <Igloo> dcoutts_: They can put whatever they want into register.sh if they write their own Setup.hs
10:44:14 <smg> lilachaze: suggest solution
10:44:25 <smg> lilachaze: i am not able to figure out
10:44:36 <dcoutts_> Igloo: 1. none do 2. I bet the first to do so will do it wrong  :-)
10:44:55 <dcoutts_> 3. all the others will do it wrong too
10:45:04 <geezusfreeek> dcoutts_: it is your responsibility to check these things before installing stuff
10:45:05 <Igloo> Well, then it's their bug, not the packager's  :-)
10:45:17 <tusho> Anyone?
10:45:48 <smg> lilachaze: ?!
10:45:54 <dcoutts_> Igloo: but if you don't hand out so much rope...
10:45:55 <geezusfreeek> dcoutts_: in fact, if you use the yaourt tool on arch linux to install packages from aur you are prompted to check the install scripts for each package
10:46:07 <dcoutts_> geezusfreeek: exactly!
10:46:13 <dcoutts_> because nobody trusts them!
10:46:29 <dcoutts_> if it's just data like a package registration file then there is no problem
10:46:34 <geezusfreeek> dcoutts_: requirement to check them does not imply they are a bad idea
10:46:52 <geezusfreeek> i agree they are less "pure"
10:46:57 <vixey> @seen Cale
10:47:13 <vixey> :[
10:47:29 <Cale> @bot
10:47:30 <geezusfreeek> arch linux is not designed around purity anyway. it's designed around convenience for people who _know what they are doing_
10:47:48 <dcoutts_> afaics it pointlessly turns data into code
10:47:58 <vixey> Cale, you know, BindIO :: IO a -> (a -> IO b) -> IO b
10:48:17 <vixey> I've tried to write runIO :: IO a -> P.IO a
10:48:19 <byorgey> tusho: what's hsBlosxom?
10:48:23 <vixey> P is Prelude
10:48:33 <Igloo> dcoutts_: It also abstracts between the different impls
10:48:48 <Cale> vixey: okay
10:48:49 <vixey> but I don't know, it doesn't seem possible to write runIO for BindIO
10:49:03 <dcoutts_> Igloo: the package manager must be aware of that stuff anyway, it doesn't help anything
10:49:08 <geezusfreeek> with the exception of heuristic merge algorithms, there is no standardized way to make changes to files in linux in a declarative, safe way. an install script is the only general way
10:49:27 * thetallguy ponders the irony of installing Haskell on a Linux designed for tinkering.
10:49:34 <geezusfreeek> and we all know that merging without the user checking is a bad idea anyway
10:49:49 <Igloo> dcoutts_: It means it's one less thing you need to vary when building for mutiple impls
10:50:00 <vixey> runIO (BindIO m a) = runIO (a (runIO m)) -- for example, doesn't work
10:50:06 <dcoutts_> Igloo: I see that in principle it might, but since it's only 10% of the problem and for the other 90% you still need to know if you're dealing with ghc/nhc/hugs
10:50:20 <Cale> vixey: runIO (BindIO x f) = do v <- runIO x; runIO (f v)
10:50:20 <Cale> ?
10:50:45 <geezusfreeek> for a binary package i can't imagine there is much flexibility in which compiler you use
10:50:47 <tusho> byorgey: do you know what Blosxom is?
10:50:50 <vixey> oh, I see
10:50:52 <Igloo> dcoutts_: Hmm? When do you need to know which you are dealing with, except for configure --with-compiler=?
10:50:54 <vixey> Cale, yes that works
10:51:13 <vixey> cool :D
10:51:13 <smg> vixey: do you have an idea to optimize that?
10:51:16 <tusho> byorgey: it's a blogging program that uses the basic filesystem and a simple flatfile structure to manage a blog
10:51:26 <Botje> gah
10:51:28 <tusho> it can generate static html pages or as a dynamic cgi
10:51:32 <Botje> qc-- is _REALLY_ generating shit code
10:51:36 <tusho> and has an extensible plugin mechanism
10:51:37 <byorgey> tusho: ah, I see.  so what would hsBlosxom be?
10:51:39 <dcoutts_> Igloo: what to run when during install/uninstall/re-install, how to build Setup.hs, I can go find more stuff from our eclass...
10:51:42 <smg> > (40000,5)`elem`[(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a]
10:51:43 <olsner> hsBloxsom? haskell mod for blosxom?
10:51:46 <lambdabot> Terminated
10:51:47 <vixey> > True
10:51:49 <lambdabot>  True
10:51:52 <tusho> byorgey: well, it was like 300 lines of code, too, so it was very minimal
10:51:52 <smg> won't terminate, because it's too bad.
10:51:52 <tusho> and
10:51:58 <tusho> since the development is pretty stagnant
10:52:07 <tusho> there are quite a few clones - including pyblosxom and blojsom
10:52:11 <tusho> (in python and java)
10:52:18 <ndm> dcoutts: cabal question, i'm just adding support for packages and verions to hoogle - would "package name(version)" be appropriate syntax for a package name and version declaration? is there something better?
10:52:19 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
10:52:19 <vixey> smg: s is any non-negative number
10:52:24 <Igloo> dcoutts_: I don't understand. "Setup copy", "Setup register --gen-script" and "./register.sh" are how you install for any impl
10:52:26 <tusho> hsBlosxom would be a blosxom clone, but since it was in haskell, it'd be about 50x more awesome
10:52:27 <tusho> :p
10:52:28 <ndm> @messages
10:52:28 <lambdabot> Botje said 5d 23h 51m 54s ago: Can you give me a pong when you're here? I've got a question about uniplate.
10:52:39 <ndm> Botje: pong
10:52:44 <byorgey> tusho: sounds cool, go for it =)
10:52:48 <dcoutts_> ndm: there is a PackageIdentifier type with a corresponding parser and pretty-printer
10:52:50 <tusho> byorgey: alright
10:53:01 <dcoutts_> ndm: it's basically "foo-1.0" for syntax
10:53:04 <ndm> dcoutts_, oh, sounds cool :)
10:53:04 <vixey> smg: (40000,5) to be in there, there must exist some s in [0..], a in [1..s], such that (40000,5) = (5*a, 2*b+1)
10:53:13 <olsner> hmm, so hsBloxsom is something that's not started yet?
10:53:13 <ndm> dcoutts_: perfect :)
10:53:16 <tusho> olsner: yes
10:53:27 <dons> anyone else see the new haskell startup sneak onto the haskellwiki last week?
10:53:29 <dons>  http://tupil.com/
10:53:32 <lambdabot> Title: (,) tupil
10:53:42 <olsner> well, it sounds like it could certainly turn out awesomely (being written in haskell and all)
10:53:43 <vixey> smg: if 40000`mod`5 == 0, the we know that a = 40000`div`5, right?
10:53:48 <dcoutts_> Igloo: how do you run the Setup.hs? You need to select an appropriate version of the Cabal lib and that's ghc-specific
10:53:59 <ndm> dcoutts_, i don't suppose that is a parsec parser? or can it be wrapped into one?
10:54:01 <dcoutts_> Igloo: you can't use runhaskell for that
10:54:13 <vixey> smg: so now you just need to find some non-negative s such that 5 = 2*(s - a)+1
10:54:15 <dcoutts_> ndm: it's ReadP and Doc
10:54:25 <tusho> olsner: guess I'll get on to it then!
10:54:34 <tusho> TAP TAP mkdir git init emacs TAP TAP
10:54:48 <Igloo> dcoutts_: I just use the Cabal that comes with GHC
10:54:48 <ndm> dcoutts: to use it in a parsec parser, would it be easier to rewrite it, or something else?
10:54:51 <tusho> hsBlosxom is a kinda lame name though. What about blohsom?
10:54:59 <FordCortina> im trying to build fgl, its saying that it cant find Data.Tree because it is hidden....
10:55:20 <FordCortina> because containers-0.1.0.1 is hidden
10:55:26 <FordCortina> this is wierd because
10:55:29 <dcoutts_> Igloo: but that means you need to say ghc -package Cabal-1.2.3.0 so that we don't select another version that might be floating around. Perhaps you have the luxury of a completely clean build host.
10:55:31 <slavik> I am trying to change the factorial function to return the list of the factorials upto n, I am having trouble with the recursion
10:55:34 <FordCortina> containers is not hidden
10:55:39 <smg> vixey: but then it will only be fast for 40000,5 or??
10:55:44 <olsner> yes, blohsom is even a better name than bloxsom imo
10:55:48 <FordCortina> and i can import Data.Tree in my programmes :S
10:55:49 <vixey> smg: think a bit more
10:55:58 <ndm> @tell Botje am around at the moment, but am not much on IRC - may be better to email
10:55:59 <lambdabot> Consider it noted.
10:56:02 <vixey> smg: it will extend to anything
10:56:03 <tusho> olsner: blosxom
10:56:05 <smg> vixey: okay i try to figure out
10:56:06 <dcoutts_> ndm: if you want it as parsec then yes, just grab the code and translate. The ReadP combinators are similar.
10:56:07 <Igloo> dcoutts_: No, if you have installed more versions then that's your problem
10:56:16 <smg> 5 = 2*(s - a)+1
10:56:16 <dons> chr1s: so is there going to be an announcement about tupil.com? :)
10:56:18 <ndm> dcoutts_, fantastic
10:56:18 <dcoutts_> Igloo: but users are always allowed to do that
10:56:19 <smg> this i do need to solve?
10:56:40 <Botje> ndm: it was a question about descend, but I figured out how to use it now. thanks for the reply though :)
10:56:41 <lambdabot> Botje: You have 1 new message. '/msg lambdabot @messages' to read it.
10:56:46 <geezusfreeek> does pacman itself allow for multiple versions of the same package at the same time?
10:56:47 <Igloo> dcoutts_: Sure, and they can install versions of gcc that are incompatible with their GHC, and they can not have /usr/bin in their PATH, and ...
10:56:48 <vixey> you already know a and the domain of s
10:57:00 <olsner> 'blosxom' is it? even worse :P
10:57:04 <FordCortina> oh wait
10:57:05 <ndm> Botje: ah, good good :)
10:57:11 <Igloo> dcoutts_: Don't forget that for teh most part I'm interested in the Debian autobuilders being able to build the package
10:57:12 <FordCortina> haha ive got fgl already
10:57:17 <FordCortina> that was dumb
10:57:20 <FordCortina> :P
10:57:31 <smg> vixey:  5 = 2*(s - a)+1 <=> 5 = 2*s -2*40000 + 1 ?
10:57:33 <dcoutts_> Igloo: right, it's a bit more tricky building stuff on end-users machines
10:57:37 <geezusfreeek> i'd say it's only important if it can still be an issue when using only the distro's package manager
10:57:37 <tusho> olsner: hmm, I think I can support dynamic+static rendering with the same infastructure
10:57:41 <tusho> so e.g. you can have comments with either
10:57:44 <Igloo> dcoutts_: And if I /did/ constrain the Cabal version, then that would get in the way of someone who actually needed to use a later version that they'd installed
10:57:50 <tusho> Though, if you want search, I'm afraid that'll have to be a cgi ;)
10:58:19 <ziman> > let facs = 1:zipWith (*) facs [1..] in facs
10:58:20 <dcoutts_> Igloo: yes, we pick the highest version that was installed via the package manager (and not one that the user registered manually)
10:58:21 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
10:59:09 <smg> 5 = 2*s -2*40000 + 1 <=> 5 + 80000 -1 = 2*s
10:59:16 <ziman> @hoogle fix
10:59:17 <lambdabot> Data.Function.fix :: (a -> a) -> a
10:59:17 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
10:59:17 <lambdabot> Control.Monad.Fix :: module
10:59:18 <smg> 2s = 80004 <=> s = 40002
10:59:23 <smg> vixey: is this true?
10:59:47 <vixey> is what true?
10:59:52 <smg> the calculation?
11:00:09 <tusho> Hm.
11:00:18 <tusho> How should I use tags insetad of categories, with a fs-based system?
11:00:20 <tusho> *instead
11:00:29 <tusho> Symlinks? :-P
11:00:49 <Botje> :[
11:00:57 <Botje> time to output C instead of c--
11:01:39 <smg> vixey: isn't that what you meant i need to do?
11:02:20 <tusho> :\
11:02:34 <lilachaze> smg: you want to know whether there exist a <- [0..], b <- [0..] with (5*a, 2*b+1) == (40000,5)
11:02:44 <smg> no
11:02:47 <smg> or maybe yes
11:02:53 <smg> i jsut want to have it terminated in finite time
11:02:57 <smg> not infinite time
11:03:33 <lilachaze> smg: this splits into two subproblems: is there an a <- [0..] with 5 * a = 40000, and is there a b <- [0..] with 2*b+1 == 5?
11:04:02 <smg> i see
11:04:21 <lilachaze> smg: first, try to convince yourself that your (...) `elem` [...] is equivalent to my statement that "you want to know whether there exist ...". we can go from there.
11:04:40 <smg> maybe my code is just bad, i need to have the enumeration of tuples of the form (a,b) where a = dividable by 5 and b is a odd number!
11:04:59 <smg> i mean list of [(a,b)]
11:05:17 <lilachaze> smg: ok, just so i'm clear: is your goal here (a) to find such a fair enumeration, or (b) to find whether a certain element would be contained within it?
11:05:28 <smg> fair enumeration!
11:05:39 <vixey> the program is \p q -> (p,q)`elem`[(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a]
11:06:00 <smg> [(5*a, 2*b+1) | s <- [0..], a <- [1..s], let b = s - a] <-- this ain't fair?
11:06:00 <lilachaze> then i think what you've already got is fine
11:06:03 <tusho> anyone have ideas?
11:06:14 <malebria> Good afternoon.
11:06:19 <slavik> fac l n = fac l (n-1):l
11:06:21 <smg> there is no improvement of that list comprehension then?
11:06:22 <vixey> you can think of it as,  exists s in [0..], a in [1..s], b = s - a,  (p,q) = (5*a,2*b+1)
11:06:28 <slavik> why is that wrong?
11:06:35 <byorgey> hi malebria
11:06:39 <vixey> for that to be true, you must have p`mod`5 == 0
11:06:44 <lilachaze> smg: well, if you know what element you want, you can arrange for that to be earlier in the list.
11:06:48 <vixey> if it's not the answer is certainly False, so you short cut
11:06:57 <vixey> if the answer is True, then a = p`div`5
11:06:58 <malebria> I've made a change in XMonadContrib library, and loaded my .xmonad/xmonad.hs file with GHCi, and it worked.
11:07:09 <byorgey> slavik: what function are you trying to write?
11:07:09 <malebria> I rebooted, and it didn't work anymore.
11:07:25 <slavik> a factorial function that builds a list of factorials
11:07:27 <lilachaze> smg: otherwise, the distance to an element grows quadratically with the size of the larger element (since the number of elements 'before' it in the diagonalization grows quadratically)
11:07:30 <malebria> My idea was that it shouldn't work, but why it has changed only after rebooting?
11:07:33 <vixey> so now you have to solve, exists s in [a..], b = s - a, q = 2*b+1
11:07:39 <tusho> Meh
11:07:40 <malebria> is there some kind of cache of libraries?
11:07:56 <vixey> which is the same as, exists s in [a..], q = 2*(s-a)+1
11:08:02 <smg> vixey: i see
11:08:11 <lilachaze> slavik: you don't appear to have a terminating condition
11:08:19 <slavik> fac l 0 = 1:l
11:08:20 <vixey> smg: so you end up with a program that doesn't use lists at all
11:08:24 <slavik> that's another line in my file
11:08:26 <byorgey> malebria: what exactly do you mean, you loaded xmonad.hs and "it worked"?  you mean xmonad.hs loaded with no errors?
11:08:29 <smg> vixey: i see
11:08:31 <lilachaze> slavik: and your program isn't well-typed.
11:08:42 <dons> ?users
11:08:43 <lambdabot> Maximum users seen in #haskell: 465, currently: 442 (95.1%), active: 24 (5.4%)
11:08:45 <smg> vixey: so with lists i don't have a chance?
11:08:49 <slavik> in my defense, I am a noob
11:08:58 <byorgey> slavik: you probably want parentheses like this: fac l ((n-1):l)
11:09:02 <lilachaze> slavik: actually, it is well-typed, but..
11:09:06 <vixey> smg: I explained a way to rewrite the programa
11:09:07 <smg> fac = factorial?
11:09:11 <byorgey> slavik: function application has higher precedence than anything else
11:09:13 <smg> vixey: yes
11:09:22 <smg> vixey: i need to thank you for that i know :]
11:09:24 <byorgey> slavik: so  fac l (n-1):l gets parsed as  (fac l (n-1)):l
11:09:44 <malebria> byorgey: no errors or warnings.
11:09:50 <malebria> byorgey: after reboot I can't load it.
11:10:45 <Vq^> > scanl (*) 1 [1..]
11:10:47 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
11:10:48 <lilachaze> > let fac l n = l:fac (n*l) (n+1) in fac 1 1
11:10:49 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
11:10:57 <byorgey> malebria: let's take this to the #xmonad channel, less noise there
11:11:39 <slavik> lilachaze: that's not exactly the fib sequence
11:11:51 <lilachaze> slavik: not really, no :)
11:12:20 <tusho> Hmm.
11:12:24 <lilachaze> slavik: but there's something especially perverse about calling a function to generate fibs 'fac' :)
11:12:28 <tusho> What heirarchical packagedoodle would Blohsom fit in?
11:12:32 <tusho> RIght now I'm just doing Blohsom.
11:13:15 <slavik> fac [l:ls] n = n*l:fac ls (n-1)
11:13:23 <slavik> oh, wait
11:13:24 <Vq^> lilachaze: not talking about describing it as "a factorial function that builds a list of factorials"
11:13:26 <hpaste>  smg pasted "good fac" at http://hpaste.org/8239
11:13:26 <slavik> factorials, p00p
11:13:31 * slavik confused himself
11:13:36 <smg> slavik: look the paste
11:13:39 <slavik> a sequence of factorials ...
11:13:47 <tusho> :\
11:14:15 <sclv> tusho: if its a program instead of a library, then it doesn't need to fit in.
11:14:29 <tusho> sclv: Yes, probably.
11:14:35 <tusho> Though it _is_ a library, technically.
11:14:45 <tusho> There's a few programs running on it: blohsom, blohsom.cgi, search.cgi.
11:14:54 <tusho> But they're more like pretty thin wrappers.
11:14:58 <tusho> No more than 200 lines.
11:15:13 <sclv> right: and they're your programs. you're not expecting end-users to impor it
11:15:47 <tusho> sclv: Well, if they're writing a plugin...
11:16:35 <sclv> xmonad, for example, uses a top level namespace.
11:16:48 <dcoutts_> ndm: what was the context btw? what is this syntax for?
11:17:36 <tusho> sclv: Yes, but what about plugins?
11:17:38 <tusho> They'll import Blohsom.
11:17:40 <tusho> Although.
11:17:41 <hexpuem> anyone here use ModelView for tables with gtk2hs?
11:17:44 <tusho> They'll live in Blohsom.Plugins.*
11:17:54 <sclv> I think that's how xmonad works too.
11:18:03 <dcoutts_> hexpuem: I don't use it much but I wrote the binding
11:18:22 <hexpuem> are there any examples of getting sorting to work?
11:19:23 <smg> ty vixey
11:19:31 <smg> slavik: you looked at it?
11:19:41 <dcoutts_> hexpuem: no, that's not so easy. I think it's possible with what we've got at the moment.
11:20:02 <dcoutts_> hexpuem: you'd have to use the sort model adapter
11:20:28 <ndm> dcoutts: for Hoogle, I'm adding package support to the database format
11:20:33 <hexpuem> ok thanks
11:20:58 <mix25> Any idea how to make this: [(1,3),(3,1),(4,2),(6,3),(7,1)] = [3,1,2,3,1]
11:20:59 <dcoutts_> ndm: so is this for queries then?
11:21:18 <slavik> yes, but will that generate a list?
11:21:19 <dmwit> mix25: map snd?
11:21:24 <smg> indeed
11:21:25 <dcoutts_> ndm: or just as an internal serialisation format?
11:21:40 <smg> mix25: map (snd) [(1,3),(3,1),(4,2),(6,3),(7,1)
11:21:43 <smg> > map (snd) [(1,3),(3,1),(4,2),(6,3),(7,1)
11:21:43 <lambdabot>  Parse error at end of input
11:21:46 <smg> > map (snd) [(1,3),(3,1),(4,2),(6,3),(7,1)]
11:21:47 <hpaste>  dmwit annotated "function to find all "straights" in a list of cards" with "one minor suggestion" at http://hpaste.org/8225#a2
11:21:47 <lambdabot>  [3,1,2,3,1]
11:22:02 <mix25> thanks i'll try
11:22:04 <byorgey> no need for the () around snd
11:23:00 <ndm> dcoutts_: no, for the database input file, so it knows which information is available - the query parsing will be unversioned
11:23:27 <dcoutts_> ndm: ah, right yes, you'd not normally care about versions in the query
11:24:51 <ndm> dcoutts: i expect only one version of each package to be installed
11:24:59 <ndm> or at least hte hoogle database for one version
11:25:24 <dcoutts_> ndm: might be tricky. It's not possible to install every package at once if you only allow one version of each package.
11:25:57 <ndm> dcoutts_: for hoogle, the most recent version of each package that worked is probably plenty - you probably don'
11:25:58 <dcoutts_> ndm: eg the current state of hackage requires at least two versions of haxml to be able to install certain combinations of packages
11:26:16 <ndm> dcoutts_: don't want to start using old API methods which have since been removed
11:26:20 <dcoutts_> ndm: if you don't need them to be consistent then it's no problem
11:27:10 <ndm> dcoutts_: searching fortunately can be rather lax about these things :)
11:27:19 <dcoutts_> right :-)
11:30:31 <vixey> instance Monad IO where
11:30:31 <vixey>  return = ReturnIO
11:30:31 <vixey>  (>>=) = BindIO
11:30:31 <vixey> getChar = GetChar
11:30:31 <vixey> putChar = PutChar
11:30:40 <vixey> so simple :)
11:30:46 <quicksilver> the thing about benchmarks is you are often not measuring the thing you thought you were measuring.
11:31:07 <quicksilver> you'd think I would have learnt that by now.
11:31:53 <lilachaze> vixey: next I'd like to see the implementation of unsafePerformIO :)
11:32:05 <vixey> hmmmm
11:32:09 <smg> vixey: you are very clever!
11:32:15 <roconnor> vixey: GADT?
11:32:18 <vixey> smg: That's due to Cale
11:32:31 <vixey> roconnor: yes
11:32:32 <smg> true, Cale is also extreme clever :)
11:32:52 <smg> btw hello Cale ;)
11:32:55 <vixey> roconnor: This is great because I can now have side effects in totally pure way
11:33:12 <quicksilver> vixey: there is a model of IO along those lines for testing purposes
11:33:14 <quicksilver> on hackage
11:33:16 <vixey> I don't think I can implement unsafePerformIO
11:33:19 <quicksilver> it might be called 'IOSpec' or something ?
11:33:28 <tusho> Hm. What should I use for a config file for a haskell app?
11:33:31 <vixey> cool I'll have a look
11:33:53 <dons> tusho: can you elaborate?
11:33:55 <dmwit> tusho: Haskell!
11:33:57 <sclv> tusho: follow the xmonad model, have the config file be an embedded haskell dsl!
11:34:03 <ibid> tusho: depends on the app
11:34:08 <dons> or you can read/show a haskell data structure
11:34:15 <dons> that's the cheapest way, usually
11:34:15 <dmwit> ooooo
11:34:18 <roconnor> vixey: this is also written at the top of http://luqui.org/blog/archives/2008/03/29/io-monad-the-continuation-presentation/
11:34:19 <lambdabot> Title: IO Monad: The Continuation Presentation @ The dreams that stuff is made of, http://tinyurl.com/5dbq4p
11:34:20 <tusho> dons: For Blohsom.
11:34:20 <ibid> tusho: i personally believe the important point of an app is what it does, not what it is written in
11:34:20 <Japsu> i can haskell databurger
11:34:33 <dons> tusho: oh, probably just read/show will do, of some data Config type
11:34:35 <tusho> dmwit: sclv: No. I don't want to require ghc. :P
11:34:43 <tusho> dons: That's not very human-editable!
11:34:46 <ibid> tusho: the more it's geared for the common user the less it should show what's under the hood
11:34:50 <dons> tusho: sure it is
11:35:01 <dmwit> read++
11:35:02 <dons> Config { url = "http://google.com", title = "my blog" }
11:35:09 <quicksilver> there is also CosmicRay's config reader
11:35:12 <quicksilver> modelled on the python one
11:35:19 <tusho> dons: Yes, but consider if you have, say, 30 config options..
11:35:20 <quicksilver> ConfigParser is it called? or ConfigFile ?
11:35:24 <tusho> Right now I'm leaning to YAML.
11:35:25 <roconnor> vixey: you need to mod out by an equivalence relation, which is a little annoying
11:35:26 <ibid> read/show is what i'd use as a fisrt cut, too :)
11:35:27 <dons> tusho: then you'll have 30 fields :)
11:35:29 <smg> vixey: is Cale your teacher? if he is that's hte best it can happen i guess :]
11:35:40 <dons> you could write a config parser too, of course
11:35:43 <tusho> dons: and it'll show into a very long line
11:35:48 <tusho> Anyway, I'll probably use YAML.
11:35:51 <dons> tusho: well, you can pretty print it.
11:35:58 <dons> yeah, just use a parser then
11:36:00 <vixey> roconnor: I don't see why
11:36:01 <dons> to build the Config type
11:36:03 <tusho> dons: Which requires a lib: at which point I should just use yaml
11:36:11 <vixey> roconnor: which equivalence?
11:36:40 <roconnor> vixey: the one that says bind is assoctive, and has the return-bind laws
11:36:51 <dons> tusho: right, use one of the parser libraries
11:36:54 <dons> e.g. the yaml parser
11:37:11 <dons> hey, go with xml :)
11:37:12 <tusho> Which yaml parser should I use, though?
11:37:23 <tusho> Eww, xml. I said human readable and writable!
11:37:46 <mmorrow> morse code!
11:37:55 <roconnor> vixey: which is okay.  But you wont have IO semantics until you write down that equivalence relation.
11:38:12 <dons> tusho: one of the ones on hackage.
11:38:22 <dons> you could do a survey, and work out which one is nicest.
11:38:29 <roconnor> vixey: and I cannot help but think that there is some other data structure that better captures IO (needing a smaller equivalence relation).
11:39:20 <vixey> I still don't see where the equivelence comes into it
11:39:34 <vixey> say I have some program :: IO a
11:39:56 <vixey> since it's a function, it'll always return the same value*
11:40:07 <vixey> I just realized that input messes that up
11:40:10 <roconnor> vixey: flip Bind Return x  is supposed to be the same as x
11:40:30 <roconnor> vixey: flip BindIO ReturnIO x  is supposed to be the same as x
11:40:38 <roconnor> but they are two different structures in your GADT
11:40:39 <vixey> roconnor: yes, that's just for programmers to know, isn't it?
11:40:47 <roconnor> sure
11:41:14 <roconnor> but imagine a data structure that captures the notion of IO exactly
11:41:23 <roconnor> wouldn't that be cooler?
11:41:45 <roconnor> OTOH, what are you trying to do with IO anyways?
11:43:14 <vixey> just seeing how it fits in with everything else and how it could be modeled
11:43:48 <vixey> I don't know how I could get closer to what IO is than this GADT really
11:44:28 <vixey> it would be nice of course
11:45:09 <dmwit> type IO a = State (String, String) a -- ?
11:45:27 <roconnor> vixey: what about IO a = ((a -> String -> String) -> String -> String) ?
11:45:36 <roconnor> dmwit: I don't think that works
11:45:45 <hexpuem> Is it possible to change the float -> str formatting of cells with gtk2hs, without switching to ModelView? The CellLayout set_data_func callback is missing in the bindings
11:46:00 <dmwit> getChar = gets (head . fst) <* modify (first head)
11:46:13 <dmwit> putChar x = modify (second (x:))
11:46:15 <dmwit> ?
11:46:20 <tusho> dmwit: Win!
11:46:52 <dcoutts_> hexpuem: you can use whatever haskell function you like to map your data to attributes of the cell renderers
11:47:12 <dmwit> roconnor: What dies?
11:47:19 <dcoutts_> hexpuem: so if you don't like show then use one of the other formatting functions from the Numberic module
11:48:11 <dcoutts_> hexpuem: or did I misunderstand your question?
11:49:11 <hexpuem> nah i just wanted to round to change float display to two decimal places
11:49:44 <hexpuem> cellText property in cell layout sets the conversion function though right?
11:50:11 <vixey> I don't know what String has to do with IO
11:50:31 <dmwit> Same thing getChar has to do with IO.
11:50:48 <dcoutts_> hexpuem: there's no implicit conversion function, you can use any function to map your data to the String that cellText expects
11:51:15 <hexpuem> ok thanks
11:51:34 <roconnor> dmwit: ah right,  I was thinking (a,(String, String) -> (String, String)), but that isn't what you have.
11:51:45 <dcoutts_> hexpuem: have you looked at the demos? they've got examples of using functions to set the cellText
11:51:45 <CosmicRay> quicksilver: ConfigFile these days.  software.complete.org/configfile
11:52:00 <CosmicRay> quicksilver: it used to be named ConfigParser after Python's, and the ConfigParser I wrote in ocaml
11:52:05 <hexpuem> yea
11:52:08 <hexpuem> looking at them again
11:52:12 <mix25> How to put the correct ident of my haskell code? There is some apps to make this when I selected my code?
11:52:17 <CosmicRay> quicksilver: but it can write files too so that was a bit misleading
11:52:23 <hexpuem> i wasnt sure if that attribute only worked with ModelView stuff
11:52:23 <ndm> dcoutts: have you seen windows delete on reboot flag?
11:52:27 <dmwit> mix25: No, you have to do it yourself.
11:52:34 <mix25> f...
11:52:36 <mix25> !
11:52:45 <dmwit> mix25: Since changes in indentation can change the meaning of the program, there's no way for an automatic tool to know the right indentation.
11:52:57 <dmwit> mix25: But really, it's not that hard.  Do you know the indentation rules?
11:52:58 <ndm> dcoutts: re bug 291
11:53:09 <dcoutts_> ndm: that's pretty unhelpful sadly, who reboots?
11:53:40 <sjanssen> Windows users?
11:53:41 <mix25> dmwit i think this is the problem :) :P
11:53:58 <ndm> dcoutts: everyone! you have to reboot to install security updates, if you don't reboot your computer will die
11:54:05 <mix25> Could you look it and say me if see something wrong?
11:54:26 <dcoutts_> ndm: and why do they do that? because they can't overwrite files! :-)
11:54:34 <dmwit> mix25: The short answer is that all lines in a do, let, or where block need to be indented to the same depth; and that depth needs to be different from all previous depths.
11:54:44 <dmwit> mix25: But sure, stick it on hpaste.org and we'll take a look at it.
11:54:52 <mix25> okey
11:55:13 <ndm> dcoutts_: and because life requires it - will give details on the bug, so if its useful someone can do it
11:55:37 <dcoutts_> ndm: I've seen that MoveFile feature. I'd rather not if we can avoid it.
11:56:25 <dcoutts_> ndm: I had to do this before for a remote update software for an AV company. I spent quite a while researching the problem that time. No solution is pretty.
11:56:54 <sclv> hmm.. code.h.o only seems to be running darcs 1 ?
11:57:00 <sclv> any plans to upgrade?
11:57:05 <ndm> dcoutts_: if you want Win9x support, then it gets a lot uglier :)
11:57:08 <bauchus> > floor 1.3 + 0.5
11:57:09 <lambdabot>  Add a type signature
11:57:13 <dcoutts_> ndm: one cheeky one is to use ntdll functions to unmap the exe file :-) works as long as you don't need to be swapped out :-)
11:57:21 <dmwit> > floor (1.3 + 0.5)
11:57:22 <lambdabot>  1
11:57:28 <dcoutts_> ndm: oh yeah, that had to work too last time. This time we're more fortunate.
11:57:32 <bauchus> no!
11:57:51 <bauchus> > (floor 1.3) + 0.5 :: Double
11:57:52 <lambdabot>   add an instance declaration for (Integral Double)
11:57:59 <dmwit> bauchus: floor returns an Integral type.
11:58:01 <Tigran> > floor (1.3 :: Int) + 0.5
11:58:01 <lambdabot>   add an instance declaration for (RealFrac Int)
11:58:11 <dmwit> > fromInteger (floor 1.3) + 0.5
11:58:12 <lambdabot>  1.5
11:58:36 <bauchus> dmwit: this was my solution, too, but is there a better one?
11:58:37 <mix25> dmwit check this: http://hpaste.org/8242
11:58:40 <dmwit> bauchus: no
11:59:03 <bauchus> what does truncate?
11:59:15 <byorgey> > truncate 1.8
11:59:16 <lambdabot>  1
11:59:21 <byorgey> > truncate (-1.8)
11:59:23 <dmwit> mix25: Gee, I don't know, could it be the last three lines that are indented by like *20 tabs*?
11:59:24 <lambdabot>  -1
11:59:31 <dcoutts_> ndm: I think the way we did it for the AV installer was to run a cmd.exe script to wait a sec and then delete the installer exe :-)
11:59:35 <bauchus> i see
11:59:44 <dcoutts_> ndm: since batch files can delete themselves ok
11:59:49 <mix25> well winhugs say me Syntax error in declaration (unexpected `::')
11:59:59 <ndm> dcoutts: i think that's the way i have done it before, for another project
12:00:06 <mix25> in line NumeroDeVeces :: [[Int]] -> [Int]
12:00:24 <dmwit> mix25: Oh, function names must start with a lower-case letter.
12:00:27 <ndm> dcoutts_: although i think the command to delete the file must be on hte last line of the .bat file, or you get errors
12:00:32 <mix25> ohhfas
12:00:37 <roconnor> getChar k (i:is) = k i is
12:00:42 <dmwit> mix25: Upper case is reserved for concrete types and constructors.
12:00:46 <dmwit> (...and classes)
12:01:02 <byorgey> (...and module names)
12:01:21 <vixey> :t let getChar k (i:is) = k i is in getChar
12:01:23 <lambdabot> forall t t1. (t -> [t] -> t1) -> [t] -> t1
12:01:37 <roconnor> putChar x k is = (k () is)++"x"
12:01:44 <dmwit> mix25: May I humbly recommend that you stop using literal tabs?  Most especially in the middle of lines?
12:01:46 <roconnor> er
12:01:51 <roconnor> putChar x k is = (k () is)++[x]
12:02:13 <mix25> literal tabs?
12:02:16 <roconnor> :t let putChar x k is = (k () is)++[x] in putChar
12:02:18 <lambdabot> forall a t. a -> (() -> t -> [a]) -> t -> [a]
12:02:27 <dmwit> mix25: Yeah, tabs.  Use spaces instead.
12:02:34 * roconnor isn't happy with ++[x]
12:02:41 <hukolele> > matchRegex (mkRegex "\\(.\\)") "a"
12:02:41 <lambdabot>   Not in scope: `mkRegex'
12:02:58 <mix25> ok
12:03:02 <int-e> mix25: did you look at your own paste? the s = length  does nowhere line up with the  z = longListas(x:xs)
12:03:23 <roconnor> ohh it is backwards
12:03:26 <roconnor> good
12:03:32 <roconnor> :t let putChar x k is = x:(k () is) in putChar
12:03:34 <lambdabot> forall a t. a -> (() -> t -> [a]) -> t -> [a]
12:03:37 <tusho> Where's the Data typeclass thingy?
12:03:39 <mix25> al least!
12:03:46 <hukolele> why this regexp doesn't works as I expect? matchRegex (mkRegex "\\(.\\)") "a" == Just ["a"]
12:04:05 <dmwit> mix25: Are you allowed to use the Prelude?
12:04:12 <hukolele> where can I find a manual of regexp for haskell?
12:04:13 <mix25> yes
12:04:20 <dmwit> mix25: agrupar = group
12:04:24 <ski_> putChar x = shift k in \is -> x : k () is
12:04:31 <dmwit> mix25: agrupar' = groupBy
12:04:31 <mix25> group is in Data.List
12:04:42 <dmwit> ?index group
12:04:42 <lambdabot> Data.List
12:04:44 <dmwit> oh
12:04:50 <mix25> ;)
12:04:51 <ski_> getChar = shift k in \(i:is) -> k i is
12:04:52 <int-e> hukolele: don't use the \\ there.
12:04:55 <dmwit> You're not allowed Data.List, then?  bummer
12:04:59 <mix25> yes
12:05:09 <mix25> I cannot import other libraries
12:05:16 <vixey> shift ?
12:05:20 <hukolele> > import Text.Regex
12:05:21 <lambdabot>  Parse error at "impor..." (column 1)
12:05:21 <tusho> mix25: Homewerk?
12:05:21 <vixey> this is contination
12:05:30 <ski_> shift/reset, yes
12:05:31 <mix25> something like that
12:05:32 <int-e> hukolele: the regexp you gave matches "...(a)..."
12:05:40 <frwmanners> hukolele: drop the \\'s
12:06:10 <hukolele> and how can I group the dot exp?
12:06:13 <tusho> > id \a -> a 3
12:06:13 <lambdabot>  Parse error at "\a" (column 4)
12:06:14 <frwmanners> hukolele: brackets seem to work fine on their own
12:06:18 * tusho wonders wh y that errors
12:06:26 <dmwit> listaIgual = (==) `on` sort -- not quite equivalent, but probably what you wanted anyway
12:06:46 <dmwit> > id (\a -> a) 3
12:06:47 <lambdabot>  3
12:07:07 <dmwit> > id $ \a -> a 3
12:07:08 <lambdabot>  Add a type signature
12:07:14 <tusho> I know, dmwit
12:07:16 <hukolele> I was just following a tuto from posix regexps at the wikipedia so... how can I group a subexpression?
12:07:17 <tusho> I'm just wondering _why_
12:07:38 <ski_> @type id $ \a -> a 3
12:07:40 <lambdabot> forall t t1. (Num t1) => (t1 -> t) -> t
12:07:57 <frwmanners> hukolele: It's a bit stranged up across regex implementations I think; try mkRegex "(.)" and match on "a"
12:07:58 <dmwit> hukolele: Text.Regex has a groupByRegex
12:08:13 <tusho> hukolele: POSIX regexpsa re outdated.
12:08:14 <tusho> *are
12:08:15 <ski_> > id $ \a -> a 3 :: (Int -> Bool) -> Bool
12:08:18 <lambdabot>  <(Integer -> (Int -> Bool) -> Bool) -> (Int -> Bool) -> Bool>
12:08:19 <tusho> \(...\) is now normally (...)
12:08:23 <tusho> and \(...\) matches literal ( and )
12:08:35 <ski_> > (id $ \a -> a 3 :: (Int -> Bool) -> Bool) (> 0)
12:08:36 <lambdabot>  Couldn't match expected type `(Int -> Bool) -> Bool'
12:08:41 <dmwit> tusho: That is true in (modern) POSIX regexen, too.
12:08:44 <Deewiant> tusho: it seems to me that id \a -> a 3 would be parsed as (id \a) -> (a 3) or something
12:08:47 <roconnor> ski_: shift isn't defined in Control.Monad.Cont
12:08:54 <dmwit> tusho: (Having just read the spec yesterday, I happen to know. =)
12:09:00 <ski_> roconnor : well, it's easy to define
12:09:15 <hukolele> tusho: outdated? and what can I use instead of?
12:09:23 <tusho> hukolele: Another tutorial.
12:10:17 <dmwit> mix25: Also, many of your base cases can be omitted entirely.
12:10:21 <dcoutts_> ndm: I wonder if we could open our own exe file with FILE_FLAG_DELETE_ON_CLOSE
12:10:48 <quicksilver> CosmicRay: *nod* I've not used it yet myself
12:10:58 <quicksilver> CosmicRay: so far I've just used deriving (Read)
12:10:59 <dmwit> hukolele: pcre-light does perl-style regexen.
12:11:10 <quicksilver> CosmicRay: punted the config file problem for a while pending a bit more enlightenment
12:11:19 <dmwit> hukolele: But POSIX is not so bad as tusho seems to be suggesting, I think.
12:12:10 <tusho> dmwit: most tutorials teaching 'posix regexs' are
12:12:16 <tusho> Anyone re: Data?
12:12:27 <quicksilver> it's only emacs-style regexen where you need \( \) for grouping.
12:12:37 <quicksilver> perl-style and posix style have () for grouping
12:12:39 <roconnor> injectMyIO myIO = interact (myIO (const const []))
12:12:49 <quicksilver> and \( \) for literal ()
12:12:57 <hukolele> which kind of regexps implements Text.Regex  on GHC?
12:13:07 <tusho> hukolele: Perl-style, I believe.
12:13:08 <quicksilver> depends which one :)
12:13:12 <quicksilver> Text.Regex.Foo...
12:13:14 <ski_> shift f = Cont (\c -> f c `runCont` id)  -- this
12:13:16 <sclv> I thought that posix regexen also had asymptotically better performance possible.
12:13:22 <quicksilver> by default it links to your C libraries' regex
12:13:26 <quicksilver> which is likely to be POSIX
12:13:27 <ski_> shift f = Cont (\c -> f (\x -> Cont (\k -> k (c x))) `runCont` id)  -- or this
12:13:27 <dmwit> tusho, hukolele: GHC only comes with POSIX regexes.
12:13:30 <tusho> sclv: Perl regexps can get gnarly but meh
12:13:33 <quicksilver> but there is a perl backend
12:13:34 <tusho> dmwit: Oh, ok
12:13:38 <quicksilver> and a pure haskell backend
12:13:39 <vixey> :t interact
12:13:41 <lambdabot> (String -> String) -> IO ()
12:13:53 <dmwit> tusho: Are you thinking of Typeable / Dynamic?
12:13:57 <ski_> reset ma = Cont (\k -> k (ma `runCont` id))
12:14:13 <tusho> dmwit: No, I'm thinking of Data. That lets you examine the field names etc. does it not?
12:14:28 <dmwit> Sounds like a Template Haskell thing, then.
12:14:40 <diptansu> Hi. Is there a good haskell ODBC library that can be installed on a Windows system?
12:14:46 <dmwit> Not sure, though, I've never heard of it.
12:15:41 <hpaste>  morrow annotated "good fac" with "faster?" at http://hpaste.org/8239#a1
12:15:42 <roconnor> perhaps injectMyIO myIO = interact (myIO (\() -> const [])) is slightly better
12:15:47 <quicksilver> tusho: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
12:15:48 <lambdabot> http://tinyurl.com/6krmmj
12:15:59 <quicksilver> tusho: however if you plan to do actual work, rather than just being interested in it
12:16:06 <quicksilver> tusho: I recommend looking at uniplate first.
12:16:13 <int-e> hukolele: hmm. using Text.Regex.Posix and Text.Regex.Base  matchTest (makeRegexOpts compBlank execBlank "\\(a\\)") "a" returns True
12:16:18 <tusho> quicksilver: It's just for a config parser!
12:16:27 <tusho> I'm going to magically turn a YAML-parsed map into a data structure.
12:16:30 <tusho> With magic.
12:16:32 <tusho> And laziness.
12:16:32 <ski_> roconnor : `(const const [])' ?
12:16:41 <quicksilver> uniplate is much easier magic than data
12:16:44 <quicksilver> that's why I recommend it.
12:17:01 <sclv> diptansu: HDBC has an ODBC backend and works quite well.
12:17:03 <quicksilver> data is level 8 magic
12:17:07 <sclv> I think Takusen might as well.
12:17:09 <quicksilver> and requires several rare feats
12:17:58 <ndm> in general, if you need Data, you usually want to wrap it up and give a nicer interface
12:18:11 <hukolele> int-e: matchRegex (mkRegex "(.)") "a" == Just ["a"]  works fine so its not posix but: matchRegex (mkRegex "(.)\1") "aa" == Nothing ...
12:18:17 <ndm> its a little like unsafePerformIO - very handy, but not something to use directly
12:18:20 <dmwit> int-e: Weird.  So does ... "(a)") "a".
12:18:32 <quicksilver> and uniplate is (from one perspective) a nicer interface to Data.
12:18:33 <int-e> dmwit: no
12:18:48 <mmorrow> smg: uh, actually i'm not sure about that statement since the "same" thing still exists in the form of foldl' checking if the tail is []
12:18:48 <int-e> dmwit: not with the line I quoted
12:18:57 <quicksilver> tusho: having said that, the SYB papers are quite readable.
12:19:01 <smg> mmorrow: k
12:19:07 <quicksilver> (they describe Data)
12:19:08 <int-e> hukolele: both are posix, it just defaults to extended posix regular expressions
12:19:15 <ndm> indeed, uniplate is an interface on to the transformation bits, i've seen a few other interfaces onto other particular bits
12:19:15 <tusho> ais523:
12:19:16 <mmorrow> smg: what do you think
12:19:16 <tusho> @src print
12:19:16 <lambdabot> print x = putStrLn (show x)
12:19:22 <quicksilver> the problem is there are several SYB papers describe similar things
12:19:23 <tusho> oh
12:19:24 <tusho> ais523:
12:19:25 <tusho> @src print
12:19:25 <lambdabot> print x = putStrLn (show x)
12:19:29 <tusho> QED
12:19:31 <smg> mmorrow: i don't know what you'retalking bout
12:19:32 <quicksilver> but with wildly different syntaxes
12:19:34 <ndm> but reading the first SYB paper is well worth it :)
12:19:37 <dmwit> int-e: err... hum; "(a)" =~ "a" returns ["a"]
12:19:41 <tusho> ais523: got that?
12:19:42 <sclv> and the second.
12:19:43 <ndm> its well written, and very clever
12:19:47 <int-e> dmwit: I didn't write that, did I?
12:19:48 <mmorrow> smg: ha. i figured. http://hpaste.org/8239#a1
12:19:58 <dmwit> int-e: No, I did.
12:20:02 <sclv> after that it departs from the realm of the standard ghc Data
12:20:15 <dmwit> int-e: Oh, I got the arguments mixed around.
12:20:18 <dmwit> int-e: Compare:
12:20:18 <ndm> yeah, the third is wacky!
12:20:20 <smg> i think it should foldl' is optimized isn't it?
12:20:25 <tusho> Hmph. Data IS confusing!
12:20:28 <tusho> Link to that other thing?
12:20:28 <quicksilver> sclv: the first uses an entirely different syntax from the current Data.Generics though doesn't it?
12:20:32 <dmwit> int-e: ("a" =~ "(a)", "a" =~ "\\(a\\)")
12:20:34 <ndm> @where uniplate
12:20:35 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
12:20:43 <quicksilver> sclv: or do I misremember my papers.
12:20:56 <dmwit> int-e: (Results in (["a"], []).)
12:20:57 <sclv> quicksilver: I think the first and second together pretty much describe it as it stands.
12:21:13 <ndm> quicksilver: i know there were some wacky :*: and :+: mappings in earlier papers, but i think they are gone by SYB1
12:21:14 <sclv> the third is syb-with-class and the "Reloaded" series are utterly different.
12:21:17 <tusho> Basically.
12:21:20 <tusho> I have a map like
12:21:25 <tusho> {'foo_bar':'baz','ding_dong':'3'}
12:21:27 <int-e> dmwit: yes, because extended regular expressions are the default.
12:21:28 <tusho> and want to turn it into
12:21:37 <mmorrow> yeah, but if you adding let x = n*x in x `seq` fac_iter ... it'd be the same essentially, but foldl' just trades the n==0 check for pattern matching against [] to see if it's done
12:21:39 <tusho> MagicalWoo { fooBar = "baz", dingDong = 3 }
12:21:43 <bauchus> @where topkata
12:21:44 <lambdabot> I know nothing about topkata.
12:21:44 <tusho> by introspecting the types and stuff.
12:21:47 <dmwit> int-e: Oh, you don't *want* extended regex? okay, ignore me
12:21:56 <tusho> Can I do that easily?
12:21:58 <int-e> dmwit: I would. hukolele didn't :)
12:22:02 <mmorrow> smg: i dunno, they're probably equivalent
12:22:02 <ndm> tusho: sounds like this is beyond the power of SYB or Uniplate - you can't create these types at runtime
12:22:07 <sclv> tusho: this is possible. if you use json instead of yaml (I forget which is a superset of which) there's a library on hackage that already does itl.
12:22:17 <ndm> tusho: although HaXml does something slightly similar, for XML instead
12:22:21 <sclv> (assuming the data type already exists)
12:22:29 <tusho> sclv: JSON is a subset of YAML.
12:22:32 <hukolele> :)
12:22:36 <tusho> A non-human-friendly one, so not wanted.
12:22:42 <tusho> I could get the YAML and reserialize it as json though
12:22:42 <tusho> :DD
12:22:48 <mmorrow> @src foldl'
12:22:49 <lambdabot> foldl' f a []     = a
12:22:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:22:58 <mmorrow> @src foldl
12:22:58 <lambdabot> foldl f z []     = z
12:22:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:23:03 <sclv> on the other hand, i'd write the rest of your program first and worry about serializing the configs last.
12:23:07 <int-e> dmwit: hmm. I get a type error with "a" =~ "(a)" ... which module should I be importing instead of Text.Regex.Posix?
12:23:12 <mmorrow> @src mapAccumL
12:23:12 <lambdabot> mapAccumL _ s []        =  (s, [])
12:23:12 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
12:23:12 <lambdabot>    where (s', y ) = f s x
12:23:12 <lambdabot>          (s'',ys) = mapAccumL f s' xs
12:23:15 <tusho> sclv: I like getting a structure of how I'd like the app to be used first.
12:23:27 <dmwit> int-e: It's just too general.  Restrict it to :: [String] to see the same results as I did.
12:23:55 <int-e> dmwit: ah, that makes sense, thanks
12:24:15 <int-e> dmwit: (:: Bool, but that's just a nit)
12:24:34 <dmwit> sure
12:25:10 <int-e> dmwit: sorry. no, you're right, that gives you the results you got. I wanted bools.
12:25:20 <dmwit> yep
12:25:27 <dmwit> Return-type polymorphism FTW.
12:26:04 <ziman> what does `FTW' mean?
12:26:10 <dmwit> "for the win"
12:26:20 <dmwit> generally, "is awesome"
12:26:22 <Japsu> :t mapAccumL
12:26:23 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:26:38 <tusho> FTW = Fuck The What.
12:26:38 <tusho> Duh.
12:26:39 <tusho> ;)
12:26:43 <dcoutts_> dmwit: surely it should be "for teh win" ? :-)
12:26:52 <dmwit> =)
12:27:14 <dmwit> Stupid spell-corrector always cheques to make shore I have the write spelling.
12:27:17 <Pidgin> dcoutts: Or, 4 teh wni. ;p
12:27:22 <mmorrow> everytime i try to type t eh in xchat it corrects it w/out me noticing and my intended connotation is t3h lost!
12:27:28 <RayNbow> dcoutts_: well, "the" is also okay. "teh" is just an upgraded form ;)
12:27:33 <tusho> mmorrow: me too
12:27:34 <tusho> try this
12:27:39 <quicksilver> sclv: I think I must have read some early preprint then
12:27:39 <mmorrow> tucho: heh
12:27:41 <tusho> tehw -> press space before the w -> delete the w
12:27:46 <mmorrow> s/c/s/
12:27:48 <quicksilver> sclv: it definitely have the :+: and :*: stuff
12:27:49 <tusho> and TADA
12:27:51 <tusho> 'teh'
12:28:06 <quicksilver> tusho: I feel obliged to remind you that deriving Show and Read does most of what you ask for at zero cost.
12:28:09 <sclv> possibly the version I read was updated
12:28:13 <quicksilver> tusho: it's your call though :)
12:28:17 <tusho> quicksilver: Without, uh, the YAML part.
12:28:20 <mmorrow> tusho: so essentially cell phone txt message shenanigans
12:28:27 <chadz> hey -- what are some options for running a specific computation for say n ms, then retreiving the result?
12:28:29 <quicksilver> tusho: you asked for "simple human readble and editable"
12:28:33 <quicksilver> tusho: you didn't ask for YAML
12:28:39 <tusho> quicksilver: I don't class 'show' output as that
12:28:52 <chadz> i'm thinking a forkio/throwTo, but, not sure if tehre's something more elegant
12:29:05 <quicksilver> tusho: it's only a few characters different from YAML
12:29:17 <quicksilver> tusho: chuck in a couple of {} and "" and its' the same.
12:29:22 <tusho> quicksilver: You're thinking of JSON.
12:29:27 <tusho> YAML is an indentation-based syntax.
12:29:37 <tusho> http://yaml.org/ is a yaml document, for instance.
12:29:38 <lambdabot> Title: The Official YAML Web Site
12:30:00 <quicksilver> tusho: I am not.
12:30:01 <mmorrow> chadz: maybe a threadDelay with a killthread action?
12:30:05 <quicksilver> tusho: I know what YAML is.
12:30:13 <tusho> quicksilver: YAML does not often feature "" or {}.
12:30:13 <quicksilver> tusho: the {} are "" are from Show/Read format
12:30:22 <tusho> quicksilver: OK.
12:30:23 <tusho> Well.
12:30:26 <tusho> Still the whole indentation thing..
12:30:29 <quicksilver> tusho: Show/Read looks like yaml with a few extra {} "" and =
12:30:34 <tusho> No it doesn't.
12:30:35 <tusho> a:
12:30:36 <tusho>  - b
12:30:37 <tusho>  - c
12:30:38 <tusho>  - d
12:30:39 <chadz> mmorrow: yah, that's what i thought of first. you could probably do it with registerDelay too
12:30:47 <tusho> Is { a = ["b","c","d"] }
12:30:50 <tusho> NOTHING like show's output
12:31:46 <mmorrow> chadz: sweet, hpaste your implem (if you can) cuz i'd be interested in a working method t odo that easily
12:31:50 <quicksilver> for simple records its very similar
12:31:57 <quicksilver> if you adopt the convention of one field per line
12:31:58 <tusho> quicksilver: Where simple means trivial, yes.
12:31:59 <paolino> PrettyPrint can do some of it
12:32:01 <quicksilver> for arrays less so.
12:32:04 * quicksilver shrugs
12:32:10 <tusho> However, I'm pretty fond of, uh, nested structures.
12:32:12 <tusho> Weird, I know.
12:32:28 <mmorrow> chadz: ah yeah. i meant registerDelay:)
12:33:20 <chadz> mmorrow: heh. i'm actually just looking for the simplest method, a friend learning haskell asked, and well, I haven't messed at all with exception handling in haskell :(
12:33:28 <chadz> but, we'll see what I find.
12:34:51 <mmorrow> chadz: that seems like the simplest way to me. just read the Control.Exception haddock page (thorough) and you'll be set to jet
12:35:26 <mmorrow> thorough as in that page is thorough
12:36:36 <mmorrow> chadz: and be sure to import Prelude hiding (catch)
12:42:07 <Armored_Azrael> Does anyone know if a ghc that produces shared modules, even an unstable one, is available? I've got a custom version that does this, and I'd rather not have to go through the rigamarole of packaging it to let others try my project that uses it.
12:42:22 <tusho> mmorrow: 'Without the catch'
12:47:05 <byorgey> @seen dons
12:47:05 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 1h 8m 42s ago.
12:48:12 <byorgey> @ask dons quick question: why is data    Conferences  = Conferences (Maybe Title) [Link] ? What's the (Maybe Title) for?
12:48:12 <lambdabot> Consider it noted.
12:48:21 <mmorrow> tusho: and no strings attached (with a few exceptions)
12:50:37 <mmorrow> Armored_Azrael: that seems to me what *would* be the easiest thing to do. at least darcs diff what you've done and put *that* on the web somewhere (at point me too it :)):)
12:50:56 <mmorrow> Armored_Azrael: (or you can wait til 6.10)
12:51:08 <mmorrow> s/at/and/
12:51:45 <Armored_Azrael> mmorrow: It's fairly simple. I've just added to build.mk a flag to tell it to build with -fPIC, copied the resulting libraries to make them versioned, and then manually build and link rather than using --make
12:52:28 <Armored_Azrael> mmorrow: It's just that I need someone else to build my project, which is kind of awkward if they have to build ghc (and yhc as well due to some stuff my project does) in order to do this instead of just installing a package. I'll be packaging it up then.
12:52:48 <mmorrow> Armored_Azrael: sweet. darcs diff that sheeyit
12:53:25 <Armored_Azrael> This is against 6.8 line btw, b/c the head wouldn't build without significant refuckulation.
12:53:26 <mmorrow> Armored_Azrael: (oh, i was presupposing that the user would be building from src)
12:54:27 <Armored_Azrael> mmorrow: No. The user is a prof who's never heard of haskell and will be grading my typed bytecode virtual machine based sql access that is set to run inside postres :P
12:54:39 <Armored_Azrael> GhcLibHcOpts = -fPIC
12:54:39 <Armored_Azrael> GhcHcOpts = -fPIC
12:54:44 <Armored_Azrael> Is what you should add to your mk/build.mk
12:54:44 <mmorrow> Armored_Azrael: refuckulation, heh.
12:55:12 <schoenfinkel> can someone help me install the materials for the "Haskell School of Expression" on a Mac?  I cant seem to install GLFW 0.3 without trouble.
12:55:13 <Armored_Azrael> Then, after building, you'll need to copy each of your libraries to also have a copy that includes a version string for ghc, as the -shared linking requires this.
12:55:31 <sclv> sounds like a pretty fancy ol project.
12:55:40 <Armored_Azrael> Finally, you'll occassionally get an error about missing symbols. In that case, objdump all the haskell libraries you have installed, and tell that to link.
12:56:01 <Armored_Azrael> sclv: Took quite a while :P and while it will perform correctly on correct input, it still has very bad error tolerance.
12:56:59 <mmorrow> Armored_Azrael: haha. hey prof, yeah so i emailed you a 60M tarball..ghc...yeah just changed a few things.. no your ghc won't work....it'll build *really* qicklike, don't worry i put in a README!....
12:57:20 <Armored_Azrael> mmorrow: Yeah. So instead I get to package up this modified ghc and yhc
12:57:30 <Armored_Azrael> well, yhc isn't modified
12:57:40 <Armored_Azrael> but yhc is not particularly fun to build and not available in most distros
12:58:28 <mmorrow> do you at least have any guarantee of what arch it'll be run on when evaluated (evaluated in the sense of an exam)?
12:58:50 <Armored_Azrael> I know it'll be x86 or x86_64
12:59:07 <Armored_Azrael> And I've already changed my build so that everything's 32 bit even on a 64 bit machine
12:59:27 <mmorrow> hmm, i guess to be safe i'd package it for both...good luck
12:59:30 <Armored_Azrael> Worst case scenario, I'll give him an account on my box in a chroot to mess around with it :P
12:59:45 <mmorrow> you could always put it in a vm...
13:00:30 <mmorrow> i guess vmware is the only real option (please correct me if i'm wrong because i want to be) here
13:01:01 <Armored_Azrael> Putting it in a VM would be silly
13:01:13 <Armored_Azrael> And vmware isn't the only option, qemu and others are available.
13:01:17 <mmorrow> yeah, all other issues aside
13:01:34 <sheyll> hi
13:01:48 <pejo> mmorrow, qemu, parallells, xen, kvm, virtualbox, and probably others. But I agree with Armored_Azrael about VM being overkill.
13:01:53 <sheyll> I have a question about arrows...
13:01:59 <mmorrow> but wrt a nice little package with a "viewer" that can be downloaded of the internets and run on any windows first try??
13:02:02 <Armored_Azrael> Because then I'd have a computer, with an OS, then a VM, then a OS, then a server, then a different kind of VM, then a pipe, then a third kind of VM, then the user's code
13:02:05 <Armored_Azrael> which would be retarded
13:02:19 <mmorrow> that would be l33t!!@
13:02:30 <Armored_Azrael> mmorrow: This won't run on windows as is. It is a loadable module for postgres 8.3
13:02:42 <mmorrow> but the vm could be running whjatever you want
13:02:44 <BMeph> sheyll: We're like Radio Shack (R) here - "You've got questions,..." ;)
13:03:12 <Armored_Azrael> mmorrow: The group of people who might be interested in this aren't running windows. I can gaurantee it.
13:03:38 <sheyll> why is "arr f = K (\b -> return (f b))" in  the instance definition of the Kleisli arrow
13:03:41 <sheyll> ?
13:04:04 <sheyll> f should return a monad already
13:04:07 <mmorrow> i would assume, but i mentioned that wrt vmware being the only option to package such a thing and have someone be *able* to do so
13:04:21 <sheyll> why the extra "return" ?
13:04:29 <mmorrow> (yes, i agree the vm would be silly)
13:04:56 <And[y]> i have the predicates sum :: [Int] -> Int, divisors :: Int -> [Int] and powerset :: [a] -> [[a]] ... now i want to write a predicate to: create the list of divisors of a given number n, create the powerset of this list and then check all the lists in the powerset, whether the sum of one is equal to the nubmer n, itself
13:04:57 <mnislaih> what is a simple algorithm to compute the cycles (not the SCCs) of a graph ?
13:05:09 <BMeph> sheyll: No, f is a regular function, otherwise arr f is much more complicated than intended. :)
13:05:21 <vixey> mnislaih: How do you represent your graph?
13:05:32 <sheyll> BMeph that violates the type of arr?
13:05:35 <mnislaih> I am using the representation in the fgl
13:05:47 <vixey> I don't know what that is
13:05:57 <Botje> fgl == Data.Graph
13:06:01 <Botje> which is pretty nice
13:06:03 <And[y]> testnum :: Int -> Bool
13:06:03 <And[y]> testnum = sum x == n
13:06:04 <And[y]> 	where (x:list) = (powerset ( divisors n ) )
13:06:33 <BMeph> sheyll: The h*ll it does, that's the point of arr. :)
13:06:42 <vixey> And[y]: Weird
13:06:43 <And[y]> but this allways returns FALSE ... but i think i understand why: it seems like my code checks the first item of the powerset list of the divisors :/
13:06:56 <mnislaih> vixey: I am not forced to use this representation, so if there is an algorithm that works for adjacency matrixes or lists that's fine
13:06:57 <And[y]> hah, vixey: nice to see you in here, too :)
13:07:04 <mmorrow> :t reachable
13:07:06 <lambdabot> Graph -> Vertex -> [Vertex]
13:07:18 <vixey> And[y]:  why do you have :list there
13:07:21 <ziman> :t unreachable
13:07:23 <lambdabot> Not in scope: `unreachable'
13:07:30 <mmorrow> see if a vertex is reachable from itself (hopefully they won't give you the trivial answer)
13:07:41 <And[y]> if i let out :list, it says something about a type missmatch
13:07:57 <mnislaih> vixey: the representation in fgl is 'inductive', it is a zipper-like representation for the nodes of the graph
13:08:06 <ski_> @type Control.Arrow.arr
13:08:08 <vixey> And[y]: but why is it there
13:08:08 <lambdabot> forall b c (a :: * -> * -> *). (Control.Arrow.Arrow a) => (b -> c) -> a b c
13:08:51 <mmorrow> mislaih: oh. *every* cycle. probably want something else
13:08:58 <And[y]> well, i thought it would be kinda equal to prolog, where i can use [head|tail]
13:09:12 <mnislaih> mmorrow: that would work only for loops
13:09:14 <And[y]> so in general: i wanted to extract one list out of the list of lists :D
13:09:16 <And[y]> testnum :: Int -> Bool
13:09:16 <And[y]> testnum n = sum x == n
13:09:16 <And[y]> 	where (x:list) = (powerset ( divisors n ) )
13:09:21 <vixey> then write
13:09:29 <vixey>  where x = head . powerset . divisors $ n
13:09:36 <vixey> (which is the same as what you have)
13:09:37 <And[y]> this is the "corrected" version so far ... the old was missing n = ... ;/
13:09:38 <mmorrow> mislaih: oh, i'm confused then on the def of a cycle
13:10:05 <sclv> oh ffs. we've got hundreds of libs, and nobody's bothered to wrap up a function to call sendmail !?
13:10:13 <dmwit> Probably also equivalent to x = divisors n
13:10:24 * CosmicRay returns
13:10:27 <sclv> yes, I know its trivial. (although multipart slightly less so).
13:10:31 <dmwit> (Probably head . powerset === id :: [a] -> [a].)
13:10:36 <mmorrow> mislaih: (if you used the reachable method, you'd have to try that for every vert (which is why that would be a bad way to find all cycles)
13:10:36 <mnislaih> mmorrow: a cycle is a closed path in a graph
13:10:37 <sheyll> BMeph: so f has not the type a -> m b, but rather a -> b??
13:10:40 <vixey> mnslaih: I don't know if this helps.. http://rafb.net/p/NAbjnN19.txt
13:10:54 <sclv> but seriously, of all the basic frcryingoutloudlibs you'd think we'd have...
13:11:19 <mmorrow> mislaih: hmm. then i'm confused on the def of a loop (i don't see how they're different)
13:11:26 <sclv> I mean, we have a esmtp server for crying out loud.
13:11:30 <And[y]> okay, so when i use this, it gives me the same result as my own code ... as you told me ofc :D
13:11:33 <mnislaih> mmorrow: a loop is a cycle of length 1 :)
13:11:36 <dmwit> sclv: Well, there's WASH.Mail.
13:11:42 <edwardk> sclv: then write one =)
13:11:49 <mmorrow> mislaih: ah.
13:11:51 <vixey> And[y]: can you think of a better name than 'testnum'?
13:11:59 <vixey> And[y]: i.e. describe what the function is
13:12:09 <And[y]> hmm, well its like pseudo complete numbers
13:12:12 <BMeph> :t arr
13:12:15 <lambdabot> Not in scope: `arr'
13:12:20 <mmorrow> mislaih: that's "the trivial answer" i refered to above
13:12:23 <sclv> in unrelated news, anyone have a nice hook into sendmail they've written laying around in a repo?
13:12:26 <BMeph> :t Control.Arr.pure
13:12:28 <lambdabot> Couldn't find qualified module.
13:12:50 <sheyll> arr f = Kleisli (return . f)
13:12:59 <sheyll> i.e.
13:13:33 <tusho> arrrrrrrrrrrrrrr!
13:13:36 <tusho> @arr
13:13:36 <lambdabot> Har de har har!
13:13:42 <mnislaih> mmorrow: sorry if I confused you. Your original idea would work, on second thought
13:14:05 <mnislaih> probably not the most efficient thing to do though
13:14:16 <sheyll> :t Control.Arrow.pure
13:14:18 <lambdabot> forall b c (a :: * -> * -> *). (Control.Arrow.Arrow a) => (b -> c) -> a b c
13:14:47 <mmorrow> mislaih: actually that's what i was thinking of, but i was merging the two cases of no loops and at least one self loop together in my head, so in that sense there is *the* trivial answer, then possibly at least one *kinda* trivial anwsers
13:14:51 <And[y]> all the predicate returns so far is false ... i guess its cause its checking only the first list of the powerset list of the divisors of n which is the empty list, ofc
13:14:54 <BMeph> Duh, yeah - there ya go. Arr takes a function, and makes it into an arrow.
13:15:11 <BMeph> Of course, since functions are an instance of arrow,... ;)
13:15:32 <ski_> @src (->) arr
13:15:32 <lambdabot> arr f = f
13:15:45 <sheyll> BMeph: I just dont understand what in case of the kleisli ... uhh.. class?  b and c are
13:16:25 <sheyll> um I meant a and b
13:16:41 <sheyll> I was just reading the paper on arrows
13:17:03 <ski_> arr :: Monad m => (a -> b) -> Kleisli m a b
13:17:03 <BMeph> sheyll: b and c are "simple" types, of which a Kleisli takes one, and gives back a monad in the other.
13:17:18 <mmorrow> mislaih: (so a vanilla reachable function would almost certainly not be able to do what you need)
13:17:58 <sheyll> I thought that in arr f  f would be f :: a -> m b ... then the return would be useless, right?
13:18:26 <sheyll> BMeph: thank you for your help :)
13:18:54 <EvilTerran> ?type arr
13:18:56 <lambdabot> Not in scope: `arr'
13:19:29 <ski_> sheyll : if it was, then it would, but it isn't, so it wouldn't
13:19:43 <sheyll> hehe
13:20:50 <sclv> oh, hey, WASH-Mail is pretty nice!
13:20:54 <sheyll> but that also means that I cannot reuse monadic functions to work with arrow combinators
13:21:02 <chadz> alright, i'm a little stumped. to actually compute as much work as possible in a certain timeframe is harder than timeing out in a certain timeframe.
13:21:05 <sclv> somebody (else) should really split it out into its own package http://www.informatik.uni-freiburg.de/~thiemann/WASH/doc/WASH-Mail-MIME.html#t%3AMail
13:21:07 <lambdabot> http://tinyurl.com/6xdvv3
13:23:03 <sclv> ?tell gwern, Two WASH components (HTML and MAIL) look like they stand alone quite nicely. Somebody (hint) may want to split them out and package them up
13:23:03 <lambdabot> Consider it noted.
13:23:54 <dmwit> I wonder if he'll get something addressed to gwern,?
13:24:04 <sclv> oh good point
13:24:11 <sclv> ?tell gwern Two WASH components (HTML and MAIL) look like they stand alone quite nicely. Somebody (hint) may want to split them out and package them up
13:24:11 <lambdabot> Consider it noted.
13:31:02 <dabd> hi
13:31:09 <chadz> how do you force evaluation?
13:31:18 <chadz> seq?
13:31:19 <tusho> chadz: don't
13:31:23 <tusho> why?
13:31:37 <chadz> i'm writing an example that computes as much work as possible in n ms
13:31:42 <dabd> is there a more concise way to define map in terms of unfold than this: map f = unfold (null) (\ xs -> f (head xs)) (tail)
13:31:46 <tusho> chadz: and?
13:31:58 <tusho> dabd: (null) = null
13:32:02 <tusho> (tail) = tail
13:32:05 <mmorrow> brainfuck interp in js (for those that haven't seen it (i have not)): http://brainfuck.progopedia.org/
13:32:06 <lambdabot> Title: Kit's JavaScript Brainfuck Interpreter v0.01
13:32:07 <tusho> (\xs -> f (head xs)) = f . head
13:32:14 <tusho> map f = unfold null (f . head) tail
13:32:17 <vixey> :t unfold null (?f . head) tail
13:32:33 <lambdabot> thread killed
13:32:35 <chadz> tusho: inheritly, i have to do the computation and not just return it.
13:32:43 <dabd> tusho: thanks
13:33:26 <dmwit> chadz: Use Control.Parallel.Strategies for evaluation strategies.
13:35:19 <quicksilver> tusho: it sounds like I'm trying to talk you out of it and really I'm not, but a pretty printed Show representation can show nesting quite nicely. Foo { \n  bar = Bar { \n    baz = 5 \n } \n }
13:36:11 <And[y]> vixey: got any idea how i could make the final step to iterate through the whole list? :>
13:37:00 <vixey> foldr or something I don't know what you mean
13:37:07 <FordCortina> (sry this question is vague) how do you reuse modules in haskell? I wanted to make a module for bipartite graphs out of the fgl graph type. i.e. I want to retrict it so that edges can only be form between distinct *types* of vertices.
13:37:44 <And[y]> testnum :: Int -> Bool
13:37:44 <And[y]> testnum n = sum x == n
13:37:44 <And[y]> 	where x = head . powerset . divisor $ n
13:38:03 <mmorrow> http://www.joeganley.com/code/jslisp.html
13:38:03 <lambdabot> Title: Joe Ganley's Lisp in JavaScript
13:38:13 <And[y]> thats what i got. and what it does seems to be: check the first list of the powerset of the divisors
13:38:17 <dmwit> FordCortina: Not sure what you mean.  Are you asking how to import a module...?
13:38:31 <And[y]> but ofc it should check all lists :)
13:38:44 <dmwit> :t all
13:38:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:38:48 <ziman> hm, what's the point of (head . powerset) ?
13:38:57 <dmwit> And[y]: Like that one?
13:39:05 <vixey> :t every
13:39:08 <vixey> :t all
13:39:16 <Gilly> quicksilver: would you have any ideas for the next problem i've been pondering about in my mud - i'm using Data.Binary to serialize the mud state to disk between shutdowns/restarts. Now when I'm developing the mud need may arise to change the data types, which doesn't work very nicely...
13:39:19 <lambdabot> Not in scope: `every'
13:39:24 <lambdabot> thread killed
13:39:35 <dmwit> Or maybe...
13:39:36 <dmwit> :t any
13:39:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:40:19 <dmwit> testNum n = any ((== n) . sum) . powerset . divisor $ n -- ?
13:40:25 <Gilly> dmwit here pointed me to an interesting paper which was about a technique that allowed me to add constructors instead of fields in constructors but i'm not sure if that's a good idea
13:40:32 <quicksilver> Gilly: yup. Data.Binary does not solve versioning problems.
13:40:34 <And[y]> possibly :)
13:40:41 <And[y]> let me check that
13:40:43 <quicksilver> Gilly: I don't think there is a "magic" solution.
13:40:57 <quicksilver> Gilly: I think you need to add version numbers to everything
13:41:04 <quicksilver> and leave code around to load old versions as well as new.
13:41:50 <And[y]> exactly like this, thank you all :)
13:41:54 <mmorrow> evalquote http://farm1.static.flickr.com/86/212588975_5fa840ddd2_o.png
13:42:01 <Gilly> hmm, so the first field in data.binary would be a version number and then in the code i'd just have an "if then else -hell" to load appropriate stuff and add appropriate defaults when it's not available?
13:42:39 <quicksilver> yes that's the general idea
13:42:52 <quicksilver> you can keep old versions of the data structure around as types if you like
13:43:03 <vixey> mmorrow: that's nice is that written by mccarthy?
13:43:11 <quicksilver> data Weapon = .... -- current version
13:43:27 <quicksilver> data Weapon0011 = ... -- (version 11 of Weapon for old savefiles)
13:43:33 <mmorrow> vixey: the original context: http://weblog.raganwald.com/2005/03/page-thirteen.html
13:43:36 <lambdabot> Title: Page Thirteen
13:43:37 <dmwit> quicksilver: Nasty.
13:43:43 <quicksilver> and then you have an 'upgrade' function :: Weapon0011 -> Weapon.
13:43:54 <quicksilver> dmwit: versioning is a nasty problem, there is no magic bullet.
13:43:55 <Gilly> i see, but then the version number would need to go along the save files too
13:43:57 <mmorrow> it says page 13 of the Lisp 1.5 manual
13:43:58 <vixey> it seems like good solution to me
13:44:21 <quicksilver> dmwit: if you are able to regulate your incompatible changes (only add new fields, never change the meaning of old fields)
13:44:27 <quicksilver> then you can do something rather simpler
13:44:33 <quicksilver> but IME that's not necessarily realistic.
13:44:44 <dmwit> Gilly: You wouldn't want something like "data Weapon = ...", "data WeaponMonoid = ...", defaultWeapon :: WeaponMonoid, load = monoidToWeapon (loadFromFile `mappend` defaultWeapon)
13:44:47 <dmwit> ?
13:45:04 <dmwit> quicksilver: Ah, good point.
13:45:24 <Gilly> yea quicksilver has a point there, more drastic changes than just adding fields may occur
13:45:25 <dmwit> Yeah, my scheme wouldn't work in case fields changed meaning or whatever.
13:46:11 <quicksilver> I have confronted these problems when designing a database file format but never actually implemented a solution.
13:46:22 <quicksilver> there might be interesting parts of the design space I didn't consider
13:46:33 <quicksilver> but if your constraint is to always be able to load every old version
13:46:40 <quicksilver> I'm not sure you'll find anything really simple :)
13:46:53 <Gilly> quicksilver: now let's suppose i had weapon and weapon0011, where do i know from the savefile i'm loading using decodeFile which version it's in?
13:47:10 <dmwit> FWIW, I worked on a (fairly sophisticated) bug tracker last summer, and its scheme is essentially the monoid of partial knowledge one outlined above.
13:47:31 <dmwit> Gilly: Stick a version number as the first line in the save file?
13:48:26 <Gilly> well something like that maybe, but it gets dirty if the weapons are saved along with players where players are in version x and weapons in version y and the current versions respectively are z and v
13:48:48 <dmwit> I would recommend rewriting in your newest version on each save.
13:49:25 <Gilly> well the point was that the weapon structure inside the player may change and thus i'd need many lines in the save file to tell the versions of all of the structures
13:51:03 <Gilly> but could i easily exploit this thing by introducing a version number as the first field in the data structure and then in the get function for that structure just change the loading according to the first field?
13:51:04 <dons> ?yow
13:51:05 <lambdabot> Will it improve my CASH FLOW?
13:51:14 <dmwit> And I'm saying that if you're saving the weapon structure in a different version number than the person, then you're doing it wrong.
13:51:25 <dmwit> Though I may still be misunderstanding.
13:51:40 <Gilly> ah, yea, you think of one global version, i think of different versions between different structures
13:52:28 <dons> anyone have any thoughts on what "idiomatic haskell" means?
13:52:29 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:52:36 <dons> we see it often said that "idiomatic haskell is slow"
13:52:52 <mmorrow> does js have goto?
13:52:54 <dons> i've a theory this means you have to use lazy lists for all data and control flow
13:52:55 <byorgey> dons: that's a spelling mistake.  it's supposed to say 'idiotic haskell is slow'
13:53:15 <dons> for example, idiomatic ocaml can use unboxed mutable arrays
13:53:17 <sclv> idiomatic haskell is foldl
13:53:26 <dons> while idiomatic haskell can't even use bang patterns
13:53:33 <mmorrow> @src foldl'
13:53:33 <lambdabot> foldl' f a []     = a
13:53:33 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:53:36 <dons> so we've let our enemies define us
13:53:44 <mmorrow> well put
13:54:55 <geezusfreeek> i think the haskell community may have, at least at first, mistakenly given outsiders reason to believe that haskell is magical, only to disappoint them
13:55:08 <dons> yes.
13:55:12 <quicksilver> Gilly: I was imagining versioning every single structure and substructure
13:55:25 <Gilly> quicksilver: same
13:55:25 <quicksilver> Gilly: so the weapon would be ( pseudocode)
13:55:32 <mmorrow> oh joy, js has goto
13:55:54 <kaol> does \f x -> f x have a name for it? is it in some standard library, even?
13:56:05 <quicksilver> v <- getVersion; if v == currentV then {- use standard Binary instance -} else {- use binary instance for WeaponXYZ and then 'upgrade' -}
13:56:06 <dmwit> :t ($)
13:56:08 <lambdabot> forall a b. (a -> b) -> a -> b
13:56:09 <dmwit> kaol: ^^
13:56:15 <Peaker> dons, but all the tutorials/examples show list manipulations.. I get the impression most of the Prelude stuff deals with lists, while very little of other data structures is exposed to Haskell newcoemrs
13:56:29 <quicksilver> Gilly: you'd hide all the 'old version' stuff off in a separate module so it didn't get in the way too muc.
13:56:30 <kaol> ooh, I knew a time would come when I'd use $ in a higher order function :-)
13:56:31 <dmwit> kaol: It's also named "id" in a less type-restricted way.
13:56:39 <dons> this is just wrong headed then. unlifted ST arrays are just as idiomatic.
13:56:39 <Peaker> as a Haskell newbie, I did/do get the impression lazy lists are the "main" data structure
13:56:48 <dons> bang patterns are *certainly* idiomatic.
13:56:49 <quicksilver> Gilly: each time you did a new version you'd just rename the old version and write the "upgrade" function.
13:57:22 <sclv> Hmm.. maybe a tutorial that explained lazy lists make sense as a control structure...
13:57:34 <quicksilver> lazy lists = for loops. End of tutorial.
13:57:38 <quicksilver> shortest tutorial eva!
13:57:39 <kscaldef> I think lots of people view bang patterns / strictness annotations as something you do to hack around the shortcomings of the default execution model
13:57:54 <kscaldef> therefore, from their point of view, not idiomatic
13:58:16 <geezusfreeek> i think a lot of it is that we tout laziness without really pointing out that it's actually just a default
13:59:28 <ddarius> kscaldef: Both eager and lazy evaluation have shortcomings and supporting both is -crucial-.
13:59:39 <mmorrow> i think they're confusing having a way to achieve lazyness *or* strictness with using strictness since lazyness is "broken" or "sucky"
13:59:57 <Gilly> quicksilver: i still didn't see your take on where the version would be stored (ie. where getVersion gets the data from)
14:00:22 <sclv> I think reddit-trolls do have a point to the extent that shootout entries use any form of FFI, however.
14:00:39 <geezusfreeek> besides doing things which have nicer syntactic alternatives, what is _not_ idiomatic haskell?
14:01:20 <dmwit> Gilly: Make your file save pairs (Version, ThingYou'reSaving)?
14:01:21 <ddarius> On a recent hpaste, someone made an RLE encoder.  The last version I posted made significant use of both strictness and lazines.
14:01:35 <atp> writing idiomatic haskell means only writing simple haskell that is consistent with what a newcomer to the language thinks haskell is all about after reading a ten minute tutorial on the subject
14:01:52 <Peaker> I read that "you should let the compiler figure out which parts to make strict", and generally avoid using strictness annotations
14:02:00 <atp> if it does anything that seems low level, then it is not idiomatic, because that's cheating
14:02:02 <sclv> i.e. acceptably idiomatic to me is I can think about strictness and etc, and even inlining and pragmas, but don't have to think about memory allocation as such.
14:02:03 <dons> sclv: yeah, let's get rid of the ffi stuff
14:02:12 <dons> STUArrays can replace all FFI usees
14:02:16 <ddarius> kscaldef: Presumably those people also think that iterators/generators are hacks to get around the shortcomings of the default execution model in languages that have them.
14:02:16 <dons> which are from an older time
14:02:18 <quicksilver> Gilly: as a header byte, basically
14:02:21 <quicksilver> Gilly: welll, header word
14:02:30 <quicksilver> Gilly: before the bit for Data.Binary to read.
14:02:44 <Gilly> hm, yea, something like that
14:02:58 <ddarius> Peaker: The compiler isn't going to change semantics.  So, sometimes the function you want is stricter than the code you've written.
14:03:19 <geezusfreeek> are optimizations that harm the composability and/or genericity of a function idiomatic?
14:03:20 <dons> kscaldef: I'd argue bang patterns are in the same class as 'inline' or macros in C.
14:03:21 <kscaldef> ddarius: You've have to ask them yourself, I suppose.
14:03:26 <Peaker> ddarius, Iterators/generators make affect the side effects that will run - so they affect semantics, whereas strictness annotations should be just optimization hints, if I understand correctly
14:03:45 <geezusfreeek> *or data type
14:03:52 <dons> the C code on the shootout is full of little optimisation hints and tweaks, particularly the use of macros to fake inlining
14:03:54 <Gilly> any idea of this safecopy library in hackage? "Binary serialization with version control."
14:03:58 <Peaker> dons, "inline" is definitely not considered "idiomatic C"
14:04:08 <kscaldef> dons: that seem fair.  Although, lots of people dislike the use of those features in C
14:04:08 <mmorrow> C without macros is like a pipe without crack
14:04:24 <vixey> haha
14:04:30 <Peaker> C uses macros to allow for compile-time values.  A function cannot be used as the size of a global array
14:04:34 <geezusfreeek> Peaker: i disagree. i use inline in C all the time without feeling evil
14:04:48 <Peaker> geezusfreeek, after profiling?
14:04:58 <geezusfreeek> well, maybe not "all the time"
14:05:03 <sclv> ?remember mmorrow C without macros is like a pipe without crack.
14:05:04 <lambdabot> Good to know.
14:05:15 <Peaker> I think we should separate optimization hints from the semantic description of the program
14:05:15 <kscaldef> geezusfreeek: using inline in public interfaces is borderline evil IMO
14:05:18 <geezusfreeek> sometimes before, but i understand that is normally a bad idea
14:06:27 <dons> almost all the code on the shootout is unidiomatic, in all languages. except for maybe ruby
14:06:31 <geezusfreeek> kscaldef: do you see rewrite rules as equivalent to that?
14:06:39 <dons> its all tricks and treats to get better performance
14:07:01 <geezusfreeek> dons: obviously we should start an "idiomatic" shootout
14:07:08 <byorgey> dons: did you get my @ask?
14:07:10 <dons> well, we can fix the truly unidioamtic haskell
14:07:11 <Peaker> dons, nvidia's drivers check for benchmark executable names as to eliminate sanity checks and gain more performance :)
14:07:14 <dons> fannkuch for one.
14:07:25 <dons> and FFI.Ptr can be replaced with ST arrays
14:07:38 <dons> that's about it, the use of Foreign.Array instead of ST
14:07:48 <dons> otherwise, I can't think of much on the shootout that isn't fine as it is.
14:07:52 <kscaldef> geezusfreeek: I'm not really sure.  The problem with inline in public interfaces is that it forces users to recompile if you make an implementation change
14:08:23 <dons> byorgey: Maybe Title is usually Nothing
14:08:36 <byorgey> dons: I see that, but what is it for?
14:08:54 <dons> oh, an optional title for the conference?
14:09:16 <byorgey> there can only be one conference at once?
14:09:17 <geezusfreeek> kscaldef: i don't see that as so bad, really
14:09:36 <geezusfreeek> oh wait, i see what you are getting at
14:09:43 <geezusfreeek> you wouldn't want to do that for a share library
14:09:48 <kscaldef> exactly
14:09:55 <byorgey> dons: the Conferences section consists of a Maybe Title, followed by a list of Links
14:10:10 <byorgey> I guess I could just read the code =)
14:10:15 <geezusfreeek> okay, but i would find that to be just one case where inline is a bad idea then
14:10:50 <Peaker> geezusfreeek, ksandstr Given the nature of gcc compilation and linkage, can inline work at all across compilation units? Or do you mean placing the code in the header file (static inline)?
14:10:58 <dons> byorgey: yeah, its a bit ad hoc
14:11:17 <byorgey> dons: ok, no problem.  After I figure out what I'm doing I'll probably end up tweaking stuff anyway. =)
14:11:21 <geezusfreeek> Peaker: i think ksandstr is talking about static inline
14:11:34 <dons> byorgey: yeah, definitely
14:12:03 <byorgey> first, I'm going to write a tool that will get the Planet Haskell RSS feed and just ask me which ones to include =)
14:12:11 <kscaldef> dons: I think that statement ("almost all the code on the shootout is unidiomatic, in all languages") probably goes a long way to explaining the criticisms of the haskell entries.  It's all about familiarity
14:12:16 <Peaker> optimization hints are yet another reason to disconnect the code's presentation (syntax) from its backend storage, so that you can store elaborate metadata about the code
14:12:59 <dons> kscaldef: yes. people are comfortable with the use of macros to fake inlining in C, or the use of register variables, or bitwise ops to simulate a Bool type.
14:13:01 <kscaldef> I just scanned a handful of the perl entries and other than one or two spots, wouldn't call it unidiomatic.  But, they do use advanced features
14:13:51 <geezusfreeek> there is nothing wrong with advanced features
14:14:08 <geezusfreeek> i wouldn't want to judge a language based on how novices use it
14:14:17 <Peaker> dons, I rarely see "register" in real C code..
14:14:33 <Adamant> I have
14:15:07 <Adamant> granted it's not extremely common but in high performance code it's not exactly rare either
14:15:31 <geezusfreeek> i have not used register much, but i again have no problem with it. c relies on understanding the runtime, and controlling the runtime is a part of using it
14:15:55 <Peaker> wouldn't "register" be a micro optimization that's rather easy for the compiler to get right, and very difficult for the C programmer to get right?  The way the instructions/machine code is laid out is significant in how you choose your registers
14:16:32 <geezusfreeek> i would argue that c was not designed with crazy compiler optimizations in mind. rather, it was designed to work similarly to how the hardware works
14:16:54 <Peaker> LCD of common von neumann machines, it seems
14:16:59 <dcoutts> @seen thetallguy
14:16:59 <lambdabot> thetallguy is in #haskell. I last heard thetallguy speak 3h 27m 33s ago.
14:17:01 <geezusfreeek> not that it does such a great job of that either
14:17:31 <quicksilver> once you use register in an interesting way you are coding for a particular arch
14:17:34 <quicksilver> not the language C
14:17:37 <Peaker> my pet peeve with C is that ptr's "*" is prefix rather than postfix (which causes precedence problems with arrays[] and functions())
14:17:44 <quicksilver> as a portable language
14:18:01 <quicksilver> otherwise it's no more than a hint for a bad compiler :)
14:18:03 <geezusfreeek> i never considered C to be all that portable anyway
14:18:03 <Peaker> which is the root of the common misunderstanding of function pointer syntax
14:18:29 <geezusfreeek> most cross-platform c code is littered with preprocessor macros for different architectures
14:18:49 <Peaker> geezusfreeek, or it can use good abstraction libraries
14:19:06 <BMeph> geezusfreeek: But C is Very portable - it runs on almost any PDP-11 around. ;p
14:20:51 <atp> one feature of C that makes it rather useful for systems dev though is the ability to control when heap allocation occurs
14:21:13 <atp> it would be nice if there were some way to make GHC complain if some code requires, in its estimation, use of the garbage collector
14:21:27 <atp> that would make writing operating systems in haskell easier
14:21:42 <geezusfreeek> atp: regions?
14:21:58 <atp> regions?
14:22:19 <geezusfreeek> as in region inference
14:22:21 <atp> what i'd like to do is write a garbage collector for an environment written in haskell in haskell :)
14:22:22 <Peaker> atp, how would you use that feature?
14:22:58 <geezusfreeek> it's a loose fit for what you said, but it's the closest thing i can think o
14:23:00 <igel> hi all
14:23:07 <atp> geezusfreeek: i guess id don't know much about it...
14:23:12 <igel> can someone give me a hint with the Ix class?
14:23:22 <Peaker> atp, why not have a global GC as part of the platform/OS and not worry about it? :)
14:23:29 <atp> Peaker: that's what i want
14:23:33 <atp> Peaker: but i want to write it in haskell
14:23:34 <igel> i'm implementing a random-access list
14:23:54 <igel> and i'd like to use an instance of Ix as index
14:23:59 <geezusfreeek> atp: JHC has no garbage collector. it uses region inference to statically determine when to allocate and free memory. it is still buggy, and it is not as fast as it could be yet
14:24:01 <atp> Peaker: and the GHC RTS as stands requires (s)brk() or similar which is an OS-specific thing
14:24:02 <igel> but i do not have a fixed length
14:24:12 <igel> so i can't save an interval (i, i)
14:24:26 <Peaker> atp, you are worried of recursive GC'ing if the GC requires GC?
14:24:39 <roconnor> ski_: should be (const (const []))
14:24:44 <igel> i rather have a starting index (Ix i) and a length (Int)
14:24:56 <atp> geezusfreeek: well, i don't want to remove the GC... i just want to be able to write Haskell that works before the GC comes on-line
14:24:57 <igel> is there a nice way to use Ix instead of fixed Ints?
14:25:08 <atp> Peaker: that's one concern :)
14:25:28 <Peaker> atp, I am not sure I see a problem with having the GC operate on its own allocations
14:26:08 <mmorrow> atp: write the program that generates the garbage collector in haskell.
14:26:20 <dons> anyone want to solve this in Haskell? http://liveatthewitchtrials.blogspot.com/2008/06/gardners-constant.html
14:26:21 <lambdabot> Title: liveatthewitchtrials: Gardner's constant, http://tinyurl.com/6fsv5v
14:26:28 <atp> Peaker: there isn't a problem, assuming it's smart about the allocations, but that requires finer-grained control than ghc currently (easily) provides
14:27:06 <atp> i mean, the papers on the House OS talk about managing memory monadically with their hardware monad H
14:27:10 <mmorrow> atp: (it'd be all the better if the generated program happened to also be haskell)
14:27:11 <atp> which is pretty neat
14:27:11 <vixey> > exp (pi * sqrt 163) :: CReal
14:27:21 <hpaste>  dons pasted "gardener's constant, close" at http://hpaste.org/8244
14:27:27 <lambdabot>  thread killed
14:27:36 <atp> mmorrow: i think it would be nice if i could just write it in haskell once...
14:27:57 <vixey> dons: huh....
14:28:07 <vixey> dons: I think CReal gives the right answer
14:28:14 <dons> > exp (pi * sqrt 163) :: CReal
14:28:22 <mmorrow> atp: that would be (unqualified) awesome. but it would be chiselled in stone.
14:28:30 <lambdabot>  thread killed
14:28:32 <tusho> > take 10 $ show $ exp (pi * sqrt 163) :: CReal
14:28:34 <lambdabot>  Couldn't match expected type `CReal' against inferred type `[Char]'
14:28:38 <tusho> > take 10 $ show $ (exp (pi * sqrt 163) :: CReal)
14:28:45 <lambdabot>  "2625374126"
14:28:49 <dmwit> ?hoogle CReal -> String
14:28:55 <tusho> > take 40 $ show $ (exp (pi * sqrt 163) :: CReal)
14:28:56 <lambdabot>  "262537412640768743.999999999999250072597"
14:28:59 <quicksilver> when did CReal get imported into LB, that's cool.
14:29:00 <lambdabot> No matches, try a more general search
14:29:00 <dons> 262537412640768743.9999999999992500725971981856888793538563
14:29:02 <dons> so not quite.
14:29:12 <vixey> dons: Do you have a proof that the number is an integer?
14:29:21 <atp> it's not an integer
14:29:22 <dons> we're looking at 262,537,412,640,768,744, according to the blog.
14:29:25 <vixey> I am guessing this is one of those joke questions
14:29:31 <dons> yeah, perhaps
14:29:41 <dmwit> What blog?
14:29:48 <dons> http://liveatthewitchtrials.blogspot.com/2008/06/gardners-constant.html
14:29:49 <lambdabot> Title: liveatthewitchtrials: Gardner's constant, http://tinyurl.com/6fsv5v
14:29:57 <tusho> it's a joke
14:29:57 <Peaker> What's CReal?
14:29:59 <tusho> http://en.wikipedia.org/wiki/Ramanujan's_constant
14:30:00 <tusho> his last link
14:30:00 <atp> this is a classic "your floating point implementation is broken if..." questions
14:30:02 <tusho> it's not an integer
14:30:07 <dons> atp, hehe
14:30:08 <vixey> dons: The result was published on April 1
14:30:09 <tusho> it's very close to one
14:30:12 <atp> it's supposed to have you running around in circles forever
14:30:12 <tusho> So ha.
14:30:14 <dmwit> dons: The first sentence says it is transcendental.
14:30:17 <vixey> by Gardner
14:30:21 <dons> :)
14:30:31 <tusho> We are fools.
14:30:41 <quicksilver> it is indeed a joke
14:30:42 <roconnor> > exp (pi*sqrt(163)) :: CReal
14:30:43 <dons> well, i was interested in why he had a hard time installing ghc
14:30:46 <lambdabot>  262537412640768743.9999999999992500725971981856888793538563
14:30:55 <vixey> how did you do that roconnor :S
14:30:58 <quicksilver> although if you're interested in mathematical games
14:31:04 <vixey> > exp (pi*sqrt 163) :: CReal
14:31:06 <lambdabot>  262537412640768743.9999999999992500725971981856888793538563
14:31:08 <quicksilver> then it's interesting to ask why that is so close to a whole number
14:31:10 <vixey> huh
14:31:13 <vixey> > exp (pi * sqrt 163) :: CReal
14:31:15 <lambdabot>  262537412640768743.9999999999992500725971981856888793538563
14:31:21 <dmwit> quicksilver: genetic algorithms?
14:31:23 <vixey> so why wasn't it working before?
14:31:32 <dmwit> quicksilver: i.e. he chose something that was close to an integer
14:31:36 <quicksilver> no
14:31:37 <ziman> http://imgs.xkcd.com/comics/e_to_the_pi_minus_pi.png
14:31:37 <atp> it's cached now, probably
14:31:40 <quicksilver> well in a sense
14:31:40 <ziman> ;)
14:31:44 <quicksilver> but there is a reason
14:32:01 <dmwit> > sqrt 163
14:32:02 <quicksilver> it's related to the sums and products of polynomials with integer coefficents and surd coefficients
14:32:08 <lambdabot>  12.767145334803704
14:32:32 <roconnor> vixey: haskell is that good
14:32:37 <dmwit> > exp pi - pi :: CReal
14:32:38 <lambdabot>  19.9990999791894757672664429846690444960689
14:32:50 <quicksilver> vixey: the machine that LB runs on is very short on resources
14:33:05 <quicksilver> vixey: when it gets too loaded and a thread runs for more than 3 seconds it gets killed
14:33:09 <atp> given how many random thing we throw LB, that impresses me quicksilver
14:33:15 <tusho> We should devise an alternate floating point system for haskell that gets both of these 'right'. :P
14:33:17 <atp> things*
14:33:35 <geezusfreeek> > exp (pi * sqrt 163) :: Double
14:33:39 <vixey> that good that it sometimes doesn't work and sometimes does :/
14:33:43 <lambdabot>  2.6253741264076826e17
14:33:56 <roconnor> tusho: what do you mean by right?  giving integers :P
14:34:10 <tusho> Yeah
14:34:11 <tusho> :P
14:35:30 <atp> i am sick of neckties
14:35:35 <geezusfreeek> > exp (pi * sqrt 163) :: CDouble
14:35:38 <lambdabot>   Not in scope: type constructor or class `CDouble'
14:36:01 <atp> are CReals infinite-precision?
14:36:12 <roconnor> atp: arbitrary precision
14:36:13 <atp> i guess they couldn't be
14:36:16 <atp> yeah
14:36:18 <atp> that's what i meant :)
14:37:29 <atp> you know, i think we should use more greek letters in our haskell code.  is GHC unicode aware?
14:37:38 <Peaker> arbitrary precision where you have the entire computation symbolically and choose the precision of the result, which choose the precision of the inputs of each computation according to that, somehow?
14:37:39 <geezusfreeek> atp: yes
14:37:43 <vixey> roconnor: CReal isn't arbitrary precision really..
14:37:55 <atp> geezusfreeek: do you use them?  how does it feel?
14:38:04 <vixey> I call it exact real arithmetic
14:38:14 <vixey> GMP is arbitrary
14:38:29 <geezusfreeek> atp: i haven't used them
14:38:35 <roconnor> vixey: I think I might agree with you
14:38:52 <atp> geezusfreeek: do you know how GHC decides what should be an operator and what shouldn't, in light of unicode?
14:38:55 <dmwit> I don't understand the distinction.
14:38:56 * gubagem keeps having weird indentation problems and stuff
14:39:03 <geezusfreeek> dunno
14:39:15 <geezusfreeek> there is also debate over what is a capital letter
14:39:20 <dmwit> ?paste it, gubagem
14:39:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:39:29 <atp> well, that i understand
14:39:35 <atp> not all writing systems are bicameral
14:39:43 <atp> and there's some overlap...
14:41:15 <gubagem> dmwit: even more errors im gonna try to hunt them down
14:42:03 <roconnor> dmwit: Maple uses arbirtrary precision arithmetic in that you can specify a size of floating point number to use for all computation; however there is still rounding at every step in the computation.
14:42:17 <dmwit> ah
14:42:20 <gubagem> isnt there a way to just use bignums for abritary precision
14:42:28 <roconnor> So prehaps it is better to save the word arbitrary precision to mean what Maple does.
14:42:57 <quicksilver> "bignum style floats" in the sense of both unbounded mantissa and unbounded exponent
14:43:03 <quicksilver> is rather unwieldy
14:43:12 <mmorrow> spidermonkey js interp main: http://lxr.mozilla.org/mozilla/source/js/src/js.c
14:43:14 <lambdabot> Title: mozilla/js/src/js.c
14:43:20 <quicksilver> due to the nature of floating point your mantissas grow very quickl indeed.
14:43:35 <quicksilver> atp: using the unicode classification stuff
14:44:25 <mmorrow> a choice quote: /* Assume that we can not use more than 5e5 bytes of C stack by default. */
14:44:31 <mmorrow> (thx)
14:45:45 <mmorrow> > 5e5/1024
14:45:46 <lambdabot>  488.28125
14:45:48 <olsner> approx. 2^19?
14:46:05 <quicksilver> 512KB
14:46:09 <olsner> > 5e5 / (2^19)
14:46:10 <lambdabot>  0.95367431640625
14:46:16 <quicksilver> probably rather reasonable.
14:46:25 <mmorrow> haha i'm an idiot
14:46:28 <olsner> quicksilver: yes, that's what I said :P
14:46:34 <mmorrow> i wont even say what i thought
14:46:38 <quicksilver> I know :)
14:46:47 <mmorrow> ;)
14:48:04 <olsner> but 512KB is pretty huge ... in some places you don't get more than 8KB and have to start by mallocing a new stack and hacking the stack pointer :P
14:48:21 <quicksilver> not the kind of arch mozilla runs on though :)
14:49:26 <Botje> before I ditch C-- and just generate C: anyone here knows why C-- generates such crap code?
14:49:39 <dons> Botje: which C-- compiler?
14:49:41 <Botje> (by C-- I mean the Quick C-- implementation)
14:49:45 <dons> oh, qc--
14:49:55 <gubagem> is C-- decebt>
14:49:58 <Botje> and is there something better? :)
14:49:59 <dons> its not widely used, in comparison to gcc?
14:50:11 <Botje> yeah
14:50:11 <gubagem> rephrase is c-- decent?
14:50:16 <dons> Botje:  i suggest using Cmm as an intermediate representation, and then passing that off to the intel C compiler
14:50:29 <quicksilver> I think C-- is probably a good language
14:50:38 <Botje> I started out by (mistakenly) assuming GHC also uses quick C--
14:50:39 <quicksilver> however its compiler has not had much loving.
14:50:51 <vixey> hey how about http://www.cs.cornell.edu/talc/
14:50:52 <lambdabot> Title: Typed Assembly Language
14:50:57 <quicksilver> the Cmm compiler in ghc is probably better.
14:50:57 <vixey> I just found this
14:50:58 <dons> Botje: no, it uses its own C-- code generator
14:51:00 <Botje> how well integrated is GHC's C-- implementation?
14:51:06 <Botje> I might just rip it out and use that
14:51:07 <quicksilver> but it's not a general purpose C-- impl AFAIK
14:51:09 <dons> its not true C--
14:51:12 <Botje> ah, bummer
14:51:19 <Botje> i'll generate C then
14:51:19 <mmorrow> Botje: i tried a few months ago to build that quick c-- compiler but hit a nightmare lua dependecny issue and abandoned it. in theory though, for functional langs it should be better code (or at least the possibility to achieve that exists)
14:51:22 <vixey> I think the one of the C-- people has worked on TAL
14:51:51 <Botje> mmorrow: the code for even a simple thing such as int main() { return 5; } is pretty horrible
14:52:22 <Botje> and I cheated on qc-- by installing the dependencies the debian/control file mentioned by hand
14:52:47 <mmorrow> Botje: i guess if it's "quick" c-- vs. gcc i'd (grudgingly) go gcc
14:53:08 <Botje> yeah
14:53:21 <Botje> I've arrived at the same conclusion
14:53:37 <Botje> perhaps I could write a Cmm compiler in haskell
14:53:38 <vixey> that's quite funny too http://www.cs.cornell.edu/talc/icfp99-contest/contest.htm
14:53:39 <lambdabot> Title: ICFP '99 Programming Contest Entry
14:53:47 <Botje> but don't have quite the time now :)
14:53:51 <mmorrow> Botje: i should try to build quick c-- again though, i'm sure the/my issue is gone months later
14:53:56 <dons> Botje: just spit it into icc or gcc
14:54:04 <Botje> dons: yup, i'll do that
14:54:07 <dons> try to produce ansi C, and the C compielr will do a good job
14:54:36 <quicksilver> unless you're after tail calls ;P
14:54:37 <mmorrow> Botje: i'd be interesting in taking part in that
14:54:51 <quicksilver> or stack unwinding
14:54:56 <quicksilver> which are pretty hard in ansi C
14:55:16 <Botje> quicksilver: while (true) { *cont(args); } ?
14:55:29 <Botje> where the code in cont should set cont and args for the next call
14:55:40 <vixey> while (true) { cont = cont(args); }
14:55:54 <Botje> yeah
14:55:56 <Botje> that's similar
14:56:07 <vixey> you just return the continuation instead of calling it
14:56:18 <Botje> i'm just confused about whether *cont will jump to the funtion or not
14:56:19 <quicksilver> Botje was just taking advantage of the mutability of his host language ;)
14:56:20 <Botje> probably not
14:56:22 <Botje> returning it is!
14:56:40 <mmorrow> i've been trying to think if that's equiv to being in a single function and using gotos to jump around
14:56:44 <mmorrow> is it?
14:56:57 <Botje> it's not, but i'd like it to be :o)
14:57:04 <vixey> mmorrow: I don't think it makes much sense to say equivalent
14:57:06 <mmorrow> crap, what i figured
14:57:26 <gubagem> so say: state<-look stat, and look returns (newState), is my newvar state gonna be wrapped with a monad?
14:57:41 <mmorrow> vixey: i guess i mean equiv in that the stack stays at 0 across gotos/calling-cont
14:57:49 <mmorrow> "calling-cont"
14:58:13 <vixey> mmorrow: the stack stays at 0 if you jump around in a huge main, the stack hops between 0 and 1 if you have continuations like that
14:58:57 <mmorrow> yeah, i guess it'd be the same if "calling-cont" was returning a funcptr and a ptr to args, the immediately calling that from within the while loop
14:59:04 <mmorrow> so a trampoline
14:59:14 <quicksilver> gubagem: I don't really understand you quesiton but I think the answer is "No. <- unwraps the monad"
15:00:36 <mmorrow> while (1) { *two = (*go)(args); go = *two; args = *(two+1); }
15:00:55 <vixey> why return anything
15:01:07 <mmorrow> so you can keep the stack from growing
15:01:35 <vixey> main(void) { thingy *stuff; while(1) { continuation = continuation(&stuff); } }
15:02:01 <chessguy> i like the variable names
15:02:56 <mmorrow> vixey: you're right, while (1) { (*go)(go,args); } -- go sets its first arg to funcptr of continuation before returning
15:03:29 <quicksilver> (*go)(&go,args)
15:03:31 <quicksilver> I thinkg
15:03:39 <vixey> depends on what go is
15:03:39 <mauke> go(&go, args)
15:03:44 <mmorrow> go in the address
15:03:46 <vixey> you know f = *f = **************f
15:03:55 <mmorrow> s/in/is/
15:04:25 <mmorrow> void (*go)(void*,void*)
15:04:32 <tusho> **********************f
15:04:33 <tusho> that wins
15:04:37 <Botje> mrr
15:04:44 <Botje> i'll go with the simplest thing that can possibly work
15:04:51 <tusho> Botje: Um.
15:05:03 <Botje> and then consider slightly more advanced stuff such as rewriting self-tail-calls to while loops
15:05:07 <Botje> tusho: yes? :)
15:05:34 <gubagem> quicksilver: thats what i want, it unwrapped, but its saying the type is IO a
15:05:52 <vixey> Botje: this continuation method is what GHC does
15:05:54 <vixey> at least I read this..
15:06:17 <Botje> ah, cool :)
15:06:28 <Botje> great minds think alike then *runs*
15:07:07 <dmwit> gubagem: For the duration of the do-block, you can treat it as though it were unwrapped.  But by the end of the block, you have to wrap it back up again.
15:07:19 <dmwit> This is a very hand-wavy explanation.
15:08:37 <quicksilver> well ghc compiles to Cmm not to C, though.
15:08:47 <gubagem> dmwit: someFunction someArgs state>>=mainLoop (which takes state as its only argument) do i still need to wrap it up again
15:08:47 <quicksilver> maybe this is what ghc does in -fvia-C mode?
15:09:12 <dmwit> gubagem: Most likely "mainLoop" wraps things up for you.
15:09:30 <dmwit> gubagem: But it's impossible to tell what you mean without seeing some type annotations.
15:09:52 <gubagem> mmmm ill keep whacking it then
15:10:05 <vincenz> vixey: f != *f
15:10:22 <dmwit> gubagem: Are you familiar with how do-notation boils down to (>>=)/return notation?
15:11:01 <vixey> vincenz: f is a function pointer
15:11:28 <mauke> or s/ pointer//
15:11:49 <vincenz> vixey: even then
15:11:59 <vincenz> oh
15:12:00 <vincenz> hmm
15:12:10 <dmwit> Surprise!
15:12:40 <dmwit> & is the identity for functions in C. (!)
15:13:09 <mauke> dmwit: not quite true
15:13:18 <cjb> s/for functions//?  :)
15:13:22 <dons> initial release of uvector, for those who like to write fast loops, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector
15:13:24 <lambdabot> http://tinyurl.com/5v6vcv
15:13:30 <dmwit> cjb: Certainly not.
15:13:45 <vixey> cool dons
15:13:50 <vincenz> dmwit, vixey: I was not aware of that
15:14:10 <mauke> * is the identity for functions
15:14:15 <mauke> & isn't
15:14:20 <mmorrow> int *x = 42; void *g; g = ((void*)())x; (*g)();
15:14:29 <lilachaze> functions in C decay (read: implicitly convert) to pointers to functions, in many contexts. in the same way, arrays of T decay to pointers-to-T.
15:14:31 <mauke> mmorrow: parse error
15:14:48 <mmorrow> yeah, i got lost in the poarens
15:14:57 <dmwit> Too much fluff.
15:15:00 <mmorrow> but that'd work (i believe)
15:15:00 <mauke> also, int *x = 42 is an error
15:15:02 <dmwit> int *x=42;
15:15:06 <mmorrow> heh
15:15:09 <dmwit> int *x;
15:15:16 <dmwit> ((void*)())x();
15:15:23 <gubagem> ok ill hpaste it
15:15:29 <dmwit> Might need one more set of parens.
15:15:32 <lilachaze> dmwit: that fails, since postfix binds tighter than prefix
15:15:32 <dmwit> (((void*)())x)();
15:15:40 <mauke> that's still an error
15:15:45 <mauke> () is not a valid expression
15:16:10 <dmwit> Oh really, does it have to be (void*()), then?
15:16:20 <lilachaze> mauke: but expr() is a valid expression if expr is a function pointer...
15:16:21 <vixey> my favorite C code is still,  void *x; x = &x;
15:16:25 <mauke> lilachaze: irrelevant
15:16:38 <mauke> vixey: can be shortened to void *x = &x;
15:16:40 * mmorrow pulls out his "The C Programming Language"
15:16:46 <mauke> variables are in scope in their own initializers
15:16:57 <mauke> (for no good reason)
15:17:07 <lilachaze> ((void*(*)())x)(); // legal, i think...
15:17:08 <hpaste>  gubagem pasted "my last remaining error, its a type problem" at http://hpaste.org/8245
15:17:23 <mauke> ((void (*)())x)()
15:17:37 <dons> $ cabal install uvector  , works dcoutts. woot.
15:17:45 <lilachaze> mauke: depends whether you want it to return void or void*. I assumed void* since that's what dmwit's example did
15:17:46 <dcoutts> @arr!
15:17:46 <lambdabot> Aye
15:18:08 <lilachaze> dmwit: your examples all cast to a function type, rather than to a pointer-to-function. :)
15:18:10 <quicksilver> dons++
15:18:12 <mauke> dmwit's example was a syntax error
15:18:18 <dons> a type family for every child! no registers left behind!
15:18:23 * dmwit ducks out of the C discussion
15:18:27 <lilachaze> mauke: dmwit's example was a semantic error :)
15:18:43 <lilachaze> (void*)() is a valid function type
15:18:43 <mauke> not really
15:18:47 <mauke> no, it isn't
15:18:49 * mmorrow can't seem to find his "The C Programming Language"
15:18:50 <mauke> types can't start with (
15:18:59 <mauke> (void*)() casts the expression () to void *
15:19:03 <Botje> gubagem: can you supply the actual error?
15:19:04 <mauke> except () is not an expression
15:19:05 <gubagem> whats the return type of a function that never returns
15:19:15 <quicksilver> mauke: variables are in scope in their initializers? that is sick ;)
15:19:17 <lilachaze> gubagem: a
15:19:25 <lilachaze> quicksilver: it can be useful
15:19:27 <dmwit> gubagem: What is the exact error?
15:19:36 <quicksilver> lilachaze: sick I tell you ;)
15:19:43 <lilachaze> quicksilver: yes, i agree :)
15:19:49 <vixey> lilachaze: In a strict language..? how?
15:20:00 <lilachaze> quicksilver: my favourite C and haskell one-liner: double x = x * 2;
15:20:15 <dmwit> quicksilver: cute
15:20:25 <lilachaze> vixey: Foo a(do_something(&a));
15:20:27 <Botje> gubagem: go should be in the monad too, though
15:20:34 <eu-prleu-peupeu> in an arbitrary type class, how do i know wich is the minimal complete definition ?
15:20:36 <dmwit> err... @lilachaze
15:20:43 <mauke> C++ infestation detected
15:20:53 <Botje> so go should look like go ... = if ... then return state else if ... then return $ State ... else return state
15:21:00 <dons> eu-prleu-peupeu: you add things till the compiler stops complaining?
15:21:00 <dmwit> eu-prleu-peupeu: Only by documentation or looking at the source.
15:21:07 <lilachaze> OK, in C then... Foo a = { do_something(&a) }; HAPPY NOW?
15:21:14 <dons> usually the docs will cover this
15:21:21 <eu-prleu-peupeu> dons: yes :/
15:21:22 <vixey> no :(
15:21:25 <lilachaze> ;-)
15:21:38 <mauke> nice use of { }
15:21:48 * mmorrow goes out to his car. maybe his "The C Programming Language" will be in there.
15:21:58 <hpaste>  (anonymous) annotated "my last remaining error, its a type problem" with "annotated with ghc error" at http://hpaste.org/8245#a1
15:22:09 <gubagem> thats mine with the error
15:22:15 <Botje> gubagem: yeah, what I just said, then
15:22:25 <Botje> put returns in the right places
15:22:40 <gubagem> where would the 'correct' places
15:22:59 <gubagem> so go should be using a return State
15:23:12 <dons> eu-prleu-peupeu: what would you like?
15:23:18 <Botje> so go should look like go ... = if ... then return state else if ... then return $ State ... else return state
15:23:27 <gubagem> okie
15:23:43 <Botje> and the type should change accordingly
15:24:09 <Botje> it should be go :: (Room->Bool)->(Location->Location)->State->IO State
15:25:07 <eu-prleu-peupeu> dons: minimal :: Class a => a -> [String] or something like that :/
15:25:34 <dmwit> Botje: I don't like that solution.
15:25:49 <dmwit> gubagem: How about changing "go ... >>= mainLoop" to "mainLoop . go ..."?
15:25:51 <eu-prleu-peupeu> or syntax to explicitly define the minimal ones
15:25:53 <dons> eu-prleu-peupeu: interesting idea.
15:25:59 <Botje> dmwit: that's what his code says, though
15:26:07 <gubagem> how do the initial wrapping of State to IO State
15:26:15 <dmwit> Botje: eh?
15:26:18 <Botje> gubagem: that's waht return does
15:26:28 <Botje> dmwit: what if he wanted to print "so you go east" after moving ?
15:26:42 <dmwit> Botje: Then he can upgrade when that becomes necessary.
15:26:45 <lilachaze> i find myself wondering whether Haskell would be a better language if the default were strict rather than lazy
15:26:48 <gubagem> i have a lot of stuff i need to work on
15:26:58 <dmwit> Botje: Until then, "go" is notionally pure, and I see no reason to change that.
15:27:07 <gwern> hm. looks like tor finally got unbanned
15:27:07 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:27:09 <Botje> i agree on that
15:27:10 <gubagem> main=do mainLoop state should become what so i can call mainLoop with IO State
15:27:16 <gwern> @messages
15:27:17 <lambdabot> sclv said 2h 3m 5s ago: Two WASH components (HTML and MAIL) look like they stand alone quite nicely. Somebody (hint) may want to split them out and package them up
15:27:31 <Botje> gubagem: you don't need to do that
15:27:42 * gubagem is lost
15:27:51 <Botje> go >>= mainloop = do newstate <- go; mainloop newstate
15:27:51 <mmorrow> "<mauke> C++ infestation detected" loll
15:28:01 <gwern> @tell sclv but hint is for going through the ghc api! what does that have to do with wash? :)
15:28:01 <lambdabot> Consider it noted.
15:28:04 <gwern> @where wash
15:28:05 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
15:28:17 <Botje> gubagem: that newstate there is of type State
15:28:29 <Botje> so mainloop should accept just a State
15:29:10 <gubagem> do i need do's inside of the case expressions? oh i see i do
15:29:14 * gubagem dodo bird
15:29:18 <newsham> new toy in case you havent seen it yet:  http://codepad.org/JREX7ETb
15:29:26 <dmwit> gubagem: No, you don't *need* them.
15:29:33 <dmwit> gubagem: Only if you want to introduce a do-block.
15:29:35 <newsham> lets you paste and execute code on website
15:29:39 <gwern> newsham: that the yhc->js thing?
15:29:39 <newsham> for many languages including haskell
15:29:42 <newsham> nope
15:30:02 <dmwit> newsham: No, it actually compiles and runs the Haskell on their server.
15:30:22 <dmwit> newsham: (In some chroot jail with other security restrictions, I suppose.)
15:30:31 <newsham> dmwit: not sure why you're telling me :)
15:30:35 <dmwit> uh
15:30:37 <dmwit> sorry
15:30:59 <dmwit> I haven't really been sleeping properly, and I've been mis-nicking all over the place.
15:34:19 <gubagem> its Compiling now hooray, thanks guys
15:34:27 <Botje> yay!
15:35:01 <gubagem> now i have a runtime bug but its time for dinner
15:35:03 <gubagem> peace
15:37:43 <mmorrow> @src read
15:37:43 <lambdabot> read s = either error id (readEither s)
15:37:51 <mmorrow> @src readEither
15:37:52 <lambdabot> Source not found. Take a stress pill and think things over.
15:38:04 <mmorrow> @src Read
15:38:04 <lambdabot> class Read a where
15:38:04 <lambdabot>   readsPrec    :: Int -> ReadS a
15:38:04 <lambdabot>   readList     :: ReadS [a]
15:38:04 <lambdabot>   readPrec     :: ReadPrec a
15:38:04 <lambdabot>   readListPrec :: ReadPrec [a]
15:41:52 <chessguy> @hoogle readEither
15:41:53 <lambdabot> No matches found
15:42:08 <mauke> readNone
15:44:46 <gwern> @where hoogle
15:44:46 <lambdabot> http://haskell.org/hoogle
15:47:57 <mmorrow> their haskell support at http://codepad.org is killing me
15:48:06 <mmorrow> foldl (*) 1 [1..99]
15:48:10 <mmorrow> Error occurred
15:48:15 <mmorrow> ERROR line 1 - Syntax error in input (unexpected `..')
15:49:16 <dmwit> mmorrow: Try main = print $ foldl (*) 1 [1..99]
15:49:18 <mmorrow> whoa, it's probably declarations not exps...
15:49:38 <awesame> mmorrow: ghc is on my to-do list
15:49:39 <dmwit> (It actually runs GHC on your code.  so...)
15:49:54 <awesame> dmwit: no, it's hugs
15:50:02 <dmwit> Oh, okay.
15:50:06 <awesame> but with -98 so you have some extensions
15:50:07 <dmwit> Anyway, it runs a compiler on your code.
15:50:12 <awesame> I'll be switch to ghc eventually
15:50:19 <awesame> *switching
15:50:29 <dmwit> Oh, are you the codepad.org author?
15:50:32 <awesame> yeah
15:50:44 * gwern updates lambdabot's hoogle; was missing something like 60kb of entries, it seems
15:50:50 <awesame> the backend is in haskell, hence my presence here
15:51:09 <dmwit> neat
15:51:22 <mmorrow> hah, victory!
15:51:25 <mmorrow> main = let fix f = f (fix f)
15:51:25 <mmorrow>        in print
15:51:25 <mmorrow>             . foldl (.) id (repeat read)
15:51:25 <mmorrow>               $ fix show
15:51:29 <mmorrow> "runhugs: Error occurred
15:51:32 <gwern> as is geordi, iirc
15:51:33 <mmorrow> ERROR - Garbage collection fails to reclaim sufficient space
15:52:03 <mmorrow> > foldl (.) id (repeat read) $ fix show
15:52:07 <lambdabot>  "
15:52:44 <newsham> awesame: your codepad site?  good stuff.  ballsy, too :)
15:52:55 <awesame> thanks
15:52:59 <newsham> http://codepad.org/CTKdgNxs http://codepad.org/j42mnYv3
15:53:01 <gwern> hugs? in my websites?
15:53:20 <vixey> cool
15:53:25 <newsham> awesame: would be nice having a longer "recent" list, with title sand such, a la hpaste.org
15:53:56 <dmwit> People are obviously trying to hack it.
15:54:05 <awesame> newsham: that julia/mandelbrot ascii thing is neat
15:54:05 <dmwit> "for x in os.walk(os.sep): print x"
15:54:15 <mmorrow> awesame: awesome!
15:54:16 <geezusfreeek> dmwit: ;)
15:54:42 <awesame> newsham: I'm thinking about adding titles.  I've been super conservative about new features, because I'm trying to keep it simple
15:54:56 <geezusfreeek> simple is good
15:55:11 <mmorrow> awesame: is the code opensource?
15:55:25 <mmorrow> awesame: or is there a darcs repo?
15:55:40 <mmorrow> s/or/so/
15:56:28 <vixey> > 1000000000000
15:56:30 <lambdabot>  1000000000000
15:56:35 <byorgey> awesame++
15:56:42 <mmorrow> awesame++
15:56:48 <geezusfreeek> awesame++
15:56:53 <geezusfreeek> :)
15:57:01 <vixey> awesame + 1000000000000
15:57:11 <awesame> mmorrow: not so far.  I'm planning on releasing the backend sometime, but my to-do list is long, and that's low-priority for me.
15:57:23 <awesame> aw, shucks
15:57:54 <vixey> why don't you release it as-is?
15:57:59 <awesame> mmorrow: it's based on geordi, though, which is available
15:58:05 <vixey> what work is there to do before you could release it
15:58:18 <awesame> vixey: I'm still shy about my haskell
15:58:20 <newsham> would be lots of fun browsing all of the pastes within the last 24hrs
15:58:40 <mmorrow> heh, just pasted "geordi" into firefox and got http://en.wikipedia.org/wiki/Geordi_La_Forge
15:58:42 <vixey> awesame: You've written a program that works!
15:58:53 <t12> alert: newsham sighting
15:58:58 <geezusfreeek> is whole the site in haskell or just some daemon or script somewhere?
15:59:07 <vixey> awesame: what could you possibly be shy about? "You could have use fix fmap return here instead of that two line helper function"
15:59:18 <geezusfreeek> i mean, obviously the interpreters/compilers aren't, and geordi isn't
15:59:23 <awesame> geezusfreeek: just the backend execution server.  the web site is in python.
15:59:29 <geezusfreeek> ah, okay
15:59:31 <mmorrow> awesame: release it as-is! are you kidding, that site is first-of-its-kind
15:59:36 <awesame> geodi is in haskell
15:59:41 <geezusfreeek> oh?
16:00:45 <geezusfreeek> neat
16:01:17 <byorgey> uvector, w00t!
16:03:33 <awesame> vixey: yeah, maybe I should get over it
16:04:01 <mmorrow> @src foldl'
16:04:01 <lambdabot> foldl' f a []     = a
16:04:01 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:04:06 <vixey> awesame: no matter how riducoulsly stupid your code -is-, You've written real working stuff :p
16:06:27 <byorgey> anyone know how I can read a character from the console immediately as soon as it is typed, without waiting for a whole line to be entered first?
16:06:45 <Lemmih> byorgey: Disable buffering.
16:07:10 <byorgey> with hSetBuffering?  does that affect input as well as output?
16:07:44 <dmwit> Since you have to specify the handle, and stdin /= stdout, no.
16:08:03 <byorgey> aha, of course
16:08:12 <byorgey> I forgot that hSetBuffering took a Handle as an argument =)
16:09:05 <byorgey> sweet, works great
16:09:31 <mmorrow> check out hSetEcho also ...
16:11:43 <vixey> :t getChar
16:11:46 <lambdabot> IO Char
16:14:31 <jaj> > getChar >>= \a -> print a
16:14:33 <lambdabot>  <IO ()>
16:14:59 <dmwit> > getChar >>= print
16:15:00 <vixey> this is great
16:15:01 <lambdabot>  <IO ()>
16:15:17 <vixey> I am really pleased with the GADT definition of IO
16:15:35 <vixey> haskell is pure
16:16:34 <gwern> now it will not korrupt our previous bodily integrity
16:17:01 <shapr> @seen edwardk
16:17:01 <lambdabot> I saw edwardk leaving #haskell-blah and #haskell 55m 44s ago, and .
16:19:45 <dobblego> what is a monad without unit?
16:19:56 <vixey> what's unit?
16:20:00 <dobblego> sorry, return
16:20:21 <dmwit> Applicative?
16:20:29 <dmwit> ?src Applicative
16:20:29 <lambdabot> class Functor f => Applicative f where
16:20:29 <lambdabot>     pure  :: a -> f a
16:20:29 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:20:34 <vixey> what's a dinosaur with no eyes..
16:20:38 <dmwit> Oh, nope, that's got a return.
16:20:46 <vixey> @src fmap
16:20:47 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:21:03 <dmwit> ?src Functor
16:21:03 <lambdabot> class  Functor f  where
16:21:03 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:21:09 <dmwit> dobblego: A Functor. =)
16:21:09 <dobblego> maybe it's a "nothing", but maybe it is not
16:21:17 <dobblego> heh, yes agreed :)
16:22:04 <slava> hi dobblego
16:22:09 <dobblego> hello slava
16:23:40 <shapr> hi slava!
16:24:01 <slava> hi shapr
16:26:22 <mmorrow> dons: so what's the motivation for -O2 instead of -O3?
16:26:51 <dmwit> -O3 is slower =P
16:26:57 <ivanm> and unstable?
16:27:08 <mauke> -O3 doesn't exist
16:27:15 <mmorrow> um
16:28:26 <mmorrow> i'm checking, but i thought it's -O4 that doesn't exist
16:28:34 <mmorrow> pretty sure...
16:28:44 <mauke> -O4 doesn't exist either
16:29:04 <dmwit> How about -O5?
16:29:05 <mmorrow> you are sly like t3h fox!
16:30:28 <dons> mmorrow: for ghc?
16:30:39 <dons> or gcc, just use at least -O2
16:30:43 <mmorrow> gcc
16:30:54 <dons> less than that and you don't get indirect jumps resolved
16:30:59 <mmorrow> oh, mauke you were prob talking about ghc...
16:31:02 <dons> above that not much more happens
16:31:15 <mmorrow> ah
16:31:59 <mmorrow> i asked about that before and sjanssen said that -O3 and the mangler didn't play well together sometimes
16:32:27 <dons> i've not heard of reports of that for a while
16:32:29 <mmorrow> is this a continuing issue, or did it just happen once for a bit after a gcc asm ouput syntax change?
16:32:34 <mmorrow> cool
16:39:50 <Maciej> @pl \x y -> y
16:39:51 <lambdabot> const id
16:40:38 <dmwit> Also, flip const.
16:40:46 <ivanm> yeah, that's what I was thinking
16:40:59 <dmwit> "seq" has the right type signature, but it could have unwanted side-effects if you don't know what you're doing. =)
16:41:23 <dmwit> const id is clever, though.
16:41:25 <dmwit> pl++
16:41:59 <kscaldef> const id is much less clear than flip const, though
16:42:07 <dmwit> right
16:42:49 <vixey> > const id 3
16:42:50 <lambdabot>  Add a type signature
16:42:57 <mauke> :t curry snd
16:42:59 <lambdabot> forall a b. a -> b -> b
16:43:08 <dmwit> cute
16:43:08 <vixey> > const id "aoeu"
16:43:09 <lambdabot>  Add a type signature
16:43:12 <dmwit> > const id 3 4
16:43:14 <lambdabot>  4
16:43:18 <dmwit> vixey: Needs more applications.
16:43:19 <Maciej> That's cool too
16:44:52 <Maciej> There's another which is not obvious I think:
16:44:57 <Maciej> :t flip id
16:44:59 <lambdabot> forall b c. b -> (b -> c) -> c
16:45:18 <dmwit> doesn't look right to me
16:45:19 <vixey> :t ($)
16:45:21 <lambdabot> forall a b. (a -> b) -> a -> b
16:45:54 <mmorrow> > foldl undefined undefined undefined
16:45:56 <lambdabot>  Exception: Prelude.undefined
16:46:06 <vixey> > undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined
16:46:07 <mmorrow> > foldl undefined undefined (repeat undefined)
16:46:09 <lambdabot>  Exception: Prelude.undefined
16:46:12 <lambdabot> Terminated
16:46:24 <dobblego> /msg lambdabot @msg #haskell  42
16:46:42 <mmorrow> whoa foldl must be foldl' in lmbdabot, cuz foldl undefined undefined (repeat undefined) isn't undefined in my ghci
16:46:52 <dmwit> mmorrow: It isn't here, either.
16:46:56 <dmwit> mmorrow: It's Terminated.
16:47:10 <vixey> mmorrow: lambdabot doesn't reply in order
16:47:10 <mmorrow> oh, that was vixey's undefined
16:47:18 <mmorrow> heh
16:47:21 <vixey> maybe it should?
16:47:24 <vixey> dons what do you think?
16:47:28 <dmwit> no
16:47:42 <dmwit> I don't think it should.
16:48:41 <mmorrow> i think it's fine, it woulda been clear if id'd noticed vixey's
16:48:45 <jaj> theoretically speaking its values is _|_, right?
16:48:52 <dmwit> yes
16:48:58 <mmorrow> rewrite rules
16:49:10 <mmorrow> fix id -> undefined
16:49:13 <dmwit> foldl ... ... (repeat ...) = _|_, I'm afraid
16:49:18 <mmorrow> foldl undefined undefined (repeat undefined) -> undefined
16:49:43 <dmwit> That's why we like foldr. =)
16:50:26 <dmwit> :t foldl
16:50:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:50:33 <dmwit> > foldl f [x,y,z]
16:50:34 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
16:50:39 <dmwit> > foldl f a [x,y,z]
16:50:41 <lambdabot>  f (f (f a x) y) z
16:51:06 <jaj> @pl f (f (f a x) y) z
16:51:07 <dmwit> > let f _ x = x in foldl f a [x,y,z]
16:51:07 <lambdabot> f (f (f a x) y) z
16:51:08 <lambdabot>  z
16:51:25 <dcoutts> dons: cabal install foo -fbar -f-baz now works (darcs pull for that and the build-reporting goodness)
16:51:27 <Maciej> lambdabot accepts variables?
16:51:31 <dmwit> ?pl \a x y z -> f (f (f a x) y) z
16:51:34 <lambdabot> (((f .) . f) .) . f
16:51:34 <vixey> Maciej: Yes
16:51:39 <dmwit> Maciej: The one-letter variables are bound to magic.
16:51:43 <dmwit> ?where twanvl
16:51:43 <lambdabot> I know nothing about twanvl.
16:51:51 <dons> dcoutts: you want me to try it out?
16:52:12 <vixey> ?pl \z a b c d e -> f (f (f (f (f z a) b) c) d) e
16:52:12 <lambdabot> (((((((f .) . f) .) . f) .) . f) .) . f
16:52:20 <dcoutts> dons: if you have time
16:52:27 <dmwit> ?where+ twanvl http://twan.home.fmf.nl/blog/haskell/
16:52:27 <dons> doing os.
16:52:30 <lambdabot> Done.
16:52:42 <dmwit> Maciej: Check out that article for how it's done; basically just some neat type-class hacks.
16:53:00 <dcoutts> dons: you were asking about it yesterday, I thought you might like the feature added :-)
16:53:05 <dons> There is no available version of Cabal that satisfies >=1.3.12 && <1.5
16:53:10 <dons> which cabal should i use?
16:53:10 <dmwit> > expr "you can also make your own named variables like this" + x
16:53:14 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Char]'
16:53:17 <dcoutts> dons: from the 1.4 branch
16:53:28 <dcoutts> d.h.o/cabal-branches/cabal-1.4
16:53:32 <dons> cheers
16:53:34 <dmwit> > expr (fun "you can also make your own named variables like this") + x
16:53:38 <lambdabot>  you can also make your own named variables like this + x
16:54:12 <mauke> > var "why so sad"
16:54:16 <lambdabot>  why so sad
16:54:28 <dmwit> But:
16:54:34 <dmwit> :t (var, expr)
16:54:35 <lambdabot> forall a. (String -> Sym a, Expr -> Expr)
16:54:37 <dcoutts> dons: if you're using the tarball snapshot you'll also notice a significant speedup in dep resolution
16:54:41 <mmorrow> http://www.mozilla.org/js/spidermonkey/tutorial.html
16:54:44 <lambdabot> Title: Brendan How to Embed JS Engine
16:54:46 <dmwit> Sym a /= Expr, right?
16:54:55 <dcoutts> dons: for the build reports, look in ~/.cabal/packages/$server/build-reports.log
16:55:08 <jaj> naah I don't like gecko
16:56:18 <mmorrow> http://developer.mozilla.org/en/docs/SpiderMonkey_Garbage_Collection_Tips
16:56:20 <lambdabot> Title: SpiderMonkey Garbage Collection Tips - MDC, http://tinyurl.com/63qp8g
16:58:12 <Maciej> dmwit: What does Sym stand for, Sym = symbol = variable?
16:58:27 * dmwit shrugs
17:02:46 <mwc> greatest tool ever: http://www.stgraber.org/download/projects/pastebin/
17:03:03 <mwc> pastebot access via CLI :D
17:03:15 <mauke> No, John. You are the greatest tool ever.
17:03:16 <mwc> needs hpaste ;)
17:03:18 <mmorrow> http://morrow.jypsis.com/code/misc/jsgrammar14.pdf
17:03:45 <shapr> @quote cjb
17:03:45 <lambdabot> cjb says: * cjb answered lots of questions about emacs from RMS, which doesn't feel like the natural order of things at all.
17:04:18 <ivanm> lol
17:04:28 <mauke> mwc: http://mauke.ath.cx/stuff/perl/pastebin ?
17:04:36 <shapr> !paste
17:04:36 <hpaste> Haskell paste bin: http://hpaste.org/
17:05:16 <mmorrow> http://morrow.jypsis.com/code/misc/jsgrammar14.txt
17:05:41 <gwern> what kind of extension is this? data Binary = forall a b c. (Read a, Show a, Read b, Show b, Read c, Show c) => BA (a -> b -> c
17:05:53 <mauke> existential
17:06:46 <dobblego> existential types?
17:07:05 <Tigran> Strangly enough, I was just reading about existential types
17:07:12 <Tigran> http://en.wikibooks.org/wiki/Haskell/Fun_with_Types
17:07:42 <vixey> mmorrow: wow :o
17:07:53 <gwern> guess it's a rank2type
17:07:54 <vixey> mmorrow: You put a lot of work in :)
17:08:05 <mmorrow> heh, i didn't make this
17:08:12 <mmorrow> just converted it from rtf
17:08:52 <mmorrow> http://developer.mozilla.org/en/docs/JavaScript_Language_Resources
17:08:53 <lambdabot> Title: JavaScript Language Resources - MDC, http://tinyurl.com/ywjxvh
17:09:14 <mmorrow> http://www.mozilla.org/js/language/grammar14.html
17:09:14 <lambdabot> Title: JavaScript 1.4 Grammar
17:09:48 <gwern> going through the lambdabot source, I sometimes wonder how Cale manages to run it at all
17:09:56 <gwern> @quote DAP
17:09:56 <lambdabot> DAP says: DAP - Download Accelerator Pro
17:10:42 <Cale> ...
17:10:50 <mauke> quote spam!
17:11:21 <gwern> aw, you're kidding. the pointless code uses *implicit parameters*? wth
17:11:44 <vixey> lol
17:11:48 <gwern> who the heck uses implicit parameters? I'll bet 8 out of 10 haskellers don't even know what those are
17:11:51 <vixey> that's great
17:12:03 <dmwit> Cale: Can you update ?list?
17:12:12 <mauke> ?lisp
17:12:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:12:12 <vixey> gwern!
17:12:32 <gwern> Cale: don't worry, I removed that in one of my patches
17:12:43 <Cale> dmwit: I suppose I could change the URL...
17:12:44 <gwern> I was surprised how much redundancy and crap there was in the quotes file
17:13:00 <Cale> gwern: Oh yeah, did byorgey get his account yet, I wonder.
17:13:30 <byorgey> Cale: not yet, but I applied gwern's patches to my local repo and uploaded a new version of oeis to hackage
17:13:49 <byorgey> I just can't push the patches to the public repo until I get my account reset
17:14:07 <gwern> Cale: dunno. he did upload an updated...
17:14:13 <gwern> (nm)
17:14:51 <Cale> ah, great
17:15:14 * gwern continues enumerating LANGUAGE pragmas. truly, -fglasgow-exts hides a multitude of sins
17:17:08 <gwern> lambdabot.hs alone requires: {-# LANGUAGE CPP, ExistentialQuantification, FlexibleContexts, FunctionalDependencies, GeneralizedNewtypeDeriving, MultiParamTypeClasses,PatternGuards, Rank2Types, RankNTypes, TypeOperators #-}
17:17:16 <dcoutts> byorgey: can I get you to try logging in to code.h.o in a min. I'm about to put your new key in.
17:20:44 <dcoutts> byorgey: try now please
17:21:25 <dons> gwern: RankN subsumes Rank2
17:22:35 <dcoutts> gwern: oh and data Binary = forall a b c. (blah blah   is existential not rank2/n
17:23:06 <dcoutts> it'd be rank 2/n if it were data Binary = Binary (forall x . blah blah)
17:23:06 <gwern> so it does
17:24:45 <dcoutts> byorgey: ?
17:24:55 <byorgey> dcoutts: ok, just a sec
17:26:04 <byorgey> dcoutts: it works, thanks =)
17:26:11 <dcoutts> byorgey: great
17:26:30 <Cale> @quote DAP
17:26:37 <lambdabot> No quotes match. Are you on drugs?
17:26:37 <Cale> @bot
17:26:43 <lambdabot> :)
17:27:20 <byorgey> gwern, Cale: ok, now I have also pushed the patches to the public oeis repo
17:27:48 <mmorrow> http://lxr.mozilla.org/mozilla/source/js/src/jslocko.asm
17:27:49 <Cale> What were the updates btw?
17:27:55 <lambdabot> Title: mozilla/js/src/jslocko.asm
17:28:08 <mmorrow> int _Optlink js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
17:28:14 <mmorrow> js_CompareAndSwap
17:28:23 <vixey> identity monad when Haskell programs are sure to terminate
17:28:23 <vixey> par tiality monad when termination is decidable
17:28:23 <vixey> general recursion monad ... not tried (cf work of Capretta
17:32:24 <vixey> Once upon a time, in the year two thousend and two of the Lord, on a
17:32:24 <vixey> fair Spring afternoon, King Haskell of Glasgow, regent of great
17:32:24 <vixey> countries and many subordinates (including the Hackers in the Great
17:32:24 <vixey> Green Forests), owner of great treasures, old and powerful scripts and
17:32:24 <vixey> uncountable lines of code, fell deeply in love with Miss Agda
17:32:45 <roconnor> > (4*60+38)*1.027
17:32:46 <lambdabot>  285.506
17:32:57 <roconnor> > ((4*60+38)*1.027)/60
17:32:58 <lambdabot>  4.758433333333333
17:34:48 <dons> who's the haddock maintainer?
17:36:13 <NameAlreadyInUse> how can i make this "avg a = (sum a / length a)" work if lenth is always Int?
17:36:30 <dons> sum a / fromIntegral (length a)
17:36:32 <vixey> you could use fromIntegral.length
17:36:51 <NameAlreadyInUse> ok, thanks
17:36:52 <dons> NameAlreadyInUse: then read http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16  :)
17:36:53 <lambdabot> Title: Haskell hacking
17:37:46 <gwern> dons: waern, iirc
17:37:48 <NameAlreadyInUse> is there any reason why Int can't be used to divide? i mean, i thought it would automatically cast
17:38:01 <vixey> there is no casting in haskell
17:38:17 <NameAlreadyInUse> not like in C
17:38:35 <NameAlreadyInUse> but why can't this work: Float / Int?
17:38:41 <vixey> it can
17:38:47 <NameAlreadyInUse> :o
17:38:49 <vixey> you may replace / with something else
17:38:54 <dons> :t (/)
17:38:56 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:38:57 <vixey> the default / doesn't work like that though
17:39:01 <dons> requires the two arguments to be of the same type
17:39:15 <dons> you can define one that coercses arbitrary types, but that's a bit unhaskelly
17:39:52 <dbueno> :t div
17:39:54 <lambdabot> forall a. (Integral a) => a -> a -> a
17:40:02 <dmwit> There's also genericLength.
17:40:05 <dmwit> :t genericLength
17:40:06 <lambdabot> forall b i. (Num i) => [b] -> i
17:40:22 <dons> > sum [1..10] / genericLength [1..10]
17:40:23 <lambdabot>  5.5
17:40:27 <NameAlreadyInUse> i see the advantages of being strongly typed, but surely it couldn't hurt to allow the default / to work on two different number types?
17:40:34 <mauke> NameAlreadyInUse: eww
17:40:35 <dons> it uses the type context to work out what return type for length you want
17:40:52 <vininim> coercion in / is source of many subtle bugs
17:40:55 <dons> NameAlreadyInUse: the risk is silent errors making it through to runtime
17:40:59 <vininim> (implicity)
17:41:22 <NameAlreadyInUse> oh, so genericLength would that be a better method than "fromIntegral (length a)"?
17:41:32 <dons> ?src genericLength
17:41:32 <vixey> genericLength = fromIntegral . length
17:41:33 <lambdabot> genericLength []    = 0
17:41:33 <lambdabot> genericLength (_:l) = 1 + genericLength l
17:41:38 <dons> well, kinda.
17:41:45 <dcoutts> vixey: erm, no
17:41:52 <vixey> :t fromIntegral
17:41:54 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:42:06 <vixey> they have the same type, how can they be different?
17:42:07 <dcoutts> vixey: genericLength will work with lazy integers for example
17:42:09 <mauke> I strongly prefer fromIntegral . length here
17:42:13 <dons> :t genericLength
17:42:16 <lambdabot> forall b i. (Num i) => [b] -> i
17:42:16 <vixey> oh I see
17:42:19 <dons> different types.
17:42:23 <vininim> @qt genericLength = fromIntegral . length -- =P
17:42:24 <gwern> @freshname
17:42:25 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
17:42:25 <lambdabot>  Press `:help' for help or `:quit' to quit.
17:42:25 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
17:42:25 <lambdabot>  > > >
17:42:25 <lambdabot> Hal
17:42:34 <vixey> :t fromIntegral . length
17:42:36 <lambdabot> forall b a. (Num b) => [a] -> b
17:42:47 <vixey> it's the same type dons
17:43:00 <dcoutts> eg, with lazy integers you can ask genericLength [1..] >= 4 and have it be True rather than _|_
17:43:05 <vixey> did anyone ever use lazy integers?
17:43:36 <dcoutts> vixey: turns out to be very useful in a few niche applications
17:43:39 <gwern> @figlet foo
17:43:39 <lambdabot> Couldn't run the figlet command.
17:43:43 <MyCatVerbs> vixey: sure, any old unary representation will do.
17:43:45 <vixey> I've never seen it
17:45:03 <dcoutts> vixey: see Modular Lazy Search for Constraint Satisfaction Problems
17:46:18 <dcoutts> in the acknowledgement they say they are particularly indebted to Colin Runciman for suggesting that they view the problem of `failFirst0` as a symptom of inadequately lazy integer arithmetic.
17:46:40 <dcoutts> and they fix it using a lazy Num instance to give an elegant solution
17:47:17 <jaj> lazy numbers, sounds great
17:47:23 <gwern> @doce
17:47:23 <lambdabot> Maybe you meant: dice docs
17:47:23 <gwern> @dice
17:47:23 <lambdabot> unexpected end of input: expecting number
17:48:13 <gwern> @dice 2
17:48:13 <lambdabot> 2 => 2
17:56:15 <vixey> > let x x = x in x 0
17:56:16 <lambdabot>  0
17:57:28 <ddarius> :t let x y = y x in x
17:57:30 <lambdabot>     Occurs check: cannot construct the infinite type:
17:57:30 <lambdabot>       t = (t -> t1) -> t1
17:57:30 <lambdabot>     Probable cause: `y' is applied to too many arguments
17:58:07 * ddarius could probably find a use for that type.
17:58:48 <vixey> I forgot what's wrong with infinite types
17:58:51 <vixey> (if anything)
17:58:57 <vixey> I mean infinite data is ok..
17:59:15 <ddarius> vixey: Nothing in theory.  In practice it would lead to many erroneous programs getting insane types rather than type errors.
17:59:19 <vixey> I guess it just makes typechecking/reconstruction really hard
17:59:29 <vixey> oh, that makes sense a bit more, yeah
17:59:40 <mauke> just use ocaml -rectypes
17:59:44 <ddarius> vixey: No, you have to go out of your way to avoid infinite types.  It's exactly the occurs check in Prolog.
17:59:56 <ddarius> (which most Prolog implementations don't implement)
18:00:07 <vixey> some prologs do rational tree unification though
18:00:14 <vixey> which lets you typecheck stuff like Y
18:00:36 <vixey> (that is, if you write a typechecker in Prolog that uses the hosts unification)
18:00:47 <ddarius> I imagine that's what you get from the normal unification algorithm minus the occurs check.
18:01:12 <ddarius> In a strongly normalizing language, such types would be a problem.
18:01:15 <vixey> you usually just get infinite loops, I'm not sure how to do the proper cyclic unification
18:02:34 <vixey> ddarius: that's what confused me about coinductives
18:03:07 <ddarius> "normal unification algorithm" for me means what's actually implemented, not that crap with substitutions.
18:03:25 <vixey> huh :[
18:03:29 <vixey> I used substitutions
18:03:39 <vixey> I just follow herbrands algorithm
18:04:05 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
18:04:08 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:04:41 <mauke> @where infinite
18:04:41 <lambdabot> I know nothing about infinite.
18:04:56 <mauke> @where+ infinite http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
18:04:56 <lambdabot> I will never forget.
18:05:01 <dmwit> "Just about every dumb change I could think of... resulted in what would be a type-correct function." =P
18:05:39 <mauke> preflex: store infinite-types http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
18:05:40 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:06:10 <vixey> oh
18:06:18 <vixey> -> is not coinductive, so that's ok
18:06:28 <vixey> you can't make x = (x -> x) or anything like that
18:19:34 <Maciej> Where can I find a more descriptive list of the commands provided by lambdabot? I only found that summary: http://code.haskell.org/lambdabot/COMMANDS
18:20:09 <vixey> Maciej: lambdabot source code
18:20:12 <vixey> ?where lambdabot
18:20:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:20:30 <vixey> Maciej: also the  commands are listed on the site (breifly)
18:20:45 <vixey> the src is quite readable though
18:21:42 <vixey> @help list
18:21:43 <lambdabot> list [module|command]
18:21:43 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
18:22:02 <Maciej> vixey: Is there no detailed documentation? E.g. what means "slap"?
18:22:10 <vixey> @help slap
18:22:11 <lambdabot> slap <nick>. Slap someone amusingly.
18:22:28 <Maciej> Ah
18:22:52 <Achilles> slap <Achilles>
18:22:56 <Achilles> :P
18:23:13 <vixey> you must use @ before if you want to be slapped
18:23:30 <Achilles> no i don't wanna
18:23:31 <Achilles> :P
18:23:39 <NameAlreadyInUse> @slap Achilles
18:23:39 * lambdabot hits Achilles with an assortment of kitchen utensils
18:23:43 <dobblego> chicken
18:23:46 <mauke> @yow
18:23:47 <lambdabot> Look!  A ladder!  Maybe it leads to heaven, or a sandwich!
18:24:01 <Achilles> errmm
18:24:03 <Achilles> ok
18:24:10 <Achilles> u all are a regular comedians :P
18:25:05 <mauke> @yow
18:25:05 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes JUST
18:25:06 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
18:25:06 <NameAlreadyInUse> why are negative exponents not allowed?
18:25:14 <mauke> they are, just not with ^
18:25:16 <Achilles> does anyone here have knowlege of haskell? :)
18:25:17 <vixey> > 2 ** (-1)
18:25:19 <lambdabot>  0.5
18:25:23 <mauke> > 2 ^^ (-1)
18:25:24 <lambdabot>  0.5
18:25:28 <NameAlreadyInUse> oh, ok
18:25:30 <mauke> > 2 ^^ (-1) :: Rational
18:25:31 <lambdabot>  1%2
18:25:35 <gwern> @seen Cale
18:25:35 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
18:25:40 <vixey> Achilles: yes
18:25:48 <NameAlreadyInUse> oh, works now
18:25:50 <NameAlreadyInUse> thanks
18:25:53 <mauke> preflex: seen Cale
18:25:53 <preflex>  Cale was last seen on #haskell 58 minutes and 3 seconds ago, saying: What were the updates btw?
18:25:55 <gwern> Cale: I've got another 19 patches inbound for you
18:26:03 <Cale> gwern: cool
18:26:10 <gwern> where's preflex's code?
18:26:20 <Achilles> because i have to write some simple program, and i can't even start the program right :P
18:26:33 <mauke> http://mauke.ath.cx/preflex/
18:26:40 <lambdabot> Title: Index of /preflex
18:26:48 <mauke> @seen me
18:26:53 <Cale> Achilles: Almost everyone here has some knowledge of Haskell.
18:26:54 <lambdabot> I haven't seen me.
18:27:05 <Achilles> me excluded :P
18:27:14 <Cale> Achilles: (just ask questions and we'll be happy to help out)
18:27:21 <gwern> mauke: lgpl?
18:27:38 <Achilles> ok
18:27:43 <mauke> my default license
18:27:54 <gwern> a strange one
18:28:08 <gwern> mauke: so what is it using for evaluation?
18:28:24 <mauke> the calculator is in ext/wcalc.c
18:28:31 <Achilles> i have to write a function that gets the number of even numbers from list higher than some value u get by a parameter
18:28:54 <Achilles> does that make any sense? :P
18:29:01 <Cale> Achilles: Okay. Yes, I think it does.
18:29:11 <Cale> Achilles: Do you know about filter?
18:29:34 <Achilles> let's say i learned about haskell five minutes ago :)
18:29:42 * vixey laughs at the comments
18:29:56 <mauke> how dare you!
18:29:59 <gwern> mauke: ...you're using C?
18:30:08 <mauke> of course! it's the language of champions
18:30:14 <Achilles> and btw, i can't use any existing functions
18:30:39 <Cale> Okay, well, one of the basic important functions in Haskell is the filter function, which takes a predicate (which is a function that takes a value and gives a Bool, that is, True or False), and a list, and gives the list of elements from that list for which the predicate gives True
18:30:45 * gwern begins wondering whether I want to hack on preflex. written in C, under the LGPL...
18:30:59 <mauke> most of it is in haskell
18:31:07 <Cale> > filter (isLower) "aBcdEfgh"
18:31:09 <lambdabot>  "acdfgh"
18:31:10 <mauke> (it's also my first IRC bot)
18:31:24 <gwern> mauke: there's a saying about a mostly wine vat...
18:31:27 <gwern> @quote wine
18:31:27 <lambdabot> simonpj says: If you put a spoonful of sewage into a vat of wine, what do you have? A vat of sewage.
18:31:33 <mauke> > filter even [1 .. 10]
18:31:35 <lambdabot>  [2,4,6,8,10]
18:31:35 <Cale> > filter (<= 20) [1,5,30,2,42,6,1]
18:31:36 <lambdabot>  [1,5,2,6,1]
18:31:59 <NameAlreadyInUse> how would you combine both filters?
18:32:04 <NameAlreadyInUse> or would you filter the filtered list?
18:32:06 <mauke> gwern: well, wcalc.c is older than the rest of this code
18:32:11 <mauke> NameAlreadyInUse: right
18:32:24 <Achilles> hmm, i think i'm not allowed to use that kind of function
18:32:35 <mauke> Achilles: you can write it yourself
18:32:45 <Achilles> that's the general idea
18:32:50 <Achilles> but how
18:32:52 <Achilles> :P
18:32:59 <Cale> Well, first of all,
18:33:02 <mauke> pattern matching, structural recursion, etc
18:33:09 <Cale> filter p [] = ...
18:33:12 <Cale> filter p (x:xs) = ...
18:33:19 <hpaste>  Tigran pasted "Instance of Show for pointless functor mess" at http://hpaste.org/8248
18:33:27 <Cale> We'll break the definition into cases depending on whether the list is empty or not.
18:33:42 <Achilles> ok
18:33:49 <mauke> gwern: maybe I can come up with a functional implementation of wcalc's parsing algorithm
18:34:02 <Cale> In the case that the list is empty, the answer for what the result should be is easy
18:34:06 <Cale> (what is it?)
18:34:09 <Achilles> 0
18:34:15 <Achilles> :P
18:34:25 <Cale> For filter, or your function?
18:34:44 <Achilles> for filter
18:34:49 <mauke> 0 is not a list
18:34:57 <Cale> Well, filter is going to produce a list, so...
18:35:30 <Cale> It must be the empty list.
18:35:31 <ralphtq> I have a question about QuickCheck
18:35:46 <Cale> So we have filter p [] = []
18:36:06 <ralphtq> Anyone know if quickCheck2 is part of GHC soon
18:36:11 <Achilles> right, right
18:36:21 <ralphtq> I need quickCheckWith
18:36:32 <Cale> Now, the more interesting case is what the result is when the list is some nonempty list (x:xs) -- if you're unfamiliar with that notation, that's the list whose first element is x, and whose tail is xs
18:36:33 <gwern> ralphtq: seems unlikely, I don't think qc2 has even been officially released
18:36:39 <gwern> and it'll break alot of code too.
18:36:46 <Cale> > let (x:xs) = [1,2,3,4,5] in (x,xs)
18:36:48 <lambdabot>  (1,[2,3,4,5])
18:37:32 <ralphtq> gwern: thanks for replying - what would you advise on changing the number of tests that are run
18:37:44 <Achilles> so with that u fill the list with 1-5 number
18:37:48 <gwern> ralphtq: 100 isn't enough?
18:37:49 <Cale> If p x is True, we want x to be part of the result, and if p x is False, we want to ignore x
18:37:50 <Achilles> ?
18:38:11 <Cale> Achilles: That was an example to show how (x:xs) matches the list [1,2,3,4,5]
18:38:20 <Cale> x gets bound to the 1 at the start
18:38:21 <ralphtq> gwern: I am generating 100,000's of tests
18:38:25 <Cale> and xs is bound to [2,3,4,5]
18:38:42 <gwern> ralphtq: I dunno. I use quickCheckWith in some of my unreleased code because I have lots of bleeding edge stuff like qc 2 installed
18:38:51 <gwern> why not just install it yourself instead of waiting for ghc?
18:38:54 <ralphtq> gwern: I could just pulldown the source code of qc2?
18:39:03 <Cale> Note that [1,2,3,4,5] is really syntax sugar for 1 : (2 : (3 : (4 : (5 : []))))
18:39:09 <Cale> > 1 : (2 : (3 : (4 : (5 : []))))
18:39:11 <lambdabot>  [1,2,3,4,5]
18:39:12 <gwern> ralphtq: sure
18:39:20 <gwern> ralphtq: darcs get http://code.haskell.org/QuickCheck
18:39:20 <lambdabot> Title: Index of /QuickCheck
18:39:21 <ralphtq> gwern: so you downloaded the source of qc2?
18:39:41 <Cale> Every list in Haskell is either [], or it's something of the form x : xs, where x is an element, and xs is another list (of elements of the same type)
18:39:54 <Achilles> ok
18:39:57 <ralphtq> gwern: great - I am in US where are you?
18:40:10 <gwern> it should download wherever
18:40:19 <gwern> I think galois hosts it in portland, but I wouldn't swear to't
18:40:37 <ralphtq> gwern: thanks - will go for qc2
18:40:40 <Cale> Achilles: Would you like to move to #haskell-overflow? It might make things easier to follow
18:40:59 <Achilles> ok
18:42:52 <lvhuashu2008> è¿™ä¹ˆå¤šäººï¼Ÿ
18:43:07 <Achilles> i know that i can type a number in a variable by var <- readLn
18:43:27 <Cale> Achilles: Are you going to join #haskell-overflow ?
18:45:02 <shapr> I guess lvhuashu2008 isn't learning Haskell...
18:45:47 <vixey> they are now
18:45:48 <vixey> :)
18:46:41 <atp> lvhuashu2008: æœ€å¥½ä¸è¦ç”¨ä¸­æ–‡ï¼Œèƒ½æ‡‚çš„äººæ¯”è¾ƒå°‘ï¼Œè¿˜æ˜¯è‹±æ–‡å¥½ï¼Œè°¢è°¢
18:47:14 <shapr> I think he's gone.
18:47:19 <atp> oh, i missed thta.
18:47:20 <atp> that.
18:47:23 <vixey> aww
18:47:28 <vixey> I wish I could learn japanese
18:47:33 <shapr> You can.
18:47:35 <vixey> I tried hebrew but it's too hard
18:47:41 <atp> that was chinese actually....
18:47:46 <vixey> shapr, I don't know about that.. I am trying though
18:47:58 <vixey> atp, weird.. my google japanese -> english accepts it
18:48:23 <atp> that's probably because japanese has a lot of chinese loan words
18:48:38 <atp> nonetheless, it's chinese
18:48:41 <atp> trust me
18:48:59 <OceanSpray> what would a 1-tuple be useful for?
18:49:12 <vixey> OceanSpray passing values around
18:49:23 <OceanSpray> how about 0-tuples?
18:49:28 <ddarius> ()
18:49:34 <dobblego> the unit value
18:49:38 <vixey> for when you have nothing useful to sy
18:49:45 <vixey> that's when () is good
18:55:37 <vixey> that CSP paper was very very neat
18:55:46 <MyCatVerbs> Would it be considered a sign of bad design when writeChan foo () -- actually does something fairly important?
18:56:06 <ddarius> No.
18:56:13 <MyCatVerbs> Because I've done that before. Mind, that was definately not the -worst- thing in that system.
18:56:39 <ddarius> putMVar mvar () can be very important
18:57:05 <MyCatVerbs> The worst thing in there was probably an awful lot of invokations via System.Process when I -really- ought to have instead learned to use the FFI and written all those helpers as C libraries instead.
18:59:50 <atp> why would you want to write helpers as C processes?
19:00:20 <atp> besides being unsafe, FFI is also not free, performance-wise... in many cases, I don't think you really gain much.
19:01:58 <Cale> atp: Sometimes for an inner-loop sort of thing, you might consider it as an option for writing something very low-level, but it's getting easier these days to write low-level code in Haskell instead.
19:05:13 <MyCatVerbs> atp: because the code wouldn't actually gain anything from being written in Haskell.
19:06:13 <MyCatVerbs> atp: the level of abstraction involved was negligible. It wasn't anything complicated, just a bit heavy on the ol' casting between integer types.
19:07:50 <atp> i don't know, i see FFI sort of the same way i see inline assembly in the C context
19:08:06 <atp> the lack of clarity doesn't really gain you much 99% of the time
19:08:09 <atp> but there is that 1%
19:09:16 <MyCatVerbs> Doing it -now-, I'd probably end up doing it in uvector instead.
19:10:00 <MyCatVerbs> It's the sort of thing where there's not much point using anything other than either uvector or straight C. All pushing int16_ts around that represent PCM samples.
19:15:23 <jre2> how well should ghc handle ~7 threads mostly waiting on readTChan and hGetString (via a socket)?
19:15:46 <MyCatVerbs> jre2: beautifully.
19:16:24 <jre2> are there particular options I should feed to ghc or my program when compiling/running?
19:17:22 <MyCatVerbs> Compile with -threaded if you want to use the threaded VM, and run with +RTS -N 2 -RTS (or some other value than 2) if you want to take advantage of multiple CPUs.
19:18:29 <MyCatVerbs> If you don't actually care about the CPU time (it sounds like your app won't) then you don't even need -threaded, AFAIK, provided you're waiting on Handles and MVars/Chans/SampleVars, etc.
19:19:03 <MyCatVerbs> It'll just compile down to something that acts vaguely like a big ol' event loop, in the end.
19:19:35 <jre2> right now it takes ~8.1s to go through 100 ticks, where a tick is collecting 1 message from each of 2 clients and sending them each back a message
19:19:49 <mauke> can someone tell lambdabot to join #yapc?
19:20:05 * Achilles laughs
19:20:20 <vixey> what's that?
19:20:28 * Achilles cries
19:20:33 <vixey> perl compiler?
19:20:35 * Achilles cries like a baby
19:20:46 <Achilles> :P
19:25:13 <MyCatVerbs> jre2: what percentage of the CPU does it use while it's doing that?
19:25:34 <vixey> mauke,
19:25:57 <MyCatVerbs> jre2: If I were you and it was eating CPU, I'd hit it with the profiler to see where it's spending the time prior to turning -threaded on... since the profiler and the threaded RTS don't play nicely together.
19:28:31 <jre2> doesn't use much cpu, but I'm not sure why
19:29:18 <seanmce> Is there a LINQ-like library for haskell?
19:31:58 <shapr> The community on #haskell is really great. Even #emacs can be a painful place at times.
19:32:21 <hpaste>  Achilles pasted "something not working stuff" at http://hpaste.org/8249
19:34:49 <ddarius> seanmce: LINQ is modelled after monads...
19:35:37 <seanmce> yes, but has anyone done a haskell library?
19:35:52 <ddarius> That does what?
19:36:15 <seanmce> compile time checked typed sql
19:36:26 <seanmce> instead of just passing a string to the db
19:36:58 <ddarius> seanmce: That's not what LINQ does, but yes there are a variety of DB interfaces that take an approach similar to that.
19:37:55 <seanmce> I haven't used linq, but that's what I thought it was. what haskell libraries can I look at?
19:38:17 <hpaste>  dibblego annotated "something not working stuff" with "(no title)" at http://hpaste.org/8249#a1
19:39:14 <ddarius> http://www.haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
19:39:15 <lambdabot> Title: Applications and libraries/Database interfaces - HaskellWiki, http://tinyurl.com/2kvjne
19:42:47 * ddarius has a Î»^â†’ to S^â†’ and back translator.
19:43:23 <vixey> actually what are those languges?
19:43:40 <vixey> infact easier might be is the code around ?
19:43:44 <ddarius> The simply typed lambda calculus and the spine calculus.
19:43:54 <vixey> I have never heard of spine calculus
19:44:04 <ddarius> That's not surprising.
19:44:28 <ddarius> It's just a different "notation" for (linear) lambda terms that's useful for certain operations such as unification.
19:46:37 <ddarius> It does have a strong justification though as the proof terms of a uniform proof system for linear logic.
19:48:07 <ddarius> That fact isn't of much use though unless you are writing a theorem prover or a logical framework.  In particular, it doesn't mean anything for a logic programming language.
19:48:20 <vixey> aww
19:52:32 <hpaste>  morrow pasted "callCC in javascript" at http://hpaste.org/8250
19:52:47 <OceanSpray> what does that * in front of the prompt in ghci mean?
19:54:07 <vixey> morrow: What's abort?
19:54:10 <vixey> aeou
19:54:22 <vixey> oh it's right there, sorry :/
19:56:20 <ddarius> Incidentally, implementing type inference/checking for linear spine terms is exactly the opposite of what evaluation of linear logic code would have to do.
19:56:55 <ddarius> I guess I could validate my implementation that way.
19:57:29 <vixey> oh so a term in the liner logic language is basically a type?
19:57:47 <vixey> and proof search is type inhabitation (where is terms are spine terms)?
19:57:58 <vixey> (or I don't konw if proof search is even how it works...)
19:58:43 <ddarius> Yes.  Proof search is finding a term (implicitly for logic programming) that has the "type" that the logical formula represents.
20:00:10 <ddarius> If I make my linear logic implementation return the proof terms (something that would be necessary for a verifying theorem prover or logical framework), then I could type check the results to verify it's correctness.
20:00:53 <vixey> it would be cool to get refutations back but it might be really memory consuming, I'm not sure
20:01:19 <vixey> I didn't try this in Prolog before because it would mean naming all the clauses of each relation
20:02:52 <edwardk> ddarius: am i correct in my presumption that the notion of a final dialgebra in http://citeseer.ist.psu.edu/backhouse99final.html cannot be meaningfully be defined for F,G-dialgebras from Hask to Hask?
20:02:53 <lambdabot> Title: Final Dialgebras: From Categories to Allegories - Backhouse, Hoogendijk (Researc ...
20:03:32 <Korollary> Oh. More globetrottery and improvised jazz.
20:03:40 <edwardk> Korollary: =)
20:04:04 <vixey> hehe
20:04:17 <edwardk> Korollary: my current goal is to gather up as much of this as I can to try to get the 'state of the art' all in one place moreso than to show off ;)
20:04:39 <vixey> I love it I am learning very small things
20:04:43 <vixey> very occasionally
20:04:45 <vixey> :p
20:06:15 <slavik> how come n*head(func(n-1)):ï»¿(func(n-1)) is fine, but (func(n-1)):n*head(func(n-1)) is not?
20:06:24 <Lycurgus> that place being?
20:06:35 <vixey> slavik: The second is a type error
20:06:56 <vixey> slavik: in general, a : b and b : a are different
20:07:07 <slavik> because haskell expect element:list ?
20:07:17 <vixey> and unless a = b = [], only one of them can typecheck
20:07:20 <edwardk> slavik: (:) has different types for the head and the tail, the head is an element, the tail is a list.
20:07:22 <vixey> (or undefined)
20:07:25 <ddarius> edwardk: Obviously the notion isn't completely vacuous as final coalgebras are included.
20:07:26 <Lycurgus> (leaving aside the fact that the state of the art for any scientific discipline is in the body of it's peer reviewed journals)
20:07:37 <edwardk> ddarius: sure, but i mean non-trivial cases
20:07:46 <slavik> edwardk: I see
20:07:47 <vixey> element:list is expressed in haskell as:  (:) :: a -> [a] -> [a]
20:07:56 <edwardk> ddarius: i can't come up with anything bigger than just the final coalgebras
20:08:03 <slavik> vixey: thanks
20:08:18 <edwardk> ddarius: its like maarten fokkinga's dyads. I can't come up with ANY that arent monads or comonads.
20:08:19 <ddarius> "dianamorpism", nice
20:08:25 <slavik> another question, in the above list will (func(n-1)) be evaluated twice or is haskell smart enough to do it once?
20:08:48 <vixey> who can tell? :)
20:08:52 <edwardk> ddarius: in fokkinga's case i think his distributive law (as a natural isomorphism) is too strong for any to exist.
20:09:00 <slavik> not me, hence the question :)
20:09:11 <vixey> if you want to ensure it is done once you could write
20:09:16 <ddarius> edwardk: Do any of the examples that are actually dialgebras translate?
20:09:16 <vixey> let x = func (n-1) in ...
20:09:24 <vixey> & use x in there instead of func
20:09:29 <slavik> I see
20:09:47 <edwardk> the only examples in the paper are the final coalgebra, and a couple of things that use non-Hask-like shape categories.
20:10:29 <dfrey> is it possible to do something like "import qualified Data.List(foldl') as L" or was that considered pointless since you are qualifying the name?
20:10:29 <slavik> let x = func(n-1) in func n = if (n == 1) then [1] else n*head(x):(x)
20:10:32 <slavik> like that?
20:10:44 <edwardk> i tried to fit any of martin erwig's trialgebras to it (using their dialgebra half) and none of those worked out either.
20:10:50 <jre2> MyCatVerbs: hmm, I recompiled my libraries (since I stupidly forgot to enable profiling originally) and apparently the speed problem fixed itself. Went from ~8.5sec to ~0.5s (and probably lower if I removed a little debuging output)
20:11:04 <vixey> slavik: those ()'s are extraneous and look pretty weird
20:11:10 <vixey> I'd write
20:11:20 <vixey> let x = func (n-1) in func n = if n == 1 then [1] else n*head x:x
20:11:22 <ddarius> edwardk: Don't natural numbers form a dialgebra?
20:11:26 <edwardk> and messing with it in my head and on paper any candidate seems to need a kind of inverse functor for one side of the dialgebra to make sense anyways.
20:11:33 <slavik> well, the only other 'functional' language I've come across was Scheme :P
20:11:48 <vixey> paranthesis are just a syntax thing in haskell
20:11:55 <edwardk> ddarius: i have a ton of dialgebras, i just can't seem to define a meaningful 'final dialgebra'
20:11:56 <vixey> they don't actually have any meaning
20:11:57 <slavik> <interactive>:1:29: parse error on input `='
20:12:17 <jre2> MyCatVerbs: scratch that, I accidently changed my code to only wait for 1 client
20:12:24 <slavik> it doesn't like the = in func n =
20:12:34 <mrd> its not correct
20:13:52 <mrd> maybe you meant ; instead of 'in'
20:14:04 <vixey> well func n =
20:14:10 <vixey> is like (define (func n) ...
20:14:17 <vixey> you put the let after/inside it
20:15:04 <slavik> right, but ghci (6.8) gives an error
20:15:30 <gwern> for every normal algebraic solution, there is a final solution?
20:15:32 <vixey> for what code and what error?
20:15:34 <edwardk> i mean i can write it out on paper, but the properties of it don't seem to give rise to any definitions in haskell. the type would have to look like outD :: f  (FD f g) -> g (FD f g) such that diana :: Bialgebra f g a) -> a -> FD f g -- where type Bialgebra f g a = f a -> g a
20:15:51 <slavik> vixey: the line you wrote, and the error I pasted
20:16:06 <mrd> in ghci you must use: let func x = ...
20:16:13 <vixey> no what I wrote is not correct code
20:16:14 <edwardk> er that is diana :: Bialgebra f g a -> a -> FD f g
20:16:18 <slavik> ahh
20:16:24 <edwardk> er Dialgebra
20:16:34 <mrd> > let x = 1; y = 2 in x + y
20:16:36 <lambdabot>  3
20:17:13 <ddarius> Bah, natural numbers are the initial dialgebra of Fa = (1,a) and Ga = (a,a) where F -> G
20:17:21 <slavik>  let x = func (n-1) in func n = if n == 1 then [1] else n*head x:x
20:17:45 <edwardk> *nods*
20:18:06 <ddarius> edwardk: Look at Hagino's thesis.
20:18:43 <edwardk> ddarius: url?
20:19:04 <ddarius> http://www.tom.sfc.keio.ac.jp/~hagino/thesis.pdf
20:19:13 <edwardk> much obliged
20:19:59 <ddarius> I'm not sure if there will be an example there, but it should at least give you some ideas to work with.
20:20:29 <edwardk> ddarius: i've actualy read through it before on a couple of occasions
20:20:47 <ddarius> I'd've been surprised if you hadn't.
20:20:58 <ralphtq> Help needed - I am on a Windows machine (regrettably) - installed PuTTY and trying to run darcs - having a problem authenticating at code.haskell.org - any ideas?
20:23:35 <ralphtq> I do an ssh to a preconfigured session - I login as anonymous - it asks for a password - hitting enter did not work
20:23:45 <mmorrow> heh, you're in for it
20:24:08 <edwardk> ddarius: anyways i had some hope that the dianamorphism stuff would work after getting synchromorphisms to finally click into place the other day
20:24:39 <mmorrow> (as i found out) all keys were revoked due to some vulnerability in debian's rng
20:24:56 <mmorrow> so you have to submit a new key (dsa *or* rsa)
20:25:21 <mmorrow> i emailed the support link
20:25:27 <mmorrow> you should too
20:25:36 <edwardk> aha i think i have an idea
20:26:11 <mmorrow> ralphtq: .
20:26:36 <ralphtq> mmorrow: ?
20:27:05 <edwardk> using the same existential encoding that you can use for the final coalgebra
20:27:07 <mmorrow> ralphtq: re: ssh'ing into c.haskell.org
20:27:12 <mmorrow>  (as i found out) all keys were revoked due to some vulnerability in debian's rng
20:27:17 <mmorrow> ...
20:27:48 <mmorrow> support [AT] community.haskell.org
20:28:33 <ralphtq> mmorrow: I'll email support
20:29:54 <mmorrow> ralphtq: :)
20:30:23 <edwardk> and that encoding makes sense as a Colimit (Dialgebra f g)
20:33:26 <edwardk> hrmm maybe not
20:33:40 <Saizan_> ralphtq: you login as anonymous? you should use the user you choose when submitting the request
20:38:54 <bos> CUFP videos on Google Video now: http://www.reddit.com/r/programming/info/6mvel/comments/
20:38:54 <lambdabot> Title: programming: CUFP 2007 sessions now up on Google Video: Haskell, Erlang, F#, oh  ...
21:05:12 <fUD> Hey
21:05:42 <vixey> hi
21:06:11 <fUD> Do you think its worth looking at erlang or haskell?
21:06:19 <vixey> yes
21:06:34 <fUD> I mean which one?
21:06:35 <fUD> :)
21:07:03 <PHO_> java.
21:07:05 <Saizan_> it depends, what are you looking for?
21:07:07 <fUD> LOL
21:07:12 <PHO_> I just wrote a function whose type is "(forall s. Constraints s -> (forall w. Widget w => w -> ST s (Constraints s)) -> ST s ()) -> SpringLayoutWidget" and got shocked because it just compiled and worked as I expected...
21:07:37 <vixey> PHO_: What are you programming?
21:07:46 <fUD> I did do some haskell at uni, and bought the erlang book but haskell seems alot better syntax wise
21:07:58 <vixey> fUD: syntax doesn't really matter
21:08:01 <PHO_> vixey: I'm writing a new widget library for HSCurses
21:08:17 <fUD> vixey: well it does when your writing in it :)
21:08:27 <vixey> I don't find that
21:09:00 <solrize> fud, imho erlang is fairly primitive compared with haskell, but it's easier to learn and has better library support for distributed programming
21:09:15 <cdsmithus> Okay, next time I try to give an introductory one-hour user group talk on haskell, someone tell me to leave more stuff out.
21:09:28 <solrize> cdsmithus :)
21:09:38 <Korollary> cdsmithus: what can you fit in one hour anyway
21:09:56 <cdsmithus> Korollary: A lot, if you don't care what the audience understands.
21:09:58 <dons> cdsmithus: how far did you get?
21:10:03 <dons> ah
21:10:05 <fUD> solrize: Well erlang seemed like the lang of the day, but when I checked it out I thought the Haskell I learnt at uni was better
21:10:22 <cdsmithus> dons: I got through about the first half before I just started skimming to get to the demo.
21:10:28 <PHO_> erlang is indeed easier than haskell but using it is very frustrating, because
21:10:40 <vixey> fUD: that suggests that you should just continue with haskell
21:10:46 <PHO_> erlang has neither mutable variable nor IO monad.
21:11:27 <solrize> well it has per-process mutable variables and it has effectful functions
21:11:38 <Korollary> cdsmithus: SPJ's talk at OOPSLA(?) was about 2 hours, and the audience didn't really get it imho.
21:11:39 <solrize> hedgehog lisp gets by with just effectful functions
21:11:52 <bos> so. my eensy weensy mapreduce example for the book works really nicely.
21:11:55 <dons> Korollary: at OSCON
21:11:58 <Korollary> ah yes
21:12:02 <dons> bos, awesome.
21:12:03 <fUD> Well I looked at the language shootout and it seems haskell is much faster erlang, I guess erlangs power lies in distributed processing
21:12:03 <Korollary> O-something heh
21:12:13 <dobblego> Erik Meijer tried in 1 hour at a conference recently
21:12:21 <bos> i can chew through hundreds of megabytes of data per second, getting a speedup of 1.8x on a dual core box.
21:12:24 <PHO_> per-process mutable variables are global! not local! I hate global variables!
21:12:30 <cdsmithus> Well, I'm feeling quite discouraged.  I think I'll just sleep and hope the morning is better.
21:12:37 <solrize> bos, cool, aren't you going to call it LiftFold instead though?  ;-)
21:12:40 <dons> fUD: it is faster. a lot more optimisations you can do on statically typed, pure code.
21:12:45 <dons> cdsmithus: small steps, small steps.
21:12:55 <dons> let's hope the ACM starts pushing for more FP in the undergrad curriculum
21:13:29 <cdsmithus> dons: Thanks for the encouragement. :)
21:13:42 <Korollary> In any talk about FP, I feel like I have to explain LC a bit because people don't really fathom how FP is turing complete otherwise.
21:13:54 <solrize> LC?
21:13:58 <Korollary> lambda calc
21:14:01 <cdsmithus> In the morning, I'll watch the video of my talk, and decide whether to claim technical difficulties.
21:14:31 <dons> Korollary: oh, "what, all you have is functions? wtf?!"
21:14:49 <solrize> korollary i think you can just show how to use tail recursion for loops and then the turing completeness is obvious
21:14:50 <Korollary> which is not that trivial to see actually
21:15:15 <solrize> LC without recursion is not turing complete
21:15:54 <cdsmithus> solrize: But LC has fixed point operators, so you get recursion for free.  It's not something you have to add.
21:15:57 <vixey> do you have a proof that untyped lambda calculus is universal?
21:16:04 <fUD> Are any of you doing web stuff with haskell?
21:16:06 <Korollary> I actually do
21:16:07 <vixey> I have found one but it's rather involved with a pretty confusing lemma
21:16:09 <dobblego> there's a good web page (or post?) somewhere explaining why loops are less preferred (bugs, etc.) to HOFs; anyone know where it is?
21:16:11 <dons> fUD: yeah.
21:16:13 <vixey> what is it?
21:16:24 <Korollary> vixey: It's in Barendregt.
21:16:26 <solrize> cdsmithus i'm thinking of typed LC
21:16:33 <cdsmithus> solrize:ah, okay
21:16:34 <vixey> m I've not read this
21:16:49 <Korollary> Barendregt is excellent. I'll find a link.
21:17:15 <solrize> vixey, look up Y combinator in wikipedia
21:17:29 <Korollary> @go introduction to lambda calculus barendregt
21:17:31 <vixey> I don't think Y has much to do with it
21:17:32 <lambdabot> http://citeseer.ist.psu.edu/barendregt94introduction.html
21:17:32 <lambdabot> Title: Introduction to Lambda Calculus - Barendregt, Barendsen (ResearchIndex)
21:18:18 <Korollary> Y has something to do with it. See chapter 3: power of lambda
21:18:21 <Armored_Azrael> vixey: The y combinator gives you anonymous recursion
21:18:54 <vixey> anonymous recursion -> every partial recursive function is lambda definable ... is a quite big gap
21:19:03 <Korollary> it's not all
21:19:38 <Korollary> which is why I said that it wasn't that obvious
21:19:43 <Armored_Azrael> ï»¿vixey: The easiest way I've found to demonstrate turing completeness of a language is to write a turing machine emulator in it. In the case of lambda calculus, it's kind of annoying to write, so I suggest you write or examine a lisp to lambda calculus interpreter and everything will fall out from there.
21:20:04 <Armored_Azrael> s/interpreter/compiler/
21:20:16 <vixey> it's quite a tedious and ugly proof though
21:20:24 <Korollary> Turing wrote that annoying TM interpreter in lambda calculus
21:20:32 <solrize> the equivalence between recursion and Y is pretty obvious i think.  the equivalence between recursion and turing machines is not at all obvious
21:20:37 <solrize> first proved in 1930's
21:21:15 <solrize> godel was pretty impressed with it, and it sold him on the idea that recursion was a good way to describe computability
21:21:38 <cdsmithus> If you're willing to go via partial recursive functions, though, rather than straight to Turing machines, then it's considerably cleaner.
21:22:23 <solrize> cdsmithus you used to have an article about operating systems, is it still around?
21:22:43 <solrize> there are still dead links to your old site all over the place :(
21:22:46 <cdsmithus> solrize: Umm, no.  And that's probably for the best.  I write it when I was 15 years old.  About 14 years ago.
21:23:02 <solrize> oh heh
21:23:03 <solrize> ic
21:23:33 <Korollary> Hey, maybe it was accurate at the time
21:27:17 <vixey> I don't understand the minimization
21:27:34 <solrize> does anyone use data.binary including the script for automatically generating Get instances?
21:31:10 <Korollary> vixey: http://en.wikipedia.org/wiki/Mu_operator
21:32:47 <dons> solrize: i use the script offline, yeah
21:42:09 <solrize> dons if i have   data Foobar = Foobar Foo Bar     where Foo and Bar are already Get instances (say with handwritten definitions), then will the derived instance for Foobar read a Foo followed immediately by a Bar?  is relying on that an ok way to parse a messy data format?
21:45:06 * ddarius could write a TM in the pure LC easily.
21:45:42 <edwardk> ddarius: figured it out
21:45:53 <ddarius> edwardk: What was the magic ju-ju?
21:46:08 <edwardk> data Diana f g = forall a. Diana (f a -> g a) a
21:46:21 <edwardk> diana :: (f a -> g a) -> a -> Diana f g; diana = Diana
21:46:46 <edwardk> strip :: (Functor f, Functor g)  => Diana f g -> Colim f -> g (Diana f g)
21:47:36 <^Someone^> All that looks kinky
21:47:38 <edwardk> strip takes a 'NuD/Diana' constructor and a 'shape' and unwraps the dianamorphism
21:47:45 <edwardk> someone: yeah =)
21:47:48 <^Someone^> Lol
21:47:55 <ddarius> Ah, yes.  I should have that about it from the perspective of representability.
21:48:00 * ddarius didn't really put much effort into it.
21:48:12 <edwardk> ddarius: no problem. took me a while, but i got there =)
21:49:11 <edwardk> A similar construction should work for dicatamorphisms in terms of universals. newtype Dicata f g = Dicata (forall a. (f a -> g a) -> a)
21:49:29 <^Someone^> What a lot there is to learn
21:49:31 <ddarius> edwardk: You do see how diana is a representation represented by Diana f g
21:49:41 <edwardk> yeah actually thats how i got there =)
21:49:50 <ddarius> Cool
21:50:24 <TomMD> Humm... I can't cabal install frag due to link errors with GLUT.  Anyone here knowledgable?  Has the API changed and the bindings not kept up-to-date?
21:50:31 <SamB> so... why do we now name types after women?
21:51:03 <ddarius> We name everything after women.
21:51:21 <ddarius> Failing that we refer to them in the feminine
21:51:29 <edwardk> another way i was thinking about going about it was expressing it as an Coend over data DianaT f g a b = DianaT (f a -> g b) b
21:51:41 <dmwit> SamB: di-ana-morphism, I guess
21:51:54 <edwardk> dmwit: yeah
21:52:12 <^Someone^> Morning, dmwit
21:52:15 <dmwit> diana, nude, co-end, backend, strip, ...
21:52:21 <dmwit> ^Someone^: 'night
21:52:31 <dmwit> ?localtime ^Someone^
21:52:32 <lambdabot> Local time for ^Someone^ is Wed Jun 11 00:52:01 2008
21:52:33 <ddarius> Dicata should give you that Nat example.
21:52:47 <edwardk> yeah
21:52:51 <fUD> co-end?
21:52:56 <edwardk> i fleshed it out on paper while eating with shapr
21:52:57 <dmwit> ^Someone^: I'm on the other coast, it's not morning here yet. =)
21:53:21 <^Someone^> That's not my time
21:53:24 <edwardk> fud: i have a post on them one sec.
21:53:39 <fUD> edwardk: k.
21:53:42 <edwardk> fud: http://comonad.com/reader/2008/kan-extension-iii/
21:53:44 <lambdabot> Title: The Comonad.Reader » Kan Extensions III: As Ends and Coends
21:53:51 <dmwit> ^Someone^: That's what your computer is reporting, might want to check into that.
21:54:03 <fUD> edwardk: I'll take a read. Cheers
21:54:07 <^Someone^> ?localtime
21:54:09 <lambdabot> Local time for ^Someone^ is Wed Jun 11 10:23:37 2008
21:54:13 <^Someone^> That's my time
21:54:14 <fUD> ?localtime
21:54:17 <lambdabot> Local time for fUD is Wed Jun 11 14:54:21 2008
21:54:25 <dmwit> ^Someone^: ...10:23?  A half-hour time-zone?
21:54:32 <dmwit> ^Someone^: Are you in Iraq or something?
21:54:36 <^Someone^> India
21:54:57 <fUD> Wow, India is that much different in time from AU
21:54:59 <dmwit> Didn't know India had half-hour time zones.
21:55:11 <^Someone^> There's only one time zone here
21:55:13 <^Someone^> This is it
21:55:20 <dmwit> nasty
21:55:27 <^Someone^> Heh, yeah
21:56:58 <fUD> India time, its done when its done?
21:57:28 <vixey> ?localtime
21:57:38 <lambdabot> Local time for vixey is Wed Jun 11 05:57:37
21:57:40 <vixey> ?localtime dmwit
21:57:41 <lambdabot> Local time for dmwit is Tue Jun 10 22:00:10
21:57:41 <shapr> @localtime
21:57:41 <lambdabot> Local time for shapr is Wed Jun 11 00:57:41 2008
21:57:47 <^Someone^> Sweden?
21:57:52 <vixey> we are spanning the globe :)
21:57:56 <shapr> Det vet jag inte.
21:58:02 <vixey> @brain
21:58:03 <lambdabot> Wuh, I think so, Brain, but burlap chafes me so.
21:58:17 <PHO_> ?localtime
21:58:17 <lambdabot> Local time for PHO_ is :æ°´, 2008/06/11 13:58:17 +0900
21:58:25 <fUD> Mizu?
21:58:31 <dmwit> heh
21:58:33 * shapr goes to sleep
21:58:39 <PHO_> sui. I'm from japan
21:58:53 <vixey> oooh
21:58:54 <fUD> Oh, suiyobi
21:58:57 <psygnisfive> i like how it says wednesday _in japanese_
21:59:09 <dmwit> psygnisfive: It's just whatever your computer reports.
21:59:18 <psygnisfive> oh? hm.
21:59:22 <dmwit> psygnisfive: You can respond *anything* to a CTCP time.
21:59:33 <dmwit> psygnisfive: You could respond with "fish" if you were feeling a bit weird.
21:59:40 <psygnisfive> well still, its interesting that his OS tracks in kanji :)
21:59:44 <vixey> I wish someone would do that
22:00:02 <psygnisfive> PHO_: what OS do you use?
22:00:07 <PHO_> NetBSD
22:00:11 <psygnisfive> oh i see
22:00:13 <PHO_> and I'm using X-chat on it
22:00:45 <fUD> People still use that?
22:00:46 * fUD runs
22:01:43 * dmwit uses Xchat
22:01:51 <fUD> I mean NetBSD
22:01:53 <fUD> :)
22:01:56 <dmwit> oh, heh
22:02:22 <cjs> Woah! Another NetBSD user!
22:02:33 <cjs> And from japan?
22:02:38 <PHO_> yes :)
22:02:39 <fUD> What esoteric h/w do you have?
22:02:40 <cjs> Am I logged in twice?
22:03:13 <PHO_> I didn't expect to find any japanese speaker here :)
22:03:16 <cjs> pc532.
22:03:28 <ddarius> @seen lambdabot
22:03:28 <lambdabot> Yes, I'm here. I'm in #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.cz, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #haskell.fr,
22:03:28 <lambdabot>  #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger,
22:03:28 <lambdabot>  #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
22:04:27 <cjs> So if I use, say, the ErrorT monad transformer, I have to lift everything I do in the other monad?
22:04:41 <fUD> pc532?
22:04:41 <mmorrow> #unicycling??
22:04:49 <cjs> Oh, wait, it looks like it works the other way around....
22:05:38 <edwardk> mmorrow: blame shapr ;)
22:05:43 <ddarius> mmorrow: Haskell and unicycling are deeply interrelated.
22:06:00 <edwardk> mmorrow: i seem to recall that he gave a talk on monads while riding a unicycle
22:06:27 <mmorrow> lol
22:07:07 <cjs> No, it looks like I do have to lift it all. That looks like a pain.
22:07:12 <mmorrow> ddarius: excellent link: http://www.tom.sfc.keio.ac.jp/~hagino/thesis.pdf , i haven't seen it before and at least once a paragraph for the first 3 pages i've been "exactly!"ing
22:07:42 <ddarius> There's a picture of SPJ on a unicycle somewhere.
22:08:28 * mmorrow goes to his closet to pull out the tricycle
22:08:39 <PHO_> lol
22:08:48 <edwardk> ddarius: shapr has it
22:09:05 <ddarius> edwardk: I know, but I thought it was somewhere handy on the internet.
22:09:14 <ddarius> Instead it's probably somewhere less handy on the internet.
22:09:33 <mmorrow> so close yet so far...
22:10:03 <edwardk> ddarius: i think it went the way of much of scannedinavian, but he's got the pic i've seen it more recently than that
22:10:13 <edwardk> er rather i think the online copy went with scannedinavian
22:13:08 <sjanssen> @yow
22:13:08 <lambdabot> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!  Equip me with MISSILES!!
22:13:34 <mrd> @yow!
22:13:34 <lambdabot> It's NO USE ... I've gone to "CLUB MED"!!
22:14:44 <mmorrow> those yows are so hillarious
22:14:58 <mmorrow> by those i mean all of them
22:16:26 <bos> dons: why does lazy ByteString hGet take an Int instead of an Int64?
22:17:02 <psygnisfive> can you define named functions with lambdas and call them like normal? e.g. foo = \n ..., foo 5?
22:17:14 <vixey> yes
22:17:36 <psygnisfive> can you use pattern matching in the lambda??
22:17:42 <vixey> yes
22:17:47 <psygnisfive> :o
22:17:49 <psygnisfive> link to refs?
22:18:02 <vixey> ?faq can haskell do pattern matching in the lambda
22:18:03 <lambdabot> The answer is: Yes! Haskell can do that.
22:18:09 <psygnisfive> ;)
22:18:16 <Saizan_> > (\(Just x) -> x) $ Just 2
22:18:18 <lambdabot>  2
22:18:24 <Saizan_> > (\(Just x) -> x) $ Nothing
22:18:24 <psygnisfive> awesome :)
22:18:25 <lambdabot>   Non-exhaustive patterns in lambda
22:18:29 <TSC``> > let f = \ [x] -> x in f [1]
22:18:30 <lambdabot>  1
22:18:40 <edwardk> ?faq can Haskell do my homework for me?
22:18:40 <lambdabot> The answer is: Yes! Haskell can do that.
22:18:53 <Axman6> it's true
22:18:55 <Saizan_> you mean #haskell ? :)
22:18:55 <PHO_> > let f = f in f
22:19:00 <Axman6> it's done mine for me a few times
22:19:03 <edwardk> saizan: lol
22:19:11 <lambdabot>  thread killed
22:19:14 <^Someone^> ?faq can Haskell eat my homework?
22:19:14 <lambdabot> The answer is: Yes! Haskell can do that.
22:19:17 <psygnisfive> what if you need multiple patterns in a lambda?
22:19:18 <PHO_> lambdabot...? you gone in an infinite loop?
22:19:19 <dons> bos, that's weird.
22:19:24 <vixey> psygnisfive: case
22:19:34 <psygnisfive> ah
22:19:36 <bos> dons: just an oversight, i guess.
22:19:39 <Axman6> ?faq monad
22:19:39 <lambdabot> The answer is: Yes! Haskell can do that.
22:19:45 <dons> i think it's an oversight, yes. i can't see any reason for it.
22:19:48 <Axman6> excelent...
22:19:52 <Saizan_> psygnisfive: \x -> case x of ...
22:20:00 <psygnisfive> ok
22:20:52 <PHO_> ?faq can Haskell do my job instead of me?
22:20:52 <lambdabot> The answer is: Yes! Haskell can do that.
22:21:06 <Elly> PHO_: you will be replaced by a very short Haskell program!
22:21:23 <Axman6> i take it lambdabot is written in haskell?
22:21:32 <PHO_> Elly: that's ok
22:21:35 <lament> lambdabot is written in a mixture of Perl and C++ template langugae
22:21:37 <lament> *language
22:22:12 <Axman6> mmj
22:22:14 <Axman6> k*
22:22:15 <vixey> no it's written in haskell
22:22:26 <Elly> vixey: I think lament's answer is funnier :)
22:22:44 <ddarius> Compiled by GHC, a mixture of Perl, C and Lazy ML.
22:23:20 <Elly> "Lazy ML"?
22:23:53 <ddarius> I believe it goes like this: hbc was used to bootstrap ghc and lml was used to bootstrap hbc
22:24:21 <^Someone^> ?faq Are you written in Haskell?
22:24:21 <lambdabot> The answer is: Yes! Haskell can do that.
22:24:22 <vixey> if every GHC compiler in the world suddenly disappears
22:24:33 <vixey> how long would it take to get GHC working again?
22:24:39 <^Someone^> ?faq Can Haskell make you answer "no" to this question?
22:24:39 <lambdabot> The answer is: Yes! Haskell can do that.
22:24:43 <^Someone^> :|
22:24:48 <rian> i love the bootstrap problem
22:24:48 <Axman6> ?faq
22:24:48 <lambdabot> The answer is: Yes! Haskell can do that.
22:24:54 <^Someone^> Failbot
22:24:59 <rian> probably my favorite thing about cs/programming
22:25:20 * mrd wonders what kind of boots compiler writers wear
22:25:31 <nwf> vixey: It depends if anybody happens to have the -via-C temporary files for GHC itself around. :)
22:25:32 <Saizan_> vixey: there are .hc files kept in a secret vault somewhere in latin america
22:25:38 <audreyt> vixey: easily, via .hc files
22:26:00 <PHO_> Can't we use Hugs to interpret GHC?
22:26:05 <nwf> Even without, we could just execute GHC on paper.
22:26:16 <Axman6> heh
22:26:18 <Saizan_> and we'd need Dr. Jones to find them, obviously
22:26:21 <vixey> :)
22:26:36 <vixey> and what if there are no .hc files?
22:26:46 <nwf> AFAIK, GHC uses GHCisms in its own code base (as any bootstrapped compiler tends to do).
22:27:09 <Saizan_> yeah, hugs can't run the GHC source
22:27:15 <nwf> vixey: How good are you with pencils?
22:27:26 <vixey> I can draw
22:28:24 <nwf> In absence of ghc executables and .hc files, feel like emulating the STG machine in pictures?
22:29:18 <PHO_> I think we'd better write an STG interpreter then
22:29:37 <PHO_> paper and pencil are not very good tool for compilation
22:30:16 <nwf> Well no.  GHC would come back probably along a path similar to how it got here in the first place.
22:30:37 <PHO_> hmm
22:30:38 <nwf> One could imagine actually replaying the bootstrapping and development process by grabbing successive revisions fro CVS, assuming it's all there.
22:38:59 <geezusfreeek> if bootstrapping was impossible, we wouldn't have bootstrapped compilers :P
22:40:26 <chessguy> what is the point of bootstrapping a language, anyway?
22:40:35 <chessguy> err, s/language/compiler/
22:40:45 <vixey> why would you not?
22:40:46 <papermachine> look cool?
22:41:05 <mmorrow> i heard that once you bootstrap and interpreter and then run it with itself you can then just pull the computer out from under it like a rug from under a table
22:41:18 <vixey> the... computer? o_o
22:41:24 <geezusfreeek> if the language is worth anything it can be beneficial to write its compiler in itself just because you prefer to work with that language
22:41:26 <mmorrow> and it'll float there like the cheshire cat
22:41:32 <Elly> mmorrow: that'd be amazing
22:41:35 <vixey> I am actually working toward a bootstrapping compiler now :)
22:41:41 <vixey> just to see what happens .. :p
22:41:53 <vixey> incase something really strange like what mmorrow says occurs
22:41:56 <geezusfreeek> vixey: what, if you delete the source code?
22:42:00 <geezusfreeek> oh i see
22:42:01 <mmorrow> dont' fall down the rabbit hole!
22:42:38 <geezusfreeek> come on, take the red pill
22:43:38 <vixey> interesting http://en.wikipedia.org/wiki/NELIAC
22:45:55 <^Someone^> Trying to install cabal
22:46:05 <^Someone^> Got this dependencies missing error: Cabal >=1.3.12%%<1.5, zlib >=0.3, HTTP >= 3000.0&&<3001.2
22:46:07 <dons> hehe, record corrected, http://theunixgeek.blogspot.com/2008/06/programming-salaries.html
22:46:08 <lambdabot> Title: The Unix Geek: Programming Salaries
22:46:50 <^Someone^> Does that mean I need to have cabal insalled in order to install cabal? :|
22:47:03 * ^Someone^ kicks bootstrapping >.>
22:47:29 <Saizan_> ^Someone^: you can install those manually, i.e. with runghc Setup configure/build/install
22:47:45 <^Someone^> That is what I tried
22:48:00 <^Someone^> runghc Setup.hs configure
22:48:10 <^Someone^> Then it came up with that message
22:48:14 <vixey> what does a haskell job mean?
22:48:17 <vixey> what do you do?
22:48:28 <jdrake> What do you do in a C# job?
22:48:32 <Elly> vixey: you think and draw diagrams for 15 hours, then write a single line starting with 'foldr'
22:48:38 <Saizan_> ^Someone^: i mean that you've to do that for those packages, not only cabal-install
22:48:42 <Elly> vixey: then you go home, job well done
22:48:44 <vixey> Elly, lol
22:49:22 <dons> vixey: you write programs, mostly.
22:49:28 <^Someone^> Saizan_: Okay :)
22:49:34 * Elly has a C++ job :(
22:49:40 * Elly has a cool C++ job, though
22:49:48 <vixey> dons, like what?
22:50:02 <vixey> I wonder if I could do it
22:50:12 <mmorrow> you can!
22:50:19 <^Someone^> Saizan_: I'm not familiar with installing anything this way, and can't understand that message very well: Which packages are those?
22:50:56 <^Someone^> Nevermind, I understand
22:51:51 <mmorrow> vixey: it wouldnt be what it is if there was a predefined it to do
22:52:07 <vixey> what kind of programs are actually needed though?
22:52:22 <vixey> there are already webservers, OSs..
22:53:29 <mmorrow> vixey: exactly
22:53:41 <vixey> I don't understand
22:53:53 <mmorrow> vixey: start thinking!
22:54:18 <Saizan_> vixey: well there are a lot of more domain/company specific applications to write :)
22:54:38 <ixdy> also, most existing software sucks.
22:55:02 <vixey> I guess that some of the stuff is like robots that trade things.. and generate money?
22:55:14 <vixey> I really don't know what goes on in these big buildings :P
22:56:35 <vixey> one probably needs some qualifications to get a job writing haskell though
22:58:44 <mmorrow> vixey: if you can do with code something that's valuable to someone/a company, it doesn't matter if you're a salamander
22:59:48 <hpaste>  cjs pasted "What's the difference?" at http://hpaste.org/8251
22:59:54 <cjs> Can someone explain that to me?
23:00:33 <cjs> Oh, the QCalc is: data QCalc a = QCalc { runCalc :: ([Q] -> (Either String a,[Q])) }
23:01:04 <cjs> I had no qualifications to get my job writing Haskell. I didn't even know Haskell!
23:01:16 <Saizan_> cjs: v :: Either String a, while there you want Either String b
23:01:21 <geezusfreeek> where did you get a job writing haskell?
23:01:27 <ixdy> cjs: where are you working?
23:01:31 <vixey> cjs: What sorts of things do you write?
23:01:40 <cjs> Oh, right! I see. Duh.
23:01:52 <cjs> (It's pretty obvious I have no qualifications. :-)
23:01:56 <roconnor> @unmlt StateT [0] (Error String)
23:01:56 <lambdabot> Maybe you meant: unmtl unpl
23:02:05 <roconnor> @unmtl StateT [Q] (Error String)
23:02:05 <lambdabot> err: `StateT [Q] (Error String)' is not applied to enough arguments, giving `/\A. [Q] -> Error String (A, [Q])'
23:02:09 <roconnor> @unmtl StateT [Q] (Error String) a
23:02:09 <lambdabot> [Q] -> Error String (a, [Q])
23:02:19 <roconnor> :/
23:02:23 <roconnor> not the same
23:02:35 <Saizan_> @unmtl ErrorT String (State [Q]) a
23:02:36 <lambdabot> [Q] -> (Either String a, [Q])
23:02:46 <vixey> @unmelt RWST a a a a a
23:02:46 <lambdabot> a -> a -> a (a, a, a)
23:02:59 <roconnor> Saizan_: better
23:03:13 <Saizan_> vixey: kind error!
23:03:16 <geezusfreeek> wait what is @unmelt?
23:03:28 <mmorrow> vixey: so, if what you've got (your skills/knowledge/sight) is valuable enough to someone (in the sense that it's their best option given current whatever), it would be foolish for them to pass up the opportunity you've just presented to them. then you may set the terms as you please because you have leverage.
23:03:42 <Saizan_> geezusfreeek: it removes the newtypes from mtl's monads
23:04:05 <geezusfreeek> Saizan_: @unmtl and @unmelt are the same?
23:04:08 <thetallguy> @yow
23:04:09 <lambdabot> My life is a patio of fun!
23:04:19 <thetallguy> ?seen dcoutts
23:04:19 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts last spoke.
23:04:52 <Saizan_> geezusfreeek: yup
23:05:04 <geezusfreeek> okay, i just hadn't seen that variant of it before
23:05:56 <vixey> :(
23:06:15 <sjanssen> geezusfreeek: it's just the spelling checker kicking in
23:06:39 <geezusfreeek> oh! i didn't even realize it had one ^_^
23:07:09 <geezusfreeek> @ywo
23:07:09 <lambdabot> Maybe you meant: wn yow
23:07:20 <sjanssen> @cow
23:07:20 <lambdabot> ... I want a COLOR T.V. and a VIBRATING BED!!!
23:07:26 <vixey> @wow color
23:07:27 <lambdabot> Yow!  Am I in Milwaukee?
23:07:45 <geezusfreeek> @yow
23:07:45 <lambdabot> You should all JUMP UP AND DOWN for TWO HOURS while I decide on a NEW CAREER!!
23:07:46 <vixey> @spin
23:07:46 <lambdabot> Maybe you meant: join ping seen
23:07:57 <vixey> @pink
23:07:58 <lambdabot> pong
23:08:12 <vixey> @keal
23:08:12 <lambdabot> T seems to be haskell, except with a decent interface at this point
23:08:28 <vixey> T ? the scheme dialect?
23:08:47 <vixey> (It's nothing like haskell...)
23:08:57 <Korollary> keal's like nobody you know
23:09:05 <sjanssen> vixey: no, just the ramblings of a fairly crazy person
23:09:07 <sjanssen> @keal
23:09:08 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
23:09:26 <vixey> @keal
23:09:27 <lambdabot> it is very easy to go off topic
23:09:30 <vixey> :D
23:09:38 <sjanssen> @keal
23:09:38 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
23:09:41 <sjanssen> @keal
23:09:41 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
23:09:42 <sjanssen> @keal
23:09:43 <lambdabot> nsa prevent me from returning to math on efnet
23:09:47 <sjanssen> okay, enough spam
23:18:16 <solrize> vixey i suspect some places have started using haskell as a screen test for nerds.  they used python that way until it became trendy
23:19:44 <vixey> oh that's interesting
23:22:01 <roconnor> > iterate (**(sqrt 2)) (sqrt 2)
23:22:03 <lambdabot>  [1.4142135623730951,1.632526919438153,2.0000000000000004,2.665144142690226,4...
23:22:28 <roconnor> hmm
23:22:32 <roconnor> not quite what I wanted
23:22:38 <roconnor> > iterate ((sqrt 2)**) (sqrt 2)
23:22:39 <lambdabot>  [1.4142135623730951,1.632526919438153,1.7608395558800285,1.8409108692910108,...
23:22:43 <solrize> > iterate ((sqrt 2)**)
23:22:44 <lambdabot>  <Double -> [Double]>
23:22:44 <solrize> yeah that :)
23:22:57 <roconnor> > (iterate ((sqrt 2)**) (sqrt 2))!!100
23:22:58 <lambdabot>  2.0000000000000004
23:23:08 <roconnor> > (iterate ((sqrt 2)**) (sqrt 2))!!1000
23:23:09 <lambdabot>  2.0000000000000004
23:24:00 <roconnor> > (iterate ((sqrt 2)**) 2)!!1000
23:24:02 <lambdabot>  2.0000000000000004
23:24:06 <roconnor> > (iterate ((sqrt 2)**) 4)!!1000
23:24:07 <lambdabot>  Infinity
23:24:15 <vixey> > Infinity
23:24:16 <lambdabot>   Not in scope: data constructor `Infinity'
23:24:19 <roconnor> > (iterate ((sqrt 2)**) 4)
23:24:20 <lambdabot>  [4.0,4.000000000000001,4.000000000000003,4.000000000000004,4.000000000000007...
23:24:25 <vixey> o_o
23:24:35 <solrize> :t iterate
23:24:37 <lambdabot> forall a. (a -> a) -> a -> [a]
23:24:38 <roconnor> unattractive fixpoint
23:24:42 <vixey> > 2**(99::Double)
23:24:44 <lambdabot>  6.3382530011411471e29
23:24:46 <vixey> > 2**(9999::Double)
23:24:48 <lambdabot>  Infinity
23:25:03 <vixey> @let pinkElephants = 2**(9999::Double)
23:25:04 <lambdabot> Defined.
23:25:31 <roconnor> > (iterate ((sqrt 2)**) 4) :: [CReal]
23:25:42 <lambdabot>  [4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,Excepti...
23:25:51 <vixey> what :S
23:25:54 <roconnor> @more
23:25:54 <vixey> that makes no sense
23:25:56 <solrize> whats CReal ?
23:26:11 <roconnor> Excepti...what?
23:26:33 <roconnor> > (iterate ((sqrt 2)**) 4)!!18:: CReal
23:26:42 <lambdabot>  4.0
23:26:47 <roconnor> > (iterate ((sqrt 2)**) 4)!!19:: CReal
23:26:58 <lambdabot>  Exception: Time limit exceeded
23:26:58 <opqdonut> :D
23:27:03 <vixey> huh!?
23:27:19 <sjanssen> > pi :: CReal
23:27:20 <lambdabot>  3.1415926535897932384626433832795028841972
23:27:55 <sjanssen> solrize: CReal is an infinite precision number
23:28:09 <vixey> > pinkElephants :: CReal
23:28:10 <lambdabot>  Couldn't match expected type `CReal' against inferred type `Double'
23:28:15 <vixey> :(
23:28:32 <sjanssen> > 2**9999 :: CReal
23:28:40 <lambdabot>  9975315584403791924418710813417925419117484159430962274260044749264719415110...
23:29:22 <roconnor> > 2^9999
23:29:23 <lambdabot>  9975315584403791924418710813417925419117484159430962274260044749264719415110...
23:30:01 <solrize> > exp (pi * sqrt 163) :: CReal
23:30:03 <lambdabot>  262537412640768743.9999999999992500725971981856888793538563
23:30:09 <solrize> nod
23:33:22 <u_quark> how can I make my own show for a type synonym: type Lala = [a] ?
23:33:42 <vixey> you cannot
23:33:45 <sjanssen> u_quark: you use a newtype instead -- newtype Lala = Lala [a]
23:33:47 <vixey> It's a synonym
23:35:33 <mmorrow> > let e_i phi = cos phi + i * sin phi in e_i pi
23:35:34 <lambdabot>  cos pi + i * sin pi
23:35:44 <mmorrow> > let e_i phi = cos phi + i * sin phi in 1 * e_i pi
23:35:45 <lambdabot>  1 * (cos pi + i * sin pi)
23:35:45 <vixey> heh
23:35:48 <mmorrow> crap
23:35:56 <mmorrow> oh
23:36:00 <sjanssen> @type i
23:36:02 <lambdabot> Expr
23:36:09 <vixey> > e ^ (sqrt (-1) * pi)
23:36:10 <lambdabot>  Add a type signature
23:36:11 <vixey> > exp (sqrt (-1) * pi)
23:36:13 <lambdabot>  NaN
23:36:14 <vixey> > exp (sqrt (-1) * pi) :: CReal
23:36:16 <lambdabot>  Exception: Ratio.%: zero denominator
23:36:23 <vixey> > exp (sqrt (-1) * pi) :: Complex CReal
23:36:26 <lambdabot>  (-1.0) :+ 0.0
23:36:29 <vixey> ah better
23:36:32 <mmorrow> > let e_i phi = cos phi + i * sin phi ; i = 0:+1 in 1 * e_i pi
23:36:33 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
23:36:35 <vixey> > exp (sqrt (-1) * pi) + 1 :: Complex CReal
23:36:37 <lambdabot>  0.0 :+ 0.0
23:36:40 <u_quark> sjanssen: no i cant use an other type... i want it to be isomorfic to lists :P
23:36:41 <mmorrow> nice
23:36:50 <sjanssen> u_quark: then you're out of luck
23:37:25 <sjanssen> u_quark: do you absolutely need to use Show?  It is usually best to use the derived instance
23:37:26 <vixey> data List a = Nil | Cons a (List a)
23:37:28 <vixey> that's isomorphic
23:37:39 <vixey> I think
23:37:45 <vixey> maybe there are multiple meanings
23:38:01 <u_quark> vixey: -XTypeSynonymInstances ? i just have to hide the prelude implementation ...
23:38:32 <sjanssen> u_quark: what is the actual type synonym you're using?
23:39:49 <u_quark> vixey: isomorphic inside the compiler ...
23:40:03 <vixey> then just use []
23:41:03 <u_quark> sjanssen: the type synonym is actually: type Table = [[TableCell]]
23:41:34 <vixey> oh in that case why don't you use
23:41:41 <vixey> data Table = Table [[TableCell]]
23:41:42 <vixey> or
23:41:51 <vixey> data Table = Table [TableRow/Column]
23:42:09 <u_quark> whats the "/" ????
23:42:13 <vixey> metasyntax
23:42:14 <Saizan_> u_quark: then you can use OverlappingInstances and instance Show [[TableCell]] where..
23:42:21 <vixey> you could define ++ and such to work on Table as well as []
23:42:23 <u_quark> i dont want to box and unbox everything ...
23:42:34 <Saizan_> u_quark: if you absolutely need Show and can't use a newtype
23:42:39 <vixey> (so that you don't  have to box and unbox things manualy)
23:42:54 <Saizan_> u_quark: why not use a separate prettyprint function?
23:44:59 <u_quark> how can i hide one instance or say that i want to use a specific one ?
23:45:08 <sjanssen> you can't.
23:45:27 <Saizan_> the best you get is OverlappingInstances
23:45:35 <u_quark> :S
23:45:52 <u_quark> can't i hind the preludes instance ?
23:46:12 <vixey> the irritating thing is
23:46:14 <vixey> @src []
23:46:14 <lambdabot> data [] a = [] | a : [a]
23:46:19 <vixey> is not valid haskell is it
23:46:24 <sjanssen> u_quark: no, instances may not be hidden
23:46:42 <Saizan_> vixey: that's not a problem in this case
23:46:45 <vixey> "Illegal binding of built-in syntax: []"
23:47:01 <u_quark> : /
23:47:07 <roconnor> <u_quark> i dont want to box and unbox everything ...
23:47:08 <vixey> Saizan: If you could hide list though, and define it yourself, and typeclasses on it.. (although this is a bad idea)
23:47:10 <roconnor> it's not so bad
23:47:30 <u_quark> roconnor: :)
23:48:10 <roconnor> just derive the monad instance
23:48:11 <Saizan_> vixey: and all the modules compiled against the old list which you've to interface with? you'd need some kind of dynamic scoping
23:48:17 <roconnor> half the functions on lists will work
23:48:47 <roconnor> er
23:48:48 <roconnor> scratch that
23:48:55 <roconnor> still
23:48:58 <roconnor> it's not so bad
23:49:03 <u_quark> lol
23:49:19 <sjanssen> u_quark: just use something other than Show
23:49:26 <sjanssen> u_quark: Show is not meant for pretty-printing
23:50:08 <u_quark> yea... if i have to settle with something less than what i want i would do that ^^^^
23:52:19 <u_quark> in general i can't override a prelude instance ?
23:53:02 <Saizan_> you can't override any instance that's defined in a module that you import, even transitively
23:53:47 <u_quark> mmmm i am missing some key-points in type-classes ... :S
23:54:54 <roconnor> u_quark: typeclasses are global.  It is a major failing of Haskell.
23:55:18 <sjanssen> I don't think it is unreasonable
23:55:38 <roconnor> I do, although I don't have an alternative.
23:55:53 <roconnor> It causes surprisingly few problems.
23:56:47 <Saizan_> well, with local instances you can get some weird behaviour
23:57:32 <roconnor> any more weird than importing local functions?
23:57:38 <sjanssen> I wouldn't mind a system where certain functions can receive an explicit dictionary (sort is a good example)
23:57:50 <^Someone^> In order to install, say, zlib, do I place the directory in a temporary directory, or in ghc's lib folder?
23:57:56 <sjanssen> roconnor: Typeable comes to mind
23:58:15 <^Someone^> Installing didn't add anything new to the lib folder
23:58:24 <Saizan_> roconnor: if i pass you a Map built with some Ord instance, and you use it with another you get something weird, no?
23:58:25 <sjanssen> ^Someone^: how did you install it?
23:58:41 <^Someone^> runghc Setup.hs configure etc.
23:58:49 <roconnor> Saizan_: how do you mean?
23:58:54 <^Someone^> Those three steps
23:58:59 <sjanssen> ^Someone^: by default, it will install in a subdirectory of lib
23:59:19 <sjanssen> ^Someone^: try ghc-pkg list to see if it was installed successfully
23:59:28 <^Someone^> Okay
23:59:36 <roconnor> Saizan_: oh a Map
23:59:37 <dfrey> Can someone tell me why this doesn't work.  I'm pretty sure it has something to do with type annotations, but I am not sure of the details
23:59:41 <dfrey> let a = listArray (0,3) [1..4]
23:59:46 <^Someone^> Oh yes it did
23:59:49 <^Someone^> Ty, sjanssen :)
23:59:57 <Saizan_> roconnor: yeah, Data.Map.Map
