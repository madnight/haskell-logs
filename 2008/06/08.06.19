00:00:52 <dancor> quicksilver: is there an example config somewhere to get it to actually connect to e.g. freenode
00:02:49 <mjrosenb> how is pure different from any other haskell function?
00:03:29 <geezusfreeek> mjrosenb: it's not? i'm not sure i understand the question
00:04:01 <mjrosenb> how is a "pure" function different from any other function that you write in haskell
00:04:23 <mjrosenb> in other words, when would you not want to annotate a function with pure
00:04:27 <geezusfreeek> mjrosenb: ah! i thought you were saying something about Control.Applicative.pure
00:04:37 <mjrosenb> no.
00:05:08 <geezusfreeek> i guess this is what i get for not just reading up a few lines
00:06:05 <ivanm> looks like what diego calls "constant" is what in haskell is considered "pure" (same input produces same output)
00:06:22 <quicksilver> mjrosenb: it's "gcc" that has the pure anootation.
00:06:24 <ivanm> AFAICT, his "pure" means that state isn't changed.... so it _could_ return a random result...
00:06:26 <quicksilver> mjrosenb: not ghc ;)
00:06:30 <mjrosenb> quicksilver: ok
00:06:41 * mjrosenb knows what pure does in gcc
00:06:41 <quicksilver> mjrosenb: in ghc all functions are pure as you correctly observe.
00:06:51 <sjanssen> unsafePerformIO!
00:06:58 <quicksilver> sjanssen: not a function ;)
00:07:07 <mjrosenb> minus ones in the IO monad
00:07:12 <sjanssen> @type Foreign.unsafePerformIO
00:07:15 <lambdabot> forall a. IO a -> a
00:07:19 <sjanssen> mjrosenb: IO functions are pure
00:07:21 * quicksilver skillfully redefines terms to avoid being wrong.
00:07:34 <sjanssen> quicksilver: isn't a function, by definition, pure?
00:07:42 <quicksilver> sjanssen: unsafePerformIO is a primitive. It doesn't have a function type, it just looks like it does.
00:07:43 <sjanssen> if it isn't pure, can you still call it a function? :P
00:07:48 <quicksilver> agreed.
00:07:54 <geezusfreeek> @src unsafePerformIO
00:07:54 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
00:07:57 <geezusfreeek> :P
00:08:00 <quicksilver> precisely my point, in fact :)
00:08:26 <sjanssen> there are many more examples in GHC
00:08:40 <sjanssen> quicksilver: you should amend your statement to "in Haskell '98 all functions are pure"
00:09:10 <quicksilver> that would be one way of amending it, yet.
00:09:10 <ivanm> ummmm.... so nothing using the IO Monad can be considered a function?
00:09:17 <sjanssen> ivanm: false
00:09:17 <hpaste>  kig pasted "slow memory-hog wf2" at http://hpaste.org/8416
00:09:24 <quicksilver> but I'd prefer to stand on the point that unsafePerformIO is not a function.
00:09:40 <ivanm> quicksilver: because it's inbuilt rather than being re-definable in your own code?
00:09:53 <sjanssen> quicksilver: eh, I think that is a bit of a stretch
00:09:59 <sjanssen> it does have a function type, as you note
00:10:10 <quicksilver> sjanssen: you said yourself "if it isn't pure can you still call it a function?"
00:10:18 <quicksilver> I agree with that analysis.
00:10:25 <sjanssen> putChar is built-in, but I'd still call it a function
00:10:36 <quicksilver> putChar is definitely a function.
00:10:39 <sutats> Couldn't it still be pure if it passes the world in?
00:10:41 <kig> re: above wf2 paste, any ideas on making it not slow?
00:11:00 <quicksilver> ivanm: not all primitives are necessarily broken in this way :)
00:11:01 <sjanssen> quicksilver: forall x. in x all functions are pure :)
00:11:19 <quicksilver> ivanm: unsafePerformIO is particularly broken
00:11:31 <ivanm> @type putChar
00:11:32 <geezusfreeek> i think unsafePerformIO is certainly a function, it just isn't very well behaved
00:11:33 <lambdabot> Char -> IO ()
00:11:41 <ivanm> OK, so why is putChar a function but not unsafePerformIO ?
00:11:45 <quicksilver> as sjanssen points out, putChar is a perfectly well behaved function.
00:11:51 <mauke> ivanm: because putChar has no side effects
00:11:58 <quicksilver> because given a particular Char as input it produces an IO action as output
00:12:02 <quicksilver> and it does so functionally.
00:12:05 <ivanm> mauke: sure it does, it changes the world!
00:12:09 <mauke> ivanm: no, it doesn't
00:12:16 <quicksilver> geezusfreeek: functions are sets of pairs.
00:12:25 <ivanm> (world == filesystem, etc.)
00:12:35 <mauke> main = const (return ()) [putChar 'h', putchar 'i', putChar '!']
00:12:38 <sjanssen> ivanm: no, putChar constructs an action that might change the world when executed
00:12:39 <mauke> what does that print?
00:12:41 <quicksilver> geezusfreeek: it's inherent in the definition of function that they always return the same result.
00:12:54 <quicksilver> geezusfreeek: (in one definition, at least)
00:13:00 <quicksilver> but that's the definition I choose ;)
00:13:08 <ivanm> mauke: pfffttt!!! :p
00:13:12 <quicksilver> as I said earlier, I'm wriggling out of being wrong by defining terms.
00:13:15 <mauke> hmm?
00:13:28 <osfameron> quicksilver++ # wriggly
00:13:29 <quicksilver> ivanm: but mauke's point is precisely the point.
00:13:49 <quicksilver> putChar is quite functional.
00:13:49 <geezusfreeek> quicksilver: can't argue with customized terminology i guess :P
00:13:51 <ivanm> you could do the same with unsafePerformIO, could you not?
00:14:05 <ivanm> geezusfreeek: yeah...
00:14:07 <quicksilver> it's only when the RTS executes things the side effect happens
00:14:18 <quicksilver> geezusfreeek: well, indeed. But in my defence it's not unusual terminology.
00:14:23 <sjanssen> main = const (return ()) (unsafePerformIO $ putChar 'c')
00:14:27 <ivanm> so now you're blaming the poor old RTS?
00:14:30 <quicksilver> geezusfreeek: when we call this 'functional programming'
00:14:31 <geezusfreeek> although i do agree that applying the mathematical definition should fit, so now i am inclined to say that it may not be a function
00:14:41 <quicksilver> geezusfreeek: this is precisely the sense of the word 'function' we mean.
00:14:43 <mauke> putChar 'x' `seq` return ()
00:14:46 <sjanssen> does the Haskell report define function?
00:14:47 <geezusfreeek> right
00:14:59 <ivanm> quicksilver: so does what sjanssen typed in before count?
00:15:07 <ivanm> it's analogous to what mauke entered...
00:15:08 <quicksilver> sure.
00:15:27 <quicksilver> well the correct comparison needs seq, in fact.
00:15:27 <ivanm> so how does that prove that putChar is a function but unsafePerformIO isn't?
00:15:44 <quicksilver> main = putChar 'h' `seq` return ()
00:15:47 <quicksilver> ^^ does no print h
00:15:49 <mauke> it doesn't because of laziness
00:15:57 <geezusfreeek> putChar will always return the same value
00:15:57 <quicksilver> main = (unsafePerformIO $ putChar 'h') `seq` return ()
00:15:59 <mauke> it would prove it if haskell were strict
00:16:01 <quicksilver> ^^ does print 'h'
00:16:18 <ivanm> ummm.... why doesn't the first one print 'h'?
00:16:23 <roconnor> must distiguish arrows and Kleisli arrows
00:16:25 <ivanm> I thought seq evaluated the first term...
00:16:30 <mauke> ivanm: it does
00:16:31 <quicksilver> exactly!
00:16:36 <mauke> ivanm: but putChar has no side effects
00:16:36 <quicksilver> now you've got to the key point.
00:16:43 <quicksilver> putChar has no side effects.
00:16:46 <ivanm> quicksilver: you said it doesn't print h!
00:16:50 <quicksilver> evaluating it does not cause anything to print.
00:16:54 <geezusfreeek> ivanm: because evaluating the term does not itself perform the side-effect
00:16:55 <quicksilver> precisely.
00:17:08 * ivanm feels his brain melting
00:17:24 <geezusfreeek> ivanm: the IO monad does nothing more than generate an imperative program at runtime
00:17:30 <ivanm> ...yes...
00:17:41 <geezusfreeek> ivanm: putChar 'h' generates the program that outputs h
00:17:44 <mauke> ivanm: type IO a = String; putChar c = "printf(\"%c\", " ++ show c ++ ");"
00:17:53 <geezusfreeek> ivanm: the result of evaluating it is that program, not the side-effect
00:18:06 <ivanm> mauke: wtf?
00:18:17 <ivanm> how can you redefine IO like that? :s
00:18:28 <mauke> (for illustration purposes)
00:18:39 <mauke> it's not a valid implementation because it ignores return values
00:18:53 <ivanm> ...OK.... so why shouldn't unsafePerformIO work like that then?
00:19:07 <ivanm> geezusfreeek: so how does that compare to unsafePerformIO? it forces evaluation?
00:19:26 <quicksilver> it forces the side effects to actually *happen*
00:19:30 <mauke> well, how do you go from a String to the result of running that String as C code?
00:19:30 <quicksilver> more than just evaluation.
00:19:52 <quicksilver> evaluating an IO action just gets you an IO action.
00:19:52 <ivanm> quicksilver: *nod*
00:19:59 <quicksilver> to actually perform the action, you need the RTS.
00:20:09 <ivanm> It actually "runs" the resultant C program?
00:20:12 <quicksilver> the only tool we have in haskell98 for performing an action is the magic sigil 'main ='
00:20:16 <ivanm> whereas the IO monad just writes it?
00:20:16 <geezusfreeek> ivanm: unsafePerformIO performs the side-effect out of turn. the runtime normally executes the program generated by the IO monad from the top level, but unsafePerformIO is like running another interpreter inside your program
00:20:26 <quicksilver> GHC gives us unsafePerformIO but it's not functional.
00:20:30 <mauke> related: http://mauke.ath.cx/stuff/haskell/how-to-io.html
00:20:32 <lambdabot> Title: Haskell: How To IO
00:20:38 <roconnor> I'd say unsafePerformIO "runs" the IO, which is distinct from evaluation of thunks.
00:20:42 <ivanm> @remember quicksilver quicksilver> the only tool we have in haskell98 for performing an action is the magic sigil 'main ='
00:20:42 <lambdabot> I will never forget.
00:20:50 <ivanm> just because I like the phrase "magic sigil" :p
00:20:58 <mauke> @quote quicksilver
00:20:58 <lambdabot> quicksilver says: quicksilver> the only tool we have in haskell98 for performing an action is the magic sigil 'main ='
00:21:01 <quicksilver> roconnor: you might even say it 'Performs' it ;)
00:21:06 <roconnor> even better
00:21:29 <roconnor> oh
00:21:34 <roconnor> I see now. :P
00:21:39 <ivanm> whoops, didn't mean to have the "quicksilver>" at the beginning there :s
00:22:06 <ivanm> quicksilver: how does "run" and "perform" differ?
00:22:09 <ivanm> in this context...
00:22:09 <roconnor> specifically unsafePerformIO forces the Performance to happen at evaulation time ... whenever that is.
00:22:16 <quicksilver> not at all.
00:22:17 <ivanm> *nod*
00:22:22 <ivanm> quicksilver: heh, OK
00:22:22 <quicksilver> roconnor was searching for a good word
00:22:29 <quicksilver> I pointed out that there was a word in the name :)
00:22:30 <quicksilver> that's all.
00:22:35 <ivanm> ahhh.... duh, unsafePERFORMio ;-)
00:23:04 <mauke> unperformSafeIO
00:23:06 <quicksilver> the program is but a stage and we are merely performers?
00:23:12 <roconnor> For some reason this reminds me of talking about the nondeterminism monad. ... which is actualy deterministic.
00:23:20 <geezusfreeek> mauke: unlaunchMissiles?
00:23:21 <ivanm> mauke: is that the inverse of main = ?
00:23:34 <ivanm> roconnor: wtf?
00:23:41 <quicksilver> safeUnlaunchMissiles
00:23:45 <roconnor> ivanm: perhaps I should't confuse the issue more.
00:23:54 <ivanm> heh
00:23:57 <ivanm> quicksilver: lol
00:24:03 <roconnor> ivanm: I can detail it after you are happy with IO
00:24:12 <mjrosenb> ivanm: not every function is invertible
00:24:15 <ivanm> roconnor: you're referring to using the list monad to perform undeterminism?
00:24:19 <ivanm> mjrosenb: I know...
00:24:27 <mjrosenb> what's the inverse of \x -> 5
00:24:28 <ivanm> e.g. max has no inverse
00:24:35 <ivanm> mjrosenb: *sigh* yes, I know :p
00:24:38 <roconnor> ivanm: for simplicity, let us consider the list moand.
00:24:43 <ivanm> yup
00:24:46 <geezusfreeek> mjrosenb: ha, now we have both taken things out of context :P
00:24:59 <mjrosenb> geezusfreeek: wheee
00:25:39 * mjrosenb doesn't see any context that would change the meaning of ivanm's statement
00:25:48 <ivanm> (though this new way of thinking of IO just makes it look more and more like Haskell compiles down to bytecode, and then gets bundled up with its own VM to run it...)
00:25:58 <roconnor> that's a good way of thinking about it.
00:26:06 <quicksilver> (that would be a possible implementation of IO, yes)
00:26:17 <quicksilver> (I feel like a lisp programmer)
00:26:22 <ivanm> lol
00:26:25 <quicksilver> (does anyone know the way out of these parentheses)
00:26:26 <geezusfreeek> haha
00:26:37 <quicksilver> (is it (over here (no this is (worse))))
00:26:44 <ivanm> quicksilver: shouldn't that be: (feel_like lisp_programmer quicksilver) ?
00:26:52 <mjrosenb> (you shouldn't say that (until you've used them) (to their full capabilities))
00:26:53 * sjanssen hands quicksilver several $'s
00:26:56 <dancor> how do i actually get lbot to join a channel
00:26:59 <roconnor> (CPS (style (sentences (dot ...
00:27:05 <ivanm> dancor: ask Cale?
00:27:09 <osfameron> I tried to read some scheme yesterday and it hurt my brain.  And the guy was surprised, "Isn't it like haskell?" ;-)
00:27:23 <dancor> ivanm: no my own lbot
00:27:27 <ivanm> dancor: ahhh
00:27:36 <dancor> Cale: tho you probably know..
00:27:40 <ivanm> mauke: did you already have that IO page, or just write it just quickly now?
00:27:49 <mauke> ivanm: I already had it
00:27:53 <ivanm> *nod*
00:28:09 <ivanm> *phew* otherwise that would have been a rather fast writing... ;-)
00:29:12 <roconnor> In the list monad, you write programs as if the language is non-deterministic; however the result is really deterministic.
00:29:20 <ivanm> *nod*
00:29:30 <geezusfreeek> first . filter (==quicksilver) . concat . concat . concat . concat . concat $ quicksilverLispWorld -- get out!
00:29:33 <roconnor> There is a specific order (depth-first) that things are tried
00:29:49 <roconnor> Some people get confused when i talke about the non-determinism
00:30:16 <ivanm> makes sense so far...
00:30:19 <roconnor> from "inside" the monad the world looks non-deterministic.
00:30:34 <roconnor> from outside in the haskell world, we see that everything is deterministic.
00:30:48 <roconnor> ... kinda like quantum mechanics in a way.
00:30:50 <ivanm> because inside you're just choosing one that fits?
00:30:55 <ivanm> lol
00:31:06 <dancor> well anyway, i can get lambdabot on an irc server, but same issue of "> 4" -> fd:7: hClose: resource vanished (Broken pipe)
00:31:22 <sjanssen> dancor: it means you're doing it wrong
00:31:26 <ivanm> though how does quantum look deterministic from the outside? or does outside == a large ensemble aka statistical mechanics?
00:31:32 <roconnor> I think in a similar way IO is impure from the inside view, but pure from the outside view.
00:31:42 <ivanm> *nod*
00:31:48 <roconnor> ivanm: the wave equation is deterministic
00:31:49 <dancor> sjanssen: hah yes.  probably i need to edge-bleed more on some deps
00:31:58 <dancor> sigh
00:32:02 <sjanssen> dancor: nah, once you've built it it should work
00:32:17 <sjanssen> dancor: I'd also suggest you RTFM, but lambdabot doesn't have one :(
00:32:24 <ivanm> roconnor: you mean schrodinger's?
00:32:29 <roconnor> ivanm: yes
00:32:51 <ivanm> hmmmmmm....... it's deterministic on the probabilities, not on the actual partical though, IIRC
00:32:55 <maltem> roconnor: hm... when all side-effectful IO actions have already happened, then what's left over of IO is pure, right :)
00:33:03 <sjanssen> dancor: what have you tried?
00:33:15 <roconnor> ivanm: when you take the entire universe, the state simply evolves according  schrodinger's equation.
00:33:31 <roconnor> including the people and computers trapped inside the universe.
00:33:35 <ivanm> heh, true
00:33:48 <ivanm> though you'd need a pretty big computer to calculate the overall wave equation :p
00:33:49 <mmorrow> there does not exist an outside of the universe.
00:33:51 <roconnor> but the people and computers see things happening randomly
00:33:57 <roconnor> because they have the inside view.
00:33:57 <mjrosenb> this still is'nt the method that i like for encapsulating IO
00:34:01 <ivanm> mmorrow: sure there is.... the parallel universes!
00:34:02 <augur> conal! :o
00:34:08 <ivanm> alternate realities, etc. :p
00:34:30 <mmorrow> well, then those are part of the universe. the universe is universal in this sense!
00:34:34 <roconnor> ivanm: anyhow, I don't know if the analogy is any good, but it is how I like to think of things.
00:35:05 <ivanm> roconnor: analogy for the so-called undeterminism?
00:35:17 <ivanm> mmorrow: no, they're a _seperate_ universe!
00:35:18 <roconnor> maltem: that's not right.
00:35:32 <ivanm> "parallel" to ours, hence the name! :p
00:35:46 <roconnor> roconnor: yes, but I use that analogy for almost all the monads
00:36:09 <ivanm> ummmm..... you're talking to yourself?
00:36:13 <mmorrow> ivanm: omG@!
00:36:21 <ivanm> you do realise that's the first sign of madness, don't you? :p
00:36:24 <roconnor> roconnor: for every monad, I think there is life inside the monad, and outside the monad, and they look different.
00:36:30 <roconnor> ivanm: ^^
00:36:35 <roconnor> sorry
00:36:38 <ivanm> heh
00:36:40 <maltem> mmorrow: "universe" can be correctly misused to denote one out of severy universes, even though "multiverse" would make more sense then
00:36:52 <roconnor> ivanm: so for the state monad, it seems like there is a global state to manipulate.
00:36:59 <ivanm> *nod*
00:37:04 <roconnor> ivanm: but from outside, there is no state
00:37:22 <maltem> s/severy/several/
00:37:25 <mmorrow> universal in the sense that a greatest lower bound/least upper bound is universal.
00:37:36 <roconnor> ivanm: what looks like a value x from the inside is really a function \s ->(x,s')
00:37:54 <roconnor> from the outside
00:38:16 <mmorrow> a (co)limit, unique! up to isomorphism
00:39:36 <roconnor> what is really mindblowing about the IO monad is that it what is inside (the IO) world in fact is he real world of flesh and blood (or at least printers and scanners)
00:40:07 <roconnor> so the inside world is really outside what I've been calling the "outside world"
00:40:14 <ivanm> so the matrix is real and the real world is a fake? :o
00:40:16 <ivanm> :
00:40:17 <ivanm> :p
00:40:18 <lament> hehehehe
00:40:19 <roconnor> yep
00:40:22 <maltem> roconnor: This is a little as with Hegel and his way of discussing antitheses. There is a global state. Wrong, there is no global state in Haskell. See, on a higher level, we just have a function from state to state, so both statements are alright!
00:40:49 <lament> roconnor: then explain what haskell is, cosmogonically
00:41:02 <roconnor> lament: ?
00:41:27 <roconnor> I imainge IO a box, and when you look inside, it is really a window into the real world.
00:41:33 <mmorrow> lament: you mean like lipstick and eyeshadow?
00:41:35 <lament> if the universe as we know it exists as a monad in Haskell, what kind of entity is Haskell?
00:42:02 <rwbarton> A category :P
00:42:08 <roconnor> lament: Haskell is running on a machine running in reality
00:42:21 <lament> it exists inside the universe yet the universe exists inside it.
00:42:30 <roconnor> lament: that is the irony
00:42:34 <ivanm> so by using Haskell we're touching the divine? :p
00:42:35 <lament> strange loooop
00:42:39 <lament> yep
00:42:40 <roconnor> yes
00:42:40 <augur> sounds like scheme to me.
00:42:45 <lament> the divine strange loop
00:42:48 <maltem> lazy evaluation makes this possible!
00:42:50 <roconnor> like penrose's loop
00:42:51 <mmorrow> tying the knot, day after day
00:42:51 <augur> almost.. metacircular?
00:42:55 <maltem> just plain mutual recursion
00:42:57 <augur> :P
00:43:20 <lament> by using Haskell we're touching the divine ...something
00:43:20 <roconnor> mathematics is created in the mind, which is a physical process, which is follows mathematical laws.
00:43:37 <mmorrow> well that's those minds model for such
00:43:40 <lament> mathematics is for dorks.
00:43:47 <augur> speaking of
00:43:51 <Korollary> you guys realize that this line of thought mutilates sex drive?
00:44:05 <augur> http://www.xkcd.com/435/
00:44:06 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
00:44:21 <roconnor> lament: mathematics and computer science are really the same.
00:44:25 <augur> i think CS is over to the right there too.
00:44:26 <mmorrow> Korollary: "mutilates" can be good or bad, you'll have to be more specific
00:44:29 <ivanm> Korollary: you of course assume that those people who bother to spend time here discussing such things will ever make use of such a thing...
00:44:35 <lament> roconnor: and philosophy!
00:44:36 <augur> ignoring machines, ofcourse.
00:44:47 <ivanm> roconnor: oh? I thought CS was a subset/subgroup/sub-whatever of maths...
00:44:53 <augur> formal linguistics is over to the right as well.
00:45:00 <lament> CS is math for the mildly retarded
00:45:06 <augur> lament: lolno.
00:45:09 <augur> :P
00:45:16 <mmorrow> ivanm: i'd say with nonempty intersection
00:45:22 <Korollary> I am offended as a seriously retarded person
00:45:22 <roconnor> lament: To be more specific, a large chunck of mathematics is computer science, and the remaining bit is philosophy.
00:45:30 <lament> roconnor: hehe
00:45:41 <roconnor> I don't care for philosophy
00:45:48 <ivanm> roconnor: I say there's more...
00:45:55 <ivanm> there's that weird "real-world" stuff :s
00:46:04 <roconnor> ivanm: more what?
00:46:09 <roconnor> oh
00:46:19 <roconnor> there are things that are not philosophy and not computer science
00:46:25 <ivanm> yes
00:46:29 <roconnor> but that stuff isn't mathematics.
00:46:32 <ivanm> how bout say abstract algebra?
00:46:36 <augur> everything thats not philosophy or CS in math is just boring.
00:46:38 <ivanm> comp phys?
00:46:38 <lament> what like integrals lolz
00:46:42 <roconnor> ivanm: abstract algebra is largely CS.
00:46:43 <ivanm> *math phys
00:46:48 <augur> integrals are deeply philosophical.
00:46:49 <ivanm> roconnor: is it?
00:46:57 <ivanm> augur: in what way?
00:47:00 <lament> augur: how are they?
00:47:16 <roconnor> ivanm: yep.  Some of it is programmed here: http://corn.cs.ru.nl/
00:47:17 <lambdabot> Title: C-CoRN
00:47:21 <augur> zeno's paradox is a philosophical problem thats easily quashed thanks to integrals.
00:47:21 <lament> integrals are primarily an application to physics
00:47:36 <roconnor> ivanm: I expect most or all of it can be programmed.
00:47:52 <ivanm> doesn't mean it _is_ CS...
00:48:06 <ivanm> just that there's a CS formulation...
00:48:17 <augur> speaking of this sort of thing
00:48:26 <roconnor> ivanm: well, that depends on how you define these terms.  What I'm saying is a matter of my opinion.
00:48:26 <augur> Structure and Interpretation of Classical Mechanics
00:48:36 <augur> lagrangian mechanics taught from a scheme perspective
00:48:43 <ivanm> roconnor: *nod*
00:48:47 <augur> that is, building lagrangian mechanics _in scheme_
00:48:53 <augur> someone should write the haskell version
00:49:03 <lament> mmhm, great idea
00:49:04 <rwbarton> roconnor: in your opinion, is topology computer science or philosophy?
00:49:50 <rwbarton> (I suppose you can also consistently say it is not mathematics :)
00:49:55 <augur> honestly tho, i'd say math isnt philosophy. i'd say logic, math, CS, and formal linguistics all belong under the greater rubrick of Formal Systems
00:49:57 <chylli> 能不能在这里问一下关于Yi的用法问题啊. 感觉有些不对劲
00:50:01 <chylli> sorry
00:50:03 <roconnor> rwbarton: probably computer science, although it hasn't been worked out entirely yet.
00:50:21 <augur> which really isnt philosophy at all
00:50:44 <ivanm> augur: logic could be considered philosophy...
00:50:48 <chylli> can I ask some questions about Yi editor? I can't use M-x command to run any command
00:50:49 <augur> i disagree
00:51:01 <augur> APPLICATION of logic, sure
00:51:10 <lament> logic is philosophy for the mildly retarded
00:51:17 <augur> how logic provides insights, its limitations, etc., sure
00:51:31 <augur> but logic just in terms of the pure formalism of it, no.
00:51:36 <mmorrow> "logic" is ancient
00:51:42 <augur> once you start talking about what these things /mean/, definitely
00:51:49 <lament> Korollary: (no offence)
00:51:52 <roconnor> examples of mathematics that I would probably consider philosophy are things like the theory of non-recursive Turing degrees and perhaps inner model theory.
00:51:58 <augur> the MEANING of logic is tightly interwoven with philosophy
00:52:07 <augur> or something like that
00:52:31 <roconnor> As I understand it all of science / math started as philosophy
00:52:31 <ivanm> especially since logic can't be proven without using logic, which is thus a philosophical conundrum ;-)
00:52:40 <augur> roconnor: lolno.
00:52:43 <ertai> @type \f x y -> f x . f y
00:52:45 <lambdabot> forall t b. (t -> b -> b) -> t -> t -> b -> b
00:52:46 <lament> I am hungry. Therefore, I eat! QED
00:52:49 <roconnor> but when subjects become well understood they branch off of philosophy
00:52:59 <augur> mathematics started as figuring out how to plant your vegetable fields along the nile.
00:53:07 <rwbarton> roconnor: but you can still get PhDs in them :)
00:53:08 <roconnor> and philosophy just gets the left over crappy bits.
00:53:10 <ertai> does the previous function reminds you some well known combinator ?
00:53:15 <mmorrow> ancient in the sense of being old and crusty
00:53:30 <roconnor> I'm expecting the philosophy of language to branch off soon.
00:53:31 <augur> science i guess sort of did start as philosophy tho. back then there was no real distinction
00:53:35 <mauke> ertai: (.) `on` f
00:53:36 <dolio> @type on (.)
00:53:37 <augur> but math definitely not.
00:53:38 <lambdabot> forall a a1. (a1 -> a -> a) -> a1 -> a1 -> a -> a
00:53:42 <roconnor> and I think that will be the end of useful philosophy.
00:53:48 <lament> augur: can you imagine, there was time with no mathematics? How did they live?
00:53:55 <augur> philosophy of language is quite useless as it is ;)
00:53:57 <mauke> @djinn (t -> b -> b) -> t -> t -> b -> b
00:53:57 <lambdabot> f a b _ c = a b c
00:54:03 <augur> linguistics > philosophy of language
00:54:05 <ertai> mauke,dolio: thanks
00:54:15 <augur> lament: they didnt pay taxes, thats for sure!
00:54:15 <ertai> @src on
00:54:15 <roconnor> augur: I see potential.  Perhaps it won't bear out.
00:54:15 <lambdabot> (*) `on` f = \x y -> f x * f y
00:54:27 <augur> philosophy of language is annoying.
00:54:34 <augur> especially continental versions
00:54:39 <augur> e.g. Derrida et al.
00:54:40 <papermachine> phil/lang rocks.
00:55:05 <roconnor> augur: sure, but semantics of natural language is pretty annoying :)
00:55:08 <augur> ::brandishes my theoretical syntactician button::
00:55:16 <augur> natural language semantics is FUN dude cmon! :o
00:55:28 * papermachine brandishes his mathematician/philosopher lapel pin.
00:55:37 <roconnor> doesn't the philosophy of language try to give semantics to natural language?  I'm not an expert.
00:55:42 <augur> ive set up a task for myself this summer to recreate Semantica and Syntactica
00:55:44 <lament> if the slogan of quantum mechanics is "Shut up and calculate", the slogan of linguistics ought to be "Shut up and TALK!"
00:55:45 <augur> roconnor: no
00:55:45 <mauke> PILLOW FIGHT
00:55:52 <augur> philosophy of language tries to understand the meaning of meaning
00:55:53 <papermachine> lament, LOL
00:55:56 <hansfbaier> there seems to be a reason we all use natural languages here (except lambdabot that is....)
00:55:56 <roconnor> augur: well, there is my problem.
00:56:01 <augur> formal semantics tries to talk about natural language semantics
00:56:10 <roconnor> augur: what's the difference between meaning and semantics?
00:56:18 * roconnor can't beleive he is asking this question
00:56:26 <augur> semantics is a rigidly defined notion
00:56:35 <papermachine> meaning is somewhat harder to get at.
00:56:38 <roconnor> what does semantics mean?
00:56:41 <augur> "meaning" is vague and spotty and the meaning of meaning is itself tricky
00:56:46 <augur> semantics has various interpretations
00:56:51 <hansfbaier> there is semantics that is formalizable and there is semantics which escapes every cleverly designed formalism
00:56:52 <augur> truth conditional semantics, for instance
00:56:55 <lament> semantics has various semantics
00:57:01 <papermachine> Which is why we need to give the continentals the chance for a good ol' Oxford try.
00:57:16 <augur> TC semantics is all about what must be true for the sentence to be true, etc.
00:57:17 <augur> e.g.
00:57:22 <augur> whatever "meaning" is
00:57:28 <hpaste>  dolio annotated "unboxing" with "benchmark results" at http://hpaste.org/8411#a4
00:57:30 <roconnor> well, I doubt the smantics of natural languge are formal.
00:57:31 <augur> regardless of whatever meaning is
00:57:37 <augur> you know when a sentence is true if you understand what it means
00:57:43 <augur> roconnor: oh you'd be surprised
00:57:47 <augur> formal semantics is pretty hardcore
00:57:55 <augur> its all predicate logic and set theory
00:58:03 <augur> atleast in possible-worlds semantics
00:58:06 <roconnor> what are the semantics of "I am lying?"
00:58:32 <augur> it'd be a truth condition
00:58:45 <augur> precisely what i dont know
00:58:57 <roconnor> what is a truth condition?
00:58:59 <augur> im not terribly familiar with progressives
00:59:22 <augur> but i can try
00:59:35 <augur> ofcourse you get into issues like self referentiality which is tricky and i dont know how to handle ;)
00:59:52 <roconnor> right
00:59:56 <roconnor> neither to I
01:00:19 <roconnor> which is why I was looking to the philosophy of language to answer questions like that.
01:00:35 <augur> philosophy of language doesnt touch that sort of thing
01:00:41 <augur> not that ive experienced anyway
01:01:10 <roconnor> I should sleep
01:01:15 <augur> night
01:01:57 <hansfbaier> augur: try a fixed point combinator :)
01:02:18 <augur> in natural language semantics?
01:02:21 <augur> goodness no
01:02:22 <augur> :P
01:13:25 <dancor> when i run 'runplugs' manually and type like 4 in there
01:13:34 <dancor> i get     Failed to load interface for `L':
01:14:47 <dancor> sjanssen: do you know what L is in runplugs
01:15:00 <Saizan> dancor: L is the module of imports
01:15:45 <dancor> maybe it's not finding State/
01:16:15 <Saizan> you need it compiled in the current working directory
01:17:12 <Saizan> see the build script
01:17:37 <dancor> oh.  wow.  hah
01:19:25 <chr1s> dcoutts_: ping
01:19:57 <dancor> ~ ghc -v0 -c -O2 -odir . -hidir . State/L.hs
01:20:02 <dancor> State/L.hs:4:0:  error: imports.h: No such file or directory
01:20:05 <dancor> but it's there
01:20:30 <czakey> copy it
01:20:32 <dancor> where
01:20:36 <dancor> i tried to State/
01:20:43 <czakey> just a moment
01:20:48 <czakey> to State
01:20:51 <czakey> yup
01:20:51 <dancor> oh
01:21:31 <sjanssen> dancor: oh, add an -I . to that
01:21:44 <sjanssen> RunPlugs might be slightly broken at the moment
01:23:23 <dancor> i can't find Data.Number.Natural
01:23:31 <dancor> packagewise
01:23:50 <Saizan> ?hackage numbers
01:23:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
01:23:53 <Saizan> iirc
01:26:11 <dancor> success!
01:28:32 <czakey> gratz ;)
01:38:56 <Deewiant> ResourceVanished (the IOError equivalent of SIGPIPE) seems to fail all the exception predicates, do I need to grep the error message for 'broken pipe' or how should I recognize it
01:41:04 <dancor> join seems to be silently failing though, any tips
01:41:13 <dancor> my lambdabot's join command
01:42:21 <dancor> oh i think it's a privalege thing
01:44:55 <amaron> what is the best way for reading binary serialized structured data?
01:45:28 <amaron> on the other side I have packed data with python and struct.pack
01:46:10 <Saizan> ?hackage binary -- amaron
01:46:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary -- amaron
01:46:19 <amaron> I tried with Data.Binary
01:46:33 <Saizan> but?
01:46:41 <amaron> numeric data are ok, but strings are messed up
01:47:38 <amaron> in python you specify stingth len, but in haskell i only get chunks of that string
01:47:43 <Saizan> you should use the Get monad directly if you've a fixed external format
01:48:23 <amaron> I see, thanks Saizan, I'm going to try that
01:51:09 <pjdelport> amaron: how did you pack the data in Python?
01:53:12 <amaron> pjdelport: i.e. struct.pack("!H5sII", small_int, some_string, int1, int2)
01:54:06 <pjdelport> is some_string always 5 bytes?
01:54:37 <amaron> sometimes is, but also i have packet with different lenght
01:54:57 <amaron> with header in which is data length, then data itself
01:55:23 <pjdelport> amaron: well, 5s will always pack exactly 5 bytes
01:55:51 <pjdelport> if some_string is more, it will only pack the first five bytes
01:56:11 <amaron> in this case yes, but thats just a header, rest of data comes after
01:57:32 <amaron> then comes data = struct.pack("%is" % data_len, data)
01:57:42 <amaron> then another packet with header and data, etc
01:58:22 <amaron> as you may guess its a custom network protocol done in python
01:58:38 <amaron> which i want to replace with haskell code
01:58:44 <pjdelport> amaron: data = struct.pack("%is" % data_len, data) is a long way to write the identity function :)
01:59:11 <pjdelport> you can just write out the string directly, in that case
01:59:53 <pjdelport> you'll still need to communicate len(data) separately, though
02:00:02 <pjdelport> for Haskell to read
02:00:23 <amaron> yes, you are right, i wrote it wrong
02:01:04 <amaron> python code isnt problem here, it works, i'm just having trouble rewriting it in haskell
02:01:15 <amaron> where im still noob
02:01:34 <BeelsebobWork> @hoogle [a] -> Maybe a
02:01:34 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
02:01:34 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
02:02:11 <quicksilver> amaron: the Get monad from Data.Binary is the right tool, I htink.
02:02:46 <amaron> quicksilver: thx, I'm just trying to figure out how to use it
02:03:35 <amaron> haskell is same time the best and weirdest thing i found so far in programming
02:04:00 <mmorrow> amaron: yes!
02:04:07 <Saizan> amaron: ever used a parser monad? it's similar
02:04:30 <mmorrow> amaron: and it helps you create bester and weirdester things!
02:04:46 <sms__> hi guys,is there a way to shorten this:
02:04:50 <sms__>                          fe <- doesFileExist (path)
02:04:50 <sms__>                          if fe
02:05:13 <quicksilver> sms__: no, not really.
02:05:25 <amaron> :)
02:05:31 <quicksilver> short of writing a function version of if
02:05:52 <sms__> k, thanks quick
02:10:42 <Mr_Awesome> does anyone else feel like Ix and Enum partially overlap in an arbitrary and annoying manner?
02:14:58 <quicksilver> Mr_Awesome: well I don't think it's arbitrary but I do think it's annoying.
02:15:19 <chr1s> sms__: there is a when function
02:15:35 <quicksilver> chr1s: that takes a Bool though
02:15:39 <quicksilver> chr1s: not an (m ool)
02:15:43 <quicksilver> chr1s: not an (m Bool) I mean
02:15:55 <chr1s> quicksilver: you're right.
02:16:11 <chr1s> I tend to use a function mif a lot, which is a monadic if.
02:16:47 <chr1s> something like mif x l r = x >>= (\cond -> if cond then x else r)
02:16:54 <Associat0r> is there a visual haskell for vs 2008?
02:17:03 <chr1s> err, that should be if cond then l else r
02:17:04 <Mr_Awesome> quicksilver: whats bugging me atm is that all Ixs clearly make use of a "succ" function, yet none is defined. and apparently tuples aren't Enums
02:19:36 <dolio> > 1120045072 / 1024^3
02:19:38 <lambdabot>  1.043123260140419
02:20:51 <chr1s> @let mif x l r = x >>= (\c -> if c then l else r)
02:20:52 <lambdabot> Defined.
02:20:54 <chr1s> @type mif
02:20:56 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
02:21:02 <dolio> That's a lot of bytes allocated.
02:23:19 <dcoutts> chr1s: pong
02:24:26 <dibblego> dcoutts, in the Applicative paper, there is a mention of some unpublished work by you regarding Applicative over accumulating errors; is there a reference for that?
02:25:09 <dcoutts> bos, dons: yeah, we need advice on what to do about prof -auto/-auto-all
02:25:16 <dcoutts> newsham: pong
02:25:46 <dcoutts> dobblego: yeah, I've got the reference, lemme find it for you...
02:26:04 <dibblego> dcoutts, that's great thanks (it seems I have reinvented something once again)
02:26:43 <mmorrow> omg if it's the wheel it too late!
02:26:55 <mmorrow> :)
02:27:01 <dcoutts> dobblego: it was something I presented at the student session of AFP back in '02
02:27:25 <dibblego> no, just error accumulation through an applicative functor (though, the paper says monoid, where I used semigroup, to allow (a, [a]) as a possibility)
02:27:50 <dcoutts> dibblego: http://web.comlab.ox.ac.uk/oucl/work/duncan.coutts/papers/arrows_for_errors.pdf
02:27:52 <lambdabot> http://tinyurl.com/5ortqt
02:27:58 <dibblego> excellent cheers!
02:28:00 <dcoutts> or slides http://web.comlab.ox.ac.uk/oucl/work/duncan.coutts/papers/arrows_for_errors_slides.pdf
02:28:01 <lambdabot> http://tinyurl.com/6mq4jv
02:30:07 <dcoutts> dibblego: so I called it <&>, but it's now called <*>
02:30:33 <dibblego> dcoutts, OK, thanks again; I'll read both in a bit (looking forward to it!)
02:31:58 <dcoutts> bos, dons: http://hackage.haskell.org/trac/hackage/ticket/200
02:31:59 <lambdabot> Title: #200 (Allow more convenient use of ghc profiling options -auto and -auto-all) -  ...
02:34:04 <dcoutts> bos, dons: the point is we cannot make it the default, or at least we need to support both ways, compiling for profiling this package, or compiling for profiling support
02:35:53 <jansz> pl unfoldr (\(f1,f2) -> Just (f1,(f2,f1+f2))) (0,1)
02:36:14 <quicksilver> Mr_Awesome: the basic function for Ix's is "range"
02:36:41 <quicksilver> Mr_Awesome: an Enum instance for tuples would only make sense for bounded types.
02:37:19 <jansz> @pl unfoldr (\(f1,f2) -> Just (f1,(f2,f1+f2))) (0,1)
02:37:20 <lambdabot> unfoldr (uncurry ((Just .) . liftM2 (.) (,) (ap (,) . (+)))) (0, 1)
02:37:48 <mm_freak_work> > map fst $ iterate (\(a,b) -> (b, a+b)) (0,1)
02:37:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:37:54 <mm_freak_work> @pl map fst $ iterate (\(a,b) -> (b, a+b)) (0,1)
02:37:55 <lambdabot> map fst (iterate (uncurry (ap (,) . (+))) (0, 1))
02:38:29 <mm_freak_work> @src ap
02:38:29 <lambdabot> ap = liftM2 id
02:39:10 <mmorrow> > fix ((0:) . scanl (+) 1)
02:39:11 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:39:42 <mmorrow> my favorite haskell one liner as of yesterday => fix ((0:) . scanl (+) 1)
02:40:01 <mm_freak_work> hmm
02:40:04 <mm_freak_work> interesting solution
02:40:29 <mmorrow> i'm not sure who's, but it's geniush
02:42:07 <Dae> Haskell, the language with a thousand fibonachi implementations
02:42:44 <mm_freak_work> and a thousand factorial implementations
02:43:21 <mm_freak_work> http://www.willamette.edu/~fruehr/haskell/evolution.html
02:43:22 <lambdabot> Title: The Evolution of a Haskell Programmer
02:43:50 <Dae> heh, read it before, it's still great :)
02:46:45 <povman> cabal is being a pest
02:46:55 <povman> i get ghc-6.8.2: unrecognised flags: -F/Users/lukeworth/Library/Frameworks for zlib
02:47:21 <dcoutts> hmm, I think I've seen that before
02:47:31 <dcoutts> so where is that flag coming from?
02:47:40 <povman> command was: /usr/local/bin/ghc -c -package base-3.0.1.0 -package bytestring-0.9.0.1 -F/Users/lukeworth/Library/Frameworks dist/build/Codec/Compression/Zlib/Stream_hsc_make.c -o dist/build/Codec/Compression/Zlib/Stream_hsc_make.o
02:48:04 <povman> is there a way of changine the inputs?
02:48:07 <povman> *flags
02:48:09 <dcoutts> ah, hsc2hs is calling ghc with -F
02:48:13 <dcoutts> right?
02:48:20 <dcoutts> cabal is calling hsc2hs
02:48:27 <povman> i think something like that.
02:49:10 <dcoutts> wait, no, cabal does not pass -F to hsc2hs
02:49:14 <dcoutts> check it with -v
02:49:24 <dcoutts> cabal build -v
02:49:33 <povman> ("/usr/local/bin/hsc2hs",["--cc=/usr/local/bin/ghc","--ld=/usr/local/bin/ghc","--cflag=-package","--cflag=base-3.0.1.0","--cflag=-package","--cflag=bytestring-0.9.0.1","--lflag=-optl-lz","-o","dist/build/Codec/Compression/Zlib/Stream.hs","Codec/Compression/Zlib/Stream.hsc"])
02:49:47 <dcoutts> I think I remember now, hsc2hs is inventing that flag all one its own
02:49:49 <dcoutts> and it's wrong
02:49:55 <dcoutts> because it's not talking to gcc
02:49:57 <povman> ew.
02:49:59 <dcoutts> it's talking to ghc
02:50:48 <dcoutts> I know cabal is telling hsc2hs to use ghc as cc, but hsc2hs would have done that anyway
02:51:00 <povman> does that mean i should use -fvia-c or something?
02:51:27 <dcoutts> wouldn't change anything
02:51:48 <povman> is that a bug then?
02:51:52 <dcoutts> yes
02:51:54 <dcoutts> povman: ok, one thing to check..
02:52:21 <dcoutts> povman: if you run the above command by hand, but leave out --cc=... , then do we still get the same problem?
02:52:41 <dcoutts> povman: ie we want to confirm that hsc2hs would be using ghc as cc anyway, even without cabal telling it to
02:53:35 <povman> yup, same error
02:53:45 <dcoutts> povman: this bug should probably be reported in the cabal and also ghc tracs
02:54:35 <dcoutts> povman: the flaw is that hsc2hs was designed to work with gcc but ghc's version of hsc2hs uses ghc as if it were gcc
02:55:51 <Dae> curious random question: is there an easy way to copy an array?
02:56:03 <ndm> @seen waern
02:56:04 <lambdabot> I haven't seen waern.
02:56:22 <opqdonut> Dae: it gets copied when a copy is needed :)
02:56:31 <opqdonut> or do you mean a mutable array?
02:56:43 <dcoutts> povman: it does not appear to have been reported in the ghc trac either
02:56:49 <povman> http://hackage.haskell.org/trac/hackage/ticket/189
02:56:50 <lambdabot> Title: #189 (Handle framework paths (-F) in Cabal) - Hackage - Trac
02:56:51 <povman> is this it?
02:56:56 <Dae> yeah, or... a diffArray rather, that I need to use in 2 threads at one time
02:57:22 <dcoutts> povman: no, that's not the same
02:59:24 <quicksilver> strange there doesn't seem to be a copy primitive
02:59:30 <quicksilver> I guess you can do thaw . freeze
03:00:33 <povman> dcoutts: why a cabal ticket?
03:01:12 <dcoutts> povman: mm, well maybe it's only ghc
03:01:30 <povman> http://hackage.haskell.org/trac/ghc/ticket/2383
03:01:32 <lambdabot> Title: #2383 (hsc2hs puts -F on call to ghc) - GHC - Trac
03:01:32 <dcoutts> povman: but I'd like to change the way we call hsc2hs to only use gcc, not ghc
03:01:51 <Dae> quicksilver: hmm ok, seems a bit of a hack, but ;)
03:02:05 <quicksilver> Dae: yes, it seems odd to me.
03:04:10 <Dae> ok, second odd question of today: is there a way to make one class an instance of another?
03:04:35 <povman> Dae: ...
03:04:44 <povman> you could use TH
03:05:02 <quicksilver> Dae: classes can't be instances.
03:05:06 <quicksilver> Dae: types are instances.
03:06:40 <quicksilver> Seems like the -cafe has stopped sending me email.
03:06:42 <quicksilver> that's odd.
03:06:44 <Dae> quicksilver: I know, just wondering if there was a smart way around it
03:07:03 <povman> Dae: what are you trying to achieve?
03:07:52 <quicksilver> Dae: my point is, your question didn't make sense.
03:07:54 <Dae> povman: I have a class that I want to define for all IArray (Int,Int) Double
03:08:50 <quicksilver> instance IArray a (Int,Int) Double  > MyClass a
03:08:58 <quicksilver> oops, missing equal sign.
03:09:14 <povman> why do you need a class for that? can't you just define functions :: (IArray (Int,Int) Double) => .....
03:09:15 <quicksilver> that overlaps with every other instance, of course.
03:09:34 <quicksilver> but if it's what you want, then...
03:09:36 <quicksilver> win 13
03:09:39 <quicksilver> grr
03:09:52 <Dae> povman: but I already have the class, there are other instances of it, and the Array is just one
03:10:59 <Dae> also.... i might be silly enough to want it to implement num (*ducks to the incomming rocks thrown at any imbecile silly enough to do that*)
03:11:33 <povman> oki then quicksilver's suggestion, instance IArray a (Int,Int) Double  => MyClass a
03:12:55 <Dae> tells me that IArray is applied to too many arguements
03:13:12 <BeelsebobWork> I appear to be getting a runtime type error from a Haskell program :/
03:13:31 <BeelsebobWork> *** Exception: No match in record selector Scene.nName
03:14:22 <hpaste>  beb0s pasted "space leak" at http://hpaste.org/8418
03:14:40 <BeelsebobWork> http://hpaste.org/8417 the code that's generating it is here
03:15:00 <BeelsebobWork> so clearly the type checker agrees that nName' is getting passed a Node, and yet the error is saying it's a Scene
03:15:39 <povman> Dae: there's no such thing as IArray (Int,Int) Double
03:16:23 <povman> Dae: IArray's first argument is the array type constructor
03:16:27 <dancor> @let x = 4
03:16:28 <lambdabot> Defined.
03:16:29 <dancor> @let x = 5
03:16:30 <lambdabot> <local>:3:0:     Multiple declarations of `L.x'     Declared at: <local>:2:0 ...
03:16:32 <dancor> wat
03:18:11 <ndm> BeelsebobWork: what is the data type declaration? is nName a record selector?
03:18:25 <BeelsebobWork> ndm: yes, it's a record selector of Node
03:18:28 <BeelsebobWork> not of Scene
03:19:58 <povman> Dae: maybe you meant IArray DiffArray Double?
03:20:16 <ndm> BeelsebobWork: hpaste the data type of Node?
03:20:19 <Dae> povman: Right, ofcourse... but wouldn't (IArray a Double) work then?
03:20:37 <povman> i guess...
03:20:50 <povman> instance (IArray a Double) => MyClass a
03:21:21 <mm_freak_work> Dae: it does, but requires an extension
03:21:22 <hpaste>  beelsebob annotated "(no title)" with "definition of types" at http://hpaste.org/8417#a1
03:21:29 <BeelsebobWork> there you go ndm
03:21:47 <povman> mmf
03:21:56 <povman> mm_freak_work: which?
03:22:04 <Dae> mm_freak_work: I'm using so many already, it's not a problem
03:22:23 <mm_freak_work> povman: dunno…  GHC will tell you, when you compile it
03:22:32 <ndm> BeelsebobWork: Add a trace around nName', it may just be a GHC error message but
03:22:42 <Dae> povman:  -XFlexibleContexts according to ghc
03:22:49 <povman> excellent.
03:23:11 <povman> Dae: what is your class ? it seems very wonderful and useful.
03:23:42 <BeelsebobWork> ndm: I'm not sure what the trace is meant to show
03:23:44 <Dae> povman: It's more than one actually, but the main one is "Num", it's a matrix library
03:24:07 <ndm> BeelsebobWork: what the value you are passing to nName is
03:27:56 <steven_ashley> can anyone enlighten me as to why the collections-avl etc were removed from hackage? They were added by GwernBranwen on the 17th and was keen to have a look at them.
03:28:07 <steven_ashley> I was*
03:28:55 <rwbarton> BeelsebobWork: I think you're passing nName' a value like InputNode foo or OutputNode bar
03:31:40 <BeelsebobWork> rwbarton: as it turns out, yes, I'm a moron :)
03:31:41 <BeelsebobWork> thanks
03:32:46 <BeelsebobWork> I had been parsing the error incorrectly
03:33:47 <chr1s> ndm: so when will we have hoogle for hackage? ;)
03:34:42 <steven_ashley> dw, was mentioned here ﻿in the logs http://tunes.org/~nef/logs/haskell/08.06.18 '13:12:16 <dons>'
03:35:02 <ndm> chr1s: a couple of months - there is no type search or web version, but the code is all set up to do it
03:35:13 <chr1s> ndm: nice!
03:35:59 <chr1s> ndm: have you decided yet what you're going to do after the SoC? Found a new job yet?
03:40:09 <ndm> chr1s: still trying - have been for an interview for a 4 month placement, and need to find a permanent job in Cambridge either Sept or Jan
03:40:20 <ndm> (if anyone wants to make an offer, please do so!)
03:41:22 <chr1s> ndm: so you're going to the industry?
03:41:47 <jbapple> What's the standard operating procedure for optional dependencies for libraries?
03:42:03 <ndm> chr1s: no, i'm looking for something that pays money in Cambridge, I'd prefer a research position, if one was available
03:42:20 <jbapple> I have a library that is a comonad, but I don't want it to be dependent on category-extras to install
03:43:30 <ndm> jbapple: i don't think Cabal supports that particularly well :( - i've asked before
03:43:57 <ndm> jbapple: the solution suggested to me was to make an additional cabal, my-library-comonad, which depends on both and gives the instance
03:44:01 <ndm> (which is quite painful)
03:44:07 <chr1s> ndm: ah. well, good luck then. =)
03:44:20 <quicksilver> it's quite a hard problem.
03:44:23 <quicksilver> in my opinon.
03:44:29 <jbapple> That's a potentially 2^n solution (for n typeclasses)
03:44:37 <jbapple> youch
03:45:19 <ndm> jbapple: worse than that, if you library doesn't export the necessary goodness you need to break the abstraction as well
03:45:42 <dcoutts> the alternative is not pleasant either
03:46:00 <ndm> instances kind of cut accross types and classes in a bad way once you have packages
03:46:11 <dcoutts> you can say that providing the comonad instance is an optional feature of your package
03:46:51 * jbapple looks up optional features in cabal
03:46:54 <dcoutts> if flag(provide-comonad-instance) { other-modules: The.One.That.Exports.Said.Instance }
03:46:59 <dcoutts> but! it's not nice
03:47:13 <dcoutts> if I need that instance, how can I say that I depend on it?
03:47:15 <dcoutts> I cannot
03:47:32 <dcoutts> you can depend on packages, not "oh this package built in that way"
03:47:40 <quicksilver> we'd need subpackage dependencies
03:47:42 <quicksilver> feature dependencies
03:47:55 <dcoutts> which is better just as packages
03:47:59 <quicksilver> ...but then, what if two packages depend on conflicting features! nightmare.
03:49:28 <dcoutts> for the case of classes and instances, what you want really is to be able to provide an instance without requiring all clients depend on that class
03:49:36 <dcoutts> but if they do, then they get the extra instance
03:50:21 <dcoutts> but then how do you compile the package that provides the class instance? that package has to be available
03:51:00 <ndm> @seen vincenz
03:51:00 <lambdabot> vincenz is in #haskell. I last heard vincenz speak 1d 15h 31s ago.
03:52:35 <jbapple> How does hackage deal with optional features?
03:53:13 <dcoutts> jbapple: I'm not what question you're asking specifically
03:53:54 <jbapple> dcoutts: There might be a type error there.
03:54:44 <dcoutts> jbapple: you mean if a package requires your optional instance?
03:54:58 <jbapple> I've never built a package before, so I don't have a command of all the jargon
03:55:33 <jbapple> dcoutts: I *think* I mean if a package provides an optional instance, how is that displayed on hackageDB
03:55:41 <dcoutts> jbapple: it's not really
03:56:00 <Deewiant> Is the only way to identify an errnoToIOError IOError to construct your own IOError and compare using the Eq instance? Is there no way to compare the Errnos directly?
03:56:25 <dcoutts> jbapple: it's kind of visible if you look at the .cabal file, but that info is not displayed on the main package page.
03:56:38 <dcoutts> jbapple: because we kind of expect packages to present one interface
03:56:46 <jbapple> dcoutts: How is your "﻿provide-comonad-instance" set?
03:57:08 <dcoutts> jbapple: my point was, it's not a good use of the 'optional feature' system.
03:57:38 <quicksilver> jbapple: the person who builds the package can request flags be on or off.
03:57:57 <dcoutts> jbapple: optional features make some sense for progs aimed at end users, like an optional gui. but it is not good practise to change the interface of a library package based on flags/features.
03:58:01 <quicksilver> jbapple: but, also, cabal will not enable flags which dpened on packages whic aren't present.
03:58:25 <jnordenberg> sry if off topic, does anyone know of a programming language with subtypes which allows me to express the type "T but not (U <: T)"?
03:58:27 <dcoutts> quicksilver: well, sort of. cabal-install might just decide to install the ones that are not present
03:59:19 <dcoutts> jnordenberg: not that I'm aware of. 'not' types sound a bit scary :-)
03:59:21 <quicksilver> jnordenberg: well normally we say T <: T
03:59:28 <opqdonut> yeah
03:59:29 <quicksilver> jnordenberg: so that's not possible ;)
04:00:05 <opqdonut> but for example for Ref T <: Ref U one has to have U<:T and T<:U (reading and writing)
04:00:10 <opqdonut> so effectively U=T
04:00:34 <dcoutts> jbapple: here's an example. the 'base' package exposes more modules if you build it with ghc (modules GHC.*) but we consider that a legacy hack and a bit evil. We do not encourage it.
04:01:15 <dcoutts> jbapple: conditionally defining instances is pretty similar to conditionally exposing modules. It's a bit evil.
04:01:45 <jbapple> jnordenberg: Have you tried Scala?
04:01:53 <Deewiant> actually, scratch that - is there /any/ way to see what Errno value an IOError corresponds to?
04:02:13 <jnordenberg> jbapple: yes you can't express it in Scala
04:02:15 <dcoutts> jbapple: so your best bet is either to just depend on the package that defines the class or to have another package with the instance. Obviously the latter is a bit unpleasant, to have a tiny package.
04:02:40 <dcoutts> jbapple: now that we have automatic package dep resolution it's not that bad to just add the extra dependency. It's no more work for your users.
04:03:09 <jnordenberg> sometimes it's useful to express "T or some subtype of T but not U", i just wondered if there are some papers on this
04:03:57 <jbapple> jnordenberg: Here's my attempt in pseudocode: (U, (∀ g: * -(+)-> * . g U -> g T) -> (﻿∀ x . x))
04:03:58 <quicksilver> @index errnoToIOError
04:03:58 <lambdabot> Foreign.C.Error, Foreign.C
04:04:11 <mattam> jnordenberg: look at intersection types. You can say T & ¬ U in some type systems like the one of CDuce.
04:04:13 <jbapple> See http://blog.jbapple.com/2007/11/leibniz-and-liskov.html
04:04:16 <lambdabot> Title: Everyone Else is Crazy: Leibniz and Liskov
04:04:35 <jbapple> -(+)-> means covariant, which I think you can say in Scala
04:04:48 <jnordenberg> jbapple: argh, you lost me in type syntax space :)
04:04:55 <quicksilver> Deewiant: I think errnoToIOError is lossy.
04:05:02 <beb0s> can anyone help me in avoiding memory leak in my code http://hpaste.org/8418 ?
04:05:03 <quicksilver> Deewiant: I don't think IOError contains enough info.
04:05:04 <jbapple>  t -> (﻿﻿∀ x . x) means not t
04:05:42 <jbapple> dcoutts: thanks for the tips
04:06:04 <quicksilver> beb0s: what have you observed?
04:06:10 <quicksilver> beb0s: how have you identified the leak?
04:06:36 <jbapple> dcoutts: you're talking about cabal-install?
04:06:46 <jnordenberg> jbapple: ill check out CDuce, thanks
04:07:08 <jbapple> jnordenberg: No prob, but the CDuce tip was due to mattam :-)
04:07:08 <dcoutts> jbapple: right, it makes installing entire stacks of interdependent packages easy.
04:07:21 <jbapple> dcoutts: isn't it still in beta?
04:07:23 <jnordenberg> mattam: oh, thanks :)
04:07:35 <beb0s> quicksilver: i use a state monad to generate some objects
04:07:39 <ndm> @tell vincenz I'm sorry but I can't ICFP-constest this year :( - I have my PhD viva on the Monday, and will be travelling all Saturday and away with no internet connection all Sunday - making me rather useless!
04:07:39 <lambdabot> Consider it noted.
04:07:48 <dcoutts> jbapple: I released it a week ago and announced it yesterday.
04:08:04 <beb0s> quicksilver: but i think they're not being garbage collected after their use
04:08:50 <mattam> There's a beautiful paper by Castagna et al that was discussed on the TYPES mailing list recently about the set-theoretic notion of subtyping that you (seem to) need to express complementation/not.
04:08:52 <jbapple> dcoutts: so I shouldn't be afraid of "0.5"? :-)
04:09:21 <dcoutts> jbapple: well it's still got some rough edges I guess. There's still lots of features to add. But it does work.
04:09:32 <beb0s> quicksilver: thanks for your attenction, i'm quite a primer, i searched in the net for some infos about state monad and strictness but i couldn't found a way out
04:11:40 <chylli> dcoutts: where is downloaded packages by cabal fetch package ?
04:11:58 <beb0s> quicksilver: essentially i generate some trees randomly and i sum up their sizes. but i end up with my stack full of ints and trees
04:12:42 <chylli> I didn't find downloaded packages in ~/.cabal
04:13:40 <dancor> @let x = 6
04:13:40 <lambdabot> <local>:3:0:     Multiple declarations of `L.x'     Declared at: <local>:2:0 ...
04:13:49 <beb0s> quicksilver: more of them i generate more memory i use, so something is not being released
04:15:40 <hpaste>  amaron pasted "how to write this correctly?" at http://hpaste.org/8419
04:16:29 <Deewiant> quicksilver: I managed to do it by creating a global ePipeError = errnoToIOError "" ePIPE Nothing Nothing, and then using (==) `on` ioeGetErrorType
04:16:39 <Deewiant> which is quite kludgey but it works
04:18:01 <amaron> I still need help with binary serialization
04:18:20 <dcoutts> chylli: they get downloaded to ~/.cabal/packages/$server/
04:18:24 <amaron> http://hpaste.org/8419
04:18:46 <Deewiant> really the problem is that the IOErrorTypes themselves aren't exported, only the Errnos, but you can only go IOError -> IOErrorType and Errno -> IOError so there's an extra layer
04:18:57 <Deewiant> I might file a bug report when I get home
04:19:09 <pjdelport> amaron: the hpaste bot automatically announces pastes, btw
04:19:22 <quicksilver> beb0s: well I'd expect you to use more memory if you generate more trees
04:19:26 <quicksilver> beb0s: how is that surprising?
04:19:29 <chylli> dcoutts: I didnt find downloaded packages. weird
04:19:57 <amaron> pjdelport: ok, just used it for the first time
04:20:02 <quicksilver> amaron: if you're pasting code with an error, please also paste the error message :)
04:20:38 <dcoutts> chylli: you mean you still don't find them?
04:20:42 <quicksilver> amaron: getN doesn't appear to make any effort to store up the values it gets.
04:20:48 <quicksilver> it just throws them away.
04:21:13 <rwbarton> amaron: how about  getN n = replicateM n getWord8
04:21:36 <quicksilver> yes that was going to be my suggestion ;)
04:21:39 <beb0s> quicksilver: ok :-) i mean i'd like that (sum [0..n]) didn't require O(n) memory but O(1)
04:22:10 <dcoutts> chylli: under ~/.cabal/packages/hackage.haskell.org/ there is a directory for each package that has been downloaded and within each of those for the versions. If you have not downloaded anything then the dir will be empty except for the 00-index.tar(.gz)
04:22:10 <chylli> dcoutts: yes. seems it didnt download packages which has already installed.
04:22:25 <rwbarton> amaron: or use getBytes in Data.Binary.Get
04:22:28 <dcoutts> chylli: perhaps you were doing it all as root so there are none for your user
04:22:48 <chylli> dcoutts: think so, then it should in /root/.cabal ?
04:22:51 <chylli> dcoutts: ok ,thanks
04:22:59 <quicksilver> beb0s: sum [0..n] will *allocate* O(n) memory
04:23:07 <jnordenberg> mattam: semantic subtyping seems to be what im looking for, thanks for pointers
04:23:10 * dcoutts recommends using cabal install --root-cmd=sudo rather than sudo cabal install
04:23:14 <amaron> tnx, people, this is all fuzzy for me...
04:23:28 <quicksilver> beb0s: since it doesn't need it all at once, the GC can reclaim some as you go along.
04:23:37 <quicksilver> beb0s: and therefore it will only use O(1) at once.
04:23:53 <jbapple> What is the proper way to build Haddock documentation with cabal-install?
04:23:57 <HunterXHunter33> sounds very inefficient
04:24:06 <beb0s> quicksilver: thanks, I meant O(n) at once, that's what i'm observing
04:24:11 <jbapple> ~/.cabal/packages $ cabal haddock category-extras
04:24:12 <jbapple> cabal: No cabal file found.
04:24:12 <jbapple> Please create a package description file <pkgname>.cabal
04:24:26 <quicksilver> beb0s: well the GC won't run until it hits a certain threshold.
04:24:27 <dcoutts> jbapple: cabal haddock works like runghc Setup.hs haddock
04:24:38 <quicksilver> beb0s: and th GC only runs at particular times even when it runs.
04:24:50 <chylli> dcoutts: still found nothing.
04:24:57 <dcoutts> jbapple: perhaps you'd like to vote for this ticket: http://hackage.haskell.org/trac/hackage/ticket/206
04:24:59 <quicksilver> beb0s: can you be precise about what exactly you're observing
04:24:59 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
04:25:14 <jbapple> dcoutts: Will anything go wrong if I unpack the files in ~/.cabal/packages?
04:25:29 <dcoutts> jbapple: should be ok
04:25:30 <jbapple> dcoutts: thank you, yes, I would.:-)
04:25:48 <dcoutts> jbapple: add your comments to the ticket and add yourself to the ticket cc list
04:26:04 <litb> hello there
04:26:58 <mjk> i have a function f :: (Num a) => Maybe a ->a
04:27:05 <mjk> f Nothing = 0
04:27:27 <mjk> f (Just a) = read $ take 5 $ show a
04:27:46 <mjk> but it raises error, why?
04:28:00 <rwbarton> what is the error?
04:28:08 <Deewiant> ?type \(Just a) -> read $ take 5 $ show a
04:28:10 <lambdabot> forall t a. (Show t, Read a) => Maybe t -> a
04:28:35 <beb0s> quicksilver: ok, echo 10000 | ./test +RTS -sstderr shows 20,410,368 bytes maximum residency
04:28:44 <rwbarton> Oh, right.  You need a constraint of the form Read a
04:28:46 <mjk> rwbarton: Could not deduce (Read a) from the context (Num a)
04:29:05 <beb0s> quicksilver: with 20000 grows to 39,428,096 bytes maximum residency
04:29:29 <rwbarton> You don't get this problem with Show because Num is a subclass of Show
04:29:35 <beb0s> quicksilver: with 50000 it knocks out my laptop
04:29:47 <mjk> lambdabot: can't find forall
04:30:31 <beb0s> quicksilver: i'm doing sort of: sum $ map get_size $ evalState (replicateM n generator) initial_state
04:30:33 <Saizan_> mjk: ignore the "forall t a." part
04:31:21 <chylli> dcoutts: is it a bug ? cabal-install doesn't fetch packages those have been installed.
04:32:14 <dcoutts> chylli: it fetches packages that it will install, so if the packages were already instlled then there is no need to fetch them
04:32:48 <HunterXHunter33> ?src forall
04:32:49 <lambdabot> Source not found. You untyped fool!
04:33:01 <rwbarton> beb0s: Change Control.Monad.State.Strict to Control.Monad.State.Lazy
04:33:03 <dcoutts> chylli: eg, if you've got X11-1.4.1 installed and you ask to install xmonad, then it will not download the X11 tarball because it does not need to install that.
04:33:03 <beb0s> quicksilver: i think it's something like: execState (replicateM n $ modify (+1)) 0
04:33:04 <mjk> changed to f :: (Show a, Read a, Num a) => Maybe a -> a is OK
04:33:05 <HunterXHunter33> ?type forall
04:33:06 <lambdabot> Not in scope: `forall'
04:33:20 <mjk> thank all
04:33:26 <chylli> dcoutts: ok. the help info :  fetch        Downloads packages for later installation or study.
04:33:27 <chylli>  
04:33:41 <chylli> I thought I can fetch any packages to study :p
04:34:14 <dcoutts> chylli: ah, there may be a bug there. If you've already got the latest version it probably does not download anything.
04:34:23 <dcoutts> chylli: you can file that as a bug.
04:34:28 <beb0s> rwbarton: OMG, it works
04:34:46 <litb> hmm
04:34:52 <chylli> dcoutts: ok. thanks
04:34:54 <dcoutts> chylli: http://hackage.haskell.org/trac/hackage/newticket
04:35:22 <beb0s> rwbarton: why? i thought i was accumulating trunks of somethings
04:35:27 <dcoutts> chylli: because fetch uses the same dep resolution system as the 'install' command
04:35:44 <chylli> dcoutts: TICKET_CREATE privileges are required to perform this operation
04:35:49 <chylli> dcoutts: again :(
04:36:16 <dcoutts> chylli: if you do not have an account then either make one or use the guest account
04:36:33 <dcoutts> chylli: see the info on the front page: http://hackage.haskell.org/trac/hackage/wiki
04:36:35 <lambdabot> Title: Hackage - Trac
04:37:09 <beb0s> rwbarton: yes, it I use State.Lazy but drops stricts return $! memory goes O(n) again
04:37:56 <beb0s> rwbarton: *if I use
04:38:09 <rwbarton> beb0s: really?  I removed every strictness annotation in the program and got constant memory usage
04:38:23 <rwbarton> beb0s: but, I don't really understand what's going on
04:38:28 <rwbarton> beb0s: sorry :)
04:39:27 <Saizan_> f $! Foo x y z where Foo is a constructor should not have any noticeable effect
04:40:35 <pjdelport> amaron: having any luck?
04:43:48 <Saizan_> beb0s: i think with Control.Monad.State.Strict you were computing all the trees up front, instead of letting sum demand them, however you still need put $! (i + 1) to not accumulate thunks in the state
04:44:41 <Saizan_> also .Strict is not strict in the state, only in the "computation"
04:46:54 <mxc> are there any language extensions that would allow you to 'extend' an ADT?
04:47:12 <mxc> say i have data Blah =  Blah Int | Boo String
04:47:35 <mxc> maybe in some other file extend it with ... Foo Int Int or something
04:48:03 <mxc> as long as all matches against that ADT have a default (_) case, it should be 'safe'
04:48:18 <beb0s> rwbarton: thanks
04:50:04 <rwbarton> mxc: what happens if a third file extends it with Foo String (Int -> Int)?
04:50:18 <mxc> fair enough
04:50:27 <vixey> mxc: data types a la carte
04:50:47 <mxc> well, you could catch that
04:52:53 <quicksilver> mxc: there isn't a haskell extension for that
04:52:58 <quicksilver> mxc: ocaml has one, though.
04:53:19 <mxc> well, ocaml also has polymorphic variants
04:53:25 <mxc> unless that was what you were referring to
04:53:29 <rwbarton> I was going to say, ocaml's exceptions are sort of like that
04:53:57 <chylli`> question: I want to write a program using binary ordered tree, which module should I use ? Data.Tree ?
04:54:40 <pjdelport> mxc: http://lambda-the-ultimate.org/node/2700
04:54:41 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
04:56:26 <Saizan_> chylli`: you mean like a search tree?
04:57:05 <chylli`> Saizan_: yes,
04:57:36 <pjdelport> chylli`: Data.Map?
04:59:20 <pjdelport> Data.Tree supports general trees, but not so much ordering and balancing
05:00:26 <chylli`> pjdelport: ok, let me read it.
05:03:46 <quicksilver> mxc: that was indeed what I was referring to.
05:04:16 <mxc> are polymorphic variants on anyone's todo list for GHC?
05:04:22 <quicksilver> chylli`: data.map and data.set are specific examples of binary ordered trees
05:04:34 <quicksilver> mxc: It's a pretty far-reaching type system change.
05:04:44 <quicksilver> as far as I know there are no serious proposals.
05:05:20 <mxc> aren't polymorphic variants basically just syntactic sugar though?
05:05:52 <chylli`> quicksilver: yes. specific examples of Bst. but I think I cant use them directly. should I  write one for myself ?
05:09:04 <Saizan_> there are some AVL tree implementations on hackage
05:09:11 <quicksilver> chylli`: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AvlTree
05:09:13 <lambdabot> http://tinyurl.com/5t3nrl
05:09:24 <quicksilver> mxc: no, not at all.
05:09:36 <quicksilver> mxc: they're a completely different type system with sub/supertyping.
05:09:39 <quicksilver> AIUI.
05:10:04 <mxc> AIUI, it was basically away to imply the type definition
05:10:36 <mxc> as in your could just littler `Cons1  `C2 ... throughout your code and it sort of put together a type definition implied by your use of the constructors
05:10:56 * quicksilver shakes his head
05:11:06 <mxc> i could be very very wrong though
05:11:07 <quicksilver> you have have [< `C2] as a type
05:11:12 <quicksilver> and [> `C2]
05:11:24 <quicksilver> sub and supertypes
05:11:40 <quicksilver> "recording supporting at least these fields" "record support at most these fields"
05:13:26 <EvilTerran> you could mung it with typeclasses, but it wouldn't be pretty
05:13:30 <EvilTerran> see: Oleg
05:17:20 <levi13> Hi, I've been playing around with type level peano numbers. I wanted to write test with quick or smallcheck for some functions
05:17:37 <levi13> So, Ideally this would generate random peano numbers, but is this possible at the type level?
05:18:04 <quicksilver> EvilTerran: yes, I was thinking of a "first-class" implementation of polymorphic variants.
05:18:18 <quicksilver> EvilTerran: I'm aware of their encoding :) but it's not quite teh same.
05:19:16 <Saizan_> levi13: yes, with existential types
05:20:31 <levi13> Saizan_:  I do have some existentials around, but haven't managed to get them right for smallcheck tests
05:21:53 <jbapple> I have found a bug in a package. Should I report it to the maintainer only, or is there a trac for these sort of things?
05:22:01 <levi13> I was leaning towards a function like generateRandomPeano being impossible, because it will have a different return type for each peano number
05:22:04 <Saizan_> levi13: my idea was to get a random Integer from smallcheck, generate the corresponding type and pass it as an existential to the test, an example of this is in the "implicit configurations" functional pearl
05:22:38 <levi13> ah yes, I've been reading that one a bit :)
05:23:25 <Saizan_> jbapple: the .cabal file might list an home page, there's not a central trac for hackage
05:23:40 <byorgey> jbapple: which package?
05:23:44 <jbapple> Saizan_: thanks
05:24:14 <levi13> Saizan_: I do have reifyInt :: Int -> (forall n. ReflectNum n => n -> w) -> w (as in the paper)
05:24:19 <jbapple> byorgey: Stream-0.2.3
05:24:31 <jbapple> byorgey: It's not really a monad
05:24:46 <jbapple> I think it is a comonad
05:24:46 <levi13> Saizan_: but I'm not seeing how to work this with SmallCheck
05:24:58 <jbapple> Also, I'm not convinced of the Eq instance
05:25:09 <Saizan_> jbapple: it is a monad, but (>>=) is broken
05:25:23 <jbapple> Which can only return False or fail to terminate
05:25:40 <jbapple> Saizan_: What's a correct (>>=)?
05:26:36 <byorgey> well, interesting question, is Eq always supposed to represent *decidable* equality?
05:26:38 <hpaste>  levi pasted "Original attempt testing with type level peano numbers" at http://hpaste.org/8420
05:26:43 <Saizan_> jbapple: (Cons x xs) >>= f = Cons (head (f x)) (xs >>= tail . f)
05:27:19 <mattam> byorgey: I think so, if you have a function into bool.
05:27:43 <byorgey> it does seem logical, I suppose.  but there's nothing in the language to enforce that.
05:27:50 <mattam> Indeed.
05:28:43 <mattam> It's one place where codata/data distinction would be needed.
05:28:45 <levi13> I pasted some example code (hpaste.org/8420) and I can't work out whether reifyInt can help me
05:29:20 <levi13> because I also want SmallCheck to know it has to generate a Vector size e, with the size given by the random peano number
05:30:15 <jbapple> Saizan_: Do you want to email the maintainer, or do you want me to do so?
05:31:54 <Saizan_> jbapple: maybe it's better if you do since i'm not using that package anyway
05:32:02 <jbapple> Saizan_: ok
05:33:00 <jbapple> Saizan_: How did you derive the implementation of bind?
05:34:30 <Saizan_> jbapple: since liftMn has to emulate zipWithN, join must take the diagonal of the generated streams to be consistent
05:36:00 <Saizan_> the broken (>>=) had the tail in the wrong place, causing it to recurse forever
05:40:20 <lilachaze> is there a good description of what comonads are useful for somewhere?
05:42:14 <jbapple> Saizan: Is not the instance for lists x >>= f = concatMap f x
05:42:47 <byorgey> jbapple: indeed
05:42:52 <ToRA> @src [] (>>=)
05:42:52 <lambdabot> xs >>= f     = concatMap f xs
05:43:06 <jbapple> Saizan: Ah, but lists have a different return!
05:43:08 <jbapple> cool.
05:43:21 <Saizan> yeah
05:44:04 <pjdelport> lilachaze: http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html perhaps
05:44:05 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
05:44:10 <pjdelport> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Comonads
05:44:11 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/yyte4n
05:44:54 <pjdelport> lilachaze: many / most monads have corresponding comonads
05:46:06 * malcolmw wonders if no-one reads the papers referred to by Haddock documentation any more, cf. the ribbonsPerLine in Text.PP.HughesPJ
05:46:18 <rwbarton> the Stream monad is more like the (->) Int monad than the [] monad
05:46:48 <Syzygy|de> rwbarton: Is it like (->) Int, or is it like (->) Integer
05:46:49 <Syzygy|de> ?
05:47:43 <pjdelport> rwbarton: what's the relation?
05:47:59 <rwbarton> A stream of a is more or less a function from nonnegative integers to a
05:48:19 <rwbarton> s <---> \x -> s !! x
05:49:22 <rwbarton> Syzygy|de: I guess (->) Integer, if you have enough time to tell them apart :)
05:49:38 <Syzygy|de> :)
05:49:51 <Syzygy|de> rwbarton: Once you start skipping ahead, that time can come in a hurry.
05:50:07 <vixey> Int makes proofs much harder
05:50:36 <Syzygy|de> Say, for instance, read a binary stream with packets and headers, seeking a particular by the header and each package carrying about a megabyte of payload?
05:50:46 <Syzygy|de> Or, if that's still too slow, make it a gigabyte of payload?
05:51:16 <pjdelport> rwbarton: how does that relate to the [] comonad?
05:52:57 <pjdelport> rwbarton: or rather, what Stream monad do you mean?
05:53:32 <rwbarton> Syzygy|de: I guess it doesn't take so long after all.
05:53:39 <rwbarton> Prelude> :set +s
05:53:39 <rwbarton> Prelude> length $ take (10^9) $ repeat 0
05:53:39 <rwbarton> 1000000000
05:53:39 <rwbarton> (11.02 secs, 28058774432 bytes)
05:54:05 <vixey> > 10^9
05:54:06 <lambdabot>  1000000000
05:54:12 <vixey> > maxBound :: Int
05:54:13 <lambdabot>  2147483647
05:54:17 <vixey> > 2^32
05:54:18 <lambdabot>  4294967296
05:54:54 <rwbarton> pjdelport: the Stream monad instance that Saizan gave
05:56:30 <lilachaze> pjdelport: thanks for the pointers :)
05:57:08 <pjdelport> rwbarton: sorry, i got my wires crossed with the comonad discussion :)
06:02:05 <gwern> >     words "If on a winter's night a traveller"
06:02:06 <lambdabot>  ["If","on","a","winter's","night","a","traveller"]
06:02:06 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
06:02:25 <gwern> hee hee. osfameron is something of a calvino fan then, I suppose
06:02:27 <gwern> @messages
06:02:27 <lambdabot> sjanssen said 7h 43m 48s ago: mueval -e "Foreign.unsafePerformIO (readFile \"/etc/passwd\")"
06:02:33 <osfameron> gwern: yarrr!
06:03:19 <gwern> what really gets me about that is I had already tested such imports :(
06:03:34 <gwern> but I hadn't realized it was a security vuln
06:04:25 <gwern> barbie says: security is hard, let's go shopping (offline)!
06:04:33 <vixey> hehe
06:07:19 <FordCortina> what does CAFS stand for as in "memoising CAFS"? http://www.haskell.org/haskellwiki/Memoization
06:07:20 <lambdabot> Title: Memoization - HaskellWiki
06:07:36 <malcolmw> Constant Applicative Form
06:07:44 <FordCortina> thanks
06:08:28 <malcolmw> = a zero-arity function decl
06:32:13 <vixey> @check \l -> let homogenous l = l == (head . group) l in all homogenous (group l)
06:32:14 <lambdabot>  OK, passed 500 tests.
06:33:50 <vixey> How could you prove
06:33:51 <vixey> all homogenous (group l)?
06:34:13 <BeelsebobWork> @type compare `on` (+1)
06:34:14 <lambdabot> Not in scope: `on'
06:34:19 <BeelsebobWork> @hoogle on
06:34:20 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:34:20 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
06:34:20 <lambdabot> Data.Function :: module
06:37:08 <quicksilver> :t on
06:37:10 <lambdabot> Not in scope: `on'
06:37:13 <quicksilver> that's odd!
06:37:18 <quicksilver> it was in scope yesterday
06:37:21 * quicksilver peers around suspiciously
06:37:22 <vixey> @undef
06:37:23 <lambdabot> Undefined.
06:37:24 <vixey> :t on
06:37:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:37:36 <vixey> lambdabot is a buggy old thing
06:37:36 <quicksilver> !
06:38:32 <SamB_XP_> quicksilver: the Cale prelude is kept in L.hs...
06:38:51 <vixey> hey SamB
06:39:09 <SamB_XP_> yeah?
06:39:31 <vixey> could you paste your rle thing?
06:39:49 <quicksilver> :t (.)
06:39:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:40:01 <quicksilver> SamB_XP_: how does that affect "on" ?
06:40:27 <hpaste>  SamB pasted "RLE thing" at http://hpaste.org/8421
06:40:35 <vixey> thank you
06:40:47 <SamB> quicksilver: not sure
06:40:57 <SamB> is on standard now?
06:40:58 <quicksilver> no, me neither.
06:41:01 <quicksilver> yup.
06:41:04 <vixey> ah cool
06:55:28 <Snark> hmm... I can't find in "A Gentle Introduction to Haskell" where I have read that some named fields of a record where not exported if prefixed with _ or something like this :-/
06:56:11 <byorgey> Snark: really? I've never heard anything like that
06:59:37 <quicksilver> that is the heuristic used by some TH script or other
06:59:49 <quicksilver> which eliminates some record boilerplate
06:59:53 <quicksilver> I forget the details :)
07:01:47 <mm_freak_work> i'd wish an 'export' statement
07:02:06 <mm_freak_work> would be more convenient than the exports list in the module statement
07:02:13 <mauke> @users
07:02:14 <lambdabot> Maximum users seen in #haskell: 464, currently: 464 (100.0%), active: 14 (3.0%)
07:02:20 <vixey> not for readers
07:02:42 <FordCortina> when do you *really* need a state monad? its seems like they get used in place of let statements... but i prefer let statements
07:03:25 <Igloo> They get used in place of passing arguments explicitly
07:03:47 <Igloo> And no, you never need one, but you also never need datatypes, for example
07:05:42 <FordCortina> Igloo: yes i can see that. but datatypes make things clearer and imvho state monads do not (generally)
07:07:00 <quicksilver> FordCortina: state monads are mostly useful because they stop you making mistakes.
07:07:11 <quicksilver> FordCortina: and they make code slightly more compact.
07:07:25 <quicksilver> they don't stop you making all mistakes, obviosly:)
07:07:33 <quicksilver> there is a class of mistakes which state monads aim to prevent
07:07:35 <mm_freak_work> vixey: how is "module MyTypes (Type1, Type2, Type3, function1, function2, function3) where" more readable than "module MyTypes where" and then a list of 'export' statements?
07:07:49 <quicksilver> when you acddientally use s' instead of s''
07:07:51 <vixey> they are throughout the file
07:08:15 <mm_freak_work> vixey: i mean at the top of the file
07:08:41 <FordCortina> thanks quicksilver
07:09:02 <quicksilver> FordCortina: basically they force you to single thread the state
07:09:14 <mm_freak_work> for two or three exports, i agree that it's more compact in the module statement, but if you have lots of exports, it can get quite ugly
07:09:32 <quicksilver> FordCortina: avoiding problems where you pass the wrong version of the state to a subroutine, or forget to update your copy with what the subroutine returns.
07:09:57 <quicksilver> FordCortina: finally, they give you access to generic combinators which can be useful!
07:10:01 <quicksilver> FordCortina: like mapM
07:13:29 <FordCortina> @src mapM
07:13:29 <lambdabot> mapM f as = sequence (map f as)
07:16:04 <FordCortina> @info StateM
07:16:04 <lambdabot> StateM
07:17:22 <quicksilver> FordCortina: in the context of state, mapM lets you run a bunch of state actions one after another, correctly threading the state, and collecting the results.
07:17:33 <quicksilver> FordCortina: that would be a slight pain to do by hand.
07:17:37 <ToRA> > let next = State (head &&& tail) in evalState (mapM (maybe next return) [Just "hello", Nothing, Just "!", Nothing, Nothing]) $ words "Bob Say Hi"
07:17:38 <lambdabot>  ["hello","Bob","!","Say","Hi"]
07:17:41 <Botje> hello everyone
07:17:47 <Botje> my exam went swimmingly :)
07:18:16 <Snark> how can I make so a module doesn't export a function ?
07:18:17 <quicksilver> ToRA: cute worked example :)
07:18:25 <Botje> i'll try to hack that type system i talked about :P
07:18:27 <quicksilver> Snark: list everything apart from that one
07:18:33 <quicksilver> Snark: in the export list
07:18:40 <Snark> hmmm... didn't seem to work :-/
07:18:43 <Snark> ghci trick ?
07:18:55 <quicksilver> ?
07:19:07 <quicksilver> ghci can see functions even if they're not exported, yes
07:19:12 <quicksilver> that's for debugging convenience
07:19:12 <Snark> ok
07:19:18 <Snark> that explains :-)
07:19:31 <FordCortina> thanks quicksilver and ToRA
07:21:29 <Yoric[DT]> Hi
07:21:40 <Yoric[DT]> I'm not a Haskellite, so I have what may be a beginner question.
07:21:58 <Botje> Yoric[DT]: go ahead :)
07:22:12 <Yoric[DT]> I don't have the syntax handy, so please bear with me.
07:22:22 <Yoric[DT]> Let's assume I have an error monad.
07:22:36 * gwern thinks 'Haskeller' sounds betters. Haskellite just sounds sinister
07:22:37 <Yoric[DT]> I want to be able to raise two possible type of errors.
07:23:07 <Yoric[DT]> Do I need to define my error monad specifically for these two types of errors or can typeclasses do that for me?
07:23:08 <quicksilver> haskellite is a rare mineral believe to exist in surprising concentrations in oleg's bloodstream
07:23:13 <Yoric[DT]> :)
07:23:26 <Yoric[DT]> Careful, he also have large concentration of MLite.
07:23:28 <Botje> reminds me of bakelite :)
07:23:29 <Yoric[DT]> s/have/has/
07:23:35 <quicksilver> the standard error monad leaves the actual type of the error undetermined.
07:23:38 <Yoric[DT]> (or is that "caml-light ?")
07:23:39 <mar77a> there are what some call haskelords
07:23:42 <quicksilver> as it, it's a tyep variable
07:23:42 <FordCortina> quicksilver: i think i see what you mean. Although, I find when reading back such code that its not obvious what's happening to the state.
07:23:47 <quicksilver> so you can instantiate it later.
07:23:51 <Yoric[DT]> quicksilver: I realize that.
07:24:04 <Yoric[DT]> But you can only instantiate it with one type, can you?
07:24:06 <quicksilver> or leave it polymorphic, indeed
07:24:08 <Botje> Yoric[DT]: control.monad.error defines an Error typeclass
07:24:09 <Yoric[DT]> Not with two types at once.
07:24:22 <quicksilver> you can leave it polymorphic
07:24:26 <Yoric[DT]> Sorry, when I wrote "typeclass", I meant "monad transformer".
07:24:32 * Yoric[DT] is a bit tired.
07:24:36 <quicksilver> and possibly contrain it further
07:24:53 <Yoric[DT]> Ok, but let's assume I have a function f which may fail and produce a string.
07:25:06 <quicksilver> FordCortina: well yes, it's one of those thigns that's not obvious until you're used to it.
07:25:06 <Yoric[DT]> And a function g which may fail and produce, say, a pair of integers.
07:25:27 <Yoric[DT]> Now, I'm writing a function which needs to invoke first f and then g.
07:25:27 <quicksilver> then you will need a custom combinator to combine those actions
07:25:27 <FordCortina> quicksilver: that's true
07:25:33 <quicksilver> fortunately it's not too hard to do.
07:25:35 <Yoric[DT]> quicksilver: ok, that was my question.
07:25:40 <Yoric[DT]> Indeed, it's trivial.
07:25:47 <Yoric[DT]> But it may not be very scalable.
07:25:53 <quicksilver> you could "lift" them both into a context in which the error type is 'Either (Int,Int) String'
07:26:05 <quicksilver> :t mapErrorT
07:26:06 <lambdabot> forall (m :: * -> *) e a (n :: * -> *) e' b. (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
07:26:33 <Yoric[DT]> Yes, but if I end up with a third kind of error, I'll need either two imbricated Either or a Either3 or something such.
07:26:42 <quicksilver> true enough.
07:26:50 <Yoric[DT]> Ok.
07:26:50 <quicksilver> I'm not sure this is inherently unscalable.
07:26:57 <Yoric[DT]> What do you mean?
07:27:05 <quicksilver> some part of your program has to acknowledge the fact you are dealing with multiple types of errors
07:27:10 <quicksilver> you can't expect that to be free
07:27:18 <Yoric[DT]> No, but I could expect that to be inferred.
07:27:22 <quicksilver> I don't think this combination ideas are any worse than would be expected.
07:27:33 <quicksilver> you can make it inferred by designing a suitable typeclass, certainly.
07:27:51 <quicksilver> typeclasses are a general mechanism for getting the compiler to make decisions for you based on types.
07:27:53 <Yoric[DT]> What would it look like?
07:28:00 <Yoric[DT]> I know that much.
07:28:05 <Yoric[DT]> I have toyed a little with typeclasses.
07:28:24 <quicksilver> YoricsError e, MonadError e m => m ()
07:28:25 <Yoric[DT]> But I don't quite have the intuition of when / how to design them.
07:35:17 <mar77a> any comments? rle xs = [(length ys, head ys) | ys <- group xs]
07:35:36 <Yoric[DT]> quicksilver: I fail to see how that will let me combine three different types.
07:35:42 <mar77a> the tutorial suggest using concat but i don't see the approach they want me to take
07:35:49 <Yoric[DT]> or scale to 4...
07:35:49 <mar77a> suggests*
07:36:12 <quicksilver> Yoric[DT]: your instances will include injections into some universal type of your choice
07:36:26 <Yoric[DT]> mmhhh...
07:36:30 <Yoric[DT]> universal type as in "Typeable" ?
07:36:34 <quicksilver> no
07:36:44 <quicksilver> universal as in data YoricError = some representation
07:36:52 <Yoric[DT]> ok
07:36:53 <quicksilver> whatever suits your application.
07:37:04 <Yoric[DT]> But I still need to redefine YoricError for each application, don't I?
07:37:12 <quicksilver> mabe
07:37:16 <quicksilver> it depends what you're trying to do
07:37:19 <Yoric[DT]> (unless YoricError happens to be Typeable, but that's a different stuff)
07:37:24 <Yoric[DT]> At the moment, nothing precise.
07:37:24 <quicksilver> you're asking very open ended questions...
07:37:44 <quicksilver> maybe you'd like to read simon marlow's extensible exceptions paper
07:37:47 <Yoric[DT]> Just attempting to find out how error monads scale up wrt other language's takes on error management.
07:37:54 <quicksilver> maybe that's the direction you're headed.
07:37:56 <DRMacIver> I find it entertaining that the description of NewBinary is "An older binary serialization library [...] For new projects consider [...] binary."
07:38:07 <Yoric[DT]> quicksilver: I'll take a look, thanks.
07:38:12 * Yoric[DT] adds to the read-list.
07:38:17 <quicksilver> http://www.haskell.org/~simonmar/bib/bib.html
07:38:21 <quicksilver> 6th down from the top
07:38:30 <vixey> mar77a, I have a nice definition
07:38:43 <quicksilver> DRMacIver: this why you should never name anything "NewFoo" ;)
07:38:49 <DRMacIver> Right. :)
07:38:50 * quicksilver points a finger at New York.
07:38:59 <DRMacIver> But I spsecifically find it entertaining that NewBinary is older than binary.
07:39:07 * quicksilver nods
07:39:16 <vixey> mar77a, rle = map (length &&& head) . group; unrle = concat . map (uncurry replicate)
07:39:30 <mar77a> i forgot about &&& by now
07:39:33 <mar77a> :t (&&&)
07:39:35 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:39:44 <mar77a> screw that
07:40:14 <DRMacIver> For functions: (f &&& g) x = (f x, g x)
07:40:15 <vixey> mar77a: a is an arrow
07:40:22 <vixey> mar77a: but it looks like a letter to me
07:40:26 <vixey> mar77a: let's use ~> instead
07:40:32 <mar77a> !??
07:40:44 <atsampso1> bear with him, this trick's good ;)
07:40:52 <vixey> (&&&) :: (b ~> c) -> (b ~> c') -> b ~> (c, c')
07:40:55 <mar77a> i like DRMacIver's definition
07:41:56 <mar77a> > ((+1) &&& sqrt) 1
07:41:58 <lambdabot>  (2.0,1.0)
07:42:02 <DRMacIver> I went through all the arrow definitions a while ago and wrote out what they did when specialised for functions. As far as I can tell it was the only thing I've ever written about Haskell which caused people to learn something. :)
07:42:07 <mm_freak_work> mar77a: that's not a definition, it's a special case
07:42:35 <mar77a> > ((+1) &&& sqrt.(+1)) 1
07:42:37 <lambdabot>  (2.0,1.4142135623730951)
07:42:41 <mar77a> > ((+1) &&& sqrt.(+3)) 1
07:42:43 <lambdabot>  (2.0,2.0)
07:42:47 <DRMacIver> Sure. But it's a useful special case. :)
07:42:51 <mar77a> > ((+1) &&& toIntegral.sqrt.(+3)) 1
07:42:52 <lambdabot>   Not in scope: `toIntegral'
07:42:58 <mar77a> > ((+1) &&& toInteger.sqrt.(+3)) 1
07:42:59 <lambdabot>  Add a type signature
07:43:02 <mar77a> ow
07:43:06 <vixey> mm_freak_work: it is a definition
07:43:22 <vixey> mm_freak_work: these are in a typeclass
07:43:30 <mm_freak_work> > ((+1) *** sqrt) (3,4)
07:43:30 <lilachaze> > let then :: Arrow (~>) => a ~> b -> b ~> c -> a ~> c; f = (>>>) in a `then` b
07:43:31 <lambdabot>  Parse error at "then" (column 5)
07:43:31 <lambdabot>  (4,2.0)
07:43:33 <mar77a> > ((+1) &&& (toInteger.sqrt.(+3))::Int) 1
07:43:34 <lambdabot>  Couldn't match expected type `Int'
07:43:39 <mar77a> omgoose
07:43:43 <DRMacIver> It's a definition of a specail case. :)
07:43:47 <lilachaze> :(
07:44:08 <mm_freak_work> vixey: true
07:44:10 <FordCortina> @hoogle &&&
07:44:11 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
07:44:57 <DRMacIver> lilachaze: 'then' is a keyword...
07:46:32 <mar77a> why doesn't haskell allow function defnitions that are infix by default
07:47:09 <mar77a> something like (!) = not
07:47:27 <mar77a> for example
07:47:35 <mm_freak_work> because that's not infix…  it's either prefix or suffix
07:47:53 <mar77a> oops
07:48:17 <mar77a> more like: (%) = mod
07:48:18 <BeelsebobWork> @hoogle a -> (a,a)
07:48:18 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
07:48:18 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
07:48:18 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
07:50:23 <chr1s> mar77a: you can define that.
07:51:05 <chr1s> you can also use regular functions in infix notation
07:51:24 <quicksilver> mar77a: operators are infix, regular identifiers are prefix, it's just a simplifying assumption
07:51:29 <chr1s> e.g. show `map` [1..5]
07:51:31 <quicksilver> mar77a: makes it easier to understand other people's code.
07:52:04 <b_jonas> Standard ML takes the other way
07:52:15 <osfameron> eeeek, infix map!
07:52:31 <gwern> ...infix map? MADNESS
07:52:31 <hpaste>  ToRA pasted "Very generic errors (scalable?)" at http://hpaste.org/8426
07:52:35 <b_jonas> osfameron: actually Mathematica has that
07:52:53 <osfameron> actually, it's readable if you think about it
07:53:03 <chr1s> osfameron: it's just an example.
07:53:07 <lilachaze> DRMacIver: it doesn't work anyway. type variables aren't allowed to be symbolic as far as I can see.
07:53:14 <lilachaze> > let thn :: Arrow (~>) => a ~> b -> b ~> c -> a ~> c; f = (>>>) in a `thn` b
07:53:14 <lambdabot>  Parse error at "~>)" (column 19)
07:54:13 <DRMacIver> lilachaze: Hm. Fair enough
07:54:28 <b_jonas> osfameron: http://reference.wolfram.com/mathematica/ref/Map.html?q=Map&lang=en
07:54:29 <lambdabot> Title: Map (/@) - Wolfram Mathematica, http://tinyurl.com/582n42
07:55:29 <chr1s> I always like (+) `foldl` 0
07:55:40 <chr1s> ;)
07:55:47 <osfameron> oh, won't Perl 6 have something like  >> as a "hyper-operator" form of infix map?
07:56:05 <Deewiant> > let (/@) = map in (+1) /@ [1..10]
07:56:07 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:56:18 <mm_freak_work> > 3 `(+)` 4
07:56:18 <lambdabot>  Parse error at "(+)`" (column 4)
07:56:21 <Deewiant> or of course we have caleskell here
07:56:25 <Deewiant> > (+1) . [1..10]
07:56:27 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:56:38 <osfameron> eeeeeek!
07:56:58 <mm_freak_work> hehe
07:57:25 <chr1s> Deewiant: how does that work?
07:57:34 <Deewiant> @src (.)
07:57:34 <lambdabot> (f . g) x = f (g x)
07:57:34 <lambdabot> -- In lambdabot, it's been generalised to:
07:57:34 <lambdabot> (.) = fmap
07:57:35 <mm_freak_work> @src (.)
07:57:35 <lambdabot> (f . g) x = f (g x)
07:57:35 <lambdabot> -- In lambdabot, it's been generalised to:
07:57:36 <lambdabot> (.) = fmap
07:57:41 <chr1s> ah.
07:57:48 <osfameron> oh, so (.) isn't just function composition then?
07:57:49 <Deewiant> ?type (.)
07:57:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:57:58 <Deewiant> not in lambdabot
07:58:01 <chr1s> it's unicode.
07:58:02 <osfameron> ah
07:58:02 <Deewiant> ?type (Prelude..)
07:58:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:58:05 <osfameron> and is that a good thing?
07:58:16 <Deewiant> I guess it's debatable :-)
07:58:23 <Deewiant> for newbies? no
07:58:25 <osfameron> presumably it makes some type errors harder to read
07:58:30 <Deewiant> in general? why not
07:58:37 <mm_freak_work> well…  what functor does it operate on?  Identity?
07:58:37 <chr1s> no, it's not unicode.
07:58:48 <Saizan> osfameron: you can use (.) instead of an infix fmap
07:58:53 <Deewiant> @src fmap (-> r)
07:58:53 <lambdabot> Source not found. :(
07:58:56 <Deewiant> @src fmap (->)
07:58:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:58:59 <Deewiant> bah
07:59:09 <Deewiant> @src (->) fmap
07:59:10 <lambdabot> fmap = (.)
07:59:16 <Baughn> http://haskell.org/ghc/download.html <- Do you also see only 6.8.2 here?
07:59:16 <lambdabot> Title: The Glasgow Haskell Compiler
07:59:24 <mm_freak_work> > fmap (+3) 4
07:59:24 <lambdabot>   add an instance declaration for (Num (f a))
07:59:26 <Deewiant> it operates on the (-> x) Functor
07:59:31 <Saizan> mm_freak_work: the ((->) r) functor when you use it as function composition
07:59:34 <mm_freak_work> ah, i see
07:59:42 <Saizan> Deewiant: (x ->)
07:59:51 <puusorsa> read my mips: no more vaxes
08:00:00 <Deewiant> Saizan: right you are, my bad
08:00:06 <osfameron> why is lambdabot not running vanilla haskell?
08:00:28 <osfameron> to play with the new syntax as a proposal?
08:00:39 <puusorsa> to amuse and confuse?
08:00:40 <Deewiant> because Cale is unruly? ;-)
08:00:53 <mm_freak_work> because we love it
08:00:56 <mm_freak_work> @botsnack
08:00:57 <lambdabot> :)
08:01:27 <Baughn> He hasn't switched the associativeness of $, though. :'(
08:01:56 <mm_freak_work> Baughn: ?
08:02:12 <mm_freak_work> > head $ sort [3,2,1]
08:02:13 <lambdabot>  1
08:02:22 <Baughn> mm_freak_work: map $ filter foo $ something or other
08:02:46 <Baughn> mm_freak_work: Should become map (filter foo) (something or other), unlike (as now) map (filter foo (something or other))
08:03:01 <Baughn> Old discussion, though. It /would/ be a bit.. breaking.
08:03:19 <mm_freak_work> i guess, that's a matter of preference…  i like it as it is now
08:03:49 <Saizan> not really preferences
08:04:09 <Saizan> since you can always use (.) in place of multiple ($) right now
08:04:25 <Saizan> with flipped associativity you can remove more parentheses
08:05:02 <Saizan> and it would be the same associativity of function application
08:06:37 <FordCortina> @hoogle put
08:06:37 <lambdabot> Control.Monad.State.Class.put :: MonadState s m => s -> m ()
08:06:38 <lambdabot> Prelude.putChar :: Char -> IO ()
08:06:38 <lambdabot> Prelude.putStr :: String -> IO ()
08:07:28 <mm_freak_work> Saizan: removing parentheses is not equivalent to making code more readable
08:07:31 <][p0tat0face> @arr
08:07:31 <lambdabot> Smartly me lass
08:07:52 <mm_freak_work> i find Baughn's example above a bit confusing
08:08:15 <Baughn> So do I. That's /effectively/ what happens, it's just..
08:08:26 <FordCortina> @src return :: a -> State s a
08:08:26 <lambdabot> Source not found. Just try something else.
08:08:35 <Baughn> > f $ g x $ h x
08:08:36 <lambdabot>  Add a type signature
08:08:41 <Baughn> > f $ g x $ h x :: Expr
08:08:42 <lambdabot>  Add a type signature
08:09:02 <mm_freak_work> FordCortina: \x -> (s -> (x,s))
08:09:10 <mm_freak_work> uhm
08:09:13 <mm_freak_work> FordCortina: \x -> State (s -> (x,s))
08:09:21 <Baughn> > f $ f x
08:09:22 <lambdabot>  Add a type signature
08:09:28 <FordCortina> mm_freak_work: thanks
08:09:45 <quicksilver> return x = State (const x &&& id)
08:09:46 <quicksilver> ;)
08:09:51 <Baughn> > (f $ g x $ h x) :: Expr
08:09:52 <lambdabot>  Add a type signature
08:10:03 <Baughn> Most. Unhelful. Error. Ever.
08:10:41 <mm_freak_work> > a + b
08:10:42 <lambdabot>  a + b
08:10:51 <mm_freak_work> > a b
08:10:52 <lambdabot>  Couldn't match expected type `Expr -> t'
08:11:08 <wagle> Baughn, nah
08:11:08 <mm_freak_work> > a $ b
08:11:09 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
08:11:29 <Baughn> > ((map) f 2) g 3
08:11:29 <lambdabot>   add an instance declaration for (Num (a1 -> a))
08:11:42 <mm_freak_work> > map f [a,b,c]
08:11:43 <lambdabot>  Add a type signature
08:11:51 <RayNbow> Hell froze over... someone posted a Haskell question on a Dutch forum. Yay for Haskell :)
08:11:54 <mm_freak_work> > map a [b]
08:11:54 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
08:12:08 <Baughn> map f [a,b,c] :: [Expr]
08:12:16 <Baughn> > map f [a,b,c] :: [Expr]
08:12:17 <lambdabot>  [f a,f b,f c]
08:12:43 <mm_freak_work> @info Expr
08:12:43 <lambdabot> Expr
08:12:49 <mm_freak_work> @info Bool
08:12:49 <lambdabot> Bool
08:12:56 <mm_freak_work> helpful!
08:15:08 <vixey> huhu
08:15:16 <vixey> @info Integer
08:15:16 <lambdabot> Integer
08:15:22 <vixey> aha!
08:16:05 <tchakkazulu> @info Bananasplit
08:16:05 <lambdabot> Bananasplit
08:16:26 <tchakkazulu> Indeed.
08:16:52 <vixey> hahaha
08:17:19 <wagle> > (a $ b x $ c x) :: Expr
08:17:20 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
08:17:39 <wagle> variable names are special..  8/
08:18:23 <MoonPatrol> YES, i can do addition in haskell now
08:18:28 <Deewiant> > (f $ (g x :: Expr -> Expr) $ h x) :: Expr
08:18:30 <lambdabot>  f (g x (h x))
08:18:31 <MoonPatrol> 1 + 1
08:18:48 <Deewiant> > succ 1
08:18:49 <lambdabot>  2
08:19:24 <MoonPatrol> does lambdabot automatically evaluate haskell code?
08:19:31 <MoonPatrol> fst ('a',2)
08:19:40 <Deewiant> adding the > helps
08:19:48 <Deewiant> > fst ('a',2)
08:19:49 <lambdabot>  'a'
08:19:56 <MoonPatrol> oh okay
08:20:51 <vixey> @info  fun $ (\x -> "@info" ++ x ++ show x)"  fun $ (\\x -> \"@info\" ++ x ++ show x)"
08:20:51 <lambdabot> fun $ (\ x -> "@info" ++ x ++ show x) "  fun $ (\\x -> \"@info\" ++ x ++ show x)"
08:20:54 <vixey> :P
08:21:16 <vixey> oh
08:21:24 <vixey> @info > fun $ (\x -> "@info" ++ x ++ show x)">  fun $ (\\x -> \"@info\" ++ x ++ show x)"
08:21:25 <lambdabot> (> fun $ (\ x -> "@info" ++ x ++ show x) ">  fun $ (\\x -> \"@info\" ++ x ++ show x)")
08:21:39 <vixey> oh :(
08:22:10 <visq> hi, is anybody reading cafe via gmane ?
08:22:11 <visq> there seems to be an 8 hour delay now (at least)
08:22:51 <Deewiant> that or there haven't been any posts in 9 hours :-)
08:23:13 <visq> http://www.haskell.org/pipermail/haskell-cafe/2008-June/date.html
08:23:13 <lambdabot> Title: The Haskell-Cafe June 2008 Archive by date
08:23:13 <Deewiant> good catch though, hadn't noticed
08:25:10 <quicksilver> visq: the -cafe mail server defeinitely had some problems sending out mails
08:25:15 <quicksilver> visq: I had a several hour delay
08:25:48 <visq> ok thanks
08:26:18 <visq> but usually there is no delay right ?
08:26:51 <Deewiant> correct
08:28:00 <visq> fine, I'll suppose it'll be fixed soon then
08:30:50 <vixey> what are type families for?
08:31:26 <quicksilver> they replace fundeps
08:31:34 <quicksilver> well the framework of assocatied types replaces fundeps
08:31:46 <quicksilver> allows explicit specification of some kinds of type functions.
08:32:00 <vixey> so it's a more precise way to express how to search of typeclass instances?
08:32:24 <amaron> anyone worked with encryption?
08:33:30 <mm_freak_work> amaron: in haskell or generally?
08:33:35 <Saizan> vixey: not exacly, it's more a way to remove some parameters from typeclasses, among the other uses
08:34:57 <amaron> mm_freak_work: in haskell
08:35:28 <mm_freak_work> amaron: i have done a few RC4 and RSA implementations for testing, but nothing serious yet
08:35:46 <amaron> mm_freak_work: with Crypto package?
08:35:55 <gwern> @seen dcoutts
08:35:56 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 3h 59m 22s ago.
08:36:08 <dcoutts_> hia gwern
08:36:16 <mm_freak_work> amaron: nope
08:36:22 <gwern> eek!
08:36:28 <gwern> I never get over that
08:37:11 <amaron> mm_freak_work: you made your own or used something else?
08:37:38 <gwern> dcoutts_: I just wanted to tell you 2 things: first, .cabal/config needs some documentation. all I see is the source in cabal-install - it's a wee bit unfair to go around correcting people with a secret weapon like that :) and second, it'd be nifty if I could use ~/ in the config - I like to avoid hardwiring addresses as much as possible
08:37:42 <mm_freak_work> amaron: my own, mainly for testing performance
08:38:21 <dcoutts_> gwern: yes and maybe :-)
08:38:29 <gwern> dcoutts_: also, are .cabal files supposed to have a trailing newline?
08:38:33 <amaron> mm_freak_work: very nice, did you read keys from i.e. ssh-gen generated key pairs?
08:38:46 <dcoutts_> gwern: I don't think that matters does it?
08:39:04 <mm_freak_work> amaron: nope, i didn't bother saving things
08:39:13 <vixey> @check \x -> let rle = map (head &&& length) . group ; unrle = concat . (uncurry replicate) in (unrle . rle) x == x
08:39:14 <lambdabot>  Couldn't match expected type `(Int, [a])'
08:39:16 <mm_freak_work> and i didn't like the crypto package, because it feeled incomplete
08:39:19 <gwern> dcoutts_: I ask because sjanssen sent me a patch adding it, and it's not something I've ever heard about (whether files should have a trailing newline or no), although IIRC GHC does complain about lacking trailing newlines?
08:39:21 <vixey> @check \x -> let rle = map (head &&& length) . group ; unrle = concat . map (uncurry replicate) in (unrle . rle) x == x
08:39:23 <lambdabot>  Falsifiable, after 0 tests: [0]
08:39:28 <tusho> Someone should code an ampersand in haskell
08:39:39 <dcoutts_> gwern: his editor probably just adds it automatically, most do.
08:39:40 <gwern> mm_freak_work: strange, the complaints i usually hear is that it's too big and too slow
08:40:01 <gwern> dcoutts_: mm. wonder whether cabal-check should mention't
08:40:04 <vixey> @check \x -> let rle = map (length &&& head) . group ; unrle = concat . map (uncurry replicate) in (unrle . rle) x == x
08:40:05 <lambdabot>  OK, passed 500 tests.
08:40:20 <mm_freak_work> gwern: i couldn't find out how to generate an RSA key with it, and also i didn't seem to provide a useful CSPRNG
08:40:34 <dcoutts_> gwern: afaik cabal does not care about trailing newlines (or dos vs unix line endings)
08:40:46 <dcoutts_> gwern: the plan is to make ~/.cabal/config self-documenting by including all the possible fields and their default values, but commented out
08:40:57 <amaron> mm_freak_work: I'm looking for something like this: using pub and priv rsa keys generated outside to encode and decode messages
08:41:04 <gwern> dcoutts_: alright then. but keep in mind the ~/ thing!
08:41:14 * gwern threatens dcoutts_ with the threat of a bugreport
08:41:19 <ivanm> trailing newlines are nice... so when you cat the file to term, the next prompt is at the beginning of the next line! :p
08:41:59 <gwern> cat? bah. less is more!
08:42:41 <mm_freak_work> amaron: then the crypto package seems right for you
08:42:49 <dcoutts_> gwern: sure, report it
08:42:50 <ivanm> gwern: nah, I prefer most
08:43:10 <dcoutts_> gwern: thing is, we do not support ~ in ordinary file paths in command line things
08:43:16 <gwern> most is too much
08:43:34 <chylli`> imagelife: hello, can you help me to write a BSTree algrithm ?
08:43:37 <chylli`> imagelife: :p
08:43:39 <amaron> mm_freak_work: did you tried to use it?
08:43:57 <imagelife> chylli, <^-^>
08:43:59 <dcoutts_> gwern: since for command lines the shell does that for us. So I'm not sure what we should do for the config file. There are not many cases where you have to mention it.
08:44:01 <pgavin> dcoutts_: gtk2hs release tomorrow or the day after or so
08:44:02 <gwern> chylli`: of course he can, you'll find his rates quite reasonable
08:44:04 <amaron> mm_freak_work: in all their examples they made pair of octets inline
08:44:12 <dcoutts_> pgavin: woo ho!
08:44:24 <gwern> pgavin: will that include that svg module hback uses?
08:44:45 <amaron> mm_freak_work: i dont know the rule how to make input for their encode/decode functions from pub and priv key files
08:44:49 <mm_freak_work> amaron: i've just had a quick look at it, and it seemed to provide those features
08:44:54 <chylli`> gwern: talking with me ?
08:44:57 <mm_freak_work> i don't know either
08:44:58 <pgavin> gwern: well, I don't know hback, but if you mean rsvg, then yes
08:45:01 <gwern> well shit. sjanssen was right
08:45:08 <gwern> mueval *is* broken
08:45:09 <mm_freak_work> really, i don't like the crypto package for a number of reasons
08:45:18 <gwern> (goddamn it ghc)
08:45:45 <mm_freak_work> unfortunately i'm unable to find an alternative other than a binding to openssl
08:46:00 <marcot> Good morning.
08:46:04 <amaron> mm_freak_work: ffi then?
08:46:57 <amaron> its more work to do, but i'll try it that way...
08:49:11 <mm_freak_work> amaron: there is a binding already
08:49:27 <mm_freak_work> somewhere on hackage
08:49:53 <mm_freak_work> i don't know if it provides an interface to libcrypto, though…  maybe it provides only SSL/TLS functionality
08:52:05 <BeelsebobWork> is it possible to speed up ghc's clock tick when profiling?
08:52:21 <amaron> mm_freak_work: got it: http://ccm.sherry.jp/HsOpenSSL/index.en.html
08:52:22 <lambdabot> Title: HsOpenSSL - (Part of) OpenSSL binding for Haskell
08:53:01 <mm_freak_work> amaron: that one seems pretty incomplete
08:53:41 <mm_freak_work> amaron: hsgnutls seems to be useful
08:54:02 <gwern> > Foreign.unsafePerformIO $ readFile "/etc/passwd"
08:54:03 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
08:54:27 <gwern> > import Foreign; Foreign.unsafePerformIO $ readFile "/etc/passwd"
08:54:28 <lambdabot>  Parse error at "impor..." (column 1)
08:55:10 <mm_freak_work> amaron: well…  not too useful, since it doesn't seem to support modern ciphers =/
08:55:34 <mm_freak_work> haskell really needs good encryption modules
08:55:49 <amaron> mm_freak_work: guess so...
08:58:23 <Baughn> mm_freak_work: Modern ciphers such as..?
08:58:45 <gwern> enigma, obviously
08:58:54 <gwern> it is unbreakable, mein fuhrer!
08:58:56 <visq> could someone give me advice on compiling a test suite using cabal ?
08:59:17 <Baughn> mm_freak_work: That seems like an odd statement, since hs-openssl already supports basically all the ciphers openssl does
08:59:31 <gwern> visq: be more specific pls
08:59:34 <visq> I'm currently using an ugly Makefile
08:59:42 <visq> It's for Language.C
08:59:50 <visq> I have a test/src directory
08:59:57 <visq> with 7 test drivers
09:00:01 <quicksilver> I don't think cabal replaces make
09:00:03 <quicksilver> in that sense
09:00:15 <quicksilver> if you want a way to execute arbitrary commands in a dependency network
09:00:17 <visq> its haskell
09:00:18 <quicksilver> to run your tests
09:00:25 <quicksilver> then make may actually be the right answer.
09:00:32 <visq> its a haskell test framework depending on the library
09:00:42 <visq> not for running, just for compiling
09:00:48 <quicksilver> oh
09:00:58 <visq> wait a sec
09:00:59 <quicksilver> then dcoutts_ is your man I think :)
09:00:59 <gwern> imo, I'm not sure you should be running tests as part of the compilation/installation?
09:00:59 <dcoutts_> visq: if each test is just an exe then you can make a .cabal file with multiple executable sections
09:01:15 <quicksilver> magic! and he appears.
09:01:17 <visq> http://code.haskell.org/language-c/test/Makefile
09:01:35 <visq> the problem is that it depends on the library
09:01:46 <visq> and I'd like to have a seperate .cabal file
09:02:24 <visq> which requires lots of duplicate Other-Module stuff ?
09:02:37 <dcoutts_> visq: you can have a separate .cabal file but it's a bit less pleasant because neither ghc nor cabal tracks changes across packages
09:02:55 <dcoutts_> ghc --make does not rebuild things when a package the modules depend on has changed
09:03:11 <visq> so its best to keep things within one cabal file and use a compileTests flag ?
09:03:45 <dcoutts_> visq: it's probably still better to have a separate one because otherwise the modules in the lib is built separately for each exe
09:04:03 <visq> ok
09:04:07 <visq> so cabal install language-c
09:04:12 <visq> cabal install language-c test
09:04:22 <visq> cabal make language-c-test-drivers
09:04:28 <visq> s/make/build
09:04:36 <visq> ?
09:04:38 <dcoutts_> right, something like that
09:04:45 <visq> thanks
09:05:00 <mm_freak_work> amaron: AES, twofish, etc.
09:05:08 <visq> ah, another question: is it possible to depend on a package with a flag enabled ?
09:05:10 <mm_freak_work> and asymmetric ciphers like RSA, ElGamal, …
09:05:34 <visq> e.g. build-depends language-c +dataGeneric +mtlBindings
09:05:50 <mm_freak_work> Baughn: maybe i'm outdated
09:06:00 <Baughn> mm_freak_work: Badly.
09:06:01 <mxc> is there a standard function that like eq but that returns true whenever the two arguments have the same constructor, independent of value?
09:06:12 <mxc> so like if you have data Foo Int  | Bar String
09:06:18 <visq> or is this the wrong approach to add extra functionality which is e.g. ghc specific ?
09:06:21 <Baughn> mm_freak_work: Look at the OpenSSL.EVP.getCipherNames function
09:06:25 <mxc> then consEq (Foo 1) (Foo 4) would be true
09:07:05 <Baughn> mm_freak_work: (You're not confusing it with hopenssl, are you?)
09:07:21 <mm_freak_work> Baughn: that's well possible
09:07:31 <Baughn> mm_freak_work: http://ccm.sherry.jp/HsOpenSSL/doc/OpenSSL-EVP-Cipher.html <-- Well, here anyway
09:08:04 <Baughn> mm_freak_work: getCipherNames returns everything that openssl supports, just to make sure.. you can then go aheda and use getCipherByName to grab whatever cipher you like.
09:08:16 <Baughn> Of course, that's for symmetric ciphers
09:08:36 <amaron> mm_freak_work: i need rsa and blowfish for now
09:08:53 <Baughn> It only supports rsa and dsa for asymmetric ones, but that's generally enough
09:08:59 <amaron> and this will serve the purpose
09:09:46 <amaron> ups, blowfish...?
09:09:53 <mm_freak_work> Baughn: great
09:10:07 <mm_freak_work> amaron: if you don't have any reason to use blowfish, you should prefer twofish over it
09:10:25 <Baughn> amaron: Supported if openssl supports them
09:11:03 <mm_freak_work> yes, it does
09:11:08 <vixey> > 1 :: 2 ++ 3
09:11:08 <lambdabot>  Parse error at "2" (column 6)
09:11:14 <vixey> > 1 : 2 ++ 3
09:11:15 <lambdabot>   add an instance declaration for (Num [t])
09:11:27 <mm_freak_work> interestingly, openssl supports the blowfish cipher, but only in libcrypto, not for SSL/TLS
09:11:51 <amaron> mm_freak_work: im porting something what uses bfish
09:12:01 <vixey> > 0
09:12:02 <lambdabot>  0
09:12:05 <vixey> > 1 ++ 2 : 3
09:12:06 <lambdabot>   add an instance declaration for (Num [t])
09:12:22 <mm_freak_work> amaron: upgrade it to twofish at the same time =)
09:12:28 <Baughn> amaron: No crypto negotiation? And backwards compatibility is required?
09:14:42 <Baughn> Prelude OpenSSL> fmap (filter (== "blowfish")) $ withOpenSSL OpenSSL.EVP.Cipher.getCipherNames
09:14:46 <Baughn> ["blowfish"]
09:14:50 <tusho> Baughn: er
09:14:53 <tusho> couldn't you just do:
09:15:07 <tusho> x >>= elem "blowfish"
09:15:10 <tusho> oh, hm
09:15:14 <tusho> fmap (elem "blowfish") x
09:15:27 <Baughn> tusho: I could have. I keep forgetting about elem.
09:16:39 <quicksilver> ("blowfish" `elem`) <$> withOpenSSL OpenSSL.EVP.Cipher.getCipherNames
09:17:13 <tusho> quicksilver: I can beat that
09:17:21 <tusho> elem"blowfish"<$>withOpenSSL OpenSSL.EVP.Cipher.getCipherNames
09:17:26 <quicksilver> ;)
09:17:39 <quicksilver> I like the ("blowfish" `elem`) idiom though
09:17:45 <quicksilver> even thought it is a few chars longer
09:18:31 <tusho> quicksilver: whitespace and parentheses must be eliminated
09:19:01 <quicksilver> ;)
09:19:49 <quicksilver> > zipWith(*)`ap`tail $ [1..]
09:19:51 <lambdabot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
09:20:00 <tusho> >zipWith(*)`ap`tail$[1..]
09:20:07 <tusho> lambdabot requires whitespace
09:20:12 <tusho> LIKE PYTHON
09:20:17 <tusho> > zipWith(*)`ap`tail$[1..]
09:20:18 <lambdabot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
09:20:20 <Deewiant> >ap(zipWith(*))tail[1..]
09:20:24 <Deewiant> > ap(zipWith(*))tail[1..]
09:20:25 <lambdabot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
09:20:28 <mjrosenb> :t ap
09:20:29 <tusho> ooooh, now you've done it....
09:20:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:20:39 <tusho> > ap(zipWith(*))[2..]
09:20:40 <lambdabot>  Couldn't match expected type `[a] -> [a]'
09:20:45 <tusho> oh
09:20:53 <tusho> hmm
09:20:56 <tusho> how can we golf ap(zipWith(*))tail[1..]
09:22:33 <newsham> morning
09:22:38 <seanl> morning
09:22:39 <newsham> dcoutts around?
09:22:47 <dcoutts_> @yarr!
09:23:00 <lambdabot> Arrr!
09:23:00 <dcoutts_> lambdabot?
09:23:00 <newsham> did you see my gtk question on haskell-cafe re: GC?
09:23:01 <Deewiant> > (\n->n^2-n).[2..]
09:23:15 <lambdabot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
09:23:19 <dcoutts_> newsham: yep, I'll take a look later
09:23:26 <newsham> cool, danke.
09:24:15 <seanl> > (1.56:Float) + (1.0e-2::Float)
09:24:15 <lambdabot>   Not in scope: data constructor `Float'
09:24:25 <seanl> > (1.56::Float) + (1.0e-2::Float)
09:24:26 <lambdabot>  1.5699999
09:24:45 <seanl> hm..... does anybody know about the precision on the Float type?
09:24:59 <dcoutts_> newsham: you wanted to get the GC out of a widget was it?
09:25:03 <Baughn> @google what every computer scientist should know about floating point
09:25:04 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
09:25:09 <Baughn> seanl: There you go. Kinda.
09:25:36 <newsham> dcoutts: exactly
09:25:36 <Deewiant> http://docs.sun.com/source/806-3568/ncg_goldberg.html
09:25:44 <seanl> Baughn: do you know how I can get 1.57 from 1.56+0.01 instead of 1.5699999?
09:25:57 <Deewiant> seanl: read the above link
09:26:05 <seanl> oh
09:26:06 <Baughn> seanl: You can't, and you're a bad person for asking.
09:26:10 <newsham> for the purpose of using a drawable/drawarea to make a custom image
09:26:10 <Baughn> Read the link. ;)
09:26:14 <dcoutts_> newsham: right, so there's nothing currently to do that. I think it's because there is no function in the gtk that gives it to us, only a direct struct access.
09:26:38 <newsham> in gtk itself (C) and many bindings (ie. pygtk) you can access the GC.
09:27:17 <newsham> for example, in pygtk:   fg = area.get_style().fg_gc[gtk.STATE_NORMAL]
09:27:19 <byorgey> seanl: you should use Rational instead.
09:27:24 <RayNbow> hmm, does it matter for ghci if a definition is tail recursive or not?
09:27:30 <byorgey> > (1.56 + 0.01) :: Rational
09:27:31 <RayNbow> or does it only matter for compiled code?
09:27:32 <lambdabot>  157%100
09:27:57 <seanl> hm.. I see
09:28:08 <byorgey> seanl: Rational can represent such numbers exactly
09:28:30 <newsham> I imagine the  style functions for getting colors in the gtk2hs bindings were added manually to go through the gc and fetch the color info?
09:28:32 <seanl> okay.. I will try with that... thank you very much:)
09:28:35 <dcoutts_> newsham: right, so you have to access the GtkWidget struct directly to get the style
09:28:49 <dcoutts_> newsham: which colour ones?
09:29:08 <Deewiant> byorgey: does GHC actually do such math in Rational at compile time?
09:29:09 <newsham> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-UI-Gtk-Genera
09:29:10 <newsham> l-Style.html
09:29:11 <lambdabot> http://tinyurl.com/5oxn9f
09:29:22 <byorgey> Deewiant: what do you mean?
09:29:30 <newsham> styleGetForeground for example
09:29:43 <byorgey> (1.56 + 0.01) doesn't do floating-point addition and then convert to Rational, if that's what you're asking
09:29:47 <newsham> there should probably be a styleGetForegroundGC as well
09:29:48 <Deewiant> byorgey: given foo :: Float, foo = 0.01 + 0.01, for instance, does it do floating-point addition
09:29:49 <mm_freak_work> > [ n^2 - n | n <- [2..] ]
09:29:50 <lambdabot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
09:30:04 <byorgey> Deewiant: yes, it does
09:30:08 <Deewiant> byorgey: alright, so if you give it Rational it does it all in Rational
09:30:10 <Deewiant> and so forth
09:30:12 <Deewiant> thanks
09:30:17 <byorgey> Deewiant: right, because of type checking
09:30:19 <dcoutts_> newsham: right, but those get stuff out of a Style, not a GC
09:30:27 <byorgey> if foo :: X  and foo = a + b  then a :: X and b :: X
09:30:29 <Deewiant> > length "[n^2-n|n<-[2..]]"
09:30:31 <lambdabot>  16
09:30:42 <Deewiant> byorgey: yeah, just wondering if there's something special going on if it knows a and b at compile time
09:30:45 <newsham> dcoutts: right, and thats the way you fetch a GC in C and pygtk.  you get it from the style
09:30:51 <Deewiant> > length "(\n->n^2-n).[2..]"
09:30:52 <lambdabot>  16
09:31:07 <ziman> @pl \n->n^2-n
09:31:08 <lambdabot> (-) =<< (^ 2)
09:31:08 <byorgey> Deewiant: remember also that numeric constants are actually polymorphic
09:31:27 <byorgey> Deewiant: i.e.  6  is actually 'fromInteger 6'  and likewise '0.01' is 'fromRational 0.01', IIRC
09:31:38 <visq> dcoutts: thanks for your help. using cabal for library stuff and Makefile for in-place executables seems to work fine.
09:31:39 <Deewiant> yep
09:31:41 <byorgey> @type fromRational
09:31:41 <ziman> :t 6
09:31:43 <lambdabot> forall a. (Fractional a) => Rational -> a
09:31:44 <lambdabot> forall t. (Num t) => t
09:31:46 <dcoutts_> newsham: so here's what you should do: see widgetGetDrawWindow in gtk/Graphics/UI/Gtk/General/Structs.hsc
09:31:51 <Deewiant> :t 0.01
09:31:53 <lambdabot> forall t. (Fractional t) => t
09:32:21 <newsham> will do, thanks.
09:32:33 <dcoutts_> newsham: that's a similar function that gets the GdkWindow out of a GtkWidget struct, you should do one similar for the style
09:32:59 <dcoutts_> newsham: if you do it and test it very soon then you might be able to persuade pgavin to include it in the release
09:33:06 <marcot> dcoutts_: what's missing in Gtk2hs to be a complete binding of GTK?
09:33:14 <BeelsebobWork> @hoogle Data.Set a -> a
09:33:14 <lambdabot> No matches, try a more general search
09:33:21 <BeelsebobWork> @hoogle Data.Set.Set a -> a
09:33:22 <lambdabot> No matches, try a more general search
09:33:27 <marcot> http://www.gtk.org/language-bindings.html
09:33:27 <lambdabot> Title: GTK+ - Language Bindings
09:33:48 <dcoutts_> marcot: various things, some new stuff in gtk+ 2.10+, some old stuff like proper clipboard + drag'n'drop
09:34:20 <dcoutts_> newsham: I suppose you'll also need the function to get the GC out of the style
09:35:52 <dcoutts_> newsham: like we've got styleGetForeground and you want to add styleGetForegroundGC
09:35:57 <bos> argh, the QuickCheck documentation is so awful.
09:36:03 <newsham> right
09:36:12 <Snark> how does ":t" in ghci work ?
09:36:27 <Deewiant> :t (:t)
09:36:30 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
09:36:30 <lambdabot>     In the second argument of `(:)', namely `t'
09:36:37 <dcoutts_> newsham: but if you want it in the release you'll have to be quick. pgavin said he wanted to get it out within a day or so.
09:36:39 <smg> Snark: :help
09:36:40 <Deewiant> :t (t:)
09:36:42 <lambdabot> [Expr] -> [Expr]
09:36:58 <smg> :t (s:)
09:36:59 <lambdabot> [Expr] -> [Expr]
09:37:12 <newsham> i'll try, unfort i have plans this evening, but maybe sometime tonight or tomorow
09:37:14 <dcoutts_> newsham: and as release manager, he's the final arbiter of what goes in
09:38:06 <lilachaze> Deewiant: i think the answer to your question (are numerical operations on constants done at compile tim?) is maybe. i believe that a compiler is permitted to, because + is strict and total, and a good optimizing compiler will.
09:38:16 <bd_> > fmap f [a,b,c]
09:38:16 <lambdabot>  Add a type signature
09:38:21 <bd_> > fmap f [a,b,c] :: [Expr
09:38:21 <lambdabot>  Parse error at end of input
09:38:22 <bd_> > fmap f [a,b,c] :: [Expr]
09:38:23 <lambdabot>  [f a,f b,f c]
09:38:25 <Snark> smg, hmm... I meant how can I do like it...
09:38:39 <smg> Snark: explain your problem :P
09:38:45 <lilachaze> Deewiant: you could try ghc-core on some sample code to find out
09:38:47 <Deewiant> lilachaze: sure, I'm just wondering if the numerical results might change as a result of the compiler doing math in Rational instead of Float (for instance)
09:38:47 <Philippa_> lilachaze: + is neither of those things, though common instances are
09:38:51 <Deewiant> rather, I was
09:39:02 <Philippa_> Deewiant: they can do, yes
09:39:18 <lilachaze> Philippa_: wow, mad pedantry skillz!
09:39:56 <Philippa_> lilachaze: there're circumstances where you might use instances it doesn't apply for. A lazy "natural" number type would allow you to handle omega for a number of purposes, for example
09:40:09 <Snark> smg, I would like to be able to print the type of an expression in a program :-)
09:40:22 <smg> that i don't know :]
09:40:29 <smg> you can use ghci to do that with :t (your expression)
09:40:38 <chylli`> how to set haskell program exit no ? $?
09:40:47 <Saizan> Snark: you can use the GHC-API for that
09:40:47 <lilachaze> Philippa_: i like to think that in the context it was clear enough... :)
09:41:10 <Snark> Saizan, what is that?
09:41:38 <quicksilver> > typeOf (["hello","world"])
09:41:39 <lambdabot>  [[Char]]
09:41:44 <Saizan> Snark: a library to use as interface for ghc
09:41:46 <quicksilver> Snark: ^^ maybe that is good enough for your needs?
09:42:11 <Saizan> ah, yeah, typeOf is way simpler :)
09:42:14 <quicksilver> depends if you mean type of an expression which is alreayd in your program, or type of an expression entered by the user.
09:42:23 <quicksilver> in the former case, typeOf is enough (and actually it happens at compile time)
09:42:31 <quicksilver> in the latter case you need to embed a haskell interpreter.
09:42:34 <quicksilver> which is what ghc-api is.
09:43:03 <Philippa_> Deewiant: the ultimate check for compile-time stuff is to have to compiler dump out some core and take a look at what it did, anyway
09:44:53 <newsham> dcoutts: when doing something like " peekElemOff (#{ptr GtkStyle, fg} stPtr)"   where is the offset of "fg" defined at?
09:44:58 <newsham> is that parsed from the .h files?
09:45:53 <dcoutts_> newsham: hsc2hs discovers it by generating a C prog, running that and substituting the result in
09:46:31 <quicksilver> which is sick, really
09:46:36 <quicksilver> but equally just about the only way.
09:46:41 <dcoutts_> newsham: you're thinking of c2hs which is a pure haskell prog, which parses the .h file
09:46:49 <dcoutts_> quicksilver: well there's the c2hs way
09:46:59 <dcoutts_> it only needs a C pre-processor not a C compiler
09:47:01 <quicksilver> dcoutts_: which assumes you know the C ABI for that platform inside out.
09:47:07 <dcoutts_> yes, yes it does.
09:47:21 * gwern muses. I ran into a c2hs haddock problem today. quelle coincidence it should come up today
09:47:27 <dcoutts_> but we can check that we're right by comparing with the C compiler
09:47:27 <quicksilver> dcoutts_: for example, what is the alignment of a struct { float a; char b; double c } ?
09:47:30 <quicksilver> ;)
09:47:47 <quicksilver> I think the hsc2hs is the right way. however ugly it is.
09:47:50 <dcoutts_> quicksilver: there's an algorithm for it and it's not that hard
09:48:11 <quicksilver> dcoutts_: but new platforms are free to define their own ABI aren't they?
09:48:18 <dcoutts_> and once you've implemented it you can easily check you're right by compiling everything with both and checking they're the same
09:48:22 * quicksilver ndos
09:48:34 <dcoutts_> quicksilver: yes but they don't vary much, just a few variables
09:48:39 * quicksilver nods
09:48:39 <newsham> (i would be more concerned about C extensions than alignment rules)
09:48:53 <dcoutts_> newsham: c2hs's C parser parses GNU C.
09:49:43 <dcoutts_> all the extensions in common (and even pretty rare) use. Enough to parse the kernel, glibc and all the other core packages in a standard linux distro.
09:49:44 <lilachaze> @instances-importing Data.Typeable Typeable
09:49:44 <lambdabot> s a
09:49:48 <lilachaze> ?
09:50:16 <gwern> dcoutts_: another question about .cabal/config: is it just for cabal-install, or will it work with the runhaskell stuff too?
09:50:17 <newsham> anyway, thanks dcoutts, I think I have enough to crack into this one, but gotta get to other stuff now..  bbl
09:50:34 <dcoutts_> gwern: just of cabal-install.
09:50:37 <dcoutts_> of/for
09:50:55 <dcoutts_> and no plan to change that
09:51:08 <gwern> also, I didn't see any profiling option?
09:52:04 <dcoutts_> gwern: it's probably not in there yet. The plan is to have all the command line args also be config options. We'll generate both from the same description.
09:53:14 <gwern> I see
10:02:23 <Snark> quicksilver, :t typeOf => Not in scope: `typeOf'
10:02:34 <luite> oops
10:03:24 <ski_> @index typeOf
10:03:24 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
10:06:19 <Snark> interesting
10:06:33 <Snark> :i TypeRep shows things like : instance [overlap ok] Eq TypeRep -- Defined in Data.Typeable
10:06:42 <Snark> what does the "[overlap ok]" mean !?
10:07:05 <bos> the module was compiled with overlapping instances permitted.
10:09:52 <bos> @pl \f -> all (`elem` f)
10:09:52 <lambdabot> all . flip elem
10:11:03 <joey_> > loeb (Just (const 1))
10:11:04 <lambdabot>  Just 1
10:13:49 <joey_> > loeb (Just fromJust)
10:13:50 <vixey> :t loeb
10:13:53 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
10:13:56 * byorgey takes cabal-install out to a fancy dinner
10:14:00 <lambdabot>  Just Exception: Time limit exceeded
10:14:16 <byorgey> dcoutts++
10:14:32 <vixey> > loeb [head]
10:14:39 <lambdabot>  [
10:14:50 <dcoutts_> byorgey: :-)
10:14:54 <joey_> > loeb [length, head]
10:14:56 <lambdabot>  [2,2]
10:15:16 <vixey> > loeb [head, length]
10:15:19 <byorgey> dcoutts_: the new install logs just saved me a world of pain
10:15:24 <lambdabot>  [
10:15:35 <dcoutts_> byorgey: oh yes? how are you using them?
10:16:04 <dcoutts_> byorgey: you know we have a parser and type for those records, it's not just a write-only log
10:16:10 <byorgey> dcoutts_: see my message to cafe -- essentially, things started segfaulting and I wasn't sure why, and I couldn't remember if I had upgraded any packages recently, and if so which ones
10:16:23 <dcoutts_> ah I see
10:16:28 <byorgey> dcoutts_: oh, nothing that fancy, I just looked there to see which packages I had upgraded
10:16:36 <dcoutts_> right yes
10:16:39 <byorgey> it turns out network-2.1.0.0 was the culprit
10:17:15 <dcoutts_> byorgey: I use them to answer questions like "which packages build with Cabal-1.2 but not 1.4"
10:17:34 <byorgey> I could see how that would be useful =)
10:17:57 <dcoutts_> and eventually to get them submitted back to hackage so we can see what packages work where
10:20:30 <dcoutts_> byorgey: so perhaps we should log the day too so you know what you built and when
10:20:44 <byorgey> dcoutts_: yes, I was thinking that would be nice
10:21:01 <byorgey> actually, I'd be glad to submit a patch for that, I haven't hacked on Cabal in a while =)
10:21:10 <dcoutts_> we don't want the anonymous reports to have timestamps more accurate than day though I think. It'd be giving away too much information.
10:21:31 <dcoutts_> byorgey: that'd be helpful.
10:21:54 <quicksilver> news at ten: secret haskell programmer loses job after too-accurate timestamp shows him working on haskell code during work hours ;P
10:22:12 <quicksilver> cabal developers blamed.
10:22:17 <byorgey> hehe
10:22:41 <dcoutts_> quicksilver: heh heh. Actually though, once you start to look at it very closely you find all kind of things you have to do to keep the data truly anonymous.
10:22:48 <dcoutts_> byorgey: the bit you're after is in cabal-install, Hackage/Reporting.hs
10:23:05 <byorgey> ok
10:23:27 <dcoutts_> quicksilver: for example we cannot keep all the reports together in a single list because that makes it easy to see clustering
10:23:55 * quicksilver nods
10:24:10 <dcoutts_> quicksilver: and since an attacker can inject their own reports at any time it would let them partition reports
10:24:15 * quicksilver nods
10:24:33 <quicksilver> injecting reports is not too dangerous as long as you don't share needles.
10:24:40 <quicksilver> sorry, I'm being a bit silly cos it's hometime!
10:24:50 * quicksilver dances madly around the channel and then sits in a corner to calm down.
10:24:56 <dcoutts_> so reports should be kept per package so you do not see the clusters of reports submitted by an individual
10:25:02 * quicksilver nods.
10:25:05 <bos> cd
10:25:25 <quicksilver> bos@#haskell:~ >
10:25:27 <dcoutts_> bos: heh, home time for you too eh? :-)
10:25:28 <byorgey> dcoutts_: hm, explain to me why this is an issue?  I don't understand what an attacker could do
10:25:36 <bos> que?
10:25:53 <bos> oh, funny.
10:25:57 <dcoutts_> cd # goes home
10:26:00 <bos> i didn't even notice i did that.
10:26:11 <dcoutts_> byorgey: suppose I'm trying to identify a related cluster of reports,
10:26:28 <joey_> > loeb (2, snd)
10:26:38 <lambdabot>  (2,Exception: Time limit exceeded
10:27:06 <byorgey> dcoutts_: ok
10:27:20 <dcoutts_> byorgey: since I know that people upload large numbers of reports together in one batch. Knowing a bunch of packages were all uploaded at the same time by one individual lets you get a long way towards identifying the uploader.
10:27:45 <byorgey> oh, I see, and then by looking through the reports you can maybe glean various information about their platform etc. ?
10:28:00 <dcoutts_> byorgey: so we do not want to timestamp them accurately. We also do not want to keep them all in one big log since then you know that sequential ones are probably uploaded together.
10:28:06 <byorgey> right
10:28:42 <dcoutts_> byorgey: and even though you do not know that all adjacent ones are the same person, I as attacker could upload my own report every minute and use that to partition the log.
10:28:58 <dcoutts_> so we must split them by package name
10:29:05 <byorgey> makes sense
10:29:19 <dcoutts_> and we must not publish new records more frequently than our timestamp accuracy
10:29:41 <dcoutts_> otherwise I can just poll the logs and find out more accurately when new reports arrive
10:30:02 <dcoutts_> anonymity is hard
10:30:46 <byorgey> dcoutts_: so should I add datestamps, or is it better to let it lie?
10:31:00 <dcoutts_> hmm, that also means that we should randomly permute the reports that arrive for each package each day
10:31:13 <byorgey> you could also store the timestamps locally, but not upload them to hackage?
10:31:24 <dcoutts_> byorgey: we can do either
10:31:49 <byorgey> is there already functionality to upload the reports to hackage, or is that a planned feature?
10:31:57 <dcoutts_> byorgey: it's planned
10:32:22 <dcoutts_> byorgey: so accurate times are useful to you the local user, but they're not so important to analysing trends
10:32:33 <byorgey> dcoutts_: right
10:32:41 <dcoutts_> byorgey: so perhaps we do not need the build date and the upload date will do
10:32:59 <dcoutts_> byorgey: ie perhaps we want different logs to be kept locally
10:33:28 <dcoutts_> byorgey: also, local logs can track installs of things that are not from hackage
10:33:44 <byorgey> that's true
10:34:07 <dcoutts_> byorgey: we partition the build reports per-server. For local ones that's not useful.
10:34:25 <dcoutts_> byorgey: so really we want a separate local logging system.
10:34:27 <byorgey> ah, right, indeed
10:37:17 <byorgey> well, this is turning into something a bit bigger than I thought =)
10:37:23 <dcoutts_> :-)
10:37:57 <byorgey> I'd still be interested in implementing it but for the time being I'll let it go, and write it on my list of projects to pursue at some point =)
10:38:13 <dcoutts_> byorgey: add a feature request with the info so we do not forget
10:38:20 <byorgey> ok, will do.
10:38:23 <dcoutts_> thanks
10:38:56 <dcoutts_> byorgey: the simplest approach would be cp Hackage/Reporting.hs Hackage/Logging.hs and then tweaking a few lines.
10:43:22 <marcot> Does debian update-haskell-control now only work with cabal?
10:43:39 <marcot> I'm looking at gtk2hs debian package, and I'm getting:
10:43:57 <byorgey> dcoutts_: that seems ugly though.  to do it properly you'd want to factor out the common code, since I imagine a lot of it could be shared.
10:44:08 <byorgey> dcoutts_: although it might be a good place to start, and do the refactoring later
10:44:16 <byorgey> once you know exactly what you want to refactor =)
10:44:19 <marcot> marcot@quindinho:~/Modelos/debian/gtk2hs/gtk2hs-0.9.12.1$ debian/rules debian/control
10:44:25 <marcot> update-haskell-control: No description file found, please create a cabal-formatted description file with the name <pkgname>.cabal
10:44:39 <ndm> @seen kosmikus
10:44:39 <lambdabot> kosmikus is in #gentoo-haskell, #darcs, #ghc and #haskell. I don't know when kosmikus last spoke.
10:44:41 <marcot> BTW, is there a plan to cabalize gtk2hs?
10:44:49 <ndm> kosmikus: ping
10:44:58 <dcoutts_> marcot: yes, but it depends on some new cabal features
10:45:16 <ndm> anyone know anything about interaction between lhs2tex and setspace?
10:45:18 <marcot> dcoutts_: do you intend to do this in the next gtk2hs release?
10:45:32 <ndm> specifically, it seems that if i don't \usepackage{setspace} then lhs2tex stops working
10:45:32 <dcoutts_> marcot: no because that's due in the next couple days
10:45:54 <ndm> on this machine only, it seems to work on other machines just fine...
10:46:28 <marcot> dcoutts_: so maybe the other one then..
10:47:49 <byorgey> dcoutts_: http://hackage.haskell.org/trac/hackage/ticket/298
10:47:51 <lambdabot> Title: #298 (Local build logs) - Hackage - Trac
10:48:09 <dcoutts_> byorgey: ta
11:08:53 <kosmikus> ndm: what's the error?
11:09:18 <hpaste>  twobitwork pasted "need help with do notation" at http://hpaste.org/8427
11:09:38 <twobitwork> can someone look at that for me... I think I'm confused about do notation
11:10:08 <twobitwork> er... brb actually
11:10:32 <byorgey> twobitwork: which line is line 28?
11:12:09 <Yoric[DT]> Does anyone know the symbol for >>= in LaTeX?
11:14:16 <Philippa_> Yoric[DT]: just smudge >>= together
11:14:30 <Yoric[DT]> Doesn't look very good.
11:14:36 <Yoric[DT]> Doesn't look like Wadler's papers :)
11:14:41 <lament> there's a pretty one, with > and = joined together
11:14:53 * lament doesn't know what it is
11:18:36 <hpaste>  (anonymous) annotated "need help with do notation" with "(no title)" at http://hpaste.org/8427#a1
11:18:40 <twobitwork> sorry
11:19:05 <twobitwork> hpaste doesn't save my name when I check the box to do so... strange
11:20:46 <twobitwork> actually, the line with "push l ()" should be "Lua.push l ()" ... but that doesn't change the syntax error
11:22:06 <int-e> Yoric[DT]: lhs2TeX uses \newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
11:22:19 <Yoric[DT]> Thanks.
11:22:33 <Yoric[DT]> I was reaching something along these lines.
11:22:45 <Yoric[DT]> But I might as well skip a few steps:)
11:23:13 <Yoric[DT]> Looks good, thanks.
11:25:55 <byorgey> twobitwork: I think the problem is with the if.
11:26:07 <byorgey> twobitwork: try doing something like this:
11:26:11 <byorgey> if n
11:26:13 <byorgey>   then do
11:26:19 <byorgey>     ...
11:26:21 <byorgey>   else
11:26:22 <byorgey> and so on
11:26:58 <byorgey> twobitwork: with so many nested do's and such, I would personally be tempted to just use explicit { } and not worry about the indentation
11:27:16 <byorgey> I would also be tempted to break it down into smaller independent pieces.
11:27:36 <byorgey> @type guard
11:27:39 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:34:10 <twobitwork> byorgey: yeah, I'm not sure how to break it into smaller peices
11:34:52 <byorgey> twobitwork: did changing the indentation of the if help?
11:35:08 <twobitwork> nope
11:35:21 <twobitwork> the {} didn't help either
11:36:25 <twobitwork> Lua.next :: IO Bool, Lua.peek :: IO a, Lua.pop :: IO ()
11:36:49 <Dynetrekk> therp: got problem 15 ;-)
11:37:04 <twobitwork> actually... Lua.peek :: IO (Maybe a)
11:37:17 <ndm> kosmikus: it says SaveRestoreHooks isn't a known command
11:38:05 <twobitwork> @hoogle guard
11:38:06 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
11:38:06 <lambdabot> Language.Haskell.TH.Guard :: data Guard
11:38:06 <lambdabot> Language.Haskell.TH.Syntax.Guard :: data Guard
11:41:58 <dons> Igloo: doesn't GLUT have a missing extra-libraries dependency on 'glut' ?
11:41:59 <dons> http://hackage.haskell.org/packages/archive/GLUT/2.1.1.2/GLUT.cabal
11:42:01 <lambdabot> http://tinyurl.com/5f3pvt
11:42:54 <dcoutts> dons: I suspect the ./configure script does that bit
11:43:14 <dons> hmm.
11:44:08 <dcoutts> dons: see FP_CHECK_GLUT in the aclocal.m4, it sets @GLUT_LIBS@ in GLUT.buildinfo.in
11:44:57 <dons> looking
11:45:26 <dons> dcoutts: ah, it adds -lglut
11:45:33 <dons> cc-options: -DCALLCONV=ccall -I/usr/local/include -I/home/dons/include
11:45:33 <dcoutts> right
11:45:33 <dons> ld-options: -L/usr/local/lib -L/home/dons/lib -lglut  -lSM -lICE -lXmu -lXi  -lGLU -lGL -lm
11:45:49 <dons> so my tool doesn't understand ld-options that mean extra-libraries
11:46:02 <dons> should all -lFOOs really be extra-libraries: Foo
11:46:17 <dcoutts> dons: there's a function in Cabal for converting one to the other
11:46:25 <dons> ah, and that also means the deps aren't listed in the .cabal ever.
11:46:30 <dons> i'd have to configure
11:46:32 <dcoutts> dons: sigh
11:46:52 <dons> interesting. i wonder how best to support that.
11:46:58 <dcoutts> dons: yep, configure is a black box.
11:47:02 <dons> damn these configurations that depend on initialisation
11:47:40 <dcoutts> dons: so yes, to support it you'd have to unpack, configure and then inspect the .buildinfo
11:47:46 <dcoutts> not nice I'm afraid
11:48:49 <dons> ah, if build-type: Configure
11:48:51 <dons> extra handling
11:49:02 <dcoutts> dons: we should see how much of the configure scripts we could get into cabal and what features we lack
11:49:42 <dcoutts> dons: ideally. Note that not all packages specify a build-type yet. Many custom ones are really configure type
11:51:42 <twobitwork> how do you give type signatures in a where clause?
11:51:59 <Deewiant> as normal
11:52:00 <mrd> same way as at toplevel
11:52:24 <twobitwork> as in: f x y :: a -> b -> -> c = ...
11:52:41 <mrd> no
11:53:05 <mrd> f :: a -> b -> c; f x y = ...
11:53:10 <mrd> f x y :: c, anyhow
11:53:19 <Dynetrekk> can anyone tell me what's wrong with some ridiculously naive code?
11:53:27 <twobitwork> ahh
11:53:32 <mrd> ?paste
11:53:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:53:38 <Dynetrekk> module Main
11:53:38 <Dynetrekk>     where
11:53:38 <Dynetrekk> show (factorial 40) / (factorial 20) ^ 2
11:53:39 <byorgey> Dynetrekk: we can try, put it on hpaste =)
11:53:48 <Dynetrekk> ah...
11:53:57 <byorgey> Dynetrekk: you can't just put expressions in a file like that
11:53:59 <Deewiant> Dynetrekk: (/) doesn't work on integers, you want div
11:54:05 <dolio> So, I've got a program...
11:54:05 <byorgey> Dynetrekk: you would want to say something like
11:54:07 <Deewiant> and what byorgey said, you need a main function
11:54:12 <byorgey> main = print (factorial ....
11:54:16 <vixey> what does it do?
11:54:16 <Dynetrekk> now really
11:54:18 <dolio> With profiling turned on, it allocates 170 kilobytes on the heap.
11:54:36 <dolio> When compiled without profiling, it allocates 200 megabytes on the heap. :)
11:54:45 <Deewiant> heisenbugs for the win
11:54:51 <mrd> you changed the results by measuring it!
11:55:02 <Dynetrekk> oh please, heisenBERG
11:55:08 <Dynetrekk> :)
11:55:19 <Deewiant> sure, but that's a heisenBUG
11:55:31 <byorgey> @go heisenbug
11:55:32 <lambdabot> http://en.wikipedia.org/wiki/Heisenbug
11:55:55 <Dynetrekk> cool
11:56:49 <Dynetrekk> what's the type of a long in Haskell?
11:57:13 <Valodim> Integer
11:57:20 <Deewiant> we have Int, which is of fixed length, and Integer, of arbitrary length
11:57:30 <Dynetrekk> impressive
11:57:36 <vixey> "long"?
11:57:39 <Dynetrekk> yee, works
11:57:45 <dolio> There's also Int64, which would be like long if you're on a 32-bit machine.
11:57:47 <Deewiant> if you really want a C long it's in Foreign.C.Types and probably called CLong
11:57:47 <int-e> @index CLong
11:57:47 <lambdabot> Foreign.C.Types, Foreign.C
11:57:47 <Dynetrekk> (long in Java f.x.)
11:57:49 <Zao> And there's all of the Word32, Int16 and whatnot.
11:58:05 <Dynetrekk> well, I just wanted something a bit longer
11:58:09 <dolio> Of course, on a 64-bit machine (with GHC) Int itself is 64-bits.
11:58:09 <Deewiant> dolio: no, that'd be long long. :-)
11:58:16 <mrd> a bit longer? 65 bits?
11:58:29 <Dynetrekk> now wait, wouldn't it be 33?
11:58:31 <Deewiant> is it really 64 bits? aren't a few bits of that shaved off?
11:58:54 <Deewiant> > maxValue :: Int
11:58:55 <lambdabot>   Not in scope: `maxValue'
11:58:59 <Deewiant> meh
11:59:05 <Deewiant> > maxBound :: Int
11:59:07 <lambdabot>  2147483647
11:59:11 <Deewiant> evidently not
11:59:16 <mrd> ghc gc doesn't mark, but i'm not sure how it distinguishes a pointer from an int
11:59:22 <byorgey> Dynetrekk: ignore all of that.  you want Integer =)
11:59:38 <dolio> Deewiant: Huh, I guess I was thinking of Java.
11:59:40 <Dynetrekk> byorgey: fortunately, I understood that
11:59:44 <byorgey> =)
12:00:03 <Dynetrekk> byorgey: I know a lot of geeks, I know their Ways
12:00:19 <byorgey> Dynetrekk: ah, excellent.  well, you should feel right at home on #haskell then =)
12:00:37 <Dynetrekk> byorgey: yes, relatively. the only problem I have is the acute lack of loops
12:00:50 <byorgey> Dynetrekk: that's what lists are for.
12:00:55 <byorgey> > map (+1) [1..10]
12:00:57 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:01:09 <joey_> Loops? Heresy!
12:01:14 <Dynetrekk> byorgey: yes yes I know that there's some clever 'workaround' which makes your software nice
12:01:23 <Dynetrekk> why do you think I bother trying?
12:01:28 <Dynetrekk> ;)
12:01:28 <byorgey> Dynetrekk: instead of a loop with a variable taking on various values, think of a list with all the values you would want the loop variable to take on
12:02:04 <Dynetrekk> similar to python's for i in range(10) then
12:02:09 <Dynetrekk> (ish)
12:02:12 <byorgey> Dynetrekk: no, I'm not just trying to be clever, I'm trying to teach you how to translate from loops to a more functional style.
12:02:20 <byorgey> Dynetrekk: right.
12:02:42 <Dynetrekk> byorgey: I know. appreciate it. being mathematically inclined this whole functional style appeals to me
12:02:57 <byorgey> yup, that's the same reason I love it =)
12:02:57 <twobitwork> Dynetrekk: we have loops...
12:03:31 <vixey> no we don't
12:03:36 <byorgey> twobitwork: eh?
12:03:39 <twobitwork> we just don't have the same kind of hackish looping structures that other languages use as a workaround for the lack of proper tail calls :)
12:03:39 <Deewiant> sure we do, they're just not in the standard library
12:03:45 <vixey> loops are control flow modulating things
12:03:50 <vixey> there's no control flow in haskell
12:04:06 <byorgey> twobitwork: ah, well, if you want to look at it that way =)
12:04:08 <Deewiant> for :: (Monad m) => m a -> (a -> m Bool) -> (a -> m a) -> (m a -> m b) -> m ()
12:04:11 <Deewiant> or something
12:04:41 <Deewiant> s/m a -> m b/a -> m b/
12:04:46 <byorgey> we don't have loops, we have recursion, tail calls, rich data structures, and laziness =)
12:04:59 <Dynetrekk> byorgey: laziness is a general feature of geeks
12:05:15 <HunterXHunter33> > fix 1
12:05:15 <lambdabot>   add an instance declaration for (Num (a -> a))
12:05:25 <Deewiant> > fix (1:)
12:05:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:05:36 <HunterXHunter33> ah
12:06:27 <byorgey> > fix ((0:) . scanl (+) 1)
12:06:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:07:24 <joey_> > let f g x = if x == g x then x else f g (g x) in f cos 1
12:07:25 <lambdabot>  0.7390851332151607
12:07:54 <joey_> Would that be the fixpoint of cosine then?
12:08:19 <vixey> > 0.7390851332151607 == cos 0.7390851332151607
12:08:20 <lambdabot>  False
12:08:23 <vixey> no
12:08:33 <Deewiant> > fix ((0:).(1:).(zipWith(+)<*>tail))
12:08:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:08:54 <Deewiant> > fix cos
12:09:03 <HunterXHunter33> > fix ((0:) . scanl (+) 1) !! 10
12:09:05 <lambdabot>  55
12:09:07 <vixey> > iterate cos 1 :: [CReal]
12:09:09 <lambdabot>  thread killed
12:09:17 <lambdabot>  [1.0,0.5403023058681397174009366074429766037323,0.85755321584639341574410627...
12:09:44 <byorgey> > iterate cos 1 !! 20 :: CReal
12:09:59 <lambdabot>  thread killed
12:10:02 <byorgey> aww
12:10:33 <Deewiant> > let x = iterate cos 1 in map ((x !!).(*10)) [1..5] :: [CReal]
12:10:44 <lambdabot>  [Exception: Time limit exceeded
12:10:49 <Deewiant> meh
12:10:52 <Deewiant> > 1+1
12:10:53 <lambdabot>  2
12:11:43 <Dynetrekk> > 2+2
12:11:44 <lambdabot>  4
12:11:47 <Dynetrekk> weee
12:12:12 <vixey> > 4+4
12:12:14 <lambdabot>  8
12:12:21 <Deewiant> > let x = iterate cos 1 in map ((x !!).(*10)) [1..5] :: [Float]
12:12:23 <lambdabot>  [0.74423736,0.73918444,0.73908705,0.7390852,0.7390852]
12:13:01 <Deewiant> > iterate (join (+)) 1
12:13:02 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:13:12 <joey_> > cos 0.7390851332151607
12:13:13 <lambdabot>  0.7390851332151607
12:13:39 <roconnor> > cos 0.7390851332151607 :: CReal
12:13:40 <lambdabot>  0.7390851332151606023536284709904846779322
12:13:51 <ziman> > 0.7390851332151607 == cos (cos 0.7390851332151607)
12:13:52 <lambdabot>  False
12:14:04 <joey_> > (let f g x = if x == g x then x else g (f g x) in f cos 1) :: [CReal]
12:14:05 <lambdabot>   add an instance declaration for (Floating [CReal])
12:14:11 <joey_> > (let f g x = if x == g x then x else g (f g x) in f cos 1) :: Float
12:14:13 <lambdabot>  Exception: stack overflow
12:14:24 <joey_> > (let f g x = if x == g x then x else f g (g x) in f cos 1) :: Float
12:14:34 <Dynetrekk> regarding heisenbugs: this assumes the Copenhagen interpretation of QM, right?
12:14:35 <lambdabot>  Exception: Time limit exceeded
12:14:38 <joey_> Hmm.
12:16:10 <Beelsebob> Deewiant: that's an interesting one -- I wonder if that's significantly faster than map (^2) [1..] -- I'm guessing so
12:16:14 <CyberGarp> Anyone got time to tell me why the foldr stack overflows? http://pastie.org/218293 I've tried seq and $! all over to no avail.
12:16:15 <lambdabot> Title: #218293 - Pastie
12:16:54 <pgavin> @seen dcoutts
12:16:55 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 27m 12s ago.
12:17:34 <roconnor> @type zip `ap` tail
12:17:36 <Beelsebob> CyberGarp: I assume you mean foldl'?
12:17:36 <lambdabot> forall b. [b] -> [(b, b)]
12:17:40 <CyberGarp> yes
12:17:43 <dcoutts> hia pgavin
12:17:52 <CyberGarp> fat fingered that one
12:17:52 <Beelsebob> also CyberGarp hpaste.org
12:17:56 <CyberGarp> k
12:18:03 <roconnor> @type find
12:18:05 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:18:06 <pgavin> dcoutts: hi...  do you know if there's a binary package anywhere for gtksourceview-1.0?
12:18:14 <pgavin> dcoutts: err, for windows I mean
12:18:19 <HunterXHunter33> > iterate (\x -> (cos x)**2 + (sin x)**2) 1
12:18:21 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
12:18:34 <HunterXHunter33> > iterate (\x -> (cos x)**2 + (sin x)**2) 3435
12:18:35 <lambdabot>  [3435.0,0.9999999999999999,0.9999999999999998,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
12:18:41 <roconnor> > find (uncurry (==)) $ zip `ap` tail $ iterate cos 1
12:18:43 <lambdabot>  Just (0.7390851332151607,0.7390851332151607)
12:18:53 <dcoutts> pgavin: hmm, probably but iirc, it depended on loads of other stuff, mainly for printing actually.
12:19:01 <roconnor> > find (uncurry (==)) $ zip `ap` tail $ iterate cos (1::Float)
12:19:07 <dcoutts> pgavin: we might be able to do it with fewer deps with gtksourceview-2.0
12:19:09 <lambdabot> Terminated
12:19:16 <dcoutts> pgavin: but that's work for another release
12:19:20 <pgavin> dcoutts: ok
12:19:33 <pgavin> dcoutts: it looks like all the other packages (but mozembed) are buildable
12:19:39 <dcoutts> pgavin: great
12:19:40 <pgavin> dcoutts: is there a way to build mozembed?
12:19:42 <roconnor> > (let f g x = if x == g x then x else f g (g x) in f cos 1) :: Double
12:19:43 <lambdabot>  0.7390851332151607
12:19:56 <dcoutts> pgavin: I did look into it, but again it's hard. and lots of deps.
12:19:59 <roconnor> > iterate cos (1::Float)
12:20:01 <lambdabot>  [1.0,0.5403023,0.85755324,0.6542898,0.79348034,0.7013688,0.76395965,0.722102...
12:20:22 <dcoutts> pgavin: the nearest I got is that I think the mono people build it for windows so they can use it as part of their Gtk# stack.
12:20:47 <dcoutts> pgavin: since most windows builds of mozilla/gecko are Win32 native, not Gtk+
12:20:48 <pgavin> dcoutts: ok... well, if anyone really wants a mozembed or sourceview binary, we can do that at a later point
12:21:08 <dcoutts> pgavin: yep, we've not done them before in windows builds
12:21:17 <roconnor> > cos (0.7390852::Float)
12:21:18 <lambdabot>  0.7390851
12:21:19 <pgavin> dcoutts: k :)
12:21:22 <roconnor> > cos (0.7390851::Float)
12:21:23 <lambdabot>  0.7390852
12:21:31 <HunterXHunter33> > pi
12:21:33 <lambdabot>  3.141592653589793
12:21:40 <roconnor> > pi :: Float
12:21:41 <lambdabot>  3.1415927
12:21:48 <dcoutts> pgavin: I'm so glad you're looking after this stuff :-)
12:21:50 <vixey> > pi :: 22/7
12:21:51 <lambdabot>  Parse error at "22/7" (column 7)
12:22:04 <Deewiant> Beelsebob: indeed, it's quite a bit faster at least here
12:22:35 <Deewiant> Beelsebob: with join (+) it takes 0.3 seconds to calculate the sum of take 50000 of that, with map (2^) it's 17 seconds
12:22:51 <HunterXHunter33> > take (-1) [1..]
12:22:52 <lambdabot>  []
12:23:01 <Beelsebob> Deewiant: not a bad speedup at all then
12:23:03 <Beelsebob> shiny
12:23:11 <Deewiant> makes sense, of course - this can reuse previous results
12:23:13 <pgavin> dcoutts: no problem at all :)
12:23:31 <roconnor> memoizing?
12:23:47 <dcoutts> pgavin: next big task for us will be cabalising everything
12:23:57 <roconnor> how about iterate (*2) ?
12:24:25 <dcoutts> pgavin: actually my hope is that that'll help reinvigorate gtk2hs development, make it easier to hack on.
12:24:28 <FordCortina> @src fix
12:24:28 <lambdabot> fix f = let x = f x in x
12:24:31 <HunterXHunter33> > iterate (*2) x
12:24:33 <lambdabot>  [x,x * 2,x * 2 * 2,x * 2 * 2 * 2,x * 2 * 2 * 2 * 2,x * 2 * 2 * 2 * 2 * 2,x *...
12:24:56 <chessguy_> @bot
12:24:56 <vixey> > inelane 7884464
12:24:56 <lambdabot> :)
12:24:57 <lambdabot>   Not in scope: `inelane'
12:25:14 <Deewiant> roconnor: about the same as join (+) - between 0.2 and 0.3 seconds
12:26:01 <proq> I get the error "unexpected symbol "-?" when I try to use the -? syntax from examples in GITH with hugs. what do I need to import for this to work?
12:26:30 <HunterXHunter33> > product (iterate (+1) 1)
12:26:39 <pgavin> dcoutts: yeah, I talked to Saizan a bit about his work on cabal, I asked him to let me know when it's ready :)
12:26:42 <lambdabot> Terminated
12:26:49 <roconnor> Deewiant: something resembling join (*) ought to do even better
12:27:01 <roconnor> maybe
12:27:12 <HunterXHunter33> > product (take 20 (iterate (+1) 1))
12:27:13 <lambdabot>  2432902008176640000
12:27:15 <Dynetrekk> > multiple_filter :: Int [] -> []
12:27:15 <lambdabot>   Not in scope: `multiple_filter'
12:27:18 <roconnor> nevermind
12:27:27 <chessguy> so, i have a dumb question. why couldn't we have a type like (Int | Integer) -> String
12:27:34 <roconnor> hmm
12:27:40 <chessguy> where | would indicate that either type would be allowed
12:27:46 <byorgey> chessguy: you can.
12:27:47 <HunterXHunter33> > product [1..20]
12:27:48 <lambdabot>  2432902008176640000
12:27:55 <dcoutts> pgavin: right, so the main one is having decent c2hs support. The other big thing is that we've got rather a lot of tests in our configure.ac which we'd have to convert either into configurations stuff in the .cabal file or tests in Setup.hs
12:28:02 <byorgey> data MyType = I Int | N Integer,   MyType -> String ...
12:28:09 <chessguy> byorgey:  i mean directly :)
12:28:25 <dcoutts> pgavin: the good thing of course is that I can add features to cabal to make it easier :-) eg like I added pkg-config support.
12:28:35 <vixey> chessguy: Why is it a dumb question?
12:29:12 <chessguy> vixey:  i'm sure there's an obvious answer, like making type inference non-finite, or something
12:29:29 <vixey> chessguy: It's just a new (ugly) syntax for typeclasses
12:29:41 <dolio> Integral i => i -> String
12:30:10 <pgavin> dcoutts: one think we probably should do is resolve the c2hsLocal vs. real c2hs problem
12:30:25 <chessguy> well, true
12:30:29 <dcoutts> pgavin: yes, we'll have to go with real c2hs
12:30:35 <chessguy> hm
12:30:57 <hpaste>  Dynetrekk pasted "multiple filter" at http://hpaste.org/8428
12:31:15 <dcoutts> pgavin: which means loosing the feature where c2hs keeps a binary cache of the processed header file
12:31:19 <FordCortina> @src modify
12:31:19 <lambdabot> Source not found. My brain just exploded
12:31:30 <chessguy> i guess the original type would be a bit too picky, actually.
12:31:40 <pgavin> dcoutts: is there anyway we can push some of our modifications upstream?
12:31:48 <Dynetrekk> byorgey: know why that code doesn't work? (ghci)
12:31:49 <dcoutts> pgavin: yes, I'm also a c2hs dev :-)
12:31:52 <roconnor> > let x = 1:do { a <- x; let a2 = 2*join (*) a; [a2,a2*2] in x
12:31:52 <lambdabot>  Parse error at "in" (column 57)
12:32:01 <roconnor> > let x = 1:do { a <- x; let a2 = 2*join (*) a; [a2,a2*2]} in x
12:32:01 <lambdabot>  Parse error at "}" (column 56)
12:32:07 <byorgey> Dynetrekk: which code?
12:32:13 <byorgey> oh, you just pasted it
12:32:15 <vixey> Dynetrekk: it does work
12:32:18 <Dynetrekk> http://hpaste.org/8428
12:32:18 <roconnor> > let x = 1:(do { a <- x; let a2 = 2*join (*) a; [a2,a2*2]}) in x
12:32:18 <lambdabot>  Parse error at "})" (column 57)
12:32:22 <Dynetrekk> http://hpaste.org/8428
12:32:26 <dcoutts> pgavin: but the short term thing is just to loose the feature for a while. It didn't get moved upstream because it wasn't quite right and needs to be done properly.
12:32:28 <Dynetrekk> yep
12:32:33 <vixey> Dynetrekk: save it into a file and :l <file>.hs
12:32:33 <HunterXHunter33> ?seen hunter
12:32:34 <lambdabot> I haven't seen hunter.
12:32:38 <HunterXHunter33> ?seen hunterxhunter
12:32:39 <lambdabot> I saw hunterxhunter leaving #scala and #haskell 22h 24m 59s ago, and .
12:32:51 <byorgey> Dynetrekk: that looks fine to me, but you won't be able to paste it into ghci
12:33:02 <byorgey> Dynetrekk: just save it in a file, then load the file into ghci with  :load filename
12:33:17 <byorgey> Dynetrekk: or are you getting an error message?
12:33:20 <Dynetrekk> byorgey: I load it with $ ghci filename.hs
12:33:35 <Dynetrekk> which is fine, but then I try to access it, and the following shows up:
12:33:45 <Dynetrekk> http://hpaste.org/8428
12:33:50 <Dynetrekk> fuck
12:34:28 <Dynetrekk> <interactive>:1:0: Not in scope: `multiple_filter'
12:34:56 <HunterXHunter33> :load filename
12:35:02 <Dynetrekk> byorgey: and that's just not nice
12:35:06 <joey_> At GHCi are you getting the prompt as Prelude> or *Filename>?
12:35:19 <Dynetrekk> joey_: the latter
12:35:21 <byorgey> HunterXHunter33: you shouldn't have to do that if you do  ghci filname in the first place
12:35:25 <chessguy> @source
12:35:25 <lambdabot>  not available
12:35:31 <chessguy> @docs
12:35:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:35:38 <HunterXHunter33> byorgey: okey
12:36:01 <roconnor> > let x = 1:concat [[2*a*a,2*2*a*a] | a <- x] in x
12:36:02 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:36:20 <roconnor> Deewiant: how about that one?
12:36:21 <Dynetrekk> byorgey: I don't see any difference with respect to :load or ghci filename
12:36:35 <roconnor> although it could use more sharing
12:36:43 <roconnor> I don't know why my do expression didn't work
12:36:48 <byorgey> Dynetrekk: that's odd, hmm
12:37:15 <byorgey> Dynetrekk: what exactly do you type at the ghci prompt which gives you that error?
12:37:19 <HunterXHunter33> > iterate (*2) 1
12:37:21 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:37:33 <pgavin> dcoutts: I wish people making windows binaries would leave in the .pc files :/
12:37:45 <dcoutts> pgavin: yeah, we need those
12:37:52 <pgavin> dcoutts:
12:37:59 <Dynetrekk> byorgey: :t multiple_filter
12:37:59 <dcoutts> pgavin: do they have split dev and dll packages?
12:38:01 <pgavin> dcoutts: I've had to copy them over from linux
12:38:09 <pgavin> dcoutts: sometimes
12:38:14 <pgavin> dcoutts: well, most of the time
12:38:15 <dcoutts> pgavin: hmm, you might have to tweak them too
12:38:24 <chessguy> hm, how come we don't have a standard data.Stack?
12:38:28 <dcoutts> pgavin: which packages don't have the .pc files?
12:38:32 <chessguy> s/dat/Dat/
12:38:37 <roconnor> > let x = 1:(do { a <- x; let a2 = 2*a*a in [a2,a2*2]}) in x
12:38:38 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:38:42 <dcoutts> chessguy: Data.List :-)
12:38:44 <Dynetrekk> byorgey: multiple_filter 5 [1:100]
12:38:50 <pgavin> dcoutts: gstreamer, libxml2, rsvg (iirc)
12:38:57 <Dynetrekk> byorgey: same result, 'Not in scope...'
12:39:00 <vixey> Dynetrekk: that's a type error=
12:39:00 <roconnor> Deewiant: ^^ slighlty better
12:39:02 <byorgey> Dynetrekk: huh, strange, it works for me...
12:39:03 <pgavin> dcoutts: need xml2 for glade & gconf etc.
12:39:13 <joey_> Dynetrekk: Sure you're using the right spelling? Loading the right version of the file, etc?
12:39:14 <vixey> Dynetrekk: you should use , instead of :
12:39:17 <dcoutts> pgavin: right. I didn't build gstreamer before.
12:39:25 <vixey> > [1:100]
12:39:25 <lambdabot>   add an instance declaration for (Num [t])
12:39:27 <Dynetrekk> vixey: where?
12:39:27 <vixey> > [1,100]
12:39:28 <dcoutts> pgavin: not on windows I mean
12:39:29 <lambdabot>  [1,100]
12:39:38 <pgavin> dcoutts: right, neither have I :)
12:39:42 <Dynetrekk> vixey: didn't help, now did it, still not in scope
12:39:43 <byorgey> Dynetrekk: yeah, that's the only think I can think of, that you're editing a different version of the file than the one you are actually loading into ghci
12:40:00 <Dynetrekk> byorgey: typical mistake :P
12:40:04 <byorgey> did you move the file while you still had it open in your editor?  that happens to me sometimes =)
12:40:07 <vixey> Dynetrekk: it's important in general
12:40:17 <dcoutts> pgavin: yeah, I think there was no .pc file last time for xml. I can't remember what I did. It's all in the scripts though.
12:40:38 <dcoutts> pgavin: the ones in tools/win32/ that make the gtk+ dev tarballs out of the individual tarballs
12:40:43 <Dynetrekk> vixey: thanks for the tip! byorgey: indeed. the editor I use seems to ignore this
12:41:07 <chessguy> dcoutts:  i'm thinking of something more along the lines of http://www.aetion.com/src/Stack.hs and http://www.aetion.com/src/Stack.hs
12:41:23 <byorgey> Dynetrekk: wait, so was that the problem or not?
12:41:37 <Dynetrekk> byorgey: yep, it was... embarrassing but true
12:41:39 <pgavin> dcoutts: yeah, I'm going to have to tweak those a bit
12:41:51 <joey_> I'm sure we've all done it before
12:42:12 <joey_> The worst one is spamming ":r" to everyone I'm chatting to on MSN/IRC
12:42:14 <dcoutts> chessguy: oh, a monad with a stack as state
12:42:32 <Dynetrekk> byorgey: now, another stupid question: how do you make a list? something like [1:10] -> [1,2,3,4,5,...,10]
12:42:43 <joey_> Dynetrekk: [1..10]
12:42:44 <chessguy> > [1..10]
12:42:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:42:51 <vixey> エl；kじゃsdfjk
12:42:53 <byorgey> Dynetrekk: hehe, no problem, it happens to the best of us =)
12:42:56 <Dynetrekk> thanks guys!
12:42:59 <joey_> > [1,5..20]
12:43:01 <lambdabot>  [1,5,9,13,17]
12:43:10 <Dynetrekk> byorgey: then I'm hoping I'm the best one then... haha
12:43:16 <byorgey> hehehe
12:43:41 <byorgey> Dynetrekk: you can even make infinite lists that way:
12:43:43 <byorgey> > [1..]
12:43:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:44:00 <joey_> Hmm, are peano numbers defined anywhere that lambdabot can see?
12:44:05 <byorgey> > [3,5..]
12:44:06 <Dynetrekk> byorgey: so I heard... coming from java/C(++), it makes me worried... hehe
12:44:06 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
12:44:29 <HunterXHunter33> > enumFromTo 1 10
12:44:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:44:33 <vixey> joey, no
12:44:34 <Dynetrekk> lambdabot: you're a busy fellow, right?
12:44:42 <vixey> Cale, I wish you would add Mu :)
12:44:46 <byorgey> Dynetrekk: hehe =)  the secret, of course, is that they are only evaluated as far as needed
12:44:46 <vixey> aw.....
12:45:02 <byorgey> lambdabot is a she ;)
12:45:04 <vixey> joey, if we had Mu, we could make peano numbers
12:45:04 <vixey> oa
12:45:08 <xerox> vixey: what's Mu?
12:45:09 <HunterXHunter33> i also came from java and c
12:45:12 <joey_> Shame.
12:45:22 <Dynetrekk> byorgey: indeed! how do you know+
12:45:28 <byorgey> @where lambdabot
12:45:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:45:31 <joey_> Literally hours of fun making peano instances of enum and num!
12:45:36 <vixey> xerox: the fixpoint tpye
12:45:36 <vixey> type*
12:45:56 <byorgey> @vixen a/s/l
12:45:57 <lambdabot> 19/f/California
12:45:57 <HunterXHunter33> lamdabot looks like a south park character lol
12:46:17 <vixey> hmmm maybe we couldn't
12:46:19 <Dynetrekk> HunterXHunter33: agree
12:46:29 <vixey> I was thinking Mu (Either ())
12:46:38 <vixey> but maybe that's not valid ?
12:46:44 <Dynetrekk> byorgey: my French teacher told me all girls are 19. seems like this holds true for lambdabot as well
12:46:56 <chessguy> @vixey are you 19?
12:46:56 <lambdabot> i truely am
12:46:58 <byorgey> yup, the lambdabot picture was generated here: http://www.sp-studio.de/
12:46:59 <lambdabot> Title: Planearium.de presents: SP-Studio.de
12:47:07 <vixey> I am 19 actually :p
12:47:16 <byorgey> hehe
12:47:17 <chessguy> @vixen how long have you been 19?
12:47:17 <lambdabot> not too long
12:47:36 <Dynetrekk> @vixen what is the meaning of life?
12:47:37 <lambdabot> i'm not sure what i mean
12:47:42 <Dynetrekk> @vixen what is the meaning of liff?
12:47:43 <lambdabot> i'm not sure what i mean
12:47:52 <chessguy> @vixen what is huffman encoding?
12:47:52 <lambdabot> i dunno...
12:47:59 <HunterXHunter33> @vixen asl
12:47:59 <lambdabot> 19/f/California
12:48:08 <HunterXHunter33> @vixen are you a girl?
12:48:09 <lambdabot> yeah, why? of course i'm a girl
12:48:34 <HunterXHunter33> @vixen when is your birthday?
12:48:34 <lambdabot> when? now? later?
12:48:49 <BCoppens> @vixen aren't you underage?
12:48:50 <lambdabot> i just turned 19
12:48:52 <HunterXHunter33> @vixen are you a girl?
12:48:52 <lambdabot> yeah, why? of course i'm a girl
12:48:56 <HunterXHunter33> @vixen are you a boy?
12:48:57 <lambdabot> i truely am
12:49:00 <BCoppens> lol =)
12:49:02 <HunterXHunter33> holy shit
12:49:17 <HunterXHunter33> @vixen are you an alien?
12:49:18 <lambdabot> i truely am
12:49:22 <HunterXHunter33> cool
12:49:31 <Dynetrekk> @vixen are you turing complete?
12:49:31 <lambdabot> i truely am
12:49:39 <HunterXHunter33> ?faq
12:49:40 <lambdabot> The answer is: Yes! Haskell can do that.
12:49:40 <tromp> @vicer are you a rotten liar?
12:49:41 <lambdabot> Maybe you meant: dice ticker vixen
12:49:51 <tromp> @vixen are you a rotten liar?
12:49:51 <lambdabot> i truely am
12:50:06 <HunterXHunter33> @dice are you here?
12:50:07 <lambdabot> unexpected "a": expecting number
12:50:15 <HunterXHunter33> @dice 1
12:50:15 <lambdabot> 1 => 1
12:50:22 <HunterXHunter33> @dice 999
12:50:23 <lambdabot> 999 => 999
12:50:34 <vixey> :k Either ()
12:50:35 <lambdabot> * -> *
12:50:47 <xerox> ?dice 1d6
12:50:47 <lambdabot> 1d6 => 2
12:50:50 <joey_> @dice 3d4 + 13
12:50:51 <lambdabot> 3d4 + 13 => 18
12:51:01 <vixey> xerox: data Mu a = Mu { roll :: a (Mu a) }
12:51:09 <vixey> joey_: type N = Mu (Either ())
12:51:20 <tromp> @dice 50d2
12:51:20 <lambdabot> 50d2 => 72
12:52:01 <HunterXHunter33> ?src dice
12:52:01 <lambdabot> Source not found.
12:52:27 <vixey> z = Mu (Left ())
12:52:28 <vixey> s x = Mu (Right x)
12:52:40 <joey_> vixey: Ahh, I see
12:53:28 <Dynetrekk> joey_: and 'or' is written how?
12:53:34 <vixey> @src or
12:53:34 <lambdabot> or    =  foldr (||) False
12:53:55 <joey_> > True || False
12:53:56 <lambdabot>  True
12:54:02 <Twinside> hi
12:54:05 <hpaste>  Twinside pasted "Class overlaping problem" at http://hpaste.org/8429
12:54:08 <joey_> "or" works over lists
12:54:18 <HunterXHunter33> or [true,false,true]
12:54:25 <Dynetrekk> joey_: ah, okay
12:54:26 <HunterXHunter33> > or [true,false,true]
12:54:27 <lambdabot>   Not in scope: `true'
12:54:34 <joey_> > or [True, True, False]
12:54:35 <lambdabot>  True
12:54:54 <mrd> what I say 3 times is True
12:54:58 <Twinside> I've got a small problem with overlapping class in my code, is there a way around given my situation ( http://hpaste.org/8429 ) ?
12:55:36 <HunterXHunter33> ?src and
12:55:36 <lambdabot> and   =  foldr (&&) True
12:56:57 <Dynetrekk> I'm getting more convinced about Haskell now...
12:57:15 <joey_> If you're convinced already then you're sold
12:57:25 <joey_> Took me months of tinkering 'til I was convinced
12:57:27 <HunterXHunter33> for how much?
12:57:59 <Dynetrekk> joey_: I said more convinced, and I started at a few %... hehe
12:58:14 <joey_> Oh, well a step in the right direction at least
12:58:22 <Dynetrekk> joey_: indeed!
12:58:49 <Dynetrekk> > print
12:58:51 <lambdabot>  <() -> IO ()>
12:58:58 <HunterXHunter33> 100 lines of haskell == 1,000 lines of C
12:59:09 <Dynetrekk> HunterXHunter33: depends what you're doing
12:59:09 <mrd> which instance of Eq is that?
12:59:22 <tromp> > undefined
12:59:24 <lambdabot>  Exception: Prelude.undefined
12:59:32 <tromp> > [undefined,..]
12:59:32 <lambdabot>  Parse error at "..]" (column 12)
13:00:10 <tromp> > [undefined..]
13:00:12 <lambdabot>  Exception: Prelude.undefined
13:00:25 <joey_> > length $ take 10 $ [undefined ..]
13:00:26 <lambdabot>  Add a type signature
13:01:33 <tromp> :t enumFrom
13:01:35 <lambdabot> forall a. (Enum a) => a -> [a]
13:02:18 <pjdelport> joey_: Haskell needs the Enum instance before it can generate the list
13:02:28 <joey_> pjdelport: Indeed. Just noticed
13:02:51 <Dynetrekk> joey_: how do you define constants? say, I would like to define the fine structure constant as a "float"
13:03:01 <tromp> > [False..]
13:03:01 <lambdabot>  Parse error at "False..." (column 2)
13:03:25 <tromp> > succ False
13:03:26 <lambdabot>  True
13:03:27 <joey_> Hmm, something like pi = 3.1415; Dynetrekk ?
13:03:37 <Dynetrekk> joey_: exactly...
13:03:43 <joey_> x :: Float; x = 3.43
13:03:44 <tromp> > enumFrom False
13:03:44 <HunterXHunter33> > pi
13:03:46 <lambdabot>  [False,True]
13:03:46 <lambdabot>  3.141592653589793
13:03:47 <Dynetrekk> > e = 2.718281828
13:03:47 <lambdabot>  Parse error at "=" (column 3)
13:04:01 <joey_> Where ";" means a new line, that is.
13:04:05 <HunterXHunter33> > e
13:04:06 <lambdabot>  e
13:04:17 <Dynetrekk> joey_: you define it as a function??
13:04:30 <joey_> In Haskell, values are functions
13:04:31 <tromp> > ['z'..]
13:04:33 <lambdabot>  "z{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
13:04:43 <tromp> > length ['z'..]
13:04:44 <lambdabot>  1113990
13:04:52 <pjdelport> Dynetrekk: what's the difference between a value and a zero-argument function?
13:04:53 <Dynetrekk> joey_: I knew everything was supposed to be a function, but FFS
13:05:04 <Dynetrekk> pjdelport: it can still have an argument
13:05:10 <joey_> @type 34 -- Here, the value of 34 is a num type function with 0 arguments
13:05:12 <lambdabot> forall t. (Num t) => t
13:05:16 <Dynetrekk> mathematically: f(x) = 4
13:05:34 <Dynetrekk> joey_: so even literals then
13:05:35 <HunterXHunter33> > [(False)..]
13:05:36 <lambdabot>  [False,True]
13:05:46 <pjdelport> Dynetrekk: not a zero-argument function :)
13:06:02 <pjdelport> Dynetrekk: it's actually truer to say that in Haskell, everything is a value
13:06:05 <Dynetrekk> pjdelport: agree, but why does it HAVE to be zero-argument?
13:06:05 <pjdelport> including functions
13:06:12 <int-e> > [False ..]
13:06:13 <lambdabot>  [False,True]
13:06:24 <Dynetrekk> pjdelport: so, you have False, True, Truer in Haskell? hihi
13:06:45 <pjdelport> Dynetrekk: well, when it happens to be zero-argument, it ends up being the same as a value
13:06:52 <tromp> @src Bool enumFrom
13:06:52 <HunterXHunter33> and theres also Falser
13:06:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:06:56 <pjdelport> there's simply no difference to be made
13:07:06 <BMeph> What difference? ;)
13:07:42 <pjdelport> Dynetrekk: in languages without referential transparency, you can make a difference using side effects
13:08:04 <Dynetrekk> pjdelport: referential transparency?
13:08:22 <Dynetrekk> now, the one thing I don't like, is long difficult words...
13:08:37 <joey_> Essentialy, f x always produces the same result for a given x
13:08:40 * BMeph bows down to the Glorious RT
13:09:01 <BMeph> Dynetrekk: Why use a long word, when a diminutive one will suffice? ;)
13:09:13 <pjdelport> Dynetrekk: when people say Haskell is a "pure" functional language, referential transparency is usually what they mean
13:09:35 <joey_> Think about it this way, Dynetrekk
13:09:45 <Dynetrekk> BMeph: something like that
13:09:56 <BMeph> Dynetrekk: Heh-heh. :)
13:10:25 <joey_> In any pure function, you can replace any expression with its value without changing the result
13:10:28 <Dynetrekk> BMeph: I thought Haskell was about simplicity?
13:10:41 <Dynetrekk> joey_: I got that part from some 'wikipedia'-level article :-)
13:11:01 <nornagon> @remember BMeph Why use a long word, when a diminutive one will suffice?
13:11:02 <lambdabot> It is forever etched in my memory.
13:11:07 <murilobsd> the :break, not found ghc version  6.6.1
13:11:07 <pjdelport> Dynetrekk: referential transparency is all about simplicity
13:11:16 <Dynetrekk> joey_: essentially the idea of mathematical functions, which caught my interest in the first place
13:11:17 <murilobsd> *Main> :break 2
13:11:20 <murilobsd> unknown command ':break'
13:11:25 <joey_> Precisely, Dynetrekk
13:11:51 <Dynetrekk> joey_: good night, have to go! the function bed is calling.
13:12:04 <joey_> G'night.
13:13:46 <BMeph> Seriously, what's simpler than "the same function, given the same argument, ALWAYS gives the same answer"? :)
13:14:46 <twobitwork> is there something like map which instead of just passing the list element into the given function it passes both the list element, and the position within the list?
13:14:59 <mauke> map f . zip [0 ..]
13:15:08 <mauke> zipWith f [0 ..]
13:15:20 <twobitwork> yeah, I guess that works :)
13:15:36 <HunterXHunter33> even a pseudo random number generator returns the same number given the same arguments
13:16:02 <BMeph> HunterXHunter33: segmentation fault (core dumped).
13:16:09 <BMeph> ;)
13:16:18 <roconnor> @type flip zipWith [0..]
13:16:19 <lambdabot> forall a b c. (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
13:33:11 <mehrheit> what problem does the monomorphism restriction solve?
13:33:27 <mauke> none
13:33:52 <mehrheit> why is it in haskell then?
13:33:59 <mauke> to annoy programmers
13:34:38 <mehrheit> oh, ok
13:34:58 <byorgey> mehrheit: it's not so much that it solves a problem, as it is that it pre-emptively prevents a possible problem, while causing other ones.
13:35:56 <byorgey> mehrheit: the issue is that the programmer might think that a polymorphic binding will only be calculated once, but since it is actually a function of the class dictionary, it must be recalculated every time it is used
13:36:39 <byorgey> so it's sort of a premature optimization.
13:36:58 <byorgey> you'll be happy to know that the MR will be removed from the next release of GHC, AIUI
13:45:23 <vincenz> Who called?
13:45:23 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
13:48:00 <HunterXHunter33> who called?
13:48:15 <HunterXHunter33> Who called?
13:48:47 <mauke> THEN WHO WAS PHONE?!
13:56:19 <dons> http://www.reddit.com/info/6o4yi/comments/
13:56:19 <lambdabot> Title: reddit.com: "GHC doesn't even break a sweat with a million threads"
13:56:22 <dons> go simon!!
13:58:31 <hpaste>  twobitwork pasted "type problems" at http://hpaste.org/8430
13:58:44 <twobitwork> I can't figure out how to make the type system happy with this function
13:58:50 <vincenz> @tell ndm Shame
13:58:50 <lambdabot> Consider it noted.
14:00:39 <twobitwork> if I add a type for pushlist like "(Lua.StackValue v) => Lua.LuaState -> [v] -> IO ()" then it complains about an ambiguous type variable
14:01:05 <mauke> twobitwork: is that supposed to be a 1?
14:01:26 <twobitwork> on line 15?
14:01:36 <mauke> 6
14:01:40 <dolio> So dons, I was playing with my MBA# implementation of fannkuch, and noticed it does around 1.5 GB of heap allocation (whereas the current one does maybe 50k or something)...
14:02:08 <twobitwork> mauke: "pushit 1 lst" that is a one
14:02:20 <dolio> dons: So, I profiled, and it said that one function was doing 99% of the allocation or something. So I rewrote it to not do that...
14:02:51 <dons> huh...
14:02:57 <dolio> Except when I turn profiling off, the new version I wrote actually does more heap allocation than the original (a benchmark of just that function reveals that the original doesn't really do any).
14:03:14 <dons> profiling interferes with some funky optimisatinos
14:03:37 <dolio> So, it would appear that there's no way to find out which function is actually doing allocation.
14:03:54 <mauke> twobitwork: which type variable is ambiguous?
14:03:59 <dolio> Because the one that does it when profiling is off doesn't do it when it's on, and the one that does it when it's on doesn't do it when it's off. :)
14:04:54 <twobitwork> hold on, I'll paste
14:05:59 <hpaste>  (anonymous) annotated "type problems" with "(no title)" at http://hpaste.org/8430#a1
14:06:17 <twobitwork> there's the error when I change the type signature
14:06:19 <dcoutts> is it just me or are the emails from haskell.org mailing lists coming in about 10 hours late?
14:06:51 <mauke> ah, much better
14:06:54 <shapr> yow!
14:07:00 <dcoutts> @arr!
14:07:00 <lambdabot> Aye Aye Cap'n
14:07:18 <mauke> twobitwork: what happens when you change 'Lua.push l n' to 'Lua.push l (n :: Int)'?
14:07:51 <twobitwork> well I'll be...
14:07:53 <twobitwork> that fixes it
14:07:58 <sclv_> @seen bos
14:07:58 <lambdabot> I saw bos leaving #ghc and #haskell 1h 3m 46s ago, and .
14:08:18 <sclv_> hmm... anyone know if the concurrency bug bos found is fixed in 6.8.3?
14:08:23 <sclv_> its sort of a showstopper for me.
14:09:59 <twobitwork> do the release notes or changelog say anything?
14:10:01 <shapr> @seen simonpj
14:10:02 <lambdabot> I haven't seen simonpj.
14:10:03 <shapr> aww
14:10:31 <twobitwork> mauke: thanks
14:14:15 <dolio> SamB: You're a stern taskmaster. "Just finished coinduction? Get going on universe polymorphism. Chop chop." :)
14:19:55 <therp> http://www.haskell.org/haskellwiki/Memoization references in 2.1 in memoFix a "memoize" function. isn't that supposed to mean memoFix?
14:19:56 <lambdabot> Title: Memoization - HaskellWiki
14:20:16 <roconnor> @hoogle mighty
14:20:16 <lambdabot> No matches found
14:20:29 <gubagem> @hoogle tiamat
14:20:30 <lambdabot> No matches found
14:22:11 <Botje> therp: no, i don't think so
14:22:21 <hpaste>  adekoba pasted "pascal's triangle" at http://hpaste.org/8431
14:22:46 <therp> Botje: hmm.. I don't see the point in the definition, so it's hard to guess what memoize should stand for..
14:23:01 <adekoba> i was wondering if anyone could make any suggestions on how to optimize "pad" and "padspace" in http://hpaste.org/8431
14:23:04 <therp> ah probably it means this memoize function at top.. I overlooked that..
14:23:07 <Botje> therp: memoize is explained at the top of the page , yeah
14:23:15 <Botje> it just transparently memoizes a function
14:23:56 <Botje> let mf = memoize (f mf) in mf is an instance of the "tying the knot" pattern
14:24:01 <Botje> which i still don't get :)
14:24:19 <therp> hmm me neither, at least not on the third read of the Typing_the_Knot wiki page
14:25:23 <therp> project euler is really fun
14:25:23 <ddarius> http://web.archive.org/web/20061011010615/http://www.haskell.org/hawiki/TyingTheKnot
14:25:24 <lambdabot> Title: TyingTheKnot - The Haskell Wiki, http://tinyurl.com/5uftfe
14:25:42 <Botje> yeah
14:25:53 <therp> ddarius: it's a bit "much"
14:26:10 <Botje> adekoba: woah. that align function is looking pretty scary
14:27:51 <Botje> adekoba: is there a good reason for separating out process from process'
14:28:15 <adekoba> Botje: not really sure. i just starting using haskell a couple weeks ago
14:28:29 <adekoba> Botje: i guess it could be merged into align
14:28:29 <Botje> you can replace the definition of process by the definition of process'
14:28:44 <adekoba> I'll try it
14:28:50 <Botje> and do (process 0) in the pipeline you've got going in align
14:29:05 <adekoba> yar
14:29:12 <Botje> you can replace the second check in padspace with otherwise
14:29:19 <Botje> that way you only have to evaluate length x once
14:29:30 <adekoba> oh, nice. that's right.
14:29:32 <ddarius> therp: That's a different page.
14:31:50 <adekoba> Botje: do you think pad could be more efficient?
14:31:56 <Botje> adekoba: probably
14:31:59 <Botje> i'm still digesting your code :)
14:33:42 <Botje> concat $ intersperse "\n" == unlines
14:34:00 <Botje> (we really need a list of equivalent prelude functions)
14:35:11 <Botje> is there a good reason for the second replicate n " " in process' ?
14:35:22 <Botje> if it's going to be at the end of the line anyway ..
14:35:25 <mauke> (concat .) . intersperse == intercalate
14:35:36 <mauke> and it's not unlines
14:35:53 <Botje> okay, not exactly.
14:35:54 <mauke> unlines = concatMap (++ "\n")
14:35:55 <adekoba> Botje: yeah, because otherwise the lists would not all be the same length
14:36:01 <Botje> adekoba: oh
14:36:11 <adekoba> Botje: perhaps not reason enough, but I couldn't figure out a way around it
14:36:39 <povman> :t unlines
14:36:42 <lambdabot> [String] -> String
14:36:53 <mauke> @src unlines
14:36:53 <lambdabot> unlines = concatMap (++ "\n")
14:36:57 <mauke> whee :-)
14:37:11 <Botje> mauke: well, since he's doing putStrLn at the end, i think that was the intended effect
14:37:16 <povman> @pl (concat.intersperse)
14:37:16 <lambdabot> join . intersperse
14:37:18 <Botje> adekoba: can you paste the cleared up version?
14:37:22 <Botje> just annotate your current paste
14:37:34 <Botje> so we have a clearer view
14:37:35 <povman> @pl (concat.intersperse "n")
14:37:36 <lambdabot> join . intersperse "n"
14:37:38 <adekoba> Botje: yep, one sec
14:37:46 <mauke> :t concat.intersperse "n"
14:37:47 <lambdabot> [[Char]] -> [Char]
14:38:27 <hpaste>  adekoba pasted "pascal, new version" at http://hpaste.org/8432
14:38:56 <Botje> adekoba: on hpaste you can add new text to existing pastes with the annotate button at the top
14:39:03 <Botje> that's what I meant, but no problem :)
14:39:25 <Botje> adekoba: okay.
14:39:34 <Botje> process n xs is really a foldr
14:40:18 <Botje> hmm
14:40:24 <Botje> maybe not exactly
14:40:26 <Botje> bah, nm that
14:41:23 <proq> @hoogle -?
14:41:23 <lambdabot> hoogle: unrecognized option `-?'
14:41:23 <lambdabot> HOOGLE - Haskell API Search
14:41:23 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
14:41:23 <lambdabot>  
14:41:23 <lambdabot> Usage: hoogle [OPTION...] search
14:41:24 <GNU\caust1c> hey, someone here who can help me with numeric? :x
14:41:26 <lambdabot> [15 @more lines]
14:42:13 <mauke> @more
14:42:14 <lambdabot>   -v                  --verbose   verbose results
14:42:14 <lambdabot>   -n 30               --count=30  number of results
14:42:14 <lambdabot>   -l path/hoogle.txt              path to hoogle.txt
14:42:14 <lambdabot>   -h                  --help      help message
14:42:14 <lambdabot>   -c                  --color     show with color
14:42:16 <lambdabot> [10 @more lines]
14:42:32 <proq> @src -?
14:42:33 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:42:36 <Botje> @hoogle -`ls`
14:42:36 <lambdabot> hoogle: unrecognized option `-`'
14:42:36 <lambdabot> HOOGLE - Haskell API Search
14:42:36 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
14:42:36 <lambdabot>  
14:42:36 <lambdabot> Usage: hoogle [OPTION...] search
14:42:38 <lambdabot> [15 @more lines]
14:42:41 <Botje> phew :p
14:43:09 <proq> @src `-?`
14:43:09 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:44:05 <Botje> adekoba: columnwidth and pad are a bit redundant i think
14:44:09 <vincenz> @hoogle $(echo "hi")
14:44:09 <lambdabot> Hoogle Error: Parse Error: Unexpected character '$(echo "hi'
14:44:21 <adekoba> Botje: i was thinking, maybe `padspace` could be made into a list, that way it wouldn't need to be generated for every element
14:44:33 <vincenz> @hoogle -l /etc/passwd
14:44:33 <lambdabot> HOOGLE - Haskell API Search
14:44:33 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
14:44:33 <lambdabot>  
14:44:37 <vincenz> o.O
14:44:39 <vincenz> serious hole
14:44:41 <Botje> you have to generate it anyway
14:44:54 <Botje> adekoba: but if i read your code correctly
14:45:05 <adekoba> Botje: yeah, but if I declare it locally (with `where`) for pad, it would only need to be generated once
14:45:23 <Botje> you're doindg padspace (x !! index) (maximum $ x !! index)
14:45:41 <Botje> so you could move the calculation for columnwidth to padspace i think
14:45:49 <adekoba> hm, i'll try that
14:46:22 <Botje> so you might as well only pass x !! index
14:46:41 <Botje> and have your padspace figure out how much to pad
14:47:43 <adekoba> I don't think that would work. columnwidth depends on xs, i.e. the entire Triangle
14:48:04 <adekoba> padspace is independent and only works on single elements
14:48:10 <Botje> hmm
14:48:10 <proq> @src (-?)
14:48:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:48:13 <povman> adekoba: is there a way you can rewrite process to remove the reverses?
14:48:18 <Botje> then i'm getting the semantics wrong
14:48:56 <adekoba> Botje: what do you mean?
14:49:38 <adekoba> povman: yeah, i might be able to, looking at it. It would need the length of the list passed to it
14:50:06 <povman> would it?
14:51:00 <adekoba> povman: to calculate how many spaces are required, i think
14:51:37 <Botje> adekoba: you can figure out the columnwidths with a simple foldr
14:51:43 <Botje> (for real, this time :P)
14:51:53 <Botje> or a foldl, which should work even nicer
14:53:19 <mauke> bah, perl needs zipWith
14:53:58 <Botje> foldl (\a b -> zipWith max a $ map length b) (repeat 0) list
14:54:05 <Botje> mauke: like List::MoreUtils::pairwise?
14:54:08 <adekoba> Botje: gah. haskell screqs with my mind
14:54:10 <hpaste>  povman annotated "pascal, new version" with "rewritten process" at http://hpaste.org/8432#a1
14:54:15 <povman> there
14:54:16 <gubagem> does anyone know how to mount a usb flashdrive under openbsd, yes i know use the mount command, what would the /dev/name be
14:54:31 <adekoba> povman: cool
14:54:35 <adekoba> Botje: h/o
14:54:37 <dons> mount -t msdos /dev/sd0i /mnt ?
14:54:41 <dons> mount -t msdos /dev/sd1i /mnt perhaps
14:54:52 <mauke> Botje: no
14:54:57 <dons> gubagem: look at your /var/logs/* to see what it was detected as
14:55:08 <proq> gubagem: dmesg will tell you the name
14:55:15 <proq> ...usually
14:55:17 <Botje> mauke: "Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a new list consisting of BLOCK’s return values."
14:55:24 <Botje> sure smells like zipWith to me
14:55:36 <mauke> Botje: I don't have arrays, and why limit it to two of them?
14:56:15 <Botje> ah.
14:56:21 * gubagem thanks dons and proq
14:56:22 <Botje> that's tricky, then
14:56:35 <mauke> I'd prefer something like map { ... } transpose $foo, $bar, $baz
14:56:38 <adekoba> Botje: brilliant. it made it a bit faster
14:59:14 <adekoba> povman: it works, but I'm not quite sure what const does
14:59:33 <povman> @src const
14:59:33 <lambdabot> const x _ = x
14:59:35 <Botje> > map (const 'X') "I like cookies!"
14:59:36 <povman> :)
14:59:37 <lambdabot>  "XXXXXXXXXXXXXXX"
14:59:38 <proq> > max [1,3,8]
14:59:39 <lambdabot>  <[Integer] -> [Integer]>
14:59:50 <chessguy> @where edison
14:59:51 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
15:00:11 <hpaste>  adekoba annotated "pascal, new version" with "updated version of triangle" at http://hpaste.org/8432#a2
15:00:11 <vincenz> :t max
15:00:14 <lambdabot> forall a. (Ord a) => a -> a -> a
15:00:22 <lament> > maximum [1,3,8]
15:00:24 <lambdabot>  8
15:00:25 <vincenz> > max [1,2,3] [1,2,4
15:00:26 <lambdabot>  Parse error at end of input
15:00:28 <vincenz> > max [1,2,3] [1,2,4]
15:00:29 <lambdabot>  [1,2,4]
15:00:32 <vincenz> o.O
15:00:32 <ziman> > let last = foldr1 (flip const) in last [1..10]
15:00:34 <lambdabot>  10
15:00:47 <vincenz> oh riht, lexicographical ordering
15:00:57 <Botje> @pl \a b -> zipWith max a $ map length b
15:00:57 <lambdabot> (. map length) . zipWith max
15:01:14 <Botje> ah
15:01:19 <Botje> that makes sense .. kind of
15:02:04 <Botje> adekoba: okay, next up, getting rid of the crufty map inside the list comprehension
15:02:16 <proq> max [1,20] [2,18]
15:02:16 <chessguy> is there a type in haskell for bits?
15:02:20 <proq> > max [1,20] [2,18]
15:02:21 <dobblego> > some (Just 7) -- why does this cause a stack overflow?
15:02:23 <lambdabot>  [2,18]
15:02:23 <lambdabot>  Exception: stack overflow
15:02:24 <chessguy> i.e., 0 and 1
15:03:10 <mmorrow> :t some
15:03:12 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
15:03:15 <Botje> [ item | (index, l) <- zip [0..(2*n-2)] xs, let item = padspace l (columnwidth !! index) ]
15:03:26 <mmorrow> @src Alternative
15:03:26 <lambdabot> class Applicative f => Alternative f where
15:03:27 <lambdabot> 	empty :: f a
15:03:27 <lambdabot> 	(<|>) :: f a -> f a -> f a
15:03:34 <mmorrow> @src some
15:03:35 <lambdabot> some v = some_v
15:03:35 <lambdabot>   where many_v = some_v <|> pure []
15:03:35 <lambdabot>         some_v = (:) <$> v <*> many_v
15:03:38 <Botje> hmm
15:03:42 <Botje> that's not quite correct :[
15:03:47 <mauke> chessguy: Integer
15:03:55 <mauke> oops
15:04:03 <mauke> I don't think so
15:04:07 <chessguy> uh, not exactly isomorphic
15:04:12 <povman> chessguy: Bool?
15:04:16 <chessguy> i'd use Bool over Integer
15:04:24 <chessguy> but i didn't know if there was a closer match
15:04:32 <mauke> data Bit = Off | On
15:04:49 <gubagem> i'd use Loob over Bool, but it would depend on how slick I wanted to be
15:05:02 <chessguy> oh brother
15:05:26 <povman> what's... loob
15:05:51 <mmorrow> > reverse . reverse $ "loob"
15:05:52 <mauke> a smooth variation on loeb
15:05:53 <lambdabot>  "loob"
15:05:53 <povman> chessguy: Bool represents a bit - what are you after?
15:05:59 <gubagem> bool spelled backwards also the a phonetic way of spelling lube
15:06:20 <povman> oh a dirty joke
15:06:20 <chessguy> povman:  something isomorphic to Bool, but which has the properties of actual numbers
15:06:47 <povman> you mean something which has +?
15:06:56 <tromp> that would be called Bit, no?
15:06:58 <Botje> okay
15:07:02 <chessguy> povman:  i'm actually not sure what exact properties i want
15:07:09 <Botje> adekoba:
15:07:16 <chessguy> is there a Bit datatype?
15:07:19 <Botje> pad xs = transpose [ item | (cw, index) <- zip columnwidth [0..(2*n-2)], let item = map (\x -> padspace (x !! index) cw) xs]
15:07:21 <chessguy> @hoogle Bit
15:07:21 <lambdabot> Data.Bits.bit :: Bits a => Int -> a
15:07:21 <lambdabot> Data.Bits :: module
15:07:21 <lambdabot> Data.Bits.Bits :: class Num a => Bits a
15:07:28 <chessguy> not quite
15:07:36 <Botje> that removes another list scan
15:07:41 <povman> chessguy: what's it for?
15:07:56 <tromp> it could also be called Word1
15:07:57 <chessguy> povman:  playing around with huffman encoding to bitstrings
15:08:03 <mmorrow> @src transpose
15:08:03 <lambdabot> transpose []             = []
15:08:03 <lambdabot> transpose ([]   : xss)   = transpose xss
15:08:03 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:08:08 <chessguy> maybe i do want bits
15:08:12 <chessguy> Bits
15:08:16 <mauke> instance Num Bool where fromIntegral = odd; (+) = (/=); (*) = (&&); negate = id
15:08:31 <monochrom> hehe
15:08:37 <monochrom> you also need signum
15:08:46 <mauke> :t signum
15:08:48 <lambdabot> forall a. (Num a) => a -> a
15:08:53 <chessguy> mauke++
15:08:54 <mauke> signum = id
15:08:57 <chessguy> that's just cool :)
15:09:05 <adekoba> Botje: *still trying to digest it*
15:09:11 <adekoba> Botje: it works btw
15:09:15 <Botje> adekoba: in short
15:09:22 <Botje> instead of doing columnwidth !! index everytime
15:09:38 <Botje> you "loop over" columnwidth and [0..2*(n-1)] at the same time
15:09:46 <byorgey> hmm, but with (+) = (/=), fromIntegral isn't natural
15:10:09 <adekoba> yes, this makes sense now
15:10:49 <povman> chessguy: Integer is an instance of Bits
15:10:52 <hpaste>  adekoba annotated "pascal, new version" with "pascal's triangle" at http://hpaste.org/8432#a3
15:10:53 <hpaste>  adekoba annotated "pascal, new version" with "pascal's triangle" at http://hpaste.org/8432#a4
15:12:52 <adekoba> thanks for cleaning it up guys. I really appreciate it.
15:18:05 <hpaste>  chessguy pasted "algorithms/data structures" at http://hpaste.org/8433
15:18:25 <chessguy> i'm looking over some old lecture notes, and i wonder if it would be beneficial to the community to implement any of these in haskell
15:18:40 <Botje> adekoba: last and (at least from me) final cleanup:
15:18:50 <Botje> pad xs = transpose [ map (flip padspace cw) items | (cw, index, items) <- zip3 columnwidth [0..(2*n-2)] (transpose xs)]
15:18:56 <Botje> assuming you don't mind transposing twice
15:18:58 <chessguy> or if they've all been done and/or considered ineffiecient in haskell
15:19:36 <chessguy> @pl pad xs = transpose [ map (flip padspace cw) items | (cw, index, items) <- zip3 columnwidth [0..(2*n-2)] (transpose xs)]
15:19:36 <lambdabot> pad = transpose . return . ((map (flip padspace cw) items | (cw, index, items)) <-) . zip3 columnwidth [0..2 * n - 2] . transpose
15:19:42 <Botje> ah yes
15:19:46 <Botje> the final improvement.
15:20:02 <Botje> if only that would work >:)
15:20:10 <chessguy> it doesn't?
15:20:17 <mauke> @. pl undo pad xs = transpose [ map (flip padspace cw) items | (cw, index, items) <- zip3 columnwidth [0..(2*n-2)] (transpose xs)]
15:20:17 <lambdabot> (line 1, column 8):
15:20:17 <lambdabot> unexpected "="
15:20:17 <lambdabot> expecting variable, "(", operator or end of input
15:20:28 <mauke> @. pl undo \xs -> transpose [ map (flip padspace cw) items | (cw, index, items) <- zip3 columnwidth [0..(2*n-2)] (transpose xs)]
15:20:28 <lambdabot> (line 1, column 42):
15:20:29 <lambdabot> unexpected ","
15:20:29 <lambdabot> expecting letter or digit, operator or ")"
15:20:29 <lambdabot> ambiguous use of a non associative operator
15:20:34 <Botje> chessguy: it doesn't know [...|....] is a list comprehension
15:20:53 <chessguy> bah
15:21:04 <Botje> patches welcome! ;)
15:23:00 <dons> looks like the mail backlog is clearing
15:23:06 <Igloo> dons: I get "ld-options:  -lglut [...]" in GLUT.buildinfo; I don't know if it should also need that
15:23:16 <dons> that is correct.
15:23:25 <dons> my concern was that the glut dep wasn't listed in the .cabal file
15:23:26 * Botje will be spending some quality time with haskell-cafe soon
15:23:28 <Botje> 2400 unread mails :)
15:23:31 <chessguy> so any thoughts on these data structurs and/or algorithms?
15:23:33 <dons> but it is correctly found via build-type: Configure
15:23:42 <dons> it just means that cabal files with build-type: Configure are less useful
15:23:49 <dons> or amenable to static analysis
15:23:57 <dons> they depend on a runtime initialisation phase
15:24:12 <dcoutts> dons: Custom too
15:24:20 <dons> Igloo: so unless 'glut' is the standard name for this on every arch, it is probably ok as is.
15:24:21 <dcoutts> indeed everything other than Simple
15:24:36 <dons> if "glut" does happen to be the correct name, we could put it in extra-libraries
15:24:39 <dons> which would be useful
15:24:53 <dcoutts> and if it's only like one OS where it's different then we can use configurations
15:24:54 <dons> hsmagick is another one, it depends only after configuration on graphicsmagick
15:25:11 <Igloo> dons: I dunno, try the Cabal or GLUT chiefs  :-)
15:25:25 <dons> dcoutts: more warnings about the use of Configure type might be good
15:25:33 <dons> or are they rare now, to see new   Configure packages?
15:25:46 <dons> perhaps we can reduce the amount of configure needec
15:25:54 <dcoutts> dons: I'm not sure actually
15:26:30 <dcoutts> dons: certainly. As I say, we should look at what the existing configure scripts are doing and see what things we're missing in Cabal to replace them.
15:26:53 <dons> does cabal --check currently prevent new packages uploading without a build-type set?
15:26:58 <dcoutts> dons: yep
15:27:13 <dcoutts> dons: looking at configure scripts and filing feature requests would be valuable activity
15:27:45 <dcoutts> btw, I got glib cabalised :-)
15:27:53 <dcoutts> gtk will be abotu 100x harder though :-)
15:29:00 <dons> i've been directly contacting authors on hackage with .cabal patches for the past week
15:29:03 <Vq^> :-o
15:29:10 <Vq^> @karma+ dcoutts
15:29:10 <lambdabot> dcoutts's karma raised to 49.
15:29:41 <dcoutts> dons: great. What kind of things?
15:30:00 <dcoutts> dons: kolmodin and I were saying we should be able to just edit .cabal files on hackage. I mean distro maintainers etc.
15:30:23 <chessguy> where did we wind up with regards to putting Data.Zipper in the standard libraries?
15:30:25 <MisterN> this channel is always like a completely different world, so much unlike everything else. most of the time, you don't even understand what kind of thing people are talking about.
15:30:34 <dcoutts> dons: and in principle that's quite possible. We can edit the one in the index and clients like cabal-install use that in preference to the one in the tarball.
15:31:32 <chessguy> MisterN:  it's like anything else, once you know the language, you understand what's going on a lot more
15:31:39 <chessguy> it just takes a while to learn the language :)
15:31:59 <lament> MisterN: #nethack used to give me that feeling too.
15:32:04 <MisterN> chessguy: well, take the fix-point function
15:32:06 <MisterN> @src fix
15:32:07 <lambdabot> fix f = let x = f x in x
15:32:14 <MisterN> sometimes i think i get it
15:32:29 <MisterN> then again, maybe a month later i think "what the fuck how can this possibly work"
15:33:25 <lament> MisterN: it's a rewrite rule.
15:33:32 <lament> you see x, you replace it with f x
15:34:02 <lament> then you still see x, so you replace it with f x again.
15:34:15 <MisterN> f f f f f f ... x
15:34:21 <MisterN> when does it stop however? and why?
15:34:25 <monochrom> MisterN: http://www.vex.net/~trebla/haskell/fix.xhtml
15:34:41 <lament> MisterN: with eager evaluation, everything would get expanded
15:34:45 <rwbarton> But the second time you might not see x right away, due to lazy evaluation
15:34:50 <lament> MisterN: but lazy evaluation means that some rewrite rules never get to be applied
15:35:05 <povman> @src transpose
15:35:05 <lambdabot> transpose []             = []
15:35:05 <lambdabot> transpose ([]   : xss)   = transpose xss
15:35:05 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:35:08 <MisterN> they will get applied only once somebody "pokes" into the x?
15:35:34 <MisterN> well, the runtime being "somebody" of course :D
15:35:40 <rwbarton> If by "pokes into" you mean "wants to know something about the value of", then yes
15:35:55 <lament> MisterN: the rewriting is part of evaluating x
15:36:05 <lament> We want to evaluate x, so we apply the rewrite rule.
15:36:14 <lament> If at some stage we no longer want to evaluate x, we won't apply the rule.
15:36:26 <lament> For example, if f x = 5, we don't need to know the value of x.
15:37:45 <MisterN> i think i get it now
15:37:51 <MisterN> i hope i can keep that in memory
15:38:02 <monochrom> buy more ram chips
15:38:37 <lament> MisterN: this isn't about fix, it's how everything works in Haskell. If you can't keep it in memory, you will have problems writing anything
15:38:57 <MisterN> lament: i don't really use haskell at this time, so it's no vital problem.
15:39:11 <monochrom> You can keep it on a Post-It note stuck to your computer screen.
15:39:27 <MisterN> my laptop screen's not really suitable for post-it notes ;)
15:40:29 <dieJana> what's the meaning of "higher-order" in the context "higher order peano arithmetic"?
15:40:33 <monochrom> someone should write a haskell book in the form of a thousand Post-It notes.
15:40:56 <MisterN> dieJana: you know ordinal numbers?
15:40:57 <dieJana> I mean, is it about being able to define functions, or quantifying over functions?
15:41:04 <monochrom> I think it means you operate on subsets of numbers, not just numbers.
15:41:06 <dieJana> MisterN: some, yeah
15:41:31 <monochrom> Yes, same as operating on functions.
15:41:33 <MisterN> dieJana: where you say that "if you give me a set of ordinal numbers, i'll just give you a number which is greater than that, by definition"?
15:41:52 <MisterN> so those numbers don't even form a set
15:42:00 <MisterN> THAT'S higher order for me :)
15:42:07 <dieJana> okay
15:42:19 <MisterN> but probably not related to your problem at all :D
15:42:30 <dieJana> to put it simpler, then, in first order all you can do is work with numbers and quantify over numbers and such
15:42:45 <dieJana> MisterN: just a bit too much for what I'm working with, yeah :)
15:43:01 <monochrom> http://en.wikipedia.org/wiki/Second-order_arithmetic
15:43:23 <dieJana> aye, good, I was searching for heyting, and they have too little on it, still
15:43:24 <monochrom> I suppose higher-order builds on that.
15:43:45 <dieJana> well, it's already answering my quest, 2nd order is more than 1st order :)
15:43:53 <chessguy> @hoogle maybe
15:43:54 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
15:43:54 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
15:43:54 <lambdabot> Data.Maybe :: module
15:43:55 <dieJana> cheers
15:44:07 <BMeph> @hoogle something
15:44:07 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
15:44:20 * BMeph wants that on a T-shirt...
15:44:27 <dieJana> hew
15:44:41 <MisterN> BMeph: why? :)
15:44:47 <lament> Maybe u do and Maybe u don't
15:44:48 <chessguy> @pl f x -> if (p x) then x else (f (g x))
15:44:49 <lambdabot> (line 1, column 5):
15:44:49 <lambdabot> unexpected ">" or "-"
15:44:49 <lambdabot> expecting variable, "(", operator or end of input
15:45:10 <monochrom> you probably forgot some lambdas
15:45:20 <MisterN> @pl \f -> let x = f x in x
15:45:21 <lambdabot> fix
15:45:24 <MisterN> lol
15:45:30 <BMeph> MisterN: So I can tell people, (Maybe u) can "@Hoogle Something". ;)
15:45:51 <noddyB> HALP! my head hurts. i'm reading Hudak's SOE and i feel absolutely weak. not that there is sth i dont' understand, it's just the overwhelming feeling of... idunno, _weakness_? is this normal for a haskell beginner, or should i go and make a career in interior design??
15:46:00 <BMeph> @pl\ f x -> if (p x) then x else (f (g x)
15:46:00 <lambdabot> (line 1, column 5):
15:46:00 <lambdabot> unexpected ">" or "-"
15:46:00 <lambdabot> expecting variable, "(", operator or end of input
15:46:15 <chessguy> @pl f x = if' (p x) x (g (f x))
15:46:15 <lambdabot> f = fix (ap (if' =<< p) . (g .))
15:46:18 <mauke> use more lambdas
15:46:20 <mrd> noddyB: it's ok, you're learning
15:46:24 <BMeph> @pl \ f x -> if (p x) then x else (f (g x)
15:46:24 <lambdabot> (line 1, column 39):
15:46:24 <lambdabot> unexpected end of input
15:46:24 <lambdabot> expecting variable, "(", operator or ")"
15:46:35 <mrd> noddyB: no pain no gain
15:46:43 <chessguy> noddyB:  that's very typical
15:46:44 <mauke> no brain no pain
15:46:46 <monochrom> no child left behind
15:47:03 <noddyB> you kids made me smile.
15:47:04 <mrd> no monkey left banana
15:47:12 <monochrom> haha
15:47:30 <lament> no time left arrow?
15:47:39 <mauke> FRP
15:47:52 <mauke> no bus no
15:48:08 <BMeph> noddyB: Haskell is full of strong functors. It's no wonder you feel weak in its presence. ;)
15:48:11 <mrd> fruit flies like a banana
15:48:24 <monochrom> @quote flies
15:48:25 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
15:48:31 <_MaK_> @pl \(x,y) -> (y,x)
15:48:32 <lambdabot> uncurry (flip (,))
15:49:19 <BMeph> OOh, another good one for a T!
15:49:37 * BMeph writes down, "Syntax rulex like a macro!"
15:49:38 <MisterN> i think @pl is actively harmful.
15:50:33 * BMeph then heel-smacks himself, and corrects "rulex" to "rules"
15:50:43 <MisterN> rolex
15:50:51 <mjrosenb> rollex
15:51:27 <BMeph> No, no, Rolex measures time. Rulex masures space! ;p
15:51:38 <mauke> xelor
15:51:46 <mjrosenb> BMeph: but they're the same thing
15:51:56 <mjrosenb> just off by a factor of i or se
15:52:15 <shachaf> @ty (uncurry . flip . curry) id
15:52:17 <lambdabot> forall a b. (b, a) -> (a, b)
15:52:19 <pjdelport> noddyB: that hurting is your brain exercising
15:52:37 <BMeph> mjrosenb: I see. Okay, next time, I'm telling my nosey neighbor to "get your face out of my time!" ;p
15:53:56 <mjrosenb> BMeph: you mean next space, I'm telling.... ?
15:54:11 <MisterN> BMeph: you have to read the last 20 xkcds before that of course.
15:54:18 <MisterN> why? just cause.
15:54:51 <BMeph> mjrosenb: No, YOU mean 'next space, I'm telling...' ;)
15:55:35 <MisterN> so, to continue on my crusade on compelling #haskell people that they're weirder than me:
15:55:36 <monochrom> time after time
15:55:44 <mjrosenb> BMeph: ja
15:55:52 <monochrom> We are compelled.
15:55:56 <MisterN> oh.
15:55:57 <MisterN> well
15:56:02 <MisterN> no need to continue then
15:56:23 <perspectival> is anyone using leijen's pprint library?
15:58:06 <MisterN> monochrom: wait, maybe i used to wrong word? maybe "compelling" is not what i meant?
15:58:34 <edwardk> just checking on recent developments. is there any utf8 oriented lexer available for Haskell? (in a perfect world one that works over lazy bytestrings)
15:58:54 <MisterN> monochrom: does "compelling" mean the same thing as "persuading" in this case?
15:59:09 <povman> any ppc users who have successfully compiled ghc 6.8.3
15:59:10 <povman> ?
15:59:46 <monochrom> Yes.
16:00:03 <monochrom> I mean answering to MisterN. I don't have ppc.
16:00:24 <MisterN> monochrom: but i'm pretty weird too
16:00:45 <chessguy> would it be useful to define BinarySearchTree in a library somewhere, maybe a newtype over Tree?
16:00:47 <monochrom> Do you play Go while unicycling?
16:00:59 <MisterN> no, not in the xkcd sense of course.
16:01:04 <chessguy> it seems like it has constraints that could be useful
16:01:29 <MisterN> monochrom: wouldn't that in fact be quite unweird in a way?
16:01:58 <monochrom> Not sure binary search tree is more useful than Data.Set
16:02:23 <chessguy> i wasn't intending to compare it to others
16:02:24 <MisterN> chessguy: Ternary Search Trees are more interesting.
16:02:35 <povman> chessguy: Data.Graph?
16:02:54 <chessguy> MisterN:  are you serious?
16:02:54 <nolrai_> @ty M.insertWith
16:02:56 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
16:03:03 <MisterN> chessguy: of course :)
16:03:19 <chessguy> povman Data.Graph doesn't make the restrictions that a BST would
16:03:31 <monochrom> For every scenerio you want a binary search tree, can you replace it with a more hiding module such as Data.Set or Data.Map?
16:04:43 <MisterN> chessguy: the interesting thing about TSTs is that they are quite good at storing lists of ordered entities without wasting space.
16:04:43 <dieJana> mmm... back with the same issue
16:05:04 <monochrom> Perhaps you do not intend to compare. But I do. In the interest of avoiding redundant work.
16:05:05 <dieJana> can I say that I work with a first order PA^\omega ?
16:05:23 <dieJana> or is that omega already saying something about some higher order
16:05:32 <chessguy> well, i was thinking about implementing splay trees, but i'd either have to generalize the splay function, or write it for a BST. maybe generalizing splay is better
16:05:42 <chessguy> (though more difficult)
16:06:01 <MisterN> @hoogle splay
16:06:01 <lambdabot> No matches found
16:06:04 <monochrom> I see.
16:06:10 <MisterN> there is no splay thing.
16:07:49 <chessguy> @go wikipedia splay tree
16:07:50 <lambdabot> http://en.wikipedia.org/wiki/Splay_tree
16:07:57 <sioraiocht> is there a function to take get a logarithm in an arbitrary base?
16:08:07 <mauke> :t logBase
16:08:08 <lambdabot> forall a. (Floating a) => a -> a -> a
16:08:15 <sioraiocht> cheers
16:08:17 <mjrosenb> oh god, splay trees
16:09:20 <MisterN> chessguy: so what's so bad about ternary search trees?
16:09:35 <chessguy> MisterN:  i don't recall saying there was anything bad about them
16:09:59 <MisterN> chessguy: sounded like it :)
16:11:24 <chessguy> MisterN:  i just hadn't heard of them before, so i didn't know if you were being serious or not
16:12:21 <MisterN> chessguy: oh i just was reminded of them because the name is so similar.
16:12:34 <MisterN> chessguy: i don't know if it fits your problem domain :)
16:12:50 <chessguy> MisterN:  i'm not working in any particular domain
16:12:59 <MisterN> then you can use them of course! :D
16:13:12 <Frederick> I need help on revising a paper on category theory ive written for university I pay with ethernal gratitude
16:13:13 <MisterN> then again, why do anything?
16:13:29 <chessguy> i'm thinking the best bet is to figure out how to generalize splay
16:14:00 <MisterN> chessguy: why? why not make haskell rule the world by creating useful software? :)
16:14:09 <chessguy> eh?
16:14:51 <MisterN> haskell is a programming language
16:15:02 <chessguy> i'm well aware of that, thanks
16:15:05 <MisterN> you can use it to create programs
16:15:37 <MisterN> so if you don't have a domain, why not just create a program? :p
16:16:01 <monochrom> you can also use it to create papers
16:16:20 <chessguy> and then you can use the papers to create paper airplanes
16:16:35 <monochrom> which will rule the world
16:16:43 <MisterN> there are easier ways to create paper airplanes
16:16:58 <MisterN> also, then the paper airplane rules the world and not haskell
16:16:58 <BMeph> At least, the meat-o-sphere side of it. :)
16:17:13 <chessguy> man, this channel is silly tonight
16:17:27 <mauke> stop it! stop this channel right now
16:17:28 <BMeph> ...and one language to (>>=) them.
16:17:32 <mauke> it's getting silly
16:17:51 <monochrom> @quote one monad
16:17:52 <lambdabot> No quotes for this person. Take a stress pill and think things over.
16:18:03 <monochrom> @quote one*monad
16:18:04 <lambdabot> No quotes match. The more you drive -- the dumber you get.
16:18:54 * monochrom doesn't like @quote being obscure to search
16:18:59 <BMeph> @quote monochrom
16:18:59 <lambdabot> monochrom says: That does not explain why people struggle with Haskell, a language that is a clean break from other computer languages. However, I can also offer a way out: people preconceive
16:18:59 <lambdabot> Haskell to be "just another computer language", and so they are tricked. If you sold it as "the mother tongue of Martians", perhaps they'll actually pick it up comfortably. :)
16:19:44 <MisterN> as long as haskell is crowded by researchers
16:19:49 <MisterN> how could it ever become popular
16:20:20 <dons> today i wanted to write a program to scale an image, and possibly convert it.
16:20:22 <dons> in haskell.
16:20:28 <dons> this is the body,
16:20:30 <dons>     image  <- load f
16:20:30 <dons>     image' <- resizeImage x y image
16:20:30 <dons>     save g image'
16:20:43 <bd_> resizeImage should be pure :(
16:20:52 <dons> there's about 10 lines around that for arg handling
16:21:06 <dons> it is nice when libraries just work.
16:21:11 <chessguy> ever heard of a pastebn?
16:21:28 * dons slaps chessguy 
16:21:32 <dons> bd_: yeah.
16:21:37 <dons> it could be
16:21:43 <dons> would have to check what gd does
16:21:50 <chessguy> oh, dons is above the tools that the rest of us mere mortals are considerate enough to use
16:21:58 <dancor> deigns
16:21:59 * dons slaps chessguy 
16:22:06 <dons> chessguy: i co-wrote hpaste.org, if that helps
16:22:16 <Maciej> > join (,) 1
16:22:17 <lambdabot>  (1,1)
16:22:23 <dons> the standard rule is 5 lines of code, btw.
16:22:35 <dancor> this is haskell, there are no standards
16:22:42 <dancor> @yow
16:22:42 <lambdabot> Couldn't find fortune file
16:22:44 <monochrom> Using a pastebin would destroy the effect the author wants to achieve. The point is clearly not about detailing the code.
16:22:46 <Maciej> Huh, this doesn't work in GHCi
16:23:10 <dons> it is the fact that you can write an image scaling and translation program in 3 lines, without thinking, by gluing hackage components together
16:23:20 <dons> 07.02.19:21:46:46 <chessguy> thanks for flooding in the middle of an interesting conversation, dons
16:23:44 <Maciej> Where is the Monad (-> a) instance located?
16:23:50 <monochrom> There was no interesting conversation at that time.
16:23:56 <MisterN> dons: and what's special about that?
16:23:57 <chessguy> @undo do image <- l f; i' <- r x y i; s g i'
16:23:57 <lambdabot> l f >>= \ image -> r x y i >>= \ i' -> s g i'
16:24:13 <dons> MisterN: nothing. it is perfectly normal. just how a general purpose language should be.
16:24:23 <Botje> yay
16:24:24 <mauke> dons: which module is that?
16:24:28 <dons> you can even get the program now in your distro of choice.
16:24:34 <dons> http://aur.archlinux.org/packages.php?ID=17910
16:24:34 <lambdabot> Title: AUR (en) - scaleimage
16:24:36 <MisterN> dons: it might not be so much the language. rather, the atmosphere.
16:24:36 <dons> for example
16:24:36 <Botje> tomorrow I get to attempt a type system for my compiler in one hour
16:24:38 <chessguy> @undo do i <- l f; i' <- r x y i; s g i'
16:24:38 <lambdabot> l f >>= \ i -> r x y i >>= \ i' -> s g i'
16:24:49 <Botje> but now, time for ambienttalk :[
16:24:50 <dons> mauke: 'gd'
16:24:52 <EvilTerran> Maciej, in Control.Monad.Instances
16:24:53 <mauke> heh
16:25:01 <dons> mauke: its bjorn's gd bindings
16:25:01 <MisterN> dons: haskell is not surrounded in an atmosphere of "ordinary problem solving"
16:25:08 <dons> MisterN: i beg to differ.
16:25:09 <mauke> I'm using the perl version :-)
16:25:25 <dons> MisterN: go look at hackage.haskell.org
16:25:28 <chessguy> load f >>= resizeImage x y >>= save g
16:25:42 <dons> 600 libraries, for every kind of problem solving you could want.
16:25:47 <roconnor> how do I write let statements inside do blocks with { ; } notation?
16:25:49 <Maciej> EvilTerran: Oh fine, now it works.
16:25:58 <MisterN> dons: if i want to solve a problem, i don't quite want to learn that Arrows are a category-theoretical whatever
16:25:58 <mauke> roconnor: let {x = y};
16:26:09 <dons> MisterN: what do arrows have to do with things?
16:26:13 <Botje> MisterN: you don't have to
16:26:20 <Botje> MisterN: just randomly perturbate the code until it typechecks
16:26:22 <roconnor> mauke: thaks
16:26:29 <roconnor> mauke++
16:26:30 <MisterN> Botje: the atmosphere makes me think i have to, however
16:26:30 <Botje> no category theory required, just evolution theory :)
16:26:34 <MisterN> it is intimidating
16:26:35 <dons> MisterN: this is an old chestnut, that you need theory to do practical things.
16:26:37 <dons> it is false.
16:26:43 <MisterN> dons: indeed
16:26:47 <mauke> MisterN: just don't think
16:26:49 <MisterN> however, if you go to #haskell
16:26:59 <MisterN> and have people talking about all this fancy theoretical stuff
16:27:08 <dons> haskell programming is basically using the type system to glue together libraries
16:27:16 <MisterN> then you might think "i'll just use perl, it isn't that fancy, but it does work for me"
16:27:27 <dons> MisterN: we encourage a culture of thinking about programming and abstraction
16:27:36 <mauke> http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
16:27:37 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
16:27:39 <MisterN> and overly emphasizing elegance
16:27:41 <MisterN> @pl!
16:27:41 <lambdabot> (line 1, column 1):
16:27:42 <lambdabot> unexpected end of input
16:27:42 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:27:42 <dons> this is different to most programming language communities. some of which are openly hostile to thinking about programming
16:27:54 <mauke> MisterN: @pl isn't about elegance
16:28:00 <MisterN> mauke: what else?
16:28:06 <mauke> silliness
16:28:10 <dons> the fact people like to understand, at a deep level, programming, doesn't mean that we're not obsessed with solving things.
16:28:14 <MisterN> mauke: so you oppose @pl?
16:28:18 <dons> the whole point of the haskell project is to make programming not suck.
16:28:21 <mauke> no, I think it's cool
16:28:30 <lament> dons: good luck with that!
16:28:31 <Vq^> the name may be silly...
16:28:32 <MisterN> mauke: so it doesn't create sillinuess
16:28:34 <mauke> I also enjoy perl golf
16:28:38 <MisterN> mauke: what does it create?
16:28:41 <Vq^> and the results sometimes maybe...
16:28:49 <dons> anyway, if you find when writing your next program that you are forced to learn category theory, i'd love to know what you're actually trying to solve
16:29:24 <dons> MisterN: seriously, rather than complain about cultural stereotypes, writing a couple of fun programs would be much more instructive.
16:29:29 <MisterN> dons: if i find myself writing a program, i probably won't find myself using haskell. using haskell is a deliberate choice.
16:29:49 <dons> go to hackage.haskell.org. look at what libraries there are. find one you like. write a command line interface or gui to some of it.
16:30:25 <MisterN> i think complaining can be full of insight, too
16:30:26 <MyCatVerbs> MisterN: @pl is, often as not, for when you're thinking there's probably a nice way to express what you've just written in combinators, but couldn't say just what it is.
16:30:29 * dons encourages "the 100 haskell programs in 100 days" program
16:30:39 <MisterN> MyCatVerbs: elegance, then.
16:30:50 <dons> participants write 100 programs, one per day, using a new hackage library each day
16:30:57 <geezusfreeek> MisterN: sometimes it comes out elegantly, sometimes not
16:31:04 <MyCatVerbs> MisterN: patern-lifting, more like.
16:31:12 <dcoutts> dons: we've got well more than that as the rate of hackage uploads.
16:31:16 <dons> by the end they're master of haskell databases, graphics, audio, network, system and web libraries
16:31:28 <EvilTerran> MyCatVerbs, MisterN: i see it not so much as a cue for lambdabot to make your code more elegant, but for #haskell to step in when lambdabot screws up ;)
16:31:29 <dcoutts> ah, as a tutorial
16:31:38 <dons> dcoutts: just a general fitness regime
16:31:45 <dcoutts> heh
16:31:46 <Vq^> MisterN: by the way of arrows, i have used a couple of arrow-based libraries without understanding the theory behind them
16:31:47 <chessguy> dons:  where do they find the ideas for 100 programs?
16:32:13 <MyCatVerbs> *pattern
16:32:14 <MisterN> Vq^: well i think i have roughly understood the concept. i might be wrong.
16:32:17 <dons> each day presents a problem. if no problems present themselves, the goal is to interface one library that does IO with logic from another
16:32:37 <dons> i can share a limited supply of creativity if needed
16:32:52 <dons> but hackage is basically a program ideas generator now
16:33:02 <dons> find two libraries, glue them together. add getArgs around it.
16:33:10 <mauke> splitCreativity
16:33:18 <MisterN> dons: then hackage is no different from CPAN
16:33:26 <MisterN> what's the point of that?
16:33:28 <MyCatVerbs> MisterN: yes!
16:33:29 <dons> that's right. it is like CPAN for the 21st century.
16:33:30 <mjrosenb> dancor: i remember a scifi story about something like that
16:33:32 <mjrosenb> err
16:33:38 <dons> strongly typed, pure components, parallelisable and modular
16:33:43 <dons> for building modern software
16:33:45 <mjrosenb> dons: i remeber a scifi story about  that.
16:33:51 <dons> easily distributable
16:34:05 <mjrosenb> dons: it ended with the earth in ruins
16:34:10 <dons> MisterN: it is remarkable how normal and everyday the haskell programming experience can be.
16:34:29 <Vq^> mjrosenb: oh noes, bad things have happen in fictional places :-o
16:34:31 <dons> you just happen to be not hitting the kind of road blocks legacy languages face building modular, reliable, expressive sytsems
16:34:38 <MyCatVerbs> MisterN: and CPAN is very good! Which is why hackage emulates it.
16:34:48 <MisterN> dons: however, it seems like not "enough" people use haskell. and it's astonishing how many people openly opppose haskell.
16:35:02 <MisterN> i wonder if that's justified
16:35:03 <dons> i don't have numbers for that
16:35:13 <dons> i'll note that #haskell is twice the size of #ruby-lang
16:35:16 <mjrosenb> MyCatVerbs: you mean CTAN
16:35:17 <Botje> MisterN: people oppose any revolution :)
16:35:25 * glguy has seen more blind support than blind opposition to Haskell
16:35:27 <dons> it does create job insecurity.
16:35:42 <Vq^> question is how many that oppose Haskell have really learned Haskell :/
16:35:44 <dons> if people feel they need to learn something new to compete, they'll generally oppose that
16:35:45 <MisterN> Botje: revolutions are usually quite violent
16:35:49 * mjrosenb has seen alot of blind opposition to haskell
16:36:03 <MyCatVerbs> mjrosenb: I don't, unless I'm mistaken. I may be mistaken, so please elaborate on how? :)
16:36:08 <chessguy> wow, nobody has hackage'd the Edison library
16:36:10 <dons> the best we can do is calmly, patiently overwhelm with quality and numbers
16:36:11 <MisterN> Vq^: so maybe the environment is not that good at encouraging people to learn haskell?
16:36:16 <mjrosenb> Vq^: that wouldn't be blind opposition
16:36:17 <dons> chessguy: yes, it has been
16:36:18 <solrize> http://lisperati.com/landoflisp/  :-)
16:36:19 <chessguy> err, never mind
16:36:22 <chessguy> sorr, i missed it
16:36:22 <dons> edisoncore and edisonapi
16:36:33 * Botje has convinced a die hard C++ professor to look at haskell a second time
16:36:34 <dons> now, what are all you slackers doing!? where are the new apps on hackage?
16:36:48 <mjrosenb> MyCatVerbs: CPAN was modelled after CTAN, the comprehensive tex archive network
16:36:55 * dcoutts adds features to Cabal and cabal-install...
16:36:59 <Vq^> i think people don't like that it isn't just C with a fancy new feature for some new specific virtual machine
16:37:00 <dons> go dcoutts !
16:37:06 <chessguy> dons:  we should track a list of new app ideas somewhere
16:37:09 <solrize> http://lisperati.com/landoflisp/panel57.html
16:37:12 <MisterN> Vq^: well, some people, maybe
16:37:15 <dons> chessguy: the wiki would be good for that.
16:37:18 <MyCatVerbs> mjrosenb: huh. I did not even know of CTAN's existence.
16:37:36 <roconnor> Steve Yegge said, "Instead, they introduced generics, right, which is this huge, massive, category-theoretic type system that they brought in, where you have to under[stand] – to actually use it you have to know the difference between covariant and contravariant return [and argument] types, and you have to understand why every single mathematical... [I tail off in strangled frustration...]"
16:37:37 <MisterN> <noddyB> HALP! my head hurts. i'm reading Hudak's SOE and i feel absolutely weak. not that there is sth i dont' understand, it's just the overwhelming feeling of... idunno, _weakness_? is this normal for a haskell beginner, or should i go and make a career in interior design??
16:37:37 <MisterN> <BMeph> noddyB: Haskell is full of strong functors. It's no wonder you feel weak in its presence. ;)
16:37:37 <joey_> It's my experience from university, that those who struggle grasping Haskell are those who are the most firmly opposed
16:37:44 <mjrosenb> MyCatVerbs: it's sad how so few people do
16:37:47 <roconnor> which I find a very scary statement to make about programming
16:37:48 <dons> joey_: quite so.
16:37:48 <MisterN> feeling weak when you try to learn haskell...
16:37:54 <MisterN> isn't that a weakness of haskell?
16:37:55 <dcoutts> just added byorgey's package logging because it was easy, byorgey can add the extras he wanted.
16:38:07 <MisterN> shouldn't a language make you feel strong?
16:38:21 <chessguy> MisterN:  only if you are :)
16:38:22 <bos> roconnor: forall ThingsThatSteveYeggeSays x, x is not true.
16:38:32 <solrize> i can think of problems with haskell but yegge's posts seem pretty bogus
16:38:33 <dolio> Heh.
16:38:41 <dons> roconnor: our industry is remakably conservative when it comes to new techniques.
16:38:42 <dcoutts> MisterN: if it's that easy to learn then it's not really changing the way you think and have you really got anywhere?
16:38:45 <MisterN> chessguy: people are productive in other languages, yet might feel overwhelmed by haskell
16:38:52 <MisterN> you think these people are weak?
16:39:04 <mauke> MisterN: yes
16:39:05 <bos> dons: in chapter 12, did you write about forAll and (==>)?
16:39:05 <dcoutts> no, all the imperative languages are the same
16:39:08 <Vq^> MisterN: most people learning Haskell knows some other paradigms before that
16:39:10 <geezusfreeek> Haskell introduces people to a whole new world of programming far beyond anything they knew existed. It can be mind-blowing, and can make them feel unexpected small.
16:39:11 <loop> how can you be opposed of something that you don't understand
16:39:19 <geezusfreeek> *unexpectedly
16:39:23 <dons> bos, implication yes, no forAll, though i think there's some comments about it.
16:39:23 <mauke> loop: trivially
16:39:24 <dcoutts> loop: fear of the unknown
16:39:27 <MisterN> erlang people can't be accused of thinking too imperatively, can they?
16:39:30 <dolio> Is he talking about Java?
16:39:30 <Vq^> MisterN: so it's hard to say that it has to be a weakness in Haskell
16:39:33 <MisterN> i mean, erlang is almost pure.
16:39:40 <mauke> MisterN: I can accuse them!
16:39:42 <bos> dons: ok, cool. i use both in ch27.
16:39:48 <dcoutts> MisterN: erlang people would have no problem learning haskell
16:39:53 <solrize> erlang seems pretty crude
16:39:54 <dons> bos, ok, i'll clarify the bits on forAll
16:40:00 <solrize> forAll ?
16:40:05 <solrize> as opposed to forall ?
16:40:09 <dons> MisterN: anyway, how's your haskell hacking coming along?
16:40:10 <MisterN> dcoutts: well, that's not true. people in #erlang do complain about haskell from time to time.
16:40:11 <bos> solrize: quickcheck
16:40:12 <dons> built cabal-install yet?
16:40:14 <solrize> oh
16:40:27 <bos> boy, chatty afternoon round here.
16:40:36 <dcoutts> MisterN: ok, the type system is different, but they're much closer than most imperative programmers
16:40:38 <mrd> solrize: no type system!
16:40:41 <Vq^> MisterN: even people in #Haskell complain about Haskell from time to time :)
16:40:42 <MisterN> dons: do i have to be an insider to ask critical questions?
16:40:43 <geezusfreeek> i think erlang is probably not any more pure than most lisps
16:40:58 <MisterN> dons: i'm no haskell hacker, no. but i'm interested in the culture and language of haskell.
16:41:00 <geezusfreeek> well, perhaps _slightly_
16:41:03 <solrize> erlang has effectful functions for i/o
16:41:05 <dons> MisterN: no, i just wonder what this achieves? :)
16:41:18 <MisterN> dons: insight. at least i hope for it.
16:41:29 <dobblego> Yegge is the anti-thesis of learning and thinking; I'd call that "weakness"
16:41:42 <roconnor> anyone is allowd to complain about the global nature of type classes.
16:41:58 <MyCatVerbs> dons: incidentally, do you have any nice documentation for uvector, please? Your blog post is a nice start, but I'm wondering if there's anything more in-depth aside from the haddock pages and sources?
16:42:06 <Vq^> MisterN: it's probably just the oldest "truth" in the book, different=bad
16:42:09 <dons> MyCatVerbs: haddock fails on type famililes :(
16:42:23 <dons> MyCatVerbs: i've not written docs yet, as a result
16:42:28 <chessguy> dons:  think i should just create a page for app/library ideas and shoot an email to -cafe?
16:42:36 <MisterN> Vq^: see, i find myself interested in haskell, yet i use perl and c++. how can that be?
16:42:45 <dons> chessguy: there's such a page on the wiki already, so you could add to it.
16:42:51 <chessguy> really?
16:42:51 <dons> MisterN: lack of practice, i suspect
16:42:56 <dolio> MyCatVerbs: You shouldn't have much trouble figuring out what functions do by looking at the export list of Data.Array.Vector.
16:42:59 <Vq^> MisterN: i use mostly Haskell, but i use C, python and assembler as well
16:43:15 <chessguy> dons:  got a link?
16:43:19 <MyCatVerbs> dons: ahhhh. Incidentally, haddock refused to write any docs out, but I'd assumed I was doing summat wrong and had to figure out what. ;)
16:43:23 <dons> you have to reach a critical threshold of knowledge, get over the learning hump, and into the "just do it" plateau
16:43:38 <solrize> do { h <- openFile "foo"; x <- readFile h; y <- readFile h; return $ munch x y }      -- criticism of haskell ;-)
16:43:47 <MisterN> dons: that might be it.
16:43:52 <Vq^> MisterN: mostly when programming you want to code at a high level of abstractions
16:43:53 <dolio> MyCatVerbs: Just remove the U from the end and look at Data.List or something. :)
16:43:57 <MisterN> dons: the plateau might be kinda too high for most people.
16:44:02 <joey_> I think that threshold is higher for Haskell than, say, Java. But more than worth it once you get there
16:44:04 <Vq^> MisterN: and Haskell is the highest-level language i know
16:44:08 <geezusfreeek> solrize: huh?
16:44:18 <dcoutts> bos: btw, did you have any suggestion about http://hackage.haskell.org/trac/hackage/ticket/200
16:44:20 <lambdabot> Title: #200 (Allow more convenient use of ghc profiling options -auto and -auto-all) -  ...
16:44:21 <dons> MisterN: well, we teach haskell to beginner programmers, so i can't imagine it is too high
16:44:43 <dons> if you've a lot of resisntance or patterns to unlearn, that might make the hill higher
16:44:46 <dolio> Cale was teaching it to grade schoolers once.
16:44:53 <dcoutts> MisterN: I teach haskell to first year undergrads as their first language.
16:45:01 <dons> depends on your background.
16:45:06 <solrize> geezusfreeek lazy i/o can trip over its own feet :)
16:45:11 <MisterN> dcoutts: have you compared your success to other language teachers?
16:45:23 <Vq^> Haskell is a quite easy language to learn when looking at things the programer has to keep track on
16:45:24 <joey_> I think its more a case of people who can't really program find it easier to fumble their way through with imperative languages :P
16:45:28 <geezusfreeek> solrize: but lazy IO is not good haskell anyway
16:45:30 <Vq^> like memory allocations
16:45:35 <Vq^> and mutations of state
16:45:38 <MyCatVerbs> dolio: differing strictnesses, though. I can't make an infinite (or even bigger-than-memory) uvector (can I?).
16:45:42 <Cale> Haskell is probably easier than C++ to learn from a point of not knowing anything about programming.
16:45:44 <roconnor> joey_: sounds right to me :)
16:45:48 <bos> dcoutts: i'm fine with one knob to control -auto-all or not.
16:45:49 <solrize> geezusfreek it's ont clear what to do instead?
16:46:02 <dcoutts> MisterN: it's pretty hard to do objectively since all students on the course do the same. But the faculty is certainly happy with the situation.
16:46:16 <dolio> MyCatVerbs: That's correct, I guess. Although I'm not entirely sure, since the current API is essentially sugar for stream fusion, instead of actual arrays.
16:46:17 <Vq^> Cale: but then C++ is ridiculusly hard
16:46:17 <bos> dcoutts: nobody ever, ever uses -auto or -caf-all
16:46:29 <MisterN> Vq^: yeah but it's quite practical too
16:46:35 <MyCatVerbs> dolio: it's the loss of laziness in some places that gives me most gyp, I think.
16:46:35 <MisterN> i find myself liking to use it.
16:46:37 <Cale> Vq^: indeed, though lots of people learn it
16:46:41 <dcoutts> bos: so a configure flag to say I want to profile *this* package.
16:46:42 <dolio> MyCatVerbs: The immutable array stuff, at least.
16:46:43 <roconnor> solrize: it should be called "unsafeReadFile" or at the very least "lazyReadFile"
16:46:43 <solrize> haskell has a very steep unlearning curve :)
16:46:56 <dcoutts> bos: leaving the meaning of the existing prof flags as is
16:47:01 <chessguy> dons: ?
16:47:05 <bos> dcoutts:
16:47:08 <bos> dcoutts: er, yes
16:47:12 <dcoutts> 'k
16:47:18 <bd_> @remember solrize haskell has a very steep unlearning curve :)
16:47:18 <lambdabot> I will remember.
16:47:28 <solrize> bd_ i think someone else said that first :)
16:47:32 <MisterN> @quote solrize
16:47:33 <lambdabot> solrize says: haskell has a very steep unlearning curve :)
16:47:33 <bd_> oh :|
16:47:36 <dons> chessguy: it is on the libraries page
16:47:39 <MisterN> @uote unlearning
16:47:39 <lambdabot> Maybe you meant: quote vote
16:47:41 <dons> under 'wanted libraries' i think
16:47:44 <monochrom> We should make haskell harder so more people want to learn it.
16:47:45 <MisterN> @quote unlearning
16:47:45 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
16:47:52 <bd_> ah, oops
16:47:54 <MisterN> dukedave was first, eh?
16:47:56 <bd_> @forget solrize haskell has a very steep unlearning curve :)
16:47:56 <lambdabot> Done.
16:47:57 <dons> if only it was as hard as C++
16:47:58 <solrize> no idea
16:48:03 <dons> ?users
16:48:03 <lambdabot> Maximum users seen in #haskell: 465, currently: 429 (92.3%), active: 31 (7.2%)
16:48:05 <geezusfreeek> solrize: well first of all, why would you ever want to lazily read twice from the same handle?
16:48:08 <bd_> dons: Let's add templates to haskell.
16:48:10 <bd_> :D
16:48:16 <mauke> -fth
16:48:22 <MisterN> yeah templates. great source of arcanity!
16:48:37 <joey_> Someone already tried adding templates, didn't they?
16:48:40 <solrize> geezusfreeek there are all sorts of things i never want to do, and it seems like a shortcoming of the language, that the type system fails to catch the error
16:48:40 <monochrom> Let's add lax natural transformations to haskell
16:48:57 <dcoutts> bos: does it make sense to profile a exe without -auto-all? should that be on by default for exes or just have it orthogonal?
16:48:58 <dolio> mauke: You've got to get with the times. It's -XTemplateHaskell. :)
16:48:59 <MyCatVerbs> dolio: it's, uh, jarring to go from (zip [1..]) working fine to (zipU (toU [1..])) being _|_.
16:49:31 <geezusfreeek> solrize: lazy IO is usually a sign of design error anyway
16:49:31 <Vq^> lets introduce Java-style NULL
16:49:40 <bos> dcoutts: i always turn on -auto-all for exes, but maybe i lack imagination?
16:49:41 <MisterN> Vq^: umm null
16:49:42 <solrize> solrize the problem came up because i wanted to crunch some arrays that live in different parts of a file and realized i'd have to carefully keep track of all the filehandles i was using
16:49:44 <MisterN> Vq^: NULL is C
16:49:51 <Vq^> MisterN: oh, right
16:49:55 <chessguy> dons:  hmm. the missing libraries there seme quite non-trivial
16:50:04 <solrize> geezusfreek lazy i/o is usually advertised as a good thing :)
16:50:05 <Vq^> MisterN: i don't write much java :/
16:50:22 <MisterN> Vq^: did you know that in c++, the type of NULL is int, once you ask for it? :)
16:50:30 <geezusfreeek> solrize: i have never seen lazy IO encouraged by a haskell guru
16:50:32 <mmorrow> love make -j10 when building ghc
16:50:38 <Vq^> MisterN: no, i didn't
16:50:43 <mauke> C++ NULL is just 0
16:50:45 <MisterN> Vq^: whereas in c it's usually void*
16:50:56 <Vq^> MisterN: did you know that Haskells Nothing is polymorphic? ;)
16:51:05 <MyCatVerbs> mmorrow: bastard. Where'd you get so many CPUs?
16:51:13 <MisterN> Vq^: well no but why not
16:51:14 <geezusfreeek> solrize: sounds to me like your problem would best be handled by an appropriate monad or arrow
16:51:19 <solrize> geezusfreeek um, all the examples i've seen use lazy i/o?  maybe i'm not looking at the right places
16:51:32 <mmorrow> MyCatVerbs: only have two, just like goingoverboard/beingexcessive
16:51:36 <geezusfreeek> solrize: lazy io is often used for simple examples, and i think it shouldn't
16:51:40 <joey_> > (Nothing :: Maybe Char, Nothing :: Maybe Int) -- !
16:51:41 <lambdabot>  (Nothing,Nothing)
16:51:46 <Vq^> MisterN: i guess it's what one would expect
16:51:52 <MyCatVerbs> mmorrow: ah, fair 'nuff.
16:51:54 <solrize> geezusfreeek so i should use pseudo-imperative monadic i/o ?
16:52:09 <chessguy> > [Nothing :: Maybe Char, Nothing :: Maybe Int]
16:52:09 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
16:52:20 <solrize> i mean the IO monad is designed from the ground up to implement lazy io
16:52:28 <mauke> solrize: whoa, what?
16:52:31 <MisterN> Vq^: *shrug*
16:52:35 <MyCatVerbs> solrize: ! No it isn't.
16:52:41 <geezusfreeek> solrize: sounds like you have a misunderstanding of things
16:52:48 <MisterN> why do non-lazy I/O?
16:52:56 <mauke> MisterN: because it's I/O
16:52:57 <MyCatVerbs> solrize: unsafeInterleaveIO is, y'know, unsafe.
16:52:58 <MisterN> when the whole language is meant to be lazy
16:53:07 <Vq^> MisterN: garantees of sequenced actions
16:53:08 <mauke> MisterN: I/O is not part of the language
16:53:11 <MisterN> mauke: getContents is lazy for a reason, right?
16:53:17 <mauke> MisterN: a bad reason
16:53:21 <geezusfreeek> MisterN: the way haskell works is by lazily generating an imperative program at runtime
16:53:26 <MyCatVerbs> MisterN: for convenience' sake.
16:53:27 <Vq^> MisterN: like reading a file and then deleting it
16:53:36 <Vq^> MisterN: should the reading fail then?
16:53:47 <solrize> the idea of lazy i/o is to separate concerns of reading and computing, i mean how should one really write "wc" ?
16:54:00 <mauke> solrize: interact :-)
16:54:14 <MisterN> Vq^: well maybe the deleting should send all the contents into some buffer or something? :D
16:54:18 <MyCatVerbs> MisterN: you don't want to use lazy IO outside of tiny scripts, usually where you can count the fds in play on one hand.
16:54:38 <MisterN> MyCatVerbs: so haskell I/O is inherently broken or what=
16:54:43 <Vq^> MisterN: that would be nice :)
16:54:49 <geezusfreeek> solrize: if memory is of no concern, read the whole thing in at once. if it is, do what you would do in C: do some buffering
16:54:51 <bd_> MisterN: No, lazy I/O is inherently broken :)
16:54:58 <MyCatVerbs> MisterN: no, so lazy IO is intrinsically unsafe.
16:55:04 <dons> it is useful in many situations
16:55:06 <MisterN> haskell does have strict I/O?
16:55:08 <bd_> MisterN: Since it's hard to control when an error condition will occur
16:55:10 <bd_> MisterN: sure.
16:55:10 <dons> yes.
16:55:10 <MisterN> or how to enforce it?
16:55:11 <mauke> MisterN: of course
16:55:15 <Vq^> MisterN: absolutely
16:55:17 <dons> haskell is a mixed strict and lazy language.
16:55:24 <MyCatVerbs> MisterN: this is why people are told to use strict IO, and do lazy computation.
16:55:26 <dons> that happens to default to lazy
16:55:29 <bd_> MisterN: basically anything that doesn't claim to give you the whole file in one chunk is strict
16:55:35 <mauke> this is simply a library issue
16:55:36 <solrize> geezusfreeek in real computing, memory is a concern :)  and buffering means having to juggle stuff around word boundaries etc
16:55:41 <dons> and happens to have very cheap laziness in comparison to most languages
16:55:47 <geezusfreeek> lazy IO seems to come up a lot. there are uses for both lazy and strict IO, but lazy IO should be avoided without really really good reason to use it
16:55:48 <MisterN> bd_: readline or so can happen to be lazy too, no?
16:56:00 <nolrai_> @ty M.insertWith
16:56:02 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
16:56:02 <dons> we use a lot more mixed strict/lazy structures than you'll find elsewhere, as a resutll
16:56:05 <bd_> MisterN: I don't believe sol.
16:56:07 <bd_> so*
16:56:08 <MyCatVerbs> MisterN: nope.
16:56:09 <MisterN> geezusfreeek: such as dealing with infinite streams of data
16:56:14 <geezusfreeek> solrize: monads and arrows are pretty good at abstracting all that juggling
16:56:25 <bd_> MisterN: if you want to be really sure, use strict bytestrings.
16:56:26 <dons> there are even 'eager' libraries for IO.
16:56:33 <MisterN> but shouldn't lazy I/O be an optional abstraction on top of strict I/O then?
16:56:37 <geezusfreeek> MisterN: you will never have an infinite stream of data from IO (except for hacks like /dev/random and stuff)
16:56:37 <dons> so you can do fully strict or fully lazy io, or a mixture.
16:56:47 <MisterN> geezusfreeek: not true
16:56:50 <dons> MisterN: why not make strictness an optional abstraciton on top of laziness?
16:56:54 <roconnor> geezusfreeek: huh?
16:57:03 <MisterN> geezusfreeek: consider an external device which sends me data all the time
16:57:09 <roconnor> geezusfreeek: the "and stuff" category is quite broad
16:57:09 <geezusfreeek> eventually the computer will be turned off
16:57:20 <MisterN> dons: because laziness is broken they say (talking I/O)
16:57:25 <geezusfreeek> i broke the abstraction by saying that, sorry
16:57:27 <monochrom> why are there bogus rule-of-thumbs such as "lazy I/O is bad" or "lazy I/O is good"?
16:57:28 <bd_> MisterN: what happens if it turns off
16:57:29 <geezusfreeek> i take it back
16:57:39 <MyCatVerbs> geezusfreeek: eventually the user will die. Such things are not our domain.
16:57:39 <monochrom> rule-of-thumbs = rule-of-dumbs
16:57:41 <roconnor> geezusfreeek: apology accepted :)
16:57:54 <MisterN> monochrom: because people like defaults
16:58:09 <MisterN> monochrom: defaults just happen to be practical and making your thinking faster
16:58:25 <roconnor> monochrom: lazy I/O is bad because if IO had semantics, lazy IO would break them.
16:58:45 <dons> it is no more broken than using strict IO to read a terabyte file is broken.
16:58:58 <MisterN> so "Don't use lazy I/O without good reasons" is pretty much a good shortcut to always deciding whether to use lazy or strict I/O - if it is true
16:59:03 <EvilTerran> IMO, "lazy IO as an abstraction atop strict IO" would be better. the other way round is slightly weird, seeing as computers are inherently strict
16:59:06 <roconnor> dons: how is susing strict IO to read a terabye file broken?
16:59:08 <dons> strict, eager and lazy IO all have their uses. some languages support more or less of these variants.
16:59:08 <roconnor> using
16:59:15 <MyCatVerbs> roconnor: oh man, imagine how long it would take to write denotional semantics for all of POSIX...
16:59:37 <roconnor> MyCatVerbs: Not so long, why?
16:59:47 <EvilTerran> so "strict IO atop lazy IO" would really be "strict IO atop lazy IO atop strict IO"
17:00:09 <bd_> dons: Is implementing the terabyte file read by creating a mmap-backed strict bytestring considered strict still?
17:00:15 <monochrom> I don't buy "it breaks the semantics".
17:00:22 <dons> bd_: hehe, then you're using the lazy IO in the kernel
17:00:26 <MisterN> EvilTerran: well, the default thing of haskell is "strict on top of lazy" right? eventually a programm will terminate and then it's all become strict
17:00:35 <MyCatVerbs> roconnor: quite a while I'd think. POSIX is physically an enormous quantity of text already.
17:00:37 <solrize> lazy IO doesn't abstract strict IO though, it actually uses unsafeInterleaveIO under the clothes....  i found the lazy io concept confusing in some vague nameless way, until someone here said what it was really doing, and then i really cringed
17:00:42 <monochrom> I mean, yes, it breaks one semantics, but it establishes another one, a more realistic one.
17:01:05 <roconnor> monochrom: sure it does.  x <- readFile "foo"; writeFile "foo" "" -- broken
17:01:06 <EvilTerran> MisterN, the default thing of the IO monad is strictness, though
17:01:09 <bd_> dons: Unless it's on a tmpfs mount, and the kernel maps it in right away:)
17:01:16 <roconnor> MyCatVerbs: so.
17:01:24 <MisterN> EvilTerran: not for getContents
17:01:36 <EvilTerran> MisterN, because the IO monad is where haskell interfaces with the (strict) computer
17:01:50 <EvilTerran> MisterN, ah, but that's the very thing we're arguing about the merits of being lazy. no circular logic!
17:02:07 <roconnor> MyCatVerbs: some people had these semantics in mind when they wrote POSIX.  Not so hard to write down those ideas.
17:02:36 <EvilTerran> let's put it this way: it's easier, i'd argue, to write clean semantics and a clean implementation for strict, eg, getContents.
17:02:54 <roconnor> monochrom: please write up these other semantics, because I have no idea what they are.
17:03:03 <MyCatVerbs> roconnor: so the model would need to include most of sections two and three of your manpages? The _names_ alone would take a long time to copy out freehand.
17:03:07 <MisterN> EvilTerran: getContents should not be strict, ever
17:03:07 <EvilTerran> so i'd say it'd make more sense for that to be in the spec. it'd give a cleaner end result.
17:03:11 <MisterN> that would be plain stupid
17:03:25 <EvilTerran> ok, hGetContents. readFile.
17:03:38 <MisterN> what's the difference?
17:03:49 <roconnor> MyCatVerbs: If man can walk on the Moon, we can write semantics for POSIX.
17:03:52 <MisterN> reading a gigabyte of input into a haskell list is always stupid.
17:04:05 <MisterN> and you have _no way_ of ensuring that it won't be a gigabyte
17:04:13 <MyCatVerbs> getContents = hGetContents stdin
17:04:20 <pjdelport> roconnor: all the software they used to get to the moon probably fit into the POSIX index
17:04:22 <EvilTerran> breaking the semantics of a language that was designed with clean semantics as a primary goal is also stupid
17:04:40 <mmorrow> @quote MisterN revolutions are usually quite violent
17:04:40 <lambdabot> No quotes for this person. Do you think like you type?
17:04:48 <MyCatVerbs> MisterN: if ~/.bashrc is a gigabyte, the user has other problems.
17:04:48 <mmorrow> @remember MisterN revolutions are usually quite violent
17:04:49 <lambdabot> Done.
17:04:53 <EvilTerran> i guess the semantics get pretty stinky around IO anyway, but there's no read to make them worse
17:04:57 <MisterN> mmorrow: heh
17:05:03 <EvilTerran> *need
17:05:08 <mmorrow> MisterN: indeed
17:05:09 <roconnor> is IO even a monad?
17:05:11 <solrize> does anyone know if it's any better with uniqueness types like clean uses?
17:05:14 <EvilTerran> .oO(what a weird typo)
17:05:23 <MisterN> EvilTerran: well maybe just don't have hGetContents at all?
17:05:28 <MisterN> that would be cleaner of course
17:05:28 <EvilTerran> that would work
17:05:32 <MyCatVerbs> roconnor: yyyes...
17:05:34 <EvilTerran> but it's a useful function to have
17:05:36 <solrize> IO is a state monad on an abstract type called RealWorld according to the standard indoctrination ;)
17:05:39 <monochrom> No, uniqueness type doesn't change this aspect.
17:05:46 <EvilTerran> i know, let's have hGetContents and hGetContents' :D
17:05:47 <roconnor> MyCatVerbs: prove that the monad laws hold. :P
17:05:52 <MyCatVerbs> roconnor: m >>= return . id === m, etc.
17:05:52 <MisterN> EvilTerran: LOL
17:05:54 <solrize> monochrom hmm thanks
17:06:01 * dons wonders if MisterN is getting anything out of this flood of text.
17:06:03 <EvilTerran> MisterN, what?! that seems like a perfectly good idea to me
17:06:16 <roconnor> MyCatVerbs: what does === mean?
17:06:27 <joey_> I've got something out of this flood of text
17:06:32 <MisterN> dons: i've been reading longer texts about political subjects today. right now, it is easy :)
17:06:43 <EvilTerran> best of both worlds. clean theoretical behaviour if you want it, clean practical behaviour if you want it
17:06:47 <joey_> I really can't read this much white text in a transparent terminal
17:06:55 <Pseudonym> Feed some through a Markov chain generator and see what happens.
17:06:58 <MisterN> EvilTerran: yeah and having to remember "what's the right version again?"
17:07:08 <EvilTerran> MisterN, same as always. ' is strict, without it isn't
17:07:10 <pjdelport> has anyone investigated ways of doing more explicit lazy I/O?
17:07:11 <MyCatVerbs> roconnor: pretty much every program I've ever written would fail if they didn't. That's the best I know how to do, aside from maybe quickcheck cases.
17:07:22 <MisterN> EvilTerran: didn't know of that convention
17:07:25 <pjdelport> stream-based or something?
17:07:29 <EvilTerran> that's the convention throughout the libraries
17:07:29 <MyCatVerbs> roconnor: equivalence.
17:07:34 <EvilTerran> MisterN, see foldl' etc
17:07:39 <MisterN> EvilTerran: isn't x' often used for helper functions?
17:07:54 <EvilTerran> yes, but, where it's used within the exposed functions of the stdlibs, it means "strict version"
17:08:12 <MyCatVerbs> roconnor: I presume the original paper proposing the IO monad probably includes a proof too. Maybe.
17:08:13 <EvilTerran> pjdelport, now that seems potentially worthy of study
17:08:32 <MisterN> EvilTerran: so getContents would be the unclean version and getContents' would be clean?
17:08:42 <MisterN> or wait, strict getContents is a bad idea anyways
17:08:46 <MisterN> so no need for that
17:08:47 <mauke> EvilTerran: which function (besides foldl') uses that convention?
17:08:47 <solrize> getContents' would be the one that could run out of memory and crash
17:08:53 <EvilTerran> pjdelport, do send us a link if you ever write a nice paper that solves that problem :D
17:08:58 <MisterN> solrize: indeed
17:09:03 <mauke> also, I do want a strict getContents
17:09:16 <EvilTerran> mauke, well, foldl1', foldr', foldr1' ... :P
17:09:22 <mauke> EvilTerran: meh
17:09:22 <MisterN> mauke: isn't there a strictify operator somewhere in haskell?
17:09:27 <mauke> EvilTerran: there is no foldr'
17:09:35 <mauke> MisterN: seq
17:09:35 <EvilTerran> whups. good point.
17:09:39 <dolio> If you want a strict getContents, use Data.ByteString. Reading into lists sucks anyway. :)
17:09:47 <mauke> dolio: I do
17:10:01 <solrize> getContents' h = let c = getContents h in length c `seq` c    ?
17:10:11 <mauke> hax :(
17:10:22 <solrize> i think what i really want is mmap and that's inherently unsafe
17:10:28 <EvilTerran> solrize, and this brings us full-circle to building strict IO on top of lazy IO :P
17:10:39 <EvilTerran> mauke, ok, it's not throughout the libraries, i mis-remembered. i'm sure i've seen it somewhere other than Data.List.foldl', but it must've been somewhere obscure, 'cos i can't find it now
17:11:23 <EvilTerran> but I figure the use of foldl' is sufficiently well-known for it to be okay to make the (' => strictness) thing a convention
17:11:45 <mauke> I vote lazyContents
17:11:52 <MisterN_> solrize: mmap is also inherently un-functional
17:11:53 <EvilTerran> getLazy
17:11:56 <dolio> There are others. insertWith'...
17:12:35 <dons> MisterN: ? mmap is a lovely example of lazy, pure IO in the kernel
17:12:49 <MisterN_> dons: yeah but it's writeable :)
17:12:53 <dons> even the normal call by name side conditions are listed in the documentation. (not the type :)
17:13:07 <MisterN_> and untyped
17:13:08 <dons> yeah, the C type system isn't powerful enough to express the purity-if-sharing constraint
17:13:26 <MisterN_> just raw memory, or that's the abstraction
17:13:27 <dons> the Haskell wrapper over mmap expresses the side conditions though.
17:13:39 <MisterN_> dons: huh where can i fand that wrapper?
17:13:50 <dons> hackage.haskell.org, where all the other libraries live.
17:13:51 <solrize> dons can i use uvector on an mmap somehow?
17:14:06 <mauke> identicons++
17:14:08 <dons> solrize: you could, there's no ByteString -> UArr a yet though
17:14:15 <MisterN_> @hoogle mmap
17:14:15 <lambdabot> No matches found
17:14:37 <solrize> dons sounds like there might be someday?  that sounds good
17:14:50 <dons> solrize: yeah, i have a draft
17:14:57 <solrize> cool
17:14:58 <dons> bytestring introduction of UArr makes a lot of sense
17:15:12 <dons> since that's our standard raw memory abstraction
17:15:29 <chessguy> hmm, i thought people weren't supposed to upload to hackage packages that they didn't write?
17:15:41 <dons> next time i hear someone complain about lazy IO, I'm going to ask them if they think mmap is useful or not.
17:15:45 <Pseudonym> Someone's uploaded some of my stuff without asking.
17:15:46 <mmorrow> solrize: you could always just grap the Ptr and do with it what you please
17:16:02 <solrize> mmorrow sounds like C programming :)
17:16:05 <Pseudonym> I'm not actually objecting, but still.
17:16:23 <MisterN_> http://hackage.haskell.org/packages/archive/mmap/0.2/doc/html/System-IO-MMap.html
17:16:23 <mmorrow> solrize: the most powerful part thereof :)
17:16:25 <lambdabot> http://tinyurl.com/5snusq
17:16:36 <MisterN_> dons: dunno but that doesn't seem to be so elegant
17:16:37 <dons> MisterN_: note there's even lazy mmap
17:16:55 <dons> where individual chunks are unmapped independently as they're discarded on the haskell side
17:16:56 <MisterN_> dons: yeah but the writable versions seem to use Ptr stuff
17:17:18 <proq> mmorrow: grap? grappa?
17:17:22 <mauke> MisterN: what did you expect?
17:17:23 <dons> wrong interface
17:17:29 <MyCatVerbs> Pseudonym: -possibly- you should be taking it as a compliment.
17:17:34 <dons> that's not the library. that's some low level binding
17:17:35 <monochrom> dons: mmap breaks semantics. consider { mmap("myfile"); fopen("myfile", "w"); ...}   <duck>  :)
17:17:37 <Pseudonym> Possibly, yes.
17:17:39 <chessguy> it seems to me if we can't control people uploading other people's packages, then we're growing _too_ fast as a community
17:17:42 <mmorrow> proq: ?
17:17:51 <joey_> Yes, at least you have produced something worthy of an upload, Pseudonym
17:17:51 <MisterN_> mauke: nothing else. dons said however, that mmap would fit nicely into haskell
17:17:52 <solrize> i have a file full of intricate data layout and it would be great to mmap it and be able to treat it as a typed structure and have the right stuff happen automagically.
17:17:55 <dons> http://hackage.haskell.org/packages/archive/bytestring-mmap/0.1.2/doc/html/System-IO-Posix-MMap.html
17:17:57 <lambdabot> http://tinyurl.com/5lsqza
17:17:59 <MisterN_> Ptr seems to prove to opposite
17:18:01 <Pseudonym> The only thing I kind of object to is that it now has a de facto version number.
17:18:02 <dons> MisterN_: mmapFile :: FilePath -> IO ByteString
17:18:10 <Pseudonym> Which I did not assign.
17:18:16 <dolio> Is Ptr not Haskell?
17:18:16 <dons> MisterN_: note that ByteString is pure, so once mapped the type system enforces that you can't write back .
17:18:18 <dolio> :)
17:18:22 <mauke> mmapFileByteStringLazy :: FilePath -> Maybe (Int64, Int64) -> IO ByteString
17:18:23 <MisterN_> dons: indeed.
17:18:26 <monochrom> dons++
17:18:28 <MisterN_> dons: and that's the problem
17:18:39 <mauke> MisterN_: I use pointers in haskell
17:18:48 <MisterN_> mauke: do you like to use them?
17:18:53 <mauke> depends
17:18:59 <solrize> where's that mmapfile?  the mmap i saw in hackage was something like unsafeMmap
17:19:11 <MyCatVerbs> solrize: that sounds like it could be done, but not automagically. How do you cope with offsets within the file?
17:19:19 <MisterN_> mauke: it seems very unhaskellish to me.
17:19:39 <mauke> MisterN_: how else are you going to interface with C libraries?
17:19:49 <solrize> mycatverbs data constructors woudl have to take care of it
17:19:56 <Pseudonym> Mind you, if you put a darcs repo out there, and put an open source licence on it, then people are _allowed_ to tarball it and post it somewhere.
17:19:57 <MisterN_> mauke: well that of course
17:20:09 <MisterN_> mauke: but when you use it, you're not being very haskellish
17:20:19 <mauke> http://mauke.ath.cx/stuff/haskell/hell.hs
17:20:27 <MisterN_> mauke: so if writable mmap needs Ptrs
17:20:32 <MyCatVerbs> solrize: e.g. some people write out binaries with 0-based offsets in bytes. Some freaks have offsets in qwords. Some real dirtbags write things using relative offsets. A handful even write things using offsets plus some random constant that relates to the memory layout of their godawful C program.
17:20:35 <MisterN_> is that very haskellish?
17:20:43 <dolio> Then use non-writable mmap.
17:20:46 <mauke> MisterN_: I don't care
17:20:58 <dons> MisterN_: oh, you're still looking at that other library?
17:20:59 <dolio> If you're deeply concerned about being "haskellish".
17:21:05 <mauke> it's a good interface
17:21:14 <mauke> if you want something else, you can write it on top of it
17:21:16 <MyCatVerbs> solrize: smart constructors, fine, but I don't see how you could roll up a file full of C structs without some effort.
17:21:22 <MisterN_> dons: it seems to be the only one with writable mmap
17:21:36 <MisterN_> dolio: or i can use C++ :>
17:21:48 <dons> so what was your question again?
17:22:08 <monochrom> there was probably no question.
17:22:11 <MisterN_> dons: i claimed that mmap was a pretty much un-functional concept
17:22:14 <solrize> mycatverbs yeah that seems to be about the best method.  i saw a paper about doing it declaratively with high powered type theory but i didn't understand it
17:22:14 <dons> oh, i note i've not uploaded the new version.
17:22:23 <MisterN_> dons: and you said my claim was wrong
17:22:39 <dons> i'm not sure "unfunctional" means anything.
17:23:01 <monochrom> is mmap referentially transparent?  <duck> :)
17:23:05 <MisterN_> so what does haskell mean then? it's main "selling point" is being functional after all
17:23:17 <dons> monochrom: the high level one enforces referential transparency, yeah
17:23:17 <pjdelport> dons: what unlambda implements?
17:23:33 <monochrom> haskell's selling point is being the finest imperative language on Earth.
17:23:35 <dons> MisterN_: you missed the memo?
17:23:36 <MyCatVerbs> solrize: right. Smart constructors are ordinary functions, though, so I guess you end up writing some kind of HOF-based binary parser library like, hey, Data.Binary or something.
17:23:42 <mauke> MisterN_: C can't do IO
17:23:54 <MisterN_> dons: the what?
17:24:07 <MisterN_> monochrom: well then the problem is solved of course :)
17:24:18 <dons> i'm not sure haskell's main claim is being functional.
17:24:41 <MyCatVerbs> solrize: if you wanted something more declarative, maybe you could write a library for Template Haskell that generated code from a description of the layout. (But parser combinators usually end up looking declarative anyway.)
17:24:47 <MisterN_> "Haskell is an advanced purely functional programming language."
17:24:50 <solrize> is putting haskell's type system in an imperative language a sane concept at all?
17:24:52 <MisterN_> first sentence on haskell.org
17:24:59 <dons> MisterN_: yes, purely functional.
17:25:07 <dons> and i gave you an example of a purely functional mmap interfacd
17:25:23 <MisterN_> dons: which can't do everything that mmap can do.
17:25:25 <dons> which uses the type system to enforce the purity the C implementation enforces only via documentation
17:25:33 <MyCatVerbs> solrize: yes. I think you'd just end up ignoring the distinction between (a) and (IO a).
17:25:36 <mauke> MisterN_: duh?
17:25:36 <nolrai_> @ty forM
17:25:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:25:39 <monochrom> Do you know that when you go to the extreme of imperative, you wrap-around back to functional; and if you go to the extreme of functional, you wrap-around back to imperative?
17:25:47 <mauke> MisterN_: haskell has no assignment operator either
17:25:48 <MyCatVerbs> solrize: and you end up with ML, that way.
17:26:00 <MisterN_> mauke: indeed
17:26:08 <solrize> mycatverbs TH is basically an untyped macro system on top of haskell expressions iirc
17:26:27 <dolio> Untyped?
17:26:40 <dons> so did you learn anything from this exercise, MisterN_ ?  is the whole idea of strong typing, purity and functional expressiveness a lost cause?
17:26:49 <MisterN_> monochrom: do you know that topology makes you go mad? :)
17:26:58 <MisterN_> dons: no it's not
17:27:07 <dolio> It's Haskell that gets executed at compile time to produce Haskell ASTs (more or less).
17:27:18 <dons> i mean, i really think that fact that it is trivially cheap to enforce purity on a mmap binding a remarkable achievment
17:27:25 <dons> there is no other language that comes close there.
17:27:35 <MyCatVerbs> solrize: maybe a macro system with good enough reflection could make sure the data declarations match the functions generated?
17:28:17 <MyCatVerbs> dons: er, Cayenne? Miranda? ;)
17:28:20 <dons> powerful invariants, the kind that keeps software robust and modular, get expressed routinely in haskell. it is just an everyday occcurence to code in type system proofs of invariants
17:28:32 <solrize> mycatverbs, yeah, something like that.  it's too advanced for me though
17:28:34 <dons> that is something remarkable.
17:28:37 <MisterN_> dons: the language needs to be lazy of course, and popular enough to warrant a mmap implementation, which rules out most other languages.
17:29:01 <MisterN_> dons: and haskell's type system is indeed impressive
17:29:19 <MyCatVerbs> dons: Agda, even? :)
17:29:23 <dons> it is that idea that you can and should use the type system to control effects, to specify strong properties statically, that haskell is trying to contribute to the world.
17:29:28 <MisterN_> dons: i'm not an enemy of haskell, more a sceptical friend.
17:30:04 <solrize> mycatverbs i don't know ML but i have the impression that it doesn't allow haskell's level of type abstraction in practice.  there's some theorem that says the type systems are the same in principle however in ML that only comes into play at the module level
17:30:21 <monochrom> I'm a friendly skeptic <duck> :)
17:30:54 <MyCatVerbs> I'm a fanboy. Nyeh nyeh.
17:31:09 <monochrom> http://www.vex.net/~trebla/haskell/
17:31:11 <dolio> Are you okay? You keep saying "duck". :)
17:31:21 <mauke> No quack!
17:31:22 <MisterN_> dolio: i bet he likes ducks.
17:31:32 <monochrom> Yes. This time it's <shameless plug>
17:31:34 <dons> being skeptical of haskell is like being skeptical of hammers.
17:31:35 <MisterN_> which are beautiful animals after all
17:31:47 <mauke> I don't believe in hammers
17:31:52 <dons> it works, it does what it does, and people use it.
17:31:56 <MisterN_> dons: why use hammers when a stone does the job? :)
17:32:05 <dons> right.
17:32:19 <MisterN_> stones fit the hand pretty well.
17:32:19 <dons> why use anything where you can implement it in an ad hoc way using other things.
17:32:26 <lament> why use a hammer when you can can just hammer in a nail with a screwdriver?
17:32:36 <MisterN_> lament: indeed!
17:32:37 <monochrom> hammer is sooo imperative...
17:32:46 <mrd> when the only tool you have is a screwdriver everything looks like a nail?
17:32:52 <MisterN_> monochrom: how'd a functional hammer be?
17:33:40 <monochrom> Use glue rather than nails. Nails are sooo destructive.
17:33:40 <dons> isn't a hammer supremely functional item.
17:33:52 <MisterN_> glue!
17:33:54 <mauke> when the only tool you have is php, every problem looks like a html template
17:34:08 <dons> every html template looks like a problem?
17:34:23 <monochrom> Do not look down upon glues. There are incredibly strong ones.
17:34:35 <MisterN_> mauke: and every array looks like a complex intermediate between an array and a string->string map
17:34:41 <MisterN_> string->object map i mean
17:34:49 <monochrom> They also dry transparent. :)
17:34:55 <loop> monochrom: you put things together once and can't pull them apart anymore?
17:34:56 <mauke> MisterN_: from the description it sounds like a hash table with a doubly linked list through the values
17:35:05 <monochrom> There are glue solvents.
17:35:05 <MisterN_> monochrom: yeah and they are used for building cars these days
17:35:05 <dons> really, haskell's philosophy is that of a hammer. be precise, strong and have each function do exactly one thing, perfectly.
17:35:14 <povman> MisterN_: na - everything is just string
17:35:19 <monochrom> Nails leave permanent holes.
17:35:31 <MisterN_> povman: php claims to have classes these days
17:35:38 <povman> i bet they're strings too
17:35:38 <dons> while some languages are more like a random aggregate of tools, with many sharp edges, and it is unclear how you're supposed to hold it
17:35:41 <mauke> povman: you're thinking of tcl
17:35:48 <MisterN_> then again, that's the whole nature of php: all claims, no substance
17:36:09 <povman> how else could "0" == ""?
17:36:31 <nolrai_> > lookup 1 (M.empty) :: Either String Int
17:36:31 <lambdabot>  Couldn't match expected type `[(t, b)]'
17:36:40 <nolrai_> > M.lookup 1 (M.empty) :: Either String Int
17:36:42 <lambdabot>  Left "Data.Map.lookup: Key not found"
17:36:51 <mauke> povman: by doing type conversion in ==
17:37:00 <mauke> just like perl (only broken)
17:37:01 <povman> peh.
17:37:03 <MisterN_> povman: now that's true for perl, but == is numbers only anyways :D
17:37:18 --- mode: ChanServ set +o dons
17:37:26 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ "]' by dons
17:37:30 --- mode: ChanServ set -o dons
17:37:43 <MisterN_> dons: wait, could you please fix the... plenks?
17:37:50 <MisterN_> "x" ,"y"
17:37:55 <MisterN_> is ugly
17:38:01 <povman> where does cabal-install put hackage docs?
17:38:01 <dons> oh, the spaces. sure
17:38:25 <dolio> You mean haddock?
17:38:25 <solrize> i think to write "wc" without lazy i/o i' d have to put the whole thing in a state monad that advances through some buffer and it would have to be in IO so it could read the next bufferload, and there would be a state machine that noticed word delimiters etc, like a C program
17:38:32 --- mode: ChanServ set +o dons
17:38:41 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org ", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
17:38:45 --- mode: ChanServ set -o dons
17:38:49 <dolio> cabal-install doesn't do haddock currently, I think.
17:38:55 <povman> noooo
17:38:56 <dons> solrize: you need some kind of lazy IO abstraction!
17:39:07 <dcoutts> dolio, povman: but we do accept patches! :-)
17:39:09 <dons> imagine if such a thing was available in the core libraries. wow, that'd be sweet.
17:39:39 <solrize> dons that would be really cool!  but, there seems to be no type-safe way of doing that
17:40:51 <mrd> haskell, like gazpacho soup, is best served cold and precise
17:41:03 <dolio> dcoutts: I'm busy guessing which of my functions is doing 1.6 GB of heap allocation. :)
17:41:10 <dcoutts> heh heh
17:41:24 <dcoutts> don't guess! profile!
17:41:38 <MisterN_> @quote solrize
17:41:38 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
17:41:39 * dcoutts wrote a gui for the ghc time/allocation profiles
17:41:43 <dolio> Can't. Profiling makes the culprit stop allocating, and makes something else allocate instead. :)
17:41:48 <MisterN_> lol lambdabot has a bug
17:41:58 <dcoutts> dons: if you're packaging gtk2hs demos, there's another nice one :-) the profile viewer
17:42:11 <dons> nice. cheers.
17:42:14 <dcoutts> dons: it just needs a new parser, one that's not totally silly
17:42:25 <solrize> there's endless bugs in haskell programs where someone doesn't have quite enough strictness annotations and the result is space leaks.  but when IO is involved, doing something lazily by accident can make i/o operations happen in the wrong order and completely mess up the program results
17:42:46 <dcoutts> dons: probably one that uses the machine readable format rather than the standard human readable form (which is a pita to parse)
17:43:50 <dcoutts> dons: oh, btw, do you have a repo for that clock one? I've got patches to make it use transparent background.
17:43:52 <MisterN_> solrize: we've already been there today :)
17:44:06 <snhmib> solrize: isn't that the reason why you can't get out of the IO monad?
17:44:11 <mrd> oh that reminds me, i should break out my gtk2glext demos
17:44:37 <dcoutts> mrd: yes, and submit them for inclusion in the gtk2hs package
17:44:51 <dons> dcoutts: i think it is code.haskell.org/~dons/code/hsclock
17:45:02 <solrize> snhmib right, but there's this escape hatch from IO that is treated as a routine operation in the language instead of being surrounded by red flags and sirens
17:45:05 <dcoutts> dons: ok ta, I'll send patches
17:45:26 <mrd> where do I go for that?
17:45:39 <snhmib> solrize: the unsafe part should be warning flag enough :P
17:45:52 <solrize> there is no unsafe part!  getContents doesn't say "unsafe" anywhere ;)
17:46:23 <solrize> maybe it's just a matter of function names and documentation
17:46:32 <snhmib> oh i thought escape hatch as getting rid of monad o_O
17:47:04 <ddarius> System.Unsafe.unsafeDoSomething
17:47:29 <MyCatVerbs> solrize: it should. This is an omission.
17:48:15 <MyCatVerbs> solrize: or probably it should at the very leat be called lazyGetContents, with an explaination of why it's so good at self-destructing.
17:48:35 <snhmib> isn't getting "everything" and then assuming you can still get something out of it an error anyway? :S
17:48:40 <monochrom> Next April someone should implement the red alert and siren using TH.
17:48:52 <dolio> Why is it good at self-destructing, exactly? Because everyone writes programs that read from/write to the same file all over the place?
17:48:54 <solrize> so if i want to use lazy i/o on multiple parts of the file i have to manually allocate and free separate file handles on each part i'm trying to read.  i guess i'd have to do that in C too, of course.
17:49:20 <MyCatVerbs> dolio: precisely that.
17:49:44 <solrize> i could have a file handle pool sort of like the db connection pool in a php program ;)
17:49:46 <MyCatVerbs> dolio: and people generally don't because we tell them not to. ;)
17:49:49 <monochrom> That is like saying div is good at aborting, don't ever use div.
17:50:20 <monochrom> recursion is good at diverging, don't use recursion.
17:50:35 <MyCatVerbs> monochrom: well okay. But to use hGetContents, you need to not mind too much if you occasionally leak a file descriptor, or memory for the contents.
17:51:18 <edwardk> @seen shapr
17:51:18 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 3h 41m 15s ago.
17:51:22 <MyCatVerbs> monochrom: if, for example, the number of FDs you're using has a low O(1) bound and you're not going to unnecessarily hold on to references close to the head of the list, then fine.
17:51:24 <shapr> What?
17:52:05 <solrize> lazy io can really break referential transparently in ways that div or recursion can't.  div might diverge but it won't return a wrong answer
17:53:08 <MyCatVerbs> monochrom: plus there's thing like the fact that: findFileSize name = readFile name >>= return . length -- doesn't actually work.
17:53:14 <MyCatVerbs> *things
17:53:53 <MyCatVerbs> monochrom: hang on, I'm wrong there, I think that does.
17:54:00 <solrize> that looks ok
17:54:06 <solrize> it reads the whole file...
17:54:45 <MyCatVerbs> monochrom: findFileSize name = do { hdl <- openFile name ReadMode; contents <- hGetContents hdl; hClose hdl; return (length contents); }
17:54:55 <nolrai_> @ty M.insertWith
17:54:56 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:55:17 <ddarius> monochrom: There are people that say those things.  Also, hGetContents can lead to erroneous not exceptional behaviour.
17:55:26 <MyCatVerbs> That always returns 0 if you try it with a lazy hGetContents, but is fine with strict hGetContents.
17:56:00 <MyCatVerbs> ddarius: like that. ^^
17:56:39 <shapr> This is WHNF Radio Haskell broadcasting to you from Boston, MA!
17:56:55 <gwern> MADNESS
17:57:05 <gwern> because you can't spell MADNESS without MA!
17:57:36 <dolio> gwern: Sorry for getting you in trouble. :)
17:58:02 <gwern> hm?
17:58:22 <gwern> dolio: who are you?
17:58:23 <dolio> Well, I suggested you update the cabal on collections and related stuff.
17:59:00 <gwern> ah, right. mm, an email to libraries@haskell.org saying that an update wouldn't be pointless for you would not go amiss
17:59:23 <gwern> (it's easy to dismiss me, because I'm crazy ol' gwern, but a second person helps)
17:59:42 <dolio> Heh, all right.
18:00:33 <shapr> gwern: hah!
18:01:35 <Botje> shapr: WHNF radio? you mean the internals only come into existence once you send out something?
18:01:58 <shapr> Botje: Yeah... that's pretty much how I organize conferences also.
18:02:03 <Botje> :))
18:02:12 <gwern> whew. thank goodness for hpaste. I lost my entire todo list, but because I had put it up on hpaste, I can retrieve it
18:02:24 * Botje has a secret theory the universe is evaluated in a WHNF fashion
18:02:26 <shapr> gwern: I've been deleting stuff off of hpaste lately....
18:02:31 <Botje> which is probably why it's expanding
18:02:46 <Botje> does there exist a command-line hpaste client yet?
18:02:58 <shapr> I think there's emacs integration.
18:03:13 * Botje adds to his hack list
18:04:31 <gwern> Botje: actually, a CLI hpaste client would be very useful. I've been musing on an idea: for lambdabot or a lambdabot  replacement, instead of maintaining @quote and @tell and @where and @fact etc. in memory or on disk, why not make it a hpaste?
18:05:04 <Botje> put all @quote's on hpaste?
18:05:18 <Botje> that'd be a _massively_ annotated paste :)
18:05:42 <Botje> it'd stress-test the server, too >:)
18:05:55 <gwern> sure. that way, you could easily edit them. you'd have a history. they'd be trivial to download. you wouldn't need to go through lambdabot. lambdabot crashes would be almost irrelevant, etc
18:06:18 <Botje> yeah, i've found myself wishing @quote was stored somewhere externally too
18:06:20 <gwern> since hpaste has a rss feed, iirc, there's even a builtin way of monitoring the webversion for changes!
18:06:59 <monochrom> eeek
18:07:36 <gwern> my other idea was a darcs repo just for the state, which allowed anonymous updates
18:07:47 <gwern> but I'm not sure how one would do that with darcs
18:15:52 <electronx> can someone let me know how i can convert ['M','Z', ' ', ' '] to and word32?
18:16:18 <electronx> > map ord  ['M','Z', ' ', ' ']
18:16:19 <lambdabot>  [77,90,32,32]
18:16:30 <electronx> then what can i do?
18:16:51 <electronx> can i to shifts?
18:16:57 <Botje> > map (fromIntegral . ord) "MZ  " :: Word32
18:16:58 <lambdabot>  Couldn't match expected type `Word32' against inferred type `[b]'
18:16:59 <electronx> or is there a better way
18:17:04 <Botje> > map (fromIntegral . ord) "MZ  " :: [Word32]
18:17:05 <lambdabot>  [77,90,32,32]
18:17:12 <Botje> like that :)
18:17:16 <electronx> no
18:17:30 <electronx> i'm thinking in C
18:17:31 <Botje> what?
18:17:36 <Botje> don't! :)
18:17:46 <electronx> int *g = &buff;
18:17:48 <povman> i think he means one word32 with those 4 letters
18:17:54 <electronx> yep
18:17:56 <Botje> oh
18:17:58 <Botje> *brrr*
18:18:03 <electronx> pvman hit the nail on the head
18:18:07 <povman> Botje: are you really a Bot?
18:18:23 <snhmib> aren't word32's in the shift class?
18:18:25 <Botje> why, did I fail the turing test? :)
18:18:30 <snhmib> err Bit i mean
18:18:35 <monochrom> Use Data.Binary. You won't be writing such conversion code yourself.
18:18:39 <povman> no, you're winning - i didn't know they solved that
18:18:43 <Botje> :)
18:18:57 <electronx> Data.Binary?
18:19:10 <mauke> @vixen did I fail the turing test?
18:19:10 <lambdabot> yes
18:19:14 <mauke> ;_;
18:19:17 <monochrom> @hackage binary
18:19:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
18:19:23 <Botje> epic turing fail
18:19:31 <snhmib> old news mauke!
18:19:31 * Botje is going to wrap up his tinkering for today
18:19:35 <monochrom> That has "Data.Binary"
18:19:38 <Botje> need sleep
18:19:48 <Botje> then fix code tomorrow
18:19:50 <Botje> and write report :(
18:20:18 <mauke> > let code = ("HA" ++) in fix code
18:20:19 <lambdabot>  "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH...
18:20:28 <Botje> :)
18:20:39 <Botje> > fix ("mauke"++)
18:20:41 <lambdabot>  "maukemaukemaukemaukemaukemaukemaukemaukemaukemaukemaukemaukemaukemaukemauke...
18:20:58 <mauke> preflex: karma "mauke"
18:20:58 <preflex>  karma for "mauke": 1
18:21:07 <monochrom> I have scared electronx away by the principle of code reuse.
18:21:23 <povman> lol
18:21:55 <MisterN_> Botje:
18:21:57 <MisterN_> > foldl (\x y -> x * 256 + y) 0 $ map ord "MZ "
18:21:58 <lambdabot>  5069344
18:22:03 <MisterN_> is this what you want?
18:22:18 <monochrom> Perhaps Data.Binary contains a monad and his brain exploded.
18:22:27 <Botje> you want to poke electronx, rather
18:22:31 <Botje> although he left, apparently
18:22:45 <MisterN_> oh
18:22:53 <MisterN_> confused you guys
18:22:58 <Botje> @pl \x y -> x * 256 + y
18:22:59 <lambdabot> (+) . (256 *)
18:22:59 <povman> maybe he crashed his computer by compiling C with GHC
18:23:09 <Botje> hmm
18:23:21 <Botje> we should hold a "guess that @pl" contest
18:23:54 <povman> me first:
18:24:08 <povman> @pl \x -> if x then x else False
18:24:09 <lambdabot> flip (join if') False
18:24:24 <Botje> heh
18:24:25 <mauke> “id”
18:24:28 <Botje> that's cheating!
18:25:15 <povman> :t if'
18:25:16 <lambdabot> Not in scope: `if''
18:26:01 <povman> i wish pattern guards were more branchy
18:26:25 <povman> ie nestable
18:26:42 <dolio> Nested guards in general would be a useful feature.
18:27:05 <dolio> I think there might be a haskell' ticket for such a beast.
18:28:42 <dolio> Oh, Clean has them.
18:30:21 <dolio> Well, it was proposed on the mailing list, but there's no ticket for them, I guess.
18:33:10 <dcoutts> dons: http://haskell.org/~duncan/gtk2hs/Clock.png
18:33:29 <dcoutts> pgavin-away: I've got an extra module so slip into the next release if there's still time :-)
18:33:49 <dcoutts> pgavin-away: it lets us make the clock demo properly transparent, see the pic above
18:34:26 <dcoutts> mm, nice drop shadows
18:35:30 <monochrom> why do I think "the golden compass" when I see that?
18:35:37 <dcoutts> heh
18:35:50 <mrd> well i linked a couple of demos i cleaned up a little ot gtk2hs wiki page
18:36:11 <dcoutts> mrd: great
18:37:38 <dcoutts> mrd: mind if we include them into the gtk2hs demos/ collection in the releases too?
18:38:11 <mrd> not at all
18:38:14 <dcoutts> ta
18:38:23 * dcoutts wanders off to bed
18:38:24 <mrd> they could probably use improvement.
18:38:26 <mrd> but wtever
18:46:12 <povman> i think i just found out why RJson exists
18:52:20 <dobblego> > some (Just 7) -- why does this cause a stack overflow?
18:52:24 <lambdabot>  Exception: stack overflow
18:52:31 <povman> :t some
18:52:33 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
18:52:39 <dobblego> > head $ some (Just 7)
18:52:40 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe t'
18:52:47 <dobblego> oops
18:53:20 <dobblego> > head <$> some (Just 7)
18:53:21 <povman> some Just
18:53:21 <lambdabot>  Exception: stack overflow
18:53:35 <dobblego> wtf?
18:53:42 <dobblego> does some *ever* terminate?
18:53:44 <monochrom> what does some do for Maybe?
18:53:48 <povman> > some Just
18:53:49 <lambdabot>        add an instance declaration for (Alternative ((->) a))
18:54:01 <dobblego> monochrom, overflow the stack?
18:54:19 <monochrom> I mean what is it supposed to do
18:54:20 <dobblego> > many (Just 7) -- same for many
18:54:21 <lambdabot>  Exception: stack overflow
18:54:28 <dobblego> monochrom, that's the essence of my question
18:54:37 <ddarius> Despite the type, some has a pretty restricted domain of application.
18:54:52 <dobblego> some is the notion of '0 or more' for an applicative functor
18:55:04 <dobblego> er, '1 or more'
18:55:11 <dobblego> (many is '0 or more')
18:55:50 <dobblego> *an applicative functor monoid
18:56:17 <roconnor> alternative functor
18:57:48 <monochrom> > some [0,1,2] :: [[Int]]
18:57:50 <lambdabot>  Exception: stack overflow
18:59:09 <monochrom> > some Nothing
18:59:10 <lambdabot>  Nothing
19:00:40 <monochrom> > some Nothing :: Maybe [Int]
19:00:41 <lambdabot>  Nothing
19:01:06 <ddarius> > some []
19:01:07 <lambdabot>  []
19:01:36 <ddarius> It repeatedly executes the passed in argument until it fails.  For Maybe and [], unless they fail immediately, this won't ever happen.
19:01:38 <dolio> some (Just 7) tries to build an infinite list of 7s, but Maybe is too strict an Applicative for that (or something along those lines).
19:02:39 <marcot> @type some
19:02:42 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
19:08:03 <Frederick> I need help interpreting a colimit diagram in an article in fact I need to make some explanation over it still i think it is oki I need some feedback is anyone here familiar with such notion?
19:09:52 <nolrai_> @instance Monad
19:09:52 <lambdabot> Maybe you meant: instances instances-importing
19:09:57 <nolrai_> @instances Monad
19:09:58 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:12:13 <nolrai_> is it posible to convert from "a -> m a" to "m (a -> a)"?
19:12:22 <nolrai_> m is a monad
19:12:44 <mmorrow> n is a nomad
19:13:10 <nolrai_> @djinn (a -> m a) -> m (a -> a)
19:13:10 <lambdabot> -- f cannot be realized.
19:13:50 <mmorrow> @djinn (a -> b) -> b
19:13:50 <lambdabot> -- f cannot be realized.
19:14:15 <mmorrow> @djinn (() -> b) -> b
19:14:16 <lambdabot> f a = a ()
19:14:22 <ddarius> nolrai_: Not in any way you want.
19:14:28 <nolrai_> That doesnt even make sense does it?
19:14:54 <ddarius> You can go the other way.
19:14:56 <mmorrow> @djinn (a -> a) -> a
19:14:56 <lambdabot> -- f cannot be realized.
19:15:10 <mmorrow> :t fix
19:15:12 <lambdabot> forall a. (a -> a) -> a
19:15:34 <rwbarton> fix is not total
19:15:44 <nolrai_> ddarius: how?
19:16:22 <nolrai_> > fix (const 2)
19:16:24 <lambdabot>  2
19:16:26 <ddarius> :t \m a -> m >>= return . ($ a)
19:16:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
19:17:12 <nolrai_> huh..hmm
19:18:43 <mmorrow> :t const (return id) :: (a -> m a) -> m (a -> a)
19:18:44 <lambdabot>     Could not deduce (Monad m) from the context ()
19:18:44 <lambdabot>       arising from a use of `return' at <interactive>:1:7-15
19:18:44 <lambdabot>     Possible fix:
19:18:58 <mmorrow> :t const (return id) :: (Monad m) => (a -> m a) -> m (a -> a)
19:19:00 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> m (a -> a)
19:19:05 <dolio> @type \f a -> f <*> pure a
19:19:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
19:20:18 <chessguy> huh. chess is a category
19:20:19 <nolrai_> dolio: pretty.
19:21:08 <nolrai_> chessguy: Huh? a category theory category?
19:21:19 <chessguy> the class is the set of positions, and the morphisms are the moves
19:21:33 <ddarius> Yes, it's a monoid.
19:21:59 <chessguy> nolrai_:  yeah
19:22:05 <ddarius> You could make finer distinctions and have it be a (proper) category.
19:22:38 <chessguy> ddarius:  what do you mean?
19:22:39 <mmorrow> which contains a submonoid which is a group, consisting of all reversible moves
19:22:56 <mmorrow> (i say off the top of my head)
19:23:01 <monochrom> "morphism is move" is wrong. breaks morphism composition. you need "morphism is zero or more moves".
19:23:22 <mmorrow> zero moves is a move where you do nothing
19:23:31 <dobblego> zugzwang
19:23:36 <mmorrow> whether the rules allow that in a partic case is another matter though...
19:24:11 <chessguy> wonder if this is important for anything other than academic curiosity
19:24:19 <monochrom> you speak like "move" is defined outside the "rules".
19:24:46 <mmorrow> hence the trouble my def of zero moves causes
19:25:50 <chessguy> ddarius:  do you mean it's a monoid in the sense of Data.Monoid?
19:25:59 <mmorrow> yes!!
19:26:06 <chessguy> ermm
19:26:10 <chessguy> not sure about that
19:26:22 <mmorrow> a monoid is a monoid
19:26:32 <nolrai_> I have an updater ":: (a -> a) -> b -> b" and a function of type "a -> m a" is it posible to combine them and get somthing of type "m b"?
19:27:06 <dobblego> @djinn (a -> a) -> b -> b
19:27:06 <lambdabot> f _ a = a
19:27:43 <rwbarton> nolrai_: it sounds like you might need mfix?
19:27:45 <dobblego> you want something :: b -> (a -> m a) -> m b?
19:27:54 <nolrai_> yes
19:27:58 <ddarius> I guess it couldn't be a monoid (naively) because the "multiplication" would not be total in general.
19:28:12 <nolrai_> :t mfix
19:28:14 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
19:28:40 <dobblego> ?type const . return
19:28:42 <lambdabot> forall b a (m :: * -> *). (Monad m) => a -> b -> m a
19:29:23 <mmorrow> ddarius: why wouldn't it be total?
19:31:21 <mmorrow> ddarius: (i'm taking the monoid as being the monoid of endos of the game w/ morphisms moves, so the multiplication would be composition of morphisms/moves and i can't think why that wouldn't be total)
19:32:00 <chessguy> mmorrow: uh...what?
19:32:29 <rwbarton> mmorrow: how do you compose "1. e4" with itself?
19:33:19 <mmorrow> chessguy: are you saying "1. e4" is a morphism?
19:33:32 <chessguy> mmorrow:  i don't know category theory
19:33:41 <mmorrow> chessguy: are you saying "1. e4" is a function?
19:33:53 <chessguy> seems that way to me
19:34:01 <mmorrow> oh oops, @rwbarton
19:34:03 <chessguy> from one position to another
19:34:09 <mmorrow> ohhhh
19:34:09 <rwbarton> I am confused about who is saying what :)
19:34:13 <mmorrow> chess move notation
19:34:31 <chessguy> right
19:34:47 <mmorrow> i'm not familiar with it and thought that "1. e4" was 1x10^4 and was like wtf??
19:34:50 <chessguy> also known as "pawn to king-4"
19:34:54 <chessguy> hahaha
19:34:58 <mmorrow> heh
19:35:54 <mmorrow> yeah, so the "moves" would have to include information about the state of the *rest* of the board as well as the info about the partic move
19:36:17 <chessguy> hrm. interesting
19:36:24 <mmorrow> (at least that's how i was defining "move")
19:36:40 <rwbarton> I would think of it this way
19:36:50 <chessguy> mmorrow:  how would a function that determines what the current legal moves are fit into the framework?
19:36:50 <rwbarton> there is a graph whose vertices are positions and whose edges are moves
19:37:01 <dobblego> there is also information required for "was the last move a white pawn to 5th rank or black pawn to 4th rank" and "has the king and/or rook(s) moved"
19:37:11 <rwbarton> you can take the free category on that graph, whose objects are positions and whose morphisms are sequences of composable moves
19:37:17 <rwbarton> But it is not a monoid, because it has many objects.
19:37:28 <mmorrow> hmm, gotta run but be back in 10, this is interesting...
19:37:41 <rwbarton> Yes, position includes a little more information than where the pieces are (also whose turn it is)
19:37:50 <chessguy> right
19:38:20 <chessguy> where it gets interesting is that there are many games that have the same properties
19:38:36 <chessguy> i wonder if there's a general category-theoretical way to describe it
19:38:50 <Frederick> folks taking advantage of the conversation ive written a ppaper for university in category theory anyone would like totake a look?
19:40:12 <chessguy> Frederick:  paste a link. i guarantee i won't even be able to read it, but i'm sure someone here can :)
19:40:15 <rwbarton> chessguy: The answer is Yes!  Category theory can do that.
19:40:24 <nolrai_> hmm, these genral problems would aplie to combinatorial games in genral.
19:40:46 <chessguy> nolrai_:  exactly. solve once, apply anywhere :)
19:41:14 <nolrai_> although I dont think chess is quite a combinatiorial game is it? because of stale mates?
19:41:30 <chessguy> i'm not sure how you're defining "combinatorial game"
19:42:36 <nolrai_> as in "combinatorial game theory" :P
19:42:39 <nolrai_> err
19:43:39 <nolrai_> http://en.wikipedia.org/wiki/Combinatorial_game_theory
19:44:00 <chessguy> according to that article, chess is a combinatorial game
19:44:19 <Frederick> article is under http://inf.ufrgs.br/~vfbsilva/129420.pdf if someone botters to read
19:46:00 <nolrai_> yes i noticed that. Strange I could of sworn it wasn't.
19:46:46 <povman> @google
19:46:47 <lambdabot> Empty search.
19:46:50 <povman> @google colimit
19:46:51 <lambdabot> http://en.wikipedia.org/wiki/Continuous_functor
19:47:20 <chessguy> nolrai_:  well, what were your thoughts on why stalemate would make a difference?
19:48:18 <nolrai_> I dont think the theory handles ties.
19:50:02 <ddarius> Frederick: There is a ton of crap you should be citing.
19:50:09 <nolrai_> because it assomes that being unable to move is a loss.
19:50:30 <Frederick> ddarius: I know still bibtex is making me crazy
19:50:51 <Frederick> ddarius: I did de file it simply is not added are you familiar with it?
19:50:55 <mmorrow> chessguy: back
19:50:57 <mmorrow> mmorrow:  how would a function that determines what the current legal moves are fit into the framework?
19:51:07 <ddarius> Frederick: I have no idea what you just said.
19:51:18 <Frederick> ddarius: what do you mean I should be citing?
19:51:57 <mmorrow> chessguy: hmm, what's the/your way of determining this (in summary)
19:51:59 <ddarius> There is a pile of work on using colimits for combining program modules.
19:52:20 <Frederick> ddarius: I have it on the references but as I just said bibtex is not working here
19:53:11 <povman> Frederick: i have a doc with a bibliography
19:53:27 <povman> only 2 commands: \bibliographystyle{plain}\bibliography{bibliography}
19:53:36 <chessguy> mmorrow:  well, it's a function of all the information about the current position, as well as the position that would result from a potentially legal move (e.g., whether it would leave the king in check)
19:55:31 <Frederick> povman: [BibTeX] 129420.aux => 129420.bbl (bibtex)
19:55:32 <Frederick> [BibTeX] finished with exit status 2
19:56:18 <mmorrow> chessguy: ok, possibly one way to phrase the situation (in general) would be to say chess is a category with objects possible-game-states and morphisms moves, where a move would just have to be the chess-notation-representation
19:57:12 <mmorrow> chessguy: so how to then get the monoid structure you could do something like you'd do if you wanted to think of the monoid (Integers,+) as a category...
19:58:04 <chessguy> hm. i need to think about this some more, but it's bedtime here. maybe we can catch up tomorrow or something
19:58:08 <mmorrow> morphisms are take any n `elem` Integers and this would be an endomorphism (Z->Z) of the Integers given by (+n)
19:58:22 <roconnor> > fromSum $ 1 `mappend` 2
19:58:23 <lambdabot>   Not in scope: `fromSum'
19:58:30 <roconnor> @hoogle Sum
19:58:31 <lambdabot> Data.Monoid.Sum :: newtype Sum a
19:58:31 <lambdabot> Data.Monoid.Sum :: a -> Sum a
19:58:31 <lambdabot> Prelude.sum :: Num a => [a] -> a
19:58:33 <solrize> :t Data.Binary.Get Int
19:58:35 <lambdabot> Not in scope: data constructor `Data.Binary.Get'
19:58:35 <lambdabot> Not in scope: data constructor `Int'
19:58:41 <chessguy> > 1 `mappend` 2
19:58:42 <lambdabot>  Add a type signature
19:58:44 <roconnor> > runSum $ 1 `mappend` 2
19:58:45 <lambdabot>   Not in scope: `runSum'
19:58:47 <solrize> :import Data.Binary
19:59:01 <roconnor> > getSum $ 1 `mappend` 2
19:59:02 <chessguy> oh well, bed time
19:59:02 <lambdabot>   add an instance declaration for (Num (Sum a))
19:59:09 <roconnor> > getSum $ Sum 1 `mappend` Sum 2
19:59:10 <lambdabot>  3
20:00:03 <vininim> :t mappend
20:00:05 <lambdabot> forall a. (Monoid a) => a -> a -> a
20:00:16 <mmorrow> chessguy: so it'd be tricky to phrase in such a way that you could make an instance of Data.Monoid, but def can be done i'm sure
20:02:18 <Frederick> povman: I pay you if you manage bibtex to work on this crap :/
20:03:03 <povman> mine took about 6 seconds to set up... can i see your .bib file?
20:04:06 <Frederick> povman: http://pastey.net/89762
20:06:05 <mmorrow> chessguy: night
20:06:53 <Frederick> povman: ?
20:07:10 <povman> i don't have any problems with it
20:07:30 <povman> run latex on your tex file, then bibtex on the same, then latex, then latex
20:07:54 <povman> make sure you're actually putting \cite's around
20:08:24 <povman> otherwise it won't render anything because you haven't cited anything
20:14:54 <EvilTerran> ... does no-one see anything wrong with a toolchain in which "run x, then y, then x twice" is considered sane?
20:15:36 <bitrot> latex is a fetish, not something sane...
20:16:39 <nolrai_> @pl \a b -> do {a' <- f a; return $ g a b;}
20:16:40 <lambdabot> (line 1, column 12):
20:16:40 <lambdabot> unexpected "{"
20:16:40 <lambdabot> expecting variable, "(", operator or end of input
20:16:43 <EvilTerran> i think most of what i take issue with boils down to "tex is old"
20:16:45 <povman> EvilTerran: this is the same culture that produced autohell
20:16:46 <ddarius> EvilTerran: Who considers TeX sane?
20:17:06 <mrd> Knuth?
20:17:16 <nolrai_> @undo do {a' <- f a; return $ g a b;}
20:17:16 <lambdabot> f a >>= \ a' -> return $ g a b
20:17:21 <EvilTerran> more specifically, the run-several-times thing being entirely a relic of the days when processors were slower and RAM was smaller
20:17:26 <lament> isn't tex old?
20:17:40 <SamB> tex is older than I am isn't it?
20:17:40 <ddarius> EvilTerran: It was more RAM the processor speed.
20:17:42 <EvilTerran> lament, that's what i said, yes
20:17:47 <nolrai_> @pl \a b -> f a >>= \ a' -> return $ g a b
20:17:47 <lambdabot> ap ((.) . (>>=) . f) (((const . return) .) . g)
20:18:11 <EvilTerran> ...also, the whole design of the tex language itself is missing out on twenty years of programming language design theory
20:18:14 <povman> EvilTerran: i also dislike the syntax and feel it should be more lispy
20:18:19 <nolrai_> :t ap
20:18:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:18:25 <lament> EvilTerran: oh, i thought that's what you took issue with.
20:18:44 <povman> writing documents in sexps would be so much cooler
20:18:46 <EvilTerran> lament, that's only part of it. i take issue with lots of things. :P
20:20:37 <nolrai_> @undo do {a' <- f a; return $ g a' b;}
20:20:38 <lambdabot> f a >>= \ a' -> return $ g a' b
20:20:45 <nolrai_> @pl \a b -> f a >>= \ a' -> return $ g a' b
20:20:46 <lambdabot> flip (fmap . flip g) . f
20:21:29 <nolrai_> :t flip (fmap . flip g) . f
20:21:30 <lambdabot> forall a (f :: * -> *) a1 c (f1 :: * -> *). (Functor f1, SimpleReflect.FromExpr (f1 (f a)), SimpleReflect.FromExpr c, Show a1, Show a, Functor f) => f1 (a1 -> f c)
20:21:58 <nolrai_> :t \f -> flip (fmap . flip g) . f
20:22:00 <lambdabot> forall a (f :: * -> *) a1 c (f1 :: * -> *). (Functor f1, SimpleReflect.FromExpr c, Show a1, Show a, Functor f) => f1 (f a) -> f1 (a1 -> f c)
20:22:17 <EvilTerran> yuck
20:22:34 <EvilTerran> ?type \f g -> flip (fmap P.. flip g) P.. f
20:22:36 <lambdabot> forall a (f :: * -> *) a1 c a2. (Functor f) => (a2 -> f a) -> (a -> a1 -> c) -> a2 -> a1 -> f c
20:22:44 <ddarius> EvilTerran: It's missing out on quite a bit more than 20 years.
20:23:01 <pgavin> but tex was designed by the master :)
20:23:21 <EvilTerran> ddarius, well, the design was frozen in 1989, from my cursory research
20:23:24 <pgavin> and it's not the language that makes it as great as it is, it's the typesetting
20:23:49 <ddarius> EvilTerran: What could possibly make you think that it was utilizing programming language research current then?
20:23:55 <gwern> a pity network effects probably make it infeasible to redo
20:23:58 <EvilTerran> i figured i'd give someone so supposedly great as Knuth the benefit of the doubt and assume he kept up to date with programming language design theory when he was, er, designing a programming language
20:24:15 <ddarius> EvilTerran: You have looked at TeX right?
20:24:15 <pgavin> lol
20:24:16 <gwern> (kind of like how emacs still has no really modern replacement, I'd venture)
20:24:28 <pgavin> gwern: yi?
20:24:34 <EvilTerran> ddarius, i've looked at its fellow relics of the 1980s, too
20:24:37 <gwern> EvilTerran: hasn't knuth always been more about data structures and algorithms, not languages?
20:24:55 <pgavin> and math
20:24:57 <Frederick> povman: do i need to cite all the stuff so it appears on the bibliography?
20:25:06 <SamB> at least Emacs uses a ... somewhat reasonable language, you know?
20:25:07 <pgavin> he wrote the greatest discrete math textbook of all time :)
20:25:07 <EvilTerran> gwern, i guess so, but still... you're designing something, you read up on how one goes about doing so
20:25:09 <povman> indeed
20:25:15 <ddarius> EvilTerran: Smalltalk existed.  Many Haskell-like languages.  Many Lisps including CL and Scheme. Algol existed.  Hell, FORTRAN existed.
20:25:21 <gwern> pgavin: that can't be considered a useful replacement in any sense; if you do, you have to admit that there are many more usable modern editors
20:25:23 <povman> Frederick: maybe not
20:25:40 <EvilTerran> you wouldn't design a house without learning architecture, you shouldn't design a language without a bit of PL&tools theory, IMO
20:25:41 <mrd> he wrote it in literate pascal
20:25:51 <EvilTerran> ddarius, true. so did cobol and pascal.
20:25:52 <pgavin> gwern: agreed, it's still needs work :)
20:25:55 <mrd> can't say he was much of a language maven
20:26:00 <ddarius> EvilTerran: Both much cleaner than TeX
20:26:14 <EvilTerran> and MUMPS! >:]
20:26:22 <povman> Frederick: put \nocite{*} somewhere in your doc
20:26:27 <gwern> pgavin: ...yes, and the world trade center needs a bit of work too
20:26:52 <pgavin> gwern: lol, don't say that too loudly :)
20:26:52 <SamB> gwern: except the WTC has a good excuse
20:27:01 <EvilTerran> but, yes, i'd say all of those are quite possibly cleaner than TeX
20:27:08 <SamB> nobody crashed any airplanes into yi to make it this way
20:27:12 <povman> latex is actually really nice to write documents in, no matter how horrid the language is
20:27:17 <EvilTerran> i guess he figured he was only designing a typesetting language, not a "real" programming language
20:27:24 <pgavin> i'm with povman :)
20:27:43 <SamB> it is AMAZING what you can do with TeX
20:27:46 <lament> I think Knuth designed whatever he would like to use for writing his book in.
20:27:55 <pgavin> right, plus, tex is pretty easy to read considering what you can do with it
20:28:03 <SamB> given how entirely strange the language is
20:28:04 <EvilTerran> SamB, and using only the \#{} characters too! :P
20:28:14 <gwern> SamB: hee hee. no, the generally crappy dynamicism solutions are like planes divebombing into yi every half-year
20:28:34 <SamB> dynamicism solutions?
20:28:38 <pgavin> I need to start using yi so I can help make it better :)
20:28:40 <EvilTerran> lament, and i am frequently tempted to do the same
20:28:47 <gwern> (honestly, dynamicism in haskell is a really sad story. the lisps have it so much better than we do)
20:28:53 <SamB> gwern: but that's not terrorists, that's would-be contributors
20:28:53 <lament> EvilTerran: do it, and perhaps you'll become equally famous :)
20:29:11 <gwern> SamB: hs-plugins, ghc api... 9/10 of the breakage in yi comes from their problems
20:29:17 <pgavin> gwern: once dynlibs work, everything will be golden :)
20:29:32 <EvilTerran> there's a little voice in the back of my mind that's telling me to do so as a haskell EDSL. i keep telling it to go away, but it's remarkably persistent
20:29:37 <SamB> pgavin: if that's so, I expect they never will
20:29:41 <lament> can you do dynamic libraries with haskell + ffi?
20:29:52 <gwern> sure, that's what they said about ghc api! It'll solve all your dynamicism problems!
20:29:56 <pgavin> lament: dynamic haskell libs, or dynamic c libs?
20:30:05 <SamB> EvilTerran: honestly, I think I'd rather write a book using LaTeX than a Haskell EDSL
20:30:07 <EvilTerran> pgavin, dynaming EVERYTHING
20:30:20 <pgavin> well dynamic c libs always work fine
20:30:22 <EvilTerran> *dynamic
20:30:32 <lament> dynamic c wrappers around haskell libs, that you load into your haskell program and unwrap :)
20:30:34 <pgavin> dynamic hs libs dont work at all afaik
20:30:45 <SamB> hah
20:30:46 <pgavin> no pic yet
20:30:53 <EvilTerran> SamB, hehe. that's my rational opinion too, but, as i say, there's this one little voice of dissent...
20:31:00 <pgavin> aparently thats planned for 6.10
20:31:01 <gwern> pgavin: work on mac, I've heard
20:31:08 <SamB> EvilTerran: I say this because the syntax would be awful
20:31:09 <pgavin> gwern: ehh, I've tried
20:31:19 <pgavin> gwern: no luck here
20:31:34 <SamB> Haskell syntax is not made for writing documents in
20:31:37 <EvilTerran> SamB, indeed. i'd probably be rather more inclined to go for some kind of pseudo-lisp
20:32:07 <dolio> You'd have to use \ \ multi-line strings to make it sane.
20:32:09 <EvilTerran> barewords as... well, words, rather than variables
20:32:12 <lament> docbook!
20:32:15 <dolio> Unless you just rely on automatic word wrap.
20:32:15 <EvilTerran> or something
20:32:32 <pgavin> so I've decided for my research I'm going to try to design an stg machine in hardware :)
20:32:45 <EvilTerran> i guess '(...) wouldn't be so bad for prose
20:32:48 <pgavin> haskell on the bare metal!
20:32:55 <gwern> no no, do GRIN!
20:33:15 <mmorrow> pgavin: do it with lava, then we can run it on any fpga
20:33:29 <pgavin> lava?
20:33:32 <ddarius> pgavin: You wouldn't be the first
20:33:33 <mmorrow> pgavin: like the reduceron(2)
20:33:38 <Frederick> povman: it just gets the first reference on the bibliography
20:33:38 <SamB> pgavin: a ¬S¬T¬G machine, you mean?
20:33:39 <EvilTerran> is there room for strict typing in the typesetting world? 'cos i think there is...
20:33:47 <povman> er what
20:33:53 * mmorrow goes to get lava links
20:33:59 <povman> Frederick: it looked like there was only 1 anyway
20:34:21 <EvilTerran> although all that talk of "type(setting)" and "type(checking)" could get confusing
20:34:24 <pgavin> mmorrow: found it
20:34:26 <ddarius> EvilTerran: There's room for strict typing everywhere.
20:34:32 <SamB> mmorrow: what?
20:34:33 <lament> strict typesetting?
20:34:37 <pgavin> mmorrow: heh, I'm also working on an hdl
20:34:42 <SamB> since when does that let you use the reduceron on any FPGA?
20:34:52 <mmorrow> pgavin: http://www.cs.chalmers.se/~koen/Lava/
20:34:53 <povman> also it's nice how you can go \section{blah} without needing an end tag
20:34:53 <lambdabot> Title: The Lava Homepage
20:34:54 <SamB> lament: crazy
20:35:01 <EvilTerran> If strict typing doesn't work for you, you're not being strict enough!
20:35:02 <mmorrow> pgavin: heh, i was too slow. cool!
20:35:09 <SamB> lament: typesetting makes essential use of laziness
20:35:13 <pgavin> mmorrow: does lava use arrows?
20:35:32 <mmorrow> pgavin: i'm not sure as i've never actually written anything using it
20:35:37 <SamB> pgavin: which version?
20:35:51 <pgavin> SamB: which version of what?
20:35:54 <mmorrow> pgavin: but it's been on my todo list for months
20:35:55 <SamB> which is to say, I can't remember what all versions there have been of Lava
20:36:04 <pgavin> ah
20:36:10 <SamB> it could be that a version has used arrows for all I can remember
20:36:13 <pgavin> I'm working on an hdl using arrows & type families
20:36:21 <SamB> or maybe you will write one tomorrow
20:36:31 <pgavin> really low level though
20:36:39 <SamB> low level in what sense?
20:36:43 <mmorrow> pgavin: i have this xilinx fpga that hooks up to a gameboy advanced and you can program for the gba's arm cpu as well as put whatever on the fpga
20:36:58 <pgavin> mmorrow: that's awesome!
20:37:12 <mmorrow> pgavin: pretty sweet, yeah. i'll find *that* link
20:37:14 <SamB> I get really confused when trying to figure out if a Haskell-based HDL is low- or high- level sometimes ;-)
20:37:16 <pgavin> SamB: ehh, low level as in I'm coding latches & flipflops & adders :)
20:37:33 <mmorrow> but doing it with haskell of the highest level...
20:37:45 <pgavin> heh, yeah
20:37:46 <mmorrow> ironic
20:38:04 <pgavin> I wonder if I'm just wasting my time on it
20:38:22 <pgavin> but it's gonna work really well when it's done, I think
20:38:23 <SamB> it really seems like the lower-level the circuit design, the higher-level the Haskel you need to do it nicely ...
20:38:30 <pgavin> SamB: yes :)
20:38:39 <mmorrow> pgavin: http://www.charmedlabs.com/index.php?page=shop.product_details&flypage=shop.flypage&product_id=17&category_id=6&manufacturer_id=0&option=com_virtuemart&Itemid=43
20:38:41 <lambdabot> Title: CharmedLabs - 150K Xport 2.0 with SDRAM Devkit, http://tinyurl.com/5v2l3e
20:39:15 <mmorrow> SamB: totally, i agree
20:39:26 <pgavin> mmorrow: can you program the gba with that, then?
20:40:46 <mmorrow> pgavin: yeah, you put your program for the gba's arm in a partic place in mem on the fpga's package and the gba boots off of that
20:40:47 <SamB> what a peculiar pastebin
20:40:57 <SamB> it supports highlighting in only four languages
20:41:07 <SamB> Coq, Prolog, Haskell, and Ocaml...
20:41:30 <pgavin> mmorrow: since it's an fpga though you can code your own co-processor onto it, maybe do the kind of stuff they did on the old snes games
20:41:40 <dolio> That's all you need, really.
20:41:50 <SamB> http://thepastesiteat.endoftheinternet.org:8080/
20:42:06 <SamB> well, it's more than hpaste does I guess ;-)
20:42:27 <dolio> Less than the mythical hpastetwo.
20:42:30 <mmorrow> pgavin: totally! unfortunately it only has 150K gates, so you choice of procs is somewhat limited
20:42:44 <dolio> Whenever that happens.
20:43:00 <SamB> mmorrow: what? an FPGA which includes a GBA? huh?
20:43:06 <mmorrow> pgavin: they have a couple cpus on http://opencores.org/
20:43:08 <pgavin> mmorrow: well, if you're gonna use it as a coproc, it doesn't have to be turing complete :)
20:43:20 <mmorrow> pgavin: ah, *co*proc
20:43:33 <jdrake> My book says that 'ord', 'isAlpha', et al. are in the standard prelude, yet ghc doesn't seem to know about them. Is there something I have to do here?
20:43:38 <pgavin> SamB: see the link above
20:43:41 <SamB> oh, it's an FPGA that you run *on* your GBA
20:43:43 <SamB> or DS?
20:43:48 <pgavin> both, prolly
20:44:05 <pgavin> jdrake: your book might be old
20:44:11 <pgavin> jdrake: ord is in Data.Char
20:44:16 <pgavin> as is isalpha
20:44:22 <SamB> jdavis: import Data.Char
20:44:25 <jdrake> 'Programming in Haskell' is the book
20:44:31 <pgavin> but you can use fromEnum instead of org
20:44:34 <pgavin> *ord
20:44:40 <SamB> I like ord better
20:44:54 <pgavin> SamB: of course, but you don't have to import for fromEnum
20:44:56 <jdrake> What is the difference?
20:45:08 <pgavin> jdrake: nothing, really
20:45:16 <pgavin> i think fromEnum = ord for Char
20:45:23 <SamB> jdrake: ord has a more specific type is all
20:45:26 <jdrake> This book is from last year
20:45:29 <SamB> and a shorter name
20:45:33 <SamB> whoa
20:45:51 <SamB> it must have been out of date before printing
20:46:05 <jdrake> Well, this is just a caesar cipher I am writing :-) I wanted to write it before reading the section :-)
20:46:28 <EvilTerran> ?src Char fromEnum
20:46:28 <lambdabot> Source not found. Maybe you made a typo?
20:46:31 <EvilTerran> ?src ord
20:46:32 <lambdabot> Source not found. There are some things that I just don't know.
20:46:34 <EvilTerran> doodies
20:46:49 <mmorrow> SamB: gameboy advanced. the fpga's on an icb part of which has the gba cartridge connector, so you plug it in like a game, but it doesn't need the gba to function.
20:47:33 <jdrake> How many of you guys use lhs instead of hs?
20:47:41 <pgavin> not me :)
20:48:01 <pgavin> lhs is for blog posts :b
20:48:04 <jdrake> I rather like it
20:48:28 <pgavin> it's annoying for library code
20:48:50 <mmorrow> pgavin: if you haven't already, check out the reduceron (awesome!):
20:48:54 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/reduceron/
20:48:55 <lambdabot> Title: The Reduceron (Old)
20:48:58 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/reduceron2/
20:48:58 <lambdabot> Title: The Reduceron
20:49:19 <pgavin> damn, they beat me to it :)
20:49:24 <mmorrow> hehe
20:49:47 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Enum.html#(line315) <- whee
20:49:48 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6msavf
20:50:00 <ddarius> pgavin: Don't worry.  They were beat to it by quite a bit too.
20:50:05 <pgavin> mmorrow: I'll make it better though
20:50:20 <mmorrow> pgavin: it's far from able to support full haskell, so ...
20:50:24 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#ord <- and that
20:50:25 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yqjxlq
20:50:31 <mmorrow> pgavin: yeah, that's what i was gonna say
20:50:41 <pgavin> that's the kind of stuff I want to do
20:50:55 <pgavin> my advisors don't understand
20:50:57 <pgavin> :)
20:51:03 <mmorrow> pgavin: or just learn from their mistakes/successes and build your own from scratch
20:51:13 <pgavin> they think functional programming is just a religion
20:51:35 <pgavin> mmorrow: yeah, I'll probably end up doing it from scratch just for the learning process
20:51:53 <mmorrow> pgavin: that sounds like the best way to go
20:52:08 <Korollary> pgavin: which department is this?
20:52:37 <mmorrow> fpga's are t3h future
20:52:38 <pgavin> Korollary: CS, of course
20:52:46 <EvilTerran> anyway, according to the first of those links, the ghc libs at least define "instance Enum Char where toEnum = chr; fromEnum = ord"
20:52:51 <pgavin> mmorrow: I need to buy one
20:53:06 <Korollary> pgavin: You were talking about hardware. I was just checking whether it was Comp Engr
20:53:17 <pgavin> Korollary: ah, gotcha
20:53:24 <mmorrow> pgavin: do it. i wanna get more.
20:53:28 <pgavin> Korollary: I'm really only interested in the logic
20:53:39 <pgavin> mmorrow: any recommendations?
20:53:41 <mmorrow> pgavin: i've seen them on pci cards
20:53:45 <Korollary> pgavin: the logic of ..?
20:53:50 <mmorrow> pgavin: check out the xilinx site
20:54:00 <mmorrow> http://www.xilinx.com/
20:54:00 <lambdabot> Title: FPGA and CPLD Solutions from Xilinx, Inc.
20:54:05 <pgavin> Korollary: processors.... as opposed to layout, engineering, silicon, etc.
20:54:29 <pgavin> mmorrow: I'm not sure which model to get
20:54:38 <Korollary> pgavin: Ah. The logic is rather unimpressive. The whole thing is dictated by layout, engineering, manufacturing, etc.
20:55:22 <mmorrow> pgavin: me neither
20:55:22 <pgavin> Korollary: the logic is where all the magic happens!
20:56:07 <mmorrow> Korollary: it makes hardware programmable, possibly by itself at runtime.
20:56:56 <mmorrow> Korollary: it can be like "oh crap i need an ethernet interface" then generate one until it need something else in that space
20:57:12 <Korollary> mmorrow: I know. I am a former CE.
20:57:27 <mmorrow> Korollary: if that's not impressive, i'm stunned
20:57:29 <shapr> Consumer Electronics?
20:57:45 <pgavin> computer engineering prolly
21:01:36 <mmorrow> pgavin: i do know that i want one that can hold at least two average-sized cpu cores at once
21:02:26 <pgavin> mmorrow: I figure you'll need a big one for that
21:02:33 <pgavin> even for a small core
21:02:41 <pgavin> like the t1 or something
21:03:02 <pgavin> but, I'm not really sure
21:03:27 <pgavin> I've heard that the t1 runs on a xilinx something-or-other
21:08:16 <mmorrow> pgavin: yeah, it'd be cool though. what i really want is one mounted on a pci-e (or whatever formfactor wifi cards in new laptops are) so i can just stick it in my laptop
21:08:31 <mmorrow> pgavin: i dunno if those exist though
21:08:44 <pgavin> mmorrow: that's mini-pci
21:08:44 <mmorrow> pgavin: definitely on larger form factors: http://www.rave.com/military/FPGA.html
21:09:01 <pgavin> mmorrow: I don't think they make fpgas for mini-pci
21:09:01 <mmorrow> pgavin: cool
21:09:15 <mmorrow> pgavin: yeah, that's my suspicion as well
21:09:26 <pgavin> I want one that works over usb
21:09:31 <pgavin> under linux
21:09:44 <pgavin> cuz I wanna take it with me
21:10:10 <mmorrow> yeah, that'd be essential and as far as i can think the only other solution for using it frequently with a laptop
21:10:28 <mmorrow> (the other being mounted on a mini-pci)
21:11:00 <pgavin> I've seen them with usb ports... I don't think they're usb host ports though
21:12:35 <mmorrow> i guess as long as you can connect the usb pins to it, you can always implement whatever circuit is needed in the fpga itself
21:13:10 <pgavin> ya, I'm worried about programming it :)
21:14:27 <mmorrow> worry not: http://opencores.org/projects.cgi/web/usbhostslave/overview
21:14:37 <mmorrow> http://opencores.org/projects.cgi/web/usb/overview
21:14:55 <mmorrow> check out the project page: http://opencores.org/browse.cgi/by_category
21:16:06 <mmorrow> all the cores there are also either GPL or BSD*
21:16:48 <pgavin> wow thats a lot more cores than I thought they had :)
21:17:24 <mmorrow> yeah, me too. haven't looked there in a bit
21:18:10 <pgavin> wth is wishbone? I see that alot
21:18:49 <pgavin> ah, it's a bus of some sort
21:20:15 <mmorrow> it's some sort of opensourceish bus spec or something from what i understand
21:20:17 <jsnx> i'm trying to write a parser that has it's own type of error
21:20:34 <jsnx> GenParse Char () (Either MyError String)
21:20:46 <jsnx> i'm having trouble finding good exampls
21:20:59 <mmorrow> pgavin: http://opencores.org/projects.cgi/web/wishbone/wishbone
21:21:02 <pgavin> mmorrow: it's pretty annoying that an open-source site like that would require registration to download pdfs
21:21:19 <jsnx> the parser is built from an error and a parser that just makes strings
21:21:45 <jsnx> my problem is, i just get the usual kind of parse error, not a MyError, when there is an error
21:22:00 <pgavin> jsnx: I haven't used many parsers in haskell, which are you using?
21:22:11 <jsnx> parsec
21:22:46 <jsnx> basically, i want to 'catch' all parser errors and replace them with my errors
21:22:49 <EvilTerran> jsnx, so your parser should always "succeed" (as far as parsec can tell)?
21:22:56 <jsnx> EvilTerran: well, no
21:23:04 <EvilTerran> i mean, overall
21:23:09 <jsnx> yes
21:23:12 <jsnx> overall
21:23:19 <EvilTerran> within the parser, you want all errors to be caught and translated into not-a-parsec-errors
21:23:24 <jsnx> yes
21:23:28 <EvilTerran> i see
21:24:13 <hpaste>  jsnx pasted "parsec error overriding" at http://hpaste.org/8434
21:24:15 <EvilTerran> does your "MyError" need data from the errors?
21:24:20 <nolrai_> :t liftM fst .
21:24:22 <lambdabot> parse error (possibly incorrect indentation)
21:24:28 <nolrai_> :t (liftM fst .)
21:24:30 <lambdabot> forall a b (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f (m (a, b)) -> f (m a)
21:24:41 <jsnx> EvilTerran: right now, no -- but it might later
21:25:05 <nolrai_> :t (liftM fst ((.) :: a -> a))
21:25:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
21:25:07 <lambdabot>     In the second argument of `liftM', namely `((.) :: a -> a)'
21:25:11 <EvilTerran> "P.choice [ Right delim , return $ Left e ]" - isn't this just "Right delim P.<|> return (Left e)"?
21:25:16 <EvilTerran> (not that that typechecks)
21:25:26 <jsnx> yes, same
21:25:37 <jsnx> i might add more errors, though
21:25:46 <pgavin> nolrai_: (.) :: (a -> b) -> (b -> c) -> (a -> c)
21:25:56 <jsnx> i am biased toward choice
21:26:07 <EvilTerran> i don't think you can pull the error data out from within a parser. not sure, though
21:26:14 <nolrai_> pgavin: thanks
21:26:23 <jsnx> hm, damn
21:26:26 <jsnx> that's no good
21:26:32 <EvilTerran> you can use getPosition, mind
21:26:46 <nolrai_> :t (liftM fst ((.) :: (a -> b) -> (b -> c) -> (a -> c)))
21:26:48 <lambdabot>     Couldn't match expected type `(a, b)'
21:26:48 <lambdabot>            against inferred type `(b1 -> c) -> a1 -> c'
21:26:48 <lambdabot>       Expected type: (a1 -> b1) -> (a, b)
21:26:50 <jsnx> so, how would you handle this problem?
21:27:12 <jsnx> basically, i'm parsing some SQL, and when there is something wrong, I want one of my errors to show up.
21:27:53 <EvilTerran> fmap Right (delim :: GenParser tok st a) <|> fmap Left getPosition :: GenParser tok st (Either SourcePos a)
21:28:04 <nolrai_> jsnx: look at the suff on the errors in the parser docs im fairly shure you can extend their error types.
21:28:11 <EvilTerran> you may need to wrap that in a try
21:28:20 <EvilTerran> (to the left of the <|>, i mean)
21:28:52 <pgavin> nolrai_: what are you trying to do?
21:29:04 <pgavin> (.) is not a monad :)
21:29:16 <jsnx> nolrai_: sounds like OO to me :)
21:29:19 <mmorrow> pgavin: ugh, i hate registering for downloading things.
21:29:33 <pgavin> mmorrow: me too :)
21:29:34 <nolrai_> :t (liftM fst) --thanks pgavin
21:29:36 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a, b) -> m a
21:30:15 <nolrai_> jsnx: not really its kindof diferent, but same reasons.
21:30:54 <jsnx> is there an implicit try in <|> ?
21:31:32 <EvilTerran> definitely not, that's the point
21:32:39 <nolrai_> @pl \ a b -> liftM fst $ findDependsOnAndDependingOn a b
21:32:39 <lambdabot> (fmap fst .) . findDependsOnAndDependingOn
21:32:43 <EvilTerran> saves it having to track potentially vast quantities of backtracking data
21:33:07 <nolrai_> :t (fmap fst .)
21:33:09 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (f (a, b)) -> f1 (f a)
21:33:15 <jsnx> EvilTerran: so, this is odd, because it always consumes the input and fails
21:33:56 <jsnx> e.g. "parse error at (line 1, column30):\nunexpected end of input...)
21:33:59 <EvilTerran> jsnx, is there any particular reason you can't deal with the errors outside the parsec parser?
21:34:10 <jsnx> EvilTerran: i don't understand
21:34:22 <nolrai_> :t (fmap fst .) (\a b -> return (a, b))
21:34:23 <lambdabot> forall a t t1. (Monad ((,) a), Functor ((->) t), Functor ((->) t1)) => t -> t1 -> a
21:34:30 <jsnx> that's why i'm doing this
21:34:44 <jsnx> i want parsec to just throw the errors up to me to deal with later
21:34:48 <rwbarton> :t parse
21:34:49 <lambdabot> Not in scope: `parse'
21:34:56 <nolrai_> :t (fmap fst .) (f :: a -> b -> m (c, c) )
21:34:57 <lambdabot>     Could not deduce (SimpleReflect.FromExpr (m (c, c)),
21:34:57 <lambdabot>                       Show b,
21:34:57 <lambdabot>                       Show a)
21:35:06 <EvilTerran> as in, let the normal parsec errors propagate to the top of the parser, and then deal with them as they appear in the return value from runParser
21:35:11 <nolrai_> :t (fmap fst .) (fff :: a -> b -> m (c, c) )
21:35:13 <rwbarton> hmm.  parse returns a value of type Either, with Left foo representing an error
21:35:13 <lambdabot> Not in scope: `fff'
21:35:17 <EvilTerran> that's what they're there for :)
21:35:30 <nolrai_> :t (fmap fst .) (undefined :: a -> b -> m (c, c) )
21:35:32 <lambdabot> forall a a1 b. a1 -> b -> a
21:35:44 <rwbarton> It doesn't throw an exception or anything like that
21:36:18 <pgavin> nolrai_: (.) cannot ever be applied to fmap
21:36:27 <pgavin> for any function
21:36:37 <EvilTerran> ?type fmap fmap fmap fst
21:36:38 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) b1. (Functor f1, Functor f) => f (f1 (b, b1)) -> f (f1 b)
21:36:40 <jsnx> so, instead of detecting and marking the errors where they happen, i should wait for them and then what?
21:37:03 <jsnx> if i'm in the "WHERE" parser and there is a certain kind of failure then i know what it has to do with
21:37:09 <pgavin> (.) has kind * -> *
21:37:17 <jsnx> but if i've just got an error machine at the top...
21:37:25 <nolrai_> pgavin: so was the pl bad?
21:37:30 <jsnx> ...it's not clear how i retain appropriate context
21:37:53 <pgavin> well, look at the class fmap belongs to
21:38:02 <pgavin> e.g., Functor f
21:38:07 <nolrai_> jsnx: pass it in the error
21:38:11 <pgavin> (.) takes 2 arguments
21:38:18 <pgavin> so it can't be a functor
21:38:26 <nolrai_> @pl \ a b -> liftM fst $ findDependsOnAndDependingOn a b
21:38:27 <lambdabot> (fmap fst .) . findDependsOnAndDependingOn
21:38:48 <nolrai_> does ^^^ do what i whant?
21:38:49 <EvilTerran> jsnx, well, you can get information like the position of the error out of the return value from runParser, if it evaluates to Left (...)
21:39:28 <pgavin> nolrai_: :t findDepends... ?
21:39:39 <EvilTerran> jsnx, and parsec does its best to also provide helpful human-readable error messages, assisted by such things as <?> annotations
21:39:57 <jsnx> well, i really would like typeful error messages
21:39:58 <d00gs> so, i'm new to haskell and working on the scheme-interpreter tutorial. i don't understand why one of my approaches works and the other doesn't:  http://hpaste.org/8435 . probably some kind of syntax issue, but i'm confused....
21:40:08 <EvilTerran> pgavin, um, (.) doesn't have any kind, it's a value, not a type
21:40:34 <pgavin> well, it's type has kind * -> * -> *
21:40:43 <EvilTerran> ... its type has kind *
21:40:53 <EvilTerran> seeing as it's a type proper and all
21:40:58 <pgavin> err, ok, I'm confused :)
21:41:05 <pgavin> you're right
21:41:09 <EvilTerran> ?type (P..)
21:41:09 <jsnx> pgavin: you can't construct types with .
21:41:10 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:41:29 <EvilTerran> any expression and/or value will have a type of kind *, ie a type proper
21:41:47 <EvilTerran> however, Functor instances must have kind *->*
21:41:48 <pgavin> EvilTerran: yes, ok :)
21:41:50 <nolrai_> pgavin: it my function, that takes two values and returns a pair in a monad
21:42:00 <nolrai_> s/it/it's
21:42:25 <pgavin> so what are you trying to do? extract the first of the pair monadically?
21:42:31 <nolrai_> yes
21:42:36 <pgavin> liftM fst should do it
21:42:50 <jsnx> so, okay, maybe my way of handling errors in Parsec is not quite right
21:42:51 <EvilTerran> or, indeed, fmap fst
21:42:53 <pgavin> (liftM fst) $ return (a, b)
21:43:02 <EvilTerran> jsnx, it seems you're re-inventing the wheel somewhat, yes
21:43:13 <jsnx> however, i am having trouble finding any really good examples of how to handle finicky errors
21:43:15 <nolrai_> yeah just want it pointless
21:43:30 <jsnx> and that is my real problem
21:43:38 <Cale> d00gs: I think the first version is getting parsed in a way different from what you expected.
21:43:38 <pgavin> > (liftM fst) $ return (1, 2)
21:43:39 <lambdabot>   add an instance declaration for (Show (m a))
21:43:43 <rwbarton> d00gs: the first line starting with <|> is less indented than the do-block, so it parses as (do { ... }) <|> ...
21:44:00 <Cale> d00gs: try indenting the two lines starting with <|> so that they're more indented than the first try
21:44:02 <nolrai_> :t (liftM fst .) .
21:44:03 <lambdabot> parse error (possibly incorrect indentation)
21:44:05 <d00gs> oh...
21:44:07 <d00gs> okay
21:44:11 <d00gs> thanks
21:44:13 <nolrai_> :t ((liftM fst .) . )
21:44:15 <lambdabot> forall a b (m :: * -> *) (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, Monad m) => f1 (f (m (a, b))) -> f1 (f (m a))
21:44:25 <pgavin> nolrai_: do you know what (.) means?
21:44:28 <Cale> d00gs: because they're less indented than the block, the whole do-block is the first parameter to <|>
21:44:33 <nolrai_> @pl \ a b -> liftM fst $ findDependsOnAndDependingOn a b
21:44:34 <lambdabot> (fmap fst .) . findDependsOnAndDependingOn
21:44:46 <d00gs> Cale: gotcha. thanks
21:44:50 <nolrai_> yeah
21:45:23 <nolrai_> Im just trying to understand what @pl gave me.
21:45:57 <pgavin> nolrai_: seems pretty obfuscated :)
21:46:06 <EvilTerran> ?type fmap fmap fmap (fmap fst)
21:46:08 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (f2 (a, b))) -> f (f1 (f2 a))
21:46:21 <EvilTerran> ?type fmap fmap fmap (fmap fst) `asTypeOf` ((liftM fst .) .)
21:46:22 <pgavin> that kind of stuff is annoying, though
21:46:23 <lambdabot> forall (f :: * -> *) a b (m :: * -> *) (f1 :: * -> *). (Monad m, Functor m, Functor f1, Functor f) => f (f1 (m (a, b))) -> f (f1 (m a))
21:46:34 <nolrai_> Yeah, your right.
21:46:36 <pgavin> it defeats the purpose of abstraction
21:46:39 <EvilTerran> (excuse me, i have a tendency to go a little overboard with the fmapping)
21:46:45 <pgavin> lol
21:46:47 <EvilTerran> ?type fmap fmap (fmap fmap) fmap fmap fst
21:46:49 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b. (Functor f2, Functor f1, Functor f) => f (f1 (f2 (a, b))) -> f (f1 (f2 a))
21:46:54 <nolrai_> Im missing the forest for the trees
21:46:58 <pgavin> lol
21:47:25 <EvilTerran> ?type fmap fmap fmap fmap fmap fmap fmap fmap fst
21:47:27 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b. (Functor f2, Functor f1, Functor f) => f (f1 (f2 (a, b))) -> f (f1 (f2 a))
21:47:33 <EvilTerran> ok, i think i'm done
21:47:56 <pgavin> that's funny, 8 fmaps in a row and you only get 2 levels of type nesting
21:48:00 <nolrai_> :t ((.) . (.))
21:48:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
21:48:06 <EvilTerran> most of them work out to be (.)
21:48:33 <pgavin> ok, (.) never mentions Functor at all
21:48:45 <pgavin> why is ((.) . (.)) mention Functor
21:48:47 <Cale> :t (Prelude..)
21:48:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:48:51 <Cale> :t (.)
21:48:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:48:54 <geezusfreeek> pgavin: lambdabot is hacked up
21:48:58 <pgavin> ah
21:49:00 <Cale> lambdabot has a generalisation
21:49:14 <nolrai_> (.) === fmap, right?
21:49:18 <dons> lambdabot implements HasCale.
21:49:19 <Cale> nolrai_: yeah
21:49:21 <dons> a new dialect.
21:49:24 <bd_> nolrai_: only in lambdabot :)
21:49:24 <geezusfreeek> nolrai_: and liftM and liftA
21:49:32 <Cale> heh, if you call changing 3 definitions a dialect.
21:49:40 <pgavin> lol
21:49:40 <EvilTerran> ((liftM fst .) .)  ->  ((fmap fst `fmap`) `fmap`)  ->  fmap (fmap (fmap fst))  ->  (fmap . fmap) (fmap fst)  ->  fmap fmap fmap (fmap fst)  ->  ...
21:50:00 <dons> did you see byorgey (I think) added HasCale to the Real World #haskell page?
21:50:02 <bd_> :t fmap fmap fmap (fmap fst)
21:50:03 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (f2 (a, b))) -> f (f1 (f2 a))
21:50:08 <Cale> dons: oh?
21:50:19 <EvilTerran> pgavin, this is all because there's an instance Functor ((->) e)
21:50:25 <dons> yeah, "Which side of the fence are you on!? HasCale, yay or nay!"
21:50:30 <EvilTerran> pgavin, which makes perfect sense if you start reading (->) as Map
21:50:32 <pgavin> for the ((->)r) monad
21:50:38 <dons> dcoutts: nice gtk clock.
21:50:46 <EvilTerran> and then fmap works out to be (.)
21:50:52 <EvilTerran> by the type alone
21:50:54 <pgavin> ok, gotcha
21:51:05 <dons> mm, haskell+gtk , http://haskell.org/~duncan/gtk2hs/Clock.png
21:51:07 <pgavin> all this stuff should be unified
21:51:20 <Cale> dons: yeah that's been around for quite some time now
21:51:30 <Cale> Perhaps a year?
21:51:45 <Cale> Unless this is a new version...
21:51:54 <EvilTerran> given f = (e ->), you get (a -> b) -> f a -> f b = (a -> b) -> (e -> a) -> (e -> b)
21:51:58 <Cale> oh, there's a shadow on this one, that might be new.
21:52:01 <EvilTerran> ?. pl djinn (a -> b) -> (e -> a) -> (e -> b)
21:52:01 <lambdabot> f = (.)
21:52:16 <EvilTerran> ?bot
21:52:16 <lambdabot> :)
21:52:38 <pgavin> EvilTerran: ok, gotcha
21:53:03 <jsnx> okay, i can only think of dumb ways to do this error handling business
21:53:18 <jsnx> one way is, get the line number and column number and try to guess at the error
21:53:26 <dons> Cale, the clock stuff?
21:53:40 <jsnx> another is, stick some stuff in the parser state and pluck it out at error handling time
21:53:45 <EvilTerran> jsnx, if you wait for the next version of parsec, it'll be a monad transformer, so you'll be able to use ParserT Either :D
21:54:02 <jsnx> EvilTerran: there's an alpha out already though, right?
21:54:04 <Cale> dons: yeah
21:54:08 <dons> dcoutts added transparency today
21:54:14 <dons> previously it is drawn in a white box
21:54:15 <EvilTerran> if so, it will be an alpha, so you probably don't wanna use it
21:54:39 <dons> i made a standalone port of the app, and put it in Arch, which encouraged dcoutts to clean it up a bit
21:54:44 <Cale> ah
21:54:45 <dons> so we can all run hsclock now
21:55:01 <EvilTerran> jsnx, is line, column, and descriptive text from <?> annotations insufficient?
21:55:33 <nolrai_> "stick some stuff in the parser state and pluck it out at error handling" this sounds like it should work, just put in a Maybe MyError.
21:56:11 <jsnx> EvilTerran: text is no good, i need types
21:56:19 <EvilTerran> "types"?
21:56:28 <jsnx> like NotAFromStatement
21:56:40 <EvilTerran> oh, i see, you've got an enumeration of errors or something
21:56:43 <jsnx> InvalidColumn "@##$"
21:56:47 <jsnx> right
21:57:07 <EvilTerran> yeah, unfortunately GenParser lacks an "error type" parameter, so i think you're stuck with ugly hacks for the time being
21:57:10 <jsnx> really, i mean constructors
21:57:17 <jsnx> !!
21:57:20 <nolrai_> and then "throwMyError error = put (Just error) >> throwError "myError" or something
21:57:34 <EvilTerran> the state one looks most likely to work
21:58:24 <pgavin> my beer comes out like foam...
21:58:44 <EvilTerran> pgavin, which beer would that be?
21:59:07 <pgavin> homebrew, I kegged it about a week ago
21:59:12 <luqui> Hey, does anybody know a small turing complete basis for concatenative programming?
21:59:19 * EvilTerran has experience of hoegaarden coming out almost entirely head when he's not been paying attention
21:59:30 <dons> luqui: hmm. good question (congrats on the new job, btw!)
21:59:32 <EvilTerran> oh, very nice
21:59:36 <pgavin> hoegaarden rules!
21:59:41 <luqui> dons: thank you :-)
21:59:46 <magnus_> Hi, is there any way when profiling ghc code to see how much time is spent in various _library_ functions?
21:59:51 <dons> luqui: ask cdsmith
22:00:15 <dons> magnus_: yeah, you need to have compiled the libraries with -prof -auto-all
22:00:35 <EvilTerran> luqui, what springs to my mind is the SKI combinators and an "apply" primitive to use in RPN
22:00:43 <EvilTerran> (would that be concatenative?)
22:00:47 <magnus_> dons: aha, i'll see if i can get that to happen
22:01:09 <luqui> EvilTerran: good idea
22:01:19 <geezusfreeek> http://barker.linguistics.fas.nyu.edu/Stuff/Iota/
22:01:23 <EvilTerran> or the X combinator and an apply operation, if you're hardcore
22:01:32 <luqui> X combinator?
22:02:23 <psygnisfive> well, if youre gonna talk about iota and jot, you might as well come to #esoteric :P
22:02:23 <bos> @seen dcoutts
22:02:24 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 3h 24m ago.
22:02:45 <geezusfreeek> psygnisfive: ;)
22:02:56 <bos> dons: do you know if ghc-prof-options in a cabal file implies that -prof will be used when compiling?
22:02:57 <pgavin> I'm not sure why, but I'll pour a beer out of the keg, and the whole thing is foam :/
22:03:14 <magnus_> dons: i think i'll try a dirtier solution: wrap the functions I'm interested in :)
22:03:26 <dons> bos, it should only be used when -p is on
22:03:27 <EvilTerran> luqui, X = \x.((xS)K) - it's TC on its own :D
22:03:29 <pgavin> bos: I'm pretty sure you have to do ./setup configure -p
22:03:36 <nolrai_> :t map (filter ((==1) . snd))
22:03:38 <lambdabot> forall a b (f :: * -> *). (Functor f, Num b) => f [(a, b)] -> f [(a, b)]
22:04:01 <bos> right.
22:04:34 <luqui> EvilTerran: cool!
22:04:52 <bos> i'm just not seeing any of my library's entry points show up when i build an app with -prof -auto-all and "ghc-prof-options: -auto-all"
22:04:58 <bos> which makes me quite suspicious.
22:05:10 <geezusfreeek> @pl \x -> (x (\a b c -> a c (b c))) (\a b -> a)
22:05:10 <lambdabot> flip ($ ap) const
22:05:22 <dons> bos, hmm, i
22:05:31 <dons> 've always used ghc-prof-options: -prof -auto-all
22:05:32 <pgavin> bos: are you sure the library's being compiled with -prof?
22:06:02 <bos> i'd have expected it to be, but i didn't chjeck.
22:06:24 <geezusfreeek> :t flip ($ ap) const
22:06:26 <lambdabot> forall (m :: * -> *) a b c a1 b1. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> c) -> c
22:07:05 <bos> and now that i recompile and try again with both -prof and -auto-all in ghc-prof-options, still no joy.
22:07:43 <pgavin> afaik, *everything* needs to be compiled w/ -p
22:07:49 <dons> do you see the library compiled twice?
22:08:05 <pgavin> otherwise stuff might get inlined etc
22:08:10 <dons> once normally, and then again with profiled? and foo.o_p libs are installed?
22:08:19 <bos> dons: i'm building it with -v, and i don't see -auto-all being passed into the compiler when building with profiling.
22:08:29 <dons> hmm
22:08:30 <bos> when did ghc-prof-options appear in cabal?
22:08:40 <dons> last year sometime
22:08:46 <pgavin> try ./setup configure -p --ghc-options=-auto-all
22:08:54 <dons> 2 years ago
22:08:55 <dons> X11/X11.cabal:ghc-prof-options:   -prof -auto-all
22:08:55 <dons> icfp06-/icfp06.cabal:-- Add -prof -auto-all for profiling
22:09:08 <dons> xmonad/xmonad.cabal:    ghc-prof-options:   -prof -auto-all
22:09:49 <dons> actually, icfp06 uses ghc-options, so it was sometime between now and july 06.
22:09:51 <bos> dons: --ghc-options passes "-prof -auto-all" to the regular build too.
22:10:05 <jsnx> where is the latest ParserT ?
22:10:07 <dons> maybe this feature broke in the new release
22:10:21 <bos> cabal 1.2 is accepting the ghc-prof-options property, but apparently ignoring it.
22:10:34 <vixey`> @check \p q -> p*q /= 11929
22:10:45 <lambdabot>  OK, passed 500 tests.
22:10:55 <bos> ok, "GHC-Prof-Options: -prof -fuckme" is silently accepted :-p
22:11:06 * bos tries with cabal 1.4.
22:11:06 <vixey`> @check \p q -> p*q /= 899
22:11:08 <lambdabot>  OK, passed 500 tests.
22:11:13 <dons> bos, oh with 1.2.3?
22:11:13 <vixey`> :(
22:11:30 <bos> dons: whatever is bundled with ghc 6.8.3
22:11:38 <dons> ok. dodgy
22:12:21 <dons> > gcd 899 29
22:12:23 <lambdabot>  29
22:12:23 <bos> wow, hackage the slow.
22:12:30 <pgavin> vixey`: it's likely that if you select a prime > 10000 qcheck will fail that test
22:12:41 <vixey`> I tried in PM
22:12:41 <dons> only 1 more week till hackage gets a new host, fibre into the new office.
22:12:42 <vixey`>  <lambdabot>  Falsifiable, after 178 tests: -29, -31
22:12:44 <vixey`> :D
22:12:45 <dons> expect speeds
22:12:53 <bos> looking forward to the move?
22:12:59 <EvilTerran> @check (==)
22:13:00 <lambdabot>  OK, passed 500 tests.
22:13:06 <EvilTerran> :D
22:13:09 <dons> for sure. we have to pick out which pool table we liked  :)
22:13:12 <pgavin> @check (+)
22:13:13 <lambdabot>  Add a type signature
22:13:25 <pgavin> @check (+) :: Int -> Int -> Int
22:13:26 <lambdabot>   add an instance declaration for (Testable Int)     In the expression:,     ...
22:13:32 <EvilTerran> pgavin, @check expects a function that returns a Bool
22:13:34 <dons> an entire floor downtown, espresso plugged into the plumbing of the building. awesomeness. :)
22:13:42 <pgavin> ah
22:13:53 <bos> sounds nice :-)
22:13:55 <EvilTerran> @check (\x -> x^2 >= (x :: Int))
22:13:57 <lambdabot>  OK, passed 500 tests.
22:14:06 <EvilTerran> @check (\x -> x^2 >= (x :: Double))
22:14:07 <lambdabot>  Falsifiable, after 12 tests: 0.8333333333333334
22:14:09 <dons> bos, *so* web 2.0 startup :)
22:14:09 <bos> galois needs to open a san francisco office.
22:14:10 <pgavin> well, I have espresso in my house :)
22:14:11 <vixey`> @check \p q -> p*q /= 32
22:14:12 <dons> but with formal methods!
22:14:13 <lambdabot>  OK, passed 500 tests.
22:14:27 <vixey`> dons: oo
22:14:40 <dons> and you know, real customers. haha
22:14:51 <bos> dammit, my ghc-doc package doesn't contain any meaningful docs.
22:14:58 <bos> what did i break?
22:15:24 <EvilTerran> EVERYTHING
22:15:34 <SamB> dons: so they have hot and cold running espresso?
22:16:26 <nolrai_> > 0.8333333333333334 ^ 2
22:16:27 <lambdabot>  0.6944444444444445
22:16:30 <bos> ah, better: "ghc-6.8.3: unrecognised flags: -fuckme"
22:16:44 <nolrai_> > 0.5 ^ 2
22:16:45 <lambdabot>  0.25
22:16:59 <vixey`> @check \a b -> sqrt 2 = a%b
22:16:59 <lambdabot>  Parse error at "=" (column 16)
22:17:03 <vixey`> @check \a b -> sqrt 2 == a%b
22:17:03 <lambdabot>   add an instance declaration for (Floating (Ratio a))
22:17:08 <vixey`> @check \a b -> sqrt 2 == a/b
22:17:09 <lambdabot>  Falsifiable, after 0 tests: 0.6666666666666666, -0.6666666666666666
22:17:11 <bos> we need -fno-uckme
22:17:30 * EvilTerran is reminded of -ffi and -fffi being equivalent
22:17:34 <vixey`> ah
22:17:48 <vixey`> @check \a b -> sqrt 2 /= a/b -- a proof that sqrt 2 is irrational
22:17:49 <lambdabot>  OK, passed 500 tests.
22:17:53 <bos> ok, with "ghc-prof-options: -auto-all" and cabal 1.4, all is well.
22:18:44 <nolrai_> @check \a b -> sqrt 100 /= a/b -- a proof that sqrt 100 is irrational
22:18:45 <lambdabot>  OK, passed 500 tests.
22:18:53 <vixey`> lol
22:19:25 <vixey`> @check \x y "foobar" == x ++ y
22:19:25 <lambdabot>  Parse error at "==" (column 15)
22:19:30 <vixey`> @check \x y -> "foobar" == x ++ y
22:19:31 <lambdabot>  Falsifiable, after 0 tests: "", "\483736"
22:19:44 <nolrai_> ??
22:19:58 <EvilTerran> what a weird choice of first test
22:19:58 <nolrai_> OH
22:20:22 <vixey`> @check \x y -> "\483736" /= x ++ y
22:20:22 <lambdabot>  Character constant out of range at ""\483..." (column 9)
22:20:42 <nolrai_> eh?
22:21:17 <EvilTerran> surprisingly, there don't seem to quite be half a million unicode characters yet
22:21:46 <EvilTerran> i'm sure they're working on it
22:23:44 <jsnx> well, the UFOnauts definitely need the rest of the space
22:25:48 <EvilTerran> i doubt they have quite that many ideographs for "anal probe"
22:26:09 <EvilTerran> (sorry, that was needlessly crass. it's getting to be not-very-early in the morning over here)
22:27:11 <geezusfreeek> ?bot
22:27:12 <vixey`> @pl \x (y:ys) -> (x:y):ys
22:27:35 <vixey`> :t uncurry ($) . (head $$$ tail)
22:27:48 <roconnor> @seen lambdabot
22:27:50 <geezusfreeek> dead
22:27:57 <roconnor> stupid haskell
22:28:02 <EvilTerran> i blame geezusfreeek!
22:28:07 <geezusfreeek> me too
22:28:23 <geezusfreeek> hax
22:28:27 <vixey`> how about this?
22:28:27 <vixey`> group [] = []
22:28:27 <vixey`> group [x] = [x]
22:28:27 <vixey`> group (x:y:ys) = if x == y then headCons x (group (y:ys))
22:28:27 <vixey`>                            else [x] : group (y:ys)
22:28:27 <vixey`>  where headCons x (y:ys) = (x:y):ys
22:29:00 <vixey`> oopls group [x] = [[x]]
22:29:47 <EvilTerran> what about it?
22:36:41 <vininim> mmm what hackage libraries do you guys suggest for web information retrieval? Mostly parsing semi-structured html and some crawling.
22:37:25 <luqui> what's the name of ndm's html library?  It was designed to do the former, IIRC
22:38:01 <mrd> tagsoup
22:39:56 <nolrai_> ?bot
22:40:04 <nolrai_> dang
22:42:13 <mrd> @botsnack
22:42:13 <quicksilver> tagsoup is definitely your best bet for non-validating docs
22:49:32 <hpaste>  solrize pasted "monad transformer?" at http://hpaste.org/8436
22:49:51 <solrize> oh hi quicksilver :)
22:51:11 <luqui> solrize: I don't claim to grok your code, but it looks like the "return" in condGet is superfluous
22:51:35 <solrize> it is?  the outer monad doesn't necessarily have mzero
22:51:52 <luqui> see, thus the not grokking.  what outer monad?
22:51:56 <luqui> or rather, what inner monad?
22:52:10 <solrize> the result of condGet is two nested monads
22:52:18 <solrize> i.e. something like   Get (Maybe a)
22:52:20 <luqui> yes I see, but why?
22:52:23 <luqui> oh I see
22:52:43 <solrize> i have a binary file which uses -1 as a sentinel value for some fields
22:52:58 <solrize> i.e. read some value only if the previous value is not -1
22:53:49 <solrize> and i'm wondering if i have to write something like GetT
22:53:58 <SamB> ???
22:54:17 <solrize> to lift the action into it ?
22:54:18 * luqui doesn't think so...  thinkinga bout it
22:54:49 <rwbarton> it seems the type of condGet should be a -> t b -> t (m b)
22:54:56 <rwbarton> at least, that's how you use it
22:55:01 <solrize> hmm
22:55:04 <luqui> agreed
22:55:32 <solrize> you're right, i musta got confused
22:56:06 <bos> oh ghc, why must you do so much unnecessary unboxing and reboxing?
22:56:27 <luqui> of course, any monadic function that just immediately returns something is a red flag... shouldn't be in a monad
22:57:16 <solrize> hmm
22:57:20 <luqui> condGet n action = if n == -1 then return mzero else return <$> action -- seems better
22:57:52 <luqui> oh wait
22:57:54 * luqui is silly
22:57:57 <solrize> that doesn't look right
22:58:16 <solrize> there's no such thing as when/else unfortunately
22:58:37 <luqui> ?type \n action -> if n == -1 then return mzero else return <$> action
22:58:44 <luqui> daft no bot!
22:58:53 <SamB_XP_> is that like a no tv?
22:58:55 <solrize> i.e.   when n==-1 mzero;  when n /= -1 action   might be ok but is ugly
22:59:07 <EvilTerran> solrize, Get (Maybe a) would be isomorphic to MaybeT Get a, not GetT Maybe a
22:59:14 <SamB_XP_> solrize: that isn't possible
22:59:42 <SamB_XP_> when :: Monad m => Bool -> m () -> m ()
22:59:51 <SamB_XP_> (from memory)
22:59:55 <bos> wow, this surprises me. an explicit counting loop is more efficient than a list comprehension?
23:00:04 <Saizan> solrize: when n == -1 you want to abort the rest of the parsing or not?
23:00:06 <solrize> evilterran, hmm, quicksilver yesterday gave me an expression that i forgot, that used MaybeT, but i'm trying to do this more generally so it handles both List and Maybe (and also possibloy Error)
23:00:09 <EvilTerran> bos, are you compiling with -O2?
23:00:13 <bos> EvilTerran: yes.
23:00:19 <solrize> saizan i don't want to abort the parsing, i just want to skip the next field
23:00:20 <EvilTerran> how peculiar
23:00:45 <SamB_XP_> bos: well, streams haven't landed in base yet...
23:00:56 <EvilTerran> when p m = if p then m else return (), iirc
23:00:57 <solrize> i.e. for the list case, there's a number n, followed by an n-element vector.  but n=-1 is treated as an empty vector
23:01:01 <luqui> solrize, I think mine is correct
23:01:04 <geezusfreeek> ?bot
23:01:33 <solrize> return <$> action  =   liftM return action        hmm
23:01:39 <EvilTerran> do { ...; unless (n == -1) parseNextField; ... }
23:01:54 <Saizan> solrize: so mzero is not really appropriate
23:01:56 <luqui> solrize: just substitute: Just -> return, Nothing -> mzero
23:02:07 * luqui would personally just use Maybe
23:02:13 <luqui> for current popular reasons
23:02:52 <solrize> luqui, the point is the first place condGet is used, it is supposed to create a Maybe (for an optional field) but in the second place where it's used, it's supposed to create a list
23:03:09 <luqui> where that list will be a singleton or empty?
23:03:11 <solrize> so condGet is supposed to be polymorphic over those monads
23:03:16 <solrize> no the list can have arbitrary size
23:03:22 <solrize> that's why the replicateM is there
23:03:48 <EvilTerran> solrize, that's deeply arcane, i must say
23:04:02 <solrize> it is?  i thought i was getting into the haskell spirit :)
23:04:19 <luqui> yes, you are overgeneralizing well :-)
23:04:27 <solrize> hehe
23:04:28 <rwbarton> solrize: in that case you need to modify condGet to have type a -> t (m b) -> t (m b)
23:04:48 <solrize> hmm
23:05:08 <solrize> i can't just pass in an action and rely on the lazy evaluation?
23:05:09 <rwbarton> It can't both produce a Just out of thin air, and also produce a list that's not of length 1
23:05:13 * luqui sees no problem with Maybe
23:05:33 <solrize> the return doesn't create a Just once type inference figures out that the result is supposed to be a Maybe?
23:05:58 <luqui> ngs <- fromJust [] <$> (condGet nf $ replicateM (fromIntegral nf) L.get)
23:06:01 <luqui> or something
23:06:05 <EvilTerran> well, that's not so much laziness as ad-hoc polymorphism
23:06:14 <hpaste>  solrize annotated "monad transformer?" with "add datatype definition" at http://hpaste.org/8436#a1
23:06:18 <luqui> sorry fromMaybe
23:06:18 <rwbarton> The way it is now, the first usage will work great, but the second one can't be made to also work.
23:07:07 <Saizan> solrize: it could, but look at the actions that you pass to condGet, one is simply (Get a) the other is (Get [a]), and you want Get (Maybe a) for the first, and Get [a] for the second, where's the general scheme?
23:07:11 <solrize> ngs isn't supposed to be a maybe, it's a list
23:07:25 <luqui> solrize: yes, thus fromMaybe
23:07:29 <EvilTerran> Saizan, MPTCs! ;)
23:07:43 <luqui> oh you weren't responding to me
23:08:23 <rwbarton> Look at the top version: Nothing corresponds to [], but there's nothing corresponding to Just in the replicateM line.
23:08:34 <rwbarton> (The thing that should correspond to Just is \x -> [x])
23:09:10 <solrize> there's nothing corresponding to Just because replicateM already creates a list
23:09:58 <EvilTerran> ?type (:[ {-om nom nom-} ])
23:10:12 <EvilTerran> bah, no bot
23:10:17 <idnar> heh
23:10:18 <solrize> eh?  some TH thing?
23:10:25 <EvilTerran> nope
23:10:28 <luqui> just a comment
23:10:36 <solrize> :[]
23:10:36 <EvilTerran> just (: []) with a comment in between the []s
23:10:38 <luqui> (:[]) :: a -> [a]
23:10:42 <Saizan> solrize: exactly, so the types in the two cases don't match
23:10:44 <solrize> oh
23:11:07 <luqui> but it's cute anyway
23:11:53 <solrize> saizan, hmm
23:11:54 <Saizan> i'd write condGet n act = if n == -1 then return mzero else action, and use (fmap Just L.get) for the Maybe case
23:12:17 * luqui would just use Maybe, and forget MonadPlus!! :-)
23:12:23 <EvilTerran> that condGet is just unless.(-1==), unless i'm mistaken
23:12:43 <solrize> :t unless
23:12:45 <solrize> no bot
23:12:48 <luqui> lol
23:12:49 <solrize> lemme try that
23:12:52 <EvilTerran> sorry, guard.(-1/=)
23:13:09 <Saizan> guard uses mzero, not return mzero
23:13:13 <solrize> doesn't that stop the whole parse if the guard fails?
23:13:17 <EvilTerran> when, unless :: Monad m => Bool -> m () -> m ()
23:13:21 <Saizan> luqui: ngs is not a singleton list
23:13:35 <EvilTerran> "guard b is return () if b is True, and mzero if b is False."
23:13:40 <luqui> Saizan, and?
23:14:00 <luqui> my suggestion has always been:  ngs <- fromMaybe [] <$> (condGet nf $ ...)
23:14:20 <solrize> i had this discussion with quicksilver before, guard wasn't quite right, it ended up needing a guard inside runMaybeT for the first one
23:14:54 <Saizan> yeah, guard doesn't work, Get is not even MonadPlus for obvious reasons
23:15:10 <EvilTerran> lift guard?
23:16:01 * sjanssen wishes Get was in MonadPlus
23:16:10 <luqui> sjanssen: how would it be?
23:16:23 <sjanssen> luqui: take Parsec, for example
23:16:24 <Saizan> EvilTerran: Get is not MonadTrans either :)
23:16:33 <luqui> ah yes
23:16:41 <EvilTerran> (amusingly, "lift guard" is also a type of worker at hotels etc)
23:16:59 <sjanssen> but Get is lazy, meaning that MonadPlus is out of the question (as I understand it)
23:17:04 <EvilTerran> (well, it amused me)
23:17:19 <roconnor> @hoogle Get
23:17:30 <roconnor> oh right
23:17:36 <luqui> sjanssen: yes that makes sense
23:17:38 <roconnor> lambdabot is written in Haskell
23:17:44 * dolio is totally baffled.
23:17:44 <luqui> wait...
23:17:53 <luqui> that depends
23:17:55 <Saizan> Get is just a State monad right now
23:18:04 * roconnor rewrite lambdabot in Erlang
23:18:23 * povman stabs roconnor in face with erlang
23:18:56 <vixey`> lol
23:19:03 <vixey`> why doesn't someone rewrite lambdabot?
23:19:19 <bitrot> hmm..would that be one stabbing, or myriad concurrent stabbings?
23:19:27 <roconnor> Jesus FUCK my EYE CHRIST!
23:19:41 <sjanssen> vixey`: okay, you rewrite lambdabot
23:19:41 <jsnx> >:3
23:19:47 <sjanssen> vixey`: you have one week, GO!
23:19:54 <roconnor> shhh
23:19:58 <jsnx> rewrite in C, plz
23:20:03 <roconnor> is it the new ICFP contest
23:20:06 <sjanssen> roconnor: also, you're on the rewrite team
23:20:11 <jsnx> kthxbye
23:20:13 <sjanssen> roconnor: YES! THIS IS A GREAT IDEA!
23:20:13 <povman> why do people want to rewrite lb?
23:20:15 <vixey`> what is the new ICFP?
23:20:25 <sjanssen> povman: lambdabot isn't very stable, and is very crufty
23:20:30 <^Someone^> vixey`, please make one that would work on windows
23:20:32 <solrize>     Occurs check: cannot construct the infinite type: b = m b
23:20:32 <solrize>     When generalising the type(s) for `condGet'
23:20:33 <roconnor> it is the (new (ICFP contest))
23:20:34 <vixey`> > 1+1
23:20:45 <povman> it must use unsafePerformIO then.
23:20:45 <vixey`> povman: observe...
23:20:49 <roconnor> sjanssen: and very old
23:21:07 <vixey`> ^Someone^: Does mueval work on windows?
23:21:09 <^Someone^> trying to get lambdabot to work on windows - that's all I've been doing these past few days
23:21:14 <solrize> rewrite with gadt's, that will avoid all bugs.  it worked for darcs... :)
23:21:15 <jsnx> it amuses me to no end that so many haskell things do not work on windows
23:21:16 <sjanssen> mueval is broken :(
23:21:30 <jsnx> i bet you simonpj does not even have windows in his lab
23:21:33 <roconnor> jsnx: must be window's fault. :P
23:21:34 <vixey`> solrize: I was thinking of writing a bot in idris
23:21:37 <dons> jsnx: simonpj uses windows.
23:21:44 <^Someone^> Hmm Dependencies	base, directory, hint (>=0.2.1), mtl, show, unix
23:21:51 <^Someone^> So I guess not
23:21:51 <sjanssen> vixey`, ^Someone^: muveal current has a posix dependency (to limit memory and CPU)
23:21:53 <jsnx> roconnor: well, no -- it's weird because m$ research pays for GHC
23:22:08 <dons> why do people always try to build lambdabot locally?
23:22:08 <jsnx> dons: hmm
23:22:09 <vixey`> ^Someone^: well... if you can write a windows replacement of mueval...
23:22:10 <dolio> I hope GHC has better intuition about when to apply the static argument transform than I do.
23:22:24 <vixey`> dons: the tools are really really good
23:22:25 <jsnx> okay, well, that was tangential
23:22:28 <dons> it was never designed for that. it is a build once program, using a compilation of obsolete techniques developed in the late 90s.
23:22:32 <^Someone^> Or a windows replacement for the unix library
23:22:35 <sjanssen> but, as I said, mueval is broken.  Try mueval -e "Foreign.unsafePerformIO (readFile \"/etc/passwd\")"
23:22:36 <solrize> what's idris?  there was an old unix-like OS with that name
23:22:36 <vixey`> dons: they should really be put into GHCi
23:22:57 <sjanssen> dons: that is begging to be @quoted :)
23:22:59 <vixey`> solrize: http://www.google.com/search?client=safari&rls=en-us&q=idris+edwinb&ie=UTF-8&oe=UTF-8
23:23:10 <dons> sjanssen: what happens? (and why don't people just use runplugs?!)
23:23:10 <vixey`> oops
23:23:13 <vixey`> solrize: sorry meant this, http://edwinb.wordpress.com/2008/03/09/idris-a-language-with-dependent-types/
23:23:14 <^Someone^> unix is supposed to be installable under cygwin, it just doesn't seem to be working for me
23:23:27 <jsnx> dons: it's still funny that GHC comes out of m$ research and so much of the stuff that's built with it does not work on windows
23:23:45 <dons> jsnx: people write stuff that uses the unix package, ah well.
23:23:49 <sjanssen> dons: mueval allows non-imported modules implicitly (just like ghci, which allows unsafe imports like unsafePerformIO)
23:23:58 <dons> i'd wager the vast majority of hackage is entirely windows friendly though
23:24:04 <jsnx> hmm
23:24:27 <dons> sjanssen: that's stupid. didn't we solve this all years ago? there's even a web page about what you have to do to make haskell eval safe
23:24:31 <solrize> argggh that snap popup is annoying
23:24:45 <sjanssen> dons: using GHC's API seems like a good idea on the face of things -- it makes sense to use the library maintained by the GHC guys, rather than expecting you (or anyone else) to update haskell-plugins for every ghc release
23:24:54 <dons> yeah, use the loader and .hi file chaser
23:24:58 <dons> don't use the evaluator.
23:25:19 <sjanssen> mueval is pretty good except for the module issue -- hopefully that is fixable
23:25:47 <dons> i'd imagine it'd be possible to write a very light hs-plugins-alike over hint
23:26:02 <dons> since all the code's in ghc already. it is just glue that's needed
23:28:00 <ivanm> is lambdabot dead again?
23:28:04 <ivanm> @bot
23:28:09 <sjanssen> yes
23:28:12 <ivanm> :(
23:28:17 <dons> if we hosted it on a non-shared machine, a lot of this would go away
23:28:26 <sjanssen> dons: what is going wrong?
23:28:28 <dons> i wonder if i can term it as root, hmm
23:28:28 <ivanm> oh?
23:28:28 <shachaf> Is Cale still running lambdabot?
23:28:51 <sjanssen> shachaf: Cale@community.haskell.org, to be specific
23:30:17 <dons> hehe
23:30:18 <dons> ?yow
23:30:24 <lambdabot> Couldn't find fortune file
23:30:28 <dons> root ftw!
23:30:31 <sjanssen> oh noes!
23:30:38 <dons> ?uptime
23:30:43 <lambdabot> uptime: 30s, longest uptime: 1m 10d 23h 44m 29s
23:30:46 <dons> ok, let's fine a fortune file
23:30:48 <sjanssen> dons: is lambdabot running out of memory?  How does being root help?
23:30:59 <dons> sjanssen: cale maintains it, it is his process on code.haskell.org
23:31:08 <dons> i've root though, so can throw signals at lambdabot till it resets
23:31:15 <sjanssen> ah, makes sense
23:31:40 <dons> > map (^2) [1..]
23:31:48 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
23:31:58 <sjanssen> dons: perhaps it would be a good idea to create a lambdabot user on c.h.o?
23:32:12 <dons> yeah, i used to do that on lambdabot's dedicated box.
23:32:23 <sjanssen> we can pass out SSH access to that account to a handful of people that tend to be on IRC frequently
23:32:25 * dons pines for the days of monthly uptimes
23:40:05 <solrize> does anyone use wordpress and know how to turn off those dang popups?
23:42:15 <^Someone^> What is this GNUreadline?
23:43:07 <ivanm> solrize: use a browser that blocks popus?
23:48:10 <solrize> ivanm, popup blocking doesn't stop those things.  i turned off javascript and that took care of it
23:49:01 <ivanm> ahhhh
23:49:15 <solrize> seems a bit brutal though
23:49:24 <ivanm> hmmm.... is there a guide anywhere on how to use code.haskell.org properly?
23:50:44 <curry> I have a datatype data Container a = Filled a | Empty, is there a way to specify that a must have an instance of show?
23:54:17 <jsnx> (Show a) => ...
23:55:27 <jsnx> data (Show a) => Container a = Filled a | Empty
23:56:03 <solrize> vixey, did you look at any of the hume stuff?  that's really interesting
23:56:43 <vixey`> I have looked over it a while ago
23:56:47 <curry> jsnx: ah thanks didnt know you could put that there
23:59:16 <povman> jsnx: isn't that generally not very useful?
23:59:57 <povman> i.e. you still have to put (Show a) => on all functions that use Container
