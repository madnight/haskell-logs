00:05:55 * ilyak_ have got a book on haskell which has interesting language: some phrases are not quite correct, as in, I don't really sure you can write sentences that way.
00:06:18 <ilyak_> After some thinking I've got a conclusion that author have some trouble writing in a such weak-typed language :)
00:06:58 <QtPlatypus> ilyak_: What is the book?
00:07:37 <ilyak_> QtPlatypus: I don't remember the title, it's in Russian tho
00:19:36 <jsnx> say i have a two paramter type class, C a b
00:19:49 <jsnx> and it has functions f and g
00:20:01 <jsnx> i'd like to 'partially specialize' g
00:20:32 <jsnx> instance C String (forall b . b) where g = lines f
00:20:46 <jsnx> w
00:20:50 <jsnx> ack
00:21:42 <jsnx> do we do partial specialization, or is there another way to get this kind of effect?
00:27:32 <sheyll> hi
00:28:52 <sheyll> when using System.Process.runInteractiveCommand I am not really able to send input to the process stdin...
00:29:58 <mxc> hi
00:30:07 <hpaste>  sheyll pasted "runInteractiveCommand" at http://hpaste.org/8116
00:30:19 <jsnx> hi
00:30:27 <sheyll> hi
00:30:41 <mxc> flushing issue?
00:30:46 <sheyll> ahhh
00:30:55 <TSC> Is there any documentation on Monad.Prompt?
00:30:56 <sheyll> I will try...
00:31:17 <mxc> not sure, but maybe an hFlush inp cld help?
00:31:31 <mxc> or along the same time, turn of buffering
00:32:07 <sheyll> mxc thanx alot that helped !!
00:32:31 <mxc> woohoo
00:32:33 <mxc> no problem
00:34:50 <augur> i imagine that with list comprehensions it would be possible to do some classical constraint based programming wouldn't it?
00:35:52 <augur> i mean, the wiki example of constraints in prolog could easily be translated into a listcomp i think, right?
00:36:05 <ddarius> Using list comprehensions would correspond to a naive generate and test approach.
00:36:16 <chid> I'm on windows, and I have a simple question, is there any "shortcut" to paste the clipboard without right-clicking and paste?
00:36:21 <augur> oh? im not sure how list comps work in haskell.
00:36:25 <augur> how they're evaluated and such
00:36:33 <chid> Also, is it possible to copy this output.. into the clipboard.
00:37:16 <mxc> chid - not sure if this is the right place, but i think control-V should do it
00:37:54 <ddarius> augur: Except for the order of evaluation (which has significant impact) they roughly have the same characteristics as the nested for-loops they look like.
00:37:59 <chid> No, it returns a ^V in the cmd.
00:38:23 <chid> Well, i am trying to use ghci, isn't it the right place =)
00:38:30 <mxc> oh ok
00:38:42 <mxc> well thats an issue with cmd.exe being a royal piece of sh1t
00:38:51 <jsnx> chid: how to use your terminal is maybe not your business
00:38:59 <jsnx> not our*
00:38:59 <mxc> i know what you mean, pisses me off too
00:39:07 <ddarius> [(x,y) | x <- xs, y <- ys] is roughly the same as (in an imperative language) foreach(x in xs) { foreach(y in ys) { yield (x,y); } }
00:39:13 <augur> ok. so in something like, say, taking the N-ary cartesian product of M number of values, the comps would have O(M^N) time complexity, etc?
00:39:27 <chid> Jsnx, yeah, but I was thinking there might be some "fix" to get around that..
00:39:30 <chid> oops
00:39:32 <augur> assuming full expansion of the list, i mean
00:39:52 <FordCortina_> chid: there is an alternative console program called console2 on sourceforge
00:40:09 <chid> FordCortina_, thanks
00:40:18 <FordCortina_> chid: to shortcut for paste is cntrl-insert
00:40:27 <FordCortina_> in that program
00:40:46 <chid> oh, cool, thanks
00:41:50 <jsnx> chid: you can also get moka5, to install a virtual linux desktop
00:41:56 <jsnx> then you can use bash
00:42:01 <jsnx> and gnome-terminal
00:42:10 <jsnx> or xterm or whatever you like
00:42:22 <jsnx> without having to actually install linux the hard way
00:43:01 <chid> nice, thanks as well
00:43:04 <mxc> jsnx - how does moka compare to cygwin?
00:43:25 <jsnx> moka5 is a very easy virtualization toolkit
00:43:43 <jsnx> so it is actually linux, any flavor you want -- gentoo, ubuntu -- with all the packages
00:43:44 <augur> moka??
00:43:49 <jsnx> moka5
00:44:08 <jsnx> also, bsd, beos, all that stuff
00:44:15 <augur> what is moka5?
00:44:20 <augur> and why is it named moka
00:44:26 <jsnx> @google moka5
00:44:28 <lambdabot> http://www.mokafive.com/
00:44:28 <lambdabot> Title: Desktop Virtualization Solutions - Work from Anywhere with MokaFive LivePCs
00:44:38 <augur> >.<
00:44:56 <jsnx> augur: i am not your librarian
00:45:08 <augur> no its not that
00:45:15 <jsnx> and i have no idea why it's called that
00:45:20 <chid> !google moka5 linux
00:45:24 <augur> i need sleep
00:45:25 <augur> night guys
00:45:40 <jsnx> @google moka5 linux
00:45:41 <lambdabot> No Result Found.
00:45:55 <jsnx> chid: go to their site, they have lots of linux
00:46:08 <jsnx> i have no idea what is up with lambdabot's googlin'
00:47:18 <chid> lol. ok
00:48:33 <jsnx> http://lab.mokafive.com/List
00:48:34 <lambdabot> Title: The Lab - MokaFive
00:48:44 <chid> lol..
00:50:56 <jsnx> i do not understand the LOL
00:51:00 <jsnx> chid: what is funny?
00:51:25 <augur> a better question is
00:51:30 <augur> what is love?
00:52:14 <chid> no, I was just wondering about the bot script
00:52:23 <jsnx> wow, something is not right with this channel
00:52:48 <MyCatVerbs> cjb: hrmn? The WhyFP paper? I've read it, but I can't recall the content now.
00:52:53 <chid> http://whatismyip.com.au/
00:52:56 <lambdabot> Title: What is my IP address? Your ip address is Unknown ; By DomainHost.com.au
00:52:57 <chid> say I do that..
00:53:04 <chid> lol..
00:53:09 <cybereal> augur: baby don't hurt me
00:53:39 <chid> <title>What is my IP address? Your ip address is 220.237.4.102 ; By DomainHost.com.au</title> this is what it should be..
00:54:08 <jsnx> admins, help! please kickban these people
00:54:11 <jsnx> !!
00:54:34 <chid> me?
00:54:43 <jsnx> no
00:55:38 <chid> I just thought it was a laughable bot script
01:05:42 <opqdonut> hey have you seen this: http://apocalisp.wordpress.com/2008/06/04/throwing-away-throws/
01:05:43 <lambdabot> Title: Lazy Error Handling in Java, Part 3: Throwing Away Throws « Apocalisp
01:05:54 <opqdonut> "In fact, Java is one big monad with bells on."
01:05:55 <chid> With http://www.haskell.org/haskellwiki/Euler_problems/1_to_10 , how do I get those to "work"?
01:05:58 <lambdabot> Title: Euler problems/1 to 10 - HaskellWiki
01:06:17 <dibblego> opqdonut, yes
01:27:28 <mxc> is there a good, pure data structure which is like a list or array but with constant update time?  (update as in return a new collection with one of the elements updated)
01:27:46 <mxc> or is the log (n) update of Data.Map the closest
01:29:12 <BeelsebobWork> mxc: what about an Array?
01:30:05 <mxc> @src Data.Array.(//)
01:30:06 <lambdabot> Source not found.
01:30:35 <dmwit> chid: Got it working yet?
01:30:35 <mxc> immutable array updates are constant time?
01:30:42 <mxc> forget i asked  then
01:31:28 <dmwit> chid: Well, I've got to run, but in case you haven't got it working yet:
01:31:38 <dmwit> Paste the code into a file (say, euler.hs).
01:31:54 <dmwit> Then load it up in ghci (ghci euler.hs) and type problem_1.
01:32:04 <dmwit> (Or problem_2 or problem_3 or whatever.)
01:32:34 <jkff> Oh, good ol' project euler
01:32:47 <dmwit> She's a beauty.
01:34:20 <Saizan> mxc: no, they aren't.
01:35:54 <maltem> mxc: Also, Data.Map.insert is O(log n), and Map even has a pure implementation, so given that a Map instead of an array is in order...
01:36:57 <maltem> mxc: _only_ given that, obviously
01:37:31 <vincenz> @localtime byorgey
01:37:32 <lambdabot> Local time for byorgey is Thu Jun  5 04:37:31 2008
01:41:40 <quicksilver> mxc: Data.Seq can acheive constant time for certain updates.
01:41:41 <ddarius> mxc: There are DiffArrays, but they probably wouldn't be described as "good"
01:42:10 <quicksilver> mxc: apparently it can be proven that it's impossible to have a persistent array with constant time update to all elements.
01:42:14 <quicksilver> certainly that's intuitive.
01:42:27 <quicksilver> mxc: but anyway, worrying about the difference between O(log n) and O(1) is wasting your time.
01:42:36 <mxc> very true
01:42:42 <mxc> was more just curious
01:42:47 <quicksilver> and your time is more valuable than your programs time :)
01:42:54 <quicksilver> Data.Seq manages constant time update near the ends.
01:42:55 <Deewiant> DiffArrays are O(number of updates), right?
01:43:00 <quicksilver> which is a neat property.
01:43:03 <Deewiant> or rather, accessing is that
01:43:12 <mxc> yes, the mantra of the haskell/ocaml comunities - dev time is more valuable than CPU time
01:43:16 <mxc> actually, speaking of ocaml
01:43:21 <quicksilver> Deewiant: accessing the current version is O(1) amortized.
01:43:31 <quicksilver> Deewiant: accessing old versions is something like O(length of history) I'm not sure.
01:43:46 <quicksilver> but, the implementation isn't very good. The constants are high.
01:43:47 <Deewiant> oh, right, of course it's that way around
01:44:01 <mxc> in ocaml, we've noticed that when data gets big (1mln nodes) Maps degrade in perfomance a lot but Hasttbl's are still good.  probably due to the GC.  is that the case in haskell too?
01:44:10 <mxc> Hashtbl's
01:44:15 <mxc> to use their bizarre spelling
01:44:25 <quicksilver> I hear it's actually quite hard to construct an example in which DiffArray is faster (than almost any other sensible choice:)
01:44:37 <quicksilver> mxc: that depends entirely on how you use the structure.
01:45:03 <Deewiant> I've been using DiffArrays quite a lot, maybe I should switch to Maps then O_o
01:45:29 <quicksilver> if DiffArray happens to be a convenient interface then sure :)
01:45:37 <quicksilver> just don't use it because you believe it's really fast.
01:45:46 <Saizan> Deewiant: sometimes even a plain Array is much faster
01:45:49 <mxc> quicksilver - in which ways
01:46:09 <mxc> ie. just inserts then just accesses, versus mix of insert, update, accesses?
01:46:19 <quicksilver> mxc: well if you are adding / deleting nodes at a massive rate
01:46:24 <quicksilver> then definitely I'd think GC will be a cost
01:46:32 <quicksilver> if the map is relatively constant then GC should not be an issue
01:46:35 <quicksilver> paging might be
01:46:42 <quicksilver> certainly Data.Map is not especially compact in memory.
01:46:58 <mxc> oooh, reminds me of another question, but i'll look it up
01:49:22 <mxc> haskell has no problem with 64-bit addressing and addressing > 4GB of ram right?
01:49:43 <ddarius> The asymptotics of hashtables and tree-based maps are different, obviously they will have different performances most noticeable at large sets of input.
01:50:12 <quicksilver> mxc: none at all.
01:50:33 <quicksilver> mxc: although a 64-bit compile of GHC does use up quite a bit more memory.
01:50:34 <mxc> so if instead of writing programs to be memory efficient, i just run on a maching w/ 32 gb of ram, i should be fine
01:50:42 <quicksilver> since "everything" is the size of a pointer
01:50:47 <mxc> right
01:50:55 <ddarius> mxc: Not if everyone else does that to.
01:51:12 <mxc> ddarius > it would be my machine and just my code
01:51:28 <quicksilver> ddarius: true although I strongly suspect the dominant effect being described is memory pressure not CPU pressure
01:51:42 <quicksilver> ddarius: so it's not the differences in algorithms so much as the differences in data structure storage.
01:51:49 <mxc> quicksilver: i'm inclined to agree with you
01:51:52 <quicksilver> knock-on effects on both cache lines and swap/pageing.
01:52:02 <mxc> hence my interest in telling the GC to fck off and just loading up on RAM
01:52:25 <quicksilver> following 12 pointers to "skip down" the side of a tree with 2^12 elements in
01:52:32 <quicksilver> is very very fast on modern CPUs
01:52:47 <quicksilver> the slow bit is paging/caching in that memory
01:52:53 <mxc> mmhm
01:52:57 <mxc> agree fully
01:53:17 <quicksilver> if you always access the same element, so that path remains cached, then it will seem perfectly fast :)
01:53:23 <mxc> 32 GB of ram is cheap compared to a week of senior developer time
01:53:30 <quicksilver> if you access elements randomly over 8GB of memory you will do a lot of paging.
01:53:59 <quicksilver> in fact, I'd go further.
01:54:05 <mxc> quicksilver - not if you have 32+ in your machine
01:54:09 <quicksilver> following 12 pointers could easily be faster than calculating a hash.
01:54:24 <quicksilver> mxc: (yes, quite. replace 8GB with '8*real memory')
01:54:30 <mxc> :)
01:54:53 <quicksilver> in particular, once your active heap is so large that a GC pass causes paging
01:54:58 <quicksilver> your performance will not be good :(
01:55:24 <Saizan> quicksilver: that's what i'm gonna say to the next who brings up that array lookup is really O(log n)
01:55:30 <mxc> i wonder how much 64 GB of ram would even be these days
01:55:33 <mxc> $1k $2k?
01:55:34 <quicksilver> Saizan: which part?
01:55:49 * ilyak_ barely uses 1gb
01:55:51 <mxc> can't be too expensive
01:56:01 <quicksilver> mxc: 64GB of SDHC cards costs only $320.
01:56:12 <quicksilver> is ram so much more expensive than flash these days?
01:56:29 <Saizan> quicksilver: "following 12 pointers could easily be faster than calculating a hash."
01:56:30 * ilyak_ have got a 8gb CF card acting as SSD holding OS files
01:56:43 <dmwit> That is a truly magnificent point.
01:56:56 <dmwit> ?remember quicksilver following 12 pointers could easily be faster than calculating a hash
01:56:57 <lambdabot> Good to know.
01:57:10 <mxc> @quote quicksilver
01:57:10 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
01:57:12 <mxc> @quote quicksilver
01:57:13 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
01:57:51 <mxc> i feel like when you get into 32GB per stick prices get high fast sicne its msotly just enterprise, server class clients
01:58:12 <quicksilver> mxc: looks like in round numbers, RAM is around $100/GB these days.
01:58:17 <quicksilver> I'm surprised, I thought it was cheaper.
01:58:30 <ddarius> In the context of inverting indexes for full-text indexing, a rather simple and efficient hash scheme tends to be best all around.  Also, as you are trying to point out, following 12 pointers is only fast if they are in cache otherwise it is extremely unlikely to be faster than a sane hash.
01:58:33 <mxc> yeah, i thought it was cheaper too
01:59:00 <ohub> $100/GB? I got 4GB for my laptop with 80â¬
01:59:05 <mxc> @quote quicksilver
01:59:05 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
01:59:14 <quicksilver> ohub: OK, I'm probably looking at the wrong place :)
01:59:31 <ddarius> How much you pay is significantly dependent on the speed of the memory and what interfaces it must have.
01:59:32 <quicksilver> ddarius: agreed.
01:59:39 <ohub> of course it depends on what kind of ram you're looking
02:00:40 <quicksilver> I have for a long time suspected there is significant optimisation possibility for GHC in improving memory locality
02:00:45 <quicksilver> (and hence cache behaviour)
02:01:02 <quicksilver> I dont' think it's easy though.
02:05:56 <dcoutts> newsham: pong
02:10:09 <al-maisan> Hello there! I would like to profile some code I wrote (http://muharem.wordpress.com/2008/06/05/finger-exercises-in-haskell/)
02:10:10 <lambdabot> Title: Finger exercises in haskell « Muharem Hrnjadovic, http://tinyurl.com/68dnxz
02:10:24 <al-maisan> and reduce the memory utilisation if possible
02:11:20 <al-maisan> Can you please point me to tips/resources about profiling haskell programs?
02:13:23 <agentzh> hi, has anyone here worked on something like PL/Haskell for PostgreSQL or just writing Pg extensions in Haskell?
02:13:32 <BONUS> guys how would calculate the lim x->1 of x^(x/(x-1))
02:13:34 <ddarius> al-maisan: Read the GHC user guide section on profiling.
02:13:38 <dmwit> al-maisan: Have a look at the GHC docs.
02:13:58 <al-maisan> OK, thanks.
02:13:59 <ddarius> BONUS: Not on topic.
02:14:14 <BONUS> thats true but still :]
02:14:27 <ddarius> But still, it's not on topic.
02:14:31 <BONUS> alright
02:14:37 <jkff> Search wikipedia for 'limit'
02:15:18 <BONUS> i know what a limit is, its just that by my calculations it comes out as 1 but its supposed to be e
02:15:23 <mxc_> BONUS:
02:15:25 <BONUS> but anyway, forget it
02:15:39 <jkff> I mean, the article should have a bunch of rules for computing limits
02:15:46 <BONUS> oh
02:16:20 <jkff> Ok, now my question. Anyone know any accessible papers on connection of relational databases with category theory? I found a really good one, but it's yet too hard for me because it assumes that I know what is a fibration, what is a sketch, etc.
02:16:42 <mxc_> last [f (1.1 ^ x) | x <- [1..]] where f x = x ^ ( x / ( x - 1))
02:16:56 <mxc_> BONUS that will work, but it might takea  while to run
02:16:58 <ddarius> jkff: There are ones in that vein, you may also want to look at the work on the Kleisli database (management system?)
02:18:17 <BONUS> haha cool
02:18:17 <jkff> Ok, I'll take a look. I'm asking because I am sure that there's a lot in category theory that can be applied to query optimization and give vast improvement against the current optimizers, and I am considering to do my thesis around that
02:18:33 <jkff> The thing that inspired me are the Free Theorems
02:18:52 <jkff> I'm studying Barr and Wells, hopefully that will help
02:18:52 <quicksilver> jkff: I'm sure there are plenty of good thesis topics around query optimisation.
02:19:01 <quicksilver> AFAIK most of the existing stuff is pretty ad-hoc.
02:19:04 <jkff> Yes, but I found none concerning category theory
02:19:11 <quicksilver> all the better :)
02:19:19 <quicksilver> you don't want to write somethign which has already been written.
02:19:22 <ddarius> jkff: Why do you think they'd give "vast improvement" over current optimizers?  Most likely they would just give a categorical grounding to existing ones (albeit perhaps allowing generalization)
02:19:47 <jkff> Because I saw queries that Oracle couldn't optimize but which it could, if only it knew what a monomorphism is, for example
02:20:13 <jkff> Of cause CT won't help in optimizing join order, but it will allow things like fusion and such
02:20:19 <solrize> those popup webpage snapshots bug the heck out of me, am i the only one who hates them?  is there a way to turn them off short of disablign JS completely?
02:20:35 <quicksilver> jkff: no query optimiser than I know of is aware of the functional dependencies in the data, either.
02:20:48 <quicksilver> jkff: which is ironic given that fundeps are one of the foundations of relational theory.
02:21:20 <jkff> Yes, this too. Sometimes functional dependencies arise from the query structure alone, independently from the actual data, but the optimizer still can't use them.
02:21:42 <jkff> However I can't talk professionally about this yet :)
02:23:42 <solrize> al-maisan, it looks like your mergesort function is using O(n) space at each recursion level because of splitAt
02:24:23 <al-maisan> solrize: Ah, that's a good point.
02:25:01 <mxc_> is network.socket.bytestring useable? or still unstable?
02:25:08 <mxc_> version number is just 0.1.1.2
02:25:22 <solrize> and i'm not sure if you're reading that enormous file as char strings
02:25:29 <solrize> instead of bytestrings
02:25:54 <solrize> finally that you're reading the whole input into memory at all means you'll eventually lose to the sort utility, which does external sorting when the input is large
02:26:35 <al-maisan> solrize: I am using IO.hGetLine for reading the file ..
02:26:53 <solrize> yeah, so each line is a char list
02:27:11 <solrize> huge overhead compared to a bytestring
02:27:20 <al-maisan> solrize: what would be the equivalent that operated on byte strings?
02:27:35 <al-maisan> operates
02:28:09 <solrize> i guess ByteString.Lazy.lines or something like that
02:28:32 <al-maisan> solrize: OK .. thank you very much for your observations ..
02:28:43 <al-maisan> I'll try to refactor the code ..
02:29:00 <solrize> i'm not an expert, i'm sure the more knowledgeable folks here can pick up stuff that i missed
02:29:03 <quicksilver> ByteString.hGetLine
02:29:10 <quicksilver> is excatly like hGetLine
02:29:14 <quicksilver> but returns a bytestring :)
02:29:18 <al-maisan> Thanks!
02:29:24 <quicksilver> note that bytestring compare is slower than string compare
02:29:32 <quicksilver> so you're trading memory use against speed to some extent
02:29:39 <quicksilver> almost certainly the right thing to do though.
02:30:00 <al-maisan> Will try using the byte string variant..
02:30:32 <solrize> your erlang stuff is interesting
02:31:22 <solrize> can you turn off that snap stuff?
02:31:44 <al-maisan> snap stuff?
02:32:14 <solrize> when you float the mouse over any of the links, there's an annoying popup with a tiny screen shot of the target page
02:32:48 <al-maisan> Ah .. I guess the only way to turn it off is to disable Javascript ..
02:33:04 <solrize> wordpress forces it on you????  i don't think that's right, there is a way to turn it on and off
02:34:14 <al-maisan> solrize: I have not done anything to turn it on explicitly .. it's a Wordpress "feature"
02:36:43 <solrize> well i turned off javascript in my browser... aaaah :)
02:37:48 <al-maisan> solrize: if you use Firefox, check out NoScript (https://addons.mozilla.org/en-US/firefox/addon/722)
02:37:54 <al-maisan> It's very good
02:41:59 <al-maisan> Wow!
02:42:38 <al-maisan> that's amazing .. after using the byte string functions my code only takes one 1/6 of the time
02:42:59 <al-maisan> and uses only 113 MB of RAM
02:43:22 <al-maisan> as opposed to 726 MB
02:43:46 <luqui> that is actually not as much of an improvement as is normally seen :-)
02:44:38 <quicksilver> relatively short strings, I expect.
02:44:43 <quicksilver> so the improvement is less.
02:44:49 <quicksilver> And the time improvement will be saved GC time
02:45:00 <quicksilver> so closely related to the RAM improvement
02:45:05 <quicksilver> (again guessed)
02:45:11 <al-maisan> yes, the strings are typically shorter than 40 characters
02:45:29 <al-maisan> makes sense ..
02:45:33 <ziman> al-maisan, does that mean your code is now faster than unix sort?
02:45:56 <al-maisan> yes .. indeed, UNIX sort took approx. 10 seconds
02:46:17 <solrize> oh someone was talking about ram prices in the scrollback... is that person still around?  it's my favorite subject these days :)
02:46:19 <al-maisan> the haskell binary now takes 2.2 seconds
02:46:41 <solrize> how big is the inpiut file again?
02:46:42 <ziman> nice :)
02:46:43 <solrize> input
02:46:46 <ziman> i wonder what the reason is
02:47:08 <quicksilver> somethign is wrong if your naive sort is faster than unix sort (no offence)
02:47:13 <quicksilver> have you run the unix sort again?
02:47:22 <quicksilver> maybe the file wasn't cached when you last ran it.
02:47:23 <al-maisan> Just did it
02:47:26 <al-maisan> same outcome
02:47:35 <quicksilver> do they both produce the same result?
02:47:43 <dmwit> I was just going to ask that. =P
02:48:07 <quicksilver> I previously spent some time working on a fast haskell sort and found it fairly hard to beat unix sort.
02:48:10 <quicksilver> Maybe I'm just dumb.
02:48:15 <al-maisan> I did two consecutive runs, same result ..
02:48:16 <quicksilver> Or maybe 6.8.2 is that much better..
02:48:32 <quicksilver> al-maisan: I meant, do your sort and unix sort produce the same data?
02:49:01 <al-maisan> just a sec
02:50:46 <al-maisan> there are differences .. checking them.
02:51:41 * dmwit bets on Unix' sort
02:51:53 <ddarius> CPSed memoizing fibonacci in Î»Prolog...
02:51:55 <al-maisan> I guess the differences stem from the fact that UNIX sort ignores case
02:52:50 <jkff> Maybe unix sort is too shy to use 113Mb of RAM and does an external sort?
02:53:30 <al-maisan> UNIX sort uses around 34 MB of RAM
02:53:34 <jkff> Maybe it has a parameter for that, or to really compare performance you should try it on a smaller file
02:53:59 <dmwit> al-maisan: sort is case-sensitive by default.
02:54:40 <quicksilver> dmwit: isn't sort based on locale collation settings by default?
02:54:43 <dmwit> al-maisan: Compare the sort order for (unlines ["a", "A"]) and (unlines ["A", "a"]) -- they're the same.
02:54:59 <dmwit> quicksilver: Maybe so.
02:55:01 <quicksilver> dmwit: yes, that's what he said.
02:55:10 <quicksilver> dmwit: his sort is case sensitve but unix sort is not :)
02:55:17 <Saizan> ddarius: where?
02:55:21 <dmwit> No... Unix sort *is* case sensitive.
02:55:31 <dmwit> quicksilver: Those two, after sorting, give the *same* output.
02:55:35 <quicksilver> ah sorry
02:55:40 <quicksilver> then I misunderstoof you :)
02:55:49 <quicksilver> al-maisan: try unix sort with LC_ALL=C
02:55:51 <ddarius> Saizan: In Hodas' thesis on Lolli.
02:55:54 <quicksilver> and see if that makes any difference.
02:56:08 <dmwit> You can turn case sensitivity off with -f.
02:56:09 <al-maisan> quicksilver: will do,
02:56:10 <dmwit> (sort -f)
02:57:50 <al-maisan> quicksilver: "LC_ALL=C" did the trick ..
02:58:24 <al-maisan> .. and now UNIX sort only takes 1.033s
02:58:33 <quicksilver> right, that's it.
02:58:46 <al-maisan> so, it was a locale setting issue
02:58:55 <quicksilver> with non-C locale, unix sort is doing an expensive locale based compare
02:59:03 <quicksilver> mcuh more expensive than a plain byte-wise strcmp
02:59:17 <al-maisan> my mergesort binary takes approx. twice as long
02:59:26 <al-maisan> and the outputs are identical
03:00:21 <al-maisan> I have learned something new :-) Thank you very much for your suggestions and insight!
03:00:35 <quicksilver> strcoll, it's called.
03:00:42 <quicksilver> strcoll is much slower than strcmp.
03:01:35 <al-maisan> yep.
03:14:30 <electronx> anyone running there site in haskell??
03:16:47 <mm_freak_work> not yet
03:17:09 <mm_freak_work> but i'm planning to, as soon as i get my own server
03:18:14 <electronx> are there any speed comparisons available?
03:19:00 <quicksilver> you will have no speed problems.
03:19:25 <electronx> quicksilver just trying to find out how much faster it will be then say php :)
03:19:30 <quicksilver> haskell is much faster than php, perl, ruby, which most website are written in.
03:19:42 <quicksilver> well it will depend on the exact application
03:19:52 <quicksilver> between 2x faster and 1000000x faster I expect.
03:20:02 <electronx> thats pretty good
03:20:55 <dmwit> heh
03:20:55 <electronx> question is how hard would it be to write a forum like phpBB3 in haskell?
03:21:47 <dmwit> Hard for an someone inexperienced at FP, but not so bad for someone who knows their stuff.
03:21:54 <dmwit> Just like everything, I suspect.
03:22:15 <dmwit> What are you planning on doing?
03:22:19 <mm_freak_work> the main difficulty of such things still is to come up with a good concept
03:22:26 <mm_freak_work> not the actual implementation
03:22:33 <dmwit> Please don't say you're writing yet another forum software...
03:23:02 <mm_freak_work> dmwit: i'm planning to write yet another CMSâ¦  what's wrong with that?
03:23:05 <electronx> no
03:23:22 <dmwit> mm_freak_work: ... =/
03:23:25 <electronx> just don't want parts of my site in php and others in haskell
03:23:52 <mm_freak_work> dmwit: difference is i write it for myself =)
03:24:13 <dmwit> mm_freak_work: Just as long as nobody uses it. ;-)
03:24:16 <dmwit> (I kid.
03:24:17 <dmwit> )
03:24:23 <mm_freak_work> so don't worryâ¦  unless it's really something sophisticated, i will not release it
03:24:42 <mm_freak_work> it's mainly for my personal site
03:27:39 <quicksilver> electronx: writing phpBB3 in php was a large task
03:27:43 <quicksilver> in some sense is was "hard".
03:27:56 <quicksilver> certainly it took a long time and has many lines of code.
03:28:04 <flux> hard or tedious?
03:28:16 <quicksilver> writing in haskell would be "easier" and very likely "better". But I'm sure ti would still be a big job.
03:28:30 <dmwit> right
03:28:37 <quicksilver> flux: I'm sure tehre were hard bugs to fix.
03:28:44 <dmwit> A big job is a big job, no matter how high-level your language.
03:28:54 <EvilRanter> factor it down - release six convenient libraries onto hackage as you go :P
03:28:59 <dmwit> (Unless you're a manager, and the language you use is English. ;-)
03:29:04 <flux> quicksilver, well yes, but I'm thinking most of the work was just there to be done, while others needed thinking (=hard)?
03:29:25 <quicksilver> flux: there probably weren't big conceptual thoughts to think, no.
03:29:30 <maltem> dmwit: depends. What if your language has a builtin simulate_phpbb3? *That* would be high-level.
03:29:39 <quicksilver> I doubt it contained any novel and exciting algorithms.
03:29:47 <dmwit> maltem: Ah, yes, the ol' HQ9+ approach.
03:29:57 <quicksilver> I suppose the DB structure took some thought.
03:30:06 <quicksilver> forum/subforum/thread/comment/user
03:30:21 <EvilRanter> the security model probably took a little meditation
03:30:24 <electronx> maybe i can just copy the phpBB3 structure
03:30:44 <flux> if one were to write a phpbb-clone in a sane language, time could be well spent by writing the application as resuable components
03:30:48 <electronx> i looked at its code and its a down right mess :)
03:30:55 <flux> so if it fails to capture the audience, perhaps some of it can still be salvaged :)
03:30:59 <quicksilver> ah, it's not that bad.
03:31:07 <quicksilver> it's better by far than most of the php I've seen.
03:31:08 <maltem> dmwit: heh
03:31:09 <EvilRanter> flux, i agree wholeheartedly
03:31:15 <quicksilver> it's quite nicely modularised.
03:31:35 <electronx> well as far as php 4 allows it to be :)
03:32:02 <quicksilver> I certainly wouldn't say "give me 2 days and I can write a haskell forum app better than phpBB3"
03:32:05 <EvilRanter> indeed, many projects may be worthwhile purely for the libraries that could be spun off them, whether or not the original project ever actually finishes
03:32:14 <quicksilver> but a fulltime week ought to cover most of it
03:32:20 <quicksilver> if you don't waste time on blind alleys
03:32:26 <dmwit> Wow.
03:32:31 <dmwit> You have very productive weeks.
03:32:33 <quicksilver> and don't spend time learning language features you didn't already grok.
03:32:38 <electronx> i have a general idea how i'm going to do it :)
03:32:57 <quicksilver> dmwit: I don't actually, I'm mostly a manager. I hop from one phone call to the next distracting email.
03:33:07 <quicksilver> I used to have productive weeks when I was an RA/programmer.
03:33:07 <quicksilver> ;)
03:33:23 <dmwit> =)
03:38:05 <electronx> question i'm wandering is why hasn't anyone used hasekll for something big it clearly has many advantages?
03:40:42 <quicksilver> the question I'm wondering is what makes you think no one has used haskell for anything big?
03:40:43 <mm_freak_work> electronx: because not many people have the passion to functional languages, especially not a pure one
03:41:24 <electronx> quicksilver: because i've hardly seen anything in terms of results
03:41:27 <quicksilver> http://www.haskell.org/haskellwiki/Applications_and_libraries
03:41:28 <lambdabot> Title: Applications and libraries - HaskellWiki
03:41:41 <quicksilver> there are thousands of programs written in haskell.
03:41:44 <quicksilver> some of them pretty big.
03:42:01 <quicksilver> there are a small but growing number of companies using haskell in large internal or bespoke projects.
03:42:59 <quicksilver> also see http://haskell.org/communities/05-2008/html/report.html
03:42:59 <lambdabot> Title: Haskell Communities and Activities Report
03:43:35 <electronx> quicksilver: i wanted to see something like myspace writing there site in haskell
03:43:40 <electronx> :)
03:43:47 <quicksilver> eh
03:43:51 <dmwit> So, for you, only webapps count as applications?
03:43:54 <quicksilver> so by "something big" you mean only webapps?
03:44:08 <electronx> no
03:44:10 <osfameron> $boss was asking "what would you use haskell for, I don't see people using it for complex business logic" this morning
03:44:12 <quicksilver> myself excepted, web applications are written only by stupid people.
03:44:21 <quicksilver> so of course you don't see them written in haskell :)
03:44:23 <osfameron> so I passed him spj's financial contract combinators presenttaion
03:44:42 <dmwit> osfameron: Good choice!
03:45:03 <electronx> link me to this presentation please
03:45:11 <osfameron> well, it's the only paper I know that makes the point that punchily (there may be others but I'm not that well read :-)
03:45:16 <dmwit> ?go composing financial contracts
03:45:17 <lambdabot> http://research.microsoft.com/~simonpj/papers/financial-contracts/contracts-icfp.htm
03:45:18 <lambdabot> Title: Simon Peyton Jones: papers
03:45:30 <dmwit> electronx: ^^
03:45:32 <osfameron> shiny.  How did it find *that one* first ?
03:45:39 <osfameron> as it's not the first result on google iirc
03:46:02 <dmwit> It is here.
03:46:12 <dmwit> You just need the right search terms. ;-)
03:46:27 <osfameron> ah!  that's right
03:46:43 <osfameron> I googled something vague, found the paper I wanted, but iwth an out of date link at microsoft, regoogled with the correct name...
03:48:54 <electronx> just skimmed that presentation
03:49:10 <electronx> someone want to tell me in a few words what its about
03:49:22 <^Someone^> No, I don't
03:49:27 <electronx> something about combinators
03:49:31 <electronx> lol
03:49:47 <dmwit> There's an abstract.
03:49:56 <quicksilver> it demonstrates why haskell is a good language for anything serious
03:49:59 <osfameron> I thought the presentation explained it fairly effectively
03:50:08 <quicksilver> and briefly outlines why using anything other than haskell can cost your company billions of dollars
03:50:20 <quicksilver> and cause you to end up in jail for negligent financial mismanagement.
03:50:28 <quicksilver> so there.
03:50:29 <quicksilver> ;)
03:50:31 <electronx> lol
03:50:32 <osfameron> well, I think it demonstrates that combinators are a good approach.
03:50:38 <quicksilver> I don't think SPJ quite uses those words though.
03:50:41 <quicksilver> I'm reading between the lines.
03:56:35 <electronx> haskell is getting a parallel gc pretty cool
03:57:27 <electronx> but what about a better debugger
03:57:53 <dmwit> We just *got* a better debugger. ;-)
03:58:13 <electronx> heh when?
03:58:19 <dmwit> in GHC 6.8
03:58:36 <electronx> you mean improved but still not good :)
03:58:41 <dmwit> Seriously, though, nobody really knows how to write a good debugger for lazy languages.
03:58:49 <dmwit> I think it's a hard problem.
03:58:57 <jkff> btw, an *even* better debugger would be one that could tell me where a particular value came from, that is, if I compute 3 = 1 + 2, that 3 would store that it was computed as 1 + 2. I think one can create a monad of 'explained values'.
03:58:58 <dmwit> If you have ideas, you should try your hand at them.
03:58:58 <electronx> ya i think it is
03:59:17 <jkff> However to store the explanation for every value is really big overhead
03:59:27 <quicksilver> fortunately a functional language needs a debugger much less.
03:59:35 <dmwit> (As for your "still not good" comment, I couldn't tell you.  I've never used the damn thing.)
03:59:44 <dmwit> (There really are that many fewer bugs.)
03:59:50 <electronx> well a parallel gc is a really complicated thing anyway so the ghc dev team are some really smart people :)
04:00:14 <dmwit> jkff: Did you hear about that "time-travelling" debugger that some people were working on?
04:00:24 <jkff> Yes, I even saw one and used one, for java
04:00:25 <dmwit> You could step both forward *and* backward in the code.
04:00:38 <electronx> thats cool
04:00:38 <dmwit> Now THAT's some overhead...
04:00:41 <jkff> That's cool, but explanation is a bit different and even better
04:00:57 <quicksilver> the encouragement to write pure functions
04:01:11 <quicksilver> makes it much easier to explore / debug code just by composing functions in ghci
04:01:22 <quicksilver> which is my preferred debugging technique for most algorithmic problems.
04:01:23 <jkff> However the overhead for that backwards debugger is not *that* big, the program slows down by a factor of 10-20, not 100-1000, it is perfectly acceptable for debugging
04:02:18 <electronx> can someone tell me what Quasiquotation is?
04:04:38 <dmwit> That's a Lisp thing.
04:04:43 <dmwit> `
04:04:47 <quicksilver> electronx: yes
04:04:50 <quicksilver> electronx: read the PDF at http://www.haskell.org/haskellwiki/Quasiquotation
04:04:51 <lambdabot> Title: Quasiquotation - HaskellWiki
04:04:54 <quicksilver> (linked in the first sentence)
04:06:45 <jkff> Is there a patch for ghc or something, that would allow me to statically step into function definitions and do :t on inline definitions appearing in 'let' and 'where'?
04:06:47 <dmwit> huh
04:07:09 <dmwit> jkff: I've often wanted that, too.
04:07:29 <jkff> ..But regretfully, there isn't? :)
04:07:49 <dmwit> As far as I know, no...
04:08:04 <dmwit> You could probably convince the debugger to do it.
04:08:12 <quicksilver> it doesn't make much sense to statically step in.
04:08:25 <quicksilver> there has to be some dynamic component
04:08:29 <dmwit> quicksilver: Why not?
04:08:30 <jkff> But I can't launch the debugger if my program has type errors
04:08:34 <quicksilver> (you have to instantiate the variables and types)
04:08:35 <dmwit> quicksilver: Just for :t queries?
04:08:38 <dmwit> ah
04:08:40 <dmwit> Still.
04:08:53 <quicksilver> in geenral I agree it's a desirable feature
04:08:56 <dmwit> You should be able to keep the polymorphism and get the types of the inner stuff.
04:09:00 <quicksilver> I was just saying it's not as simple as you'd hope.
04:09:10 <quicksilver> jkff: it's annoying. Two choices present themselves
04:09:23 <jkff> Which ones?
04:09:25 <flux> ocaml compiler can be persuaded to generate an annotation list, which contains the list of begins and ends of expressions and the associated type
04:09:32 <flux> can't see why that wouldn't work with haskell as well
04:09:43 <dmwit> jkff: Change the implementation of some stuff to "undefined" until you get a compiling program.
04:09:45 <quicksilver> 1. float the defns up to top level for this purpose
04:09:52 <dmwit> Then :t your way around...
04:09:52 <flux> so within emacs you can press C-c C-t and see the type under cursor
04:10:00 <jkff> But the compiler can do lambda lifting himself
04:10:05 <quicksilver> 2. give more explicit type annotations.
04:10:09 <quicksilver> annotate every let expression
04:10:14 <quicksilver> that will make the error message better
04:10:21 <quicksilver> and hopefully help you understand.
04:10:34 <jkff> I usually do so
04:10:36 <dmwit> flux: There's something similar for Vim, but I guess a bit more restricted (from your description).
04:11:10 <flux> also there's a program that merges the annotations with the program, producing a fully-annotated source
04:11:54 <jkff> Is there one for haskell?
04:11:59 <electronx> please don't compare ocaml to haskell
04:12:18 <vixey> electronx there's very similar...
04:12:23 <quicksilver> why not? it's a very interesting comparison.
04:12:42 <vixey> actually quicksilver put it much better
04:12:45 <electronx> well for starters ocaml won't be getting a parallel gc :)
04:12:57 <osfameron> why not?
04:13:00 <quicksilver> in particular their type checkers do a very similar job, so this discussion about types for lets is very related.
04:13:07 <flux> electronx, I don't see how that would affect the typing issue at hand
04:13:08 <quicksilver> electronx: in claiming that, you are comparing them.
04:13:11 <electronx> secondly haskell is lazy
04:13:17 <electronx> lol
04:13:22 <quicksilver> and again, you are comparing them.
04:13:26 <flux> unless you're suggesting parallel gc is somehow performed with the assistance of the type system, maybe it's possible :)
04:13:28 <electronx> :)
04:13:28 <mm_freak_work> flux: you can configure emacs to show the type automatically
04:13:31 <jkff> Well, haskell is lazy, so what?
04:13:34 <quicksilver> (do you really think I don't know that ocaml is strict and haskell is lazy?)
04:13:45 <jkff> That doesn't affect type checking in a way that I am aware of
04:13:55 <electronx> makes it a different beast imho
04:14:02 <flux> mm_freak_work, oh, thanks for the info. although the magic breaks when you modify the buffer. I don't think it keeps track of insertions/deletions etc.
04:14:05 <electronx> so comparing them is not fair
04:14:20 <jkff> We're not comparing the languages, just their typecheckers
04:14:29 <jkff> And associated tools
04:14:44 <osfameron> and even the languages (syntax/libraries/real world usage) can be usefully compared in some ways
04:15:19 <quicksilver> usefully compared in all kinds of ways.
04:15:30 <quicksilver> viewing the language as tools, they share many advantages
04:15:44 <quicksilver> so when choosing one for a task, it's an interesting question to ask if the other might be better.
04:15:53 <quicksilver> of course, the answer is always that haskell is better ;)
04:15:53 <mm_freak_work> flux: ah, you mean the types for the current buffer?  no, that doesn't work
04:15:58 <quicksilver> but it's still an interesting question.
04:16:06 <mm_freak_work> flux: it works for the base libs
04:16:17 <mm_freak_work> (most of them at least)
04:16:19 <flux> mm_freak_work, oh, right, I think I've seen that in action..
04:16:27 <electronx> quicksilver: no doubt haskell is superior :)
04:17:22 <electronx> quicksilver: the lispers where very strongly discouraging me from learning haskell but i saw the light in the end
04:17:54 <dmwit> ?quote lisp
04:17:54 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
04:17:58 <dmwit> ?quote lisp
04:17:58 <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
04:18:03 <dmwit> ?quote lisp
04:18:03 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
04:18:09 <dmwit> ?quote lisp
04:18:09 <lambdabot> qwe1234 says: lisp is a wannabe python from the seventies.
04:18:16 <tsuwabuki> > map ((!!) ['a'..'z']) [7, 4, 11, 11, 14]
04:18:17 <lambdabot>  "hello"
04:18:24 <dmwit> ?quote veracitysnobs
04:18:24 <lambdabot> No quotes match. :(
04:18:32 <electronx> rofl
04:18:41 <vixey> > zipWith (flip (!!)) ['a'..'z'] [7, 4, 11, 11, 14]
04:18:41 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
04:19:14 <vixey> @quote
04:19:15 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
04:19:18 <vixey> @quote
04:19:19 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
04:19:30 <vixey> @quote meta
04:19:34 <lambdabot> fasta says: masak: Their meta types don't match
04:19:35 <jkff> > do x <- [7,4,11,11,14]; ['a'..'z']!!x
04:19:36 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Char'
04:19:39 <jkff> Oh
04:19:41 <dmwit> ?quote dcnstrct
04:19:41 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
04:19:44 <dmwit> =)
04:19:51 <ddarius> There is a type debugger for Chameleon that also works on Haskell (albeit probably only Haskell 98).
04:20:07 <therp> electronx: I'd call myself a lisper and I actively encourage you to learn Haskell. Don't listen to the folks in #lisp.
04:20:31 <jkff> > do x <- [7,4,11,11,14]; return $ ['a'..'z']!!x
04:20:33 <lambdabot>  "hello"
04:20:35 <jkff> Wow
04:20:38 <ddarius> electronx: There is work on a parallel debugger, not (currently) on a concurrent one (there was previous work on an incremental one.)
04:20:40 <tsuwabuki> nice
04:21:04 <electronx> for haskell?
04:21:06 <vixey> > (liftM2 (!!)) [7,4,11,11,14] ['a'..'z']
04:21:09 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
04:21:31 <jkff> > [7,4,11,11,14] >>= return . (['a'..'z']!!)
04:21:32 <lambdabot>  "hello"
04:21:48 <electronx> lol
04:22:04 <dmwit> > map (['a'..'z']!!) [7,4,11,11,14]
04:22:05 <lambdabot>  "hello"
04:22:10 <electronx> > fromEnum 'a'
04:22:12 <lambdabot>  97
04:22:27 <ddarius> s/debugger/GC
04:22:30 <electronx> > fromEnum 'h'
04:22:31 <lambdabot>  104
04:23:01 <electronx> its amazing how hard it is to get a working darcs under windows
04:23:06 <dmwit> > map chr [104, 101, 108, 108, 111]
04:23:08 <lambdabot>  "hello"
04:23:27 <dmwit> electronx: Oh, really?  There's no binaries available on darcs.net?
04:23:27 <FordCortina> electronx: is that on vista?
04:23:33 <electronx> no xp
04:24:03 <FordCortina> electronx: i just used the binary installer personally
04:24:06 <tsuwabuki> I recommend you git.
04:24:16 <electronx> dmwit: binaries are availible but you need lots of third party libs that are sometimes very hard to find working for windows
04:24:32 <dmwit> hum
04:24:49 <FordCortina> then again ive only got darcs 1
04:25:15 <dmwit> Yet another reason to never switch back to Windows.
04:25:29 <electronx> ah well i have the latest one :)
04:25:36 <jkff> And another reason for someone to never switch to darcs
04:25:43 <electronx> dmwit: i forced to use windows :(
04:25:49 <FordCortina> heh
04:25:51 <^Someone^> Okay, I'll never switch to darcs :D
04:26:10 <dmwit> ^Someone^: Man, that joke just never gets old for you, does it? =D
04:26:11 <FordCortina> i use mercurial mainly
04:26:14 <jkff> Well, if this is a reason for you :)
04:26:22 <tsuwabuki> me too
04:26:29 <tsuwabuki> w
04:26:31 <electronx> well if i upload my working darcs somewhere then there shouldn't be any problems then :)
04:26:34 <pejo> Does git work that well on Windows? My impression was that it used some assumptions about the file system that were quite unixy.
04:26:44 <quicksilver> bzr ftw!
04:26:46 <^Someone^> Shush dmwit! :P
04:26:48 <quicksilver> VCS war is on!
04:26:51 <^Someone^> Not everyone's heard it yet :D
04:27:12 <FordCortina> :)
04:27:56 <mm_freak_work> > map (chr . (+ ord 'a')) [7,4,11,11,14]
04:27:57 <lambdabot>  "hello"
04:28:01 <Japsu> pejo: it works well enough under cygwin
04:29:15 <FordCortina> pejo: that's what i heard too. mercurial works on windows tho :D
04:29:32 * FordCortina is a mercurial fanboy
04:29:56 <electronx> bah whats wrong with darcs
04:30:10 <electronx> its as easy as pie to check something out
04:30:27 <vixey> it's easy to check things out with any rcs
04:30:30 <electronx> its also compiled so no dependencies
04:30:50 * Japsu should try darcs 2
04:30:51 <electronx> except for windows :)
04:31:04 <FordCortina> electronx i havent worked out how to revert to an older revision with darcs yet. it seems to be like doing another checkout/branch
04:31:16 <FordCortina> :S
04:32:03 <electronx> FordCortina: go ask at #darcs
04:32:53 <FordCortina> electronx: i think i asked before no one really had an answer
04:33:03 <FordCortina> electronx: maybe just bad luck
04:33:08 <electronx> how long did ya wait
04:33:10 <electronx> ?
04:33:11 <dmwit> darcs unrecord; darcs revert?
04:33:13 <FordCortina> ill rtfm one day
04:33:29 <electronx> thats a good idea :)
04:33:29 <dmwit> Just read "darcs help", it tells most of what you need to know.
04:33:30 <ivanm> FordCortina: stop lying... NO-ONE reads the manual! :p
04:33:49 <FordCortina> i didnt know unrecord
04:34:08 * FordCortina is one of those people who found darcs help revert confusing
04:34:53 <osfameron> reverting is confusing in any VCS
04:34:55 <electronx> anyway later haskellers :)
04:35:04 <FordCortina> :)
04:35:22 <FordCortina> osfameron: true that
04:36:34 <vixey> @essence Applicative
04:36:34 <lambdabot> Unknown command, try @list
04:36:38 <vixey> :(
04:37:22 <osfameron> oooo, I've been trying to implement monads in Perl, but cos it doesn't have strong typechecking, there's no way to know which monad I'm in for the polymorphic functions (fail, return etc.)
04:37:35 <osfameron> I just realised that I could make every monad thread the initial monad through it with a Reader...
04:38:04 <vixey> cool
04:38:14 <vixey> can you replace ; or what do you use for bind?
04:38:36 <osfameron> vixey: I'm overloading '>>'
04:38:53 <osfameron> current state of play is http://greenokapi.net/svn/code/scratch/Monads/test.pl
04:39:24 <yitz> osfameron: why fail? that really has nothing to do with monads, it's for special Haskell syntax.
04:39:30 <FordCortina> !pastebin
04:39:31 <hpaste> Haskell paste bin: http://hpaste.org/
04:39:38 <vixey> cool
04:40:02 <osfameron> yitz: well, it's MonadFail isn't it?  I like the "NotJustMaybe" pattern of subs that could fail in more interesting ways than Nothing
04:40:20 <yitz> osfameron: you're thinking of MonadZero
04:40:28 <osfameron> er, yeah, sorry ;-)
04:40:45 <osfameron> in any case, Perl doesn't have the same strong typing issues that make it a bad thing for fail to be in the root class
04:41:01 <yitz> osfameron: that's only certain monads
04:41:04 <osfameron> (and this is just a sketch anyway, if it turns out to be useful I'll refactor)
04:41:14 <vixey> I don't think that's why fail is in the wrong place
04:41:41 * dmwit neither
04:41:55 <yitz> osfameron: you can put anything you want in the root class, but that's not part of monads in general
04:41:59 <yitz> vixey?
04:42:00 <Socrates> > map (chr . $104) $ scanl1 (.) [id, (+ (-3)), (+7), id, (+3)]
04:42:00 <lambdabot>  Parse error at "$104)" (column 12)
04:42:05 <Socrates> > map (chr . ($104)) $ scanl1 (.) [id, (+ (-3)), (+7), id, (+3)]
04:42:06 <lambdabot>  "hello"
04:42:10 <vixey> yitz: What?
04:42:29 <yitz> don't think that's why fail is in the wrong place? ?
04:42:35 <vixey> yitz: yes
04:42:36 <vixey> :t (+-3
04:42:37 <vixey> :t (+-3)
04:42:37 <lambdabot> parse error (possibly incorrect indentation)
04:42:39 <lambdabot> Not in scope: `+-'
04:42:51 <vixey> :t (+ -3)
04:42:52 <lambdabot>     The operator `+' [infixl 6] of a section
04:42:53 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
04:42:53 <lambdabot>         in the section: `(+ - 3)'
04:42:54 <osfameron> yitz: ok.
04:42:58 <Socrates> @t +(-3)
04:42:58 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:43:05 <yitz> don't think what's why?
04:43:08 <Socrates> @type +(-3)
04:43:10 <lambdabot> parse error on input `+'
04:43:14 <osfameron> yitz: but in any case, there are certain functions (such as fail) which haskell types into the correct class, but which Perl can't as it doesn't do type checking
04:43:15 <Socrates> @type (+)(-3)
04:43:17 <lambdabot> forall a. (Num a) => a -> a
04:43:19 <vixey> "strong typing issues"
04:43:28 <osfameron> yitz: my current stupid solution is to walk the caller tree till I find which Monad called it :-)
04:43:44 <mm_freak1work> @type (+(-3))
04:43:46 <lambdabot> forall a. (Num a) => a -> a
04:43:46 <osfameron> but I think binding the monad in via reader might be cute (though might mess with my feeble brain)
04:44:35 <osfameron> vixey: well "issues" is a bit strong :-)  It doesn't do it, and therefore gets neither a) the benefits or b) the troubles that strong typing entails.
04:48:41 <yitz> @go monads in python
04:48:42 <lambdabot> http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html
04:48:42 <lambdabot> Title: Valued Lessons: Monads in Python (with nice syntax!)
04:49:21 <osfameron> you've seen the existing Perl one?
04:49:33 <yitz> osfameron: have you seen that? it's very nice. uses some funky Python stuff, like decorators and bi-directional generators, but maybe it would be helpful
04:49:39 <yitz> osfameron: where?
04:49:47 <osfameron> @go monads in perl
04:49:47 <lambdabot> No Result Found.
04:49:52 <osfameron> stupid bot
04:50:01 <osfameron> http://sleepingsquirrel.org/monads/monads.html
04:50:02 <lambdabot> Title: Monads in Perl
04:50:02 <yitz> osfameron: google's fault this time
04:50:05 <osfameron> yeah
04:50:08 <osfameron> well, no
04:50:12 <osfameron> it's the first result
04:50:12 <yitz> @botsnack
04:50:13 <lambdabot> :)
04:50:15 <vincenz> Does anyoner emember the paper that encoded monads as a datatyep?
04:50:22 <osfameron> the perl one uses source filters
04:50:23 <vincenz> datatype
04:50:42 <osfameron> I'm looking at using Data::Declare, and eventually bytecode hackery to make the syntax nicer
04:53:13 <osfameron> ooo, that do example is rather pretty, I don't get how that works
04:53:27 <osfameron> yitz: never heard of a bidirectional generator :-(
04:55:16 <yitz> osfameron: generators are python's lazy functions. recent python added the capability of passing data into the generator after it has already partially evaluated.
04:56:33 <yitz> a perverse imperative twist to laziness :)
04:56:44 <osfameron> ah, one-line anonymous functions are exactly what you need for pretty syntax for monads
04:57:36 <yitz> one-line?
04:58:26 <hpaste>  FordCortina pasted "How to deal with "complementary" constructors?" at http://hpaste.org/8118
04:58:58 <FordCortina> that problem has been bothering me for a while. can anybody suggest a solution/hint?
04:59:06 <vixey> solution to what?
04:59:22 <FordCortina> see hpaste
04:59:28 <vixey> um
04:59:28 <vixey> ......
04:59:36 <vixey> I'd suggest closing the parenthesis you open
04:59:36 <FordCortina> it the annoying way i have to handle And and Or
05:00:00 <FordCortina> vixey: that would be a good start yes :)
05:00:25 <FordCortina> i havent run all of that code because it looks plain ugly
05:00:26 <vixey> (I still don't know what you are actually asking)
05:00:49 * FordCortina FordCortina tries to think a bit more about what hes askign
05:01:02 <osfameron> yitz: well, python doesn't have multiline lambdas does it?
05:03:03 <yitz> osfameron: right you have to give functions some name, in general. the one-line things aren't very useful most of the time.
05:03:49 <SamB_XP> that's only because Python is impure ;-)
05:03:53 <osfameron> hmmm, I don't understand how that works.  Good chance to gen up on Python / decorators / generators
05:04:11 <SamB_XP> but doesn't allow statements in lambdas
05:05:24 <yitz> SamB_XP: that's also a limitation, but you can call functions. the main problem is that there just isn't room to do anything, and the syntax is awkward.
05:05:30 <osfameron> oh, "yield" just works automagically as bind?
05:06:07 <vixey> oh fun http://www.haskell.org/haskellwiki/Haskell_Quiz
05:06:08 <lambdabot> Title: Haskell Quiz - HaskellWiki
05:06:26 <yitz> osfameron: yield means return just one value of the list for now, then hide in the background (like a thunk) until more is demanded.
05:07:23 <Deewiant> FordCortina: how about making map (demorgan . Not) a helper function
05:08:32 <osfameron> yitz: ah!  so the do block is just called repeatedly passing the next chained value along.
05:08:38 <FordCortina> Deewiant: thanks
05:10:05 <FordCortina> maybe i need to take a break, sometimes i try to search for the clean and minimal program to much... and it turns out to be an empty file lol
05:10:15 <vixey> hehe
05:18:17 <ski_> vincenz : as a datatype ?
05:18:18 * yitz studied the monads in python thing again.
05:18:24 <yitz> osfameron: yes, right. :)
05:18:44 <stephano> hello.
05:18:51 <osfameron> yitz: shiny.  That's clever, twisted, and I think I can do it in Perl with Coro::Generator
05:19:06 <stephano> is there a quick way to check if in a string there are two words double times in it?
05:19:17 <yitz> osfameron: ok, nice (that's new Perl stuff, I've been out of it for a long time)
05:19:23 <stephano> example i need to check if a string contains "this is an example text text and it is false"
05:19:29 <stephano> and "text" is two times in it
05:19:44 <stephano> can i somehow find all double words like "text text" easily?
05:20:00 <vixey> > group . sort . words $ "this is an example text text and it is false"
05:20:01 <ski_> yitz : "bidirectional generator" ? "passing data into the generator after it has already partially evaluated" ? .. do you mean like a stream processor ?
05:20:02 <lambdabot>  [["an"],["and"],["example"],["false"],["is","is"],["it"],["text","text"],["t...
05:20:12 <vixey> any (> 1) . map length ?
05:20:14 <yitz> osfameron: it's cool how they got the "do" block to look cosmetically almost like Haskell. Seems like it should be a hack, but in fact it's even a nice way to do it.
05:20:15 <stephano> vixey: ah okay
05:20:33 <stephano> vixey: you are a good haskell man
05:20:46 <osfameron> yitz: the only sad thing is that "yield" doesn't look as nice as << or similar
05:20:50 <vixey> uh.
05:20:52 <stephano> vixey: where do i get group and sort?
05:20:57 <stephano> List?
05:21:10 <TSC> Data.List
05:21:20 <stephano>  any (>1) . map length (group . sort . words $ "this is an example text text and it is false")
05:21:20 <stephano>  <-- ?
05:21:45 <ski_> @index group
05:21:45 <lambdabot> Data.List
05:21:46 <stephano> let x = group . sort . words $ "this is an example text text and it is false" in (any (>1) . map length) x
05:22:09 <yitz> osfameron: i guess. it's like two mutually recursive lazy functions that alternate pulling data out of each others. sort of. well, forget it, it's imperative, really.
05:22:18 <Deewiant> > any (>1) . map length (group . sort . words $ "this is an example text text and it is false")
05:22:19 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
05:23:12 <stephano> mytest = (any (>1) . map length) . group . sort . word
05:23:16 <stephano> is that haskell way?
05:23:17 <ski_> yitz : like `data SP a b = Put b (SP a b) | Get (a -> SP a b)' ?
05:24:09 <Deewiant> > any (>1) . map length . group . sort . words $ "this is an example text text and it is false"
05:24:14 <lambdabot>  True
05:24:24 <TSC> I would write:  any ((>1) . length) . group . sort . words $ "blah blah bla"
05:24:29 <stephano> hehe
05:24:38 <stephano> okay no i need to give back a list with the double words
05:24:40 <TSC> That is, put the length inside the "any" test
05:24:45 <stephano> any (>1) . map length (group . sort . words $ "this is an example text text and it is false")
05:24:54 <stephano> then it should give me back only "text"
05:24:55 <Deewiant> > filter ((>1) . length) . group . sort . words $ "this is an example text text and it is false"
05:24:57 <lambdabot>  [["is","is"],["text","text"]]
05:25:07 <stephano> Deewiant: ah i did it with map. my bad
05:25:13 <stephano> yeah but now i need nub Deewiant !
05:25:14 <stephano> :)
05:25:17 <stephano> to unify the list
05:25:18 <stephano> eh unique
05:25:19 <Deewiant> > map nub . filter ((>1) . length) . group . sort . words $ "this is an example text text and it is false"
05:25:20 <lambdabot>  [["is"],["text"]]
05:25:23 <mm_freak_work> @type any
05:25:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:25:29 <Deewiant> > concatMap nub . filter ((>1) . length) . group . sort . words $ "this is an example text text and it is false"
05:25:31 <lambdabot>  ["is","text"]
05:25:39 <mm_freak_work> > any [True,True,False]
05:25:40 <lambdabot>  Couldn't match expected type `a -> Bool'
05:25:43 <vixey> @let s = "this is an example text text and it is false"
05:25:44 <lambdabot> Defined.
05:25:45 <vixey> > s
05:25:46 <lambdabot> Terminated
05:25:49 <vixey> @let s' = "this is an example text text and it is false"
05:25:50 <vixey> > s'
05:25:50 <lambdabot> Defined.
05:25:51 <lambdabot>  "this is an example text text and it is false"
05:25:52 <mm_freak_work> @src any
05:25:52 <lambdabot> any p =  or . map p
05:26:22 <ski_> runningAverage :: SP Int Double
05:26:26 <ski_> runningAverage = loop 0 0
05:26:30 <ski_>   where
05:26:33 <mm_freak_work> at least now i know that i was reinventing the wheel all the time
05:26:46 <ski_>   loop sum count = Get $ \n -> let
05:26:51 <ski_>     sum' = sum + n
05:26:58 <ski_>     count' = succ count
05:27:03 <ski_>  in Put (sum' / count') (loop sum' count')
05:27:21 <stephano> really cool :]
05:27:44 <vixey> > let those = group . sort . words $ s' ; these = unwords those in words . take (((-)`on`length) these (unwords . map (head . nub) $ those)) these
05:27:45 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
05:27:49 <ski_> yitz : is that anything similar to what can be done with "bidirectional generators" in python ?
05:29:31 <stephano> mh
05:29:34 <stephano> it's sadly wrong
05:29:37 <stephano> Deewiant: :(
05:29:43 <mm_freak_work> > [ x | x <- [2..], not $ any ((== 0) . rem x) [2..x-1] ]
05:29:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:29:54 <yitz> ski_: not sure what you mean. what is that supposed to do?
05:30:18 <stephano> Deewiant: the worsd need to be direct behind each other
05:30:48 <ski_> yitz : it yields the current average, can be resumed by feeding another integer, then it yields with the now current average, et.c.
05:30:49 <^Someone^> How do I define a function again?
05:30:54 <^Someone^> For lambdabot
05:31:01 <ski_> @let foo = 42
05:31:02 <lambdabot> Defined.
05:31:06 <ski_> > foo
05:31:07 <lambdabot>  42
05:31:17 <^Someone^> Okay, but didn't work : \
05:31:23 <^Someone^> @let Id x = x
05:31:24 <lambdabot> <local>:4:0: Not in scope: data constructor `Id'  <local>:4:7:     Ambiguous ...
05:31:27 <stephano> > filter ((>1) . length) . group . sort . words $ "this is an text example text and it false"
05:31:28 <lambdabot>  [["text","text"]]
05:31:32 <stephano> Deewiant: you see?
05:31:49 <^Someone^> @let id x = x
05:31:50 <lambdabot> Defined.
05:31:52 <^Someone^> AH
05:31:56 <^Someone^> Ty
05:32:10 <ski_> ^Someone^ : variables defined by some expression must start with lowercase letter (or `_', iirc)
05:32:13 <stephano> vixey: maybe you?
05:32:21 <vixey> what about me
05:32:29 <^Someone^> Ty ski_
05:32:34 <^Someone^> Hey vixey :)
05:32:46 <mm_freak_work> ski_: variables actually don't exist in haskell
05:33:00 <vixey> @report
05:33:01 <lambdabot> ()
05:33:02 <yitz> ski_: so yeah, that's a good example then. that would be a simple use of those thingies. (though in python you'd more likely use an object for that)
05:33:08 <vixey> ?where report
05:33:09 <lambdabot> http://www.haskell.org/onlinereport/
05:33:11 <ski_> mm_freak_work : sure they do
05:33:37 <ski_> mm_freak_work : implicit reference cells, however, doesn't exist in haskell
05:33:56 <mm_freak_work> ski_: not in the common programming sense, that's why i don't like the term in this place
05:34:14 <vixey> mm_freak_work: look at the report
05:34:39 <yitz> as the old Haskell saying goes: Variables don't.
05:34:52 <^Someone^> id 1
05:34:52 <^Someone^> > id 1
05:34:52 <lambdabot> Terminated
05:34:56 <^Someone^> Huh
05:34:59 <ski_> mm_freak_work : the math (and logic) use of the term, predates the imperative programming use (and the former is what is used in declarative languages, such as Haskell, Prolog, ...)
05:35:03 <^Someone^> @let id x = x
05:35:04 <lambdabot> <local>:4:0:     Warning: Pattern match(es) are overlapped              In th...
05:35:09 <^Someone^> id 1
05:35:12 <^Someone^> > id 1
05:35:13 <lambdabot> Terminated
05:35:15 <^Someone^> Huh
05:35:16 <^Someone^> Why
05:35:25 <yitz> @type id
05:35:26 <vixey> @under
05:35:26 <lambdabot> Maybe you meant: index undo
05:35:27 <lambdabot>     Ambiguous occurrence `id'
05:35:27 <lambdabot>     It could refer to either `L.id', defined at <local>:4:0
05:35:27 <lambdabot>                           or `Data.Function.id', imported from Data.Function at imports.h:15:0-32
05:35:41 <yitz> @type L.id
05:35:43 <lambdabot> forall t. t -> t
05:35:50 <ski_> @undefine
05:35:50 <lambdabot> Undefined.
05:35:57 <ski_> :-P
05:35:58 <vixey> @underfed
05:35:58 <lambdabot> Unknown command, try @list
05:36:11 <yitz> @botsnack
05:36:11 <lambdabot> :)
05:36:36 <ski_> yitz : ok
05:37:04 <stephano> someone in?
05:37:21 <ski_> no
05:38:25 <lilac> > let avg (l:ls) s n = (s+l)/(n+1):avg ls (s+l) (n+1); foo (a:as) = (a*2+3):foo as; averages = avg values 0 0; values = 1:foo averages in take 10 values
05:38:26 <lambdabot>  [1.0,5.0,9.0,13.0,17.0,21.0,25.0,29.0,33.0,37.0]
05:38:40 <lilac> ski_: ^^ there's a mutual generator thingy for you :)
05:38:42 <vixey> ?go devils nest recursion
05:38:43 <lambdabot> http://arxiv.org/pdf/cs/0505037
05:38:46 <^Someone^> Brb
05:39:18 <mm_freak_work> ski_: i don't like to use the term, when talking about haskell, because regardless of the original meaning, it usually just confuses folks
05:40:42 <mm_freak_work> > map snd $ iterate (\(r,s) -> (r+1, s + 2*r + 1)) (0,0)
05:40:44 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
05:41:22 <ski_> mm_freak_work : i think that, in the context of haskell, most everyone knows the meaning of `variable' to be the one referred to here .. so i think it would be non-direct, and possibly confusing to use other words ..
05:42:03 <ski_> mm_freak_work : in an imperative programming context, however, i agree that it is probably best to reserve the word `variable' for the "reference cell" meaning
05:42:30 <lilac> you could call them "thunktions" *ducks*
05:42:46 * ski_ slaps lilac up the haid
05:43:37 <lilac> in any case, variables do exist (eg MVar)
05:44:08 <stephano> vixey: are you there?
05:44:19 <^Someone^> id 1
05:44:24 <^Someone^> >id 1
05:44:26 <^Someone^> > id 1
05:44:28 <lambdabot>  1
05:44:31 <^Someone^> Yay
05:44:40 <^Someone^> Ty
05:44:47 <vixey> > let sloth 0 = 0 ; sloth n = sloth (sloth' (n-1))) + sloth' (n-1) ; sloth' 0 = 0 ; sloth' m | sloth (m-1) <= m = sloth' (sloth m) + m | otherwise = 0 in sloth 14
05:44:47 <lambdabot> Unbalanced parentheses
05:49:06 <stephano> vixey: may i ask you something?
05:49:15 <vixey> yes
05:49:45 <stephano> you solved not the problem from above
05:49:56 <stephano> i have now a solution on my own, but maybe you want to suggest an optimaziation
05:51:50 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8119
05:51:54 <stephano> http://hpaste.org/8119
05:51:58 <stephano> someone look at the paste
05:52:08 <stephano> <vixey> > group . sort . words $ "this is an example text text and it is false"
05:52:19 <stephano> that is wrong because it alsao matches "this is an example text this it is false"
05:52:31 <stephano> because this and this is NOT direct behind each other should not match
05:52:54 <vixey> stephano: Do you understand what group . sort . words does?
05:53:36 <vixey> > words $ "this is an example text text and it is false"
05:53:37 <lambdabot>  ["this","is","an","example","text","text","and","it","is","false"]
05:53:39 <vixey> > sort . words $ "this is an example text text and it is false"
05:53:41 <lambdabot>  ["an","and","example","false","is","is","it","text","text","this"]
05:53:44 <vixey> > group . sort . words $ "this is an example text text and it is false"
05:53:45 <lambdabot>  [["an"],["and"],["example"],["false"],["is","is"],["it"],["text","text"],["t...
05:53:48 <vixey> > group . words $ "this is an example text text and it is false"
05:53:49 <lambdabot>  [["this"],["is"],["an"],["example"],["text","text"],["and"],["it"],["is"],["...
05:55:52 <lilac> stephano: what are you trying to do?
05:57:33 <lilac> > map (any ((>1) . length) . group . words) ["this is an example text this it is false", "this is an example text text and it is false"]
05:57:43 <lambdabot>  [False,True]
05:57:52 <Deewiant> he wants to find groups of consecutive words only
05:57:52 <skorpan> lol
05:58:13 <vixey> @let filteringMap (f,p) = map f . filter p
05:58:14 <Deewiant> i.e. exactly that.
05:58:20 <lambdabot> Defined.
05:58:20 <stephano> vixey: yes and it is false for my exercise :]
05:58:31 <vixey> stephano: understanding it is important
05:58:32 <vixey> @let (x <-- y) = (x,y)
05:58:32 <lambdabot>  Parse error in pattern
05:58:35 <stephano> "this is an example text and it is false text"
05:58:40 <stephano> and this should not be true
05:58:51 <stephano> because there is no "is is" or "text text" in it "text blabla foo text" is okay
05:58:58 <stephano> could you understand me?
05:59:09 <vixey> stephano: yes but do you understand how to solve the problem now?
05:59:16 <stephano> vixey: look at paste
05:59:18 <stephano> i solved it :]
05:59:21 <vixey> > filteringMap (head,  (>1) . length) . group . words $ s'
05:59:21 <lambdabot>   Not in scope: `s''
05:59:32 <stephano> Deewiant: yes
05:59:34 <vixey> @let s' = "this is an example text and it is false text
05:59:34 <lambdabot>  Improperly terminated string
05:59:36 <vixey> @let s' = "this is an example text and it is false text"
05:59:37 <lambdabot> Defined.
05:59:39 <vixey> > filteringMap (head,  (>1) . length) . group . words $ s'
05:59:40 <lambdabot>  []
06:00:03 <vixey> > filteringMap (head,  (>1) . length) . group . words $ ("this " ++ s' ++ " text")
06:00:05 <lambdabot>  ["this","text"]
06:00:05 <stephano> map (any ((>1) . length) . group . words) <-- is it?
06:00:09 <dcoutts_> @seen newsham
06:00:10 <lambdabot> newsham is in #haskell-blah and #haskell. I last heard newsham speak 9h 16m 1s ago.
06:00:29 <vixey> @let ofThose = (,)
06:00:30 <lambdabot> Defined.
06:00:41 <vixey> > filteringMap (head `ofThose` (>1) . length) . group . words $ ("this " ++ s' ++ " text")
06:00:43 <lambdabot>      precedence parsing error
06:00:43 <lambdabot>         cannot mix `ofThose' [infixl 9] and `(....
06:01:30 <lilac> stephano: the map at the start of that is just so i could run it on multiple strings with one command to lambdabot
06:01:36 <stephano> mh yeah
06:01:41 <stephano> i like my solution because i understand mine
06:01:49 <stephano> lilac: yours is also right?
06:02:54 <stephano> lilac: have you also a version which gives back the list of that words?
06:04:25 <stephano>  (nub . concatMap (\x -> if (length x) > 1 then x else []) . group . words) <---
06:08:50 <vixey> stephano: Do you know what (.) is?
06:09:52 <stephano> sure :]
06:09:55 <stephano> function composition
06:09:59 <chessguy> 'morning
06:10:03 <vixey> ye
06:10:04 <vixey> s
06:10:04 <^Someone^> @let bn 0 = id; let bn n = pair(false,n-1)
06:10:04 <lambdabot>  Parse error
06:10:06 <stephano> vixey: i just wanted to code "a verbose version" to understand
06:10:09 <stephano> now i'm shorting the code
06:10:14 <vixey> hi chessguy
06:10:20 <vixey> stephano: oh ok then
06:10:26 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8120
06:10:30 <stephano> http://hpaste.org/8120
06:10:36 <stephano> vixey: check the paste please :]
06:12:13 <^Someone^> So why doesn't that work?
06:12:32 <stephano> btw concatMap = (concat . map)
06:13:12 <quicksilver> well concatMap f = concat . (map f)
06:13:16 <quicksilver> not quite the same :)
06:13:24 <BMeph> ^Someone^: What's pair, and how does it generate a function? :)
06:13:41 <^Someone^> pair x y z = z(x,y)
06:13:55 <ivanm> ^Someone^: besides, what's false? do you mean False? :p
06:14:04 <^Someone^> false x y = y
06:14:11 <^Someone^> I defined those just now
06:14:15 <^Someone^> (In another channel)
06:14:21 <yitz> @. @pl @src concatMap
06:14:22 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
06:14:23 <ivanm> O...K...
06:14:25 <byorgey> @pl \x y z -> z (x,y)
06:14:26 <lambdabot> (flip id .) . (,)
06:14:27 <ivanm> @src false
06:14:27 <lambdabot> Source not found. :(
06:14:35 <ivanm> ahh, k
06:14:38 <^Someone^> false 1 2
06:14:40 <^Someone^> > false 1 2
06:14:41 <lambdabot>  2
06:14:43 <ivanm> didn't see you paste it back up there
06:14:49 <byorgey> church booleans! =)
06:14:58 <^Someone^> Indeed :D
06:14:59 <ivanm> \o/
06:15:14 <lilac> > head . filter ((>1) . length) . group . words $ "this is text text for stephano, with the word repeated repeated"
06:15:15 <lambdabot>  ["text","text"]
06:15:17 <stephano> is there a group function for three?
06:15:23 <BMeph> Haskellers are very religious, always talking about church and all... ;)
06:15:23 <lilac> > map head . filter ((>1) . length) . group . words $ "this is text text for stephano, with the word repeated repeated"
06:15:25 <lambdabot>  ["text","repeated"]
06:15:31 <stephano> hehe
06:15:44 <^Someone^> Lol
06:15:48 <stephano> lilac: is that better?
06:15:58 <lilac> stephano: you wanted it to return the words
06:16:00 <byorgey> stephano: what do you mean by 'a group function for three'?
06:16:09 <stephano> lilac:
06:16:10 <stephano> i have:
06:16:17 <lilac> stephano: do you understand what group does?
06:16:31 <stephano> > (nub . concatMap (\x -> if (length x) > 1 then x else []) . group . words) "this is text text for me with the word repeated repeated"
06:16:32 <lambdabot>  ["text","repeated"]
06:16:37 <lilac> > group "aaaaa bbb cccccccc dd e ffff g"
06:16:38 <lambdabot>  ["aaaaa"," ","bbb"," ","cccccccc"," ","dd"," ","e"," ","ffff"," ","g"]
06:16:55 <stephano> is that with nub . concatMap bad?
06:17:22 <byorgey> stephano: that concatMap would more naturally be expressed as a filter
06:17:26 <stephano> k
06:17:39 <byorgey> filter ((>1) . length)
06:17:46 <lilac> nub's pretty slow, too, as the list grows large. but you probably don't care about that
06:17:52 <byorgey> well, followed by a concat
06:18:01 <ivanm> nub == O(n^2), does it not?
06:18:06 <byorgey> indeed
06:18:33 <lilac> stephano: for the input "foo foo bar bar foo foo", do you want ["foo","bar"] or ["foo", "bar", "foo"]?
06:18:36 <byorgey> if you want an O(n lg n) nub you can do  map head . group . sort
06:18:45 <byorgey> but of course that changes the order of things
06:18:57 <quicksilver> ivanm: nub = O(n*m) where m is the number of distinct items.
06:19:00 <quicksilver> I think.
06:19:18 <ivanm> quicksilver: well, at worst they're all distinct... so it's O(n^2)
06:19:20 <stephano> okay
06:19:23 <EvilTerran> so, worst case, everything's unique and it's O(n^2)
06:19:24 <chessguy> @src nubBy
06:19:24 <lambdabot> nubBy eq []             =  []
06:19:24 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:19:24 <ivanm> isn't O(...) worst case?
06:19:27 <quicksilver> inded.
06:19:27 <stephano> what then better map head or nub??
06:19:35 <ivanm> EvilTerran: didn't I just say that? :p
06:19:35 <vixey> map head
06:19:37 <quicksilver> ivanm: not necessarily, no.
06:19:39 <stephano> chessguy: ah so i need to use nubBy?
06:19:41 <EvilTerran> ivanm, yeah, you type quicker than I
06:19:43 <stephano> instead of filter?
06:19:43 <quicksilver> O(..) can be what you want it to be.
06:19:45 <chessguy> @src nub
06:19:45 <lambdabot> nub = nubBy (==)
06:19:46 <ivanm> EvilTerran: heh
06:19:50 <vixey> it's a map and a filter
06:19:53 <vixey> you can't espace it
06:19:53 <^Someone^> Sooo
06:19:53 <lilac> nub's O(m^2) where m is the number of initial elements forced, right?
06:19:54 <ivanm> quicksilver: oh? :p
06:19:56 <stephano> so i use
06:19:58 <^Someone^> @let bn 0 = id; let bn n = pair(false,n-1)
06:19:59 <lambdabot>  Parse error
06:19:59 <quicksilver> if you decide to describe the problem more accurately with more variables that's fine.
06:19:59 <lilac> or something like that, at least
06:20:02 <^Someone^> How do I make that work?
06:20:14 <quicksilver> and you will see people say quicksort is O(n log n) average but O(n^2) worst case.
06:20:28 <stephano> map head . filter ( (>1) . length) . group . words
06:20:30 <stephano> and i use now
06:20:38 <vixey> what's pair?
06:20:46 <^Someone^> pair x y z = z(x,y)
06:20:52 <stephano> > nubBy ((>1).length) . group . words "foo foo bar foo bar"
06:20:53 <lambdabot>  Couldn't match expected type `a -> Bool'
06:20:55 <^Someone^> Hint - I'm doing lambda calculus
06:21:03 <chessguy> @pl pair x y z = z (x,y)
06:21:03 <lambdabot> pair = (flip id .) . (,)
06:21:05 <EvilTerran> stephano, if the duplicates are all consecutive, (map head . group) is probably best
06:21:11 <stephano> > nubBy ((>1).length) . group . words $ "foo foo bar foo bar"
06:21:12 <lambdabot>  Couldn't match expected type `a -> Bool'
06:21:21 <stephano> EvilTerran: k
06:21:23 <vixey> what has "pair" got to do with lambda calcuus
06:21:37 <lilac> ^Someone^: you want bn n = pair false (n-1), I think
06:21:50 <EvilTerran> with the appropriate criteria in there
06:22:06 <quicksilver> a traditional question to ask about the lambda calculus is how to implement pairs.
06:22:07 <stephano> EvilTerran: is it fast enough?
06:22:12 <^Someone^> lilac, yes, but then won't it apply false to (n-1)?
06:22:15 <chessguy> @pl pair z x y = z (x y)
06:22:15 <lambdabot> pair = (.)
06:22:26 <quicksilver> so it's discussed in most introductory treatments of lambda calc
06:22:30 <quicksilver> there is more than one possible way :)
06:22:30 <frwmanners> EvilTerran: Is elems . Set.fromList going to work?
06:22:31 <chessguy> @pl pair z x y = z (x, y)
06:22:31 <lambdabot> pair = (. (,)) . (.)
06:22:42 <EvilTerran> if they're not consecutive, nub is good if you need to preserve order, otherwise (map head . group . sort) is better owing to better complexit
06:22:42 <EvilTerran> yt
06:22:44 <^Someone^> vixey, tha's how you define a list [x,y]
06:22:48 <^Someone^> Well, that's one way
06:22:51 <lilac> ^Someone^: no, bn n would then be the function \z -> z false (n-1)
06:23:12 <lilac> ^Someone^: (assuming your definition of pair is pair x y z = z x y)
06:23:13 <EvilTerran> frwmanners, that would work, yes, but i'd say (map head.group.sort) is probably more elegant
06:23:21 <^Someone^> Yes, lilac
06:23:21 <^Someone^> Okay
06:23:26 <EvilTerran> seeing as it doesn't throw another data type in there
06:23:26 <^Someone^> @let bn 0 = id; let bn n = pair false n-1)
06:23:27 <lambdabot>  Parse error
06:23:31 <^Someone^> :\
06:23:34 <EvilTerran> and they'll both be O(n.log n)
06:23:38 <^Someone^> @let bn 0 = id;let bn n = pair false n-1)
06:23:38 <lambdabot>  Parse error
06:23:39 <frwmanners> EvilTerran: with sort first, you're sorting a larger list than you need to, I think
06:23:42 <^Someone^> @let bn 0 = id;bn n = pair false n-1)
06:23:42 <lambdabot>  Parse error
06:23:45 <^Someone^> Eh
06:24:04 <vixey> it's not
06:24:05 <frwmanners> EvilTerran: It's a question of whether we mean n = no of elements or n = no of distinct elements
06:24:15 <vixey> \car cdr -> \selector -> selector car cdr
06:24:16 <EvilTerran> frwmanners, eh. constant factors. :P
06:24:18 <vixey> use this instead
06:24:24 <vixey> :t \car cdr -> \selector -> selector car cdr
06:24:26 <lambdabot> forall t t1 t2. t -> t1 -> (t -> t1 -> t2) -> t2
06:24:27 <quicksilver> EvilTerran: may not be a constant factor :)
06:24:31 <vixey> @src []
06:24:31 <lambdabot> data [] a = [] | a : [a]
06:24:52 <frwmanners> EvilTerran: Is it possible to have it linear in n, i.e. total length, but m log m in m, i.e. no of distinct elems?
06:25:34 <EvilTerran> ... i guess that's your Set version
06:25:45 <frwmanners> EvilTerran: Ok
06:25:49 <EvilTerran> or you could use a Map String Int, if you wanted to count duplicates
06:26:23 <lilac> ^Someone^: bn isn't well-typed, so you're going to have trouble...
06:26:36 <^Someone^> I'm new to Haskell
06:26:38 <^Someone^> And to lambdabot
06:26:56 <lilac> you're missing the ( before n-1 too :)
06:26:57 <stephano> > map (!!0) [ [1,2], [3,4]]
06:26:59 <lambdabot>  [1,3]
06:27:02 <^Someone^> OH
06:27:04 <^Someone^> Yeah
06:27:06 <stephano> hehe !!0 looks more evil then head
06:27:13 <^Someone^> @let bn 0 = id; let bn n = pair false (n-1)
06:27:13 <lambdabot>  Parse error
06:27:26 <EvilTerran> frwmanners, ie: assocs . foldr (\k -> insertWith (+) k 1) empty
06:27:27 <^Someone^> Grrrrr
06:27:31 <^Someone^> What is the format?
06:27:54 <EvilTerran> ?type assocs . foldr (\k -> insertWith (+) k 1) empty
06:27:56 <lambdabot> Not in scope: `insertWith'
06:28:33 <frwmanners> EvilTerran: Ah.  Cunning
06:28:40 <EvilTerran> ?type Data.Map.assocs . foldr (\k -> Data.Map.insertWith (+) k 1) Data.Map.empty
06:28:42 <lambdabot> forall a a1. (Ord a, Num a1) => [a] -> [(a, a1)]
06:29:10 <frwmanners> EvilTerran: Um, how does that initialize to zero?
06:29:41 <EvilTerran> insertWith puts the given value in if the key didn't already exist, otherwise combines the old and new values with the operator
06:29:51 <stephano> lilac: :)
06:30:07 <frwmanners> EvilTerran: ok
06:30:33 <hpaste>  mix25 pasted "(no title)" at http://hpaste.org/8121
06:30:45 <mix25> Someone can help me?
06:31:10 <EvilTerran> anyway, i think that'd be O(l + n*log n) where l = length xs; n = length (nub xs) -- if you force the entire output list, anyway
06:31:20 <maltem> mix25, forgot "="?
06:31:32 <mix25> foldr = ?
06:31:39 <EvilTerran> actually, probably even if you don't, seeing as i think Maps are spine-strict (or whatever the term is)
06:31:53 <mix25> ctctctct ok
06:31:56 <mix25> thanks
06:32:15 <stephano> > map (!!0) . filter ((>1) . length) . group . words . map (\x -> if (x /= '.' && x /= ',' && x /= '?' && x /= '!' && x /= ';' && x /= ':') then x else ' ') $ "this this is a a text for me for testing" -- eliminates bad character like ; , ! ? etc..
06:32:16 <lambdabot>  ["this","a"]
06:32:18 <mix25> no
06:32:39 <stephano> can i somehow shorten the last map?
06:33:00 <ivanm> @pl \x -> if (x /= '.' && x /= ',' && x /= '?' && x /= '!' && x /= ';' && x /= ':') then x else ' '
06:33:00 <lambdabot> flip (if' =<< liftM2 (&&) ('.' /=) (liftM2 (&&) ((',') /=) (liftM2 (&&) ('?' /=) (liftM2 (&&) ('!' /=) (liftM2 (&&) (';' /=) (':' /=)))))) ' '
06:33:03 <mix25> :i foldr
06:33:03 <ivanm> lol
06:33:05 <opqdonut> stephano: not $ x `elem` ".,?!"
06:33:18 <stephano> ah so not $ x `elem` ";-,!?"?
06:33:22 <ivanm> yeah, what opqdonut said :p
06:33:31 <opqdonut> yeh
06:33:37 <opqdonut> that's a handy trick
06:33:41 <mix25> maltem, is not the "=" symbol.
06:33:53 <stephano> mh it won't work??
06:33:59 <stephano> > not $ "foo,bar" `elem` ";-!?"
06:34:00 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
06:34:16 <maltem> mix25, what are you going to tell me?
06:34:16 <stephano> > not $ "foo,bar" `elem` [',', '?']"
06:34:17 <lambdabot>  Improperly terminated string at """ (column 34)
06:34:20 <stephano> > not $ "foo,bar" `elem` [',', '?']
06:34:21 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
06:34:46 <opqdonut> stephano: you want letter `elem`
06:34:49 <opqdonut> not word `elem`
06:35:15 <mix25> I need help with this code:  http://hpaste.org/8121   and you answer me : "="
06:35:21 <opqdonut> stephano: you might also like
06:35:24 <opqdonut> > intersect "foo,bar" ",.?!" -- this
06:35:25 <lambdabot>  ","
06:35:31 <opqdonut> for testing a whole string
06:36:18 <maltem> mix25, because a "=" is clearly missing. I didn't say that's the only thing what is missing
06:36:35 <stephano> opqdonut: ah okay
06:36:48 <stephano> i just wondered how `elem` would operate on lists
06:36:52 <stephano> intersect haha
06:36:53 <mix25> now is returning me type error
06:36:57 <mix25> in same line
06:37:06 <maltem> mix25, what is that code for?
06:37:13 <mix25> perms
06:37:13 <stephano> ah i need flip
06:37:15 <stephano> do i?
06:37:18 <mix25> permuts
06:37:19 <mix25> *
06:37:24 <quicksilver> mix25: you appear to have given foldr only 1 parameter
06:37:29 <quicksilver> mix25: foldr takes 3 parameters.
06:37:34 <stephano> (flip . intersect ",.?!") "foo,bar"
06:37:40 <stephano> > (flip . intersect ",.?!") "foo,bar"
06:37:40 <lambdabot>  Couldn't match expected type `a -> b -> c'
06:37:41 <^Someone^> @let bn 0 = id; bn n = pair false (n-1)
06:37:42 <lambdabot> <local>:1:18: Not in scope: `pair'  <local>:1:23: Not in scope: `false'
06:38:00 <quicksilver> mix25: I also don't know how you fixed that line....
06:38:14 <maltem> mix25, I meant as in, what are you doing this for, because it looks like you don't understand what you wrote yourself
06:38:43 <mix25> i'm not wrote this
06:38:56 <mix25> is the solution of my fu**ng teacher
06:39:22 <^Someone^> @let bn 0 = id; bn n = pair false(n-1)
06:39:22 <lambdabot> <local>:4:18:     Occurs check: cannot construct the infinite type:       t =...
06:39:24 <^Someone^> What?
06:39:26 <maltem> mix25: Then tell your teacher that his solution is wrong :)
06:39:39 <mix25> Have not time man.
06:39:43 <mix25> I*
06:40:34 <mix25> if i'd time , i'd kick her ass :P
06:40:54 <mix25> his
06:40:56 <mix25> *
06:41:00 <vixey> ...
06:42:21 <stephano> opqdonut: i want to substitute all ,;:?! in the string with spaces
06:42:25 <stephano> so i used that map
06:42:44 <stephano> > map (\x -> if (x /= '.' && x /= ',' && x /= '?' && x /= '!' && x /= ';' && x /= ':') then x else ' ') $ "foo,;,bar?!"
06:42:46 <lambdabot>  "foo   bar  "
06:42:52 <stephano> how to shorten?
06:42:53 <vixey> > map (\x -> if x`elem`",;:?!" then ' ' else x) ",;:?!,oeau;eou:eo?ua!eouaeuoa,;:?!"
06:42:54 <lambdabot>  "      oeau eou eo ua eouaeuoa     "
06:43:01 <stephano> -.-
06:43:16 <stephano> maybe filter?
06:43:26 <opqdonut> no, that doesn't replace
06:43:35 <stephano> ahh
06:43:37 <stephano> true
06:43:39 <vixey> stephano: map (\x -> if x`elem`",;:?!" then ' ' else x) ",;:?!,oeau;eou:eo?ua!eouaeuoa,;:?!"
06:43:46 <stephano> yeah i see
06:43:52 <opqdonut> you want something like "maybeMap :: (a -> Maybe a) -> [a] -> [a]
06:43:57 <stephano> but i mean deleting spaces is stupid because the text gets bad then
06:44:00 <opqdonut> if you want to make it nice
06:44:01 <vixey> filteringMap
06:44:08 <quicksilver> opqdonut: which you can do pretty much with concatMap
06:44:12 <opqdonut> yeah, true
06:44:14 <EvilTerran> ?hoogle catMaybes
06:44:15 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
06:44:19 <mix25> in which module is defined permuts :: [a] -> [[a]] ?
06:44:26 <vixey> mix25: none
06:44:28 <lilac> @hoogle (a -> Bool) -> [a] -> [[a]]
06:44:29 <lambdabot> Distribution.Simple.Utils.breaks :: (a -> Bool) -> [a] -> [[a]]
06:44:30 <EvilTerran> opqdonut, (catMaybes . map f) works, too
06:44:35 <lilac> @hayoo (a -> Bool) -> [a] -> [[a]]
06:44:36 <lambdabot> Unknown command, try @list
06:44:38 <quicksilver> :t mapMaybe
06:44:40 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
06:44:45 <opqdonut> EvilTerran: no it won't
06:44:47 <quicksilver> mapMaybe does actually exist :)
06:44:53 <mix25> sure=
06:44:54 <mix25> ?
06:44:55 <EvilTerran> no?
06:45:00 <opqdonut> i meant that an element is Maybe modified
06:45:00 <quicksilver> mix25: Yes.
06:45:02 <vixey> mix25: yes
06:45:04 <mix25> ok
06:45:07 <EvilTerran> ohhhh, i see
06:45:09 <opqdonut> if f returns Nothing the original is retained
06:45:14 <stephano> nice
06:45:19 <stephano> haskell is handy
06:45:20 <opqdonut> which is what stephano's usecase would need
06:45:29 <EvilTerran> ?type (fromMaybe <*>)
06:45:31 <lambdabot> forall a. (a -> Maybe a) -> a -> a
06:45:35 <quicksilver> opqdonut: ah, not.
06:45:39 <quicksilver> nod.
06:45:49 <EvilTerran> ?type map . (fromMaybe <*>)
06:45:51 <lambdabot> forall a. (a -> Maybe a) -> [a] -> [a]
06:46:03 <opqdonut> ah
06:46:05 <EvilTerran> owzat?
06:46:31 <opqdonut> yeah, that does it :)
06:46:38 <quicksilver> EvilTerran++
06:46:40 <EvilTerran> :D
06:46:52 <EvilTerran> yay for the S combinator!
06:49:07 <opqdonut> ah, that <*> is just ap in the r-> functor :D
06:49:11 <mm_freak_work> yesterday i've compared my STUArray sieve of eratosthenes <http://hpaste.org/7984> to an equivalent i've written in C <http://nopaste.de/p/aEXQYIO3y>
06:49:14 <opqdonut> fuddled me for a moment
06:49:22 <EvilTerran> opqdonut, exactly. (fromMaybe <*> f) x = fromMaybe x (f x)
06:49:29 <mm_freak_work> the C version is much faster than the haskell versionâ¦  does anyone have hints for speeding the haskell version up?
06:49:33 <opqdonut> EvilTerran: yeah, S
06:49:42 <jkff> > let p = ",;:!. "
06:49:42 <lambdabot>  Parse error at end of input
06:49:43 <EvilTerran> which is exactly what we need
06:49:46 <jkff> > let p = ",;:!. ";
06:49:47 <lambdabot>  Parse error at end of input
06:49:51 <jkff> Hmm
06:50:10 <jkff> > let x = 1 in x + 1
06:50:11 <lambdabot>  2
06:50:12 <EvilTerran> jkff, the syntax for giving bindings to lambdabot is @let ...
06:50:15 <mm_freak_work> as far as i see, it's almost at its edge, but maybe i've overlooked something
06:50:17 <jkff> Thanks
06:50:17 <EvilTerran> (with no "in")
06:50:28 <EvilTerran> also, you can talk to her via private message
06:50:28 <jkff> @let p=",;:!. "
06:50:29 <lambdabot> Defined.
06:51:15 <smg> hey vixey how are you buddy?
06:51:30 <smg> guess what my teacher said today O(n^3) is good for a sorting algorithm -.-
06:51:35 <smg> O(n^3) :|
06:51:35 <jkff> > unwords . takeWhile (not . null) . tail . map fst . iterate (break (`elem` p) . dropWhile (`elem` p) . snd) . ((,) "") $ "Hello , my good!!! world."
06:51:36 <lambdabot> Terminated
06:51:36 <vixey> lol
06:51:45 <jkff> Hmm, worked in ghci
06:51:46 <smg> i mean that IS funny :)
06:51:50 <quicksilver> mm_freak_work: there is a very long and involved thread about what counts as a true sieve, if you're interested in such thinks.
06:52:55 <quicksilver> mm_freak_work: how much is the difference in speed?
06:53:19 <mm_freak_work> quicksilver: where do i find it?  the difference is a linear factor, so i'm sure they're equivalent
06:53:26 <mm_freak_work> at home it was around 10-15
06:55:00 <maltem> mm_freak_work: What input(s) are you testing with?
06:55:02 <quicksilver> mm_freak_work: the first thing that springs to mind is your C code is not doing bounds checks on each array access
06:55:06 <quicksilver> while your haskell code is.
06:56:08 <quicksilver> the second thing is I would strong suspect that haskell doesn't generate the best code to access bit arrays compared to your nice C code.
06:56:22 <mm_freak_work> maltem: from 10^7 up
06:56:22 <vixey> smg: http://www.e-pig.org/downloads/notanum.pdf
06:56:55 <quicksilver> mm_freak_work: see how much unsafe read/write helps.
06:57:02 <mm_freak_work> quicksilver: the memory usage suggests that GHC is doing the right thing (i.e. implementing it as a real bit array)
06:57:03 <Baughn> @src words
06:57:04 <lambdabot> words s = case dropWhile isSpace s of
06:57:04 <lambdabot>     "" -> []
06:57:04 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:57:50 <quicksilver> mm_freak_work: yeah, but I think it will be doing the wrong thing when looking up :)
06:57:52 <frevidar> smg: good way to keep your teacher busy: shuffle a pack of cards and ask your teacher to sort them
06:58:02 <quicksilver> mm_freak_work: it won't generate such simple elegant bit acces opcodes. I fear.
06:58:13 <quicksilver> mm_freak_work: it might be interesting to compile with -fvia-C and see if that's better.
06:58:50 <mm_freak_work> true, i'll test that one
06:59:15 <quicksilver> unsafeRead/Write should make a pretty big difference, I would hope.
06:59:27 <frevidar> is ghc c output somewhat readable or ugly as anything?
07:00:02 <frevidar> looking at the c output might give you an idea about the difference
07:00:36 <quicksilver> GHC doesn't produce C output by default.
07:01:15 <smg> frevidar: hahaaha :)
07:01:40 <smg> btw i got him today, i asked about foldr and foldl etc :) he could not figure out differences :|
07:01:45 <frevidar> doesn't -fvia-c do that?
07:01:53 <quicksilver> yes.
07:01:56 <quicksilver> "by default"
07:01:56 <quicksilver> ;)
07:02:02 <frevidar> ok...
07:04:20 <smg> he has an intersting code to check if a list is empty
07:04:32 <vixey> (==[])
07:04:36 <smg> no :)
07:04:49 <smg> empty [] = []
07:04:57 <smg> eh empty [] = True
07:05:06 <opqdonut> heh
07:05:10 <hpaste>  frevidar pasted "How to write a explicit type signature for tridiagonal_solve (and gen_matrix)" at http://hpaste.org/8122
07:05:13 <vixey> is that it?
07:05:16 <smg> empty (x:xs) = if x /= [] || xs /= [] then False else True
07:05:22 <smg> vixey: that it is :D
07:05:23 <vixey> o______________o
07:05:25 <opqdonut> smg: whaat :D
07:05:29 <nornagon> wtf
07:05:30 <smg> nice code is it?
07:05:34 <vixey> no
07:05:43 <smg> hehe true :)
07:05:48 <frevidar> if someone could check out that paste, it would much appreciated
07:05:53 <opqdonut> :t let empty (x:xs) = if x /= [] || xs /= [] then False else True in empty
07:05:55 <nornagon> empty [] = True
07:05:55 <lambdabot> forall a. (Eq a) => [[a]] -> Bool
07:05:57 <Socrates> Is this a school teacher or a university lecturer, smg?
07:05:58 <nornagon> empty _ = False
07:06:04 <opqdonut> yep, it checks for [] and [[]]
07:06:05 <smg> university lecturer
07:06:09 <ddarius> :t null
07:06:10 <^Someone^> vixey, why does this not work? Orlando *9mil says (9:54 AM):
07:06:10 <^Someone^> I don't want it to be just about German
07:06:11 <lambdabot> forall a. [a] -> Bool
07:06:15 <Socrates> Christ.
07:06:28 <smg> hehe
07:06:44 <^Someone^> @let bn 0 = id; bn n = pair false(n-1)
07:06:44 <lambdabot> <local>:5:18:     Occurs check: cannot construct the infinite type:       t =...
07:06:48 <^Someone^> What???
07:07:40 <mxc> are datagram sockets not generally supported?
07:07:47 <mxc> as in, not on OS X?
07:08:08 <mxc> (internal, UNIX sockets)
07:08:54 <smg> Socrates: it's really bad, he translates all englisch stuff like weak head normal form to german and so i don't understand it good
07:09:02 <vixey> ^Someone^: I don't think you should use haskell to do this
07:09:13 <vixey> the types are too restrictive
07:09:20 <Socrates> It sounds like your university needs to do some "human resource reshuffling"
07:09:35 <kaol> is there any reason why I couldn't use StateT on the Q monad of Template Haskell?
07:09:41 <Socrates> read: Get him teaching the numpty modules like "Digital e-business"
07:09:52 <smg> vixey: your document IS insane good :)
07:10:03 <smg> Socrates: haha i would say yes
07:10:32 <anakin_> what tutorial/books would you recommend?
07:10:50 <quicksilver> mm_freak_work: I find unsaferead/write is about 30% faster
07:10:59 <quicksilver> mm_freak_work: still comes in at 8 times slower than C though
07:11:03 <Socrates> anakin_: For what level of Haskell?
07:11:09 <MedeaMelana> @pl \x y -> fromJust (followM x y)
07:11:10 <lambdabot> (fromJust .) . followM
07:11:25 <vixey> level aleph 1
07:11:44 <quicksilver> anakin_: Hutton. Hudak.
07:11:46 <anakin_> Socrates: begginer
07:12:00 <anakin_> with tons of OOP background :\
07:12:09 <quicksilver> anakin_: http://www.haskell.org/haskellwiki/Books
07:12:10 <lambdabot> Title: Books - HaskellWiki
07:12:11 <Socrates> Programming in Haskell then
07:12:21 <Socrates> By G. Hutton
07:12:37 <anakin_> thanks
07:12:44 <mm_freak_work> quicksilver: how can i do unsafe writing/reading?
07:13:06 <quicksilver> O'Sullivan, Stewart and Goerzen
07:13:15 <kaol> I wonder how that would work along with the splice operations and quasiquotes...
07:13:15 <quicksilver> mm_freak_work: http://www.haskell.org/haskellwiki/Modern_array_libraries
07:13:17 <lambdabot> Title: Arrays - HaskellWiki
07:13:19 <quicksilver> when it comes out.
07:13:22 <anakin_> well I've gone through the main tutorials on the site but I'd like somehting better
07:13:42 <paczesiowa> is it possible to make (id, id) of type (a -> a, a -> a) without giving explicit type signature?
07:14:08 <vixey> :t (\id -> (id, id)) id
07:14:10 <lambdabot> forall a. (a -> a, a -> a)
07:14:20 <Socrates> If you interested in the mathematical basis; not just Haskell specific, Bird is worth while read too
07:14:26 <MedeaMelana> @hoogle Either String a -> a
07:14:27 <lambdabot> No matches, try a more general search
07:15:05 <MedeaMelana> Is there something like
07:15:06 <MedeaMelana> fromEither :: Either String a -> a
07:15:06 <MedeaMelana> fromEither (Left msg) = error msg
07:15:06 <MedeaMelana> fromEither (Right x) = x
07:15:07 <MedeaMelana> ?
07:15:07 <paczesiowa> vixey: how about if we had id1 and id2?
07:15:18 <MedeaMelana> Already available I mean
07:15:24 <tromp> :t (id,id)
07:15:26 <lambdabot> forall a a1. (a -> a, a1 -> a1)
07:15:49 <vixey> :t (,)
07:15:52 <lambdabot> forall a b. a -> b -> (a, b)
07:16:01 <vixey> > let (*) = (,) :: a -> a -> (a,a) in (id*id)
07:16:02 <lambdabot>  Add a type signature
07:16:27 <vixey> :t let (*) = ((,) :: a -> a -> (a,a)) in (id*id)
07:16:29 <lambdabot> forall a. (a -> a, a -> a)
07:16:58 <paczesiowa> :t let id1 = id in let id2 = id . id in (id1, id2)
07:16:59 <quicksilver> :t either error
07:17:00 <lambdabot> forall a a1. (a -> a, a1 -> a1)
07:17:01 <lambdabot> forall c b. (b -> c) -> Either [Char] b -> c
07:17:03 <quicksilver> :t either error id
07:17:06 <lambdabot> forall b. Either [Char] b -> b
07:17:13 <quicksilver> MedeaMelana: there you go :)
07:17:23 <MedeaMelana> Thanks :-)
07:17:39 <vixey> Define a new tuple constructor which has type a -> a -> (a,a)
07:18:09 <phlpp> - _ -
07:18:19 <phlpp> byorgey: hi
07:18:25 <phlpp> byorgey: why not idling #go? :>
07:18:31 <byorgey> hi phlpp
07:18:39 <byorgey> there's a #go channel? o.O
07:18:42 <phlpp> there is!
07:18:43 <vixey> hi byorgey
07:18:52 <paczesiowa> if only I needed it to play with id and tuples:P, but thanks vixey, I'll try that
07:18:57 <BMeph> mm_freak_work: Have you checked out Oleg's version? ;)
07:19:04 <phlpp> byorgey: i'm now really addicted to go.. thanks to you -_-
07:19:05 <phlpp> :>
07:19:07 <byorgey> hi vixey
07:19:17 <byorgey> phlpp: awesome! =D
07:19:27 <vixey> byorgey: I finally got to the end of the paper I linked :p
07:19:41 <vixey> did you like it ?
07:19:54 <byorgey> vixey: the "general recursion via coinductive types" one?
07:20:00 <vixey> yes
07:20:07 <paczesiowa> BMeph: of which of thousands Oleg's papers are you talking about?
07:20:14 <byorgey> vixey: I don't know, I haven't read it.  would you recommend it?
07:20:29 <quicksilver> paczesiowa: sieve of eratosthenes
07:20:41 <vixey> well It was a bit hard for me .. but after I read this http://www.megacz.com/research/plpv07-megacz.pdf it made sense
07:20:44 <paczesiowa> in a type system?
07:21:29 <byorgey> cool, I will check that one out as well
07:21:55 <byorgey> btw, Agda just got coinductive types!
07:21:57 <quicksilver> mm_freak_work: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
07:21:57 <lambdabot> Title: [Haskell-cafe] Re: Genuine Eratosthenes sieve [Was: Optimization fun], http://tinyurl.com/yphbu2
07:22:03 <quicksilver> mm_freak_work: is one of the many threads
07:22:08 <vixey> now the fun bit is figuring out how to use the stuff from the paper :p
07:22:25 <vixey> hmmmm
07:22:37 <vixey> I still don't understand why coinduction is ok
07:23:09 <byorgey> vixey: what do you mean by 'ok'?
07:23:34 <vixey> I mean doesn't introduce inconsistency
07:23:47 <hkBst> is there a prelude function like filter and map, that uses pairs (False, ignored), (True, new-value) to decide whether to filter or map each value?
07:23:55 <mm_freak_work> BMeph: do you have a reference?
07:24:09 <quicksilver> hkBst: filter fst ?
07:24:11 <frevidar> any ideas on http://hpaste.org/8122 anyone?
07:24:13 <quicksilver> hkBst: map snd . filter fst?
07:24:46 <mm_freak_work> quicksilver: regarding that, btw, mine _is_ a real sieve
07:24:53 <mm_freak_work> not just a filter
07:25:24 <quicksilver> mm_freak_work: yeah, I know.
07:25:32 <quicksilver> mm_freak_work: I just thought you'd find the thread interesting.
07:25:52 <quicksilver> mm_freak_work: some parts of that do talk about optimisation
07:25:58 <quicksilver> (or was it another thread?)
07:26:01 <quicksilver> there have been many.
07:27:45 <hkBst> quicksilver: right :) I could first map the function that creates the pairs and then filter it. It would be a little bit less efficient though, won't it?
07:27:59 <quicksilver> hkBst: not really, no.
07:28:05 <quicksilver> hkBst: a preluade function would jsut be clunky.
07:28:12 <quicksilver> it would be no more efficient than what I wrote.
07:28:35 <quicksilver> frevidar: do you not like the type ghci gives you when you ask it.
07:28:44 <mm_freak_work> quicksilver: i've read many things about fast arrays
07:28:59 <EvilTerran> hkBst, how about (\xs -> [x | (True, x) <- xs])?
07:29:01 <mm_freak_work> and the one you see in hpaste is the fastest one i've come up with
07:29:07 <frevidar> quicksilver: when I use the type ghci gives it still fails to compile
07:30:15 <mm_freak_work> quicksilver: one reason why the C version is much faster is that it accesses the array directly
07:30:28 <mm_freak_work> no wrapper functions and no bounds checks
07:30:52 <quicksilver> mm_freak_work: well yes, that's one of the things I said to you :)
07:31:01 <quicksilver> mm_freak_work: unsafe will at least turn off the bounds checks.
07:31:11 <mm_freak_work> yes, you mentioned the bounds checks
07:31:14 <quicksilver> mm_freak_work: but I still don't think it will get the bit twiddling as efficient as it could.
07:31:36 <quicksilver> unsafe gave me a 20%-30% improvement
07:32:08 <mm_freak_work> quicksilver: how did you do the unsafe stuff?
07:32:19 <mm_freak_work> i can't find anything in Data.Array.MArray
07:32:32 <mxc> its Network.Socket a work in progress with respect to Datagram sockets?  I get "operation not supported" errors whenever I make the call to listen on a datagram socket
07:32:42 <quicksilver> mm_freak_work: the details are in the link I pasted you, taht's why I pasted it.
07:32:48 <quicksilver> mm_freak_work: they're in Data.Array.Base IIRC
07:33:19 <mm_freak_work> can't find that one
07:34:03 <hpaste>  frevidar pasted "GHCi suggest signature that fails to compile" at http://hpaste.org/8123
07:34:41 <frevidar> quicksilver: I've inserted into the signature the sig GHCi suggests, but it still gives an error on compiling
07:34:58 <quicksilver> frevidar: yes, I tried that too.
07:35:03 <quicksilver> frevidar: I'm a bit confused now.
07:35:20 <quicksilver> frevidar: the inferred signature for me mentions an unused a6 for example.
07:35:21 <vixey> why do you want to annotate it?
07:35:24 <quicksilver> frevidar: it might even be a bug.
07:36:08 <frevidar> vixey: I figure its not good if I can't even work out the type signature
07:36:20 <vixey> I don't think it matters
07:36:27 <quicksilver> I disagree strongly.
07:36:32 <quicksilver> there is something odd going on here.
07:36:33 <byorgey> yeah, that suggested signature doesn't really look right anyway.
07:36:39 <quicksilver> frevidar: I think you should mail the cafe or open a bug.
07:36:42 <quicksilver> something's not right there :)
07:37:13 <frevidar> wow, I just got started :-)
07:37:29 <frevidar> I was going to start building a whole crank nicolson scheme
07:37:49 <frevidar> I'll put in the bug report
07:38:00 <frevidar> are there any other compilers that could compile this code?
07:38:09 <vixey> can't you compile it already?
07:38:11 <frevidar> well, actually
07:38:14 <frevidar> I can compile it
07:38:17 <vixey> ok
07:38:18 <frevidar> without the sig
07:38:43 <EvilTerran> what compile error happens with the sig in place?
07:39:05 <frevidar> evilterran: its big
07:39:27 <smg> someone knows what "rÃ¼ckgrat evaluation" means in context with lists @ haskell?
07:39:41 <frevidar> I'll paste it
07:40:46 <hpaste>  frevidar pasted "Compile error with ghci signature" at http://hpaste.org/8124
07:40:49 <byorgey> @babel de en rÃ¼ckgrat
07:40:50 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
07:40:54 <byorgey> argh
07:41:05 <vixey> spine
07:41:10 <frevidar> evilterran: the error is in the recent paste
07:41:30 <byorgey> ah, spine
07:41:42 <smg> byorgey: the lecturer does translate all english stuff to german, and that german words are really obscure so you don't know what it is if you read it
07:41:51 <quicksilver> smg: the spine is the shape of the list
07:41:55 <byorgey> hehe
07:41:57 <quicksilver> all the : in it
07:42:02 <quicksilver> but not the actual values
07:42:08 <vixey> _:_:_:_:_:_:_:_:_:_:_:_:_:_:_:[]
07:42:12 <quicksilver> exactly.
07:42:22 <quicksilver> when you call "length" on a list, haskell is forced to evaluate the spine
07:42:23 <smg> it's spine evaluation then?
07:42:28 <quicksilver> but not necessarily the values.
07:42:33 <smg> ah
07:42:35 <quicksilver> well I'm guessing that's what he means.
07:42:37 <smg> thats rÃ¼ckgrat evaluation?
07:42:42 <quicksilver> maybe, maybe not :)
07:42:48 <quicksilver> maybe it translates into a different english term.
07:43:09 <byorgey> hm, _:_:_:_:_:_:_:_:_ kind of looks like a spine =)
07:43:27 <HunterXHunter> ascii art :P
07:43:35 <smg> btw what's simply and fully evaulated lists?
07:44:00 <quicksilver> fully evaluated means you have evaluated the whole thing.
07:44:07 <byorgey> fully evaluated probably means what it says, i.e. the list contains no thunks whatsoever.  the spine as well as the values have been evaluated.
07:44:09 <quicksilver> "simply" out of context, I have no idea.
07:44:18 <byorgey> maybe it means whnf?
07:44:26 <smg> yeah byorgey that is my problem
07:44:35 <byorgey> whnf = weak head normal form, i.e. evaluating just enough to know what the first constructor is
07:44:35 <smg> i now that normal forms etc, but he uses this stupid german words...
07:44:44 <byorgey> so in the case of a list you would have _:?
07:44:54 <byorgey> er, I should say (x1:x2)
07:45:01 <byorgey> where x1 and x2 might be unevaluated thunks
07:45:07 <smg> byorgey: thank you and if we have evaluatted all we are at the normal form
07:45:12 <solrize> rÃ¼ckgrat sounds like "retrograde" but i've never heard of retrograde evaluation
07:45:14 <smg> and there is no thunk / redex to evaluate
07:45:27 <byorgey> smg: right, normal form == fully evaluated
07:45:37 <Lavos^> Can anyone help me with a rather big problem I'm having? :x
07:45:37 <smg> solrize: i sounds like "reek rate"
07:45:45 <smg> solrize: it :)
07:45:59 <quicksilver> Lavos^: until you tell us what it is, no.
07:46:14 <frevidar> quicksilver: what do you think the type signature should be?
07:46:21 <frevidar> as in, the most general it can be?
07:46:22 <byorgey> Lavos^: what's the problem?
07:46:32 <solrize> rnf = reduced normal form = fully evaluated, no thunks
07:46:50 <smg> k
07:47:00 <Lavos^> Well, first GHC wouldn't build from source, and I had to comment out the docs install lines for it to finally install, and now I'm getting the following for everything:
07:47:02 <smg> so if i print [1..10] on a ghci terminal it will be _fully_ evaluated
07:47:04 <solrize>  http://en.wiktionary.org/wiki/R%C3%BCckgrat aha
07:47:04 <lambdabot> Title: RÃ¼ckgrat - Wiktionary
07:47:07 <Lavos^> ghc-6.9.20080603: panic! (the 'impossible' happened)
07:47:07 <Lavos^>   (GHC version 6.9.20080603 for i386-unknown-linux):
07:47:07 <Lavos^> 	interactiveUI:setBuffering2
07:47:08 <solrize> spine
07:47:10 <smg> if i do length [1..10] it will be spine evaluated
07:47:13 <mxc> ok
07:47:15 <mxc> i'm an idiot
07:47:39 <smg> and if i do empty (x:_) = True it will be head evaulated i.e. wkf
07:47:40 <smg> ?
07:47:42 <vixey> mxc: if you are an idiot would it really be wise to trust your own judement about that?
07:48:12 <mxc> vixey> my idiocy has a limited domain.  i'd like to think that i'm actually quite adept at spotting idiots
07:48:13 <byorgey> smg: right.
07:48:43 <byorgey> smg: in the case of length [1..10] there's actually no difference between spine and full evaluation since the numbers have to be evaluated anyway (to see when the list is ended).
07:48:48 <byorgey> smg: but that's the right idea. =)
07:50:13 <lilac> > length . map (const undefined) $ [1 .. 10]
07:50:28 <lambdabot>  10
07:50:43 <byorgey> Lavos^: looks like a bug in ghc HEAD.  if I were you I'd try the #ghc channel, or the ghc mailing list.
07:50:57 <byorgey> Lavos^: is there some reason you need to use a bleeding-edge version of ghc?
07:52:19 <lilac> is there a 'strong head normal form'?
07:52:46 <Lavos^> Well there's a bug in 6.8.2, which prevents me from using the only thing I need GHC for.
07:53:03 <Lavos^> Which is fixed in the head, so sayth the ticket.
07:53:05 <byorgey> Lavos^: fair enough.
07:53:48 <vixey> lilac: normal form
07:53:52 <byorgey> Lavos^: I'm not saying this is an inappropriate place to ask, but you'll probably have more luck asking in a ghc-specific forum
07:54:06 <vixey> normal form vs weak (head normal) form
07:54:07 <Lavos^> Yeah, sorry.
07:54:46 <byorgey> Lavos^: no, no need to apologize, I said this *isn't* an inappropriate place to ask =)
07:55:27 <Lavos^> I couldn't see an IRC on GHC's website, so I went Google'ing and this was the first, and only, channel to do with GHC I can find. :P
07:55:37 <Lavos^> I could find*
07:56:10 <paczesiowa> vixey: how about this: I want to unify only endings of terms:
07:56:12 <paczesiowa> :t let f = undefined :: Int -> a -> a in let g = undefined :: String -> Char -> a -> a in (f,g)
07:56:14 <lambdabot> forall a a1. (Int -> a -> a, String -> Char -> a1 -> a1)
07:56:27 <byorgey> Lavos^: well, maybe it is not well advertised.  but there is indeed a #ghc channel.
07:56:44 <byorgey> lots of really smart people hang out there. =)
07:56:46 <vixey> a -> b -> c = a -> (b -> c)
07:57:08 <hkBst> > let transform g [] = []; transform g (x:xs) = let gx = g x in if fst gx then snd gx : transform g xs else transform g xs
07:57:08 <lambdabot>  Parse error at end of input
07:57:22 <hkBst> > let transform g [] = []; transform g (x:xs) = let gx = g x in if fst gx then snd gx : transform g xs else transform g xs in transform (\x -> (even x, x)) [1..10]
07:57:23 <lambdabot>  [2,4,6,8,10]
07:57:42 <paczesiowa> vixey: I know, so it would be easier to unify beginnings, right?
07:57:48 <lilac> vixey: ok, so it's "weak (==head) normal form" rather than "weak (head normal form)"
07:57:49 <vixey> > filter even [1..10]
07:57:50 <lambdabot>  [2,4,6,8,10]
07:57:59 <vixey> lilac: yes I think so
07:59:09 <vixey> just define a new tuple constructor like before, this time with type (z -> a -> a) -> (x -> y -> a -> a) -> (z -> a -> a, x -> y -> a -> a)
08:00:12 <vixey> > map (+7) . filter even $ [1..10]
08:00:14 <lambdabot>  [9,11,13,15,17]
08:00:41 <paczesiowa> vixey: the problem is, I'd need some general tuple constructor (working for every function ending in a -> a)
08:00:51 <vixey> > let when = (,) ; filteringMap (f,p) = map f . filter p in filteringMap ((+7) `when` even) $ [1..10]
08:00:52 <lambdabot>  [9,11,13,15,17]
08:01:16 <vixey> paczesiowa: What are you actually trying to do?
08:01:24 <vixey> :t uncurry
08:01:26 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:01:27 <vixey> might be useful
08:02:04 <hkBst> quicksilver: so you don't think there will be a performance difference due to extra consing between `transform g s = (filter fst $ map g s)' and `transform g [] = []; transform g (x:xs) = let gx = g x in if fst gx then snd gx : transform g xs else transform g xs'?
08:02:27 <paczesiowa> I want to build a list of different functions but it must have ending terms unified
08:02:39 <vixey> @src Endo
08:02:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:02:43 <vixey> :t Endo
08:02:45 <lambdabot> forall a. (a -> a) -> Endo a
08:02:49 <quicksilver> hkBst: I wouldn't think so. Try it ;)
08:02:57 <vixey> :t Epi
08:02:59 <lambdabot> Not in scope: data constructor `Epi'
08:04:06 <paczesiowa> I want to write functions of form [< `Cons1 | `Cons2 ] -> [> `Cons1 | `Cons3 ]
08:04:22 <vixey> why
08:04:25 <hkBst> quicksilver: can `(filter fst $ map g s)' be changed into a single ''call'' to a list comprehension?
08:04:39 <paczesiowa> polymorphic variants are great
08:04:42 <EvilTerran> hkBst, i did that earlier
08:05:00 <EvilTerran> [15:28] <EvilTerran> hkBst, how about (\xs -> [x | (True, x) <- xs])?
08:05:07 <quicksilver> hkBst: no. list comprehensions are only sugar for calls to filter and map.
08:05:27 <hkBst> EvilTerran: that's only the filtering part, no?
08:05:36 <EvilTerran> oh, right
08:05:44 <quicksilver> hkBst: I mean, yes you can do it, but don't expect different performance.
08:05:53 <jaj> quicksilver: you can also see then as sugar for monadic notation, right?
08:06:09 <EvilTerran> sorry, i thought you were still talking about (map snd . filter fst)
08:06:18 * EvilTerran needs to pay attention
08:06:35 <hkBst> quicksilver: I was just wondering because if the calls for filter and map were interchanged you could do it I think.
08:06:50 <EvilTerran> hkBst, that doesn't really lend itself to list comprehension, i guess
08:07:09 <EvilTerran> [x | x <- g xs, fst x]
08:07:10 <byorgey> jaj: indeed
08:07:14 <EvilTerran> er, no...
08:07:15 <quicksilver> [ y' | y <- s,  let y' = g y, fst y']
08:07:28 <EvilTerran> [x | x <- xs, let y = g x, fst x] would be it
08:07:28 <quicksilver> I believe.
08:08:32 <EvilTerran> > [y | x <- cycle [False ..] `zip` [0..], let y = g x, fst y]
08:08:32 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Bool, b))
08:09:00 <EvilTerran> er, never mind. my brain seems to be utterly broken this afternoon.
08:20:44 <sioraiocht> is there any information on using castIOUArray
08:30:06 <Lavos^> join #ghc
08:31:08 <Apocalisp> I had the hiccups this morning.
08:31:19 <Lavos^> Awww. >:
08:31:22 <byorgey> BOO!
08:32:04 <byorgey> @seen edwardk
08:32:05 <lambdabot> edwardk is in #haskell-blah and #haskell. I last heard edwardk speak 10h 51m 56s ago.
08:32:08 <travisbrady> is there a haskell equivalent to Python's pickle?
08:32:23 <quicksilver> Data.Binary perhaps
08:33:38 <mm_freak_work> <vixey> _:_:_:_:_:_:_:_:_:_:_:_:_:_:_:[]
08:33:43 <mm_freak_work> looks like a snake =)
08:34:05 <travisbrady> quicksilver: thank you
08:36:08 <hkBst> what is "the monomorphism restriction"?>
08:36:52 <quicksilver> look it up on the haskell wiki
08:37:00 <vixey> hkBst: fist of all do you know the type difference between ((\x -> t) y) and let x = y in t?
08:39:04 <mm_freak_work> i'd say they have the same typeâ¦  the type of t
08:39:29 <hkBst> vixey: no
08:39:49 <vixey> :t let x = 1 in (x,x)
08:39:51 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
08:39:53 <vixey> :t (\x -> (x,x)) 1
08:39:55 <lambdabot> forall t. (Num t) => (t, t)
08:40:25 <mm_freak_work> oh
08:40:58 <mm_freak_work> but that's not the same, is it?
08:41:10 <mm_freak_work> :t let x = 1 in (id,id)
08:41:12 <lambdabot> forall a a1. (a -> a, a1 -> a1)
08:41:39 <mm_freak_work> :t (\x -> (id,id)) 1
08:41:41 <lambdabot> forall a a1. (a -> a, a1 -> a1)
08:41:45 <mm_freak_work> as expected
08:42:06 <mm_freak_work> it's the same, besides that the let form defines x
08:43:41 <EvilTerran> vixey, the difference is that polymorphic parameters to a function can only be used on one type within the function body
08:43:55 <EvilTerran> *as one type
08:44:06 <EvilTerran> :t (\x -> (x,x))
08:44:08 <lambdabot> forall t. t -> (t, t)
08:44:47 <EvilTerran> both those t's have to be the same, because they're scoped to the same forall in the type
08:44:56 <mm_freak_work> (\x -> (x,x)) is much more special than the (\x -> t) from above
08:45:04 <chessguy> @pl \x -> (x,x)
08:45:04 <lambdabot> join (,)
08:45:09 <EvilTerran> but, that doesn't have that much to do with the monomorphism restriction, AFAIK
08:45:36 <EvilTerran> the monomorphism restriction is an attempt to make the language more intuitive by making things that look like constants really be constant
08:46:16 <EvilTerran> consider "three = 3" as a top-level binding - if (three :: Num a => a), then the value will need to be calculated for every type you specialise down to
08:47:04 <EvilTerran> so, to prevent this repeated calculation happening accidentally, the monomorphism restriction forces such parameterless definitions to be monomorphic instead of polymorphic unless a type signature is explicitly given
08:47:20 <EvilTerran> hkBst, does that make sense?
08:49:35 <hkBst> EvilTerran: why is it different for three than for 3?
08:49:59 <EvilTerran> blame the language designers
08:50:15 <hkBst> but 3 will have to be converted too...
08:50:45 <hkBst> it's just as non-constant as three
08:51:07 <EvilTerran> ok, that's a poor example, because the value's a very cheap computation
08:51:42 <EvilTerran> if, instead, it was some long, convoluted expression, it might be clearer
08:52:07 <quicksilver> the wiki page explains the reason pretty clearly
08:52:10 <quicksilver> and gives some examples
08:52:12 <EvilTerran> because you wouldn't want it being re-calculated for Int, Integer, Rational, Float, Double, etc without you noticing if it's an expensive computation
08:53:18 <geezusfreeek> i would say in that circumstance you should use a type annotation to force it to be only one of those types
08:53:26 <hkBst> quicksilver: I'm trying to understand the example `f xs = (len,len) where len = genericLength xs' and how there could be multiple calculations of len.
08:53:29 * geezusfreeek dislikes monomorphism restriction
08:54:03 <quicksilver> hkBst: suppose the type was f :: [a] -> (Int,Double)
08:54:13 <vixey> hkBst: Compare it with (\len -> (len,len)) (genericLength xs')
08:54:17 <quicksilver> hkBst: then genericLength is called at two different types.
08:54:44 <geezusfreeek> :t genericLength
08:54:45 <lambdabot> forall b i. (Num i) => [b] -> i
08:54:58 <quicksilver> geezusfreeek: I also dislike the monomorphism restriction, although I fear removing it will increase annotations in numerically heavy programs.
08:55:12 <EvilTerran> geezusfreeek, indeed, forcing it to one type would be fine
08:55:43 <EvilTerran> longExpensiveComputation :: Integer; genericLongExpensiveComputation :: Num a => a; genericLongExpensiveComputation = fromInteger longExpensiveComputation
08:55:59 <EvilTerran> would save the hidden cost, and still leave you with a polymorphic value
08:56:07 <hkBst> quicksilver: but the function definition makes that impossible
08:56:14 <geezusfreeek> quicksilver: i don't think so. the monomorphism restriction forces you to insert as many (or more) type annotations anyway
08:56:22 <quicksilver> geezusfreeek: nope, that's not true. ;)
08:56:22 <geezusfreeek> *i suspect
08:56:31 <geezusfreeek> no? aw :(
08:56:55 <quicksilver> geezusfreeek: consider a program which uses many, many simple expreesions like "x = 1.0; y = 1.0+r*cos theta"
08:56:58 <quicksilver> geezusfreeek: and so on.
08:57:13 <quicksilver> geezusfreeek: then it calls liibrary routines like plotPoint(x,y,z)
08:57:26 <hkBst> quicksilver: so basically the problem is that the compiler forgets that certain types are the same?
08:57:31 <quicksilver> (plotPoint being polymorphic)
08:57:37 <quicksilver> hkBst: it's not a problem. It's a feature.
08:57:43 <quicksilver> hkBst: the question is how to manage the feature.
08:57:54 <hkBst> how is it a feature?
08:57:57 <quicksilver> geezusfreeek: with the DMR active, tpically one type annotation is enough.
08:58:12 <quicksilver> geezusfreeek: one single (::Double) 'ripples' through
08:58:16 <vixey> this is a consequence of ad-hoc polymorphism
08:58:30 <quicksilver> forcing all the necessarily monomorphic x,y,r,theta to be Double.
08:58:40 <geezusfreeek> ah, i see. i was not thinking of that ripple effect being taken away without the monomorphism restriction
08:58:45 <quicksilver> nod
08:58:57 <quicksilver> when the ripple goes, more of your simple expressions remain polymoprhic
08:59:00 <quicksilver> so you need more annotations.
08:59:13 <quicksilver> to be fair, most people probably don't write that kind of program very often.
08:59:21 <quicksilver> openGL programmers do, though.
08:59:33 <quicksilver> Because the builtin primitves vertex, normal, and so on are polymorphic.
08:59:45 <geezusfreeek> right
09:00:00 <quicksilver> I still don't like the DMR.
09:00:09 <quicksilver> But this disadvantage of removing it only occurred to me this morning.
09:00:13 <quicksilver> so it's fresh in my mind.
09:00:14 <hkBst> D for devilish?
09:00:33 <quicksilver> JaffaCake suggested I try compiling my code with XNoMonorphism and see if the problem is really as big as I am suggesting.
09:00:38 <quicksilver> which is a good idea :)
09:00:52 <mm_freak_work> :t (::)
09:00:54 <lambdabot> parse error on input `::'
09:01:19 <mm_freak_work> :t (:: Int)
09:01:21 <lambdabot> parse error on input `::'
09:01:27 <mm_freak_work> > (:: Int) 3
09:01:27 <lambdabot>  Parse error at "::" (column 2)
09:01:33 <geezusfreeek> yeah i still don't think it sounds like it would be _that_ big, but i still hadn't thought of it
09:01:48 <quicksilver> mm_freak_work: :: is syntax.
09:01:52 <quicksilver> mm_freak_work: it's not an operator.
09:02:11 <mm_freak_work> i know, i just wanted to see how similar it is to an operator
09:02:57 <EvilTerran> hkBst, D for "dreaded" :D
09:04:22 <hkBst> quicksilver: I still don't understand how DMR is a feature. It prevents cases of lack of sharing, but those cases are a consequence of loss of equality of types, so...
09:04:43 <paczesiowa> I think that good explanation to monomorphism restriction would be x = 2000000000+2000000000. you don't know value of x until you really know the type (Int vs Integer)
09:06:00 <quicksilver> hkBst: no, it also prevents sharing where the expression is used twice at the same type.
09:06:09 <quicksilver> hkBst: unless your compiler automatically specialises.
09:06:17 <quicksilver> hkBst: that's why it's a feature.
09:06:38 <hkBst> quicksilver: do you have an example?
09:07:12 <quicksilver> x = LongSlowIntegralComputation; main = print (x+x::Int)
09:07:18 <quicksilver> x will be computed twice
09:07:24 <quicksilver> because it isn't a caf although it looks like one
09:07:39 <quicksilver> that is (x::Int) will get computed twice.
09:09:12 <hkBst> there's only one x that's actually used there, quicksilverm, so how is it so that the compiler has to be too stupid to see that?
09:09:33 <paczesiowa> maybe "seeing" that takes too long?
09:10:18 <quicksilver> hkBst: x is actually a function
09:10:24 <quicksilver> although it doens't look like it
09:10:43 <quicksilver> x has type: IntegralDict -> a
09:10:54 <quicksilver> functions are not memoised automatically.
09:11:02 <quicksilver> it's an implementation issue rather than a theoretical one.
09:11:12 <quicksilver> (but the issue of CAFs being cached is, too)
09:11:27 <hkBst> quicksilver: well, at least it's an issue now :) and not a feature anymore
09:11:49 <quicksilver> the DMR is a feature because it prevents you losing sharing when you don't want to.
09:12:08 <quicksilver> it's an undesirable feature because it forces you to annotate types sometimes in an annoying way.
09:18:35 <lilac> why are polymorphic functions implemented as functions from (essentially) a v-table to a value, rather than being specialized C++-template-style?
09:19:49 <jkff> Probably because if they get exported outside the module, they will *have* to expose their interface as a function from a v-table to a value
09:19:59 <BMeph> Does anyone know of a project to develop a syntax for Arrow Calc in Haskell?
09:20:04 <jkff> However that doesn't answer the question 'why can't they be inlined at least inside the module'
09:20:10 <jkff> Probably they are
09:22:42 <quicksilver> lilac: jkff has the basic general answer.
09:23:00 <quicksilver> lilac: unlike C++, haskell supports separate compilation of polymorphic "templates"
09:23:08 <quicksilver> lilac: (GHC, I should say, not haskell)
09:23:15 <lilac> that only holds if you assume no inter-module optimization... which i thought GHC did?
09:23:30 <quicksilver> however, inlining and specialisation both occur.
09:23:38 <lilac> ok
09:23:49 <quicksilver> explicit dictionary passing is the "basic" model
09:23:58 <quicksilver> in practice the dictionaries are normally eliminated.
09:25:02 <quicksilver> across module boundaries they can only be eliminated in the function concerned is considered an inlining candidate and goes into the hi file.
09:25:16 <hkBst> how should one read numbers from input?
09:25:22 <quicksilver> of course the important ones in the standard lib have explicit INLINE pragmas to make sure that happens.
09:25:34 <quicksilver> hkBst: readLn is a nice simple way.
09:25:35 <lilac> presumably with full inter-module optimization (and assuming no dynamic linking) it's always possible to eliminate the dictionaries? (though i'm guessing GHC doesn't necessarily do that)
09:25:58 <quicksilver> lilac: absolutely. However that's whole-program computation.
09:26:03 <quicksilver> lilac: compilation.
09:26:13 <lilac> sure, ok. makes sense.
09:26:21 <quicksilver> lilac: quite a lot of aspects of compilation are O(n^2) or worse.
09:26:32 <quicksilver> so whole-program isn't necessarily feasible as a general strategy.
09:26:46 <quicksilver> someone used to maintain a hack to transform a GHC program into a single module.
09:26:58 <quicksilver> it produced code which was much slower to compile and often ran faster :)
09:27:06 <quicksilver> that's the trade off compiler writers normally have to live with.
09:27:06 <ddarius> That was Hal Daume III I believe
09:27:24 <ddarius> @google HAllInOne
09:27:25 <quicksilver> lilac: see also supercompilation and ndm's thesis.
09:27:26 <lambdabot> http://osdir.com/ml/lang.haskell.general/2003-07/msg00149.html
09:27:26 <lambdabot> Title: Ann: HAllInOne bug fix release: msg#00149
09:27:38 <geezusfreeek> JHC also does whole program optimization
09:27:43 <quicksilver> lilac: and, FYI, JHC doesn't use dictionary passing.
09:27:47 <quicksilver> I'm not sure what it does?
09:27:59 <ddarius> It monomorphizes for the most part.
09:28:02 <quicksilver> it has a fundamentally somewhat different compilation model.
09:28:10 <ddarius> I believe it uses type passing for the remaining cases.
09:28:36 <hkBst> quicksilver: and when there are more numbers in one line?
09:28:57 <geezusfreeek> "The basic idea is that instead of passing a dictionary, a case statement directly scrutinizes the type parameter of a function and calls the appropriate overloaded routine directly." from http://repetae.net/computer/jhc/jhc.shtml
09:28:58 <lambdabot> Title: jhc
09:29:27 <Lavos^> Does anyone know the name of that machine IBM built that has a ridiculous amount of RAM to run the internet on?
09:31:08 <quicksilver> ddarius: it's not obvious to me that a type parameter is fundamentally anything different from a dictionary.
09:31:31 <quicksilver> I mean, you might as well use a dictionary as a concrete standing for a type.
09:31:36 <quicksilver> seems much of a muchness to me.
09:33:11 <quicksilver> ah, the page explains a bit more..
09:33:30 <lilac> sounds like JHC would need to know all of the instances of a class before it can do its codegen?
09:33:50 <geezusfreeek> lilac: whole program optimization
09:34:03 <geezusfreeek> it doesn't generate object files to be linked later
09:34:23 <chessguy> so, i'm writing a function that takes a list of sorted elements which has been rotated, and figures out how much it's been rotated. how hard would it be to write a quickcheck property for this?
09:34:47 <chessguy> i'm thinking i'd have to go to something like sparsecheck
09:35:34 <chessguy> > sort [2,1,3]
09:35:36 <lambdabot>  [1,2,3]
09:35:56 <geezusfreeek> chessguy: what would be the problem?
09:35:59 <smg> haskell is the power
09:36:20 <chessguy> geezusfreeek: well, that's a pretty particular input it's supposed to work on
09:36:27 <quicksilver> \xs -> chessguy (rotate n (sort xs)) == n
09:36:34 <geezusfreeek> just take a random list and sort it in the property
09:36:37 <quicksilver> chessguy: seems easy to write a quickcheck property?
09:36:48 <chessguy> well, the n needs to be random too
09:36:56 <quicksilver> \n xs -> chessguy (rotate n (sort xs)) == n
09:36:56 <mrd> [1,1,1] how much has that been rotated
09:36:56 <geezusfreeek> yes
09:37:00 <quicksilver> that's what I meant :)
09:37:07 <hkBst> I see Numeric has a readInt, but I don't see how it should be used.
09:37:15 <mrd> @hoogle readInt
09:37:19 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
09:37:19 <lambdabot> Data.ByteString.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
09:37:19 <lambdabot> Data.ByteString.Lazy.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
09:37:52 <mrd> ReadS a = String -> a -- iirc
09:38:49 <mrd> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v%3AreadInt
09:38:50 <ddarius> quicksilver: It's not fundamentally different from a dictionary.
09:38:51 <lambdabot> http://tinyurl.com/yjng6j
09:39:11 <quicksilver> \n xs -> let sorted = sort xs; rotated = rotate n sorted; m = chessguy rotated; in rotate m sorted = rotated
09:39:12 <mrd> hkBst: might find readDec easier to use
09:39:16 <quicksilver> chessguy: sorry, that's better
09:39:21 <quicksilver> hkBst: or just readLn
09:39:29 <chessguy> mm, the n has to be less than or equal to the size of the list too
09:39:32 <quicksilver> chessguy: now it copes with [1,1,1]
09:39:44 <quicksilver> chessguy: well over-rotating doesn't actually matter.
09:39:47 <quicksilver> it's just a waste of time :)
09:39:54 <quicksilver> it still "works"
09:39:55 <hkBst> quicksilver: how do you readLn "3 4"?
09:39:55 <chessguy> well, true
09:40:06 <quicksilver> hkBst: split it by spaces first?
09:40:11 <chessguy> it has to be non-negative though
09:40:18 <quicksilver> hkBst: but I thought you were using user input, not a fixed string.
09:40:22 <mrd> > reads "3 4"
09:40:24 <lambdabot>  []
09:40:34 <mrd> > reads "3 4" :: [(Int, String)]
09:40:35 <quicksilver> > map read (words "3 4") :: [Int]
09:40:37 <lambdabot>  [3,4]
09:40:37 <lambdabot>  [(3," 4")]
09:40:52 <hkBst> quicksilver: well, in the end it should read a file for input
09:41:02 <quicksilver> chessguy: note my test checks if the answer is a working rotation
09:41:08 <quicksilver> chessguy: it doesn't check if it's the same as the given n
09:41:14 <quicksilver> chessguy: so it wouldn't matter of n was negative.
09:41:30 <quicksilver> chessguy: you might want to check that the answer is 0 <= ... <= length xs, definitely.
09:41:36 <mrd> if you want to read a file of numbers quickly, bytestring has a nifty way
09:42:12 <mrd> S.getContents >>= unfoldr S.readInt
09:50:45 <vixey> @quote
09:50:45 <lambdabot> vegai says: in soviet russia, YOU blow up GHC's brain!
09:50:48 <vixey> @kel
09:50:49 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
09:51:01 <vixey> @protorntorpedo
09:51:02 <lambdabot> I had one guy tell me he was 16x as fast to develop something in smalltalk
09:51:14 <vixey> @quote
09:51:14 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
09:51:32 <chessguy> @hoogle sort
09:51:33 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
09:51:33 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
09:51:33 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
09:56:50 <hkBst> how do you take integer square root?
09:56:58 <vixey> floor . sqrt
09:57:08 <gchrupala> Hi, does someone know how i can install GHC (in a user account) on a system with the wrong version of libreadline?
09:57:30 <vixey> why do you want to use the wrong version of readline?
09:57:40 <gchrupala> want?
09:57:50 <gchrupala> its a different version than what ghc needs
09:58:21 <hkBst> gchrupala: gentoo prefix? ;)
09:58:34 <gchrupala> hkBst: ?
10:01:35 <pejo> gchrupala, if you have a different version of readline installed elsewhere that you use I think there's a --with-readline-{headers,library} switch to configure. Otherwise there should be a --disable-readline or similar, if you don't want to use it at all.
10:02:04 <pejo> headers = includes. Hm. You better read the output from configure --help to make sure you get the name right. :-)
10:02:19 <hkBst> :t floor
10:02:31 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
10:02:58 <gchrupala> pejo: thanks ill try it
10:04:20 <gchrupala> pejo: but i think this wont work with a binary GHC install, no?
10:04:38 <gchrupala> as in its already built to use libreadline?
10:04:54 <dolio> @yow! coinductive agda.
10:04:55 <lambdabot> PEGGY FLEMMING is stealing BASKET BALLS to feed the babies in VERMONT.
10:05:24 <vixey> so .. what can we do with coinductives?
10:05:58 <dolio> Well, partiality monad for one, presumably.
10:06:36 <dolio> coIO monad, too, perhaps, whenever that gets where it's going (for writing total, non-terminating programs).
10:07:11 <vixey> like an operating system?
10:07:35 <dolio> Yeah, or a daemon.
10:07:58 <pejo> gchrupala, hm, no, probably not - you need the right version of readline. (If you're on some unixy system you can set LD_LIBRARY_PATH to some place that has the right version of readline, I guess)
10:08:08 <dolio> I'm not sure what the formal classification of most programs in that regard is.
10:08:09 <vixey> I am really confused where do coinductives come from
10:08:44 <BMeph> vixey: From some mathist's co-imagination? ;)
10:08:58 <vixey> yeah if you have a terminating procedure, then a correctenss proof is just a your answer = my answer proof
10:09:08 <vixey> but with coinductive .. side effecting stuf.. what is correctness?
10:09:20 <vixey> the same side effects in the same order, or ?
10:09:32 <vixey> BMeph: why is it allowed in type theory though?
10:10:04 <dolio> I think you can also write programs like 'primes = coinductive-stream-of-primes ; foo = let first-ten-primes = take 10 primes in ...'
10:10:27 <dolio> Where first-ten-primes is a list.
10:10:34 <vixey> dolio: gonna take a big proof though to write it :p
10:10:38 <vixey> (isn't it?)
10:10:43 <dolio> Proof of what?
10:10:45 <vixey> (proof theres at least 10 primes)
10:11:09 <vixey> oh if there wasn't 10 primes it would be ok I guess
10:11:20 <dolio> Hmm. Not sure about that. I think streams are guaranteed to be infinite.
10:11:29 <gchrupala> pejo: i dont think there is the right version installed anywhere
10:11:35 <dolio> I mean, if you define them right.
10:12:09 <gchrupala> pejo: there is an rpm in ghc download site but i cant install rpms in my account
10:12:11 <vixey> if so, doesn't that mean you have to prove there's infinite primes
10:12:18 <dolio> Anyhow, if you have an infinite, productive stream, and you take 10 (which is inductive in 10), I think you should be fine.
10:12:25 <frevidar> how can I do something like this:
10:12:33 <frevidar> f :: t -> t
10:12:34 <frevidar> f x = 2 * y where
10:12:35 <frevidar> 	y :: t
10:12:37 <frevidar> 	y = 2 * x
10:12:46 <Deewiant> t means any type at all
10:12:50 <Deewiant> @ty (*)
10:12:55 <lambdabot> forall a. (Num a) => a -> a -> a
10:13:03 <pejo> gchrupala, is the problem that you have readline4 installed, but it wants 5 or vice versa?
10:13:07 <Deewiant> as you can see, you need to restrict to being a number
10:13:12 <frevidar> ummm, lets say t is a numeric type
10:13:20 <Deewiant> so you can do the above
10:13:23 <gchrupala> pejo: vice versa
10:13:24 <Deewiant> and it's f :: Num t => t -> t
10:13:28 <Deewiant> and similarly for y
10:13:40 <dolio> vixey: I'm not 100% sure. fibs is maybe a better example, since the construction of that makes it obvious that there are infinitely many.
10:13:51 <mattam> vixey: yes, otherwise the sieve wouldn't be productive.
10:13:54 <Deewiant> alternatively, specify the exact type by replacing t with Integer or Double or whatever
10:14:11 <frevidar> f :: (Num t) => t -> t
10:14:13 <frevidar> f x = 2 * y where
10:14:14 <frevidar> 	y :: (Num t) => t
10:14:16 <frevidar> 	y = 2 * x
10:14:19 <frevidar> still fails to compile
10:14:49 <frevidar> its line 3 which I'm concerned about
10:14:50 <tchakkazulu> frevidar: 'y' doesn't have 'x' in scope.
10:14:50 <Deewiant> what's the error (don't paste it in full here, or if you must use http://hpaste.org)
10:14:53 <dolio> vixey: But the idea would be that you can program with haskell-like infinite structures if your methods are productive, and then use finite portions of them in your program.
10:14:56 <Socrates`> Where's x in the function y?
10:15:11 * vixey nod
10:15:12 <frevidar> whoops
10:15:19 <Deewiant> huh? surely y can see x
10:15:28 <pejo> gchrupala, if you can't install the right version you could try (the very very unsupported) editing of the ghc-binary. It *might* let the compiler run to the extent you need. Find the binary and change the libreadline.so.5 to libreadline.so.4 instead. :-)
10:15:33 <Socrates`> Ahh, it's a where.
10:15:35 <hkBst> > let primes = filter (\n -> firstFactor n /= 0) [2..]; firstFactor n = let limit = floor $ sqrt n in (transform (\p -> if p > limit then (True, 0) else (mod n p == 0, p)) primes) !! 0 in firstFactor 121
10:15:36 <tchakkazulu> Oh, wait. Yes. Where.
10:15:36 <lambdabot>   Not in scope: `transform'
10:15:46 <frevidar> hang on
10:15:46 <tchakkazulu> Indentation got lost on me :-/
10:15:52 <frevidar> yeah, that should be ok
10:15:53 <hkBst> > let transform g s = map snd $ filter fst $ map g s; primes = filter (\n -> firstFactor n /= 0) [2..]; firstFactor n = let limit = floor $ sqrt n in (transform (\p -> if p > limit then (True, 0) else (mod n p == 0, p)) primes) !! 0 in firstFactor 121
10:15:54 <lambdabot>  Add a type signature
10:16:00 <vixey> http://www.cs.chalmers.se/Cs/Research/Logic/TypesSS05/resources/coq/filters/
10:16:03 <lambdabot> Title: Index of /Cs/Research/Logic/TypesSS05/resources/coq/filters, http://tinyurl.com/6k4k99
10:16:27 <Deewiant> if it's a syntax error it's complaining about you probably need to move the 'where' or y
10:16:45 <Deewiant> it might be that y has to be indented deeper than the where
10:16:48 <frevidar> deewiant: for example?
10:17:32 <Deewiant> what I generally do is foo = ...<CR> where<CR><indentation>bar = ...<CR><indentation>baz = ...
10:17:39 <bluestorm> data Functor f => Fix f = Fix (f (Fix f))
10:17:44 <Deewiant> i.e. where is on its own line and indented by one space
10:17:46 <lilac> @pl \p x -> if p x then Just x else Nothing
10:17:46 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
10:17:46 <bluestorm> is it possible to remove the "Fix" constructor ?
10:17:57 <Deewiant> and all the where-definitions are indented deeper
10:18:09 <hpaste>  Socrates pasted "Indentation fix" at http://hpaste.org/8125
10:18:17 <bluestorm> i'd like to be able to write    data Functor f => Fix f = f (Fix f)
10:18:20 <lilac> @hoogle (a -> Bool) -> a -> Maybe a
10:18:28 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
10:18:30 <bluestorm> or something near
10:18:58 <frevidar> f :: (Num t) => t -> t
10:19:00 <frevidar> f x = 2 * y
10:19:01 <frevidar>  where
10:19:03 <frevidar>   y :: (Num t) => t
10:19:04 <frevidar>   y = 2 * x
10:19:09 <Socrates`> frevidar: http://hpaste.org/8125
10:19:14 <frevidar> that doesn't compile either
10:19:15 <Deewiant> ah, but it's not a syntax error it's complaining about
10:19:21 <gchrupala> pejo: segmentation fault
10:19:43 <bluestorm> (anyone ?)
10:19:54 <frevidar> I think line 4 is the issue
10:19:56 <Deewiant> hmm, this is beyond my understanding... it doesn't like the type signature of y
10:20:04 <Deewiant> but I can't see why
10:20:20 <Deewiant> put the full error message on hpaste and hopefully somebody more knowledgeable will answer :-)
10:20:27 <frevidar> this is a simplification of a more complex code
10:20:33 <lilac> @check \p x -> (if p x then Just x else Nothing) == find p [x]
10:20:34 <lambdabot>  OK, passed 500 tests.
10:21:15 <Deewiant> the easiest fix is to remove the type signature
10:21:34 <hpaste>  mix25 pasted "(no title)" at http://hpaste.org/8126
10:21:44 <hpaste>  frevidar pasted "Code and error question?" at http://hpaste.org/8127
10:21:48 <mix25> Why ?
10:21:49 <hpaste>  hkBst pasted "how to do integer square root" at http://hpaste.org/8128
10:22:09 <lilac> @pl \p x -> find p [x]
10:22:09 <lambdabot> (. return) . find
10:22:15 <vixey> :t floor . sqrt
10:22:17 <lambdabot> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
10:22:31 <vixey> :t floor . sqrt . realToFrac
10:22:33 <hkBst> vixey: that just gives me another type error
10:22:35 <lambdabot> forall b a. (Real a, Integral b) => a -> b
10:22:44 <Botje> funny
10:23:01 <vixey> :t let isqrt = floor . sqrt . realToFrac in isqrt :: Integer -> Integer
10:23:03 <lambdabot> Integer -> Integer
10:23:06 <Botje> I just noticed glasgow has been typo'd in "imperative functional programming" by simonpj and pwadler
10:23:24 <bluestorm> is there a way to allow a "Cycle in type synonym declarations" ?
10:24:28 <frevidar> any ideas how to fix the second type signature in http://hpaste.org/8127 ?
10:24:32 <tchakkazulu> frevidar: Section 8.7.6 of the GHC manual has more information.
10:24:36 <tchakkazulu> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
10:24:36 <_andre> is there a function assoc = zipWith (,) [0..] in the standard lib?
10:24:36 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
10:24:49 <BMeph> frevidar: Put the 'where' at the end of the line that f starts on. :)
10:24:49 <lilac> > let sqrtInt n = find (\a -> a*a==n) [floor . sqrt . fromIntegral $ n] in sqrtInt (99556 * 99556)
10:24:50 <frevidar> tchakkazulu: ah, cool, thanks!
10:24:51 <lambdabot>  Just 99556
10:25:25 <tchakkazulu> frevidar: You may need a flag to enable that syntax, but that should be a starting point.
10:25:33 <BMeph> bluestorm: No, you'd get an occurs error with that. Or at least, that's my theory. ;)
10:25:59 <Deewiant> oh, it's an extension? darn
10:26:05 <bluestorm> BMeph: my type is sane and i can construct it with a "data"
10:26:27 <bluestorm> except that "Data" force me to add a constructor, wich is not so handy
10:26:46 <hkBst> > floor $ sqrt 16
10:26:48 <lambdabot>  4
10:26:57 <hkBst> > sqrt 16
10:26:58 <lambdabot>  4.0
10:27:10 <hkBst> > :t floor $ sqrt 16
10:27:11 <lambdabot>   parse error on input `:'
10:27:16 <hkBst> :t floor $ sqrt 16
10:27:17 <lambdabot> forall b. (Integral b) => b
10:27:30 <hkBst> :t \x -> floor $ sqrt x
10:27:32 <lambdabot> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
10:28:10 <bluestorm> hm
10:28:33 <bluestorm> i might have a workaround : i can deconstruct the constructor in every function that doesn't want it
10:28:38 <bluestorm> but it's somewhat clumsy
10:28:39 <hkBst> I don;t understand what the problem is with http://hpaste.org/8128
10:28:47 <bluestorm> i wish ghc allowed a -rectypes option or something
10:29:04 <hpaste>  Deewiant annotated "Code and error question?" with "(no title)" at http://hpaste.org/8127#a1
10:33:13 <byorgey> hkBst: you can only use 'sqrt' on floating-point numeric types
10:33:15 <byorgey> @type sqrt
10:33:16 <lambdabot> forall a. (Floating a) => a -> a
10:33:32 <byorgey> hkBst: if you want to do integer square root, you have two options
10:33:49 <byorgey> 1) convert to floating-point and back:  intSqrt = round . sqrt . fromIntegral
10:34:12 <byorgey> but that suffers from accuracy problems, and flat-out doesn't work for numbers that are too big
10:34:34 <byorgey> you can also implement it directly using integer operations, the idea is to adapt Newton's method
10:34:57 <byorgey> there's some code for it somewhere on the wiki, IIRC
10:38:10 <byorgey> hkBst: In your case, though, instead of trying to code an intSqrt function, I'd just change it to  (\p -> if p*p > n then ... )
10:38:19 <byorgey> much simpler and no square root calculations needed
10:42:39 <EvilTerran> or "if p^2 > n then"
10:45:45 <Deewiant> > let isqrt n = let nf = fromIntegral n; f x = (x + nf / x) / 2; seq = iterate f nf in floor.fst.head.dropWhile ((>= 0.5) . uncurry (-)) $ zip seq (tail seq) in isqrt 256
10:45:46 <lambdabot>  16
10:51:28 <mmorrow> love ghosting zombie scum!
10:52:35 <stephano> w00t?
10:52:49 <mmorrow> !
10:55:53 <mmorrow> > Node 0 []
10:55:54 <lambdabot>  Node {rootLabel = 0, subForest = []}
10:56:00 <mmorrow> yesh
10:56:11 <mmorrow> :t fromList
10:56:13 <lambdabot> Not in scope: `fromList'
10:56:21 <mmorrow> :t toList
10:56:22 <lambdabot> Not in scope: `toList'
10:56:29 <mmorrow> :t viewl
10:56:31 <lambdabot> Not in scope: `viewl'
10:56:38 <mmorrow> :t levels
10:56:40 <lambdabot> forall a. Tree a -> [[a]]
10:56:50 <mmorrow> :t scc
10:56:53 <lambdabot> Graph -> Forest Vertex
10:57:05 <Deewiant> > levels $ Node 0 []
10:57:06 <lambdabot>  [[0]]
10:59:35 <mmorrow> > let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in fromJust $ unfoldForestM_BF (f 4) [0]
10:59:36 <lambdabot>  [Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {r...
11:00:57 <mmorrow> :t unfoldForestQ
11:01:00 <lambdabot> Not in scope: `unfoldForestQ'
11:01:12 <mmorrow> unfoldForestQ :: Monad m => (b -> m (a, [b])) -> Seq b -> m (Seq (Tree a))
11:01:23 <bluestorm> is it possible to partially apply types constructors ?
11:01:39 <bluestorm> ha
11:01:47 <lilac> :t Either String
11:01:48 <bluestorm> changing the "type" into a "data" allows that
11:01:49 <lambdabot> Not in scope: data constructor `Either'
11:01:49 <lambdabot> Not in scope: data constructor `String'
11:01:56 <mmorrow> too bad lambdabot doesn't have Data.Seq imported (or can you tell it to?)
11:02:39 <mmorrow> > let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in levels . fromJust $ unfoldForestM_BF (f 4) [0]
11:02:40 <lambdabot>  Couldn't match expected type `Tree a'
11:02:49 <mmorrow> > let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in fmap levels . fromJust $ unfoldForestM_BF (f 4) [0]
11:02:50 <lambdabot>  [[[0],[1,2],[2,3,3],[3]]]
11:03:18 <bluestorm> lilac: there is a problem still
11:03:26 <bluestorm> i cannot partially apply a type synonym
11:03:56 <bluestorm> and data adds constructors, wich are not so funny to handle all over the place
11:04:02 <mmorrow> i think it depends on how you define it
11:04:32 <mmorrow> e.g. type Asdf a = Either String a
11:04:33 <mmorrow> vs
11:04:41 <mmorrow> type Asdf = Either String
11:06:22 <bluestorm> hm
11:06:32 <bluestorm> so if i have
11:06:42 <bluestorm> type OptPair a b = Maybe (a, b)
11:06:58 <bluestorm> how could i functorize it ?
11:07:08 <bluestorm> is there a functor composition operator ?
11:07:18 <vixey> :t (.)
11:07:20 <bluestorm> (something like    Maybe . (,)  could work ?)
11:07:20 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:07:31 <vixey> @undef
11:07:32 <lambdabot> Undefined.
11:07:33 <vixey> :t (.)
11:07:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:07:42 <mmorrow> bluestorm: how do you want to use it where it's partially applied?
11:07:46 <Deewiant> :t fmap
11:07:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:08:09 <bluestorm> mmorrow: eg.  OptPair Int :: * -> *
11:09:17 <byorgey> bluestorm: check out the TypeCompose library, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose
11:09:19 <lambdabot> http://tinyurl.com/6gcnqh
11:09:23 <mmorrow> hmm, in this case the (,) is a pain
11:09:39 <mmorrow> maybe rewrite it somehow
11:09:44 <bluestorm> hm
11:09:46 <mmorrow> (the type syn)
11:09:55 <conal> @seen dons
11:09:55 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 12h 21m 16s ago.
11:10:10 <conal> @seen dcoutts_
11:10:10 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 5h 9m 4s ago.
11:10:14 <byorgey> ah, it's conal himself!
11:10:20 <dcoutts_> hia conal
11:10:25 <conal> hi!
11:10:29 <byorgey> bluestorm was just asking about composing functors =)
11:10:36 <conal> byorgey: oh!
11:10:48 <conal> dcoutts_: i'm looking for pointers in learning to read ghc core.  any recommendations?
11:11:02 <dcoutts_> conal: ok...
11:11:32 <dcoutts_> conal: so it's a subset of Haskell with slightly different semantics in places
11:11:44 <dcoutts_> conal: in particular case is always strict
11:12:07 <dcoutts_> conal: ie case foo of x ->  actually evaluates foo where as it would no in ordinary haskell
11:12:30 <dcoutts_> conal: #'s are important, they indicate primitive operations
11:13:02 <dcoutts_> conal: let means a heap allocation (except for lets of primitive # types)
11:13:36 <dcoutts_> and of course all global names are fully qualified
11:13:44 <dcoutts_> operators are written prefix
11:14:24 <conal> dcoutts_: all helpful info, thx!  what about funny variable names, like b_am0, a_a1Z, tpl1_B3
11:14:38 <dcoutts_> conal: they're all compiler generated local names
11:15:33 <dcoutts_> mostly those names are insignificant except where they're obvious modifiers on global names in which case sometimes the suffix give you a clue about why the name was generated, eg a type specialisation
11:15:34 <conal> dcoutts_: the names contain meaningful clues, don't they?
11:16:00 <thetallguy> conal: I think the Spineless Tagless G-Machine paper has all these details
11:16:10 <dbueno> dcoutts_: I'm not generating unsatisfiable plans anymore!
11:16:15 <conal> dcoutts_: okay, those oare the clues i meant.
11:16:26 <conal> thetallguy: oh!  i wouldn't have guessed to look there
11:16:36 <dcoutts_> conal: I can't think of an example off the top of my head, what kinds of names are you seeing?
11:16:42 <dcoutts_> dbueno: woo hoo!
11:17:24 <conal> dcoutts_: tpl1_B2, o_akZ, c_aib
11:17:34 <dcoutts_> conal: I think those have no clues
11:17:55 <conal> dcoutts_: okay, then i'll stop trying to decipher them. :)
11:17:59 <dcoutts_> conal: when it's more like Some.RandomModule.foo$4 then that's more of a clue
11:19:02 <dcoutts_> conal: my tip for reading core is to spit it out into a file and then load them up in a text editor, make it really wide (since you often get very deeply nested cases) and highlight it as if it were Haskell code.
11:19:21 <dcoutts_> conal: dons also has a ghc-core filter program to make it a bit more readable, I've not used it yet
11:19:23 <conal> dcoutts_: i'll do that.  thanks.
11:20:24 <dcoutts_> dbueno: so what did you have to do to make it work?
11:20:29 <dons> yeah, i like ghc-core
11:20:35 <dons> use it all the time now
11:20:45 <dcoutts_> dons: how do you use it?
11:21:00 <dbueno> dcoutts_: There were logical errors in my formalisation.  In particular, I didn't allow installed packages to resolve unresolved deps. =]
11:21:05 <conal> dons: do you know of tips on reading & using core?
11:21:19 <dcoutts_> dbueno: :-)
11:21:31 <dbueno> dcoutts_: This was hard to figure out, though, because there are several levels of abstraction.  And I had to take a detour through proper Writer-monad logging, which I've never done before.
11:21:43 <conal> dons: i'm trying to get a handle on why derivatives and linear maps are having so much redundant computation.  and why my lineap map fusion rule isn't firing.
11:21:55 <dbueno> dcoutts_: and I was bitten a few times by a stupid design decision I made early, so I had to change that too.
11:22:17 <dcoutts_> dbueno: so next up is trying some big examples :-)
11:22:51 <dbueno> dcoutts_: Well, I generate an incorrect plan (in fact, my test case should only have to figure out that everything necessary is already installed), but I think I know where the bug is.
11:22:57 <dcoutts_> dbueno: I've got a list of packages where it's possible to get a valid plan (by excluding a couple dozen packages)
11:23:00 <dbueno> dcoutts_: When this test passes, I'll try something bigger.
11:23:13 <dbueno> dcoutts_: A maximal list?  Like, most of hackage?
11:23:18 <dcoutts_> dbueno: right
11:23:29 <dcoutts_> all of hackage except for ~20ish
11:23:32 <dbueno> dcoutts_: Sweet.  When I'm a bit more confident I definitely want to try that.
11:24:08 <dcoutts_> dbueno: with the latest cabal-install from darcs you can try it: $ cabal install --dry-run -v $(cat pkgs)
11:24:23 <dcoutts_> and watch the current algorithm do the search
11:24:45 <dcoutts_> where the pkgs file is that big list
11:24:46 <dbueno> dcoutts_: You mean the pkgs file is committed?
11:24:59 <dcoutts_> dbueno: no, I can send it to you though
11:25:00 <dbueno> dcoutts_: ah. okay.  Oh ... you have a nifty progress-meter?
11:25:09 <dbueno> dcoutts_: Sure, would you email it to me?
11:25:11 <dcoutts_> well with -v it spits out progress
11:25:26 <dbueno> dcoutts_: Ah, right.  My progress is ... coarse-grained, at the moment.
11:25:44 <conal> dons: how did you learn to use core effectively?
11:25:46 <dcoutts_> I changed the function from returning Either Failure [PlanPackage a] to Progress Log Failure [PlanPackage a]
11:26:23 <dcoutts_> dbueno: data Progress step fail done = Step step (Progress step fail done) | Fail fail | Done done
11:26:33 <dbueno> dcoutts_: I'm using that interface.
11:26:39 <dbueno> But I never use the Step constructor. =]
11:26:42 <dcoutts_> right
11:26:51 <dcoutts_> so you're just using it as if it were Either
11:26:54 <dcoutts_> that's fine
11:27:14 <dcoutts_> so if you do use step then it gets printed at -v2 or higher
11:27:29 <dcoutts_> and at -v1 we could do a cool spinner or something :-)
11:27:33 <dbueno> dcoutts_: Ah.
11:28:39 <dons> conal, lots of practice. but ghc-core helps
11:28:47 <dons> it uses syntax highlighting and renaming
11:29:40 <dons> conal, there's also the ghc-core paper by tolmach
11:29:46 <dons> which gives an overview
11:29:50 <dons> but its very haskellish
11:29:50 <dbueno> dcoutts_: Heh, yeah.  Mine will appear to hang the spinner and then stop. =]
11:30:03 <dcoutts_> dbueno: :-)
11:33:34 <conal> dons: what is ghc-core for?  i read the description and thought of 'ghc -ddump-simpl | more'.  that can't be it, can it?
11:37:14 <dons> that's basically it. it also colourises, and renames the core, to simplify it. it also ensures you can read the assembly, whether you use -fasm or -fvia-C
11:38:42 <dbueno> dcoutts_: Yay, a valid plan!
11:38:49 <conal> dons: oh, wow.  sounds useful indeed.  why did you include pager functionality, instead of relying on the user to compose with more, less, or nothing at all?
11:39:03 <dcoutts_> dbueno: :-) what was the example?
11:39:03 <dbueno> In order, the following would be installed: containers-0.1.0.0, mtl-1.0
11:39:11 <dbueno> dcoutts_: installing bimap-0.2
11:39:34 <dbueno> dcoutts_: Unfortunately, it wants to install stuff that *can be* but needn't be installed.
11:39:47 <dcoutts_> dbueno: nice. So my canonical examples are always: 1. xmonad, 2. yi and 3. all of hackage :-)  in order of difficulty
11:40:00 <dcoutts_> dbueno: that's fine, my first versions did that
11:40:12 <dbueno> dcoutts_: yi is impossible to install. =]
11:40:40 <dcoutts_> dbueno: I don't believe it :-)
11:40:42 <dbueno> dcoutts_: As is xmonad. =[
11:40:46 <dons> conal, automate the most common case.
11:40:48 <dbueno> dcoutts_: Me neither.
11:41:02 <dons> also, git does this for long output, which i find a useful interface to borrow from
11:41:24 <dcoutts_> dbueno: if you check my code you'll see a function that takes an existing plan and improves it by replacing configured by installed packages where possible.
11:41:28 <conal> dons: i see.  i live in emacs. is it easy to turn off the paging?
11:41:44 <dcoutts_> dbueno: it just checks each package in the plan in reverse topological order
11:41:56 <dbueno> dcoutts
11:41:56 <dbueno> dcoutts_: Ah, so you fix it up later.  Isn't that cheating? =]
11:42:08 <dcoutts_> dbueno: depends on your pov
11:42:42 <dbueno> dcoutts_: I'll be back in a bit.  It is time for coffee.
11:42:43 <dcoutts_> dbueno: I think it isn't. I take the view that you have to go for the least constraining solution first (ie the available package) and then if you can optimise it later then great.
11:42:51 <dons> conal: hmm. we could. ghc-core | cat ?
11:43:14 <dbueno> dcoutts_:  Yeah, that makes sense.  That optimisation step could be applied to any plan produced by any resolver, right?
11:43:19 <dbueno> Then I could use your code directly. =]
11:43:21 <dcoutts_> dbueno: right
11:44:19 <conal> dons: okay.  i'd have left those two functionalities independent and let users alias the composition.
11:44:28 <dcoutts_> dbueno: but if you actively want to prefer installed packages then you need to go for packages that are both installed and available rather than just the latest available otherwise you'll not be able to improve to the installed version
11:44:58 <dcoutts_> dons: yes, then you'd not need to go looking for files ghc drops in /tmp
11:45:14 <dcoutts_> ghc -blah -ddump-simple | ghc-core | less
11:45:54 <dcoutts_> though do less/more do ANSI colour stuff ok? I presume they do
11:47:03 <dcoutts_> seems to do so ok
11:52:26 <thetallguy> conal: I was wrong, I must have been thinking of another paper
11:52:30 <conal> dons: a problem with "automate the most common case" is that you have to predict it accurately.  i'd go for the principle of convenient composability instead.
11:52:34 <conal> thetallguy: okay.  thanks.
11:52:59 <dons> well, i figure git got it right. and lots of people use git. so ... :)
11:56:25 <conal> dons: lots of people use fortran, C, Java, Windows, ...
11:57:20 <dons> anyway, try it out and let me know of any improvements.
11:57:35 <thetallguy> Now, now, gentlemen, keep it above the belt...
11:57:37 <conal> dons: will do.  thanks.
11:57:40 <dons> i'd like to make it as easy as possible to review and understand the results after compilation
12:06:55 <mmorrow> dcoutts: more by default, less with less -r
12:07:19 <mmorrow> dcoutts: (re: less/morrow with ansi color stuff)
12:07:23 <mmorrow> he
12:07:25 <mmorrow> less/more
12:08:26 <dcoutts_> I see
12:13:17 <chessguy> @pl \x -> f n (l x) x
12:13:18 <lambdabot> f n =<< l
12:13:30 <chessguy> oh the interviewer will love that
12:14:23 <mmorrow> @pl \m n > return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:14:23 <lambdabot> (line 1, column 6):
12:14:23 <lambdabot> unexpected ">"
12:14:23 <lambdabot> expecting pattern or "->"
12:14:28 <mmorrow> @pl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:14:29 <lambdabot> (return .) . ap (,) . (. (1 +)) . (. (take 2 . iterate (1 +))) . takeWhile . flip (<)
12:15:08 <stephano> mmorrow: looks pointless :)
12:15:13 <mmorrow> heh
12:15:25 <stephano> ap is in monad?
12:15:34 <Deewiant> @src ap
12:15:34 <lambdabot> ap = liftM2 id
12:15:57 <stephano> :P
12:16:48 <mmorrow> ($ 2) (return . ($ 3) =<< (,))
12:16:50 <mmorrow> > ($ 2) (return . ($ 3) =<< (,))
12:16:51 <lambdabot>  (2,3)
12:16:55 <mmorrow> readability!
12:16:58 <Deewiant> @pl \m n -> takeWhile (<m) [n+1,n+2]
12:16:58 <lambdabot> (. liftM2 (:) (1 +) (return . (2 +))) . takeWhile . flip (<)
12:18:55 <Deewiant> @. pl undo \m n -> [ x | x <- [n,n+1], x < m-1]
12:18:55 <lambdabot> (. ap (:) (return . (1 +))) . (=<<) . flip flip [] . (`ap` return) . (if' .) . flip (<) . subtract 1
12:19:02 <Deewiant> that's a good one
12:19:39 <mmorrow> whats this "@. pl undo" business?
12:19:59 <Cale> mmorrow: @. composes lambdabot commands
12:20:06 <Deewiant> undo opens up the list comprehension
12:20:08 <mmorrow> oh snap
12:20:18 <Deewiant> it doesn't always work as it should though
12:20:29 <Deewiant> @. pl src id
12:20:29 <lambdabot> (line 1, column 1):
12:20:29 <lambdabot> unexpected end of input
12:20:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:20:35 <Deewiant> @src id
12:20:35 <lambdabot> id x = x
12:20:37 <Deewiant> @pl id x = x
12:20:38 <lambdabot> id = id
12:20:43 <mmorrow> @. pl unpl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:20:45 <lambdabot> (return .) . ap (,) . (. (take 2 . iterate (1 +) . (1 +))) . takeWhile . flip (<)
12:21:01 <mmorrow> @. unpl pl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:21:02 <lambdabot> (\ k ai -> return (((,) >>= \ p -> (\ al -> takeWhile (\ h -> h < k) (take 2 (iterate (\ d -> 1 + d) (1 + al)))) >>= \ o -> return (p o)) ai))
12:21:13 <mmorrow> @. pl unpl pl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:21:13 <lambdabot> (line 1, column 17):
12:21:13 <lambdabot> unexpected "\""
12:21:13 <lambdabot> expecting variable, "(", operator or end of input
12:21:31 <mmorrow> @. unpl pl unpl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:21:31 <lambdabot>  Parse error at "mn" (column 14)
12:21:32 <Deewiant> @. pl . unpl pl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:21:33 <lambdabot> (return .) . ((,) >>=) . (. (return .)) . (>>=) . (. (take 2 . iterate (1 +) . (1 +))) . takeWhile . flip (<)
12:21:41 <mmorrow> oh
12:22:02 <Deewiant> mmorrow: . is kind of like haskell's (.) in that it only takes two arguments
12:22:13 <mmorrow> ah i see
12:22:35 <EvilTerran> @@ @unpl @pl @unpl \m n -> return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1))
12:22:36 <lambdabot>  (\ j ah -> return (((,) >>= \ o -> (\ ak -> takeWhile (\ g -> g < j) (take 2 (iterate (\ b -> 1 + b) (1 + ak)))) >>= \ n -> return (o n)) ah))
12:22:38 <mmorrow> doesn't do the foldl (.) id for you...
12:22:53 <mmorrow> oooo
12:24:01 <Deewiant> @help .
12:24:03 <lambdabot> . <cmd1> <cmd2> [args].
12:24:05 <lambdabot> . [or compose] is the composition of two plugins
12:24:07 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
12:24:57 <EvilTerran> @list quote
12:24:58 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
12:25:18 <Deewiant> @yhjulwwiefzojcbxybbruweejw
12:25:18 <lambdabot> "\""
12:25:26 <EvilTerran> @@ @@ @read @run let q = (@show @yow) in "<yow> " ++ q ++ " <vixen> @vixen " ++ q
12:25:27 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
12:25:29 <EvilTerran> hm
12:25:31 <EvilTerran> @@ @@ @read @run let q = (@show @yow) in "<yow> " ++ q ++ " <vixen> @vixen " ++ q
12:25:32 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
12:25:36 <EvilTerran> grr. it works in pm.
12:25:51 <EvilTerran> <EvilTerran> @@ @@ @read @run let q = (@show @yow) in "<yow> " ++ q ++ "<vixen> @vixen " ++ q
12:25:51 <EvilTerran> <lambdabot>  <yow> We just joined the civil hair patrol! <vixen> you sound cute :)
12:26:12 <dbueno> dcoutts_: I sometimes produce plans with duplicate packages specified as selected dependencies... do you think I should clean that up afterward or encode it into the problem somehow?
12:26:19 <Deewiant> @@ @read @run let q = (@show @yow) in "<yow> " ++ q ++ " <vixen> @vixen " ++ q
12:26:20 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
12:26:42 <dcoutts_> dbueno: hmm, how does that happen?
12:27:25 <mmorrow> maybe there should be a @reads...
12:27:40 <dbueno> dcoutts_: I have basically boolean vars that correspond to whether we should select each package for installations
12:27:41 <EvilTerran> @@ @@ @read @run let q = (@show @yow) in "<yow> " ++ q ++ " <vixen> \x40vixen " ++ q
12:27:42 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
12:27:45 <EvilTerran> gah!
12:27:52 * EvilTerran thought he'd fixed it there
12:28:16 <dcoutts_> dbueno: yes, and is there not one such var per-package? so can't we only select each package once?
12:28:29 <EvilTerran> @yow
12:28:30 <lambdabot> BARBARA STANWYCK makes me nervous!!
12:28:34 <dbueno> dcoutts_: and three sets of constraints to go along with this: (1) all installed packages are selected; (2) all packages that are available and not installed must have (packages satisfying their) dependencies selected, and (3) all unresolved deps must have satisfying packages selected.
12:28:51 <dbueno> dcoutts_: Oh, right now there's one var per package-identifier.
12:29:07 <dbueno> dcoutts_: Because I thought we might want to install multiple versions of one packages?
12:29:31 <dcoutts_> dbueno: yes, maybe, in some circumstances. That's actually a sticky issue.
12:29:33 <mmorrow> after learning about @. i suddenly feel the urge to read about all the lambdabot plugins
12:29:55 <dbueno> (Sorry constraint (2) should read "all packages selected that are available and not installed must have their deps satisfied".)
12:30:12 <dcoutts_> dbueno: my solver at the moment only picks one version of each package and never several versions
12:31:01 <dbueno> dcoutts_: So if a "valid" (though not minimal) plan might include installing several verssions of something.  oh, but I guess a particular ConfiguredPackage should never have two packages to resolve one dep...maybe that's the problem?
12:31:06 <dcoutts_> dbueno: it's sometimes impossible to get a global solution with that strict a constraint so we may want to allow multiple versions so long as there are no inconsistencies within any individual package's deps
12:31:15 <dbueno> dcoutts_: I'm working on the xmonad test case.
12:32:01 <dcoutts_> dbueno: the current spec for validity in InstallPlan says that two dependencies on a package name within the same plan must be on the same version of that package
12:32:27 <dbueno> dcoutts_: Right, that's what I was aiming for --- the possibility of multiple versions installed in a plan.  But I think, then, I may have to formalise a way for me to know *for which* package's deps a particular package was selected.
12:33:00 <dbueno> dcoutts_: Oh, so even if I produce a plan that installs two diff. versions of the same package in a non-conflicting way, InstallPlan will reject it?
12:33:12 <dcoutts_> dbueno: which means a plan with foo-1.0 and 2.0 is ok so long as we do not have dependencies on foo 1.0 and 2.0 anywhere else in the plan (any deps, not just deps from a single package)
12:33:52 <dcoutts_> dbueno: basically it means that if someone asks to install foo 1.0 and 2.0 then we can do that, but not if both are depended on by anything else in the plan
12:34:04 <dbueno> dcoutts_: Hm, okay.
12:34:32 <dcoutts_> dbueno: the least restrictive condition would be to only disallow actually inconsistent deps
12:34:48 <mmorrow> :t runQ
12:34:50 <lambdabot> Not in scope: `runQ'
12:34:55 <mmorrow> awww
12:35:03 <dcoutts_> dbueno: ie any single package in the plan having multiple versions of a package in its dependency closure
12:35:29 <dbueno> dcoutts_: Right, 'cause then how would it link...
12:35:51 <mmorrow> > VarE . StringL $ "asdf"
12:35:51 <lambdabot>   Not in scope: data constructor `StringL'
12:35:56 <dcoutts_> dbueno: oh, it'd link ok (since the symbols are actually versioned) but it'd probably not compile :-)
12:35:57 <mmorrow> :t VarE
12:35:58 <lambdabot> Not in scope: data constructor `VarE'
12:36:05 <mmorrow> had to make sure...
12:36:11 <dbueno> dcoutts_: Oh, hah.
12:36:58 <dcoutts_> dbueno: eg if we have bytestring-0.9.0.1 and 0.9.0.4 and two other packages are built against one and the other and export functions that use ByteString in the type, then if we compose the two in a fourth package then we find that they types do not match up
12:37:41 <dcoutts_> dbueno: if we happened to know that a package does not use any of the types in its public interface then there is no such restriction, but we do not know that so we have to be conservative.
12:38:15 <dbueno> dcoutts_: Subtle.
12:38:17 <dcoutts_> dbueno: if we had "private-build-depends" then we'd not have any restriction
12:38:41 <dcoutts_> dbueno: yeah it is annoyingly subtle
12:39:18 <dcoutts_> dbueno: so the current restriction might be a bit restrictive but it's also not that bad, it guarantees that you can combine any pair of packages
12:39:37 <dcoutts_> which is a nice property
12:39:50 <dcoutts_> or indeed any subset
12:40:04 <dbueno> dcoutts_: You're saying the current way InstallPlan validates is the least restrictive it can be in this respect, at least without private-build-depends?
12:40:24 <dcoutts_> dbueno: no it's not the least restrictive, it's kind of in between
12:40:44 <vixey> How is |- pronounced?
12:40:46 <BMeph> > thenQ
12:40:47 <lambdabot>  You're welcome! ;)
12:41:17 <vixey> or read
12:41:18 <BMeph> @bot
12:41:18 <lambdabot> :)
12:41:27 <dcoutts_> dbueno: the least would be that condition about no dups in the deps closure of each package, the most restrictive is only one version of a package in the plan globally and the actual current one which is only one version if it's depended on
12:41:38 * edward1 waves hello.
12:41:55 <dbueno> dcoutts_: Ah, k, I think I get it now.
12:42:15 <dcoutts_> dbueno: we should probably change it to be the least restrictive
12:42:32 <dcoutts_> dbueno: and then planners are free to decide if they want to take advantage of that relaxation
12:42:49 <dcoutts_> dbueno: eg my solver would be a good deal more tricky but yours might not
12:43:03 <dbueno> dcoutts_: Yeah, the current solutions produced by my solver --- even when it's correct --- may hit that limitation.
12:43:16 <dbueno> dcoutts_: I have no current mechanism for providing "hints" to the solution.
12:43:40 <dbueno> Unless I can/do encode those constraints as circuits; then it's no problem.
12:43:46 <dcoutts_> dbueno: right
12:44:06 <dcoutts_> dbueno: well I'm happy to accept a patch to change the restriction
12:44:08 <chessguy> @hoogle [a] -> ([a],[a])
12:44:09 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
12:44:09 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
12:44:09 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
12:44:30 <dbueno> dcoutts_: Yes. =]  I'll put it on the back burner.
12:44:39 <dcoutts_> dbueno: it's the PackageIndex.dependencyInconsistencies function
12:44:40 <hpaste>  morrow pasted "playing with fire..." at http://hpaste.org/8132
12:46:04 <hpaste>  morrow annotated "playing with fire..." with "itd be interesting to know" at http://hpaste.org/8132#a1
12:48:44 <EvilTerran> vixey, in what context?
12:49:07 <gwern> @seen nominolo
12:49:07 <lambdabot> nominolo is in #haskell-soc, #haskell.se, #ghc, #haskell-hac4 and #haskell. I don't know when nominolo last spoke.
12:49:13 <gwern> @seen nomeata
12:49:13 <lambdabot> I saw nomeata leaving #darcs, #xmonad and #haskell 1d 1h 5m 57s ago, and .
12:49:31 <dons> dcoutts_: i've just switched to linux, so don't have a haskell package system in place yet. does grabbing darcs cabal-install make sense?
12:49:39 <EvilTerran> vixey, i've seen it used in aximatic logic as "entails"
12:49:42 <dcoutts_> dons: yes
12:49:46 <vixey> for example, Gamma, x : phi |- \y -> x : pho -> phi
12:49:58 <dcoutts_> dons: It's working pretty well atm I think
12:49:58 <dons> ok. will do. i already miss my ghc-core, hmp3, et al.
12:50:09 <gwern> dons: you're no longer on openbsd?
12:50:18 <dons> but we still have a long term goal of fully integrating into the distro package systems, right?
12:50:33 <dcoutts_> dons: depends what you mean
12:50:35 <dons> gwern: right. using arch linux. the bsd of linuxes
12:50:37 <EvilTerran> hm... "<typing context> entails <expression> is of type <type>" ...that kinda works
12:50:49 <dons> dcoutts_: well, i was thinking about writing a program to convert cabal specs into arch packages
12:50:55 <dons> so i can, pacman -S hmp3
12:51:12 <dons> we need that to pick up outside users. to "normalise" haskell as a development environment
12:51:18 <dcoutts_> dons: right, we've got lots of those sorts of translators now. We should really try and combine them a bit and share the best stuff.
12:51:23 <gwern> dons: yes, that doesn't surprise me. what made you switch? that's a fair bit of work
12:51:24 <dons> so you do this in gentoo, right.
12:51:39 <dons> gwern: better multicore support, primarily. also flash and skype
12:51:45 <dcoutts_> dons: yes, there are translators for gentoo, nixos, debian, fedora
12:51:53 <dons> ok. good.
12:52:31 <mmorrow> (fedora is my fav)
12:52:56 <gwern> dons: that makes sense. (but now that I think about it, I am a tiny bit surprised you didn't switch to Nix)
12:53:52 <chessguy> @src partition
12:53:52 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
12:53:52 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
12:53:52 <lambdabot>                               | otherwise = (ts, x:fs)
12:54:18 <chessguy> ha
12:54:19 <chessguy> nice
12:54:41 <dcoutts_> dons: you might like to check out hackport which is the gentoo tool
12:55:02 <dons> ok. cheers
12:55:39 <dcoutts_> dons: are arch packages binary? I mean do they have resolved deps or deps as version ranges?
12:56:15 <dcoutts_> as that makes a difference to how you'd want to generate packages
12:56:45 <dcoutts_> eg we generate gentoo packages as almost a direct translation but for a binary package you'd want a resolved package with exact dependencies
12:57:28 <dons> dcoutts_: yeah, they're binary, and they do dep resolution. i'm not sure how precise the deps are.
12:57:48 <dons> clearly they'll need to be exact for haskell stuff
12:58:06 <dcoutts_> ok, then perhaps it might be better to look at the cabal-rpm tool
12:58:17 <dons> ah, right. gentoo does src builds
12:58:35 <dcoutts_> right, so .ebuild files are very much like .cabal files
12:58:44 <vixey> > const id 3
12:58:46 <lambdabot>  Add a type signature
12:58:52 <vixey> > const id 3 4
12:58:55 <lambdabot>  4
12:59:22 <dmwit> > const 3 4
12:59:23 <lambdabot>  3
13:00:17 <mar77a> :t const
13:00:19 <lambdabot> forall a b. a -> b -> a
13:00:29 <vixey> :t const id
13:00:31 <lambdabot> forall a b. b -> a -> a
13:01:00 <Deewiant> :t flip const
13:01:02 <lambdabot> forall a b. b -> a -> a
13:01:15 <mmorrow> :t flip ($)
13:01:18 <lambdabot> forall a b. a -> (a -> b) -> b
13:01:18 <mmorrow> :t flip id
13:01:20 <lambdabot> forall b c. b -> (b -> c) -> c
13:01:43 <mmorrow> :t flip const
13:01:45 <lambdabot> forall a b. b -> a -> a
13:01:46 <mmorrow> :t const id
13:01:47 <lambdabot> forall a b. b -> a -> a
13:02:02 <mar77a> :t flip . burgers
13:02:04 <lambdabot> Not in scope: `burgers'
13:02:17 <mar77a> :t bin-laden
13:02:19 <lambdabot> Not in scope: `bin'
13:02:19 <lambdabot> Not in scope: `laden'
13:02:27 <mar77a> BARHGHA
13:02:37 <mmorrow> hahasdfg
13:02:58 <vixey> ?djinn (a -> b) -> (b -> c) -> (c -> d) -> (d -> e) -> a -> e
13:02:59 <lambdabot> f a b c d e = d (c (b (a e)))
13:03:13 <Deewiant> @. djinn type flip flip flip flip flip flip flip flip
13:03:15 <lambdabot> f a b = a b (\ c d e -> c e d)
13:03:24 <mmorrow> @pl \a b c d e -> d (c (b (a e)))
13:03:24 <lambdabot> (((flip (.) .) . flip (.)) .) . flip (.)
13:04:06 <MedeaMelana> tease :-)
13:04:43 <conal> probably a lot prettier with (>>>) than (.)
13:05:03 <conal> a >>> b >>> c >>> d
13:05:25 <mmorrow> (.) has a place in my heart (mathematics would cry)
13:05:27 <conal> too bad ">>>" is such a clunky symbol.  like three sharp elbow jabs.
13:05:33 <mmorrow> heh, yeah
13:05:40 <mmorrow> ouch, sto...ouch
13:05:49 <conal> :)
13:05:55 <mmorrow> :)
13:06:45 <dmead> :t .
13:06:47 <lambdabot> parse error on input `.'
13:06:52 <dmead> :t (.)
13:06:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:07:13 <conal> lambdabot's (.) = fmap
13:07:25 <dmead> :t fmap
13:07:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:07:32 <dmead> ah yes
13:07:47 <MedeaMelana> why?
13:07:59 <dmead> ask dons
13:08:18 <conal> i suspect Cale
13:10:04 <stevan> :t succ . read . getLine
13:10:06 <lambdabot> forall a. (Read a, Enum a) => IO a
13:10:57 <Deewiant> @check \n f x -> n >= 0 ==> (iterate flip f !! n) id x == (flip flip flip f) (x :: (Int->Int->Int)->Int->Int->Int)
13:10:59 <lambdabot>  OK, passed 500 tests.
13:11:05 <conal> :t succ . read . Just
13:11:05 <Cale> I'm the one running the bot :)
13:11:07 <lambdabot>     Couldn't match expected type `String'
13:11:07 <lambdabot>            against inferred type `Maybe a'
13:11:07 <lambdabot>       Expected type: a -> String
13:11:25 <Deewiant> :t succ . (.) read . Just
13:11:27 <lambdabot> forall a. (Read a, Enum (Maybe a)) => String -> Maybe a
13:11:52 <dcoutts_> dons: what you'd really want is a 'cabal' binary since it can then bootstrap everything else (including Cabal and itself from source). I've been testing this out recently.
13:12:12 <dons> yeah.
13:12:20 <dcoutts_> just fixing it so it can build older versions of Cabal than the one it was built with
13:12:23 <dons> just gimme 'cabal' which can install things, install itself, et al.
13:12:57 <Cale> MedeaMelana: I just generalised a few of the Prelude definitions for lambdabot.
13:13:49 <MedeaMelana> Such as?
13:13:56 <Cale> MedeaMelana: (.) is normally a special case of fmap, with the Functor in question being ((->) e), that is, functions from a fixed type e.
13:14:18 <Cale> So I generalised that.
13:14:20 <MedeaMelana> That's interesting. A bit like $ being id.
13:14:42 <MedeaMelana> I never realised these things are generalizations of each other.
13:14:43 <dbueno> dcoutts_: Do I need to worry about FlagNames clashing across packages?
13:14:54 <dbueno> dcoutts_: I assume so, right?
13:15:04 <dcoutts_> dbueno: they're considered different for each package
13:15:06 <dibblego> does the prelude source contain the instance Functor ((->) e) somewhere?
13:15:08 <Cale> and (++) is a nicer name for mappend
13:15:20 <Cale> dibblego: Unfortunately that instance isn't even in the Prelude.
13:15:27 <dibblego> in lambdabot?
13:15:27 <dcoutts_> dibblego: Control.Monad.Instances, it's not part of Haskell98 libs
13:15:31 <Cale> dibblego: You have to import Control.Monad.Instances to get it
13:15:35 <dibblego> ah ok thanks
13:15:44 <Cale> I think that instance ought to be in the Prelude.
13:16:10 <dibblego> yes, I find myself disliking the verbosity of the name 'map'
13:16:19 <dibblego> or fmap as it were
13:16:29 <Cale> Well, having map as a prefix version is still nice.
13:16:54 <MedeaMelana> Is it possible to explicitly re-export an instance?
13:17:11 <Cale> MedeaMelana: It's impossible to prevent instances from being exported.
13:17:12 <dcoutts_> MedeaMelana: no, they're always implicitly re-exported
13:18:27 <MedeaMelana> I mean, if Prelude wanted to re-export an instance (or all instances) from Control.Monad
13:18:37 <MedeaMelana> It'd have to export Control.Monad () ?
13:18:46 <dmwit> right
13:18:51 <Cale> > sortBy (comparing length ++ compare) (words "here is a list of words to sort by length and then alphabetically")
13:18:52 <lambdabot>  ["a","by","is","of","to","and","here","list","sort","then","words","length",...
13:19:10 <mmorrow> i think it would only have to import Control.Monad ()
13:19:22 <mmorrow> ?
13:19:28 <dmwit> MedeaMelana: I have a module that I've been growing that exports a whole bunch of useful instances, functions, modules, etc.  Probably not a bad idea to start one yourself.
13:19:31 <Cale> (that's one of my favourite examples of why monoids should have a nicer syntax :)
13:19:49 <Cale> (the name mappend is rather ugly)
13:19:52 <stevan> Cale: has there been any discussion on incorporating those changes to the standard?
13:19:58 <vixey> Cale, (sqrt 2)^(sqrt 2) is irrational by the way :p
13:20:10 <Cale> vixey: Figures :)
13:20:36 <mmorrow> i wish there was a way to hide instances when importing a module
13:20:44 <Cale> vixey: Have a nice proof of it?
13:21:01 <vixey> no I don't
13:21:09 <vixey> It's the GelfondâSchneider theorem
13:21:28 <mmorrow> <something about margins and not having time>
13:21:32 <Cale> oh
13:21:41 <Cale> Gelfond-Schneider.
13:21:45 <Cale> yes
13:21:52 <Cale> Heh, you beat me to it.
13:21:55 <MedeaMelana> I have to think about how ((->) a) is a Functor
13:22:07 <EvilTerran> think of it like (Map a)
13:22:13 <Cale> MedeaMelana: Well, given a type b, you get the type (a -> b)
13:22:22 <EvilTerran> it's surprisingly similar in many ways
13:22:29 <dbueno> dcoutts_: Flags aren't by chance given unique names by cabal when translating them to an internal representation, are they?
13:22:36 <Cale> fmap :: (a -> b) -> f a -> f b
13:22:43 <Cale> so when f = ((->) e)
13:22:51 <augur> "Imperative languages generally rely on a concept of linear time, while aliens, as we know, are fully 4-dimensional beings, able to move back on forth in time freely."
13:22:52 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
13:22:58 <Cale> and that's the type of composition
13:22:58 <EvilTerran> and when f = Map e, fmap :: (a -> b) -> Map e a -> Map e b
13:22:59 <augur> my conclusion from this quote is that aliens program in haskell.
13:23:22 <mmorrow> no. they've already done so tomorrow
13:23:24 <Cale> augur: haha, where'd you get that quote?
13:23:26 <MedeaMelana> hmm
13:23:36 <augur> someone in the esolang channel
13:23:44 <augur> i added the conclusion :p
13:24:09 <conal> augur: that quote describes the difference between imperative and functional reactive programming.
13:24:10 <EvilTerran> MedeaMelana, my point being that you can think of (a -> b) and (Map a b) as both being mappings from a to b, just with different implementations
13:24:26 <augur> does it conal?
13:24:29 <MedeaMelana> EvilTerran: yes, i understand that
13:24:38 <MedeaMelana> EvilTerran: it makes sense
13:24:39 <Cale> Yeah, arrays are just functions with a finite domain that are stored in a peculiar way.
13:24:42 <augur> i like reactive programming, its sexy
13:24:43 <conal> but i'd relate it to functional programming, not to haskell, which mixes functional and imperative.
13:24:56 <augur> its sort of like functional programming in reverse
13:25:18 <conal> augur: frp is about temporal entities as first class values.
13:25:54 <augur> where a functional programming evaluates long changes of nested functions when the topmost is called, reactive programming pushes values up from the bottom forcing each later to revaluate its value
13:25:58 <augur> its kind of cool.
13:25:58 <conal> dons: does pcre-light work in windows?  my 'cabal install ghc-core' choked on pcre-light-0.3.1.
13:26:18 <Cale> (and Maps moreso)
13:26:22 <dmwit> > let x = sqrt 2 in (x ^ x) ^ x
13:26:23 <lambdabot>  Add a type signature
13:26:27 <dmwit> > let x = sqrt 2 in (x ** x) ** x
13:26:29 <lambdabot>  2.0000000000000004
13:26:34 <dmwit> ;-)
13:26:35 <Cale> heh
13:26:46 <Cale> > let x = sqrt 2 in (x ** x) ** x :: CReal
13:26:48 <lambdabot>  2.0
13:27:16 <conal> i like that perspective.  in addition, frp is functional programming.  hm.
13:27:21 <dmwit> That's kind of a famous one, right?
13:27:21 <augur> conal: could you describe in more detail this idea of temporal entities as first class?
13:27:31 <Cale> dmwit: The proof?
13:27:32 <dmwit> Find irrational p, q so that p^q is rational?
13:27:35 <Cale> yeah
13:28:12 <Cale> > let x = sqrt 2 in showCReal 50 ((x ** x) ** x)
13:28:13 <lambdabot>  "2.0"
13:28:37 <Cale> Aw, it's not going to oblige me with a long string of 0's.
13:28:53 <Deewiant> > let x = sqrt 2 in show x ++ repeat 0
13:28:54 <lambdabot>   add an instance declaration for (Num Char)
13:28:59 <Deewiant> > let x = sqrt 2 in show x ++ repeat '0'
13:29:00 <lambdabot>  "1.4142135623730951000000000000000000000000000000000000000000000000000000000...
13:29:05 <Deewiant> :-P
13:29:15 <Deewiant> infinite accuracy floating-point, right there
13:29:21 <Cale> > showCReal 50 (sqrt 2)
13:29:22 <lambdabot>  "1.41421356237309504880168872420969807856967187537695"
13:29:26 <Cale> > showCReal 100 (sqrt 2)
13:29:28 <lambdabot>  "1.4142135623730950488016887242096980785696718753769480731766797379907324784...
13:29:38 <dmwit> > showCReal 100 pi
13:29:39 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
13:29:48 <geezusfreeek> woah that's a lot of digits
13:29:49 <conal> augur: sure.  a central question is how to conceptualize and formalize change through time.  imperative programming (even in Haskell) uses state that changes discretely.  a holder of one value at a time.  there's a representation of the ref/cell, but not of the whole lifetime of its content.  frp captures that lifetime as a single, first-class value.  as well as generalizes it greatly, to allow for continuous change, not merely discrete.
13:29:53 <dons> conal: oh, ghc-core doesn't work on windows, due to some wired in assumptions about where temp files go, and how to get hold of a pager :(
13:29:53 <dmwit> Wow, those digits are correct!
13:29:58 <dmwit> How does it do *that*?
13:30:04 * dmwit is impressed
13:30:12 <Cale> dmwit: By not using floating point to represent the numbers.
13:30:22 <mmorrow> shock! and awe!
13:30:24 <dmwit> Right, that much is obvious.
13:30:39 <augur> hmm. conal, do you have any good intro tuts to frp?
13:30:44 <dmwit> Cale: But it must do a pretty hefty computation to convert itself to String, then?
13:30:53 <geezusfreeek> oh hey conal, how goes it?
13:30:54 <conal> dons: urk!  could i satisfy its assumptions manually?  also, i'm not sure those problems are the ones showing up in pcre
13:31:04 <conal> geezusfreeek: hi.  great
13:31:14 <Cale> Well, computing pi to 100 places isn't that hard :)
13:31:37 <geezusfreeek> > showCReal 1000 pi !! 999
13:31:37 <dmwit> Not these days. =)
13:31:39 <lambdabot>  '9'
13:31:40 <conal> augur: there's a very old fran tutorial that may give a flavor.  it's in http://conal.net/fran/tutorial.htm.
13:31:40 <lambdabot> Title: Composing Reactive Animations
13:31:53 <vixey> > showCReal 100 pi
13:31:54 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
13:32:00 <vixey> great
13:32:16 <conal> augur: i don't know of any modern tutorial.  i better do something about that!
13:32:18 <Cale> It appears to use power series representations for various functions, and arctan in particular.
13:32:20 <dmwit> This doesn't sound right: "It is not known whether 2e, <snip other examples>, ... are irrational."
13:32:23 <dons> conal, right, pcre.h will be missing. you'll need to install the pcre C library.
13:32:41 <dmwit> Surely if 2e was rational, e would be, too?
13:32:45 <Cale> aha...
13:32:46 <augur> conal, how much acid were you on when you wrote these little scripts? :P
13:32:48 <dons> conal, but then, the tool itself won't work for tedious reasons: tmpdir, and absence of 'less' and 'ls'
13:32:48 <vixey> Cale, how did you tell ?
13:32:49 <conal> dons: thanks.  maybe through cygwin install.
13:32:51 <Cale> data CReal = CR (Int -> Integer)
13:32:55 <mmorrow> dmwit: that's most definitely wrong
13:32:56 <vixey> oh reading the source
13:33:01 <dmwit> Cale: Oh, clever!
13:33:19 <vixey> what's the Int for ? :S
13:33:29 <conal> dons: maybe it'll work on cygwin.
13:33:38 <Cale> vixey: precision bound
13:33:50 <vixey> that sounds very dangerous
13:33:51 <conal> augur: :)
13:33:57 <dmwit> mmorrow: Aha, it was a bad copy-paste of 2^e.
13:33:58 <Cale> This is almost directly the definition of a computable real from the literature.
13:34:00 <vixey> I'm sure that is not correct code if it's using Int for that
13:34:20 <mmorrow> dmwit: heh, love when that stuff happens...
13:34:26 <augustss> And the CReal implementation has been proven correct by David Lester.
13:34:29 <Cale> Well, it's reasonably safe, since you'll run out of memory before you can compute more digits than an Int can count.
13:34:38 <dons> augustss: oh?
13:34:43 <dons> conal, ah maybe.
13:34:47 <dons> the dependencies are few.
13:34:48 <augustss> A long time ago
13:34:55 <vixey> running out of memory first doesn't really have anything to do with its correctness though
13:35:16 <geezusfreeek> vixey: practically?
13:35:18 <vixey> > maxBound :: Int
13:35:19 <lambdabot>  2147483647
13:35:50 <mmorrow> vixey: why? choose any number in Z and get yerself to the memory store and you'll get a correct answer
13:36:03 <Cale> vixey: (So long as there are no other bugs) It's not possible to observe a failure.
13:36:19 <mmorrow> (note: oo `not elem` Z)
13:36:21 <vixey> #include <stdlib.h>
13:36:21 <vixey> int main(void) { void * x = malloc(2147483647); return 0; }
13:36:26 <vixey> doesn't crash my computer
13:36:26 <Cale> Note that Int is larger on platforms which allow more memory.
13:36:46 <dmwit> vixey: Try writing zeros every PAGE_SIZE bytes.
13:37:22 <geezusfreeek> hmm... actually, it is possible to observe a failure... consider overflowing an Int far enough to obtain a small positive integer
13:37:39 <geezusfreeek> but that would arguably be a flaw elsewhere in the program
13:38:09 <vixey> what if I want the 2147483646'th digit of a number
13:38:12 <mmorrow> vixey: clever, but exists x `elem` Z | x > maxBound::Int
13:38:29 <vixey> and it happens to require calcuating the 2147483648'th digit of some other numbers
13:38:41 <vixey> mmorrow: I have no idea what that means
13:38:42 <Cale> vixey: Then you'll run out of memory anyway.
13:38:47 <BCoppens> vixey: malloc is allowed to fail
13:39:03 <BCoppens> in which case it just returns NULL
13:39:03 <Cale> Unless you're on a 64 bit platform, in which case those bounds aren't the same.
13:39:28 <augustss> vixey: while I agree in principle that the Int is a problem, it's not really a practical problem.  Not with the speed of CReal
13:39:28 <dmwit> BCoppens: malloc is allowed to fail, *and* malloc is allowed to return a positive value and do nothing! =O
13:39:39 <mmorrow> vixey: that this doesn't have anything to do with the artificial limitations put in place by happening to rep Ints with 32 (or 64, or...) bits
13:39:42 <vixey> BCoppens: malloc didn't fail either
13:40:10 <geezusfreeek> this is definitely no worse than:
13:40:12 <geezusfreeek> :t (!!)
13:40:14 <lambdabot> forall a. [a] -> Int -> a
13:40:14 <dmwit> BCoppens: And, in fact, on most Linux machines, malloc doesn't really do all that much; actual physical pages are allocated lazily thanks to memory management.
13:40:16 <BCoppens> dmwit: hmmm, 'do nothing'?
13:40:22 <Cale> vixey: You can't allocate enough memory for a 2147483648 digit number.
13:40:26 <BCoppens> dmwit: ah, like that, yes
13:40:35 <vixey> geezusfreeek: (!!) only uses (!!) on small arguments than its parameters
13:40:47 <vixey> smaller*
13:41:05 <vixey> I am sure that CReal looks ahead of the digit you ask for
13:41:11 <vixey> (in the sumcomputations)
13:41:16 <mmorrow> (in space)
13:41:19 <geezusfreeek> vixey: but the principle is the same. in what case is it valid to use a value larger than is physically possible for your machine to handle?
13:41:32 <vixey> no the principle is different
13:41:43 <vixey> (that's why I'm worried about this)
13:42:02 <Cale> vixey: It doesn't have spigot algorithms for things, so it can't compute *just* the nth digit.
13:42:13 <Cale> vixey: It computes and stores all the digits up to that one as well.
13:42:33 * dmwit wonders what situations call for >10,000 digit accuracy
13:42:54 <Cale> vixey: Therefore, if your computation needs a number of digits larger than will fit in an Int, you're screwed anyway, since you'll run out of memory.
13:43:10 <dmwit> Forget 2,000,000 digit accuracy, can you name *one* application that has to go above 10,000 digits?
13:43:25 <Cale> dmwit: recreational mathematics problems
13:43:31 <dmwit> heh
13:43:34 <geezusfreeek> some sort of fractal, perhaps?
13:43:45 <mmorrow> digits of pi for a neurotic?
13:43:47 <vixey> Cale: I wonder how hard it would be to formalize that kind of argument
13:43:48 <Cale> and yeah, deep zooming in fractals
13:44:15 <nus> ehm, what would be the closest thing to CLHS for Haskell?
13:44:17 <BCoppens> Cale: aren't fractals mostly recreational maths?
13:44:22 <nus> the reports?
13:44:24 <dmwit> nus: What's CLHS?
13:44:34 <BMeph> conal: So, Fran has a flavor? ;)
13:44:38 <nus> dmead, CL HyperSpec
13:44:41 <b_jonas> who'd notice if you just add random digits after the 10,000th?
13:44:44 <geezusfreeek> BCoppens: some consider them art... which some consider to be recreational ;)
13:44:47 <hkBst> > let primes = filter (\n -> firstFactor n /= 0) [2..]; firstFactor n = let limit = ceiling $ sqrt $ fromIntegral n in (transform (\p -> if p > limit then (True, 0) else (mod n p == 0, p)) primes) !! 0; transform g s = map snd $ filter fst $ map g s in head primes
13:44:49 <vixey> BCoppens: various aspects of the math have real uses
13:44:51 <BCoppens> geezusfreeek: :P
13:44:52 <dmwit> nus: Yeah, the Haskell Report is probably the closest thing.
13:44:57 <nus> damn autocompletion
13:44:59 <vixey> BCoppens: e.g. fractal compression
13:45:02 <lambdabot>  thread killed
13:45:05 <Vq^> nus: whats CL HyperSpec?
13:45:06 <BCoppens> vixey: just like other recreational maths problems, I'd say :)
13:45:07 <hkBst> :(
13:45:32 <mmorrow> b_jonas: someone who likes (head . reverse . show)?
13:45:34 <dmwit> > let primes = filter (\n -> firstFactor n /= 0) [2..]; firstFactor n = let limit = ceiling $ sqrt $ fromIntegral n in (transform (\p -> if p > limit then (True, 0) else (mod n p == 0, p)) primes) !! 0; transform g s = map snd $ filter fst $ map g s in head primes
13:45:49 <lambdabot>  thread killed
13:45:55 <b_jonas> mmorrow: the last digit of pi?
13:46:07 <vixey> yeah.. I'm not sure there's anything in maths which isn't recreational (If you take that to mean interesting/worth studying in its own right/not for practical applications only)
13:46:18 <mmorrow> b_jonas: remember, oo `not elem` (the integers)
13:46:40 <dmwit> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in primes
13:46:41 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:46:44 <nus> Vq^, http://www.lisp.org/HyperSpec/FrontMatter/
13:47:08 <mmorrow> b_jonas: (and you have the choice of computing a number to n `elem` (the integers) digits...n)
13:47:36 <dmwit> nus: HyperSpec means "hyperlinked specification", right?
13:47:58 <geezusfreeek> > showCReal 1000 $ sqrt 2 * sqrt 2
13:48:02 <lambdabot>  "2.0"
13:48:33 <nus> dmwit, yep, it's quite handy, and there's hyperspec.el for emacs for lookups
13:48:40 <Deewiant> > showCReal 1 2 ++ repeat '0'
13:48:42 <lambdabot>  "2.0000000000000000000000000000000000000000000000000000000000000000000000000...
13:48:50 <mmorrow> > (**2) $ sqrt 2
13:48:51 <lambdabot>  2.0000000000000004
13:49:07 <dmwit> > sqrt 2 ^ 2
13:49:08 <lambdabot>  2.0000000000000004
13:49:15 <Deewiant> > sqrt 2 ^ 2 :: Float
13:49:16 <lambdabot>  1.9999999
13:49:27 <geezusfreeek> impressive
13:49:48 <EvilTerran> mmorrow, function application always binds tighter than operators, so "sqrt 2 ** 2" would be fine
13:50:10 <mmorrow> good to know
13:50:21 <EvilTerran> and :: always binds looser than operators
13:50:33 <mmorrow> but (**) is a function...(just saying)
13:50:45 <geezusfreeek> > showCReal $ sqrt (-1)
13:50:46 <lambdabot>   add an instance declaration for (Typeable CReal)
13:50:50 <geezusfreeek> > showCReal 10 $ sqrt (-1)
13:50:52 <EvilTerran> i mean juxtaposition. but not everyone knows what that means in this context.
13:50:59 <mmorrow> yeah, just being difficult
13:51:01 <lambdabot>  "Exception: Time limit exceeded
13:51:02 <BMeph> Why have a spec, anyway? The lisp-folks will claim that all programming languages are Lisp, to some degree or another. :P
13:53:17 <Socrates`> > 2 :: Complex
13:53:18 <lambdabot>      `Complex' is not applied to enough type arguments
13:53:18 <lambdabot>     Expected kind `?',...
13:53:18 <nus> BMeph, smells like 'turing argument'
13:53:22 <Socrates`> > 2 :: Complex Double
13:53:24 <lambdabot>  2.0 :+ 0.0
13:53:36 <Socrates`> > sqrt ( (-1) :: Complex Double )
13:53:37 <lambdabot>  -0.0 :+ 1.0
13:54:04 <geezusfreeek> > showCReal 10 (sqrt (-1) :: Complex CReal)
13:54:05 <lambdabot>  Couldn't match expected type `CReal'
13:54:12 <EvilTerran> > sqrt (-1) :: Complex Double -- ah, the joys of type inference
13:54:13 <lambdabot>  -0.0 :+ 1.0
13:54:13 <geezusfreeek> oh forgot complex api
13:54:18 <vixey> nus: It's more a very good syntax transformers argument but it's not really true
13:54:49 <geezusfreeek> > showCReal 10 $ realPart (sqrt (-1) :: Complex CReal)
13:54:50 <lambdabot>  "0.0"
13:54:57 <geezusfreeek> > showCReal 10 $ imagPart (sqrt (-1) :: Complex CReal)
13:54:59 <lambdabot>  "1.0"
13:55:05 <nus> actually what I'm looking for is way to peruse ghc via emacs, and I've found haskell-mode lacking
13:55:19 <nus> *is a way
13:55:20 <dmwit> nus: Oh, try :browse
13:55:25 <dmwit> (in ghci)
13:55:33 <dmwit> You can see what a module exports.
13:55:52 <geezusfreeek> > showCReal 100 $ realPart (exp (pi * sqrt (-1)) :: Complex CReal)
13:55:54 <lambdabot>  "-1.0"
13:56:02 <dmwit> I'm sure emacs has a nice way to get ghci in a buffer or something.
13:56:03 <geezusfreeek> > showCReal 100 $ imagPart (exp (pi * sqrt (-1)) :: Complex CReal)
13:56:05 <lambdabot>  "0.0"
13:56:06 <Socrates`> Out of interest, anyone used Leksah?
13:57:32 <nus> dmwit, yes, 'a nice way' even got a name -- 'haskell-mode'.
13:57:49 <dmwit> okay
13:57:58 <dmwit> I use vim, so excuse me for not knowing the names of these things.
13:57:59 <geezusfreeek> haskell inferior mode
13:59:01 <conal> BMeph: flavor?
13:59:35 <conal> geezusfreeek: how are things going?
13:59:40 * edwardk is sitting here thinking about posting a bunch of functional programming in c# tidbits on his blog, but not sure if enough people would care.
13:59:54 <vixey> Zygomorphisms in C#?!
14:00:00 <geezusfreeek> conal: well, i haven't really been working on frp that much the last couple weeks
14:00:02 <conal> edwardk: i'd like like to know what it'd be like
14:00:16 <edwardk> vixey: was going to start small, but I have a fairly large library of stuff that i've written that i use in c# ;)
14:00:24 <geezusfreeek> i did discover a small memory problem even in my new version :(
14:00:38 <conal> geezusfreeek: fixable?
14:00:44 <vixey> I would read it ..
14:00:47 <vixey> if you posted this
14:00:48 <geezusfreeek> conal: don't know yet
14:00:52 <vixey> I don't really know C# though
14:01:07 <edwardk> The thing is i'll admit most of the stuff i do in c# can be condensed down to tricks. and a lot of it gets painfully domain specific.
14:02:42 <edwardk> It is funny how verbose some things get though:
14:03:18 <edwardk> public static class FixedPoint { public static Func<TResult> Of<TResult>(Func<Func<TResult>, Func<TResult>> phi) { Fix<Func<TResult>> Fix = rec => () => phi(rec(rec))(); return Fix(Fix); } }
14:03:31 <conal> ack!!  my eyes!
14:03:34 <vixey> coool
14:03:40 <edwardk> go go gadget Y combinator ;)
14:03:53 <vixey> what sort of things do you write in C#?
14:04:01 <smtms> nothing?
14:04:58 <conal> edwardk: i've stared talking with a group interested in pure functional programming in C#, and particularly functional reactive programming.  my hunch is that they're going to hit some brick walls, at least due to strictness.  i'd love to have some more specifics on what works and what doesn't.
14:05:04 <edwardk> vixey: I do quite a bit of sharepoint development. I also have/had a side project building a massively distributed LINQ provider. That I am in the process of shelving and/or opening up little by little.
14:05:21 <geezusfreeek> conal: it appears that my memory thing is a buildup of stuff from SDL, so i am assuming that i am not properly garbage collecting events from SDL for some reason
14:05:21 <edwardk> conal: frp is going to be hard in a strict environment
14:05:44 <conal> edwardk: yep.  i wonder what else.
14:06:06 <edwardk> conal: well, the lack of parametric polymorphism hurts a lot of the idioms I know and love.
14:06:15 <conal> geezusfreeek: oh, i think andy gill found the same issue with GLUT, in our functional 3D library with frp.
14:06:25 <edwardk> You wind up using reflection a lot as a result.
14:06:29 <edwardk> Or at least I do
14:06:32 <conal> edwardk: c# doesn't have parametric polymorphism now?
14:06:40 <edwardk> It has generics. Not quite the same
14:06:51 <conal> edwardk: what differences pop up?
14:07:15 <edwardk> Well, I can abuse reflection readily to cheat.
14:07:40 <vixey> edwardk: Well I am very glad you're getting the Y combinator into real software :D
14:07:48 <geezusfreeek> conal: i assume it is yet unsolved?
14:07:59 <ddarius> conal: Lack of type inference hurts a lot.
14:08:04 <edwardk> So a function T f<T>(T a) { ... } has all sorts of inhabitants other that id and bottom.
14:08:16 <edwardk> well, with lambdas and 'vars' in 3.5 it doesn't suck so much
14:08:34 <conal> geezusfreeek: i think so, but also not examined much.
14:08:37 <edwardk> but you can't do mixin classes using the boilerplate pattern because of the restrictions on generics
14:08:37 <ddarius> conal: I made a HaXml like library and the type instantiations were taking about as much space as the content.
14:08:47 <edwardk> ddarius: 2.0 or 3.5?
14:09:00 <ddarius> 2.0 but I don't think 3.5's support would help at all
14:09:05 <conal> ddarius: i found something similar in java, with pajama (pan compiling to java).
14:09:30 <edwardk> var and lambdas have cut my code size by a factor of 4-5 in c#.
14:09:48 <edwardk> But it is still fairly verbose by comparison, but its not really a fair fight ;)
14:10:01 <conal> edwardk: var & lambdas??
14:10:05 <ddarius> edwardk: var would barely help and the lambdas wouldn't help at all.
14:10:10 <edwardk> vixey: i'd never use the y combinator in real code =)
14:10:33 <conal> edwardk: oh, i can guess lambda.  what's var?
14:10:40 <edwardk> conal: c# picked up a lambda syntax     x => x + y
14:10:43 <ddarius> Lack of laziness is aggravating for stream based software.
14:10:48 <edwardk> var is 'figure out the type of the lvalue from the type of the rvalue.
14:11:05 <conal> edwardk: oh, limited type inference.
14:11:05 <edwardk> its the c# version of the comparatively new c++ auto
14:11:07 <edwardk> yeah
14:11:35 <edwardk> they added that and anonymous tuples/structs, which helps a lot with writing linq code
14:12:32 <edwardk> The main thing I really really want is real polymorphism and higher kinded types. You can't make a real 'Functor' in that setting.
14:12:59 <conal> edwardk: yeah, that bites. like haskell before gofer.
14:13:05 <ddarius> What's not real about the polymorphism?  Lacking higher kinded types isn't completely unreasonable.
14:13:07 <edwardk> after that then i want rank-n polymorphism so i can port my category theory code =)
14:13:20 <conal> edwardk: are there parameterized type definitions?  there aren't in java 5.
14:13:47 <ddarius> C# could really use type synonyms/typedefs.  I have no idea why they left those out.
14:13:49 <edwardk> class Foo<T> { ... } style generics
14:14:07 <conal> edwardk: class?  what about synonyms?
14:14:07 <edwardk> ddarius: there is a little known typedef using the using clause but its file scoped
14:14:08 <dons> dcoutts_: yeah, starting with a blank system, the first thing i want is cabal-install. we need packages for that on every distro, so i don't have to find HTTP and zlib by hand
14:14:23 <edwardk> using Foo = Something.Really.Long; works
14:14:29 <edwardk> they left it out for separate compilation reasons
14:15:12 <conal> edwardk: i'm going to meet with this group on monday, and i'd like to shock them into seriously considering shifting their work into pure (IO-free) Haskell.
14:15:14 <edwardk> But I do miss real typedefs.
14:15:44 <twobitwork> > let f (IO x) = x in putStrLn "asdf"
14:15:46 <lambdabot>   Not in scope: data constructor `IO'
14:15:51 <twobitwork> why is that?
14:15:57 <conal> edwardk: shock them unless their plan of pure functional (including reactive) programming in c# really is workable.
14:16:03 <edwardk> @hpaste
14:16:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:16:32 <hpaste>  edwardk pasted "c# Maybe" at http://hpaste.org/8134
14:16:54 <edwardk> heh i got cut off by hpaste
14:16:55 <conal> edwardk: i've never been willing to try F(R)P in C#, so my arguments lack some specific grounding.
14:17:11 <edwardk> well, it depends on how they want to represent the events
14:17:23 <edwardk> I suppose you COULD do it, it just requires rethinking a lot of FRP
14:17:26 <tusho> I just had a fun dependent-typey thought
14:17:32 <ddarius> conal: You can probably do it not too insanely if you're willing to tolerate Java-like verbosity.
14:17:39 <twobitwork> can someone tell me why typeconstructor IO isn't in scope?
14:17:41 <tusho> type variables are a bit weird as you either need special syntax - 'a - or a special case for undefined vars in the type level
14:17:43 <tusho> But..
14:17:46 <tusho> forall \a -> ...
14:17:55 <tusho> forall :: (# -> a) -> a
14:18:10 <tusho> Since the only time you get an unscoped type variable is in a function type, and in that case they're implicitly-forall'd...
14:18:18 <conal> edwardk: geez, that c# code goes on & on
14:18:35 <edwardk> tusho: look up pure type systems =)
14:18:47 <Dzlk> Is SyB 2 included in ghc 6.8.2 or do I need the package that I can't seem to find anywhere?
14:18:50 <conal> edwardk: how do those #region constructs get used?
14:19:03 <ddarius> twobitwork: There is no standard definition of the IO type and in practice you wouldn't want to rely on the insides anyway.  There's no requirement that there even be an IO data constructor.
14:19:07 <edwardk> They let you collapse the code in the editor
14:19:16 <tusho> edwardk: Pure type systems for dummies, maybe? :)
14:19:30 <twobitwork> ddarius: interesting...
14:19:31 <ddarius> tusho: That's not anything particular about type variables.
14:19:38 <twobitwork> ?src IO (>>=)
14:19:38 <lambdabot> m >>= k     = bindIO m k
14:19:43 <edwardk> tusho: one sec, there is a very good PTS for dummies paper. lemme find it
14:19:50 <twobitwork> @src bindIO
14:19:50 <lambdabot> bindIO (IO m) k = IO ( \ s ->
14:19:50 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
14:20:02 <twobitwork> how does that work then?
14:20:07 <dons> dcoutts_: cabal-install says my cabal is too new?
14:20:09 <mmorrow> @src forkIO
14:20:09 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
14:20:09 <lambdabot>     where action_plus = catchException action childHandler
14:20:14 <ddarius> twobitwork: That's GHC specific code.
14:20:18 <mmorrow> @src forkOS
14:20:18 <lambdabot> Source not found. stty: unknown mode: doofus
14:20:24 <geezusfreeek> i wish i understood retainer sets somewhat better
14:20:25 <edwardk> tusho: http://people.cs.uu.nl/johanj/MSc/jwroorda/
14:20:26 <lambdabot> Title: Pure Type Systems for Functional Programming
14:20:32 <geezusfreeek> anybody know what CAF,SYSTEM represents?
14:20:40 <vixey> hehe it's called Henk
14:20:42 <ddarius> twobitwork: That code is defined in the same (GHC) module that IO is defined in.
14:20:46 <tusho> edwardk: I hope it really is for dummies ;P
14:20:51 <twobitwork> ddarius: I see
14:20:51 <mmorrow> @src Handle
14:20:51 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:20:58 <edwardk> tusho: it was the first thing that made them click for me
14:21:04 <mmorrow> @src MVar
14:21:05 <lambdabot> Source not found. Are you on drugs?
14:21:13 <dons> dcoutts_: we're up to 1.5.3 without any new hackage releases between 1.2.3 and now?
14:21:20 <dons> so finding 1.3 <=> 1.5 is a bit hard?
14:21:27 <vixey> edwardk: what do you mean click?
14:21:28 <mmorrow> @src newChan
14:21:28 <lambdabot> Source not found. :(
14:21:45 <edwardk> vixey: that moment when you finally understand what is going on
14:22:24 <tusho> edwardk: any HTML version? I don't know if this machine has a ps viewer ATM
14:22:26 <edwardk> conal: and yeah, it does seem a bit verbose doesn't it =)
14:22:35 <edwardk> tusho: i'll convert it real quick
14:23:18 <mmorrow> @src unsafePerformIO
14:23:18 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
14:23:26 <mmorrow> @src unsafeInterleaveIO
14:23:27 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
14:23:58 <mmorrow> @src IO
14:23:58 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
14:24:05 <mmorrow> @src RealWorld
14:24:05 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:24:16 <mmorrow> @src ST
14:24:16 <lambdabot> newtype ST s a = ST (STRep s a)
14:24:19 <mmorrow> @src STTRep
14:24:19 <lambdabot> Source not found.
14:24:22 <mmorrow> @src STRep
14:24:22 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
14:24:23 <b_jonas> @faq
14:24:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:24:32 <edwardk> tusho: http://comonad.com/roorda.pdf
14:24:48 <mmorrow> @src lazy
14:24:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:24:59 <mmorrow> @src seq
14:25:00 <lambdabot> Source not found. Sorry.
14:25:13 <dcoutts> dons: http://darcs.haskell.org/cabal-branches/cabal-1.4/
14:25:14 <lambdabot> Title: Index of /cabal-branches/cabal-1.4
14:25:24 <dons> dcoutts: sweet.
14:25:26 <tusho> edwardk: thanks
14:25:29 <sjanssen> dcoutts: I had trouble finding that as well
14:25:32 <dcoutts> dons: the Cabal-1.4 release will be soonish
14:25:33 <EvilTerran> seq is defined as an internal by the report, and i think lazy is likewise by ghc
14:25:43 <mmorrow> hold on, i
14:25:47 <dcoutts> sjanssen: it's linked on the cabal-install page
14:25:48 <mmorrow> ll find the code
14:25:50 <EvilTerran> ?hoogle lazy
14:25:50 <lambdabot> GHC.Exts.lazy :: a -> a
14:25:50 <lambdabot> Control.Monad.ST.Lazy :: module
14:25:50 <lambdabot> Data.STRef.Lazy :: module
14:26:07 <dcoutts> sjanssen: it will not be needed for long, I'll do another pre-release soon
14:26:16 <dons> so step one for haskell platform compliance: a native binary bundle of cabal-install for the distro
14:26:20 <dcoutts> sjanssen: I'm just trying to test that all packages that work with 1.2 will work with 1.4
14:26:23 <sjanssen> dcoutts: ah, so it is :)
14:26:47 <dcoutts> dons: you can't ask source distros to do binary bundles of anything :-)
14:27:21 <dons> well, those guys make life hard. the general requirement is a single command to get a working cabal-install on your system
14:27:51 <dcoutts> dons: emerge cabal-install :-)
14:27:55 <mmorrow> lazy :: a -> a
14:27:58 <mmorrow> lazy x = x
14:28:00 <mmorrow> it's magic
14:28:05 <dons> dcoutts: perfect.
14:28:18 <sjanssen> dcoutts: so once Cabal 1.4 is out, the new cabal-install will shortly follow?
14:28:19 <dons> i want 'haskell platfrom ready' badges to hand out to distros
14:28:23 <dcoutts> sjanssen: right
14:28:42 <dcoutts> dons: we should update the packaging page as appropriate
14:28:50 <dons> yeah.
14:28:51 <sjanssen> it will probably be a while before Debian can catch up, they have trouble upgrading Haskell libraries...
14:29:29 <tusho> edwardk: I could kinda do with a 3-sentence brief of pure type systems before I delve into this
14:29:29 <dcoutts> dons: as we start to accumulate more packages into the platform we'll need more central testing infrastructure so we can be sure they all actually work and not leave too much QA work for the packagers
14:29:44 <edwardk> tusho: ok fair enough. you know how haskell has types right? =)
14:30:00 <dons> dcoutts: right. so hackage remains the wiki-like free-for-all upload
14:30:13 <dons> then the core platfor undergoes more rigorous Q&A
14:30:14 <edwardk> tusho: and have you looked at something scarier like system F?
14:30:32 <mmorrow> @src unsafeDupableInterleaveIO
14:30:32 <lambdabot> Source not found.
14:30:40 <edwardk> tusho: a pure type system is a very elegant way of taking all sorts of crazy type systems and shoe-horning them into a simple elegant easy to remember structure.
14:30:49 <dcoutts> dons: right, we define a series of subsets of hackage with the innermost being a platform release
14:30:58 <tusho> edwardk: any relation to dependent types?
14:31:46 <edwardk> You basically unify the idea of a function arrow and forall by making them the same thing. Pi a : *. b  = forall a. b, and Pi _: a. b = a -> b
14:32:12 <dcoutts> dons: so the testing infrastructure can be applied to all packages on hackage so it should means we can move a high quality package in quickly
14:32:13 <tusho> edwardk: You lost me. :(
14:32:16 <edwardk> if you have a non-_ in Pi _: a. b, you have a dependent type =) Pi x : a. b  allows x to appear inside b.
14:32:36 <dons> yeah, we'll need automatic testing to choose the core set.
14:32:46 <dcoutts> dons: where as at the moment only ghc and the core packages get regular high quality QA
14:32:52 <vixey> tusho: In depenent types you have types which depend on values right?
14:32:57 <tusho> vixey: Rite.
14:33:12 <vixey> tusho: if you have functions like (+) :: a -> a -> a, then you have values depending on values
14:33:17 <Cale> vixey: Yeah, basically, type constructors which construct types given values, rather than just other types.
14:33:30 <tusho> vixey: expressions are all about values depending on values right? :P
14:33:36 <vixey> tusho: if you have type constructors, thats types depending on types, and something like Fin (n : nat) is a type depending on a value
14:34:05 <edwardk> lets take an example (PI x : Int. SomeFancyVectorType x) would be an example of a dependent type. where the type depends on the supplied integer.
14:34:37 <vixey> tusho: to look at it like a PTS.. say values is *, types is [] .. then [(*,*),([],[]),([],*)] means you have values depending on values, types on types and types on values
14:34:37 <tusho> vixey: Right ... and?
14:34:55 <nominolo> edwardk: i much prefer the forall x:Int. Vector x  or (x:Int) -> Vector x syntax
14:35:28 <dons> woot, cabal-install in place.
14:35:41 <tusho> So wait, in my toy TypesAreValuesValuesAreTypesAndDependentTypesGalore language, I mentally have:
14:35:42 <edwardk> nominolo: i'm kinda neutral on the notation
14:35:46 <tusho> forall : (Type -> a) -> a;
14:35:47 <tusho> and you can do
14:35:47 <vixey> tusho: does it make sense?
14:35:51 <tusho> id : forall \a. a -> a;
14:35:59 <tusho> but
14:36:00 <tusho> technically
14:36:07 <tusho> forall : forall \a. (Type -> a) -> a;
14:36:11 <vixey> id : Pi (A:*), (a:A), A
14:36:14 <tusho> so a bit of recursion there
14:36:22 <vixey> id : Pi (A:*), A -> A  -- add some sugar
14:36:24 <tusho> vixey: I just don't see how that lets me get rid of 'forall' or whatever.
14:36:28 <nominolo> tusho: no, the forall is like the lambda
14:36:30 <vixey> oops
14:36:31 <edwardk> tusho: what you have is an abstract binder. Take a look at Yarrow. They allow you to define new 'binders' using that same general idea.
14:36:34 <vixey> id : Pi (A:*), Pi (a:A), A
14:36:39 <vixey> that's what I meant before
14:36:40 <edwardk> that lets you 'define' forall in the language.
14:36:44 <tusho> edwardk: :|
14:36:45 <dons> $ cabal install ghc-core, and my system is back in business.
14:36:48 <dons> dcoutts++
14:36:51 <tusho> edwardk: But that forall depends on itself for its type
14:36:57 <vixey> tusho: Did you understand what I said about what PTSs are though?
14:37:05 <tusho> Kinda.
14:37:17 <vixey> tusho: Pi *is* forall
14:37:35 <tusho> vixey: So, what, you renamed forall? Somehow I doubt that's what your'e getting at
14:37:41 <nominolo> dcoutts: did cabal-install get any new dependencies other than Cabal, HTTP and tar?
14:37:41 <edwardk> tusho: in their case that would rely on the underlying notion of pi, which IS forall. =) but you might use it similarly for a different Binder, i.e. defining a weak existential or something in terms of universal quantification
14:37:44 <vixey> I didn't rename it
14:37:54 <vixey> this is common notation like using Lambda instead of "Fun"
14:38:15 <tusho> vixey: Well, whatever, still it's just my 'forall' and it's primitive.
14:38:26 <tusho> edwardk: So instead of 'pi' call it 'forall' and write a type function and ...
14:38:50 <vixey> tusho: What are you trying to figure out?
14:39:04 <vixey> tusho: How to erase forall and still have value indexed types?
14:39:34 <tusho> vixey: No. Just what the hell you're all talking about and wondering how on earth I should change my system to it ;)
14:39:49 <vixey> what's your system?
14:39:58 <edwardk> tusho: well, actually 'pi' is a little more powerful than the haskell forall. pi can have different levels of the type system in the place where you put the kind annotation. In haskell forall x : k. ... can only take a kind for k, and can only return a type. You can choose to open that set to a larger domain and/or range in a pure type system
14:39:59 <vixey> (I was trying to explain what a PTS was since you asked)
14:40:15 <tusho> edwardk: ah
14:40:19 <tusho> well my forall : (Type -> a) -> a
14:40:27 <tusho> which, uh, I guess is pi?
14:40:32 <tusho> You could feed it (Type -> Type -> a)
14:40:33 <tusho> or
14:40:35 <tusho> (Type -> Int) or whatever
14:40:45 <vixey> tusho: Have you seen Agda 2?
14:40:54 <tusho> vixey: Seen yes, used no.
14:41:13 <edwardk> tusho: it is 'a particular instance of a type-dependent term, which is a particular form that pi is allowed to take in some pure type systems
14:41:40 <geezusfreeek> is Agda based on CoC or is it some other form of dependent type system?
14:41:47 <tusho> edwardk: What type does pi have, or is it a primitive syntaxy thing?
14:41:52 <dpiponi> hi edwardk
14:41:54 <edwardk> iirc thats possible in any PTS that permits rules of the form (#,*,*)
14:41:57 <edwardk> heya dpiponi =)
14:41:58 <vixey> Agda seems to be CIC + K
14:42:00 <vixey> not sure
14:42:11 <geezusfreeek> what is K here?
14:42:15 <vixey> Axiom K
14:42:21 <geezusfreeek> ah
14:42:22 <vixey> (for pattern matching)
14:42:26 <vixey> I could be totally wrong... though
14:42:34 <nominolo> vixey: seems about right
14:42:37 <edwardk> dpiponi: I figured I slacked enough last week that you didn't have anything to read so I tried to make up for it today =P
14:42:42 <tusho> my language is probably based on the Calculus of WhatTheHellThisIsImpossibleToImplementAndInsanelyNonFormal
14:42:47 <tusho> The PHP of type systems!!
14:43:01 <geezusfreeek> lol, PHP as a type system
14:43:12 <nominolo> tusho: did you look at Qi?
14:43:14 <tusho> geezusfreeek: hahaha, yes
14:43:18 <tusho> nominolo: again: seen, not used
14:43:46 <nominolo> tusho: me neither, but the goal seems similar, except they'd probably call it the "Lisp of Type Systems" ;)
14:43:58 <vixey> nominolo: I don't think Qi is anything other than dynamic types
14:43:59 <edwardk> tusho: if it makes you feel better I spend a fair chunk of time hacking on an effectively untyped toy language, so i'm not wedded to incredible formality, its just occasionally very useful to be precise.
14:44:00 <dpiponi> edwardk: Oh no ! Another post. I hadn't noticed it. I'm going to need to take some days off work to catch up.
14:44:06 <vixey> nominolo: Isn't it just passing predicates around at runtime?
14:44:31 <nominolo> vixey: hm, i thought it allowed you to have a custom type-system
14:44:37 <vixey> yes it does
14:44:46 <vixey> but I think that the type rules are enforced at runtime
14:44:48 <nominolo> vixey: with the soundness proof left to you
14:44:49 <EvilTerran> could you do that with lisp macros?
14:44:53 <vixey> in the same sense as object orientation
14:44:53 <edwardk> dpiponi: I'm thinking about heading up to the MSFP, at least for the day of the workshop, maybe for the conference. Are you going to be there through the whole ICALP thing?
14:44:59 <geezusfreeek> many dependent type systems do require dynamic types
14:45:01 <EvilTerran> statically, even?
14:45:07 <vixey> EvilTerran: You can do much better than Qi with lisp eamacros
14:45:07 <nominolo> EvilTerran: you could...
14:45:14 <tusho> I'ma paste a snippit of code from my language so people go AAAH :D
14:45:24 <tusho> As usual, a typed printf, 'cause i have some kinda typed printf fetish or something
14:45:25 <EvilTerran> (type-system 'system-f (...))
14:45:29 <vixey> geezusfreeek: What do you mean
14:45:49 <vixey> EvilTerran: hehe cool idea
14:45:50 <geezusfreeek> some non-normalizing ones in particular
14:46:01 <geezusfreeek> i'm trying to find an example
14:46:04 <dpiponi> edwark: I'm going to be in Iceland a few days before and a few days after July 6. But I've no plans yet on how I'm going to spend them.
14:46:27 <nominolo> isn't there a conference in island?
14:46:45 <nominolo> er iceland
14:46:54 <Apocalisp> Frábært
14:48:39 <Heffalump> nominolo: MSFP - dpiponi is giving an invited talk at it :-)
14:48:44 <EvilTerran> vixey, let's take things further (evaluation-mode 'lazy (type-system 'system-f (syntax-ext patterns (...)))) :D
14:49:01 <edwardk> dpiponi: Fair enough. Looking at the flights I'm probably going to schedule a flight up there a day or two before the conference. I'd love to take the chance to grab a beer with you (or whatever) if you'd like.
14:49:42 <hpaste>  tusho pasted "AWFUL TYPE-SAFE PRINTF IN MY AWFUL PHP-OF-TYPE-SYSTEMS LANGUAGE ALLCAPS :D" at http://hpaste.org/8135
14:50:00 <dpiponi> edwardk: A beer or two would be great. But note: http://www.pintprice.com/region.php?/Iceland/USD.htm :-)
14:50:01 <tusho> hm
14:50:01 <lambdabot> Title: pintprice.com - The price of beer in Iceland
14:50:03 <tusho> (i::Int) can be i
14:50:13 <edwardk> Heh
14:50:27 <EvilTerran> tusho, cruise control for cool, amirite?
14:50:35 <tusho> and (fmt::Str) is (fmt : Str)
14:50:38 <PeterMc> Hi.  Hope I'm not interrupting anything, but can anyone help me with a simple monadic IO question?
14:50:42 <tusho> EvilTerran: VERILY
14:50:51 <tusho> PeterMc: YES PLEASE STATE YOUR QUESTION
14:50:55 <PeterMc> OKAY
14:50:59 <PeterMc> Dead easy.
14:51:00 <edwardk> PeterMc: Ask away
14:51:09 <PeterMc> I start with:
14:51:09 <Apocalisp> dpiponi: Go to a viking feast in Hafnarfjörður, go snowcatting on a glacier, visit cool places in East Iceland like the Puffin Rock.
14:51:12 <dpiponi> edwardk: Closer to the date let's exchange email.
14:51:14 <EvilTerran> ?quote meta-ask
14:51:14 <lambdabot> No quotes match. You type like i drive.
14:51:14 <geezusfreeek> hmm, perhaps i should just wait until i get home so i can cite something from ATTAPL that i think i remember reading
14:51:20 <edwardk> dpiponi: sounds like a plan
14:51:29 <vixey> tusho: Have you implemented this?
14:51:30 <PeterMc> do handle <- openFile path ReadMode
14:51:48 <PeterMc> contents <- getContents handle
14:51:56 <edwardk> dpiponi: mostly was sounding out if anyone i cared to hang out with was actually planning on attending the main conference ;)
14:52:06 <PeterMc> let contents' = lines contents
14:52:10 <PeterMc> Very straight forward.
14:52:23 <PeterMc> Anyway, then I pick out a piece of data.  E.g.:
14:52:44 <EvilTerran> ?hoogle FilePath -> IO String
14:52:45 <lambdabot> Prelude.readFile :: FilePath -> IO String
14:52:45 <lambdabot> System.IO.readFile :: FilePath -> IO String
14:52:45 <lambdabot> Distribution.Simple.Utils.rawSystemStdout :: Verbosity -> FilePath -> [String] -> IO String
14:52:46 <nominolo> Heffalump: yeah, figured something like this ;)
14:52:48 <PeterMc> let line_1 = head contents'
14:52:52 <EvilTerran> PeterMc, that might be handy, btw.
14:53:07 <EvilTerran> ?src readFile
14:53:08 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
14:53:14 <geezusfreeek> LtU is down! D:
14:53:17 <PeterMc> Oh yeah.  Forgot about that.  readFile does the whole lot in one go.
14:53:21 <PeterMc> Thanks.
14:53:27 <tusho> vixey: no, but I will!
14:53:28 <PeterMc> Anyway.  The next things I want to do are:
14:53:32 <EvilTerran> also, you forgot the h on hgetcontents. but carry on.
14:53:48 <hpaste>  tusho annotated "AWFUL TYPE-SAFE PRINTF IN MY AWFUL PHP-OF-TYPE-SYSTEMS LANGUAGE ALLCAPS :D" with "fixed, and a type safe list builder thing" at http://hpaste.org/8135#a1
14:53:48 <PeterMc> return the piece of data I got from the file and close the file.
14:53:52 <PeterMc> E.g.:
14:53:58 <PeterMc> hClose handle
14:54:05 <tusho> -- with 'fix' at the type level 'cause I didn't wanna define a new type!
14:54:06 <PeterMc> return line_1
14:54:17 <tusho> of course. the types are unreadable
14:54:18 <vixey> so type checking will be able to infinite loop?
14:54:21 <tusho> and I'm mixing lambda syntaxes...
14:54:24 <tusho> vixey: just like in Cayenne, yep
14:54:34 <tusho> vixey: it could also destroy your harddrive
14:54:44 <tusho> or solve some kinda mathematical problem before typing or not
14:54:48 <PeterMc> The trouble is, if I close the file *before* I return the datum then, because of laziness (I think), I end up with *nothing*.
14:54:53 <PeterMc> How do I fix that?
14:55:16 <EvilTerran> PeterMc, i think i can guess what your problem is... http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetContents
14:55:17 <lambdabot> http://tinyurl.com/y9dfge
14:55:42 <vixey> tusho: oh it's *you*
14:55:47 <EvilTerran> once you hGetContents, you don't need to worry about closing the file, as hGetContents lazily reads the entire contents of the file then closes it
14:55:49 <PeterMc> EvilTerran: Thank you.  That's precisely what my problem is.
14:55:53 <PeterMc> Oh.
14:55:56 <PeterMc> It closes the file.
14:55:57 <dcoutts> nominolo: only Cabal, network, HTTP and zlib (not tar)
14:56:00 <tusho> vixey: hahahahahahhahah
14:56:04 <tusho> got a problem with that :DD
14:56:08 <dons> dcoutts: cabal install hmp3, now works :)
14:56:13 <PeterMc> I thought it did some kind of weird "semiclose" think, that means I can't open it again later.
14:56:23 <vixey> it's odd that you keep changing your nick
14:56:29 <tusho> vixey: no.
14:56:32 <tusho> ehird->tusho
14:56:34 <tusho> one change
14:56:36 <hpaste>  tusho annotated "AWFUL TYPE-SAFE PRINTF IN MY AWFUL PHP-OF-TYPE-SYSTEMS LANGUAGE ALLCAPS :D" with "some fixes!! yes, more!!" at http://hpaste.org/8135#a2
14:57:08 <EvilTerran> PeterMc, it semicloses it immediately, but all "semiclosing" it basically means is that it gets closed automatically when all the data's been read (by hGetContents)
14:57:19 <dcoutts> dons: yay
14:57:38 <dcoutts> dons: report any problems you hit that you think are Cabal/cabal-install's fault
14:57:41 <PeterMc> Terran: Thank you.  Problem solved.  Yay!
14:57:41 <tusho> so yeah my latest paste is pretty much totally win
14:57:50 <tusho> apart from the : for types and : for cons thing
14:58:14 <dcoutts> dons: I've been doing some large scale tests trying to install basically everything, under different configurations (different versions of ghc, Cabal lib etc)
14:58:26 <PeterMc> Y'know, it's a long time since I've visited #haskell.  When did it get so *busy*!?  When did Haskell get so popular?
14:58:38 <dibblego> yesterday
14:58:47 <tusho> PeterMc: At least last tuesday.
14:59:01 <tusho> @users
14:59:01 <lambdabot> Maximum users seen in #haskell: 465, currently: 444 (95.5%), active: 17 (3.8%)
14:59:07 <EvilTerran> actually, most of the new folks are chat-bots we wrote while you were away
14:59:08 <tusho> the 2 ruby channels: 523
14:59:09 <tusho> catchin' up...
14:59:15 <tusho> EvilTerran: like me
14:59:19 <geezusfreeek> PeterMc: i started a year and a half ago and it seemed about as busy at the time, although i know it has grown significantly since then
14:59:32 <tusho> geezusfreeek: Tell me about geezus!
14:59:41 <tusho> Will he save me, on phonic?
14:59:45 <tusho> (or phonics)
15:00:04 <PeterMc> Anyway, thanks guys.  I'll go back to my hacking now.
15:00:04 <geezusfreeek> tusho: you dare to mock my nick!
15:00:43 <tusho> geezusfreeek: Are you kristean?
15:01:01 <nominolo> has anyone here tried to embed an effect type system into a dependently typed language?
15:01:07 <nominolo> i mean, as a library
15:01:35 <mattam> Look at Ynot.
15:01:40 <geezusfreeek> tusho: i was. i would now consider myself far too distanced from mainstream christianity to say that i am one anymore
15:01:44 <augur> conal: thinking about it, reactive programming is the reverse of functional programming in another way: its 100% side effects
15:01:51 <tusho> geezusfreeek: were you a geezus freeek?
15:01:55 <mattam> @where Ynot
15:01:55 <lambdabot> I know nothing about ynot.
15:02:07 <conal> augur: interesting.  it's also 100% free of side-effects.
15:02:12 <augur> :)
15:02:21 <EvilTerran> ... maybe they're co-side-effects?
15:02:23 <tusho> oh, and: my language will let you use arbitary modules in the type system
15:02:24 <geezusfreeek> tusho: yup
15:02:32 <conal> augur: i suspect we're thinking about side-effects on different levels
15:02:33 <tusho> your program could pop up a wx gui asking people what parts of the program they want to compile!
15:02:36 <tusho> :D
15:02:46 <tusho> geezusfreeek: was that the source of your nick?
15:02:47 <Cale> geezusfreeek: do you still believe in the existence of supernatural entities?
15:02:54 <EvilTerran> tusho, you remind me of perl's BEGIN{...} blocks
15:02:56 <geezusfreeek> tusho: yes
15:03:06 <augur> conal: maybe
15:03:12 <geezusfreeek> Cale: i believe in the possibility
15:03:18 <geezusfreeek> if that is a belief
15:03:22 <augur> conal: im probably using the term wrong
15:03:33 <geezusfreeek> it depends on the meaning of "supernatural"
15:03:40 <tusho> EvilTerran: I wonder if you can nest them?
15:03:42 <conal> augur: there are lots of ways to use a term.  one doesn't have to be wrong.
15:03:48 <EvilTerran> tusho, yes, you can
15:03:55 <edwardk> I can't get God to typecheck ;)
15:03:59 <EvilTerran> you can also do weird stuff like nesting BEGIN{}s and END{}s
15:04:07 <tusho> geezusfreeek: did it not occur to you that it sounds a bit sarcastic? :P
15:04:30 <tusho> geezusfreeek: (ps believing in the possibility of supernatural entities without directly believing in them would be agnosticism or close i'd say)
15:04:34 <geezusfreeek> tusho: quite sarcastic, but i won't give in to heckling :P
15:04:49 <EvilTerran> although i don't remember what the semantics are. i wouldn't be surprised if the manual doesn't say.
15:04:49 <augur> conal: but i think, like, where in haskell you have IO monads and such as a sort of.. thing on top of the functions, with reactive programming the IO is the fundamental notion that drives everything
15:04:49 <dibblego> no it wouldn't
15:05:04 <Cale> geezusfreeek: I've stopped believing even in the existence of objective truth, but consider myself an atheist because I don't use the existence of a god to make any of the conclusions that I do.
15:05:05 <geezusfreeek> tusho: there actually is such as thing as an agnostic christian
15:05:21 <dibblego> agnosticism is an epistemological position
15:05:22 <tusho> geezusfreeek: no, no there isn't. if there is it's an abuse of terms :P
15:05:38 <dibblego> tusho, yes there is, also agnostic atheist
15:05:40 <tusho> or rather we're using different ones..
15:05:47 <dibblego> tusho, no, you are abusing the term agnostic
15:05:57 <tusho> :)
15:05:58 <dibblego> (it's incredibly common)
15:06:03 <EvilTerran> "someone who follows the teachings of christ without believing him to be the son of god, that he died and rose again, etcetc"
15:06:21 <tusho> EvilTerran: ok, that's totally cool, I believe thomas jefferson was like that
15:06:29 <Cale> EvilTerran: Are you sure that's what it is?
15:06:29 <augur> is that what "christian" means tho? i mean
15:06:34 <tusho> but I wouldn't call those people 'christians', really
15:06:44 <geezusfreeek> heh, that's exactly why i'm not sure whether to call myself a christian
15:06:45 <mattam> @where+ Ynot http://www.eecs.harvard.edu/~greg/ynot/
15:06:45 <lambdabot> Nice!
15:06:50 <augur> i agree with tusho
15:06:53 <EvilTerran> that's what i understand the term "christian atheist" to mean
15:07:01 <tusho> they follow the teachings of christ (though personally I think that guy's morals were crap) but considering with what is referred to as a 'christian' it seems silly to call them that
15:07:04 <augur> you wouldnt be a christian if you didnt believe the religious stuff
15:07:14 <vixey> maybe #haskell-blah..
15:07:19 <tusho> vixey: i agree
15:07:21 <dibblego> we are talking about the fact that agnosticism versus atheism/theism are unrelated
15:07:24 <geezusfreeek> yeah i was thinking blah as well
15:07:27 <tusho> but whenever anyone says that, the conversation dies
15:07:27 <tusho> :P
15:07:34 <augur> anyway, conal, tell me more of what you know about frp
15:07:47 <dibblego> I am agnostic atheist; when I get to work, I will see my friend who is agnostic theist
15:07:53 <nominolo> mattam: thanks. looks interesting
15:07:58 <dibblego> @go epistemology
15:07:59 <lambdabot> http://en.wikipedia.org/wiki/Epistemology
15:08:03 <conal> augur: i think of I/O (more specific than the IO "sin bin") driving frp only as much other functional (no-IO) programming in haskell.  for instance, why does a number get computed other than because it's output?
15:08:39 <tusho> i am turtleist
15:08:44 <tusho> I believe in turtles and their innate type-system power.
15:08:59 <nominolo> FSM FTW!
15:09:31 <tusho> nominolo: die heretic
15:09:37 <tusho> turtles will infer your type ... IN HELL!
15:09:45 <tusho> (I am talking about types every 2nd message so this is on topic okay.)
15:09:49 <conal> btw, one question is whether jesus would be a christian.
15:10:04 <tusho> conal: jesus was a jew I don't think anyone sane would argue with that
15:10:06 <nominolo> well, god is an atheist
15:10:13 <conal> though, i agree -- #haskell-blah
15:10:19 <geezusfreeek> conal: definitely not the christians we all know today
15:10:20 <augur> i guess. but in haskell its always pulling data, and if you're dealing with IO you have to do fancy stuff thats more complicated that normal functions, whereas with reactive programming it seems like those grungy IO things are so fundamental to the paradigm that they just sort of permeate every little thing; IO becomes no different from any other reactive relationship
15:10:22 <tusho> conal: but, it's about the TYPE of god!
15:10:22 <Cale> tusho: I've seen people argue with that, stupidly enough.
15:10:28 <conal> tusho: not so clear.  the first christians were *all* jews.
15:10:29 <dons> would jesus like static typing?
15:10:39 <tusho> dons: no, he was a bit too contradictory for that
15:10:51 <tusho> i guess if you could have multiple types of functions, that'd be OK
15:10:51 <geezusfreeek> @faq Can Haskell save my soul?
15:10:52 <lambdabot> The answer is: Yes! Haskell can do that.
15:10:56 <dons> i guess if you can turn water to wine, you can turn runtime errors into a list of success
15:11:16 <jfredett> dons: lol
15:11:20 <tusho> @faq Can Haskell have the same type language as value language?
15:11:20 <lambdabot> The answer is: Yes! Haskell can do that.
15:11:21 <dons> dynamic typing is a bit miraculous
15:11:21 <tusho> IT LIES
15:11:27 <conal> btw, i've just tuned into #haskell-blah, hoping the religious conversation continues there, or at least discontinues here.
15:11:34 <nominolo> it DEPENDS...
15:11:35 <Cale> @faq Can Haskell prove that souls don't exist, making geezusfreeek's question only vacuously true?
15:11:36 <lambdabot> The answer is: Yes! Haskell can do that.
15:11:40 <glguy> @faq Can Haskell make Ruby look good?
15:11:40 <lambdabot> The answer is: Yes! Haskell can do that.
15:11:52 <Vulpyne> You found a bug.
15:12:03 <jfredett> @faq Can Haskell make Ruby look bad?
15:12:04 <lambdabot> The answer is: Yes! Haskell can do that.
15:12:13 <EvilTerran> s/can do/does/
15:12:24 <jfredett> no, @faq just argues from a complete, rather than a consistent logic.
15:12:39 <augur> http://xkcd.com/224/
15:12:39 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
15:12:41 <tusho> hahaha, jfredett
15:12:55 <jfredett> every valid question is a theorem, but there exist contradictory theorems
15:13:06 <tusho> @faq can i borrow some sugar?
15:13:06 <lambdabot> The answer is: Yes! Haskell can do that.
15:13:07 <geezusfreeek> @faq Can Haskell create an expression so complex that it can't evaluate it?
15:13:08 <lambdabot> The answer is: Yes! Haskell can do that.
15:13:14 <conal> augur: i wonder if you're thinking of a particular implementation of frp, rather than the semantics.  there's nothing i can think of that's IO-related about frp, other than its implementation.
15:13:29 <augur> perhaps
15:14:04 <conal> and of course, the *implementation* of pure (no IO) lazy functional programming is chock-full of side-effects.
15:14:28 <tusho> conal: not in a lazy language
15:14:42 <conal> tusho: especially in a lazy language.
15:14:46 <nominolo> tusho: what would you call a thunk update then?
15:15:04 <nominolo> or a stack push, or a heap allocation, ...
15:15:06 <tusho> nominolo: You can implement the LC in Haskell without any side effects..
15:15:22 <mmorrow> inefficiently
15:15:25 <conal> tusho: then you'd get call-by-name but not laziness
15:15:30 <conal> i.e., not call-by-need
15:15:51 <augur> tusho is an esolanger, he wants to make everything out of lambdas, and the more inefficient the better ;)
15:15:52 * Cale hates the call-by terms since he can never remember which is which.
15:16:05 <Cale> conal: Are you saying you'd get normal order rather than lazy evaluation?
15:16:11 <tusho> audreyt: shush you, grownups are talking about things in coo-coo dream land
15:16:17 <tusho> err
15:16:19 <tusho> augur too
15:16:21 <augur> hahaha
15:16:26 <edwardk> I still think call-by-coinflip would be fun =)
15:16:43 <nominolo> edwardk: that's game theory, right?
15:16:52 <conal> Cale: yes, for instance.
15:16:54 <tusho> edwardk: a language that evaluates expressions in every call-by-X parallelly
15:16:58 <tusho> the one that finishes first gets used
15:17:00 <Cale> Heh, probabilistic termination properties.
15:17:02 <tusho> and the rest are terminated
15:17:17 <edwardk> Well, I was mostly facetiously referring to call-by-whatever-the-hell-the-system-feels like. which works as long as you only apply it to total functions.
15:17:21 <conal> and there are many additional side-effects in the implementation of pure FP.
15:17:32 <augur> is haskell easy to parallelize?
15:17:49 <tusho> augur: no, it is impossible
15:17:50 <tusho> you can never do it
15:17:51 <nominolo> augur: there's a paper on it
15:17:52 <tusho> it's magica
15:17:52 <tusho> l
15:17:55 <edwardk> but it would be nice to have it with a known distribution because then you can use probability theory, and it'd be cool to see a termination argument that used Tchebysheff's theorem or something =)
15:17:58 <Cale> augur: Compared to languages with more side effects, yes.
15:18:00 <tusho> as soon as you parallelise haskell - it turns into a donkey
15:18:07 <nominolo> augur: from satnam sing at the last icfp
15:18:23 <Cale> We have a few means of writing parallel code.
15:18:25 <edwardk> er his inequality
15:18:40 <augur> then i imagine that haskellers will be in greater demand in the near future. there was an article recently about how wallstreet coders cant hack parallelism, and i suspect its because they're all java programmers.
15:18:41 <Cale> One is via parallelism annotations (par/pseq)
15:18:59 <nominolo> edwardk: my answer was more meant as a joke, but sure, with total functions the evaluation order doesn't matter
15:19:04 <Cale> another is by parallelising concurrency, and we have nice systems for concurrency like STM
15:19:23 <Cale> and yet another which is being worked on, and possibly the most promising, is data parallelism
15:19:50 <Cale> In which you simply define computations on a particular datatype (called a parallel array), and the work is automatically load-balanced across available cores.
15:20:09 <nominolo> Cale: you can already (kind of) do this in MATLAB
15:20:16 <nominolo> though it's more manual
15:20:25 <nominolo> and not really NDP
15:20:36 <mmorrow> and for $99 (if your a student)
15:20:44 <edwardk> nominolo: or if you CPS transform it first. I've been toying with that style because it permits a whole lot more optimizations in the compiler, of course its a whole lot harder to prove that something never happens though. so things like contract checking blow up
15:20:45 <mmorrow> octave!
15:20:56 <edwardk> because you have to check all possible reduction paths, not the single canonical one
15:21:25 <nominolo> edwardk: don't dependently typed languages guarantee totality?
15:21:28 <edwardk> nominolo: (in the absence of a nice proof of confluence of the system)
15:21:40 <Cale> Yeah, the data parallelism which the GHC guys are working on is nested data parallelism, which means that you can have parallel algorithms which use other parallel algorithms (and don't need to know that they're actually parallel), and the system flattens things out to ensure that work is distributed in a fair way
15:21:43 <edwardk> nominolo: most of the ones used in practice, but they don't have to
15:21:54 <nominolo> edwardk: right
15:22:46 <nominolo> Cale: though oftentimes you want to control how your data is distributed;  but it's still very interesting
15:22:55 <Cale> augur: Yeah, I see Haskell (or something like it) as the inevitable conclusion of moving to processors with large numbers of cores.
15:22:59 <nominolo> Cale: the alternatives a way worse.
15:23:25 <edwardk> nominolo: I keep messing around with ripping out types, just testing approximately for failed case matches, and checking contracts to enforce bigger picture constraints.
15:23:47 <edwardk> nominolo: giving up decidability of type checking for a 'best effort' static contract checking style approach.
15:24:19 <nominolo> edwardk: i'm not so convinced about contracts, so far
15:24:31 <edwardk> nominolo: the problem is its been one of those 10% draws on my attention for a couple of years, I need to just binge on it long enough to get somewhere definitive
15:25:03 <edwardk> nominolo: What I've done with predicate subtypes convinces me they really make for an expressive type system, even if you can only partially check them
15:25:30 <nominolo> edwardk: but many tricky errors are still at runtime, right?
15:25:58 <nominolo> otoh, better than doing it manually
15:25:59 <Cale> It's fairly ridiculous, if you're setting out to make parallel programming easy, to start with a language that has lots of side effects, where you're kind of dead from the outset, and try to do things to prove that operations can really be carried out in parallel and revive yourself. It seems so much more natural to start from a pure language, where you know that computations can be carried out in parallel safely, and
15:25:59 <Cale>  cautiously add only the effects which are really required.
15:26:03 <conal> Cale: just to be clear, do you mean *pure* (IO-free) Haskell?
15:26:08 <Cale> conal: yeah
15:26:37 <edwardk> nominolo: Well, my preferred model is to inject them at compile time SCC/ESC/Haskell style, check them then, and if you can't prove they hold then emit a warning and then compiler flags can say if that is acceptable and/or if you should insert runtime checks
15:26:59 <roconnor> When will I learn my lesson to not read reddit comments?
15:27:03 <Cale> roconnor: heh
15:27:09 <edwardk> ideally i'd like the ability to fire off a manual theorem prover to dump a proof of correctness into a database interactively, but thats not going to hit mainstream ;)
15:27:10 <nominolo> edwardk: i see
15:27:10 <dons> i've modified my hwn script to do daily updates of new packages, published on haskell.org,
15:27:12 <Cale> roconnor: What's going on now?
15:27:14 <dons> http://haskell.org/
15:27:15 <lambdabot> Title: Haskell - HaskellWiki
15:27:24 <dons> what do people think of the 'Recent packages' section?
15:27:35 <Cale> dons: great!
15:27:38 <dons> i'm hoping that this helps the front page stay more up to date
15:27:51 <roconnor> Cale: stupid (aka "funny") comments get modded up to the top, where I don't want to read them.
15:27:54 <nominolo> dons: date would be nice
15:27:57 <edwardk> nominolo: but they let you flag more stuff at compile time than without them without appreciably increasing developer effort. because if you ever DO fire one off with a counter example you get the actual case and a trace to fix
15:28:03 <edwardk> so it leads to a nice development process
15:28:52 <dons> nominolo: ok.
15:29:30 <Cale> conal: I also mean in terms of designing programs in Haskell with IO, where you have the choice of what goes in IO and what doesn't.
15:29:54 <nominolo> edwardk: and you're looking into how the compiler can still extract some information from those constraints?
15:30:49 <edwardk> nominolo: yes. because those constraints let the compiler have more knowledge about what optimizations are allowed, in some cases they directly supply 'local rewrite rules' it can use.
15:31:34 <tusho> Hmm.
15:31:36 <nominolo> would speculative optimisations also be possible?
15:31:36 <edwardk> nominolo: i started out interested in layering them on top of something like Haskell ala Dana Xu's stuff, but I think its more interesting to try them in a void over something closer to an Erlang with Haskell-like data constructors.
15:31:37 <tusho> test : test; test = test;
15:31:50 <tusho> Types referencing values that aren't defined at the type level, eek :P
15:31:53 <tusho> Thankfully that doesn't work.
15:32:14 <edwardk> nominolo: speculative execution is just an evaluation strategy its not incompatible with any of this.
15:32:16 <dcoutts> dons: perhaps "Recently updated packages" is a better description
15:32:26 <edwardk> Nothing here cares if its lazy or strict really.
15:32:34 <nominolo> edwardk: no, i mean speculative _optimisation_ ie, like jvm does
15:33:09 <edwardk> nominolo: ah, yes definitely i need it for open cases. will be back in ~20 minutes. food =)
15:33:12 <nominolo> edwardk: or rather HotSpot.  like assuming short ints, and specialising
15:33:18 <dons> i was basing it on this, dcoutts, fwiw, http://www.archlinux.org/
15:33:19 <lambdabot> Title: Arch Linux
15:33:37 <dons> we could almost add "Package search" to the front page too..
15:34:19 <dcoutts> dons: note that that page has a slightly more accurate title of "Recent Updates" rather than "Recent Packages"
15:34:41 <dons> yeah, i think i like "Recent Updates" better
15:35:06 <dcoutts> dons: and in that context the packages bit is implicit but for haskell.org I think packages needs to be explicit (afterall it's not updates to the language! :-))
15:35:53 <dcoutts> dons: and we've got more space for a three word title with our layout, hence "Recent Package Updates" or "Recently Updated Packages"
15:36:23 <dons> yep, i'm going with the former
15:37:08 * nominolo was about to propose exactly the same
15:37:11 * dcoutts thinks the haskell.org front page scrolls too much
15:37:29 <dcoutts> all those important links on the side bar that you have to scroll to see
15:37:52 <dcoutts> and all that wasted space at the top
15:38:00 <tusho> haskell.org is just a wiki, so
15:38:32 <dcoutts> yeah but the front page needs special attention and consensus
15:38:33 <nominolo> mediawiki does allow special front-pages
15:38:45 <nominolo> dcoutts: i won't try again
15:38:47 <tusho> does it nominolo?
15:38:48 <tusho> Example?
15:38:58 <mm_freak> what is the preferred way to build a test program along with a library, that i don't want to distribute, just for quick-n-dirty tests?
15:39:02 <nominolo> tusho: www.wikipedia.org
15:39:06 <dcoutts> nominolo: won't try what again?
15:39:10 <tusho> nominolo: that's a custom html page.
15:39:19 <tusho> http://en.wikipedia.org/wiki is the real wikipedia url.
15:39:20 <lambdabot> Title: Main Page - Wikipedia, the free encyclopedia
15:39:23 <nominolo> dcoutts: trying to find a concensus
15:39:29 <tusho> wikipedia.org is just a hand-written page linking to the actual wikis.
15:39:30 <dcoutts> nominolo: oh, heh
15:39:35 <nominolo> dcoutts: someone with some respect should just do it
15:39:40 <nominolo> dcoutts: like last time
15:39:45 <dons> dcoutts: cabal install hackage2hwn works now.
15:39:57 <nominolo> stupid bikesheds ...
15:40:01 <dcoutts> dons: oh you updated hackage2hwn
15:40:05 <dons> yep.
15:40:12 <dons> it now prints the wiki page content instead.
15:40:41 <nominolo> tusho: that's close enough IMO
15:41:01 <tusho> nominolo: It doesn't allow anything, though.
15:41:14 <tusho> It's just like writing HI GO TO MY <wiki> where wiki is a link to the MW installation
15:41:18 <tusho> and putting it in index.html
15:41:22 <tusho> in fact, it's _exactly_ that.
15:41:37 <nominolo> putting the "Haskell" in the logo, decreasing the header size and using a three-column layout will fix all dcoutts' complaints
15:42:03 <nominolo> tusho: if it's an index.html not everyone can edit it
15:42:15 <tusho> nominolo: Nobody can edit wikipedia.org's home page.
15:42:18 <dons> the stuff at the top used to be at the bottom, fwiw
15:42:26 <tusho> nominolo: Go on, find an edit page for that portal.
15:42:27 <dons> the logo, search box, et al
15:42:28 <dcoutts> which was better
15:42:31 <tusho> I'll wait.
15:42:43 <dcoutts> well, the edit stuff is not needed at the top, the search at the top is handy
15:42:56 <nominolo> tusho: ok, i didn't mean the main page, i meant the per-language main pages
15:43:03 <RayNbow> anyone here good at ODEs? I need to confirm my thoughts :)
15:43:08 <tusho> nominolo: ok, but it doesn't allow anything special about them like you implied.
15:43:25 <nominolo> tusho: you can leave out the heading
15:43:29 <nominolo> and some other features
15:43:42 <tusho> nominolo: that's just a regular MW feature
15:43:45 <tusho> you can do it on every page
15:43:46 <nominolo> sure, in it's not completely different
15:43:58 <tusho> nominolo: the main page is not special.
15:43:59 <TomMD> "WARNING: unversioned dependencies are deprecated, and will NOT be accepted by GHC 6.10" -- I'm surprised I haven't seen this before - guess I should pay closer attention to the MLs.
15:44:01 <kilimanjaro> Just curious, is it feasible to embed ghci, hugs, or any other haskell interpreter in a C application so that haskell code can be evaluated at runtime and be invoked from the host program?
15:44:03 <nominolo> but it'll fix the scrolling problem
15:44:14 <dons> kilimanjaro: yeah.
15:44:23 <dons> via ghc-api, or hs-plugins.
15:44:29 <dons> just calling compiled haskell routines is pretty easy
15:44:56 <nominolo> but you'll get quite a big executable
15:45:01 <nominolo> and ghc-api is not stable
15:45:03 <dcoutts> TomMD: I'm not sure it was announced, we were just a bit surprised to see that it was still allowed since it's such an obviously dangerous thing to do and Cabal has been using versioned deps for ever
15:45:11 <nominolo> not yet, anyways
15:46:05 <nominolo> what exactly are unversioned dependencies?
15:46:06 <kilimanjaro> I was just thinking about using haskell in that sort of scenario, I'd like the associated runtime, debugger, etc to be exposed as well
15:46:13 <dcoutts> TomMD: so the only times you'll see that is with old home grown haskell/ghc build systems or if you manually write package registration files
15:46:16 <nominolo> like build-depends: foo?
15:46:26 <dcoutts> no, in ghc-pkg registration files
15:46:26 <kilimanjaro> dons, thanks I'll check out those two
15:46:36 <RayNbow> say, if I have a system of (linear) ODEs in the form of dy/dt = Ay... then the Jacobian is just A, right?
15:46:37 <dcoutts> nominolo: ie for built binary packages
15:47:20 <nominolo> dcoutts: i see, thanks
15:50:13 <monochrom> :âº: :â: :ââ: are the best use of unicode symbols in haskell code I've seen.
15:50:28 <vixey> oh what's this from?
15:50:41 <nburlett> has anyone forced HDBC-postgresql to build under cabal 1.3?
15:50:42 <EvilTerran> ... one more time, for those of us without an appropriate font?
15:50:48 <RayNbow> monochrom: for what are they used?
15:51:04 <monochrom> haskell-cafe, "automatically deriving Map and Filter ..."
15:51:14 <EvilTerran> i get the down-arrow, but the first and last one don't show up here
15:51:18 <RayNbow> EvilTerran: first symbol is like an arrow pointing to its tail
15:51:42 <RayNbow> the last symbol are two arrows pointing away from eachother
15:51:45 <RayNbow> /\
15:51:47 <RayNbow> like that
15:51:54 <EvilTerran> i... see...
15:52:05 <RayNbow> or do you want me to take a screenshot? :p
15:53:01 <EvilTerran> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/40994
15:53:02 <lambdabot> Title: gmane.comp.lang.haskell.cafe
15:53:13 <dcoutts> nburlett: it should work, if not I'll fix Cabal-1.4 to make it work
15:53:24 <nburlett> dcoutts: it doesn't work
15:53:48 <RayNbow> âº <-- damn, my browser doesn't display this one... but my IRC client does...
15:54:16 <RayNbow> (come on, Windows... how hard is it to do fonts stuff correctly :p)
15:54:16 <hpaste>  nburlett pasted "HDBC-postgresql configure failure" at http://hpaste.org/8136
15:54:26 <EvilTerran> RayNbow, it's the other way 'round for me
15:54:49 <dcoutts> nburlett: oh, that's because it's been explicitly prevented from working
15:55:00 <nburlett> dcoutts: oh
15:55:03 <dcoutts> Cabal-Version: >=1.2 && < 1.3
15:55:11 <nburlett> dcoutts:  any ideas on how I can force it to work?
15:55:13 <EvilTerran> iirc, firefox downloaded a load of fonts when i first tried to view a mathml file, and i get the impression it uses those for exotic unicode symbols, too
15:55:14 <dcoutts> nburlett: so I cannot work around that
15:55:19 <geezusfreeek> it all works for me! :D
15:56:11 <monochrom> "computer modern" is the font name
15:56:14 <EvilTerran> if i could put up with how ugly DejaVu Sans Mono is, i'd use that in my IRC client, but i really can't
15:56:45 * PeterMc delurks
15:56:56 <PeterMc> I didn't know you could write Haskell source in Unicode!
15:57:09 <EvilTerran> PeterMc, there's no need to change your nick, btw. we can tell by the scrollback, and by your being set /away or otherwise
15:57:25 <edwardk> back
15:57:26 <dcoutts> nburlett: yeah, two things, one remove the && < 1.3 and also import Distribution.PackageDescription.Parse
15:57:32 <monochrom> DejaVu Sans Mono is not ugly.
15:57:39 <dcoutts> nburlett: I'll fix Cabal-1.4 to make the second change unnecessary
15:57:46 <PeterMc> EvilTerran: Is there an /away command?
15:57:50 <RayNbow> EvilTerran: I use Tahoma in mIRC, but I have no idea what IE uses for rendering webpages :p
15:57:50 <EvilTerran> monochrom, well, that's a matter of opinion. i personally find it literally painful on the eyes.
15:58:43 * PeterMc finds it hard to understand why people get so exercised about different monospace fonts.
15:58:45 <EvilTerran> PeterMc, that'll depend on your client. i've never heard of Purple IRC, but it works on most of them.
15:58:55 <Heffalump> what does $f<number> mean as a cost-centre in a GHC profile?
15:59:04 <edwardk> nominolo: anyways, yeah exploring the basic ideas of polyinline caching in that setting or exploiting the fact that the optimization techniques used in Supero aren't a hack in an environment without types. After all all my structures are effectively getting Reynolds' style defunctionalized anyways )
15:59:25 <PeterMc> EvilTerran: I'm using Pidgin, so I guess it should have all the mainstream functionality working.
15:59:45 <EvilTerran> PeterMc, well, i've done enough graphic design to feel justified in being snobbish about fonts :P
15:59:47 <nominolo> edwardk: which requires whole-program optimisation, right?
16:00:35 * EvilTerran knows what he likes in a monospaced font, and that boils down to approximately "courier new, only with better unicode coverage"
16:00:52 <EvilTerran> i like my letters square, dammit :P
16:01:08 <edwardk> nominolo: to work well anyways
16:01:20 <nburlett> dcoutts: thank you, that worked
16:01:27 <PeterMc> EvilTerran: Fair enough.  All I really care about is that I can distinguish my 1s from my ls and my 0s from my Os.
16:01:40 <nominolo> ok, i gotta rewrite an introduction chapter now
16:01:43 <RayNbow> just wondering, in what color scheme do people run their ghci sessions?
16:01:56 * RayNbow prefers old school green on black :p
16:02:01 <dcoutts> nburlett: it should also work with cabal-install since that'll just pick an older version of Cabal to compile the setup script with
16:02:08 <RayNbow> (reminds me of green monochrome CRTs)
16:02:12 <PeterMc> Incidentally, I once designed a programming language called Woodstock (as in the bird in Charles Shultz's comic strip).
16:02:19 <edwardk> nominolo: I'm keen to explore 'whole program optimization' in a space where most programs are small (due to being small erlang-style mailbox engines)
16:02:21 <nburlett> dcoutts: it doesn't
16:02:37 <dcoutts> nburlett: what version of cabal-install are you using?
16:02:39 <EvilTerran> i find, fairly frequently, but in sans-serif mono fonts in particular, the verticals at the ends of wider letters in monospaced fonts tend to get mushed together
16:02:50 <EvilTerran> which puts me right off a font
16:03:03 <PeterMc> Woodstock's speech is just lots of little vertical lines.  So Woodstock only uses the characters 1, l, I and |.  That's enough for the S, K and I combinators.
16:03:18 <nominolo> edwardk: wow, that was spooky... you talk of defunctionalisation and i *accidentally* open a link to this webpage http://www.iis.sinica.edu.tw/~scm/2007/deriving-a-virtual-machine/
16:03:18 <nburlett> dcoutts: cabal-install version 0.4.6\n using version 1.5.1 of the Cabal library
16:03:19 <lambdabot> Title: Deriving a Virtual Machine | for the few of us., http://tinyurl.com/6p7t9o
16:03:21 <EvilTerran> dejavu sans mono falls into that trap
16:03:22 <MyCatVerbs> EvilTerran: pdbqpdpqb?
16:03:30 <roconnor> what about brackets?
16:03:33 <edwardk> hah
16:03:33 <EvilTerran> MyCatVerbs, pardon?
16:03:41 <MyCatVerbs> EvilTerran: like that --^?
16:03:47 <dcoutts> nburlett: hmm, ok, I'll take a look
16:03:51 <PeterMc> roconner: Don't need 'em.  You just need a prefix functional application combinator.
16:03:59 <MyCatVerbs> EvilTerran: I mean, is that the kind of text patterns that cause that problem to come up?
16:04:07 <MyCatVerbs> Er, pattern, even.
16:04:08 <EvilTerran> kinda. more MNWD...
16:04:17 <roconnor> PeterMc: function application is already prefix.
16:04:26 <roconnor> you still need brackets
16:04:40 <hpaste>  nburlett annotated "HDBC-postgresql configure failure" with "(no title)" at http://hpaste.org/8136#a1
16:04:50 <PeterMc> roconner: What I mean is: app S K
16:05:01 <EvilTerran> roconnor, you only need one "bracketing" character, he means
16:05:05 <PeterMc> Unlambda works the same way.  It's weird, but it works.
16:05:11 <roconnor> ok okay
16:05:28 <MyCatVerbs> EvilTerran: ahhh, I see.
16:06:06 <EvilTerran> roconnor, it's like you don't need parentheses in RPN, i guess
16:06:34 <PeterMc> roconner: It's a bit like writing "cons a cons b cons c nil" instead of "(a b c)".
16:06:41 <roconnor> EvilTerran: is it really?
16:06:56 <roconnor> EvilTerran: I thought RPN usually works because object have a fixed arity
16:07:06 <roconnor> not so with combinators
16:07:07 <EvilTerran> objects do have a fixed arity
16:07:17 <EvilTerran> everything has arity 0, apart from "apply" which has arity 2
16:07:47 <roconnor> well, if you are going to have 4 symbols, then ya, everything is fine
16:08:06 <roconnor> you only need 2 symbols if you are going to use the X combinator and app
16:08:17 <EvilTerran> we've got 4 symbols - "1, l, I and |"
16:08:23 <roconnor> yep
16:08:35 <PeterMc> roconner: Is the X combinator some weird combinator that can do S, K and I all on it's own?
16:08:41 <EvilTerran> PeterMc, exactly
16:08:46 <roconnor> PeterMc: yep
16:08:57 <roconnor> I = SKK
16:09:38 <vixey> X = KSK ?
16:10:00 <vixey> X = \x->xKSK ?
16:10:19 <roconnor> @pl \x -> x K S K
16:10:19 <lambdabot> flip (flip ($ K) S) K
16:10:33 <PeterMc> Oh yuck.
16:10:40 <vixey> @@ @djinn @type flip
16:10:42 <lambdabot>  f a b c = a c b
16:10:52 <vixey> can you write flip using SK?
16:10:55 <edwardk> i x = x S K is the iota calculus version isn't it?
16:11:02 <PeterMc> I was gonna' say that the problem with Woodstock is that pure SKI was just too damn' slow.
16:11:03 <edwardk> Found it: http://barker.linguistics.fas.nyu.edu/Stuff/Iota/
16:11:30 <EvilTerran> vixey, yes - as I = SKK, and SKI is turing-complete, you can write something equivalent to *any* untyped lambda calc expression using just SK
16:11:40 <vixey> can you do it :P
16:11:45 <vixey> *I* can't
16:11:51 * EvilTerran thinks...
16:12:12 <PeterMc> vixey: I spent a lot of time learning how to make SKI do anything I wanted.
16:12:29 <vixey> Can you write flip in SK?
16:12:33 <geezusfreeek> all you'd have to do is figure an algorithm to convert lambda calculus to SK and apply that
16:12:44 <PeterMc> Sure I can.  Gimme' a moment to think about it.
16:12:45 <geezusfreeek> which i don't know my heart, but there is one
16:12:48 <EvilTerran> let's see... pair = \xys.sxy; fst = \xy.x; snd = \xy.y ...
16:12:53 <geezusfreeek> *by heart
16:13:36 <EvilTerran> flip = \p s -> pair snd fst s p - i'm gonna stop now, as i CBA to expand that
16:13:54 <geezusfreeek> :t (<*>)
16:13:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:14:15 <EvilTerran> actually, that should be \p s -> p (pair snd fst s)
16:16:48 <PeterMc> vickey: On second thoughts, I can't remember how any more.  I might need a bit longer to think about it....
16:19:18 <RayNbow> @djinn (a->b->c) -> (a,b) -> c   -- how does djinn actually deal with tuples?
16:19:18 <lambdabot> Cannot parse command
16:19:26 <RayNbow> @djinn (a->b->c) -> (a,b) -> c
16:19:26 <lambdabot> f a (b, c) = a b c
16:19:36 <vixey> what do you mean how?
16:20:10 <vixey> proving (p,q) -> x is equivalent to proving p -> q -> x (by currying)
16:20:18 <monochrom> djinn deals with tuples by having been programmed with rules for tuples.
16:20:58 <monochrom> The next version of djinn will program itself, so it can deal with everything.
16:21:02 <RayNbow> :p
16:21:35 <PeterMc> vixey: Flip is S (S (K S) (S (K S) S)) (K (K K I)) ... I think
16:21:53 <vixey> omg :D
16:22:12 <monochrom> "omgbbqskk"?
16:22:40 * PeterMc can't believe how much of his life he wasted learning this stuff.
16:23:26 <Pseudonym> :t flip
16:23:28 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:24:04 <desp> Did anyone solve the last Google Treasure hunt in haskell?
16:24:17 <dons> ?seen vegai
16:24:18 <lambdabot> I haven't seen vegai.
16:25:05 <Pseudonym> = S (S (K S) (S (K K) S)) (K K)
16:25:16 <desp> Here's my amateurish solution -- http://pastie.textmate.org/209896
16:25:17 <lambdabot> Title: #209896 by Mietek BÄk (desp) - Pastie
16:25:22 <Pseudonym> That's what I make it.
16:25:39 <mm_freak> i'm currently using the FlexibleContexts extension to express this:  eratosthenes :: MArray a Bool m => Int -> m (a Int Bool)
16:25:44 <desp> I was wondering if anyone else had better approaches
16:25:47 <Pseudonym> I think the problem is that you've got stuff like K K I
16:25:50 <mm_freak> is there any way to do it without that extension?
16:25:52 <Pseudonym> Which is, obviously, K
16:26:01 <Pseudonym> Optimise, people!
16:26:04 <MyCatVerbs> @type let { i = id; k = const; s x y z = x y (y z); } in s (s (k s) (s (k s) s)) (k (k k i))
16:26:05 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
16:26:05 <lambdabot>     Probable cause: `k' is applied to too few arguments
16:26:05 <lambdabot>     In the second argument of `s', namely `(k (k k i))'
16:26:26 <PeterMc> Pseudonym: Yes, that's right.  I just noticed that when I was checking my answer.
16:26:30 <Pseudonym> @type let { k = const; s x y z = x y (y z) } in s (s (k s) (s (k k) s)) (k k)
16:26:32 <lambdabot> forall a b. (b -> a) -> a -> b -> b -> a
16:26:35 <Pseudonym> Hmm.
16:26:37 <Pseudonym> Maybe not.
16:26:43 <monochrom> mm_freak: I think FlexibleContext is necessary and rather tame.
16:27:07 <Pseudonym> @type let { k = const; s x y z = x y (y z) } in \f b -> s f (k b)
16:27:08 <lambdabot> forall t t1 a. ((t -> a) -> a -> t1) -> a -> t -> t1
16:27:49 <Pseudonym> Oh.
16:27:51 <mm_freak> monochrom: is there any particular reason for needing an extension here?  or is it just that haskell 98 overlooked that one?
16:27:56 <Pseudonym> @type let { k = const; s x y z = x z (y z) } in s (s (k s) (s (k k) s)) (k k)
16:27:59 <lambdabot> forall t a b. (b -> a -> t) -> a -> b -> t
16:28:00 <Pseudonym> I got S wrong.
16:28:02 <Pseudonym> That's it.
16:28:06 <monochrom> I am not sure.
16:28:21 <mm_freak> ok, thanks
16:28:23 <PeterMc> @type let {k = const, i = id, s a b c = a c (b c)} in s (s (k s) (s (k k) s)) (k k)
16:28:25 <lambdabot> parse error on input `,'
16:28:58 <mmorrow> s/,/;/
16:29:03 <mmorrow> s/{}//
16:29:23 <PeterMc> ï»¿@type let {k = const; i = id; s a b c = a c (b c)} in s (s (k s) (s (k k) s)) (k k)
16:29:27 <PeterMc> meh
16:29:51 <PeterMc> Oh.  Pseudonym's gone and done it for me.  Thanks.
16:29:53 <mmorrow> uhoh it blew up
16:30:18 <mmorrow> i guess the s/{}// wasn't necessary
16:30:33 <PeterMc> Is lambdabot broken now?
16:30:40 <PeterMc> 'kay.
16:30:45 <mmorrow> > fix show
16:30:46 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:31:04 <mmorrow> :t let {k = const; i = id; s a b c = a c (b c)} in s (s (k s) (s (k k) s)) (k k)
16:31:06 <lambdabot> forall t a b. (b -> a -> t) -> a -> b -> t
16:31:09 <mm_freak> is there some "platform's most efficient integer" type?
16:31:34 <geezusfreeek> @type let s = (<*>) in let k = pure in s (s (k s) (s (k k) s)) (k k)
16:31:36 <lambdabot> forall (f :: * -> *) b a. (Applicative f) => f (a -> b) -> a -> f b
16:32:18 <mmorrow> PeterMc: weird
16:32:21 <Pseudonym> mm_freak: No, but I think you just want Int.
16:32:30 <PeterMc> geezusfreeek: WTF's that about?
16:33:07 <PeterMc> flip at the type level, or something?
16:33:17 <geezusfreeek> Applicative is basically a generalization of S and K
16:33:34 <mm_freak> k
16:33:50 <mmorrow> > show . last $ [0..]
16:33:53 <lambdabot>  "
16:33:54 <PeterMc> I read about applicative functors when Conal used them in his FRP library.
16:34:08 <PeterMc> How do I get lambdabot to tell me the definition of something?
16:34:14 <vixey> @src on
16:34:14 <lambdabot> (*) `on` f = \x y -> f x * f y
16:34:18 <vixey> like this maybe
16:34:26 <vixey> it doesn't do @lets
16:34:37 <PeterMc> @src (<*>)
16:34:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:34:48 <vixey> @instances Applicative
16:34:49 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
16:34:52 <PeterMc> lambdabot: That's none of your damn' business.
16:34:57 <vixey> @instances-importing Control.Applicative Applicative
16:34:58 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
16:35:04 <vixey> @src <*> []
16:35:04 <lambdabot> Source not found. You type like i drive.
16:35:11 <vixey> @src [] <*>
16:35:11 <lambdabot> Source not found. My pet ferret can type better than you!
16:35:13 <vixey> :(
16:35:43 <PeterMc> Crumbs.
16:36:09 <Pseudonym> Of course, flip = C.
16:36:15 <PeterMc> Anyway, it's bedtime for me.  Thanks for the stimulative dialogue 'n' stuff.
16:36:32 <PeterMc> Pseudonym: Waddya' mean?
16:36:34 <vixey> bye
16:36:42 <PeterMc> g'night vix
16:36:56 <Pseudonym> Oh, if you're using the practical combinator set, flip is C.
16:37:05 <Pseudonym> S, K, I, B, C, S', B* and C'
16:37:13 <PeterMc> Ah.  Thanks.
16:37:35 * PeterMc waves gobyebye.
16:37:44 <geezusfreeek> pure x y = x; ef <*> ex = \y -> (ef y) (ex y)
16:37:59 <geezusfreeek> aw missed him
16:38:35 <mm_freak> i'd like to write a library, where i want to demand something right at program start (similar to IO's global StdGen), and i want to keep the result for the program's lifetimeâ¦  i've read somewhere that i need unsafePerformIO to do thatâ¦  how?
16:39:34 <geezusfreeek> @type let s = (<*>) in let k = pure in ((s ((s (k ((s (k s)) k))) s))(k k))
16:39:36 <lambdabot> forall (f :: * -> *) b a. (Applicative f) => f (a -> b) -> a -> f b
16:39:36 <Pseudonym> mm_freak: Is your "think" polymorphic?
16:39:38 <Pseudonym> thing
16:39:45 <mm_freak> Pseudonym: nope
16:39:49 <Pseudonym> Excellent.
16:39:51 <Pseudonym> Then you can do that.
16:39:57 <mm_freak> it's a UArray Int Bool
16:39:57 <Pseudonym> If it's polymorphic, you can break things.
16:40:24 <Pseudonym> http://andrew.bromage.org/darcs/dynamicmarkov/IOStableRef.hs
16:40:27 <Pseudonym> There's an example in there.
16:40:28 <mm_freak> more specifically it's just a precalculated prime sieve
16:40:33 <mm_freak> thanks
16:40:37 <Pseudonym> Oh, hang on, no there isn't.
16:40:42 <mm_freak> ok =P
16:40:45 <Pseudonym> Oh.
16:40:49 <Pseudonym> Uhm...
16:40:59 <Pseudonym> If it's a precalculated array, then it's surely not mutable.
16:41:14 <Pseudonym> So why would you use unsafePerformIO?
16:41:18 <mm_freak> it's immutable, of type UArray Int Bool
16:41:27 <Pseudonym> So just make a top-level CAF.
16:41:29 <mm_freak> i want to ensure that it's precalculated
16:41:39 <mm_freak> and that it's never garbage-collected
16:42:00 <Pseudonym> A CAF is only garbage collected if the garbage collector can prove that it will never be used again.
16:42:13 <mm_freak> what is a CAF?  any pointers?
16:42:19 <dons> dcoutts: looks like hackage has fallen into the bytestring update problem
16:42:20 <Pseudonym> CAF = Constant Applicative Form
16:42:28 <dons> with things compiled against the wrong versions of bytestring
16:42:31 <bos> oh noes!
16:42:32 <Pseudonym> It means anything that isn't a lambda.
16:42:41 <dcoutts> dons: aye, not surprising
16:42:45 <Pseudonym> So, for example, at the op level:
16:42:46 <Pseudonym> top
16:42:52 <Pseudonym> f x = 1
16:42:54 <Pseudonym> That's a lambda.
16:42:56 <Pseudonym> f = 1
16:42:57 <dons> yeah, see, e.g. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pngload-0.1
16:42:58 <Pseudonym> That's a CAF.
16:42:59 <lambdabot> http://tinyurl.com/624y8f
16:43:10 <dcoutts> dons: it's exactly what one gets if you just update everything in any old order
16:43:16 <dons> right.
16:43:20 <bos> but f = \x -> 1 is a CAF
16:43:26 <Pseudonym> Yes.
16:43:30 <dcoutts> dons: it needs to be scrapped and replaced with proper build reporting
16:43:31 <dons> when a new package appears, a clever recompilation might be required on hackage
16:43:32 <bos> just to confuse things.
16:43:42 <mm_freak> no compiler flags or pragmas to make GHC detect CAFs?
16:43:46 <Pseudonym> Actually, is it?
16:43:46 <Pseudonym> In Haskell?
16:43:50 <dons> dcoutts: i'm surprised we don't reinstall via a clean 'cabal install' each time
16:43:55 <Pseudonym> mm_freak: Yes.  -O1 or higher.
16:43:55 <bos> Pseudonym: yes.
16:43:59 * Heffalump repeats his question from earlier: what does $f<number> mean as a cost centre in a GHC profile?
16:44:00 <dons> that'd give reasonable warnings about things that aren't cabal-isntallable
16:44:06 <dcoutts> dons: would take a lot of building
16:44:15 <dons> sure, it'd be comprehensive :)
16:44:18 <mm_freak> ok, thank you guys
16:44:30 <dons> Heffalump: hmm, $f, $w is a work, $f, can't recall. SPJ knows
16:44:33 <dcoutts> dons: that's why we want lots of data which means collecting it from clients :-)
16:44:34 <Pseudonym> OK, let me rephrase that.
16:44:38 <Pseudonym> GHC _always_ detects CAFs.
16:44:51 <Pseudonym> But at -O1 or higher, they're floated to the top level.
16:44:57 <Pseudonym> That's what makes them always shared.
16:45:02 <mmorrow> :t let f = flip . flip in f fix f id
16:45:02 <dcoutts> dons: besides the server doesn't have eg gtk, wx, lots of other db libs
16:45:04 <lambdabot> forall b c. b -> c
16:45:04 <mm_freak> well, one question remainsâ¦
16:45:18 <Heffalump> dons: what's a work?
16:45:27 <Cale> :t fix id
16:45:29 <lambdabot> forall a. a
16:45:30 <dcoutts> dons: I'm pretty close to being able to generate build reports in cabal-install
16:45:38 <mm_freak> what if it's a 50 mebibytes array?  does it still precalculate it?  does it precalculate it at all?
16:45:50 <vixey> hi Cale
16:45:54 <Pseudonym> mm_freak: Think lazy evaluation for a moment.
16:45:56 <Cale> hi
16:46:00 <Cale> :t fix ($)
16:46:02 <lambdabot> forall a b. a -> b
16:46:05 <vixey> I found a different proof of strong normalization for simple types
16:46:06 <Pseudonym> It's calculated the first time you evaluate it.
16:46:07 <dons> Heffalump: "worker", sorry
16:46:12 <Heffalump> ah, right
16:46:13 <vixey> at least I think it's different
16:46:20 <Pseudonym> Right?
16:46:22 <mm_freak> ok, makes sense
16:46:23 <dons> dcoutts: great. let me know if you need testing.
16:46:24 <Pseudonym> That's how lazy evaluation works.
16:46:28 <luqui> vixey, cool, sketch?
16:46:35 <Pseudonym> Then it's kept until it can prove that you'll never reference it again.
16:46:36 <mmorrow> :t flip id
16:46:38 <lambdabot> forall b c. b -> (b -> c) -> c
16:46:39 <mmorrow> :t flip ($)
16:46:41 <lambdabot> forall a b. a -> (a -> b) -> b
16:46:59 <mmorrow> :t (flip . flip) id
16:46:59 <dcoutts> dons: I'll probably get onto it seriously after the Cabal-1.4 release
16:47:01 <lambdabot> forall b c. (b -> c) -> b -> c
16:47:04 <mm_freak> any way to force it to be evaluated at program start?  i.e. unboxing the thing?
16:47:06 <mmorrow> :t ($)
16:47:07 <lambdabot> forall a b. (a -> b) -> a -> b
16:47:13 <Cale> vixey: One which doesn't go by induction on the derivation of the type?
16:47:14 <vixey> define the degree of a type t by, d p = 0; d (u -> v) = 1 + max (d u) + (d v)
16:47:23 <Pseudonym> mm_freak: Only way I can think of is to reference it in main.
16:47:29 <Cale> vixey: ah, okay
16:47:36 <dcoutts> dons: though I may hack something together quickly just to help me with testing
16:47:44 <Pseudonym> It's unfortunate that Haskell doesn't have "static arrays".
16:47:50 <vixey> now when a term M is not in normal form, we define mM = (d_M, n_M)
16:47:59 <Pseudonym> But really, this is almost as good.
16:48:04 <Pseudonym> And in some circumstances, better.
16:48:05 <vixey> d_M = max { d(Chi) | Chi is a redex in M }
16:48:13 <mm_freak> Pseudonym: then GHC unboxes it?  (i'd like to remove the check, whether it's already evaluated)
16:48:20 <vixey> n_M is the number of redexs in M
16:48:25 <Pseudonym> mm_freak: Unboxes what?
16:48:28 <Pseudonym> The array?
16:48:36 <mm_freak> yesâ¦  not the array elements, but the array itself
16:48:41 <vixey> so... we actually do proof by induction on the lexiographicaly order list of tuples
16:48:43 <Pseudonym> Arrays aren't unboxed.
16:48:58 <Cale> vixey: interesting...
16:48:58 <vixey> basically normalize the term by reducing the bits which have most complex types
16:49:06 <vixey> until you get the simplest type, the result
16:49:14 <vixey> at least that's my intuition ...
16:49:25 <Pseudonym> mm_freak: I wouldn't worry about it unless it turns out to be a bottleneck.
16:49:37 <Pseudonym> Which I doubt.
16:49:47 <mm_freak> Pseudonym: imagine i need the array a million times a secondâ¦  ensuring that it's available (thus removing the check) will speed things up
16:49:48 <Pseudonym> GHC goes to a _lot_ of trouble to optimise cases like that.
16:50:09 <Pseudonym> If you need the array a million times a second, you're talking about an inner loop, right?
16:50:28 <vixey> if M' is obtained by M, then M' may have more redexes, but it will have less redexes of degree d
16:50:34 <Pseudonym> Chances are very good that whether or not it's evaluated will be checked once _outside_ the loop.
16:50:38 <mm_freak> one possibility is a prime generator, where most numbers are caught by the prime sieve already
16:51:27 <mm_freak> well, i'll just try out, i guess
16:51:31 <Pseudonym> Yeah.
16:51:35 <vixey> oh sorry this is normalization, not strong normalization
16:51:38 <mm_freak> i'm sure, that one can be optimized later easily
16:51:41 <edwardk> @seen dolio
16:51:41 <lambdabot> dolio is in #haskell-blah and #haskell. I don't know when dolio last spoke.
16:51:42 <Pseudonym> I'm curious to know what sort of code you get.
16:51:48 <vixey> strong normalization is that any reduction sequence works
16:51:57 <Pseudonym> If you get bad code, then I think you've got a good case to submit to the GHC guys.
16:52:50 <mm_freak> yeahâ¦  i'll upload it to hackage anyway, since it's one thing missing, and it hurts not to have it:  a fast primality test =)
16:53:01 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/
16:53:02 <lambdabot> Title: Index of /darcs/numbertheory/Math
16:53:11 <Pseudonym> FWIW
16:53:40 <Pseudonym> I'm not happy with the Atkin sieve, though.
16:53:56 <Pseudonym> I think I'll dump it when I get a chance to fiddle with this.
16:54:08 <mm_freak> oh
16:54:20 <Pseudonym> If you want to put it in this library, I'd be very happy for that.
16:54:33 <Pseudonym> I'm sure you can do better.
16:55:11 <mm_freak> are you andrew j. bromage?
16:55:26 <Pseudonym> Yes.
16:55:37 <mm_freak> ok =)
16:55:52 <vixey> I like the idea of using tuples like that
16:56:03 <vixey> It's pretty simple I think to show that it will always terminate
16:56:04 <mm_freak> yes, i'd actually love to contribute to that oneâ¦  didn't even know it before
16:56:35 <Pseudonym> I wrote it mostly to play with the interface, though I'm very happy with the performance of the Fibonacci code.
16:56:47 <Pseudonym> And the factorial/binomial stuff.
16:56:50 <mmorrow> whoa, wtf does this mean:
16:56:57 <mmorrow> [m@ganon SCRATCH]$ ./FixRules
16:57:00 <Cale> vixey: But it takes some cleverness to come up with just enough information in the induction step to make the proof work...
16:57:01 <mmorrow> FixRules: <<loop>>
16:57:11 <mmorrow> (program ends)
16:57:12 <ovnicraft> hi, i use hugs98, but  dont recognize ord function in my prelude (over linux slackware)
16:57:17 <ovnicraft> anyone can help me
16:57:25 <Cale> mmorrow: It means that the program went into a detectable infinite loop, and was killed for it.
16:57:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8137
16:57:35 <Cale> ovnicraft: ord is in Data.Char
16:57:43 <Cale> ovnicraft: type  :also Data.Char
16:57:50 <mm_freak> Pseudonym: ok, i'll have a darcs quickstart and you'll certainly get some patches from me
16:58:04 <codetoad> I have an evaluation order (perhaps?) question -- http://hpaste.org/8137
16:58:08 <Pseudonym> Cool.
16:58:24 <mmorrow> Cale: heh, i kinda got unsafeCoerce from flip, fix, id and a rewrite rule: fix id = undefined
16:58:26 <vixey> I am trying to understand it fully
16:58:32 <mmorrow> Cale: (then)
16:58:42 <Cale> mmorrow: Except that it's not unsafeCoerce :)
16:58:43 <Pseudonym> If you know more cabal than me, feel free to modify that, too.
16:58:53 <Pseudonym> And if you want to fork the repo, do that too, and let me know where it is.
16:58:56 <luqui> mmorrow, instead it's const undefined
16:59:03 <mmorrow> Cale: if you set <<loop>> = segfault, it is :)
16:59:04 <luqui> (for a rather less useful value of undefined)
16:59:24 <Cale> mmorrow: const undefined will do the same thing
16:59:28 <luqui> mmorrow, not so, since unsafeCoerce :: Int -> Int is just id.
16:59:40 <Cale> unsafeCoerce has the property that coercing a value to the same type won't change it
16:59:54 <mm_freak> Pseudonym: if you're well reachable, i don't need to fork itâ¦  my main interest is the Math.Prime part
16:59:55 <mmorrow> so does mine with this rule, hold on i'll paste it
17:00:12 * luqui is intrigued
17:00:23 <Pseudonym> Sure.
17:01:16 <ovnicraft> Cale: where i can find doc about that
17:01:22 <Cale> codetoad: the trouble is that the value containing the exception isn't being evaluated until after the catch ends.
17:01:37 <codetoad> So my C.evaluate isn't strong enough?
17:01:45 <Cale> ovnicraft: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
17:02:05 <Cale> codetoad: evaluate only evaluates things up to determining the top-level constructor
17:02:17 <ovnicraft> Cale: is posible load it and call from 'hugs>'
17:02:21 <Cale> codetoad: So if you give it a list, it'll evaluate it just far enough to decide if it's empty or not.
17:02:22 <luqui> ovnicraft, or haskell.org/hoogle
17:02:34 <Cale> ovnicraft: yes, :also Data.Char
17:02:50 <bos> codetoad: quickcheck is not really the right place to be doing that kind of testing.
17:03:04 <codetoad> bos: what would be better?
17:03:41 <codetoad> i wanted to have full coverage from the tests, and testing the errors is part of that?
17:03:51 <Cale> codetoad: Typically, that kind of exception isn't really meant to be caught (though it's technically possible to do so, as you know)
17:04:04 <bos> codetoad: strictcheck or chasing bottoms.
17:04:10 <dons> you can test errors, you just need to always force the error before catching it.
17:04:16 <Pseudonym> Chasing bottoms sounds fun.
17:04:18 <Cale> You use those exceptions for errors which should never occur.
17:04:19 <dons> bytestring has some tests along this line.
17:04:29 <bos> cale is of course correct.
17:04:39 <dobblego> Pseudonym, now we know what will you be doing this evening
17:04:47 <Pseudonym> I'll stop to pick a buttock up.
17:04:52 <dons> foo_should_fail x = unsafePerformIO (catch (const True) (do let x = my fun to test in x `seq` return x)
17:05:00 <Pseudonym> (That sounds funner in an English or Australian accent.)
17:05:01 <dons> foo_should_fail x = unsafePerformIO (catch (const True) (do let x = my fun to test in x `seq` return False)
17:05:06 <Cale> So typically, just testing the function normally will be enough, and if the test dies with one of those exceptions, you've found a bug.
17:05:12 <dons> codetoad: make sense?
17:05:22 <dons> just force the error inside the catch, so you know it will happen
17:05:29 <dons> then check in the handler it is of the form you expect
17:05:35 <Cale> dons: he's already doing that, using evaluate
17:05:45 <Cale> But the trouble is that he needs something like rnf
17:05:49 <ovnicraft> Cale: and how return to hugs>
17:05:55 <dons> ok. cool. rnf it is then :)
17:06:04 <dons> evaluate is too weak
17:06:08 <dons> hehe
17:06:10 <bos> evaluate is not the droid he is looking for.
17:06:26 <dons> so you have an error inside a structure?
17:06:32 <dons> like a list, for example
17:06:37 <bos> right.
17:06:39 <dons> so you want to deep seq it before catching
17:06:58 <Cale> ovnicraft: Uh, hmm... perhaps reload whatever module you were working on? I'm not sure how to unload modules in hugs.
17:07:25 <Cale> ovnicraft: It shouldn't matter so much though, both should be loaded.
17:08:02 <ovnicraft> Cale: reloading it is ok... thanks ;)
17:08:16 <Cale> hmm
17:08:27 <Cale> actually, :also doesn't seem to do what I'd expect.
17:08:40 <Cale> (it's not equivalent to :m + in ghci)
17:09:28 <Cale> It works with one module...
17:09:33 <Cale> That's strange.
17:10:44 <Cale> ovnicraft: I find GHCi to be much more comfortable. You might want to try it if you're not required to use hugs.
17:11:17 <mmorrow> love when your computer dies and you get to be entertained by fsck's status bar for like an hour
17:11:39 <Pseudonym> You spin me round, round, baby, right round...
17:11:46 <mmorrow> luqui, Cale: i was wrong about it being id on the same type
17:11:53 <Cale> mmorrow: heh
17:11:56 * Pseudonym hands mmorrow a journaling fs
17:11:59 <mmorrow> heh
17:12:02 <ovnicraft> Cale: i am going to try it, last question, how load a file from my source code, not prompt?
17:12:11 <mmorrow> the reisers were murderously unscathed
17:12:20 <Cale> mmorrow: better yet, my machine now reports a ridiculous time since the last check and forces me to watch the fsck on every reboot now.
17:12:33 <codetoad> dons: I'm not sure how I can use deepSeq to get this to do what I want
17:12:48 <RayNbow> http://reductiotest.org/examples/scala <-- hmm, some kind of QuickCheck for Scala?
17:12:52 <lambdabot> Title: Reductio
17:12:55 <Cale> ovnicraft: you basically have to do that :)  Either pass the filename as a parameter on the commandline, or use :load mySource.hs
17:13:05 <RayNbow> ah right... it says on the homepage
17:13:09 <mmorrow> Cale: hah, that's happens only when mine dies thankfullu
17:13:19 <vixey> @karma quickcheck
17:13:20 <lambdabot> quickcheck has a karma of 3
17:13:26 <vixey> quickcheck++
17:13:40 <dobblego> RayNbow, yes, it is for Scala and Java
17:13:42 <RayNbow> quickcheck++
17:13:47 <Cale> Yeah, it's like "/dev/sda has not been checked in 47357 days, check forced" or something :)
17:13:52 <RayNbow> QC is nice... it gave me the Gen monad :)
17:14:05 <mmorrow> and you're like "shoot me now!!!!@'
17:14:10 <Pseudonym> Agm teag,
17:14:14 <Pseudonym> Ah, yeah, I meant.
17:14:16 <ovnicraft> Cale: i want from mysource.hs load Data.Char for example.
17:14:27 <bos> rnf is haskell for deepSeq.
17:14:28 <Cale> Why doesn't fsck have a key you can hit to skip the test?
17:14:37 <bos> ctrl-alt-delete?
17:14:38 <Cale> Or does it, and I'm just missing something?
17:14:50 <Pseudonym> What you'd like there is to be able to confirm that a filesystem is okay while it's operating.
17:14:55 <Cale> bos: No use, it'll just restart fsck when the machine reboots.
17:14:55 <Pseudonym> In the background.
17:15:03 <Pseudonym> And if it finds an error, then you reboot and watch fsck at your leisure.
17:15:17 <bos> Cale: what OS?
17:15:21 <Cale> bos: Ubuntu
17:15:32 <bos> and it's running fsck? that's weird.
17:15:49 <Cale> bos: It's also reporting that the machine hasn't been checked in a ridiculous number of days
17:15:55 <bos> oh.
17:16:06 <Cale> bos: anywhere from a few thousand to 50,000 days.
17:16:11 <bos> ridiculous as in plausible, or as in complete nonsense?
17:16:15 <sjanssen> Cale: perhaps something funny is going on with your system clock?
17:16:20 <Cale> complete nonsense
17:16:24 <bos> ah. then there is a genuine problem of some sort with your filesystem.
17:16:35 <Cale> bos: It never detects a problem.
17:16:38 <bos> because that number ought to be correct.
17:16:49 <Cale> sjanssen: That's plausible.
17:17:18 <Cale> Perhaps I should stick an rdate in the startup before the fsck.
17:17:54 <bos> Cale: tune2fs -c 0 -i 0 /dev/whatever
17:18:04 <sjanssen> well, you could just see what your BIOS says at startup
17:18:37 <bos> it should be updating the superblock with the last check date when e2fsck completes.
17:20:21 <Cale> It could be that the system clock is set to a nonsense date at that point though, since the network isn't up yet.
17:20:48 <mmorrow> Cale: (maybe i should clarify, mine doesn't have the ridiculous days problem, always around 20something which is probably correct)(fedora)
17:21:59 <Pseudonym> I did have a machine once that I didn't reboot in about 1000 days.
17:22:20 <Pseudonym> It was a dedicated firewall/router.
17:22:26 <Pseudonym> So it never needed it.
17:22:58 <mmorrow> oh, i wouldve guessed windows on anything
17:22:58 <Pseudonym> Trouble was, it was running NetBSD, and the version couldn't be cleanly upgraded by the time it came to actually reboot.
17:23:17 <Pseudonym> Because I skipped a couple of ugprade cycles.
17:23:45 <mmorrow> how many times did you run uptime just to be amused
17:38:17 <hkBst> how does end of input detection work?
17:39:10 <Dzlk> why doesn't HXT export QN anymore?
17:42:57 <mm_freak> @src unsafeInterleaveST
17:42:58 <lambdabot> Source not found. stty: unknown mode: doofus
17:43:21 <mm_freak> is unsafeInterleaveST magic?
17:43:46 <Saizan> yeah.
17:44:11 <Saizan> it messes with the internal representation of ST actions
17:46:31 <TomMD> hummm, I wonder how many hackage packages have cbits.  I have been running into impure packages (Haskell + C) more often that thought I would before cabal.
17:46:51 <mrd> naughty c bits
17:47:35 <TomMD> Indeed.  Darn C programs thinking static buffers are OK.  Darn 'C' for being efficient for zero allocation transformations.
17:47:50 <dcoutts> TomMD: fairly easy to check, you'd want to see how many include c-sources
17:48:06 <dcoutts> the package index contains all the info you need there
17:48:12 <TomMD> I was just considering using tag soup + http to do just that
17:48:38 <dcoutts> much nicer to do it precisely and with only one download
17:48:56 <TomMD> The index does?  I thought I might have to untar packages.
17:49:06 <bd_> TomMD: haskell's efficient for strict, zero-allocation transformations too! :)
17:49:25 <dcoutts> TomMD: nope, since the .cabal file says if it has any c source files that need to be compiled
17:49:52 <dcoutts> TomMD: so just download the index, unpack it and do a recursive grep
17:51:41 <dcoutts> TomMD: the answer is 84
17:51:55 <dcoutts> $ grep -i c-sources $(find -name '*.cabal') -l | cut -d'/' -f2 | uniq | wc -l
17:52:17 <dcoutts> distinct package names (is not counting lots of versions of the same package)
17:53:14 <dcoutts> TomMD: so that's about ~15% of packages
17:53:34 <TomMD> Yeah, my slow machine (and fingers) are untarring...
17:53:45 <dcoutts> TomMD: of course that does not count packages which bind to pre-existing pre-installed C libs
17:53:54 <dcoutts> only ones that actually bundle C source code and build it
17:53:56 <TomMD> The latest one that took me by surprise was bos's bloomfilter
17:56:36 <dmwit> hkBst: What do you mean with that question?
17:56:49 <TomMD> bd_ sorry, I was playing with zcat/grep and missed you comment.  Haskells efficiency for this operation is why I am a little surprised there are 15% of packages using C.  I guess you can't beat zero dev time.
17:56:55 <dmwit> hkBst: Are you asking how to detect EOF on a normal command-line program?
17:57:21 <hkBst> dmwit: I mean, what happens when you try to read from an empty input port
17:57:22 <dmwit> ?hoogle eof
17:57:22 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
17:57:22 <lambdabot> Text.Read.EOF :: Lexeme
17:57:22 <lambdabot> Text.Read.Lex.EOF :: Lexeme
17:57:35 <dmwit> hkBst: Most likely you get an error.
17:57:40 <hkBst> what does readLn do when it encounters eof
17:57:43 <dmwit> hkBst: TIAS
17:58:29 <luqui> *** Exception: <stdin>: hGetLine: end of file
17:59:36 <dmwit> I get "user error (Prelude.readIO: no parse)" here.
18:00:07 <dmwit> But yeah, it will generally be an error, and it may vary by what particular input function you're calling.
18:00:28 <hkBst> how would you call readLn from ghci?
18:00:37 <dmwit> readLn :: IO Int -- for example
18:01:26 <luqui> or:   x :: Int <- readLn
18:01:41 <hkBst> dmwit: alright, I also get that "*** Exception: user error (Prelude.readIO: no parse)", but how do you test for this?
18:01:43 <sjanssen> dcoutts, TomMD: some of these seem to be false positives (eg. AvlTree doesn't actually have a c-sources but lists it in the .cabal file anyway)
18:01:43 <luqui> (might need glasgow-exts for that, but I have that enabled in ghci by default)
18:02:00 <dmwit> hkBst: catch
18:02:02 <dmwit> :t catch
18:02:05 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:02:29 <dcoutts> sjanssen: yeah
18:02:55 <dcoutts> sjanssen: one could do it accurately with some code, just load the index and count the packages with non-empty c-sources
18:03:19 <luqui> catch readLn (const $ return 0) -- to read an int and return 0 otherwise
18:03:45 <TomMD> I was noticing that, but my point was simply that there were more packages than I expected do this and in cases where I couldn't see the benefit (beyond much shorter dev time - don't get me wrong, I appriciate that).
18:04:01 <TomMD> s/do/doing
18:05:13 <dmwit> hkBst: But in this particular case, I recommend a combination of hIsEOF and reads to avoid exceptions entirely.
18:07:17 <hkBst> dmwit: can you do that if you don't read char for char?
18:07:47 <dmwit> I don't understand the question.
18:08:02 <mxc_> mxc_
18:08:04 <hkBst> don't you need to check for eof after every char that you read?
18:08:06 <mxc_> oops sry
18:08:25 <dmwit> hkBst: Ah, I guess you probably do.
18:08:31 <dmwit> hkBst: So never mind me, then. =)
18:09:54 <hkBst> What I want is to change     main = do { n <- readLn; p <- readLn; print $ root n p }     into code that tries to read two numbers on separate lines repeatedly and stops if eof is encountered.
18:10:47 <dmwit> hkBst: Do you mind switching away from readLn to something like getContents?
18:11:20 <hkBst> dmwit: apart from that I have no idea how that works, no :)
18:11:31 <dmwit> :t getContents
18:11:33 <lambdabot> IO String
18:11:48 <dmwit> hkBst: getContents (lazily) returns all the input, up to EOF.
18:12:03 <dmwit> See also "interact".
18:12:06 <dmwit> :t interact
18:12:08 <lambdabot> (String -> String) -> IO ()
18:13:24 <hkBst> @src interact
18:13:24 <lambdabot> interact f = do s <- getContents; putStr (f s)
18:14:52 * luqui thinks about how to abstract that.  MaybeT...
18:15:35 <hkBst> dmwit++
18:16:24 <hkBst> @karma dmwit
18:16:24 <lambdabot> dmwit has a karma of 5
18:17:11 <hkBst> I need some sleep now. Thanks dmwit, I'll try again tomorrow to bend Haskell to my will ;P
18:17:39 * dolio thinks Agda's coinductive stuff is still somewhat iffy.
18:18:08 <vixey> dolio: what did you do with it?
18:18:40 <dolio> I'm translating the proofs/etc in General Recursion via Coinductive Types.
18:18:51 <vixey> cool!
18:18:57 <vixey> I really want to see that
18:19:11 <vixey> I've just read this paper yesterday
18:19:21 <dolio> But, for example, if I have: 'map f (Now x) = Now (f x) ; map f (Later dx) = Later (map f dx)'...
18:19:50 <dolio> Or, that fails the termination checker. replacing = with ~ works (because map is coinductive)...
18:20:25 <dolio> But, if I want to use the fact that 'map f (Now x) = Now (f x)' in a proof, that's only possible if I use an inductive definition, and not a coinductive definition.
18:20:48 <vixey> aren't coinductive equalities setoids though?
18:21:11 <dolio> That's why I can't prove the divergence of 'never = Later never' in the thing I sent to the mailing list, too.
18:21:51 <dolio> Because the proof is 'diverge-never = diverge (diverge-never)', but it can't unify never with Later never.
18:23:22 <vixey> let me try it in Coq
18:23:33 <vixey> I have never used coinductive anything before
18:23:44 <dolio> Well, the paper claims to be checked on Coq, so presumably it works there.
18:23:59 <dolio> I haven't looked at the coq code they reference.
18:24:09 <vixey> oh that makes it easier
18:24:52 <vixey> yeah the Coq one just uses rewrite..
18:38:01 <dolio> Uh oh.
18:38:37 <vixey> did you just prove false? :p
18:38:46 <dolio> No, I looped the type checker.
18:38:54 <vixey> cool!
18:38:56 <vixey> how?
18:39:19 <dolio> I used = in the definition of never.
18:39:21 <ddarius> Doesn't Agda have the Type : Type copout?
18:39:33 <SamB_XP> it has, but you have to turn it on
18:40:02 <dolio> Since that's the fix for mapD, but since it was a literal in another type (and is coinductive) it tried expanding it forever, I guess.
18:40:24 <vixey>  that's exactly what I was wondering about coinductives
18:40:31 <vixey> how can they be valid in type theory?
18:40:43 <SamB_XP> vixey: why not?
18:40:50 <ddarius> What Sam said.
18:40:54 <vixey> because they are weird ..
18:41:03 <vixey> and I never read any consistency proof
18:41:03 <SamB_XP> so are a lot of other things
18:41:04 <ddarius> You're weird.
18:41:11 <vixey> induction isn't weird
18:41:15 <ddarius> vixey: They are dual to inductive types.
18:42:00 <vixey> that isn't part of a consistency proof though is it?
18:42:36 <dolio> Usually when one thing is dual to another, you get the proofs for one 'for free' from the proofs for the other.
18:42:43 <dolio> Just flip things around.
18:42:59 <ddarius> vixey: I imagine you could take a consistency proof for inductive types, add a few simple facts about Set and duality and easily get a consistency proof for coinductive types.
18:43:00 <vixey> I would like to see foldr fusion proved like that for inductive and coinductive lists
18:43:20 <vixey> ddarius: My guess then is the devil is in the details
18:43:22 <ddarius> There is unfoldr fusion (the dual of foldr)
18:43:31 <ddarius> vixey: No, there is no devil.
18:44:05 <ddarius> The only question is whether the coalgebras exist at all.
18:44:24 <jmsaunde> is there any way to place guards on "where"d vals?
18:44:27 <vixey> what!?
18:44:42 <ddarius> jmsaunde: Yes. Just do it like normal.
18:45:17 <dolio> where x | g1 = foo | g2 = bar
18:46:17 <jmsaunde> I want something like this: fun x = | n == 0 = x where n = x+1 or something
18:46:31 <ddarius> That works.
18:46:32 <vixey> change = | to |
18:46:37 <jmsaunde> AH!
18:46:38 <jmsaunde> thanks
18:46:43 <jmsaunde> thanks
18:47:46 <vixey> I don't know why I am just really usure about coinduction
18:48:08 * ddarius prescribes more OO programming for vixey
18:48:22 <vixey> no.. thanks..
18:49:10 <vixey> I guess I just want to see more examples, all I know about it at the moment is the reals
18:49:29 <ddarius> @google tutorial on coinduction
18:49:30 <lambdabot> http://citeseer.ist.psu.edu/105244.html
18:49:30 <lambdabot> Title: A Tutorial on Co-induction and Functional Programming - Gordon (ResearchIndex)
18:50:16 <hpaste>  morrow pasted "Lua VM instructions" at http://hpaste.org/8138
18:50:49 <hpaste>  morrow annotated "Lua VM instructions" with "stack vs. registers" at http://hpaste.org/8138#a1
18:51:02 <ddarius> http://citeseer.ist.psu.edu/jacobs97tutorial.html this is the one I was aiming at
18:51:02 <lambdabot> Title: A Tutorial on (Co)Algebras and (Co)Induction - Jacobs, Rutten (ResearchIndex)
18:56:18 <augur> ok so wiki says call by need tends not to be used in languages with side effects but i dont see why this would be the case
18:56:21 <augur> does anyone know why?
18:56:51 <vixey> why doesn't everyone program in ALGOL
18:57:03 <Riastradh> Call-by-need makes it very difficult to reason about the order of effects.
18:57:07 <Saizan> augur: since it becomes hard to figure out when side-effects would occur
18:57:09 <shapr> Hiya Riastradh!
18:57:23 <SamB_XP> Riastradh: no duh!
18:57:36 <augur> oh i see, yes, not side effects in the function but side effects produced by evaluating the argument
18:57:39 <augur> i see
18:57:39 <SamB_XP> that's what we have all these ways of keeping effects from being side-effects
18:57:50 <vixey> oh ALGOL is call by name not need
18:58:09 <ddarius> We have up-effects, down-effects, back-effects, and forward-effects, but no side-effects.
18:58:21 <SamB_XP> yes.
18:58:25 <shapr> I want some ana and kata effects.
18:58:33 <augur> i wonder, is there any way to do stuff like infinite lists without call-by-need?
18:58:34 <SamB_XP> we make you sign a disclaimer before using unsafePerformIO
18:58:44 * dcoutts wonders why the xmonad-utils requires the ghc package
18:58:46 <ddarius> augur: Sure.
18:58:48 <Riastradh> augur, no.  Circular lists, yes.
18:58:50 <SamB_XP> declaring that you will not consider the results to be side effects
18:58:53 <augur> 4th dimension hypereffects dont come until the next version of haskell, im sure.
18:59:02 <Pseudonym> Or that you will break polymorphism.
18:59:06 <dons> dcoutts: it doesn't. where is that listed?
18:59:16 <dons> oh, xmonad-utils ??
18:59:20 <dcoutts> dons: in its the .cabal file
18:59:25 <dons> what is -utils?
18:59:32 <dons> ah, i see. interesting
18:59:35 <dcoutts> dons: dunno, it's on hackage
18:59:36 <dons> something andrea wrote
18:59:40 <Saizan> augur: see python'ss generators
18:59:45 <dons> `heval' i guess
18:59:57 <augur> right but python's generators arent proper lists as such i dont think
19:00:02 <augur> they're not treated like normal lists
19:00:09 <SamB_XP> augur: of course not
19:00:17 <dcoutts> dons: ah, fair enough
19:00:19 <SamB_XP> normal lists are mutable
19:00:20 <augur> syntactically i mean
19:00:28 <SamB_XP> syntactically?
19:00:32 <augur> yeah
19:00:42 <SamB_XP> what exactly do you mean by that?
19:00:42 <augur> afaik python generators are special constructors
19:00:44 <nus-> define 'list'
19:00:46 <augur> constructs*
19:00:48 <augur> you cant just be like
19:00:50 * dcoutts thinks too many packages do not work with ghc-6.6 for no good reason
19:00:52 <augur> inflist[20]
19:00:57 <augur> you have to iterate through i think
19:01:00 <SamB_XP> augur: okay, I guess not
19:01:09 <augur> hm. maybe you could store a definition??
19:01:10 <nus-> augur, python lists are arrays
19:01:12 <SamB_XP> but that's a silly thing to do with any list of that sort anyway
19:01:38 <Saizan> inflist !! 20 "iterates" through the list too
19:01:50 <augur> and make it mutable by having part-wise definitions, e.g. when you do something like items[20] = 4 the definition becomes conditional?
19:02:22 <augur> hm. well, thank you for the information on call-by-need, i'll take the supposition to proglangdesign :)
19:02:26 <jsnx> I am a little mystified about how to get `Setup test` to work in Cabal
19:02:34 <dcoutts> dons: I'm really looking forward to getting build reporting so we can have summary pages to name and shame the QA offenders
19:02:36 <SamB_XP> the one thing about generators is that python doesn't expect you to backtrack
19:02:42 <augur> right
19:02:59 <dcoutts> jsnx: you have to write a test hook in the Setup.hs
19:03:00 <SamB_XP> jsnx: a hook in Setup.lhs
19:03:09 <jsnx> yes
19:03:18 <jsnx> but it's type is weird
19:03:26 <jsnx> i don't see what i am supposed to do
19:03:43 <jsnx> i am trying to find an example
19:03:59 <SamB_XP> isn't there a wikibook?
19:04:02 <dcoutts> jsnx: there are not many examples because it's an almost useless feature
19:04:13 <SamB_XP> oh ;-)
19:04:14 <jsnx> dcoutts: okay
19:04:34 <dcoutts> jsnx: I mean it does work but it doesn't do much
19:04:42 <jsnx> so, what is the usual way to put together tests for a Cabal package?
19:04:54 <dcoutts> jsnx: people do ad-hoc stuff
19:04:56 <jsnx> i just want to cut with the grain
19:05:00 <jsnx> oic
19:05:11 <jsnx> no grain whatsoever -- particleboard
19:05:14 <dcoutts> it's an area we've not standardised yet
19:05:14 <jsnx> i hate that
19:05:47 <jsnx> i suppose i could stick all the unit tests in the module i'm going to test
19:07:47 <hpaste>  Korollary pasted "for jsnx" at http://hpaste.org/8139
19:08:53 <Korollary> the framework doesn't pay attention to return codes, so I used to visually inspect test results
19:11:30 <Lemon> :t read
19:11:41 <Lemon> ...?
19:11:45 <lambdabot> thread killed
19:11:46 <Lemon> > 1 + 1
19:11:47 <lambdabot>  2
19:11:59 <Lemon> :t read "3" :: Int
19:12:01 <lambdabot> Int
19:12:11 <Lemon> :t read
19:12:13 <lambdabot> forall a. (Read a) => String -> a
19:13:07 <nus-> @src id
19:13:08 <lambdabot> id x = x
19:13:46 <nus-> @src (->)
19:13:46 <lambdabot> Source not found. You untyped fool!
19:16:02 <dmwit> ?kind (->)
19:16:03 <lambdabot> ?? -> ? -> *
19:16:05 <dmwit> nus-: ^^
19:16:25 <dmwit> (->) is a type constructor, not a value
19:17:13 <chessguy> @quote type
19:17:13 <lambdabot> ghc says: There must be at least one non-type-variable in the instance head
19:17:48 <nus-> looks like what I need to peek'n'poke @ Haskell is a local lambdabot copy [-:
19:18:49 <chessguy> nus-:  that's what /msg is for :)
19:19:18 <vixey> ?where lambdabot
19:19:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:19:44 <monochrom> /msg lambdabot @will_you_marry_me
19:20:35 <dmwit> Unknown command, try @list =/
19:20:50 <monochrom> heart broken
19:21:28 <nus-> thanks, got @ http://code.haskell.org/lambdabot
19:21:28 <lambdabot> Title: Index of /lambdabot
19:22:03 <dmwit> Yikes, good luck with that.
19:24:21 <shapr> dmwit: Is lambdabot hard to build?
19:24:26 <shapr> I haven't tried it lately.
19:24:28 <nus-> hmm, so haskell-src, haskell-src-exts and some weird way to map over modules sources
19:24:30 <codetoad> I'm using debian - where do the haddock-y files for cabal installed packages get shoved?
19:25:01 <dmwit> shapr: At least three people have been in here with troubles in the last week or so.
19:25:17 <shapr> ouch
19:25:18 <dcoutts> codetoad: ask $ ghc-pkg field $pkg haddock-html
19:25:58 <nus-> dmwit, more like my plan is to figure out what's going on under the hood, not build it really
19:26:43 <dmwit> nus-: There are probably some papers online that explain bits of it.
19:26:47 <codetoad> dcoutts: thanks!
19:26:50 <dmwit> What are you interested in in particular?
19:27:10 <dmwit> Some module?  How the modules get loaded?  Safely executing arbitrary Haskell?
19:27:40 <nus-> well, the first thing was "How do I get at the source, dammit!"
19:27:59 <nus-> looking at Plugin/Source.hs things became clearer
19:28:23 <nus-> or gimme my M-.
19:28:42 <mmorrow> So i've recently gotten a username on code.haskell.org. It says ssh to community.haskell.org. I gave an ssh key when requesting the account (ssh-keygen -t dsa), and it's in my ~/.ssh/id_dsa.pub file. It may be that i'm not working ssh properly, but when i ssh morrow@community.haskell.org it asks me for a password (which i don't have since we're using keys here). Anyone have any suggestions? Thanks.
19:29:35 <nus-> mmorrow, ssh -v to see what's going on?
19:30:22 <mmorrow> hmm
19:30:50 <hpaste>  morrow pasted "woe is me" at http://hpaste.org/8140
19:30:58 <mmorrow> ^^
19:32:42 <nus-> mmorrow, so it offered the id_dsa, got rejected, next authmethod
19:32:48 <nus-> try rsa?
19:33:32 <mmorrow> hmm, I only gave them a dsa. I'll send them an email. Thanks!
19:33:51 <ddarius> You didn't copy the wrong key did you?
19:34:22 <mmorrow> Hope not, don't think so, but is there anyway to find out?
19:34:34 <bd_> mmorrow: DSA keys might be disabled in the wake of the debian fiasco
19:34:35 <ddarius> Not really
19:35:00 <ddarius> Yeah, if you are using an old OpenSSL implementation, that might be the problem.
19:35:05 <monochrom> Specific keys are revoked but not a blanket.
19:35:16 <bd_> no, DSA keys are often blanket revoked
19:35:17 <mmorrow> OpenSSH_4.7p1, OpenSSL 0.9.8b 04 May 2006
19:35:24 <bd_> just USING them on a vulnerable system can be a compromise
19:35:28 <jsnx> many admins just disable keyed log in
19:35:37 <bd_> as DSA requires a secret random number to used
19:35:39 <bd_> to be used
19:35:47 <bd_> and if that can be guessed, the key can be derived
19:35:55 <ddarius> mmorrow: I believe you need p3 or later
19:35:57 <mmorrow> When requesting the account, specifically says to gen the key via ssh-keygen -t dsa
19:36:04 <cjb> DSA keys have been disallowed on debian.org, freedesktop.org and so on.
19:36:16 <mmorrow> ddarius: thanks, i'll update it and see if any dice
19:36:21 <monochrom> I see now. Thanks.
19:36:27 <bd_> mmorrow: try rsa?
19:36:35 * monochrom goes dsa witch hunting :)
19:36:50 <ddarius> bd_: community.haskell.org doesn't take RSA (presumably)
19:37:04 <bd_> It really, really should :)
19:37:04 <monochrom> Hrm! No rsa, no dsa?
19:37:08 <bd_> but did you try?
19:37:20 <cybereal> it's too bad TLS requires DSA for the only required cipher
19:37:24 <mmorrow> that would require rerequesting the account through http://community.haskell.org/admin/account_request.html which specifically asks for dsa keys...
19:37:24 <lambdabot> Title: Account Request
19:37:49 <monochrom> Nice, I have been using just one key and it's rsa all along. :)
19:38:06 <ddarius> mmorrow: You can email the support link rather than rerequesting an account.  I'm not sure if they'd prefer that or not.
19:41:13 <mmorrow> i'm currently building the current openssh and gonna try that. I'll take that route if it new ssh fails.
19:41:22 <mmorrow> Thanks
19:41:37 <ddarius> You're going to have to generate a new key regardless
19:41:45 <mmorrow> crap
19:41:49 <bd_> mmorrow: it's not openssh, it's openssl
19:42:00 <mmorrow> oh
19:42:09 <bd_> anyway all dsa keys ever used on a compromised system should be considered compromised
19:42:14 <bd_> as you can detemine the private key from a tcpdump
19:42:19 <bd_> determine*
19:42:23 <bd_> yes, *used*
19:42:32 <bd_> DSA should be considered deprecated at this point
19:43:53 <mmorrow> ok, so the verdict is, even if I upgrade to openssl of required newness, I'll still have to gen a new key ==> The only solution is to email the support link.
19:43:54 <mmorrow> ?
19:44:10 <ddarius> Yes.
19:44:17 <mmorrow> Thanks.
19:44:17 <Dzlk> New keys would be a good idea anyway.
19:45:10 <bd_> mmorrow: what version of openssl/distro are you on now?
19:45:35 <mmorrow> OpenSSH_4.7p1, OpenSSL 0.9.8b 04 May 2006
19:46:24 <bd_> mmorrow: distro patchlevel
19:46:34 <bd_> dpkg -l openssl
19:46:40 <mmorrow> bd_: i don't understand what system you claim has been compromised (are you speaking in generalities?)
19:47:03 <ddarius> http://lists.debian.org/debian-security-announce/2008/msg00152.html
19:47:04 <lambdabot> Title: [SECURITY] [DSA 1571-1] New openssl packages fix predictable random number gener ..., http://tinyurl.com/5epevf
19:47:13 <mmorrow> heh
19:47:27 <bd_> mmorrow: Okay, first off, the compromise only applies directly to debian or derivatives (ubuntu etc). The effect is any keys generated, and any DSA private keys /used/ on an affected system should be considered compromised.
19:47:30 <Dzlk> Debian's RNG wasn't quite R.
19:47:40 <bd_> In fact, all you need is a ~10M lookup table for keys generated there
19:47:45 <mmorrow> Linux ganon 2.6.24.7-92.fc8 #1 SMP Wed May 7 16:50:09 EDT 2008 i686 GNU/Linux
19:47:54 <bd_> and a bit of protocol analysis + ~10M lookup table for the DSA funstuff
19:47:55 <mmorrow> fedora
19:48:21 <bd_> mmorrow: You're probably not affected directly - but a lot of sites are rejecting all DSA keys because you can't tell if they've been /used/ on a compromised system
19:48:37 <mmorrow> oh, i see what you're saying
19:48:49 <bd_> yeah
19:48:54 <bd_> DSA's kind of horrible like that :)
19:49:25 <bwr> I need my type to remain Integer and i'm using floor$logBase 10 n   what can i do?
19:49:26 * roconnor always uses RSA
19:49:28 <bd_> and should be considered deprecated completely at this point
19:49:44 <mmorrow> tell that to code.haskell.org
19:49:48 <mmorrow> (really)
19:50:01 <dons> you can use dsa keys on code.
19:50:06 <bd_> bwr: floor $ logBase 10 (fromIntegral n) ?
19:50:25 <dmwit> bwr: length . show?
19:50:25 <bd_> :t floor . logBase 10 . fromIntegral
19:50:27 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
19:50:37 <bd_> hmmm
19:50:40 <dmwit> bwr: Well, genericLength . show, anyway.
19:50:57 <bwr> hmm, so many responses... i'm a bit confused
19:51:21 <bd_> @check \n -> (genericLength (show n) :: Integer) == (floor $ logBase 10 (fromInteger n))
19:51:24 <lambdabot>  Falsifiable, after 0 tests: -2
19:51:34 <bd_> @check \n -> n < 1 || (genericLength (show n) :: Integer) == (floor $ logBase 10 (fromInteger n))
19:51:36 <lambdabot>  Falsifiable, after 3 tests: 1
19:51:39 <bd_> heh
19:51:46 <dmwit> bd_: Yes, they're different.
19:51:57 <bd_> @check \n -> n < 1 || (genericLength (show n) :: Integer) == (1 + (floor $ logBase 10 (fromInteger n)))
19:51:58 <lambdabot>  OK, passed 500 tests.
19:52:21 <bd_> bwr: well, as you can see here, they have roughly the same effect
19:52:26 <bwr> ok
19:52:35 <bd_> I'd expect the floor $ logBase 10 (fromInteger n) to be slightly faster
19:52:36 <bwr> length.show seems easier
19:52:40 <bwr> oh
19:52:42 <bd_> because there's no string ops involved
19:52:44 <dmwit> @check \n -> n >= 1 ==> (genericLength (show n) :: Integer) == (1 + (floor $ logBase 10 (fromInteger n)))
19:52:44 <bd_> but whatever works
19:52:45 <lambdabot>  OK, passed 500 tests.
19:52:58 <dobblego> can one instance of the lambdabot process join more than one network?
19:53:02 <dmwit> bd_: (==>) discards test-cases that fail the first test, which is nice.
19:53:21 <bd_> bwr: put it in a function (countDigits?) and see if it's a performance problem with actual profiling, I suppose :)
19:53:24 <bd_> or just assume it's not for now
19:53:38 <bwr> yea
19:53:46 <bwr> i'm just working on a project euler problem
19:53:58 <bd_> ahh
19:54:06 <bd_> if it's project euler, heck, whatever works :)
19:54:20 <dobblego> @check \x -> False ==> x
19:54:21 <lambdabot>  Arguments exhausted after 0 tests.
19:54:24 <dmwit> Yeah, you almost certainly want the simplest possible thing then.
20:08:43 <jsnx> regular expressions and constructor pattern matches are alike, in some weird way
20:09:03 <jsnx> regular expressions have indeterminate constructors, like .*
20:09:14 <jsnx> e.g., what does it make?
20:09:40 <monochrom> That is where they aren't alike.
20:09:50 <jsnx> monochrom: yes
20:10:27 <jsnx> but it would be so cool to unify them on the left hand side of equations, in case statements and the like
20:10:33 <vixey> regular expressions match a language
20:10:39 <vixey> patterns match a language
20:10:43 <jsnx> well, they match lists
20:10:49 <vixey> I think that's about as much as they are similar
20:11:10 <jsnx> well, they also bind variables
20:11:21 <jsnx> (in common usage)
20:11:48 <vixey> not the regex I know
20:12:07 <jsnx> like \1, \2, &c.
20:12:26 <jsnx> you could just make them bind named variables instead though I'm not sure how
20:12:44 <jsnx> it might also be an abuse of the eye and mind, though
20:13:27 <vixey> you could extend lots of things in various ways
20:13:34 <pjdelport> jsnx: several regex dialects support named groups
20:13:41 <jsnx> yes
20:14:01 <pjdelport> e.g. (?P<name>...) in Python
20:14:10 <jsnx> but using parentheses and the : and trying to get that to work inside list pattern matches would not be quite right
20:14:22 <jsnx> oh yes, question mark
20:14:32 <jsnx> mu-hu-ha-ha-ha
20:15:17 <mmorrow> jsnx: haskell-src-exts is the haskell-src package with a bunch of new syntax + support for so called "regular patterns" used by harp which used an ast filter (HsModule -> HsModule) to accomodate this. Never used them though...
20:15:36 <mmorrow> harp is on hackage i believe
20:15:48 <mmorrow> s/used/uses/
20:16:15 <mmorrow> i mean s/ which used an ast filter/which uses an ast filter/
20:16:32 * pjdelport wonders how regular expression differentiation relates to type differentiation
20:17:30 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harp
20:17:35 <mmorrow> http://www.cs.chalmers.se/~d00nibro/harp/
20:17:36 <lambdabot> Title: Haskell Regular Patterns
20:18:57 <mmorrow> "
20:19:00 <mmorrow> foo [/ _*, a /] = ... => a is bound to the last element of the list
20:19:05 <mmorrow> foo [/ a@(/ _, _ /), _* /] = ... => a is bound to the list containing the first two elements
20:19:10 <mmorrow> foo [/ (/ a, _ /)* /] = ... => a is bound to the list of the first, third, fifth etc elements of a list of even length
20:19:13 <mmorrow> "
20:19:45 <mmorrow> heh
20:19:47 <mmorrow> oo [/ _, a@1, b, c@3*, 4+, d@5?, e@(/ f@:6, g /)*, h@( 8 | (/ 9, i /) ) /] = (a,b,c,d,e,f,g,h,i)
20:20:04 <mmorrow> s/oo/foo/
20:20:17 <mmorrow> assuming: foo :: [Int] -> (Int, Int, [Int], Maybe Int, [[Int]], [Int], [Int], Either Int [Int], [Int])
20:21:09 <mmorrow> this is all from: http://www.cs.chalmers.se/~d00nibro/harp/tutorial.html
20:21:10 <lambdabot> Title: Haskell Regular Patterns - tutorial
20:21:19 <mmorrow> </assault>
20:23:45 <jsnx> wow, harp is cool
20:24:39 <mmorrow> i never really looked into it, but now i think i will
20:25:14 <Dzlk> If one's got "Parse error in pattern" on a line where there's no pattern but there is a where clause, what might the problem be?  I've exhausted all my guesses.
20:25:57 <jsnx> Dzlk: hpaste, please
20:26:54 <ddarius> If there is a where clause then there is a pattern
20:27:05 <monochrom> "x = y" the x there is a pattern
20:27:21 <monochrom> everything is a pattern, one may say.
20:28:05 <hpaste>  Dzlk pasted "Parse error in pattern" at http://hpaste.org/8141
20:28:33 <Dzlk> monochrom: Okay, so "pattern" in the error isn't a hint :)
20:31:05 * Dzlk reads up on layout.
20:31:42 <jsnx> Dzlk: I am confused by the definition of resolveHREFsRoot
20:32:10 <Dzlk> (this isn't my code, by the way)
20:32:41 <jsnx> seems to be two argument in one case and one argument in the other
20:33:03 <monochrom> You would get a type error for that.
20:33:21 <monochrom> (If anything.)
20:34:07 <Dzlk> Hm, that is odd, I don't know what's up with it either. Fixed.
20:34:32 <jsnx> does it work now?
20:34:40 <monochrom> Good, because I can't reproduce the error anyway.
20:37:01 <Dzlk> Hm, well, apparently that was the source of the parse error, at least.
20:38:09 <jsnx> :t any
20:38:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:38:45 <Dzlk> Now I'm just unsure how to fix resolveHREF because I can't see what the author meant it to do.
20:38:57 <ddarius> monochrom: Having a different number of parameters in different clauses is syntactically an error.
20:39:03 <monochrom> recent ghc versions have random-driven spurrious error generators. it's a membership drive for #haskell.   <duck>
20:39:11 <ddarius> > let f x y = (); f x = id in f
20:39:11 <lambdabot>  arity mismatch for 'f' at "f" (column 5)
20:39:19 <Dzlk> *laugh*
20:39:38 <Dzlk> Ok. I'd have expected that to be a type error, I think.
20:39:49 <ddarius> It's well typed.
20:40:05 <monochrom> There is no different clauses in the case at hand.
20:40:11 <dmwit> Yep, I've run into that before.
20:40:18 <dmwit> It's a little annoying.
20:41:08 <jsnx> well, that code was confusing, so i'm glad there was an error in this case
20:41:13 <mmorrow> http://www.cs.chalmers.se/~d00nibro/harp/examples.html
20:41:13 <lambdabot> Title: Haskell Regular Patterns - examples
20:42:18 <roconnor> @src partitionEithers
20:42:19 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:42:59 <monochrom> Oh, I remember that one. We spent forever naming it. :)
20:43:28 <dmwit> Dunno how the actual source is, but the semantics are like this:
20:43:30 <augur> ok guys, lemme get your general opinions:
20:43:45 <augur> suppose you have mutable self-referential lists, say
20:43:48 <dmwit> partitionEithers xs = ([x | Left x <- xs], [x | Right x <- xs])
20:43:49 <augur> ones = 1:ones
20:44:00 <augur> if you then did ones[3] = 5
20:44:02 <augur> would you expect
20:44:08 <roconnor> dmwit: that's it's specification
20:44:11 <augur> a) ones == [1,1,1,5,1,1,1,1,1,1,...]
20:44:19 <roconnor> its
20:44:21 <augur> b) ones == [1,1,1,5,5,5,...]
20:44:24 <dmwit> roconnor: Right, as I said, I don't know the actual source.  Only its semantics.
20:44:30 <augur> or c) ones == [1,1,1,5,1,1,1,5,1,1,1,5,...]
20:44:32 <augur> ?
20:44:40 <augur> or d) something else
20:44:40 <dmwit> d) ones == [5,5,5,...]
20:44:40 <augur> :p
20:44:45 <ddarius> augur: For a mutable list, it should be repeat 5
20:44:59 <augur> ok.
20:45:09 <ddarius> augur: This is why using explicit reference types is a good idea
20:45:16 <monochrom> I have a better answer. Implementation dependent.
20:45:18 <augur> explicit reference types?
20:45:34 <dmwit> monochrom: yikes! heh
20:45:34 <Saizan> ?type foldr (either (first . (:)) (second . (:))) ([],[])
20:45:36 <lambdabot> forall a b. [Either a b] -> ([a], [b])
20:46:16 <monochrom> Here is a rationale. You should allow compilers to unroll 4 times or 8 times or something to help CPU pipelines.
20:46:24 <ddarius> augur: See SML or O'Caml (or Haskell, but it isn't as clear in Haskell)
20:46:31 <augur> ok :)
20:46:40 <ddarius> monochrom: Compilers shouldn't change semantics.
20:46:52 <monochrom> Precisely my point.
20:46:59 <mxc_> i know that i've said this before, but I think tha tthe powerset function is one of the most beautiful pieces of code i've ever seen
20:47:16 <augur> mxc_: powerset function?
20:47:22 <monochrom> Either make it immutable, or make it implementation dependent. Then compilers can unroll while staying legal.
20:47:32 <dmwit> augur: filterM (const [True, False])
20:47:45 <augur> oh god i wish i knew what that meant... x.x
20:47:47 <dmwit> :t filterM
20:47:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:48:01 * augur repeats
20:48:02 <dmwit> > filterM (const [True, False]) [1,2,3]
20:48:02 <augur> :P
20:48:03 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:48:31 <augur> oh
20:48:31 <dmwit> > filterM (const [True, False]) "world"
20:48:32 <lambdabot>  ["world","worl","word","wor","wold","wol","wod","wo","wrld","wrl","wrd","wr"...
20:48:34 <augur> the set of all subsets
20:48:35 <augur> ok.
20:48:53 <sjanssen> filterM (const [True, False]) actually generates all subsequences
20:49:08 <augur> i dont grasp haskell enough to understand how that does that but ok :)
20:49:10 <vixey> wont there be collections of normalization proofs kind of like collections of a^2+b^2=c^2 proofs?
20:49:13 <Dzlk> Yikes. That is beautiful.
20:49:17 <mxc_> augur> took me about a week
20:49:25 <vixey> I've only found two but I think there will be many many more
20:49:33 <augur> whats the definition of filterM?
20:49:38 <dmwit> ?src filterM
20:49:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:49:41 <dobblego> ?type filterM
20:49:43 <dmwit> whoop!
20:49:43 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:49:43 <ddarius> The obvious one.
20:49:49 <SamB_XP> vixey: or collections of beer on the wall?
20:50:03 <Saizan> ?src filter
20:50:03 <lambdabot> filter _ []     = []
20:50:03 <lambdabot> filter p (x:xs)
20:50:03 <lambdabot>     | p x       = x : filter p xs
20:50:03 <lambdabot>     | otherwise = filter p xs
20:50:05 <jsnx> i've got 'incoherent' instances, but they seem pretty clear to me:
20:50:07 <jsnx> https://svn.j-s-n.org/public/haskell/blocktalk/Text/BlockTalk/Blocks/Line.hs
20:50:08 <lambdabot> http://tinyurl.com/5tlwdw
20:50:11 <mxc_> the key is the way binding works on the list monad
20:50:11 <Saizan> convert to monadic form :)
20:50:22 <monochrom> I don't want to write 300 normalization proofs. 1 is quite enough thank you very much.
20:50:27 <augur> oh its a monadic filter? ok.
20:50:37 <jsnx> the basic issue is at the bottom, with the prop_... functions
20:50:39 <dmwit> augur: ...hence the name filterM
20:50:43 <augur> ;P
20:50:43 <mxc_> @t >>=
20:50:44 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:50:50 <mxc_> :t (>>=)
20:50:51 <augur> i dont know haskell naming conventions :)
20:50:51 <gubagem> does mapM_ mean map function over a monad and drop the results?
20:50:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:50:59 <dmwit> gubagem: yes
20:51:44 <mxc_> @src ((>>=) :: [a] -> (a -> [b]) -> [b])
20:51:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:51:47 <mxc_> hm
20:52:01 <mxc_> how can you get the >>= implementation for Data.Lists?
20:52:09 <dmwit> ?src (>>=) []
20:52:10 <lambdabot> Source not found. Do you think like you type?
20:52:13 <dmwit> ?src [] (>>=)
20:52:13 <lambdabot> xs >>= f     = concatMap f xs
20:52:19 * gubagem wonders how a list is a monad 
20:52:27 <mxc_> ?src concatMap
20:52:27 <lambdabot> concatMap f = foldr ((++) . f) []
20:52:44 <dmwit> gubagem: return x = [x]; xs >>= f = concat (map f xs)
20:52:54 <mxc_> :t concat
20:52:56 <lambdabot> forall a. [[a]] -> [a]
20:53:09 <Saizan> jsnx: i don't think you can define a "common" implementation like you want to do with Context String parsed
20:53:18 <jsnx> Saizan: fudge
20:53:19 <dmwit> gubagem: It's sometimes called the "nondeterminism" monad.
20:53:26 <ddarius> It models nondeterminism
20:53:30 <jsnx> if i remove it, it just get a different error
20:53:33 <gubagem> lists do?
20:53:34 <ddarius> (not particularly well, but... )
20:53:43 <jsnx> no instance for (a, [Aesthetic])
20:53:50 <dmwit> gubagem: You can think of it intuitively as: I have a function with many possible results.
20:53:59 <gubagem> thats a monad??
20:54:08 <dmwit> gubagem: So, represent all the results as a list.
20:54:18 <jsnx> if i define an instance for a tuple (A, B) and make a tuple, why can't it infere the (A, B) part?
20:54:21 <dmwit> gubagem: Well, it has the monad functions, and it satisfies the monad laws.
20:54:25 <dmwit> gubagem: So yes. =)
20:54:57 <Saizan> jsnx: because there could be another instance with other parts
20:55:12 <augur> does anyone have an example of an explicit evaluation involving monads?
20:55:26 <jsnx> well, there isn't one -- maybe if i compile instead of load...
20:55:38 <ddarius> augur: Either I don't know what you mean or there is nothing special.
20:55:43 <augur> er
20:56:05 <augur> i mean like.. just a trace of each step of the evaluation of something that involves a monad
20:56:09 <augur> like filterM
20:56:14 <Saizan> jsnx: the typechecker uses an open-world assumption, so the fact that it doesn't exist doesn't help
20:56:21 <augur> applying filterM to some monad
20:56:23 <dmwit> > filterM (const [True, False]) [x, y, z]
20:56:25 <lambdabot>  [[x,y,z],[x,y],[x,z],[x],[y,z],[y],[z],[]]
20:56:33 <augur> thanks. :P
20:56:34 <ddarius> augur: There's nothing special.  It's just a normal function.
20:56:35 <dmwit> Well, that's less helpful than I thought.
20:56:39 <Saizan> jsnx: in other words, add a type annotation
20:56:53 <augur> er.. but it has to be able to handle any kind of monad...
20:56:55 <monochrom> [0,1] >>= f  ->  ...  -> [f 0, f 1]
20:56:58 <augur> so i dont see how it would work
20:57:08 <dmwit> gubagem: See also the sigfpe article on monads.
20:57:16 <dmwit> ?go you could have invented monads and maybe you already did
20:57:17 <augur> if i could see the evaluation play out it'd make sense to me
20:57:17 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
20:57:17 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
20:57:48 <monochrom> You can't ask for one very concrete execution trace that holds for all abstract monads.
20:58:03 <augur> thats fine
20:58:07 <augur> i just want to see _a_ trace
20:58:20 <monochrom> By the time you ask me "so what happens next to m >>= f" I will have to ask you "which >>= do you want"
20:58:30 <monochrom> Fine.
20:58:44 <monochrom> undefined >>= undefined -> ... which >>= do you want?
20:58:46 <augur> i mean, filterM has to somehow be able to inspect, say, a Tree monad, which would be very different from inspecting a List monad versus...
20:59:16 <Saizan> augur: that's entirely done by (>>=)
20:59:27 <augur> then the question is how does >>= do it :P
20:59:43 <ddarius> augur: It's just the typeclass mechanism
20:59:44 <Saizan> do you know how typeclasses work?
20:59:48 <augur> i mean, i get what >>= does conceptually
20:59:53 <augur> i just dont see how it gets interpreted
21:00:10 <augur> no clue, saizan. :P
21:00:31 <monochrom> INSUFFICIENT DATA FOR MEANINGFUL ANSWER.  http://www.multivax.com/last_question.html
21:00:31 <lambdabot> Title: The Last Question -- Isaac Asimov
21:01:06 <vixey> mmmmm
21:01:10 <Saizan> augur: ah, that's the key then :) are you familiar with overloading at all?
21:01:17 <vixey> I wish I could have a normal sounding voice read this to do
21:01:19 <vixey> to me
21:01:27 <augur> enough, yeah.
21:01:45 <dmwit> vixey: ?
21:01:46 <augur> listen, i dont need to know how it works for all monads, im just curious how a trace would look
21:01:50 <augur> it would clear things up to me
21:01:52 <augur> for me*
21:02:00 <Saizan> so (>>=) is overloaded for each monad, i.e. it has a different implementation for each type
21:02:02 <monochrom> I say, just use the list monad.
21:02:21 <augur> ok so the monad's definition includes the definition for >>= over that monad
21:02:25 <augur> that makes a lot more sense.
21:02:30 <vixey> the Asimov text
21:02:33 <monochrom> Show him how [0,1]>>=f -> ... -> [f 0, f 1]  and be done.
21:02:38 <Saizan> yeah, (>>=) and return
21:02:44 <augur> its just type pattern matching then. ok.
21:03:02 <augur> List >>= f = .. something about lists ..
21:03:05 <dmwit> errr... type "pattern matching"?
21:03:10 <mxc_> > [1,2,4] >>= (const [True, False])
21:03:10 <dmwit> kind of
21:03:11 <lambdabot>  [True,False,True,False,True,False]
21:03:18 <Saizan> list >>= f = concat (map f list)
21:03:28 <augur> ok.
21:03:46 <vixey> I perfer
21:03:49 <vixey> (>>=) = flip concatMap
21:03:53 <mxc_> @src concatMap
21:03:54 <lambdabot> concatMap f = foldr ((++) . f) []
21:03:55 <augur> that makes sense. :)
21:03:55 <vixey> because it reminds me of that cat
21:04:19 <vixey> and return = (:[])
21:04:35 <monochrom> monkey
21:04:51 <Saizan> the monkey-cat monad?
21:06:57 * vixey listens using computer voice
21:07:32 <monochrom> You may be delighted to know that someone naughtily replaced "multivax" by "google" in that story.
21:07:55 <dmwit> hee hee!
21:09:43 <NewBe> Where can I find information on showing special symbols?
21:09:49 <vixey> computer speech synthesis really doesn't get the intonation right
21:10:00 <dmwit> NewBe: There's no information, just show them.
21:10:50 <dmwit> NewBe: Haskell's String is already a Unicode string.
21:11:08 <NewBe> oh i see thanks =]
21:11:28 <SamB_XP> well...
21:11:40 <SamB_XP> dmwit: you really shouldn't lead him on like that!
21:11:50 <ddarius> vixey: You should fix it.
21:12:39 <monochrom> "just show them" doesn't get the symbols right yet.
21:13:10 <monochrom> supposedly there is even a haskellwiki page on this.
21:15:13 <dmwit> mmm, so it doesn't
21:17:02 <SamB_XP> the whole Unicode Char thing was presumably just a "hey, these things will already take up a word, we might as well use as many bits as possible"
21:18:28 <Saizan> so a Word8 takes a word anyway?
21:18:52 <mxc_> just out of curiosity, how can you define a Word32 literal?
21:19:05 <Saizan> > 0 :: Word32
21:19:07 <lambdabot>  0
21:19:31 <mxc_> oh, right
21:19:32 <SamB_XP> Saizan: except in special situations, yes
21:19:34 * mxc_ slaps self
21:20:44 <mxc_> @hoogle (String -> Network.Socket.SockAddrInet)
21:20:45 <lambdabot> No matches, try a more general search
21:20:51 <mxc_> @hoogle (String -> Network.Socket.SockAddr)
21:20:51 <lambdabot> No matches, try a more general search
21:21:07 <monochrom> look for getHostByName
21:21:36 <mxc_> @hoogle getHostByName
21:21:36 <lambdabot> No matches found
21:21:45 <mxc_> @hoogle getAddrByName
21:21:45 <lambdabot> No matches found
21:22:17 <mxc_> getAddrInfo
21:22:44 <monochrom> Look for module Network.BSD
21:24:06 <mxc_> got it
21:24:34 <dbpatterson> I know people talk a lot about math -> programming/haskell, but does anyone know of a paper/article about the reverse? specifically, computer science based logic to predicate logic?
21:24:57 <monochrom> Yes, there is one.
21:24:59 <dbpatterson> as in, I understand computer science logic a lot more than math logic... and it's messing with my head :)
21:25:16 <dbpatterson> do you remember what it is called?
21:25:25 <monochrom> processing
21:26:08 <dbpatterson> that is the title?
21:26:08 <Saizan> computer since logic as in?
21:26:16 <Saizan> *science
21:26:33 <gubagem> does anyone else ever have haskell dreams
21:26:40 <gubagem> or you wake up and its already on your mind
21:26:50 <dbpatterson> hmm. I guess its all the if... then... , logical and/or, it seems really close but slightly different
21:27:41 <jsnx> gubagem: soon, the masters will come to visit you while you are asleep
21:27:58 <dbpatterson> for ex, something I'm looking at - this being universally true: (P & (P => Q)) => Q
21:27:59 <SamB_XP> jsnx: that is so mean
21:28:00 <NewBe> > "â3"
21:28:01 <lambdabot>  "\8730\&3"
21:28:06 <SamB_XP> they should visit while he's awake
21:28:07 <dbpatterson> I'm still wondering how it evaluates
21:28:13 <SamB_XP> so he can ask them stuff
21:28:23 <monochrom> The haskellwiki tutorial list doesn't list it. this is a shame.
21:28:55 <jsnx> you have to be pray and fast before that happens
21:29:10 * SamB_XP thinks he's come near having Haskell dreams, but can't remember how near
21:29:16 <codetoad> gubagem: i had a dream about higher-order functions and being a wizard who had powers that allowed me to manipulate the universe
21:29:20 <dbpatterson> ... I guess I'm the only person here w/o even an undergrad degree in math(s)
21:29:28 <SamB_XP> hah
21:29:29 <mmorrow> heh
21:29:32 <codetoad> ...
21:29:44 <ddarius> dbpatterson: I don't have an undergrad degree in anything.
21:29:44 <jsnx> dbpatterson: i don't have an undergrad in anything at all
21:29:52 <SamB_XP> aren't there some highschoolers here still?
21:29:56 <dbpatterson> good company I guess
21:30:01 <dbpatterson> I am entering uni in the fall....
21:30:06 <jsnx> i'm 26, though
21:30:16 <jsnx> stay in school, kids!
21:30:18 <Saizan> dbpatterson: well you can write that in haskell as (p,p -> q) -> q, and i think you can see how to write it :)
21:30:31 <ddarius> Or you could just ask djinn
21:30:43 <Saizan> s/as /as the type /
21:30:52 <SamB_XP> anyway, I'm going for an EE degree
21:31:01 <dbpatterson> Saizan: hmm, but how is the type something that be evaluated for trueness?
21:31:14 <monochrom> http://www.amazon.co.uk/Haskell-Logic-Maths-Programming-Computing/dp/0954300696
21:31:16 <lambdabot> http://tinyurl.com/yu986w
21:31:20 <ddarius> @google Curry Howard isomorphism
21:31:21 <lambdabot> http://en.wikipedia.org/wiki/Curry-Howard_correspondence
21:31:24 <SamB_XP> dbpatterson: evaluating for trueness is so passe
21:31:34 <dbpatterson> I guess, it makes perfect sense
21:31:42 <dbpatterson> but the way it is explained (in the text I'm looking at) makes no sense
21:31:48 <codetoad> how is it explained?
21:31:49 <monochrom> And it is a shame the haskellwiki book page doesn't list it either.
21:31:57 <SamB_XP> but you can prove a type by making a value that inhabits it
21:32:14 <ddarius> monochrom: You can change that.  We have the technology.
21:32:22 <SamB_XP> this doesn't work too well for Haskell, though, since, well...
21:32:24 <dbpatterson> like, if P and P => Q is true then Q is true
21:32:25 <Saizan> dbpatterson: roughly, if a type corresponds to a theorem then you can write a function of that type, if it's not then you can write one only using undefined
21:32:26 <SamB_XP> @type undefined
21:32:28 <lambdabot> forall a. a
21:32:34 <ddarius> :t undefined :: (p, p -> q) -> q
21:32:35 <lambdabot> forall p q. (p, p -> q) -> q
21:32:47 <monochrom> "I can change that" and "it is a shame" are not in conflict.
21:32:52 <SamB_XP> so we might as well make this explicit...
21:32:56 <dbpatterson> monochrom: maybe I'll get that book
21:32:57 <SamB_XP> @let absurd = undefined
21:32:58 <lambdabot> Defined.
21:33:08 <ddarius> monochrom: Then we're agreed.
21:33:35 <dbpatterson> I guess the problem I'm having is it isnt that for all inputs these are true, it is a sort of dependency?
21:34:00 <dbpatterson> maybe I shouldnt think about it too much?
21:34:03 <monochrom> In fact real programmers are required to swear while they fix bugs.
21:34:13 <codetoad> dbpatterson: yeah, it is a dependency because of the &
21:34:33 <SamB_XP> well, -> is implication
21:35:02 <SamB_XP> if you have a function of type a -> b, that means you can calculate a b given any a whatsoever
21:35:20 <ddarius> :t sqrt
21:35:22 <lambdabot> forall a. (Floating a) => a -> a
21:35:22 <monochrom> oh well, it's already under http://www.haskell.org/haskellwiki/Books_and_tutorials/Mathematics
21:35:24 <lambdabot> Title: Books and tutorials/Mathematics - HaskellWiki, http://tinyurl.com/62knb6
21:35:37 <SamB_XP> dbpatterson: you could learn Coq or Agda or something ;-)
21:35:56 <dbpatterson> SamB_XP: I'm trying to learn math now thanks... got enough languages on the back burner...
21:35:59 <dbpatterson> :)
21:36:18 <codetoad> dbpatterson: are you in a discrete math course?
21:36:20 <SamB_XP> well, those languages are the kind of languages in which this actually makes sense ;-)
21:36:41 <ddarius> Well Coq is a theorem prover.
21:36:45 <dbpatterson> codetoad: nope, just trying to review stuff by learning new stuff
21:36:53 <Saizan> dbpatterson: write down a table of all the possible assignments to p and q, and the corresponding value of (P & P -> Q)  -> Q
21:36:58 <dbpatterson> straight review makes me explode
21:37:02 <SamB_XP> ddarius: isn't that just code for "total functional programming language"?
21:37:06 <codetoad> what lead you to haskell?
21:37:08 * SamB_XP exhaggerates slightly
21:37:12 <ddarius> SamB_XP: No.
21:37:21 <roconnor> @dijn (p,p->q) -> q
21:37:22 <lambdabot> Maybe you meant: dice dict djinn
21:37:29 <roconnor> @djinn (p,p->q) -> q
21:37:30 <lambdabot> f (a, b) = b a
21:37:35 <dbpatterson> codetoad: asking me?
21:37:38 <SamB_XP> (some "theorem provers" are based on other principles)
21:37:42 <vixey> that was really brillian
21:37:43 <vixey> t
21:37:45 <codetoad> dbpatterson: yes, sorry
21:37:48 <davidL> Would a monad be appropriate to represent a gzipped bytestring?
21:37:52 <SamB_XP> ddarius: well, that's what Coq is.
21:37:58 <dbpatterson> Saizan: this is where it doesnt make sense. if P is false, then how can the first part be true (and'ing with P)
21:38:00 <SamB_XP> ddarius: with some, you know, tactics
21:38:12 <vixey> Coq is also a theorem prover
21:38:20 <dbpatterson> codetoad: lambda calculus actually... on wikipedia :)
21:38:30 <codetoad> dbpatterson: the "P" before the first & assumes P is true
21:38:34 <Saizan> dbpatterson: you want to prove the implication
21:38:43 <SamB_XP> vixey: well, yes...
21:38:46 <dbpatterson> Ahh!
21:38:48 <ddarius> dbpatterson: What is the truth table for implication?
21:38:55 <roconnor> @djinn (void,void->q) -> void
21:38:55 <lambdabot> f (a, _) = a
21:39:00 <dbpatterson> so if there is an and, it assumes they are both true, if it is or, it assumes one is true?
21:39:03 <SamB_XP> but it's a curry-howard theorem prover and so also a total functional programming language...
21:39:04 <monochrom> P is false.  P & (P->Q) -> Q  can still be true.
21:39:14 <Saizan> dbpatterson: no, no assumptions
21:39:15 <SamB_XP> dbpatterson: and is like pairs
21:39:23 <SamB_XP> dbpatterson: or is like Either
21:39:35 <monochrom> Focus on the -> rather than the & there.
21:39:45 <dbpatterson> monochrom: okay. processing :)
21:39:56 <vixey> SamB: Oh I wrote a type checker in Coq
21:40:12 <vixey> sort of
21:40:21 <vixey> repeat progress (try apply TVar; try apply TApp; try apply TLam)
21:40:49 <monochrom> top-down thinking and lazy evaluation prevents getting distracted.  this is a principle behind Why FP Matters.
21:41:42 <SamB_XP> vixey: what???
21:41:58 <SamB_XP> vixey: that's not Gallina...
21:41:59 <Saizan> ..if you think about proving it as a lambda term you can assume that P and (P -> Q) holds in a sense
21:42:05 <vixey> It's Ltac
21:42:34 <SamB_XP> (Coq is actually made up of several languages, which for some reason have names0
21:42:36 <vixey> but it's cool because now I can just write
21:42:46 <vixey> |- \x -> x : a -> a or something like that
21:43:03 <vixey> and my tactic will prove that, (or do nothing if the term doesn't have that type)
21:43:24 <dbpatterson> Saizan: hmm, I guess I'm still unclear as to what you are assuming and what you arent...
21:43:27 <vixey> now if I could just prove that... I could have a well typed version
21:43:47 <dbpatterson> are you just trying all permutations of truth and false'ness and seeing if the statement is always true?
21:43:54 <SamB_XP> do you have a judgement for "ill-typed"?
21:44:01 <SamB_XP> or "not of this type"?
21:44:04 <monochrom> In Mary -> John, assume Mary, don't assume John.  It's all due to -> being ->, not due to Mary being Mary.
21:44:13 <Saizan> dbpatterson: that's the truth table way
21:44:13 <vixey> SamB: I have a proof of HasTyp 0 vnil t_omega typ -> False.
21:44:32 <dbpatterson> Saizan: is that a recommended way to approach it?
21:44:37 <dbpatterson> just write out the tables?
21:44:39 <Korollary> dbpatterson: There's a ##logic btw
21:44:45 <SamB_XP> vixey: hmm?
21:44:49 <dbpatterson> Korollary: sorry, I'll stop...
21:44:56 <Korollary> dbpatterson: oh no. it's not off topic
21:45:01 <monochrom> truth table is probably simpler and less philosophical burden
21:45:07 <Korollary> just fyi
21:45:13 <dbpatterson> Korollary: thanks...
21:45:23 <vixey> SamB: well I was hoping to formalize normalization but I haven't got that far yet
21:45:33 <codetoad> dbpatterson: are you having trouble understanding the predicate logic or the connection to haskell's types?
21:45:34 <SamB_XP> truth tables only make sense for decidable propositions
21:45:43 <dbpatterson> codetoad: predicate logic...
21:45:56 <monochrom> We are still at the level of decidable propositions.
21:45:58 <dbpatterson> I think if I understand that, the connection will make sense
21:46:06 <vixey> P \/ ~P?
21:46:27 <Saizan> dbpatterson: start with the truth table for a -> b
21:46:27 <Korollary> dbpatterson: do you have any reference text for predicate logic?
21:46:28 <SamB_XP> vixey: you may want to consider inductively defining some ill-typednes judgements
21:46:29 <dbpatterson> yes, I get that one :)
21:46:45 <dbpatterson> Korollary: it is actually an introduction of a calc text
21:46:53 <vixey> I did two already
21:46:54 <roconnor> there is also #constructive-math
21:46:56 <dbpatterson> probably would be more helpful if I had an actual text...
21:47:19 <Korollary> roconnor: really?
21:47:39 <roconnor> Korollary: sure, why not?
21:47:41 <codetoad> dbpatterson: you can assume that you can draw a big truth table, or you can assume that you have these rules of reduction that allow you to deduce whether or not the statement is true.  your statement is one such reduction - you can use it to make statements that are more complicated simpler..
21:47:47 <Korollary> roconnor: it doesn't exist at the moment
21:47:53 <vixey> yes it does
21:48:06 <roconnor> Korollary: Constructive Math - Bishop, Type Theory, Abstract Stone Duality, ...
21:48:14 <Korollary> dbpatterson: I can point you to an online textbook on logic if you want
21:48:23 <SamB_XP> vixey: did you prove that either of those is equivalent to the negation of the typing judgement?
21:48:27 <roconnor> Korollary: vixey joined
21:48:30 <dbpatterson> Korollary: that woudl be great
21:48:31 <SamB_XP> and and vice-versa?
21:48:32 <dbpatterson> would*
21:48:38 <vixey> Theorem const_ty : forall a b,
21:48:38 <vixey>   HasTyp 0 vnil t_const (arrow a (arrow b a)).
21:48:38 <vixey> Proof.
21:48:38 <vixey>   intros a b; tcheck.
21:48:38 <vixey> Qed.
21:48:57 <vixey> &
21:49:00 <vixey> Theorem omega_wont_ty : forall typ, HasTyp 0 vnil t_omega typ -> False.
21:49:18 <vixey> (proof for that is kind of longer though)
21:49:18 <Elly> what language is that, vixey?
21:49:25 <dbpatterson> codetoad: this is kind of where I'm wondering where the intersection between reductions in general in computer science (which seem very straightforward) and reductions in math.
21:49:41 <Korollary> dbpatterson: http://euclid.trentu.ca/math/sb/pcml/
21:49:41 <lambdabot> Title: A Problem Course in Mathematical Logic
21:49:41 <vixey> Elly: iCoq
21:49:45 <vixey> s/i//
21:49:50 <Elly> ah!
21:49:52 <SamB_XP> vixey: so did you at least write a typechecker that succeeds properly?
21:49:53 <Elly> I thought as much
21:49:55 <Elly> neat :)
21:50:31 <codetoad> dbpatterson: the only difference i know of is in math they often skip many steps and eschew formal logic
21:50:36 <SamB_XP> (but doesn't prove that the expression was ill-typed when it fails?)
21:51:02 <vixey> SamB: well Ltac is just this dynamic language which may not even terminate for writing proof search methods, that's what I wrote tcheck in .. so It's kind of bad, it would be possible (but I haven't done the math yet) to write term -> { HasType term type } + { forall type, HasType term type -> False }
21:51:13 <vixey> SamB: since typeability for STLC is decideable
21:51:47 <SamB_XP> have you read "a view from the left", btw?
21:52:19 <SamB_XP> or was that THE view?
21:52:19 <vixey> yes that was a really great paper
21:52:22 <SamB_XP> I can never remember
21:52:26 <vixey> The
21:52:39 <monochrom> lambdabot can remember
21:52:53 <SamB_XP> anyway, doesn't it have exactly this program in it, with the proof of failure and all?
21:54:14 <vixey> no it's a bit different
21:54:29 <SamB_XP> how so?
21:55:10 <SamB_XP> oh, they do have those terms with types embedded, don't they...
21:55:24 <vixey> the one in view from the left, (or my term -> { _ } + { _ } thing I haven't written yet) they always terminate and the result has a very specific logical meaning (which is all expressed in types), but only *I* know that my Ltac proof search macro works
21:55:42 <vixey> (since it's in a dynamic & partial language)
21:55:52 <SamB_XP> vixey: well, yes, I was talking about the one you WANTED to have
21:55:58 <SamB_XP> not the one you already wrote
21:56:16 <vixey> yeah what I want to have should be roughly equivalent but a few orders of magnitude less elegant :p
21:56:28 <vixey> (I don't think I can code as well as these guys yet..)
21:56:36 <SamB_XP> you can't copy their code?
21:56:58 <SamB_XP> well, I guess it's a little harder to do that in Coq than in Agda 2...
22:00:39 <vixey> SamB: The toughest thing for me at the moment is pattern matching
22:00:59 <SamB_XP> using SVN or 8.1?
22:01:05 <vixey> SamB: I am getting the hang of it but all the really advanced automated stuff Conor keeps writing about is very appealing..
22:01:19 <vixey> svn
22:01:55 <vixey> like the term for (!!) : (v : Vec a n) -> (i : Fin n) -> a
22:01:59 <vixey> is huge :s
22:02:09 <dbpatterson> Korollary: thanks a lot for the text, it somehow made me think what I was not thinking at all earlier. P and Q are frames, not statements... in that context it makes perfect sense
22:02:27 <vixey> (whereas it's probably 2 lines in Epigram)
22:03:54 <SamB_XP> what the heck is a frame?
22:04:11 <augur> its a think you put pictures in
22:04:17 <augur> they're usually made of wood
22:05:04 <dbpatterson> SamB_XP: it is the word they (this text) are using for a function like P(x) w/o the x being a value
22:05:07 <Cale> It's one of a series of images displayed rapidly in sequence so as to produce an animation.
22:05:25 <vixey> @w80 frame
22:05:26 <lambdabot> *** "frame" wn "WordNet (r) 2.0"
22:05:26 <lambdabot> frame
22:05:26 <lambdabot>      n 1: a structure supporting or containing something [syn: {framework},
22:05:26 <lambdabot>            {framing}]
22:05:26 <lambdabot>      2: one of a series of still transparent photographs on a strip
22:05:28 <lambdabot> [28 @more lines]
22:05:42 * SamB_XP doesn't understand
22:05:55 <vixey> what context?
22:06:17 * SamB_XP does however understand how types are statements
22:06:32 <dbpatterson> I guess the idea is like a picture frame
22:06:37 <dbpatterson> it can have anything put into it
22:06:40 <dbpatterson> right now it is open
22:06:51 <dbpatterson> P(x) is the empty frame
22:06:58 <dbpatterson> P(4) is it with the picture in it :)
22:07:02 <Korollary> predicate symbols of some arity
22:08:16 <monochrom> How many words have been invented to refer to unapplied functions?
22:08:36 <Korollary> it's not a function
22:09:11 <lament> monochrom: 69105
22:09:41 <SamB_XP> Korollary: how so?
22:09:43 <codetoad> dbpatterson: but it can only accept True or False
22:09:56 <SamB_XP> codetoad: there is no False, silly
22:10:03 <Korollary> in first order logic you construct terms using functions and constants (nullary functions), and then predicates apply to terms and are connected via connectives.
22:10:09 <vixey> False exists
22:10:10 <SamB_XP> data False
22:10:35 <vixey> there's just no x : False
22:10:45 <newsham> let F be a family of functions containing f such that f's mother says to him "why don't you apply yourself more?"
22:11:14 <lament> funny
22:11:39 <monochrom> Use the False.
22:11:54 <newsham> what are some GC systems written natively in the function they are collecting for?
22:12:07 <newsham> (other than language == C,C++)
22:12:12 <monochrom> does haskell count?
22:12:16 <newsham> s/function/language/
22:12:22 <newsham> yah, are there haskell GC's written in haskell?
22:12:26 <lament> objective C :D
22:12:50 <monochrom> someone should write one in LaTeX
22:12:54 <lament> probably very many smalltalks, lisps and forths
22:13:20 <lament> and if you can pronounce lisps, try pronouncing lispspspsps
22:14:00 <SamB_XP> the wonderful thing about a False is that you can use it to prove anything ;-)
22:14:02 <dmwit> lament: That's the sound I make to attract cats.
22:14:35 <SamB_XP> that's nothin'
22:14:45 <SamB_XP> try lithpthpthpthpthpth
22:14:50 <lament> haha
22:15:06 <lament> wow, lisp is hard!
22:15:12 <Dzlk1> "lispspspspsps..." is actually easier than "lisps", because you can break syllables at the "p".
22:15:13 <monochrom> Someone should make a new language called psst.  He/she could write a compiler for it called pssst, and a library repository called psssst.org
22:15:22 <newsham> -blah.
22:15:42 <lament> Dzlk1: ok, lispsspsspsspsspsspssps :)
22:15:56 <SamB_XP> newsham: but -blah is already talking about something
22:15:59 <lament> better: lisps'sps'sps'sps'sps'sps'sps
22:16:37 <monochrom> How was ghc's gc written?
22:17:09 <monochrom> Oh darn, the whole bloody rts is probably C.
22:17:23 <dmwit> monochrom: yep
22:19:04 <codetoad> what does rts stand for?
22:19:12 <monochrom> runtime system
22:20:28 <vixey> SamB: oh yeah have you seen Exploring the Regular Tree Types?
22:20:51 <Korollary> Has anyone ever used ContT?
22:20:56 <SamB_XP> no, but I can imagine firing an arrow or something to get up into them
22:21:08 <monochrom> I have.
22:21:21 <SamB_XP> monochrom: no, some of the RTS is written in Cmm
22:21:54 <vixey> It's good (I am still confused by the sequel though)
22:22:04 <monochrom> http://www.vex.net/~trebla/haskell/ContMonad.lhs  has some examples.
22:23:24 <Korollary> monochrom: That's excellent. I wrote such a little module myself for learning, but I can't think of actual use.
22:23:54 <monochrom> They use StateT s (Cont y) but you can change it to ContT y (State s) and most examples will still work the same.
22:25:59 <vixey> ForwardConstraint.hs is so great
22:26:07 <codetoad> why is it that the ghci debugger is limited in how far you can :back ?
22:26:38 <monochrom> hehe
22:28:02 <monochrom> ForwardConstraint.hs is 95% documentation and 5% code. This is a metric of nirvana.
22:30:25 <codetoad> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs ?
22:30:26 <lambdabot> http://tinyurl.com/26xt9x
22:30:30 <monochrom> Yes.
22:40:28 <MedeaMelana> Good morning
22:41:04 <Korollary> good @localtime
22:41:17 <tsuwabuk_> @a
22:41:18 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
22:42:00 <leoncamel> hmm, what does this mean : "getLine  :: IO String"
22:42:24 <tsuwabuki> > getLine >>= print
22:42:27 <lambdabot>  <IO ()>
22:42:27 <vixey> leoncamel: It means that getLine has type String in the IO monad
22:43:09 <leoncamel> hmm, OK. I will check the monad. I am not understand the "monad" till now
22:43:44 <leoncamel> tsuwabuki, what is ">>==" operator ?
22:44:27 <leoncamel> and one more stupid question. does haskell consider there is only "ONE" return value of the function?
22:44:28 <tsuwabuki> monad? It's just algebraic datatype.
22:44:31 <newsham> it glues "getLine" and "\x -> print x" (two IO actions) into a big IO action
22:45:08 <newsham> each function results in a value, the value can be composite, like a tuple of 5 values
22:45:20 <newsham> > let f n = (n,n+1,n+2) in f 23
22:45:21 <lambdabot>  (23,24,25)
22:45:29 <leoncamel> ok. got it.
22:46:28 <newsham> "getLine >>= \x -> print x" is sort of like  "let x <- getLine in print x"
22:46:46 <leoncamel> so, I could define the function type like " a -> b->(t)". which means the output of the function is a tuple. so , I could fil anything to the tuple ?
22:47:16 <newsham> tuples of different sizes are different types
22:47:16 <luqui> leoncamel, well, tuples are statically typed
22:47:20 <codetoad> leoncamel:  as far as i know, no
22:47:28 <newsham> and with fixed types for their constituents
22:47:37 <newsham> so:   a -> b -> (a,b)     would be one function type
22:47:46 <newsham> and:  a -> b -> (Int,b,b)   would be another
22:48:00 <leoncamel> newsham, hmm, a little bit clear about it. You konw, I learn C/C++, Python before, so, the grammar of haskell is little bit hard to understand..
22:48:22 <leoncamel> codetoad, why not ?
22:48:24 <newsham> yes, haskell is a bit different than languages like python.
22:48:37 <newsham> I'm also from C and python
22:48:45 <codetoad> leoncamel: it's probably possible to do what you want, you just have to look at it differently
22:48:46 <tsuwabuki> You should study earliness ML more than Haskell.
22:48:48 <newsham> it will stretch your brain out a bit
22:49:21 <vixey> what's earliness?
22:49:46 <codetoad> leoncamel: you could, for instance, make a type for what it is you want to be in that tuple
22:49:51 <monochrom> f x y = (x && True, y : "hello")
22:50:11 <monochrom> My f has type Bool -> Char -> (Bool, String)
22:50:17 <newsham> ?type \x y = (x && True, y : "hello")
22:50:19 <lambdabot> parse error on input `='
22:50:22 <MedeaMelana> x && True can be written as just True
22:50:25 <newsham> ?type \x y -> (x && True, y : "hello")
22:50:27 <lambdabot> Bool -> Char -> (Bool, [Char])
22:50:38 <MedeaMelana> as just x i mean
22:50:39 <MedeaMelana> doh
22:50:45 <leoncamel> monochrom, hmm, thanks, more clear now.
22:50:57 <vixey> MedeaMelana: that has a different principle type though
22:50:57 <vixey> a
22:51:20 <monochrom> educational examples are always silly. simplifying them misses the point.
22:51:28 <MedeaMelana> Ah, I wasn't following the discussion; I took it out of context.
22:51:41 <monochrom> optimizing them is a war crime.
22:52:04 <quicksilver> tsuwabuki: not necessariyl. It's true that learning ML first would make haskell easier, but learning haskell first would make ML easier.
22:52:24 <quicksilver> tsuwabuki: I don't think ML before haskell is necessary.
22:53:16 <leoncamel> hmm, one more stupid question. Is the functional programming language, like Haskell, could be optimized as concurrent unit easily ?
22:54:06 <tsuwabuki> $B$=$&$G$9$+!#(B
22:54:22 <vixey> :t $B$=$&$G$9$+!#(B
22:54:23 <lambdabot> parse error on input `$'
22:54:35 <newsham> haskell provides opportunities for parallelization, but the compilers wont necessarily be parallelizing things automatically for you
22:54:40 <mxc_> tsuwabuki - hanmoji wo tsukatte kudasai
22:55:05 <tsuwabuki> OK
22:55:31 <mxc_> zenmoji wo mienai kara..
22:55:43 <vixey> What does zenmoji mean?
22:55:51 <tsuwabuki> Japanese
22:55:52 <mxc_> i think double-byte character
22:56:05 <mxc_> hanmoji I know is single byte character
22:56:21 <mxc_> i could be wrong on both
22:56:26 <mxc_> anyway, whats your question?
22:56:51 * luqui found haskell to be a fine first functional language
22:57:07 <luqui> I mean, it was hard as hell to learn, but I learned well because haskell did not allow any funny business
22:57:20 <mxc_> luqui - agree
22:57:23 <luqui> whereas if I learned ML first, I would have still been thinking imperatively for much longer
22:57:31 <mxc_> luqui - disagree
22:57:36 <mxc_> i learned ocaml first
22:57:54 <vixey> I have started writing something in ocaml it's very nice
22:58:00 <mxc_> as long as you're relatively disciplined you can become a pretty decent FP programmer
22:58:10 <luqui> I have no way to counter that argument :-)
22:58:11 <mxc_> but you wont learn monadic IO, monadic coding
22:58:40 <mxc_> luqui - you could take the standard DIGG approach and just insult my mother
22:58:56 <luqui> Yo mama could take the standard DIGG approach!
22:59:02 <mxc_> touche
23:00:19 <newsham> perhaps monadic IO is not the one true way ;-)
23:00:33 <hpaste>  dolio pasted "heinous types" at http://hpaste.org/8142
23:01:02 <dobblego> how do you tell lambdabot to take a message for another user? (I forget the command)
23:01:10 <Korollary> tell
23:01:13 <dobblego> thanks
23:01:49 * luqui has been trying to free himself of monads as wel
23:01:50 <luqui> l
23:02:08 <luqui> many times they are too strong, and you can get by with a weaker algebraic structure that lets you mess around with it more
23:03:11 <tsuwabuki> > "hello"
23:03:13 <lambdabot>  "hello"
23:03:52 <vixey> what's heinous?
23:04:09 <vixey> it looks very complex but ok
23:04:10 <newsham> > (unwords.map reverse.words) "hello there world!"
23:04:12 <lambdabot>  "olleh ereht !dlrow"
23:04:21 <dolio> Extreme sigma-type nesting and lambda expressions?
23:04:50 <vixey> does it typecheck?
23:04:54 <dolio> Yes.
23:05:27 <dolio> Took me a while to translate it from the english/type theory hybrid description of finitary, though.
23:05:31 <monochrom> Extreme Typing. :)
23:05:54 * monochrom organizes The First International Conference and Workshops on Extreme Typing
23:06:11 <Korollary> two people typechecking in front of the same monitor?
23:06:21 * luqui thinks strongly typed water sports or The Typing of The Dead, isn't sure which
23:06:32 <monochrom> hahahahah
23:07:03 <dolio> I'm not totally certain I got it right, either.
23:07:06 <ivanm> monochrom: the latest extreme sport? :p
23:07:09 <newsham> last year a team of type checkers were stranded in a closure for three weeks, several lost their extremities to bitrot
23:07:17 <ivanm> lol
23:07:24 <luqui> heheheh
23:07:47 <monochrom> "write types before code"
23:08:00 <mxc_> newsham et al.:  see, this is why I keep saying we need polymorphic variants!  the types could just grow new extremities!
23:08:01 <luqui> "types before code"
23:08:09 <ivanm> monochrom: so about half of all haskellers already practice extreme typing?
23:08:09 <luqui> or "types code"
23:08:23 <Korollary> type driven development
23:08:25 <ivanm> luqui: so you dont' dictate the code then?
23:08:32 <monochrom> Or rather, all haskellers already practice half of Extreme Typing.
23:08:46 <ivanm> Korollary: what's great is how what you said was a corollary of monochrom's statement :p
23:08:47 <mxc_> korollary > i like that.  type driven development
23:08:48 * luqui thinks it would be easier to dictate haskell than any other PL he knows
23:08:58 <mxc_> applescript
23:09:01 <luqui> except maybe smalltlak
23:09:04 <Korollary> ivanm: that's how I roll
23:09:05 <mxc_> its basically natural language
23:09:07 <ivanm> brainfuck?
23:09:08 * luqui doesn't know appescript :-
23:09:18 <tsuwabuki> w
23:09:21 <ivanm> Korollary: heh
23:09:47 <mxc_> sample applescript: tell application "iTunes" to play
23:10:12 <monochrom> tell application "iTunes" to get lost
23:11:02 <vixey> it's not natural language
23:11:10 <luqui> brainfuck, not too hard
23:11:13 <luqui> > map ("<>.[]" !!) $ map (`mod` 5) $ randoms (mkStdGen 42)
23:11:14 <lambdabot>  "><].<>[].>><<>[[<]<[[<]<<<]>>><.>><<.].[]<>.>[].>><.<.<<>..[[.>[].[<.<]<[<[...
23:11:47 <tsuwabuki> www
23:12:26 <luqui> tell application "iTunes" to get me a shot of whiskey, then play "when I drink alone"
23:12:38 <Korollary> yo application "iTunes" turn it up homey
23:12:39 <luqui> oops
23:12:45 <luqui> sudo tell application "iTunes" to get me a shot of whiskey, then play "when I drink alone"
23:12:47 <luqui> :-)
23:13:20 <newsham> > map (("<>.[]" !!).(`mod` 5)) $ randoms (mkStdGen 42)
23:13:21 <lambdabot>  "><].<>[].>><<>[[<]<[[<]<<<]>>><.>><<.].[]<>.>[].>><.<.<<>..[[.>[].[<.<]<[<[...
23:14:28 <psygnisfive> i thought this was a haskell channel, not a brainfuck channel
23:15:12 <vixey> > map (("[[[<++++-->]]]" !!).(`mod` 5)) $ randoms (mkStdGen 42)
23:15:14 <lambdabot>  "[[+[[[<+[[[[[[<<[+[<<[+[[[+[[[[[[[[[[+[<+[[[[<+[[[[[[[[[[[[<<[[<+[<[[[+[<[<...
23:15:21 * luqui didn't like the composition because they were both sections
23:15:26 <vixey> aww
23:15:29 <luqui> oh right, + and -
23:15:38 <vixey> > map (("[[[<++++-->]]]" !!).(`mod`14)) $ randoms (mkStdGen 42)
23:15:39 <lambdabot>  "<+]-[<-[]>+<--[--]][-[+>+[<+-<[]>[+]]]]-[[][[-]>+[--->+--+[[-->]++]-[+]]-<[...
23:15:55 <vixey> no too many []'s
23:16:29 <monochrom> whiskey is good
23:16:53 <psygnisfive> i like applescript
23:16:58 <psygnisfive> its.. odd, but cute.
23:17:17 <monochrom> applecider even better.  <duck>
23:17:42 <Dzlk> I liked HyperTalk when I was thirteen or so.
23:18:13 <quicksilver> applescript is quite interesting
23:18:14 <vixey> I want pear cider
23:18:18 <quicksilver> it's strongly typed with type inference
23:18:37 <quicksilver> and arguably it has something a bit like type classes
23:18:49 * luqui is thirsty
23:18:54 <newsham> none of the distributors here carry pear cider :(
23:19:10 * quicksilver thought the correct name was 'Perry'.
23:19:19 <newsham> if someone could send me some wyder's pear cider I would appreciate it, thx.
23:19:41 <monochrom> The next Extreme Typing programming language is HyperType. Its error messages are presented in a system called HyperVent.
23:19:57 * Dzlk gets to work on PCTP.
23:21:33 <Dzlk> It's a restricted subset of BTP (Beverage Transport Protocol), optimized for pear cider.
23:28:43 <shachaf> Ook! seems pretty easy to dictate.
23:30:09 * dolio thinks Epigram-style â would be handy.
23:32:32 <newsham> does ghc inline code much?
23:32:49 <mxc_> i love the top story on planet haskell
23:32:53 <mxc_> totally off topic, but I like it
23:33:15 <quicksilver> newsham: yes, quite aggressively
23:33:20 <monochrom> Yes, ghc inline much.
23:33:25 <quicksilver> newsham: inlining is vital for many of its optimisation.
23:33:40 <quicksilver> s.
23:48:04 <roderyk> having a lot of trouble with getting SDL working: Loading package SDL-mixer-0.5.2 ... linking ... <interactive>: /usr/local/lib/SDL-mixer-0.5.2/ghc-6.8.2/HSSDL-mixer-0.5.2.o: unknown symbol `Mix_LoadWAV'
23:48:09 <roderyk> any ideas?
23:48:24 <dmwit> I hate to ask this, but... is libSDL installed?
23:48:46 <roderyk> dmwit: I would like to tell you... *I think*
23:49:02 <roderyk> that is, it is installed but I fear maybe some of the LIBDIR paths are off
23:49:43 <roderyk> eg. I couldn't get SDL to import until in desperation I did:
23:49:45 <roderyk>  sudo ln -s /usr/local/lib/libSDL.so /usr/lib/
23:49:48 <newsham> seems like the straightforward translation to STG has lot of indirect branches per productive insns
23:50:00 <leoncamel> hmm, I learned this from the tutorial: "uppercase = map toUpper", and the type is "[Char]->[Char]". But if i define "myadd x y = x + y" and then "myadd3 x = myadd 3", it can:t work. why ?
23:50:02 <dmwit> yipe!
23:50:31 <dmwit> leoncamel: That should work just fine.
23:50:37 <dmwit> leoncamel: Although it might not do what you want it to.
23:50:40 <newsham> leon:  myadd3 x = myadd 3 x
23:51:06 <newsham> (or:  myadd3 = myadd 3)
23:51:44 <monochrom> "myadd3 = myadd 3" suffers from the monomorphism restriction.
23:51:48 <newsham> > let myadd x y = x + y; myadd3 = myadd 3 in myadd3 5
23:51:49 <lambdabot>  8
23:52:40 <monochrom> Of course "uppercase = ..." does too.  But it's already monomorphic to begin with, nothing lost. Whereas in "myadd3 = myadd 3" you lose polymorphism.
23:54:31 <leoncamel> oh.. I load the description from the file.
23:54:54 <leoncamel> and in the interactive command, I try "myadd3 5", it report a error
23:55:00 <leoncamel> the file here is:
23:55:09 <leoncamel> myadd x y = x + y
23:55:15 <newsham> ?hpaste
23:55:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:55:26 <leoncamel> myadd2 = myadd 2
23:55:39 <leoncamel> hmm, it is quite simple, so I just type it here.
23:55:51 <monochrom> My explanation applies.
23:56:15 <newsham> mono: can you reword your answer in simpler terms.
23:56:31 <monochrom> It is already in simplest terms.
23:56:35 <leoncamel> monochrom, hmm, what is monomorphism ? could you exaplain more deeply ?
23:56:59 <EvilTerran> monomorphism = lack of polymorphism
23:58:11 <hpaste>  newsham pasted "leon's code" at http://hpaste.org/8144
23:58:38 <EvilTerran> the Dreaded Monomorphism Restriction is a feature of haskell whereby things that look like they're constants (ie stuff defined as "foo = ..." without parameters) get made non-polymorphic (ie monomorphic) to prevent a certain class of behaviour happening when people don't mean it to
23:58:38 <newsham> its definitely not in simplest form.
23:59:53 <newsham> leon: your function "myadd" is valid over a wide class of different numeric types
