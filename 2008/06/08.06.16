00:00:15 <hpaste>  httpdss pasted "recursive function to infinity" at http://hpaste.org/8358
00:00:50 <httpdss> hey nice bot ;)
00:01:26 <httpdss> thats an example of what im trying to solve
00:02:15 <Saizan> that will either return True or recurse forever..
00:02:52 <blackdog> how do you read a string in as a binary number?
00:03:22 <sjanssen> @type Numeric.readInt
00:03:24 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
00:03:25 * blackdog has muy rusty haskell
00:03:58 <adu> muy == very?
00:04:09 <blackdog> bueno
00:04:09 <blackdog> :)
00:04:16 <sjanssen> @type Numeric.readInt 2 (`elem` "01") digitToInt
00:04:18 <lambdabot> forall t. (Num t) => String -> [(t, String)]
00:04:19 <adu> mi no comprende
00:04:27 <blackdog> adu: yes.
00:04:30 <blackdog> sorry, silly mood.
00:04:51 <blackdog> long meeting, kept sane by sketching a solution to the shortest pangram problem in haskell
00:05:05 <blackdog> mothers, don't let your babies became programmers on big teams....
00:05:12 <httpdss> Saizan, yes thats my basic problem ... can i say to haskell "if you have reached a recurse for ever, return false" ??
00:05:28 <adu> blackdog: pangram? whats that?
00:05:40 <adu> blackdog: whats wrong with big teams?
00:05:58 <blackdog> adu: a list of strings that contain all 26 letters
00:06:12 <blackdog> adu: you get a bit swamped by communication overhead
00:06:47 <adu> > ['a'..'z']
00:06:49 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
00:06:52 <adu> like that?
00:07:56 <blackdog> adu: well, generally you're also given a list of acceptable strings to build your pangram out of
00:08:05 <adu> o
00:08:10 <blackdog> the classic example is 'the quick brown fox jumped over the lazy dog"
00:08:15 <Saizan> httpdss: no, that would require solving the halting problem, you've to add a condition yourself, maybe count the recursive calls with an accumulator?
00:08:18 <blackdog> uh, modulo ' " mixups :)
00:08:29 <vixey> > sort . concat . word $ "the quick brown fox jumped over the lazy dog"
00:08:30 <lambdabot>   Not in scope: `word'
00:08:36 <vixey> > sort . concat . words $ "the quick brown fox jumped over the lazy dog"
00:08:37 <lambdabot>  "abcddeeeefghhijklmnoooopqrrttuuvwxyz"
00:09:05 <blackdog> so ideally i want to make a lazy list of 'em, in order of length
00:09:15 <blackdog> oops, gotta go. thanks for the readInt help
00:09:19 <adu> k
00:09:25 <vixey> www
00:09:32 <vixey> the problem is a fun one
00:09:51 <vixey> since letters may repeat, but you wish to reduce the amount of repeats
00:10:24 <blackdog> vixey
00:10:26 <blackdog> gotta go
00:10:28 <blackdog> but
00:10:28 <blackdog> http://www.itasoftware.com/careers/SolveThisWorkHerePuzzles.html?catid=114
00:10:29 <lambdabot> Title: Current ITA Programming Puzzles, http://tinyurl.com/5fpxlz
00:10:31 <blackdog> :) have fun
00:11:59 <httpdss> Saizan, im not gonna go for the nobel price yet so i'll try the accumulator instead ;) thx
00:12:00 <adu> heh
00:12:37 <vixey> @hoogle lower
00:12:39 <lambdabot> Text.ParserCombinators.Parsec.Char.lower :: CharParser st Char
00:12:39 <lambdabot> Data.Char.LowercaseLetter :: GeneralCategory
00:12:39 <lambdabot> Data.Char.isLower :: Char -> Bool
00:12:44 <vixey> @hoogle lowercase
00:12:44 <lambdabot> Data.Char.LowercaseLetter :: GeneralCategory
00:12:53 <vixey> how do you turn things to lowercase :s
00:13:00 <sjanssen> > toLower 'x'
00:13:01 <lambdabot>  'x'
00:13:04 <sjanssen> > toLower 'X'
00:13:05 <lambdabot>  'x'
00:13:18 <vixey> than
00:13:22 <vixey> thank you :)
00:25:10 <fishmacs> Hi all, I have a question
00:26:30 <fishmacs> I want to write a function which return the next random int
00:27:15 <fishmacs> getStdRandom $ randomR (1,100)
00:27:44 <fishmacs> but it has a type IO Int, how to get the Int?
00:28:33 <mm_freak> not at all…  such a function must be IO Int
00:29:39 <fishmacs> so how to use it?
00:30:07 <fishmacs> a <- myRandFunc?
00:30:07 <mm_freak> like you would use randomIO and randomRIO
00:30:11 <mm_freak> yes
00:31:05 <fishmacs> I want to use it in a let or where clause
00:31:23 <mm_freak> consider the impure nature of a function "returning the next random number"
00:31:28 <mm_freak> such a function has to be monadic
00:31:50 <mm_freak> but there are alternatives:  for example, you can create an infinite list of random bytes
00:31:55 <adu> >do g <- newStdGen ; return $ take 10 (randoms g :: [Int])
00:31:58 <mm_freak> see 'randoms'
00:32:02 <adu> > do g <- newStdGen ; return $ take 10 (randoms g :: [Int])
00:32:17 <lambdabot>  thread killed
00:32:34 <mm_freak> looks like lambdabot doesn't use unsafeInterleaveIO
00:32:44 <fishmacs> greate idea, thanks
00:32:51 <adu> > do g <- newStdGen ; return (take 10 (randoms g :: [Int]))
00:32:52 <lambdabot>  <IO [Int]>
00:33:08 <adu> hmm how to print
00:33:27 <fishmacs> but I still can not use list !! i?
00:33:32 <adu> > do g <- newStdGen ; print (take 10 (randoms g :: [Int]))
00:33:33 <lambdabot>  <IO ()>
00:33:45 <fishmacs> after I got IO [Int]
00:34:37 <mm_freak> > let g = unsafePerformIO newStdGen in take 10 (randoms g :: [Int])
00:34:38 <lambdabot>   Not in scope: `unsafePerformIO'
00:34:55 <mm_freak> fishmacs: you can pass the list to a pure function
00:34:56 <adu> fishmacs: sure you can
00:35:02 <mm_freak> you cannot create it outside the IO monad, though
00:35:28 <adu> fishmacs: just "do xs <- (some IO [Int] thing) ; xs !! i"
00:35:48 <vixey> @src on
00:35:48 <lambdabot> (*) `on` f = \x y -> f x * f y
00:36:27 <fishmacs> got the idea, thanks!
00:37:18 <mm_freak> fishmacs: you can just pass the infinite list, because it will be calculated lazily…  in fact, you should even prefer the infinite list
00:38:37 <adu> > next 1000
00:38:38 <lambdabot>  Add a type signature
00:38:59 <mauke> :t next
00:39:14 <lambdabot> thread killed
00:39:34 <adu> > next (mkStdGen 1000)
00:39:35 <lambdabot>  (40013322,40054014 40692)
00:39:51 <adu> > next (mkStdGen 1000
00:39:51 <lambdabot> Unbalanced parentheses
00:39:55 <adu> > next (mkStdGen 1000)
00:39:56 <lambdabot>  (40013322,40054014 40692)
00:40:07 <adu> hmm, not quite random
00:40:11 <adu> > next (mkStdGen 1001)
00:40:12 <lambdabot>  (40053336,40094028 40692)
00:40:27 <mauke> :t next
00:40:29 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
00:40:56 <mm_freak> @src StdGen
00:40:56 <lambdabot> Source not found. You speak an infinite deal of nothing
00:41:09 <adu> @src mkStdGen
00:41:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
00:41:32 <adu> @src String
00:41:33 <lambdabot> type String = [Char]
00:41:35 <mm_freak> :i StdGen
00:41:49 <mauke>  (StdGen)
00:43:31 <adu> > map (fst . next . mkStdGen) [1..]
00:43:32 <lambdabot>  [39336,79350,119364,159378,199392,239406,279420,319434,359448,399462,439476,...
00:43:36 <adu> there we go!
00:44:02 <mauke> ew
00:44:49 <electronx> can some help me with the following error with darcs
00:44:59 <opqdonut> > unfoldr (just.next) (mkStdGen 666)
00:45:00 <lambdabot>   Not in scope: `just'
00:45:04 <opqdonut> > unfoldr (Just.next) (mkStdGen 666)
00:45:05 <lambdabot>   Not in scope: `Just.next'
00:45:09 <electronx> family@TheMaster:~/Happs$ darcs get --partial --tag=0.9.2 http://happs.org/repos/HAppS-HTTP
00:45:09 <electronx> darcs: failed to read patch:
00:45:09 <electronx> Wed Dec 19 06:22:39 EST 2007  alex@happs.org
00:45:09 <electronx>   tagged 0.9.1.2
00:45:09 <electronx> /home/family/Happs/HAppS-HTTP/_darcs/patches/20071218192239-49c54-88c23fec4a12830b80c79ff71af2341d7cc59e1e.gz: openBinaryFile: does not exist (No such file or directory)
00:45:10 <opqdonut> > unfoldr (Just . next) (mkStdGen 666)
00:45:11 <electronx> family@TheMaster:~/Happs$
00:45:12 <lambdabot>  [26648646,1139484619,436583220,1620094785,278974428,2115895568,746443351,936...
00:45:14 <opqdonut> fuck this :P
00:45:21 <adu> electron hpaste.org
00:45:29 <mauke> > evalState (replicateM 10 next) (mkStdGen 666)
00:45:30 <electronx> oops srry
00:45:30 <lambdabot>  Couldn't match expected type `State s a'
00:46:07 <mauke> > evalState (replicateM 10 (State next)) (mkStdGen 666)
00:46:08 <lambdabot>  [26648646,1139484619,436583220,1620094785,278974428,2115895568,746443351,936...
00:46:40 <opqdonut> mauke: good point
00:47:13 <mauke> > evalState (sequence . repeat $ State next) (mkStdGen 666)
00:47:14 <lambdabot>  [26648646,1139484619,436583220,1620094785,278974428,2115895568,746443351,936...
00:47:20 <Japsu> evilState
00:47:30 * Japsu evilLaughter
00:47:35 <mauke> liveEtats
00:47:53 <opqdonut> vive l'etat!
00:47:56 <adu> electronx: i get the same error
00:47:57 <opqdonut> (or something to that effect)
00:48:21 <electronx> adu: so its something wrong with the version they have up there
00:48:38 <adu> yes, so its not your fault
00:48:44 <adu> just a sec let me check something
00:49:41 <electronx> thanks adu i thought i had compiled darcs incorrectly
00:54:09 <vixey> florisugent whacky gump a boxhead hova majo sa whiz cap squat!
00:54:30 <mauke> schtonk.
00:54:30 <vixey> > sort "florisugent whacky gump a boxhead hova majo sa whiz cap squat"
00:54:44 <electronx> > reverse "florisugent whacky gump a boxhead hova majo sa whiz cap squat!"
00:54:46 <lambdabot>  thread killed
00:54:53 <dons> dcoutts: 250 haskell libraries, apps and tools available in arch now :)
00:55:00 <lambdabot>  thread killed
00:55:05 <electronx> > reverse "florisugent whacky gump a boxhead hova majo sa whiz cap squat!"
00:55:10 <dons> just need to get  the gtk2hs things working, and we're sorted.
00:55:19 <lambdabot>  "!tauqs pac zihw as ojam avoh daehxob a pmug ykcahw tnegusirolf"
00:55:31 <vixey> > sort "florisugent whacky gump a boxhead hova majo sa whiz cap squat"
00:55:32 <lambdabot>  "          aaaaaaaabccdeefgghhhhiijklmmnooooppqrsssttuuuvwwxyz"
00:55:46 <electronx> why would you use GTK
00:55:52 <mauke> because it works
00:55:54 <electronx> why not wx
00:56:19 <electronx> wxHaskell also works great
00:56:31 <electronx> and is better imho
00:56:37 <vixey> unchrisom duplexity a whiz fagus akee benn hova majo sa cap tyt cran dowl squat :P
00:57:02 <osfameron> eeek!  #haskell is speaking in tongues.  Oh, it usually does that.
00:57:19 <hpaste>  vicky pasted "pangram generator" at http://hpaste.org/8360
00:57:21 <mauke> > (S.toList . S.fromList) "unchrisom duplexity a whiz fagus akee benn hova majo sa cap tyt cran dowl squat"
00:57:23 <lambdabot>  " abcdefghijklmnopqrstuvwxyz"
00:58:17 <mauke> > unwords $ map (: "izzle") ['a' .. 'z']
00:58:19 <lambdabot>  "aizzle bizzle cizzle dizzle eizzle fizzle gizzle hizzle iizzle jizzle kizzl...
00:58:36 <XGas> oh wow
00:59:04 <adu> electronx: have you tried 0.9.3?
00:59:17 <vixey> my program is very fond of "whacky gump"
00:59:20 <electronx> no i thought 0.9.2 was latest
00:59:29 <adu> 0.9.5 is latest
00:59:44 <vixey> and "akee benn cran dowl squat"
00:59:47 <adu> i dunno, I'm just looking at the bugtracket
00:59:49 <adu> er
01:00:01 <electronx> adu: is it stable?
01:00:11 <vixey> how could I have it repeat less..
01:00:25 <mauke> > repeat "less"
01:00:26 <lambdabot>  ["less","less","less","less","less","less","less","less","less","less","less...
01:01:32 <electronx> > take 5 (repeat "less")
01:01:34 <lambdabot>  ["less","less","less","less","less"]
01:02:28 <mauke> > "more" >> "less"
01:02:36 <lambdabot>  "lesslesslessless"
01:02:55 <electronx> heh why does that work?
01:03:05 <Deewiant> ?ty ("more" >>)
01:03:10 <lambdabot> forall b. [b] -> [b]
01:03:46 <electronx> :t (>>)
01:03:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
01:04:08 <Deewiant> > (concatMap . const) "more" "less"
01:04:10 <lambdabot>  "moremoremoremore"
01:04:13 <Deewiant> oops
01:09:07 --- mode: irc.freenode.net set +o Igloo
01:09:07 --- mode: irc.freenode.net set +o ChanServ
01:09:14 <Saizan> electronx: * is the "type" of the 'a' variable
01:09:32 <electronx> lol
01:09:44 <electronx> okay so i can think of it as the super type?
01:09:49 <Saizan> yeah
01:10:12 <electronx> so its not really usefull?
01:10:21 <adu> I've never heard of '*' before
01:10:28 <Deewiant> not in the sense that you'd have to use it pretty much anywhere
01:10:36 <Saizan> * is the kind of types of values, * -> * is the kind of type-functions
01:11:11 <Deewiant> but it can be handy to look at the kind of a monad transformer or some such complicated type and understand what it is
01:11:26 <Saizan> you've to care about it only if you need to write something that has type-parameters with a kind that's not *
01:11:36 <idnar> ?kind Monad
01:11:37 <lambdabot> Class `Monad' used as a type
01:12:00 <idnar> er
01:12:15 <Deewiant> Monad is a type class, not a type :-)
01:12:19 <idnar> yes
01:12:29 <idnar> I'm attempting to reconstruct the chain of reasoning that lead to me typing that out
01:12:35 <Deewiant> heh
01:12:36 <idnar> but not having much luck :P
01:12:42 <Saizan> to be an instance of Monad a type must be of kind * -> *
01:12:43 <Deewiant> ?kind (->)
01:12:44 <electronx> hehe
01:12:45 <lambdabot> ?? -> ? -> *
01:12:49 <Deewiant> O_o
01:12:53 <idnar> whee
01:13:03 <electronx> holly schmolly
01:13:17 <electronx> theres a ?? type and a ? type never knew that
01:13:24 <Deewiant> I was expecting * -> * -> *
01:13:30 <electronx> maybe theres also a ??? type
01:13:31 <Saizan> ?? and ? are almost GHC implementation details
01:13:32 <lambdabot> Plugin `compose' failed with: Unknown command: ""
01:13:40 <Saizan> electronx: they are kinds
01:13:44 <adu> ?kind (*)
01:13:46 <lambdabot> parse error on input `*'
01:13:55 <electronx> ?kind (??)
01:13:56 <adu> ?kind (->*)
01:13:57 <lambdabot> Not in scope: type variable `??'
01:13:59 <lambdabot> Not in scope: type variable `->*'
01:14:12 <Saizan> kinds don't have a kind :)
01:14:17 <electronx> :)
01:14:31 <electronx> its should at least say Master Kind :)
01:14:31 <Saizan> ?? and ? have to do with unboxed types
01:14:32 <lambdabot> Plugin `compose' failed with: Unknown command: ""
01:14:41 <adu> ?kind (\x,y,z->(x->y->z))
01:14:42 <lambdabot> parse error on input `\'
01:14:44 <idnar> ?kind (->) Int
01:14:46 <lambdabot> ? -> *
01:14:56 <adu> ?kind (\x y z->(x->y->z))
01:14:57 <lambdabot> parse error on input `\'
01:15:06 <idnar> I can't remember the difference between ?? and ?
01:15:28 <electronx> Saizan why do you know so much about haskell?
01:15:47 <electronx> Deewiant you also :)
01:15:50 <adu> electronx: do you mean why? or how?
01:16:00 <electronx> both really
01:16:07 <Saizan> idnar: ? is only * + unboxed tuples, ?? also all the unboxed types, iiirc
01:17:11 <Saizan> electronx: because i've been on this channel and used haskell for some time :)
01:17:16 <Deewiant> electronx: been using it since last autumn and I've been listening to this IRC channel a lot ;-)
01:17:21 <adu> I know so much because I read the Haskell98 report every night
01:17:22 <Deewiant> and I've been reading reddit
01:17:35 <electronx> hehe
01:17:53 <electronx> doing anything serious in haskell?
01:17:54 <idnar> Saizan: ah
01:18:37 <adu> electronx: I think the most serious thing that you can do is to convert someone to FP
01:18:49 <electronx> lool
01:19:21 <electronx> i'm converted but we'll know if it will stick after i start writing my site in it :)
01:19:31 <adu> i mean i talk to ppl at my work and they tell me about memory leaks and buffer overflows and race conditions
01:19:46 <electronx> also an timetable solver for a business
01:19:58 <adu> then I tell them about Haskell and how many of these problems don't exist
01:20:19 <adu> then they're like "What's functional programming"?
01:20:20 <electronx> adu: for a sec i thought you were talking about haskell :)
01:20:29 <Deewiant> yeah, instead we've got problems like "fromJust: Nothing" ;-)
01:20:42 <electronx> and run
01:20:43 <electronx> .......
01:20:47 <electronx> staock overflow
01:20:50 <electronx> stack*
01:21:09 * electronx Sh#t mother ######
01:21:13 <electronx> :)
01:22:11 <electronx> on a side note adu why do you work with people that don't even know what an fp language is?
01:22:35 <electronx> clearly those people shouldn't even be coding
01:22:36 <adu> because I don't know which companies would be better
01:22:43 <osfameron> huh?
01:22:46 <Saizan> Deewiant: the solution is clear, use Agda :)
01:22:55 <osfameron> I'd guess most non-uni trained jobbing programmers don't know about FP
01:23:05 <osfameron> and most uni-trained ones did a course in it, hated it, then forgot it
01:23:22 <osfameron> being snide about the average programmer doesn't really help advance the cause
01:23:26 <electronx> osfameron i'm one of the later
01:23:33 <electronx> but i'm back
01:23:34 <Saizan> at my uni we don't even have an fp course..
01:23:40 <idnar> stock overflow
01:23:52 <adu> I know 2 fp programmers IRL, and neither of them does fp for a living
01:24:02 <osfameron> yeah, I keep on thinking about doing an actual computer science degree, but the Open University ones don't seem to have any FP content, which I'd like
01:24:17 <Deewiant> Saizan: might as well go Prolog while we're at it. :-P
01:24:19 <electronx> haha Open University
01:24:23 <idnar> osfameron: weeeelll, being snide doesn't help, but the average programmer really shouldn't be allowed near a keyboard
01:24:37 <osfameron> idnar: then no code would get written and business owners would get upset
01:24:43 <vixey> Prolog will say "no"
01:25:34 <osfameron> electronx: well, any of the "distance learning" courses in UK that I've looked at -- know of any better ones?
01:25:39 <electronx> if you are good programmer and know haskell well you can create something better then a team of 10 monkeys with C. So why not just become competition for them and run them out of business?
01:25:57 <electronx> osfameron: no :(
01:25:58 <osfameron> electronx: *that*'s a better answer :-)
01:26:56 <electronx> Metastock and Amibroker is real world proof about what i'm talking about
01:27:04 <adu> electronx: that requires business intelligence, which most programmers (even the best) don't have
01:27:30 <electronx> adu: Thats unfortunate
01:28:12 <electronx> althought Amibroker is not created in Haskell it shows what a big difference it is for someone who is a good programmer
01:28:34 <electronx> Metastock about 15 employees amibroker 1
01:28:43 <idnar> osfameron: hah
01:28:53 <adu> plus, its a bad idea to be an entrepreneur and an engineer at the same time
01:28:56 <electronx> Metastock in C++ and amibroker in C++
01:29:11 <electronx> ada: i beg to differ
01:29:25 <electronx> it doesn't take alot to create a website these days
01:29:37 <electronx> and sell you prgramme
01:29:43 <adu> electronx: a website, no, a company, yes
01:29:46 <electronx> if people like it then they will come
01:30:47 <vixey> has anyone else tried a pangram generator?
01:31:02 <vixey> I've made one but it's tricky to get it to give good variety
01:31:19 <electronx> whats pangram generator?
01:31:47 <vixey> well it generates pangrams..
01:32:07 <electronx> whats funny is if we want to make fp and Haskell popular we need to create something that is real world and better then anything out there
01:34:02 <electronx> why hasn't anyone done that?
01:34:12 <electronx> i'm confused
01:34:22 <adu> electronx: they have
01:34:29 <electronx> like what?
01:34:44 <adu> electronx: just look at darcs, xmonad, happs, and yi
01:34:45 <vixey> well I've made a program that prints out "bronchoplegia diffusivity waxmaker jazzily alloquy"
01:34:54 <electronx> lol
01:35:01 <vixey> :p
01:35:18 <electronx> vixey: i'm being serious
01:35:23 <hpaste>  vicky pasted "better variety" at http://hpaste.org/8361
01:35:26 <vixey> so am I!
01:35:29 <adu> although I think the installation procedure should be streamlined
01:35:40 <BeelsebobWork> adu: well, from an outside standpoint darcs is not as good as hg because it's slow, xmonad is just a reimplementation of something that already existed, and yi is very geared towards editing Haskell
01:35:52 <adu> whats hg?
01:35:54 <sieni> Well, as usual, installation is the reverse of the removal procedure
01:35:57 <BeelsebobWork> Mercurial adu
01:36:03 <adu> o
01:36:42 <electronx> i feel like commiting suicide by putting all this time into haskell and being the first to create a fully fledged website and programme in haskell
01:37:12 <adu> electronx: like what?
01:37:19 <electronx> i just wish someone had done it something big before me so i know that it can be done
01:37:39 <vixey> preflex: rhinoplastic abjudge formazyl waxmaker absvolt abietin adamite quinquetuberculate
01:37:40 <electronx> adu: Trading website
01:37:54 <adu> like ebay?
01:38:08 <electronx> almost that big
01:38:23 <electronx> but not quite but very big
01:39:02 <electronx> java would have been that logical choice
01:39:12 <adu> not really
01:39:35 <adu> only for executives and entrepreneurs
01:39:41 <adu> a programmer would never choose java
01:39:57 <electronx> adu: well i can't see the site running on php not to mention ruby
01:40:13 <electronx> those two are way to slow
01:40:24 <vixey> @w80 squirrelproof
01:40:24 <lambdabot> No match for "squirrelproof".
01:40:26 <adu> right, php is also a nice executive choice, but a poor programmer's choice
01:40:40 <vixey> @w80 billywix
01:40:41 <lambdabot> No match for "billywix".
01:40:43 <electronx> well ruby is really really slow
01:40:45 <BeelsebobWork> @w80 squirrelfish
01:40:45 <lambdabot> *** "squirrelfish" wn "WordNet (r) 2.0"
01:40:45 <lambdabot> squirrelfish
01:40:45 <lambdabot>      n 1: similar to sea bream; small spiny-finned fish found in bays
01:40:45 <lambdabot>           along the southeastern coast of the United States [syn:
01:40:45 <lambdabot>           {pinfish}, {sailor's-choice}, {Lagodon rhomboides}]
01:40:47 <lambdabot> [4 @more lines]
01:40:55 <electronx> python is okay but also slow for my liking
01:41:04 <BeelsebobWork> ah, so that's what it does
01:41:05 <vixey> ah hemoglobiniferous patchworky devilize abjudge alloquy extreme squirrelfish
01:41:21 <BeelsebobWork> vixey: what the hell are you up to today?
01:41:50 <electronx> adu: doesn't leave many options does it?
01:41:54 <adu> electronx: ya, theres this guy who kept telling my that python was fast, then he wrote a window system in it and kept worrying that it would idle at 70% cpu usage... lol
01:41:59 <vixey> BeelsebobWork: http://hpaste.org/8361
01:42:11 <telexicon> are there base64 functions available for haskell? i just downloaded Crypto-4.1.0 and found that the base64 module was removed, did this move somewhere else? was it included in some other library?
01:42:30 <adu> electronx: then I would use happs
01:42:47 <electronx> adu: exactly what i'm doing :)
01:42:52 <adu> :)
01:43:28 <adu> electronx: have you tried installing happs without the --tag=0.9.2?
01:43:35 <electronx> no
01:43:38 <dcoutts> dons: that's almost as many packages as we have in gentoo :-)
01:43:41 <adu> electronx: i.e. just getting the latest
01:43:53 <BeelsebobWork> vixey: http://webkit.org/blog-files/squirrelfish.png
01:43:57 <electronx> but is latest stable?
01:44:06 <vixey> hehe
01:44:09 <adu> i don't know
01:44:13 <dcoutts> adu: do you need anything that needs Cabal >1.5.1? there should not be any such thing.
01:44:40 <adu> electronx: by definition, no, but from my experience yes (but you may have to add "Build-Type: Simple" to some file somewhere
01:45:11 <electronx> i did darcs get  http://happs.org/repos/HAppS-HTTP
01:45:15 <electronx> 908 patches
01:45:16 <adu> YEY!
01:45:36 <adu> dcoutts: yes, latest yi
01:45:54 <dcoutts> adu: hmm, they should fix that. They should depend on >=1.4 && < 1.5
01:46:03 <BeelsebobWork> electronx: --partial time?
01:46:13 <adu> dcoutts: that would be nice
01:46:34 <adu> dcoutts: why <1.5
01:46:36 <electronx> no --partial
01:46:52 <dcoutts> adu: otherwise it will break when 1.5 starts getting more api changes
01:47:03 <adu> o
01:47:44 <electronx> what i like about Happs is that i get a compiled server
01:47:53 <electronx> not scripts
01:49:12 <electronx> also haskell will have a super compiler soon if Neil finishes it :-)
01:51:29 <adu> electronx: super-Hopt?
01:53:35 <nus> electronx, how do you update such a server? is downtime negligible?
01:54:10 <electronx> www-users.cs.york.ac.uk/~ndm/supero/
01:54:20 <electronx> nus: yeah
01:54:45 <electronx> a few seconds downtime isn't a big deal
01:55:28 <electronx> i'm sure you code make it moduler if its a big problem so you would only changes bits of the server
01:55:33 <electronx> could*
01:55:35 <adu> electronx: it is if you don't want to drop from 99.999 to 99.99
01:55:51 <electronx> lol
01:56:20 <electronx> adu: to tell you the truth a havn't thought of it that much actually
01:56:36 <electronx> i don't think it would be such a big issue
01:56:49 <adu> if you are an ISP it is a huge issue
01:57:09 <electronx> well nobody would run an ISP on haskell :)
01:57:18 <electronx> maybe erlang would be better
01:57:40 <quicksilver> FUD
01:57:48 <electronx> adu: did ya check out the link for supero
01:57:53 <quicksilver> running an ISP on haskell may easily be a sensible choice.
01:57:55 <adu> just cuz Erickson runs on Erlang doesn't mean Haskell isn't better
01:57:59 <cjs> Having run an ISP, Haskell would be no worse than anything else I've used.
01:58:10 <quicksilver> zero downtime upgrades are accomplished in another layer
01:58:19 <quicksilver> you have a cheap http frontend proxy
01:58:29 <quicksilver> which switches over from old version to new version atomically
01:58:36 <quicksilver> app startup time is not an issue
01:58:47 <cjs> Oh, yeah, for web stuff? That's all in other layers.
01:58:56 <quicksilver> sure, it's mildly convenient if you can do an upgrade transparently in the app layer
01:59:08 <quicksilver> but in practice there are other good reasons to have layers in front
01:59:31 <quicksilver> (load balancing, transparent caching of static data, GeoIP magic)
01:59:38 <quicksilver> and since you've got the other layers you may as well use them.
01:59:39 <electronx> well i learnt something new then haskell can run an isp
01:59:44 <electronx> that*
02:00:34 <electronx> someone should write a p2p app in haskell
02:00:48 <mm_freak_work> isn't there one already?
02:00:53 <electronx> it would probably come out pretty nice
02:01:04 <electronx> lazy evaluation would be kind
02:01:07 <electronx> king*
02:02:16 <electronx> <mm_freak_work>: i would say it isn't very good
02:02:50 <mm_freak_work> dunno, haven't tried it
02:03:00 <mm_freak_work> IMO there are more useful things than p2p clients
02:03:22 <electronx> just thought that its somewhere where Haskell would shine
02:03:37 <mm_freak_work> mldonkey wasn't so successful, because it was written in ocaml…  in fact, i didn't like it a lot
02:03:56 <mm_freak_work> but it was the first client to support many p2p networks, and which had that client/server model
02:03:57 <mapreduce> How did being written in ocaml negatively affect it?
02:04:13 <mm_freak_work> mapreduce: it didn't, i guess
02:04:14 <adu> ocaml is a great language
02:04:14 <electronx> mapreduce: lack of libs?
02:04:23 <mm_freak_work> mldonkey is a memory hog
02:04:43 <mapreduce> electronx: Oh, is there no FFI?
02:04:46 <electronx> ocaml is poorly written imho
02:05:00 <electronx> mapreduce there is but that takes time
02:05:54 <mm_freak_work> electronx: i'm pretty sure that ocaml is a good language, if you can live with the impure nature of it
02:05:58 <mapreduce> I see.  But obviously time wasn't a great problem, as it got there first.
02:06:15 <mm_freak_work> mldonkey was innovative, and that made its success
02:06:21 <electronx> mapreduce: maybe that dev wasn't very good
02:06:48 <electronx> depends alot of the developer too
02:06:50 <quicksilver> electronx: "ocaml is poorly written" ?
02:06:51 <quicksilver> wtf?
02:06:51 <electronx> on*
02:07:04 <quicksilver> you got any evidence to back that statement up?
02:07:15 <electronx> <quicksilver>: something i read in one of the mailing lists
02:07:21 <quicksilver> must be true then.
02:07:29 <electronx> lol
02:07:50 <electronx> the general complaint was that the devs behind ocaml wern't fixing things
02:08:01 <quicksilver> does sound like "poorly written" then
02:08:05 <quicksilver> sounds like "under-maintained"
02:08:10 <electronx> yep
02:08:28 <mapreduce> Ok, thanks.  I know now to ignore your non-specific complaints, electronx and mm_freak_work :)
02:08:31 <adu> I want to help with Yi maintainance
02:08:32 <electronx> they said that some things 'were to hard to fix'
02:08:33 <nus> quicksilver, the question in essence is how much the recovery of the app state does cost you. For a general webserver, not much, I guess.
02:09:51 <mm_freak_work> mapreduce: complaints?  i didn't complain about anything
02:10:03 <electronx> quicksilver: maybe if ocaml was being supported by someone like Simon Marlow then ocaml would have been a really really good language
02:10:08 <mm_freak_work> <mm_freak_work> electronx: i'm pretty sure that ocaml is a good language, if you can live with the impure nature of it
02:10:14 <quicksilver> ocaml is a relly really good language.
02:10:18 <mm_freak_work> doesn't sound like a complaint ;)
02:10:20 <quicksilver> It's far more widely used than haskell.
02:10:31 <quicksilver> And very wel thought of throughout the functional programming community.
02:10:36 <electronx> <quicksilver>: really why do you say that?
02:10:38 <mapreduce> "<mm_freak_work> mldonkey wasn't so successful, because it was written in ocaml…  in fact, i didn't like it a lot"
02:10:38 <cjs> I don't like the syntax nearly as much as Haskell.
02:10:39 <quicksilver> It won over many user sfrom SML.
02:10:54 <quicksilver> Personally I much prefer haskell, both for syntactic and semantic reasons (purity)
02:11:14 <electronx> quicksilver #ocaml has only 75 people in it
02:11:18 <quicksilver> however it's hard to describe ocaml as anything other than a excellent language with good tool support and a great compiler.
02:11:19 <cjs> And also, Haskell appears to have a much brighter future, as far as implementations go.
02:11:19 <mm_freak_work> mapreduce: sorry, that's a misunderstanding
02:11:25 <electronx> #haskell has 414
02:11:26 <mapreduce> I've been meaning to glance over at OCaml.
02:11:35 <vixey> assuming 75 = 64
02:11:42 <quicksilver> electronx: with respect, you clearly don't know what you're talking about.
02:11:53 <mapreduce> electronx: Java is the most used language according to TIOBE, but #haskell has 150 more users than ##java.
02:11:53 <quicksilver> I've used ocaml for years and I know many many other people who have.
02:11:58 <mm_freak_work> mapreduce: it should mean: the fact that mldonkey wasn't so successful, is not it being written in ocaml, but because it was innovative
02:11:59 <quicksilver> most of them aren't in #ocaml.
02:12:03 <mapreduce> Largely because #haskell is great and ##java's a shithole. :)
02:12:12 <electronx> quicksilver: i have never code in ocaml
02:12:14 <adu> lol
02:12:27 <quicksilver> that would support the suggestion taht you don't know what you're talking about.
02:12:32 <adu> electronx: I only know 2 things about ocaml:
02:12:42 <quicksilver> How about you reserve your criticism of languages for ones you have ACTUALLY USED?
02:12:55 <adu> (1) No type classes (2) The 'object' keyword
02:12:57 <cjs> NO CRITICISM OF COBOL! :-)
02:13:06 <electronx> quicksilver: i did alot of research before coming to haskell and my impression was that ocaml was less popular then haskell
02:13:07 <vixey> adu: they have modules though
02:13:10 <mapreduce> I can criticise dynamic languages without using them.
02:13:22 <mapreduce> "They're crap because they don't have static types"
02:13:34 <electronx> <adu>: lol
02:13:51 <adu> vixey: hmm, that's right, they can act as interfaces...
02:13:56 <electronx> mapreduce: lol
02:14:08 <mapreduce> I might be wrong, (and actually don't quite think that way), but it's a valid viewpoint.
02:14:22 <fishmacs> hi, how can I join a list of String with white space?
02:14:22 <adu> I love the 'object' keyword, because it allows you to make unnamed datatypes, pretty much
02:14:23 <quicksilver> mapreduce: valid but not very well informed :)
02:14:26 <Vq^> quicksilver: do you know why/what that let rec is about?
02:14:31 <fishmacs> just like join function in perl or python?
02:14:34 <quicksilver> mapreduce: that's a weak sense of the word 'valid'.
02:14:36 <quicksilver> mapreduce: ;)
02:14:40 <electronx> okay quicksilver we should continue this discussion in ten years :)
02:14:41 <Vq^> quicksilver: and why SML doesn't need it?
02:14:46 <quicksilver> fishmacs: unwords
02:15:08 <quicksilver> Vq^: ocaml has separate recursive and non-recursive lets
02:15:11 <adu> why ten?
02:15:12 <electronx> i bet that ocaml will end up like lisp
02:15:14 <vixey> hopefully there will be something more interesting to talk about in 10 years than which programming language is more popular
02:15:25 <quicksilver> Vq^: the order of function definitions is significant, IIRC.
02:15:28 <mm_freak_work> unlambda is the best language…  functional and only a single type =)
02:15:28 <electronx> lol
02:15:33 <quicksilver> I forget the deatils.
02:15:56 <fishmacs> but if not white space, just ',' or other characters?
02:15:59 <electronx> lisp: is dying a slow painfule death just as ocaml will :)
02:16:09 <adu> i gtg
02:16:12 <vixey> fishmacs: intercalate
02:16:13 <electronx> me too
02:16:14 <adu> later
02:16:17 <electronx> later adu
02:16:31 <vixey> > intercalate "," ["this","that","the other"]
02:16:32 <sjanssen> fishmacs: concat
02:16:33 <lambdabot>  "this,that,the other"
02:16:39 <sjanssen> fishmacs: oh, with whitespace
02:16:53 <sjanssen> fishmacs: unwords or unlines
02:16:56 <Vq^> quicksilver: why not just declare everything 'rec'? what do they win by giving the choice to the programmer?
02:17:10 <sjanssen> > unwords ["foo", "bar"]
02:17:11 <lambdabot>  "foo bar"
02:17:23 <Vq^> i've searched quite a while on that big net thingemajig and haven't been able to find information on that :(
02:17:31 <mm_freak_work> > lines "test\r\ntest"
02:17:32 <lambdabot>  ["test\r","test"]
02:17:47 <mm_freak_work> > lines "test\n\ntest"
02:17:48 <lambdabot>  ["test","","test"]
02:18:02 <fishmacs> :m Data.List
02:18:15 <mm_freak_work> @src lines
02:18:15 <lambdabot> Source not found. :(
02:18:16 <vixey> :m + Data.List
02:18:41 <Vq^> makes sense, lambdabot is on a *nix box i believe
02:18:47 <mm_freak_work> > words "abc  def\n\nghi"
02:18:49 <lambdabot>  ["abc","def","ghi"]
02:19:27 <mm_freak_work> > words "abc  def\n\nghi\r\ntest"
02:19:29 <lambdabot>  ["abc","def","ghi","test"]
02:19:30 <sjanssen> Vq^: Windows will have the same behavior
02:19:32 <fishmacs> intercalate is the right choice, thanks
02:19:37 <mm_freak_work> hmm
02:19:50 <Zao> sjanssen: Indeed it does.
02:19:51 <osfameron> heh, homework guy yesterday ".i mean i came here to look help and you point me to tutorilas........like i have my whole life to read them...."
02:19:58 <sjanssen> Vq^: it isn't a problem in practice since all the text IO functions do the necessary conversions
02:20:19 <osfameron> I even told him which words to search for to find the solution :-(
02:20:23 <Vq^> sjanssen: ah, how convenient
02:20:41 <Vq^> sjanssen: does it do the same on the other systems that differ from unix?
02:20:41 <Zao> osfameron: It had me chuckling a bit.
02:20:56 <mm_freak_work> sjanssen: it's a problem for telnet-like protocols, for which i need to write own versions
02:21:18 <quicksilver> Vq^: I know of two possible answers
02:21:34 <sjanssen> mm_freak_work: yeah, this is true.  There should be an "untokenize" generalization over unwords/lines
02:21:41 <mm_freak_work> there should be functions like linesBy and wordsBy
02:21:42 <quicksilver> Vq^: (a) it may be seen as a way to make compilation faster, not having to do dependency analysis
02:21:51 <quicksilver> Vq^: (b) it lets you refer to 'old versions of'
02:22:00 <quicksilver> is in "let s = s + 1"
02:22:13 <quicksilver> which is a recursive binding in haskell but not in ocaml.
02:22:21 <sjanssen> Vq^: I only know about Windows and Unix (does GHC run in any places with different line conventions?)
02:22:45 <quicksilver> To be fair, I prefer the approach haskell takes, but the ocaml one is definitely defensible.
02:22:55 <quicksilver> sjanssen: OSX ;)
02:23:12 <quicksilver> sjanssen: but I think because ghc runs in OSX's "unix layer" it uses unix line endings.
02:23:13 <sjanssen> quicksilver: isn't OS X pure \n?
02:23:28 <Vq^> sjanssen: yes it is
02:23:50 <Vq^> old macos wasn't thought
02:24:58 <BeelsebobWork> classic Mac OS (pre-OS X) used '\r'
02:27:26 <Vq^> OpenVMS had a curious system, the os took care of separating the lines in line-based files
02:27:47 <Vq^> and then you had a specific set of systemcalls for working with lines
02:29:30 <vincenz> @seen ndm
02:29:30 <lambdabot> ndm is in #haskell-blah. I last heard ndm speak 19m 21s ago.
02:29:36 <vincenz> ndm: ping
02:32:10 <cjs> That used to be pretty common in the mainframe world. Unix-style was the curious system back in the 70s, actually,.
02:33:55 <Vq^> quicksilver: so it could be for supporting redefinition of functions when the new function is recursive?
02:40:16 <quicksilver> Vq^: something like that
02:44:26 <Spockz|Orthesaur> BeelsebobWork: what is the current line-ending of OS X?
02:44:35 <BeelsebobWork> \n
02:44:39 <BeelsebobWork> just like any other UNIX
02:44:55 <Spockz|Orthesaur> ok. That's why. :)
02:45:26 <Spockz|Orthesaur> I saw every newline twice, one newline and one carriage return
02:45:46 <pejo> ChilliX, \hscase{\hscase{x}{..}}{..} gives a weird placement of the "of" for the first case-statement. Happen to have any insight about this? :-)
02:46:15 <BeelsebobWork> Spockz|Orthesaur: a file edited under windows that you opened in a TextEditor that wasn't expecting it?
02:48:03 <czShadoW> \r was in MAC OS 9 and older.
02:48:32 <BeelsebobWork> czShadoW: yes, but getting *both* is a windows thing, because strangely, Windows is the only OS that gets it right there
02:49:14 <BeelsebobWork> "right" in terms of telling a printer exactly what to do
02:51:26 <pejo> 1 2 3, testing the lambdabot tell.
02:55:59 <Baughn> BeelsebobWork: You realize I'm going to have to murder you fatally for saying that, right?
02:56:14 <Baughn> Anyway, you may have been correct.. 20 years ago... these days we have printer drivers. And no line-printers.
02:56:20 <sieni> how do you murder non-fatally?
02:56:21 <BeelsebobWork> indeed
02:58:33 <osfameron> sieni: presumably that's how you'd murder in a side-effect free language
02:59:33 <Spockz|Orthesaur> BeelsebobWork: Yes, that was the case indeed
02:59:39 <Spockz|Orthesaur> But it wasn't with every line.
03:17:50 <heavensrevenge> hello?
03:18:13 <quicksilver> hello.
03:18:44 <heavensrevenge> can anyone recommend a Gui toolkit?? :)  one tat has quite able haskellness to it, wx or gtk??
03:18:53 <quicksilver> Yes.
03:18:57 <heavensrevenge> both seem to work good
03:18:57 <quicksilver> WX or GTK.
03:18:58 <quicksilver> ;)
03:19:00 <heavensrevenge> i trried both
03:19:29 <heavensrevenge> and both are just fine from the intro, but do you know any larger scale effect from using them??
03:20:22 <heavensrevenge> like, the gtk binaries are WAY smaller, and the glade gui builder seems damn delicious, and the wx app seems primitive and fast, since i dunno of a gui builder for it
03:20:56 <mm_freak_work> if you don't have any particular reason to prefer WX, use GTK
03:21:04 <heavensrevenge> so im just lookin for input from an experienced set of hands that may be able to enlighten me for a project :)
03:21:28 <heavensrevenge> no, i have no preference on either 1 little bit
03:21:28 <laz0r> there exists qt binding for haskell too, but it is in alpha or beta stage
03:21:53 <mm_freak_work> GTK is richer and almost everybody with a GUI and non-windows has it installed
03:21:56 <heavensrevenge> yea, thats why ive just been mentioning the others, i know of the Qt binding, but it did seem very alpha
03:22:35 <heavensrevenge> just a wonder, are apps indirectly openGL enabled??
03:22:37 <mm_freak_work> and it seems like many people find the GTK interface clearer and more intuitive
03:23:05 <heavensrevenge> or at least video card rendered and not cpu rendered
03:23:24 <heavensrevenge> if free gl rendering comes with gtk, them im sold lol
03:23:33 <mm_freak_work> many operations are hardware-accelerated, but without opengl
03:24:07 <heavensrevenge> im not going to be using any internally specific gl renders
03:24:17 <Dzlk> there was a time wx was cross-platform and GTK wasn't, but that's not really true anymore, so the case for wx is less strong than it was.
03:24:21 <heavensrevenge> it would just be nice if it was hardware accelerated
03:24:34 <fishmacs> hi, is there something like Text.Printf.printf, but write to a String?
03:24:48 <heavensrevenge> thank you muchly guys
03:24:58 <heavensrevenge> i do believe ill continue with gtk for now :)
03:25:39 <wjt> fishmacs: printf can do that
03:25:41 <heavensrevenge> as im aiming for a nice x-platform MSN client, coded in haskell of course
03:25:56 <wjt> > (printf "%d %f" (3::Int) (3.3::Float)) :: String
03:25:58 <lambdabot>  "3 3.3"
03:26:13 <wjt> fishmacs: or, you can run printf in IO:
03:26:14 <wjt> > (printf "%d %f" (3::Int) (3.3::Float)) :: IO String
03:26:15 <lambdabot>  <IO [Char]>
03:26:57 <fishmacs> > (printf "%d %f" 3 1.0) :: String
03:26:59 <lambdabot>  "3 1.0"
03:27:16 <fishmacs> that's great, thanks wjt!
03:29:10 <Baughn> fishmacs: For your edification, figure out just how printf does that. The type tricks are.. amusing
03:29:49 <laz0r> mmh, how can printf have a variable number of arguments?
03:29:56 <laz0r> i am just wondering...
03:30:11 <Botje> laz0r: google for "polyvariadic functions"
03:30:14 <Saizan> ?type printf
03:30:15 <lambdabot> forall r. (PrintfType r) => String -> r
03:30:18 <Botje> and come back when your head is done exploding :)
03:30:23 <Botje> @quote polyvar
03:30:24 <lambdabot> Botje says: [on googling for polyvariadic typeclasses] OH GOD THE FIRST HIT IS OLEGS SITE! / *ahum* / I meant, "yay, reading material"
03:30:48 <swiert> Polyvariadic functions have a peculiar arity.
03:31:08 <Saizan> Text.Printf is not so head-explosive, still h98!
03:31:16 <laz0r> uh, shiny, but who is this Oleg anyways?
03:31:33 <laz0r> seems to be some kind of running gag around here
03:32:29 <Dzlk> on a related subject, is there a way to do an 'apply' function, as in apply :: (a -> a -> a) -> [a] -> b ..?
03:32:55 <Dzlk> for the moment I don't need variable arity.
03:33:14 <dibblego> Dzlk, fmap?
03:33:45 <wjt> laz0r: he performs amazing feats with the type system
03:33:50 <fishmacs> Yes, printf seems magic
03:33:57 <Dzlk> (I was about to add that there's probably something perfectly obvious)
03:34:18 <wjt> Dzlk: where did b come from there?
03:34:27 <swiert> Dzlk: there's no way to get a "b" if all you have is "a's"..
03:34:51 <dibblego> Dzlk, your question is too vague
03:35:05 <dibblego> perhaps you're looking for a lifting operation, such as fmap
03:35:56 <Dzlk> Er. I think 'b' must have come from my being awake 24+ hours. I somehow meant it to mean 'I don't care about the return value'.
03:36:23 <Saizan> apply f (x:y:_) = f x y -- you mean this?
03:36:31 <swiert> > :t foldr1
03:36:32 <lambdabot>   parse error on input `:'
03:36:39 <Dzlk> Saizan: yes.
03:36:53 <dibblego> cripes; how'd you guess that?
03:38:00 <dibblego> ?type foldr
03:38:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:38:16 <swiert> ?type foldr1
03:38:18 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:38:45 <Dzlk> Aha. I was fooling around with folds but forgot about foldr1.
03:39:02 <dibblego> Dzlk, foldr1 is a specialisation of foldr
03:39:28 <Saizan> > foldr1 f [x,y,w,z]
03:39:30 <lambdabot>  f x (f y (f w z))
03:39:38 <Athas> Is there a guide somewhere to setting up a decent Haskell work environment (interactive evaluation and so forth) in Emacs? I found haskell-mode, but it appears out-of-date.
03:42:51 <quicksilver> Athas: which haskell-mode did you find?
03:43:23 <Athas> quicksilver: http://haskell.org/haskell-mode/ and whatever is retrieved when I install the haskell-mode package in Debian.
03:43:24 <lambdabot> Title: Haskell Mode for Emacs
03:43:50 * quicksilver nods
03:44:20 <quicksilver> I don't think the debian one is out of date.
03:44:24 <quicksilver> what made you think it was?
03:44:49 <Athas> Remarks on websites with no date specified.
03:45:38 * quicksilver nods
03:45:48 <quicksilver> well it's fairly old code, but it works fine.
03:45:58 <quicksilver> I personaly use kuribas' updated indentation code, though.
03:46:01 <quicksilver> quite a bit nicer.
03:52:04 <Athas> What's the Haskell naming conventions with respect to files?
03:52:09 <Athas> I might as well learn it from the start.
03:52:54 <mm_freak_work> huh?!
03:52:57 <mm_freak_work> > (a,b,c)
03:52:58 <lambdabot>  (a,b,c)
03:53:11 <mm_freak_work> :t a
03:53:11 <Jaak> @type a
03:53:13 <lambdabot> Expr
03:53:14 <lambdabot> Expr
03:53:32 <Jaak> @instances Num
03:53:33 <lambdabot> Double, Float, Int, Integer
03:53:38 <Jaak> > a + b
03:53:39 <lambdabot>  a + b
03:53:45 <Jaak> hmh
03:53:55 <mm_freak_work> Athas: module A.B.C would be in C.hs in the directory A/B/ relative to the source root
03:53:56 <quicksilver> Athas: module Foo.Bar.Baz defined in file Foo/Bar/Baz.hs
03:54:21 <mm_freak_work> there is a Setup.lhs and a package-name.cabal for most packages
03:54:39 <Athas> quicksilver: so using uppercase for filenames is a custom?
03:54:44 <mm_freak_work> i prefer package names in lower case, others prefer capitalized package names
03:55:02 <Athas> The standard packages are capitalised, right?
03:55:18 <mm_freak_work> apart from 'base', there is no standard package
03:56:49 <quicksilver> you are talking at cross purposes.
03:57:06 <quicksilver> Athas: the standard module hierarchy parts are initial caps, yes.
03:57:16 <quicksilver> Athas: and that is mandated by the language.
03:57:36 <quicksilver> module parts must be initial uppercase. So therefore files must be initial uppercase.
03:57:46 <blarz> http://haskell.org/haskellwiki/Real_World - hahaha
03:57:47 <lambdabot> Title: Real World - HaskellWiki
03:57:48 <quicksilver> except, perhaps, for your main file which is allowed to cheat.
03:58:40 <quicksilver> package names are indeed convenitonally lowercase but that's something orthogonal
03:58:47 <quicksilver> packages contain many modules
03:58:57 <mm_freak_work> quicksilver: i mean the package name only
04:00:38 <quicksilver> mm_freak_work: I knew what you meant, but I didn't think Athas did ;
04:00:44 <quicksilver> I was just expanding somewhat.
04:00:56 <mm_freak_work> ok =)
04:03:06 <Athas> Okay, I've just completed Euler project #1. In order to nip any coding style issues in the bud, I'd like to ask for critique on my code. Is there any preferred place to paste Haskell code?
04:03:18 <Saizan> !paste
04:03:18 <hpaste> Haskell paste bin: http://hpaste.org/
04:03:53 <Tigran``> @instances PrintfType
04:03:54 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
04:03:58 <Tigran``> @instances-importing PrintfType
04:03:59 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
04:04:06 <Tigran``> Hm.
04:04:32 <hpaste>  Athas pasted "Critique my coding style, please." at http://hpaste.org/8363
04:04:38 <Saizan> @instances-importing Text.Printf PrintfType
04:04:39 <lambdabot> (a -> r), IO a, [c]
04:04:52 <Tigran``> Ah, thanks Saizan
04:05:24 <Tigran``> Athas: Use type signatures!
04:05:29 <Saul_> Athas: Looks good to me
04:05:37 <RayNbow> Athas, foldl (+) 0 == sum?
04:06:00 <Athas> RayNbow: that could be right.
04:06:12 <Saul_> Athas: Those are both actually good points
04:06:29 <Saul_> Athas: I must say that my first piece of code was a lot worse
04:06:48 <byorgey> Athas: using type signatures is good advice -- even though you don't 'need' them, it helps a lot in debugging and thinking about your code
04:07:11 <Athas> That sounds right, most Haskell code I've seen uses type signatures.
04:07:16 <Tigran``> It can often be the case that the type inference "over-generalises" the types of your functions
04:07:29 <Tigran``> Which can lead to problems and a lot of debugging down the road
04:07:31 <Athas> It wasn't very prevalent in SML, which is the static functional language I have most experience with.
04:08:11 <byorgey> Athas: using a list comprehension is fine, but I would write  sumMultiples max = sum (filter isMultiple [0..max])
04:08:40 <byorgey> it's not necessarily 'better', just giving you an idea of what's possible
04:08:44 <Athas> Oh, so when are list comprehensions the proper choice? Is it just something you get an intuitive feel for?
04:08:57 <Athas> Apart from when they are necessary, I mean.
04:08:58 <osfameron> personal choice isn't it?
04:09:10 * osfameron doesn't like them
04:09:12 <Tigran``> List comprehensions are effectively a map and filter together
04:09:12 <byorgey> Athas: well, they are never actually 'necessary'
04:09:27 <byorgey> yeah, just personal preference and what you feel is clearer etc.
04:09:34 <Athas> I admit that I chose list comprehensions for this problem because I'm not used to them from SML or Lisp, and they seem fun. :-)
04:09:35 <Tigran``> It's essentially a notation pretty close to the mathematical notation I believe
04:09:47 <byorgey> personally I rarely use them -- I've found the more comfortable I become with Haskell the less I use them
04:10:07 <byorgey> Athas: sure, that's a fine reason =)
04:10:49 <mm_freak_work> > sum $ nub $ takeWhile (<1000) [3, 6 ..] ++ takeWhile (<1000) [5, 10 ..]
04:10:50 <lambdabot>  233168
04:11:07 <audreyt> it's much more difficult to write comprehensive comprehensions without comprehensive comprehension syntax, though.
04:11:11 <Athas> Ooh, that's an elegant solution!
04:11:16 <byorgey> audreyt: hehe
04:11:26 <mm_freak_work> Athas: not really, i don't like it
04:11:30 <mm_freak_work> but it's short in code
04:11:39 <Athas> What does nub do?
04:11:44 <RayNbow> remove duplicates
04:11:50 <mm_freak_work> > nub [1,2,2,3,1]
04:11:51 <lambdabot>  [1,2,3]
04:12:07 <maltem__> (in the most general, thus most inefficient way)
04:12:31 <RayNbow> sum [x| x <- [3..999], mod x 3 == 0 || mod x 5 == 0 ] -- this was my solution for the problem btw for Proj. Euler #1
04:13:00 <Tigran``> Hmm
04:13:02 <mm_freak_work> i'm sure that there is a much easier solution
04:13:11 <Tigran``> > nubBy (/=) [1, 2, 2, 3, 4, 4]
04:13:12 <lambdabot>  [1]
04:13:27 <mwotton> forgive a stupid question - how do i turn a Char into a Word8?
04:13:39 <quicksilver> mwotton: fromIntegral . fromEnum
04:13:41 <Deewiant> fromEnum?
04:13:43 <RayNbow> sum [3,6..999] + sum [5,10..999] - sum [15,30..999] -- recently I also wrote this solution :p
04:13:48 <quicksilver> mwotton: with standard proviso that this is a BAD THING TO DO.
04:14:10 <mwotton> quicksilver: why?
04:14:21 <quicksilver> because Char is a 32 bit type and Word8 is an 8-bit type
04:14:24 <mwotton> um. let me rephrase.
04:14:25 <mm_freak_work> RayNbow: that's a nice one!
04:14:29 <quicksilver> converting one to other is losing information
04:14:32 <byorgey> PIE ftw!
04:14:47 <mwotton> ... i did not know that. Char is what, unicode?
04:14:50 <byorgey> mmm, PIE
04:14:51 <mwotton> i always figured it was ascii
04:14:56 * mwotton feels dopey
04:15:19 * byorgey gives mwotton a lambda-shaped blueberry PIE
04:15:26 <quicksilver> mwotton: right, unicode
04:15:29 <mwotton> so if i want the literal ascii? basically, i want to split a ByteString up using 'split' and a literal char...
04:15:42 <quicksilver> mwotton: use the Char version of bytestring.
04:15:48 <quicksilver> if you wish to interpret the bytes as chars :)
04:16:07 <mwotton> i think i'm dealing only with ascii
04:16:23 <Deewiant> hmm, process-2.0 isn't on Hackage, do I need to grab a 6.8.3 RC of GHC to get it?
04:16:34 <mwotton> so fromIntegral .fromEnum is ok, right?
04:17:24 <mm_freak_work> sum $ takeWhile (<1000) $ scanl (+) 3 $ cycle [2,1,3,1,2,3,3]
04:17:29 <mm_freak_work> > sum $ takeWhile (<1000) $ scanl (+) 3 $ cycle [2,1,3,1,2,3,3]
04:17:30 <lambdabot>  233168
04:17:36 <RayNbow> mm_freak_work: I also came up with a faster sum
04:17:46 <RayNbow> so I could rewrite: sum [a,b..c] ~~> sum_arith a b c
04:18:05 <mm_freak_work> RayNbow: i've made a wheel-based solution
04:18:08 <maltem> > (3 * 333 * 334 + 5 * 199 * 200 - 15 * 66 * 67) `div` 2
04:18:10 <lambdabot>  233168
04:18:25 <RayNbow> mm_freak_work: wheel-based?
04:18:35 <byorgey> > 233168  -- the fastest and shortest solution possible!
04:18:36 <lambdabot>  233168
04:18:37 <mm_freak_work> RayNbow: yeah, similar to wheel factorization
04:18:55 <RayNbow> mm_freak_work: I'm not familiar with wheel factorization :p
04:18:58 <Deewiant> > "233168" -- so you don't have to call 'show'
04:19:00 <mm_freak_work> maltem: you're doing precalculations outside of the code
04:19:00 <lambdabot>  "233168"
04:19:15 <byorgey> mm_freak_work: so did you =)
04:19:26 <maltem> mm_freak_work: Right, you'd have to parametrise that; it was only to show the idea
04:19:31 <mm_freak_work> byorgey: true
04:19:36 <byorgey> most project euler problems require precalculations outside of the code anyway =)
04:19:42 <MarcWeber> Can you query the line number of the location where splicing in takes place talking about template-haskell?
04:20:00 <mm_freak_work> byorgey: but my precalculations go up to 15, not to 1000 ;)
04:20:13 <mm_freak_work> that's enough to generate the wheel
04:20:43 <byorgey> mm_freak_work: heh, I know =)
04:21:02 <mm_freak_work> RayNbow: the idea is based on that one:  you can check divisibility by a list of primes 'xs' by taking modulo 'product xs' and testing there
04:21:09 <byorgey> I just find it interesting that there's a fine line between a proper "solution" in Haskell and "cheating"
04:21:24 <mm_freak_work> if 'product xs' is small (15 in this case), it's faster to do lookup
04:21:44 <maltem> > let s x = x * (d * (d+1)) where d = 999 `div` x in (s 3 + s 5 - s 15) `div` 2
04:21:45 <lambdabot>  233168
04:22:03 <maltem> mm_freak_work: That's better?
04:23:34 <quicksilver> mwotton: why not use the char version of bytestingg
04:23:42 <quicksilver> mwotton: all the types will be right, you won't need to convert.
04:24:42 <mm_freak_work> maltem: yeah, i like it
04:25:27 <mm_freak_work> byorgey: cheating is precalculating the sum in a non-algebraic way, IMO
04:25:52 <maltem> of course, s 3 + s 5 - s 15 should really be (\ns -> sum (map s ns) - s (product ns)) [3,5] -- :)
04:26:26 <byorgey> mm_freak_work: oh, you mean in a way that doesn't generalize?  fair enough
04:26:29 <maltem> wait, that won't do if the list is longer than two elements
04:26:33 <Athas> What's the general opinion on using $ to avoid parentheses?
04:26:41 <Zao> Athas: Good.
04:26:42 <maltem> (bah, who cares)
04:26:46 <byorgey> Athas: it's pretty common
04:27:29 <Zao> It'd be interesting to have an IDE that highlighted the range of code that $ and () affects.
04:27:42 <Zao> That'd probably help a lot with teaching the language.
04:28:07 <Zao> Much like Codekana for C++ has vertical lines to indicate loop/conditional scopes.
04:29:03 <osfameron> this is the reason I have a love/hate thing with '$'.  It feels wrong to hide valuable contextual information from the programmer (or in my case, *me*)
04:29:19 <Deewiant> generalizing that, being able to see the first and second arguments of any operator would be cool
04:30:14 <tchakkazulu> $ = start new nesting level here, and end whenever the current nesting level ends.
04:30:28 <tchakkazulu> Basically <_<
04:30:52 <quicksilver> Zao: I have something of a phobia for the phrase IDE.
04:31:06 <Zao> quicksilver: s/IDE/language-aware editor/
04:31:06 <quicksilver> Zao: It would be good to have a code editor which highlighted operate argument range, though
04:31:21 <quicksilver> and in a similar vein, showed the nesting of layout blocks
04:31:30 <Athas> So... x : foo versus [x] ++ foo. I prefer the former, what's community consensus?
04:31:34 <mm_freak_work> Athas: i like to prevent a (b (c (d (e …)))) using ($):  a $ b $ c $ d $ e …
04:31:35 <quicksilver> I often think that gentle background colouring might be nicer.
04:31:41 <mm_freak_work> and i hate it for almost everything else
04:31:47 <Zao> Aye, I had something along those lines in mind.
04:32:05 <maltem> Athas: the former is preferred because the latter just reduces to the former
04:32:08 * quicksilver prefer a . b . c . d . e $
04:32:13 <quicksilver> for mm_freak_work's example
04:32:24 <Zao> quicksilver: When you accumulate enough intensity to have a hot pink background, you should probably break things up :)
04:32:27 <mm_freak_work> quicksilver: depends on context
04:32:38 <quicksilver> in most contexts I prefer . to $
04:32:41 <quicksilver> cos its associative
04:32:46 <quicksilver> associative is nice.
04:32:50 <mm_freak_work> true
04:34:58 <mm_freak_work> quicksilver: i don't like the high priority of (.), though
04:35:13 <mm_freak_work> that's why at many places, i prefer ($) over (.)
04:35:28 <quicksilver> nod
04:36:00 <mm_freak_work> i think, it's just that ($) is a bad symbol from typographical view
04:36:14 <osfameron> it is very loud
04:36:38 <mm_freak_work> but it's intuitive in a sense…  you can read it as: "take that, do that, do that on the result, do that on the result, …"
04:37:10 <mm_freak_work> concat $ filter f2 $ map f1 $ join …
04:37:27 <mm_freak_work> well…  makes no sense to intermix concat and join, though =)
04:37:43 <Zao> concat.filter f2.map f1.join $ xs
04:38:08 <Zao> -- that's a bit unreadable though :)
04:38:20 <Saizan> put spaces
04:38:35 <maltem> The only really ugly thing about a . b . c . d $ x is that ($) being the outermost operator isn't obvious at first glance, I think
04:39:35 <osfameron> how would I prettify:  filter (not .(liftM2 (||) isSpace (`elem` ".:"))) "hello. world:"   ?
04:40:05 <osfameron> (being an answer to the homework question from last night)
04:40:32 <maltem> you could do "let ($$) = flip ($) in x $ a . b . c . d" to remedy that, but then that's reverse-in-reverse notation
04:41:08 <maltem> osfameron: one pair of () is superfluous
04:41:54 <Saul_> I usually write (a . b . c . d) x
04:42:07 <osfameron> maltem: oh so it is.  Didn't expect that
04:42:34 <maltem> osfameron: Not sure whether that was the point of the exercise, though :)
04:42:53 <maltem> Saul_: I sometimes use that, too
04:42:56 <AtnNn> osfameron: I usually write code like filter wordChar "hello. world:" where wordChar c = isSpace c || elem c ".:"
04:43:24 <osfameron> AtnNn: oh yes, that would be cleaner
04:43:27 <swiert> Ooh. ICFP's list of accepted papers is online.
04:46:06 <quicksilver> swiert: where?
04:46:14 <pejo> swiert, congrats!
04:46:24 <swiert> quicksilver: http://www.icfpconference.org/icfp2008/accepted/accepted.html
04:46:24 <lambdabot> Title: ICFP 2008 Accepted Submissions
04:46:31 <swiert> pejo: Thanks!
04:50:07 <swiert> Quite a lot of HMF papers.
04:55:09 <quicksilver> grats, swiert, chillix, malcolmw, augustss
04:55:17 <quicksilver> not a bad result for one IRC channel :)
04:55:47 <quicksilver> looks like conal's was rejected though :(
04:56:07 <swiert> Yeah - that's a shame.
04:56:43 <swiert> quicksilver: let's not forget kosmikus and Heffalump.
04:58:49 <Zao> When will the papers be available? After the conference?
04:59:20 <swiert> Zao: a lot are already available online.
05:01:12 <pejo> quicksilver, getting rejected when 70+% of the submitted papers do doesn't say that much though, surely they must reject some good papers.
05:04:55 <Zao> Hrm, haskell.org awol for anyone else?
05:05:07 <quicksilver> swiert: I don't know kosmikus's real name.
05:05:20 <quicksilver> I have no defence for Heffalump though. Poor eyesight.
05:05:31 <quicksilver> pejo: yes, this is a godo point.
05:05:35 <sw17ch> Zao, appears so...
05:06:36 <mauke> Zao: works here
05:06:59 <Zao> Ah, works now.
05:07:00 <sw17ch> Zao, it's back now
05:08:42 <Saul_> I don't know the real names of most of the people here
05:09:28 <RayNbow> Saul_, type /who #haskell and start memorizing :p
05:10:43 <kosmikus> quicksilver: I'm co-author of the NixOS paper. That narrows it down to two :)
05:10:45 <Saul_> Hmmz I didn't have enough scrollback lines to read the entire list :)
05:11:10 <Saul_> Andres?
05:11:23 <mauke> Löh
05:12:32 <mm_freak_work> who "#haskell" >>= print . unwords . lines
05:14:28 <mauke> is chillix manuel chakravarty?
05:14:33 <Saul_> kosmikus: You don't actually have your name in the /who list, so who are you?
05:14:43 <quicksilver> mauke: yes
05:15:10 <kosmikus> Saul_: your guess was correct
05:15:15 <Saul_> Oh cool
05:15:25 <Saul_> I did AFP last block
05:15:45 <Saul_> Now you guess who I am :P
05:16:38 <Gilly> If i run mapM on some list is this done lazily?
05:17:37 <mauke> depends
05:17:47 <quicksilver> in general though the answer is no.
05:17:48 <Saizan> it depends a lot on the monad
05:17:51 <Gilly> IO monad.
05:17:58 <quicksilver> the effects must be complete before the next effect can take place
05:18:02 <quicksilver> (the effect after the mapM)
05:18:04 <mauke> Gilly: no
05:18:18 <quicksilver> often the sequencing of effects will force the computations to a great extent.
05:18:21 <quicksilver> not always, though.
05:18:39 <Gilly> ok, damn - if i convert io arrays to ordinary arrays is it an expensive operation? (in terms of time)
05:18:46 <Gilly> i need laziness here :P
05:18:50 <quicksilver> no. It's a simple copy.
05:18:55 <quicksilver> Copying memory is not expensive.
05:18:59 <quicksilver> computers are good at that :)
05:19:10 <quicksilver> if you use unsafeFreeze the meory doesn't even get copied.
05:19:44 <mm_freak_work> doesn't seem to be lazy
05:19:46 <Gilly> okies, thanks... going to look at it
05:19:52 <kosmikus> Saul_: difficult to guess. but great to see you here ;)
05:19:53 <mm_freak_work> > mapM (return :: a -> IO a) (iterate (+1) 0) >>= return . take 100
05:19:53 <mm_freak_work> ^CInterrupted.
05:19:57 <lambdabot>  <IO [Integer]>
05:20:12 <Saul_> kosmikus: I'm Paul Visschers, the guy from Eindhoven
05:21:14 <kosmikus> Saul_: ok.
05:28:06 <FordCortina> does anybody know at what point Agda2 support haskell-like @-patterns?
05:28:27 <FordCortina> like @(FooConstructor x)
05:28:47 <FordCortina> supported*
05:28:51 <swiert> FordCortina: I think Agda used to, but it's been dropped for some reason IIRC.
05:29:12 <swiert> It's something I'm quite happy to live without, really.
05:29:42 <FordCortina> swiert: would you use case statements instead then?
05:29:57 <SamB> there is no case
05:30:04 <quicksilver> it's nice to be able to re-use a pristine value without rebuilding it
05:30:12 <Jaak> with to the resque
05:30:12 <FordCortina> (sry i dont know much agda)
05:30:18 <swiert> FordCortina: No, just pattern match.
05:30:32 <swiert> And rebuild the results if I actually wanted an @-pattern.
05:30:39 <Jaak> c*
05:30:41 <mm_freak_work> @ is ugly in haskell, IMO…  i wouldn't use it, unless the construction is very long
05:31:15 <ddarius> mm_freak_work: What's ugly about @?
05:31:21 <quicksilver> it seems annoying (although not *very* important) to build new heap cells
05:31:32 <quicksilver> when there is an old one which represents precisely what you want.
05:31:36 <mm_freak_work> ddarius: i prefer to write (x:xs) instead of some name, mostly
05:31:58 <mm_freak_work> quicksilver: GHC seems to optimize that away
05:32:08 <FordCortina> hmm.... im trying to work out how @-patterns could be eleminated without case in Haskell....
05:32:20 <ddarius> quicksilver: It can be important although there are alternate ways to deal with those cases.
05:32:43 <mauke> I'd like extended @ patterns
05:32:55 <mauke> I want to use them in the middle of expressions to bind variables
05:33:36 <mauke> print ones@(1 : ones)
05:33:43 <SamB> eww
05:33:58 <BONUS> oh my
05:34:00 <ddarius> mauke: It's called fix.
05:34:01 <FordCortina> personally i use at @ when i want partition the behaviour of a function, but i dont want to "unwind" the value ive recieved? what else do you do in that circumstance?
05:34:10 <mauke> ddarius: or let
05:34:20 <mm_freak_work> or iterate
05:34:24 <mm_freak_work> or …
05:34:29 <mauke> but it seems like a cool extension
05:34:55 <mauke> I could also use it to write recursive types
05:34:57 <ddarius> It's entirely redundant.
05:35:00 <sw17ch> fix still confuses me
05:35:06 <mauke> ddarius: most of haskell's syntax is
05:35:58 <quicksilver> mm_freak_work: I don't think it does, no.
05:36:03 <FordCortina> @hoogle fix
05:36:03 <lambdabot> Data.Function.fix :: (a -> a) -> a
05:36:03 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
05:36:03 <lambdabot> Control.Monad.Fix :: module
05:36:13 <FordCortina> @src fix
05:36:13 <lambdabot> fix f = let x = f x in x
05:36:14 * SamB_XP suspects that @ confused Agda
05:36:46 <mm_freak_work> quicksilver: it gives the same performance at least for reconstructing a list cons, but i haven't looked into the assembly code
05:37:13 <SamB_XP> mm_freak: look at the core
05:39:36 <ddarius> mm_freak_work: It's very unlikely that GHC does this as either adding or removing sharing can have significant consequences.
05:40:02 <sw17ch> :t fix fix
05:40:06 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
05:40:06 <lambdabot>     Probable cause: `fix' is applied to too many arguments
05:40:06 <lambdabot>     In the first argument of `fix', namely `fix'
05:40:39 <mm_freak_work> ddarius: maybe it does for the obvious cases
05:41:04 <mm_freak_work> sw17ch: fix f = f (f (f (f (f …))))
05:41:16 <mm_freak_work> > fix (1:)
05:41:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:41:51 <sw17ch> mm_freak_work, i've figured this much out... but i am a little confused about where the first value gets fed into fix
05:42:22 <mm_freak_work> sw17ch: somewhere at infinity
05:42:43 <sw17ch> mm_freak_work, how does it know when/if to terminate? is it when x is finally evaluated?
05:42:53 <mauke> sw17ch: there is no first value
05:43:21 <mauke> it uses a bit of time travel to feed the function its own return value
05:43:23 <sw17ch> mauke, i keep thinking the output of the first call feeds back into itself
05:43:30 <mauke> :-)
05:43:31 <mm_freak_work> sw17ch: if the 'frist value' is required to calculate the result of 'fix f', then the result is bottom
05:44:07 <mauke> it's not a loop, however, so it doesn't need a stopping condition
05:44:10 <sw17ch> mm_freak_work, what are some functions we can fall fix on which do terminate?
05:44:22 <sw17ch> s/fall/call/g
05:44:23 <mauke> > fix (const 42)
05:44:25 <lambdabot>  42
05:44:40 <FordCortina> hmm
05:44:42 <mm_freak_work> sw17ch: see mauke or lazily build structures
05:44:52 <mm_freak_work> s/build/built/
05:45:03 <mauke> > fix (\self n -> if n < 2 then 1 else n * self (n - 1)) 5
05:45:04 <lambdabot>  120
05:45:13 <FordCortina> so basically you can eliminate @ patterns by changing the order of the function definitions?
05:46:37 <sw17ch> > fix (\n self -> if n < 2 then 1 else n * self (n - 1)) 5
05:46:38 <lambdabot>      Occurs check: cannot construct the infinite type:
05:46:38 <lambdabot>       t = (t -> t1) ->...
05:46:44 <sw17ch> ah, thought so.. :)
05:46:58 <sw17ch> alright, i think i'm closer to getting it now :) ty
05:47:42 <mmorrow> @ patterns are awesome
05:48:29 <mauke> f_lambda :: a@(a -> a)
05:48:35 <sw17ch> :t const
05:48:37 <lambdabot> forall a b. a -> b -> a
05:49:30 <mmorrow> > (\a@(Just _, b@(x:_)) -> (x,(a,b))) (Just (), [0..3])
05:49:32 <lambdabot>  (0,((Just (),[0,1,2,3]),[0,1,2,3]))
05:50:01 <mauke> > let x@y@z = 'f' in [x,y,z]
05:50:03 <lambdabot>  "fff"
05:50:20 <mmorrow> heh
05:50:51 <mauke> m-multitrack drifting!
05:52:44 <ddarius> > fix f :: Expr
05:52:58 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
05:55:41 <Jaak> @instances MonadFix
05:55:42 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:56:12 <Jaak> @src MonadFix IO
05:56:12 <lambdabot> Source not found. Sorry.
06:23:55 <bens> whois hukolele
06:24:37 <mm_freak_work> bens: try /whois
06:25:02 <bens> yeah, slipped there...
06:26:34 <Snark> re
06:26:55 <DRMacIver> Are there plans to package cabal install with future versions of ghc?
06:26:56 <Snark> grrrmm... I tried to use "forall" but the interpreter shouts at me...
06:27:27 <dcoutts_> DRMacIver: as part of a platform release, yes. ghc releases themselves are getting smaller not bigger.
06:27:30 <DRMacIver> ok
06:27:55 <quicksilver> Snark: what are you using it for?
06:28:07 <DRMacIver> It's kindof a pain to get it set up currently. :)
06:28:16 <mxc> quick question, is Network.Socket.send threadsafe, or should I wrap it up snugly in an MVar?
06:28:23 <quicksilver> Snark: it's switched on by -XScopedTypeInstances and -XRankNTypes, I imagine, probably others.
06:28:28 <Snark> Not a constructor: `forall'
06:28:29 <dcoutts_> DRMacIver: because of the two dependencies zlib and HTTP?
06:28:41 <Snark> well, I don't use it yet, I was reading something about it and trying the examples
06:28:44 <DRMacIver> Basically.
06:28:48 <DRMacIver> And cabal itself
06:28:52 <quicksilver> mxc: if you only call it in one thread it's (obviously) fine
06:29:04 <mxc> um
06:29:13 <quicksilver> mxc: that's often a sane approach, to consider a given handle/socket "owned" by a particular thread.
06:29:17 <quicksilver> then you don't get into troule.
06:29:18 <DRMacIver> I mean, it's not that much of a pain if you're already familiar with haskell build systems
06:29:29 <mxc> true
06:29:43 <mxc> could always put messages themselves in the MVar
06:29:48 <Snark> quicksilver, will that get me into trouble?
06:29:52 <DRMacIver> But it would be nice to say to people "I've written a cool program. Just install ghc and you can use cabal to grab it" and have it easy for them to do without any prior Haskell knowledge.
06:30:26 <dcoutts_> DRMacIver: sure, that's the idea of doing platform releases, that we include all the stuff you need, not just ghc but tools like haddock, cabal-install, etc
06:30:32 <DRMacIver> ok
06:30:45 <DRMacIver> (And purely selfishly it would be nice if it worked out of the box on new computers when I set things up :) )
06:30:52 <dcoutts_> right
06:30:57 <quicksilver> mxc: messages probably go into a chan most naturally ;)
06:31:04 <dcoutts_> DRMacIver: that's where we want to get to
06:31:12 <quicksilver> Snark: I was talking to mxc in that case.
06:31:16 <Snark> oh
06:31:19 <Snark> good :-)
06:31:22 <mxc> :)
06:31:28 <quicksilver> Snark: the answer to your question is "you switch on whichever extension you are trying to use"
06:31:35 <quicksilver> tell us what you're trying to do and we can help.
06:31:44 <quicksilver> -XExistentialTypes is another option.
06:31:48 <Snark>  -XExistentialQuantification is the one
06:31:53 <dcoutts_> DRMacIver: we're currently building the infrastructure needed to do that kind of high quality platform releases without quickly burning through release managers :-)
06:32:01 <Snark> quicksilver, I would need to make an heterogeneous list
06:32:23 <quicksilver> Fact: 99% of #haskell people who think they want a heterogeneous list actually don't.
06:32:33 <quicksilver> but yes, you want to turn existentials on
06:32:37 <quicksilver> at which point forall is a keyword.
06:32:45 <DRMacIver> dcoutts_: Fair enough. :)
06:32:57 <Snark> quicksilver, how can I avoid heterogeneous lists ?
06:33:04 <mxc> quicksilver - are people actually clamoring for heterogeneous lists?
06:33:08 <quicksilver> Snark: Easy. Just don't use them.
06:33:25 <quicksilver> mxc: Often people ask for them not realising there is an easier solution.
06:33:34 <quicksilver> Snark: seriously, what are you trying to do?
06:33:35 <mxc> dont variant types basically solve that problem?
06:33:36 <Snark> quicksilver, well, what other solutions are there ?
06:33:40 <opqdonut> Snark: use a custom datatype with multiple constructors instead
06:33:44 <mxc> or polymorphic, forget which is which
06:33:46 <quicksilver> Snark: that depends what your problem is!
06:33:50 <Snark> I'm trying to do financial simulations
06:34:02 <dcoutts_> DRMacIver: without pretty decent automation it becomes far too big a job to coordinate releases. A Haskell platform release is on a comparable scale to a GNOME release.
06:34:06 <Snark> I have a basic setup where I run a "state" through time
06:34:24 <mxc> data Heteroflexble = A of Int | B of String
06:34:26 <Snark> but I'd need to be able to make that state have several "accounts"
06:35:54 <MarcWeber> Snark: Can't you just put a description of your heterogenious list?
06:36:13 <Snark> MarcWeber, I don't have it yet...
06:36:36 <quicksilver> data Account = ThisType .. | ThatType .. | TOtherType ..
06:36:39 <quicksilver> [Account]
06:36:43 <Snark> I will need several accounts, and 'ask' them for investment opportunities
06:36:50 <quicksilver> is the normal way to do a 'heterogenous' list
06:37:51 <Snark> I fear I'll end up writing mostly the same code again and again if I do like this
06:37:56 <MarcWeber> Snark: So you have something like [ Account ]. How would you describe an account?
06:38:16 <quicksilver> Until you start writing some code, your fears are unfounded.
06:38:25 <Snark> eh
06:38:27 <quicksilver> You're searching for a solution to a problem you don't know that you have ;)
06:38:44 <quicksilver> The risk is you will find a solution to a problem which you don't, in fact, have.
06:39:14 <Snark> I did write mostly the same code in eiffel, lisaac and python, so I have a good idea what's ahead
06:39:28 <Snark> (though haskell is the first pure functional language)
06:39:32 <DRMacIver> dcoutts_: One of the problems with success I suppose. :)
06:39:39 <quicksilver> well if you want a meaningful answer from us, you'll need to explain a bit more of a problem to us.
06:39:44 <dcoutts_> DRMacIver: right :-)
06:39:48 <quicksilver> What do you think is wrong with the [Account] version?
06:39:55 <MarcWeber> Snark: So you don't want to tell us more about the design?
06:40:10 <Snark> MarcWeber, well, the design is that I have a bunch of a -> a functions
06:40:25 <MarcWeber> Snark does'nt have a problem at all because he already has a solution in his head, in python, in eiffel, in .. :-)
06:40:35 <MarcWeber> I guess a = Account
06:40:38 <Snark> begin_of_month, end_of_month, begin_of_year and end_of_year turn a Situation into another Situation
06:41:04 <MarcWeber> Situation = the state you've talked about above?
06:41:05 <mm_freak_work> data Account = forall a. Business a => Account a
06:41:10 <Snark> MarcWeber, yes
06:41:26 <pejo> Snark, how can you have many a -> a functions?
06:41:49 <Snark> pejo, I name them differently...
06:42:01 <Snark> begin_of_month, end_of_month, begin_of_year and end_of_year all have type Situation -> Situation
06:42:41 <MarcWeber> Snark: It's time to talk about that Situation = state = a ?
06:42:41 <Snark> in fact, I made a Temporel class type of which Situation is an instance
06:42:47 <pejo> Oh, that's a much more specific type, I can guess how you can have many different of those.
06:42:58 <Snark> MarcWeber, yes, I'm coming to it... busy with baby on the knees!
06:43:51 <Snark> I have a multiple :: Num t => (b -> b) -> t -> (b -> b) which applies a function repeatedly
06:44:09 <Snark> my main loop is : simulation = multiple annee 15
06:44:22 <Snark> where : annee = debut_d_annee . multiple mois 12 . fin_d_annee
06:44:29 <Snark> and mois = debut_de_mois . virement_pret . revenus . fin_de_mois
06:45:05 <mauke> wait, what does multiple annee (sqrt (-1)) do?
06:45:11 <Snark> virement_pret is a function which takes money from the Current account in Situation, and uses it for the Pret
06:45:31 <Snark> mauke, eh... no idea : the signature isn't my doing afaict
06:45:50 <quicksilver> runs for ever, I imagine.
06:46:02 <mauke> enjoy your complex numbers
06:46:12 <Snark> multiple f 1 = f
06:46:12 <Snark> multiple f n = f . multiple f (n-1)
06:47:05 <DRMacIver> Bah. I really hate trying to install anything at all under windows.
06:47:21 <mauke> :t \f n -> foldr (.) id (replicate n f)
06:47:23 <quicksilver> s/install anything/do/;
06:47:24 <lambdabot> forall a. (a -> a) -> Int -> a -> a
06:47:41 <quicksilver> hmm
06:47:45 <quicksilver> s/install/do/;
06:47:47 <quicksilver> better.
06:47:53 <mm_freak_work> DRMacIver: search google, go to the website, download the demo version, search google, find a crack, download the crack, install the demo version, apply the crack…  what can be easier than that?
06:48:24 <MarcWeber> Snark: Why don't you copy paste the whole module then ? It's not about how to split a year in month.. it's about how to represent the state ? You didn't give me a nice answer to that
06:48:26 <Snark> I have to fetch the kids at school :-/
06:48:28 <DRMacIver> mm_freak_work: I'm actually talking about open source stuff for windows. :)
06:48:42 <Snark> data Situation = Situation { courant:: Courant,
06:48:43 <Snark>                              pret:: Pret,
06:48:43 <Snark>                              trace:: String -> String }
06:48:48 <Snark> MarcWeber, that's it
06:49:02 <Snark> Courant is the Current I meant
06:49:05 <Snark> Pret means Loan
06:50:00 <Snark> my goal is to add a list of investment opportunities in there (of various type)
06:50:03 <mm_freak_work> DRMacIver: that's a special case:  search google, go to the visual studio website, download the demo version, search google, find a crack for visual studio, download the crack, install the demo version, apply the crack, find that visual studio can't build your source without a lot of patches
06:50:20 <DRMacIver> Heh
06:50:35 <Snark> some type which allows asking for an investment opportunity, sort the list on expected result, and "apply" the best one
06:50:38 <MarcWeber> Snark: In which way do they differ?
06:50:46 <MarcWeber> What is an investment? Just a currency value?
06:50:51 * Baughn notes that the VS toolchain is already free. You just pay for the IDE, which you don't /need/ to build things
06:51:10 <DRMacIver> This hsould all build under MinGW anyway.
06:51:12 <Snark> MarcWeber, no, it's different "accounts" with different interest rates
06:51:21 <DRMacIver> And seems to have binary installers.
06:51:35 <Snark> and different max account balance, life expectancy, etc
06:51:35 <DRMacIver> It's the fact that it takes more than "apt-get install libcurl" that annoys me.
06:51:38 <quicksilver> Snark: what definitely soundsl ike a case for data Opportunity = FixedRate | VariableRate | Blah ...
06:52:12 <Snark> there are several FixedRate...
06:52:25 <MarcWeber> Snark [(Account, ItnerestRate)] and interest rate just some number?
06:52:54 <quicksilver> Well the FixedRate would be more complex than I just sugegsted
06:53:15 <Snark> MarcWeber, definitely not enough, as I said each has a different (legally defined) minimal balance, maximal balance, interest rate, etc
06:53:15 <quicksilver> FixedRate { name :: String, rate :: Double, lengthInYears :: Int, .... }
06:53:19 <quicksilver> I was simplifying.
06:54:41 <MarcWeber> Snark In which way do they differ?
06:54:47 <MarcWeber> If they don't at all you can use
06:55:07 <Snark> quicksilver, that is the reason why I think having a type class would make more sense... and then heterogeneous lists
06:55:25 <quicksilver> why?
06:55:30 <quicksilver> why do you think that is different?
06:55:31 <MarcWeber> data ExtraAccount = ExtraAccount ExtraAccountType [the list of items ..]
06:55:36 <Snark> MarcWeber, well, some have common points in the organization, with different values, but other have different organizations too
06:55:43 <Snark> I have to go, sorry :-(
06:55:45 <quicksilver> ;)
06:55:58 <quicksilver> the main difference between classes and a fixed type is that classes are open
06:55:59 <MarcWeber> Snark: Hope your baby is still fine
06:56:02 <quicksilver> and fixed types are closed.
06:56:11 <quicksilver> However, fixed types are easier to dcode for and reason about
06:56:19 <quicksilver> so they're preferred unless you need openness
07:01:50 <Botje> @pl \l -> (l!!0) == (l!!1)
07:01:51 <lambdabot> liftM2 (==) (!! 0) (!! 1)
07:01:52 <Botje> excellent :)
07:02:44 <osfameron> @pl \(a:b:rest) -> a == b
07:02:45 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (==) . head) tail
07:02:45 <vixey> @pl \(x:y:_) -> x==y
07:02:46 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (==) . head) tail
07:02:54 <vixey> :)
07:02:57 <osfameron> heh
07:03:03 <vixey> we are the borg
07:03:39 <osfameron> interesting how the code comes out so differently
07:03:41 <mauke> :t liftM2 (==) head (head . tail)
07:03:42 <lambdabot> forall a. (Eq a) => [a] -> Bool
07:04:36 <vixey> osfameron: "differently"? O_o
07:04:47 <vixey> we wrote the exact same thing!
07:04:52 <osfameron> I mean the original !!0 !!1 version and the pattern match one
07:05:35 <quicksilver> I would probably write \(a:b:_) -> a == b
07:08:04 <Athas> Is there a standard name for foldr (++) []?
07:08:21 <swiert> Athas: concat?
07:08:33 <mauke> @src concat
07:08:33 <lambdabot> concat = foldr (++) []
07:08:44 <mauke> @hoogle [[a]] -> [a]
07:08:46 <Athas> Yes, thanks.
07:08:59 <Athas> I was looking for "flatten" or something.
07:09:00 <lambdabot> thread killed
07:09:08 <mauke> @hoogle [[a]] -> [a]
07:09:08 <lambdabot> Prelude.concat :: [[a]] -> [a]
07:09:09 <lambdabot> Data.List.concat :: [[a]] -> [a]
07:09:09 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
07:11:35 <Baughn> What machine is LB running on? code.haskell.org?
07:11:42 <quicksilver> I believe so.
07:12:09 <Baughn> How would I go about getting an account on that machine so I can figure out what's making it so unreliable lately?
07:12:30 <quicksilver> the machine is overloaded
07:12:33 <quicksilver> either CPU or memory
07:12:37 <quicksilver> or maybe both?
07:13:02 <Baughn> That would only do anything if it's actually running /out/ of memory, invoking the OOM killer
07:14:00 <Saizan> there's a lot of runplugs <defunct>, that's probably not good
07:14:02 <Baughn> ..does it even run linux? IIRC, the other OSs have pretty much settled on crashing as the correct response to an OOM condition
07:14:51 <Baughn> Definitely not, but it has to be environmental
07:17:07 <hpaste>  mm_freak pasted "List of powers of two?" at http://hpaste.org/8365
07:19:04 <dcoutts_> Saizan, Baughn: lambdabot + runplugs is using 49% of memory on community.h.o, apache another 30% leaving only 20% for everything else including the kernel
07:19:19 <dcoutts_> it's only got 600Mb total
07:19:34 <Botje> that's a lot of ram
07:20:04 <dcoutts_> lambdabot itself is using 175
07:20:24 <dcoutts_> and 5 instances of runplugs are using another 17m each
07:20:41 <quicksilver> those ones are presumably not defunct?
07:20:49 <dcoutts_> indeed, not defunct
07:21:01 <quicksilver> sounds like when it terminates (exceeds its time limit)
07:21:10 <quicksilver> it's not *actually* killing the process?
07:21:13 <quicksilver> at least, not successfully.
07:21:25 <quicksilver> or maybe it does mostly but not all the tim.
07:21:31 <dcoutts_> runplugs is not terminating, if it were it'd be defunct
07:21:34 <dcoutts_> and take no memory
07:21:44 <dcoutts_> at least, not always terminating
07:21:46 <Zao> > sum [0..]
07:21:50 <lambdabot>  out of memory (requested 1048576 bytes)
07:22:00 <quicksilver> well runplugs is supposed to be killed by the main LB ?
07:22:05 <quicksilver> if it goes over 3 seconds?
07:22:19 <quicksilver> my suggestion was that killing part isn't working.
07:22:21 <dcoutts_> these all have <1 sec runtime
07:22:27 <dcoutts_> cpu time that is
07:22:37 <quicksilver> or is there another level of indirection? does runplugs launch subprocesses of its own
07:22:58 <dcoutts_> these processes are not using cpu time, they're blocked on something
07:23:02 * quicksilver is poorly placed to do more than speculate, he doesn't know enough about how it works.
07:23:10 <quicksilver> dcoutts_: they are wasting swap though.
07:23:24 <quicksilver> and maybe even real memory (how much swap does it have / it is using?)
07:23:37 <Saizan> there's 0 swap
07:23:37 <Zao> dcoutts_: Can you strace them?
07:23:55 <quicksilver> Ouch. Is there a good reason why there is no swap?
07:24:10 <quicksilver> typically disk space is cheap and 1-2G of swap is sensible choice.
07:25:05 <Saizan> mmh, probably because it's a virtual machine?
07:25:27 <dcoutts_> Zao: apparently nothing:
07:25:28 <dcoutts_> Process 23562 attached - interrupt to quit
07:25:28 <dcoutts_> futex(0x8ca86d0, FUTEX_WAIT, 13, NULL
07:25:34 <quicksilver> virtual machines can have swap.
07:26:30 <byorgey> mm_freak_work: nice, I like it
07:27:01 <Saizan> however gwern has rewritten the "run haskell in a sandbox" part in mueval on top of ghc-api
07:28:37 <vixey> has anyone started writing the next lambdabot?
07:31:01 <quicksilver> well mauke has a different bot design
07:31:08 <quicksilver> which doesn't attempt to do haskell evaluation at all
07:31:23 <quicksilver> on the other hand, as Saizan says, gwern is trying to rewrite the "safe evaluation" as mueval
07:31:35 <quicksilver> either might be useful
07:31:43 <dcoutts_> Igloo: why do we run smbd and snmpd on community.h.o?
07:32:09 <Igloo> snmpd is probably for mrtg
07:32:19 --- mode: Igloo set -o Igloo
07:32:33 <Igloo> smbd I don't think there's a good reason for
07:32:51 <Baughn> Why is LB so large? It's just using 90m here
07:33:07 <Igloo> snmpd can presumably be firewalled to localhost only
07:33:08 <vixey> It sucks how I can't redefine Monad []
07:33:12 <vixey> having to use a newtype
07:33:23 <dcoutts_> Igloo: no I was wondering from a memory consumption pov
07:33:40 <Igloo> Oh, is memory use a problem?
07:33:41 <dcoutts_> Igloo: and can we add some swap? that'd alleviate the lambdabot bugs for a bit
07:33:47 <mapreduce> > foldr (||) True (repeat True)
07:34:00 <dcoutts_> Igloo: lambdabot + runplugs pushes the machine into OOM state regularly
07:34:03 <lambdabot>  thread killed
07:34:21 <mapreduce> Anyway, the above gives True on my machine.  How does foldr start from the end of an infinite list?
07:34:37 <Igloo> dcoutts_: Is that because of bugs in lambdabot, or just a lack of memory?
07:34:39 <dcoutts_> mapreduce: it doesn't, it starts at the beginning
07:34:45 <mapreduce> hmm.
07:34:49 <dcoutts_> Igloo: it's because of lambdabot
07:34:52 <Baughn> > foldr (||) x (repeat x)
07:34:57 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
07:35:09 <Baughn> > foldr f x (repeat x)
07:35:09 <dcoutts_> Igloo: it ends up using half the ram, it plus the processes it spawns
07:35:14 <lambdabot>  f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f...
07:35:28 <Igloo> dcoutts_: But is it because lambdabot is leaking memory, or using more than it ought to, or is it just that lambdabot really needs that much RAM?
07:35:36 <Deewiant> > foldr (||) True (repeat False)
07:35:37 <Baughn> mapreduce: Lazy evaluation. Outside-in, see
07:35:44 <Deewiant> > foldl (||) True (repeat False)
07:35:51 <lambdabot>  thread killed
07:35:57 <lambdabot> Terminated
07:36:04 <mm_freak_work> byorgey: what?
07:36:13 <quicksilver> Igloo: there appears to be some issue with old runplugs subprocesses not being killed.
07:36:18 <Baughn> dcoutts_: Hm. Set stricter memory limits on runplugs, with the appropriate RTS options?
07:36:21 <byorgey> mm_freak_work: your paste re: powers of two
07:36:33 <quicksilver> Igloo: I don't think any of the people here knows what the problem exactly is.
07:36:45 <mapreduce> > foldr (/) [1, 2] 3
07:36:46 <lambdabot>        add an instance declaration for (Num [[t]], Fractional [t])
07:36:53 <mapreduce> How do I make this work?
07:36:56 <dcoutts_> Igloo: it leaks itself (starts at ~17Mb, currently up to 175Mb) and to make things worse it does not always kill off runplugs when it's done so we get half a dozen of those hanging around using no cpu time but using ~17Mb each.
07:37:11 <quicksilver> Igloo: as a presumably unrelated problem, the main lambdabot appears to use an unreasonable amount of memory.
07:37:12 <Igloo> quicksilver, dcoutts_: OK, so in that case it sounds like (a) the problems should be fixed rather than worked around, and (b) even if we do work around it, we'll still run out of memory a little while later anyway
07:37:16 <dcoutts_> Igloo: and since we have no swap, each of the runplugs is taking real memory
07:37:18 <mapreduce> (/) is the only thing I can think of that easily shows the order of foldr.
07:37:20 <Botje> mapreduce: you swapped the last two arguments
07:37:26 <mm_freak_work> byorgey: ah ok, that wasn't actually meant for this channel…  it was for a usenet post =)
07:37:28 <mapreduce> heh
07:37:35 <byorgey> oh, hehe
07:37:54 <quicksilver> Igloo: swap means we don't have to care so much about orphaned blocked runplugs
07:38:03 <quicksilver> Igloo: and it makes the system more robust to low memory conditions.
07:38:04 <Baughn> mapreduce: / is strict, though. Using a strict function with foldr is a bad idea, since it's not tail-recursive
07:38:10 <Igloo> quicksilver: Yeah, so it'll never get fixed
07:38:28 <Baughn> mapreduce: It'll build up a chain of thunks from the entire list before getting any answers
07:38:30 <dcoutts_> Igloo: question is how do we put pressure on the lambdabot owners to fix it so it stops clobbering the community server.
07:38:30 <Igloo> Is our real memory actually real memory, given it's a virtual machine?
07:38:48 <dcoutts_> Igloo: well we only have 600Mb of it.
07:39:07 <dcoutts_> Igloo: so it doesn't matter to us if that's backed by real or virtual memory.
07:39:08 <mapreduce> Baughn: Could something like foldr be parallelised, or is that only for foldl?
07:39:11 <Igloo> dcoutts_: If it's causing a problem then either it needs to be fixed or we'll stop running it
07:39:17 <quicksilver> Igloo: well, I think that's a harsh line to take. The community server has other jobs and they don't deserve to suffer for lambdabot's sins.
07:39:38 <quicksilver> Igloo: furthermore it is or was generally said about linux that it's not designed to run without swap.
07:39:47 <quicksilver> It's a VM operating system, it expects swap to run efficiently.
07:40:10 <Baughn> mapreduce: It could not. The way fold is defined, data is explicitly chained through the function; without the optimizer doing naughty peeking at the function definition, it has no way of knowing that anything can be done in parallel.
07:40:16 <quicksilver> the OOM killer is notoriously inaccurate in its attempts to kill the genuinely guilty process, too.
07:40:20 <dcoutts_> Igloo: then lets ask Cale and dons et al to move lambdabot back to its previous host until the memory issue is brought under control.
07:40:46 <dcoutts_> Igloo: though we probably could do with having some swap
07:40:52 <Baughn> mapreduce: There are certainly fold variants that do things in parallel (like.. map/reduce from google), but those work entirely differently
07:41:11 <mapreduce> @check \x y z -> foldl (/) x [y, z] == foldr (/) x [y, z]
07:41:26 <Igloo> quicksilver: That's because it wants to cache disk, isn't it? But isn't there something beneath us doing its own caching?
07:41:26 <lambdabot>  thread killed
07:41:47 * Igloo doesn't know the details of how these things work
07:42:06 <Igloo> The Virtual Host people set it up without swap, though, so presumably they think that that's the best way to go
07:42:10 <quicksilver> Igloo: there might be. I don't know. It depends which virtualisation layer as far as I know.
07:42:14 <Baughn> Igloo: Depends on the exact variety of virtual machine. If it's something like vmware then, yes, that's how it works
07:42:20 <dcoutts_> Igloo: but it lets programs that are rarely running to not count towards our 600M quota
07:42:31 <Baughn> Igloo: Though I do believe vmware likes to lock client memory into ram - no swapping
07:42:43 <quicksilver> Igloo: but 600M *including total virtual memory* is an incredibly low figure for a modern server
07:42:45 <Igloo> dcoutts_: But if we don't actually have 600M of real memory then that's irrelevant
07:42:45 <dcoutts_> Igloo: ah, well if they set it up that way then that's a different issue. We should perhaps enquire.
07:42:58 <dcoutts_> Igloo: but we really do have a 600M max quota
07:43:04 <Snark> MarcWeber, quicksilver I'm back and I thought a little : the main difference I see between using type classes vs an union, is that with type classes, all code about a specific account type will be kept together but all code for features (like investment propositions) will be spread, while for a union all code for a specific feature will be kept together, but the code for a specific account will be spread
07:43:12 <quicksilver> presumably the machine has disk space?
07:43:18 <dcoutts_> Igloo: there's no way for the machine to use more than it has been given
07:43:21 <quicksilver> Snark: yes, I agree. I find that is often nicer.
07:43:28 <Snark> now that I have thought things through more, I'm not sure either solution will do
07:43:33 <quicksilver> if the machine has disk space you can add a swap file yourself.
07:43:39 <dcoutts_> right
07:43:39 <Igloo> quicksilver: But at least 1/3 of that is being taken up by lamdabot leaks, right? So if that's fixed then we have loads free
07:43:41 <quicksilver> just mkswap a file and swapon it.
07:43:52 <Baughn> dcoutts_: Don't you have root access to it?
07:43:58 <dcoutts_> Baughn: yes we do
07:44:04 <Snark> because when I get a proposition, what can I do with it if the proposition giver is hidden in a whatever I chose?
07:44:09 <Baughn> Then quicksilver has a point
07:44:23 <dcoutts_> Baughn: it's a question of if we should. We know we can.
07:44:38 <Baughn> dcoutts_: Well, it would give us some leeway right now
07:44:39 <Igloo> dcoutts_: OK, but if we add some swap then we still have a fixed limit, and lambdabot will still fill it
07:44:49 <dcoutts_> eg, why did the hosting company set it up without swap? was there a good reason for it?
07:44:57 <quicksilver> Irrspective of fixing lambdabot, or dumping lambdabot, I would always run a linux machine with swap.
07:44:59 <dcoutts_> Baughn: I know, that's my point too.
07:45:00 <Igloo> And then when we want to swap out, we first have to swap in the memory on the layer above us!
07:45:00 <Baughn> Igloo: It's a bit odd. I'm runing the exact same lambdabot here, and I can't induce it to leak
07:45:04 <quicksilver> As far as I know there is just no reason not to.
07:45:30 <Baughn> Igloo: I have a feeling the memory leak might be /caused/ by lack of memory
07:45:47 <dcoutts_> Igloo: yes, but much more slowly, esp the runplugs since they're blocked so can easily be swapped out
07:46:05 <Igloo> Baughn: Is that just a wild guess, or do you have some reason to think that?
07:46:19 <dcoutts_> Baughn: it's got plenty, lambdabot is using 175Mb atm, which is ~30% of our total.
07:46:23 <Baughn> Igloo: A wild guess
07:46:29 <dcoutts_> and it leaks runplugs processes
07:46:40 <Igloo> Bearing in mind that before it started leaking there was presumably >100M free
07:46:45 <dcoutts_> which is the most grievous crime
07:46:57 <dcoutts_> since each one costs 3% of memory
07:46:59 <Igloo> (unless something else used a lot before)
07:47:08 <Baughn> dcoutts_: Something is causing it. It doesn't do it here. Thus, I write random patches trying to induce the same behaviour here so I can fix it.
07:47:16 <Baughn> I haven't had any success so far.
07:47:28 <Igloo> How quickly does it start leaking on community?
07:47:45 <dcoutts_> @uptime
07:47:46 <lambdabot> uptime: 5d 13h 21m 21s, longest uptime: 1m 10d 23h 44m 29s
07:47:47 <Igloo> And did you compile with the same version of GHC?
07:48:08 <Igloo> dcoutts_: What I meant was, if lambdabot is restarted, does it immediately start leaking?
07:48:13 <dcoutts_> Igloo: current cpu time is nearly 2hrs
07:48:17 <dcoutts_> Igloo: no, it's slow
07:48:40 <Igloo> dcoutts_: It immediately starts leaking it a slow rate, or it takes a while before it starts leaking at all?
07:48:42 <flux> I've found producing log and logging memory usage to be helpful with these kinds of cases.
07:48:53 <hpaste>  (anonymous) annotated "Critique my coding style, please." with "(no title)" at http://hpaste.org/8363#a1
07:49:03 <dcoutts_> Igloo: not sure, but you come back a day or two later and it's looking bad.
07:49:17 <jstanley> Can the way swampMVar is used in http://hpaste.org/8366 create deadlock? Seems to me that it can because of the lock contention for mvM between the broadcast thread and the 'talk' thread instances.
07:49:22 <jstanley> swapMVar*
07:49:37 <Igloo> OK, so it's possible that there's some command or something that causes it to start leaking
07:49:50 <dcoutts_> Baughn: probably adding tracing and logging to the real production instance, and running it on a more capable host would be a way to debug the issues.
07:49:55 <dcoutts_> Igloo: possibly
07:49:56 <Igloo> Although unlikely, unless it causes it to leak a lot all at once
07:49:58 <EvilTerran> Athas, well, foldl (+) 0 = Prelude.sum
07:50:04 <quicksilver> Baughn: the leaking might not be related to the eval stuff, I guess
07:50:15 <quicksilver> Baughn: it might be related to something which happens in busy IRC channels
07:50:18 <quicksilver> Baughn: like the @seen code
07:50:20 <dcoutts_> quicksilver: though the leaking of runplugs processes must be
07:50:25 <quicksilver> dcoutts_: yes
07:50:41 <Baughn> quicksilver: Could be. It *does* leak here, but it also seems to stabilize at 200m or so
07:50:51 <quicksilver> 200M is a hell of a lot of memory though :)
07:51:00 <dcoutts_> 200m is too much for community.h.o to support
07:51:07 <quicksilver> how much does it use when started fresh and loading all its databases?
07:51:11 <Baughn> 19m
07:51:22 <quicksilver> presumably the in-memory representatio of @seen and @quote is fairly large
07:51:25 <quicksilver> but not 200M large
07:51:31 <Igloo> It probably hasn't stabilised, it probably just looks like that as the heap size goes up by factors of 2
07:51:35 <Baughn> And yes, it is. I'll restart it and log the GCs, see if that helps in a few days
07:51:47 <hpaste>  (anonymous) annotated "Critique my coding style, please." with "(no title)" at http://hpaste.org/8363#a2
07:51:57 <dcoutts_> Baughn: are the commands logged too?
07:52:06 <dcoutts_> a sensible target should probably be ~50M
07:52:20 <quicksilver> even 50M seems high, bearing in mind what the bot actually does.
07:52:37 <Baughn> dcoutts_: Generally speaking, mine doesn't /see/ any commands
07:52:40 <quicksilver> It records the last comment and time of ~700 IRC users in a few channels.
07:52:47 <dcoutts_> I just mean from the pov of what the community server can support
07:52:51 <Baughn> dcoutts_: It increases anyway.
07:53:02 <quicksilver> it records a few small databases (@where, @src) which only have a few hundred lines in each
07:53:59 <dcoutts_> is lambdabot run with a max heap size?
07:54:09 <dcoutts_> +RTS -blah blah
07:55:53 <mm_freak_work> > 3 `seq` 4
07:56:02 <Baughn> ..it's awfully GC-happy, doing 1-generation GCs /every time someone speaks/
07:56:08 <lambdabot>  thread killed
07:56:14 <mm_freak_work> huh?!
07:56:22 <Baughn> mm_freak_work: Yeah, a bit broken
07:56:24 <mmorrow> hmm
07:56:33 <mmorrow> > 3
07:56:42 <Baughn> > 3 `seq` 4
07:56:43 <Cheiron>  4
07:56:44 <jstanley> Can someone take a peek at http://hpaste.org/8366 and confirm/deny my suspicion about there being deadlock potential due to swapMVar usage betwen the broadcast thread and the per-client message-producing threads?
07:56:49 <lambdabot>  thread killed
07:56:58 <lambdabot>  thread killed
07:57:16 <dcoutts_> @where lambdabot
07:57:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:57:16 <Cheiron> http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:57:17 <lambdabot> Title: lambdabot
08:00:38 <mmorrow> jstanley: in the docs: "Note that there is a race condition whereby another process can put something in the MVar after the take happens but before the put does." , so without having worked your code out it my head, this is my only useful comment...
08:01:32 <mmorrow> (but you've probably already read the docs)
08:02:53 <mmorrow> jstanley: using stm (TMVar, atomically) will remove the guesswork
08:03:05 <jstanley> mmorrow: Right, the docs are why I think there's a problem here, I just wanted someone to confirm.  The way I see it, the swapMVar use in the broadcast thread can cause deadlock by taking from the mvar and having an interleaved producer thread do a put before the broadcast thread can.
08:03:18 <BeelsebobWork> hmm, why would seq (unsafePerformIO (print ((s :=: t):c'))) (error "Type unification failed") not print before dying?
08:03:39 <jstanley> mmorrow: Yeah, I'm planning on doing it both ways, just trying to understand both approaches first (this isn't actually my code, e.g.)
08:04:04 <mmorrow> jstanley: cool. yeah, if i were you i'd def go the stm route *just to be sure* :)
08:04:28 <jstanley> mmorrow: Cool, thanks =)
08:09:09 <Baughn> BeelsebobWork: Buffering?
08:09:24 <BeelsebobWork> Baughn: shouldn't be -- the error appears
08:09:26 <BeelsebobWork> the print doesn't
08:09:45 <Baughn> BeelsebobWork: Could be different streams - stdout vs. stderr. Try flushing anyway.
08:10:12 <BeelsebobWork> it's within ghci, so no way (that I know) to flush
08:10:26 <Baughn> hFlush? ;)
08:10:47 <Baughn> I don't think ghci redirects stdout
08:10:48 <BeelsebobWork> nothing more in stdout or stderr
08:21:06 <quicksilver> BeelsebobWork: lack of newline
08:21:27 <BeelsebobWork> print adds a newline doesn't it?
08:21:52 <quicksilver> @src print
08:21:53 <lambdabot> print x = putStrLn (show x)
08:21:56 <quicksilver> Oh ;)
08:21:58 <quicksilver> not thtat then.
08:22:28 <quicksilver> maybe some breaking optimsation applied.
08:22:38 <quicksilver> your unsafeperformIO got floated or hoisted or something :)
08:26:02 <hpaste>  yrlnry pasted "type check failure in definition of fromInteger" at http://hpaste.org/8367
08:26:16 <yrlnry_> I don't understand this error, and I hope someone will be able to explain it to me.
08:26:26 <yrlnry_> The code is included in the paste.
08:27:21 <mauke> the error doesn't match the code
08:27:59 <yrlnry_> You're right, I scrolled back too far and copied the previous iteration of the message, which is substantively identical.
08:28:03 <mauke> you need fromInteger p
08:28:31 <mauke> and deriving (Eq, Show)
08:29:52 <hpaste>  mauke annotated "type check failure in definition of fromInteger" with "works" at http://hpaste.org/8367#a1
08:33:50 <yrlnry_> It's the fromInteger that I was missing.  My real code does have the deriving clause, and I took it out of my example because it doesn't affect the error.
08:33:51 <yrlnry_> THanks.
08:34:04 <yrlnry_> I don't need it on the 0 because it's implicit there, right?
08:34:53 <byorgey> yrlnry_: right.  numeric constants always have an implicit 'fromInteger'
08:35:12 <yrlnry_> Hey, did you get to Philadelphia yet?
08:35:23 <yrlnry_> July, I now remember.
08:36:30 <mmorrow> > 3
08:36:32 <Cheiron>  3
08:36:36 <mmorrow> :)
08:36:46 <lambdabot>  thread killed
08:37:06 <mmorrow> > foldl (.) id (repeat read) $ fix show
08:37:12 <Cheiron>  "Exception: Time limit exceeded
08:37:21 <lambdabot>  thread killed
08:38:12 * Baughn would like to suggest killing lambdabot
08:38:37 <mauke> @msg #haskell admin
08:38:38 <lambdabot> admin
08:38:38 <Cheiron> admin
08:38:39 <mmorrow> would she rejoin if she got kicked?
08:38:45 <mauke> :-)
08:39:57 <Baughn> mauke: Well, right now LB is just noise. Cheiron should be.. relatively reliable.
08:39:57 <yrlnry_> Oh, but now I remember I have more question.  Since the type of the mobius fromInteger is supposed to be (Num a) => Integer -> a, why can't I write the code as I had it originally and infer that the mobius fromInteger has type Integer -> Mobius Integer ?
08:40:47 <mauke> it's supposed to be (Num a) => Integer -> Mobius a
08:41:29 <byorgey> yrlnry_: I'm moving to Philadelphia on or around August 1. =)
08:41:32 <mauke> it did infer Integer -> Mobius Integer, and then complained because 'Integer' is more specific than the required 'a'
08:41:38 <yrlnry_> Isn't Integer -> Mobius Integer a subtype of  (Num a) => Integer -?> Mobius a
08:41:41 <yrlnry_> ?
08:41:53 <yrlnry_> byorgey: Have a good move.
08:41:57 <byorgey> thanks =)
08:42:11 <mauke> yes, but the class definition requires a more general type
08:42:17 <mauke> 'rigid type variable'
08:42:53 <yrlnry_> Why?
08:43:41 <mauke> because you wrote instance (Num a) => Num (Mobius a), not instance Num (Mobius Integer)
08:43:52 <mauke> (and the latter is illegal in H98)
08:44:11 <byorgey> with (Num a) => Num (Mobius a), the Num class requires that fromInteger must be able to produce a value of type  Mobius a,  for *any* type a which is an instance of Num.  the caller gets to choose.
08:44:24 <byorgey> so a function that always returns  (Mobius Integer) doesn't fit the bill.
08:44:29 <yrlnry_> byorgey: thanks, that's the answer I was looking for.
08:45:34 <Deewiant> aahh, help! runInteractiveProcess is returning a Handle which can't be hFlushed or hClosed without having the whole program die (no output), what's going on? (happens only on Linux, Windows works fine)
08:46:29 <byorgey> Deewiant: try jiggling the Handle, then maybe it will hFlush properly
08:46:41 <byorgey> sometimes they get stuck
08:46:43 <quicksilver> Baughn: if you are volunteering to keep cheiron alive and attempt to investigate the ongoing memory leak situation then that could be an interesting offer.
08:46:51 <Deewiant> I've been jiggling it for the past two hours, no luck
08:46:52 <Baughn> quicksilver: I am, yes.
08:46:54 <mauke> Deewiant: my crystal ball says: SIGPIPE
08:47:00 <quicksilver> Baughn: it would be sad to lose the @seen, @quote, and @where databases though.
08:47:14 <yrlnry_> SIGGRIPE
08:47:15 <Baughn> quicksilver: Upload the latest versions of same and I'll install them
08:47:23 <Deewiant> mauke: what's the cause and what can I do about it
08:47:23 <quicksilver> I don't have access.
08:47:26 <mauke> IMO preflex's seen > lambdabot's seen
08:47:50 <mauke> Deewiant: attempting to write to a filehandle whose read end is closed causes a SIGPIPE, which is fatal by default
08:47:57 <Baughn> quicksilver: That said, my internet connection isn't the world's most reliable. There are no doubt people with better pipes to host it on.
08:48:09 <quicksilver> dcoutts_ , Cale : Baughn offers to try to maintain a LB installation on a machine he has accesss to and try to get to the bottom of the problem.
08:48:15 <mauke> Deewiant: this can easily happen with IPC pipes
08:48:29 <osfameron> @index powerset
08:48:29 <lambdabot> bzzt
08:48:30 <Cheiron> bzzt
08:48:32 <quicksilver> dcoutts_ , Cale : I'd be sad to see the databases lost though so I'd rather a solution which involved the databases being copied over.
08:48:58 <dcoutts_> quicksilver, Baughn: fine with me. check with Cale
08:49:01 <Baughn> For the record, I'll probably be equally able to find the reason /without/ hosting the main LB
08:49:14 <mauke> isn't @seen per-connection anyway? it seems to forget everything when it's restarted
08:49:27 <Deewiant> mauke: you are probably correct, getProcessExitCode suggests that the process died before I had time to do anything with it
08:49:34 <Deewiant> mauke: so, now I have two more questions
08:49:48 <Deewiant> 1) shouldn't the runtime catch these kind of errors?
08:49:57 <mauke> not unless you tell it to
08:50:12 <Baughn> mauke: No, it just seems that way because the seen db is easily corrupted and thus gets deleted on restart
08:50:13 <mauke> signal handling is serious business
08:50:19 <mauke> Baughn: :-(
08:50:20 <Deewiant> 2) why does my program (main = interact ("foo" ++)) die?
08:50:33 <Baughn> mauke: Works fine if LB /doesn't/ crash, though
08:51:30 <quicksilver> Deewiant: it might be nice the the RTS caught SIGPIPE, but, meh, you're living in a posix world. Learn posix.
08:51:44 <quicksilver> Deewiant: ignor'ing sigpipe is only one line of code.
08:51:48 <mauke> Deewiant: good question. what are you doing to it?
08:51:54 <Deewiant> or even that the shell would print "got SIGPIPE"
08:52:00 <Deewiant> getting no output at all is what shocked me
08:52:07 <mauke> echo $?
08:52:13 <Deewiant> 141
08:53:05 <mauke> #define SIGPIPE     13  /* Broken pipe (POSIX).  */
08:53:05 <gwern> offhand, does anyone know why you can't profile anything using the GHC API?
08:54:23 <yrlnry_> Now I've defined an "ExtNum a" type which tries to life the numeric type a to a type that includes an "infinity" value.  I just defined all the functions for this type, and every one of them is functorial:  they all look like     abs (Finite a) = Finite (abs a)     abs Infinite = Infinite    and so forth.  It seems like I ought to be able to get this stuff generated automagically by declaring ExtNum to be an instance of Functor.  Does thi
08:54:23 <yrlnry_> s make sense?
08:54:24 <Deewiant> mauke: (inp, out, _, pid) <- runInteractiveProcess ("test", []) (Just "the working directory") Nothing
08:54:36 <Deewiant> oh, don't tell me I need to put a ./ there
08:54:54 <mauke> did you just call a test program "test"?
08:55:06 <mauke> CARDINAL SIN
08:55:28 * Baughn usually calls it "a.out"
08:55:55 <Baughn> (And I have a.out.hs to prove it)
08:56:03 * mauke calls his test programs "try.{pl,c,hs}"
08:56:05 <osfameron> @pl (\x -> length x > 3)
08:56:05 <lambdabot> (> 3) . length
08:56:06 <Cheiron> (> 3) . length
08:56:11 <mauke> I think I read that in a Perl book somewhere
08:56:12 <kpreid> mauke: hmm?
08:56:20 <kpreid> mauke: who cares, if . isn't on your path, which it shouldn't be?
08:56:35 <Deewiant> mauke: okay, so now why do I need to make it ./test even though I give the working directory!!
08:56:48 <mauke> kpreid: Deewiant does. because his test program mysteriously produces no output and exits immediately :-)
08:56:54 <osfameron> what's wrong with calling it "test" ? ;-)
08:56:59 <yrlnry_> In Unix Version 2, the first version to have a separate assembler, the assembler was programmed to deposit its output in a file whose name was the current month.
08:57:17 <Deewiant> argh, dammit
08:57:17 <mauke> osfameron: it'll invoke the /bin/test exe
08:57:19 <yrlnry_> So in January the assembler would write a file named "janvier", etc.
08:57:20 <Deewiant> I'm a fool
08:57:33 <yrlnry_> This was in August 1971.
08:57:42 * Deewiant wears a dunce cap
08:57:45 <mauke> haha
08:57:48 <yrlnry_> They quickly realized it was a stupid idea, and changed the code to continue using the same filename.
08:57:55 <yrlnry_> And it's been a.out ever since.
08:58:01 <osfameron> mauke: ah gotcha.  I tend to just invoke them as "perl test.pl" so it doesn't make any different but good point
08:58:09 <yrlnry_> It should have been ao.ut, but Dennis RItchie misspelled it.
08:58:37 <mauke> eval: "ragout" =~ /a.out/
08:58:41 <Deewiant> mauke: thanks for the help anyways, can you now tell me how I can deal with the SIGPIPE (preferably getting an IO exception)?
08:58:52 <mauke> you need to ignore it. sec
08:58:57 <yrlnry_> The misspelling could not be corrected, for backward compatibility reasons.
08:59:18 <mauke> Deewiant: installHandler openEndedPipe Ignore Nothing
08:59:25 <quicksilver> Deewiant: the working directory is not in the path.
08:59:30 <quicksilver> Deewiant: oops, sorry.
08:59:38 <quicksilver> Deewiant: didn't realise I was scrolled up a couple of pages.
08:59:40 * quicksilver hates that.
08:59:50 <Deewiant> @hoogle installHandler
08:59:50 <Cheiron> GHC.ConsoleHandler.installHandler :: Handler -> IO Handler
09:00:03 <lambdabot> GHC.ConsoleHandler.installHandler :: Handler -> IO Handler
09:00:14 <Deewiant> mauke: that's probably not what you meant?
09:00:27 <mauke> import System.Posix.Signals
09:01:36 <Deewiant> ugh, now how can I version that it so that it won't cause problems on Win32
09:01:43 <Deewiant> do I need to use the CPP? *shudder*
09:02:03 <mauke> maybe cabal has support for that
09:02:50 <dcoutts_> Deewiant: yes, you need cpp
09:03:14 <dcoutts_> ghc's cpp defines a host_os cpp define
09:04:07 <yrlnry_> @pf k
09:04:07 <lambdabot> Maybe you meant: bf pl
09:04:08 <Cheiron> Maybe you meant: bf pl
09:04:27 <vixey> :t (.0
09:04:29 <Cheiron> parse error (possibly incorrect indentation)
09:04:29 <vixey> :t (.)
09:04:31 <Cheiron> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:04:42 <lambdabot> parse error (possibly incorrect indentation)
09:04:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:04:48 <mauke> lambdabot: @part
09:04:48 <lambdabot> Plugin `system' failed with: Prelude.last: empty list
09:10:46 <quicksilver> mauke: was that definitely the best thing to do?
09:10:55 <quicksilver> mauke: lambdabot appears to be currently working
09:10:59 <mauke> I don't know
09:11:05 <mauke> it was much slower, though
09:11:09 <quicksilver> and until we make a definite plan I have a preference for keeping around the one with the @seen databases.
09:11:12 <quicksilver> true.
09:12:34 <mehrheit> not haskell related: does the function which returns itself for any argument have a special name?
09:13:16 <Baughn> a -> (a -> (a ->...
09:13:41 <Baughn> newtype F = F (a -> F) -- Would that work?
09:14:02 <dcoutts_> > 1+1
09:14:03 <Cheiron>  2
09:14:15 <mehrheit> Baughn, yes, it does
09:14:22 <oldsalt> hi all. which ghc libraries are not available on hackage.haskell.org?
09:14:59 <Squishei> mehrheit: doesn't that create an infinite type?
09:15:10 <Squishei> oh, no it doesn't
09:15:12 <Squishei> >.<
09:16:10 <quicksilver> no more infinite than List, really.
09:16:13 <dcoutts_> oldsalt: base, rts, ghc. I think that's it.
09:16:16 <quicksilver> which is to say, yes it's an infinite type.
09:16:22 <quicksilver> in that sense.
09:17:49 <oldsalt> dcoutts_: thank  you
09:25:29 <quicksilver> mauke, Baughn : let's dump Cheiron and bring LB back for now.
09:25:32 <quicksilver> it is working.
09:25:38 <quicksilver> we'll bring cheiron in if LB actually breask.
09:25:50 <quicksilver> and when we can get hold of Cale we'll try to plan a way out of this siutation.
09:25:59 <osfameron> if I wanted to read a text file of words and store the results in a dictionary (key->value pairs for fast lookup), what tutorials/modules should I be looking at?
09:26:18 <quicksilver> Data.Map ?
09:27:15 <mmorrow> osfameron: do a foldl' with Data.Map.insertWith
09:27:18 <dcoutts_> @botsnack
09:27:19 <lambdabot> :)
09:27:19 <Cheiron> :)
09:27:30 <dcoutts_> > 1+1
09:27:31 <Cheiron>  2
09:27:32 <lambdabot>  2
09:27:33 <osfameron> ta
09:27:40 <mauke> Cheiron: @part #haskell
09:27:54 <mrd> mapping what to what?
09:28:14 <osfameron> String -> String actually
09:28:25 <osfameron> (the first being a canonicalised form of the same word)
09:28:29 <osfameron> oh hang on
09:28:33 <osfameron> so String -> [String]
09:29:40 <mrd> what are the Strings
09:29:43 <mmorrow> foldl' (\m x -> M.insertWith (++) (canonicalize x) [x] m) mempty . lines =<< readFile "thefile.file"
09:30:03 <osfameron> mrd: words from a dict file
09:30:09 <mrd> that's a set
09:30:52 <mmorrow> but doesn't he want to key by canonicalized form and map that to the list/set/whatever of noncanocial occurrences?
09:31:01 <osfameron> :t mempty
09:31:03 <lambdabot> forall a. (Monoid a) => a
09:31:08 <osfameron> yeah, it's for an anagram solver
09:31:10 <mmorrow> mempty => M.empty
09:31:28 <osfameron> so the canonical key would just be 'sort key'
09:31:46 <mrd> ?instances-importing Data.Map Monoid
09:31:46 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Map k v, Maybe a, Ordering, Product a, Sum a, [a]
09:32:23 <mmorrow> osfameron: cool, so let canonicalize = sort in foldl' (\m x -> M.insertWith (++) (canonicalize x) [x] m) mempty . lines =<< readFile "thefile.file" should work i believe
09:32:37 <mrd> :t sort
09:32:39 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:32:46 <mrd> probably raise DMR
09:32:53 <mrd> :)
09:33:11 <mmorrow> ?
09:33:12 <osfameron> I don't understand what mempty is relating to -- is that the start value of the fold?
09:33:16 <osfameron> so just [] ?
09:33:25 <mmorrow> mempty :: Map k v
09:33:25 <mrd> mempty = M.empty
09:33:40 <mmorrow> analogous to foldl' (*) 0 [1..9]
09:33:44 <mrd> he's just being clever and using the Monoid class's empty
09:33:47 <mmorrow> mempty there would be 0
09:33:53 <osfameron> ah ok
09:34:00 <mmorrow> :)
09:34:05 <osfameron> and =<< ?
09:34:20 <osfameron> I mean, it's obvious what that does, but where odes it come from?
09:34:33 <mmorrow> oh, forget that part. assume you have your words in a list :: [String]
09:34:48 <mmorrow> then do let canonicalize = sort in foldl' (\m x -> M.insertWith (++) (canonicalize x) [x] m) mempty listOfWords
09:35:15 <mrd> osfameron: hmm? that connects the output of readFile
09:35:20 <mrd> which is IO String
09:35:23 <mauke> @index (=<<)
09:35:23 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:35:27 <osfameron> yeah, that makes sense (I would have taken a lot more time to get there, starting off recursively of course)
09:35:29 <mauke> @src (=<<)
09:35:29 <lambdabot> f =<< x = x >>= f
09:35:29 <quicksilver> isn't fold/insertWith just fromListWith?
09:35:32 <mrd> also I think mmorrow meant liftM
09:35:55 <mmorrow> yeah yer right, but i meant => return . at the beginning
09:35:56 <mrd> since the left-hand side is pure
09:36:26 <mmorrow> (my personal preference to liftM)
09:37:03 <osfameron> eeek, hometime
09:37:07 <mrd> (fromListWith (++) . map (sort &&& return) . lines) `liftM` readFile "foo"
09:37:30 <mmorrow> return . fromListWith (++) . map (sort &&& return) . lines =<< readFile "foo"
09:37:34 <mmorrow> :)
09:37:39 <osfameron> why return rather than id ?
09:37:48 <Deewiant> hmm
09:37:49 <mrd> return :: a -> [a]
09:37:55 <osfameron> oh
09:38:00 <mmorrow> :t (=<<)
09:38:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:38:02 <Saizan> no
09:38:05 <mmorrow> aq -> IO a
09:38:09 <mmorrow> a -> IO a
09:38:13 <mmorrow> (in this case)
09:38:25 <mrd> the return inside the map is the List version
09:38:26 <Deewiant> now I'm passing Just [("PATH", "directory where the binary is contained")] to runInteractiveProcess but it still can't find the binary I want to run
09:38:39 <osfameron> heh, thanks, I'll copy these to have a look at later...
09:38:40 <mmorrow> oh, i was talking about the wrong return...
09:38:44 <Deewiant> which I find odd since it does apparently read path otherwise (as evidenced by my troubles earlier)
09:38:47 <quicksilver> Deewiant: that's the environment for the launched process.
09:38:54 <quicksilver> Deewiant: it does change your PATH.
09:38:56 <quicksilver> erm
09:38:57 <quicksilver> doesn't.
09:39:07 <Deewiant> right, so I need to change the path of the caller and not the callee
09:39:26 <quicksilver> why not just give a full path?
09:39:33 <quicksilver> that seems easier in this case than modifying PATH?
09:39:48 <Deewiant> in general the path comes from the user
09:40:33 <Deewiant> I was hoping to offer the convenience of being able to run binaries in the working directory with just "foo" instead of "working-directory/foo"
09:40:53 <mauke> ew, convenience :(
09:40:59 <Deewiant> as System.Environment doesn't have anything in the way of modifying the environment I guess I can't do that :-)
09:41:22 <mauke> @hoogle setenv
09:41:23 <lambdabot> No matches found
09:41:55 <mauke> System.Posix.Env.setEnv
09:42:15 <dcoutts_> Deewiant: you can launch new processes in their own working dir and with their own env, see System.Process
09:42:44 <quicksilver> dcoutts_: yes, he is tring that
09:42:50 <mauke> dcoutts_: yes, but you still have to specify a filename
09:42:54 <quicksilver> dcoutts_: but the process he wants to launch is not in the PATH either
09:42:55 <Deewiant> dcoutts_: yeah, but if the filename of the exe is given as "foo" I don't know whether they want "workingdir/foo" or path's foo
09:43:09 <quicksilver> Deewiant: are you aware of why it's poor security to have "." in the path?
09:43:10 <Deewiant> I can't always prepend "workingdir/" because if it's in the path that fails
09:43:19 <Deewiant> yes, I am
09:43:21 <quicksilver> and why this whole path thing exists in the first place?
09:43:31 <Deewiant> I guess I'm just too used to Windows :-)
09:43:36 <quicksilver> well then just check if workingdirectory/foo exists
09:43:38 <dcoutts_> Deewiant: the path of the exe is in the current environment, not in the child env
09:43:49 <dcoutts_> you find the exe first, then launch it with a new env
09:44:00 <Deewiant> yeah, quicksilver explained that
09:45:40 <quicksilver> what kind of program are ou writing?
09:45:48 <quicksilver> what is it doing that means it is launching processes on command?
09:46:06 <Snark> re
09:46:16 <mmorrow> http://code.haskell.org/~morrow/code/js/dom.idl.html
09:47:01 <Deewiant> quicksilver: I'm writing a Make-replacement :-)
09:47:24 <mauke> haha, good luck
09:47:33 <quicksilver> I'm pretty much convinced that automaticallylaunching arbitrary executables in arbitrary working directories would be a misfeature
09:47:35 <mauke> (make itself just calls system(), doesn't it?)
09:47:49 <quicksilver> certainly it uses the user's shell
09:47:53 <quicksilver> I imagine that's via system()
09:48:05 <mauke> system calls /bin/sh -c, not the user's shell
09:48:18 <Deewiant> mauke: actually it's pretty much done minus debugging
09:48:21 <newsham> ?src system
09:48:21 <lambdabot> Source not found.
09:48:29 <newsham> bad bot
09:48:33 <quicksilver> a very good point.
09:48:33 <mauke> system(3)
09:48:37 <newsham> mauke: i know.
09:49:47 <newsham> quick: PATH exists because early unix didnt have union mounts.
09:50:20 <newsham> (ps. 1st ed didnt have PATH, and shell would only run commands from /bin or . or full paths)
09:56:09 <quicksilver> newsham: that is one one of viewing the situation.
09:56:27 <quicksilver> newsham: however I've never administered or used a unix system which did use union mounts to solve the problem PATH solves today.
09:56:39 <newsham> quick: try plan9.
09:56:55 <quicksilver> newsham: and I don't believe union mounts would solve the common status quo where different users have different PATHs.
09:56:59 <quicksilver> newsham: thanks, but no thanks.
09:57:11 <newsham> different users can have different union mounts
09:57:39 <newsham> why add add hoc search mechanisms into each utility when you can implement them once and for all in the os?
09:58:03 <newsham> s/add hoc/ad hoc/
09:58:13 <quicksilver> because I work with operating systems which exist and run on the computers I am paid to work on.
09:58:18 <quicksilver> and they don't have this feature.
09:58:24 <quicksilver> I'm not disagreeing with the notion.
09:58:35 <quicksilver> but, GHC has System.POSIX and not System.Plan9
09:58:38 <quicksilver> you will observe.
10:03:15 <Baughn> > 2
10:03:16 <Cheiron>  /tmp/MaLqG11244.o: unknown symbol `__stginit_arrowszm0zi4_ControlziArrowziOp...
10:03:16 <lambdabot>  2
10:03:32 <Baughn> @part #haskell
10:03:32 <lambdabot> Not enough privileges
10:04:11 <quicksilver> Baughn: interesting error :)
10:04:41 <Baughn> quicksilver: ..yeah. I broke a few things forcing LB into the shape of a profiled application.
10:04:50 <Baughn> Hopefully it'll still leak
10:05:09 <newsham> build profiled versions of your deps
10:05:26 <Baughn> newsham: hs-plugins is an issue
10:05:39 <newsham> oh, hs-plugins doesnt work with prof stuff?
10:05:52 <Baughn> Nope. It might have, but some needed ghc code isn't profiled.
10:06:13 <Baughn> That said, I don't really /need/ hs-plugins. It's only used by other executables, not LB itself
10:06:33 <Baughn> I suspect this particular break is because I failed to recompile runplugs in any way, shape or form. No matter.
10:07:03 * Baughn now has the awesome power of the GHC profiler at his disposal. Tremble, bugs! Tremble!
10:16:14 <byorgey> anyone have any experience with the 'feed' library on hackage?  I'm having a heck of a time trying to extract any information at all from some gmane RSS feeds, for example http://rss.gmane.org/topics/excerpts/gmane.comp.lang.haskell.cafe
10:16:23 <roconnor> bugs?
10:16:46 <byorgey> I don't think so, I think I just don't know the right functions to call from the library
10:16:57 <byorgey> it's not very well-documented (read: there is no documentation)
10:17:33 <Saizan> is there anything between arrows and monads wrt expressivity?
10:18:02 <dcoutts_> Saizan: you mean strictly in between?
10:18:03 <byorgey> Saizan: well, arrows and monads aren't really on a continuum, so your question doesn't really make sense =)
10:18:12 <roconnor> every monad induces the Kleisli arrow
10:18:20 <roconnor> @hoogle Kleisli
10:18:21 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
10:18:21 <lambdabot> Control.Arrow.Kleisli :: (a -> m b) -> Kleisli m a b
10:18:21 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
10:18:26 <Saizan> dcoutts_: yeah
10:18:40 <roconnor> oh
10:18:43 <Saizan> roconnor: i mean arrows without apply
10:18:44 <lament> there's more arrows than monads
10:18:46 <roconnor> that's what you are asking
10:19:14 <dcoutts_> Saizan: not anything that I know of. I'm sure one could construct something, but I don't know of anything in common use.
10:19:23 <byorgey> lament: in what sense?
10:19:50 <lament> in that for every monad there's an arrow but not vice-versa, iirc
10:19:50 <vixey> @instances Arrow
10:19:52 <lambdabot> (->), Kleisli m
10:19:52 <vixey> @instances Monad
10:19:53 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:20:17 <lament> not in the mathematical sense of "more" :)
10:20:31 <byorgey> hehe, ok =)
10:20:37 <vixey> there's 2 arrows and there's 1000 trillion monads
10:20:45 <lament> haha
10:20:54 <lament> that's also true
10:21:06 <lament> ergo, 2 > 1000000000000000
10:21:32 <vixey> "for a finale, man goes on to prove black is white and gets run over at the next zebra crossing"
10:21:56 <byorgey> one thing that I think a lot of people miss, though, is that the Kleisli arrow resulting from a monad is not as expressive as the original monad.  so arrows are not a generalization of monads.
10:22:38 <lament> if they were as expressive and a superset of monads, people would just use arrows
10:22:50 <roconnor> byorgey: sure they are,  there Kleisli arrows have the runKleisli command :P
10:23:02 <byorgey> roconnor: hehe, that's cheating =)
10:23:17 <roconnor> byorgey: oh, why is that?
10:23:21 <Saizan> byorgey: you've app on that Kliesli arrow
10:23:49 <gal_bolle> what is it you can express through the monad but not through the Kleisli arrow ? (if the question even makes sense)
10:24:01 <roconnor> are things that are more general, less expressive by definition?
10:24:10 <byorgey> roconnor: I mean, there are some monadic computations which you cannot express as arrow computations, with a final runKleisli
10:24:26 <elliottt> byorgey: what's an example?
10:24:34 <byorgey> gal_bolle: with monads, you can use the result of a previous computation to choose the computation you will perform next.  you can't do that with general Arrows.
10:24:51 <elliottt> thanks :)
10:25:02 <byorgey> for that you need ArrowChoice.
10:25:23 <roconnor> @type Kleisli return
10:25:27 <byorgey> and there's also ArrowApply, which allows you to do what is basically the arrow version of 'ap'
10:25:29 <lambdabot> forall a (m :: * -> *). (Monad m) => Kleisli m a a
10:25:40 <byorgey> at which point you *do* get the same power as monads
10:25:47 <roconnor> @type Kleisli fmap
10:25:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => Kleisli ((->) (f a)) (a -> b) (f b)
10:25:56 <gal_bolle> and the Kleisli arrow is not guaranteed to be an ArrowChoice and ArrowApply, i guess
10:26:03 <roconnor> @type Kleisli join
10:26:04 <elliottt> so, you just get to specify at the type level what you're going to do with the monad, then
10:26:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => Kleisli m (m (m a)) a
10:26:25 <roconnor> @type \f -> Kleisli (fmap f)
10:26:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> Kleisli f (f a) b
10:26:33 <roconnor> hmm
10:27:11 <roconnor> @type arr
10:27:13 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:27:21 * roconnor nods
10:27:37 <Saizan> i suggest http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf for a more precise tractation
10:27:51 <lambdabot> http://tinyurl.com/6evopg
10:27:53 <roconnor> byorgey: do I get to use arr, Kleisli return, and Kleisli join?
10:28:11 <byorgey> Saizan: indeed.
10:29:47 <byorgey> roconnor: sure.
10:31:05 <BMeph> gal_bolle: Kleisli _is_ guaranteed to be ArrowApply, IIRC. :)
10:31:23 <bos> @hoogle writeArray
10:31:24 <lambdabot> Data.Array.MArray.writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
10:32:55 <byorgey> BMeph: good point. =)
10:33:44 * BMeph takes a bow
10:34:29 <vixey> hmm "I find this is a major problem with regular programmers playing with systems like Coq; the learning curve is just too steep for writing proofs.
10:34:42 * BMeph then notices all of the arrow talk, and _slowly_ puts the bow down...
10:34:58 * vixey . o O ( you've already been writing proof the whole time )
10:40:14 <vixey> what's a telescope in programming?
10:40:41 <elliottt> composition of lenses? ;)
10:41:08 <vixey> something like a list of typed terms with each one maybe depending on the previous
10:41:10 <roconnor> vixey: are you asking what a telescope in Coq is?
10:41:13 <vixey> I'm just guessing though
10:41:17 <vixey> no not in Coq
10:41:19 <roconnor> oh
10:41:26 <vixey> I didn't know there was such a thing
10:41:30 <roconnor> vixey: you might be right about that
10:41:40 <swiert> "A telescope is a vector where the type of elements varies with their position in the
10:41:40 <swiert> structure."
10:41:49 <swiert> vixey: http://www.cs.nott.ac.uk/~pwm/thesis.pdf has some examples.
10:42:10 <vixey> oh great, thanks sweirt
10:42:18 <swiert> np
10:42:21 <vixey> swiert*
10:42:30 <roconnor> I've seen telescope uses for a nested series of type-casts
10:42:45 <roconnor> used
10:42:54 <vixey> It's a bit like nested tuples then I suppose
10:44:01 <swiert> vixey: yep - provided by "tuples" you mean "dependent pairs"
10:44:13 <vixey> ahh
10:47:47 <dolio> @seen dons
10:47:47 <lambdabot> dons is in #haskell, #haskell-soc, #arch-haskell, #ghc and #xmonad. I last heard dons speak 3s ago.
10:48:12 <dolio> 3 seconds...
10:49:22 <roconnor> not here
10:49:28 <roconnor> in arch-haskell
10:49:47 <dolio> :)
10:50:24 <xerox> what's arch-hs?
10:50:39 <dolio> arch is a linux distribution.
10:53:50 <dolio> Wow, ghc 6.10 is getting quasiquoting.
10:54:41 <bd_> quasiquoting?
10:54:47 <dolio> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
10:54:49 <lambdabot> http://tinyurl.com/yo9sa3
10:56:24 <dolio> At least, it's on their list.
10:56:24 <roconnor> is that possible with types?
10:56:24 * bd_ makes a note to read that paper later, after work
10:56:25 <dolio> The page says they're "keen to get" it in. So I guess it's not as definite as view patterns, for instance.
10:56:25 <PeakerWork> trying to build wxcore (with cabal install) seems to try to install it system-wide: "Unable to rename "/usr/lib/ghc-6.8.2/package.conf" to "/usr/lib/ghc-6.8.2/package.conf.old"" -- any idea why?
10:56:30 <PeakerWork> Did anyone successfully install wx with cabal-install?
10:56:44 <vixey> oh cool when in 6.10 out?
10:56:50 <dcoutts_> PeakerWork: it's a bug in the package itself.
10:57:01 <dcoutts_> PeakerWork: it's because it uses build-type: Make
10:57:02 <PeakerWork> dcoutts_, ah, thanks
10:57:10 <dolio> Not for a while yet, I imagine.
10:57:14 <dcoutts_> PeakerWork: and then does not respect the --user flag
10:59:27 <PeakerWork> dcoutts, if I install it system-wide, it should work?
10:59:53 <PeakerWork> dcoutts, and does running cabal-install as root install stuff system-wide or does cabal-install have to be built differently to install system-wide?
11:00:09 <osfameron> hmmm, the Data.Map example from earlier works beautifully, except for having to specify "Data.List.map" instead of map (cos it's ambiguour with Data.Map.map)
11:00:10 <dcoutts_> PeakerWork: presumably it works. Use --global
11:00:21 <osfameron> is there a nice way around that?  Just to import hiding map ?
11:00:31 <mrd> osfameron: you shouldn't import Data.Map without qualifying it
11:00:33 <osfameron> (but can't do that in ghci)
11:00:33 <bd_> osfameron: import qualified Data.Map as M <-- is the common way
11:00:39 <osfameron> ah of course
11:00:44 <osfameron> how does that work in ghci then?
11:00:48 <dcoutts_> import qualified Data.Map as Map
11:00:53 <dcoutts_> import Data.Map (Map)
11:01:17 <dcoutts_> gets you the Map type unqualified rather than as Map.Map
11:01:37 <PeakerWork> probably good to also add (!) to the unqualified names
11:01:55 <bd_> osfameron: you could :load a source file with a qualified import, I guess
11:01:59 <osfameron> ok, but again not in ghci (:m +Data.Map as M  <-- doesan't work)
11:02:48 <bd_> osfameron: I mean, :load one in ghci
11:03:01 * Syzygy|de just learned he can get donations from NVidia for research material that accidentially doubles as equipping the office computer to be a kickass gaming box. :)
11:03:37 <osfameron> bd_: yeah, ok
11:03:39 <dolio> Oh, I guess the quasiquoting stuff is a relatively small patch against GHC, so it shouldn't be too hard to get in.
11:04:17 <byorgey> Syzygy|de: hehe, nice =)
11:08:50 <Syzygy|de> byorgey: Basically, I spent the day learning how to deal with the CUDA platform for generic GPU programming. While lunching, I spoke to one of the instructors, who told me that NVidia have a researcher collaboration programme, where university affilliated researchers can requisition GeForce cards for research projects, and NVidia have yet to deny an application.
11:09:01 <Syzygy|de> So I'm thinking about writing topological computation algorithms for GPUs.
11:09:19 <byorgey> Syzygy|de: sounds pretty cool!
11:09:28 <Syzygy|de> :)
11:12:06 <dons> dcoutts_: http://aur.archlinux.org/packages.php?ID=17719
11:12:06 <lambdabot> Title: AUR (en) - hback
11:12:11 <dons> gtk2hs games :)
11:12:17 <dcoutts_> yay
11:12:46 <dons> with sound.
11:13:35 <therp> hmm why are so many interesting papers I stumble across recently from chalmers university?
11:13:43 <int-e> sound :)  system $ "mplayer " ++ f ++ "> /dev/null &"
11:14:03 <dcoutts_> therp: because they have a great FP group
11:14:30 * therp wonders what his local university is good at..
11:14:56 <dcoutts_> therp: I believe the technical reason is "Chalmers ftw!!1"
11:15:03 <dons> hehe
11:15:32 <therp> oh.. wikipedia tells it's a private university.
11:15:37 <dcoutts_> erm, no
11:16:18 <ronwalf> Is there a way to reference type variables in a function definition?
11:16:37 <PeakerWork> all the cool FRP packages are not in hackage :-(
11:16:40 <PeakerWork> (except Yampa)
11:16:48 <dcoutts_> therp: where does it say that?
11:17:13 <therp> dcoutts_: http://en.wikipedia.org/wiki/Chalmers_University_of_Technology - on the right hand side in the box "Type:"
11:17:22 <dons> dcoutts_: we have an arch haskell overlay now, http://code.haskell.org/arch/x86_64/ 250 packages so far. more to come now gtk2hs is working as a dependency target
11:17:22 <lambdabot> Title: Index of /arch/x86_64
11:17:33 <Saizan> ronwalf: search the ghc manual for ScoperTypeVariables, or you can use asTypeOf
11:17:37 <dons> those are all automatically generated direct from .cabal files
11:17:58 <dcoutts_> therp: hmm, weird.
11:18:08 <dcoutts_> dons: great
11:18:19 <ronwalf> Saizan: Am I a bad man to use a bazillion type extensions?
11:18:34 <Deewiant> not if they'll be in Haskell'
11:18:40 <Saizan> s/Scoper/Scoped/
11:18:57 <Saizan> ronwalf: not so much if you don't care about portability
11:19:04 <dcoutts_> dons: I think that is the best answer to the arguments in favour of autoconf based build systems
11:19:25 <dons> right. clear, declarative specs. easy porting.
11:19:29 <ronwalf> Saizan: I'm using Wouter's extensible datatypes.  I've lost portability a while ago :(
11:20:04 <dcoutts_> dons: you've added the majority of those in a few days once the tool was working. That's basically impossible if you have to manually verify the deps of every package as you do with autoconf.
11:20:11 <dons> exactly.
11:20:24 <dcoutts_> dons: there was a long argument about this issue on the darcs devel list
11:20:26 <dons> once the tool does the translation, productivity increases say, 100 fold.
11:20:31 <dcoutts_> yep
11:20:41 <dons> i can port 200 packages in a day, instead of maybe 10-15
11:20:48 <dcoutts_> dons: we found the same with gentoo
11:21:15 <dons> yeah, its a no brainer. if anything, it argues we should have more standardisation, and less custom cases
11:21:21 <dcoutts_> right
11:21:42 <dons> i'll write a blog post about this during the week, i think
11:21:49 <dons> since everything worked so well, its a good story
11:21:54 <dcoutts_> :-)
11:22:15 <dcoutts_> I've been fixing up a few bug reports that came in after the 1.4 release
11:22:18 <dolio> dons: You think any of that array stuff is worth bringin up on a mailing list?
11:22:31 <dons> dolio: yeah, i think simon marlow is back now, so see what he says
11:22:37 <dons> maybe the mutable array write barrier is showing up
11:22:39 <dcoutts_> dons: I'll probably upload new point releases and announce today
11:22:44 <dons> cool
11:22:48 <dolio> glasgow-users?
11:22:57 <dons> yeah sure.
11:23:08 <dolio> All right. I'll put something together.
11:23:11 <luite> ~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~therp: chalmers does have some kind of contract with the government for some public funding though. I don't quite know all the details, and it's been a while since I've been there :)
11:23:13 <dons> cool
11:23:20 <luite> oops, some problem with my terminal, sorry :/
11:23:31 <lament> FNORD
11:24:31 <osfameron> how do I quell the monomorphism restriction errors again?  http://www.haskell.org/haskellwiki/Monomorphism_restriction doesn't seem to have the incantation
11:24:32 <lambdabot> Title: Monomorphism restriction - HaskellWiki
11:25:01 <Deewiant> -XNoMonomorphismRestriction?
11:25:12 <Y0uR_m0m> Hello
11:25:30 <mauke> {-# LANGUAGE NoMonomorphismRestriction #-}
11:25:58 <Y0uR_m0m> Is anyone there?
11:26:11 <Y0uR_m0m> Preferably someone who knows haskell :)?
11:26:13 <Deewiant> always
11:26:16 <dons> ?users
11:26:16 <lambdabot> Maximum users seen in #haskell: 471, currently: 447 (94.9%), active: 26 (5.8%)
11:26:27 <Zao> Y0uR_m0m: Have you've considered asking a question?
11:26:38 <mauke> it's .hr, don't bother
11:26:44 <Zao> Ah.
11:26:48 <lament> preflex: nickometer Y0uR_m0m
11:26:48 <preflex>  Y0uR_m0m is 99.7342% lame
11:26:53 <therp> luite: what was your status at chalmers? student?
11:26:56 <Zao> Quite accurate, that meter.
11:26:58 <Y0uR_m0m> lol
11:27:02 <dons> hah
11:27:02 <Deewiant> preflex: nickometer Zao
11:27:03 <preflex>  Zao is 0% lame
11:27:20 <Deewiant> where does that come from? O_o
11:27:34 <luite> therp: yes, but only for half a year, in an exchange program
11:27:35 <franko> better :)?
11:27:39 <lament> Deewiant: mostly common sense.
11:27:45 <therp> luite: erasmus?
11:27:47 <lament> franko: yes. Now you may ask your question :P
11:27:48 <luite> therp: yes
11:27:53 <franko> thnx :)
11:28:18 <osfameron> mauke: shiny, thanks
11:28:37 <franko> i have an assignment... To write a haskell function that finds the distance between the largest and the smallest element of a list
11:29:03 <Zao> Then I suggest that you write a haskell function to find the distance between the largest and smallest element of a list.
11:29:13 <lament> franko: that's not a question
11:29:31 <osfameron> sometimes I just need to quell the warning in order to see what the type it's going to write is :-)
11:29:44 <franko> Zao, are you as helpful as you are funny :)?
11:30:05 <Zao> franko: If you make an effort to learn as opposed to the other dozen lazy students at your uni, possibly.
11:30:07 <roconnor> Zao: please, if you are not going to be helpful, better to say nothing.
11:30:18 <osfameron> franko: why don't you explain what you've already done to try to solve the problem, and explain where you're having trouble?
11:30:18 <franko> lament: the question is: Is there anyone here willing to help me ?
11:30:33 <lament> franko: you mean, do your homework for you?
11:30:35 <mauke> I vote "no"
11:30:42 <lament> franko: we can help you. We won't do your homework for you.
11:31:12 <franko> ok, i don't need you doing it for me
11:31:24 <_cs> I'm fairly new to parsec and haskell.  I'm parsing a "sparse" file, in that I only care about one type of line and throw the rest away.  How should I do that?  Something like "field <|> stuff" forces stuff to return something meaningful (I think).
11:31:33 <franko> it's just that, we don't have such great materials to study from
11:31:47 <lament> franko: well, all the functions you need are in the Prelude ( http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html )
11:31:48 <lambdabot> http://tinyurl.com/y4wexy
11:31:58 <therp> franko: try the haskell book dons is writing :)
11:32:26 <therp> sorry forgot the title..
11:33:22 <franko> lament: which function should I use to iterate throgh the list?
11:33:43 <therp> franko: the most generic one is foldl/foldr
11:34:04 <therp> franko: but you don't have to go for higher order functions like these.. try with simple recursion first
11:34:08 <proq> therp: does that mean it's available somewhere?
11:34:48 <therp> proq: http://book.realworldhaskell.org/
11:34:50 <lambdabot> Title: Real World Haskell
11:35:23 <franko> therp: recursion? can you give me a couple of pointers to what that recursion should do?
11:35:39 <nus> huh
11:35:45 <therp> franko: no, I can't. that's where the magic happens and all the work
11:35:47 <mauke> @where real
11:35:47 <lambdabot> I know nothing about real.
11:35:52 <franko> lol
11:35:59 <lament> I would do it without any recursion or iteration
11:36:09 <lament> there's already functions in the prelude that do pretty much exactly what you need
11:36:24 <lament> not sure if your teacher would accept that, though
11:36:27 <Zao> franko: A recursion should shave off part of the problem and feed the remaining part through the same function.
11:36:27 <franko> i suppose you aren't going to tell me what that functions are
11:36:28 <mauke> I bet predefined functions are not allowed
11:36:28 <Baughn> @hoogle evaluate
11:36:29 <lambdabot> Control.Exception.evaluate :: a -> IO a
11:36:58 <mauke> > liftM2 (-) maximum minimum [1,10,3,5,3,12]
11:37:10 <lambdabot>  11
11:37:17 <franko> it says predefined functions from additional libraries aren't allowed
11:37:19 <mauke> > liftM2 (-) maximum minimum [1,10,3,5,-3,12]
11:37:20 <lambdabot>  15
11:37:27 <lament> no, they're from the Prelude
11:37:29 <nus> franko, how do you measure dinstance? in general?
11:37:43 <Snark> sigh... it's not possible to spread the differend definitions for cases in different parts of a file : I'm going for heterogeneous lists...
11:37:44 <franko> hmm, largest - smallest
11:37:55 <osfameron> why are you using liftM2 ?
11:38:09 <mauke> osfameron: because it's the simplest solution
11:38:20 <franko> mauke: that actually works?
11:38:31 <mauke> franko: did you see lambdabot's replies?
11:38:31 <lament> i think he's doing it for obfuscation :)
11:38:34 <osfameron> mauke: wouldn't it be simplest to do:  maximum x - minimum x (where x is the list)
11:38:38 <osfameron> ?
11:38:43 <mauke> osfameron: then I'd have to repeat x
11:38:48 <Deewiant> osfameron: that's the same thing
11:38:50 <mauke> and/or use an explicit binding
11:38:51 <osfameron> mauke: gosh, that's really complicated?
11:38:57 <mauke> yes
11:39:01 <lament> osfameron: he's a Haskeller :)
11:39:09 <mauke> <GumbyBRAIN> my hovercraft is full of phds?
11:39:18 <franko> oh, i didn't realize lambdabot is actually a bot :)
11:39:32 <osfameron> I don't understand what liftM2 does, whereas I understand a function call
11:39:49 <lament> :t liftM2
11:40:01 <mauke> liftM2 c f g x == f x `c` g x
11:40:05 <lambdabot> thread killed
11:40:18 <lament> :t liftM2
11:40:21 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:40:26 <mauke> there we go
11:40:42 <franko> errm.. what does that mean :)?
11:40:56 <lament> franko: you don't need this for your assignment.
11:41:03 <lament> (you don't need liftM2)
11:41:12 <dcoutts> Saizan: ping
11:41:13 <franko> oh
11:41:18 <Saizan> dcoutts: pong
11:41:28 <franko> but then i don't know what DO i need :(
11:41:51 <dcoutts> Saizan: do you have a blog you can use? the community wants to know what you're doing :-)
11:42:00 <mauke> that's where the whole "writing a program" part comes in
11:42:13 <lament> franko: you should be able to figure it out, now that the magical functions have been mentioned :)
11:42:28 <franko> magical functions, you mean max and min?
11:42:36 <dcoutts> Saizan: see http://hackage.haskell.org/trac/summer-of-code/wiki/progress2008
11:42:38 <lambdabot> Title: progress2008 - Haskell.org Google Summer of Code - Trac
11:44:26 <franko> ok, i think i got it
11:44:30 <Saizan> dcoutts: heh, ok :) i'm opening one on blogspot then
11:44:57 <franko> > let x = [1,10,6,7]; maximum x - minimum x
11:44:58 <lambdabot>  Parse error at end of input
11:45:00 <franko> > let x = [1,10,6,7]; maximum x - minimum x;
11:45:01 <lambdabot>  Parse error at ";" (column 42)
11:45:24 <byorgey> Saizan: let me know what it is, so I can be sure to include it in the HWN
11:45:34 <byorgey> sometimes it can take a while to get added to Planet Haskell
11:45:35 <dcoutts> Saizan: cool
11:45:35 <franko> hmm, it works in my GHCi
11:46:07 <fons> hi
11:46:49 <mauke> > let x = [1,10,6,7] in maximum x - minimum x
11:46:51 <lambdabot>  9
11:46:56 <franko> oh
11:46:58 <franko> IN
11:47:12 <franko> thank you :)
11:47:30 <franko> thanks, all of you
11:47:37 <fons> can the maximum tuple size supported by ghc (62 as of version 6.8.2) be accesed  somewhere?
11:47:39 * franko sends flowers to everyone
11:47:42 <fons> or is it hardcoded?
11:48:25 <lament> franko: as payment for our homework service, try to understand what the liftM2 solution does :)
11:48:41 <franko> ok, i will :)
11:48:42 <mauke> haha
11:48:44 <franko> but laters
11:48:52 <mauke> don't do it, your brain will explode!
11:48:56 <franko> right now the Croatia - Poland match is starting :)
11:49:02 <franko> (i'm from croatia) :)
11:49:07 <mauke> what about Germany - Austria?
11:49:27 <franko> don't really care 'bout them :)
11:49:33 <franko> we already beat them
11:49:39 <newsham> fons: dont know the ansewr, but curious why you want it.
11:49:56 <franko> anyways, i'll try to learn a bit more about haskell, thnx once again
11:49:57 <franko> byee
11:50:08 <mauke> bye
11:50:19 <mauke> what a nice young man
11:50:29 <newsham> fons: how about (a, (b, (c, (d, (e, f))))  ?
11:51:37 <mauke> (a, (b, (c, (d, (e, (f, ()))))))
11:52:02 <fons> newsham: I'm creating instances
11:52:18 <fons> and besides, nesting is much uglier than using tuples
11:52:19 <newsham> mauke: the ()'s not really necessary
11:52:56 <lilachaze> fons: haskell's handling of tuples with instances is somewhat unfortunate :(
11:53:00 <newsham> data Fons6 a b c d e f = Fons6 a b c d e f
11:53:31 <fons> lilachaze: I'm well aware :)
11:53:45 * Baughn wonders why the profiler totally fails to collect any profiling data on LB
11:53:55 <fons> I'm working on a DSL for system modelling
11:54:03 <fons> processes are modeeled as functions
11:54:06 <Baughn> (Any ideas? It's just giving me an empty file.. with a header, so not totally empty)
11:54:21 <fons> which might have different numbers of inputs and outputs
11:54:50 <lilachaze> fons: if it were me, i'd look at using template haskell to generate the instances
11:55:00 <fons> the variable number of inputs of the functions is habdled with a trick similar to the one used by Printf
11:55:08 <fons> lilachaze: sure, taht's exactly what I'm using
11:55:41 <fons> lilachaze: but it breaks when creating instances for tuples larger than 62
11:56:02 <fons> that's why I wanted to know if that upper limit is accesible somehow
11:56:09 <fons> I wouldn't want to ahrdcode
11:56:09 * lilachaze has a different trick for functions with variable numbers of arguments
11:56:13 <fons> hardcode it
11:56:27 <fons> lilachaze: Id like to know about it
11:57:08 <hpaste>  lilachaze pasted "lisp-style "list" function" at http://hpaste.org/8368
11:58:03 <orbitz> are bitwise operators built into haskell?
11:58:21 <fons> so anyway ... no one knows how to access the upper size limit of tuples in GHC?
11:58:37 <fons> orbitz: Data.BIts if I recall properly
11:58:41 <fons> Data.Bits
11:59:05 <byorgey> > 3 .&. 22
11:59:06 <lambdabot>  Add a type signature
11:59:09 <nus> hmm, is there a language with infinite tuple? that's what lists are for, aren't they?
11:59:10 <byorgey> > 3 .&. 22 :: Int
11:59:11 <lambdabot>  2
11:59:22 <orbitz> > 1 `shiftL` 2
11:59:22 <lambdabot>  Add a type signature
11:59:30 <fons> Uhm .. I'm afraid I'm going to hardcode 62 as that limit
11:59:33 <byorgey> nus: an infinite tuple is not quite the same as a list
11:59:40 <newsham> nus: isabelle defines tuples in terms of pairs (a, (b, ...))
11:59:42 <byorgey> nus: in a list, all the elements must be of the same type
11:59:55 <byorgey> nus: whereas in a tuple the elements can be of different types
12:00:00 <pejo> fons, how does it "break"?
12:00:02 <orbitz> > 1::Int `shiftL` 2::Int
12:00:03 <lambdabot>  Parse error at "`shif..." (column 8)
12:00:07 <byorgey> with that said, you'd have trouble defining the type of an infinite tuple =)
12:00:18 <fons> pejo, do you want the exact error?
12:00:24 <nus> "62 - The new meaning of the Universe"
12:00:34 <mauke> > 1 `shiftL` 2 :: Int
12:00:34 <fons> pejo: it said something about an upper limit of 62
12:00:42 <lambdabot>  4
12:00:49 <fons> let me get the exact error ...
12:01:09 <mauke> > complement 0
12:01:10 <lambdabot>  Add a type signature
12:01:14 <mauke> > complement 0 :: Int
12:01:15 <lambdabot>  -1
12:01:20 <pejo> fons, oh, so the compiler realizes you've gone past the limit, and gives you an error message?
12:01:30 <fons> pejo: yes
12:02:02 <nus> byorgey, I'd call them bags, anyway (-:
12:02:42 <lilachaze> doesn't 'bag' usually refer to an unordered multiset?
12:02:48 <byorgey> nus: sure, although I've usually heard the term 'bag' used to refer to a collection of unordered elements, all of the same type
12:02:58 <fons>     A 63-tuple is too large for GHC
12:02:59 <fons>       (max size is 62)
12:02:59 <fons>       Workaround: use nested tuples or define a data type
12:03:07 <byorgey> s/collection of unordered/unordered collection/
12:03:12 <nus> every freaking language designer has his very own notions of what sets, tuples, bags, lists are [-;
12:03:44 <lament> yes, can't we all just standardize on something and never change it!
12:05:38 <nus> In the Beginning there was a cons. (-;
12:05:39 <fons> Uhm, Igloo pointed out a cool solution to my problem (sorry for the cross-channeling)
12:05:54 <fons> Igloo: fons: Oh, you want to know for TH presumably? in which case you might be able to do it by reifying larger and larger sizes until you get an exception, or something
12:06:02 <nus> then it begot one-way linked lists ((-;
12:06:08 <fons> cool!
12:06:35 <newsham> in the beginning there was untyped
12:06:52 <nus> undefined
12:06:54 <nus> (-:
12:07:00 <lament> in the beginning there was empty set
12:07:14 <mauke> in the beginning there was SKK
12:07:59 <Baughn> In the beginning there were ratchets and clanks
12:10:02 <pizza_> back when we had only 1 bit of memory we never had these organizational problems
12:10:41 <mauke> preflex: remember pizza back when we had only 1 bit of memory we never had these organizational problems
12:14:32 <noamz> how do you catch non-exhaustive pattern exceptions in haskell?
12:14:42 <noamz> I want the equivalent of "(fn 0 => 0) 1 handle Match => 2" in sml
12:15:08 <mauke> bad idea :-/
12:15:26 <noamz> why is that?
12:15:31 <mauke> laziness
12:15:52 <hpaste>  morrow pasted "making  javascript bearable" at http://hpaste.org/8369
12:16:32 <noamz> but you can catch exceptions inside the IO monad, right?
12:16:36 <mauke> yes
12:16:46 <noamz> there is even a PatternMatchFail exception
12:16:48 <mauke> :t evaluate
12:16:50 <lambdabot> forall a. (Testable a) => a -> Gen Result
12:16:51 <noamz> but it doesn't seem to do what I want
12:16:53 <mauke> what
12:17:04 <mauke> @index evaluate
12:17:04 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
12:17:11 <mauke> :t Control.Exception.evaluate
12:17:13 <lambdabot> forall a. a -> IO a
12:17:17 <mauke> there we go
12:17:43 <byorgey> noamz: why not just add an extra case with a wildcard pattern?
12:18:09 <byorgey> noamz: catching a non-exhaustive pattern exception, even if possible, is not a very haskellish way to do things
12:18:38 <byorgey> or you could change the return type from   foo  to  Maybe foo
12:19:09 <byorgey> then deal with the two possible cases (Nothing or Just x) at the call site, instead of catching an exception
12:19:22 <byorgey> exceptions = yuk
12:19:35 <mauke> hater :(
12:19:48 <orbitz> > pl \acc x -> x + (acc `shiftL` 1)
12:19:48 <lambdabot>  Parse error at "\acc" (column 4)
12:20:26 <mauke> s/> /@/
12:20:35 <orbitz> @ pl \acc x -> x + (acc `shiftL` 1)
12:20:36 <noamz> byorgey: I could probably do that, but I am still confused why I can't catch a pattern-matching exception
12:20:38 <orbitz> @pl \acc x -> x + (acc `shiftL` 1)
12:20:39 <lambdabot> (+) . (`shiftL` 1)
12:20:55 <orbitz> :t  (+) . (`shiftL` 1)
12:20:56 <lambdabot> forall a. (Bits a) => a -> a -> a
12:21:20 <byorgey> noamz: maybe paste your code?
12:21:25 <byorgey> !paste
12:21:25 <hpaste> Haskell paste bin: http://hpaste.org/
12:21:40 <orbitz> @pl \acc x -> (1 + x) + (acc `shiftL` 1)
12:21:40 <lambdabot> (. (1 +)) . (+) . (`shiftL` 1)
12:21:54 <byorgey> noamz: note that to use exceptions you will have to put your code in the IO monad.
12:22:02 <byorgey> which would be a shame if it doesn't actually do any I/O.
12:23:06 <noamz> here's one try:
12:23:09 <noamz> > return ((\0 -> 0) 1) `catch` \e -> return 10
12:23:09 <noamz> *** Exception: <interactive>:1:9-15: Non-exhaustive patterns in lambda
12:23:10 <lambdabot>  <IO Integer>
12:23:36 <mauke> noamz: yeah, 'return ...' doesn't throw
12:25:21 <dieJana> what does "nulltype" mean to you?
12:25:50 <dieJana> (I suppose there "don't ask to ask" policy around here)
12:26:01 <mauke> nothing, without context
12:26:27 <dieJana> in the context of type theory
12:28:19 <orbitz> can i easily fold over a list but taking 8 elements at a time?
12:29:07 <Deewiant> > let x `inGroupsOf` n = map (take n) . takeWhile (not.null) . iterate (drop n) $ x in [1..] `inGroupsOf` 8
12:29:13 <lambdabot>  [[1,2,3,4,5,6,7,8],[9,10,11,12,13,14,15,16],[17,18,19,20,21,22,23,24],[25,26...
12:30:05 <byorgey> dieJana: maybe a type with no inhabitants?
12:30:28 <byorgey> dieJana: I can't say I've ever heard of that though
12:32:11 <mapreduce> @users
12:32:12 <lambdabot> Maximum users seen in #haskell: 471, currently: 447 (94.9%), active: 23 (5.1%)
12:35:42 <noamz> okay let me try to ask my question a different way
12:36:00 <noamz> I want to write a function papp :: (a -> b) -> a -> b -> b
12:36:08 <hukolele> @pl \l -> l ++ cycle' l
12:36:09 <lambdabot> ap (++) cycle'
12:36:14 <noamz> such that papp f x y = f(x) if f is defined on x
12:36:22 <noamz> and papp f x y = y if f(x) raises a match exception
12:36:26 <noamz> is that possible?
12:37:33 <mauke> maybe with unsafePerformIO
12:37:49 <dieJana> byorgey: yeah, maybe, thanks!
12:38:04 <sjanssen> noamz: no, it is not possible
12:38:28 <sjanssen> papp :: (a -> b) -> a -> b -> IO b -- is possible
12:38:53 <noamz> sjanssen: and how would you write that?
12:39:04 <fons> you cannot catch exceptions in pure code
12:39:16 <fons> only throw them
12:39:16 <sjanssen> noamz: check out Control.Exception
12:40:53 <fons> lilachaze: your trick to implement functions with variable arguments is actually quite similar to the one used byt printf
12:40:58 <fons> by*
12:41:22 <rwbarton> noamz: have you thought about this case:
12:41:26 <rwbarton> > let { f [0] = [0] ; f (x:xs) = x : (f xs) } in (f [1,2,3])
12:41:27 <lambdabot>   Non-exhaustive patterns in function f
12:41:30 <rwbarton> > let { f [0] = [0] ; f (x:xs) = x : (f xs) } in head (f [1,2,3])
12:41:32 <lambdabot>  1
12:42:50 <rwbarton> what would   let { f [0] = [0] ; f (x:xs) = x : (f xs) } in head (papp f [1,2,3] [])  do?
12:44:03 <mapreduce> How would you get ["123", "456"] from "123abc456"?
12:44:46 <mapreduce> I'm thinking something with zip and \x y -> isDigit x != isDigit y but I get lost after that.
12:45:24 <rwbarton> > groupBy (\x y -> isDigit x == isDigit y) "123abc456"
12:45:26 <lambdabot>  ["123","abc","456"]
12:46:02 <rwbarton> > filter (isDigit . head) $ groupBy (\x y -> isDigit x == isDigit y) "123abc456"
12:46:03 <lambdabot>  ["123","456"]
12:46:08 <rwbarton> kind of ugly
12:46:21 <Deewiant> > groupBy ((==) `on` isDigit) "123abc456"
12:46:23 <lambdabot>  ["123","abc","456"]
12:47:31 <Deewiant> > let f x = let (a,b) = span isDigit x in [a, takeWhile isDigit . dropWhile (not.isDigit) $ b] in f "123abc456"
12:47:33 <lambdabot>  ["123","456"]
12:47:35 <Deewiant> :-P
12:48:27 <noamz> rwbarton: thanks for the example
12:48:57 <noamz> rwbarton: i don't think this sort of case shows up in what I'm trying to do...but i'll go back and think harder...
12:48:58 <Athas> Is Yi under active development?
12:49:12 <rwbarton> > words . map (\x -> if isDigit x then x else ' ') $ "123abc456"
12:49:13 <lambdabot>  ["123","456"]
12:50:55 <Tigran``> > (\_ -> ["123", "456"]) "123abc456"
12:50:56 <hpaste>  morrow annotated "making  javascript bearable" with "debug "shell"" at http://hpaste.org/8369#a1
12:50:57 <lambdabot>  ["123","456"]
12:50:59 <Tigran``> Huzzah!
12:54:52 <byorgey> Athas: yes, it is
12:56:18 <shachaf> \evensidemargin 0
12:56:18 <shachaf> \oddsidemargin 0
12:56:28 <shachaf> Oops, sorry.
12:59:52 <hpaste>  morrow annotated "making  javascript bearable" with "fixed (i think)" at http://hpaste.org/8369#a2
13:27:12 <Peaker> its kind of frustrating to read about all these wonderful libraries, and that all of these are not a "cabal install" away
13:29:02 <byorgey> Peaker: hm?
13:29:20 <Peaker> byorgey, fudgets, frantk, fruit, grapefruit, ...
13:35:51 <shachaf> byorgey is an excellent library indeed.
13:35:53 <Peaker> I read about GrapeFruit (I think it was) and they said that a GUI type is an arrow from (a, UserInput) to (b, OutputToUser)  where UserInput is keyboard/mouse input, and OutputToUser is stuff to present to the user/etc.  a,b are arbitrary things the gui collects from the surroundings or from the user..
13:35:58 <Peaker> hehe
13:36:05 <byorgey> shachaf: why, thank you ;)
13:36:26 <Peaker> This is very elegant, however I am wondering whether the Signal Function/arrow they used is not problematically naive -- as its signal is an Image
13:37:19 <Peaker> I was thinking that maybe Signal Functions should actually process differentials and generate differentials
13:38:32 <Peaker> So an SF arrow from (a,Keyboard/Mouse) to (b,Image) would get diffs about a the keyboard and the mouse and generate diffs on b and the image -- for efficient draw operations
13:40:15 <Peaker> maybe the naive approach can be made fast by serious compiler optimizations though
14:04:28 * byorgey sings the lambda-song
14:09:31 <Peaker> "why FP" is a cool paper
14:12:06 <Baughn> ..wouldn't you know, when I try to debug a memory leak, /it disappears/
14:12:31 <Baughn> Anyone happen to know when/if the profiler will be made to work with threading?
14:21:28 <Peaker> I wonder why he implements minimax as min calling max calling min, instead of only search calling search and negating its result
14:22:21 <MyCatVerbs> Peaker: they're isomorphic in the end though anyway.
14:22:29 <Peaker> yeah, but a little more duplication
14:22:42 <MyCatVerbs> Peaker: but yeah, search recursing and negating is... well, conceptually a lot cleaner.
14:23:45 <MyCatVerbs> I mean, you end up that way with -one- function that contains the definition of your search strategy, rather than having it spread over three.
14:24:26 <MyCatVerbs> Like if you wanted to change the min-calls-max approach to add alpha-beta pruning, it'd be a lot more work than to do the same using the search-recurses approach.
14:24:54 <Peaker> he is wrong about noughts and crosses being not practical to search entirely.. if you nub identical positions then its a pretty small game tree
14:25:07 <cjb> symmetric, too?
14:25:24 <Peaker> MyCatVerbs, I agree, I never thought someone actually used min/max literally in minimax... I always thought it was a bad name too :)  maximax it is :)
14:26:36 <MyCatVerbs> Peaker: I kinda like it. It's just that...
14:28:29 <MyCatVerbs> Peaker: hrmn. You could write search :: Bool -> ..., then have search maxing ... = let select = case maxing of { True -> max; false -> min; } in ...
14:30:00 <Peaker> MyCatVerbs, but then a "win" is not 1 but 1 or -1 depending on whether it is me
14:30:11 <MyCatVerbs> Peaker: alternatively, you could write a search :: ((a -> a -> a),(a -> a -> a)) -> ... where he usual invocation is "search max min ..." and the recursive case is something like search (f,g) = search (g,f) ... where ...
14:30:39 <MyCatVerbs> The former of those would be a waste of time, admittedly.
14:31:02 <MyCatVerbs> I kinda like the latter a little bit because it doesn't build up a huge chain of negations, though.
14:31:03 <Peaker> MyCatVerbs, note its not just min,max that have to be replaced but also the meaning of a win
14:31:49 <MyCatVerbs> Peaker: isn't the... okay, what if you give comparison operators instead?
14:32:44 <Peaker> MyCatVerbs, if you put "winValue" that's negated each time then its probably ok, but defeats the purpose
14:33:11 <MyCatVerbs> Peaker: you only have to compare values to one another though, don't you?
14:33:18 <hpaste>  morrow annotated "making  javascript bearable" with "oops" at http://hpaste.org/8369#a3
14:33:40 <Peaker> MyCatVerbs, yeah, but if you encounter a "win" (3 X's in a row), is that better or worse than a 0 (no winner)?
14:34:53 <MyCatVerbs> Peaker: yes, because ["xxx","oox","xoo"] > ["xxo","oox","xxo"], using your comparison operator ">".
14:35:11 <hpaste>  morrow annotated "making  javascript bearable" with "another fix" at http://hpaste.org/8369#a4
14:35:11 <therp> Knuth should have used Haskell not MIX in tAoCP.
14:35:39 <roconnor> @quote sortBy
14:35:39 <lambdabot>  @free says: @free sortBy ==> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
14:35:47 <MyCatVerbs> Peaker: min-max usually involves going after a "high score" rather than an absolute win or lose, after all, since you can't often afford to search the game tree to completion.
14:36:34 <Peaker> MyCatVerbs, its simpler to say that you can search it to completion and then treat the partial-search as a search that yields more values except -1,0,1
14:38:04 <MyCatVerbs> Peaker: you've lost me here somewhere.
14:38:24 <MyCatVerbs> Peaker: a "win" is simply the upper bound on the score that you can achieve, right? A "loss" being the lower bound.
14:38:47 <MyCatVerbs> Peaker: so you can always tell a win from an intermediate or even a loss because a win is always greater than any non-win value.
14:38:48 <Peaker> MyCatVerbs, yeah
14:38:57 <Peaker> MyCatVerbs, but a "win" is subjective
14:39:10 <MyCatVerbs> Peaker: it is?
14:39:25 <Peaker> MyCatVerbs, for X an X win is a win, but an O win is a lose, and vice versa
14:40:11 <MyCatVerbs> Peaker: yyyyyyes... so you reverse the order of comparisons during the 'mini' stages.
14:40:40 <Peaker> but when looking at the board, you see "XXX" (an X win), what value do you assign to it?
14:40:46 <Peaker> if you're X, its 1, if you're O its -1
14:41:21 <MyCatVerbs> ...? I'm sorry, I'm failing utterly to see where this presents a conceptual difficulty?
14:41:24 <edwardk> minimax/alphabeta?
14:42:03 <MyCatVerbs> Peaker: just pick a convention. Let's say "X wins == 1", right?
14:42:17 <Peaker> MyCatVerbs, you can do that - but its more code than just saying "all wins == 1" and negating each time
14:42:30 <MyCatVerbs> Peaker: then if you're calculating moves for O, use a comparison operator which runs backwards.
14:42:38 <Peaker> MyCatVerbs, I'm merely saying that it takes a bit more code than the negating recursion, because you have to make the win convention objective
14:42:47 <MyCatVerbs> Peaker: what... is the issue? I don't see why you're even bothering to mention this?
14:43:13 <MyCatVerbs> (Yes, the sky is blue. No, this won't break your camera. Etc.)
14:43:15 <Peaker> MyCatVerbs, well, you said you can replace the negating recursion with one that gives min/max instead, so I just said you also need to fix the way you handle wins if you do that
14:43:56 <MyCatVerbs> Peaker: if you search the tree to completion, you get back a maximum achievable score and a path to it, yes?
14:44:06 <Peaker> MyCatVerbs, yes
14:44:22 <MyCatVerbs> Peaker: whoever called the "search" function can then make up their own mind about whether that result is a win for them or not.
14:44:24 <Peaker> MyCatVerbs, but you don't want to assign a maximal value to one that makes you lose :)
14:45:39 <Peaker> MyCatVerbs, the caller cannot fix a result if you used a combination of   cmp=max,win=-1, and cmp=min,win=1, instead of cmp=max,win=1, ...   that result is simply wrong
14:46:05 <MyCatVerbs> Peaker: I'm... what?
14:46:26 <Peaker> MyCatVerbs, its not that important, never mind
14:46:29 <MyCatVerbs> Peaker: why do you care about whether some inbred twit can't even get a calling convention right?
14:46:34 <Cheery> hi, have you found a site that explains how to calculate the product of two DFAs?
14:46:53 <Cheery> I have hard time finding one
14:48:00 <osfameron> @pl (\a b -> length a == length b)
14:48:00 <lambdabot> (. length) . (==) . length
14:48:09 <Cheery> (asking here, because I can count on it that somebody on haskell-channel knows something, whatever question related to computations I'd ever ask.)
14:48:12 <osfameron> huh?
14:49:18 <Cheery> it does not help that DFA is an acronym for crapload of things
14:49:31 <ddarius> Death From Above!
14:49:43 <MyCatVerbs> Cheery: personally, I wasn't even aware that there was such a *concept* as taking the product of finite automata.
14:49:45 <osfameron> o/ let's make love and listen to death from above o/
14:50:05 <MyCatVerbs> Cheery: what does DFA stand for in this context, then?
14:50:10 <edwardk> the product of two DFAs is usually a completely wrecked mech. at the very least one that can't walk ;)
14:50:51 <ahunter_> Hey, anyone here real familiar with the GranSim stuff in GHC?
14:50:54 <Cheery> deterministic finite automata
14:51:08 <Peaker> the Fudgets library and others of its ilk seem to be ~5-10 years old -- unmaintained?  Scary to use such stuff
14:51:38 <edwardk> cheery: i gathered as much. product in the sense that you have an alphabet consisting of the product of the two alphabets and you make two transitions at the same time?
14:51:42 <BMeph> Does anyone know 1) if there's a workup of "unpl" as a regular program; 2) where to find it if it exists? :)
14:52:25 <edwardk> bmeph: you can run lambdabot from the command line
14:52:32 <ahunter_> edwardk: I must say, you nearly brought a tear to my eye there, good to see BT fans still around :)
14:52:36 <BMeph> Peaker: Send a note of to conal directly - if he has any time to respond at all, he will. :)
14:52:51 <Peaker> oh naughts and crosses is the unlimited-board tic-tac-toe...  then I take back my statement above :)
14:52:56 <edwardk> ahunter: =)
14:53:12 <BMeph> edwardk: No, YOU can run lambdabot. I'm stuck using Ween-doze at work. ;p
14:54:02 <Cheery> edwardk: hmm... not sure. I want to union two DFAs, and read that you can extract a product from two DFAs, then take in all accepted states to union them
14:54:02 <Peaker> BMeph, what horrible workplace forces you to run Windows?
14:54:17 * ddarius used to develop lambdabot on Windows.
14:54:49 <edwardk> ahunter: i wrote a mech editor back about yesh. 15 years ago. http://www.sarna.net/files/download/programs/designers/mech/dos/mech_ed_1.0.zip still has it online =)
14:55:33 <BMeph> Peaker: acoustics manufacturing plant. I sometimes "cheat" by loading VMWare on a machine... ;)
14:55:44 <gubagem> mech editor for battletech?
14:55:51 <edwardk> gubagem yeah
14:56:02 <gubagem> i used to play the hell out of that game when i was younger
14:56:03 <ahunter_> edwardk: think I may have used that at some point :) One of my pet projects that I need to get around to Real Soon Now is making a new editor that fixes the few real annoyances I have with HMP and can't fix due to silly closed source-ness
14:56:12 <ahunter_> I should obviously write it in Haskell
14:56:21 <edwardk> the funny thing is i got registrations for that thing up until about 6 years ago. =)
14:56:23 <BMeph> Mech ed? Is that BattleTech's version of Drivers' Ed? ;)
14:56:38 <gubagem> i remember the inner sphere medium laser was at a very nice point for packing in maximum damage at a decent range with low heat
14:57:11 <gubagem> yea its where they shave your head and strap on a neurohelmet and let you remotely 'drive' one around a ruined farm on some periphery system
14:57:13 <edwardk> i was always a big fan of abusing xl engines in a 21 ton hovercraft and cruising into your nice expensive mech's leg at 60+ hexes a turn.
14:57:22 <gubagem> ouch
14:57:32 <gubagem> i never much got into physical or vehicle
14:57:35 <edwardk> i take 10 points of damage to my front armor. you. you lose a mech. i was never in range to be shot ;)
14:57:42 <ahunter_> edwardk: Have we met before?  I've definitely met people on BT forums who are fans of that :)
14:57:42 <gubagem> did alot of designing lighter mechs and dueling
14:57:47 <Peaker> are fudgets a precursor to FRP? Does FRP "obselete" fudgets?
14:58:00 <gubagem> whats a fudget
14:58:11 <Peaker> gubagem, GUI library from the 90's
14:58:14 <Cheery> so I need to keep searching the solution myself.
14:58:19 <thomashartman1> http://www.reddit.com/info/6ngfy/comments/c04dhy4
14:58:20 <lambdabot> Title: reddit.com: An Interesting Little Problem
14:58:31 <edwardk> ahunter: very possible
14:58:44 <thomashartman1> seems like what I need is a scanl that doesn't overflow.
14:58:49 <thomashartman1> best way to do this?
14:58:55 <ahunter_> edwardk: what do you go by on CBT/HMP, if you indeed go there?
14:59:14 <edwardk> actually i don't
14:59:26 <edwardk> i haven't actively played anything battletechish in probably 10 years
14:59:29 <ahunter_> heh
14:59:37 <ahunter_> what a pity
14:59:44 <ahunter_> Megamek is actually pretty damn good these days
14:59:47 <edwardk> i used to play on the old muse
14:59:58 <thomashartman1> define scans for arrays? just use bytestring (which has scans defined) for a bytestring translation of a list of integers?
15:00:06 <thomashartman1> how would you guys do this?
15:00:39 <sclv> @src scanl
15:00:39 <lambdabot> scanl f q ls = q : case ls of
15:00:39 <lambdabot>     []   -> []
15:00:39 <lambdabot>     x:xs -> scanl f (f q x) xs
15:00:43 <edwardk> wow i just realized that was a long time ago: http://www.sarna.net/wiki/BattleTech_3025_MUSE
15:00:44 <lambdabot> Title: BattleTech 3025 MUSE - BattleTechWiki - Sarna.net Classic BattleTech Wiki
15:00:50 <Saizan> Cheery: you can easily describe the union of two DFA as an NFA, then you can convert that NFA to a DFA
15:01:14 <BMeph> gubagem: Except, if you're Clan, the farm isn't ruined...yet. ;)
15:01:17 <Cheery> Saizan: do you know where to find the algorithm?
15:01:21 <sclv> @src scanr
15:01:21 <lambdabot> scanr _ q0 []     =  [q0]
15:01:21 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
15:01:21 <lambdabot>     where qs@(q:_) = scanr f q0 xs
15:01:39 <edwardk> heh, the same event that killed the 3025 muse killed a MUD I used to run, since it was on the same hardware at worldchat. i never realized that
15:01:48 <Peaker> BMeph, fudgets is also conal's work? the website says Thomas Hallgreen
15:02:16 <Saizan> Cheery: googling NFA to DFA seems to give some valid results
15:02:19 <sclv> thomashartman1: just write stricter versions of the scans.
15:02:23 <Peaker> the Fudgets stuff seems to be in the pre-Arrow era
15:02:48 <ahunter_> edwardk: I'm only 20, what is a MUSE anyway? :P Similar to a MUD/etc?
15:03:00 <sclv> arrows for standard guis (as opposed to games) never made much sense to me.
15:03:09 <BMeph> Peaker: No, he isn't doing Fudgets, but much of his Reactive stuff is inspired by Fudgets.
15:03:43 <edwardk> ahunter: multi-user simulated environment. the basic idea was a mud/moo with a live simulator for mech combat, where you can look at your instruments, and flip switches in the mech in real time
15:03:49 <Peaker> BMeph, it seems to contain a subset of the knowledge of the other stuff I read about..   I wish I could avoid the "obselete" libs, and only see the state of the art
15:04:08 <ahunter_> edwardk: that actually seems pretty awesome
15:04:09 <edwardk> ahunter, a twitch gaming mud ;)
15:04:24 <edwardk> ahunter: it was quite compelling at the time
15:04:29 <sclv> if you have a click-response type pattern traditionally done by listeners, as opposed to a sort of continuous stream of robots moving around and shooting or whatever, arrows don't feel a conceptual match.
15:04:56 <BMeph> Peaker: Don't we all? However, a "bit-rot sniffer" is probably translatable to solving the Halting Problem. ;)
15:04:57 <Peaker> sclv, I think of arrows as merely a way to compose non-opaque functions
15:05:16 <Peaker> sclv, so these "functions" can do more interesting things than simply compute a result
15:05:36 <Peaker> BMeph, yes, and people routinely solve the halting problem manually :)
15:06:01 <Peaker> BMeph, I am sure people know which libs are superseded by which ones - and could relay this information forward..
15:06:33 <BMeph> Peaker: Yes, but do they _want_ to do it? ;)
15:06:37 <Cheery> Saizan: thank you
15:06:52 <Peaker> sclv, a GUI arrow makes sense to me when defined as (in Yampa terms):  GUI a b = SF (a, UserInput) (b, OutputToUser)
15:07:00 <edwardk> ahunter: anyways back in the day they had a few btech muses, simulated the major houses, had combats between them. people'd pile into a jumpship, head over on a dropship, land and do full scale battles, etc.
15:07:19 <Peaker> sclv, generally even a simple GUI has a computation of many inputs
15:07:26 <edwardk> er rather they were separate games, but within a game you'd have the houses with the jumpship/dropship/btech sim
15:07:32 <ahunter_> edwardk: Obviously, someone needs to make a MMO version of MW4, because that needs to happen again :P
15:07:49 <sclv> Peaker: right, but how would you translate that into, e.g., a clean way to think about an interface to gimp?
15:07:57 <ahunter_> edwardk: I, at least, would pay hundreds of dollars for World
15:08:02 <ahunter_> Of Battletech
15:08:55 <Peaker> sclv, gimp :: GUI ImageData ImageData
15:09:19 <Peaker> sclv, where ImageData is all the image data the gimp has (layers, etc)
15:10:00 <sclv> forget the actual drawing bit -- thats seperate. just think about all the panels and how selecting this tool makes other panels possible and greys other tools and ungreys other tools and etc.
15:10:23 <Peaker> sclv, those things are encapsulated in the value of the GUI type
15:10:51 <sclv> so they're all "new" every time you get any user input? yeech
15:11:35 <Peaker> sclv, no, not necessarily. did you see   www.apocalypse.org/~antony/work/pubs/defense.ppt ?
15:12:12 <sclv> not yet, I think. thanks for the link though! i've got to run, but i'll check it out.
15:13:41 <Peaker> that value just describes the GUI.. it is converted by a different function into an IO-monadic value, which can carry as much state as it wants (e.g current dialogs are open, etc)
15:17:21 <edwardk> ahunter: well, that would have to come down through microsoft i think, so it would be quite a tricky proposition.
15:18:02 <ahunter_> edwardk: yeah, yeah--we can but hope.
15:19:41 <Peaker> did anyone here play with conal's Reactive package?
15:21:41 * ddarius wonders if he could use Reactive internally..
15:23:34 <edwardk> ahunter: hrmm some of them seem to be still around: http://btech.mushpark.com/
15:23:37 <lambdabot> Title: Battletech 3065 - Home
15:24:36 <Peaker> Ok, if Reactive works, that's great. If not, I'll try to understand how to use Yampa again. Its tutorial and examples were a bit overwhelming for me at the first read
15:25:04 <ddarius> Reactive is quite a bit newer than Yampa and more actively maintained.
15:25:40 <Peaker> So it should not have obvious/glaring missing things that Yampa does have, right?
15:26:10 <ddarius> Peaker: That is not what my statement means.
15:26:51 <Peaker> I don't mean in terms of missing work, but for example, Yampa speaks of getting rid of time/space leak bugs by not exposing the signals, but instead exposing signal functions. Such an insight would be incorporated into Reactive, I'd suppose
15:28:32 <ddarius> Reactive works differently from Yampa.
15:29:06 <ddarius> One is not the continuation of the other.  They are both independent and still living projects.
15:29:09 <Peaker> I see. I guess I'll just have to play with them both
15:29:35 <Peaker> Thanks for the tips
15:30:31 <Peaker> I was also wondering why Yampa changed "Behavior" to "Signal"
15:31:20 <edwardk> do you think it would be too confusing if a non-haskell dialect made mdo the default do?
15:31:44 <edwardk> mainly to free up the superfluous keyword
15:32:07 <Philippa_> edwardk: depends on whether your desugaring uses mfix when it's not necessary or not
15:32:24 <edwardk> Philippa_: the mfix equivalent would only apear when its necessary
15:32:33 <edwardk> er appear
15:32:52 <Philippa_> go for it, then
15:33:15 <edwardk> yay one more rule ripped out of my parser =)
15:33:19 <Philippa_> it does admittedly make do a <- foo; a <- bar; ... behave oddly
15:33:40 <edwardk> my main concern is do a <- simplify a; return (f a)
15:33:41 <Philippa_> but there's a strong argument that the right response is "WTF did you write that anyway?"
15:33:41 <Cheery> zzz..... hang .. ppl who write larger than 1MB powerpoint presentations
15:36:25 <dons> Lemmih: dbus binding also missing buildinfo.in file?
15:36:26 <dons> config.status: error: cannot find input file: DBus.buildinfo.in
15:36:37 <Cheery> so there is a catch in transforming NFA to DFA... resulting DFA may be 2^n larger than the original
15:36:52 <ddarius> As is well known...
15:36:54 <edwardk> cheery: sure
15:37:46 <Cheery> is the penalty lesser if I merge two DFAs with that same algorithm?
15:38:30 <edwardk> well, work it out
15:38:49 <Cheery> yes, I'll need to
15:38:53 <Cheery> going to sleep
15:39:02 <Cheery> gn
15:42:30 <vincenz> @seen byorgey
15:42:30 <lambdabot> byorgey is in #haskell, ##logic, #xmonad and #haskell-blah. I last heard byorgey speak 1h 38m 2s ago.
15:44:15 <tusho> Someone needs to code a bear in haskell.
15:44:38 <bos> @seen dons
15:44:38 <lambdabot> dons is in #haskell, #haskell-soc, #arch-haskell, #ghc and #xmonad. I last heard dons speak 8m 11s ago.
15:44:48 <ddarius> @faq Can Shardik be programmed in Haskell?
15:44:48 <lambdabot> The answer is: Yes! Haskell can do that.
15:47:03 <tusho> ddarius: :-)
15:47:30 <deli2323> @seen deli2323
15:47:31 <lambdabot> You are in #haskell. I last heard you speak just now.
15:47:48 <deli2323> tusho: A bear?
15:47:58 <tusho> deli2323: Yes.
15:48:03 <tusho> A bear
15:52:00 <Peaker> Doesn't seem that "Examples" in the Reactive package work out of the box (a bunch of assertion failed inside Gtk/gdk)
15:53:55 <sjanssen> @seen gwern
15:53:55 <lambdabot> gwern is in #haskell, #ghc, #darcs and #xmonad. I last heard gwern speak 6h 46m 13s ago.
15:54:43 <sjanssen> @tell gwern the file limit stuff in mueval is no good -- hint can't open my package.conf!
15:54:43 <lambdabot> Consider it noted.
15:57:09 <dcoutts> dons: heh, I see you're extracting demos from gtk2hs now :-)
15:57:25 <dcoutts> dons: I guess I should bind the stuff needed to make that clock actually transparent
16:07:09 <Peaker> what does this syntax mean: import Control.Compose ((:.)(..), inO,inO2)
16:07:14 <Peaker> isn't there a missing comma there?
16:08:32 <thomashartman1> is there a strict list package up on hackage anywhere? I'm trying to do something lik e<lambdabot> scanl f q ls = q : case ls of
16:08:32 <thomashartman1> *** iblechbot (n=iblechbo@ppp-62-216-222-142.dynamic.mnet-online.de) has quit:
16:08:32 <thomashartman1>     Read error: 113 (No route to host)
16:08:32 <thomashartman1> <lambdabot>     []   -> []
16:08:33 <edwardk> peaker: that is saying bring in the class or data type named (:.) and all of its constructors and named fields
16:08:35 <thomashartman1> <lambdabot>mistake.
16:08:39 <thomashartman1> sorry.
16:09:00 <Peaker> edwardk, oh, thanks
16:09:05 <thomashartman1> trying to do something like: head $ scanr (+) 1 [1..(10^6)]
16:09:09 <edwardk> peaker: might be easier to read if (:.) wasn't infix. then it would be import Prelude (Either(..),some,other,stuff)
16:09:13 <thomashartman1> and have it work :)
16:11:04 <thomashartman1> or last $ scanl (+) 1 [1..(10^6)]
16:12:14 <thomashartman1> this is discussed at http://www.haskell.org/haskellwiki/Stack_overflow but other than suggesting to use a head strict list no solution is provided
16:12:14 <lambdabot> Title: Stack overflow - HaskellWiki
16:14:39 <sjanssen> thomashartman1: use strictify = foldr (\x xs -> (:xs) $! x) []
16:15:11 <sjanssen> this will make each cell of the list strict in the head
16:15:21 <adu> wow
16:16:20 <adu> i just learned about HOC: A Haskell to Objective-C binding
16:17:01 <ddarius> thomashartman1: There are three solutions provided.
16:17:52 <thomashartman1> sjannsen: like this? head $ scanr (+) 1 $ strictify [1..(10^6)]
16:18:21 <thomashartman1> ddarius: none with source though
16:18:49 <ddarius> thomashartman1: The head strict list suggestion doesn't have source either.
16:19:32 <thomashartman1> ddarius: true. conceded.
16:23:07 <thomashartman1> sjannsen... strictify as above still pops stack. am I missing something?
16:23:43 <adu> does JPB ever show up here?
16:25:34 <mauke> > transpose [[1,2,3],[4,5,6]]
16:25:41 <lambdabot>  [[1,4],[2,5],[3,6]]
16:25:43 <ddarius> > scanr (+) 0 [1..10] :: [Expr]
16:25:44 <lambdabot>  [1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0))))))))),2 + (3 + (4 + ...
16:26:04 <ddarius> @src scanr
16:26:04 <lambdabot> scanr _ q0 []     =  [q0]
16:26:05 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
16:26:05 <lambdabot>     where qs@(q:_) = scanr f q0 xs
16:26:14 <OceanSpray> guys
16:26:21 <OceanSpray> I'm trying to compile hs-plugins,
16:26:32 <OceanSpray> but when doing runhaskell Setup.hs configure,
16:26:37 <thomashartman1> OceanSpray: I think I was able to get hs-plugins to work doing cabal install
16:26:51 <SamB_XP> it tells you that you have the wrong version of base?
16:26:53 <OceanSpray> I get "checking for C compiler default output file name... configure: error: C compiler cannot create executables
16:26:53 <OceanSpray> See `config.log' for more details.
16:26:53 <OceanSpray> "
16:27:13 <adu> OceanSpray: are you on macosx?
16:27:14 <SamB_XP> OceanSpray: did you see "config.log"?
16:27:18 <thomashartman1> oceanspray: what platform? what does config log say?
16:27:26 <OceanSpray> I'm on archlinus
16:27:28 <OceanSpray> *linux
16:27:36 <mm_freak> @pl \x -> [ y | y <- [x], f y ]
16:27:36 <lambdabot> (: [f y]) . ((y | y) <-) . return
16:27:40 <adu> OceanSpray: what version?
16:27:55 <ddarius> thomashartman1: The issue is that you shouldn't be using a strict in its second argument function like (most instances of) (+) with scanr.
16:28:07 <mm_freak> @pl \x -> if f x then [x] else []
16:28:07 <lambdabot> flip (liftM2 if' f return) []
16:28:18 <mm_freak> @src if'
16:28:18 <lambdabot> Source not found. Are you on drugs?
16:28:24 <mm_freak> :t if'
16:28:26 <lambdabot> Not in scope: `if''
16:28:29 <thomashartman1> ddarius: so I need a lazy version of (+) ?
16:28:40 <ddarius> thomashartman1: No, you need to not use scanr.
16:28:47 <OceanSpray> hold on
16:28:49 <OceanSpray> @hpaste
16:28:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:29:16 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/8371
16:29:37 <OceanSpray> oy,truncated.
16:30:33 <OceanSpray> I downloaded hs-plugins-1.0-rc0.tar.gz
16:31:26 <Peaker> Ok, I narrowed it to wx itself - it seems to get stuck on init (when merely calling Graphics.UI.WX.start)
16:31:27 <adu> I don't think this is good:
16:31:28 <adu> #define TOP "/home/karl/Haskell/lambdabot/hs-plugins
16:31:46 <adu> thats where the " is missing
16:31:50 <Peaker> anybody here uses Haskell's wx wrappers on a Linux distribution?
16:32:57 <adu> OceanSpray: hello karl :)
16:33:35 <OceanSpray> ho
16:34:30 <adu> OceanSpray: I would try reconfiguring
16:35:13 <OceanSpray> hm
16:35:31 <thomashartman1> ddarius: ... alternative approaches to <lambdabot> scanl f q ls = q : case ls of
16:35:31 <thomashartman1> *** iblechbot (n=iblechbo@ppp-62-216-222-142.dynamic.mnet-online.de) has quit:
16:35:31 <thomashartman1>     Read error: 113 (No route to host)
16:35:31 <thomashartman1> <lambdabot>     []   -> []
16:35:34 <thomashartman1> <lambdabot> sorry, alternative approaches to http://www.reddit.com/r/programming/info/6ngfy/comments/ ?
16:35:35 <lambdabot> Title: programming: An Interesting Little Problem
16:36:10 <thomashartman1> ( I think answer3 seems the simplest )
16:38:00 <adu> OceanSpray: maybe its ls colors
16:38:07 <adu> OceanSpray: try disableing ls colors
16:38:14 <OceanSpray> what's ls colors?
16:38:37 <thomashartman1> OcanSpray: do type ls or alias ls
16:38:52 <thomashartman1> and it'll show you if you are executing ls with some flag that adds colors
16:38:54 <OceanSpray> ls is aliased to `ls --color=auto'
16:39:04 <OceanSpray> how do I disable?
16:39:06 <adu> well, ls colors adds control codes like ^[443^\ to the output of ls, and it tries not to do this when the output is being used by another program, but it might have messed up
16:39:13 <thomashartman1> alias ls='ls' I think
16:39:29 <mauke> aliases don't go in scripts
16:39:32 <adu> --color=auto tries to guess if you really want color --color=off or false disables it
16:39:55 <OceanSpray> still error
16:39:58 <mauke> configure:1461: checking for value of __GLASGOW_HASKELL__
16:39:59 <mauke> configure:1466: result: 608
16:39:59 <mauke> [?1034h
16:40:02 <mauke> this is not ls
16:40:12 <mauke> configure fails at reading command output
16:40:45 <adu> mauke: I can see it fails, but why does it fail?
16:40:56 <OceanSpray> there's this line:
16:41:01 <OceanSpray> TOP=`echo "Directory.getCurrentDirectory >>= putStrLn.init.tail.show " | ghc --interactive -ignore-dot-ghci -v0`
16:41:38 <adu> o thats why it fails
16:41:47 <OceanSpray> Prelude> Directory.getCurrentDirectory >>= putStrLn.init.tail.show
16:41:48 <adu> replace that with TOP=`pwd`
16:41:48 <OceanSpray> /home/karl/Haskell/hs-plugins
16:42:23 <mauke> adu: why would that fail?
16:42:50 <adu> mauke: ghci is probably doing some ncurses/readline stuff
16:42:58 <mauke> I see
16:42:59 <adu> i dunno
16:43:08 <mauke> OceanSpray: which terminal are you using?
16:43:10 <adu> just guessing
16:43:12 <OceanSpray> That fixed one problem.
16:43:15 <OceanSpray> I got another.
16:43:22 <OceanSpray> I'm using Terminal
16:43:26 <OceanSpray> the one for xfce
16:43:48 <OceanSpray> sed: file ./confstatBoYzsY/subs-1.sed line 40: unterminated `s' command
16:43:56 <OceanSpray> config.status: creating testsuite/makewith/io/TestIO.conf
16:44:50 <ddarius> > inits [1..10]
16:44:51 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
16:45:02 <ddarius> > tails [1..10]
16:45:02 <OceanSpray> somehow, I get the feeling that this package just wasn't made right.
16:45:03 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
16:45:04 <adu> OceanSpray: what does "echo $TERM" say?
16:45:16 <OceanSpray> xterm
16:45:49 <adu> hmm
16:45:54 <mauke> smm=\E[?1034h
16:45:56 <mauke> bingo
16:46:09 <OceanSpray> why
16:46:11 <OceanSpray> whut
16:46:41 <ddarius> > let f xs = map product (zipWith (++) (inits xs) (tail (tails xs))) in f [4,3,2,1,2]
16:46:42 <lambdabot>  [12,16,24,48,24]
16:46:56 <mauke> "turn meta key on"
16:47:05 <mauke> I wonder why ghci wants to print that
16:47:30 <adu> heh
16:47:48 <OceanSpray> @hpaste
16:47:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:47:53 <adu> wouldn't that be turned off with "-v0"?
16:48:02 <thomashartman1> ddarius: hm, all without scans.
16:49:09 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8371#a1
16:49:22 <OceanSpray> there's the rest of that .log
16:49:35 <adu> yey that looks better
16:50:22 <OceanSpray> actually...
16:50:28 <adu> o thats the same...
16:50:53 <dcoutts> @seen ndm
16:50:53 <lambdabot> I saw ndm leaving #haskell-blah 14h 18m 24s ago, and .
16:51:08 <mauke> can't reproduce this with TERM=xterm
16:51:58 <Zao> Wasn't there a similiar issue with bold text before?
16:52:03 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/8371#a2
16:52:24 <Zao> I believe that TERM=dumb was suggested as a workaround then.
16:53:18 <OceanSpray> @seen dons
16:53:18 <lambdabot> dons is in #haskell, #haskell-soc, #arch-haskell, #ghc and #xmonad. I last heard dons speak 1h 16m 52s ago.
16:53:25 <OceanSpray> hmm
16:53:34 <thomashartman1> ddarius: seems no longer O(n) though. but thanks.
16:53:53 <ddarius> Yeah, it's a direct, naive translation of the specification.
16:54:07 <thomashartman1> ddarius: there is hot air blowing out of my laptop :)
16:54:26 <ddarius> > (\xs -> zipWith (++) (inits xs) (tail (tails xs))) [4,3,2,1,2]
16:54:27 <lambdabot>  [[3,2,1,2],[4,2,1,2],[4,3,1,2],[4,3,2,2],[4,3,2,1]]
16:54:37 <OceanSpray> this is extremely frustrating.
16:54:50 <ddarius> However, you can probably calculate a better one from that "specification".
16:55:01 <thomashartman1> yeah i'm gonna try.
16:55:25 <thomashartman1> maybe something with memoization...
16:55:39 <ddarius> @google "Richard Bird" sudoku
16:55:39 <lambdabot> No Result Found.
16:55:56 <gwern> @seen sjanssen
16:55:56 <lambdabot> sjanssen is in #haskell and #xmonad. I last heard sjanssen speak 40m 45s ago.
16:57:18 <ddarius> thomashartman1: http://icfp06.cs.uchicago.edu/bird-talk.pdf
16:57:31 <gwern> @tell sjanssen the file limit stuff is kind of arbitrary right now. I have it set to 6/7 right now, but I have no idea why it cannot be any lower without breakage. maybe you could try bumping the file limit in Resources.hs up until it works and tell me the correct value?
16:57:31 <lambdabot> Consider it noted.
16:58:54 <ddarius> thomashartman1: By "calculate", I mean applying semantics preserving transformations to the original code to get optimized code.
16:59:43 <dolio> Are the pages on that PDF upside down for anyone else?
17:00:14 <dons> ghc is not the only slow compiler, 1.1g 4752 R   99 29.5   1:09.19 cc1
17:00:21 <OceanSpray> dons!
17:00:28 <dons> hmm?
17:00:30 <TomMD> Careful, you'll scare him away!
17:00:34 <ddarius> dolio: Just rotate them.
17:00:36 <edwardk> dolio: yeah
17:00:43 <OceanSpray> Your hs-plugins-1.0rc0 doesn't work.
17:00:50 <dons> use 1.2 on hackagfe
17:00:56 <mauke> preflex: quote bos
17:00:56 <preflex>  <bos> i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
17:00:58 <OceanSpray> wha
17:01:00 <dons> 1.0rc0 is about 2 years out of date
17:01:06 <dons> 1.2 is on hackage.haskell.org
17:01:14 <OceanSpray> oh
17:01:44 <adu> preflex: lol
17:04:14 <gwern> so anyway, does anyone know why a GHC API-using interpreter binary needs to be able to open up 6 or more files?
17:04:15 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
17:04:31 <gwern> @messages
17:04:31 <lambdabot> sjanssen said 1h 9m 48s ago: the file limit stuff in mueval is no good -- hint can't open my package.conf!
17:04:37 <Zao> gwern: Trace it and see?
17:04:47 <dons> gwern: .hi files
17:04:53 <OceanSpray> dons, I still get the same old errors while trying to compile.
17:05:09 <OceanSpray> runhaskell Setup.hs configure should work, right?
17:05:09 <dons> try the darcs version, code.haskell.org/~dons/code/hs-plugins iirc
17:05:22 <gwern> Zao: I can't parse strace output really
17:05:22 <Zao> How much of the GHC tree does one need to bundle along when using the GHC api?
17:05:39 <gwern> dons: oh, for loading in modules?
17:05:50 <dons> gwern: that's how it works out what to load, yeah
17:06:10 <gwern> Zao: approximately 18 megs worth, in my experience :)
17:06:15 <dons> $ find lib -name '*.hi' | wc -l
17:06:16 <dons> 558
17:06:28 <gwern> dons: so would the number of .hi files to open differ from place to place?
17:06:44 <dons> it'll differ depending on what you're trying to load
17:06:57 <dons> you writing some kind of syscall policy for ghc?
17:07:40 <gwern> well, that can't be a direct relation. I have like 5000 .hi files, and mueval works with a 6/7 soft/hardlimit on file access
17:08:13 <gwern> dons: tightening up the rlimits stuff from lambdabot. eg. lambdabot doesn't use them all, and completely omits setting file limits
17:08:57 <dons> indeed. it relies on the type system
17:09:26 <dons> i recommend proofs over runtime checking, where feasible
17:10:22 <gwern> bleh. what we need is some sort of -safe flag where everything that breaks type safety is omitted from the libs
17:10:30 <gwern> and anything that uses them, as well
17:10:46 <bd_> gwern: so, no bytestring?
17:10:49 <ddarius> There has been some suggestions for a "tainting" system.
17:11:04 <bd_> since it uses foreign pointers :)
17:12:06 <gwern> bd_: well, why on earth should lambdabot allow you to use bytestring, eh? after all, it's supposed to be the same as String...
17:12:29 <OceanSpray> urgh.
17:12:37 <bd_> gwern: So you can use Data.Binary, of course :)
17:12:44 <gwern> (even if it's different for unicode stuff)
17:12:45 <OceanSpray> the SAME DAMN ERRORS, no matter which version I use.
17:13:12 <Zao> OceanSpray: Of?
17:13:26 <OceanSpray> trying to compile hs-plugins
17:13:48 <OceanSpray> runhaskell Setup.hs configure always craps out
17:15:01 <gwern> hs-plugins = unhappiness
17:15:14 <OceanSpray> who else here has compiled it?
17:16:26 * gwern has
17:16:53 <Mr_Awesome> OceanSpray: maybe something needs to be cleaned?
17:17:01 <OceanSpray> cleaned?
17:17:20 <Mr_Awesome> deleting previously compiled files
17:17:37 <Mr_Awesome> just a thought
17:19:56 <OceanSpray> I doubt that will do anything.
17:21:09 <edwardk>  > ap (zipWith (*) . init . scanl (*) 1) (tail . scanr (*) 1) ([1..5] ++ [5,4..1])
17:21:14 <edwardk> > ap (zipWith (*) . init . scanl (*) 1) (tail . scanr (*) 1) ([1..5] ++ [5,4..1])
17:21:15 <lambdabot>  [14400,7200,4800,3600,2880,2880,3600,4800,7200,14400]
17:56:57 <mar77a> how does one use maxBound?
17:57:56 <rwbarton> > maxBound::Int
17:57:57 <lambdabot>  2147483647
18:04:15 <kig> i want to parse some http logs into a histogram, and print the results out sorted by count. what would be a good way to do that? (Data.Map? total haskell newbie here)
18:05:10 <seanl> i am also quite new, but it seems like it
18:05:22 <seanl> i mean map
18:06:45 <byorgey> kig: sure, you could use Data.Map
18:07:13 <byorgey> although it might be easier just to use lists along with Prelude functions like groupBy, sortBy, and so on
18:07:27 <byorgey> kig, seanl, welcome =)
18:07:35 <seanl> thanks
18:07:42 <mar77a> don't let him trick you
18:07:46 <seanl> but isn't map more efficient than list in this case?
18:07:47 <mar77a> he's a devious programmer
18:07:51 <seanl> lol
18:08:24 <byorgey> seanl: yes, it probably would be.  so yeah, it depends on the particular needs.
18:08:24 <ddarius> @hoogle accumArray'
18:08:26 <lambdabot> No matches found
18:08:36 <byorgey> kig: how big are these http logs?
18:09:48 <kig> a hundred megs or so
18:10:15 <byorgey> oh.
18:10:18 <byorgey> !
18:11:01 <byorgey> yeah, try Data.Map, although the memory overhead might be too high, depending on how much RAM you have
18:11:37 <byorgey> at that point you'd have to look into more memory-efficient structures or using some sort of multi-pass algorithm
18:11:56 <kig> i'll try, thanks
18:12:53 <seanl> so is Data.Map less memory-efficient?
18:13:16 <seanl> just because it maintains keys and values?
18:13:20 <seanl> or any other reason?
18:13:29 <byorgey> seanl: it's not Data.Map in particular
18:14:24 <byorgey> seanl: many data structures in haskell end up with a relatively high memory overhead
18:14:35 <seanl> yup
18:14:43 <byorgey> that's the price you pay for higher-level things like algebraic data types and laziness
18:14:43 <seanl> i get it
18:14:59 <seanl> thanks :)
18:15:02 <byorgey> sure =)
18:17:43 <dons> algebraic data types aren't so bad. just a pointer and a bit tag, and some fields
18:18:13 <dons> general purpose trees though, that's you're storing other types inside of, well, some overheads there.
18:18:15 <mar77a> this is amazing
18:18:18 <mar77a> could i possibly be ..
18:18:20 <mar77a> understanding monads
18:18:36 * mar77a hugs book.realworldhaskell.org
18:24:28 <Botje> congratulations
18:24:39 <kpreid> does there exist a test suite (e.g. via QuickCheck) for Num instances?
18:24:40 <Botje> here's a complementary roll of duct tape for your next conquest
18:27:21 <mar77a> i have to admit this will be a great book, congrats dons and whoever else is writting it
18:28:13 <pengrate> Hmm, why is it that Haskell doesn't have dependant types again? Is there some undecidable problem associated with them?
18:28:36 <pengrate> *dependent
18:28:57 <SamB> pengrate: well, they require a somewhat different style of programming...
18:28:58 <kpreid> (I ask because I was wondering if I could use it to test whether a sort of number I thought of would have the normal properties)
18:30:25 <SamB> pengrate: they also more-or-less require that the type and value namespaces be merged
18:30:31 <SamB> which is not going to work for Haskell
18:30:39 <pengrate> Ah, okay
18:32:54 <byorgey> pengrate: well, type inference is in general undecidable for dependent types
18:33:33 <ddarius> Also, dependent types were nowhere near as well understood when Haskell was starting as they are now.
18:34:15 <SamB> byorgey: that isn't the problem ;-)
18:35:02 <byorgey> SamB: true, but pengrate asked if there is some undecidable problem associated with dependent types
18:35:19 <ddarius> That said, Lennart made Cayenne, a Haskell-like dependently typed language quite a while ago.
18:35:52 <SamB> well, Haskell *already* has undecidable type inference
18:36:20 <dolio> GHC does.
18:36:22 <SamB> that is, some types must be supplied by the programmer
18:36:22 <byorgey> SamB: isn't H98 type inference decidable?
18:36:36 <SamB> byorgey: yes, but Haskell hasn't meant H98 in a while now ;-)
18:36:39 <byorgey> SamB: I thought that was only with certain extensions
18:36:47 <byorgey> well, ok =)
18:37:10 <pengrate> byorgey: Thanks. I thought I had heard about an undecidable problem related to them, but I couldn't remember if it was type inference or not..
18:41:12 <hpaste>  morrow annotated "lisp-style "list" function" with "(no title)" at http://hpaste.org/8368#a1
18:44:26 <mar77a> > return "hi" >>= (\x -> x)
18:44:29 <lambdabot>  "hi"
18:44:48 <mar77a> > return "hi" >>= id
18:44:49 <lambdabot>  "hi"
18:48:25 <mar77a> is there any use for double-monads
18:48:34 <mar77a> for example, using (return . return)
18:49:07 <byorgey> mar77a: I've never seen (return . return) used
18:49:31 <mar77a> yeah it strikes me as kinda pointless
18:49:47 <Botje> i've once used return `liftM` foo
18:49:51 <Botje> does that count? >:D
18:49:53 <byorgey> mar77a: however, you can think of  (>>=) as applying a function (a -> m b)  'inside' the  (m a)  to produce  an  (m (m b)), then using join to 'collapse' the double monad
18:50:15 <mar77a> ah
18:50:22 <byorgey> i.e. x >>= f = join (fmap f x)
18:50:24 <rwbarton> I've used (return (return ()) inside unsafePerformIO inside runST, for debugging
18:50:34 <gwern> hey, can anything think of some major projects besides haddock and yi which use the GHC API?
18:50:49 <ddarius> byorgey: There are things in Haskell 98 that can't be inferred.
18:50:57 <Botje> lambdabot?
18:50:58 <byorgey> ddarius: oh, really?
18:51:06 <SamB> ddarius: what?
18:51:24 <gwern> Botje: in the future, perchance
18:51:33 <ddarius> Besides the obvious show . read, there's polymorphic recursion.
18:51:44 <byorgey> aha, right
18:52:43 <mmorrow> plymorphic recursion FTW
18:52:49 <ddarius> mar77a: There can be.
18:52:54 <mar77a> "Recall, however, that all Haskell functions really take only one argument"
18:52:55 <mar77a> what?
18:53:15 <Botje> yup
18:53:16 <bd_> :t (+)
18:53:18 <lambdabot> forall a. (Num a) => a -> a -> a
18:53:24 <bd_> ^^^ that type formula is the same as:
18:53:24 <mmorrow> mar77a: in an "abstract sense"
18:53:25 <ddarius> All Haskell functions take exactly one argument.
18:53:31 <bd_> (Num a) -> a -> (a -> a)
18:53:41 <bd_> ie, takes a number, and returns a function which takes a number and returns a number
18:53:48 <bd_> > let addone = (+) 1 in addone 2
18:53:49 <lambdabot>  3
18:53:52 <mar77a> ah
18:54:05 <bd_> passing two arguments just immediately goes and passes the second
18:54:18 <bd_> of course, the compiler has a bag of tricks to make this more efficient than it seems at first :)
18:54:27 <mar77a> is his related to currying
18:54:31 <bd_> this is currying :)
18:54:41 <mar77a> that'd explain the name of the language
18:56:27 <mmorrow> ddarius: (w/ the implicit functions existing at every possible partial app)
18:56:46 <mmorrow> ((and they do exist))
19:10:26 <hpaste>  solrize pasted "code smell?" at http://hpaste.org/8372
19:12:15 <gwern> > [1] `isInfixOf` [1..10]
19:12:18 <lambdabot>  True
19:12:32 <gwern> > [1] `Data.List.isInfixOf` [1..10]
19:12:33 <lambdabot>  True
19:13:40 <jadrian> guys I've got haskell mode installed
19:13:53 <jadrian> for xemacs
19:13:55 <jadrian> and whenever I press tab I get
19:14:02 <gwern> a good start
19:14:19 <jadrian> Invalid argument: invalid syntax designator, ?\t
19:14:27 <jadrian> anyone has any idea?
19:14:35 <kpreid> solrize: data Segment = Segment <big tuple> seems an odd thing to do
19:14:45 * gwern didn't know haskell-mode even worked with xemacs
19:14:57 <jadrian> gwern: I've always used it with xemacs
19:15:01 <gwern> silly xemacser
19:15:06 <jadrian> for years and years
19:15:10 <kpreid> solrize: also, I wonder about 1 being special-cased in ngs -- but I don't know what this data type is really about (but I can see the code is an unserializer)
19:15:20 <jadrian> but now I'm stuck :S
19:15:58 <solrize> kpreid the reason for the big tuple is that i have an LBinary (like Data.Binary) instance for tuples that automatically deserializes the types inside the tuple.  the /= 1 was supposed to be -1, it's fixed now
19:16:41 <solrize> what i thought was smelly was the other stuff in the conditionals, i.e. return Nothing vs. liftM Just L.get
19:16:50 <kpreid> solrize: ...but you're not using that instance for the 9-element tuple in Segment?
19:16:59 <kpreid> I'm thinking about that conditional
19:17:14 <solrize> not using it for the 9-tuple because there's stuff inside the tuple that's conditionalized on other stuff
19:17:29 <kpreid> so why do you define Segment in terms of a tuple?
19:18:03 <solrize> well, getting (sn,ss,dg,dso) in one operation is convenient, and there are some other record formats in the app that don't have as much conditional hair
19:18:10 <solrize> so i can read them more straightforwardly as tuples
19:18:10 <kpreid> er...
19:18:36 <kpreid> I'm asking why you have data Segment = Segment (SegName, SegSize ... instead of data Segment = Segment SegName SegSize ...
19:18:51 <solrize> right, the deserializer would be more complicated the second way
19:18:56 <kpreid> why?
19:19:09 <kpreid> why does the deserializer care, since you're using a custom instance?
19:19:10 <solrize> because i'd have to call get separately for segname, segsize, ...
19:19:21 <kpreid> I'm not asking about (sn,ss,dg,dso)
19:19:27 <kpreid> but about the Segment data type itself
19:19:35 <solrize> hmm
19:19:59 <solrize> oh i see what you're saying.  yeah i could do that way but using a tuple is consistent with the way some of the other ones work
19:20:07 <solrize> although, i guess i could write them all that way
19:20:08 <solrize> hmm
19:20:17 <solrize> there was some better reason for this
19:20:28 <solrize> i discussed it with quicksilver a couple nights ago and this was the result
19:20:54 <kpreid> :t \dso get -> guard (dso == -1) >> return L.get
19:20:56 <lambdabot> Not in scope: `L.get'
19:20:58 <kpreid> :t \dso get -> guard (dso == -1) >> return get
19:21:00 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m, Num a) => a -> b -> m b
19:21:07 <solrize> hmm
19:21:11 <solrize> dso?
19:21:17 <kpreid> not quite right
19:21:24 <solrize> i think i see what you're saying
19:21:29 <kpreid> :t \dso get -> guard (dso == -1) >> liftM get
19:21:31 <lambdabot> forall a a1 r (m :: * -> *). (Monad m, MonadPlus ((->) (m a1)), Num a) => a -> (a1 -> r) -> m a1 -> m r
19:21:43 <kpreid> no...
19:22:25 <jadrian> oh well I'll just bug-report it
19:22:28 <jadrian> to xemacs
19:22:32 <jadrian> it works fine in emacs
19:25:34 <solrize> but i'd have to put the guard on the right of the <-   can i do that??
19:26:16 <solrize> dsinfo <- when (dso /= -1) L.get                 -- is that ok?
19:26:23 <kpreid> :t when
19:26:24 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:26:34 <kpreid> no...that's going to discard the result
19:26:38 <solrize> so that will infer to the maybe monad
19:26:39 <solrize> oh
19:27:08 <kpreid> hmm
19:27:10 <kpreid> :t fmap fmap
19:27:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
19:27:29 <ddarius> :t fmap fmap fmap
19:27:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:27:32 <ddarius> :t (.) . (.)
19:27:34 <kpreid> no...
19:27:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:28:12 <kpreid> :t \dso -> guard (dso == -1) >> return readLine
19:28:14 <lambdabot> Not in scope: `readLine'
19:28:21 <kpreid> :t \dso -> guard (dso == -1) >> return getArgs
19:28:23 <lambdabot> Not in scope: `getArgs'
19:28:39 <kpreid> :t \dso -> guard (dso == -1) >> return (undefined :: IO String)
19:28:40 <lambdabot> forall a (m :: * -> *). (MonadPlus m, Num a) => a -> m (IO String)
19:28:52 <edwardk> @pl \m -> Exp (runExp f . mappend m)
19:28:53 <lambdabot> Exp . (runExp f .) . mappend
19:28:58 <kpreid> hrm
19:29:32 <kpreid> whereas we want IO (Maybe String), but that inversion is not readily available afaik
19:30:07 <kpreid> if there was a MaybeT then we could use lift
19:31:21 <solrize> hmm
19:31:31 <solrize> we're actually not in IO
19:31:45 <solrize> but we're in this other monad Get
19:32:20 <dolio> @hackage MaybeT
19:32:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
19:32:40 <kpreid> er, yeah. I was using IO as a standin for the relevant monad
19:33:02 <solrize> np
19:33:21 <solrize> oh well, it sounds like there's no real obvious cleanup anyway
19:33:56 <kpreid> yeah, it's pretty good as it is
19:34:01 <solrize> thanks
19:34:03 <kpreid> oh hm
19:35:41 <kpreid> :t do g <- return (undefined :: IO string); guard True; return g
19:35:43 <lambdabot> forall string (t :: * -> *). (MonadPlus t) => t (IO string)
19:36:16 <solrize> hmm
19:36:19 <kpreid> er, there was supposed to be a fmap somewhere in there
19:36:53 <kpreid> :t sequence
19:36:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:37:17 <kpreid> @hoogle Maybe (m a) -> m (Maybe a)
19:37:18 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
19:37:18 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
19:37:22 <kpreid> nope
19:37:44 <kpreid> :t a -> Bool -> Maybe a
19:37:46 <lambdabot> parse error on input `->'
19:37:51 <kpreid> @hoogle a -> Bool -> Maybe a
19:37:52 <lambdabot> No matches, try a more general search
19:37:58 <kpreid> I give up
19:38:14 <solrize> thanks for trying
19:38:16 <kpreid> your thing *could* be expressed with a general combinator, but I don't think that combinator exists
19:38:27 <solrize> yeah maybe i'll try writing one as an exercise
19:38:36 <kpreid> @src sequence
19:38:37 <lambdabot> sequence []     = return []
19:38:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:38:37 <lambdabot> --OR
19:38:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:39:10 <kpreid> mseq Nothing = return Nothing; mseq (Just x) = do v <- x; return (Just v)
19:39:32 <solrize> hmm
19:39:47 <kpreid> then you can mseq (guardR (dso == -1) L.get)
19:40:06 <solrize> :t listToMaybe $ mseq (guardR (dso == -1) L.get)
19:40:08 <lambdabot> Not in scope: `mseq'
19:40:08 <lambdabot> Not in scope: `guardR'
19:40:08 <lambdabot> Not in scope: `dso'
19:40:10 <solrize> ehh
19:40:21 <kpreid> where guardR c a = if c then Just a else Nothing
19:40:43 <solrize> guardR = mplus ?
19:40:51 <solrize> nah
19:40:52 <kpreid> more generally, guardR c a = if c then return a else mzero
19:40:58 <solrize> yeah
19:41:07 <kpreid> I've wanted it before, I think
19:41:09 <solrize> i'm surprised that's not standard
19:41:13 <edwardk> @pl \f m -> f . mappend m
19:41:14 <lambdabot> (. mappend) . (.)
19:41:21 <kpreid> "I could use guard, but I want to return the value from before"
19:42:51 <solrize> sec there's someone here
19:43:52 <kpreid> oh another thing: ngs could be <- replicateM (max 0 (fromIntegral nf)) L.get -- but that might be overly obscuring what it's actually for
19:46:25 <solrize> yeah they use -1 as a special marker for a whole bunch of things
19:48:19 <solrize> let guardR c a = do { guard c >> a } in guardR True 7 :: Maybe Int
19:48:22 <mwc> why isn't reddit.com/r/haskell more popular?
19:48:22 <solrize> > let guardR c a = do { guard c >> a } in guardR True 7 :: Maybe Int
19:48:23 <lambdabot>   add an instance declaration for (Num (Maybe Int))
19:48:46 <solrize> > let guardR c a = do { guard c >> a } in guardR True (Just 7)
19:48:48 <lambdabot>  Just 7
19:48:53 <solrize> > let guardR c a = do { guard c >> a } in guardR False (Just 7)
19:48:54 <lambdabot>  Nothing
19:52:11 <sclv> > round (1/0) :: Int
19:52:13 <lambdabot>  0
19:52:15 <sclv> > round (1/0) :: Integer
19:52:16 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
19:52:22 <sclv> > round (0/0) :: Integer
19:52:23 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
19:52:26 <sclv> > round (0/0) :: Int
19:52:27 <lambdabot>  0
19:52:56 <solrize> ugh!!!!!
19:53:03 <solrize> sclv :)
19:53:25 <ddarius> > 2^50
19:53:26 <lambdabot>  1125899906842624
19:53:57 <rwbarton> > round (1/0) - 2^1024 :: Integer
19:53:58 <lambdabot>  0
19:55:26 <solrize> hmm i don't see how to get that guardR to the inner monad
19:56:11 <sandbox> where is showPackageId?
19:56:59 <sandbox> Everything seems to point to Distribution.Package but it doesn't seem to be there
19:57:22 <sandbox> ghc version 6.8.2
19:58:19 <sandbox> cabal 1.2.3.0
19:59:04 <sandbox> I see it on http://haskell.org/ghc/docs/6.8.2/html/libraries/Cabal/Distribution-Package.html
19:59:05 <lambdabot> http://tinyurl.com/6pkl5v
19:59:12 <sandbox> but :browse shows completely different stuff in ghci
20:29:00 <vixey> Epigram is crazy
20:29:27 <dolio> Epigram 1?
20:29:43 <vixey> well 2 I suppose
20:29:53 <vixey> all this generic stuff is really cool
20:30:40 <vixey> they seem to be going to model the whole languages data in a metacircular way and replace real data with a universe defined inside the system itsself
20:31:53 <dolio> What are you reading?
20:32:04 <vixey> http://www.cs.nott.ac.uk/~pwm/thesis.pdf
20:32:15 <vixey> all the stuff by pwm is relevant though
20:32:27 <dolio> Oh, yeah, I've read a fair amount of that.
20:32:28 <vixey> It's all mad..
20:32:35 <dolio> I didn't realize that kind of stuff was going into Epigram 2, though.
20:32:38 <dolio> That'd be awesome.
20:33:20 <dolio> Or, that is, the stuff in that paper is awesome, but it'd be terrible to use the way it's written, because you can't use any actual data types, only ones defined in the universe.
20:36:47 <vixey> I hope they use a TeX interactive mode :p
20:37:38 <dolio> At least, I'm not big on having to write stuff like 'let List = `mu` `1` `+` fz `*` fs fz' instead of 'data List a = Nil | Cons a (List a)'.
20:38:02 <vixey> yes
20:38:10 <SamB> vixey: I think that's just a model of the system they really want to make
20:38:40 <dolio> That whole paper is written in Epigram 1, though, as I recall.
20:39:00 <dolio> The only stuff they use that would be in Epigram 2 is extensional equality in some places.
20:39:47 <SamB> isn't the "OTT now!" paper written in Agda?
20:40:12 <vixey> I think there is an OTT checker in Agda 2, maybe..
20:40:39 <dolio> Epigram's custom destructor/recursion operators strike me as pretty interesting, though.
20:41:04 <SamB> oh, was that "observational equality, now!"?
20:42:16 <SamB> yes, that's in Agda 2
20:42:34 <SamB> probably because Agda 2 is a bit easier to obtain a copy of than Epigram 2?
20:42:47 <vixey> I might have been thinking of Syntacticosmos
20:58:38 <dolio> @yow
20:58:38 <lambdabot> Couldn't find fortune file
20:58:46 <dolio> It's quiet in here tonight.
20:59:25 <vixey> it's 5am on tuesday, where is everyone?!
20:59:33 <newsham> being productive?
21:00:24 <dons> Cale, fortune file gone missing
21:16:49 <thetallguy> Not very fortunate.
21:20:43 <dolio> Observational Equality Now! uses "---until now." a  lot. :)
21:21:40 <dolio> Since the dawn of time, man has failed to conquer the egg---until now!
21:25:27 <solrize> vixey that thesis is really interesting
21:32:17 <vixey> solrize: yes it's cool stuff, there's other related ones too http://www.cs.nott.ac.uk/~pwm/
21:32:18 <lambdabot> Title: Peter Morris's Homepage
21:37:07 <solrize> vixey thanks
21:39:36 <hpaste>  cjs pasted "QuoteCalc" at http://hpaste.org/8373
21:40:09 <dolio> @arr! GHC failed to compile.
21:40:09 <lambdabot> Yo ho ho, and a bottle of rum!
21:40:31 <cjs> So, I've got this list of quotes that I do various operations on, and I'm running into a bit of trouble.
21:41:03 <cjs> I sometimes need to do some operations on a subset of these, so I've been just consing up another instance of the monad, and doing them in there, and taking the result.
21:41:29 <cjs> But I'd kinda like an easy way just to get the result back from that nested one, but have the error status just flow straight through.
21:42:32 <cjs> I.e., instead of let (result, _) = runQuotes foo someQuotes; case result of Left err -> ..., having something simpler that gives me the x from Right x, like <- kinda does, or just fails the current set of calcaulations.
21:42:35 <cjs> Any thoughts?
21:43:38 <vixey> it sounds exactly like the Maybe monad
21:43:49 <vixey> except Nothing is augmented
21:44:06 <cjs> I've got that implemented, if you have a quick look at the paste....
21:44:32 <cjs> But how do I do a new set of separate calculations, returning a different value, with...wait...maybe I'm looking too hard for something complex here....
21:45:56 <cjs> Oh, I see what's going on; the issue is that I change the list of Quotes that the calculation is working on for these sub-calculations.
21:46:11 <cjs> So I need a way to pass that in to the sub-calculations, but have it revert back after they're done.
21:49:07 <cjs> Ah! Do I just need a return that leaves the old qs in place?
21:49:24 <cjs> Or something like that...hmmm....
21:50:05 <cjs> Ah, I need something that stashes away the old list, puts the new list in the monad, runs the calculations, and then restores the old list.
22:03:25 <sandbox> I'm trying to find showPackageId but Distribution.Package is completely different than ghc docs, what am I looking at?
22:08:55 <solrize> is it a code smell to have a bunch of different integer types and use fromIntegral all over the place?
22:12:12 <Heffalump> solrize: it certainly sounds dubious, but there might be a good reason
22:15:26 <solrize> newtype VInt = VInt Integer
22:15:26 <solrize>     deriving (Num, Show)   -- should this be able to derive Eq by itself?  i'm using GeneralizedNewtypeDeriving
22:15:42 <solrize> heffalump i'm deserializing a binary file so i'm using int8, word32, etc
22:16:08 <solrize> but what's a bit odd is that i have those types in my data constructors instead of turning them into integers during deserialization
22:16:46 <solrize> and they're in the data constructors because that drives a class-based deserializer (basically Data.Binary)
22:18:25 <adu> so I got Yi to compile
22:18:41 <adu> just thought I'd let y'all know
22:19:59 <adu> and I thought it was enough of a hassle that I'd like to write a page on it
22:20:05 <adu> is there a place on the wiki?
22:20:16 <vixey> good adu
22:21:11 <vixey> adu: where did you look on the wiki when you were having trouble compiling?
22:21:16 <vixey> (put it there)
22:21:57 <adu> the place that said to darcs-get http://www.cse.unsw.edu.au/~dons/yi
22:21:59 <lambdabot> Title: Index of /~dons/yi
22:22:10 <adu> and when I did that it told me to darcs get http://darcs.haskell.org/yi
22:22:11 <lambdabot> Title: Index of /yi
22:22:21 <adu> and when i did that it told me to darcs get http://code.haskell.org/yi
22:22:22 <lambdabot> Title: Index of /yi
22:22:26 <adu> it was very confusing
22:23:39 <adu> http://www.cse.unsw.edu.au/~dons/yi.html
22:23:40 <lambdabot> Title: yi text editor
22:23:43 <adu> that was the page
22:24:35 <adu> ah I see http://haskell.org/haskellwiki/Yi has the right place...
22:24:36 <lambdabot> Title: Yi - HaskellWiki
22:26:36 <jekor> How do you convert a Color to a Pixel with the X11 library?
22:27:47 <adu> jekor: http://cvs.haskell.org/Hugs/pages/libraries/X11/Graphics-X11-Xlib-Color.html
22:27:48 <lambdabot> http://tinyurl.com/6r2e2p
22:28:01 <adu> jekor: are you talking about this?
22:30:18 <jekor> adu: Yes. I can't find any functions with signatures that return Pixel values, except for whitePixelOfScreen and blackPixelOfScreen.
22:30:38 <jekor> I think I might have found something on thi wiki with initColor...
22:30:41 <adu> vixey: but anyways, one of the nice things I noticed is that there is already some code in there to use Cocoa, which I'm interested in since I'm on macosx
22:31:54 <vixey> adu: Are you going to write an objective c ffi?
22:32:41 <adu> jekor: (color_pixel myclr)
22:32:45 <jekor> Ah, I found it. I hadn't realized that Color is actually a type that contains a color_pixel element.
22:32:47 <jekor> Thanks, adu.
22:33:25 <adu> vixey: thats already done, http://hoc.sourceforge.net/
22:33:26 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
22:33:48 <vixey> I doubt HOC works
22:33:51 <adu> my guess is that it is a secret requirement that isn't in the "dependancy" section yet
22:34:06 <adu> well i'll test it
22:34:07 <jekor> By the way, before I write this program: Does anyone know of a GNU/Linux screen recorder that records to a lossless format, aside from vnc2swf?
22:35:34 <adu> while true ; do screenshot ; wait 1 ; done ?
22:36:22 * adu confuses wait and sleep
22:37:14 <jekor> :)
22:37:52 <jekor> I think I'm going to have to add XDamage support to the X11 library.
22:46:07 <adu> if I reinstall GHC after installing Cabal, will I have to reinstall Cabal again?
22:49:03 <ivanm> same version of ghc?
22:49:11 <ivanm> if so, you'll have to re-register cabal with ghc
22:50:12 <adu> ok
22:58:32 <hpaste>  L29Ah pasted "Julia" at http://hpaste.org/8374
22:59:13 <cjs> What combines an (a -> Bool) and an (a -> Bool) to produce a new (a -> Bool)? mappend?
22:59:43 <dolio> Not exactly.
22:59:44 <sjanssen> cjs: there is more than one answer
22:59:50 <dolio> You need to choose a Bool monoid.
22:59:50 <vixey> :t liftM2 (&&)
22:59:56 <sjanssen> @type liftA2 (||)
23:00:13 <vixey> ah, it's A2 I wanted
23:00:26 <sjanssen> vixey: they're the same in this instance
23:00:26 <cjs> Ah, I knew it was something like that. I've done this before with comparing....
23:01:04 <fishmacs> > :t mapM_
23:01:25 <fishmacs> @ :t mapM_
23:01:27 <vixey> (a -> m b) -> [a] -> m ()
23:01:28 <sjanssen> cjs: Bool (and a -> Bool) doesn't have a Monoid instance since there are several reasonable choices
23:01:46 <sjanssen> lambdabot: what is wrong with you?
23:02:19 <cjs> I'm basicallylooking for the "and" of two (a -> Bool)s.
23:03:53 <cjs> I need to learn this Control.Applicative stuff one day.
23:03:53 <sjanssen> you might consider changing your types to (a -> All) just for Monoid convenience :)
23:04:42 <cjs> That might make sense for what I need, actually.
23:06:06 <JethroeCledus> is haskell better than c?
23:06:13 <sjanssen> yes
23:06:21 <JethroeCledus> cool
23:06:28 <cjs> @faq is haskell better than C?
23:06:40 <cjs> Where's lambdabot?
23:06:52 <sjanssen> I guess we answered all his questions :)
23:09:17 <sandbox> @hoogle depends
23:11:40 <fishmacs> lambdabot is sleeping
23:11:54 <vixey> :(
23:12:03 <vixey> this is not what I wanted to see http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Type.hs
23:13:02 <sandbox> so what version of cabal do I need to build hs-plugins
23:13:19 <fishmacs> I want to map a monadic function, how can I?
23:13:21 <sjanssen> sandbox: I think the 1.2.x series is okay
23:13:24 <sjanssen> fishmacs: mapM
23:13:39 <sjanssen> or mapM_ if you want to throw away the results
23:13:42 <sandbox> thanks, I'll try that
23:14:56 <vixey> What's the best IRC parser?
23:14:58 <fishmacs> Oh, I only know mapM_
23:18:14 <cjs> quoteSel    :: [(Quote -> Bool)] -> (Quote -> Bool)
23:18:14 <cjs> quoteSel     = foldM (liftM2 (&&)) (liftM True)
23:18:20 <cjs> So where am I going wrong here.
23:18:26 <cjs> s/.$/?/
23:20:56 <dolio> True isn't a function.
23:21:25 <cjs> Doh. How does one lift it?
23:21:33 <dolio> return?
23:21:48 <vixey> liftM . const $ Tru
23:22:19 <dolio> I'm not sure why you're using foldM, either.
23:22:26 <cjs> What do I want to use?
23:22:34 <cjs> Oh, mapM, right?
23:22:42 <dolio> foldr, I imagine.
23:22:53 <cjs> I originally tried that, and that was going all wrong.
23:23:06 <dolio> foldM is for function of type (b -> a -> m b).
23:23:24 <dolio> But liftM2 (&&) is (m Bool -> m Bool -> m Bool).
23:24:26 <cjs> I have a list of (a -> Bool) and want to turn them all in a single (a -> Bool) that does the "and" of them. It's entirely eluding me.
23:25:01 <dolio> @type foldr (liftM2 (&&)) (return True)
23:25:10 <dolio> Oh, right.
23:26:00 <adu> hello
23:26:31 <vixey> % mueval "1+1"
23:26:32 <vixey> mueval: setResourceLimit: invalid argument (Invalid argument)
23:26:33 <vixey> :/
23:26:48 <dolio> There's also \l -> and . sequence l
23:27:19 <vixey> I guess mueval is linux only?
23:27:54 <fishmacs> End of a "do" clause must be an expression, is there any dummy exp does nothing?
23:28:02 <vixey> return ()
23:28:42 <fishmacs> I'm fool, sounds very easy
23:30:30 <cjs> Is there a reference around that can explain to me, slowly, the magic in foldr (liftM2 (&&)) (return True)?
23:30:45 <vixey> @src or
23:31:04 <vixey> and = foldr (&&) (return True)
23:31:09 <vixey> oops
23:31:12 <vixey> and = foldr (&&) True
23:31:19 <vixey> and :: [Bool] -> Bool
23:31:32 <vixey> andM = foldr (liftM2 (&&)) (return True)
23:31:33 <cjs> Yup, I get that.
23:31:41 <vixey> or maybe it should be
23:31:44 <vixey> andA = foldr (liftA2 (&&)) (return True)
23:31:55 <vixey> andA :: [a -> Bool] -> (a -> Bool)
23:32:24 <vixey> it's exactly &&, it just works on a different kind of boolean
23:33:06 <dolio> If you're using liftA2, you probably want to use pure as well.
23:33:14 <dolio> Otherwise it's required to be a Monad, still.
23:33:35 <dolio> And your type signature gets longer.
23:33:58 <vixey> What's going on here?
23:33:58 <vixey> *Main> setResourceLimit ResourceStackSize (ResourceLimits (ResourceLimit 0) (ResourceLimit 0))
23:33:58 <vixey> *** Exception: setResourceLimit: invalid argument (Invalid argument)
23:34:14 <cjs> Ok, I definitely need to go read the Control.Applicative paper.
23:34:20 <cjs> Or is there a gentler introduction?
23:34:28 <vixey> cjs: There's another, equivalent definitios
23:35:07 <vixey> andA booleans a = or . map ($a) booleans
23:35:39 <vixey> oh
23:35:42 <vixey> andA booleans a = or (map ($a) booleans)
23:37:58 <adu> vixey: I just made my first contribution to the wiki :)
23:38:52 <vixey> @seen gwern
23:42:20 <fishmacs> I want to benchmark different parts of my program, so ClockTime is the best choice?
23:42:45 <fishmacs> where is milisecond?
23:46:54 <fishmacs> no choice other than System.Time?
23:46:54 <Beelsebob> fishmacs: doing that is usually a bad plan
23:47:05 <Beelsebob> purely because lazyness will give you very wrong answers
23:47:28 <Beelsebob> well, unless you artificially insert strictness annotations, and then your answers are wrong because of strictness
23:50:27 <fishmacs> My program is only about database access, what I really want to measure is the database r/w time
23:50:58 <fishmacs> I think it is not affected much by laziness?
23:51:36 <Beelsebob> nope, shouldn't be
23:51:46 <cjs> Not if you're measuring time from some specific input to your program to some specific output from it.
23:52:12 <cjs> Basically, as soon as you say, "print the result of this calculation," it has to do the entire calculation.
