00:00:02 <vixey> oh.
00:00:22 <rwbarton> I guess if f was an Expr, you couldn't apply it to x.
00:00:28 <ivanm> when did lambdabot get the ability to do Expr calculations?
00:00:55 <vixey> months ago..
00:01:01 <ivanm> heh
00:01:12 <mmorrow> > scanl f z (replicate 6 a)
00:01:13 <ivanm> is there a tarball version of lb with it, or just darcs?
00:01:13 <lambdabot>  [z,f z a,f (f z a) a,f (f (f z a) a) a,f (f (f (f z a) a) a) a,f (f (f (f (f...
00:01:35 <mmorrow> > foldr g b (scanl f z (replicate 6 a))
00:01:36 <lambdabot>  g z (g (f z a) (g (f (f z a) a) (g (f (f (f z a) a) a) (g (f (f (f (f z a) a...
00:01:43 <mmorrow> > foldl g b (scanl f z (replicate 6 a))
00:01:45 <lambdabot>  g (g (g (g (g (g (g b z) (f z a)) (f (f z a) a)) (f (f (f z a) a) a)) (f (f ...
00:03:16 <rwbarton> > x x
00:03:17 <lambdabot>  Couldn't match expected type `Expr -> t'
00:03:43 <rwbarton> > f f
00:03:44 <lambdabot>  Add a type signature
00:03:49 <rwbarton> > f f :: Expr
00:03:50 <lambdabot>  Add a type signature
00:07:03 <mxc-wrk> is anyone here familiar with HDBC-ODBC?
00:11:13 <vixey> > f f :: Expr :: Expr
00:11:13 <lambdabot>  Parse error at "::" (column 13)
00:23:20 <solrize> anyone know hackage's new whereabouts?
00:24:36 <ivanm> in the hearts and minds of haskell lovers everywhere!
00:25:29 <solrize> true:)
00:27:56 <adu> I <3 Haskell
00:29:20 <vixey> ah this is genious http://okmij.org/ftp/Haskell/staged/TypeCheck.hs
00:29:55 <mxc-wrk> ivanm > ty, i like the heartbased, DVCS-esque new hackageDB, but any  idea how we can update our local DBs as new packages are added?
00:31:22 <vixey> hmm could it be done without TH though?
00:32:22 <glguy> solrize: hackage is moving to a new office and is expected to return some time tomorrow
00:32:25 <ivanm> mxc-wrk: that'll be part of darcs3 IIRC :p
00:39:58 <hpaste>  morrow annotated "BoolExp" with "simplify now does its best" at http://hpaste.org/8573#a6
00:48:26 <BeelsebobWork> is it only me, or is hackage.haskell.org down, but not haskell.org?
00:49:01 <solrize> vixey do the fancier languages make it more straightforward to do that stuff?
00:49:22 <ivanm> BeelsebobWork: different servers IIRC
00:49:29 <BeelsebobWork> ah, I see
00:49:38 <ivanm> doesn't galois host hackage?
00:49:39 <BeelsebobWork> anyone with the power to poke hackage.haskell.org with a pointy thing?
00:50:02 <ibid> istr there was a notice of scheduled downtime'
00:50:12 <ivanm> yeah, they're moving offices or something
00:50:18 <BeelsebobWork> oh, okay
00:50:21 <vixey> solrize: yes and no.. It's harder to write a lot of things because I'm more used to haskell idioms but there is more expression to do these kind of things
00:50:35 <codacola> arrr, knoppix doesnt seme to have any haskell development packages
00:51:00 <ibid> "Hackage and darcs.haskell.org downtime" on the libraries list
00:51:01 <solrize> glguy cool thanks
00:52:27 <ibid> BeelsebobWork: http://www.haskell.org/pipermail/libraries/2008-June/010025.html
00:52:28 <lambdabot> Title: Hackage and darcs.haskell.org downtime
00:54:13 <vixey> mmorrow: simplify (Not (Not (Cond (const True)))) = _|_
00:54:34 <mjrosenb> @hoogle a -> b -> b
00:54:34 <lambdabot> Prelude.const :: a -> b -> a
00:54:35 <lambdabot> Prelude.seq :: a -> b -> b
00:54:35 <lambdabot> GHC.Conc.par :: a -> b -> b
00:54:46 <mjrosenb> dammit
00:54:56 <mjrosenb> flip const seems... ugly
00:55:11 <mjrosenb> more ugly than (\ x y -> y)
00:55:23 <vixey> :t flip const
00:55:25 <lambdabot> forall a b. b -> a -> a
00:56:16 <vixey> mjrosenb: Just name flip const something else and use that then?ao
00:56:28 <mjrosenb> err flip const
00:56:35 <mmorrow> vixey: crap
00:56:42 * mjrosenb entered flip . const
00:56:48 <mjrosenb> that is a very different function
00:57:06 <mjrosenb> vixey: i'm using it *once*
00:57:29 <vixey> mjrosenb: That's fine you should still abstract
01:03:36 <hpaste>  morrow annotated "BoolExp" with "Not works" at http://hpaste.org/8573#a7
01:03:56 <mmorrow> nice catch vixey
01:07:05 <mjrosenb> is there a good reason i can't create an instance Show (Foo -> Foo)?
01:07:28 * mjrosenb guesses how it's implemented internally
01:09:09 <paolino> is it a type synonim instance ?
01:09:12 <mmorrow> mjrosenb: that'd be great if the default was to spit out pagefulls upon pagefulls of asm to your screen and you're like wtf!!
01:10:41 <mjrosenb> paolino: Foo is a datatype
01:11:04 <mjrosenb> mmorrow: right, but i can let's say, evaluate something, then show that
01:11:33 <mjrosenb> in this instance evaluation doesn't loose a whole lot of information
01:13:42 <vixey> mmorrow: Now fix Or :P
01:15:37 <mmorrow> mjosenb: i was just picturing that situation and laughing audibly to myself....i totally agree, i usually way is to print the type sig or something
01:15:56 <mmorrow> s/way is to/
01:16:00 <mmorrow> /
01:16:04 <paolino> type C = Int -> Int
01:16:04 <paolino> instance Show C where
01:16:04 <paolino>  show _ = "no"
01:16:08 <paolino> compiles here
01:17:16 <mmorrow> vixey: uhoh, what?
01:17:42 <vixey> mmorrow: Same problem as Not
01:18:28 <quicksilver> mjrosenb: you can certainly write a show instance if you want to.
01:18:29 <mmorrow> haha, i just realized
01:18:32 <quicksilver> lambdabot has one.
01:18:36 <vixey> mmorrow: in mine I try to arrange a set of invariants that would ensure termination and also that simplification is done everyone as much as possible, so simplify works from the inside out applying simplSteps to each compound (that will terminate if the input is finite and simplSteps does), simplSteps is transitive closure of simplStep so if simplStep always decreases the 'complexity' of the term or return Nothing simplSteps wil also always terminate..
01:18:36 <vixey>  the notion of 'complexity' is just a totally abstract thing (it's not in the code anywhere) but it could be say the sum of the number of constructors in the code
01:18:38 <mmorrow> ghci> simplify (Or (Or (Cond id) (Cond id)) (Or (Cond id) (Cond id)))
01:18:39 <mmorrow> Interrupted.
01:18:46 <quicksilver> > (\x -> "foo" ++ x)
01:18:47 <lambdabot>  <[Char] -> [Char]>
01:19:11 <mmorrow> vixey: good point, i see the general problem
01:19:50 <solrize> @hoogle a -> [a]
01:19:51 <lambdabot> Prelude.repeat :: a -> [a]
01:19:51 <lambdabot> Data.List.repeat :: a -> [a]
01:19:51 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
01:20:01 <mmorrow> vixey: transitive closure FTW
01:20:14 <vixey> hehe
01:21:12 <mmorrow> so by taking the "closure" => you're finding the terminal object
01:21:37 <quicksilver> mmorrow: it's strange how much easier it is to perceive the general problem from a specific example, sometimes, than explain the general case properly.
01:21:48 <quicksilver> says something odd about the human brain. Or just my brain maybe.
01:22:19 <mmorrow> quicksilver: interesting observation
01:22:21 <mmorrow> totally
01:24:03 <telemach> does someone have a copy of storable-complex-0.1.tar.gz floating around?
01:24:34 <telemach> i need it for work. unfortunately hackage still doesn't work.
01:25:04 <mmorrow> http://code.haskell.org/~morrow/code/storable-complex-0.1.tar.gz
01:25:13 <mmorrow> how's that for speed ;)
01:25:45 <telemach> great!
01:25:48 <telemach> thanks :)
01:26:06 --- mode: ChanServ set +o quicksilver
01:27:21 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/", "{hackage,darcs}.haskell.org down until approx 2008.06.28"]' by quicksilver
01:27:36 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/", "{hackage,darcs}.haskell.org down until approx 2008.06.28 UTC"]' by quicksilver
01:28:09 <ski_> mmorrow : may i ask if i may ask what you are hacking on ?
01:29:04 <vixey> *Main> (\x -> case x of Nothing -> (False,False) ; Just x -> (x,not x))
01:29:07 <vixey> (\x -> case x of Nothing -> (False,False) ; Just True -> (True,False) ; Just False -> (False,True))
01:29:07 <vixey> :P
01:29:55 <vixey> mjrosenb: sort of silly but you can do it
01:30:57 <vixey> (slightly dodgy too)
01:31:00 <vixey> *Main Data.Maybe> fromJust
01:31:00 <vixey> (\x -> case x of Nothing -> *** Exception: Maybe.fromJust: Nothing
01:33:19 <mjrosenb> vixey: how did you get that into an instance Show?
01:34:22 <vixey> I defined a typeclass that enumerates every element of a type
01:34:28 <vixey> instance Inhabitants Bool where inhabitants = [True,False]
01:34:45 <vixey> It's quite simple from there to define instance (Inhabitants p, Show p, Show q) => Show (p -> q) where
01:35:03 <vixey> you just map the function over the inhabitants of the domain and pretty print it
01:35:14 <quicksilver> it's more common to print it as a list of pairs
01:35:17 <quicksilver> than a case expression
01:35:24 <quicksilver> although the latter is certainly cute :)
01:35:28 --- mode: quicksilver set -o quicksilver
01:35:48 <ski_> mmorrow : is this intended :
01:35:53 <ski_>   simplify (And _ (Lit False)) = Lit True
01:35:55 <ski_>   simplify (And _ (Lit False)) = Lit True
01:35:59 <ski_> er
01:36:12 <ski_>   simplify (Or _ (Lit True)) = Lit False
01:36:46 <ski_> shouldn't the `True' and `False' results there be flipped ?
01:37:00 <mjrosenb> vixey: perhaps i should be more specific
01:37:09 <ski_> > False && undefined
01:37:10 <lambdabot>  False
01:37:15 <ski_> > True || undefined
01:37:16 <lambdabot>  True
01:38:59 <mjrosenb>     Illegal instance declaration for `Show (AST -> AST)'
01:38:59 <mjrosenb>         (The instance type must be of form (T a b c)
01:38:59 <mjrosenb>          where T is not a synonym, and a,b,c are distinct type variables)
01:38:59 <mjrosenb>     In the instance declaration for `Show (AST -> AST)'
01:38:59 <mjrosenb> Failed, modules loaded: none.
01:39:10 <mmorrow> ski_: oops.
01:39:18 <quicksilver> mjrosenb: -XFlexibleInstances
01:39:29 <quicksilver> mjrosenb: this has nothing to do with it being a function type.
01:39:34 <vixey> I didn't need flexible instances
01:39:54 <quicksilver> mjrosenb: it would also be illegal (in haskell 98) to define a Show instance for data Pair a b = Pair a b; instance Show (Pair Int Int)
01:39:55 <vixey> I don't know if it could be avoided in general..
01:40:01 <quicksilver> vixey: no, because your instance was legal.
01:40:10 <quicksilver> vixey: it was correctly polymorphic in all type parameters.
01:40:28 <quicksilver> mjrosenb: haskell98 has a very restrictive and unhelpful syntactic restriction on instance forms.
01:40:30 <ski_> mmorrow : also, is it intended to not have these short-cut rules in `eval' ?
01:40:37 <mmorrow> ski_: oh nothing in particular in terms of what it's for, but very particular about what idea it's for
01:41:00 <mjrosenb> quicksilver: i see
01:41:45 <ski_> mmorrow : ? .. can you elaborate what you mean ?
01:42:08 <mmorrow> simplifying ASTs containing functions, then turning them back in to functions, while trying to simplify thosebuilt-up ASTs as much as possible in the middle
01:42:33 <mmorrow> that should've started...
01:42:43 <mmorrow> "building ASTs containing functions...
01:42:54 <vixey> I think it's a good candidate for HOAS but the problem is still how to parse them from untyped representatinos
01:43:09 <mmorrow> hmm
01:43:11 <vixey> (without TH?)
01:43:39 <vixey> (Just to make things much harder for no real reason :P)
01:43:40 <mmorrow> i think one would *have* to use Rank2Types and unsafeCoerce
01:43:47 <ski_> parse `Exp a' ?
01:43:58 <mmorrow> data Exp t = Exp t (forall a. a)
01:44:09 <mmorrow> then,
01:44:14 <ski_> hm ?
01:44:27 <mmorrow> exp2Int :: Exp Int
01:44:37 <mmorrow> exp2Int (Exp _ a) = unsafeCoerce a
01:44:41 <ski_> what concrete syntax would be allowed for values of type `Exp a' ?
01:44:55 <quicksilver> mjrosenb: I believe it's generaly accepted that it's quite safe to use FlexibleInstances.
01:45:04 <mmorrow> or actually i think you can use GADTs to accomplish the same
01:45:07 <ski_> mmorrow : i don't think the `unsafeCoerce' is needed in that case
01:45:07 <quicksilver> I wonder if yhc/nhc supports them.
01:45:09 <vixey> ski_: In the paste did you see my 'Term'?
01:45:27 <mmorrow> but you're essentially performing identical tasks with unsafeCoerce and the GADT
01:45:39 <ski_> vixey : not sure .. i skipped to the end of <http://hpaste.org/8573> to get recent
01:46:09 <ski_> (found it)
01:46:57 <mmorrow> (that shou've been exp2Int :: Exp Int -> Int
01:46:59 <mmorrow> )
01:47:53 <quicksilver> I thought I remembered a discuss with one of you (ski?) in which we decided that GADTs didn't solve the parsing problem?
01:48:05 <vixey> I can't help but think this is simplified by dynamic typing..
01:48:20 <quicksilver> all type problems are simplified by dynamic typing.
01:48:26 <quicksilver> they stop being problems.
01:48:31 <ski_> (mmorrow : since the second component was polymorphic, it should allow itself to be of type `Int' with no coercing required)
01:48:32 <vixey> verry good point :)
01:48:33 <jon_of_arc> Not quite all
01:48:37 <quicksilver> However, dynamic typing is not a monotone improvement on your program.
01:48:49 <quicksilver> it removes your typing problems and gives you soundness problems instead.
01:48:49 <jon_of_arc> Truly wrong types stay about as much a problem as they were.
01:48:54 <jon_of_arc> Well, fair enough.
01:49:10 <mmorrow> but its not Exp t = forall a. Exp t a , it's Exp t = Exp t (forall a. a)
01:49:33 <ski_> right .. so the component is polymorphic, not existential
01:49:44 <mmorrow> so, you have to unsafeCoerce it from *All* types to a particular one
01:49:52 <mapreduce> Except in those cases where you know the code will not fail but don't know how to persuade the typesystem of that.
01:50:05 <ski_> mmorrow : no
01:50:06 <mmorrow> ski_: i may be wrong
01:50:08 <quicksilver> does the unsafeCoerce idea make sense with all possible haskell implementations.
01:50:13 <quicksilver> or is it a coincidence of GHC?
01:50:21 <quicksilver> for exampe, JHC uses explicit type parameters.
01:50:26 <quicksilver> I think unsafeCoerce breaks it then
01:50:35 <mmorrow> ski_: hmm, lemme get some code from the other day that i am basing 100% of my opinion on...)
01:50:43 <quicksilver> s/coincidence/peculiarity/
01:50:51 <ski_> mmorrow : consider the record representation of a monad `data Monad m = MkMonad (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)'
01:51:29 <ski_> mmorrow : here the two components are also polymorphic, you can restrict `a' and `b' to any type you like, when you extract the second component
01:51:35 <quicksilver> ski: +(forall a b. (a -> b) -> m a -> m b)
01:51:45 <quicksilver> ;)
01:52:38 <ski_> mmorrow ; however, when you *construct* the package, you may only pack polymorphic components .. in your case, you may only pack `undefined' as second component of the `Exp' data constructor (unless you cheat by dark magic)
01:52:56 <hpaste>  morrow pasted "polymorphic vs. existential" at http://hpaste.org/8576
01:53:19 <ski_> quicksilver : you can construct that from the other components
01:53:36 <quicksilver> ski_: yes, it was a half-joke, sorry.
01:53:50 <ski_> np
01:53:54 <mmorrow> ski_: hmm
01:54:25 <mmorrow> ski_: so i guess then that what i was really talking about was how to put stuff in their by dark magic
01:54:44 <mmorrow> ski_: thereby being able to manipulate types in any way you please
01:54:59 <mmorrow> ski_: (under strictly controlled conditions of course)
01:55:02 <ski_> (mmorrow : of course, if you used an existential in `Exp' the situation would be the converse .. you could pack anything, but you couldn't extract without evil)
01:55:21 <mmorrow> haha, good point
01:55:35 <mmorrow> the dual needs consideration as well
01:55:50 <adu> phew
01:56:08 <adu> i just finished packing for vacation
01:56:10 <adu> :)
01:56:37 <ski_> @hoogle pack
01:56:37 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
01:56:37 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
01:56:37 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
01:56:43 <quicksilver> for some reason using the existential fees more logica
01:56:55 <quicksilver> unsafeCoerce'ing on the way out.
01:57:02 <quicksilver> rather than on the way in.
01:57:46 <mmorrow> hmm
01:58:47 <adu> is 30x fewer lines of code an average comparison between C and Haskell?
01:59:49 <quicksilver> adu: sounds a little on the optimistic side
01:59:58 <quicksilver> I'd have guess 4x to 10x depending on coding styles
02:00:03 <quicksilver> (both C and haskell coding styles)
02:00:17 <quicksilver> I haven't done a study though. :)
02:00:39 <asmanian> well I guess one could say if haskell needs N times fewer lines of code you have to think about each line N times longer ;)
02:00:41 <adu> quicksilver: well, I just implemented (read . filter isDigit) in 20 LoC and (unwords . reverse . words) in 40 LoC
02:00:45 <asmanian> <- haskell beginner
02:01:07 <adu> quicksilver: so i figured the average was 30...
02:01:35 <Vq^> asmanian: not exactly N ;)
02:01:49 <adu> and obviously, (read . filter isDigit) is 1 LoC, which makes for a 20/1 ratio in that case
02:02:06 <Vq^> asmanian: but i agree that one probably reads one haskell-line for longer time
02:02:29 <adu> Vq^: i suppose
02:02:43 <quicksilver> adu: yes but that's severe cheating.
02:02:51 <Vq^> adu: i think it depends a lot on the problem
02:02:58 <quicksilver> adu: it would be 3 lines in C if you had equivalent libraries.
02:03:07 <quicksilver> or thereabouts.
02:03:09 <dibblego> it is not lines of code that matters; it's the composition of smaller parts to make larger parts
02:03:16 <asmanian> yeah libraries matter a lot
02:03:17 <Vq^> adu: some things are really awkward to write in C :/
02:03:31 <asmanian> so loc comparsion is always somewhat vague
02:03:45 <adu> Vq^: but thats the thing, I didn't even choose these excersises
02:04:50 <adu> quicksilver: true, all the while, I was wondering if I could use Glib
02:05:26 <adu> Glib is good for C
02:06:30 <quicksilver> it's true that the libraries are fiddly to implement in C, though.
02:06:42 <quicksilver> what do you use for [String]? char **?
02:06:46 <quicksilver> (thinking about words)
02:06:57 <quicksilver> if you use char **, who is responsible for deallocating the memory?
02:06:58 <quicksilver> etc.
02:07:09 <quicksilver> not enough abstraction around data types.
02:08:04 <adu> quicksilver: I didn't use [String], I did this: http://pastebin.com/m77599a5d
02:08:36 <adu> I fill up the destination string in order, but skip around the source string
02:08:46 <quicksilver> yes.
02:09:02 <quicksilver> C's limitations make you write your algorithms awkwardly ;)
02:09:34 <quicksilver> on the other hand, this awkwardness is coupled with a relatively easy to understand mapping to machine code, and predictably fast code.
02:09:37 <quicksilver> it's not all bad.
02:09:49 <Vq^> no, C certainly has it's place
02:10:09 <quicksilver> I'm implementing isosurface tesselation at the moment.
02:10:29 <quicksilver> On the one hand this kind of algorithm would be well suited to C's compact array types
02:10:32 <quicksilver> and be much faster in C
02:10:39 <quicksilver> on the other hand, it would be bloody hard to get it right :)
02:10:54 <quicksilver> haskell's abstract data types help a lot with labelling the 6 faces of a cube, for example.
02:11:09 <Vq^> sounds interesting, i've played around with isosurfaces in povray quite a bit :)
02:11:50 <quicksilver> data Axis = X | Y | Z; data Polarity = Plus | Minus; type Face = (Axis,Polarity); type Corner = (Polarity,Polarity,Polarity); type Edge = (Axis,Polarity,Polarity)
02:12:10 <quicksilver> that kind of thing is nasty in C; You find a really space-efficient encoding of all that as ints or chars
02:12:14 <quicksilver> and then no-one else can read your code :)
02:12:18 <quicksilver> or yourself, 2 days later.
02:12:22 <kalven> just write an implementation of it, link it to reddit with the title "lolz, haskell is slow" and some haskell evangelists will rush in to fix any performance issues.
02:12:52 <quicksilver> given that I'm reasonably well acquainted with the evangelists in question I could probably just ask them to help :)
02:13:01 <quicksilver> but yes, trolling tends to get quick answers.
02:13:21 <osfameron> is there a pragma for that {# LANGUAGE lolz-haskell-is-slow #} that will do that automatically?
02:14:12 <adu> quicksilver: lol
02:14:46 <Vq^> :)
02:14:52 <adu> osfameron: lol
02:14:57 <kalven> osfameron: no, but there's a plz-dons-,-rewrite-my-idiomatic-haskell-in-c-ish-haskell pragma
02:15:03 <quicksilver> osfameron: nice idea, you should file a trac ticket
02:15:24 <quicksilver> Vq^: the fun bit is to animate the algorithm so you can see it working.
02:15:33 <quicksilver> Vq^: of course this is substantially more work, but it's definitely the fun part.
02:15:37 * quicksilver likes code he can visualise.
02:16:01 * adu too
02:16:21 <quicksilver> once you've got a basic tesselation from a grid, you can then refine the triangles.
02:16:32 <quicksilver> and then simplify triangles if the surface is quite flat at that point
02:16:48 <quicksilver> and end up with an adaptive tesseation which only uses lots of triangles at the tricky bits.
02:20:23 <Peaker> If I want a linked list with O(1) deletion of an arbitrary node - what can I use?
02:22:06 <ski_> zipper
02:22:14 <ski_> `IORef',`STRef s'
02:23:00 <quicksilver> Peaker: what makes you think you want a linked list?
02:23:12 <quicksilver> that's an implementation technique, not a specification.
02:23:19 <quicksilver> perhaps you want Data.Sequence
02:23:28 <Peaker> quicksilver, true. surely I can use other techniques, but I was wondering
02:23:32 <quicksilver> which is not a linked list, but has O(log (something small)) deletion.
02:23:36 <ivanm> isn't there that new random skipped list igli or someone did?
02:23:55 <Peaker> quicksilver, AFAIC, O(log(..)) on today's computers is O(1) :-)
02:24:00 <quicksilver> yes, there's a random access list which is slightly faster than sequence for particular usage pattern.
02:24:00 <Peaker> well, almost ;)
02:24:03 <quicksilver> Peaker: exactly.
02:24:05 <osfameron> talking of linked lists: I wrote a cached version of fac i.e. as a lazy list, and it didn't seem to be any faster than just calculating the product of [1..n] each time.  Is that going to be the overhead of descending the list each time?
02:24:28 <quicksilver> osfameron: yes, following two pointers is slower than doing one multiplication :)
02:24:46 <osfameron> quicksilver: heh, still, was instructive to do
02:25:06 <quicksilver> Peaker: Data.Sequence is a good general purpose sequence with good compexity operations
02:25:20 <quicksilver> for update / insert / delete / append / split
02:25:21 <osfameron> guess would be worth precaching to an array (I only needed ! of 0..9 anyway.  This is for Euler 34)
02:25:34 <quicksilver> osfameron: or precaching to a Map or a Sequence
02:25:43 <quicksilver> osfameron: anything permitting faster than O(n) access to the nth element :)
02:25:53 <Peaker> quicksilver, thanks
02:26:09 <osfameron> quicksilver: oh, sequence might make more sense, I'll read up on it
02:50:17 <Peaker> is cvs.haskell.org/hackage down?
02:52:14 <Baughn> Peaker: Changing physical location
02:53:51 <quicksilver> Peaker: yes, see topic.
02:54:06 <Saizan_> 5/TOPIC
02:54:10 <Peaker> oh thanks
02:54:56 <ivanm> quicksilver: with the topic, at which _time_ will it be down till? it just says "until approx 2008.06.28 UTC"...
02:55:46 <quicksilver> well, it is approx
02:55:57 <quicksilver> approx 2006.06.28 00:00:00
02:55:58 <ivanm> _very_ :p
02:56:00 <quicksilver> IMO.
02:56:13 <quicksilver> I added 24 hours to the time of dons's message, and added a bit for paranoia.
02:56:16 <Baughn> 0pm, maybe
03:02:35 <mm_freak_work> topic !! 5
03:04:15 <dcoutts_> mm_freak_work: it's moving to a fatter pipe
03:07:43 <mm_freak_work> ok
03:11:42 <ski_> > topic !! 5
03:11:44 <lambdabot>   Not in scope: `topic'
03:14:28 <camio> @users
03:14:29 <lambdabot> Maximum users seen in #haskell: 469, currently: 419 (89.3%), active: 9 (2.1%)
03:15:03 <camio> @hoogle
03:15:03 <lambdabot> HOOGLE - Haskell API Search
03:15:03 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
03:15:03 <lambdabot>  
03:15:15 <camio> @hoogle lambda
03:15:16 <lambdabot> No matches found
03:16:25 <camio> I've got a program that works well when compiled with ghc, but with ghci it painfully fails. Anyone know what the differences are?
03:19:06 <dcoutts_> camio: how does it fail?
03:19:42 <camio> dcoutts: Eats up all RAM and freezes (It's a reactive opengl app)
03:20:18 <dcoutts_> camio: ok, so there are a couple possibilities
03:20:32 <ivanm> possibly because it's interpreting and taking longer?
03:20:54 <dcoutts_> camio: ghci is of course a bytecode interpreter and it does not apply many optimisations. Some optimisations can eliminate space leaks so that's one possibility.
03:20:55 <camio> Well, it doesn't actually finish processing one frame.
03:21:13 <dcoutts_> camio: see if it works to compile all the modules first and then load it up in ghci
03:21:28 <dcoutts_> that'd tell us if it was an issue with compiling vs bytecode
03:21:54 <dcoutts_> camio: the other issue is that ghci uses the multi-threaded runtime system by default where as by default compiled progs do not
03:22:10 <dcoutts_> so if you are using threads in your program then that can make a difference
03:22:10 <camio> dcoutts: Same behavior
03:22:13 <BeelsebobWork> yep, we've been using -threaded in GHC
03:22:18 <BeelsebobWork> and -N2 in +RTS
03:22:39 <camio> And it works without them as well, when compiled.
03:22:55 <dcoutts_> camio: and in both cases you were compiling with -O I presume?
03:23:02 <camio> dcoutts: neither
03:23:07 <dcoutts_> ok
03:23:48 <dcoutts_> camio: and did you say if you were using -threaded when you built the standalone program?
03:24:15 <BeelsebobWork> yep
03:25:08 <camio> dcoutts: yep
03:25:09 <quicksilver> I've never found openGL to work well in ghci
03:25:13 <quicksilver> or, indeed, at all.
03:25:22 <dcoutts_> so to clarify: worked: "ghc --make -threaded Foo.hs && ./Foo", failed: "ghc --make -threaded Foo.hs && ghci Foo.hs"
03:25:44 <quicksilver> (at all in ghci)
03:25:48 <camio> dcoutts: correct
03:26:13 <dcoutts_> camio: ok, well we've eliminated the obvious differences then. :-(
03:26:16 <camio> quicksilver: I have seen it work pretty well in other circumstances (using yampa instead of reactive).
03:26:34 <hpaste>  beelsebob pasted "what camio is talking about" at http://hpaste.org/8577
03:27:10 <BeelsebobWork> dcoutts: note the bus error in ghci, but not when running the built binary
03:27:19 <dcoutts_> BeelsebobWork: right
03:27:22 <BeelsebobWork> same thing happens with all the .os hanging about when ghci is run
03:28:44 <dcoutts_> BeelsebobWork, camio: well, see if you can make a small test case and submit it as a ghc bug
03:29:35 <maltem> Wait, this is on OS X?
03:29:49 <dcoutts_> maltem: seems so
03:30:00 <camio> maltem: OS X and windows (I'm the sellout, Bob is the winner)
03:30:04 <maltem> Where you have to "bundle" graphical applications so they run at all? Or does this particula rapp run wuthout bundling?
03:30:11 <maltem> erm
03:30:35 <maltem> ... particular app run without bundling
03:30:38 <dcoutts_> that's a point, in the paste they're running mkbndl -f Boingee0 in the compiled case
03:30:43 <BeelsebobWork> maltem: it runs without bundling -- but it doesn't like becoming the front meost window
03:30:44 <quicksilver> maltem: openGL apps run without bundling.
03:30:53 <quicksilver> maltem: there is something magic in GLUT.
03:31:00 <quicksilver> dunno what exactly.
03:31:02 <BeelsebobWork> it fails in the same way without the mkbndl
03:31:18 <BeelsebobWork> quicksilver: yeh, it's magic glut stuff -- not magic open gl stuff
03:31:27 <dcoutts_> BeelsebobWork: you mean it works in the same way, it's the compiled case that's working right?
03:31:29 <BeelsebobWork> so us using glfw, it needs to get bundled to become frontmost
03:31:40 <quicksilver> right.
03:31:46 <quicksilver> definitely GLUT magic.
03:31:50 <quicksilver> I wish I understood how it worked :)
03:31:51 <BeelsebobWork> dcoutts_: both have the same behavior (except that it doesn't come frontmost) without the bundling
03:32:38 <BeelsebobWork> the only difference between OS X and windows is that the windows version dies and eats ram, without exiting, while the OS X version bus errors and dies instantly
03:32:38 <maltem> ah ok... anyway, I think on the wxhaskell pages they advertise similar magic to run graphical apps from ghci
03:33:03 <maltem> it may be interesting to compare those approaches of magic :)
03:33:34 <BeelsebobWork> the ghci version does not crash, iff all calls to openGL functions are commented out
03:33:44 <BeelsebobWork> which suggests that ghci might be moving the openGL call from one system thread to another
03:33:53 <BeelsebobWork> hence causing the OpenGL implementation to bail
03:34:16 <dcoutts_> BeelsebobWork: are you using bound threads for the gl calls then?
03:34:28 <quicksilver> maltem: if you you succeed in understanding the magic or unveiling some details, I'd be really grateful if you posted your understanding to the -cafe
03:34:31 <quicksilver> maltem: and/or the wiki
03:34:32 <dcoutts_> BeelsebobWork: that could be it you know
03:34:43 <dcoutts_> BeelsebobWork: the 'main' thread is always bound
03:34:48 <BeelsebobWork> then it should be bound
03:34:55 <BeelsebobWork> because all OpenGL is happening on the main thread
03:34:55 <quicksilver> does ghci guarantee that the main thread is bound, though?
03:35:02 <quicksilver> are you running it by calling "main" as an action
03:35:06 <quicksilver> or using the magic ":main" ?
03:35:14 <BeelsebobWork> nope, -e Main.main in the command line
03:35:29 <dcoutts_> BeelsebobWork: so if you're doing your gl calls from the main thread in the compiled prog but if ghci fires off evals in an ordinary forkIO'ed thread then it would not be bound
03:35:32 <EvilRanter> ... wouldn't it be better to use runghc?
03:35:58 <BeelsebobWork> dcoutts_: sounds reasonable -- how can that be made bound?
03:36:08 <BeelsebobWork> EvilRanter: possibly -- but this is interesting
03:36:47 <dcoutts_> BeelsebobWork: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#8
03:36:48 <lambdabot> http://tinyurl.com/33wpmr
03:37:06 <dcoutts_> BeelsebobWork: open ghci and test Control.Concurrent.isCurrentThreadBound
03:37:49 <quicksilver> you could try running (forkOS main) from ghci
03:37:51 <quicksilver> I think?
03:38:13 <quicksilver> malcolmw: does yhc do -XFlexibleInstances ?
03:38:35 <malcolmw> quicksilver: no
03:38:40 <dcoutts_> quicksilver: runInBoundThread might be better
03:38:43 <BeelsebobWork> that's it dcoutts_
03:38:50 <dcoutts_> @yarr!
03:38:50 <lambdabot> Smartly me lass
03:38:54 <quicksilver> BeelsebobWork: fixed?
03:38:56 <BeelsebobWork> Control.Concurrent.runInBoundThread main -- works fine
03:39:01 <malcolmw> quicksilver: at least, I don't know what they are, but if they aren't H'98, then yhc doesn't do them
03:39:40 <quicksilver> malcolmw: think like instance Show (Pair Int Int)
03:39:50 <dcoutts_> BeelsebobWork: so I guess ideally for the lib to be transparent it should use runInBoundThread on the gl ops
03:39:54 <quicksilver> malcolmw: instances for specific types which are abstracted over all variables.
03:40:01 <quicksilver> BeelsebobWork: awesome.
03:40:14 <malcolmw> quicksilver: definitely not
03:40:15 <quicksilver> BeelsebobWork: I must make some more experiments abotu running opengl code in ghci then.
03:40:33 <quicksilver> BeelsebobWork: I gave it up as a bad job.
03:40:40 <quicksilver> unfortunately most of my opengl code links in WX too
03:40:43 <quicksilver> that has its own problems.
03:41:48 <maltem> quicksilver: (re if you you succeed in ...), right, *if*. :) I wasn't even planning to do so, I'm afraid
04:04:27 <hukolele> @hoggle (Eq a) => Int -> [a] -> [a]
04:04:28 <lambdabot> Prelude.take :: Int -> [a] -> [a]
04:04:28 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
04:04:28 <lambdabot> Data.List.take :: Int -> [a] -> [a]
04:05:40 <hukolele> how can get elements from a list complaining a condition plus 1 w/o using length? i mean some like this:
04:05:57 <hukolele> take (((+1) . length . takeWhile (/=0)) [1,2,3,0,4]) [1,2,3,0,4]
04:06:09 <hukolele> > take (((+1) . length . takeWhile (/=0)) [1,2,3,0,4]) [1,2,3,0,4]
04:06:12 <lambdabot>  [1,2,3,0]
04:06:38 <ivanm> hukolele: you could do something like this:
04:06:51 <hukolele> but its no lazy, i need a lazy version
04:08:10 <ivanm> > let f xs = let (taken,rest) = split (/= 0) xs in taken ++ (take 1 rest) in f [1,2,3,0,4]
04:08:11 <lambdabot>  Couldn't match expected type `t -> (t1, t2)'
04:08:25 <ivanm> or something :p
04:08:38 <ivanm> > split (/= 0) [1,2,3,0,4]
04:08:38 <lambdabot>  Couldn't match expected type `[t1] -> t'
04:08:43 <ivanm> @type split
04:08:45 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
04:08:54 <ivanm> oh, whoops, not what I wanted :s
04:09:08 <ivanm> @hoogle (a -> Bool) -> [a] -> ([a],[a])
04:09:08 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
04:09:08 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
04:09:08 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
04:09:16 <ivanm> > let f xs = let (taken,rest) = span (/= 0) xs in taken ++ (take 1 rest) in f [1,2,3,0,4]
04:09:17 <lambdabot>  [1,2,3,0]
04:09:24 <ivanm> hukolele: ^^ there you are
04:09:49 <hukolele> > let f xs = let (taken,rest) = span (/= 0) xs in taken ++ (take 1 rest) in f ([1,2,3,0,4]++[0..])
04:09:50 <lambdabot>  [1,2,3,0]
04:10:00 <hukolele> thx ivanm!! :D
04:10:30 <ivanm> no worries
04:14:52 <ivanm> > let f xs = let (taken,rest) = span (/= 0) xs in taken ++ (take 1 rest) in f [1,2,3,4] -- check if all match
04:14:53 <lambdabot>  [1,2,3,4]
04:16:51 <ivanm> yay for laziness!
04:17:35 <ivanm> sorry, just felt like saying that... a function I just wrote works nicely because iterate is lazy and I do a takeWhile to ensure an invalid value isn't used
04:17:53 <ivanm> hmmm.... actually, hukolele, it turns out that I need that function as well! ;-)
04:19:15 <hukolele> im in same situation haha
04:19:42 * ivanm defines takeWhile' in his code
04:20:12 <hukolele> i defined takeWhilePlusOne 8)
04:20:33 <ivanm> though it's not the most efficient possible, since the ++ at the end adds time...
04:20:36 <ivanm> @src takeWhile
04:20:37 <lambdabot> takeWhile _ []                 =  []
04:20:37 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
04:20:37 <lambdabot>                    | otherwise =  []
04:21:07 <ivanm> hmmmm.... might be an idea to define it based on this code to avoid the ++
04:21:58 <hukolele> recursion doesnt looks as much  elegant
04:23:19 <paolino> @pl \(x:xs) -> (x,xs)
04:23:20 <lambdabot> liftM2 (,) head tail
04:23:27 <ivanm> yes, but efficiency is improved!
04:23:38 <EvilTerran> ?type head &&& tail
04:23:39 <lambdabot> forall a. [a] -> (a, [a])
04:24:27 <EvilTerran> it'd just be a case of replacing the "otherwise = []" with "otherwise = [x]", i think
04:24:36 <vixey> why would anyone want [a] -> (a, [a]) /
04:24:37 <vixey> ?
04:24:40 <ivanm> EvilTerran: yeah, I was just about to say that :p
04:24:51 <EvilTerran> vixey, dunno, ask paolino
04:25:17 <paolino> > (id *** reverse) . (head &&& tail) . reverse $ [1..10]
04:25:19 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
04:25:37 <EvilTerran> > last &&& init $ [1..10]
04:25:38 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
04:26:15 <opqdonut> > uncurry (:) $ last &&& init $ [1..10]
04:26:16 <lambdabot>  [10,1,2,3,4,5,6,7,8,9]
04:26:17 <opqdonut> :P
04:26:34 <vixey> > iterate (uncurry (:) $ last &&& init) "whoosh"
04:26:35 <lambdabot>  Couldn't match expected type `(a, c)'
04:26:39 <vixey> :(
04:26:44 <vixey> > iterate (uncurry (:) . last &&& init) "whoosh"
04:26:45 <lambdabot>  Couldn't match expected type `[(a, [a])]'
04:26:47 <paolino> EvilTerran: always running the list twice
04:26:53 <vixey> > iterate (uncurry (:) . (last &&& init)) "whoosh"
04:26:54 <lambdabot>  ["whoosh","hwhoos","shwhoo","oshwho","ooshwh","hooshw","whoosh","hwhoos","sh...
04:27:19 <EvilTerran> > map (take 6) . iterate tail . repeat $ "whoosh"
04:27:20 <lambdabot>  [["whoosh","whoosh","whoosh","whoosh","whoosh","whoosh"],["whoosh","whoosh",...
04:27:23 <EvilTerran> er
04:27:29 <EvilTerran> > map (take 6) . iterate tail . cycle $ "whoosh"
04:27:31 <lambdabot>  ["whoosh","hooshw","ooshwh","oshwho","shwhoo","hwhoos","whoosh","hooshw","oo...
04:27:48 <EvilTerran> well, that goes the other way
04:27:53 <paolino> how you get the 6
04:27:58 <EvilTerran> length "whoosh"
04:28:20 <opqdonut> > map (take 6) . iterate (drop 5) . cycle $ "whoosh"
04:28:21 <lambdabot>  ["whoosh","hwhoos","shwhoo","oshwho","ooshwh","hooshw","whoosh","hwhoos","sh...
04:28:30 <opqdonut> but that's ugly, it uses the length
04:28:37 <vixey> nothing ugly about it
04:29:09 <paolino> vixey, no need to scan the list twice in theory
04:29:19 <EvilTerran> might be better to say \x -> map (zipWith (flip const) x) . ...
04:29:20 <vixey> ?
04:29:24 <EvilTerran> that'll work for infinite inputs too
04:31:29 <EvilTerran> ?. pl djinn a -> b -> b
04:31:29 <lambdabot> f = const id
04:33:50 <paolino> no way to scan the list once ?
04:37:50 <paolino> lastinit [x] k = (x,k)
04:37:50 <paolino> lastinit (x:xs) k = let (y,k') = lastinit xs k in (y,x:k')
04:38:13 <paolino> is this scanning it once ?
04:39:24 <EvilTerran> yes
04:39:50 <paolino> I can thwrow away k
04:40:10 <paolino> lastinit [x]  = (x,[])
04:40:11 <paolino> lastinit (x:xs) = let (y,k) = lastinit xs in (y,x:k)
04:40:31 <Botje> :t let lastinit (x:xs) = let (y,k) = lastinit xs in (y,x:k) in lastinit
04:40:32 <lambdabot> forall t t1. [t] -> (t1, [t])
04:40:47 <EvilTerran> um
04:41:15 <EvilTerran> :t let lastinit [x] = (x,[]); lastinit (x:xs) = let (y,k) = lastinit xs in (y,x:k) in lastinit
04:41:16 <lambdabot> forall a. [a] -> (a, [a])
04:42:29 <paolino> is it possible to use fix there ?
04:42:37 <EvilTerran> yes, but it won't be pretty
04:43:04 <paolino> ok, I don't want to see it
04:43:13 <EvilTerran> :t fix (\f (x:xs) -> if null xs then (x,[]) else second (x:) (f xs))
04:43:14 <lambdabot> forall a. [a] -> (a, [a])
04:43:57 <ivanm> what is that meant to do?
04:44:06 <EvilTerran> > fix (\f (x:xs) -> if null xs then (x,[]) else second (x:) (f xs)) [1..10]
04:44:07 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
04:44:45 <paolino> EvilTerran: not so unreadable
04:44:52 <EvilTerran> > fix (\f (x:xs) -> if null xs then (x,[]) else (x:) . f xs) [1..10] -- >:]
04:44:54 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
04:45:02 <EvilTerran> paolino, yeah, the use of Control.Arrow.second really helps
04:45:43 <EvilTerran> ... which also happens to be fmap for (w,), which is what i've taken advantage of there
04:45:50 <chylli> EvilTerran: is there some doc about fix ? i dont really understand it yet.
04:46:52 <paolino> EvilTerran: I don't understand your last
04:47:06 <paolino> :t (.)
04:47:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:47:34 <EvilTerran> i'm using (.) as fmap
04:47:39 <EvilTerran> ?src (,) fmap
04:47:39 <lambdabot> fmap f (x,y) = (x, f y)
04:47:40 <paolino> ah, Calettitudines
04:47:45 <EvilTerran> hence the >:]
04:48:34 <EvilTerran> chylli, i can't think of any appropriate docs on the internet offhand
04:49:15 <chylli> EvilTerran: maybe you can write one ? or can you describe it by one sentence ?
04:49:16 <chylli> :p
04:49:28 <EvilTerran> ?src fix
04:49:29 <lambdabot> fix f = let x = f x in x
04:49:46 <EvilTerran> fix f = x where x = f x
04:50:22 <EvilTerran> applying equational reasoning, we can substitute (f x) for x: "fix f = f x where x = f x"
04:50:41 <EvilTerran> and we can, likewise, substitute (fix f) for x (by the original equation): "fix f = f (fix f)
04:51:31 <EvilTerran> if you like, you can eta-expand to "(fix f) x = f (fix f) x"
04:51:49 <EvilTerran> (dunno if that actually makes things any clearer...)
04:52:05 <EvilTerran> anyway, the point is that f gets (fix f) as its first parameter
04:52:23 <chylli> EvilTerran: I understand it under math circumstance, but not sure in monad, like :
04:52:25 <chylli>     reader <- forkIO $ fix $ \loop -> do
04:52:25 <EvilTerran> so you can do recursion without having to necessarily bind a name
04:52:25 <chylli>         (nr', line) <- readChan chan'
04:52:25 <chylli>         when (nr /= nr') $ hPutStrLn hdl line
04:52:25 <chylli>         loop
04:52:28 <chylli>  
04:52:33 <Saizan_> http://www.vex.net/~trebla/haskell/fix.xhtml
04:53:34 <chylli> thanks
04:53:49 <EvilTerran> fix f = f $ fix f = f $ f $ fix f = f $ f $ f $ fix f = ...
04:55:13 <chylli> oh, then i got a recursive funcion. isn't it ?
04:55:17 <Saizan_> however fix (\f -> <...>) === let f = <...> in f
04:55:43 <Saizan_> yes, fix is nothing more than recursion
04:56:24 <Saizan_> but you can also have recursive values that are not functions
04:56:44 <Saizan_> > let ones = 1:ones in ones
04:56:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:56:50 <Saizan_> > fix (1:)
04:56:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:57:05 <opqdonut> a short blog post on fix: http://pseudo.fixme.fi/~opqdonut/blog/Musings_on__code_fix__code_.html
04:57:07 <lambdabot> Title: (&#x03BB;blog. blog blog) (&#x03BB;blog. blog blog): Musings on <code>fix</code>, http://tinyurl.com/6gvsoj
04:57:38 <opqdonut> heh, those tags show up in the html name, I should fix that
05:00:18 <vixey> -+
05:00:34 <quicksilver> opqdonut: nothing wrong with using entities in a title, AFAIK.
05:01:10 <ivanm> Saizan_: with that link, is the fibonacci fix code right? lambdabot doesn't seem to like it :s
05:01:12 <opqdonut> quicksilver: yeah, but there's something wrong with "Musings_on__code_fix__code_.html"
05:01:21 <quicksilver> ah ;)
05:01:24 <opqdonut> :)
05:02:38 <masak> dons: if there is a new darcs repo for yi, why don't you change the address of the darcs repo on your yi page?
05:03:29 <Saizan_> let fibs      = 0 : scanl 1 (+) fibs in fibs
05:03:36 <Saizan_> > let fibs      = 0 : scanl (+) 1 fibs in fibs
05:03:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:03:47 <Saizan_> ivanm: flipped arguments
05:04:00 <ivanm> ahhhhh
05:04:09 <ivanm> about to say, I couldn't even get that working!
05:05:00 <masak> @ask dons if there is a good reason not to change the darcs URIs on http://www.cse.unsw.edu.au/~dons/yi.html to http://darcs.haskell.org/yi
05:05:00 <lambdabot> Consider it noted.
05:05:30 <ivanm> (the let fibs = ... form)
05:07:06 <Saizan_> @tell monochrom in http://www.vex.net/~trebla/haskell/fix.xhtml the arguments to scanl are flipped
05:07:06 <lambdabot> Consider it noted.
05:07:06 <ivanm> masak: because darcs.haskell.org is currently down? :p
05:07:21 <masak> ivanm: just noticed that too :/
05:07:29 <ivanm> masak: /topic
05:08:01 * masak will try to restrain himself
05:08:17 <ivanm> from what?
05:10:45 <masak> Ã–=
05:10:48 <masak> :)
05:11:03 <masak> it's just that I want to play with yi today
05:12:11 <ivanm> ahhh, k
05:12:38 <ivanm> Saizan_: with the fix'd version of factorial... does the actual recursion get delayed until the value is given or something?
05:13:21 <Saizan_> ivanm: sure, lazy eval is outermost first
05:13:25 <ivanm> *nod*
05:13:30 <ivanm> lazy_eval++ :p
05:24:02 <ivanm> in a function defined with guards, is the where statement common to all guards?
05:24:26 <therp> depends on the indention I think..
05:24:33 <opqdonut> yeah
05:24:45 <ivanm> if the w in where is aligned with the |'s
05:24:48 <ivanm> ?
05:24:55 <opqdonut> then common
05:24:59 <opqdonut> i'd think
05:25:01 <ivanm> *nod*
05:26:36 <quicksilver> scoping over guards is the main reason 'where' exists.
05:26:40 <quicksilver> Well, maybe.
05:27:06 <ziman> i prefer `where' to let wherever possible
05:27:21 <ziman> i find it look cleaner
05:27:31 <ivanm> quicksilver: should that be "Maybe well"? :p
05:27:42 <quicksilver> In a mathematical paper, do you define your terms before using them?
05:27:51 <quicksilver> Or use them first, and then define them in a footnote?
05:27:54 <opqdonut> i prefer let too
05:27:57 <ivanm> depends ;-)
05:27:58 <quicksilver> There is no right answer, here.
05:28:04 <quicksilver> both styles are appropriate
05:28:14 <quicksilver> but all else being equal, I would define my terms first
05:28:16 <quicksilver> so I would use let.
05:28:23 <sw17ch> i use let when i want to use arguments to the function in the expression, and where when i want something more pure :)
05:28:27 <quicksilver> using 'where' in those cases makes the reader jump up and down as he tries to understand.
05:28:53 <ziman> i'd first give the sketch of the function in general terms and then decompose the terms to what they actually mean
05:29:00 <quicksilver> I use 'where' when the definition isn't important
05:29:06 <quicksilver> as a general guideline
05:29:33 <RayNbow> I prefer 'where', often using descriptive names
05:29:49 <RayNbow> such that the "main" definition of the function is readable
05:30:31 <nomeata> I use where for larger definitions, such as functions, and let for simple values.
05:33:42 <ivanm> quicksilver: where it isn't _important_ ?
05:34:11 <ivanm> RayNbow: AFAICT, I agree with you :p
05:34:24 <quicksilver> ivanm: yes. important to understanding the function.
05:34:39 <quicksilver> "foo a = burble x where burble = ..." I consider poor style
05:34:41 <ziman> maybe where it's clear from the name, e.g. evenPrimes ;)
05:34:47 <quicksilver> because to understand the function you *have* to understand burble
05:35:05 <quicksilver> so by hiding burble away at the end of the function, you are damaging comprehension.
05:35:09 <quicksilver> However...
05:35:14 <tromp> it's about top-down vs bottom-up
05:35:26 <quicksilver> "foo a = drawCircle radius where radius = ...." I consider fine style
05:35:38 <RayNbow> sort (x:xs) = smaller ++ (x : larger) where ... --? :p
05:35:43 <quicksilver> since it's perfectly possible to understand the function without knowing exactly what the radius is
05:35:52 <quicksilver> and you can look in the "footnote" later
05:36:05 <quicksilver> as a result, clear naming is more important with where-style than let-style.
05:36:11 <quicksilver> not to say it's not important with both, though.
05:38:02 <quicksilver> I also mildly deprecate nested definitions at all.
05:38:19 <quicksilver> top-level definitions are preferred for anything which can be considered remotely independent
05:38:28 <quicksilver> then it can be indepently docced and tested
05:39:22 <lilachaze> quicksilver: if 'burble' has a good name, then "foo a = burble x where burble = ..." seems readable to me
05:40:02 <lilachaze> for instance, "fib n = last (fibsUpTo n) where fibsUpTo = ..."
05:40:19 <ddarius> With an expression that short, the where is going to be immediately on the next line anyway, it's not like you won't be able to figure out what burble is.
05:40:43 <quicksilver> ddarius: yes that was trimmed, I was really talking about longer definitions.
05:40:53 <quicksilver> lilachaze: indeed, hence my comment about naming shortly after.
05:41:34 <ddarius> quicksilver: A longer definition is almost certainly going to fall under the other case.
05:41:36 <lilachaze> a brief survey of code i've written reveals that i almost exclusively use where; i have about as many "do ... let" as "let ... in"
05:42:22 <quicksilver> ddarius: I find that's not true.
05:42:41 <quicksilver> ddarius: in particular, I dislike functions which delegate all the "Real work" to a where clause
05:44:25 <ivanm> anyone here familiar with FGL?
05:44:29 <lilachaze> quicksilver: do you have any code examples from 'in the wild' that you consider to be hard to read due to use of where rather than (say) bad naming? i think that'd help illustrate your point
05:44:29 <ddarius> My opinion is that a "top-down" style is both preferable for reading and writing within a single function.
05:45:14 <quicksilver> lilachaze: not off-hand, but if I come across somethign I'll mention it.
05:45:22 <quicksilver> I'm well aware that I'm in a minority on this point :)
05:45:54 <RayNbow> ddarius: when I'm writing a small app in Haskell, I usually do both top-down as bottom-up :p
05:50:53 <quicksilver> there is a long thread at http://www.mail-archive.com/haskell-cafe@haskell.org/msg32769.html
05:50:54 <lambdabot> Title: [Haskell-cafe] let vs. where, http://tinyurl.com/66mvm5
05:51:02 <Axman6> hmm, is hackage down?
05:51:03 <quicksilver> I don't think it contains anything revoluationary though
05:51:07 <quicksilver> Axman6: yes (see topic)
05:51:09 <ivanm> Axman6: /topic
05:51:25 <Axman6> ah, lame
05:51:33 <Axman6> wanted to try xmonad :\
05:52:00 <mauke> Axman6: the darcs version?
05:52:06 <Axman6> no
05:52:12 <Axman6> but i need X11
05:52:25 <mauke> oh, d'oh
05:52:42 <mauke> I have X11 darcs here :-)
05:52:57 <Axman6> could i het the link? :)
05:52:58 <ivanm> apparently you don't need it anymore...
05:53:16 <SamB> xmonad now works on the console too?
05:53:16 <ivanm> oh, wait, forget that
05:53:16 <Axman6> fair enough
05:53:26 <ivanm> I thought you said you needed the X11 darcs :s
05:53:52 <mauke> http://mauke.ath.cx/tmp/X11/
05:53:53 <lambdabot> Title: Index of /tmp/X11
05:54:24 <ddarius> RayNbow: Most people usually do both in any program in any programming language.  I'm saying that I find top-down is usually better within functions.  For the overall program, it depends.
05:54:26 <mauke> darcs can just pull from that, right?
05:54:42 <ivanm> Axman6: you might be able to find a mirrored copy somewhere...
05:54:51 * ivanm wonders if its in the gentoo mirrors
05:55:13 <Axman6> ivanm: yeah, 'darcs get http://code.haskell.org/xmonad' is working, and X11 is coming from mauke
05:55:17 <Axman6> thanks mauke
05:55:30 <atsampson> if code.haskell.org could be made available by rsync, we could easily mirror it on mirrorservice.org...
05:55:31 <Axman6> is there any compression in darcs?
05:56:12 <mauke> the patches themselves are .gz files
05:56:15 <Axman6> might be useful for people with crap connections like me
05:56:18 <Axman6> ah, excellent
05:57:24 <mauke> looks like it's done
06:00:50 <pgavin> hmm, hackage/darcs.h.o still down?
06:01:09 <dcoutts_> pgavin: it's moving house
06:01:12 <Axman6> bleh, X11 won;t link
06:01:21 <pgavin> dcoutts_: ya, I thought it might be done :)
06:01:25 <gwern> anyone know how one turns a .lhs into .hs?
06:01:32 * gwern is having haddock problems with darcs
06:01:35 <mauke> Axman6: what's the error message?
06:01:39 <pgavin> dcoutts_: rc4 will probably be the final
06:01:39 <dcoutts_> gwern: mv :-)
06:01:43 <dcoutts_> pgavin: cool
06:01:47 <Axman6> ld: library not found for -lX11
06:01:47 <Axman6> collect2: ld returned 1 exit status
06:01:47 <Axman6> linking dist/build/Graphics/X11/Types_hsc_make.o failed
06:01:47 <Axman6> command was: /opt/local/bin/ghc -optl-lX11 dist/build/Graphics/X11/Types_hsc_make.o -o dist/build/Graphics/X11/Types_hsc_make
06:01:49 <gwern> dcoutts_: har har
06:01:55 <Axman6> hmm, thought that was only three lines
06:02:02 <dcoutts_> gwern: ok, and wrap the whole lot in \begin{code} ... \end{code}
06:02:03 <gwern> Axman6: you installed the -dev package?
06:02:05 <pgavin> dcoutts_: have you gotten a chance to test it?
06:02:14 <Axman6> i'm on OS X, and i think i can fix that
06:02:18 <dcoutts_> pgavin: I tried r3 I think it was, on windows
06:02:19 <gwern> dcoutts_: that turns a .lhs into .hs? interesting....
06:02:33 <dcoutts_> gwern: oh, sorry, you can use unlit to do that
06:02:44 <dcoutts_> gwern: ghc -E I think will do it too
06:02:51 <pgavin> dcoutts_: cool, I don't think anything changed in the installer between rc3 and rc4
06:03:08 <mauke> I had a perl command for bird-style .lhs somewhere
06:03:38 <dcoutts_> pgavin: oh I was wondering if the behaviour was as you expected. It lets me continue even if it doesn't find the right ghc version.
06:03:56 <ivanm> I've got one that converts bird to latex that someone did for me when I couldn't get the wiki ones to work...
06:03:56 <pgavin> dcoutts_: yeah, that's what it did before
06:04:05 <dcoutts_> pgavin: really? oh
06:04:16 <dcoutts_> that's my fault then :-)
06:04:27 <pgavin> dcoutts_: I was going to change it so that if it doens't find it automatically you can insert the path to the one you want to use
06:04:52 <pgavin> dcoutts_: but never got around to it
06:04:54 <gwern> anyone know why haddock might object to '-- simple \verb-darcs add newdir newdir/*-'?
06:05:02 <dcoutts_> pgavin: right, sounds like more effort for you, I wouldn't bother
06:05:36 <dcoutts_> gwern: \ is special for haddock ins't it?
06:05:43 <mauke> / is special
06:05:57 <mauke> try newdir\/*
06:06:36 <Axman6> hmm, how do i tell ghc where to look for libs? i'm using './Setup configure --user --ghc-options="-I/usr/X11/include -L/usr/X11/lib"'
06:06:40 <gwern> yeah, but would that break latex?
06:06:57 <mauke> probably
06:09:16 <dcoutts_> Axman6: use ./Setup configure --user --extra-lib-dirs=... --extra-include-dirs=...
06:09:28 <Axman6> ah, thanks
06:09:51 <dcoutts_> Axman6: if you only use ghc-option then you'd have to use the same every time you used the package
06:10:08 <dcoutts_> Axman6: doing the above includes the dirs in the package registration info
06:10:16 <dcoutts_> though those flags are new in Cabal-1.4.x
06:10:32 <Axman6> Setup: Unrecognised flags: --extra-lib-dirs=/usr/X11/lib
06:11:08 <dcoutts_> ah, you're using an older Cabal
06:11:42 <Axman6> cabal-install version 0.5.1
06:11:43 <Axman6> using version 1.4.0.1 of the Cabal library \
06:11:45 <Axman6> ?
06:12:02 <dcoutts_> Axman6: then use cabal and not ./Setup
06:12:14 <Axman6> ok, how do i do that?
06:12:14 <leoncamel> hey. a question from newbie. for this expression "((+1) . (*3)) 15", it is OK. But, this expression, "(+1) . (*3) 15" reports a error. And I am confused about "(.)". As defined in Prelude, the type is "(.) :: (b -> c) -> (a -> b) -> a -> c". what is the difference between "((+1) . (*3)) 15" and "(+1) . (*3) 15" in haskell ?
06:12:17 <dcoutts_> clearly you built that ./Setup using an older version of the Cabal lib
06:12:28 <Axman6> i've only used it to fetch and download packages
06:12:36 <dcoutts_> Axman6: cabal configure --user --extra-lib-dirs=... --extra-include-dirs=...
06:12:37 <pgavin> dcoutts_: I think I need to be added to the sf.net project
06:12:43 <Axman6> i just built setup just then :\
06:12:58 <dcoutts_> pgavin: ah, true. Do you have a sf account?
06:13:27 <dcoutts_> Axman6: if you've got cabal-install there's no need to the runghc Setup.hs stuff ever again
06:13:34 <pgavin> dcoutts_: yep, pgavin
06:13:43 <gwern> (ideally, anyway)
06:13:49 <gwern> hackage is still down right?
06:14:04 <Axman6> Warning: The 'build-type' is 'Configure' but there is no 'configure' script.
06:14:50 <gwern> (oh, that sounds like a problem. if a package claims to need configure, there should be a configure script)
06:15:00 <Axman6> ah, read the README Axman
06:15:07 <gwern> Axman6: what happens if you run 'autoconf' in topdir?
06:15:22 <Axman6> yeah, that's what i just read
06:15:39 * gwern suspected as much
06:15:56 <gwern> hm, I may not be able to get my cabalized darcs to have haddocks
06:16:12 <gwern> (maybe I'll upload today anyway)
06:16:16 <Axman6> ok, looking good dcoutts_ and gwern, thanks a lot
06:16:41 <gwern> Axman6: if you need xinerama support, make sure the configure messages told you it was enabled
06:16:59 <gwern> oft people don't notice and are confounded and confusticated when they actually run xmonad
06:17:06 <Axman6> what is xinerama?
06:17:35 <gwern> multiple monitors
06:17:52 <Axman6> ah, ok. not needed so far
06:19:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8579
06:19:54 <feis> err
06:19:59 <feis> that was me
06:20:16 <feis> I'm new to haskell and trying to do some simple stuff to get used to the language
06:20:39 <feis> but when I try to load that function in ghci it hangs while compiling and just eats cpu
06:20:52 <EvilTerran> feis, if you want to use an alphanumeric name infix, you need to write it between ``s
06:21:01 <EvilTerran> if (num `mod` 3) == 0 || (num `mod` 5) == 0
06:21:01 <EvilTerran>  ...
06:21:17 <feis> EvilTerran: gotcha. thanks a bunch
06:21:22 <leoncamel> hmm, is there anybody could explain the simple previous question ? about (.)
06:21:24 <dcoutts_> pgavin: ok, added. You should be able to make file releases.
06:21:46 <EvilTerran> leoncamel, function application binds tighter than any infix operator
06:22:03 <EvilTerran> (+1) . (*3) 15 = (+1) . ((*3) 15)
06:22:36 <mauke> feis: I have no idea why it does that
06:22:52 <mauke> looks like a bug to me
06:24:07 <feis> mauke: well I fixed my error with not quoting mod and it stopped the hanging
06:27:45 <leoncamel> EvilTerran: hmm, OK. if (.) (+1) (*3) 15. they are all prefix functions. the order should be "left to right" ?
06:31:06 <lilachaze> leoncamel: (.) (+1) (*3) 15 === ((+1).) (*3) 15 === ((+1).(*3)) 15 === (+1)((*3) 15) === (+1)((15*3)) === (+1)(45) === (45+1) === 46.
06:33:31 <Axman6> anyone know what the mac equiv to mod-shift-return is on OS X?
06:34:12 <leoncamel> lilachaze: thanks for your explanation. any formal definition about the evaluation rules ?
06:35:12 <BeelsebobWork> anyone know where I can aquire a copy of Field Trip from?
06:37:10 <EvilTerran> leoncamel, that's not the exact evaluation order, i don't think, that's just applying various equational reasoning rules
06:37:24 <EvilTerran> leoncamel, but, yes, function application groups left-to-right
06:37:29 <EvilTerran> a b c = (a b) c
06:38:05 <EvilTerran> the evaluation rules are basically "left-to-right, outside-to-inside"
06:39:12 <Gilly> byorgey: is your multiset partition code available in a plain .hs format somewhere?
06:39:29 <leoncamel> EvilTerran: but is there any rules or manual about the details ? you know , something like infix, priority ,etc.. where can I read the rules ?
06:40:14 <EvilTerran> for instance, snd (undefined, sum) [1,2,3] = (snd (undefined,sum)) [1..3] = ((\(_,x) -> x) (undefined,sum)) [1,2,3] = sum [1..3] = ...
06:40:34 <EvilTerran> leoncamel, you can find the fixity of any operator in ghci with :i
06:41:15 <EvilTerran> if it doesn't say, it'll be the default
06:41:55 <EvilTerran> which is infixl 9
06:42:11 <EvilTerran> http://haskell.org/onlinereport/decls.html#fixity
06:42:11 <lambdabot> Title: The Haskell 98 Report: Declarations
06:42:36 <Botje> eval: snd (undefined, sum) [1..3]
06:42:40 <Botje> uhh
06:42:43 <Botje> > snd (undefined, sum) [1..3]
06:42:45 <lambdabot>  6
06:42:48 <Botje> O_O
06:42:56 <Botje> i was really expecting that to throw a syntax error :[
06:42:56 <Deewiant> laziness at work
06:42:58 <leoncamel> EvilTerran: yes. I notice that there is some priority definition in :info.
06:43:07 <EvilTerran> Botje, why? the 1..3?
06:43:40 <Botje> err
06:43:44 <Botje> make that a type error, then
06:43:46 <leoncamel> EvilTerran: aha. thanks, that's quite usefully. that is exactly what I want ..
06:43:54 <EvilTerran> :)
06:44:10 <EvilTerran> Botje, why?
06:44:42 <Botje> thinking of an example
06:44:46 <Gilly> byorgey: nvm - that article .lhs suffices and i found it :) (excellent stuff, btw. i did something similar (though only counting the number of multipartitions) using the same idea of viewing them as vectors, but your code is neat and now i'd need to enumerate :)
06:44:55 <Botje> > snd snd (1,(1,2))
06:44:56 <lambdabot>  Couldn't match expected type `(a, b)'
06:45:02 <Botje> like that
06:45:04 <Botje> but i see now :)
06:45:11 <mauke> > (snd . snd) (1,(1,2))
06:45:13 <lambdabot>  2
06:45:18 <vixey> cdr
06:45:22 <mauke> > snd . (1,(1,2))
06:45:24 <lambdabot>  (1,2)
06:45:33 <ToRA> has hackage gone down?
06:45:45 <EvilTerran> ToRA, see the /topic
06:46:12 <ToRA> ah
06:46:14 <ToRA> ta
06:46:15 <mauke> > snd (1,(1,2))
06:46:16 <lambdabot>  (1,2)
06:46:22 <mauke> therefore (.) == id
06:46:26 <mm_freak_work> would it be corrent to optimize 'fix id' to 'id'?
06:46:35 <mauke> mm_freak_work: no
06:46:41 <Deewiant> ?ty fix id
06:46:42 <lambdabot> forall a. a
06:46:45 <Deewiant> ?ty id
06:46:47 <lambdabot> forall a. a -> a
06:46:50 <Deewiant> hence, no.
06:47:07 <vixey> :t fix (id :: (a -> a) -> a -> a)
06:47:09 <lambdabot> forall a. a -> a
06:47:12 <vixey> :t id
06:47:14 <lambdabot> forall a. a -> a
06:47:28 <mauke> fix id is âŠ¥
06:47:28 <Deewiant> shh ;-)
06:48:03 <Deewiant> but yeah, in general optimizing a non-terminating program to a (possibly) terminating one isn't allowed
06:48:31 <EvilTerran> it's a refinement!
06:48:43 <Deewiant> sure, but not an optimization :-)
06:48:49 <mauke> optimize infinite loops into nethack
06:49:06 <dmwit> mm_freak_work: id is one fix-point of id, but it is not the least fix-point.
06:49:20 <EvilTerran> unsafePerformIO nethack :P
06:49:43 <dmwit> (Indeed, any value at all is a fix-point of id, so choosing "id" as the representative doesn't really have a lot going for it.)
06:58:19 <mm_freak_work> would 'fix id' be the same as 'id' at infinite time?
06:58:51 <mauke> look at the definition of fix
06:58:58 <mauke> @src fix
06:58:58 <lambdabot> fix f = let x = f x in x
06:59:36 <leoncamel> what is the difference between ":m +Data.List" from ":m Data.List" ?
07:00:49 <dmwit> + adds it to the list of modules, the other replaces the list of modules.
07:03:55 <EvilTerran> mm_freak_work, at infinite time, fix id could be anything
07:04:12 <smg> hello.
07:05:17 <EvilTerran> mm_freak_work, except it can't really, 'cos fix finds the _least_defined_ fixed point
07:06:13 <mm_freak_work> EvilTerran: 'fix id' is the identity of the identity of the identity of â€¦
07:06:23 <mm_freak_work> but honestly, i don't know what a fixed point is
07:06:44 <dmwit> Solve for x in f(x) = x.
07:06:49 <dmwit> That's a fix-point.
07:07:36 <mm_freak_work> and what is "least" in this sense?
07:07:45 <dmwit> There's a paper on it.
07:07:55 <dmwit> But the short story is that "undefined" is less than everything else.
07:07:56 <quicksilver> "least" as in "least defined"
07:08:04 <quicksilver> as in "most like _|_"
07:08:16 <mm_freak_work> couldn't find anything on haskell.org, where do i find it?
07:09:07 <mm_freak_work> hmm
07:09:14 <quicksilver> it appears to be covered in http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
07:09:20 <mm_freak_work> "most defined" would be a value?
07:09:22 <quicksilver> I'm not sure if that's a good exposition because I haven't read it.
07:09:55 <quicksilver> _|_ is less defined that (_|_,_|_) which is less defined that (1,_|_) which is less defined that (1,2)
07:10:01 <quicksilver> s/that/than/g;
07:11:00 <idnar> what about (_|_,2) ?
07:11:19 <dmwit> 1 = 2 for defined-ness, probably
07:11:43 <dmwit> or, at the very least, 1 /< 2
07:13:01 <quicksilver> idnar: definedness is a partial order
07:13:16 <quicksilver> idnar: (1,_|_) and (_|_,2) are incomparable
07:13:20 <idnar> quicksilver: ok
07:13:26 <quicksilver> other than that they fit into the chain in the same place
07:13:29 <quicksilver> they're "siblings"
07:15:08 <tromp> so are []:undefined and undefined:[]
07:15:27 <tromp> but you do length on the latter
07:18:26 <quicksilver> tromp: what's your point?
07:19:12 <osfameron> that the latter is more defined than the former?
07:19:42 <quicksilver> tehre is no contradiction with length(A) being _|_ and length(B) being 1
07:19:48 <quicksilver> if they're incomparable.
07:19:58 <quicksilver> it would be a contradiction if B was less defined that A, sure
07:20:07 <quicksilver> since haskell functions are all supposed to be continuous
07:21:14 <tromp> no point:-)
07:21:17 <quicksilver> ok :)
07:21:31 <quicksilver> a function , given a more defined input, must return a more defined output
07:21:38 <quicksilver> (take more to mean "equally or more")
07:21:45 <quicksilver> the converse does not hold though.
07:22:36 <tromp> yes, functions are monotone with respect to definedness
07:23:01 <idnar> []:undefined is a type error, no?
07:23:07 <quicksilver> nope
07:23:10 <tromp> it's type [[a]]
07:23:14 <idnar> oh duh
07:23:15 <quicksilver> it's a list of lists
07:23:20 <quicksilver> :t []:undefined
07:23:21 <idnar> ok, so they have different types
07:23:22 <lambdabot> forall a. [[a]]
07:23:24 <quicksilver> yes
07:23:34 <quicksilver> so tehcnically there shouldn't be comparable anyway
07:23:38 <mauke> > head ([] : undefined)
07:23:39 <lambdabot>  []
07:23:46 <quicksilver> they have a common type though
07:23:57 <quicksilver> the last one could be instantiated to [[a]] if you chose
07:24:11 <quicksilver> so it's not unreasonable to compare them, I was wrong
07:24:26 <tromp> :t ([]:undefined)==(undefined:[])
07:24:27 <Saizan_> but, is the definedness order defined for any two values that aren't bottoms?
07:24:27 <lambdabot> Bool
07:24:40 <quicksilver> Saizan_: no it's a partial order
07:24:54 <quicksilver> Saizan_: ehm, sorry, what did you mean?
07:25:08 <quicksilver> in a typed setting, definedness is only interesting within one type
07:25:26 <quicksilver> asking whether (1,_|_) is more defined that Left _|_ is just not a very interesting question.
07:25:37 <quicksilver> certainly you could answer it by saying "they are incomparable"
07:25:48 <quicksilver> you can always join together partial orders like that :)
07:25:56 <Saizan_> i'm asking if values are only comparable with bottom
07:26:10 <quicksilver> no, e.g. (1,_|_) is comparable to (1,2)
07:26:14 <quicksilver> (being strictly less defined, in fact)
07:26:52 <Saizan_> yeah, i realized that when asking :)
07:29:57 <Saizan_> but ():_|_ and _|_:[] aren't, but if you consider functions parametric on the element type you could expect a more defined output for the latter
07:30:13 <Saizan_> (modulo seq)
07:33:21 <quicksilver> Saizan_: yes if you choose to build polymorphism into your definedness net, which seems fairly natural
07:33:36 <quicksilver> Saizan_: then _|_ having totaly polymorphic type 'a' joins all the strands together
07:33:57 <quicksilver> Saizan_: whilst _|_:[] is in an [a] strand and ():_|_ in a [()] strand
07:34:01 <quicksilver> and there are inter-relations.
07:34:15 <quicksilver> however in my experience this stuff is *used* on well-typed terms.
07:34:21 <quicksilver> and well-typed terms don't have such ambiguitys.
07:37:17 <Saizan_> my point was more that indutively i'd expect _|_:[] to be more defined, and that's only because i was considering functions that are parametric on a
07:37:29 <Saizan_> "intuitively"
07:42:31 <notsmack> so what's up with hackage?
07:43:16 <quicksilver> machine is moving
07:47:08 <marcot> Hackage seems to be down.
07:47:19 <Deewiant> 2008-06-27 17:43:16 ( quicksilver) machine is moving
07:47:47 <dolio> Hey, hackage doesn't seem to be working.
07:47:52 <Deewiant> 2008-06-27 17:43:16 ( quicksilver) machine is moving
07:47:54 <dolio> :)
07:48:00 <marcot> hehehe
07:48:40 <gwern> dolio: didn't you read dons's email?
07:48:49 * gwern pities da fool who doesn't read announcements
07:49:17 <dolio> No, I didn't. But I read the stuff 4 and 0 minutes before what I typed. :)
07:49:34 <int-e> http://www.haskell.org/pipermail/libraries/2008-June/010025.html ... hmm, libraries, not haskell-cafe.
07:49:34 <lambdabot> Title: Hackage and darcs.haskell.org downtime
07:50:17 <marcot> Is anyone here going to DebConf?
07:54:31 * gwern ain't
08:03:46 <hpaste>  ellisk pasted ""rigid type variable" error in GHC, help?" at http://hpaste.org/8581
08:05:15 <dolio> (Chromosome c) => [c] -> p means that it can turn a list of any type of Chromosome into a population of type p.
08:06:12 <gwern> I am curious. suppose I have a list of stuff (with repetitions), and I want to turn it into a list of stuff, but sorted (and then uniq'd) by popularity
08:06:19 <gwern> there must be some built in function for this
08:06:25 <gwern> any ideas what?
08:06:54 <dolio> People have proposed nubSorted before.
08:07:05 <dolio> But it's not in the libraries to my knowledge.
08:07:15 <EvilTerran> can't you just sort then group?
08:07:31 <mm_freak_work> quicksilver: it's very useful so far, but i'm not through it completely yet
08:07:32 <gwern> EvilTerran: I'm not sure. what is a group?
08:07:38 <EvilTerran> ?src group
08:07:38 <lambdabot> group = groupBy (==)
08:07:51 <EvilTerran> > group . sort $ "abcracadabra"
08:07:52 <lambdabot>  ["aaaaa","bb","cc","d","rr"]
08:08:00 <EvilTerran> O(n.log n)
08:08:06 <mm_freak_work> quicksilver: explains 'definedness' very well and understandable as a partial order relation
08:08:07 <mrd> map head . sortBy (comparing `on` length) . group . sort
08:08:24 <quicksilver> mm_freak_work: good :)
08:08:28 <mrd> > map head . sortBy (comparing `on` length) . group . sort $ [1,1,1,2,2,3]
08:08:29 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> a
08:08:29 <lambdabot>     Probabl...
08:08:31 <mrd> blargh
08:08:33 <EvilTerran> shouldn't that be (comparing length) or (compare `on` length)?
08:08:39 <mrd> > map head . sortBy (compare `on` length) . group . sort $ [1,1,1,2,2,3]
08:08:40 <lambdabot>  [3,2,1]
08:08:43 <mrd> aha
08:08:55 <Deewiant> and if you want one that doesn't require Ord:
08:09:09 <gwern> mrd: I think that's opposite of what I need :)
08:09:11 <Deewiant> \rel xs -> map (\a -> filter (rel a) xs) (nubBy rel xs)
08:09:12 <dolio> Yeah, comparing length or compare `on` length.
08:09:19 <mrd> > map head . sortBy (flip compare `on` length) . group . sort $ [1,1,1,2,2,3]
08:09:20 <Deewiant> which can probably be optimized.
08:09:20 <lambdabot>  [1,2,3]
08:09:23 <quicksilver> > map (head &&& length) . group . sort $ "abcracadabra"
08:09:24 <lambdabot>  [('a',5),('b',2),('c',2),('d',1),('r',2)]
08:09:37 <EvilTerran> @@ (@type comparing); @type (compare `on`)
08:09:40 <lambdabot>  forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering; forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
08:09:41 <quicksilver> > sortBy (comparing snd) . map (head &&& length) . group . sort $ "abcracadabra"
08:09:42 <lambdabot>  [('d',1),('b',2),('c',2),('r',2),('a',5)]
08:10:03 <gwern> well, I have a practice of replacing nub by calls to Set for efficiency reasons when I don't need my uniq to be stable, but otherwise I think one of those would work
08:10:14 <dolio> Is ellisk here?
08:13:11 <mm_freak_work> > foldl (\x y -> y : reverse x) [] "abcde"
08:13:12 <lambdabot>  "ecabd"
08:13:23 <mm_freak_work> > foldr (\x y -> x : reverse y) [] "abcde"
08:13:24 <lambdabot>  "acedb"
08:14:04 <quicksilver> gwern: I have a practice of only worrying about efficiency in code where efficiency matters :)
08:14:15 <quicksilver> gwern: but otherwise I agree entirely with your comment.
08:17:13 <hpaste>  dolio annotated ""rigid type variable" error in GHC, help?" with "the answer" at http://hpaste.org/8581#a1
08:18:27 <BMeph> gwern: why not toAscList . fromList? ;)
08:23:18 <hpaste>  zeno__ pasted "updateListMulti" at http://hpaste.org/8582
08:23:26 <zeno__> is there a better way to do that?
08:24:59 <dolio> Does that work? It looks like you throw away x too fast.
08:25:30 <gwern> zeno__: offhand, maybe a guarded function for updateHelper would look cleaner?
08:25:31 <dolio> Other than that, it's all right.
08:26:06 <zeno__> dolio: ah ok, thanks :) no more efficient way though?
08:26:47 <dolio> I don't think so. That's one pass.
08:28:30 <dolio> Oh, also, if someone passes something like [(1,'a'),(1,'b'),(2,'c')] you're in trouble if you don't handle that.
08:29:01 <jeffersonheard> Anyone know what "checking for path to top of build tree... pwd: timer_create: Invalid argument"  would mean in the context of a dead GHC ./configure?
08:29:20 <jeffersonheard> that's the error the GHC build is dying with
08:29:21 <zeno__> dolio: yeah thanks for the heads up :)
08:29:24 <zeno__> @hoogle comparing
08:29:25 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:29:39 <Zao> Isn't that the ghci bold problem or something?
08:30:49 <Saul_> Does anyone know how to express datatypes like Either in an sql database?
08:31:06 <Zao> jeffersonheard: I'd search the ghc bug DB, but hackage is moving.
08:31:21 <jeffersonheard> I noticed.  I started with that this morning, but it's unreachable
08:31:40 <ziman> jeffersonheard, that's a common problem of all ghc-compiled programs; they don't work on systems without (or with weird) timer_create
08:31:45 <ziman> asa far as i know/googled
08:32:09 <Zao> ttp://www.mail-archive.com/cvs-ghc@haskell.org/msg08243.html
08:32:14 <ziman> using timer_create can be turned off but first you need to recompile ghc to produce such programs
08:32:36 <jeffersonheard> Well, my problem is compiling GHC itself, but thanks
08:32:53 <ziman> yes, i've run into the same problem ;)
08:32:59 <ziman> an i don
08:33:00 <Zao> Since that patch was applied in april, shouldn't it be in 6.8.3?
08:33:22 <jeffersonheard> I'd think so, but I downloaded 683 yesterday
08:33:26 <ziman> and i don't know how to solve it except for recompiling ghc on a different machine and copying it over there
08:33:45 <dons> http://talkingcode.co.uk/2008/06/27/getting-started-with-haskell-still/ nice
08:33:45 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:33:46 <lambdabot> Title: Getting started with Haskell&#8230; still : : talkingCode, http://tinyurl.com/5v9wc3
08:35:14 <jeffersonheard> alright...  what an odd problem.
08:35:29 <ziman> a kind of bootstrapping problem :)
08:36:02 <Apocalisp> whence if' ?
08:36:27 <jeffersonheard> yeah.  All our intel/amd supercomputers use a RHEL based distro called rox cluster, and the problem is universal on these
08:36:57 <Apocalisp> ?pl \x y -> if x == "" then x else y
08:36:57 <lambdabot> if' =<< ([] ==)
08:37:08 <Apocalisp> ^^ where's this from?
08:37:22 <kpreid> Apocalisp: it's only in pl's database
08:37:27 <kpreid> if' a b c = if a then b else c
08:37:57 <Apocalisp> oh, I thought it was part of some library full of clever things like that
08:38:01 <kpreid> sadly, no
08:38:10 <kpreid> @hoogle if'
08:38:11 <lambdabot> No matches found
08:38:54 <Saul_> Does anyone know how to express datatypes like Either in an sql database?
08:39:14 <kpreid> two extra tables...
08:39:39 <kpreid> (actually, I don't really know)
08:40:31 <dolio> (Bool,a,b)?
08:41:16 <jeffersonheard> I would use a bool column followed by two columns, one of type a and one of type b
08:41:35 <Saul_> ok
08:41:45 <Saul_> I want a and b to be tables though
08:42:32 <geezusfreeek> umm, you mean keys referring to rows in two different tables?
08:42:39 <Saul_> actually I have a sum type with some choices empty, others referring to tables and yet others to column data
08:43:28 <hpaste>  Saul_ pasted "Hoe to SQL-lize this?" at http://hpaste.org/8583
08:43:40 <Saul_> I want to store this
08:44:18 <hpaste>  Saul_ annotated "Hoe to SQL-lize this?" with "With..." at http://hpaste.org/8583#a1
08:44:43 <quicksilver> Saul_: I'm not aware of an elegant solution
08:45:10 <quicksilver> something with an explicit tag
08:45:13 <geezusfreeek> if you know any C you can extend PostgreSQL with custom types
08:45:14 <quicksilver> and a variable foreign key
08:45:23 <quicksilver> (which might link to one of two other tables)
08:45:47 <Saul_> my current solution is a blob :P
08:46:58 <dolio> You need a database that stores dependent tuples.
08:47:13 <Saul_> geezusfreeek: I do know some C, but I don't have access to postgres for this
08:47:19 <dolio> Then it's Sigma (b:Bool) (if b then A else B)
08:47:59 <geezusfreeek> a dependently typed relational database? has something like that been done before?
08:48:19 <dolio> Can't say I know of one, but I haven't looked.
08:49:01 <geezusfreeek> no obvious results on first page of google search
08:49:26 <quicksilver> if you google for 'sql inheritance problem' and suchlike things
08:49:35 <quicksilver> you'll uncover some discussion / solutions in particular cases.
08:49:48 <jeffersonheard> Another quick question: is withCStringLen supposed to return a null terminated string with associated length, or is that unspecified?
08:49:50 <quicksilver> inheritane may not seem like the right word here
08:50:06 <quicksilver> but that's the word that springs to OO-minded people to describe the problem
08:50:06 <geezusfreeek> yeah this is a common problem in ORM
08:50:23 <quicksilver> OO langauges use inheritance instead of sum types.
08:50:29 <quicksilver> (abuse)
08:51:18 <Saul_> I've been thinking about making a database engine myself that just works with Haskell well
08:51:21 <quicksilver> jeffersonheard: I believe not.
08:51:31 <quicksilver> jeffersonheard: I believe you use withCString if you want null termination.
08:51:33 <Saul_> But I doubt I'm smart enough to solve it
08:52:01 <quicksilver> CStringLen : A string with explicit length information in bytes instead of a terminating NUL
08:52:13 <jeffersonheard> Thanks
08:52:20 <geezusfreeek> i believe MACID was designed for that, right?
08:52:27 <Saul_> The most elegant way to do it is to just have data that "appears" to be in memory, and then uses lazy evaluation to query as necessery
08:52:29 <quicksilver> geezusfreeek: in a sense.
08:52:37 <quicksilver> geezusfreeek: that gives you ACID, but it doesn't give you relations.
08:52:48 <quicksilver> Saul_: nitpick : that's not lazy evaluation, that's lazy IO.
08:52:55 <geezusfreeek> right, i was responding to "I've been thinking about making a database engine myself that just works with Haskell well"
08:53:05 <quicksilver> geezusfreeek: agreed. it answers that well.
08:53:12 <quicksilver> some people think the "relational" part actually has value, though
08:53:17 <quicksilver> and don't want to throw it away.
08:53:30 <geezusfreeek> relational is nice for many domains, just not all
08:53:35 <quicksilver> especially in terms of expressing queries which present alternate views on the data
08:53:46 <quicksilver> whereas the happs approach ties you to one view of the data
08:53:53 <quicksilver> I have not made up my own mind on these arguments
08:53:59 <quicksilver> I think both sides have some convincing points.
08:54:18 <dcoutts_> quicksilver: how does it tie you to one view of data?
08:54:24 <geezusfreeek> i thought i had, especially in this whole relational vs. semi-structured debate, but my mind is wavering
08:54:27 <quicksilver> there is the slight point that happs *actually* provides ACID, where as SQL databases merely claim they do.
08:54:33 <dcoutts_> doesn't it let you use whatever haskell data structure you like?
08:54:42 <quicksilver> dcoutts_: yes. YOu pick a structure and you use it.
08:54:54 <quicksilver> dcoutts_: any such structure is optimised for some calculations and suboptimal for others
08:54:58 <dcoutts_> and so if you pick a relation data structure then...
08:55:01 <quicksilver> as programmers we solve such problems every day
08:55:01 <geezusfreeek> well, we both know that SQL is not truly relational
08:55:03 <quicksilver> it's not a biggy.
08:55:20 <quicksilver> but the relational ethos is "find a neutral representation which makes all kinds of queries easy"
08:55:31 <quicksilver> and then "have a query engine which can compute arbitrary queries relatively efficiently"
08:55:46 <quicksilver> dcoutts_: only if you feel like embedding a query optimiser in your haskell project.
08:55:54 <quicksilver> dcoutts_: which is a fun idea, indeed :)
08:56:07 <quicksilver> but using a conventional relational DB lets you use someone else's query optimiser.
08:56:19 <dcoutts_> quicksilver: happs has an Ix set which gives you user-defined indexes on whichever columns you like
08:56:31 <quicksilver> geezusfreeek: true indeed but that's not the point I was making personally.
08:56:52 <quicksilver> geezusfreeek: I was making a point about extant SQL implementations not being serialised
08:56:58 <geezusfreeek> you and i are nitpicking different things i think ;)
08:57:03 <quicksilver> geezusfreeek: whereas MACID really is, I believe.
08:57:10 <quicksilver> dcoutts_: which is a step in teh right direction.
08:57:14 <dcoutts_> quicksilver: true, if you've got a very wide range of complex queries (esp if they're not known before hand) then it makes sense
08:57:17 <quicksilver> dcoutts_: but some way short of a full query optimiser.
08:57:35 <quicksilver> of course there is a huge domain in which you don't need the query optimiser
08:57:40 <quicksilver> and that approach works.
08:57:52 <quicksilver> my day job happens to involve relatively large SQL relations and complex reporting queries.
08:57:55 <quicksilver> ;)
08:58:26 <osfameron> mmm, I like SQL/reporting
08:58:26 <geezusfreeek> i've been pondering a lot lately about RESTful architectures, and the relational model doesn't seem to fit that at all
08:58:35 <gwern> 'But, being a bunch of software developers means we are continuously craving something different, like switching to Haskell and using Ruby on Rails. Joking aside (and nobody panic)...'
08:59:11 <geezusfreeek> s/at all/most of the time/
08:59:41 <dolio> Ruby on Rails is old hat now.
08:59:44 <quicksilver> dcoutts_: the other advantages are a central solution to the backup problem
08:59:53 <quicksilver> dcoutts_: and related deployment/admin considerations.
09:00:12 <dcoutts_> quicksilver: doesn't using a external db make deployment harder?
09:01:42 <quicksilver> dcoutts_: well in a sense yes.
09:01:53 <quicksilver> dcoutts_: but equally it's a solved problem and you can reuse the solution.
09:02:12 <quicksilver> dcoutts_: particular if your company already has an "X" SQL server and deployment/backup procedures in place.
09:02:35 <zeno__> > groupBy (\a b -> (fst a) == (fst b)) [(4,"ggg"),(3,"baa"),(4,"asf")]--how come this isnt grouping?
09:02:36 <lambdabot>  [[(4,"ggg")],[(3,"baa")],[(4,"asf")]]
09:02:53 <quicksilver> zeno__: they're not adjacent
09:02:55 <mauke> it is
09:02:59 <quicksilver> zeno__: you have to sort first if you want that
09:02:59 <EvilTerran> zeno__, group only groups adjacent things
09:03:07 <quicksilver> @stereo
09:03:08 <lambdabot> Unknown command, try @list
09:03:10 <zeno__> thanks all
09:03:18 <EvilTerran> > groupBy ((==) `on` fst) . sort $ [(4,"ggg"),(3,"baa"),(4,"asf")]
09:03:19 <lambdabot>  [[(3,"baa")],[(4,"asf"),(4,"ggg")]]
09:06:16 <Zao> You could always nubBy, couldn't you?
09:09:07 <EvilTerran> you wouldn't keep any pairs that got grouped that way, though
09:20:08 <Apocalisp> ?hoogle [[a]] -> (a,a)
09:20:08 <lambdabot> No matches, try a more general search
09:21:11 <EvilTerran> Apocalisp, what behaviour did you want? a function of that type will always be partial
09:21:45 <Apocalisp> EvilTerran: Yes, I know
09:21:49 <Apocalisp> just wondering
09:22:18 <Apocalisp> ?hoogle [[a]] -> [(a,a)]
09:22:18 <lambdabot> No matches, try a more general search
09:22:29 <Apocalisp> that's more like what I want
09:22:39 <Apocalisp> ?type map zip
09:22:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => f [a] -> f ([b] -> [(a, b)])
09:22:47 <Deewiant> ?ty Prelude.map zip
09:22:48 <lambdabot> forall a b. [[a]] -> [[b] -> [(a, b)]]
09:23:36 <EvilTerran> ?type map.zip
09:23:38 <lambdabot> forall (f :: * -> *) a b. (Functor f) => [a] -> f [b] -> f [(a, b)]
09:23:55 <Deewiant> ?ty uncurry zip . splitAt 5
09:23:56 <lambdabot> forall a. [a] -> [(a, a)]
09:30:00 <zeno__> @hoogle `on`
09:30:00 <lambdabot> Hoogle Error: Parse Error: Unexpected character '`on`'
09:31:01 <gwern> @hoogle on
09:31:01 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:31:01 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
09:31:01 <lambdabot> Data.Function :: module
09:31:13 <gwern> can't use infix syntax, hoogle doesn't parse things like that
09:31:25 <gwern> it's a name, or a signature
09:52:38 <chylli> there is #ifdef in haskell program. where can I find the introduction ?
09:52:48 <Taggnostr> I need some help: I want to write a program that generates some random numbers and check how many of them have the number '3' as a digit
09:52:58 <pgavin> chylli: you have to use -cpp
09:53:19 <pgavin> chylli: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor
09:53:22 <lambdabot> Title: 5.10. Options related to a particular phase, http://tinyurl.com/smq5n
09:53:31 <chylli> pgavin: thanks
09:53:54 <Taggnostr> how can I do that?
09:55:02 <quicksilver> Taggnostr: which part?
09:55:09 <quicksilver> do you know how to generate random numbers?
09:55:13 <Taggnostr> nope
09:55:17 <quicksilver> do you know how to check if they have the number '3' as a digit?
09:55:18 <pgavin> http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#t%3ARandomGen
09:55:19 <lambdabot> http://tinyurl.com/3yau3k
09:55:24 <quicksilver> do you know how to count how many do?
09:55:44 <Taggnostr> I guess that I have to convert them in string
09:55:52 <quicksilver> yup.
09:56:04 <quicksilver> solve the problem in parts, one part at a time.
09:56:19 <quicksilver> I'd say the first problem to sove is checking if a number contains the digit 3
09:56:49 <Taggnostr> yes
10:11:08 <marcot> I think I'll rewrite zenity in haskell...
10:13:02 <dmead> whats zenity?
10:14:13 <marcot> http://freshmeat.net/projects/zenity
10:14:13 <lambdabot> Title: freshmeat.net: Project details for Zenity
10:20:43 <ertai> the extra-lib-dirs option of cabal-install seems to not be took in account for linking dist/setup/setup?
10:41:25 <hcube> hi, is here a haskell opengl guru ?  i'd like to get a matrix from c function (via Ptr CFloat) but i dot know how to alloc a matrix temporaly and how to pass it to a funtion what accepts Ptr CFloat. i need this for my bullet physics engine wrapper example :p
10:42:15 <dcoutts_> ertai: right, we expect that to "Just Work"tm. If not then your ghc is messed up.
10:42:48 <dcoutts_> ertai: do you normally need extra options when you compile Setup.hs ?
10:42:49 <ertai> dcoutts_: it's missing -L/opt/local/lib to find libgmp
10:43:09 <dcoutts_> ertai: then add that into the registration of the base package
10:43:16 <ertai> dcoutts_: not just, since 6.8.3
10:43:17 <dcoutts_> since every single ghc link will need it
10:43:35 <ertai> dcoutts_: where is that file ?
10:44:08 <ertai> dcoutts_: package.conf ?
10:44:09 <dcoutts_> ertai: you'd have to use ghc-pkg describe base > base.pkg, edit base.pkg and then ghc-pkg update base.pkg
10:44:19 <dcoutts_> ertai: don't edit package.conf directly
10:44:27 <ertai> dcoutts_: thanks
10:45:07 <dcoutts_> ertai: and perhaps you can file a ghc feature request to allow you to configure ghc in such a way that those extra paths are baked in
10:46:29 <ertai> dcoutts_: It was a binary package and I think that the path should be hardcoded since the dep is hardcoded in the doc
10:47:14 <dcoutts_> ertai: you mean a generic binary package from haskell.org/ghc or a distro package?
10:48:27 <ertai> dcoutts_: great I worked (not my extra-lib-dirs, but library-dirs), thanks !
10:48:42 <ertai> dcoutts_: from haskell.org/ghc
10:49:17 <rwbarton> hcube: You probably want mallocArray and peekArray, from Foreign.Marshal.Array
10:53:49 <quicksilver> hcube: I thought I talked you through that the other day..
10:53:58 <quicksilver> hcube: peekArray, fromIntegral
10:54:00 <marcot> dcoutts_: have you seen my mail about something like zenity as a Haskell library?
10:54:26 <dcoutts_> marcot: I've not checked my mail this afternoon
10:54:52 <marcot> dcoutts_: ok. =)
10:55:41 <dcoutts_> marcot: wouldn't it just be a simple wrapper module for gtk2hs ?
10:55:54 <dcoutts_> marcot: zenity just makes simple message boxes right?
10:58:22 <hpaste>  tobias_tud pasted "GHC and Foreign Call" at http://hpaste.org/8584
10:58:25 <ertai> Is there something more precise than __GLASGOW_HASKELL__
10:58:30 <marcot> dcoutts_: Yes, I don't think it's just a wrapper, but it'll be done with gtk2hs.
10:58:59 <tobias_tud> can anyone help me? i try to interface a library with my haskell program and i didn't find out, what is wrong at his point
10:59:09 <dcoutts_> ertai: __GLASGOW_HASKELL__ gives the major version number. Do you want somethine more precise than that?
10:59:34 <marcot> dcoutts_: some things like fileSelection :: IO FilePath sounds very usefull for me.
10:59:45 <ertai> dcoutts_: right, I have to #ifdef a diff from 6.8.2 to 6.8.3
10:59:57 <dcoutts_> tobias_tud: linking with a C++ program?
11:00:15 <dcoutts_> ertai: 'k, that info is not available directly via CPP
11:00:28 <tobias_tud> yes, it's a c++ program, but i made a c-interface. but i dont know, if it's correct
11:00:40 <dcoutts_> ertai: on the theory that people should not need to distinguish minor versions :-)
11:01:03 <ertai> dcoutts_: arg, HsModule arity has changed and their is no field selectors... :(
11:01:15 <hpaste>  tobias_tud pasted "C-Interface" at http://hpaste.org/8585
11:01:17 <dcoutts_> tobias_tud: I think you need to link with some C++ standard library. g++ does that automatically but ghc calls gcc not g++
11:01:22 <tobias_tud> that's it, not much
11:01:41 <dcoutts_> tobias_tud: or you can tell ghc to use g++ as gcc for linking purposes
11:02:03 <dcoutts_> ertai: oh TemplateHaskell library?
11:02:11 <marcot> dcoutts_: don't you think it's usefull?
11:02:12 <tobias_tud> ah, okay. do you know how i can tell ghc to use g++?
11:02:25 <ertai> dcoutts_: no in Yi (more precisely in Shim).
11:02:45 <dcoutts_> ertai: so that's the ghc api then is it?
11:02:55 <ertai> dcoutts_: right
11:02:58 <tobias_tud> ah, i have it. thanks, dcoutts_
11:03:41 <dcoutts_> ertai: hmm. Well if you can't make it compatible with both then you can use Cabal to pass different CPP flags depending on the version of a library.
11:03:58 <ertai> dcoutts_: good idea
11:05:20 <tusho> @src ap
11:05:20 <lambdabot> ap = liftM2 id
11:05:29 <ertai> dcoutts_: how do you test a version library in the cabal, a new flag is needed?
11:05:39 <dcoutts_> ertai: right
11:05:42 <tusho> > ap (++) show "ap (++) show "
11:05:53 <lambdabot>  "ap (++) show \"ap (++) show \""
11:06:03 <tusho> @src liftM2
11:06:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:06:27 <dcoutts_> ertai: we're going to add a new syntax for this use case, but it's not done yet.
11:06:40 <tusho> @src (->) return
11:06:40 <lambdabot> return = const
11:06:42 <tusho> @src (->) (>>=)
11:06:42 <lambdabot> f >>= k = \ r -> k (f r) r
11:07:40 <ertai> dcoutts_: "the configuration language evolution problem"...
11:08:07 <tusho> dcoutts: YAML!
11:08:28 <dcoutts_> ertai: actually it's not an extension, it's just syntactic sugar
11:08:46 <tobias_tud> i try to compile my program with: ghc  -lminisat -pgml g++  -L./ -o MyBridge --make -auto-all Bridge.hs         and it doesn't works
11:08:52 <dcoutts_> tusho: actually I looked at it, but it's both not nice for what we want and it's also too general
11:08:58 <ertai> dcoutts_: why not plain haskell ?
11:09:21 <dcoutts_> ertai: because it's turing complete. That's no good for a configuration language.
11:09:57 <ertai> dcoutts_: a matter of point of view
11:10:08 <RayNbow> > [init,tail] `ap` [[1..9],[2..9]]
11:10:09 <lambdabot>  [[1,2,3,4,5,6,7,8],[2,3,4,5,6,7,8],[2,3,4,5,6,7,8,9],[3,4,5,6,7,8,9]]
11:10:47 <dcoutts_> ertai: yes, exactly. From the package authors pov they want most power. From the distributor /package manger / users pov they want to be able to interrogate and manipulate the package.
11:11:06 <dcoutts_> ertai: so the power of the language is a trade off between the different needs.
11:11:30 <ertai> dcoutts_: right, however in some sense the power is already too high
11:12:03 <ziman> > [(+1), (*2)] `ap` [3, 17]
11:12:04 <lambdabot>  [4,18,6,34]
11:12:13 <dcoutts_> ertai: it's currently a relational/logic language. It's specifically designed to be solvable.
11:13:12 <ertai> dcoutts_: having boolean expressions of comparisons of packages, leads to hard cases for "installability checking"
11:13:27 <dcoutts_> ertai: hmm?
11:14:47 <dcoutts_> ertai: you mean trying to plan an installation for a set of dependencies?
11:14:52 * ertai is trying to find out a paper about that...
11:15:06 <dcoutts_> ertai: technically it makes it no harder, since it was already an NP-complete problem.
11:15:14 <ertai> dcoutts_: no telling if a package is br0ken in a given distribution
11:15:48 <dcoutts_> ertai: presumably checking if it's broken means checking if it's possible to install it right?
11:15:49 <ertai> dcoutts_: it depends how complex are your dependencies, no?
11:15:55 <ertai> dcoutts_: right
11:16:17 <dcoutts_> ertai: even without the flags feature the package installation planning problem is NP-complete
11:17:11 <dcoutts_> ertai: and adding the flags feature must still be NP (since checking if the solution is valid is only P-time)
11:17:18 <ertai> dcoutts_: you're right it's their "Theorem 1" by the way :)
11:17:37 <dcoutts_> ertai: which paper are you looking at btw?
11:17:40 <ahunter> ertai: link?
11:18:17 <ertai> dcoutts_,ahunter: that's from the EDOS project, but one of the links seems br0ken
11:18:43 <ertai> This one is a only status report http://www.edos-project.org/xwiki/bin/download/Main/Publications/wsl06.pdf
11:18:45 <lambdabot> http://tinyurl.com/58rn4p
11:20:12 <dcoutts_> ertai: oh, I should look into that more. I've wrote a simple constraint solving system for cabal-install to do the install planning.
11:20:41 <ertai> dcoutts_: yes could be usefull, indeed
11:21:17 <ertai> dcoutts_: the guys I now have done most of their work using OCaml, so mostly functional
11:21:49 <dcoutts_> ertai: right. Same here obviously. I should perhaps write a paper about it with the constraint programming people here in my department. :-)
11:23:13 <hcube> sorry for my stupid questions, i have not lot of haskell experience. how can i convert IO CFloat to GLfloat ? i need this during cornvert my Ptr CFloat array to GLmatrix
11:23:41 <hcube> *dont have
11:32:45 <ertai> dcoutts_: can dl the paper but here is the slides http://www.edos-project.org/xwiki/bin/download/Main/Wp2/ase06.talk.pdf
11:32:46 <lambdabot> http://tinyurl.com/5sqg89
11:34:24 <dcoutts_> ertai: so I want to introduce some of these checks to hackage. Though actually requiring the whole archive to be consistent is not realistic sadly. But we can require that it be possible to install each package (just not all of them simultaneously)
11:34:40 <dcoutts_> ertai: and we can make a consistent subset
11:35:21 <ertai> dcoutts_: yeah would be great
11:36:06 <dcoutts_> ertai: currently I can get a consistent subset covering all but about 20 packages on hackage.
11:36:18 <dcoutts_> using my current cabal-install dependency planner
11:45:18 <ertai> dcoutts_: how long it takes to check it ?
11:48:54 <RayNbow> @seen dons
11:48:54 <lambdabot> I saw dons leaving #xmonad, #arch-haskell and #haskell 1h 42m 20s ago, and .
11:49:05 <RayNbow> @seen bos
11:49:05 <lambdabot> I haven't seen bos.
11:58:01 <pgavin> dcoutts_: I uploaded binaries to sf.net, but it looks like the last release had binaries on www.haskell.org also
11:59:09 <pgavin> dcoutts_: do you want to put a copy of them there, or maybe we can put them on code.haskell.org?
12:06:10 <RayNbow> hmm, I didn't know you're allowed to have let definitions within a list comprehension...
12:07:12 <pgavin> RayNbow: lets are allowed anywhere any other expression is allowed
12:07:38 <mauke> pgavin: no
12:07:44 <mauke> you're thinking of 'let .. in'
12:09:11 <RayNbow> > [a | x <- [1..5], let a = x*x]
12:09:12 <lambdabot>  [1,4,9,16,25]
12:10:09 <tromp> > map (join (*)) [1..5]
12:10:11 <lambdabot>  [1,4,9,16,25]
12:10:14 <mauke> > [a | x <- [1..5], a <- [x*x]]
12:10:15 <lambdabot>  [1,4,9,16,25]
12:10:41 <mauke> > [x | x <- [1..5], 9 <- [x*x]]
12:10:42 <lambdabot>  [3]
12:10:45 <rwbarton> > do { x <- [1..5] ; let a = x*x ; return a }
12:10:46 <lambdabot>  Parse error at "}" (column 43)
12:11:07 <tromp> > [1..5] >>= return . join (*)
12:11:08 <lambdabot>  [1,4,9,16,25]
12:11:55 <rwbarton> > do { x <- [1..5] ; let { a = x*x } ; return a }
12:11:56 <lambdabot>  [1,4,9,16,25]
12:12:14 <RayNbow> > [1,4,9,16,25] -- constant folding :p
12:12:16 <lambdabot>  [1,4,9,16,25]
12:13:03 <mjrosenb> RayNbow: huh?
12:13:04 <tromp> > join (zipWith (*)) [1..5]
12:13:05 <lambdabot>  [1,4,9,16,25]
12:14:37 <mehrheit> @src [] join
12:14:37 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:15:16 <mauke> @src join
12:15:17 <lambdabot> join x =  x >>= id
12:17:52 <tromp> :t (*) >>= id
12:17:53 <lambdabot> forall a. (Num a) => a -> a
12:21:03 <tromp> :t (->) (>>=)
12:21:05 <lambdabot> parse error on input `->'
12:21:11 <tromp> @src (->) (>>=)
12:21:11 <lambdabot> f >>= k = \ r -> k (f r) r
12:21:54 <mauke> :t \r -> id ((*) r ) r
12:21:56 <lambdabot> forall a. (Num a) => a -> a
12:22:06 <mauke> @pl \r -> id ((*) r ) r
12:22:06 <lambdabot> join (*)
12:29:58 * mjrosenb grumbles at the monomorphism restriction
12:32:21 <coram> ((*) >>= id) 5
12:32:31 <coram> > ((*) >>= id) 5
12:32:33 <lambdabot>  25
12:32:56 <vixey> join
12:34:32 <Athas> Which operating system/distribution is preferred by most Haskellers?
12:34:44 <cjb> Athas: there's a surprising mix
12:34:56 <cjb> many of the GHC developers use Windows, because they work for Microsoft Research
12:35:06 <cjb> some (like dons) use FreeBSD
12:35:15 <cjb> I think most of the Linux users use Debian or Ubuntu
12:35:18 <dolio> dons runs Arch Linux now.
12:35:23 <cjb> oh, ok
12:35:26 <quicksilver> cjb: I don't think the MSR guys necessarily use windows :)
12:35:40 <quicksilver> cjb: although I'm sure they have to on one machine at least.
12:35:44 <cjb> quicksilver: *someone* had to develop Visual Haskell ;-)
12:35:49 <vixey> I am really disappointed I could not install linux
12:35:51 <quicksilver> not anyone at MSR
12:35:53 <cjb> and SPJ gives talks using powerpoint
12:35:56 <quicksilver> visual haskell was written by an intern.
12:36:01 <cjb> ah.
12:36:01 <BMeph> I always thought it was because developing systems on Windows is more of a challenge... ;)
12:36:46 <BMeph> s/on Windows/that work on Windows/
12:42:55 <soduko> hi, is there a ini file reader/writer in haskell ?
12:48:55 <ertai> is there a cabal "install-only"
12:48:58 <ertai> ?
12:49:22 <vixey> fetch
12:49:28 <vixey> idk there is a list of commands
12:50:45 <BMeph> soduko: I'm not sure what you're asking for. Could you please elaborate? :)
12:50:59 <ertai> no I mean a replacment for runhaskell Setup install
12:51:23 <ertai> BMeph: you're right it was unclear
12:52:41 <ertai> cabal install in a src dir: configure, build, and install the package
12:52:58 <ertai> and here I don't want it to reconfigure
12:53:24 <ertai> so I can "cabal build", but not "cabal install-without-reconfig..."
12:54:10 <ertai> got it: cabal copy
13:02:18 <adekoba> hackage has been down for a while now, eh?
13:02:38 <maltem> ertai: that would be cabal copy && cabal register, I think
13:03:06 <ertai> maltem: thanks
13:03:30 <ertai> maltem: so, cabal build && cabal copy && cabal register
13:05:34 <mjrosenb> adekoba: physical move iirc
13:05:58 <adekoba> mjrosenb: i see
13:08:58 <RayNbow> > exp pi - pi
13:08:59 <lambdabot>  19.999099979189474
13:08:59 <BMeph> adekoba, mjrosenb: To be pedantic, a host server change.
13:10:54 <mjrosenb> ok, style question, what's better,  (\ [pat] -> do bar) . f _or_ \ x -> do pat <- f x; bar
13:11:02 <maltem> RayNbow: Didn't xkcd pun on that?
13:11:11 <Heffalump> mjrosenb: they're different programs
13:11:16 <RayNbow> maltem: yes
13:11:26 <RayNbow> someone just reposted that xkcd in another channel
13:11:33 <maltem> heh
13:11:37 <Heffalump> the first one will fail on a non-singleton list, the second one will map bar over the entire list
13:12:06 <RayNbow> sigh... every channel should have a lambdabot
13:12:18 <dibblego> RayNbow, which channel?
13:12:31 <RayNbow> or... running an IRC channel without a lambdabot should be a criminal offense :p
13:12:37 <RayNbow> dibblego: a Dutch channel
13:12:38 <mjrosenb> Heffalump: err (\ pat ...) . map f
13:12:42 <RayNbow> #anime @ irc.tweakers.net
13:13:34 <Heffalump> I think it depends on the situation, then, and on personal preferences.
13:13:49 * mjrosenb doesn't know how thet got munged
13:13:54 <Heffalump> (you mean map (\pat ...) . f btw)
13:14:18 <mjrosenb> Heffalump: pretty sure i got it the second time around.
13:14:40 <mjrosenb> the only reason that i could think that one is better is it's easier to handle other patterns
13:15:09 <Heffalump> by switching to a case?
13:15:11 <Heffalump> yeah.
13:15:49 <Heffalump> and I'm fairly sure I'm right about the equivalent code - f happens first, then bar happens for each pat resulting from f x.
13:16:09 <rwbarton> I think it depends on other factors, e.g., if bar is short but f is long, I'd be more likely to write the first
13:16:15 <Heffalump> Also, they aren't equivalent even then, because you get filtering with the do-notation but not with the lambda (which would just cause a runtime error) if the pattern is not total.
13:16:35 <mjrosenb> Heffalump: this is true
13:16:51 <maltem> > do Just x <- [Just 1, Nothing, Just 2]; return (x^2)
13:16:52 <lambdabot>  [1,4]
13:16:57 <desp> Hi.  Can someone suggest how can I get rid of the explicit type annotation in line 10 of http://pastie.textmate.org/223651 ?
13:16:58 <lambdabot> Title: #223651 by Mietek BÄ…k (desp) - Pastie
13:17:28 <mjrosenb> wait, does haskell not support multiple matches in anonymous lambdas?
13:17:36 <Heffalump> mjrosenb: no.
13:17:41 <Heffalump> you have to do \x -> case x of ...
13:17:57 <mjrosenb> gah
13:18:04 <BMeph> desp: Use readInt, maybe? :)
13:18:11 <Heffalump> it is a bit annoying sometimes
13:18:24 <mjrosenb> i vaguely remember doing that
13:18:35 <mjrosenb> then again, i'm also an ml programmer
13:18:52 <RayNbow> is there a package for Haskell for arbitray precision floats?
13:18:53 <desp> BMeph: hm. ;)
13:19:05 * RayNbow wants to check hackage... but it's not responding :p
13:19:27 <maltem> desp: you cannot really, because you have to tell the compiler you want n to be an Int
13:19:31 <BMeph> RayNbow: A-P fractions are all I know of (i.e., Rational)
13:20:00 <BMeph> maltem: Which is why I suggested (Numeric.)readInt. ;)
13:20:00 <Heffalump> desp: you'll have to have a signature somewhere to disambiguate. (Unless defaulting applies here?)
13:20:05 <mjrosenb> but those can't do (1/2) ^^ (1/2) very well
13:20:08 <maltem> BMeph, right :)
13:20:22 <desp> BMeph: yeah, but readInt is hairy.
13:21:21 <desp> readDec would be ok; I'm trying to figure out what to do with the ReadS it returns now. ;)
13:21:28 <maltem> actually, readInt doesn't do what one would think it does
13:21:56 <rwbarton> desp: if you remove the annotation, it doesn't default to Integer?  Or is that not good enough?
13:22:20 <desp> rwbarton: it does.  It works fine; just trying to further my understanding.
13:22:34 <maltem> desp: alas, readDec is polymorphic in the number type, too
13:23:03 <desp> Oh right. And readInt is, too.
13:23:42 <mjrosenb> hrmm, fuck, i want to take the inverse of a non-invertable function
13:24:06 <maltem> that would be an invertable non-function?
13:24:18 <zeno__> @hoogle second
13:24:18 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
13:24:18 <lambdabot> Data.Time.Clock.secondsToDiffTime :: Integer -> DiffTime
13:24:18 <lambdabot> Distribution.Configuration.parseCondition :: ReadP r (Condition ConfVar)
13:24:23 <paolino> desp , it's problem A of the code jam exercise !
13:24:28 <RayNbow> BMeph: but Rationals are kind of limited, right? The function exp is not defined for Rationals
13:24:31 <maltem> (or a functional non-inverse?)
13:24:36 <desp> paolino: ssh. ;)
13:24:57 * mjrosenb needs to think this over a bit more
13:25:53 <mjrosenb> the basic idea is i have a stream of data.  i need to read off n bytes of compressed data, then do some operation on it.  any ideas?
13:27:13 <vixey> ideas about what?
13:27:53 <vixey> RayNbow: It could be defined but what woud 2%1 ^ 1%2 be?
13:28:03 <vixey> since it's partial, maybe that's why it's undefined
13:28:51 <mjrosenb> vixey: ideas about dealing with this.  i think i'm going to go for the quick hack :(
13:29:26 <gwern> woot, my darcs-cabalized is finished
13:29:34 <gwern> now all I need is for hackage to come back up
13:29:37 <codacola> mjrosenb, you couldnty just use Read()?
13:29:48 <jnaimard> congrats gwern
13:30:20 <gwern> it's a very fragile cabalization, but building from sdist should work
13:30:40 <mjrosenb> codacola: i assume you mean an instance of Read?
13:31:00 <mjrosenb> codacola: this is also not [Char], but [Word8]
13:31:17 <gwern> aaaand hackage is still down
13:31:27 * gwern guesses I'll have to wait then
13:31:28 <codacola> no i mean the read mathod of "StreamReader"
13:31:29 <vixey> mjrosenb: what is the problem
13:31:29 <vixey> ?
13:31:50 <gwern> this bites
13:31:57 * gwern thinks I'll go pick mulberries
13:32:01 <mjrosenb> vixey: i have something that looks like this
13:32:18 <yakov> hey
13:32:19 <mjrosenb> assuming that it's stored as [Char]
13:32:28 <codacola> everything is in a file
13:32:39 <mjrosenb> (show size) ++ compress data ++ data'
13:33:07 <codacola> oh crao
13:33:12 <codacola> sorry, wrong bloody channel
13:33:17 <codacola> i thought i was in #csharp
13:33:38 <lament> heh
13:33:43 <mjrosenb> with a bunch of extra data around it, but solving this problem will let me solve the full problem
13:34:02 <lament> with the C# 3.0 features, anybody could have made that mistake!
13:34:44 <vixey> mjrosenb: what if the size was 345
13:34:44 <vixey> mjrosenb: but the compressed data was 53435
13:34:45 <vixey> mjrosenb: how would you tell between the size and the compressed data?
13:34:47 <vixey> "34553435..."
13:35:11 <mjrosenb> vixey: size is going to be a fixed number of chars
13:35:46 <mjrosenb> eeehhh, i'm too tired to think about this, i'm going to use the hacky solution
13:36:17 <vixey> you say "hacky" as if that's a bad thing
13:36:57 <codacola> hacks are bad?
13:37:10 <MyCatVerbs> You could just write a 64 bit big-endian integer in there. :P
13:39:45 <desp> So uh...
13:39:52 <desp> How do you use something that returns a ReadS a?
13:40:15 <EvilTerran> ?src ReadS
13:40:15 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:40:27 <vixey> desp:
13:40:27 <vixey> @src ReadS
13:40:27 <vixey> it's String -> String anyway
13:40:27 <lambdabot> Source not found. :(
13:40:35 <EvilTerran> ReadS a = String -> [(a,String)]
13:40:56 <desp> Is it?
13:41:19 <rwbarton> yeah, it's just a type synonym.
13:41:22 <EvilTerran> > reads "123" :: [(Int,String)]
13:41:24 <lambdabot>  [(123,"")]
13:41:35 <Kenichiro> Wanna Play Fun RPG game ? /q me or join #HypeRPG
13:41:57 <vixey> Kenichiro: fab thanks.. just what I have been waiting for ... :p
13:42:02 <desp> vixey, rwbarton: are you thinking of ShowS maybe?
13:42:05 <vixey> Kenichiro: (I think you are in the wrong place)
13:42:18 <EvilTerran> vixey, i think you're talking to a bod
13:42:20 <EvilTerran> *bot
13:42:29 <vixey> desp  yeah I was
13:42:59 <rwbarton> desp: uh, I'm not really sure I was thinking of anything :)
13:43:18 <desp> :)
13:43:25 <rwbarton> desp: I just clicked here: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AReadS
13:43:28 <paolino> ï»¿> reads "123andmore" :: [(Int,String)]
13:43:36 <lambdabot> http://tinyurl.com/ovjef
13:43:38 <desp> EvilTerran, paolino: thanks, yeah
13:43:50 * vixey laughs at fishing attemp
13:43:51 <vixey>  * Topic for #HypeRPG is: Help : /msg HypeRPG RPG help <> Game Help : /msg HypeRPG rpg help gameplay <> To Register : /msg HypeRPG rpg register <nick> <password>
13:44:19 <paolino> > reads "123andmore" :: [(Int,String)]
13:44:20 <lambdabot>  [(123,"andmore")]
13:45:50 <paolino> EvilTerran: why the list ?
13:46:01 <EvilTerran> in case it's ambiguous
13:46:12 <paolino> it was!
13:46:14 <EvilTerran> which doesn't happen in any of the standard instances, but could theoretically
13:46:14 <Kenichiro> Wanna Play Fun RPG game ? /q me or join #HypeRPG
13:46:14 <sw17ch> EvilTerran, i'd really prefer a Maybe in that case... oh well
13:46:19 <EvilTerran> @where ops
13:46:19 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:46:43 --- mode: ChanServ set +o xerox
13:46:53 <EvilTerran> doh
13:46:54 <desp> Ha.
13:47:00 <EvilTerran> scared it off
13:47:24 --- mode: xerox set +b *!*@*.splius.lt
13:47:26 <EvilTerran> sw17ch, i agree, but that's how it seems to be done
13:47:37 --- mode: xerox set -o xerox
13:47:38 * sw17ch grumbles, complains... goes back to work
13:47:54 <idnar> Maybe doesn't let you return multiple values, I guess
13:48:09 <glguy> What's wrong?
13:48:18 <paolino> (1,"23") was a valid parse
13:48:29 <sw17ch> idnar, what case would that make sense for reads?
13:48:30 <sw17ch> @type reads
13:48:32 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:48:50 <idnar> sw17ch: I don't know anything about the implementation details
13:48:57 <sw17ch> alright
13:49:07 <sw17ch> > reads "" :: (Int,String)
13:49:07 <lambdabot>  Couldn't match expected type `(Int, String)'
13:49:18 <EvilTerran> paolino, i believe the spec specifies "longest possible sequence" for the grammar
13:49:19 <sw17ch> > reads "" :: [(Int,String)]
13:49:20 <lambdabot>  []
13:49:26 <sw17ch> see, that should be Nothing
13:49:39 <sw17ch> it would be a lot less scary that way
13:50:05 <paolino> EvilTerran: then which ambiguities ?
13:50:21 <EvilTerran> i don't know, man, i didn't do it! <_<  >_>
13:50:34 <paolino> :)
13:50:51 <sw17ch> hehe
13:53:26 <sw17ch> so, i'm part of a small compiler club... two of us are writing compilers in Haskell
13:53:30 <sw17ch> and i had this funny idea
13:54:06 <vixey> compilers for what languages antd to what target?
13:54:10 <sw17ch> i'm not sure if it's used already (i'm sure it is somehow). I parse an AST, and then have that AST implement a class interface. The class interface defines how to generate code for a specific target.
13:54:28 <sw17ch> vixey, the language is an academic "here's how compilers work" language
13:54:34 <sw17ch> the target is Parrot's PIR for now
13:54:53 <vixey> o_o
13:55:00 <vixey> do you have a description of the lanuage?
13:55:03 <sw17ch> hehe
13:55:09 <sw17ch> yes....
13:55:10 * sw17ch looks for it
13:55:43 <sw17ch> http://cs.calvin.edu/curriculum/cs/382/jdfrenscompilers/hobbes.html
13:55:44 <lambdabot> Title: CS 382: Hobbes, http://tinyurl.com/6k7zoh
13:56:16 <sw17ch> though, i'm not tied to this language, it is a club after all
13:56:19 <vixey> oh ok
13:56:45 <vixey> anyway sorry for interrupting you, what were you saying?
13:57:37 <sw17ch> vixey, i'm wondering if it makes sense to make a well defined AST, and have the AST data type implement a type interface for each target one wants to target
13:57:53 <sw17ch> so i have a TargetPIR class, and i could have a TargetPPC or TargetX86...
13:57:54 <sw17ch> etc
13:58:09 <sw17ch> and it defines a few things one must do to convert an AST to that target language
13:58:24 <sw17ch> assuming super dumb code generation
13:59:11 <Athas> What is the .hsc extension used for?
13:59:21 <dons> Athas: preprocessing by hsc2hs
13:59:28 <dons> a tool that includes C #defines into haskell
14:00:01 <vixey> sw17ch: sounds ok I don't think I wuold bother to make a typeclass for it though
14:00:36 <Athas> Oh, that looks fairly clever.
14:02:28 <sw17ch> vixey, that's the part i'm not sure about
14:08:48 <Saizan_> sw17ch: the question is, given the interface of the typeclass, could you write some useful functions that use the methods without knowing the precise type?
14:09:26 <sw17ch> Saizan_, well, that's mostly why i asked. i'm wondering if there are obvious good reasons to do it this way
14:09:35 <sw17ch> if not, i'm going to try it and see what comes of it
14:13:07 <dons> well, galois has moved.
14:13:11 <dons> servers are slowly coming back up
14:13:19 <dons> hopefully hackage is back up soonish
14:13:48 <desp> http://pastie.textmate.org/223689 -- could I have avoided definig two arrays for readInt?
14:13:49 <lambdabot> Title: #223689 by Mietek BÄ…k (desp) - Pastie
14:13:54 <desp> defining*
14:14:21 <mar77a> the adventures of donsvelix and galoisvelix
14:14:47 <dons> elliottt: /join #galois
14:16:50 <tobias_tud> does anyone knows a good tutorial about Data.Graph?
14:27:42 <codacola> ok this error is confusing me :S
14:27:44 <codacola> *** Expression     : base power
14:27:44 <codacola> *** Term           : base
14:27:44 <codacola> *** Type           : Int
14:27:44 <codacola> *** Does not match : a -> b
14:27:51 <dolio> desp: I'm pretty sure 'valid = array (chr 0, chr 255) (zip src (repeat True))
14:27:54 <EvilTerran> whoa there
14:27:56 <EvilTerran> ?hpaste
14:27:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:28:09 <dolio> desp: And toInt = array (chr 0, chr 255) (zip src [0..])
14:28:14 <codacola> sorry
14:28:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8588
14:28:51 <desp> dolio: um, no?
14:28:54 <codacola> http://hpaste.org/8588
14:29:04 <codacola> ah
14:29:06 <codacola> interesting
14:29:15 <desp> Ah, so array ignores additional input.
14:29:31 <dolio> desp: zip truncates to the shortest array anyhow.
14:29:38 <dolio> Er, list.
14:29:52 <EvilTerran> codacola, "myexp(base power-1)"?
14:29:58 <desp> Ah, of course, silly me. Thanks.
14:30:07 <EvilTerran> codacola, ITYM "myexp base (power-1)"
14:30:29 <dolio> desp: You could also combine them like 'combined = array (chr 0, chr 255) (src `zip` [0..] `zip` repeat True)' (you might need to associate them differently).
14:31:14 <codacola> aha!
14:31:17 <codacola> thankyou EvilTerran
14:31:21 <dolio> Of course, that doesn't necessarily help with memoizing the functions you want to.
14:32:08 <desp> dolio: you mean GHC could automatically memoize those array lookups?
14:32:44 <BMeph> desp: Just curious, desp, but... what is the goal of this program, anyhow? :)
14:33:01 <dolio> Well, I mean you could use, say (`elem` src) instead of (valid !), but the former is O(n) instead of O(1).
14:33:24 <dolio> That's why you're using arrays, right?
14:33:43 <rwbarton> @hoogle a -> [a] -> Int
14:33:44 <lambdabot> No matches, try a more general search
14:34:20 <desp> dolio: yes.  OK, I wasn't sure what you were referring to.
14:34:22 <rwbarton> @hoogle elemIndex
14:34:23 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
14:34:23 <lambdabot> Data.ByteString.elemIndex :: Word8 -> ByteString -> Maybe Int
14:34:23 <lambdabot> Data.ByteString.Char8.elemIndex :: Char -> ByteString -> Maybe Int
14:34:24 <hpaste>  (anonymous) pasted "sigh, "C in haskell" on reddit again" at http://hpaste.org/8589
14:35:05 <Mr_Awesome> i feel like the standard arrays in haskell could be much much better than they currently are
14:36:02 <dons> there's some great new array libraries on hackage
14:36:06 <dons> uvector, Vec, hmatrix
14:36:08 <vixey> Mr_Awesome: the best thing to do is note down your ideas in the form of code
14:36:14 <Athas> So, `ghc-pkg list X11
14:36:34 <Athas> So, `ghc-pkg list X11' gives two results, how do I control which is used when I do `runhaskell Setup build'?
14:36:35 <idnar> haha @ paste
14:36:50 <Mr_Awesome> vixey: i dont understand...
14:37:12 <dons> people haven't really tried using the new array libraries yet. the game has changed a fair bit
14:37:23 <dons> hmatrix, for example, makes whole new classes of haskell solutions possible
14:37:52 <Mr_Awesome> indeed. i dont know why anyone settled with the current standard arrays
14:39:21 <MyCatVerbs> dons: !
14:39:24 <MyCatVerbs> dons: hmatrix is <3
14:40:06 <MyCatVerbs> Actually, come to think of it, does \bot have hmatrix installed?
14:40:09 <dolio> Speaking of uvector, have you thought anymore about what the MUArr portion of the library is going to look like?
14:40:11 <hpaste>  BMeph annotated "sigh, "C in haskell" on reddit again" with "No IRC?!" at http://hpaste.org/8589#a1
14:40:18 <vixey> can't you do this?
14:40:19 <vixey> data Foo a = Bar :: Foo Int
14:40:19 <vixey>            | Baz :: Foo (Foo Int)
14:40:47 <MyCatVerbs> vixey: doesn't that require GADTs?
14:41:03 <vixey> what do I need to do to make it work
14:41:03 <vixey> ?
14:41:05 <dolio> And if so, will the sorting stuff I've been working on be part of it, perchance? Or should I work on putting together a separate library for it?
14:41:55 <Saizan_> vixey: data Foo a where Bar :: Foo Int; Baz :: Foo (Foo Int)
14:42:03 <dolio> I'm at sorting parity with C++, more or less. A fast introsort, a slow heapsort, and a fast merge sort.
14:42:08 <vixey> what about exactly what I wrote?
14:42:47 <shapr> %yow
14:42:49 <shapr> ?yow
14:42:49 <lambdabot> Couldn't find fortune file
14:42:52 <shapr> !yow
14:43:12 <Saizan_> what you wrote is not even contemplated by the syntax
14:43:21 <dolio> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!!
14:43:38 <vixey> I found something like it in the epigram source code
14:43:44 <shapr> dolio: Thank you!
14:43:50 <vixey> that's odd
14:43:58 <dolio> I aim to please.
14:44:24 <shapr> @hackage
14:44:24 <lambdabot> http://hackage.haskell.org
14:44:29 <shapr> @seen hackage
14:44:29 <lambdabot> I saw hackage leaving #haskell 22h 58m 3s ago, and .
14:44:31 <shapr> aww
14:44:42 <dons> soon soon!
14:44:50 <dons> the mail server is back up, more stuff coming on all the time
14:45:20 <sutats> How can I read a binary file into a UArray Bool?
14:45:36 <shapr> What's the best XMPP lib for Haskell?
14:45:40 <dons> sutats: there's hGetU instances
14:46:20 <sutats> dons: Where can I find that?
14:46:56 <shapr> I want hackage mirrors!
14:46:58 <dons> sutats: its in Data.Array.Vector.UArr, look in the source to find it.
14:47:10 <dons> shapr: yeah. the new chalmers machine will be a european mirror, i think
14:47:13 <sutats> dons: Thanks, I'll check it out.
14:47:15 <dons> and we can use code.h.o ass another one
14:47:50 <shapr> cool
14:48:04 <dolio> dons: Any thoughts on what I said above (sorry to pester)?
14:48:05 <shapr> Too bad we don't have torrents.hackage.h.o
14:49:04 <MyCatVerbs> shapr: what on Earth would that be good for? Distributing full copies of GHC's darcs history?
14:49:16 <shapr> It'd be an instant mirroring system.
14:49:36 <MyCatVerbs> Bittorrent isn't designed for quick updating, though.
14:49:43 <shapr> Plus I like to download ALL the libs, not just some of them!
14:49:49 <MyCatVerbs> Heh.
14:49:54 <shapr> MyCatVerbs: But it would suffice.
14:49:57 <MyCatVerbs> shapr: like weekly snapshots or something?
14:50:02 <shapr> Yeah, that would be cool.
14:50:09 <MyCatVerbs> Yeah, I guess that would be pretty okay.
14:50:28 <shapr> Of course, cabal would need to support local hackage repos then.
14:50:36 <MyCatVerbs> Would be better if we had something bittorrent-like that could distribute (where possible) just the diffs between successive weeks.
14:51:28 <MyCatVerbs> So that you'd end up downloading deltas each week, rather than repeatedly wasting bandwidth on the whole thing. >>
14:51:55 <shapr> MyCatVerbs: Quick! Write it!
14:52:08 <shapr> Or use rsync?
14:52:17 <shapr> How could you mix rsync and bittorrent?
14:52:21 <MyCatVerbs> shapr: rsync isn't distributed though.
14:52:31 * MyCatVerbs thinks.
14:52:53 <dons> dolio: oh, sorry, busy
14:52:57 <MyCatVerbs> shapr: obvious solution: built a darcs2 or git patch each week, then put up two torrents: this week, and the diff between this week and last week.
14:53:03 <dons> MyCatVerbs: rsync?
14:53:05 <dolio> 'Sallright.
14:53:11 <MyCatVerbs> shapr: if you miss a week, that sucks, you get to re-download eveyrthing again. Other than that, fine.
14:53:18 <hukolele> @hoogle [a] -> [[a]]
14:53:18 <lambdabot> Data.List.inits :: [a] -> [[a]]
14:53:18 <lambdabot> Data.List.tails :: [a] -> [[a]]
14:53:18 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
14:53:21 <MyCatVerbs> dons: rsync doesn't get you distribution like bittorrent does, though.
14:53:25 <sutats> Or you patch the previous weeks and repatch the current week.
14:53:26 <dons> right
14:53:48 <MyCatVerbs> sutats: well okay, that too. Depends on how big the diffs are compared to the repos.
14:53:59 <sutats> True.
14:54:02 <hukolele> @hoogle a -> [[a]]
14:54:02 <lambdabot> No matches, try a more general search
14:54:26 <EvilTerran> > (return.return) x
14:54:26 <lambdabot>   add an instance declaration for (Show (m (m1 Expr)))
14:54:30 <EvilTerran> > (return.return) x :: [[Expr]]
14:54:31 <bd_> MyCatVerbs: The diffs would just contain all the new patches, surely
14:54:32 <lambdabot>  [[x]]
14:54:48 <sutats> The problem with the torrent approach is that each week you'll be generating another torrent (or two).
14:54:55 <bd_> right
14:54:55 <sutats> And people might stop seeding the older ones
14:55:13 <grahamhutton> @users
14:55:13 <lambdabot> Maximum users seen in #haskell: 469, currently: 450 (95.9%), active: 21 (4.7%)
14:55:21 <MyCatVerbs> bd_: there's a lot of disparate systems in there, though. Things like the trac wiki, etc. I'd be surprised if you ended up with anything other than a single monolithic patch for the entire week.
14:55:22 <bd_> I've had this idea kicking around for an updatable torrent protocol extension, but I've never gotten around to implementing it, or even fleshing out a proto-spec...
14:55:47 <MyCatVerbs> sutats: well, switch the trackers off for everything more than one or two weeks old.
14:56:12 <sutats> MyCatVerbs: And then people who miss more than a week will have to pull the entire set?
14:56:26 <bd_> MyCatVerbs: Oh, I thought you meant just the darcs stuff.
14:56:27 <MyCatVerbs> sutats: yeah. But who does that?
14:56:29 <vixey> humpf :(
14:56:37 <bd_> MyCatVerbs: Things like wiki and the bug trackers are possibly better off with just rsync
14:56:50 <vixey> hi grahamhutton :)
14:57:04 <grahamhutton> hi vixey!
14:57:11 <shapr> hi grahamhutton !
14:57:16 <grahamhutton> hi shae!
14:57:17 <MyCatVerbs> bd_: no, hackage and everything too, so that people could keep going even when hackage.h.o goes kaboom, albeit with slightly stale versions of all the contents.
14:57:44 <hukolele> @hoogle Int -> [a] -> [[a]]
14:57:45 <lambdabot> No matches, try a more general search
14:57:49 <MyCatVerbs> bd_: or if the trac wiki suddenly disappears off the face of the earth? Maybe it'd be nice to have a local copy.
14:58:14 <hukolele> @hoogle [a] -> Int -> [[a]]
14:58:14 <lambdabot> No matches, try a more general search
14:58:28 <MyCatVerbs> sutats: well, the alternative is to write an entirely new tool which combines both Bittorrent and Rsync's tasks. Which, er, would be fun. :P
14:58:35 <bd_> MyCatVerbs: right, I mean, something like bittorrent is probably not ideal for things like trac and the wikis - a tree of rsyncs might be better
14:58:54 <bd_> in particular, bt does badly with insertions or deletions
14:59:05 <bd_> (within a file)
14:59:11 <sutats> MyCatVerbs: Haha, that would be fun...
14:59:14 <MyCatVerbs> bd_: badly? Methought it didn't deal at all. :P
14:59:29 <bd_> MyCatVerbs: Well, if you get really lucky... :)
14:59:34 <MyCatVerbs> bd_: this is why the suggestion is to distribute regularly generated patches instead.
14:59:54 <shapr> @seen stepcut
14:59:54 <lambdabot> I haven't seen stepcut.
14:59:55 <bd_> MyCatVerbs: how is this better than a rsync server, possibly with a mirror set as well?
14:59:55 <MyCatVerbs> bd_: heh. So only, what, 1 in (block size) odds? :P
14:59:56 <shapr> aww
15:00:33 <bd_> MyCatVerbs: nono, 1 in (probability of the original file containing a sequence which, truncated to $length_of_match, is its own prefix)
15:00:37 <MyCatVerbs> bd_: probably isn't. The only benefit would be to save haskell.org some of the bandwidth from people mirroring it.
15:00:56 <MyCatVerbs> bd_: but then, rsync is just as good in practice anyway since people cascade rsync mirrors.
15:01:10 <shapr> sethk is gone forever :-(
15:01:12 <bd_> right, and cascading like that means you don't have to worry about missing an updaty
15:01:13 <shapr> @seen sethk
15:01:13 <lambdabot> I haven't seen sethk.
15:01:15 <bd_> update*
15:01:16 <bd_> otoh, higher cpu load
15:01:29 <MyCatVerbs> bd_: hrm? CPU load?
15:01:41 <bd_> rsync has to compute the diff on the fly
15:01:48 <shapr> dons: sethk passed away - http://marvelouspersona.blogspot.com/2008/06/seth-kurtzberg.html
15:01:49 <lambdabot> Title: Brooklonnolly.: Seth Kurtzberg.
15:01:54 * shapr is sad
15:02:15 <bd_> vs just tossing a precomputed file into the network card
15:02:28 <MyCatVerbs> bd_: probably not a huge issue. Most places would only be seeing a couple of incoming rsync requests a day.
15:02:47 * Eldanen pats shapr on the shoulder.
15:02:47 <bd_> sure
15:02:56 <bd_> and the mirror cascade could precompute patches for the tier-2 mirrors
15:03:15 <dons> shapr: oh no
15:03:52 <dons> shapr: this is terrible news :(
15:04:30 <shapr> yes, very sad, he did a lot of cool stuff, was a cool guy.
15:05:13 <shapr> #buglabs and #linuxhelp mention him in the topic
15:06:35 <dons> i remember when he first appeared here a few years ago, he was writing a testing system for some chip manufacturing hardware assembly line in taiwan, in haskell
15:06:41 <dons> super smart guy, very talented
15:07:05 <dons> amazing engineer
15:07:22 <shapr> Yeah, and he owned cql.com, that's where I first saw him.
15:12:16 <shapr> :-(
15:12:29 <shapr> Best remembrance is to write good code!
15:19:02 <roconnor> @remember Seth Kurtzberg
15:19:02 <lambdabot> Okay.
15:19:26 <shapr> yeah
15:22:58 <dons> wow, he was something of a pioneer in #haskell, way back in 02, http://www.cse.unsw.edu.au/~dons/sethk.txt
15:23:39 <shapr> Yeah, long time ago.
15:24:26 <tobias_tud> has anybody experience with Data.Graph?
15:24:41 <dons> tobias_tud: yav just rewrote the scc algorithm for it
15:25:36 <tobias_tud> okay, thanks, i'll ask him
15:26:28 <RayNbow> dons, I had a question regarding RWH... is there a reason why list comprehension is mentioned in ch. 16 for the first time?
15:26:34 <jadrian> is there an empty object in Haskell?
15:26:37 <dons> RayNbow: hah.
15:26:38 <vixey> no idea what to do ...
15:26:39 <shapr> jadrian: () ?
15:26:41 <jadrian> that is a type with no values at all
15:26:45 <dons> RayNbow: no, there's no special reason.
15:26:46 <vixey> jadrian: data Void
15:26:51 <jadrian> shapr: that's terminal no?
15:27:18 <jadrian> vixey: where is that defined?
15:27:23 <vixey> it's not
15:27:42 <vixey> you will need -XEmptyDataDecls or somithng
15:27:45 <Japsu> jadrian: what do you mean with empty object? like, null or None in other languages?
15:28:06 <RayNbow> dons: ah ok. I was probably put off guard by "The list monad is similar to >>a familiar Haskell tool<<, the list comprehension"
15:28:17 <jadrian> Japsu: I mean a type that has no values
15:28:19 <RayNbow> so I started browsing through the previous chapters
15:28:23 <Japsu> oh, I missed that
15:28:28 <jadrian> vixey: thanks let me check that
15:28:33 <vixey> jadrian: of course no such thing exists in haskell
15:28:35 <dons> RayNbow: wow, so we really don't mention it till ch16?
15:28:37 <vixey> :t undefined
15:28:38 <lambdabot> forall a. a
15:28:45 <vixey> jadrian: but Void is pretty close
15:28:47 <dons> RayNbow: can you put a comment in regarding that? it seems an oversight
15:28:53 <Japsu> depends on the definition of haskell
15:28:53 <RayNbow> sure
15:28:55 <Japsu> ;)
15:28:58 <vixey> @report
15:28:59 <lambdabot> ()
15:29:03 <vixey> Japsu: that one
15:29:09 <Japsu> heh
15:29:18 <RayNbow> dons, http://www.google.nl/search?source=ig&hl=nl&rlz=&q=site%3Abook.realworldhaskell.org+comprehension&meta= <-- I even asked Google where list comprehensions are mentioned
15:29:19 <jadrian> vixey: by that you mean it still has undefined?
15:29:19 <lambdabot> Title: site:book.realworldhaskell.org comprehension - Google zoeken, http://tinyurl.com/6bethf
15:29:25 <vixey> jadrian: yes
15:29:26 <jadrian> vixey: or what do you mean exactly
15:29:39 <jadrian> vixey: ok that's fine in my case... I think
15:29:59 <Japsu> there's even practical uses for types with no values
15:30:01 <vixey> I'm trying to think of something I could do in haskell
15:30:07 <vixey> maybe write a tutorial or something
15:30:15 <vixey> I don't know I am bored
15:30:16 <jadrian> Japsu: well I'm asking because it would be handy now :P
15:30:21 <dons> write a ffi binding !
15:30:44 <Japsu> jadrian: http://pseudo.fixme.fi/~opqdonut/blog/Attribute_Grammars__GADTs_and_MonadFix__part_1_.html
15:30:46 <lambdabot> Title: (&#x03BB;blog. blog blog) (&#x03BB;blog. blog blog): Attribute Grammars, GADTs a ..., http://tinyurl.com/5refno
15:30:46 <vixey> I gave up because of c2hs and I think has it covered
15:30:55 <vixey> I think adu has it covered
15:31:49 <dons> ?users
15:31:49 <lambdabot> Maximum users seen in #haskell: 469, currently: 443 (94.5%), active: 12 (2.7%)
15:32:39 <jadrian> In my case I have a data declaration lets say:     data X a b = C1 a | C2 b     and sometimes it happens that  b  does not exist
15:32:50 <jadrian> and it should not be possible to have C2 b
15:32:54 <jadrian> for any value
15:33:05 <vixey> there will always be C2 undefined
15:33:06 <jadrian> so I want be to be Void
15:33:12 <vixey> you can just not make it though
15:33:12 <dibblego> data X a b = C1 a | C2 b | C3
15:33:14 <jadrian> vixey: yes I know :S
15:33:16 <vixey> then it will never happen
15:33:23 <EvilTerran> newtype Foo = Foo Foo
15:33:47 <shapr> opqdonut: Nice post
15:33:54 <EvilTerran> also has _|_ as its only value
15:34:06 <jadrian> vixey: what if I put a strictness anotation ...
15:34:14 <jadrian> vixey: in the data definition
15:34:22 <vixey> jadrian: What's the point in this anyway?
15:34:30 <opqdonut> shapr: heh thanks
15:34:38 <vixey> jadrian: maybe there are some invarients you want to express.. and they can be done in a different way
15:34:41 <opqdonut> i'm writing part 2 right now actually
15:34:42 <pastorn> anyone: hackage is down
15:34:45 <jadrian> vixey: I'm implementing something similar to curien concrete data structures...
15:34:53 <vixey> what's that?
15:34:54 <jadrian> vixey: maybe...
15:34:56 <shapr> opqdonut: I wonder if figuring out the morphisms behind AGs would let you fuse the passes whenever you feel like it?
15:35:01 <jadrian> vixey: semantics stuff
15:35:03 <pastorn> *s/anyone/anyone that has power over it*
15:35:11 <jadrian> vixey:  would take ages to explain...
15:35:15 <jadrian> vixey:  but basically
15:35:21 <dons> shapr: so what you up to these days?
15:35:26 <jadrian> vixey:  I have values and I have cells
15:35:27 <dons> working for edwardk?
15:35:29 <shapr> dons: Work? Fun?
15:35:30 <opqdonut> shapr: hmm?
15:35:44 <jadrian> vixey:  and values can be simple stuff like integers
15:35:55 <jadrian> vixey:  but can also be more complicated stuff
15:35:55 <shapr> dons: Yeah, working for edwardk. C# and Microsoft development is ... well it pays well. I'm not so impressed other than that.
15:36:01 <dons> heh
15:36:05 <jadrian> vixey:  like reading from a cell
15:36:08 <shapr> dons: On the other hand, lunch time with edwardk is frickin awesome.
15:36:11 <opqdonut> well c# isn't the worst possible lalnguage
15:36:15 <vixey> jadrian: ok
15:36:17 <dons> i saw a girl today wearing a tshirt saying "Boston Sucks" -- is that true?
15:36:23 <shapr> opqdonut: I've been doing vba the last two months.
15:36:29 <jadrian> vixey:  so I have    ValSet a c = Base a | Read c
15:36:35 <shapr> opqdonut: Now I'm switching to sharepoint dev with C#.
15:36:42 <opqdonut> good for you :)
15:36:42 <RayNbow> shapr: which flavor of VBA?
15:36:44 <jadrian> vixey:  but I might have no cells to read from
15:37:03 <RayNbow> Word's VBA somewhat resembles VB
15:37:18 <RayNbow> but Access's VBA is mutilated
15:37:20 <shapr> dons: I live about two miles from MIT/Harvard, so I really like living in Somerville.
15:37:35 <shapr> dons: Boston is a seriously weird place. Driving here is a bloodsport, pretty much.
15:37:43 <jadrian> vixey:  so in that case I would have something like  ValSet Int Void
15:37:43 <vixey> jadrian: so whether or not Read <x> typechecks could be based on the type 'a'?
15:38:00 <vixey> oh
15:38:16 <vixey> jadrian: in that case Void might be (), or Bool, or 3, or 4 .. ?
15:38:19 <shapr> Happily, I enjoy driving in Boston! It's great fun!
15:38:25 <vixey> jadrian: Void might be replaced with*
15:38:44 <shapr> dons: For fun, I sleep...
15:38:50 <jadrian> vixey: If I understood your question yes
15:38:56 <shapr> dons: How's life in the northwest?
15:39:03 <jadrian> vixey:  I could have  ValSet Int Int
15:39:09 <vixey> jadrian:
15:39:09 <vixey> data Fin n where
15:39:09 <vixey>  Fz :: Fin (S n)
15:39:09 <vixey>  Fs :: Fin n -> Fin (S n)
15:39:24 <vixey> data Z
15:39:24 <vixey> data S a
15:39:34 <shapr> dons: I was just talking about you yesterday on the carpool home... I am amazed that you can be married and employed and still have time for #haskell and community stuff!
15:40:10 <jadrian> vixey:  you totally lost me :)
15:40:10 <vixey> jadrian: what we have is Finite sets
15:40:16 <vixey> jadrian: Fin 0 is Void
15:40:18 <vixey> jadrian: Fin 1 is ()
15:40:23 <vixey> jadrian: Fin 2 is Bool ...
15:40:29 <vixey> jadrian: (at least to isomorphism)
15:40:45 <vixey> jadrian: so if you have 6 cells, then you can use Fin 6 to have a type of numbers restricted by that bound
15:41:59 <vixey> in this case
15:42:20 <vixey> Read x :: ValSet Int (Fin 0) will never type check
15:42:22 <vixey> for any x
15:42:44 <vixey> Read Fz :: ValSet Int (Fin 2) and Read (Fs Fz) :: ValSet Int (Fin 2)  or ok though
15:42:46 <idnar> @kind Void
15:42:48 <lambdabot> Not in scope: type constructor or class `Void'
15:42:53 <akuma2k8> hi all...i apologize in case i'm asking what many others have asked, but is hackage.haskell.org down?
15:43:04 <vixey> jadrian: does that make sense? (also I use the shorthand 2 for S (S Z))
15:43:07 <EvilTerran> akuma2k8, the /topic can tell you
15:43:14 <dons> akuma2k8: yes, it is a scheduled server move.
15:43:16 <jadrian> vixey:  this actually looks intersting... although I still have to give the finite sets def another look... but
15:43:21 <lowki> i need help with confusing error message
15:43:21 <dons> hopefully back up in the next few hours
15:43:22 <lowki>  No instance for (Eq a)
15:43:22 <lowki>       arising from use of `==' at Tokenizer.hs:395:7-26
15:43:22 <lowki>     Possible fix: add (Eq a) to the type signature(s) for `getIndex'
15:43:28 <jadrian> vixey:  my cells definition needs to be very flexible
15:43:30 <lowki> how fix ?
15:43:34 <shapr> dons: Moving to portland?
15:43:41 <jadrian> vixey:  I really need it to be polimorphic on cells
15:43:42 <vixey> jadrian: if this is too primitive maybe it can be generalized
15:43:46 <dons> shapr: yes, in downtown portland now
15:43:50 <akuma2k8> dons, EvilTerran : thanks :) i was trying to get xmonad up and running but i guess i'll have to wait
15:43:51 <dons> in the middle of the city
15:44:03 <dons> akuma2k8: right, or grab it from a mirror (e.g. code.haskell.org/xmonad)
15:44:22 <hpaste>  lowki pasted "getIndex" at http://hpaste.org/8590
15:44:24 <shapr> @seen adept
15:44:24 <lambdabot> I haven't seen adept.
15:44:26 <shapr> aww
15:44:31 <jadrian> vixey:  cells can be base cells...   or they can be sets of pairs (values, cells)
15:45:06 <lowki> please haskell types make things strange and give error messages to things that should make sense
15:45:13 <jadrian> vixey:  one second
15:45:17 <slava> hi dons
15:45:18 <vixey> lowki: that is not true
15:45:18 <shapr> lowki: What?
15:45:27 <lowki> like  lowki pasted "getIndex" at http://hpaste.org/8590
15:45:30 <dons> http://hpaste.org/8590 he's referring to
15:45:33 <lowki> gives error mesage
15:45:46 <shapr> lowki: Do you know about typeclasses?
15:45:48 <vixey> lowki: just remove the type annotation
15:45:49 <EvilTerran> that's a pretty clear error message
15:45:54 <vixey> lowki: the problem will disappear
15:45:55 <shapr> lowki: Where are you taking classes?
15:45:57 <dons> ?src (!!)
15:45:57 <lambdabot> xs     !! n | n < 0 = undefined
15:45:57 <lambdabot> []     !! _         = undefined
15:45:57 <lambdabot> (x:_)  !! 0         = x
15:45:57 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:46:07 <dons> ?src elemIndex
15:46:08 <lambdabot> elemIndex x     = findIndex (x==)
15:46:11 <dons> ?src findIndex
15:46:11 <lambdabot> findIndex p     = listToMaybe . findIndices p
15:46:15 <dons> ?src findIndices
15:46:15 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
15:46:17 <dons> heh
15:46:24 <lowki> so i just take out type assignment and will work?
15:46:28 <vixey> lowki: try it
15:46:36 <dons> lowki: you're missing an Eq a instance, no?
15:46:43 <dons> since you try to use == on any type 'a'
15:46:44 <lowki> shapr: i not take classes
15:46:53 <dons> but it'll only work on, Eq a => a -> [a] -> Int
15:46:54 <EvilTerran> dons, the error he pasted earlier said precisely that
15:46:56 <deadManShoues> maybe deriving?
15:47:03 <shapr> lowki: Oh, how did you start with Haskell?
15:47:08 <lowki> dons: that sounds like error message repeat not explain anything
15:47:22 <vixey> lowki: Have you tried it ...?
15:47:23 <dons> getIndex :: Eq a => a -> [a] -> Int
15:47:29 <lowki> shapr: by using this chatroom + yaht
15:47:32 <dons> lowki: missing Eq a
15:47:40 <shapr> lowki: What got you interested in Haskell?
15:47:42 <lowki> kk
15:47:45 <lowki> i try that
15:47:59 <lowki> shapr: its the most functional language
15:48:00 <jadrian> vixey: so you see.. I need cells to be quite general
15:48:06 <shapr> lowki: That's a good reason.
15:48:10 <jadrian> vixey: not finite sets or anything of the sort
15:48:11 <lowki> :)
15:48:29 <shapr> No wonder I can't darcs pull the cabal repo...
15:48:31 <shapr> duh
15:48:42 <jadrian> vixey: they might be integers, characters, or even pairs (cell,value)
15:49:07 <vixey> jadrian: You might not want to give a complete expression of the store using types but if you did one dimension to generalize in is that numbers (S (S (S Z))) are lists of (),
15:49:11 <lowki> dons: thanks it worked =>
15:49:15 <dons> :)
15:49:22 <vixey> jadrian: so it could be changed into a list of types instead
15:49:59 <vixey> lowki: You could still try removing the type annotation
15:50:11 <vixey> lowki: All the information you wrote can be inferred
15:50:41 <vixey> jadrian: the question is whether you actually benefit from putting that much precision into the type
15:51:26 <vixey> Should GHC 6.8.3 comple?
15:51:28 <vixey> compile?
15:51:29 <lowki> vixey: i like verbosity
15:51:51 <lowki> i still have 6 more errors in file to take care of had hundreds
15:51:51 <vixey> lowki: regardless, it might be illustrative of what's going on
15:52:25 <dons> opqdonut: you should check your file incrementally, using 'undefined' for parts not written yet
15:52:35 <dons> that way you can ensure you always code in the right direction
15:52:42 <lowki> i was softening the rpoku parser or still am softcoderizing it
15:52:46 <opqdonut> dons: ?
15:53:03 <vixey> I am wondering why GHC fails to beild..
15:53:06 <vixey> build*
15:53:07 <lowki> tokenizer actually you know lojban
15:53:13 <jadrian> vixey: basically what that tecnhique does is calculating Int^X right?
15:53:24 <jadrian> vixey: and if X = () you get Int
15:53:26 <dons> opqdonut: sorry. i mean lowki
15:53:26 <vixey> jadrian: I have no idea what Int^X means
15:53:31 <opqdonut> dons: np :)
15:53:53 <lowki> i went to jail for pushing my mom so i couldnt program for a while so have been away
15:54:22 <jadrian> vixey:  Int would be the set of integers
15:54:32 <jadrian> vixey:  ^X and exponential
15:54:38 <jadrian> vixey:  where X is some other set
15:54:47 <vixey> I don't know what that means
15:54:47 <jadrian> vixey:  mathematics... not haskell
15:54:54 <lowki> now i have my own place so it better anyways just got my laptop back wednesday evening
15:55:17 <lowki> meh i go back to coding
15:55:19 <jadrian> vixey:  well your technique to calculate finite sets
15:55:30 <jadrian> vixey:  to define finite sets sorry
15:55:41 <jadrian> vixey: you use () as the base case
15:56:08 <jadrian> vixey: and then just iterate recursively over it...
15:56:24 <vixey> what I really meant was
15:56:29 <vixey> your type level 3
15:56:35 <vixey> is sort of like [(),(),()]
15:56:47 <vixey> but a generalization could be to change it into [Int,(Int,Int),Int]
15:56:57 <leoncamel> hey. folks. I can't connect to hackage.haskell.org . can you confirm if it works ?
15:57:05 <dolio> Heh.
15:57:10 <dons> leoncamel: it is down while it is being physically moved to a new location
15:57:17 <shapr> Nobody reads the topic...
15:57:18 <shapr> not even me.
15:57:19 <dons> soon to be back online with faster bandwidth
15:57:26 <vixey> how come nobody reads the topic ;_;
15:57:39 * heatsink reads the first line of the topic
15:57:43 <dolio> Too much work!
15:57:46 <heatsink> That's all my irc client displays
15:57:48 <shapr> y0 heatsink, long time no see.
15:57:50 <rwbarton> It's off the screen...
15:57:59 <shapr> heatsink: Wait, you're not Echo Nolan...
15:58:02 <leoncamel> dons: OK. but, when will it back ?
15:58:19 <dolio> "until approx 2008.06.28 UTC"
15:58:22 <heatsink> Nolan?
15:58:35 <dolio> It says that in the topic, too. :)
15:58:37 <shapr> heatsink: Yeah, Echo Nolan used to hang out on #haskell as heatsink.
15:58:54 <shapr> heatsink: Or am I confused and it was you? Several years ago?
15:58:54 <heatsink> oh... I didn't know that.
15:58:55 <dons> leoncamel: this afternoon, hopefully
15:59:09 <dons> maybe very soon
15:59:20 <dons> i can ping the machine, no ssh yet
15:59:21 <heatsink> I've had this nick registered for several years, but I haven't been Echo Nolan for at least several years.
15:59:36 <shapr> heatsink: Were you Echo Nolan at some point?
15:59:40 <heatsink> Nope
15:59:42 <leoncamel> dons: OK. thanks.
15:59:42 <shapr> Kattana: SST?
16:00:05 <Kattana> yes
16:00:14 <shapr> Kattana: Just checking... what bring you here? Picking up Haskell?
16:00:23 <shapr> heatsink: Ok, I must be confused, sorry.
16:00:27 <heatsink> sok
16:00:38 <vixey> what's SST
16:00:47 <shapr> vixey: It's a tremulous server.
16:00:58 <vixey> oh
16:01:10 <heatsink> what's a tremulous server?
16:01:16 <shapr> Tremulous is an open source game.
16:01:21 <heatsink> oh
16:01:41 <jadrian> vixey: I'll have to give this some thought as even the first definition is still not clear to me... are you using GADTs?
16:01:59 <shapr> heatsink: Ah, I was confused.. Echo Nolan is someone else entirely.
16:02:06 * shapr feels silly.
16:02:14 <jadrian> vixey: that's the only situation in which I've seen data ... _where_ instead if data ... =
16:02:32 <shapr> Kattana: Are you learning Haskell?
16:03:55 * heatsink posts a "Have you seen this man?" picture of Echo Nolan on the wall
16:04:02 <jadrian> vixey: but what just doesn't feel right is that it seems like quite a generalization (sort of a restriciton on the number of possible cells, via types) when the only thing I need is an empty type
16:04:07 <shapr> heatsink: hellish is Echo Nolan.
16:04:31 <jadrian> vixey: which is a much smaller requirement... and feels like it should be easier to do
16:05:12 <vixey> what's this checking for DocBook DTD...  thing in GHC ./configure?
16:05:16 <vixey> It hangs for me
16:05:16 <EvilTerran> jadrian, data...where... is the -XGADTs extension
16:05:27 <vixey> oh wait it got past it
16:05:53 <jadrian> EvilTerran: yeap that's what I thought, haven't used them yet, just read the examples in the man
16:06:28 <shapr> Crap, where can I get a copy of polyparse?
16:06:41 <ddarius> @where polyparse
16:06:41 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
16:06:44 <shapr> aha!
16:06:48 <shapr> too easy
16:07:13 <shapr> ddarius++
16:07:21 <shapr> edwardk++
16:07:58 <ddarius> I know someone(s) on this channel is into NLP, when are we going to have a natural language query interface for lambdabot?
16:10:23 <LordBrain> why does haddock ignore functions which are foriegn exports ?
16:10:29 <BMeph> I can't see the part of the topic where it talks about the server shift, unless I make the window so wide, that most of it is off the screen. :P
16:10:31 <LordBrain> or how do i get it to stop doing that
16:11:24 <BMeph> LordBrain: Because foreigners are suspicious? ;)
16:12:38 <LordBrain> that will be funnier later
16:12:42 <LordBrain> maybe
16:13:37 <BMeph> ET: GADT's are discussed in 8,4,6 of the GHC manual. I haven't looked for the online ref, though. :)
16:15:57 <BMeph> EvilTerran, jadrian: Someone asked about GADTs? http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt is the online reference.
16:15:59 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
16:16:03 <vixey> I want to make a logic language based on allegories
16:16:16 <vixey> but I would like to have dependent products in it somehow :S
16:16:24 <vixey> I think the bits don't fit together
16:16:41 <shapr> vixey: Try it?
16:16:48 <jadrian> I always forget, what is the difference between   newtype a = C a  and data a = C ! a
16:16:53 <dcoutts> ertai: there's an internal undocumented cabal install --only
16:17:08 <EvilTerran> @Where newtype
16:17:08 <lambdabot> I know nothing about newtype.
16:17:18 <EvilTerran> @wiki newtype
16:17:18 <lambdabot> http://www.haskell.org/haskellwiki/newtype
16:17:23 <shapr> dcoutts: Are you scrolled back?
16:17:37 <dcoutts> shapr: yo
16:17:40 <shapr> y0 y0
16:17:43 <shapr> w4ssup?
16:17:47 <jadrian> thanks EvilTerran
16:17:47 <dcoutts> @arr!
16:17:48 <lambdabot> Aye
16:18:15 <dcoutts> shapr: you know, just writing my phd, doing a bit of hacking, that kind of thing
16:18:32 <shapr> dcoutts: Sounds like fun... any new peval code to see?
16:18:37 * dcoutts will skip off on holiday for a week and a half
16:18:47 <shapr> dcoutts: Are you going to Iceland also?
16:18:51 <dcoutts> shapr: I switched topic a couple years ago. I've been doing stream fusion
16:18:54 <shapr> Ah
16:19:24 <dcoutts> shapr: no, just camping with a big group of friends. I'll be sleeping under a tarp for a week and I'll come back smelling of woodsmoke
16:19:46 <shapr> Sounsd like fun.
16:20:15 <BMeph> Heh-heh, "Now, dcoutts comes in mesquite-flavor!" 8D
16:20:36 <EvilTerran> dcoutts, oo, sounds like fun
16:20:37 <levi13> hi, I'm having my first go at profiling/performance stuff with haskell
16:20:38 <dcoutts> BMeph: heh, right
16:20:42 * EvilTerran does that sort of thing
16:20:58 <levi13> I have some uvector code that's only performing as well as lists though. Any tips?
16:21:01 <dcoutts> EvilTerran: yeah, I eschew tents these days
16:21:17 <dcoutts> though I might bring a mosquito net as my luxury
16:21:17 <lumi> Can elements in a Data.Map map depend on other elements?
16:21:24 <EvilTerran> well, i usually go for a tent, but i mean the whole setting up in the great outdoors thing
16:21:55 <dcoutts> lumi: yes, because maps are lazy in their values
16:22:19 <dcoutts> lumi: so you can make recursive maps, just like you can with lazy arrays
16:22:46 <lumi> dcoutts: Cool, thanks :)
16:22:53 * lumi tries it out
16:22:56 <shapr> @seen malcolmw
16:22:56 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 6h 52m 22s ago, and .
16:23:58 <shapr> @tell malcolmw HaXml dev page links to HaXml 1.19.3, but the link is broken since 1.19.4 is the latest version.
16:23:58 <lambdabot> Consider it noted.
16:24:45 * BMeph imagines what a system done in a mix of Haskell and Lua would look like...
16:25:30 <ddarius> @google metalua
16:25:31 <lambdabot> http://metalua.luaforge.net/
16:25:31 <lambdabot> Title: Metalua
16:26:02 * shapr builds HaXml 1.19.4
16:26:35 <vixey> a binary and a bunch of script files ... ?
16:26:44 <vixey> I don't know it would probably be like any old program that uses lua
16:26:53 * vixey builds GHC..
16:32:49 <shapr> wheee!
16:33:00 <shapr> haskell-xmpp builds, now to get it to talk to ejabberd
16:33:44 <vixey> twiddle (x:xs) ys = x : (twiddle ys xs)
16:34:12 * edwardk mostly just builds category-extras
16:34:13 <zeno__> is there a quicker way than round (sqrt x) assuming it will always produce an integer?
16:35:12 <idnar> > let twiddle (x:xs) ys = x : (twiddle ys xs) in twiddle [1..10] [100..110]
16:35:12 <EvilTerran> you can do a O(log(sqrt x)) search yourself
16:35:13 <lambdabot>   Non-exhaustive patterns in function twiddle
16:35:25 <vixey> > let twiddle (x:xs) ys = x : (twiddle ys xs) in twiddle [1..] [100..]
16:35:27 <lambdabot>  [1,100,2,101,3,102,4,103,5,104,6,105,7,106,8,107,9,108,10,109,11,110,12,111,...
16:35:44 <idnar> @type intersperse
16:35:45 <lambdabot> forall a. a -> [a] -> [a]
16:35:57 <idnar> hmm, no
16:37:28 <rwbarton> > join $ transpose [[1..], [100..]]
16:37:30 <lambdabot>  [1,100,2,101,3,102,4,103,5,104,6,105,7,106,8,107,9,108,10,109,11,110,12,111,...
16:37:52 <jadrian> I have over 19.000 unread messages on Haskell-Cafe
16:37:53 <jadrian> :D
16:38:10 <jadrian> There was a time when I actually followed the mailling list
16:38:19 <jadrian> and read almost every single message...
16:38:20 <jadrian> :S
16:38:20 <nowhea> vixey: i'd love a tutorial on functional datastructures, okasaki light...
16:38:31 <jadrian> I don't think I'll catch up any time soon
16:39:40 <vixey> nowhea: sorry, I couldn't write much about that I don't know about datastructures
16:39:48 <desp> How would you represent a rectangular grid without knowing its boundaries?
16:40:05 <desp> shapr: are you perhaps working on a XMPP gateway?
16:40:37 <rizzix> A 4-way linked list :o
16:40:51 <vixey> how come ghci is weird
16:41:01 <vixey> delete is inserting \DEL characters
16:41:06 <vixey> ^C and ^D don't do anything..
16:41:14 <vixey> but it said it compiled with readline
16:41:23 <desp> rizzix: yeah, but in Haskell? ;)
16:41:38 <vixey> desp: what's in the grid?
16:41:59 <desp> vixey: nothing; the interesting thing is the connections between the grid cells.
16:42:01 <vixey> desp: how about [(Integer,Integer,Value)], the initial grid could be []
16:43:09 <desp> Uh.
16:43:28 <vixey> 'Uh."?
16:44:30 <desp> Finding out whether there's a connection between adjacent cells should be O(1).
16:44:56 <vixey> well you never said anything about that ....
16:44:59 <shapr> g'day seafood
16:45:18 <desp> vixey: isn't that obvious?
16:45:25 <seafood> shapr: How are you good sir ! :-)
16:45:38 <vixey> desp: no, Infact I can't read your mind
16:45:58 <shapr> seafood: Doing well, how are you?
16:47:57 <BMeph> jadrian: I was the same way with the Lua list. :)
16:49:18 <BMeph> ddesp: Sounds very "ZigZag"-esque... ;)
16:49:53 <desp> BMeph: I'm not actually hoping for a complete solution, just for a nudge in the right direction.
16:50:03 <BMeph> desp: Heh-heh. :)
16:50:08 <desp> In C I'd fake this with an array that's a few times too large.
16:51:57 <BMeph> desp: I'm very weak in haskell-fu, but I might try a pair of Data.Maps, with negward and posward, respectively. That's just me, and I have no hope of evaluating how suitable it'd be.
16:51:59 <heatsink> desp: Is this actually an unbounded array, or a small section of a bounded array?  Is it mutable?
16:52:23 <heatsink> *or a bounded array?
16:53:09 <BMeph> heatsink: If it is what I think it is (and desp seemed to imply so), then it's unbounded and mutable all over the place.
16:53:12 <desp> heatsink: a section of a bounded array; the connections between cells should start at Maybe and be mutable into Yes/No.
16:53:46 <desp> BMeph: the array actually has a defined size, but I need to start filling the connections from a point that has an unknown location.
16:53:51 <codacola> http://www.youtube.com/watch?v=J5LNTTGDKYo&feature=related
16:53:52 <lambdabot> Title: YouTube - Write in C
16:54:16 <BMeph> desp: Okay, so what's the size of the array repressent?
16:54:26 <desp> BMeph: pardon?
16:54:31 <heatsink> desp: By mutable, I mean whether the array is resizable and/or its contents can be changed.
16:55:52 <desp> heatsink: no, the size of the array doesn't change.  There actually are no contents; the only interesting thing about the array are the connections.
16:56:00 <BMeph> desp: You said, "the array actually has a defined size," implying that there is a reason that it is the size it is, i.e., the size of the array represents a particular value.
16:56:14 <desp> So a 4-way linked list would be good for this, but how to write one in Haskell?
16:56:17 <heatsink> desp: In that case, a 4-way linked list should do fine.
16:56:32 <vixey> use a graph
16:56:50 <heatsink> type MFourList = Maybe FourList
16:56:59 <heatsink> data FourList = FourList MFourList MFourList MFourList MFourList
16:58:32 <heatsink> desp: Do you see how that works as a 4-way linked list?
16:59:38 <desp> Yeah. I can't believe I didn't see this earlier. ;)
16:59:44 <desp> Thanks.
17:00:04 <heatsink> u welcome.
17:00:17 <sutats> Is there any documentation on how to use uvector?
17:00:18 <heatsink> You could actually get rid of the maybe and have FourCons ... | FourNil.
17:01:56 <nus> @src []
17:01:57 <lambdabot> data [] a = [] | a : [a]
17:02:37 <bd_> nus: note that due to the slightly special nature of [], it can't be implemented using normal haskell (ie, the compiler does it in some magical way :)
17:02:42 <vixey> I don't see how you can do anything with FourList
17:02:56 <bd_> nus: by special, I mean syntax-wise
17:04:43 <nus> @src null
17:04:43 <lambdabot> null []     = True
17:04:43 <lambdabot> null (_:_)  = False
17:04:46 <heatsink> vixey: It's a specialized graph data type.  Given a FourList, you can figure out what neighbors it has (check whether the fields are Just or Nothing), and look at its neighbors.
17:06:23 <proq> does anyone know why "let x = 1" works with ghci but not with hugs? (on hugs it gives the error Syntax error in expression (unexpected end of input)
17:06:25 <rwbarton> heatsink: but you can't, say, determine the number of vertices in the graph, nor form a new graph by adding a vertex
17:07:27 <heatsink> rwbarton: You can determine the number of vertices in the graph because you know a priori that they form a mesh shape.
17:07:53 <vixey> it's very hard to program
17:08:20 <heatsink> It's not a particularly useful data structure, granted, since the only information you can get out of a FourList is an array size and a position, which you could have represented with four ints.
17:08:48 <rwbarton> heatsink: Well, yes that is true.
17:11:04 <MyCatVerbs> proq: the REPLs are less powerful than the proper programming language, unfortunately.
17:11:34 <desp> proq: IIRC, you can just write "x = 1" in Hugs...
17:12:02 <MyCatVerbs> proq: GHCi is slightly more powerful than Hugs in interactive mode. Both are much less powerful than either Hugs or GHC when used to bludgeon source files into submission.
17:12:08 <opqdonut> proq: ghci works as if you were inside a do-block in the IO monad
17:12:11 <opqdonut> dunno about Hugs
17:12:47 <opqdonut> the thing I miss in the repls is the ability to define data structures
17:12:47 <heatsink> opqdonut: We're all inside do-blocks in the IO monad if you think about it.
17:12:53 <opqdonut> and also to dump all custom definitions
17:12:57 <opqdonut> heatsink: :D
17:13:10 <opqdonut> it's the matrix
17:13:14 <nus> rebinding a CAF safely seems to be a problem, from what I gather
17:14:27 <proq> hugs will let me get by with let x = 1 in x
17:14:31 <pjdelport> @remember heatsink opqdonut: We're all inside do-blocks in the IO monad if you think about it.
17:14:32 <lambdabot> Good to know.
17:14:40 <vixey> @quote
17:14:40 <lambdabot> SeanRussell says: [Seen on the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
17:14:40 <lambdabot> Haskell.
17:14:50 <vixey> @quote
17:14:50 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
17:14:51 <rwbarton> proq: yes, that's an expression like any other
17:15:18 <mrd> smell as sweet?
17:15:34 <proq> a nose by any other name...
17:15:37 <vixey> @quote
17:15:37 <lambdabot> weitzman says: The Prelude needs verse numbers to use when quoting it.
17:16:28 <opqdonut> heh
17:18:30 <vixey> How do I make delete and ^C and ^D work in ghci?
17:18:40 <opqdonut> compile it with readline support
17:18:54 <vixey> how?
17:19:08 <rwbarton> which version?
17:19:14 <vixey> 6.8.3
17:19:44 <rwbarton> (just checking because readline was/will be replaced by something else in 6.9)
17:19:49 <opqdonut> rwbarton: oh
17:19:53 <opqdonut> something custom?
17:19:58 <rwbarton> editline, I think
17:20:08 <vixey> oh I can install 6.9 now?
17:20:32 <vixey> I would much rather do that
17:20:41 <vixey> http://www.haskell.org/ghc/dist/current/dist/ghc-6.9.20080615-src.tar.bz2
17:20:42 <lambdabot> http://tinyurl.com/66ukn7
17:20:45 <vixey> i that the thing to get?
17:20:56 <rwbarton> Yes.
17:21:05 <rwbarton> If ./configure fails for you, delete utils/pwd/pwd and try again
17:21:30 <rwbarton> I mean, that's just some recent snapshot release.  I haven't tested that particular version at all
17:22:10 <rwbarton> I probably shouldn't call it a release.  More "it is possible to download it" :)
17:22:57 <pjdelport> desp: have you looked at hashfile?
17:23:02 <pjdelport> hashlife, even
17:23:06 <pjdelport> http://dotat.at/prog/life/hslife.hs
17:24:48 <desp> pjdelport: hmm, thanks.
17:25:28 <pjdelport> desp: the specifics might not be relevant, but it also uses a quad tree to represent an unbounded grid
17:25:35 <desp> Yeah.
17:25:58 <desp> It's quite interesting in its own right.
17:36:27 <nus> @hoogle CLabel
17:36:27 <lambdabot> No matches found
17:55:38 <codacola> what does "missing binding" mean in haskell errors?
17:57:50 <rwbarton> I think it might mean you wrote a type signature for a function but didn't define it?
17:58:33 <rwbarton> But usually I don't read error messages too carefully, I just look at the line number reported, so I don't know what various messages mean without looking at the source.
18:00:22 <codacola> rwbarton, heh i do that in C as well, but error messages are nice when youre learning a new language (and moreso when its completely different to what you alreayd know)
18:01:08 <codacola> oh i see, thanks you were right. the names were different (i used I instead of i)
18:04:00 <rwbarton> GHC's error messages can be obscure, so you may want to keep track of what kind of human errors cause what kind of compiler errors as you learn :)
18:04:16 * codacola is using hugs
18:05:02 <codacola> but yeah, i get your point :P
18:07:16 <codacola> curious, why do they say haskell will require less debugging than other languages?
18:07:18 <codacola> just hype?
18:07:29 <augustss> no
18:07:41 <augustss> that's my experience
18:07:41 <vixey> codacole: it's actually true for most people
18:08:04 <ddarius> You can actually make more objective reasons for why that is true.
18:09:39 <mar77a> what's the difference between ap and liftM?
18:09:50 <ddarius> :t ap
18:09:51 <ddarius> :t liftM
18:09:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:09:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:10:01 <mar77a> doesn't say much
18:10:07 <ddarius> Yes it does.
18:10:28 <ddarius> :t ap . return
18:10:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
18:10:30 <mar77a> to me
18:10:58 <rwbarton> @pl ap . return
18:10:59 <lambdabot> fmap
18:11:03 <rwbarton> @pl liftM
18:11:03 <lambdabot> fmap
18:12:08 <mar77a> so ap is like liftM but it injects the result?
18:12:12 <mar77a> or doesn't
18:12:50 <ddarius> mar77a: What is the difference between their types?  Just syntactically, what is the difference?
18:13:03 <mar77a> that m
18:13:11 <codacola> this chapter is quite cute. all of the exercises are based on an ascii picture. the picture is defined by a [[char]]
18:15:29 <nus> :t return
18:15:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:30:04 <vixey> yay
18:30:10 <vixey> thank you rwbarton++
18:30:31 <rwbarton> ah
18:30:34 <rwbarton> welcome :)
18:30:39 <rwbarton> Does editline work for you?
18:30:59 <vixey> assuming this uses editline, yes
18:37:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8592
18:37:17 <codacola> wow thats ugly :P
18:39:03 <mar77a> http://www.haskell.org/haskellwiki/From_a_newbie_II =)
18:39:04 <lambdabot> Title: From a newbie II - HaskellWiki
18:41:27 <mjk> why i can't arrive to http://hackage.haskell.org/?
18:44:42 <dons> mjk: the servers have moved to a new location, back up soon. see /topic
18:46:35 <mjk> dons: so that's it.
18:46:59 <mjk> how long time it's can be visit?
18:52:26 <desp> Is there a shorter way to write ('A' : 'B' : 'C' : str) ?
18:52:33 <bd_> desp: "ABC"++str ?
18:52:41 <desp> bd_: as a pattern match?
18:52:52 <bd_> oh, I don't think so :)
18:53:03 <desp> OK. :)
18:53:07 <bd_> (unfortunately?)
18:53:41 <desp> I guess I'll just omit the spaces. ;)
18:55:43 * rwbarton is tempted to suggest quasiquotating, but does not
18:56:15 <rwbarton> quasiquoting even
18:58:23 <bd_> rwbarton: would it help here?
18:58:56 <rwbarton> It would help if the string "ABC" was sufficiently long...
19:00:15 <rwbarton> You could write a quasiquoter s that turns [$s|"ABC"++str] into ('A':'B':'C':str), if you wanted
19:00:30 <rwbarton> [$s|"ABC"++str|] I mean
19:01:37 <MyCatVerbs> vixey: ldd the executable if you want to find out for sure whether or not it's linked against editline.
19:01:45 <rwbarton> (as either an expression or a pattern)
19:02:00 <MyCatVerbs> rwbarton: is that TH?
19:02:19 <dolio> @where blas
19:02:19 <lambdabot> I know nothing about blas.
19:03:03 <cmarcelo> rwbarton: how quasiquoting relates to things like shell variable expansion, like "lalala $VAR"... $VAR there acts like a "metavariable" here, or not? am I missing something important distinction? (I've just read the wikipedia article and I'm a bit curious)
19:03:16 <rwbarton> It is a new feature of ghc 6.9 that is closely related to TH, yes.  I'm not sure I could tell you the exact relationship between them
19:05:49 <dons> http://www.reddit.com/info/6pc7f/comments/
19:05:49 <lambdabot> Title: reddit.com: Haskell introduction: countdown words game solver
19:05:50 <rwbarton> cmarcelo: it's kind of like that, though whether any kind of interpolation occurs is totally up to the quasiquoter author
19:06:09 <dolio> Quasiquoting is like TH for which you can write your own parser.
19:06:11 <dolio> Sort of.
19:06:15 <dons> dolio: blas is a hackage lib :)
19:06:29 <dolio> I know. I think I found the darcs repo, though.
19:06:45 <dolio> I'm going to find out why that guy's program is so slow.
19:06:59 <dolio> Probably because he's constructing a 10-million element list that isn't being fused, among other things.
19:07:01 <MyCatVerbs> dolio: hang on, whut? BLAS is a set of standard mathematical subroutines with crazy naming conventions.
19:07:07 <cmarcelo> hm.. and by what I see, there's also the pattern matching feature.. "lalala" can be some structure, and $VAR could contain some structure in the example.. I guess string interpolation misses this.
19:07:15 <MyCatVerbs> Er, dons, not dolio, sorry.
19:09:06 <dons> dolio: it's all on the C side, really, so whatever his issue is , i bet its trivial
19:09:23 <dons> either improving the haskell-side representation of the foreign arrays (i.e. strict fields for the length)
19:09:30 <dons> or not using mapM_ or foldM for loops
19:09:42 <rwbarton> cmarcelo: Like dolio said, quasiquoting is basically the ability to define your own literal syntax for (part of) a haskell program.  Often, you may want to include some way to embed the usual Haskell syntax into yours, hence the name "quasiquotation".
19:09:55 <dons> dolio: the hmatrix library's very fast for the same kind of thing, and uses the same library underneath
19:10:37 <MyCatVerbs> dons: isn't converting to and from the matrix formats that hmatrix uses somewhat expensive?
19:11:32 <dons> no? any expense is on the C side
19:11:43 <dons> e.g. changing row/column forms is just flipping two ints around
19:12:00 <dolio> dons: Well, for instance, he's got "foldM (\ ii zz -> do rv <- v1 `getDot` v2 ; return $ zz + rv) 0.0 [0..times]" which takes 2 seconds here even when I turn it into "\ii zz -> return zz".
19:12:13 <dolio> times is 10 million.
19:12:56 <dons> i'd doubt foldM is carefully written
19:12:58 <dons> ?src foldM
19:12:58 <lambdabot> foldM _ a []     = return a
19:12:58 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
19:12:59 <dolio> No unboxing, 'cause it's lazy, too.
19:13:05 <dolio> The addition, that is.
19:13:09 <dons> well, doesn't look too bad, but the iO will interfere.
19:13:14 <dons> right.
19:13:32 <dons> when will people's learn to use recursion first, then try hofs
19:13:41 <dons> before complaining about "haskell performance" in general
19:14:08 <dolio> Heh, probably when people stop telling them to just use higher order functions because it's the Haskell way. :)
19:14:22 <dons> higher order, lazy, monadic folds!
19:14:40 <dons> ah well, nothing like not knowing what your code is really doing  :)
19:15:20 <dolio> @where storable-complex
19:15:21 <lambdabot> I know nothing about storable-complex.
19:16:26 <dolio> I should just switch to Arch, apparently. Then I'd have all this.
19:17:39 <roconnor> what's wrong with hofs?
19:17:52 <dolio> GHC isn't MLTon yet.
19:17:52 <roconnor> what is going on here?
19:18:14 <roconnor> why not?
19:18:14 <ddarius> roconnor: The problem isn't HOFs, the problem is people not knowing/understanding what their code is doing.
19:18:49 <roconnor> ddarius: It's the opposite.  HOFs allow people to reason about their programs.
19:19:14 <dolio> It allows them to reason about what it does, not what machine code it turns into.
19:19:53 <roconnor> right, that's what is important.
19:19:57 <ddarius> roconnor: I'm not talking about semantically, I'm talking about implementationally.
19:20:12 <ddarius> roconnor: Yes, that is why there isn't a problem with the HOFs.
19:20:20 <dons> fold's are fine, but lazy monadic folds, you'd want to check what they compile to if you're chasing C.
19:20:29 <roconnor> why are we chasing C?
19:20:46 <roconnor> that's GHC's job
19:21:19 <ddarius> roconnor: As I said, HOFs aren't a problem, understanding is.  If you understand what a HOF does, at a low and high level (or at least the relevant level) then you are in a position to determine whether to use one or not.
19:21:32 <dolio> Can we use your time machine to get the future version of GHC that runs this guy's program not 250x slower than C?
19:21:32 <ddarius> (Or what one to write if existing ones are inappropriate.)
19:22:04 <roconnor> dolio: if it is too slow, he should write it in C and use the ffi.
19:22:23 <roconnor> hmm
19:22:32 <rwbarton> To be fair, the C program that was 250 times faster was also buggy: it did nothing.
19:22:35 <dons> this is basic stuff.
19:22:42 <dolio> If what is too slow? His particular program?
19:22:44 <dons> he wrote a for loop, he wrote a foldM. one was 10x slower.
19:22:50 <dolio> What if we can tweak the haskell to be acceptable?
19:23:04 <dons> its trivial, using recursion, to wipe out the difference.
19:23:27 <dolio> I seem to have been defeated by storable-complex.
19:23:38 <roconnor> that's disturbing
19:24:12 <dolio> Anyone know off hand if it exists outside of hackage?
19:24:16 <ddarius> roconnor: It would be disturbing if it was using the exact same code, just explicitly.  That is not what is happening.
19:24:19 <dons> foldM is a lazy monadic thing. its has quite different semantics to the for loop he thought it was.
19:24:36 <dons> if he wrote something that actually was a for loop, and it wasn't the same speed, we'd have a bug report.
19:24:38 <roconnor> dons: what monad are we talking about?
19:24:39 <dons> but no, we don't.
19:24:45 <dolio> IO
19:25:28 <SamB> dons: what kind of list ?
19:25:49 * roconnor is confused by dons explaination
19:26:45 <roconnor> foldM is defined recursively
19:26:48 <roconnor> what's the diff?
19:27:21 <ddarius> roconnor: foldM is a different function than what he wants.
19:27:24 <roconnor> (semantically)
19:28:09 <ddarius> roconnor: No compiler claims to take any "semantically" identical code and produce the same assembly output.
19:28:44 <SamB> @src foldM
19:28:44 <lambdabot> foldM _ a []     = return a
19:28:44 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
19:29:32 <roconnor> ddarius: sure, I don't know what we are comapring things to, but I imagine the other function looks almost intensionally the same.
19:29:36 <dons> foldM is a lazy fold. too easy to screw up.
19:29:43 <dons> consider,
19:29:44 <dons>  do d <- foldM (\a b -> return (a + b)) 0 [1..(10^9::Double)]
19:29:47 <dons>     let d = foldl' (\a b -> a + b) 0 [1..(10^9::Double)]
19:29:53 <dons> which one unboxes its accumulator?
19:30:06 <dons> the first has type,
19:30:07 <dons> M.a :: (Double -> Double -> IO Double) -> Double -> [Double] -> State# RealWorld -> (# State# RealWorld, Double #)
19:30:14 <SamB> it looks like foldM is a foldr
19:30:16 <dons> the second,
19:30:17 <dons> M.$wlgo :: Double# -> [Double] -> Double#
19:30:24 <SamB> ... why the heck is it not defined as such?
19:30:43 <roconnor> oh, so wer are talking about foldr vs foldl
19:30:45 <SamB> this one is too hard to read!
19:31:15 <TomMD> Ha!  Look at the top city searching for "haskell":  http://www.google.com/trends?q=haskell&ctab=0&geo=all&date=all&sort=0
19:31:15 <TomMD> Blame Andy.
19:31:15 <dons> omg, wildly different performance characteristics. *and* i'm using lazy lists in one language.
19:31:16 <lambdabot> Title: Google Trends: haskell, http://tinyurl.com/69cmte
19:31:54 <roconnor> dons: is the "recursive" we are comparing foldM to version tail recursive?
19:31:57 <dons> and consider,
19:31:59 <SamB> dons: you are aware that lazy lists are almost exactly the same thing as for loops?
19:32:07 <dons>     let d = foldlU (\a b -> a + b) 0 (enumFromToFracU 1 (10^9::Double))
19:32:12 <dons> SamB: think again.
19:32:19 <SamB> dons: they are
19:32:28 <dons>     $wfold_s197 :: Double# -> Double# -> Double#
19:32:30 <mar77a> http://www.google.com/trends?q=c%2B%2B%2Chaskell
19:32:31 <lambdabot> Title: Google Trends: c++,haskell
19:32:31 <mar77a> almost
19:32:35 <SamB> except that pesky fact that you can backtrack...
19:32:37 <roconnor> so we are simply talking about foldr vs foldl?
19:32:41 <dons> SamB: start again.
19:32:44 <solrize> Haskell women roll, 75-63   is that about Philippa and audreyt?
19:33:06 <SamB> dons: there's this paper, see...
19:33:08 <dons> roconnor: well, i'm talking about the wildly different runtime representations.
19:33:26 <SamB> Lists to Streams to Nothing at All...
19:33:32 <TomMD> solrize: Yes, I know, I just find it funny that it coincides with the location of a top Haskeller.
19:33:38 <SamB> ring a bell?
19:33:44 <dons> SamB: you're not being helpful.
19:34:16 <roconnor> dons: I'm confused because you keep using associative functions.
19:34:47 <dons> my single point is that foldM is a far more complicated loop. not knowing this is a problem.
19:35:39 <roconnor> foldM is more complicated than a pure function?
19:36:15 <SamB> foldM is not a complicated loop
19:36:15 <dons> the other side of the coin is unrealistic expectations that any junk people through at the compiler is identical to a 'for' loop. reliance on sufficiently smart compilers without care or respect for the transformations involved is dangerous and naive
19:36:34 <SamB> the problem is that it's a foldr, afaict.
19:36:41 <dons> ok fine. go write some fast code with it.
19:37:00 <SamB> have you ever seen a fast foldr?
19:37:02 <rwbarton> I'm pretty sure it's a foldl, no?
19:37:22 <roconnor> > foldr (^) 1 [1..4]
19:37:24 <lambdabot>  1
19:37:27 <bd_> SamB: foldr (:) []
19:37:28 <bd_> ?
19:37:28 <roconnor> > foldl (^) 1 [1..4]
19:37:29 <lambdabot>  1
19:37:34 <roconnor> > foldl (^) 2 [2..4]
19:37:36 <lambdabot>  16777216
19:37:40 <roconnor> > foldr (^) 2 [2..4]
19:37:52 <lambdabot> Terminated
19:37:54 <dons> foldM _ a []      =  return a
19:37:54 <dons> foldM f a (x:xs)  =  f a x >>= \fax -> foldM f fax xs
19:37:54 <ddarius> bd_: foldr (:) [] is a rather wasteful and slow way of writing id.
19:37:55 <SamB> bd_: you can't call it "fast" if it doesn't need to be evaluated at runtime ;-P
19:37:57 <roconnor> > foldr (^) 2 [2..3]
19:37:59 <lambdabot>  512
19:38:03 <roconnor> > foldl (^) 2 [2..3]
19:38:04 <lambdabot>  64
19:38:05 <SamB> or did you just mean id
19:38:25 <roconnor> > runIdentity $ foldM (^) 2 [2..3]
19:38:26 <lambdabot>      Occurs check: cannot construct the infinite type: a = Identity a
19:38:26 <lambdabot>       E...
19:38:38 <roconnor> @type foldM
19:38:40 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:38:42 <bd_> SamB: Well, I mean, it's not like it needs to traverse the entire list to evaluate the outer cons
19:38:45 <ddarius> foldM is obvious a monadic left fold.
19:38:57 <roconnor> > runIdentity $ foldM (\x y -> return (x^y)) 2 [2..3]
19:38:58 <lambdabot>  64
19:39:09 <SamB> dons: oh, damn lambda
19:39:20 <roconnor> dons: does runIdentity $ foldM run as fast as foldl?
19:39:21 <SamB> forgot that you can't substitute under them :-(
19:39:30 <SamB> pretty silly, huh?
19:40:05 <roconnor> okay, so it isn't a foldl vs foldr problem.
19:40:28 <roconnor> I'm not sure what the recursive version we are comparing foldM to is.
19:40:49 <roconnor> dons compared foldM to a bunch of pure functions, which didn't make any sense to me.
19:41:11 <ddarius> roconnor: The kind of issues are: the compiler can't see through through the monadic binds to do things like strictness analysis.
19:41:30 <SamB> oh
19:41:31 <roconnor> ddarius: binds are inlined
19:41:40 <roconnor> what's the problem?
19:41:43 <SamB> so the problem is that the compiler doesn't specialize foldM for IO ?
19:41:48 <SamB> or what?
19:42:10 <ddarius> roconnor: The problem is the semantics of IO mean it's very difficult to verify if a value will be forced.
19:42:18 <ddarius> An IOError (or something else) could happen at any time.
19:42:44 <roconnor> so, what, we are talking about someone using IO for something that doesn't involve IO?
19:42:47 <ddarius> Also, I don't believe the lazy list will fuse.
19:43:03 <dons> i will not fuse. there is no 'foldr' anywhere here.
19:43:36 <ddarius> roconnor: No, I'm saying -you- know what you want with regards to strictness.  The compiler can't read your mind and won't change your code's semantics.
19:43:58 <SamB> yeah, dons and dcoutts have been slacking so we still have this lame foldr/build fusion ;-P
19:44:01 * SamB is kidding, btw
19:44:17 <dolio> There's stream fusion on hackage. Oh wait...
19:44:22 <ddarius> So this foldM use involves constructing a lazy list, traversing it, and building thunks for the intermediate sums.
19:44:23 <dons> we get much better code from
19:44:25 <dolio> :)
19:44:25 <roconnor> ddarius: why can it read my mind when I write a recursive function? (not that I know what the recursive function is)
19:44:29 <dons> foldM             :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:44:29 <dons> foldM f a xs = go a xs
19:44:29 <dons>     where
19:44:29 <dons>         go !a []     = return a
19:44:29 <dons>         go !a (x:xs) = f a x >>= \z -> go z xs
19:44:30 <ddarius> This is what is being compared to a C for loop.
19:44:43 <ddarius> roconnor: It can't, but you can -say- what you mean.
19:44:45 <dons> unsurprisingly. inlinable, specialised on 'f', then strictness analysis works out.
19:44:55 <dons> and you get the same loop as the manual versions.
19:44:58 <ddarius> roconnor: As I said at the start, the function he was using is -not- the function he wanted.
19:45:17 <dons> so foldM' might be useful in some circumstances.
19:45:52 <dons> still not perfect code, due to nested CPR not able to fire, and list enumeration not fusing.
19:45:56 <roconnor> ddarius: dons said we should use recursion rather than HOFs.  I found and still find that hard to believe.
19:46:26 <dons> roconnor: as a predicable, reliable way to generate identical code to a for loop, and as a tool for teaching people how things work, recursive loops still rule.
19:46:26 <dolio> If you want good code to be generated, today, that's probably true in this case.
19:46:38 <ddarius> [21:13] <dons> when will people's learn to use recursion first, then try hofs
19:46:38 <ddarius> [21:13] <dons> before complaining about "haskell performance" in general
19:47:10 <dons> otherwise you need to understand what loop your fold is actually generating, how its state components are analysed and propragated, any defaulting, any fusion that takes place.
19:47:24 <dons> esp. if you've already written a manually fused, unboxed for loop in c.
19:47:24 <solrize> it's counterintuitive, i would have thought the implementations for the standard hofs would be tuned much better than naively coded recursion
19:47:28 <ddarius> roconnor: As I said: [21:21] <ddarius> roconnor: As I said, HOFs aren't a problem, understanding is.  If you understand what a HOF does, at a low and high level (or at least the relevant level) then you are in a position to determine whether to use one or not.
19:47:28 <ddarius> [21:21] <ddarius> (Or what one to write if existing ones are inappropriate.)
19:47:35 <dons> solrize: tuned? there's nothing to tune.
19:47:41 <dons> in the limit they yield the same code.
19:48:10 <dons> if you've a fusion system, pipelines will yield the same code as manually fused recursion, at less cost.
19:48:11 <SamB> dons: the limit as what ?
19:48:24 <roconnor> ddarius: I'm having some serious understanding issues then.
19:48:28 <roconnor> "foldM (\ ii zz -> do rv <- v1 `getDot` v2 ; return $ zz + rv) 0.0 [0..times]" this is the foldM code
19:48:35 <roconnor> what is the good "recursive" code?
19:48:35 <dolio> One would think that foldM would look something like the definition dons gave above.
19:48:38 <dons> the limit of optimisation. assuming everything works, you'll end up with the same core as the recursive version gets first time around.
19:48:50 <dolio> Since they've done it to foldr/foldl...
19:48:52 <ddarius> roconnor: Code that doesn't build a list, code that forces the sum as it goes.
19:48:56 <dons> dolio: yeah.
19:49:05 <dons> at least make it inlinable, so strictness analysis has a chance.
19:49:15 <dons> then the bangs won't be needed,  i suspect ... checking...
19:49:21 <SamB> dons: "as what" meaning "what do I need to do to the parameters to get closer"
19:49:36 <SamB> i.e. what goes under the
19:49:39 <SamB> \lim
19:49:50 <dolio> roconnor: go k m !zz | k <= m = do rv <- v1 `getDot` v2 ; go (k+1) m (zz + rv) | otherwise = return zz
19:49:54 <ddarius> roconnor: There's no problem with writing a HOF that -does that- and using -that HOF-, but that HOF is a -different- function.
19:49:54 <dolio> Or something of the sort.
19:50:07 <dolio> roconnor: Call with 'go 0 times 0.0'
19:50:13 <roconnor> ddarius: good
19:50:25 <adu> hi
19:50:45 <SamB> you know ...
19:50:50 <adu> I'm getting more linking errors
19:51:15 <adu> How do I specify that a haskell library must be linked with a c library from a Cabal file?
19:51:33 <adu> or do I have to use a Makefile
19:51:35 <dons> adu: extra-libraries: openssl
19:51:57 <SamB> hmm, nevermind...
19:52:08 <dons> or whatever your C library is. *no*, you don't need a Makefile, C dependencies are easy to describe and use from .cabal files
19:52:38 <SamB> this has not always been the case ;-)
19:52:59 <SamB> previously, you'd have had to add an -l flag in the cabal file ;-P
19:53:11 <adu> ok
19:54:07 <roconnor> dolio, ddarius: I can understand the lack of a strict accumulator, but is using a list really a problem?
19:54:44 <ddarius> roconnor: It adds allocation overhead, heap checks, GC overhead, destructuring overhead.
19:55:00 <roconnor> ddarius: why can it not be optimized away?
19:55:00 <MyCatVerbs> @pl \c -> unlines $ map (\n -> show (n,esterr n (timing id c))) [1..5]
19:55:00 <lambdabot> unlines . flip map [1..5] . (show .) . ap (,) . flip esterr . timing id
19:55:51 <ddarius> roconnor: Some of it can in theory, the laziness can't.  As dons said: [21:36] <dons> the other side of the coin is unrealistic expectations that any junk people through at the compiler is identical to a 'for' loop. reliance on sufficiently smart compilers without care or respect for the transformations involved is dangerous and naive
19:56:43 <solrize> what would the code look like in a strict language like ML?
19:56:49 <roconnor> ddarius: why can I see that doilo's recursive version is the same as foldM' but GHC cannot?
19:57:27 <dons> which foldM' ?
19:57:30 <SamB> roconnor: why can you prove stuff that Coq does not?
19:58:00 <SamB> why does anyone ever need to type anything between "Proof." and "Qed."?
19:58:06 <dons> the one I gave was close enough that it was the same.
19:58:29 <MyCatVerbs> SamB: hey, every postulation implies all true consequences of itself. :)
19:58:38 <roconnor> SamB: because I can see some inductive hypothesis that Coq cannot.
19:58:41 <MyCatVerbs> SamB: and every correct statement implies all tautologies. ^^
19:58:41 <ddarius> roconnor: I have the same question as dons, what is foldM'?
19:59:01 <MyCatVerbs> ddarius: strict left monadic fold?
19:59:06 <bd_> SamB: because one could construct a proof isomorphic to the termination condition of some arbitrary program
19:59:10 <SamB> MyCatVerbs: and all contradictions do too ;-)
19:59:20 <fberthold> Hi folks.
19:59:23 <SamB> bd_: you mean a theorem
19:59:23 <roconnor> ddarius: foldM' is what dons wrote above with a strict accumulator.
19:59:25 <MyCatVerbs> SamB: well yeah, but contradictions imply everything. :)
19:59:27 <SamB> bd_: don't you?
19:59:32 <bd_> SamB: er right.
19:59:34 <dons> monadic, strict accumulator, worker/wrapper fold
19:59:54 <fberthold> I'm trying to shoehorn HList into an instance of Data and can't seem to get it right.
20:00:06 <fberthold> Would someone mind taking a look at my code and let me know what I'm doing wrong?
20:00:08 <SamB> speaking of which, I can't figure out how to write the multiplication operation of http://conal.net/blog/posts/beautiful-differentiation/ in Coq
20:00:09 <lambdabot> Title: Conal Elliott » Blog Archive » Beautiful differentiation
20:00:16 <hpaste>  fberthold pasted "Generic HList" at http://hpaste.org/8595
20:00:33 <SamB> I tried using a coinductive datatype, I tried ye old (lambda () ...) trick...
20:01:13 <ddarius> roconnor: Ah.  Then it's simply the fact that GHC doesn't do such fusion.  It does foldr/build fusion, not arbitrary recursive function/enumFromTo fusion.
20:01:18 <SamB> (the latter gave me:
20:01:21 <SamB> User error: cannot guess decreasing argument of fix
20:01:22 <SamB> )
20:01:33 <SamB> (when I tried to write dZero)
20:02:26 <roconnor> ddarius: so the right thing to do is use foldM' and write a fusion rule.  Thus we get the readablity/reasoning of HOF, and the spead of a recursive code.
20:03:01 <ddarius> roconnor: That's one possibility, and that's fine.
20:03:54 <atp> dons' foldM' isn't in the libs, is it
20:04:03 <atp> might be a good addition
20:04:37 <atp> in fact I think having more explicitly strict versions of functions would help get us out of this "idiomatic haskell" tarpit we've been pigeonholed into recently
20:05:00 <SamB> what does idiomatic haskell have to do with the pigeonhole theorem?
20:05:05 <atp> haha
20:05:13 <atp> i love this channel :)
20:05:15 <SamB> I'd think it would have more in common with the hilbert hotel ;-)
20:05:25 <dolio> Huh, I just got a stack overflow compiling Data.List.Stream on 6.9
20:05:43 <SamB> uh-oh!
20:05:58 <SamB> non-confluent rewriting systems??
20:06:03 <ddarius> atp: There is a library of strict data structures, but in my opinion we need to move/add/remove many functions in the standard libraries.
20:06:14 <solrize> i'm horribly confused all the time about laziness and strictness intermixing and i wish the type system could keep them separate
20:06:16 <ddarius> foldl should be removed or at least swap places with foldl'.
20:06:27 <SamB> ddarius: removed
20:06:38 <roconnor> Can foldM be written with foldr and seq?
20:06:38 <SamB> foldl should be renamed to foldl'', actually
20:06:42 <roconnor> :)
20:06:54 <SamB> and foldl' should be promoted to Prelude
20:07:03 <fberthold> When I attempt to use a generic function on my HList I get "*** Exception: Prelude.undefined"
20:07:10 <dons> dolio: make clean, i've seen that before as well.
20:07:37 <SamB> (swapping two functions that have the same type would be disasterous!)
20:07:47 <ddarius> solrize: unboxed types somewhat does that.
20:07:48 <SamB> (or pointless)
20:07:53 <atp> while i agree that foldl should probably be relegated to use only by people who know exactly what they're doing,
20:07:58 <SamB> (either way it's not a good thing to do)
20:08:10 <atp> i think having a nomenclature for strict functions is valuable
20:08:16 <atp> even if it's only the addition of a prime
20:08:26 <SamB> okay, how about just swapping which one is in Prelude ?
20:08:38 <ddarius> atp: What I meant by "swap places" was to put foldl' in the Prelude and foldl in Data.List.
20:08:39 <atp> yeah, you could make people import Data.List for foldl
20:08:45 <atp> ddarius: i agree wi that.
20:08:46 <solrize> atp it should be strict (or lazy) terms, not just functions, so you get a type error if you use a lazy term in what's supposed to be a strict expression
20:08:49 <SamB> okay, in that case I'm all for it
20:08:52 <SamB> ;-)
20:08:55 <atp> solrize: why would you want that?
20:09:22 <SamB> but it should merely be marked "deprecated" in Prelude'
20:09:29 <solrize> to not get constantly smacked with surprising space leaks and io actions happening in the wrong order
20:09:44 <SamB> speaking of which, {-# DEPRECATED #-} should be semi-standardized
20:09:45 <atp> solrize: io actions happening in the wrong order?
20:09:51 <ddarius> solrize: You shouldn't have IO actions happening in the wrong order.
20:09:51 <atp> solrize: are you using unsafePerformIO ?
20:10:10 <atp> solrize: i think being smacked by lazy evaluation is the best way to learn to analyze it
20:10:26 <ddarius> solrize: Having unlifted types or (better?) an Unlifted type constructor could potentially very useful.
20:10:28 <solrize> atp the string "unsafePerformIO" doesn't appear in any code that i wrote
20:10:30 <SamB> lazy evaluation is the thing that keeps us in line
20:10:34 <ddarius> They've certainly been brought up before.
20:10:40 <SamB> by forcing us to be 99% pure
20:10:49 <atp> solrize: then you should never have IO actions happen in the wrong order.  post the code on hpaste?
20:10:56 <ddarius> solrize: What about unsafeInterleaveIO or hGetContents?
20:10:57 <atp> and tell us what you expect and what happens.
20:11:12 <ddarius> SamB: Like Ivory.
20:11:13 <atp> yeah, i guess if you're using hGetContents it might do something weird.
20:11:14 <atp> maybe.
20:12:01 <ddarius> solrize: If you are not using lazy IO and you are not using unsafePerformIO (or it's relatives) then you should not have any IO ordering determined by evaluation order.
20:12:18 <solrize> atp, right, i'm not sure what to do instead, i'm trying to write a type like   data FileSegment = FileSegment Handle Offset Size   which represents a section of a file
20:12:26 <SamB> I don't think you can get hGetContents to do the wrong thing ... unless unsafeInterleaveIO is messed up
20:12:51 <solrize> hGetContents uses unsafeInterleaveIO
20:13:03 <solrize> sec
20:13:35 <fberthold> Has anyone tried implementing Data by hand instead of letting GHC take care of it?
20:13:35 <SamB> yes but the only thing that could be wrong with it would be if it were using the wrong variant of unsafeInterleaveIO, if there are even two variants
20:13:43 <solrize> and i was planning to use bytestring.lazy.hGet but i think that amounts to the same
20:13:56 <SamB> fberthold: why?
20:14:08 <ddarius> SamB: ? unsafeInterleaveIO is called that for a reason.
20:14:13 <solrize> the problem is that i want to have several segments open on the same file which means i'm seeking around and file handles aren't really pure that way
20:14:25 <SamB> oh, RIGHT
20:14:26 <SamB> that
20:14:30 <SamB> X-P
20:14:49 <ddarius> solrize: You should be using strict IO for that (in my opinion, you should rarely or never use lazy IO)
20:14:51 <fberthold> SamB: I'm trying to do it with HList and not having a lot of luck.
20:14:56 * SamB was only thinking of the order in which the Chars are read from the Handle ;-)
20:15:09 <SamB> fberthold: heh
20:15:10 <roconnor> hGetContents should probably be only used in code that does no other file IO other than that.
20:15:23 <solrize> ddarius i think you're right i'm just having trouble figuring out how to write the strict code since everything about haskell is oriented torwards a lazy style
20:15:32 <balsagot1> hi people
20:15:33 <SamB> well, that should definately be the last file I/O you do on that Handle
20:15:42 <fberthold> Hi balsagotl.
20:15:53 <solrize> can i use Cont to write something like python generators?
20:15:58 <ddarius> solrize: Not really.  Just think of a higher order function that could handle the mode of processing you want.
20:16:07 <fberthold> SamB: Slightly more of a challenge than I anticipated, are you familiar with the subject?
20:16:15 <ddarius> solrize: For a generic example, there are Oleg's left fold enumerators.
20:16:23 <solrize> hmmm
20:16:47 <SamB> fberthold: not terribly, except that I know that HList involves heavy typeclass prolog ...
20:17:01 <solrize> i will look at that again but the word "oleg" is supposed to strike fear into the heart of anyone hoping to code something straightforwardly :)
20:17:03 <balsagot1> anynone knowns anything that can explain monads to a imperative mind like mine :)
20:17:22 <SamB> solrize: well, take heart in the lack of mention of type classes
20:17:30 <fberthold> SamB: Aye, and it has Typeable implemented, but not Data.
20:17:53 <SamB> fberthold: so, you'd have to implement it for each individual datatype
20:18:03 <ddarius> balsagot1: Read the last paper on this page: http://homepages.inf.ed.ac.uk/wadler/topics/monads.html  Read any others that strike your fancy as well.
20:18:04 <lambdabot> Title: Wadler: Monads
20:18:12 <balsagot1> i can't understant State monad, even IO monad
20:18:37 <balsagot1> thanks ddarius
20:19:06 <SamB> balsagot1: well, p >>= \x -> q is like x = doSomething(); doSomethingElse(x);
20:19:20 <SamB> in the IO monad
20:19:49 <fberthold> SamB: Ah, I see what you mean, That might explain why I'm getting the Exception: Prelude.undefined issue.  It's probably calling one of the other data types. I'll dig.
20:19:52 <SamB> or, if you add in some fork(), also in the ListT IO near-monad
20:20:08 <SamB> fberthold: oh, you may have not implemented all the methods ???
20:20:16 <SamB> that's probably the issue
20:20:17 <pgavin> Gtk2Hs 0.9.13 is officially out: http://haskell.org/gtk2hs/archives/2008/06/20/gtk2hs-0913-released/
20:20:19 <lambdabot> Title: Gtk2Hs » Blog Archive » Gtk2Hs 0.9.13 released, http://tinyurl.com/66ac4m
20:20:24 <adu> pgavin: Yey
20:20:29 <hpaste>  dolio pasted "Stream fusion" at http://hpaste.org/8596
20:20:35 <SamB> fberthold: or someone ELSE implemented Data but left methods unimplemented...
20:20:41 <dolio> There's you higher order functions.
20:21:00 <^Someone^> ^Someone|Else^? :o
20:21:00 <SamB> well. except usually those give the source location of the class definition...
20:21:22 <SamB> ^Someone^: er, possibly ?
20:21:32 <SamB> I don't know what libs he's using ;-P
20:21:32 <^Someone^> What a scary thought
20:21:35 <dolio> roconnor: ^^
20:21:49 <fberthold> SamB: It doesn't look like Data is implemented any where, but I could be missing it.
20:22:11 <fberthold> SamB: Thanks for the direction.
20:22:13 <SamB> fberthold: don't you have anything *in* your HLists?
20:22:34 <balsagot1> SamB: but why use a monad to do something? we can do with a function
20:22:59 <SamB> balsagot1: well, referential transparency is the answer
20:23:44 <balsagot1> SamB: i will read more about monads and came later lol
20:23:54 <fberthold> SamB: I'm sorry, I don't understand my source is here: http://hpaste.org/8595
20:23:57 <SamB> if we did IO like most languages do, we'd get really damn surprising results
20:24:12 <solrize> ddarius is this what you're referring to?  http://okmij.org/ftp/Haskell/fold-stream.lhs
20:24:20 <SamB> balsagot1: try using unsafePerformIO for all of your IO and you'll see what I mean
20:25:37 <roconnor> dolio: looks good.
20:26:02 <dolio> roconnor: Fix nested concatmaps and we can put it in GHC. :)
20:26:03 <solrize> so i should write an enumerator that creates a suspension explicitly using a lambda
20:26:58 <SamB> @doc Data
20:26:58 <lambdabot> Data not available
20:27:01 <SamB> @doc Data.Generics
20:27:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
20:27:22 <roconnor> Rather than writing a bunch of recursive functions, is is much nicer to write new rules to fix issues for everyone at the same time!
20:27:55 <pgavin> is darcs.h.o still down, huh?
20:28:10 <Axman6> that's what the topic says
20:28:25 <pgavin> oh, sorry :)
20:28:39 <ddarius> roconnor: You have to 1) know your original code has a problem, 2) know how to solve it, 3) know how to generalize that solution without losing its benefits and 4) know how to add the appropriate RULEs and prove them correct to do that.
20:29:39 <solrize> pgavin, yeah
20:29:46 <ddarius> roconnor: The issue is with people who can't even do (1).  -They- are the ones that need to use recursive loops until they can hit (3).
20:30:07 <pgavin> what country are darcs & hackage in?
20:30:36 <solrize> pgavin they're at galois.com in washington (northwest USA)
20:30:40 <solrize> iirc
20:30:42 <solrize> or was it oregon
20:30:44 <pgavin> ah, ok
20:30:57 <pgavin> that makes sense
20:31:08 <pgavin> all this time I thought they were in england
20:32:13 <ddarius> solrize: As I said, that solution is a rather generic one.  You can probably make a HOF tailored to your particular problem that handles the IO for you (it doesn't have to use the same techniques though it may or may not benefit from them)
20:32:56 <SamB> roconnor: any idea how to do http://conal.net/blog/posts/beautiful-differentiation/ in Coq?
20:32:57 <lambdabot> Title: Conal Elliott » Blog Archive » Beautiful differentiation
20:33:05 <roconnor> ddarius: people who cannot do (1) shouldn't be trying to write performace critical code in Haskell.
20:33:22 <solrize> ddarius yeah i should get some dinner before trying to figure this out, i'm a little buzzed from low blood sugar and not thinking clearly.  but this hof will be monadic?
20:33:40 <ddarius> roconnor: Agreed, but they still try and then complain about how slow Haskell is.
20:33:48 <roconnor> SamB, with co-inductive types
20:33:51 <roconnor> ddarius: ah, okay
20:33:55 <SamB> roconnor: I already tried that
20:34:06 <SamB> but multiplication wouldn't work :-(
20:34:10 <ddarius> solrize: Probably, I don't know the details of your problem.
20:34:36 <ddarius> solrize: Ideally, you want the HOF to take care of all the IO stuff and you just parameterize it by pure functions.
20:34:40 <roconnor> SamB, making guarded cofixpoints is not always easy.
20:34:45 <solrize> in 1) what kind of problem are we talking about?  just absence of fusion causing some lists to be produced and consumed in sync?  or something causing stack overflows?
20:34:51 <SamB> roconnor: you can say that again
20:35:08 <SamB> there should be a tutorial on the techniques involved...
20:35:16 <roconnor> SamB, hmm, that definition looks guarded to me.
20:35:19 <ddarius> solrize: Also, you don't have to do this abstraction.  You can just write your code using strict IO.
20:35:28 <solrize> ddarius the usual operation i want to do is read a binary integer from one segment, and use it as a disk address to seek to in another segment
20:35:31 <ddarius> solrize: That and more.  Just performance issues.
20:35:55 <SamB> roconnor: Coq doesn't like the addition between the D and the recursive calls to *
20:36:05 <SamB> afaict
20:36:14 <roconnor> oh
20:36:18 <roconnor> interesting
20:36:21 <roconnor> yep
20:36:23 <roconnor> that's right
20:36:32 <roconnor> who knows what + does
20:36:40 <roconnor> hmm
20:36:43 <SamB> well, I do!
20:36:45 <roconnor> wait
20:36:52 <roconnor> why would it be a problem
20:36:53 <ddarius> solrize: So have seeker peekDataStructure where peekDataStructure :: DataStructure -> FileOffset  or perhaps Ptr DataStructure -> IO FileOffset or something like that perhaps.
20:37:08 <roconnor> hmm
20:37:29 <SamB> roconnor: well, in the manual it says you can't have any other functions between the constructor and the recursive call
20:37:44 <roconnor> SamB, right.  Okay
20:37:59 <roconnor> I think there is a problem with + potentially adding or removing constructors.
20:38:06 <SamB> so is there some other way to encode the data type?
20:38:19 <solrize> ddarius i could write it in a c-like style where the application's actions are inside some kind of explicit iteration but ugh, i thought i took up functional programming to get away from that.   in python i use a generator and it works out ok, and i think the corresponding haskell construction is a monadic hof
20:39:16 <ddarius> solrize: Heck, you could make a generator or coroutine monad (transformer) and just do exactly what you did in python.
20:39:32 <solrize> ddarius that would be cool, would i use Cont for that?
20:39:46 <ddarius> solrize: You could.
20:40:07 <solrize> ok i will see if i can read about Cont
20:40:48 <solrize> is there some standard construction for this?
20:40:51 <dolio> CC-delcont has a module for doing generators over the delimited continuation monad (transformer).
20:41:10 <solrize> http://www.haskell.org/haskellwiki/Library/CC-delcont
20:41:11 <lambdabot> Title: Library/CC-delcont - HaskellWiki
20:41:17 <dolio> Like, 'generator (\yield -> your code here)'
20:41:17 <solrize> looking
20:41:29 <dolio> It's in Control.Monad.CC.Cursor.
20:41:37 <solrize> oh neat
20:41:43 <solrize> that sounds ideal
20:41:55 <ddarius> Note that this stuff is very much related to the left fold enumerator stuff I mentioned earlier.
20:42:25 <ddarius> solrize: In general, you should think about how you'd -like- to write your code, and then make that a reality.
20:43:18 <roconnor> SamB: unfortunately coinductive types are not well documented in Coq.
20:43:34 <dolio> solrize: And if you have problems/suggestions with that, let me know.
20:43:49 <solrize> ddarius yeah, that's reasonable, i tried starting with the file segment type and got stuck
20:43:50 <solrize> thanks
20:43:55 <SamB> roconnor: well, this restriction is one of the few things the documentation actually explicitly says
20:44:13 <roconnor> SamB: I'd try to try defining the cofixpoints mutually, to see if that helps
20:44:25 <solrize> i really think my life is going to be easier if i write this thing with mmap instead of all these file handles, but unfortunately it has to run on 32 bit os's and the files are too big
20:45:25 <solrize> and we had that chat the other night about how mmap ends up giving less resource control than explicit io
20:49:10 <solrize> whoops!  i guess these cc modules are on hackage :)
20:49:45 <dolio> http://code.haskell.org/~dolio/
20:49:46 <lambdabot> Title: Dan Doel's Haskell Hacking
20:50:56 <solrize> oh neat, thanks, cc-delcont is there
20:51:13 <dolio> I think the latest from darcs should work.
20:51:20 <solrize> but maybe i'll see if i can figure out how to write that generator combinator
20:51:27 <dolio> If not, I'll upload a tar of the version of hackage.
20:52:15 <solrize> darcs get worked
20:52:26 <dolio> I think the only thing I changed from the latest on hackage was to switch from fundeps to type families.
20:52:32 <solrize> i mean it downloaded something successfully
20:52:35 <solrize> zomg
20:52:41 <solrize> you mean i need 6.9?
20:52:46 <fberthold> SamB++
20:53:21 <SamB> fberthold: what'd I do?
20:55:53 <roconnor> SamB: how about x@(D x0 xâ€™) * y@(D y0 yâ€™) = D (x0 * y0) (xâ€™ * y) + D 0 (x * y')
20:56:52 <atp> hey ddarius, are you a grad student?
20:56:54 <SamB> roconnor: it satisfies the guardedness condition
20:57:11 <SamB> at least, according to me it does
20:57:15 <SamB> but I'm only human ;-)
20:57:42 <roconnor> SamB: it isn't as symetric, although you could make it symmetric.
20:58:40 <ddarius> atp: No.
20:59:17 <atp> ddarius: postdoc?  involved in academia at all?
20:59:33 <atp> (just curious, fwiw)
20:59:50 <ddarius> atp: No.
21:00:39 <atp> hm, interesting.  you seem to have an unusually deep understanding of cs/math concepts for someone not actively involved in research...
21:00:48 <atp> so i was just curious
21:02:46 <b7j0c> has anyone ever had compilation/runtime issues with Text.XML.Light ?
21:02:49 <solrize> dolio, this is nice!  (cc modules)
21:03:02 <b7j0c> i.e. the xml ffi bindings
21:03:28 <dons> b7j0c: its not an ffi binding though
21:03:35 <dons> libxml is, however.
21:03:39 <mjrosenb> what do i need to import to get Functor ((,) a)?
21:03:41 <b7j0c> sorry
21:03:48 <dons> b7j0c: are you trying to pull it from hackage?
21:03:53 <dons> (which is done atm)
21:04:18 <atp> mjrosenb: i'm not sure an instance is defined anywhere, although (,) is a bifunctor in category-extras
21:04:21 <b7j0c> yes, i got it from hackage and replaced hxt in a program. after that, compiles would fail periodically and i would get routine coredumps
21:04:28 <b7j0c> i submitted a bug for ghc
21:04:35 <b7j0c> with the program attached
21:04:44 <b7j0c> just wondering if anyone else had these issues
21:04:53 <dons> b7j0c: Text.XML.Light is pure haskell, so if anything crashed, it would be a ghc bug
21:05:13 <dons> make sure you aren't running into partial-rebuild problems (i.e. does it go away after a full clean and rebuild?)
21:05:16 <mjrosenb> atp: so http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AFunctor say's it's defined
21:05:17 <lambdabot> http://tinyurl.com/y25qsm
21:05:26 <b7j0c> hmmm, okay. i did pull "xml" from hackage using cabal-install, which rules by the way
21:05:27 <atp> mjrosenb: then i stand corrected
21:05:29 <mjrosenb> ooh, ih hackage back up?
21:05:33 <atp> @instances Functor
21:05:35 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:05:42 <mjrosenb> atp: just ghci doesn't believe it exists yet
21:05:49 <dons> b7j0c: ok, its just that hackage is down today while we move servers.
21:05:58 <atp> hm
21:06:02 <b7j0c> dons - i rm the .o, .hi etc...so i believe i am doing a "clean" build
21:06:11 <dons> runhaskell Setup.hs clean ?
21:06:19 <dons> or are you not using cabal in your project?
21:06:20 * mjrosenb would guess that i need to give ghc some extra flags
21:06:25 <dolio> Agda's productivity checker doesn't like it, either.
21:06:35 <b7j0c> no this is just a single file "script" style program
21:06:36 <rwbarton> mjrosenb: maybe you need Control.Monad.Instances?
21:06:51 <atp> mjrosenb: not likely.  you probably just need to import the module the instance is defined in
21:06:56 <dolio> solrize: Glad you like them.
21:07:02 <mjrosenb> rwbarton: that worked
21:07:23 <b7j0c> i really like Text.XML.Light by the way, other than this bug
21:07:29 <b7j0c> much easier to use than hxt
21:07:29 <mjrosenb> but it doesn't seem to be working as expected :(
21:07:32 <rwbarton> From the Control.Monad doc page, it does look like there is a bug in something...
21:08:04 <rwbarton> It keeps the first component fixed--it's a functor of the second component only
21:08:13 <mjrosenb> indeed
21:08:17 <b7j0c> is there a simple way to debug crashing haskell programs?
21:08:40 <ddarius> b7j0c: Use the debugger.
21:08:41 <dons> b7j0c: if its segfaulting, gdb will help identify what foreign call was involved, or if it was a haskell symbol
21:08:44 <atp> mjrosenb: what did you expect it to do?
21:08:55 <dons> if its just crashing from a pattern match error, the ghci debugger might help
21:09:09 <dons> but in general, pure code, with a segfault, is a serious compiler bug
21:09:15 <b7j0c> ddarius,dons - if i use it with #!/usr/local/bin/runghc, it never crashes
21:09:25 <b7j0c> it is only when i compile it with ghc --make -O
21:09:29 <dons> check what happens in the interpreter, when compiled, if -O or -O2 change things
21:09:35 <dons> if -fasm or -fvia-C change the result
21:09:37 <mjrosenb> atp: i expected fmap (+1) (1,2) == (2,3)
21:09:49 <dons> and then you might be able to boil it down to a small test case to submit
21:09:54 <atp> mjrosenb: no, that would make (a, a) an instance of Functor
21:10:03 <dons> btw, i put an example of using the rss feed library instead of xml for your curl examples on the wiki, b7j0c
21:10:11 <rwbarton> "Join (,)"
21:10:14 <atp> mjrosenb: which you could define, if you wanted it
21:10:18 <dons> i'm also working on a nice wrapper over curl for simple uri downloading
21:10:23 <mjrosenb> atp: not by haskell98
21:10:27 <atp> rwbarton: neat :p
21:10:28 <b7j0c> oh cool dons!
21:10:43 * mjrosenb preffers to use haskell98 even if it is silly
21:10:43 <b7j0c> maybe that will help me route around my problem in another way!
21:10:53 <atp> mjrosenb: check out rwbarton's suggestion
21:11:00 <b7j0c> although i should do the due diligence as you recommend with the other compilation options
21:11:01 <rwbarton> It doesn't actually exist as far as I know
21:11:14 <dons> b7j0c: oh, you're using the curl library in this program?
21:11:23 <dons> it could be the curl ffi code crashing, rather than the xml library
21:11:24 <atp> rwbarton: bummer, that would be pretty nice.
21:11:24 <rwbarton> (that's what the quotes were intended to suggest)
21:11:26 <b7j0c> yes, using curl
21:11:29 <b7j0c> works great
21:11:40 <mjrosenb> rwbarton: Join is a class, or newtype?
21:11:40 <b7j0c> i have replaced network.http in all my code with it
21:11:41 <dons> gdb will tell you if its something on the curl side
21:11:55 <atp> mjrosenb: it doesn't exist, ignore us :(
21:12:04 <b7j0c> oh, okay, i suppose that is the more likely culprit of Text.XML.Light is pure haskell
21:12:12 <atp> mjrosenb: you can make a newtype and make it an instance if you want
21:12:14 <rwbarton> mjrosenb: It's my imagination, based on:
21:12:15 <b7j0c> i hate gdb, this will be painful!
21:12:19 <rwbarton> @pl \a -> (a,a)
21:12:19 <lambdabot> join (,)
21:12:57 <b7j0c> okay i will try that out, and thanks for amending my example with rss code dons, i will check that out
21:14:15 <atp> mjrosenb: do you need it to be a functor?
21:14:16 <rwbarton> In retrospect the analogy is strained
21:14:45 <atp> mjrosenb: are you trying to write functions that work for all functors, or are you just trying to apply f to both elements of a pair
21:14:50 <mjrosenb> atp: i mostly want the correct function (a->b)-(a,a)->(b,b)
21:15:15 <mjrosenb> which fmap with Functor (a,a) would be presumably
21:15:28 <atp> sure, but you could easily write such a function yourself... or use arrows
21:15:42 <dolio> @type \f -> f *** f
21:15:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
21:16:10 * mjrosenb should learn about arrows
21:16:13 <mjrosenb> but not now
21:16:15 <atp> you don't need to
21:16:25 <atp> in this case all you care about is the function arrow
21:16:44 <mjrosenb> :t arrow
21:16:45 <lambdabot> Not in scope: `arrow'
21:16:46 <atp> > (*2) *** (*2) $ (3, 4)
21:16:48 <lambdabot>  (6,8)
21:17:11 <atp> learning arrows is just like learning monads... learn specific ones first
21:17:22 <atp> it's easy to generalize when you have a variety of examples to draw on
21:17:29 <mjrosenb> atp: yeah, the internets seem to be lacking in examples
21:17:36 <atp> here's one :p
21:18:08 <atp> you could do something like ap (***) id if you want to be point-free
21:18:48 <atp> > ap (***) id (*2) $ (2, 3)
21:18:49 <lambdabot>  (4,6)
21:19:00 <ddarius> atp: That's just play with the combinators in a trivial case.
21:19:06 <ddarius> Anyway, join (***)
21:19:21 <atp> oh right, we just talked about that :p
21:19:26 <atp> thanks ddarius
21:19:35 <mjrosenb> ap was looking non-useful without any examples
21:19:44 <atp> ap is just the s combinator...
21:19:51 <atp> i like this one
21:20:05 <atp> > fix $ (0:) . (1:) . ap (zipWith (+)) tail
21:20:06 <mjrosenb> well it's the s combinator inside of a monad
21:20:06 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:20:19 <rwbarton> @quote aztec
21:20:19 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
21:20:28 <ddarius> mjrosenb: No it is not.
21:20:38 <mjrosenb> err, or it isn't
21:20:43 <atp> hehe
21:20:53 <atp> (r->) is a monad...
21:20:57 <ddarius> ap is S in the particular case of the (r->) monad.
21:21:10 <ddarius> ap is, as the name suggests, just a monadic form of function application
21:21:16 <ddarius> :t liftM2 ($)
21:21:17 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
21:21:26 <mjrosenb> ddarius: right
21:22:07 <atp> it's pretty useful if you have a function in a monad, as the type signature suggests
21:22:26 <mjrosenb> indeed
21:23:09 <atp> anyway ddarius is right, my love for s blinded me to the simpler def
21:23:14 <atp> join is better (and easier to understand)
21:23:24 <atp> join (***) (*2) $ (4, 8)
21:23:30 <atp> > join (***) (*2) $ (4, 8)
21:23:31 <lambdabot>  (8,16)
21:23:52 <ddarius> join is (for (r->) still) the W combinator
21:23:59 <mjrosenb> for the most part everything i've seen in Functor and Monad makes sense
21:24:06 <mjrosenb> W combinator?
21:24:14 <atp> ya it's pretty straightforward
21:24:16 * mjrosenb has not heard of the W combinator
21:24:19 <atp> one of the other combinators
21:24:22 <atp> defined by that german dude
21:24:25 <atp> his name escapes me
21:24:31 <atp> along with b and c and such
21:24:47 <atp> someone will supply his name in a second i'm sure
21:25:02 <^Someone^> Vinay
21:25:08 <atp> vinay?
21:25:09 <atp> hm
21:25:15 <atp> that's not who i was thinking of, maybe i'm wrong
21:25:21 <^Someone^> That's my name
21:25:24 <gwern> schonfinkel?
21:25:43 <atp> yah that's what i was thinking
21:25:47 <atp> thanks gwern
21:26:00 <atp> although wikipedia says haskell curry discovered it
21:26:39 <atp> anyway b = (.), c = flip, w = join and k is const iirc
21:26:48 <roconnor> I love my haskell definitions
21:26:53 <roconnor> fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs)
21:27:09 <roconnor> zipWith (zipWith g)   <3
21:27:29 <atp> what's g?
21:27:39 <roconnor> g x y = if null x then y else x
21:27:59 <atp> that is decidely opaque
21:28:04 <roconnor> :)
21:28:09 <vininim> @date
21:28:09 <lambdabot> Maybe you meant: dice paste vote
21:28:17 <vininim> @time utc
21:28:23 <atp> > let g x y = if null then y else x ; fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs) ; in fixUp [2, 3, 4]
21:28:23 <lambdabot>   add an instance declaration for (Num [c])
21:28:34 <roconnor> it allows me to replace blank entries in a list of list of lists with values from the previous list.
21:28:39 <gwern> atp: one of the nice things in FP is that since it is math which appearsunder multiple guises (the various calculi, logics, category theories, etc.), there are often multiple discoveres
21:28:52 <atp> > let g x y = if null x then y else x ; fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs) ; in fixUp [2, 3, 4]
21:28:52 <lambdabot>   add an instance declaration for (Num [[a]])
21:29:01 <atp> hm
21:29:10 <roconnor> > let g x y = if null then y else x ; fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs) ; in fixUp [["a","b"],["","c"]]
21:29:10 <lambdabot>  Couldn't match expected type `Bool'
21:29:23 <roconnor> > let g x y = if null x then y else x ; fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs) ; in fixUp [["a","b"],["","c"]]
21:29:24 <lambdabot>  [["a","b"],["a","c"]]
21:29:25 <SamB> roconnor: how come most of those primes were not "'"s?
21:29:26 <atp> gwern: yah, good point
21:29:36 <atp> roconnor: ah, i see
21:29:41 <atp> roconnor: my type checker was poor :p
21:29:48 <SamB> when you suggested that definition form for *?
21:29:49 <roconnor> atp: not a good name for the function
21:30:04 <atp> roconnor: you should point-free it, just for kicks.
21:30:05 <roconnor> SamB: I probably made a mistake
21:30:15 <roconnor> SamB: I was fiddling with the code a bit.
21:30:20 <roconnor> but you get the idea
21:30:27 <mjrosenb> @hoogle Bool -> a -> a -> a
21:30:28 <lambdabot> No matches, try a more general search
21:30:32 <mjrosenb> :(
21:30:33 <SamB> roconnor: what I'm really curious about was HOW was it possible for you to make that mistake?
21:30:47 <SamB> hmm, ah I see
21:30:51 <roconnor> SamB, I removed the x@ stuff, and then tried to put it back
21:31:07 <SamB> the blog entry has the funky primes in it
21:31:12 <SamB> that's wierd
21:31:21 <hpaste>  mar77a pasted "ini reader, ways to improve it?" at http://hpaste.org/8597
21:31:25 <gwern> atp: which is bad for the historians and students trying to memorize who did what, but good for anybody who thinks multiple independent discoveries proves something to be a good true idea
21:31:37 <roconnor> atp: you can see how this function might be useful
21:32:10 <roconnor> > let g x y = if null x then y else x ; fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs) ; in fixUp [["a","b"],["","c"],["","d"],["e",""]]
21:32:11 <lambdabot>  [["a","b"],["a","c"],["a","d"],["e","d"]]
21:32:31 <atp> oh, yeah.  nice.
21:32:35 <roconnor> I should proably rewrite it to use Maybes
21:32:55 <atp> gwern: i agree.  i'm still going to call them the schonfinkel combinators though
21:33:12 <roconnor> atp: the recursive call to fixUp allows me to carry the default through mutiple empty strings.
21:33:44 <atp> roconnor: out of curiosity, how did you write it?
21:33:54 <atp> roconnor: did it start out bigger and get progressively simpler?
21:34:03 <atp> roconnor: or did you fool around with a pencil and paper for a bit
21:34:51 <roconnor> atp: I wanted to use the previous value to help out the current value.  So I wrote zip x (tail x) first
21:35:11 <roconnor> atp: then I realized I wanted to carry forward more than one potentially
21:35:21 <roconnor> so I need to carry forwared the fixed value
21:35:32 <ddarius> Curry and Schoenfinkel weren't independent.
21:36:00 <roconnor> atp : so it became x : f $ zip xs' (fixUp xs)
21:36:11 <mjrosenb> let fif bool = (if bool then id else flip) const
21:36:12 <roconnor> atp : then I started writing f
21:36:21 <roconnor> atp: but I soon realized it was a map
21:36:22 <mjrosenb> this seems like a bad idea
21:36:36 <mjrosenb> but i'm still going to do it :)
21:36:40 <atp> mjrosenb: good
21:36:41 <roconnor> atp: so I got x : map f $ zip xs' (fixUp xs)
21:37:12 <atp> hm
21:37:14 <roconnor> at: then wrote f (a,b), and realized this map zip combo was really a zipWith
21:37:27 <atp> right, of course, nice
21:37:30 <roconnor> atp: so I goet x : zipWith f xs' (fixUp xs)
21:37:39 <roconnor> so then I started writing f
21:37:47 <roconnor> and then I realized it was also a zipWith
21:38:05 <atp> that's healthy helping of awesome roconnor
21:38:05 <roconnor> and that makes x : zipWith (zipWith g) xs' (fixUp xs)
21:38:25 <mjrosenb> roconnor: what on earth does that do?
21:38:27 <atp> nested zipWiths make my brain hurt
21:38:32 <roconnor> :)
21:38:40 <roconnor> > let g x y = if null x then y else x ; fixUp xs@(x:xs') = x:zipWith (zipWith g) xs' (fixUp xs) ; in fixUp [["a","b"],["","c"],["","d"],["e",""]]
21:38:41 <atp> mjrosenb: did you miss the example he posted?
21:38:41 <lambdabot>  [["a","b"],["a","c"],["a","d"],["e","d"]]
21:38:47 <atp> there you go :p
21:39:03 <atp> mjrosenb: he also just explained how he derived it
21:39:11 <atp> it was groovy
21:39:21 <mjrosenb> evidently
21:39:34 <roconnor> atp: It's nice to illustrate how such opaque functions are derived.
21:39:34 * mjrosenb has been writing code
21:39:36 <mjrosenb> writing haskell is so slow
21:39:44 <atp> mjrosenb: it gets faster :p
21:39:51 <mjrosenb> i spend 30 seconds writing code
21:40:09 <mjrosenb> then 5 minutes in here talking about completely unrelated stuff
21:40:12 <atp> roconnor: i agree.  and it's funny how quickly you take that sort of derivation for granted, and how difficult (read impossible) it is in the imperative space
21:40:42 <atp> i spend a lot of time manipulating my code algebraically because it's fun and because i can :)
21:41:06 <atp> mjrosenb: don't think of chatting in here as unproductive, you can learn a frighteningly large amount of useful stuff just listening
21:41:07 <roconnor> atp: this ought to be generalized to work with Maybe's.  But I'm just writing a little script, so I will probably leave it as is.
21:41:15 <atp> it's pretty nice as is
21:41:35 <atp> 6 months down the road it may take you a bit of thinking to figure out how it works, though :)
21:41:44 <mjrosenb> roconnor: does it propagate a full list over the empty lists in a list of tuples of lists?
21:41:50 <rwbarton> You'd just need to change 'g' to 'mplus'
21:42:09 <scodil> but thats the nice thing: you can still shuffle code around without knowing how it works
21:42:16 <scodil> just stick to the rules
21:42:34 <atp> yeah... and more importantly, the *compiler* can do that
21:42:45 <scodil> no for aesthetic purposes tho :)
21:43:08 <atp> lately i've been amusing myself by never using explicit recursion
21:43:18 <roconnor> mjrosenb: it propagates a full list over the empty lists in a list of lists.
21:43:23 <roconnor> ... I think
21:43:25 <atp> listening to edwardk talk about his various morphisms in here
21:43:46 <mjrosenb> oh, those are lists, not tuples, my bad
21:43:57 <roconnor> mjrosenb: I have a spreadsheet where some cells are left blank because they are the same as the previous cell.
21:44:05 <roconnor> mjrosenb: I'm "fixing it up"
21:44:08 <edwardk> atp: heh
21:44:14 <roconnor> mjrosenb: hence the crappy name
21:44:29 <scodil> i think "makeBetter" would be more descriptive
21:44:36 <edwardk> i only have a couple of them that are mine, the rest of them are just rehashes of everyone else's stuff ;)
21:44:46 <atp> edwardk: hey, it's true!  inspiration... unfortunately i'm not great at identifying things other than cata ana and hylomorphisms
21:45:00 <edwardk> thats a definite start
21:45:09 <atp> edwardk: i'm still waiting on that blog post you promise giving use examples of all the exotic ones :p
21:45:14 <edwardk> apo is a nice next step, coz its easy
21:45:15 <atp> promised*
21:45:26 <rwbarton> > let fixUp xs = tail $ scanl (zipWith (flip mplus)) (repeat Nothing) xs in fixUp [[Just "a", Just "b"], [Nothing, Just "c"], [Nothing, Just "d"]]
21:45:27 <lambdabot>  [[Just "a",Just "b"],[Just "a",Just "c"],[Just "a",Just "d"]]
21:45:31 <edwardk> atp: yeah went to movies tonight instead. ;)
21:45:43 <atp> edwardk: hm, ok, i'll check out apo next.  what did you see?
21:45:46 <edwardk> atp: i'll bang out the next couple some time this weekend
21:45:50 <edwardk> atp: wall-e
21:45:59 <atp> oooo i'm going to go see that tonight too i think
21:46:05 <atp> girlfriend's been itching to see it
21:46:09 <atp> (me too of course)
21:46:14 <edwardk> atp: yeah my wife dragged me. glad i went
21:46:50 <atp> rwbarton: i likes :p
21:47:06 <atp> anyway, speaking of which i'd better go wake her up or we'll never get there tonight
21:47:07 <rwbarton> > let fixUp = scanl1 (zipWith (flip mplus)) in fixUp [[Just "a", Just "b"], [Nothing, Just "c"], [Nothing, Just "d"]]
21:47:08 <lambdabot>  [[Just "a",Just "b"],[Just "a",Just "c"],[Just "a",Just "d"]]
21:47:08 <edwardk> i think what i'mn going to do order wise is do anamorphism, apomorphism, then generalized anamorphism, generalized catamorphism, that will let me introduce f-distributive (co)monads in terms of monads rather than comonads so i don't scare everyone away
21:47:46 <atp> edwardk: ha, it's funny how an innocuous little co- can be enough to make the entirety of the likes of reddit shun you
21:48:02 <edwardk> and i can then use the generalized version to remotivate para and apo, and i can build up zygo and its dual, histo, futu, etc.
21:48:04 <edwardk> heh
21:48:05 <roconnor> rwbarton: ah
21:48:21 <roconnor> rwbarton: it's so obvious
21:48:30 <atp> edwardk: i'm definitely looking forward to that
21:48:35 <rwbarton> roconnor: My first 6 or so attempts were much longer than yours :)
21:48:39 <scodil> what about xylem and phloem? how do you derive those?
21:48:42 <adu> I think HOC needs to be broken up
21:48:46 <roconnor> rwbarton: that makes me feel better
21:48:48 <atp> scodil: haha
21:48:52 <atp> scodil: you a bio geek?
21:49:01 <scodil> uh
21:49:04 <scodil> no
21:49:06 <scodil> i don't think
21:49:08 <scodil> maybe
21:49:09 <edwardk> atp: anyways thats the current plan. we'll see how far i get. I have house guests coming next week, then I'm off to iceland for MSFP.
21:49:17 <SamB> scodil: well, you start with the difference between a hard cell wall and a cell membrane...
21:49:29 <ddarius> > scanl1 (zipWith (flip mplus)) . map listToMaybe $ [["a","b"],["","c"],["","d"],["e",""]]
21:49:29 <lambdabot>  Couldn't match expected type `[m a]'
21:49:36 <atp> edwardk: oo, iceland.  you'll like it.  try to hit the hot springs.
21:49:45 <scodil> wait aren't those both plant cells?
21:49:46 <ddarius> > scanl1 (zipWith (flip mplus)) . map . map listToMaybe $ [["a","b"],["","c"],["","d"],["e",""]]
21:49:47 <lambdabot>  Couldn't match expected type `[[m a]]'
21:49:52 <edwardk> atp: i'll keep that in mind
21:49:53 <SamB> scodil: yes
21:50:00 <atp> edwardk: ok, gotta go.  remember that you do have an audience out here that appreciates your work a lot though
21:50:07 <atp> in case you ever get discouraged or whatever
21:50:16 <SamB> I just couldn't think of anything else to say that related in ANY WAY to plant cells
21:50:29 <edwardk> alright. i'll definitely keep that in mind. and i'll make sure to write the next couple of entries in the field guide for ya ;)
21:50:37 <SamB> that had anything like the right form for an answer to that question
21:50:49 <ddarius> > scanl1 (zipWith (flip mplus)) . map (map (fmap return listToMaybe)) $ [["a","b"],["","c"],["","d"],["e",""]]
21:50:51 <atp> scodil: throwing technical terms from any discipline around in this channel will have people expecting you to know their defs :)
21:50:55 <lambdabot>        add an instance declaration for (Show (m (Maybe Char)))
21:51:01 <atp> ok gotta go
21:51:03 <atp> later peeps
21:51:03 <SamB> edwardk: so are you going to write about the floamorphism?
21:51:15 <scodil> xylem takes water up from the roots, phloem takes sugar back down. at least thats what i remember
21:51:15 <SamB> er.
21:51:19 <SamB> phloemorphism
21:51:31 <SamB> scodil: definately that or the other way round
21:51:40 <scodil> yeah. one of the two
21:51:45 <scodil> its the duality thats important :)
21:51:49 <edwardk> samb: i might write about polymorphism =)
21:52:07 <scodil> i'm impressed that the gtk text widget spell check has "xylem" and "phloem"
21:52:07 <solrize> @hoogle hseek
21:52:07 <lambdabot> System.IO.hSeek :: Handle -> SeekMode -> Integer -> IO ()
21:52:10 <SamB> edwardk: I'm not familiar with that kind of morphism
21:52:21 <SamB> what properties does it satisfy?
21:52:41 <scodil> no mesophyl tho. But it does have 'tho'. odd.
21:52:42 <SamB> wantsACracker?
21:52:56 <adu> extra-libraries isn't working
21:53:27 * SamB wonders why nobody has groaned
21:53:32 <edwardk> samb: depends on the type. no one can agree on the definition.
21:53:44 <SamB> hehehe
21:54:28 <gwern> edwardk: you know, I've been seriously musing over redirecting all the cato- and hylo- and etc. -morphism articles on Wikipedia into a single article where I just copy-paste your taxonomy
21:54:56 <scodil> so where do lagomorphisms fit in there?
21:54:56 <edwardk> gwern: let me finish the content first =)
21:55:07 <adu> is "runhaskell Setup.hs build --verbose" supposed to show "-lthing" if you use extra-libraries: thing
21:55:08 <adu> ?
21:55:27 <gwern> lagomorphisms...?
21:55:33 <scodil> <- WINNER
21:55:37 <edwardk> a lagomorphic catamorphism is both cruel and unusual.
21:55:38 * gwern tries to resist the urge to make a Snow Crash joke
21:56:23 <scodil> aren't there lots of lagomorphic catamorphs in anime?
21:56:36 <edwardk> ah true. tenchi muyo had one
21:56:42 <scodil> ah
21:56:43 <roconnor> I would have never thought to use scan
21:56:47 <scodil> thats what I'm thinking of
21:57:06 <edwardk> the english version was even voiced by someone with the last name 'cabbit' which i found hilarious.
21:57:10 <rwbarton> At one point I had:
21:57:19 <rwbarton> > let fixUp xs = evalState ( sequence [ do { l <- get ; let { l' = zipWith mplus s l } ; put l' ; return l' } | s <- xs ] ) (repeat Nothing) in fixUp [[Just "a", Just "b"], [Nothing, Just "c"]]
21:57:20 <lambdabot>  [[Just "a",Just "b"],[Just "a",Just "c"]]
21:57:27 <rwbarton> and then I figured there must be a name for that
21:57:30 <roconnor> *L*
21:57:37 <roconnor> fixUp = scanl1 (zipWith g)
21:57:37 <roconnor>  where
21:57:37 <roconnor>   g x "" = x
21:57:37 <roconnor>   g _ y  = y
21:57:41 <gwern> edwardk: cabbitmorphisms?
21:57:43 <roconnor> that's almost readable now
21:58:18 <gwern> cabbimorphisms, would be better i suppose. on the other hand, almost the entire cast makes sense this way - tenchimorphisms, ryokomorphisms...
21:58:45 * gwern glares around. hey! they're no worse than 'hylomorphism' or the even weirder named ones!
21:58:50 <roconnor> > scanl1 undefined []
21:58:51 <lambdabot>  []
21:59:06 <edwardk> alas they don't fit Meertens' greek fetish ;)
21:59:08 <roconnor> > scanl1 undefined [x]
21:59:09 <lambdabot>  [x]
21:59:40 <roconnor> it even works on empty lists
21:59:56 <edwardk> The whole system of grecomorphisms is a little absurd I'll admit.
22:00:36 <gwern> edwardk: no one would notice a harmless little ayekamorphism. that's practically greek already
22:01:17 <scodil> but how ridiculous would you feel going on about "downforms" and "upforms"
22:01:48 * pjdelport suggests "buildups" and "letdowns"
22:01:56 <gwern> I wouldn'. at least they try to appeal to some intuition and be understandable
22:02:07 <edwardk> scodil: i'll admit i used to think of them as folds, unfolds and refolds
22:02:24 <scodil> but if the layperson can't parse what you're saying, they'll at least give you the benefit of the doubt :)
22:02:36 <edwardk> pjdelport: heh, that sounds fairly apt for what the style has led to for the industry ;)
22:02:36 <mjrosenb> hrmm, it's taking like 3 seconds to parse an id3 header.  this is highly non-ideal
22:03:05 <edwardk> mjrosenb: the question is does it take 4 seconds for an id4.
22:03:22 <solrize> heh
22:03:35 <roconnor> mjrosenb: id3 at the beginning or end of the file?
22:04:10 <scodil> is it a steganographic id3? if so 3sec is not that bad
22:08:33 <mjrosenb> roconnor: v2; at the beginning
22:08:50 <edwardk> there needs to be some name for a generalized apomorphism other than generalized apomorphism, g-apo is dual to zygo, so g-zygo is dual to g-g-apo, which is just silly.
22:08:57 <mjrosenb> all in all, i should be toughching about 2k of data
22:08:58 <edwardk> symmetry demands a name ;)
22:11:29 <solrize> ddarius are you still here?
22:12:10 <ddarius> Yes.
22:13:28 <solrize> i'm still trying to write that iterator, and am remembering now, i'm trying to use data.binary.get to parse values from the file, and that expects a lazy bytestring
22:13:56 <solrize> oh i see, i can use fromChunks
22:14:35 <solrize> but that still isn't so good because i don't know in advance how many chars i want to read
22:14:58 <solrize> any advice about how to write this strictly?
22:15:27 <cjs> solrize: What are you trying to do?
22:15:47 <solrize> cjs i'm trying to parse a weird binary file format from several places in the file concurrently
22:16:20 <solrize> and per the advice i've been getting, i'm trying to do it without using lazy i/o
22:16:58 <solrize> so i'm trying to figure out how to use the built-in data.binary.get actions in that context
22:17:49 <cjs> Hm. Are you sure you want to use those? I don't recall them off-hand exactly, but I looked at that, and for whatever reason, ended up with my own parser.
22:18:08 <gwern> solrize: there is no binary-strict?
22:18:14 <solrize> well they're really really nicely designed for lazy strings
22:18:35 * gwern thought there was
22:18:38 <solrize> gwern, hmm, i'm just looking at the docs and it says lazy but maybe there's a strict version?
22:19:32 <cjs> You're talking about Data.ByteString.Lazy?
22:19:33 <solrize> would i pass a file handle to the get actions?  i don't remember seeing anything like that
22:19:56 <ddarius> There is a binary-strict package
22:19:59 <solrize> The Get monad. A monad for efficiently building structures from encoded lazy ByteStrings
22:20:31 <rwbarton> maybe you can use Data.ByteString.hGet and then turn it into a lazy ByteString somehow
22:20:43 <cjs> "Lazy" vs. "Strict" is misleading you here. That's only a storage format difference.
22:20:46 <solrize> aha
22:20:49 <cjs> Or so I think.
22:21:04 <solrize> .
22:21:04 <solrize> Let's update the first example with this strict version of Get. You'll have to install the binary-strict package for it to work.
22:21:13 <solrize> (http://www.haskell.org/haskellwiki/DealingWithBinaryData)
22:21:13 <lambdabot> Title: DealingWithBinaryData - HaskellWiki
22:21:39 <solrize> hmm that example still uses getContents
22:22:08 <dolio> That's getContents with a strict ByteString.
22:22:29 <solrize> that appears to read the whole file into memory :(
22:22:35 <dolio> Yeah.
22:22:46 <rwbarton> I think cjs is sort of right, except that also, Data.ByteString.getContents is strict IO and Data.ByteString.Lazy.getContents is lazy IO.
22:23:01 <rwbarton> Do you know how much you need to read?
22:23:30 <solrize> rwbarton no, amount of data is determined by the file contents
22:23:37 <cjs> Right. But that strict vs. lazy IO is nothing to do with strict vs. lazy bytestrings.
22:24:06 <solrize> the basic problem is that the Get actions have to cause i/o to happen
22:24:30 <dolio> What's the problem with using lazy IO in this situation?
22:24:30 <rwbarton> and that i/o is going to require a seek in your situation?
22:24:34 <solrize> in the case of lazy bytestrings that's abstracted by hGetContents which uses lazy io
22:24:59 <solrize> dolio it's the same thing again, i want to seek around in the file and read stuff from different places
22:25:17 <dolio> Ah.
22:25:26 <rwbarton> Would it be acceptable to just open the file with multiple handles?
22:25:50 <cjs> Well, it makes sense just to seek around.
22:25:54 <solrize> rwbarton yeah i'm going to use separate handles for each segment
22:26:16 * edwardk &
22:27:11 <dolio> Well, if you're seeking around, I don't think you'll be using binary.
22:27:27 <solrize> the trouble with lazy io is that it's buffered (reads ahead) so if i seek then it can get confused, i think
22:28:00 <cjs> You don't want to use lazy IO for this. You'll end up reading all of the file up to the furthest point to which you read, instead of just the parts you need.
22:28:16 <solrize> that too
22:28:43 <solrize> i would think that i'm trying to do something very normal and routine here... is that correct?
22:28:55 <rwbarton> I think the main thing is you'd need to rewrite the lazy io loops so that they seek to where they ought to read from each time they read data.
22:28:58 <solrize> it sounds like i have to write my own version of the Get monad
22:29:01 <cjs> Well, hackage.haskell.org appears to be dead, so I'll see if I can build the haddocs for my copy of Data.Binary and look at it.
22:29:20 <solrize> http://www.cse.unsw.edu.au/~dons/binary/Data-Binary.html#v%3AgetWord16le
22:29:22 <lambdabot> http://tinyurl.com/33q9a7
22:29:23 <solrize> oops
22:29:29 <solrize> http://www.cse.unsw.edu.au/~dons/binary/Data-Binary.html
22:30:37 <solrize> i need something like Get for a file handle instead of a bytestring
22:30:40 <cjs> Ah, so the issue is that you don't know how much you need to read? Is there a limit on the potential size?
22:31:02 <solrize> cjs in practice the size won't be terribly large most of the time, but it seems ugly to depend on that
22:31:10 <cjs> Argh! I somehow just turned by program back into a massive memory-eating monster!
22:31:18 <solrize> cjs :)
22:31:31 <cjs> Damn. Something just got unstrict somewhere.
22:31:48 <roconnor> @hoogle (a -> Maybe b) -> [a] ->[b]
22:31:49 <lambdabot> Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
22:32:05 <cjs> Anyway, yeah, you don't want to depend on that. You need to be reading the bits that determine the size, parsing them, and then reading further. In other words, you need a parser, not Data.Binary.
22:32:10 * solrize shouts to cjs's runtime system, "get up, get up, you lazy evaluator!!!"
22:32:19 <cjs> Heh.
22:32:44 <solrize> well that's what Data.Binary.Get is supposed to be, i thought :)
22:33:05 <cjs> No. Data.Binary.Get parses one object. You're parsing more than one.
22:33:30 <solrize> well i call data.binary.get multiple times...
22:33:34 <rwbarton> I think you can work with Data.Binary.Get by managing the lazy IO yourself and seeking before each read
22:34:07 <cjs> You don't want lazy IO, but yes, you want to manage it yourself.
22:34:31 <solrize> seeking before each read doesn't make sense and would kill me with system call overhead anyway
22:34:57 <cjs> You do that many reads?
22:34:59 <rwbarton> Only twice as many syscalls...
22:35:00 <cjs> Seeking is quite cheap.
22:35:03 <solrize> although, hmm, maybe there's something like stdio underneath system.io, that avoids the system call if the seek is in the same block?
22:35:18 <solrize> i'm presuming that hRead is buffered....
22:35:35 <cjs> If you're doing that many reads, that's what's killing you, and the seeks will contribute negligably to that.
22:35:36 <solrize> so i can read a few chars at a time without getting clobbered
22:35:47 <cjs> Yes. See hSetBuffering.
22:36:04 <solrize> ok but then what happens when i seek?  i'm typically reading a few chars at a time
22:36:22 <cjs> If you seek within the buffered data, I'd assume that no syscalls are made.
22:36:46 <solrize> that's sort of ok, but man, what a mess, having to write all this low level hair
22:37:03 <cjs> Regardless, I'd just implement it and only worry about the seeks, etc. if it turns out to be a problem.
22:37:17 <solrize> seeks are about 70 microseconds
22:37:27 <solrize> when the file is in kernel cache
22:37:28 <cjs> But how many hundreds of thousands of reads are you doing?
22:37:34 <solrize> millions/billions
22:37:50 <cjs> And how big is the file?
22:37:57 <solrize> 10's of gb
22:38:04 <solrize> later probably 100's of gb
22:38:29 <cjs> Hm. Can you find an algorithm that will just let you scan through the file linearly?
22:38:51 <cjs> If you can do that, building up whatever data set you need in memory as you go, you'll do much better.
22:39:00 <cjs> This is the classic "use an index or do a table scan?" problem.
22:39:18 <solrize> doing a 100gb table scan to look up one value is almost always wrong ;)
22:39:42 <cjs> Yeah, but you're not looking up one value; you're doing millions/billions of reads, you said.
22:39:57 <They> Guys, I need your help
22:40:08 <They> @hpaste
22:40:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:40:17 <solrize> true :)
22:40:31 <solrize> hmm
22:41:11 <hpaste>  They pasted "Parsec" at http://hpaste.org/8598
22:41:34 <They> I've been trying to debug this thing for hours, but I just can't figure it out.
22:41:44 <They> well, half an hour.
22:42:12 <They> when I run the 'binary' parser, I keep on getting stack overflows.
22:42:13 <solrize> for the immediate thing i'm doing i want to read these segments mostly sequentially.  i think the table scan approach will be ok for that.
22:42:43 <solrize> however i still don't know in advance how big the data values are (they are fairly small though)
22:43:04 <solrize> later i'll want to do some operations that involve a few thousand reads from random places in the file
22:46:39 <solrize> i think what's happening is i'm hitting a fairly unexplored corner of haskell hacking.  that didn't occur to me at first but i guess it makes sense given that data.binary is relatively nes
22:46:40 <solrize> new
22:48:14 <solrize> i don't have that many types to parse, so i guess i can write a Get-like monad that operates on a file handle instead of a bytestring
22:48:40 <solrize> does that make sense?  does it sound useful in general?
22:48:52 <solrize> that is basically what i have in my python version
22:48:54 <rwbarton> solrize: Yes, I think that's the simplest thing to do.
22:49:06 <solrize> rwbarton thanks
22:49:27 <rwbarton> You can pretty much just write each of those functions to operate directly on a filehandle
22:50:06 <solrize> ok i'll try that
22:50:14 <rwbarton> Ideally I guess Get and your thing could belong to a common type class
22:51:52 <solrize> hmm, Get is a monad
22:52:55 <dons> dolio: we could do a walk over Control.Monad if people are going to use those things for tight loops
22:53:04 <solrize> Get :: (* -> *)
22:53:30 <rwbarton> solrize: you should ask dons your questions
22:53:50 <solrize> rwbarton i think i've pestered dons way too much in recent months :)
22:53:56 <rwbarton> ok then :)
22:55:00 <rwbarton> class Monad g => MonadGet g where skip :: Int -> g () ; ...
22:55:33 <rwbarton> But anyways, that doesn't help you with this specific problem
22:56:03 <dolio> dons: You might be able to point them at Control.Monad.Stream.
22:56:17 <dolio> Since that fuses better.
22:57:28 <dolio> I did some testing and my loop version of replicateM_ wasn't significantly faster than replicateM_. It's possible that tuple-element unboxing issue hurts.
22:57:42 <dolio> It's also possible the blas bindings aren't super optimized.
23:03:46 <dolio> Actually, that looks unlikely, I guess.
23:04:39 <dolio> Unless it's lack of inlining.
23:16:49 <dibblego> is there a way of saying "is defined" or "is not bottom" using denotational semantics?
23:20:55 <bd_> dibblego: The problem with that is it's equivalent to a halting problem solver if implemented :)
23:21:05 <dibblego> bd_, :)
23:21:20 <dolio> It depends what you mean, exactly.
23:21:48 <rwbarton> I would say yes, "$x \ne \bot$", but I think that must not be what you mean.
23:22:38 <solrize> dibblego i don't think so.  there's a type for every proposition, and bottom is a member of every type.
23:23:01 <dolio> Denotational semantics for certain languages might talk about bottom all the time.
23:23:58 <dolio> Like 'f is non-strict if f _|_ /= _|_'
23:24:28 <solrize> hmm
23:24:29 <dolio> But that doesn't mean you can decide the halting problem in the language you're giving semantics for.
23:26:21 <solrize> yeah ok what i was thinking makes no sense
23:28:33 <rwbarton> On a mostly unrelated note, what kind of programming language would you design for a computer equipped with an oracle for the halting problem?
23:28:47 <rwbarton> (The halting problem for ordinary computers, not its own halting problem, of course)
23:29:10 <solrize> i guess you wouldn't need any algorithms
23:29:18 <solrize> just encode everything as a halting instance and call the oraclae
23:29:20 <solrize> oracle
23:29:44 <solrize> that's for ordinary problems
23:30:27 <psygnisfive> <whoremode> i just invented a cool fractal-ish version of the look-tell algorithm :x
23:30:37 <psygnisfive> and it makes for pretty pictures too
23:30:55 <solrize> but then you want to solve undecidable problems that need multiple oracle calls..
23:31:27 <solrize> rwbarton have you seen any of joel hamkins' papers about infinite time turing machines?  they are really neat
23:32:15 <solrize> http://jdh.hamkins.org/Publications   start with 2002d
23:32:16 <lambdabot> Title: Joel David Hamkins
23:33:01 <rwbarton> Hmm.  I wonder whether every problem that can be solved by such a machine only requires one call of the oracle
23:33:49 <psygnisfive> http://wellnowwhat.net/alphabeticalseesay.xhtml << type a letter into the box and click submit. see the pretty visualization of the look-tell. :)
23:33:50 <psygnisfive> :x
23:36:44 <rwbarton> "With more complicated arrangements of rockets flying around rockets, one can solve more complicated number theoretic questions." nice
23:37:23 <codacola> :|
23:38:22 <lament> psygnisfive: what is that?
23:41:35 <psygnisfive> its a look-tell with letter names
23:41:36 <psygnisfive> e.g.
23:41:46 <psygnisfive> a -> ay, b -> be, h -> aitch, w -> doubleyou
23:41:48 <psygnisfive> and so on
23:41:59 <psygnisfive> but instead of drawing letters, i draw colored bars
23:42:06 <psygnisfive> and i did it multiple iterations deep
23:42:20 <lament> what are the colored bars
23:42:23 <psygnisfive> and i aligned them left and then aligned them right
23:42:28 <psygnisfive> the colored bars represent letters
23:42:38 <psygnisfive> "a" has one bar, for "a"
23:42:43 <psygnisfive> "ay" has two
23:42:48 <psygnisfive> "aywhy" has five
23:42:50 <psygnisfive> and so on
23:43:00 <solrize> it wedged my browser
23:43:11 <psygnisfive> sorry :(
23:43:17 <int-e> rwbarton: how would you decide, with one call to the oracle, whether exactly one of two given turing machines halts?
23:43:25 <psygnisfive> the drawing is pretty painful
23:43:43 <lament> psygnisfive: i don't understand the colored bars.
23:43:48 <psygnisfive> why not?
23:44:02 <psygnisfive> each vertical band corresponds to a letter
23:44:11 <lament> oh, i see now
23:44:14 <lament> you draw multiple iterations
23:44:18 <psygnisfive> yes :)
23:44:21 <lament> and you don't draw any space between them
23:44:25 <psygnisfive> right
23:44:32 <psygnisfive> to show that they bleed into one another in interesting ways
23:45:02 <lament> do they?
23:45:04 <rwbarton> int-e: Yeah, I think the answer is probably no.
23:46:29 <psygnisfive> yeah just look at it :P
23:46:36 <dons> dolio: do we know where the darcs version of the haskell blas lib is
23:46:36 <psygnisfive> for "a"
23:46:48 <dolio> Yeah, I found it earlier.
23:46:48 <psygnisfive> the whole nth iteration is the left 1/3 ish of the n+1th iteration
23:47:05 <dolio> http://www-stat.stanford.edu/~patperry/code/blas
23:47:06 <lambdabot> Title: Index of /~patperry/code/blas
23:47:07 <psygnisfive> while the righty 2/3rds of the nth iteration is the right 2/9ths of the n+1 iteration
23:47:22 <dolio> I don't have storable-complex, though, so I can't build it.
23:47:32 <roconnor> @seen hackage
23:47:32 <lambdabot> I saw hackage leaving #haskell 1d 8h 1m 6s ago, and .
23:47:47 <roconnor> :(
23:48:16 <dons> i've got storable-complex. let's see if there's a src bundle...
23:48:48 <dons> dolio: code.haskell.org/~dons/storable-complex-0.1.tar.gz
23:48:57 <dons> cabal++
23:49:45 <roconnor> @hoogle String -> CalendarTime
23:49:46 <lambdabot> No matches, try a more general search
23:50:01 <dons> i'd feel better if cblas was compiled with -O2 -fvia-C
23:50:16 <dons> we can send perry some patches
23:50:24 <dons> poke around his data decls
23:52:08 <dolio> Is this not compiled with -O2 at all?
23:52:10 <dolio> Just -Wall?
23:52:15 <dons> looks like.
23:52:21 <dons> so no spec constr on any loops, if it has them.
23:52:48 <dons> probably not a big deal. this foldM / replicateM is more of a killer in Anatoly's stuff
23:53:48 <dons> ah, i need 'atlas' hmm.
23:54:07 * Apocalisp shrugs
23:54:27 <ivanm> if f :: a -> a -> a, is there a difference between (x `f`) and (`f` x) (assuming commutativity)?
23:57:49 <mmmdonuts> Anyone know where I can get a copy of network-2.2.0.0.tar.gz ?  (Seeing as hackage is down)
23:58:34 * mmmdonuts moodily contemplates the Mad-Max-like wasteland that is the Haskell world without hackage
23:59:07 <roconnor> how do I convert from UTCTime to UniversalTime?
23:59:13 <dons> code.haskell.org/~dons/network-2.1.0.0.tar.gz
23:59:18 <dons> mmmdonuts: close enough?
23:59:52 <dons> "CPU Throttling apparently enabled!
23:59:52 <dons> It appears you have cpu throttling enabled, which makes timings
23:59:53 <dons> unreliable and an ATLAS install nonsensical."
23:59:54 <dons> wow.
