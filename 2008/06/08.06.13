00:00:04 <dons> TomMD:
00:00:05 <dons> $ runhaskell Setup.lhs configure
00:00:05 <dons> Configuring pureMD5-0.2.0...
00:00:05 <dons> $ runhaskell Setup.lhs build
00:00:05 <dons> Preprocessing library pureMD5-0.2.0...
00:00:07 <dons> Setup.lhs: can't find source for Data.Digest.Pure.MD5 in ["Data","Test"]
00:00:14 <dons> works with cabal 1.3.12 and later though
00:31:49 <sjanssen> j
00:32:04 <Baughn> k?
00:32:05 <sjanssen> repeat after me: #haskell is not mutt
00:32:26 <Baughn> @tell sjanssen Works fine for email, though
00:32:27 <lambdabot> Consider it noted.
00:32:40 <ivanm> lol
00:32:54 <ivanm> @remember sjanssen repeat after me: #haskell is not mutt
00:32:54 <sjanssen> @messages
00:32:54 <lambdabot> It is forever etched in my memory.
00:32:54 <lambdabot> Baughn said 28s ago: Works fine for email, though
00:36:27 <frevidar> I got this error after installing Data.List.Stream and upon attempting to compile a file which imports Data.List.Stream
00:36:28 <frevidar> main.o(.text+0x281):fake: undefined reference to `__stginit_streamzmfusionzm0zi1zi1_DataziListziStream_'main.o(.text+0x281):fake: undefined reference to `__stginit_streamzmfusionzm0zi1zi1_DataziListziStream_'
00:36:43 <sjanssen> frevidar: compile with --make
00:37:06 <frevidar> sjanssen: ah, thanks!
00:38:46 <dons> dcoutts: fyi, http://aur.archlinux.org/packages.php?ID=17509 :)
00:38:46 <lambdabot> Title: AUR (en) - haskell-cabal
00:41:17 <BeelsebobWork> does anyone know of a good paper that covers automatic insertion of type applications to get Haskell-like parametric polymorphism (where one doesn't have to run around annotating types on instances of map all the time for example)
00:53:17 <osfameron> following the discussion on Reader last night, I began wondering why we need it :-)  As in, can't we just declare:  let env = whatever;  at the beginning of some other monad, and that will be in lexical scope for the whole of the do block anyway?
00:53:55 <dmwit> osfameron: It's mostly there for the ap/liftM2-type tricks you can pull, I think.
00:54:03 <sjanssen> osfameron: we don't *need* Reader -- we don't need any of the Monads
00:54:11 <dmwit> I don't think I've ever written a do-block version of Reader.
00:54:14 <sjanssen> osfameron: the point of the instance is to package that pattern for re-use
00:54:53 <osfameron> but is it more convenient than just having a lexical environment?  (To not use other monads would be significantly more painful)
00:55:34 <sjanssen> osfameron: but what if you can't use a single scope? (perhaps your task spans several functions)
00:56:18 <osfameron> ah, gotcha.  That makes perfect sense, ta
00:58:08 <quicksilver> osfameron: or you want to run the same "action" with different lexical envs.
00:58:37 <quicksilver> (maybe you'd find the point more convincing when you consider reader as just one 'aspect' of a more complex monad, too?)
00:58:50 <osfameron> good point about lexical envs
00:59:03 <osfameron> quicksilver: yeah, maybe, I'm still too scared to look at complex monads :-)
00:59:13 * dmwit points at local
00:59:21 <dmwit> :t local
00:59:24 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
01:00:44 <quicksilver> osfameron: if you're thinking "but really this is just a shared parameter to all the functions"
01:00:49 <quicksilver> then, yes, that's exactly what it is.
01:00:58 <quicksilver> and in simple cases, Reader doesn't even save typing.
01:01:13 <osfameron> ok
01:01:21 <quicksilver> but it does save typing in some complex cases, and it also lets you use generic Monad m => combinators.
01:01:37 <quicksilver> some of which are useful, like mapM_ or zipWithM
01:01:39 <quicksilver> say.
01:03:09 <osfameron> quicksilver: shiny, I will get onto looking at those soon I hope
01:03:37 <osfameron> quicksilver: if you have time/interest, I'd appreciate any comments you have on my latest lambdacamellish post on monads in perl
02:18:09 <mm_freak_work> @pl \c -> init . foldr (\x ys -> x:c:ys) []
02:18:10 <lambdabot> (init .) . flip foldr [] . flip ((.) . (:)) . (:)
02:18:47 <opqdonut> mm_freak_work: isn't that just intersperse?
02:18:55 <mm_freak_work> opqdonut: almost
02:19:02 <mm_freak_work> it's undefined for the empty list
02:19:08 <opqdonut> ah
02:19:17 <mm_freak_work> i was just curious about what it would look like points-free
02:19:25 <mm_freak_work> and i wonder if @pl is that smart…
02:19:51 <mm_freak_work> @pl \c xs -> if null xs then [] else (init . foldr (\x ys -> x:c:ys) [] xs)
02:19:51 <lambdabot> ap (flip if' [] . null) . ((init .) .) . flip foldr [] . flip ((.) . (:)) . (:)
02:20:31 <opqdonut> heh
02:20:36 <dmwit> ?pl \c xs -> drop 1 . foldr (\x ys -> c:x:ys) [] xs
02:20:36 <lambdabot> ((drop 1 .) .) . flip foldr [] . (. (:)) . (.) . (:)
02:20:59 <dmwit> > (\c xs -> drop 1 . foldr (\x ys -> c:x:ys) [] xs) 'a' "bbb"
02:21:00 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
02:21:30 <ziman> :t (***)
02:21:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:21:35 <dmwit> :t \c xs -> drop 1 . foldr (\x ys -> c:x:ys) [] xs
02:21:37 <lambdabot> forall a. [a] -> [[a]] -> [[a]]
02:21:57 <dmwit> > (\c xs -> drop 1 . foldr (\x ys -> c:x:ys) [] xs) "a" ["b", "b"]
02:21:59 <lambdabot>  ["","","",""]
02:22:06 <dmwit> hum
02:22:07 <ziman> > ((+1) *** (+2)) (1, 1)
02:22:08 <lambdabot>  (2,3)
02:22:37 <dmwit> :t foldr
02:22:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:23:19 <dmwit> :t \x -> foldr (\a b -> x:a:b)
02:23:21 <lambdabot> forall a. a -> [a] -> [a] -> [a]
02:23:33 <dmwit> :t \x -> foldr (\a b -> x:a:b) []
02:23:34 <lambdabot> forall a. a -> [a] -> [a]
02:23:52 <dmwit> oh... (.) vs ($)
02:24:11 <dmwit> > (\c -> drop 1 . foldr (\x ys -> c:x:ys) []) 'a' "bbb"
02:24:11 <ziman> > second (drop 1) . break (== '=') $ "abc=def"
02:24:13 <lambdabot>  "babab"
02:24:13 <lambdabot>  ("abc","def")
02:24:18 <dmwit> > (\c -> drop 1 . foldr (\x ys -> c:x:ys) []) 'a' ""
02:24:19 <lambdabot>  ""
02:24:22 <dmwit> Yes!
02:24:40 <Itkovian> Damnit! When will the sysadmin learn that he should not bloody shut down the main work access machine! Grmbl!
02:25:15 <Zao> Itkovian: He'll learn when you apply the emergency stop sledgehammer on his machine.
02:25:43 <Itkovian> Zao: I'm working from at home, so that might be a tad difficult.
02:35:40 <solrize> is there something like cabal install these days?
02:38:01 <Saizan> solrize: cabal install?
02:38:12 <Saizan> ?hackage cabal-install
02:38:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
02:38:16 <mauke> a barrel roll
02:38:57 <solrize> thanks should i use it in preference to running setup.lhs for each package?
02:39:16 <solrize> i had the impression it was still under development and not really ready
02:39:23 <solrize> that's what i was asking about basically
02:39:35 <quicksilver> cabal install is the thing most like cabal install, though
02:39:37 <quicksilver> there is no doubt.
02:39:52 <quicksilver> I believe it is useful. It may not be free of bugs.
02:39:54 <Saizan> ah, well dcoutts realesed that yeasterday, it's quite stable
02:41:25 <solrize> hey quicksilver, would you mind looking at another one of those file formats i'm trying to read with data.binary?
02:41:33 <solrize> http://hpaste.org/8310
02:41:56 <solrize> notice the Maybe (x,y) in the middle
02:42:08 <solrize> the point is that field is only in the file if DocStoreOffset has a particular bit set
02:42:32 <solrize> so i'm wondering if you have advice about handling that
02:43:05 <quicksilver> with a custom instance.
02:43:12 <quicksilver> this is why you need custom instances in general.
02:43:49 <quicksilver> so you can make bits conditional on other bits
02:43:52 <solrize> ic, sigh.
02:44:28 <solrize> should i use parsec?  this file will be pretty small, though some of the other ones are large
02:45:03 <quicksilver> I don't think you should use parsec, no.
02:45:09 <quicksilver> I think the way you are doing it is fine.
02:45:15 <solrize> ok
02:45:19 <quicksilver> why are you so scared of writing a custom instance for this bit? :)
02:45:35 <solrize> it just seems ugly to have to do that
02:45:46 <quicksilver> I would name that long tuple (SegName,....,IsCompoundFile)
02:46:02 <solrize> name it?
02:46:06 <quicksilver> yes.
02:46:20 <solrize> you mean like { x : (...)} ?
02:46:23 <quicksilver> data SingleSegement = SingleSegment SegName SegSize DelGen ....
02:46:28 <solrize> oh i see
02:46:34 <quicksilver> and then you just have to write a custom instance for SingleSegmant
02:46:43 <solrize> yeah that makes sense
02:47:16 <solrize> and i could actually split that into several tuples
02:47:30 <solrize> read the start and end tuples with the automatic instance
02:47:44 <solrize> and use a bit from the start tuple to decide whether to read the Maybe
02:47:44 <quicksilver> get = do { sn <- get; ss <- get; dg <- get; dso <- get; mdss <- if dos .&. BIT then Just <$> get else return Nothing;
02:47:46 <solrize> this isn't too bad
02:47:49 <solrize> yeah
02:48:20 <quicksilver> I don't think it's ugly to have to encode the peculiarity of the file format
02:48:24 <quicksilver> you've got to do that somehow.
02:48:36 <quicksilver> I do agree with the person yesterday who said a declarative DSL for file formats would be nice.
02:48:39 <quicksilver> It would.
02:48:47 <quicksilver> but in the absence of writing one of those, this is fine :)
02:48:49 <solrize> that's sort of what parsec is, no?
02:52:07 <solrize> hmm looks like i can write  get = do { (sn,ss,dg,dso) <- get; mdss <- if dos .&. BIT then ... ; (hsn,nf,ng,icf) <- get }
02:52:20 <solrize> if i have that tuple instance like we talked about
02:54:25 <quicksilver> Yes.
02:54:31 <quicksilver> I think you probably can
02:54:50 <quicksilver> don't forget "return SingleSegment sn ss dg dso mdss hsn nf ng icf
02:54:51 <quicksilver> ;)
02:55:01 <solrize> right :)
03:09:53 <solrize> @src Word32
03:09:53 <lambdabot> Source not found. Sorry.
03:10:47 <frevidar> is there a way to import a module so its functions override the prelude?
03:11:07 <mauke> no
03:11:22 <frevidar> in particular, I don't want to have to qualify all my uses of Data.List.Stream
03:11:28 <solrize> import Prelude hiding (....)   ?
03:11:35 <solrize> then import the module
03:11:36 <EvilTerran> import Prelude hiding (...)
03:11:36 <frevidar> solrize: I was thinking that
03:11:44 <EvilTerran> yeah, that's the way forward
03:12:00 <frevidar> as in, ... are all the names I want to hide?
03:12:08 <solrize> yeah
03:13:57 <frevidar> coolies
03:13:58 <frevidar> thanks
03:16:05 <EvilTerran> frevidar, or you can just "import qualified Data.List.Stream as S" - then the qualifiers are nice and short
03:16:37 <frevidar> evilTerran: yeah, I think I'll do that
03:18:03 <quicksilver> I think the import export hiding stuff isn't *quite* clever enough.
03:18:09 <quicksilver> Although I'm not 100% sure how to fix it.
03:18:28 <quicksilver> It is annoying that if you import somethign which overrides chunks of the Prelude (normally its' Foldable and Traversable, in my case)
03:18:36 <quicksilver> then (a) you have to hide them from Prelude
03:18:47 <quicksilver> (b) you then have to hide those things form the Prelude that Control.Monad re-exports
03:18:58 <quicksilver> (c) ... repeat for Control.Monad.*
03:23:32 <Syzygy|de> DRMacIver: You're being missed over at EFNet.
03:29:18 <solrize> haskell seems to fall out of my brain if i don't use it for a while
03:32:07 <osfameron> solrize: yeah definitely
03:32:18 <solrize> that doesn't happen as much with other languages
03:34:24 <Saizan> maybe because these other languages are more similar to each other than they are to haskell
03:35:24 <solrize> haskell has a bigger memory footprint
03:35:45 <solrize> anyway i'm sleepy, i'll mess with this some more during the weekend, i think it's making more sense now
03:37:20 <quicksilver> haskell doesn' thave a bigger memory footprint, IMO.
03:37:25 <quicksilver> OO languages have a massive memory footprint.
03:37:34 <quicksilver> but as Saizan says, the others are more alike.
03:39:11 <osfameron> OO languages the things you have to remember are often method names etc., which are easily browsable in the IDE
03:39:17 <solrize> python is OO and it's much simpler than haskell
03:39:36 <solrize> i played with leksah for a few minutes, maybe i should start actually using it
03:39:53 <quicksilver> I don't think python is much simpler than haskell.
03:40:01 <quicksilver> just different.
03:40:23 <quicksilver> it has its own peculiarities (reference semantics, value semantics, exception handling, generators)
03:40:30 <osfameron> most languages are more susceptible to brute force techniques than haskell
03:40:47 <osfameron> when needing to get something done quickly in desperation, without thought of elegance etc.
03:41:05 <quicksilver> I think that is only true because the desperate person has experience of imperative coding.
03:41:24 <quicksilver> My experience with teaching people who have never programmed before is that the notion of imperative coding is not particularly natural.
03:41:34 <quicksilver> (I'm not trying to claim functional is more natural. Neither is)
03:41:34 <solrize> haskell's footprint for me is in dealing with the type system
03:41:47 <solrize> one could imagine an imperative language with similar types
03:41:53 <quicksilver> scala
03:41:59 <quicksilver> ocaml
03:42:07 <opqdonut> mmhmm
03:42:13 <solrize> scala, yow, the demon spawn of java and ML ?
03:42:30 <quicksilver> thesis: any imperative language with similar types to haskell will be 5 chars long.
03:42:40 <solrize> heh
03:42:42 <quicksilver> groovy has a few haskell like features as I recall.
03:42:45 <quicksilver> some type inference and stuff?
03:42:46 <solrize> disciple ?
03:42:54 <smg> what are the great benefits of using haskel instead of a non-functional language?
03:43:01 <quicksilver> your code works.
03:43:24 <smg> quicksilver: in java it won't?
03:43:30 <solrize> so i have this type   data X = X Foo Bar [Baz]
03:43:31 <quicksilver> it permits more flexible kinds of abstraction and modularisation, increases code reuse, and reduces runtime errors,
03:43:40 <smg> i see
03:43:41 <solrize> that i want to read with this data.binary thing
03:43:56 <solrize> and the Baz list can be very large so i don't want to read it all
03:44:10 <solrize> i have a way of computing the disk address of say, the 15 millionth element
03:44:42 <opqdonut> why not use an array then?
03:44:45 <opqdonut> or a sequence
03:45:02 <quicksilver> well it sounds like [Baz] is wrong then.
03:45:06 <quicksilver> sounds like you want
03:45:15 <quicksilver> MyDiskBackedArray Baz
03:45:22 <solrize> hmm
03:45:29 <quicksilver> I.e. you want another type which indicates you will read at demand from disk.
03:45:42 <solrize> yeah
03:45:52 <quicksilver> [Baz] indicates that all the data is there, really.
03:45:56 <solrize> right
03:46:04 <quicksilver> even unsafely interleaving IO you could at best leave off a final chunk
03:46:14 <quicksilver> you'd still end up forcing the spine up to 15 millionth
03:46:14 <solrize> right
03:46:16 <solrize> yeah
03:46:26 <solrize> that's where my question was going
03:47:39 <solrize> thanks
03:47:44 <smg> lol
03:47:57 <smg> instructor says [1..] will evaulate till i turn off my pc :)
03:49:37 <Deewiant> :t [1..]
03:49:38 <solrize> if i get more serious i'd want MyDiskBackedArray to have an LRU cache
03:49:38 <lambdabot> forall t. (Enum t, Num t) => [t]
03:49:42 <Deewiant> hmh
03:49:44 <quicksilver> smg: yes.
03:49:51 <Deewiant> doesn't it default to Int?
03:49:53 <quicksilver> solrize: indeed. you think of all kids of tricks.
03:49:58 <quicksilver> Deewiant: Integer.
03:50:12 <quicksilver> > length ([1..]::[Word8])
03:50:12 <smg> quicksilver: i guess i get memor overflow?
03:50:13 <lambdabot>  255
03:50:19 <quicksilver> smg: depends how you use it.
03:50:27 <quicksilver> smg: if you "print" it, then, no.
03:50:34 <smg> k
03:50:39 <kaol> > [1..] `seq` "done"
03:50:40 <quicksilver> if you just print it to a terminal it shouuld run for ever.
03:50:40 <lambdabot>  "done"
03:50:48 <quicksilver> > length ([1..]::[Word16])
03:50:49 <lambdabot>  65535
03:50:54 <quicksilver> > length ([1..]::[Word32])
03:50:56 <lambdabot> Terminated
03:50:58 <quicksilver> ;(
03:52:56 <mauke> > length ['\1' ..]
03:52:57 <lambdabot>  1114111
03:53:15 <solrize> should that be straightforward to code, i.e. data MyDiskBackedArray = StateT (IO FileHandle) Data.IntMap   or something like that, where the intmap is the cache and i juggle stuff in and out of it?
03:53:21 <frevidar> is there a function like scanr that doesn't return the last element?
03:53:23 <solrize> i mean State, not StateT
03:53:37 <quicksilver> well you probably do mean StateT actually
03:53:41 <quicksilver> StateT IO
03:53:48 <solrize> hmm
03:53:50 <quicksilver> to do the actual IO in.
03:54:00 <quicksilver> frevidar: init (scanr ... )
03:55:39 <solrize> still this doesn't sound so bad.  doing all these formats is a few 100 lines of haskell instead of many kloc of java
03:55:56 <solrize> spewed across dozens of source files
03:56:00 * quicksilver nods
03:56:52 <smg> if i have exercise: define a list comprehension, then i write f x = [list_compr] ? i don't think so...
03:57:50 <solrize> i think python and haskell would be about the same amount of code but i was hoping the haskell version would be more self-maintaining (i.e those Get monads that combine automatically)
03:58:02 <solrize> smg i don't understand the question
03:58:15 <smg> forget :)
03:58:18 <smg> my instructor sucks
03:58:52 <Saizan> solrize: to be picky, the monad is Get, what you're referring to with monads are called actions or monadic functions
03:58:57 <osfameron> solrize: yeah, but I bet you could do it with a Perl oneliner ;-P
03:59:22 <solrize> lol
04:00:05 <smg> solrize: the task was : write a list comprehension to double all elements
04:00:08 <nus> and then cut that line half with APL?-)
04:00:29 <solrize> double_all_elements xs = [2*x | x <- xs]
04:00:30 <smg> but he wanted a recursive function
04:00:30 <nus> smg, so what did you wrote?
04:00:52 <smg> i don't see why i need to write a map function when in the exercises there is written write a list comprehension
04:00:53 <smg> -.-
04:00:54 <smg> kinda funny
04:01:38 <hjon> perhaps your teacher wanted to show you the relation between map and list comprehension :p
04:01:40 <quicksilver> solrize: the haskell version will be less buggy
04:01:56 <quicksilver> solrize: because the type system will convey invariants which you can accidentally break in python.
04:02:15 <quicksilver> solrize: e.g. in python you have nested dictionaries/arrays/tuples and there would be nothing to guarantee it had the right 'shape'
04:02:16 <solrize> right
04:02:19 <solrize> yeah
04:02:26 <quicksilver> of course, maybe you never make mistakes, and your code is bug free
04:02:31 <solrize> haha
04:02:31 <quicksilver> in which case this is not an issue :)
04:02:35 <quicksilver> for me, however, it is...
04:03:04 <solrize> right, that's what i mean about generating the code automatically to read those nested structures
04:03:13 <quicksilver> I've programmed in perl for many years (And python a bit, on the side) and it's the lack of any way of specifying types which I dislike the most.
04:03:29 <ivanm> heh
04:03:52 <ivanm> how about dynamic introduction of variables (AKA stuffing up using typos)?
04:04:02 <quicksilver> use strict helps there.
04:04:03 <smg> hjon: no he is just....
04:04:13 <quicksilver> but then you start using hashes to pass around groups of variables
04:04:19 <quicksilver> and use strict can no longer help you.
04:04:26 <solrize> $$x = "foo"
04:04:27 <solrize> arggh!!
04:04:33 <quicksilver> (this idiom is also popular in python I believe: passing around groups of variables in dictionaries)
04:04:38 <osfameron> well you could use Moose to easily create structs with appropriate accessors
04:04:42 <quicksilver> you can indeed.
04:04:51 <quicksilver> Moose can get you a long way towards a useful type system.
04:04:56 <osfameron> (but of course the problem is that most of the time you don't and do indeed just pass hashes...)
04:05:08 <solrize> ever use ada?  why does everyone hate it so much?
04:05:10 <quicksilver> Moose is great.
04:05:22 <quicksilver> to be fair, Moose is fairly recent and most of my years of perl experience are pre-moose.
04:05:28 <quicksilver> some of them are even pre-nested hashes :)
04:05:34 <osfameron> eeeek!
04:05:40 * quicksilver wassa perl4 programmer.
04:05:44 <Botje> all good programming languages have four letters or more
04:05:50 <smg> quicksilver: wassa :)
04:05:55 <smg> quicksilver: you know "Wasa"?
04:06:34 <quicksilver> Oh, by the way, I tested print (length ([1..]::(Word32)) here
04:06:35 <solrize> does lambda have six letters or one?
04:06:44 <quicksilver> it took 7 minutes 32 seconds.
04:06:47 <quicksilver> that's pretty disappointing.
04:06:59 <mauke> hmm, this excludes C, C++, Ada, PL/I, PHP ... what else?
04:07:07 * osfameron thinks he might well end up being a Haskell/F#/Erlang programmer at some point, however right now, in North of England, the number of Perl jobs is non-zero, which is better than the functional ones... :-(
04:07:10 <quicksilver> 450 seconds to count to 4billion.
04:07:51 <solrize> what did the core look like?
04:07:58 <quicksilver> that's, erm, 100ns per count?
04:08:03 <solrize> not consing 4 billion nodes i hope
04:08:15 <quicksilver> which is 50 cycles on this 2Ghz machin.
04:08:22 <quicksilver> is that math right?
04:08:31 <solrize> 200 cycles
04:08:34 <quicksilver> no. 200 cycles.
04:08:34 <quicksilver> thanks.
04:08:52 <solrize> but why did it stop at 4 billion?
04:08:57 <solrize> instead of wrapping around?
04:08:59 <quicksilver> (Word32)
04:09:12 <quicksilver> of course, amusingly the answer is -1 ;)
04:09:13 <quicksilver> but that's OK.
04:09:16 <solrize> > length ([1..]::(Word8))
04:09:17 <lambdabot>  Couldn't match expected type `Word8' against inferred type `[a]'
04:09:24 <solrize> > length ([1..]::[Word8])
04:09:25 <lambdabot>  255
04:09:41 <mauke> > length ([1..] :: [Int8])
04:09:42 <lambdabot>  127
04:09:43 <solrize> ic, enumFromTo stops when it gets to the end of the type
04:10:56 <quicksilver> well you can define an instance doing whatever you want.
04:11:04 <quicksilver> but that's the way the instances on the standard types do, yes
04:11:17 <quicksilver> they behave as if it was [1..maxBound]
04:11:22 <solrize> yeah
04:11:32 <quicksilver> yes, it really is consing the nodes.
04:11:36 <quicksilver> I thought it would fuse
04:11:42 <solrize> -O2 ?
04:11:52 <quicksilver> it hasn't even inlined GHC.Word.$wintegralEnumFrom1
04:12:01 <quicksilver> so you don't even get unpacked ints.
04:12:13 <mmorrow> omg http://hpaste.org/8313
04:12:25 <mmorrow> screenshot http://code.haskell.org/~morrow/code/images/jsrepl.png
04:12:31 <quicksilver> I wonder if Int is any better.
04:12:36 <quicksilver> maybe that inlines better.
04:14:45 <solrize> hee
04:14:49 <solrize> mmorrow
04:14:57 <mmorrow> weee
04:15:32 <solrize> ireland rejected the eu treaty
04:16:03 <quicksilver> solrize: yes. 34s
04:16:16 <quicksilver> solrize: so even allowing for the list being half as long, that's 7 times faster.
04:16:23 <quicksilver> down from 200 cycles to 30. more reasonable indeed.
04:16:33 <quicksilver> Word32 must fail to inline in a way Int does.
04:16:45 <solrize> 30 cycles still sounds terrible
04:16:48 <solrize> are the ints unboxed?
04:17:22 <quicksilver> no, it's a true list.
04:17:28 <quicksilver> Main.lvl1 :: [GHC.Base.Int]
04:17:33 <solrize> k
04:17:33 <quicksilver> Main.lvl1 = GHC.Enum.eftInt 1 2147483647
04:17:54 <pastorn> hasell.org looks like shit, what font does it use?
04:17:58 <quicksilver> dons: is there some circumstance in which GHC can unroll [1..] into a listless loop?
04:18:02 <pastorn> +k
04:18:10 <quicksilver> looks fine to me.
04:18:15 <quicksilver> some san serif font.
04:18:18 <quicksilver> Verdana maybe?
04:18:38 <pastorn> it looks like a japanese website with english text
04:18:45 <mmorrow> lol
04:19:20 <mauke> ｙｏｕ ａｒｅ ｎｏｗ ｂｒｅａｔｈｉｎｇ ｍａｎｕａｌｌｙ
04:19:24 <quicksilver> looks like it renders as "your default sans font" or something
04:19:30 <maltem> pastorn: Bad browser settings?
04:19:31 <quicksilver> for me its' -webkit-sans
04:19:32 <sieni> mauke: WTF was that?
04:19:44 <sieni> quicksilver: how can you disable that in irssi?
04:19:54 <sieni> s/quicksilver/mauke/
04:19:59 <mauke> disable what?
04:20:25 <sieni> mauke: so that I won't see that kind of visual abuse
04:20:52 <mauke> how is it abuse?
04:21:07 <Saizan> sieni: they are just unicode characters
04:21:18 <sieni> O_O
04:22:06 <solrize> are things like drift and syb heavyweight contraptions that should only be used for complex problems?  or is it sane to use them on fairly lightweight stuff like what i'm doing
04:22:17 <sieni> what kind of characters are those? :-o
04:22:31 <mauke> U+FF55 (ef bd 95): FULLWIDTH LATIN SMALL LETTER U [ｕ]; U+FF41 (ef bd 81): FULLWIDTH LATIN SMALL LETTER A [ａ]
04:22:32 <quicksilver> solrize: given what you're doing I'd be inclined to write it by hand first :)
04:22:51 <quicksilver> solrize: and worry about clever tricks when you have it working.
04:22:53 <sieni> mauke: why on earth are there such characters in unicode?
04:23:04 <mauke> ☃
04:24:00 <ivanm> I know that I found some weird star-like one in dejavu that I use as a seperator in xmobar ;-)
04:24:12 <sieni> oh, it's a snowman
04:24:15 <ivanm> sieni: so my guess is because they can :p
04:24:16 <mauke> ≛⋆★☆✯☪✡✪✭✰٭✦✧✩✫✬✮✴✵✶✹⍟⍣✷✸❂
04:24:16 <Botje> sieni: asian text (which has fat^Wwide characters) that doesn't want their text to look like shit
04:24:16 <sieni> looked like a condom
04:24:19 <ivanm> is it? I can't make it out...
04:24:44 <Botje> http://www.fileformat.info/info/unicode/char/2603/browsertest.htm
04:24:44 <lambdabot> Title: Browser Test Page for Unicode Character 'SNOWMAN' (U+2603)
04:25:50 <pastorn> actually what i _was_ looking for was the list of companies that employs haskell, but i can't seem to find it
04:26:09 <Botje> http://haskell.org/haskellwiki/Haskell_in_industry
04:26:09 <lambdabot> Title: Haskell in industry - HaskellWiki
04:26:13 <solrize> @go galois
04:26:14 <lambdabot> http://en.wikipedia.org/wiki/%C3%89variste_Galois
04:26:21 <pastorn> Botje: thanks :)
04:26:24 <Botje> oh my
04:26:34 <Botje> that page sure has grown since .. january
04:26:37 <mauke> C♯, Haskeλλ and Java☕
04:27:06 <Botje> I'd like Java\snowman better
04:27:06 <pastorn> mauke: niiiiiiiiiiiice :D
04:29:01 <solrize> is there a coffeecup symbol?
04:30:44 <ivanm> they actually have a java coffee cup symbol in unicode? :o
04:33:51 <Botje> it's called "HOT BEVERAGE"
04:34:39 <smg> hrhr
04:36:18 <m4DN3ss> i need help with haskel
04:36:41 <Zao> m4DN3ss: Unasked questions rarely get answered.
04:37:03 <m4DN3ss> i need to make function that will eliminate all empty characters (space, : or ;) from inputed string
04:37:14 <Zao> m4DN3ss: Let me guess, you have the third assignment for the programming languages course at the Big University of Croatia?
04:37:20 <Botje> <3
04:37:23 <BeelsebobWork_> lol
04:37:23 <m4DN3ss> :D
04:37:34 <BeelsebobWork_> m4DN3ss: questions about Homework don't get answered
04:37:37 <Botje> sure looks like that
04:37:41 <BeelsebobWork_> questions about the language do
04:38:07 <Zao> m4DN3ss: You should read up on pattern matching with functions.
04:38:16 <m4DN3ss> any good link?
04:38:29 <Zao> I'd say YAHT, probably.
04:39:18 <ivanm> @where yaht
04:39:18 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:39:26 <ivanm> m4DN3ss: ^^
04:39:45 <m4DN3ss> tnx :)
04:40:57 <quicksilver> it's not actually true that questions about homework don't get answered.
04:41:19 <quicksilver> the policy is here : http://www.haskell.org/haskellwiki/Homework_help
04:41:21 <ivanm> it depends how bored everyone is!
04:41:21 <lambdabot> Title: Homework help - HaskellWiki
04:41:36 <ivanm> @quote homework
04:41:36 <lambdabot> newsham says: I think the problem with people asking homework questions in this channel is that the people in this channel don't have enough homework questions of their own to do
04:41:59 <byorgey> questions ABOUT homework get answered.  questions CONSISTING OF homework don't (shouldn't).
04:43:55 <m4DN3ss> any idea how to cut white spaces from string, once i load it?
04:44:02 <Zao> m4DN3ss: Yes.
04:44:56 <quicksilver> You will want to investigate the function "filter"
04:44:59 <quicksilver> for example
04:45:03 <m4DN3ss> tnx :D
04:45:08 <quicksilver> > filter (>5) [1,2,3,4,5,6,7,8,9]
04:45:09 <lambdabot>  [6,7,8,9]
04:45:14 <Zao> quicksilver: I have a feeling the assignment like all the others contain the clause "no silly library functions" :)
04:45:25 <quicksilver> > filter (/= 'a') "abcdabcab"
04:45:26 <lambdabot>  "bcdbcb"
04:45:37 <quicksilver> could be. Filter is often allowed.
04:45:47 <quicksilver> fortunately the source for filter is publically available
04:45:56 <quicksilver> so if you're not allowed to use it you can look at how it works
04:45:59 <quicksilver> @src filter
04:45:59 <lambdabot> filter _ []     = []
04:45:59 <lambdabot> filter p (x:xs)
04:45:59 <lambdabot>     | p x       = x : filter p xs
04:45:59 <lambdabot>     | otherwise = filter p xs
04:46:02 <ivanm> Zao: you mean direct list walking?
04:46:24 <Zao> ivanm: It would most likely be enlightening if the goal is to introduce recursion and pattern matching.
04:46:25 <m4DN3ss> yep need to make my own filter, but this will help
04:47:25 <matthew-_> you could do it with fold
04:47:40 <matthew-_> it's a hetamorphism isn't it?
04:48:10 <nus> ♻ Ha∮ke≸ code
04:52:20 <marcot> I've just installed etch and the ghc 6.8.2 binary as user.  I'm trying to build the darcs version of Cabal, but I got this, when I run ghc --make Setup:
04:52:25 <marcot> /usr/bin/ld: cannot find -lgmp
04:52:31 <marcot> It's strange cause libgmp3c2 is installed
04:52:39 <marcot> ii  libgmp3c2                         4.2.1+dfsg-4                      Multiprecision arithmetic library
04:55:04 <quicksilver> apparently that's not the version you compiled ghc against
04:55:05 <Zao> marcot: ldd the ghc binary and see what version it tries to load?
04:55:11 <quicksilver> if you don't have gmp-dev installed
04:55:16 <quicksilver> it probably compiled against the internal version
04:55:20 <quicksilver> (is there still an internal gmp?)
04:55:29 <marcot> sure, I need gpm-dev
04:55:40 <mauke> the mouse daemon?
04:55:48 <marcot> Thanks.
05:12:14 <seanmce> join #thunderbird
05:12:37 <seanmce> oops, sorry
05:16:38 <ivanm> should that be #thunderbirds ? :p
05:22:48 <Axman6> wow, darcs at 1.08GB RAM :|
05:23:22 <int-e> what are you doing?
05:23:48 <mauke> "darcs add /dev/urandom"
05:23:59 <BeelsebobWork_> rofl
05:24:18 <BeelsebobWork_> Axman6: what version of darcs? 1.x or 2?
05:24:23 <Axman6> 2
05:24:27 <opqdonut> heh
05:24:30 <BeelsebobWork_> and what are you adding?
05:24:33 <BeelsebobWork_> or doing?
05:25:14 <Axman6> initial commit (yes?) of a 250MB dir
05:25:24 <BeelsebobWork_> how bizare
05:25:31 <opqdonut> indeed
05:25:40 <BeelsebobWork_> and that's "real" memory, not OS X's read out of virtual memory?
05:25:45 <Axman6> yep
05:26:45 <Axman6> it got to 1624/1640 changes, and kinda stopped
05:27:56 <Axman6> and it's doing it again...
05:32:14 <maltem> darcs is crap for large initial commits. just don't do them
05:33:03 <marko_> hi all
05:33:28 <wolverian> maltem, or fix darcs. :)
05:33:35 <wolverian> (or, use another scm.)
05:33:53 <maltem> fair enough
05:34:54 <int-e> From my superficial reading of the code, darcs habitually keeps whole pristine trees in memory - as a cache, but it's not hard to make it read in the whole tree.
05:36:34 <maltem> marko, be welcomed
05:36:59 <Itkovian> Any idea how to get the latest ghc without upgrading gcc tot 4.3.x on gentoo?
05:37:34 <maltem> Itkovian: Download from haskell.org?
05:38:31 <kosmikus> Itkovian: does the ghc ebuild have a dependency on gcc-4.3?
05:38:35 <mauke> Itkovian: huh? why would you upgrade gcc to 4.3?
05:38:50 <Itkovian> mauke: I would not, but emerge tells me it would like to
05:38:56 <mauke> sounds unlikely
05:39:05 <mauke> I'm on ghc-6.8.2 and gcc-4.1.2
05:40:35 <mauke> also. 4.3.* is masked
05:42:11 <mauke> what exactly did you unmask?
05:42:12 <mm_freak_work> Itkovian: i have the latest GHC and GCC 4.1.2
05:42:37 <mm_freak_work> gcc is ACCEPT_KEYWORDS="x86" here
05:42:38 <Itkovian> mauke: I tried ACCEPT_KEYWORDS="~x86" USE="binary" emerge -up ">=dev-lang/ghc-6.8.2"
05:42:52 <mm_freak_work> almost everything else is ~x86
05:43:57 <mauke> er, don't
05:45:06 <mauke> echo 'dev-lang/ghc' >>/etc/portage/package.keywords; echo 'dev-lang/ghc binary' >>/etc/portage/package.use
05:45:17 <mauke> emerge -va ghc
05:45:38 <Botje> Itkovian: setting ACCEPT_KEYWORDS to ~x86 is effectively saying "install all newest versions this package depends on"
05:46:19 <Itkovian> Botje: Oops, I always figured it told portage to install even if it can break
05:48:16 <Botje> that too
05:49:00 <Botje> nowadays you're better off doing what mauke suggested
05:53:16 <Itkovian> darcs is still busy checking in Jikes RVM.
06:26:42 <dcoutts> solrize: I released cabal-install-0.5.0 on hackage yesterday
06:27:11 <dcoutts> dons: nice
06:44:30 <tobias_tud> does anyone know how to show a data Bla = X Int | Y (IOArray Int Int)?
06:44:44 <Botje> you can't, i think
06:45:15 <tobias_tud> i tried it and it doesn't work, but i would like to know the content of my var :-)
06:45:22 <tobias_tud> any idea?
06:45:35 <Saizan> tobias_tud: to read from an IOArray you need to be in IO
06:45:35 <maltem> It would be showIO :: Bla -> IO String
06:45:52 <Botje> tobias_tud: you'll have to implement show yourself
06:46:02 <Botje> with an unsafePerformIO for the Y case
06:46:10 <maltem> bah
06:46:29 <Botje> i don't think it's too bad for his app
06:46:30 <maltem> We all hate unsafePerformIO, did you forget that already?
06:46:39 <maltem> well I don't know his app
06:46:41 <Botje> it has its uses
06:46:51 <Botje> and if he just wants to use this for debugging, why not
06:46:55 <quicksilver> tobias_tud: your array doesn't exist.
06:46:55 <Botje> can always remove it later
06:47:02 <tobias_tud> it doesnt matter, my code is ugly. i dont think this makes the code more unreadable
06:47:21 <maltem> Botje: While debugging he will be in IO anyway
06:47:21 <quicksilver> tobias_tud: the array just a reference.
06:47:39 <quicksilver> tobias_tud: it only has values at a particular point in time (i.e. in IO)
06:48:07 <quicksilver> as an academic exercise I'd be interested to know how the show solution works, but I suspect a naive unsafeperformIO would reguarly show incorrect values
06:48:15 <quicksilver> being either before or after the time you thought you were checking.
06:48:26 <Botje> maltem: i've used Debug.Trace enough to know it's damn handy
06:48:30 <Botje> @quote oasis
06:48:30 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
06:48:41 <quicksilver> personally I'd just write showIO :: Bla -> IO String
06:49:00 <quicksilver> I've not used Debug.Trace enough to know how rarely it is needed :)
06:49:03 <maltem> Botje: sure, but not in this case, I don't think
06:49:15 <Botje> i guess
06:49:18 <tobias_tud> okay, im looking for Data.Trace and showIO, perhaps it's easy to implement. thank you all for your help
06:49:19 <quicksilver> Debug.Trace is mostly enlightening as a tool to demonstrate when evaluation happens.
06:49:32 <Botje> agreed
06:49:39 <maltem> tobias_tud: You only need one of the two :)
06:49:42 <quicksilver> as a tool to print debug statements I find it over-recommended and under-useful.
06:50:03 <Botje> it sure beats the ghc debugger
06:50:22 <Botje> which has a rather annoying interface imo
06:50:30 <Peaker> quicksilver, how else to debug? I tried the ghc debugger and it was very disappointing
06:50:31 <maltem> tobias_tud: And in case that wasn't evident, showIO is a function you'll have to write yourself
06:50:34 <tobias_tud> cool, there is a ghc debugger? :-)
06:50:48 <tobias_tud> i really should learn the tools before start coding
06:50:51 <Axman6> tobias_tud: ever had anyting break while using ghc?
06:51:07 <Peaker> I think an FP can be MUCH easier to debug, but gdb/c pdb/python is easier than debugging Haskell :(
06:51:09 <Botje> hmmm
06:51:15 <atsampson> quicksilver: I use it most often when I've profiled a program and found something expensive is being evaluated more often than it ought to be, in order to find out where/how often...
06:51:25 <maltem> tobias_tud: The most important tool is ghci. At least it isn't disputed
06:51:42 <Botje> feature request for GHC: when complaining about a failed pattern match, show the expression that failed
06:51:45 <quicksilver> atsampson: exactly.
06:51:57 <quicksilver> Botje: I've never used the GHC debuger and rarely missed it.
06:52:17 <quicksilver> Peaker: I debug programs almost exclusively by evaluating functions or calling actions from ghci
06:52:20 <bd_> Botje: which expression?
06:52:23 <Axman6> Botje: i'd like to see that too
06:52:29 <quicksilver> Peaker: building up (or down) to a counterexample.
06:52:49 <therp> botje: that requires every data type to implement an instance of Show. For some strange reason, Haskell decided not to do that.
06:52:53 <ToRA> Botje: nah, you want GHC to complain more reliably when you have incomplete patterns so it never happens at runtime
06:53:07 <quicksilver> Peaker: I find this much more effective than traditional imperative techniques most of the time.
06:53:20 <therp> ToRA: doesn't it do that already with the -Wall switch?
06:53:24 <quicksilver> Peaker: for heavily IO-sequenced code I do use the tried and tested "stick putStrLn everywhere" I admit.
06:53:39 <ToRA> therp: mostly, it's not perfect though.  Doesn't understand GADTs properly for a start :(
06:54:05 <Peaker> quicksilver, what if you have a lot of existing code, and it has some infinite recursion somewhere, and you don't know where?
06:54:18 <quicksilver> Peaker: then I call the functions
06:54:22 <quicksilver> Peaker: until I find the recursion.
06:54:54 <quicksilver> Botje: that would  be handy but it's hardly a showstopper
06:55:02 <quicksilver> Botje: it's trivial to add a case to your function
06:55:06 <Botje> of course
06:55:19 <quicksilver> f a b c = error $ "f called with invalid args" ++ show (a,b,c)
06:55:21 <Botje> but when it's 4 am and you mis-type a case in your case statement
06:55:29 <quicksilver> agreed.
06:55:32 <quicksilver> definitely useful.
06:55:47 <quicksilver> but the workaround is pretty quick.
06:55:53 <Botje> indeed
06:56:31 <Botje> and then you fatfinger that case and put it in the case statement of the last of the outer case
06:56:43 <Botje> which puzzled me for a good fifteen minutes
06:56:50 <Botje> (this is why you don't develop at night, kids)
06:57:00 <quicksilver> ;)
06:57:30 <quicksilver> therp: it would be very handy if there was some cheating internal class DebugShow
06:57:39 <quicksilver> therp: which GHC *could* derive an instance for for every single thing.
06:57:42 <atsampson> Data is nearly as good
06:57:55 <quicksilver> therp: even if the instance was bad in some way, or even non-ref-transparent.
06:58:05 <atsampson> (and I've got a pretty-printing show that works on any Data thing that's pretty handy)
06:58:05 <Botje> also, is there an easy way to return from a call and skip all subexpressions in the function?
06:58:09 <quicksilver> (the code could be generated only with the -debug flag)
06:58:35 <quicksilver> atsampson: I quite often work with stuff which isn't Data though.
06:58:37 <Botje> dammit #haskell, stop being interesting
06:58:45 <Botje> i have non-haskell code (ie crap) to write :(
06:58:47 <quicksilver> atsampson: everything which can derive Data can also derive Show, can't it?
06:59:23 <atsampson> quicksilver: I dunno, but that sounds reasonable
06:59:24 <therp> quicksilver: sorry, I don't get your first sentence. why would it be hard to derive DebugShow? We can already derive Show automatically
06:59:44 <atsampson> quicksilver: I've got quite a lot of stuff for which I've had to write Data and it saves me writing Show too ;)
07:00:01 <therp> quicksilver: the only problem why we might not want to do that automatically is with circular data types such as circular lists.. but there a ways and means to print even these without running into a loop.
07:00:29 <Saizan> therp: functions?
07:01:03 <quicksilver> therp: functions, IO
07:01:08 <quicksilver> therp: all the things we can't derive Show for.
07:01:09 <therp> Saizan: ah right...
07:01:22 <quicksilver> most of my interesting data types are non-showable.
07:01:38 <quicksilver> atsampson: why did you have to write Data?
07:01:43 <quicksilver> atsampson: what's wrong with deriving Data?
07:02:26 <EvilTerran> you can't derive it for GADTs, i believe
07:03:09 <BeelsebobWork_> I never understood why functions aren't Showable actually -- the specific functions you may want to Show have always been build from bits of source you've got sat there -- so why not just stick them together
07:03:36 <Saizan> well derived Data can break encapsulation
07:04:13 <quicksilver> BeelsebobWork_: because it breaks referential transparency
07:04:35 <BeelsebobWork_> quicksilver: hmm? can you give me an example where it would?
07:05:34 <quicksilver> http://www.haskell.org/haskellwiki/Show_instance_for_functions
07:05:35 <lambdabot> Title: Show instance for functions - HaskellWiki
07:05:49 <love^_^me> can any one help me how to make own server ? MIrc new server
07:05:52 <love^_^me> love^_^me is using [IRCop ScripT ] by love^_^me
07:06:22 <twobitwork> you're looking to write an irc server in haskell?
07:06:49 <love^_^me> no i want to make a new server
07:07:02 <Peaker> he just spammed #python with some mIRC scripts and other crap
07:07:05 <love^_^me> i knw how to make all scripts but i dun knw how to make own server
07:07:10 <quicksilver> this channelis for the discussion of the haskell language
07:07:10 <Botje> did the same thing on #perl
07:07:15 --- mode: ChanServ set +o quicksilver
07:07:16 <twobitwork> this channel is for people who are interested in programming in the haskell language
07:07:18 <BeelsebobWork_> quicksilver: hmm, okay, it breaks referential transparency, if you say a function is entirely defined by in's semantics
07:07:18 <Botje> love^_^me: UNREALIRCD. NOW STOP SPAMMING RANDOM CHANNELS
07:07:22 <BeelsebobWork_> which I'm not certain it is
07:07:26 <atsampson> quicksilver: "deriving Data" doesn't get dataCast1 right for parameterised types (or it used not to, anyway)
07:07:27 <love^_^me> Botje i need help
07:07:31 <love^_^me> :S
07:07:34 <quicksilver> atsampson: interesting.
07:07:36 <Botje> yes you do. you're spamming.
07:07:52 <love^_^me> Botje i need help
07:07:55 --- mode: quicksilver set +b *!*=love___m@116.71.174.*
07:07:56 --- kick: love^_^me was kicked by quicksilver (quicksilver)
07:08:00 <twobitwork> yay
07:08:35 <twobitwork> someone who obviously doesn't know a damn thing about IRC wants to start their own server.... *sigh*
07:08:50 <twobitwork> and now he msging me
07:08:51 <quicksilver> BeelsebobWork_: referential transparency says that I can replace (+2) with (\x -> x + 2) in any context
07:09:00 <quicksilver> BeelsebobWork_: and this will not change the meaning of the program.
07:09:02 <therp> @Show_Instances_from_functions: the problem that show (λx.x+x)!= show(λx. 2*x) is far from convincing..
07:09:02 <lambdabot> Unknown command, try @list
07:09:11 <quicksilver> BeelsebobWork_: the obvious show instance would change that.
07:09:12 <BeelsebobWork_> quicksilver: ah yeh, fair point
07:09:25 <BeelsebobWork_> the example on website is not the same as that
07:09:35 --- mode: quicksilver set -o quicksilver
07:09:36 <BeelsebobWork_> and is much less convincing
07:09:42 <quicksilver> therp: consider this :
07:09:52 <quicksilver> g f = (show f, f 2)
07:10:03 <quicksilver> g :: (Int -> Int) -> (String,Int)
07:10:18 <quicksilver> g (+2) is now different from g (\x -> x+2)
07:10:23 <quicksilver> this breaks r.t.
07:10:24 <therp> HsSyn would be more elegant than String but go ahead :)
07:10:40 <quicksilver> nonetheless, I think that a (r.t.-violating) class like this would be useful for debugging.
07:10:50 <quicksilver> which is why I suggest it be enabled only with the -debug flag.
07:11:39 <therp> quicksilver: +2 is just syntax sugar for \x -> x+2. I would argue that syntax sugar should be stripped before "tying" function definitions to closures.
07:11:52 <quicksilver> then take a more complex example
07:11:57 <quicksilver> add2 x = x + 2
07:12:10 <quicksilver> is (g add2) different from (g (+2))
07:12:16 <quicksilver> ?
07:12:35 <quicksilver> what about (2+) and (+2)
07:12:45 <quicksilver> these are, in a sesne, different algorithms for the same function.
07:12:51 <quicksilver> referentially they are the same.
07:12:55 <BeelsebobWork_> (2+) and (+2) *are* different even from the point of view of referential transparency
07:12:55 <therp> hmm, if we rewrite add2 x = x + 2, to add2 = \x -> x+2 (I don't remember if the haskell report actually specifies this)
07:13:00 <BeelsebobWork_> the others are not though
07:13:06 <quicksilver> BeelsebobWork_: are they? show me how?
07:13:12 <quicksilver> observe a different between them.
07:13:20 <quicksilver> s/nt/nce/
07:13:25 <BeelsebobWork_> the language says nothing about the symetry of (+)
07:13:26 <therp> quicksilver: referentially they are only the same if you define referentially for two functions f and f' as forall x. f x = f' x
07:13:31 <BeelsebobWork_> so you can make no proof that they are the same
07:13:39 <BeelsebobWork_> operationally, they are -- but you can't prove it
07:13:47 <BeelsebobWork_> same reason the example on the website is unconvincing
07:13:48 <therp> quicksilver: this definition is in my opinion quite ok but probably not in this case..
07:13:56 <BeelsebobWork_> it relies on a mathematical property that the language doesn't enforce
07:15:01 <quicksilver> BeelsebobWork_: that's not relevant.
07:15:06 <quicksilver> BeelsebobWork_: I am speaking semantically.
07:15:13 <quicksilver> semantically they are the same function Int -> Int
07:15:16 <BeelsebobWork_> yes -- but referential transparency isn't about that
07:15:18 <quicksilver> that's all that matters for this purpose.
07:15:28 <quicksilver> Yes is it. referential transparency is precisely about semantics.
07:15:41 <quicksilver> it says that you can replace a term with another term, if they have the same denotation.
07:15:46 <BeelsebobWork_> referential transparency is about things that are *provably* equal having the same effect in a program
07:15:54 <BeelsebobWork_> not about things that are equal only in the mind of the programmer
07:16:04 <quicksilver> things which are semantically equal are indeed provably equal.
07:16:11 <quicksilver> the semantics is a form of proof.
07:16:14 <BeelsebobWork_> the semantics of Haskell do not define that (2+) and (+2) are equal
07:16:24 <quicksilver> the semantics of (+) does.
07:16:31 <BeelsebobWork_> no it doesn't
07:16:34 <quicksilver> yes it does.
07:16:38 <quicksilver> (this is like monty python)
07:16:41 <BeelsebobWork_> show me where in the spec it says it's symetric
07:16:44 <BeelsebobWork_> yeh, it is a bit
07:16:48 <EvilTerran> is (+) necessarily symmetric even in the case of floating point numbers?
07:16:49 <BeelsebobWork_> I asked for an argument!
07:16:58 <quicksilver> denotationally, (+2) is denotated by a function from Int -> Int
07:17:02 * EvilTerran suspects so, but isn't sure
07:17:06 <quicksilver> this is a simple mathematical object.
07:17:13 <BeelsebobWork_> EvilTerran: entirely plausable that it isn't actually
07:17:19 <quicksilver> it's a set of pairs from the finite set Int x Int
07:17:22 <quicksilver> and they are both the same.
07:17:23 <Saizan> BeelsebobWork_: think of Int's or Integer's (+), no need to take polymorphism in this argument
07:17:44 <quicksilver> referential transparency has (need have) nothing to do with syntax and proof systems.
07:17:48 <BeelsebobWork_> Saizan: yes there is -- this is a polymorphic function
07:17:53 <quicksilver> it is something you can frame entirely in the semantic domain.
07:18:04 <quicksilver> BeelsebobWork_: no, I'm working with the monomorphic function Int -> Int
07:18:08 <quicksilver> I specified that upfront.
07:18:17 <BeelsebobWork_> yes -- but the point is that the Hasell spec does not tell you tha t the semantics of the (+) function are symetric
07:18:17 <quicksilver> g :: (Int -> Int) -> (String,Int)
07:18:23 <BeelsebobWork_> so you can't assume they are
07:18:33 <BeelsebobWork_> you certainly can tell me that (\x -> x + 2) and (+2) are the same function
07:18:38 <quicksilver> the haskell report does not define the semantics of haskell.
07:18:38 <BeelsebobWork_> but you can't tell me than (2+) is as well
07:18:48 <quicksilver> nonetheless everyone knows what the semantics of haskell is.
07:18:55 <quicksilver> well not quite everyone. But I do, and you do.
07:19:18 <BeelsebobWork_> yes, and I'm as EvilTerran is, unconvinced that (+) is symetric (in for example the Float case)
07:20:04 <quicksilver> I'm not talking about Float.
07:20:09 <quicksilver> I'm talking about Int.
07:20:10 <Saizan> BeelsebobWork_: add = (+) :: Int -> Int, is add symmetric?
07:20:13 <BeelsebobWork_> no, you're talking about (+)
07:20:21 <quicksilver> I'm talking about (+2) :: Int -> Int
07:20:21 <BeelsebobWork_> and (+)'s type is Num a => a -> a -> a
07:20:25 <BeelsebobWork_> not Int -> Int -> Int
07:20:29 <quicksilver> I did specify my types carefully up front.
07:20:43 <quicksilver> 15:10 < quicksilver> g :: (Int -> Int) -> (String,Int)
07:20:43 <quicksilver> 15:10 < quicksilver> g (+2) is now different from g (\x -> x+2)
07:20:44 <EvilTerran> it has been said repeatedly "considering only the Int->Int->Int case"
07:21:03 <BeelsebobWork_> you did that
07:21:08 <BeelsebobWork_> sorry, I missed that
07:21:18 <BeelsebobWork_> so there was a good amount of monty python for no reason >.<
07:21:21 <edwardk> saizan/quicksilver: it fails to be symmetric because of _|_
07:21:30 <edwardk> oh wait
07:21:33 <edwardk> no in +'s case
07:21:37 <edwardk> its symmetric there too
07:21:40 <BeelsebobWork_> yep
07:21:43 <edwardk> isn't it? its strict in both args
07:21:47 <therp> hmm how about zero != 0, with zero = (let rec n = rec n/2 in rec 10)?
07:21:47 <edwardk> so it should be fine
07:22:46 <therp> can they be argued to be the same using fixed point argument?
07:22:54 <chr1s> dcoutts: ping
07:24:17 <Saizan> therp: rec n is just _|_ i'd say
07:24:22 <therp> because quicksilver's argument rests on the referential transparency of functions defined as f=f' <=> forall x.f x = f' x. that's equivalent to checking FIX f = FIX f'. so I'm asking whether FIX zero = FIX 0?
07:25:19 <Saizan> zero is not a function..
07:25:43 <quicksilver> you can't FIX zero
07:25:47 <quicksilver> zero doesn't have any arguments.
07:25:53 <quicksilver> zero :: Double
07:25:56 <edwardk> zero isn't broken, you can't fix it.
07:25:59 <quicksilver> and its denotation is _|_
07:26:00 <quicksilver> quite.
07:26:06 <therp> er, I probably meant FIX rec.
07:26:16 <b_jonas> doesn't referential transparentiality mean that if x equals x' then f x equals f x' ?
07:26:20 <quicksilver> it's simpler to reason about referential transparency denotational in my experience
07:26:20 <therp> in comparison with FIX (const 0)
07:26:26 <b_jonas> oh, I see
07:26:26 <quicksilver> b_jonas: yes it (also) means that.
07:26:33 <b_jonas> the other variant is just a special case
07:26:36 <quicksilver> therp: no, they are not equal.
07:26:46 <quicksilver> zero is _|_ and 0 is 0.
07:26:58 <quicksilver> if you're fond of denotational brackets
07:27:08 <quicksilver> [[zero]] = _|_ while [[0]] = 0
07:29:33 * ronwalf is mister newbie-using-too-many-language-extensions-man
07:29:57 <ziman> @hoogle (<$>)
07:29:57 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
07:30:35 <therp> if we have rec n = rec (n/2), that equal to rec = FIX (\f n -> f (n/2)) right ?
07:31:16 * ronwalf makes the ghc's type system break down and cry
07:34:06 <ronwalf> oh darn, the type system was right....
07:34:32 <ronwalf> Does anyone play with Wouter's datatypes?
07:34:59 <dcoutts_> chr1s: pong
07:39:12 <quicksilver> therp: yes that's right
07:41:05 <ziman> > fix (const 0)
07:41:08 <lambdabot>  0
07:45:17 <nolrai_> @pl \op f g x -> op (f x) (g x)
07:45:17 <lambdabot> liftM2
07:45:36 <nolrai_> :t on
07:45:38 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:46:10 <nolrai_> :t liftM2
07:46:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:46:58 <edwardk> Hrmm. I just realized my understanding of dialgebras was pretty flawed.
07:47:57 <nolrai_> :t not . (&&)
07:47:58 <lambdabot>     Couldn't match expected type `Bool'
07:47:58 <lambdabot>            against inferred type `Bool -> Bool'
07:47:58 <lambdabot>     Probable cause: `&&' is applied to too few arguments
07:48:39 <nolrai_> :t on
07:48:41 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:53:01 <nolrai_> :t negate
07:53:03 <lambdabot> forall a. (Num a) => a -> a
07:53:39 <tusho> I read (Num a) as (Numa)
07:54:56 <chr1s> dcoutts_: what's the state of c2hs these days?
07:55:09 <chr1s> dcoutts_: how much of the generation can be automated?
07:55:25 <dcoutts_> chr1s: what kind of generation?
07:55:38 <chr1s> I'd like to generate a .hs file from a c header file while doing the minimum possible amount of work.
07:55:56 * BMeph gives tusho a hearty "Numa numa iai!"
07:56:06 <chr1s> I don't mind haskell hacking, but I don't really like to go into all these C files
07:56:16 <dcoutts_> chr1s: so it doesn't do things like generating bindings to all functions in a header file, but it does make it fairly easy to do that yourself.
07:56:26 <chr1s> ah, ok.
07:56:33 <dcoutts_> chr1s: but you do have to list the functions you want to bind, it doesn't just bind everything.
07:56:41 <chr1s> ah
07:56:50 <dcoutts_> chr1s: {# call foo_bar #} args
07:57:02 <dcoutts_> and it generates the ffi import with the correct types
07:57:15 <chr1s> dcoutts_: and it also does structs, right?
07:57:31 <dcoutts_> chr1s: depends if you want structs by value or by reference
07:57:44 <chr1s> dcoutts_: I see.
07:57:47 <dcoutts_> by reference/pointer it's pretty good, that's what gtk2hs uses
07:57:52 <nolrai_> @hoogle (a,a) -> [a]
07:57:53 <lambdabot> No matches, try a more general search
07:58:03 <nolrai_> @hoogle range
07:58:04 <lambdabot> Data.Ix.range :: Ix a => (a, a) -> [a]
07:58:04 <lambdabot> Language.Haskell.TH.Range :: data Range
07:58:04 <lambdabot> Language.Haskell.TH.Syntax.Range :: data Range
07:58:06 <dcoutts_> chr1s: if you want Storable instances for C structs then c2hs doesn't help that much with that.
07:58:26 <quicksilver> by opaque reference, you mean, dcoutts_ ?
07:58:29 <dcoutts_> yes
07:58:37 <quicksilver> for passing back to later native calls
07:58:40 <chr1s> dcoutts_: thanks. I'll go back to my header file and see how far I can get.
07:58:40 <dcoutts_> yes
07:59:04 <dcoutts_> chr1s: what are you binding btw?
07:59:18 <chr1s> I'm trying to generate a module that binds to the uw-imap c-client library.
07:59:23 <mar77a> how do i extract "pull out" the IO result of getDirectoryContents
07:59:33 <chr1s> as I haven't found a binding yet, and I can't find a good haskell-library that does imap.
07:59:35 <mar77a> say i want something like: getfiles dir = getDirectoryContents dir
07:59:43 <mar77a> but i want the list, not the IO list
07:59:46 <dcoutts_> chr1s: right
08:00:04 <dcoutts_> mar77a: time to learn about the IO monad.
08:00:07 <chr1s> dcoutts_: the interface is pretty big, see http://www.washington.edu/imap/documentation/internal.txt.html
08:00:08 <lambdabot> Title: UW IMAP software--UW IMAP Server Documentation
08:00:16 <mar77a> i'm on it :<
08:00:30 <dcoutts_> mar77a: basically: do files <- getDirectoryContents dir; return (something files)
08:00:46 <mar77a> o_O
08:00:55 <mar77a> i thought return actually put the thing in an IO
08:00:59 <chr1s> if I make it, I'll release it on hackage.
08:01:18 <dcoutts_> mar77a: it does, but that 'something' there is a pure function [FilePath] -> Whatever
08:01:27 <dcoutts_> mar77a: which means the overall thing is type IO Whatever
08:01:34 <mar77a> which is what i don't want
08:01:43 <mar77a> i want a function of type String -> [String]
08:01:59 <chr1s> mar77a: you can not do that, it *has* to be in the IO monad.
08:02:09 <mar77a> boo :<
08:02:27 <nolrai_> :t concatMap
08:02:29 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:02:32 <chr1s> mar77a: once you've programmed with it for a while, you'll learn to appreciate it.
08:03:59 <mar77a> yeha i was told..i'm already starting to get how's the deal
08:04:56 <dcoutts_> chr1s: mm, it's not a small spec
08:04:58 <ertai> > 1%2
08:04:59 <lambdabot>  1%2
08:07:01 <ertai> where can I find documentation about this % in 1%2? it's rationals right?
08:07:23 <SamB> @index %
08:07:24 <lambdabot> Data.Ratio
08:07:29 <SamB> @docs Data.Ratio
08:07:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
08:07:55 <chr1s> dcoutts_: exactly, but as there's not really an alternative
08:08:07 <chr1s> well, there is a SoC project, maybe I should look into that.
08:08:20 <dcoutts_> chr1s: is there? oh
08:08:31 <chr1s> dcoutts_: http://darcs.haskell.org/SoC/haskellnet/
08:08:32 <lambdabot> Title: Index of /SoC/haskellnet
08:08:52 <quicksilver> mar77a: a function of type String -> [String] always returns the same list of strings when given the same input
08:09:05 <quicksilver> mar77a: whether it's run on your machine, in my machine, tomorrow, yesterday, etc.
08:09:06 <dcoutts_> chr1s: ah, the imap bit
08:09:13 <quicksilver> mar77a: this people call a "pure function"
08:09:14 <chr1s> yeah.
08:09:23 <mar77a> so it would be illegal to do what i want to
08:09:27 <quicksilver> mar77a: your function evidently depends on hard disk contents
08:09:31 <quicksilver> so its correct type is
08:09:35 <quicksilver> String -> IO [String]
08:09:46 <mar77a> and it can't be made String -> [String]
08:09:48 <quicksilver> "How I Stopped Worrying And Learned To Love IO"
08:09:51 <quicksilver> correct.
08:09:56 <quicksilver> String -> [String] is the wrong type :)
08:10:22 <mar77a> ok thanks
08:10:49 <dcoutts_> chr1s: yeah, ask the author about that. I've no idea how complete it is.
08:11:05 <dcoutts_> chr1s: that's a pure haskell impl it looks like
08:11:32 <quicksilver> chr1s: IMAP is such a lovely protocol
08:11:45 <quicksilver> and there are no email programs that actually do it justice
08:11:55 <quicksilver> serverside searching, low bandwidth change notifications
08:12:01 <quicksilver> a haskell lib for it might be fun
08:12:02 <dcoutts_> chr1s: another C lib is tinymail which is supposed to be designed to have language bindings
08:12:19 <quicksilver> dcoutts_: it may be hardly worth it.
08:12:23 <quicksilver> dcoutts_: IMAP is mostly sexps
08:12:27 <quicksilver> it's super-easy to parse
08:12:28 <chr1s> dcoutts_: ah, nice.
08:12:31 * Peaker thinks protocols and API's should be interchangable
08:12:47 <chr1s> quicksilver: are you sure? I've heard virtually all servers behave differently.
08:12:50 <quicksilver> a library might help with the multipart stuff I guess.
08:12:53 <Peaker> we should have one library/infrastructure that can pass an API over a network, and ignore the difference from then on
08:13:02 <quicksilver> chr1s: Ah, that's beyond my expertise. I only tried the simple stuff.
08:13:11 <mar77a> do i have to write my own find substring function?
08:13:14 <quicksilver> chr1s: message list, server side search, idle notifications.
08:13:19 <quicksilver> mar77a: isInfixOf
08:13:27 <EvilTerran> ?hoogle index
08:13:28 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
08:13:28 <lambdabot> Data.ByteString.index :: ByteString -> Int -> Word8
08:13:28 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
08:13:35 <EvilTerran> ?hoogle find
08:13:35 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
08:13:36 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
08:13:36 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
08:13:39 <EvilTerran> hmm
08:14:17 <EvilTerran> ?type findIndex
08:14:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
08:14:37 <mar77a> isInfixOf does the task
08:15:06 <EvilTerran> ?type \xs -> findIndex (xs `isPrefixOf`) . tails -- will give you the index
08:15:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
08:15:22 <EvilTerran> ?type \xs -> findIndices (xs `isPrefixOf`) . tails -- or, if you want multiple matches...
08:15:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Int]
08:17:03 <nolrai_> hoogle (a,b) -> (b, a)
08:17:08 <nolrai_> @hoogle (a,b) -> (b, a)
08:17:08 <lambdabot> No matches, try a more general search
08:17:26 <Peaker> @pl f (a, b) = (b, a)
08:17:26 <lambdabot> f = uncurry (flip (,))
08:17:27 <quicksilver> chr1s: I wouldn't be surprised to hear the reality falls short of the bold ideals of the spec :)
08:17:49 <quicksilver> of course, I fear a C library binding to a SEXP based format would be clumsy when accessed from haskell
08:17:56 <quicksilver> probably lost the attractive structure
08:18:00 <chr1s> quicksilver: yeah, I saw it a couple of times when googling.
08:18:09 <EvilTerran> nolrai_, (uncurry (flip (,))) and (snd &&& fst) are the pointsfree versions
08:18:33 <EvilTerran> nolrai_, but i personally would just define "swap ~(x,y) = (y,x)" at the toplevel and be done with it
08:19:40 <quicksilver> funnily enough I don't find you need "swap" as often as you might think.
08:19:50 <edwardk> of course there is always the category extras version, where it has to go through two typeclasses to tell you how to swap ;)
08:19:55 <EvilTerran> ?type snd &&& fst
08:19:56 <lambdabot> forall a b. (a, b) -> (b, a)
08:20:10 <Peaker> snd &&& fst   is pretty cool ;)
08:20:32 <Peaker> much easier to understand than uncurry $ flip (,), imo
08:20:34 <edwardk> quicksilver: if you permit weaker categories than Hask you need it a lot.
08:20:35 <EvilTerran> quicksilver, i find it odd, actually, that there isn't something defined in Control.Arrow, seeing as it seems to be used in the de-sugaring
08:20:55 <EvilTerran> Peaker, yeah, although people will look at the type of (&&&) and get scared ;)
08:21:10 <edwardk> its in the categorical derivation, but Control.Arrow doesn't provide it because it can be rederived through arr/pure.
08:21:25 <EvilTerran> ?type arr snd &&& arr fst
08:21:26 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) (b, a)
08:21:43 <cjay> edwardk: what does the ~ do?
08:21:47 <EvilTerran> edwardk, Control.Arrow provides plenty of things that can be derived, though
08:22:06 <EvilTerran> > let foo (x,y) = "this breaks" in foo undefined
08:22:07 <lambdabot>  "Exception: Prelude.undefined
08:22:14 <EvilTerran> > let foo ~(x,y) = "this works" in foo undefined
08:22:15 <lambdabot>  "this works"
08:22:18 <edwardk> cjay: ~ makes the pattern 'irrefutable' which means that even if the pair itself turns out to be bottom you're safe unless you look at either of the sides of the resulting pair.
08:22:47 <edwardk> heh, my version of swap: http://comonad.com/haskell/category-extras/src/Control/Category/Braided.hs
08:22:48 <lambdabot> http://tinyurl.com/5lbrqq
08:22:54 <edwardk> perhaps a wee bit too verbose.
08:23:08 <edwardk> but that one works for Either and (,) over (->) and in some other categories.
08:23:09 <cjay> thanks
08:23:56 <Peaker> is it important for Haskell to preserve bottoms?  Someone here said   reverse . reverse cannot be rewritten to id because of that.  Wouldn't it be better to not guarantee bottoms and allow such rewrites?
08:23:56 <edwardk> cjay take for instance swap undefined. if you didn't have an irrefutable pattern, the program would crash, with the irrefutable pattern the output is a pair of bottoms.
08:24:24 <EvilTerran> cjay, the point is that, when a value is being matched against a pattern to decide which branch to take, the part of the value corresponding to a ~(...) in the pattern need not be evaluated
08:24:38 <HKhan> hey everyone, ummmm where does one get the lambdabot-utils module? >.<
08:24:39 <edwardk> peaker: i find it important to not introduce bottoms, i don't care if you give me back a function that is more defined than the one i gave you
08:24:57 <EvilTerran> > let foo ~(Just x) = 1 in foo Nothing -- this works
08:24:58 <lambdabot>  1
08:25:10 <mar77a> http://hpaste.org/8317 i still don't get how to bypass this
08:25:11 <Peaker> edwardk, so why can't reverse.reverse -> id?
08:25:11 <EvilTerran> > let foo ~(Just x) = x in foo Nothing -- but, in this, x is _|_
08:25:12 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
08:25:17 <mar77a> probably something like filterM?
08:25:36 <EvilTerran> Peaker, ISTR dcoutts agrees with you. reverse.reverse -> id is a "refinement", i think he'd say :P
08:25:49 <Peaker> ISTR?
08:25:52 <edwardk> peaker: i'm pretty sure it is sound. laugh at the person who told you no next time ;)
08:25:52 <quicksilver> Peaker: yes, many people argue that refinements are safe.
08:25:54 <EvilTerran> "i seem to recall"
08:26:12 <quicksilver> however, a refinement is still a semantic change.
08:26:20 <dcoutts_> yep
08:26:21 <Peaker> but ghc doesn't do such refinements, because of bottom preservation, no?
08:26:23 <quicksilver> changing a non-terminating program to a terminating one is a pretty big change.
08:26:30 <quicksilver> ghc does some refinements as far as I know.
08:26:32 <nolrai_> mar77a: "<-"  needs to be inside of a do block.
08:26:42 <edwardk> quicksilver: sure, but requiring strict equality in all your rewrite rules quickly leaves you with nothing to rewrite ;)
08:26:58 <Peaker> quicksilver, I think its legitimate to convert a non-terminating program to a terminating one. Guaranteeing non-termination is not important, imo
08:27:04 <mar77a> hm
08:27:10 <EvilTerran> dcoutts, you use "toStream.fromStream = id" in your stream fusion even if it's more of a [= than a =, right?
08:27:33 <EvilTerran> (or whatever the functions are called)
08:27:42 <Peaker> wouldn't it be nice if we could add optimization rewrite rules in user code? :)
08:27:54 <EvilTerran> i believe we can, as a GHC pragma
08:28:14 <quicksilver> most of the rewrite rules are in user code
08:28:17 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
08:28:17 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
08:28:23 <quicksilver> it's one of GHC's most remarkable/powerful features
08:28:25 <Peaker> ah cool thanks
08:28:34 <quicksilver> it's how bytestring was possible
08:28:41 <quicksilver> (bytestring fusion, that is)
08:29:05 <cjay> EvilTerran: I see, but it's hard to imagine where it could be useful. I have never carried around undefined values in my code.
08:29:11 <nolrai_> mar77a: or you could use liftM. getLogs cwd = liftM (filter isLog) getDirectoryContents cwd
08:29:35 <dcoutts_> EvilTerran: right, the problem with stream . unstream is that it turns _|_ streams into const _|_ streams.
08:30:01 <mar77a> i got it somehow else
08:30:24 <mar77a> nolrai_: http://hpaste.org/8318 how does that look
08:30:24 <nolrai_> ok
08:30:54 <ziman> what's the url length threshold after which lambdabot provides a tinyurl?
08:31:28 <dcoutts_> EvilTerran: which is bad, because it means if we swap stream . unstream for id then it actually introduces _|_, so it's not a refinement, quite the reverse.
08:31:43 <dcoutts_> because what used to be const _|_ is now _|_
08:31:59 <nolrai_> It looks good.
08:32:12 <dcoutts_> EvilTerran: so we have to avoid making _|_ streams at all, ever.
08:38:00 <mar77a> now why doesn't this work: http://hpaste.org/8319
08:38:10 * byorgey throws chocolate lambda sprinkles
08:38:21 <gwern> woot, tor finally got unblocked
08:38:55 <quicksilver> mar77a: mapM is a monadic function
08:39:03 <quicksilver> you want logSp <- mapM logSplit logs
08:39:05 <gwern> so, anyway. I had a productive night last night cleaning up my mueval program, and it now whitelists modules
08:39:11 <gwern> so it is essentially functional
08:39:13 <quicksilver> mar77a: I'm 99% sure I said that yesterday.
08:39:16 <mar77a> doh
08:39:23 <byorgey> @type mapM
08:39:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:39:26 <mar77a> yeah probably..i have a short term memory loss problem
08:39:30 <quicksilver> mar77a: in future, though, please paste the error message along with the error :)
08:39:36 <gwern> (which makes me happy, since I can do a release today probably if I get my act together)
08:39:38 <mar77a> sure
08:39:40 <quicksilver> it helps us find the problem quickly.
08:39:49 <byorgey> gwern: what is mueval?
08:39:58 <gwern> and thus far, it passes all the tests I've devised
08:40:05 <byorgey> releasing things is fun =)
08:40:27 <gwern> speaking of which, does anyone have any pathological code fragments that lambdabot correctly/safely handles?
08:41:04 <gwern> byorgey: a standlone interpreter using the GHC API which safely evaluates haskell code fragments/clone of lambdabot's >
08:41:17 <byorgey> gwern: ah, cool
08:41:24 <mar77a> :t foldl'
08:41:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:42:02 <gwern> test cases, people! I need'em
08:42:51 <mar77a> > foldl' (++) [] [[1],[2],[3]]
08:42:52 <lambdabot>  [1,2,3]
08:43:05 <mar77a> > foldl' (++) [] [[(1)],[(2)],[(3)]]
08:43:07 <lambdabot>  [1,2,3]
08:43:17 <mar77a> > foldl' (++) [] [[(1,1)],[(2,2)],[(3,3)]]
08:43:18 <lambdabot>  [(1,1),(2,2),(3,3)]
08:43:23 <RayNbow> > concat [[1],[2],[3]]
08:43:24 <lambdabot>  [1,2,3]
08:43:34 <byorgey> mar77a: you should probably use foldr for that rather than foldl
08:43:43 <mar77a> isn't foldl' faster or something
08:43:52 <RayNbow> it is strict
08:43:53 <byorgey> mar77a: using (++) left-associatively is slow
08:44:00 <byorgey> mar77a: it depends.  in this case, it isn't.
08:44:02 <mar77a> maybe i should use concat
08:44:10 <byorgey> @src concat
08:44:10 <lambdabot> concat = foldr (++) []
08:44:12 <byorgey> =)
08:44:13 <mar77a> ah
08:44:16 <mar77a> i was about to :p
08:44:18 <mar77a> ok ty
08:45:06 <RayNbow> mar77a: do you know why (++) is slow when you apply it in a left-assoc. way?
08:45:36 <mar77a> because the limit of the sequence (1 + 1/n)^n is e
08:46:07 <mar77a> "The last statement in a 'do' construct must be an expression", but the last statement is a print o_O
08:46:10 <mar77a> no idea RayNbow
08:46:21 <RayNbow> @src (++)
08:46:22 <lambdabot> []     ++ ys = ys
08:46:22 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:46:22 <lambdabot> -- OR
08:46:22 <lambdabot> xs ++ ys = foldr (:) ys xs
08:46:22 <lambdabot> -- In lambdabot, this is generalised to:
08:46:24 <lambdabot> (++) = mappend
08:46:26 <tromp> nothing to do with e:(
08:46:56 <RayNbow> (++) is O(n) where n is the length of the first operand
08:47:47 <RayNbow> so when you apply it left-associatively, the first operand is growing
08:47:49 <asmanian> when I want to devide a sum and a length which both are integers, how can I do that?
08:47:58 <asmanian> do I have to cast the ints to fractional somehow?
08:48:10 <quicksilver> mar77a: print is an expression
08:48:14 <quicksilver> mar77a: that's fine
08:48:25 <mar77a> http://hpaste.org/8320 maybe that'll help
08:48:29 <quicksilver> mar77a: that error normally menas the last statement is of the form "a <- b" instead of just "b"
08:49:00 <mar77a> strange
08:49:37 <mar77a> i can't see how it's of the form "a <- b"
08:49:58 <blsecres> @type liftM words
08:50:00 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m [String]
08:50:05 <quicksilver> actually this is a poor error message
08:50:05 <asmanian> @hoogle fromInt
08:50:06 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
08:50:06 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
08:50:13 <quicksilver> mar77a: the problem is the use of 'data'
08:50:17 <quicksilver> data is a reserved wrod.
08:50:28 <quicksilver> as you can see in hpaste because it's purple
08:50:32 <quicksilver> that's what is confusing the parser.
08:50:37 <blsecres> @type ( openFile "" ReadMode >>= hGetLine >>= )
08:50:39 <lambdabot> Not in scope: `openFile'
08:50:39 <lambdabot> Not in scope: data constructor `ReadMode'
08:50:39 <lambdabot> Not in scope: `hGetLine'
08:50:44 <mar77a> ah right
08:50:50 <nolrai_> @hoogle map
08:50:50 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
08:50:50 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
08:50:50 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
08:51:04 <quicksilver> :t unzip3
08:51:06 <lambdabot> forall a b c. [(a, b, c)] -> ([a], [b], [c])
08:51:11 <quicksilver> mar77a: incidentally
08:51:18 <blsecres> @type ( System.IO.openFile "" System.IO.ReadMode >>= System.IO.hGetLine >>= )
08:51:19 <lambdabot> forall b. (String -> IO b) -> IO b
08:51:28 <quicksilver> let (killers,victims,weapons) = unzip3 data
08:51:36 <quicksilver> mar77a: unzip3 does exactly what you're doing there :)
08:51:42 <blsecres> @type ( System.IO.openFile "" System.IO.ReadMode >>= System.IO.hGetLine >>= liftM words )
08:51:44 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
08:51:44 <lambdabot>       Expected type: Char -> b
08:51:44 <lambdabot>       Inferred type: String -> [String]
08:51:44 <quicksilver> mar77a: of course you're going to need to rename data.
08:51:53 <mar77a> yep, that did the trick
08:52:14 <blsecres> why is liftM words lifting into the List monad instead of the IO monad?
08:52:22 <quicksilver> blsecres: because that's what the type is, there.
08:52:33 <quicksilver> liftM has no choice, it has to use the type you ask for.
08:52:51 <mar77a> quicksilver++
08:53:02 <nolrai_> @ty Data.Map.lookup
08:53:03 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
08:53:36 <blsecres> OK, how do I ask to lift words into IO instead of List?  I've been poking around ListT and Trans but seem to be missing something fundamental
08:53:57 <quicksilver> blsecres: note that you were looking around for something of type (String -> IO b)
08:54:07 <quicksilver> blsecres: your last but one @type
08:54:20 <quicksilver> blsecres: liftM words has type IO String -> IO [String]
08:54:44 <Deewiant> @ty liftM words
08:54:46 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m [String]
08:55:12 <quicksilver> blsecres: you just want return . words
08:55:16 <quicksilver> :t return . words
08:55:17 <lambdabot> forall (m :: * -> *). (Monad m) => String -> m [String]
08:55:31 <quicksilver> that has the type you're after
08:56:37 <Zao> :t liftM words (readFile "foo.txt")
08:56:39 <lambdabot> IO [String]
08:56:43 <Zao> A-ha!
08:56:55 <paolino> :types liftM words $ ( System.IO.openFile "" System.IO.ReadMode >>= System.IO.hGetLine)
08:57:09 <paolino> too late
08:57:22 <idnar> heh
08:57:53 <paolino> @src liftM
08:57:53 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:58:24 <quicksilver> yes
08:58:28 <quicksilver> liftM is >>= . return
08:58:31 <quicksilver> speaking loosely
08:58:42 <quicksilver> so blsecres's problem was using both >>= *and* liftM
08:58:52 <quicksilver> which was, in effect, trying to unwrap two layers of monad
08:58:58 <quicksilver> you either use >>= (with return .)
08:59:06 <quicksilver> or you just use liftM (without >>=)
08:59:22 <paolino> how is fmap related to liftM ?
08:59:30 <Deewiant> fmap = liftM
08:59:36 <Apocalisp> ?type fmap
08:59:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:59:39 <Apocalisp> ?type liftM
08:59:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:59:48 <paolino> because monad is functor ?
08:59:49 <lilachaze> exccept not in standard haskell, since Monad isn't an instance of Functor, right?
08:59:57 <blsecres> heh, actually three, but I pared it down to a simpler case. thanks for forcing me to pay closer attention to the type signatures
08:59:57 <Deewiant> @instances Monad
08:59:58 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:59:58 <Deewiant> er
09:00:01 <Deewiant> @instances Functor
09:00:02 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:00:17 <Deewiant> hmph
09:00:33 <quicksilver> blsecres: ;)
09:00:35 <Deewiant> Monad m => Functor (WrappedMonad m)
09:00:41 <quicksilver> paolino: yes all monads should be functors
09:00:46 <quicksilver> it is a bug in the prelude that they are not.
09:00:58 <lilachaze> fmap and liftM could be different for the same type, but that'd be very strange
09:00:58 <quicksilver> but there are annoying-but-trivial reasons why people don't want to fix it.
09:01:35 <paolino> so one shouldn't use liftM
09:01:37 <Deewiant> how many custom Preludes are there out there? I've been thinking of writing my own (or at least designing one) for fun
09:01:48 <geezusfreeek> wait, i thought prelude did require functor, just not applicative?
09:02:10 <dcoutts_> geezusfreeek: neither sadly
09:02:12 <geezusfreeek> huh, guess not
09:02:17 <geezusfreeek> jeez
09:02:56 <paolino> @src WrappedMonad
09:02:57 <lambdabot> Source not found. Where did you learn to type?
09:03:05 <lilachaze> paolino: if you happen to have a monad which isn't an instance of Functor, then liftM would be fine. or if you want your type to be (Monad m) => rather than (Functor m) =>
09:03:50 <nolrai_> and if your in any of the existing monads then they are the same, right?
09:03:59 <geezusfreeek> heh this would explain why i sometimes have to do (Functor m, Monad m) =>
09:04:04 <nolrai_> s/your/you're
09:04:06 <quicksilver> yes.
09:04:24 <geezusfreeek> i was so sure that wasn't so, so it surprised me when i ran into that the other day
09:04:41 <geezusfreeek> but i didn't check the definition to verify i was wrong
09:05:42 <Peaker> I think Haskell needs class instances that are themselves classes. I'd call those "adapters".  Then:   adapter Functor Monad where fmap = liftM
09:05:57 <lilachaze> Can you construct >>= out of liftM and return?
09:06:10 <geezusfreeek> lilachaze: you need join to do that
09:06:20 <quicksilver> Peaker: how would those be different form superclasses?
09:06:20 <lilachaze> geezusfreeek: makes sense.
09:06:25 <Deewiant> m >>= f  ==  join (liftM f m)
09:06:46 <quicksilver> (which haskell already has)
09:06:50 <Deewiant> http://en.wikipedia.org/wiki/Monads_in_functional_programming#Alternate_formulation
09:06:51 <lambdabot> http://tinyurl.com/y586b9
09:06:58 <byorgey> lilachaze: if you just have liftM and return, you have what you might call a 'pointed functor'
09:07:10 * geezusfreeek prefers thinking of monads in terms of join rather than bind
09:07:26 <paolino> I don't understand, liftM is defined in term of >>= and return so it's valid for every monad, then what's the sense of not being Functor m => Monad m ?
09:07:35 <quicksilver> paolino: there is no sense in it.
09:07:36 <Peaker> quicksilver, you could add them retroactively
09:07:39 <nolrai_> :t fmap
09:07:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:07:45 <quicksilver> paolino: it's a bug.
09:07:58 <lilachaze> is it legal to define all instances of a class to be instances of another class? or is it an extension?
09:08:07 <paolino> ok
09:08:13 <lilachaze> legal being legal Haskell'98
09:08:15 <quicksilver> paolino: one of the reasons people don't want to do it is it would force you to write Functor instances for all Moands.
09:08:27 <quicksilver> paolino: to which I reply sarcastically "cry me a river"
09:08:33 <quicksilver> I.e. I don't think that's a problem.
09:08:38 <quicksilver> but some people apparently do.
09:08:40 <Peaker> quicksilver, also if Monad subclasses Functor, I'd have to define fmap, return and >>= on my Monadic types.  With such adapters, I'd only have to define return and >>=
09:08:41 <Apocalisp> That's such a tiny price to pay
09:09:04 <lilachaze> quicksilver: you mean, class (Functor m) => Monad m, rather than instance (Monad m) => Functor m?
09:09:15 <quicksilver> lilachaze: that is what I meant, yes.
09:09:24 <nolrai_> geezusfreeek: cojoin is definately better for comonads then cobind.
09:09:41 <quicksilver> lilachaze: as far as I can remember instance Monad m => Functor m is legal haskell98
09:09:45 <wjt> It's a shame that you can't have class (Functor m) => Monad m where fmap = ...
09:09:49 <lilachaze> quicksilver: perhaps my noobosity is showing here, but wouldn't the latter be better?
09:09:56 <quicksilver> but unfortunately it means that the *only* functors are monads.
09:10:03 <quicksilver> the only way you can be a functor is to be a monad.
09:10:07 <quicksilver> probably not what you want.
09:10:13 <quicksilver> (it overlaps with all other instances)
09:10:14 <wjt> that is, have default implementations for the prerequisite class's methods
09:10:21 <quicksilver> wjt: agreed.
09:10:26 <quicksilver> see also
09:10:27 <lilachaze> quicksilver: ah, right, you need the overlapping instances extension. got it.
09:10:30 <Peaker> quicksilver, the adapter would allow you to have types that are instances of Functor directly. it would just mean that all monads are automatically functors without having to define fmap
09:10:32 <quicksilver> @go john meacham class alias proposal
09:10:33 <lambdabot> http://repetae.net/recent/out/classalias.html
09:10:34 <lambdabot> Title: Class Alias Proposal for Haskell
09:10:39 <geezusfreeek> lilachaze: being a Functor is a _prerequisite_ for being a Monad, not the other way around
09:10:43 <quicksilver> Peaker: what do you do if both happens?
09:10:48 <quicksilver> Peaker: sounds like overlapping instances to me
09:10:49 <Peaker> wjt, but adapters are more powerful, I think
09:10:54 <quicksilver> which are uncomfortable.
09:11:17 <Peaker> quicksilver, you should not be allowed to define Monad and Functor on the same type, if there is an adapter already - because indeed liftM and fmap both exist, which is the "right" one?
09:11:29 <lilachaze> geezusfreeek: true, but the basic monadic operators don't include liftM, and you'd want to enforce that fmap = liftM somehow
09:11:29 <Peaker> quicksilver, or maybe have the direct instance override for optimization reasons (faster fmap than liftM)
09:11:50 <lilachaze> geezusfreeek: basic monadic operators in haskell's formulation, i mean
09:12:26 <geezusfreeek> lilachaze: why not just define liftM = fmap then?
09:12:32 <Baughn> @src Functor
09:12:32 <lambdabot> class  Functor f  where
09:12:33 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:12:39 <Peaker> quicksilver, the existence of an adapter can imply all that subclassing implies too, so adapters can replace subclasses, maybe
09:12:48 <geezusfreeek> lilachaze: if we were to require a Functor instance for Monad in the first place that would be possible
09:12:54 <Baughn> Mm. Seems to me having a Monad a => Functor a instance would work just fine
09:13:17 <geezusfreeek> Baughn: it would if you don't mind overlapping instances
09:13:45 <Baughn> geezusfreeek: Well, you'd have to edit the libraries a bit to remove those overlaps
09:13:48 <nolrai_> is there a fmapM?
09:13:53 <lilachaze> geezusfreeek: my point is that it should be the case that Monad m => liftM f == (>>= (return.f)), and it should be the case that Monad m => liftM = fmap
09:14:10 <lilachaze> geezusfreeek: i don't think you can achieve that with superclasses without reformulating Monad with different basic operators
09:14:11 <Peaker> you could say that the adapters form a graph, and you use a dijkstra path finding on that graph to find the "shortest" path to disambiguate.  direct instance distance is 0.  Each adapter can be assigned a "weight"
09:14:17 <geezusfreeek> Baughn: what if something is defined first as a functor but then it is discovered that it is also a monad? you would have to remove that functor instance
09:14:45 <geezusfreeek> lilachaze: and there are also the monad laws. haskell's type system isn't sufficient to enforce those
09:14:58 <Baughn> geezusfreeek: Or turn on overlapping instances for that file. Since they're identical, there should be no issues
09:15:05 <Peaker> geezusfreeek, you can disambiguate the multiple instances
09:15:10 <geezusfreeek> nolrai_: mapM in either Data.Foldable or Data.Traversable. i always mix those up
09:15:15 <Baughn> Although, having ghc accept identical overlapping instances automatically would be nice
09:15:17 <lilachaze> sure, but i'd prefer for there to be as few unenforced laws as possible. this *can* be enforced, and so I'd prefer it was
09:15:19 <EvilTerran> Baughn, Monad f => Functor f would overlap *every* other Functor instance
09:15:30 <nolrai_> @src mapM
09:15:31 <lambdabot> mapM f as = sequence (map f as)
09:15:31 <Peaker> Baughn, "identical" means isomorphic? undecidable?
09:15:35 <EvilTerran> seeing as overlaps don't take the class context into account
09:15:38 <geezusfreeek> lilachaze: it's also enforced simply by defining liftM = fmap
09:15:39 <nolrai_> @hoogle mapM
09:15:39 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:15:39 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:15:39 <lambdabot> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
09:15:53 <geezusfreeek> and also defining monads with join instead of bind
09:15:56 <lilachaze> geezusfreeek: that only enforces one of my two axioms
09:16:08 <Peaker> EvilTerran, what about Functor instances that aren't monads?
09:16:09 <lilachaze> yes, join instead of bind does the trick.
09:16:16 <Baughn> Peaker: Identical means identical code - quite decidable.
09:16:25 <sclv> oh, it turns out that I think ghc does accept identical instances created by standalone deriving clauses.
09:16:27 <Peaker> Baughn, oh, but liftM and fmap would probably not have identical code
09:16:37 <sclv> (i.e. where it knows the instances are identical because it writes them itself)
09:16:45 <Baughn> Peaker: Shoudn't fmap = liftM for all functors that are also monads?
09:16:48 <EvilTerran> Peaker, yes, even Functor instances that aren't Monads. that's what i mean by "it doesn't take the class context into account when determining overlaps"
09:17:05 <Peaker> Baughn, I meant if Monad subclasses Functor, without having that adapter
09:17:12 <sclv> this is a huge relief for things that should obviously be instances of e.g. Show or Data but aren't made such.
09:17:19 <Baughn> ..hang on, that's..
09:17:21 <Saizan> is there a stream monad on hackage?
09:17:22 <Baughn> @src [] liftM
09:17:23 <lambdabot> Source not found. I am sorry.
09:17:23 <EvilTerran> "i have instance Functor [] and instance ... Functor a. oh dear, they overlap"
09:17:29 <Baughn> @src [0 fmap
09:17:30 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:17:32 <Baughn> @src [] fmap
09:17:32 <lambdabot> fmap = map
09:17:34 <lilachaze> geezusfreeek: the "overlapping instances" solution seems to be perfect, except that haskell can't statically determine that the instances don't in fact overlap (due to separate compilation, i think)
09:17:35 <Peaker> EvilTerran, oh
09:17:38 <geezusfreeek> Saizan: a stream... monad?
09:17:54 <sclv> so the "simple" solution is to add standalone deriving for Functor, no?
09:18:00 <Peaker> EvilTerran, why not take the class context into account?
09:18:00 <EvilTerran> Peaker, however, overlapping instances usually aren't that much of a problem. it's the incoherent ones that cause trouble.
09:18:04 <sclv> oh wait, that doesn't solve the monad problem.
09:18:10 <quicksilver> Peaker: I don't think your adapter is any differnt from the standard overlapping instances.
09:18:15 <EvilTerran> Peaker, i think that would make it potentially undecidable
09:18:24 * sclv mumbles "nevermind" quietly.
09:18:25 <BMeph> Peaker: LiftM is fmap, specialized to the Monad class, but otherwise it's the same function, just like (+) for particular number types. :)
09:18:29 <Saizan> geezusfreeek: yeah
09:18:33 <quicksilver> ie. your adapter is no different from instance (Monad m) => Functor m
09:18:47 <quicksilver> ISTR there are a couple of good reasons not to take context into account
09:18:52 <quicksilver> I don't remember what they are, though.
09:18:52 <tobias_tud> is Data.Map / Data.IntMap mutable? or is there a mutable version?
09:18:53 <Peaker> quicksilver, do they let you define classes as instances?
09:18:58 <lilachaze> am i right in thinking that Monad m => Functor m is only overlapping because Haskell doesn't know the instances of Monad at the point where it's looking for overlaps?
09:19:05 <geezusfreeek> Saizan: i'm trying to think of what a stream monad would do. work like a ziplist?
09:19:08 * EvilTerran would have classes Functor, Pointed, Zero, Additive, Alternative, and Monad, with the appropriate contexts in the class definitions
09:19:11 <quicksilver> lilachaze: no, it's overlapping full stop. That's what it says.
09:19:18 <quicksilver> lilachaze: it says "All m are functors"
09:19:25 <quicksilver> lilachaze: but add the constraint that they also be Monads
09:19:26 <sclv> although if *everybody* autoderived functor, then...
09:19:26 <EvilTerran> (and appropriate properties stated in the documentation)
09:19:30 <BMeph> Saizan: Not yet, but you could be the first. :)
09:19:52 <quicksilver> EvilTerran: JohnMeacham's solution is a minor piece of sugar to simplify the class contexts
09:20:01 <quicksilver> EvilTerran: but afaicr it is mostly what you say.
09:20:03 <lilachaze> quicksilver: i read it as "forall m, Monad m => Functor m", which doesn't overlap with "Functor (,)" for instance.
09:20:06 <Saizan> geezusfreeek: that's the idea
09:20:15 <Peaker> EvilTerran, it would suck to have to define redundant functions like fmap after already defining  return (>>=) though
09:20:15 <lilachaze> quicksilver: but that may well be misinterpretation
09:20:15 <Saizan> geezusfreeek: i'm not sure if the details match, yet
09:20:17 <quicksilver> lilachaze: well, with respect, you read it wrong :)
09:20:21 <geezusfreeek> i don't know of one right now
09:20:31 <EvilTerran> (Functor :> Pointed :> Monad, Zero :> Additive, Zero :> Alternative)
09:20:33 <quicksilver> lilachaze: I'm not saying your reading is unreasoable. It's reasonable but wrong.
09:20:33 <BMeph> geezusfreeek: Exactly. And the join is taking the diagonal of the Stream-of-streams.
09:20:50 <lilachaze> quicksilver: ok then, i guess what i'm asking is, is the reason it's not done like that because of separate compilation?
09:20:53 <quicksilver> lilachaze: I'm not sure why though. I'm not sure what the deep reason is that we can't take contexts into account this way.
09:20:59 <EvilTerran> dunno if Pointed :> Zero or Functor :> Zero - i forget what axioms are necessary offhand
09:21:01 <quicksilver> lilachaze: I don't know.
09:21:15 <EvilTerran> s/axioms/properties/
09:21:40 <lilachaze> quicksilver: ok, fair enough. given that this is Haskell rather than some hacky language spelled with a C, I'll just assume there is a good reason and deal with the consequences :)
09:22:02 <geezusfreeek> BMeph: ah, well, that is the semantics of Reactives in conal's Reactive framework, and Sources in mine
09:22:22 <monochrom> Does anyone know the complexity of checking or inference if contexts are taken into account?
09:22:23 <geezusfreeek> but those are not just straight streams
09:22:59 <BMeph> geezusfreeek: Hmm, that makes sense, if you consider a Reactive as a Time-based stream of values. :)
09:23:00 <quicksilver> lilachaze: I have a faint memory of having read that there is a good reason.
09:23:04 <quicksilver> lilachaze: but I dunno what it is.
09:23:30 <quicksilver> conal: ping?
09:23:46 <Saizan> geezusfreeek: reactives have times, right?
09:24:02 <quicksilver> that killed him off.
09:24:09 <nolrai_> @hoogle fromError
09:24:09 <lambdabot> No matches found
09:24:20 <sclv> http://citeseer.ist.psu.edu/hughes99restricted.html
09:24:20 <lambdabot> Title: Restricted Data Types in Haskell - Hughes (ResearchIndex)
09:24:31 <BMeph> EvilTerran: What's a "Pointed" class do? :)
09:24:40 <EvilTerran> BMeph, pointed is functor+return
09:24:57 <sclv> hughes raises two issues with implementing them in haskell -- the first is that it requires a great deal more dictionary passing.
09:25:07 <BMeph> EvilTerran: So, what's a functor + join? :)
09:25:09 <Saizan> geezusfreeek: do you have your reactive framework available somewhere?
09:25:15 <EvilTerran> class Functor f => Pointed f where pure :: a -> f a; forall f. fmap f . pure = pure . f
09:25:45 <quicksilver> geezusfreeek: I am playing around with some GUI ideas. If I wanted to read one paper on the train home today to convince me I should consider a reactive model, which would you recommend?
09:25:47 <EvilTerran> BMeph, no idea :P - "pointed" is another CT term, iirc
09:26:03 <sclv> the second is that it overloads previously monomorphic definitions.
09:26:24 <sclv> "We believe the correct solution here is to revise the monomorphism restriction"
09:26:54 <lilachaze> BMeph: "semi-monad" apparently means *something*, maybe it's that?
09:26:55 <EvilTerran> man, the laws for Applicative are hairy
09:27:44 <sclv> on the other hand, the use case he puts forward is handled neatly by type families.
09:28:21 <quicksilver> EvilTerran: the intuitive law for applicative is this one:
09:28:53 <quicksilver> forall permutations p, sequence l = (p^-1) . sequence . p $ l
09:29:09 <quicksilver> no hang on, that's not it.
09:29:11 <quicksilver> erm.
09:29:13 * quicksilver tries harder.
09:29:24 <BMeph> lilachaze: Mmm, yeah, I guess I need to work on CT-fu, now. ;)
09:29:26 <quicksilver> that one isn't even true :)
09:29:51 <quicksilver> sequence . map pure = id ?
09:30:37 <EvilTerran> quicksilver, the haddock for Control.Applicative lists five laws
09:30:52 <EvilTerran> including the terrifying "forall f g x. pure (.) <*> f <*> g <*> x = f <*> (g <*> x)"
09:31:14 <EvilTerran> (i see what it means, i see why it should be true, but it's still a bit cringeworthy)
09:31:43 <HKhan> ld: cannot find -lHSlambdabot-utils-4.1 << anyone know how to fix this? i've already installed lambdabot-utils :S
09:32:15 <quicksilver> EvilTerran: that's why I prefer to pretend sequence is the primitive
09:32:23 <quicksilver> EvilTerran: the rules look nicer with sequence IMO
09:32:26 <EvilTerran> (that's partly why i want to break pure out into its own class - try to simplify the laws)
09:32:49 * EvilTerran thinks for a minute
09:33:16 <EvilTerran> ?type foldr (liftA2 (:)) (pure [])
09:33:17 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
09:33:35 <EvilTerran> quicksilver, are there a set of laws that comes to the exact same thing?
09:33:41 <EvilTerran> s/are/is/
09:33:43 <quicksilver> EvilTerran: I think so. I don' tknow for sure.
09:33:59 <quicksilver> the fundamental theorem for applicatives says you might as well write
09:34:08 <quicksilver> f <$> a <*> b <*> c ....
09:34:12 <quicksilver> and you could write that as
09:34:14 <Peaker> The Reactive package on hackage includes conal's "efficient FRP" paper stuff?
09:34:25 * EvilTerran tries to think if there's any laws using just fmap and pure other than "forall f. fmap f . pure = pure . f"
09:34:46 <quicksilver> (\[x,y,z...] -> f x y z) . sequence
09:34:50 <ddarius> EvilTerran: That one seems hardly worth stating.
09:35:10 <EvilTerran> ddarius, is it provable from the types of the functions?
09:35:27 <EvilTerran> (assuming total functions)
09:35:35 <ddarius> EvilTerran: Yes.  It is exactly the statement that pure is a natural transformation (assuming fmap is what it should be)
09:35:54 <ddarius> @free a -> [a]
09:35:54 <lambdabot> Extra stuff at end of line
09:36:01 <ddarius> @free  pure :: a -> [a]
09:36:01 <lambdabot> $map f . pure = pure . f
09:36:27 <byorgey> @free pure :: a -> f a
09:36:27 <lambdabot> Extra stuff at end of line
09:36:29 <EvilTerran> @free return
09:36:30 <lambdabot> Expected variable or '.'
09:36:53 <quicksilver> but polymorphic haskell functions are always natural
09:37:03 <quicksilver> parametricity ftw
09:37:23 <EvilTerran> ddarius, what about "class Functor f => Zero f where zero :: f a"? is it necessary to say "forall f. fmap f zero = zero"?
09:37:39 <ddarius> Yes.
09:37:44 <ddarius> Er.
09:38:08 <ddarius> I think so.
09:38:13 <EvilTerran> ?free zero :: [a]
09:38:14 <lambdabot> $map f zero = zero
09:38:32 <EvilTerran> ... remind me, what does that $ in @free output mean?
09:38:38 <ddarius> Nothing really.
09:38:41 <byorgey> since zero has to work for any a, there can't be any specific value of type a for fmap f to have an effect on
09:38:45 <quicksilver> "this is the real map, not one you might have given me"
09:39:11 <EvilTerran> quicksilver, so, approximately "$" = "Prelude." ?
09:39:21 <ddarius> quicksilver: No,
09:39:26 <ddarius> Er EvilTerran
09:40:04 <EvilTerran> byorgey, are you saying (fmap f zero = zero) is provable from the fmap laws and the types too?
09:40:17 <byorgey> EvilTerran: yes, intuitively it seems so
09:40:33 <byorgey> although I'd have to go dig out Wadler's paper to back it up formally =)
09:41:08 <byorgey> EvilTerran: did my hand-wavey intuitive argument above make any sense?
09:41:34 <EvilTerran> byorgey, vaguely, yes
09:41:54 <byorgey> since zero has type  forall a. f a, it can't actually contain any specific values of type a
09:42:19 <byorgey> thus  fmap f  will have no effect since there is nothing to which f can be applied
09:43:06 <EvilTerran> what branch of study is this kind of proof?
09:43:17 <nolrai_> :t foldr
09:43:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:43:48 <EvilTerran> (i mean, an uber-rigorous version)
09:44:11 <EvilTerran> byorgey, ah, now i follow that. "it can't actually contain any specific values" is the important bit, i guess.
09:44:18 <byorgey> EvilTerran: yeah
09:44:45 <nolrai_> so zero is the empty container?
09:44:56 <nolrai_> :t foldr
09:44:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:45:48 <byorgey> nolrai_: viewing functors as containers, yeah, it must correspond to an empty container
09:46:05 <byorgey> EvilTerran: I'm not quite sure.  category theory?  type theory?
09:46:07 <nolrai_> :t zero
09:46:09 <lambdabot> forall m. (Monoid m) => m
09:46:24 <byorgey> EvilTerran: it's very categorical, but IIRC correctly Wadler's "theorems for free!" paper doesn't actually make reference to CT
09:46:33 <tusho> > zero
09:46:34 <nolrai_> @instance Monoid
09:46:34 <lambdabot> Maybe you meant: instances instances-importing
09:46:34 <lambdabot>  ()
09:46:40 <byorgey> er, s/correctly// =)
09:46:41 <tusho> > zero :: Integer
09:46:42 <lambdabot>   add an instance declaration for (Monoid Integer)
09:46:42 <lambdabot>     In the expression: zer...
09:46:44 <tusho> Hah.
09:46:50 <tusho> > zero :: String
09:46:51 <lambdabot>  ""
09:47:05 <nolrai_> @instances Monoid
09:47:06 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:47:06 <byorgey> that's a different sort of zero =)
09:47:19 <ddarius> Theorems for free is a result about parametricity.  However, there are results that relate parametricity and (di)naturality.
09:47:38 <ddarius> > mzero :: String
09:47:39 <lambdabot>  ""
09:47:52 <EvilTerran> byorgey, ah, very good. i intend to do the "lambda-calc and type theory" course next year, and CT if they'll let me (it was 4th-year only this year, and i'll be in 3rd next year)
09:48:02 <EvilTerran> maybe then it'll start making sense
09:48:24 <byorgey> EvilTerran: cool, yeah, all of that stuff is all related =)
09:48:24 <ddarius> EvilTerran: You can read CT crap and Type Theory crap on your own.  You don't have to wait for someone to give you permission.
09:48:37 <byorgey> that's what I do! =)
09:48:51 <EvilTerran> ddarius, well, yes, but i imagine it'll be easier to be taught it than to teach myself
09:49:08 <EvilTerran> especially as i'm excricuatingly lazy about learning stuff off my own bat
09:49:11 <ddarius> EvilTerran: It won't take you two years to learn CT to the level they'd teach you.
09:49:41 <EvilTerran> i guess, if i learnt CT myself over the vac, i could clobber the course and the exam :D
09:50:00 <quicksilver> it's quite hard to be taught CT
09:50:14 <quicksilver> it's quite hard to motivate a lot of it (as a teacher)
09:50:20 <byorgey> going over the same material twice (or more) from different angles/approaches I find to be an extremely effective way of learning.
09:50:25 <quicksilver> much easier to learn it because you have foudn a motivation of your own.
09:50:29 <quicksilver> and, yes, what byorgey says.
09:50:35 <quicksilver> although actually CT isn't "hard".
09:50:37 <ddarius> quicksilver: That's tre of anything.
09:50:39 <Gilly> a side question, what CT stands for ?
09:50:43 <ddarius> s/tre/true
09:50:45 <byorgey> so learning some on your own and then taking a class might work really well.
09:50:47 <ddarius> Category Theory
09:50:49 <quicksilver> it doesn't necessarily need huge leaps.
09:50:50 <Gilly> ahh
09:50:53 <monochrom> I recommend three angles.
09:50:59 <quicksilver> it's just abstract and there is  alot to digest.
09:51:07 <quicksilver> ddarius: yes, it is, but it's easier to motivate some things than others.
09:51:10 <ddarius> Not too much to digest.
09:51:37 <quicksilver> ddarius: it's easier to teach (some parts of) physics to fighter pilots because they understand how it affects their planes.
09:51:40 <quicksilver> they have motivation.
09:51:47 <quicksilver> it is harder to find such motivations for CT.
09:51:48 <monochrom> It's abstract. This is where your prior concrete experience becomes crucial.
09:52:09 <quicksilver> partly because the motivations are general not found in the kind of things that a typical undergrad will have already done before their first CT course.
09:52:55 <byorgey> EvilTerran: I recommend the Barr/Wells lecture notes, since they come at it from a CS angle and in general it's quite readable.
09:52:57 <vixey> CT is pretty hard
09:53:10 <EvilTerran> i've seen people prove a couple of very nice (and unexpected) isomorphisms using something vaguely CT-ish
09:53:11 <ddarius> vixey: It's pretty easy actually.
09:53:16 <byorgey> I also tried the MacLane book, which is much harder
09:53:32 <monochrom> Math is hard. Let's go typing.
09:53:38 <EvilTerran> byorgey, http://www.let.uu.nl/esslli/Courses/barr-wells.html ?
09:53:43 <lambdabot> Title: Courses: Barr / Wells
09:53:52 <quicksilver> I find MacLane exemplifies it quite well.
09:53:53 <ddarius> vixey: There are difficult applications and some difficult parts, but understanding the basics and being able to work with it like algebra or calculus is probably easier than either algebra or calculus.
09:54:02 <quicksilver> It's a very well written and comprehensive work
09:54:08 <quicksilver> with almost no motivation for the material.
09:54:14 <byorgey> EvilTerran: yup, that's it.
09:54:14 * ddarius found MacLane's book a lot lighter than he was expecting.
09:54:20 <quicksilver> it's like reading a dictionary.
09:54:32 <quicksilver> what's the point if you don't know what to use the words for?
09:54:34 <byorgey> what is it with saying things are easy?
09:54:50 <quicksilver> trying to distinguish different kinds of "hard" I think.
09:54:51 <ddarius> byorgey: Because most human constructed things are easy.
09:54:52 * byorgey is going to write a blog post entitled 'Saying Things Are Easy Considered Harmful'
09:55:03 <vixey> yeah I like that
09:55:04 <quicksilver> there is "hard" in the sense of "I cannot solve this puzzle, it hurts my brain"
09:55:10 <vixey> dictionaries are useless
09:55:21 <monochrom> Anyway, on this note, I find that Piaget's postulate is underappreciated. Piaget postulates that you need comprehensive concrete experience before you're ready for the next abstraction leap. This completely explains both "math is hard", "haskell is hard", and "ct is hard".
09:55:29 <quicksilver> CT is more "hard" in the sense of "I am learning a new language and I don't know any of the vocabulary"
09:55:37 <quicksilver> and there is a *lot* of vocabulary.
09:55:41 <byorgey> ddarius: yes, but pedagogically I don't find it a very useful response when someone says 'X is hard' to say 'no, X is easy'.
09:55:48 <EvilTerran> ?djinn (a -> b) -> ((e -> a) -> a) -> ((e -> b) -> b)
09:55:48 <lambdabot> -- f cannot be realized.
09:55:59 <quicksilver> and it's not obviously similar to the languages you already know.
09:55:59 <byorgey> although I guess it depends on the individual.
09:56:06 <ddarius> byorgey: That wasn't a pedagogical context.
09:56:28 <EvilTerran> byorgey, oh, heh, i went to save that in my "papers" folder, and discovered it was already there :P
09:56:35 <byorgey> EvilTerran: hehe =)
09:56:41 <ddarius> byorgey: Anyway I could retort with: 'Saying Things Are Hard Considered Harmful'
09:57:04 <byorgey> ddarius: true.  more precision is needed. =)
09:57:17 * quicksilver thinks #haskell is at least a moderately pedagogical context.
09:57:30 <vixey> EvilTerran: What's that type?
09:57:40 <byorgey> EvilTerran: heh, I think I somehow ended up with three copies of SPJ's 'Implementing Functional Languages' in my papers folder at one point.
09:57:44 <ddarius> quicksilver: It can be, but it's neither required nor assumed to (always) be.
09:58:30 <EvilTerran> vixey, don't worry 'bout it, i'm just tinkering
09:58:39 <vixey> I am worried though!
09:58:57 <vixey> probably doesn't exist does it?
09:58:58 <ddarius> EvilTerran: You want b -> a
09:59:12 <EvilTerran> ddarius, where
09:59:13 <EvilTerran> ?
09:59:17 <ddarius> Actually, I think you'd need both.
09:59:21 <vixey> ?djinn (b -> a) -> ((e -> a) -> a) -> ((e -> b) -> b)
09:59:22 <lambdabot> -- f cannot be realized.
09:59:32 <EvilTerran> ?djinn (a -> b) -> (b -> a) -> ((e -> a) -> a) -> ((e -> b) -> b)
09:59:32 <lambdabot> f a b c d = a (c (\ e -> b (d e)))
09:59:36 <EvilTerran> yeesh
09:59:50 <vixey> wow
09:59:57 <_roconnor> > 1.006**12
09:59:57 <vixey> I had no idea djinn could do that
10:00:00 <lambdabot>  1.0744241677219248
10:00:11 <EvilTerran> I was trying to figure out if a Functor instance for "newtype Throw e a = Throw { runThrow :: (e -> a) -> a }" was possible
10:00:24 <ddarius> vixey: djinn can do all of the control functions of CPS
10:00:35 <EvilTerran> having previously realised that "newtype Throw e a = Throw { runThrow :: (e -> b) -> (a -> b) -> b }" is not a valid newtype
10:00:43 <vixey> ddarius: I don't know what they are yet :[
10:00:45 <ddarius> EvilTerran: You can immediately tell that it is not as it has 'a' both positively and negatively.
10:00:52 <EvilTerran> ddarius, indeed
10:00:57 <quicksilver> EvilTerran: it's an e-functor though :)
10:01:03 <EvilTerran> I'm still getting the hang of type theory here :P
10:01:05 <ddarius> vixey: Read up on CPS.  There is a whole section on readscheme.
10:01:11 <vixey> ok
10:01:23 * quicksilver nominates conal's reactive paper for train reading.
10:01:26 <byorgey> quicksilver: e-functor?
10:01:34 <quicksilver> byorgey: functor in the 'e' variable :)
10:01:36 <ddarius> http://library.readscheme.org/page6.html
10:02:31 <byorgey> quicksilver: ah, so it is =)
10:02:37 <ddarius> vixey: You'd probably also enjoy and benefit from the Lambda the Ultimate papers if you haven't read them already.
10:02:40 <mar77a> is there a std::endl in the prelude?
10:03:08 <nolrai_> mar77a: no but there is putStrLn.
10:03:09 <ddarius> http://library.readscheme.org/page1.html
10:03:17 <byorgey> mar77a: there is "\n"  =)
10:03:22 <mar77a> ou
10:03:42 <ddarius> @bot
10:03:43 <lambdabot> :)
10:04:04 <byorgey> so many papers and so little time!!! =(
10:04:11 <Socrates> @let endl = "\n"
10:04:12 <lambdabot> Defined.
10:06:16 <mar77a> but something like endl = putStrLn "" won't do the trick
10:07:49 <mar77a> that, i can't do string = "hi" ++ endl
10:08:00 <byorgey> mar77a: endl = "\n"
10:08:20 <mar77a> but i want it to be \r\n on windows
10:08:49 <byorgey> you want it to be cross-platform?
10:08:53 <mar77a> yeah
10:08:59 <byorgey> ick
10:09:23 <byorgey> well, there's probably an easy way to do it, but I don't know what it is
10:09:37 <quicksilver> pretend the problem doesn't exist
10:09:39 <quicksilver> "\n" is magic
10:09:44 <quicksilver> it *will* be \r\n on windows.
10:09:47 <byorgey> maybe just use CPP to conditionally include either endl = "\n"  or endl = "\r\n"
10:09:51 <quicksilver> that's what textmode file handles do.
10:09:58 <byorgey> aha, nice =)
10:10:05 <mar77a> interesting
10:10:31 <mar77a> not pure tho :p
10:10:32 <ndm> @seen dcoutts
10:10:32 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 3h 43m 21s ago.
10:10:59 <dcoutts_> @arr!
10:10:59 <ndm> dcoutts, I am just trying to install cabal-install and its demanding cabal < 1.5, but i upgraded earlier today
10:10:59 <lambdabot> Aye Aye Cap'n
10:11:18 <dcoutts_> ndm: you can get it from hackage
10:11:36 <ndm> dcoutts, should i avoid using the darcs?
10:11:53 <ndm> i tend to go for darcs versions of cabal/cabal-install, since i often find bugs and that way i can get them properly tested in
10:11:53 <dcoutts_> ndm: you can use the cabal 1.4 darcs branch if you like
10:12:07 <ndm> but cabal HEAD and cabal-install HEAD is a no-go?
10:12:45 <dcoutts_> ndm: at the moment yes, we might branch cabal-install too at some point, but currently cabal-install is using the 1.4 stable branch
10:13:46 <ndm> dcoutts, suggestion? which is the recommendation?
10:13:59 <ndm> i just want cabal-install and cabal goodness
10:14:10 <dcoutts_> ndm: if you prefer darcs versions then yes, use cabal-1.4 branch and cabal-install
10:15:11 <ndm> dcoutts - where is the 1.4 branch? its not on http://haskell.org/cabal/code.html
10:15:11 <lambdabot> Title: Getting the Code
10:15:49 <dcoutts_> ndm: oh thanks, I'll update that page. It's at http://darcs.haskell.org/cabal-branches/cabal-1.4/
10:15:51 <lambdabot> Title: Index of /cabal-branches/cabal-1.4
10:16:42 <ndm> dcoutts, many thanks :)
10:17:12 <nolrai_> @pl findConnectedOutput pos board  = liftM (filter ((== Output) . fst)) findConnected pos board
10:17:12 <lambdabot> findConnectedOutput = fmap (filter ((Output ==) . fst)) findConnected
10:17:57 <sclv> anyone with hxt experience here?
10:18:10 <sclv> how I do I keep it from trying to fetch a dtd from a url?
10:18:19 <dons> TomMD: did you get my message about pureMD5 not being cabal 1.2.3 friendly?
10:18:46 <dcoutts_> dons: what was the problem btw?
10:20:25 <dons> Setup: can't find source for Data.Digest.Pure.MD5 in ["Data","Test"]
10:20:33 <dons> works with 1.4
10:23:07 <dons> dcoutts_: two questions, one: i have a list of Dependencies that come with the default ghc build, so i want to filter those out from the pkgbuild file i generate -- as they have no package of their own. but i want to filter respecting version numbers
10:23:20 <dons> dcoutts_: is there any easy way to do that correctly?
10:23:55 <dons> so, e.g. cabal2arch depends on Cabal>1.3.12 &&<1.5, and Cabal [1,2,3] is on the system. so i *do* need to add a "haskell-cabal" constraint
10:24:04 <dcoutts_> dons: hmm, do you know why the sources are not found with 1.2.x? I'm not aware of any changes in that area.
10:24:20 <dons> it's Tom's package, so no, i've not looked at it.
10:24:20 <nolrai_> > fail "msg" :: Either String Int
10:24:21 <lambdabot>  Left "msg"
10:24:29 <dons> should be easy to reproduce: try to build it with Cabal 1.2.3
10:25:25 <dcoutts_> dons: so don't you just need to finalise the package description and then filter out built-in packages when you convert to the arch package?
10:25:34 <dons> that's what I do, yes.
10:25:41 <dons> but i need to do a smart filter that handles the versioning
10:25:48 <dons> is there a comparison function handy for that?
10:26:22 <dons> i need to not filter when the version info isn't satisifed, even with core packages
10:26:28 <dcoutts_> dons: oh you mean because you still get package version ranges in the depends list after finalising rather than specific version numbers
10:26:41 <dons> hmm, I think so, yes.
10:26:44 <dons> i do.
10:26:53 <dons> Intersects and Unions and so on.
10:27:10 <dcoutts_> dons: and so you're trying to work out if it should depend on a version you've got built-in or if it should be a later version that has a real corresponding package?
10:27:19 <dons> yep
10:27:28 <dons> i.e. "haskell-cabal-1.4"
10:27:43 <dcoutts_> dons: so that's basically up to you. You get to make that decision about which versions of deps get used.
10:28:07 <dons> removeCoreFrom (x@(Dependency n _):xs) =
10:28:07 <dons>   case find (\(Dependency k _) -> n == k) corePackages of
10:28:07 <dons>     Just _ -> removeCoreFrom xs
10:28:07 <dons>     Nothing -> x : removeCoreFrom xs
10:28:10 <dcoutts_> dons: by default Cabal configure will pick the highest version numbers but you can specify constraints so that it picks the ones you want.
10:28:36 <dons> hmm, does this go back to finalise needing a complete package spec?
10:28:43 <dcoutts_> dons: no
10:28:57 <dons> my above function just lokos up the corePackages by name, and filtesr
10:29:06 <dcoutts_> dons: you're building a binary package right? So you know exactly what versions of the deps it's going to be built against.
10:29:09 <dons> but i really need to handle the Intersect/Union versionRange logic
10:29:29 <dons> that's right.
10:30:08 <dons> the package says "Cabal>1.3.12&&<1.5", and I've cabal 1,2,3 builtin, so I need to emit "haskell-cabal-1.4"
10:30:37 <dcoutts_> dons: right, because there is only one version available in your package index that satisfies the dep
10:30:46 <dcoutts_> and that turns out not to be a builtin
10:30:52 <dcoutts_> so it doesn't get filtered
10:30:57 <dons> yep
10:32:06 <dons> so there's no cabal code already for entirely resolving ranges in the presence of a known list of package versions?
10:32:09 <dcoutts_> dons: there's a function configDependency that will do this for you
10:32:13 <dons> ah
10:32:21 <dcoutts_>  :: Verbosity -> PackageIndex InstalledPackageInfo -> Dependency -> IO PackageIdentifier
10:32:43 <dcoutts_> dons: or if you need a pure one, it's pretty trivial
10:33:01 <dcoutts_> dons: PackageIndex.lookupDependency index dep
10:33:12 <dcoutts_> gives you the list of packages that satisfy a dependency
10:33:18 <dons> ah ha, yes.
10:33:19 <dcoutts_> if it's [] you're stuffed
10:33:27 <dons> so i just need to build my own PackageIndex then?
10:33:28 <dcoutts_> if there are several then you have to choose
10:33:51 <dcoutts_> dons: if you want to do it accurately then yes
10:34:02 <dons> right, so "cannot satisfy dependency" would map to "there is no Arch package yet"
10:34:10 <dcoutts_> right
10:34:11 <dons> then, if it can , i'll get a concrete version
10:34:16 <dcoutts_> yep
10:34:18 <dons> which i can filter directly from the core list, or extras list
10:34:27 <dons> yes, awesome.
10:34:44 <dons> ok, i'll play around with this.
10:34:53 <dons> already making good progress, fwiw, 50 packages uploaded last night
10:34:57 <dcoutts_> dons: in fact it'd be better to use your own PackageIndex ArchPackage rather than PackageIndex InstalledPackageInfo
10:35:05 <dons> yeah, good idea
10:35:14 <dcoutts_> PackageIndex is generic in the package type
10:35:36 <dcoutts_> dons: and note that ArchPackage is an instance of PackageFixedDeps, like InstalledPackageInfo
10:36:00 <dcoutts_> because for a binary ArchPackage you know exactly what other PackageIds it depends on
10:36:17 <dons> cool
10:36:34 <dcoutts_> dons: there's a bunch of useful functions in PackageIndex for looking at package dep graphs
10:37:00 <nolrai_> :t any
10:37:01 <dcoutts_> you can check that you've got a consistent set of packages
10:37:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:38:48 <dcoutts_> dons: so when you configure a package you can specify exactly what versions of its deps it should be using. That's what cabal-install does.
10:39:14 <dcoutts_> dons: otherwise if there are several versions available it picks the highest that satisfies the deps.
10:39:26 <dons> cool
10:39:39 <dons> does cabal-install have some logic for going from a name to a hackage url?
10:39:51 <dcoutts_> dons: yep, see...
10:40:20 <dcoutts_> dons: Hackage.Fetch.packageURI :: AvailablePackage -> URI
10:41:13 <dcoutts_> an AvailablePackage knows what hackage server it is from
10:46:23 <dons> dcoutts_: is that in cabal-install?
10:46:28 <dons> ok, i'll steal that.
10:47:06 <mar77a> i compiled my program on a linux machine, then ftp'd it to another linux machine in which when i try to run it, i get "error while loading shared libraries: libgmp.so.3: cannot open shared"
10:47:15 <mar77a> (ofc it runs fine on the first machine)
10:49:11 <dancor> mar77a: what does   ldconfig -p | grep libgmp   say on machine2
10:49:23 <dancor> this is more of a shared library question than a haskell one
10:49:33 <mar77a> -bash: ldconfig: command not found
10:50:08 <dancor> you may need root, or use locate or google to find it for your platform
10:50:17 <EvilTerran> /sbin/ldconfig ?
10:50:35 <mar77a> that one works
10:50:50 <mar77a> but when i grep libgmp it returns 0 lines
10:50:53 <EvilTerran> hooray for sbin -.-
10:51:03 <dancor> mar77a: so you don't have libgmp installed on that machine
10:51:23 <mar77a> is there any way to make my program at compile time, not to depend on that lib
10:51:47 <dancor> mar77a: i think there was some open bug to make ghc not depend on libgmp or somethign
10:52:17 <dancor> but i believe that currently at least you basically need that for haskell to do its bigint stuff
10:52:52 <mar77a> hm ok
10:52:58 * dancor wonders, if you use like Int instead of Integer everywhere does your executable compile without needing libgmp
10:53:18 <mar77a> i don't use Integer anywhere
10:53:19 <mar77a> i think
10:53:41 <mar77a> actually
10:53:42 <mar77a> maybe i do
10:54:00 <dancor> mar77a: well libraries you use could, it might always have deps in the runtime anyway
10:54:15 <dancor> is putting gmp on machine2 annoying for some reason
10:54:26 <mar77a> not root
10:54:45 <dancor> mar77a: have you tried compiling on machine2 directly
10:54:56 <mar77a> can't install ghc
10:54:58 <mar77a> :<
10:55:05 <nolrai_> @hoogle (a -> b -> m b) -> [a] -> m [b]
10:55:06 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
10:55:06 <lambdabot> Data.List.foldr :: (a -> b -> b) -> b -> [a] -> b
10:55:07 <dancor> can't install it to your homedir?
10:55:13 <mar77a> maybe
10:55:32 <dancor> (i don't know how easy it is with packages avail, but def possible in theory)
10:55:33 <dons> dancor: i'd be surprised
10:55:42 <dons> since you're likely using functions in base that need it
10:55:49 <nolrai_> :t foldr
10:55:50 <dons> dancor: woudl be useful to know though
10:55:51 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:57:56 <nolrai_> @hoogle foldM
10:57:57 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:57:57 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:57:57 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:59:44 <ziman> > (init &&& last) "abcde"
10:59:45 <lambdabot>  ("abcd",'e')
11:00:31 <dmwit> ziman: If you're doing that a lot, you probably want to just reverse the string, then use head/tail.
11:01:44 <Deewiant> > (reverse.tail &&& head) . reverse $ "abcde"
11:01:45 <lambdabot>  ("abcd",'e')
11:04:41 <EvilTerran> ziman, or, if you're working from both ends, you may want to look at Data.Sequence
11:05:42 <chr1s> dcoutts_: I'm probably going to go with libEtPan!, which also handles SMTP: http://www.etpan.org/libetpan/index.html
11:05:43 <lambdabot> Title: libEtPan! - a mail library
11:05:50 <ziman> well, for each n-tuple of chars, i'm collecting a set of chars that follow the n-tuple in the text
11:06:32 <EvilTerran> in that case, you may even want to look at Data.Set (and potentially Data.Map or Data.Array for the char->tuple mapping)
11:06:35 <ziman> dmwit, is reversing the string faster?
11:07:09 <EvilTerran> ziman, not for a single change, as they're both O(n)
11:07:31 <viller> a haskell tutorial told me to write a program that calculates the sum of numbers you give it. I did this: http://hpaste.org/8321 but ghci gives me an error
11:07:32 <EvilTerran> ziman, but, if you were to strip off every element in turn from the end, you'd end up with O(n^2) for your version and O(n) for reversing first
11:07:33 <dcoutts_> chr1s: looks ok
11:08:15 <agcorona> hi, te best tutorial is session with the ghci debugger
11:08:15 <EvilTerran> viller, it seems you're trying to return the final sum instead of printing it?
11:08:37 <ziman> i just do > map (init &&& last) . take n . tails
11:08:45 <ziman> (plus some takeWhile to filter out too short strings but that would obfuscate the idea)
11:08:45 <EvilTerran> viller, that won't work, as main is of type "IO ()", not "IO <some numeric type>"
11:09:03 <EvilTerran> ziman, yikes, that'll definitely be O(n^2)
11:09:05 <Deewiant> > map (init &&& last) . take 4 . tails $ "foobar"
11:09:06 <lambdabot>  [("fooba",'r'),("ooba",'r'),("oba",'r'),("ba",'r')]
11:09:07 <dcoutts_> chr1s: so from a brief look it seems it mostly uses pointers to opaque structures. c2hs works nicely for that model. It's what gtk uses and gtk2hs can use c2hs features nicely for that. See especially the {# pointer #} c2hs hook.
11:09:13 <EvilTerran> (if you force the output in full)
11:09:21 <agcorona> by the way, are there some people trying to integrate the ghci debugger with an editor?
11:09:33 <dons> awesome, http://www.ghc.com/
11:09:35 <lambdabot> Title: GHC Gerling, Holz + Co. - Spezialist fr Spezialgase
11:09:49 <dons> special gases eh?
11:10:00 <viller> EvilTerran: does do make main of type IO()?
11:10:16 <b_jonas> viller: no
11:10:20 <ziman> EvilTerran, i'll think about it, thanks!
11:10:28 <EvilTerran> viller, no, it's just the way the entry point is defined in the spec
11:10:49 <EvilTerran> "entry point is a top-level binding main :: IO ()"
11:11:05 <viller> what is entry point?
11:11:10 <EvilTerran> like in C, "entry point is a function int main (int,char **)"
11:11:24 <Deewiant> the entry point is what the OS calls when you run your executable
11:11:30 <agcorona> dons : what about a Yi extension with ghci debugger integrated?
11:11:38 <EvilTerran> it's where execution starts, ish.
11:11:43 <viller> ok
11:12:42 <viller> what if I rename main?
11:12:44 <dancor> the dons that say "Yi!"
11:12:45 <EvilTerran> viller, anyway, main :: IO () as haskell doesn't have anything meaningful to do with values returned from main (if such values could be returned)
11:12:47 <frwmanners> viller: There is another problem with your code; you imply that "main" returns a list, but also that it returns a number (from the use of sum)
11:13:07 <EvilTerran> viller, i think what you want is a new function to call from main
11:13:12 <EvilTerran> (that also calls itself)
11:14:15 <frwmanners> viller: I've annotated on hpaste if you want a solution
11:14:32 <frwmanners> viller: (That does what EvilTerran recommends)
11:15:21 <viller> thank you
11:15:33 <ahunter_> @type &&&
11:15:35 <lambdabot> parse error on input `&&&'
11:15:38 <ahunter_> @type (&&&)
11:15:40 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:16:31 <viller> can someone explain me why there's a $ sign before sum?
11:16:31 <Deewiant> i.e. (b -> c) -> (b -> d) -> (b -> (c,d))
11:18:06 <EvilTerran> ?src ($)
11:18:06 <lambdabot> f $ x = f x
11:18:26 <EvilTerran> $ doesn't actually *do* anything, it just applies its left parameter to its right
11:18:34 <bos> how does one interface to C code that uses fixed-width types like uint32_t?
11:18:41 <bos> the FFI doesn't have e.g. CInt32
11:18:43 <EvilTerran> as that definition says, "f $ x" literally means "f x".
11:19:10 <tromp> ($) == id
11:19:19 <EvilTerran> but $ is really low-precedence, so using it lets you leave out brackets you'd otherwise need
11:19:45 <dcoutts_> bos: I'd guess that Int32 can be used in an ffi import in ghc at least
11:19:54 <viller> I like brackets :D
11:20:33 <bos> dcoutts_: seems to work, but perhaps a bit philosophically sketchy :-)
11:20:34 <dancor> viller: yeah $ is just like counterreaction from ppl that hated lisp :)
11:20:56 <dons> bos, hmm. we should add CInt32 et al to Foreign.C.Types
11:20:57 <EvilTerran> "length (filter id (zipWith xs [0..] (reverse (...))))" vs "length . filter id . zipWith (==) xs . reverse $ ..."
11:21:04 * dons is surprised this isn't the case already
11:21:12 <Peaker> viller, $ helps prevent a  LOT of ))))))) at the end of the line
11:21:26 <dancor> > map ($ 4) [(2 +), (6 *)]
11:21:27 <mar77a> i think of $ as a ( where it's written and a ) where the statement ends
11:21:27 <lambdabot>  [6,24]
11:21:31 <bos> dons: it wasn't an issue when the FFI was being put together, and stdint.h didn't exist.
11:21:32 <dons> yeah,they're missing. dodgy.
11:21:33 <Peaker> viller, a $ b $ c $ d $ e $ f   vs.   a (b (c (d (e (f)))))
11:21:41 <dons>         , CIntMax, CUIntMax
11:21:41 <dcoutts_> bos: actually they're ok http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-120003.2
11:21:43 <lambdabot> Title: 3 Foreign Declarations, http://tinyurl.com/yezf7t
11:21:47 <dons> was added, what, last year?
11:22:04 <dcoutts_> bos, dons: Int8, 16 32 etc are in the original FFI spec
11:22:11 <dcoutts_> and Word8, 16, 32
11:22:18 <bos> oh, they are? ok, cool.
11:22:18 <dons> ah.
11:22:21 <dcoutts_> oh and 64
11:22:31 <dons> so they're guaranteed isomorphic to the C types?
11:24:04 <dcoutts_> dons: I'm not sure it says exactly. But they're obviously going to be native endian in which case they must coincide with the corresponding fixed width C types.
11:24:09 <bd_> dons: the C char/short/int/long aren't guarenteed to be 8/16/32/64 (and indeed, int and long often vary)
11:24:16 <dancor> the documentation for fix is like a lie, since fix (^2) is undefined but "the least fixed point" is def 0
11:24:18 <bd_> so, it'd have to be the fixed width ones I guess
11:24:39 <EvilTerran> dancor, the ordering used by the definition "least fixed point" isn't the one you're expecting
11:24:48 <dcoutts_> dons: yeah, only C99 introduced actual fixed width C types
11:24:59 <EvilTerran> dancor, it's one in which _|_ (aka undefined) is the "least" value of any type
11:25:34 <dancor> EvilTerran: but why isn't _|_ the result of fix (0:) then
11:25:40 <geezusfreeek> Saizan and quicksilver: sorry, i had to leave before you asked me those questions about FRP. Saizan: my reactive framework is not worth trying to use yet, but you can still find its current pieces at http://github.com/geezusfreeek/simple-haskell-game/tree/master . quicksilver: maybe http://haskell.cs.yale.edu/frp/genuinely-functional-guis.pdf ? i honestly haven't read much FRP material. trying to remain somewhat uninfluenced b
11:25:42 <dancor> well heh i guess it is.. it's very weird
11:25:43 <lambdabot> Title: geezusfreeek's simple-haskell-game at master &mdash; GitHub
11:25:44 <EvilTerran> dancor, because it's not a fixedpoint
11:26:06 <EvilTerran> (1:) _|_ = (1:_|_) /= _|_
11:26:17 <dancor> ok
11:26:52 <EvilTerran> you can think of (fix f) as the limit of (iterate f undefined)
11:27:54 <EvilTerran> each step, one more level of recursion of f happens between the _|_ and the value
11:27:56 <dancor> > undefined < []
11:27:57 <lambdabot>  Exception: Prelude.undefined
11:28:32 <dancor> they shouldn't tacitly use cross-type comparisons in the docs that aren't in haskell
11:28:51 <EvilTerran> for terminating functions with a finite return value, after a certain point in (iterate f undefined) all the rest of the list will be the same
11:29:46 <EvilTerran> that's the least fixedpoint of such a function, as you've slowly been working up from a first approximation of fix as _|_ (at the bottom of the ordering) to increasing, increasingly accurate approximations
11:29:54 <byorgey> dancor: it's not cross-type, and it has nothing to do with Ord
11:30:17 <EvilTerran> "least fixed point" is a pretty common term in type theory etc
11:30:39 <byorgey> dancor: undefined is a member of every type
11:47:59 <ziman> is there a specific Map implementation suitable for being keyed by Strings? i mean some patricia trees or similar
11:48:27 <ziman> (in ghc standard libs)
11:48:31 <dcoutts_> ziman: no
11:48:43 <dcoutts_> but there are various on hackage
11:48:53 <ziman> thanks
11:54:45 <ziman> @pl \c -> p c || q c
11:54:46 <lambdabot> liftM2 (||) p q
12:02:53 <agcorona> to follow the execution of a debug session in an editor that permit only a single instance like gedit is easy if the linebreak and the filename were available:  this would be the ghci command for this:  ghci> :set stop :edit currentfile linebreak
12:03:06 <eu-prleu-peupeu1> heya
12:04:00 <geezusfreeek> hello
12:04:55 <byorgey> hey there
12:08:05 <igel> @pl \x y -> EQ == compare x y
12:08:06 <lambdabot> ((EQ ==) .) . compare
12:09:59 <eu-prleu-peupeu1> i want to create bindings to haskell, to a lib that i want to use, what do i have to read in order to do that ?
12:11:21 <dons> read 'how to create a haskell package' on haskell.org
12:11:46 <dons> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
12:11:47 <lambdabot> Title: How to write a Haskell program - HaskellWiki
12:11:55 <eu-prleu-peupeu1> ok, thanks
12:17:24 <augustss> yo
12:23:30 <byorgey> hi augustss
12:35:15 <viller> all the benefits of pure functional programming languages come from pure functions but what's the point when most programs have huge state data?
12:35:50 <viller> half the functions are still impure
12:36:19 <augustss> not true
12:36:25 <geezusfreeek> viller: perhaps on a top level, but you are still invariably using tons of pure functions underneath
12:36:31 <roconnor> much less than half the functions are impure.
12:36:49 <roconnor> I'd guess 10% or less
12:36:51 <augustss> In my code it's probably about 1% impure code
12:36:54 <roconnor> involve IO
12:37:20 <geezusfreeek> even the "impure" code is still actually pure most of the time
12:37:30 <RayNbow> what is the most common definition for impure code btw?
12:37:33 <augustss> And I'm talking code size around 100K lines
12:37:50 * roconnor thinks he get 10% because his programs are all tiny
12:38:34 <roconnor> RayNbow: in this case I'm intepreting what viller means by impure as involving IO
12:38:51 <augustss> yes, that's what I took it to mean as well
12:39:20 <geezusfreeek> RayNbow: what roconnor said, but i normally don't consider IO to be impure most of the time. all the IO monad does is generate a program in a basically pure way
12:39:52 <vixey> IO is pure :)
12:40:13 <roconnor> all haskell is pure... except the unsafe bits.
12:40:36 <viller> I'm just beginning to try and understand FP so I don't know anything but how do you carry state then? You always pass all the state stuff as a huge argument?
12:40:58 <vixey> viller: yes, that huge argument might be implicit though
12:41:00 <roconnor> which is why we interpreted that viller was talking about IO.
12:41:00 <geezusfreeek> viller: you say huge argument as if it's clunky ;) (it's not)
12:41:32 <roconnor> sometimes we pass a large data structure around.
12:41:34 <RayNbow> that huge argument is always implicit in mainstream imperative languages :+
12:41:35 <augustss> viller: yes, state is passed around somehow.  There are many ways
12:41:51 <geezusfreeek> viller: to be more clear, passing an argument in haskell doesn't necessarily imply that you do it explicitly, or that there is as much overhead involved as in many imperative languages
12:41:52 <roconnor> often that structure gets chopped up and smaller bits are passed into further functions.
12:51:08 <rwbarton> My Data.ByteStream.Char8-using programs stopped linking once I installed ghc 6.8.2.  Do I need to use some new command-line options?
12:55:40 <hircus> hullo! any Agda folks here?
12:57:00 <koninkje> rwbarton: you may need to use -package bytestring, or --make
12:57:47 * sclv shakes a stick at arrows
12:58:43 <rwbarton> koninkje: thanks, those work
12:59:36 <augustss> hircus: I've used Agda
13:00:19 <hircus> augustss: ah. I'm just starting on it. it builds fine, but.. no binary is generated
13:00:55 <augustss> hircus: Hmmm, I just followed the instructions and it worked
13:00:58 * roconnor vaguely remembers that problem
13:01:22 <roconnor> hircus: I had to change to another directory or something
13:01:23 <hircus> roconnor: does that happen only when configuring to install as non-root?
13:01:36 <roconnor> hircus: I think the problem was that I didn't read the directions
13:01:40 <hircus> augustss: did you install to the main Haskell directory?
13:01:45 <roconnor> :)
13:01:45 <hircus> hm. need to double-check that
13:01:58 <hircus> I wish cabal-rpm does not choke on the Agda cabal file
13:02:05 <roconnor> or the directions were hard to find
13:02:09 <roconnor> or something weird
13:02:36 <augustss> hircus: I just got it with darcs and followed the instruction in README
13:02:54 <hircus> ah. src/main !
13:02:58 <hircus> silly me
13:04:15 <hircus> uh, I just hit a zlib bug when trying to build the executable
13:04:48 <koninkje> @tell Cale you should link to the filterM (const [True,False]) call tree from the CaleWiki home page (or from the fold diagrams page,...)
13:04:48 <lambdabot> Consider it noted.
13:12:34 <sclv> wrestling with hxt is no fun.
13:13:48 <geezusfreeek> woah, associated data types are in ghc 6.8.2?
13:14:06 <Cale> geezusfreeek: sort of
13:14:06 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:14:24 <geezusfreeek> what is lacking?
13:15:07 <Cale> I'm not sure of the details, but they seemed rather broken when I tried them out.
13:15:17 <geezusfreeek> seems to be working fine for me right now
13:15:32 <geezusfreeek> i didn't even mean to use ghci-6.8.2, but it loaded fine
13:16:03 <Cale> The typechecker seemed not to apply them to see that types were the same sometimes.
13:16:18 <SamB> Cale: you mean the ATsyns?
13:16:44 <Cale> Type families
13:17:18 <geezusfreeek> i think i will roll with this a bit and see where it goes
13:19:47 <sclv> this freaking ArrowList is utterly quirky.
13:20:10 <sclv> what if I don't *want* empty to fail.
13:20:14 <sclv> bleh
13:20:57 <WhiteWofflan> Can someone tell me how I am supposed to random numbers in Haskell?
13:21:40 <hircus> WhiteWofflan: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
13:21:43 <lambdabot> http://tinyurl.com/2fpup7
13:22:08 <geezusfreeek> WhiteWofflan: random g, where g is an instance of RandomGen and the type you want is an instance of Random
13:22:20 <geezusfreeek> see Systemm.Random for details
13:22:27 <geezusfreeek> *System
13:22:28 <WhiteWofflan> ok thanx
13:24:45 <Cale> WhiteWofflan: Basically, there are two approaches. If you're at the top level of your program and need some random numbers, you can get them directly in the IO monad. If you're writing what is essentially a pure algorithm, but it needs a supply of random or pseudorandom numbers, the solution is to take that supply as input.
13:25:26 <Cale> A value of type StdGen is effectively the seed/state for a pseudorandom number generator.
13:25:50 <Cale> and you can pass those around and use them to compute new random values, along with further StdGens
13:26:26 <Cale> :t random
13:26:28 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
13:26:45 <Cale> > random (mkStdGen 42) :: (Integer, StdGen)
13:26:46 <lambdabot>  (-1673289139,128694412 1655838864)
13:27:26 <Cale> Or, you can use randoms to get an infinite list of pseudorandom elements from a single generator:
13:27:34 <Cale> > randoms (mkStdGen 42) :: [Integer]
13:27:35 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
13:27:46 <Cale> (and pass that along into the algorithm)
13:28:41 <Cale> In the IO monad at the top level, you can use  newStdGen  to construct a StdGen based on the current time (though I wish it would use the system entropy pool to get a seed)
13:29:16 <Cale> :t newStdGen
13:29:18 <lambdabot> IO StdGen
13:29:39 <Cale> :t randomIO
13:29:40 <lambdabot> forall a. (Random a) => IO a
13:33:18 <Cale> WhiteWofflan: follow that? :)
13:35:21 <ahunter_> So here's a question, perhaps better suited for the mailing list, but nonetheless interesting: is there an accepted suite of Haskell *parallel/concurrent* benchmarks?
13:35:23 <geezusfreeek> also take note of the MonadRandom package which gives you a handy state monad for passing around the generator
13:36:40 <ahunter_> I mean, if you want to bench something in Haskell, you use nofib like everyone does--but what if we care about stuff that's parallel?  Nofib has some parallel stuff but I haven't seen it referenced much in the literature, and a lot of it is worrisomely trivial (parfib, for instance)
13:37:25 <Heffalump> Please tell me parfib isn't a parallel fib.
13:37:34 <geezusfreeek> i personally would love to see a "great language shootout" that is run on a many-core machine
13:37:45 <Cale> Heffalump: heh, how could it be anything else? :)
13:37:51 <ahunter_> Heffalump: I'm afraid so.  Kinda defeats the purpose of "nofib", eh?
13:37:51 <Heffalump> butbutbutbut....
13:38:08 <ahunter_> Far as I can tell, the parallel directory is dumped as-is from one of the old parallel haskell projects?
13:39:14 <ahunter_> So, for instance, http://research.microsoft.com/~tharris/papers/2005-haskell.pdf uses GHC parallelized in a cute way, but not only can I not reasonably call that an "accepted standard" for benchmarking, I also can't find anywhere that parallelized GHC is available
13:40:18 <ahunter_> So yeah, anyone want to clue me on some great parallel benchmarks?
13:48:39 <proq> geezusfreeek: that sounds like a good idea, but depending on *which* machine you would get dramatically different results
13:49:25 <ahunter_> geezusfreek: also, what do you want to run on those many cores? :)
13:50:14 <geezusfreeek> i just mean basically the same as the existing shootout but where the programs are written for for parallelization/concurrency
13:50:22 <proq> or maybe you could try using several machines and combining the results into one overall average
13:50:35 <geezusfreeek> probably any of the same challenges even
13:50:53 <geezusfreeek> yeah it may vary a lot
13:51:21 <sclv> aha -- solved it. either missing something or turning listArrows from depth to breadth first traversal patterns in hxt is ridiculously nontrivial.
13:52:04 <koninkje> geezusfreeek: the problem is "parallelism" isn't really a well-defined notion. SIMD, SMP, NUMA, cc-NUMA,... all will have very different behaviors because they all "parallelize" things in different ways
13:52:08 <ahunter_> geezusfreeek: not all of them are parallelizable, at least not easily.  If we wanted this to be meaningful
13:52:26 <nus> x86-64 is the LCD, not so sure about the algo
13:54:04 <geezusfreeek> i wouldn't want to set it up, i'd just like to see it :P
13:54:07 <koninkje> geezusfreeek: not to mention cluster computing and abstraction ideologies (mesage passing, remote function calls, artetecture wirings and fold patterns,...)
13:54:19 * koninkje would love to see it too :)
13:54:38 * geezusfreeek doesn't have the resources for such a beast anyway
13:55:03 <sclv> and... yeah... there was the unsurprisingly super trivial solution I missed.
13:55:11 <sclv> listA
14:37:13 <grahamhutton> @users
14:37:14 <lambdabot> Maximum users seen in #haskell: 453, currently: 439 (96.9%), active: 13 (3.0%)
14:40:22 <dons> dcoutts: what's the best way to build all of hackage in correct dependency order?
14:40:36 <dons> do we have a way to dump out a traversal that achieves this?
14:58:06 <fophillips> Does anyone know if it’s possible to change the name of a patch in darcs? #darcs is a little, er, quiet.
15:08:47 <proq> fophillips: are you using darcs 2? if so, how do you like it?
15:09:58 <fophillips> proq: Not yet.
15:12:35 <chessguy> hm, have splay trees been implemented in haskell?
15:12:51 <chessguy> @go haskell splay tree
15:12:52 <lambdabot> No Result Found.
15:13:06 <roconnor> what are splay trees?
15:13:26 <chessguy> self-balancing binary search trees
15:13:27 <ddarius> @google splay trees
15:13:28 <lambdabot> http://en.wikipedia.org/wiki/Splay_tree
15:14:16 <roconnor> ooh
15:14:19 <roconnor> Splay Monad
15:14:26 <chessguy> (incidentally, one of their inventors also built the biggest and best commercial internet chess server out there)
15:14:35 <chessguy> splay monad?
15:14:59 <roconnor> Wikipedia says: ``t recently accessed elements are quick to access again''
15:15:06 <Botje> I think a functional splay tree would have the same difficulties as a functional AVL tree
15:15:16 <roconnor> the whole notion of recently accessed only makes sense in a monad.
15:15:26 <roconnor> ... or by hacking the runtime system a la DiffArrays
15:15:39 <chessguy> roconnor:  you mean because of immutability?
15:15:52 <roconnor> more or less
15:16:04 <roconnor> I'd say because of referential transparency.
15:16:10 <dolio> If all your operations are SplayTree -> (result, SplayTree) it makes sense.
15:16:31 <roconnor> dolio: as in State SplayTree.
15:16:40 <dolio> Of course, that's monad-ish if even your reads have that kind of type.
15:16:41 <ddarius> @google scapegoat tree
15:16:42 <lambdabot> http://en.wikipedia.org/wiki/Scapegoat_tree
15:18:19 <koninkje> in particular it's a restatement of State
15:19:01 * Botje misread O(log n) and Oleg. Instant hyperventilation
15:19:03 <koninkje> ...which seems to be the most commonly reinvented monad (after Maybe and List/Set/...)
15:19:12 <Socrates`> chessguy: ICC by any chance?
15:19:22 <chessguy> Socrates`:  indeed
15:19:37 <Socrates`> Are you a member?
15:19:49 <chessguy> my account is expired at the moment
15:19:53 <Socrates`> Ah right.
15:20:06 <Socrates`> I've had an account for a few months
15:20:13 <chessguy> i don't play enough to make it worth paying any more
15:20:14 <Socrates`> But I'm still only a lowly 1400
15:20:17 <chessguy> i certainly used to
15:22:09 <roconnor> It's kinda nice how in Haskell flip f x y is the same as f y x.
15:26:00 <dcoutts> dons: you can just list every package and then ask to install them all, that's what I do
15:26:12 <dons> ask who?
15:26:24 <dcoutts> cabal list --simple-output
15:26:37 <dcoutts> cabal install --dry-run $(cat pkgs)
15:26:39 <dons> ah, i want to use cabal2arch , in dependency order
15:26:54 <dcoutts> dry-run says what it'll install
15:26:56 <dcoutts> in the right order
15:26:59 <dons> ah ok
15:27:05 <dons> excellent
15:27:09 <dcoutts> so if you know what you want to install then that's it
15:27:13 <dons> so that gives me a "topologicall sort"
15:27:25 <dcoutts> dons: but bear in mind that it is impossible to install all of hackage simultaneously, at least to do it consistently
15:27:32 <dons> yeah, that's fine.
15:27:43 <dons> i just want to build as many binary packages as I can
15:27:46 <TomMD> dons:  I didn't get your message, but I did see one on the ML about that.  I'll get to up, but later tonight
15:27:53 <TomMD> s/up/it/
15:27:55 <dons> TomMD: right, 1.2.3 not compliant
15:28:00 <TomMD> yes
15:28:13 <dcoutts> in fact I think it's a bug in 1.4 that it works
15:28:30 <dcoutts> it should not work, 1.2.3 is correct
15:28:37 <Lord_Illidan> hey, what happens if you use keywords inadvartently as parameters?
15:28:51 <dcoutts> Lord_Illidan: syntax errors
15:29:03 <Lord_Illidan> hmm, i just used the map keyword as a parameter
15:29:06 <Lord_Illidan> and it worked
15:29:11 <dcoutts> map is not a keyword
15:29:31 <Lord_Illidan> oh?
15:29:33 <dcoutts> it's a function defined in the Prelude
15:29:42 <bd_> @src map
15:29:42 <lambdabot> map _ []     = []
15:29:42 <lambdabot> map f (x:xs) = f x : map f xs
15:29:51 <Lord_Illidan> ah..this is better than I thought
15:30:11 <Lord_Illidan> 10x
15:30:49 <bd_> haskell doesn't have very many keywords... module, where, import, qualified, as, in, let, case, of, ->, if, then, else, ::, =, ... am I forgetting any? :)
15:31:03 <mauke> class, instance, deriving
15:31:15 <mauke> do
15:31:32 <dolio> ,
15:31:56 <bd_> ah, right
15:32:00 <bd_> () I suppose, too
15:32:05 <bd_> and =>
15:32:06 <dons> Resolving dependencies...
15:32:12 <dons> go, cabal, go!
15:32:44 <dons> dcoutts: any way to easily prune uninstallable things?
15:33:08 <dons> cabal: cannot configure HRay-1.1. It requires gtk >=0.9.7
15:33:09 <dons> There is no available version of gtk that satisfies >=0.9.7
15:33:11 <dons> that kind of thing
15:33:37 <dcoutts> dons: well ones that just cannot be configured at all on their own are easy but there are much harder cases
15:33:59 * dons just wants an up to date install order for things that have a chance of building
15:34:04 <dcoutts> dons: I'm sure finding a maximal subset of consistent packages is NP-complete
15:34:14 <dons> mmm . you might be right...
15:34:25 <tromp> ~maxclique is...
15:34:37 <dons> stupid combinatorial problems
15:34:37 <dcoutts> well, just finding a single consistent subset is NP-complete
15:34:48 <tromp> empty subset is consistent?
15:35:00 <dcoutts> you can encode 3SAT as a hackage package index problem :-)
15:35:00 <koninkje> bd_: | also counts as a key"word"
15:35:07 <dons> scary
15:35:20 <dcoutts> and that's not even counting configuration flags
15:36:08 <dcoutts> dons: so, yeah we can filter the easy cases where something requires a package that isn't on hackage, but there are other cases where packages have conflicting deps and it's not clear which should be chucked out
15:36:16 <Toxaris> bd_: <-, [, ], {, }, ;
15:36:21 <dons> publishing a minimal subset list that corresponds to the 'haskell platform'
15:36:25 <Toxaris> bd_: unary -
15:36:25 <koninkje> bd_: and () is no more special than [], which is to say it's syntactically special, but just another value not a keyword
15:36:27 <dcoutts> eg if 30 packages need parsec < 2 and 3 need > 3 then it might be obvious
15:36:29 <dons> and a large 'total haskell' subset woudl be enough
15:36:34 <dcoutts> dons: yes, exactly.
15:36:40 <dons> we only need compute it once a week or so
15:36:56 <dcoutts> dons: a platform release would have to be a subset of the consistent packages
15:37:00 <dons> yep
15:37:22 <dcoutts> dons: I imagine that working like GNOME releases
15:37:37 <dcoutts> new release every 6 months with minor updates in between
15:37:52 <dons> yeah
15:38:02 <Toxaris> bd_: @, ~ (or are lazy patterns an extension?),
15:38:10 <dcoutts> consistent set of packages tested together and buildable and tested on all platforms
15:38:22 <dons> yes, that list would be valuable
15:38:35 <dons> a hackage translation tool, like cabal2arch, could build the platform automatically
15:38:39 <dcoutts> right
15:38:44 <dcoutts> that's my aim
15:38:51 <dons> i think we're almost there
15:39:03 <dons> i mean, i'm manually pruning down to a 'total haskell' set atm
15:39:06 <dcoutts> do more central QA so that cabal->native translation can be more automatic
15:39:07 <dons> we'll see how it goes
15:39:20 <dcoutts> so that each distro does not have to do the QA
15:39:25 <dons> lots  of things depend on some silly 'gtk' package
15:39:33 <dcoutts> dons: that's why I resigned as a gentoo dev, to do this stuff centrally
15:39:40 <dons> cool
15:39:53 <dcoutts> yeah, and gtk needs to be on hakage
15:40:02 <koninkje> Toxaris: I forget if lazy patterns are an extension, but "~" is invalid as an operator, so...
15:40:13 <dons> the consistent subset is pretty big, it seems
15:40:15 <Botje> koninkje: it's not an exception
15:40:20 <Botje> *extension
15:40:21 <dcoutts> dons: yes, about 560 packages
15:40:21 <Botje> dammit
15:40:37 <dcoutts> dons: about 80 fewer with 6.6
15:40:50 <koninkje> Botje: is it H98 or just canonical?
15:40:54 <dcoutts> dons: I get about 150 failures with 6.8 out of those 560
15:41:13 <Toxaris> so many nice characters are unavailable as operators :(
15:41:20 <nus> dcoutts, does Cabal do "garbage collection"?
15:41:20 <dons> not bad for a first run
15:41:28 <Botje> i'm not an expert, but i remmeber seeing it in the report
15:41:35 * Toxaris would like to have (@) = (<*>)
15:41:40 <dcoutts> dons: now that cabal-install logs build reports we should be able to manage that more easily
15:41:58 <dcoutts> dons: there's code for loading a build report log so you can run whatever queries you like
15:42:05 <dons> nice
15:42:06 <dcoutts> nus: no
15:42:08 <koninkje> Toxaris: it's not the characters that are excluded, it's the entire token:
15:42:09 <koninkje> > let (~~) = (+) in 1 ~~ 2
15:42:10 <lambdabot>  3
15:42:35 <koninkje> > let (@@) = (+) in 1 @@ 2
15:42:36 <lambdabot>  3
15:42:57 <Toxaris> koninkje: hmm ok slightly better, but still not the same I would write on a blackboard
15:42:58 <dons> oh, that's a pity. hpodder isn't conistent?
15:43:05 <dons> that's one of the most popular debian programs in haskell
15:44:12 <Botje> > let ✪ = (<*>) in return (+1) ✪ Just 5
15:44:12 <lambdabot>  Illegal character ''\156''
15:44:12 <lambdabot>  at "" (column 6)
15:44:18 <Botje> booo!
15:44:18 <koninkje> Toxaris: agreed. I'd enjoy it if @ was used for indexing in lieu of ! or !! (as part of the effort to move "!" towards only meaning strictness)
15:44:38 <bd_> koninkje: I mean, ( expression ) :)   Toxaris: don't forget \ :)
15:44:59 <koninkje> then again I'm all for allowing trailing ! in entity names so we could have foldr! instead of overloading the meaning of primes everywhere
15:45:11 <nus> dcoutts, so, manual cleanup on every update? or you consider it more a distribution pkg manager concern?
15:45:46 <vixey> I'm not keen on !
15:46:05 <koninkje> bd_: reminds me of explaining the functor [] to people... :)
15:46:09 <dcoutts> nus: thing is, it's not clear what it means to clean up. What packages are no longer needed? Do you only need the latest version of everything?
15:46:19 <koninkje> vixey: in what sense?
15:46:22 <vixey> seems like f.g should be rewritten f . g if you allows f!
15:46:49 <dcoutts> nus: also cabal-install currently does not do uninstalling at all. It does not track what files it installs.
15:46:52 <Toxaris> koninkje: what about allowing *all* characters inside (but not at the start) of identifiers, and force the user to use spaces to terminate characters?
15:46:53 <koninkje> vixey: I was meaning that the trailing ! is part of the identifier name, just like ' does
15:47:23 <dcoutts> nus: so yes it can be done by distros and for people who use cabal-install, well it's another feature we've not yet implemented.
15:47:37 <vixey> I don't like it because ! is an operator on its own (but ' is not)
15:48:00 <koninkje> Toxaris: that may be too liberal for computer parsers to enjoy (or human parsers for that matter). ' ! ? seem like reasonable exceptions, but beyond that I'm not so sure
15:48:22 <koninkje> @hoogle (!)
15:48:22 <lambdabot> Data.Map.(!) :: Ord k => Map k a -> k -> a
15:48:23 <lambdabot> Data.IntMap.(!) :: IntMap a -> Key -> a
15:48:23 <lambdabot> Data.Array.IArray.(!) :: (IArray a e, Ix i) => a i e -> i -> e
15:48:29 <nus> dcoutts, yep, I see. Let the user tweak the merge/unmerge plan, giving him the max version plan and a backtracking plan, seems the way to go.
15:48:41 <Toxaris> koninkje: I don't see a problem. (noneOf whiteSpace) seems to be an easy parser to me
15:49:02 <dons> dcoutts: http://code.haskell.org/arch/install-plan.txt how's that?
15:49:18 <koninkje> vixey: There's a general movement for trying to get away from the use of !/!! as indexing lookup. If (and only if) that goes through would the proposal to allow trailing ! in names be sensible
15:49:19 <dons> dcoutts: but it doesn't look like its in dependency order
15:49:37 <dons> dcoutts: but its what i get from cabal install --dry-run
15:49:45 <dcoutts> dons: what's not in order?
15:50:14 <koninkje> Toxaris: the human parser is more important. Is (a+) a section or a name? a*b ?
15:50:16 <dons> well, it looks to be in alphabetical order, i was expecting a build order
15:50:36 <Toxaris> koninkje: clearly both names.
15:50:58 <dcoutts> dons: it should be a perfectly good build order
15:51:01 <koninkje> Toxaris: that is, I'd like not to have to put spaces everywhere in my programs because the tokenizer is excessively liberal
15:51:27 <dons> dcoutts: oh, its a 'cabal install' order
15:51:28 <dcoutts> dons: the reason that it looks alphabetical is because for many packages there is no order constraint and it picks them out of a ordered Map
15:51:39 <dons> if i ran cabal install on each of those, cabal install can handle the deps
15:51:45 <dcoutts> dons: no
15:51:46 <dons> but its not listing the dependencies themselves?
15:51:51 <Toxaris> koninkje: sure, that's the trade-off. From my POV, not to put spaces everywhere is a totally nonsense, so there is no problem. But I agree that this is a very personal POV induced by my coding style
15:51:51 <eu-prleu-peupeu1> hmm
15:51:52 <koninkje> requiring spaces, while it works, is tantamount to admiting defeat
15:52:03 <eu-prleu-peupeu1> how do i specify a list with 10 0's ?
15:52:05 <dons> dcoutts: hmm. so ghc-core is listed, but it depends on e.g. pcre-light, which isn't listed
15:52:06 <dcoutts> dons: it's the toplogical install order. That is the order that it would install them in if you omit --dry-run
15:52:14 <roconnor> > repeat 10 0
15:52:15 <koninkje> (defeat at writing the tokenizer I mean)
15:52:15 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[t2]'
15:52:18 <dcoutts> dons: that'll be because pcre-light is installed
15:52:23 <dons> ah i see.
15:52:26 <roconnor> ?
15:52:27 <dons> so i should blank out my system first
15:52:33 <roconnor> @type repeat
15:52:34 <lambdabot> forall a. a -> [a]
15:52:42 <roconnor> oh
15:52:44 <Toxaris> koninkje: whyshouldyounotputspacesbetweendifferentwordswichformasentence?itstheobviousthingtodo,andhasbeeninventedabout2000yearsagoforagoodreason
15:52:45 <dons> then what would it list? pcre-light *before* ghc-core ?
15:52:47 <mauke> > replicate 10 0
15:52:48 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
15:52:49 <roconnor> > replicate10 0
15:52:50 <lambdabot>   Not in scope: `replicate10'
15:52:52 <dcoutts> dons: or use the code and supply it with an installed index containing just the ghc core packages.
15:52:55 <roconnor> bah
15:52:58 <roconnor> what mauke said
15:53:08 <pjdelport> > take 10 $ repeat 0
15:53:09 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
15:53:19 <roconnor> @src replicate
15:53:20 <lambdabot> replicate n x = take n (repeat x)
15:53:38 <koninkje> Toxaris: wellitdependsonwhichlanguagesyouspeak. japanese,chinese,andheckevengermanseemtodofine
15:53:40 <chessguy> @pl \n x -> t n (r x)
15:53:40 <lambdabot> (. r) . t
15:53:41 <eu-prleu-peupeu1> nice :)
15:54:05 <dcoutts> dons: so yes, a quick hack would be to rename your per-user ghc package index temporarily, thus simulating a clean installed package index
15:54:19 <dcoutts> dons: unless you've got lots of packages registered globally too
15:54:39 <dons> well, i can clean it all up pretty cheaply. pacman --remove ghc
15:55:13 <Toxaris> koninkje: warumsolltedasimdeutscheneinfacherzulesensein? whyshouldthatbeeasiertoreadingerman?
15:55:14 <dcoutts> dons: but that doesn't work, it needs ghc-pkg and it needs the base, rts and ghc packages to be installed
15:55:23 <dcoutts> dons: since they do not exist on hackage
15:55:25 <dons> yep. i'll reinstall ghc, and try again
15:55:38 <chessguy> Toxaris:  aren't nouns capitalized in german?
15:56:01 <dcoutts> dons: I recommend getting the ghc arch package to keep a clean copy of the ghc package db. That's what gentoo and debian do. We have a package.conf.shipped
15:56:05 <koninkje> Toxaris: German noun-noun compounds have a special place in many people's hearts, even if the language as a whole tends towards spacing
15:56:11 <dons> but i'm confused, even if i do that, its not going to give me the packages in dependency order, is it? i.e. something starting with A will always be first from --dry-run?
15:56:20 <roconnor> @. pl @src replicate
15:56:21 <lambdabot> Plugin `compose' failed with: Unknown command: "@src"
15:56:28 <roconnor> @. pl src replicate
15:56:28 <lambdabot> (line 1, column 1):
15:56:28 <lambdabot> unexpected end of input
15:56:28 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:56:50 <dons> i expected to see things in the order, say, binary ; pcre-light ; mersenne-random ; ghc-core
15:57:06 <dcoutts> dons: no, as I said, it's a proper toplogical sort. It's an install order. It's just that when there are no other constraints, we arbitrarily pick in alphabetical order because we're using an ordered finite map.
15:57:15 <Toxaris> koninkje: oh, I see.
15:57:38 <dons> ah  no , i see.
15:57:39 <dcoutts> dons: binary is not listed because it doesn't need to be re-installed.
15:57:55 <dcoutts> dons: unregister binary and try again, you'll see.
15:57:57 <dons> yes, you're right. i see some non-alpha orderings
15:58:01 <dons> yes yes. all good.
15:58:18 <Toxaris> chessguy: yes they are, but that doesn't help that much with lexing I think.
15:58:20 <dons> excellent.
15:58:44 <roconnor> @src replicateM
15:58:44 <lambdabot> replicateM n x = sequence (replicate n x)
16:02:16 <tusho> Interesting discussion!
16:04:48 <monochrom> Neato, Data.List.stripPrefix exists right at the time I want it. :)
16:05:45 <mauke> :t stripPrefix
16:05:46 * monochrom suspect that haskell libraries can predict what I need and make it available just in time. lazy development? :)
16:05:47 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
16:06:00 <mauke> why isn't it called dropPrefix?
16:06:02 <roconnor> whoever added stripPrefix is a genius.
16:06:17 <monochrom> > (stripPrefix "hello" "hello you", stripPrefix "hello" "hi there you")
16:06:18 <lambdabot>  (Just " you",Nothing)
16:06:41 <roconnor> mauke: maybe strip is sexier than drop
16:07:20 <monochrom> hehe
16:07:39 <dcoutts> TomMD: I've fixed Cabal-1.4 so that it should not build pureMD5-0.2.0 as-is. Cabal-1.2.x had the correct behaviour here.
16:08:46 <dcoutts> TomMD: the fix is to remove the hs-source-dirs field completely. You do not need it in this case and specifying incorrect src dirs overrides the default which is ["."]
16:09:51 <dcoutts> TomMD: the bug was that we were always using "." as a src dir even when the user specified their own src dirs
16:10:09 <dcoutts> it's supposed to only use "." if no other src dirs are given
16:11:04 <eu-prleu-peupeu1> "Note that while arrays are O(1) access, they are not O(1) update. They are in fact O(n) update, since in order to maintain purity, the array must be copied in order to make an update."
16:11:05 <TomMD> dcoutts: so that will give me a warning on hackage too?
16:11:06 <eu-prleu-peupeu1> why is this ?
16:11:19 <eu-prleu-peupeu1> isn't this a very big price to pay for purity ?
16:11:25 <lament> it is.
16:11:31 <lament> that's why there's also mutable arrays.
16:11:33 <lament> err
16:11:37 <lament> better mutable :)
16:11:39 <eu-prleu-peupeu1> ah ok
16:11:39 <eu-prleu-peupeu1> :P
16:11:43 <eu-prleu-peupeu1> sorry then
16:12:03 <TomMD> eu-prleu-peupeu1: You are darned persistent for a troll ;-)
16:12:08 <Cale> eu-prleu-peupeu1: However, we don't tend to use mutable arrays all that much.
16:12:09 <yav> hey dcoutts: i have a cabal question for you
16:12:28 <eu-prleu-peupeu1> Cale: why ?
16:12:30 <dcoutts> TomMD: well, once hackage updates to the latest Cabal then it'll fail to build yes. The fix will be in Cabal-1.4.0.1 and later.
16:12:38 <yav> can i use Setup install to install just to documentation for a package somehow
16:12:45 <Cale> eu-prleu-peupeu1: More often, something like Data.Map, which is both pure and supports relatively efficient updates is more convenient and easier to get right.
16:12:50 <dcoutts> TomMD: sorry that the fix makes your package break :-(
16:12:58 <eu-prleu-peupeu1> oh i see
16:13:06 <dcoutts> yav: if it's quick, I'm off to bed
16:13:14 <TomMD> dcoutts: sounds great, you rock.  Don't worry about 'breaking' my packages when they are already broken for some people
16:13:39 <TomMD> dcoutts++ -- for general cabal work
16:13:47 <dons> TomMD: btw, i've a tool that depends on a working pureMD5
16:13:53 <dcoutts> yav: oh, you asked already, :-) the answer is no, you can configure and then build the docs, but installing will always try to install the code too.
16:14:11 <yav> hm. ok, thanks!
16:14:22 <mauke> preflex uses pureMD5!
16:14:33 <dcoutts> TomMD: as I say the fix just involves deleting one line from the .cabal file, remove the hs-source-dirs: field.
16:14:51 <TomMD> dons: really? wow, I didn't know there were users before yesterday.
16:14:51 <Cale> eu-prleu-peupeu1: Data.Map has O(log n) updates and accesses, which is effectively constant time, given that nobody has more than a constant amount of memory to store elements (which, by the way, is the same reason that memory access is considered O(1) and not O(log n)).
16:15:04 <dons> TomMD: cabal2arch, the main tool for generating arch packages.
16:15:18 <dons> please fix please plz. thanks.
16:15:31 <dcoutts> yav: there is an open tickets requesting this feature. Perhaps you could add your comments to that, say that you need it, how much of a pain it is that you can't do it and say how you would expect it to work.
16:15:42 <jsnx> I'm trying to install a Cabal package, and ld is giving me an 'atom sorting error': http://hpaste.org/8323
16:15:48 <Cale> pls fix pls pls thx
16:15:55 <eu-prleu-peupeu1> is it ? i thought it was because memory access is considered to be "one" operation, hence O(1)
16:16:11 <jsnx> hai
16:16:13 <TomMD> Oh, its fixed, don't worry.  I should have used KATs from the start, but just wasn't motivated (and scared to put too much work into it)
16:16:15 <yav> dcoutts: can i copy and paste that :)  i'll look for the ticket at some point
16:16:16 <dcoutts> yav: especially the last point. It's much easier to code something up if we know how it's supposed to behave, rather than just that there should exist a way of doing X.
16:16:27 <jsnx> i has atom sorting err
16:16:29 <Cale> eu-prleu-peupeu1: Well, there's no way that you can build an architecture which has uniform access speed to unbounded amounts of memory. It's physically impossible.
16:16:38 <jsnx> kthxbye
16:17:00 <Cale> eu-prleu-peupeu1: The fact that there's a bound on the amount of memory in the machine puts a bound on address sizes, which allows memory accesses to be "constant time".
16:17:26 <Cale> But when talking about asymptotic costs, putting bounds on the amount of memory available trivialises everything.
16:18:56 <jsnx> memory access -- the pleasure of infinity, delivered in constant time
16:19:03 <eu-prleu-peupeu1> Cale: you are aware that big-O notation is not about time...right ?
16:19:09 <roconnor> bascially array access are only constant time when arrays larger than maxBound :: Int are not allowed.
16:19:22 <Cale> eu-prleu-peupeu1: I'm aware that it's about classes of functions.
16:19:57 <lament> "IT'S ABOUT TIME!"
16:19:59 <roconnor> otherwise just reading the index to an array takes O(log n), let alone accessing the memory.
16:19:59 * lament vanishes
16:20:22 <TomMD> Is haskell.org down?
16:20:48 <Cale> Really, you can't design a physically realistic architecture which can access unbounded amounts of memory in any better than O(n^(1/3)) time, as the amount of memory increases.
16:20:50 <eu-prleu-peupeu1> hmmm
16:20:54 <Cale> Let along logarithmic time.
16:20:57 <Cale> alone*
16:21:08 <dons> TomMD: looks to be
16:21:18 <eu-prleu-peupeu1> my understanding of algorithms is not as deep as yours, so my mind becomes confused when i read your exaplantions
16:21:32 <mmorrow> TomMD: looks like that to me too (but it responds to my pings)
16:21:55 <TomMD> Would anyone find find a pureSHA line useful?
16:21:58 <Cale> Well, as far as we know, you can't move information through space any faster than the speed of light, and you can only store a finite amount of information in a fixed amount of space.
16:22:04 <lament> Cale: what if you uncurl the curled dimensions?
16:22:15 <marcot> Good evening.
16:22:17 <lament> you can easily improve that to O(n^(1/11)) !
16:22:28 <Cale> lament: hah
16:22:35 <Toxaris> Cale: why can't you store unlimited amount of information in fixed amount of spacE?
16:22:49 <marcot> Is haskell.org down?
16:22:54 <jsnx> marcot: i think so
16:22:56 <TomMD> marcot: yes
16:23:08 <roconnor> Cale: if you believe the holographic principle, you can only store a fixed amount of information in a fixed surface area of space.
16:23:14 <Peaker> what if the amount of information is a superlinear function of the amount of space (e.g qubits)?
16:23:22 <Cale> roconnor: Yes, I sometimes point that out too :)
16:23:22 <jsnx> Toxaris: well, can you store an unlimited amount of anything in a finite amount of space?
16:23:28 <Cale> roconnor: That makes it O(n^(1/2)) :)
16:23:30 <lament> the amount of information in a qubit is one bit.
16:23:45 <lament> the amount of information that can be stored in a region of space is firmly fixed by quantum mechanics.
16:23:50 <roconnor> lament: I thought it is more like 2 bits
16:24:00 <Peaker> lament, but the amount of information in two qubits is more than 2 bits
16:24:03 <jsnx> i store infinite love in my heart
16:24:03 <roconnor> granted, they are different units, so it is a bit hard to compare
16:24:14 <lament> the amount of love that can be stored in jsnx's heart is infinite.
16:24:22 <jsnx> indeed
16:24:29 <roconnor> anyhow, this notion of space is outside the typical computing model.
16:24:31 <Cale> lament: But that love only has finite Kolmogorov complexity.
16:24:32 <lament> we should make computers use your love for storage
16:24:39 <roconnor> let's get back to log(n)
16:24:46 <jsnx> last friday, i hung out with a 4 year old who showed me the stone with everyone's love in it
16:24:50 <jsnx> the love stone
16:25:00 <jsnx> it was only a litre or so
16:25:06 <Cale> Yeah, the logarithmic bound is easy to understand without physics.
16:25:07 <TomMD> lament: its volatile, so not a good idea.
16:26:16 <Cale> You need O(log(n)) bit addresses to address n different memory locations.
16:26:18 <dons> 539 packages in my install plan, dcoutts
16:26:25 <lament> jsnx: love stone, nice
16:26:28 <eu-prleu-peupeu1> :P
16:26:45 <lament> jsnx: i was wondering where all that love went
16:26:48 <Cale> So just manipulating the addresses of n memory locations takes O(log n) time at best.
16:27:39 <Cale> So array accesses are actually at least O(log n) time, even though we usually simplify matters and call it O(1), because we know that there's only a finite amount of memory in our machines.
16:27:58 <eu-prleu-peupeu1> Cale
16:28:02 <eu-prleu-peupeu1> what if they are cached ?
16:28:03 <eu-prleu-peupeu1> :P
16:28:19 <TomMD> Humm... it takes a lot to get on p.h.o.  8 day wait period - I can get a hand gun faster than this.
16:28:31 <Peaker> does turing completeness include the infinite size of memory that should be accessible? If so, does O(1) memory access imply turing incompleteness?
16:28:38 <Toxaris> jsnx: I don't really understand physics, but I'm thinking about something like electrical field intensity, which can be superimposed without actually "needing" space.
16:28:38 <Cale> Even if they're cached, the cache needs to look at those log(n) bits to tell that that address is in the cache.
16:29:08 <SamB_XP_> wouldn't that require you to expand existing memory cells when you add memory to the computer?
16:29:09 <Cale> Peaker: yes, technically, I would agree with that
16:29:14 <eu-prleu-peupeu1> you know there is a clock in your computer, right ?
16:29:20 <Cale> eu-prleu-peupeu1: Indeed I do.
16:29:27 <eu-prleu-peupeu1> do you know that everything keeps synchronized to that clock beat ?
16:29:32 <jsnx> Toxaris: well, how do you get the charge without putting some electrons in space?
16:29:36 <Cale> eu-prleu-peupeu1: Yes, and that's besides the point.
16:29:53 <Cale> eu-prleu-peupeu1: My machine isn't even of the same kind that one discusses when one talks about algorithmic complexity.
16:30:18 <eu-prleu-peupeu1> so, how come you say that it needs long(n) to do cache look-up ?
16:30:43 <Cale> n is about 32 in my case.
16:30:49 <Cale> and the constant is small
16:30:58 <Cale> er, sorry
16:31:03 <Cale> n is about 2^32 rather
16:31:15 <Toxaris> eu-prleu-peupeu1: my machine uses 32bit pointers. to process a n bit adress to some huge storage array, it needs n / 32 operations, which is clearly not constant.
16:31:53 <Cale> If I wanted to put more than 2^32 addressable memory locations into my machine, I would need to change my machine's architecture.
16:32:21 <oklofok> "Peaker: does turing completeness include the infinite size of memory that should be accessible? If so, does O(1) memory access imply turing incompleteness?" <<< i don't get that logic, can someone explain?
16:32:24 <Cale> However, when you write out the definition of something like O(log(n)), you'll note that the bound only applies for n *larger* than an arbitrary constant.
16:32:47 <sms_> TomMD, i'm using pureMD5, too. 1.2 since 2.0 refuses to work
16:32:50 <Peaker> oklofok, A turing machine, by definition, has infinite memory - its not finite. If it was finite, then you could solve the halting problem for it
16:33:29 <Peaker> oklofok, infinite memory requires non-constant memory access time.  We have constant-memory access time only because we have finite memory.  So turing completeness (infinite memory) disagrees with constant-time memory access
16:33:36 <Toxaris> oklofok: turing machines have infinite memory, real machines not. so there is no turing complete real machine.
16:33:39 <EvilTerran> if nothing else, by constructing a DFA of all possible <alphabet size>^<memory size> states
16:33:50 <eu-prleu-peupeu1> ish
16:34:04 <oklofok> Peaker: why can't infinite memory have constant memory access time?
16:34:13 <oklofok> where's the contradiction?
16:34:13 <Peaker> oklofok, Cale addressed that above
16:34:17 <oklofok> hmm
16:34:26 <EvilTerran> ... multiply by memory size, to include the position of the tape head
16:34:29 <Cale> oklofok: Because addresses get larger and larger, and thus take longer to manipulate.
16:34:34 <oklofok> addresses?
16:34:51 <Cale> oklofok: yes -- relative or absolute locations of things in the memory.
16:35:12 <EvilTerran> haskell's Integers are O(log n) for various operations
16:35:23 <Peaker> EvilTerran, for what n?
16:35:26 <Cale> In fact, with a strict turing machine, it takes n steps to move n spaces along the tape, so you're *much* worse off than constant time access.
16:35:38 <EvilTerran> Peaker, the magnatude of the values being manipulated
16:35:57 <Peaker> EvilTerran, (^) specifically?
16:36:07 <Cale> A turing machine whose tape was a large binary tree might be somewhat more realistic in terms of cost model.
16:36:08 <EvilTerran> what?
16:36:15 <Peaker> EvilTerran, which operations?
16:36:19 <oklofok> well, with a mathematical model, you can choose what ordos mean for it
16:36:23 <Cale> (where by large, I mean infinite)
16:36:27 <EvilTerran> well, (+), for starters
16:36:30 <eu-prleu-peupeu1> brb
16:36:41 <oklofok> but yeah, i guess the problem is you're somehow mixing real world with turing-completeness
16:36:41 <Peaker> EvilTerran, oh, Integers, not Ints, sorry :)
16:36:45 <EvilTerran> T(x + y) = O(log x + log y)
16:36:54 <EvilTerran> you need to do one operation for each digit
16:37:00 <Cale> oklofok: Okay, I agree that you can posit a kind of machine which has constant time access to infinite amounts of memory. It's just unrealistic.
16:37:01 <EvilTerran> that's what it boils down to
16:37:15 <Cale> You can also posit machines which can take an infinite number of steps in finite time.
16:37:21 <oklofok> Cale: the infinity part is unrealistic, yeah
16:37:31 <eu-prleu-peupeu1> why is memory access O(log n) ?
16:37:35 <EvilTerran> Cale, i imagine either of those could be derived from the other
16:37:42 <eu-prleu-peupeu1> shouldn't hardware implement it on O(c) ?
16:37:43 <Cale> oklofok: Not just the infinity part -- you might only use a finite subset of that memory in any computation which terminates.
16:37:57 <eu-prleu-peupeu1> c = log n ? :/
16:38:07 <EvilTerran> eu-prleu-peupeu1, basically what i just said - when manipulating addresses, you need to do one operation per digit, so any manipulation is at best logarithmic in the length of the number
16:38:11 <Cale> eu-prleu-peupeu1: Only if the hardware supports a finite amount of memory will it be constant.
16:38:17 <EvilTerran> assuming arbitrarily big memory
16:38:30 <EvilTerran> if there's an upper limit on the memory available, then it's trivially constant time
16:38:31 <eu-prleu-peupeu1> ah, ok
16:38:44 <EvilTerran> (upper limit being the worst possible access time)
16:38:58 <Cale> If you can just keep putting more and more memory into the system in order to do larger computations, those computations will become slower.
16:39:02 <eu-prleu-peupeu1> so, 32bits, means log(32), which is constant so, O(c)
16:39:11 <EvilTerran> exactly, O(1)
16:39:25 <vixey> don't write O(c) write O(1)
16:39:32 <roconnor> 32 bits means log(2^32) so O(1)
16:39:40 <eu-prleu-peupeu1> vixey: why ?
16:39:41 <vixey> c is suggesting there is some variable
16:39:42 <EvilTerran> constant factors can be dropped in O()s, so it's equivalent
16:39:46 <Cale> eu-prleu-peupeu1: Of course, the exact same argument applies to accesses in binary trees in a finite machine.
16:39:49 <eu-prleu-peupeu1> okey
16:40:12 <Cale> Or even accesses to lists, which are normally O(n) to get to the nth element
16:40:14 <EvilTerran> i could go into the formal definitions of O() to justify this claim, but i doubt either of us can really be bothered
16:40:25 <eu-prleu-peupeu1> eheh
16:40:27 <Cale> Once you have a constant bound on n, everything becomes constant time.
16:40:28 <eu-prleu-peupeu1> ok
16:40:29 <eu-prleu-peupeu1> i understand
16:41:05 <eu-prleu-peupeu1> you guys are very meticulous, so much it is hard for me to understand your argumentation base...
16:41:24 <SamB_XP_> Cale: but is any such bound still there once you connect the machine to the internet?
16:41:32 <Cale> SamB_XP_: yes.
16:41:33 <proq> eu-prleu-peupeu1: nothing a little black tea won't fix
16:41:39 <SamB_XP_> Cale: how so?
16:41:39 <Cale> SamB_XP_: The internet is still finite :)
16:42:03 <SamB_XP_> is it?
16:42:05 <EvilTerran> f(n) = O(g(n))  <=>  (lim_{n -> +Inf} g(n) / f(n)) > 0
16:42:07 <Cale> SamB_XP_: However, I agree that this is a useless way to look at things, if it's all you have.
16:42:20 <dmwit> SamB_XP_: The Universe is finite.
16:42:21 <EvilTerran> multiply g by a constant factor and the result will still work the same
16:42:30 <dmwit> But yeah, this isn't very helpful.
16:42:32 <SamB_XP_> dmwit: have you seen the whole universe?
16:42:39 <lament> preflex: nickometer eu-prleu-peupeu1
16:42:39 <preflex>  eu-prleu-peupeu1 is 42% lame
16:42:43 <dmwit> Of course not.
16:42:46 <vixey> I doubt you can prove it ...
16:42:54 <Cale> preflex: nickometer Cale
16:42:55 <preflex>  Cale is 0% lame
16:42:56 <ahunter_> quick ghc build-related question:  I have a fully-built GHC repository, and want to build one of the utils (nofib-analyse) using my newly built GHC, and my checked out/built libraries (as opposed to the libs/ghc installed on my system.) Is there an easy way to do this?
16:42:59 <Cale> hah!
16:43:08 <EvilTerran> i think most contemporary models of the universe consider it finite
16:43:13 <EvilTerran> preflex: help
16:43:13 <preflex>  try 'help help' or see 'list' for available commands
16:43:23 <dmwit> preflex: nickometer elite
16:43:23 <preflex>  elite is 62% lame
16:43:24 <vixey> models are not the real thing
16:43:30 <Peaker> EvilTerran, most of those models don't predict we'll be sucked into a black hole soon, but some do :)
16:43:33 <SamB_XP_> EvilTerran: that's only because they watched the Matrix too many times
16:43:33 <slava> nickometer pr3d4t0r
16:43:43 <slava> preflex: nickometer pr3d4t0r
16:43:43 <preflex>  pr3d4t0r is 99.911218% lame
16:43:45 <Toxaris> If finite space means finite information, and the Universe itself is finite, does that mean that everything is O(1)?
16:43:46 <slava> hahaha
16:44:00 <dmwit> Toxaris: yes
16:44:22 <EvilTerran> for sufficiently big values of 1 :P
16:44:42 <shapr> d00d, w4ssup?
16:44:50 <EvilTerran> @. elite yow
16:44:51 <lambdabot> COU|Dn'7 phind fOR7uN3 FIle
16:44:55 <EvilTerran> ERROR
16:44:58 <koninkje> preflex: nickometer koninkje
16:44:58 <preflex>  koninkje is 0% lame
16:45:00 <shapr> 3RR0R !
16:45:07 <shapr> preflex: nickometer shapr
16:45:07 <preflex>  shapr is 0% lame
16:45:10 <shapr> whew
16:45:16 <roconnor> dmwit: isn't the universe getting bigger?
16:45:38 <dmwit> roconnor: immaterial, the number of states is not increasing
16:45:55 <roconnor> why not?
16:46:05 * dmwit ponders
16:46:19 <dmwit> Insufficient information to form a meaningful answer.
16:46:23 * roconnor thinks up a theory of quantum gravity
16:46:33 <EvilTerran> roconnor, 42
16:46:56 <koninkje> what was the question?
16:47:05 <roconnor> koninkje: why not?
16:47:25 <dmwit> Suppose the amount of matter is finite, and the number of particles is not increasing.  But each particle is increasing.  Is the number of possible states increasing?
16:47:36 <EvilTerran> koninkje, no, "what?!" was the question :P
16:47:44 <roconnor> particles come and go with vacuum fluctuations
16:48:17 <lament> particles come and go, but waves are forever
16:48:19 <roconnor> more universe => move vacuum fluctuations ?
16:48:32 <dmwit> Or, in spirit: if we assume the universe is finite *right now*, can the number of possible states increase as time goes forward?
16:48:36 <roconnor> lament: that is a fair point.
16:48:56 <Peaker> dmwit, there is just 1 possible state? :)
16:49:07 <koninkje> roconnor: but the net of fluctuations is 0 (last I heard) hence only the deviation of the curve would be changing (if that)
16:49:15 <EvilTerran> what is an interrogative
16:49:18 <dmwit> Peaker: I don't think so, or else we're all in serious trouble.
16:49:29 <EvilTerran> yay determinism!
16:49:31 <lament> EvilTerran: just don't ask what an imperative is!
16:49:32 <dmwit> EvilTerran: Neat!
16:49:32 <Peaker> dmwit, if the universe is deterministic, that is
16:49:53 <dmwit> EvilTerran: I guess you already knew that your sentence works as both a sentence as a question.  very cool =)
16:49:55 <dmwit> Peaker: Even so.
16:50:01 <dmwit> Peaker: For example:
16:50:03 <EvilTerran> dmwit, indeed, that was the idea :P
16:50:10 <roconnor> I think quantum gravity is needed to answer this question.
16:50:20 <dmwit> Peaker: Given a light switch, there are two possible states, even though only one of them is the one we're "in".
16:50:40 <dmwit> Peaker: I'm talking about "possible states" in the thermodynamic sense of the word.
16:50:40 <Peaker> dmwit, why not millions of intermediate states?  What defines a "possible" state?
16:51:07 <dmwit> Peaker: Of course, there are lots of intermediate states.  I was just pointing out that determinism doesn't restrict you to only one possible state.
16:51:07 <EvilTerran> <teacher> begin a sentence starting with "I..." <pupil> "I is-" <teacher> no no no! you must say "I am..." <pupil> oh, okay. "I am the ninth letter of the alphabet."
16:51:23 <monochrom> haha
16:51:34 <koninkje> EvilTerran++
16:51:48 <EvilTerran> :D
16:51:53 <augustss> heh
16:52:44 <roconnor> > fromEnum 'I'
16:52:45 <lambdabot>  73
16:52:47 <Peaker> dmwit, well, by that sense of "possible" then why are there not always infinite possibilities -- as the universe "could have" more or less particles, to any finite number
16:53:00 <dmwit> Peaker: Ever heard of Planck's constant?
16:53:11 <dmwit> wait
16:53:24 <Peaker> dmwit, yeah, what about it?
16:53:28 <roconnor> Peaker: why there is more matter than antimatter is one of the great mysteries of the universe.
16:53:39 <dmwit> Peaker: Sorry, that was unrelated, I hadn't finished reading your comment. =P
16:53:40 <roconnor> Personally, I'm holding out for CPT violations.
16:53:58 <dmwit> roconnor: Why should that be a mystery?
16:54:08 <dmwit> roconnor: Surely it's not surprising that there's more of *one* of them.
16:54:10 <Cale> antimatter is just what matter looks like when it's moving backwards in time :)
16:54:34 <dmwit> roconnor: And in that case won't it pretty much annihilate until the one there's more of pretty much dominates?
16:54:35 <jsnx> consume antimatter to regain your youth...
16:54:45 <Peaker> roconnor, why do they think that there is more matter in the universe? Maybe some parts of the universe have more antimatter instead?
16:55:06 <roconnor> dmwit: I'm not aware of any physical process that produces more matter than antimatter.
16:55:07 <eu-prleu-peupeu1> what happens when i reach 100% lame ?
16:55:17 <eu-prleu-peupeu1> do i get a free beer ? :P
16:55:20 <jsnx> epic fail?
16:55:20 <roconnor> Peaker: I've wondered about that too.
16:55:30 <EvilTerran> preflex: nickometer 1337
16:55:30 <preflex>  1337 is 63% lame
16:55:36 <dmwit> roconnor: What are the chances that the universe came into being with an *exact* balance of matter and antimatter?
16:55:45 <Cale> preflex: nickometer lame
16:55:45 <preflex>  lame is 62% lame
16:55:51 <jsnx> preflex: nickometer jsnx
16:55:51 <preflex>  jsnx is 0% lame
16:56:00 <roconnor> dmwit: isn't that is the theory?
16:56:02 <Peaker> dmwit, if time is a part of the universe, "came into being" cannot mean anything for the universe
16:56:03 <Cale> preflex: nickometer preflex
16:56:03 <preflex>  preflex is 0% lame
16:56:14 <Cale> preflex: nickometer is
16:56:14 <preflex>  is is 0% lame
16:56:24 <dmwit> roconnor: I am far out of my depth.  I don't know what the theory is. =P
16:56:32 <Cale> preflex: nickometer is 0% lame
16:56:32 <preflex>  is 0% lame is 99.0787% lame
16:56:38 <dmwit> Maybe I should stop talking about my fields of ignorance. =)
16:56:40 <Cale> preflex: nickometer is 99.0787% lame
16:56:40 <preflex>  is 99.0787% lame is 99.8091% lame
16:56:48 <roconnor> dmwit: nah, it's fun!
16:56:49 <Cale> preflex: nickometer is 99.8091% lame
16:56:49 <preflex>  is 99.8091% lame is 99.8158% lame
16:56:56 <Cale> preflex: nickometer is 99.8158% lame
16:56:56 <preflex>  is 99.8158% lame is 99.8114% lame
16:57:02 <Cale> preflex: nickometer is 99.8114% lame
16:57:02 <preflex>  is 99.8114% lame is 99.8158% lame
16:57:03 <roconnor> fix preflix: nicometer
16:57:07 <Cale> aww, cycle
16:57:11 <jsnx> oh, we are nearing a fixed point
16:57:26 * vixey already found the fixpoint :P
16:57:26 <cjay> :D
16:57:28 <dmwit> Somebody found a fixed point the other day.
16:57:30 <lament> preflex: nickometer is 99.8144% lame
16:57:30 <preflex>  is 99.8144% lame is 99.8091% lame
16:57:34 <EvilTerran> preflex: nickometer preflex
16:57:35 <preflex>  preflex is 0% lame
16:57:35 <lament> damn
16:57:58 <jsnx> preflex: nickometer 99.8140%
16:57:58 <preflex>  99.8140% is 84% lame
16:58:03 <jsnx> preflex: nickometer 99.8142%
16:58:03 <preflex>  99.8142% is 77% lame
16:58:08 <EvilTerran> fail
16:58:12 <dmwit> preflex: nickometer 34%
16:58:12 <preflex>  34% is 34% lame
16:58:21 <jsnx> !!
16:58:30 <Cale> preflex: nickometer 34% lame
16:58:30 <preflex>  34% lame is 95.24% lame
16:58:43 <jsnx> preflex: nickometer is 99.8140% lame
16:58:43 <preflex>  is 99.8140% lame is 99.8158% lame
16:58:47 <Cale> preflex: nickometer 95.24% lame
16:58:47 <preflex>  95.24% lame is 99.1545% lame
16:58:48 <jsnx> preflex: nickometer is 99.8144% lame
16:58:48 <preflex>  is 99.8144% lame is 99.8091% lame
16:58:51 <jsnx> preflex: nickometer is 99.8142% lame
16:58:52 <preflex>  is 99.8142% lame is 99.8091% lame
16:58:54 <flux> bet that can keep you guys amused all day/night?
16:58:56 <jsnx> preflex: nickometer is 99.8141% lame
16:58:56 <preflex>  is 99.8141% lame is 99.8158% lame
16:58:58 <Cale> preflex: nickometer 99.1545% lame
16:58:58 <preflex>  99.1545% lame is 99.5539% lame
16:59:01 <dmwit> I vote you try to find the fixpoint in /msg and report it here when you win.
16:59:09 <jsnx> lolz
16:59:16 <lament> preflex: nickometer is 99.8136% lame
16:59:16 <preflex>  is 99.8136% lame is 99.8136% lame
16:59:17 <jsnx> preflex: nickometer lolz
16:59:18 <preflex>  lolz is 0% lame
16:59:21 <lament> i win
16:59:24 <mauke> lament++
16:59:28 <koninkje> Peaker: why? naturally "begin" can't have the temporal reading we usually ascribe to it, but just becasue time is entwined in the existance of the universe doesn't preclude other "..." where/when the universe doesn't exist
16:59:35 <Cale> lament: now classify all the fixed points
16:59:56 <Peaker> koninkje, other what though?
16:59:59 <lament> i found a very small and neat classification
17:00:00 <jsnx> can we please take the "brief history of time" thread to #haskell-blah?
17:00:12 <lament> ... that this channel is too small to contain
17:00:12 <eu-prleu-peupeu1> preflex: haskell
17:00:18 <Apocalisp> preflex: nickometer Apocalisp
17:00:20 <preflex>  Apocalisp is 0% lame
17:00:21 <roconnor> I'm still betting on a CPT violation.  Ever since Yang-Mill's I've lost my faith in symmetry.
17:00:35 <koninkje> Peaker: well we don't rightly have a name for it (or some membrane theorists might), but that doesn't mean the axis doesn't exist
17:00:41 <eu-prleu-peupeu1> ehh
17:00:49 <sclv> cale: you can solve them from here -- http://www.adamspiers.org/computing/nickometer/nickometer.pl
17:01:08 <Peaker> koninkje, the axis would have to be outside the universe, and thus not a "real" thing that exists, no?
17:01:11 <Apocalisp> preflex: nickometer 1337hAxX0r
17:01:11 <preflex>  1337hAxX0r is 99.7984% lame
17:01:19 <roconnor> stupid more particles comming out the left side.
17:01:25 <Peaker> what is 100% lame?
17:01:27 <roconnor> stupid weak nuclear force
17:01:29 <dmwit> Peaker: That's stupid.  Are numbers real?
17:01:45 <Peaker> dmwit, no :)
17:01:57 <Peaker> dmwit, They don't "come into being", anyhow
17:01:58 <koninkje> Peaker: depends on definitions of "real", i.e. exists within the universe vs exists within some larger extant framework of being
17:02:10 <roconnor> preflex: nickometer weak nuclear force
17:02:11 <preflex>  weak nuclear force is 26% lame
17:02:12 <dmwit> Peaker: So what's the point of arguing against something's reality if it doesn't have to be real to be useful?
17:02:21 <vixey> exists ~~ to be constructed
17:02:32 <Cale> define "real"? :)
17:02:36 <lament> preflex: nickometer functional programming
17:02:36 <preflex>  functional programming is 14% lame
17:02:40 <dmwit> Cale: exactly
17:02:44 <Peaker> dmwit, I didn't say it wasn't useful - only that you cannot really say that the "universe came into being" because on some imaginary axis, there are points in which the universe does not exist
17:02:53 <dmwit> Why not?
17:02:53 <mauke> preflex: nickometer C++
17:02:53 <preflex>  C++ is 40% lame
17:02:55 <Apocalisp> I think what Peaker means is that numbers are not existents. They're abstractions from existents.
17:03:15 <lament> preflex: nickometer US foreign policy
17:03:15 <preflex>  US foreign policy is 31% lame
17:03:20 <mauke> preflex: nickometer Object-Oriented Programming
17:03:20 <preflex>  Object-Oriented Programming is 99.8379% lame
17:03:25 <lament> ouch :)
17:03:37 <Peaker> dmwit, if time is part of the universe, then the "universe has always existed" would be true
17:03:55 <koninkje> Apocalisp: but they must be existants within some ontological framework; they "exist" "somewhere" regardless of the terminology we want to slap on them
17:04:05 <Peaker> preflex, nickometer Jesus
17:04:05 <preflex>  Jesus is 0% lame
17:04:06 <dmwit> Peaker: I thought you were arguing that time is not, in fact, part of the universe.  Which side are you on?
17:04:15 <ziman> preflex, nickometer Haskell
17:04:15 <preflex>  Haskell is 0% lame
17:04:16 <sclv> I don't think you can reach 100
17:04:22 <dmwit> (part of the universe, i.e. real)
17:04:32 <Peaker> dmwit, I think time is - but anyhow I haven't said it was or wasn't, only that if it was then ...
17:04:39 <ziman> preflex, nickometer ````````````
17:04:39 <preflex>  ```````````` is 99.99237918% lame
17:04:43 <Cale> preflex: nickometer r0r0r0r0r0r0r0r0r0r0r0r0
17:04:43 <preflex>  r0r0r0r0r0r0r0r0r0r0r0r0 is 99.988881% lame
17:05:04 <elliottt> how is it picking the lame score?
17:05:08 <koninkje> preflex: nickometer j0
17:05:08 <preflex>  j0 is 22% lame
17:05:18 <sclv> elliottt: http://www.adamspiers.org/computing/nickometer/nickometer.pl
17:05:18 <ziman> preflex, nickometer j0j
17:05:18 <preflex>  j0j is 31% lame
17:05:29 <elliottt> ah, excellent.  thanks :)
17:05:31 <Peaker> elliottt, its an oracle machine
17:05:39 <elliottt> hehe
17:05:46 <ahunter_>  @pl p n = length $ enumFromTo 1 n
17:05:52 <sclv> scans for numbers, caps, 3113t3 speak, keywords, and a few special cases.
17:05:56 <sclv> and length.
17:05:57 <mauke> SELECT score FROM nickometer WHERE nick = ?
17:05:57 <dmwit> ?nickometer pron
17:05:57 <lambdabot> Unknown command, try @list
17:05:58 <Peaker> its actually an undecidable problem, but it solves it
17:06:03 <dmwit> preflex: nickometer pron
17:06:03 <preflex>  pron is 94.78% lame
17:06:06 <dmwit> preflex: nickometer pronpron
17:06:06 <preflex>  pronpron is 94.78% lame
17:06:08 <vixey> flip const
17:06:10 <dmwit> ok
17:06:15 <ahunter_> @list
17:06:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:06:17 <vixey> oh wait,
17:06:17 <vixey> id
17:06:18 <Cale> preflex: warez0r
17:06:23 <Cale> preflex: nickometer warez0r
17:06:23 <preflex>  warez0r is 98.16% lame
17:06:26 <dmwit> preflex: nickometer r0
17:06:27 <preflex>  r0 is 22% lame
17:06:30 <elliottt> preflex: nickometer flip-compose
17:06:30 <preflex>  flip-compose is 14% lame
17:06:30 <dmwit> preflex: nickometer r0r0
17:06:30 <preflex>  r0r0 is 83% lame
17:06:36 <dmwit> huh
17:06:48 <Cale> preflex: nickometer r0x
17:06:48 <preflex>  r0x is 31% lame
17:06:55 <Cale> preflex: nickometer r00x
17:06:55 <preflex>  r00x is 49% lame
17:07:21 <Cale> preflex: nickometer ````````````````````````````````````````````````````````````````````
17:07:21 <preflex>  ```````````````````````````````````````````````````````````````````` is 99.99658332% lame
17:07:38 <dmwit> preflex: nickometer [[[[[[]]]]]]
17:07:38 <preflex>  [[[[[[]]]]]] is 99.987575% lame
17:07:48 <mar77a> preflex: nickometer ¿
17:07:48 <preflex>  ¿ is 38% lame
17:07:55 <mar77a> preflex: nickometer
17:07:55 <preflex>   is 0% lame
17:07:58 <mar77a> :D
17:08:13 <vixey> [~] % perl nickometer.pl -e 'print nickometer("hello");'
17:08:14 <vixey> [~] %
17:08:15 <lament> yeah, you can't get to 100% since that corresponds to score = infinity
17:08:16 <vixey> :(
17:08:17 <Cale> preflex: nickometer ````````````````````````````````````X
17:08:17 <preflex>  ````````````````````````````````````X is 99.99628788% lame
17:08:23 <lament> and score cannot be infinity :)
17:08:35 <Cale> lament: I wonder...
17:08:54 <Cale> If it's a float, it could be, if it overflowed.
17:09:07 <solrize> :t ap
17:09:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:09:10 <mauke> vixey: nickometer.pl doesn't do anything with command line args
17:09:14 <solrize> :t liftM
17:09:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:09:35 <lament> Cale: that might need a _really_ long nick
17:09:43 <Cale> lament: That's true.
17:09:46 <sclv> {uglynick} is NaN lame
17:09:55 <solrize> :t (<*>)
17:09:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:10:03 <lament> (my god perl is ugly)
17:10:32 <solrize> @hoogle (Monad m) => (a->b) -> (m a) -> (m b)
17:10:32 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
17:10:32 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
17:10:32 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
17:13:23 <roconnor> ``the functions unit and bind together form a standard construction called a monad''
17:13:32 <roconnor> I still get a kick out of that.
17:13:33 <mauke> preflex: nickometer
17:13:33 <preflex>  mauke is 0% lame
17:13:53 <mauke> lament: ITYM "nickometer.pl is ugly"
17:14:00 <Cale> roconnor: out of what? The fact that unit and bind form a monad?
17:14:01 <proq> preflex: nickometer b4sh
17:14:01 <preflex>  b4sh is 22% lame
17:14:16 <roconnor> Cale: that "standard construction" is another name for monad.
17:14:26 <lament> mauke: the most obvious ugly things are sigils and missing function arguments. I think that's common to all perl
17:14:29 <Cale> ah, right
17:14:46 <mauke> nah, sigils aren't ugly
17:15:06 <roconnor> It's a very very subtle joke.
17:15:11 <Peaker> the inconsistently used die exception model too
17:15:15 <koninkje> roconnor: or unit and join, if you're a theorist. Though the notation is less helpful for programmers
17:15:59 <lament> mauke: well, i'm extremely unused to looking at perl code, i'm sure i could get used to them, but they seem like so much extraneous noise and make stuff harder to read.
17:16:02 <roconnor> koninkje: usually I define it with unit, join (and map), but in this paper I defined it with unit and bind.
17:16:11 <roconnor> because it is quicker.
17:16:22 <mauke> lament: they also provide information on what kind of thing you're looking at
17:16:39 <lament> mauke: yes.
17:16:49 <lament> they do something.
17:16:55 <mauke> hmm. sort of like capitalizing nouns in german
17:16:59 <lament> yes.
17:17:03 <koninkje> mauke: though some of that is going by the wayside in Perl6, alas
17:17:17 <lament> i'm not a fan of capitalizing nouns, either :)
17:17:26 <EvilTerran> I pretty much lost interest in perl6 when i came across haskell and its ilk
17:17:39 <Peaker> I read that in just a couple of years there'll be more Python code on the net than Perl code
17:17:48 <roconnor> EvilTerran: did perl 6 lead you to Haskell?
17:17:54 <EvilTerran> actually, no
17:17:57 <Cale> The problem with sigils is that there are only so many usable ones, and there are infinitely many possible types of things you might want sigils for.
17:17:58 * dons imported 70 haskell packages into arch today
17:18:01 <mauke> "only Haskell can parse Perl 6"
17:18:04 <dons> 500 to go.
17:18:17 <Cale> mauke: ahaha!
17:18:23 <EvilTerran> i led myself to perl5, and comlab.ox.ac.uk led me to haskell a few years later
17:18:30 <lament> Cale: as far as i can tell, the main problem with sigils is that i don't want to see them.
17:18:33 <lament> Cale: "TMI"
17:18:46 <EvilTerran> let the typechecker work 'em out :P
17:19:15 <lament> at least, in Python or Haskell i somehow don't miss sigils at all (maybe i just don't know what i'm missing? heh)
17:19:17 <mauke> it's enough for basic qualification: $ for single things, @ for multiple things (arrays)
17:19:39 <lament> mauke: haskell doesn't have that distinction. Did that ever bother you?
17:19:43 <mauke> no
17:19:51 <mauke> haskell has a completely different data model
17:19:54 <lament> seems like simply bad design, then
17:19:56 <dons> let's reimplement all the haskell types as symbols
17:20:08 <lament> dons: xmonad is well on its way :)
17:20:09 <dons> and bring up the convention that all variables be annotated with their type
17:20:11 <mauke> lament: I don't think it's bad, just different
17:20:25 <vixey> it's a different language
17:20:28 <paczesiowa> does anyone have some useful information on working with infinite types (with newtype trick)?
17:20:42 <Cale> newtype Rec a = In { out :: Rec a -> a }
17:20:42 <Cale> y :: (a -> a) -> a
17:20:42 <dons>   let (x::(:$:) = 7  in (x::(:$:)) + (x::(:$:))
17:20:44 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
17:20:57 <dons> postfix sigils for dumb interpreters!
17:21:06 <mauke> newtype SHI = O SHI
17:21:09 <roconnor> paczesiowa: GHC's inliner doesn't play well with them.
17:21:14 <dons> type inference is hard, let's go shopping for annotations!
17:21:16 <pjdelport> http://www.python.org/dev/peps/pep-3117/ -- on the topic of sigils
17:21:17 <lambdabot> Title: PEP 3117 -- Postfix type declarations
17:21:23 <koninkje> lament: the nicest thing about sigils is that they separate the namespace of values from the namespace of functions and keywords. In haskell such a distinction is a little[1] silly, but in imperative languages it's a godsend
17:21:43 <Cale> That distinction is silly in any language.
17:21:44 <koninkje> [1] Though it would be nice if locally bound variables were made distinct from gobally bound variables...
17:21:51 <paczesiowa> roconnor: so no optimisations? I can live with that
17:21:56 <vixey> Cale, it's a very nice distinction in Common Lisp
17:21:58 <dons> there's no reason for imperative languages not to have first class functions though
17:21:59 <koninkje> Cale: you haven't done much C have you?
17:22:00 <Cale> Well, at least the distinction between functions and other values.
17:22:09 <dons> even perl brings in &foo()
17:22:10 <Cale> vixey: I absolutely *hated* it in common lisp.
17:22:28 <roconnor> paczesiowa: you can also use NOINLINE pragmas, but turning off optimizations is the simplest way to deal with it.
17:22:32 <Cale> (I prefer scheme's way of doing things there)
17:22:39 <lament> koninkje: It's not a very useful distinction in a language with first-class functions
17:22:42 <Peaker> lisp-2 is definitely annoying and introduces stupid complexity.  The reason? They want to call their variables "list"
17:22:45 <vixey> yeah scheme is good too, I use both
17:22:45 <paczesiowa> Cale: no blog/mailinglist post about using/understanding it?
17:22:55 <Cale> koninkje: I have, I just think that C is missing some features.
17:22:57 <lament> although some people swear by lisp-2
17:22:59 <vixey> Peaker: not really
17:23:00 <Cale> paczesiowa: hmm...
17:23:17 <vixey> Peaker: think about implementing a hygienic macro system and why CL doesn't need one
17:23:24 <mauke> for some reason I find perl's way of doing things a lot more pleasant than common lisp, even though it's essentially the same thing
17:23:33 <mauke> re: function namespace
17:23:34 <koninkje> lament: exactly what I noted about it being silly in haskell. In python, perl, or smalltalk where you have to be explicit about applying them there's still a distinction
17:23:36 <Cale> paczesiowa: Well, the idea is basically to name the infinite type with a newtype.
17:23:43 <Cale> paczesiowa: Then it can refer to itself.
17:23:52 <lament> koninkje: but no sigils :)
17:24:03 <Peaker> vixey, it doesn't need one? why doesn't CL need one?
17:24:27 <Peaker> vixey, macros in CL can definitely wreck havoc on the surrounding namespaces/etc
17:24:43 <lament> koninkje: the brackets in f(x) are better than sigils because, for one, it's an extremely popular notation widely used everywhere
17:24:43 <Cale> I think there shouldn't be a distinction between the kind of function you can apply and the kind of function which is a value.
17:24:55 <pjdelport> Peaker: some people say that the namespace segregation removes the need for lexical hygiene
17:25:15 <Peaker> pjdelport, I am not sure I see why those 2 things are at all related
17:25:21 <paczesiowa> Cale: are they useful, or is every infinite type destined to doom?
17:25:30 <pjdelport> Peaker: i don't say it :)
17:25:43 <Cale> paczesiowa: Well, I usefully applied an infinite type there, in order to write the Y combinator.
17:25:57 <Cale> paczesiowa: But usually they indicate type errors.
17:26:22 <roconnor> paczesiowa: they are not destined to doom, but I'm not aware of any serious use for them.
17:26:24 <EvilTerran> paczesiowa, there are reasons to want to use an infinite type, but, if you don't know if you want to use one, you probably don't
17:26:24 <Cale> If the type system allowed infinite types, there are a *lot* of bugs which it couldn't catch.
17:26:25 <paczesiowa> Cale: are there things that cannot be solved without them?
17:26:44 <EvilTerran> haskell is turing complete .'. no :P
17:26:57 <roconnor> EvilTerran: sadly it is
17:26:59 <Cale> I suppose it depends on what you mean...
17:27:12 <paczesiowa> haskell is, haskell's type system not so much
17:27:19 <vixey> It's fine that haskell is universal
17:28:16 <koninkje> lament: ultimately, the point is that there's a distinction between s-expressions and m-expressions. Even haskell has this which is why we must spell the plus function "(+)" when it's used as data, we can't just write "+" like we do when we use it as a computation. Non-symbolic names can escape this, but haskell is not free of warts
17:28:17 <roconnor> if we didn't have bottom, we'd have fewer arguments about whether optimisations should preserve it.
17:28:50 <EvilTerran> > (+) 1 2 -- look, ma, (+) is a computation
17:28:51 <lambdabot>  3
17:28:58 <lament> koninkje: actually (+) is the name of the function :)
17:29:06 <lament> koninkje: it's not really a wart
17:29:07 <EvilTerran> the "(+)" vs "+" distinction isn't really relevant
17:29:09 <lament> yeah
17:29:14 <ziman> it's just syntax
17:29:16 <lament> that's functions vs. infix operators
17:29:17 <Cale> roconnor: If we didn't have bottom, we also wouldn't be able to write many programs.
17:29:37 <roconnor> Cale: you know that isn't true in practice.
17:29:48 <Cale> roconnor: Oh?
17:29:51 <pjdelport> codata!
17:29:59 <EvilTerran> Cale, as a proportion of the space of all programs, yes. but what about as a proportion of the space of *useful* programs?
17:29:59 <roconnor> Coq, Agda, etc.
17:30:13 <lament> koninkje: but sure, there's a distinction, and it must be made somehow - the specific details of how the distinction is made are what separates good design from bad design
17:30:19 <dolio> I think he means there are many programs one couldn't write, not that most programs would be off limits.
17:30:47 <EvilTerran> well, you couldn't produce a program to print the first odd perfect number
17:30:48 <Cale> dolio: right.
17:31:02 <roconnor> EvilTerran: you might be able to.
17:31:03 <EvilTerran> or, if you could, maths would like to hear from you :P
17:31:33 <znutar> print " the first odd perfect number"
17:31:43 <vixey> It's just nice to be able to be so so expressive with types
17:31:44 <EvilTerran> in Coq, at least, I believe doing so would require a proof that such a thing existed
17:31:49 <pjdelport> EvilTerran: you could write a program to search for it, with the assurance that it won't get stuck in an infinite loop
17:31:50 <vixey> things like (!) :: Vector a n -> Fin n -> a
17:31:57 <roconnor> EvilTerran: you could write a program to find the first perfect number less than 2^2^2^2^2^2^2^2^2^2^2^2.
17:32:07 <EvilTerran> roconnor, eh, true
17:32:08 <roconnor> if it exists.
17:32:26 <vixey> EvilTerran: it wouldn't require a proof so much as -be- a proof
17:32:59 <pjdelport> EvilTerran: such a program would be an infinite corecursion
17:33:05 <dolio> The question is, how many of those 'many programs' are useful.
17:33:20 <EvilTerran> pjdelport, doesn't a co-recursion require a proof that it produces more data eventually?
17:33:40 <bd_> dolio: and how many of the 'useful programs' would need to be written unnaturally
17:33:46 <roconnor> EvilTerran: one can use the non-termination monad.
17:33:55 <dolio> Besides the canonical 'interpreter for that language.'
17:34:11 <EvilTerran> roconnor, ah! cunning.
17:34:13 <roconnor> codata NT a := WaitForIt (NT a) | HereYouGo a
17:34:28 <roconnor> EvilTerran: not my idea unfortunately.
17:34:31 <paczesiowa> I want to write a function foo, which takes x and depending on type of x returns 42 or foo itself, looks like it needs infinite types
17:34:36 <EvilTerran> funny. i'd been thinking about such a thing myself a while ago
17:34:51 <EvilTerran> paczesiowa, heavens no, that doesn't need infinite types
17:34:56 <EvilTerran> it'll need a typeclass
17:35:02 <vixey> oh there's a very nice example of that Monad in use http://www.dcs.st-and.ac.uk/~eb/partial.php
17:35:03 <EvilTerran> potentially overlapping instances
17:37:17 <lambdabot> Title: SK Combinator Calculus Interpreter
17:37:17 <pjdelport> EvilTerran: well, you would have a proof that it always keeps on making progress searching the integers space
17:37:17 <bd_> paczesiowa: hmm, doesn't printf do that?
17:37:17 <vixey> (if anyone knows of more examples.. I'd like to know, seems there aren't many.)
17:37:17 <pjdelport> you don't need a proof of terminatation (i.e., existence of what's being searched for)
17:37:17 <paczesiowa> I think I oversimplified my real problem:/
17:37:17 <EvilTerran> pjdelport, using something like that non-termination monad, i could see how that could work
17:37:17 <pjdelport> EvilTerran: well, the monad is just sugar
17:37:17 <EvilTerran> but i mean always producing an "i'm still looking" message in finite time
17:37:18 <pjdelport> the formalized codata and corecursion is the important bit
17:37:21 <koninkje> paczesiowa: How do you resolve the type difference between 42 and foo?
17:37:22 <pjdelport> (as i understand it.  disclaimer: i'm a noob. :)
17:37:53 * roconnor grumbles about Coinduction and subject reduction in Coq
17:37:55 <EvilTerran> paczesiowa, class Num a => Foo a where foo :: a -> a; instance Foo Int where foo _ = 42; instance Foo Float where foo x = x
17:38:00 * roconnor grumbles
17:38:01 <dolio> The problem with the [artiality monad is getting stuff out of it.
17:38:08 <dolio> Partiality, even.
17:38:16 <bd_> class Foo t where foo :: t; instance Foo (SomeType -> Int) where foo = const 42; instance Foo t => Foo (SomeOtherType -> t) where foo = const foo
17:38:20 <EvilTerran> dolio, indeed, seeing as its result is codata
17:38:22 <bd_> @ paczesiowa
17:38:26 <roconnor> dolio: the IO monad enjoys similar difficulties
17:38:27 <bd_> ( I think )
17:38:30 * vixey suggests roconnor implement a dependently typed language :p
17:38:42 <dolio> Even when you write your search in it, you can only ask things like "does it find the answer in n steps?"
17:38:44 <paczesiowa> koninkje: in my real problem there is plenty of typeclass magic (half of HList)
17:38:48 <roconnor> vixey: it looks about 10x harder than I thought.
17:38:59 <vixey> roconnor: yes!
17:39:06 <dolio> Unless you make it a primitive in the language, like IO (in which case, your language is Turing complete).
17:39:11 <vixey> roconnor: It's really hard :)
17:39:11 <EvilTerran> bd_, that's gloriously dubious. i like.
17:39:13 <roconnor> and it was supposed to be simple. :P
17:39:25 <dolio> Although, Turing complete in a way that's more structured than most languages.
17:39:29 <bd_> EvilTerran: untested, naturally :)
17:39:42 <bd_> EvilTerran: might need a fundep, actually
17:39:43 <EvilTerran> ooh, my favourite :D
17:39:51 <roconnor> dolio: I don't think I'd say that adding IO makes your language Turing complete anymore than adding IO makes your langauge impure.
17:39:55 <EvilTerran> you don't need a fundep, there's only one class parameter
17:39:57 <bd_> instance Foo a r | a -> r where foo :: a -> r; [...]
17:40:03 <vixey> You can easily express turing complete computations and other such things anyway
17:40:08 <bd_> EvilTerran: I mean, make it use a fundep to resolve the ambiguity
17:40:14 <vixey> you define things as data, not functions
17:40:24 <EvilTerran> as you wrote it, those instances wouldn't overlap, AFAICT
17:40:49 * bd_ tests
17:41:00 <EvilTerran> because SomeType and SomeOtherType are disjoint, so are the (->) types
17:41:08 <dolio> roconnor: Well, if you can write a program that executes an arbitrary partial computation, doesn't that count as Turing complete?
17:41:24 <EvilTerran> dolio, that would, yes (i think)
17:41:51 <dolio> roconnor: It would likely help with the problems Turing completeness causes with dependent types, though.
17:42:03 <roconnor> dolio: techinically you can only write a program that writes a program that executes an arbitrary partial computations.  And this is okay becuase you can't actually exectute the program that your program writes.
17:42:12 <bd_> EvilTerran: Well, it works, but you have to specify things like foo (1 :: Int) :: Int to match a Int -> Int
17:42:39 <bd_> though I guess that's somewhat unavoidable, possibly
17:42:52 <dolio> roconnor: Yeah, but that's like saying Haskell can't do IO. In practical terms, it can.
17:43:51 <roconnor> dolio: we are into to murky semantic waters here.
17:44:47 <roconnor> dolio: Haskell can't to IO in the sense that there is no function IO a -> a .... you know what I mean.
17:46:08 <dolio> Yeah.
17:46:56 <roconnor> so adding IO to a system like Agda would make it "practically" Turing complete, but I'd say theoreticially speaking it wouldn't be Turing complete.
17:47:13 <vixey> what do you mean to add IO to Agda?
17:47:27 <vixey> by the way there is a dependent typed language with IO
17:47:32 <vixey> Idris
17:47:37 <roconnor> probably by adding an abstract data type to Agda
17:47:41 <dolio> I imagine Cayenne can do IO, too.
17:48:01 * mmorrow starts taking notes
17:48:19 <roconnor> or by having IO () represent Assembly, if you want take a more insane route.
17:48:32 * mmorrow becomes gidddy
17:48:57 <dolio> I seem to recall seeing papers on a provably terminating IO for dependently typed languages.
17:49:14 <dolio> And coIO for productive, non-terminating IO programs.
17:49:43 <roconnor> well if IO () represents assembly it isn't even a function
17:49:48 <roconnor> it is essentially a string
17:49:50 <vixey> why not use IO as a GADT
17:50:16 <mmorrow> roconnor: eval??
17:50:55 <roconnor> eval?
17:51:16 <Staz> "E[E1(E2)] r k = E[E1]r;Fun?\f.E[E2] r; f; k"    <--- I have read over this many times but have not understood it. It involves continuations/environments etc.
17:51:18 <roconnor> actually my Assembly idea probably doesn't work.
17:51:21 <mmorrow> i've been playing with template haskell and hs-plugins's eval function lately. it's perspective-changing.
17:51:40 <Staz> I know it is semantic algebra for calling a function.
17:52:46 <Staz> from what I can gather, r = environment, k = expression continuation.
17:53:45 <dolio> That's some cryptic notation.
17:53:47 <mmorrow> hmm, i'm unfamiliar with the notation so am
17:53:50 <mmorrow> heh, yeah
17:53:55 <mmorrow> (having trouble)
17:54:44 <dolio> I think it says...
17:55:04 <mauke> eval[E1(E2)] env k = eval[E1] env $ \f -> eval[E2] env $ k . f
17:55:07 <dolio> To execute E1(E2) in a context E with environment r and continuation k...
17:55:46 <Staz> dolio : understood so far :)
17:55:47 <dolio> Evaluate E1 in the context, and bind the result to f (if it's a function), and then evaluat E2 in that context, and apply f to the result, and then apply k to the result of that.
17:56:22 <mauke> oh, like a stack
17:56:32 <dolio> Oh, yeah, I guess E[-] = eval makes more sense.
17:56:56 <koninkje> @hoogle mkStableName
17:56:57 <lambdabot> No matches found
17:57:30 <Staz> dolio : You have really helped out! thank you
17:57:39 <Staz> I will read your comments over and over
17:57:51 <dolio> Heh.
17:58:27 <Staz> What meaning do the semi colons have in semantic algebra?
17:58:37 <dolio> Looks like application.
17:58:49 <dolio> x ; f means f applied to x.
17:58:51 <Staz> I mean hoe do you know that the 'Fun?' bit applies to the result of evaluating the expressin?
17:58:52 <mauke> it seems to separate instructions
17:59:01 <Staz> ahh!
17:59:03 <mauke> push 1; push 2; add
17:59:10 <Staz> That makes far more sense.
17:59:22 <Staz> I really wish the lecturer had explained that :)
17:59:44 <Staz> I don't think anyone in my class knew what half of the symbols meant.
17:59:51 <mmorrow> i hate non-rigorously-defined/and/or/explained notations
18:00:02 <mauke> on that note, ℘ℰℛℒ
18:00:06 <mmorrow> heh
18:03:00 <mmorrow> mauke: (nice use of (non)capitalization)
18:14:05 <Staz> dolio : In that expression, what scope does the lamda have?
18:14:14 <vixey> I guess something like ML modules/functors would work for interacting between verified and unverified code
18:14:14 <vixey> a
18:15:24 <dolio> Staz: At a guess, I'd say it extend all the way to the end.
18:15:36 <electronx> i'm wandering what would the advantages be of making a website in haskell??
18:16:03 <Staz> dolio : thanks again
18:16:07 <Staz> it is all very cryptic!
18:19:47 <dolio> Staz: It's certainly not the usual CPS transform notation you typically see.
18:19:52 <mar77a> can anyone think of a way to optimize the following: takeWhile ((<=1000) . length . show) [fib x | x <- [1..]]
18:20:08 <mar77a> fib is: fib 0 = 0; fib 1 = 1; fib n = fib(n-1) + fib(n-2);
18:20:23 <mar77a> in case you haven't noticed, it's for problem 25 of projecteuler :p
18:20:28 <dolio> Write a more efficient fib?
18:20:32 <dibblego> do you understand why that will perform poorly (the fib function)?
18:20:32 <vixey> mar77a: Did you see the memo stuff?
18:20:39 <dibblego> vixey, what memo stuff?
18:20:43 <vixey> i.e. change it to
18:20:49 <vixey> fib 0 = 0; fib 1 = 1; fib n = fib' (n-1) + fib' (n-2);
18:20:57 <vixey> fib' n = fibs!!n
18:21:03 <vixey> fibs = map fib [0..]
18:21:20 <mar77a> why is it slow?
18:21:41 <vixey> recursion recomputes everything
18:21:50 <dolio> That algorithm takes O(fib(n)) function calls.
18:22:04 <dibblego> because computing fib (n - 1) requires computing fib(n - 2) and so on, then it is all computed again
18:22:18 <mar77a> i need a way to store them fibs
18:22:35 <vixey> mar77a: I showed you one way, do you know how it works?
18:22:43 <dibblego> > let fibs = zipWith (+) fibs (tail fibs) in fibs
18:22:57 <dibblego> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
18:22:58 <lambdabot>  thread killed
18:22:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:23:42 <mar77a> why is this
18:23:45 <mar77a> SO much faster
18:23:53 <vixey> which?
18:24:08 <dibblego> because it doesn't compute the same thing more than once
18:24:10 <mar77a> yours
18:24:26 <vixey> fibs = map fib [0..] -- this bit is crucial
18:24:37 <vixey> say you compute fib 2
18:24:50 <vixey> that actually does fib' (2-1) + fib' (2-2)
18:24:56 <vixey> so fib' n = fibs!!n
18:25:00 <mar77a> ah
18:25:01 <vixey> that tugs in fibs a couple times
18:25:05 <vixey> & now,
18:25:12 <vixey> fibs = 0 : 1 : map fib [2..]
18:25:29 <vixey> next time you call fib 2, fibs doesn't have to recompute anything
18:25:42 <vixey> so it's like a lookup table that extends by need
18:26:41 <vixey> whereas, with direct recursion...
18:26:46 <dolio> > fix ((0:) . scanl (+) 1)
18:26:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:26:53 <vixey> > reh fib 0 = 0; fib 1 = 1; fib n = fib(n-1) + fib(n-2) it fib 4 :: Expr
18:26:54 <lambdabot>  Parse error at "=" (column 11)
18:26:57 <vixey> > let fib 0 = 0; fib 1 = 1; fib n = fib(n-1) + fib(n-2) it fib 4 :: Expr
18:26:57 <lambdabot>  Parse error at end of input
18:27:05 <vixey> tsk
18:27:07 <vixey> > let fib 0 = 0; fib 1 = 1; fib n = fib(n-1) + fib(n-2) in fib 4 :: Expr
18:27:09 <lambdabot>  1 + 0 + 1 + (1 + 0)
18:27:37 <mar77a> it's ok i got it
18:27:45 <vixey> > let fib 0 = 0; fib 1 = 1; fib n = fib'(n-1) + fib'(n-2); fib' n = fibs!!n; fibs = map fib [0..] in fib 4 :: Expr
18:27:46 <lambdabot>  1 + 0 + 1 + (1 + 0)
18:27:55 <vixey> damn :p
18:27:58 <vixey> > let fib 0 = 0; fib 1 = 1; fib n = fib'(n-1) + fib'(n-2); fib' n = fibs!!n; fibs = map fib [0..] in fib 6 :: Expr
18:27:59 <lambdabot>  1 + 0 + 1 + (1 + 0) + (1 + 0 + 1) + (1 + 0 + 1 + (1 + 0))
18:28:11 <vixey> I was hoping it would do something else
18:28:26 <vixey> I guess expr actually stores them that way, it makes sense
18:31:30 <koninkje> vixey: what were you hoping for?
18:31:58 <vixey> something with bigger numbers than 1 and 0 in it, thinking about it now though of course that wouldn't happen
18:33:39 <koninkje> mar77a: one of the problems with this particular approach to memoization is that the list of fibs will be held onto forever. There are some additional tricks to get a fib :: Integer -> Integer function to discard the table after the main call to it is done (and also improvements to make it only hold two previous results at a time instead of all of them)
18:33:59 <koninkje> vixey: ah the joys of packed forests :)
18:34:30 <vixey> koninkje: we did a few tests
18:34:50 <vixey> http://hpaste.org/8023
18:34:51 <koninkje> vixey: tests on?
18:35:06 <vixey> memoizing fibs
18:35:31 <vixey> fib1 shows how to get the memo table erased after each call
18:38:17 <koninkje> I was raising the point more for pedogogical purposes (where "this particular approach" == fib2)
18:39:21 <koninkje> (or the more canonical fibs = 0 : 1 : [i+j| (i,j) <- zip fibs (tail fibs)] version)
18:41:05 <roconnor> http://www.tachyos.org/godel/godel_summary.html
18:41:06 <lambdabot> Title: G&ouml;del's incompleteness theorem - project summary
18:41:14 <roconnor> ``What made things a lot simpler was realising how suitable the programming language Haskell was for the task.
18:41:43 <dons> nice
18:42:19 <koninkje> vixey: that version does still hold onto the whole list during computation, rather than just the last two cells of it
18:42:33 <koninkje> (where "that version" == fib1)
18:46:54 * koninkje wishes ghci had hugs' :set +g
18:49:02 <mmorrow> did someone mention fib?
18:49:08 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/fib.html
18:49:49 <koninkje> that's cheating ;)
18:49:55 <mmorrow> hehe
18:50:11 <vixey> nice :)
18:50:23 <mmorrow> harpy is *so* sweet
18:50:27 <vixey> hmmmmm
18:50:31 <vixey> you can do JIT?
18:50:38 <koninkje> though we could get the same thing with a strict tail-calling version of the memoizer
18:50:39 <mmorrow> oh yesh!
18:50:49 <mmorrow> @vixey
18:50:49 <lambdabot> hahaha.
18:50:52 <Adamant> lol, cheat much?
18:51:08 <Adamant> that is awesome though
18:51:08 <mmorrow> never....ok lots
18:51:14 <dolio> Template Haskell *and* assembly code generation?
18:51:26 <mmorrow> yes! that is what i'm thinking
18:51:27 <dolio> You, sir, are too bold.
18:51:31 <mmorrow> haha
18:52:16 <vixey> this is great
18:52:33 <koninkje> mmorrow++ for being too bold
18:52:43 <mmorrow> :)
18:55:05 <vixey> I want to use this
18:55:38 <mmorrow> they have two pdf  tutorials on the harpy website, those'llget you going nicely
18:56:40 <vixey> I don't know what to do yet though
18:57:43 <mmorrow> look at the second tutorial. it's a lambda calc compiler. omg.
18:57:45 * nus wnats runtime code degenerator
18:58:25 <mmorrow> so, with tutorial two, just add parsing and a nice readline/editline prompt and...
18:58:39 <mmorrow> runtime codegen lambda-calc interp
19:01:03 <mmorrow> dolio: i also extended mauke's hell.hs: http://code.haskell.org/~morrow/code/haskell/misc/Call.html
19:01:49 <mmorrow> you can just jump to a [Word8]!!
19:02:04 <mmorrow> (actually call it)
19:02:11 <dolio> Hah.
19:02:38 <mmorrow> heh, those ioccc were inspiring
19:03:09 <newsham> shell code in haskell
19:03:36 <mmorrow> l333th4x0ring
19:03:57 <dolio> We'll be segfaulting at a professional level in no time.
19:04:02 <mmorrow> preflex: nickometer l333th4x0ring
19:04:02 <preflex>  l333th4x0ring is 99.915708% lame
19:04:10 <mmorrow> dolio: oh yeah!
19:04:52 <mmorrow> haskell can segfault with the best of them!
19:06:42 <newsham> dumps to end, gets old EIP into ECX, and calls write(1,"Hello world!\n", 14)
19:06:48 <newsham> s/dumps/jumps/
19:07:04 <mmorrow> harpy has a nice disassembler as well
19:07:17 <newsham> err, I forgot a "," in there.
19:07:24 <mmorrow> even has disassembleList :: [Word8] -> [Instruction]
19:07:42 <newsham> does maukehell.hs work on codepad?  (is it x86?)
19:07:49 <mmorrow> i love how it returns 0
19:07:53 <mmorrow> xor eax, eax
19:08:12 <mmorrow> newsham yeah, x86
19:08:23 <newsham> codepad is?
19:08:40 <mmorrow> we'll find out!
19:09:03 <newsham> codepad didnt like Language.haskell.TH.Lib
19:09:31 <mmorrow> i only use it for nonimportant parts, so just zap it
19:09:42 <mmorrow> (and delete mkCall, mkCallQ)
19:11:10 <newsham> it has other problems with it
19:11:23 <mmorrow> fixable, i'll try...
19:11:37 <newsham> codepad is a hoot http://codepad.org/8rTeKtvg
19:11:52 <nolrai_> @src (->) bind
19:11:52 <lambdabot> Source not found. My brain just exploded
19:12:27 <newsham> ?src (->) (>>=)
19:12:27 <lambdabot> f >>= k = \ r -> k (f r) r
19:14:18 <nolrai_> newsham: thanks was having brain fart.
19:15:37 <newsham> morrow needs to select haskell not C
19:16:15 <mmorrow> newsham: crap, i think it's trying to run it through cpp and it's dieing with Line 1: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'Foreign'
19:16:20 <mmorrow> oh well
19:16:34 <newsham> you need to change the drop down box that select language from C to haskell
19:16:38 <newsham> otherwise it tries to gcc it :)
19:17:34 <mmorrow> oh, ha
19:17:36 <newsham> (note: codepad.org, not haskellpad.org)
19:17:46 <sclv> haha wow. we need to get some Harpy generated bytecode onto the shootout. really get those "you're cheating" guys up in arms!
19:17:58 <electronx> woot haskell can seg fault thats new to me
19:18:35 <newsham> if you cant segfault it, its not a sufficiently powerful system
19:18:45 <electronx> rofl
19:19:07 <mmorrow> haha
19:19:10 <mmorrow> Error occurred
19:19:10 <mmorrow> ERROR "t.hs" - Error while importing DLL "./t.so":
19:19:10 <mmorrow> ./t.so: cannot open shared object file: No such file or directory
19:19:13 <electronx> so plain haskell code can segfault how the hell does that happen
19:19:36 <mmorrow> readInt32Off nullPtr 1
19:19:40 <mmorrow> seqfault
19:19:50 <mmorrow> easy!
19:19:53 <gubagem> using something unsecure?
19:19:57 <nolrai_> :t Data.Map.insertWith
19:19:59 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
19:20:04 <gubagem> wait we have nullPtr ?
19:20:30 <mmorrow> yeah (name is something like that
19:20:45 <mmorrow> readInt32Off (castPtr 0 :: Ptr Int32) 1
19:20:47 <mmorrow> there
19:20:49 <gubagem> what do i have to import to get the nullPtr
19:20:50 <mmorrow> seqfault
19:20:57 <newsham> if you couldnt represent a null pointer how powerful could it be?
19:21:33 <mmorrow> nullPtr :: forall a. Ptr a      -- Defined in GHC.Ptr
19:21:40 <gubagem> what module do i need to load to get that code to work
19:21:41 <gubagem> ok thx
19:21:43 <mmorrow> nullFunPtr :: forall a. FunPtr a        -- Defined in GHC.Ptr
19:21:59 <mmorrow> also :m + GHC.Storable
19:22:20 <pjdelport> Haskell: pure by day, party animal by night
19:22:24 <mmorrow> ghci> readInt32OffPtr nullPtr 1
19:22:24 <mmorrow> Segmentation fault
19:23:18 <newsham> Foreign.Ptr.nullPtr
19:23:25 <mmorrow> yeah
19:23:46 <nolrai_> > let a = Data.Map.insertWith (error "msg1") "konichi wa" "hellow" Data.Map.empty in Data.Map.insertWith (error "msg1") "konichi wa" "guten tag" a
19:23:47 <lambdabot>   Not in scope: `Data.Map.insertWith'
19:24:01 <mmorrow> oh i had that problem.
19:24:02 <gubagem> @hoogle readInt32OffPtr
19:24:02 <lambdabot> No matches found
19:24:06 <mmorrow> :t M.insertWith
19:24:07 <gubagem> :-/
19:24:07 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
19:24:22 <mmorrow> gugabem: it's in GHC.Storable
19:24:27 <electronx> this is interesting does this mean that you can write an exe protector in haskell?
19:24:39 <mmorrow> you can do anything in haskell!
19:24:51 <mmorrow> (yes)
19:25:02 <nolrai_> > let a = M.insertWith (error "msg1") "konichi wa" "hellow" M.empty in M.insertWith (error "msg1") "konichi wa" "guten tag" a
19:25:03 <lambdabot>  fromList [("konichi wa","Exception: msg1
19:25:05 <electronx> i mean an exe protector is really really low level stuff
19:25:26 <mmorrow> you can go as low as you want
19:25:34 <nolrai_> wow, lazyness in action!
19:25:45 <mmorrow> or at least generate the code to do what you want
19:25:49 <gubagem> @faq can Haskell Mutate record syntax
19:25:49 <lambdabot> The answer is: Yes! Haskell can do that.
19:25:52 <gubagem> liar
19:25:57 <mmorrow> haha
19:26:02 <newsham> > peek nullPtr :: Char
19:26:02 <lambdabot>   Not in scope: `nullPtr'
19:26:05 <mmorrow> write a srccode filter
19:26:14 <mmorrow> ghc has hooks for that
19:26:17 <mmorrow> voila!
19:26:22 <mmorrow> recordsyn muation
19:26:26 <newsham> > peek Foreign.Ptr.nullPtr :: Char
19:26:26 <lambdabot>   Not in scope: `Foreign.Ptr.nullPtr'
19:26:52 <gubagem> im in a bind, I need to mutate adt's to store state for a mud, large level of fields per record, whats the correct appraoch << newbie
19:26:55 <electronx> hmm someone should write a vm in haskell
19:27:07 <electronx> that would be ausomeness to the max
19:27:22 <newsham> how about a system emulator?
19:27:25 <Axman6> VMwhere
19:27:44 <newsham> http://www.mutantlemon.com/omegagb/
19:27:46 <lambdabot> Title: OmegaGB - Game Boy Emulator
19:27:53 <electronx> yeah me can call it a vmh
19:27:57 <electronx> we*
19:28:03 <electronx> or hvm
19:28:17 <newsham> game boy system emulator written in haskell
19:28:27 <mmorrow> ooh nice link
19:28:33 * mmorrow goes to look
19:28:56 <electronx> doesn't look like its still developed
19:31:04 <electronx> still a pretty nice effort
19:31:44 <gubagem> that almost sparks my interest
19:32:00 <newsham> http://codepad.org/HsGCscVc
19:32:46 <gubagem> wait do we have a poke to go along with peek?
19:32:53 <newsham> yes.
19:32:54 <mmorrow> yes
19:32:54 <electronx> why doesn't haskell have some sort of active commercial backing apart from the microsoft devs working on ghc
19:33:08 <pjdelport> @go CUFP
19:33:09 <lambdabot> http://cufp.galois.com/
19:33:09 <lambdabot> Title: Commercial Users of Functional Programming
19:33:13 <newsham> el: like galois?
19:33:18 <nus> so 'where' expressions are slightly faster (an assumption from the vixey's http://www.hpaste.org/8023)?
19:33:31 <nus> i.e. fib1 vs fib2
19:33:38 <gwern> omegagb is abandoned, more or less
19:34:02 <gwern> (I asked the author since I ran into copmpile errors, and he is busy with school/work)
19:34:17 <electronx> school???
19:34:22 <nus> @version
19:34:22 <lambdabot> lambdabot 4p664, GHC 6.8.2 (Linux i686 2.40GHz)
19:34:22 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:34:24 <electronx> the guys in school
19:34:37 <newsham> you cant write an emulator in school?
19:34:42 <Axman6> sure
19:34:47 <nolrai_> unversity i assume?
19:34:48 <gwern> it was school or work, I can look up the specific email if you really care
19:34:55 <electronx> how did the guy find out about haskell?
19:35:03 <Axman6> i wrote othello in school, that's just as hardcore!
19:35:19 <electronx> i only found out about haskell in uni
19:35:23 <nolrai_> I found haskell the summer after highschool.
19:35:39 <newsham> this isnt going to turn into a testimonial, is it?
19:35:41 <gubagem> i found about haskell from reddit.com /programming i believe
19:35:43 <electronx> and i hated it really bad
19:35:58 <pjdelport> dons++
19:36:00 <gubagem> i looked at hugs over a year ago and it just seemed icky to me
19:36:09 <electronx> but after a few years of C++ i started to like it alot
19:36:12 <newsham> brother gwern, tell us how you came to haskell!
19:36:14 <gubagem> ghc >> hugs
19:36:14 <gwern> 'Thanks for the info and the patch. I'm busy with personal stuff these
19:36:15 <gwern> days so I'll only be able to take a look at it next month.'
19:36:37 <gubagem> and a guy on my aim buddlist recommended this channel
19:36:38 <electronx> aaah
19:36:45 <newsham> ?type ghc >> hugs
19:36:47 <lambdabot> Not in scope: `ghc'
19:36:47 <lambdabot> Not in scope: `hugs'
19:36:52 <gwern> newsham: I wuz lost in the vale of java, brother, and I saw a preacherman by the name of lisp! and I went and dwelt with him for a time
19:37:13 <gubagem> i learned from the zen master DrScheme slowly
19:37:21 <gwern> newsham: and lordy lor, I was mightily displeased, and I beseeched my soul, 'Lisp is too messy! Surely there be a better way?'
19:37:33 <electronx> anyone see a big advatage in writing a website in haskell instead of say java or ruby??
19:37:46 <gwern> newsham: and in my greatest extremity, I saw dons's posts to proggit, and I was saveduh!
19:37:52 <gubagem> scheme seemed to lack execution speed and it was missing some basic things
19:37:57 <gubagem> whats proggit
19:38:13 <vixey> electronx: why haskell over say smalltalk?
19:38:18 <newsham> programming.reddit
19:38:27 <electronx> i don't like lisp :)
19:38:28 <psygnisfive> i've had an idea: strip all IO from haskell. without IO, haskell would never need to actually compute anything, since you could never know the answer, therefore you'd never need to run any programs in practice, just assume they run, which means they run infinitely fast (mathematics has no time :D ).
19:38:29 <vixey> @protontorpedo
19:38:30 <lambdabot> how do we automate ftp file transfers with haskell?
19:38:34 <vixey> @protontorpedo
19:38:34 <lambdabot> some dude called topmind says that oo is bs
19:38:47 <newsham> ?keal
19:38:47 <lambdabot> bot seems useless
19:39:04 <psygnisfive> ostensibly, the programs run, but since there's no IO, there's no need to actually run them. :)
19:39:17 <newsham> how will you account for heat?
19:39:18 <electronx> lol
19:39:26 <monochrom> That solves the halting problem nicely.
19:39:30 <psygnisfive> heat is IO!
19:39:32 <electronx> anyone writtent a site in haskell??
19:39:33 <Axman6> psygnisfive: everyone knows IO is what slows everything down anyway
19:39:37 <electronx> written*
19:39:48 <psygnisfive> banish thermodynamics
19:39:56 <Cale> electronx: There have been some.
19:39:56 <psygnisfive> computation is reverseable anyway
19:40:05 <newsham> elect: http://darcs.haskell.org/hws/
19:40:06 <lambdabot> Title: Index of /hws
19:40:09 <electronx> Cale: how did they go?
19:40:17 <nolrai_> electronx: some one was talking about it a few weeks ago, iirc.
19:40:17 <Cale> electronx: As far as I know, fairly well.
19:40:17 <newsham> the computation is reversible, but time is not, turn back, turn back.
19:40:38 <electronx> is there a big advatage?
19:40:42 <newsham> my website runs on HWS http://www.thenewsh.com/~hws/
19:40:43 <lambdabot> Title: HWS - Haskell Web Server
19:40:48 <Cale> electronx: There is HAppS, which is an application server framework with lots of desirable properties.
19:40:48 <Axman6> is there anything like yaws in haskell? (like, something that's actually good, not just proof of concept)
19:41:37 <Cale> electronx: There's also Hope, which is a CMS.
19:41:40 <newsham> http://www.cs.nott.ac.uk/~gmh/papers/13.ps
19:41:41 <electronx> yeah i was looking at HApps
19:41:51 <electronx> but that doesn't seem to be really active
19:42:03 <Cale> electronx: HAppS is very active from what I understand.
19:42:16 <Cale> At least, if it's not active, that's recent news.
19:42:17 <newsham> ?shapr
19:42:18 * lambdabot slaps  with a slab of concrete
19:42:38 <rwbarton> my code uses a function in Data.Set whose type changed slightly between ghc 6.6.1 and 6.8.2.
19:42:38 <gwern> does ghc still go through C--, or is that just -fvia-c?
19:42:50 <rwbarton> is there some conditional compilation trick I can do to make my code compile under both?
19:42:59 * gwern wonders about http://www.reddit.com/r/programming/info/6n962/comments/c04cjcr
19:43:00 <lambdabot> Title: programming: LLVM 2.3 released
19:43:20 <Axman6> whoot
19:43:29 <dolio> C-- is the new backend.
19:43:31 <newsham> rw: both which?
19:43:32 <Axman6> llvm is awesomeness
19:43:40 <dolio> -fvia-c generates actual C.
19:43:46 <rwbarton> Both versions, ghc 6.6.1 and 6.8.2
19:43:49 <gwern> I thought it went from sTG to asm these days?
19:43:59 <newsham> ahh,  you can use the c preprocessor and #ifdef's if you must
19:44:11 <dolio> C-- is their portable assembly.
19:44:11 <nolrai_> @hoogle seq
19:44:11 <lambdabot> Prelude.seq :: a -> b -> b
19:44:11 <lambdabot> Data.Sequence.Seq :: data Seq a
19:44:11 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
19:44:39 <dolio> Of sorts, at least.
19:44:48 <nolrai_> what is C--?
19:45:14 <dolio> Apparently it allows you to do certain lower level things that even C would hide from you.
19:46:05 <newsham> barton: ghc has an option that lets you use a preprocessor
19:46:12 <newsham> and it has definitions for various versions
19:46:16 <nolrai_> where are the strictness controlers?
19:46:25 <dolio> http://www.cminusminus.org/
19:46:31 <lambdabot> Title: C-- Home
19:47:27 <gwern> good ol' -cpp, how we loathe thee
19:47:45 <newsham> i dont mind cpp, i mind people who dont know how ot use it properly
19:48:03 <nolrai_> dolio: thanks.
19:48:33 <newsham> you'd think people who deal with abstraction as a career could figure out how to abstract portability.
19:49:36 <gwern> yeah, it's a little odd how unconfigurable portability-related stuff can be, but I suppose there's no research papers to't
19:49:54 <newsham> its not really that hard to make portable software thats also readable.
19:49:58 <newsham> just that most people dont.
19:50:15 <newsham> take a look at the ghc linker sometime to see what i'm talking about :(
19:51:01 <newsham> there should be a penalty for each ifdef you use.
19:51:28 <newsham> if you have omre than 30 maybe you should think "gee, should I abstract this into a platform specific file?"
19:52:31 <newsham> </rant>
19:55:28 <gwern> one of the fun things about darcs is when you hack on darcs - 'yeah, so you'll need to get the darcs darcs, and once your darcs darcs is installed you can test it out.' 'When you darcs get darcs... er, darcs, be sure to use --lazy to speed things up'
19:56:33 * gwern finds a juvenile humor in the sound of 'darcs darcs'. sounds like a seal
19:59:20 * gubagem starts singing like a phat wallrussian
20:21:34 * vixey thanks haskell for teaching her fold
20:21:36 <vixey> (foldr)
20:22:52 <roconnor> > foldr f x
20:22:53 <lambdabot>  <[()] -> SimpleReflect.Expr>
20:22:59 <roconnor> > foldr f x [a,b,c]
20:23:01 <lambdabot>  f a (f b (f c x))
20:23:26 <Korollary> > f
20:23:27 <lambdabot>  Add a type signature
20:23:32 <Korollary> what the f is f?
20:23:37 <vixey> :t f
20:23:38 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
20:23:48 <vixey> I think it's a variadic function
20:24:24 <Staz> Can anybody link me to a good resource on continuations / environments / stores etc?
20:24:52 <dons> Staz: bob harper's book "Programming Languages : theory and practice"
20:24:59 <dons> pdfs are on the web, and linked from haskell.org's book page
20:25:22 <Staz> I'll take a look thanks!
20:25:33 <Staz> my brain is about to explode
20:25:42 <vixey> lucky
20:25:44 <vixey> :)
20:25:45 <Staz> trying to read semantic algebra.
20:25:53 <monochrom> Someone said explosion is the solution, not the problem.
20:26:17 * Axman6 steps away from WWII reference
20:26:26 <Korollary> explosion for the sake of explosion could be a problem
20:26:42 <Axman6> like fireworks?
20:26:47 <monochrom> @quote quicksilver
20:26:47 <lambdabot> quicksilver says: *quicksilver beats Deewiant with the i-will-not-use-fail-stick [Deewiant] quicksilver: I'm willing to accept a good alternative. [quicksilver] no. all you are permitted to accept
20:26:47 <lambdabot> is a beating.
20:27:08 <monochrom> @quote head-explosion
20:27:08 <lambdabot> No quotes match. My pet ferret can type better than you!
20:27:39 <roconnor> I know a good alternative.
20:27:45 <roconnor> @hoogle Alternative
20:27:45 <lambdabot> Control.Applicative.Alternative :: class Applicative f => Alternative f
20:27:49 <roconnor> ^^
20:27:58 <monochrom> http://sequence.complete.org/hwn/20080611  look for "head-explosion"
20:27:59 <lambdabot> Title: Haskell Weekly News: June 11, 2008 | The Haskell Sequence
20:29:00 <roconnor> @type zip `ap` tail
20:29:02 <lambdabot> forall b. [b] -> [(b, b)]
20:29:32 <roconnor> > zip `ap` tail [0..]
20:29:33 <lambdabot>  Couldn't match expected type `[a] -> [b]'
20:29:38 <roconnor> > zip `ap` tail $ [0..]
20:29:40 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
20:30:08 <Axman6> that hurts my brain
20:30:12 <nolrai_> :t lift
20:30:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
20:31:14 <roconnor> > f `ap` g $ x
20:31:14 <lambdabot>  Add a type signature
20:31:26 <roconnor> > f `ap` g $ x :: Expr
20:31:27 <lambdabot>  Add a type signature
20:31:40 <Axman6> @type ap
20:31:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:32:07 <roconnor> > (f :: Expr -> Expr -> Expr) `ap` g $ x
20:32:08 <nolrai_> @src ap
20:32:08 <lambdabot> ap = liftM2 id
20:32:08 <lambdabot>  f x (g x)
20:32:18 <newsham> roconnor: it wants to know which `ap` you mean
20:32:36 <newsham> (i think)
20:32:46 <nolrai_> so its the s of the ski, right?
20:32:51 <roconnor> obviously I mean the reader monad.  I'm applying the result to x
20:33:01 <roconnor> nolrai_: that is one ap
20:33:09 <roconnor> and the ap I'm using here
20:33:29 <newsham> reader monad
20:33:46 <nolrai_> what does ap do in other monads?
20:33:58 <newsham> [17:28] < lambdabot> ap = liftM2 id
20:34:28 <nolrai_> @unlet ap
20:34:28 <newsham> > pure (+) `ap` [1,2] `ap` [3,4]
20:34:28 <lambdabot>  Parse error
20:34:29 <lambdabot>  [4,5,5,6]
20:35:03 <nolrai_> > pure (+) `ap` [1,0] `ap` [1,0]
20:35:04 <lambdabot>  [2,1,1,0]
20:35:21 <newsham> > (+) <$> [1,2] <*> [100,200]
20:35:22 <lambdabot>  [101,201,102,202]
20:35:39 <newsham> the <$> does "pure f <*>"  the <*> is ap
20:35:48 <nolrai_> hmm
20:36:00 <newsham> > (+) <$> Just 3 <*> Just 5
20:36:01 <lambdabot>  Just 8
20:36:23 <newsham> > getZipList $ (+) <$> ZipList [1,2] <*> ZipList [10,20]
20:36:24 <lambdabot>  [11,22]
20:36:42 <nolrai_> cool
20:36:58 <Axman6> you're all breaking my brain now
20:37:10 <newsham> conal has a cool paper on all this
20:37:22 <newsham> which will break your brain the first 2 times you read it
20:37:52 <newsham> err, Conor.
20:37:54 <newsham> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
20:37:54 <lambdabot> Title: Applicative Programming with Effects
20:38:56 <newsham> ?type ap
20:38:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:39:39 <newsham> so ie:  "pure (+)" or "return (+)" makes a (Maybe (a->a->a))
20:40:01 <newsham> `ap` that to Just 3   gives a  (Maybe (a->a))
20:40:09 <newsham> and `ap` that to a Just 8 gives a (Maybe a)
20:42:01 <roconnor> oh god
20:42:16 <roconnor> this guys seems to be compiling haskell to FOL
20:42:28 <vixey> neet!
20:42:37 <roconnor> well
20:42:41 <roconnor> a small subset of Haskell
20:42:44 <SamB_XP_> FOL?
20:42:49 <newsham> first order logic
20:42:52 <SamB_XP_> that sounds so boring
20:42:57 <roconnor> if, case and let are the only statements which can be used. where is not implemented, and neither are do or monadic programming.
20:42:57 <SamB_XP_> I wasn't asking what FOL is
20:43:00 <newsham> FSOL > FOL
20:43:02 <newsham> sorry
20:43:12 <SamB_XP_> I like HOL
20:43:13 <newsham> ambiguous questions get wrong answers
20:43:20 <roconnor> http://www.tachyos.org/godel/Godel_arithmetization.html
20:43:20 <lambdabot> Title: G&ouml;del arithmetization applet details
20:43:36 <vixey> Isabelle?
20:43:40 <vixey> you have tried this?
20:43:48 <newsham> i've playd with isabelle a little bit
20:43:59 <newsham> there's a live cd with isabelle if you wanna goof w/ it
20:44:10 <newsham> at  http://typessummerschool07.cs.unibo.it/
20:44:11 <lambdabot> Title: Types Summer School 2007
20:44:48 <vixey> I read about half a book on it
20:44:54 <vixey> I didn't ever touch the system though
20:45:06 <newsham> the interactive features are neat
20:45:13 * SamB_XP_ actually uses Coq, which is plenty higher-order for him
20:45:34 <newsham> i have some screenshots here http://users.lava.net/~newsham/formal/reverse/
20:45:34 <lambdabot> Title: Formal methods: Reverse
20:46:35 <vixey> nice easy proof
20:46:50 <newsham> i work much better with easy
20:54:45 <roconnor> @free reverse
20:54:47 <lambdabot> $map f . reverse = reverse . $map f
20:56:05 <Elly> what does @free actually do?
20:56:24 <SamB> @google "theorems for free"
20:56:26 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
20:56:26 <lambdabot> Title: Theorems for Free! - Wadler (ResearchIndex)
20:56:56 <SamB> Elly: that paper explains the principles behind it
20:57:26 <SamB> the gist is that it can derive a theorem from the type of a function
20:57:40 <newsham> lambdabot has more journal article features than any other bot
20:57:54 <Elly> yeah, I noticed
20:58:04 <vixey> It's to do with natural transforms
20:58:20 <SamB> what other journal article features does it have?
20:58:22 <SamB> djinn?
20:58:24 <SamB> quickcheck?
20:58:26 <vixey> what it has to do with them I have no idea
20:58:30 <roconnor> @free id
20:58:31 <Elly> citeseer won't give me the actual paper
20:58:31 <lambdabot> f . id = id . f
20:58:36 <SamB> Elly: it won't?
20:58:41 <vixey> @quote academic
20:58:41 <lambdabot> ricky_clarkson says: Is Haskell an interface between programming languages and academics?
20:58:59 <Elly> oh, no, there it is
20:59:11 <newsham> samb: vixen?  ;-)
20:59:35 <SamB> newsham: there can't be a journal article about a silly thing like that can there?
20:59:51 <SamB> it isn't even an ELIZA-class intelligence!
21:00:22 <roconnor> @free undefined
21:00:24 <lambdabot> f undefined = undefined
21:00:24 <solrize> fortress looks interesting
21:00:43 <roconnor> @free fix
21:00:45 <lambdabot> f . g = h . f => f (fix g) = fix h
21:01:49 <roconnor> @free sort
21:01:52 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
21:02:01 <roconnor> typeclass
21:02:15 <roconnor> @free sortBy
21:02:18 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
21:02:41 * roconnor ponders that
21:02:47 <SamB> that's actually a pretty good theorem
21:03:09 <roconnor> g x y = h (f x) (f y) ?
21:03:11 <roconnor> ah
21:03:34 <nolrai_> :t sec
21:03:36 <lambdabot> Not in scope: `sec'
21:03:40 <nolrai_> :t snd
21:03:42 <lambdabot> forall a b. (a, b) -> b
21:03:43 <SamB> @remember @free @free sortBy ==> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
21:03:43 <lambdabot> Okay.
21:03:47 <SamB> @quote @free
21:03:47 <lambdabot>  @free says: @free sortBy ==> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
21:04:24 <Elly> for some reason this pdf is owning xpdf
21:04:35 <Elly> it's taking 15 seconds to draw each page
21:05:30 <SamB> is anyone here any good at Ruby?
21:06:13 <TomMD> sms__: Try pureMD5 0.2.1, which should fix the Cabal issue.
21:06:17 <dolio> I used to dabble in Ruby.
21:06:22 <dolio> But I'm out of practice.
21:06:45 <roconnor> @free callCC
21:06:47 <lambdabot> Expected variable or '.'
21:06:47 <SamB> I wish Ohloh could count ocaml...
21:07:10 <SamB> (and ohcount is written in Ruby.)
21:07:19 <roconnor> @free ((((a -> b) -> a) -> a) -> b) -> b
21:07:20 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:07:22 <dolio> Ah.
21:07:35 <roconnor> @free (foo:: ((((a -> b) -> a) -> a) -> b) -> b)
21:07:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:07:40 <SamB> I mean, look at this! http://www.ohloh.net/projects/coq/analyses/latest
21:07:41 <lambdabot> Title: Coq proof assistant - Ohloh
21:08:05 <SamB> As reasonable as it would be for Coq to be written in LaTeX...
21:08:25 <SamB> I think it has a lot more ocaml code than C++
21:12:35 <vixey> ocaml is ace
21:13:22 <vixey> lol SamB
21:13:28 <vixey> those statistics are ridiculous
21:14:02 <nolrai_> what is @free?
21:14:06 <SamB> vixey: I think they're okay except for the part where they leave out all of the Ocaml and Vernacular code...
21:14:26 <SamB> (i.e. just about all of the code ;-)
21:14:27 <vixey> I think the whole idea of this ohloh thing is wrong
21:15:30 <SamB> maybe they should just come up with a better way to implement new languages for ohcount ?
21:16:39 <vixey> they should just take down the entire website
21:19:56 <SamB> I wish the Coq guys would stop writing commit messages in French :-(
21:20:35 <vixey> just learn french
21:21:17 <SamB> Well, I think I can read this one: Correction bug alias d'alias
21:21:54 <nolrai_> >(mod 4 2, mod 2 4)
21:22:20 <nolrai_> > (mod 4 2, mod 2 4)
21:22:22 <lambdabot>  (0,2)
21:23:13 <Adamant> learn Interlingua, then you can pick up any Romance language fast
21:24:59 <nolrai_> :t printLn
21:25:00 <lambdabot> Not in scope: `printLn'
21:25:09 <dibblego> :t putStrLn
21:25:10 <lambdabot> String -> IO ()
21:28:47 <nolrai_> does hpast anounce not work any more?
21:30:12 <vixey> ?djinn  ∀x, x
21:30:13 <lambdabot> Cannot parse command
21:30:50 <nolrai_> can one define mutualy recusive things with "let"s in ghci?
21:31:34 <vixey> no
21:31:46 <vixey> it has to be a single let
21:31:51 <shachaf> > let x = 1 : y; y = 1 : x in x
21:31:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:32:04 <shachaf> Oh, with multiple lets.
21:32:14 <shachaf> No; ghci is like do notation.
21:33:37 <nolrai_>  (do {let x = 1 : y; y = 1 : x; return x} ) undefined;
21:33:49 <nolrai_> > (do {let x = 1 : y; y = 1 : x; return x} ) undefined;
21:33:49 <lambdabot>  Parse error at "}" (column 40)
21:33:56 <nolrai_> > (do {let x = 1 : y; y = 1 : x; return x;} ) undefined;
21:33:57 <lambdabot>  Parse error at ";}" (column 40)
21:35:07 <Axman6> > let x = 1 : y; y = 2 : x in x
21:35:08 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
21:35:30 <Axman6> ok
21:36:21 <vixey> > let x = fix (1:2:) ; y = tail x in x
21:36:22 <lambdabot>      The operator `:' [infixr 5] of a section
21:36:22 <lambdabot>         must have lower precede...
21:36:29 <vixey> ... :(
21:36:37 <vixey> > let x = fix ((1:).(2:)) ; y = tail x in x
21:36:38 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
21:38:18 <Axman6> that's starting to look like ascii boobs...
21:38:56 <solrize> :t (.).(.)
21:38:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
21:39:18 <vixey> :t ((.)(.)(.))
21:39:18 <solrize> :t (*).(*)
21:39:20 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
21:39:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
21:42:17 * vixey still wishes for something worthwhile to do with harpy...
21:42:58 <shapr> !paste
21:43:01 <shapr> hmm
21:43:18 <shapr> @seen hpaste
21:43:18 <lambdabot> I saw hpaste leaving #haskell 2d 11h 13m 4s ago, and .
21:43:20 <shapr> oops
21:43:39 <vixey> shapr!!!!! :P
21:43:46 <shapr> vixey!
21:44:19 <shapr> tadah! hpaste has returned!
21:44:22 <shapr> !paste
21:44:22 <hpaste> Haskell paste bin: http://hpaste.org/
21:44:29 <vixey> cool
21:44:37 <shapr> nolrai_: Ok, I fixed it!
21:45:03 <shapr> I think I'm the maintainer for hpaste, so if it has any problems, tell me!
21:45:22 <shapr> I do wish it could reconnect automatically.
21:45:45 <TomMD> What is this?  A perfectly good Friday night and I don't see any Haskell blogs popping up.
21:45:48 <vixey> doesn't lambdabot reconnect automatically using some kind of bash while loop
21:45:59 <shapr> I don't know.
21:46:07 <shapr> If it does, I'm sure I can get hpaste to do that too.
21:46:15 <vixey> If I wrote some code I'd blog it .
21:46:15 <shapr> TomMD: I was being social, what's your excuse? :-)
21:46:28 * shapr gave his number to a cute chick.
21:47:04 <TomMD> shapr: I'm writing Data.ByteString.Lazy.Num
21:47:08 <shapr> TomMD: cool!
21:47:17 <shapr> @seen bos
21:47:17 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
21:47:35 <bos> que?
21:47:42 <shapr> Does anyone know if bos' bloomfilter library includes edwardk's linear bloom filters?
21:47:46 <shapr> bos: oh hi!
21:47:56 <shapr> slanche! or something like that...
21:48:00 <bos> no, edwardk's stuff would be quite a bit of work to implement.
21:48:01 <TomMD> And why is he using C code? ;-)
21:48:35 <bos> TomMD: if you want to rewrite bob jenkins's hash functions in haskell, and tune them to C levels of performance, please send me a patch when you're done :-)
21:48:47 * shapr grins
21:49:18 <bos> i do want to implement those linear bloom filters, but gotta finish the book and go on vacation and find a new job and stuff first.
21:49:24 <bos> oh, and move house.
21:49:32 <shapr> bos: c'mon, that leaves you LOTS of spare time!
21:49:38 <shapr> But seriously, I was thinking about hacking on them some.
21:49:42 <bos> go for it.
21:49:57 <shapr> Just curious whether you already had them or not.
21:50:10 <shapr> I've been reading some really interesting papers on bloom filters for network routing.
21:50:27 <bos> you might find my code a bit unsuited to your needs, as my filters are power-of-two sized for performance reasons.
21:50:38 * shapr gets out the code machete
21:50:39 <TomMD> bos: I don't get that last one?  Move house?
21:50:43 <bos> yes, bloom filters have lots of interesting applications.
21:50:48 <shapr> bos: Where are you moving?
21:51:02 <bos> just moving to a bigger place nearby.
21:51:06 * Axman6 googles bloom filters
21:54:55 <Axman6> how interesting
21:58:38 <slava> where do i read about the implementation of forkIO?
22:00:37 <vixey> I'm keen on forkIO = ForkIO
22:00:44 <vixey> this I like
22:01:18 <vixey> when the interpreter sees a ForkIO datum it just forks
22:02:04 <bos> slava: http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz
22:02:45 <bos> oh dear god. how far into rank-2 types do i go to explain the ST monad?
22:03:39 <Elly> I fear Haskell so much :(
22:03:45 <shapr> Elly: Bah, there's nothing to fear.
22:03:56 <shapr> If I can do Haskell, anyone can do Haskell.
22:03:57 <Elly> "how far into rank-2 types do I go to explain the ST monad?"
22:04:15 <Elly> people say stuff like that all the time!
22:04:41 <bos> Elly: there's understanding enough to be able to use it, and going deep, and the two are not really related.
22:04:48 <Elly> heh
22:04:52 <Elly> I want to go deep though :P
22:05:00 * Elly likes the little type theory he knows
22:05:02 <shapr> Elly: Well, it's hard to start deep.
22:05:08 <bos> well then. get those fear glands ready, because there's plenty to learn.
22:05:13 <Elly> excellent
22:05:15 <shapr> Elly: But if you start shallow, deep stops being deep pretty fast :-)
22:05:18 <Elly> I need to learn what monads are I think
22:05:28 <shapr> Elly: Monads are an abstraction, like objects.
22:05:40 <bos> Elly: there's this great book you should buy when it comes out. i know some of the authors.
22:05:45 <Elly> bos: which?
22:05:59 <bos> http://book.realworldhaskell.org/beta/
22:06:00 <shapr> They're a convention that lets you encapsulate and compose chunks of code such that the code parts behave the same no matter how you compose them.
22:06:00 <lambdabot> Title: Real World Haskell
22:06:05 <shapr> No wait..
22:06:08 <shapr> bos IS one of the authors!
22:06:20 <bos> shapr: they're a friggin spacesuit, and apple cart, and escape hatch.
22:06:35 <Elly> that is my problem with monads
22:06:40 <shapr> Elly: What?
22:06:43 <Elly> people have a lot of elaborate metaphors for them
22:07:01 <bos> ignore the descriptions that use metaphor. they're all utterly awful.
22:07:09 <Elly> bos: is dons Don Stewart?
22:07:13 <shapr> Elly: Actually, monads are three laws that the convention must follow, and one type.
22:07:14 <bos> yes.
22:07:25 <Elly> ahh
22:07:31 <Elly> shapr: what are the three laws?
22:07:36 <shapr> Elly: Thing is, monads are really freakin simple. You can describe them totally and fully in one line of irc text.
22:07:36 <bos> a monad must not harm a coder, or through any action allow a coder to come to harm.
22:07:40 * shapr laughs
22:07:44 <Elly> bos: ;)
22:07:50 <thetallguy> bos: nice one
22:07:50 <vixey> hehee
22:07:58 <vixey> hmmm
22:08:05 <shapr> Elly: But knowing that one line of text doesn't show you all the COOL STUFF you can do with monads!
22:08:07 * vixey looks for more asimove
22:08:07 <bos> a monad must obey orders given to it by coders, except where such orders would conflict with the First Law
22:08:07 <Elly> bos: I will totally buy this book :)
22:08:19 <bos> a monad must protect its own existence as long as such protection does not conflict with the First or Second Law.
22:08:23 <shapr> bos: Um, how much extra does an autographed copy cost?
22:08:26 <Elly> bos: so we are safe from Haskell-powered robotic killing machines :)
22:08:26 * shapr snickers
22:08:46 <bos> Elly: not if shapr has anything to do with it!
22:08:50 <thetallguy> Never, ever, ask a monad about its god.
22:09:03 <bos> i think he's building them in his basement death lab even as we speak!
22:09:14 <Elly> but if he uses monads they can't harm us
22:09:19 <Elly> and if he doesn't he can't do I/O!
22:09:27 <bos> the problem is, most monads have an escape hatch.
22:09:31 <Elly> o_O?
22:10:23 <shapr> bos: Actually, I only succeeded in soldering a bunch of pins together. Until I get a solder sucker, the world is safe from by Haskell-powered robotic killing machines.
22:10:43 <bos> most monads have an execution function. you put stuff in, run the monad, and get a result out afterwards. that's the escape hatch.
22:10:51 <Axman6> i need to try out my coldheat soldering iron sometime
22:11:02 <Elly> where's the canonical list of monad tutorials?
22:11:22 <vixey> ?where Monads
22:11:22 <lambdabot> http://www.haskell.org/all_about_monads/html/
22:11:25 <bos> Elly: ignore them all. just read sigfpe's "you could have invented monads", and read the monad chapters of the book.
22:11:26 <thetallguy> Elly: bos' law is so funny, not just because of Asimov's laws, but because that really is what the monad laws are supposed to do
22:11:27 <Axman6> bos: as opposed to getting the result before you out int the stuff?
22:11:33 <vixey> actually yes
22:11:38 <vixey> the one bos mentioned is really good
22:11:46 <vixey> at least it's the first thing that made any kind of sense to me
22:12:44 <Axman6> link?
22:13:03 <Saizan> ?google you could have invented monads
22:13:04 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:13:04 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
22:13:29 <vixey> @seen monochrom
22:13:29 <lambdabot> I saw monochrom leaving #haskell-blah and #haskell 1h 7m 35s ago, and .
22:13:35 <vixey> :(
22:13:47 * vixey wants asimov short story recommendations
22:14:32 <bos> our coverage of monads is somewhat inspired by sigfpe's.
22:14:41 <Elly> vixey: The Last Question, of course
22:15:10 <bos> only, because we're writing a book and not a blog posting, we get to spend several chapters on the subject.
22:15:12 <vixey> Elly, I absolutely loved that one.. it's the only one I've read though
22:15:26 <solrize> nightfall is the most famous
22:15:38 <Elly> the foundation series is pretty good
22:15:50 <solrize> those aren't stories :)
22:16:02 <solrize> nightfall is a novella, i guess
22:18:42 <slava> bos: that paper doesn't go into the implementation
22:18:55 <bos> slava: hm, thought it did, sorry.
22:19:06 <bos> slava: what details did you have in mind?
22:19:25 <slava> a high-level overview of the relevant code in rts
22:19:49 <bos> that might be hard to come by.
22:20:30 <bos> slava: you might start here - http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts
22:20:31 <lambdabot> Title: Commentary/Rts - GHC - Trac
22:21:00 <bos> slava: but there's little about concurrency there
22:21:32 <bos> slava: try this - http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
22:21:35 <lambdabot> Title: Commentary/Rts/Scheduler - GHC - Trac
22:22:16 <jdrake> How much would you pay for an ethernet cable? http://www.usa.denon.com/ProductDetails/3429.asp
22:22:16 <lambdabot> Title: Denon USA | AK-DL1
22:31:24 <TomMD> @src fromIntegral
22:31:24 <lambdabot> fromIntegral = fromInteger . toInteger
22:49:01 <Adamant> jdrake - this is why audiophiles in the digital age drive me nuts
22:49:11 <Adamant> well, a certain class of them
22:49:43 <jdrake> Adamant: :-)
22:50:29 <bos> we should all be using coathangers for audio.
22:50:40 <Adamant> we could. it's digital.
22:50:49 <Draconx> Audiophile, noun: Someone who listens to the equipment rather than the music.
22:51:17 <Elly> uhm...wait
22:51:25 <Elly> why is this 5-foot CAT5E cable $500?
22:51:25 <bos> Adamant: even for non-digital audio: http://consumerist.com/362926/do-coat-hangers-sound-as-good-monster-cables
22:51:26 <lambdabot> Title: Experiments: Do Coat Hangers Sound As Good Monster Cables?, http://tinyurl.com/26n3w5
22:51:29 <solrize> @where (.&.)
22:51:29 <lambdabot> I know nothing about (.&.).
22:51:33 <solrize> 3 .&. 1
22:51:37 <solrize> > 3 .&. 1
22:51:38 <lambdabot>  Add a type signature
22:51:42 <solrize> > 3 .&. 1 :: Int
22:51:43 <lambdabot>  1
22:52:13 <bos> Data.Bits
22:52:17 <solrize> thanks
22:52:25 <Adamant> it's interesting listening to my dad talk about back in the day when you could easily design speakers that were as good as most pro speakers at home, then it was probably fun to be an audiophile.
22:52:47 <solrize> now you can buy $500 audiophile ethernet cables from denon...
22:54:22 <solrize> import Data.Bits ((.&.))    -- heh
22:54:33 <solrize> (.&.) didn't work
22:55:15 <Elly> I still don't understand the existence of audiophile ethernet cables
22:55:28 <Elly> wouldn't you be using an error-correction protocol *anyway*?
22:55:36 <solrize> http://gadgets.boingboing.net/2008/06/13/500-ethernet-cable-a.html
22:55:37 <lambdabot> Title: $500 ethernet cable: are your packets worth it? - Boing Boing Gadgets, http://tinyurl.com/6ez99s
22:55:41 <solrize> apparently they don't
22:57:25 <Elly> that's dumb
22:57:32 <Elly> not that it matters either way
22:57:45 <Elly> but for $500 I could buy a second computer to send exact copies of all my packets for me
22:58:15 <roconnor> I suppose techinically a good cable could increase throughput by having fewer errors
22:58:23 <nolrai_> "x:y:_" is how to patern match to a list with 2 or more inputs, right?
22:59:14 <vixey> yes
22:59:22 <Elly> roconnor: for $500 you could run two cheap cables side by side and increase throughput :P
22:59:37 <roconnor> that might be more effective
23:01:10 <HunterXHunter>  '<
23:02:11 <SamB> wouldn't that be more like an additional $30-$40?
23:02:52 <SamB> anyway, super-high-quality cables would only make sense for analog ...
23:07:52 <Elly> well
23:07:59 <Elly> for $500 you could run at least 10 extra cables
23:08:06 <Elly> that's some extra throughput :P
23:08:46 <mmorrow> slava: http://darcs.haskell.org/ghc/rts/
23:08:46 <lambdabot> Title: Index of /ghc/rts
23:08:50 <mmorrow> slava: http://citeseer.ist.psu.edu/682782.html
23:08:52 <lambdabot> Title: Making a Fast Curry (ResearchIndex)
23:09:12 <mmorrow> vixey: did you check out harpy??
23:09:25 <vixey> mmorrow: yeah I did
23:09:38 <mmorrow> vixey: what are your thoughts?
23:09:50 <vixey> mmorrow: I'm still trying to figure out what to do with it
23:10:02 <mmorrow> vixey: haha. me too
23:10:04 <vixey> mmorrow: I'm sure there's something really really great to do with it :)
23:10:10 <mmorrow> vixey: haha. me too.
23:10:17 <mmorrow> vixey: :)
23:12:32 <mmorrow> vixey: was thinking it'd be good to have a layer between it (or any other codegen/whatever) and other code. maybe a typeclass that at first just make harpy somehow an instance of
23:12:54 <mmorrow> that way no harpy vendor locking thing
23:15:09 <Elly> what's harpy?
23:15:12 <mmorrow> i'm not sure yet how such a class would/should look, but it's on my mind fairly often
23:16:02 <mmorrow> Elly: heh. http://code.haskell.org/~morrow/code/haskell/misc/fib.html
23:16:04 <mmorrow> http://uebb.cs.tu-berlin.de/harpy/
23:16:09 <Staz> E[E1 O E2] r k = R[E1] r \e1 . R[E2] r \e2 . O[O](e1,e2)k <-- is anybody able to help me understand what on earth is going on here?
23:16:16 <mmorrow> Elly: check out the tutorials
23:16:21 <Staz> (semantic algebra)
23:16:24 <Elly> oh, wow
23:16:29 <Elly> the title pretty much says it all
23:17:07 <Staz> It's used to evaluate expression of the form <operand> <operator> <operand>
23:17:25 <Staz> O could be '+' , '-' etc..
23:17:51 <electronx> hi how do i convert a list of 4 chars into an int? or word32?
23:18:16 <Staz> r = environment, k = expression continuation
23:18:19 <electronx> because i did file <- readFile "test.exe"??
23:20:10 <mmorrow> turn em into [Word8] the get your Data.Bits on
23:20:33 <mmorrow> w/the/then/
23:20:34 <augustss> yawn
23:20:38 <mmorrow> s/w/s/
23:21:02 <electronx> how do i turn them into word8?
23:21:17 <Saizan> Staz: R[] and O[] ? versions of E[] specialized to operands and operators?
23:21:27 <mmorrow> fromIntegral . ord
23:21:34 <mmorrow> :t fromIntegral . ord
23:21:36 <lambdabot> forall b. (Num b) => Char -> b
23:21:42 <mmorrow> :t fromIntegral . ord :: Char -> Word8
23:21:43 <lambdabot> Char -> Word8
23:22:23 <electronx> :t fromIntegral
23:22:25 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:22:28 <electronx> thanks
23:22:34 <mmorrow> :)
23:23:12 <Staz> Saizan : R is for evaluating right hand expressions I think.
23:23:24 <Staz> E evaluates any expression.
23:24:08 <Staz> R[E] r k = E[E] r; deref; Rv ? ; k
23:26:01 <Saizan> however, have you ever used CPS?
23:26:10 <Staz> Saizan : does not ring a bell
23:26:27 <Saizan> continuation-passing-style
23:27:16 <Staz> never heard of it but now I have a new key word to google :)
23:27:26 <Staz> every little bit helps
23:27:59 <Saizan> in haskell your E would have a type like Expr -> Env -> (Value -> x) -> x
23:28:01 <Staz> In the expression I pasted above, what scope do the lamdas have?
23:28:27 <Saizan>  E[E1 O E2] r k = R[E1] r (\e1 . R[E2] r (\e2 . O[O](e1,e2)k))
23:28:47 <Staz> excellent that helps a lot!
23:30:58 <Staz> so "(\e1 . R[E2] r (\e2 . O[O](e1,e2)k))" is the continuation?
23:31:17 <Saizan> yes, it's the continuation passed to R[E1] r
23:32:00 <Saizan> and (\e2 . O[O](e1,e2)k) is the one for R[E2] r
23:32:22 <Staz> thanks very much for this Saizan. This stuff has been driving me crazy all day.
23:32:32 <Staz> actually more like all week
23:33:10 <ooxwo> Anybody know any good docs on importing?  I can import Data.List in ghc but not Data.Set.  Am I just missing some library or path setting?
23:33:34 <mmorrow> import qualified Data.Set as S
23:33:48 <mmorrow> (possibly you problem)
23:33:56 <ooxwo> Yeah that's what I've got, but it doesn't seem to work
23:34:01 <mmorrow> why?
23:34:21 <mmorrow> what is the error "_"
23:35:06 <ooxwo> Undefined symbols:
23:35:06 <ooxwo>   "___stginit_containerszm0zi1zi0zi1_DataziSet_", referenced from:
23:35:06 <ooxwo>       ___stginit_Main_ in surreal.o
23:35:06 <ooxwo> ld: symbol(s) not found
23:35:08 <Saizan> Staz: no problem :) haskell's Cont monad is exactly the same mechanism btw
23:35:09 <ooxwo> collect2: ld returned 1 exit status
23:35:17 <dmwit> ghc --make
23:35:30 <mmorrow> what dmwit said
23:35:51 <Saizan> this should be added to ghc's error message
23:35:53 <ooxwo> Aha.  Thanks
23:36:13 <ooxwo> Any way to import Data.Set into ghci?
23:36:23 <Saizan> ooxwo: :m + Data.Set
23:36:24 <mmorrow> :m + Data.Set
23:37:06 <ooxwo> Ah, cool.  This has been a mystery to me, thanks all around.
23:40:14 <mmorrow> being burnt at the stake would be a pretty terrible way to die
23:40:44 <mmorrow> (jon_of_arc_ => joan of arc)
23:40:58 <mmorrow> </randomthoughtspew>
23:41:02 <jon_of_arc> Heh, I'd imagine.
23:41:11 <jon_of_arc> Hopefully there won't be any confusion :)
23:41:29 <mmorrow> just practice blowing out matches. you'll be fine.
23:42:19 <solrize> @hoogle (forall m :: *->*). (Monad m) => Int -> m a
23:42:19 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*->*). (Mo'
23:42:34 <solrize> @t print
23:42:34 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:42:44 <solrize> :t liftM
23:42:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:43:01 <solrize> @hoogle forall (m :: *->*). (Monad m) => Int -> m a
23:43:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*->*). (Mo'
23:43:25 <solrize> @hoogle forall (m :: * -> *). (Monad m) => Int -> m a
23:43:25 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *). ('
23:44:44 <solrize> i'm trying to write a data.binary.Get instance for a counted string, i.e. some bytes representing an integer n, then n data bytes.  what's the right way to do that?
23:48:08 <Saizan> solrize: write an action to extract the integer and then get that number of bytes?
23:48:21 <solrize> i've got the integer, i'm not sure how to get the bytes
23:48:38 <solrize> with replicateM ?
23:49:07 <Saizan> depends how do you want them [Word8] or ByteString ?
23:49:30 <solrize> ByteString i guess
23:49:46 <Saizan> getBytes :: Int -> Get ByteString
23:49:53 <Saizan> in Data.Binary.Get
23:50:18 <solrize> oh neat, i'm looking at the wrong doc page
23:50:23 <solrize> didn't realize there was a separate one
23:50:29 <solrize> thanks, lemme look there
23:52:39 <nolrai_> :t ***
23:52:43 <lambdabot> parse error on input `***'
23:52:48 <nolrai_> :t (***)
23:52:50 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:54:04 <solrize> i can't have bytestrings whose lengths don't fit in an Int?
23:55:43 <Saizan> there's getLazyByteString iirc
23:55:50 <Saizan> which takes an Int64
23:56:01 <solrize> getLazyByteString :: Int -> Get ByteString
23:56:01 <solrize> An efficient get method for lazy ByteStrings. Fails if fewer than n bytes are left in the input.
23:56:07 <Saizan> oh
23:56:56 <solrize> i don't see how it can both be lazy and know if fewer than n bytes are left in the input
23:58:04 <Saizan> getLazyByteString :: Int64 -> Get ByteString <- in 0.4.2
23:58:30 <Elly> it tries reading the bytes
23:58:31 <solrize> aha
23:58:32 <Elly> and fails?
23:58:40 <solrize> that's the definition of non-laziness ;)
23:58:54 <Saizan> An efficient get method for lazy ByteStrings. Does not fail if fewer than n bytes are left in the input.
23:58:57 <Elly> touche
23:59:07 <Saizan> well "fail" is quite ambiguous here
23:59:11 <Elly> maybe it has some kind of lookahead
23:59:15 <solrize> aha, thanks for that int64, i'm looking at a way-old doc, gotta find the newer one
23:59:57 <Saizan> it could be the monadic fail, or simply an "error "foo"" hidden in the tail of the bytestring
