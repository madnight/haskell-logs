00:11:34 <solrize> hmm, now i've got to read some bytes until i hit one that doesn't have the 0x80 bit set, i.e. something like   takeWhile (\x->x.&.0x80 == 0) getRemainingLazyByteString   but i think that will gobble the whole rest of the string.  i guess i can write a recursive action for this but is there a simpler way?
00:19:13 <Cale> solrize: maybe lookAhead?
00:19:30 <Cale> Or perhaps lookAheadM
00:20:08 <Cale> er, hmm
00:20:43 <Saizan> solrize: it seems like getRemainingLazyByteString won't alter the state looking at the code
00:22:04 <solrize> hmm interesting, so i can use that and then skip
00:22:08 <Cale> and even if it did, you could wrap it in a lookAhead to prevent it from eating the rest of the input.
00:22:10 <Cale> Yeah.
00:22:19 <solrize> thanks, that sounds good
00:22:58 <solrize> lookAhead fires up a new State monad so it doesn't mess with the current one?  ic
00:23:18 <solrize> > 1 << 3
00:23:19 <lambdabot>   Not in scope: `<<'
00:23:24 <solrize> > 1 .<<. 3
00:23:25 <lambdabot>   Not in scope: `.<<.'
00:23:31 <solrize> > 1 `lshift` 3
00:23:32 <lambdabot>   Not in scope: `lshift'
00:23:41 <solrize> > 1 `lShift` 3
00:23:42 <lambdabot>   Not in scope: `lShift'
00:23:50 <Cale> shiftL
00:23:53 <solrize> thanks
00:23:58 <Cale> > 1 `shiftL` 3
00:23:58 <lambdabot>  Add a type signature
00:24:02 <Cale> > 1 `shiftL` 3 :: Integer
00:24:03 <lambdabot>  8
00:27:34 <solrize> :t replicateM
00:27:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
00:31:54 <solrize> instance LBinary Int32 where
00:31:54 <solrize>     get = do
00:31:54 <solrize>       [a,b,c,d] <- replicateM 4 (liftM fI getWord8)
00:31:54 <solrize>       let (<<) = shiftL
00:31:54 <solrize>       return (a<<24 + b<<16 + c<<8 + d)
00:31:57 <solrize> Does that look ok?
00:32:01 <solrize> fI = fromIntegral
00:33:26 <Cale> Reasonably so, but I'm not sure what the LBinary class is.
00:33:49 <solrize> it's like data.binary except with no type tags in the data
00:33:59 <solrize> it actually starts to look like a useful general purpose module
00:34:21 <solrize> i'm writing it to parse some binary files that came from a java program
00:34:55 <solrize> so for int32, i want to read 4 bytes in big-endian order etc.
00:35:05 <solrize> i hope the compiler won't actually cons up that [a,b,c,d] list
00:35:37 <Cale> It may.
00:36:04 <taruti> Is there an easy way to capture the input parsed by a parsec parser? i.e. capture :: CharParser st any -> CharParser st (any, String)
00:36:07 <Cale> Isn't that the behaviour of Data.Binary as it is though?
00:36:20 <solrize> i don't know, the docs don't say
00:36:46 <solrize> i mean data.binary might do that for int32 but i also want to parse a bunch of lists and tuples that are just concatenated together
00:37:30 <Cale> Ah, it does actually.
00:38:26 <Cale> For Int32, it uses fromIntegral and the instance for Word32, which uses get/putWord32be
00:39:14 <hpaste>  Cale pasted "getWord32be" at http://hpaste.org/8327
00:39:17 <solrize> ohhh these weren't in the other docs
00:39:18 <solrize> thanks
00:39:48 <solrize> readN?
00:41:20 <Cale> ah, that's defined in Data.Binary.Get
00:41:25 <Cale> readN :: Int -> (B.ByteString -> a) -> Get a
00:41:25 <Cale> readN n f = fmap f $ getBytes n
00:41:40 <Cale> -- | Pull @n@ bytes from the input, as a strict ByteString.
00:41:40 <Cale> getBytes :: Int -> Get B.ByteString
00:42:11 <solrize> http://hackage.haskell.org/packages/archive/binary/0.4.2/doc/html/Data-Binary-Get.html    not in here ?
00:42:13 <lambdabot> http://tinyurl.com/6kgduv
00:42:29 <Saizan> it's not exported
00:42:49 <Saizan> however you can just use the getWord* primitives
00:42:53 <Cale> Right, it's not exported.
00:42:58 <solrize> ic, so haddock doesn't show it even though it's in that @n@ notation
00:43:28 <Cale> Right, if at some point it were exported, it would be documented ;)
00:44:12 <Cale> Perhaps Haddock should put a section at the end for internal module documentation.
00:46:16 <Saizan> taruti: look at getState and getPosition
00:46:37 <solrize> :t fromIntegral
00:46:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:52:10 <taruti> Saizan: SourcePos (used by getPosition) uses a line+col format which makes it nonsuitable.
01:11:49 <solrize> darn that monomorphism restriction ;P
01:15:54 <alech> Hi, I am pretty new to Haskell so please bear with me :) I am trying to write a CGI that outputs the contents of a file, but I am having some trouble with the IO monad there ...
01:15:57 <hpaste>  alech pasted "CGI + readFile" at http://hpaste.org/8328
01:16:07 <alech> maybe someonw knows a clever trick?
01:16:46 <vixey> alech: I think readFile has the type String -> IO String
01:16:51 <vixey> :t readFile
01:16:52 <alech> it does
01:16:53 <lambdabot> FilePath -> IO String
01:16:55 <vixey> yeah
01:17:05 <vixey> so, well +++ needs a String doesn't it ?
01:17:14 <alech> true
01:17:21 <alech> but I can't convert IO String to String, right?
01:17:29 <vixey> in which case, you can get the String out of the IO String like this:
01:17:31 <vixey>       do
01:17:38 <vixey>    s <- readFile "/tmp/foo"
01:17:45 <vixey>     output $ renderHtml $ body << h1 << "Foo" +++ s
01:17:55 <vixey> um.. with better indentation I suppose
01:17:58 <alech> :)
01:18:04 <alech> ok, I'll try that
01:18:09 <alech> can I only do that in cgiMain?
01:18:19 <alech> I believe I've tried something similar in a different function
01:18:25 <alech> but ended up with an IO String again
01:18:29 <vixey> you could do that sort of thing in any do block (in a monad)
01:18:33 <Boney> you can do that in a function that is IO somthing.
01:18:42 <vixey> s will be a String for the whole body of that 'do'
01:18:59 <vixey> if someone out side the do block looks in, it will be IO String again
01:19:04 <alech> ah, ok.
01:19:07 <alech> I see.
01:20:30 <alech> hmmm, I get an error with that:
01:20:32 <hpaste>  alech pasted "error ..." at http://hpaste.org/8329
01:20:56 <vixey> oh maybe it's got to be
01:21:02 <solrize> > (fromInteger (255 :: Word8)) :: Int
01:21:02 <lambdabot>  Couldn't match expected type `Integer'
01:21:05 <vixey>    s <- lift $ readFile "/tmp/foo"
01:21:08 <vixey> or
01:21:10 <solrize> > (fromIntegral (255 :: Word8)) :: Int
01:21:10 <vixey>    s <- liftIO $ readFile "/tmp/foo"
01:21:11 <lambdabot>  255
01:21:15 <vixey> or something like that
01:21:41 <maltem> alech: Probably you have runCGI at a bad position relative to the other functions
01:22:17 <alech> maltem: hmmm, no idea, that came from the CGI example ...
01:22:45 <maltem> alech: Well what's your code now?
01:22:58 <solrize> > (fromInteger (255 :: Word8)) :: Int32
01:22:59 <lambdabot>  Couldn't match expected type `Integer'
01:23:03 <solrize> > (fromIntegral (255 :: Word8)) :: Int32
01:23:04 <lambdabot>  255
01:23:28 <vixey> alech: try to lift it?
01:23:36 <alech> vixey: yes, that seems to work :)
01:23:41 <vixey> oh cool
01:23:47 <alech> now I only need to understand the theory behind that ...
01:23:51 <vixey> alech: so that means that CGI is a monad transformer
01:23:53 <vixey> stack
01:24:03 <vixey> so there are some layers of monads
01:24:22 <vixey> the operations would act in layer 1 usually, but lifting it up will let you use the inner layer (IO)
01:24:33 <vixey> & there is a much better explanation than mine..
01:24:39 <alech> :-)
01:24:54 <vixey> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
01:24:55 <alech> I'll still need to wrap my head around monads in general, I guess.
01:25:13 <vixey> this is a great paper about it
01:25:20 <solrize> minBound 3 :: Int
01:25:28 <solrize> > minBound :: Int
01:25:29 <lambdabot>  -2147483648
01:25:31 <solrize> > minBound :: Int8
01:25:32 <lambdabot>  -128
01:25:50 <solrize> > 200 :: Int8
01:25:51 <lambdabot>  -56
01:26:08 <maltem> alech: Monad transformers are just a way to combine the functionality of different monads (here, CGI and IO)
01:26:14 <solrize> > fromIntegral (200 :: Word8) :: Int8
01:26:15 <lambdabot>  -56
01:26:22 <alech> ok ...
01:26:23 <oldsalt> @seen TomMD
01:26:23 <lambdabot> TomMD is in #haskell, #xmonad and #ghc. I last heard TomMD speak 2h 55m ago.
01:28:21 <solrize> whooie
01:28:23 <solrize> sorry
01:30:32 <hpaste>  solrize pasted "pointless clone of Data.Binary?" at http://hpaste.org/8330
01:31:04 <solrize> oh heh, ignore that list instance :)
01:35:18 <maltem> solrize: That's just like the Binary class without a put?
01:35:56 <solrize> maltem yeah, the idea is that the external representation of (a,b) is the representation of a immediately followed by the representation of b
01:36:09 <solrize> which is probably true of Data.Binary but is not stated in the documentation
01:37:06 <maltem> The implementation in Data.Binary is equivalent:
01:37:13 <solrize> i also have to write a bunch of my own types with special instances
01:37:16 <maltem>     put (a,b)           = put a >> put b
01:37:30 <maltem> ah wait, wrong line
01:37:40 <maltem>     get                 = liftM2 (,) get get
01:37:49 <maltem>     get                 = liftM3 (,,) get get get
01:37:51 <maltem> and so on
01:37:51 <solrize> yeah, i just am not so keen on relying on undocumented implementation details
01:38:27 <maltem> ah, but there is no other reasonable semantics for those instances
01:38:46 <solrize> what's reasonable?  it could use DER or something
01:39:00 <solrize> put (a,b) could be put b >> put a
01:39:33 <maltem> right, and put (a,b,c,d) could be put b >> put d >> put c >> put a
01:39:38 <solrize> right
01:39:46 <solrize> vax byte order or something like that ;)
01:40:17 <solrize> liftM2 (,) get get
01:40:23 <solrize> how does it know what order to do those gets in?
01:40:37 <maltem> @src liftM2
01:40:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:40:48 <solrize> ah, ok
01:41:14 <maltem> Well I see what your worries are
01:42:03 <maltem> But personally, I'd prefer the elegance of just using Binary, and hope no one will change its behaviour
01:42:54 <solrize> it's version 0.4.2 which is sort of an advert that the behaviour might change
01:43:32 <solrize> i mean the interface already changed between 0.4.1 and 0.4.2 (not that particular operation)
01:44:04 <solrize> can i alias LBinary to Binary somehow?
01:44:30 <solrize> then i can change it later if i have to, without having to go change all my instances
01:44:41 <EvilTerran> "type"?
01:44:51 <solrize> LBinary and Binary are classes, not types
01:44:56 <EvilTerran> ohh
01:45:15 <EvilTerran> then no. short of writing an instance One => T'Other
01:45:25 <EvilTerran> class aliases are still on the to-do list
01:46:02 <solrize> instance (Binary a) => LBinary a where get :: Get t
01:46:23 <solrize> and then there's a way to make a default implementation of get?  sort of like inheritance in OO
01:46:43 <maltem> where get = get, not were get :: Get t
01:46:58 <solrize> oops i meant class, not instance
01:46:59 <EvilTerran> that'd need undecidable instances
01:47:17 <EvilTerran> (that instance)
01:47:28 <EvilTerran> and a default implementation would need overlapping instancesw
01:47:32 <maltem> bah, whenever I get into tricky class things, I'll step onto that one
01:47:35 <solrize> class (Binary a) => LBinary a where get :: Get t
01:48:25 <Saizan> that's more reasonable, and yes, you can add a default implementation get = Data.Binary.get
01:48:54 <solrize> cool, that's what i think i'll do
01:49:12 <solrize> then i can write my own custom instances of more complicated types without worrying about their conflicting with data.binary
01:49:14 <Saizan> you've to declare which types are instance of LBinary "manually"
01:49:15 <EvilTerran> well, yes, there's that, but that sort of default implementation only kicks in if you just go "instance LBinary Foo where {}" or something
01:49:40 <EvilTerran> unless you "instance Binary a => LBinary a" too
01:49:53 <solrize> ic, that's not too bad though
01:50:18 <maltem> Let's see if I understand instance constraints right now
01:50:20 <EvilTerran> that's an undecidable instance, and will overlap with any other instances
01:50:24 <Saizan> that forces you to declare instanced of Binary for all the types you want ot use with LBinary though
01:50:51 <solrize> oh, ugh.
01:50:51 <maltem> thanks, Saizan, was just going to ask about that :)
01:51:42 <oldsalt> TomMD, 2.1.0 works fine, thank you
01:51:44 <solrize> it looks like Binary's implementation is smarter than my naive LBinary
01:51:46 <Saizan> and then add instance LBinary a => Binary a, which with instance Binary a => LBinary a makes the compiler loop!
01:51:53 <solrize> heh
01:52:06 <EvilTerran> Saizan, yes, hence the undecidable instances
01:54:13 <solrize> where are you looking at the Data.Binary source?  downloaded it?
01:54:41 <maltem> Hmm, what we really need is a type checker that decides whether our instances are decidable or not
01:54:48 <solrize> haha
01:55:13 <Saizan> yeah, an oracle for the halting problem can be handy :)
01:59:44 <maltem> On the more realistic hand, have there been any efforts to relax the Haskell 98 instance rules in some way without allowing for undecidable instances?
02:02:04 <sjanssen> maltem: sure, see the FlexibleInstances extension in GHC
02:02:26 <Fallen_Demon> Hi people, are there any interfaces between haskell and java?
02:05:02 <EvilTerran> maltem, sjanssen: beyond that, i can envisage something like a deeper analysis (analysing all instances together instead of just each decleration independently) that allows proper recursive instances
02:05:43 <EvilTerran> StructurallyRecursiveInstances or something
02:06:50 <sjanssen> sure.  FlexibleInstances actually aren't that flexible
02:11:43 <maltem> ah ok, I begin to get the connection between all that instances stuff in ghc :)
02:12:54 <Fallen_Demon> Does anyone know of an interface for java and haskell?
02:13:41 <sjanssen> I suppose one nice thing about the way instances are handled now is that the user only has to look at one instance to see whether it is valid
02:14:23 <Staz> "C[[output 1; output 2]] () (\s.stop) s"  <-- what would the continuation be if I went to evaluate 'output 1' ?
02:14:51 <Staz> (\s.stop) is the continuation that causes the program to stop.
02:15:03 <sjanssen> Fallen_Demon: http://haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages#Java
02:15:05 <lambdabot> Title: Applications and libraries/Interfacing other languages - HaskellWiki, http://tinyurl.com/69upkq
02:15:09 <ski_> Staz : the `()' and `s' arguments being ?
02:15:16 <EvilTerran> Fallen_Demon, if no-one answers, it means no-one knows. especially at this hour, when the channel's moving quite slowly, no-one's gonna miss anything, so there's really no need to repeat yourself
02:15:23 <Staz> () is an empty environment (all programs start like that)
02:15:25 <Staz> s is the store
02:15:35 <EvilTerran> we'll get to you eventually :)
02:15:46 <Staz> which consists of a single location which has the program input as its contents.
02:15:53 <Fallen_Demon> EvilTerran: Oh, ok, I thought I didn't have voice
02:16:22 <sjanssen> Fallen_Demon: I'm not sure whether any of those are maintained or actually work well, but those are the only ones the community at large seems to know about
02:16:28 <EvilTerran> "* Channel #haskell modes: +tnc" <- it's not +m, you don't need voice :)
02:16:42 <Fallen_Demon> fair enough :)
02:16:55 <ski_> Staz : possibly `C[[output 1; output 2]] () (\s.stop) s  =  C[[output 1]] () (\s. C[[output 2]] () (\s. stop) s) s' ?
02:17:23 <Staz> hmm I need to ponder that for a while.
02:17:26 <Staz> thanks ski_
02:21:36 <Saul_> I'm having a bit of a problem with my code for a website
02:22:02 <Staz> ski_ : On this handout I have been given it says C[C1;C2] r c = C[C1] r; C[C2] r; c
02:22:12 <Staz> what does that mean?
02:23:52 <Saul_> The website contains a bunch of entities that can be displayed as a webpage, but it also has some wiki-like pages like history, previous versions and edit forms
02:24:11 <Saul_> The problem I have is that there are different types of entitities
02:24:32 <Saul_> it's going to be a game related website, so I have (for now) the Game type and the Developer type
02:25:02 <Saul_> both of which display there page differently, handled with typeclasses
02:25:09 <Saul_> that is not where the problem is
02:25:48 <Saul_> the problem is that I need to choose the right type based on the url, so /game/gamename/ should show the page for the game "gamename"
02:26:36 <Saul_> However I don't seem to be able to write a dispatch function without a load of code duplication per type of entity I have (which I will expand later)
02:26:49 <ski_> Staz : hm .. `C[C1;C2] r c' before you had three extra arguments, not you just have two : `r',`c'
02:26:58 <Saul_> Does anyone know how to do that?
02:27:10 <Staz> ski_ : yeah it is very confusing!
02:27:29 <Staz> where did the store argument go
02:27:31 <ski_> Staz : possibly it's talking about different versions of the semantic function `C'
02:27:49 <Saizan> Saul_: i'm not usre but you might be interested in existential types
02:27:52 <maltem> Saul_: The obvious thing would be a sum type for things that can be rendered to a page, but that won't be really nice if there are really many types to choose from
02:28:09 <ski_> Staz : if you remove the `s' arguments from my guess, you get basically what you said afterwards, note
02:28:17 <Staz> ski_ : It's the semantic function for [C1;C2] in a language called 'SMALL'
02:29:03 <Saul_> Saizan: I know about existentials, but I still need to somehow force the right type, or Haskell won't know how to show the page
02:30:05 <Saul_> Saizan: I also need to select the data from a db with HSQL, so there I also need to know the type
02:30:27 <Staz> I wish I had the entire "The Denotional description of programming languages". I just have one chapter that gives me all the semantic functions but does not tell me how to interpret them whatsoever.
02:31:03 <Saul_> Saizan: Could you give me a small example of what you mean?
02:31:40 <Saizan> Saul_: uhm, how do you specify which page goes to which url?
02:31:47 <Saizan> s/page/handler/
02:32:37 <Saul_>  /game/name/ and /developer/name/
02:33:12 <Saul_> I already have a parser for it, so I have a datatype with the info
02:33:24 <Saul_> I'll paste it
02:33:27 <Saizan> no, i mean in the code
02:33:51 <Saizan> you are starting to write a dispatcher from scratch or do you already have one?
02:34:10 <hpaste>  Saul_ pasted "request datatype" at http://hpaste.org/8331
02:34:31 <Saul_> I'm starting from scratch
02:37:20 <Saul_> I do have some code, but it's not pretty
02:37:30 <Saul_> nor complete
02:39:10 * solrize used to program in ratfor, does that count?
02:40:00 <Saizan> in the end there must be a point where the decision of which type to use is explicit, i.e. where you create the response, but the code that handles the response doesn't have to care
02:41:01 <Saul_> Saizan: Yes, but I'm not sure how/where to do that in a nice way
02:42:43 <Saizan> you said that you've a lot of repetition, what is blocking you from abstracting it away?
02:44:00 <Saul_> I have to force the type everywhere, I'm not sure how to move it up
02:44:57 <Saizan> can you show the code?
02:45:13 <Saul_> Saizan, yes but it isn't done
02:45:20 <Saul_> I stopped before I got stuck
02:45:46 <hpaste>  Saul_ annotated "request datatype" with "dispatch function" at http://hpaste.org/8331#a1
02:46:02 <Saul_> Ok I'll be changing my password now :D
02:46:50 <Saizan> heh
02:47:32 <Saizan> so there for every category there's a different handler?
02:47:44 <Saizan> which returns a different type?
02:48:37 <Saul_> no the same type, IO Html
02:49:12 <Saizan> erm, so i don't see where's the problem
02:50:35 <Saizan> however, maybe you could look at how other haskell web-frameworks does this, even if yours is pretty specialized
02:50:50 <Saul_> I'll do that
02:50:51 <Saul_> thanks
03:02:49 <norbi> can anyone point me to a timer library? I need to execute some actions periodicaly...
03:03:20 <alech> Can I use 's/foo/bar/' with Text.Regex, and if yes, how?
03:05:38 <solrize> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html
03:05:39 <lambdabot> http://tinyurl.com/2ydz82
03:06:02 <solrize> alech you probably want to read the regex tutorial from realworldhaskell.org
03:06:57 <Cale> norbi: well, you can just forkIO a thread with a loop pretty easily...
03:06:58 <solrize> er, there's a sleep function too
03:07:04 <solrize> well you need to be able to sleep
03:07:15 <solrize> which appears to live in System.Posix or System.Win32 depending on your os
03:07:16 <Cale> Yeah, threadDelay will handle that
03:07:18 <Cale> no
03:07:24 <solrize> hmm ok
03:07:33 <Cale> Use threadDelay, you don't want to sleep the OS thread you're running in.
03:07:49 <solrize> ic.  in Control.Concurrent
03:08:19 <alech> solrize: hmmm, can you point me to a specific part? I've read a similar blog entry, but they only seem to talk about matching, not substitution
03:08:34 <norbi> threadDelay looks like just what I need good. Thanks!
03:11:06 <solrize> hmm  http://book.realworldhaskell.org/beta/glob.html  doesn't say a whole lot about substituting
03:11:09 <lambdabot> Title: ChapterÂ 10.Â Case study: regular expressions and file name matching
03:11:41 <alech> solrize: yes, that's what I was looking at ... :-/
03:11:42 <solrize> there's some way of getting the offsets and lengths of the matched substrings out, then you can cut and paste
03:11:45 <cedricshock> I'm getting the following error, and a bunch more. I assume the linker can't find Data.Map. What can I do to correct this?
03:11:47 <cedricshock> DefinitionTree.o: In function `s1mr_info':
03:11:47 <cedricshock> (.text+0x81): undefined reference to `containerszm0zi1zi0zi1_DataziMap_singleton_closure'
03:11:54 <alech> solrize: doesn't sound too elegant ...
03:12:29 <solrize> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/  this is the one i was thinking of
03:12:30 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
03:13:08 <cedricshock> I think there was some magic argument to GHC that makes it actually compile and link... can't remember.
03:13:12 <alech> solrize: yes, that's the one I read earlier, doesn't say anything about substitution, though ...
03:13:30 <solrize> i did something with it once involving some hand juggling and it wasn't too bad
03:15:03 <solrize> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg11442.html
03:15:04 <lambdabot> Title: ANN: regex-tdfa 0.56, http://tinyurl.com/6zloey
03:26:27 <maltem> cedricshock: --make ?
03:30:24 <solrize> let's say (simplified version of what i'm really doing) that i have two int32 vectors in the same disk file (starting at different offsets in the file) and i want to compute the inner product by reading the file segments as lazy bytestrings.  is the simplest way to open the file twice and use take/drop on each one to get the segment?
03:31:27 <solrize> i guess mmap would be simpler but the file is too big
03:33:18 <gwern> wait, I thought mmap was the right thing to use on really really large files?
03:33:40 <solrize> no it's limited to the machine's address space, 4gb for a 32 bit machine
03:34:55 * gwern chortles a snooty 64-bit laugh at such a limitation
03:35:24 <solrize> we're actually using 64 bit hardware with 32 bit os's
03:36:56 * gwern chortles a snooty 64-bit-OS-and-hardware laugh at such a limitation
03:37:09 <Saizan> solrize: if you use drop you don't gain much by opening the file twice, maybe hSeek?
03:37:19 <gwern> (the '90s called, they want their OSes back)
03:37:50 <solrize> gwern we have a lot of 32 bit machines too (they use a lot less power) so we run the same os on everything
03:38:34 <cedricshock> maltem: Tried that; just got a .o file, not sure if it linked. Maybe I need to make a Main...
03:38:36 <solrize> saizan i don't see how to use hseek without basically reimplementing bytestring?
03:38:51 <solrize> the idea is that the hseek would have to jump back and forth between the two streams
03:39:09 <Saizan> solrize: bytestring has hGetContents
03:39:19 <solrize> oh hmm, i can call it twice?
03:39:25 <solrize> lemme check that
03:39:34 <Saizan> not on the same handle
03:39:36 <maltem> cedricshock: You won't get an executable without a Main module (containing main :: IO bla)
03:40:10 <solrize> ok, so i'm back to opening the file twice but i guess that's really not too obnoxious
03:40:57 <Saizan> but if you opening the file twice and then just use ByteString.drop on the second to get to the right offset you still have to read all the first segment (and maybe GCing it) before you get to the second array
03:41:39 <Saizan> instead with hSeek you can start reading the second array without traversing all of the first
03:41:55 <hpaste>  staz pasted "Driving me nuts" at http://hpaste.org/8332
03:41:55 <solrize> bytestring.drop reads the first segment???   hmm
03:42:16 <Staz> Using the paste above, what are the steps involved in evaluating something like P[program output 5; output 9] () ?
03:42:24 <solrize> what's O(n\c) mean?
03:42:47 <Saizan> n is the number of bytes, c is the chunk size
03:42:52 <solrize> and where's hseek?
03:42:55 <solrize> what's \ ?
03:42:58 <Saizan> in System.IO
03:43:13 <Saizan> \ is a type for / i think, division
03:43:19 <Saizan> *typo
03:43:23 <solrize> hmm
03:43:29 <Staz> \ is lamba
03:43:48 <Saizan> it's not like ByteString.drop knows that you're reading that ByteString from a file..
03:44:00 <Staz> err lambda
03:44:06 <Saizan> so it has to traverse the spine
03:44:07 <solrize> it doesn't know?
03:44:28 <solrize> hmm ok
03:44:44 <Saizan> no, a lazy ByteString is only a list of byte arrays
03:45:10 <Saizan> i.e. a list of strict ones
03:45:16 <solrize> aha, i use hseek then hgetcontents
03:45:44 <solrize> with two handles on the same file
03:46:32 <solrize> i've had this conversation before but i wish there was a way to control the i/o chunk size
03:47:53 <solrize> maybe i can switch between strict and lazy bytestrings depending on the size of the vectors
03:48:17 <solrize> haskell gets less elegant once you start having to do stuff like this
03:50:01 <solrize> anyway thanks
03:51:17 <Staz> Is there a semantics IRC channel by any chance? :)
03:51:48 <Staz> or any other channel that would be appropriate to ask my question.
03:52:20 <solrize> this is a good channel it's just a dead time of night
03:54:24 <smtms> night? what night?
04:01:46 <EvilTerran> Staz, #oasis, maybe?
04:01:57 <EvilTerran> #oasis           32      Zenny channel about programming languages where *semantics* is the issue and *syntax* is ignored, where both concepts and pragmatics are of interest | Logging of this channel is only allowed if expressly granted by the channel's committe | Wiki @ http://li23-146.members.linode.com/oasis/
04:01:57 <lambdabot> Title: FrontPage - Oasis Wiki
04:03:29 <Staz> sounds perfect!
04:03:34 <Staz> thanks EvilTerran
04:04:05 <ndm> @seen nomilo
04:04:05 <lambdabot> I haven't seen nomilo.
04:04:33 <ndm> David Waern around?
04:06:59 <EvilTerran> :)
04:08:09 * gwern adds appropriate show and simplereflect stuff to mueval
04:08:15 <gwern> man, mueval is going so well
04:08:18 <gwern> I hope people like it
04:08:29 <Saizan> what is it?
04:09:04 <gwern> Saizan: think the > part of lambabot, but cleaned up, using the GHC API, and more secure
04:09:14 <gwern> also, it will be installable by mortals
04:09:45 <Saizan> no hs-plugins?
04:10:13 <gwern> I intend to release .2 today; all that's left on my list is adding in support for changing user, and actually cabalizing it. (if dcoutts sets up a repo in time, I'll also have a public darcs repo for't)
04:10:17 <gwern> Saizan: right!
04:10:37 <Staz> heh #oasis is asleep too
04:10:46 <gwern> *well, maybe not dcoutts but whomever handles such requests
04:11:15 <hpaste>  gwern pasted "mueval example output" at http://hpaste.org/8333
04:11:30 <m4DN3ss> How can i use regex in filter function? for example filter (![A-Z]) ["abcXsdzWEE"] ?
04:11:36 <gwern> Saizan: ^ if you're interested in how it looks
04:13:04 <ndm> > filter (`notElem` ['A'..'Z']) "abcXsdzWEE"
04:13:06 <lambdabot>  "abcsdz"
04:13:22 <ndm> m4DN3ss: ^^^
04:13:24 <m4DN3ss> do i need to implement library Text.Regex.Posix ?
04:13:35 <ndm> no regex's there
04:13:45 <m4DN3ss> ndm: TNX ! ^^
04:14:02 <Saizan> gwern: cool
04:14:38 <gwern> (I'm proud of it. I have very few substantial haskell programs to my name.)
04:15:59 <sieni> btw, is ['A'..'Z'] required to produce
04:16:15 <sieni> > ['A'..'Z']
04:16:17 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
04:16:49 <sieni> the usual alphabet are contiguous in ascii, but not e.g. in ebcdic
04:17:04 <EvilTerran> ?hoogle isUpper
04:17:05 <lambdabot> Data.Char.isUpper :: Char -> Bool
04:17:08 <EvilTerran> use that :)
04:17:17 <EvilTerran> should work for unicode as well, iirc
04:17:31 <EvilTerran> (although reading in unicode text is a whole other ballgame)
04:18:00 <EvilTerran> (@ m4DN3ss, sieni)
04:18:41 <sieni> yes, of course
04:18:43 <EvilTerran> > filter (not.isUpper) "abcXsdzWEE"
04:18:44 <lambdabot>  "abcsdz"
04:19:15 <m4DN3ss> hm...
04:19:35 <EvilTerran> @docs Data.Char
04:19:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
04:19:46 <EvilTerran> lots of useful stuff like that in there
04:19:56 <sieni> people just tried to compile python on z/os and it had such insanities as if (foo >= 'a' && foo <='z') bar();
04:20:10 <gwern> @hoogle notElem
04:20:11 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
04:20:11 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
04:20:11 <lambdabot> Data.Foldable.notElem :: (Foldable t, Eq a) => a -> t a -> Bool
04:20:28 <sieni> but perhaps haskell requires ascii behaviour or something
04:20:44 <EvilTerran> m4DN3ss, if and when you need more sophisticated text processing than mere character classes, Parsec is the de facto standard parsing tool
04:20:45 <EvilTerran> ?where parsec
04:20:45 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
04:21:12 <hpaste>  solrize pasted "how do i actually get the number out?" at http://hpaste.org/8334
04:21:29 <m4DN3ss> ye i do but first i need to figure this out :D
04:21:58 <EvilTerran> parsing without a parser combinator library or parser generator is a bit fiddly, but a heck of a lot easier in haskell than most languages
04:21:59 <solrize> oh i see
04:22:21 <solrize> no i don't
04:25:12 <maltem> sieni: Haskell requires Unicode ordering
04:25:44 <sieni> maltem: yeah, I remembered something like that
04:25:56 <EvilTerran> but you should still use isUpper etc when possible
04:26:40 <sieni> EvilTerran: it depends on what you want
04:26:58 <EvilTerran> if there's a function in Data.Char that does what you want, you probably want to use it
04:27:24 <EvilTerran> (`elem` ['a'..'z']) would be slower than isLower, and miss out accented characters etc
04:28:28 <sieni> well, Ã„ is an uppercase character that's widely used in Finnish, but not between A and Z (neither in ascii nor finnish collation order)
04:29:22 <EvilTerran> if you *really* mean (`elem` ['A'..'Z']), sure, write that. but usually you'd mean isUpper :)
04:29:47 <sieni> probably :-)
04:29:53 <EvilTerran> actually, don't write that anyway, write (inRange ('A','Z'))
04:30:03 <sieni> better even :-)
04:30:11 <EvilTerran> that'll be two comparisons instead of potentially 26 :)
04:31:09 <Deewiant> there should be a rewrite rule, (flip elem . enumFromTo) = (curry inRange)
04:31:53 <EvilTerran> might not be equivalent
04:31:58 <EvilTerran> should be, might not
04:36:47 <Deewiant> example?
04:36:58 <gwern> hm. what is in the libraries for changing the user of a process?
04:37:05 <gwern> I see setUID, but I'm not sure that's what I want
04:37:49 <gwern> Deewiant: well, the idea is that programs like tor often have a tor user, so they can't damage anything of root or the usual user. that's the idea
04:38:38 <Deewiant> my message came well before yours, I wasn't asking you but that's interesting anyway :-)
04:39:06 <EvilTerran> Deewiant, if the instance of Enum overrides enumFromTo and inRange, there could be problems
04:39:09 <Deewiant> and I can't help you
04:39:14 <gwern> oh. I guess lag meant I saw my message arrive first
04:39:21 <EvilTerran> > inRange (0,1) 0.5
04:39:22 <lambdabot>  Add a type signature
04:39:29 <EvilTerran> > inRange (0,1) (0.5 :: Float)
04:39:30 <lambdabot>   add an instance declaration for (Ix Float)
04:39:30 <lambdabot>     In the expression: inRange (...
04:39:33 <EvilTerran> er
04:39:36 <EvilTerran> ?type inRange
04:39:37 <Deewiant> ?ty inRange
04:39:38 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:39:39 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:39:40 <EvilTerran> doh
04:39:50 <Deewiant> well that explains it
04:39:53 <maltem> floating-point Ix's could be fun
04:40:14 <EvilTerran> maltem, well, i guess that's what Data.Map's good for
04:40:19 <gwern> yeah. setUID doesn't take a password, just an int, so I guess that means only root can use it
04:40:21 <EvilTerran> (that kinda thing)
04:41:02 <maltem> EvilTerran: I meant the sarcastic side of fun, when you struggle with equality on floating-point numbers
04:41:36 <gwern> @pl \e opts -> opts { expression = e}
04:41:36 <lambdabot> (line 1, column 17):
04:41:36 <lambdabot> unexpected "{"
04:41:36 <lambdabot> expecting variable, "(", operator or end of input
04:41:42 <EvilTerran> that's my favourite kind of fun!
04:41:54 <EvilTerran> gwern, no pointsfree form for record update, i'm afraid
04:42:06 <gwern> @unpl \e opts -> opts {expression = e}
04:42:06 <lambdabot> \ e opts -> opts{expression = e}
04:42:19 <gwern> bah humbug
04:43:40 <EvilTerran> unless you're using Oleg's extensible records :P
04:44:08 <Heffalump> that is as short as it gets
04:49:35 <m4DN3ss> hom
04:49:55 <gwern> fair enough. well, I can't figure out how to change users, so I guess I'll finish up and do a release
04:50:35 <m4DN3ss> if i want to use 'A'..'Z' and 'a'..'z' then i would miss acented characters... can i combine isLetter in filter fucntion?
04:50:49 <sieni> of course
04:51:08 <sieni> @t isLetter
04:51:08 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:51:17 <sieni> @type isLetter
04:51:19 <lambdabot> Char -> Bool
04:51:33 <sieni> > filter isLetter "af8usa98vd34"
04:51:34 <lambdabot>  "afusavd"
04:51:35 <m4DN3ss> but the line filter (`isLetter`) "Abac#"$sdfs" is not woorking, i want to return string not bool
04:51:49 <m4DN3ss> oh
04:51:56 <m4DN3ss> was using ti wrong
04:52:22 <sieni> backticks are for making a regular function infix
04:52:43 <m4DN3ss> how can i make "isLetter" not count \t, as tabulator?
04:52:59 <ivanm> isLetter x || x == '
04:53:04 <ivanm> * x == '\t' ?
04:53:06 <m4DN3ss> for eg. filter isLetter "asdf$#$     dfs"
04:53:34 <ivanm> > filter (\ x -> isLetter x || x == '\t') "asdf$#$     dfs"
04:53:35 <lambdabot>  "asdfdfs"
04:53:47 <m4DN3ss> aha, interesting
04:54:04 <ivanm> hmmm looks like that's just 4 spaces rather than a tab character there...
04:54:07 <olsner_> > filter (\ x -> isLetter x || x == '\t') "asdf$#$\tdfs"
04:54:09 <lambdabot>  "asdf\tdfs"
04:54:27 <ivanm> olsner_: sure, insert a literal '\t' in there :p
04:54:33 <ivanm> cheater! ;-)
04:54:54 <m4DN3ss> want to work with tabulator not \t, says eror for \t
04:54:54 <olsner_> :)
04:55:25 <m4DN3ss> like lexical error in string/character literal at character \t oo?
04:55:31 <ivanm> m4DN3ss: what do you mean by 'tabulator' ?
04:56:24 <m4DN3ss> the big white space when u press TAB (in other words \t)
04:56:57 <ivanm> m4DN3ss: which is '\t'
04:57:13 <ivanm> in your example above, you had 4 spaces
04:57:18 <m4DN3ss> yes
04:57:19 <ivanm> that isn't a literal tab character...
04:57:21 <Lycurgus> that's just "tab"
04:57:28 <ivanm> in which case, you need to do string matching
04:57:32 <Lycurgus> tabulator is another word for calculator
04:57:42 <ivanm> you're using TAB as a key, not as a character
04:57:48 <m4DN3ss> yes
04:58:11 <ivanm> what you _could_ do is somehow first convert all spaces to tabs, and _then_ fun the filter, then convert tabs back to spaces again
04:58:13 <m4DN3ss> it's same as '\t' but i says eror cuz isLetter returns bool fo char
04:58:15 <Lycurgus> (actually a specific kind using mechanical or puched card technology)
04:58:27 <m4DN3ss> so it loks differenly the '\' and 't'
04:58:33 <ivanm> m4DN3ss: nope, it'c completely different
04:58:53 <ivanm> '\t' is a charachter... "    " is a 4-character string
04:59:08 <ivanm> something that checks for characters can't also check for strings
05:00:43 <hpaste>  solrize annotated "how do i actually get the number out?" with "is there a way to get at the type variable a in getFrom?" at http://hpaste.org/8334#a1
05:01:36 <ivanm> besides, how many spaces is a tab equivalent to? that is probably either the 2nd or 3rd biggest computing war around (emacs vs vi is the largest, of course) :p
05:02:56 <m4DN3ss> tab is 4 spaces i think
05:03:06 <ivanm> no it's not
05:03:09 <ivanm> that is a common definition
05:03:19 <ivanm> but not always... linux kernel uses 8 spaces IIRC
05:03:24 <ivanm> some code uses 2 spaces
05:03:32 <m4DN3ss> haskkell uses 4?
05:03:42 <ivanm> m4DN3ss: haskell uses whatever your editor uses
05:03:47 <ivanm> AFAIK, anyway
05:04:01 <m4DN3ss> oh
05:04:06 <m4DN3ss> tought it was 4
05:04:08 <ivanm> can someone more familiar with the report comment on this?
05:04:53 <Deewiant> IMO a tab is "indent one level" and has no direct mapping to spaces
05:05:12 <ivanm> *nod*
05:05:26 <ivanm> and mixing tabs with spaces is of course a Bad Idea (R)
05:05:27 <ivanm> :p
05:05:50 <ivanm> Deewiant: though surely there's a visual representation used?
05:06:10 <Deewiant> and that's up to the editor
05:06:17 <Deewiant> it can be from 1 to 1 million spaces
05:06:37 <maltem> solrize: I think you'd need Scoped Type Variables to put the 'a' there
05:06:52 <solrize> is that a ghc option?
05:07:03 <solrize> i took out the annotation altogether and that seemed to work though it hadn't worked earlier
05:07:07 <maltem> yes, a language extension
05:07:25 <maltem> right, removing the annotation is the easier solution :)
05:07:46 <maltem> with scoped type variables you'd also need a forall somewhere, to bring a into scope
05:07:52 <solrize> but scoped type variables do sound useful for other purposes
05:07:54 <solrize> hmm
05:08:10 <solrize> well i wanted to bring the a from the function type signature into the scope
05:08:17 <Saizan> haskell considers tab 8 spaces.
05:08:50 <ivanm> m4DN3ss: well there you have it
05:08:53 <Saul_> Saizan: I have my dispatching working now, it's not very pretty, but there is no duplicate code
05:08:58 <hpaste>  solrize annotated "how do i actually get the number out?" with "this actually looks dangerous" at http://hpaste.org/8334#a2
05:09:03 <Saul_> Saizan: Thanks again for your help
05:09:06 <ivanm> but still, it's issues like that that make many people (including me) dislike the tab character
05:09:23 <Saizan> for the sake of layout i mean, in a String literal you've to use \t
05:09:37 <ivanm> yes, which is what m4DN3ss was talking about IIRC...
05:09:56 <ivanm> and then the printing of it is up to your editor/terminal/etc.
05:10:12 <ivanm> s/printing of it/printing of the string literal/
05:10:14 <Saizan> Saul_: np :)
05:10:21 <maltem> solrize: dangerous?
05:10:31 <solrize> yeah, what happens if i use getFrom on the same handle twice?
05:10:33 <ivanm> that code is a hardened criminal! :p
05:10:54 <solrize> i can't open the file from inside getFrom because it would never get closed
05:11:16 <maltem> That's what you get for using lazy hGetContents :)
05:11:21 <Saizan> solrize: hGetContents closes the handle for you.
05:11:25 <solrize> i guess i can use strict bytestrings but that limits the flexibility
05:11:35 <Saizan> solrize: when it reaches EOF
05:11:53 <solrize> i don't expect to ever reach EOF, i want to use this to read a few megabytes out of the middle of a multi-gigabyte file
05:13:14 <Saizan> ok, so yeah, it is a bit dangerous, in fact hGetContents is implemented with lazy IO :)
05:14:01 <solrize> yeah, i think i understand the sentinment that lazy IO is a crock
05:14:19 <solrize> but it makes stuff like this easier if dangerous
05:14:31 <solrize> could uniqueness types help with this?
05:15:12 <maltem> you could try and close the handle after forcing the result of the read, maybe chiming in some CPS
05:15:40 <Saizan> i don't think so, you really want those side effects to be delayed until you force the content if the file is so large i guess
05:16:11 <solrize> i think if i use strict bytestrings i'll survive, it just doesn't seem like the haskell spirit
05:16:33 <solrize> the file is very large but the parts of it that i actually want to read are manageable (a few MB) on a big machine
05:16:41 <vixey> haskell spirit ~ crush kill and destroy
05:17:02 <solrize> hee
05:17:42 <gwern> ok everyone. Mueval is up! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
05:18:08 <solrize> neat
05:18:12 <vixey> cool
05:18:19 <gwern> give it a try plskthnxbai
05:18:36 <solrize> lolz
05:18:42 <Saizan> somwthing like withFile :: FilePath -> (ByteString -> IO a) -> IO a might be a safer interface, suggesting that the handle will be closed when the action has executed
05:18:52 <gwern> (specifically you want 0.21, I forgot a runtime depency)
05:19:13 <solrize> saizan good idea
05:19:42 <ivanm> gwern: what's mueval meant to be?
05:20:29 <solrize> i just pasted that suggestion into the source file, i think i'll stop soon and mess with it more during the weekend
05:20:35 <gwern> ivanm: you know how lambdabot does > stuff?
05:20:59 <gwern> ivanm: this is the same thing
05:21:11 <ivanm> ooohhhh..... in what?
05:21:35 <solrize> saizan that re-opens the file on every one of those actions, which i guess is ok for megabyte operations but sounds painful for small operations
05:22:12 <solrize> i think the real answer is 64 bit os's and mmap
05:22:55 <gwern> ivanm: well, I'm composing the ANN now
05:23:11 <ivanm> OK, I'll wait for that then :p
05:23:16 <ivanm> so you're jumping your own gun?
05:30:21 <gwern> ok, it's sent
05:30:28 <gwern> ivanm: read alla 'bout it
05:31:14 <m4DN3ss> why is this not working: let space y = filter (\x -> isSpace x) y
05:31:32 <m4DN3ss> it gives me error "Not in scope: 'isSpace'
05:31:51 <RayNbow> gwern, "Mueval is POSIX-only" <-- how the hell am I supposed to give it a try? :p
05:32:01 <gwern> maybe you need Data.Char?
05:32:08 <gwern> @hoogle isSpace
05:32:09 <lambdabot> Data.Char.isSpace :: Char -> Bool
05:32:09 <lambdabot> Data.ByteString.Internal.isSpaceWord8 :: Word8 -> Bool
05:32:24 <vixey> (==' ')
05:32:26 <vixey> isSpace
05:32:28 <m4DN3ss> oh
05:32:36 <m4DN3ss> need to import library
05:32:45 <gwern> RayNbow: I dunno, tell windows to get off its ass and add rlimits/tell the haskell library hackers to add support for windows rlimits?
05:33:11 <RayNbow> :p
05:33:12 <gwern> ivanm: http://www.haskell.org/pipermail/haskell-cafe/2008-June/044233.html
05:33:15 <gwern> ^ mueval ANN
05:33:18 <lambdabot> Title: [Haskell-cafe] ANN: Mueval 0.21, http://tinyurl.com/68qcxx
05:34:22 * gwern covered both my bases there :)
05:34:30 <ivanm> thanks gwern
05:34:56 <gwern> (altho I omitted the third base of rlimits existing & supporting but me ignorant)
05:35:06 <ivanm> wow, of all the possible code samples you could have chosen... you chose _that_? :s
05:35:37 <ivanm> gwern: main problem I see with mueval: if you're running it off your own machine, why not just run ghci?
05:36:17 <vixey> ivanm: what about something like lambdabot
05:36:19 <ivanm> ahhhh, sandboxing
05:36:35 <gwern> it was the first one I saw scrolling up...
05:36:35 <gwern> ivanm: suppose you are like mauke, and you're written preflex. how do you add > functionality?
05:36:41 <ivanm> vixey: yes, but atm looks like mueval is meant to be run off your own machine
05:36:44 <ivanm> gwern: true
05:36:53 <ivanm> duh....
05:36:54 <gwern> with mueval, you simply do 'printToIRC $ runFile "/usr/bin/mueval" ircInput'
05:37:21 <gwern> but try it witjout mueval, using runFile "ghci" ircInput, and I'll just go > let x = readFile "/etc/passwd" in x'
05:37:30 <gwern> since you can show IO String...
05:37:50 <vixey> /etc/passwd doesn't have anything in it though..
05:38:36 <gwern> right. the interface itself is not much of an improvement over ghci or ghc -e, truthfully. it's the safety thing which is mueval's nice
05:39:17 <gwern> ivanm: and even better, now one could in theory go into lambdabot and rip out several modules and replace them with a dependency on mueval and a oneliner, as is true of mauke's preflex and whatever other haskell irc bots exist
05:39:17 <gwern> (and who knows whether website people might like it)
05:39:25 <solrize> hmm, i actually have an application for it
05:39:39 <ivanm> solrize: oh? what for?
05:39:41 <solrize> can it compile the code instead of interpreting it?
05:39:44 <ivanm> gwern: how long did it take you?
05:40:00 <solrize> ivanm, user scriptable server side template system on a web site
05:40:07 <gwern> ivanm: well, what would a mueval-meant-to-be-run-off-someone-else's-machine look like? an email interface? I dunno
05:40:53 <ivanm> gwern: no, I just originally thought that it sounded useless because you needed ghc to build it, and then you only run it off your machine anyway so you might as well run ghc
05:41:05 <ivanm> I didn't think of the external usage factor
05:41:51 <solrize> could also be nice for a browser extension if people couth up enough to want to run haskell applets instead of java or js :)
05:41:54 <gwern> fine, "/home/vixey/taxreturn.txt"
05:43:17 <ivanm> solrize: you mean apart from that javascript backend to yhc? :P
05:44:39 <solrize> heh
05:45:17 <gwern> ivanm: 3 or 4 nights
05:45:42 <gwern> ivanm: well, it's statically linked, so it's good for binary distros - gentoo users would still need to have ghc installed, though
05:45:49 <ivanm> heh
05:45:59 <ivanm> so it's a mini-interpreter?
05:46:52 <gwern> solrize: I'm not actually sure whether using the GHC API means it's compiled or interpreted, but iirc, there's not much different in the GHC model when you print the results immediately and end the program
05:46:53 <gwern> ivanm: if 17 or 18 megabytes counts as mini...
05:46:58 <ivanm> lol
05:47:11 <Baughn> gwern: These days, it does
05:47:15 <solrize> gwern, it's a pure interpreter, no way to compile?
05:47:21 <ivanm> but realistically, AFAICT the main usage of it would be to utilise it from within projects, am I right?
05:47:28 <ivanm> otherwise you could just use ghci, hugs, etc.
05:47:43 * gwern hopes peoples' cabals will strip the binary to get it down from 28 megs
05:48:07 <ivanm> lol
05:49:02 <ivanm> what would be haskell's 6-word summary in the spirit of these? http://www.michaelnygard.com/blog/2008/06/six_word_methods.html
05:49:04 <lambdabot> Title: Wide Awake Developers: Six Word Methods
05:49:22 <ivanm> we have to at least do better than Ocaml's: "No, try meta-meta-meta-programming." ;-)
05:50:17 <gwern> ivanm: reddit has it. 'haskell: category theory versus software engineering. theory wins'
05:50:19 <gwern> or something like that
05:50:32 <olsner_> "Do it in the type system."?
05:50:44 <ivanm> hmmm... I _thought_ I got that link off reddit, but now can't find it again :s
05:51:40 <ivanm> olsner_: lol
05:51:50 <solrize> gateway drug to even more weirdness
05:52:01 <ivanm> gwern: isn't that 7 words?
05:52:33 <solrize> hmm there's two mmap modules, one by dons and one by someone in poland
05:53:14 <ivanm> ahhh, wait, I found it... the title is different and so is the URL :s
05:53:24 <solrize> oh on gmail
05:53:36 <gwern> ivanm: *OR SOMETHING*
05:54:42 <ivanm> hmmm?
05:55:20 <ivanm> ahhh, wait
05:55:29 * gwern downloads my email, waiting for the rapturously adulatory emails in reply to my ANN
05:55:42 <ivanm> yeah, it was actually "pragmatism versus category theory. pragmatism loses"
05:56:10 <mapreduce> Is Liskell dead?  I notice that its copyright notice is only up to 2007, and that its site has things like "check back in a few weeks", written in 2007.
05:56:14 <gwern> hm. perhaps they are all queued up due to their overwhelming volume. it's ok, gmail, I don't expect you to perform brilliantly under such stress
05:56:29 <gwern> ivanm: ah, pragmatism is one shorter than software engineering
05:56:44 <gwern> I think my version is less negative, though
05:56:55 <ivanm> true
05:57:08 <ivanm> "category theory versus engineering. theory wins"?
05:57:23 <gwern> maybe 'haskell: Side-effects vesus category theory. Theory wins."
05:57:45 <ivanm> with side-effects counting as one word?
05:57:49 <gwern> mapreduce: I haven't heard any announcements of its demise
05:57:52 <gwern> hm. actually, I rather like my side-effects version
05:58:00 <gwern> mapreduce: does it not work? try emailing the author maybe. sometimes lakc of announcements is due just to forgetfulness
05:58:18 <gwern> ivanm: of course. after all, it's not "side effects", but 'side-effects'
05:58:28 <mapreduce> gwern: I haven't yet tried, largely because trying involves building it.
05:58:31 <ivanm> *sigh* I had a great usage of the term "side-effect" in a pun in a report I submitted yesterday, but I doubt my supervisors will get it :s
06:00:20 <ivanm> part of the project involved porting some code from haskell to fortran, and I said something like: "as a side-effect of doing so, some errors were found in the original program"
06:00:43 <gwern> oh man, liskell is a fork of ghc 6.6? no wonder no one uses it
06:01:10 <gwern> mapreduce: incidentally, what are you looking at, liskell.org?
06:01:20 <mapreduce> http://clemens.endorphin.org/liskell
06:01:21 <lambdabot> Title: 28 Liskell - clemens.endorphin.org
06:01:34 <RayNbow> > map fst $ unfoldr (\(a,b) -> Just ((a,b),(b,a+b))) (0,1)
06:01:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:01:38 * mapreduce notices the redirect at the top of the page.
06:02:00 <ivanm> gwern: it was an actual fork? by the sounds of it I thought it just used ghc, not forked it :s
06:02:16 <maltem> ivanm: You told people you had errors in your Haskell program?
06:02:30 <gwern> 'Liskell is a regular GHC branch and builds identical to a regular GHC branch:'
06:02:31 <ivanm> maltem: yes... logic errors, not coding errors
06:02:43 <gwern> @hoogle unfoldr
06:02:43 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:02:43 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
06:02:43 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
06:03:42 <gwern> hm. breakfast time
06:06:07 <MyCatVerbs> So anyway. Hoogle is TOTALLY broken. http://haskell.org/hoogle/?q=(Monad+m)+%3D>+m+a+->+(a+->+m+b)+->+m+b
06:06:07 <lambdabot> http://haskell.org/hoogle/?q=(Monad+m)+%3D>+m+a+->+(a+->+m+b)+->+m+b
06:06:58 <RayNbow> http://haskell.org/hoogle/?q=%28%3E%3E%3D%29
06:07:00 <lambdabot> Title: (>>=) - Hoogle
06:11:33 <MyCatVerbs> RayNbow: that's nice, but since Hoogle is meant to be a system for finding functions from their types, you'd expect it to find (>>=) given its type.
06:12:09 <MyCatVerbs> RayNbow: go copy (>>=)'s type off that result and paste it back in. Total failure.
06:13:05 <pejo> MyCatVerbs, ndm is working on hoogle4
06:13:15 <MyCatVerbs> RayNbow: Prelude.(>>=) comes up on page... four. It totally fails to match the "m b" term. >>
06:13:34 <MyCatVerbs> pejo: that's nice, but wasn't hoogle actually working at one point? This seems like a bit of a drastic regression.
06:20:28 <byorgey> MyCatVerbs: no, Hoogle has never handled type constructors well
06:41:18 <Igloo> What's a good word for the opposite of deprecated?
06:41:44 <SamB_XP_> what IS the opposite of deprecated?
06:42:03 <nornagon> supported?
06:43:29 <Igloo> I guess; I was hoping for something a bit more neutral, but that's better than anything I've come up with
06:44:38 <pejo> Looking in the dictionary the opposite would be a word that means "to express approval of".
06:46:08 <gwern> encouraged
06:46:28 <gwern> adulated, approbated, approved, enjoined, maybe
06:47:19 <gwern> enconiumated
06:48:54 <gwern> acclaim?
06:50:13 <augustss> offprecated :)  (like defence / offence)
06:50:38 <slarba> :))
06:51:27 <golubovsky> Hi, Dimitry is here
06:52:04 <golubovsky> I have a hackage-related question.
06:52:04 <gwern> greetings fellow human
06:52:15 <gwern> have you ingested many nutritious chemicals today?
06:52:42 <golubovsky> Is it possible to programmatically query Hackage for the latest version of a particular package which was successfully built?
06:53:17 <gwern> tagsoup + wget/curl would be my first instinct
06:53:20 <golubovsky> Tarfiles provided (like 00-index) are of no help: e. g. all three versions of BerkeleyDB failed to build, but they are mentioned in the index.
06:53:57 <golubovsky> gwern: OK, I would do the same, my primary question is if there is any avaliable query tool?
06:54:36 <Lord_Illidan> Hi guys
06:54:41 <golubovsky> Was HackageDB supposed (or expected) to become such a query-capable database?
06:54:59 <byorgey> hi Lord_Illidan
06:55:18 <Lord_Illidan> When writing a function, if you don't specify the parameter, how come it still works?
06:55:42 <gwern> so far as I know, no. bug reports and patches welcomed, as the hackage/cabal devs say
06:55:43 <Lord_Illidan> eg : testFunction = head . reverse . toWords
06:56:12 <Lord_Illidan> gives the same output as testFunction verse = (head . reverse . toWords) verse
06:57:09 <gwern> I don't even know if hackagedb is a real db at all
06:57:11 <byorgey> Lord_Illidan: this is called a 'points-free' style
06:57:25 <byorgey> Lord_Illidan: i.e. instead of saying how a function acts on some parameter, you just say what the function IS
06:57:32 <gwern> Lord_Illidan: it's called partial application, and it's because functions are first-class
06:57:57 <byorgey> Lord_Illidan: in this case, 'testFunction = head . reverse . toWords' means that testFunction IS the composition of head, reverse, and toWords
06:58:07 <jeffwheeler> You're essentially returning a function, which accepts 'verse'.
06:58:08 <gwern> (currying is closely related but technically different, in case you were wondering)
06:58:15 <Lord_Illidan> I see
06:58:15 <byorgey> Lord_Illidan: i.e. anywhere you see 'testFunction' you may replace it with 'head . reverse . toWords'
06:58:28 <Lord_Illidan> hmm, 10x
06:58:34 <gwern> Lord_Illidan: it's the same reason that 'map (+1) [1..10]' works, for example
06:58:44 <gwern> > map (+1) [1..10]
06:58:45 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
06:59:45 <Lord_Illidan> because + should have 2 operands, but the second is being provided by the map
07:00:18 <gwern> Lord_Illidan: it's nice, because it's so algebraic, ie, 'foo a = bar . baz $ a' == 'foo = bar . baz', 'x+1=x+1' == 'x=x'
07:01:59 <Lord_Illidan> so when applying partial application, haskell gives the function the type of the final function?
07:02:12 <Lord_Illidan> for instance, in my example : testFunction = head . reverse . toWords
07:02:31 <jeffwheeler> I cannot find many resources on Yi. Would the best place to learn just to go through the source, and my local documentation build?
07:02:32 <golubovsky> I'm wondering whether cabal-install does anything similar?
07:02:42 <Lord_Illidan> ah, I finally understood it all, 10x
07:03:03 <gwern> jeffwheeler: yes. there are tutorials and such, but the best are outdated, iirc
07:03:30 <gwern> jeffwheeler: also reading through yi-devel might help? good place to ask jyp questions anyway
07:03:33 <jeffwheeler> gwern: yeah, I chose to use the dev branch, 0.4; it really seems like the perfect editor for me.
07:04:02 <jeffwheeler> (I'd love to extend it, such that it's not just Haskell; its lexer support seems like it should handle that nicely.)
07:04:05 * gwern would know more, but I haven't been able to build yi in a coon's age because of the diamon dependency problem
07:04:40 <jeffwheeler> gwern: diamon? I didn't have any dependencies problems beyond just . . . having to install them. :P
07:04:49 <Saizan> diamond
07:05:14 <jeffwheeler> Oh. I installed some of the stuff through apt, so that may have kept me out of trouble.
07:06:43 <gwern> *diamond
07:07:12 <golubovsky> OK, I'd ask the same on mailing list. Thanks gwern.
07:07:14 <golubovsky> Bye
07:17:09 * sunnavy msg sunnavy
07:40:43 <dafra> > 1 + 1
07:40:44 <lambdabot>  2
07:41:06 <dafra> @source Data.List.map
07:41:06 <lambdabot> Data.List.map not available
07:41:17 <dafra> @source map
07:41:17 <lambdabot> map not available
07:41:19 <Saizan> @src map
07:41:20 <lambdabot> map _ []     = []
07:41:20 <lambdabot> map f (x:xs) = f x : map f xs
07:41:30 <Saizan> src /= source
07:41:33 <dafra> thanks Saizan
07:41:42 <dafra> what's source ?
07:41:47 <Deewiant> @help source
07:41:47 <lambdabot> source <lib>. Lookup the url of fptools libraries
07:42:03 <Saizan> @source Data.List
07:42:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
07:42:22 <Saizan> @source Data.Map
07:42:22 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
07:42:30 <Saizan> heh, hardcoded :)
07:42:32 <dafra> i wonder : what if i ask for an infinite list ?
07:42:47 <Deewiant> > [1..]
07:42:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:42:56 <Saizan> > map (+1) [1..]
07:42:57 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
07:43:14 <dafra> clever
07:44:06 <Japsu> laziness :)
07:44:38 <Japsu> > take 30 . (++ "...") $ show [1..]
07:44:39 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13"
07:44:49 <Japsu> oops,
07:44:53 <Japsu> > take 30 >>> (++ "...") $ show [1..]
07:44:55 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13..."
07:52:16 <david__> so guys, what is the best book to read on haskell?
07:53:58 <Saizan> "programming in haskell" has good reviews, or you could look at the online chapters of real world haskell
07:54:06 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml
07:54:12 <byorgey> david__: there's also the wikibook.
07:54:28 <byorgey> david__: but in the end, the answer is probably 'it depends'. =)  What is your background/what are you looking for?
07:55:39 <byorgey> monochrom: is that your website?
07:56:35 <monochrom> Yes.
07:56:59 <byorgey> ok, just trying to connect names with nicks. =)
08:03:41 * byorgey tries installing topkata
08:07:07 <RayNbow> <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml <-- this site punishes me for being lazy and using IE :p
08:09:02 <monochrom> haha :)
08:09:45 <SamB> RayNbow: so ... write a decent browser so you can use that
08:10:02 <kadir> can you suggest and IDE for haskell
08:10:03 <SamB> (I don't think there are any decent browsers yet, are there?)
08:10:06 <monochrom> lazy implies not going to write browser
08:10:15 <kadir> eclipsefp?
08:10:16 <SamB> kadir: does emacs count as an IDE?
08:10:32 <kadir> hmmm, maybe :)
08:10:32 <monochrom> I suppose eclipsefp is ok
08:10:56 * RayNbow just hit WinKey+R, firefox[enter] and pasted the URL to view monochrom's link :p
08:11:09 <kadir> what about hIDE?
08:11:30 <SamB> does it build?
08:11:31 <SamB> run?
08:11:34 <SamB> do anything useful?
08:11:58 <SamB> I think the last time I tried hIDE it was still largely mockup?
08:12:35 <monochrom> Interesting. You don't have an icon for Firefox?
08:13:17 <SamB> is that legal?
08:13:20 <kadir> hÄ±mm, i think i's in prototype mode
08:13:36 <SamB> oh
08:13:53 <RayNbow> <monochrom> Interesting. You don't have an icon for Firefox? <-- somewhere... :p
08:14:08 <RayNbow> but moving the mouse is slow :p
08:14:20 <Igloo> Hmm, not a good thing to see in a nofib result: +2248311.3%
08:14:30 <hpaste>  jeffwheeler pasted "Generating yi's haddock" at http://hpaste.org/8335
08:14:37 <jeffwheeler> I can't seem to get Yi to generate Haddock; that's the error I'm getting.
08:15:38 <jeffwheeler> The warning should be fine, and the installation is good too. That file begins with "module Yi.Buffer.Region" as far as I can tell, not "module Main" or anything like that.
08:17:15 <byorgey> kadir: emacs and vim still seem to be preferred for Haskell development (both have various modes that can be installed that make it quite nice).
08:17:21 <byorgey> kadir: there's also Leksah which is promising
08:17:43 <byorgey> but probably still not ready for primetime yet
08:19:11 <kadir> byorgey: Leksah, i'll look for, thanks
08:19:19 <byorgey> @where leksah
08:19:19 <lambdabot> I know nothing about leksah.
08:19:25 <byorgey> @go leksah
08:19:26 <lambdabot> No Result Found.
08:19:28 <byorgey> !
08:20:10 <byorgey> http://leksah.org/
08:20:11 <lambdabot> Title: Leksah - Haskell IDE in Haskell
08:20:16 <byorgey> @where+ leksah http://leksah.org/
08:20:16 <lambdabot> It is stored.
08:21:07 <jeffwheeler> Lambdabot should respond to private messages.
08:21:52 <RayNbow> byorgey: I rather type Haskell in notepad than in emacs or vim :p
08:21:56 <Saizan> ?where sourceview
08:21:56 <lambdabot> I know nothing about sourceview.
08:22:01 <Saizan> jeffwheeler: it does
08:22:04 <RayNbow> (but my experience with vim and emacs are near to zero :p)
08:22:12 <RayNbow> *is
08:22:21 <jeffwheeler> Saizan: hmm, it doesn't seem to be responding to anything I say to it.
08:22:36 <gubagem> vim > emacs (in my not so humble opinion)
08:22:56 <Lemmih> jeffwheeler: Have you identified?
08:23:08 <jeffwheeler> Lemmih: nevermind; I figured it out.
08:23:15 <Saizan> byorgey: did you manage to install leksah?
08:23:21 <jeffwheeler> It still requires a prefix. Silly me.
08:23:31 <byorgey> Saizan: I did at one point a long time ago
08:23:45 <byorgey> RayNbow: notepad!?!
08:23:46 <kadir> all the time IDE wars end up with emacs and vim discussions
08:24:41 <jeffwheeler> Woah, it does infinite lists for _much_ longer when in private discussions.
08:24:46 <monochrom> I should write a review of Bird's introductory book and submit to TMR. The book is perpetually underrated.
08:25:32 <RayNbow> byorgey: blame Windows :+
08:25:52 <byorgey> RayNbow: that is not an excuse =)
08:26:27 <byorgey> monochrom: that would be great!
08:26:33 <RayNbow> hmm, from what I can remember... I didn't use a fancy editor either when I was young on the VMS OS
08:27:02 * RayNbow can't recall what he used though... memory is failing :p
08:27:08 <monochrom> There was no fancy editor on VMS. But there was a fine editor.
08:28:09 <RayNbow> I can't even remember how old I was back then
08:28:18 <RayNbow> maybe 8 years old?
08:29:03 <monochrom> Blessed are the 8yo's who had access to a VAX.
08:29:15 <monochrom> My access was when I was 18yo.
08:29:59 <RayNbow> monochrom: my uncle had a VAX at home, so when I was there... I was spending my time at painting and typing texts :p
08:30:15 <RayNbow> the company where he works at no longer uses VAX though...
08:32:54 <RayNbow> http://www.oldmouse.com/articles/hawley/ <-- nostalgia, monochrom? :)
08:32:55 <lambdabot> Title: Non-PC Mouses - Hawley Mouse House ~ o l d m o u s e .c o m ~
08:45:12 <monochrom> RayNbow: I have used some of them, namely those from Sun.
08:57:58 <gubagem> sun mice have a nice feel to them
09:03:42 <nolrai_> Just out of curiosity, is it posible to compile from haskell to the i-Phone?
09:04:12 <RayNbow> @faq
09:04:12 <lambdabot> The answer is: Yes! Haskell can do that.
09:04:18 <asmanian> lol
09:04:22 <nolrai_> :P
09:05:13 <RayNbow> well, it should be possible to run Haskell on the iPhone... but you might have to port some things first yourself :p
09:05:14 <obk> monochrom: There was VI for VMS. I know because I ported it :-)
09:07:29 * monochrom cringes 
09:08:02 <jeffwheeler> I just checked in Installer, and there's currently no Haskll packages already, unfortunately.
09:08:31 <nolrai_> is IntSet, better then Set Int?
09:10:52 <sclv> nolrai_: as long as you're only using Ints, yes.
09:11:31 <nolrai_> How much better?
09:11:55 <gubagem> if im "mutating" "state" alot in my haskell program, am I doing something wrong?
09:12:00 <sclv> time it and find out :-)
09:12:30 <monochrom> Perhaps. Depends.
09:12:59 <gubagem> monochrom: its for a mud im writing ever so slowly
09:13:28 <sclv> anyway, the notion is it uses a binary trie rather than a standard tree structure, so you have a fixed complexity on the size of an Int rather than one which varies over your input size.
09:14:02 <sclv> (except it only "bursts" into subtrees when it needs too, so works well for small n as well)
09:14:14 * gubagem goes to breakfast...
09:14:24 <nolrai_> hmm
09:14:35 <tobias_tud> is there a way to force my program to wait until "t <- system "bla bla"" really ends? if i call sat4j in the command line, it really waits, but with minisat the program flow breaks
09:14:44 <sclv> I don't know the timings, but it certainly should be better in pretty much all cases.
09:15:45 <nolrai_> Hmm ill keep it in mind as an optimization, but right now a simple type scheme is more important. Thanks sclv.
09:16:47 <sclv> tobias_tud: use System.Process instead of System.Cmd
09:17:09 <tobias_tud> thank you, sclv
09:17:46 <gwern> tobias_tud: what sclv said, although it'll take some effort to write a function which runs a command, gets its stdout, and only returns when it is done
09:17:56 * gwern has had to do that before
09:18:13 <Deewiant> @hoogle waitFor
09:18:13 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
09:18:13 <lambdabot> System.IO.hWaitForInput :: Handle -> Int -> IO Bool
09:18:22 <shapr> @yow !
09:18:22 <lambdabot> Couldn't find fortune file
09:18:24 <shapr> aww
09:18:40 <Philippa> hi
09:18:47 <shapr> hi Philippa!
09:19:11 <sclv> the process stuff gets confusing with the lazy io and all. there might need to be some manual stream closing involved too.
09:19:40 <Philippa> I need to do a bunch of modelling work - if I had forever I'd do some basic dataflow or FRP work in haskell and go from there, but I need pretty pics in <24 hours. Spreadsheet not good enough
09:19:55 <Philippa> anyone got any tool recommendations? Windows for preference, linux okay
09:20:24 <Philippa> and hi shapr :-)
09:20:54 <Philippa> "ask $chan" works too in a pinch
09:21:19 <laz0r> Philippa: modelling as in 3D modelling?
09:21:22 <pejo> Philippa, would graphviz do?
09:21:35 <Philippa> laz0r: mathematical modelling, dynamic systems etc etc
09:21:53 <Philippa> pejo: nope. At best it'd be part of a toolchain
09:22:08 <Philippa> unless it does stuff I don't know about at all
09:22:21 <Philippa> the pretty pics're more likely to be the other kind of graph
09:22:59 <nolrai_> :t fmap
09:23:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:23:20 <pejo> Philippa, oh, ok, then it's not what you're looking for.
09:23:23 <nolrai_> > fmap (\1 -> 2) [1]
09:23:24 <lambdabot>  [2]
09:23:45 <nolrai_> > fmap (\1 -> 2) (S.fromList [1])
09:23:46 <lambdabot>   add an instance declaration for (Functor S.Set)
09:23:46 <lambdabot>     In the expression: fmap...
09:24:07 <laz0r> Philippa: i can't really think of anything, but maybe you could use blenders python interface to hack a little script that creates what you want, and then just render it with blender...
09:24:23 <nolrai_> is there a resason that set isnt a Functor?
09:24:36 <nolrai_> s/set/Set
09:24:36 <byorgey> nolrai_: yes, Ord
09:24:50 <nolrai_> hmm
09:24:57 <sclv> ?ty S.empty
09:24:59 <lambdabot> forall a. S.Set a
09:25:06 <sclv> byorgey^^
09:25:23 <nolrai_> :t S.map
09:25:23 <byorgey> sclv: ?
09:25:25 <lambdabot> forall a b. (Ord b, Ord a) => (a -> b) -> S.Set a -> S.Set b
09:25:36 <astrolabe> Philippa: It's nasty, but spreadsheets let you produce plots quickly, as does matlab (octave is a free matlab-a-like).
09:26:14 <Philippa> astrolabe: thanks. What're the odds of two people figuring octave out from no experience in time, given that I'm one of them?
09:26:17 <nolrai_> I guess it makes sese that an empty set can (not) contain anything.
09:26:18 <sclv> ah -- gotcha. the empty constraint wasn't an issue, but I forgot that you needed the constraint on map as well.
09:27:17 <byorgey> nolrai_: it's not necessarily a *good* reason -- Set is certainly a little-f functor, it's just not a big-F Functor in Haskell due to the way things are defined and the way Haskell works
09:27:27 <geezusfreeek> unfortunate that Set requires an implementation detail like that to be exposed
09:27:35 <gwern> Philippa: "Sir, the possibility of successfully navigating octave areapproximately three thousand seven hundred and twenty to one!"
09:27:41 <astrolabe> Philippa: You'd get matlab quickly, I don't know what the Octave help system is like, but I'd be hopeful.  The language is easy, annoying, ugly, but you can get stuff done with it.
09:27:51 <laz0r> Philippa: https://forja.rediris.es/projects/csl-qtoctave/ <- this might be helpful for someone that is new to octave
09:28:34 <byorgey> geezusfreeek: indeed.
09:28:34 <Apocalisp> ?hoogle (a -> b) -> (b -> a)
09:28:35 <lambdabot> No matches, try a more general search
09:28:43 <geezusfreeek> I suppose that even if Ord wasn't necessary, Eq would still be
09:28:46 <Philippa> laz0r: thanks
09:28:48 <laz0r> it is a qt frontend for octave, but i don't know how far these guys are, so i cannot tell you if it is working at all...
09:29:01 <Philippa> astrolabe: cheers. I gather the lang's a little bit lisp-with-syntax
09:29:26 <Apocalisp> ?hoogle m a -> (a -> b) -> (b -> a) -> m b
09:29:27 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
09:29:27 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
09:29:27 <lambdabot> Control.Parallel.Strategies.(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
09:30:18 <astrolabe> Philippa: I wouldn't say it was like lisp, but it there is an interpreter, which helps a lot.
09:30:52 <geezusfreeek> i bet it wouldn't be too hard to define a "general" map function for Set in some category other than Hask though
09:33:39 <Saizan> Set is a functor in the subcategory of Ord-able types
09:38:31 <Apocalisp> ?hoogle (Monad m) => (a -> b) -> ((a -> b) -> (b -> a)) -> m a -> m b
09:38:31 <lambdabot> No matches, try a more general search
09:39:15 <Apocalisp> ?hoogle (Functor f) => (a -> b) -> ((a -> b) -> (b -> a)) -> f a -> f b
09:39:16 <lambdabot> No matches, try a more general search
09:39:21 <Apocalisp> drat
09:39:51 <gwern> see, when people say things like that, I get an urge to haul out the pitchforks
09:40:18 <Apocalisp> things like what?
09:40:41 <gwern> 'Set is a functor in the subcategory of Ord-able types'
09:41:40 <Apocalisp> Oh, right. Do you mean "pitchfork" as in (--<) ?
09:42:08 <gwern> -_-
09:42:58 <ski_> what? .. oh, *that* `Set'
09:43:36 <ttt--> i thought Set was a category
09:43:57 <ski_> that was the one i was thinking first of, yes
09:44:07 <ttt--> how is it a functor?
09:44:53 <ski_> ttt-- : in this case, it means roughly the covariant finite-powerset functor
09:45:38 <Saizan> ttt--: Data.Set.Set
09:46:18 <Saizan> ..and i guess i should have said from
09:47:25 <ttt--> oh i see
09:47:40 <dafra> @src (>>>)
09:47:40 <lambdabot> Source not found. Maybe you made a typo?
09:47:49 <dafra> @src >>>
09:47:50 <lambdabot> Source not found. :(
09:49:26 <ski_> @src (->) (>>>)
09:49:26 <lambdabot> f >>> g = g . f
09:49:37 <ski_> @src Kleisli (>>>)
09:49:38 <lambdabot> Source not found. You type like i drive.
09:51:02 <dafra> why the (->) before (>>>) ?
09:53:53 <Lemmih> dafra: (>>>) is overloaded like 'show'.
09:53:57 <gwern> @seen dcoutts
09:53:57 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 17h 37m 41s ago.
09:55:28 <dafra> @Lemmih so what ?overloaded needs (->) ?
09:55:28 <lambdabot> Unknown command, try @list
09:56:29 <gwern> @ask dcoutts hey, I noticed in cabal-1.4 that haddock doc generation seems to be broken - error looks like 'Hackage/Reporting.hs:104:4:\nparse error on input `-- | Which build tools we were using (with versions)\n--    tools      :: [PackageIdentifier],'. Is this a known problem or a haddock 2 bug?
09:56:29 <dafra> ~src show
09:56:29 <lambdabot> Consider it noted.
09:56:42 <dafra> @src show
09:56:42 <lambdabot> show x = shows x ""
09:56:56 <dafra> @src shows
09:56:56 <lambdabot> Source not found. Are you on drugs?
09:57:05 <dafra> yes
09:57:25 <ski_> @src Bool show
09:57:25 <lambdabot> Source not found.
09:57:28 <ski_> @src Bool shows
09:57:29 <lambdabot> Source not found. My brain just exploded
09:58:19 <dafra> @src Show Bool
09:58:19 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:59:28 <chylli> I want to install collections by cabal , but I got an error:
09:59:46 <chylli>     Could not find module `Data.ByteString.Lazy':
09:59:47 <chylli>       it is a member of package bytestring-0.9.1.0, which is hidden
09:59:47 <chylli>  
10:00:08 <gwern> split-base strikes again
10:00:15 <gwern> chylli: where did you get this collections from? ln pls
10:00:36 <gwern> chylli: incidentally, the quick fix is to edit collections.cabal, find build-depends: and insert 'bytestring'
10:00:47 <chylli> I used ghc-pkg describe bytestring-0.9.1.0  and find the flag of exposed is true
10:00:50 <ski_> dafra
10:00:51 <ski_>   showsPrec _ True  = showString "True"
10:00:51 <ski_>   showsPrec _ False = showString "False"
10:00:59 <ski_> <http://darcs.haskell.org/packages/base/GHC/Show.lhs>
10:01:00 <chylli> gwern: I just use cabal install collections
10:01:10 <chylli> It download that automatically
10:02:05 <gwern> chylli: the 'hidden' part is not referring to 'your system' hiding bytestring, but rather it refers to how cabal, when building collections, 'hides' everything collections does not spcifically ask for, so that way collections must be honest about what it needs
10:02:17 <gwern> ah, so it's from hackage then
10:03:13 <gwern> I've been meaning for a few weeks to update the collections business...
10:03:44 <gwern> chylli: btw, you probably shouldn't expect collections to install (immediately), looking at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections it fails compilation under both 6.8 and 6.6
10:03:51 <lambdabot> http://tinyurl.com/63pbz5
10:04:11 <chylli> gwern: ok.
10:04:53 <chylli> gwern: I found that the hackapge is not as good as CPAN . I remembered the bytestring has caused lots of trouble.
10:04:54 <sjanssen> gwern: the 6.6 error is just haddock stuff
10:05:19 <sjanssen> gwern: is collections not maintained any more?
10:05:48 <gwern> chylli: it's much younger, and the bytestring dependency problem is in part a systemic problem, not just hackage
10:06:01 <gwern> sjanssen: not really. jyp last committed to the darcs repos like a year ago or so
10:06:25 <chylli> gwern: is haskell younger or cabal younger or bytestring younger ?
10:07:16 <gwern> chylli: haskell > bytestring > cabal, roughly (bytestring may succeed cabal, but it's been in wider use faster)
10:07:25 <gwern> and hackage is younger than cabal, actually
10:07:36 <sjanssen> gwern: that isn't true
10:07:54 <chylli> gwern: I'm reading an article "Monad Tranformers step by step" . the module "Data.Map" is used. so I want to look at that module.
10:08:00 <sjanssen> Cabal is definitely older than fps/ByteString (I remember the first version was packaged with Cabal)
10:08:37 <gwern> sjanssen: yeah, but it got picked up a lot faster by the community than did cabal
10:08:57 <sjanssen> gwern: I don't think this is true either
10:10:03 <Saizan> chylli: Data.Map is in containers, not collections
10:10:11 <gwern> I haven't run the numbers, but from my experience packaging stuff up, cabal was not in wide use when bytestring became popular. there was plenty of stuff using bytestring but not cabal
10:10:13 <Saizan> chylli: and you probably have containers installed
10:10:20 <gwern> (darcs, for example)
10:10:47 <gwern> (making cabal really standard has taken quite a while)
10:11:06 <chylli> Saizan: ok, thanks
10:11:51 <gwern> on the other hand, besides a few holdouts like John Meachem and Dr. Roundy, we've made a lot of progress, and I think we could declare victory when cabal-install gets released
10:13:52 <chylli> I dont know why the namespace of package is not unified with module name. why not like PackageA.pm and 'Package PackageA' in perl ? I really don't know where should I look for one module.
10:14:27 <chylli> Saizan: seems that collections also have that ?
10:16:33 <Saizan> chylli: collections has Data.Map.AVL and Data.Map.List which are different from Data.Map
10:17:44 <Saizan> and yeah, you don't know "where to look for a module" that's why libraries packaged with cabal list their dependencies
10:20:34 <chylli> Saizan: for example, now I read a piece of code that use 'Data.Map', then what should I do to study that module? to read the prototype of that module ? how to know that Data.map is in 'container' ? please give me some tips ?
10:23:04 <rwbarton> chylli: for modules included with ghc, you can check the list here: http://haskell.org/ghc/docs/latest/html/libraries/
10:24:21 <chylli> rwbarton: ok, thanks very much.
10:24:55 <rwbarton> If you have an older ghc, you can change 'latest' to '6.6.1' say
10:25:23 <chylli> ok
10:29:51 <dafra> what's the point of const ?
10:30:05 <smg> @type const
10:30:08 <lambdabot> forall a b. a -> b -> a
10:30:23 <dafra> I know the type, I want the point :)
10:30:34 <Lycurgus> that's it
10:30:56 <dafra> why on earth would you want to forget rhe second argument ?
10:31:40 <Saizan> dafra: when you use higher order functions it can be handy
10:31:55 <Lycurgus> since everything is const
10:32:05 <dafra> lol
10:32:06 <Lycurgus> you need an explict const to be const
10:32:25 <dolio> > let head = foldr const (error "head of empty list.") in head "foobar"
10:32:26 <lambdabot>  'f'
10:33:12 <dolio> > let fst = uncurry const in fst (1,2)
10:33:13 <lambdabot>  1
10:33:21 <Saizan> > let dropEnd n xs = zipWith const xs (drop n xs) in dropEnd 3 [1..10]
10:33:22 <lambdabot>  [1,2,3,4,5,6,7]
10:35:17 <dolio> > let callCC e k = e (\a -> const (k a)) k in callCC (\exit -> exit 5) id
10:35:19 <lambdabot>  5
10:36:55 <ddarius> callCC (\k -> k x) is not a terribly interesting example.
10:37:31 <dolio> Yeah, but making a more interesting one requires a lot more typing.
10:37:49 <ddarius> Not really.
10:38:03 <newsham> I made a "haskell" username on codepage.org (pw: haskell) if people wanna put up interesting codebits more permanently
10:38:46 <ddarius> > let callCC e k = e (\a -> const (k a)) k in callCC (\exit -> exit 5 $ \k a -> k (a + 1)) id
10:38:47 <lambdabot>      Occurs check: cannot construct the infinite type:
10:38:47 <lambdabot>       a = (t1 -> a) ->...
10:38:58 <ddarius> > let callCC e k = e (\a -> const (k a)) k in callCC (\exit -> exit 5 $ \a k -> k (a + 1)) id
10:38:59 <lambdabot>      Occurs check: cannot construct the infinite type:
10:38:59 <lambdabot>       a = (t1 -> a) ->...
10:40:15 <Saizan> $ /= >>=
10:41:45 <ddarius> Saizan: But I'm only going for m >>= return . f which is just fmap.  It can certainly be simplified.
10:43:50 <ddarius> > let callCC e k = e (\a -> const (k a)) k in callCC (\exit k -> exit 5 $ k . (+ 1)) id
10:43:51 <lambdabot>  5
10:44:07 <ddarius> > let callCC e k = e (\a -> const (k a)) k in callCC (\exit k -> (\k' -> k' 5) $ k . (+ 1)) id
10:44:08 <lambdabot>  6
10:55:19 <dolio> > let return :: a -> (a -> r) -> r ; return a k = k a ; (m >>= f) k = m (flip f k) ; foldM :: (b -> a -> (b -> r) -> r) -> b -> [a] -> (b -> r) -> r ; foldM f z [] = return z ;  foldM f z (x:xs) = f z x >>= \fzx -> foldM f fzx xs ; callCC e k = e (\a -> const (k a)) k in callCC (\exit -> foldM (\p n -> if n == 0 then exit 0 else return (p*n)) 1 [-10..10]) id
10:55:20 <lambdabot>  0
10:59:09 <ddarius> There you go.
11:00:15 <ddarius> callCC is so sillily non-linear.
11:02:07 <newsham> does lb not have the Cont monad?
11:05:07 <dolio> > let return a k = k a ; m >>= f = m . flip f ; foldM f z [] = return z ; foldM f z (x:xs) = f z x >>= \fzx -> foldM f fzx xs ; control e k = e (\a -> const (k a)) id in foldM (\p n -> if n == 0 then control (const $ return 0) else return (p * n)) 1 [-10..] id
11:05:09 <lambdabot>  0
11:05:50 <dolio> Two consts in that one!
11:27:21 <noecksit> hello, theres a problem with haddock, i posted in gentoo-haskell but i dont think anyones there
11:27:43 <noecksit> it gives an error when compiled with "doc" use falg
11:28:54 <Lemmih> Well, don't do that then.
11:29:53 <ertai> @src lift2M
11:29:53 <lambdabot> Source not found. You untyped fool!
11:30:01 <ertai> @type lift2M
11:30:04 <lambdabot> Not in scope: `lift2M'
11:30:12 <ertai> @index lift2M
11:30:12 <lambdabot> bzzt
11:30:21 <int-e> @type liftM2
11:30:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:30:32 <int-e> @type liftA2
11:30:34 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:30:46 <ertai> thanks int-e
11:43:40 <dolio> @type (. <*>) . (<$>)
11:43:41 <lambdabot> parse error on input `<*>'
11:43:49 <dolio> @type (. (<*>)) . (<$>)
11:43:51 <lambdabot> forall (f :: * -> *) a b b1. (Applicative f) => (f b -> b1) -> f (a -> b) -> f a -> b1
11:44:01 <dolio> Oops.
11:44:18 <shachaf> Is there a nice way to do anyM :: (Monad m) => (a -> m Bool) -> [a] -> m Bool?
11:45:18 <RayNbow> mapM?
11:45:28 <dolio> @type \p -> liftM or . mapM p
11:45:28 <shachaf> There's fmap or . mapM f, I guess.
11:45:29 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m Bool
11:45:44 <ddarius> Is that the semantics you want?
11:46:03 <ddarius> That will execute the action on all results.
11:46:12 <dolio> Yeah, that runs all the actions. If you want to short-circuit, it's something else.
11:47:18 <ddarius> :t \p -> foldr (\x xs -> do b <- p x; if b then return True else xs) (return False)
11:47:19 <lambdabot> forall a (t :: * -> *). (Monad t) => (a -> t Bool) -> [a] -> t Bool
11:49:05 <shachaf> ddarius: I guess that'll work, thanks. It's not predefined anywhere?
11:49:44 <ddarius> I don't think so.  Maybe something in Foldable or Traversable is close.
11:50:14 <ddarius> :t some
11:50:15 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
11:57:21 <norbi> I have a question related to the HTTP package Browser library. How can I create a cookie? I don't see a data constructor for it...
11:57:46 <norbi> Maybe this is a more general question, but I just bumped into this now...
11:57:56 <norbi> with this lib.
12:02:13 <roconnor> > some [5]
12:02:14 <lambdabot>  Exception: stack overflow
12:02:23 <roconnor> > some []
12:02:24 <lambdabot>  []
12:02:24 <EvilTerran> ?src some
12:02:25 <lambdabot> some v = some_v
12:02:25 <lambdabot>   where many_v = some_v <|> pure []
12:02:25 <lambdabot>         some_v = (:) <$> v <*> many_v
12:03:17 <EvilTerran> er... so "some v = (:) <$> v <*> (some v <|> pure [])", then?
12:03:25 <EvilTerran> ?src many
12:03:26 <lambdabot> Source not found. Wrong!  You cheating scum!
12:04:14 * EvilTerran checks... unsurprisingly, it's "many v = many_v where <as before>"
12:04:18 <roconnor> > head $ some [5]
12:04:19 <lambdabot>  Exception: stack overflow
12:04:58 <EvilTerran> i guess the point is it's a "run it 'til it fails and collect the results" kinda thing
12:05:05 <roconnor> > some $ Just 5
12:05:06 <lambdabot>  Exception: stack overflow
12:05:23 <Saizan> it kind of make sense only for parsers
12:05:31 <Saizan> it seems
12:05:32 <roconnor> oh
12:05:34 <roconnor> parsers
12:05:37 <roconnor> @hoogle some
12:05:38 <lambdabot> Control.Applicative.some :: Alternative f => f a -> f [a]
12:05:38 <lambdabot> Data.Generics.Schemes.somewhere :: MonadPlus m => GenericM m -> GenericM m
12:05:38 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
12:11:12 <EvilTerran> i think i can contrive an example using StateT, but it won't work in lambdabot as the requisite instances aren't there
12:11:16 <smg> > (3%4)
12:11:17 <lambdabot>  3%4
12:11:21 <smg> is that rational?
12:11:30 <Zao> :t (3%4)
12:11:30 <EvilTerran> ?type 3%4
12:11:31 <smg> works not in ghc 6.6.1
12:11:32 <lambdabot> forall t. (Integral t) => Ratio t
12:11:33 <lambdabot> forall t. (Integral t) => Ratio t
12:11:43 <smg> sadly it's > 6.8.x i guess
12:11:44 <EvilTerran> you have to import/load Data.Ratio
12:14:30 <smg> uhm. thank you.
12:34:46 <alsonk_> what was the rationale for breaking the library into a bunch of sub-libraries?  that seems to have broken a ton of Cabal-ed packages.
12:36:58 <EvilTerran> future flexibility
12:37:05 <EvilTerran> also: smugness
12:38:04 <smg> punkte liste name = sum [sum . map punkte' $ l1, sum . map punkte'' $ l2
12:38:07 <smg> can i make this more elegant?
12:39:00 <EvilTerran> you appear to have un-matched [s
12:39:11 <gwern> 'I have always been impressed with the winner of the 2004 Obfuscated V contest, who concealed an error in a vote-counting program by adding a voter-verifiable paper trail function that overflowed a buffer. Thatâ€™s evil with style.'
12:39:31 <EvilTerran> :D
12:39:31 <RayNbow> smg: why German? :p
12:39:56 <smg> RayNbow: sorry
12:40:17 <RayNbow> you don't have to apologize
12:40:22 <RayNbow> just wondering why
12:41:04 <Zao> smg: Could you hpaste the whole function?
12:41:55 <Zao> Well, never mind.
12:42:00 <int-e> hmm,  sum . map sum $ zipWith map [punkte', punkte''] [l1, l2]
12:42:12 <RayNbow> anyway, my opinion is that German sucks in Haskell... you can't always properly capitalize German nouns since variables must start with a lowercase letter :p
12:42:26 <int-e> (if l1 and l2 have the same type)
12:43:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8340
12:43:39 <smg> the paset is in it
12:43:46 <smg> Zao: i pasted it
12:44:31 <Saizan> ((fst $ ergebnis x), (snd $ ergebnis x))
12:44:41 <Saizan> == ergebnis x
12:46:02 <EvilTerran> punkte' x = case f `compare` s of GT -> 3; EQ -> 1; LT -> 0
12:46:07 <EvilTerran>     where ...
12:46:25 <smg> EvilTerran: ah nice
12:46:43 <smg> i wanted to do it with case but i forgot
12:47:25 <int-e> > map (pred . (2^) . fromEnum) [LT,EQ,GT] -- *ducks*
12:47:26 <lambdabot>  [0,1,3]
12:47:28 <Saizan> punkte' and punkte'' are the same modulo a flip on compare
12:47:49 <Toxaris> smg : ... where (f, s ) = ergebnis x
12:49:16 <smg> hehe :)
12:49:24 <smg> Saizan: ?
12:49:57 <Toxaris> smg: I would sort each element of the match list so that the team in question is in the first component (that is, swap teams if not). then its a simple sum . map punkte
12:51:44 <tobias_tud> is anyone familar with satisfiability testing?
12:52:00 <tobias_tud> or knows a nice irc channel?
12:52:26 <Toxaris> smg: by the way: (case uncurry compare ergebnis of GT -> 3; EQ -> 1; LT -> 0) should work without where :)
12:53:51 <hpaste>  EvilTerran annotated "(no title)" with "for <smg>" at http://hpaste.org/8340#a1
12:53:59 <EvilTerran> I think that's right
12:56:37 <smg> haah evil EvilTerran :)
12:56:39 <smg> i like you
12:57:02 <smg> Toxaris: interesting
12:58:41 <smg> Toxaris: mh won't work? :|
12:58:57 <Toxaris> smg: well depends on what information your match list contains :)
12:59:08 <smg> hehe
12:59:12 <Toxaris> smg: you have to throw out all unrelated matches, too, so the current approach may be better :)
12:59:47 <smg>             points'  x = case uncurry compare $ ergebnis x of GT -> 3;  ^^
12:59:51 <smg> EvilTerran: thank you
13:00:06 <dolio> ddarius: You don't waste words.
13:00:56 <smg> erm
13:01:00 <smg> Toxaris: could i use flip?
13:01:05 <smg> for the punkte'' thing?
13:01:41 <Toxaris> :t uncurry (flip (,)) -- searching for this one, smg?
13:01:43 <lambdabot> forall b a. (a, b) -> (b, a)
13:01:54 <Toxaris> smg: if not, I don't understand what you mean
13:02:06 <smg> yes! :)
13:02:54 <TomMD> Is there a built in 2's complement or should I make my own?
13:03:21 <smg> EvilTerran: your implementation is really cool
13:03:48 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8340#a2
13:10:35 <smg> EvilTerran: are you in?
13:11:30 <roconnor> I hate Makefiles!
13:11:48 <roconnor> Do we have a replacement for make written by a Haskeller yet?
13:12:40 <roconnor> a make system that is declaritive
13:13:24 <smg> unentschieden = filter (\x -> uncurry (==) $ ergebnis x)
13:13:27 <smg> can i somehow shorten that?
13:13:31 <smg> unentschieden means = remis
13:13:46 <Saizan> roconnor: i should write it by the end of the summer :)
13:14:03 <roconnor> Saizan: thank god.
13:14:29 <Saizan> roconnor: can you elaborate on "declarative" ?
13:14:34 <roconnor> I'm tired of global variables in my make files whose order of evaluation is totally unclear.
13:15:26 <roconnor> It's like I'm writing in BASIC
13:15:32 <roconnor> or FORTRAN
13:15:46 <Elly> roconnor: are you using = or := to assign?
13:15:50 <Saizan> heh, or bash..
13:15:56 <roconnor> :=
13:16:00 <Elly> hrm
13:16:04 <Elly> the order shouldn't be unclear then
13:16:47 <roconnor> when I include a rules.mk file, all my variables change
13:16:54 <roconnor> thoses files include other files
13:17:01 <roconnor> and the result is a big mess
13:17:05 <roconnor> because there is no scoping
13:17:06 <Elly> oh, oops
13:17:09 <Elly> yeah, well
13:17:13 <Elly> that's what you get for using make :P
13:17:17 <roconnor> no locality
13:17:18 <roconnor> bleh
13:17:34 <smg> f = filter (\x -> uncurry (==) $ ergebnis x)
13:17:41 <smg> is there something to simplify?
13:18:01 <roconnor> I'll stop using variable names like D and use GUIDs instead
13:18:13 <roconnor> granted that will be harder to read
13:18:14 <smg> f = filter (uncurry (==) . ergebnis)
13:18:17 <smg> that's it?
13:18:33 <roconnor> @pl filter (\x -> uncurry (==) $ ergebnis x)
13:18:33 <lambdabot> filter (uncurry (==) . ergebnis)
13:19:36 <roconnor> using a list comprehension might be slightly shorter.
13:19:42 <smg> hehe :]
13:19:46 <smg> really? <:
13:20:07 <roconnor> I seem to recall replacing something similar to that with a list comprehension to remove a few characters.
13:28:32 <s1d> haskell haters http://youtube.on.nimp.org/watch?v=3zvTRQr7ns8
13:28:39 <lambdabot> Title: GNAA Last Measure Live!
13:29:50 <EvilTerran> @where ops
13:29:50 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:30:37 * EvilTerran has heard of nimp.org before - it's a shock site
13:31:59 <smg> EvilTerran:
13:32:05 <smg> please are there i have a new implementation
13:32:41 <roconnor> ``The site itself is merely a way to make your web browser jump around on your screen, and open all programs attached to it. It can be annoying, but it is easy to stop on Mozilla Firefox. Microsoft Internet Explorer is very vulnerable to this "attack"
13:32:45 --- mode: ChanServ set +o Igloo
13:33:20 --- mode: Igloo set +b *!*@64.81.136.196
13:33:23 --- kick: s1d was kicked by Igloo (Igloo)
13:33:33 <Igloo> Thanks EvilTerran
13:33:40 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8340#a3
13:33:44 <smg> EvilTerran: http://hpaste.org/8340#a3
13:33:50 <smg> do you like that EvilTerran? :)
13:34:23 <tusho> EvilTerran: it's Last Measure
13:34:36 <tusho> 'shock site' is a bit of an understatement
13:34:45 <EvilTerran> smg, well, i'd still extract the calls to filter out to a function
13:34:59 <smg> hehe
13:35:21 <EvilTerran> > sum [x, y] -- this is also relevant
13:35:25 <lambdabot>  0 + x + y
13:35:26 <tusho> Hmm. I think I'll write a Haskell-subset to JS compiler.
13:35:32 <EvilTerran> er, ignoring the stray (0+) there :P
13:35:32 <tusho> Because, uh, the YHC one is dog slo.
13:35:33 <tusho> *slow
13:36:15 <EvilTerran> smg, ie, you can write that sum [(...), (...)] as just (...) + (...)
13:36:32 <smg> @pl > filter (\x -> id x == 20)
13:36:32 <lambdabot> (line 1, column 1):
13:36:32 <lambdabot> unexpected ">"
13:36:32 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:36:45 <smg> @pl > let f list = filter (\x -> id x == 20) list
13:36:45 <lambdabot> (line 1, column 1):
13:36:45 <lambdabot> unexpected ">"
13:36:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:36:45 <EvilTerran> (==20)
13:36:50 <tusho> I warn you all. It will include desperately huge amounts of awesome,
13:36:52 <EvilTerran> @pl filter (\x -> id x == 20)
13:36:52 <lambdabot> filter (20 ==)
13:36:52 <tusho> so beware
13:37:07 <EvilTerran> pl takes expressions, no leading > or anything
13:38:34 <smg> ahh ok
13:38:49 <hpaste>  (anonymous) annotated "(no title)" with "final ..." at http://hpaste.org/8340#a4
13:38:51 <roconnor> points' doesn't use f
13:38:57 <smg> it does
13:39:13 <smg> ah it does not
13:39:38 <smg> now it does okay
13:41:55 <hpaste>  (anonymous) annotated "(no title)" with "..." at http://hpaste.org/8340#a5
13:42:09 <smg> can i somewhere elimate parenthesis?
13:43:18 <roconnor> smg: does gast = heim . swap?
13:44:19 <smg> what is swap?
13:44:38 <EvilTerran> > uncurry (++) . unzip $ [(a,x),(b,y),(c,z)]
13:44:39 <lambdabot>  [a,b,c,x,y,z]
13:44:41 <smg> hehe
13:44:47 <roconnor> swap (a,b) = (b,a)
13:45:00 <czakey> @src swap
13:45:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:45:07 <czakey> @src flip
13:45:07 <lambdabot> flip f x y = f y x
13:45:16 <EvilTerran> oddly, it's not defined in the libraries anywhere
13:45:17 <czakey> difference?
13:45:23 <czakey> swap = flip?
13:45:29 <EvilTerran> although i'm angling toget it in caleskell ;)
13:45:57 <roconnor> czakey: nope
13:46:04 <int-e> @type uncurry (flip (,))
13:46:07 <roconnor> @pl \(a,b) -> (b,a)
13:46:09 <lambdabot> forall b a. (a, b) -> (b, a)
13:46:09 <lambdabot> uncurry (flip (,))
13:50:56 <asolove> hi all, I'm trying to get cabal, -install, and some libs working. Is there an expected path ghc/hugs look for these?
13:51:01 <hpaste>  roconnor annotated "(no title)" with "untested" at http://hpaste.org/8340#a6
13:53:22 <newsham> stdlib needs a   swap (a,b) = (b,a)
13:54:22 <newsham> (commute?)
13:55:19 <roconnor> i've been calling it swap
13:55:28 <newsham> if its important enough to have a mathematical name, its probably important enough to be in the stdlib
13:55:39 <Lemmih> asolove: Expected path?
13:56:17 <asolove> when I install, it works perfectly fine, but other packages that require it can't find it, so I assume things are in the wrong place
13:56:19 <dons> asolove: cabal-install should just be in your path. cabal itself should be registered with ghc-pkg (which happens automatically when you build and install it)
13:56:20 <newsham> ?let swap (a,b) = (b,a)
13:56:21 <lambdabot> Defined.
13:56:28 <dons> asolove: ghc-pkg list --user ?
13:56:34 <dons> see if Cabal is registered
13:56:56 <newsham> > unfoldrp (/= 0) (swap divMod) 12345
13:56:57 <lambdabot>  Couldn't match expected type `(t, t1)'
13:57:05 <newsham> > unfoldrp (/= 0) (swap.divMod) 12345
13:57:06 <lambdabot>  Couldn't match expected type `(t, t1)'
13:57:16 <int-e> roconnor: I think Match is a record - it has to contain four values at least. (two teams, and a score for each team)
13:57:26 <asolove> it has an old cabal 1.2, though I just ran the install script for 1.4
13:57:38 <roconnor> int-e: ah
13:57:49 <roconnor> int-e: so he needs a specialized swap
13:58:53 <newsham> > unfoldrp (/= 0) (swap.(`divMod` 10)) 12345
13:58:55 <lambdabot>  [5,4,3,2,1]
13:59:56 <Lemmih> asolove: You might wanna try installing it like you would any other library.
14:00:14 <int-e> > unfoldr (liftM2 (>>) (guard . (/= 0)) (return . swap . (`divMod` 10))) 12345 -- unfoldr isn't all that bad
14:00:16 <lambdabot>  [5,4,3,2,1]
14:00:33 <newsham> liftM2 (>>) is kinda bda.
14:00:34 <newsham> bad
14:00:38 <int-e> :P
14:01:05 <newsham> (but i was trying to show off "swap", not "unfoldrp")
14:02:00 <newsham> its weird that humans dont write numbers from least sig digit to most.
14:02:01 <int-e> @type snd &&& fst
14:02:03 <lambdabot> forall a b. (a, b) -> (b, a)
14:02:39 <newsham> inte: yes, that is the most natural definition of commutativity over conjunction ever.
14:03:45 <int-e> newsham: I don't know; it would make sense to write them that way, but if you read a number aloud, the order of magnitude is a very important information and should be conveyed first.
14:04:46 <newsham> i think it reads very naturally as code.
14:04:52 <newsham> but i think that swap is common enough operation to have its own name
14:04:57 <newsham> far more basic than (&&&)
14:05:06 <roconnor> int-e: how do you state the order of magnitude of the order of magnitude?
14:05:10 <int-e> yes. I agree that  swap  would be useful.
14:05:36 <roconnor> @free swap
14:05:37 <EvilTerran> ?type arr swap
14:05:38 <lambdabot> $map_Pair g f . swap = swap . $map_Pair f g
14:05:39 <lambdabot> forall t t1 (a :: * -> * -> *). (Arrow a) => a (t, t1) (t1, t)
14:06:00 <EvilTerran> roconnor, cool, i didn't know you could do that with ?lets
14:06:10 <roconnor> neither did I
14:06:34 <newsham> btw, if you compile:   swap = (snd && fst) = \p -> (snd p, fst p)    does that get implemented pretty similarly as   swap (a,b) = (b,a)   ?
14:07:50 <roconnor> @src fst
14:07:50 <lambdabot> fst (x,_) =  x
14:08:35 <roconnor> newsham: probably not, because people here stupidly insist on preserving bottoms.
14:09:01 <newsham> roconnor: perhaps you want a bottom-free language? ;-)
14:09:09 <roconnor> I do
14:09:14 <chessguy> @quote bottom
14:09:14 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
14:09:39 <int-e> > case swap undefined of (_,_) -> "Lalala"
14:09:40 <roconnor> but I'd be happy if we let the optimizer change bottoms into less bottomy things
14:09:43 <lambdabot>  "Exception: Prelude.undefined
14:10:03 <newsham> -fless-bottoms
14:10:33 <roconnor> > case (fst &&& snd) undefined of (_,_) -> "Blah Blah Blah"
14:10:34 <int-e> > case (snd &&& fst) undefined of (_,_) -> "Lalala"
14:10:35 <lambdabot>  "Blah Blah Blah"
14:10:36 <lambdabot>  "Lalala"
14:11:29 <roconnor> at least I have a fairly reasonable example for my arugment that the optimizer should be allowed to change bottoms.
14:12:00 <newsham> case p of ((,) a b) -> ((,) b a)       vs     (case p of ((,) _ b) -> b,  case p of ((,) a _) -> a)
14:12:11 <newsham> can optimizers lift the case over the (,)  ?
14:12:46 <roconnor> they could if we let them.
14:12:53 <int-e> swap ~(a,b) = (b,a)  and  swap = snd &&& fst  generate the same code. (with ghc 6.8.2, and -O2)
14:14:07 <int-e> and also -O
14:14:17 <newsham> what's the ~(a,b)   annotation?  strictness?
14:14:22 <RayNbow> lazy pattern match?
14:14:25 <roconnor> oh right, we can make the pattern match lazy
14:14:29 <int-e> irrefutable pattern match.
14:14:51 <int-e> lazy, it's more of a delayed pattern match to me
14:14:53 <roconnor> I forgot that wasn't done even when there is only one constructor.
14:15:01 <roconnor> it is only done with let statements.
14:15:10 <roconnor> and lambda?
14:15:22 <roconnor> > case (\(a,b) -> (a,b)) undefined of (_,_) -> "Blah Blah Blah"
14:15:23 <lambdabot>  "Exception: Prelude.undefined
14:15:35 <roconnor> > case (\~(a,b) -> (b,a)) undefined of (_,_) -> "Blah Blah Blah"
14:15:35 <lambdabot>  Parse error at "->" (column 15)
14:16:05 <roconnor> > case (\p -> let (a,b) = p in (b,a)) undefined of (_,_) -> "Blah Blah Blah"
14:16:06 <lambdabot>  "Blah Blah Blah"
14:16:18 <roconnor> what a screwy language
14:16:30 <newsham> bottom's up
14:16:43 <Lemmih> > case (\ ~(a,b) -> (b,a)) undefined of (_,_) -> "Blah Blah Blah"
14:16:44 <lambdabot>  "Blah Blah Blah"
14:17:04 <osfameron> ooo, "monadic parsing" is just parser combinators!?
14:17:11 <roconnor> Lemmih: ah, thanks
14:17:29 <roconnor> I'm a little surprised that patterns in lambdas are not irrefutable.
14:17:39 <int-e> > let a\~b = 42 in 0\~1
14:17:41 <lambdabot>  42
14:18:34 <roconnor> @remember never let me write a Haskell parser
14:18:34 <lambdabot> Good to know.
14:18:41 <roconnor> er
14:18:42 <eu-prleu-peupeu> :)
14:18:49 <roconnor> @forget never let me write a Haskell parser
14:18:50 <lambdabot> Done.
14:19:01 <newsham> > parse (many digit) "" "123"
14:19:01 <lambdabot>   Not in scope: `digit'
14:19:07 <roconnor> remember isn't quite the same as reminder
14:19:18 <newsham> > parse (many $ oneOf ['0'..'9']) "" "123"
14:19:19 <lambdabot>   Not in scope: `oneOf'
14:19:27 <int-e> @tell roconnor please don't write a haskell parser
14:19:27 <lambdabot> Consider it noted.
14:19:30 <int-e> is that better? :)
14:19:36 <roconnor> :)
14:19:36 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
14:19:39 <roconnor> ooh
14:19:44 <roconnor> @messages
14:19:44 <lambdabot> int-e said 17s ago: please don't write a haskell parser
14:20:49 <Lord_Illidan> yikes..I managed to understand foldr!
14:21:17 <int-e> roconnor: I guess the reason is that irrefutable patterns have a performance cost and there's no way to turn an irrefutable pattern into a refutable one.
14:25:30 <roconnor> int-e: lets are irrefultable.
14:25:42 <roconnor> > foldr f x [a,b,c]
14:25:43 <lambdabot>  f a (f b (f c x))
14:26:05 <int-e> roconnor: yes, does that contradict what I said?
14:26:34 <roconnor> int-e: what is unclear is why lambdas are refutable but lets are irrefutable.
14:27:34 <int-e> so you'd expect  f x = y  to behave differently from  \x -> y ?
14:27:54 <int-e> (where x is a pattern, and the interesting case is that the pattern doesn't match)
14:31:12 <cjay> are there good reasons for let being irrefutable?
14:32:57 <int-e> not sure, but the fact that lets can be recursive seems to play into this. consider  let (a,b,c) = (f b,g c,1)
14:33:21 <Toxaris> > let (x, y) = (y, 1) in x
14:33:22 <lambdabot>  1
14:34:04 <cjay> I see
14:36:48 <newsham> hah, that let is awesome
14:37:22 <cjay> yeah
14:39:49 <int-e> > (\Nothing -> 42) (Just 23)
14:39:51 <lambdabot>   Non-exhaustive patterns in lambda
14:40:48 <int-e> (I like this error)
14:44:21 <tobias_tud> is there an equivalent function for HashTable like Data.Map.elemAt ?
14:45:54 <newsham> can you explain what it does?
14:46:46 <dons> tobias_tud: the   HashTable impl is a bit slow , fwiw.
14:46:56 <dons> needs a czar to oversee its revamp
14:46:58 <monochrom> let {x=y; y=1} in x.  let {y=1; x=y} in x.
14:47:14 <tobias_tud> it retrieves an element by index.
14:47:26 <noteventime> Heya, could anyone familiar with continuations tell me if this is a proper CPS implementation of map? http://hpaste.org/8342
14:47:27 <dons> dcoutts: could hackage prevent packages being uploaded without a synopsis?
14:47:36 <dons> it messes up my haskell.org frontpage
14:47:42 <tobias_tud> so i can lookup the key from a given value
14:48:31 <tobias_tud> dons, but it sounds like an IO-thing, so it is mutable and better then Map?
14:49:05 <dons> mutable and slower than Map, yeah.
14:49:17 <dons> and less flexible, since its not persistent. ah well
14:49:27 <dons> i wonder, has anyone tried a Hash monad running over ST?
14:49:37 <newsham> Data.Map.(!)
14:49:39 <dons> int-e: what do you think? implement HashTable in ST?
14:49:54 <tobias_tud> ... now, i'm confused :-)
14:50:01 <monochrom> hash table could be very fast if someone did some very low level coding.
14:50:47 <newsham> > M.fromList [("test",1), ("this",2), ("out", 3)] ! "out"
14:50:48 <lambdabot>  Couldn't match expected type `Array i e'
14:51:08 <newsham> > M.fromList [("test",1), ("this",2), ("out", 3)] M.! "out"
14:51:10 <lambdabot>  3
14:51:37 <newsham> I assume by "index" you mean the key
14:51:41 <int-e> sounds like a job for  unsafeIOtoST  if you want a quick job
14:52:05 <tobias_tud> nono, i want ti ask 3 and it sould give me "out"
14:52:20 <newsham> how does 3 map to out?
14:52:24 <newsham> you want the inverse map?
14:52:45 <newsham> or are you using that a map has a particular ordering?
14:53:20 <newsham> ?hoogle Map k a -> Map a k
14:53:21 <lambdabot> No matches, try a more general search
14:53:54 <rwbarton> I think M.elemAt m 1 is supposed to return the element with the smallest key?
14:54:34 <newsham> > M.toList (M.fromList [("test",1), ("this",2), ("out", 3)]) `elemAt` 1
14:54:34 <lambdabot>   Not in scope: `elemAt'
14:54:37 <dons> dolio: where's that fannkuch entry, did you make any more progress on it?
14:54:47 <newsham> > M.toList (M.fromList [("test",1), ("this",2), ("out", 3)]) !! 1
14:54:48 <lambdabot>  ("test",1)
14:55:06 <tobias_tud> yes, i need a reverse map. but the problem is, that a immutale map seems to slow if i put a lot in the map. there are over 50 000 elements
14:55:41 <dons> tobias_tud: are you using IntMap ?
14:55:50 <dons> that's probably the best thing, atm , short of a custom structure
14:55:53 <dons> compile with -O2
14:56:06 <dons> what are the key and element types?
14:56:15 <dons> IntMap is usually about twice as fast as Map, fwiw
14:56:31 <dons> should have a look at the inlining on those modules one day
14:56:37 <newsham> > (M.fromList . map swap . M.toList) (M.fromList [("test",1), ("this",2), ("out", 3)])
14:56:38 <lambdabot>  fromList [(1,"test"),(2,"this"),(3,"out")]
14:56:50 <tobias_tud> key is an own data of the form data x = bla int | blub x x | lala String and element type is Int
14:57:11 <dons> ah interesting.
14:57:29 <dons> do you have a small example that demonstrates the performance problem?
14:57:31 <tobias_tud> and IntMap is really much faster? but it looks that its immutable too
14:57:43 <dons> IntMap is much faster than Map, yes.
14:57:52 <dons> HashTable is around Map like speed, maybe slower.
14:58:12 <dons> you can hunt around on hackage.haskell.org for other more specialised lookup structures too
14:58:46 <dons> the main speed issue will be how effective your comparison function is for your key type
14:58:56 <tobias_tud> i can give you the code and i can tell you that i query and insert many many values
14:59:16 <newsham> tobias: codepad.org is useful
14:59:22 <dons> if you had a complete program, that say, generated the values, and did some things typical that would illustrate the problem, that might be useful
14:59:29 <dons> you could put it on hpaste.org
14:59:39 <dons> also, say how you compile them, how you produce the values
14:59:47 <newsham> hpaste doesnt syntax/type check, compile or run it
14:59:50 <dons> do you read them from a file?
14:59:51 <hpaste>  tud_tobias pasted "map" at http://hpaste.org/8343
15:00:31 <tobias_tud> http://hpaste.org/8343?lines=true#a0
15:00:32 <dons> ah, maybe strict insertion?
15:00:36 <tobias_tud> ah, im stupid
15:00:36 <dons> insertWith' ?
15:01:02 <dons> insertWith', insertWithKey'
15:02:33 <tobias_tud> i am compiling with -O2 and there are about 55569 SVars. data Formula = And Formula Formula | Or Formula Formula | Not Formula | Var Int | SVar String
15:03:13 <tobias_tud> and only SVars, No And, Or, Not, Var
15:04:39 <tobias_tud> ah, insertWith seems to be interesting.
15:07:56 <tobias_tud> no, insertWith is not a good choice, because it replaces the old value.
15:07:57 <dons> how big are the strings?
15:08:18 <dons> you can combine the old and new values, if that's useful
15:08:30 <dons> saving you a lookup and then insert.
15:08:32 <tobias_tud> ten characters
15:08:39 <dons> there's also update/modify/ et al
15:09:00 <dons> i'd probably write that as Var {-# UNPACK #-}!Int -- if these are common
15:09:06 <dons> speed up comparisons a bit
15:09:16 <newsham> are you using the map the right way?  it sounds like you're saying you want to do lookups and inserts based on the value (a) not the key (k)
15:09:26 <newsham> which might mean you're using k and a backwards
15:09:36 <rwbarton> I think you want insertLookupWithKey
15:10:37 <tobias_tud> yes, insertLookupWithKey sounds better
15:11:14 <rwbarton> That should save you a factor of 2 on Data.Map operations, since your current code always traverses the map twice
15:11:18 <rwbarton> .
15:12:06 <tobias_tud> yes, the first time i need the Formula as a key to do a lookup if a formula is in the map. if Formula f is in the map, then i return the value (Int). the next time i have some Ints and i want to replace the Ints with the Formulas
15:13:01 <newsham> perhaps you want a set of formulas and a map of Ints to formulas?
15:13:09 <tobias_tud> okay, factor 2 sounds good :-). IntMap a is Map Int a?
15:14:19 <newsham> oh, nevermind you said you need both lookups
15:15:08 <dons> tobias_tud: yes, IntMap is Map Int a, basically
15:15:38 <int-e> dons: hmm, I almost forgot, I had a hashtable implementation lying around that works with IO and ST. http://rapidshare.com/files/122484744/hash.tar.gz.html ...
15:15:40 <lambdabot> Title: RapidShare: Easy Filehosting
15:16:13 <NewBe> Hello. Can anyone tell me how to compose a module in ghci? I'm constantly having to switch back and forth between the terminal and my text editor. I'd like to do all my work in the terminal.
15:17:50 <dons> you can't compose one in ghci, NewBe. the editor is where it's at.
15:18:16 <dons> you might want to look into editor integration with ghci
15:18:28 <tobias_tud> int-e: and is your hashtable efficient? :-)
15:18:28 <dons> so you can hit one comand to type check or run the current buffer
15:18:34 <noteventime> NewBe: Use emacs :)
15:19:12 <dons> xmonad + vim is also one key reloading :)
15:19:44 <noteventime> I still have to try xmonad, I wonder if apt has it
15:20:02 <noteventime> Neat, it does
15:20:11 <dons> i should hope so.
15:21:35 <tobias_tud> int-e: is your hashtable implementation really fast?
15:25:31 <newsham> "screen" works well for switching between two windows (ie. editor + ghci)
15:25:50 <newsham> of course you have to remember to save, and reload
15:26:26 <alsonk_> is the HaRP package still alive?
15:30:30 <dbueno> @seen dcoutts
15:30:30 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 23h 14m 14s ago.
15:30:35 <dbueno> @seen dcoutts_
15:30:35 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 1d 3h 41m 52s ago.
15:31:54 <int-e> tobias_tud: it's a bit (~20%) slower than Data.HashTable, so, no.
15:33:35 <tobias_tud> perhaps an external database is faster?
15:44:19 <jadrian> hmm haven't programmed in haskell in ages and forgetting about the details
15:44:32 <jadrian> are we supposed to export classes and instances?
15:44:48 <jadrian> or are they always public
15:46:39 <wolverian> export
15:49:06 <dons> instances are always exported
15:49:27 <Zao> And polluting builds with warnings about orphans.
15:50:17 <jadrian> ah ok I was going to ask how to export an instance...
15:51:09 <jadrian> are we going to get class aliases with haskell'?
15:51:40 <jadrian> I remember some talk about that but then didn't follow
16:03:28 <vixey> :t unfoldrp
16:03:35 <lambdabot> forall b a. (b -> Bool) -> (b -> (a, b)) -> b -> [a]
16:04:06 <dibblego> ?Src unfoldrp
16:04:06 <lambdabot> Maybe you meant: rc src
16:04:10 <dibblego> ?src unfoldrp
16:04:10 <lambdabot> Source not found. Maybe you made a typo?
16:05:17 <idnar> unfoldrip
16:05:19 <idnar> heh
16:07:16 <vixey> :t let unfoldrp p split b = if p b then [] else case split b of (a,b) -> a:unfoldrp p split b in unfoldrp
16:07:17 <lambdabot> forall t a. (t -> Bool) -> (t -> (a, t)) -> t -> [a]
16:07:59 <dolio> dons: I haven't looked at it in a couple days. I've been busy. I looked at it a while after I pasted it for you, but no obvious improvements jumped out at me.
16:08:47 <dolio> dons: http://hpaste.org/8271
16:10:40 <Lord_Illidan> hi guys, I got a problem with lambda notation
16:11:02 <Lord_Illidan> If I have something like this, for instance : addNum n = \m -> n+m
16:11:39 <Lord_Illidan> does that mean that addNum takes an argument n and defines another function that takes another argument, and adds that argument and the first one?
16:11:55 <ecks> hello, has anyone had experience with gtk, im trying to get an actual listStore object when a user clicks on a row and im not sure how its done
16:12:25 <vixey> Lord_Illidan: I think the best way to think about this is looking at the type, (Num a) => a -> a -> a
16:12:44 <dibblego> Lord_Illidan, consider -> to be right-associative, so it is equivalent to addNum n m = n + m and addNum = \n m -> n + m and addNum = (+)
16:12:55 <Lord_Illidan> the type is addNum :: Int -> (Int -> Int)
16:13:03 <ecks> C seems to have a "gtk_tree_model_get" function but gtk2hs doesnt have it, the closest it has is "treeModelGetValue" but that returns a GenericValue and im not sure what to do with it
16:13:06 <dibblego> Lord_Illidan, right, those parentheses are redundant
16:13:18 <Lord_Illidan> ah
16:13:19 <dibblego> a -> b -> c is the same as a -> (b -> c)
16:13:57 <geezusfreeek> Lord_Illidan: and addNum m n = m + n is the same as addNum m = \n -> m + n
16:37:06 <vixey> hm
16:37:11 <vixey> why don't lambdabot have Mu
16:37:14 <vixey> a
16:38:14 <asolove> #happs
16:41:29 <vixey> :)
16:46:14 <dons> dolio: ok, saved it.
16:48:45 <Staz> http://hpaste.org/8332 <-- Hopefully I have found a time where more people are awake :)
16:48:56 <dolio> dons: Fooling with the shootout version a bit, I rewrote it to use a copy function written in haskell (via readIntOffAddr and writeIntOffAddr) like the ST/uvector versions use, and it slows it down to around the uvector speed.
16:49:18 <Staz> How would I go about evaluating something like "P[[program output 5; output 9]] ()" ?
16:49:28 <dolio> dons: So, unless there's some memcpy thing for MutableByteArray#s I'm not seeing, the one with Ptrs may always be a little faster.
16:49:36 <Staz> I have an exam coming up soon and am certain I will get something like this :)
16:49:40 <vixey> hi Sta
16:49:41 <ddarius> Staz: You'd apply the definitions of P mechanically.
16:49:46 <vixey> hi Staz
16:49:49 <Staz> hey
16:49:55 <dolio> I'm still not sure why the ST version is a few seconds slower than the uvector version on 11.
16:51:32 <dons> dolio: we can always ffi bind memcpy :)
16:51:34 <Staz> I have attempted the first few lines, but get very stuck very quickly :)
16:51:38 <dons> its in Data.ByteString.Internal
16:52:00 <dons> dolio: its often safe to cast MutableByteArray#s to Addr#
16:53:32 <dolio> Ah.
16:54:09 <dons> i think uvector has a memcpy down in there somewhere
16:54:20 <dolio> A wrapper around that would probably be a good addition to STArray and uvector (if it's not in the latter already).
16:54:31 <dons> ah no, in ndp.
16:55:02 <dons> foreign import ccall unsafe "__hscore_memcpy_src_off" memcpy_ba_baoff :: RawBuffer -> RawBuffer -> Int -> CSize -> IO (Ptr ())
16:55:05 <dons> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/Arr/BUArr.hs
16:55:06 <lambdabot> http://tinyurl.com/5nu44z
16:55:16 <dolio> The STUArray vs. MUArr thing really puzzles me, though.
16:55:27 <dons> mm
16:55:34 <dolio> Because the only difference between the two is unsafeRead/Write vs. read/writeMU.
16:55:40 <dons> inlining (?)
16:55:47 <dons> or maybe how well the classes specialise?
16:55:55 <dolio> Possibly.
16:56:00 <dons> should be easy to look at the core for a small example
16:56:08 <dons> STUArray's aren't nearly as aggressive as uvector
17:02:20 <ecks> hello, what version of gcc is ghc supposed to work with?
17:05:02 <hpaste>  staz pasted "What I have evaluated so far" at http://hpaste.org/8344
17:05:45 <Staz> err.. "Note : let s1 = (1/input)" should be "Note : let s1 = (i/input)"
17:09:42 <dons> ecks: all of them
17:17:03 <ecks> wtf, i get "timer_create: Operation not supported" for all the packages that refer to ghc-6.8.2
17:17:06 <hpaste>  dolio pasted "ST vs. uvector benchmarks" at http://hpaste.org/8345
17:18:17 <dons> ecks: have you googled for that error?
17:18:18 <hpaste>  dolio annotated "ST vs. uvector benchmarks" with "uvector version" at http://hpaste.org/8345#a1
17:18:41 <dons> ecks: http://www.haskell.org/pipermail/haskell-cafe/2008-April/041328.html
17:18:42 <lambdabot> Title: [Haskell-cafe] Re: trying to install ghc-6.8.2 both binaries and sources, http://tinyurl.com/59rap8
17:19:20 <ecks> dons: yea, i saw that and thats why i asked what version of gcc i should use
17:19:33 <dons> yeah, looks like that might be the issue then
17:19:47 <dons> dolio: looking
17:19:57 <hpaste>  dolio annotated "ST vs. uvector benchmarks" with "timing" at http://hpaste.org/8345#a2
17:20:50 <ecks> i am installing it right now on my other version and it didnt complain, but it has gcc-4.2.2 as opposed to the other one which has 4.1.2
17:22:39 <dons> dolio: interesting STUArray's not inlining
17:22:47 <dons> $wa :: forall s_ahT. Data.Array.Base.STUArray s_ahT Int Int -> Data.Array.Base.STUArray s_ahT Int Int -> Int#
17:22:50 <dons> that kind of thing
17:23:12 <dons> and elsewhere.
17:24:01 <electronx> is that haskell 6.8.3 real?
17:24:06 <dons> some things more polymorphic than it needs to be
17:24:13 <dolio> dons: Well, note I don't have an inline pragma on copy in the ST version.
17:24:14 <electronx> i can see packages in the download dir?
17:24:22 <dolio> dons: Adding one makes it much, much slower on my machine.
17:24:55 <dons> no, i was thinking there's some things in STUArray's definition that need to be tuned
17:25:00 <dons> unpack pragmas on the length hints?
17:25:05 <ecks> hey it worked on gcc.4.1.2 on my other comp too, weird
17:25:19 <dons> data STUArray s i a = STUArray !i !i !Int (MutableByteArray# s)
17:25:27 <dons> i wonder if its compiled with -funbox-strict-fields
17:25:53 * dons tries
17:36:29 <dons> there's definitely some differences in how well STUArray gets unboxed
17:36:44 <dons> i've workers in STUArray that look like this,          Int#
17:36:45 <dons>          -> Int
17:36:45 <dons>          -> State# s_aot
17:36:45 <dons>          -> (# State# s_aot, () #)
17:37:50 <dons> that i can't get rid of, dolio
17:37:52 <dons> hmm
17:39:03 <dons> though i've got them running at the same performance now.
17:40:06 <dons> both look pretty good, actually
17:41:27 <hpaste>  dolio annotated "ST vs. uvector benchmarks" with "ptr version" at http://hpaste.org/8345#a3
17:41:29 <dons> almost the same code generated, dolio
17:41:39 <dolio> Ah, good then.
17:42:18 <dolio> If you eliminate the difference between uvector and ST, then the only other thing is improving copy performance for MutableByteArray#s, I think.
17:42:42 <dons> ST is winning now
17:42:53 <dolio> Uh oh. :)
17:43:20 <hpaste>  dons annotated "ST vs. uvector benchmarks" with "ST vs UVector" at http://hpaste.org/8345#a4
17:43:36 <dons> just added some type annotations, basically
17:44:26 <dolio> Oh, you don't have copy inlined on uvector.
17:44:34 <dons> wasn't needed
17:44:48 <dolio> Hmm. It made a difference here, I think...
17:44:51 <dons> ah, uvector is still winning maybe
17:45:01 <dons> 1.219 vs
17:45:02 <dons> 1.537
17:45:09 <dons> dolio: i couldn't see any difference in the final core.
17:45:13 <dons> everything is inlined into 'main'
17:45:17 <dons> one huge function
17:45:45 <dons> oh, you should, module Main (main) where
17:45:51 <dons> since that let's ghc be more aggressive.
17:45:53 <dafra> what's uvector ?
17:46:09 <dons> dolio: restrict the export to a single top level function, then ghc knows there's only a single use
17:46:14 <dons> so it will always inline
17:46:22 <dons> dafra: an alternative arrays library
17:46:42 <dafra> @src UVector
17:46:43 <lambdabot> Source not found. You untyped fool!
17:47:02 <dolio> dons: Ah, yeah, that may be the difference. I forgot to do that.
17:47:03 <dafra> untyped ? me ?
17:47:18 <dons> dafra: its on hackage
17:47:38 <dafra> @source UVector
17:47:38 <lambdabot> UVector not available
17:47:55 <dolio> You want lambdabot to paste the source of the entire module here? :)
17:48:47 <dolio> dons: -funbox-strict-fields was the difference, then?
17:50:30 <dons> dolio: oh, hmm, i was also compiling 'arrays' with that, yes.
17:50:35 <dons> i should check if that was the issue.
17:50:36 <dafra> cool, i need fast array for my app
17:53:11 <dons> dolio: no, that made no difference
17:53:22 <dons> so i suspect it was exporting all the functions from the module
17:53:25 <dons> let's try to confirm that.
17:53:28 <dolio> Hmm.
17:53:39 <dons> yes, that's it.
17:53:50 <dons> all the inlining breaks down if you use: module Main where
17:54:05 <dons> though hmm, speed seems unaffected on my box.
17:54:09 <dons> its radically different code though
17:56:10 <dolio> Something else must be going on with the fannkuch benchmark, then, because it's still significantly slower here for me.
17:56:32 <dons> let's see.
17:56:37 <dolio> Even with 'module Main (main)'
17:57:42 <dolio> 16 - 17 seconds vs 12 - 13 seconds.
17:58:08 <dons> its heavily nested core, i note
17:58:15 <dons> compared to the 'hand written' core version
17:58:33 <dons> which is 6s here, versus the ST version's 10s
17:58:52 <dolio> Your computer's too fast. :)
17:59:24 <dons> still, a lot more code being generated too, in the ST version
18:04:54 <gwern> hm. no one seems interested in my mueval
18:05:04 <Cale> mueval?
18:05:07 <gwern> I guess dons is the only haskell rockstar :)
18:05:25 * gwern envies dons the women, the booze, and whatever drugs a haskeller would use. lsd, maybe
18:05:29 <gwern> Cale: see -cafe
18:05:49 <Cale> ah, I haven't been watching the mailing lists at all lately :)
18:06:18 <dons> gwern: i figured you'd just update lambdabot to not depend on hs-plugins?
18:06:22 <gwern> Cale: oh. in that case: it's the evaluation facility of lambdabot, split out as a GHC API implementation embodied in a CLI tool
18:06:53 <gwern> dons: I will, eventually. first I want feedback on mueval before I break lambdabot. also, doesn't lambdabot use hs-plugins for more than just >? I thought it did
18:07:09 <dons> it did, formerly
18:07:49 <gwern> oh. so what does it use for state and config changes now? (that being what I have a vague memory of it using hs-plugins for)
18:08:06 <Cale> gwern: nice!
18:08:38 <eu-prleu-peupeu> i have this c++ project to finish up, but i just want to code in haskell, so i spend my time reading beginner haskell stuff, instead of coding for the project :/
18:08:48 <heavensrevenge> ello
18:08:48 <Cale> If you're familiar with the GHC API, you might want to have another look at hs-plugins itself and see whether more of it could be trivialised.
18:09:00 <Cale> heavensrevenge: hi
18:09:00 <ddarius> eu-prleu-peupeu: Write a C++ code generator in Haskell.
18:09:07 <eu-prleu-peupeu> what is the cure for my disease ?
18:09:18 <gwern> Cale: was that a sensible reply? I've been struggling with the pithy one-liner of what mueval is. I know what it is, but it seems hard to explain
18:09:18 <eu-prleu-peupeu> oh, i have a schedule :(
18:09:21 <eu-prleu-peupeu> its august
18:09:32 <heavensrevenge> there should be a cabal-install package in debian
18:09:33 <Cale> eu-prleu-peupeu: The cure is to finish up the stuff you have to do in C++ so that you never have to write C++ code ever again ;)
18:09:48 <eu-prleu-peupeu> 29th of july to be precise :/
18:09:56 <ddarius> That's more than enough time.
18:09:57 <heavensrevenge> then all the rest of the cabal packages/libs would be pretty much accessable
18:10:28 <gwern> yes, cabal-install is generally pretty nice alright
18:10:47 <eu-prleu-peupeu> i dont code a line of haskell because i have the project to do, and i dont do the project because i want to code in haskell so i spend my time reading :/
18:10:48 <heavensrevenge> since it now has a cabal upgrade :)
18:10:50 <eu-prleu-peupeu> bahhh
18:11:24 <heavensrevenge> i luv haskell, im watcing a video lecure from germany
18:11:26 <heavensrevenge> pretty cool
18:11:34 <Cale> gwern: If you're asking whether that summary of what mueval does made sense, then yeah, I get what it is from that :)
18:12:04 <gwern> heavensrevenge: unfortunately, if you can't bring yourself to code your project in either haskell or c++, there's not a lot we can do for you...
18:12:17 <Cale> gwern: you mean eu-prleu-peupeu
18:12:47 <eu-prleu-peupeu> i dont have time to remake in haskell what i have already done in c++
18:13:57 <gwern> dag, I saw heavensrevenge praise of the video and confused it with eu-prleu-peupeu
18:14:49 <ddarius> eu-prleu-peupeu: No one said to do that.
18:15:40 <gwern> and the one example I've seen of haskell/c++ hybrid, qthaskell, had an atrocious build process, so I couldn't recommend using both languages simultaneously, really
18:16:17 <jaj> eu-prleu-peupeu: you could add C++ support to FFI, then program the remainder of your project in Haskell and include it via FFI
18:16:17 <gwern> incidentally, qthaskell bears out my maxim 'if it's not on hackage, it doesn't exist'. I don't think I've seen anyone but me and the original ANN ever mention it
18:16:36 <dolio> I've compiled it before.
18:17:11 <eu-prleu-peupeu> c++ support is always a pain because of the horrible name mangling...
18:17:21 <dolio> It didn't look particularly easy to use.
18:17:22 <eu-prleu-peupeu> ...it depends from compiler to compiler :/
18:17:28 <ddarius> gwern: C++ + anything (including C++) is pretty atrocious.
18:18:16 <jaj> that's because of the horrible side effect of the ++ operator ;)
18:18:24 <eu-prleu-peupeu> ah ah
18:18:29 <gwern> ddarius: so I've heard, from many people
18:21:34 <eu-prleu-peupeu> anyway
18:22:01 <eu-prleu-peupeu> check this sound: http://www.todaysbigthing.com/2008/03/10
18:22:01 <lambdabot> Title: Predator: the Hip Hopera is Today's BIG Thing - MAR 10, 2008
18:22:02 <eu-prleu-peupeu> :P
18:29:18 <eu-prleu-peupeu> hip hop at its best
18:30:02 <jaj> it's flash so I can't see it
18:30:21 <eu-prleu-peupeu> oh too bad
18:30:23 <eu-prleu-peupeu> im off
18:30:28 <eu-prleu-peupeu> you should try gnash instead
18:30:30 <eu-prleu-peupeu> it works fine...
18:30:39 <eu-prleu-peupeu> bye
18:30:54 <jaj> yeah but no, I prefer the web less flashy
18:31:00 <jaj> bye
18:46:03 <dons> Lemmih: the dbus bindings are missing some config.in or .h files?
18:46:19 <dons> not building out of the box, anyway
18:54:39 <ddarius> @tell edwardk You may this other paper by Hagino interesting.  I don't think I've read it before even though it is right there: http://www.tom.sfc.keio.ac.jp/~hagino/cclc.pdf
18:54:40 <lambdabot> Consider it noted.
19:06:59 <nus> What's the current situation with incremental compilation in Haskell? Particularly in GHC? (or am I better off to #ghc for such kind of questions?)
19:07:01 <hpaste>  dolio annotated "ST vs. uvector benchmarks" with "new benchmark" at http://hpaste.org/8345#a5
19:14:10 <Cale> nus: hs-plugins and the GHC API support that sort of thing.
19:14:24 <Cale> nus: and you can see it at work in lambdabot:
19:14:38 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
19:14:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:15:41 <Apocalisp> Do you know of any papers about using continuation queues to solve tail-call optimization?
19:15:52 <ddarius> Apocalisp: wtf?
19:16:03 <Apocalisp> never mind then
19:19:13 <olsner_> > fix$(0:).(1:).(zipWith(+)`ap`tail) -- Cale surely meant something more like this :P
19:19:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:19:36 <Cale> > fix ((0:) . scanl (+) 1)
19:19:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:20:20 <nus> Cale, IIUC, it ends presented as selfupdating "thunk", right? I'm thinking more in line of how do I arrange application runtime "Lispish" way, with REPL and live updates Is this feasible at all?
19:20:47 <olsner_> hmm, scanl... touché
19:21:00 <Apocalisp> I'm not sure what the right terms are here, but it would be something like a function with a side effect to tell the machine "call me again with these parameters".
19:21:12 <Cale> nus: Hmm, actually, the eval function is in IO
19:21:26 <Cale> nus: So it probably evaluates when that IO action is executed.
19:21:37 <Cale> eval :: Typeable a => String -> [Import] -> IO (Maybe a)
19:21:49 <olsner_> or fix$(0:).scanl(+)1 if you remove unnecessary parens and whitespace
19:22:13 <Cale> (and there's a more complicated version as well, for collecting the error messages, and passing additional compilation options)
19:23:05 <hpaste>  dolio annotated "ST vs. uvector benchmarks" with "pointer benchmark 2" at http://hpaste.org/8345#a6
19:23:13 <ddarius> Apocalisp: Isn't that exactly what a recursive call does?
19:23:21 <Cale> nus: Of course, if you were to wrap that in a call to unsafePerformIO (which actually would be reasonably sane, so long as you're not using template haskell, the compiler can be thought of as a pure function)
19:23:22 <vixey> olsner: or fix (((((\tail -> (0:tail)). (scanl (\x y -> (x) + y) (1)))))) if you add unnecessary parens and whitespace and eta expand
19:23:37 <Cale> then you'd get something which ran the compiler when the thunk was forced
19:23:52 <augustss> andyjgill: Are you in Kansas now?
19:24:03 <andyjgill> Yes. In Kansas!
19:24:10 <olsner_> vixey: :)
19:24:21 <andyjgill> Got here a couple of days ago.
19:24:28 <augustss> andyjgill: in the middle of nowhere :)
19:24:57 <andyjgill> The middle of the US, actually :-)
19:25:26 <Apocalisp> ddarius: Yes, I suppose it is.
19:27:01 <Cale> nus: Oh, perhaps I know what you're getting at... as far as state goes, your application would have to manage that itself.
19:27:37 <nus> Cale, it the typechecker available at the runtime?
19:27:40 <nus> s/it/is/
19:27:46 <Cale> nus: yes, it's typesafe-eval
19:28:05 <Cale> The typechecker *must* run, because the meaning of Haskell code can depend on the types involved
19:28:34 <Cale> and then the type of the result of evaluation is checked against the desired type, and they have to match, or you get Nothing back.
19:28:49 <Cale> (Otherwise, you get  Just x, where x is the result of evaluation)
19:29:29 <SamB_XP_> Cale: but it would check the type before evaluating the value, no?
19:29:35 <Cale> If you want more detailed control over the typechecking process, the GHC API exports lots of things in that regard... I haven't looked closely at that though.
19:29:40 <Cale> SamB_XP_: yes
19:34:24 <nus> Looks like I need to educate myself much more w.r.t. the API, and thanks for the input, Cale, evaluating (-:
19:35:08 <atp> hi guys
19:35:57 <atp> does anyone know who qwe1234 on reddit actually is?
19:36:47 <dolio> The most badass C++ coder ever?
19:36:55 <nus> What's the fuss with reddit? A trendy aggregator?
19:37:13 <atp> i'm not sure i'd describe it as any more trendy than any other site really
19:37:24 <atp> increasingly it seems as though its time has passed
19:37:30 <atp> (i only read proggit, though)
19:37:52 <atp> dolio: i'm actually curious because every now and then he makes a comment that makes me wonder what his background really is
19:38:05 <atp> dolio: ie, one that seems unusually informed for a C++ defender
19:38:41 <atp> maybe it's because of usenet, but i actually like trolls that make informed quips from time to time
19:38:48 <atp> it keeps people on their toes
19:39:16 <SamB_XP_> I wish poppavic would do that
19:39:36 <dolio> I pretty much ignore everything he says, so I suppose I'm not being kept on my toes.
19:39:41 <SamB_XP_> actually, I finally got around to putting him on /ignore
19:41:01 <atp> i find him fairly amusing, from a "yhbt hand" perspective
19:41:09 <dolio> Then again, I've been actually reading comments and stuff on reddit less and less lately.
19:41:13 <atp> me too.
19:41:25 <atp> proggit has gotten pretty disappointing and ltu hasn't picked up the slack.
19:41:31 <dolio> Or even visiting the site, since there are even fewer actually interesting articles than there used to be.
19:43:09 <atp> like this: http://www.reddit.com/info/6m9l2/comments/c049qen  ... those are ML types, aren't they?
19:43:10 <lambdabot> Title: reddit.com: Some C++ Gotchas
19:43:40 <atp> makes you wonder
19:43:55 <olsner_> is qwe1234 on reddit related to the one in @quote?
19:44:04 <atp> which?
19:44:06 <atp> probably
19:44:08 <vixey> that's not valid ML
19:44:13 <dolio> Yeah, those are quotes of stuff he's said on reddit.
19:44:25 <vixey> that's not valid ocaml*
19:44:26 <atp> vixey: i wouldn't know, i only have superficial familiarity with ML
19:44:35 <vixey> I'm tell ing you
19:44:39 <atp> thanks
19:45:13 <olsner_> oh, so they are reddit quotes originally? I always assumed they were from #haskell
19:45:13 <shapr> olsner_: Same guy, yes.
19:45:16 <shapr> nah
19:45:31 <atp> olsner_: i sort of doubt he would come here, except to harass us :)
19:45:50 <dolio> dons: In that newer benchmark, uvector outperforms ST, and Addr# seems to edge out uvector a bit.
19:46:06 <dolio> dons: So it's copying isn't the only difference.
19:46:07 <SamB_XP_> @quote qwe1234.*
19:46:08 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
19:46:14 <SamB_XP_> @quote qwe1234.*
19:46:15 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
19:46:18 <SamB_XP_> @quote qwe1234
19:46:18 <lambdabot> qwe1234 says: all you happened to have demonstrated is that you suck at writing assembly code.
19:46:26 <shapr> He sounds like TopMind
19:46:35 <shapr> Or a variety of internet trolls.
19:47:03 <atp> he's a great troll
19:47:07 <atp> by which i mean he trolls well
19:47:09 <atp> not that he's great
19:47:14 <shapr> yeah, I can dig it.
19:47:29 <atp> he's especially good at getting smug lisp weenies to go apeshit
19:47:38 <atp> (i like lisp, fwiw)
19:48:11 <atp> not that that's particularly difficult, as they seem unusually willing to rise to any bait
19:48:14 <atp> especially on proggit
19:48:58 <SamB_XP_> is bit actually called proggit now?
19:49:11 <SamB_XP_> s/bit/it/
19:49:52 <atp> i don't think so
19:50:17 <atp> was there a motion to officially call it that?
19:50:37 <olsner_> argh, clicking the logo on programming reddit always takes me to the "normal" reddit, which I *never* want to go to
19:50:39 <Cale> I rather dislike that abbreviation.
19:51:11 <atp> Cale: what would be better?  i don't much like it either, but typing programming subreddit gets annoying after a bit
19:51:15 <Cale> olsner_: click the link which says "PROGRAMMING"
19:51:15 <SamB_XP_> okay, it's just that I'd heard that programming.reddit was no longer programming.reddit -- I wasn't sure if that was literally true or not
19:51:43 <Cale> SamB_XP_: well, it's now www.reddit.com/r/programming
19:51:53 <SamB_XP_> eww ick
19:51:56 <atp> did that compsci reddit suggestion ever go anywhere?
19:51:56 <SamB_XP_> why the hell?
19:52:03 <olsner_> Cale: oh, that's a quite recent thing :) and it only appears on *some* pages under the programming reddit (i.e. not that comment page linked previously)
19:52:18 <vixey> http://www.reddit.com/r/types
19:52:19 <lambdabot> Title: Types and typed programming
19:52:19 <atp> SamB_XP_: i think they decided that people should be able to make their own "reddit communities"
19:52:34 <SamB_XP_> atp: what does that have to do with anything?
19:53:23 <atp> SamB_XP_: i don't know, it's simpler than screwing with DNS?
19:53:38 <olsner_> screwing with DNS is pretty easy though
19:53:45 <SamB_XP_> I guess you mean they were too lazy to make that work?
19:53:52 <atp> no, it worked before
19:53:57 <atp> they broke it, on purpose i think.
19:54:23 <atp> it's annoying, but maybe they're thinking of internationalizing?
19:54:32 <atp> you can put unicode in a url
19:54:46 <atp> or rather in a path
19:54:47 <atp> sorry
19:55:01 <atp> i'm just hypothesizing, i have no clue really.
19:57:04 <dolio> dons: I guess the ST code looks less unboxed again.
19:57:10 <dolio> dons: And there's a lot more of it.
19:57:16 <atp> which bench is this?
19:58:04 <dolio> Benchmarking pieces of the fannkuch shootout program to figure out why STUArrays are slower than MUArrs and why they're both slower than Addr#.
19:58:26 <atp> hm
19:58:36 <dolio> Because the current entry is terrible.
19:58:49 <atp> yeah.
19:59:27 <atp> that's interesting... doesn't STUArray just reduce to an Addr# usually anyway?
19:59:41 <dolio> No, the arrays use MutableByteArray# underneath.
19:59:51 <dolio> That is, I think uvector does, too. STUArray definitely does.
20:01:10 <atp> isn't that a cosmetic difference though (forgive me for asking, i don't actually know much about this stuff).  Shouldn't MutableByteArray# just be a pointer with some dimension information?
20:01:37 <dolio> I don't think it has any dimension information. It's just a primitive type.
20:02:06 <dolio> dons says you can cast it to Addr# safely in some circumstances, but you'd have to ask him about taht.
20:02:29 <atp> hm
20:02:49 <atp> because if it's just a pointer underneath, and Addr# is just a pointer... maybe the answer has to do with the GC
20:02:59 <atp> interesting
20:06:28 <dolio> I guess MutableByteArray# does contain its length.
20:07:07 <atp> perhaps the issue then is that with the array types you're doing a lot of unnecessary bounds checks?
20:07:58 <atp> that seems unlikely to make much difference on modern hardware, though
20:07:59 <dolio> I don't think it does bounds checks.
20:08:20 <atp> have you dumped the assembly?
20:08:40 <dolio> Bounds checking is much higher up. Part of the implementation of STUArray, for instance.
20:09:06 <dolio> And MUArr doesn't do any bounds checking.
20:09:31 <dolio> You can read/write with indices outside the declared size of your array.
20:10:11 <dolio> No, I haven't looked at the assembly, just the core.
20:10:40 <atp> have you been hacking on this benchmark stuff for a long time?  it seems pretty cool.
20:10:52 <dolio> Just tonight.
20:11:41 <dolio> I rewrote the fannkuch benchmark a few days ago.
20:11:52 <atp> how does your version compare?
20:12:32 <dolio> Well, on my machine, the one on the shootout runs in around 10 seconds, the one with uvectors takes 12, and the STUArray one takes 16 seconds.
20:12:48 <atp> and the C?
20:13:06 <dolio> Haven't run that on my machine.
20:13:13 <dolio> It's winning on the shootout.
20:13:17 <dolio> I think.
20:13:22 <atp> the C or the Haskell?
20:13:24 <atp> let me check
20:13:28 <dolio> C.
20:13:43 <dolio> Yeah, ICC.
20:14:04 <dolio> Haskell's around 3x the runtime of the C version.
20:14:33 <atp> ouch.  java is beating us.
20:14:37 <atp> that hurts.
20:44:05 <parag1> what does it mean to have braces in data declaration?
20:44:37 <dolio> It's a record type.
20:45:09 <parag1> kind of like hash?
20:45:21 <dolio> data Foo = Foo1 { a :: Bar , b :: Baz } | Foo2 { c :: Quux , d :: Quuux } is sugar for...
20:46:01 <dolio> data Foo = Foo1 Bar Baz | Foo2 Quux Quuux ; a (Foo1 x _) = x ; b (Foo2 _ y) = y ; ...
20:46:04 <dolio> More or less.
20:46:18 <dolio> There's also some special syntax for working with records.
20:49:15 <parag1> thanks dolio!
20:49:36 <ddarius> @google site:archive.org UsingRecords
20:49:36 <lambdabot> No Result Found.
20:51:43 <parag1> it seems Haskell creates selector functions (a, b, c, d for the case above) if you use this syntactic sugar
20:52:29 <SamB_XP_> it's actually not anything like a hash
20:52:39 <SamB_XP_> it just sorta resembles one
20:53:14 <SamB_XP_> syntactically
20:56:00 * sjanssen thinks it is unfortunate that Perl has permanently stolen the word "hash"
20:59:01 <parag1> On the other hand, I think haskell "case .. of" is probably the closest thing to Perl / Ruby hash
20:59:23 <vixey> what
21:00:22 <SamB_XP_> sjanssen: not really, I'm just speaking his language for him... I still know what a hash really is ;-)
21:00:37 <sykopomp> wtf is a perl hash?
21:00:51 <SamB_XP_> like Python's dictionaries
21:00:58 <sjanssen> sykopomp: dictionary/associative array
21:01:20 <sykopomp> ah
21:22:04 <Jammal> hello
21:27:02 <TomMD> hello jammal
21:27:34 <TomMD> oh, you left, so now I'm talking to a dead room with no jammal... why am I still talking?
21:30:05 <vixey> I'm not quite dead yet
21:30:44 <gwern> heh. so I meant to write 'darn', and I somehow wound up writing 'darcs'
21:30:53 <gwern> (too much haskelling, methink)
21:31:02 <TomMD> gwern: No, its a good sign
21:31:42 <olsner_> gwern: did I mention how darcs vanished all my local changes last week?
21:31:44 <gwern> I mean, they don't even have the same number of letters
21:32:04 <gwern> olsner_: they were terrorists and deserved it
21:32:41 <olsner_> it could've at least put them through a week of torture so that I could've rescued them
21:33:12 <olsner_> *harmless and legal interrogation
21:33:30 <gwern> only heros like jessica lynch are allowed rescue
21:33:39 <olsner_> hmm, who's that?
21:34:18 <gwern> an American Hero, like Pat Tillman
21:39:06 <olsner_> there seems to be some controversy though... "In war, the first casualty is truth." as they say
21:44:14 <TomMD> Yay, connectivity!
21:44:29 <TomMD> @let ping = "pong"
21:44:29 <dons> you found the internets, Tom?
21:44:30 <lambdabot> Defined.
21:44:32 <TomMD> > ping
21:44:33 <lambdabot>  "pong"
21:44:39 <dons> hehe
21:44:49 <SamB_XP_> TomMD: so how wide is your tube?
21:45:21 <TomMD> I'm on a cable line on US East coast, so typically I don't have issues.
21:45:41 * SamB_XP_ should have explicitly said diameter...
21:46:06 <dons> dolio: i think we should try to implement whatever the current C version does
21:46:15 <TomMD> I knew something was wrong when gwern didn't respond to talk about mueval.
21:46:17 <dons> in say, ST, and look at the asm line by line.
21:46:37 <dons> hey Tom, is there a pureSHA on the way?
21:46:43 <dons> i could probably use it.
21:46:46 <dons> :)
21:47:23 <olsner_> > let pi*r*r = 100 in 2*r -- that many megabits in diameter :P
21:47:23 <lambdabot>  Parse error in pattern at "in" (column 18)
21:47:28 <TomMD> dons: I started one, but wasn't sure if I should finish.  Moderate time investment, it probably won't help me get into any academic program and certainly doesn't lead to a paper.
21:47:42 <dons> that sounds true enough
21:47:53 <dolio> That does what the C version does, essentially.
21:47:59 <TomMD> dons: I will likely be releasing Data.ByteString.Lazy.Num soon and decide on the next library after that.
21:48:05 <dons> dolio: yeah, so hmm, we have to look at the runtime representations then
21:48:11 <dons> dolio: you reckon the algorithm's the same?
21:48:27 <dons> TomMD: is that some parsers for numeric types/
21:49:01 <dolio> dons: I was looking at the C when writing the code. It seemed easier than the existing Haskell implementation. :)
21:49:12 <TomMD> dons: Basically its allows you to treat LPS's as an inefficient unsigned integer.
21:49:21 <dolio> The old haskell one does the same thing as the C, too, of course.
21:49:24 <dons> dolio: right. i agree.
21:49:33 <dons> TomMD: oh, curious
21:49:45 <TomMD> All calculations will be within GF(max (L.length a) (L.Length b))
21:50:01 <dons> oh, a bit like the byte array underneath Integer?
21:50:23 <TomMD> I don't know about that, but probably.
21:50:57 <olsner_> so it should make way for a pure-haskell implementation of integer not requiring gmp? or perhaps just a different way to wrap gmp?
21:51:08 <TomMD> It started from an actual need, but at this point its more for fun.
21:52:15 <TomMD> olsner_: No, for example, if I need a 96 bit uint then I can just use a lps.  Actually, it will suffice for any uint multiple of 8 (operates on bytes, unsurprisingly)
21:52:26 <dons> we've already a pure integer implementation, fwiw.
21:52:52 <TomMD> I remember that - why don't we use it?  Is performance that much different?
21:53:17 <olsner_> oh, I thought the only available implementation used gmp
21:53:29 <TomMD> Its odd to me that I have this huge laundry list of BSD code and a key GPL dependency.
21:54:27 <jcreigh> oh, is GMP GPL'd?
21:54:49 <jcreigh> oh, LGPL
21:55:16 <sjanssen> gwern: speaking of mueval, how is that going?  Is the latest version available somewheres?
21:55:18 <TomMD> jcreigh: Yeah.  It causes surprisingly few problems - I'm not sure what to make of that.
21:55:27 <sjanssen> ah, I see it is on hackage
21:55:50 <audreyt> hi. quick sanity check question on possible syntax:
21:55:51 <TomMD> Yes - and it is pure Haskell!  Yay, down with FFI bindings ;-)
21:55:52 <audreyt> putStrLn $ $(printf "%s: %9d") name (amount*10)  -- Text.Printf.TH
21:55:57 <audreyt> putStrLn [$p|%s(name): %9d(amount*10)|]          -- Text.Printf.QQ
21:56:06 <audreyt> does the .QQ one seem sensible?
21:56:17 <jcreigh> I don't like licensing problems. I wish everything was BSD. Heck, I wish everything was public domain, except it's not clear that you can actually put something into the public domain.
21:56:18 <gwern> :( no one read my mueval ANN
21:56:36 <sjanssen> gwern: I'm 360 messages behind on my Haskell lists
21:56:55 <gwern> goodness. how many are you on?
21:57:05 <TomMD> gwern: didn't even notice it - reading now!  and a big THANKS!
21:57:10 <sjanssen> gwern: pretty much all of them
21:57:37 <gwern> audreyt: what on earth is [$p|%s(name): %9d(amount*10)|]? looks like linenoise to little ol' non-TH/printf me
21:57:48 <gwern> TomMD: what are you thinking of using it for?
21:58:29 <audreyt> gwern: it's semantically the same thing as the .TH one -- statically checked printf using quasiquoting syntax
21:58:43 <audreyt> # http://haskell.org/haskellwiki/Quasiquotation
21:58:44 <lambdabot> Title: Quasiquotation - HaskellWiki
21:58:48 <gwern> incidentally, I've been wondering whether the output is optimal, you know, the whole 'Expression type:\nresult:'
21:59:32 <sjanssen> gwern++ mueval looks good.  can has darcs repo? :)
21:59:47 <TomMD> gwern: I'd use it as a library to allow remote users to run code.  Can I use it as a library?  No dependencies on 'C' libraries being installed on the platform, right?
21:59:55 <gwern> audreyt: it still looks too perlish to me. I mean, offhand it looks like a list comprehension with a prefix operator consing onto a list which is itself a function application of another prefix...
22:00:18 <sjanssen> gwern: I'd say that mueval should only dump the result of the expression, with a --print-type flag as an option
22:00:21 <olsner_> hmm, hackage feature request: include link to darcs/vcs repository
22:00:25 <gwern> sjanssen: well, I filed a community request yesterday for a repo, which I think is how it works
22:00:44 <gwern> TomMD: C library dep...? I think it's pretty much statically linked
22:00:55 <sjanssen> gwern: yep, just have to wait until the admins catch up
22:01:03 <vixey> QQ looks good to mea
22:01:17 <audreyt> gwern: I see. so would this simplified syntax look too perlish too?
22:01:18 <gwern> ldd shows a number of .so links, but none of them look too unusual...
22:01:22 <audreyt> printf "%s(name): %9d(amount*10)"
22:02:01 <gwern> audreyt: that looks a lot better, although I'm still unsure what %9d is trying to do and why there are no spaces
22:02:14 <vixey> I guess that something like let tail = "%9d(amount*10)" in printf ("%s(name):" ++ tail) is impossible ?
22:02:35 <audreyt> vixey: with QQ, surely possible
22:02:45 <vixey> oh cool
22:02:51 <audreyt> [$p|  %s(name): %(tail) |]
22:03:15 <sjanssen> audreyt: are those spaces significant?  Are consecutive spaces meaningful?
22:03:28 <audreyt> sjanssen: spaces are significant as in printf, I think.
22:03:37 <audreyt> also, you get to write newlines without writing \n
22:03:52 <sjanssen> audreyt: significant whitespace outside of some sort of quote mark is a bit scary in my opinion
22:03:59 <TomMD> gwern: Thats great.  Seeing as you are using the GHC api its just compiled to bytecode and ran, right?  You don't have any optimization plans in the pipe?
22:04:19 <mmorrow> -XQuasiQuotes rock
22:04:25 <audreyt> sjanssen: I see. it may make sense to trip the leading and trailing spaces
22:04:29 <audreyt> *trim
22:04:35 <gwern> TomMD: anyway, I split mueval between a lib and executable which is my usual method, so if you don't like the driver mueval.hs, it should be relatively easy to use the modules and write your own
22:04:56 <gwern> TomMD: so far as I know, Hint doesn't give access to optimization options
22:05:02 <mmorrow> all of the inner is passed to your parse-to(exp|pat) as a string
22:07:36 <sjanssen> audreyt: even internal whitspace sensitivity is a bit funky -- it goes against my expectations at least
22:07:52 <audreyt> *nod*
22:08:15 <gwern> TomMD: if you're interested in looking at hint, see the repo http://www.glyc.dc.uba.ar/daniel/repos/hint
22:08:17 <lambdabot> Title: Index of /daniel/repos/hint
22:08:23 <gwern> maybe it optimizes by default, I have not read enough
22:08:38 <audreyt> sjanssen: [$p|   "%s(name): %(tail)"   |] would make you more comfortable I take it?
22:09:00 <sjanssen> audreyt: yeah
22:09:12 <audreyt> ok, I'll code that up first then. thanks for the feedback :)
22:10:09 <audreyt> btw, for people not working with ghc 6.9, here's a patch for ghc 6.8.3 that makes QQ work:
22:10:12 <audreyt> http://community.haskell.org/~audreyt/qq-6.8.3.diff
22:10:53 * mmorrow finds the qq paper from implementor...
22:11:37 <mmorrow> oh, it's linked to on the wiki http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
22:11:39 <lambdabot> http://tinyurl.com/yo9sa3
22:13:01 <audreyt> once [%p|...|] syntax is relatively stable, [$l|...|] would perform localization using the same syntax
22:13:07 <audreyt> er, I mean [$p|...|].
22:16:59 <mmorrow> heh, i was like whoa what have you done?!
22:20:31 <slava> quasiquoting?
22:20:59 <ddarius> @google quasiquoting in haskell
22:21:00 <lambdabot> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/
22:21:00 <lambdabot> Title: Quasiquoting Support for GHC
22:22:15 <gwern> TomMD: ok, I've added -O2 to mueval
22:22:44 <gwern> interesting, it changes why some malicious examples timeout
22:25:04 <TomMD> Strictness eval, probably
22:25:42 <gwern> makes it worth doing, thgouh. they timeout faster while the 'good' expressions in my test script still complete fine
22:26:41 <TomMD> thats certainly a win if you can notice the difference.
22:27:27 <sjanssen> gwern: I bet you're triggering the non-allocating thread issue in GHC
22:27:42 <sjanssen> gwern: but rlimits still catch that, which is good to know
22:27:46 <gwern> sjanssen: hm? can't say I've heard of that, I think
22:28:01 <sjanssen> gwern: I was blathering about it to you the other day :)
22:28:41 <sjanssen> gwern: if a thread is in a tight loop with no allocations, other threads will not be able to run
22:28:45 <gwern> sjanssen: well, actually, the interesting thing here is that without -O2, some of the expressions would get caught by rlimits only, right? but when I plopped in -O2, I noticed that now some were being killed by the handler I register
22:28:58 <sjanssen> (this is assuming non-threaded, or -threaded with only one OS thread active)
22:29:11 <gwern> I dunno if that is what you mea
22:29:34 <sjanssen> that's actually the opposite of what I expected
22:30:09 <gwern> or maybe it wasn't the rlimit, but the watchdog threads. hum. I forget
22:32:02 <gwern> I've piled on so much stuff I'm not actually sure what is responsible for killing an evil expression :)
22:32:33 <gwern> is it the two handlers, the OS rlimits I call, the two watchdog threads, the nicing/cding/optimization...
22:32:46 <sjanssen> why multiple watchdog threads?
22:33:17 <gwern> sjanssen: well, one watchdogs the interpreter thread, and the other watchdogs the main thread
22:34:20 <gwern> that way, even if the interpreter thread ignores the watchdog signal, the main thread will still respect it and exit, which kills the entire program iirc regardless of how plaintively the threads swear they still have work to do
22:36:01 <povman> what makes uniform-cost search uniform? is there a non-uniform cost search algorithm?
22:36:05 <gwern> (and then the watchdogs call killThread anyway. :)
22:38:26 <vixey> typeclass dispatch should probably be able to work with negation since it's always terminating
22:45:09 <gwern> 'I've got this Ph.D. languages intern whose a big Haskell fan, and [surprisingly] a big Scheme fan, and an ML fan. [But especially Haskell.] He knows functional programming, he knows type systems. I mean, he's an expert.
22:45:11 <gwern> He looked at Scala yesterday, and he told me: "I'm finding this rather intimidating."'
22:46:01 <vixey> really what's weird about scala?
22:46:07 <vixey> I thought it was just java
22:46:23 <gwern> 'The... the the the... the language spec... oh, my god. I've gotta blog about this. It's, like, ninety percent [about the type system]. It's the biggest type system you've ever seen in your life, by 5x. Not by an order of magnitude, but man! There are type types, and type type types; there's complexity...'
22:46:36 <gwern> 'They have this concept called complexity complexity<T> Meaning it's not just complexity; it's not just complexity-complexity: it's parameterized complexity-complexity. (mild laughter) OK? Whoo! I mean, this thing has types on its types on its types. It's gnarly.' http://steve-yegge.blogspot.com/2008/06/rhinos-and-tigers.html
22:46:37 <lambdabot> Title: Stevey's Blog Rants: Rhinos and Tigers
22:47:48 <audreyt> @hoogle String -> ExpQ
22:47:50 <lambdabot> Language.Haskell.TH.stringE :: String -> ExpQ
22:47:50 <lambdabot> Language.Haskell.TH.Lib.stringE :: String -> ExpQ
22:48:31 <audreyt> hm, no, what I'd like is something that parse arbitrary haskell snippet into ExpQ
22:48:41 <audreyt> is there such a thing?
22:49:21 <audreyt> @hoogle HsExp -> ExpQ
22:49:22 <lambdabot> No matches, try a more general search
22:49:49 <gwern> heck, I dunno. the most difficult template haskell I've ever done was to call 'ghc -lib-dir; at compile time and substitute in as a String
22:51:01 <gwern> that actually is one of the most annoying things about the GHC API - you need to find the library directory of ghc at compile-time. the api just won't do it for you. so everyone uses configure or Setup.hs hacks...
23:56:35 <nus> @seen therp
23:56:36 <lambdabot> I saw therp leaving #haskell 7h 7m 23s ago, and .
