00:06:08 <GrayShade> can anyone help me with this? http://hpaste.org/8045 I find it rather strange
00:06:47 <dmwit> No!  Nobody can help you.
00:07:40 <mauke> :t M.lookup
00:07:41 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
00:07:56 <mauke> GrayShade: different monad
00:08:10 <dmwit> I think your second response there is a lie.
00:08:24 <mauke> dmwit: hmm?
00:08:33 <dmwit> Shouldn't there be another layer of []'s there?
00:08:42 <mauke> not if it's in IO
00:08:47 <dmwit> Ah, IO.
00:16:07 <GrayShade> right, thanks
00:47:38 <Saizan> ?src mapAccumL
00:47:39 <lambdabot> mapAccumL _ s []        =  (s, [])
00:47:39 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
00:47:39 <lambdabot>    where (s', y ) = f s x
00:47:39 <lambdabot>          (s'',ys) = mapAccumL f s' xs
00:48:49 <Saizan> ?src mapAccumR
00:48:50 <lambdabot> Source not found. You speak an infinite deal of nothing
00:57:09 <kalven> @hoogle [[a]] -> [a]
00:57:10 <lambdabot> Prelude.concat :: [[a]] -> [a]
00:57:10 <lambdabot> Data.List.concat :: [[a]] -> [a]
00:57:10 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
00:58:00 <ddarius> @hoogle showParen
00:58:01 <lambdabot> Prelude.showParen :: Bool -> ShowS -> ShowS
00:58:01 <lambdabot> Text.Show.showParen :: Bool -> ShowS -> ShowS
01:08:04 <vixey> @src ShowS
01:08:04 <lambdabot> type ShowS = String -> String
01:12:19 <dreixel> hello everyone
01:12:28 <dreixel> I asked this before, and also on the haskell-cafe mailing list, but got no answer
01:13:00 <dreixel> would anyone know if it is possible to define a default type synonym, in an associated type synonym declaration?
01:14:52 <dolio> Apparently you'll be able to, but it's not implemented yet or something.
01:15:34 <dolio> Even in 6.9.
01:18:18 <dolio> (Unless they've fixed it in the past couple days, that is.)
01:21:42 <dreixel> yeah
01:21:52 <dreixel> I assume I should be able to because of the error I get
01:22:05 <dolio> You can try it in 6.9, but it'll give you a bogus error message that tells you you're doing it wrong.
01:22:07 <dreixel> Type declaration in a class must be a kind signature or synonym default
01:22:43 <dreixel> I'm using 6.9.20080309
01:22:52 <dolio> Yeah, that's the one.
01:22:53 <dreixel> but the message is the same with 6.8.2
01:23:01 <dolio> Oh, really?
01:23:20 <dolio> Well, it doesn't work in any case.
01:23:22 <dreixel> yes. Quite some stuff of the type families is already in 6.8.2
01:23:30 <dolio> Either that, or no one knows the right syntax. :)
01:23:39 <dreixel> well, I checked the parser
01:23:43 <dreixel> at least some version of it
01:23:49 <dreixel> and it seems not to be implemented
01:24:03 <dreixel> same thing goes for GADTs in the associated data declarations
01:24:15 <dreixel> (but then the error is a bit worse)
01:24:55 <vixey> > 1+1
01:25:01 <lambdabot>  2
01:26:42 <dolio> Yeah, 6.8.2 is officially very incomplete/wrong with regard to type families, but 6.9 is still missing a lot of stuff, too.
01:26:46 <quicksilver> GADTs + Associated data is untrod ground AIUI
01:26:57 <quicksilver> as in people aren't sure what all the answers are
01:27:06 <quicksilver> (maybe they're not even exactly sure what the questions are?)
01:27:29 <dreixel> :-)
01:27:53 <vixey> Now, let's set a breakpoint on the right-hand-side of the second equation of qsort:
01:27:53 <vixey> *Main> :break 2
01:27:56 <vixey> :S
01:28:10 <dolio> Yeah, how would you use GADTs in that regard? On the parameters that aren't type indices?
01:28:49 <dreixel> well, I don't really need GADTs there (for now)
01:29:02 <dreixel> but I can imagine you would want type equality
01:29:35 <dreixel> you can probably do it some other way, but it might be more convenient to have it at that point...
01:30:47 <dreixel> and, supposedly, the equality constraints of open type functions unify with GADTs
01:30:52 <dreixel> according to http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html
01:30:53 <lambdabot> Title: Research Papers of Manuel Chakravarty
01:42:53 <quicksilver> the thing is I've not seen any really convincing examples of GADT use
01:42:59 <quicksilver> just toy examples in papers
01:43:23 <vixey> didn't like the tagless well typed interpreter?
01:43:24 <quicksilver> let alone convincing examples of how to conflate them with associated types in an useful way
01:43:51 <quicksilver> I don't know if I've seen that one, where is.
01:43:52 <quicksilver> it?
01:44:29 <vixey> http://okmij.org/ftp/papers/tagless-final-APLAS.pdf
01:46:48 <quicksilver> that paper claims not to use GADTs?
01:47:18 <quicksilver> definitely look sinteresting though
01:47:24 <vixey> doh
01:47:30 <vixey> I guess you're right then
01:51:30 <dreixel> convincing examples of GADT use?
01:52:08 <dreixel> http://people.cs.uu.nl/andres/SYB1.html
01:52:09 <lambdabot> Title: "Scrap Your Boilerplate" Revolutions
01:53:13 <dreixel> http://www.di.uminho.pt/~joostvisser/publications/TypesafeTwolevelDataTransformation.pdf
01:53:15 <lambdabot> http://tinyurl.com/6noehg
01:53:29 <dreixel> (Type-safe Two-level Data Transformation)
02:04:59 <cjs> Hm. Can I get haddock to have two -B options to locate libraries?
02:05:51 <cjs> I seem a bit stuck; it looks as if it only uses the last one. So I can give it my ghc libs, or my project libs, but not both?
02:06:04 <cjs> Maybe I need to pass on a gcc option?
02:09:29 <Saizan> cjs: which version of haddock? mine doesn't have a -B option
02:10:17 <cjs> 2.0.0.0
02:10:56 <cjs> I worked it out; I can give it the -optghc="-package-conf ..." option.
02:15:42 <sioraiocht> @src scanr
02:15:42 <lambdabot> scanr _ q0 []     =  [q0]
02:15:42 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
02:15:42 <lambdabot>     where qs@(q:_) = scanr f q0 xs
02:16:11 <sioraiocht> @src scanl
02:16:11 <lambdabot> scanl f q ls = q : case ls of
02:16:11 <lambdabot>     []   -> []
02:16:11 <lambdabot>     x:xs -> scanl f (f q x) xs
02:50:25 <alexander> is there a way of making String -> (a -> b)
02:50:50 <alexander> i know that it can be done in lisp
02:50:53 <Vq^> alexander: for what a and b?
02:50:54 <quicksilver> yes.
02:50:57 <quicksilver> import the compiler
02:51:00 <quicksilver> q.v. hs-plugins
02:51:02 <quicksilver> and metaplug
02:51:27 <alexander> i was thinking of either passing a function name or a lambda function to a program as an argument
02:51:49 <quicksilver> name of existing function -> you probably want to just build up a map yourself.
02:52:02 <quicksilver> lambda function -> you definitely want to import the compiler
02:52:04 <alexander> ok
02:52:11 <alexander> cool :)
02:53:16 <Lemmih> You most likely want to look for a third option, though.
02:54:00 <Vq^> it's a better idea in lisp than in Haskell...
02:57:35 <dmwit> Yeah, that's not such a common thing in well-written Haskell.
03:00:12 <yitz> alexander: another example technique: xmonad spawns the compiler as a separate process to recompile the config file "xmonad.hs" when it notices that the file has changed.
03:00:23 <Vq^> i have actually implemented a small subset of scheme once when i wanted some dynamic behaviour in a program :)
03:00:42 <vixey> Vq^: did it have mutation?
03:01:50 <yitz> Vq^: more often you would write a DSL. A simpler way is to create a custom ghci environment that has the commands you want.
03:02:46 <Vq^> vixey: yes, the interpreter basicly lived inside the IO monad
03:03:34 <Vq^> yitz: i wanted a somewhat restricted interpreter in this case
03:03:57 <shapr> Good morning #haskell!
03:04:14 <vixey> hi shapr"!
03:04:16 <yitz> Vq^: ah, yes, it's hard to control the power of a user in ghci :)
03:04:18 <Vq^> otherwise i agree, using standard haskell to make a DSL is a very nice way to do it
03:04:26 <shapr> hiya vixey, how's code?
03:04:30 <Vq^> hej formarn!
03:04:38 <shapr> hej Vq^ !
03:04:41 <shapr> God morgon!
03:04:43 <vixey> I am really confused :P
03:04:47 <vixey> but I am getting somewhere
03:04:55 <shapr> vixey: That's great!
03:04:59 <vixey> how are you doing ?
03:05:08 <Vq^> shapr: it's past 12 here :)
03:05:36 <hjon> it can still be a god morgon :(
03:05:39 <shapr> I'm doing well, though I haven't done any Haskell lately, just teaching myself basic electronics, soldering and that sort of stuff.
03:05:48 <vixey> oh cool
03:05:58 <shapr> Vq^: I just woke up, getting ready for work.
03:06:07 <vixey> I always blow up the transistors
03:06:10 <vixey> (by accident)
03:06:36 <shapr> My advice so far is.. don't buy soldering stuff from Radio Shack, they really suck.
03:06:43 <Vq^> shapr: what? you have adapted to that timezone already? :o)
03:07:06 <shapr> It's been six months since I changed time zone last :-)
03:07:14 <Vq^> hehe
03:07:32 <Vq^> shapr: electronics is fun :)
03:08:16 <Vq^> i have been playing around a bit with avr's recently
03:08:54 <Vq^> i wonder how hard it would be to port ghc to avr...
03:10:26 * atsampson ponders Yorkshire Haskell: "data Maybe a = Owt a | Nowt"
03:10:55 <cjs> Hee hee.
03:11:45 <shapr> Vq^: Yeah, I bought an Arduino, I've been wondering the same sort of thing.
03:12:06 <Vq^> or perhaps tdwtf haskell:  data Bool = False | True | FileNotFound
03:12:12 <shapr> Or at least, how do I get a purely functional embedded language for embedded systems?
03:13:22 <xerox> shapr: http://it.youtube.com/watch?v=-zEWS7P91d4 maybe you could consult him
03:13:22 <lambdabot> Title: YouTube - Simple Robot Programmed in Haskell
03:13:44 <xerox> http://citeseer.ist.psu.edu/peterson99lambda.html
03:13:45 <lambdabot> Title: Lambda in Motion: Controlling Robots with Haskell - Peterson, Hudak, Elliott (Re ...
03:15:02 <dcoutts> @seen thomashartman1
03:15:03 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
03:15:06 <dcoutts> grr
03:15:20 <sioraiocht> @src iterate
03:15:20 <lambdabot> iterate f x =  x : iterate f (f x)
03:15:23 <vixey> @seen Cale
03:15:23 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
03:15:58 <vixey> > iterate (const 3) ()
03:16:07 <shapr> xerox: Yeah, I have to ask dpiponi next time he's on.
03:16:14 <lambdabot>  thread killed
03:16:58 <vixey> repeat = iterate id
03:23:06 <mm_freak_work> > take 10 $ iterate (const 3) ()
03:23:06 <lambdabot>   add an instance declaration for (Num ())
03:23:23 <mm_freak_work> > take 10 $ iterate (const 3) 0
03:23:24 <vixey> > (iterate id) 3
03:23:25 <lambdabot>  [0,3,3,3,3,3,3,3,3,3]
03:23:25 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
03:28:50 * shapr boings off to work
03:29:03 <vixey> see you
03:41:20 <gpds> is anyone familiar with putting a flex gui on haskell like here (http://jpmoresmau.blogspot.com/2007/03/haskell-gui-in-flex.html) though the code links seem to be dead
03:41:20 <lambdabot> Title: JP Moresmau's Programming Blog: A Haskell GUI in Flex
04:09:00 <yitz> gpds: that's a nice idea. Yeah, too bad about the code links. You could always use fastcgi or happs instead of that dedicated https server.
04:10:01 <gpds> hmm, yeah.
04:11:02 <yitz> @seen Cale
04:11:02 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
04:12:57 <yitz> @tell Cale As of Jun 2 11:00 GMT, the lambdabot seen plugin is broken. Thanks!
04:12:57 <lambdabot> Consider it noted.
04:13:33 <Cale> sigh... I'll fix it.
04:13:33 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
04:13:40 <vixey> > 1+1
04:13:42 <lambdabot>  2
04:13:47 <yitz> good morning Cale
04:13:52 <vixey> hi Cale
04:14:16 <Cale> hi
04:14:19 <Cale> and goodnight :)
04:14:27 <Cale> haven't slept
04:14:46 <vixey> @seen Cale
04:14:53 <yitz> Cale: ugh. perfect time for the bot to break.
04:14:54 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 19s ago.
04:16:04 <quicksilver> @users
04:16:12 <lambdabot> Maximum users seen in #haskell: 434, currently: 433 (99.8%), active: 4 (0.9%)
04:20:24 <ZsoL> what's the purpose of #haskell-overflow? or should i ask there?
04:20:25 <ZsoL> :[-)
04:20:43 <vixey> It's the overflow channel
04:20:48 <EvilTerran> #haskell-overflow 18      Overflow conversations and technical discussion from #haskell
04:21:16 <mm_freak_work> > let 1+1 = 3 in 1+1
04:21:17 <lambdabot>  3
04:21:49 <EvilTerran> as i understand it, it's for conversations that're still vaguely haskell-related (so not for -blah), but too technical and specialised to be suitable for the main channel
04:22:11 <ZsoL> ah thanks EvilTerran that's the explanation i was looking for
04:22:14 <EvilTerran> eg, if 4 people are having a heated debate about cache performance in ghc and what to do about it
04:22:49 <Saizan> or the inverse
04:23:04 <EvilTerran> ?
04:24:03 <EvilTerran> ... the cache is having a heated debate about people performance?
04:24:04 <Saizan> e.g. for when here gets too noisy to teach a newbie
04:24:15 <EvilTerran> ah. yes, that makes sense
04:24:36 <ndm> EvilTerran: it tends to be for 2 people communicating that would otherwise be a private chat, but which everyone is welcome to see
04:25:37 <EvilTerran> i see
04:27:17 <ToRA>  /join #haskell-overflow
04:27:22 <ToRA> mmm
04:27:26 <ToRA> that didn't work as expected
04:27:29 <EvilTerran> gesundheit
04:27:34 <EvilTerran> take the leading space out
04:27:54 <ToRA> :)
04:40:35 <eu-prleu-peupeu> hello haskell people
04:41:24 <Botje> > "hello"
04:41:25 <lambdabot>  "hello"
04:41:52 <dmwit> Hiya!
04:58:40 <ziman> @hello
04:58:42 <lambdabot> Maybe you meant: help tell
04:58:49 <cnwdup> :-D
05:11:11 <yitz> @vixen hello
05:11:11 <lambdabot> hi
05:25:28 <slarba> is ghc6.8.3 due soon?
05:27:21 <dcoutts_> slarba: yes
05:27:34 <slarba> parallel gc stuff integrated?
05:27:48 <dcoutts_> slarba: no, that's for 6.10
05:28:02 <dcoutts_> this is just a bug fix release in the 6.8.x series
05:28:11 <slarba> ok
05:31:05 <quicksilver> no point including the parallel gc until it's useful :)
05:33:26 <zoro123> any plans for data parallel haskell on CUDA :)
05:34:05 <slarba> quicksilver: is there any benchmarks on parallel code what kind of gains parallel gc really has?
05:35:21 <ndm> slarba: http://research.microsoft.com/~simonpj/papers/parallel-gc/index.htm
05:35:22 <lambdabot> Title: Parallel garbage collection, http://tinyurl.com/6eql8l
05:35:25 <pejo> Doesn't the ISMM-paper show some benchmarks?
05:37:37 <dcoutts_> zoro123: yes, the UNSW guys are working on it
05:37:58 <zoro123> o, thats great :)
05:39:56 <sioraiocht> @seen dcoutts
05:39:56 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 1h 21m 21s ago.
05:40:00 <sioraiocht> @seen dcoutts_
05:40:00 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 2m 23s ago.
05:40:11 <dcoutts_> hia sioraiocht
06:08:10 <vixey> > map (2^) [5..]
06:08:13 <lambdabot>  [32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,52428...
06:08:52 <int-e> == iterate (2*) 32
06:09:01 <vixey> > iterate (2*) 32
06:09:02 <lambdabot>  [32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,52428...
06:09:21 <vixey> hmmmm
06:09:36 <int-e> should be more efficient if you actually use all those powers.
06:09:38 <vixey> @src (^)
06:09:39 <lambdabot> Source not found. That's something I cannot allow to happen.
06:10:33 <opqdonut> > iterate (shift 1) 32
06:10:35 <lambdabot>  [32,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,...
06:10:41 <vixey> :t shift
06:10:42 <opqdonut> heh
06:10:43 <lambdabot> forall a. (Bits a) => a -> Int -> a
06:10:47 <opqdonut> ah
06:10:51 <vixey> @scr shift
06:10:51 <lambdabot> Maybe you meant: arr rc src
06:10:54 <opqdonut> > iterate (flip shift $ 1) 32
06:10:55 <lambdabot>  Add a type signature
06:10:55 <vixey> @arr shift
06:10:56 <lambdabot> Shiver me timbers!
06:10:59 <vixey> @src shift
06:10:59 <lambdabot> Source not found. Take a stress pill and think things over.
06:11:01 <opqdonut> > iterate (flip shift $ 1) (32::Word32)
06:11:02 <lambdabot>  [32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,52428...
06:11:03 <int-e> :t shiftL
06:11:04 <lambdabot> forall a. (Bits a) => a -> Int -> a
06:11:09 <opqdonut> there
06:11:46 <vixey> > iterate (`shift` 1) 32
06:11:47 <lambdabot>  Add a type signature
06:11:53 <vixey> > iterate (`shift` 1) (32::Word32)
06:11:54 <lambdabot>  [32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,52428...
06:12:00 <vixey> > iterate (`shift` -1) (32::Word32)
06:12:01 <lambdabot>      The operator `shift' [infixl 8] of a section
06:12:01 <lambdabot>         must have lower pre...
06:12:04 <vixey> > iterate (`shift` (-1)) (32::Word32)
06:12:05 <lambdabot>  [32,16,8,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
06:12:51 <int-e> > length $ takeWhile (0/=) $ iterate (/2) 1
06:12:52 <lambdabot>  1075
06:13:30 <dmwit> > last . takeWhile (0 /=) . iterate (/2) $ 1
06:13:31 <lambdabot>  5.0e-324
06:14:26 <int-e> 5^1074
06:14:32 <int-e> oops
06:15:33 <int-e> > "0." ++ take 10 (show (5^1074)) ++ "e-323"
06:15:34 <lambdabot>  "0.4940656458e-323"
06:16:30 <int-e> > length (10^1074) - length (5^1074)
06:16:31 <lambdabot>   add an instance declaration for (Num [a1])
06:16:45 <int-e> > length (show $ 10^1074) - length (show $ 5^1074)
06:16:47 <lambdabot>  324
06:17:11 <dmwit> > let strlen = length . show in strlen (10^1074) - strlen (5^1074)
06:17:12 <lambdabot>  324
06:17:25 <dmwit> To confuse the heck out of all C programmers. ;-)
06:17:40 <vixey> > let strlen = length . show in ((-)`on`strlen) (10^1074) (5^1074)
06:17:42 <lambdabot>  324
06:17:50 <dmwit> very nice
06:18:05 <vixey> > let strlen = length . show in ((-)`on`(strlen.(^1074))) 10 5
06:18:06 <lambdabot>  324
06:29:48 <BeelsebobWork> @ty on
06:29:50 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:37:20 <vixey> @src on
06:37:20 <lambdabot> (*) `on` f = \x y -> f x * f y
06:38:15 <BeelsebobWork> uh, okay
06:38:21 <BeelsebobWork> interesting version of source for it
06:38:29 <mauke> @. djinn type on
06:38:34 <lambdabot> f a b c _ = a (b c) (b c)
06:39:23 <vixey> on is one of the best codes
06:39:31 <vixey> it uses everything
06:39:40 <vixey> (almost)
06:41:46 <SamB_XP> it doesn't use monads, FFI, or parsing combinators!
06:42:02 <vixey> nobody uses monads anymore :P
06:42:16 <SamB_XP> nor arrows, nor Applicative
06:42:27 <vixey> P
06:42:30 <vixey> oops
06:42:36 <vixey> why is there two of you ...
06:42:55 <Vq^> we have always been two
06:44:52 <mapreduce> "Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together." - Cale++
06:45:55 <Maciej> ?hoogle (b -> Bool) -> [b] -> b
06:45:55 <lambdabot> No matches, try a more general search
06:47:44 <yitz> @remember Cale Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together.
06:47:44 <lambdabot> I will remember.
06:47:58 <yitz> @quote lego
06:47:59 <lambdabot> Boney says: Haskell is like Lego
06:48:04 <yitz> @quote lego
06:48:04 <lambdabot> Cale says: Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together.
06:48:24 * osfameron doesn't remember having to understand category theory to play with lego
06:48:40 <osfameron> that said, they always said I was a bright child.  I really have come downhill...
06:49:12 <yitz> osfameron: you obviously didn't own commutative lego blocks.
06:49:14 <vixey> I don't understand category theory
06:49:22 <vixey> maybe that's my problem :[
06:49:55 <quicksilver> Maciej: head . filter?
06:50:49 <vixey> yitz lol
06:51:28 <ziman> @pl \p -> head . filter p
06:51:29 <lambdabot> (head .) . filter
07:00:23 <Maciej> quicksilver: No, I want the element before that element.
07:01:15 <vixey> :t splitAt
07:01:17 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:01:23 <vixey> :t splitBy
07:01:25 <lambdabot> Not in scope: `splitBy'
07:01:30 <vixey> well something is missing
07:01:31 <quicksilver> :t break
07:01:31 <kpreid> :t break
07:01:34 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:01:34 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:01:41 <vixey> @src splitAt
07:01:41 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:01:44 <quicksilver> Maciej: or last . takeWhile ?
07:02:00 <kpreid> > (last . fst . break (== 'b')) "abc"
07:02:04 <lambdabot>  'a'
07:02:49 <Maciej> > (last . fst . break (=='a')) "abc"
07:02:50 <lambdabot>  Exception: Prelude.last: empty list
07:02:56 <quicksilver> Oh, interesting.
07:03:05 <vixey> @remember <jdh30> The problem is that the Haskell community is composed entirely of academics who have absolutely no idea what industry needs.
07:03:06 <lambdabot> Done.
07:03:23 <Maciej> Yeah, that's what I was looking for.
07:03:26 <quicksilver> vixey: that's a strange quote to choose to remember.
07:03:35 <vixey> quicksilver: it's not funny ?
07:03:49 <quicksilver> you mean it's funny because it shows that jdh30 is ignorant?
07:05:14 <int-e> @quote community
07:05:14 <lambdabot> <jdh30> says: The problem is that the Haskell community is composed entirely of academics who have absolutely no idea what industry needs.
07:06:01 <int-e> @quote #ocaml
07:06:01 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
07:06:01 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
07:07:34 <pjdelport> #haskell: it's moreish
07:08:27 <opqdonut> @quote ocaml
07:08:28 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
07:08:34 <opqdonut> :)
07:08:38 <vixey> hed
07:08:39 <opqdonut> a classic
07:08:40 <vixey> hehe*
07:10:13 <BMeph> Greetings, Earthlings! ;)
07:22:18 <vixey> hi
07:24:30 <Maciej> Is there a Haskell package providing a Hamming en- and decoder?
07:26:56 <quicksilver> Maciej: I very much doubt it.
07:27:06 <vixey> > let merge (x:xs) (y:ys) | x < y = x : xs `merge` (y:ys) | x > y = y : (x:xs) `merge` ys | otherwise = x : xs `merge` ys ; hamming = 1 : map (2*) hamming `merge` map (3*) hamming `merge` map (5*) hamming in hamming
07:27:11 <lambdabot>  [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72...
07:28:14 <opqdonut> vixey: different hamming :P
07:28:28 <vixey> I stole it from wiki
07:29:56 <laz0r> hi #haskell, i am having a little trouble trying to convert between Int and GLsizeiptr
07:30:15 <laz0r> i trief fromIntegral, and using things like (:: GLsizeiptr)
07:30:28 <laz0r> but ghc keeps on complaining
07:30:48 <mauke> where is GLsizeiptr defined?
07:31:20 <laz0r> Glsizeiptr is just a type synonym: type GLsizeiptr = Int32
07:31:26 <quicksilver> :i GLsizeiptr will tell you.
07:31:38 <quicksilver> laz0r: fromIntegral is the correct answer.
07:31:39 <mauke> then fromIntegral will work
07:31:52 <quicksilver> laz0r: you must have been using it wrong :)
07:31:58 <laz0r> i looked into Data.Int, and there was a footnote saying i could use fromIntegral to convert between different Int types
07:32:05 <quicksilver> that's correct.
07:32:06 <laz0r> and i assumed Int32 is an Int type
07:32:09 <quicksilver> correct.
07:32:10 <mauke> > 42 :: Int32
07:32:12 <laz0r> mmh
07:32:13 <lambdabot>  42
07:32:17 <quicksilver> and fromIntegral is right.
07:32:31 <quicksilver> so now you have to show us your code and the error message
07:32:32 <mauke> > let n :: Int32; n = 42 in  n :: Int
07:32:33 <lambdabot>  Couldn't match expected type `Int' against inferred type `Int32'
07:32:36 <quicksilver> or we won't go any further :)
07:32:37 <mauke> > let n :: Int32; n = 42 in  fromIntegral n :: Int
07:32:39 <lambdabot>  42
07:33:57 <laz0r> i am trying to upload a vertex array into a VBO, and i need to specify how much data i want to upload
07:34:06 <laz0r> i have the length of my list of vertices
07:34:23 <quicksilver> fromIntegral (length vv)
07:34:34 <laz0r> oh, wait, i just see something...
07:35:35 <laz0r> narf, now it works
07:35:54 <quicksilver> I have some VBO code which works.
07:36:00 <quicksilver> Feel free to ask if you get stuck
07:37:07 <laz0r> quicksilver: ok, thanks, i would definatly like to look at it, but atm i think i already figured everything out so far that i can start using VBOs
07:41:07 <paczesiowa> is anyone familiar with Oleg's polymorphic variants?
07:44:10 <quicksilver> at least (1) : Oleg ;)
07:44:17 <mxc_> there are polymorphic variants in haskell?
07:45:02 <EvilTerran> mxc_, only with olegian type hackery, but yes
07:45:07 <EvilTerran> there are also extensible records likewise
07:45:11 <paczesiowa> Oleg doesn't take "no" for an answer:>
07:45:57 <quicksilver> we should make @typefaq : The answer is Yes! Oleg can do that.
07:46:27 <mxc_> any chance of oleg's magic being supported by GHC?
07:46:31 <paczesiowa> anyway, it's easy to translate this ocaml code to haskell/Oleg "let f x = match x with `Constructor1 -> 1 | `Constructor2 -> 2" but does anyone have an ide how to translate this: "if true then `Constructor1 else `Constructor2"?
07:46:42 <shepheb> have to implement that LB function in the type system, though
07:47:25 <quicksilver> mxc_: oleg's magic is normally haskell98
07:47:33 <quicksilver> mxc_: or haskell98 + some very minimal extensions.
07:47:35 <mxc_> paczesiowa> from my limited knowledge, the only way to do that is if you have a data declaration
07:47:48 <mxc_> data MyType=  Constructor1 | Constructor2
07:47:56 <EvilTerran> @@ @run unwords.uncurry(++).second(("Oleg":).tail).splitAt 4.words$@show @faq
07:47:57 <lambdabot>  "The answer is: Yes! Oleg can do that."
07:47:58 <mxc_> is there a webpage reference?
07:48:02 <paczesiowa> quicksilver: like undecidable and overlapping instances:>
07:48:24 <mxc_> on a related note, can you restrict the parameter in a parameterized  type?
07:48:44 <paczesiowa> mxc_: that's something different (it's not extendable)
07:48:51 <mxc_> like data Blah a = (Num a) => Blah a
07:48:59 <skorpan> isn't that what GADT's are for=?
07:48:59 <skorpan> ?
07:49:05 <mxc_> paczesiowa> completely agree and am with you on that
07:49:21 <EvilTerran> skorpan, you can do something similar with GADTs, but there's also a notation for standard ADTs
07:49:38 <EvilTerran> both behave slightly unintuitively, mind, altho the GADTs one is a bit more intuitive than t'other
07:50:02 <mxc_> evilterran > do you have a reference for the vanilla ADT version?
07:50:04 <skorpan> so which is the notation for the ordinary ADTs?
07:50:24 <quicksilver> mxc_: the short answer is don't.
07:50:36 <mxc_> using GADTs considered a good thing?
07:50:38 <quicksilver> the longer answer is that the haskell 98 syntax for this is useless and should never be used.
07:50:48 <quicksilver> the GADT syntax is occasionally helpful.
07:50:48 <EvilTerran> mxc_, the report?
07:50:57 <quicksilver> But note, you're not actually using GADTs
07:51:07 <quicksilver> just a syntax change to get sensible class contexts out of constructors.
07:51:11 <mxc_> i thought GADTs were an extension and not in h98
07:51:13 <quicksilver> it's often simplest just not to bother.
07:51:16 <quicksilver> that's right.
07:51:23 <quicksilver> in h98 you can't do what you want.
07:51:27 <quicksilver> just do data Blah a = Blah a.
07:51:51 <EvilTerran> mxc_, http://haskell.org/onlinereport/decls.html#datatype-decls describes the h98 thing
07:51:51 <lambdabot> Title: The Haskell 98 Report: Declarations
07:52:11 <quicksilver> but it doesn't work.
07:52:13 <quicksilver> so don't use it.
07:52:20 <mxc_> i can't see any reason why it would, but would using GADTs interfere with any ghc optimizations ?
07:52:34 <mxc_> i guess it could make using ndm's catch tricky if it doesn't support it
07:53:18 <quicksilver> you wouldn't be using GADTs.
07:53:36 <quicksilver> you'd just be using a related syntax which makes class contexts on constructors meaningful.
07:53:37 <EvilTerran> ''For example, the declaration "data Eq a => Set a = NilSet | ConsSet a (Set a)" ... the overloaded type for ConsSet ensures that ConsSet can only be applied to values whose type is an instance of the class Eq. Pattern matching against ConsSet also gives rise to an Eq a constraint. For example: "f (ConsSet a s) = a" the function f has inferred type Eq a => Set a -> a. The context in the data declaration has no other effect whatsoever.''
07:53:49 <mxc_> whats bad about:  data Eq a => Set a = NilSet | ConsSet a (Set a)
07:54:15 <mxc_> evilterran - seems perfect
07:54:40 <EvilTerran> it means your code would get covered in (Eq a) constraints in the explicit type annotations
07:54:45 <CosmicRay> can someone fill me in on this ccall vs. stdcall stuff on Windows?
07:55:00 <EvilTerran> and you could add those yourself without the class constraint in the data decleration to get the same end result
07:55:13 <EvilTerran> so it's a bit pointless
07:55:23 <dcoutts_> question for everyone: suppose you have foo-1.0 installed and it's also the latest version available on hackage. You say $ cabal install foo . What do you expect to happen? Nothing or re-install foo-1.0 (possibly with different config flags)
07:55:44 <EvilTerran> if you look at the types of stuff in Data.Set, you'll see most of them are "Ord a => ... Set a ..."
07:56:10 <EvilTerran> but some of them don't need to be (eg, empty set, singleton set), so they've been left off there
07:56:36 <quicksilver> that's what I meant by 'doesn't work'
07:56:39 <EvilTerran> if there was an (Ord a) constraint in the data decl, everything that took or returned a (Set a) would need an (Ord a) constraint in the type sig
07:56:53 <mxc_> got it
07:57:13 <quicksilver> dcoutts_: "foo is already the latest version (--force to reinstall afresh)"
07:57:21 <EvilTerran> which would just make things more verbose, for a fairly small gain in terms of sanity checks
07:58:36 <dcoutts_> quicksilver: mm
07:59:09 <pejo> dcoutts, I'll go with quicksilver.
07:59:35 <dcoutts_> anyone know what apt does in this case?
07:59:59 <dcoutts_> gentoo just re-installs by default
08:00:14 <dcoutts_> and uses --upgrade to only do it if it's an actual version change
08:00:49 <dcoutts_> though of course apt is an installer for binary packages so perhaps it's a different use case
08:00:53 <pejo> It doesn't reinstall it - that's for sure.
08:01:11 <dcoutts_> right, with a binary it wouldn't be any different the second time round
08:02:29 <dcoutts_> quicksilver, pejo: I think I'd tend to agree with you
08:03:03 <pejo> The common use-case for installing a package you already have installed is that you somehow missed that you already had it I think. I'd be slightly upset if installing something twice recompiles the entire thing.
08:03:06 <dcoutts_> just thinking how to translate that preference into something specific for the dep resolver to work with
08:03:17 <dmead> > "roar"
08:03:18 <lambdabot>  "roar"
08:07:53 <hpaste>  roderyk pasted "a = Maybe a;; can a fresh pair of eyes find my type error, please?" at http://hpaste.org/8048
08:11:06 <dcoutts_> quicksilver, pejo: so it means we have to prefer the latest one for packages explicitly requested and prefer the installed one for all others.
08:12:38 <MedeaMelana> ol√°
08:13:09 <quicksilver> roderyk: maybe Nothing (\x -> Just (fst x))
08:13:14 <quicksilver> roderyk: this is just "fmap fst"
08:14:06 <roderyk> quicksilver: ah, cool :)
08:14:57 <quicksilver> roderyk: in when you call 'chooseWithThreshold' on elems
08:15:16 <quicksilver> roderyk: you are handing it a [(a,Maybe Bool)]
08:15:44 <quicksilver> roderyk: so you would need the 5th parameter to be Maybe (a,Maybe Bool)
08:15:57 <quicksilver> and it will return (Maybe (a,Maybe Bool),Maybe Bool)
08:16:02 <quicksilver> I'm nt sure that's what you wanted :)
08:16:10 <sioraiocht> @seen tibbe
08:16:10 <lambdabot> tibbe is in #xmonad, #haskell-soc, #ghc and #haskell. I don't know when tibbe last spoke.
08:16:20 <sioraiocht> tibbe: ping?
08:16:20 <lambdabot> sioraiocht: You have 1 new message. '/msg lambdabot @messages' to read it.
08:16:33 <tibbe> sioraiocht: pong
08:18:12 <roderyk> quicksilver: isn't mElem :: Maybe a  ?
08:20:20 <roderyk> OT: is there any reason why one should use "map" instead of "fmap"? I think I need to start using the latter more to spot where it can be applied (like the above example)
08:20:42 <vixey> roderyk:
08:20:44 <vixey> :t map
08:20:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:20:53 <ToRA> :t Preludce.map
08:20:55 <lambdabot> Couldn't find qualified module.
08:20:57 <ivanm> don't forget, according to lambdabot map == fmap !
08:21:03 <ivanm> @src map
08:21:04 <lambdabot> map _ []     = []
08:21:04 <lambdabot> map f (x:xs) = f x : map f xs
08:21:06 <vixey> well this my point..
08:21:16 <ziman> map == (.) == fmap :)
08:21:18 <vixey> letting map = fmap is quite acceptable
08:25:32 <quicksilver> roderyk: I wasn't talking about mElem
08:25:48 <quicksilver> roderyk: sorry, yes, I was
08:25:52 <quicksilver> roderyk: that's exacly my point
08:25:56 <quicksilver> roderyk: mElem :: Maybe a
08:26:06 <quicksilver> roderyk: but you needed it to be Maybe (a , Maybe Bool)
08:27:43 <quicksilver> roderyk: I think you're calling chooseWithThreshold wrongly, personally.
08:28:02 <quicksilver> roderyk: by the way, while I'm looking at your code, forcing it into the IO monad just because you use random numbers is yuck :)
08:28:51 <roderyk> quicksilver: I'm pretty sure I want mElem :: Maybe a :)   so the issue is chooseWithThreshold? :P
08:29:27 <quicksilver> roderyk: well the way you're calling it.
08:29:28 <roderyk> quicksilver: let me try to grok the type mismatch in my spaghetti code, but as a sidenote, what would be a better solution for random numbers?
08:29:53 <quicksilver> roderyk: if you want mElem :: Maybe a
08:30:18 <quicksilver> roderyk: then you need to pass chooseWithThreshold [a] as its thrid parameter
08:30:27 <quicksilver> you are passing it [(a,Maybe Bool)] as third parameter
08:30:30 <quicksilver> that's what I think is wrong.
08:30:38 <roderyk> oh!
08:30:45 <roderyk> yes it is : )
08:31:04 <quicksilver> roderyk: MonadRandom would be a better general solution for random numbers.
08:31:46 <quicksilver> for a solution which doesn't involve downloadin code of the wiki, perhaps using State g (where RandomGen g )
08:32:35 <roderyk> quicksilver: (remove a [a]) is what I intended, thanks for the help. And I will look into refactoring the random numbers. It was a sore spot for me, but not one I knew how to fix : )
08:54:33 <vixey> does anyone have a parser for a haskell like language?
08:54:56 <vixey> I mean a really short simple one but doing layout
08:55:06 <czkmobile> Prolog?
08:56:52 <vixey> czkmobile: what ..?
08:57:47 <czkmobile> Is Prolog a Haskell-lake
08:57:53 <czkmobile> lang
08:57:57 <czkmobile> ?
08:57:58 <vixey> no
08:58:23 <vixey> it doesn't have abstractions applications or pattern matching
08:58:52 <cjay> o_O
08:58:58 <mrd> vixey: there's some kind of indentation sensitive parser on hackage i think
08:59:17 <czkmobile> Ok
08:59:18 <czkmobile> cause I have a Prolog parser
08:59:19 <czkmobile> :)
08:59:37 <czkmobile> Ok Im off
08:59:41 <vixey> czkmobile: cool, is it available?
08:59:56 <vixey> (have you put it online anywhere?)
09:00:30 <vixey> mrd, thanks, did you mean haskell-src-exts?
09:00:36 <vixey> or something I missede?
09:00:39 <mrd> no, but that would be a haskell parser too
09:04:34 <bos> where does a body file a bug against the base libraries?
09:04:57 <bos> oh, in the ghc trac.
09:05:01 <dons> ?bug
09:05:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:05:13 <Saizan> scusa mario
09:27:34 <augustss> yo!
09:29:31 <bos> eep!
09:30:06 <dcoutts_> @arr!
09:30:07 <lambdabot> Keelhaul the swabs!
09:30:38 <tibbe> I need something interesting to read in the gym, any nice (but not too dense!) papers to read?
09:32:04 <pejo> tibbe, Partial Vectorisation of Haskell programs (http://research.microsoft.com/~simonpj/papers/ndp/index.htm) or Parallel generational-copying garbage collection with a block-structured heap (http://research.microsoft.com/~simonpj/papers/parallel-gc/index.htm) maybe?
09:32:05 <lambdabot> Title: Simon Peyton Jones: papers
09:32:39 <augustss> the GC paper is a nice read
09:32:47 <paczesiowa> paper about HList. when you see someone abuse typesystem to embed nice human-readable strings in type errors you just know it's divine.
09:32:50 * quicksilver wonders how you can read papers in the gym
09:33:11 <dcoutts_> tibbe: "Modular Lazy Search for Constraint Satisfaction Problems" very nice paper
09:33:39 <pejo> quicksilver, bicycle/stepping machine/etc.
09:34:44 <FordCortina> is there any way to enter a list like this into haskell [(1,2),1,1,(4,2)] ? I'm trying to get this as pure as possible without a mess of constructors and such.
09:35:00 <vixey> FordCortina: No they have different types
09:35:11 <vixey> What would you do with [(1,2),1,1,(4,2)] if you had it?
09:35:20 <hellige> FordCortina: besides, there's already a mess of constructors there. ;)
09:35:23 <Deewiant> perhaps [(1, Just 2), (1, Nothing), (1, Nothing), (4, Just 2)]
09:35:39 <FordCortina> hellige: i dont want to add more ;)
09:35:47 <roconnor> > [Left (1,2), Right 1, Right 1, Left (4,2)]
09:35:53 <lambdabot>  [Left (1,2),Right 1,Right 1,Left (4,2)]
09:36:01 <vixey> FordContina: any idea ?
09:36:25 <FordCortina> its sort of a short form for some constants in my program
09:36:40 <vixey> what does it end up as?
09:36:42 <vixey> in long forma
09:36:43 <paczesiowa> (1,2) .*. 1 .*. 1 .*. (4,2) .*. HNil
09:36:46 <FordCortina> from which i generate the main values in my program (proper data types)
09:36:47 <augustss> How about [(1,2),[1],[1],[4,2]]
09:37:01 <augustss> sorry, I meant [] for the first ()
09:37:07 <FordCortina> augustss: nice idea
09:37:12 <roconnor> [[1,2],[1],[1],[4,2]]
09:37:31 <roconnor> so many well-typed options
09:37:41 <mrd> or ((1,2),1,1,(4,2))
09:37:55 <vixey> or "[(1,2),1,1,(4,2)]"
09:38:09 <roconnor> @slap vixey
09:38:12 * lambdabot pushes vixey from his chair
09:38:13 <FordCortina> vixey: yes i was thinking about the string and parse approach
09:38:18 <augustss> If they are all numeric constants there are some grue some overloading tricks you could use
09:38:25 <mrd> i'm having difficulty understanding how this notation helps you
09:38:27 <vixey> pf lambdabot sucks
09:38:37 <Deewiant> or [(2,1,2),(1,1,undefined),(1,1,undefined),(2,4,2)]
09:38:47 <smg> vixey: !
09:38:51 <smg> lambabot = cool
09:38:56 <roconnor> Deewiant: that's unsafe.
09:38:59 <augustss> @yarr
09:38:59 <lambdabot> Where d' all t' pirates come from?
09:38:59 <lambdabot> Great Yarrmouth!
09:39:10 <Deewiant> roconnor: how do you mean
09:39:16 <roconnor> If it is a list of constants, it seems like a record type is approriate
09:39:45 <roconnor> Deewiant: if you make a logical error in your code, you might accidentally try to read undefined.
09:39:58 <roconnor> Deewiant: and the type system will not catch it.
09:40:12 <Deewiant> roconnor: of course, if you make logical errors, you can cause problems the type system won't catch. :-P
09:40:38 <roconnor> Deewiant: but our goal is to reduce that as much as possible
09:40:38 <Deewiant> that was mostly a tongue-in-cheek suggestion but I don't think it's /that/ bad
09:40:50 <Deewiant> true
09:40:57 <geezusfreeek> i think it's pretty bad
09:41:29 <geezusfreeek> especially since a type safe solution is almost as easy
09:41:34 <augustss> FordCortina: does the sequence of numbers and pars follow a pattern?
09:42:16 <FordCortina> augustss: not really the pairs and single can occur in any order
09:42:19 <vixey> FordCortina: what does it end up as?
09:42:33 <oklopol> > "o"
09:42:44 <Deewiant> data OneOrTwo a b = One a | Two a b
09:42:47 <FordCortina> they are a symbolic representation of terms and links in an html document
09:42:49 <Deewiant> @bot
09:42:50 <lambdabot>  thread killed
09:42:50 <lambdabot> :)
09:42:55 <vixey> i.e. what internal structure does ((1,2),1,1,(4,2)) end up as
09:43:13 <FordCortina> so (1,2) is term 1 pointing to document 2
09:43:26 <vixey> yes but what structure do you get ...
09:43:34 <vixey> as a value
09:43:36 <roconnor> oh
09:43:42 <quicksilver> how about [ 1 :-> 2 , Link 1, Link 1, 4 :-> 2 ] as syntax
09:43:58 <mm_freak> > unsafePerformIO $ unsafeInterleaveIO (return 3)
09:43:59 <lambdabot>   Not in scope: `unsafeInterleaveIO'
09:44:01 <roconnor> FordCortina: sounds like you are describing your own algebraic datatype
09:44:06 <FordCortina> quicksilver: nice
09:44:18 <roconnor> FordCortina: if that is true, then you should write a data type
09:44:25 <roconnor> such as quicksilver's
09:44:27 <augustss> The only reason to worry about how the representation looks is if you'll have to write this by hand.  And if you have to write this by hand it sucks already. :)
09:44:34 <quicksilver> FordCortina: data Thing = Int :-> Int | Link Int
09:44:37 <Deewiant> data OneOrTwo a b = Link a | a :-> b
09:44:40 <Deewiant> ;-P
09:44:44 <FordCortina> roconnor: yes i am i guess, but when i write the constants it looks verbose, but quicksilvers idea is good
09:44:50 * vixey gives up trying to extract information ...
09:45:02 <FordCortina> sorry vixey
09:45:17 <FordCortina> you pose some good questions
09:45:28 <augustss> @quote
09:45:28 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
09:45:56 <mrd> who lets a rat in the house anyhow
09:46:13 <FordCortina> something like data Document = Doc Integer (Set DocEntry), DocEntry = Term | Link
09:46:42 <FordCortina> im not sure basically, ill have to think more. thanks all
09:47:09 <vixey> not Link Integer ?
09:47:11 * Botje hands vixey a sharper and more painful tool to extract information
09:47:37 <FordCortina> vixey: yes sorry was being a bit rough there...
09:47:58 <FordCortina> should have been DocEntry = Term Integer | Link Doc
09:48:13 <FordCortina> hmm
09:48:15 <vixey> oh
09:48:23 <quicksilver> I find mini data types to specific constant data occasionally useful
09:48:31 <quicksilver> I quite often use ad-hoc lists of tuples too
09:48:46 <quicksilver> (in fact, this is one of the very few occasions of tuples)
09:48:52 <quicksilver> very few occasions that I do use tuples
09:48:54 <quicksilver> I mean
09:49:05 <quicksilver> to do static data / dispatch tables / "custom syntax"
09:49:53 <vixey> anyway seems like some things are self referential which means you need to fix everything
09:50:13 <vixey> fix (foo --> bar & baz & quux & bar --> baz)
09:50:14 <quicksilver> not if you're using integers as explicit keys
09:50:20 <vixey> for suitable defined combinators
09:50:33 <quicksilver> genuininely self-referential data is rather rarely a good idea.
09:50:41 <vixey> well the two datastructures are mutually defined
09:50:45 <quicksilver> (haskell has infinite data but it doesn't have cyclic data)
09:51:40 <vixey> unless Doc means something other than Document
09:51:43 <vixey> It's hard to tell
09:51:49 <int-e> cycle "abc"  builds a truly circular list
09:52:04 <vixey> there's no way to check that it's cyclic is there?
09:52:06 <geezusfreeek> well, it's an infinite list for sure
09:52:12 <int-e> nope
09:52:29 <FordCortina> im not interested in "documents" that link to themselves really, but i think a cyclic reference in a datatype might be a bad idea
09:52:50 <bd_> depends on the datatype
09:52:52 <vixey> @src []
09:52:52 <lambdabot> data [] a = [] | a : [a]
09:52:54 <vixey> I think it's ok :P
09:53:00 <geezusfreeek> i think it's fine as well
09:53:10 <int-e> vixey: but you can do something like   let x = cycle "abc" in length x `seq` x  and observe that the program runs in constant memory
09:53:32 <pejo> quicksilver, what is cyclic data, if Haskell doesn't have it?
09:53:33 <int-e> vixey: which, admittedly, is not a proof :)
09:53:45 <quicksilver> pejo: (useful) cyclic data is observably cyclic
09:53:55 <bd_> the canonical example is an assembler, where you pass in a function mapping labels to addresses (when those addresses are only known after assembling)
09:53:59 <quicksilver> pejo: when we speak of data we often usefully confine ourselves to observable properties
09:54:15 <bd_> I suppose that's not cyclic, as such, though...
09:54:30 <quicksilver> I wouldn't say that's cyclic
09:54:34 <geezusfreeek> i think "cyclic" really only means anything when the list is mutable, otherwise it is just infinitely repeating
09:54:38 <quicksilver> I'd say it was cleverly tying the not.
09:54:41 <quicksilver> knot.
09:54:43 <quicksilver> like fibs.
09:54:53 <quicksilver> fibs is self referential but the chain of dependency is well founded
09:54:54 <pejo> quicksilver, could you give an example of an observable cyclic data? It sounds like it's the GC that can observe cyclicness in general, not the programmer.
09:55:07 <vixey> > (fix . (++)) "abc"
09:55:08 <quicksilver> pejo: any language which supports pointer equality
09:55:15 <vixey> > (fix . (flip (++))) "abc"
09:55:16 <roconnor> bd_: have you been reading my assembler article :)
09:55:18 <quicksilver> pejo: e.g. C, Perl, C++, Java, Lisp.
09:55:18 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
09:55:30 <lambdabot>  thread killed
09:56:23 <ddarius> geezusfreeek: It doesn't have to be mutable.
09:56:27 <hpaste>  int-e pasted "observing circularity" at http://hpaste.org/8050
09:56:47 <mrd> reallyUnsafe
09:56:50 <mrd> nice
09:56:53 <int-e> vixey: with ghc you can ... but it's not reliable :)
09:56:57 <vixey> cool!
09:56:57 <geezusfreeek> ddarius: what meaning has it for immutable data though, besides constant memory use in some runtimes?
09:57:31 <roconnor> that looks unsafe.
09:57:36 <quicksilver> geezusfreeek: it means you can calculate things over the data.
09:57:45 <quicksilver> geezusfreeek: for example, you might calculate the length of the shortest cycle :)
09:57:47 <ddarius> geezusfreeek: If I want to traverse a cyclic graph and print out all nodes, I need to be able to observe cycles, but I don't need mutation.
09:57:50 <quicksilver> geezusfreeek: people study such things all the time.
09:58:09 <quicksilver> but you need observable cyclicity to prevent infinite loops.
09:58:19 <quicksilver> People do this routinely every day in C++, Java, etc
09:58:23 <quicksilver> (using pointer equality)
09:58:25 <quicksilver> typically.
09:58:31 <bd_> roconnor: I might've read it at some point in the past :)
09:58:34 <mrd> well here you have observably distinct nodes
09:59:12 <int-e> roconnor: obviously it's not referentially transparent, it can switch from 0 to 1, and it can in principle switch from 1 to 0 - if the original was a thunk that got evaluated twice due to unlucky timing in the threaded RTS.
09:59:40 <int-e> roconnor: unsafePerformIO is more dangerous, I think.
09:59:44 <mrd> you don't need pointers to give identity to nodes
10:00:18 <quicksilver> of course not
10:00:34 <quicksilver> there are plenty of ways to model cyclic structures in haskell
10:00:42 <quicksilver> otherwise it would be a toty language :)
10:00:44 <quicksilver> and not turing complete.
10:00:58 <quicksilver> the point we're making is that this kind of cyclicity is not observable
10:01:04 <quicksilver> and shouldn't be used to model cyclicity
10:01:07 <mrd> turing completeness is overrated
10:01:18 <quicksilver> you should model cyclicity with your own form of identity
10:01:22 <quicksilver> it's possible to make it pretty elegant.
10:01:39 <quicksilver> mrd: that's why I said toy language first and not turing complete second.
10:01:44 <quicksilver> the former is the more damning criticism.
10:02:09 * pjdelport parsed that as "total" instead of "toy"
10:02:23 <mrd> toytal?
10:02:30 <int-e> oh the reallyUnsafePtrEquality comes with an interesting comment in the source: --  (#1 Bad Guy: Alistair Reid :)
10:03:05 <pjdelport> mrd: har, excellent coinage
10:03:27 <int-e> (http://darcs.haskell.org/ghc/compiler/prelude/primops.txt.pp)
10:05:19 <geezusfreeek> i think the reason for my disagreement here is that i am interpreting "cyclic" to be a referential concept (where recursive algorithms don't care about identity), but others here are using it as a value concept (where unique identifiers are necessary to identify cycles)
10:05:47 <geezusfreeek> or perhaps i got that backwards
10:06:04 <int-e> the confusion stems from languages with observable pointers :)
10:06:28 <quicksilver> geezusfreeek: there is no confusion. I understand both concepts.
10:06:42 <quicksilver> geezusfreeek: I was choosing one interpretation in particular because that is what we were talking about.
10:06:47 <geezusfreeek> i didn't mean to imply there was confusion on anybody's part but my own ;)
10:06:50 <dons> ?yow
10:06:55 <lambdabot> Let's all show human CONCERN for REVERAND MOON's legal difficulties!!
10:06:58 <quicksilver> had we started the conversation in another way I would have used cyclic in the other sense, no doubt :)
10:07:20 <quicksilver> this comment: " seems like some things are self referential which means
10:07:21 <quicksilver>                you need to fix everything"
10:07:38 <quicksilver> creates cyclic data in this sense (non-observably cyclic)
10:07:43 <quicksilver> and that's what I was recommending against.
10:07:51 <geezusfreeek> ah
10:08:02 <quicksilver> the OP's problem is about link structures in documents, if cycles exist there I imagine he needs to reason about them explicitly.
10:08:08 <quicksilver> which means he will need to model identity explicitly.
10:08:16 <quicksilver> (although you can hide the plumbing quite nicely)
10:10:50 <Pingouin> hi there ! I'm trying to install HGL but it requires GreenCard. But GreenCard requires Data.FiniteMap, which is deprecated to Data.Map. How can i install GreenCard without error ?=-O
10:12:15 <dcoutts_> Pingouin: you can install the compat package for Data.FiniteMap
10:12:29 <DRMacIver> Are you sure it requires greencard? It doesn't say anything about that in hackage.
10:12:39 <DRMacIver> (And I dont' remember having to install greencard when I installed it myself)
10:13:41 <Pingouin> I quote the official site : "To build it from source, you will need GreenCard 3.01 and GHC 6.x as well."
10:14:20 <Pingouin> But i didn't try to install without it, maybe i should ;)
10:15:12 <DRMacIver> I'd recommend just giving the version on hackage a try.
10:15:18 <DRMacIver> I suspect the official site might be outdated
10:15:24 <DRMacIver> But I could be wrong
10:15:37 <Igloo> I think you're right
10:15:39 <Pingouin> copyright is 1999-2003 :p
10:15:55 <quicksilver> yeah, I believe there is a much newer HGL than that
10:16:04 <quicksilver> or, someone wrote an HGL compatibility layer, at least.
10:16:07 <Pingouin> i was scared that HGL was outdated, but if it's just the site
10:16:21 <Pingouin> i'll try, thank you indeed ;)
10:16:24 <DRMacIver> HGL probably is too. :) But it's a nice library for having a play with.
10:16:36 <dons> ?uptime
10:16:36 <lambdabot> uptime: 6h 2m 29s, longest uptime: 1m 10d 23h 44m 29s
10:16:39 <DRMacIver> It certainly works. I've used it on GHC 6.8.2
10:16:50 <Pingouin> right :) bye !
10:19:16 <EvilTerran> an HGL compatibility layer's been written for OpenGL, at least. something else as well, iirc.
10:19:49 <_dolio> @quote primops.txt.pp
10:19:49 <lambdabot> No quotes match. stty: unknown mode: doofus
10:26:57 <sclv> interesting issue with cabal dependency resolution: http://groups.google.com/group/HAppS/browse_thread/thread/25a63c3be18bc056
10:26:59 <lambdabot> Title: cabal install fail for happs-hsp-template - HAppS | Google Groups, http://tinyurl.com/5mg7oq
10:27:12 <sclv> (i.e. what to do when different versions of cabal itself are required)
10:27:19 <hpaste>  cpf_ pasted "(no title)" at http://hpaste.org/8051
10:27:22 * dcoutts_ reads
10:27:48 <dcoutts_> sclv: I think my new dep resolution algorithm will fix that
10:28:04 <dcoutts_> in that example it'll pick Cabal-1.2.3.0
10:28:12 <dcoutts_> since ghc-6.8.2 requires it
10:28:46 <dcoutts_> I don't think plugins does require Cabal-1.5, it'll work with 1.2.x, so that's what the algorithm will pick
10:29:06 <dcoutts_> perhaps I should get them to test this
10:29:17 <sclv> ah, so even if the plugins cabal file claims to require 1.5, then it will try it with the old version anyway?
10:29:28 <dcoutts_> sclv: but it doesn't
10:29:56 <sclv> oh -- the "  package plugins-1.2 requires Cabal-1.5.2 " is an artifact of the algorithm then?
10:30:26 <dcoutts_> sclv: plugins-1.2 says build-depends: Cabal >= 1.2.3
10:30:52 <dcoutts_> sclv: the error message you get there is a bit of cabal-install that verifies that proposed package install plans are valid
10:31:00 <dcoutts_> it's talking about inconsistencies in the plan
10:31:14 <sclv> ah. i gotcha. good to know that things like this will get cleared up.
10:31:35 <dcoutts_> so the plan says that it'll build with plugins-1.2 using Cabal-1.5 and ghc-6.8.2 using Cabal-1.2.3.0
10:31:44 <dcoutts_> and the verifier says, nope, can't do that
10:32:14 <dcoutts_> sclv: it's not making any statement about the universe of packages and dependencies, just about one specific bogus install plan
10:32:22 <sclv> and then it doesn't backtrack? aha.
10:33:12 <dcoutts_> sclv: the current dep resolver is called naiveResolver for a very good reason
10:33:53 * sclv is enlightened.
10:34:14 <dcoutts_> sclv: actually my new algorithm doesn't backtrack either but it uses constraints to guide its choices and guesses
10:34:16 <dcoutts_> a full backtracking search would need to be more sophisticated yet to prevent doing an exponential amount of work
10:35:27 <sclv> maybe a -naive-go-exponential flag could be an option :-)
10:35:52 <dcoutts_> I wouldn't recommend it
10:36:22 <sclv> cabal install --i-have-lots-of-cycles-to-burn
10:36:48 <dcoutts_> or just try the new resolver
10:37:01 <sclv> right -- i'm just being goofy.
10:37:07 <dcoutts_> it's in cabal-install darcs now, though needs to be enabled manually atm
10:39:24 <hpaste>  cpf_ annotated "(no title)" with "(no title)" at http://hpaste.org/8051#a2
10:46:29 <lux0815> hi http://tinyurl.com/62l8jc -pls help
10:46:30 <lambdabot> Title: Meine wilde Ex!!!
10:46:45 <smg> lux0815... kiddie
10:46:56 <Valodim> haha
10:47:03 <Valodim> saved by \bot, yay :)
10:47:13 <dsrogers> what is \bot?
10:47:22 <Beelsebob> @vixen this is \bot
10:47:23 <lambdabot> wanna hear a story?
10:47:26 <Valodim> what is \?
10:47:32 <Valodim> @botsnack
10:47:33 <lambdabot> :)
10:47:36 <vixey> lambda
10:47:43 <smg> lambdabot
10:48:09 <vixey> in haskell \_->_ is a lambda abstraction
10:48:35 <smg> is this new? :)
10:48:37 <Beelsebob> specifically \bot -> exp would be pronounced "lambda bot, returns exp"
10:48:52 <Beelsebob> smg: it is to dsrogers
10:49:12 <smg> hehe ok
10:49:49 <dsrogers> ah. thanks
10:51:15 <EvilTerran> dsrogers, \ is pronounced "lambda"
10:51:26 <smg> \ looks like the greek Œª
10:51:33 <EvilTerran> 'cos it looks like the long stroke of a lambda, and most of us don't have a Œª key
10:51:34 <smg> can you read my greek lambda unicode? :)
10:51:39 <dsrogers> I can.
10:51:45 <EvilTerran> smg, yeah, it works here. UTF-8 FTW!
10:51:47 <int-e> hmm, I'm tempted to say "lambda bot dot exp", never mind that the dot is an arrow :)
10:51:50 <smg> EvilTerran: :)
10:52:07 <int-e> lambdabot: did you hear that? ;)
10:52:23 <smg> <3 for Œªbot
10:52:33 <smg> ŒªŒ≤ŒøŒò :)
10:53:14 <Beelsebob> > let f = \y ‚Üí y + y in f 2
10:53:15 <lambdabot>  Illegal character ''\134''
10:53:15 <lambdabot>  at "Üí" (column 13)
10:53:18 <Beelsebob> bad lambdabot
10:55:58 <dons> dcoutts_: is 'cabal', the binary, likely to support cabal-setup style commands soon? i.e. cabal configure; cabal build;
10:56:07 <dons> or does it already?
10:56:11 <dcoutts_> it does
10:56:26 <dons> ah sweet. i should try a new snapshot
10:56:34 <dcoutts_> has done since ~Febuary
10:56:34 <dons> dcoutts++ need to get cabal tshirts
10:56:38 <dcoutts_> heh
10:56:55 <dcoutts_> dons: I'd particularly like you to try the new dep resolver in a day or two
10:57:01 <dons> yep. will do. just yell
10:57:02 <dcoutts_> I hope to have it enabled by default soon
10:57:09 <dons> oh, the cabal logo  is missing on http://haskell.org/cabal/
10:57:10 <lambdabot> Title: The Haskell Cabal
10:57:36 <dons> also, i think you should change the front page to say:  "Cabal itself is packaged with Cabal (because we're fully nerd)."
10:57:51 <dcoutts_> heh heh
10:58:10 <dcoutts_> however Cabal doesn't need a pre-existing Cabal to build
10:58:15 <dcoutts_> since it can bootstrap itself
10:58:23 <dcoutts_> so it's not quite fully nerd
10:59:27 <dcoutts_> dons: so yes, 'cabal' the prog is supposed to be *the* command line UI to all of cabal/hackage
10:59:48 <Pingouin> hi. I'm trying to install HGL, but i've got the following error : missing dependencies X11 -any. I'm new in the UNIX world, so how i can fix that ?
10:59:49 <dcoutts_> dons: I never run Setup.hs anymore
11:01:50 <dons> dcoutts_: neither. cabal install ftw!
11:01:56 * dons should upload a ftw package
11:04:04 <vixey> is there any library missing from cabal which is not really really hard to write?
11:04:08 <int-e> Pingouin: install the X11 package
11:04:15 <byorgey> Pingouin: do you have the haskell X11 package installed?
11:04:19 <int-e> Pingouin: (the haskell package X11)
11:04:33 <CosmicRay> vixey: mbox, maildir, imap, pop3 libraries
11:04:57 <Pingouin> i've to install a special haskell pachage ?
11:05:32 <int-e> Pingouin: HGL, what you're trying to install, is a package. X11 is a package just like HGL.
11:05:41 <Pingouin> ok it's allright then. thank you ;)
11:06:03 <byorgey> Pingouin: you can get it from hackage.haskell.org.  or, if you have cabal-install, you can just 'cabal install X11'
11:06:23 <int-e> A good place to start is  http://hackage.haskell.org/packages/archive/pkg-list.html  -- it lists X11 under Graphics
11:06:39 <dsrogers> is there a numerical optimization and linear algebra package for haskell?
11:06:50 <int-e> @quote stereo
11:06:50 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
11:10:18 <bos> @seen dons
11:10:18 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 8m 22s ago.
11:13:06 <oldsalt> hi all. can i build a Map from keys to something that occupies very little space (null?)
11:13:17 <Deewiant> how about using a Set instead
11:13:38 <Zao> oldsalt: Map OmgKeyType ()  is a valid map.
11:13:46 <Zao> Albeit quite boring.
11:13:46 <oldsalt> in fact it is a special kind of Map that i need to use
11:14:00 <lament> oldsalt: are you sure it's not a set?
11:14:09 <oldsalt> and i am only interested in the keys
11:14:11 <oldsalt> yes, i am
11:14:29 <Vq^> sounds a lot like a Set
11:14:31 <oldsalt> i am using a trie-based StrMap for prefix search
11:14:36 <bos> if you're only interested in the keys, and it's not a set, why is it not a map?
11:15:14 <oldsalt> Map OmgKeyType ()  looks interesting
11:15:39 <oldsalt> i think i will try that
11:16:01 <saml> > read "'\\c'" : "d"
11:16:04 <lambdabot>  "Exception: Prelude.read: no parse
11:16:11 <oldsalt> well, a set won't  let me search for prefixes i guess
11:16:18 <vixey> > '\c'
11:16:18 <lambdabot>  Illegal escape sequence at "'\c'" (column 1)
11:16:25 <Zao> oldsalt: () is the only value of the () type.
11:16:30 <Zao> (apart from bottom, of course)
11:17:06 <Vq^> oldsalt: is it a radix-tree you want?
11:17:06 <Toxaris> oldsalt: neither a map :)
11:17:06 <vixey> isn't that a trie?
11:17:08 <oldsalt> yes, it is a trie
11:17:17 <vixey> what is ?
11:17:48 <Vq^> oldsalt: but you don't want that?
11:18:08 <oldsalt> i want to use the trie i have but i don't want to store information at the nodes
11:18:19 <oldsalt> so i guess i was looking for the ()
11:18:21 <vixey> huh.......
11:18:35 <Zao> So just hack up a Trie type yourself?
11:18:49 <Vq^> oldsalt: () or building a set-trie
11:18:54 <vixey> how can you not store the information?
11:18:58 <Vq^> oldsalt: i would probably go for the latter
11:19:01 <vixey> and still be able to use it as a lookup
11:19:29 <Vq^> vixey: i think he means that the leaf nodes shouldn't contain additional data
11:20:03 <oldsalt> mmh, good point
11:20:11 <oldsalt> maybe i need to store some information
11:20:24 <oldsalt> i think i have to think it over again
11:21:19 <Toxaris> oldsalt: I would start with () as type for the node data, but write a wrapper around the whole thing with a more set-trie-like interface (e.g. no mention of node data). then, when I later realize I want to get rid of all these (), I can easily copy-paste the existing implementation and delete the node data.
11:22:23 <oldsalt> i already have the trie-implementation. but it occupies a lot of space and so i am trying to persist the data at the nodes
11:23:18 <oldsalt> but i guess vixey is right. i need data at the nodes
11:23:25 <Toxaris> oldsalt: so you already are in the second step? are you sure the node data is the problem?
11:23:51 <oldsalt> yes and no
11:23:53 <Toxaris> oldsalt: normally in a trie, you need at least a boolean at every nodes, to differentiate prefixes from real data
11:23:59 <oldsalt> the trie occupies a lot of memory anyway
11:24:09 <oldsalt> but i can save some by persisting the data
11:24:14 <oldsalt> that is the first step
11:24:22 <oldsalt> the second will be to persist subtrees
11:24:43 <Toxaris> what does "to persist" mean?
11:25:04 <oldsalt> write it to the hard disk and get it out of the memory
11:25:16 <oldsalt> and read it when needed
11:25:41 <Toxaris> so your trie is a in-memory index for a file-based db?
11:25:47 <Toxaris> maybe you want a dbms?
11:26:26 <oldsalt> no, i don't want a dbms for that
11:26:34 <oldsalt> i guess that would be way too slow
11:28:43 <oldsalt> i think i will use Ints in the trie and store numbered files
11:28:53 <oldsalt> thank you
11:29:49 <tensh> os.system("memcached &> /dev/null &") still gives me output. Can anyone tell me why and how to avoid it? ;)
11:30:10 <dsrogers> 2>&1
11:30:26 <daf> &> is not portable, I think
11:30:33 <dsrogers> memcached > /dev/null 2>&1
11:30:39 <dsrogers> and yeah, it's not portable.
11:30:44 <tensh> will that really make a difference? `memcached &> /dev/null &` works fine when I type it in mu terminal
11:30:44 <Deewiant> what is &>?
11:30:55 <tensh> it's supposed to be both combined
11:31:04 <dcoutts_> does bash support that?
11:31:11 <tensh> yes
11:31:13 <Deewiant> don't system() calls always use sh?
11:31:20 <tensh> oh, maybe that's why ;)
11:31:23 <dsrogers> the shell spawned with os.system isn't necessarlly you're shell
11:31:27 <dsrogers> *your
11:31:27 <tensh> I'll try it out, sec
11:31:28 <Deewiant> I don't know, but I think they do
11:31:39 <saml> > "\c"
11:31:41 <lambdabot>  Illegal escape sequence at ""\c"" (column 1)
11:31:41 <vincenz> @seen jedbrown
11:31:41 <lambdabot> I haven't seen jedbrown.
11:31:46 <vincenz> @seen tibbe
11:31:46 <lambdabot> tibbe is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard tibbe speak 2h 1m 8s ago.
11:31:50 <Deewiant> preflex: seen jedbrown
11:31:50 <preflex>  Sorry, I haven't seen jedbrown
11:32:08 <tensh> 2>&1 didn't work either :(
11:32:32 <tensh> oh, this was the wrong channel
11:32:34 <Deewiant> try 2>/dev/null
11:32:41 <tensh> this was supposed to go in python ;)
11:32:52 <tensh> alright
11:32:57 <Vq^> tensh: we know python too ;)
11:33:15 <tensh> yeah, but I guess you don't want to read about it here. sorry about that
11:33:22 <tensh> I'm somewhat stressed
11:33:25 <Vq^> tensh: there is a couple of functions called popen
11:33:30 <Vq^> tensh: look at them
11:33:51 <Pingouin> do you know where HGL documentation is ? I can't find it :-( !
11:34:17 <tensh> 2> worked fine though
11:34:26 <tensh> except I want stdout to be thrown away as well
11:34:39 <Deewiant> heh, of course you need to redirect stdout and stderr separately
11:34:49 <Deewiant> so if you did 2>&1 by itself it only redirected stderr to stdout :-)
11:35:21 <tensh> Vq^: thanks, I'll do that tomorrow. I just gotta get this working for now cos I have some more important stuff to take care of right now
11:35:45 <tensh> Deewiant: in bash, &> redirects both I think
11:35:52 <tensh> or >&
11:35:53 <tensh> same thing
11:35:59 <Deewiant> no, >& is not the same thing
11:36:06 <Deewiant> &1 refers to the first stream, i.e. stdout
11:36:11 <Deewiant> I don't know about &>
11:36:26 <Deewiant> but you could equivalently write 2>&1 as 2> &1
11:36:32 <Deewiant> i.e. redirect second stream to stream 1.
11:36:43 <tensh> but >& might not be the same as >&1, right?
11:36:53 <tensh> ah, I see
11:37:15 <Deewiant> okay, evidently 2> &1 doesn't work after all but my point stands :-)
11:38:20 <tensh> ok :)
11:42:08 <tensh> Deewiant: how about memcached > /dev/null 2>&1
11:42:14 <tensh> that should redirect both, right?
11:42:39 <Deewiant> yep
11:42:51 <Deewiant> as dsrogers originally suggested :-P
11:43:04 <tensh> oh, I misunderstood
11:43:17 <tensh> I thought I was supposed to replace &> with 2>&1
11:43:22 <tensh> silly me ;)
11:43:31 <dsrogers> no.
11:43:37 <dsrogers> in fact, it's order dependent.
11:44:55 <tensh> anyway, thanks for all the help!
11:49:39 <cnwdup> How do I convert Double to Integer? I am searching myself crazy.
11:49:47 <dons> truncate
11:49:52 <dons> or round, ceiling, floor
11:50:21 <cnwdup> Ah, ok. I tried ceil which seems to be something different.
11:50:25 <cnwdup> Thanks, dons!
11:50:28 <dons> > fromIntegral (truncate (pi :: Double))
11:50:31 <lambdabot>  3
11:50:31 <dons> for example
11:50:32 <geezusfreeek> :t ceil
11:50:34 <lambdabot> Not in scope: `ceil'
11:50:39 <dons> :t ceiling
11:50:41 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:50:42 <cnwdup> Weird.
11:50:45 <geezusfreeek> @hoogle ceil
11:50:45 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
11:50:56 <byorgey> ceil?
11:50:59 <geezusfreeek> cnwdup: where did you see ceil?
11:51:03 <dons> in math.h :)
11:51:15 <geezusfreeek> psh :P
11:51:17 <cnwdup> I don't know. I thought I tried that.
11:51:33 <dons> ?hoogle ceil
11:51:33 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
11:51:35 <dons> hehe
11:52:34 <cnwdup> :t mapM_
11:52:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:54:37 <ziman> > truncate pi
11:54:38 <lambdabot>  3
11:54:52 <vixey> > punctuate truncate
11:54:54 <lambdabot>  Couldn't match expected type `Doc' against inferred type `a -> b'
11:55:56 <bos> dcoutts: when do you think it will make sense to start cutting prebuilt binaries of "cabal install"?
11:56:00 <ziman> > const truncate punctuate pi
11:56:02 <lambdabot>  3
11:56:14 <bos> dcoutts: i think that would make haskell library use a lot more palatable to people.
11:56:27 * bos daydreams about bundling "cabal install" *with* ghc
11:56:43 <Deewiant> > const const punctuate truncate const pi
11:56:45 <lambdabot>  3
11:57:13 <tibbe> bos: I want my linux distribution to have cabal install to avoid the bootstrapping problem
11:57:15 <vixey> Deewiant :D
11:58:09 * BMeph thinks Deewiant is /smoooooooth/ ;)
11:58:21 <Twinside> hi is there someone to take a look at my code ( http://hpaste.org/8036 ), I've got a problem with the type signature, the first one is equal to the infered one, but when present ghc refuse to compile, does someone get an idea?
11:59:26 <roconnor> @ytype punctuate
11:59:28 <lambdabot> Doc -> [Doc] -> [Doc]
11:59:29 <roconnor> @type punctuate
11:59:31 <lambdabot> Doc -> [Doc] -> [Doc]
12:00:55 <Deewiant> > const const const const punctuate const const const truncate const truncate const pi truncate pi pi
12:00:57 <lambdabot>  3
12:02:29 <BMeph> Twinside: What's your definition of (!\\) look like? :)
12:03:27 <ziman> @hoogle punctuate
12:03:27 <hpaste>  Twinside annotated "(no title)" with "added information" at http://hpaste.org/8036#a1
12:03:31 <lambdabot> Language.Haskell.TH.PprLib.punctuate :: Doc -> [Doc] -> [Doc]
12:03:50 <Twinside> I've added the class definition in the new paste
12:06:26 <BMeph> Twinside: Thank you (still reading...)
12:06:33 <tibbe> vincenz: ping, you wanted something?
12:08:36 <vincenz> tibbe: yeah
12:08:50 <vincenz> tibbe: wanted to discuss icfpc
12:09:43 <sjanssen> dons: perhaps with the new darcs-to-git it would be possible to update those darcs mirrors daily?  Updated ohloh stats would be nice :)
12:15:33 * byorgey mixes some lambda mojitos
12:15:46 <therp> byorgey: how does that work?
12:16:07 <BMeph> Twinside: It looks like your program doesn't know how to infer that (StrictPixel p r) holds.
12:16:09 <byorgey> very nicely
12:16:36 <BMeph> byorgey: lambditos? ;)
12:16:52 <byorgey> BMeph: heh, sure =)
12:16:57 <Twinside> BMeph, is there a solution?
12:17:42 <thetallgu1> ?seen igloo
12:17:43 <lambdabot> igloo is in #haskell-soc, #darcs, #ghc and #haskell. I last heard igloo speak 2h 2m 5s ago.
12:18:06 <geezusfreeek> i think the only thing i hate more than huge space leaks is small ones
12:18:53 <BMeph> Twinside: Uh, somehow, tell the compiler that (StrictPixel p r) holds? ;)
12:19:06 <byorgey> Twinside: what is the 'r' in StrictPixel p r?  it doesn't occur anywhere else in the type signature.
12:19:18 <Twinside> I wonder...
12:19:54 <BMeph> geezusfreeek: "But it's only a wafer-thin space leak..." ;)
12:20:12 <Twinside> normally i use StrictPixel to be able to store pixel in UnboxedArray, but this function is for version when p = r
12:20:26 <Twinside> (am I clear enough?)
12:21:00 <BMeph> byorgey, Twinside: Presumably, the ignored third parameter of the de-constructed Pixmap is of type r, right?
12:21:47 <BMeph> s/Pixmap/Pixmap img/
12:21:58 <Twinside> nope the type is (IArray UArray r, Num r) => UArray r
12:23:01 <BMeph> Twinside: Hmm, I guess we'd need to see how Pixmaps are constructed. :)
12:23:08 <Twinside> I'm going to add all the definitions
12:23:23 <BMeph> Okay, I'll brace myself... ;)
12:23:40 * BMeph holds on to a pair of bracing lambdas...
12:26:20 <hpaste>  Twinside annotated "(no title)" with "(no title)" at http://hpaste.org/8036#a2
12:30:39 <Twinside> BMeph, not scared by my code?
12:31:52 * MWumpusZ is, if that makes you feel better :-P  But I haven't looked at haskell in, urr, 5 years or so...  just staring at it and trying to work out how much I still understand :-)
12:32:39 <vincenz> @seen jedbrown
12:32:40 <lambdabot> I haven't seen jedbrown.
12:32:47 <byorgey> MWumpusZ: welcome back! =)
12:33:44 <Pingouin> i've just installed HGL, and when I type "import Graphics.HGL" GHC can't find the module. What have i to do ?
12:33:52 <byorgey> MWumpusZ: I'm guessing that may not the best code for refreshing your Haskell
12:34:30 <MWumpusZ> probably not :-)  but hey, its something, and it's interesting :-)
12:35:25 <Twinside> Pingouin, Have you tried -package HGL in GHC options?
12:35:54 <Pingouin> no, let's try ;)
12:36:31 <vincenz> tibbe: `ap` #oasis
12:39:56 <Pingouin> i've to do something like ghc -o graphic.o -package HGL ?
12:40:26 <Twinside> hmm -package option is just for link time I think
12:40:50 <Pingouin> link time is ghc -c command ?
12:41:02 <Twinside> nope -c only compile
12:41:16 <Pingouin> link time, what doya mean ?
12:41:32 <Saizan> Pingouin: use --make when compiling, eg. ghc --make graphic.hs
12:42:08 <Twinside> link time, when you put all your .o files to make a nice software ready to run
12:43:00 <Twinside> erf and the package name give by ghc-pkg is OpenGL, my bad
12:44:56 <Pingouin> so, i've a graphic.hs file, which contains something like "" import Graphics.HGL main = do -- creating a window "" , what have i exactly to do to making an executable ?
12:45:43 <Saizan> ghc --make graphic.hs
12:46:49 <Twinside> wait by looking at the librairies, I see that the module name is Graphics.Rendering.OpenGL, not HGL, could it be your problem?
12:47:28 <Pingouin> Saizan's solution works well, thank you indeed :D
12:47:51 <Pingouin> but what does that command exactly do ?
12:49:16 <Saizan> it chases dependencies and link the proper libraries for you
12:49:29 <ttt--> are there any other languages (besides haskell) that are linked to category theory in some way?
12:50:11 <ttt--> preferably some explicit link
12:52:21 <Pingouin> ok thank you very much Saizan :)
12:56:00 <EvilTerran> ttt--, well, implicit links are everywhere. that's the point of category theory.
12:56:30 <EvilTerran> ... but, in terms of explicit links, i think it's pretty much just haskell and any other languages that've nicked the monad idea (say, Agda, IIRC)
12:57:45 <BMeph> Twinside: It looks like your Pixmap has a phantom type - is it deliberate, or am I missing something? :)
12:58:01 <Twinside> erf
12:58:11 <Twinside> it's absolutely not deliberate :/
13:01:02 <Twinside> BMeph, you mean that the a in the pixmap definition is 'phantom'?
13:01:47 <ttt--> EvilTerran, I dont know much about it, but i was thinking of a little toy language where you can make Sets that are types, add constants etc
13:02:12 <Peaker> Writing a toy ray tracer: How bright should a point on a surface of an object/shape be, as a function of the angular distance between the reflection vector and the towards-light vector?
13:02:24 <ttt--> in the category terminology
13:03:05 <byorgey> Peaker: the intensity falls off as the cos of that angle
13:03:22 <Peaker> byorgey, thanks
13:03:50 <Peaker> what's a nice way to figure out the angular difference between two vectors?
13:04:32 <byorgey> take the dot product, since u . v = |u||v| cos theta
13:04:32 <Twinside> Peaker, normalize your vectors and make a scalar product, you should obtain the cosine of that angle
13:04:41 <Peaker> Twinside, ah, thanks
13:05:02 <Peaker> ah cool, so the dot product is the intensity! :)
13:05:15 <byorgey> right =)
13:05:16 <Peaker> (of the normalized ones)
13:05:29 <Twinside> you should look at OpenGL's equation for illumination
13:05:53 <Twinside> it's a good way to understand the basics lighting functions
13:06:18 <Peaker> I am trying to keep this a fun toy :)
13:14:03 <Peaker> while the dot product is yielding an *extremely* interesting result, it does not seem to be the right one ;)
13:14:09 * MWumpusZ discovers that he doesn't adequately understand the class declarations, heh ;P  so yeah, you're right, probably not the best place to start :-)
13:15:32 <MWumpusZ> any recommendations?  thats probably hard to say without some quantification of what I know/knew, but that, equally, is hard for me to say about myself :/  I know I never really wrapped my head around monads to my satisfaction (going to be making a, hmm, 3rd run-up at them in the next days), but than in itself isn't a useful observation.
13:15:59 <MedeaMelana> I never understood monads until I wrote one myself
13:16:05 <byorgey> Peaker: make sure you've got the vector orientations correct ?
13:16:13 <MedeaMelana> Which took me a while, but it helped tremendously
13:16:34 <Peaker> byorgey, I am gonna print some traces to see that I do
13:16:52 <byorgey> Peaker: if you have a surface normal pointing away from the surface, you'll want the other vector pointing *from* the surface *to* the light source
13:16:56 <Peaker> byorgey, http://nextflow.dyndns.org/test.png  to see the funny result :)
13:17:12 <Peaker> byorgey, the light is above them in the middle
13:17:29 <byorgey> hmmm, interesting... =)
13:17:40 <byorgey> broken raytracers are a fun source of bizarre images =)
13:17:44 <Twinside> seem to be a clamping issue
13:18:46 <Peaker> byorgey, without the dot product, you can reload the image
13:19:21 <Peaker> (those are a yellow/blue ball on top of a checkerboard floor, with a light on top (that's only affecting things through its distance), and reflections on the balls
13:22:11 <dbpatterson> I'm trying to build wxcore... on linux, with wxgtk version 2.6.3. compilation fails with the following error - cc1: error: unrecognized command line option "-fno-toplevel-reorder"
13:22:21 <dbpatterson> googling that compiler flag gives me nothing...
13:22:51 <dbpatterson> oh, woops, I should have googled fno-toplevel-reorder (without the '-')... still, ideas?
13:24:28 <EvilTerran> track that flag down in the build files and try removing it?
13:29:00 <jaj> @users
13:29:00 <lambdabot> Maximum users seen in #haskell: 465, currently: 457 (98.3%), active: 13 (2.8%)
13:29:54 <Peaker> Twinside, what did you mean by clamping? clamping negative to 0?
13:30:01 <Peaker> Twinside, because that was what it was :)
13:30:12 <Twinside> hmm
13:30:26 <Twinside> nope I thought it was an integer overflow
13:30:44 <Twinside> so maybe you've got an orientation issue in your vector, try negate one of them
13:31:33 <Peaker> it seems ok now (still not perfect, but now its just tuning)
13:36:11 <Peaker> the digits followed by "e-02" float notation is so annoying. I keep getting confused by it
13:38:45 <Peaker> does light deteriorate according to distance or distance squared?
13:38:46 <dons> sjanssen: good idea.
13:39:21 <Twinside> BMeph, I've found a solution to the problem, instead of using the generic (!\\) operator defined in the class, I use a much more constrained accessor which deal with the phantom type, and now it work, thanks for the advice :)
13:39:22 <vixey> light/area is inversely propertional to distance squared
13:39:48 <Peaker> vixey, thanks
13:40:37 <EvilTerran> if you think about it, the surface of the sphere that must be illuminated at distance r has area O(r^2), so the amount of light hitting any fixed-area region of it will be O(n^-2)
13:41:02 <vixey> n ?
13:41:09 <EvilTerran> r.
13:41:16 <Defty> k..
13:41:23 <EvilTerran> my bad, O()s are usually in terms of n :P
13:42:01 <BMeph> Twinside: Glad it worked out for you. :)
13:44:10 * Twinside is jumping shouting "IT COMPILE!!!! w00t"
13:44:57 <ksandstr> i did that too, before i got my first stack overflow error :-|
13:44:59 <Twey> Hahaha
13:44:59 <Defty> hey, .. has anyone tried hopengl?
13:45:29 <Defty> i was thinking learning haskell with it a while back but I couldn't link against it on debian unstable :p
13:45:54 <Defty> so it only worked in interpreted mode which is kind of too slow for pretty much anything.
13:46:28 <Defty> it seems the included libs in unstable are compiled with older libstdc++ or something.
13:47:18 <monochrom> boring (low morale) day. I come to you for lighting up my life.
13:47:32 <vixey> monochrom!!!!!!!!!!!!
13:47:36 <vixey> :p
13:47:38 <opqdonut> <3
13:47:54 <vixey> I found repeat = iterate id
13:48:05 <jaj> always look on the bright side of life
13:48:28 <ksandstr> it's easier if you were just freshly crucified. unlike some of the others.
13:48:28 <TomMD> @seen meBrokenStill?
13:48:29 <lambdabot> I haven't seen meBrokenStill?.
13:48:50 <AllNight^> hello all! :)
13:49:09 <monochrom> Indeed repeat = iterate id.
13:49:27 <vixey> hi
13:50:58 * AllNight^ is a Haskell newbie wondering if someone can help him with a tiny bit of code he wrote to play around with multi-parameter type classes... it compiles, but I get 'Unresolved overloading' errors when trying to use it & I dont understand why :|
13:51:15 <monochrom> hpaste.org
13:51:45 * monochrom starts polling hpaste.org every 5 milliseconds.
13:51:53 <Twey> Haha
13:51:57 <MWumpusZ> :P
13:52:00 * Twey watches hpaste.org explode.
13:52:32 <AllNight^> now that's what I call side-effects! (things going boom!) :)
13:53:30 <Peaker> AllNight^, my guess is that you are not using all of the class parameters so they remain ambiguous?  You might want to use | a -> b in the class declaration to mean that for any type a  only 1 type b is allowed
13:53:54 <vixey> I found scary unification code
13:54:02 * vixey stops lookin at hpaste
13:54:07 <AllNight^> no - I am using them all.... I'm trying to define a type class for isomorphisms as
13:54:16 <AllNight^> class Iso a b where
13:54:23 <AllNight^>   up :: a -> b
13:54:28 <AllNight^>   down :: b -> a
13:54:46 <AllNight^> and then I have a sample instance
13:54:52 <AllNight^> (auxiliary code)
13:55:24 <AllNight^> quax = [(x,x + 99) | x <- [1..10]]
13:55:24 <AllNight^> quix = ([1..10],[100..109])
13:55:24 <AllNight^> foo :: ([a],[b]) -> [(a,b)]
13:55:24 <AllNight^> foo x = zip (fst x) (snd x)
13:55:24 <AllNight^> bar :: [(a,b)] -> ([a],[b])
13:55:25 <AllNight^> bar x = (map fst x, map snd x)
13:55:32 <AllNight^> instance Iso [(a,b)] ([a],[b]) where
13:55:37 <AllNight^>    up = bar
13:55:39 <dolio> Noo!
13:55:39 <sjanssen> AllNight^: next time use hpaste
13:55:40 <AllNight^>   down = foo
13:55:45 <jaj> @where hpaste
13:55:45 <lambdabot> http://hpaste.org/
13:55:59 <AllNight^> soory sjanssen am new to the channel (first time here!) - I dont know what hpaste is :)
13:55:59 <monochrom> Forget next time.  Use hpaste.org this time already.
13:56:26 <jaj> AllNight^: see the topic ;)
13:56:28 <monochrom> Perhaps I was too subtle when I said I will poll it every 5ms?
13:56:30 <AllNight^> ah.. I see it in the topic!
13:56:36 <AllNight^> ty jaj :)
13:58:26 <MWumpusZ> ?seen chilli
13:58:26 <lambdabot> I haven't seen chilli.
14:01:29 <hpaste>  AllNight^ pasted "Problems with Multi-parameter classes" at http://hpaste.org/8053
14:01:42 <AllNight^> ok.. duly pasted :)
14:02:19 <jaj> my brain must have some strange connections. I always see titles on hpaste like they were mirrored because they are aligned on the right
14:04:13 <sjanssen> AllNight^: how are you trying to use it?
14:04:53 <monochrom> AllNight^: It is preferrable that included in the paste is the concrete code for "use".
14:05:19 <AllNight^> just interactively with 'up quax'
14:05:32 <monochrom> One valuable lesson in science education should be: give complete instructions to others for reproducing your observations.
14:05:35 <sjanssen> you need 'up quax :: ([Int], [Int)'
14:05:40 <AllNight^> which I _expected_ to give me quix back... only it doesnt, I get an error instead
14:05:45 <sjanssen> you need 'up quax :: ([Int], [Int])', I mean
14:05:58 <sjanssen> erm, s/Int/Integer/
14:06:34 <AllNight^> ok! thanks sjanssen!
14:06:38 <AllNight^> that works!
14:06:53 <AllNight^> though... *wince* - I still dont see _why_ that works
14:06:57 <mrd> alternatively, class Iso a b | a -> b
14:07:05 <mrd> type a determines type b
14:07:05 <sjanssen> AllNight^: the problem is that the compiler doesn't know which instance to chose purely from 'a'
14:07:05 <Twey> AllNight^: Heh
14:07:29 <AllNight^> I dont want to do that though mrd - wouldnt that mean no type could then be isomorphic with more than one other type?
14:07:43 <AllNight^> (using functional dependencies)
14:07:46 <mrd> of course, then how is it supposed to know which instance you meant?
14:07:54 <mrd> w/o the dependency
14:08:08 <mrd> hence the type annotation
14:08:25 <sjanssen> AllNight^: for all we know, there could also be 'instance Iso [(Integer, Integer)] [(String, String)]' floating around somewhere
14:08:47 <AllNight^> but if I'm passing the result to a function where only one of them would make sense - why not just eliminate the other candidates as 'he obviously meant that one' ?
14:09:09 <sjanssen> AllNight^: but you're not passing the result to a function where only one of them would make sense
14:09:22 * AllNight^ has played with Lisp, Java & other languages - but not Haskell before - and dosnt quite grok type inference yet
14:10:21 <Philippa_> AllNight^: it's fairly simple until you run into typeclasses (and even then it's /mostly/ simple) or rank-n types
14:10:23 <AllNight^> I see - so in effect the type checker  is saying that 'in the future you might go and provide additional definitions with would screw this up' ?
14:10:47 <AllNight^> I got as far as monadic type classes without any real problems (teach self from online docs)
14:11:13 <AllNight^> then ran into this & it just left me head scratching & going *wtf?!* (only in politer language) :)
14:11:20 <sjanssen> AllNight^: more like 'there are not enough constraints to figure out the actual types of both parameters of the Iso class'
14:11:48 <monochrom> the "closed world assumption" is not used.
14:11:51 <Heffalump> the type-checker just applies a set of rules. The set of rules is determined by what is justified under an open world assumption.
14:12:12 <AllNight^> ah ha - I think I had been assuming 'closed world'
14:12:33 * AllNight^ needs to double check that means what he thinks it does... but that makes more sense now!
14:12:41 <AllNight^> thanks everyone :)
14:13:26 <sjanssen> AllNight^: one rule that Haskell generally tries to follow is that adding instance declarations will not cause a valid program to become invalid
14:14:01 <AllNight^> for what it's worth... theres a paper on strongly typed _hetrogenous_ collections in Haskell than I'm trying to follow & the author is using multi-parameter type classes
14:14:21 <AllNight^> so I decided I probably ought to understand those first before I tried to figure out what he was on about
14:14:49 <Peaker> Twinside, byorgey: Are you sure the dot product is right? I am getting very quick light deterioration (only a small spot on the ball is properly lighted)
14:15:16 <AllNight^> paper is here: http://homepages.cwi.nl/~ralf/HList/paper.pdf
14:15:33 <AllNight^> and looks very interesting!
14:16:13 * AllNight^ doesnt not pretend to understand yet - but is working towards that goal (I understand _what_ it does, but not _how_ it does it)
14:16:36 <Heffalump> AllNight^: that stuff is clever, but also quite ugly
14:17:02 <Heffalump> I tend to think of it as a last resort :-)
14:17:17 <AllNight^> but others might like to check that paper - he does things I though where impossible in haskell - like having lists with elements of different types in them, of unbounded length, and then have generic accessors)
14:17:34 <Heffalump> it's a well-known paper, FWIW
14:17:35 <AllNight^> (not my best summary of a paper - anyone interested, I recommend it) :)
14:17:57 <Peaker> AllNight^, I just learned about existential types the other day.. seemed like magic at first, but pretty simple now :)
14:18:06 <Heffalump> and one of the authors, Oleg Kiselyov, is well-known for working magic with the type system in many ways
14:18:37 <monochrom> It works by assigning to each list a type as large as the length of the list.  A custom-made nesting tuple type.  Since you don't have to write out the type yourself, you don't pay.  The compiler pays.
14:19:05 <sjanssen> you may pay in vastly increased compilation time :)
14:20:13 <AllNight^> hi Peaker :)
14:20:19 <Peaker> hi AllNight^
14:21:56 <hpaste>  thomashartman1 pasted "need help installing plugins" at http://hpaste.org/8054
14:22:01 <twobitwork> monochrom: so what happens when you add to the list?
14:22:15 <AllNight^> well ... that too had a purpose... I aiming (eventually) to make Haskel talk to Postgres via the CodFish library... but that builds ontop of HLists
14:22:22 <monochrom> The new list has a different and larger type than the old list.
14:22:30 <AllNight^> and a) HLists look very useful anyway
14:22:51 <AllNight^> and b) I'm uncomfortable building code on top of deep magic I dont understand
14:23:08 <thomashartman1> do I need to hide the more modern cabal packages installed, so the plugins install picks the older one?
14:23:24 <monochrom> The large type has equivalent information to "the 1st item is an Int, the 2nd item is a Bool, ... and this list has 26 items".
14:24:13 <twobitwork> monochrom: wouldn't that break foldl, etc? because the function has to be (a -> b -> a)
14:24:19 <twobitwork> or am I thinking backwards...?
14:24:21 <monochrom> The typeclass gives you back genericity over all such types.
14:24:28 <twobitwork> ahh
14:25:24 <monochrom> foldl is going to be tricky or impossible.
14:26:34 <twobitwork> hmm.. I also have a hard time thinking of instances you would need omnimorphic(?) lists...
14:27:15 <monochrom> "heterogenous" is the usual name
14:27:20 <twobitwork> ahh, of course
14:27:43 <twobitwork> that was on the tip of my tongue... but my fingers wouldn't type it
14:27:51 <thomashartman1> ok, askin the list about the plugins install issue.
14:28:29 <monochrom> Some applications of heterogenous list can switch to homogenous list plus existential type, e.g., "I am thinking OOP, I have a list of Shape, Shape may be Circle or Rectangle or... and I want to leave it open-ended."
14:28:56 <dons> i'd argue almost all common uses of hlists are actually existentially quantiifed lists.
14:29:31 <Heffalump> existentially quantified but homogenous?
14:29:40 <dons> yep.
14:29:51 <quicksilver> well they're finite length
14:29:51 <dons> [T] , data T = forall a. C a => T a
14:29:52 <Heffalump> that would seem a silly thing to do
14:29:59 <quicksilver> so they only cover a finite number of types
14:30:08 <quicksilver> so you can unify those types into some kind of class
14:30:09 <Heffalump> existentially quantified homogeneous lists are way simpler
14:30:12 <quicksilver> even if only trivially :)
14:30:17 <Peaker> average of 2 colors is the average of each component separately?
14:30:19 <quicksilver> HLists should not be thought of as lists.
14:30:28 <quicksilver> they are tuples with clever type-class functions
14:30:48 <Peaker> quicksilver, even existential-type-containing lists?
14:30:49 <monochrom> Yes Peaker. Linear algebra rulez.
14:30:57 <geezusfreeek> Peaker: that is one way of many to blend colors, sure
14:30:57 <Heffalump> AllNight^: What does the Codfish library do? Googling for "codfish postgres" doesn't provide much enlightenment.
14:31:17 <vincenz> Heffalump: what's with the @?
14:31:22 <quicksilver> tehre are two ds in codd
14:31:38 <vincenz> quicksilver: and one in cod :)
14:31:41 <Heffalump> vincenz: forgot to drop it after banning something a day or two ago
14:31:42 * quicksilver nods
14:31:44 --- mode: Heffalump set -o hellige
14:31:48 --- mode: Heffalump set -o Heffalump
14:31:49 <Heffalump> DOH!
14:31:59 <quicksilver> but in the context of sql, I'm sure he means coddfish
14:33:09 <AllNight^> there we go Heffalump
14:33:36 <AllNight^> talk to a datase the way it should be done... with static check you code prefereves refernital integrity
14:33:54 <Heffalump> thanks
14:33:55 <AllNight^> and no silly messing about with creating sql-strings on the fly
14:34:00 <AllNight^> np! :)
14:34:13 * AllNight^ hopes you find it usefu;
14:34:26 <AllNight^> useful even!
14:34:59 <AllNight^> I want to a) get it to work with postgres (a package I know)
14:35:14 <Heffalump> how does it differ from HaskellDB?
14:35:21 <travisbrady> does anyone know of a binary of 6.8.2 for Ubuntu?
14:35:30 <vincenz> travisbrady: hardy ships with it
14:35:35 <vincenz> travisbrady: and there's one on the download page
14:35:39 <AllNight^> and b) if necessary extend it allow postgree features like table inheritance, MVCC transaction support & so on
14:35:52 <travisbrady> vincenz: i checked the dl page and got that one but i'm hitting errors
14:35:55 <vincenz> AllNight^: yhow familiar are you with haskell?
14:35:57 <vincenz> travisbrady: try the other one
14:36:01 <vincenz> travisbrady: the one for readline5
14:36:02 <travisbrady> i thought maybe it was related to the fact that it's compiled for fedora
14:36:32 <AllNight^> no - I'm a newbie with Haskell vincenz, but experince with Java, Scheme & various others
14:36:44 <travisbrady> vincenz: i'm on 64 bit linux btw
14:36:54 <AllNight^> I'm not a new programmer, just new to haskell :)
14:36:57 <vincenz> AllNight^: it seems like you're trying to push a oo-mentality into haskell :)
14:37:11 <vincenz> AllNight^: I'd try starting with learning haskell before you force a dsign-decision
14:37:33 <vincenz> travisbrady: yes, 6.82 for readlin should work, if you get some missing things, make sure to install the -dev packager
14:37:40 <AllNight^> I'm trying to push seamless database access into haskell - software transactional memory :)
14:37:57 <vincenz> AllNight^: haskell has stm
14:38:33 <quicksilver> conversely, no SQL db satisfies serialisability
14:38:33 <AllNight^> exported as relational database?
14:38:39 <quicksilver> so no SQL db has STM-appropriate properties
14:38:56 <Heffalump> serialisability?
14:39:05 <hpaste>  travisbrady pasted "GHC Install on Ubuntu" at http://hpaste.org/8055
14:39:08 <travisbrady> vincenz: the 64 bit binary fails with ^^
14:39:09 <AllNight^> that depends on transaction isolation modes surely?
14:39:11 <quicksilver> the illusion that transactions are executed in serial
14:39:19 <quicksilver> AllNight^: no. All transaction isolation modes fail.
14:39:30 <travisbrady> which i can fix
14:39:31 <bd_> quicksilver: so does STM, it just retries
14:40:05 <Heffalump> can you give an example of how that illusion is violated?
14:40:08 <hpaste>  travisbrady pasted "GHC make install failure" at http://hpaste.org/8056
14:40:21 <travisbrady> but then i get ^^ and i'm not sure how to fix that
14:41:12 <AllNight^> anyway - I said it was a long term project... something to do to teach the laguage with
14:41:23 <AllNight^> (shock! horror! possible real world uses)
14:41:25 <AllNight^> :)
14:41:38 <Heffalump> we've got quite a few of those already :-)
14:41:41 <AllNight^> teach me the language*
14:41:41 <vincenz> travisbrady: install build-tools
14:41:49 <vincenz> travisbrady: I believe
14:42:11 <travisbrady> vincenz: is that in apt?
14:43:02 <AllNight^> I am allowed to lurk btw?
14:43:13 <AllNight^> I canrt stay much longer irl
14:43:26 <Heffalump> yes, loads of people do
14:43:29 <vincenz> travisbrady: hmm, now I Can't remember
14:43:31 <AllNight^> cool :)
14:43:43 <AllNight^> I'll just watch & see what I pick up then
14:43:46 <vincenz> travisbrady: did you download the 64bit version?
14:43:48 <AllNight^> thanks Heffalump
14:44:06 <Heffalump> it's very busy, you could spend your entire life keeping up :-)
14:45:01 <roconnor> what is bind for the reader monad
14:45:14 <roconnor> as a combinator.
14:45:18 <vincenz> @src (-> a) (>>=)
14:45:19 <lambdabot> Source not found. Just try something else.
14:45:20 <AllNight^> gnight all :)
14:45:33 <quicksilver> bd_: yes but the point is the SQL dbs in question do not retry
14:45:38 <vincenz> a >>= b = \x -> b x  (a x)
14:45:41 <vincenz> roconnor: I think that
14:45:42 <quicksilver> bd_: they happily commit incorrect and inconsistent data
14:45:46 <quicksilver> bd_: and isolation levels be damned.
14:45:49 <vincenz> erm
14:45:52 <vincenz> b (a x) x
14:45:53 <roconnor> like how map is (.) and join is W
14:46:06 <quicksilver> set transaction isolation mode = serializable; # EPIC FAIL
14:46:08 <dbueno> @seen dcoutts
14:46:08 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 10h 27m 32s ago.
14:46:14 <BMeph> ?src ((->)a) (>>=)
14:46:14 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:46:14 <dbueno> @seen dcoutts_
14:46:15 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 3h 11m 21s ago.
14:46:18 <dolio> (>>=) is like flip S.
14:46:19 <roconnor> and how ap is S
14:46:28 <vincenz> roconnor: ap is S if typed
14:46:39 <vincenz> :t ap
14:46:41 <dolio> Or, not flip S.
14:46:41 <roconnor> dolio: I don't think that can be right
14:46:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:46:59 <dolio> S . flip maybe.
14:47:03 <roconnor> oh
14:47:08 <roconnor> it is kinda like S
14:47:23 <roconnor> S . flip I could believe
14:49:16 <BMeph> flip S is bind, and const is return.
14:49:16 <tchakkazulu> (>>=) is not really flip S. You need to flip the second parameter to (>>=) as well.
14:49:16 <roconnor> BMeph: I think think flip S is bind
14:49:16 <roconnor> er
14:49:16 <roconnor> I don't htink flip S is bind
14:49:16 <dolio> I guess it's (=<<) = S . flip
14:49:16 <tchakkazulu> a >>= f = s (flip f) a, though.
14:49:16 <roconnor> @pl \a f -> s (flip f) a
14:49:16 <lambdabot> flip (s . flip)
14:49:17 <roconnor> I always think of =<< as bind anyways
14:49:30 <roconnor> in my own little world
14:49:50 * BMeph hopes roconnor is happy, in his little world...
14:50:05 <roconnor> and where everything typechecks
14:51:00 <Heffalump> quicksilver: but you can abort a transaction, right?
14:51:23 <Heffalump> and the transaction gets a consistent view of the world when it does reads
14:52:18 * BMeph has to go pay off the car mechanic now...
14:52:22 <BMeph> Ciao! :)
14:53:36 <travisbrady> vincenz: i did download the 64-bit version yes
14:54:07 <vincenz> travisbrady: not sure then
14:54:23 <travisbrady> hmmm
14:54:59 <travisbrady> vincenz: what is build-tools?
15:12:14 <Socrates`> > (1 / 0)
15:12:15 <lambdabot>  Infinity
15:12:25 <Socrates`> > (1 / (-0))
15:12:26 <lambdabot>  -Infinity
15:12:40 <Socrates`> > (1 / 0) ** (1 / (-0))
15:12:41 <lambdabot>  0.0
15:12:45 <mrd> > 0 / (-0)
15:12:46 <lambdabot>  NaN
15:15:20 <dcoutts> dbueno: hia
15:16:03 <dcoutts> thomashartman1: that would work or if you're using a recent Cabal then you can apply constraints on the versions of deps picked at configure time
15:16:06 <dsrogers> oh no! no lurky?
15:16:18 <dsrogers> who's gonna lurk now!
15:16:23 <dsrogers> we'll be lurkless
15:16:33 <Twey> Haha
15:16:44 <opqdonut> .
15:16:51 <dcoutts> bos: I think that certainly cabal-install should come with the haskell platform
15:17:05 <dcoutts> bos: I dunno about as part of ghc itself since that is tending to be smaller
15:17:36 <dcoutts> bos: but so long as we can put together a sensible set of platform packages and release them as a "batteries included" thing then that'd be ok
15:18:35 <dcoutts> bos: I see that as the medium/long term packaging goal, to develop the infrastructure to make high quality platform releases from a ghc release + a subset of packages on hackage
15:19:00 <dcoutts> first step of course is a Cabal-1.4 release and a cabal-install release
15:19:07 <dcoutts> which I hope to have soon
15:19:42 <dcoutts> I'll put out another pre-release in a day or two hopefully
15:23:14 <mm_freak> @src fix
15:23:14 <lambdabot> fix f = let x = f x in x
15:24:02 <mm_freak> > fix (:) 3
15:24:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
15:24:06 <lambdabot>     Pro...
15:24:20 <vixey> > fix (flip (:)) 3
15:24:21 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a -> [a]'
15:24:26 <mm_freak> > fix (3:) []
15:24:26 <monochrom> You may like to try fix (3 :)
15:24:27 <lambdabot>  Couldn't match expected type `[a] -> t'
15:24:35 <vixey> > (fix . (flip (:))) 3
15:24:35 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
15:24:35 <lambdabot>       Expected...
15:24:40 <vixey> > (fix . (:)) 3
15:24:41 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
15:24:53 <mm_freak> hmm
15:25:03 <monochrom> You will understand why. :)
15:25:14 <mm_freak> fix (+1) is an infinite number?
15:25:35 <mm_freak> essentially \x -> x + 1 + 1 + 1 + 1 + ‚Ä¶ ?
15:25:43 <ddarius> > fix (1+) :: Expr
15:25:45 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
15:25:47 <monochrom> Yes. x = x+1.
15:26:08 <monochrom> err, x = 1+x.
15:26:14 <mm_freak> ok‚Ä¶  any real uses other than obscuring code?
15:26:23 <mm_freak> x+1 in my case =)
15:26:24 <vixey> real uses of what?
15:26:40 <mm_freak> of 'fix'
15:26:42 <monochrom> Thinking holistically.
15:27:04 <mm_freak> i've seen it being used a lot in pointless code
15:27:20 <monochrom> Sufficiently holistic abstractions look like obfuscated code.
15:27:26 <ddarius> Occasionally it fits nicely, most of the time explicit recursion is better.
15:28:00 <monochrom> IIRC there are a couple of fix uses in xmonad.  Don't say it's obscure or obfuscating or impractical.
15:29:40 <mm_freak> unless studying code from others, i think i can live happily without fix
15:29:57 <monochrom> That's what every beginner says.
15:30:07 <ddarius> And they're right.
15:30:24 <twanvl> We can fix that!
15:30:27 <monochrom> They probably say the same about laziness, monads, arrows, functional programming.
15:30:27 * twanvl ducks
15:30:33 <mm_freak> monochrom: some things _really_ are stupid, like point-free overuse (rendering code point-less)
15:31:00 <monochrom> "overuse" is tautologically stupid. That statement adds no information.  <duck>
15:31:38 <mm_freak> good use:  isqrt = truncate . sqrt . fromIntegral
15:32:35 <mm_freak> and you recognize overuse by liftM, flip and a lot of nasty compositions =)
15:32:54 <ddarius> What's wrong with liftM?
15:33:11 <monochrom> If you say liftM2 you begin to have a case.
15:33:37 <monochrom> You see how "overuse" varies with your level.
15:33:43 <mm_freak> ddarius: nothing, but lambdabot likes to spit out a lot of lifts
15:33:59 <monochrom> Have you taken a logic course?
15:34:12 <monochrom> Do you know "exist x. Px" does not imply "forall x. Px"?
15:34:34 <Twey> Heh
15:34:42 <mm_freak> monochrom: ?
15:35:09 <monochrom> For example, "there exist a logic course using a tedious proof system" does not imply "all formal logics are tedious".
15:35:28 <mm_freak> i didn't say that
15:35:33 <dobblego> do you watch television? of course it implies that!
15:35:40 <monochrom> I'm just going off a tangent.
15:36:36 <mm_freak> i like point-free style, when it's appropriate‚Ä¶  "overuse" starts for me, where the pointy style is more readable than point-free
15:36:55 <monochrom> "readable" varies with your level too.
15:37:25 <mm_freak> yes, it does‚Ä¶  and i prefer not to expect from code readers to have a Ph.D. =)
15:37:27 <dobblego> I have people tell me that 4 pages of Java is more readable than the equivalent 20 characters of Haskell
15:37:43 <monochrom> I don't have a PhD either.
15:37:49 <dbpatterson> dobblego: well, they definitely do more 'reading'
15:37:50 <chessguy> dobblego:  that depends on whether or not you know haskell :)
15:37:53 <Twey> If you don't know Haskell, well yeah :-P
15:38:20 <monochrom> Everyone should aspire to doing more.
15:38:28 <dobblego> chessguy, actually, it depends on whether or not you *only know Java*, since people who know neither can read the Haskell and people who know both agree the Haskell is significantly easier to read; these are my anecdotes
15:38:40 <Philippa_> dobblego: if it's 20 characters then that can easily be the case
15:38:42 <chessguy> either way, though, i'd rather look for bugs in 20 characters than 4 pages, regardless of the language
15:38:59 <mm_freak> that's actually one great thing about haskell‚Ä¶  you can understand its code, even if you don't know it, unless bizarre haskell peculiarities are used too much =)
15:39:07 <dbpatterson> chessguy: have you seen some (intentionally) obfuscated code before?
15:39:22 <dcoutts> @seen dbueno
15:39:22 <lambdabot> dbueno is in #haskell. I last heard dbueno speak 53m 8s ago.
15:39:23 <chessguy> dbpatterson:  sure
15:39:27 <dcoutts> dbueno: ping
15:39:34 <chessguy> dbpatterson:  obviously that's not what we're talking about
15:39:47 <dbpatterson> just being a pain, that's all
15:39:50 <lament> chessguy: even if the 4 pages are more or less English, and 20 characters are '*@$X!√±3!√•*[[=~//\√©|=' ?
15:39:56 <ddarius> Bizarre Haskell peculiarities like lazy evaluation!
15:40:16 <mar77a> haskell is
15:40:16 <dobblego> lament, even then, it's easier to determine what the 20 characters mean
15:40:17 <chessguy> like higher order functions :)
15:40:20 <mar77a> impossible to read
15:40:24 <vixey> hehe
15:40:24 <mar77a> unless you know haskell
15:40:25 <mm_freak> ddarius: that's not bizarre =)
15:40:36 <Vq^> try describing fix to a Java monkey...
15:40:38 <monochrom> I write my code assuming readers to be much trained, and this is because I want to work with programmers much trained.
15:41:09 * chessguy gets a funny picture in his head of what a "Java monkey" would look like
15:41:10 <dobblego> monochrom, I completely agree
15:41:28 <monochrom> I am happy to explain it to beginners in elementary terms, but I want to bring everyone up one level. It's my contribution to the world.
15:41:46 <mm_freak> Vq^: good point‚Ä¶  try to describe "iterate f x" as an infinite list =)
15:42:31 <mm_freak> people from other languages are used to list generators, but 'iterate f x' is not a generator for an infinite sequence‚Ä¶  it _is_ an infinite list itself
15:42:50 <monochrom> If everyone thinks "everyone is at the elementary level" and writes code accordingly, how can there be progress?
15:42:51 <ddarius> IEnumerable<A> Iterate<A>(Func<A,A> f, A a) { while(true) { yield return a; a = f(a); } }
15:43:05 <vixey> cool
15:43:19 <vixey> what sort of stuff can you do inside those <>'s?
15:43:21 <Philippa_> chessguy: coffee in one end, code out of the other
15:43:36 <monochrom> So, at your place in the world, write code at just 0.1 level above the average. That will gradually bring your whole team up.
15:43:42 <vixey> do the only bind names?
15:43:46 <chessguy> haha
15:43:47 <mm_freak> monochrom: not at the elementary level, but you'll agree that some things really don't add any value, but make code less readable to beginners
15:43:48 <Philippa_> they even fight by flinging code at each other
15:43:49 <ddarius> vixey: That's C# by the way (and we know they've been infiltrated by insidious Haskell programmers)
15:44:32 <monochrom> I'll agree because the statement is vacuous.
15:44:50 <monochrom> Or at least, most of the time vacuous, vacuous in practice.
15:44:56 <mm_freak> monochrom: why?  because i didn't name any examples?
15:45:12 <shepheb> argh, I can't get this darcs patch off the mailing list through TBird through GMane, from the haskell.org pipermail archives or anywhere. it's always failing the hash
15:45:19 <dobblego> mm_freak, some code, like Haskell, is less readable to beginners, therefore, we should all use Java
15:45:20 <dmwit> mm_freak: "some things" is sufficiently vague to mean anything.
15:45:25 <monochrom> Most of the time, the use of an advanced technique does add value, and therefore justifies being unreadable by beginners.
15:45:36 <Taggnostr> what is an infix operator?
15:45:44 <dmwit> Taggnostr: Like (+).
15:45:45 <shepheb> it doesn't contain CRLFs. I think it might be about leading and trailing newlines
15:45:55 <dmwit> Taggnostr: It goes "in between" its two arguments.
15:45:56 <monochrom> You can name lots of examples that no sane one ever does, not even me.
15:46:05 <Taggnostr> ok
15:46:17 <Socrates`> > (+) 1 2
15:46:18 <dmwit> Taggnostr: Hence "infix".  Contrast "prefix" (before its arguments) and "postfix" (after its arguments).
15:46:18 <lambdabot>  3
15:46:19 <Socrates`> > 1 + 2
15:46:21 <lambdabot>  3
15:46:47 <monochrom> Obsession with beginners is unhealthy. It's equivalent to obsession with infants.
15:46:53 <chessguy> oh man, i had a great interview question today
15:47:02 <chessguy> "Name the 4 cornerstones of Object Oriented programming"
15:47:19 <monochrom> English is utterly unreadable to infants. Let's use infant languages in this channel.
15:47:20 <mm_freak> dobblego: well misinterpreted‚Ä¶  you completely missed my point =)
15:47:21 <chessguy> i almost laughed out loud
15:47:33 <mm_freak> dmwit: true
15:47:37 <ddarius> What was the answer?  PIE is only three.
15:47:38 <dobblego> mm_freak, actually, I completely understood your point; I think you missed mine
15:47:46 <Philippa_> chessguy: optimism, sloppiness, bullshit and appropriation?
15:47:54 <chessguy> ddarius:  PIE?
15:48:05 <Philippa_> Polymorphism, Inheritance, Encapsulation
15:48:17 <chessguy> oh, never heard that acronym before
15:48:19 <shepheb> Kool-Aid?
15:48:26 <mm_freak> dobblego: i didn't‚Ä¶  i don't promote easy-to-understand code for the sake of beginners, but for the sake of readability
15:48:29 <chessguy> though i named those all, plus abstraction
15:48:37 <dobblego> mm_freak, and that's my point
15:48:39 <chessguy> it's just such a silly question
15:48:58 <dobblego> mm_freak, the term "readability" is relative to you
15:49:10 <monochrom> readable to much trained readers.
15:49:16 <dobblego> mm_freak, since beginners claim that Java is more readable than Haskell, should we continue to use Java?
15:49:25 <infrared> is inheritance so crucial? you can certainly have OO without classes..
15:49:27 <chessguy> "And Bjorne Stroustrap spoke from heaven and said, 'The cornerstones of OOP are 4, and 4 shall be the number of their counting..."
15:49:28 <dobblego> if not, then should we use "what is readable to us?" or should we aspire to be better?
15:49:30 <shepheb> ugh I'm doing the job interview thing, I need to brush up on my OO terminology and design patterns, because I know those questions are coming
15:49:34 <monochrom> As said, I'm happy to help beginners understand.
15:49:39 <ddarius> infrared: Inheritance doesn't need classes.
15:49:49 <Vq^> infrared: and you can have inheritance without classes
15:50:03 <infrared> still, you don't need inheritance to have OO
15:50:03 <dobblego> you can replace Java with "sloppy Haskell" in that statement
15:50:22 <mm_freak> it's about the same as doing excess pointer arithmetic magic in C, rendering code a little bit more compact, but almost impossible to comprehend
15:50:28 <ddarius> Many OO languages don't have "Encapsulation" either.
15:50:42 <chessguy> shepheb:  yeah, i got a few that kind of caught me off guard today
15:50:43 <monochrom> And as said, "unreadable and adds no value" is bad, but no intelligent person does that.
15:50:46 <mm_freak> it adds no value in the end, but the readability suffers a lot
15:50:51 <vincenz> @seen cale
15:50:52 <lambdabot> cale is in #haskell, #haskell-overflow and #ghc. I don't know when cale last spoke.
15:51:10 <mm_freak> monochrom: true, and i didn't claim that
15:51:21 <zopeland`> ls
15:51:41 <shepheb> it's just such an empty exercise. in order to get a job, I need to learn names for things that I thought were common sense.
15:51:50 <shepheb> well, I hope to avoid that.
15:51:52 <Vq^> zopeland`: Command not found
15:52:06 <Twey> zamez: Bad command or file name.
15:52:19 <monochrom> You may like to know that x+y=y+x has a name too: commutativity.  Actually two: Abelian group.
15:52:34 <zopeland`> Vq^: ups :)
15:52:35 <monochrom> or Abelian monoid. or just Abelian. :)
15:52:39 <mm_freak> x+y = y+x doesn't imply a group
15:52:43 <Twey> Er, zopeland`**
15:52:50 <Twey> Dang Dvorak typos.  Heh
15:53:06 <mm_freak> i'd just call it commutativity =)
15:53:09 <monochrom> x=x has a name too :)
15:53:26 <monochrom> abelian is shorter but less well-known
15:53:28 <chessguy> ?free x=x
15:53:28 <lambdabot> Extra stuff at end of line
15:53:37 <mm_freak> @whatis reflexivity
15:53:37 <lambdabot> I know nothing about reflexivity.
15:53:42 <chessguy> @pl \x -> x==x
15:53:42 <lambdabot> join (==)
15:53:46 <monochrom> "x=y implies fx=fy" has a name too
15:54:13 <ddarius> injectivity is not "common sense", it's not even true most of the time
15:54:22 <chessguy> wow, what do you know, lots of things have names. there must be a pattern here!
15:54:29 <monochrom> err, as usual, two names actually. referential transparency, leibniz fule
15:55:05 <infrared> ddarius: by inheritance without classes you meant clone+extend in language with prototypes? or maybe sth else?
15:55:34 <monochrom> ddarius: no no not injectivity.
15:55:36 <ddarius> infrared: That's one possibility.  There's delegation and scoping as well.
15:55:43 <ddarius> monochrom: I know I read the implication backwards.
15:55:45 <mm_freak> @pl \a b -> rem a b == 0
15:55:46 <lambdabot> flip flip 0 . ((==) .) . rem
15:55:57 <mm_freak> that's what i consider point-free "overuse" =)
15:56:13 <monochrom> Yes.
15:56:30 <Twey> I wouldn't if I could read it.  :-P
15:56:31 <infrared> ddarius: delegation, but still in the prototypes world?
15:56:39 <augustss> :t flip flip
15:56:41 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
15:56:52 <ddarius> infrared: Delegation doesn't need prototypes.
15:57:09 <mm_freak> Twey: i would, even if i could read it fluently, because no matter how well you can read it, the pointy version is still better, because it tells you immediately what it is
15:57:34 <Twey> You could be right.  Bit o' KISS going on there.
15:58:02 <shepheb> anyone share their secrets for getting a hash-passing darcs patch out of a mailing list?
15:58:15 <infrared> ddarius: oh, you mean that an object that "inherits" will simply delegate to another object messages it doesn't understand?
15:58:34 <ddarius> infrared: That's one possibility,yes.
15:58:56 <infrared> ddarius: one possibility, is there another with delegation?
15:59:40 <osfameron> where can I download cabal-install from?
15:59:49 <dcoutts> @where cabal-install
15:59:49 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
16:00:13 <osfameron> dcoutts: thanks, but that doesn't seem to point to a stable download, just a darcs repo
16:00:17 <dcoutts> osfameron: the version you'd want is the devel version in darcs
16:00:28 <dcoutts> the released versions are far too old to be useful
16:00:57 * osfameron does the "download yet another bloody vcs because I want to install something" dance
16:01:11 <dcoutts> osfameron: if you prefer tarballs there was a pre-release of Cabal-1.4 and cabal-install a month or so ago
16:01:22 <dcoutts> I'll be doing another pre-release soonish
16:01:35 <osfameron> cool, yeah
16:01:52 <dcoutts> osfameron: it's because it depends on the devel version of the Cabal lib so that's why there has not been a stable release of cabal-install for a while
16:02:17 <osfameron> it's probly not that taxing to "man darcs" to read the command I need to install it, but it's even easier to unpack a tarball :-)
16:02:17 <dcoutts> and making new releases of the Cabal lib needs significant testing so that people do not shout at us :-)
16:02:22 <osfameron> true
16:02:57 <dcoutts> osfameron: darcs get --partial http://the.thing/that/you/want/
16:03:11 <osfameron> lovely thanks
16:03:54 * vixey hastily clicks the URL
16:04:03 * osfameron wonders why aptitude felt the need to set up exim4 in order to install darcs...
16:04:52 <monochrom> turn off "automatically install recommended packages"
16:05:17 <ddarius> infrared: You are consistently being overspecific.  Here's another possibility, you have interceptors around method invocation or the methods themselves are objects.
16:06:07 <monochrom> Ah, maybe there is another reason. darcs sometimes sends out mail (upon your command). someone wants it to depend on a mailer. you can choose mailx, mutt, exim4...  one of them get defaulted.
16:07:40 <monochrom> Ha, it's a combination of both.  Recommends installing exim4 or mail-transport-agent, where the latter offers a lot of choices.
16:07:40 <dbueno> dcoutts: The solver backend runs!  Unfortunately it gives the wrong answer.
16:07:50 <infrared> ddarius: how methods as objects help inheritance?
16:07:51 <dcoutts> dbueno: woo hoo!
16:08:06 <monochrom> Turn off "automatically install recommended things".  It's evil.
16:08:08 <dcoutts> dbueno: heh, don't worry, mine did that too the first three times :-)
16:08:11 <ddarius> The context was delegation.
16:08:38 <dcoutts> dbueno: are you finding the InstallPlan validation helpful in explaining what's wrong with the plans you generate?
16:08:40 <infrared> ddarius: ok, then how methods as objects help inheritance in context of delegations?
16:08:53 * dbueno is not using installplan validation
16:09:06 <dbueno> dcoutts: I would think it tremendously helpful.  Is there an example of such usage in the TopDown solver?
16:09:14 <dbueno> err... TopDown backend.
16:09:58 <dbueno> dcoutts: Oh, also, it determined the problem was unsat, so, it didn't even get a putatively valid InstallPlan.
16:10:00 <dcoutts> dbueno: the Dependency module takes the result of the resolver and validates it using InstallPlan.new
16:10:00 <ddarius> How does delegation help inheritance?
16:10:10 <dbueno> dcoutts: So right now, the point is moot, since it doesn't even get that far.
16:10:18 <dcoutts> dbueno: ok
16:10:47 <dcoutts> dbueno: when you're closer, use InstallPlan.new and if it gives you errors use map InstallPlan.showPlanProblem problems
16:11:09 <dcoutts> dbueno: for reference see how the Dependency module does it
16:11:11 <dbueno> dcoutts: Ah, great, I'll make a note of that.
16:11:58 <dcoutts> dbueno: of course if you actually plug it in as a resolver that the Dependency module knows about then that'll all happend automatically but it may be useful to you while you're testing/debugging
16:12:09 <dcoutts> to call it explicitly
16:12:24 <osfameron> hmmm, the README for cabal-install doesn't tell you how to install cabal-install
16:12:36 <dbueno> dcoutts: Great.  I'll use it explicitly for the time being; all I did to call my backend was change "defaultResolver"
16:12:44 <osfameron> it should probably cite the basic runghc Setup.hs incantations at least
16:12:53 <dcoutts> osfameron: probably so
16:13:03 <dcoutts> dbueno: right
16:17:00 <infrared> ddarius: with delegation you can inherit from another object by handling extra methods and delegating to this object for the rest of messages. Handling of the other methods can be done explicitly, or by wrappers/interceptors as you suggested. what about methods as objects, how that help?
16:17:43 <ddarius> infrared: The methods themselves can choose whether to delegate or not.
16:18:29 <dbueno> dcoutts: When I actually get it to produce a plan, it should list all the problems in the Fail message now: thanks for the tip.!
16:20:23 <dcoutts> dbueno: btw when you've got something nearer to working I'd love to talk about error reporting, how you might construct human readable error messages explaining why their request cannot be satisfied
16:20:53 <dcoutts> dbueno: it actually seems to be one of the harder aspects of this problem
16:20:56 <dbueno> dcoutts: Yeah, I have some (I think good) ideas for that, too.  I'll let you know when I'm closer.
16:21:02 <dcoutts> dbueno: great
16:21:06 <dbueno> dcoutts: Indeed, it doesn't just "fall out".
16:21:25 <dcoutts> I do it by remembering all the reasons for each constraint
16:21:44 <dcoutts> and then when I get conflicting constraints I can look up why all the alternatives were excluded
16:22:13 <osfameron> dammit!  I also need HTTP, network, and zlib...  I guess all these things will be packaged with a future install of ghc eventually
16:22:21 <dbueno> dcoutts: part of the problem is the sat solver produces a total assignment.  And right now, the SAT problem has 114000 variables.
16:22:31 * osfameron sighs and calls it a night
16:22:47 <dbueno> dcoutts: I remember such "reasons" too, so, perhaps it could be leveraged.  I think I can do something slightly better, though.
16:22:57 <dcoutts> dbueno: wow :-) is that for trying to install all of hackage simultaneously or something?
16:23:01 <vixey> where do you get a problem with 114000 variables?
16:23:05 <dbueno> dcoutts: An "unsatisfiable core" is a sub-portion of the sat problem which is itself unsat.
16:23:06 <vixey> oh!
16:23:31 <vixey> I should have thought it's just a topological sort
16:23:35 <dbueno> dcoutts: I think there is a clever way to get that; which would make the offending (unsat) part as small as possible (or at least "small enough").
16:23:38 <dcoutts> vixey: hah, no.
16:23:59 <dcoutts> vixey: you can encode 3SAT into the package dep problem, ergo it's an NP-complete problem
16:24:19 <dcoutts> dbueno: right, and perhaps the core conflict is small enough to describe as an error message
16:24:38 <dbueno> dcoutts: Right now I just asked it to install one package, but, currently it encodes all of hackage into the database, because it might need to resolve arbitrarily-many dependencies.  But I will need to be cleverer than that, it is obvious.
16:24:40 <dbueno> dcoutts: Right.
16:25:45 <dcoutts> dbueno: ah yes, I see. Right you can bound it by flattening each package and looking at the maximal possible deps. And do that transitively. That'll give you the maximum possible subset of packages that you'd ever have to consider.
16:26:11 <dbueno> dcoutts: Right.  I just don't do that, right now. =]  That will considerably reduce the size of the problem.
16:26:17 <dcoutts> but as you say it's just an optimisation
16:26:46 <dcoutts> since you want to be able to cope with someone wanting to install hundreds of packages anyway
16:26:46 <dbueno> dcoutts: It's heartening that currently it takes 7 minutes or so to convert the problem to CNF (to get the 114000-variable problem) but mere seconds to solve it. =]
16:26:57 <dcoutts> interesting
16:26:57 <dbueno> ... the solving part is heartening.  Not the other part.
16:27:02 <dcoutts> yes :-)
16:27:31 <dbueno> dcoutts: I expected that ... most of the variable assignments don't matter.  And it will be even shorter when I bound the number of packages I need to consider.
16:27:43 <dcoutts> dbueno: right
16:28:09 <dcoutts> dbueno: yeah, my solver seems to be able to get away with making guesses a lot of the time and still finding solutions
16:28:29 <dbueno> dcoutts: In fact ... the PackageIndex has nice functions that give you the transitive closure and whatnot, right?  Right now I explicitly map over all packages in the index ... I should easily be able to reduce it to an index in which only packages that matter are translated.
16:28:32 <dbpatterson> are there any functional GUI libraries that work well on linux? Been trying Phooey but it seg faults and doesnt update fields properly in the examples... would like to avoid using 'low level' imperative stuff (gtk2hs, wxhaskell) directly
16:28:49 <Pseudonym> If the guesses are sufficiently well-educated, that's cool.
16:29:10 <dbueno> dcoutts: I suspect that over time the problem will get harder --- I didn't even *know* you could use variables in a cabal file, but, I can imagine that if people start using that, it will be harder for approximate solutions to work.
16:29:23 <dcoutts> dbueno: it's a bit trickier since the transitive closure is only for indexes of packages that have exact deps, not version ranges
16:30:23 <dcoutts> dbueno: so you'd have to consider all versions of a package together, flatten them all and look at all their possible deps, probably without taking versions into account
16:30:45 <dcoutts> just looking at package names
16:31:00 <dbueno> dcoutts: Ah, okay.
16:31:06 * dbueno makes a note of it
16:31:29 <dcoutts> dbueno: I do something like that in my resolver to assign each package an index in topological order
16:31:50 <dcoutts> I use that index as the order in which I make guesses
16:33:25 <dcoutts> dbpatterson: there's also grapefruit
16:34:27 <dbueno> dcoutts: So I really want a tree traversal starting at the UnresolvedDeps, including all available/installed packages that can resolve deps; and this recursively.
16:34:39 <dbueno> (recursively on the dependencies of each package encountered)
16:35:00 <dcoutts> it's a depth first search of the graph
16:35:11 <dbpatterson> dcoutts: is it supported (as much as any open source software is) on linux? also, I was under the impression it was missing a lot of widgets, is this dated info?
16:35:28 <dcoutts> dbpatterson: yes on linux, yes probably limited
16:35:55 <dcoutts> dbpatterson: I've not tried it myself so I don't know how limited, I don't think you could call it production ready
16:36:20 <dbpatterson> dcoutts: thanks, I'll look into it
16:36:25 <dmwit> dbpatterson: I don't really understand what are new/old versions of what, but have you seen TV?
16:36:29 <dmwit> http://www.haskell.org/haskellwiki/TV
16:36:32 <lambdabot> Title: Tangible Value - HaskellWiki
16:37:06 <dbpatterson> dmwit: I was under the impression that it is pretty specific in scope? like for visualizing number crunching type stuff? is that incorrect (could be)?
16:37:14 <dmwit> dunno
16:37:21 <dmwit> I never have really looked into this stuff carefully.
16:37:58 <dmwit> The person to ask would be conal, he seems most active in this area.
16:38:22 <dbpatterson> dmwit: conal wrote phooey... but he only uses windows (and as a result, as cool as it looks, it seg faults/doesnt work on linux)
16:38:38 <dmwit> whoa, seg faults?
16:38:46 <dmwit> Does it really use super-low-level stuff?
16:38:56 <dmwit> (i.e. FFI stuff?)
16:39:09 <dbpatterson> dmwit: well, it is a wrapper around wx, which is a wrapper around wxgtk, which is C++...
16:39:22 <dbpatterson> Examples.Monad> runUI basket3
16:39:23 <dbpatterson> Segmentation fault
16:39:57 <dbpatterson> Now if only someone could write an OS in haskell... get rid of seg faults altogether...
16:40:15 <dmwit> That doesn't sound right.
16:40:23 <dmwit> I wonder if you have wx/etc. installed correctly.
16:40:27 * dmwit goes to try it
16:40:31 <bd_> dbpatterson: It's been done
16:40:42 <bd_> http://programatica.cs.pdx.edu/House/
16:40:42 <dbpatterson> dmwit: perhaps if I compile it vs running it in ghci it wont have that problem?
16:40:43 <lambdabot> Title: House
16:40:56 <dmwit> That should not fix it. =P
16:41:13 <dmwit> But dead chickens have been waved before, and I am told that these things work whether you believe in them or not.
16:41:34 <dmwit> ?hackage phooey
16:41:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/phooey
16:42:31 <dmwit> Oh boy, dependency chases!
16:42:31 <dbpatterson> dmwit: it could also be wx2.4/wx2.6 incompatibilities.. it seems like conal (as of august last year, anyway) was developing it on 2.4, and some fields wouldnt update on 2.6. But, the only people reporting the problem were using linux, so who knows
16:43:12 <dbpatterson> :)
16:43:23 <dbpatterson> bd_: is it super stable?
16:43:41 <dmwit> It's super incapable, if that's what you mean.
16:43:50 <dmwit> I think they were proud of displaying a GIF graphic on screen.
16:43:54 <dbpatterson> hehe
16:43:58 <bd_> dbpatterson: haven't tried it :)
16:47:57 <dbpatterson> dmwit: is it working?
16:48:05 <dmwit> I'm still installing.
16:48:14 <dmwit> (I didn't have any of the packages installed, or wxWidgets.)
16:48:34 <dbpatterson> ahh... what distro?
16:48:40 <dmwit> Ubuntu
16:49:26 <dbpatterson> should be somewhat similar then (debian here)
16:50:13 <dmwit> "I can't find the Unicode version of wxWidgets!"
16:50:19 <dmwit> What do I do about that?
16:50:20 <dmwit> 'P
16:51:15 <dbpatterson> add the wxgtk international package
16:51:44 <dbpatterson> wx2.6-i18n
16:51:51 <dbpatterson> (I believe)
16:52:36 <dmwit> I'm jumping straight to wx2.8, just to live on the edge. ;-)
16:53:08 <dbpatterson> dmwit: ahh, nice
16:53:16 <dmwit> Hoo hoo hoo!
16:53:22 <dmwit> -Wall doesn't like me
16:53:36 <dmwit> Luckily there's no -Werror...
16:55:05 <dmwit> Wow, have you waded through http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries ?
16:55:06 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yvrplw
16:57:31 <dbpatterson> dmwit: yeah, most of them are pretty old/unmaintained
16:57:41 <dmwit> seems that way
16:57:53 <dbpatterson> and I was only looking at the high level ones
17:01:42 <dbpatterson> it seems like until haskell has made it's way enough into the public realm for gui applications to be written by businesses, and thus full time paid people working on the libraries, it'll probably remain that way... conal seems to be the exception
17:02:23 <dcoutts> dbpatterson: yep, the only complete and maintained ones are the lower level ones, wx and gtk
17:02:58 <Pseudonym> One thing I'd like to point out is that there are no general-purpose standard GUI libraries for C++ either.
17:03:18 <Pseudonym> Or C.
17:03:38 <Pseudonym> This is an unsolved problem in general.  Haskell just happens to be no exception.
17:03:41 <dbpatterson> Pseudonym: I dont do much gui programming, but wouldnt people say Qt for C++ and gtk for C?
17:03:51 <dbpatterson> (on the linux front)
17:03:57 <Pseudonym> In the open source world, possibly.
17:04:11 <Pseudonym> The closest thing we have to a standard GUI library/framework for C is Motif.
17:04:13 <bos> Qt is pretty widely used in the commercial world, too.
17:04:16 <Pseudonym> And that's only X11.
17:04:20 <bos> nobody uses Motif.
17:04:29 <Pseudonym> As for Qt... it's not actually standard C++.
17:04:37 <Pseudonym> It's not even exception-safe.
17:04:47 <Pseudonym> bos: Completely untrue.
17:05:29 <Pseudonym> I'd say that the overwhelming majority of in-house GUI applications that aren't written for Windows are written in Motif.
17:05:41 <Pseudonym> Motif is still big business.
17:05:54 <Pseudonym> That's like saying "nobody uses CORBA".
17:06:07 <Pseudonym> Or "nobody uses COBOL".
17:06:32 <bos> Pseudonym: OK, nobody who isn't professionally stuck in 1993.
17:07:24 <lament> lol motif
17:07:39 <bos> all kinds of horrible software lives on for decades after anyone has stopped caring about it in any capacity beyond its ability to bring the next paycheck in.
17:08:00 <dbpatterson> so just in general, do people who do write gui software in haskell just use wx or gtk directly?
17:08:21 <dbpatterson> like a nasty imperative shell around a (hopefully) functional core?
17:08:28 <bos> dbpatterson: yes. gtk is now more widely used, but the numbers are small in any case.
17:08:31 <dbpatterson> or is it that noone is writing gui software t all
17:08:52 <tieTYT> haskell doesn't seem to be for frontends, but i'm a complete newb
17:09:24 <lament> i'm not aware of any living haskell projects that use a gui toolkit
17:09:40 <dbpatterson> lament: that's depressing
17:09:50 <lament> there's some toys and plenty of bitrotten stuff
17:09:51 <Pseudonym> I'm always wary of any claim that someone knows what a language is "for".
17:10:12 <lament> dbpatterson: the excuse is that people haven't figured out how to do GUI programming in haskell yet.
17:10:35 <tieTYT> Pseudonym: shouldn't you be more wary of a claim like "I'm a complete newb"?
17:10:37 <bos> lament: i think you're making stuff up.
17:10:45 <Pseudonym> Actually, peronsal opinion: Motif ain't so bad.
17:10:49 <dbpatterson> and people just point and conal (and functional reactive programming) and say he is working on it?
17:10:52 <Pseudonym> It's not that much worse than GTK.
17:10:55 <lament> dbpatterson: yes.
17:10:59 <Pseudonym> From an API point of view.
17:11:04 <dmwit> tieTYT: Oh, no, I'm sure he's quite confident to accept a claim like "I'm a newb". ;-)
17:11:11 <Pseudonym> tieTYT: :-)
17:11:18 <lament> dbpatterson: "see, we have papers and stuff, it's coming any day now"
17:11:53 <bos> it would definitely be fair to say that there are no good answers for GUI programming in a fairly pure functional context.
17:12:12 <lament> bos: how am i making stuff up then? That's what I meant.
17:12:31 <bos> lament: "in haskell" is not the same as "in the pure subset of haskell".
17:12:58 <dmwit> Bah, wxcore won't build.
17:13:01 * dmwit gives up
17:13:09 <lament> bos: it seems people aren't interested enough in doing stuff in haskell just for the sake of doing it in haskell to actually write software with a gui.
17:13:16 <dbpatterson> dmwit: is it bugging about a gcc flag?
17:13:22 <dbpatterson> -fno-something-reorder?
17:13:23 <lament> bos: i'm sure that would change if we did have a purely functional ui toolkit.
17:13:31 <tieTYT> lament: maybe it's simply that C/C++/Java communities are larger
17:13:43 <dmwit> dbpatterson: 'can't find source for Graphics.UI.WXeDraw in ["src"]'
17:13:59 <dbpatterson> dmwit: oh hmm, I didn't get that error... well, thanks for trying anyway...
17:14:36 <dcoutts> @yarr!
17:14:36 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
17:14:42 <dcoutts> $ cabal install --dry-run xmonad
17:14:42 <dcoutts> In order, the following would be installed:
17:14:42 <dcoutts> xmonad-0.7
17:14:49 <dcoutts> not surprising right...
17:14:54 <dcoutts> $ cabal upgrade --dry-run xmonad
17:14:55 <dcoutts> In order, the following would be installed:
17:14:55 <dcoutts> X11-1.4.2
17:14:55 <dcoutts> xmonad-0.7
17:14:58 <dcoutts> yay!
17:15:07 <dcoutts> upgrade does deep upgrade of deps
17:15:17 <dcoutts> (I had X11-1.4.1 installed previously)
17:15:26 <dmwit> Sweet!
17:15:37 * dcoutts records and pushes
17:15:49 <dmwit> But wait, why would "install" not install 1.4.2?
17:16:12 <dcoutts> because xmonad-0.7 will work with X11-1.4.1 which I have already
17:16:35 <dbpatterson> it's lazy
17:16:54 <dcoutts> no, it's constraint solving :-)
17:16:58 <dmwit> ...oh
17:17:13 <dcoutts> install has an explict preference for the installed versions
17:17:34 <dcoutts> upgrade has a preference for the latest, irrespective of install state
17:18:22 <dcoutts> "cabal install foo" means give me the latest version of foo, but for dependencies of foo prefer the ones I've got already
17:18:56 <dcoutts> ie install as little as possible while still giving me the latest version of the package I asked for
17:19:31 <tieTYT> mysql is so shitty
17:19:39 <dcoutts> where as "cabal upgrade foo" means give me the latest version of foo and make sure that I'm using the latest version of everything that foo depends on
17:19:42 <tieTYT> it tries to execute subqueries before it checks if columns exist in the outer query
17:19:48 <sjanssen> dcoutts++
17:20:38 <sjanssen> dcoutts: have you given any thought to making cabal-install easier to install?
17:20:55 <Cale> Including it with GHC would help.
17:21:02 <sjanssen> if it required fewer dependencies than xmonad itself, I'd consider making it the recommended install procedure for xmonad
17:21:24 <dcoutts> sjanssen: including it with a haskell platform release would obviously help
17:21:44 <dcoutts> sjanssen: otherwise we can make a release (not on hackage) that bundles the deps
17:21:47 <sjanssen> Cale, dcoutts: is that such a good idea?  Seems like cabal-install is moving faster than GHC lately
17:21:58 <dcoutts> sjanssen: sure not with ghc itself
17:22:10 <dcoutts> the hackage release will have to be ordinary and dep on the things it deps on
17:22:18 <Cale> Well, you could use the version provided with GHC to update itself, couldn't you?
17:22:19 <dcoutts> but we can easily make a separate all-included tarball
17:22:31 <bd_> The thing I don't like about things like cabal-install is they don't integrate with the distro package manager at all... it'd be much nicer to produce $distropackage out of haskell packages (although cabal-install would be nice if you don't have root)
17:22:56 <dcoutts> Cale: yes but ghc releases are getting smaller not bigger, a platform release is the right place (along with other haskell tools, alex, happy, haddock all the other common libs)
17:23:00 <dons> hey guys, here's a draft of the followup to the haskell performance post of a couple of weeks ago. comments welcome (don't post it anywhere yet)
17:23:00 <sjanssen> bd_: the problem with your statement is '$distropackage'
17:23:03 <dons> http://galois.com/~dons/tmp/fast-fusion.txt
17:23:20 <dons> ddarius: same idea as last time, but this time working at a higher level of abstraction to get the same raw performance
17:23:33 <dons> any insights that would help strengthen the article would be great.
17:23:33 <bd_> sjanssen: Indeed. Still, cabal-install has no way of pulling in non-haskell dependencies, and doesn't integrate with the distro's updates system
17:23:37 <dcoutts> bd_: cabal was designed wit that in mind, we have tools to generate distro packages for gentoo, debian and fedora
17:24:07 <dcoutts> bd_: as for cabal-install, yes, integration with distro package managers is hard
17:24:15 <bd_> dcoutts: But no automatic builders - people should be able to deb http://cabal.haskell.org/debian sid main and have it Just Work :/
17:24:30 <sjanssen> bd_: show us the code! :P
17:24:43 <dcoutts> bd_: that's really the responsibility of the distro packages who makes those tools
17:24:50 <bd_> hah :)
17:25:04 <bd_> I've been meaning to make something like that, but I've (still!) not gotten around to it :)
17:25:11 <bd_> so I probably shouldn't complain
17:25:28 <dcoutts> bd_: I think they're mostly happy with using the tools themselves and doing some QA and putting the packages into the main distro, rather than having an archive of all hackage packages with no QA
17:25:36 <sjanssen> dcoutts: oh, I suppose the other issue with cabal-install/xmonad is the ~/.cabal/bin default
17:26:05 <bd_> dcoutts: Well, I'm not advocating feeding the results into $distro directly. Rather, add a seperate repository for people who want the bleeding edge
17:26:07 <dcoutts> bd_: if there is enough central QA and enough work on the translators then such things might become sensible
17:26:30 <dcoutts> bd_: it requires complete automation which is a lot harder than just being mostly automated
17:26:39 <bd_> mmm
17:26:40 <dcoutts> bd_: I agree it's desirable
17:26:58 <dcoutts> sjanssen: what's the problem with that?
17:27:23 <dcoutts> sjanssen: oh you mean the fact that ~/.cabal/bin is probably not on the path? that's something we need to address.
17:27:30 <sjanssen> dcoutts: it isn't typically in the user's $PATH, meaning extra documentation work
17:28:06 <dcoutts> sjanssen: some people think we should not be putting things directly into ~/bin/ automatically and "without asking"
17:28:17 <sjanssen> dcoutts: this seems reasonable to me
17:28:17 <dcoutts> though "cabal install foo" seems like asking to me :-)
17:28:42 <sjanssen> oh, I didn't read your "not", in which case I support your view :)
17:29:01 <dcoutts> sjanssen: another idea is to put stuff in ~/.cabal/bin but symlink things into ~/bin/ so long as it doesn't overwrite existing stuff in ~/bin/
17:29:37 <sjanssen> how likely is it that overwriting something in ~/bin will cause a problem?
17:30:03 <dcoutts> sjanssen: to be honest I think it's more of a psychological problem :-)
17:30:27 <dcoutts> that some users thing ~/bin/ is to be personally managed by them and nothing else should "automatically fiddle" with it
17:30:36 <sjanssen> dcoutts: I bet if you just changed the default without saying so, nobody would complain :)
17:30:44 <dcoutts> sjanssen: so we need to work out some sensible behaviour
17:30:58 <dcoutts> sjanssen: I know a couple people who would ;-)
17:31:17 <dcoutts> sjanssen: I think probably the thing to do is have it a config option that the paranoid can turn off
17:31:31 <dcoutts> sjanssen: but have the default be that things end up in your $PATH
17:31:54 <dcoutts> sjanssen: if you want to work out a proposal and send us patches... :-)
17:32:10 <sjanssen> dcoutts: sure, I'll take a look at that
17:32:17 <dcoutts> great!
17:32:59 <dcoutts> sjanssen: I particularly like the idea of symlinking into ~/bin/ and put versioned binaries in ~/.cabal/bin
17:33:04 <dolio> dons: Looks fine to me, although I still think it's somewhat confusing that the arrays library is currently more for convenient stream fusion programming than use as arrays. :)
17:33:18 <dcoutts> sjanssen: you know we can append version numbers to installed programs now
17:33:28 <dons> mm. yes, dolio
17:33:45 <dons> it's my todo: finish the immutable arrays "direct' implementation
17:33:49 <dons> stick it on hackage
17:34:16 <dolio> Is stream fusion for lists still slated for 6.10, by the way?
17:34:49 <dons> not in the base lib. i'll just release an updated version of the stream-lists library on hackage
17:35:10 <dolio> Are there still issues with list comprehensions?
17:36:00 <dons> haven't tried them recently. we need to rerun all the benchmarks to know whats changed between 6.6 and 6.10
17:36:13 <dons> probably they work now?
17:36:30 <dons> dcoutts: do you rememeber if we needed anything   other than SAT ?
17:36:34 <dolio> Heh.
17:36:56 <dons> concatMap sucks anyway
17:36:58 <dons> who needs it!?
17:36:59 <dons> not me.
17:37:06 <dcoutts> heh, all nested loops
17:37:22 <dcoutts> dons: I'm not sure, I can't think of anything beyond SAT
17:37:27 <sjanssen> dons-- you can have the karma back when you apologize for beating on (>>=) in the list monad :)
17:37:46 <dons> oh, where'd i do that, sjanssen ?
17:37:49 <MyCatVerbs> dons: eh? concatMap is great. How else do you feel like implementing >>= ?
17:37:55 <dons> oh i see.
17:37:56 <dcoutts> dons: concatMap = >>=
17:37:58 <dons> :)
17:38:01 <dons> stupid list moand
17:38:10 <dons> optimise itself, it should.
17:38:25 <dons> likes stream fusion, yoda does.
17:38:40 <dons> strong with the rewrite rules, this one is.
17:38:49 <sjanssen> dcoutts: has ~/.cabal/bin vs. ~/bin been discussed on the mailing list?
17:38:54 <dcoutts> interestingly the list monad doesn't get the same build/foldr treatment afaik, just list comprehensions
17:39:02 <dcoutts> sjanssen: hmm, I'm not sure actually
17:39:13 <dcoutts> sjanssen: I think it may have just been irc and hackathons
17:39:20 <sjanssen> dcoutts: I'm just curious where the opposition was voiced
17:39:30 <sjanssen> dcoutts: so maybe a mailing list discussion is the best place to start
17:39:35 <dcoutts> sjanssen: sure
17:40:15 <dons> dcoutts: i want to write a paper about emprically studying the effectiveness of different test generation strategies
17:40:27 <dons> which generator strategy is best for which kind of code
17:40:38 <dons> and how to unify all generators under a single property language
17:41:08 <dcoutts> dons: I think ndm would like to write about that too, and perhaps Colin
17:41:11 <dons> use hpc, plus defects found, to test how easy it is to do good testing of say, a parser, a data structure library, and some io code
17:41:26 <dcoutts> dons: I'd not mind either, especially about strictness testing which is under appreciated
17:49:34 * dcoutts pushes a patch to enable the new dep resolver
17:49:56 <ivanm> \o/
17:49:59 <ivanm> it works now?
17:50:20 <dcoutts> I hope so
17:50:22 <dcoutts> try it!
17:50:27 <ivanm> heh
17:50:50 <dcoutts> indeed, I invite all cabal-install testers to grab the latest darcs version and try out the new dep resolver
17:50:54 <dcoutts> send in the bug reports
17:52:26 <vincenz> dcoutts: what did you fix?
17:52:47 <dcoutts> vincenz: it's a completely new dep resolver, it produces valid install plans
17:53:03 <vincenz> dcoutts: Ah, I see. Congrats (:
17:53:09 <dcoutts> as opposed to the previous one which in all non-trivial cases produces invalid ones
17:53:12 <ivanm> you mean previously your dep resolver produces _wrong_ install plans?
17:53:15 <ivanm> how could yoU!
17:53:22 <dcoutts> ivanm: exactly
17:53:26 <vincenz> ivanm: you wouldd think the type system catches that!
17:53:43 <ivanm> vincenz: exactly!
17:53:43 <vincenz> unsafeInvalidDep
17:53:53 <ivanm> type system = typing from keyboard in this case? :p
17:54:12 <dcoutts> ivanm: I didn't write the previous one, but I did write the plan validator that checks if plans are legit or not
17:54:49 <ivanm> excuses excuses :p
17:54:50 <dcoutts> plan validity is a fairly complex check, I don't think it can be encoded into the Haskell type system
17:55:06 <ivanm> what? you mean the haskell type system isn't turing complete? :o
17:55:14 <dcoutts> thankfully not :-)
17:55:31 <dcoutts> gwern: new cabal-install for you to play with, bug reports welcome
17:55:54 <dcoutts> gwern: new dep resolution algorithm which should solve the diamond dep problem
17:56:53 <gwern> interesting!
17:56:54 * gwern goes and does it
17:57:12 <gwern> dcoutts: so to compile yi, borked under the old cabal, what would I need to do?
17:57:22 <ivanm> dcoutts: what did you do to poor gwern so that he'll do whatever you tell him to? :p
17:57:36 <dcoutts> gwern: cabal install yi (--dry-run -v)
17:57:37 <ivanm> gwern: unbork yi? :p
17:58:24 <gwern> dcoutts: hm. does "cabal install" now work out of the local dir?
17:58:38 <dcoutts> gwern: always has done afaik
17:58:54 <dcoutts> where always == last 5 months ;-)
17:59:05 * gwern wonders what the download-from-hackage cabal-install is then
17:59:22 <dcoutts> gwern: old stuff to be avoided
17:59:27 <dobblego> @type editDistance
17:59:29 <lambdabot> Not in scope: `editDistance'
18:00:46 <dcoutts> gwern: you need the darcs version of cabal-install
18:08:32 <gwern> dcoutts: so. um, is darcs cabal-install not supposed to work with darcs cabal?
18:09:04 * gwern just instaleld cabal 1.5.2 but cabal-install says Cabal >=1.3.11 && <1.5
18:09:18 <dbueno> gwern: it needs cabal-1.4
18:09:42 <dcoutts> gwern: http://darcs.haskell.org/cabal-branches/cabal-1.4/
18:09:43 <lambdabot> Title: Index of /cabal-branches/cabal-1.4
18:10:36 * gwern removes the conditional. seems to compile
18:11:40 <dcoutts> gwern: it might do at the moment, cabal-1.5 will diverge eventually
18:11:49 <dcoutts> especially after the actual Cabal-1.4 release
18:14:20 <malebria> How is duck typing related to type inference?
18:14:38 <malebria> I'm reading about duck typing in wikipedia and it seems to do kind of the same thing.
18:14:59 <TomMD> Yay, dual core laptop ordered so I can now play with the wonder that is `par` (and soon DPH)!
18:15:51 <TomMD> *and see actual performance differences, that is.
18:15:52 * gwern curses how haddock cannot be installed with profiling, it seems
18:19:33 <Gwern-away> oh, that is just great. so profiled darcs haddock fails with link errors with directory; reinstall directory with profiling, and now cabal fails!<interactive>: /home/gwern/bin/lib/Cabal-1.5.2/ghc-6.8.2/HSCabal-1.5.2.o: unknown symbol `directoryzm1zi0zi0zi0_SystemziDirectory_lvl9_closure'
18:19:38 <Gwern-away> ghc-6.8.2: unable to load package `Cabal-1.5.2'
18:20:52 * Gwern-away unregisters: Cabal-1.5.2 Cabal-1.5.1 Cabal-1.3.11 and Cabal-1.2.3.0 before "runhaskell Setup clean" finally works again
18:40:46 <gwern> note to self: never reinstall directory *after* reinstalling cabal
18:41:56 <ivanm> heh
18:49:15 <gwern> hm. one needs alex to build alex?
18:49:43 <geezusfreeek> gwern: i didn't...
18:54:51 <SamB_XP> probably the tarballs have that part done already
18:55:50 <gwern> fortunately, I could install a .deb of alex, which solves my bootstrapping problem
18:56:06 <geezusfreeek> ah darcs version
19:00:45 <mar77a> :t many
19:00:49 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
19:01:02 <vixey> @instances Alternative
19:01:02 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
19:01:05 <vixey> :(
19:01:09 <vixey> what is Alternative
19:03:25 <ivanm> @hoogle many
19:03:27 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
19:03:27 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
19:03:27 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
19:03:32 <ivanm> @doc Control.Applicative
19:03:33 <lambdabot> Control.Applicative not available
19:03:59 <mar77a> what does many do
19:04:07 <vixey> @src many
19:04:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:04:17 <vixey> @hoogle Alternative
19:04:17 <lambdabot> Control.Applicative.Alternative :: class Applicative f => Alternative f
19:04:22 <rms> vixey: have you read your SICP today?
19:04:29 <vixey> @instances-alternative Control.Applicative.Alternative Alternative
19:04:29 <lambdabot> Unknown command, try @list
19:04:36 <vixey> :/
19:04:42 <vixey> @instances-importing Control.Applicative.Alternative Alternative
19:04:43 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
19:04:49 <mightybyte> Can haskell/ghc/hugs/etc address more than 4 gigs of RAM?
19:05:16 <ivanm> mightybyte: you might have to tell the RTS that, but I don't see why not...
19:05:28 <ivanm> then again, that'll depend on the data type used to manage memory...
19:05:33 <Twey> Should do if the OS supports it...
19:05:37 <monochrom> I have an friend trying out haskell and say: "it is very easy to understand the compiler errors, everything is an almost instant fix".
19:05:42 <mightybyte> ivanm: I've had some very strange behavior with some tests.
19:05:42 <ivanm> probably should ask on #ghc though...
19:05:44 <mar77a> dons!
19:05:47 <ivanm> monochrom: heh
19:05:51 <mightybyte> Twey: mine does
19:05:56 <hpaste>  mightybyte pasted "Playing with memory" at http://hpaste.org/8057
19:05:57 <Twey> monochrom: Well, compared to C++ compiler errors... :-P
19:06:12 <monochrom> Ha
19:06:17 <vixey> @src Alternative
19:06:17 <lambdabot> class Applicative f => Alternative f where
19:06:17 <lambdabot> 	empty :: f a
19:06:17 <lambdabot> 	(<|>) :: f a -> f a -> f a
19:06:17 <vixey> @instances-importing Control.Applicative Applicative
19:06:18 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
19:06:29 <mightybyte> ivanm: I can't get that code to address more than a little less than 4 gigs in one array.
19:06:40 * ivanm loves it when compilers spit out error messages, yet google can't find any other instance of that error message :s
19:06:57 <Twey> ''undefined reference to `vtable for Tmp''
19:07:03 <ivanm> mightybyte: #ghc is probably a better place to ask
19:07:08 <heatsink> mightybyte: Sounds like a ghc bug.
19:07:13 <vixey> > Nothing <|> Just 3
19:07:14 <lambdabot>  Just 3
19:07:18 <vixey> > Just 1 <|> Just 3
19:07:19 <lambdabot>  Just 1
19:07:25 <mightybyte> Well, that middle instance of size that is commented out definitely looks like a ghc bug.
19:07:47 <mightybyte> I don't know if the ~4gig restriction is or not.
19:07:55 <mightybyte> Although I would hope not.
19:08:27 <dons> mar77a: ?
19:08:32 <mightybyte> Since I'm currently kind of interested in using a 6gig array.
19:08:45 <Twey> Owch
19:08:57 <Twey> Got a supercomputer handy?  :-)
19:09:01 <mightybyte> Yeah
19:09:13 <mightybyte> I've got 8 gigs here
19:09:23 <mightybyte> And 8 cores to go with it.
19:10:40 <Twey> Nice <3
19:11:35 <bos> mightybyte: ghc will have no problem with large memory if you're using a 64-bit OS
19:11:56 <mightybyte> bos: I'm using 64-bit linux.
19:12:10 <bos> mightybyte: where did you get ghc from?
19:12:29 <mightybyte> I think it's the ubuntu package.
19:12:37 <bos> ok.
19:12:50 <mightybyte> checking...
19:12:55 <dons> you should have no problem allocating ridiculous amounts on 64 bit.
19:13:02 <bos> mightybyte: what kind of array are you using?
19:13:16 <mightybyte> http://hpaste.org/8057
19:13:29 <mightybyte> I've tried StorableArray and IOUArray
19:13:43 <mightybyte> The interesting thing is that StorableArray is much faster than IOUArray
19:13:54 <SamB_XP> yeah, you won't run into the address-space fragmentation issues that we'd have on 32-bit, since you have WAAAAY more address space than memory
19:13:58 <dons> ghc compiled in 32 bit mode?
19:14:10 <SamB_XP> you could fit your entire memory in the address space many times over, after all ;-)
19:14:13 <mightybyte> And without -O2 it's much much slower.
19:14:22 <mightybyte> dons: Not sure, how do I find out.
19:14:32 <dons> mightybyte: they should be identical given -O2 fwiw.
19:14:40 <dons> well, almost identical
19:14:41 <bos> mightybyte: print (sizeOf (undefined :: Int))
19:14:49 <bd_> operative phrase being 'should be'
19:14:53 <dons> > sizeOf (undefined :: Int)
19:14:54 <lambdabot>   Not in scope: `sizeOf'
19:14:59 <dons> > Foreign.sizeOf (undefined :: Int)
19:15:00 <lambdabot>   Not in scope: `Foreign.sizeOf'
19:15:01 <bd_> FFI
19:15:03 <bd_> > maxBound :: Int
19:15:04 <lambdabot>  2147483647
19:15:08 <mightybyte> dons: Let me do a test on my machine
19:15:11 <dons> ?hoogle sizeOf
19:15:12 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
19:15:14 <bd_> ^^^ 32 bit
19:15:21 <bos> Prelude> maxBound::Int
19:15:21 <bos> 9223372036854775807
19:15:22 <dons> > Foreign.Storable.sizeOf (undefined :: Int64)
19:15:23 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
19:15:31 <bd_> > if maxBound `shiftR` 32 == 0 then 32 else 64
19:15:31 <dons> oh right-o lambdabot . i get it.
19:15:32 <lambdabot>  Add a type signature
19:15:37 <bd_> > if maxBound :: Int `shiftR` 32 == 0 then 32 else 64
19:15:37 <lambdabot>  Parse error at "`shif..." (column 20)
19:15:46 <bd_> > if (maxBound :: Int ) `shiftR` 32 == 0 then 32 else 64
19:15:47 <lambdabot>  32
19:16:05 <dons> mightybyte: are those byte arrays?
19:16:13 <dons> i wonder if you'll have an easier time using strict bytestrings here.
19:16:32 <dons> the byte array of gentlemen.
19:17:07 <mightybyte> dons: Well, I'd like to use arrays of whatever my word size is.
19:17:18 <mightybyte> dons: I was just testing with Int8s for ease of memory calculation
19:17:30 <SamB_XP> hmm.
19:17:37 <bos> does ghc's storage manager have a large object manager?
19:17:38 <SamB_XP> CUIntPtr?
19:17:56 <bd_> > 1 + (length $ unfoldr (\n -> guard (n /= 0) >> return ((), n `shiftR` 1)) (maxBound::Int))
19:17:57 <dons> MBlock.* bos. big things are handled specially
19:17:58 <lambdabot>  32
19:17:59 <bd_> > 1 + (length $ unfoldr (\n -> guard (n /= 0) >> return ((), n `shiftR` 1)) (maxBound::Int64))
19:18:01 <lambdabot>  64
19:18:16 <mightybyte> dons: StorableArray takes approximately 8.669s to initialize on my machine.
19:18:25 <bos> dons: yeah, that's what i'd have expected.
19:18:28 <mightybyte> ...when compiled with -O2
19:18:41 <mightybyte> dons: IOUArray takes 35.126s
19:18:49 <dons> mightybyte:oh, initialisation is another story.
19:18:59 <dons> you can fill both with a memfill if you need to
19:19:13 <mightybyte> Oh, ok
19:19:23 <dons> memset.
19:19:25 <bd_> why is the performance so different?
19:19:42 <bos> memset is optimised.
19:19:59 <bd_> surely IOUArray can be specialised to use the same method that StorableArray does
19:20:04 <mightybyte> bd_: All I did was change line 27 from buildTable2 to buildTable1
19:20:16 <bos> bd_: "can be" != "is"
19:20:20 <dons>     newArray (l,u) init = do
19:20:20 <dons>         fp <- mallocForeignPtrArray size
19:20:20 <dons>         withForeignPtr fp $ \a ->
19:20:20 <dons>             sequence_ [pokeElemOff a i init | i <- [0..size-1]]
19:20:20 <dons>         return (StorableArray l u size fp)
19:20:24 <dons> for StorableArray
19:20:46 <bd_> and that's faster than IOUArray? oO
19:21:09 * bd_ digs for the IOUarray impl
19:21:38 <mightybyte> dons: So how do I tell if my ghc is built for 64bit?
19:21:46 <dons> for IOArray
19:21:47 <dons> newIOArray lu init  = stToIO $ do {marr <- newSTArray lu init; return (IOArray marr)}
19:22:10 <dons> not the right one.
19:22:21 <bos> mightybyte: maxBound::Int
19:22:39 <mightybyte> Prelude> maxBound::Int
19:22:39 <mightybyte> 9223372036854775807
19:22:46 <bos> ok, then you're good.
19:22:56 <mightybyte> But I'm not good. :)
19:23:06 <bd_> @hoogle IOUArray
19:23:06 <lambdabot> Data.Array.IO.IOUArray :: data IOUArray i e
19:23:07 <lambdabot> Data.Array.IO.castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
19:23:17 <dons> ah, and the IOUArray one uses the STUArray fill code default
19:23:18 <dons>     newArray (l,u) init = do
19:23:19 <dons>         let n = safeRangeSize (l,u)
19:23:19 <dons>         marr <- unsafeNewArray_ (l,u)
19:23:19 <dons>         sequence_ [unsafeWrite marr i init | i <- [0 .. n - 1]]
19:23:51 <dons> so perhaps it doesn't specialise?
19:23:55 <bos> that looks reasonable.
19:24:13 <bos> that would be interesting. i could get more bloom filter performance for free :-)
19:24:26 <dmwit> > 2^64 :: Integer
19:24:29 <lambdabot>  18446744073709551616
19:24:32 <dons> custom filling functions have been useful for other things in the past.
19:24:33 <dmwit> oh
19:24:34 <dons> so i'd not be surprised.
19:25:00 <bd_> dons: at the very least IOUArrays should outperform generic things like StorableArrays - or, failing that, be implemented in terms of them :)
19:25:32 <dons> i get marginally faster code with StorableArray filling too
19:25:42 <bos> how utterly odd.
19:25:48 <sjanssen> does StorableArray use memset?
19:25:53 <dons> nope. just haskell
19:26:06 <mightybyte> But when I use that middle size for the array, I get this:
19:26:06 <mightybyte> ("Building table...",4294907296)
19:26:06 <mightybyte> Main: internal error: getMBlock: mmap: Invalid argument
19:26:06 <mightybyte>     (GHC version 6.8.2 for x86_64_unknown_linux)
19:26:06 <mightybyte>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
19:26:06 <mightybyte> Aborted
19:26:08 <lambdabot> Title: ReportABug - GHC - Trac
19:26:15 <dons> for 2^39, 1.099s vs 1.247s
19:26:18 <tieTYT> fold diagrams are down! :(
19:26:28 <dons> 2^29
19:26:37 <bd_> hmmm
19:26:54 <bd_> can't all of the IOUArray types simply be zeroed with a quick memset anyway?
19:27:02 <bos> i wonder if any distros ship with profiling builds of the core and extralibs libraries.
19:27:21 <dons> ah, inlining!
19:27:22 <sjanssen> Debian does
19:27:37 <dons> StorableArray's newArray is entirely inlined and specialised
19:27:37 <bd_> libghc6-mtl-prof - Haskell monad transformer library for GHC; profiling libraries
19:27:40 <bd_> :)
19:27:42 <tieTYT> how's this: myConcat xs = foldr (++) [] xs
19:27:47 <bos> sjanssen: do you mean plain profiling, or SCC-annotated?
19:27:52 <dons> while the other one stays as      case Data.Array.Base.$wa10
19:27:52 <dons>            @ RealWorld
19:27:52 <dons>            @ Int
19:27:53 <dons> boo
19:27:58 <sjanssen> bos: plain profiling
19:27:59 * dons patches things.
19:28:15 <bos> sjanssen: ah. that's common enough, i think.
19:28:24 <bos> since you can't profile at all without it.
19:28:39 <mightybyte> So since I've got 64bit GHC, any other ideas why I can't get more memory?
19:28:40 <tieTYT> i know foldr is often described as replacing the : in a list with the function.  That's easy to remember.  Is there an easy way to remember foldl?
19:29:16 <dobblego> tieTYT, http://blog.tmorris.net/scalalistfoldleft-for-java-programmers/
19:29:17 <lambdabot> Title: Œª Tony&#8217;s blog Œª ª Blog Archive ª scala.List.foldLeft for Java programmer ...
19:29:22 <bos> mightybyte: beats me :-(
19:29:48 <dmwit> tieTYT: That looks like a good myConcat definition.  So good that...
19:29:49 <dons> mightybyte: ask SimonM / bug report if you can't allocate say, a strict bytestrings bigger than 2^32
19:29:51 <dmwit> ?src concat
19:29:51 <lambdabot> concat = foldr (++) []
19:29:55 <bos> mightybyte: what happens if you try to create a big bytestring?
19:30:01 <dmwit> tieTYT: ...that the Prelude agrees with you. =)
19:30:07 <tieTYT> noice
19:30:17 <mightybyte> bos: haven't tried that.
19:30:25 <dmwit> As for foldr/foldl, let me see if I can find Cale's diagrams...
19:30:31 <mightybyte> bos: Let me code that up really quick.
19:31:13 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
19:31:32 <dmwit> It's  taking a long time to load.
19:31:39 <dmwit> http://www.haskell.org/haskellwiki/Fold # just two of the diagrams are here
19:31:40 <lambdabot> Title: Fold - HaskellWiki
19:31:50 <tieTYT> yeah diagrams are good
19:31:58 <tieTYT> but the "replace : with function" is easier to remember
19:32:10 <Cale> hmm
19:32:21 <Cale> might be the fact that I have this torrent running :)
19:32:34 <dmwit> Oh, are you hosting that yourself?
19:32:38 <dmwit> yi.org
19:32:39 <Cale> yeah
19:32:42 <Cale> cale.yi.org
19:32:44 * dmwit slaps himself
19:32:56 <Cale> yi.org is just a dynamic dns provider
19:33:00 <dmwit> yi.org <--> dyndns.org
19:33:01 <dmwit> yeah
19:33:17 <dmwit> Where (<-->) means "is similar to". ;-)
19:34:04 <mightybyte> bos: Are bytestrings mutable?
19:34:17 <bd_> mightybyte: bytestrings are immutable
19:34:34 <mightybyte> Oh, that won't work for me.
19:34:42 <bd_> mightybyte: what do you plan to do with them?
19:34:51 <mightybyte> My application pretty much requires mutable data structures.
19:34:54 * dons specialises too hard
19:34:55 <dons> ghc-6.8.2: panic! (the 'impossible' happened) (GHC version 6.8.2 for x86_64-unknown-openbsd):
19:34:57 * chessguy wonders if mightybytestrings would be mutable or immutable
19:35:03 <mightybyte> lol
19:35:24 <dons> mightybyte: you can jump into them and mutate them. but STUArray Int e are probably more fun for now
19:35:51 <mightybyte> bd_: Well, given my need for > 4gig bytestrings, it shouldn't be too hard to understand why I wouldn't want to be copying them all the time.
19:36:05 <mightybyte> dons: Ok
19:36:20 <bd_> mightybyte: ... ah :)
19:36:34 <mightybyte> dons: But then I'm back to the original 4gig problem
19:36:45 <bd_> hmm,the boehm GC had an efficient(?) mutable string data structure based on immutable strings
19:36:54 <bd_> might be interesting to try porting it to haskell
19:37:19 <dons> mightybyte: let me try a test program.
19:37:25 <mightybyte> dons: Ok
19:43:30 <hpaste>  dons pasted "example?" at http://hpaste.org/8058
19:43:38 <dons> mightybyte: does something like that work?
19:43:45 <dons> i don't have > 2G atm so can't try
19:43:48 <mightybyte> dons: Let me give it a try.
19:44:03 <dons> if it doesn't, file a bug, and we'll see what Simon "The Storage Manager" Marlow says
19:44:54 <mightybyte> dons: Segmentation fault
19:45:04 <mightybyte> dons: Ok
19:45:51 <dons> ?bug
19:45:52 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:46:27 <mightybyte> Should I submit a separate one for the weird getMBlock error?
19:52:38 <hpaste>  dons pasted "bytestrings?" at http://hpaste.org/8059
19:52:45 <dons> mightybyte: how about that ^
19:52:49 <gwern> @pl foo x = windows $ copyWindow x (currentTag s)
19:52:49 <lambdabot> foo = windows . flip copyWindow (currentTag s)
19:56:47 <mightybyte> dons: One moment.
19:57:30 <mightybyte> dons: Still segmentation fault.
19:58:26 * SamB hunts down old screen sessions to reclaim RAM
19:59:03 <mightybyte> Here's my ticket: http://hackage.haskell.org/trac/ghc/ticket/2332
19:59:04 <lambdabot> Title: #2332 (Can't allocate 4 gigs of RAM) - GHC - Trac
19:59:36 <dons> ok. we'll see what simonm says
20:00:11 <mightybyte> I'll be anxious to see.
20:00:51 <mightybyte> Well, I'm out.  Thanks for the help.
20:03:17 <dmwit> > xor True False -- what's the function for this?
20:03:18 <lambdabot>   add an instance declaration for (Bits Bool)
20:03:18 <lambdabot>     In the expression: xor True...
20:05:11 <mar77a> dons i was reading your hitchhakunamatata tutorial and i found the "many" function (?). was wondering what it did
20:06:32 <roconnor> Ah, the LISP 1.5 Programmer's manual
20:06:53 <ykrs> hitchhakunamatata?
20:07:15 <mar77a> "hitchikers" i think
20:08:52 <dons> hmm, i don't think that was me.
20:09:00 <dons> but 'many' is probably from parsec
20:09:02 <dons> ?hoogle many
20:09:03 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
20:09:03 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
20:09:03 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
20:09:07 <dons> or applicaitve
20:09:27 <gubagem> say i want something like
20:09:40 <gubagem> > [String,Bool,Integer]
20:09:41 <lambdabot>   Not in scope: data constructor `Integer'
20:10:08 <mar77a> "parseInput =  do dirs <- many dirAndSize"
20:10:21 <dmwit> gubagem: (String, Bool, Integer)
20:10:33 <dmwit> gubagem: Also, String, Bool, and Integer are types, not values.
20:10:43 <cjs> Sometimes I'd give a lot for some sort of Ruby-style alternate string constants.
20:10:47 <gubagem> can I make a list of them ?
20:10:53 <cjs> Testing stuff that escapes double quotes is a bit of a pain.
20:10:59 <dmwit> gubagem: You'll have to make your own union type.
20:11:16 <araujo> glguy, if you decide to write a ruby interpreter in haskell , let me know
20:11:17 <araujo> :-P
20:11:34 <glguy> wasn't planning on it ;)
20:11:40 <dmwit> gubagem: But you should consider just having three lists, instead.
20:11:44 <gubagem> can I pass them into read (thingie)::x where x=head [String,Bool,Int]
20:12:04 <dobblego> [String,Bool,Int] -- WTF?
20:12:11 <araujo> glguy, well, or any conspiracy haskell->ruby related
20:12:14 <araujo> :-]
20:12:21 <dmwit> gubagem: String, Bool, and Int are types, not values!  You can't make a list out of them.
20:12:22 <gubagem> i want to parse different input strings
20:12:26 <gubagem> :-(
20:12:31 <dmwit> You can do that.
20:12:33 <dmwit> No problem.
20:12:41 <mar77a> dons!
20:12:44 <dmwit> Create a tagged union type, and use reads.
20:12:46 <dmwit> :t reads
20:12:49 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:13:30 <dmwit> > (reads "True", reads "True") :: ([(Bool, String)], [(Int, String)])
20:13:31 <lambdabot>  ([(True,"")],[])
20:13:50 <dmwit> Or even better, use Parsec. ;-)
20:17:07 <dmwit> > scaryPrint $ map (map (\x -> if x then 'o' else ' ')) sierpinski
20:17:08 <lambdabot> o
20:17:08 <lambdabot> oo
20:17:08 <lambdabot> o o
20:17:08 <lambdabot> oooo
20:17:08 <lambdabot> o   o
20:17:10 <lambdabot> [6 @more lines]
20:17:13 <dmwit> ?more
20:17:13 <lambdabot> oo  oo
20:17:14 <lambdabot> o o o o
20:17:16 <lambdabot> oooooooo
20:17:18 <lambdabot> o       o
20:17:20 <lambdabot> oo      oo
20:17:21 <dmwit> t-hee!
20:17:22 <lambdabot> o o     o...
20:25:07 <roconnor> @type scaryPrint
20:25:08 <lambdabot> [[Char]] -> Expr
20:25:26 <roconnor> @type sierpinski
20:25:27 <lambdabot> [[Bool]]
20:30:37 <dmwit> roconnor: nextSierpinskiRow = box . ap (zipWith xor') tail where box xs = True : xs ++ [True]; xor' a b = (not a && b) || (a && not b)
20:31:43 <roconnor> dmwit: don't we just have a cellular automonton comonad built into lambdabot?
20:31:48 <dmwit> > let box = True : xs ++ [True]; nextSierpinskiRow = box . ap (zipWith (.^.)) tail in nextSierpinskiRow [True]
20:31:49 <lambdabot>   Not in scope: `xs'
20:31:52 <dmwit> Heh, we ought to.
20:32:02 <dmwit> > let box xs = True : xs ++ [True]; nextSierpinskiRow = box . ap (zipWith (.^.)) tail in nextSierpinskiRow [True]
20:32:03 <roconnor> so we just give it a Word256 and that is that
20:32:03 <lambdabot>  [True,True]
20:32:11 <dmwit> Okay, I'm done spamming now.
20:32:28 <conal> xor' = (/=)
20:33:00 <dmwit> aha!
20:33:04 <dmwit> Very nice. =)
20:33:08 <conal> :)
20:33:32 <roconnor> not a && b = a <= b
20:33:49 <conal> roconnor: well, that one is pretty arbitrary.
20:33:59 <roconnor> conal: how so?
20:34:07 <roconnor> oh the ordering on bools
20:34:13 <conal> roconnor: yeah
20:34:21 <roconnor> It'd be cool if it were reversed
20:34:32 <roconnor> then a <= b would mean b implies a
20:34:38 <conal> oh!
20:34:49 <roconnor> alas
20:34:52 <roconnor> it is not the case
20:35:11 <dmwit> You just need (=>) = flip (>=). ;-)
20:35:31 <roconnor> mmm
20:38:34 <gubagem> @hoohle fromJust
20:38:35 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
20:38:45 <dmwit> Danger!
20:38:54 <dmwit> :t fromMaybe -- less dangerous
20:38:56 <lambdabot> forall a. a -> Maybe a -> a
20:38:59 <gubagem> how so :(
20:39:04 <gubagem> whats the difference
20:39:05 <dobblego> > fromMaybe Nothing
20:39:06 <dmwit> > fromJust Nothing :: Int
20:39:06 <lambdabot>  Add a type signature
20:39:07 <lambdabot>  Exception: Maybe.fromJust: Nothing
20:39:10 <dobblego> > fromJust Nothing
20:39:11 <lambdabot>  Exception: Maybe.fromJust: Nothing
20:39:12 <cjs> frommaybe takes a default to return.
20:39:17 <dmwit> > fromMaybe 0 Nothing :: Int
20:39:18 <lambdabot>  0
20:39:22 <cjs> fromJust has the default (crash!) built in. :-)
20:39:23 <dmwit> > fromMaybe 0 (Maybe 3) :: Int
20:39:24 <lambdabot>   Not in scope: data constructor `Maybe'
20:39:32 <dmwit> > fromMaybe 0 (Just 3) :: Int
20:39:33 <lambdabot>  3
20:39:40 <gubagem> ill be dangerous, its in a branch where i know the result is not Nothing
20:39:42 <cjs> > fromJust Nothing
20:39:43 <lambdabot>  Exception: Maybe.fromJust: Nothing
20:39:56 <mxc> since when does hoohle = hoogle
20:39:58 <mxc> ?
20:40:04 <cjs> I do that too; I've always wondered how you type check that.
20:40:04 <dmwit> \bot has spell-correction
20:40:14 <gubagem> @hoo !!
20:40:14 <lambdabot> Maybe you meant: hoogle hoogle+ show todo yow
20:40:15 <cjs> @botsnack
20:40:15 <lambdabot> :)
20:40:29 <mxc> @botsnack
20:40:29 <lambdabot> :)
20:40:34 <dmwit> ?botsmack
20:40:34 <lambdabot> :)
20:40:44 <mxc> heh heh, well done
20:40:58 <mxc> my favorite is TCSH's spell correction
20:41:08 <mxc> tsch_shell>  bill gates
20:41:09 * Twey snorts.
20:41:13 <dmwit> ?botlneck
20:41:14 <lambdabot> :)
20:41:15 <mxc> kill gates?
20:41:21 <Twey> Hahaha
20:41:32 <mar77a> stupid question time
20:41:33 <mxc> if anyone has tcsh up (at least the version that was in mac osx until 10.2)
20:41:50 <mar77a> why doesn't > 0:1:[]:[] work if it makes sense?
20:42:00 <mxc> :t []:[]
20:42:01 <lambdabot> forall a. [[a]]
20:42:03 <Twey> bill -> kill is a reasonable correction
20:42:09 <mxc> thats your answer mar77a
20:42:18 <mar77a> translate to english
20:42:21 <mxc> > []:[]
20:42:23 <lambdabot>  [[]]
20:42:32 <mxc> mar77a, the type of []:[] is a list of lists
20:42:33 <mar77a> aha
20:42:36 <Twey> mar77a: 0, 1, and [] share no common type
20:42:43 <mxc> so you could do [1]:[2]:[]:[]
20:42:45 <mar77a> ahhhhhhhh
20:42:46 <mxc> > [1]:[2]:[]:[]
20:42:48 <lambdabot>  [[1],[2],[]]
20:42:56 <roconnor> (:[]) -- Grrrrrr
20:43:02 <mxc> twey - yes, but still funny
20:43:05 <mar77a> > :t []:[]:[]
20:43:05 <lambdabot>   parse error on input `:'
20:43:11 <mar77a> :t []:[]:[]
20:43:11 <Twey> mxc: Yes :-P
20:43:12 <dmwit> MONKEY COMBINATOR WILL EAT YOUR CHILDREN
20:43:13 <lambdabot> forall a. [[a]]
20:43:21 <Twey> Hahaha
20:43:34 <Saizan> > (1:2:[]):[]
20:43:34 <Twey> Jill school to go monkey apple combinator!
20:43:35 <lambdabot>  [[1,2]]
20:43:51 <SamB> :t 0:1:[]:[]
20:43:53 <lambdabot> forall a. (Num [a]) => [[a]]
20:44:15 <mar77a> :t (.)
20:44:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:44:19 <dmwit> instance Num a => Num [a] where ... -- ;-)
20:44:21 <Twey> Clever lazy type inference
20:45:13 <dmwit> ... where [(+), (-), (*), div, mod] = map zipWith [(+), (-), (*), div, mod]
20:46:12 <Twey> dmwit: *blink*
20:46:13 <Twey> Impressive
20:47:09 <conal> dmwit: is that legal haskell??
20:47:18 <dmwit> I don't see why not.
20:47:21 <dmwit> Let me try it.
20:47:43 <dmwit> (Though div, mod are not in Num.)
20:47:53 <conal> those overloadings are just are just the sort i do a lot of.
20:48:23 <dmwit> Nope, not valid Haskell. =/
20:48:28 <conal> sigh
20:48:47 <mar77a> where can i see all prelude functions
20:48:58 <dmwit> ?where prelude
20:48:59 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
20:50:38 <mar77a> is there any difference between $ and $!
20:50:46 <mar77a> can't tell from :t
20:51:00 <dmwit> There's a "seq" in $!.
20:51:02 <mxc> isn't $! strict?
20:51:05 <dmwit> ?src ($!)
20:51:06 <lambdabot> f $! x = x `seq` f x
20:51:25 <mar77a> :t seq
20:51:29 <lambdabot> forall a t. a -> t -> t
20:51:34 <mar77a> ehm
20:51:37 <mxc> mar77a - that wont help
20:51:37 <dmwit> seq a b = {- evaluate a -} b
20:51:41 <gubagem> well haskell is looking to lop off 200 lines of a 450 line java program
20:51:41 <dmwit> It's a primitive.
20:52:02 <dmwit> mar77a: It's used to add strictness.
20:52:04 <mxc> mar77a - seq forces the evaluation of the first argument (which might not be fully evaluated because of laziness) and then returns the second
20:52:21 <mar77a> anti-laziness measures?
20:52:27 <mxc> i saw a great title on FP/static type
20:52:28 <mxc> typing
20:52:38 <noecksit> @undo test = do { print "hello" }
20:52:38 <lambdabot> test = print "hello"
20:52:39 <dmwit> mar77a: But you should note that the first argument is only evaluated to weak head normal form... i.e. to the first constructor.
20:52:42 <mxc> it was something like "Functional Programming, B&D, not S&M"
20:55:33 <mxc> dmwit - whats the difference between WHNF  and  HNF? and, its been a long time since bcpierce's class, but HNF = evaluated as much as possible right?
20:55:54 <mxc> HNF = a lambda with only unbound variables?
20:56:12 <koninkje> I'm trying to convince my boss to use Haskell for a compiler project where one of the future goals may be to permit linking as/to Java. I know there're a few java/jvm--haskell projects out there, is there a canonical or most-developed one?
20:57:18 <dmwit> mxc: I have no idea, this is cargo-cult Haskell I'm spewing right now.
20:57:22 * koninkje is trying to convince him away from C++, fwiw
20:57:29 <dmwit> I know the big heads say "seq evaluates to WHNF", but I don't know what it means.
20:57:34 <mxc> dmwit++
20:57:47 <glguy> dmwit: it evaluates the outermost constructor
20:57:48 <mxc> dmwit - well said, well fcking said
20:57:55 <gubagem> whats the lambda form for a two argument function (in haskell)
20:58:01 <dmwit> \x y -> ...
20:58:05 <glguy> or is that the vague version that doesn't make sense?
20:58:11 <dmwit> That's the vague version.
20:58:14 <gubagem> dmwit: k thx
20:58:15 <dmwit> It makes sense.
20:58:33 <dmwit> But what does WHNF mean for lambda's, i.e. what's a constructor in that world?
20:58:43 <dmwit> And what does "weak" mean?
20:58:50 <mxc> so the only difference is that in HNF the type constructor is evaulated?
20:58:54 <dmwit> I assume these would all make sense if I actually took the time to look them up. =P
20:58:56 <koninkje> dmwit: what is the return value of the lambda? the head of that is the "head of the lambda"
20:59:01 <mxc> so WHNF is basically fully evaluated?
20:59:13 <glguy> it's far from fully evaluated
20:59:15 <bos> is there a Language extension that allows use of e.g. MutableByteArray# in an FFI binding?
20:59:24 <dmwit> koninkje: Uh, what?  How can you get the head of a lambda without a value to apply it to?
20:59:27 <bos> MagicHash isn't enough.
20:59:34 <glguy> its at least enough computation to tell you just the outermost constructor (maybe more but no guarantees)
20:59:53 <glguy> dmwit: I think in the lambda case it's a function from the first argument to the rest
20:59:55 <mxc> is HNF 'fully evaluated'?
21:00:01 <glguy> which might be another function in the multiple arguments case
21:00:08 <koninkje> dmwit: if it's truly just the lambda, then lambda is the head. I was presuming you meant the lambda was applied to something
21:00:09 <dmwit> glguy: Okay.  That's what intuition would say, too. sweet
21:01:22 <SamB> HNF isn't exactly a Haskell concept...
21:05:56 <koninkje> dmwit: that is, in particular the lambda that is the returned value, so "(\x y -> x + y) 5" will return the (5+) lambda not the (+) lambda
21:06:20 <dmwit> mmm
21:06:53 <dmwit> ...okay, got it
21:07:03 <koninkje> I mean, if "(\x y -> x + y) 5" was our thunk, then pulling on it would yield the new function
21:07:10 <dmwit> right
21:07:31 <dmwit> Incidentally, you have just replaced "evaluate" with "pull" in my vocabulary.
21:07:57 <Twey> Haha, mine too
21:08:25 <dolio> "\x -> (\y -> x + y) 5" is in weak head normal form, though.
21:08:26 <koninkje> (actually pulling on it would probably be a no-op since "the new function" is a partial application thunk; but what's /really/ returned is a matter of implementation and whether the implementation specializes for certain partial applications)
21:09:06 * koninkje thought "pull" was canonical already :)
21:09:22 <dolio> Though it's not in head normal form.
21:11:14 <gubagem> haskell seems to reach towards a higher density of "code" per line
21:11:37 <sjanssen> gubagem: yes, I think this is widely agreed
21:11:39 <ivanm> and a higher density of functions per module
21:12:26 <sjanssen> is this really true?
21:12:53 <ivanm> seems like it to me
21:12:59 <ivanm> so possibly not ;-)
21:13:11 <koninkje> gubagem: That's a side-effect of the high-level abstraction that makes coding time in haskell (frequently) more productive than in boilerplate languages like C/Java
21:16:38 <dmwit> If only the Prelude included Data.List, Control.Monad, Control.Arrow, Data.Char, Data.Maybe, Data.Ratio, etc...
21:17:01 <Twey> Why?
21:17:12 <Twey> Wouldn't be very minimal :-P
21:17:14 <koninkje> it includes the generically necessary parts of those
21:17:30 <dmwit> Twey: You say that like minimal is a good thing.
21:17:45 <SamB> dmwit: there's a reason it doesn't
21:17:48 <dmwit> Yet you use Haskell instead of Lisp.
21:17:50 <koninkje> (dependency tracking)++
21:17:55 <Twey> dmwit: Yes, because it would end up being PHP
21:17:59 <Twey> I also use Lisp.  :-P
21:18:06 <dmwit> =)
21:18:08 <SamB> dmwit: having it export all that would be MORE like lisp, not LESS
21:18:35 <Twey> Not CL, it wouldn't
21:18:39 <SamB> there is WAY too much stuff in the COMMON-LISP package
21:18:40 <dmwit> I was referring to the differences in syntax.
21:18:51 <dmwit> But, okay, if you want a stricter analogy, compare it to Scheme.
21:19:03 <Twey> SamB: Well yes, but it still has packages
21:19:36 <SamB> and, you know, it's packages don't work very well with the multiple facets of a name
21:19:57 <dmwit> Well, I didn't mean to start a language war.
21:19:57 <gubagem> in ghci :load programnamehere.hs should bring all my functions into scope in ghci, shouldn't it?
21:20:07 <Twey> dmwit: It's not really a war
21:20:07 <dmwit> Only if there's no main.
21:20:12 * gubagem wants to see the armageddon of languages
21:20:17 <Twey> Hahaha
21:20:19 <dmwit> Twey: No meta-wars, either. ;-)
21:20:22 <gubagem> if there is a main im out of luck?
21:20:29 <SamB> it's more of a rant session
21:20:38 <Twey> Hahaha
21:20:50 <gubagem> scheme was nice except it took me forever to learn it by myself
21:20:59 <dmwit> gubagem: You might be able to do something like :m + *Main
21:21:05 <gubagem> haskell seems to have better libraries, resources, community, compiler etc
21:21:14 <Cale> uh, you might want to check for .o files
21:22:05 <Cale> If they're present, ghci tends to load them which tends to make some of the names in that module inaccessible.
21:22:25 <SamB> a VERY nasty habbit, that
21:22:34 <dmwit> *hobbit
21:22:37 <gubagem> does the module definition come before the imports in haskell?
21:22:38 <SamB> I mean, loading them regardless
21:22:38 <dmwit> Fixed that for you. =)
21:22:51 <Cale> gubagem: yeah
21:22:53 <dmwit> gubagem: Yes, "module" comes first.
21:23:03 <gubagem> Module Main where ... rest of my program?
21:23:07 <Cale> yeah
21:23:10 <gubagem> k
21:23:11 <Cale> module*
21:23:12 <dmwit> lower-case module
21:25:00 <gubagem> if ive made a monad by accident am I heading in the correct direction?
21:25:40 <Twey> gubagem: Hahaha
21:25:45 <Twey> <3 Yes
21:26:01 <gubagem> im out
21:26:03 <gubagem> night
21:28:41 <sclv> ?remember gubagem If I've made a monad by accident, am I heading in the correct direction?
21:28:42 <lambdabot> Good to know.
21:29:08 <Twey> Aye :-P
21:30:25 <SamB> sclv: correct for what?
21:30:47 <edwardk> heh, anyone here good at combinatorics? =)
21:31:05 <ivanm> so-so
21:31:10 <sclv> SamB: you'll have to ask him.
21:31:12 <ivanm> depends on what you want
21:31:28 <edwardk> I'm trying to optimize k in http://www.mathbin.net/24100 to minimize the sum.
21:31:31 <lambdabot> Title: MathBin.net - optimization problem
21:32:50 <edwardk> I believe the derivation to be correct up to that point. Optimizing the binomial version on the top would be fine or the Poisson approximation below it. I have sort of a pragmatic answer, but I was hoping for something from first principles.
21:33:53 <dmwit> yipe!
21:34:43 <ivanm> edwardk: heh, looks a bit too much for me :p
21:34:52 <edwardk> ivanm: fair nuff
21:34:55 <ivanm> you want to find the minimum?
21:35:09 <edwardk> yeah i want a k such that the overall sum is minimized.
21:35:14 <ivanm> my guess would be to take the derivative and find it when it equals 0
21:35:23 <edwardk> heh
21:35:40 <edwardk> yeah that much i gathered. i just don't have an easy form for that
21:35:55 <ivanm> well, derivative wrt k...
21:36:26 <ivanm> I can't think of a nice way of taking the derivate of (1 - x^k)^k :s
21:36:38 <edwardk> when its a single level filter k ~ m/n ln 2 works perfectly here that can lead to oversaturation of a cell because you get things piling on binomially.
21:36:57 <ivanm> what's this for, anyway?
21:37:06 * ivanm hasn't done any combinatorial optimization stuff :s
21:38:04 <edwardk> I was writing up a blog post on some extensions I came up with for Bloom filters a few months back that I have been using for distributed Bloom joins, which give them nice properties for solving distributed database problems. I just wanted a nice closed form solution rather than handwave the practical values I use in reality ;)
21:40:05 <edwardk> I haven't had to do any of it for a while myself =)
21:40:33 <edwardk> I handwaved my way through building a model for this in BUGS and got a distribution for the error a while back, but I can't find the code I used =/
21:45:08 <edwardk> anyways this isn't needed for the core of the results, just would have been nice.
21:45:39 <ivanm> *nod*
21:50:48 <edwardk> ivanm: re the derivative from earlier: D[(1 - x^k)^k,k] = (1 - x^k)^k*(-((k*x^k*Log[x])/(1 - x^k)) + Log[1 - x^k])
21:51:27 <newsham> are there any wiki articles discussing generated machine code?  (ie. spineless tagless g machine type stuff)
21:51:38 <ivanm> edwardk: heh, looks ugly enough to be right :p
21:52:03 <edwardk> i just asked mbot ;)
21:52:36 * edwardk can feel his calculus skills slipping away.
21:53:02 <dolio> Who needs calculus when you've got Mathematica?
21:53:23 <newsham> edward: want practice?  i have a fun problem that seems easy at first :)
21:53:43 <Elly> newsham: what is it? :P
21:54:06 <edwardk> newsham: ?
21:54:07 <ivanm> dolio: someone who doesn't want to either 1) pay money for software and 2) doesn't like piracy?
21:54:22 <dolio> Ask mbot, then. :)
21:54:25 <newsham> you have a cyllindrical cup.  fill it up, tip it over until the water line goes from the lip on one side to the top of the base on the other side.  how much water is left?
21:54:28 <ivanm> dolio: heh
21:54:32 <edwardk> I own a copy of Mathematica. I just haven't bothered to move the license back to a PC from a Mac. ;)
21:54:57 * ivanm suddenly finds a copy of mathematica on his computer that magically appeared form nowhere
21:55:16 <newsham> err.. sorry, not the top of the base, the middle point of the base.
21:55:21 <newsham> (the top of the base is pretty easy problem)
21:59:40 <ivanm> newsham: a more important question: how much water did you waste by spilling when you tipped it over? :p
22:00:53 <Liempt> :t ByteString
22:01:08 <lambdabot> thread killed
22:01:17 <newsham> why do you say it was wasted?
22:01:19 <Twey> O.O
22:01:22 <Twey> Thread killed?
22:01:29 <Twey> :t ByteString
22:01:32 <newsham> perhaps you poured it into the pan you're using to make soup?
22:01:34 <lambdabot> Not in scope: data constructor `ByteString'
22:02:03 <Twey> Better... but... why so slow?
22:02:16 <dmwit> :k ByteString
22:02:18 <lambdabot>     Not in scope: type constructor or class `ByteString'
22:10:35 <roconnor> @hoogle intersect
22:10:39 <lambdabot> Data.List.intersect :: Eq a => [a] -> [a] -> [a]
22:10:39 <lambdabot> Data.List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:10:39 <lambdabot> Data.Set.intersection :: Ord a => Set a -> Set a -> Set a
22:10:54 <roconnor> @src Data.List.intersect
22:10:54 <lambdabot> Source not found. You speak an infinite deal of nothing
22:11:04 <roconnor> @src intersect
22:11:05 <lambdabot> intersect = intersectBy (==)
22:11:09 <roconnor> @src intersectBy
22:11:09 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
22:20:26 <psygnisfive> according to this: http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf
22:20:35 <psygnisfive> you need a PhD to properly program with types
22:20:43 <psygnisfive> two PhDs to program Haskell with types
22:20:44 <psygnisfive> :)
22:21:18 <newsham> psyg: you misread what he's saying.  he said H-M types are a sweet spot
22:21:24 <newsham> ie. "haskell good"
22:21:29 <psygnisfive> shh, it was funny. :P
22:21:38 <Heffalump> haskell 98 good, anyway
22:22:01 <psygnisfive> Do we want languages where a PhD* is required to understand
22:22:02 <psygnisfive> the library documentation? *two PhFs for Haskell
22:22:04 <dons> its an insider joke too. bjpierce wrote "Types and Programming Languages"
22:22:08 <psygnisfive> PhDs*
22:22:59 <dons> psygnisfive: read benjamin's book, http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091/ref=pd_sim_b_4/104-0009163-6568732
22:23:02 <lambdabot> http://tinyurl.com/282m6x
22:23:05 <dons> the joke makes more sense after  that.
22:23:30 <dons> you might also enjoy his "basic category theory" book
22:23:56 <psygnisfive> dude i cant grasp half the stuff you haskellers get. i dont even try.
22:24:07 <psygnisfive> "catamorphism"? way over my head.
22:24:10 <dons> that's a shame.
22:24:13 <psygnisfive> category theory? yeah ok.
22:24:14 <psygnisfive> :P
22:24:30 <psygnisfive> ive never found a good introduction even to monads
22:24:33 <psygnisfive> nevermind any of the other stuff
22:24:41 <dons> pity. there's lots of good ones.
22:24:49 <dons> and they're ludicrously simple, anyway
22:25:04 <dons> our CS courses don't teach people to think in abstractions, sadly
22:25:16 <edwardk> catamorphisms are just a generalized 'foldl/foldr'
22:25:22 * Twey feels the same, but still tries again every so often.  :-)
22:25:22 <dons> the fundamentals of the discipline are missing
22:25:33 <psygnisfive> i rely on SICP :P
22:25:40 <psygnisfive> not that SICP is all of CS
22:25:43 <newsham> too busy pumping lemmas
22:25:48 <dons> psygnisfive: just remember, 'catamorphisms' are catastrophic. they destroy data
22:25:49 <psygnisfive> but its really all i can find.
22:26:01 <ivanm> dons: not to mention lots of mediocre or even bad ones ;-)
22:26:01 <ivanm> I kinda got the bananas, etc. paper on morphisms
22:26:01 <ivanm> might try it again now that I've done some abstract algebra
22:26:30 <dons> an ability to deal with abstractions is probably one of the key distinguishing characteristics in our industry.
22:26:53 <ivanm> I tried reading "Category theory for computer scientists"... following along until they came to arrows, and then I called it quits :s
22:26:56 <dons> its often characterised as the ability to reason at all levels of the compilation process, from source to opcodes
22:27:08 <ivanm> I mean, using categories to emulate stacks was bad enough... ;-)
22:27:14 <dons> heh
22:27:22 <edwardk> dons: you get the same problem in math programs. people come out of calculus thinking that the rest of math is just more of the same. rote memorization of tools and groping towards applications of obscure rules rather than theorems and proofs. In a lot of programs you don't get to real math until you get disturbingly close to graduation ;)
22:27:24 <psygnisfive> i need a good tutorial
22:27:26 <psygnisfive> dons, you have one?
22:27:29 <dons> psygnisfive: if you're up to it, ask Cale tomorrow. he's a great teacher.
22:27:48 <dons> psygnisfive: you could try reading 'real world haskell' perhaps?
22:27:54 <dons> its got a rather good monads chapter
22:27:57 <dons> ?go real world haskell
22:27:59 <lambdabot> http://www.realworldhaskell.org/
22:27:59 <lambdabot> Title: Real World Haskell
22:28:01 <ivanm> psygnisfive: yeah, read it for free whilst you still can!
22:28:02 <ivanm> :p
22:28:09 <Cale> Have you tried my monad tutorials?
22:28:09 <ivanm> @where real world haskell
22:28:09 <lambdabot> I know nothing about real.
22:28:13 <ivanm> hmmm...
22:28:15 <dons> edwardk: hmm. that's interesting.
22:28:35 * Cale wonders if the RWH site will stay online after the book is in print.
22:28:37 <dons> edwardk: so that's much like CS. the abstractions don't kick in till the 5th year or so
22:28:46 <ivanm> edwardk: at UQ, we tried to change it this year by having a 1st year course for all scientists where they do math, science and programming
22:28:56 <newsham> that would make a great haskell t-shirt "Have you tried my monad tutorial?"
22:29:01 <dons> Cale, i expect so. we like humans.
22:29:03 <ivanm> newsham: lol
22:29:20 <psygnisfive> cale: link to monad tut?
22:29:21 <dons> you could try newsham's monad tutorial
22:29:34 * glguy proposes a ban on timezones
22:29:37 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
22:29:38 <ivanm> dons: so is RWH _your_ monad tutorial? :p
22:29:39 <lambdabot> Title: Monads as computation - HaskellWiki
22:29:39 <dons> yo glguy in the house!
22:29:41 <ivanm> glguy: why?
22:29:42 * glguy doesn't want to go to sleep so early
22:29:43 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
22:29:46 <lambdabot> Title: Monads as containers - HaskellWiki
22:29:49 <Cale> those two :)
22:29:52 <dons> glguy: how's the east coast?
22:29:58 <glguy> *late*
22:30:14 <psygnisfive> will read
22:30:16 <edwardk> ivanm: most times I've seen a university try to change that structure it lasts for a few semesters then the pass rate sucks so bad they dumb the curriculum back down or they take their nice new titles for courses and shovel in the old content under a new name ;)
22:30:19 <dons> that's Cale's tutorial.
22:30:24 <dons> people shouldn't recommend their own.
22:30:26 * edwardk is a little cynical re: academia. ;)
22:30:26 <glguy> I walked to the whitehouse and washington monument on capitol building, was cool
22:30:30 <ivanm> edwardk: no, I think this'll last
22:30:36 <dons> nice, glguy. i wish i was there.
22:30:45 <Twey> Oh () *is* a tuple.  Of course.
22:30:46 <ivanm> they have to dumb it down a bit as they didn't get through all the content (this was the first semester they did it)
22:30:48 <Cale> I also wrote http://www.haskell.org/haskellwiki/Introduction_to_IO if you're just interested in getting started with IO, but it doesn't really talk about monads in general.
22:30:49 <lambdabot> Title: Introduction to IO - HaskellWiki
22:30:54 <edwardk> ivanm: and one course does not a scientist make ;)
22:30:57 <ivanm> true
22:31:03 <Cale> (IO just happens to be a monad)
22:31:08 <ivanm> but at least we managed to get some of them learning how to do it
22:31:24 <ivanm> edwardk: main problem was biologists suddenly coming to 3rd year and told they had to code
22:31:34 <ivanm> at least math/phys people did basic stuff from first year
22:31:59 <cjs> Is it possible to have a map where the value is declared as a class, rather than a concrete type?
22:32:12 <psygnisfive> cale
22:32:13 <dons> i've a draft for the second part of my performance series, http://galois.com/~dons/tmp/fast-fusion.txt
22:32:14 <ivanm> edwardk: I'd point you to the link with lecture notes, etc. to look at but IIRC you have to sign in to see them :s
22:32:15 <edwardk> Yeah I did some bioinformatics work. In general the biology folks were in way over their heads ;)
22:32:15 <psygnisfive> which should i read first
22:32:18 <psygnisfive> computation or container?
22:32:30 <dons> Cale, et al, opinions welcome on how to strengthen it up, before i put it out tomorrow
22:32:40 <dons> psygnisfive: containers is good
22:32:45 <psygnisfive> ok
22:32:55 <dons> you could also try 'monads as programmable semicolons'
22:33:03 <hpaste>  morrow pasted "ghc/compiler/cmm/DataFlow.hs" at http://hpaste.org/8060
22:33:13 <ivanm> edwardk: my brother got a job helping to design a database solely because he does biol+math+phys, so they figured he'd be a good go-between for the biol people who wanted the database and the people actually building it ;-)
22:33:31 <ivanm> dons: what metaphor is RWH using?
22:33:40 * Twey laughs.
22:33:51 <ivanm> what are we up to now anyway? containers, programmable semicolons, and what else?
22:33:57 <ivanm> Twey: what at?
22:33:59 <dons> ivanm: space capsules of nuclear waste orbiting a frozen planet
22:34:00 <Cale> psygnisfive: I'm not sure exactly. Monads as computation gives the more typical way that functional programmers think about monads.
22:34:18 <dons> the planet has a liquid centre containing apple juice
22:34:30 <Twey> ¬´ my brother got a job helping to design a database solely because he does biol+math+phys ¬ª
22:34:36 <Twey> dons: Hahahaha
22:34:58 <dons> fairly self explanatory view of monads
22:35:01 <Twey> And there are little robots to help manage it all?
22:35:05 <ivanm> dons: so based off the wikibook one?
22:35:29 * Twey finds the absurd monad metaphors very amusing but not very helpful.  :-(
22:35:32 <dons> Twey: you definitely need to use the lolbotz of monad land
22:35:42 * Twey grins.
22:35:59 <Twey> And they've all got two layers of armour and two pincers
22:36:02 <Twey> Hence >>=
22:36:48 <newsham> nomadic computing with (o|-<)
22:36:56 <Cale> Heh, I should change "Monads as Containers" to be "Monads as Strudel".
22:37:03 <Cale> mmm... apple strudel
22:37:20 <dons> radioactive apple strudel!
22:37:25 <psygnisfive> monads as strudal? lol
22:37:32 <Twey> Hahaha
22:37:45 <psygnisfive> lolwut?
22:37:58 <Cale> psygnisfive: There are a lot of bad monad tutorials out there.
22:38:17 <psygnisfive> you sound like someone talking about JS books.
22:38:48 <newsham> IO: you can checkout anytime you want, but you can never leave.
22:39:30 <psygnisfive> livin it up at the hotel IO monad
22:39:47 <newsham> unsafePerformIO leave
22:39:49 <psygnisfive> maybe that shoud've been haskell IO monda instead
22:42:02 <psygnisfive> whats a functor/
22:42:03 <psygnisfive> ?
22:42:15 <newsham> ?instances Functor
22:42:16 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:42:20 <newsham> those :)
22:42:24 <psygnisfive> :(
22:42:52 <newsham> ?type fmap
22:42:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:43:03 <newsham> ?src Maybe fmap
22:43:03 <lambdabot> fmap _ Nothing       = Nothing
22:43:03 <lambdabot> fmap f (Just a)      = Just (f a)
22:43:13 <psygnisfive> you know i dont get Haskell types
22:43:13 <psygnisfive> :P
22:43:15 <newsham> thats an example of something that's a functor, with its implementation of fmap
22:43:17 <Deewiant> ?src [] fmap
22:43:17 <lambdabot> fmap = map
22:43:41 <newsham> fmap takes a function (a -> b) and turns it into a function   (f a -> f b)
22:44:02 <newsham> ie, a function  (Int -> Int) and converts it to a function ([Int] -> [Int])  or (Maybe Int -> Maybe Int)
22:44:23 <psygnisfive> hmm
22:44:28 <newsham> > (fmap (+1)) (Just 5)
22:44:31 <psygnisfive> i have a feeling that could be useful but i dont know how...
22:44:31 <lambdabot>  Just 6
22:44:44 <newsham> > (fmap (+1)) [5,6,7]
22:44:46 <lambdabot>  [6,7,8]
22:44:49 <dmwit> psygnisfive: Functors are just an abstraction.  fmap is just a polymorphic function.
22:45:05 <psygnisfive> no stop i dont get that :P
22:45:07 <dmwit> psygnisfive: fmap works differently on different types of Functors, and you have to learn them each separately.
22:45:11 <psygnisfive> let me look at what newsham wrote
22:45:23 <Deewiant> I think of functors as containers, which works for most of them - the defining feature being that if you can change the contents you can get a container with different contents
22:45:42 <Deewiant> (which can also be seen in the type of fmap)
22:45:56 <newsham> if you think of them as containers, fmap maps the function across the elements of the container
22:46:09 <psygnisfive> ok so a functor is just something that wraps a function?
22:46:13 <dmwit> no
22:46:19 <dmwit> A Functor wraps a type.
22:46:21 <newsham> so like you could define your own custom tree data type, and make it an instance of Functor by defining an fmap on that tree structure
22:46:25 <psygnisfive> ok
22:46:59 <newsham> if "[]" is the functor then it wraps a type (like Int) to form "[Int]".
22:47:00 <Deewiant> you know 'map', right? 'fmap' generalizes it to all kinds of containers, not just lists
22:47:05 <newsham> fmap is the thing "wrapping" the function
22:47:26 <psygnisfive> ok, so fmap takes some container, unwraps it, calls the function on the value, and rewraps it, right?
22:47:36 <dmwit> rarely
22:47:47 <dmwit> But that's sometimes an ok way to think about it.
22:47:53 <ivanm> heh
22:47:53 <psygnisfive> well, thats my way of trying to conceptualize a generic map :P
22:48:07 <dmwit> Yep, that's the "monads as containers" approach.
22:48:11 <ivanm> "that's wrong, but think of it that way" <-- brilliant
22:48:28 <Deewiant> well, it could be right
22:49:00 <newsham> > fmap (++"!") getLine
22:49:01 <lambdabot>  <IO [Char]>
22:49:02 <dmwit> It gets harder to justify as you move away from the []/Maybe Functors.  For example, what does "unwrapping the value" mean in a continuation Functor?
22:49:08 <newsham> ?type (++"!")
22:49:10 <lambdabot> [Char] -> [Char]
22:49:12 <psygnisfive> so if thats fmap
22:49:21 <psygnisfive> what is a functor?
22:49:23 <dmwit> Or, as newsham points out, in the IO functor?
22:49:24 <Deewiant> like said, it doesn't work for them all, notably Conts and the function types.
22:49:36 <Deewiant> a functor is something for which fmap is defined. :-)
22:49:40 <newsham> functors are the things that implement the Functor class
22:49:42 <psygnisfive> oh i see
22:49:58 <newsham> ie. things for which fmap is defined
22:50:03 <psygnisfive> so a functor is just one of those containers that lets you unwrap, and then rewrap
22:50:10 <Deewiant> essentially, yes.
22:50:26 <dmwit> Just be careful.
22:50:27 <Deewiant> but as dmwit said it sometimes takes a bit of imagination to think of a given functor as a 'container'. :-)
22:50:33 <newsham> ?type fmap (++"!")
22:50:35 <dmwit> Because when you "unwrap" it, there might be nothing there.
22:50:35 <lambdabot> forall (f :: * -> *). (Functor f) => f [Char] -> f [Char]
22:50:40 <Deewiant> @src (->) fmap
22:50:40 <lambdabot> fmap = (.)
22:50:42 <dmwit> > fmap (+1) Nothing
22:50:43 <lambdabot>  Nothing
22:51:14 <psygnisfive> in a pseudo-OO style could this be viewed vaguely like somecontainer.copyByApplyingFunction(somefunction)
22:51:15 <psygnisfive> ?
22:51:16 <Deewiant> > fmap (+1) (+2) 3
22:51:17 <dmwit> It's more accurate to say you're mapping the function across the contents of the container; no unwrapping or wrapping necessary.
22:51:18 <lambdabot>  6
22:51:25 <dmwit> And, in fact, that's why it's called fmap. =)
22:51:36 <dmwit> psygnisfive: yes
22:51:45 <psygnisfive> ok.
22:52:00 <psygnisfive> so its really just a map. gotcha.
22:52:11 <newsham> and sometimes not even really a "container"
22:52:20 <dmwit> right
22:52:23 <newsham> "mapping a function over a function"  "mapping a function over an IO action"
22:52:44 <psygnisfive> so whats with the =>??
22:52:49 <ivanm> dmwit: I thought it was called fmap because map was already taken and its used on Functors... :s
22:53:13 <ivanm> psygnisfive: in the type statement? that's used to denote type classes
22:53:15 <dmwit> psygnisfive: You mean in (Functor f => f a) type signatures?
22:53:22 <psygnisfive> yeah
22:53:23 <ivanm> @type sum
22:53:25 <lambdabot> forall a. (Num a) => [a] -> a
22:53:32 <Deewiant> @type 10
22:53:34 <lambdabot> forall t. (Num t) => t
22:53:42 <dmwit> psygnisfive: (Functor f =>) asserts that the type "f" implements fmap.
22:53:43 <koninkje> edwardk: where's your post for the bloom filter extensions?
22:53:50 <Deewiant> > (10 :: Double, 10 :: Int)
22:53:51 <lambdabot>  (10.0,10)
22:54:07 <dmwit> psygnisfive: In Haskell jingo, "Functor f" is called the "context" of the type signature.
22:54:18 <dmwit> psygnisfive: You can also make stronger claims.  For example,
22:54:41 <dmwit> "(Functor f, Show (f a))" asserts that "f" has an fmap, and that "f a" has a show function.
22:55:02 <edwardk> koninkje: i haven't written it up yet ;)
22:55:06 <koninkje> heh
22:55:11 <dmwit> i.e. loosely, tuple-notation is used to assert several class restrictions at once.
22:55:17 <psygnisfive> i just looked at the type of fmap and suddenly it made sense because i remembered pattern matching
22:55:23 <koninkje> edwardk: are you on planet haskell i assume?
22:55:26 <edwardk> koninkje: i was hoping for some more analytics before i posted up the bulk of it
22:55:30 <edwardk> koninkje: yeah.
22:55:31 <dmwit> psygnisfive: ...pattern matching?
22:55:32 <psygnisfive> but i think i forgot why i made sense immediately after realizing. x.x
22:55:40 <edwardk> comonad.com/reader is the blog. its on planet haskell
22:55:45 * koninkje will see it when it comes out then :)
22:55:47 <psygnisfive> dmwit: dont ask why, my mind works oddly.
22:56:02 <psygnisfive> all i know is
22:56:07 <psygnisfive> i looked at it and realized that
22:56:16 <edwardk> koninkje: I wanted to put a little more computer science into it that just hey look this works well for these purposes. ;)
22:56:32 <edwardk> I may just relent and post it sans science ;)
22:56:46 <psygnisfive> (a -> b) -> f a is itself a pattern that matches against things just like fac n is a pattern
22:57:07 <dmwit> That's not a pattern in the Haskell sense of the word.
22:57:14 <psygnisfive> thats ok :p
22:57:16 <psygnisfive> it is in my mind
22:57:28 <koninkje> edwardk: understandable. I'm in the process of trying to convince my boss to go with haskell for a project instead of c++. Library support was one of the derirables and we'd use bloom filters so...
22:57:30 <psygnisfive> and then i understood how that type signature worked once i realized that
22:57:41 <dmwit> Okay, great! =)
22:57:42 <edwardk> koninkje: what problem domain?
22:57:53 <edwardk> my stuff is mostly useful for bloom joins
22:58:08 <edwardk> Also all my code for it is in c# ;0
22:58:15 <psygnisfive> i think i partially saw a fictitious lisp pattern matching interpreter in my mind as i realized what that meant :p
22:58:50 <edwardk> psygnisfive: yeah technically type unification is a form of pattern matching.
22:58:54 <psygnisfive> i do all my conceptualization of patterns in terms of the logic programming interpreter they built in SICP
22:59:17 <koninkje> edwardk: implementing a logic programming language for natural language processing
22:59:22 <psygnisfive> in types, its not values being unified, its types, right?
22:59:32 <edwardk> psygnisfive: yeah
22:59:42 <psygnisfive> so in some sense, its the value of a "type property"
22:59:54 <koninkje> edwardk: ah. there was a hackage announcement for bloom filters recently, so maybe the properties'll carry over
22:59:54 <dmwit> Sure.
23:00:04 <dmwit> psygnisfive: And you can run right up the typing chain.
23:00:18 <edwardk> koninkje: yeah, I was talking to bos about my toy extensions earlier
23:00:22 <dmwit> psygnisfive: Haskell stops at "kinds" (the type of types), but you can go as high as you want in some languages.
23:00:25 <psygnisfive> which is a trivial thing to add on top of a pattern matcher
23:00:25 <psygnisfive> hm.
23:00:44 <psygnisfive> i think im beginning to understand. :o
23:00:50 <koninkje> psygnisfive: re dmwit's comment, Omega in particular if you want a Haskell-like language
23:01:07 <koninkje> with higher kinds I mean
23:01:21 <psygnisfive> i have this dream of implementing haskell on top of JS for fun webbrowser coding
23:01:27 <bos> edwardk: how goes the article?
23:01:40 <psygnisfive> who knows, you guys might enlighten me enough to make that possible. lol
23:01:43 <psygnisfive> :)
23:01:54 <dmwit> psygnisfive: Take a look at YHC, I think they have a JS backend.
23:02:08 <dmwit> psygnisfive: (And even some interface to the DOM and stuff like that.)
23:02:09 <psygnisfive> (greet 'lispy)
23:02:11 <edwardk> bos: I got the core written. I was trying to find a nice analytic solution to http://www.mathbin.net/24100 to make the exposition go less handwavy though =)
23:02:19 <psygnisfive> YHC?
23:02:20 <lambdabot> Title: MathBin.net - optimization problem
23:02:26 <dmwit> ?where yhc
23:02:27 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
23:02:32 <lispy> psygnisfive: hi
23:02:33 <dmwit> ?go haskell javascript
23:02:34 <lambdabot> No Result Found.
23:02:55 <edwardk> bos: i can't find the BUGS model I used to calculate the values I use in practice for it =/
23:03:05 <dmwit> psygnisfive: http://www.haskell.org/haskellwiki/Yhc/Javascript
23:03:06 <lambdabot> Title: Yhc/Javascript - HaskellWiki
23:03:20 <psygnisfive> ugh, thats no fair i wanna make an interpreter. :|
23:03:30 <dmwit> psygnisfive: There's nothing stopping you!
23:03:33 <psygnisfive> :P
23:03:45 <psygnisfive> ill make a different but inspired language instead.
23:04:02 <psygnisfive> brb
23:04:27 <jfredett_> Interesting question- is there some kind of mechanism for defining isomorphisms between types? eg if I define a type "data Toggle = On | Off" and want this to have all the properties and usefulness of being boolean functions, but with some kind of extra functionality that is only available for my Toggle datatype?
23:04:29 <hpaste>  bos pasted "Bloom filter sizing" at http://hpaste.org/8061
23:04:39 <bos> edwardk: ^^^
23:04:45 <dobblego> jfredett_, implicit
23:04:48 <dmwit> jfredett_: newtype
23:05:01 <bos> edwardk: that's what i use for a normal bloom filter; the expressions are similar.
23:05:04 <dobblego> oops, wrong language
23:05:13 <jfredett_> dmwit: but what if I, for some reason or another, need to use a datatype?
23:05:26 <dmwit> *need* to?
23:05:33 <edwardk> yeah. you can cheat and just use k = m /n ln 2. but the analytic solution isn't as nice in the case i provided.
23:05:33 <jfredett_> maybe I need a recursive type which is isomorphic to a list, but maybe different somehow
23:05:35 <dobblego> jfredett_, put the "extra functionality" in a type-class
23:06:21 <dmwit> That's a good idea.  Types which "behave similarly" should probably be in a type class together.
23:06:48 <jfredett_> dobblego: my original reasoning was wanting to be able to use the if_then_else_ thing work with any old type, mostly for asthetic purposes
23:06:50 <edwardk> anyways you want to slightly underpopulate the hierarchical form in practice relative to a normal bloom I find. so the analytic solution for the simple case doesn't seem to exactly apply in the hierarchical case. asymptotically its all the same, but asymptotics rarely tell the whole story ;)
23:06:55 <psygnisfive> so
23:07:09 <psygnisfive> Haskell shares a lot of its design with Miranda it seems
23:07:19 <psygnisfive> what makes haskell significantly different?
23:07:24 <bos> edwardk: indeed.
23:07:27 <dmwit> jfredett_: class Boolish a where unsafePerformBooleanify :: a -> Bool :
23:07:36 * psygnisfive asks in an interviewer-ish style
23:07:45 <jfredett_> dmwit: yah- thats a hell of a verbosity tax
23:07:47 <dobblego> class Nottable n where not :: a -> a
23:07:48 <dmwit> I don't know, Haskell is still alive?
23:07:59 <psygnisfive> hahaha
23:08:02 <bos> psygnisfive: miranda is so old, only a few people here have ever used it.
23:08:11 <edwardk> psygnisfive: type classes, better notation for types, about 9000 extensions to the type system ;)
23:08:27 <edwardk> psygnisfive: a lot of syntactic sugar. monads, too much stuff to count.
23:08:29 <dmwit> jfredett_: It was parody, you could of course use something nice and short like "bool", or "b" if you want to mystify your readers.
23:08:33 <psygnisfive> i see.
23:08:36 <psygnisfive> ok.
23:08:37 <jfredett_> what would be really neat would be to have "isomorphism Toggle -> Boolean where {total function convert takes any toggle to a boolean}
23:08:53 <jfredett_> and then have the compiler automatically spit in the convert function as needed
23:09:05 <jfredett_> kind of like a typeclass-lite
23:09:17 <dmwit> Neat, but a little bit scary.
23:09:45 <dmwit> Implicit conversions have caused me no end of pain in C[++].
23:10:10 <jfredett_> yah- it'd obfuscate some type checking, I suppose the better way would be to lift all that boolean stuff into a typeclass
23:10:24 <jfredett_> then have a Boolean a => a -> ...
23:10:32 <jfredett_> which is what you guys said
23:10:49 <jfredett_> so once again, the brains of the many are greater than the brains of me. :P
23:11:01 <koninkje> dons: Do you know what the state of the art is for Haskell/JVM stuff? (either or both of compiling Haskell to bytecode, or linking a Haskell library/executable against Java)
23:11:19 <Liempt> Hey folks, quick question.
23:11:27 <jfredett_> Liempt: go for it
23:11:37 <jfredett_> thar be smart peoples around here.
23:11:51 <jfredett_> did I scare him off?
23:11:57 <jfredett_> jfredett_-- :(
23:12:05 <Liempt> Nope.
23:12:05 <dmwit> can't change your own karma
23:12:10 <Liempt> Nevermind, I fix'd it.
23:12:15 <Liempt> =3
23:12:20 <jfredett_> dmwit: I know, thats why I didn't mind doing it. :P
23:12:23 <dmwit> All he had to do was restart his IRC client!
23:12:26 <dmwit> heh
23:12:34 <Liempt> =P
23:12:34 <jfredett_> crisis averted
23:12:43 <newsham> everyone makes their own karma
23:12:50 <jfredett_> we're so awesome, we answered your question with out even doing anything
23:12:54 <dmwit> My karma ran over your dogma.
23:13:16 <newsham> > reverse "dogma? I am god!"
23:13:18 <lambdabot>  "!dog ma I ?amgod"
23:13:26 <Pseudonym> Karma karma karma karma karma chameleon...
23:13:27 <psygnisfive> in haskell, if i had some sort of function, say, pair a b = (a,b), can i use that in a pattern like foo (pair a b) and successfully match against foo (1,2) or will this not work?
23:13:42 <dmwit> This will not work.
23:13:56 <dmwit> foo (a, b) = ... -- will, of course, work
23:14:08 <dmwit> But creating function inverses is not possible, in general.
23:14:14 <dmwit> As I'm sure you know. =)
23:14:16 <roconnor> oops
23:14:23 <roconnor> *Main> filter (not . slowIsPrime) primes
23:14:24 <roconnor> [162401,252601
23:14:28 <roconnor> heh
23:14:30 <psygnisfive> but theres no way to use a custom function in a pattern match?
23:14:52 <roconnor> my primes function isn't as good as I thought.
23:14:52 <dmwit> roconnor: uh-oh...
23:14:56 <dmwit> psygnisfive: No, only constructors.
23:14:58 <jfredett_> psygnisfive: not in general, so far as I know
23:15:04 <dmwit> psygnisfive: ...which are custom functions, incidentally. =)
23:15:08 <jfredett_> roconnor: well, you're discoraging it, calling it slow.
23:15:15 <psygnisfive> and operators like + and : and stuff, right?
23:15:24 <dmwit> psygnisfive: No, only constructors.
23:15:24 <roconnor> dmwit: I still appear to have got the right answer for the google treasure hunt
23:15:28 <jfredett_> rename it to "reallyexcellentnotfastbutstillveryniceIsPrime"
23:15:31 <dmwit> psygnisfive: (:) is a constructor.
23:15:31 <jfredett_> and it will feel better
23:15:34 <psygnisfive> but you can do n+k patterns and x:xs
23:15:35 <jfredett_> and then run petter
23:15:41 <dmwit> psygnisfive: pattern matching on (+) is an abomination.
23:15:43 <roconnor> dmwit: even with my faulty primes list
23:15:46 <psygnisfive> ok. :)
23:15:56 <roconnor> oh
23:15:59 <roconnor> hmm
23:16:05 <roconnor> acutally maybe I didn't fine the smallest
23:16:07 <roconnor> crap
23:16:18 <psygnisfive> and constructors are defined in some special way i presume?
23:16:25 <newsham> > let f (a :+ b) = a + b in f (1 :+ 2)
23:16:27 <lambdabot>  3.0
23:16:41 <dmwit> data Foo a b c = Constructor1 a b  | Constructor2 Int c | etc.
23:17:01 <newsham> contructors start with capital letters or capital punctuations
23:17:08 <dmwit> ...
23:17:18 <psygnisfive> capital /punctuation/?
23:17:19 <jfredett_> capital punctuations?
23:17:19 <dmwit> Where "capital punctuations" means ':'?
23:17:37 <newsham> but never capital numbers
23:17:46 <jfredett_> maybe it'd be better to say constructors start with shifted characters :P
23:17:51 <psygnisfive> capital apostrophe!
23:18:01 <jfredett_> shift+<something other than a number>
23:18:04 * dmwit chuckles
23:18:18 <dmwit> But seriously, capital letters and ':' only.
23:18:24 <psygnisfive> ok
23:18:29 <dmwit> No other capital punctuations (*snicker*) allowed.
23:18:42 <jfredett_> psygnisfive: typically people use : and some kind of ascii arrow shape
23:19:08 <dmwit> Incidentally: Capital letters are prefix constructors by default, and : are infix constructors by defualt.
23:19:11 <jfredett_> a la :-> or :+
23:19:53 <dmwit> You can convert Prefix to `Infix` and in:fix to (:) pre fix.
23:19:55 <psygnisfive> :) creates a monad of happiness *harp*
23:20:22 <dmwit> But all of this would be laid out nicely in a tutorial. ;-)
23:20:51 <jfredett_> :< creates the monad of angry sadness.
23:20:58 <bos> ouch, building a Data.Map is expensive.
23:21:14 <Liempt> fd:9: hClose: resource vanished (Broken pipe)
23:21:24 <dmwit> bos: How big is your Map??
23:21:34 <bos> dmwit: just 6000 elements.
23:21:37 <jfredett_> it's n log n, isn't it?
23:22:09 <jfredett_> > 6000 * (log 6000)
23:22:10 <lambdabot>  52197.08848926115
23:22:17 <newsham> > mkInt 3#
23:22:18 <lambdabot>   parse error on input `}'
23:22:20 <jfredett_> that shouldn't take to long.
23:22:24 <dmwit> That is a truly meaningless number.
23:22:35 <jfredett_> dmwit: nuh-uh.
23:22:56 <dmwit> bos: Well, what do you consider expensive?
23:23:05 <dmwit> On the order of seconds, or how long is it taking you?
23:23:08 <roconnor> dmwit: Ah, now I have a lovely mutually recursive definition between primes and isPrime.
23:23:17 <bos> dmwit: it's taking about a second.
23:23:24 <dmwit> ok
23:23:39 <roconnor> primes are those numbers that isPrime (and fastIsPrime)
23:23:46 <dmwit> roconnor: Wait, you're writing your own implementation of primes/isPrime? O_o
23:24:19 <roconnor> and a number isPrime if it's primes upto the square root of n all don't divid it.
23:24:29 <roconnor> dmwit: hmmm
23:24:40 <roconnor> I guess I should have downloaded something from hackage.
23:24:44 <roconnor> ...
23:24:49 * dmwit wishes we could bind to GMP
23:24:50 <roconnor> that would have been smart
23:25:04 <newsham> why cant you bind to gmp?
23:25:07 <Liempt> Do you folks do any Lambdabot support here, or is there a dedicated channel for that?
23:25:22 <dmwit> Every time I suggest it, people say it would wreak havoc with GHC's internal connection to GMP.
23:25:22 <mxc> i thought writing your own primality test, doing some obscure optimization, and then putting it on your blog was a requiremnet for being a haskell coder
23:25:26 <Liempt> Or is there. . . oh God. . . no. . . support?
23:25:28 <dmwit> I don't understand it, but...
23:25:28 <sjanssen> Liempt: #haskell is the place
23:25:34 <Liempt> Okay.
23:26:14 <Liempt> I'm getting a hClose: resource vanished (Broken pipe) error every time I try to invoke evaluation.
23:26:41 <newsham> liempt: do you have "runplugs" in the dir lambdabot is in?
23:26:54 <newsham> what happens when you   echo 1 + 1 | ./runplugs  ?
23:27:03 <newsham> did you do all the steps in the ./build file?
23:27:05 <dobblego> go newsham!!
23:27:17 <dobblego> this is the third person (including myself) to hit this problem
23:27:58 <Liempt> Sorry, one sec.
23:28:03 <Liempt> Let me check.
23:29:06 <roconnor> dmwit: got the same answer
23:29:20 <Liempt> Runplugs may or may not be active, I'm still working on it.
23:29:34 <roconnor> @hoogle prime
23:29:34 <lambdabot> Data.HashTable.prime :: Int32
23:29:34 <lambdabot> Text.ParserCombinators.Parsec.Prim.tokenPrimEx :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> Maybe (SourcePos -> tok -> [tok] -> st -> st) -> (tok -> Maybe a) -> GenParser tok st
23:29:34 <lambdabot> a
23:29:39 <Liempt> And there were ./build files, one of which was out of date.
23:29:40 <newsham> if you look at the stuff in "build" it'll letyou know what you need to do
23:29:51 <roconnor> > Data.HashTable.prime
23:29:51 <lambdabot>   Not in scope: `Data.HashTable.prime'
23:30:05 <Liempt> Okay.
23:30:07 <Liempt> Will do.
23:30:13 <jfredett> my interent didst die.
23:30:18 <newsham> the only change I needed in the build file was to add "--docdir=`pwd`/doc"  to the configure line
23:30:21 <psygnisfive> why is bind called bind and now flatmap or something, since it flattens the map of something?
23:30:39 <dmwit> It's not, it's called (>>=). ;-)
23:30:45 <psygnisfive> right :P
23:31:04 <dmwit> psygnisfive: Check this out:
23:31:07 <newsham> psyg: bind lets you take the result of one action and bind it to a value for use in another action
23:31:10 <newsham> sort of like "let"
23:31:12 <dmwit> do {
23:31:14 <psygnisfive> and why is it join not flatten? :(
23:31:17 <dmwit>   x <- getLine
23:31:19 <dmwit>   print x
23:31:20 <dmwit> }
23:31:29 <psygnisfive> whaaa
23:31:29 <roconnor> psygnisfive: how about join-map, since it is join composed with map
23:31:35 <dmwit> psygnisfive: What would you call the (x <-) bit there?  Would "bind" be okay?
23:31:37 <jfredett> dmwit: is there an echo in here?
23:31:41 * jfredett chuckles
23:31:59 <mxc> dmwit, your example is the same as do { getLine >>= print}?
23:31:59 <psygnisfive> er
23:32:04 <mxc> is it?
23:32:05 <dmwit> mxc: yes
23:32:12 <psygnisfive> i dont really know :X
23:32:26 <mxc> excellent
23:32:35 <newsham> monadlet x = getLine in print x
23:33:01 <sjanssen> > var "x" :: Sym Int
23:33:02 <dmwit> psygnisfive: Or, in C: { x = getLine(); printf(x); }.  You might call that a "binding" of "x" to its value (the result of getLine()).
23:33:03 <lambdabot>  x
23:33:10 <mxc> now, if i can just go from kinda-sorta-vaguely understanding monadtransformers to being able to productively use and create them, i'll feel like i've accomplished something
23:33:21 <mxc> so close to being able to use this language productively
23:33:24 <dmwit> psygnisfive: This is the sense of "bind" that is used in the monad's bind function.
23:33:29 <psygnisfive> hrm
23:33:29 <newsham> dmwit: you shouldnt pass user input as the format string parameter of printf.
23:33:40 <dmwit> Yeah, I know.
23:33:46 <dmwit> But you shouldn't use C in the first place.
23:33:54 <newsham> sometimes I should.
23:34:07 <jfredett> mxc: I still don't understand MonadT's, and I'm fairly productive
23:34:15 <jfredett> mxc: I like Arrows better. :)
23:34:27 <dmwit> newsham: Fine, change it to "write(x);" if it makes you feel better.
23:34:37 <newsham> write takes three arguments :)
23:35:01 <opqdonut> he meant puts
23:35:10 <dmwit> Bah!
23:35:17 <opqdonut> :P
23:35:18 * dmwit hateses C
23:35:23 <hpaste>  mxc pasted "java example" at http://hpaste.org/8062
23:35:27 <mxc> or, in java:
23:35:31 <opqdonut> now now, let's not turn all irrational here
23:35:36 <mxc> (too long to type i nthe channle)
23:35:42 <newsham> \x -> write(1, x, strlen(x))
23:35:57 <dobblego> mxc, that won't compile for a number of reasons
23:35:59 <dmwit> s/to type i nthe channle// # fixed that for you, mxc
23:36:17 <bos> ouch, Data.IntMap is 50% slower than Data.Map in my test here.
23:36:31 <opqdonut> bos: wow, that's weird?
23:36:43 <opqdonut> or are you mapping (pun not intended) another key type to int
23:36:44 <bos> opqdonut: yes, isn't it?
23:36:55 <bos> opqdonut: it's just a newtype wrapper around an int.
23:37:01 <opqdonut> hmm
23:37:12 <jfredett> you can't spell "idiocy" without "c"
23:37:13 <mxc> dobblego my java is rusty, but i believe that the point stands
23:37:28 <bos> 1.1 seconds for Map, 1.7 for IntMap.
23:37:41 <newsham> you cant spell idiocy without IO
23:37:46 <opqdonut> bos: could you post the code?
23:37:47 <psygnisfive> ok now i dont get the whole getline >>= print thing
23:37:56 <opqdonut> or preferrably a minimal example of this happening
23:38:10 <jfredett> and you can't spell verbosity without "com.import.java.lang.org.enterprise.lists.words.letters.*"
23:38:16 <dmwit> psygnisfive: You grok lambdas?
23:38:21 <newsham> psyg:   do { x <- getLine; print x }      getLine >>= \x -> print x
23:38:25 <newsham> getLine >>= print
23:38:37 <psygnisfive> right, ok
23:38:43 <hpaste>  bos pasted "slooow" at http://hpaste.org/8063
23:39:00 <psygnisfive> getLine is a monad? or returns a monad?
23:39:12 <newsham> getLine is an "IO String" :)
23:39:16 <dobblego> ?type getLine
23:39:18 <newsham> IO is a monad
23:39:22 <bos> opqdonut: ^^^
23:39:29 <lambdabot> IO String
23:39:29 <opqdonut> thanks
23:39:36 <opqdonut> i'll have a look once i get to work
23:39:37 <opqdonut> ->
23:39:41 <newsham> you might say that getLine is an IO action.
23:40:02 <dmwit> bos: Are you sure the time is in the Map/IntMap, not in the reading/grouping?
23:40:10 <psygnisfive> is an IO String a functor?
23:40:18 <bos> dmwit: i'm sure it's not in the reading.
23:40:18 <newsham> IO is a functor
23:40:20 <sjanssen> psygnisfive: no, but IO is
23:40:25 <newsham> > fmap (++"!") getLine
23:40:26 <lambdabot>  <IO [Char]>
23:40:37 <bos> dmwit: and the groupBy costs about 10%.
23:40:42 <psygnisfive> so then how can we do >>= on an IO string if its not a functor??
23:40:50 <newsham> ?src IO fmap
23:40:50 <lambdabot> fmap f x = x >>= (return . f)
23:41:21 <newsham> psyg: things that you can do (>>=) with are monadic values
23:41:28 <dmwit> bos: Okay, just checking to make sure you were doing profiling.  Though I should have guessed from the {-# SCC "groupBy" #-} that you knew what you were doing. =P
23:41:32 <psygnisfive> monadic values??
23:41:45 <newsham> >>= is for things that are instances of Monad
23:41:49 <dmwit> Values whose type are in a Monad.
23:42:01 <psygnisfive> oh i see, monads are distinguished from actual containers
23:42:04 <bos> dmwit: the profiling output makes no sense, unfortunately.
23:42:08 <psygnisfive> monads be a kind of container
23:42:09 <psygnisfive> ok
23:42:18 <jfredett> psygnisfive: exactly
23:42:24 <jfredett> a monad can't exist by itself
23:42:28 <newsham> ie:    (x :: IO String) >>= (y :: String -> IO b)
23:42:38 <jfredett> it always has something in it, even if that thing is nothing, if that makes sense
23:42:48 <psygnisfive> ok so IO is just a kind of container
23:43:08 <bos> dmwit: ghc swears that i spend my time in the reading code, which i know not to be true. i think the rewrite rules must be causing the cost centres to show up in the wrong places. or, er, something.
23:43:10 <newsham> IO is an instance of Monad and an instance of Functor
23:43:12 <jfredett> (value >>= function) just means "apply the functons to the value in the box"
23:43:31 <psygnisfive> but IO is also just a kind of container, not an instance of a container
23:43:34 <jfredett> s/functons/function/
23:43:59 <newsham> I wouldnt say that IO is a container myself.
23:44:05 <psygnisfive> right
23:44:09 <psygnisfive> its a kind of container, no?
23:44:15 <newsham> I would say that an (IO a) is some imperative code that results in a value of type a.
23:44:22 <jfredett> psygnisfive: I like to think that IO "contains" the state of the world
23:44:31 <jfredett> it's a bit of a stretch
23:44:44 <newsham> and bind lets you combine two imperative actions together into a bigger imperative action
23:44:45 <jfredett> but I think it works.
23:44:50 <newsham> (while letting you bind tothe intermediate result)
23:45:02 <jfredett> monads are really general buggers, which makes them a bit hard to understand sometime
23:45:05 <jfredett> s
23:45:06 <psygnisfive> ok.
23:45:39 <sjanssen> psygnisfive: the reason we say that 'IO' is a functor but 'IO String' isn't, is because being a Functor/Monad is a property of the container itself, not the container combined with whatever it is holding
23:45:52 <newsham> ie:  getLine :: IO String    and   writeFile "/tmp/blah" :: String -> IO ()
23:45:53 <psygnisfive> ok
23:46:01 <newsham> > getLine >>= writeFile "/tmp/blah"
23:46:03 <lambdabot>  <IO ()>
23:46:09 <jfredett> >>= is kind of like function application for monads, I suppose
23:46:12 <newsham> now I have a bigger combined IO action
23:46:21 <newsham> >>= glued em together
23:46:35 <jfredett> newsham: not unlike (.) for pure functions
23:46:54 <newsham> except the two things being combined have different shapes.
23:47:02 <jfredett> newsham: right.
23:47:09 <newsham> I think  "let var = val1 in expr2"  is a better analogy
23:47:11 <sjanssen> >>= is closer to ($), I think
23:47:13 <newsham> where expr2 may references var
23:47:31 <audreyt> I thought >=> is like (.) and >>= is more like ($)
23:47:32 <sjanssen> @type ($)
23:47:34 <lambdabot> forall a b. (a -> b) -> a -> b
23:47:42 <sjanssen> @type (=<<)
23:47:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:47:44 <jfredett> :t =<<
23:47:47 <lambdabot> parse error on input `=<<'
23:47:49 <newsham> act >>= \var -> expr     is like:   monadlet var = act in expr
23:47:50 <jfredett> damn, you beat me.
23:47:59 <audreyt> @type (<=<)
23:48:01 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:48:12 <jfredett> audreyt: fancy.
23:49:13 <psygnisfive> <(^.^<) (>^.^)> <(^.^<)
23:49:27 <dmwit> psygnisfive: You must promise me one thing.
23:49:30 <psygnisfive> :P
23:49:32 <psygnisfive> ok
23:49:34 <jfredett> AHH! evilmoticons!
23:49:43 <dmwit> psygnisfive: You must not write a tutorial about this.
23:49:48 <sjanssen> psygnisfive: not a valid Haskell expression.
23:49:49 <psygnisfive> hahaha
23:49:50 <jfredett> dmwit: LoL
23:49:51 <luqui> haha
23:49:57 <psygnisfive> aw why not? :)
23:50:00 <newsham> you will not get a "have you tried my monad tutorial" shirt until you write one.
23:50:06 <Twey> Ahahahaha
23:50:07 <jfredett> psygnisfive: because they're _everywhere_
23:50:23 <psygnisfive> i wrote a JS tutorial in the last few days
23:50:27 <psygnisfive> tutorials are in my blood! O_O
23:50:57 <psygnisfive> 44 pages of JS tutorial. god help me.
23:51:04 <psygnisfive> 44 pages of monad tutorial! :o
23:51:15 <jfredett> psygnisfive: no, god please no
23:51:19 <psygnisfive> hahaha
23:51:21 <newsham> have you written printf for js yet?
23:51:30 <psygnisfive> printf?
23:51:39 <jfredett> formatted print function
23:51:39 <dmwit> > printf "%d" 32 :: String
23:51:40 <quicksilver> Heffalump: not totally consistent, no.
23:51:43 <lambdabot>  "32"
23:51:45 <quicksilver> Heffalump: "mostly" consistent.
23:52:04 * luqui just reads that shirt "have you tried Cale's monad tutorial"
23:52:05 <psygnisfive> oh. such things aren't really necessary :)
23:52:08 <dmwit> > printf "I have %d bananas, and that's %c%c lie." 65 'n' 'o' :: String
23:52:09 <lambdabot>  "I have 65 bananas, and that's no lie."
23:52:22 <jfredett> my question- how did they hack up the variable argument function in haskell?
23:52:33 <dmwit> abuse of type classes
23:52:35 <psygnisfive> "I have " + 65 + " bananas, and that's no lie."
23:52:37 <luqui> hack is a very appropriate word in that question
23:52:42 <dmwit> :t printf
23:52:47 <lambdabot> forall r. (PrintfType r) => String -> r
23:52:49 <sclv> now now let's not be too harsh here.
23:52:53 <sjanssen> s/abuse/epic/
23:52:54 <newsham> > let s="let s=%s in var$\"> \"++printf s (show s)" in var$"> "++printf s (show s)
23:52:55 <jfredett> aaaaaahh
23:52:56 <lambdabot>  > let s="let s=%s in var$\"> \"++printf s (show s)" in var$"> "++printf s (s...
23:53:06 <dmwit> sjanssen: yep =)
23:53:15 <jfredett> newsham: you and your crazy quines
23:53:15 <psygnisfive> we dont need no stinkin printf in JS
23:53:29 <newsham> printf for fun and profit
23:53:31 <jfredett> psygnisfive: we don't need one in haskell either, but it is nice
23:53:34 <dmwit> psygnisfive: We don't need it in Haskell either, but there's always some misguided C newbie... ;-)
23:53:42 <jfredett> dmwit: jynx, owe me a soda
23:53:46 <psygnisfive> omg
23:53:50 <dmwit> dang!
23:53:57 * jfredett WINS!
23:54:00 <psygnisfive> i should stop learning haskell otherwise i'll start thinking like everyone else :(
23:54:03 <newsham> js most definitely does need printf
23:54:06 <psygnisfive> haskell is mind control!!!
23:54:06 <dmwit> jfredett: Well, I'll spot you a drink or two next time I see you.
23:54:12 * jfredett <-- is ungodly.
23:54:13 <psygnisfive> newsham: whyso?
23:54:21 <newsham> because its useful
23:54:28 <roconnor> oh crap
23:54:28 <psygnisfive> example where it would be?
23:54:28 <jfredett> victory dance time, I never win those things
23:54:40 <roconnor> dmwit: my fastIsPrime is really slow
23:54:48 * dmwit nods
23:54:53 <psygnisfive> maybe you should name it slowIsPrime??
23:55:03 <jfredett> psygnisfive: printf lets you separate the appearence of the outputted string and the actual dynamic content of that string
23:55:07 <psygnisfive> dont make the algo better, just change the name :)
23:55:16 <audreyt> or make the name shorter: fastIs'
23:55:17 <roconnor> screw you Fermat
23:55:20 <roconnor> *sigh*
23:55:20 <Twey> psygnisfive: Oh gods, not another crap JS tutorial :-(
23:55:25 <roconnor> all my numbers are too small
23:55:48 <psygnisfive> jfredett: i suppose. ive never seen an actual need for it
23:55:56 <luqui> audreyt, you mean to reduce the function call overhead? =P
23:56:08 <audreyt> exactly! (hi luqui :))
23:56:18 <jfredett> psygnisfive: well, if your printing out stuff for reading on stdin -- like local interprocess communication say
23:56:22 <psygnisfive> twey: http://wellnowwhat.net/Quick%20and%20Dirty%20JavaScript.pdf
23:56:23 <psygnisfive> :P
23:56:26 <quicksilver> bah. Use Jemplate :P
23:56:29 <luqui> long time no see audreyt
23:56:50 <jfredett> two programs read from STDIN, you could have a nice partial applied printf with a template stored somewhere thats easy to change
23:56:51 <psygnisfive> jfredett: but in Js...
23:56:59 <audreyt> luqui: indeed. how have you been? I see plenty of hackage actions from you :)
23:57:09 <solrize_> someone could write a javascript monad in haskell, so a tutorial for it could be about JS and monads at the same time ;)
23:57:14 <jfredett> psygnisfive: it's not strictly necessary, but it occasionally makes things prettier
23:57:26 <Twey> psygnisfive: What the hell is this O.O
23:57:45 <lament> 0.0 is the version number of all my projects
23:57:46 <luqui> audreyt, pretty well.   I blame you for making me a haskell zealot.
23:58:03 <Twey> <html> <head> <script type="text/javascript" src="sourcecode.js"><script/> </head> <body> </body> </html>
23:58:11 <Twey> That's not even valid HTML
23:58:13 <Twey> :-\
23:58:15 <thoughtpolice> anyone know a good way to go from Integer -> Word8?
23:58:21 <luqui> audreyt, if all goes as planned, will move to belgium for a haskell job.
23:58:22 <dmwit> :t fromInteger
23:58:24 <lambdabot> forall a. (Num a) => Integer -> a
23:58:27 <jfredett> thoughtpolice: with a function
23:58:31 <dmwit> oh
23:58:34 <audreyt> well haskell is merely a mathematician's shell for computers, and you're a mathematician, so blame math not me :)
23:58:34 <psygnisfive> whoops. twey, thank you for catching that. i modified that from a self-closing script tag lol
23:58:37 <psygnisfive> and didnt move the /
23:58:39 <dmwit> ?instances-importing Data.Word Num
23:58:40 <audreyt> luqui: excellent! my job is already a haskell job :)
23:58:40 <lambdabot> Double, Float, Int, Integer, Word, Word16, Word32, Word64, Word8
23:58:44 <psygnisfive> jfredett: sure, but you can make it pretty without printf
23:58:49 <Twey> psygnisfive: It's still not even valid HTML :-P
23:58:58 <jfredett> psygnisfive: you're missing the point... :/
23:59:07 <luqui> audreyt, in the sense that you made it one?
23:59:08 <Twey> I'd check the JS... but... I think it's going to give me apoplexy...
23:59:09 <psygnisfive> er.. yes it is twey. :P
23:59:09 <jfredett> psygnisfive: :P
23:59:28 <psygnisfive> jfredett: i dont see how. its not necessary in JS at all.
23:59:49 <Twey> psygnisfive: Lacking DOCTYPE, lacking <title> element, lacking <body> contents (for Strict)
23:59:53 <audreyt> luqui: aye. I need to start posting recruit notes on jobs.haskell.org
23:59:55 <jfredett> Twey: apoplexy? why you gotta be all fancy like that
23:59:55 <Twey> (which you should be using)
