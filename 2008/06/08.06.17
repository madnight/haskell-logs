00:05:21 <Armored_Azrael> Hey, does anyone know of whether or not the QIO monad has
00:05:22 <Armored_Azrael> a.) been packaged
00:05:22 <Armored_Azrael> b.) permission requested from the guys that made it to package it?
00:05:43 <Armored_Azrael> http://www.cs.nott.ac.uk/~asg/QIO/ (for reference)
00:05:57 <osfameron> morning
00:06:43 <osfameron> I seem to remember there was a function to pass to sortBy that meant instead of doing sortBy (\a b -> a `op` b) you could do sortBy (foo op)
00:07:02 <osfameron> (I mean, which existed in the libs -- of course I could write it)
00:07:03 <vixey> It's called comparing
00:07:09 <osfameron> ah, thanks
00:07:46 <osfameron> @index comparing
00:09:31 <osfameron> ah, Data.Ord
00:12:35 <lament>  
00:13:53 <osfameron> how can I reverse the order of the comparing?
00:14:02 <osfameron> do I need to just combine with reverse. ?
00:14:05 <vixey> flip comparisg
00:14:10 <osfameron> ah!
00:15:22 <osfameron> that's a *good* use of flip :-)
00:16:38 <lament> flap x y z = z y x
00:17:09 <osfameron> flop x y z = z x y
00:17:39 <lament> floop x y z = floop x y z
00:18:12 <osfameron> that could also be 'flid' :-)
00:18:25 <Saizan> flip . comparing, btw
00:18:40 <osfameron> I used flip $ comparing :-)
00:18:52 <osfameron> sortBy (flip $ comparing length)
00:18:52 <lament> flip . comparing is better
00:18:56 <osfameron> why?
00:19:19 <osfameron> sortBy (flip . comparing length) doesn't compile
00:19:26 <Saizan> comparing length is a bit of a waste btw
00:19:39 <opqdonut> yeah i prefer one $ instead of one . and one $
00:19:52 <opqdonut> (flip $ comparing length) aot. (flip . comparing $ length)
00:19:55 <vixey> I perfer ()'s
00:20:14 <vixey> flip (comparing length)
00:20:16 <osfameron> yeah I started with flip (comparing length) and moved to $.  I'm never sure about $
00:20:25 <opqdonut> heh, i guess this is the haskell equivalent of indentation fights :D
00:20:30 <osfameron> Saizan: what's wrong with comparing length?  I want a list sorted in reverse order of length
00:20:30 <lament> oh, i like $ here, i thought you actually meant (flip . comparing)
00:21:05 <osfameron> actually what I wanted was for my powerset function to return the sets in order of length, but the one I cargo culted doesn't
00:21:17 <Saizan> osfameron: that you're going to pay the O(n) of length twice for each comparison, that's more than once for each element
00:22:33 <osfameron> Saizan: so should I precache with a Schwartzian transform or whatever the haskellish equivalent is?
00:23:15 <Saizan> yeah, but only if you care about performance
00:24:45 <osfameron> ok, ta
00:30:36 <osfameron> if anyone would like to rip art^W^Wcritique my code, http://greenokapi.net/svn/code/scratch/countdown.hs  (mkdict largely having been written by #haskell, see the irclog pasted below code, I'll move those into a credits comment :-)
00:33:08 <Saizan> longEnough = not . null . drop 2
00:33:29 <vixey> alternatively, instance Num (Peano) where .. :p
00:34:47 <vixey> osfameron: You should not write import Control.Arrow  -- for &&&
00:34:54 <vixey> osfameron: instead import Control.Arrow ((&&&))
00:35:34 <vixey> it would be ok to write import Foo.Bar though
00:35:44 <vixey> but -- for <things> is not a good thing to have written
00:35:53 <osfameron> vixey: it's a comment :-)
00:36:00 <vixey> I know
00:36:03 <osfameron> it's useful to me to remind myself which functionality comes from which modules
00:36:06 <vixey> that's why I say it's bada
00:36:20 <vixey> that's why I suggest import Control.Arrow ((&&&))
00:36:26 <osfameron> but yeah, I guess importing explicitly the symbols I need has that capability too
00:36:30 <osfameron> good idea
00:36:37 <vixey> otherwise you could write
00:36:38 <maltem> sortBy (flip $ comparing length) = map fst . sortBy (comparing snd) . map (id &&& length) -- better if lots of lengths to be computed, or if long lists are involved
00:36:48 <vixey> import Data.List -- for <something which is not in Data.List>
00:37:59 <osfameron> maltem: shiny, that's what I meant by "schwartzian transform", thanks :-)
00:38:08 <osfameron> maltem: is that pattern abstracted in some library already?
00:39:15 <maltem> osfameron: I don't think so... I see sortBy often used for concise, but little efficient code
00:40:03 <maltem> I'd just write sortOn if I'd need that pattern often
00:41:44 <maltem> That is, factoring "length" out.
00:43:34 <osfameron> yeah I've used it a couple of times but not enough to bother factoring out yet, I'll have a look when I need a little fun exercise
00:45:32 <telexicon> whats the base64 encoding library to use with haskell?
00:49:27 <Deewiant> @bot
00:49:42 <ivanm> lambdabot is dead
00:49:47 <Cale> oh?
00:49:56 <Deewiant> evidently
00:49:57 <ivanm> Cale: yes
00:50:58 <ivanm> @botsnack
00:51:06 <lambdabot> :)
00:52:52 <vixey> Proof: Boring!
00:55:38 <vixey> whenever I see C-like pseudocode with math mixed in I just think the author is confused :/
01:02:57 <smtms> vixey, pseudocode is free form, why you'd thin anyone's confused?
01:03:40 <vixey> since they chose C ...
01:04:18 <smtms> vixey, you know what C is, and you know that many languages created after it borrow syntax from it
01:09:07 <vixey> it's like if you can have any car you like at all, why would you choose broken glass filled boots?
01:10:39 <smtms> vixey, using C syntax is one thing, using C is another
01:11:18 <smtms> C syntax is very common, and I'd be surprised if somebody chose to use Modula 3 syntax for example :-)
01:13:01 <kig> my haskell-fu has successfully made ghc explode with ld errors
01:14:44 <Maddas> I, for one, prefer Forth-like pseudocode.
01:15:27 <kig> aha, lacking package flags
01:18:27 <Saizan> kig: use --make
01:18:28 <Saul_> smtms: I actually like the indentation-directed syntax of languages like Haskell and Python
01:19:17 <Saul_> I use tabs anyway, so I'm glad to be rid of the unnecessary braces (or begin and end of some languages)
01:21:10 <vixey> I write pseudocode in lisp sometimes
01:21:16 <vixey> it usually actually runs though
01:21:17 <kig> Saizan: perfect, thank you
01:22:26 <osfameron> haskell's indentation is a wonderful thing, it sucks surprisingly little
01:22:49 <osfameron> I don't mind the idea of python having indentation (I mean, I indent my code anyway) but the fact it prevents them from having multiline lambdas just sucks
01:23:04 <lament> yeah
01:23:34 <lament> could have been fixed with a nicer lambda construct, although conceptually more complex
01:23:37 <Saul_> osfameron: I think you can have multiline anything by placing a backslash at the end of the line
01:23:48 <ivanm> vixey: what? pseudocode that actually runs? isn't that cheating? :o
01:23:49 <ivanm> :p
01:23:54 <Saul_> works in normal code and in strings iirc
01:24:23 <osfameron> oh?  I've definitely read they only have one-line lambdas.  But maybe I misunderstood, not grokking python and all
01:25:22 <maltem> Haskell's indentation rule only lacks "easy" multi-line strings
01:25:32 <lament> osfameron: yes, it could have been but wasn't
01:25:49 <lament> presumably to keep the language simple
01:26:02 <ivanm> maltem: you mean easier than list concatenation?
01:26:02 <osfameron> yeah, most programming languages don't have multiline strings (Perl ftw!)
01:26:18 <lament> Guido is actually against lambdas, which means that he's really just a nut
01:26:56 <maltem> ivanm: List concatenation isn't a multiline string? Not really, I mean
01:27:01 <Saul_> lament: Well at least he made a really awesome imperative language
01:27:32 <ivanm> maltem: well, you can kind of fake it...
01:27:36 <maltem> Well, Haskell _does_ have multiline strings, but only if you don't fear backslashes
01:27:39 <osfameron> and python's ternary is insane
01:27:44 <osfameron> maltem: and you still need to insert \n yourself
01:27:48 <ivanm> maltem: oh? in what way?
01:27:51 <ivanm> osfameron: ahhh
01:27:58 <ivanm> I thought you meant multiline in the source
01:28:09 <lament> yes, python ternary is insane
01:28:23 <lament> and in general the newer features seem to lack sense
01:28:39 <lament> maybe i'm just getting old :)
01:28:43 <osfameron> but they have builtin 'yield' which is cute
01:28:47 <osfameron> and the decorators look nice
01:29:02 <osfameron> I was reading some python code recently and getting very envious about it (from a Perl perspective)
01:29:04 <lament> ahhh but having real blocks would be so much better than this yield bullshit
01:29:14 * PHO_ likes Python's % operator
01:29:29 <lament> (see Ruby for how to do this right)
01:29:51 <hpaste>  maltem pasted "Multiline" at http://hpaste.org/8375
01:30:03 <maltem> ivanm: ^^
01:30:27 <osfameron> what does python % do ?
01:30:59 <lament> remainder
01:31:02 <osfameron> maltem: oh that's not bad.  I actually like the prepended \ as it delimits where you start again (so you don't have to line up multiline strings to the left)
01:31:11 <osfameron> oh.  Like everyone else then :-)
01:31:11 <PHO_> osfameron: http://docs.python.org/lib/typesseq-strings.html
01:31:12 <lambdabot> Title: 3.6.2 String Formatting Operations
01:31:14 <PHO_> not remainder
01:31:20 <osfameron> heh
01:31:23 <ivanm> maltem: does that become "onetwothree" ?
01:31:27 <lament> which is by the way an insanely useful operation
01:31:34 <lament> which haskell doesn't have in the stdlib
01:31:35 <ivanm> or "one\ntwo\nthree" ?
01:31:39 <lament> last time i checked
01:31:44 <ivanm> lament: mod?
01:31:49 <lament> :t mod
01:31:51 <quicksilver> @seen Cale
01:31:52 <ivanm> @hoogle rem
01:31:52 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I don't know when Cale last spoke.
01:31:53 <lambdabot> Prelude.rem :: Integral a => a -> a -> a
01:31:53 <lambdabot> System.Directory.removeDirectory :: FilePath -> IO ()
01:31:53 <lambdabot> System.Directory.removeDirectoryRecursive :: FilePath -> IO ()
01:31:58 <vixey> unlines ["one"
01:32:02 <vixey>      ,"two"
01:32:03 <ivanm> rem is probably what you want, actually...
01:32:03 <lambdabot> forall a. (Integral a) => a -> a -> a
01:32:04 <lament> >>> 3.5 % 3
01:32:05 <lament> 0.5
01:32:07 <vixey>             ,"three"]
01:32:08 <maltem> osfameron: See, if the left delimiter was not \ but determined by indentation... though I guess you get other problems then, but cool it would be
01:32:08 <osfameron> PHO_: oh it's like having sprintf builtin to strings?!
01:32:13 <lament> they're all "Integral"
01:32:14 <maltem> ivanm: onetwothree
01:32:15 <ivanm> lament: ahhh......
01:32:16 <PHO_> I think the format operator can be implemented using TH
01:32:19 <ivanm> maltem: *nod*
01:32:20 <PHO_> osfameron: yes
01:32:38 <quicksilver> haskell has that kind of %
01:32:39 <lament> i had to implement that one at some point, but really should be in the stdlib
01:32:43 <quicksilver> it just spells it `printf`
01:32:48 <osfameron> yeah I've seen someone post a template haskell solution to do multiline strings
01:32:50 <ivanm> lament: a remainder for reals doesn't really make sense, does it?
01:32:59 <osfameron> but I think TH is exceedingly ugly (and it scares me :-)
01:32:59 <lament> sure it does
01:33:02 <quicksilver> > "%s%s%s" `printf` "one" "two" "three" :: String
01:33:03 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
01:33:08 <lament> i mean
01:33:16 <quicksilver> hmm
01:33:16 <ivanm> lament: mathematically it doesn't....
01:33:20 <lament> yeah, sure it does
01:33:28 <vixey> no it doesn't
01:33:35 <ivanm> remainer : (Z,Z) -> Z
01:33:36 <lament> why not?
01:33:38 <maltem> osfameron: yea, as long as one doesn't need TH, it just scares off
01:33:44 <ivanm> where Z == integers
01:33:45 <quicksilver> remainder makes perfect sense for reals
01:33:48 <ivanm> *remainder
01:33:54 <quicksilver> we have it in Data.Fixed
01:33:54 <ivanm> quicksilver: in what way?
01:34:05 <ivanm> how does it make sense mathematically?
01:34:07 <quicksilver> the remainder when dividing 7.5 by 3 is 1.5
01:34:24 <quicksilver> it's only useful occasionally.
01:34:26 <ivanm> ummmmmm......... wtf?
01:34:37 <quicksilver> but when it's useful, it's useful. As is so often the case.
01:34:39 <lament> you have two lengths, A and B. You take the length B and draw it along A, counting the number of times you can place it. Once you can't fit any more Bs, you measure the _remainder_ of A that's uncovered by B.
01:34:40 <PHO_> I thought something 3 `mod` 7.5
01:34:44 <ivanm> so its integer division and return the rest?
01:34:48 <maltem> "%s%s%s" %% "one" %% "two" %% "three" -- could work in some way
01:34:49 <PHO_> s/something/something like/
01:35:03 <ivanm> lament: still don't think that's really mathematically correct.....
01:35:15 <lament> note that i never said A and B had to be integers, but it still makes sense
01:35:19 <quicksilver> what on earth do you mean by "mathematically correct" ?
01:35:23 <ivanm> since then you'd have to have something like 7.5 `remainder` 1.5
01:35:30 <quicksilver> lament's explanation is direct and 'physical'
01:35:36 <quicksilver> yes, 7.5 `rem` 1.5 is 0
01:35:37 <lament> ivanm: yes, it makes sense mathematically
01:35:40 <ivanm> quicksilver: as in something that makes sense in mathematics... not `physically` :p
01:35:53 <quicksilver> if it makes sense physically it's not hard to formalise it in mathematics.
01:35:54 <ivanm> the _name_ doesn't...
01:36:09 <lament> ivanm: in algebra terms, you can do R mod x where x is any real number.
01:36:15 <lament> ivanm: you get a ring
01:36:15 <quicksilver> lament's explanation gives an intuition as to why this operation crops up in geometry, sometimes.
01:36:18 <ivanm> I don't think so...
01:36:30 <ivanm> lament: that's not a remainder though...
01:36:49 <lament> that's what remainder is
01:36:54 <ivanm> you're talking about getting the ideal/quotient ring or something?
01:36:59 <lament> yes
01:37:10 <lament> remainder takes things into that ring
01:37:11 <ivanm> I wouldn't call it a remainder though :s
01:37:20 <lament> that's exactly what it is
01:37:55 <quicksilver> this is a silly argument.
01:38:00 <quicksilver> It's widely called remainder.
01:38:01 <ivanm> heh
01:38:06 <quicksilver> it's obvious why it's called remainder.
01:38:06 <ivanm> how about we agree to disagree?
01:38:24 <quicksilver> your argument boils down to "I think that's a bad name"
01:38:29 <ivanm> quicksilver: IMHO, remainder has to do with integers
01:38:30 <lament> suppose you have a circle with circumference of length A, and then you move along the circumference. note that every time you pass distance A, you get back to zero point. Your position inside the circle is the remainder.
01:38:38 <lament> That's where the word "ring" is coming from, i believe
01:38:40 <quicksilver> ivanm: your opinion is respected. Just wrong.
01:39:00 <ivanm> or more technically speaking to a euclidean domain
01:39:10 <ivanm> quicksilver: lol
01:40:14 <ivanm> you're defining remainder by the r term in "b = qa + r", right?
01:40:52 <lament> yes
01:41:43 * ivanm didn't think R was a euclidean domain...
01:42:07 <quicksilver> that's a perfectly reasonable interpretation, yes
01:42:16 <ivanm> hmmm.... wikipedia says you _can_ have remainder over the reals, but "... is not of theoretical importance in mathematics;..."
01:42:16 <quicksilver> but when something has an obvious continuous extension to R
01:42:31 <quicksilver> it's very common to use the same name for that extension
01:42:34 <quicksilver> or a minor variation
01:42:38 <ivanm> oh, wait, the reals would be a euclidean domain...
01:42:43 <ivanm> OK, fine, you're right
01:42:51 <lament> it might not be of theoretical importance, but it's practically useful
01:43:00 <quicksilver> "...not of theoretical importance to number theory, which is the only area of mathematics this wikipedia author holds is important..."
01:43:02 <lament> in exactly the situation i described
01:43:21 <lament> putting an angle in radians into a canonical form, for example
01:43:31 <ivanm> quicksilver: heh
01:43:34 <lament> it's just angle mod 2pi
01:43:41 <lament> when you have mod over reals
01:43:43 * ivanm gets back to studying for his exam tomorrow
01:43:52 <ivanm> which, coincidentally, is on abstract algebra :p
01:44:01 <quicksilver> lament: yes, it has application on principal values for complex numbers in the same way
01:44:09 <ivanm> so at the very least, my (futile and wrong) arguments were good practice :p
01:44:22 <quicksilver> lament: and IIRC you seem some related notation when people consider manifolds for complex log etc.
01:44:39 <lament> yes
01:44:53 <lament> it's all examples of the same thing
02:07:43 <swiert> @seen mattam
02:07:43 <lambdabot> mattam is in ##logic and #haskell. I don't know when mattam last spoke.
02:36:42 <solrize> @hoogle (a,b)->(b,a)
02:36:42 <lambdabot> No matches, try a more general search
02:37:51 <quicksilver> solrize: it's not there.
02:37:58 <solrize> np
02:38:02 <quicksilver> coming in the next release of Data.Tuple under the name 'swap'.
02:38:06 <idnar> @type snd &&& fst
02:38:07 <solrize> heh
02:38:09 <lambdabot> forall a b. (a, b) -> (b, a)
02:38:10 <quicksilver> although actually I've never needed it.
02:38:23 <quicksilver> If I did, I just write (\(x,y)->(y,x))
02:38:32 <quicksilver> does what it says on the tine.
02:38:44 <quicksilver> sometimes a small \-expression is a very concise way to say what you mean.
02:39:24 <solrize> yeah, i just thought maybe there was a builtin.  i used a listcomp instead
02:41:43 <evil_elf800> what is built is concurrency and parallelism mean?
02:41:50 <evil_elf800> does-
02:41:53 <evil_elf800> do-
02:42:07 <smtms> evil_elf800, try again
02:42:32 <Botje> it means you don't have to muck around with locks and mutexes and semaphores and all that crap
02:43:21 <quicksilver> solrize: yes, list comps are a nice syntax for "rearrangements".
02:45:54 <solrize> when i do an import i don't get the type aliases of the imported module?
02:46:16 <audreyt> not unless they export them explicitly iirc
02:46:22 <solrize> tx
02:46:27 <audreyt> np
02:47:13 <solrize> i think there's a zen to deciding when to use native types, when to use type aliases and when to make types with constructors
02:48:14 <audreyt> the important thing is the ADT-nature
02:48:51 <audreyt> as long as they are abstract, the zenness is preserved
02:49:37 <quicksilver> solrize: type aliases : a safe guideline is never.
02:49:40 * luqui almost always uses newtypes nowadays...
02:49:45 <solrize> hmm
02:50:03 <quicksilver> the only advantage of a type alias is slightly better "documentation" in :t (and haddock)
02:50:17 <solrize> yeah it's been of some help in error diagnostics too
02:50:23 <quicksilver> Sphere :: Radius -> Slices -> Stacks -> QuadricPrimitive
02:50:34 <quicksilver> ^^ Radius, Slices and Stacks are all just aliases for Float
02:50:42 <quicksilver> but the type aliases help you remember which is which.
02:50:45 <solrize> and it makes type annotations on functions more explicit
02:50:46 <solrize> yeah
02:50:46 <quicksilver> (that's from openGl library)
02:50:47 <luqui> but really I think that has to do with a lack of named parameters...
02:50:57 <quicksilver> luqui: yes. it's a substitute for named parameters
02:50:59 <quicksilver> in this example.
02:51:21 <solrize> using newtypes for everything means you get deeply nested constructors all over the place
02:51:34 <solrize> is there a way to use newtypederiving to get an integer type that inherits all the integer operations?
02:51:38 <quicksilver> yes
02:51:52 <quicksilver> newtype Foo = Foo Integer deriving (Num,Eq,Show,....)
02:52:04 <solrize> newtype VInt = VInt Integer
02:52:04 <solrize>     deriving (Eq, Num, Show, Integral, Enum, Real, Ord)
02:52:18 <solrize> yeah i hoped to not have to spell all that out, it seems unabstract
02:52:19 <quicksilver> oh, you were hoping for a shorthand?
02:52:21 * quicksilver nods
02:52:26 <quicksilver> No, I dont' think there is.
02:52:33 <quicksilver> mind you I disagree that it's not abstract.
02:52:41 <quicksilver> Num,Integral etc are part of the interface
02:52:48 <quicksilver> they're not hidden behind an abstraction layer
02:53:02 <quicksilver> class aliases would help though
02:53:07 <solrize> right but the abstract operation is copy all the classes from Integer
02:53:13 * quicksilver nods
02:53:21 <solrize> i.e. if Integer somehow got some new classes added, then that newtype wouldn't get them
02:53:24 <quicksilver> deriving (...)
02:53:28 <quicksilver> meaning derive everything
02:53:34 <quicksilver> that's quite a good idea.
02:53:38 <solrize> you can do that?  that's what i wanted
02:53:41 <quicksilver> no, you can't.
02:53:44 <solrize> oh :(
02:53:47 <quicksilver> it's a good idea though.
02:53:53 <quicksilver> maybe make a trac request for it
02:54:04 <solrize> hmm
02:54:46 <solrize> i have a type like   data Foo = Foo Bar Baz
02:55:59 <solrize> but what i really want is something like   data Foo = Foo {(bar, getBar, putBar):Bar} {(baz, getBaz, putBaz)}
02:56:08 <solrize> where getbar and putbar are serializer/deserializer
02:56:50 <solrize> instead of either having to put inappropriate types into the values or else separate the serialization code from the type signature
02:57:06 <solrize> this is that thing you looked at the past few nights
02:57:57 <hpaste>  solrize pasted "VInt parser" at http://hpaste.org/8376
02:58:01 <solrize> tell me if that sucks
03:01:42 <Saizan> ?hoogle Maybe Bool -> Bool
03:01:42 <lambdabot> No matches, try a more general search
03:02:01 <Saizan> :t fromMaybe False
03:02:05 <lambdabot> Maybe Bool -> Bool
03:02:48 <quicksilver> solrize: g >>= (return.VInt) would normally be written liftM VInt g
03:02:54 <quicksilver> solrize: or even better VInt <$> g
03:03:03 <solrize> hmm ok
03:03:32 <solrize> changed
03:04:43 <Saizan> i often feel bad when importing Control.Applicative just for <$>
03:04:51 <quicksilver> I don't :)
03:04:54 <solrize> just changed another liftm
03:05:17 <hpaste>  solrize annotated "VInt parser" with "(no title)" at http://hpaste.org/8376#a1
03:05:57 <solrize> can i turn the ifs into guarded actions or something?  i had a discussion of that earlier with someone but we didn't find any way
03:07:05 <quicksilver> yes, but I don't think it's worth the hassle.
03:07:14 <solrize> ok
03:07:21 <quicksilver> it would looksomething like this:
03:07:46 <quicksilver> runMaybeT ( guard (dso /= -1) >> lift L.get )
03:07:54 <solrize> yow
03:08:04 <quicksilver> imo the explicit runMaybeT is "as much noise" as the explicit Nothing
03:08:06 <quicksilver> in this simple case
03:08:13 <maltem> For some fun you could rewrite the recursion on g using fix :)
03:08:14 <quicksilver> it's worth it if you have a whole bunch of guards
03:09:02 <solrize> :t fix
03:09:03 <lambdabot> forall a. (a -> a) -> a
03:09:37 <solrize> i kept wondering if there was a way to avoid that recursion
03:09:40 <solrize> with an unfold or something
03:10:39 <evil_elf800> does haskell allow storing a lot of info without using a database?
03:10:50 <quicksilver> yes, there would be, but I think that recursion is probably the most elegant way to express it.
03:10:58 <solrize> evil_elf800: yes, haskell can do that
03:11:06 <solrize> hmm ok
03:11:13 <maltem> solrize: lol
03:11:27 <evil_elf800> ?
03:11:45 <solrize> inside joke
03:11:46 <evil_elf800> soutpark?
03:11:55 <solrize> @faq does haskell allow storing a lot of info without using a database?
03:11:55 <lambdabot> The answer is: Yes! Haskell can do that.
03:12:25 <solrize> @faq delete all files at a wave of your hand?
03:12:25 <lambdabot> The answer is: Yes! Haskell can do that.
03:13:12 <solrize> there are various persistence libraries around
03:13:16 <solrize> plus some database layers
03:13:36 <vixey> aha! http://www.iro.umontreal.ca/~monnier/tpch.pdf
03:13:54 <maltem> evil_elf800: For serialization you may want to have a look at Data.Binary
03:15:11 <maltem> evil_elf800: It serves for dumping a data structure efficiently to a file, you just have to remember the type of your data
03:16:19 <solrize> vixey, wow
03:19:04 <solrize> i wonder if i could  use a gadt in this deserializer so i could say Foo ExtBar ExtBaz  and get back Foo Bar Baz after running the appropriate get methods
03:21:28 <quicksilver> interesting idea.
03:24:44 <mm_freak_work> how can i hide functions from the Prelude?
03:24:54 <lilachaze> import Prelude hiding (...)
03:25:00 <solrize> what lilachaze said
03:25:05 <mm_freak_work> ty
03:25:39 <PeakerWork> hey, any chance the wx/haskell maintainer is here?
03:26:24 <quicksilver> don't think any of the wx guys IRC
03:28:01 <solrize> so i want to write that disk backed array class, should i make it hold a pure file handle, then pass it into an IO action that operates on the handle?  is that even allowed?  it sounds bogus
03:28:48 <quicksilver> file handles are pure but, in a sense, unsafe
03:29:00 <solrize> right
03:29:05 <quicksilver> in that they probably contain some underlying notion of file number
03:29:16 <quicksilver> and if the file is closed the pure handle becomes useless
03:29:22 <solrize> right, reading them or seeking on them mutates them
03:29:30 <quicksilver> it's even possible that if a later file is opened the number might get reused
03:29:33 <solrize> they're definitely not referentially transparent
03:29:35 <quicksilver> and an old handle might point to a new file
03:29:40 <quicksilver> I've no idea of that can actually happen.
03:30:02 <solrize> so i should make them live in IO all the way through
03:30:37 <solrize> i remember that example of two lazy io streams on the same file snarling each other up... because lazy io uses unsafeinterleaveio under the clothes
03:30:39 <mm_freak_work> quicksilver: IO closes files only, when the handle is garbage-collected, doesn't it?
03:30:47 <BeelsebobWork> @hoogle (a -> b -> c) -> Map k a -> Map k b -> Map k c
03:30:47 <quicksilver> mm_freak_work: incorrect.
03:30:49 <lambdabot> Data.Map.intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
03:30:57 <quicksilver> IO closes files when you "hClose hdl"
03:31:05 <solrize> yeah
03:31:25 <mm_freak_work> well…  i regard this as the programmer closing it, not IO itself
03:31:27 <PeakerWork> does anyone successfully use wx? I have a bunch of assertion failures from Gtk/gdk and then a wx hello world fails.
03:31:34 <quicksilver> mm_freak_work: yes, I agree.
03:31:43 <quicksilver> PeakerWork: yes, I successfully use wx all the time.
03:31:59 <mm_freak_work> if the programmer doesn't care about the handle, it's closed when garbage-collected, AFAI understood
03:32:00 <quicksilver> PeakerWork: can you compoile any of their sample apps?
03:32:05 <quicksilver> mm_freak_work: No.
03:32:13 <quicksilver> mm_freak_work: I don't think so.
03:32:19 <PeakerWork> quicksilver, I get a hang inside glib from __do_global_ctors_aux (before main even runs)
03:32:32 <quicksilver> mm_freak_work: close on garbage collection is only when you use the nasty readFile
03:32:47 <quicksilver> PeakerWork: using one of their sample apps?
03:32:51 <quicksilver> PeakerWork: or in your own app?
03:33:09 <PeakerWork> quicksilver, Nope, but merely linking against wx causes this problem, regardless of which code is in there.. so both an empty program and Reactive's wx examples did not work
03:33:18 <PeakerWork> (gdb shows they're stuck before main)
03:33:28 <quicksilver> PeakerWork: sounds like your WX is broken.
03:33:35 <quicksilver> PeakerWork: but, when you say 'linking against wx' what do you mean?
03:33:53 <PeakerWork> quicksilver, well, I used cabal install wx --global (it has a bug that it can only be installed globally)
03:33:59 <mm_freak_work> quicksilver: ah ok, that seems to be GHC-specific
03:34:05 <PeakerWork> quicksilver, and then I use ghc --make on an empty program that has "import Graphics.UI.WX"
03:34:08 <mm_freak_work> "GHC note: a Handle will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: […]"
03:34:19 <PeakerWork> quicksilver, (empty as in uses main = return ()
03:34:31 <quicksilver> PeakerWork: that's very odd.
03:34:39 <quicksilver> if you import Graphics.UI.WX but don't actually use any functions
03:34:45 <quicksilver> I'm surprised the linker even links it.
03:35:02 <PeakerWork> quicksilver, it runs in the gcc hack that lets libraries run before main()
03:35:05 <quicksilver> PeakerWork: which version of wx and wxcore?
03:35:26 <PeakerWork> wx-0.10.3, wxcore-0.10.3
03:35:32 <quicksilver> that's not a gcc hack, that's a C++ feature ;)
03:35:46 <PeakerWork> heh
03:35:47 <SamB> well, it can be either ;-)
03:35:53 <quicksilver> which version of ghc?
03:36:00 <PeakerWork> The Glorious Glasgow Haskell Compilation System, version 6.8.2
03:36:03 * quicksilver nods
03:36:08 <mm_freak_work> hmm…  hClose can fail…  so what is the correct way to close a handle?  whileM?
03:36:10 <PeakerWork> (Ubuntu 8.04)
03:36:25 <quicksilver> I have 0.10.2 working with 6.6.1
03:36:30 <quicksilver> which is not much help to you.
03:36:37 <PeakerWork> is there a withFile that uses bracket on it?
03:36:38 <quicksilver> which version of wxWidgets ?
03:37:31 <PeakerWork> quicksilver, ldd shows libwxc-gtk2.8.7-0.10.3.so => /usr/lib/libwxc-gtk2.8.7-0.10.3.so (0xb7e43000),   I have Debian's libwxgtk2.8-dev (2.8.7.1-0ubuntu3) installed
03:37:44 <PeakerWork> s/Debian/Ubuntu
03:38:21 <PeakerWork> and libwxbase2.8-dev 2.8.7.1-0ubuntu3,  and wx2.8-headers 2.8.7.1-0ubuntu3
03:38:39 <quicksilver> PeakerWork: I didn't think wxHaskell supported 2.8?
03:38:44 <quicksilver> I thought it only worked with 2.6
03:38:56 <PeakerWork> quicksilver, no idea, I was hoping cabal install/configure scripts would handle those kinds of things for me :)
03:39:06 <quicksilver> - Support for wxWidgets 2.6.x (support for wxWidgets 2.4.2 if  you compile from source). wxWidgets 2.8 is not yet supported
03:39:17 <quicksilver> from the announce file for wx 0.10.3
03:39:18 <PeakerWork> oh, why does "configure" not yell about it?
03:39:25 <quicksilver> WX is not very cabal aware
03:39:33 <quicksilver> there are problems
03:39:39 <quicksilver> I think dcoutts could explain some of them, I can't.
03:39:44 <PeakerWork> I see, but the wx-haskell has its own configure/make stuff that could probably yell
03:39:49 <quicksilver> I installed it by hand according to the readmes
03:40:17 <PeakerWork> how do I uninstall a ghc-pkg ?
03:40:24 <PeakerWork> so I can install it manually?
03:41:07 <quicksilver> I think installing again, on top of it, will work.
03:41:08 <quicksilver> I'm not sure.
03:43:17 <PeakerWork> can ghc-pkg tell me where are the files for a listed package?
03:43:47 <maltem> PeakerWork, quicksilver: wxhaskell from darcs supports compiling against wxwidgets 2.8  (even though probably not perfectly stable)
03:44:03 <PeakerWork> maltem, I'll use that then, thanks
03:44:11 <PeakerWork> now trying to get rid of the mess I made :)
03:45:09 <vixey> GADTs HOAS and De Bruijn indexing!
03:45:43 <solrize> that thing with gadt-based generics was interesting too
03:46:10 <greenrd> How can I trace an installed package in the ghci debugger?
03:46:37 <greenrd> I would need to load it as interpreted - how would I do that?
03:47:43 <quicksilver> you can't because installed packages don't (in general) have source.
03:47:47 <quicksilver> AIUI.
03:47:50 <vixey> that's fantastic
03:48:22 <pejo> There's a blogpost somewhere about how to get wxwidgets 2.8 and .. working on Mac. I've seen it run, so it "works" for some value of works.
03:50:19 <swiert> http://necrobious.blogspot.com/2008/05/wxhaskell-go-go.html
03:50:19 <lambdabot> Title: Necrobious': wxhaskell a go go
03:50:33 <swiert> I think that's the blog post. It worked all right for me...
03:51:03 <greenrd> quicksilver: I have the source available, I'm not just sure how to load it into ghci
03:51:41 <quicksilver> greenrd: I guessed; I was explaining why it doesn't "just work".
03:51:59 <quicksilver> greenrd: I don't know how to acheive it, I guess by loading one of the .hs files
03:52:08 <solrize> laterz all... thanx
03:53:17 <vixey> mmm
03:53:19 <vixey> you know Inaccessible case alternative?
03:53:43 <vixey> say I write VNil !! Fz = undefined, GHC complains with that message
03:53:51 <vixey> if I leave it out, -Wall says I didn't do all cases
03:53:56 <greenrd> OK, I loaded all the .hs files
03:54:06 <greenrd> but I stil don't get any trace for my exception :(
03:54:29 <vixey> is there no way to say explicity, this case is impossible, to make Wall happy?
03:55:22 <greenrd> oh, wait, I misunderstood, I thought that :trace would *display* the history
03:55:25 <greenrd> never mind
03:56:06 <SamB_XP> you have to explicetly request it to be displayed, yes...
04:01:25 <maltem> vixey: In what way is it impossible, GADT design?
04:01:28 <epsilo1> is there a way I can enter an editor from the ghci?
04:01:44 <vixey> maltem: yes
04:01:51 <maltem> mm
04:02:02 <maltem> epsilo1: :edit ?
04:02:34 <epsilo1> woah. thanks!
04:04:15 <maltem> vixey: One should actually hope for GHC to recognize that itself. I'm a little disappointed it doesn't
04:04:29 <vixey> yes
04:04:57 <vixey> it makes it impossible to be sure your function is partial
04:05:03 <vixey> em I mean, total
04:06:46 <maltem> oh, it is even worse: http://hackage.haskell.org/trac/ghc/ticket/2006
04:06:47 <lambdabot> Title: #2006 (unreachable GADT pattern clauses show up as warnings with -Wall) - GHC -  ...
04:07:09 <vixey> worse?
04:07:11 <vixey> I don't understand
04:07:31 <maltem> no, not worse, you mentioned something already I read over until now :)
04:08:22 <maltem> namely, the error message for the dummy branch
04:16:22 <maltem> Still the phrase "The code is old and crufty, and has several outstanding bugs. A rewrite is needed." does count as worse
04:24:05 <cjs> Damn, I'm finally plotting a graph of calculated volatitlities.
04:24:08 <cjs> Rock and roll!
04:30:24 <cjs> I feel like a real financial programmer now.
04:31:49 <vixey> I tried to make a List type which cannot be make infinite i.e. fix (Cons 1) is a type error, but you can still define (++) and so on
04:31:53 <vixey> I gave up..
04:31:59 <vixey> I think it's impossible
04:33:00 <EvilTerran> vixey, it'd need to have a type-level encoding of its length or something
04:33:04 <FordCortina> @hoogle Int -> String -> Char
04:33:04 <lambdabot> No matches, try a more general search
04:33:14 <FordCortina> @hoogle String -> Int -> Char
04:33:14 <lambdabot> No matches, try a more general search
04:33:39 <FordCortina> @hoogle [a] -> Int -> a
04:33:39 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
04:33:39 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
04:42:19 <PeakerWork> I get the same problem with wxhaskell/wx from darcs :(
04:44:04 <luqui> vixey, indeed, due to laziness haskell is "compact", so any type which can support lists of all lengths must also support a list of infinite length
04:44:45 <luqui> except, I suppose, for strictness annotations ;-/
04:45:38 <wjt> surely you could do this with type-level ints?
04:45:39 <luqui> okay nevermind, I kind of missed the point
04:45:54 <luqui> yeah, because that's not a single type...
04:45:59 <wjt> i'm not sure if you could make it a Monoid though
04:47:03 <vixey> I'd need something like typeclasses but GHC takes a closed world assumption on them
04:47:20 <vixey> so I could say,
04:47:37 <vixey>  Cons :: Mismatch x y => a -> List a x -> List a y
04:47:46 <vixey> such that fix (Cons 1) does not typcheck
04:48:03 <vixey> but since it's possible to add an instance Mismatch x x, it typechecks fine
04:48:14 <greenrd> conal: I'm getting this error from simple-reactive: "Future mempty: it'll never happen, buddy"
04:51:11 <greenrd> conal: I think I've figured out that it's being produced by listToEvent, but I haven't figured out what is trying to consume it yet
04:54:52 <maltem> PeakerWork: That's odd, I think it worked for me some weeks ago
04:55:45 <PeakerWork> maltem, I think I'll debug it deep down.. unfortunately there's a bug in the ubuntu glib package that the -dbg package does not really provide debug info.  Maybe I'll hack away the dh_strip of the glib package to debug it
05:00:01 <greenrd> conal: ah, I think it's my use of filterMP
05:08:12 <quicksilver> vixey: this is solvable by adding another parameter.
05:08:16 <quicksilver> vixey: see Oleg.
05:16:09 <vixey> what
05:16:21 <vixey> where is he?
05:18:52 <pejo> Does anyone happen to know of any popularity studies of F# or similar? Preferably something citeworthy.
05:19:17 <quicksilver> vixey: eveyrwhere.
05:19:45 <quicksilver> vixey: http://www.haskell.org/pipermail/haskell-cafe/2008-May/042869.html
05:19:46 <lambdabot> Title: [Haskell-cafe] Re: Trying to avoid duplicate instances, http://tinyurl.com/6zoajv
05:43:47 <PeakerWork> could be nice to have a script that tells you about potential style improvements for your program that are easy to identify.  For example, simple @pl'ing stuff.  \x -> blah <op> x  to become (<op> x) and stuff like that
05:46:45 <Snark> PeakerWork, I think lambdabot can do that
05:46:59 <Snark> I have read about it somewhere
05:47:45 <ivanm> not really as a script
05:48:06 <flux> I think making stylistic suggestions is still beoynd lambdabot's capabilities ;)
05:48:14 <ivanm> problem with that is how do you quantize style improvements? some people might prefer the @pl'd form, others don't
05:48:21 <Snark> ivan, well, can be adapted if the code exists
05:48:27 <ivanm> and it also depends on the context
05:48:33 <Snark> flux, I'm pretty sure I saw something about it
05:48:35 <flux> hey, represent the code in xml and let the editor choose how to display it \o/
05:48:36 <flux> ..not
05:48:46 <ivanm> e.g. @pl form might be nicer for the function in a map, etc. but not if defined normally
05:48:55 <ivanm> flux: lol
05:49:01 <flux> maybe a database of nice and bad constructions could be constructed
05:49:09 <flux> and an expert system would query this database to make suggetions
05:49:18 <Snark> http://www.haskell.org/haskellwiki/Pointfree
05:49:19 <lambdabot> Title: Pointfree - HaskellWiki
05:49:23 <Toxaris> can GADTs encode anything which Church encoding (with Rank2Types) can't?
05:49:25 <ivanm> flux: your mission, should you choose to accept it...
05:49:30 <PHO_> @pl'ing everything would make your code unreadable...
05:49:30 <lambdabot> pong
05:49:37 <ivanm> lol
05:49:42 * luqui thinks SK
05:49:43 <Toxaris> I mean RankNTypes I guess
05:50:16 <flux> @pl'ing code could be viewed as a relatively efficient way of doing automatic code obfuscation
05:50:16 <lambdabot> pong
05:50:37 <ivanm> flux: @pl'ing + concatenating
05:50:38 <PHO_> indeed :)
05:50:53 <ivanm> i.e. @pl a function, then replace that @pl'd form everywhere that function was called
05:50:55 <ivanm> then recurse
05:51:03 <flux> however, it would be cool if the @pl was able to.. do exactly that
05:51:09 <flux> so you could feed, say, lambdabot to it
05:51:11 <mm_freak_work> @help @djinn
05:51:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:51:15 <ivanm> which would also worsen the efficiency
05:51:17 <ivanm> @help djinn
05:51:18 <lambdabot> djinn <type>.
05:51:18 <lambdabot> Generates Haskell code from a type.
05:51:18 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:51:18 <mm_freak_work> @help djinn
05:51:18 <lambdabot> djinn <type>.
05:51:18 <lambdabot> Generates Haskell code from a type.
05:51:20 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:51:20 <flux> and get a humongous function that does everything
05:51:29 <flux> ivanm, performance, pft!
05:51:32 <ivanm> heh
05:51:40 <mm_freak_work> @djinn Integer
05:51:40 <lambdabot> -- f cannot be realized.
05:51:43 <flux> you could then pass that to a newbie to decipher
05:51:48 <mm_freak_work> @djinn Bool
05:51:48 <lambdabot> f = False
05:51:53 <mm_freak_work> ?!
05:51:53 <lambdabot> Maybe you meant: . ? @ v
05:51:57 <sieni> flux: mutually recursive functions might need some special treatment
05:51:59 <bluestorm> @djinn (a -> b) -> ([a] -> [b])
05:51:59 <lambdabot> -- f cannot be realized.
05:52:03 <mm_freak_work> @djinn IO Int
05:52:03 <lambdabot> -- f cannot be realized.
05:52:04 <flux> "once you've solved this, you can consider yourself a Je^H^HHaskell Master"
05:52:15 <ivanm> mm_freak_work: Bool has a parametric type, Integer doesn't
05:52:17 <bluestorm> @djinn a -> [a]
05:52:18 <lambdabot> -- f cannot be realized.
05:52:19 <PeakerWork> ivan, I prefer @unpl for complicated things, but for simple sections and stuff I think there's probably concensus that @pl is better..
05:52:21 <mm_freak_work> ah, ok
05:52:22 <ivanm> @djinn Maybe Bool
05:52:22 <lambdabot> f = Nothing
05:52:27 <mm_freak_work> @djinn Maybe Bool
05:52:27 <lambdabot> f = Nothing
05:52:36 <PeakerWork> ivanm, you can probably configure such a script for your @pl preferences
05:52:45 <mm_freak_work> @djinn IO Bool
05:52:45 <lambdabot> -- f cannot be realized.
05:52:45 <ivanm> PeakerWork: yes, but who would want to?
05:52:48 <bluestorm> @djinn (a -> a) -> a
05:52:48 <lambdabot> -- f cannot be realized.
05:52:50 <bluestorm> :]
05:52:56 <ivanm> mm_freak_work: I don't think djinn knows about monads...
05:52:59 <flux> sieni, yeah, there are some complications.. I doubt the problem is easy to solve.
05:53:07 <flux> s/is/would be/
05:53:07 <bluestorm> @djinn (a -> a)
05:53:08 <lambdabot> f a = a
05:53:11 <ivanm> nor lists, unfortunately :(
05:53:13 <mm_freak_work> where is @djinn useful?
05:53:20 <Snark> what does "@pl" mean?
05:53:21 <flux> @dfinn [a] -> a
05:53:21 <Baughn> It isn't
05:53:21 <lambdabot> -- f cannot be realized.
05:53:24 <ivanm> mm_freak_work: you actually want _usefulness_?
05:53:29 <Baughn> mm_freak_work: djinn is a neat toy
05:53:31 <mm_freak_work> ok hehe
05:53:32 <flux> hm, I thought it did handle lists, but I remembered wrong then
05:53:34 <ivanm> Snark: creates a point-free version of the given function
05:53:37 <bluestorm> how comes he doesn't know about  (a -> a) -> a  ?
05:53:40 <ivanm> @pl \ x y -> x + y + 1
05:53:40 <lambdabot> flip flip 1 . ((+) .) . (+)
05:53:48 <Snark> ivanm, eh, that was was I was referring to, then
05:54:02 <ivanm> bluestorm: how would you define a generic function of that type?
05:54:06 <flux> bluestorm, hm, how would you implement a function with prototype (a -> a) -> a?
05:54:07 <mm_freak_work> @djinn [Bool]
05:54:08 <lambdabot> -- f cannot be realized.
05:54:17 <ivanm> mm_freak_work: doesn't know about lists either ;-)
05:54:28 <chessguy> @pl \ x y -> 1 + x + y
05:54:28 <lambdabot> (+) . (1 +)
05:54:28 <ivanm> @djinn Either Bool Int
05:54:29 <lambdabot> f = Left False
05:54:34 <vixey> flux: it's only possible with recursion ( fix f = f (fix f) )
05:54:36 <ivanm> @djinn Either Int Bool
05:54:36 <lambdabot> f = Right False
05:54:36 <bluestorm> flux:   fix f = f (fix f) ?
05:54:42 <bluestorm> ach, too slow :-'
05:54:43 <vixey> or a really weird recursive type
05:54:53 <vixey> so djinn certainly cannot produce it
05:54:55 <sieni> @pl let even x = if x == 0 then True else not (odd (x - 1)) in let odd x = not (even x) in (\x -> (even x, odd x))
05:54:56 <lambdabot> liftM2 ap ((,) .) (not .) (ap (flip if' True . (0 ==)) (not . odd . subtract 1))
05:55:15 <mm_freak_work> ok hehe
05:55:19 <bluestorm> can't djinn recurse ?
05:55:24 <mm_freak_work> can i feed own types into lambdabot?
05:56:01 <chessguy> no
05:56:01 <ivanm> mm_freak_work: don't think so...
05:56:17 <vixey> bluestorm: Djinn produces only lambda terms which are proofs of first order intuitionistic statements, so it will never recurse
05:56:30 <sieni> @pl let even x = if x == 0 then True else not (odd (x - 1)) in let odd x = not (even x) in even
05:56:31 <lambdabot> ap (flip if' True . (0 ==)) (not . odd . subtract 1)
05:56:34 <bluestorm> yes, i just realized that  (a => a) => a  is not exactly a tautology
05:57:03 <vixey> it's certainly true in the logic of haskell
05:57:06 <bluestorm> (a => (a => a) => a, on the other hand... hey !)
05:57:10 <sieni> isn't that wrong?
05:57:10 <vixey> djinn only cares about a subset though
05:57:30 <sieni> odd shouldn't show up in either of the end results
05:58:07 <bluestorm> sieni: i'd say your functions are not mutually recursive
05:58:30 <sieni> > let even x = if x == 0 then True else not (odd (x - 1)) in let odd x = not (even x) in even 4
05:58:36 <bluestorm> as he use the already-defined 'odd' at the first time
05:58:39 <bluestorm> +s
05:58:45 <lambdabot>  thread killed
05:58:53 <sieni> oops
05:59:35 <sieni> blah
05:59:44 <bluestorm> @pl let {even x = if x == 0 then True else not (odd (x - 1)) ; odd x = not (even x) } in even 4
05:59:44 <lambdabot> (line 1, column 5):
05:59:44 <lambdabot> unexpected "{"
05:59:44 <lambdabot> expecting "()", natural, identifier or "in"
05:59:45 <sieni> odd 5
05:59:46 <Snark> does "flip (.)" have a name ?
05:59:48 <bluestorm> hmm
05:59:56 <Baughn> @pl flip (.)
05:59:56 <lambdabot> flip (.)
06:00:00 <Baughn> Guess not.
06:00:21 <Toxaris> :t (>>>)
06:00:24 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:00:47 <Toxaris> :t (>>>) :: (x -> y) -> (y -> z) -> (x -> z)
06:00:48 <lambdabot> forall x y z. (x -> y) -> (y -> z) -> x -> z
06:00:52 <Snark> yes, for arrows
06:01:01 <Snark> but I don't work with arrows (well, not directly)
06:01:07 <Toxaris> well, functions are arrows
06:01:09 <Snark> I just have function compositions
06:01:18 <Snark> as I said "not directly" ;-)
06:01:44 <sieni> @pl let {even x = if x == 0 then True else (odd (x - 1)); odd x = not (even x)} in even
06:01:44 <Toxaris> so you can use general arrow combinators with functions, just as you use general monad combinators with e.g. IO
06:01:44 <lambdabot> (line 1, column 5):
06:01:44 <lambdabot> unexpected "{"
06:01:44 <lambdabot> expecting "()", natural, identifier or "in"
06:01:56 <sieni> sigh
06:03:15 * Baughn ponders optimizing peano arithmetic by replacing the list with a counter of list length
06:03:18 <maltem> you probably want x == 0 || odd (x-1) anyway
06:03:25 <Toxaris> > let even odd x = if (x == 0) then True else not (odd (x - 1)) in let odd even x = not (even x) in even odd 4
06:03:26 <lambdabot>  Couldn't match expected type `Bool'
06:05:13 <therp> can someone rewrite "The Art of Computer Programming" using Haskell? Please.
06:05:32 <ivanm> therp: how much coin you going to offer someone to do so?
06:05:40 <sw17ch> therp, sounds like an excellent learning exercise :)
06:05:55 <pejo> therp, have you read the book by Okasaki?
06:05:57 <chessguy> hmm, it does that
06:06:01 <RayNbow> TAOCP hasn't been completed yet :p
06:06:05 <therp> ivanm: free beer for the whole night :)
06:06:10 <ivanm> let's see... first you need to have the money to buy the books... that requires you to get a _real_ job to be able to afford them... sounds like too much work :p
06:06:21 <ivanm> therp: well, I'm out as I dont' imbibe
06:06:34 <sw17ch> ivanm, or if you're from an upper-middle class home and can manage to get expensive geeky presents for a birthday...
06:06:43 <ivanm> nope
06:06:47 <RayNbow> http://www.gamedev.net/community/forums/topic.asp?topic_id=497841&whichpage=2&#3247851 <-- hmm, Haskell being mentioned in this thread...
06:06:51 <lambdabot> Title: Programming languages - the things that are wrong. - GameDev.Net Discussion Foru ..., http://tinyurl.com/5hkuy3
06:07:07 <therp> ivanm: damn, me neither, so I though that was a good chance to get rid of the beer leftovers from the last party :)
06:07:07 <ivanm> only expensive geeky gift I got was graduation from high school, when my parents got me a laptop
06:07:13 <ivanm> heh
06:08:17 <therp> btw rumors has it that TAOCP is available on a/the swedish bittorrent tracker
06:08:49 <ivanm> yes... but printed > digital
06:09:06 <sw17ch> ivanm, hah, my copy of TAOCP came as a combination last-year-of-college-and-your-birthday-and-christmass-happen-to-be-really-close-together present
06:09:11 <ivanm> lol
06:09:19 <therp> ivanm: indeed. however, I wouldn't mind buying the book, if it wasn't for MIX. It's so ugly to my eyes.
06:09:22 <ivanm> I needed a new computer, so...
06:09:33 <ivanm> MIX == the language knuth used?
06:09:40 <therp> yes. it's basically assembler.
06:09:59 <ivanm> hmmm.... I should probably see if I can grab it from the uni library.... never actually read any of it tbh :s
06:10:03 <therp> why would anyone such as knuth do that? I really don't understand it.
06:10:31 <quicksilver> he believes that it serves to focus attention on the *algorithm*
06:10:35 <ivanm> what other languages were around when he started?
06:10:42 <chessguy> MIX would be fun to embed and/or implement in haskell
06:10:43 <ivanm> had he done any cweb stuff at the time?
06:10:44 <quicksilver> rather than being distracted by the features of the high level language concerned.
06:10:57 <ivanm> quicksilver: isn't that the argument used for teaching lisp nowadays?
06:11:00 <Gilly> Suppose I have a collection S* of elements (i,S) where i \in N_0 and S is a set. I wish to select a set Q such that for each (i,S) \in S* holds |S `intersect` Q| = i. Any ideas on applicable algorithms?
06:11:10 <ivanm> it was here... (not that I'm complaining, as that's what led me to Haskell \o/ )
06:11:39 <quicksilver> I think if his argument holds any validity at all it's only because all his structures basically work on machine bytes or ascii chars.
06:11:46 <quicksilver> I.e. he doesn't use datatypes.
06:11:50 <ivanm> *shudder*
06:11:56 <quicksilver> But, I don't think it particularly damages the book.
06:12:02 <quicksilver> It's about algorithm + structure, not encoding.
06:12:38 <ivanm> quicksilver: probably depends on how much syntax gets in the way of the algorithm
06:12:54 <ivanm> with assembler, since there's not much syntax... ;-)
06:12:56 <chessguy> Gilly:  sounds like a #math question
06:13:14 <Gilly> probably so.
06:13:24 <therp> the argument that you have to focus on the algorithm is true for sure. but it's just as valid as presenting Shakespeare to English students in morse code with the argument that it makes you focus on letters.
06:14:49 <vixey> or a ##algorithms question
06:15:03 <sayaaan> is anyone here using lava?
06:15:20 <Gilly> oh there's even ##algorithms? :) great gonna pop up there
06:15:32 <lilachaze> Gilly: sounds NP-complete, if that helps :)
06:15:39 <Gilly> i suspect it is
06:15:51 <Gilly> haven't been able to reduce it to exact cover or similar though :/
06:16:59 <opqdonut> Gilly: the structure you're trying to obtain sounds a bit like a steiner system
06:17:17 <opqdonut> see http://mathworld.wolfram.com/SteinerSystem.html
06:17:17 <lambdabot> Title: Steiner System -- from Wolfram MathWorld
06:17:38 <opqdonut> no, i misremembered
06:17:46 <opqdonut> there's another structure that is like that tho
06:17:54 <Gilly> hmm
06:17:57 <sayaaan> -_-
06:18:04 <lilachaze> Gilly: it's a special case of 0-1 linear programming
06:18:31 <chessguy> hm, which would be more fun, embedding MIX in some EDSL or actually building an interpreter for it
06:19:02 <Gilly> I don't know about linear programming. Does that mean there's some nice solution available?
06:19:18 <opqdonut> well yes and no
06:19:19 <ivanm> chessguy: fun == "easy" or fun == "elegant"?
06:19:28 <ivanm> or does fun == "challenging"?
06:19:34 <opqdonut> there are a lot of algorithms for integer LP but they're still exponential
06:19:36 <litb> hello all
06:19:38 <chessguy> ivanm: elegant, i guess
06:19:43 <opqdonut> but finding an implementation should be easy at least
06:19:54 <litb> hmm
06:19:57 <ivanm> elegant and easy would be best :p
06:19:58 <opqdonut> but hey, almost every NP problem is reducible to integer programming :P
06:20:00 <lilachaze> Gilly: it also means it's NP-complete.
06:20:10 <opqdonut> lilachaze: no it doesn't
06:20:22 <opqdonut> lilachaze: quite many trivial problems are special cases of ILP :P
06:21:01 <lilachaze> opqdonut: naturally, but every case of ILP reduces to Gilly's formulation too
06:21:09 <chessguy> ivanm:  technically, it would be MIXAL that would be embedded/interpreted. MIX itself would just be modelled
06:21:13 <lilachaze> opqdonut: actually...
06:21:24 <Gilly> eek - i clearly need more education on algorithms - can't handle the discussion you are going :)
06:21:37 <Gilly> *having
06:21:44 <opqdonut> lilachaze: ah you should've said it's equivalent with ILP
06:21:46 <lilachaze> opqdonut: yes, i think there's a straightforward translation from ILP to the special case
06:21:59 <pejo> Gilly, there's a good chapter on linear programming in the algorithms book by Cormen et al.
06:22:00 <lilachaze> opqdonut: indeed, i should have :)
06:22:04 <opqdonut> yeah i'd fathom so too
06:22:12 <opqdonut> (that there's a transformation as you said)
06:22:19 <chessguy> pejo:  is that the CLR book?
06:22:34 <Gilly> so what does ILP stand for? so i can google on it
06:22:50 <chessguy> integer linear programming
06:22:57 <pejo> chessguy, probably, it's a brick, Rivest is another one of the authors.
06:23:07 <Gilly> pejo: don't have the book nor time to order and read it :/ thanks for the pointer though
06:23:08 <chessguy> pejo:  yeah, sounds like it
06:23:14 <lilachaze> opqdonut: looks to be a bit fiddly though, since in (i,S), S is a set. but (1,{a,b}), (1,{b,c}) guarantees a == c, so you can duplicate elements.
06:23:14 <Gilly> chessguy: thanks
06:23:35 * chessguy adds that to his list of books to buy once he has a job
06:23:45 <litb> lol
06:24:24 <chessguy> CLR, Okasaki (or whatever that functional data structures book's author is), AOCP...i'm in for a fun few months of reading...
06:24:34 <litb> can haskell do SHM ?
06:24:46 <lilachaze> @faq can haskell do SHM ?
06:24:46 <lambdabot> The answer is: Yes! Haskell can do that.
06:25:16 <quicksilver> litb: SHM between unix processes? I've not seen any bindings for that.
06:25:29 <quicksilver> litb: shared memory concurrency? Yes, using threads.
06:26:05 <osfameron> chessguy: problem is... you get a job, and then you have money but no time
06:26:12 <chessguy> what is SHM?
06:26:15 <lilachaze> chessguy: you need at least the second edition of CLR for the LP stuff.
06:26:55 <chessguy> lilachaze:  good to know, thanks. i'll probably look for a pretty recent edition
06:27:57 <chessguy> especially if i wind up with a job that makes me actually think, as i hope to
06:29:00 <tibbe> are there any alternate names for fold(l/r) and unfoldr in FP literature? I know reduce is quite common. Any others?
06:29:21 <vixey> catamorphism
06:29:46 <tibbe> right
06:29:50 <tibbe> and anamorphism
06:29:57 <tibbe> I was thinking of easier to read names :)
06:30:00 <araujo> morning
06:30:08 <tibbe> like "build"
06:30:25 <Saizan> :t GHC.Exts.build
06:30:26 <vixey> build is no easier than catamorphism or any other word
06:30:28 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
06:39:17 <Snark> hmmm... if I have a type class Bar, which inherits from Foo
06:39:44 <opqdonut> don't say inherits
06:39:49 <opqdonut> it doesn't work that way
06:39:55 <opqdonut> you're thinking OO
06:40:28 <matthew-_> it's more a restriction that you can't make an instance of Bar which is not an instance of Foo
06:40:44 <Snark> hmmm...
06:41:24 <Snark> my question was : if I overload a function for Bar instances, how can this overloaded function use the function it overloads (calling "super" in some languages)
06:41:29 <Snark> ?
06:41:33 <Snark> can it even do it?
06:41:34 <quicksilver> you can't.
06:41:44 <ivanm> overloading isn't allowed
06:41:44 <quicksilver> that's not what classes are for.
06:41:51 <quicksilver> They're for adhoc polymorphism
06:41:51 <matthew-_> quicksilver : what if they're in different modules?
06:42:05 <quicksilver> not implementation inheritance
06:42:12 <ivanm> quicksilver: adhoc? what kind of polymorphism isn't adhoc then?
06:42:19 <matthew-_> @type id
06:42:21 <lambdabot> forall a. a -> a
06:42:23 <quicksilver> ivanm: parametric
06:42:30 <Snark> ivanm file:///usr/share/doc/haskell98-tutorial/html/classes.html#sect5
06:42:32 <ivanm> quicksilver: as in [a], etc.?
06:42:35 <quicksilver> ivanm: right
06:42:37 <Snark> parametric, indeed...
06:42:47 <quicksilver> Snark: your question doesn't even make sense in haskell
06:42:48 <ivanm> Snark: that doesn't do me any good :p
06:42:58 <quicksilver> Snark: consider Num, which inherits from Eq
06:43:07 <quicksilver> Snark: if I'm trying ot make "MyType" and instance of Num
06:43:16 <quicksilver> I cannot choose an "different implementation" of (==)
06:43:23 <quicksilver> which is what your question would boil down to.
06:43:24 <ivanm> quicksilver: see, that's what I get for learning haskell in an "adhoc" fashion :p
06:43:45 <quicksilver> Snark: rather I make "MyType" an instance of Eq, and an instance of Num.
06:43:57 <quicksilver> and Num in fact *requires* that I make MyType an instance of Eq
06:44:04 <quicksilver> that's all class inheritance means.
06:44:08 <Snark> yes, I saw that
06:44:19 <quicksilver> so there is no overloading involved.
06:44:38 <Snark> I'm still trying to understand how I can use haskell to do the same something to different data types
06:44:59 <quicksilver> can you make your question slightly more concrete?
06:45:02 <matthew-_> the data type is an instance of the type class for which you want to do the "things"
06:45:44 <Snark> quicksilver, I can hardly make my question more concrete... since it's a purely theoretical one
06:45:58 <lilachaze> Snark: if you overload a function for Bar instances, you can call the function with the same name for a different type simply by calling it in the normal fashion.
06:46:02 <Snark> let's try to cook up something
06:46:05 <lilachaze> Snark: for instance...
06:46:16 <Saizan> ?src Eq
06:46:16 <lambdabot> class  Eq a  where
06:46:16 <lambdabot>     (==), (/=)   :: a -> a -> Bool
06:46:30 <Saizan> (==) does something different for every type
06:46:53 <Saizan> you define it in the instance declaration
06:46:55 <lilachaze> Snark: class X a where foo :: a -> a; instance X Int where foo = (1+); instance X [Int] where foo = map foo
06:47:41 <matthew-_> that last one would be better as instance (X a) => X [a] where foo = map foo
06:48:10 <Snark> hmmm... no, I can't cook something up : it doesn't look sane, indeed I'm not sure the question has a meaning :-/
06:48:23 <quicksilver> Snark: well the problem is, the answer to the question would be different in different circumstances.
06:48:30 <Snark> lilachaze, yes, this works, but it isn't directly my question
06:48:37 <quicksilver> Snark: in one case, I might say "yes, actually, typeclasses are a good solution in this case"
06:48:52 <quicksilver> in another I would say "Hmm, I would recommend bundling some higher-order functions into a control structure"
06:48:53 <Socrates> Snark: There's not notion of "super", since you're not overriding a default implementation
06:49:24 <lilachaze> except if the class has a default implementation?
06:49:29 <Snark> Socrates, my question was about overloading a default implementation but still wanting to use it...
06:49:36 <lilachaze> but it doesn't really make sense to call that most of the time
06:49:40 <quicksilver> parametric polymorphism, parametric data types, and higher order functions provide a very powerful toolkit.
06:49:44 <Snark> lilachaze, indeed
06:50:08 <quicksilver> Snark: You might have data Drawable = { draw :: IO (), getExtent :: IO Rect }
06:50:20 <quicksilver> Snark: then you might have a defaultDrawable with default "methods"
06:50:25 <Snark> quicksilver, perhaps I already asked the question here, but is there a "Big Guide to Haskell for dummy OO programmers" ? ;-)
06:50:53 <quicksilver> and you might have square = Drawable { draw = do { draw defaultDrawable; ... do some more stuff } }
06:50:59 <ivanm> there's a C programmers guide...
06:51:08 <quicksilver> Snark: no, because the issues are entangled.
06:51:09 <Snark> quicksilver, oh, what you describe would give me a different method for each piece of data!
06:51:15 <quicksilver> Snark: if you want, yes.
06:51:24 <quicksilver> Snark: it corresponds loosely to prototype objects
06:51:24 <Snark> ivanm, C and OO aren't exactly the same thing!
06:51:29 <quicksilver> e.g. javascript
06:51:51 <Snark> quicksilver, eh, perhaps I'll be able to push the only heterogeneous list I have out!
06:52:01 <quicksilver> the problem is class-based OO languages, especially Java, only have one abstraction.
06:52:04 <quicksilver> Class.
06:52:06 <quicksilver> that's the only tool you have.
06:52:11 <matthew-_> Snark: you could always use hpaste to paste big bits of code
06:52:17 <quicksilver> to java programmers *every* problem is expressible using classes.
06:52:27 <quicksilver> to find a good solution you want to unwind that slightly
06:52:39 <byorgey> except the ones that are too hard  ;)
06:52:41 <quicksilver> and recognise that actually there a few different abstractions that suit different kinds of modularity.
06:52:51 <And[y]> hi, i want to take a number like 123 and mirror it, so that my function returns 321 ... but i have no idea, how to do it :/
06:53:05 <Snark> oh yes, I think I'll be able to get rid of that heterogeneous list which looked hideous
06:53:07 <matthew-_> And[y]: that sounds like a homework question to me
06:53:10 <ivanm> Snark: I know, but it's the closest I could think of
06:53:18 <quicksilver> parametric data types, higher order functions, and (sparing) use of existential types provide quite a lot.
06:53:21 <Socrates> > (read :: Int) . reverse . show $ 123
06:53:22 <lambdabot>  Couldn't match expected type `Int'
06:53:23 <Snark> perhaps even get rid of a few artificial type classes
06:53:29 <And[y]> matthew-: you are just partially right ...
06:53:30 <Socrates> > (read :: Integer) . reverse . show $ 123
06:53:31 <lambdabot>  Couldn't match expected type `Integer'
06:53:34 <Socrates> Hmm.
06:53:40 <And[y]> its for a project :)
06:53:45 <Snark> ivanm, :-)
06:53:49 <quicksilver> > (read . reverse . show $ 123) :: Int
06:53:50 <lambdabot>  321
06:54:19 * Snark thinks hard
06:54:19 <ivanm> or you could unfold it, reverse the list then fold it again...
06:54:19 <Socrates> Ahh. Ye.
06:54:31 <quicksilver> Snark: yes, I often use explicit dictionaries instead of "artificial type classes"
06:54:33 <byorgey> read . reverse . show  turns the number into a String (a list of Chars), reverses that, then turns it back into a number.
06:54:38 <quicksilver> Snark: tehre is an example on hpaste somewhere
06:54:43 <Socrates> > (read :: String -> Int) . reverse . show $ 123
06:54:45 <lambdabot>  321
06:54:50 <byorgey> the key is to turn it into a list of digits that can be reversed.
06:54:55 <And[y]> thanks for the remarks so far :>
06:54:57 <byorgey> you could also implement the same thing mathematically.
06:55:10 <quicksilver> Snark: http://hpaste.org/3558
06:55:10 <lilachaze> > let m x y = if x < 10 then y * 10 + x else m (x `div` 10) (y * 10 + x `mod` 10) in m 123 0
06:55:11 <Snark> quicksilver, what do you mean by "explicit dictionaries" ?
06:55:12 <lambdabot>  321
06:55:14 <ddarius> Here's the short guide to Haskell for OO programmers: Haskell isn't at all an OO language.
06:55:20 <matthew-_> it's really like a non-boolean "not" function
06:55:21 <quicksilver> Snark: exactly what you are thinking about at this moment.
06:55:26 <quicksilver> Snark: passing a bundle of higher order functions.
06:55:28 <ivanm> ddarius: lol
06:55:30 <Snark> ah, yes
06:55:33 <quicksilver> dictionary = bundle of functions.
06:55:40 <ivanm> @remember ddarius Here's the short guide to Haskell for OO programmers: Haskell isn't at all an OO language.
06:55:41 <lambdabot> Done.
06:56:16 <quicksilver> Snark: there is http://www.haskell.org/haskellwiki/OOP_vs_type_classes
06:56:18 <lambdabot> Title: OOP vs type classes - HaskellWiki
06:56:21 <quicksilver> I'm not sure if that document is 100% reliable
06:56:23 <quicksilver> it's a wiki
06:56:26 <lilachaze> the longer guide would say that you can implement a lot of OO ideas in haskell (data abstraction, encapsulation, inheritance, interfaces, ...)
06:56:32 <quicksilver> and it's too long for me to read it through right now :)
06:56:59 <lilachaze> but that such things in haskell are a special case of more general facilities :)
07:05:27 <ddarius> lilachaze: You can't implement OO style inheritance or interfaces in a reasonable way in Haskell.  Data abstraction and encapsulation aren't OO ideas.
07:14:00 <chessguy> @pl f b a = h (d (l a - l b - 1) a))
07:14:01 <lambdabot> (line 1, column 32):
07:14:01 <lambdabot> unexpected ")"
07:14:01 <lambdabot> expecting variable, "(", operator or end of input
07:14:07 <chessguy> @pl f b a = h (d (l a - l b - 1) a)
07:14:07 <lambdabot> f = (h .) . join . (d .) . flip flip 1 . ((-) .) . flip ((-) . l) . l
07:15:51 <audreyt> @pl (<*>)<$>(<*>)
07:15:51 <lambdabot> (<*>) <$> (<*>)
07:18:07 <quicksilver> ddarius: sure you can implement inheritance in a reasonable way.
07:18:17 <quicksilver> I expect there are multiple reasonable ways.
07:25:22 <Saizan> quicksilver: can you sketch one?
07:31:50 <quicksilver> Saizan: I just did; store a record full of higher order functions
07:31:57 <quicksilver> Saizan: override some using record update syntax.
07:32:19 <quicksilver> possible to thread the "superclass" through to make it slightly neater.
07:35:21 <Saizan> quicksilver: a bit problematic to get it right for recursive methods, but i see, a kind of lightweight OOHaskell
07:36:08 <quicksilver> well a kind of 'pick and choose the bits you need' yes
07:51:44 <vincenz> @seen ndm
07:51:44 <lambdabot> I haven't seen ndm.
07:57:52 <sclv> I'm having some serious cabal-install woes
07:58:38 <sclv> I installed the latest cabal from hackage
07:59:03 <sclv> then tried the latest cabal-install and it tells me it can't satisfy the Cabal >= 1.4 dependency, even though it shows up just fine in ghc-pkg list
07:59:26 <sclv> I even unregistered the older Cabal just to be sure? This is on a fresh suse system using the ghc tree
08:01:44 <mauke> preflex: seen ndm
08:01:44 <preflex>  ndm was last seen on #haskell-blah 1 day, 5 hours, 51 minutes and 35 seconds ago, saying: apart from this one (http://www.bio-computing.org/showabstract.php?pmid=12122261) which 503's on the free text link
08:01:47 <lambdabot> Title: Quantification of the non-planarity of the human carotid bifurcation.
08:04:08 <Apocalisp> > "http://www.bio-computing.org/showabstract.php?pmid=12122261"
08:04:10 <lambdabot>  "http://www.bio-computing.org/showabstract.php?pmid=12122261"
08:04:10 <lambdabot> Title: Quantification of the non-planarity of the human carotid bifurcation.
08:04:54 * quicksilver wonders about an HTTP url whos title contains a valid URL
08:05:27 <mapreduce> @hoogle String -> Char -> String
08:05:27 <lambdabot> No matches, try a more general search
08:05:49 <vixey> :t (flip (:)) :: String -> Char -> String
08:05:53 <lambdabot> String -> Char -> String
08:06:44 <mapreduce> > (flip (:)) "hello" ',' == "h,e,l,l,o"
08:06:46 <lambdabot>  False
08:07:37 <mapreduce> What function would do that, or am I best off with a fold?
08:07:59 <vixey> :t intersperse
08:08:01 <lambdabot> forall a. a -> [a] -> [a]
08:08:15 <mapreduce> > intersperse ',' "hello"
08:08:16 <lambdabot>  "h,e,l,l,o"
08:08:28 <dcoutts_> sclv: so what are you doing exactly?
08:08:35 <mapreduce> Thanks.
08:08:44 <quicksilver> sobbing in a corner, I expect
08:09:04 <dcoutts_> sclv: doing runghc Setup.hs configure for cabal-install-0.5.0 ? and previously installed Cabal-1.4.0.0 with --user?
08:09:36 <dcoutts_> sclv: or are you using cabal-install to install the latest cabal-install?
08:09:57 <sclv> dcoutts -- fresh system, no cabal install yet
08:09:58 <sclv> I'
08:10:14 <dcoutts_> sclv: if you're using runghc Setup.hs, are you using the --user flag? it's not the default for the runghc Setup.hs interface
08:10:21 <sclv> erm. I'm doing runghc Setup.hs configure. I previously installed Cabal without user
08:10:28 <dcoutts_> sclv: oh, hmm
08:10:51 <dcoutts_> sclv: so when you say that ghc-pkg says it's there, what do you mean exactly? what is the output of ghc-pkg list Cabal ?
08:11:10 <dcoutts_> sclv: is Cabal-1.4.0.0 registered in the global or per-user package db?
08:11:49 <mapreduce> @hoogle a -> [a] -> [a]
08:11:50 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
08:11:50 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:11:50 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
08:12:26 <sclv> eh. heck with it. I think I might have hosed my install otherwise.
08:12:28 <mapreduce> How do scanl and scanr fit that?
08:12:45 <dcoutts_> sclv: hmm?
08:13:26 <int-e> @type scanl (+)
08:13:27 <sclv> two ghc 6.8.2 installs (standard and suse package) might be competing for the same space.
08:13:28 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
08:13:50 <dcoutts_> sclv: oh, you mean like one in /usr/bin and another in /usr/local/bin
08:14:17 <dcoutts_> sclv: they'll have separate package dbs but which one turns up on the $PATH first is anybody's guess, you can check with 'which'
08:14:19 <sclv> and maybe two package databases or something... its bizzare
08:14:28 <dcoutts_> sclv: and cabal configure -v will tell you which one it finds
08:15:55 <FordCortina> @src (++)
08:15:56 <lambdabot> []     ++ ys = ys
08:15:56 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:15:56 <lambdabot> -- OR
08:15:56 <lambdabot> xs ++ ys = foldr (:) ys xs
08:15:56 <lambdabot> -- In lambdabot, this is generalised to:
08:15:57 <lambdabot> (++) = mappend
08:16:14 <mapreduce> @src intersperse
08:16:15 <lambdabot> intersperse _   []     = []
08:16:15 <lambdabot> intersperse _   [x]    = [x]
08:16:15 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
08:16:25 <sclv> dcoutts_: thanks! I'm just going to try to clean everything out and start over.
08:16:46 <dcoutts_> sclv: 'k, let me know how it goes with cabal-install
08:20:39 <BMeph> mapreduce: scanl and scanr fit the signature, following the "first" argument.
08:21:02 <pejo> dcoutts, which might give the wrong answer if you're running bash and have different settings for [t]csh
08:21:39 <mapreduce> @check \st c -> intersperse c st == foldl (\x y -> [x, c, y]) (head st) (tail st)
08:21:39 <dcoutts_> pejo: aye, though cabal configure does it's own path searching and does not use any system shell
08:21:40 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]       Expected...
08:22:14 <Igloo> dcoutts_: Does Cabal use the Cabal file for anything other than configure (and copying it in sdist)?
08:23:20 <dcoutts_> Igloo: actually, I'd have to check whether it loads it from the file each time or uses the saved info in the local build info
08:23:22 <dcoutts_> Igloo: why?
08:23:29 <dcoutts_> why do you ask I mean
08:23:56 <ttt--> how come language with pattern matching only allow simple patterns, and not things like functions?
08:24:06 <Igloo> dcoutts_: I'm wondering if fiddling with what is written in dist/ is sufficient to build a package with a different name to what is in the Cabal file
08:24:19 <ttt--> is it too complex to build into the language or are there other problems?
08:24:23 <vixey> ttt--: To match on functions would mean calculating the inverse of any given function, that's really really hard
08:24:24 <Zao> ttt--: What about guards?
08:24:53 <dcoutts_> Igloo: might work, but sounds rather icky. The format is not stable.
08:24:53 <quicksilver> view patterns have been proposed as a haskell extension
08:24:53 <Igloo> dcoutts_: Although thinking about it, that doesn't help much. sdist is the difficult part, as you can't just copy the Cabal file somewhere else and put "../" in front of all the paths in it for sdist, but you probably can for everything else
08:24:59 <quicksilver> and some version at least has been implemented
08:25:07 <quicksilver> that allows pattern matching on arbitrary functions
08:25:09 <ttt--> is there a set of functions for which it is easy?
08:25:14 <vixey> ttt--: Another problem is you end up with relations instead of functions
08:25:19 <vixey> f (append x y) = y ++ x
08:25:27 <vixey> f "xyz" = "zxy"
08:25:31 <quicksilver> ttt--: yes, Constructors.
08:25:33 <vixey> f "xyz" = "yzx"
08:25:36 <vixey> and so on..
08:25:42 <quicksilver> ttt--: which is exactly why they're chosen :)
08:26:26 <vixey> ttt--: You can experiment with the classes of relations which are invertible in Prolog
08:26:42 <vixey> but you have left functional programming
08:29:40 <Igloo> dcoutts_: Do you think it would be cleaner to break sdist's internals up into "makeTree >>= tarTree", or to pass in a (TmpDir -> IO ()) to be run in the middle?
08:30:55 <dcoutts_> Igloo: sdist should be in two parts, one that decides what files will be installed and another part that installs a list of files. That would make it easier for us to redirect to a temp dir or to make a manifest of files we're installing etc.
08:30:58 <dons> woot! http://www.reddit.com/info/6nr0c/comments/
08:30:59 <lambdabot> Title: reddit.com: Haskell now has a parallel, multicore garbage collector!
08:31:09 <Igloo> Actually, the former should probably be done anyway
08:31:38 <dcoutts_> Igloo: what else would we want it for?
08:31:59 <JaffaCake> dons: ta :)
08:32:16 <dons> JaffaCake++
08:32:23 <Igloo> dcoutts_: Doing QA checks on what will go into an sdist without having to tar and untar, for example
08:32:30 * JaffaCake mods myself up
08:32:46 <quicksilver> JaffaCake++
08:32:49 <Igloo> dcoutts_: Without a good reason not to, I think Cabal should be split up into chunks as much as possible to make things that we haven't thought of possible
08:33:06 <dcoutts_> Igloo: oh I agree. I'm just wondering if you were thinking of anything specific.
08:33:28 <Igloo> Ah, no
08:33:32 <dcoutts_> Igloo: install certainly needs to be split apart. It's currently too easy to make mistakes.
08:33:55 <dcoutts_> I want to enforce more stuff, do less unrestricted IO
08:33:57 <Igloo> JaffaCake: - means stderr? Ug
08:34:49 <JaffaCake> Igloo: ok, want to suggest something else?
08:35:01 <matthew-_> 3
08:35:01 <Igloo> No, I'd just like to complain on IRC  :-)
08:35:08 <JaffaCake> I figured '-' means 'std'
08:35:25 <matthew-_> 1 is stdin, 2 is stdout so 3 is stderr ;)
08:35:42 <Igloo> Fair enough
08:35:54 <JaffaCake> well, I don't care that much, I just got tired of typing -sstderr
08:36:09 <JaffaCake> and +RTS -s is already taken
08:36:10 <dcoutts_> JaffaCake: then you want bash completion for +RTS :-)
08:36:21 * JaffaCake doesn't use bash
08:36:37 <Igloo> What does -s do?
08:36:45 <dcoutts_> well, all shells have some kind of completion, no?
08:36:50 <JaffaCake> puts the stats in <prog>.stat, or something
08:36:55 <vincenz> @seen ndm
08:36:55 <lambdabot> I haven't seen ndm.
08:37:06 <Igloo> Maybe that's the problem, then?
08:37:26 <Igloo> i.e. maybe -s should send to stderr unless given a filename to send to
08:38:06 <JaffaCake> Igloo: yeah, I wondered about that, but didn't want to break existing uses of +RTS -s
08:38:46 <JaffaCake> probably it doesn't matter much though - the only use I can think of is runstdtest, and we can fix that
08:39:27 <Igloo> *nod*, I'd certainly be in favour of changing it
08:39:35 <JaffaCake> righto, will do
08:40:28 <sclv> dcoutts_: fyi, nailing everything and starting clean did the trick.
08:40:59 <dcoutts_> sclv: great
08:47:42 <Igloo> Hmm, www.haskell.org is being a bit unresponsive
08:49:16 <dcoutts_> aye
08:49:27 <Dzlk> for me three.
08:49:35 <dcoutts_> my ssh sessions are going slowly
08:51:15 <vixey> @instances Monad
08:51:16 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:53:50 <chx> hi. i have a strange request. the php community is discussing adding lambda and closures to PHP. Anyone here with Haskell and PHP knowledge too could look at http://wiki.php.net/rfc/closures ?
08:53:50 <lambdabot> Title: PHP: rfc:closures [PHP Wiki]
08:54:35 <dons> chx, it might be worth soliciting some of the serious language design people on haskell-cafe@haskell.org ?
08:54:50 <dons> people like Simon Peyton Jones might even be available for comment.
08:54:55 <chx> is that an appropriate channel for this?
08:55:21 <quicksilver> You can certainly ask on -cafe
08:55:27 <quicksilver> Who knows who will respond :)
08:55:31 <quicksilver> someone might be interested.
08:55:48 <dons> IRC is ok, but you also have access to the experts on the subject by contacting key language people directly
08:56:11 <chx> thanks
08:57:44 <And[y]> hey, i asked for a solution to reverse a number ... and you all posted nice approaches ...
08:57:56 <And[y]> anyway, i guess i found an even shorter approach :)
08:57:58 <And[y]> revNum x = read (reverse (show x)) :: Int
08:58:28 <And[y]> just for those of you, who are interested, ofc ;)
08:58:51 <Socrates`> That's pretty much identicle to the solution posted earlier
08:59:36 <And[y]> ofc, you are right ... but this one is a function, actually, so i wanted to let you know :)
09:00:00 <Socrates`> @let reNum x = (read . reverse . show $ 123) :: Int
09:00:01 <lambdabot> Defined.
09:00:03 <Socrates`> reNum 123
09:00:10 <Socrates`> > reNum 123
09:00:12 <lambdabot>  321
09:00:31 <Syzygy|de> > raNum 1000
09:00:32 <lambdabot>   Not in scope: `raNum'
09:00:38 <Syzygy|de> > reNum 1000
09:00:39 <lambdabot>   Not in scope: `reNum'
09:00:40 <Socrates`> Oops.
09:00:48 <Socrates`> @let reNum x = (read . reverse . show $ x):: Int
09:00:49 <lambdabot> Defined.
09:00:55 <Socrates`> > reNum 1000
09:00:56 <lambdabot>  1
09:01:42 <And[y]> reNum 0123456789
09:02:18 <vixey> I would much rather call it reverseDigits
09:02:59 <And[y]> you probably could, but i'm no native english speaker ;)
09:03:05 <mm_freak_work> i don't like it, because it's not reversible
09:03:08 <Socrates> @undefine reNum
09:03:09 <lambdabot> Undefined.
09:03:13 <mm_freak_work> > reNum . reNum $ 1000
09:03:14 <lambdabot>   Not in scope: `reNum'
09:03:16 <Socrates> @let revNum = read . reverse . show
09:03:17 <lambdabot> <local>:1:9:     Ambiguous type variable `a' in the constraint:       `Read a...
09:03:20 <Socrates> @let revNum = read . reverse . show :: Int
09:03:21 <lambdabot> Couldn't match expected type `Int' against inferred type `a1 -> a'
09:03:28 <Socrates> @let revNum = (read . reverse . show) :: Int
09:03:28 <lambdabot> Couldn't match expected type `Int' against inferred type `a1 -> a'
09:03:31 <vixey> @undef
09:03:32 <lambdabot> Undefined.
09:03:39 <vixey> @let revNum = (read . reverse . show) :: Integer
09:03:40 <lambdabot> Couldn't match expected type `Integer'
09:03:42 <Syzygy|de> @let revNum = (read.reverse.show) :: Int -> Int
09:03:44 <lambdabot> Defined.
09:03:47 <Syzygy|de> > revNum 1000
09:03:48 <lambdabot>  1
09:03:52 <vixey> what's wrong with Integer?
09:03:55 <Syzygy|de> > revNum 012345
09:03:56 <lambdabot>  54321
09:03:58 <mm_freak_work> > revNum . revNum $ 1000
09:04:00 <Socrates> It's partial application
09:04:00 <lambdabot>  1
09:04:06 <Syzygy|de> vixey: Nothing is wrong with integer, but revNum is a -> a
09:04:07 <vixey> oh of course
09:04:28 <Syzygy|de> > revnum 5432100
09:04:28 <lambdabot>   Not in scope: `revnum'
09:04:32 <Syzygy|de> > revNum 5432100
09:04:34 <lambdabot>  12345
09:04:35 <Socrates> > 0001 == 1
09:04:36 <lambdabot>  True
09:04:57 <And[y]> > 663+3
09:04:58 <lambdabot>  666
09:05:00 <And[y]> =D
09:05:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8379
09:05:11 <vixey> > iterate (revNum.(*7).(+3)) 1
09:05:12 <lambdabot>  [1,82,595,6814,91774,934246,3479356,31555342,514788022,Exception: Prelude.re...
09:06:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8380
09:06:19 <And[y]> the thing about dropping the 0's is the only problem i still have with this function
09:06:37 <vixey> just use strings instead of integers then
09:06:43 <vixey> > reverse "0231531"
09:06:45 <lambdabot>  "1351320"
09:06:58 <BMeph> > reverse . digify $ 7342521
09:06:59 <lambdabot>  "1252437"
09:07:13 <Socrates> @src digify
09:07:13 <lambdabot> Source not found. I am sorry.
09:07:55 <And[y]> > digify 123
09:07:56 <lambdabot>  "123"
09:08:18 <Syzygy|de> @quick \n -> digify n == show n
09:08:18 <lambdabot> Not enough privileges
09:08:24 <Syzygy|de> o.O
09:08:30 <Syzygy|de> @check \n -> digify n == show n
09:08:32 <lambdabot>  Exception: Numeric.showInt: can't show negative numbers
09:08:44 <hpaste>  Munch pasted "xmonad.hs" at http://hpaste.org/8381
09:08:55 <Socrates> > digify "abc"
09:08:55 <lambdabot>   add an instance declaration for (Integral [Char])
09:08:56 <lambdabot>     In the expression: di...
09:09:21 <hpaste>  Munch pasted "xmonad.hs" at http://hpaste.org/8382
09:10:15 <mm_freak_work> @let revNum' l n = foldl (\x y -> 10*x + y) 0 $ tail $ take (l+1) $ map snd $ iterate (\(x,d) -> divMod x 10) (n,0)
09:10:15 <lambdabot> Defined.
09:10:28 <mm_freak_work> > revNum' 10 12345
09:10:29 <lambdabot>  5432100000
09:10:41 <mm_freak_work> > revNum' 10 . revNum' 10 $ 12345
09:10:42 <lambdabot>  12345
09:11:43 <olsner> @pl \f g h x -> f (g (h x))
09:11:44 <lambdabot> (. (.)) . (.) . (.)
09:13:01 <ziman> cool :)
09:13:30 <ziman> > (. (.)) . (.) . (.) (+1) (*2) (-1) 3
09:13:31 <lambdabot>        add an instance declaration for (Num (t -> f (f1 b -> b1)))
09:13:40 <ziman> > ((. (.)) . (.) . (.)) (+1) (*2) (-1) 3
09:13:41 <lambdabot>   add an instance declaration for (Num (t -> a))
09:14:39 <Deewiant> @unpl (. (.)) . (.) . (.)
09:14:40 <lambdabot> (\ m s g j -> m (s (g j)))
09:15:34 <Deewiant> > (+1) ((*2) ((-1) 3))
09:15:35 <lambdabot>   add an instance declaration for (Num (t -> a))
09:15:42 <Deewiant> ah, of course
09:15:59 <Deewiant> > ((. (.)) . (.) . (.)) (+1) (*2) (subtract 1) 3
09:16:00 <lambdabot>  5
09:17:54 <vixey> @src Monad
09:17:54 <lambdabot> class  Monad m  where
09:17:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:17:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:17:54 <lambdabot>     return      :: a -> m a
09:17:54 <lambdabot>     fail        :: String -> m a
09:18:08 <vixey> why is >> in there?
09:18:32 <Deewiant> the more important question is why is fail in there ;-)
09:18:37 <byorgey> vixey: good question.  probably because it's needed for do-desugaring?
09:18:53 <Deewiant> @src [] (>>)
09:18:53 <lambdabot> xs >> ys      = concatMap (const xs) ys
09:18:54 <quicksilver> just in case it happens to be more efficient to implement it directly
09:18:56 <quicksilver> I believe
09:18:58 <Deewiant> @src Maybe (>>)
09:18:58 <lambdabot> (Just _) >>  k      = k
09:18:58 <lambdabot> Nothing  >>  _      = Nothing
09:19:14 <HunterXHunter> ?type Nothing
09:19:14 <And[y]> @src length
09:19:16 <lambdabot> forall a. Maybe a
09:19:16 <lambdabot> Source not found. I feel much better now.
09:20:08 <olsner> > ((.) (. (.)) ((.) . (.))) (+1) (*2) (subtract 1) 3
09:20:09 <lambdabot>  5
09:20:16 <And[y]> i tried to modify mm_freak_work's version to use length of n, instead of l ... but i had no luck so far :/
09:20:36 <matthew-_> Does the final comment in http://hackage.haskell.org/trac/ghc/ticket/1537
09:20:37 <lambdabot> Title: #1537 (do notation translation) - GHC - Trac
09:20:50 <matthew-_> mean that it's going to be in 6.8.3 or being left to 6.10 ?
09:21:04 <olsner> > ((.) (flip (.) (.)) ((.) (.) (.))) (+1) (*2) (subtract 1) 3
09:21:05 <lambdabot>  5
09:21:29 <Deewiant> matthew-_: sounds like the latter to me
09:23:36 <And[y]> > show ['>',' ','6','6','3','+','3']
09:23:37 <lambdabot>  "\"> 663+3\""
09:23:46 <olsner> ah, yes, finally beating python into submission... it just needed some more lambda
09:23:48 <Deewiant> > fix show
09:23:49 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:25:05 <sandbox> I can't get plugins to compile.  My Distribution.Package never exports the right symbol set.  Am I just stupid?
09:25:38 <sandbox> Right now I have parsePackageId, parsePackageName, showPackageId.
09:25:56 <sandbox> ghc 6.8.2
09:25:58 <olsner> unfortunately, you end up with a *lot* of parantheses ... python syntax for function application is always f(x) rather than f x
09:29:00 <byorgey> sandbox: Distribution.Package is from the Cabal library.  what version(s) of Cabal do you have installed?
09:29:55 <And[y]> > read show ['>',' ','6','6','3','+','3']
09:29:56 <lambdabot>  Couldn't match expected type `String'
09:30:02 <dcoutts_> sandbox: sounds like it needs Cabal-1.2.x, and would break with 1.3.x or later.
09:30:20 <sandbox> Right now whatever comes with ghc, but I've also tried my distros packages for 1.2.3.0 and 1.2.2.0
09:30:23 <sandbox> I'm on gentoo
09:30:45 <sandbox> okay, I'll try that out, is there something I need to modify to get it to use a different version of cabal?
09:30:50 <sandbox> Not too familiar with the build stuff
09:31:00 <dcoutts_> sandbox: you can tighten the version range in the plugins.cabal to be build-depends: Cabal >= 1.2 && < 1.3
09:31:13 <sandbox> I'll try that out, thanks
09:31:15 <dcoutts_> sandbox: but if you say you've only got 1.2.x versions installed anyway then it'll not help.
09:31:48 <dcoutts_> sandbox: my suggestion is only relevant if you also have >=1.3 versions that are getting in the way
09:32:29 <sandbox> doesn't ghc come with some version of cabal?
09:32:44 <dcoutts_> sandbox: ghc-6.8.2 comes with 1.2.3.0
09:32:44 <sandbox> or have it embedded I guess
09:32:57 <dcoutts_> sandbox: use ghc-pkg list Cabal to find out
09:33:16 <sandbox> 1.2.3.0
09:33:29 <sandbox> suggest I try an older version?
09:34:19 <dcoutts_> sandbox: so where are you getting this plugins package from? from gentoo? which version?
09:34:31 <sandbox> hackage, 1.2
09:35:11 <vixey> @src (>>=) Maybe
09:35:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:35:14 <dcoutts_> sandbox: ok, that's apparently busted and no new one has been uploaded.
09:35:30 <dcoutts_> sandbox: I think you'll need the darcs version or find a way of not using plugins.
09:35:41 <sandbox> okay, thanks
09:35:46 <wjt> @src Maybe (>>=)
09:35:46 <lambdabot> (Just x) >>= k      = k x
09:35:46 <lambdabot> Nothing  >>= _      = Nothing
09:52:31 <sandbox> got plugins 1.2 to build, should I put up the patches so other people can test it?
10:00:15 <quicksilver> sandbox: at least a summary of your solution to haskell-cafe would be appreciated.
10:03:41 * byorgey is confused as to how PHP can be anyone's favorite language
10:04:21 <smtms> if someone knows only PHP, I bet it will be his favourite programming language
10:04:30 <Dzlk> The only other one they know is COBOL?
10:05:37 <byorgey> yes, both those situations seem plausible
10:05:42 <byorgey> thank you for clarifying =)
10:07:12 <BMeph> Dzlk: Not nice; COBOL is an excellent language - for lit-majored business folks. ;p
10:07:51 <byorgey> LAMBDA FUNCTION WITH PARAMETER X RETURNING X
10:09:03 <BMeph> PROCEDURE SECTION. LAMBDA SUB-SECTION.
10:09:29 <roconnor> @bab nl en hoogle
10:09:30 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
10:09:36 * BMeph likes COBOL humor
10:09:53 <Dzlk> I really think someone should have come out with an object-oriented extension called ADD ONE TO COBOL GIVING COBOL.
10:10:05 <roconnor> ah
10:10:12 <roconnor> hoogle means professor
10:10:21 <roconnor> does ndm know this?
10:10:41 <Saul_> I've just written out an identity function for my type because I needed the type to change (but not the content, which isn't based on the type), is there a better way to do something like that?
10:11:36 <Saul_> data Bloeb a = Bloeb Int; convert :: Bloeb a -> Bloeb b; convert (Bloeb x) = Bloeb x
10:11:41 <Saul_> something like this
10:11:49 <Saul_> only my actual type is more complex
10:12:46 <Saul_> roconnor: I think that's hoogleraar
10:13:10 <lilachaze> Saul_: perhaps you could do something like: data Bloeb a = Bloeb BloebData; data BloebData = BloebData Int; then internally operate directly on BloebData
10:13:12 <Deewiant> Saul_: so, why have the type parameter?
10:13:31 <lilachaze> i'm guessing you don't expose convert, given that it negates any type-safety your type parameter would give
10:13:36 <Jaak> @type unsafeCoerce
10:13:37 <byorgey> Saul_: I've done things like that when dealing with phantom types before, too
10:13:44 <lambdabot> Not in scope: `unsafeCoerce'
10:14:11 <Saul_> Deewiant: I have it because I need to force the proper type later on
10:15:20 <Saul_> Jaak: Thanks, I think that one will do fine
10:15:23 <edward1> saul: i've had to do that for explicitly coercing phantom type parameters before its not so scary
10:15:47 <edward1> saul: if you have a newtype the convert should be free even without unsafeCoerce
10:16:24 <Saul_> edward1: It's not though, which is too bad
10:16:42 <edwardk> then unsafeCoerce is your friend ;)
10:18:08 <Saul_> ok thanks guys
10:20:54 <hpaste>  lostson pasted "no XMonad" at http://hpaste.org/8383
10:21:04 <mmorrow> @src enumFromTo :: Int -> Int -> [Int]
10:21:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:21:26 <mmorrow> @src foldl
10:21:26 <lambdabot> foldl f z []     = z
10:21:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:21:28 <mmorrow> @src foldr
10:21:28 <lambdabot> foldr f z []     = z
10:21:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:21:31 <mmorrow> @src zipWith
10:21:31 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:21:31 <lambdabot> zipWith _ _      _      = []
10:23:53 <roconnor> Saul_: hmm, you could be right
10:27:02 <mar77a> @src putStrLn
10:27:03 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
10:27:13 <mar77a> @src putStr
10:27:13 <lambdabot> putStr s  = hPutStr stdout s
10:27:20 <mar77a> @src hPutStr
10:27:20 <lambdabot> Source not found. That's something I cannot allow to happen.
10:31:34 <And[y]> @src reverseDigits
10:31:34 <lambdabot> Source not found. You untyped fool!
10:32:54 <And[y]> @src reverse
10:32:54 <lambdabot> reverse = foldl (flip (:)) []
10:37:01 <And[y]> @src length
10:37:01 <lambdabot> Source not found. My mind is going. I can feel it.
10:37:52 <mar77a> length [] = 0; length [x] = 1; length (x:xs) = length x + length xs
10:37:54 <mar77a> i wonder if that works
10:37:55 <And[y]> hmm ... how can i calculate the number of digits of a number? :/
10:37:56 <Deewiant> length = foldr (const (+1)) 0
10:38:09 <mar77a> And[y]: length . show?
10:38:19 <And[y]> i will give that a try, thx :)
10:38:21 <Deewiant> mar77a: length (x:xs) = length [x] + length xs would work
10:38:30 <Deewiant> as you typed it, it's a type error
10:38:40 <mar77a> ah
10:38:42 <mar77a> yeah
10:38:54 <Deewiant> but simpler is, of course, length [] = 0; length (x:xs) = 1 + length xs
10:39:02 <mar77a> right
10:39:03 <Deewiant> which leads to the foldr above
10:39:12 <mar77a> but code wise it's the same, right?
10:39:19 <Deewiant> codewise?
10:39:27 <mar77a> machine code
10:39:43 <Deewiant> probably not actually
10:40:10 <Deewiant> yours has three cases: [], [x], (x:xs), whereas the simpler has only two
10:40:25 <Deewiant> the definitions for [] and (x:xs) will probably be compiled to the same code
10:40:34 <Deewiant> but yours will still have the extra check for [x]
10:40:45 <And[y]> revNum x = revNum2 x (length ( show x))
10:40:45 <Deewiant> or then not, I don't know what the optimizer does with such.
10:40:45 <And[y]> revNum2 n l = foldl (\x y -> 10*x + y) 0 $ tail $ take (l+1) $ map snd $ iterate (\(x,d) -> divMod x 10) (n,0)
10:40:56 <And[y]> its still missing the 0's :/
10:41:15 <And[y]> revNum 0321 -> 123
10:41:19 <And[y]> -.-
10:42:18 <And[y]> if i take this: revNum x = revNum2 x (length ( show x)) ... and make it to revNum x = revNum2 x (length ( show x) +1)
10:42:38 <And[y]> it atleast works for one ZERO ...  but if theres more than one, its still the same problem
10:43:02 <lilachaze> revNum 0321 is never going to do anything different from revNum 321, since you can't distinguish 0321 from 321 in any built-in Num instance
10:43:14 <Deewiant> > 0321
10:43:15 <lambdabot>  321
10:43:19 <Deewiant> > 0o321
10:43:20 <lambdabot>  209
10:43:37 <czakey> > 0x3ab
10:43:39 <lambdabot>  939
10:43:43 <lilachaze> @instances Num
10:43:43 <lambdabot> Double, Float, Int, Integer
10:43:45 <And[y]> > 0xdeadbeef
10:43:46 <lambdabot>  3735928559
10:43:58 <lilachaze> > (0321::Double, 0321::Float, 0321::Int, 0321::Integer)
10:43:59 <lambdabot>  (321.0,321.0,321,321)
10:44:08 <And[y]> okay, so i guess this won't be a problem then :>
10:44:24 <lilachaze> And[y]: depends what you're trying to do
10:44:41 <lilachaze> if you want a self-inverse revNum, it can't be Int -> Int
10:45:06 <And[y]> oh, i don't really need it self-inverse
10:45:25 <And[y]> but i can't tell you exactly, what i need this stuff for, as it is kind of complicated
10:45:32 <lilachaze> it's ok if revNum 3210 and revNum 321 are both 123?
10:45:52 <And[y]> yeah, it should be
10:46:13 <And[y]> the whole sence of this is to do some easy calculations and find some palindroms
10:46:33 <And[y]> i will show you, when i've finished it :)
10:46:45 <And[y]> but that probably won't be before thursday i guess :D
10:47:25 <And[y]> thanks for all of your support, so far, you really kick some butts ;)
10:53:01 <int-e> And[y]: was  read . reverse . show  too slow?
10:53:13 <ahunter_> gah, unless I'm mistaken, some recent patches to HEAD mean you need ghc 6.8 or so to successfully build GHC :(
10:53:14 <nus> ?t (.).(.)
10:53:14 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:53:49 <nus> @type (.).(.)
10:53:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:54:00 <nus> @type (.)(.)(.)
10:54:01 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:55:17 <nus> :t (.)(.)(.)
10:55:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:55:48 <nus> hrrm, my local lambdabot copy misbehaves :-(
10:56:07 <Deewiant> :t (.)(Prelude..)(Prelude..)
10:56:08 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:56:36 <nus> lambdabot> @type Just x
10:56:39 <nus> Plugin `type' failed with: invalid ghci output: no type signature
10:57:08 <mrd> wouldn't be a type sig, x is free
10:58:14 <nus> lambdabot> @type Nothing
10:58:14 <nus> forall a. Maybe a
10:58:15 <nus> Plugin/Type.hs -- a hairy regex fails, it seems
11:00:02 * jadrian just took 5 min to realise he had written "date" instead of "data"
11:00:23 <nus> Plugin/Type.hs' extract_signatures is broken
11:01:48 <dbelange> Does anyone know any category theory?
11:01:52 <nus> @version
11:01:52 <lambdabot> lambdabot 4p664, GHC 6.8.2 (Linux i686 2.40GHz)
11:01:52 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:03:06 <jadrian> dbelange: a bit
11:03:17 <jadrian> dbelange: less than I wish I did...
11:03:34 <jadrian> dbelange: but plenty of people here do
11:04:47 <byorgey> dbelange: do you have a CT-related question?
11:05:36 <nus> mrd, yep, just an example, :t (.).(.) fails here too
11:06:20 <jadrian> I think he was really just wondering if Haskell people know CT
11:06:38 <jadrian> probably a survey
11:07:13 <ahunter_> damn those advanced math surveys
11:07:29 <ahunter_> I'm so sick of getting phone calls during dinner about my ability to solve PDEs
11:08:13 <bos> it only gets worse once you learn bayesian statistics.
11:08:22 <bos> people calling you all the time, questioning your choice of priors.
11:08:44 <vixey> ?check \f g list -> map g (concat (map f list)) == map (concat . map (g . f)) list
11:08:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]       Expected...
11:09:22 <vixey> ?check \f g list -> map g (concat (map f list)) == map (\x -> concat (map (g (f x)))) list
11:09:23 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]     Probable c...
11:09:31 <roconnor> does your choice of priors matter?
11:09:37 <vixey> ?check \f g list -> map g (concat (map f list)) == map (\x -> concat (map g (f x))) list
11:09:38 <lambdabot>  Add a type signature
11:09:44 <bos> @seen dons
11:09:45 <lambdabot> dons is in #arch-haskell, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 19m 33s ago.
11:10:09 <gwern> bos: oh, I don't question your choice of priors. I know we can reach agreement over them :)
11:10:56 <gwern> roconnor: not if you're rational. Aumann's no-disagreement theorems and all that
11:11:30 <dons> bos?
11:11:45 * byorgey would be more worried about his choice of prions
11:11:55 <dons> byorgey: how's the HWN? settled in?
11:11:56 <bos> dons: do you have any idea what the excessive boxing in STUArray was, to which dan doel was referring?
11:12:30 <dons> well, i found the odd function here and there would end up with boxed Int arguments. these would go away with enough inlining
11:12:43 <dons> but fiddling around inside the arrays , i couldn't spot why.
11:12:50 <byorgey> dons: it's good, I'm still fiddling, automating, and so on... I wouldn't say I'm "settled in" yet =)
11:12:54 <dons> uvector didn't have this problem. so likely an unpack/strictness issue somewhere
11:12:58 <bos> hmm.
11:13:21 <dons> STUArray suffers from a bit more complexity than uvector
11:13:22 <roconnor> gwern: http://www.overcomingbias.com/2007/01/fair_betting_od.html makes me wonder about those theorems
11:13:22 <lambdabot> Title: Overcoming Bias: Fair betting odds and Prediction Market prices
11:13:30 <dons> being parameterised by the indices means there's yet more things to specialise on
11:13:35 <bos> yes.
11:13:38 <roconnor> gwern: but I haven't fully understood that article
11:13:47 <bos> i wonder who actually takes advantage of that capability.
11:13:58 <dons> good question
11:14:04 <dons> instances for pairs?
11:14:14 <bos> it's presumably useful for n-dimensional matrices, but at a cost.
11:14:31 <bos> having all of your array indices boxed and lazy just isn't good for your computational health.
11:14:49 <gwern> roconnor: well, obiously one of the axioms (...rationality...) is violated in general. you have to have *two* rational parties to be sure to reach agreement, iirc one irrational and one rational means the rational one can partially update based on the irrational one, but certainly she need not match
11:15:40 <gwern> 'The discussion about "agreeing to disagree" assumes ideal bayesians, and the preferred resolution requires that the disputants are willing to spend the time to reach agreement.' <-- the theorem's integrity depends on being ideal bayesians, in other words
11:16:30 <bos> does ghci accept an environment variable for its search path?
11:16:33 <roconnor> gwern: perhaps the solution is that prediction market of ideal bayesians would never make any trades
11:16:36 <bos> it seems not.
11:16:58 <roconnor> gwern: they would settle on the geometric mean of their original odds, and then not bet.
11:17:35 <gwern> roconnor: entirely possible. I believe there are a number of no-trade theorems in economics where in an efficient market, only a fool or someone with inside/non-public information should be willing to make or accept an offer
11:17:42 <vixey> @check map g (concat (map f y)) = map (\x  -> concat . map g) (map f y)
11:17:42 <lambdabot>  Parse error at "=" (column 26)
11:17:53 <roconnor> gwern: ha, no trade theorems
11:18:27 <lament> no free trade theorems?
11:18:54 <MyCatVerbs> See: casinos. There are an awful lot of fools in the world.
11:18:56 <gwern> what? they are serious theorem; this are serious discussion...
11:19:12 <gwern> no free lunch theorems...
11:19:13 <MyCatVerbs> gwern: and I are serious catverbs.
11:19:14 <pgavin> @seen dcoutts
11:19:14 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 9h 53m 59s ago.
11:20:10 <gwern> of course, bets are nice in that you can limit them to resolvable ones, ie. how do irrational folks settle 'is communism a bad idea?' as opposed to 'will there be fewer communist countries in 2000CE than now?' or 'will obama be president?'
11:20:47 <gwern> incidentally, I dunno how the prediction markets can justify odds of ~36% for mccain. that's madness
11:20:55 <cjb> gwern: too low?
11:20:59 <cjb> yeah, it seems odd
11:21:01 <bos> too high.
11:21:03 <pgavin> cjb: too high :)
11:21:04 <cjb> hah
11:21:46 <cjb> my wife wants to take that bet :)
11:21:51 <cjb> she doesn't think McCain will win
11:22:00 <cjb> but she thinks it'll increase substantially before the election
11:22:07 <lament> does anyone think he'll win?
11:22:15 <pgavin> lament: my dad?
11:22:24 <gwern> way too low. historically, when was the last time a republican candidate had that low a chance to win?
11:22:34 <gwern> remember, this is the part which re-elected GWB, and has more presidents than the democrats. and the gap between two candidates *always* tightens as the election comes up
11:22:40 <cjb> lament: the national polls give Obama a ~10% lead when asked "Who do you think will win?"
11:22:46 <lament> not much
11:22:50 <cjb> (as opposed to "Who do you want to win?")
11:22:58 <lament> what about who do you want to win?
11:23:07 <lament> what's the lead like?
11:23:11 <cjb> currently 47-42
11:23:14 <cjb> Obama
11:23:21 <cjb> was tied until the last two weeks
11:23:22 <roconnor> gwern: I see 40% on the IEM.
11:23:28 <Peaker> I think McCain sucks, but I want him to win so that Iran's nuclear ambitions are stopped..
11:23:30 <roconnor> well 40% for republican
11:23:40 <roconnor> McCain will be slightly lower
11:23:40 <gwern> lament: I think the true odds are currently more like 47-53 in favor of Obama, but 36-64 is massively overly optimistic
11:23:45 <cjb> Peaker: you don't think Obama wants to stop Iran's nuclear ambitions?
11:23:47 <pgavin> cjb: plus (stupid) people tend to vote for who they *think* will win, not who they *want* to win
11:23:49 <gwern> oh, I want Obama to win, absoltely. but I don't let that fool me into thinking he's that secure
11:23:52 <roconnor> he might die of old age before winning the nomination.
11:24:13 <Peaker> cjb, I think he puts it as a lower priority and dares not to risk another Iraq
11:24:26 <pgavin> at least he's willing to negotiate
11:24:32 <pgavin> and not ignore the whole mess
11:24:39 <gwern> roconnor: except I've pulled my earnings out of IEM. this flood thing is really unfortunately timed
11:24:50 <cjb> Peaker: I don't have any evidence for him placing less priority on stopping nukes.  I agree with him about not wanting to invade another country for no good reason.
11:25:01 <Peaker> Iran is so close to a nuclear weapon that "negotiation" may stall everyone enough for them to go past the "no return" point
11:25:15 <cjb> Peaker: [citation needed]
11:25:17 <roconnor> gwern: why did you pull out your money?
11:25:26 <pgavin> on topic: anyone have any advice for tracking down a space leak?
11:25:36 <roconnor> or rather why is the flood worrysome
11:25:42 <gwern> willing to negotiate... like Bush was willing to try all diplomatic options before the last reosrt of invasion, I suppose
11:26:04 <pgavin> gwern: hope you're being sarcastic :)
11:26:09 <bos> this obamamccainia is awesome, and all, but it belongs on #haskell-blah.
11:26:14 * roconnor mangaged to turn $5 into $50 over the last year on the IEM.
11:26:15 <Peaker> cjb, one example: http://www.jpost.com/servlet/Satellite?cid=1209627027461&pagename=JPost%2FJPArticle%2FShowFull
11:26:17 <lambdabot> Title: Israel: Iran could have nukes by '09 | Jerusalem Post, http://tinyurl.com/56roqo
11:26:23 <bos> so.
11:26:26 <bos> please.
11:26:32 <Peaker> ok
11:26:32 <paolino> stop
11:26:33 <gwern> roconnor: too small markets. I wanted to try intrade
11:26:50 <gwern> roconnor: oh, well if everyone is fighting/fleeing the flood, who's going to cut my check and send it?
11:26:52 <roconnor> gwern: oh, so it isn't flood related.
11:27:06 <bos> pgavin: compile with -prof -auto-all, run with -P
11:27:18 <pgavin> bos: been there, done that
11:27:20 <roconnor> gwern: you think university of Iowa will go under ... literally?
11:27:22 <lament> Peaker: How would McCain stop their nuclear ambitions?
11:27:30 <bos> lament: please
11:27:37 <cjb> Peaker: Sure.  And the US said that Iraq had WMDs.  And they were lying.
11:27:39 <pgavin> bos: I've isolated it down to a small function that doesn't look like it should be allocating any thunks
11:27:42 <monochrom> Hai. Whutz da best wayz to rulez da wurld in Haskell?
11:27:45 <lament> oh, sorry
11:27:46 <roconnor> gwern: I assume they will dry out eventually and then you would get your cheques.
11:27:56 <roconnor> gwern: although I haven't been paying attention to the news
11:28:18 <mmorrow> monochrom: unsafePerformIO unsafeFireMissiles?
11:28:24 <Peaker> cjb, can you come to #haskell-blah?
11:28:26 <bos> pgavin: have you tried retainer profiling?
11:28:27 <gwern> roconnor: nice. I managed to turn 10$ in 38$, but it took me 4 years. (I sent in 20$, lost 5 to the fee or whatever, and then lost another 5 dollars to Kerry despite all I had made in successful interest rate bets)
11:28:38 <dcoutts> pgavin: I'm a bit busy atm, check in with me later or tomorrow
11:28:43 <gwern> roconnor: dude, it *is* under. they've already lost the art museum
11:28:50 <monochrom> I heard launchMissiles :: STM () is safer. :)
11:28:53 <roconnor> :(
11:28:59 <cjb> Peaker: Now that you point it out, I should go back to work instead.  :)
11:29:07 <pgavin> bos: in fact, the function that the leak is showing up just calls another one immediately, but the leak isn't showing up in those functions
11:29:20 <pgavin> dcoutts: np :)
11:29:27 <bos> pgavin: ^^^
11:29:34 <mmorrow> monochrom: unsafePerformIO . atomically $ unsafeFireMissiles
11:29:34 <pgavin> bos: what's that?
11:29:37 <gwern> roconnor: I mean literally, not metaphorically as in 'fail to be a viable enterprise' :)
11:29:48 <bos> pgavin: it's "did you see what i just wrote?"  :-)
11:29:58 <mmorrow> monochrom: oops, i meant: unsafePerformIO . atomically $ launchMissiles
11:29:59 <monochrom> w00t, so it's unsafe??!!!
11:30:01 <roconnor> gwern: If you count the fee, then I've turned $10 into $50
11:30:06 <pgavin> bos: I mean, what's retainer profiling :)
11:30:23 <bos> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#retainer-prof
11:30:29 <lambdabot> Title: 6.4. Profiling memory usage, http://tinyurl.com/ycro5f
11:30:48 <gwern> roconnor: incidentally, re that Overcoming Bias post - I agree that prediction markets are all badly distorted in the extremes. recent politics shows that IEM and intrade can't be trusted on low-probability candidates
11:30:49 <bos> pgavin: you can't completely rely on -P to give you useful information about space leaks.
11:30:51 <roconnor> gwern: let me know how intrade works out.  Their transaction fees scare me a tiny bit.
11:31:13 <gwern> roconnor: hm. what bets did you make to get 500%?
11:31:19 <pgavin> bos: cool, thanks, I'll try that
11:31:34 <roconnor> gwern: are you subscribed directly or indirectly to my blog?
11:32:33 <gwern> roconnor: ah, neither AFAIK unless it comes down through planet haskell?
11:32:48 <roconnor> gwern: it is on planet haskell
11:33:14 <roconnor> gwern: I'll post by money making secrets after the election in november.
11:33:21 <roconnor> :)
11:33:31 <jadrian> hmm I forgot all the details about named records :S
11:33:41 <roconnor> gwern: Hint, I use Haskell :P
11:33:44 <mar77a> > 33 - 9
11:33:46 <pgavin> bos: lol, that gives me a segfault
11:33:47 <lambdabot>  24
11:33:53 <jadrian> can you do pattern mathing with named records?
11:33:53 <bos> pgavin: erk
11:33:54 <jadrian> that is
11:34:00 <bos> jadrian: yes
11:34:01 <jadrian> I can do
11:34:05 <jadrian> (x:xs, [])
11:34:14 <gwern> curses! and I would've gotten away with it if it weren't for you meddling kids!
11:34:37 <jadrian> how do you write this if   Pair = P { a :: [Int] , b :: [Int] }
11:34:42 <jadrian> ?
11:34:42 <pgavin> bos: but it's a long running simulation, and it segfaults after about 30 seconds.  I can run it for a shorter time, and see if it finishes before it crashes again
11:35:08 <bos> pgavin: is it a parallel program, by any chance?
11:35:08 <byorgey> jadrian: you can do something like  P { a = foo, b = bar }
11:35:18 <pgavin> bos: no, single threaded
11:35:19 <jadrian> so
11:35:22 <bos> pgavin: wow.
11:35:25 <byorgey> jadrian: where 'foo' and 'bar' are patterns to match against the values of a and b
11:35:31 <monochrom> I like scrolling.
11:35:32 <jadrian> byorgey: ok thanks
11:35:33 <pgavin> bos: yeah :)
11:35:36 <jadrian> let me try that
11:35:36 <monochrom> scrolling away
11:35:37 <bos> segfaults in single threaded haskell code are thankfully rare.
11:35:56 <roconnor> gwern: have you signed up for intrade?
11:35:56 <monochrom> non-atomic questions
11:36:05 <pgavin> bos: I have to use ghc-6.9 because I'm using type families, that may be why
11:36:13 <gwern> roconnor: do you have any posts on prediction markets worth looking up?
11:36:31 <bos> pgavin: oh. living dangerously, then.
11:36:35 <gwern> roconnor: not yet. I was waiting for mah money to arrive
11:36:45 <pgavin> bos: it's more fun that way :)
11:36:59 <roconnor> gwern: http://r6.ca/blog/tag/prediction-market.html
11:36:59 <lambdabot> Title: prediction market
11:37:15 <bos> crappopotamus.
11:37:21 <roconnor> gwern: I'd be intrested in knowing how easy it is to sign up.  Let me know how it goes.
11:37:49 <gwern> thnks
11:37:52 <roconnor> gwern: the posts largely consist of me losing money (both real and fake) on various markets.
11:37:59 <gwern> sure, although I hear it more or less comes down to what banks/credit processors you happen to use
11:38:13 <pgavin> bos: retainer profiling isn't giving me any useful information
11:38:34 <roconnor> gwern: oh, what are you planning to use?
11:38:40 <pgavin> bos: all I see in the .prof file is: Retainer Profiling: 0, at 0.157062 seconds
11:38:40 <pgavin>         Average number of visits per object = 8.794890
11:38:41 <bos> pgavin: pardon me while i swear at ghci myself.
11:38:49 <pgavin> bos: lol :)
11:38:56 <bos> pgavin: got a code snippet or something that we can eyeball?
11:39:07 <roconnor> gwern: http://r6.ca/blog/20030915T024000Z.html <-- has gotten a lot of hits from google in the last few months.
11:39:08 <lambdabot> Title: Hilary Clinton Chances to Win the Democratic Nomination
11:39:31 * gwern is teh reading
11:39:54 <vixey> what's the e->_ monad called?
11:39:55 <gwern> roconnor: I'll probably try debit gatewayed through visa
11:39:59 <bos> vixey: reader
11:40:10 <gwern> else maybe a check, I suppose
11:40:19 <gwern> roconnor: ...why is a three sentence blog post so popular?
11:40:22 <vixey> thanks
11:40:39 <bos> vixey: usually written (->) e
11:40:49 <roconnor> gwern: well, it is relatively popular, compared to my other blog posts :P
11:41:04 <roconnor> > foldr shapl
11:41:05 <lambdabot>   Not in scope: `shapl'
11:41:09 <gwern> (although I suppose a 10% was reasonable if not under-priced in 2003)
11:41:16 <roconnor> > foldl shapr
11:41:16 <lambdabot>   Not in scope: `shapr'
11:41:49 <vixey> @src (>>=) ((->)e
11:41:50 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:41:51 <vixey> @src (>>=) ((->)e)
11:41:51 <lambdabot> Source not found. My mind is going. I can feel it.
11:41:52 <roconnor> gwern: back in 2003 I thought it was absurd that she would run for president.
11:41:55 <vixey> @src ((->)e) (>>=)
11:41:56 <lambdabot> Source not found.
11:42:01 <vixey> @src (->) (>>=)
11:42:01 <lambdabot> f >>= k = \ r -> k (f r) r
11:42:11 <vixey> @src (->) return
11:42:11 <lambdabot> return = const
11:42:40 <bos> jeebus pleebus. why is ghci giving me "module main:BloomFilter is not loaded"?
11:42:59 <bos> is it too much to ask that it at least give a meaningful error message?
11:43:04 <gwern> http://r6.ca/blog/20030914T194600Z.html <-- ouch, so you lost on both sweden and gray davis?
11:43:05 <lambdabot> Title: No Euro for Sweden
11:43:14 <roconnor> gwern: I totally suck
11:43:27 <shapr`> roconnor: wha?
11:43:47 <shapr`> oh
11:43:51 <pgavin> bos: hmm, I'm not sure it would help, honestly...
11:44:05 <gwern> roconnor: http://r6.ca/blog/20040522T154400Z.html <-- don't feel bad. I lost real money on kerry, not just play
11:44:05 <lambdabot> Title: More Futures Market
11:44:29 <roconnor> gwern: I like this quote " Although I think Kerry will get more votes that Bush, I think it is likely that other people know something that I don’t.
11:44:53 <roconnor> ah, baysian updates!
11:45:05 <bos> pgavin: that makes it a bit tricky to help, then :-)
11:45:24 <gwern> roconnor: a lesson learned!
11:45:58 <bos> is JaffaCake still in portland?
11:46:02 <dons> nope
11:46:02 <roconnor> gwern: so far, I've been doing good on the "US won't attack Iran before Jan 2009"
11:46:16 <dons> bos, he went back last month, after a 3 month stint.
11:46:19 <roconnor> gwern: I thought it was absurdly overpriced last year.
11:46:19 <bos> ok.
11:46:33 <bos> dons: shame. it was handy when he was in our time zone :-)
11:46:42 <roconnor> gwern: the December Intellegence report gave me quite a boost.
11:46:47 <dons> for sure. now you have to grab him before 10am or so
11:47:02 <gwern> roconnor: re http://r6.ca/blog/20051204T152900Z.html actually, it's a bit tricky because there are many known & inherent biases in prediction markets which aren't currently compensated for. for example, consider a bet that 'RHIC will spawn a black hole/strange matter that will devour the earth and kill us all'. it must be obvious that it will be mispriced
11:47:03 <lambdabot> Title: Market Pricing.
11:47:04 <gwern> roconnor: and prices have been dropping (odds there will be an attack going up)?
11:47:13 <gwern> oh wait, rising
11:47:31 <gwern> the december report being the one that said iran had abandoned the weaponization  program, iirc
11:47:39 <glguy> I didn't see how it started, but politics and economics aren't really on topic
11:48:27 <roconnor> ObOnTopic: http://r6.ca/blog/20070820T175938Z.html
11:48:27 <lambdabot> Title: Implementing the Kelly Criterion
11:48:30 <gwern> glguy: it started out of a discussion of bayesian reasoning :) which wasn't really on topic either
11:49:04 <roconnor> anyhow, I'll go to the bank now.
11:51:13 <vixey> @src Cont (>>=)
11:51:13 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
11:51:34 <hpaste>  pgavin pasted "space leak" at http://hpaste.org/8384
11:51:43 <pgavin> bos: ^^^
11:52:21 <pgavin> bos: I stuck a bunch of bangs in there to try to find the leak
11:52:48 <bos> pgavin: oh, you're using arrows. i don't speak teh crazy :-(
11:53:02 <pgavin> bos: lol :)
11:53:07 <bos> pgavin: at a guess, your list concatenation might be a problem.
11:53:10 <pgavin> bos: crazy, I definitely am
11:53:32 <pgavin> bos: yeah, I thought so... but trace tells me those lists never get longer than 3 or so
11:54:01 <bos> huh.
11:54:06 <pgavin> bos: and even using length to evaluate the spine doesn't reduce the leak
11:54:51 <monochrom> First you have to impeach the concrete arrow type used.
11:55:05 <bos> pgavin: tuples are generally lazy, too.
11:55:16 <gwern> roconnor: 'sgood blog though, too bad you're not updating it much these days. guess you're busy
11:55:41 <monochrom> Yes, that's the second thing to impeach, although I already see proc (!state', !time, !inp1, !inps2, !outs1) -> do ...  which may mitigate it.
11:55:57 <pgavin> monochrom: what do you mean by that?
11:56:10 <pgavin> monochrom: re, the concrete arrow type?
11:56:30 <monochrom> >>> can be written lazily or eagerly. up to the author.
11:56:57 <pgavin> monochrom: generally the arrow type will be a kleisli (at the bottom, anyways)
11:57:29 <vixey> @src ArrowMonad (>>=)
11:57:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:57:33 <pgavin> monochrom: and in the case I have with the leak, its Kleisli IO
11:57:33 <monochrom> >>= can be written lazily or eagerly too. up to the author.  Cf Control.Monad.State.Strict vs Control.Monad.State.Lazy.
11:57:53 <vixey> why is there ((->)r) and Reader r?
11:57:54 <pgavin> isn't >>= strict for IO, though?
11:58:04 <monochrom> OK, then we'll impeach something else.
11:58:08 <bos> vixey: convenience, i think.
11:58:35 <bos> vixey: having (->) e be a monad often confuses people.
11:58:38 <pgavin> vixey: ((->)r) can't be stacked
11:58:54 <pgavin> although, I guess Reader can't either :)
11:59:01 <pgavin> I was thinking of ReaderT :)
11:59:02 <bos> pgavin: ... right.
12:01:53 <Dynetrekk> cheers earthlings... anyone know of a good SOAP library for Haskell?
12:02:09 <monochrom> You tried inserting trace. When you did that, was there space leak?
12:02:20 <pgavin> monochrom: yes, still
12:02:31 <pgavin> monochrom: I think it may be a bug in GHC at this point :)
12:03:57 <pgavin> monochrom: every list I use here gets fully evaluated in short order, anyhow
12:04:20 <pgavin> monochrom: e.g., the caller always iterates over it
12:06:13 <monochrom> Do you turn on optimizations?
12:06:31 <pgavin> monochrom: the leak happens either way
12:06:42 <pgavin> with, or without -O
12:08:55 <bos> Dynetrekk: i don't believe any exists.
12:09:48 <jadrian> just to make sure I am not reinventing the wheel
12:09:59 <jadrian> is there any library even if very simple
12:10:19 <jadrian> for working with sets defined by description?
12:10:26 <jadrian> with properties and the like...
12:10:39 <pgavin> jadrian: you mean, like list comprehensions?
12:10:45 <jadrian> pgavin: yes exactly
12:10:50 <jadrian> was missing the word
12:10:59 <pgavin> jadrian: why not just use that?
12:10:59 <jadrian> do not need anything super fancy and theorem proving like
12:11:20 <Dynetrekk> bos: something called Haifa exists
12:11:21 <pgavin> jadrian: like [ x^2 | x <- [0..10], x % 2 == 0 ]
12:11:32 <Dynetrekk> but I'm not convinced from the web page
12:11:39 <jadrian> pgavin: no what I want is the representation of the set to be the description itself
12:11:57 <pgavin> jadrian: ah, ok, I understand
12:12:04 <pgavin> jadrian: not that I know of :)
12:12:05 <jadrian> so you could have thing like
12:12:19 <jadrian> m in Z
12:12:29 <jadrian> m in Z, m != 4
12:12:31 <jadrian> etc
12:12:32 <bos> Dynetrekk: it gives the appearance of death.
12:12:39 <bos> Dynetrekk: sort of like SOAP itself.
12:12:44 <jadrian> but like I said I don't need anything to fancy
12:13:02 <pgavin> jadrian: are you going to serialize the set descriptions?
12:13:07 <Dynetrekk> bos: so, fuck it all, is the basic message?
12:13:13 <jadrian> pgavin: define serialize?
12:13:19 <pgavin> jadrian: write to a file?
12:13:31 <bos> Dynetrekk: well, you could try dusting that library off, if you feel like it.
12:13:34 <jadrian> pgavin: to stdout
12:13:43 <jadrian> pgavin: at least...
12:14:00 <Dynetrekk> bos: no, I'm not good enough to change it. I want to learn haskell, but I need some sort of "project"...
12:14:16 <pgavin> jadrian: ok, nm...  what I mean is that if you're not serializing the sets, you shouldn't need to represent them internally as descriptions like that
12:14:21 <bos> Dynetrekk: something as horrifying as soap would be a bad place to start, then :-)
12:14:23 <jadrian> and I might also want to create the set or the list form the descriprition
12:14:49 <jadrian> pgavin: sure the whole point is to be able to look at them
12:14:57 <Dynetrekk> bos: thanks for the tip. well, a computer scientist friend of mine said it wasn't too hard to make it run
12:15:10 <pgavin> jadrian: you could embed ghc and use haskell directly to describe your sets :)
12:15:44 <pgavin> bbiab
12:15:49 <jadrian> pgavin: I just want something very limited and restricted
12:15:52 <jadrian> if I program it
12:16:09 <Dynetrekk> bos: anyway, I can't stand screwing around with sorting lists and that kind of tutorials. at least not over time
12:16:14 <jadrian> I'll probably do something like, just a list of properties
12:16:32 <jadrian> which might eventually be empty
12:16:58 <jadrian> and no simplifications or anything of the sort
12:17:14 <jadrian> anyway just wanted to know if it existed
12:17:32 <jadrian> is there a class for enumerable elements?
12:17:33 <jadrian> Ix
12:17:40 <jadrian> seems like Ix needs a range :S
12:18:05 <bos> Dynetrekk: it's definitely better to start with something interesting.  however, SOAP is not interesting, and it's a horribly overcomplicated pile of steaming not interestingness, so not a good place to start in any language.
12:18:46 <bos> SOAP was designed to give large consulting firms full employment.
12:19:02 <Dynetrekk> bos: point taken. I'll have to calculate something hard then (I'm a physics student)
12:19:05 <vixey> if you had: data N = Z | S N
12:19:09 <jadrian> ah Enum
12:19:10 <jadrian> got it
12:19:11 <vixey> and fold z s Z = z ; fold z s (S x) = s (fold z s x)
12:19:13 <Dynetrekk> bos: like most "mainstream" software I guess
12:19:20 <vixey> can you define pred just using fold?
12:20:42 <byorgey> vixey: you can if you have tuples
12:21:06 * jadrian doesn't like the Enum class
12:21:07 <jadrian> :S
12:21:36 <jadrian> the enum class doesn't really allow you to enumerate all elements does it?
12:21:53 <pgavin> jadrian: if the instance is implemented correctly, yes
12:22:12 <jadrian> pgavin: not really...
12:22:12 <dolio> Depends on the type.
12:22:13 <pgavin> it should anyways
12:22:17 <dolio> > succ 1.1
12:22:20 <lambdabot>  2.1
12:22:23 <jadrian> pgavin:  hmm wait
12:22:36 <pgavin> dolio: well, Double probably shouldn't be Enum then :)
12:22:42 <jadrian> pgavin:  hmm yeah you kind of can actually but no proper function provided
12:22:47 <dolio> No argument here. :)
12:22:54 <jadrian> in the sense that the ones that list elements , only go up
12:23:06 <jadrian> so only enumerate from a certain value
12:23:10 <jadrian> upwards
12:23:28 <tchakkazulu> jadrian: There's also "pred", with which you can go down as well.
12:23:33 <jadrian> it would be nice if a standard way of enumerating all elements was given
12:23:38 <pgavin> the "correct" implementation of Enum Double would have succ x = x + epsilon :)
12:23:40 <dolio> You can actually enumerate Doubles, but that's rarely what people would want, I guess.
12:23:46 <jadrian> tchakkazulu: yeap exactly... I just noticed that so I can enumerate them
12:23:55 <mercury^> > succ $ (Data.Ratio.%) 1 1
12:23:56 <lambdabot>  2%1
12:23:59 <jadrian> tchakkazulu: but I have to write my own function with pred and succ
12:24:06 <mercury^> > succ $ (Data.Ratio.%) 2 1
12:24:07 <lambdabot>  3%1
12:24:10 <jadrian> that should really be part of the class
12:24:21 <mehrheit> > succ $ (Data.Ratio.%) 1 2
12:24:22 <lambdabot>  3%2
12:24:24 <jadrian> a function that gives you the list of all elements
12:24:39 <tchakkazulu> jadrian: If you have both Enum and Bounded, you can do [minBound .. maxBound]
12:24:40 <mercury^> seems like it is broken for Q
12:24:58 <jadrian> tchakkazulu: but it should be possible with no bounds
12:25:22 <tchakkazulu> jadrian: Indeed, but then you'll need at least one element.
12:25:45 <byorgey> vixey: let z = (Z,Z); s (_,Z) = (Z, S Z); s (x,y) = (S x, S y); then  pred = fst . fold z s
12:25:52 <jadrian> tchakkazulu: sure, or the starting point could be part of the definition
12:26:36 <jadrian> anyway it is simple to implement
12:27:53 <tchakkazulu> jadrian: You'd need to have them out of order, though.
12:28:33 <vixey> cool
12:31:23 <therp> Dynetrekk: I recently enjoyed participating in http://projecteuler.net
12:31:23 <lambdabot> Title: Project Euler
12:32:02 <byorgey> vixey: oh, actually, I cheated, since if all you have is fold, presumably you can't pattern-match on Z like I did in the definition of s
12:32:11 <therp> Dynetrekk: Haskell is quite ok to solve the problems.. but projecteuler convinced me that I need to look beyond Haskell some day..
12:32:13 <byorgey> vixey: thankfully this is easy to solve, I just had the details wrong
12:32:40 <byorgey> vixey: let z = (Z,Z); s (_,y) = (y, S y); pred = fst . fold z s
12:32:49 <byorgey> that's much simpler anyway =)
12:34:41 <jadrian> tchakkazulu: sure
12:34:55 <Dynetrekk> therp: as in, Haskell is OK but you think you could do better?
12:35:04 <jadrian> is there any set implementation that handles infinite sets?
12:35:10 <Dynetrekk> therp: I think the most important of all is to learn some functional programming
12:35:36 <byorgey> jadrian: sure, just represent a set over the universe U as a function U -> Bool
12:35:36 <jadrian> with sorted lists or something...
12:36:20 <jadrian> byorgey:  yeah I know I can do thatm but I also want to list them...
12:36:29 <byorgey> that's a nice elegant representation, and you can easily do element insertion, deletion, set union/difference/intersection, and test for membership...
12:36:31 <jadrian> byorgey:  and sure, I can program it
12:36:38 <byorgey> the only thing you can't do easily is list all the elements of course =)
12:36:42 <jadrian> byorgey:  but wondering if there's one available already
12:36:55 <jadrian> byorgey:  yeap
12:36:58 <byorgey> jadrian: not that I know of
12:37:26 <byorgey> if you want to be able to have infinite sets and list the elements, you need to know some things about the sets you will be dealing with
12:37:39 <byorgey> so I don't think it would be possible to have a 'general' implementation
12:37:51 <jadrian> byorgey: it can easily be done with lists
12:37:59 <vincenz> they need to be enumerable :)
12:38:19 <byorgey> and they probably need to be ordered if you want to be able to do any sort of meaningful set operations
12:38:24 <jadrian> yeap
12:38:34 <jadrian> of course there will be plenty of limitations
12:38:39 <jadrian> not a problem though
12:38:49 <jadrian> even Data.Set needs ord for some operations
12:38:57 <vincenz> jadrian: it's nice to be explicity about them
12:38:59 <byorgey> jadrian: I'm not saying it can't be done, just that you probably won't find an existing library because it would be hard to know how to make it general enough
12:39:03 <therp> Dynetrekk: Haskell is ok, but I was stunned that lazyness sometimes not only makes things slower but sometimes even fails to give answers (for instance, because it runs out of stack, for a totally linear algorithm..)
12:39:25 <therp> Dynetrekk: I started to dream of a language that understands or at least supports me in space/time trade-off decisions.
12:39:25 <jadrian> byorgey: yeah but that's my point, _any_ set library will have restrictions
12:39:27 <Dynetrekk> therp: even for a good implementation? sounds hopeless.
12:39:37 <jadrian> byorgey: and won't be general enough, yet they exist
12:39:42 <therp> Dynetrekk: I'm using GHC.. I guess that's pretty good
12:39:49 <Dynetrekk> I thought lazyness was meant to be better for these things
12:39:59 <therp> Dynetrekk: or did you meant 'my way of implementing the problem'?
12:40:09 <jadrian> byorgey: in this case it would be handy for me one that choses a different kind of restrictions instead of the existing ones in Data.Set
12:40:17 <Dynetrekk> therp: no offence meant :-)
12:40:28 <jadrian> byorgey: Data.Set choses to implement only finite sets and to require ord for most operations
12:40:44 <Dynetrekk> therp: I do the same thing frequently, sometimes when making a simple plot..
12:40:45 <therp> Dynetrekk: try to solve problem 14 on project euler :)
12:40:46 <jadrian> byorgey: I was wondering if someone implemented one with a different kind of restrictions in mind
12:40:57 <Dynetrekk> therp: will have a look at least
12:41:03 <therp> Dynetrekk: my whole programming style is about 'making it simple' :)
12:41:12 <Dynetrekk> therp: sounds good to me
12:41:42 <jadrian> therp: simplicity is not easy to define though :)
12:41:50 <therp> Dynetrekk: when you have solved p14, you get access to a problem-specific forum. the guys discussed the "out of stack" problem of Haskell in there
12:42:09 <Dynetrekk> ah, okay
12:42:35 <therp> Dynetrekk: I resorted to Common Lisp for that problem. 30 seconds versus I guess >15 minutes on Haskell (greater-than because I canceled it)
12:42:51 <Dynetrekk> therp: I see
12:43:27 <therp> jadrian: I once heard: "code isn't good when there is nothing left to add, but when there is nothing left to remove."
12:43:30 * byorgey wonders about making a set implementation where you have to pass it an equality relation or an ordering relation when you construct it
12:43:39 <Dynetrekk> therp: disagree
12:43:52 <byorgey> then you wouldn't have any of the problems of it not being a Functor or Monad
12:44:07 <byorgey> because it wouldn't actually require an Eq or Ord constraint
12:44:11 <therp> I found that quite insightful...
12:44:19 <dolio> You'd have problems with it being a monad.
12:44:26 <dolio> Or, at least, you'd have to make an arbitrary decision.
12:44:43 <dolio> When computing the union of two sets.
12:45:01 <byorgey> dolio: oh, because you'd have two sets with different order relations?
12:45:08 <dolio> Potentially.
12:45:11 <byorgey> right, I see
12:46:02 <dolio> Also, fmap and return would be tricky.
12:46:15 <byorgey> oh, so they would.
12:46:21 <dolio> For fmap, you have to construct an ordering relation on bs given only an ordering on as.
12:46:24 <Dynetrekk> therp: my impression is that the main problem with functional programming is the lack of side effects. seems inconvenient
12:46:46 <byorgey> Dynetrekk: actually, that's the main advantage =)
12:46:52 <pgavin> Dynetrekk: heh, I think it adds convenience :)
12:47:12 <byorgey> dolio: yes, you're absolutely right
12:47:17 <Dynetrekk> byorgey: yes, I know. but, in the end, if your program has no side effects, why would you need it in the first place?
12:47:31 <therp> Dynetrekk: trust me, that's not problematic
12:47:40 <Dynetrekk> therp: good to hear
12:47:41 <roconnor> Haskell has explicit side-effects
12:47:47 <Dynetrekk> yes, monads
12:47:48 <roconnor> so they are not really "side"-effects
12:47:48 <byorgey> Dynetrekk: good question! This is why we have the IO monad, to safely encapsulate the side effects you do need, keeping them from contaminating the rest of your program.
12:47:49 <pgavin> Dynetrekk: Haskell does support side effects, they're just isolated
12:48:03 <roconnor> basically Haskell has effects that are not side
12:48:23 <Botje> haskell doesn't have side-effects, it has intended consequences.
12:48:24 <byorgey> heh, roconnor, I like that way of putting it =)
12:48:27 <therp> Dynetrekk: the problem with no side effects is that there is no concept that allows you to change your mind. there is no code transformer that allows you to slap on a call-by-value transformation to functions, so that you can use side effects.
12:48:35 <dolio> In general, there are lots of programs you can write where side effects aren't explicitly important.
12:48:40 <Dynetrekk> I understand the gains of having little/no side effects. believe me, I am writing a Java GUI application, I know about side effects
12:49:02 <mib_mq2jxo> hello
12:49:03 <Dynetrekk> dolio: in the end, it has to write something to the terminal.... this is explicitly important for me :-)
12:49:04 <dolio> All sorts of traditional unix utilities are functions from strings to strings, essentially.
12:49:09 <byorgey> hi mib_mq2jxo
12:49:22 <Dynetrekk> dolio: indeed, and then they write to the terminal
12:49:37 <dolio> It's just incidental that this has to be accomplished by side effects in practice.
12:49:49 <therp> Dynetrekk: with haskell you have to have a lot of foresight where your code wants to go. if the code has different plans than you it means cumbersome rewriting, which is boring, especially because editing is not really possible on a structural level (as with Lisp S-exp syntax), so refactoring is in general a bit more work with Haskell syntax..
12:50:19 <mib_mq2jxo> I need some help with ghci under emacs (ubuntu hardy heron)
12:50:21 <pgavin> therp: haskell can be written to look just like Lisp :)
12:50:29 <vincenz> liskell
12:50:33 <therp> pgavin: I know :) I have done Liskell
12:50:42 <dolio> Dynetrekk: The only thing you care about is String -> String, though. You can write lots of useful programs of that type, and let some runtime system worry about making it work on your computer correctly.
12:50:50 <dolio> In theory.
12:50:54 <pgavin> even without Liskell, just wrap all your function calls in parens :)
12:51:15 <dolio> Most of project Euler is Integer -> Integer or some such thing.
12:51:19 <Dynetrekk> therp: so it's not so great for playing with and trying out different stuff then
12:51:23 <mib_mq2jxo> I can't make the tab-completion work (as when i run ghci from terminal window)
12:51:28 <mib_mq2jxo> any pointers ?
12:51:31 <shapr`> mib_mq2jxo: Any specific questions?
12:51:52 <shapr`> I don't think tab completion has ever worked in ghci
12:51:55 <pgavin> Dynetrekk: Haskell is *great* for playing with and trying different stuff :)
12:52:08 <shapr`> You can hit M-p to get to previous commands though
12:52:14 <mib_mq2jxo> well it does when i run it from the term
12:52:16 <therp> Dynetrekk: oh, yes it is! Haskell is very powerful. So if you start from scratch, you don't have any drawback from it's little resistance to refactoring.
12:52:19 <Dynetrekk> pgavin: if refactoring is inconvenient?
12:52:44 <shapr`> hiya andyjgill, how's Kansas?
12:52:45 <mib_mq2jxo> and i tried to send to the ghci process i tab, but for some unknown reason it's not working
12:52:49 <therp> Dynetrekk: project euler is really good wrt, as you only write little programs, mostly 3-4 lines, and can restart quite easily.
12:52:59 <andyjgill> hi shapr`, going well.
12:53:00 <Dynetrekk> I see
12:53:05 <shapr`> mib_mq2jxo: I don't know
12:53:08 <mib_mq2jxo> yeah i know that M-p thingy
12:53:14 <pgavin> Dynetrekk: I don't find refactoring to be inconvenient in Haskell
12:53:17 <Dynetrekk> therp: should be good for learning some tricks then :-)
12:53:18 <mib_mq2jxo> damn it !!!  :-P
12:53:33 <pgavin> Dynetrekk: in fact, I find it to be more convenient than other languages
12:53:41 <pgavin> Dynetrekk: because Haskell code is so malleable
12:53:54 <therp> Dynetrekk: ah and btw that's just my personal experience with haskell. pgavin seems to have a different opinion :)
12:53:56 <mib_mq2jxo> i was searching the web for hours
12:53:57 <pgavin> Dynetrekk: it feels like play-doh in my hands :)
12:54:35 <shapr`> pure functions are nice for refactoring
12:54:35 <Dynetrekk> pgavin: I like the idea of haskell, as I am somewhat mathematically oriented, but there's a lot of hard-to-get stuff in the beginning
12:54:36 <mib_mq2jxo> it feels like nails in mine :-D
12:54:52 <pgavin> Dynetrekk: yes, that's true
12:54:53 <shapr`> mib_mq2jxo: Don't worry, it gets easy quickly!
12:54:59 <Dynetrekk> I learned python by myself some time ago. takes 5 min to get starting. Haskell has a disadvantage there
12:55:01 <pgavin> Dynetrekk: but it's all worth it in the end :)
12:55:02 <mib_mq2jxo> i was kidding
12:55:22 <mib_mq2jxo> i love haskell (still a novice, but still like)
12:55:25 <pgavin> Dynetrekk: once you understand monads, everything else is cake
12:55:32 <Dynetrekk> pgavin: time will tell. it's my "rainy summer day" project of this summer I think
12:55:55 <roconnor> pgavin: well, I found recursive do a little screwy.  Took me a few hours to figure it out.
12:55:56 <Dynetrekk> pgavin: what's so hard about these monads? it seems to me you just say that "the order matters here" for  a while
12:55:58 <shapr`> Dynetrekk: Ever tried to work with a large Python codebase, vs working with a large Haskell codebase?
12:55:58 <mehrheit> Dynetrekk, Haskell might change your thinking a bit, if you haven't programmed in functional languages before
12:56:17 <mehrheit> (or mabe a lot)
12:56:17 <Dynetrekk> shapr`: no, I only write small scripts
12:56:18 <mrd> mib_mq2jxo: there's M-/ for emacs's completion
12:56:29 <mehrheit> s/mabe/maybe
12:56:40 <Dynetrekk> shapr`: this is what I love python for - reading a text file, make a plot, doing an FFT, printing a file
12:56:42 <mib_mq2jxo> have you guys tried the language Oz ?
12:56:58 <mib_mq2jxo> really ? wait i'm gonna try this one - cheers anyhow
12:57:09 <Dynetrekk> shapr`: takes 5 minutes even if you are new to it. yes, I suspect it's a pain if the code base is big.
12:57:13 <pgavin> Dynetrekk: ghci happens to be great for doing that kind of one-liner stuff
12:57:14 <vixey> mib_mq2jxo: yes
12:57:33 <roconnor> python takes 5 minutes to learn because it is almost the same as every other langauge.
12:57:33 <shapr`> Dynetrekk: I did Zope/Plone hacking for a living for a few years
12:57:37 <paolino> mib_mq2jxo: and curry
12:58:28 <Dynetrekk> pgavin: haskell to make plots? read text files? now THAT I don't believe.
12:58:37 <shapr`> heh
12:58:54 <jadrian> therp: sure but that doesn't give you a metric at all
12:58:57 <pgavin> Dynetrekk: reading text files, sure
12:58:59 <mib_mq2jxo> M-/ is for already known tags ...
12:59:01 * ronwalf runs into "Constraint is no smaller than the instance head" :(
12:59:04 <jadrian> therp: to explain what I meant
12:59:10 <pgavin> Dynetrekk: I'm sure there's a plotting library out there somewhere :)
12:59:12 <Dynetrekk> pgavin: and a Gnuplot interface?
12:59:24 <mib_mq2jxo> do you have a list of all the prelude deafult symbols ?
12:59:25 <Dynetrekk> pgavin: I don't want "a plotting library", as most are crap...
12:59:27 <pgavin> Dynetrekk: should be simple to do :)
12:59:28 <shapr`> mib_mq2jxo: hippie-expand is even more fun than M-/
12:59:40 <jadrian> therp: for instance some people will look at a problem and see a patterns such as monads and the like
12:59:42 <mehrheit> Gnuplot can be interfaced through a pipe or an intermediate file
12:59:44 <Dynetrekk> pgavin: show me a code example, and I'll reconsider!
12:59:45 <shapr`> I think there's already a Haskell gnuplot interface
12:59:53 <jadrian> therp: and use them to make the code shorter and more reusable
13:00:02 <pgavin> actually, a haskell/gnuplot interface would be pretty easy to do
13:00:15 <jadrian> therp: but of course you can get cryptic
13:00:30 <jadrian> therp: and it's far from objective
13:00:32 <therp> jadrian: I totally agree that simplicity is hard to define and is mostly a matter of taste
13:00:32 <Dynetrekk> shapr`: in that case, I could consider it. but then, python is _really_ easy for this kind of stuff. for haskell to beat it, it has to be good
13:00:37 <roconnor> I'm hoping for Haskell Charts to replace gnuplot.
13:00:56 * roconnor hates gnuplot
13:01:03 <pgavin> roconnor: why's that?
13:01:13 <shapr`> Dynetrekk: So try it!
13:01:14 <therp> jadrian: the quote (no idea which source) was just to illustrate that "problem" as it contrasts "add stuff=good" with "remove stuff=good"
13:01:15 <pgavin> roconnor: it's pretty easy and works well in my exp
13:01:15 <roconnor> pgavin: because it isn't referentially transparent
13:01:27 <pgavin> roconnor: lol, ok, fair enough :)
13:01:27 <jadrian> therp: yeap I certainly agree with that
13:01:31 <Dynetrekk> shapr`: where did you find this Gnuplot interface, did you say?
13:01:37 <shapr`> Dynetrekk: I think Python is only easy if you've already done imperative programming
13:01:52 <roconnor> pgavin: you have to set this and set that to get the enviroment just right.  It makes coposing scripts a nightmare.
13:01:56 <roconnor> composing
13:01:56 <b_jonas> gnuplot interface? I only know two of those
13:02:04 <Dynetrekk> shapr`: could be, but that's what people learn first, usually (Java, C, etc)
13:02:10 <b_jonas> oh, as haskell one?
13:02:12 <b_jonas> is there a need?
13:02:18 <pgavin> roconnor: yes, that's true, the interface could use some help, and the syntax isn't exactly nice
13:02:23 <shapr`> Dynetrekk: try http://dockerz.net/twd/HaskellCharts ?
13:02:23 <lambdabot> Title: HaskellCharts - twd
13:02:24 <therp> jadrian: a quote hanging on my fathers desk was, "good solutions develop from the trivial to the complex and finally to the simple". he was in business consulting :)
13:02:36 <b_jonas> I mean, gnuplot can be fed data from text files just fine, so there's not much need of a specific interface really
13:02:37 <jadrian> therp: ah nice :)
13:03:19 <jadrian> Dynetrekk: starting with C is painful :)
13:03:27 <Dynetrekk> shapr`: this thing can make nice vector plots of scientific quality?
13:03:39 <Dynetrekk> jadrian: yes, C is utter pain
13:03:45 <roconnor> Dynetrekk: not at the moment :(
13:03:50 <pgavin> roconnor: I happen to like gnuplot's output, so I generally just dump my data to a flat text file and write a shell script to call gnuplot
13:03:53 * jadrian is still looking for a "first imperative language" better than pascal :S
13:03:58 <jadrian> if anyone knows of any
13:04:02 <pgavin> jadrian: scheme :)
13:04:09 <vixey> jadrian: yeah lisp or scheme
13:04:14 <shapr`> haskell!
13:04:21 <jadrian> oh come on
13:04:22 <shapr`> hiya jadrian!
13:04:23 <vixey> oh haskell the imperative
13:04:31 <Dynetrekk> pgavin: dump data to a text file and a shell script to call gnuplot is the easy way. now, what do you do if you want to make 1000 plots?
13:04:31 <jadrian> heya shapr`!!
13:04:44 <roconnor> pgavin: I found gnuplot to produce ugly ugly graphs.  They don't do proper hidden surface removal.
13:04:48 <b_jonas> Dynetrekk: I think C is better as a first imperative language than perl, except you have to avoid the bad books and bad advices which are floating plenty out there
13:05:01 <Dynetrekk> pgavin: write 1000 files takes time - and what if the file is 10s of MB?
13:05:02 <b_jonas> if you learn from a good book or a good teacher, C is just better than pascal
13:05:03 <mib_mq2jxo> Are you familiar with C nested function ? you can program functionally down the stack   (this is gcc extension)
13:05:03 <jadrian> shapr`: I actually don't find haskell that good for imperative :P
13:05:04 <pgavin> Dynetrekk: n=0; while [ n -lt 1000 ]; do gnuplot < file$n ; done
13:05:09 <shapr`> aww
13:05:15 <bos> when did bytestring get split out of base?
13:05:16 <shapr`> I like it for most things.
13:05:17 <roconnor> pgavin: I honestly couldn't believe how terrible gnuplot was after all there years.
13:05:24 <bos> was that for ghc 6.8.1, or 6.6?
13:05:31 <roconnor> pgavin: I can only assumed it stagnated somtime in the early 90s
13:05:36 <pgavin> roconnor: but it has online help! :)
13:05:36 <Dynetrekk> pgavin: yes, and I tried it. however it is slow and only works nicely for small plot files
13:05:55 <pgavin> Dynetrekk: I suppose you could have gnuplot read from a pipe
13:06:07 <roconnor> pgavin: hidden surface removal! It is the 21 century! :D
13:06:09 <jadrian> shapr`:  for instance you got issues with laziness
13:06:11 <Dynetrekk> pgavin: that's how the Gnuplot-py interface works.
13:06:31 <Dynetrekk> roconnor: gnuplot is messy but makes nice output - that's why people like it
13:06:35 * roconnor checks his old example.
13:06:49 <jadrian> shapr`:  in a "normal" imperative language instructions are preformed in the order you define
13:07:05 <jadrian> shapr`:  in a monad, in do notation, that is not the case
13:07:32 <vixey> nothing happens in haskell
13:07:36 <jadrian> shapr`:  then the variables in a monad are not even statically typed
13:07:40 <vixey> so ordering doesn't even make sense
13:08:21 <jadrian> vixey: kind of, you might want to define order, and you can
13:08:32 <roconnor> vixey: when a monad is "executed" the effect will happend in the stated order.
13:08:32 <jadrian> vixey: you have to use strictness anotations though
13:08:32 <shapr`> jadrian: huh?
13:08:50 <jadrian> shapr`: define huh? :)
13:09:00 <jadrian> shapr`:  the bindings thing?
13:09:31 <shapr`> jadrian: Why do you say do notation does not order things?
13:09:50 <pgavin> roconner: oh, I've never really done 3d with gnuplot, only 2d
13:09:50 <tessier_> Haskell now has a parallel, multicore garbage collector! Very cool.
13:10:02 <shapr`> Dynetrekk: I found two gnuplot bindings for Haskell, but neither are complete
13:10:09 <jadrian> shapr`:  what I mean is that inside the do notation having
13:10:21 <Dynetrekk> shapr`: so, you'll have to go through some pain to do it then
13:10:32 <jadrian> shapr`:   do {  x <- P1 ; ... ; y <- P2 }
13:10:45 <shapr`> Dynetrekk: I think so. GNUplot hasn't been a high priority library yet.
13:10:48 <jadrian> shapr`:   doesn't mean x will be assigned a value before y
13:11:10 <Dynetrekk> shapr`: it's not GNU. it's not even GPL. tragic but true
13:11:14 <jadrian> shapr`:   think of getting the time, performing action, getting the time again, and check the difference
13:11:35 <b_jonas> gnuplot just doesn't need a library
13:11:43 <dons> shapr`: do you know if anyone got ghc targetting the nokia yet?
13:11:46 <Dynetrekk> b_jonas: so how do you do loops?
13:11:49 <hpaste>  roconnor pasted "GnuPlot -- still looks ugly to me." at http://hpaste.org/8385
13:11:49 <jadrian> shapr`:  I'd like that to be super trivial in a "first imperative language"
13:11:52 <shapr`> dons: stepcut did
13:11:55 <b_jonas> Dynetrekk: what loops?
13:11:55 <jadrian> shapr`:  it is not in haskell
13:12:03 <dons> shapr`: ah interesting.
13:12:04 <pgavin> dons: I'm waiting for the iphone port :)
13:12:04 <b_jonas> I just output stuff to a text file
13:12:16 <b_jonas> I've written such a perl script once
13:12:24 <b_jonas> outputs numeric data to a temp text file,
13:12:29 <jadrian> shapr`:  in an imperative language I want the order of execution of actions to be trivial to understand
13:12:31 <b_jonas> pipes commands to gnuplot
13:12:34 <Dynetrekk> b_jonas: I would like to make a loop, plotting several files, or making a function to make a plot
13:12:48 <b_jonas> Dynetrekk: you can build the commands dynamically
13:12:53 <Dynetrekk> b_jonas: something I did in python as an example: plot all linear resonances of an accelerator lattice up to order N
13:12:54 <b_jonas> it's just text
13:13:18 <Dynetrekk> b_jonas: I know, but not in "gnuplot language", so you need to write bash, python or someting
13:13:26 <b_jonas> yep, not in gnuplot
13:13:34 <b_jonas> from another language
13:13:37 <b_jonas> like perl
13:13:38 <Dynetrekk> b_jonas: which is why you need "something"
13:13:48 <b_jonas> it's probably just as easy in haskell
13:14:04 <Dynetrekk> b_jonas: could be, I don't know Haskell well enough (yet?)
13:14:06 <b_jonas> it's just plain text, I don't think a library would actually make it much easier
13:14:23 <mib_mq2jxo> ok guys, thanks for the help :-) laterz
13:14:24 <b_jonas> I mean, the data is just input as numbers from a text file
13:14:25 <Dynetrekk> b_jonas: in my experience, Gnuplot-py makes it easier.
13:14:33 <shapr`> jadrian: if you have 3 IO actions, the first one will always happen before the last one. I don't understand.
13:14:59 <hpaste>  roconnor annotated "GnuPlot -- still looks ugly to me." with "no hidden surface removal" at http://hpaste.org/8385#a1
13:14:59 <b_jonas> I dunno
13:14:59 <Dynetrekk> b_jonas: that is not always the most convenient way
13:15:08 <b_jonas> my problem with such libraries is that they are often limited
13:15:09 <b_jonas> like
13:15:19 <b_jonas> octave's builtin plot functions are interfaces to gnuplot
13:15:22 <roconnor> pgavin: http://imagepaste.net/images/gnuplot1.png
13:15:26 <shapr`> jadrian: Why do you say variables in monads are not typed? That doesn't make sense to me.
13:15:32 <pgavin> roconnor: yes, that's pretty bad
13:15:33 <b_jonas> but there are some things gnuplot can do that you can't do from octave
13:15:49 <Dynetrekk> b_jonas: the gnuplot-py library is limited, but also unlimited. you can always call gnuplot_instance('random string') which lets you do pretty much everything
13:16:03 <b_jonas> though it's probably still convenient to have the plot functions built in octave
13:16:06 <b_jonas> so maybe it does help
13:16:19 <roconnor> okay, I should say that I'm happy gnuplot exists, and I get what I pay for.  I just think we should strive for better.
13:16:27 <b_jonas> and I always like reinventing other libraries as well :-)
13:16:32 <shapr`> jadrian: Can you show me some code that demonstrates what you describe?
13:16:48 <Dynetrekk> b_jonas: indeed - example code follows: g.plot(somelist) instead of writing some random text file and running commands and pipes and everything
13:17:02 <Dynetrekk> b_jonas: where g is the gnuplot instance
13:17:06 <jadrian> shapr`:  sure but you don't have each line of the instructions in the monad being evalutated  (in the classical imperative sense) sequencially
13:17:08 <b_jonas> hmm, let me check how many lines was that in perl...
13:17:26 <twobitwork> does ghc do any optimizing of lists for quicker random access?
13:17:31 <jadrian> shapr`:  just write the program to get time, calculate something, and get time again
13:17:37 <Heffalump> twobitwork: no
13:17:42 <jadrian> shapr`:  I'd do it myself but my haskell is rusty :S
13:17:42 <roconnor> twobitwork: nope
13:18:02 <twobitwork> so, they're really always stored as a struct with 2 elements, the second being a pointer...
13:18:09 <roconnor> twobitwork: arrays or map or Seq are the way to go for random access.
13:18:13 <jadrian> shapr`:  thing is you have to force the evaluation with strictness annotations
13:18:18 <dons> twobitwork: for random access, no way.
13:18:23 <dons> use a random-access list
13:18:25 <shapr`> jadrian: So you think the second getTime could occur before the first?
13:18:29 <jadrian> shapr`:  no
13:18:34 <twobitwork> dons: is that different than an array?
13:18:52 <jadrian> shapr`:  but you wouldn't evaluate the time the program taes to be performed
13:19:08 <jadrian> shapr`:  because no evaluation would be performed before geting the time
13:19:11 <dons> twobitwork: yeah, see hackage.haskell.org, or look at one of the other random access types
13:19:20 <twobitwork> ok, thanks
13:20:55 <pgavin> jadrian: right, but how does that show that monad's are inconsistent?
13:21:03 <pgavin> jadrian: you're just showing that Haskell is lazy
13:21:20 <vixey> jadrian: You can force the evaluation of course
13:21:24 <b_jonas> it seems it took like 15 lines in perl for me to write the data file from a sequence of coordinates and run gnuplot with the command
13:21:31 <jadrian> doesn't show anything bad about haskell
13:21:41 <b_jonas> the rest of the script is for generating the data
13:21:56 <jadrian> except that I would not use it to as a first "imperative programming language"
13:21:59 <Dynetrekk> b_jonas: and in gnuplot-py (python) this was one line once you ha the list
13:22:00 <shapr`> jadrian: Ah, if you your students to learn that every instruction happens in the exact order that they are written, then Haskell is not the language you want. But why teach students that idea?
13:22:02 <jadrian> for teaching purposes
13:22:08 <b_jonas> Dynetrekk: yup
13:22:20 <shapr`> ok
13:22:27 <pgavin> shapr`: assembly is as good a language for teaching that as any other :)
13:22:31 <shapr`> yup
13:22:32 <b_jonas> though it would be three actually, as I'd have to push data to an array
13:22:38 <b_jonas> I'm reading it sequentially
13:22:54 <jadrian> shapr`: well I do have that notion associated to the idea of imperative programming...
13:22:54 <b_jonas> plus, there would be one more line for setting the format or something
13:22:54 <shapr`> pgavin: except that it doesn't work that way when you have a cpu pipeline
13:23:03 <shapr`> jadrian: oh I see
13:23:10 <jadrian> shapr`: you can argue otherwise and of course I'll accept that
13:23:16 <pgavin> shapr`: well, externally, it should
13:23:17 <Dynetrekk> b_jonas: another nice thing, you only do settings and stuff once
13:23:21 <pgavin> shapr`: internally, it may not
13:23:28 <Dynetrekk> b_jonas: 'cause you keep a gnuplot instance running
13:23:34 <b_jonas> Dynetrekk: yep
13:23:36 <jadrian> shapr`:  but in practice, I'm not so sure that as it stands it is of much use to teach someone an imperative lazy language
13:23:37 <b_jonas> I can do that in perl too
13:23:50 <b_jonas> here I'm producing only one plot
13:23:56 <Dynetrekk> b_jonas: okay, I suspect you out-skill me in the ways of the shell
13:24:02 <jadrian> shapr`:  not going to help much moving to any other imperative language
13:24:05 <pgavin> jadrian: imperative and lazy are pretty much conflicting
13:24:08 <Dynetrekk> (and perl)
13:24:14 <b_jonas> but actually I'm runnign a gnuplot command like "!sleep" or something to wait for a keypress
13:24:29 <b_jonas> so I could use more than one of those and plot multiple graphs
13:24:37 <pgavin> jadrian: imperative implies order is important, but lazy implies it's not important
13:24:42 <Dynetrekk> b_jonas: I see... good for you :-)
13:25:02 <pgavin> jadrian: you'd have to segregate your imperative code from the lazy code, just like haskell does anyways
13:25:02 <shapr`> jadrian: I think multicore programming will be easier for students that understand a lazy language. But I do agree, Haskell isn't the pinnacle of in-order execution.
13:25:05 <b_jonas> but I mean, if you write the settings to a program
13:25:17 <jadrian> pgavin: that is my idea too
13:25:21 <b_jonas> you wouldn't write it more than once even if you run gnuplot many times
13:25:24 <Dynetrekk> b_jonas: anyway, I know it can be done, and I have done it myself. I just found it less comfortable, and in python (or haskell) you have lots and lots of mathematical functions etc
13:25:28 <b_jonas> that's the whole point of functions
13:25:45 <pgavin> jadrian: you know that scheme supports lazy (err, delayed) evaluation, right?
13:25:46 <Dynetrekk> b_jonas: okay, I think I misunderstood what you meant
13:25:46 * ronwalf gives up and adds -fallow-undecidable-instances
13:26:04 <pgavin> jadrian: but you still have to force the computation explicitely
13:26:23 <Dynetrekk> b_jonas: anyway, point being, convenience matters as well
13:26:31 <vixey> I don't think it scheme supports lazy evaluation
13:26:33 <roconnor> ronwalf: ouch
13:26:33 <b_jonas> yep
13:26:49 <jadrian> shapr`: as for the variables having sytatic types, take as an example
13:26:54 <pgavin> vixey: see the delay/force functions
13:27:09 <vixey> pgavin: I don't think they count as support by scheme
13:27:23 <pgavin> vixey: well, minimal support
13:27:31 <ronwalf> roconnor: I'm already stressing the type system with Wouter's extensible datatypes
13:27:37 <pgavin> vixey: so does ocaml/sml/etc.
13:27:42 <pgavin> vixey: in a similar way
13:27:47 <roconnor> ronwalf: oh, that's what you are doing
13:27:52 <roconnor> ronwalf: carry on then.
13:28:10 <shapr`> jadrian: ?
13:28:13 <pgavin> ronwalf: undecidable instances isn't necessarily bad
13:28:18 <jadrian> f = do {m<- return 'a'; m <- return 1; return m}
13:28:38 <jadrian> shapr`:  f = do {m<- return 'a'; m <- return 1; return m}  -- this
13:28:39 <roconnor> My ploting program in Coq isn't as nice as gnuplot yet.
13:28:51 <pgavin> ronwalf: it just means the compiler can't prove that the typechecker will terminate for your classes/instances
13:28:51 <jadrian> shapr`:  I really dislike that
13:29:13 <jadrian> shapr`:  I like my variables statically typed
13:29:33 <pgavin> jadrian: you know that m has 2 different meanings in that code snippet
13:29:52 <pgavin> jadrian: the second m is an entirely different variable
13:29:53 <ronwalf> pgavin: At some point, I want to study the type system.  There are certain logics that are really stretching what you can do and still be decidable (description logics, for example)
13:30:10 <jadrian> pgavin: as for scheme, not an expert on scheme... but it's not statically typed right?
13:30:14 <pgavin> ronwalf: yeah, it's definitely neat stuff
13:30:18 <jadrian> pgavin: I really like static typing
13:30:19 <pgavin> jadrian: right, dynamic
13:30:22 <pgavin> jadrian: me too :)
13:30:35 <jadrian> pgavin: yeah I know it's two completely different vars
13:30:38 <vixey> What are description logics?
13:30:42 <ronwalf> Does anyone have a translation of the type system to FOL?
13:30:46 <dogbite> hey, i'm looking to hire a functional programmer -- i'm at a hedge fund in new york
13:30:54 <dogbite> any advice on how to go about searching for somebody
13:30:59 <dogbite> a good place to post a job description?
13:31:06 <pejo> jadrian, it's not the same m, and it is statically typed.
13:31:06 <roconnor> dogbite: hire me
13:31:15 <pgavin> dogbite: haskell-cafe@haskell.org
13:31:16 <dons> go cabal! http://www.reddit.com/info/6nsl6/comments/
13:31:17 <lambdabot> Title: reddit.com: cabal-install released! Automatically dep chase, download and build  ...
13:31:25 <dogbite> roconnor: you in nyc?
13:31:26 <jadrian> pgavin: and I'm ok with it in haskell, but again not haskell being used as a first imperative language
13:31:40 <ronwalf> vixey: A class of decidable logics characterized by a variable-free syntax (not that they aren't there, but they're implicit)
13:31:42 <roconnor> dogbite: nope.  Would I have to relocate?
13:31:43 <jadrian> pejo: yes I know... point is, we know because we really understand how it is working
13:32:06 <ronwalf> vixey: Often used for taxonomies, term descriptions, and the like
13:32:07 <pgavin> jadrian: I happen to think haskell IO is the "right" way to think about programming with side effects; every other language is wrong :)
13:32:11 <jadrian> pejo: and I don't think the way it works is simple enough to take it and give it as a first imperative language which is what we are talking about
13:32:14 <dogbite> roconnor: okay, could be possible.  we'd have to chat offline.
13:32:28 <ronwalf> vixey: They even have a web standard (OWL)
13:32:30 <dogbite> roconnor: yes to the relocate though
13:32:44 <roconnor> dogbite: oh.  nevermind then.  I'm not prepared to move to the US.
13:32:57 <jadrian> pgavin: programming with side effects, maybe... which is not the same as imperative language
13:33:07 <dogbite> roconnor: can't blame you, heh
13:33:14 <jadrian> pgavin: but even then side effects in haskell can be a $%$&#%&
13:33:17 <jadrian> ;)
13:33:30 * roconnor puts his dreams of making millions working with Haskell for a hedge fund on hold.
13:33:34 <jadrian> pgavin: sure you do have control over them
13:33:35 <pgavin> jadrian: imperative implies side-effects
13:33:45 <pejo> jadrian, you can shadow global variables in C too though.
13:33:50 <jadrian> pgavin: sure... but it's not equivalent too...
13:34:20 <pgavin> jadrian: well, it depends on your definition of equivalent
13:34:37 <jadrian> pejo: that is a good point...
13:34:39 <pgavin> jadrian: if you take equivalent to mean "equally capable"
13:34:59 <roconnor> dogbite: Also, I'm not quite done my PhD yet. :P
13:35:48 <shapr`> jadrian: Yeah, I don't think that shadowing is different than it would be in an imperative language like C
13:36:12 <dogbite> roconnor: either am i :-)
13:36:18 <jadrian> pgavin: for instance you just said a while ago that imperative for you implied order was important
13:36:29 <dons> win 42
13:36:36 <jadrian> shapr`: yeap I'm reconsidering that argument :)
13:36:42 <roconnor> dogbite: out of curiousity, were you looking for someone right a way?
13:36:46 <dogbite> dons: i see you listed on the jobs-in-fp page
13:36:48 <jadrian> shapr`: although it is a bit different
13:36:55 <dogbite> dons: any advice?
13:36:56 <jadrian> shapr`: you are forced to declare a variable
13:37:01 <dons> dogbite: i listed?
13:37:06 <dons> ah, galois.
13:37:10 <jadrian> shapr`:  and in that scope that identifier only has one type
13:37:17 <dons> advice,hmm, get really good at haskell
13:37:18 <dogbite> roconnor: yeah, we're hiring now.
13:37:28 <Dynetrekk> therp: Best starting number:  837799
13:37:31 <dogbite> dons: well thanks -- i'm trying very hard to get good
13:37:32 <jadrian> shapr`:  in here each time it appears it's a new variable of course
13:37:34 <Dynetrekk> therp: says my program
13:37:35 <dons> dogbite: oh, you're hiring someone?
13:37:41 <dogbite> dons: yeah
13:37:43 <dons> dogbite: you could add details to the haskell-in-industry page
13:37:45 <jadrian> shapr`:  so each occurrence is a declaration in fact
13:37:47 <roconnor> dogbite: ah. I have a contract with the university until the end of the year.
13:37:51 <Dynetrekk> therp: how do you find out if it's right?
13:37:52 <dons> dogbite: maybe talk to well-typed
13:37:53 <shapr`> jadrian: nah, that's a lambda, different scopes
13:38:00 <dons> http://haskell.org/haskellwiki/Haskell_in_industry
13:38:06 <vixey> lambda!
13:38:06 <jadrian> shapr`:  exactly
13:38:22 <pgavin> jadrian: you can have ghc warn you when you hide one definition with another (which is what you did there)
13:38:22 <ahunter_> Can anyone here give me some build help?  Specifically, I cannot get nofib-analyse to build, and I'm unsure why
13:38:23 <dons> dogbite: but the main thing would be to go to the NYC FP meetup
13:38:35 <pejo> jadrian, the same is true for Haskell, variables don't change type all the sudden. You're conveniently ignoring that it's a new scope.
13:38:35 <jadrian> pgavin: oh ok I didn't know that
13:38:35 <dons> dogbite: hang out with the CS and Deutsche bank guys, and see who turns up
13:38:42 <dogbite> dons: i've been there
13:38:52 <dogbite> dons: great group -- they keep quoting me on the invites, ha
13:38:53 <dons> re. hiring, most is done via an advertisement to haskell-cafe@
13:38:56 <pgavin> jadrian: I think -Wall turns that on (which is usually what I use by default)
13:39:10 <jadrian> pejo: yes I understand that
13:39:11 <dons> i see the next meetup is june 25
13:39:15 <jadrian> pejo: you are right
13:39:15 <dogbite> dons: thanks, i'll email haskell-cafe
13:39:22 <dons> dogbite: exciting!
13:39:36 <dogbite> dons: thrilling yeah
13:39:54 <dons> dogbite: also, you might consider coming to CUFP, if you've not been before
13:40:02 <dogbite> dons: what is cufp?
13:40:09 <dons> commercial users of FP meeting, in vancouver this year.
13:40:10 <jadrian> pejo: I understand what is happening, and I know it's different vars and different scopes
13:40:10 <Heffalump> you should consider going even if you have been before :-)
13:40:21 <BMeph> shapr`: I think jadrian is petitioning for enforcing DMR inside do-clauses... ;p
13:40:21 <dons> http://cufp.galois.com/
13:40:22 <lambdabot> Title: Commercial Users of Functional Programming
13:40:22 <dogbite> dons: vancouver sounds like fun, i'll google
13:40:36 <therp> Dynetrekk: just register with projecteuler.net
13:40:47 <pgavin> what ever happened to AmeroHaskell?
13:40:48 <jadrian> pejo: what I mean is that in practice the restrictions imposed by C or Pascal to allow for shadowing are better ones
13:40:49 <Dynetrekk> therp: ah, okay
13:41:01 <jadrian> pejo: because it's more obvious for the programmer that it is happeneing
13:41:04 <dons> dogbite: also, talk to guys like Heffalump, augustuss (i gues you've met), jeff polakow.
13:41:20 * ronwalf sends a naive message about haskell types to haskell-cafe
13:41:26 <Dynetrekk> therp: yeee, I did it. (in python...)
13:41:29 <dogbite> dons: i don't know the screen names but okay
13:41:40 * BMeph thinks a Galois-sponsored conference should be in Vancouver... WA.
13:41:44 <therp> Dynetrekk: oh that was a fast registration :)
13:41:44 <shapr`> BMeph: hah
13:41:54 <therp> Dynetrekk: what's your username? :)
13:42:26 <Dynetrekk> therp: guess once, and the first one doesn't count
13:42:32 <Dynetrekk> (Dynetrekk again)
13:43:04 <therp> ah you solved 14 right away. have the ones before been to easy? :)
13:43:04 <Dynetrekk> therp: took 2 min in python, so it can't be the hardest problem
13:43:24 <Dynetrekk> therp: I just tried the one you suggested while I was talking BS in here
13:44:08 <therp> dynetrekk: that's me http://projecteuler.net/index.php?section=profile&profile=clemens :) .. I like those profiles because I watch the progress of friends, and discuss problems whenever they get ahead of me :) (although the really interesting was start I guess way beyond 30?)
13:44:08 <lambdabot> Title: Project Euler
13:44:43 <Dynetrekk> therp: so now you'll follow my progress? :P
13:45:03 <therp> math stalker geek :)
13:45:13 <dons> good work, byorgey
13:45:24 <Dynetrekk> therp: what kind of geek?
13:45:32 <Dynetrekk> typeof(geek) or something
13:45:39 <twobitwork> too bad you can't put expressions in ``
13:45:45 <psnively> Testing
13:45:53 <pgavin> twobitwork: you can't?
13:45:56 <twobitwork> like: [1,1,1] `(zipWith (+))` [2,2,2]
13:46:07 <twobitwork> > [1,1,1] `(zipWith (+))` [2,2,2]
13:46:07 <lambdabot>  Parse error at "(zipW..." (column 10)
13:46:12 <therp> Dynetrekk: according to wikipedia 'Stalking, obsessively following or constantly observing another person'
13:46:14 <pgavin> twobitwork: heh, I thought you could :)
13:46:27 <pgavin> twobitwork: nested `` could be a problem
13:46:32 <Dynetrekk> therp: okay, but what subject? (not chemistry I presume)
13:46:38 <twobitwork> ahh... yeah, that would be a problem
13:46:38 <pgavin> twobitwork: for the parser, I mean
13:46:53 <pgavin> although parens would resolve that
13:46:57 <twobitwork> and expressions can have `` in them, thus you would have to support that
13:47:14 <therp> Dynetrekk: sorry, what's the question? what type of geek I am?
13:47:22 <twobitwork> yeah, if it required you to use `()` for expressions then it would work
13:47:23 <Dynetrekk> therp: no problem, and, yes
13:47:28 <byorgey> dons: thanks
13:47:34 <therp> Dynetrekk: I'd suggestion programming + its theory :)
13:47:41 <therp> s/suggestion/think/
13:47:51 <Dynetrekk> therp: okay, not surprising I suppose
13:48:03 <rwbarton> > let (&) = flip id in [1,1,1] & (zipWith (+)) [2,2,2]
13:48:04 <lambdabot>  [3,3,3]
13:48:27 <twobitwork> rwbarton: that defeats the purpose :P
13:48:47 <shachaf> > let (&) = flip id in [1,1,1] & zipWith (-)) [2,2,2]
13:48:47 <lambdabot> Unbalanced parentheses
13:48:56 <shachaf> > let (&) = flip id in [1,1,1] & (zipWith (-)) [2,2,2]
13:48:57 <lambdabot>  [1,1,1]
13:49:03 <rwbarton> oops
13:49:12 <Dynetrekk> therp: I'm a physics student (in fact, a physicist! in 3 weeks or so)
13:49:28 <shachaf> But you can use the same trick that some OCaml people use, which lets you use infix expressions, I think.
13:50:00 <byorgey> whee!
13:50:09 * byorgey dives into learning HXT
13:50:51 <pgavin> byorgey: in my experience haxml is nicer
13:51:03 <twobitwork> let zipAdd = zipWith (+) in [1,1,1] `zipAdd` [2,2,2]
13:51:04 <byorgey> pgavin: oh? why's that?
13:51:14 <dons> i like galois' 'xml' for littlejobs
13:51:19 * byorgey is open to anything at this point
13:51:20 * twobitwork smacks lambdabot 
13:51:23 <dons> haxml's popular though
13:51:24 <twobitwork> > let zipAdd = zipWith (+) in [1,1,1] `zipAdd` [2,2,2]
13:51:25 <twobitwork> :P
13:51:25 <lambdabot>  [3,3,3]
13:51:27 <dons> and updated today
13:51:29 <byorgey> dons: oh, I'll check that out too then
13:51:38 <pgavin> byorgey: hxt is really messy, and the division between arrows and functions isn't as well defined as it should be
13:51:43 <dons> cabal install xml; cabal install hxt; cabal install haxml
13:51:47 <byorgey> pgavin: fair enough
13:52:01 <byorgey> basically, I want to extract some information from some html
13:52:03 <pgavin> byorgey: the haxml combinators are really nice
13:52:33 <byorgey> but it's nice, well-formed html with lots of nice divs and stuff, so tagsoup feels a little messy and ad-hoc
13:52:50 <dons> yeah, if its well-formed you may as well parse it
13:52:58 <dons> rather than the sort of light tokenising tagsoup does
13:53:09 <dons> hexpat is another option
13:53:20 <dons> we've half a dozen xml libs now, yay :)
13:53:26 <byorgey> hehe
13:53:38 <pgavin> dons: I think there's a libxml2 wrapper somewhere, too
13:53:45 <byorgey> normally I'd say yay too, but right now I just need one ;)
13:54:04 <pgavin> dons: if not I was thinking about doing one to better integrate with gtk2hs
13:54:04 <therp> Dynetrekk: enjoy project euler, I'm heading to bed with a nice paper about types :)
13:54:12 <dons> yep, libxml
13:54:29 <dons> byorgey: if you've used tagsoup, galois xml is pretty close
13:54:34 <dons> you'll get a nice xml parse tree
13:54:41 <Dynetrekk> therp: types?
13:54:43 <dons> haxml is a bit bigger, but more thorough
13:54:52 <Dynetrekk> therp: okay, have a good night
13:54:59 <pgavin> haxml is still smaller than hxt
13:55:10 <byorgey> dons: ok, and are there nice combinators for saying things like "give me any text inside a "div class=foo" tag anywhere in this tree"?
13:55:12 <Botje> quick reminder: download ff3 today, they're going for the world record of "software most downloaded in a single day"
13:55:24 <pgavin> byorgey: yes, pretty much
13:55:24 <dons> byorgey: hmm, maybe.
13:55:34 <byorgey> dons: I don't want to have to say "child $ child $ child" or whatever
13:55:39 <pgavin> byorgey: or you can assemble one easily
13:55:53 <Cale> I'll get it when it shows up in apt.
13:55:56 <nus> "Load all back ends into every instance of the compiler, and treat every compilation as a cross-compilation." -- fighting with "the root of all level"?
13:56:01 <byorgey> ok, well, I'll play with haxml and xml
13:56:17 <nus> s/level/evil/
13:57:16 * byorgey <3 cabal-install =)
13:57:16 <byorgey> cabal-install++
13:58:13 <monochrom> both haxml and hxt have "search the whole tree for predicate"
13:58:26 <Twinside> hi
13:58:37 <sjanssen> @karma cabal-install
13:58:37 <lambdabot> cabal-install has a karma of 1
13:59:14 <twobitwork> I just had a program compiled with ghc segfault... :(
13:59:18 * twobitwork is traumatized
14:00:12 <twobitwork> and its just a 3 liner with no weirdness
14:00:25 <jadrian> twobitwork: wow :)
14:00:25 <vixey> why don't you paste it here
14:01:57 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8386
14:02:02 <twobitwork> http://hpaste.org/8386
14:02:06 <twobitwork> ohh :P
14:02:11 <monochrom> traumatization prevents the victim from doing anything.
14:03:31 <pgavin> > let fibs = 1 : 1 : zipWith (
14:03:31 <lambdabot> Unbalanced parentheses
14:03:34 <pgavin> doh :)
14:03:51 <pgavin> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 1000 fibs
14:03:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:04:24 <pgavin> twobitwork: that's funny though, you never even look at x in your code
14:04:41 <twobitwork> yeah
14:04:44 <pgavin> you might as well have done: do x <- undefined ; putStrLn "."
14:05:00 <pgavin> well, maybe do x <- return undefined ; ...
14:05:05 <rwbarton> twobitwork: that shouldn't even compile, take 1000 fib is not of type IO a
14:05:08 <twobitwork> well... wouldn't that still force evaluation of the first 1000 fibs?
14:05:24 <pgavin> rwbarton: lol, good point
14:05:35 <pgavin> twobitwork: no, none of it
14:05:39 <byorgey> hi Twinside
14:05:41 <twobitwork> rwbarton: ohh... right... for some reason I was thinking it would work like a list monad, but I guess I forgot main is always IO
14:05:44 <pgavin> twobitwork: only if you pattern match against it
14:06:28 <jadrian> twobitwork: even if it wastn't main
14:06:36 <jadrian> twobitwork: you end with an IO expression
14:06:38 <pgavin> twobitwork: you'd have to do something like depSeq to force the whole list
14:06:41 <twobitwork> jadrian: ah, of course :)
14:06:44 <rwbarton> twobitwork: Well, technically you're right in the sense that the compiler fails on the next line: putStrLn doesn't have type [()]
14:06:59 <BMeph>  Botje: Looks like FF/Moz isn't getting their wish; "Http/1.1 Service Unavailable"
14:07:03 <monochrom> I do not get a segfault.
14:07:15 <byorgey> of course, none of this should cause a ghc segfault!
14:07:19 <byorgey> twobitwork: what version of ghc?
14:07:25 <jadrian> I'm still wondering how that even compiled
14:07:34 <Botje> BMeph: yeah. keep trying
14:07:35 <twobitwork> $ ghc --version
14:07:35 <twobitwork> The Glorious Glasgow Haskell Compilation System, version 6.8.2
14:07:37 <jadrian> twobitwork: sure you compiled that??
14:07:46 <Botje> it's been downloaded 1.5M times in the past four hours
14:07:50 <byorgey> twobitwork: I have 6.8.2 as well, and I get a normal compile error, not a segfault
14:07:56 <Botje> it's averaging 8000 downloads per minute :)
14:08:22 <twobitwork> I ran ghc --make test.hs -o test
14:08:29 <pgavin> Botje: where did you get that info from?
14:08:43 <Botje> http://downloadcounter.sj.mozilla.com/
14:08:53 <Botje> no idea on how accurate it is or even if it's connected to real world data
14:08:55 <Botje> but it sure looks cool
14:09:04 <pgavin> wow, nice
14:09:12 <monochrom> Mozilla sets the record for the longest down time.
14:09:13 <pgavin> 10,000 per minute
14:09:19 <dafra> is there a good tutorial for \bot commands ?
14:09:28 <byorgey> twobitwork: yup, I still get a normal compile error
14:09:36 <byorgey> @list
14:09:36 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:09:40 <dafra> i discover a new one each time i log on here :)
14:09:43 <pgavin> interesting, china is only downloading 8 per minute
14:09:45 <byorgey> dafra: there's no tutorial, but there's a list
14:10:08 <Botje> given that it's early morning there
14:10:14 <Botje> give it some time :)
14:10:28 <pgavin> Botje: yeah, they need to be awake to download :)
14:10:34 <dafra> i know this list : scarse doc ...
14:10:48 <dafra> what's karma ?
14:10:57 <dafra> @karma dafra
14:10:58 <lambdabot> You have a karma of 0
14:11:12 <BMeph> Impressive - five minutes to connect. :p
14:11:18 <dafra> great ! i will reincarnate into rabbit crap ...
14:11:21 <ahunter_> pgavin: sez who?  wget <url> || { sleep 60; /this_file.sh } or something similar :P
14:11:37 <pgavin> ahunter_: fair enough :)
14:11:51 <pgavin> ahunter_: ok, they need to either be awake or have planned ahead :)
14:12:02 <ahunter_> Be Prepared :P
14:12:03 <dafra> @hem
14:12:04 <lambdabot> Maybe you meant: help let temp
14:12:06 <dafra> @help
14:12:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:12:09 <pgavin> or have stayed up all night :)
14:12:25 <byorgey> dafra: well, if you would like to reincarnate into something better, just be generally helpful around here and someone will give you some karma points =)
14:12:51 <dafra> i see : how to give karma points ?
14:13:02 <dafra> @karma byorgey +1
14:13:03 <lambdabot> byorgey has a karma of 13
14:13:09 <byorgey> for example, I have gained enough points to reincarnate into a nematode!
14:13:13 <byorgey> woo!
14:13:30 <byorgey> dafra: you can either  @karma+ nick,  or just nick++
14:13:53 <dafra> @karma byorgey++
14:13:53 <lambdabot> byorgey++ has a karma of 0
14:14:01 <pgavin> @karma pgavin
14:14:01 <lambdabot> You have a karma of 0
14:14:02 <dafra> @karma+ byorgey
14:14:02 <lambdabot> byorgey's karma raised to 14.
14:14:03 <byorgey> but not both at once =)
14:14:11 * pgavin will still be a newt in the next life
14:14:31 <byorgey> are you kidding? you need 375 points to be a newt
14:14:37 <dafra> lol
14:14:49 <pgavin> lol
14:14:54 <dafra> i wanna be a master mind flayer
14:14:56 <byorgey> and at 10,000 points you can get an HDTV
14:15:36 <pgavin> I see the dollar is still worth more than a karma point (for the time being)  :)
14:16:09 <dons> hehe
14:16:19 <pgavin> how many karma points gets me a gallon of gas?
14:16:51 <dafra> @localtime
14:16:53 <lambdabot> Local time for dafra is mardi 17 juin 2008 23:16:43
14:16:59 <dafra> great !
14:17:12 <pgavin> @localtime
14:17:13 <lambdabot> Local time for pgavin is Tue Jun 17 17:17:12 2008
14:17:21 <pgavin> dafra: french?
14:17:31 <dafra> yes, almost bed time
14:17:51 <ahunter_> @localtime
14:17:51 <dafra> France anyway, but Italian bought the arbiter
14:17:52 <lambdabot> Local time for ahunter_ is 2008-06-17 14:17:08 -0700
14:18:00 <pgavin> dafra: I have family over there :)
14:18:10 <dons> ghc 6.8.3 released.
14:18:15 <pgavin> dons: yay :)
14:18:17 <dafra> most american come from europe :)
14:18:26 <dafra> @djinn
14:18:27 <lambdabot> Cannot parse command
14:18:28 <pgavin> dons: I can release gtk2hs 0.9.13 now :)
14:18:35 <pgavin> dafra: yes, that's true
14:18:44 <dafra> 6.8.3 : joy !
14:18:53 <pgavin> dafra: my mom was born in paris, though :)
14:18:56 <dafra> @karma+ dons
14:18:56 <lambdabot> dons's karma raised to 143.
14:18:58 <BMeph> pgavin, dafra: Really, I thought most Americans came from America... ;p
14:19:03 <pgavin> @karma+ dons
14:19:03 <lambdabot> dons's karma raised to 144.
14:19:07 <dons> dafra: i didn't release it.
14:19:08 <dons> Igloo++ did
14:19:20 <pgavin> @karma+ Igloo
14:19:21 <lambdabot> Igloo's karma raised to 16.
14:19:23 <dafra> dons: i just discovered 'karma'
14:19:29 <dons> hehe
14:19:41 <dafra> gavin doesnt look cheyenne
14:19:54 <dafra> @eval 1+1
14:19:55 <pgavin> no, I definitely do not :)
14:20:05 <dafra> @eval toto
14:20:09 <dafra> @eval
14:20:13 <dafra> huh ?
14:20:14 <pgavin> @help eval
14:20:14 <lambdabot> eval. Do nothing (perversely)
14:20:24 <pgavin> > 1+1
14:20:25 <lambdabot>  2
14:20:48 <dafra> @pointful (+)
14:20:48 <lambdabot> (+)
14:20:51 <nus> @where STG
14:20:51 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
14:20:56 <dafra> not very pointful ...
14:21:00 <mrd> pure lazy evaluation is a perverse way of doing nothing, indeed
14:21:35 <pgavin> mrd: it's like quantum mechanics.... it changes when you look at it
14:21:55 <nus> citeseer AWOL, or my ISP misbehaving /-:
14:21:57 <dons> http://www.reddit.com/info/6nsts/comments/
14:21:57 <lambdabot> Title: reddit.com: Go, go go! GHC version 6.8.3 out now.
14:22:09 <monochrom> onoes
14:22:14 <pgavin> today must be release day
14:22:16 <dons> super busy day.
14:22:20 <dafra> spj just said in haskell cafe that ms has a new intern to refactor the optimizer ...
14:22:21 <pgavin> for every package out there
14:22:40 <mrd> ghc is by far the most popular
14:22:55 <dafra> there are other compilers ? :)
14:22:56 <pgavin> mrd: even over mozilla?
14:23:08 <monochrom> Ian released GHC in time to watch Euro himself :)
14:23:18 <mrd> mozilla, shmozilla
14:23:40 <pgavin> mrd: :)
14:23:59 <dafra> i've been using ghc for 1 month, and it is already improving
14:24:08 <dafra> how often do they release ?
14:24:11 <Botje> is GHC competing with mozilla on most downloads? ;)
14:24:14 <dons> seriously, we don't stop.
14:24:28 <Botje> hmm
14:24:33 <Botje> the ghci config file thing is cool
14:24:34 <dons> this is how open source can mow down the competition
14:24:37 <Botje> did they take vista into account?
14:24:43 <dons> an unrelenting onslaught of code.
14:24:46 <Botje> where it's C:/Users/user/.... ?
14:24:49 <dafra> competition with whom ?
14:25:11 <dons> meanwhile the ivory towers of F# , OCaml, et al spin on their chairs. :)
14:25:24 <dons> bazaars beat cathedrals
14:25:26 <dafra> ocaml is a joke on windows, and mercury's documentation and syntax looks like 70's, so ghc is alone
14:25:34 <mrd> ivory is an awfully expensive material to build a tower from
14:25:38 <dafra> f# is good
14:25:41 <pgavin> mercury isn't really functional...
14:25:48 <dafra> why ?
14:25:48 <lament> it's not really ivory
14:25:58 <lament> it's plastic that's supposed to feel just like ivory
14:26:03 <dafra> mercury is a pain for HOF
14:26:13 <lament> ivory is prohibited by law anyway
14:26:29 <monochrom> ghc is not a small bazaar.
14:26:38 <mrd> is it a bizarre bazaar?
14:26:40 <dafra> @slap
14:26:40 * lambdabot puts on her slapping gloves, and slaps
14:26:46 <dafra> lol
14:26:56 <dafra> @slap pgavin
14:26:56 <lambdabot> I don't perform such side effects on command!
14:27:12 * pgavin says oww and rubs his cheek
14:27:13 <mrd> @do slap pgavin
14:27:14 <lambdabot> slap pgavin not available
14:27:30 <Botje> what's with that bytestring version?
14:27:37 <Botje> isn't 0.9.0.4 out?
14:27:45 <dafra> @tell pgavin hello
14:27:45 <lambdabot> Consider it noted.
14:27:55 <pgavin> uhh
14:27:56 <lambdabot> pgavin: You have 1 new message. '/msg lambdabot @messages' to read it.
14:28:01 <pgavin> @messages
14:28:01 <lambdabot> dafra said 16s ago: hello
14:28:02 <dafra> @undo
14:28:02 <lambdabot> ()
14:28:22 <dafra> @undo
14:28:22 <lambdabot> ()
14:28:28 <pgavin> @help
14:28:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:28:44 <dafra> wow
14:28:47 <dafra> @vixen
14:28:47 <lambdabot> I dunno
14:28:54 <dafra> ...
14:29:09 <dafra> @vixen pamela anderson
14:29:10 <lambdabot> why do you look like ham?
14:29:14 <shapr`> Does anyone know what happened to TheHunter, aka Thomas Jaeger?
14:29:14 <monochrom> ghc source code is five times larger than extralibs source code. it is a cathedral. ghc proves that cathedral can also enjoy lively development.
14:29:33 <dons> shapr`: moved the US to do a math degree
14:29:38 <dons> couple of years ago
14:29:48 <dons> haven't heard from him since. some small web presence (michigan?)
14:29:51 <shapr`> I thought he was around Boston somewhere, just wondering if I could track him down to come to the next CHUG.
14:29:58 <dafra> ghc has tons of contributors
14:30:14 <shapr`> Ah, Michigan?
14:30:15 <monochrom> Yes.
14:30:20 <dons> the key though is the ecosystem of tools and libraries around ghc. all interconnected community efforts
14:30:20 <dafra> @version
14:30:21 <lambdabot> lambdabot 4p664, GHC 6.8.2 (Linux i686 2.40GHz)
14:30:21 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:30:30 <pgavin> the compiler proper is probably more cathedralish, the libraries are more bazaarish
14:30:35 <monochrom> ghc proves that everything said about bazaar applies to cathedral too.
14:30:46 <dons> if ghc is the town hall, hackage is the bazaar surrounding it, where you can buy and sell almost anything,
14:30:54 <shapr`> Yeah, the Linux kernel is one project, but not a cathedral.
14:31:11 <dafra> linux is mountain of patches
14:31:30 <pgavin> darcs is a mountain of patches :)
14:31:49 <pgavin> actually, darcs is a corrupter of patches, but I digress...
14:31:54 <dafra> @pretty 1  +          1
14:31:54 <lambdabot>  1 + 1
14:32:03 <dons> pgavin: grab darcs 2.0. remarkably stable
14:32:13 <dons> i've had *0* problems since I switched
14:32:16 <pgavin> dons: it still won't pull haddock's repo :/
14:32:19 <dafra> darc is mountain of patches manager
14:32:22 <shapr`> I haven't had time to try darcs 2.0 :-(
14:33:02 <dafra> i've read doc for darcs 2.0, i will skip darcs 1
14:33:20 <dons> now if only one could cabal install darcs.
14:33:22 <dons> grumble
14:33:36 <monochrom> cabal-install cabal-install
14:33:47 <Botje> fix cabal-install
14:33:52 <pgavin> cabal-install: <<loop>>
14:33:52 <dons> works.
14:33:58 * BMeph just did that a couple of hours ago
14:34:06 <monochrom> darcs pull darcs
14:34:18 <dons> every self respecting distro should have cabal-install in it by the end of the week.
14:34:19 <u_quark> how can i send messages between threads ?
14:34:29 <dons> if you're in a position to ensure that happens, get to it!
14:34:32 <pgavin> u_quark: MVars?
14:34:38 <sjanssen> u_quark: probably Control.Concurrent.Chan
14:34:49 <sjanssen> u_quark: but there are loads of other options, MVars, STM, etc.
14:34:51 <dafra> @ft
14:34:54 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
14:34:54 <lambdabot>  Press `:help' for help or `:quit' to quit.
14:34:54 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
14:34:54 <lambdabot>  > > >
14:35:11 <Ugarte> Jesus Christ.
14:35:16 <dafra> i(ll try this another day ....
14:35:20 <Ugarte> One of my ex-coworkers is amazingly good at creating bizarre errors.
14:35:24 <Ugarte> Er, wrong channel.
14:35:29 <u_quark> hhhmmm in an event based manner ?
14:35:34 <pgavin> hmm, I take that back about darcs-2.0 not pulling haddock.. it just did, but wouldn't before
14:35:46 <monochrom> Your ex-co-worker is a haskell newbie.
14:36:29 <pgavin> I wonder if the repo was corrupted momentarily
14:37:25 <pgavin> hmm, has anyone been able to compile ghc with threading support?
14:37:49 <dons> ghc 6.8.3?
14:37:54 <dons> it should be built -threaded by default.
14:37:55 <u_quark> pgavin, sjanssen tnx allot! I will use those...
14:37:58 <dafra> @more
14:38:18 <pgavin> dons: hmm, ghc-6.8.2 wouldn't compile -threaded for me
14:38:28 <dafra> @haddock map
14:38:28 <dons> oh, 6.8.2, certainly
14:38:28 <lambdabot> Unknown command, try @list
14:38:36 <pgavin> dons: I'm compiling 6.8.3 as we speak, I'll let you know
14:38:51 <dafra> @hoogle map
14:38:51 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
14:38:52 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
14:38:52 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
14:39:12 <dafra> @dice
14:39:13 <lambdabot> unexpected end of input: expecting number
14:39:17 <dafra> @dice 6
14:39:18 <lambdabot> 6 => 6
14:39:22 <dafra> @dice 6
14:39:22 <lambdabot> 6 => 6
14:39:26 <dafra> @dice 10
14:39:26 <lambdabot> 10 => 10
14:39:28 <dafra> @dice 10 1
14:39:28 <lambdabot> 10 1 => 101
14:39:36 <dafra> @dice 6 5 4
14:39:36 <lambdabot> 6 5 4 => 654
14:39:49 <dafra> what's the point of dice ?
14:39:57 <pgavin> @help dice
14:39:57 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
14:40:05 <pgavin> @dice 2d4
14:40:05 <lambdabot> 2d4 => 3
14:40:11 <dafra> ok
14:40:14 <pgavin> @dice 3d20
14:40:15 <lambdabot> 3d20 => 38
14:40:16 <leoncame1> hmm, a stupid question, operator "+" is a monad . right ?
14:40:24 <dafra> no
14:40:25 <pgavin> dafra: it's for DnD players only :)
14:40:26 <dafra> a function
14:40:39 <dafra> i know d20
14:40:48 <dafra> i've used them for many role games
14:40:59 <leoncame1> dafra: you mean operator + is a function ?
14:41:00 <pgavin> leoncame1: a monad isn't really an object per-se
14:41:13 <dafra> operators are infix functions
14:41:20 <pgavin> > 1 + 1
14:41:22 <lambdabot>  2
14:41:24 <pgavin> > (+) 1 1
14:41:25 <lambdabot>  2
14:41:28 <dafra> > (+) 1 1
14:41:29 <lambdabot>  2
14:41:45 <dafra> mod 4 3
14:41:46 <pgavin> > foldl (+) 0 [1..10]
14:41:51 <lambdabot>  55
14:42:03 <leoncame1> pgavin: hmm,yes. but, we can write "1 + 1 + 1".
14:42:07 <dafra> 4 `mod` 3
14:42:11 <dafra> > 4 `mod` 3
14:42:12 <lambdabot>  1
14:42:17 <dafra> > mod 4 3
14:42:17 <mar77a> >  hi <- return "hi"; putStrLn hi;
14:42:18 <lambdabot>  Parse error at "<-" (column 4)
14:42:18 <lambdabot>  1
14:42:30 <mar77a> > hi <- return "hi"; putStrLn hi;
14:42:30 <lambdabot>  Parse error at "<-" (column 4)
14:42:38 <mar77a> > hi <- (return "hi"); putStrLn hi;
14:42:38 <pgavin> > do hi <- return "hi" ; putStrLn hi
14:42:38 <lambdabot>  Parse error at "<-" (column 4)
14:42:39 <lambdabot>  <IO ()>
14:42:40 <Socrates> 1 + 1 + 1 = (1 + 1) + 1 or (+) ((+) 1 1) 1
14:42:48 <mar77a> ah right
14:42:58 <leoncame1> ok. I got it .
14:43:01 <pgavin> > unsafePerformIO $ do hi <- return "hi" ; putStrLn hi
14:43:02 <lambdabot>   Not in scope: `unsafePerformIO'
14:43:05 <pgavin> doh :)
14:43:06 <dafra> do { let hi = "hi"; putStrLn hi}
14:43:12 <Socrates> > (+) ((+) 1 1) 1
14:43:13 <lambdabot>  3
14:43:34 <dafra> > do { let hi = "hi"; putStrLn hi}
14:43:34 <lambdabot>  Parse error at "}" (column 32)
14:43:38 <dafra> > do { let hi = "hi"; putStrLn hi }
14:43:38 <lambdabot>  Parse error at "}" (column 33)
14:43:39 <pgavin> leoncame1: right, you can do that, but that doesn't make + a monad
14:43:53 <dafra> > do let hi = "hi" in putStrLn hi
14:43:55 <lambdabot>  <IO ()>
14:43:55 <leoncame1> what is the magic point of monad ? for example ..
14:43:58 <pgavin> it would have to be (+) :: a -> a -> IO a
14:44:06 <pgavin> for example
14:44:15 <dafra> monads are programmable semicolons
14:44:21 <pgavin> dons: utils/Binary.hs:462:13: Not in scope: data constructor `S#'
14:44:45 <dafra> usually semicolons means sequencing, like in imperative languages
14:45:10 <dafra> but other behaviours are possible : backtracking, state hiding, etc.
14:45:20 <pgavin> a monad is a universe in which sequencing makes sense
14:45:33 <pgavin> to put it abstractly
14:45:43 <dafra> leoncame1 : new to haskell ?
14:46:02 <leoncame1> dafra: yes.. newbie ..
14:46:09 <dafra> me too
14:46:19 <pgavin> @src Monad
14:46:19 <lambdabot> class  Monad m  where
14:46:19 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:46:19 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:46:19 <lambdabot>     return      :: a -> m a
14:46:19 <lambdabot>     fail        :: String -> m a
14:46:26 <dafra> a few weeks old, and still struggling a bit with monads
14:46:37 <dafra> do you know Real World Haskell ?
14:46:37 <pgavin> so the 'm' in 'm a' is the monad type
14:46:44 <dafra> its the best tutorial (by far)
14:46:54 <dafra> http://www.realworldhaskell.org/blog/
14:46:56 <lambdabot> Title: Real World Haskell
14:46:56 <pgavin> it's like a one-way box
14:47:06 <leoncame1> :).. I am heavily influenced by impreative languages .. :(..
14:47:26 <pgavin> the only way to get stuff out of the box is to give it a function that ends up putting it in a new box
14:47:37 <dafra> this tutorial is good for that
14:47:40 <pgavin> that's what >>= is for
14:47:52 <dafra> scoll down a bit, there are sample chapters for comment
14:48:00 <dafra> strat from chapter 1 ...
14:48:07 <leoncame1> dafra: yes. I know.. it is a great book . but, currently , I am reading <<All About Monads>>
14:48:23 <pgavin> I really think monads would make more sense if you knew about arrows first
14:48:24 <dafra> all about monads is tough
14:48:33 <leoncame1> what does the "return" mean ?
14:48:35 <pgavin> arrows are more complicated to implement, but easier to understand
14:48:38 <leoncame1> exactly ?
14:48:43 <dafra> the examples with continuations are frightening
14:48:44 <pgavin> leoncame1: it lifts a value into the monad
14:48:51 <dafra> lol
14:49:03 <leoncame1> something like, override the "return" operator ?
14:49:06 <roconnor> pgavin: I sort of agree.  The idea of the Kleisi arrow is a very important to know about when working with monadic code.
14:49:21 <dafra> btw, how did you all learnt haskell : i learnt on the net only
14:49:22 <monochrom> haskell's "return" is not the same as C's "return".
14:49:32 <dafra> and a book (craft of functional programming)
14:49:46 <Socrates> Hmm, to be honest, every Monad tutorial I've seen online has been awful
14:49:58 <Peaker> is Control.Applicative.liftA2 the same as: \f b c -> (f <$> b <*> c) ?
14:50:03 <dafra> real world haskell is good for monads too
14:50:06 <DRMacIver> So, um, why does this happen:
14:50:10 <DRMacIver> > (>)
14:50:11 <lambdabot>  <() -> () -> Bool>
14:50:13 <DRMacIver> Oh
14:50:19 <DRMacIver> That wasn't the "this" that was supposed to happen. :)
14:50:23 <pgavin> sometimes it helps to show someone the FFI when explaining monads
14:50:27 <roconnor> Peaker: yes
14:50:33 <roconnor> @src liftA2
14:50:33 <lambdabot> liftA2 f a b = f <$> a <*> b
14:50:36 <Peaker> oh
14:50:39 <Peaker> heh
14:50:46 <Peaker> why is it defined? Its yucky :)
14:50:46 <pgavin> because IO a is sorta like a C function pointer to void f (a)
14:50:56 <dafra> @src <*>
14:50:56 <lambdabot> Source not found. stty: unknown mode: doofus
14:51:02 <dafra> @src (<*>)
14:51:03 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:51:03 <pgavin> lol
14:51:04 <leoncame1> OK. for example. if I want write a program to "decode" complex network packet. what Can I do with monad ?
14:51:11 <pgavin> @src Applicative
14:51:12 <lambdabot> class Functor f => Applicative f where
14:51:12 <lambdabot>     pure  :: a -> f a
14:51:12 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:51:21 <Peaker> dafra, liftA2 is a function, but (<*>) is a method
14:51:35 <pgavin> leoncame1: if you already have the packet, you should be able to decode it without a monad
14:51:40 <dafra> Haskell has methods ???
14:51:51 <pgavin> dafra: sorta
14:51:51 <Peaker> dafra, the things that classes have are "methods"
14:51:59 <dafra> ah ! ok
14:52:20 <dafra> not really like OOP because binding is static
14:52:23 <Peaker> dafra, methods don't have "source code" but each instance of a class will have a function for each of the class's methods
14:52:38 <Peaker> dafra, with existential types and Typeable it can be dynamic too
14:52:43 <pgavin> @src (Applicative IO)
14:52:43 <lambdabot> Source not found. Do you think like you type?
14:52:45 <dafra> yes classes are like OOP interfaces
14:52:57 <dafra> @src IO Applicative
14:52:57 <lambdabot> Source not found. Take a stress pill and think things over.
14:53:16 <Socrates> @src IO (<*>)
14:53:16 <lambdabot> (<*>) = ap
14:53:16 <pgavin> dafra: IO is an instance of Applicative, not vice-versa
14:53:17 <dafra> \bot once called me an untyped fool :)
14:53:22 <Peaker> I think Haskell should consider the use of specific-type functions as bad style, and always have class-specific code rather than type-specific code
14:53:25 <pgavin> Socrates: ahah :)
14:53:40 <dafra> yes, dont you put the instance first in @src ?
14:53:56 <dafra> @src Maybe return
14:53:57 <lambdabot> return              = Just
14:53:57 <leoncame1> OMG, I hope I could forget all about programming language I learned before. then, I could study haskell....
14:54:05 <pgavin> dafra: ah, ok, sorry :)
14:54:21 <Peaker> there should be a Bool class with True and False, and BoolType should be an instance of it, for example. Functions should return a (Bool a => a) and not a BoolType
14:54:39 <pgavin> Peaker: performance would die :/
14:54:44 <Socrates> Hmm, what else would by an instance of Bool class then?
14:54:47 <pgavin> Peaker: unless you specialized everything
14:54:53 <Peaker> pgavin, Hopefully the compiler did just that :)
14:55:01 <dafra> Peaker, you should learn prototype languages : lisaac, diesel
14:55:04 <glguy> bos: How long does it usually take for something like GHC 6.8.3 to get into updates-testing?
14:55:04 <Peaker> pgavin, it does this already for class Num, does performance die?
14:55:15 <pgavin> Peaker: I suppose not :)
14:55:16 <Peaker> dafra, I'll add them to my todo list
14:55:31 <dafra> Lissac does that and is as fast a C
14:55:32 <pgavin> Socrates: have you ever used verilog or vhdl?
14:55:42 <Socrates> 'fraid not
14:55:44 <dafra> Lisaac is about first at the shootout
14:55:46 <Peaker> pgavin, a few points that still use types rather than classes make some things in FRP and other places ugly (need to use >. instead of > for example)
14:55:50 <dafra> but the syntax sucks
14:55:58 <pgavin> Socrates: there are "boolean" types that have values other than "true" and "false"
14:56:00 <bos> glguy: i would be ready to push that to updates-testing today, but i have a haddock problem.
14:56:07 <pgavin> Socrates: the other values or non-determinate, though
14:56:22 <bos> glguy: fedora ships with haddock 2.0.0.0, and ghc will only build with haddock 0.9.
14:56:40 <bos> glguy: so until someone reviews my backport of haddock 0.9, ghc 6.8.3 is blocked.
14:56:46 <glguy> ew
14:56:49 <pgavin> Socrates: e.g. X represents unknown, and True && X = X, False && X = X, etc
14:56:56 <Socrates> I see.
14:57:16 <monochrom> Too much generality is unfriendly to newbies.  E.g., Q: "how do you get 'true and true = true' in haskell?"  A: "see this tutorial on Stone duality"
14:57:28 <Socrates> I think learning Haskell is probably hard enough as it is, without littering the prelude with BoolType, but I understand the reasoning behind your idea
14:57:31 <bos> glguy: and package reviewer cycles are generally really hard to get.
14:57:37 <glguy> bos: Alright. Thanks for your proactive RPM creation anyway!
14:57:46 <mrd> monochrom: what's 'true and true = true'?
14:57:59 <dafra> i wonder how easy it must be to learn as a first language
14:58:14 <dafra> should be fine
14:58:26 <lament> everything is hard to learn as a first language.
14:58:28 <monochrom> mrd: do you know stone-cech topologies?
14:58:31 <pgavin> I think scheme should be the first language taught to anyone
14:58:34 <dafra> Can Haskell be a first language ?
14:58:35 <mrd> nope
14:58:35 <Socrates> In the same sense that map is defined in the prelude, instead of requiring learners to grapple functors
14:58:40 <pgavin> since you can go any direction from there
14:58:46 <monochrom> nevermind, joke.
14:58:49 <dafra> Is it possible to learn Haskell as a first language ?
14:58:57 <monochrom> Yes.
14:58:57 <lament> pgavin: you can only go in the direction of decreasing parentheses.
14:59:03 <pgavin> lament: lol, true
14:59:04 <dafra> \bot is off ?
14:59:18 <pgavin> > "working"
14:59:19 <lambdabot>  "working"
14:59:23 <dafra> Is it possible to learn FP with Haskell  ?
14:59:25 <mrd> @bot
14:59:25 <lambdabot> :)
14:59:37 <byorgey> pgavin: the haxml combinators are nice indeed!  I just can't figure out how to get from the output of htmlParse (Document something blah) to something I can actually manipulate with the combinators.  any hints?
14:59:39 <dafra> Is it possible to make coffee with Haskell  ?
14:59:39 <mrd> dafra: is it possible to not learn FP with haskell?
14:59:53 <mrd> extensive use of unsafePerformIO
14:59:54 <Socrates> @faq Can haskell help me make coffee?
14:59:55 <lambdabot> The answer is: Yes! Haskell can do that.
14:59:59 <dafra> ah :
15:00:09 <dafra> \bot was slow on this one
15:00:42 <EvilTerran> mrd, extensive use of IORefs, forM_, etc would be enough
15:00:45 <dafra> @faq
15:00:45 <lambdabot> The answer is: Yes! Haskell can do that.
15:00:58 <mrd> EvilTerran: but it's functional..
15:01:07 <dafra> @faq does SPJ eat frogs ?
15:01:07 <lambdabot> The answer is: Yes! Haskell can do that.
15:01:18 <EvilTerran> yes, it would still teach the use of such things as strict typing and lexical scoping and whatnot
15:01:22 <pgavin> byorgey: you have to break apart the Document using pattern matching
15:01:31 <EvilTerran> but it'd still be writing in a fundamentally imperative way
15:01:34 <shapr`> There were those guys who wrote erlang successfully in Haskell.
15:01:40 <shapr`> I forget what they were writing...
15:01:53 <mrd> channels are ok
15:01:56 <dafra> a real programmer can write Erlang in any language :)
15:02:00 <mrd> but did they do distributed stuff?
15:02:03 <pgavin> byorgey: http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text-XML-HaXml-Types.html#t%3ADocument
15:02:05 <lambdabot> http://tinyurl.com/5r4rqj
15:02:07 <EvilTerran> dafra, he can write any language in haskell, too :D
15:02:18 <pgavin> byorgey: you probably want the Element field
15:02:37 <dafra> its a classic joke, with Fortran
15:02:40 <byorgey> pgavin: ok, I see, and then I can further extract a list of Contents from that
15:02:45 <pgavin> byorgey: right :)
15:02:49 <byorgey> which the combinators actually apply to
15:02:56 <pgavin> yep
15:02:57 <byorgey> pgavin++
15:02:59 <byorgey> thanks =)
15:03:07 <pgavin> yay, my first karma :)
15:03:11 <pgavin> @karma
15:03:11 <lambdabot> You have a karma of 1
15:03:17 <pgavin> thanks byorgey :)
15:03:19 <dafra> what ?
15:03:22 <pgavin> you get one too
15:03:25 <pgavin> byorgey++
15:03:28 <lament> pgavin: it's a long road to becoming Buddha
15:03:29 <dafra> I gave you one karma tonite, my first one
15:03:31 <byorgey> hehe, awesome =)
15:03:33 <Peaker> I can finally use Reactive and its sample programs, whew :) Now to try to understand them...
15:03:35 <pgavin> lol :)
15:03:41 <dafra> @karma+ pgavin
15:03:41 <lambdabot> pgavin's karma raised to 2.
15:03:53 <dafra> didint work the first time ...
15:03:58 <pgavin> dafra: yay, 2 karma!
15:04:08 <dafra> @karma
15:04:08 <lambdabot> You have a karma of 0
15:04:11 <dafra> :(
15:04:16 <pgavin> dafra++
15:04:21 <dafra> :)
15:04:24 <pgavin> karma reciprocation :)
15:04:42 <dafra> karma must be like citation : you cite to be cited
15:05:01 <Peaker> I wish conal used qualified imports
15:05:09 <mrd> circular citation?
15:05:15 <dafra> dons had 130+ karma, and still pretty human
15:05:33 <pgavin> no, I think he said he's a nematode :)
15:05:36 <dafra> @karma
15:05:36 <lambdabot> You have a karma of 1
15:05:47 <dafra> what's a nematode ?
15:05:59 <byorgey> hehe, look it up on wikipedia =)
15:06:12 <dafra> @wikipedia nematode
15:06:12 <lambdabot> No Result Found.
15:06:29 <byorgey> @go nematode
15:06:30 <lambdabot> http://en.wikipedia.org/wiki/Nematoda
15:06:31 <pgavin> @wiki nematoda
15:06:31 <lambdabot> http://www.haskell.org/haskellwiki/nematoda
15:06:32 <dons> i'm a pretty human?
15:07:09 <jaj> hehe I just had an infectiology exam this morning :)
15:07:24 <dafra> that's disgusting
15:07:46 <dafra> @help go
15:07:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:07:48 <pgavin> ok, gotta go now
15:07:54 <pgavin> thanks for that karma guys :)
15:07:55 <dafra> go = google ?
15:08:01 <jaj> no! exam as in writing an exam
15:08:15 <jaj> a test
15:09:04 <byorgey> dafra: indeed
15:09:14 <dafra> your mothe ris so dumb that she failed her urin exam (dont the right english phrasing)
15:09:55 <jaj> dafra: yeah :) I meant exam as in assessment
15:10:37 <dafra> @go ghc 6.8.3
15:10:40 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/2318
15:10:40 <lambdabot> Title: #2318 (building GHC 6.8.3 Release Candidate 6.8.2.20080527 under PC solaris fail ...
15:11:12 <dafra> its a bug ticket :)
15:17:31 <Peaker> why does a lazy language need mapM_ and other func_'s? Can't laziness take care of the lack of access to the result?
15:18:25 <dons> :t mapM
15:18:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:18:35 <dons> :t mapM_
15:18:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:19:41 <BMeph> Peaker: They calculate the "shape" of the result, while throwing away the values. Otherwise, laziness would say not to even bother doing the calculation. :)
15:20:06 <Saizan> Peaker: monadic code introduces more data dependencies in general
15:20:29 <Peaker> but why not use mapM instead of mapM_ and just let it throw it away as it is unused?
15:20:29 <BMeph> It reminds me of a definition I made up as a teen-ager: "Laziness: The quality of avoiding doing other people's work." ;)
15:21:03 <BMeph> Peaker: If it is unused, then why do the calculation? :)
15:21:27 <Saizan> ?src sequence
15:21:27 <lambdabot> sequence []     = return []
15:21:27 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:21:27 <lambdabot> --OR
15:21:27 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:21:31 <Saizan> ?src sequence_
15:21:31 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:21:53 <Peaker> BMeph, m [b] is used, but b isn't
15:22:53 <Peaker> holding a thunk that would make a b is more expensive than a thunk to a () ?
15:24:35 <monochrom> Many >>='s are eager.
15:26:01 <Saizan> also sequence_ is essentially tail-recursive
15:27:12 <roconnor> @src sequence_
15:27:12 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:29:52 <dafra> anybody working on a compiler for the CLR ?
15:30:09 <BMeph> dafra: Not even MS, heh-heh. ;)
15:30:16 <dafra> :(
15:30:26 <dafra> not yet hopefully
15:32:20 <dafra> the Java guys have Scala and Cal, we .Net pogrammers only have F#, I'm jealous
15:38:42 <nus> so, being strict means being sequenced?
15:39:10 <shapr`> So block structured heaps are basically 'have your own memory manager' yeah?
15:39:16 <monochrom> I don't know what the question means.
15:40:06 <shapr`> nus: In what context?
15:40:23 <nus> shapr, partial evaluation
15:40:52 <shapr`> um
15:40:58 <pejo> nus, a function f is strict if f \bot = \bot
15:41:26 <nus> ie fixpoint?
15:41:41 <pgavin> no, \bot == bottom == undefined
15:41:49 <pgavin> essentially
15:42:32 <pgavin> if you call a function f with a parameter whose value is undefined, and f's result is undefined, then we'd call f a strict function
15:43:04 <pgavin> a function can be strict in one or more (or none) of its arguments
15:43:17 <pgavin> or even only part of one argument
15:43:43 <pgavin> e.g. the length function is strict in the spine of the list, but not the values kept in the list
15:43:49 <pgavin> e.g.:
15:43:57 <pgavin> > length [undefined, undefined, undefined]
15:44:01 <lambdabot>  3
15:45:14 <pgavin> so strictness is not necessarily a yes or no answer
15:45:15 <shapr`> Would there be any advantage in using bloom filters for garbage collection? I know you can swap them around to get only false negatives...
15:46:10 <pgavin> shapr`: how do you remove the garbage from the set?
15:46:12 <nus> pgavin, don't you need to evaluate something to define? i.e. undefined ~~ not evaluated fully?
15:46:51 <monochrom> I think I'm lost.
15:47:06 <pgavin> nus: i don't understand your question - if undefined is ever evaluated, your program will die
15:48:09 <nus> what's the bottom limit of 'undefined'?
15:48:58 <pgavin> nus: what do you mean by bottom limit?
15:49:09 <shapr`> pgavin: I was thinking about using the bloom filter to quickly figure out if something has been evacuated.. but upon further thought, you already have pointer equality, so it's not useful unless it could be used as a cute way to hashconst :-)
15:50:36 <ahunter_> nus: the idea is like this
15:50:47 <ahunter_> nus: suppose I have an expression (f x) and f is strict
15:51:00 <ahunter_> nus: remember, f strict ==> f \bot = \bot
15:51:19 <pgavin> and id :: a -> a is the canonical strict function
15:51:24 <ahunter_> so it's safe to evaluate x first--if x is \bot, then f x would be too
15:51:58 <ahunter_> if f was lazy, then that wouldn't be safe, because f _ = <something> would still have a useful value, even if x diverged
15:53:19 <BMeph> Is "\bot" some kind of quasi-Tex referrent? :)
15:53:34 <monochrom> Yes.
15:53:44 <pgavin> I dunno, I usually use \perp for that symbol
15:54:00 <monochrom> _|_ or ⊥
15:54:06 <byorgey> \bot is usually used around here to refer to lambdabot =)
15:54:25 <monochrom> When Will IRCing Be Liberated from The ASCII Keyboard?
15:54:25 <pgavin> is \bot valid tex?
15:54:26 <BMeph> monochrom: That makes sense (to me) now. Thank you. :)
15:54:38 <byorgey> but in this context ahunter_ obviously meant _|_ =)
15:54:41 <pgavin> monochrom: when the unicode keyboard fits on my laptop?
15:54:50 <monochrom> \bot is valid TeX.
15:55:14 <BMeph> byorgey: I thought so, after a while, but I started trying to interpret it as a lambda function... ;)
15:55:22 <byorgey> hehe
15:55:29 <monochrom> λbot
15:55:35 <pgavin> lol
15:55:51 <nus> may I rephrase being strict is avoiding evaluating 'undefined'?
15:56:03 <monochrom> opposite
15:56:29 <pgavin> lazy functions generally don't look at or touch their arguments
15:56:51 <BMeph> Yes; a strict function _insists_ on evaluating arguments before giving an answer, even if it could give a valid answer.
15:57:30 <BMeph> Case in point, the 'length' example, above.
15:57:38 <pgavin> a strict function can still have a thunk around it though
15:57:54 <pgavin> when the thunk is forced, the arguments are evaluated, then the thunk is applied
15:58:01 <pgavin> err, the function is applied
15:58:47 <pgavin> so if you do something like let f = id undefined; print "blah" your program won't die
15:58:54 * BMeph is eerily reminded of the 'IMMEDIATE' word in Forth...
15:59:29 <monochrom> > let x = length undefined in length []
15:59:34 <lambdabot>  0
15:59:51 <BMeph> pgavin: Try putting a '$!' in f's defn... ;)
15:59:58 <monochrom> > let x = length $! undefined in length []
16:00:00 <lambdabot>  0
16:00:02 <pgavin> > let length' [] = 0; length' ((!x):xs) = 1 + length' xs in length [ undefined, undefined, undefined ]
16:00:02 <lambdabot>  Parse error in pattern at "in" (column 56)
16:00:07 <pgavin> err
16:00:35 <ahunter_> > let length' [] = 0; length' ((!x):xs) = 1 + length' xs; in length [undefined, undefined, undefined]
16:00:36 <lambdabot>  Parse error in pattern at ";" (column 55)
16:00:42 <monochrom> You can shadow length alright, no need to length'
16:00:49 <monochrom> add some { } s
16:00:58 <pgavin> ah, right
16:01:12 <ahunter_> hmm, I swear I've fixed some such problems with more ;'s
16:01:17 <BMeph> ...then add some cowbell? ;)
16:01:18 <pgavin> > let { length' [] = 0; length' ((!x):xs) = 1 + length' xs } ; in length' [ undefined , undefined, undefined ]
16:01:18 <lambdabot>  Parse error in pattern at "}" (column 58)
16:01:31 <monochrom> no ; after }
16:01:40 <pgavin> > let { length' [] = 0; length' ((!x):xs) = 1 + length' xs } in length' [ undefined, undefined ]
16:01:40 <lambdabot>  Parse error in pattern at "}" (column 58)
16:01:48 <nus> pgavin, what'm trying to say, when you 'sequence undefined' i.e. try to enforce defintion^W evaluation of 'undefined' you catch an exception i.e. no do.
16:02:01 <monochrom> Oh, she doesn't like bang patterns. Sorry for remember it this late.
16:02:10 <pgavin> saying "sequence undefined" is incorrect
16:02:19 <pgavin> but yes
16:02:26 <ahunter_> @type sequence
16:02:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:02:31 <pgavin> lol
16:02:44 <pgavin> ok
16:02:51 <monochrom> Beware that "sequence" doesn't mean "sequence".
16:02:51 <nus> pgavin, let me quote myself: <nus> so, being strict means being sequenced?
16:03:06 <pejo> nus, chapter 2.5.4 (p 33) of "THe implementation of functional programming languages" gives a more verbose explaination.
16:03:10 <monochrom> Hell, no one here ever says what he means or means what he says.
16:03:19 <pejo> (It's available on Simon Peyton Jones homepage somewhere).
16:04:00 <pgavin> well, there is the seq pseudo function
16:04:13 <pgavin> > undefined `seq` 1
16:04:14 <lambdabot>  Exception: Prelude.undefined
16:04:25 <ahunter_> as a side note, it would be awesome if that book got rewritten for haskell, some of the miranda-isms and old-ness get annoying sometimes
16:04:52 <monochrom> need open-sourcing the latex files :)
16:05:10 <ahunter_> Hey, I wasn't volunteering :P
16:05:20 <pgavin> all cs textbooks books should have open repos with the tex :)
16:05:28 <pejo> Sheesh. He's trying to learn partial evaluation or something similar, semantics in the presence of seq is very much advanced stuff.
16:05:36 <pgavin> err, heh, too many books :)
16:05:50 <pgavin> pejo: I know, I know :)
16:05:51 <BMeph> monochrom: "Hell, no one here ever says what he means or means what he says." You didn't REALLY mean that, did you? ;)
16:06:02 <ahunter_> http://www.cs.princeton.edu/theory/complexity/
16:06:03 <lambdabot> Title: Complexity Theory: A Modern Approach / Sanjeev Arora and Boaz Barak
16:06:04 <ahunter_> amusingly close
16:06:18 <monochrom> pejo: I don't think anyone knows for sure what his questions mean.
16:06:32 <pgavin> lol
16:06:51 <monochrom> BMeph: You're right. Clearly, "no one" is an exaggeration. I don't really mean "no one". :)
16:07:04 <BMeph> After all, rhetorical questions aren't necessary, are they? ;p
16:07:16 <pgavin> monochrom: so, you didn't mean what you said?
16:07:42 <monochrom> You risk running into the liar paradox now. :)
16:07:44 <pgavin> so, that means, you did mean what you said
16:07:53 <nus> pejo, partial evaluation ends up being a method to restrain from indefinetely recursive semantics
16:08:15 <monochrom> That is confused, IMO.
16:08:15 <pgavin> ummm
16:09:17 <pgavin> can partial evaluation save us from the liar paradox then?
16:09:31 <monochrom> non-strictness can
16:09:37 <pgavin> lol
16:10:24 <monochrom> "x = not x" has a solution.  _|_ = not _|_.  solved.
16:10:39 <monochrom> so perhaps strictness saves us.
16:10:55 <pgavin> nus: non-strict functions generally put a box around their arguments and never look at them
16:10:59 <monochrom> or perhaps this _|_ CPO business saves us. whatever. this is confusing.
16:11:04 <pgavin> e.g. (:) the list constructor is non-strict
16:11:06 * BMeph pats the lovely (_|_)...er, I meant
16:11:27 <pgavin> is it only coincidence that (_|_) looks like a butt?
16:11:38 <BMeph> pgavin: in the first argument, but not the second.
16:11:43 <monochrom> I think it is a sinister conspiracy.
16:11:53 <pgavin> BMeph: uhh, both
16:12:06 * BMeph waits to see if monochrom will "get to the bottom" of the conspiracy.
16:12:15 <pejo> nus, I have to run, but there's a fine book available in case you want to read more. http://www.itu.dk/people/sestoft/pebook/ has a pdf online. The webpage states "Partial evaluation creates a specialized version of a general program. The specialized program may be much faster than the general one."
16:12:16 <lambdabot> Title: Jones, Gomard, Sestoft: Partial Evaluation
16:13:27 <pgavin> BMeph: wouldn't (:) be non-strict in both?   you can pattern match e.g. (x:xs) even if xs is undefined
16:13:55 <pgavin> the same way that you can with (,)
16:14:13 <pgavin> but xs happens to have type [a] instead of just a
16:14:44 <BMeph> pgavin:You're right. It works. :)
16:16:52 <leoncame1> what is the pronunciation of ">>=" ?
16:16:58 <pgavin> bind
16:17:04 <pgavin> or gtgteq
16:17:07 <roconnor> flip bind
16:17:19 <chessguy> gtgteq?
16:17:19 <roconnor> *sigh*
16:17:21 <roconnor> okay bind
16:17:35 <pgavin> chessguy: you know, gtgteq
16:17:41 <pgavin> > > =
16:17:41 <chessguy> ...
16:17:42 <lambdabot>  Parse error at "=" (column 3)
16:17:49 <roconnor> much greater than or equal to.
16:17:52 <pgavin> its hard to say
16:18:10 <BMeph> I think "flip bind" should be callet meet instead. But only for its comedic potential.
16:18:13 <pgavin> anyone built 6.8.3 yet?
16:18:58 <BMeph> pgavin: Someone has, since I'm using a downloaded executable. ;)
16:19:02 <pgavin> lol
16:19:11 <nus> pgavin, pouncing on it a bit, your saving from resolving the liar paradox is dependant on how strictly one enforces you to the solution (-;
16:19:26 <roconnor> BMeph: it could be lazily compiled. :P
16:19:46 <pgavin> nus: yes, if you never ask me to answer the liar paradox, it doesn't matter that it exists
16:20:01 <pgavin> it fails for me
16:20:10 <pgavin> but I think I messed up something
16:20:15 <ahunter_> pgavin: HEAD seems broken, for that matter
16:20:17 <nus> and the paradox arises only in semantically 'closed' languages reciting the wikipedia, btw
16:20:28 <pgavin> ahunter_: yes, exactly
16:20:34 <nus> i.e. true vs false
16:20:36 <pgavin> ahunter_: I was trying to build with HEAD
16:20:40 <BMeph> roconnor: Yes, but it's still be compiled, were it run. :)
16:20:49 <BMeph> s/it's/it'd/
16:20:51 <ahunter_> it breaks on the librarires for me
16:21:12 <pgavin> HEAD fails? or 6.8.3?
16:21:26 <BMeph> Ooh, GHC's HEAD is broken more often than not, in my experience. :|
16:21:47 <pgavin> BMeph: yes, as soon as they fix one thing I find something else it breaks :)
16:22:14 <pgavin> and it's always on code I don't want to post yet
16:22:32 <BMeph> pgavin: I hope we don't frighten away any newbies, with alll this "HEAD-bashing" talk... ;)
16:22:45 <pgavin> lol
16:23:28 <ahunter_> speaking of building stuff, anyone know why I can't build some of the utils?
16:23:43 <pgavin> ahunter_: that's where it failed for me
16:23:44 <ahunter_> either I'm doing something really stupid, or the Makefile for nofib-analyse is totally broken
16:23:49 <pgavin> missing S# or something
16:24:17 <pgavin> I find the makefiles are frequently broken
16:24:34 <pgavin> make clearly wasn't designed with Haskell in mind, though
16:24:48 <pgavin> make works well for c programs though
16:25:14 <ahunter_> yeah, but that doesn't help me build the damn analyser :P
16:25:28 <pgavin> no, sorry
16:25:36 <ahunter_> Out of curiosity, neglecting all the librarires and all the CMM, how close is ghc --make to being able to build GHC itself?
16:26:10 <pgavin> well, if you're only talking about the .hs files, it should be pretty close
16:26:24 <ahunter_> yeah, that's mostly what I was wondering
16:26:46 <pgavin> cabal needs a proper build system
16:27:56 * Saizan is writing it for cabal, should really blog about it as soon as he can
16:28:55 <pgavin> Saizan: awesome, any progress?
16:29:23 <ahunter_> I would just really love a better interaction with packaging systems (yes, I'm aware of the flamewar on -cafe)--I run debian/ubuntu, mostly, and I really don't love installing packages not by apt/dpkg
16:29:44 <ahunter_> it'd be nice if I could somehow almost-kinda treat cabal as a repository and use my normal package management techniques on it
16:29:54 <dons> ahunter_: so good distros provide tools to generate native packages directly from .cabal files
16:30:06 <dons> arch has 300+ haskell packages now, by auto-converting from .cabal to .pkg
16:30:13 <dons> ahunter_: so, talk to your package maintainers.
16:30:27 <Saizan> pgavin: it's quite complex to record every dependency to maximize reuse of previous computations, it's kind of a twisted FRP
16:30:34 <ahunter_> dons: good to know, wasn't really aware of that--thanks
16:30:37 <dons> if they can't do that, the minimum is to get cabal-install in the package system
16:30:47 <dons> to bypass the  native package system
16:30:49 <pgavin> Saizan: yeah, I know what you mean
16:30:59 <dons> gentoo has several hundred packages too
16:31:09 <pgavin> Saizan: I tried throwing one together about a year ago
16:31:17 <pgavin> Saizan: it never really went anywhere though
16:31:37 <Saizan> pgavin: i'm using a dependency graph as the model, but the problem is that you end up with egdes that depend on the nodes..
16:31:53 <pgavin> Saizan: the graph depends on itself :)
16:32:07 <pgavin> Saizan: look at the algorithm implemented by GNU make
16:32:24 <Saizan> yeah, you've to "execute" it to expand it
16:32:24 <pgavin> Saizan: just for an idea of how they do it
16:32:49 <pgavin> http://www.gnu.org/software/make/manual/html_node/Implicit-Rule-Search.html#Implicit-Rule-Search
16:32:50 * BMeph thinks that "gobby + hpaste" project should get worked on...just not by him
16:32:50 <lambdabot> Title: Implicit Rule Search - GNU `make', http://tinyurl.com/6xjdhl
16:32:59 <pgavin> it's not simple
16:33:09 <pgavin> not that I would duplicate what make does...
16:33:26 <pgavin> but it's a good reference point
16:33:38 <Saizan> thanks :)
16:34:06 <pgavin> so I figure your doing an Arrow based approach?
16:34:22 <pgavin> e.g., the FRP?
16:34:46 <Saizan> if it's something it's monading
16:34:50 <Saizan> *monadic
16:35:04 <pgavin> ok
16:35:42 <Saizan> but i'm still using a more explicit declaration of rules
16:35:57 <pgavin> part of the problem is that making one target can change the status of other targets
16:36:30 <dons> dcoutts: you should have a big headline on the front page of haskell.org/cabal
16:36:34 <pgavin> e.g., if you have rules for *.hi and *.o, the .hi file is rebuilt when the .o file is built
16:36:37 <dons> maybe a link to the cabal-tagged rss items
16:36:46 <dons> at least a 'news' section
16:36:46 <augur> in haskell, how do you distinguish between thunk referencing and thunk calls?
16:36:59 <pgavin> augur: uh, you don't
16:37:03 <dons> augur: distinguish in a program? you don't
16:37:03 <augur> ?!
16:37:03 <lambdabot> Maybe you meant: . ? @ v
16:37:13 <augur> but surely you want to be able to pass thunks around
16:37:16 <dons> you don't observe passing a value, or demanding it, usually
16:37:25 <dons> augur: they're all passed, until they're demanded
16:37:26 <Saizan> pgavin: that's why the nodes in my graph are the computations, rather than the targets
16:37:27 <dons> then they're called.
16:37:46 <dons> you can force that with 'seq' , but in general, you can't observe the evaluation order
16:37:55 <dons> good question though, augur
16:38:10 <augur> hm..
16:38:12 <pgavin> Saizan: ok, so to get the dependencies of a node, you run the computation?
16:39:06 <dons> augur: so basically, all based by name (unevaluated), till they're demanded. the runtime then jumps to the thunk, forcing it, and it its body is updated with the result
16:39:09 <dons> so it won't be recomputed
16:39:30 <dons> the pointer to the thunk has its bottom bits used to encode whether or not it is already evaluated, and if so, what constructor it points to
16:39:49 <Saizan> pgavin: i've something like Rule { depends :: [Target], targets :: [Target], action :: m [Representation] }, the depends field is actually more than that to handle what i call dynamic dependencies
16:39:53 <augur> hm..
16:40:01 <augur> damn you haskell :P
16:40:17 <pgavin> Saizan: depends is not an action?
16:41:02 <bos> wow, ghc produces even huger binaries than it needs to.
16:41:07 <pgavin> citeseer down?
16:41:14 <pgavin> bos: yes, indeed
16:41:23 <Saizan> pgavin: no, but some of the dependencies can generate more dependencies for that rule dynamically, e.g. A.hi depends on the modules imported inside A.hs
16:41:41 <pgavin> bos: just wait till shared libraries are implemented
16:41:55 <dons> shrug. disk space is growing faster than ghc's binaries are.
16:41:55 <bos> pgavin: that won't help my case.
16:41:59 <pgavin> Saizan: right...
16:42:11 <bos> dons: CD-ROMs aren't.
16:42:13 <dons> bos, strip and split objs?
16:42:29 <dons> i saw a writeable blue-ray burner in bestbuy last week
16:42:29 <pgavin> Saizan: so what are you using to generate the dynamic dependencies?
16:42:37 <dons> that'll be enough for a while
16:42:47 <bos> the weird thing is that ghc emits vast numbers of symbols into a binary that it generates. that's my specific beef.
16:42:51 <dons> but yeah, install media.
16:42:54 <bos> it bloats the size of a binary by almost 2x.
16:43:10 <dons> so that halves after you strip it?
16:43:13 <bos> and the symbols serve no purpose that i can discern.
16:43:14 <bos> yes.
16:43:15 <dons> or still messes things up?
16:43:20 <bos> no, things run fine.
16:43:31 <dons> that's interesting. ghc -fasm should be able to avoid that junk eh?
16:43:53 <bos> -fasm would be the default, no?
16:44:01 <pgavin> with proper use of static -fvia-C shouldn't make extra junk either
16:44:05 <bos> i'm not going -fvia-C
16:44:27 <pgavin> have you tried it?
16:44:34 <Saizan> pgavin: code.haskell.org/~Saizan/cabal/Make/Rule.hs <-- take a look :)
16:45:05 <bos> pgavin: no, i'd prefer the problem to be fixed at the source :-)
16:45:29 <dafra> dons do you know how many bottom bits ghc puts in pointers ? (just curious)
16:45:31 <BMeph> Can't a "pre-stripped" binary be made the default? :)
16:45:51 <bos> i'm also running into barfage with SELinux.
16:46:17 <dafra> 1 for "evaluated", maybe another one for constructor id ?
16:46:26 <bos> SELinux is to security what J2EE is to the web: a guarantee of perpetual employment for the mindless drone.
16:46:27 <pgavin> Saizan: interesting...
16:46:53 <pgavin> Saizan: don't you need IO to scan a file for the dynamic deps?
16:47:07 <BMeph> bos: How about a RTS that "pre-runs" a program to estimate how much of a heap it needs, then lobotomizes itself (the RTS) for extra-slim goodness? :)
16:47:27 <pgavin> BMeph: halting problem?
16:47:53 * BMeph nods his head at pgavin, admiring the wisdom.
16:47:55 <dons> dafra: 3 on 64 bit, 2 on 32 bit
16:47:58 <pgavin> lol
16:48:29 <dons> bos, no kidding. we have people whose job it is to write policies :)
16:48:38 <Saizan> pgavin: the IO is done while computing the target associated with the DepMaker
16:48:43 <pgavin> dons: talk about a boring job :)
16:48:46 <BMeph> bos: Support the mentally-challenged! Support SELinux in your workplace! ;)
16:49:00 <dons> well, there are more fun jobs writing compilers that produce policies :)
16:49:00 <pgavin> ah, ok
16:49:31 <pgavin> dons: and I take it that's the one you have? :)
16:49:32 <bos> dons: i don't envy those people. also, SELinux is horribly complex.
16:49:39 <Saizan> pgavin: this means introducing artificial targets sometimes, but they help with caching anyway
16:50:24 <dons> pgavin: no, not my job. we use a lot of selinux though.
16:51:55 <pgavin> Saizan: is it usable yet?  I want to get gtk2hs under cabal
16:51:57 <pgavin> :)
16:53:02 <BMeph> Catch y'all later...
16:53:04 <Saizan> heh, not yet :)
16:54:19 <pgavin> Saizan: ok, well, I've pulled your repo, let me know when you're ready for testing :)
16:55:03 <Peaker> what is this syntax? "f     <- frame [ visible := False, text := name ]" (the bracket contents)
16:55:19 <Saizan> it's a list
16:56:17 <Peaker> oh, := just a data constructor?
16:56:24 <Saizan> yup
16:56:29 <Peaker> interesting
16:56:34 <Peaker> haven't seen that before
17:00:45 <pgavin> Peaker: gtk2hs?
17:00:59 <Peaker> pgavin, wx
17:01:14 <pgavin> ah
17:05:00 <Saizan> the problem with using FRP in a build system is that you need to share values between computations that are far away, e.g. many modules can import the same other module and so compiling them depends on its interface file
17:08:08 <pgavin> Saizan: right... speaking of which, how are you extracting the imports from the .hs files?
17:09:37 <jaj> hmm I tried to design a beautiful xmonad/openbsd wallpaper. guess I failed... http://www.hcl-club.lu/~jaj/stuff/obsd_xmonad.png
17:13:57 <dafra> jaj nice pic
17:15:24 <mjrosenb> hey, what library should i use to read in a file that has raw binary data in it?
17:15:37 <EvilTerran> ByteString?
17:15:50 <dons> Data.Binary or Data.ByteString
17:16:04 <dons> Data.ByteString is a good start
17:16:40 <MyCatVerbs> Data.Binary is a good idea if you feel like parsing it. :)
17:17:52 <jaj> dafra: thanks. now that I learned how gimp actually works I'll try to make something better ;)
17:18:55 <dafra> dont forget to port xmonad to windows btw :)
17:19:02 <mjrosenb> can't bytestring give the output as a list of word8's?
17:19:11 <dons> mjrosenb: if you unpack it, yes.
17:19:18 <dons> though that'll be inefficient
17:19:33 <dons> :t Data.ByteString.unpack `fmap` Data.ByteString.readFile
17:19:36 <lambdabot>     Couldn't match expected type `BSC.ByteString'
17:19:36 <lambdabot>            against inferred type `IO BSC.ByteString'
17:19:36 <lambdabot>       Expected type: FilePath -> BSC.ByteString
17:19:43 <dons> :t Data.ByteString.unpack `fmap` Data.ByteString.readFile ?f
17:19:44 <lambdabot> (?f::FilePath) => IO [Word8]
17:20:02 <newsham> what is ?f  ?
17:20:14 <dons> oh, implicit parameter. useful hack for querying the type checker
17:20:56 <newsham> :type read $ return ?x
17:21:04 <dons> stefan o'rear thought of it.
17:21:14 <dons> ?type read $ return ?x
17:21:15 <lambdabot> forall a. (?x::Char, Read a) => a
17:21:26 <atp> it's part of lambdabot?
17:21:32 <newsham> awesome, i've always wanted something that could do that
17:21:33 <atp> or does ghci support it too
17:21:37 <dons> no, ghc language extension of nefarious origin
17:21:39 <EvilTerran> it's a ghc extension
17:21:43 <dons> -fimplicit-parameters
17:22:33 <newsham> can I ask what the type of "return x" is inside "read $ return x"  ?
17:22:36 <atp> hey, is there any way to have ghc tell you when it evaluates a thunk as a program is running, you know, for debugging purposes?
17:22:43 <EvilTerran> ?hoogle trace
17:22:44 <lambdabot> Debug.Trace.trace :: String -> a -> a
17:22:44 <lambdabot> Debug.Trace :: module
17:22:44 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
17:22:52 <EvilTerran> or the ghci debugger
17:22:59 <dons> :t read (?y)
17:23:01 <lambdabot> forall a. (Read a, ?y::String) => a
17:23:04 <SamB> trace works better
17:23:05 <atp> i guess i meant without me needing to litter my code with the haskell equivalent of printf
17:23:18 <newsham> hmm, perhaps that isnt the best example.
17:23:23 <EvilTerran> atp, debugger, then
17:23:48 <atp> k, thanks.  i knew ghci had added one but i haven't tried it yet.
17:24:15 <golubovsky> Hi everybody, Dimitry here.
17:24:51 <golubovsky> Has anybody activated an account at community.haskell.org recently?
17:25:23 <Saizan> ?type assert
17:25:25 <lambdabot> Not in scope: `assert'
17:25:37 <Saizan> ?ty Control.Exception.assert
17:25:39 <lambdabot> forall a. Bool -> a -> a
17:25:44 <Apocalisp> ?hoogle a -> ((a -> b), (a -> c)) -> (a, c)
17:25:45 <lambdabot> No matches, try a more general search
17:26:00 <Apocalisp> ?hoogle a -> ((a -> b), (a -> c)) -> (b, c)
17:26:00 <lambdabot> No matches, try a more general search
17:26:39 <Saizan> ?type flip (uncurry (&&&))
17:26:42 <lambdabot> forall b c c'. b -> (b -> c, b -> c') -> (c, c')
17:26:47 <EvilTerran> ?type flip (uncurry (liftM2 (,)))
17:26:49 <lambdabot> forall a1 a2 b. b -> (b -> a1, b -> a2) -> (a1, a2)
17:27:06 <Apocalisp> ?type (&&&)
17:27:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:27:19 <Apocalisp> nice!
17:27:40 <EvilTerran> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c,c'))
17:27:50 <EvilTerran> think of ~> as a generalisation of ->
17:28:07 <Apocalisp> yes
17:28:32 <mjrosenb> EvilTerran: wait, you can have infix type constructors?
17:28:55 <EvilTerran> it's another ghc extension, but yes
17:29:24 <mjrosenb> oic
17:33:14 <dancor> are there any lambdabotalikes for other more procedural langs
17:33:26 <dancor> i guess stopping untoward sideeffects becomes a nightmare
17:34:11 <mjrosenb> can Data.Binary deal with individual bits?
17:39:25 <EvilTerran> mjrosenb, that's more a job for Data.Bits
17:39:50 <EvilTerran> dancor, perl has a sandbox system, which (iirc) is used by the bot in #perl
17:40:15 <EvilTerran> also, mbot does Mathematica or something, not that that's procedural
17:41:02 <dolio> codepad.org does evaluation for several languages through a web interface.
17:50:11 <dobblego> > map (\a -> "T" ++ show a) [1..10] -- how can I get rid of these quotes from the String show instance?
17:50:13 <lambdabot>  ["T1","T2","T3","T4","T5","T6","T7","T8","T9","T10"]
17:50:25 <mjrosenb> EvilTerran: right, but I haven't found any way to get data into that
17:50:40 <mjrosenb> dobblego: use printString.  they're strings
17:51:00 <dobblego> ?hoogle printString
17:51:01 <lambdabot> No matches found
17:51:14 <Draconx> putStrLn, perhaps?
17:51:23 <dobblego> I definitely do not want putStrLn
17:51:45 * mjrosenb was thinking of putStr
17:51:52 <dolio> newtype NoQuoteString = Str { unStr :: String } ; instance Show NoQuoteString where show = unStr
17:52:47 <dobblego> dolio, I thought that might be the usual way, cheers
17:53:18 <EvilTerran> hm... why does "instance Append (List i) (List j) (List n) => Append (List (Succ i)) (List j) (List (Succ n))" fail the coverage condition given "class Append xs ys zs | xs ys -> zs"?
17:53:25 <dolio> dobblego: The only other thing I can think of is to write a custom 'showArrayTheWayIWant :: [String] -> String' function.
17:53:36 <dolio> Er, list.
17:53:39 <dobblego> dolio, right
17:53:40 * dolio has arrays on the brain.
17:53:51 <mjrosenb> so importing Data.ByteString gives two instances of readFile.  is there any way to use only the instance of readFile from Data.ByteString
17:54:10 <EvilTerran> import Prelude hiding (readFile)
17:54:38 <EvilTerran> you'll still be able to access the normal one via Prelude.readFile
17:55:01 <mjrosenb> sweet
17:55:18 <EvilTerran> mjrosenb, alternatively, "import qualified Data.ByteString as BS", and then all the ByteString stuff isn't imported into the main namespace, but you get at it with, eg, BS.readFile
17:55:29 <EvilTerran> thinking about it, i think that's the usual approach
17:56:21 <hpaste>  morrow pasted "mueval: some call to setResourceLimit failing with exception" at http://hpaste.org/8388
17:56:49 <mjrosenb> EvilTerran: awesome, thanks
17:57:59 <hpaste>  morrow annotated "mueval: some call to setResourceLimit failing with exception" with "info" at http://hpaste.org/8388#a1
17:58:10 <leoncame1> ?type mplus
17:58:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:59:21 <byorgey> @users
17:59:22 <lambdabot> Maximum users seen in #haskell: 463, currently: 413 (89.2%), active: 12 (2.9%)
17:59:35 <mmorrow> gwern: any idea why some of the calls to setResourceLimit are failing?: http://hpaste.org/8388
17:59:45 <byorgey> a lot of new users lately, it seems!
17:59:49 <byorgey> welcome, new users =)
18:01:21 <ddarius> When I joined #haskell, there was about 30 or 40 people on it.
18:02:32 <mrd> fresh fish
18:05:25 <gwern> mmorrow: invalid argument?
18:05:33 <proq> why is this broken and how do I fix it?: let f = iterate (\(x,y,z) -> (x,x + y,y + z)) (1,2,3) in fst (f !! 10)
18:05:42 <leoncame1> > Hex 0
18:05:43 <lambdabot>   Not in scope: data constructor `Hex'
18:05:57 <gwern> hum. that's interesting. I would've expected any erros to be permission denied, either access to resources denied or setting-a-limit-acess denied
18:06:11 <ddarius> proq: Why do you think it is broken?
18:06:52 <proq> ddarius: I get the error: Type : (c,c,c) Does not match : (a,b)
18:07:02 <rwbarton> fst only works on pairs
18:07:23 <proq> ah
18:07:35 <ddarius> proq: Also you may want to use GHC instead.
18:07:44 <gwern> mmorrow: so does it work with the three resources commented out?
18:07:50 <ddarius> and provide error messages when you say things are "broken"
18:07:54 <proq> ddarius: unfortunately, ghc doesn't run on my zaurus
18:09:07 <proq> ghci does seem to have a clearer error description
18:11:36 <atp> proq: ddarius' more important point is that it's rude to say something is broken, because it implies that it's someone else's fault
18:11:56 <atp> a more polite way to ask for help is to ask what you've done wrong
18:12:24 <atp> always be very sure something is broken before you claim it is in public
18:13:35 <gwern> oh #haskell! I have sinned! please instruct me in the error of my pointful, pointful ways
18:13:46 <atp> uh oh, what did you do?
18:14:08 <mmorrow> gwern: i'm on crappy internet, got disconn. reading the log...
18:14:29 <proq> atp: that's a rather odd interpretation of the word "broken"
18:14:38 <gwern> mmorrow: ah. I was briefly wondering whether that was something mueval had done
18:14:38 <mmorrow> gwern: resending what never got sent...
18:14:47 <gwern> in which case I've screwed up very badly somewhere :)
18:14:47 <mmorrow>  gwern: yeah, i put a comment in the code at http://hpaste.org/8388#a0 with what i tracked it to
18:14:52 <mmorrow> gwern: it was giving me:
18:14:57 <mmorrow>  [m@ganon code]$ mueval
18:15:02 <mmorrow> mueval: setResourceLimit: invalid argument (Invalid argument)
18:15:06 <mmorrow> (and similarly with any combination of args)
18:15:06 <ddarius> atp: That's not my point at all.  My point is that the error message/what you want/what you got are useful pieces of information; "it's broken" isn't particularly useful and potentially useless.
18:15:34 <mmorrow> it works now with the offending args commented out though
18:15:49 * EvilTerran bashes his head against the coverage condition
18:16:40 <gwern> mmorrow: mm mm. what I meant was did you figure out which resource was it? I find it hard to believe 4 different resources set to 3 different things would be invalid
18:17:51 <mmorrow> gwern: all of these [ResourceTotalMemory,ResourceOpenFiles,ResourceDataSize,ResourceCPUTime] (+ their zipWithed counterparts) were causing setResourceLimit to throw an exception ""setResourceLimit: invalid argument (Invalid argument)
18:18:44 <gwern> odd, odd.
18:19:04 <mmorrow> it may be something trivial, but i'm not familiar enough with setResourceLimit to diagnose
18:19:29 <gwern> mmorrow: could you try setting each of the hard/soft limits to zero? that'll cause a runtime failure if you try to do antying, obviously, but I'm wondering whether rlimits could just not be entirely sipported on your platform
18:19:47 <mmorrow> doing...
18:22:11 <gwern> bollocks. BLAS fails to specify a QC dep < 2
18:22:20 <gwern> man, QC 2 is going to break so much stuff
18:22:47 <mrd> not if it's been tested!
18:23:05 * gwern thwacks mrd 
18:23:37 <TomMD> gwern: Going to?  You haven't been using QC2?
18:23:47 <TomMD> ;-)
18:24:31 <gwern> not really. I keep having to add QuickCheck <2, so I'm not sure I've ever actually used it
18:27:02 <gwern> argh! this is even more annoying, I already sent a patch for blas
18:27:10 <mmorrow> ah crap, got cutoff again...
18:27:18 <gwern> (the heck, mon?)
18:27:19 <mmorrow> <mmorrow> gwern: with all offending set to (ResourceLimits zero zero):
18:27:19 <mmorrow> <mmorrow> [m@ganon code]$ mueval -t 3 -m Data.Function -e 'fix show'
18:27:19 <mmorrow> <mmorrow> mueval: /usr/local/ghc/ghc-6.9.20080504_editline/lib/ghc-6.9.20080504/package.conf: openBinaryFile: resource exhausted (Too many open files)
18:27:19 <mmorrow> <mmorrow> mueval: Time limit exceeded
18:27:19 <mmorrow> <mmorrow> gwern: so no exceptions..., so maybe the default values are bad for my particular system...?
18:27:51 <byorgey> QC2 rocks my socks
18:28:13 <mmorrow> this coffee shop gives "free internet" but makes you register a username/pass (doesn't verify the email) THEN cuts you off every ten minutes and makes you RElogin in your browser
18:28:15 <gwern> mmorrow: I think that must be it. too many open files is exactly the error I would expect to see if the rlimits are implemented and fine
18:28:23 <mmorrow> so irc gets the chop every ten min
18:28:37 <mmorrow> gwern: cool, thx
18:28:50 <byorgey> mmorrow: well... it is free, I guess =P
18:29:02 <mmorrow> no complaints here...
18:29:09 <mmorrow> ..other than once every ten minutes
18:29:11 <gwern> mmorrow: ah. ok, the next thing to try is, I want you to keep everything at zero, and set something to an absurdly high limit, so high that it's guaranteed to blow your user's default ulimit
18:29:18 <gwern> *but set something
18:29:43 <mmorrow> gwern: will do, but gotta bail from here. be back in about 20min
18:31:00 <gwern> @tell mmorrow the point of that being obviously to see what error too-generous limits cause, to see whether it's the same as the error you were getting by default
18:31:00 <lambdabot> Consider it noted.
18:32:27 <OceanSpray> Where can I get a binary of lambdabot?
18:33:02 <gwern> lol
18:33:06 <gwern> OceanSpray: you can't
18:33:19 <OceanSpray> I've been trying to compile it for days.
18:33:20 <OceanSpray> No dice.
18:33:39 <gwern> OceanSpray: let me put it this way, anytime you see hardwired constants which look like foo = "./dist/,,,", don't expect to see any binaries anytime soon
18:34:16 <OceanSpray> :|
18:34:39 <adu> hi
18:34:48 <adu> I made some nice Yi images
18:35:06 <gwern> greetings fellow human
18:35:30 <gwern> @seen Cale
18:35:30 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 4h 39m 37s ago.
18:35:32 <adu> hi gwern
18:37:28 <gwern> @ask Cale are you running the 'dynamic' version of lambdabot? I ask because the dependency on hs-plugins seems forced by the smallcheck/quickcheck/evaluation modules in scripts/, and by Boot.hs. the former can be replaced by mueval or whatever, but the latter is irreplaceable - unless it's not being used at all
18:37:28 <lambdabot> Consider it noted.
18:39:27 <adu> Anyone wanna see some nice Yi pics?
18:40:01 <gwern> are they legal? yi's very young after all
18:40:09 <adu> lol
18:40:13 <adu> http://tetration.itgo.com/up/art2.zip
18:40:26 <adu> the text editor, silly
18:40:45 <TomMD> I refuse to use any editor that didn't start on VAX...
18:41:20 <thetallgu1> Teco?
18:41:40 <dons> dcoutts: did you see, cabal-install described as "game changing".
18:42:19 <gwern> I
18:42:21 <gwern> 'm sure it made him feel fuzzy inside
18:42:48 <mmorrow> gwern: i'm not sure how this will effect your test, but:
18:42:48 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
18:42:49 <dons> it changes the game though, it just got a lot cheaper to build haskell for the masses
18:42:52 <mmorrow> [m@ganon mueval-0.2.1]$ ulimit
18:42:52 <mmorrow> unlimited
18:42:53 <ddarius> Describing cabal-install as "game changing" (if I'm taking that right) takes a rather short part of Haskell history into effect.
18:43:03 <ddarius> s/effect/account
18:43:37 <dons> i think it is probably the biggest step in lowering the cost of getting haskell apps out there. it ties up ghc, hackage and cabal nicely
18:43:50 <mmorrow> gwern: so this worked: (ResourceLimits (ResourceLimit (10^100)) (ResourceLimit (10^100))) -- , (ResourceLimits openFilesLimitSoft openFilesLimitHard)
18:43:51 <byorgey> very nice, adu!
18:43:51 <dons> i only use 'cabal install' now , for all local and remote building
18:43:59 <dons> as a result i've got something like 200 haskell libraries installed
18:44:02 <adu> byorgey: you saw my pics?
18:44:08 <mmorrow> gwern: but still gave: mueval: /usr/local/ghc/ghc-6.9.20080504_editline/lib/ghc-6.9.20080504/package.conf: openBinaryFile: resource exhausted (Too many open files)
18:44:09 <byorgey> adu, yes
18:44:34 <gwern> mmorrow: mm. oh geez. well, that messes up my theory that your system has fascist ulimit settings
18:44:39 <adu> byorgey: thanks :)
18:44:46 <mmorrow> gwern: heh
18:46:16 <adu> I was thinking the yi-char-16 could be used in html docs or something, if not for consistency reasons, then for people w/o fonts
18:47:22 <mwotton> hey, is there a data structure that lets you look up a string in it, and gives you everything that has that string as a prefix?
18:47:36 <ddarius> mwotton: A trie
18:47:46 * mwotton substitutes string as shorthand for Eq a, Ord a => [a] :)
18:48:05 <mwotton> is there a haskell implementation, before i go write my own?
18:48:31 <dons> mwotton: of what?
18:48:37 <dons> ah. suffixtree?
18:48:42 <dons> oh, prefixtree :)
18:49:07 <mwotton> dons: hiya mate, how're things? long time no talk :)
18:49:16 <adu> but the most important thing is that I now use yi-lambda-dark as my desktop background on all my computers :)
18:49:17 <mmorrow> gwern: it works though with the exception-causing ResourceLimits commented out though, so i'm good. thanks!
18:49:27 <dons> are suffix trees what i'm thinking of?
18:49:37 <mwotton> dons: but yeah, i want to look up 'spec' in a big dict and get ["special", "spec", "specialisation", ... ]
18:49:53 <mwotton> don't know. had some little thing nagging at me, but couldn't remember the name
18:50:21 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/suffixtree
18:50:23 <lambdabot> http://tinyurl.com/2whnln
18:50:46 <gwern> mmorrow: could you run tests.sh and see whether things work out?
18:50:51 <mwotton> cheers. (am at google dev day. fun stuff :)
18:50:52 <ddarius> Any of a suffixtree, inverted index or trie would work for that reasonably well.
18:50:58 <mmorrow> gwern: yes
18:51:05 <dons> one of the trie libs might work too, actually
18:51:12 <dons> mwotton: google dev .au or usa?
18:51:24 <mwotton> .au
18:51:34 <mwotton> down on suffix street
18:51:36 <mwotton> uh, sussex street
18:51:37 <dons> heh
18:51:39 * mwotton slaps head
18:51:53 <dons> Data.Trie is in http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections
18:51:55 <lambdabot> http://tinyurl.com/63pbz5
18:52:18 <pgavin> does anyone get this error while building ghc?
18:52:22 <dons> but neither are 6.8 friendly -- they need small tweaks to build with small-base
18:52:24 <hpaste>  morrow annotated "mueval: some call to setResourceLimit failing with exception" with "./tests.sh" at http://hpaste.org/8388#a2
18:52:28 <pgavin> main/Main.hs:1:0: Failed to load interface for `Prelude':
18:52:28 <pgavin>       Perhaps you haven't installed the "thr" libraries for package base?
18:52:34 <mmorrow> gwern: pasted :)
18:53:02 <mmorrow> gwern: (this is with the exception-causing ResourceLimits commented out)
18:53:12 <pgavin> I get that while building stage2
18:53:41 <gwern> mmorrow: so nothing hung, even with resourcelimits gone?
18:54:31 <hpaste>  pgavin pasted "ghc build error" at http://hpaste.org/8389
18:54:39 <pgavin> that's the last 30 lines or so
18:54:42 <mmorrow> well, the one commented out are: [ResourceTotalMemory,ResourceOpenFiles,ResourceDataSize,ResourceCPUTime]
18:54:48 <mmorrow> gwern: ^
18:54:56 <mmorrow> gwern: the others are still there
18:55:20 <mmorrow> gwern: the others being: [ResourceStackSize,ResourceFileSize,ResourceCoreFileSize]
18:55:57 <gwern> hm. sjanssen also had trouble with ResourceOpenFiles
18:56:09 <gwern> I wonder whether I should add some sort of configurability or remove them entirely
18:56:31 <vixey> I had to comment out ResourceLimits stackSizeLimitSoft stackSizeLimitHard
18:56:44 <vixey> (& ResourceStackSize)
18:57:15 <mmorrow> gwern, vixey: what are you each running/etc?
18:57:24 <mmorrow> my uname -a: Linux ganon 2.6.24.7-92.fc8 #1 SMP Wed May 7 16:50:09 EDT 2008 i686 GNU/Linux
18:57:28 <gwern> dang. I wonder what is special about my system?
18:57:42 <gwern> mmorrow: I'm running ubuntu hardy heron
18:57:45 <gwern> Linux craft 2.6.24-19-generic #1 SMP Wed Jun 4 15:10:52 UTC 2008 x86_64 GNU/Linux
18:59:45 <mmorrow> hmm, i have no idea
19:01:15 <andyjgill> Does anyone know if there is an instance Functor ((->) t) ? I can not find it.
19:01:20 <dons> sure is.
19:01:25 <dons> Control.Monad.Instances
19:01:38 <dons> instance Functor ((->) r) where fmap = (.)
19:01:47 <dons> instance Monad ((->) r) where return = const f >>= k = \ r -> k (f r) r
19:02:02 <dons> kind of amazing we didn't have that in base until 2007.
19:02:21 <andyjgill> Now, how would I find this out using hoggle?
19:02:39 <vixey> @instances Functor
19:02:49 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:02:53 <bd_> I usually import Control.Monad.Reader
19:03:09 <Saizan> it's an orphan instance, hard to find
19:04:46 <andyjgill> Thanks!
19:11:57 <greeg> hi
19:12:01 <greeg> http://www.youtube.com/watch?v=ZYmADPVEqU4
19:12:01 <lambdabot> Title: YouTube - Ernie practices some blast beats
19:12:23 <monochrom> ban?
19:12:50 <Cale> greeg: This channel is about the Haskell programming language.
19:12:50 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
19:13:20 <greeg> lol
19:13:42 <ddarius> The people here are too damned nice.
19:14:22 <monochrom> Being friendly to trolls is being unfriendly to genuine members of the community.
19:14:22 <bugQ> GRAAH KICK YOU IN THE GROIN
19:14:25 <bugQ> better?
19:14:39 <TomMD> Yay, cabal upload kicks ass.  Now if only there were a 'cabal uploadDist == cabal sdist >>= cabal update'  ;-)
19:15:00 <dons> oh, you're using cabal-upload, TomMD ?
19:15:03 <dons> i couldn't build it
19:15:10 <gwern> TomMD: I filed a bug report for that, btw
19:15:13 <monochrom> But you don't have to be unfriendly to trolls either. Just ban. Focus on genuine members.
19:15:25 <TomMD> gwern: Ha! Beat me to it.
19:15:44 <dons> oh, 'cabal upload'
19:15:56 <dons> didn't know about that. that *is* awesome
19:15:57 <TomMD> dons: For the first time just now - fix a haddock error stopping pureMD5 from building on hackage (which I only noticed when it interfered with cabal2arch haddock)
19:16:05 <gwern> TomMD: yes, that often happens. re a recent cabal thread, I sometimes beat myself to it
19:16:27 <gwern> I had almost filed a bug report when dcoutts wrote mentioning the bug report I had filed :)
19:16:28 <dons> hmm, i should merge mkcabal into cabal now
19:16:31 <dons> cabal generate
19:16:33 <rwbarton> is there a standard function  Word32 -> [Word8]?
19:16:39 <Elly> mwotton: you meant Tries, by the way
19:16:46 <dons> rwbarton: unpack . encode
19:16:46 <rwbarton> or Word32 -> Data.ByteString
19:16:51 <dons> encode
19:16:56 <dons> :t Data.Binary.encode
19:16:58 <lambdabot> forall a. (Data.Binary.Binary a) => a -> BSLC.ByteString
19:17:11 <dons> :t Data.ByteString.Lazy.unpack . Data.Binary.encode
19:17:13 <lambdabot> forall a. (Data.Binary.Binary a) => a -> [Word8]
19:17:37 <dons> :t \(x :: Word32) -> Data.ByteString.Lazy.unpack . Data.Binary.encode  $ x
19:17:39 <lambdabot> Word32 -> [Word8]
19:17:53 <dons> network order
19:18:03 <dons> rwbarton: grab binary from hackage.haskell.org
19:18:15 <rwbarton> ah, that must be why hoogle didn't know about it
19:18:36 <dons> yeah, i think the new hoogle will know about everything on hackage, but that's due later this summer
19:18:38 <TomMD> hoogle doesn't know about far too much, but I bet ndm will see to that this summer.
19:18:57 <dons> this northern hemisphere summer
19:19:04 * dons notes how quickly he sold out his roots
19:19:22 <TomMD> dons: Living in Portland is legitimate, not selling out.
19:19:34 <gwern> I worry that getting everything on hackage might lead to name pollution, but I suppose that'll just be an incentive to split out libraries?
19:19:37 <dons> legitimately southern hemisphere? :)
19:19:38 <TomMD> If you live in a desert or on the east coast I'd say otherwise.
19:19:51 <gwern> 'zOMG, forever is defined in 27 different packages! maybe we should move it into Control.Monad'
19:20:07 <TomMD> Close enough.  Note that I am biased being from the Northwest.
19:20:14 <dons> heh
19:20:53 <TomMD> :t Control.Monad.forever
19:20:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
19:21:21 <TomMD> gwern: It wasn't there once upon a time, which is why it was defined in so many different places, which is why it is there now.
19:21:35 <TomMD> Sorry if you were being sarcastic.
19:21:50 <gwern> iirc, forever only made it in for 6.6. I recall... yeah, what TomMD said
19:22:03 <monochrom> You can sell out to the corporate hemisphere too. Then you will say "Q2", "Q3".
19:22:28 <TomMD> And the year will end whenever the budget says it ends!
19:22:34 <dons> in Q3 hoogle will be going live and primetime.
19:22:39 <gwern> and riotously celebrate the end of the fiscal year?
19:22:54 <TomMD> Only if you get a financial sector bonus ;-(
19:23:01 <chylli> Hi, when I install Yi editor, I got dependence error:
19:23:09 <Elly> I wish I knew Haskell :(
19:23:10 <chylli> cabal: internal error: could not construct a valid install plan.
19:23:11 <chylli> The proposed (invalid) plan contained the following problems:
19:23:11 <chylli> Package bytestring is required by several packages, but they require inconsistent versions:
19:23:11 <chylli>   package yi-0.4 requires bytestring-0.9.0.1
19:23:14 <chylli>   package vty-3.0.1 requires bytestring-0.9.1.0
19:23:17 <chylli>  
19:23:37 <chylli> how to resolve this problem ?
19:23:46 <gwern> chylli: ah, the bytestring/diamond dependency problem strikes again!
19:23:54 <chylli> the package byestring caused too many trouble.
19:23:59 <dons> that's a good warning to have.
19:24:06 <chylli> gwern: how to resolve it ?
19:24:08 <dons> the alternative is a linker error
19:24:12 <TomMD> chylli: Update your vty (cabal install vty).
19:24:25 <dons> if that works, that's good to know.
19:24:31 <gwern> chylli: remove vty, and reinstall vty, making sure it uses 0.9.0.1. the easiest to so make sure would be to nuke the new bytestring
19:24:34 <chylli> TomMD: notonly vty, lots of packages.
19:24:47 <dons> oh, yi explicitly needs the old version?
19:24:56 <TomMD> chylli: 'cabal upgrade' might do it with the latest cabal.
19:25:17 <gwern> dons: believe so, since it calls into ghc api, no?
19:25:28 <chylli> but seems Yi editor using 0.9.0.1, others use 0.9.1.0
19:25:30 <dons> ah
19:26:08 <gwern> chylli: well, there's good reason for that, irksome as it is
19:26:15 <gwern> gods, I hope 6.8.3 used 0.9.1!
19:26:38 <gwern> dons: please tell me ghc 6.8.3 was compiled against an updated bytestring :(
19:26:43 <chylli> gwern: I hate bytestring!!!
19:26:46 <chylli> sigh
19:27:25 <monochrom> hackage hell? :)
19:27:49 <gwern> there there chylli. it's really GHC's fault
19:27:58 <TomMD> chylli: Bytestring is good, yi's dependence on an internal aspect is bad.
19:27:58 <chylli> gwern: then I hate ghc :p
19:28:03 <Elly> you guys are talking about cabal like it's a package manager, but when I ask ubuntu to install cabal for me, I get no such effect :(
19:28:17 <chylli> TomMD: which one should I hate?
19:28:30 <TomMD> yi... then dons, he started both ;-)
19:28:42 <TomMD> Or at least was involved.
19:28:49 <monochrom> ubuntu is not a respectable distro.
19:28:59 <gwern> Elly: well, isn't ubuntu's cabal package horribly obsolete? I think it's at 1.1 or something
19:29:03 <gwern> TomMD: no, dons didn't start yi
19:29:05 <chylli> TomMD: what should I do now ? waiting for a new version of Yi ?
19:29:16 <TomMD> gwern: No?  I always confuse my yi history.
19:29:37 <chylli> TomMD: are you using Yi now ?
19:29:47 <chylli> Yi sounds like a chinese word
19:29:53 <gwern> chylli: well, I would wait for ghc 6.8.3, which hopefully will link against the latest bytestring and hide this problem until such time as another bytestring gets released
19:29:55 <TomMD> chylli: you could, at your option, perform "ghc-pkg unregister bytestring-newest-version-number"
19:30:10 <TomMD> And remove / reinstall vty based on the old.
19:30:10 <gwern> chylli: japanese, iirc
19:30:27 <gwern> TomMD: he'd still need to recompile vty
19:30:29 <TomMD> I just setup this system a week ago and was able to "cabal install yi" with no issues.
19:30:35 <chylli> TomMD: but I has upgrade almost all of packages to newset bytestring.
19:30:37 <dons> gwern: no, why would it.
19:30:57 <dons> gwern: it doesn't link against the new bytestring.
19:31:05 <dons> you just need to explicitly build yi with the old one.
19:31:08 <chylli> gwern: what ever, it is no different to me that it is chinse or japenese.
19:31:11 <TomMD> chylli: I made the same mistake once... I learned.
19:31:17 <chylli> gwern: I'm chinese
19:31:51 <gwern> chylli: well, it could be korean too. eg. the turtle ship dude, admiral Yi sun-whatever
19:31:53 <PHO_> chylli: There's no japanese word "Yi"
19:31:54 <mrd> yi isn't in the japanese phonemes
19:32:12 <mrd> the closest would be iai
19:32:24 <chylli> I believe it is a Chinese word
19:33:03 <chylli> dons: what's the command to instruct compiler to using old bytestring ?
19:33:08 <gwern> (ah, it was Admiral Yi Sun-sin. I was close)
19:33:27 <dons> hmm. one way would be to remove the new bytestring temporarily ( also removing vty)
19:33:33 <dons> then build yi.
19:33:56 <dons> ghc-pkg unregister bytestring-0.9.1.0 ; ghc-pkg unregister vty ; cabal install yi -- might just work
19:34:43 <chylli> dons: unregister all of packages which using new bytestirng ?
19:34:51 <mmorrow> just like shooting fish in a barrel
19:35:15 <PHO_> mrd: yi was one of the distinct japanese phonemes a long long time ago, maybe 1000 or more years ago
19:35:21 <dons> chylli: yeah, i think that will work.
19:35:26 <dons> hey PHO_
19:35:27 <mrd> maybe. i heard of 'ye'
19:35:40 <PHO_> dons: ?
19:35:46 <dons> PHO_: are you "pho" the haskell package writer?
19:35:51 <PHO_> yes.
19:35:54 <dons> welcome! :)
19:35:54 <PHO_> pho@cielonegro.org
19:36:01 <PHO_> thanks :)
19:36:08 <dons> hsopenssl
19:36:11 <dons> hssvn?
19:36:28 <chylli> dons: is there a faq about this problem ?
19:36:30 <PHO_> yeah, and Lucu, hshyperestraier, etc...
19:36:37 <dons> chylli: hmm. seems like it would be a good idea, chylli
19:36:40 <chylli> I think it is not uncommon.
19:36:49 <dons> it should be a yi faq
19:37:09 <chylli> dons: not only yi. I meet this porblem before when install something.
19:37:17 <chylli> maybe HAppServer
19:37:26 <chylli> or something else
19:37:35 <gwern> chylli: it's covered in the Yi haskell.org FAQ page
19:37:50 <gwern> we've been encountering it for a long time now :(
19:37:51 <chylli> gwern: thanks
19:37:54 <dons> PHO_: http://aur.archlinux.org/packages.php?ID=17661 :) uploaded yesterday
19:37:55 <lambdabot> Title: AUR (en) - haskell-hsopenssl
19:38:09 <chylli> is anyone using Yi now ?
19:38:09 <PHO_> woa
19:38:14 <dons> it's a well understood problem, that forced cabal-install to work properly.
19:38:34 <dons> hopenssl is also in there too, fwiw.
19:38:40 <bos31337> dons: what does arch linux do for multiple versions of a single package?
19:39:11 <dons> it uses the lastest version
19:39:15 <dons> wiki-style.
19:39:25 <dons> everyone resyncs with the latest snapshot
19:39:28 <dons> no releases.
19:39:40 <dons> its the 'cabal install' of distros :)
19:40:16 <dons> would be interesting to implement arbitrary disto-state undo on top of this. hmm
19:41:25 <bos> i think we should recommend "cabal install" in the book.
19:41:48 <bos> it just beats the poo out of foontling about in hackage by hand.
19:41:53 <dons> that's a good idea.
19:42:09 <dons> i expect most distros to have a copy within a few months
19:42:14 <bos> however, our ace cabal ninjas need to release binary installers of the thing for windows and OS X.
19:42:36 <dons> mm. yes, a .dmg for the mac would be a great tool
19:43:05 <mwotton_> speaking of foontling about in hackage by hand - what do i have to do to get bytestring exposed so that collections will install?
19:43:07 <ddarius> Apply that new damage file.
19:43:29 <dons> i think cabal-install should be step 2 in 'haskell platform accreditation' ,after a working ghc 6.8.x
19:43:34 <bos> mwotton_: muh?
19:43:45 <dons> we can think rank distros based on how well they support haskell
19:43:50 <mwotton_>    Could not find module `Data.ByteString.Lazy':
19:43:50 <mwotton_>       it is a member of package bytestring-0.9.1.0, which is hidden
19:43:57 <mwotton_> when i try to install collections :/
19:44:01 <dons> mwotton_: you have to edit the collections .cabal file by hand
19:44:08 <dons> since it is written prior to the base split up
19:44:14 <dons> one of about 15 packages left on hackage that are in this state
19:44:21 <mwotton_> ah
19:44:22 <dons> changing build-depends: base to build-depends base, bytestring
19:44:24 <dons> might be enough
19:44:27 <mwotton_> ok, cool. :)
19:44:50 <dons> i've a list here of the packages failing to build due to those silly reasons. the authors will be receiving personal emails
19:45:02 <dons> (now i got my own house in order)
19:45:14 <dons> ah, speaking of the devil. bos, suffixtree isn't small-base compliant
19:45:40 <bos> small-base?
19:45:41 <chylli> dons: I has unregistered all of dependent packages, but the problem still appear...
19:45:42 <dons> http://hackage.haskell.org/packages/archive/suffixtree/0.2.1/suffixtree.cabal
19:45:44 <lambdabot> http://tinyurl.com/6fvqm8
19:45:44 <adu> speaking of bytestring, I had a small implementation of one of its typeclasses
19:45:56 <bos> what is this small-base of which you speak?
19:46:00 <dons> bos, yeah,
19:46:00 <dons> flag small_base description: Choose the new smaller, split-up base package.
19:46:05 <dons>     if flag(small_base)
19:46:05 <dons>         build-depends: base >= 3,
19:46:05 <dons>                        bytestring >= 0.9,
19:46:23 <dons> the required if-def for compatibility between base < 3 and base >= 3
19:46:50 <bos> oh, i must have made a mistake somewhere. hm.
19:47:10 <hpaste>  dons pasted "typical small-base compliance example" at http://hpaste.org/8390
19:47:21 <bos> i only understood what cabal configurations actually *are* this morning, when i was writing 'em up for the book.
19:47:30 <dons> heh
19:47:39 <bos> prior to that, it was all copy-and-paste cargo cultism.
19:47:46 <dons> right, suffixtree is pre-configurations
19:48:15 <dons> a corrected .cabal would be,
19:48:23 <dons> well, leading to,
19:48:24 <dons>     Could not find module `Data.ByteString.Lazy':
19:48:24 <dons>       it is a member of package bytestring-0.9.0.1, which is hidden
19:49:10 <bos> sure, it's easily fixe.d
19:50:27 <bos> i'm doing a substantial cleanup of the fedora ghc package at the moment.
19:50:29 <gwern> oh, jpb applied my collections patches
19:50:46 <dons> gwern: great.
19:50:46 * gwern better upload tarballs then
19:50:47 <hpaste>  adu pasted "ByteString stuff" at http://hpaste.org/8391
19:50:51 <hpaste>  dons pasted "suffixtree.cabal" at http://hpaste.org/8392
19:51:26 <gwern> bos: remember to add profiling support for ghc api
19:51:58 <bos> gwern: i have no idea what that might involve
19:52:18 <dons> gwern: oh, you mean ghc-api complied -prof ?
19:52:38 <gwern> bos: a slight edit to config.mk, iirc
19:53:08 <gwern> http://www.haskell.org/haskellwiki/GHC/As_a_library#Profiling
19:53:08 <lambdabot> Title: GHC/As a library - HaskellWiki
19:53:14 <adu> Has the format of the ghc -package-conf files changed between 6.2 and 6.8?
19:53:17 <bos> dons: does arch consider extralibs as a monolithic chunk, or as a pile of little packages?
19:53:22 <gwern> dons: yes, so one could compile yi/haddock/mueval/etc. with -p
19:53:33 <gwern> otherwise you error quickly on Outputable not being profiled
19:53:44 <adu> gwern: whats -p?
19:53:46 <chylli> gwern: are you talking about my Yi problem ?
19:54:03 <adu> chylli: you having Yi problems?
19:54:17 <gwern> adu: cabal flag to add -prof -auto-all, iirc
19:54:20 <chylli> adu: yes, bytestring problem
19:54:47 <bos> i'm trying to decide whether fedora should consider extralibs as a pile of little packages or as a monolithic chunk (as it does now).
19:54:52 <dobblego> ?src compare []
19:54:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:54:56 <dobblego> ?src [] compare
19:54:57 <lambdabot> Source not found. You type like i drive.
19:54:59 <adu> chylli: look at my Yi pics, it will make you feel better... :)
19:55:01 <adu> http://tetration.itgo.com/up/art2.zip
19:55:04 <dons> bos, extra-libs are parsed individuallly. i have a lookup table to the actual C packages they correspond to
19:55:15 <bos> debian breaks extralibs into pieces, and i've found that annoying in practice. i can't compile simple stuff because i don't have mtl installed, etc.
19:55:25 <dons> so, say, 'Imlib2' -> "imlib" , "pcap" -> "libpcap" , "alut" -> "freealut" or something
19:55:37 <dons> oh, you mean extra haskell libs
19:55:44 <bos> yes, the ones usually bundled with ghc.
19:55:44 <dons> no, that's a monolithic chunk
19:55:52 <dons> yeah, all those map to the 'ghc' package
19:56:02 <dons> so i have to filter them out, and replace them with a reference to 'ghc'
19:56:04 <bos> ok, so we're not alone in fedora-land :-)
19:56:12 <dons> other libs i convert the name to 'haskell-$name'
19:56:16 <chylli> adu: is it screenshot ?
19:56:24 <dons> e.g. haskell-haxml or haskell-binary
19:56:26 <bos> how do you package cabal-install, then?
19:56:41 <dons> cabal-install is just an executable, that depends on haskell-cabal>=1.4, iirc
19:56:47 <bos> i see.
19:56:54 <dons> so its a special case, since it needs a new cabal
19:56:59 <adu> chylli: no, its a 1200x1200 icon (you have to zoom out) and a wallpaper...
19:57:08 <dons> for some of those extralibs there are individual packages -- you're right
19:57:37 <dons> http://aur.archlinux.org/packages.php?ID=17411
19:57:38 <lambdabot> Title: AUR (en) - cabal-install
19:57:43 <chylli> adu: excellent, but it is not what I need :p
19:57:44 <dons> arch=('i686' 'x86_64')
19:57:44 <dons> makedepends=('ghc' 'haskell-http' 'haskell-zlib>=0.4')
19:58:01 <dons> oh, that looks wrong actually! bad gour.
19:58:08 <adu> chylli: but if you want a screenshot, I can make one for you :)
19:59:05 <chylli> adu: what I really need is how to install Yi editor :p
19:59:36 <adu> chylli: I just did that yesterday...
19:59:39 <adu> chylli: it was hard
19:59:52 <adu> chylli: but maybe I can help
19:59:56 <chylli> adu: 義義義...
20:00:16 <chylli> adu: gou yi qi :p
20:00:37 <chylli> adu: I think I should remove all about ghc, then install it :(
20:00:43 <chylli> s/install/reinstall/
20:00:54 <adu> chylli: ok, I'll help you through it if you want
20:00:58 <chylli> unregistering package is not enough
20:01:33 <chylli> dons: is there a compiled version if yi in aur ? I didn't find it.
20:02:17 <dons> no, not yet. since it won't build for me
20:02:29 <dons> getting closer to an automated build though.
20:03:15 * papermachine_ contemplates Yi.
20:03:48 <bos> dons: when you're writing about the FFI, are you going to mention hsc2hs?
20:04:01 <adu> papermachine_: have you installed it yet?
20:04:05 <gwern> does yi have the lambda nature?
20:04:06 <papermachine_> Nope.
20:04:08 * ddarius doesn't understand why so many people want to install Yi.
20:04:27 <ddarius> Yi has the no-official-public-release nature.
20:04:40 <bos> it's like emacs has been for the past decade.
20:04:41 <PHO_> just for fun?
20:04:55 <dons> bos, yes, it's required.
20:04:56 <gwern> ddarius: lies! there's three official public releases
20:05:06 <gwern> (.1, .2, and .3)
20:05:12 <gwern> although I don't actually know where you'd get .1 anymore
20:05:12 <dons> 0.1 was the best :)
20:05:15 <golubovsky> Hi everybody, Dmitry here
20:05:21 <bos> choosing a text editor is like choosing a religion, skin colour and sexual orientation all at once. it's hard to change after a while.
20:05:21 <dons> hey golubovsky
20:05:37 <PHO_> I have once tried yi. It was kind of fun but not very practical
20:05:58 <golubovsky> does anybody know how to find status of a ticket on rt.haskell.org?
20:06:00 * papermachine_ wonders what sexual orientation emacs represents.
20:06:07 <PHO_> so I still use haskell-mode.el
20:06:33 <ddarius> papermachine_: The answer to that is clear.
20:06:35 <bos> papermachine_: http://www.stallman.org/extra/personal.html
20:06:43 <papermachine_> HAHAHAHA
20:07:26 <golubovsky> I tried to create an account on the community/code, nothing in response (I expected some e-mail), I tried ~24h ago.
20:07:50 <golubovsky> I sent a request to support@community, and got ticket number on rt.haskell.org
20:08:01 <ddarius> golubovsky: Wait longer.
20:08:41 <golubovsky> How long? It is not urgent, but I thought those accounts are created automatically, aren't they?
20:08:54 <ddarius> I highly doubt that they are.
20:08:57 <dons> golubovsky: actually, pinging malcolmw or igloo here should get it done
20:10:42 <bos> a nice thing about compiling FFI bindings with -fvia-C is that if you specify a header file in an FFI declaration for a function, the C compiler will typecheck your FFI binding.
20:10:51 <bos> we lose that with -fasm, which is a shame.
20:11:05 <bos> makes it easier to bugger up your types by saying CInt when you meant CSize.
20:11:55 <noecksit> :t liftM6
20:11:57 <lambdabot> Not in scope: `liftM6'
20:12:02 <noecksit> :t liftM5
20:12:04 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
20:12:07 <golubovsky> @ping igloo
20:12:08 <lambdabot> pong
20:12:13 <noecksit> is there no liftM6?
20:12:27 <dobblego> noecksit, no, there are other abstractions available, like Applicative
20:12:29 <dons> cabal upload ftw.
20:13:11 <dobblego> noecksit, note that liftM<N> can be written with liftM<N - 1> and ap (which is one of the functions of Applicative)
20:13:19 <byorgey> liftM6 g a b c d e f = g <$> a <*> b <*> c <*> d ...
20:13:20 <dons> bos, yeah, i use -fvia-C with FFI just for the checking
20:13:27 <golubovsky> OK, sent Igloo a PM.
20:13:30 <golubovsky> Thanks.
20:13:46 <gwern> excellent, collections is uploaded
20:13:46 <byorgey> dobblego: actually, ap is in Control.Monad, (<*>) is probably what you're thinking of
20:14:01 <noecksit> ok, im not too familiar with applicative yet, all I know is what <$> does
20:14:02 <dons> does all that stuff build, gwern ?
20:14:04 <byorgey> they are the same for reasonable Monad instances
20:14:13 <dobblego> byorgey, sorry, I meant "corresponds to one of the functions of Applicative"
20:14:14 <byorgey> noecksit: right, <$> is just fmap
20:14:16 <gwern> now off to buy a well-deserved loaf of bread
20:14:22 <byorgey> dobblego: indeed, it does =)
20:14:23 <dons> gwern: oh, you split up collections?
20:14:26 <dobblego> which reminds me, is there a spoken name for the (<*>) function?
20:14:32 <pgavin> @where stream fusion
20:14:32 <lambdabot> I know nothing about stream.
20:14:39 <dons> yeah, you say it "<*>"
20:14:43 <byorgey> dobblego: 'splort'
20:14:49 <Korollary> Is there enough GADT (or whatever type system extension powah) to parameterize the likes of liftMn using some encoding of naturals?
20:14:52 <EvilTerran> i just say "ap" for <*>
20:15:03 * ddarius would just say ap.
20:15:06 <noecksit> what is <*> supposed to represent?
20:15:09 <noecksit> :t <*>
20:15:10 <lambdabot> parse error on input `<*>'
20:15:14 <ddarius> :t (<*>)
20:15:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:15:37 <EvilTerran> it's applying a lifted function to a lifted parameter and getting out a lifted result
20:15:53 <dons> Lemmih: i fixed libxml. i saw you hadn't touched it since 2006, so just fixed it to build and uploaded 0.1.1
20:15:54 <byorgey> i.e. function application 'inside' a functor
20:16:27 <dons> what, is this a joke: "Tokyo Society for the Application of Currying" !:)
20:16:39 <dons> that's so awesome, http://www.starling-software.com/en/tsac.html
20:16:41 <lambdabot> Title: Tokyo Society for the Application of Currying - Starling Software
20:16:51 <dons> "should not be confused with the Tokyo Schönfinkel Appreciation Club "
20:16:54 <noecksit> is there any good paper, tutorial or guide on applicative online?
20:17:18 <dobblego> @google functional programming with applicative effects
20:17:19 <lambdabot> http://en.wikipedia.org/wiki/Functional_programming
20:17:29 <bos> noecksit: http://book.realworldhaskell.org/beta/binary.html
20:17:31 <lambdabot> Title: Chapter 12. Code case study: parsing a binary data format
20:17:31 <dobblego> not that :)
20:17:34 <pgavin> @where streams
20:17:34 <lambdabot> I know nothing about streams.
20:17:58 <dobblego> http://strictlypositive.org/IdiomLite.pdf
20:18:03 <pgavin> @help where+
20:18:03 <lambdabot> where+ <key> <elem>. Define an association
20:18:04 <byorgey> noecksit: http://www.soi.city.ac.uk/~ross/papers/Applicative.html
20:18:05 <lambdabot> Title: Applicative Programming with Effects
20:18:12 <pgavin> @where+ streams http://www.cse.unsw.edu.au/~dons/streams.html
20:18:12 <lambdabot> I will remember.
20:18:16 <Korollary> dons: I'm surprised that it's in English
20:18:24 <dons> http://www.cynic.net/tsac.html
20:18:25 <lambdabot> Title: Tokyo Schönfinkel Appreciation Club - Cynic Networking Laboratories
20:18:38 <dons> Korollary: expats mostly?
20:18:41 <bos> the research papers on Applicative and idioms assume a fair amount of background.
20:18:45 <OceanSpray> :t ma[p
20:18:46 <lambdabot> parse error (possibly incorrect indentation)
20:18:46 <OceanSpray> :t map
20:18:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:18:58 <bos> they're not exactly accessible.
20:19:19 <dons> bos, i remember we sat around for about 2 years after conor started raving about idioms before us mortals realised what was going on.
20:19:37 <dons> he'd already wandered off into idiom brackets, idioms in epigram and so on
20:19:50 <Korollary> dons: lost in translation
20:19:51 <bos> they're tremendously easy to use, once someone spoonfeeds you little prechewed moistened lumps.
20:20:16 <bos> i don't remember where i figured them out, but it wasn't from reading anything conor wrote :-)
20:20:17 <ddarius> Note to self: Never eat over at bos' place
20:20:37 <dons> applicatives comes served in wee little jars, http://www.organicsonly.com.au/upload/product_img/28082006150455337.jpg
20:20:38 <lambdabot> http://tinyurl.com/6xx5r6
20:20:39 <bos> ddarius: if it worked for 250 million years of bird evolution, it's good enough for me.
20:21:01 <dons> actually, baby food jars would make good logos for haskell packages
20:21:08 <bos> oh, the chapter where i burble happily about Applicative isn't online yet. bugger.
20:21:09 <dons> ones with little lambdas and applicative symbols on them
20:21:10 <SamB> hah
20:21:10 <Korollary> dons: not manly enough
20:21:21 <dons> ok, 44 gallon drums of crude
20:21:33 <Korollary> dons: and a shotgun and a bacon cheeseburger
20:21:39 <dons> black, smokey lambdas
20:21:49 <byorgey> crude... SCOTCH BONNET JUICE
20:21:50 <dons> burning in the hot desert sun
20:21:51 <bos> actually, i think haskell would have to be an oxyacetyline cylinder.
20:21:59 <dons> mmm
20:22:09 <bos> or perhaps the plasma confined in a tokamak.
20:22:18 <dons> yeah, future weapons.
20:22:28 <bos> or maybe it's the hawking radiation causing a black hole to evaporate.
20:22:33 <Korollary> Arctic Warfare Magnum sniper rifle
20:23:08 <noecksit> the paper seems very promising actually, thanx
20:23:10 <dons> this guy understands monads, http://www.hdgamenews.com/uploaded_images/future-weapons-766963.jpg
20:23:10 <lambdabot> http://tinyurl.com/65gko5
20:24:14 <PHO_> He surely understands higher-rank polymorphism
20:24:39 <papermachine_> Setup.hs: Package yi-0.3 can't be built on this system. :(
20:24:43 <papermachine_> Ah well.
20:24:52 <dons> warning, contains category theory: http://www.defensereview.com/stories/aa-12/FRAG-12%20Projectile_1.jpg
20:24:53 <lambdabot> http://tinyurl.com/295tat
20:25:18 <chylli> I really want to know, is it a plan to resolve the dependent problem ?
20:25:34 <byorgey> papermachine_: that error usually means you don't have a UI package installed: yi needs either vty (console-based) or gtk2hs (GUI).
20:25:39 <bos> dons: this would be the PHP image: http://www.joe-ks.com/archives_may2004/6NailHeadA.jpg
20:25:41 <papermachine_> That contains category theory? mrr.
20:25:52 <papermachine_> Ah, ok.
20:26:06 <dons> bos, yes, your brain on monads
20:26:16 <Pseudonym> There's category theory and there's category theory.
20:26:21 <dons> oh dear. he doesn't look at all healthy
20:26:45 <pgavin> is there a category theoretical aspect ot Applicative as well?
20:26:48 <byorgey> someone had a wee mishap with a nail gun, perhaps?
20:26:55 <byorgey> pgavin: of course!
20:27:22 <pgavin> awesome
20:27:23 <Pseudonym> pgavin: Yes!
20:27:33 * papermachine_ apt-gets
20:27:39 <pgavin> is there anything *not* explainable through category theory?
20:27:55 <araujo> category theory itself
20:27:58 <pgavin> lol
20:28:01 <papermachine_> nope
20:28:12 <papermachine_> there's a category-theoretical definition of categories.
20:28:23 <Pseudonym> Scientology isn't explainable with or without category theory.
20:28:27 <pgavin> is the category of all categories that are do not contain themselves a category of itself?
20:28:30 <Pseudonym> I think that's everything, though.
20:28:49 <papermachine_> Bah, foundations are annoying.
20:28:58 <Pseudonym> http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows-and-idioms <- This might help; category explanation of Applicative.
20:29:00 <lambdabot> Title: Wadler: Links, http://tinyurl.com/5j58vk
20:29:01 <papermachine_> I prefer ukiyo-e mathematics.
20:29:09 <araujo> pgavin, only if such a category is contained itself inside every category of them
20:29:25 <PHO_> Let's build quantum mechanics on top of category theory!
20:29:36 <Korollary> There are physicists who use CT
20:29:45 <pgavin> PHO_: then model it in Haskell :)
20:29:46 <PHO_> woa
20:29:50 <Korollary> @google john baez
20:29:50 <byorgey> PHO_: actually, I understand those are rather related =)
20:29:50 <lambdabot> http://math.ucr.edu/home/baez/
20:29:50 <lambdabot> Title: John Baez's Stuff
20:30:06 <Pseudonym> PHO_: Already done.
20:30:15 * byorgey sings the 'everything is category theory' song
20:30:16 <pgavin> quantum mechanics is just more evidence that the universe is a computer simulation
20:30:18 <PHO_> I can't believe that...
20:30:29 <Pseudonym> http://math.ucr.edu/home/baez/rosetta.pdf
20:30:39 <pgavin> quantum mechanics happens when we hit the round-off errors
20:30:50 <Pseudonym> PHO_: Go read.
20:31:00 <monochrom> hahahaha
20:31:22 * PHO_ starts to read the pdf
20:31:39 * ddarius should probably read it again if it has been finalized.
20:31:39 <dobblego> > Left 7 < Right 7
20:31:41 <lambdabot>  True
20:32:01 <EvilTerran> > Left undefined < Right undefined
20:32:02 <lambdabot>  True
20:33:08 <pgavin> Pseudonym: wow, awesome paper :)
20:33:29 <pgavin> Pseudonym: I need to print this out and give copies to my profs
20:33:57 <pgavin> they keep asking why I want to learn category theory better, this should help them understand
20:34:09 <Pseudonym> Yeah.
20:34:14 * dolio wonders if that's newer than the copy he has.
20:34:15 <Korollary> Usually profs don't ask such questions
20:34:21 <Pseudonym> Essentially, category theory is one level more abstract than abstract algebra.
20:34:39 <ddarius> Pseudonym: It is?
20:34:42 <pgavin> Korollary: ?
20:34:50 <Pseudonym> It's nice to be able to talk about mathematical proofs, lambda calculus programs and physical processes as if they're the same things.
20:34:56 <Pseudonym> ddarius: Yes.
20:34:58 <dons> byorgey: hwn blog item , http://w3future.com/weblog/stories/2008/06/16/adtinjs.xml
20:34:59 <lambdabot> Title: Algebraic Data Types in JavaScript - w3future.com
20:35:07 <swalters> I'm starting to believe that learning haskell is mostly about carefully crafting small and clever functions and then finding out that they are already part of the standard library.
20:35:09 <pgavin> Pseudonym: or stateful programs even
20:35:21 <byorgey> dons: thanks
20:35:28 <Pseudonym> ddarius: What I mean by that is that there are patterns that turn up in different algebras.
20:35:33 <ddarius> Pseudonym: At best, I'd put CT diagonally upward from abstract algebra, if not about lateral.
20:35:35 <pgavin> swalters: part of the process is arriving to those abstractions yourself :)
20:35:46 * byorgey is furiously coding tools to automate putting together the HWN
20:35:47 <EvilTerran> @remember swalters I'm starting to believe that learning haskell is mostly about carefully crafting small and clever functions and then finding out that they are already part of the standard library.
20:35:47 <lambdabot> Done.
20:35:55 <byorgey> hopefully it will pay off in the long run =)
20:35:58 <Pseudonym> And category theory is the only sensible way to describe them as if they'[re the same thing.
20:36:02 <Pseudonym> e.g. the notion of an "ideal".
20:36:11 <byorgey> hurrah, a quote for the HWN! ;)
20:36:19 <ddarius> Pseudonym: Better would be the notion of "free" algebraic structure.
20:36:30 <pgavin> Pseudonym: category theory is the grand unified theory of science
20:36:45 <Pseudonym> pgavin: One proviso on that.
20:36:53 <ddarius> pgavin: You may want to tell the scientists that.
20:36:59 * monochrom should craft a quote too.
20:37:00 <Pseudonym> Category theory, IMO, is primarily a _language_.
20:37:11 <monochrom> @quote monochrom
20:37:11 <lambdabot> monochrom says: people  haskellers =
20:37:19 <Pseudonym> Quantum field theory isn't really a theory either.
20:37:25 <Pseudonym> It's a framework that you can make theories out of.
20:37:27 <monochrom> That one is corrupted.
20:37:33 <SamB> Pseudonym: what do you mean it's not a theory?
20:37:43 <SamB> it's just not a scientific theory...
20:37:53 <Pseudonym> Not by itself.
20:37:54 <SamB> haven't you heard of mathematical theory?
20:38:05 <monochrom> Something like people ∩ haskellers = ∅ IIRC
20:38:17 <SamB> as in, say, theoretical mathematics, theoretical computer science...
20:38:19 <monochrom> @quote monochrom
20:38:20 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
20:38:29 <Pseudonym> Those are really umbrella terms.
20:38:41 <SamB> well yeah
20:38:41 <monochrom> That one is old. Probably already happened in previous HWNs.
20:39:03 <ddarius> Why would it be in a HWN?
20:39:05 <monochrom> "theory" has several meanings. it's just semantics.
20:39:18 <ddarius> "semantics" has several meanings.
20:39:21 <Pseudonym> Actually, "theory" _is_ just semantics if you ask a literary theorist.
20:39:29 <Pseudonym> But I digress.
20:39:50 <Pseudonym> Category theory is a 100% valid mathematical theory, I'm not disputing that.
20:39:56 <Pseudonym> But I see it primarily as a vocabulary.
20:40:08 <SamB> well yes
20:40:17 <ddarius> valid against what model!
20:40:18 <vixey> Has anyone ever seen a correctness proof of RLE encoding?
20:40:24 <Pseudonym> It's a way of describing other mathematical theories.
20:40:32 <Pseudonym> ddarius: The Pseudonym internal model.
20:40:39 <SamB> the most important theories are also vocabulary...
20:40:44 <ddarius> vixey: Maybe.  I'm sure someone has.  I probably haven't.  I could make one.
20:40:45 <vixey> I just realized it's trivial to write a proof in paper for this but it's very very hard to prove formally
20:40:55 <SamB> such as, say, ring, group, monoid, ...
20:41:12 <ddarius> vixey: Simply prove that the encode and decode functions are inverses.
20:41:13 <SamB> vixey: how come?
20:41:28 <vixey> I tried, I did induction on everything, nothing works :(
20:41:40 <monochrom> ddarius: http://sequence.complete.org/hwn/20061114  already features that quote of mine. :)
20:41:41 <lambdabot> Title: Haskell Weekly News: November 14, 2006 | The Haskell Sequence
20:41:55 <SamB> hmm.
20:42:06 <SamB> vixey: well, it might depend on how you implement it?
20:42:23 <SamB> maybe if you first broke the input into runs?
20:42:41 <SamB> (or runs of the appropriate size or less?)
20:42:45 <byorgey> vixey: paste your definitions of encode and decode?
20:42:48 <vixey> yeah if you give weak specifications you can't prove anything, if you try to give really strong specifications you can't even implement the function you want to prove correctness of
20:43:10 <ddarius> vixey: The strongest specification would be an implementation.
20:43:38 <SamB> vixey: well, you could specify it by writing a decoder
20:43:51 <monochrom> Some implementations miss the forest for the trees (from the POV of proving).
20:44:08 <monochrom> You need something abstract enough and concrete enough.
20:44:14 <vixey> span x [] = [(x,1)]
20:44:15 <vixey> span x (y:ys) = if x == y then inc (span y ys) else (x,1):(span y ys)
20:44:21 <ddarius> monochrom: Agreed, but irrelevant to my statement.
20:44:24 <vixey> rle (x:xs) = span x xs
20:44:45 <OceanSpray> Say a new functional language wants to take advantage of existing Haskell libraries and GHC's extensions.
20:44:46 <monochrom> But a relevant advice to everyone who tries to prove things.
20:45:04 <OceanSpray> Should a compiler for that language compile to Haskell or to GHC's Core?
20:45:07 <vixey> splat s 1 tl = s::tl
20:45:09 <vixey> splat s k tl = s::(splat s (k-1) tl)
20:45:24 <ddarius> OceanSpray: Yes.
20:45:26 <SamB> and then define an encoder and prove that decoder ∘ encoder = id
20:45:34 <SamB> er.
20:45:44 <SamB> where by =, I mean pointwise equality
20:45:45 <vixey> unrle [] = []
20:45:47 <vixey> unrle ((s,k):ts) = splat s k (unrle ts)
20:46:09 <SamB> vixey: why no map?
20:46:14 <vixey> oops I used :: instead of :
20:46:14 * monochrom doesn't miss the forest for the trees. wants to give advice to goalseekers, rather than respond to every fine point made in the channel.
20:47:03 <vixey> monochrom: Finding the balance is somewhat.. impossible it seems, I am doing most things by trial and improvement
20:48:05 <monochrom> It is a normal stage of the learning process.
20:48:52 <vixey> oh also inc ((s,x):xs) = (s,x+1):xs
20:48:56 <ddarius> > let encode = map (head &&& length) . group; decode = concatMap (uncurry replicate) in decode . encode $ "It is a normal stage of the learning process."
20:48:57 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
20:49:22 <ddarius> > let encode = map (head &&& length) . group; decode = concatMap (uncurry $ flip replicate) in decode . encode $ "It is a normal stage of the learning process."
20:49:23 <lambdabot>  "It is a normal stage of the learning process."
20:50:20 <thetallguy> anyone know what the time overhead of profiling in ghc is?  I know what the space overhead is.
20:50:21 <lambdabot> thetallguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:50:36 <papermachine> > :t (&&&)
20:50:37 <lambdabot>   parse error on input `:'
20:50:51 <Pseudonym> :t (&&&)
20:50:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:50:59 <papermachine> Thanks.
20:51:37 <ddarius> > concat . group $ "It is a normal stage of the learning process."
20:51:39 <lambdabot>  "It is a normal stage of the learning process."
20:52:49 <ddarius> decode . encode = concat . map (uncurry replicate) . map (length &&& head) . group = concat . map (uncurry replicate . (length &&& head)) . group
20:53:16 <vixey> oh cool
20:53:26 <vixey> there is a way to decompose it into subproblems
20:53:31 <ddarius> You now have two lemmas to prove.  uncurry replicate . (length &&& head) = id (for a restricted domain) and concat . group = id
20:53:38 <vixey> looking at  f . g = id, and f . f' . g' . g
20:53:40 <vixey> = id
20:53:48 <monochrom> nice.
20:54:11 <SamB> of course, it's sure to be a bit trickier than that in a formal setting
20:54:19 <scook0> is there an admin for code.haskell.org about? I need to provide a new ssh key so that I can log on again
20:54:22 <SamB> but that's a decent outline
20:54:27 <ddarius> Also a third lemma that guarantees that group only outputs things that head can accept.
20:54:28 <scook0> or failing that, does anybody know who I should email about it?
20:54:44 <ddarius> Email the key to the support email address.
20:54:58 <byorgey> support@community.haskell.org
20:55:11 <scook0> ah, thanks
20:55:24 <byorgey> then once you've emailed your key to that address, whine about it in here some more until someone does something about it ;)
20:55:31 <byorgey> usually works for me =)
20:57:23 <ddarius> And it's probably best to assume that the input is finite, though that's not completely necessary.
21:02:52 <ddarius> @src group
21:02:52 <lambdabot> group = groupBy (==)
21:02:57 <ddarius> @src groupBy
21:02:57 <lambdabot> groupBy _  []       =  []
21:02:57 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:02:57 <lambdabot>     where (ys,zs) = span (eq x) xs
21:09:00 <bos> dons: do you specify a BuildFlavour when building ghc for arch?
21:12:26 <dons> nope.
21:17:55 <dons> dcoutts: should 'cabal upload --help contain the lines:
21:17:56 <dons> You can store your Hackage login in FIXME: configFile
21:17:57 <dons> using the format ("username","password").
21:18:09 <dons> :)
21:18:35 <orbitz> hi, i have some code that is producing a tree and when i run it, it prints out par to fht tree and just hagn there.  it doesn't seem to be in an infinite loop (although since things are lazy maybe it's just not being executed?) any suggestison on debugging it?
21:19:27 <dolio> Are you in ghci?
21:19:40 <orbitz> yes
21:19:48 <dolio> Compile it, I bet it's an infinite loop.
21:20:09 <dolio> Blackholing in ghci just halts execution, as I recall.
21:20:21 <dolio> So there's no exception, but also no cpu usage.
21:20:37 <orbitz> ok
21:20:58 <Korollary> you can insert Debug.Trace statements
21:21:19 <Korollary> ghci has a debugger, too
21:21:45 <orbitz> Korollary: i have done that but since no function seems ot be executed i don't see much
21:22:05 <byorgey> orbitz: what would you expect it to do after printing the tree?
21:22:24 <orbitz> hah
21:22:25 <orbitz> after compiling it
21:22:28 <orbitz> i get a stack overflow
21:22:37 <orbitz> byorgey: i'd expec tto get a prompt
21:23:03 <byorgey> orbitz: ok, if you get a stack overflow, then sounds like an infinite loop for sure.
21:23:09 <orbitz> yeah def
21:23:17 <orbitz> just didn't see it in th eitnerpreter
21:23:24 <byorgey> orbitz: you should also make sure that you are turning off output buffering if you want to see the prompt before entering input
21:24:15 <orbitz> byorgey: i won't be entering any input here, just calling a function with a string it iwll turn into a tree
21:24:43 <byorgey> oh, 'expect to get a prompt' meaning back to the terminal/ghci prompt?
21:24:52 <orbitz> yes
21:24:54 <byorgey> I thought you meant your program would display a prompt =)
21:25:01 <orbitz> sorry for being imprecise:)
21:25:05 <byorgey> hehe, never mind then
21:25:07 <byorgey> no problem =)
21:25:20 <orbitz> can i get a stack trace from a stack overflow?
21:26:59 <byorgey> orbitz: I don't know, I've never tried
21:27:47 <orbitz> ugh this code i sso ugly, it's not very haskell
21:31:04 <orbitz> hrm
21:31:06 <orbitz> well i foudn the error
21:31:27 <orbitz> i was doig let f = foo in let f = bar f in f
21:31:40 <orbitz> i though ti could shadow bindings liek that but clearly i'm wrong
21:33:37 <byorgey> orbitz: you can shadow bindings.
21:33:59 <byorgey> the first f there is different from the other three
21:33:59 <dobblego> how do I get (.) = fmap with an import?
21:34:05 <byorgey> but the other three are all the same
21:34:34 <byorgey> dobblego: you just have to define it yourself, it's not in the standard libraries
21:34:40 <dobblego> ok ta
21:34:43 <byorgey> only in the special lambdabot libraries
21:35:10 <adu> dobblego: diy
21:38:31 <augustss> dobblego: import Prelude hiding((.)); (.) = fmap
21:38:57 <augustss> modulo the monomorphism restriction
21:46:25 <hpaste>  dobblego pasted "(no title)" at http://hpaste.org/8393
21:46:46 <vixey> @check \x  -> let encode = map (length &&& head) . group ; decode = concat . map (uncurry replicate) in decode . encode $ x == x
21:46:48 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
21:47:27 <vixey> @check \x  ->  ((concat . map (uncurry replicate)) ((map (length &&& head) . group) x)) == x
21:47:28 <lambdabot>  OK, passed 500 tests.
21:47:49 <vixey> @check \x  ->  ((map (uncurry replicate)) ((map (length &&& head)) x)) == x
21:47:50 <lambdabot>   add an instance declaration for (Eq (f [a]))
21:48:20 <vixey> @check \x y  ->  ((map (uncurry replicate)) ((map (length &&& head)) x)) y == x y
21:48:21 <lambdabot>  OK, passed 500 tests.
21:48:55 <vixey> :(
21:49:06 <vixey> > (map (length &&& head)) [[]]
21:49:08 <lambdabot>  [(0,Exception: Prelude.head: empty list
22:01:58 <byorgey> Or, on learning the alphabet. =P
22:02:39 <byorgey> mischan.  your challenge is now to come up with a haskell-related question for which that answer makes sense, retroactively.
22:22:04 <chylli> is there an pkgbuild about ghc 6.8.3 ?
22:23:38 <dons> PHO_: http://aur.archlinux.org/packages.php?ID=17844
22:24:16 <PHO_> :)
22:31:27 <dobblego> ?type guard
22:31:28 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:33:42 <roconnor> > guard true
22:33:43 <lambdabot>   Not in scope: `true'
22:33:48 <roconnor> > guard True
22:33:48 <lambdabot>   add an instance declaration for (Show (m ()))
22:33:58 <roconnor> > guard True : [()]
22:33:59 <lambdabot>  Couldn't match expected type `m ()' against inferred type `()'
22:34:07 <roconnor> > guard True :: [()]
22:34:08 <lambdabot>  [()]
22:34:14 <roconnor> > guard False :: [()]
22:34:15 <lambdabot>  []
22:51:30 <roconnor> @spell Cartesian
22:52:27 <roconnor> Cartesian product sounds nicer than cross product
22:54:02 <mjrosenb> roconnor: but cartesian is longer to type and harder to fit into 80 characters
22:55:08 <Deewiant> > length "cartesian" <= 80
22:55:11 <lambdabot>  True
22:55:13 <Deewiant> > length "cross" <= 80
22:55:14 <lambdabot>  True
22:55:26 <Deewiant> both seem to fit fairly well to me
22:55:50 <quicksilver> Doesn't work as well in jokes, though.
22:56:00 <quicksilver> "How do you make a Maltese Cartesian?"
22:56:51 <byorgey> what do you get when you take the Cartesian product of a mountain climber and a mosquito?
22:57:27 <byorgey> yeah, doesn't really work =)
22:57:46 <mjrosenb> why did they nail jesus to the cartesian?
23:00:04 <bos> rebuilding ghc on a laptop is a great way to keep my hands warm.
23:02:04 <byorgey> any opinions on whether/how many conference announcements, calls for papers/talks/proposals etc. I should include in the HWN?
23:02:23 <byorgey> would they be helpful or just annoying/take up space?
23:02:44 <quicksilver> I think they should be brief, if mentioned at all.
23:03:03 <quicksilver> Monad.Reader and HCAR, of course, are highly relevant.
23:03:30 <quicksilver> In terms of standard academic conferences it's maybe more interesting to hear if haskell-related papers have been accepted?
23:04:43 <byorgey> right.  ok, that's pretty much what I was thinking too.
23:05:09 <byorgey> I'll try to convince people to let me know if & when they get haskell-related papers accepted.
23:10:52 <dons> 30 uploaded packages today on hackage
23:10:54 <dons> record :)
23:11:01 <dons> some new.
23:12:51 <OceanSpray> oooh
23:15:56 <povman_> does anyone know of a non-happs-state persistence library?
23:16:38 <vixey> the lemma is hard to prove :[
23:16:58 <povman_> should I just use Show and Read?
23:17:07 <vixey> I just need to do, expansions (compressions x) = x -> expansions (compressions (a :: x)) = a :: x
23:17:25 <dons> povman_: or data.binary
23:17:31 <dons> there's 'safecopy' too
23:17:32 <povman_> oooooooo
23:17:57 <byorgey> dons++
23:18:07 <povman_> byorgey: what's that?
23:18:18 <byorgey> povman_: what's what?
23:18:25 <povman_> the ++
23:18:35 <povman_> people keep doing that around here
23:18:40 <byorgey> povman_: I was giving dons a karma point
23:18:51 <byorgey> it's a way to show appreciation when people are helpful or do good work
23:18:55 <byorgey> @karma dons
23:18:55 <lambdabot> dons has a karma of 146
23:19:00 <Axman6> from C++, increments something "makes it greater"
23:19:00 <povman_> ooo
23:19:02 <povman_> @karma povman
23:19:02 <lambdabot> povman has a karma of 0
23:19:05 <povman_> lol
23:19:07 <byorgey> dons has been doing good work for a very long time =)
23:19:10 <PHO_> povman_: or generic-xml http://hackage.haskell.org/cgi-bin/hackage-scripts/package/generic-xml
23:19:18 <PHO_> I've not tried it though
23:19:47 <dons> oh, that's an interesting idea. xml serialisation
23:19:50 <povman_> what would be best would be a haskelly database thing
23:20:03 <dons> well, why not a database then?
23:20:08 <dons> sqlite?
23:20:29 <dons> Data.Binary makes a cheap 'database' in my experience
23:20:33 <PHO_> HaskellDB's SQL combinators are very haskelly
23:20:34 <povman_> i'm scared of databases
23:21:04 <povman_> is there a way of writing some datatypes and having them translated into sql CREATE TABLE's
23:21:34 <dons> that'd be cool. i've often wanted for such a thing
23:21:38 <PHO_> AFAIK there's not
23:21:46 <povman_> gah
23:21:51 <dons> a haskell types to sql compiler...
23:21:59 <sjanssen> I think HaskellDB has something that goes the other way, from SQL to Haskell types
23:22:11 <dons> you might be right, sjanssen . yes.
23:22:24 <sjanssen> but this is a foggy memory from years ago
23:23:00 <povman_> sjanssen: apparently, from looking at the examples
23:23:20 <papermachine> That would be interesting.
23:23:22 <papermachine> Hrm.
23:23:42 <Axman6> a SQLite module would be very nice indeed
23:23:58 <sjanssen> @google site:hackage.haskell.org sqlite
23:23:59 <lambdabot> No Result Found.
23:24:03 <sjanssen> lies!
23:24:03 <dons> Axman6: well, there's lots of sqlite bindings. just no auto generation
23:24:11 <dons> hdbc-sqlite, hsqlite, sqlite3 et al
23:24:13 <PHO_> this one? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sqlite
23:24:19 <Axman6> nice
23:24:22 <dons> that's a fairly complete low level binding
23:24:30 <dons> hdbc-sqlite gives a bit higher level
23:24:56 <dons> ?google sqlite site:hackage.haskell.org/cgi-bin/hackage-scripts/package
23:25:01 <dolio> Does NCG stand for native code generator on the GHC trac?
23:25:05 <dons> dolio: yep
23:25:11 <lambdabot> Plugin `search' failed with: thread killed
23:25:14 <dons> dolio: yep
23:25:16 <dons> ?google sqlite site:hackage.haskell.org/cgi-bin/hackage-scripts/package
23:25:21 <dons> huh.
23:25:31 <sjanssen> dons: @google seems to lie fairly often
23:25:34 <dons> haskelldb-hsql-sqlite
23:25:40 <dons> takusen/sqlite
23:25:44 <dons> hdbc-sqlite
23:26:21 <dons> JaffaCak1: has spj tried upgrading to darcs 2.0 yet?
23:27:54 <thetallguy> we've upgraded, although we haven't converted old repositories yet
23:28:15 <dons> no, neither. just done the upgrade
23:28:46 <thetallguy> is there a recommended method?
23:29:44 <thetallguy> Heh.  I always find these things after I ask.
23:29:52 <thetallguy> darcs get --hashed old new
23:29:59 <bos> we really need to write a ccache analogue for GHC :-)
23:30:18 <thetallguy> I had a rough design for that
23:30:20 <sjanssen> bos: that would incredibly useful
23:30:38 <idnar> ghccache
23:30:43 <bos> rebuilding GHC takes so long for the most trivial of changes that it would save a lot of time.
23:30:57 <povman_> haskelldb won't compile with ghc6.8 because it was only released in 2007
23:31:28 <bos> unfortunately, GHC is very clever with flags like --make, so writing a hccache program would actually be rather tricky.
23:32:15 <bos> it would almost be handier if ghc --make created a little makefile and then executed it, instead of doing everything from a single process.
23:32:30 <dobblego> are there type-classes for scanr/scanl like there is for foldl/foldr?
23:34:06 <dons> good idea, dobblego. Scannable
23:34:19 <dons> they should probably be part of Foldable
23:34:30 <dons> since you can implement one with the other
23:34:43 <sjanssen> one can imagine classes that are foldable but aren't scannable
23:34:47 <bos> does anyone actually use scan?
23:35:00 <Pseudonym> scanl, yes
23:35:00 <sjanssen> dobblego: I think you could write the various scans with the Traversable class
23:35:04 <dons> scan on arrays is common in some math stuff.
23:35:15 <Pseudonym> scanl is an automaton in a can.
23:35:30 <dons> > fix ((0:) . scanl (+) 1) -- lovely
23:35:32 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:35:41 <dons> can't get more real world than that.
23:36:02 * dolio uses fibonacci numbers constantly.
23:36:07 <Pseudonym> Yeah, Haskell can solve any problem concisely, so long as it's Fibonacci numbers.
23:36:16 <Pseudonym> Oh, and the Hamming problem.
23:36:23 <dons> good thing xmonad has a fibonacci layout
23:36:27 <bos> and an infinite list of ones
23:36:36 <dons> we were able to reduce window management to fibonaccis, luckily
23:36:44 <Pseudonym> Don't be silly.  Who needs an infinite list of ones in a "real" program?
23:36:53 <dobblego> can a scan really be written with a Foldable or don't you also need construction?
23:37:03 * sjanssen thinks only crazy people would really want their windows in a spiral
23:37:13 <sjanssen> dobblego: yes, you need something more than Foldable
23:37:56 <sjanssen> dobblego: I think Traversable could work, since scan is like mapM in the State Monad
23:37:56 <dons>  => (a -> b -> a) -> a -> t b -> t a ?
23:39:20 <dobblego> sjanssen, ok, I'll give it a burl on Traversable in a tick, thanks
23:43:52 <shapr> whee
23:44:13 <PHO_> @closedform fix ((0:) . scanl (+) 1)
23:44:13 <lambdabot> Unknown command, try @list
23:44:20 <PHO_> <lambdabot> \ n -> (1/sqrt 5)*(((1+sqrt 5)/2)^^n-((1-sqrt 5)/2)^^n)
23:45:51 <povman_> povman--
23:45:54 <povman_> @karma povman
23:45:54 <lambdabot> povman has a karma of -1
23:45:58 <povman_> ooo
23:46:01 <povman_> povman++
23:46:03 <povman_> @karma povman
23:46:03 <lambdabot> povman has a karma of 0
23:46:07 <povman_> ...
23:46:12 <povman_> povman++
23:46:19 <povman_> @karma povman
23:46:20 <lambdabot> povman has a karma of 1
23:46:38 <povman_> I 4ms t3h 1337 haxs0r
23:52:08 <mjrosenb> @karma jhc
23:52:08 <lambdabot> jhc has a karma of 1
23:52:22 <mjrosenb> sweet
