00:00:32 <silver> mmorrow: I have not seen this, I'll bookmark
00:00:46 <silver> I'm going to be busy while I am in Europe!
00:01:08 <mmorrow> silver: nice. check them out if you're interested in linalg in haskell without writing your own
00:01:26 <silver> That will be good, I could use that in my simulator
00:01:51 <mmorrow> silver: and if you were so inclined, could very easily customized code to you partic desire
00:02:06 <mmorrow> s/d//
00:02:42 <silver> I worka nuclear collision event simulator in Java, I would like to recode it into Haskell once I get good
00:02:53 <silver> wrote I mean
00:03:40 <silver> It seems that it is easier to take advantage of parallel computing using programs written in Haskel
00:03:53 <silver> I work on a computing Cluster from time to time
00:04:48 <mmorrow> i don't know what you're comparing it against, so i hesitate to say yes/no
00:05:22 <mmorrow> but, you should definitely reimplem your sim in haskell, you will be so much happier with the result
00:06:05 <silver> Is GUI and multi-media very hard in haskell?
00:06:20 <silver> The GUI is current written using Swing in Java
00:06:47 <silver> the muti-media is just a bunch of dots, but I would not mind 3D animation
00:07:09 <adu> silver: deep
00:07:10 <mmorrow> hmm, i say either do a web interface things or start learning a gui toolkit, but i'm not that familiar with any..
00:07:15 <silver> deep?
00:07:41 <silver> ok, i'll look into that
00:07:53 <mmorrow> silver: oh, also OpenGL come in the stdlibs
00:07:56 <adu> silver: my favorite functor is the one that maps complex numbers and holomorphic functions to Vandermond vectors and Carleman matrices
00:08:07 <mmorrow> and GLUT too i believe
00:08:19 <silver> oh, ok
00:08:20 <adu> silver: and one of the reasons why i like them so much is that it allows you to do continuous iteration using linear algebra :)
00:08:27 <silver> I'll have to brush up on OpenGL
00:08:58 <ziman> haskell has quite usable gtk bindings, just pick up a tutorial and have a look
00:08:59 <silver> adu: which function is that?
00:09:35 <adu> silver: the Carleman matrix
00:10:16 <silver> ok
00:10:31 <ziman> http://www.haskell.org/gtk2hs/documentation/#tutorials there, hello world
00:11:39 <silver> adu: I hadn't heard of that, looks interesting
00:12:35 <silver> ziman, that looks really good, thanks
00:13:28 <adu> sorry i crashed
00:13:53 <luqui> didn't miss anything
00:13:57 <adu> anyways, for more about continuous iteration, see the forum i visit: http://math.eretrandre.org/tetrationforum/index.php
00:13:58 <lambdabot> Title: Tetration Forum
00:14:27 <silver> adu: i'm looking at your site now
00:14:51 <adu> o
00:15:10 <silver> are you into Analysis?
00:15:29 <silver> Operator theory, etc...?
00:16:39 <adu> silver: i dunno, I like Haskell
00:18:00 <silver> Adu: I ask because the research on your site, and this forum you sent seem to have alot of Analysis and Operator theory involved
00:18:36 <adu> I guess
00:19:28 <silver> Looks intersting, your doing Math that goes over my head!
00:19:44 <adu> I like Analysis and Operator theory as much as anyone, but I'm really all about continuous iteration
00:19:56 <adu> I love continuous iteration
00:20:41 <silver> No worries, I'm just trying to fit things into boxes
00:20:59 <mmorrow> @yow
00:20:59 <lambdabot> Couldn't find fortune file
00:21:00 <silver> I've never seen this before
00:21:08 <mmorrow> <lambdabot> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!  Equip me with MISSILES!!
00:21:31 <silver> that was special
00:21:54 <mmorrow> that was her most special quote
00:21:59 <silver> lol
00:22:01 <mmorrow> (imho)
00:22:20 <hansfbaier> mmorrow: whats a hairpiece?
00:22:41 <silver> adu, have you ever heard of CERN?  http://www.cern.ch
00:22:47 <adu> yes
00:22:48 <lambdabot> Title: CERN - European Organization for Nuclear Research
00:22:54 <mmorrow> like an obviously fake cartoonish male hair wig
00:23:06 <silver> thank you lambdabot!
00:23:15 <mmorrow> hansbaier: like an obviously fake cartoonish male hair wig
00:23:35 <adu> silver: have they stabalized Kerr black holes yet?
00:23:39 <mmorrow> (the common name for it's slipping my mind)
00:23:50 <silver> no, the LHC isn't even up and running yet
00:23:59 <adu> :(
00:24:13 <silver> its scheduled to go online July 20-something
00:24:24 <silver> They keep pushing the date back
00:26:12 <adu> silver: thats soon
00:26:43 <silver> actually, I am checking my email, it looks like early August
00:26:52 <adu> silver: I betchya they'll prove its all electrons and gluons, after all...
00:27:32 <silver> They are still installing some materials in the detector all the way till July 27th according to the last email I recieved
00:28:17 <silver> adu: don't forget quarks, photons, W and Z bosons and mabye gravetrons ;)
00:28:36 <silver> Oh yeah, and mabye the higgs particle too
00:28:44 <adu> silver: I don't believe in quarks
00:28:47 <silver> lol
00:28:57 <silver> thten what are gluons for?
00:29:03 <silver> then*
00:29:09 <adu> to hold the leptops together
00:29:15 <adu> :P
00:29:25 <adu> leptons
00:29:25 <silver> so Protons are made out of leptons?
00:29:30 <adu> yes
00:29:35 <osfameron> Repton!
00:29:44 <silver> thats an interesting conjecture
00:30:16 <adu> its not conjecture
00:30:17 <adu> http://en.wikipedia.org/wiki/Beta_decay
00:30:32 <vixey> substructural PTSs :o
00:30:41 <silver> I thnk everything is a conjecture
00:31:06 <silver> oh, I see what you are getting at
00:31:16 <sieni> well, leptons are known not to experience the strong nuclear force
00:31:22 <sieni> problem solved
00:31:33 <adu> silver: well my conjecture is that particle decays tell us the content of the original particle
00:31:36 <sieni> protons are not formed from leptons
00:32:11 <silver> Beta and inverse beta decay is the result of the conservation of lepton number and charge
00:32:30 <silver> and probably something else that I am forgetting
00:32:36 <adu> sieni: sure they are, protons naturally decay into positrons, neutrinos and photons
00:32:42 <silver> oh yeah, mass
00:33:03 <sieni> adu: are photons made of leptons as well?
00:33:25 <adu> sieni: no, photons are still magical
00:33:26 <sieni> a photon can decay into a positron and electron
00:33:31 <silver> adu: but this does not nessasarily suggest that the contents of the original proton is leptons
00:33:56 <silver> sieni: case in point
00:34:23 <adu> sieni: I would be more inclined to say that electrons and positrons are half-photons
00:34:45 <silver> I thnk of particles as being bundles of energy, or perturbations of a field
00:35:03 <adu> silver: true
00:35:16 <silver> these energy states can change from one particle to another(s) so long as quantum numbers are preserved
00:36:08 <silver> and energy can change into mass as well, which is one reason why we know quarks exist
00:36:31 <silver> ever hear of jets in a nuclear collision
00:36:34 <silver> ?
00:36:45 <adu> hmm
00:37:00 <adu> no, but i've heard of "blue jets" in relation to ball lightning
00:37:36 <adu> is it like that?
00:38:13 <silver> if the energy density in a nuclear collision event is high enough, nucleons (protons and neutrons) can actually separate(at least current data strongly suggests this)  into quarks and gluons
00:38:39 <adu> silver: have we seen this?
00:39:15 <silver> because of the way Quantum Chromodynamics works, some quarks-anti-quark paits can fly appart
00:40:01 <adu> I don't want to learn QCD if it means I have to believe quarks
00:40:18 <silver> the enery reqired to allow this to happen is so high, it is sufficient to create new particles, thus a shower of mesons is created
00:40:35 <silver> yeah, you'd have to beleve in quarks
00:40:54 <silver> ues, we have seen strong evedence of this
00:40:58 <silver> yes*
00:41:07 <adu> but then again, mesons are harder to explain w/o quarks
00:41:08 <dolio> http://en.wikipedia.org/wiki/Quark-gluon_plasma
00:41:09 <silver> evidence*
00:41:19 <silver> thanks dolio
00:42:26 <silver> The Star project at RHIC and the Alice project (the one I am working on) at CERN are very intersted in QGP
00:43:36 <adu> silver: but what if its all leptons?
00:43:44 <silver> btw, RHIC = Relativistic Heavy Ion Collider
00:44:10 <silver> if its all leptons, then alot of physicists are going to be very supprised
00:44:24 <silver> including myslef
00:45:05 <adu> heh ok
00:45:38 <silver> adu: since you like leptons, have you looked at the neutrino project at all?
00:45:51 <adu> silver: no but they also fascinate me
00:46:08 <adu> silver: the last thing I read about neutrinos was that they oscillate
00:46:46 <silver> yeah, that was the work of the Neutrino project, they could not figure out why there were certain proportions of flavors emenating from the sun
00:46:59 <adu> where's the neutrino project?
00:47:30 <silver> we actually had the opportunity the bring the neutrino project here locally to a local nuclear power plant, but politics took hold
00:47:41 <adu> :(
00:47:42 <silver> its moving to China now
00:48:16 <silver> I think that was originally the work of the neutrino project but don't quote me
00:48:16 <adu> Chinese neutrinos... perhaps too small?
00:48:41 <silver> Diablo valley was the perfect location
00:48:45 <silver> ideal I should say
00:51:35 <adu> silver: is it possible to turn 3 Cu into Au + O?
00:51:44 <silver> In 1998, research results at the Super-Kamiokande neutrino detector determined that neutrinos do indeed flavor oscillate, and therefore have mass. The experiment is only sensitive to the difference in the squares of the masses (Mohapatra, 2005).
00:52:02 <silver> sorry, that was done at Super Kamiokande
00:52:45 <silver> adu: if I knew the answer to that, I would probably not be paying rent!
00:54:01 <adu> let philoStone [Cu, Cu, Cu] = [Au, O] in fix philoStone $ repeat Cu
00:55:20 <adu> silver: you could also live in a copper box, until the CO2 gets deadly
00:55:45 <silver> adu: if it failed, I doubt it would be stable
00:55:59 <silver> i mean, I doubt it would be stable
00:56:29 <adu> right
00:56:32 <adu> o well
00:56:42 <silver> no, I am quite confident it would not work
00:56:55 <silver> copper does not have enough neutrons to make it stable
00:57:33 <vixey> coool http://www.cs.ru.nl/~janz/yarrow/index.html
00:57:34 <lambdabot> Title: Yarrow Home Page
00:57:41 <adu> 3*65 -> 179 + 16
00:59:38 <silver> adu: true, but with too few neutrons the nucleus would fly appart due to coulomb repulsion
01:00:01 <adu> ouch
01:00:10 <silver> yeah, bad for business
01:00:43 <adu> i bet filtering it before-hand would be kinda silly
01:01:05 <silver> filtering it?
01:01:24 <adu> making sure you start with Cu-65 instead of Cu-63
01:02:08 <adu> aren't there mass spectrometers that do that?
01:02:11 <silver> Well, the next issue though is the ammount of energy required to fuse them
01:02:47 <adu> isn't that always 1.21 GW? ;)
01:02:49 <silver> by the time the electric bill comes in, you need to cash in the gold you've made and you still need to charge the rest to your credit card
01:03:07 <adu> no thats power...
01:03:12 <adu> n/m
01:03:21 <silver> thats to travel back in time in an old delorian! ;)
01:03:58 <codacola> ive got a weird question.....im reading a book on haskell, but the function definitions seem weird. it was fine until i got to "guards", are there several "kinds" of functions? eg different "kinds" have a different way to return a value, or is there an overall syntax?
01:04:21 <Vq^> codacola: it's just syntax
01:04:23 <vixey> codacola: no everything is completely uniform
01:04:31 <adu> codacola: guards are different
01:04:44 <vixey> f x | p1 = b1
01:04:48 <vixey>     | p2 = b2
01:04:58 <vixey> is just syntax which means
01:05:24 <vixey> f x = if p1 then b1 else if p2 then b2 else <other clauses>
01:05:47 <vixey> if/then/else is a function too
01:06:16 <silver> Alright everyone, thank you for your suggestions (and the physics discussion), I'm sure I'll be back soon. I'll have to log in when i ge to CERN next week and let you know whats going on!
01:06:18 <codacola> oh, so in effect when using them im calling other functions ?
01:06:24 <adu> silver: ok
01:06:25 <vixey> yes
01:06:34 <codacola> ah, that makes more sense
01:06:36 <codacola> thank you
01:06:43 <vixey> codacola: also,
01:06:45 <vixey> @src otherwise
01:06:46 <lambdabot> otherwise = True
01:07:01 <vixey> otherwise is not special either (I didn't realize that for ages..)
01:07:26 <codacola> another quesiton, is there a decent sized project i could take a look at (written in haskell), havent found many examples of it being used to write serious programs
01:07:40 <vixey> Yarrow is written in Haskell
01:07:44 <vixey> Agda 2 is as well
01:08:21 <adu> codacola: my favorites are Darcs, XMonad, and Yi
01:09:14 <chr1s> codacola: GHC is written in Haskell, and quite big.
01:09:17 <adu> codacola: but of those, only Darcs is "serious"
01:09:27 <adu> GHC is also "serious"
01:10:18 <chr1s> codacola: on hackage there are also a lot of somewhat smaller programs, see http://hackage.haskell.org
01:10:19 <lambdabot> Title: HackageDB: introduction
01:10:23 <codacola> wow, theres an hsdl
01:10:55 <adu> codacola: theres also HOpenGL and wxHaskell, and gtk2hs, and win32hs
01:10:57 <jbapple> @go pugs perl haskell
01:10:58 <lambdabot> No Result Found.
01:11:34 <jbapple> er,ok
01:11:35 <jbapple> http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fosdc2005.cgpublisher.com%2Fproposals%2F74&ei=HqxgSMyrE5masQPHrOXZAw&usg=AFQjCNH8lKX_-b1sRoNE7CrP3f_VUo7_bA&sig2=JsQW9kJaBYKcSfsgZehyDg
01:11:36 <lambdabot> Title: Introduction to Pugs: Perl 6 in Haskell, http://tinyurl.com/583t3c
01:14:11 <adu> codacola: ah, and you can't forget Parsec
01:14:30 <adu> Parsec is the most advanced parser library on the planet
01:14:42 <hpaste>  Paczesiowa pasted "OOParsec vs. OMeta" at http://hpaste.org/8496
01:17:23 <vixey> really?
01:17:36 <vixey> I didn't think it was so advanced.. just really well designed
01:19:38 <hansfbaier> adu: antlr-3 is also very nice, albeit not available for haskell.
01:19:46 <hansfbaier> @google antlr
01:19:47 <lambdabot> http://www.antlr.org/
01:19:47 <lambdabot> Title: ANTLR Parser Generator
01:20:09 <paczesiowa> why would you mess with extra tool when you can do it inside haskell?
01:20:13 <solrize> i wish there was a cross between parsec and happy
01:20:47 <solrize> so that parsec would dump out your parser as a program that it could then compile and run
01:21:09 <vixey> what would the advantage of that be?
01:21:10 <PHO_> That's sounds cool
01:21:20 <opqdonut> happy has great features nowadays, attribute grammars and whatnot
01:21:28 <solrize> it would be a lot faster than the combinator parsec which is sort of interpretive
01:22:12 <jbapple> anybody notice that stream-fusion and Stream both expose Data.Stream?
01:22:20 <jbapple> http://hackage.haskell.org/packages/archive/Stream/0.2.4/doc/html/Data-Stream.html
01:22:22 <lambdabot> http://tinyurl.com/68lca3
01:22:26 <jbapple> http://hackage.haskell.org/packages/archive/stream-fusion/0.1.1/doc/html/Data-Stream.html
01:22:28 <lambdabot> http://tinyurl.com/6qautn
01:22:39 <quicksilver> doesn't one supersede the other?
01:22:50 <jbapple> not as far as I know
01:22:50 <adu> lisp = atomic <|> parens $ lexeme lisp
01:23:07 <jbapple> quicksilver: I think they do different things
01:23:09 <quicksilver> solrize: there aren't many situations in which the speed of parsec matters.
01:23:20 <solrize> quicksilver there are some where it does ;)
01:23:21 <PHO_> I think parsec's combinators are inlined anyway
01:23:24 <quicksilver> however, I believe polyparse is generally faster.
01:23:28 <vixey> hehe adu
01:23:31 <vixey> that's nice
01:23:34 <solrize> i don't know of polyparse i should look for it
01:23:41 <quicksilver> certainly you can imagine parser combinators which precompile to some extent.
01:23:44 <quicksilver> but they can't be monads.
01:24:01 <quicksilver> one of the reasons people like arrow parsers is that they can precompute first symbol tables.
01:24:09 <quicksilver> indeed that was one of the first examples of an arrow
01:24:09 <solrize> hmm
01:25:57 <quicksilver> I wrote a parser combinator library in lua which computed first-symbol tables
01:26:08 <quicksilver> and it automatically removed left recursion from itself, too.
01:28:05 <vixey> hehe
01:28:11 <vixey> I looked at the Yarrow build script
01:28:19 <vixey> pages of
01:28:19 <vixey> ghc -c HaTuple.hs
01:28:20 <vixey> ghc -c General.hs
01:28:20 <vixey> ...
01:28:36 * vixey thinks.. maybe --make didn't exist before?
01:32:17 <vixey> @hoogle flush
01:32:18 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
01:32:18 <lambdabot> System.IO.hFlush :: Handle -> IO ()
01:35:44 <adu> night
01:38:50 <EvilTerran> ?where polyparse
01:38:51 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
01:52:36 <hackage> New hackage package: lazysmallcheck 0.3
01:53:35 <opqdonut> small as opposed to quick?-)
02:17:02 <vixey> induction-recursion is just mind boggling
02:17:47 <Yoric[DT]> What do you mean?
02:18:21 <vixey> It's just so confusing
02:20:08 <chr1s> vixey: what exactly do you mean by induction-recursion?
02:21:19 <chr1s> vixey: nevermind, I googled some papers about it.
02:21:54 <vixey> chr1s: If you find anything which makes sense please tell me :)
02:22:00 <vixey> I couldn't understand this yet
02:22:01 * Yoric[DT] is googling to check that induction-recursion is what he believes.
02:22:31 <Yoric[DT]> mmhhh....
02:22:33 <Yoric[DT]> obviously not
02:23:01 <medfly> recursion is like in coding, vixey. if that helps.
02:23:11 <dolio> Heh.
02:28:15 <dcoutts> audreyt: are you talking about bindings where you also optionally want to use a bundled C lib rather than a (missing) system one?
02:28:15 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
02:28:37 <medfly> oh, i thought i am in #math... alt+3 is math for me.
02:28:44 <medfly> vixey, recursion is like in math.
02:28:44 <dolio> Google's not too good at finding relevant results for induction-recursion.
02:28:46 <medfly> :-))
02:29:17 <dolio> It finds more thing about induction and recursion than induction-recursion.
02:29:45 <vixey> it seems like a metatheory for mutually recursion definitions of inductive types and functions operating on them
02:29:57 <vixey> recursive*
02:30:15 <vixey> thing is it makes no sense so I could be totally wrong ...
02:30:37 <dolio> Maybe I should just look up Peter Dybjer.
02:32:52 <dcoutts> @tell audreyt so cabal-install does not know that readline fails to build on windows, so it tries it. If readline could not even be configured on windows then it would be able to avoid it, but build failures are too late for install planning.
02:32:52 <lambdabot> Consider it noted.
02:34:01 <dcoutts> @tell audreyt you can use if !os(win32) { build-depends: readline } though some might consider that less than ideal.
02:34:01 <lambdabot> Consider it noted.
02:34:56 <dcoutts> @tell audreyt and yes, cabal-install does basically ignore version tags because the Ord instance for Version is messed up. We don't know which version is bigger than the other when they differ only in the tags.
02:34:57 <lambdabot> Consider it noted.
02:36:11 <jbapple> @seen mmorrow
02:36:11 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 2h 12m 32s ago.
02:36:13 <telemach> aaahhhh
02:36:21 <telemach> haskell hogs too much brain resources.
02:36:32 <telemach> *smoke*
02:36:41 <vixey> telemach: "use it or lose it" :P
02:36:47 <dcoutts> @tell audreyt as for a C binding, I'd either modify the regex-pcre package to optionally use a bundled C lib, like I do for the zlib binding. Another approach is to make a package that consists only of the C code (regex-pcre-cbits or something) and have regex-pcre optionally depend on that.
02:36:47 <lambdabot> Consider it noted.
02:36:51 <telemach> ;)
03:09:55 <Yoric[DT]> mmmmffff
03:10:06 <Yoric[DT]> Proving monadic laws in an impure language doesn't look easy.
03:26:49 <byorgey> http://dpillay.blogspot.com/2008/06/haskell-type-inference.html
03:26:50 <lambdabot> Title: Prometheus: Haskell & Type Inference
03:27:16 <byorgey> looks like a newbie who needs inviting to #haskell =)
03:28:19 <Saizan_> yeah
03:28:43 <mjrosenb> indeed
03:29:04 <Saizan_> more so since it mentions strictness while evaluation has no place there
03:29:23 <Saizan_> "he"
03:29:28 <byorgey> Saizan_: I'm pretty sure by 'strictness' they just meant 'strict type system'
03:29:58 <Saizan_> ah, makes sense
03:30:05 <litb> hello all :p
03:30:27 <byorgey> hi litb
03:56:35 <mjrosenb> @hoogle (a
03:56:36 <lambdabot> Prelude.abs :: Num a => a -> a
03:56:36 <lambdabot> Prelude.asin :: Floating a => a -> a
03:56:36 <lambdabot> Prelude.acos :: Floating a => a -> a
03:56:39 <mjrosenb> gah
03:57:02 <mjrosenb> hoogle (a -> Bool) -> [a] -> [[a]]
03:57:21 <mjrosenb> and again
03:57:30 <mjrosenb> @hoogle (a -> Bool) -> [a] -> [[a]]
03:57:30 <lambdabot> Distribution.Simple.Utils.breaks :: (a -> Bool) -> [a] -> [[a]]
03:57:55 <idnar> @type break
03:57:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:57:58 <idnar> oh right
03:58:56 <mjrosenb> why is that non in Data.List?
03:59:15 <mjrosenb> not
03:59:17 <mjrosenb> oh god
03:59:20 <mjrosenb> i need sleep
03:59:50 <quicksilver> no good reason I guess.
04:00:57 <vixey> How come I never heard of Distribution.Simple.Utils before?
04:01:15 <idnar> @type \x y -> unfoldr (\(l, r) -> if (null l) then Nothing else Just (l, r)) y x
04:01:17 <lambdabot>     Occurs check: cannot construct the infinite type: t = ([a], t)
04:01:17 <lambdabot>       Expected type: ([a], t)
04:01:17 <lambdabot>       Inferred type: t
04:01:32 <idnar> er, oops
04:02:09 <idnar> @type \f a -> unfoldr (\(l, r) -> if (null l) then Nothing else Just (l, break f r)) a
04:02:11 <lambdabot> forall a. (a -> Bool) -> ([a], [a]) -> [[a]]
04:02:37 <idnar> @type \f a -> unfoldr (\(l, r) -> if (null l) then Nothing else Just (l, break f r)) (break f a)
04:02:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
04:03:16 <idnar> @help check
04:03:17 <lambdabot> check <expr>
04:03:17 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
04:03:39 <idnar> @check let breaks' f a = unfoldr (\(l, r) -> if (null l) then Nothing else Just (l, break f r)) (break f a) in \s -> breaks' s == Distribution.Simple.Utils.breaks s
04:03:40 <lambdabot>   Not in scope: `Distribution.Simple.Utils.breaks'
04:03:53 <idnar> doh
04:04:42 <quicksilver> vixey: it's part of cabal
04:04:44 <quicksilver> AFAIK.
04:06:03 <mjrosenb> idnar: what does @check do?
04:06:15 <idnar> it tests a function under quickcheck
04:06:23 <mjrosenb> i see
04:06:23 <idnar> @check \s -> s == s
04:06:24 <lambdabot>  OK, passed 500 tests.
04:06:32 <idnar> are you familiar with quickcheck?
04:07:15 <mjrosenb> i've never used it
04:07:23 <mjrosenb> but i've heard plenty about it
04:07:32 <idnar> ok
04:24:35 <vixey> @check 0/0 == 0/0
04:24:37 <lambdabot>  Falsifiable, after 0 tests:
04:24:47 <vixey> @check \x -> x == x
04:24:48 <lambdabot>  OK, passed 500 tests.
04:25:13 <vixey> ok randomized testing is a really bad idea
04:25:36 <ToRA> @scheck \x -> x == x
04:25:38 <lambdabot>   Completed 1 test(s) without failure.
04:26:04 <dolio> () == () seems like it makes sense to me.
04:26:37 <vixey> @check \p q -> p*q /= 621
04:26:38 <lambdabot>  OK, passed 500 tests.
04:26:42 <vixey> > 23*27
04:26:43 <lambdabot>  621
04:26:47 <ToRA> anybody here involved with lazysmallcheck ?
04:27:03 * vixey is anti-testing :p
04:28:03 <SamB> @check \p q -> p*q /= 1
04:28:04 <lambdabot>  Falsifiable, after 6 tests: 1, 1
04:28:13 <SamB> @check \p q -> p*q /= 3
04:28:14 <Eelis> when i hexdump the output of     ghc -e True   , i see that it outputs "[?1034h" after "True\n". this is interfering with my subsequent processing of the output. what's the purpose of the extra output, and how can i disable it?  (see http://rafb.net/p/SOJvrE64.html )
04:28:14 <lambdabot>  Falsifiable, after 63 tests: 1, 3
04:28:16 <lambdabot> Title: Nopaste - No description
04:28:23 <SamB> @check \p q -> p*q /= 7
04:28:24 <lambdabot>  OK, passed 500 tests.
04:28:42 <mjk> i have defined a data :data BB = B{name::String, age::Int} , want to compare the instance of BB, like B{name} == B{name} igore B{age}
04:28:47 <mjk> how to do?
04:28:55 <Botje> Eelis: doesn't do that over here
04:29:04 <Botje> Eelis: sure that's not your shell? :)
04:29:17 <Eelis> Botje: it's not my shell, because  echo -n|hexdump  shows nothing
04:29:32 <vixey> strang
04:29:47 <SamB> Eelis: man console_codes
04:30:10 <solrize> " The use of Haskell was a success for this project. A prototype was correctly
04:30:10 <solrize> working within a remarkably short time frame (3 man-weeks), which encouraged
04:30:10 <solrize> us to continue using Haskell. However, we encountered problems with unexpected
04:30:10 <solrize> laziness frequently filling up the heap space. A further 2 months were needed to
04:30:10 <solrize> obtain reasonable resource usage."
04:30:52 <smtms> solrize, where's that?
04:30:52 <Eelis> SamB: i'm frankly not that interested in what the exact code means. i just want it gone :)
04:31:12 <solrize> article about a biology program done in haskell
04:31:22 <Eelis> strace ghc -e True 2>&1 | grep write   <- shows: write(1, "\33[?1034h", 8)
04:31:27 <SamB> Eelis: you asked what it's for!
04:31:30 <solrize> http://users.aber.ac.uk/afc/papers/ClareKingPADL.pdf
04:31:36 <SamB> I expect console_codes will tell you what it does
04:31:46 <SamB> which goes a long way towards figuring out what it's for, no?
04:32:33 <Eelis> SamB: fine. then consider that part of my question answered. now remains the part of how to get rid of the extra output :)
04:32:58 <solrize> "    The main disadvantage that was faced was dealing with unwanted laziness...  At every step of the coding process it was found that code was easy
04:32:58 <solrize> to get right, but then difficult to get working in practice without running out of
04:32:58 <solrize> memory.
04:35:35 <solrize> http://users.aber.ac.uk/afc/stricthaskell.html  also of interest
04:35:35 <lambdabot> Title: Making Haskell programs faster and smaller
04:37:30 <quicksilver> Igloo , dcoutts : haskell-cafe borken?
04:37:40 <quicksilver> no new messages in 6 hours? I think this is unprecedented ;)
04:37:44 <dcoutts_> quicksilver: mm
04:37:44 <lambdabot> dcoutts_: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:37:54 <dolio> Everyone's on Haskell Hall now.
04:38:03 <dcoutts_> hah
04:38:13 <Saizan_> solrize: do they say which version of ghc were they using?
04:38:36 <Igloo> It's been slow for a few days. It doesn't look particularly broken at first glance, though
04:38:40 <solrize> i didn't notice but i think that paper is a few years old
04:40:52 <BeelsebobWork> WRYYYYYYYYYYY
04:41:06 <BeelsebobWork> why does everyone think that you have to make things strict to make Haskell fast
04:43:33 <SamB> BeelsebobWork: well, it's not so much Haskell as certain algorithms
04:43:50 <solrize> well when i hear stuff like that from people like vesa karvonen enough times, i start to think it means something
04:44:15 <SamB> ... many of which are inherently strict, and the annotations just save space and/or avoid crashes
04:44:30 <SamB> oh, and time
04:44:48 <SamB> possibly improve locality ...
04:45:54 <solrize> "In a data mining environment, where all data needs to be read and counted, and all calculations will be used, laziness provides few advantages, and usually takes up huge amounts of heap space while delaying all computation until the last minute. "
04:46:32 <SamB> solrize: now that sounds wrong ;-)
04:46:43 <SamB> because I'm sure there is some use for laziness
04:47:27 <solrize> vesa's usual riff says yes there are uses for laziness but rarely for multiple levels of nested thunks, so it makes more sense to have strict default with laziness annotations, than the other way around
04:47:40 <SamB> because, you see, codata -- aka control -- structures use laziness inherently ...
04:48:13 <SamB> much, much harder to have "laziness annotations"
04:48:47 <solrize> in scheme it's done with delay/force which simply wraps lambda around the expression
04:48:51 <joey_> mjk: Make your own instance of Eq that just compares them on the name field of each record.
04:48:56 <SamB> I mean, once a value is demanded, there isn't much you can do about it
04:48:58 <idnar> laziness isn't just about using values vs. not using values, it's also about *when* the values get used
04:49:02 <vixey> it wraps a tagged closure
04:49:07 <vixey> it's not a lambda
04:49:11 <SamB> solrize: isn't that provably less flexible than real laziness?
04:49:17 <vixey> (which is stupid and irritating since scheme has side effects..)
04:49:33 <joey_> mjk: instance Eq BB where; a == b = name a == name b -- Or something to that effect
04:49:47 <vixey> SamB: seen the Oz approach?
04:49:52 <solrize> samb i dunno, it could be that the cases where it matters are very rare
04:50:05 <EvilTerran> ?hoogle equating
04:50:06 <lambdabot> No matches found
04:50:09 <SamB> you really only understand laziness when you try to use codata in a total language ;-)
04:50:28 <EvilTerran> mmm, total languages
04:50:34 <pejo> SamB, so laziness is too complex for mere mortals?
04:50:43 <SamB> solrize: in any case, it provably gets less library support
04:50:53 * osfameron suggests TaPL to the Liverpool.gov.uk libraries service
04:51:20 <mjk> joey_: still can't implement it
04:51:29 <pejo> osfameron, suggest attapl while you're at it. :-)
04:51:33 <joey_> mjk: What's the problem?
04:51:46 <SamB> but you can download attapl in ps or pdf
04:51:48 <SamB> I forget which
04:51:55 <osfameron> pejo: well I don't want to overdo it :-)
04:51:58 <joey_> mjk: Try using http://hpaste.org/
04:52:11 <mjk> sorry, it is ok
04:52:12 <osfameron> actually I just want to read TaPL myself, but I just ordered a couple of programming books, should wait a bit
04:52:14 <dolio> I'm not sure that was totally legitimate.
04:52:17 <mjk> joey_: thank you
04:52:27 <SamB> dolio: probably not ;-)
04:53:07 <dblhelix> dolio: were you serious about haskell hall?
04:53:17 <dolio> Hah, no.
04:53:22 <EvilTerran> SamB, i *believe* i remember hearing that strict languages are provably less expressive, although i'm not sure how that works given that you can do laziness explicitly
04:53:37 <SamB> what would Haskell Hall be?
04:53:50 <EvilTerran> someone gave an algorithm that can't be expressed in a strict language or something
04:53:56 <SamB> EvilTerran: well, this was strict pure languages
04:54:07 <EvilTerran> ah, yes, that's how it works. now it makes more sense.
04:54:29 <SamB> EvilTerran: now, no practical langauge is totally strict and pure...
04:54:31 <EvilTerran> explicit laziness without mutation will result in repeated evaluation of delayed expressions
04:54:38 <SamB> but that's why.
04:54:45 <EvilTerran> QED :)
04:55:28 <pejo> EvilTerran, http://portal.acm.org/citation.cfm?id=969871
04:55:29 <lambdabot> Title: More haste, less speed: lazy versus eager evaluation
04:56:13 <pejo> SamB, depending on your definition of "practical" - Timber might fit that criteria.
04:56:26 <SamB> I believe there are two classes of language-supported explicit laziness, one of which is less flexible in an O(n) sense than laziness-by-default, and the other of which is only less flexible in a "why don't the libraries support this bette" sense
04:56:35 <SamB> pejo: what is timber?
04:56:50 <pejo> SamB, basically a strict O'Haskell
04:56:59 <dblhelix> SamB: haskell hall is an alternative to prison: it's a place people who misbehave are sent to
04:57:08 <SamB> pejo: how does it do IO?
04:57:14 <SamB> dblhelix: oh ;-)
04:57:15 <pejo> SamB, monads
04:57:34 <SamB> pejo: so how does it use the input to effect the output?
04:58:11 <dblhelix> SamB: http://www.nabble.com/INVITATION-to18058548.html
04:58:12 <lambdabot> Title: Nabble - INVITATION
04:58:49 <pejo> SamB, huh?
04:59:13 <SamB> doesn't IO make essential use of laziness?
05:02:00 <opqdonut> not really
05:02:33 <pejo> SamB, could you give an example of when? (I don't really understand laziness).
05:03:18 <SamB> Well... the IO computations are built up lazily
05:03:19 <vixey> I don't think IO cares about lazyness
05:03:27 <SamB> hmm.
05:03:45 <SamB> but I suppose that the lambdas would make that happen anyway
05:12:51 <vixey> SamB: out of curiosity what have you been doing with codata?
05:52:05 <BeelsebobWork> @hoogle (a -> b) -> (a -> Maybe b)
05:52:06 <lambdabot> No matches, try a more general search
05:52:28 <BeelsebobWork> @hoogle Monad m => (a -> b) -> (a -> m b)
05:52:29 <lambdabot> No matches, try a more general search
05:52:58 <malcolmw> BeelsebobWork: I think you are looking for (Just .)
05:53:11 <BeelsebobWork> yep, I just realised that about 5 seconds before you said it
05:53:12 <BeelsebobWork> >.<
05:54:44 <BeelsebobWork> bah, Data.Map's argument oredring is annoyingly inconsistant
05:55:05 <BeelsebobWork> insert puts key, then value while update puts value, then key
05:56:26 <johnnowak> it's designed to keep you on your toes
05:59:16 <BeelsebobWork> heh
05:59:49 <BeelsebobWork> it gets really annoying when you are sat about doing (uncurry M.insert) (something that returns a tuple)
05:59:54 <BeelsebobWork> and then you try and do the same with an update
06:02:36 <ziman> @djinn (a -> b) -> (a -> Maybe b)
06:02:36 <lambdabot> f a b = Just (a b)
06:03:14 <ziman> @pl f a b = Just (a b)
06:03:14 <lambdabot> f = (Just .)
06:03:18 <ziman> ;)
06:03:27 <dmwit> ?. pl djinn (a -> b) -> a -> Maybe b
06:03:27 <lambdabot> f = (Just .)
06:13:53 <malcolmw> the older FiniteMap API was much more consistent and easy to use
06:17:48 <gwern> the translation between the two is pretty mechanical. you've seen the FiniteMap.hs compat module implemented in terms of Data.Map? it's mostly aliases with a few flips thrown in
06:18:19 <audreyt> the only problem is that Data.HashTable is still using the old-style unflipped API...
06:18:19 <lambdabot> audreyt: You have 4 new messages. '/msg lambdabot @messages' to read them.
06:19:19 <gwern> incidentally, audreyt, I have a compile problem with the hackage pugs...
06:19:45 <hpaste>  gwern pasted "pugs compile error" at http://hpaste.org/8498
06:19:59 <ivanm> who writes the geekrant.wordpress.com blog?
06:28:59 <therp> is there anything implementing AVL trees in the standard libs?
06:29:24 <therp> I just want to build a structure that has quick membership checking
06:30:13 <dolio> @hackage AvlTree
06:30:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AvlTree
06:30:37 <therp> time to try cabal-install
06:30:51 <therp> oh it's packaged in gentoo-haskell already.. fine
06:31:06 <dcoutts_> therp: it's still a good time to try cabal-install though :-)
06:31:53 <dolio> dcoutts_: Is there a cabal-install that works with ghc 6.9/cabal 1.5.1?
06:32:15 <dcoutts_> dolio: with ghc-6.9, yes, with Cabal 1.5.x, no.
06:32:24 <dcoutts_> Cabal-1.4 will work with ghc-6.9
06:32:35 <dolio> Ah.
06:32:46 <dcoutts_> dolio: or if it doesn't then tell me and I'll fix it :-)
06:33:19 <dolio> I'll try now. I didn't consider installing an older cabal. :)
06:37:48 <dolio> The only complaint is that -fffi is old and busted.
06:38:33 <rabbit64> Don't you know about some c( parser based on parsec?
06:39:12 <rabbit64> (parser that parses c  or maybe even c++ files)
06:39:51 <quicksilver> C parser, yes.
06:39:54 <quicksilver> parsec based, no.
06:40:21 <ddarius> You're not going to find a C++ parser just lying around.
06:40:45 <rabbit64> pitty
06:41:07 <quicksilver> why do you need it to be based on parsec?
06:41:31 <rabbit64> I like parsec ;)
06:42:01 <rabbit64> (but if there is none...I use the other)
06:43:03 <rabbit64> quicksilver, ok so what parser do you know?
06:51:26 <cpfr> howdy
06:51:39 <cpfr> is there anything like ocamlbrowser for haskell
06:51:43 <cpfr> i know of hoogle
06:51:52 <cpfr> but that requires being online
06:51:52 <opqdonut> what does ocamlbrowser do?
06:52:13 <cpfr> ocamlbrowser tells me navigate all the modules and functions in ocaml
06:52:17 <cpfr> see their types
06:52:27 <cpfr> and sometimes even how they are implemented
06:52:28 <ivanm> is hoogle installable on a home machine?
06:52:35 <Botje> ivanm: yup
06:52:38 <Botje> i'm using it daily
06:52:41 <ivanm> *nod*
06:52:46 <Botje> ooh ooh!
06:52:46 <ivanm> cpfr: there's always lambdabot ...
06:52:53 <quicksilver> rabbit64: language.c
06:53:00 <Botje> can cabal-install generate hoogle docs when it sees hoogle is installed?
06:53:06 <Botje> that would be uber-win
06:53:09 <quicksilver> rabbit64: http://www.sivity.net/projects/language.c/wiki/
06:53:11 <lambdabot> Title: language.c - Trac
06:53:19 <dcoutts_> Botje: that's probably the most commonly requested feature at the moment
06:53:33 <dcoutts_> Botje: if you want to implement it then talk to me
06:53:42 <rabbit64> quicksilver, thanks
06:54:36 <ivanm> Botje: or if _you_ don't want to implement it, bribe dcoutts_ :p
06:54:51 <Botje> .. have a lambdacookie? :)
06:54:59 <ivanm> heh
06:55:04 <Botje> dcoutts_: how much work do you estimate it to be?
06:55:21 <pejo> Heh, isn't he fairly busy writing up his dissertation?
06:55:21 <cpfr> Botje, wait it is?
06:55:21 <Botje> if it's just a couple of days inspired hacking, no problem
06:55:22 <cpfr> how
06:55:34 <dcoutts_> Botje: yeah, not that hard
06:55:37 <Botje> cpfr: just download and compile
06:55:54 <dcoutts_> Botje: http://hackage.haskell.org/trac/hackage/ticket/206
06:55:55 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
06:55:55 <cpfr> ok
06:55:58 <Botje> http://www.haskell.org/haskellwiki/Hoogle
06:55:59 <lambdabot> Title: Hoogle - HaskellWiki
06:56:01 <ivanm> pejo: shhh!!!!
06:56:09 <Botje> check out the "using hoogle from ghci" bit
06:56:24 <ivanm> what's more important, haddock support for cabal-install, or Yet Another Haskell Thesis? :p
06:56:32 <dcoutts_> hah
06:57:52 <pejo> ivanm, hm, not sure.
06:58:08 <pejo> dcoutts, what's it about? (Have I asked you that already? I remember asking swiert)
06:58:35 <dcoutts_> pejo: stream fusion
06:58:47 <dcoutts_> and bytestrings and all that fun stuff
06:59:18 <ivanm> what? I thought that was dons' exclusive domain! :p
06:59:37 <dcoutts_> ivanm: we wrote those papers together
06:59:40 <ivanm> with the rest of us acting as supplicants around the altar of haskell speed-ness!
06:59:43 <ivanm> dcoutts_: yeah, I know
06:59:51 <ivanm> that's when you came down under, isn't it?
07:00:20 <pejo> dcoutts, any additional research from the published papers?
07:00:40 <dcoutts_> ivanm: partly, yes
07:00:57 <dcoutts_> pejo: the thesis will have more detail mainly
07:06:13 <mapreduce> :t mapAccumL
07:06:15 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:07:19 <mapreduce> > mapAccumL (\acc x -> (acc, acc+x)) 1 [1..10]
07:07:34 <lambdabot>  thread killed
07:15:05 <dcoutts_> @seen pgavin
07:15:05 <lambdabot> I saw pgavin leaving #haskell 8h 25m 23s ago, and .
07:15:17 <dcoutts_> @tell pgavin I get the same message about needing to be admin
07:15:18 <lambdabot> Consider it noted.
07:19:27 <pastorn> @src sqrt
07:19:27 <lambdabot> Source not found. You untyped fool!
07:19:47 <dolio> @src Float sqrt
07:19:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:34:48 <monochrom> shopping is too much walking. let's do haskell.
07:36:41 <asmanian> haskell is to much thinking, let's go shopping ;)
07:36:48 <asmanian> +o
07:37:08 <zeno_> are 2-3 nested wheres bad style?
07:37:14 <monochrom> let the symbols do the work
07:37:25 <nornagon> asmanian: Exception: <<loop>>
07:37:27 <monochrom> No.
07:38:42 <MyCatVerbs> zeno_: you very often don't need to nest at all, most nested wheres can be flattened.
07:39:40 <MyCatVerbs> zeno_: if you actually have a function that involved that it needs so many helpers, perhaps it'll actually turn out that some of those helpers are general enough that they really ought to be at top-level so you can use them elsewhere too?
07:40:12 <nornagon> ♫ I've got a cat he's got some verbs, uh-huh ♪
07:40:38 <MyCatVerbs> nornagon: I'm flattered, I think.
07:41:24 <nornagon> MyCatVerbs: http://www.rathergood.com/knees/
07:41:24 <lambdabot> Title: My Cat's Got Knees, rathergood.com by Jacqui and Joel Veitch
07:43:53 <zeno_> MyCatVerbs: its not really compilicated pretty much just that the funciton in the second where uses an argument thats not passed to the first where
07:43:59 <MyCatVerbs> nornagon: ZOMG IT'S SO BEAUTIFUL
07:45:28 <gwern> that site is the cat's pygamaes
07:45:31 <gwern> the bee's knees
07:46:10 <gwern> perhaps it is even the cat's whiskers? but that goes beyond my competency to assess
07:46:13 <Athas> So, I'll soon be done with the "Programming in Haskell" textbook. Is the Haskell Report a decent way to go from there?
07:46:15 <zeno_> nornagon: my wifes new homepage, speakers on 85% :)
07:46:30 <nornagon> zeno_: ;D
07:46:36 * gwern is assured that it is not the eel's hip, though
07:46:37 <quicksilver> Athas: I don't imagine you'll find the haskell report an interesting read, it's mostly a reference.
07:47:15 <Athas> It'll be an interesting read if I learn anything from it.
07:47:22 <psyklops> (I'm reading tutorials) Is it legal to say    func :: Num -> Num ?
07:47:31 <mrd> no
07:47:34 <MyCatVerbs> zeno_: oh sure, sounds great.
07:47:42 <mrd> func :: Num a => a -> a
07:47:51 <gwern> psyklops: try 'func :: Num a => a -> a
07:48:27 <gwern> mrd: oh sure! anyone could dash out answers if they're sloppy and avoid prefatory remarks like verbs and recipients!
07:48:37 * gwern hews to a higher standard of IRCery, sirrah!
07:48:43 <psyklops> The question came to mind when I read this:
07:48:44 <psyklops> fib :: (Num a, Num b) => a -> b
07:49:00 <psyklops> Now I see, classes are not types
07:49:01 <mrd> fooey
07:49:02 <psyklops> thanks
07:49:20 <mrd> psyklops: indeed, they are classes of types
07:50:08 <gwern> Athas: anything which is an easy read? then you'll love _A Million Random Digits with 100,000 Normal Deviates_, indeed, I can guarantee that from an information theoretic viewpoint, you'll probably learn far more than any other book you are lief to read
07:50:14 <gwern> *informative read
07:50:23 <ToRA> @type \(_::Num) -> ()
07:50:25 <lambdabot>     Class `Num' used as a type
07:50:25 <lambdabot>     In the type `Num'
07:50:25 <lambdabot>     In a pattern type signature:
07:50:40 <zeno_> psyklops: classes are like interfaces, if you're from java
07:52:09 <mrd> A Million Random Digits ... is that a memoir?
07:52:56 <gwern> mrd: http://www.amazon.com/Million-Random-Digits-Normal-Deviates/dp/0833030477
07:52:58 <lambdabot> http://tinyurl.com/yakqmh
07:55:53 <mrd> so it is
07:56:22 <dcoutts_> @seen TomDB
07:56:23 <lambdabot> I haven't seen TomDB.
07:58:41 <gwern> preflex: seen TomDB
07:58:42 <preflex>  Sorry, I haven't seen TomDB
08:02:00 <loupgaroublond> how can i get the ID for a package by name using the CLI tool ghc-pkg?
08:02:25 <quicksilver> I ddin't know packages had ids.
08:02:48 <loupgaroublond> well, using the command 'hide' or 'unregister' wants a pkg-id
08:02:56 <loupgaroublond> and using just the name, or name with version won't work
08:02:57 <dcoutts_> $ ghc-pkg list Cabal --simple-output
08:02:57 <dcoutts_> Cabal-1.2.3.0 Cabal-1.3.11 Cabal-1.3.12 Cabal-1.4.0.0 Cabal-1.4.0.1
08:03:01 <dcoutts_> loupgaroublond: ^^
08:03:24 <dcoutts_> gives you the ids of all registered packages with that name
08:04:21 <dcoutts_> loupgaroublond: so yes, the id is the name-version
08:04:44 <hpaste>  loupgaroublond pasted "ghc-pkg won't work" at http://hpaste.org/8499
08:04:55 <loupgaroublond> dcoutts_, check that paste?
08:05:07 <byorgey> dcoutts_: you mean TomMD?
08:05:19 <dcoutts_> byorgey: erm, maybe I do
08:05:46 <dcoutts_> loupgaroublond: you'll notice that the package is in the per-user db. So you have to delete it from the --user db. The default is the --global db.
08:06:12 <dcoutts_> loupgaroublond: ghc-pkg hide --user X11-1.4.1
08:06:38 <loupgaroublond> ah...
08:06:44 <dcoutts_> loupgaroublond: if you do cabal list without the --simple-output then it shows you which section it's in, global or user
08:06:51 <loupgaroublond> thanks :), i figured it could figure that out by itself
08:06:52 <dcoutts_> oops, I mean ghc-pkg list
08:06:53 <loupgaroublond> i guess not
08:07:18 <dcoutts_> loupgaroublond: well you can have the same package registered in both so it'd be ambiguous in general
08:08:26 <loupgaroublond> hmm... sometimes i get strange errors when i do that, but that has something to do with the global install being managed by RPM
08:10:35 <russell^^> how easy is it to integrate java and haskell?
08:10:47 <quicksilver> there have been 3 or 4 projects to do so
08:10:52 <quicksilver> as far as I know they are all dormant and bitrotted
08:10:57 <russell^^> oh
08:11:09 <MyCatVerbs> russell^^: there's basically nothing in practice.
08:11:14 <gwern> so basically, don't bet on it.
08:11:22 <MyCatVerbs> If you want to call Java from Haskell or vice-versa, you have two possible paths.
08:11:30 <russell^^> i want to learn functional programming but it's difficult using java and functionaljava.org
08:11:38 <gwern> good ol' stdin stdout :)
08:11:42 <Botje> russell^^: grab haskell and dive in!
08:12:04 <MyCatVerbs> russell^^: if you're wedded to the JVM, you might want to try one of the ML-a-likes on the JVM.
08:12:13 <russell^^> java 7 is getting functional stuff in it but in the meantime i think i'll learn haskell
08:12:18 <MyCatVerbs> russell^^: but just standalone GHC is pretty decent anyway.
08:12:40 <russell^^> are there quite a lot of libraries? xml parsing, gui etc.?
08:12:43 <Botje> wasn't there a project to compile haskell to the JVM?
08:12:45 <monochrom> You should learn haskell anyway (or sml or ocaml or scheme or ...)
08:12:45 <russell^^> (for haskell that is)
08:12:46 <mc__> russell^^: it is definetely worth it, i just started 3 days ago haskell is an amazing language
08:12:54 <quicksilver> Botje: yes, or perhams more than one.
08:13:00 <MyCatVerbs> Anyway. Calling Haskell from Java, you'd have to expose a C API from Haskell using the FFI, then use JNI to call it from Java. I'm not sure if the other way around is even *possible*.
08:13:09 <mc__> I'm jjust a little scared by the lack of OOP
08:13:11 <dolio> Heh, functional stuff.
08:13:44 <MyCatVerbs> Alternatively and more sanely, run one Java process and one Haskell process, keep a socket between them, serialize communication over it.
08:13:49 <EvilTerran> mc__, you'll stop missing OOP once you get a good grasp of haskell's type system, i suspect ;)
08:13:54 <zeno_> is the standard way of turning a string to int read x::Int?
08:13:58 <ziman> russell^^, haskell's central package repository has many libraries: http://hackage.haskell.org/packages/archive/pkg-list.html
08:14:05 <monochrom> Some people learn yoga in english. Yes you can do that up to a certain basic extent. To go into it for real, you must eventually learn sanskrit itself.
08:14:07 * EvilTerran now deeply distrustful of OOP
08:14:12 <Botje> zeno_: yup
08:14:18 <EvilTerran> zeno_, well, that's one way
08:14:21 <EvilTerran> ?hoogle readInt
08:14:21 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
08:14:21 <lambdabot> Data.ByteString.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
08:14:21 <lambdabot> Data.ByteString.Lazy.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
08:14:23 <Botje> zeno_: although you can drop the type signature more often than not
08:14:32 <mc__> EvilTerran: probably
08:14:33 <EvilTerran> ?hoogle reads
08:14:33 <lambdabot> Prelude.reads :: Read a => ReadS a
08:14:33 <lambdabot> Text.Read.reads :: Read a => ReadS a
08:14:33 <lambdabot> Prelude.ReadS :: type ReadS a
08:14:39 <EvilTerran> ?src ReadS
08:14:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:14:51 <zeno_> > read "12" + 5
08:14:51 <russell^^> also, why do you choose haskell when other languages have things like lambda expressions and other functional functionality (:D) so on built-in
08:14:52 <lambdabot>  17
08:15:02 <EvilTerran> ?type reads (undefined :: String)
08:15:02 <mc__> EvilTerran: I'm not seeing the big picture yet but I love functional programming
08:15:03 <lambdabot> forall a. (Read a) => [(a, String)]
08:15:11 <Botje> EvilTerran: urgh. I have a course (software architectures) which turned out to be nothing but design patterhs
08:15:19 <EvilTerran> > read "error" :: Int
08:15:21 <lambdabot>  Exception: Prelude.read: no parse
08:15:22 <Botje> i'm really hating the prospect of that exam
08:15:24 <MyCatVerbs> russell^^: the purity, strong type system, generally nice syntax. Laziness is also a big win in terms of expressive power.
08:15:32 <EvilTerran> > reads "error" :: [(Int,String)]
08:15:33 <lambdabot>  []
08:15:38 <monochrom> "other functional functionality (:D) so on built-in" is false.
08:15:56 <russell^^> oh
08:16:03 <EvilTerran> zeno_, the problem with read is that it throws an error if there's no parse
08:16:21 <EvilTerran> zeno_, however, reads returns a list of (result, remainder of string) pairs for each possible parse
08:16:28 <EvilTerran> (usually there's either 0 or 1 parses)
08:17:09 <zeno_> > reads "12"
08:17:11 <lambdabot>  []
08:17:24 <MyCatVerbs> russell^^: purity means that you get all sorts of invariants pretty much for free, when you're writing code. The strong type system is... well, it's actually powerful enough to be useful, rather than just annoying like Java's or C's.
08:17:28 <EvilTerran> zeno_, so, if the string may not be valid, it's probably better to use reads and handle the error more cleanly than an exception
08:17:42 <EvilTerran> > (reads :: ReadS Int) "12"
08:17:43 <lambdabot>  [(12,"")]
08:18:05 <EvilTerran> zeno_, the trap you fell into just there is that types tend to default to ()
08:18:08 <EvilTerran> > reads "()"
08:18:09 <lambdabot>  [((),"")]
08:18:20 <EvilTerran> > reads "  (   )   blah"
08:18:21 <lambdabot>  [((),"   blah")]
08:18:47 <zeno_> EvilTerran: ah ok thanks, just seems really verbose
08:18:57 <russell^^> ok, i'll download the compiler tonight and have a play about, cheers! :)
08:19:15 <EvilTerran> zeno_, in most contexts, though, it should be able to deduce that the type must be numeric (ie implementing Num) - in those cases, it'll default to Int
08:19:43 <mauke> Integer
08:19:44 <EvilTerran> there *could* be a Num instance for (), but it wouldn't be very interesting, so there isn't
08:19:48 <MyCatVerbs> > (reads :: ReadS Float) "12.0e3"
08:19:48 <EvilTerran> my bad, Integer
08:19:49 <lambdabot>  [(12000.0,"")]
08:19:50 <monochrom> russell^^: use Real World Haskell for getting started on the compiler+interpreter
08:20:06 <monochrom> @where rwh
08:20:06 <lambdabot> is http://www.realworldhaskell.org/blog/
08:20:26 <monochrom> what lambdabot said
08:22:19 <zeno_> monochrom: oh wow that looks like a great resourse
08:22:23 <zeno_> thanks a ton
08:22:45 <monochrom> The authors are also on this channel.
08:23:07 <zeno_> well thanks a bigger ton to them then :)
08:23:10 <MyCatVerbs> They are? Crap! *hides*
08:23:58 <joey_> Oh, there's more chapters since the last time I checked
08:25:38 * CosmicRay waves at MyCatVerbs
08:28:19 <earthy> there. if this flies I'll get to program Haskell for money again...
08:28:45 <Botje> earhtly :: Money -> IO Haskell
08:28:50 <Botje> bah
08:28:54 * earthy laughs
08:28:57 <Botje> damn keyboard keeps sabotaging me
08:28:58 <earthy> ya, that. :)
08:29:14 <mar77a> isn't it :: Haskell -> Money
08:29:30 <Botje> no, that's the type of Galois :)
08:29:34 <Botje> actually, no
08:29:40 <Botje> they're also Money -> IO Haskell
08:29:42 <earthy> nope. I get money, I make Haskell. :)
08:32:20 <monochrom> Money -> IO (Haskell, Money)  =  StateT Money IO Haskell
08:32:56 <monochrom> It is the general type.
08:33:23 <joey_> Hmm, why is Ix needed, wouldn't Enum suffice?
08:34:15 <monochrom> Because Enum succs.  (pun :) )
08:35:23 <quicksilver> joey_: they're different.
08:35:28 <quicksilver> joey_: no enum instances for tuples
08:36:09 <quicksilver> and "range" isn't deducible in an easy way from the enum methods on things like tuples
08:36:18 <joey_> Oh, you can index with a tuple over something like a matrix?
08:36:20 <monochrom> Yeah
08:36:39 <joey_> Or 2D array.
08:36:40 <monochrom> great for 3-dimensional arrays
08:43:41 <zeno__> would it be much (or any) more efficient to have a length 361 list rather than a 19x19 list?  Worth going to an array at that size? (will get indexed sorta often)
08:44:31 <esteth> Hey there :) I'm wondering if there are libraries for haskell for interacting with Windows. For instance, a WMI or COM library? I've noticed a general lack of windows anything for haskell though, so I'm not sure if a wmi/COM library will exist
08:45:53 <monochrom> like http://www.haskell.org/ghc/docs/latest/html/libraries/Win32/System-Win32.html  ?
08:45:54 <lambdabot> http://tinyurl.com/6xcqoo
08:47:08 <Botje> zeno__: at the very least, a COM bridge exists
08:47:13 <Botje> i read a paper about it
08:47:22 <Botje> don't know how maintained it is
08:48:05 <zeno__> esteth: 4u :) ^
08:48:40 <Botje> doh
08:49:41 <quicksilver> Botje: "not" maintained I imagine.
08:49:58 <Botje> you never know
08:49:59 <Botje> :)
08:50:00 <quicksilver> esteth: haskell makes it easy to write cross platform programs.
08:50:06 <quicksilver> so most people choose to do so.
08:50:19 <quicksilver> HOC (cocoa for haskell) is similarly seldom used.
08:50:55 * Botje tried to think up a joke involving "ad hoc"
08:51:39 <monochrom> ad HOC polymorphism
08:52:14 <atsampson> I've never seen an ad for HOC -- perhaps that's why nobody uses it?
08:52:17 <nornagon> post hoc ergo propter hoc
08:53:09 <nolrai_> ?bot
08:53:10 <lambdabot> :)
08:53:17 <nolrai_> :t mapM
08:53:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:55:53 <gwern> heh heh. "museum pieces". well, I suppose that's one way to describe a lot of my hackage uploads
08:57:15 <esteth> zeno__, Thanks for the info, i'll try and find something about it
08:57:58 <esteth> quicksilver, I'm aware that writing cross platform stuff is easy in haskell, but there's some stuff I imagine can only really be dome with COM/WMI, such as asking windows to add an exception to the firewall for your app, amongst other things
08:58:46 <quicksilver> esteth: yup. I was just making a guess as to why it might be it's not popular.
08:59:01 <quicksilver> esteth: I wasn't making a value judgment on your choice of API :)
08:59:27 <esteth> Okie, I wasn't trying to sound nasty :)
09:03:57 <tusho> perfunctory :: (Perfunctor (f :: * -> *)) => f a -> f a
09:03:59 <tusho> i like that
09:18:00 <ziman> @ping
09:18:00 <lambdabot> pong
09:22:38 <mc__> @ping
09:22:38 <lambdabot> pong
09:22:48 <mc__> > gc 123 234
09:22:48 <lambdabot>   Not in scope: `gc'
09:22:55 <mc__> > gcd 123 234
09:22:56 <lambdabot>  3
09:27:26 <Tordek> is there pattern mtching syntax to check if a number is within a range?
09:27:48 <Tordek> like f (a < 1) b = 0
09:27:59 <marcot> Tordek: you can use guards.
09:28:11 <geezusfreeek> Tordek: f a b | a < 1 = 0
09:28:29 <sw17ch> f x | x < 10 = 'a' |
09:28:31 <sw17ch> woops
09:28:57 <Tordek> thansk
09:28:59 <Tordek> *ks
09:29:18 <sw17ch> Tordek: that's not the correct syntax... my backspace key isn't working...
09:30:03 <Tordek> I'm using geezusfreeek's
09:31:56 <Tordek> should I define my functions' types when writing my source, or just leave it to the compiler until it complains?
09:33:53 <sieni> Tordek: I guess it's a matter of taste, but I guess it's quite common to use explicit type annotations for documentational purposes if not else
09:35:13 <geezusfreeek> Tordek: i give type signatures for top level functions to make sure that things are compiling the way i expect
09:35:22 <geezusfreeek> and it helps with documentation too
09:36:21 <Tordek> okay, then
09:36:26 <sw17ch> i'll write the function with it there the first time, but when heavy hacking time comes, i drop it until the end, then i add them back to make sure i have what i expect
09:36:35 <Tordek> so... new question :P
09:37:12 <Tordek> I have a function f :: a -> a -> b, and another that is g -> a -> a -> [(b,b)]
09:37:50 <Botje> Tordek: Data.Ix has an inRange function
09:37:52 <Tordek> is there an easy way to map f g, or just map (\(x,y)...
09:37:53 <Botje> @hoogle inRange
09:37:53 <lambdabot> Data.Ix.inRange :: Ix a => (a, a) -> a -> Bool
09:37:53 <lambdabot> Distribution.Version.withinRange :: Version -> VersionRange -> Bool
09:38:31 <Botje> map (uncurry f) g
09:38:44 <dcoutts_> @seen pgavin
09:38:45 <lambdabot> pgavin is in #haskell. I don't know when pgavin last spoke.
09:38:58 <pgavin> hi dcoutts_
09:38:58 <lambdabot> pgavin: You have 1 new message. '/msg lambdabot @messages' to read it.
09:39:34 <pgavin> dcoutts_: hmm, I told it no permissions were necessary
09:39:41 <dcoutts_> pgavin: hmm
09:39:49 <Tordek> thanks, Botje
09:39:56 <pgavin> dcoutts_: xp?
09:40:02 <dcoutts_> pgavin: win2k3
09:40:12 <pgavin> k
09:40:12 <zeno__> Tordek: also the compiler can run into problems if you dont annotate your types occasionally
09:41:28 <dcoutts_> pgavin: unfortunately I cannot test the feature in inno setup, because the version of innosetup that introduces the feature itself requires admin privileges to install. Where as with older versions I was able to just skip the bits where it tried to write to inaccessible registry keys.
09:41:33 <pgavin> dcoutts_: PrivilegesRequired=none is actually what I added
09:41:45 <pgavin> ahh, hold on
09:42:29 <pgavin> the only registry key touched is in HKEY_CURRENT_USER
09:44:50 <pgavin> dcoutts_: ok, well I'll try making a limited user on XP and testing it there today
09:44:58 <sw17ch> dcoutts_: just so you know, i got something working which maintains type safety last night
09:45:03 <sw17ch> with the PCM headers
09:45:06 <dcoutts_> pgavin: thanks
09:45:11 <dcoutts_> sw17ch: well done :-)
09:45:13 <pgavin> dcoutts_: if it works on xp, 2k3 should work as well
09:45:20 <dcoutts_> pgavin: yeah
09:46:22 <dcoutts_> pgavin: unfortunately the only windows machine I have access to is this win2k3 server and I've only got an unprivileged account.
09:46:58 <pgavin> dcoutts_: I've been using a vm
09:47:17 <dcoutts_> pgavin: good idea. What vm do you use?
09:47:21 <pgavin> my desktop dual boots but it's just easier
09:47:30 <pgavin> dcoutts_: vmware
09:47:42 <dcoutts_> pgavin: full version or the free beer version?
09:47:44 <pgavin> dcoutts_: on mac osx
09:47:53 <pgavin> full version
09:48:01 <dcoutts_> right
09:48:14 <pgavin> umm, virtual box is what I use on linux though
09:48:28 <pgavin> it works similarly to vmware
09:48:34 <dcoutts_> pgavin: I should look into some vm solution for more automated testing
09:48:35 <pgavin> easier than xen etc.
09:48:46 <fons> hi
09:48:46 <lambdabot> fons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:48:50 <dcoutts_> pgavin: virtual box is Sun's thing right?
09:49:03 <pgavin> dcoutts_: yes, sun bought them
09:49:04 <fons> does anybody use the test feature of darcs?
09:49:09 <pgavin> dcoutts_: it's open source though
09:49:15 <dcoutts_> pgavin: yes
09:49:19 <byorgey> fons: sure.  xmonad is a prominent example
09:49:31 <fons> I'd like to know if there is a way to apply tests with push
09:50:01 <fons> I have a remote server with a special environment for certain test which I don't have locally
09:50:18 <fons> (EDA tools for hardware synthesis)
09:50:50 <fons> I would like tests only to happen with push, but it doesn't seem possible
09:52:33 <dcoutts_> fons: I suggest using darcs send and have the server side test+apply
09:52:53 <dcoutts_> fons: if the tests are long running then the whole thing being async is a bonus anyway
09:54:04 <fons> as well, I would also like the tests only to run when changes are made under certain directories (src/) without the need to explicitly supply --no-test. e.g. it's pointelss to run tests when documentation changes are made
09:55:11 <fons> dcoutts_: The thing is there is some other people who might contribute with code and I want to make sure that the tests run before patches are applied (with push)
09:55:36 <dcoutts_> fons: you could not get them to use send instead?
09:56:08 <dcoutts_> fons: eg just block direct push :-)
09:56:40 <fons> dcoutts_: I know a possible alternative is making them use send, but that either restricts their autonomy or requires signing mails
09:57:13 <dcoutts_> which isn't too hard of course, darcs send --sign iirc
09:57:30 <dcoutts_> fons: that's what we use for contributions to the gentoo haskell overlay for example
09:57:53 <dcoutts_> the server-side script applies signed patches and forwards anonymous patches to a reviewer list
09:57:59 <fons> dcoutts_: and how do you distribute keys and set the whole thing?
09:58:13 <pgavin> dcoutts_: hmm, I guess I must have messed up somewhere... I got the installer working under limited (but it doesn't find ghc)
09:58:32 <dcoutts_> fons: we have a gpg keyring on the server side containing the keys of everyone with write access
09:59:08 <dcoutts_> fons: you're welcome to have a look at the script we use
09:59:29 <fons> dcoutts_: I'm not saying it's not possible, but I find it reallly complicated if everyone already has direct access to the repository
09:59:40 <fons> (through ssh)
10:00:05 <dcoutts_> fons: I agree it would be good to be able to do tests at push time. I don't know that it's not possible.
10:01:54 <dcoutts_> fons: could you use the apply posthook? or does that run after it's been committed and so you cannot reject? I dunno.
10:02:43 <fons> dcoutts_: hooks can make patches being rejected?
10:03:05 <dcoutts_> fons: I'm not sure, I've only ever used them for email notifications
10:03:15 <fons> dcoutts_: I though it was just a command being run, without consecuences on the behaviour of darcs
10:03:20 <fons> thought
10:03:33 <dcoutts_> fons: that may well be the case, I don't know
10:03:48 <fons> uhmm, thanks, I didn't consider that possibility
10:04:04 <dcoutts_> fons: apply on the server side is used at push time though
10:04:32 <dcoutts_> I think. I mean our email notifications are done as an apply post hook, so can apply do tests too?
10:04:46 <dcoutts_> fons: apply has a --test / --no-test flag
10:06:01 <marcot> Good afternoon.
10:06:15 <marcot> Is there a difference between using fail and error in an IO monad?
10:06:27 <fons> dcoutts_:  apply can do tests, but push is what I need
10:06:40 * fons think he's mssing something
10:06:41 <dcoutts_> fons: yes, but what happens on the server side?
10:06:53 <fons> the server runs apply?
10:07:11 <maltem> @src IO fail
10:07:11 <lambdabot> fail s  = failIO s
10:07:14 <maltem> @src failIO
10:07:15 <lambdabot> failIO s = ioError (userError s)
10:07:32 <maltem> marcot: looks like it boils down to the same
10:07:36 <dcoutts_> fons: well I'm guessing so because we use the apply post-hook to do email notifications and that certainly works for darcs push.
10:07:50 <fons> let me check
10:07:51 <marcot> maltem: ok, thanks.
10:07:59 <ddarius> NO, ioError isn't error
10:08:06 <dcoutts_> marcot: for ghc it's the same, for other implementations it is not
10:08:13 <fons> BTW, do hooks have access to what's going on in the repository?
10:08:20 <marcot> dcoutts_: hum... good to know.
10:08:22 <ddarius> ioError is a catchable error in IO, error is not catchable at all in Haskell 98
10:08:26 <dcoutts_> fons: they get some env vars
10:08:37 <maltem> ah, I thought ghc produces a userError on "error", but I was wrong
10:09:00 <dcoutts_> maltem: it does.
10:09:15 <fons> dcoutts_: the ones described in the manual?
10:09:26 <dcoutts_> fons: I presume so, I've never looked
10:09:39 <fons> dcoutts_: they don't really tell what's going on
10:09:55 <ddarius> Also, fail is an action then when executed will throw an IOError.  error is an undefined value.
10:10:10 <dcoutts_> maltem: the confusion is that ghc's exception mechanism is used for IO errors too. ghc's exceptions let you throw errors in pure code and catch them in IO. So it just reuses the same mechanism for IO errors.
10:10:16 <fons> anyway, let's see if apply is really run on the server side
10:10:23 <maltem> dcoutts_: nice to know I was right, but then, why does an error call not print "user error"?
10:10:31 <dcoutts_> marcot: it's certainly better to use fail than error if you have the option to do either.
10:10:42 <dcoutts_> maltem: it does doesn't it?
10:10:54 <ddarius> > error "foo"
10:10:55 <lambdabot>  Exception: foo
10:11:15 <maltem> dcoutts_: as it turns out it doesn't
10:11:20 <dcoutts_> 'k, the must use different exception constructors then
10:11:42 <maltem> right
10:12:07 <dcoutts_> yes, ErrorCall :: String -> Exception
10:12:48 <ddarius> > fail "foo" `seq` ()
10:12:48 <lambdabot>  Add a type signature
10:12:49 <marcot> dcoutts_: to be explicit that I'm in a Monad?
10:12:58 <ddarius> > (fail "foo" :: IO a) `seq` ()
10:13:00 <lambdabot>  ()
10:13:08 <ddarius> > (error "foo" :: IO a) `seq` ()
10:13:09 <lambdabot>  Exception: foo
10:13:28 <dcoutts_> marcot: well it is better defined wrt ordering and is more portable
10:13:29 <ddarius> marcot: error and failIO do completely different things.
10:14:22 <marcot> Then they're not the same.
10:14:33 <marcot> I think fail is a good option.
10:14:53 <dcoutts_> marcot: right, if you're in a monad context then use fail
10:15:04 <marcot> My point is with Graphics.UI.Gtk.Glade.xmlNew, if the .glade file is not found.
10:15:15 <marcot> Is there as standard exception for this?
10:15:23 <dcoutts_> not really
10:15:51 <dcoutts_> marcot: you could use doesNotExistErrorType
10:16:46 <dcoutts_> ioError (mkIOError doesNotExistErrorType "message" Nothing (Just filename))
10:17:22 <marcot> dcoutts_: thanks, I was just searching how to use this function.
10:18:00 <zeno__> i have a class g with method1 :: g -> a -> Bool, but i want instances to be able to use anything for a.  is there a way to do this (define a type for 'a' in each instance)?
10:18:49 <Igloo> zeno__: Do you mean that, if you know g, then you also know a? e.g., if g == Bool then a must be Int?
10:21:11 <zeno__> Igloo: not really sorry, expample: class G g where f :: g -> a instance G A where f _ = 1;class G B where f _ = String
10:22:17 <zeno__> error: 'a' is a rigid variable bound by the type signature 'f' at...
10:22:19 * Igloo doesn't follow
10:22:30 * Igloo disappears for a bit
10:22:46 <ddarius> class G g a | g -> a where f :: g -> a
10:23:31 <hpaste>  eks pasted "(no title)" at http://hpaste.org/8501
10:23:55 <zeno__> ddarius: ah thanks a lot :)
10:24:25 <zeno__> haskells type system sure is powerful
10:24:36 <nolrai_> is MVar the haskell version of mutexes?
10:25:27 <ddarius> nolrai_: No, but you could use them for that purpose.
10:25:58 <dons> go darcs 2
10:27:46 <marcot> dcoutts_: in gtk2hs is it a problem to use load the glade file each time a widget is get?
10:28:03 <dcoutts_> marcot: yes. Don't do that.
10:28:32 <dcoutts_> marcot: They'll be different instances each time you load the glade file.
10:28:55 <dcoutts_> load it once, get the widgets you need and save them in a record
10:28:58 <marcot> dcoutts_: I've seen it in python SimpleGladeApp.  It is good to detroy windows and recreate then.
10:29:32 <dcoutts_> marcot: that's the only time you'd want to do it. If you're destroying the whole window and re-creating it from scratch then yes you can load the glade file again.
10:29:52 <marcot> dcoutts_: I know they'll be different widgets, but that's what I want.  It's like when pressing New..., I want a different window from the last time the user has pressed New...
10:30:03 <dcoutts_> marcot: yes, that's fine.
10:30:29 <zeno__> wouldnt it be preferrable to program it all in w/o glade?
10:31:56 <marcot> dcoutts_: but if I use associate xmlNew with xmlGetWidget in a function that will be called for all widgets, but not to get the same reference of a widget, will it be worse from the performance point of view?
10:32:11 <marcot> dcoutts_: does it make a big difference?
10:32:17 <dcoutts_> zeno__: no, glade makes gui design much easier
10:32:57 <marcot> And the program much more flexible.  You can run the same code with different glade files and get different results.
10:33:25 <dcoutts_> marcot: xmlGetWidget will return the same widget each time for the same instance of the gladexml. It is slower than saving the result of course.
10:33:44 <dcoutts_> marcot: as for how big a difference, I don't know exactly. You'd have to measure it.
10:34:32 <dcoutts_> marcot: I just think it's a preferable design to do all the xmlGetWidget calls in one go and not do it anywhere else in the code.
10:35:39 <nolrai_> if Im writing to an IORef in one thread, and reading it in another, will the reads get messed up by the writes, ie will I end up reading part of one write and part of the next, or will this work?
10:36:38 <dcoutts_> nolrai_: there is certainly no ordering guarantee
10:36:58 <dcoutts_> nolrai_: if you're using multiple threads you should be using an MVar not an IORef
10:37:07 <ddarius> nolrai_: I'm pretty sure you can safely assume the actual writing to an IORef is atomic.  You won't get have a pointer or anything.
10:37:16 <ddarius> s/have/half
10:37:42 <dons> Igloo: hey, why's fgl in the extralibs ?
10:37:50 <hpaste>  marcot pasted "Glade question" at http://hpaste.org/8502
10:37:51 <marcot> I don't think you I expressed myself very well...
10:37:52 <dons> Igloo: shouldn't martin just release it on his own on hackage?
10:38:06 <dcoutts_> dons: doesn't that go for all of "extralibs" ?
10:38:09 <dons> Igloo: maybe we can swap it for some of the other hot things. e.g.   binary, hmatrix.
10:38:18 <dons> dcoutts_: well, extra-libs as a whole are a useful concept
10:38:22 <marcot> dcoutts_: I agree with you, I don't call xmlGetWidget more than one time for each object.
10:38:31 <dons> haskell platform time!
10:38:46 <dons> ghc + core + extra-libs == blessed platform, would make me happy
10:38:48 <marcot> dcoutts_: my question is if there's a problem (maybe of performance) of calling a xmlNew to each xmlGetWidget.
10:38:48 <dcoutts_> dons: right, a platform. I'm not sure ghc+extralibs is useful.
10:38:57 <dons> enough to build all major apps, and cover a good spectrum of use cases
10:39:13 <dcoutts_> dons: we should not be synchronising all these other lib releases with the ghc release.
10:39:15 <dons> s/extralibs/snapshot of the platform for 6.10/
10:39:26 <dons> just so people know what to download
10:39:29 <marcot> dcoutts_: Cause as it's good to do this when I want a new window, I don't see a reason not to do this if there's no significative performance loss.
10:39:57 <Igloo> dons: All of extralibs are only in extralibs because they've always been in extralibs
10:40:32 <dcoutts_> marcot: your two examples do quite different things. One makes one instance of the widgets. The other makes two instances.
10:40:35 <dons> i'd like to move towards a bundled 'haskell: batteries included' suite by 6.10 then.
10:40:38 <dons> does that seem possilbe?
10:40:49 <dcoutts_> dons: yes, but not synchronised with ghc if possible
10:40:53 <dons> right.
10:41:02 <dons> just as long as its linked next to ghc on the web site
10:41:05 <dcoutts_> dons: we should be doing a platform release some days or weeks after the ghc-6.10 release
10:41:07 <marcot> dcoutts_: two instances of each widget?
10:41:22 <dcoutts_> marcot: yes, but then you're only getting a reference to one of them
10:41:31 <dons> dcoutts_: yes. with encouragement to distros to bundle ghc + haskell platform
10:41:38 <dons> SO how do we bring about consensus here.
10:41:38 <dcoutts_> marcot: eg if the glade file defines a top level window then you'll be getting two of them
10:42:02 * dons finds the perspective of a distro maintainer motivating for batteries included installs
10:42:08 <marcot> dcoutts_: hum, I see...
10:42:10 <RayNbow> <dons> i'd like to move towards a bundled 'haskell: batteries included' suite by 6.10 then. <-- this is actually a good idea
10:42:14 <dcoutts_> dons: we drop extralibs from the ghc release completely and say that there will be a "batteries included" platform release after the ghc release
10:42:41 <marcot> dcoutts_: so it's a good idea to use xmlNew again only if I need to work with another window?
10:42:42 <dcoutts_> dons: we use that intermediate time to make sure all the platform libs and tools work smoothly with the new ghc release
10:42:48 <dcoutts_> marcot: right.
10:42:58 <marcot> dcoutts_: ok, thanks.
10:42:58 <dons> dcoutts_: and to identify the platform, of course.
10:43:08 <dons> we should start now, assuming 6.10 is september
10:43:12 <setuid_w00t> Is there a standard way to get a hexadecimal string from an Int or Integer?
10:43:40 <dcoutts_> marcot: xmlNew actually constructs all the widgets. xmlGetWidget just gets a reference to an already-constructed widget.
10:43:50 <dcoutts_> setuid_w00t: see the Numeric module
10:43:54 <dcoutts_> dons: right
10:44:04 <dcoutts_> dons: and we should tell people what the plan is.
10:44:04 <setuid_w00t> dcoutts_: Thanks
10:44:07 <dons> dcoutts_: so how to approach this? prepare a good proposal offline, announce on libraries?
10:44:17 <dons> with mechanisms for QA, vetting packages
10:44:29 <dons> based on our experience, and that of other projects
10:44:35 <dcoutts_> dons: the best analogy I can think of is Gtk+ and GNOME
10:44:39 <dons> with metrics for stabilyt, coverage of the platform and so on
10:44:41 <dons> yes.
10:45:06 <dons> how many packages do you think would fall under the core platform?
10:45:08 <maltem> > showHex 12 "" -- ^ setuid_w00t
10:45:09 <lambdabot>  "c"
10:45:11 <dons> something approximating python's coverage?
10:45:23 <dons> or with duplicates for particular domains?
10:45:27 <dcoutts_> dons: Gtk+ is obviously the core of the GNOME platform. It's got a release cycle that means that Gtk+ releases happen well before the GNOME platform releases. Enough time for maintainers of platform packages to make sure it works and take advantage of new features.
10:45:51 <dons> yes, we've been caught out with timing before
10:45:59 <dons> getting release cycles in place would be good
10:46:08 <dcoutts_> dons: we should use being in the platform as a carrot but also as a QA hump
10:47:05 <marcot> dcoutts_: I'm trying to run something like it in GHCi, and in the second call I make to xmlNew, it creates a window, even before mainGUI.
10:47:09 <dcoutts_> dons: again that's following the GNOME approach. They have a bunch of QA guidelines. People can proposes new packages for the platform to be included in the next major release. They obviously have to be up to scratch.
10:47:13 * Igloo is in favour of anything that gets rid of extralibs  :-)
10:47:45 <dons> Igloo: agreed. its crufty and doesn't represent the diversity of haskell libs now
10:47:45 <dcoutts_> dons: so staring small means we can get QA improvements for things that are to be added to the platform.
10:47:52 <dons> yes
10:48:09 <dons> ok, a wiki page, and a plan for the first cut of the platform
10:48:36 <dons> then the platform team can do entirely separate releases from ghc
10:48:45 <dcoutts_> dons: yes
10:48:45 <dons> which will make libraries@ happy
10:48:58 <dons> ok. i can see a path to getting this done now.
10:49:02 <dons> i'll put up some notes.
10:49:24 <dons> if we can start with say, full trac support for anything in the platform
10:49:24 <dcoutts_> dons: there has already been some discussion along these lines on some mailing list. I don't recall which.
10:49:37 <dcoutts_> dons: I was pushing the GNOME approach of course :-)
10:49:48 <marcot> dcoutts_: The second example creates two windows.  Thanks for the help.
10:49:49 <dcoutts_> dons: hmm? trac?
10:50:10 <dons> a central bug tracker for things in the platform
10:50:11 <dcoutts_> dons: you mean each package in the platform must have some kind of bug tracker?
10:50:18 <dons> so users know where to report platform issues
10:50:22 <dcoutts_> dons: oh, central. I don't think that'll work.
10:50:30 <dcoutts_> dons: several have existing tracs.
10:50:38 <dons> well, aggregating them at least
10:50:47 <dons> so there's  a single url you visit to report a library problem
10:50:52 <dcoutts_> dons: but we should add a bugs link in the .cabal files and require that of all platform packages.
10:51:00 <dons> that'd do it.
10:51:08 <dcoutts_> and a darcs repo :-)
10:52:26 <fons> dcoutts_: just in case you're curious, push causes apply commands in the server
10:52:38 <dcoutts_> fons: right
10:53:02 <fons> dcoutts_: so push can run tests without problems is test is set as the default argument
10:53:23 <Baughn> Or you can set darcs to run tests locally before pushing
10:53:42 <fons> and if the prehook fails with an error exit code, apply is not run
10:53:55 <fons> Baughn: that's exactly what I'm trying to avoid :)
10:54:07 <fons> Baughn: I want the tests to be run in the server
10:54:17 <Baughn> fons: Well, you might want both
10:54:34 <Baughn> The server is usually overloaded, too
10:55:05 <fons> Baughn: the problem is that the server has anvironment I cannot have
10:55:19 <fons> Baughn: which makes some local changes imposible
10:55:54 <fons> the only thing I'm missing is a --no-test argument for push
10:56:29 <dcoutts_> dons: the other good thing about the GNOME release management is that it is predictable. They have releases every 6 months, no slippage. In between they have bug fix point releases, 3 of them at even intervals.
10:56:51 <hpaste>  Baughn pasted "Stack overflow" at http://hpaste.org/8503
10:57:05 <dcoutts_> dons: so there is no pressure to make deadlines slip because you can always put new features into the following release.
10:57:24 <Baughn> So this thing overflow some 700,000 records in. It's not even using explicit recursion, so.. anything obvious?
10:57:27 <dons> that's good
10:57:35 <dons> ghc's long cycles create some pressure we should try to avoid
10:57:51 <dcoutts_> dons: Gtk+ also has longer release cycles. It's not a major problem.
10:59:30 <dcoutts_> dons: Gtk+ has ~9 month release cycles. GNOME releases only pick up major Gtk+ releases if they are ready ~3 months before the platform release. That gives enough time to stabilise.
11:04:48 <Igloo> dons: GHC's cycle is only 12 months - or <6 if you're including point releases
11:06:20 <dons> right, it's those gaps between 6.6, 6.8, 6.10 that used to create pressure to get things in core. That pressure may largely have dissipated thanks to hackage/split-base.
11:06:37 <dons> we'd want to ensure any core platform was also similarly flexible wrt. timginn
11:06:48 <dcoutts_> dons: another interesting aspect of GNOME releases compared to how we've done ghc releases is that GNOME ones are collections of pre-existing tarballs not packages that were unreleased and then all released at the same moment.
11:07:04 <dons> so just "blessed" in some way
11:07:05 <dons> ?
11:07:18 <dons> rather than the magic sneaky releases we do now of say, unix or mtl
11:07:24 <dons> or process, random, et al
11:07:46 <dcoutts_> dons: uin the GNOME release cycle there is a window of a week or two for the "final tarballs" to be uploaded to the central gnome server
11:07:49 <dcoutts_> uin/in
11:08:05 <dcoutts_> dons: then the overall release is a list of tarballs
11:08:29 <dcoutts_> dons: using hackage in a similar way would be the obvious thing for us to do
11:08:41 <dons> yep
11:09:20 <dcoutts_> dons: rather than the current system of darcs repos of the extra libs and then making tarballs of all of them simultaneously at the time of the final release
11:09:21 <dons> ok. so I think this is something we need to set as a firm goal by 6.10
11:09:33 <dons> its a crucial next step,after hackage and cabal-innstall
11:09:38 <Igloo> dcoutts_: For bootlibs I think doing it our way is easier
11:09:45 <dcoutts_> Igloo: yes
11:09:51 <hpaste>  Larose pasted "User defined type" at http://hpaste.org/8504
11:09:52 <dons> a single tarball you mean, Igloo ?
11:10:17 <Igloo> dons: Well, working directly with the darcs repos
11:10:21 <dcoutts_> dons: yes, and we need the testing infrastructure. That's the other aspect of the gnome system. They've got a good infrastructure to let people build and test all the packages together.
11:10:37 <Larose> How can I access the "Int" in "Vnum"? http://hpaste.org/8504
11:10:40 <vixey> Larose: what?
11:10:41 <Igloo> dons: But also single tarball, yes. Otherwise users need to always get n tarballs instead of just 1
11:11:00 <vixey> Larose: I think you should use GADTs to make this simpler
11:11:08 <dcoutts_> Igloo, dons: I think that's fine. The ghc+bootlibs are tightly coupled.
11:11:10 <Baughn> So I just rewrote a fairly complex text extraction/indexing system to pipeline its work across several processors - painlessly, in less than five minutes. Bravo, haskell!
11:11:22 <vixey> Larose: if you index Exp with the type, you can write it more naturally
11:11:24 <dcoutts_> Igloo, dons: but they're also pretty small these days. So that's all fine.
11:11:36 <vixey> Larose: (I'll make an example.. one second..)
11:12:07 <dcoutts_> dons: the most important thing is telling people and managing expectations. We have to stop people from expecting a windows installer the very second that ghc is released.
11:12:45 <Igloo> Well, they can have an installer of GHC+bootlibs
11:13:04 <Igloo> which will may include cabal-install
11:13:04 <dcoutts_> yes, though it's probably not useful for the average windows noob
11:13:57 <hpaste>  vicky annotated "User defined type" with "well typed evaluation" at http://hpaste.org/8504#a1
11:14:41 <vixey> Larose: with that sort of thing, you can use haskell values instead of boxing up Int and Bool into a union (Val)
11:15:09 <vixey> Larose: and as a consequence you don't have to do (unsafe in the sense that it's not type checkably correct) unboxing
11:15:25 <Larose> vixey: ok thanks
11:16:20 <vixey> Larose: the other way is to write partial functions like  fromNumVal :: Val -> Int, fromBoolVal :: Val -> Bool
11:16:45 <vixey> Larose: then you put them everywhere, and hope for the best
11:16:48 <dino-> Hello Haskellites
11:17:11 <dino-> I'm confused about 'forall', I'm getting an error from ghc 6.8.2 for some source that uses this in a type sig
11:18:24 <dino-> It seems to be not at all what the compiler is expecting to see: Database/HSQL/Types.hs:134:18: Not in scope: type variable `forall'
11:18:51 <byorgey> dino-: you probably need to enable ExistentialQuantification
11:19:06 <byorgey> i.e. put {-# LANGUAGE ExistentialQuantification #-} at the top of your program
11:19:07 <dino-> ah, directive
11:19:13 <byorgey> or compile with -XExistentialQuantification
11:19:27 <dino-> Now, let me ask a possibly silly question..
11:19:34 <dino-> Why is this necessary?
11:19:47 <dino-> I mean, here's the type: stmtGetCol :: forall a . Int -> FieldDef -> (FieldDef -> CString -> Int -> IO a) -> IO a
11:19:54 <dino-> Isn't is obvious that this if for all a?
11:19:55 <byorgey> dino-: Haskell 98 does not allow explicit 'forall's in type signatures
11:20:08 <dino-> no no, I mean why do we need to say it at all?
11:20:10 <byorgey> dino-: yes, in fact, the forall would be implicit if you just leave it off
11:20:11 <Deewiant> it is obvious, even more so if you leave out the forall ;-)
11:20:24 <rwbarton> dino-: Writing 'forall a .' lets you use 'a' as a type variable in the definition of stmtGetCol.
11:20:53 <byorgey> all types with type variables are implicitly quantified with a forall
11:20:59 <dino-> Ok, so in this case, just looking at the type sig, I'm not seeing what the forall is really useful for (yet)
11:21:09 <byorgey> dino-: in this particular case, nothing.
11:21:25 <dino-> ok, I need to learn this. But atm I'm merely tryig to get that bad old hsql to build
11:22:01 <byorgey> rwbarton: well, you would also need to enable ScopedTypeVariables
11:22:35 <Baughn> dino-: forall is useful in the specific case where it /isn't/ scoped over the entire type declaration
11:22:55 <dino-> Ok. Thank you very much.
11:26:51 <dino-> At this point I've had to make a fair number of changes to get this thing to build. I would much rather be making these changes into a darcs repo though. Is there somewhere that thigns like this live for darcs get? hsql says it's currently unmaintained..
11:27:26 <dino-> But I'd love to work against the existing repo with history rather than darcs init
11:30:37 <rpaulo> hi, I want to read a list of integers from input, but ++ doesn't seem to work with IO [Int]
11:30:54 <rpaulo> how do I accomplish that?
11:31:03 <vixey> no ++ wont
11:31:12 <EvilTerran> rpaulo, have you met "do" blocks?
11:31:15 <vixey> you can just read it normally
11:31:20 <vixey> > read "[1,2,3]" :: [Int]
11:31:21 <rpaulo> EvilTerran: yes.
11:31:22 <lambdabot>  [1,2,3]
11:31:45 <EvilTerran> dionoea, ...
11:32:02 <dionoea> EvilTerran: sorry about that :)
11:32:12 <EvilTerran> rpaulo, well, you can get the [Int] out of an IO[Int] with <- in a do block
11:32:45 <dino-> aha: http://darcs.haskell.org/HSQL/
11:32:46 <lambdabot> Title: Index of /HSQL
11:33:21 <rpaulo> hmmm
11:33:22 <EvilTerran> well, that's a half-truth - an IO[Int] doesn't actually contain an [Int], it just contains instructions to the run-time system that tell it to do some side-effects and give back an [Int]
11:33:44 <dons> dcoutts_: should i be using cabal-install with build reporting yet?
11:33:49 <dino-> er: Use the new repo at http://code.haskell.org/HSQL/
11:33:50 <lambdabot> Title: Index of /HSQL
11:33:55 <rpaulo> I have a "n" number of integers to read
11:34:13 <EvilTerran> this is why, if you have action :: IO[Int], then (do x <- action; y <- action; return (x,y)) won't necessarily return two identical values
11:34:14 <vixey> rpaulo: You will probably want to use : instead of ++
11:34:20 <EvilTerran> rpaulo, ahhh, i see
11:34:34 <EvilTerran> rpaulo, are you reading each one in on stdin on its own line?
11:34:45 <EvilTerran> or something similar to that?
11:34:45 <rpaulo> each on its own line
11:35:08 <EvilTerran> ?type readLn
11:35:10 <lambdabot> forall a. (Read a) => IO a
11:35:15 <EvilTerran> that will get you one value
11:35:24 <rpaulo> yeah
11:35:28 <vixey> > let countDown 0 = [] ; countDown n = n : countDown (n-1) in countDown 23
11:35:29 <lambdabot>  [23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
11:35:29 <dcoutts> dons: you certainly can use it. It doesn't actually upload to the server but it generates them in a form where we'll be able to upload later. There's also functions for parsing the report log files.
11:35:30 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
11:36:10 <dcoutts> dons: it's already generating them if that's what you mean. There's no flag to turn it on/off yet.
11:36:35 <rpaulo> EvilTerran: I have something like: main = do k <- readK; list <- readN k ..
11:36:50 <rpaulo> but I'm having troubles implementing readN
11:36:53 <EvilTerran> that's a good start, actually
11:36:56 <EvilTerran> what's readN's type?
11:37:01 <vixey> rpaulo: it will be similar to countDown
11:37:02 <rpaulo> readN :: Int -> IO [Int]
11:37:06 <EvilTerran> that works
11:37:21 <EvilTerran> now, let's do some case analysis; readN 0 = ???
11:37:30 <rpaulo> readN 0 = return []
11:37:33 <EvilTerran> indeed
11:37:56 <vincenz> rpaulo: what is your basae case?
11:37:59 <vincenz> EvilTerran: noooo
11:38:08 <EvilTerran> no?
11:38:22 <vincenz> readN = sequence . flip replicate (read1)
11:38:34 <vixey> :t read1
11:38:36 <lambdabot> Not in scope: `read1'
11:38:39 <vincenz> assuming some read1
11:38:46 <vincenz> (which is monadic)
11:38:57 <EvilTerran> vincenz, i know readN = flip replicateM readLn, but that doesn't help with the basic concepts
11:39:17 <vincenz> ok
11:39:30 * vixey prefers.. readNLn n = sequence . replicate n readLn
11:39:42 <rpaulo> right, that works
11:39:46 <EvilTerran> that'll just look like magic if you can't write the explicit recursion and do-block version
11:39:58 <rpaulo> which I can't :-)
11:40:00 <vixey> rpaulo: Do you understand countDown though?
11:40:06 <EvilTerran> rpaulo, right, let's fix that :)
11:40:09 <vincenz> vixey: need a $ then
11:40:32 <vixey> oh yes
11:40:38 <EvilTerran> rpaulo, so, now we just need to define readN n | n > 0
11:41:28 <EvilTerran> rpaulo, let's do an inductive step, and assume that readN (n-1) will do what we'd expect
11:41:46 <rpaulo> so, readN (n+1) = do number <- readK ; ..
11:41:58 <EvilTerran> readK?
11:42:07 <rpaulo> readLn
11:42:10 <EvilTerran> righto
11:42:24 <EvilTerran> ah, we're using (n+k) notation. okay then.
11:42:45 <vincenz> n+k notation is evil
11:42:51 <suspect43> beginner question: i got fed up with C++'s anal retentiveness, then i got fed up with python's performance. is haskell the right lang to learn?
11:42:52 <EvilTerran> we're trying to define (readN (n+1)), so our inductive step would be to assume that (readN n) does what we want
11:43:04 <vixey> vincenz: the true evil is not having defined Integer as peano :p
11:43:05 <opqdonut> vincenz: it's good to have as long as we can't pattern match succ
11:43:10 <suspect43> or should i go for D or ocaml? or something else?
11:43:10 <EvilTerran> ie, produces an IO [Int] with n values in it
11:43:12 <opqdonut> vixey: :)
11:43:21 <Tordek> I'm doing some dice rolls analysis, and I need to generate all posibilities. I need a function generateRolls :: a -> [[b]], which takes the number of dice I roll, and returns all the possibilities... how can I do that?
11:43:24 <rpaulo> yes but now what? return number:(readN n) ?
11:43:27 <vincenz> vixey: easily done
11:43:34 <vixey> rpaulo: you cannot do that
11:43:35 <vincenz> vixey: data Nat = Z | S nat :)
11:43:45 <suspect43> basically: how fast is naive haskell code?
11:43:54 <EvilTerran> rpaulo, but (readN n :: IO [Int]), and (:) wants an [a] on the right, not an IO[A]
11:43:57 <EvilTerran> er, s/A/a/
11:44:05 <rpaulo> hmm
11:44:05 <Tordek> ie, generateRolls 1 = [[1],[2],[3],[4],[5],[6]]. generaterolls 2 = [[1,1],[1,2],...]?
11:44:06 <vixey> vincenz: yeah...... but a bit impractical, the compiler wont accelerate that with GMP and such
11:44:20 <EvilTerran> rpaulo, you got an Int from an (IO Int) a minute ago - it's the same trick
11:44:42 <vincenz> vixey: sadly
11:45:05 <mattam> suspect43: I would advice ocaml, it has a performance model closer to what you know and all of the benefits brought by functional programming.
11:45:07 <vincenz> Tordek: shouldn't you pass in the number of sides as wel?
11:45:26 <vincenz> > sequence $ replicate 3 $ [1..3]
11:45:27 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
11:45:37 <Tordek> vincenz: I'm just doing it for d6, but, sure
11:45:41 <mattam> suspect43: It's got an oo system too if you're into that.
11:45:49 <vincenz> > let dice n s = sequence $ replicate n $ [1..s]s in dice 2 6
11:45:49 <lambdabot>  Couldn't match expected type `t -> a' against inferred type `[a1]'
11:45:58 <vincenz> > let dice n s = sequence $ replicate n $ [1..s] in dice 2 6
11:45:59 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[3,...
11:46:01 <Tordek> thanks :)
11:46:08 <vixey> @dice 2d6
11:46:08 <lambdabot> 2d6 => 12
11:46:12 <vixey> :P
11:46:22 <suspect43> mattam: alright. and what's the pros of haskell vis-a-vis ocaml?
11:46:26 <EvilTerran> rpaulo, the thing is, you can tell from (readN n)'s type (ie IO [Int]) that it's an IO action - that is, you need to "run" it before its side-effects (ie reading from stdin) can happen and an actual [Int] value can be obtained
11:46:26 <Tordek> hehe
11:47:07 <EvilTerran> rpaulo, and you do this the same way you would if you wanted to get an Int from an action of type IO Int
11:47:27 <EvilTerran> rpaulo, and that would be ...?
11:48:44 <mattam> suspect43: well, it's (almost completely) pure, which makes it look like math: simple, rigourous and effective notation. It has overloading/lightweight modules. It has a great community :)
11:48:45 <rpaulo> I tried next <- readN n; return (number ++ next) but that fails :-/
11:49:01 <rwbarton> > 3 ++ [4,5,6]
11:49:02 <lambdabot>   add an instance declaration for (Num [t])
11:49:14 <vixey> rpaulo: hello...?
11:49:20 <rwbarton> Hmm, that's not a very helpful error message.
11:49:21 <suspect43> :)
11:49:23 <EvilTerran> rpaulo, bear in mind that (readN n :: IO [Int]), so, in that case, (next :: [Int])
11:49:27 <vixey> rpaulo: <vixey> rpaulo: Do you understand countDown though?
11:49:42 <rpaulo> vixey: sorry, I missed that
11:49:43 <EvilTerran> wait, never mind
11:49:56 <EvilTerran> rpaulo, the problem is that (number :: Int)
11:50:05 <EvilTerran> ?type (++) -- and (++) wants lists on both sides
11:50:07 <lambdabot> forall m. (Monoid m) => m -> m -> m
11:50:09 <EvilTerran> DOH
11:50:13 <EvilTerran> ?hoogle (++)
11:50:13 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
11:50:13 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
11:50:13 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
11:50:21 <rpaulo> EvilTerran: ah, right. dumb me
11:50:33 <suspect43> math >> oo. haskell sounds awesome. where do i sign up?
11:50:52 <vixey> suspect43: What is ">>" ?
11:51:05 <EvilTerran> "much greater than", i suspect(43 ;])
11:51:12 <suspect43> greater-greater?
11:51:26 <vixey> weird abuse of conventional notation
11:51:34 <sw17ch> right shift by "oo" ?
11:51:42 <suspect43> vixey: it IS conventional notation
11:51:44 <Igloo> It's quite common IME
11:51:53 <vixey> I've not seen this anyway
11:51:53 <Igloo> Although confusing in a Haskell context
11:51:55 <vixey> anywhere
11:52:04 <suspect43> as in: x/y = 0 if y>>x, that kind of thing
11:52:19 <vixey> never seen that ever
11:52:24 <vixey> seems like informal nonsense
11:52:27 <EvilTerran> "much greater than" does strike me as a slightly peculiar phrase
11:52:36 <rpaulo> EvilTerran: thanks a lot for the help, it works well now :)
11:52:38 <EvilTerran> i guess it means "as the difference tends to infinity"
11:52:40 <vixey> x/y -> 0 as y -> inf is ok
11:52:56 <suspect43> vixey: high school math. the textbooks are full of it
11:53:00 <vixey> oh
11:53:04 <Igloo> Oh, I've only seen it used informally
11:53:07 <vixey> then yes, informal nonsense
11:53:14 <suspect43> vixey: well, yes :)
11:53:15 <Igloo> If you think that makes it nonsense, then that's your right  :-)
11:53:26 <EvilTerran> ?go lockhart's lament
11:53:28 <lambdabot> http://www.maa.org/devlin/devlin_03_08.html
11:53:28 <lambdabot> Title: Lockhart's Lament
11:53:32 <flux> vixey, not really, it would be y/x -> inf?
11:53:32 <vixey> I don't think I learned any math in my several years in school ...
11:53:53 <flux> I wouldn't be so sure it's not used in the unis too, though
11:54:02 <flux> although I haven't paid attention
11:54:10 <EvilTerran> that thar link's about the epic failure that's school-level maths education
11:54:13 <suspect43> but verbosely using a limit where a >> will do is exactly the kind of thing screwed up in C++
11:54:45 <vixey> sorry for that whole digression
11:54:58 <suspect43> :) nevertheless, lockhart's lament is worth a read
11:55:09 <vixey> suspect43: I think the best thing to do anyway, just pick some application to write and go for it
11:55:18 <EvilTerran> suspect43, the thing about haskell is that it often helps to stop thinking about pure code as a program, and more as you would a mathematical expression
11:56:02 <EvilTerran> i think a lot of programmers who're used to imperative languages struggle because they don't make that distinction
11:57:11 <EvilTerran> you said you didn't like how "anal retentive" C++ is - what exactly did you mean by that?
11:57:51 <EvilTerran> poorly-specified (if not broken) semantics? painful verbosity to tell the compiler things it should be able to work out for itself (java, i'm looking at you here)?
11:58:16 <suspect43> verbosity, most of all, and kludgy syntax
11:59:07 <suspect43> code that's eye rape (which is what drew me to python) and needs half an hour to make minor changes to
11:59:12 * vixey . o O ( Does java have the monomorphism restriction too? )
12:00:00 <suspect43> hack-y templates and un-"generic programming"
12:00:04 <EvilTerran> vixey, java doesn't have type inference
12:00:20 <vixey> I know.. :p
12:00:27 <EvilTerran> Map<Integer,String> = new HashMap<Integer,String>(); kinda pain is what i was thinking of
12:00:34 <vixey> I was kidding aat "verbosity to tell compiler things it should work out itsself"
12:00:43 <EvilTerran> er, i missed out the variable name, but you get the idea :P
12:00:52 <suspect43> exactly :)
12:01:14 <EvilTerran> suspect43, well, haskell has type inference, so you need practically no type signatures
12:01:29 <EvilTerran> and is generally pretty good at things being inferred when they can be
12:02:13 <suspect43> superstitious question: that's fast, right?
12:02:23 <EvilTerran> type inference is almost entirely compile-time
12:02:28 <suspect43> silly me. it's a compilet time decision?
12:02:32 <suspect43> ah, i thought so
12:02:34 <vixey> huh.. almost?
12:02:48 <EvilTerran> there's a few cases where a run-time decision is needed, but they're pretty exotic
12:03:01 <vixey> which cases
12:03:02 <vixey> ?
12:03:06 <EvilTerran> wrong button? :P
12:03:23 <EvilTerran> i think it comes up occasionally if you're using existential types or GADTs
12:03:50 <EvilTerran> think of Data.Dynamic for an extreme example
12:04:34 <suspect43> "existential types" :) i remember reading this language spec, lang called Sartre -- an existential lang. it segfaulted of despair
12:04:43 <EvilTerran> heh
12:04:50 <byorgey> heh, not THAT kind of existential =)
12:05:06 <suspect43> oo segfaults! do you have THOSE?
12:05:17 <EvilTerran> suspect43, anyway, haskell is capable of speeds that're comparable to C. it'll tend to be a little slower, but nearer to C than to python in most cases
12:05:26 <vincenz> I segfault, therefore I am.
12:05:30 <EvilTerran> we don't usually have segfaults
12:05:32 <vixey> suspect43: yes, in a small well defined part of the language only
12:05:48 <EvilTerran> the foreign function interface can be used to cause segfaults, i suspect
12:06:13 <EvilTerran> occasionally a compiler bug will come up and ghc will tell you that the impossible just happened
12:06:18 <suspect43> but my 30 line toy probably won't? lovely.
12:06:28 <EvilTerran> but, even when the impossible happens, it doesn't usually segfault
12:06:39 <vixey> suspect43: You will not get a segfault in any pure code or certain monds, that's one the purposes of a type system
12:06:47 <mauke> you can cause segfaults with unsafePerformIO or unsafeCoerce, or by calling C functions
12:06:48 <vixey> (the property is called soundness?)
12:07:03 <mauke> or by sending yourself a SIGSEGV :-)
12:07:20 <sw17ch> i caused a segfault today with FFI :)
12:07:35 <sw17ch> it was intentional to make sure what i thought i was doing was actually waht i was doing...
12:07:35 <EvilTerran> suspect43, if you don't do any of the stuff mauke's talking about, you should be completely safe from segfaults
12:07:52 <EvilTerran> sw17ch, did you want a core dump to analyse or something?
12:07:57 <EvilTerran> i'm sure there's a better way of doing that
12:08:01 <sw17ch> suspect43, if you don't know what he's *talking* about, then you're also safe
12:09:14 <suspect43> who, mauke? SIGSEGV has been my constant companion through day and night -- more night than day, though.
12:09:16 <EvilTerran> sw17ch, should that emphasis be on "know" rather than "talking"?
12:09:31 <EvilTerran> to emphasise that i said "do" where you said "know", i mean...
12:09:32 <sw17ch> EvilTerran, yes... it should
12:09:39 <sw17ch> :)
12:09:41 * EvilTerran is a grammar fascist
12:09:57 <suspect43> emphasis fascist
12:09:58 <suspect43> rather
12:10:01 <sw17ch> hah
12:10:08 <EvilTerran> i guess so
12:10:13 <EvilTerran> semantics fascist
12:10:36 <sw17ch> so, just out of pure curiosity, what are the ages in here? I'm 22.
12:10:42 <suspect43> but his semantics may differ. square one :)
12:10:44 <EvilTerran> it's not like the grammar i use is perfectly in line with "proper english"
12:10:58 <suspect43> which is ill-defined in any case
12:11:02 <EvilTerran> but it's self-consistent
12:11:14 <paolino> sw17ch: can it be for anything out of curiosity ?
12:11:26 <BMeph> EvilTerran: Semanscist? ;)
12:11:45 <sw17ch> sure
12:11:54 <EvilTerran> and doesn't have stupid things like {...," he said}
12:11:56 <suspect43> paolino: on anywhere except a programming language channel, it would most likely NOT be out of curiousity :)
12:12:13 <EvilTerran> (the comma goes outside the quotemark, dammit. it's part of the outer sentence, not the one being quoted! jeez.)
12:12:36 <EvilTerran> sw17ch, i'm 19, just finished the second year of my undergrad degree
12:13:00 <sw17ch> math/cs?
12:13:00 <suspect43> 16. enduring high school. getting bored in math classes.
12:13:23 <mauke> that's a new one.
12:13:24 <mauke> haddock: Prelude.Enum.Bool.toEnum: bad argument
12:13:32 <sw17ch> suspect43: ah! fantastic! wow, you're my little brother's age... perhaps you could convince him to drop the XBox and learn to program
12:13:33 <mauke> has anyone seen this?
12:14:32 <sw17ch> would any one else be interested in having full ALSA bindings?
12:14:35 <pgavin> dcoutts: http://code.haskell.org/~pgavin/gtk2hs-0.9.13-rc/gtk2hs-0.9.13-rc3.exe
12:14:36 <lambdabot> http://tinyurl.com/6c8huj
12:14:58 <dcoutts> pgavin: ok, I'll try it when I'm in the office tomorrow.
12:15:04 <pgavin> dcoutts: k :)
12:15:05 <suspect43> i had a difficult choice a month ago between spending my savings on an X360 (GTA IV!) or saving more for a new guitar. gah. guitar prices go up, tech prices go down. chicks dig guitars :)
12:15:31 <lament> what kind of guitar?
12:15:43 <sw17ch> suspect43: ... my brother does all that stuff too... i can't even coerce the things to make a nice noise
12:15:44 <pgavin> suspect43: get rock band, you can have both :)
12:16:04 <paolino> sw17ch: 38, but here we have had fascists
12:16:10 <suspect43> i think not :)
12:16:39 <suspect43> saving up for a jackson RR -- but might change in the shop. quality varies, especially here
12:16:52 <sw17ch> where is "here" ?
12:17:20 <Tordek> what's wrong with this? countCopies :: Int -> [Int] -> Int ; countCopies n a = length . filter (==n) a
12:17:26 <paolino> well I'm not japanese
12:17:30 <mauke> Tordek: .
12:17:40 <vixey> :t length . filter (==?n) ?a
12:17:41 <lambdabot> Not in scope: `==?'
12:17:48 <vixey> :t length (filter (== ?n) ?a)
12:17:49 <lambdabot> forall a. (?a::[a], Eq a, ?n::a) => Int
12:17:56 <lament> suspect43: looks pointy
12:17:57 <vixey> > (+1) . 3
12:17:58 <lambdabot>   add an instance declaration for (Num (f a))
12:18:01 <vixey> > (+1) (3)
12:18:02 <lambdabot>  4
12:18:05 <suspect43> east of new delhi, india. which means LOTS of guitarists around to play with :)
12:18:09 <mauke> haddock--
12:18:11 <vixey> Tordek: does that help?
12:18:18 <suspect43> SOUNDS pointy too :)
12:18:24 <lament> suspect43: will that guitar make you sound better? :)
12:18:29 <mauke> haddock--
12:18:34 <Tordek> it could, if I had any idea what it meant ;P
12:18:46 <vixey> Tordek: What is it that you don't understand?
12:19:10 <Tordek> what is wrong about the .?
12:19:13 <suspect43> most probably. my current guitar makes me go through kludgy workarounds on some notes, doesn't bend nice, goes out of tune, etc.
12:19:27 <vixey> Tordek: it doesn't mean anything
12:19:34 <vixey> > (+1) . 3
12:19:35 <lambdabot>   add an instance declaration for (Num (f a))
12:19:38 <rwbarton> Tordek: . composes functions.  You just want to apply 'length' to 'filter (==n) a'
12:19:45 <vixey> 3 isn't a function
12:19:52 <rwbarton> You could also write  (length . filter (==n)) a, if you wanted
12:20:04 <vixey> (f . g) x = f (g x)
12:20:05 <Tordek> which is more confusing since a couple of lines above that I have practically the same, and it works
12:20:18 <Tordek> comparar a d = length . filter (==True) $ zipWith (>) a d
12:20:28 <vixey> there's a $ there
12:20:34 <vixey> that makes it different
12:20:49 <mauke> Tordek: that's filter (== True), not filter (== n) a
12:21:02 <mauke> different number of arguments
12:21:10 <Tordek> so...
12:21:11 <rwbarton> Tordek: So here, you could write  length . filter (==n) $ a
12:21:20 <Tordek> $ is like a closing parentheses?
12:21:26 <vixey> not really
12:21:29 <mauke> f $ x is like (f) (x)
12:21:34 <vixey> since there is no open paranthesis
12:21:52 <suspect43> is there a good article with basic algos (graph traversal, djikstra, etc.) in haskell? that should get me up and running
12:21:52 <rwbarton> $ has very low precendence, while function application has very high precedence
12:22:16 <Tordek> ah, mauke makes it clearer, I thought f $ x was f (x)
12:22:31 <vixey> f $ x = f x
12:22:58 <Tordek> so f g $ y would be (f g) y, explaining the parentheses above
12:23:08 <Tordek> right
12:23:09 <Tordek> ?
12:23:32 <mauke> yes
12:23:55 <Tordek> thanks :)
12:24:00 <Deewiant> which is the same as f g y
12:26:10 <suspect43> qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs) .. is this kind of thing also fast-to-run (as well as being fast-to-type :))?
12:27:12 <mauke> there are probably better algorithms
12:27:34 <mauke> it seems to have the right time complexity, though
12:27:39 <suspect43> oh wait. it says it's naive on the same page. sorry :)
12:27:43 <rwbarton> suspect43: It will be within a constant factor of how fast you expect it to be :)  It will do a lot of allocation.
12:28:43 <suspect43> rwbarton: well, that just says quicksort will always be O(nlogn) :)
12:28:57 <vixey> suspect: it still sorts a list
12:28:59 <suspect43> but i get your point.
12:29:02 <vixey> @src sorc
12:29:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:29:05 <vixey> @src sort
12:29:05 <lambdabot> sort = sortBy compare
12:29:08 <vixey> this is a better one though
12:29:10 <vixey> @src sortBy
12:29:11 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:29:24 <vixey> foldr insert is simple
12:29:28 <Deewiant> @src insertBy
12:29:28 <lambdabot> insertBy _   x [] = [x]
12:29:29 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
12:29:30 <lambdabot>                                  GT -> y : insertBy cmp x ys'
12:29:32 <lambdabot>                                  _  -> x : ys
12:30:07 <vixey> insertBy :: ... -> Sorted [a] -> Sorted [a]
12:30:22 <suspect43> that looks like insertion sort
12:30:35 <suspect43> but i'm not familiar with the syntax much
12:30:37 <nolrai_> which is not very good, iirc
12:31:13 <rwbarton> suspect43: dijkstra's algorithm isn't really a good first haskell example, because it involves "state"
12:31:13 <suspect43> not on large or high-entropy datasets
12:31:36 <vixey> nothing is wrong with state
12:31:41 <nolrai_> but randomised qsort would require unsafeIO.
12:31:46 <suspect43> although fast quicksorts drop into insertion sort for low entropy end work ie. almost sorted stuff.
12:31:52 <Deewiant> or just the ST monad?
12:32:08 <vixey> if you're going to do practical programming you should not spend your time avoiding things like that
12:32:51 <suspect43> rwbarton: alright. what's a an algorithmically non-trivial first example, then?
12:32:51 <rwbarton> Right, it's a good second haskell example, to learn why there are things like the State monad.
12:32:59 <mib_u72ycfjx> hi all... is it possible to parameterize a type synonym with a specific class....
12:33:44 <mib_u72ycfjx> I mean type Model2Model model = (model -> model -> model)... restrict model from being a instance of AbstractModel class?
12:35:24 <suspect43> where did you learn it from?
12:36:02 <Gilly> how does the RWS monad work?
12:36:16 <vixey> :k RWS
12:36:18 <lambdabot> * -> * -> * -> * -> *
12:36:34 <rwbarton> suspect43: I actually don't recall.  I think I picked it up from my college roommate who was using it...
12:36:40 <vixey> @src RWS
12:36:40 <lambdabot> Source not found. I feel much better now.
12:36:54 <Deewiant> ?unmtl RWS a b c d
12:36:54 <lambdabot> a -> c -> (d, c, b)
12:37:00 <paolino> Gilly it gives you ask,tell,modify all together
12:37:06 <suspect43> :) lambdabot shares some sudo insults
12:37:11 <Gilly> so it's like reader, writer and state combined?
12:37:16 <vixey> huh
12:37:18 <vixey> I thought it was Gilly
12:37:25 <vixey> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-RWS-Lazy.html
12:37:26 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6g8dmr
12:37:28 <vixey> but it seems not
12:37:36 <vixey> maybe this is an optimization though
12:38:36 <paolino> it's a swiss knife to make memory explode
12:38:37 <nolrai_> does GHC 8.2 use cooperetive or pre-emptive scheduling?
12:40:04 <mauke> nolrai_: preemptive
12:40:08 <mauke> more or less
12:40:09 <Gilly> ok, i guess i get it :) the documentation on haddoc just was a bit terse
12:40:28 <nolrai_> thanks
12:42:44 <Baughn> Is there any way I can catch indexing exceptions in a lazy bytestring without also catching all other possible errors?
12:43:06 <MyCatVerbs> Baughn: dunno, maybe you could rethrow.
12:43:08 <Baughn> I can't really check against the length of a two terabyte bytestring.. although in theory it could just check the filesize
12:43:28 <cjb> is it fixed-width bytes?
12:43:34 <Baughn> It's a bytestring
12:43:39 <Baughn> Word8, period
12:43:42 <cjb> cool.
12:43:43 <mauke> all bytes have a fixed width
12:43:57 <cjb> yeah.  not all strings do, though.
12:44:23 <Baughn> I'm pretty sure haskell defines bytes to be 8 bits, and nobody really cares if it won't run on DSPs
12:44:35 <cjb> Baughn: I was thinking utf8
12:44:45 <cjb> but yes, bytestrings != strings, my mistake.
12:45:14 <Baughn> cjb: Oh. No.. the utf8-string package provides a couple bytestring wrappers, but the /bytestrings/ are just fast ways of handling binary blobs
12:45:24 <cjb> nod.
12:46:41 <rwbarton> suspect43: The knapsack problem makes a good, algorithmically non-trivial first Haskell program, I think.
12:47:25 <rwbarton> suspect43: But I don't know of any articles on it specifically.
12:47:27 <Tordek> I have a function that takes 2 ints and return an array of fractions (lets say f a b = [a/b]), but it gives me a "No instance for Fractional Int"
12:47:31 <suspect43> goody. dynamic programming would be a nice example. where can i find code?
12:47:40 <suspect43> ok. i'll look for some, it's a good idea.
12:47:56 <mauke> Tordek: yeah, Ints don't support /
12:48:17 <Tordek> how do I do that, then?
12:48:18 <Deewiant> Tordek: if you want fractions, use %
12:48:32 <Deewiant> > fromRational (3 % 4) :: Double
12:48:33 <mauke> Tordek: what type do you want?
12:48:34 <lambdabot>  0.75
12:48:36 <mauke> for the results, I mean
12:48:52 <chessguy> http://sequence.complete.org/node/263
12:48:53 <lambdabot> Title: Dynamic Programming in Haskell | The Haskell Sequence
12:48:54 <Baughn> Tordek: /, % and div all have different behaviour
12:49:03 <Tordek> i'm indifferent to fractions or reals, tho I think reals would be better
12:49:30 <Baughn> Tordek: / will give you a real (well, a floating-point approximation to a real), but you have to convert the inputs with fromIntegral first
12:49:34 <mauke> fromIntegral a / fromIntegral b
12:49:48 <mauke> Baughn: / will give you whatever the context demans
12:49:50 <mauke> +d
12:49:55 <rwbarton> chessguy: Yes, that is one way.  But you don't actually need arrays at all to solve knapsack
12:49:58 <Deewiant> hmm, maybe there should actually be instances for Fractional Int and Integer?
12:50:12 <mauke> Deewiant: er, why?
12:50:20 <Baughn> mauke: Point. I meant that in the "will give you, if you ask it to" sense, but..
12:50:20 <Deewiant> ?ty (/)
12:50:22 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:50:25 <EvilTerran> Deewiant, not if you want the semantics to make sense
12:50:30 <Deewiant> ah but crap
12:50:39 <Deewiant> I was thinking that you could do (1 / 2) :: Double
12:50:53 <mauke> > 1/2 :: Double
12:50:54 <lambdabot>  0.5
12:50:57 <mauke> ;-)
12:51:07 <lament> > 1%2 :: Double
12:51:09 <lambdabot>  Couldn't match expected type `Double'
12:51:10 <Deewiant> you know what I meant >_<
12:51:14 <mauke> yeah
12:51:15 <EvilTerran> class Div a where (/) :: a; instance Div (Int -> Int -> Rational) where (/) = (%); ...
12:51:16 <EvilTerran> >:]
12:51:16 <Tordek> I have map (/ fromIntegral length list) list
12:51:17 <Deewiant> > (1 :: Int) / (2 :: Int) :: Double
12:51:18 <lambdabot>  Couldn't match expected type `Double' against inferred type `Int'
12:51:20 <Baughn> > 1/2 :: Ratio Int
12:51:21 <lambdabot>  1%2
12:51:31 <Baughn> > 1/2 :: Int
12:51:32 <lambdabot>   add an instance declaration for (Fractional Int)
12:51:32 <lambdabot>     In the expression: 1 /...
12:51:42 <mauke> Tordek: fromIntegral only takes one argument
12:51:50 <BMeph> Isn't there a Knapsack entry on the HWiki? :)
12:51:57 <EvilTerran> instance Fractional a => Div (a -> a -> a) where (/) = (Prelude./) ...
12:52:16 <Tordek> mauke: i'm aware, I don't know the syntax at all yet
12:52:56 <EvilTerran> Tordek, function application (the space between consecutive identifiers, if you will) is left-associative
12:53:20 <EvilTerran> Tordek, this means you can leave off parentheses if a function has multiple (curried, as is the tradition in haskell) parameters
12:53:41 <EvilTerran> but you need to put parens in if you're passing the result of one function (given a parameter) to another
12:54:02 <EvilTerran> > f g x :: Expr
12:54:03 <lambdabot>  Add a type signature
12:54:09 <EvilTerran> > f x y :: Expr
12:54:10 <lambdabot>  f x y
12:54:15 <EvilTerran> > (f x) y :: Expr
12:54:16 <lambdabot>  f x y
12:54:53 <Baughn> Any horrible, horrible gotchas in using unsafePerformIO to catch a bytestring index exception in order to return Nothing instead of crashing?
12:54:59 <BMeph> http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell#Chapter_3:_Packing_the_knapsack_and_testing_it_with_class.2C_too_.28and_don.27t_forget_your_towel.21.29
12:55:01 <lambdabot> Title: Hitchhikers guide to Haskell - HaskellWiki, http://tinyurl.com/mg7d9
12:55:34 <Tordek> it may be ugly, but I got it to work: map (\x -> fromInteger x / fromInteger (length list)) list
12:56:03 <rwbarton> BMeph: Ah, so there is.
12:56:03 <EvilTerran> Tordek, you may want to store "fromInteger (length list)" in a variable outside the map, to save re-computing it every time
12:56:12 <Baughn> Tordek: It would probably be cleaner to use a ratio
12:56:20 <Baughn> -nal
12:56:27 <EvilTerran> also, you can write fromInteger (length xs) as genericLength xs
12:57:23 <EvilTerran> (you'll need to "import Data.List (genericLength)" first, i suspect)
13:00:48 <psyklops> Could someone help me drive a point into my head by labelling what the different parts of this statement are called?
13:00:51 <psyklops> data Forever a = AThing a (Forever a)
13:01:45 <psyklops> type name parameter operator constructor parameter (name parameter)
13:01:45 <Baughn> Forever is a type constructor; Forever Int is a type; AThing is a data constructor (but don't quote me on that)
13:02:05 <vincenz> Everything is a data constructor
13:02:15 <Baughn> Datatype constructor?
13:02:38 <psyklops> type constructor vs. data constructor, hmm
13:04:09 <psyklops> I called the "type constructor" the "name" of the type
13:04:29 <nolrai_> "Forever" is a type constuctor of kind * -> *, and AThing is a constructor (not type) of type a -> Forever a -> Forever a, right?
13:04:39 <Baughn> psyklops: It isn't that. Forever isn't a type at all
13:04:44 <orzo> hello
13:05:01 <orzo> I'm using ghc compiled modules from a c++ program
13:05:03 <Baughn> nolrai_: Yes
13:05:26 <Baughn> orzo: Not the other way around? Okay..
13:05:28 <Tordek> Baughn: how could I use a ratio?
13:05:34 <orzo> the c++ program has reference counting objects and when the first haskell-using object is created, it calls hs_init() and when the last is destroyed, it calls hs_exit().
13:05:35 <EvilTerran> (Forever) is a type expression, but not a type proper
13:06:13 <Baughn> Tordek: 2/3 :: Ratio Integer, or Ratio Int if you like.. or any other integral type
13:06:14 <orzo> but then a new haskell-using object may be created later causing it to cause hs_init()
13:06:23 <Baughn> Tordek: The specific interface (to decompose it) is in Data.Ratio
13:06:35 <orzo> unfortunately, a call out to a haskell function after that causes a segfaultt
13:06:43 <EvilTerran> much like (True + "false) is an expression, but is not a value
13:06:44 <Baughn> Tordek: And the point of using it would be that it's exact; it doesn't lose data. If you don't care about that..
13:06:50 <EvilTerran> er, (True + "false")
13:06:57 <orzo> is that a bug?  Or am I supposed to not call hs_init more than once even if i did hs_exit() before
13:07:12 <EvilTerran> ... that's poorly typed, and trying to use Forever as a type would be poorly kinded
13:07:26 <dons> orzo: hmm. you're really only supposed to call it once.
13:07:27 <Baughn> orzo: Right now, you must not call hs_init or hs_exit more than once each
13:07:46 <tobias_tud> hi there! is there a nice permutations functions that generated 2-perms and ignoring the order? example [1,2,3] = [[1,2],[1,3],[2,3]]
13:07:46 <dons> once on startup, once on shutdown
13:07:51 <Baughn> orzo: You could wrap those in another reference counter, I guess. And make it abort if you try to increment after it goes to 0 once
13:08:08 <EvilTerran> tobias_tud, there's nothing in the libraries - try defining it yourself?
13:08:11 <orzo> well that doesnt make sense with the program
13:08:30 <orzo> i do want to allow all haskell-using objects to go away
13:08:42 <Baughn> The RTS isn't set up to allow that, I'm afraid
13:08:44 <tobias_tud> EvilTerran: thanks
13:08:46 <EvilTerran> should have type [a] -> [[a]], for any a - no class constraints
13:08:57 <Baughn> orzo: hs_exit does do some cleanup, but it leaves most of it to the OS
13:09:10 <Baughn> orzo: Memory maps and such internal things, so.. another call to hs_init won't work
13:09:21 <dons> > replicate 2 [1,2,3]
13:09:22 <lambdabot>  [[1,2,3],[1,2,3]]
13:09:25 <dons> > replicateM 2 [1,2,3]
13:09:27 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
13:09:56 <Baughn> @src replicateM
13:09:56 <lambdabot> replicateM n x = sequence (replicate n x)
13:13:27 <RayNbow> http://www.engadget.com/2008/06/24/wiihds-homebrew-guide-hacking-doesnt-get-much-easier-than-thi/ <-- so... when will we see a Haskell interpreter being ported to the Wii? :p
13:13:27 <lambdabot> Title: WiiHD's homebrew guide: hacking doesn't get much easier than this - Engadget, http://tinyurl.com/4tedq6
13:15:15 <sw17ch> i want to see ghc ported to an ARM9
13:15:21 <sw17ch> then i can run it on gumstix hardware :)
13:15:23 <cjb> it doesn't run on arm?
13:15:27 <dons> ghc already runs on Arm, (e.g. nokia's)
13:15:30 <sw17ch> cjb: it very well might...
13:15:30 <sw17ch> :)
13:15:43 <cjb> sw17ch: sounds like you're set already.
13:15:48 <RayNbow> I do know that Hugs runs on the Nintendo DS
13:15:51 * sw17ch slinks away... after discovering, in fact, it already works
13:16:04 <sw17ch> has any one run it on gumstix hardware?
13:16:04 <dons> ghc on the iphone is nextt
13:16:05 <sw17ch> :)
13:16:16 <RayNbow> hmm
13:16:18 <sw17ch> dons: don't say that... i just committed to a 2yr contract with verizon
13:16:24 <RayNbow> is there a Haskell version voor Windows Mobile?
13:16:27 <Gilly> Hmm... i'd need a priority queue with changeKey operation but i've come to the impression that heaps usually only implemenet decreaseKey. Any wise advice on the subject?
13:16:32 <sw17ch> RayNbow, not that i know of
13:16:40 <sw17ch> but we know how good i am at knowing things
13:17:19 <RayNbow> Google tells me people have asked the same question before :p
13:19:34 <rwbarton> Gilly: seems like you could implement increaseKey using the heap-down operation (switch a vertex with the smaller of its two children)
13:19:49 <rwbarton> Gilly: but yeah, you never seem to hear about increaseKey, only decreaseKey.
13:21:22 <rwbarton> Gilly: You can think of deleteMin as increasing the value at the root to infinity, then re-heaping
13:22:14 <Gilly> well, in my program i'd load all the elements into the heap in the beginning and then start deleteMin'ing and at the same time change keys (until there are no more elements left)
13:22:31 <Gilly> not sure what would be the most efficient way to do this
13:26:07 <nolrai_> Increase key would either be time consumtive or only be able to buble down the sub heap the item is in.
13:26:19 <nolrai_> (Off the top of my head)
13:26:38 <rwbarton> Oh, I see--you might end up with an unbalanced "heap" in that case.
13:26:51 <Gilly> yea...
13:26:51 <rwbarton> or...
13:27:28 <rwbarton> Well, I could be convinced there is a problem, but I'm not sure what it is yet.
13:29:36 <rwbarton> What I said about deleteMin is wrong.
13:31:06 <RayNbow> > let f = flip (foldl1' seq .) (fix ((0 :) . (1 :) . (zipWith (+) =<< tail))) . take       in     f 10
13:31:08 <lambdabot>  34
13:31:24 <RayNbow> pl abuse :p
13:32:29 <Gilly> well, i got to go to sleep too - gotta think about this :) cu folks
13:40:36 <dons> ?users
13:40:36 <lambdabot> Maximum users seen in #haskell: 461, currently: 448 (97.2%), active: 14 (3.1%)
13:40:53 <EvilTerran> rwbarton, i think what you said about deleteMin was right, it's just that only works for the root item
13:42:25 * EvilTerran wonders if an asymptotically faster implementation of increaseKey exists than decreaseKey'ing everything else
13:42:26 <RayNbow> main = let f = flip (foldl1' seq .) (fix ((0 :) . (1 :) . (zipWith (+) =<< tail))) . take in  print . f . read . head =<< getArgs  -- can anyone make this shorter? :)
13:42:43 <EvilTerran> good lord!
13:42:53 <RayNbow> blame lambdabot's @pl feature :p
13:43:16 <luite> EvilTerran: he was showing me how to write 'l33t code' in haskell ;)
13:43:16 <vixey> lol
13:43:28 <EvilTerran> i hope you don't intend that to be readable
13:43:37 <sjanssen> RayNbow: what is the seq for?
13:43:41 <RayNbow> http://raynbow.pastebin.com/fa3b6280 <-- evolution can be seen here (most pointless on top)
13:44:09 <nolrai_> @unmtl StateT IO r
13:44:09 <lambdabot> err: `StateT IO r' is not applied to enough arguments, giving `/\A. IO -> r (A, IO)'
13:44:11 <Schmallon> I the slow speed of the function "floor :: Float -> Float" a known issue?
13:44:15 <nolrai_> @unmtl StateT s IO r
13:44:16 <lambdabot> s -> IO (r, s)
13:44:40 <RayNbow> sjanssen, the original definition of fibs was: fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
13:44:50 <RayNbow> if you take the 1 millionth element of it
13:45:02 <RayNbow> using genericIndex, you run out of stack space
13:45:17 <b_jonas> Schmallon: I think it converts to an Integer and back
13:45:33 <b_jonas> it's always bothered me
13:45:48 <EvilTerran> ... why does genericIndex stack overflow?
13:46:18 <b_jonas> I thoguht you could always write wrappers for the rounding functions in libc with the foreign interface, so I thought it's not such a big issue
13:46:31 <RayNbow> EvilTerran: because the 1 millionth element of the list refers to all previous elements of the list
13:46:31 <Schmallon> that's what i just did
13:46:34 <RayNbow> so it's a huge expression
13:46:38 <b_jonas> what bothers me is not just speed, but possible bad results for some types of rounding
13:46:42 <EvilTerran> ah, yes, i see
13:47:07 <Schmallon> using the libc one makes it faster by several orders of magnitude
13:47:10 <EvilTerran> you need a value-strict list :)
13:47:18 <b_jonas> Schmallon: wow, that was fast
13:47:22 <RayNbow> oh, and to answer <EvilTerran> i hope you don't intend that to be readable <-- of course not, it's just for fun :p
13:47:47 <EvilTerran> data SList a = Nil' | !a :! Slist a
13:48:04 <b_jonas> I wonder if there's a library on hackage that readily wraps all of the c99 arithmetic functions
13:48:12 <Schmallon> According to the profiler, the function that took about 70% percent of all time before now takes less than 3
13:48:18 <EvilTerran> means you can just run down the spine without risk of such problems
13:48:23 <rwbarton> EvilTerran: Well, the problem is that when it gets down to the bottom, it might not be at the right of the bottom row.
13:48:32 <rwbarton> EvilTerran: So over time, the heap might become unbalanced
13:48:42 <EvilTerran> indeed
13:49:50 <RayNbow> EvilTerran: hmm, but then I also have to write a zipWith function for SList? :)
13:49:59 <EvilTerran> and things would go horribly wrong immediately if you were representing your heap with that mutable array implementation
13:50:17 <RayNbow> (then I might as well just write a recursive function with accumulators to compute the nth Fibonacci number)
13:50:49 <vixey> well my non-solution would be to just compute smaller numbers
13:50:59 <vixey> then you don't have to change your datastructures!
13:51:06 <EvilTerran> RayNbow, well, that or wait for Data.Stream.zipWith :: Stream s => (a -> b -> c) -> s a -> s b -> s c
13:51:15 <RayNbow> :p
13:52:41 <hackage> New hackage package: Vec 0.9.0
13:52:59 <EvilTerran> hackage: version
13:53:08 <EvilTerran> hm. don't talk much, does he?
13:54:33 <quicksilver> there is a zipWith function for traversable
13:54:40 <quicksilver> does Data.Stream implement traversable?
13:54:44 <EvilTerran> probably
13:55:05 <EvilTerran> you'd need to toStream and fromSream explicitly, though
13:55:08 <nolrai_> @Hoogle State s r -> IORef s -> IO r
13:55:08 <lambdabot> Maybe you meant: google hoogle
13:55:14 <nolrai_> @hoogle State s r -> IORef s -> IO r
13:55:15 <lambdabot> No matches, try a more general search
13:55:26 <nolrai_> @hoogle IORef s -> State s r -> IO r
13:55:27 <lambdabot> No matches, try a more general search
13:55:36 <nolrai_> @hoogle IORef -> State
13:55:37 <lambdabot> No matches, try a more general search
13:55:43 <nolrai_> @hoogle IORef State
13:55:43 <lambdabot> No matches, try a more general search
13:55:46 <quicksilver> nolrai_: there is no function.
13:55:58 <quicksilver> nolrai_: easy to write though.
13:56:00 <EvilTerran> ?type \m x -> runState m <$> readIORef x
13:56:02 <nolrai_> ok its easy to write
13:56:02 <lambdabot> Not in scope: `readIORef'
13:56:15 <quicksilver> and there's no need to permute the args, hoogle does that :)
13:56:36 <nolrai_> thats good.
13:58:27 <nolrai_> :t runState
13:58:28 <lambdabot> forall s a. State s a -> s -> (a, s)
13:58:30 <EvilTerran> that should be evalState, but the principle's the same
13:58:34 <EvilTerran> :t evalState
13:58:35 <lambdabot> forall s a. State s a -> s -> a
13:58:50 <EvilTerran> ?src evalState
13:58:50 <lambdabot> Source not found. I feel much better now.
13:59:22 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html#evalState <- pretty straightforward
13:59:23 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
13:59:55 <nolrai_> thanks All.
14:00:12 <quicksilver> it's almost a composition of atomicModifyIORef and runState
14:00:22 <quicksilver> but the parameters are not quite in the right order
14:00:40 <EvilTerran> ?hoogle atomicModifyIORef
14:00:40 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
14:00:50 <quicksilver> or, alternatively, modifyIORef doesn't have quite general enough a type.
14:00:54 <quicksilver> you can't quite win.
14:01:59 <EvilTerran> also, atomicModifyIORef would overwrite the value of the IORef with the final value of the state, and what i wrote didn't
14:02:16 <quicksilver> yes.
14:02:24 <quicksilver> but surely that is nolrai_'s intention.
14:02:41 <quicksilver> surely that is the point of searching for something using IORef s and not just s.
14:02:42 <EvilTerran> you make a good point. that hadn't occurred to me, which made the suggestion strike me as a little odd
14:03:02 <quicksilver> I frequently run state actions inside IORefs
14:03:05 <quicksilver> as it were.
14:06:50 <EvilTerran> ?type modifyIORef
14:06:52 <lambdabot> Not in scope: `modifyIORef'
14:06:57 <EvilTerran> ?hoogle modifyIORef
14:06:58 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
14:06:58 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
14:07:29 <quicksilver> it bothers me that modifyIORef and modifyMVar have different types.
14:08:36 <roconnor> atomicModifyIORef?
14:08:42 <quicksilver> all three types (including modifyMVar_) are sensible
14:08:54 <quicksilver> but you want all three for both (IORef/MVar) and consistently named.
14:09:13 <roconnor> @type modifyMVar
14:09:15 <lambdabot> Not in scope: `modifyMVar'
14:09:22 <roconnor> @hoogle modifyMVar
14:09:22 <lambdabot> Control.Concurrent.MVar.modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
14:09:22 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
14:10:09 <quicksilver> I often define the pure version "modifyMVarPure" which takes a plain (a->a)
14:10:24 <quicksilver> and sometimes I want the impure version of the IORef one
14:11:33 <roconnor> @pl \a f -> modifyMVar a (runKleisli (pure f))
14:11:34 <lambdabot> (. (runKleisli . pure)) . modifyMVar
14:11:41 <quicksilver> ;)
14:11:45 <quicksilver> yes. Nice.
14:12:09 <quicksilver> arrows might be a good way to look at all of those.
14:12:13 <roconnor> that was even more complicated than I expected
14:12:49 <roconnor> how did modifyMVar end up to the right of runKleisli?
14:13:00 <roconnor> @unpl (. (runKleisli . pure)) . modifyMVar
14:13:00 <lambdabot> (\ d j -> modifyMVar d (runKleisli (pure j)))
14:13:10 <roconnor> strange
14:15:43 <nolrai_> @pl \f a -> modifyMVar a (runKleisli (pure f))
14:15:43 <lambdabot> flip modifyMVar . runKleisli . pure
14:16:54 <roconnor> @unpl flip $ flip modifyMVar . runKleisli . pure
14:16:54 <lambdabot> (\ b c -> modifyMVar b (runKleisli (pure c)))
14:33:06 <vixey> Has anyone tried implementing module systems for Haskell?
14:33:37 <cjb> vixey: like what?  it already has an (admittedly bare) module system.
14:33:44 <quicksilver> I'm not aware of any serious efforts.
14:33:50 <quicksilver> there have been some proposals, including one by SPJ
14:34:02 <quicksilver> I guess the itch isn't quite bad enough to scratch though.
14:44:45 <travisbrady> are there any sort of equivalents in Haskell to mnesia/ets/dets in the Erlang world?
14:48:17 <fophillips> Is there a nicer way of writing <http://hpaste.org/8508>?
14:49:50 <telemach> yo, try this game: http://www.albinoblacksheep.com/games/bloxorz
14:49:59 <lambdabot> Title: Games &#187; Bloxorz
14:50:17 <telemach> oh, it's in the database....
14:51:34 <zachk> fophillips: I remember solving something like in java, I think I used state with swapping and you can get it down to like 4 compares
14:51:44 <dons> telemach: that's considered spam.
14:52:08 <dons> travisbrady: distributed databases? no. there are STM-based in-memory maps and so on.
14:52:16 <zachk> dons: is their a social channel for haskell?
14:52:25 <dons> zachk: yeah, #haskell-blah
14:53:19 <geezusfreeek> fophillips: well, to start with, if a > b and a < c then we can infer from that that b < c, so the guard is unnecessary
14:53:59 <travisbrady> dons: thank you
14:54:31 <dons> travisbrady: ?
14:54:52 <geezusfreeek> @pl between a b c = (a > b && a < c) || (a < b && a > c)
14:55:22 * geezusfreeek broke lambdabot?
14:55:37 <dons> ?bot
14:56:00 <geezusfreeek> not that i expected a sensical answer anyway
14:56:02 <dons> hmm., code.haskell.org isn't responding.
14:56:12 <TomMD> It seems like there has been less chatter in here since cabal became popular - its now too easy to build a library and get instant publication/gratification.
14:56:39 <travisbrady> dons: you answered me re: mnesia
14:56:44 <dons> TomMD: so hmm, people are off writing libraries instead?
14:57:02 <travisbrady> an erlang person was asking me earlier the equivalents in Haskell-land and I had no idea
14:57:02 <dons> TomMD: or the newbies aren't having trouble doing things, except build cabal-install ?
14:57:57 <Tordek> is there a trace function or macro or something, that could autoprint calls made to a function?
14:58:05 <geezusfreeek> fophillips: you should totally go with between = ap (ap . (liftM2 (||) .) . ap (flip . (((.) . (&&)) .) . (>)) (<)) (ap (flip . (((.) . (&&)) .) . (<)) (>))
14:58:09 <geezusfreeek> it makes perfect sense
14:58:10 <dons> travisbrady: remember that erlang's targetting distributed systems, while ghc's targetting shared memory. so ghc's equivalent is an in-heap transactional structure, like an STM Map
14:58:25 <Baughn> Tordek: Debug.Trace, assuming you understand the evaluation model
14:58:48 <fophillips> geezusfreeek: I’ll have to benchmark it.
14:58:55 <geezusfreeek> fophillips: it was a joke
14:59:01 <fophillips> As was mine.
14:59:03 <vixey> x `between` (a,b) = min [a,b] <= x && x <= max [a,b]
14:59:10 <zachk> geezusfreeek: would that work correctly?
14:59:25 <geezusfreeek> zachk: i didn't test it, but maybe :)
14:59:29 <geezusfreeek> time to go home
14:59:43 <zachk> vixey: whats <= mean
14:59:50 <fophillips> Guess.
14:59:54 <Baughn> zachk: I doubt ghc is smart enough to fuse the two loops, though
14:59:55 <TomMD> dons: Oh, hi!  Sorry, I was off writing a library...
15:00:03 <Baughn> ..would be interesting if it is
15:00:12 <lambdabot> between = ap (ap . (liftM2 (||) .) . ap (flip . (((.) . (&&)) .) . (>)) (<)) (ap (flip . (((.) . (&&)) .) . (<)) (>))
15:00:12 <lambdabot> :)
15:00:18 <mauke> :t inRange
15:00:21 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
15:00:24 <psyklops> Is that lessthan or equal?
15:00:31 <vixey> ?report
15:00:32 <lambdabot> ()
15:00:35 <vixey> @report
15:00:36 <lambdabot> ()
15:00:39 <vixey> ?where report
15:00:39 <lambdabot> http://www.haskell.org/onlinereport/
15:00:39 <dons> TomMD: i note that audreyt's publishing pugs via cabal install now, so there's something to it.
15:01:03 <vixey> zachk: http://www.haskell.org/onlinereport/standard-prelude.html#$tOrd
15:01:04 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
15:01:05 <TomMD> Yes, I already installed it, though I don't actually have a use for pugs, I just had to have it.
15:01:36 <psyklops> Hm... the code pasting has calmed down tonight. I was using code pasted in this channel to judge my haskell readiness.
15:01:46 <psyklops> If I see an operator I don't understand, I am not ready
15:02:06 <vixey> not ready for what?
15:02:18 <psyklops> ready to understand, ready to create
15:02:21 <Baughn> psyklops: http://hpaste.org/8503 <-- Spot the stack overflow
15:02:30 <vixey> what?
15:03:02 <psyklops> s/I am not ready/I have not finished learning Haskell/
15:03:17 <psyklops> Of course, nobody has ever finished learning haskell
15:03:30 <psyklops> ... s/learning Haskell/reading tutorials/
15:04:52 <Saizan_> Baughn: count+1
15:05:39 <vixey> psyklops: There's no reason you shouldn't be able to write anything you want in haskell right now
15:05:39 <Baughn> Saizan_: Only if it somehow manages to extract over half a million articles per second. Well spotted, but that's not it
15:06:09 <psyklops> I want to make sure I don't start bad habits by not knowing the way things are done in haskell
15:06:22 <vixey> bad habits don't matter
15:06:23 <psyklops> like immediately doing  main = do
15:06:29 <psyklops> and then writing it like C
15:06:34 <dons> psyklops: are you using hoogle online to learn the functions?
15:06:41 <psyklops> not yet
15:06:42 <vixey> if you do something you will either never find out it's a problem or you'll fix it when you need to
15:06:43 <dons> ?hoogle +++
15:06:44 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
15:06:44 <lambdabot> Text.ParserCombinators.ReadP.(+++) :: ReadP a -> ReadP a -> ReadP a
15:06:44 <lambdabot> Text.ParserCombinators.ReadPrec.(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
15:07:08 <psyklops> is there an interface to that outside of this channel?
15:07:26 <TomMD> @where hoogle
15:07:26 <lambdabot> http://haskell.org/hoogle
15:08:04 <psyklops> yet another firefox keyword for constant use :)
15:08:13 <TomMD> psyklops: Note that you can use hoogle in GHCi as well.
15:08:25 <Baughn> psyklops: Or you can install the package and use it from the CLI
15:08:49 <TomMD> Though it is in the form of a command (requiring a ':') instead of a function.
15:10:07 <TomMD> There was a slick hoogle like search, but I can't remember what or where.  I think it was named as a take-off of Yahoo.  Anyone remember?
15:11:31 <TomMD> Never mind, I found it: http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:11:32 <lambdabot> Title: Hayoo!
15:11:37 <TomMD> @where hayoo
15:11:37 <lambdabot> I know nothing about hayoo.
15:11:48 <TomMD> @where+ hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:11:49 <lambdabot> Okay.
15:11:54 <TomMD> @where+ hayoo! http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:11:55 <lambdabot> I will never forget.
15:12:25 <mar77a> @where vagina
15:12:26 <lambdabot> I know nothing about vagina.
15:12:29 <mar77a> i knew it
15:13:07 <TomMD> Lambdabot is fairly pure, at least when the vixen plug-in isn't loaded.
15:13:29 <lament> @seen cock
15:13:29 <lambdabot> I haven't seen cock.
15:13:40 <mar77a> so that's what you mean with haskell programs being pure
15:13:53 <mapreduce> @faq porn
15:13:53 <lambdabot> The answer is: Yes! Haskell can do that.
15:14:09 <Saizan_> Baughn: uhm i can't see the stack overflow, what was it? something related to haxml?
15:14:26 <Baughn> Saizan_: I have no idea. I'm running it with -xc now, hoping to get something useful
15:15:19 <Baughn> Saizan_: The (+1) thing /might/ be it, except it's normally handling only a couple of hundred articles per second. It'd take over half a million to break the stack, so..
15:16:56 <Saizan_> ah, it sounded like you already figured it out :)
15:17:43 <psyklops> I started by highlighting all <-
15:18:00 <Baughn> Nope. I replaced it with a bytestring-based version that doesn't really parse xml, takes an awful O(n) shortcut on string matching (safe, though. :P) and runs about fifty times faster. :D
15:18:02 <psyklops> I'm really not the one to find these things though, I haven't typed a single line of haskell yet
15:18:46 <Baughn> No need to get fancy on searching for a string when your needle, being an xml tag, /can't/ overlap itself
15:20:12 <Baughn> psyklops: Space leaks are one thing, but stack overflows are invariably caused by building up giant chains of thunks that have to be evaluated strictly
15:20:37 <Baughn> The (1 + (1 + (1 + ... chain would actually be a good possibility, if it wasn't far too slow for me to believe that..
15:20:54 <Baughn> (If it turns out to /be/ the cause, I'm going to slap myself)
15:22:27 <hpaste>  (anonymous) annotated "Exp" with "(no title)" at http://hpaste.org/8510#a1
15:22:32 <dons> psyklops: time to start learning by doing! fire up your editor and write some programs
15:22:41 <dons> at a minimum, getArgs, and print them out.
15:22:53 <psyklops> I was about to start reading some haskell source of real apps
15:22:59 <dons> import System.Environment; main = do args <- getArgs ; print args
15:23:04 <psyklops> or maybe some "practical haskell" tutorials
15:23:04 <dons> ghc --make A.hs ; ./A
15:23:22 <psyklops> now I can just copy and paste that :-\
15:23:38 <dons> just type it in to your editor, compile the code, and run it, and you'll be underway
15:23:49 <psyklops> will do
15:24:18 <dons> constant daily practice, and writing Haskell will be as natural to you as your native tongue
15:24:30 <Tordek> is there an asvantage to writing a function as fixed point?
15:24:35 <Tordek> *advantage
15:24:36 <vixey> mblondin: yuck! :p
15:24:41 <dons> Tordek: it can be cleaner some times.
15:24:48 <Baughn> Tordek: Depending on the function, it can be cleaner
15:25:00 <Baughn> Like if you're mapping a fixed point mathematical function to haskell. :P
15:25:22 <psyklops> ./a.out ahaha hohoho
15:25:22 <psyklops> ["ahaha","hohoho"]
15:25:32 <hpaste>  dons pasted "psyklops, getting things done." at http://hpaste.org/8511
15:25:33 <dons> yay
15:25:43 <dons> there you go.
15:25:45 <Baughn> psyklops: Now try rewriting common unix utilities with interact
15:25:56 <psyklops> interact?
15:25:56 <Baughn> A surprising number are one-liners
15:25:59 <psyklops> ghci?
15:26:01 <Baughn> @type interact
15:26:03 <lambdabot> (String -> String) -> IO ()
15:26:15 <Baughn> Basically, interact embodifies the unix pipe
15:26:32 <Baughn> .."embodifies". >_<;
15:26:44 * vixey wonders if Larose is mblondin?
15:26:48 <psyklops> superflumous
15:26:57 <hpaste>  dons pasted "more stuff" at http://hpaste.org/8512
15:27:01 <dons> psyklops: ^
15:28:05 <psyklops> something I don't understand, the $
15:28:11 <zachk> psyklops: try writing a ghetto text editor
15:28:12 <psyklops> strangely haven't seen it in all the tuts
15:28:18 <zachk> that is probably his shell prompt
15:28:19 <Baughn> psyklops: foo $ bar baz === foo (bar baz)
15:28:19 <dons> its a small function that lets you avoid using lots of parenthesis
15:28:22 <dons> ?src ($)
15:28:22 <lambdabot> f $ x = f x
15:28:42 <dons> so, we can say:   f (g (h x))  -->   f . g . h $ x
15:28:50 <Baughn> psyklops: Think of it as a left paranthesis that closes off as far to the right as possible
15:29:07 <zachk> dons: cant you just say f $ g $ h $ x?
15:29:11 <dons> you could too
15:29:16 <Baughn> For the time being. ($ 2) is also valid, which is neat
15:29:18 <mapreduce> f . g . h x
15:29:29 <zachk> psyklops: I think of it as from the right to the left piping of inputs to outputs
15:29:32 <cjb> zachk: there's occasional argument that . is less "interrupting" to read
15:29:40 <cjb> so people sometimes prefer that where it can be used
15:29:42 <Peaker> psyklops, mainly used to save parens, as Baughn mentioned, but also as a way to pass function application as a function.  For example ($4) is a function that applies 4 to its argument(which is a function)
15:29:50 <dons> and hey, its a functional language, function composition should be cheap and common
15:30:05 <mapreduce> @check \f g h x -> f $ g $ h x == f . g . h x
15:30:20 <lambdabot>  thread killed
15:30:40 <Baughn> > map ($ 2) [const 1, (+3), (*42)]
15:30:41 <Peaker> mapreduce, prefix/funccall is always higher-precedence than infix (.)
15:30:42 <lambdabot>  [1,5,84]
15:31:04 <Baughn> > map (`id` 2) [const 1, (+3), (*42)]
15:31:05 <lambdabot>  [1,5,84]
15:31:13 <Baughn> @src id
15:31:13 <lambdabot> id x = x
15:31:33 <rwbarton> :t \f g h x -> f $ g $ h x == f . g . h x
15:31:35 <lambdabot> forall t b (f :: * -> *). (Eq (f Bool), Functor f) => (b -> Bool) -> (Bool -> b) -> (t -> f Bool) -> t -> Bool
15:31:59 <Baughn> psyklops: See the similarity? Though hopefully you won't see people using id where $ is clearer, or vice versa. The difference is in what syntax haskell allows, and fixity
15:32:09 <dons> Cale: 2 runplugs instances were going insane on code.
15:32:22 <dons> compiled without rlimits?
15:32:22 <psyklops> I see
15:32:45 <psyklops> can the space be removed?
15:32:50 <psyklops> $2
15:32:54 <dons> yeah
15:32:59 <psyklops> looks like "second argument" in bash-ese
15:33:01 <hpaste>  Tordek pasted "(no title)" at http://hpaste.org/8513
15:33:17 <mapreduce> @check \f g h x -> (f $ (g :: Integer -> Integer) $ h (x :: Integer)) == (f . g . h $ x)
15:33:19 <lambdabot>  OK, passed 500 tests.
15:33:29 <psyklops> nice even number of tests
15:33:56 <Tordek> how could I speed it up a bit? like, dynamic programming-ish
15:34:42 <rwbarton> :t let mono = \f g h x -> f $ g $ h x == f . g . h x in mono
15:34:44 <lambdabot> forall b t (f :: * -> *). (Eq (f Bool), Functor f) => (b -> Bool) -> (Bool -> b) -> (t -> f Bool) -> t -> Bool
15:34:48 <Tordek> (it analyzes an absolute victory % for a given number of attacking/defending armies in a game of risk)
15:35:18 <rwbarton> :t let mono = 3 in mono
15:35:19 <lambdabot> forall t. (Num t) => t
15:35:32 <Baughn> Tordek: I'd have to say.. start by studying statistics. YOu don't need fancy programming; you need fancy math.
15:35:56 <Baughn> And a little goes a long way, here
15:35:56 <Tordek> Baughn: if the point was getting the results, sure ;)
15:36:17 <mapreduce> > \f x -> f f x
15:36:18 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
15:36:18 <lambdabot>     ...
15:36:24 <mapreduce> darn infinite types
15:36:45 <Igloo> Tordek: I haven't looked at your code, but an easy way to do synamic programming is to recursively define the contents of an array, and then read off the cell that you want
15:36:55 <EvilTerran> > \f x -> f (f x)
15:36:56 <lambdabot>  Add a type signature
15:37:00 <EvilTerran> ?type \f x -> f (f x)
15:37:02 <lambdabot> forall t. (t -> t) -> t -> t
15:37:23 <Baughn> How strict is an UArray? Is it possible to build it from a list that's built by reading the array, assuming it isn't done out of order?
15:37:27 <Baughn> ..I should just check.
15:37:33 <EvilTerran> mapreduce, it's a property of the STLC that you can't pass a value as a parameter to itself
15:37:48 <mapreduce> I know :)
15:37:59 <mapreduce> It's a nice alternative to fix in lisp.
15:38:20 <Igloo> Tordek: i.e. something like    let arr = array ((0, maxDefenders), (0, maxAttackers)) [(i, j) = ... arr (i-1, j) ... | (i, j) <- <the array bounds except for the edge cases> ]
15:38:44 <Igloo> Tordek: Err, "arr ! (i-1, j)", not "arr (i-1, j)", sorry
15:38:50 <EvilTerran> and, unless you use typeclasses or datatypes (or rank-n types or such exotic extensions), the haskell type-system has the same restriction
15:39:02 <mapreduce> ((lambda (f x) (f f x)) (lambda (x) (< x 2) x (* x (f (1- x)))) 5) 'should come out at 120 iirc
15:39:16 <EvilTerran> i forget what simple typing + rank-1 polymorphism is called, though
15:39:22 <mapreduce> Is there an extension that lets the above work?
15:39:24 <vixey> it looks like a different language that haskell..........
15:39:39 <mapreduce> ..perhaps with a different syntax
15:39:49 <vixey> write a scheme interpreter
15:40:11 <vixey> ?go y combinator in haskell
15:40:12 <lambdabot> No Result Found.
15:40:17 <mapreduce> damn, that'd be fun.
15:40:38 <Baughn> Ah great. Nope, deadlocked.
15:40:51 <vixey> what's rank-1 polymorphism?
15:40:58 <vixey> isn't that STLC...
15:41:06 <Baughn> I was hoping I could do the C unboxed array dynamic programming thing. :/
15:41:19 <EvilTerran> vixey, AFAIK, there's no polymorphism in simple types. i may be wrong, though
15:41:54 <Tordek> (\f x -> f f x) (\x if x < 2: then: x else: x * f (x-1)) 5 ?
15:42:15 <EvilTerran> as, with rank-1 polymorphism, i think typing becomes too complicated for typechecking to be done as a single traversal
15:42:27 <EvilTerran> mapreduce, if you're willing to deal with the explicit unboxing, you can use something like data Fn a = Val a | In { out :: Fn a -> Fn a }
15:42:31 <mapreduce> \f x in the second lambda.
15:42:36 <mapreduce> Tordek: ^^
15:42:48 <Baughn> Is there any way I can tell GHC to let me access a partially dethunked array, just promising not to read anything it hasn't written?
15:43:08 <mapreduce> @src In
15:43:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:43:23 <Saizan_> vixey: rank1 is what haskell98 has, you can have forall only outside (->)
15:44:55 <Saizan_> forall a b. (a -> b) -> a -> b rank-1, forall b. (forall a. a -> b) -> b rank2
15:45:47 <rwbarton> Baughn: Maybe you can define an 'array' replacement using STUArray and unsafeNewArray_ that does what you want?
15:46:14 <rwbarton> Baughn: I'd like to have such a thing as well
15:46:25 <Baughn> rwbarton: That's a good idea. I'll try it
15:46:39 <Baughn> The mushroom cloud will be GHC blowing up
15:46:41 <thomashartman1> I'm trying to upload a package to hackage. cabal sdist gives me error "No 'build-type' specified". where do I specify this? cabal file?
15:47:54 <EvilTerran> actually, make that data Fn a = Val { getVal :: a } | Fn { (?) :: Fn a -> Fn a }; infixr 0 ?; then: fix f x = getVal (f' ? f' ? Val x) where f' = Fn (Val.f.getVal)
15:48:06 <Saizan_> thomashartman1: yes, and you should be using build-type: Simple if you're not using a custom Setup.hs
15:49:14 <thomashartman1> I Saizan: if I specify build-type: Simple in my cabal file I get another error.
15:49:29 <thomashartman1> Warning: happs-tutorial.cabal: Unknown fields: build-type (line 16)
15:49:29 <thomashartman1> Fields allowed in this section:
15:49:30 <thomashartman1> executable, main-is,...
15:50:00 <Baughn> thomashartman1: Probably need a newer Cabal
15:50:03 <thomashartman1> fwiw, I initiated the cabalization process using mk-cabal --init-project. is there a better way to do this?
15:50:04 <Saizan_> you've to put it in the first section, together with name etc..
15:50:05 <Baughn> Make that definitely
15:50:06 <dons> build-type goes in the top stanza
15:50:12 <dons> not inside the executable or library parts
15:50:17 <thomashartman1> oh I didn't realize there were sections/stanzas.
15:50:19 <Baughn> ..or you could be doing it wrong. Granted.
15:51:40 <thomashartman1> okay, cabal upload -c checks now.
15:52:25 <dons> so hands up if you'd like: cabal init
15:52:32 <dons> to intiialise a proper .cabal for your project
15:52:43 * Baughn raises hand
15:52:58 <Baughn> Having to look it up every time is getting annoying, and I don't do it often enough to remember
15:53:02 <dons> hmm
15:53:03 <thomashartman1> my hand goes up.
15:53:04 <dons> me too
15:53:18 <thomashartman1> this would do the same thing as mkcabal did right?
15:53:22 <thomashartman1> xcept that's out of date now.
15:53:26 <dons> yep, but using the new cabal syntax
15:53:27 * BMeph raises both hands
15:53:41 <Baughn> For bonus points, it could scan the directory tree for Main modules and such to try fleshing it out
15:53:43 * RayNbow hasn't used cabal yet in his life :p
15:54:06 <RayNbow> (well, creating cabal packages that is)
15:54:08 <Baughn> ..do that well enough, and you won't /need/ a .cabal file most of the time
15:54:28 <Baughn> To be honest, most of mine are totally predictable. Add the pwd as the package name, and..
15:54:40 <Baughn> *cwd
15:55:59 <roconnor> is submonad a real term, or something that my advisor made up? :)
15:56:10 <dons> i've never heard that, roconnor
15:56:18 <roconnor> A submonad would have something to do with having an injection from one monad to another.
15:56:24 <dons> but there's a lot i don't know, so who knows.
15:57:13 <Botje> submonads are like submarines
15:57:19 <Botje> you don't see them until they bomb you.
15:57:44 <RayNbow> Botje: unless you have a submonad-sonar?
15:58:05 * BMeph scans the bay with binoculars, looking for ballistic submonads
15:58:06 <mmorrow> has anyone been success getting QuasiQuotes to work in 6.8.3 with http://community.haskell.org/~audreyt/qq-6.8.3.diff  ??? (they're already in 6.9 since january)
15:58:07 <RayNbow> roconnor: Google gives a few hits when searching for submonad...
15:58:08 <Botje> good point :)
15:58:12 <RayNbow> the question is, can we trust Google? :p
15:58:23 <mmorrow> s/success/successful/
15:58:29 * EvilTerran launches his cosubmonads
15:58:33 <thomashartman1> schweet. I uploaded my first package to hackage ;)
15:58:37 <thomashartman1> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happs-tutorial
15:58:38 <Botje> oh noes
15:58:39 <dons> thomashartman1++
15:58:39 <lambdabot> http://tinyurl.com/6repg4
15:58:44 <Botje> quick, deploy the cosubmonad shield!
15:59:08 <Botje> (is a cosubmarine a submarine-shaped mass of water?)
15:59:09 <roconnor> is that the same as a supcomonad?
15:59:58 <mapreduce> Oh, did I join #cobol?
16:00:40 <EvilTerran> ... if we can agree on a definition for sub(co)monad, and have some mapping between monads and comonads, we can probably work that one out
16:00:43 <Botje> nah, they only get to play with regular missiles
16:01:06 <mmorrow> ok i'm gonna get 6.8.3 and apply that diff and put the result on the web somewhere
16:02:30 <mmorrow> does anyone know where a darcs repo of ghc-6.8.3 is?
16:02:40 <mmorrow> (i'm currently searching)
16:03:05 <Botje> i'd wager you pull the main darcs repo but add --tag=6.8.3 ?
16:03:14 <mmorrow> ah, thanks
16:03:25 <Botje> (note: i have no idea of the GHC people did that)
16:03:39 <Botje> you're probably better off getting the tarball, no?
16:04:25 <mmorrow> hmm, on second thought that might be weird since i want to add audreyt's QQ patch to 6.8.3 so it's in a nice package for people that want to use QuasiQuotes but aren't ready to use 6.9
16:04:39 <mmorrow> Botje: yeah, i think that's what i'll do :)
16:05:12 <thomashartman1> hmmm, in my source directory I can do sudo cabal install and my project installs. however, when I do sudo cabal install happs-tutorial (which I just uploaded to hackage) I get error src/Main.hs:8:7:
16:05:13 <thomashartman1>     Could not find module `Misc':
16:05:27 <thomashartman1> shouldn't either both work or neither? what do I do now?
16:05:39 <mmorrow> btw, check out http://code.haskell.org/~morrow/code/haskell/regexqq/ !!
16:05:39 <lambdabot> Title: Index of /~morrow/code/haskell/regexqq
16:05:53 <mmorrow> ghci> :m + Text.Regex.PCRE.QQ
16:05:53 <mmorrow> ghci> [$rx|([aeiou]).*(er|ing|tion)([\.,!\?]*)$|] "helloing.!?!?!"
16:05:53 <mmorrow> Just ["elloing.!?!?!","e","ing",".!?!?!"]
16:05:57 <mmorrow> ghci> tail `fmap` [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
16:05:57 <mmorrow> Just ["-","3","141592653589793"]
16:06:05 <mmorrow> </spam>
16:06:13 <vixey> huh
16:06:20 <vixey> why use qq?
16:06:36 <vixey> oh it saves escaping \'s ?
16:06:37 <mmorrow> because then using regexes become trivial
16:06:48 <byorgey> mmorrow: wow, neat =)
16:07:04 <mmorrow> that link is to a cabaled/darcs repo
16:07:07 <vixey> ohh I see how it is
16:07:08 <mmorrow> check it out!
16:07:09 <vixey> cool
16:07:27 <Peaker> In conal's Reactive library, how does one implement: "applyInPlace :: Event (a->a) -> Behavior a -> Behavior a" ?
16:07:33 <rwbarton> Can you bind variables with the result of a regex pattern match?
16:07:52 <byorgey> thomashartman1: hold on, I will test if it installs correctly for me
16:08:00 <mmorrow> rwbarton: it would depend on how the quasiquoter qas coded, currently no, but this could be added
16:08:07 <mmorrow> s/qas/was/
16:08:14 <luite> qoded ;)
16:08:17 <thomashartman1> thanks byorgey
16:08:20 <byorgey> cabal: cannot configure happs-tutorial-0.0. It requires containers >=0.1.0.2
16:08:20 <byorgey> There is no available version of containers that satisfies >=0.1.0.2
16:08:24 <byorgey> thomashartman1: ^^^
16:08:29 <mmorrow> rwbarton: check out the code and see the possibilities!
16:08:40 <byorgey> it needs some special non-released version of containers?
16:08:44 <thomashartman1> byorgey: cabal --version
16:08:44 <thomashartman1> cabal-install version 0.4.9
16:08:44 <thomashartman1> using version 1.3.12 of the Cabal library
16:08:45 <thomashartman1> you?
16:09:05 <thomashartman1> I think there was recently some improvements to cabal that did better dependency chasing.
16:09:11 <thomashartman1> I have a pretty recent version.
16:09:26 <mmorrow> [$rx|^([+-])?([0-9]+)\.([0-9]+)|]   ====> this evaluates to a (String -> Maybe [String])
16:09:27 <byorgey> thomashartman1: I have cabal-install 0.5 and Cabal 1.4
16:09:32 <Peaker> does Yampa require the user to use explicit "thread forking" functions like conal's Reactive library?
16:09:44 <thomashartman1> and no, it doesn't need any special non-released version of containers.
16:09:46 <EvilTerran> rwbarton, the quasiquote is translated into a call to a (String -> Q Exp), IIRC, with the Exp spliced in at compile-time
16:09:56 <byorgey> thomashartman1: what version of ghc do you have?
16:10:11 <byorgey> the newest version of containers on hackage is 0.1.0.1
16:10:13 <thomashartman1> byorgey: 8.2.3
16:10:20 <Peaker> hmm, not a lot of FRP hackers on tonight? :)
16:10:21 <byorgey> !?!
16:10:23 <mmorrow> case myStringRegex of [$rx|.+|] -> "you're nuts!" ; [$rx|asd[fgh]|] -> "you're still nuts!"
16:10:23 <thomashartman1> I mean...
16:10:25 <byorgey> wow!
16:10:35 <thomashartman1> the one that ends in 3 :)
16:10:35 <byorgey> do you have a time-travel machine? ;)
16:10:44 <thomashartman1> 6.8.3
16:10:44 <byorgey> thomashartman1: ok, that's probably why then
16:10:53 <thomashartman1> what's the explanation?
16:11:05 <EvilTerran> I suspect it could return a Q [Dec] or something too, depending on context or whatever
16:11:17 <byorgey> thomashartman1: apparently, containers-0.1.0.2 is bundled with ghc-6.8.3, but isn't on hackage.
16:11:53 <Botje> with the GSoC GHC plugin thing, could you add new syntax to haskell?
16:11:53 <thomashartman1> hm, so should I do containers <= 0.1.0.1 ?
16:11:58 <byorgey> thomashartman1: does your happs-tutorial package *really* require containers-0.1.0.2?
16:12:03 <thomashartman1> byorgey: no.
16:12:13 <byorgey> thomashartman1: you can probably just say 'containers'
16:12:19 <thomashartman1> cool I'll try that.
16:12:29 <byorgey> if you don't specify a version cabal is free to choose whatever version is available
16:12:35 <mmorrow> Botje: i'm not sure, but you could most certainly do so with QuasiQuotes!
16:13:00 <mmorrow> i put the newest template-haskell docs here: http://code.haskell.org/~morrow/code/haskell/misc/template-haskell-HEAD_080623/
16:13:01 <lambdabot> http://tinyurl.com/5qyynk
16:13:02 <thomashartman1> I just filled in the missing deps as cabal reported errors, "such and so is hidden in package foo"
16:13:15 <mmorrow> in particular, see: http://code.haskell.org/~morrow/code/hahttp://code.haskell.org/~morrow/code/haskell/misc/template-haskell-HEAD_080623/Language-Haskell-TH-Quote.htmlskell/misc/template-haskell-HEAD_080623/Language-Haskell-TH-Quote.html
16:13:16 <lambdabot> http://tinyurl.com/5h3xhz
16:13:22 <Botje> heheh
16:13:22 <byorgey> thomashartman1: sure, that's fine
16:13:32 <Botje> so much to hack on, so little time :)
16:13:34 <byorgey> thomashartman1: but no need to overspecify the exact version requirements
16:13:42 <mmorrow> Botje: totally
16:15:10 <thomashartman1> when I specify base > 3 is that the same thing as saying you need ghc 6.8.3 ?
16:15:37 <mmorrow> for the curious:
16:15:38 <mmorrow> data QuasiQuoter = QuasiQuoter {
16:15:38 <mmorrow> quoteExp :: String -> Q Exp
16:15:38 <mmorrow> quotePat :: String -> Q Pat
16:15:38 <mmorrow> }
16:16:27 <mmorrow> so, this means that the identity QuasiQuoter is:
16:16:36 <mmorrow> idQQ = QuasiQuoter (litE . stringL) (litP . stringL)
16:16:43 <mmorrow> then, you can do:
16:17:08 <mmorrow> [$idQQ|asdfadsf  this  is a """"""""""""""""""""""""""""string|]
16:17:19 <mmorrow> and you get a string
16:17:20 <byorgey> thomashartman1: I think so, yes
16:17:25 <Botje> *glop*
16:17:34 <byorgey> thomashartman1: base 3.0.0.0 is the version that comes with 6.8.2
16:17:53 <byorgey> thomashartman1: you probably want to say base >= 3
16:18:07 <vixey> this is cool
16:19:22 <byorgey> mmorrow: wow, very cool =)
16:19:24 <thomashartman1> byorgey: are there any other "you gottas" for cabal version numbers or is that pretty much the only one?
16:19:39 <byorgey> thomashartman1: well, it depends =)
16:19:44 <thomashartman1> yeah yeah. :)
16:19:49 <mmorrow> and you can do   case "asdf" of [$idQQ|not " asdf|] -> 0 ; [$idQQ|asdf|] -> 1
16:19:50 <byorgey> thomashartman1: but try it with just that and see what happens
16:19:53 <thomashartman1> i won't torture you. you've been very helpful.
16:19:55 <mmorrow> byorgey: totally cool!
16:20:13 <byorgey> mmorrow: so what are the two different functions 'quoteExp' and 'quotePat' for?
16:20:36 <EvilTerran> one for when it's used in Exp context and one for Pat context, i gues
16:20:45 <byorgey> oh! of course
16:20:51 <byorgey> ok, that makes sense
16:21:08 <vixey> idQQ is the pat context?
16:21:25 <mmorrow> byorgey: they are how ghc takes the given string inside the quasiquotes and translates them (depending on the context in which the qq appears) into a template-haskell ExpP or ExpQ which it then knows how to evaluate
16:21:30 <Peaker> iddqd?
16:21:42 <vixey> ohhh I see
16:22:04 <mmorrow> vixey: yes, which function is used (quoteExp or quotePat) depends on the context in which the quasiquote [$idQQ|...|] appears
16:22:09 <mmorrow> so cool
16:23:14 <mmorrow> so the ExpQ returned by the quoteExp in a particular QuasiQuoter can evaluate to *any* type of expression
16:23:42 <mmorrow> in the rx QuasiQuoter, it evals to a (String -> Maybe [String]), and in idQQ it evals to a String
16:24:41 <mmorrow> the PatQ from quotePat in rx evals to a literal string pattern because this is the only thing that i could see making sense of the top of my head
16:24:53 <mmorrow> but it could do arbitrarily crazy things
16:25:20 <Botje> woah
16:25:26 <mmorrow> yes
16:25:28 <Botje> 60 lines of imports!
16:25:32 <mmorrow> haha, oh
16:25:54 <rwbarton> It would be awesome to have  > yearOfDate [$rx|^(year@([0-9]{4}))-[0-9]{2}-[0-9]{2}|] = year
16:26:06 <rwbarton> where I've made up some syntax for binding variables inside regexps
16:26:11 <rwbarton> which probably isn't a very good one
16:26:20 <mmorrow> rwbarton: nice. that should be the next quasiquoter package...dates!
16:26:47 <rwbarton> mmorrow: Yes, it should
16:26:51 <mmorrow> rwbarton: i think it would be useful, it could wrap a date parser so the programmer can enter it however
16:27:41 <mmorrow> and whether it's a valid date would still be a compile-time check
16:28:19 <mmorrow> just like an invalid regex in the rx qqer stops compilation with an error
16:29:00 <mmorrow> (i believe that's so, but haven't tested it yet)
16:29:12 <mmorrow> just in ghci
16:31:02 <Peaker> I am reading in a paper that Haskell compilers cannot recognize a function's call to itself (with the same arguments), (allowing to share computations). is this true?
16:31:42 <thomashartman1> How do I tell cabal to bundle a subdirectory with the distribution? I tried Hs-source-dirs:      src in the cabal file but it's not getting bundled.
16:31:47 <mmorrow> http://code.haskell.org/~morrow/code/haskell/regexqq/EXAMPLES
16:32:01 <Peaker> e.g:  f = \a b -> blah (f a b)  as identical to:   f = let x = blah x in x
16:32:01 <vixey> Peaker: You can memoize in other ways
16:32:30 <Peaker> vixey, its a paper about space leaks introduced by early implementations of FRP - and I'm wondering why that kind o thing is not optimized automatically
16:32:38 <vixey> that's not identical
16:32:51 <vixey> oh it could be actualy...
16:33:03 <dcoutts> thomashartman1: it's not recursive, you have to list the files you want bundled
16:33:03 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
16:34:06 <thomashartman1> oh bother. I'd rather just not use a subdirectory.
16:34:21 <Peaker> @pl f a b = blah (f a b)
16:34:21 <lambdabot> f = fix ((blah .) .)
16:34:26 <mmorrow> http://code.haskell.org/~morrow/code/haskell/regexqq/RegexQQ.html
16:34:52 <Peaker> @pl f = let x = blah x in x
16:34:52 <lambdabot> f = fix blah
16:35:14 <vixey> :t ((?blah .) .)
16:35:16 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, ?blah::a -> b) => f1 (f a) -> f1 (f b)
16:35:30 <vixey> yeah they can be the same
16:36:47 <thomashartman1> ah, I see, with cabal you have to specify each file of source always.
16:36:55 <thomashartman1> whether it's in a subdirectory or not.
16:37:16 <dons> for libraries, yes.
16:37:16 <Peaker> ((blah .) .) is somehow the same as blah? How come?
16:37:30 <dons> you can choose which ones to import,and which to export, but  you must list all that might be needed
16:37:31 <dcoutts> thomashartman1: right. See also http://hackage.haskell.org/trac/hackage/ticket/213
16:37:34 <lambdabot> Title: #213 (allow wildcards in data-files or extra-source-files?) - Hackage - Trac
16:37:39 <thomashartman1> what about for executables that have dependencies on modules in the distribution?
16:37:47 <thomashartman1> which is what I'm doing
16:37:52 <dons> they'll be built into little static binaries
16:38:06 <dons> so you just say:   executable foo \n main-is: Main.hs
16:38:13 <Staz> @src (++)
16:38:13 <lambdabot> []     ++ ys = ys
16:38:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:38:13 <lambdabot> -- OR
16:38:13 <lambdabot> xs ++ ys = foldr (:) ys xs
16:38:13 <lambdabot> -- In lambdabot, this is generalised to:
16:38:15 <dons> dcoutts: btw, does main-is: default to Main.hs ?
16:38:15 <lambdabot> (++) = mappend
16:38:53 <dcoutts> dons: there is no default
16:41:11 <vixey> why are foldr and others in the order they are?
16:41:17 <ziman> :t fmap
16:41:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:41:25 <vixey> particularly the actual object is last
16:41:34 <dons> so you can partially apply things
16:41:44 <Botje> vixey: so you can have foldr (:) [] === id
16:41:59 <vixey> I thought it was some category theory thing..
16:42:16 <Botje> nah, just that
16:42:51 <Botje> okay
16:42:59 <Botje> time for bed!
16:43:55 <byorgey> vixey: if you think of foldr as a list algebra, the order makes sense
16:44:00 <Saizan_> cata :: Functor f => (f a -> a) -> Mu f -> a, so there's not much to choose there :)
16:44:17 <byorgey> @type foldr
16:44:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:45:23 <byorgey> vixey: but as you may have read in that thread on haskell-cafe, other orders for the arguments bring out other ways of thinking of foldr
16:45:43 <byorgey> e.g. (a -> (b -> b)) -> ([a] -> (b -> b))
16:45:52 <vixey> I haven't seen this
16:46:33 <byorgey> vixey: http://article.gmane.org/gmane.comp.lang.haskell.cafe/41607
16:46:34 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:47:10 <byorgey> well, the whole thread is here: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/41607
16:47:11 <lambdabot> Title: Gmane Loom
16:48:46 <vixey> huh that's cool
16:52:43 <hackage> New hackage package: happs-tutorial 0.0
16:54:19 <byorgey> dons: is the hackage bot code somewhere?
16:57:34 <dons> byorgey: its rss2irc on hackage
16:58:43 <Saizan_> byorgey: so that thread concluded that foldr is a way to build a monoid homomorphism between [a] and (b -> b) given (a -> b -> b) ?
16:59:02 <byorgey> Saizan_: that is one way to think of foldr, yes
16:59:08 <thomashartman1> cabal error: Error: A library was specified, but no 'exposed-modules' list has been given.
16:59:22 <thomashartman1> I don't want to package a library, just an executable.
16:59:39 <thomashartman1> I have executable:          happs-tutorial
16:59:39 <thomashartman1> main-is:             src/Main.hs
16:59:52 <thomashartman1> what else do I need to do, to get past this error? or do I always need to give an exposed module list?>
17:00:18 <Saizan_> ?hackage mueval
17:00:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
17:02:25 <Saizan_> thomashartman1: do you have something like this? http://hackage.haskell.org/packages/archive/Shu-thing/1.1/Shu-thing.cabal
17:02:26 <lambdabot> http://tinyurl.com/5clk6s
17:04:35 <thomashartman1> Saizan: yeah I do... this isn't as complicated as I though... something simple is wrong.
17:07:01 <gwern> thomashartman1: shuthing is a single haskell file, so 'main-is:             Shu-thing.hs' is enough. maybe you are loking for 'other-modules' instead of 'exposed-modules'?
17:09:57 <thomashartman1> is the hs-source-dirs field not applicable for an executable project, only for lib projects?
17:11:45 <gwern> no, but it is a subtle field and may not be needed or do what you think it does
17:12:22 <thomashartman1> I don't give an exposed-modules field, just other-modules. it still says "Error: A library was specified, but no 'exposed-modules' list has been given."
17:12:34 <thomashartman1> why does it think "a library was specified?
17:12:35 <gwern> in shu-thing, for example, it's not listed since '.' is the default, and shu-thing.hs is in the top-level, ., so I need only specify the name and not the full location
17:13:02 <gwern> thomashartman1: typically it's because you've used a library-only field like exposed-modules
17:13:27 <thomashartman1> but I didn't, I took that field out.
17:13:53 * gwern would really have to see an hpaste to know
17:16:27 <hpaste>  thomashartman1 pasted "cabal woes" at http://hpaste.org/8514
17:17:42 <gwern> ok, my first move would be to move hs-source-dirs and other-modules down to below build-depends
17:18:00 <gwern> many fields are location dependent in an obscure manner, annoyingly enough
17:24:31 <thomashartman1> okay I figured something out.
17:24:47 <thomashartman1> whenever Hs-source-dirs:      src is present, it complains that it's a library but no exposed modules field was given.
17:24:49 <thomashartman1> is this a bug?
17:25:23 <gwern> maybe not. as I said, location matters
17:45:04 <mmorrow> i patched ghc-6,8,3 with audreyt's QuasiQuotes patch and put it at http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.tar.bz2
17:45:05 <lambdabot> http://tinyurl.com/6r7suq
17:45:23 <mmorrow> i'm building it on my machine now in order to test it, but just started compiling
17:45:30 <mmorrow> so...
17:45:50 <mmorrow> also, a git repo of the same is at http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.git/
17:45:50 <lambdabot> Title: Index of /~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.git
17:46:18 <mmorrow> (i at least *tried* to use darcs first, but...)
17:46:30 <povman> but?
17:46:45 <mmorrow> it took about 10 minutes to import the initial dir tree
17:46:47 <mmorrow> then
17:46:48 <rwbarton> Cannot get remote repository information.
17:46:48 <rwbarton> Perhaps git-update-server-info needs to be run there?
17:47:01 <mmorrow> after i applied the patch and committed it
17:47:11 <mmorrow> darcs whatsnew was overflowing the stack
17:47:22 <mmorrow> so, i increased the stack size to a HUGE amount
17:47:26 <thomashartman1> Beh. I am starting to think that there is no way to hackage an executable other than as one large file, eg shu thing.
17:47:31 <thomashartman1> at least using cabal sdist.
17:47:35 <rwbarton> (^^ message from git clone)
17:47:42 <mmorrow> and whatsnew worked, but first spit out a couple hundred lines of garbage
17:47:49 <Saizan_> thomashartman1: see the .cabal for cabal-install
17:47:53 <mmorrow> no sadly i used git
17:47:54 <thomashartman1> I tried testing this on a darcs checkout of topkata (which is hackaged) and cabal sdist gets rejected.
17:48:30 <mmorrow> rwbarton: i've never used git before, so you'll have to tell me what i need to do
17:48:39 <mmorrow> all i did was
17:48:41 <mmorrow> git init
17:48:44 <mmorrow> git add *
17:48:49 <mmorrow> <did patch>
17:49:04 <mmorrow> actually, delete that "<did patch>
17:49:08 <mmorrow> git commit
17:49:11 <mmorrow> <did patch>
17:49:14 <mmorrow> git commit
17:49:16 <rwbarton> mmorrow: Sure.  Gimme one sec...
17:49:30 <mmorrow> rwbarton: thanks
17:50:01 <rwbarton> Go to the .git/hooks directory, and make the file 'post-update' executable
17:50:08 <rwbarton> Then run it
17:50:18 <mmorrow> ok, going...
17:50:28 <mmorrow> a sec
17:50:57 <mmorrow> ok, done
17:52:13 <mmorrow> reading the git-update-server-info man page now...
17:52:28 <povman> i wish the derived show would find equal elements in its data structure and put them in a let
17:52:55 <mmorrow> in the meantime, there's the .bz2 version there for anyone interested
17:53:42 <mmorrow> like i said, haven't tested it yet, but it's currently building on my machine
17:54:41 <thomashartman1> Saizan: thanks, looks like things have changed a lot with cabal... trying to base off of that.
17:55:31 <povman> are there any technical difficulties: just find shared parts and only print them once, in a let clause.
17:56:21 <povman> mmorrow: are you using darcs2?
17:56:37 <mmorrow> 1.0.9 (release)
17:56:45 <ddarius> povman: Sharing isn't visible (or required) in Haskell.
17:56:52 <povman> ddarius: thanks
17:57:15 <mmorrow> povman: why? how is it in comparison?
17:57:43 <povman> well i know darcs2 downloaded and applied 140 patches in a second, compared to the couple of minutes darcs1 took
17:58:01 <povman> and the repository format is different
17:58:08 <mmorrow> oh crap, had a compilation error while building that ghc, will fix and reupload once i do
17:58:36 <mmorrow> the good thing is that it's not in the compiler part itself, but a library
17:59:23 <mmorrow> oh actually it was in the compiler section, but should be easy to fix
18:00:43 <mmorrow> *oh*. it's because i'm building it with 6.9. if it were to be built with 6.8 i don't think that'd occur
18:01:10 <mmorrow> i'll try building it with 6.8 then test it...
18:03:40 <mmorrow> i'm also gonna delete the git version since getting it is broken, but the .bz2 tarball will remain (and unpacked, it itself is a git repo)
18:04:40 <povman> mmorrow: how did you get 6.8.3?
18:05:19 <gwern> Tomas: incidentally, topkata is just broken because it omitted a module in other-modules
18:06:03 <jbapple> Does anyone know how to give haddock enough information to fix:
18:06:03 <jbapple>  could not find link destinations for:
18:06:03 <jbapple>     GHC.Base.Monad GHC.Base.Functor Data.Either.Either GHC.Num.Integer Data.Stream.Stream
18:06:11 <mmorrow> povman: i'll find the link, a sec..
18:06:23 <mmorrow> http://www.haskell.org/ghc/dist/stable/dist/ghc-6.8.3-src.tar.bz2
18:06:27 <mmorrow> http://www.haskell.org/ghc/dist/stable/dist/ghc-6.8.3-src-extralibs.tar.bz2
18:06:28 <lambdabot> http://tinyurl.com/5vo3ja
18:06:42 <mmorrow> oh yeah, that bz2 has the extralibs already in it
18:06:48 <povman> .. how come you're using git then?
18:06:52 <jbapple> The only solution I found was: http://www.mail-archive.com/haskell-cafe@haskell.org/msg39130.html
18:06:54 <lambdabot> Title: Re: [Haskell-cafe] Haddock Help Required, http://tinyurl.com/6nygpl
18:07:10 <jbapple> Which says to compile GHC from source
18:07:25 <jbapple> This seems a little heavyweight just to get documentation links to work
18:08:02 <mmorrow> povman: i wanted to track the changes the patch made to the src tree with darcs, but it had troubles so git
18:08:24 <mmorrow> povman: (and the bz2'ed ghc src packages aren't darcsed)
18:08:42 <gwern> er. I meant thomashartman1
18:08:43 <gwern> jbapple: complain to your distro - 'needs moar docs!'
18:08:56 <povman> eh ok.
18:09:46 <mmorrow> povman: :(
18:10:11 <povman> mmorrow: you could just use diff :)
18:10:25 <mmorrow> i could, but there already is one! :)
18:10:37 <povman> yes... you could just not do anything.
18:10:41 <mmorrow> hehe
18:10:56 <mmorrow> yeah, i dunno why i felt compelled to version control it but so it is
18:11:20 <rwbarton> Is your home directory on code.haskell.org on some weird filesystem type or something?
18:11:30 <mmorrow> povman: this way though, any future changes to that repo are version controlled...
18:11:54 <rwbarton> Because the problem was, there were directories .git/objects/{10..18} that are in the tarball but weren't showing up in the apache directory listing
18:11:56 <povman> hopefully not too many changes... they'll all get slaughtered by ghc 6.10
18:12:09 <Igloo> mmorrow: You can get tarballs of the darcs tree from darcs.haskell.org
18:12:42 <mmorrow> Igloo: oh, thanks. i was asking about that earlier and was unclear about how to get *just* 6.8.3 code
18:12:56 <mmorrow> Igloo: cuz i have a patch from audreyt against that
18:13:24 <Igloo> mmorrow: Oh, you can't get it for releases, but you could get the latest stable snapshot and pull the rest
18:14:52 <mmorrow> Igloo: hmm. so my purpose is to apply audreyt's patch to 6.8.3 (which adds QuasiQuotes), and make the result available so people who don't want to go to 6.9 right now can still use quasiquotes. Are we talking about the same thing?
18:15:13 <mmorrow> (and so they don't have to apply it themselves)
18:15:54 <Igloo> mmorrow: I'd just make a standard diff(1) patch for that
18:16:29 <povman> Igloo: it already exists
18:16:31 <mmorrow> yeah, that's what i've already available. i
18:16:33 <mmorrow> yeah
18:16:53 <povman> mmorrow: patch the src tarball, and retar it
18:16:59 <povman> :p
18:17:03 <mmorrow> just want to make it *easy* to get QuasiQuotes in 6.8.3 cuz i just wrote a package that i want to put on hackage the depends on them
18:17:14 <mar77a> > let armons n = (/) 1 (1**n) in foldr (+) 0 $ map armons [0..50]
18:17:15 <lambdabot>  51.0
18:17:19 <mmorrow> povman: i did! http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.tar.bz2
18:17:20 <lambdabot> http://tinyurl.com/6r7suq
18:17:37 <mar77a> o_O
18:17:40 <rwbarton> mmorrow: do you mind unpacking that tarball onto code.haskell.org again?  I'd like to sanity check something
18:17:49 <mmorrow> sure, hold on
18:17:50 <povman> mmorrow: but we still haven't held the launch party?
18:17:58 <mar77a> > let armons n = (/) 1 (2**n) in foldr (+) 0 $ map armons [0..50]
18:17:59 <lambdabot>  1.9999999999999991
18:18:05 <mar77a> > let armons n = (/) 1 (2**n) in foldr (+) 0 $ map armons [0..200]
18:18:06 <lambdabot>  2.0
18:18:10 <mar77a> x)
18:18:23 <mmorrow> povman: unsafePerformMissileLaunch???
18:19:17 <mmorrow> rwbarton: done
18:19:18 <povman> this discussion is going off topic like ackermann
18:20:06 <geezusfreeek> > let armons n = (/) 1 (2**n) in foldr (+) 0 $ map armons [0..50] :: CReal
18:20:08 <lambdabot>  1.9999999999999991118215802998747676610947
18:20:22 <mar77a> > let armons n = (/) 1 (2**n) in foldr (+) 0 $ map armons [0..1000] :: CReal
18:20:33 <lambdabot>  Exception: Time limit exceeded
18:20:37 <geezusfreeek> will come out to 2.0 because it can't show enough digits
18:20:41 <mar77a> > let armons n = (/) 1 (2**n) in foldr (+) 0 $ map armons [0..500] :: CReal
18:20:52 <lambdabot>  Exception: Time limit exceeded
18:20:53 <geezusfreeek> > let armons n = (/) 1 (2**n) in foldr (+) 0 $ map armons [0..200] :: CReal
18:20:55 <mar77a> what's CReal anyways
18:21:00 <lambdabot>  2.0
18:21:01 <mar77a> is it in the standard library
18:21:18 <mar77a> @hoogle CReal
18:21:18 <lambdabot> No matches found
18:21:34 <geezusfreeek> @where CReal
18:21:34 <lambdabot> I know nothing about creal.
18:22:17 <geezusfreeek> well, http://darcs.augustsson.net/Darcs/CReal i think
18:22:20 <lambdabot> Title: Index of /Darcs/CReal
18:22:35 <roconnor> @where+ CReal http://darcs.augustsson.net/Darcs/CReal/
18:22:35 <lambdabot> It is forever etched in my memory.
18:22:48 <rwbarton> mmorrow: thanks.  Turns out apache was "cleverly" sorting 1a, 1b, ..., 9e, 9f before 10, 11, etc. so I didn't see the directory I was looking for
18:23:11 <mmorrow> haha
18:23:42 <mar77a> > exp_dr 1
18:23:43 <lambdabot>   Not in scope: `exp_dr'
18:23:57 <psyklops> I've seen in a couple tutorials functions with _ or ' in their name, do those characters have special meanings?
18:24:18 <psyklops> like func_  mathstuff'
18:24:46 <rwbarton> Nope, just part of the identifier name.
18:24:49 <mar77a> they're usually used either to make function names nicer (tho i camel notation is more common) or with helper functions
18:24:59 <mar77a> tho in the std lib it depends
18:25:10 <mar77a> like _ is used as the monad function that discards results sometimes
18:25:18 <rwbarton> Yes, they may have special meanings to humans reading the code, but not to the compiler.
18:25:52 <psyklops> okay, no effect in code, that's all I wanted to know
18:26:14 <psyklops> I was reading the ' as "prime" and thinking maybe it was a "not" operator of some kind
18:26:32 <psyklops> and I thought _ was for constants or something (silly in haskell though)
18:26:47 <darrint> Is there a way to get the list of remaining input tokens after Text.Parset.parse returns?
18:28:32 <psyklops> This is a bad time to talk, ey...
18:29:06 <psyklops> func x | x <- list, boolFunc x
18:29:12 <psyklops> what does the comma mean here?
18:29:36 <mar77a> it's used to seperate parts in the list comprehension
18:29:51 <psyklops> I have all these questions because I noted them down in a text file to be later investigated (or just to be deleted as I learned)
18:30:15 <psyklops> I need to re-learn list comprehension then
18:30:35 <pgavin> psyklops: the comma introduces a guard
18:30:36 <TomMD> psyklops: You can often think of it as an "AND" operator.
18:30:48 <pgavin> :t guard
18:30:50 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:31:00 <TomMD> > [x | x <- [0..10], x < 5]
18:31:01 <lambdabot>  [0,1,2,3,4]
18:31:27 <TomMD> > [x | x <- [0..10], x < 5, x > 3]
18:31:28 <pgavin> > do { x <- [0..10] ; guard (x < 5) ; return x }
18:31:29 <lambdabot>  [4]
18:31:29 <lambdabot>  [0,1,2,3,4]
18:32:09 <psyklops> I see
18:32:33 <hpaste>  mdmkolbe pasted "What does this error mean?" at http://hpaste.org/8515
18:33:05 <mdmkolbe|work> Any GADT experts want to take a swing at this error message? http://hpaste.org/8515
18:33:56 --- mode: irc.freenode.net set +o ChanServ
18:34:12 <mdmkolbe|work> was that a net split?
18:34:15 <Saizan_> mdmkolbe|work: give foo an explicit type signature
18:34:46 <geezusfreeek> i haven't seen that error message before but i suspect it will go away or at least be more meaningful with a type signature
18:34:52 <povman> people can't decide whether to boycott haskell or not
18:35:09 <darrint> Is is possible to use parsec to incrementally parse a long string?
18:36:58 <psyklops> >[x| x <- [2,4..24] | x<16}]
18:37:25 <geezusfreeek> jeez freenode
18:37:39 <psyklops> global notice
18:38:06 <psyklops> > [x | x <- [2,4..24] | x<16]
18:38:06 <lambdabot>  Parse error at "|" (column 21)
18:38:16 <psyklops> hm, easier than asking ;)
18:38:48 <chylli> [x | x <- [1..2]]
18:39:00 <chylli> > [x | x <- [1..2]]
18:39:02 <lambdabot>  [1,2]
18:39:22 <chylli> how to ask lambda ? add prefix '>' ?
18:39:27 <chylli> > hello
18:39:27 <lambdabot>   Not in scope: `hello'
18:39:28 <psyklops> > [x | x <- [2,4..24], x<16]
18:39:29 <lambdabot>  [2,4,6,8,10,12,14]
18:39:53 <chylli> hello, lambdabot
18:39:58 <psyklops> and a space after it, apparentl
18:39:59 <psyklops> y
18:42:42 <thomashartman1> gwern: I re-uploaded happs-tutorial to hackage and it works now.
18:42:44 <thomashartman1> whew.
18:42:54 <psyklops> > fibs 13
18:42:55 <lambdabot>   Not in scope: `fibs'
18:43:02 <psyklops> > fib 13
18:43:03 <lambdabot>   Not in scope: `fib'
18:44:55 <byorgey> wow, that is a boatload of warnings
18:45:42 <byorgey> thomashartman1: works for me now
18:46:57 <psyklops> I still need to further my understanding of  \   >>=   >>   and   @
18:47:06 <psyklops> And Just
18:47:21 <psyklops> > :t Just
18:47:22 <lambdabot>   parse error on input `:'
18:47:26 <psyklops> :t Just
18:47:28 <lambdabot> forall a. a -> Maybe a
18:47:37 <thomashartman1> byorgey: oorah :)
18:47:39 <psyklops> "a." ?
18:48:02 <mmorrow> oh man, it looks like somehow i put a NONpatched ghc6.8.3 instead of the patched one. sighsigh
18:48:03 <thomashartman1> byorgey: can you open localhost:5001 in firefox?
18:48:11 * mmorrow begins fixing
18:48:40 <SamB> psyklops: \ is the poor mans λ
18:48:42 <byorgey> thomashartman1: oh, well, it didn't ACTUALLY install because I forgot to do things with the proper permissions =)
18:48:52 <psyklops> Yes, I know it is read "Lambda"
18:49:04 <byorgey> but everything built and then just at the end it failed because it couldn't create the proper directories
18:49:04 <psyklops> But I don't fully understand its effect
18:49:16 <SamB> @google barendregt introduction to lambda calculus
18:49:17 <thomashartman1> groovy.
18:49:18 <lambdabot> http://citeseer.ist.psu.edu/barendregt94introduction.html
18:49:18 <lambdabot> Title: Introduction to Lambda Calculus - Barendregt, Barendsen (ResearchIndex)
18:49:32 <SamB> psyklops: there's a nice long work on the subject ;-)
18:49:47 <psyklops> I'd prefer short
18:49:53 <thomashartman1> Getting this cabalized was a total pain in the ass, but I have to admit a warm fuzzy feeling.
18:49:57 <SamB> you don't have to read the whole thing
18:50:09 <psyklops> I inevitable will try
18:50:10 <SamB> probably the first couple chapters would be enough ;-)
18:50:13 <byorgey> thomashartman1: it gets easier with practice =)
18:50:16 <mmorrow> povman: well, just found out why darcs spit out a few hundred lines of "garbage". that wasn't garbage at all, just a data string in Happy-generated code ;)
18:50:31 <psyklops> Or not...
18:50:43 <povman> arhh
18:51:00 <SamB> psyklops: well, what do you understand about it so far?
18:51:33 <psyklops> Hm, not much. I just think "defines a function in place"
18:52:25 <psyklops> which probably in itself is wrong
18:52:42 <SamB> psyklops: not as far as it goes
18:52:45 <hackage> New hackage package: happs-tutorial 0.1
18:52:45 <hackage> New hackage package: zipedit 0.2.2
18:53:07 <shepheb> ooh hackage bot
18:53:37 <sykopomp> happs-tutorial = haskell tutorial?
18:54:16 <byorgey> sykopomp: no
18:54:38 <byorgey> happs is a haskell web framework
18:54:55 <byorgey> ask thomashartman1 if you want a better explanation =)
18:55:20 <byorgey> thomashartman1: ok, it's actually installed now.  now what do I do?  run it and try going to localhost:5001?
18:55:48 <byorgey> thomashartman1: IO Error: Just "templates/base.st" -- does not exist
18:57:18 <byorgey> hmm, if the hackage bot got a botsnack every time it posted something, would it be hackage package snackage?
18:59:01 <psyklops> :t ->
18:59:04 <lambdabot> parse error on input `->'
18:59:06 <psyklops> heh
18:59:31 <psyklops> I see a third use of the -> in these example lambda functions
18:59:41 <mmorrow> ok, now this *really* is the patched ghc : http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.tar.bz2
18:59:43 <lambdabot> http://tinyurl.com/6r7suq
18:59:50 <psyklops> 1) type declaration 2) case statements
19:00:07 <dons> anyone seen http://okmij.org/ftp/Computation/Continuations.html#shift-cgi
19:00:08 <lambdabot> Title: Continuations and delimited control
19:00:15 <dons> dolio: looks cool ^ (CGI with delconts)
19:00:20 * byorgey downloads mmorrow's ghc
19:00:51 <hpaste>  povman pasted "Fun problem" at http://hpaste.org/8516
19:01:42 <mmorrow> byorgey: we can race to see who gets it build first...go!
19:01:56 * rwbarton already started building a couple minutes ago
19:02:05 <ddarius> dons: I did something like that today in C#, though the web stuff won't scale.
19:02:08 <byorgey> mmorrow: ... it's still downloading =P
19:02:15 <mmorrow> still running configure..
19:02:31 <mmorrow> make -j10 !!!!
19:02:41 <dons> ddarius: oh, interesting. care to elaborate?
19:02:49 * dons is on  the lookout for new CGI models
19:02:58 <povman> i'm having trouble with existential quantification ^^^
19:03:03 <mdmkolbe|work> Saizan: (belated) thanks.  after working that change back into the original code (took a while thus the belated), that seem to work
19:03:23 <mmorrow> dons: yeah that looks very interesting, looked over it a while back but just a skim
19:03:33 <dons> we've delcont-CC in hackage
19:03:38 <dons> would be interesting to see if that's enough
19:03:42 <dons> and if it really does clean up the model
19:04:13 <mmorrow> dons: (i dunno if there attached to that article or another but) have you seen oleg's NewCGI.hs??
19:04:22 <mmorrow> s/there/it is/
19:04:22 <ddarius> dons: On this blog post a while back I said you could make identical code work in console/GUI/Web environments ( http://blogs.msdn.com/wesdyer/archive/2007/12/22/continuation-passing-style.aspx#6841990 ).  Today, I decided to put my money where my mouth was.
19:04:23 <lambdabot> http://tinyurl.com/ypfmka
19:04:51 <dons> in C# ?
19:04:56 <ddarius> dons: There really isn't much else to say, it's pretty well-known stuff in the "continuations" community.
19:05:30 <dons> yeah, i'm curious about what you get with delimited continuations though
19:05:38 <dons> we've had WASH et al using continuations for CGI forever
19:06:12 <dons> gee, we've even commercial sites running continuation-based Haskell CGI (braintreehemp.com.au)
19:06:26 <mmorrow> dons: found it:
19:06:29 <mmorrow> http://okmij.org/ftp/Haskell/NewerCGI.hs
19:06:34 <mmorrow> http://okmij.org/ftp/Haskell/FastCGI.hsc
19:06:41 <mmorrow> and they're here:
19:06:57 <ddarius> dons: The "nested transactions" is presumably the gain.
19:06:58 <mmorrow> http://okmij.org/ftp/Haskell/#NewerCGI
19:06:59 <lambdabot> Title: Haskell Programming: Miscellanea
19:07:05 <dons> ddarius: yeah
19:07:34 <dons> hmm, mmorrow interesting
19:07:46 <dons> all oleg's stuff is in the public domain.
19:07:53 <dons> i should sit down one weekend and package all the haskell stuff
19:08:20 <mmorrow> dons: yeah. i tried hacking on them to get em working, but there's a Util module or something missing, so i didn't get that far
19:08:56 <mmorrow> but it could def be done if something just spent the time figuring out whats going on
19:09:04 <gwern> offhand, anyone know how you take a given number (like 30 quintillion) and figure out how many bits would be necessary to represent it?
19:09:34 <ddarius> gwern: log base 2
19:09:39 <shepheb> gwern: find the first power of two larger than it vi log?
19:09:42 * gwern 's usual method of incrementing 2^ would probably take too long for that :)
19:09:46 <dons> log base 2.
19:09:51 <dons> oh, as ddarius said
19:10:06 <gwern> @hoogle log
19:10:07 <lambdabot> Prelude.log :: Floating a => a -> a
19:10:07 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
19:10:07 <lambdabot> GHC.Conc.Logoff :: ConsoleEvent
19:10:26 <dons> > logBase 2 32
19:10:27 <ddarius> > logBase 65536 2
19:10:28 <lambdabot>  5.0
19:10:29 <lambdabot>  6.25e-2
19:10:33 <gwern> > logBase 2 (sqrt (10^39) + 1024)
19:10:35 <lambdabot>  64.77759785030356
19:10:36 <ddarius> Wrong way.
19:10:47 <gwern> > logBase (sqrt (10^39) + 1024) 2
19:10:49 <lambdabot>  1.5437435675075958e-2
19:10:55 <ddarius> No, I got it the wrong way.
19:11:08 * gwern sighs
19:11:10 <dons> > logBase 2 256
19:11:12 <lambdabot>  8.0
19:11:23 <ddarius> gwern: So 65 bits.
19:11:39 <dons> ?let bits n = ceiling (logBase 2 n)
19:11:40 <lambdabot> Defined.
19:11:47 <dons> > bits (sqrt (10^39) + 1024)
19:11:49 <lambdabot>  65
19:11:58 <ddarius> > let bits = ceiling . logBase 2 in bits 65536
19:11:59 <lambdabot>  16
19:12:16 <gwern> hm. obviously I've messed up somewhere. 65 bits is way too small a key
19:12:34 <povman> > logBase 2 30000000000000000000
19:12:34 <dons> you want 2k keys i guess :)
19:12:35 <lambdabot>  64.70159630358104
19:12:57 <gwern> > logBase 2 (10^39 + 2^1024)
19:12:59 <lambdabot>  Infinity
19:13:09 <dons> had an interesting bug at work today where someone was generating 32k keys instead of 2k and wondering why the code was 16x slower than expected :)
19:13:18 <dons> it wasn't Integer at fault hehe
19:13:29 <gwern> dons: nah, I'm trying to figure out how long a key you'd need to defeat the ultimate laptop brute-forcing it
19:13:44 <ddarius> > 2^1024 :: Double
19:13:46 <lambdabot>  Infinity
19:13:53 <roconnor> > logBase 2 (10^39 + 2^1024) :: CReal
19:13:55 <lambdabot>  1024.0
19:13:56 <ddarius> > 2^1023 :: Double
19:13:57 <lambdabot>  8.98846567431158e307
19:14:01 <gwern> dons: but, but it'll be secure for dozens of years then! :)
19:14:01 <dons> gwern: number of protons in the universe is a good amount
19:14:08 <dons> > 10^80
19:14:10 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
19:14:18 <dons> > bits $ 10^80
19:14:20 <lambdabot>  266
19:14:48 <ddarius> 10^39 takes roughly 120 bits.
19:14:51 <mar77a> :t bits
19:14:53 <lambdabot> forall t b. (RealFrac t, Floating t, Integral b) => t -> b
19:15:54 <povman> does anyone know about existential quantification?
19:16:03 <povman> http://hpaste.org/8516
19:20:13 <mmorrow> :t \x->(x\\).(x\\)
19:20:15 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:20:27 <mmorrow> > (\x->(x\\).(x\\)) [0,1,2]
19:20:28 <lambdabot>  <[Integer] -> [Integer]>
19:20:32 <bd_> oO
19:20:35 <mmorrow> > (\x->(x\\).(x\\)) [0,1,2] [2..5]
19:20:36 <bd_> \\?
19:20:37 <lambdabot>  [2]
19:20:49 <mmorrow> haha
19:20:56 <mmorrow> that's from:
19:20:57 <mmorrow> http://okmij.org/ftp/Haskell/#mastermind
19:20:58 <lambdabot> Title: Haskell Programming: Miscellanea
19:20:58 <bd_> this some new extension I've not heard about yet? :)
19:21:12 <mmorrow> that list diff
19:21:17 <mmorrow> (in Data.List)
19:21:28 <mmorrow> > [0..9] \\ [5..20]
19:21:29 <lambdabot>  [0,1,2,3,4]
19:21:30 <bd_> ah
19:21:42 <mar77a> :t (\\)
19:21:44 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:21:51 <mar77a> what does (\\) do
19:21:51 <gwern> argh. ghc builds, but make install fails with link errors
19:21:57 <mar77a> besides resemble some emo hair
19:21:57 <gwern> so annoying
19:22:01 <mmorrow> > [0..9] \\ [5..20]
19:22:03 <lambdabot>  [0,1,2,3,4]
19:22:31 <byorgey> hehe, (\\), the emo hair operator
19:22:58 <mar77a> i still don't see what it does
19:23:20 <mmorrow> list difference
19:23:51 <mar77a> (\\) = zipWith (/) ?
19:23:52 <byorgey> it deletes each element of the second list from the first list
19:23:59 <mmorrow> A \\ B = x `elem` A suchthat x (not an elem) B
19:24:01 <mar77a> whaaa
19:24:04 <byorgey> > [1..10] \\ [4,6]
19:24:05 <lambdabot>  [1,2,3,5,7,8,9,10]
19:24:16 <byorgey> see, that's the list [1..10] with 4 and 6 removed
19:24:26 <mmorrow> [0,1,2] \\ [1]
19:24:28 <mmorrow> > [0,1,2] \\ [1]
19:24:28 <gwern> @src (\\)
19:24:28 <mar77a> got it
19:24:29 <lambdabot> (\\) = foldl (flip delete)
19:24:30 <lambdabot>  [0,2]
19:24:36 <byorgey> mmorrow: that's actually not *quite* right...
19:24:41 <byorgey> for example:
19:24:42 <mmorrow> yeah..hehe
19:24:44 <mar77a> > [] \\ []
19:24:45 <byorgey> > [3,3,3] \\ [3]
19:24:46 <lambdabot>  []
19:24:47 <lambdabot>  [3,3]
19:24:50 <mar77a> > [] \\ [2]
19:24:51 <lambdabot>  []
19:25:00 <newsham> "functional" \\ "fun"
19:25:20 <byorgey> "ocaml"
19:25:26 <mmorrow> haha
19:25:33 <byorgey> just kidding =)
19:25:34 <mar77a> quote
19:25:37 <mar77a> :P
19:25:45 <mar77a> i would've said lisp tho
19:25:50 <mdmkolbe|work> I'm using "ghc -E" to extract code form a literate haskell, but it ends up leaving a *lot* of blank lines.  Is there a way to have it remove those extra blank lines (where the text was before)?
19:26:01 <mar77a> > "locomotora" \\ "aeiou"
19:26:03 <lambdabot>  "lcomotor"
19:26:12 <mar77a> why are the "o"'s there
19:26:26 <byorgey> mar77a: it only deletes as many copies as are in the second list
19:26:28 <mar77a> > [1,1,1] \\ [1]
19:26:30 <lambdabot>  [1,1]
19:26:30 <newsham> sed '/^$/d' < file
19:26:32 <mar77a> > [1,1,1] \\ [1,1]
19:26:34 <lambdabot>  [1]
19:26:37 <mar77a> mm
19:26:38 <mmorrow> mdmkolbe|work: sed -r 's/^[\s\t]*$//g'
19:26:44 <byorgey> > "locomotora" \\ "aeiooou"
19:26:45 <lambdabot>  "lcmtor"
19:26:57 <newsham> mmorrow: s doesnt delete lines
19:27:18 <newsham> /^[\s\t]*$/d
19:27:20 <TomMD> byorgey: Have you moved to Penn yet?  If so, how do you like it there?
19:27:22 <newsham> /^[\s\t]*$/d
19:27:22 <mar77a> > 0.000000000000000000000000000000001 / 0.000000000000000000000000000001
19:27:24 <lambdabot>  1.0e-3
19:27:27 <mmorrow> newsham: hmm, didnt know that
19:27:40 <byorgey> TomMD: nope, haven't moved yet, we will be moving on August 2
19:28:18 <rwbarton> mmorrow: The compiler builds, and doesn't choke on LANGUAGE QuasiQuotes.
19:28:29 <mdmkolbe|work> newsham: well, I don't want all the blank lines removed, I just want multiple blank lines collapsed into one
19:28:49 <newsham> thats harder.
19:29:00 <newsham> (in sed)
19:29:07 <mmorrow> rwbarton: nice! i'm still building. check out http://code.haskell.org/~morrow/code/haskell/regexqq/  !!!
19:29:08 <lambdabot> Title: Index of /~morrow/code/haskell/regexqq
19:29:14 <rwbarton> Do you know how I can point it at my ghc packages?  (I don't really want to install it, just running compiler/stage2/ghc-inplace)
19:29:15 <mmorrow> you need pcre-light
19:30:43 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light
19:30:46 <lambdabot> http://tinyurl.com/6agmkz
19:30:53 <mmorrow> darcs repo:
19:30:54 <mmorrow> http://code.haskell.org/~dons/code/pcre-light/
19:30:55 <lambdabot> Title: Index of /~dons/code/pcre-light
19:31:27 <TomMD> I fear this proliferation of library dependencies (ex: OpenSSL, pcre-light) is going to make packaged binaries harder to distribute.
19:31:46 <rwbarton> I got it from hackage.  But I'm trying to point ghc-inplace at it
19:33:28 <mmorrow> rwbarton: my plan is to install at /usr/local/ghc/ghc-6.8.3_QQ-0.1/, then export PATH=/usr/local/ghc/ghc-6.8.3_QQ-0.1/bin:$PATH   then  /Setup configure --prefix=/usr/local/ghc/ghc-6.8.3_QQ-0.1/ pcre-light
19:33:41 <rwbarton> ah, I need a whole separate ghc 6.8.3 package.conf it looks like
19:33:56 <dons> TomMD: binaries themselves are all statically linked though.
19:34:02 <dons> which kills off much of the problem.
19:34:09 <mmorrow> rwbarton: that's prob gonna be painful do run it from the build location
19:34:17 <dons> it does place a greater burden on having a decent "haskell platform" on every distro
19:34:18 <mmorrow> s/do/to/
19:34:21 <rwbarton> mmorrow: Yes, it looks like it might be.
19:35:17 <dons> TomMD: but compared to the situation 4 years ago when the few who could distribute apps bundled ad hoc versions in tree, its a golden age
19:35:41 <dons> mm. firefox3 is pretty nice.
19:37:16 <dolio> dons: So, despite what I previously said, I went ahead and added memcpy and memmove-based copying to my local copy of uvector, and it seems to be somewhat faster for things that do a fair amount of copying (merge sort, for instance).
19:37:35 <dons> ok.
19:37:48 <dons> the ndp library has a copy function i didn't get around to adding
19:37:58 <mmorrow> dolio: ooh, paste a darcs diff
19:39:24 <dolio> Ah. I'd be interested to see what they did (see if I did it right :)). I'm not sure about the names I made, either. There's already copyMU :: MUArr e s -> Int -> UArr e -> ST s (), so I added an extra M.
19:39:31 <dolio> But that might not be ideal.
19:40:07 <mmorrow> names can always be changed
19:40:47 <mmorrow> (well, until code starts depending on a partic name that is)
19:41:08 <hpaste>  dolio pasted "uvector memcpy/memmove diff" at http://hpaste.org/8517
19:41:12 <mmorrow> yay
19:41:41 <dolio> Oh, wait, that doesn't include the c files.
19:42:44 <mmorrow> oh look at mr slick, using MutableByteArray# in foreign calls
19:43:20 <mmorrow> so does this pass a ptr to it or what?
19:43:34 <hpaste>  dolio annotated "uvector memcpy/memmove diff" with "with C files" at http://hpaste.org/8517#a1
19:43:50 <dolio> And that gets chopped.
19:44:14 <mmorrow> when it rains it ours
19:44:23 <mmorrow> pours
19:44:36 <dolio> I could just send you a patch if you message me your e-mail.
19:45:03 <mmorrow> cool
19:46:44 <rwbarton> mmorrow: It works!
19:46:55 <mmorrow> rwbarton: awesome!!
19:47:13 <mmorrow> mine's *still* building
19:47:33 <rwbarton> Currently only when I :load a file... how do I tell ghci to turn on language options?
19:47:51 <rwbarton> Ah, I guessed right
19:47:52 <thomashartman1> byorgey: ooh, this is bad. i have to add each individual template file as a code dependency if packaging this with cabal. I guess I'll stick with a darcs-tagged project for now.
19:47:52 <thomashartman1> It would be okay if there was some way I could specify all files under some directory as needing to be packagedup.
19:47:53 <thomashartman1> But I don't think there's any way to do that at present.
19:47:55 <mmorrow> edit your ~/.ghci file
19:48:13 <byorgey> thomashartman1: there is, I think
19:48:32 <mmorrow> i'll past one with what you'll want...
19:48:32 <thomashartman1> wasn't that some ticket for cabal that dons mentioned before?
19:48:32 <byorgey> thomashartman1: hang on a sec, let me find it for you
19:48:36 <rwbarton> I guessed :set -XQuasiQuotes, that made it work.
19:49:12 <byorgey> thomashartman1: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
19:49:13 <lambdabot> Title: Neil Mitchell's Haskell Blog: Adding data files using Cabal, http://tinyurl.com/364awx
19:49:17 <byorgey> maybe that will help?
19:49:53 <hpaste>  morrow pasted ".ghci for QuasiQuotes" at http://hpaste.org/8518
19:50:11 <petekaz> Does 'cabal install gd' work for anyone else?
19:50:19 <hpaste>  morrow annotated ".ghci for QuasiQuotes" with "(e.g.) my .ghci" at http://hpaste.org/8518#a1
19:50:24 <thomashartman1> hm, I'll have a look.
19:51:13 <mmorrow> rwbarton: my favorite is -fno-print-bind-result
19:52:47 <dolio> mmorrow: Sent.
19:52:56 <dons> "
19:52:56 <dons> Firefox now empowers even greater Web development, with JavaScript 1.8—including expression closures, generator expression and array reduce. "
19:52:56 <mmorrow> dolio: cool, thanks
19:53:11 <rwbarton> googling for -fno-print-bind-result gets you youtube music videos...
19:53:39 <dons> strange things to advertise. is JS with what, lazy lists, closures and folds?
19:54:16 <mmorrow> hehe
19:54:40 <dons> this is what the future looks like
19:55:16 <dolio> Didn't javascript already have closures?
19:55:23 <ddarius> It looks an awful lot like the 70s.
19:55:45 <ddarius> dolio: Yes.  But now they have a prettier syntax.
19:55:53 <ddarius> Like C# 3.0 v. C# 2.0
19:55:54 <dolio> Ah. Well that's nice.
19:56:01 <psyklops> Google, I ask you, what similarity at all do those videos have to that search term?
19:57:07 <thomashartman1> is there a way I can rollback darcs commits to a particular file, one after the other, till it's in a state that I like?
19:59:19 <psyklops> (5 stars even)
20:00:48 <dolio> Well, the mergesort I banged out in a day is now apparently just as fast as the introsort I've been playing with for quite some time now.
20:01:04 <thomashartman1> I guess I can just do darcs get --to-patch in some tmp dir and copy the file to my working dir.
20:01:36 <dolio> Moderately slower for reverse-sorted lists, but significantly faster for the introsort-worst-case test.
20:01:53 <roconnor> introsort?
20:02:15 <hpaste>  rwbarton pasted "compile-time regex errors" at http://hpaste.org/8519
20:02:20 <dolio> Introsort is quicksort that keeps track of its recursion depth and switches to heapsort if it thinks it's taking too long.
20:02:39 <rwbarton> mmorrow: I made it fail at compile time if the regex string is invalid, see hpaste
20:05:18 <mmorrow> rwbarton: omg mine works too!!@
20:05:43 <mmorrow> rwbarton: cool. quasiquotes are *very* exciting in their possibilities
20:06:17 <mmorrow> rwbarton: oh, nice *critical* fix :)
20:06:42 <roconnor> dolio: are you sorting lists?
20:07:02 <dolio> roconnor: Unboxed mutable arrays.
20:07:37 <dons> rwbarton: hey, is that pcre-light ?
20:07:49 <dons> and you're running it at compile time?
20:08:21 <roconnor> does it matter that they arrays are unboxed?
20:08:30 <roconnor> sorting is parametric
20:08:35 <rwbarton> dons: Yes
20:08:47 <dons> rwbarton: that's awesome.
20:09:11 <rwbarton> dons: But only to check that the pattern is valid, not to precompute its internal representation.
20:09:25 <dolio> It matters if you want really fast arrays.
20:09:52 <dons> rwbarton: right, that you could actually do as well though.
20:10:02 <dons> since pcre lets you persist the compiled bytecode (even to disk)
20:10:09 <dons> so you'd write a Regex -> ByteString function
20:10:16 <rwbarton> oh, neat
20:10:16 <dons> store it as a compiled regex literal (string)
20:10:26 <dons> and then use it at runtime with a ByteString -> Regex coercion
20:12:07 <mmorrow> rwbarton: i added your patch to the darcs repo, so darcs pull
20:13:21 <mmorrow> dons: doing the precomputation was what i first planned on doing, but that requires an instance of lift for Regex, which i'm not sure how one would write
20:13:38 <mmorrow> (an instance of TH.Lift)
20:14:17 <mmorrow> dons: or something equivalent
20:17:30 <roconnor> what is an ABI bump?
20:17:36 <roconnor> for a linux kernel?
20:22:47 <hpaste>  morrow annotated "compile-time regex errors" with "now added" at http://hpaste.org/8519#a1
20:23:12 <hpaste>  morrow annotated "compile-time regex errors" with "HsColour-ized src here:" at http://hpaste.org/8519#a2
20:25:55 <dmwit> roconnor: As I recall, the ABI tells about calling conventions and how C's structs are stored.
20:27:08 <roconnor> looks like I need to recompile loop-aes
20:31:30 <gwern> @quote cabal
20:31:31 <lambdabot> musasabi says: combining Cabal and autoconf is an evil and complex art.
20:33:21 <mmorrow> rwbarton: i didn't see what you meant with the QuasiQuotes flag until i built regexqq under 6.8.3 myself
20:33:50 <mmorrow> i fixed regexqq.cabal so it'll build under 6.8.3's cabal
20:36:04 <mmorrow> so a verified-working ghc-6.8.3 *with support for quasiquotes* made possible by audreyt's patch is and will be at: http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.tar.bz2
20:36:06 <lambdabot> http://tinyurl.com/6r7suq
20:38:14 <thomashartman1> byorgey: I rehackaged happs-tutorial. just specified all data files individually for this run. maybe I'll use neil mitchell's trick for a better package next time. More likely I'll just release with darcs-tag ;)
20:39:38 <dmwit> Okay!  Who wants to fill me in on the news of the last week?
20:39:48 <dmwit> Have any good bots arisen?  Has preflex gotten even better?
20:39:55 <dons> we've a hackage bot now
20:40:01 <dons> actually general rss2irc bots
20:40:01 <dmwit> ooo
20:42:26 <ivanm> dons: but couldn't it have a better real name than "tutorial bot"? :s
20:44:03 <monochrom> "artificial education lifeform prototype"
20:44:19 <ivanm> heh
20:44:24 <newsham> waaaallleeee
20:44:45 <ddarius> newsham isn't a shill
20:45:07 <newsham> but i do have an artificial education
20:45:13 <monochrom> haha
20:50:58 <mjrosenb> reads x :: ReadS Int
20:51:11 <mjrosenb> will that ever have more than 1 element in it?
20:51:53 <SamB_XP_> @src ReadS
20:51:53 <lambdabot> Source not found. :(
20:52:01 <SamB_XP_> @hoogle ReadS
20:52:01 <lambdabot> Prelude.ReadS :: type ReadS a
20:52:02 <lambdabot> Text.Read.ReadS :: type ReadS a
20:52:02 <lambdabot> Text.ParserCombinators.ReadP.ReadS :: type ReadS a
20:52:06 <SamB_XP_> arg.
20:52:07 <dolio> None of the read instances for built-in types are ambiguous, I believe.
20:52:35 <SamB_XP_> type ReadS a = String -> [(a, String)]
20:52:46 <hackage> New hackage package: happs-tutorial 0.2
20:52:46 <hackage> New hackage package: Pugs 6.2.13.5
20:52:47 <SamB_XP_> doesn't have an "element" per se...
20:53:17 <mjrosenb> SamB_XP_: element in a list
20:53:50 <mjrosenb> let y = reads x :: ReadS Int in length y
20:54:06 <mjrosenb> SamB_XP_: fine, will that ever return something other than 0 or 1?
20:54:25 <SamB_XP_> > reads ?x :: ReadS Int
20:54:25 <lambdabot>   Not in scope: `?'
20:54:41 <dolio> No.
20:54:42 <SamB_XP_> > \x -> reads x :: ReadS Int
20:54:43 <lambdabot>  Couldn't match expected type `ReadS Int'
20:55:02 <SamB_XP_> > \x -> reads x
20:55:03 <lambdabot>  Add a type signature
20:58:58 <dmwit> ?check \x -> length (reads x :: [(Int, String)]) < 2
20:59:05 <lambdabot>  OK, passed 500 tests.
21:00:08 <ddarius> Top-level uses of reads should never return more than one result.  In particular, the Int instance certainly won't.
21:01:31 <mjrosenb> > \x -> reads x :: String -> ReadS Int
21:01:33 <mjrosenb> yay for proving code correct
21:01:33 <lambdabot>  Couldn't match expected type `String -> ReadS Int'
21:01:35 <mjrosenb> is there anything like read that returns a Maybe?
21:01:47 <dmwit> :t listToMaybe . reads
21:01:54 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
21:02:26 <ddarius> @hackage safe
21:02:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safe
21:03:06 <mjrosenb> hrmm, guess what i have works
21:03:28 <dmwit> got something against reads?
21:03:40 <dmwit> ...or something against listToMaybe? ;-)
21:04:33 <mjrosenb> dmwit: it's about as much code as i already have
21:04:42 * dmwit nods
21:04:52 <mjrosenb> dmwit: and i already have this code
21:09:45 <fons> hi
21:10:13 <dmwit> Hiya, fons!
21:10:43 <fons> can someone tell me what are the runhaskell flags in http://darcs.haskell.org/bytestring/_darcs/prefs/prefs for?
21:10:59 <fons> $ runhaskell
21:10:59 <fons> runhaskell: syntax: runghc [-f GHC-PATH | --] [GHC-ARGS] [--] FILE ARG...
21:11:10 <mjrosenb> dons and fons?
21:11:10 <mjrosenb> my index finger won't like this
21:11:21 <fons> there is no sign of -i anywhere ..
21:11:39 <fons> yep, I guess it must be confusing
21:12:23 <ivanm> fons == The Fonz? :p
21:12:56 <fons> ivanm: damn, not again!
21:13:10 <ivanm> what? I've never said that before!
21:13:27 <fons> I didn't even know what The Happy Days were when people began colling me like that :)
21:13:49 <fons> ivanm: no, it's not you, people keep telling me
21:14:01 <fons> fons is just a shortenning for Alfonso
21:15:10 <ivanm> yeah, I guessed that from seeing your real name with /whois fons
21:15:48 <fons> oh ok
21:16:04 <fons> didn't even kown my irc client was providing my real name
21:16:07 <fons> know
21:16:39 <ivanm> stay online a bit more, I haven't finished downloading your credit history yet! :p
21:17:25 <fons> @seen dons
21:17:25 <lambdabot> dons is in #haskell, #ghc, #xmonad, #haskell-soc and #arch-haskell. I last heard dons speak 37m 24s ago.
21:17:50 <fons> he surely knows what those runhaskell flags are for
21:22:32 <fons> I'm just stupid, the -i is just used to include the libraries needed
21:22:40 <fons> forget about it
21:47:19 <povman> does anyone know how i can build editorStack in http://hpaste.org/8516?
21:50:45 <dmwit> Where is build defined?
21:51:08 <povman> in data EditorBuilder
21:51:10 <dmwit> You might want to consider dropping the "forall st. (EditorState st) =>" contexts on your data types.  (Maybe.)
21:52:09 <dmwit> How does it break?
21:52:36 <povman> dmwit: compile it
21:53:07 <povman> i need editorPool to be a collection of functions for building different instances of EditorState, which are all stored in a stack
21:53:35 <dmwit> What extensions should I enable?
21:53:41 <povman> -fglasgow-exts
21:53:46 <dmwit> boooo
21:53:54 <dmwit> You should know which extensions you're using. ;-)
21:54:25 <povman> i was going to figure it out but -fglasgow-exts worked
21:54:58 <dmwit> If -fglasgow-exts weren't so useful for playing around, I'd wish it didn't exist.
21:55:55 <povman> so, i need a heterogeneous collection of ((EditorState a) => Dynamic -> a) whose outputs are stored in a heterogeneous stack of (EditorState a) => a
21:56:19 <povman> i never need to know what type the EditorState actually is, just use the EditorState functions on it
21:57:16 <povman> without resorting to [Dynamic]...
21:57:38 <dmwit> How many instances are possible?
21:57:46 <dmwit> s/possible/planned/
21:57:47 <povman> \infty
21:57:57 <povman> they're supposed to be plugins
21:58:02 <dmwit> mm
21:58:19 <povman> unless [Dynamic] isn't as evil as i think
21:59:36 <povman> but it *feels* like existential wrappers should do the trick
22:00:30 <dmwit> Those are universals, not existentials... but I know what you mean.
22:00:54 <povman> i never understood how they got the name in the first place :)
22:01:04 <dmwit> Really?
22:01:21 <dmwit> Universal == works for all values in the universe.
22:01:38 <dmwit> Existential == works for some value in the universe (i.e. there exists some value for which it works).
22:01:40 <dmwit> anyway.
22:01:48 <dmwit> Is it possible to re-architect this?
22:02:08 <povman> i have a working version with EditorState as a type instead of a class, but it's awful
22:02:45 <dmwit> i.e. keep the same class declaration, but let the instance be something like
22:03:27 <dmwit> Well... modeled on the monad class, basically.
22:03:46 <dmwit> data SEState a = SEState a
22:03:50 <povman> :-|
22:04:39 <dmwit> Then the instance stays almost exactly the same.
22:04:52 <dmwit> Basically float all your forall's to the top-level.
22:05:18 <povman> which is the top-level?
22:05:37 <dmwit> value, selection, replace
22:05:45 <dmwit> They have implicit forall's in their types.
22:06:27 <dmwit> Think about it this way:
22:06:33 <dmwit> lists are always homogeneous.
22:06:38 <dmwit> So even if you have something of type
22:07:05 <dmwit> [EditorStateData (forall st. EditorState st => st)]
22:07:35 <dmwit> What you're really saying is that the EditorStateData structure has to be able to store a value of *any* instance of EditorState.
22:08:00 <dmwit> (i.e. each element of the list must store any instance, and you don't really get the effect you're looking for.)
22:08:09 <povman> what would EditorStateData be?
22:08:24 <povman> that sounds like the effect i want
22:08:39 <dmwit> At least, if I understand correctly: if you want each element of the list to use some different instance, but be nailed down to a particular instance.
22:08:39 <povman> i want a list of stuff i can apply value, selection, replace to and nothing else
22:09:04 <dmwit> povman: Presumably, though, you want each element nailed to a particular instance of EditorState, right?
22:09:36 <povman> i suppose... but once something is in there, i don't care
22:09:41 <dmwit> yeah
22:09:46 <dmwit> But that's the problem:
22:10:17 <dmwit> you want the creator of the data to choose the instance, but your type says the *user* of the data gets to choose the instance.
22:10:39 <povman> you mean [EditorStateV]?
22:10:44 <dmwit> yes
22:11:31 <povman> ok now i'm confused.
22:11:46 <dmwit> sorry...
22:12:21 <povman> if i have data ShowC = forall a. Show a => ShowC a, can't i show [ShowC]?
22:12:22 <dmwit> povman: Okay, suppose I have weeble :: EditorStateV.
22:12:29 <povman> ok
22:12:59 <dmwit> With a trivial pattern match, I get a new value foo :: forall st. EditorState st => st.
22:13:09 <dmwit> (Which is the thing I'm really interested in anyway.)
22:13:17 <dmwit> Now we're in familiar territory.
22:14:11 <dmwit> If I have instance EditorState Bar and instance EditorState Baz, then I expect as a programmer that I can use (foo :: Bar) and (foo :: Baz) anywhere in my code.
22:14:35 <dmwit> That is, the *user* of foo gets to decide what instance foo should get nailed down to.
22:14:47 <dmwit> foo has to be flexible enough to provide values of both types.
22:14:55 <dmwit> But what you want is something else:
22:15:17 <dmwit> you want to take a value of type Foo and stick it in a list with a value of type Bar without the compiler complaining.
22:15:22 <dmwit> I am not sure how to do this. =P
22:15:54 <fons> does anyone happen to know if there's a way to tell cabal to register/use packages from a different database other than the global or user ones?
22:16:14 <dmwit> What other one is there?
22:16:38 <fons> dmwit: you cannot create other databases other than the global and user?
22:16:53 <fons> and use them from ghc?
22:16:53 <dmwit> I've never heard of it.
22:17:01 <dmwit> Maybe you should tell what you're trying to do?
22:17:14 <fons> dmwit: I'm creating a testing script for darcs
22:17:38 <fons> which need to check that the package is compiled and installed properly
22:19:31 <dmwit> Ah, and you want to avoid poisoning the global or user package databases?
22:19:33 <dmwit> hum
22:19:40 <fons> dmwit: exactly
22:19:44 <Heffalump> well, a hack would be to symlink the user package db temporarily
22:19:56 <Heffalump> but that would race with other invocations of the same script etc
22:20:19 <fons> furthermore, I need to install because of postinstall hooks necessary for the correct behaviour of the code
22:20:20 <hpaste>  povman annotated "Fun problem" with "ShowC example" at http://hpaste.org/8516#a1
22:20:38 <povman> dmwit: what you just said doesn't work works in that example
22:21:34 <fons> Heffalump: what do you exactly mean?
22:22:40 <mwotton> stupid question: how do you make lambdabot actually respond to things? i have it joining a channel on my own server, but it just sits there when i try to run commands...
22:23:39 <dmwit> povman: Obviously I don't understand universals.  Maybe you should ask again, and I'll keep quiet this time. =/
22:24:25 <dmwit> mwotton: It shouldn't require anything special, try "?echo" and see what happens.
22:24:38 <povman> dmwit: sorry... (i hope you weren't being sarcastic)
22:25:01 <fons> OK, you can tell ghc to read other databases
22:25:02 <dmwit> Nope, I really don't understand universals. heh
22:25:03 <fons> -package-conf file
22:25:06 <mwotton> oh, so ?command works
22:25:20 <dmwit> mwotton: Yep, all commands have to be prefixed with ? or @ .
22:25:21 <fons> now the problem is how to tell cabal to install the package in that database
22:25:42 <dmwit> mwotton: The only exceptions are :t, :k, >, and a few miscellaneous stuff that respond to things in the middle of sentences.
22:25:45 <mwotton> ok. how do you get that evaluation thing then?
22:25:48 <mwotton> > 100
22:25:54 <lambdabot>  100
22:25:55 <dmwit> mwotton: Just like that. =)
22:26:09 <mwotton> gives me
22:26:09 <mwotton> 15:30 <blackdog> > 100
22:26:09 <mwotton> 15:30 <lambdabot>  fd:10: hClose: resource vanished (Broken pipe)
22:26:25 <dmwit> Oy, let's see if I have that answer still in my logs...
22:26:25 <mwotton> so i've clearly buggered something :)
22:28:58 <dmwit> Oh, look, I saved it on my web space.
22:29:01 <dmwit> http://dmwit.homelinux.com/blah.log
22:30:42 <dmwit> Although I see now later in the logs that it wasn't the solution.
22:31:00 <dmwit> In any case, you should maybe try to catch dibblego, who is the most recent person to tackle this, I think.
22:31:05 <mwotton> ok
22:31:11 <mwotton> thanks :)
22:34:13 <fons> oh, and Cabal has the register command, which allows me to do what I want, great!
22:35:13 <dmwit> mwotton: Did you #define USE_RESOURCE_WORKAROUND in scripts/Resource.hs?
22:35:18 <dmwit> If not, you should. =)
22:35:57 <sjanssen> dmwit: why?
22:36:04 * dmwit shrugs
22:36:08 <mwotton> i don't have a Resource.hs...
22:36:10 <dmwit> Because that's what fixed it for dibblego.
22:36:27 <sjanssen> I just removed the resource hack.
22:37:00 <dmwit> ?farber
22:37:00 <lambdabot> It's a hairy banana.
22:37:05 <dmwit> indeed
22:37:10 <sjanssen> I don't see how it could actually change anything (it's just a copy paste job of a module from the unix lib)
22:37:53 <dmwit> Apparently there's two implementations of rlimit, one that's straight-up FFI and one that does... something else.
22:38:04 * dmwit does not have a copy of the source to verify this with
22:41:00 <sjanssen> the old lambdabot code looks like a manually hsc2hs'ed version of the standard one with most of the resources and ResourceLimitInfinity/Unknown support removed
22:41:14 <sjanssen> http://darcs.haskell.org/package/unix/System/Posix/Resource.hs
22:41:23 <sjanssen> http://code.haskell.org/lambdabot/scripts/Resource.hs
22:41:30 <sjanssen> oh, well I guess the second is gone now
22:42:40 <sjanssen> anyway, if dibblego can't use lambdabot without the resources hack, I'd like to know
22:43:16 <sjanssen> I'd also like to know which madman added this resource hack in the first place
22:43:46 <dons> oh, is that was i mentioned earlier today?
22:43:57 <dons> i saw that runplugs was running out of control on code.haskell.org
22:44:02 <dons> like someone had disabled the resource limits
22:44:05 <sjanssen> hmm
22:44:36 <sjanssen> dons: tons of runplugs processes eating CPU and memory?
22:44:43 <dons> no, only 2.
22:44:48 <dons> but chewing away on the cpu
22:45:02 <dons>     installHandler sigXCPU (CatchOnce $ throwTo mainThread $ ErrorCall "Time limit exceeded") Nothing
22:45:05 <dons>     setResourceLimit ResourceCPUTime $ ResourceLimits cpuTimeLimitSoft cpuTimeLimitHard
22:45:08 <dons> looks ok though
22:45:11 <dons> http://code.haskell.org/lambdabot/scripts/RunPlugs.hs
22:45:19 <povman> what responds to :t?
22:45:21 <povman> :t 3
22:45:23 <lambdabot> forall t. (Num t) => t
22:45:41 <sjanssen> > let f :: Int -> Int; f x = f $! (x+1) in f 0
22:45:54 <lambdabot> Terminated
22:46:10 <sjanssen> dons: so that one worked
22:46:14 <povman> @yhjulwwiefzojcbxybbruweejw
22:46:14 <lambdabot> "\""
22:46:22 <sjanssen> dons: at least it seemed to, watching top
22:46:42 <dmwit> povman: What do you mean by "responds to"?
22:46:43 <prb> Haddock-2.x isn't building for me under 6.8.3.  Known issue?
22:46:53 <povman> lambdabot doesn't see :t
22:47:06 <dmwit> povman: In privmsg, you have to use ?ty
22:47:19 <povman> why not :t?
22:47:21 <dmwit> Also, :k -> ?kind
22:47:27 <dmwit> povman: hysterical raisins
22:47:43 <povman> heh.
22:48:22 <cjs> What's the canonical way to parse an int, with signature 'String -> Maybe Int'?
22:48:30 <cjs> read it and catch the exception?
22:48:35 <sjanssen> cjs: see reads
22:48:37 <sjanssen> @type reads
22:48:39 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:48:51 <sjanssen> > (reads "1" :: Int, reads "xyz" :: Int)
22:48:53 <lambdabot>  Couldn't match expected type `Int'
22:49:02 <sjanssen> oops, that isn't right
22:49:19 <cjs> Ah.
22:49:26 <sjanssen> > (reads "1" :: [(Int, String)], reads "xyz" :: [(Int, String)])
22:49:28 <lambdabot>  ([(1,"")],[])
22:49:58 <sjanssen> dons: I notice lots of zombie runplugs
22:50:31 <hpaste>  rwbarton pasted "panic with regex pattern" at http://hpaste.org/8520
22:50:34 <dmwit> :t \s -> reads s >>= ensure (null . snd)
22:50:36 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:50:43 <dmwit> whoops
22:50:51 <sjanssen> ensure?
22:50:55 <povman> @hoogle a -> Maybe a
22:50:55 <lambdabot> Prelude.Just :: a -> Maybe a
22:50:55 <lambdabot> Data.Maybe.Just :: a -> Maybe a
22:50:55 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
22:51:08 <dmwit> :t \s -> fmap fst . ensure (null . snd) =<< reads s
22:51:10 <lambdabot> forall a. (Read a) => String -> [a]
22:51:12 <povman> :t ensure
22:51:14 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
22:51:18 <cjs> case reads s of { [(i,"")] -> Just i; _ -> -> Nothing }
22:51:19 <dmwit> sjanssen: ensure p x = guard (p x) >> return x
22:51:34 <sjanssen> cjs: correct
22:51:59 <sjanssen> or: do [(i, "")] <- reads s; return i
22:52:00 <mmorrow> regex quasiquoter on hackage! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq
22:52:02 <lambdabot> http://tinyurl.com/6jskro
22:52:06 <dons> sjanssen: yeah, looks like the zombie handling of waitProcess at least is borked
22:52:15 <dons> that was one of the first things that worked :)
22:52:46 <hackage> New hackage package: regexqq 0.1
22:54:00 <rwbarton> @ask mmorrow Do regular expressions as patterns work for you?  I'm getting ghc panics, see http://hpaste.org/8520
22:54:00 <lambdabot> Consider it noted.
22:54:17 <quicksilver> cjs: case reads s of [(i,sp)] | all isSpace sp -> Just i
22:54:30 <quicksilver> cjs: would be slightly more consistent with 'read'. If you care about trailing whitespace
22:54:32 <dons> mmorrow: i'd recommend using a useful synopsis in the package description, along with examples
22:54:33 <mmorrow> rwbarton: yeah i noticed that a little bit ago, i think that part is missing from audreyt's patch
22:54:34 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
22:54:43 <dons> since this is what readers see, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq-0.1
22:54:44 <lambdabot> http://tinyurl.com/6h8ucj
22:54:45 <rwbarton> ah you're still here
22:54:49 <dons> which might be hard to work out why they'd use the package :)
22:55:05 <mmorrow> dons: yeah, i didn't realize what was going where. i'm gonna upload another with a better description
22:55:24 <cjs> quicksilver: this is an argument to a command line option I'm parsing, so actually "13 " is wrong.
22:55:37 <dons> Building regexqq-0.1...
22:55:37 <dons> Text/Regex/PCRE/QQ.hs:1:30: unsupported extension: QuasiQuotes
22:55:54 <dons> mmorrow: maybe put in some mention of whatever constraints are needed to make it build
22:56:07 <cjs> That do above didn't work for me, though. "Couldn't match expected type `Maybe t' against inferred type `[(a, String)]'" on the "reads s".
22:56:17 <mmorrow> dons: yeah, i had to fudge with the cabal file to get hackage to accept it, but unless you're using an unpatched 6.8.*, it should work
22:56:20 <cjs> Don't I have to lift it?
22:56:32 <quicksilver> yes
22:56:33 <sjanssen> mmorrow: unpatched?
22:56:43 <dons> mmorrow: so maybe add some text to the effect it uses the QuasiQuote extension, which exists where?
22:56:44 <quicksilver> sjanssen meant [(i,"")] <- return (reads s)
22:56:53 <mmorrow> dons: audreyt had a patch for 6.8.3 which adds QuasiQuotes to it
22:57:14 <dons> is it in ghc head?
22:57:21 <mmorrow> dons: i applied it and put a patched ghc at http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.1.tar.bz2
22:57:22 <lambdabot> http://tinyurl.com/6r7suq
22:57:32 <mmorrow> dons: yes, it should be in any 6.9
22:57:33 <hpaste>  brad pasted "get rss and print out titles and urls" at http://hpaste.org/8521
22:58:04 <mmorrow> dons: (if you *are* using 6.9, then i managed to break building on 6.9 while fudging the cabal file()
22:58:49 <cjs> Hm, but "[(i,"")] <- liftM reads s" doesn't work for me, because s is not an m a1, but just an a1.
22:59:28 <mmorrow> dons: the only workaround to have hackage accept it (it says "unknow extension QuasiQuotes" if it's anywhere in the cabal file) was to just have it be in a LANGUAGE pragma at the top of QQ.hs and nowhere else
22:59:32 <cjs> So what am I really supposed to be doing here?
22:59:44 <quicksilver> cjs: did you not see my answer? :
22:59:55 <quicksilver> cjs: <- return (reads s)
23:00:13 <cjs> I did, but was wanting to play with the version in the maybe Monad.
23:00:21 <dmwit> ...
23:00:36 <dmwit> That is in any monad.
23:00:43 <cjs> Oh.
23:00:56 <dmwit> (sadly)
23:01:05 <dmwit> fail--
23:01:37 <cjs> Darn, it's really taking me a while to pick up all this clever stuff in Haskell.
23:02:12 <cjs> I'd be looking much smarter to my client now if I'd chosen LISP instead. :-)
23:02:28 <dmwit> heh
23:02:35 <cjs> Right, I see; liftM is for use with >>=.
23:02:36 <hpaste>  povman pasted "copying things around" at http://hpaste.org/8522
23:02:41 <povman> aha ^^ distilled
23:02:45 <dmwit> looks-- for cjs ;-)
23:03:23 <cjs> "Err, yeah, it's the Monad thing, I think, no wait, is it a Monoid? Argh!"
23:04:01 <povman> cjs: monoid: a container you put stuff into, like a list or a maybe
23:04:15 <dmwit> povman: The first three lines + "g (ShowC x) = x" distills it even farther, if you're interested.
23:04:55 <cjs> Now, using GetOpt, in the function of a ReqArg, is there some way to signal that I couldn't parse the argument to the option?
23:05:18 <povman> er not quite
23:05:38 <cjs> Or do I just signal the error in the return value and check it later?
23:06:01 <cjs> What I'd really like is a way to add something to the errs array that comes out of getOpt.
23:06:27 <hpaste>  povman pasted "even more distilled" at http://hpaste.org/8523
23:09:39 <povman> ^^ Cannot use record selector `build' as a function due to escaped type variables
23:10:01 <povman> it's toally laaaaame
23:12:15 <cjs> Hm. So when I have 'opts { optStopAfter = i }', and I want to pass optStopAfter into the function using this, is there a way to do that? I.e., in the sense of 'opts { accessor = i }'?
23:13:08 <quicksilver> povman: well basically haskell existentials have to be explicitly tagged with a constructor.
23:13:13 <quicksilver> you can't subvert that.
23:13:27 <quicksilver> it's not a problem in practice
23:14:11 <hpaste>  dons annotated "get rss and print out titles and urls" with "curl + feed parser" at http://hpaste.org/8521#a1
23:14:59 <mmorrow> does anyone know how to use haddock's '>' markup to begin code lines in the "description:" section of a cabal file?
23:15:21 <mmorrow> (if the line(s) with > at the beginning aren't the first line(s))
23:15:29 <povman> quicksilver: in both builderList and showList, i don't care what actual type the elements are, only that they are instances of Show
23:16:02 <povman> so it feels like i should be able to copy between them
23:16:45 <povman> cjs: can you explain again?
23:17:42 <quicksilver> povman: and indeed you can.
23:18:00 <povman> but how?
23:18:11 <quicksilver> povman: case sc of ShowC a -> ShowBuilder a
23:18:33 <quicksilver> case sb of ShowBuilder a -> ShowC a
23:18:37 <quicksilver> respectively
23:19:03 <quicksilver> showList = map (\(ShowBuilder a) -> ShowC a) builderList
23:19:08 <cjs> povman: Given "data Rec = Rec { i, j :: Int }", I can update a record with "rec { i = 3 }", changing only i and leaving j as it was.
23:19:30 <mmorrow> easier question, how does one indicate a newline in haddock code sections @...@ ??
23:19:34 <cjs> However, I'd like to have a function that can update either i or j, based on an argument passed in.
23:19:51 <povman> quicksilver: i love you
23:19:52 <opqdonut> cjs: you just need to case over the argument
23:19:54 <cjs> But I don't think I can do that in a generic way, because in this usage, "i" and "j" are not functions (as they are for accessors), but syntax.
23:20:02 <opqdonut> or then you want functional references
23:20:04 <adu> can you have more than one library per Cabal file?
23:20:06 <opqdonut> ?where FRef
23:20:07 <povman> quicksilver: i've been working on this for like 6 months
23:20:17 <quicksilver> povman: you could have just asked :P
23:20:19 <opqdonut> ?bot
23:20:20 <povman> (not full time...)
23:20:26 <quicksilver> cjs: that's correct. sucks doesn't it?
23:20:26 <cjs> @botsnack
23:20:32 <cjs> Wow, she's left us again.
23:20:34 <quicksilver> cjs: "record selectors are not first class"
23:20:39 <quicksilver> cjs: try using lenses.
23:20:51 <opqdonut> cjs: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details <- or this
23:21:01 <opqdonut> (or is that a lens?)
23:21:07 <quicksilver> that is indeed a lens.
23:21:16 <povman> a lens is something like snd isn't it?
23:21:47 <quicksilver> povman: the details of the haskell type system mean that existentials need to be tagged with constructors to infer their types correctly, so existential heavy code ends up with explicit 'cases' as you unwrap.
23:21:54 <quicksilver> snd is only "half" a lense.
23:21:58 <povman> ohh
23:21:59 <quicksilver> snd is the deconstruction half.
23:22:05 <quicksilver> you need the reconstruction half too.
23:22:17 <quicksilver> a lense is like \(a,b) -> (a,\a' -> (a',b))
23:22:21 <povman> so unsnd :: (a,b) -> b -> (a,b)
23:22:37 <povman> sndlens :: (snd,unsnd)
23:22:38 <povman> ?
23:22:44 <quicksilver> right.
23:22:47 <povman> how extremely
23:23:00 <cjs> Hey, this FRef stuff is kinda neat.
23:23:02 <quicksilver> or my formulation saves one parameter.
23:23:05 <quicksilver> but it's the same idea.
23:23:07 <cjs> That's a lens?
23:24:05 <quicksilver> lens is a traditional name for what twanvl calls functional references.
23:24:26 <quicksilver> although lenses traditionally take the form s -> (v,v->s)
23:24:33 <quicksilver> instead of (s->v,s->v->s)
23:24:34 <mmorrow> regex quasiquoter hackage page, now with an up to snuff description: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq-0.2
23:24:42 <quicksilver> left-factoring the leftmost "s"
23:25:04 <cjs> What kind of type is (->)?!
23:25:15 <povman> cjs: function...
23:25:47 <povman> length :: (->) [a] Int
23:26:12 <cjs> Wow.
23:26:20 <nornagon> Prelude> :k (->)
23:26:20 <nornagon> (->) :: ?? -> ? -> *
23:26:45 <povman> think of type constructor syntax as similar to data constructors
23:27:03 <cjs> Ok, I just got confused because ":t (->)" in ghci gives me a parse error.
23:27:17 <quicksilver> because (->) doesn't have a type
23:27:19 <quicksilver> it *is* a type.
23:27:31 <quicksilver> just like ":t Int" doesn't make any sense.
23:27:44 <povman> > Left 4 :: Int `Either` Int
23:27:46 <cjs> Ah.
23:28:05 <povman> holy crap that works
23:28:14 <quicksilver> (actually it's a type constructor, but the point is the same)
23:29:01 <glguy> @seen dons
23:29:13 <povman> > 43
23:29:29 <nornagon> you can define infix type constructors too
23:29:34 <povman> > Integer :: 4
23:29:45 <nornagon> data Thingy a = a :+: a
23:30:01 <nornagon> er wait
23:30:04 <nornagon> that's .. not what i meant
23:30:10 * nornagon <-- confused
23:30:29 <dobblego> data :+: a = a `Thingy` a -- ?
23:30:32 <nornagon> that's an infix *data* constructor. Not sure if you can do it with types
23:30:34 <povman> you meant data a :+: b = A a b
23:30:37 <povman> or something
23:30:43 <nornagon> yeah, something like that
23:30:52 <nornagon> not sure if it's possible, in retrospect.
23:30:59 <povman> it just compiled
23:31:15 <povman> *Main> :t A 4 5
23:31:15 <povman> A 4 5 :: forall t t1. (Num t1, Num t) => t :+: t1
23:31:46 <dobblego> I read a paper the other day that used an infix type constructor; forget which it was though
23:31:50 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq-0.3
23:31:59 <mmorrow> done
23:32:25 <povman> when does ghc6.10 plan to release itself?
23:34:35 <nornagon> povman: oh, neat.
23:35:22 <povman> i was a complete newb at the start of the year and now i understand all this stuff
23:36:45 <^Someone^> "when does ghc6.10 plan to release itself?" I like that :D
23:52:47 <hackage> New hackage package: regexqq 0.4
23:52:47 <hackage> New hackage package: regexqq 0.3
23:52:47 <hackage> New hackage package: regexqq 0.2
23:53:48 <solrize> @remember povman when does ghc6.10 plan to release itself?
23:54:21 <rwbarton> ghc-HEAD builds, but won't install--wasn't someone here just having that problem?
23:54:44 <mmorrow> what's the reason it gives?
23:55:02 <rwbarton> some linker errors
23:55:20 <mmorrow> ooh crappy. does it by chance have to do with editline?
23:55:55 <hpaste>  rwbarton pasted "linked errors installing ghc-HEAD" at http://hpaste.org/8524
23:57:49 <mmorrow> rwbarton: i just looked through darcs changes for the pretty package in HEAD:
23:57:51 <mmorrow> Fri May 18 11:37:57 CDT 2007  Ian Lynagh <igloo@earth.li>
23:57:51 <mmorrow>   * Remove non-pretty-printing stuff (of base), and rename package to "pretty"
23:58:09 <mmorrow> maybe this has something to do with it??
23:58:18 <rwbarton> It's also missing stuff like base_GHCziBase_True_closure
23:58:30 <mmorrow> oh. i *hate* linker errors
23:58:37 <rwbarton> I'm going to see whether I can give that command the --make option
23:58:54 <mmorrow> come to think of it, what i suggested about pretty is ridiculous
