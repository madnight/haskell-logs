00:00:00 <mmorrow> one might say.
00:00:37 <newsham> oceanspray; ghc is used for many purposes, some of them include language research.
00:01:01 <OceanSpray> I am aware of that.
00:02:29 <newsham> that has advantages and disadvantages.
00:02:37 <newsham> you get cutting edge features, and perhaps featuritus
00:03:31 <ivanm> newsham: can't help feature bloat in ghc... it is, after all, sponsored by microsoft ;-)
00:03:59 <newsham> append only
00:06:46 <newsham> (at least your featuritus has formal underpinnings which dont conflict)
00:11:21 <newsham> > 2
00:11:21 <lambdabot>  fd:12: hClose: resource vanished (Broken pipe)
00:12:27 <roconnor> lack of expresitivity of the type system
00:12:35 <roconnor> oops
00:13:50 <roconnor> GADTs allows one to capture (some of) the dynmic nature of functions in the types.
00:14:15 <roconnor> without it s/True/False to a program, and it still typechecks
00:15:26 <newsham> > ()
00:15:33 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
00:15:41 <Cale> hmm...
00:15:44 <Cale> > ()
00:15:51 <lambdabot>  setResourceLimit: invalid argument (Invalid argument)
00:15:52 <Cale> @bot
00:15:55 <Cale> oh...
00:15:57 <lambdabot> :)
00:16:03 <roconnor> > 2+2
00:16:08 <lambdabot>  setResourceLimit: invalid argument (Invalid argument)
00:16:10 <Cale> damn, it's that thing again
00:16:17 <Cale> Someone got rid of Resource.hs?
00:16:34 <Cale> *sigh*
00:16:44 <newsham> does darcs have a "blame" command?
00:16:51 <glguy> annontate?
00:16:58 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
00:16:59 <Cale> Maybe I'll try upgrading GHC first to see if the bug in the posix library has been fixed.
00:17:02 <glguy> (only works on small repositories)
00:17:24 <hpaste>  newsham pasted "my runplugs is broken" at http://hpaste.org/8620
00:17:27 <glguy> lambdabot keeps giving me the same message
00:17:38 <glguy> @flush
00:17:46 <lambdabot> Not enough privileges
00:18:18 <Cale> newsham: remove L.o
00:18:33 <Cale> newsham: it appears to be built against oeis 0.1?
00:19:02 <newsham> that seems to have partially fixed it..  rm'ing *.o and rebuilding
00:19:49 <Cale> now what?
00:20:14 <hpaste>  newsham annotated "my runplugs is broken" with "still has error" at http://hpaste.org/8620#a1
00:20:27 <Cale> interesting
00:20:55 <newsham> do I have to manually build L.o?  its not in build anymore.
00:20:58 <Cale> remove all the .hi files to be sure as well
00:21:39 <newsham> doing that now and building clean
00:23:25 <Cale> I hope this posix resource bug is fixed in 6.8.3
00:23:55 <Cale> So I don't have to coerce darcs into giving me Resource.hs from before someone deleted it.
00:24:00 <newsham> yah, now it says "failed to load interface for 'L'.  I'm guessing the cabal build doesnt do everything the old build script did?
00:24:20 <Cale> well, hmm...
00:24:44 <Cale> L.hs gets reconstructed by the bot all the time
00:25:01 <Cale> So I'm betting it's actually the bot's responsibility to ensure it gets built.
00:25:03 <newsham> oh, i didnt run the bot yet, just runplugs
00:25:31 <newsham> hmm.. nope, still not loading.
00:26:03 <hpaste>  newsham annotated "my runplugs is broken" with "L not loading" at http://hpaste.org/8620#a2
00:26:14 <Cale> load up the bot and @undefine
00:26:22 <Cale> and see if that helps
00:26:38 <Cale> (that should copy Pristine.hs to L.hs and rebuild)
00:27:11 <newsham> oh, I think tihs is my fault.  I had previously built conal's Dif.hs and commented out the Dif that lambdabot was originally loading
00:27:18 <newsham> and onw I just erased my .hi's and .o's
00:28:06 <newsham> ok, after ?undefine its working now
00:29:21 <newsham> thanks for the help
00:30:18 <Cale> grr... the 6.8.3 binaries don't seem to want to work
00:30:23 <Cale> checking for path to top of build tree... configure: error: cannot determine current directory
00:31:45 <Cale> hmm, hacking the configure script worked
00:31:57 <Cale> It was using some custom pwd for some reason.
00:32:28 <Cale> A custom pwd which does nothing but give a floating point exception when run...
00:32:29 <Cale> hmm
00:32:36 <lorne> are you running debian stable?
00:32:49 <Cale> I have no idea what code.haskell.org is running :)
00:33:23 <Cale> oh, it seems that all these binaries give floating point exceptions.
00:33:25 <lorne> http://www.nabble.com/ghc-6.8.3-binary-dist-problem-td18134361.html
00:33:26 <lambdabot> Title: Nabble - Haskell - Glasgow-haskell-users - ghc-6.8.3 binary dist problem, http://tinyurl.com/6czebv
00:33:44 <Cale> ah
00:33:53 <Cale> So it's that libc is too old.
00:34:35 <Cale> okay then
00:34:44 <Cale> I suppose all that's left is to compile it.
00:35:07 <lorne> I was lazy and went with 6.8.2
00:35:40 <Cale> Now that I think about it, 6.8.2 had the same (or similar) problem on this machine.
00:38:07 <Cale> Oh well, I suppose that means it'll be at least a few hours until lambdabot's working properly again.
00:38:16 * Cale runs make in a screen and detaches.
00:39:04 <OceanSpray> aww.
00:40:05 <newsham> is that machine one of the few that has problems with the resource api?
00:40:46 <Apocalisp> What's a really good simple example problem for which concatMap is useful?
00:40:48 <newsham> or is it pretty common?
00:42:06 <OceanSpray> I wanted a lambdabot,
00:42:21 <OceanSpray> but building it was a pain in the ass.
00:42:35 <newsham> its getting simpler.
00:43:41 <Heffalump> Apocalisp: do you consider the list monad simple?
00:43:47 <Heffalump> or list comprehensions?
00:43:54 <Heffalump> if so, then desugaring either usually results in a concatMap
00:44:28 <newsham> lets say you wanted to collect square roots of a list [5,6,7] but you wanted to have both positive and negative roots.
00:44:49 <newsham> so you have   mysqrt x = [sqrt x, negate $ sqrt x]
00:45:08 <newsham> then if you   map mysqrt [5,6,7]   you dont get a flat list anymore, you get a list of lists
00:45:13 <newsham> but you can flatten it again with concat.
00:45:27 <newsham> so   concatMap mysqrt [5,6,7]   gives the flat list
00:45:41 <Apocalisp> how about a cartesian product?
00:45:45 <enzo_> Anyone: is there a function which alphabetizes a list of strings?
00:46:39 <newsham> sort?
00:47:22 <Cale> > sort (words "here is a list of strings to sort")
00:47:22 <lambdabot>  fd:10: hClose: resource vanished (Broken pipe)
00:47:26 <Cale> oh, right :)
00:47:26 <newsham> sort $ words "one two three four" -> ["four","one","three","two"]
00:47:55 <newsham> want a hot-swap bot?
00:48:43 <enzo_> omg cool!
00:49:16 <Cale> newsham: if you have a working lambdabot, that would be cool :)
00:49:27 <enzo_> lol
00:49:32 <newsham> > sort $ words "one two three four"
00:49:32 <lambdabot>  fd:10: hClose: resource vanished (Broken pipe)
00:49:33 <noBotE>  ["four","one","three","two"]
00:49:47 <newsham> feel free to /kick him when lbot's ready
00:49:52 <Cale> okay
00:50:21 <newsham> i'll probably be asleep
00:50:33 <Cale> Yeah, I might be too, by the time ghc finishes.
00:50:47 <Cale> We're still in stage1 of course :)
00:51:05 <Cale> newsham: You built with 6.8.3?
00:51:22 <newsham> no, this is 6.8.2
00:51:25 <Cale> Oh, right, there's no way to know what I want to know anyway without actually trying this :)
00:51:28 <Apocalisp> > let cartesian xs = (`fmap` x) . (*) =<< xs
00:51:29 <noBotE>  Parse error at end of input
00:51:45 <Apocalisp> > let cartesian xs = (`fmap` xs) . (*) =<< xs
00:51:45 <noBotE>  Parse error at end of input
00:52:01 <Cale> Didn't finish your let expression
00:52:06 <Cale> @let cartesian xs = (`fmap` xs) . (*) =<< xs
00:52:07 <noBotE> Thread 157a600 has exited with leftover thread-specific data after 4 destruct...
00:52:11 <Cale> uhh...
00:52:12 <Apocalisp> oh, @let
00:52:14 <Apocalisp> duh
00:52:14 <Cale> @let cartesian xs = (`fmap` xs) . (*) =<< xs
00:52:15 <noBotE> Defined.
00:52:17 <Cale> heh
00:52:28 <Cale> Sweet random flakiness
00:52:33 <Apocalisp> cartesian [1,2,3]
00:52:37 <Cale> > cartesian [1,2,3]
00:52:38 <noBotE>  [1,2,3,2,4,6,3,6,9]
00:52:38 <Apocalisp> > cartesian [1,2,3]
00:52:39 <noBotE>  [1,2,3,2,4,6,3,6,9]
00:52:39 <Apocalisp> gah!
00:53:49 <Apocalisp> > let cartesian xs = (\f -> fmap f xs) . (,) =<< xs in cartesian "cartesian"
00:53:50 <noBotE>  [('c','c'),('c','a'),('c','r'),('c','t'),('c','e'),('c','s'),('c','i'),('c',...
00:54:30 <HunterXHunter2> > cartesian "ab"
00:54:31 <noBotE>   add an instance declaration for (Num Char)
00:54:31 <noBotE>     In the expression: cartesian...
00:54:55 <Apocalisp> @let cartesian xs = (\f -> fmap f xs) . (,) =<< xs
00:54:55 <noBotE> <local>:2:15:     Occurs check: cannot construct the infinite type: a = (a, a...
00:54:58 <Cale> > let cartesian = join (liftM2 (,)) in cartesian [1,2,3]
00:55:00 <noBotE>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
00:55:18 <HunterXHunter2> nice
00:55:41 <Apocalisp> yes, yes, but I want to demonstrate concatMap, not liftM2 :)
00:55:56 <Apocalisp> ?src liftM2
00:55:56 <noBotE> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:56:05 <Apocalisp> ?. undo src liftM2
00:56:05 <noBotE> ()
00:56:16 <newsham> > (,) <$> [1,2,3] <*> [4,5,6]
00:56:16 <Apocalisp> boo
00:56:17 <noBotE>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
00:56:29 <Apocalisp> nice.
00:56:38 <newsham> applicable rules
00:56:56 <Apocalisp> applicable rocks
00:57:00 <dibblego> applicative?
00:57:04 <newsham> yah that
00:57:13 <Apocalisp> applicative is applicable
00:57:24 <newsham> i need sleep..  cheers.
01:03:39 <ziman> > liftM2 (,) [1, 2, 3]
01:03:40 <noBotE>  Add a type signature
01:03:58 <ziman> > liftM2 (,) [1, 2, 3] :: [[Int]]
01:03:58 <noBotE>  Couldn't match expected type `[[Int]]'
01:05:26 <Cale> > liftM2 (,) [1,2,3] [1,2,3]
01:05:27 <noBotE>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
01:06:52 <dibblego> ?type \f ma mb -> ma >>= \a -> fmap (f a) mb
01:06:53 <noBotE> forall (m :: * -> *) a a1 b. (Monad m, Functor m) => (a -> a1 -> b) -> m a -> m a1 -> m b Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
01:10:15 <ziman> > join (+) 5
01:10:16 <noBotE>  10
01:10:32 <ziman> got it
01:11:03 * ziman is still not familiar with the (-> (a)) monad
01:12:30 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
01:12:31 <noBotE>  ("Hello","olleH","HELLO")
01:12:49 <Cale> Does that example help? :)
01:13:44 <ddarius> conal: Is there a reason filterE and muxing/demuxing is not in the Reactive library?
01:14:10 <conal> ddarius: are you comparing with an older version?
01:14:10 <ziman> wow, more brain-twisting magic :)
01:14:44 <ddarius> conal: No, unless you consider Fran an older version.
01:15:17 <conal> ddarius: yeah, that's what i wanted to know.  i generalized filterE to filterMP (with Cale's help, iirc).
01:15:34 <conal> ddarius: which old mux/demux do you mean?
01:16:18 <ddarius> conal: I don't know if there was an old one, but a function of type (a -> Either b c) -> Event a -> Event (Event b, Event c) or something like that.
01:16:26 <ddarius> (or a generalization thereof)
01:17:18 <conal> ddarius: oh, i see, thx.  yeah -- easy to define via joinMaybes, and useful.
01:18:01 <conal> ddarius: i'd go for Event (Either b c) -> (Event b, Event c)
01:19:35 <conal> ddarius: for simplicity/orthogonality
01:19:54 <ddarius> Yeah, it's the difference of an fmap.  It's easy to go either way.
01:20:25 <ddarius> I guess the filterE I wanted is joinMaybes . fmap f
01:23:30 <paolino> haskell.org is under stress
01:24:10 <Myc> @pl \r -> x * + (x*r)
01:24:10 <noBotE> (line 1, column 11):
01:24:10 <noBotE> unexpected "\b"
01:24:10 <noBotE> expecting space or simple term
01:24:47 <Myc> action blinks. Did I he just send backspace cahba
01:25:26 <Myc> @pl \r -> x + (x*r)
01:25:26 <noBotE> (x +) . (x *)
01:26:50 <conal> Peaker: hi
01:31:15 <paolino> ping is responding, is haskellwiki down there ?
01:38:19 <ddarius> conal: Another question: is there a reason there is no runR?
01:56:25 <ziman> @src ((->) r) >>=
01:56:26 <noBotE> Source not found. Sorry.
01:56:51 <Deewiant> @src ((->) r) (>>=)
01:56:52 <noBotE> Source not found. Just what do you think you're doing Dave?
02:07:21 <gwern> @seen newsham
02:07:21 <noBotE> newsham is in #haskell-blah, #haskell and ##poetry. I last heard newsham speak 1h 9m 57s ago.
02:08:28 <gwern> @ask newsham fix your lambdabot problem ok? and yes, I do find it a bit odd keeping State/ under darcs control - but mangaging them as gzip'd binary files is even weirder
02:08:28 <noBotE> Consider it noted.
02:13:35 <pjdelport> @src (->) (>>=)
02:13:35 <noBotE> f >>= k = \ r -> k (f r) r
02:14:21 <pjdelport> ziman, Deewiant: you don't have to say ((->) r), for the same reason you don't have to say [r]
02:14:52 <Deewiant> but what about if there's one for (r ->) and a different one for (-> r) ;-)
02:15:06 <opqdonut> err, or rather for the same reason you don't write (Either String)
02:15:29 <opqdonut> Deewiant: in h98 the type in the "head" uniquely identifies the instance
02:15:39 <opqdonut> under ghc class system extensions not :)
02:15:52 <Deewiant> >_<
02:17:06 <opqdonut> yes, I realize it was a quip ;)
02:19:08 <opqdonut> it's kinda unintuitive that the monad type is in some arbitary kind and not *->*
02:21:01 <Cale> opqdonut: what?
02:21:26 <opqdonut> Cale: @src (->) (>>=) and @src [] (>>=)
02:21:34 <Cale> opqdonut: oh
02:21:41 <opqdonut> yeah, not in haskell, in lambdabot
02:22:03 <Cale> opqdonut: yeah, that's just the heading someone decided to give those bits of code :)
02:22:16 <Cale> gwern: any idea whose idea it was to remove Resource.hs?
02:22:20 <opqdonut> and, as i remarked, in h98 the head type identifies the instance
02:22:22 <opqdonut> right?
02:22:30 <Cale> opqdonut: yeah
02:26:07 <gwern> Cale: iirc, I didn't remove it
02:26:28 <Cale> gwern: Maybe it was sjanssen's patches.
02:26:30 <gwern> Cale: I wasn't going to mess with the > stuff until mueval was ready
02:27:14 <gwern> Cale: incidentally, I'm working through build problems with Plugin/Url.hs - do you see them?
02:27:22 <Cale> nope
02:28:19 <gwern> hum. problem is Network.URI conflicting with import Plugin
02:31:15 * Cale adds lambdabot-utils to the build script.
02:31:30 <Cale> Missed that.
02:31:45 <ski> lambdabot: @arr ?
02:32:02 <Cale> I just installed 6.8.3 here, so I should be able to catch problems arising from not having packages installed.
02:32:26 <Cale> I'm using cabal install in the lambdabot build script now.
02:34:31 <Cale> hmm, cabal-install is giving a strange error installing the unlambda package now.
02:34:40 <Cale> cabal: /home/cgibbard/darcs/lambdabot/.copyFile17828.tmp: copyFile: inappropriate type (Is a directory)
02:35:09 <Cale> that file doesn't exist at all
02:35:56 <Cale> hmm, it worked when I ran "cabal install unlambda" directly.
02:36:09 <Cale> very strange.
02:37:28 <Cale> (it was installing it as a prerequisite for installing lambdabot)
02:59:13 <dcoutts> @seen Saizan_
02:59:13 <noBotE> Saizan_ is in #haskell-blah and #haskell. I don't know when Saizan_ last spoke.
03:08:13 <enzo_> What is the file extension .lhs ? I'm trying to install a Cabal package and I can't seem to find a file Setup.hs. Only Setup.lhs.
03:08:31 <dcoutts> enzo_: it's another style of haskell module
03:08:46 <dcoutts> it's called a "literate" haskell script
03:09:17 <dcoutts> it's where the default is comments, with special markup for bits of code
03:09:22 <Peaker> @seen conal
03:09:22 <noBotE> conal is in #haskell. I last heard conal speak 1h 42m 32s ago.
03:09:36 <Peaker> conal, hey, was away
03:10:24 <_zenon_> I have a case of type-delirium
03:10:54 <_zenon_> Readin the "all about monads" tutorial on monads, on the chapter of State monad, in the definition for >>=
03:11:23 <_zenon_> I am not quite sure that I have _fully_ understood the type of     (f v)
03:11:33 <_zenon_> I guess it's (s -> (a,s))
03:11:45 <enzo_> dcoutts, instruction are telling me to; runghc  Setup.hs configure ...but there is no file Setup.hs, only Setup.lhs. did I download the wrong package?
03:13:09 <enzo_> or is there a way to transform "literate" haskell script into generic haskell script?
03:13:30 <enzo_> ...I'm pretty lost on this one
03:14:22 <ziman> sed -nr 's/^> //p' :)
03:14:52 <_zenon_> I reason: it "should" be (s -> (a,s)) since  runState :: (s -> (a,s)) , thus  s' is of type s, for runState to get a parameter of type s , (f v) s' must reduce to s.
03:17:07 <enzo_> nm,  I figured it out..
03:17:56 <_zenon_> Am I totally of?
03:24:44 <_zenon_> Someone willing to help a type-confused soul?
03:33:43 <iamabarnacle> _zenon, i think (f v) is of type State s a
03:34:44 <iamabarnacle> f is of type a -> m b, right?  then f v should give m b
03:34:59 <_zenon_> but what about runState ?
03:35:08 <_zenon_> runState is of type (s -> (a,s))
03:35:25 <_zenon_> should it not receive s?
03:35:44 <_zenon_> (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s'
03:35:59 <iamabarnacle> runstate is a field label
03:36:07 <_zenon_> 'doh!
03:36:11 <_zenon_> I forgot about that!
03:36:45 <iamabarnacle> therefore applicable only to state s a types
03:39:38 <_zenon_> so, f :: a -> m a, thus        (f v) s'     yields       State s[s'] a[v]
03:40:17 <Saizan_> dcoutts: pong
03:40:27 <_zenon_> and the field label plucks out the state transformer and hands it over to the type constructor.
03:41:18 <_zenon_> yes?
03:45:44 <_zenon_> yet another question
03:46:36 <_zenon_> newtype State s a = State { runState :: (s -> (a,s)) }
03:47:11 <_zenon_> yet, when defining State s a as a member of the Monad class, it's written instance Monad (State s) where
03:47:54 <_zenon_> why not instance Monad (State s a)
03:49:11 <BONUS> i think that the in the instance declaration, the s stands for the whole state data structure
03:49:25 <BONUS> or wait, no, hmm
03:52:42 <Saizan_> _zenon_: for the same reason you e.g. defined instance Monad Maybe where, because only types with kind * -> * can be a Monad
03:53:38 <Saizan_> because you must unify it with 'm' in the type of return and (>>=)
03:54:23 <Saizan_> this also guarantees that the instances work the same for every type 'a' used as parameter for the monad
03:54:33 <Saizan_> ?ty (>>=)
03:54:34 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
03:54:39 <Deewiant> O_o
03:54:45 <Deewiant> ?ty (>>=)
03:54:46 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
03:54:57 <Deewiant> ?ty (>>)
03:54:58 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
03:55:10 <_zenon_> So, if I haven't missunderstood it, in the "instance Monad (State s) " the s is the implicit type s as I suspected, okay, thank you for your answer Saizan_  :)
03:55:38 <Saizan_> s is the type of the state
03:55:57 <_zenon_> ops, didn't mean to type "implicit" there.
03:56:01 <_zenon_> yes.
03:56:11 <_zenon_> as you said: s is the type of the state
03:56:22 <_zenon_> wadlers paper on monads is really neat,
04:05:44 <_zenon_> Okay another question
04:06:02 <_zenon_> in the same example of the State monad (in the "all about monads" text)
04:06:37 <_zenon_> the getAny function getAny :: (Random a) => State StdGen a
04:07:15 <_zenon_> in the definition of it, it says do g <- get  ; (x, g') <- return $ random g
04:07:25 <_zenon_> now I am type-confused again
04:07:40 <Cale> _zenon_: what type are you confused about?
04:07:48 <_zenon_> random
04:07:55 <Cale> :t random
04:07:56 <noBotE> forall g a. (RandomGen g, Random a) => g -> (a, g) Thread 157a600 has exited with leftover thread-specific data after 4 destr
04:08:00 <Cale> heh
04:08:07 <_zenon_> g -> (a,g)
04:08:22 <RayNbow> Thread 157a600? :p
04:08:22 <Cale> yeah
04:08:28 <_zenon_> but get :: m s
04:08:39 <Cale> RayNbow: Something strange with newsham's machine
04:09:06 <Cale> m here is State StdGen
04:09:08 <_zenon_> are we "unboxing" the m s type to access the s ?
04:09:15 <Cale> and get :: State StdGen StdGen
04:09:31 <Cale> So g :: StdGen
04:09:41 <Cale> because it's the result of that action
04:10:23 <_zenon_> This is just the thing I feel is difficult to grasp.
04:10:59 <_zenon_>  do p <- e1; e2   { is rougly equal to }        e1 >>= \p -> e2          ?
04:11:16 <Cale> If x :: m a, in do-notation, if you have  v <- x, then v :: a
04:12:03 <_zenon_> yes! I have suspected it for long, but never got the courage to ask it if was so
04:12:14 <_zenon_> Now, I want to understand the mechanics for this
04:13:21 <Cale> Well, the exact mechanics vary based on which monad you're using, however, the usual idea is that x is an action being carried out, and the result is v.
04:13:57 <conal> Peaker, ddarius: ping
04:14:25 <Cale> But yeah, it desugars to bind like you said
04:14:36 <_zenon_> okay, therefore  in the example15:       get is type State s, thus g <- get is (s -> (a,s))
04:14:48 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
04:15:11 <Cale> get :: State s s
04:15:15 <Cale> so g :: s
04:15:25 <conal> ddarius: (re: "Another question: is there a reason there is no runR?").  no reason.  the newer unreleased version of Reactive does have runR.
04:15:26 <_zenon_> ops, forgot the s
04:15:28 <Cale> In this case, s is StdGen
04:16:02 <Cale> g <- get isn't itself an expression (so it doesn't have a type on its own), it's a statement in the do-block
04:16:37 <_zenon_> mhmm
04:17:15 <Cale> So g is a StdGen
04:17:37 <Cale> and then  random g :: (a, StdGen)
04:17:39 <smtms> 6
04:17:51 <Cale> that use of return is a bit funny.
04:18:00 <Cale> Normally, we'd use let
04:18:16 <_zenon_> yes, random takes (s -> (a,s)) thus it fits
04:18:27 <Cale> do g <- get; let (x,g') = random g; ...
04:18:36 <_zenon_> well I think return fits the purpose
04:18:46 <Cale> It's unnecessary to use it.
04:19:07 <Cale> let is what you normally use to make local definitions in a do-block
04:20:29 <_zenon_> but... since  y <- x is sugar for  x >>= \y ->         it makes sense for me at least that you must type construct first
04:21:35 <_zenon_> Cale: thank you a lot, this really cleared my clouded sky
04:22:06 <Cale> Oh, I should perhaps say it's necessary to use return here if you want to use <- to bind the result of random g, since that's not an action.
04:22:29 <_zenon_> that's right
04:26:13 <yitz> hi all. no bot today?
04:26:22 <oklopol> > "o"
04:26:23 <noBotE>  "o"
04:26:33 <yitz> ah, a different bot )
04:26:34 <oklopol> no bot e today
04:26:35 <yitz> :)
04:28:04 <FordCortina> @src fix
04:28:04 <noBotE> fix f = let x = f x in x
04:28:25 <Cale> actually... :)
04:28:46 * EvilTerran prefers "fix f = x where x = f x"
04:29:04 <Cale> er... no, it's still broken, grr
04:29:44 <Cale> now I'm getting stuff like /tmp/MMzgIy1667.o: unknown symbol `__stginit_QuickCheckzm1zi1zi0zi0_TestziQuickCheck_'
04:29:55 <Cale> I suspect because QuickCheck is installed as user.
04:30:08 <FordCortina> the "x" in "f x" is the same x being defined in the let right?
04:30:13 <Cale> FordCortina: right
04:31:51 <EvilTerran> FordCortina, take f = (1:) or something, that might make it clearer
04:31:56 <_zenon_> Cale: Okay yet another question: right under what I was just wondering about it says {put g'} and {return x}
04:31:58 <EvilTerran> "fix (1:) = x where x = 1 : x"
04:32:22 <Cale> _zenon_: okay
04:32:38 <_zenon_> Cale: so {put g' >> return x}
04:32:46 <Cale> yeah
04:33:56 <_zenon_> Cale: and   {by def::: put s = State $ \_ -> ((),s) } so { State $ \_ -> ((),g') >> return x }
04:34:29 <_zenon_> it seems to me that the put g' is "lost into the void"
04:34:48 <Cale> The put g' updates the current state to be g'
04:35:21 <Cale> It's probably best to understand how put works independently of actual occurrences of it :)
04:35:36 <_zenon_> indeed, but as I reason " >> " will not pass on the State to return
04:35:44 <Cale> No, it will.
04:35:57 <_zenon_>  m >> k           =  m >>= \_ -> k
04:38:18 <EvilTerran> or, for a (vagely) more true-to-life example: fix (\fac x -> if x > 0 then x * fac (x-1) else 1) = (let f = (\fac x -> if x > 0 then x * fac (x-1) else 1) f in f) = (let f x = if x > 0 then x * f (x-1) else 1 in f)
04:40:05 <yitz> > let f g n | n<2 = 1 | otherwise = n*g(n-1); factorial = fix f in factorial 4
04:40:07 <noBotE>  24
04:40:27 <_zenon_> Cale: what am I missing out ?
04:40:55 <Cale> _zenon_: well, look at the definition of >>= after that
04:41:13 <Cale> _zenon_: >> ignores the result of the action, but in put's case, the result is just ()
04:41:13 <Deewiant> @src State (>>=)
04:41:13 <noBotE> Source not found. You speak an infinite deal of nothing
04:42:18 <Cale> x >>= f = State $ \s -> let (s',v) = runState x s; (s'', w) = runState (f v) s' in (s'', w)
04:42:29 <Cale> or, if you prefer,
04:42:37 <Cale> x >>= f = State $ \s -> let (s',v) = runState x s in runState (f v) s'
04:43:03 <Cale> So if you want to specialise that definition to one for >>
04:43:36 <Cale> x >> y = x >>= \k -> y
04:43:38 <Cale> = State $ \s -> let (s',v) = runState x s in runState ((\k -> y) v) s'
04:43:49 <Cale> = State $ \s -> let (s',v) = runState x s in runState y s'
04:44:26 <Cale> So you see that the state is still getting passed along.
04:44:41 <Cale> It's the v, the result of the first action, which is being dropped.
04:44:57 <_zenon_> mmmmm
04:45:19 <Cale> (I may have gotten the pairs backwards there, but I'm being consistent, anyway :)
04:46:28 <_zenon_> it's so tricky
04:48:46 <_zenon_> Cale: thanks a lot,
04:50:09 <Cale> _zenon_: well, the definition of >>= and >> and so on are supposed to be studied and then forgotten about, trusted to create the intended effect :)
04:50:46 <Cale> _zenon_: It gets really complicated quickly if you start plugging in the definitions of everything and trying to reduce it all by hand... though you can do it if you want :)
04:51:45 <_zenon_> Cale: So how will I get the " natural " feeling of it? You mentioned one nice rule of thumb 1) g::m a , so in do x <- g , x will be a
04:53:18 * Maya-sama lix RayNbow~
04:53:38 <Cale> _zenon_: well, the intention is that the state is carried along from one action to the next... the result of running 'get' is the current value of the state (and it doesn't change the state), and the effect of running 'put x' is to update the state to x
05:00:09 <_zenon_> sorry for dropping out,
05:00:16 <_zenon_> my screen literally went black
05:01:14 <yitz> _zenon_: looks like Cale's screen also went black
05:02:19 <yitz> _zenon_: Cale's last message before you both dropped out was: well, the intention is that the state is carried along from one action to the next... the result of running 'get' is the current value of the state (and it doesn't change the state), and the effect of running 'put x' is to update the state to x
05:02:44 <_zenon_> mhm..
05:02:54 <_zenon_> okay, I really want to thank Cale for the help
05:03:15 <yitz> _zenon_: you can leave a message with the bot
05:03:51 <yitz> @help tell
05:03:51 <noBotE> tell <nick> <message>. When <nick> shows activity, tell them <message>.
05:04:19 <_zenon_> Okay :)
05:14:59 <ski> (_zenon_ : your GNU screen ?)
05:15:21 <shapr> @yow !
05:15:21 <noBotE> Couldn't find fortune file
05:15:51 <_zenon_> ski: how do you mean?
05:15:59 <ski> ..
05:16:08 <shapr> hej ski!
05:16:16 <shapr> god morgon!
05:16:19 <ski> hej shapr :)
05:16:47 <ski> min dator vaknade idag efter 53 dagars sömn
05:18:35 <_zenon_> darn it it happened again
05:18:42 <ski> wb _zenon_ : <http://en.wikipedia.org/wiki/GNU_Screen>
05:19:35 <_zenon_> ski: no
05:19:56 <_zenon_> ski: I am using kde, and this is xchat
05:20:11 <_zenon_> however I should take a look at this strange malfunction
05:20:34 <ski> ok
05:21:07 <ski> (however i think it is possible to run xchat under GNU screen)
05:21:33 <Cale> ski: Only in text mode, of course :)
05:21:43 <lorne> does xchat have a text mode?
05:21:51 <Cale> lorne: yeah
05:23:12 <_zenon_> I think it was the translucency setting in kde
05:23:21 <_zenon_> Cale: thank you so much for your help
05:23:24 * Cale is not sure what to do with these link errors given that unsafeEval_ doesn't seem to give me anything sensible if I tell it to pass --make on the GHC commandline.
05:23:34 <Cale> _zenon_: no problem
05:24:32 <ski> Cale : i didn't know about text-mode .. i was thinking of cursed-gtk
05:25:48 <_zenon_> here we go again :)
05:26:06 <oklopol> http://www.willamette.edu/~fruehr/haskell/evolution.html <<< can someone actually read the combinatory version?
05:26:06 <noBotE> Title: The Evolution of a Haskell Programmer
05:26:27 <ski> <http://zemljanka.sourceforge.net/cursed/screenshots/xchat-1.png> <http://zemljanka.sourceforge.net/cursed/screenshots/xchat-2.png>
05:26:59 <oklopol> ski: you must own with combinators, do you read that?
05:27:11 <_zenon_> Well yes.
05:27:33 <_zenon_> The S , K are part of the standard combinators in Lambda calculus
05:27:34 <ski> oklopol : error : cannot parse "own with combinators"
05:27:52 <oklopol> ski: be good with em
05:28:16 <shapr> ski: VarfÃ¶r sovde din dator 53 dagars? Var du pÃ¥ semester i ett andra land?
05:28:39 <oklopol> varför all the svenska?
05:29:29 <ski> shapr : nej, datorn bestämde sig plötsligt för att inte svara på någonting .. när den vaknade trodde den fortfarande att det var 10 sjunde maj (och alla program var fortfarande igång)
05:29:59 <olsner> for 53 days!?
05:30:20 <shapr> That's pretty bizarre.
05:30:30 <shapr> oklopol: Well, it seemed like a fun thing to do at the time.
05:30:42 <ski> oklopol : shapr har bott i sverige (och i finland, iirc) .. jag tror han gillar att prata icke-modersmäl ibland
05:31:04 <oklopol> ski: what's his modersmäl then?
05:31:08 <shapr> jo
05:31:17 <shapr> Alabamsk
05:31:19 <ski> oklopol : alamabian, iirc
05:31:22 * shapr laughs
05:31:32 <oklopol> i don't actually know what that is.
05:31:36 <shapr> @wikipedia Alabama
05:31:38 <noBotE> No Result Found.
05:31:38 <ski> (/me thinks that sounds a bit like "albanian" :)
05:31:52 <ski> olsner : last two times it was only 15 days each ..
05:31:56 <shapr> oklopol: http://en.wikipedia.org/wiki/Alabama
05:32:18 <shapr> Alabamsk Ã¤r en skoj...
05:32:42 <ski> (ett skämt)
05:32:50 <oklopol> yeah, i got it
05:32:52 <shapr> I've been picking up some Brazilian Portuguese lately.
05:33:03 <ski> hur så ?
05:33:29 <shapr> Well, there's this thoroughly attractive Brazilian woman I've been flirting with ...
05:33:33 <olsner> ski: so what do you do when your computer hangs for a couple of weeks? wouldn't you normally just hit the reset switch after a while?
05:33:42 <shapr> ski: Yeah, that's what I would do.
05:34:44 <ski> olsner : well, i was about to give up .. (i had unsaved buffers in emacs, so i was hoping it would wake up)
05:35:08 <olsner> lol
05:35:18 <shapr> I think I'd wait about ... fifteen minutes? But only if I had something else to do during those fifteen minutes.
05:35:26 <oklopol> couldn't you have replaced that data in the ages you spent waiting? :P
05:35:39 <ski> (olsner : i had another session on a uni server, so i wasn't totally in abstinence ..)
05:36:41 <ski> oklopol : i didn't remember exactly what was in the fifteen-odd buffers i had
05:38:46 <telemach> yo :)
05:38:55 <shapr> y0 telemach, how's code?
05:39:29 <telemach> hm.. it works ... not.
05:39:37 <gwern> I would only wait 10 minutes, because I set emacs to save temps every 100 keystrokes or so
05:39:43 <gwern> thus, I wouldn't lose a whole lot
05:40:02 <telemach> i'm doing some quantum information processing stuff. ^^
05:40:11 <oklopol> i save about every 5 seconds automatically, sort of a reflex
05:40:11 <gwern> also, computers generally recover within 15 minutes or not at all in my experience
05:40:21 <telemach> (compression of quantum states)
05:40:31 <gwern> if I had valuable stuff unsaved, maybe I'd try the magic sysrq keys, or sshing in
05:40:33 <shapr> Sounds like fun. I'm playing with xmpp/jabber.
05:40:40 <_zenon_> telemach: would you like to explain a bit about it?
05:40:42 <gwern> (but that's pretty rare)
05:40:44 <ski> gwern : apparently not in my case, though
05:41:07 <shapr> ski: Having a suspended computer wake up after 53 days sounds pretty magical.
05:41:11 <telemach> it's not exactly fun, but it's ok.
05:41:27 <ski> (ssh:ing didn't work .. no response at all .. except that the display monitor showed the same frozen X image the whole through)
05:41:28 <shapr> I would think that it would never come back if it hadn't come back in the first hour or so.
05:41:46 <telemach> my prof told me to compare the performance of three compression algorithms
05:42:06 <shapr> My prof told me I should go back to school.
05:42:10 <telemach> schumacher compression, quantum huffman compressing and arithmetic coding
05:42:25 <_zenon_> telemach: first, what is quantum compression? :)
05:42:26 <olsner> I'd have reset the computer after 30 seconds at most
05:42:53 <telemach> huffman and arithmetic coding can be generalized to work qubits.
05:43:02 * ski maybe is patient bordering on the insane, at least in some cases ..
05:43:06 <telemach> of course, the formulation is quite different.
05:43:24 * gwern vaguely wonders how long a computer could run without being usable or eternally looping/unproductive - which I guess would reduce to figuring out the busy beaver for a given computer
05:43:46 <telemach> you see, a bit can 0 or 1, while a qubit is in a superposition of 0 and 1
05:44:02 <telemach> qubit = c1 |0> + c2 |1>
05:44:11 <telemach> c1 and c2 are both complex numbers
05:44:19 <ski> any ones ?
05:44:55 <telemach> the big problem is: qubits cannot be copied in general.
05:45:11 <telemach> ("no-cloning theorem")
05:45:26 <_zenon_> uhoh.. w8, what does |0> and |1> mean?
05:45:39 <ski> "ket"s
05:45:44 <telemach> these are the basis states.
05:46:18 <telemach> in principle, one might say they are vectors.
05:46:23 <ski> <http://en.wikipedia.org/wiki/Bra-ket_notation>
05:46:35 <telemach> |0> = (1, 0) and |1> = (0, 1)
05:46:52 <_zenon_> mmmmmm
05:46:55 <_zenon_> okay, go on
05:48:03 <telemach> you can't process qubits like in the "classical" sense.
05:48:40 <telemach> qubits have to be transformed with an unitary operator.
05:48:54 <telemach> otherwise you'd loose information.
05:49:36 <telemach> during the processing the input qubits are consumed.
05:50:25 <telemach> that's why quantum compression algorithms have to be formulated as unitary matrices.
05:51:02 <ski> `unitary' meaning `(two-sided) invertible' ?
05:51:29 <telemach> U^+ = U^(-1)
05:52:13 <ski> left-hand-side being (conjugate) transpose ?
05:52:27 <telemach> yes, the adjoint.
05:54:12 * ski wonders whether this entails unit determinant or not
05:54:13 <telemach> though i'm not sure what an unitary matrix represents in an information processing sense.
05:54:21 <telemach> it does.
05:54:48 <telemach> sort of like an orthonormal matrix.
05:56:51 * ski ought to read a few papers on quantum logic
05:57:04 <telemach> nah, don't
05:57:10 <ski> why ?
05:57:17 <telemach> take care of your brain's health. ^^
05:57:32 <ski> that's why i ought to read it
05:57:53 <ski> it's only healthy to explode your brain, from time to time
05:58:07 <ski> (also i'm interested in how quantum logic compares to linear logic)
05:58:08 <_zenon_> hehe
05:58:15 <telemach> imo quantum logic isn't that interesting.
05:58:46 <telemach> quantum mechanics is a lot more fascinating.
05:59:56 <telemach> most people i know agree that quantum mechanics is the most interesting topic in physics.
06:00:05 <qubit666> indeed
06:00:38 <hpaste>  Andy pasted "instance Eq ..." at http://hpaste.org/8622
06:00:43 <telemach> but it's hard at the beginning.
06:01:00 <telemach> there are quite a few good books.
06:01:03 <qubit666> quantum decoherence -> unitary so one does not have to 'look' at the process and thereofree does not decohere
06:01:05 <And[y]> there you see, my paste. i would be happy if someone could tell me how to do that :)
06:01:24 <qubit666> i think ...
06:01:29 <qubit666> correct me if im wrong pls
06:01:41 <vixey> instance Eq BasedNumber where
06:02:13 <And[y]> the problem is: i don't know how i actually can call my function for comparison in instance Eq ...
06:02:15 <vixey>  BasedNumber d1 b1 == BasedNumber d2 b2 = b2d b1 d1 == b2d b2 d22
06:02:36 <telemach> no, decoherence is that decay of quantum states due to external influences.
06:02:41 <telemach> that = the
06:03:06 <telemach> to prevent decoherence you have to cool atoms down to 0 kelvin.
06:03:37 <telemach> obviously this isn't possible, so one has to error correction codes.
06:03:40 <And[y]> hah, that works, thank you vixey ... i feel kinda dumb now :D
06:03:41 <telemach> +use
06:03:51 <And[y]> i spent almost 2 hours trying to figure that out myself -.-
06:04:22 <vixey> And[y]: A lot of times looking at examples or the bit in the references saves time guessing
06:04:50 <And[y]> do you know one good page on the net that has a lots of samples available? :>
06:04:52 <telemach> decoherence is the biggest stumbling in quantum computing. :/
06:05:03 <And[y]> something like a tutorial site?
06:05:06 <vixey> there's tonnes of haskell code everywhere
06:05:18 <vixey> I meant to look at actual programs people wrote not really tutorials
06:05:22 <vixey> but they are useful also
06:05:31 <And[y]> thats true ... but on most pages theres only code ... but no comments on what the code is actually supposed to do :D
06:06:12 <telemach> ï»¿in fact, i believe that decoherence will ultimately prevent the construction of quantum computers.
06:06:17 <vixey> the code should have some meaning
06:07:07 <telemach> (yes, i'm very pessimistic.)
06:08:33 <dcoutts> @type (>=>)
06:08:34 <noBotE> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:09:09 <telemach> i even think it's a waste of time, just like the "string theory"
06:09:57 <_zenon_> what do you think about the string theory?
06:10:11 <Cale> telemach: Well, noise doesn't prevent analog computers from producing results.
06:10:25 <telemach> cale, exactly
06:10:49 <telemach> analog computers are small, fast and hardly need energy
06:11:21 <telemach> quantum computers on the other hand generally need a LOT of energy just for cooling.
06:11:38 <telemach> and you can't program them like usual computers.
06:11:52 <vixey> who wants to program in the usual way ...?
06:12:00 <telemach> they are a productivity killer.
06:12:01 <_zenon_> you are talking of it as if it exists quantum computers?
06:12:12 <telemach> vixey, everyone who's got a job to be done.
06:12:25 <vixey> um....
06:12:33 <telemach> quantum computers do exist, but only for a small number of qubits
06:13:19 <telemach> there are plenty different physical implementations
06:13:19 <b_jonas> telemach: oh sure, but that doesn't actually prove it's possible to build large quantum computers with human technology
06:13:51 <telemach> that's what i believe, too.
06:14:14 <_zenon_> define small number of qubits? :)
06:14:16 <kryptiskt> everybody knows heavier than air flight is impossible
06:14:22 <telemach> 2 - 3
06:14:30 <vixey> kryptiskt!!
06:15:47 <_zenon_> telemach: well okay, since I obviously :) know nothing about this, how do the physics-world define a quantum computer consisting of 2 -3 qubits?
06:15:58 <_zenon_> how do we define computer?
06:18:13 <b_jonas> _zenon_: well, there are precise definitions like turing machine and stuff
06:18:29 <b_jonas> there are also ones that define abstract machines with limited memory
06:18:43 <b_jonas> similarly, there's a currently accepted defn for a quantum computer
06:18:51 <_zenon_> b_jonas: yes, but which definition is used for these quantum computers?
06:19:13 <telemach> simple. it processes qubits :).
06:19:15 <b_jonas> of course if it turns out that it's not possible to realize a quantum computer with that defn, then there'll be a new one
06:19:37 <telemach> (using a mixture of measurements and unitary operators)
06:19:41 <b_jonas> and then research about quantum computer algorithms with the old defn will mostly stop
06:20:39 <telemach> there are proofs that certain gates are "universal", i. e. they can be used to realize every quantum operation.
06:21:23 <_zenon_> mmm
06:21:30 <telemach> unitary matrices can be decomposed into logic gates.
06:21:58 <telemach> it depends on the physical implementation what logic gates are available.
06:23:19 <telemach> you can construct circuits somewhat similar to digital circuits.
06:23:19 <_zenon_> soooo..... how do we connect this to haskell again? (seeking some stable ground) :)
06:24:01 <telemach> you can't.
06:24:16 <telemach> haskell evaluates one expression after another.
06:24:50 <telemach> quantum computers evaluate all possible paths at the same time and thus require a fundamentally different way of thinking.
06:24:59 <telemach> bad luck, dude ;).
06:25:07 <shapr> Has anyone else tried haskell-xmpp?
06:25:16 <b_jonas> telemach: yep, the phisical interpretation, exactly
06:25:17 <qubit666> curry haskell was a student of Hamiton?
06:25:29 <qubit666> Hamilton?
06:25:41 <b_jonas> it's not easy to build it in the real world with current technology yet
06:25:45 <vixey> if everyone was averted to fundamentally different way of thinking there wouldn't be 430 poeple here
06:25:49 <b_jonas> whereas we can build normal computers
06:25:49 <qubit666> we'll find a way
06:25:54 <Beelsebob> telemach: eh? why does Haskell evaluate one expression after the other?
06:25:54 <b_jonas> I'm sitting near one
06:25:56 <qubit666> no doubt
06:25:57 <_zenon_> telemarch: why not construct all possible models and evaluate them sequentially?
06:26:04 <Beelsebob> where in the spec does it say "you must evaluate in this order"?
06:26:08 <qubit666> i like your idea zenon
06:26:19 <Beelsebob> what you mean is "current haskell implementations are sequential"
06:26:23 <Beelsebob> not "haskell is sequential"
06:26:30 <telemach> whatever.
06:26:31 <jpcooper> hello
06:26:35 <shapr> hi jpcooper
06:26:40 <jpcooper> could anyone link me to how threads are done in ghc?
06:27:13 <telemach> quantum are truly parallel in the most general sense.
06:27:14 <Beelsebob> jpcooper: in a variety of ways, but probably best to start with the Control.Concurrent module
06:27:28 <telemach> (and that's a big problem, too!)
06:27:30 <jpcooper> thanks
06:27:31 <Beelsebob> and enable -threaded and then +RTS -N<number of system threads wanted>
06:27:42 <shapr> jpcooper: http://www.haskell.org/haskellwiki/Concurrency_demos ?
06:27:44 <b_jonas> jpcooper: there was something on the wiki
06:27:50 <Beelsebob> jpcooper: the other thing you might want to look at is the par construct
06:27:53 <noBotE> Title: Concurrency demos - HaskellWiki
06:28:02 <telemach> beelsebob, imagine a "quantum if".
06:28:09 <jpcooper> will do
06:28:31 <shapr> telemach: So, are you implementing these compression schemes in Haskell?
06:28:48 <telemach> "if" takes a boolean expression and returns one of two results.
06:29:06 <_zenon_> telemach: the list monad then for you :)
06:29:18 <_zenon_> for several possible results
06:29:23 <telemach> a quantum computer uses both results (qubit = superposition of two bits)
06:29:33 <shapr> telemach: So, how to connect this to Haskell again?
06:29:37 <telemach> shapers, yes
06:29:44 <telemach> shapr..
06:30:01 <telemach> haskell has a nice linear algebra library.
06:30:25 <telemach> and haskell... is haskell. do i need more reason? ^^
06:30:34 <qubit666>  Curry Haskell was supervised by David Hilbert
06:30:54 <shapr> telemach: Well, Haskell is the topic for #haskell...
06:30:59 <qubit666> Hilbert is a big name in Q Physics
06:31:15 <_zenon_> telemach: and so the circle is complete
06:31:16 <_zenon_> :)
06:31:16 <qubit666> on a tnagent yes, but related no the less
06:31:22 <qubit666> :P
06:32:12 <povman> why doesn't the ghc macport install opengl? i can't even see how it misses it
06:32:15 <telemach> hey, someone asked me what i'm doing, so i started babbling, ok? :)
06:32:20 <shapr> ok!
06:32:33 <qubit666> im listening tele' even if it is Off the topic
06:32:42 <qubit666> mwahahahaaa
06:33:19 <vixey> @qeal
06:33:19 <noBotE> pork steaks taste like dick
06:33:23 <telemach> i hardly dare to say it... there's a world besides haskell :).
06:33:23 <qubit666> was listening gtg cya :)
06:33:38 <telemach> ok, bye
06:33:41 <_zenon_> noBotE now thats! offtopic
06:33:53 <shapr> Has anyone else used xmpp from Haskell?
06:33:58 <_zenon_> nop
06:34:07 <_zenon_> well... surely someone, but not me
06:34:49 <_zenon_> why do people use XOR so little?
06:35:14 <skorpan> xor do they?
06:35:17 <_zenon_> "Would you like coffe och tea" ? Should be coffe XOR tea
06:35:26 <_zenon_> right?
06:35:39 <mar77a> because they have a trauma about not killing the giant baby in XEN from hl
06:35:42 <_zenon_> or , at least social rules force the semantics of {or} to xor
06:36:18 <_zenon_> which is interesting, that a boolean function is semantically altered by social rules.
06:36:36 <vixey> -_-
06:36:47 <_zenon_> it's like social rules behave like function-transformers :P
06:36:52 <yitz> _zenon_: xor and or are used properly in lojban.
06:37:21 <yitz> _zenon_: which tells you something about that idea, i suppose
06:37:27 <_zenon_> yes of course
06:38:07 <_zenon_> I was trying to get a haskell discussion going here :)
06:38:30 <mauke> XOR is (/=) in Haskell
06:39:18 <mar77a> why didn't they go with (!=) :(
06:39:43 <b_jonas> mar77a: the third alternative is (<>)
06:39:51 <vixey> and use for(int i = 0; i < 100; i++) { .. instead of this stupid recursion nonsense
06:39:59 <b_jonas> mar77a: and then there's (~=) too
06:40:00 <mauke> mar77a: because ! is an indexing operator
06:40:14 <yitz> b_jonas: pattern match
06:40:32 <mar77a> dunno
06:40:39 <mar77a> feels like trying to be original where you shouldn't
06:40:48 <mauke> > let a != b = a ! b == b in (!=)
06:40:49 <noBotE>  Add a type signature
06:40:53 <mauke> :t let a != b = a ! b == b in (!=)
06:40:54 <noBotE> forall i. (Ix i) => Array i i -> i -> Bool Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
06:40:56 <vixey> mar77a: Your background is C or Java or something
06:40:58 <mauke> wat
06:41:00 <b_jonas> mar77a: I think it's not original to haskell, /= was used somewhere else too
06:41:02 <vixey> mar77a: That's just you, not everyone
06:41:04 <yitz> @let (!=) = (/=)
06:41:05 <noBotE> <local>:2:7:     Ambiguous type variable `a' in the constraint:       `Eq a' ...
06:41:14 <telemach> i'm off
06:41:17 <telemach> bye!
06:41:26 <mauke> :t let a != b = a ! b == b in (!=)
06:41:26 <noBotE> forall i. (Ix i) => Array i i -> i -> Bool
06:41:36 <_zenon_> bye
06:41:38 <mauke> @let a != b = a ! b == b
06:41:39 <noBotE> Thread 157a600 has exited with leftover thread-specific data after 4 destruct...
06:41:47 <yitz> @let (!=) :: Eq a => a -> a -> Bool; (!=) = (/=)
06:41:48 <noBotE> Defined.
06:41:57 <mauke> noooo
06:41:57 <yitz> > 3 != 5
06:41:58 <noBotE>  True
06:42:12 <b_jonas> yitz: also set precedence
06:42:20 <mar77a> i wonder what was the reason behind using (/=) and not other operator
06:42:34 <mauke> because /= is the closest approximation of â‰ 
06:42:35 <yitz> Well, it's less violent than (.) = fmap :)
06:42:46 <mar77a> ah that makes sense
06:43:55 <yitz> @let infix 4 /=; (!=) :: Eq a => a -> a -> Bool; (!=) = (/=)
06:43:55 <noBotE> <local>:3:44:     Multiple declarations of `L.!='     Declared at: <local>:2:...
06:44:02 <yitz> @undef
06:44:02 <noBotE> Undefined.
06:44:06 <yitz> @let infix 4 /=; (!=) :: Eq a => a -> a -> Bool; (!=) = (/=)
06:44:07 <noBotE> <local>:1:8: Not in scope: `/='
06:44:17 <mauke> @let a != b = a ! b == b
06:44:18 <noBotE> Defined.
06:44:19 <yitz> @let infix 4 !=; (!=) :: Eq a => a -> a -> Bool; (!=) = (/=)
06:44:20 <noBotE> <local>:2:44:     Multiple declarations of `L.!='     Declared at: <local>:1:...
06:44:23 <mauke> hah!
06:44:28 <yitz> ya got me
06:44:42 <mauke> > 1 != 2
06:44:43 <noBotE>   add an instance declaration for (Num (Array i i))
06:45:20 <yitz> mauke: well, are you quite satisfied?
06:45:54 <mauke> > listArray (0, 9) [0 .. 9] != 3
06:45:55 <noBotE>  True
06:46:16 <mauke> now it's consistent with C
06:46:27 <vixey> mauke: wonderfuly, bridging the gap
06:46:35 <ziman> > listArray (0, 9) [0 .. 9] != 30
06:46:36 <noBotE>  Exception: Error in array index
06:47:04 <yitz> mauke: easy to crash programs. yes, quite like C.
06:47:27 <yitz> :)
06:47:38 <yitz> got to go. bye all. have fun..
06:48:29 <ivanm> @type first
06:48:30 <noBotE> Not in scope: `first'
06:48:40 <mauke> @index first
06:48:40 <noBotE> Control.Arrow
06:48:43 <ivanm> what? lambdabot is down again? :o
06:48:46 <ivanm> @hoogle first
06:48:46 <noBotE> A Hoogle error occured.
06:48:50 <ivanm> :@
06:48:52 <mauke> preflex: seen lambdabot
06:48:52 <preflex>  lambdabot was last seen on #haskell 5 hours, 59 minutes and 20 seconds ago, saying:  fd:10: hClose: resource vanished (Broken pipe)
06:49:00 <ivanm> lol
06:49:42 <ivanm> OK, can noBotE do @pl?
06:49:44 <ivanm> @help
06:49:44 <noBotE> help <command>. Ask for help for <command>. Try 'list' for all commands
06:49:51 <ziman> just try it
06:49:53 <ziman> (it can)
06:50:05 <ivanm> @pl \ (x,y) -> (f x, y)
06:50:05 <noBotE> first f
06:50:20 <ivanm> which is what I thought... so why wn't it work? :s
06:50:28 * ivanm looks at his code again
06:51:32 <_zenon_> going for a shower
06:51:36 <ivanm> oh, wait, I was using the wrong function :s
06:51:50 * ivanm bangs his head against the desk, making sure to miss any electrical equipment
06:52:23 * _zenon_ (shower :: showerMonad a)
06:52:27 <ivanm> heh
06:52:47 <ivanm> @pl concat . unfoldr f
06:52:47 <noBotE> join . unfoldr f
06:52:58 <ivanm> didn't think there'd be a nicer function
06:53:09 <vixey> :t concat . unfoldr ?f
06:53:10 <noBotE> Not in scope: `unfoldr'
06:53:13 <_zenon_> what does @pl do?
06:53:19 <shapr> pointless
06:53:24 <_zenon_> ahhhh
06:53:25 <mauke> @help pl
06:53:25 <noBotE> pointless <expr>. Play with pointfree code.
06:53:26 <shapr> it turns a pointful function into point-free.
06:53:27 <Japsu> _zenon_: it tries to convert your function to point-free style
06:53:32 <b_jonas> how does that work?
06:53:34 <_zenon_> so nice :)
06:53:34 <b_jonas> @src first
06:53:34 <Japsu> @quote stereo!
06:53:34 <noBotE> Source not found. Sorry.
06:53:34 <noBotE> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
06:53:40 <b_jonas> @type first
06:53:41 <noBotE> Plugin `type' failed with: invalid ghci output: no type signature
06:53:56 <vixey> noBotE sucks
06:54:05 <Japsu> @pl \xs -> concat (map f xs)
06:54:05 <noBotE> (f =<<)
06:54:06 <shapr> @seen lambdabot
06:54:06 <noBotE> I saw lambdabot leaving #haskell and #haskell-blah 6h 4m 22s ago, and .
06:54:08 <b_jonas> wouldn't (mapf f) work btw?
06:54:09 <shapr> aww
06:54:35 <_zenon_> where is the function of this point free reduction system?
06:54:37 <ivanm> b_jonas: for what?
06:54:45 <_zenon_> can you download it and have at your ghci fingertips?
06:54:46 <ivanm> _zenon_: in lambdabot's code
06:55:01 <shapr> vixey: aw, come back!
06:55:05 <ivanm> so you can try getting goa to work... not sure if that's been updated :s
06:55:22 <b_jonas> ivanm: for \ (x,y) -> (f x, y)
06:55:24 <shapr> Yeah GHCi on Acid is lambdabot inside ghci.
06:55:33 <b_jonas> oh no, it wouldn't
06:55:48 <_zenon_> well the @pl seems mostly like some fun stuff....
06:55:53 <b_jonas> that would affect the snd, not the fst
06:55:54 <_zenon_> ok, really have to go take that shower
06:56:10 <ivanm> @type mapf
06:56:11 <noBotE> Plugin `type' failed with: invalid ghci output: no type signature
06:56:14 <b_jonas> that reply with "first" seems fishy to me
06:56:16 <ivanm> never heard of mapf before...
06:56:26 <b_jonas> maybe I'm confusing it with fmap
06:56:33 <ivanm> b_jonas: why? first f (x,y) = (f x, y)
06:56:35 <b_jonas> I think both exist but I don't know which one is which
06:56:39 <ivanm> @type fmap
06:56:40 <noBotE> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:56:51 <b_jonas> ivanm: but what's "first"?
06:57:00 <b_jonas> where does it come from or what's its type?
06:57:05 <b_jonas> @hoogle first
06:57:05 <noBotE> A Hoogle error occured.
06:57:10 <ivanm> b_jonas: in terms of tuples, applys the function to the first value in the pair
06:57:26 <b_jonas> is it an arrow thing?
06:57:28 <ivanm> > :t first
06:57:28 <ivanm> first :: (Control.Arrow.Arrow a) => a b c -> a (b, d) (c, d)
06:57:28 <noBotE>   parse error on input `:'
06:57:31 <ivanm> yup
06:57:41 <b_jonas> I see
06:59:21 <b_jonas> thanks
07:00:14 <mauke> > inRange (2, 4) 4
07:00:16 <noBotE>  True
07:00:32 <mauke> :t any
07:00:33 <noBotE> forall a. (a -> Bool) -> [a] -> Bool
07:02:50 <wjt> @ty inRange
07:02:51 <noBotE> forall a. (Ix a) => (a, a) -> a -> Bool
07:02:54 <wjt> excellent
07:05:02 <Deewiant> @instances Ix
07:05:02 <noBotE> Couldn't find class `Ix'. Try @instances-importing
07:06:53 * shapr boings
07:07:19 <int-e> @instances-importing Data.Array Ix
07:07:19 <noBotE> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
07:08:06 <shapr> ooh
07:08:10 <shapr> That's handy.
07:08:45 <b_jonas> those are only the ones in Prelude
07:08:48 <b_jonas> that sucks
07:10:14 <ivanm> b_jonas: well, you _could_ do all the ones in the standard lib.... but as for any other, that means that every time a new lib or version comes out you'd have to re-process it all
07:10:20 <ivanm> since AFAICT it uses an internal db
07:10:34 <b_jonas> ivanm: not all in standard lib
07:10:47 <b_jonas> but lambdabot imports lots of modules by default
07:10:51 <b_jonas> for convenience with eval
07:10:53 <ivanm> that's why I said you _could_
07:10:56 <ivanm> *nod*
07:11:16 <ivanm> but it looks like noBotE is a stripped-down lb (possibly old version?)
07:11:16 <b_jonas> it imports most normally and some of them by an alias (Data.Seq => S; Data.Map => M iirc)
07:11:19 <mauke> @index inRange
07:11:19 <noBotE> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
07:11:33 <b_jonas> luckily the docs list more Ix
07:14:02 <ski> @index boing
07:14:03 <noBotE> bzzt
07:15:00 <mauke> bah, why is text transformation so much easier in perl
07:15:38 <b_jonas> mauke: yeah, that's one of the biggest strengths of perl
07:17:12 <_zenon_> mauke: what do you want to do?
07:17:26 <mauke> $s =~ s/($dere)|z([[:xdigit:]]+)U/defined $2 ? chr hex $2 : $dez{$1}/eg;
07:18:17 <_zenon_> xhumm
07:18:32 <_zenon_> can you explain it?
07:19:09 <mauke> I have a table of translations
07:19:16 <b_jonas> what's $dere contain?
07:19:27 <mauke> a regex for keys %dez
07:19:37 <b_jonas> ah, I see
07:19:39 <mauke> that way I know that the lookup succeeds
07:19:41 <ivanm> dammit, turns out that FGL already has a function similar to one I spent ages developing :@
07:19:52 <ivanm> mine's fancier though ;-)
07:20:45 <adekoba> I'm trying to build soegtk, which imports System.Time (of package old-time), and I get an error saying that old-time is hidden. I tried exposing it, but I still get the same error. Note that this error only occurs when building with cabal. If I use ghc --make, everything works fine. What is going wrong?
07:23:06 <mauke> > all isDigit "Â¹"
07:23:07 <noBotE>  False
07:23:14 <mauke> > length "Â¹"
07:23:15 <noBotE>  1
07:23:23 <adekoba> ah. apparently, cabal hides all packages by default. It's a dependency error
07:23:35 <mauke> > length "\1Â¹"
07:23:36 <noBotE>  2
07:23:45 <_zenon_> mauke: ?
07:23:58 <mauke> oh wait
07:24:03 <ziman> > length "Â¹Â²Â³"
07:24:04 <noBotE>  3
07:24:18 <mauke> _zenon_: I need to know what is* do with unicode
07:24:23 <mauke> except I don't because I'm using bytestrings anyway
07:26:17 <_zenon_> a monadic question
07:26:39 <mar77a> > length ""
07:26:40 <noBotE>  0
07:26:49 <mar77a> length []
07:26:54 <mar77a> > length []
07:26:55 <noBotE>  0
07:26:55 <_zenon_> in all about monads
07:27:00 <mar77a> > [] == ""
07:27:01 <noBotE>  True
07:27:02 <_zenon_> example13
07:27:04 <_zenon_> the list monad
07:27:09 <vixey> :t ("",[])
07:27:10 <noBotE> forall a. ([Char], [a])
07:27:18 <_zenon_> {do x <- (return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word ""))}
07:27:22 <mar77a> > 1:2:3:""
07:27:23 <noBotE>   add an instance declaration for (Num Char)
07:27:24 <_zenon_> will x be of type Parsed ?
07:27:49 <vixey> > 1:2:3:([] :: [Char])
07:27:50 <noBotE>   add an instance declaration for (Num Char)
07:27:54 <_zenon_> because { foldM parse init s }
07:28:07 <_zenon_> >:i foldM
07:28:50 <_zenon_> foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:29:07 <_zenon_> in the list monad, m a is [a]
07:30:04 <_zenon_> parse matches the type signature for (a -> b -> m a) by Parsed -> Char -> [Parsed]
07:30:26 <_zenon_> init however is of type Parsed, but how can that be when it was a whole list?
07:31:31 <FordCortina> :t (!!!)
07:31:32 <noBotE> Not in scope: `!!!'
07:33:48 <FordCortina> anybody know what (!!!) does?
07:33:53 <vixey> nothing
07:33:57 <ski> @index (!!!)
07:33:57 <noBotE> bzzt
07:34:00 <ski> @index !!!
07:34:00 <noBotE> bzzt
07:34:05 <Beelsebob> @hoogle (!!!)
07:34:06 <noBotE> A Hoogle error occured.
07:34:09 <vixey> FordCortina: Where did you see it?
07:34:13 <FordCortina> http://www.haskell.org/haskellwiki/Memoization#Efficient_tree_data_structure_for_maps_from_Int_to_somewhere
07:34:14 <noBotE> Title: Memoization - HaskellWiki, http://tinyurl.com/2w22yf
07:34:25 <FordCortina> in the memoizeInt function
07:34:27 <vixey> FordCortina: "Look up the node for a particular number
07:34:27 <vixey> "
07:34:35 <vixey> FordCortina: The defiition is there
07:34:40 <FordCortina> ah
07:34:41 <ski> _zenon_ : @type init
07:34:41 <FordCortina> sry
07:34:48 <FordCortina> thanks
07:34:49 <vixey> FordCortina: Node a tl tr !!! 0 = a
07:34:57 <vixey> FordCortina: can be viewed as (Node a tl tr) !!! 0 = a
07:35:13 <_zenon_> ski: what do you mean?
07:35:31 <ski> _zenon_ : iow "what is the type of `init' ?"
07:35:43 <b_jonas> > :t init
07:35:43 <noBotE>   parse error on input `:'
07:35:43 <_zenon_> yes, precisely my questio
07:35:47 <b_jonas> >:t init
07:35:55 <FordCortina> is lambdabot on holiday? :D
07:36:17 <mauke> preflex: zdec xmonadzm0zi7_XMonadziCore_zdf27_closure
07:36:17 <preflex>  xmonad-0.7_XMonad.Core_$f27_closure
07:36:18 <b_jonas> anyway, my ghc says it's "init :: [a] -> [a]"
07:36:24 <_zenon_> yeah , mine too
07:36:26 <ski> b_jonas : i'd be `@type init' (or `:t init') .. no `> ' should be used .. however, `init' is probably not a standard thing
07:36:30 <b_jonas> or did you mean inits?
07:36:33 <_zenon_> I didn't know it could access that?
07:36:45 <b_jonas> ski: it is
07:36:48 <b_jonas> it is standard
07:36:59 <vixey> what's zdec?
07:37:12 <ski> b_jonas : or rather, the `init' that _zenon_ speaks of, is not the standard thing (forgot about the standard thing for a moment there :))
07:37:34 <vixey> like c++filt?
07:37:54 <mauke> vixey: sort of
07:38:07 <ski> _zenon_ : alternatively, if you don't know the type of `init', it might help if you could point to the code in question where `init' is defined
07:38:13 <mauke> the ghc symbol mangling is called "z-encoding"
07:38:17 <vixey> :t init
07:38:18 <noBotE> forall a. [a] -> [a]
07:38:32 <vixey> mauke oh ok I didn't know about this
07:38:38 <_zenon_> parseArg s = do init <- (return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word ""))
07:38:41 <ski> (vixey : i'm positive that's not the one _zenon_ is talking about ..)
07:38:46 <b_jonas> ski: oh yeah
07:38:47 <vixey> ski oh sorry
07:38:48 <ski> _zenon_ : ty
07:38:49 <b_jonas> I see
07:39:11 <_zenon_> then he does a foldM over it
07:39:25 <_zenon_> with it*
07:39:27 <b_jonas> _zenon_: that's not a definition
07:39:29 <ski> _zenon_ : and is `foldM parse init s' a subsequent command in that `do'-expression ?
07:39:30 <_zenon_> foldM parse init s
07:39:40 <_zenon_> ski: yes
07:39:40 <vixey> :t foldM
07:39:41 <noBotE> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:39:43 <b_jonas> I mean, it doesn't define init
07:39:52 <vixey> in that case init has type a
07:40:06 <_zenon_> b_jonas: I have not said anything about definition?
07:40:11 <ski> b_jonas : it locally does
07:40:30 <b_jonas> oh, I see
07:40:36 <b_jonas> it's init <-
07:40:39 <b_jonas> so it defines it
07:40:40 <_zenon_> so, my problem is that I don't get the types to go together in my head
07:40:40 <ski>   (return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word "")) :: m x
07:40:46 <ski> for some type `m' and `x'
07:40:47 <_zenon_> ski: yes
07:40:49 <ski> so
07:40:53 <ski>   init :: x
07:40:58 <ski> for the same type `x'
07:41:02 <_zenon_> there is where it stops for me
07:41:04 <ski> so if
07:41:16 <_zenon_> foldM should take a list, yes?
07:41:16 <ski>   Hex 0 :: Parsed
07:41:18 <ski> then
07:41:22 <ski>   init :: Parsed
07:41:33 <_zenon_> foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:41:39 <ski> _zenon_ : i believe the `s' argument to `foldM' is the list argument
07:41:53 <ski>   foldM parse init s
07:41:57 <ski> count youself
07:42:08 <_zenon_> indeed, but init was a list first
07:42:13 <_zenon_> and now it turned into a single element
07:42:13 <ski> where ?
07:42:17 <_zenon_> that is what i mean
07:42:23 <_zenon_> m x => x
07:42:26 <ski> where were `init' a list ?
07:42:30 <ski> no
07:42:45 <_zenon_> there :  (return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word "")) :: m x
07:42:50 <ski> `(return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word ""))' is a monadic action
07:42:59 <ski> maybe a list here, it is not clear
07:43:35 <ski> the result `init' that you get on the left-hand-side of the `<-' is not of same type as this monadic action (perchance a list)
07:44:09 <ski> `init' is the "monadic return value / result" of the monadic action
07:44:20 <_zenon_> yes I roger that.
07:44:22 <ski> have you seen the `IO'-monad ?
07:44:30 <_zenon_> yes.
07:44:36 <ski> there we have
07:44:41 <ski>   getLine :: IO String
07:44:49 <_zenon_> sure
07:45:12 <_zenon_> and we can get the string  by x <- getLn
07:45:15 <ski> this is *not* a line read, this is an action that *when*performed* will give back a line string
07:45:18 <ski> right
07:45:23 <ski> same with your `init'
07:45:44 <_zenon_> yes, but what is type-confusing me is that init is a parse
07:46:00 <_zenon_> however, when used with the foldM it is performed for "each one "
07:46:15 <_zenon_> even if it is not [x]
07:46:31 <ski> `init' is some parse we conjure up, so that we have something to start with
07:46:58 <_zenon_> composed of several m x
07:47:18 <_zenon_> ski: do you understand what I have trouble understanding ? :)
07:47:44 <ski> hm
07:47:47 <ski> you have
07:47:52 <ski>   parse :: Parsed -> Char -> [Parsed]
07:48:02 <ski> what may be confusing you is that this returns a list
07:48:06 <ski> yes ?
07:48:24 <_zenon_> no , not taht
07:48:26 <_zenon_> that*
07:49:05 <_zenon_> maybe I just need to look a bit more on the definitions....
07:49:31 <_zenon_> :t >>
07:50:06 * ski btw thinks this seems to be a somewhat strange way to parse ..
07:50:12 <ski> @type (>>)
07:50:13 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:50:23 <esteth> Is there a way to fetch, configure and install cabal packages from hackage automatically? It gets annoying to have to download a package, then download all it's dependencies and their dependencies, and so on.
07:50:54 <vixey> esteth: cabal install
07:50:55 <mauke> esteth: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
07:51:02 <noBotE> http://tinyurl.com/2sj7lw
07:51:27 <esteth> Lovely :D Thanks vixey and mauke
07:51:27 <_zenon_> ski: what makes me go round is that the init is an initial parse setup which  "was a list"
07:51:46 <_zenon_> and then we treat it as a single element
07:51:48 <ski> `init' in no way "was a list"
07:51:54 <_zenon_> m x
07:51:59 <ski> `init' was "arbitrarily selected from" a list
07:52:56 <ski> the list was a list of `Parsed' values .. `init' can be thought of as "any (not any one in particular)" element of that list
07:53:34 <_zenon_> all values in the list
07:53:37 <ski> in execution, all the possible values for `init' will be tried .. and the resulting final lists for these three elements will be concatenated
07:54:19 <ski> > do x <- [2,3,5]; y <- [400,900]; return (x+y)
07:54:20 <noBotE>  [402,902,403,903,405,905]
07:54:29 <ski> do you understand that example ?
07:54:38 <_zenon_> yeah
07:54:45 <_zenon_> when you said that about all possible
07:54:46 <_zenon_> it klicked
07:54:53 <ski> the list monad is similar to list comprehensions
07:54:56 <ski> ok, goof
07:55:00 <ski> s/f/d/ :)
07:55:13 <_zenon_> just that I didn't get that it was implicit ALL possible
07:56:02 <ski> just remember that since haskell is lazy .. if you only look at the first element of the final resulting list, then probably it won't go through all the later "iterations"
07:56:04 <b_jonas> it's not ALL possible, rather ANY possible if you imagine the result as a list of possibilites as well
07:56:14 <ski> > head (do x <- [2,3,5]; y <- [400,900]; return (x+y))
07:56:15 <noBotE>  402
07:56:41 <Deewiant> @undo [(x+y) | x <- [2,3,5], y <- [400,900]]
07:56:41 <noBotE> concatMap (\ x -> concatMap (\ y -> [(x + y)]) [400, 900]) [2, 3, 5]
07:58:11 <_zenon_> okay
07:58:23 <ski> b_jonas : hm .. clarify your distinction ?
07:58:34 <_zenon_> now, did you understand the possibility of mash-up?
07:58:57 <b_jonas> ski: well, I don't actually know what "ALL possible" would mean in that context
07:59:05 <b_jonas> so um, I can't
07:59:39 <b_jonas> ALL seems like an iteration or quantor of some kind, whereas by ANY I mean nondeterminism
08:00:06 <ski> b_jonas : and i don't know what "ANY possible" would mean in the ".. all the possible values for `init' can be .." .. so maybe we're even ? ;)
08:00:19 <ski> @type any
08:00:19 <noBotE> forall a. (a -> Bool) -> [a] -> Bool
08:00:20 <ski> @type all
08:00:20 <noBotE> forall a. (a -> Bool) -> [a] -> Bool Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
08:00:31 <_zenon_> hmmm something like this ???
08:00:35 <_zenon_> { do x <- y ; f   ==  y >>= \x -> f  }  by def { m >>= f  = concatMap f m } ==> concatMap foldM parse [theexpression] s
08:00:42 <_zenon_> although not quite right
08:02:23 <ski> (b_jonas : ok .. i was using `any' for nondeterminism too .. and `all' for the concrete explanation in terms of the underlying list operations)
08:02:29 <vixey> How is equality defined for coinductives in OTT?
08:02:54 <ski> _zenon_ : do you have any commands after the `foldM parse init s' command in the `do'-expression ?
08:03:01 <b_jonas> ski: I see
08:03:04 <_zenon_> ski: nope
08:03:16 <esteth> Is the version of zlib on hackage broken for anyone else? I can't compile it.
08:03:23 <_zenon_> ski: it's the list monad example from "all about monads"
08:03:37 <ski> _zenon_ : what about possible commands between the `foldM ..' and the `init <- ..' commands ?
08:03:49 <_zenon_> ski: none
08:03:56 <ski> _zenon_ : probably i've not read that particular example
08:04:00 <ski> ok
08:04:50 <ski>   concatMap (\init -> foldM parse init s) ((return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word ""))')
08:04:50 <_zenon_> ski: http://www.haskell.org/all_about_monads/html/listmonad.html#example
08:04:51 <noBotE> Title: The List monad, http://tinyurl.com/4akbey
08:04:55 <ski> is your translation
08:05:20 <ski> s/'//
08:05:30 <ski> @undo do init <- (return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word "")); foldM parse init s
08:05:30 <noBotE> (return (Hex 0)) `mplus` (return (Digit 0)) `mplus` (return (Word "")) >>= \ init -> foldM parse init s
08:05:55 <_zenon_> ski: yes, that's what I was trying to build, the do x <- y notations somewhat make it difficult so grasp the whole mechanism "behind"
08:06:14 <ski> ok
08:06:31 <_zenon_> therefore I saw the init like a single value,
08:06:42 <_zenon_> but when you write it without sugar
08:06:49 <_zenon_> it becomes visible what things are
08:07:30 <_zenon_> at least until I have gotten more comfortable with the { do x <- y } notation
08:07:31 <ski> `init' is still of type `Parsed' .. but it will at different places in the computation be bound to different elements of the list
08:07:51 <_zenon_> ski: yes of course,
08:08:00 <_zenon_> but now it's evident that it will be different ones
08:08:25 <ski> _zenon_ : yeah, if you think you can handle it better for the while, please use/expand to the underlying `(>>=)' combinators and lambdas ..
08:09:33 <_zenon_> ski: expand?
08:10:01 <vixey> macro-expansion
08:10:06 <_zenon_> ah, sure.
08:10:21 <vixey> @undo do x <- u ; y <- v ; f g h ; return (x,y)
08:10:21 <noBotE> u >>= \ x -> v >>= \ y -> f g h >> return (x, y)
08:10:23 <_zenon_> I just had a tough time rewriting it, but ski fixed it.
08:10:32 <_zenon_> okay, nice,
08:10:41 <_zenon_> thanks a lot ski
08:10:48 <ski> np
08:12:08 <ski> @undo do () <- u; m
08:12:08 <noBotE> u >>= \ a -> case a of { () -> m; _ -> fail ""}
08:13:37 <_zenon_> I guess you get the hang of it after some use,
08:14:02 <mauke> I've got a programmable semi-colon
08:14:57 <vixey> coinductives are definitely evil
08:20:15 <_zenon_> does ghci have built in macro expansion? Or are you refering to the lambdabot expansion?
08:20:34 <vixey> every haskell compiler has it built in
08:20:47 <ski> vixey : why ?
08:20:52 <_zenon_> how do you invoke it?
08:21:58 <ski> _zenon_ : you don't .. it expands automatically (modulo "as if")
08:24:17 <_zenon_> thus, you are refering to the lambdabot function @undo
08:25:03 <ski> _zenon_ : not necessarily .. you can expand by hand, too (which was what i had in mind)
08:25:11 <vixey> _zenon_: I was suggesting where 'expansion' comes from in general
08:25:29 <_zenon_> ski: ok, well that is what I try to do as much as possible
08:25:33 <ski> vixey : why would coinductives be evil ?
08:25:58 <_zenon_> vixey: yeah I know :D heheh
08:28:48 <_zenon_> vixey: define evil?
08:29:16 <_zenon_> define: evil @ google ==> morally objectionable behaviour [and several others]
08:29:35 <vixey> ski: such hard to understand...
08:30:09 <ski> vixey : in some sense, i think of functions as coinductives
08:30:16 <esteth> Does anyone know how to get cabal-install to install executables to my real filesystem, instead of it's ~/.cabal centred "fake" one?
08:30:38 <vixey> ski: could you tell me a bit about how ?
08:31:03 <ski> vixey : e.g. `Nat -> a' is isomorphic to `Stream a'
08:31:21 <RayNbow> hmm, http://homepage.mac.com/sigfpe/Computing/diff.html <-- just wondering... does type 0 correspond with bottom or...?
08:31:22 <noBotE> Title: Differentiation of Datastructures for Non-Functional Programmers
08:31:31 <ski> vixey : coinductive values are generally infinite, functions likewise
08:31:50 <FordCortina> can you put type class constraints in type synonyms?
08:32:46 <ski> RayNbow : `0' is the type with no value at all
08:32:47 <Deewiant> RayNbow: it corresponds to a type without constructors, in my mind
08:33:04 <FordCortina> like type MyType = Monad m => Int -> m IntSet
08:33:10 <FordCortina> (which doesnt work)
08:33:16 <ski> RayNbow : since in haskell, every type has bottom value, the best we can approximate it with is the type with no constructors
08:33:28 <ski> data Void =  -- no constructors
08:33:35 <dolio> In Haskell it would have one value, bottom, but Haskell isn't very principled as a logic.
08:33:51 <Saizan_> esteth: i use "cabal install --global --root-cmd=sudo foo"
08:33:59 <vixey> ski: would this not mean computing the value of f 0, f 1, .. just to get f 10?
08:34:25 <ski> FordCortina : you can with some GHC extension (dunno if some other impl. supports it)
08:34:36 <Saizan_> esteth: the root-cmd is what is used to gain privileges when copying the executable in /usr/bin
08:35:08 <Saizan_> "/usr/local/bin"
08:35:08 <ski> FordCortina : well, hm .. i think you must bind `m' somewhere, too .. try adding a `forall m.' (or adding `m' as a parameter, if you prefer)
08:35:35 <Saizan_> esteth: you can also specify explicit paths, see cabal install --help
08:36:15 <ski> vixey : you don't necessarily need to computer earlier elements when you computer part of the "spine"
08:36:27 <gwern> @seen boegel
08:36:27 <noBotE> boegel is in #haskell-blah. I don't know when boegel last spoke.
08:36:52 <FordCortina> i tried giving it a param it gave me: Illegal polymorphic or qualified type: forall (m :: * -> *). (Monad m) => Pos -> m PosSet
08:37:00 <gwern> esteth: if you want to install locally, --prefix=/home/gwern/bin works for me
08:37:01 <ski> (vixey : also, it's quite possible the isomorphism isn't quite exact in the presence of haskell's impure bottom)
08:37:03 <FordCortina> Int = Pos
08:37:43 <esteth> Saizan_, gwern, Thanks :) I'll use --global / --root-cmd in future, for now i'll just symlink what I allready have :)
08:39:01 <ski> FordCortina : <http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-synonyms> is the relevant section
08:39:01 <noBotE> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-synonyms>
08:39:32 <dolio> One easy way to see the correspondence (I suppose) is something like 'memoize :: (a -> b) -> InfiniteMap a b'.
08:40:10 * _zenon_ away socialising
08:40:15 <Saizan_> FordCortina: what's the new definition? however unless you're consciously trying to use higher-rank/existential types i'd avoid using type synonyms like that
08:40:19 <dolio> InfiniteMap clearly has to be coinductive if 'a' doesn't necessarily have a finite number of elements.
08:40:27 <dolio> (Since it has to be infinite.)
08:42:15 <gwern> @tell boegel I've sent you patches for hray several times, iirc. are you not getting them? is the email in the cabal wrong?
08:42:15 <noBotE> Consider it noted.
08:43:51 <FordCortina> Saizan: im just experimenting with memoization techniques
08:44:28 <FordCortina> the monad is a state monad
08:44:37 <dolio> I suppose that does some explaining as to why definitional equality on coinductives is problematic in, say, Agda, since equality on them is extensional (as it is with functions).
08:45:14 <vixey> yeah I am wondering what equality will be for coinductives in OTT
08:46:06 <dolio> I don't know if they've done that yet, but since it allows easy use of extensional equality for functions, I suppose it may turn out well.
08:46:49 * RayNbow forgot he asked a question here in this channel... :p [sometimes humans fail at multitasking]
08:47:02 <RayNbow> ski et al., thanks for the answers :)
08:47:49 <mattam> vixey: it should be bisimulation.
08:48:24 <vixey> are there predicates which could not be satisfied for two objects that bisimulate?
08:48:56 <vixey> (but do for definitional equality)
08:49:09 <edwardk> bisimulation is the idea that the two systems cannot be distinguished by an observer
08:49:19 <dolio> vixey: Presumably, they just add the rule 'a `bisim` b -> a = b' to their set of true propositions, and then you get extensional equality on coinductive objects.
08:49:23 <mattam> Nope. Bisimulation should be the biggest observable equality.
08:49:53 <mattam> They ought to do it better. You can do that kind of thing in Coq already.
08:50:00 <mattam> Or Agda I guess.
08:51:31 <mattam> The point would be that the derived propositional equality on coinds would be bisimulation, I'm not sure about the definitional one, not much is decidable there.
08:59:29 <olsner> @bot
08:59:29 <noBotE> :)
08:59:43 <vixey> > 1 + (let x = 2 in x + 1)
08:59:44 <noBotE>  4
09:01:08 <b_jonas> ok, haskell's got back to the normal track where people throw completely nonsense words at each other that sound like category theory
09:01:36 <oklopol> :)
09:01:37 <vixey> I've seen category and impredicative definitions of it but neither makes sense
09:02:31 <edwardk> b_jonas: sorry about that =)
09:02:41 <b_jonas> where was that wiki page with the long seemingly nonsense title?
09:02:51 <vixey> @google real world #haskell
09:02:57 <edwardk> b_jonas you can blame me for that one too
09:03:02 <noBotE> http://www.realworldhaskell.org/blog/
09:03:02 <noBotE> Title: Real World Haskell
09:03:13 <edwardk> @google zygohistomorphic prepromorphism
09:03:15 <noBotE> http://www.reddit.com/user/Wiseman1024/
09:03:15 <noBotE> Title: profile for Wiseman1024
09:03:39 <edwardk> wow epic fail google
09:03:50 <vixey> @wiki Real World
09:03:51 <noBotE> http://www.haskell.org/haskellwiki/Real_World
09:06:17 <b_jonas> should be linked from http://haskell.org/haskellwiki/Humor
09:06:18 <noBotE> Title: Humor - HaskellWiki
09:06:43 <kryptiskt> can I call a vararg function with the FFI?
09:07:11 <b_jonas> kryptiskt: I think no
09:07:22 <b_jonas> there's no portable way to do itin c either,
09:08:02 <b_jonas> plus, imagine even a haskell function that can accept a single argument of any type and converts that to c according to the c ffi rules
09:08:22 <b_jonas> write a wrapper in c that's not vararg or something
09:08:35 <kryptiskt> guess i have to do that
09:09:20 <b_jonas> otoh it's probably mostly safe to call a vararg function you treat as fixarg like mkdir or open
09:09:33 <b_jonas> provided you include the header so the compiler has the declaration
09:10:48 <kryptiskt> too much voodoo for me
09:11:04 <kryptiskt> I'll make a wrapper
09:12:41 <b_jonas> that's only good for a few functions
09:12:52 <b_jonas> most vararg functions like printf aren't really suitable for this
09:14:31 <kryptiskt> I'm packaging libmicrohttpd so I know the varargs are key-value pairs. So they are kind of typed at least.
09:17:59 <dolio> vixey: Category and impredicative definitions of what?
09:18:09 <vixey> coinductives
09:18:15 <dolio> Oh.
09:18:52 <mapreduce> Are static types inherently incompatible between systems?  E.g., can Haskell and Clean talk to each other reasonably, or nobetter than they can each talk to C?
09:19:19 <dolio> Haskell talks to C pretty easily.
09:19:48 <dolio> Although there is a C types module you have to use, I think, due to possible inconsistencies between, say, the C type 'int' and the Haskell type 'Int'.
09:20:26 <dolio> (For instance, on my machine, I think int may be 32 bits, but Int is 64.)
09:20:39 * Nafai sighs
09:20:54 <newsham> morning
09:21:22 <Nafai> Every time I try to write Haskell code for something practical after having a break, I struggle
09:22:22 <mapreduce> Sure, but C doesn't expose whether a function is pure, or have any form of type parameterisation.  I think you've not understood my question, or you just chose to answer it in a way I don't understand. :)
09:22:25 <b_jonas> mapreduce: depends
09:23:03 <newsham> you can assume that C functions are not pure by default, and denote them as being pure if you can offer that guarantee yourself
09:23:19 <dolio> mapreduce: All C functions imported into Haskell have a return type involving IO. Then you can use unsafePerformIO if you wish to tell the Haskell type system that they're pure.
09:23:22 <mapreduce> Sure.  But interfacing with another Haskell-like system you'd hope to get more than that.
09:23:32 <newsham> dolio: no, you can denote them as pure as well
09:23:47 <edwardk> mapreduce: the problem comes in when there is an impedence mismatch. Clean has a uniqueness type. if you don't use it you should be able to define ffi between clean and haskell, but the moment you do there is something the haskell type system cannot maintain so you lose some type info going across the border.
09:23:49 <dolio> Can you?
09:24:03 <newsham> foreign import ccall unsafe "sin" c_sin :: CDouble -> CDouble
09:24:12 <dolio> Ah. I stand corrected.
09:24:40 <mapreduce> edwardk: Sure.  I suppose I mean "for those things that are the same can you generally use them without pain?".
09:25:09 <edwardk> otoh, clean at last check lacked some of the rank-n polymorphism tricks that ghc has adopted, so there is an impedence mismatch there as well
09:25:22 * mapreduce realises how ambiguous his question is and gives up on it.
09:25:25 <edwardk> mapreduce: unfortunately there is no foreign import cleancall ...
09:25:31 <dolio> It's not as easy with Clean, I imagine, because talking to Clean isn't built into GHC.
09:25:44 <dolio> But if it were, it'd be just as easy as C. Just a different calling convention.
09:26:08 <dolio> > maxBound :: Int
09:26:09 <noBotE>  9223372036854775807
09:27:17 <dolio> I think there are compilers that target other platforms (javascript in a browser?) that have other calling conventions.
09:27:39 <dolio> I'm not sure what all GHC has.
09:27:52 <edwardk> yeah i've been having a 1@#*( of a time getting a javascript calling convention right for kata =)
09:29:04 <newsham> there are some other systems written in haskell that have an FFI to haskell, too
09:29:08 <newsham> like agda -> haskell
09:32:27 <dolio> The GHC manual doesn't appear to list its calling conventions. The FFI report lists ccall, cplusplus, dotnet, jvm and stdcall as potential options.
09:32:31 <dolio> Only ccall is mandated.
09:32:49 <Nafai> Is it safe to assume there isn't an equivalent of Python's string method strip in Haskell?
09:32:56 <Nafai> i.e., I have to write it?
09:33:19 <dolio> What's it do? Removes white space at both ends?
09:33:23 <Nafai> Yeah
09:33:36 <dolio> Yeah, I don't think that's anywhere in the standard libs.
09:34:30 <Deewiant> reverse . dropWhile isSpace . reverse . dropWhile isSpace
09:35:07 <Saizan_> join (.) $ reverse . dropWhile isSpace -- another old classic
09:36:19 <RayNbow> strip = takeWhile (not . isSpace) . dropWhile isSpace -- how about this one?
09:36:23 <mar77a> does 'reverse' actually reverse the list in memory
09:36:26 <mar77a> or does some pointer tricks
09:36:36 <RayNbow> @src reverse
09:36:36 <noBotE> reverse = foldl (flip (:)) []
09:36:45 <mar77a> i mean, in the implementation
09:36:48 <Deewiant> well you'd still need to change all N pointers :-)
09:36:49 <ski> RayNbow : try applying that to `" a b c "'
09:36:50 <mar77a> code wise
09:36:57 <dolio> RayNbow: That won't work well if you have internal spaces.
09:37:05 <RayNbow> ah right
09:37:08 <RayNbow> stupid me :p
09:37:47 * RayNbow should use QC more often
09:43:13 <dolio> > let dropWhileEnd p = snd . foldr f (True, []) where f x ~(b,l) | p x && b = (True, l) | otherwise = (False, x:l) ; strip p = dropWhile p . dropWhileEnd p in strip isSpace "   foo   bar  baz    "
09:43:14 <noBotE>   Not in scope: `strip'
09:43:38 <dolio> > let dropWhileEnd p = snd . foldr f (True, []) where { f x ~(b,l) | p x && b = (True, l) | otherwise = (False, x:l) } ; strip p = dropWhile p . dropWhileEnd p in strip isSpace "   foo   bar  baz    "
09:43:39 <noBotE>  "foo   bar  baz"
09:45:53 <nus> :t (>>=)
09:45:54 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:45:59 <nus> :t []
09:46:00 <noBotE> forall a. [a]
09:46:35 <nus> now how am I supposed to know that a list is a monad too ?-)
09:46:51 <Zao> By reading the report?
09:46:54 <EvilTerran> ?src (:)
09:46:54 <noBotE> Source not found. I can't hear you -- I'm using the scrambler.
09:46:59 <Deewiant> ?instances Monad
09:47:00 <noBotE> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:47:02 <EvilTerran> ?src []
09:47:02 <noBotE> data [] a = [] | a : [a]
09:47:05 <Deewiant> thusly
09:47:19 <EvilTerran> or by looking in the Prelude haddock for the list of instances
09:48:00 <dolio> Meditate until you reach enlightenment.
09:48:09 <mar77a> *aaaa*
09:51:14 <atp> noBotE?
09:51:58 <Deewiant> a play on ENOBOT?
09:52:25 <hpaste>  Nafai pasted "How do I avoid IO [String]?" at http://hpaste.org/8625
09:52:55 <mauke> Nafai: you don't
09:52:58 <Nafai> :(
09:53:10 <mauke> the function depends on the file system
09:53:20 <mauke> you can't just deduce the contents from the filename
09:53:35 <mar77a> why do you want to do that, Nafai ?
09:53:50 <mauke> btw, foo <- return (...) can be written as let foo = ...
09:54:18 <Nafai> mauke: Thanks
09:54:37 <Nafai> Part of my annoyance is trying to play with these functions on the ghci prompt as I'm building my program
09:55:12 <Nafai> If I do a 'let contents = getFileContents ledgerFileName", contents naturally is type IO [String]
09:55:37 <Nafai> So I then can't do things like (contents !! 0)
09:55:46 <mauke> contents <- getFileContents ...
09:56:10 <mar77a> http://book.realworldhaskell.org/beta/io.html that tutorial is good
09:56:15 <noBotE> Title: ChapterÂ 9.Â I/O
09:56:25 <mar77a> suggested!
09:57:23 <Nafai> mauke: I didn't realize I could do that in ghci, thanks!
09:57:38 <mauke> interactive do block
09:57:41 <Nafai> Yeah
09:57:45 <Nafai> Of course :)
09:58:03 <Nafai> I spend too much time with Java and every time I come back to learn Haskell my head hurts :)
09:58:22 <newsham> its not a toomuh
09:58:34 <maltem> Nafai: Not the other way around?
09:58:36 <Nafai> Heh
09:58:41 <mar77a> the imperative tumour
09:58:56 <mar77a> check the link, Nafai
09:58:58 <mar77a> bbl
09:59:00 <Nafai> maltem: My head doesn't hurt doing Java, except for maybe the banging my head against the desk
09:59:15 <maltem> That's what I mean :)
09:59:20 <Nafai> :)
10:02:55 <noecksit> @seen dcoutts
10:02:56 <noBotE> dcoutts is in #haskell and #haskell-blah. I last heard dcoutts speak 3h 54m 22s ago.
10:04:20 <noecksit> hello, who would i talk to about including a code snippet in the examples page of haskell.org/gth2hs?
10:04:55 <noecksit> namely the imagepattern example from C
10:05:21 <Botje> it's a wiki, you can add it :)
10:06:15 <noecksit> sorry for being unclear, im talking about http://darcs.haskell.org/gtk2hs/demo/
10:06:20 <noBotE> Title: Index of /gtk2hs/demo
10:09:02 <int-e> noecksit: see http://www.haskell.org/gtk2hs/development/ -- note that  http://darcs.haskell.org/gtk2hs/demo/ is the old repo, the new one is on code.haskell.org
10:09:03 <noBotE> Title: Gtk2Hs » Development
10:09:11 <noecksit> maybe i could push to that repository and someone would get an email?
10:11:20 <noecksit> yeah, i think ill do that
10:12:46 <noecksit> its funny, you guys have "darcs get --partial http://code.haskell.org/gtk2hs" but it still links to darcs.haskell.org/gtk2hs
10:12:47 <noBotE> Title: Index of /gtk2hs
10:14:05 <int-e> darcs send  is the right command for submitting patches. for gtk2hs, they'll go to the gtk2hs-devel mailing list.
10:17:42 <zachk> am I guessing here or does ghc 6.8 have a decent bit more then 6.6?
10:18:44 <dmwit> Yes, it has a decent bit more than 6.6.
10:18:57 <dmwit> One of the most notable additions for people new to Haskell is the debugger.
10:19:16 <zachk> im notcing i can do x+pi in 6.8 but not in 6.6
10:19:37 <dmwit> You had better look a little closer.
10:19:54 <dmwit> There's something else you're doing differently between them, because type-checking is still type-checking.
10:19:57 <mar77a> @src pi
10:19:57 <noBotE> Source not found. That's something I cannot allow to happen.
10:20:13 <dmwit> mar77a: pi is in some type class, I think
10:20:22 <dmwit> ?src Real
10:20:23 <noBotE> class  (Num a, Ord a) => Real a  where
10:20:23 <noBotE>     toRational      ::  a -> Rational
10:20:28 <dmwit> ?src RealFloat
10:20:28 <noBotE> Source not found. stty: unknown mode: doofus
10:20:33 <dmwit> :t pi
10:20:34 <noBotE> forall a. (Floating a) => a
10:20:38 <dmwit> ?src Floating
10:20:38 <noBotE> class  (Fractional a) => Floating a  where
10:20:38 <noBotE>     pi                                                      :: a
10:20:38 <noBotE>     exp, log, sqrt, sin, cos, tan                           :: a -> a
10:20:38 <noBotE>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
10:20:38 <noBotE>     (**), logBase                                           :: a -> a -> a
10:20:46 <dmwit> There we go. =)
10:21:33 <dmwit> zachk: Care to paste the code that seems to behave differently between 6.6/6.8?
10:21:39 <dmwit> ?hpaste
10:21:39 <noBotE> Haskell pastebin: http://hpaste.org/new
10:23:21 <zachk> its upstairs on my openbsd box that has no net connection in a ghci window i segfaulted yesterday
10:23:39 <dmwit> ...
10:23:45 <dmwit> Are you messing with the FFI?
10:23:49 <zachk> nope
10:24:02 <dmwit> How did you manage to segfault ghci?
10:24:15 <zachk> i was trying to implement imap where imap is just mapM_
10:28:08 <dmwit> In any case, nothing about (+pi) should have changed unless you had -fglasgow-exts on.  (And maybe not even then?)
10:34:09 <noecksit> what does "darcs get --partial" do, does it not make the full repository under revision control?
10:34:31 <dmwit> It doesn't grab the full history.
10:35:19 <noecksit> it only grabs the revision history of the topmost folder i see, so if there was something in an inner folder, it wouldnt know about it
10:35:56 <int-e> no, it just doesn't grab all the patches
10:36:33 <int-e> you get the whole working tree.
10:38:10 <noecksit> oh ok, like the old patches that arent necessary
10:41:14 <noecksit> ahh, im supposed to have sendmail for this to work!
10:42:03 <matthew_-> noecksit: no, you just need any standard mta which has a sendmail program, normally in /usr/bin/
10:42:30 <matthew_-> err, I meant /usr/sbin/
10:44:13 <gwern> what, to do a darcs send?
10:44:37 <gwern> noecksit: look at darcs help send, you can specify your own program/shell command
10:44:47 <noecksit> matthew_- : i never use my laptop to send mail, which one could i painlessly install then get rid of?
10:45:09 * gwern for example has 'sen'd aliased to the lengthy but useful: darcs send -v --summary --from=`gpg-address` --sendmail-command="torify ssmtp -au `gpg-address` -ap `gpg-password` %t %<" "$@"
10:46:00 <gwern> noecksit: ssmtp and msmtp seem to be fairly common. of course, you could just do a 'darcs send -o foo.patch' and attach it to an email you manually compose to the author
10:46:11 <gwern> I used to do that before I bit the bullet and got ssmtp configured
10:47:04 <noecksit> gwern : yeah i think that might be easier considering im trying to send one itsy bitsy patch only at this time
10:48:16 * matthew_- uses postfix everywhere
11:00:18 <int-e> noecksit: you can also put options into ~/.darcs/defaults, for example a line saying "send sendmail-command esmtp -t %<" (I'd also suggest "send edit-description")
11:19:59 <greylord> Hello all
11:20:15 <vixey> hi
11:20:15 <greylord> I have a question that I'm hoping someone can answer
11:20:29 <greylord> Why doesn't this work: (x - (truncate x))
11:20:42 <dmwit> truncate doesn't return the same type
11:20:50 <dmwit> (-) works only on two values of the same type.
11:20:53 <kpreid> :t truncate
11:20:53 <vixey> greylord: What happens when you try it?
11:20:54 <noBotE> forall a b. (Integral b, RealFrac a) => a -> b Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
11:20:55 <dmwit> Try this instead:
11:21:08 <greylord> I understand that truncate returns an inegral, but I was under the impression that Haskell will automatically convert it to a double/float
11:21:14 <dmwit> x - (fromInteger $ truncate x)
11:21:20 <mauke> greylord: haskell never autoconverts
11:21:23 <vixey> no haskell will not automaticalaly convert thingsn to and fro
11:21:28 <dmwit> greylord: No, Haskell does no implicit casting ever.
11:21:34 <greylord> Oh, I misunderstood then.
11:21:41 <greylord> dmwit: thanks, I'll give it a quick try.
11:21:54 <mauke> @hoogle modf
11:21:54 <noBotE> A Hoogle error occured.
11:21:56 <vixey> you could write x - fromInteger $ truncate x
11:21:58 <mar77a> so it's static typed but can dynamically inferr types from context?
11:22:02 <vixey> the brackets aren't needed
11:22:08 <dmwit> vixey: Good point. =)
11:22:08 <mauke> mar77a: s/dynamically/statically/
11:22:12 <vixey> mar77a no
11:22:36 <dmwit> I'm surprised there's no "fractionalPart" function already.
11:22:37 <dolio> x - fromInteger $ truncate x = (x - fromInteger) (truncate x)
11:22:51 <greylord> Cool, thanks guys!  That worked perfectly!
11:23:20 <b_jonas> dmwit: you mean modf? I think there is a name for it
11:23:23 <b_jonas> let me look that up
11:23:29 <dmwit> :t modf
11:23:30 <noBotE> Not in scope: `modf'
11:23:43 <b_jonas> yeah, I know it's not called like that
11:23:52 <dolio> :t mod'
11:23:53 <noBotE> forall a. (Real a) => a -> a -> a Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
11:23:58 <mauke> > properFraction pi
11:23:59 <noBotE>  (3,0.14159265358979312)
11:24:11 <dmwit> Ah, cool.
11:24:32 <b_jonas> yeah, that's it
11:24:37 <mar77a> with haskell being lazy and all
11:24:46 <mar77a> it's possible to define an irrational number isn't it?
11:24:49 <mauke> > properFraction (-4)
11:24:50 <noBotE>  (-4,0.0)
11:24:54 <mauke> > properFraction (-4.2)
11:24:55 <noBotE>  (-4,-0.20000000000000018)
11:25:24 <Toxaris> mar77a: I have read something about arithmetic over infinite streams of digits recently
11:25:26 <vixey> mar77a: you can do this in non-lazy languages
11:25:32 <b_jonas> frexp and ldexp are renamed in haskell too
11:25:34 <b_jonas> it's just crazy
11:25:37 <b_jonas> they rename everything
11:26:10 <Toxaris> mar77a: http://sigfpe.blogspot.com/2008/01/what-does-topology-have-to-do-with.html
11:26:12 <noBotE> Title: A Neighborhood of Infinity: What does topology have to do with computability?, http://tinyurl.com/435zff
11:26:17 <dolio> data Number = ... | Root Integer Integer ; sq2 = Root 2 2
11:26:26 <mar77a> well i'm studying from my series (among other things) exam
11:26:28 <dolio> An irrational number! :)
11:26:39 <mar77a> and i've been using haskell a bit
11:26:40 <b_jonas> well, you can make a class that can represent large classes of integers
11:26:43 <b_jonas> um
11:26:50 <b_jonas> large classes of irrationals
11:26:58 <b_jonas> and type
11:27:16 <b_jonas> I've written a type that can represent any quadratic irrational
11:27:27 <dmwit> There's an arbitrary-precision number type already implemented, isn't there?
11:27:31 <b_jonas> but it either still falls to an infinite loop or is really slow
11:27:48 <b_jonas> dmwit: arbitary precision would still always be rational
11:27:55 <dmwit> yes
11:28:12 <b_jonas> well, mine can do more than Rational :-)
11:28:16 <dmwit> I think what dolio pointed out is that it just depends on how you represent your number. =)
11:28:21 <b_jonas> but it's not optimized at all so it's unusable
11:28:46 <vixey>  arbitary precision would still always be rational?
11:28:48 <vixey> what no
11:29:11 <dolio> Arbitrary precision usually means arbitrary finite precision.
11:29:11 <vixey> oh you meant like a finite list of digits
11:29:12 <vixey> ?
11:29:23 <Toxaris> dolio's type is a symbolic computation solution, which is fine, but nothing new
11:29:32 <b_jonas> vixey: or Rational Integer
11:29:41 <b_jonas> either that or a bigfloat in some radix like you say
11:32:42 <dolio> If you want infinite streams of digits, you can look here: http://users.info.unicaen.fr/~karczma/arpap/
11:32:45 <dmwit> b_jonas: No, I'm talking about something like (instance Num (Integer -> Integer) where ...), where the Integer argument tells how many digits you want computed.
11:32:47 <noBotE> Title: Some papers (Karczmarczuk)
11:32:56 <dolio> The Most Unreliable Technique in teh World to Compute PI uses it.
11:33:07 <dmwit> b_jonas: (Which has no trouble representing square roots, pi, e, etc.)
11:33:24 <b_jonas> dmwit: it can represent them, but you can't do arithmetic on them in general
11:33:27 <b_jonas> that's the problem
11:33:30 <dmwit> False.
11:33:53 <dmwit> I'm pretty sure there's an instance Num written in Haskell, I just can't remember what it's called.
11:34:40 <Toxaris> to represent irrational numbers, something like [(Rational, Rational)] should be enough, shouldn't it?
11:34:59 <chessguy> howdy
11:35:20 <newsham> arbitrary precision can be irrational (infinite stream)
11:35:52 <dmwit> ?info Decimal
11:35:52 <noBotE> Decimal
11:35:55 <dmwit> bah
11:35:59 <dmwit> I keep forgetting.
11:36:02 <Toxaris> newsham: depends on what you mean by arbitrary. e.g. http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ARational uses the word differently.
11:36:03 <noBotE> http://tinyurl.com/ovjef
11:36:07 <dmwit> > 3 :: Decimal
11:36:07 <noBotE>   Not in scope: type constructor or class `Decimal'
11:36:34 <dmwit> > 3 :: CReal
11:36:35 <noBotE>  3.0
11:36:38 <dmwit> aha!
11:36:45 <chessguy> so, i'm reading the Bananas paper. they say filter is a catamorphism.....i don't get that. filter doesn't "destroy" a list
11:36:55 <dmwit> > sqrt 2 :: CReal
11:36:56 <noBotE>  1.4142135623730950488016887242096980785697
11:37:06 <newsham> > filter (/= 3) [1,1,1,1,1,1]
11:37:07 <noBotE>  [1,1,1,1,1,1]
11:37:08 <Deewiant> > filter (const False) [1..100]
11:37:09 <noBotE>  []
11:37:11 <dolio> chessguy: It does, but its result is a list as well.
11:37:12 <newsham> > filter (/= 3) [3,3,3,3,3]
11:37:13 <noBotE>  []
11:37:15 <Deewiant> pretty destructive to me :-P
11:37:17 <dons> ?yow
11:37:17 <noBotE> Couldn't find fortune file
11:37:17 <dmwit> > sqrt 2 + sqrt 3 :: CReal -- arithmetic
11:37:18 <noBotE>  3.1462643699419723423291350657155704455125
11:37:31 <Toxaris> chessguy: consider that the result list may be shorter then the input list
11:37:39 <chessguy> sure, it _may_ be
11:37:45 <Deewiant> and it's never longer
11:38:02 <dolio> > (\p -> foldr (\x -> if p x then (x:) else id) []) (==3) [1..5]
11:38:03 <noBotE>  [3]
11:38:41 <Toxaris> chessguy: so the structure of the result list is not the structure of the input list, so the structure of the input list is destroyed by filter and thrown away.
11:39:01 <chessguy> but the structure is still a list
11:39:03 <newsham> now i am become filter, the destroyer of lists
11:39:26 <Toxaris> chessguy: yes, but accidently :)
11:39:29 <chessguy> so, would map be a catamorphism then, too?
11:39:40 <chessguy> it "tears down" the old list, and builds a new one
11:39:58 <dolio> > (\f -> foldr ((:) . f) []) (+1) [1..10]
11:39:59 <noBotE>  [2,3,4,5,6,7,8,9,10,11]
11:40:26 <Toxaris> chessguy: yes I think so. consider id. it's about every kind of morphism you can think of at once.
11:40:42 <chessguy> ok, so we're not talking about very formal definitions then
11:41:42 <Saul_> I've been doing some stuff on generic programming, and there map is actually a lot harder than fold, because both breaking down and building up the container needs to be done there
11:41:47 <dolio> Strictly speaking, foldr might be called *the* list catamorphism. But I suppose you could call anything else you can write in terms of fold a catamorphism as well.
11:42:00 <Saul_> So I would definitely consider map a catamorphism
11:43:09 <dolio> That is, foldr is the unique morphism you get from the initiality of lists. map is not.
11:43:09 <newsham> ?google lolcatamorphism
11:43:10 <noBotE> No Result Found.
11:43:40 <chessguy> initiality? do you feel smarter because you use words the rest of us don't know?
11:44:01 <Toxaris> CT speaking, foldr is the list catamorphism and nothing else. but FP speaking, foo is a catamorphism if foo = foldr f x for some f and x.
11:44:08 <dolio> They don't talk about initial algebras in there?
11:44:19 <chessguy> oh, i haven't finished the paper yet
11:44:20 <Saul_> If you use the definition of map that dolio just used in terms of fold, then it will only build lists
11:45:03 <Deewiant> CT?
11:45:07 <dolio> chessguy: Well, they may well not. I haven't read that paper in a long time. They probably gloss over it, because it's not necessary to understand the category theory to use the functional programming.
11:45:09 <Saul_> so if you generalize folds to consume any container type (basically any type of kind * -> *), that definition of map will only work from some container to lists
11:45:12 <Toxaris> Deewiant: Category Theory.
11:45:18 <Deewiant> ah, of course.
11:45:47 <Saul_> so that is why making a generalized map is harder
11:46:25 <dmwit> > 3 ^ 9
11:46:26 <noBotE>  19683
11:46:42 <newsham> > 9 ^ 3
11:46:43 <noBotE>  729
11:46:49 <Toxaris> Saul_: but for a algebraic container type, e.g. defined by data C (x : *) = ..., it should be easy, shouldn't it? you basically pass in the constructors as arguments to the fold
11:47:04 <newsham> > (3^9) `div` (9^3)
11:47:05 <noBotE>  27
11:47:24 <Deewiant> > 3 * 9 * 9 ^ 3
11:47:25 <noBotE>  19683
11:47:25 <desp> Has anyone seen linker errors such as Undefined symbols: "_containerszm0zi1zi0zi1_DataziMap_polyzugo_info", referenced from:
11:47:35 <Saul_> Toxaris: That is true, but it's still harder than a fold
11:47:46 <dmwit> desp: ghc -- make
11:47:46 <mauke> preflex: zdec _containerszm0zi1zi0zi1_DataziMap_polyzugo_info
11:47:46 <preflex>  _containers-0.1.0.1_Data.Map_poly_go_info
11:47:50 <EvilTerran> you can define map with fold, but not vice-versa
11:47:57 <desp> dmwit: aha
11:47:57 <dons> mauke: nice.
11:48:14 <dons> dmwit: usually it means partially recompiled code with some dependent library changed
11:48:19 <dons> desp: sorry
11:48:26 <dons> desp: so try removing dist/ or -no-recomp
11:48:28 <desp> --make helped, thanks.
11:48:35 <dons> oh, and yes, that. :)
11:48:38 <desp> :)
11:48:49 <desp> dons: btw, thanks for pointing out the zipper article on reddit
11:48:56 <dons> oh hehe
11:49:03 <chessguy> zipper article on reddit?
11:49:06 <chessguy> @go reddit zipper
11:49:08 <noBotE> http://reddit.com/info/6ddxt/comments/
11:49:08 <noBotE> Title: reddit.com: Differentiation, Calculus of Algebraic Datatypes (e.g. how you deriv ...
11:49:21 <Saul_> EvilTerran: In normal polymorphic Haskell that is true, but if you want to make functions that work on any datatype, they are different
11:49:22 <dolio> I imagine a generalized map is 'gmap :: Functor f => (forall b. f b -> f b) -> Mu f -> Mu f ; gmap f = cata (InF . f)' or something of the sort.
11:49:23 <desp> @go reddit holes
11:49:23 <dons> zippers should be taught in school, you learn lists, you learn types, and how to differentiate them to get the zipper. then you learn trees and so on.
11:49:24 <noBotE> No Result Found.
11:49:33 <Deewiant> http://www.reddit.com/r/programming/info/6pfvy/comments/
11:49:34 <noBotE> Title: programming: Data structures with holes: a blessed man's formula for holey conta ...
11:50:06 <dolio> For mapping over the fixed points of functors, at least.
11:50:23 <chessguy> oh yes, that one
11:51:48 <dons> here's one for you,
11:51:48 <dons> /usr/bin/ld: dist/build/Numeric/GSL/Special/Internal_hsc_make: hidden symbol `__powidf2' in /usr/lib/gcc/x86_64-unknown-linux-gnu/4.3.1/libgcc.a(_powidf2.o) is referenced by DSO
11:51:51 <dons> /usr/bin/ld: final link failed: Nonrepresentable section on output
11:52:25 <Saizan_> dons: that lets you change the shape of the structure, though
11:52:34 <Saizan_> err, dolio
11:52:42 <desp> Too many d's!
11:53:40 <chessguy> down with d's!
11:54:07 <dolio> Saizan_: Hmm, true.
11:54:19 <dolio> Who needs zippers? I'll just use C and pointers.
11:55:18 <dolio> Saizan_: What you really need is some way to lift (a -> b) into forall c. f c -> f c.
11:56:59 <dolio> I suppose f can't stay the same, either, then.
11:57:52 <dolio> So it's more like 'gmap :: Bifunctor f => (a -> b) -> Mu (f a) -> Mu (f b) ; gmap f = cata (InF . bimap f id)'
11:58:35 <Saizan_> yes, that looks like it
12:00:18 <chessguy> is there such a thing as a zipper for an array?
12:00:47 <EvilTerran> it doesn't have an algebraic definition, really
12:00:49 <mauke> an array is not recursive
12:00:55 <EvilTerran> that too
12:01:01 <mauke> it's just a tuple
12:01:42 <lament> sure it is recursive
12:01:51 <lament> an array is an element plus an array of smaller size :)
12:02:06 <mauke> we call that a "list"
12:02:17 <EvilTerran> mauke, that's an implementation detail
12:02:34 <lament> no, with lists you don't need to specify "smaller size"
12:02:57 <Toxaris> lament: what's wrong with infinite size arrays? (e.g. pointers in c)
12:03:09 <Toxaris> lament: or turing machine bands
12:03:15 <Saizan_> the derivative of a^n is na^n-1, and in fact the context can be tought as an array of n-1 elements and an index for where the focussed element belongs
12:04:31 <chessguy> but i guess there's not much point, for an O(1) access data structure
12:05:02 <Toxaris> maybe if you have a zipper-based collections api, you want to include arrays, too
12:05:52 <Toxaris> so you could internally represent the array of (n - 1) elements as the original array with an index to know which element to leave out, so you arrive at the obvious array iterator (index, array)
12:06:10 <Toxaris> but it could feel like a zipper.
12:06:44 <Saizan_> yeah, that's exactly what the pointer comonad is
12:10:12 <Peaker> conal, pong
12:10:22 <conal> Peaker: hi
12:10:29 <Peaker> hey :)
12:10:59 <conal> Peaker: did you see my responses yesterday to your questions about Reactive?
12:11:13 <Peaker> conal, the one about reactive value being discrete? Yeah
12:11:25 <lament> Toxaris: you can't have O(1) access to an infinite data structure.
12:11:28 <conal> yes, and about threading
12:11:53 <lament> Toxaris: in particular, turing machine bands have O(n) access. They're (bidirectionally infinite) lists
12:11:54 <Peaker> conal, I wonder what you thought about the idea of using Events containing deltas to represent a changing value (similar to a Behavior) in a way that allows differential computing
12:11:56 <Toxaris> lament: oups, I forgot about pointer size.
12:12:07 <Toxaris> lament: but what about a ring buffer then?
12:12:11 <conal> Peaker: i expect this stuff to get cleaned up quite a bit this summer, since we plan to use it at anygma.
12:12:17 <Peaker> conal, oh yeah I eagerly await the separation of the thread stuff. From other languages I have grown to be very wary of threads :)
12:12:39 <lament> Toxaris: if you claim a ring buffer is an infinite array, that's just cheating :)
12:13:08 <Toxaris> lament: I claim that the context in the ringbuffer is not smaller then the ringbuffer. but maybe that is plain wrong.
12:13:40 <Toxaris> lament: since you have to leave something out to get a context ...
12:13:47 <conal> Peaker: by "differential", do you mean the same thing as "incremental"?  i.e., computing successive Event or Reactive values efficiently in terms of earlier ones?
12:14:46 <Peaker> conal, well, incremental computing seems to mean just computing the new value when necessary. I mean something like a differential-sort implementation that can take in "add/remove" deltas and spit out "add-at-index/remove-at-index" deltas, for example
12:15:40 <conal> Peaker: okay, as in "adaptive functional programming" (acar et al)
12:15:56 <Peaker> conal, perhaps, I'll need to read about that :)
12:16:06 <dons> conal, you're working at anygma?
12:16:47 <Peaker> conal, I used differential computation in a prototype I was working on -  it has nice side-effects like allowing a Widget to animate the deltas that happen, even if they passed through processors (since it knows the essence of the change, rather than the old/new values)
12:16:48 <conal> Peaker: see also magnus carlsson's "monads for incremental computing".
12:17:18 <conal> Peaker: btw, magnus really uses Applicative and points out why Applicative can be more accurate than Monad can.
12:17:27 <Peaker> conal, I read "monads for incremental computing" -- its really cool, but it has very limited forms of representing "deltas"
12:17:30 <conal> Peaker: sounds neat.
12:17:40 <conal> Peaker: i've played with incremental/adaptive reactive values and events a few times and haven't gotten anywhere.  for instance, i don't know how i'd do fmap incrementally.
12:18:15 <augur> conal!
12:18:19 <conal> augur: ?
12:18:19 <Peaker> conal, you need a new set of primitives and only compose those -- you'd only be able to use fmap with a function that is in that set of primitives
12:18:34 <augur> oklopol and i are working on a reactive programming language :)
12:18:47 <conal> Peaker: so variants of Functor, Applicative etc.
12:19:13 <conal> augur: oh yeah.  how's it going?
12:19:52 <augur> is good. i was wondering, can i show you some of it and see what you think?
12:20:06 <Peaker> conal, I think you could use Functor itself, but if the type you're fmap'ing is:  (Event ListDelta), then the func given to fmap would need to be of type ListDelta->a (probably ListDelta->SomeKindOfDelta)
12:20:24 <Peaker> conal, where for each type you have the matching delta type
12:20:51 <Peaker> And probably a   newtype DeltaValue = Delta a => Event a
12:21:28 <Peaker> then if you make Behavior/DeltaValue be instances of some class, you can have things that work on both
12:22:31 <Peaker> (not sure if that last part is useful or actually works)
12:23:43 <conal> augur: i probably would be very helpful, as i've moved for the summer and am starting a new project, and am pretty scatter-brained right now.
12:24:45 <conal> Peaker: have you implemented your idea?  if not, could you prototype it for lists?
12:25:56 <Peaker> conal, I'll try.  I have created a Python project that can do arithmetic combination of list deltas -- I think it could be useful to port that to Haskell, and then declare it a Functor instance/etc
12:26:16 <Peaker> (that was before discovering Haskell :)
12:27:22 <Peaker> Does Monoid require cummutativity?
12:27:34 <Peaker> s/require/guarantee
12:28:25 <dolio> No.
12:28:33 <dolio> Only associativity.
12:29:01 <dolio> Technically that's not guaranteed by the type system or anything, but otherwise it's not a monoid.
12:29:19 <Toxaris> > mappend [0] [1] == mappend [1] [0]
12:29:20 <noBotE>  False
12:29:28 <Peaker> oh, right! the list monoid, heh :)
12:29:43 <Peaker> yeah, great.  In my Python deltas I overloaded + for delta combinations.  I'll make it a Monoid now
12:29:48 <mauke> @check \a b -> mappend a b == mappend b a
12:29:49 <noBotE>  OK, passed 500 tests.
12:29:52 <mauke> what
12:29:57 <Peaker> hehe
12:30:04 <Peaker> tests suck! :)
12:30:10 <Toxaris> defaulting?
12:30:12 <dolio> That's using the () monoid.
12:30:29 <augur> conal: ah ok.
12:30:35 <Deewiant> @src Monoid ()
12:30:35 <noBotE> Source not found. My mind is going. I can feel it.
12:30:46 <mauke> @check \a b -> mappend a b == mappend b (a :: [Int])
12:30:47 <dolio> So it checked that mappend () () == mappend () () 500 times.
12:30:47 <noBotE>  Falsifiable, after 1 tests: [0], [-2]
12:31:39 <vininim> @hoogle Zipper
12:31:40 <noBotE> A Hoogle error occured.
12:31:56 <vininim> wut
12:32:45 <dolio> @hoogle a -> a
12:32:46 <noBotE> A Hoogle error occured.
12:32:52 <dolio> That's not good.
12:33:06 <Toxaris> vininim: there is no specific Zipper, it's more like a design pattern
12:33:29 <dolio> I guess noBotE might not have a hoogle database.
12:33:30 <mauke> there is, actually
12:33:34 <Toxaris> (but one of these theoretically backed FP design patterns)
12:33:45 <mauke> didn't oleg make a generic zipper?
12:33:51 <dolio> Yes.
12:34:01 <earthy> not just oleg
12:34:32 <earthy> but yeah
12:35:24 <vixey> I think there was ageneric zipper in universe of strictly positive types
12:36:16 <dolio> Yeah, that related thesis has a whole chapter on computing derivatives of the types they're working with and having automatic zippers for anything, as I recall.
12:36:40 <dolio> That might be somewhat harder to pull off in Haskell, though.
12:36:48 <Toxaris> anything? is there a zipper for anything?
12:37:06 <vixey> there is a zipper for at least any ADT
12:37:18 <dolio> Any algebraic data type.
12:37:21 <vixey> I think the whole strictly positive families do too, not sure..?
12:37:22 <vixey> do they
12:37:53 <dolio> Aren't they a subset of all algebraic types?
12:38:03 <dolio> Or not, because they're dependent?
12:38:22 <vixey> I thought that each instantiation would be an ADT, but the family as a whole is not
12:38:24 <dolio> I never read to the part where he starts modelling dependent types.
12:38:29 <vixey> um.. I could be confusing concepts though
12:40:47 <dolio> Yeah, families sounds like it wouldn't be an algebraic data type, I guess.
12:41:06 <dolio> The strictly positive types are a subset of all algebraic types, though, I think.
12:41:53 <dolio> I assume a strictly positive family is some kind of indexed family where at each particular index, it's a strictly positive type.
12:47:42 <mauke> http://dis.4chan.org/read/prog/1214746131
12:47:43 <noBotE> Title: 4chan BBS - Reading PAIP
12:50:30 <vininim> Is there a wiki focused on type theory?
12:50:47 <MarcWeber> Is a tuple with only one element equal to no tuple Int = (Int)?
12:50:57 <dolio> Heh, fast printf.
12:51:47 <mauke> and sprintf = safe printf
12:52:09 <Peaker> does it make no sense to have empty classes only for their subclassing?
12:52:10 <Toxaris> MarcWeber: There is no tuple with only one element
12:52:10 <vininim> "Also, last time I checked, it doesn't work on Windows, which makes it even better." hahahaha
12:52:43 <vininim> Toxaris: isn't that what phantom types are?
12:53:01 <vininim> fsvo are
12:53:11 <mauke> Peaker: sometimes
12:53:22 <MarcWeber> Toxaris: http://rafb.net/p/WVho4m72.html :) Template haskell is generating this code
12:53:23 <mauke> xmonad uses an empty class for its event system
12:53:27 <noBotE> Title: Nopaste - No description
12:54:00 <dolio> yhc has a 1-tuple, from what I've yeard.
12:54:03 <dolio> Heard, even.
12:54:13 <mauke> blasphemy!
12:54:20 <Toxaris> MarcWeber: I'm confused.
12:54:22 <mauke> this is madness
12:54:41 <MarcWeber> Toxaris: Maybe it's a template haskell error..
12:55:18 <mrd> this is #HASKELL!
12:56:38 <Peaker> where's lambdabot?
12:56:41 <Toxaris> > let {f :: (Int) -> String; f _ = "no 1-tuples in here"} in f (undefined :: Int)
12:56:42 <noBotE>  "no 1-tuples in here"
12:57:01 <mauke> preflex: seen lambdabot
12:57:01 <preflex>  lambdabot was last seen on #haskell 12 hours, 7 minutes and 29 seconds ago, saying:  fd:10: hClose: resource vanished (Broken pipe)
12:57:10 <vininim> disregard me lumping tuples with labeled records
12:57:13 <MarcWeber> Peaker: don't know .. some time ago there was lambdac
12:57:23 <mauke> his pipe is broken
12:57:57 <Deewiant> preflex: seen lambdac
12:57:57 <preflex>  lambdac was last seen on #haskell 3 days, 23 hours, 32 minutes and 27 seconds ago, saying: Not enough privileges
12:58:42 <Toxaris> these days are bad days for bots
13:01:19 <gwern> lambdabot and hs-plugins got too messy and unmaintainable
13:01:19 <noBotE> gwern: You have 1 new message. '/msg noBotE @messages' to read it.
13:01:31 <gwern> @messages
13:01:32 <noBotE> boegel said 1h 57m 7s ago: no, I got them, but I was unable to build the latest darcs on my system, and your patches seem to be incompatible with my darcs version
13:02:28 <cmarcelo> b
13:03:19 * matthew_- gets a 4842 line type checking error message out of ghc
13:03:25 <matthew_-> that's possibly a new record
13:03:47 <gwern> wow
13:04:10 <matthew_-> you can actually see ghc pausing trying to evaluate different parts of the error message
13:04:23 <dolio> Finally we're competing with C++.
13:04:39 <vininim> matthew_-: might be I/O buffering
13:05:10 <Peaker> is there a standard function like:  slice start stop = take (stop-start) . drop start ?
13:05:25 <matthew_-> vininim: yeah, could well be.
13:05:47 <matthew_-> it is effectively a 269KB string
13:07:34 <augustss> dolio: sigfpe has a 50M error message from a c++ compiler, so we're still behind
13:07:59 * matthew_- gets to work
13:08:15 <dolio> Heh.
13:08:31 <gwern> augustss: well, that hardly counts because templates are so messy and powerful, I should think
13:08:41 <olsner> augur: 50MB error message? wow!
13:09:17 <matthew_-> actually, it's trivial. You implement a prime checker in the type system and then try to assert that on some huge non-prime. The recursion should, I think, create an enourmous error message
13:09:26 <augustss> gwern: haskell type classes with the right ghc flags are turing complete, so we should be able to compete
13:10:14 <olsner> C++ compilers have a fixed recursion limit though... I'd suspect sigfpe set that recursion limit ridiculously high to be able to produce that message
13:10:27 <olsner> if it's a template thing, that is
13:10:28 <augur> olsner: what??
13:10:39 <augur> olsner, i think you mean augustss not me :p
13:11:00 <olsner> augur: meh, stop being ahead of augustss in the tab list! :P
13:11:23 <roconnor> C++ needs lazy error messages
13:11:31 <vininim> a constant type is a type of finite values? like no-value 0 and singleton 1?
13:11:41 <augur> olsner: im just awesome. :P
13:12:10 <matthew_-> ghc has a fixed recursion limit with certain flags. and a fixed stack depth. And tends to chew on a lot of memory, so finite resources may cause problems
13:12:27 <matthew_-> fortunately, I have access to a machine with 16GB of ram, so I might be in luck...
13:13:26 <Toxaris> the trick about encoding ones code with type-level RSA is that the error message in case of failure to provide the correct private key kills the atackers machine.
13:14:16 <matthew_-> Toxaris: lol
13:14:39 <matthew_-> ...and takes until the death of the universe to type check
13:14:42 <gwern> I would @remember that, but...
13:21:55 <nus> gwern, patch State/quote directly (-;
13:25:08 <nus> on a related note would my level of HS mastery be considered 'immediate' if I ever manage to debug Plugin/Type.hs ?-)
13:25:31 <dmwit> debug?
13:26:09 <nus> dmwit, lambdabot says strange things about interaction with ghci, so I consider it a bug.
13:26:21 <Saizan_> ?ty map
13:26:22 <noBotE> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:27:04 <nus> lambdabot> :t blah Main: caught (and ignoring) too few bytes. Failed reading at byte position 8 invalid ghci output: no type signature
13:35:41 <yitz> @listmodules
13:35:42 <noBotE> activity babel base bf check compose dice dict djinn dummy elite eval fact free fresh ft haddock help hoogle instances irc karma localtime log more oeis offlinerc pl pointful poll pretty quote
13:35:42 <noBotE> search seen slap small source spell state system tell ticker todo topic type undo unlambda unmtl url version vixen where
13:35:56 <yitz> @listchans
13:35:56 <noBotE> ##poetry #haskell #haskell-blah
13:36:17 <yitz> poetry?
13:36:45 <ddarius> @quote cummings
13:36:46 <noBotE> No quotes match. That's something I cannot allow to happen.
13:37:34 <yitz> @quote byron
13:37:34 <noBotE> No quotes match. And you call yourself a Rocket Scientist!
13:37:40 <yitz> @quote lordbyron
13:37:40 <noBotE> No quotes match. Do you think like you type?
13:42:19 <Botje> @qote
13:42:19 <noBotE> Maybe you meant: quote vote
13:42:21 <Botje> @quote
13:42:21 <noBotE> beelsebob says: > filter isJuggler #haskell
14:13:15 <Toxaris> wtf is a strange closure type 18313 ?
14:19:37 <dons> Toxaris: rts bug if you see that.
14:20:00 <Toxaris> it happens randomly when compiling
14:21:19 <Toxaris> dons: I guess I will ignore it for now :) thanks for the info.
14:23:37 <macondo> What's the way of determining if all the items in an array are equivalent?
14:23:59 <b_jonas> compare the first with each of the rest
14:24:03 <b_jonas> and and the results
14:24:07 <noecksit> hello, i'm having trouble with let and do statements in a function
14:24:23 <macondo> b_jonas: all (= x !! 0) x
14:24:34 <dolio> @type Data.Foldable.all
14:24:35 <noBotE> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Bool
14:24:47 <noecksit> is it "func = let purefunction in do inpure code" or smthing else?
14:25:07 <macondo> b_jonas: that was my first approach but I'm sure it has to be a more beautiful way
14:25:20 <b_jonas> macondo: sort of, but only compare to the rest (tail) of elements
14:25:21 <Peaker> noecksit, you can use "let x = y" in its own line, without an "in" section inside a "do"
14:25:45 <ddarius> noecksit: That will work. A 'do' block is just an expression.
14:26:11 <ddarius> Further, there's nothing impure about the body of a do block; it's very simple syntactic sugar.
14:26:15 <dolio> > let arr = listArray (0,4) [3,3,3,3] in Data.Foldable.all (==3) arr
14:26:16 <noBotE>  Exception: (Array.!): undefined array element
14:26:18 <dmwit> macondo: all (uncurry (==)) . ap zip tail
14:26:23 <kpreid> @undo let x = 1 in print x
14:26:23 <noBotE> let { x = 1} in print x
14:26:25 <ddarius> @undo do x <- m; let y = x+1; return y
14:26:25 <noBotE>  Parse error at end of input
14:26:30 <dolio> > let arr = listArray (0,4) [3,3,3,3,3] in Data.Foldable.all (==3) arr
14:26:31 <noBotE>  True
14:26:32 <kpreid> @undo do let x = 1; print x
14:26:32 <noBotE>  Parse error at end of input
14:26:37 <ddarius> @undo do x <- m; let { y = x+1 }; return y
14:26:37 <noBotE> m >>= \ x -> let { y = x + 1} in return y
14:26:43 <dmwit> macondo: It has the benefit of working for empty lists, too. =)
14:27:12 <noecksit> well, i get a weird error when i try to do that, and when i separate the function so that its on its own i seem to get no error
14:27:18 <b_jonas> dmwit: eek
14:27:45 <dmwit> But there's nothing wrong with "allEquiv [] = True; allEquiv (x:xs) = all (== x) xs".
14:27:46 <b_jonas> but wouldn't (all (= head x) (tail x)) also work for empty lists too?
14:27:49 <macondo> dmwit: I'm not sure if I understand what you are doing there, I'm just beginning
14:27:55 <b_jonas> > tail []
14:27:56 <noBotE>  Exception: Prelude.tail: empty list
14:27:59 <b_jonas> no, it wouldn't
14:28:00 <b_jonas> sorry
14:28:06 <vixey> null [()| i <- indices arr , arr ! 0 == arr ! i]
14:28:16 <ddarius> dmwit: Why wouldn't you use: and . ap (zipWith (==)) tail ?
14:28:19 <vixey> or maybe null [()| i <- indices arr , arr ! 0 /= arr ! i]
14:28:33 <b_jonas> dmeit: could you like unpl that?
14:28:39 <dmwit> ddarius: Because my mind is too weak. =)
14:28:41 <dolio> > (\l -> all (== head l) l) []
14:28:42 <noBotE>  True
14:28:50 <dmwit> ddarius: Of course, once suggested, I would certainly use that.
14:29:15 <ddarius> dmwit: uncurry and zip being in the same expression is usually a tip off.
14:29:17 <dmwit> b_jonas: Pattern matches are not pl-able in general, but that one probably is.  You have to do that part by hand though.
14:29:23 <ddarius> You can also calculate that result nicely.
14:29:30 <b_jonas> dmwit: I meant the one with ap
14:29:46 <dmwit> b_jonas: That is already pl-ed, isn't it?
14:29:52 <b_jonas> but unpl
14:29:57 <dmwit> Oh, sure.
14:30:16 <b_jonas> @unpl all (uncurry (==)) . ap zip tail
14:30:16 <noBotE> (\ c -> all (uncurry (==)) ((zip >>= \ e -> tail >>= \ d -> return (e d)) c))
14:30:22 <dmwit> b_jonas: \l -> all (uncurry (==)) (zip l (tail l)
14:30:35 <dmwit> b_jonas: But see ddarius' version for something even nicer.
14:30:37 <noecksit> @undo let f n = n * 2 in do putStrLn (f 2)
14:30:37 <noBotE> let { f n = n * 2} in putStrLn (f 2)
14:31:10 <noecksit> is this allowed?
14:31:22 <ddarius> noecksit: Yes, as has already been said.
14:31:36 <ddarius> Except n*2 is probably not going to be a String.
14:32:16 <macondo> dmwit: what do you think about this? let alleq (x:xs) = case xs of {"" -> True; _ -> if x == head xs then alleq xs else False}
14:33:33 <ddarius> > let allEq = (1==) . length . group in (allEq (replicate 10 4), allEq [1,2,1,1,1])
14:33:34 <noBotE>  (True,False)
14:33:54 <ddarius> > let allEq = (1==) . length . group in (allEq [])
14:33:55 <noBotE>  False
14:34:13 <ddarius> So I guess (1>=)
14:34:27 <macondo> > let alleq (x:xs) = case xs of {"" -> True; _ -> if x == head xs then alleq xs else False} in (alleq "aaa")
14:34:28 <noBotE>  True
14:34:50 <vixey> > null . tail . group $ "aaa"
14:34:51 <noBotE>  True
14:34:52 <vixey> > null . tail . group $ "axaa"
14:34:53 <noBotE>  False
14:35:02 <ddarius> > null . tail . group $ []
14:35:03 <noBotE>  Exception: Prelude.tail: empty list
14:35:09 <macondo> Ah, it breaks
14:35:16 <macondo> > let alleq (x:xs) = case xs of {"" -> True; _ -> if x == head xs then alleq xs else False} in (alleq "")
14:35:17 <noBotE>   Non-exhaustive patterns in function alleq
14:35:31 <ddarius> > null . drop 1 . group $ []
14:35:32 <noBotE>  True
14:35:36 <ddarius> > null . drop 1 . group $ [1,1,1]
14:35:37 <noBotE>  True
14:35:39 <ddarius> > null . drop 1 . group $ [1,2,1]
14:35:40 <noBotE>  False
14:35:45 <ddarius> There you go.
14:35:47 <macondo> Interesting
14:35:53 <noecksit> oh, smthing was wrong where i had a local and a global function defined with the same name actually
14:36:18 <dolio> > (\l -> all (head l ==) l) [1,2,1]
14:36:19 <noBotE>  False
14:36:32 <ddarius> noecksit: While shadowing is legal.  You should avoid it most of the time.
14:36:46 <dolio> Anyone here using ghc 6.9?
14:36:53 <Heffalump> dolio: I do a bit
14:37:02 <dolio> Does line editing work for you?
14:37:04 <MyCatVerbs> dolio: only when I shouldn't be.
14:37:07 <MyCatVerbs> dolio: yes.
14:37:10 <Heffalump> dolio: no :-(
14:37:18 <Heffalump> at least not since march - I stopped upgrading cos of that
14:37:23 <dolio> MyCatVerbs: Did you have to do anything special for that?
14:37:49 <vixey> I am dolio
14:37:55 <MyCatVerbs> dolio, Heffalump: HEAD is meant to be build against libedit instead of libreadline, because of the licensing issues. (libedit is BSD-licensed instead.)
14:37:58 <Peaker> I want to add an assertion, but it will be the first code that requires the arg to be an Eq instance.  Is there a way to have a "best-effort" assertion that will only assert if its an Eq, but otherwise not restrict it to be an Eq?
14:38:03 <MyCatVerbs> *built, even.
14:38:05 <vixey> it mostly works but sometimes it has glitches..
14:38:14 <dolio> Oh, hmm...
14:38:24 <ddarius> vixey: More commas in the future.
14:38:33 <Heffalump> MyCatVerbs: ok, but why doesn't that happen by default?
14:38:34 <MyCatVerbs> dolio, Heffalump: if you're on Ubuntu, you want to apt-get install libedit-dev libedit2
14:38:45 <Heffalump> ah, will it happen once those are installed?
14:38:48 <MyCatVerbs> Heffalump: it does, but you need to install libedit.
14:38:52 <dolio> MyCatVerbs: Thanks for the tip.
14:38:53 <Heffalump> ok, cool
14:38:57 <MyCatVerbs> Heffalump: yes, the configure script picks it up.
14:38:59 <Heffalump> what about the snapshots, will they work?
14:39:09 <Heffalump> or do I have to build with the dev libs installed for it to work?
14:39:29 <MyCatVerbs> So long as everything's at the same version.
14:39:49 <MyCatVerbs> libedit has a very stable API, so it doesn't make any odds in practice.
14:41:25 <MyCatVerbs> dolio: no worries. Thank Igloo, indirectly. :)
14:41:46 <MyCatVerbs> (Or maybe it was dons or dcoutts? I can't remember. Anyway, the people in #ghc rock.)
14:42:09 <TomMD> @seen
14:42:47 <roconnor> mmorrow: plot(w1,type="l") isn't as pretty as I had hoped
14:42:49 <nominolo> @seen swiert
14:42:50 <noBotE> I saw swiert leaving #haskell 7h 32m 38s ago, and .
14:42:52 <roconnor> in R
14:43:54 <mmorrow> roconnor: heh, yeah. sometime you're like awwww
14:44:37 <roconnor> mmorrow: I mean it is not bad
14:44:42 <mmorrow> roconnor: perfect timing, btw. just literally open my laptop after hours.
14:44:50 <roconnor> but ... not antialiased :)
14:45:25 <mmorrow> oh yeah. convert -antialias   'll set it straight
14:46:27 <mmorrow> roconnor: this hack might be handy (i'll paste)
14:46:51 <macondo> can you set a step when using [a..b]?
14:47:06 <iabal> yep
14:47:16 <roconnor> > [1,3..11]
14:47:17 <iabal> [a,b..c]
14:47:17 <noBotE>  [1,3,5,7,9,11]
14:47:17 <macondo> I remember it is possible, but I don't remember how
14:47:33 <iabal> is not just a step, is a+step
14:47:34 <macondo> oh, I was doing [a..b,c]
14:47:41 <roconnor> @hoogle enumFrom
14:47:41 <noBotE> A Hoogle error occured.
14:48:16 <noecksit> just out of curiousity, is there a better way to convert from Int to Double than "realToFrac"?
14:48:39 <roconnor> noecksit: fromIntegral will also work
14:48:41 <vixey> "better"?
14:49:00 <roconnor> @type realToFrac
14:49:01 <noBotE> forall a b. (Fractional b, Real a) => a -> b Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
14:49:19 <b_jonas> heeh
14:49:22 <noecksit> maybe not better, but other
14:49:22 <roconnor> noecksit: I don't think realToFrac works
14:49:33 <roconnor> @type (realToFrac :: Int -> Double)
14:49:34 <noBotE> Int -> Double
14:49:47 <roconnor> ?
14:49:51 <jinok> hey all, has anyone been through Ch. 28 (Sockets and Syslog) of Real World Haskell yet?
14:49:52 <roconnor> how is that possible?
14:49:58 <mmorrow> roconnor: i'm stillsearching for it, but Re: antialiasing
14:50:05 <mmorrow> use the Cairo device
14:50:11 <b_jonas> roconnor: because Int is an instance of Fractional
14:50:11 <wjt> @src realToFrac
14:50:11 <noBotE> realToFrac = fromRational . toRational
14:50:15 <vixey> @instances Real
14:50:16 <noBotE> Double, Float, Int, Integer
14:50:19 <mmorrow> roconnor: antialiases everything
14:50:22 <vixey> b_jonas: No it's not
14:50:25 <roconnor> mmorrow: ah, that would provide fair compatition with haskell charts
14:50:26 <b_jonas> it's not?
14:50:28 <b_jonas> hmm
14:50:37 <roconnor> Int is a Real?
14:50:44 <b_jonas> roconnor: sure it is
14:50:45 <vixey> roconnor: yes
14:50:59 <roconnor> okay what is Real again.
14:51:00 <mmorrow> roconnor: here's and example of it's use: http://code.haskell.org/~morrow/code/R/mapping.R.html
14:51:04 <roconnor> what terrible names
14:51:07 <mmorrow> s/and/an/
14:51:16 <vixey> :t let foldn z s 0 = z ; foldn z s n = s (foldn z n (n-1)) in foldn 0 (1+)
14:51:17 <noBotE> forall t. (Num t, Num (t -> t)) => (t -> t) -> t
14:51:18 <noecksit> @instances Fractional
14:51:19 <noBotE> Double, Float
14:51:34 <vixey> :t let foldn z s 0 = z ; foldn z s n = s (foldn z s (n-1)) in foldn 0 (1+)
14:51:35 <noBotE> forall t t1. (Num t, Num t1) => t1 -> t
14:51:51 <MyCatVerbs> No, Int isn't an instance of Fractional.
14:52:01 <MyCatVerbs> Double is an instance of Fractional, silly.
14:52:03 <roconnor> @type toRational
14:52:04 <noBotE> forall a. (Real a) => a -> Rational Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
14:52:09 <MyCatVerbs> (/) isn't defined on Ints.
14:52:23 <b_jonas> so Real is Num and Ord with toRational
14:52:25 <roconnor> Real is a terrible name for that class
14:52:30 <b_jonas> why is it?
14:52:34 <b_jonas> it's not such a bad name
14:52:57 <roconnor> because it has nothing to do with real numbers
14:53:03 <b_jonas> why not?
14:53:10 <mmorrow> roconnor: you'll prob have to get it from CRAN
14:53:13 <roconnor> in fact, the real numbers don't even have a toRational function.
14:53:18 <mmorrow> roconnor: section 6.3 here: http://cran.r-project.org/doc/manuals/R-admin.pdf
14:53:24 <vixey> yeah it's well known that haskells numeric hierarchy is stupid
14:53:25 <mmorrow> http://cran.r-project.org/
14:53:25 <noBotE> Title: The Comprehensive R Archive Network
14:53:31 <MyCatVerbs> Anyway. realToFrac :: Int -> Double is a really inefficient way of doing things, I'll wager.
14:53:36 <b_jonas> a Real is a number that has comparison and can be rounded to a rational so it must be arbitarily near a rational ergo is a real number
14:54:00 <vixey> b_jonas: shouldn't it be something like a complete archimedian ordered field?
14:54:06 <b_jonas> vixey: no
14:54:09 <MyCatVerbs> It involves turning an integer n into a pair (n,1) (numerator and denominator), then converts the integer n to a double m, then returns (m/1), doing an unnecessary division.
14:54:10 <b_jonas> it can be a subset of reals
14:54:18 <roconnor> mmorrow: is there an easy way to get a Cairo device from the REPL?
14:54:18 <mmorrow> roconnor: http://cran.r-project.org/web/packages/Cairo/index.html
14:54:19 <noBotE> Title: CRAN - Package Cairo
14:54:23 <MyCatVerbs> For Pete's sake, use the "round" function instead.
14:54:23 <b_jonas> it means that all instances are reals
14:54:27 <b_jonas> not that all reals are instances
14:54:47 <b_jonas> just like how a Num doesn't have to be able to represent all numbers
14:55:03 <vixey> b_jonas: every Integer is in the set of reals, but the set of integers is not a real
14:55:04 <roconnor> b_jonas: all instances are also rationals, and complex numbers
14:55:19 <mmorrow> roconnor:
14:55:20 <mmorrow> > library(cairoDevice)
14:55:20 <mmorrow> > Cairo(width = 9, height = 9, pointsize = 10, surface = "screen")
14:55:20 <mmorrow> > plot(1)
14:55:20 <noBotE>  Parse error at "=" (column 13)
14:55:21 <noBotE>   Not in scope: `cairoDevice'
14:55:21 <noBotE>   Not in scope: `plot'
14:55:23 <roconnor> b_jonas: why pick the name reals
14:55:40 <b_jonas> rocconor: but you can't have non-real complex numbers in Real
14:55:45 <b_jonas> so complex wouldn't be too precise
14:55:49 <b_jonas> and they don't have to be all rationals
14:56:11 <b_jonas> I've written a type that represents all quadratic irrational real numbers
14:56:12 <mmorrow> roconnor: to write to a pdf, swap filename="a.pdf" for surface="screen"
14:56:13 <roconnor> b_jonas: how can you have a toRational function if the are not all rationals?
14:56:23 <b_jonas> and that is a Real minus the toRational
14:56:32 <b_jonas> roconnor: as an approximation
14:56:36 <b_jonas> I didn't write that function though
14:56:37 <mmorrow> roconnor: oh, and swap Cairo_pdf for Cairo
14:56:42 <jinok> hey dons, did you write the sockets and syslog chapter (#28) of RWH?
14:56:44 <roconnor> b_jonas: that's stupid
14:56:45 <b_jonas> and the other functions didn't work well
14:56:52 <b_jonas> hmm, you're saying something actually
14:56:55 <b_jonas> dunno
14:57:03 <b_jonas> maybe it should be rational then
14:57:13 <roconnor> :)
14:57:15 <b_jonas> but definitely not complex because it's Ord
14:57:32 <roconnor> ok
14:57:37 <b_jonas> hmm
14:58:30 <b_jonas> yeah, I guess it should be rational or something
14:58:58 <roconnor> mmorrow: does R have support for ploting date/time data?  For the moment I've converted the data to the modified Juliean day, but it makes it hard to read the dates :)
14:59:53 <roconnor> mmorrow: ah found the ubuntu package r-cran-cairodevice
15:00:58 <hpaste>  petekaz pasted "Simple IMAP client to check for new messages" at http://hpaste.org/8627
15:01:07 <b_jonas> and of course some say that Monad shouldn't be called that
15:01:36 <roconnor> What do they say Monad should be called?
15:01:46 <b_jonas> something that implies it has fail
15:01:49 <b_jonas> I dunno
15:02:06 <hpaste>  morrow pasted "*hack* cgi script to plot data from sqlite in R" at http://hpaste.org/8628
15:02:15 <Saizan_> ..that's kind of backwards
15:02:32 <b_jonas> btw, gnuplot can plot dates
15:02:52 <roconnor> b_jonas: oh well, fail should be removed from the monad class
15:02:57 <roconnor> :)
15:03:10 <b_jonas> though I found this out only recently, and I've converted dates to unix epoches in lots of plots
15:03:16 <b_jonas> roconnor: yep, that's what they say
15:03:16 <roconnor> b_jonas: so can haskell charts :)
15:03:40 <mmorrow> roconnor: sweet! hmm, off the top of my head i'm not sure how you'd handle to dates, but i'm sure there's a way
15:04:05 <mmorrow> roconnor: i usually prepare the data as much as possible before it goes into R
15:05:15 <mmorrow> roconnor: then read.table(...) and do the plotting stuff
15:05:41 <roconnor> ah
15:05:47 <roconnor> the cairo plot is nicer
15:06:02 <roconnor> I don't suppose R can generate SVG?
15:06:17 <roconnor> that is one thing that I'm not sure haskell charts can do.
15:07:04 <mmorrow> roconnor: the pain in the ass is that unless you have an X11 device present, it can only do a subset of it's possible output formats
15:07:36 <mmorrow> so, for instance, in that sh cgi script, i had to go to hackmode10 to get it to a png
15:08:12 <mmorrow> roconnor: but wrt SVG, i've never output to that so i'm not sure how (but i bet you can...)
15:10:35 <mmorrow> roconnor: toally, i use the cairo device for everything :)
15:15:11 <roconnor> I should install Cabal 1.2
15:16:00 <roconnor> can cabal 1.1 install cabal 1.2?
15:16:06 <roconnor> er
15:16:08 <roconnor> or 1.4
15:16:08 <dons> cabal 1.2 comes with ghc 6.8.x
15:16:12 <dons> i guess you want 1.4.1 ?
15:16:21 <roconnor> I have ghc 6.6
15:16:27 <dons> and yes, it can bootstrap itself
15:19:13 <roconnor> hm
15:19:41 <roconnor> the more packages I install, the more disinsentive there is to upgrage to ghc 6.8
15:19:49 <roconnor> :)
15:20:16 <Peaker> conal, deep into implementing the list delta example, I realized that at least in terms of efficiency, a linked-list delta is quite useless (My Python list delta is actually an array delta, as Python lists are really arrays)
15:20:50 <Peaker> conal, a general-delta on a list is really O(n) to apply, just like a whole new list..
15:22:13 <jinok> i'd like to work through how to persist server state across multiple requests, using ch. 28 of Real World Haskell as a jumping off point.  would anyone be willing to help out?
15:23:06 <Peaker> conal, I guess for example purposes that's not too bad though
15:23:11 <dmwit> jinok: Got a link to chapter 28 for the terminally lazy?
15:23:17 <roconnor> woah, cabal-setup
15:23:22 <jinok> http://book.realworldhaskell.org/beta/sockets.html
15:23:23 <noBotE> Title: ChapterÂ 28.Â Sockets and Syslog
15:24:18 <Saizan> cabal-setup is supposed to be obsoleted by cabal-install i think
15:24:40 <roconnor> oh
15:24:41 <roconnor> ok
15:24:47 <dmwit> jinok: What is your server serving?
15:25:10 <dmwit> jinok: Is it the syslog server shown there, or something more interesting like web/IRC?
15:25:43 <jinok> it's just the syslog server as is for now, i'm really just trying to grok some fundamentals
15:26:02 <dmwit> Cool, what do you want to persist?
15:26:52 <dmwit> (Without seeing what you're trying to do, I might suggest just writing/reading a file on the server.)
15:26:58 <jinok> what i'd like to do is change the server from printing out each message it receives, to stuffing that message into a buffer.  when the buffer fills (say, 10 messages), then the server prints them out.
15:27:17 <dmwit> ah
15:27:31 <dmwit> Give me a second to look at the server code.
15:28:35 <roconnor> ooh, numeric-prelude is in hackage
15:28:52 <jinok> the mental barrier i'm trying to work through is how to write the HandlerFunc that works with the persistent state.
15:29:11 <dmwit> Yeah, that may not really be feasible/idiomatic.
15:29:37 <dmwit> It can be done (by doing a closure over an IORef, say), but you wouldn't really see it done that way in common code.
15:30:20 <dmwit> I recommend morphing the serveLog code, instead.
15:30:54 <dmwit> replicateM will repeat an IO action a given number of times.
15:31:21 <roconnor> if I ghc-pkd unregister a package, will the data be deleted (freeing up hard drive space)?
15:31:22 <dmwit> So, if instead of (recvFrom sock 1024) you use (replicateM 10 (recvFrom sock 1024)), you will receive 10 messages.
15:31:27 <roconnor> ghc-pkg
15:31:38 <dmwit> They will be stored in a list, and you can then pass that list on to your handler.
15:31:45 <dmwit> But the handler will have to have a different type.
15:31:47 <Saizan> roconnor: no
15:31:56 <dmwit> jinok: Did you follow that, or should we go more slowly?
15:32:02 <roconnor> Saizan: is there a proper method for cleaning up old packages?
15:32:20 <Saizan> roconnor: you've to rm the files manually
15:32:21 <roconnor> I don't even know where the packages are stored
15:32:49 <jinok> i think i followed that, but i don't know if i like it :)
15:32:54 <dmwit> =)
15:32:55 <dons> jinok: maybe use Chans?
15:33:06 <dons> and a writer/buffer thread.
15:33:12 <dons> hmm. nice exercise
15:33:23 <roconnor> Saizan: am I supposed to cabal uninstall my old packages?
15:34:51 <jinok> I am still very new to haskell.  I'm willing to try anything, but I'm not familiar with the libraries and idioms yet.
15:34:55 <Saizan> roconnor: well they shouldn't interfere with the use of newer packages, but if you want to free space you can unregister them and delete the files, ghc-pkg describe package will tell you where the files are, before unregistering
15:35:31 <dmwit> jinok: There's a very readable paper by SPJ on Chans.  I think it's the "Tackling the Awkward Squad" paper.
15:35:42 <dmwit> (But it could be "Beautiful Concurrency" instead.)
15:36:04 <Saizan> roconnor: global ones are under /usr/local/lib, and user ones under ~/.cabal/lib by default
15:36:11 <wjt> Beautiful Concurrency is about TVars, if that's the essay from Beautiful Code
15:37:48 <jinok> "Tackling the Awkward Squad:
15:37:49 <jinok> monadic input/output, concurrency, exceptions, and
15:37:49 <jinok> foreign-language calls in Haskell"?
15:37:49 <dmwit> Yep, it's Tackling.  Section 4: Concurrency starts on page 28, though the rest of the paper is nice, too.
15:38:00 <dmwit> Yes, that one.
15:38:08 <jinok> excellent, thank you.
15:39:14 <dmwit> The semantics subsection will be difficult to follow if you don't read section 3... =P
15:39:26 * roconnor cleans out some old unused packaged from /usr/local/lib
15:39:47 <Peaker> conal, do you mind if I implement a Data.Map delta instead? List/array deltas are significantly more complicated..
15:40:03 <jinok> dons:  btw, your blog and advocacy on reddit are what got me interested in haskell, thanks.
15:40:23 <dons> hehe.
15:40:41 <hpaste>  dons pasted "print messages in chunks of 10" at http://hpaste.org/8629
15:40:56 <dons> so that example ^^ uses one thread to generate messages every 0.5 seconds
15:41:11 <dons> the other thread accumulates them in chunks of 10, printing them out once all 10 are seen
15:41:34 <dons> so in effect you'll see 10 messages printed every 5 seconds
15:41:40 <dmwit> This would also require a modification to serverLog, right?
15:41:54 <dons> concurrency is a nice solution to some problem.
15:41:57 <dmwit> Since the handler passed to serverLog takes only a single element, not the whole (infinite) list.
15:42:11 <dons> yeah, here it uses a chan
15:42:17 <dons> so you'd need to set up some plumbing
15:42:28 <dons> have the log fork a buffer thread, for example, and write to that every time a message arrives
15:42:35 <dons> somewhere there has to be a buffer, here it is a Chan
15:42:54 <Peaker> What would be a sensible class for Monoid plus negation?
15:43:46 <mauke> Group
15:44:07 <roconnor> hackageDB could use a TOC of module names
15:44:18 <Peaker> mauke, no pre-existing class for this though?
15:44:32 <mauke> I don't know
15:44:59 <edwardk> peaker: a group, no class exists in haskell for it though
15:45:23 <edwardk> blame the non-math-centric mathematical hierarchy
15:45:50 <edwardk> i mean, what is a Num anyways? =) what properties hold? =)
15:45:51 <yitz> Peaker: Group
15:46:31 <yitz> ah, mauke said that.
15:47:36 <dmwit> > "what bot is serving the room right now?"
15:47:37 <noBotE>  "what bot is serving the room right now?"
15:47:45 <roconnor> edwardk: is Num a normed ring?
15:47:47 <mauke> @bot
15:47:47 <noBotE> :)
15:48:07 <roconnor> hmm
15:48:30 <edwardk> roconnor: except you have no laws interconnecting (+), (-), (*), negate, abs, signum and fromInteger.
15:48:47 <edwardk> roconnor: because you make Floats into Nums and they satisfy almost nothing.
15:48:52 <yitz> oconnor: normed?
15:49:02 <roconnor> edwardk: :)
15:49:08 <mauke> what's the opposite of a norm?
15:49:11 <yitz> roconnor: normed?
15:49:12 <roconnor> Floats don't fit into a mathematical heirarchy
15:49:19 <roconnor> normed!
15:49:30 <roconnor> having a norm
15:49:38 <yitz> roconner: you mean abs?
15:49:42 <edwardk> brb
15:49:54 <jinok> dons:  awesome, thanks.  looking at this, though, i realize this isn't really what i want.  what i'm more interested in is persisting the data structure.  for instance, what if instead of a list, i wanted to keep a running tally of how many messages i had received from each ip address?
15:49:58 <roconnor> that is the function that would imply a norm
15:50:31 <dons> jinok: write, you'd store the local state in the buffer function
15:50:40 <roconnor> maybe floating point numbers shouldn't be allowed to use + and *
15:50:46 <dons> read messages off the chan, use them to increment a parameter.
15:50:47 <dons> let's see..
15:51:02 <Peaker> where can I find data-type definitions that can describe Haskell code?
15:51:10 <mauke> roconnor: welcome to OCaml
15:51:18 <jinok> ah, lightbulb!
15:51:19 <yitz> roconnor: we've gone around in circles on the cafe several times about that
15:51:21 <vixey> Language.Haskell
15:51:21 <jinok> thanks
15:51:27 <Peaker> vixey, thanks
15:53:14 <Peaker> vixey, that's pretty large!
15:53:49 <yitz> roconnor: is Num a mathematical thing, or is it data structures that approximate the math for computing?
15:53:50 <hpaste>  dons annotated "print messages in chunks of 10" with "abstract out message channel better" at http://hpaste.org/8629#a1
15:54:01 <dons> jinok: like that, I guess?
15:54:22 <dons> just use the channel for message passing, while keeping a thread-local counter
15:54:43 <ziman> what laws do Floats break?
15:55:13 <vixey> you probably simplify it down to your own type to actually use it
15:55:21 <vixey> at least that's one thing you can do
15:55:29 <vixey> ziman: + isn't comutative
15:55:29 <mauke> I wouldn't bet on a * (b + c) = a*b + a*c
15:55:45 <mauke> I think + is commutative
15:55:53 <mauke> associativity doesn't hold, though
15:56:19 <vixey> that's the one I meant thanks mauke
15:56:50 <ziman> and what use would floats have if (+) and (*) were forbidden for them?
15:57:11 <jinok> dons:  yes, that's great; i see how that can grow.  thank you!
15:57:23 <Peaker> (+) can be cummutative for floats.. just always sort left/right by some arbitrary property?
15:59:01 <roconnor> yitz: should the compiler be allowed to assume associtivity of (+) (think parallel map/reduce)?
15:59:37 <EvilTerran> we must encode this property in the typesystem!
16:00:03 <roconnor> EvilTerran: no, but we might what to write it into a haskell report
16:00:06 <yitz> roconnor: for floats, you have to decide this per algorithm. sometimes, yes.
16:00:16 <EvilTerran> roconnor, indeed, that'd make sense
16:00:17 <roconnor> I think the compiler should be allowed to assume associative of (+)
16:00:27 <vininim> (0.1 + 1e100) - 1e100 != 0.1 + (1e100 - 1e10)
16:00:36 <EvilTerran> the report already specifies properties that must hold for various things that aren't enforced at the type level
16:00:42 <vininim> disconsdering my typo
16:00:57 <vininim> and grammar D:
16:01:01 <roconnor> special (floatPlus) should be used by those who need to know the compiler isn't screwing with their floating point numbers
16:01:18 <yitz> roconnor: floats are implemented in hardware, we don't have control over that. but we do use them as numbers, even though the laws get fuzzy near the edges.
16:01:25 <EvilTerran> so it does make those assumptions, then?
16:01:37 <vixey> I prefer import DangerousFloats
16:01:44 <vixey> vs import Floats
16:01:53 <vixey> then you can use + and not floatPlus
16:02:05 <roconnor> yitz: the bigger question is, should the compiler be allowed to rewrite (a+b)-b as a?
16:02:22 <roconnor> yitz: some floating point algorithms require that the compiler not do this
16:02:32 <roconnor> yitz: but most people don't care I think.
16:02:33 <EvilTerran> i think our machine learning lecturer would say that doing so would be "probably approximately correct"
16:02:40 <yitz> roconnor: right.  for floats you have to tell the compiler.
16:02:59 <roconnor> I think both ways should be allowed.
16:03:16 <roconnor> preferably in some fine grained way
16:03:27 <yitz> roconnor: if the rewrite is significant enough, then you must care
16:03:31 * vixey thinks we should just use CReal
16:03:39 <vixey> who needs Floats..
16:04:20 <vininim> some other stuff breaks when you consider moves from float hardware to/from memory.
16:04:20 <yitz> vixey: tell the chip designers
16:04:24 <augustss_> Floating point is nasty
16:05:18 <yitz> we do the same kind of fuzzy thing with Monad due to seq
16:05:34 <augustss_> seq is nasty
16:06:03 <dmwit> people are nasty, let's not go shopping
16:06:09 <yitz> seq should be a type class
16:06:19 <dmwit> yitz: It is.
16:06:23 <augustss_> yitz: yes, as it used to be
16:06:25 <dmwit> ...just not under that name
16:07:02 <dmwit> Control.Concurrent.Strategies
16:07:45 <dmwit> err...
16:07:57 <roconnor> I wonder of the reasons for removing the Seq typeclass still hold water today.
16:08:08 <roconnor> I found it uncompelling when reading History of Haskell
16:08:30 <roconnor> then again, I also find the monomorphism restriction uncompelling.
16:08:42 <EvilTerran> dmwit, Control.Parallel.Strategies?
16:08:49 <dmwit> Yeah, maybe.
16:09:04 <EvilTerran> Control.Concurrent is for explicit IPC and suchlike
16:09:14 <dons> changing the type of things to add a bang pattern would be annoying
16:09:25 <yitz> augustss: the monomorphism restriction is...
16:09:41 <dmwit> rnf :: NFData a => a -> Done
16:09:48 <yitz> come on, say it, nasty.
16:12:20 <yitz> dons: I guess bang patterns syntax would have to be restricted to instances, like do notation.
16:14:09 <mapreduce> How would you do something like, given [1,2,2,3,4,4,5], when you see an odd number, skip it and the number after it, otherwise, return double the number?
16:14:11 <yitz> and strict ADT fields
16:14:23 <mapreduce> [1,2,2,3,4,4,5] would hence give 4, 8
16:14:46 <EvilTerran> manual recursion, i guess
16:15:08 <mapreduce> You could do it with zipping with the tail, but then it wouldn't stretch to skipping more than 2 numbers very well.
16:16:04 <vixey> wobble (x:y:z:zs) | odd x = 2 * z : wobble zs
16:16:17 <EvilTerran> > let f [] = []; f (x:xs) | odd x = f (drop 1 xs) | otherwise = (2*x) : f xs in f [1,2,2,3,4,4,5]
16:16:19 <noBotE>  [4,8]
16:16:52 <vixey> oeau
16:17:02 <vixey> oops
16:17:29 <dmwit> > (\xs -> [2 * y | (x, y) <- ap zip tail xs, even x, even y]) [1,2,2,3,4,4,5]
16:17:30 <noBotE>  [4,8]
16:18:17 <mapreduce> I guess EvilTerran's is a bit less sensitive to how many to skip.
16:18:34 <mapreduce> I mean, it would work if you needed to drop 2 or 3 instead, with only changing 1 to 2 or 3.
16:18:40 <dmwit> Quite a lot less, yes.
16:18:44 <mauke> > (\xs -> [2 * y | (x, y) <- ap zip tail xs, even x, even y]) [1,1,2]
16:18:45 <noBotE>  []
16:18:47 <mauke> fail
16:19:00 <dmwit> Plus mine is buggy. =)
16:19:04 <yitz> > let f (x:xs) | odd x = Just (Nothing, drop 1 xs) | otherwise = Just (Just $ 2*x, xs); f _ = Nothing in unfoldr f [1,2,2,3,4,4,5]
16:19:05 <noBotE>  [Nothing,Just 4,Nothing,Just 8,Nothing]
16:19:18 <yitz> > let f (x:xs) | odd x = Just (Nothing, drop 1 xs) | otherwise = Just (Just $ 2*x, xs); f _ = Nothing in catMaybes $ unfoldr f [1,2,2,3,4,4,5]
16:19:19 <noBotE>  [4,8]
16:19:43 <mauke> this reminds me of "my" list problem
16:19:56 <EvilTerran> i figure, unless the parameter to unfoldr is pointsfree, you're better off writing an explicit recursion
16:19:58 <EvilTerran> if anything, it winds up less verbose
16:20:26 <Peaker> @type unfoldr
16:20:27 <noBotE> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:20:44 <mapreduce> EvilTerran: I really like your version, thanks.
16:20:56 <EvilTerran> :)
16:21:09 <Peaker> @djinn (b -> Maybe (a, b)) -> b -> [a]
16:21:09 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
16:21:20 <Peaker> djinn is pretty useless :)
16:21:48 <dmwit> > let splitBy p = groupBy (\x y -> p x && not (p y)) in splitBy odd [1,2,2,3,4,4,5]
16:21:49 <noBotE>  [[1,2,2],[3,4,4],[5]]
16:22:05 <Toxaris> :t const (const []) :: (b -> Maybe (a, b)) -> b -> [a]
16:22:06 <noBotE> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:22:09 <yitz> @pl \(x:xs) -> if odd x then Just (Nothing, drop 1 xs) else Just (Just $ 2*x, xs)
16:22:09 <noBotE> ap (ap (ap . (. (Just . (,) Nothing . drop 1)) . if' . odd) ((Just .) . (,) . Just . (2 *)) . head) tail
16:22:10 <dmwit> > let splitBy p = groupBy (\x y -> p x && not (p y)) in splitBy odd [1,2,2,3,4,4,5] >>= map (*2) . drop 2
16:22:11 <noBotE>  [4,8]
16:22:22 <Toxaris> Peaker: not every proof is the program you want
16:22:37 <dmwit> I like mine for obfuscation purposes. =)
16:22:37 <roconnor> added an SVG backend to Haskell Charts
16:22:41 <roconnor> very simple
16:22:42 <yitz> EvilTerran, there you go, pointsfree. :)
16:22:57 <mauke> > let splitBy p = groupBy (\x y -> p x && not (p y)) in splitBy odd [1,1,2] >>= map (*2) . drop 2
16:22:58 <noBotE>  []
16:23:00 <mauke> fail
16:23:02 <EvilTerran> mmm, tasty
16:23:07 <Peaker> Toxaris, it seems to fail to find a program for any type that's more complicated than a first-order trivial function, at worst with a tuple thrown in
16:23:14 <yitz> roconnor: w/ Cairo, or from scratch?
16:23:17 <dmwit> mauke: Bah!
16:23:19 <dmwit> mauh
16:23:20 <dmwit> bauh
16:23:26 <dmwit> ...bah
16:23:40 <roconnor> yitz: w/Cairo
16:23:50 <yitz> roconnor: nice!
16:23:51 <roconnor> eventually I want to make a raw SVG backend
16:23:59 <roconnor> so that gtk2hs doesn't need to be installed
16:24:08 <ziman> @djinn (a->b)->(c->d)->(a,c)->(b,d)
16:24:08 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
16:24:17 <yitz> roconnor: it would be nice to have Cairo without gtk
16:24:22 <vixey> ?djinn (b -> c) -> (a -> b) -> (a -> c)
16:24:22 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
16:24:23 <Toxaris> Peaker: well, const (const []) is a quite easy inhabitant of unfoldr's type, so it djinn seems to be really broken
16:24:24 <roconnor> yitz: ah
16:24:31 <roconnor> yitz: that might be better still
16:24:33 <dcoutts> yitz: it's just a packaging issue
16:24:36 <dmwit> > let splitBy p = groupBy (\x y -> not (p y)) in splitBy odd [1,2,2,3,4,4,5] >>= map (*2) . drop 2
16:24:36 <Toxaris> ?djinn a -> [a]
16:24:37 <noBotE>  [4,8]
16:24:37 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
16:24:42 <mauke> @djinn a -> a
16:24:42 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
16:24:43 <dmwit> > let splitBy p = groupBy (\x y -> not (p y)) in splitBy odd [1,1,2] >>= map (*2) . drop 2
16:24:44 <noBotE>  []
16:24:46 <mauke> bot's broken
16:24:48 <dmwit> There we go.
16:24:52 <Saizan> djinn doesn't handle lists at all.
16:24:52 <dcoutts> yitz, roconnor: we'll have a separate cairo when we cabalise gtk2hs
16:24:56 <vixey> @undef
16:24:57 <noBotE> Undefined.
16:25:00 <yitz> dcoutts: "just" a packaging issue? :)
16:25:06 <mauke> dmwit: what
16:25:08 <Peaker> Toxaris, that's true of anything that returns a list. I think it tries to use all the args though
16:25:08 <vixey> ?djinn (b -> c) -> (a -> b) -> (a -> c)
16:25:09 <noBotE> Plugin `djinn' failed with: Prelude.tail: empty list
16:25:09 <roconnor> dcoutts: that's good news
16:25:30 <dcoutts> yitz: sure, the cairo package does not depend on the gtk package. It's just that we currently build them together.
16:25:39 <chessguy> i can't remember, if i've got an algebraic data type, and i've made it an instance of Arbitrary...how do i actually get arbitrary values of it?
16:25:51 <mauke> f [1,1,2] --> [4]
16:25:52 <dmwit> > let splitBy p = groupBy (const p) in splitBy even [1,1,2]
16:25:53 <yitz> dcoutts: oh, ok. yes, that would be great!
16:25:53 <noBotE>  [[1],[1,2]]
16:26:05 <roconnor> dcoutts: that explains the namespaces
16:26:09 <vixey> what's Arbitrary
16:26:13 <dmwit> > let splitBy p = groupBy (const p) in splitBy even [1,1,2] >>= map (*2) . drop 1
16:26:14 <noBotE>  [4]
16:26:15 <vixey> @src Arbitrary
16:26:15 <noBotE> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:26:23 <dmwit> > let splitBy p = groupBy (const p) in splitBy even [1,2,2,3,4,4,5] >>= map (*2) . drop 1
16:26:24 <noBotE>  [4,4,8,8]
16:26:27 <EvilTerran> it's something quickcheck uses, iirc
16:26:28 <dmwit> oof
16:26:32 <vixey> is that quickcheck
16:26:43 <mauke> you can't do this with normal list processing functions
16:28:13 <Frederick> folks can anyone here point me to a papr explaining the do command?
16:28:14 <yitz> dmwit: those groupBy tricks can be nice, but they depend on the implementation of groupBy, so you can't rely them.
16:28:31 <dmwit> yitz: I know. =/
16:28:55 <EvilTerran> aren't implementations supposed to follow the behaviour of the report definitions?
16:28:57 <mauke> Frederick: http://mauke.ath.cx/stuff/haskell/how-to-io.html#a7
16:28:59 <noBotE> Title: Haskell: How To IO
16:29:13 <yitz> EvilTerran, yeah, but it's still an artifact.
16:29:26 <EvilTerran> true
16:29:40 <dmwit> Frederick: Do you know how monads work?
16:29:53 <dmwit> Frederick: If not, take your pick of the many monad tutorials out there.
16:30:08 <dmwit> ?go you could have invented monads
16:30:10 <noBotE> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
16:30:10 <noBotE> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
16:30:10 <dmwit> ?go all about monads
16:30:12 <noBotE> http://www.haskell.org/all_about_monads/
16:30:12 <noBotE> Title: All About Monads
16:30:17 <Frederick> dmwit: Im looking dfor someone very specific
16:30:22 <Frederick> 1 sec Iprovede a link
16:30:39 <dmwit> Frederick: Once you know how monads work, "do" is very simple.
16:31:29 <dmwit> do {a <- x; y} --> x >>= \a -> y
16:31:42 <dmwit> do {x; y} --> x >> y --> x >>= \_ -> y
16:32:16 <dmwit> do {let a = x; y} --> let a = x in y
16:32:20 <dmwit> do {y} --> y
16:32:39 <dmwit> That last rule may only be applied if none of the previous rules apply.
16:32:47 <vixey> > do Nothing
16:32:48 <noBotE>  Nothing
16:33:08 <vixey> > Just (do Nothing)
16:33:09 <noBotE>  Just Nothing
16:33:19 <chessguy> @hoogle generate
16:33:19 <noBotE> A Hoogle error occured.
16:34:45 <chessguy> > generate 52  (mkStdGen 42) (arbitrary :: Int)
16:34:46 <noBotE>   Not in scope: `generate'
16:35:08 <chessguy> > Test.QuickCheck.generate 52  (mkStdGen 42) (arbitrary :: Int)
16:35:09 <noBotE>   Not in scope: `Test.QuickCheck.generate'
16:35:15 <dmwit> ?index generate
16:35:15 <noBotE> Test.QuickCheck, Debug.QuickCheck
16:35:34 * chessguy mutters something ugly under his breath
16:35:57 <dmwit> Blast!  You might have to open a terminal and run ghci!
16:36:51 <dmwit> Actually, the line "do {a <- x; y} --> x >>= \a -> y" wasn't perfectly accurate.  but meh
16:36:53 <Toxaris> > map (* 2) . map head . filter (even . head . tail) . filter (even . head) . tail . tail . reverse . tails . reverse . (0 :) $ [1,2,2,3,4,4,5]
16:36:55 <noBotE>  [4,8]
16:37:04 <Itkovian> Would this be a good way to print information? putStr $ unlines $ map (printf "relative error =  %f" :: Double -> String) [0.1, 0.2]
16:37:50 <dmwit> > map (* 2) . map head . filter (even . head . tail) . filter (even . head) . tail . tail . reverse . tails . reverse . (0 :) $ [1,1,2]
16:37:51 <noBotE>  []
16:37:56 <EvilTerran> mapM (printf "relative error =  %f" :: Double -> String) [0.1, 0.2]
16:38:09 <chessguy> dmwit:  for your information, ghci isn't working right either
16:38:12 <chessguy> and i'm not sure why
16:38:14 <dmwit> chessguy: =/
16:38:26 <shachaf> EvilTerran: You mean :: Double -> IO ()?
16:38:29 <EvilTerran> ?instances-importing Text.Printf PrintfType
16:38:30 <noBotE> (a -> r), IO a, [c]
16:38:33 <Toxaris> dmwit: oh missed the significance of that test case
16:38:34 <EvilTerran> er, yes
16:38:41 <EvilTerran> copy-and-paste fail
16:39:05 <dmwit> You probably also want s/%f/%f\n/.
16:39:13 <Frederick> dmwit: I have something like http://pastey.net/90231 and I want tounderstandwhy it runs in paralel
16:39:46 <dmwit> Frederick: That's not legal.  And it doesn't run in parallel.
16:40:25 <Frederick> dmwit: but I got this idea  from this article http://research.microsoft.com/~simonpj/papers/com.ps.gz
16:40:31 <dmwit> > let (#) = (+) in 3 #3 -- maybe it could be legal
16:40:32 <noBotE>  6
16:41:52 <dmwit> Okay, so maybe foo #foo could be legal.
16:41:56 <dmwit> :t \x -> x $ x
16:41:57 <noBotE>     Occurs check: cannot construct the infinite type: a = a -> b
16:41:57 <noBotE>     Probable cause: `x' is applied to too few arguments
16:41:57 <noBotE>     In the second argument of `($)', namely `x'
16:42:02 <dmwit> nope =P
16:42:59 <Frederick> dmwit: ?
16:43:09 <dmwit> Frederick: Can you be a bit more specific?  What part of the paper are you talking about, and what is it that is run in parallel?
16:43:40 <Frederick> dmwit: sure look for do eric sings
16:43:46 <Frederick> loog for #sings
16:43:53 <dmwit> (In any case, it is nothing intrinsic about "do" that makes things run in parallel.  "do" is just the introducing keyword to a nice piece of syntactic sugar.)
16:45:03 <MyCatVerbs> dmwit: (&&&) from Control.Arrow, of course! Feel free to put both sides of the tuple on opposite sides of a `par`. :)
16:45:49 <Itkovian> EvilTerran: that mapM line certainly does not seem to do what I want
16:45:52 <Itkovian> > mapM (printf "relative error =  %f" :: Double -> String) [0.1, 0.2]
16:45:53 <noBotE>  ["rr","re","rl","ra","rt","ri","rv","re","r ","re","rr","rr","ro","rr","r ",...
16:45:54 <dmwit> Frederick: Sounds like he's talking about the COM library specifically.
16:46:10 <Frederick> dmwit: so it is not something on the language?
16:46:12 <dmwit> Itkovian: s/String/IO ()/
16:46:18 <dmwit> Frederick: correct
16:46:23 <roconnor> My SVG files is 10x bigger than my png file
16:46:23 <Itkovian> right
16:46:24 <EvilTerran> Itkovian, yeah, dmwit noticed i got the type wrong
16:46:31 <Itkovian> Sorry bout that
16:46:33 <Frederick> dmwit: dang, how could I achieve the same behavior in plain haskell?
16:46:51 <Toxaris> map (* 2) . map head . filter (even . length . takeWhile odd . tail) . filter (even . head) . tail . tail . reverse . tails . reverse . (0 :) $ [1,2,2,3,4,4,5]
16:46:54 <Toxaris> > map (* 2) . map head . filter (even . length . takeWhile odd . tail) . filter (even . head) . tail . tail . reverse . tails . reverse . (0 :) $ [1,2,2,3,4,4,5]
16:46:55 <dmwit> Frederick: There are many possibilities.  There's forkIO, MVars, Channels, ...
16:46:55 <noBotE>  [4,8]
16:47:02 <Toxaris> > map (* 2) . map head . filter (even . length . takeWhile odd . tail) . filter (even . head) . tail . tail . reverse . tails . reverse . (0 :) $ [1,1,2]
16:47:03 <noBotE>  [4]
16:47:06 <yitz> roconnor: png is gzipped. gzip the svg and then compare
16:47:08 <Toxaris> dmwit: :)
16:47:10 <Itkovian> Does give an exception in ghci
16:47:13 <Itkovian> but thx.
16:47:19 <Frederick> dmwit: could you show me the basic call for the simplest of all?
16:47:45 <Frederick> dmwit: a simple sample notging bigger thana hello world
16:48:00 <dmwit> forkIO (print (2^1000)) >> print "hey"
16:48:19 <dmwit> ?index forkIO
16:48:19 <noBotE> Control.Concurrent
16:48:21 <Frederick> dmwit: but with that structure
16:48:38 <dmwit> But you probably don't want forkIO.
16:48:39 <MyCatVerbs> roconnor: just scale then to 1600x1200, then the SVG file will be smaller.
16:48:47 <MyCatVerbs> roconnor: or gzip the SVG file, that works too.
16:48:48 <Frederick> could I run siman anderc in paralel with some simple syntax?
16:49:27 <dmwit> Frederick: What was complicated about the syntax I gave?
16:50:02 <dmwit> But like I said, you probably want something else in most use cases.
16:50:13 <Frederick> dmwit: like what?
16:50:50 <dmwit> MVars/Channels for communication, TVars for STM, par for pure code, ...
16:52:06 <dmwit> It depends a lot on what you want to do. =)
16:52:06 <roconnor> gziped SVG file is a bit larger than the PNG file.
16:52:39 <roconnor> I wonder if I can get appache to serve up my gzipped file as if it was unzipped (and serve it compressed if the client allows it)
16:53:31 <roconnor> rsvg-view is happy reading a gzipped file
16:54:05 <Frederick> dmwit: thanksa lot I will work on it.
16:54:08 <roconnor> mozilla initally seems less happy
16:54:12 <dmwit> Frederick: Out of curiosity, what are you doing?
16:54:26 <dmwit> (It's really hard to give good, detailed advice with so little information.)
16:55:37 <Frederick> dmwit: seems I wrote some stupid thing in a school assignement im trying tofix
16:55:50 <Frederick> I can send you the text if you want to look.
16:56:04 <Frederick> and the professor sort of complained abut what ive said about haskell
16:56:09 <Frederick> but he does not know jackabout it
16:56:17 <Frederick> so I will pretend that imright
16:56:32 <dmwit> If he hasn't taught you about concurrency commands, I would suggest that maybe you don't need them.
16:56:56 <Frederick> dmwit: may I mail you what ive written so you can understand better?
16:57:00 <dmwit> ?hpaste
16:57:01 <noBotE> Haskell pastebin: http://hpaste.org/new
16:57:55 <Frederick> dmwit: I have a pdf written in latex I hope thepastebin dont mess up with all
16:58:18 <mauke> hpaste will
16:58:27 <dmwit> If it's larger than 5K, put it up on the web somewhere.
16:58:40 <dmwit> But yeah, you should probably put it on the web somewhere even if it's smaller than 5K.
16:59:01 <dmwit> (And I'm not sure how willing I am to look at something larger than 5K, anyway. =)
16:59:24 <Frederick> dmwit: 6 sentences
16:59:38 <dmwit> That should be fine.
17:00:47 <jinok> you've taken more than 6 sentences asking if dmwit would be willing to read 6 sentences... :)
17:01:15 <noecksit> @instances Functor
17:01:15 <noBotE> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:02:11 <Frederick> dmwit: section 4
17:02:44 <dmwit> of what?
17:04:11 <Frederick> http://inf.ufrgs.br/~vfbsilva/129420.pdf
17:06:22 <dmwit> That doesn't look like an assignment to me.
17:09:03 <dolio> Wow, big linker errors on ghc 6.9 today.
17:09:30 <Frederick> dmwit: the assigment was to write the paper :p
17:10:36 <dmwit> So why is it important that they be in parallel?
17:10:55 <dmwit> Your point about composing actions is a nice one, whether or not the actions run in parallel.
17:14:48 <Toxaris> Frederick: I dont understand your mapping from software components terms to category theory terms in section 3. I think you should make clear what the morphisms are.
17:15:27 <Zao> There's also a "dancess" typo.
17:15:49 <Toxaris> Frederick: "the composition is the functional composition" is imho misleading. composition is an operation on morphisms, not on objects, but functional composition is about software components, not about whatever your morphisms are, or?
17:16:59 <noecksit> > map (\a -> a + 5) (map (\a -> a * 2) [1,2,3])
17:17:00 <noBotE>  [7,9,11]
17:17:16 <noecksit> is this possible to do using mapM?
17:17:38 <dmwit> As long as we're commenting on the paper: I don't think it's generally considered kosher to copy text literally from another paper without making it perfectly clear that you are doing so.
17:17:38 <Frederick> Toxaris: thanks forjoining me thisisa review ive already recieved and changed but I made it into a portuguese version
17:17:55 <noecksit> > mapM (\a -> print a >> return a) [1,2,3]
17:17:56 <noBotE>  <IO [Integer]>
17:18:13 <dmwit> noecksit: mapM is unnecessary.
17:18:21 <dmwit> > map ((+5) . (*2)) [1,2,3]
17:18:22 <noBotE>  [7,9,11]
17:18:38 <Frederick> dmwit: Ive added thelatex citations in theportugueselanguage first time ive wrote it I was not fully familiar with latex
17:18:40 <noecksit> > mapM (\a -> print a >> return a) (mapM (\a -> print a >> return a) [1,2,3])
17:18:41 <noBotE>  Couldn't match expected type `[a]' against inferred type `IO ()'
17:19:20 <Toxaris> noecksit: if you want mapM, you have to use >>= instead of a chain of function applications
17:19:21 <mauke> :t mapM_ (join (liftM2 (>>)) print)
17:19:22 <noBotE> forall a. (Show a) => [a] -> IO () Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
17:19:41 <noecksit> i would need to get out of IO in order to use the list underneath
17:20:05 <dmwit> noecksit: ...or just use the list in both places.
17:20:31 <Frederick> Toxaris: are you familair with category theory?
17:20:37 <Toxaris> noecksit: you cannot. bring your whole "use the list" operation into IO (using e.g. liftM), or avoid the print at this place
17:21:27 <noecksit> Toxaris : what do u mean "use >>= instead of chain of function application"?
17:21:29 <Toxaris> Frederick: a little bit. not as much as others around here. I like to use CT concepts I don't understand to draw funny pictures on blackboards.
17:22:41 <Toxaris> > return [1,2 3] >>= mapM (\a -> print a >> return (2 * a)) >>= mapM (\a -> print a >> return (5 + a)) -- noecksit
17:22:42 <noBotE>   add an instance declaration for (Num (t -> t1))
17:22:48 <Toxaris> > return [1,2,3] >>= mapM (\a -> print a >> return (2 * a)) >>= mapM (\a -> print a >> return (5 + a)) -- noecksit
17:22:49 <noBotE>  <IO [Integer]>
17:24:39 <Toxaris> Frederick: But I know that the first question, if someone draws such pictures to proof something, is: "what category are you exactly in here?" unfortunately, I can almost never answer this one myself :(
17:24:52 <noecksit> what i would like to do is run a monad for lets say [1..18], but then i want to represent that computation as one row, and then run another row, and so on
17:24:56 <noecksit> if that makes sense
17:25:30 <noecksit> kind of like how you would update a two-dimensional list
17:26:38 <dmwit> :t mapM . mapM
17:26:38 <noBotE> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [[a]] -> m [[b]]
17:26:40 <Toxaris> > mapM (mapM (\a -> print a >> return (2 * a))) [[1, 2], [3, 4]]
17:26:41 <noBotE>  <IO [[Integer]]>
17:27:36 <Toxaris> noecksit: If I get confused with mapM and friends, I tend to use ordinary maps, building lists of lists of IO actions or whatever, and then use sequence to combine them into a single big action
17:28:08 <Toxaris> noecksit: that's exactly what mapM would do, but sometimes it's easier to design as a two-step process
17:29:02 <Toxaris> > map (map (\x -> print x >> return x)) [[1, 2], [3, 4]]
17:29:03 <noBotE>  [[<IO Integer>,<IO Integer>],[<IO Integer>,<IO Integer>]]
17:29:15 <Toxaris> > map sequence $ map (map (\x -> print x >> return x)) [[1, 2], [3, 4]]
17:29:16 <noBotE>  [<IO [Integer]>,<IO [Integer]>]
17:29:21 <Toxaris> > sequence $ map sequence $ map (map (\x -> print x >> return x)) [[1, 2], [3, 4]]
17:29:22 <noBotE>  <IO [[Integer]]>
17:29:54 <MyCatVerbs> Cale: just in case you're not aware, lambdabot's inoperandi.
17:30:50 <noecksit> > replicate 18 [1..18]
17:30:51 <noBotE>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18],[1,2,3,4,5,6,7,8,9,10,11,12,...
17:31:26 <noecksit> > mapM (mapM (\a-> print a >> return (2 * a))) replicate 18 [1..18]
17:31:27 <noBotE>  Couldn't match expected type `t -> b'
17:31:37 <noecksit> > mapM (mapM (\a-> print a >> return (2 * a))) (replicate 18 [1..18])
17:31:38 <noBotE>  <IO [[Integer]]>
17:31:59 <mmorrow> > fmap (join replicate) [0..]
17:32:00 <noBotE>  [[],[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8...
17:32:18 <mmorrow> > fmap (\n->replicate n n) [0..]
17:32:19 <noBotE>  [[],[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8...
17:33:07 <roconnor> does every browser support Content-Encoding: gzip?  will apache decompress it before sending if the client doesn't support it?
17:33:19 <joey__> @hoogle on
17:33:19 <noBotE> A Hoogle error occured.
17:33:22 <joey__> @index on
17:33:22 <noBotE> bzzt
17:33:22 <roconnor> ... not entirely sure why I'm asking this in #haskell
17:33:44 <joey__> Hmm. Where's "on" in the libs, if at all?
17:33:49 <dmwit> Data.Function
17:33:51 <Cale> MyCatVerbs: I'm aware of that. I've been trying to fix it actually. RunPlugs is giving me link errors.
17:33:52 <Toxaris> Data.Function
17:33:59 <joey__> Thanks dmwit, Toxaris
17:34:27 <dmwit> Cale: add --make ;-)
17:34:37 <MyCatVerbs> Cale: cool. I'd suspected you probably would, but there've been times before when you've come back a few hours later and been irritated because no one thought to tell you. :)
17:35:18 <Cale> dmwit: That seems to make unsafeEval_ emit a message about compiling instead of the result of evaluation.
17:35:24 <mmorrow> roconnor: you'll have to link me to a sample image of what you're working on when you get a chance, i'm very interested :)
17:35:28 <Cale> MyCatVerbs: Yeah, thanks :)
17:35:51 <Cale> dmwit: I'm sure that it *would* fix it though, if only it actually worked at all.
17:36:03 <dmwit> Cale: Oh, the *plugin* is giving link errors?
17:36:05 <Cale> dmwit: Adding -package flags doesn't seem to help.
17:36:20 <Cale> dmwit: hs-plugins is, when evaluating things
17:36:26 <dmwit> got it
17:36:39 <Cale> dmwit: It doesn't seem to be finding the packages that I have installed as user.
17:37:11 <Cale> dmwit: I suppose I could just reinstall them all globally...
17:37:28 <Cale> I was hoping to find a better solution than that. Having to do that is stupid.
17:37:52 <dmwit> Is \bot running as you?
17:38:04 <dmwit> (i.e. maybe you just have to install them as \bot's user?)
17:38:38 <Cale> Yes. In fact, I've compiled my entire Haskell environment as user -- I don't have root privileges or any other accounts on this machine.
17:39:11 <dmwit> huh
17:40:54 <Cale> I'll try adding my user package.conf explicitly to the list of commandline options.
17:41:14 <Cale> That's again an annoying solution because it doesn't work for the main lambdabot repo.
17:41:35 <Cale> hmm, doesn't seem to have helped
17:44:08 <MyCatVerbs> Is there a fixpoint operator for types, by the way? Heck, is it possible to define one in Haskell, or anything resembling it?
17:44:25 <dmwit> mu
17:44:36 <Cale> newtype Mu f = In { out :: f (Mu f) }
17:44:48 <MyCatVerbs> Ah, cool.
17:45:09 <dmwit> It's how you get around the occurs check. =)
17:45:12 <MyCatVerbs> I wasn't sure whether it was possible to define it, I thought types were always fully evaluated (so it'd blow up with an infinite data structure).
17:45:37 <dolio> There's also nu.
17:45:38 <MyCatVerbs> I think my model of how Haskell's type checker works is probably disturbingly far off the mark. Ah, well.
17:45:45 <Cale> They are always fully evaluated :)
17:45:46 <dolio> newtype Nu f = In { out :: f (Nu f) }
17:45:47 <dolio> :)
17:46:02 <dmwit> dolio: Looks suspiciously similar... =)
17:46:13 <dolio> Yeah, well, in haskell they're the same.
17:46:25 <MyCatVerbs> dolio: data Metal m = Horns m m m | Bird m, type CrapMusic = Nu Metal
17:46:26 <Cale> Yeah, it really probably should be called Nu, since it is the greatest and not the least fixed point.
17:47:08 <dolio> But in some other environment, you might have 'data Mu f = In (f (Mu f))' and 'codata Nu f = In (f (Nu f))'.
17:47:10 <ddarius> Cale: As dolio said, they're the same.  There is just -the- fixed point.  So, I prefer Fix.
17:47:32 <dolio> If you didn't worry about strict positivity.
17:49:15 <Cale> hmm, actually, perhaps newtype Mu f = In { out :: !f (Mu f) } ?
17:49:53 <ddarius> Cale: That doesn't make any difference.
17:50:02 <Cale> hmm
17:50:08 <ddarius> I'm not even sure that is syntactically legal (even with the parens)
17:50:16 <dolio> Strictness annotations on newtypes don't mean anything.
17:50:22 <Cale> oh, right
17:50:32 <dolio> In fact, they're disallowed in 6.9.
17:50:47 <Cale> Forgot that it was a newtype :)
17:52:42 <petekaz> Can anyone else install the 'gd' package from hackage?
17:53:03 <petekaz> It won't build for me.
17:53:16 <Cale> Doesn't build for me.
17:53:31 <hpaste>  petekaz pasted "gd build output" at http://hpaste.org/8630
17:53:44 <Cale> same here
17:53:48 <petekaz> Cale: thanks, same error?
17:54:12 <Cale> yeah
17:54:20 <petekaz> I've been dying to play with dons sparklines post
17:54:59 <petekaz> I'll post something to cafe, thanks for the confirm.
17:56:12 <slava> :t join
17:56:13 <noBotE> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:56:13 <dolio> You can do 'data Nu f = forall s. Unfold s (s -> f s)' and 'data Mu f = Mu (forall b. (f b -> b) -> b)', I suppose.
17:56:33 <slava> @src join
17:56:34 <noBotE> join x =  x >>= id
18:00:54 <|Steve|> No lambdabot?
18:01:11 <dmwit> There's noBotE filling in, for now.
18:01:59 <|Steve|> Great, thanks.
18:02:14 <Cale> ...
18:02:19 <Cale> heh
18:04:15 <mmorrow> petekaz: gd builds fine for me. maybe you don't have a new enough libgd ??
18:04:22 <Frederick> hi Cale
18:04:43 <Cale> Can anyone remind me what the .cabal/config option was to set the default --prefix?
18:04:46 <petekaz> mmorrow: is that specified somewhere in hackage?
18:04:49 <mmorrow> petekaz: my gd /usr/lib/libgd.so.2.0.0
18:04:53 <Cale> Or did that not exist?
18:04:59 <mmorrow> petekaz: are you on windows or linux?
18:05:02 <petekaz> mmorrow: let me check mine (I'm on a debian etch system)
18:05:04 <Cale> Frederick: hi
18:05:36 <mmorrow> petekaz: if all else fails, get the newest tarball from gd.org (or whatever) and build/install that
18:05:52 <petekaz> mmorrow: I have two versios ...1.8.4 and 2.0.33
18:06:12 <mmorrow> petekaz: possibly it's using the 1.8.4 ??
18:06:33 <petekaz> mmorrow: perhaps ... let me figure out how to point it elsewhere.
18:06:34 <mmorrow> petekaz: what does the link /usr/lib/libgd.so point to?
18:07:02 <mmorrow> (well what does its target point to)
18:07:05 <petekaz> 1.8 version
18:07:10 <Cale> Is the .cabal/config file even documented anywhere?
18:07:10 <mmorrow> bingo
18:07:26 <mmorrow> petekaz: change it to point to the 2.whatever
18:07:46 <mmorrow> petekaz: (and pray other apps dont then break!)
18:08:21 <petekaz> mmorrow: I'll try using the package manager to do that ...
18:08:28 <mmorrow> hehe, good idea
18:11:27 <dmwit> Man, I pity the poor fool who has to maintain this code in the future.
18:11:52 <dmwit> liftM2 (liftM2 (++)) n1 n2 -- any takers on the behavior?
18:12:03 <mar77a> > exp 1
18:12:04 <noBotE>  2.7182818284590455
18:12:07 <mar77a> > exp 1 :: CReal
18:12:08 <noBotE>  2.7182818284590452353602874713526624977572
18:12:20 <petekaz> mmorrow: got it to work, thanks!
18:12:38 <mar77a> > exp 1 :: CDouble
18:12:39 <noBotE>   Not in scope: type constructor or class `CDouble'
18:12:41 <Cale> :t liftM2 (liftM2 (++))
18:12:42 <noBotE> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m, Monoid a1) => m1 (m a1) -> m1 (m a1) -> m1 (m a1)
18:12:42 <mar77a> > exp 1 :: Double
18:12:43 <noBotE>  2.7182818284590455
18:12:56 <Cale> looks reasonable :)
18:13:08 <dmwit> :t liftM2 (liftM2 (Prelude.++))
18:13:08 <noBotE> forall a (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 (m [a]) -> m1 (m [a]) -> m1 (m [a])
18:15:03 <dmwit> It'll certainly make 'em pause longer than (\x k -> n1 x k ++ n2 x k) would have, though. =P
18:15:16 <Cale> oh, they're both the ((->) e) monad?
18:15:24 <dmwit> yep
18:15:38 <Cale> If you generalise (++) you'll get that behaviour without explicit lifting :)
18:16:06 <Cale> (using the function monoid, twice)
18:16:32 <dmwit> > let f a b = [a, b]; g c d = [d, c] in (f ++ g) 1 2
18:16:33 <noBotE>  [1,2,2,1]
18:16:37 <dmwit> neat!
18:16:41 <Cale> > sortBy (comparing length ++ compare) (words "this is a list of words")
18:16:42 <noBotE>  ["a","is","of","list","this","words"]
18:18:11 <Saad_Ahmad> Hello people, I have a rather small question
18:18:22 <Cale> go for it :)
18:19:13 * Cale suddenly becomes incredibly annoyed with cabal for completely ignoring his config options for where to install packages.
18:20:45 <Saad_Ahmad> Excellent, my question is that is it possible to see the thunk at a given time, like in WinHugs if there is a pattern match failure it will show what it was being matched with, and since its lazy it would not have evaluated by then. So is it possible to see the evaluation this way?
18:21:30 <Cale> Saad_Ahmad: you mean inspect a value with placeholders inserted in the not-yet-evaluated parts?
18:21:51 <Saad_Ahmad> Cale: Yes
18:22:01 <Cale> Saad_Ahmad: In new versions of GHC, there's a debugger with a :print command for doing that.
18:22:18 <dmwit> My suggestion is to not write partial functions in the first place. ;-)
18:22:40 <dmwit> You can ask ghc[i] to warn you about partial functions.
18:22:56 <mmorrow> or at least in the catchall case call error "some descriptive description"
18:23:13 <Cale> Though, :print sometimes gives me strange results, and I'm not entirely sure why.
18:23:32 <Cale> It'll refuse to show parts of the value which have clearly been evaluated.
18:23:33 <Saad_Ahmad> dmwit, I want to see how those variables are being evaluated
18:23:50 <Cale> Saad_Ahmad: another option is to insert calls to Debug.Trace.trace
18:23:53 <mmorrow> petekaz: awesome!
18:24:05 <Cale> Which will print messages on stderr when the trace gets evaluated.
18:24:19 <Saad_Ahmad> Alright, then I shall look into it :)
18:24:26 <Saad_Ahmad> Thanks
18:24:56 <Cale> dcoutts_: are you around?
18:26:22 <Cale> okay, well, I can't worry about this too much longer... I'll just pass all the paths by hand and hopefully things will work.
18:27:31 <mmorrow> Saad_Ahmad: check out Debug.Trace also
18:27:35 <noecksit> @src lift
18:27:36 <noBotE> Source not found. Just what do you think you're doing Dave?
18:27:44 <mmorrow> ha, Cale beat me to it
18:27:45 <Cale> mmorrow: I suggested that :)
18:27:50 <mmorrow> heh
18:30:04 <Apocalisp> doesn't (return .) kind of cheat?
18:30:19 <dmwit> eh?
18:30:46 <mmorrow> everything is fair in love and haskell
18:31:13 <Apocalisp> (return .) f -- won't that apply f and then put the result in the monad, rather than applying f "in" the monad?
18:31:25 <Cale> Apocalisp: I don't know what you mean...
18:31:41 <Cale> Apocalisp: (return .) f  = (return . f)
18:31:42 <shapr> @yow !
18:31:42 <noBotE> Couldn't find fortune file
18:32:01 <Cale> Apocalisp: (return .) will be the first thing to be applied when that expression is evaluated.
18:32:06 <Saad_Ahmad> Debug.Trace seems to be what I want, but not exactly, the following code kind of shows what I want to see, "foobar n accum | n < 5 = foobar (n + 1) (n + accum)" produces the following error message (I purposely did the error to show what I mean) in WinHugs  "pattern match failure: foobar 5 (4 + (3 + (2 + (1 + (0 + 0)))))". I was thinking of is there a way to see the 5+4+3+2+1 part in that form?
18:32:07 <shapr> @seen lambdabot
18:32:07 <noBotE> I saw lambdabot leaving #haskell and #haskell-blah 17h 42m 22s ago, and .
18:32:27 <mmorrow> > let f = (*) in return . ($ 8) =<< (return .) f =<< return 2
18:32:27 <noBotE>   add an instance declaration for (Show (m a))
18:32:47 <mmorrow> > let f = (*) in map id . return . ($ 8) =<< (return .) f =<< return 2
18:32:48 <noBotE>   add an instance declaration for (Show (m a))
18:33:03 <mmorrow> > let f = (*) in head . return . ($ 8) =<< (return .) f =<< return 2
18:33:04 <noBotE>   add an instance declaration for (Num (m b))
18:33:07 <mmorrow> ahhhhh
18:33:22 <dmwit> Saad_Ahmad: | otherwise = error (show n ++ show accum)
18:33:39 <shapr> @pl (return .) f
18:33:39 <noBotE> return . f
18:34:14 <Apocalisp> (return . f) a, I mean
18:34:25 <mmorrow> oh yeah, i was thinking => (return .) . f
18:34:40 <dmwit> Apocalisp: Could you be a bit more specific?  What do you mean by "cheating"?
18:35:30 <Saad_Ahmad> dmwit, However that will output the evaluated arguments, I want to be able to see the expression right before it is evaluated
18:35:38 <Apocalisp> Let's say f is _really_ expensive to calculate. And that return is the unit function for a monad that runs things on a very powerful supercomputer somewhere else in the world.
18:36:25 <dmwit> There is no such monad.
18:36:26 <Cale> Apocalisp: return constructs a computation with *no* side effects which simply returns the supplied value
18:36:57 <Cale> Apocalisp: Presumably such a monad would have primitive computations for interacting with the remote computer. Plain Haskell expressions won't cut it.
18:37:04 <dmwit> right
18:37:42 <Cale> Haskell expressions will always be evaluated on the computer on which your executable is running.
18:37:59 <Cale> (at least with GHC)
18:38:17 <Saad_Ahmad> Cale, was that at me?
18:38:30 <Cale> Saad_Ahmad: is was to Apocalisp
18:38:32 <Cale> it*
18:38:41 <Cale> > 1 + 1
18:38:42 <noBotE>  2
18:38:44 <Saad_Ahmad> Alright, then I shall continue waiting
18:38:47 <mmorrow> what about ...  newtype MyIO a = MyIO (IO a) ; instance Monad MyIO where return a = MyIO (fireMissileIO a >> return a) ...
18:38:48 <lambdabot>  2
18:39:23 <dmwit> Saad_Ahmad: If the built-in debugger does not do what you want, then you have very few options.
18:39:25 <dolio> That won't satisfy the monad laws.
18:39:37 <roconnor> > 640/96*72
18:39:38 <noBotE>  480.0
18:39:44 <lambdabot>  480.0
18:39:48 <roconnor> > 480/96*72
18:39:49 <Cale> code.haskell.org is laggy :P
18:39:49 <noBotE>  360.0
18:39:54 <lambdabot>  360.0
18:39:55 <dmwit> Saad_Ahmad: There is an option for specifically numeric calculations, but that's it, basically.
18:40:11 <dmwit> Saad_Ahmad: Beyond that, you'd have to plug in to the GHC API, which is likely to be much more work than you want.
18:40:16 <Saad_Ahmad> dmwit: What would that option be? :)
18:40:41 <dmwit> > 2 + x + 1 :: Expr -- how smart is this, does it collapse the 2 and the 1?
18:40:48 <lambdabot>  2 + x + 1
18:40:53 <dmwit> > 1 + 2 :: Expr
18:41:02 <lambdabot>  1 + 2
18:41:10 <dmwit> That is your option for numeric calculations.
18:41:12 <shapr> Yay, hackage is back!
18:41:21 <Saad_Ahmad> Is that available on GHC?
18:41:30 <dmwit> ?where simplereflect
18:41:31 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
18:41:33 <Cale> Saad_Ahmad: It's in the SimpleReflect module.
18:41:42 <Saad_Ahmad> Thanks all :)
18:41:49 <Apocalisp> What I want is to construct (m b) from (a -> b), given some a. Specifically because f is very expensive and I want to carry around just the "very expensive b".
18:41:50 <Cale> I think that's on hackage now...
18:41:56 <Cale> But I'm not sure which package :P
18:42:14 <Cale> Ah, the show package.
18:42:17 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/show
18:43:18 <Apocalisp> wait... haskell is lazy. f a will create me a very expensive b.
18:43:18 <dmwit> Apocalisp: The Reader monad should be fine for that; it's extremely unlikely that many implementations will recompute (f b) repeatedly.
18:43:26 <dmwit> exactly
18:43:32 <Apocalisp> doh!
18:43:54 <dmwit> errr... though that doesn't really have much to do with laziness.
18:44:00 <Apocalisp> What if I were in.. say... Scala?
18:44:00 <dmwit> Unless I'm completely misunderstanding you.
18:44:02 * Apocalisp ducks
18:45:42 * mmorrow curses his non-heatseeking fireMissileIO implementation
18:46:32 <Apocalisp> I'm not sure laziness saves me here, you're right. What I want is to *not* run the expensive function at all, just pretend that I did and carry the result around until I say "give's it".
18:46:53 <mmorrow> isn't that lazy evaluation
18:47:09 <dolio> Sounds like it to me.
18:47:22 <shapr> Cool, haskell-xmpp works!
18:48:32 <Apocalisp> Reader monad it is.
18:49:15 <dmwit> Apocalisp: I'm worried that you're still confused.
18:49:43 <Apocalisp> Don't worry, I'm only confusing.
18:50:21 <Apocalisp> I'm trying to get laziness in a strict language.
18:50:52 <dmwit> > Right (Just 3)
18:50:53 <lambdabot>  Right (Just 3)
18:50:55 <dmwit> huh
18:51:02 <shapr> There's lots of laziness in strict languages. If statements are a good example.
18:52:03 <dmwit> ?src Show
18:52:03 <lambdabot> class  Show a  where
18:52:03 <lambdabot>     showsPrec :: Int -> a -> ShowS
18:52:03 <lambdabot>     show      :: a   -> String
18:52:03 <lambdabot>     showList  :: [a] -> ShowS
18:53:00 <dolio> I think short-circuiting boolean operators are a more convincing example.
18:53:49 <cetinsert> hi, does anyone have experience with building gtk2hs on x86_64 with ghc 6.8.3?
18:53:57 <scodil> cetinsert: yes
18:54:49 <vininim> Any specific example on how GHC extensions might break deriving Show?
18:54:56 <cetinsert> scodil: really I am constantly running into this UTFString problem...
18:55:20 <dolio> vininim: Break how?
18:55:35 <mmorrow> vininim: GADT Show deriving doesn't yet exist (if that's an example of what you mean)
18:55:49 <vininim> yes
18:55:52 <scodil> cetinsert: oh wait is this 0.9.13?
18:55:57 <vininim> what mmorrow said
18:56:08 <scodil> cetinsert: i haven't tried that yet. I can if you're going to stick around for a few min
18:56:38 <cetinsert> scodil: I tried two latest releases and also something I checked out from the darcs repository
18:56:52 <scodil> what is the error?
18:57:29 <cetinsert> scodil: I will retry it now and paste the error somewhere and maybe post a link here, would that be ok?
18:58:42 <scodil> sure. i'm dling 0.9.13 now, I'll see if i get any errors
18:58:53 <scodil> if the error is big don't post it here, tho
19:00:41 <cetinsert> ok... I will just post the link here then
19:01:30 <scodil> damn. wife rebooted the amd computer. stupid windows-only netflix
19:01:35 <scodil> I won't be able to build it
19:03:49 <cetinsert> http://sert.homelinux.org/projects/config
19:03:56 <cetinsert> http://sert.homelinux.org/projects/make
19:04:34 <cetinsert> scodil: oh I see... well here are my outputs, maybe you have encountered the same type of error already
19:06:55 <scodil> I can't figure it out
19:07:01 <scodil> ping dcoutts
19:07:53 <cetinsert> ping dcoutts?
19:07:56 <scodil> whats this "file 2 already allocated" business? Does that have to do with you making these files? 2>&1 and all that?
19:08:04 <scodil> dcoutts is one of the gtk2hs devs
19:08:12 <scodil> he's usually around, not now I guess
19:08:17 <scodil> very helpful guy
19:09:00 <cetinsert> oh I see... well even if I do not use any redirections I get this file 2 already allocated message
19:09:01 <roconnor> @quote click
19:09:01 <lambdabot> roconnor says: if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
19:11:19 <scodil> its hard to tell whats going on because the error appears to be in gcc, which was called by ghc
19:12:30 <ddarius> dmwit: I'm pretty sure SimpleReflect intentionally does no simplification.
19:13:59 <cetinsert> scodil: well, i didn't understand even that o_O myself... thank you very much. I will also ask dcoutts next time. Because if you google parts of what I get as an error from make, you get quite a few results.
19:14:09 <scodil> sorry cetinsert, I'm stumped. You should maybe post this to the mailing list. It does not look (to me) like a simple config error on your part (ie, not having the dependencies installed)
19:14:42 <cetinsert> the mailing list, you mean haskell-cafe or the mailing list from gtk2hs?
19:15:05 <scodil> gtk2hs-users@lists.sourceforge.net
19:15:19 <cetinsert> ok... I will do that right away ^_^
19:22:20 <leoncamel> > pl \x y -> x y
19:22:20 <lambdabot>  Parse error at "\x" (column 4)
19:22:33 <leoncamel> @pl \x y -> x y
19:22:33 <lambdabot> id
19:22:47 <leoncamel> @foldr f e . map g
19:22:48 <lambdabot> No match for "f".
19:22:48 <lambdabot>  
19:22:48 <lambdabot> *** "e" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:22:48 <lambdabot> E
19:22:48 <lambdabot>  
19:22:50 <lambdabot> [80 @more lines]
19:23:28 <shapr> @foldr fmap
19:23:29 <lambdabot> No match for "fmap".
19:24:41 <leoncamel> @pl foldr f e . map g
19:24:41 <lambdabot> foldr f e . map g
19:25:04 <leoncamel> @pl sum' xs = foldr (+) 0 xs
19:25:04 <lambdabot> sum' = foldr (+) 0
19:25:30 <leoncamel> @unpl id
19:25:30 <lambdabot> (\ a -> a)
19:26:45 <shapr> @seen adept
19:26:45 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
19:27:14 <leoncamel> ?
19:27:25 <shapr> ADEpt: Awake?
19:28:00 <shapr> ADEpt: Where's the code for type_ id_ etc in haskell-xmpp?
19:29:46 <shapr> @seen adept
19:29:46 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
19:29:48 <shapr> foo
19:36:02 <dmwit> preflex: seen ADEpt
19:36:02 <preflex>  ADEpt was last seen on #haskell 1 day, 15 hours, 10 minutes and 16 seconds ago, saying: Saizan_: it's a pity, though. Hope that parsec3 would not supercede 2.1.0 branch anytime soon as a "default parsec:
19:36:07 <dmwit> shapr: ^^
19:37:12 <shapr> aha
19:37:15 <shapr> dmwit: Thanks
19:39:01 <dmwit> ?where lambdabot
19:39:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:39:49 <shapr> @where dons
19:39:49 <lambdabot> http://www.cse.unsw.edu.au/~dons
19:39:53 <shapr> @where dmwit
19:39:53 <lambdabot> I know nothing about dmwit.
19:39:55 <shapr> hm
19:40:01 <shapr> @where edwardk
19:40:01 <lambdabot> http://slipwave.info/
19:40:08 <dmwit> I don't have a blog or anything.
19:40:19 <shapr> @where+ edwardk http://comonad.com/
19:40:19 <lambdabot> It is stored.
19:40:39 <ddarius> What the?
19:40:50 <cetinser2> ?where dcoutts
19:40:50 <lambdabot> I know nothing about dcoutts.
19:40:55 <shapr> @where ddarius
19:40:55 <lambdabot> I know nothing about ddarius.
19:41:00 <shapr> @where shapr
19:41:00 <lambdabot> http://www.ScannedInAvian.com/hope
19:41:03 <shapr> ugh
19:41:11 <shapr> @where+ shapr http://www.ScannedInAvian.com/
19:41:11 <lambdabot> Nice!
19:44:07 <Apocalisp> @where+ Apocalisp http://apocalisp.wordpress.com/
19:44:07 <lambdabot> It is stored.
19:44:18 <Apocalisp> that's nifty
19:45:57 <dmwit> ?. elite part #somechannelyouarenotin
19:45:58 <lambdabot> Plugin `compose' failed with: Privledged commands cannot be composed
20:08:32 <nicktestbot> ?bot
20:08:32 <lambdabot> :)
20:08:38 <nicktestbot> > "hum"
20:08:40 <lambdabot>  "hum"
20:09:01 <nicktestbot> Oh HO!
20:55:51 <roconnor> Are Cairo operations in pixels or points?
20:56:13 <mjrosenb> gah, points
20:56:27 <roconnor> mjrosenb: is that an answer?
20:56:28 * mjrosenb remebers points from using visual basic in like 6th grade
20:56:36 <mjrosenb> roconnor: no, just a complaint
20:56:44 <roconnor> mjrosenb: a point is simply 1/72nd of an inch
20:56:51 <mjrosenb> i know
20:57:03 <mjrosenb> i like doing things in pixels
20:57:23 <jinjing> is there a way to pick and evaluate a function from a list based on a command line argument?
20:57:24 <roconnor> mjrosenb: each have their uses
20:57:32 <roconnor> but it is annoying when programs confuse them
20:57:55 <mjrosenb> jinjing: most likely
20:58:08 <roconnor> and searching for DPI in http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html#v%3AsetLineWidth turns up nothing
20:58:09 <lambdabot> http://tinyurl.com/266njv
20:58:15 <roconnor> which really worries me
20:58:53 <roconnor> @seen dcoutts_
20:58:53 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
20:59:11 <roconnor> preflex: seen dcoutts_
20:59:11 <preflex>  dcoutts_ was last seen on #haskell 2 days, 9 hours, 22 minutes and 53 seconds ago, saying: using my current cabal-install dependency planner
20:59:25 <roconnor> preflex: seen dcoutts
20:59:25 <preflex>  dcoutts was last seen on #ghc 4 hours, 25 minutes and 18 seconds ago, saying: installing inplace doesn't feel like a good general solution
20:59:46 <mjrosenb> roconnor: does C cairo not havea default?
20:59:56 <mjrosenb> err, cairo's C bindings
21:00:02 <roconnor> mjrosenb: I know nothing about Cairo
21:00:53 <mjrosenb> my point is that you should try looking at the docs for C rather than the haskell bindings
21:00:55 <jinjing> mjrosenb: so how can do say: arg1 <- getArgs; _eval( head arg1);
21:01:19 <mjrosenb> jinjing: you want to parse a string as haskell source?
21:01:31 <roconnor> a frieghtening prospect
21:01:42 <jinjing> mjrosenb: i want to pick a function by name :)
21:01:45 * roconnor googles cairo dpi
21:02:00 <roconnor> hey
21:02:05 <roconnor> first hit: Graphics.UI.Gtk.Cairo
21:02:05 <mjrosenb> jinjing: oh, that's a bit more difficult
21:02:12 <mjrosenb> roconnor: lol
21:03:07 <roconnor> cairoFontMapSetResolution :: FontMap -> Double -> IO ()
21:03:17 <mjrosenb> jinjing: i think the easiest thing to do would be to make a variable that has the type [(String, IO ())]
21:03:25 <roconnor> I hate bindings to imperitive libs
21:03:40 <mjrosenb> jinjing: construct that list with all of the functions that you could want, and use lookup
21:03:42 * roconnor cries
21:04:06 <mjrosenb> roconnor: i know.  I'm trying to decode mpeg1-layer3 in haskell
21:04:37 <roconnor> sadly proper haskell bindings usually involve a complete reworking of the API
21:04:44 <mjrosenb> i'm still trying to decide if i should throw wrappers around libmad or if i should just write the whole decoder in haskell
21:04:48 <roconnor> not that this should be surprising
21:05:16 <roconnor> mjrosenb: I'm a big fan of shuning imperative code.
21:05:30 <jinjing> mjrosenb: thanks, that would do:)
21:05:37 <mjrosenb> so libmad seems easier than most, since it tracks a pointer with user data and uses callbacks
21:05:41 <roconnor> mjrosenb: ... I'm also not very good at writting efficent code
21:06:03 <roconnor> mjrosenb: I've used libmad before
21:06:22 <roconnor> mjrosenb: I added mp3 support to OS/2's multimedia manager.
21:06:34 <roconnor> mjrosenb: not quite as nice as libvorbis, but pretty good.
21:06:39 <mjrosenb> awesome;
21:06:48 <mjrosenb> i was thinking about os/2 for a while
21:07:00 <roconnor> ... or was it the other way around
21:07:05 <mjrosenb> but it just doesn't seem to offer any advantages
21:07:13 <roconnor> anyhow, they are both pretty nice
21:07:21 <mjrosenb> i'd guess that libvorbis is beautiful
21:07:28 <roconnor> mpglib sucked
21:08:14 <mjrosenb> god, the documentation for mp3 is so dense
21:08:28 <roconnor> mp3 is a hack
21:08:38 <mjrosenb> indeed
21:08:52 <roconnor> it is supposed to be the audio layer of mpeg.  But ripping it out means not TOC, etc.
21:09:08 <roconnor> mjrosenb: ... haven't we stopped using mp3 by now?
21:09:33 <mjrosenb> roconnor: well i'm trying to use only flac, and when more things support it, ogg flac
21:09:47 <mjrosenb> but for now, most of my music exists soley as .mp3 :(
21:10:17 <roconnor> http://r6.ca/MMAudioPak/ <- if you ever want to play mp3s in OS/2
21:10:18 <lambdabot> Title: MMAudio Pak 2 for OS/2
21:10:36 <roconnor> or ogg
21:10:37 <roconnor> or flac
21:10:50 <roconnor> well, ogg-vorbis
21:10:54 <mjrosenb> mpd hasn't been ported?
21:11:06 <roconnor> what is mpd?
21:11:28 <mjrosenb> http://www.musicpd.org/
21:11:29 <lambdabot> Title: MPD: Music Player Daemon
21:12:08 <roconnor> Not as of 4 years ago
21:13:11 <mxc-wrk> @hoogle split
21:13:11 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
21:13:11 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
21:13:11 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
21:13:17 <mxc-wrk> @hoogle lines
21:13:18 <lambdabot> Prelude.lines :: String -> [String]
21:13:18 <lambdabot> Data.List.lines :: String -> [String]
21:13:18 <lambdabot> Data.ByteString.Char8.lines :: ByteString -> [ByteString]
21:16:05 <roconnor> cairo really seems to use pixels
21:16:06 <slava> dons: we need some help with a type theoretical problem in #concatenative :)
21:20:40 <nornagon> Haskell seems to have grabbed a hold of my brain, and it won't let go.
21:20:50 <nornagon> Here I am, writing code in the State monad ... in MATLAB.
21:21:46 <mmorrow> may (>>=) have mercy on your soul
21:22:31 <nornagon> well, it's more like a pathetic imitation of the state monad, but still... the spirit is there
21:22:49 <mmorrow> use octave!
21:24:37 <vininim> sage!
21:25:00 <telexicon> i got this error at runtime, im not sure what it means: (10,0)-(13,33): Non-exhaustive patterns in function next_int
21:25:12 <nornagon> mmorrow: not my choice to make; i'm doing RA work for psychologists :)
21:25:52 <mmorrow> nornagon: aww, so it is. :)
21:26:50 <mmorrow> wait, so then you're saying the *phychologists* program matlab so you do too?
21:27:20 <mmorrow> i didn't know psychologists program
21:27:25 <nornagon> well
21:27:35 <nornagon> these people are closer to physiologists
21:27:42 <nornagon> i'm writing experiments in stereo vision
21:27:54 <nornagon> i think the term is 'psychophysics'
21:27:58 <mmorrow> ahh, interesting
21:28:19 <nornagon> would love to use haskell but there's a bunch of proprietary stuff i have to interface with that only works in matlab :)
21:28:33 <mmorrow> oh noes psycho physicists !!@
21:28:35 <nornagon> plus this code has to be maintainable by other people who likely don't know anything but matlab
21:29:29 <mmorrow> nornagon: i hear you, octave can't help with all that interfacing stuff
21:30:02 <mmorrow> nor would it be friendly to someone that knows only matlab
21:31:05 <mmorrow> i just like to shamelessy promote octave whenever anyone mentions matlab :)
21:31:09 <nornagon> heh :)
21:31:23 <mmorrow> ;)
21:32:06 * mjrosenb doesn't enjoy matlab
21:32:14 <mmorrow> use octave!
21:32:30 <mjrosenb> mmorrow: i avoid it at all costs
21:32:36 <mmorrow> use haskell!
21:32:52 <mjrosenb> also, since i'm no longer an electrical engineer, i don't have to touch it ever again
21:33:04 <nornagon> matlab is hoooorrible
21:33:15 <nornagon> it's like python with retarded syntax
21:33:27 <nornagon> and when i say retarded, by Jove do I mean it.
21:33:47 <mjrosenb> nornagon: indeed
21:33:49 <mmorrow> yeah, it wouldn't ruin my day if i never had to touch matlab/octave again
21:35:45 <telexicon> can anyone help me to understand why im getting "(11,0)-(14,33): Non-exhaustive patterns in function next_int" in http://slexy.org/view/s21kkMwqfF
21:35:46 <lambdabot> Title: Slexy 2.0
21:36:33 <mjrosenb> telexicon: you don't handle the empty list case in 2 of your functions
21:36:33 <mmorrow> next_int []
21:36:42 <mmorrow> pattern match error
21:36:52 <telexicon> oh
21:37:07 <telexicon> i guess that would happen this time now.. thats why it didnt do it before
21:37:08 <telexicon> ok thanks
21:37:34 <telexicon> wait, it wont ever get passed the empty list
21:37:40 <mmorrow> noprob. i think i see what you're trying to do. you could make it better with guards
21:37:57 <telexicon> oh yeah it will on xs.. ok
21:38:15 <mmorrow> :)
21:39:36 <telexicon> it just builds this: ["22","+","3"]
21:39:56 <telexicon> well it works now, thanks mmorrow
21:41:54 <mmorrow> :) http://slexy.org/view/s2Ofn1Al75
21:41:54 <lambdabot> Title: Slexy 2.0
21:42:52 <mmorrow> oh oops, that should be (String -> String -> (String,String))
21:43:03 <telexicon> heh, yeah was wondering about that
21:43:12 <mmorrow> hehe
21:43:51 <telexicon> what does a@ mean?
21:44:16 <mmorrow> it binds a to the whole pattern
21:44:27 <telexicon> ohh.. thats handy
21:45:06 <mmorrow> > let f [] = [] ; f xs@(x:_) = x:xs in f "asdf"
21:45:10 <lambdabot>  "aasdf"
21:45:28 <mmorrow> handy indeed
21:45:45 <mjrosenb> does the thing to the left of @ need to be an identifier?
21:45:57 <mmorrow> hmm, i dunno
21:46:06 <newsham> > let f a@(b,c) = (a,b,c) in f (5,'a')
21:46:08 <lambdabot>  ((5,'a'),5,'a')
21:46:31 <mmorrow> > let f (*)@_ a b = a*b in f (+) 1 1
21:46:33 <lambdabot>  2
21:46:46 <mmorrow> never thought to try that
21:47:21 <mmorrow> mjrosenb: sweet!
21:47:26 <ddarius> Those are both identifiers.
21:47:32 <mjrosenb> yeah
21:47:40 <mmorrow> oh, what did you mean then?
21:47:43 * mjrosenb was thinking of putting a pattern there
21:47:54 <mmorrow> oh, i don't believe so
21:48:13 <telexicon> whats the function to test for membership? like 'a' in ('a', 'b', 'c')
21:48:25 <mjrosenb> `elem`
21:48:28 <mmorrow> > a `elem` "adsf"
21:48:29 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
21:48:36 <mmorrow> > 'a' `elem` "adsf"
21:48:37 <lambdabot>  True
21:48:38 <mjrosenb> or elem if you don't want infix
21:48:46 <telexicon> thanks
21:49:04 <mmorrow> i like the infix a lot since it mirrors the math notation nicely
21:49:18 * mjrosenb thinks allowing patters to be placed there is a good step towards having full disjunctive patterns
21:50:51 <mmorrow> mjrosenb: if you can figure out how to translate such patterns into a legal haskell pattern, a source preproc could be written in 30 lines that would parse the haskell src (w/ a minor change to the parser), apply your transform, spit out valid haskell.
21:51:24 <mmorrow> the haskell-src-exts parser supports most all haskell syntax
21:51:29 <mmorrow> including extensions
21:52:03 <mjrosenb> mmorrow: disjunctive patterns would be damn sexy
21:52:34 <telexicon> how long does it take to start understanding this stuff?
21:52:35 <slava> what are disjunctive patterns?
21:53:06 <mjrosenb> slava: they're also called or patterns
21:53:16 <mmorrow> mjrosenb: that would be awesome! i've been working with haskell-src-exts a bunch lately, so could whip up a short skeleton easily. you'd just have to figure the translation out
21:53:19 <mjrosenb> but that's not as cool
21:53:43 <mjrosenb> it's when you can have multiple different matches in one case
21:54:07 <mmorrow> ahhh, i see where you're going with this
21:54:13 <mmorrow> hmm
21:54:18 <mjrosenb> so if you have a type synonym, type foo = Either (a,b) (b,a)
21:54:27 <mjrosenb> you can say
21:54:41 <ddarius> I'm pretty sure such situations were intentionally omitted by the designers.
21:55:04 <mmorrow> ddarius: even better! :)
21:55:05 <mjrosenb> apply f (Left (x,y)) || apply f (Right (y,x)) = f x y
21:55:25 <mjrosenb> http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps
21:55:44 <mmorrow> oh that'd be easy to translate
21:55:53 <mjrosenb> that gives an implementation of red-black trees in like 15 lines using disjunctive patterns
21:56:11 <newsham> ?djinn (a,b) -> Either (a,b) (b,a)
21:56:12 <lambdabot> f (a, b) = Left (a, b)
21:56:18 <newsham> ?djinn (a,b) -> (b,a)
21:56:19 <lambdabot> f (a, b) = (b, a)
21:56:31 <newsham> ?djinn a -> b -> ((a,b), (b,a))
21:56:31 <lambdabot> f a b = ((a, b), (b, a))
21:56:43 <mjrosenb> sml/nj has a sample implementation
21:57:03 <telexicon> so are accumulators an idiom in haskell like they are in erlang?
21:57:15 <mjrosenb> oh yeah, that should be type foo a b = ...
21:57:29 <newsham> there is a class of monoids.  is that what you mean?
21:57:35 <newsham> what are accumulators in erlang like?
21:58:13 <ddarius> telexicon: They are an idiom in all functional languages and then some.
21:58:58 <telexicon> you use a function parameter as a list to store up the result as you process something
21:59:24 <hpaste>  morrow pasted "disjunctive pattern translation" at http://hpaste.org/8631
21:59:40 <mmorrow> mjrosenb: would that translation in the paste be correct?
21:59:41 <newsham> you mean like:   sums (x:xs) accum = sum xs (accum+x) ?
21:59:49 <telexicon> newsham, yes
22:00:04 <newsham> you'd normally use a higher order function to avoid that kind of recursion in haskell
22:00:17 <telexicon> oh?
22:00:27 <newsham> ?src sum
22:00:27 <lambdabot> sum = foldl (+) 0
22:00:33 <newsham> > sum [1,2,3,4,5]
22:00:35 <lambdabot>  15
22:00:43 <ddarius> newsham: You'd normally use higher order functions to avoid recursion in general.
22:00:52 <newsham> ddarius: yah thats what i intended to say
22:01:27 <newsham> tele: here foldl abstracts out the concept of recursion that reduces a list of elements to a result
22:01:46 <newsham> > foldl (*) 1 [1..5]
22:01:47 <lambdabot>  120
22:02:10 <ddarius> It's stronger than that. foldl captures the concept of iterating over a list while accumulating a value.
22:03:11 <mmorrow> mjrosenb: and if so, is '||' the only "operator" or whatever that's used? if so, that'd be easy peasy!
22:03:17 <mjrosenb> mmorrow: looks good
22:03:55 <mjrosenb> mmorrow: that's just what's used in the paper.. in sml/nj they use '|' for everything
22:04:14 <mmorrow> mjrosenb: ah, either way diff name for the same thing
22:04:14 <mjrosenb> it fits in better with sml syntak
22:04:20 <mjrosenb> syntax
22:04:25 <telexicon> newsham, so what would you do with the next_int function in this: http://slexy.org/view/s2Q5kVlyNk
22:04:25 <lambdabot> Title: Slexy 2.0
22:04:33 <mjrosenb> but | isn't as prevalent in haskell
22:05:13 <mmorrow> mjrosenb: since (i don't think) you can ever use '|' (or '||') in a pattern match, that would be ok. ?
22:05:33 <mjrosenb> also, i've never seen the syntax that you translate to, but it's pretty obvious what it does
22:05:45 <mmorrow> mjrosenb: yeah, it's fairly new
22:05:45 <mjrosenb> mmorrow: it looks fine.
22:06:08 <ddarius> mmorrow: It's actually rather old.
22:06:27 <mmorrow> ddarius: what? the idea or its implem in haskell?
22:06:38 <ddarius> The paper suggesting it was in 2000.
22:07:02 <mmorrow> ddarius: ah, i haven't looked at the paper yet. it's suggests its implem in haskell then?
22:07:05 <ddarius> mmorrow: The implementation preceded the paper.
22:07:06 * mmorrow open the paper
22:07:13 <mmorrow> ddarius: ah
22:08:12 <kevinEllis> Hello, I am having a strange typing error ("rigid types", ???). I'm using GHC and tried posting my problem to hpaste. While the response somewhat explained what rigid types are, it didn't indicate how I should solve the problem. Would someone mind looking at my hpaste @ http://hpaste.org/8581 and seeing if they can make anything of it? I would appreciate it, thanks.
22:09:20 <mmorrow> ddarius: wait, now i'm confused. i just looked at the paper, in which it appears that that's his made up syntax so he can write the matches compactly, but i didn't see any mention of an implementation in haskell.
22:09:57 <roconnor> anyone here have Firefox 3 installed?
22:09:58 <mjrosenb> mmorrow: the paper i posted is from 1993
22:10:12 * mmorrow looked at the wrong paper
22:10:31 <ddarius> mmorrow: Read the conclusion.
22:10:58 <mmorrow> all i can seem to find scrolling back is  http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps
22:11:03 <mmorrow> could you repost the link?
22:11:33 <ddarius> I'm talking about pattern guards.
22:11:54 <mmorrow> heh, silly me.
22:12:16 <obk> Is there a way to get a pretty-printed output using the default show?
22:12:28 <mmorrow> *but*, the '|' syntax would eliminate a bunch of duplicate rhs's
22:12:40 <obk> Doing a show of a complex value gives one huge line which is hard to read
22:13:05 <mmorrow> (but could not handle *different* rhs's => pattern guards are more general)
22:13:06 <obk> This is for debugging so I don;t want to go into the whole define-your-own show if I don't have to, anything "reasonable" will do
22:13:13 <ddarius> The Show class isn't for pretty printing.  You could try to post-process the result, but otherwise no.
22:13:52 <obk> ddarius: Thanks :-( Maybe a small Perl script... hmmm...
22:14:01 <ddarius> obk: There's probably a generic pretty printer somewhere in the libraries.
22:14:10 <ddarius> "generic" as in Scrap Your Boilerplate
22:14:20 <obk> There's Text.PrettyPrint but it seems to be unrelated
22:14:34 <jre2> does anyone here use darc's test hook?
22:14:35 <obk> Well, a bit related, it can be used to roll your own show
22:14:46 <mmorrow> this "many-duplicate-rhss" elimination justifies the effort to translate the '|' syntax to pattern guards in my mind
22:15:31 <ddarius> Derive probably also has something to derive pretty printers
22:15:51 <mmorrow> i don't think it does, been messing with that a lot recently also
22:16:30 <obk> ddarius: I wouldn't start using template Haskell just for debug prints...
22:17:27 <ddarius> obk: I didn't say anything about TH.
22:17:37 <obk> Doesn't Derive require it?
22:17:42 <ddarius> No.
22:17:52 * obk ws looking at the wrong place then
22:18:38 <obk> Ah, found the right one.
22:18:58 <mmorrow> were you looking at th-lift?
22:19:17 <mmorrow> great package
22:20:11 <carl> is there a way to use event based sockets in haskell?
22:20:28 <obk> ddarius: Seems like it does what I want, if I can get it to work... thanks!
22:20:47 <jim__> sockets are always event based arent tehy?
22:21:03 <jim__> you mean you don't want to program with lazy lists?
22:21:17 <jim__> i dont understand your question carl
22:21:21 <newsham> telex: takeWhile/dropWhile?
22:22:04 <newsham> > let splitWhile p xs = (takeWhile p xs, dropWhile p xs) in splitWhile isDigit "123 abc"
22:22:06 <lambdabot>  ("123"," abc")
22:22:07 <carl> well theres not much on networking on the net but from what most ppl seem to do they fork and then read from the socket using something like <- hGetContents
22:22:24 <cjs> I'm thinking that carl wants select()-type stuff, right?
22:22:25 <telexicon> newsham, oh.. i suppose that would work
22:22:31 <ddarius> obk: Here's the source for the generic show function in Data.Generics. http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Generics-Text.html#gshow  By replacing the string manipulation with the pretty printing combinators from Text.PrettyPrint you could probably make a (pretty ugly) pretty printer in about 10 lines of code.
22:22:32 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5olhfa
22:22:46 <carl> yes lol c is much more familiar to me
22:22:50 <jim__> well you can get select by declaring it as a foriegn import
22:22:53 <newsham> telexicon; btw, there are parsing libraries and parser generators
22:22:55 <obk> ddarius: Sounds good, I'll look into it
22:23:09 <telexicon> newsham, yeah, i just wanted to know how parsers work
22:23:11 <cjs> There are nonblocking reads, but ghc's threading supports tens of thousands of threads with no problem, apparently, so most people go with that instead.
22:23:22 <telexicon> newsham, thanks
22:23:34 <newsham> telexicon: http://www.thenewsh.com/%7Enewsham/formal/parse/parser.lhs
22:23:36 <cjs> Which gets you multiprocessing as well. And then use STM for inter-thread communication.
22:23:44 <solrize_> @where hair shirt
22:23:45 <lambdabot> I know nothing about hair.
22:23:50 <solrize_> @where hairshirt
22:23:50 <lambdabot> I know nothing about hairshirt.
22:24:05 <telexicon> newsham, ! wow, thanks
22:24:14 <Adamant> Haskell: We Know Nothing About Hairshirts
22:24:16 <carl> ill probably go with whats easiest then im still rather new to this
22:24:27 <solrize_> @go hairshirt
22:24:28 <lambdabot> http://en.wikipedia.org/wiki/Cilice
22:24:45 <mmorrow> ddarius: that's a good idea (wrt gshow and String -> Doc)
22:25:22 <solrize_> @quote hairshirt
22:25:22 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
22:25:29 <cjs> carl: I'd go with the threads, then, yes. I can imagine that there might me times when event-driven IO is easier, but that's probably not true in most simple situations.
22:25:32 <solrize_> @where+ hairshirt http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
22:25:32 <lambdabot> I will remember.
22:25:44 <solrize_> @where hairshirt
22:25:45 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
22:26:29 <scodil> lambdabot wheres the hairshit
22:26:40 <solrize_> if the hair shirts, wear it
22:26:48 <geezusfreeek> @where hairshit
22:26:49 <lambdabot> I know nothing about hairshit.
22:26:52 <geezusfreeek> lol
22:27:21 <leoncamel> ..lol..
22:39:13 <roconnor> > 64/48 == 48/36
22:39:14 <lambdabot>  True
22:39:45 <jinjing> how does lambdabot evaluate haskell expression on the fly :?
22:39:50 <roconnor> > 64/48 == 96/72
22:39:51 <lambdabot>  True
22:40:10 <jinjing> > 1 == 2
22:40:11 <lambdabot>  False
22:41:01 <sbahra> > 0+0 == 0-0
22:41:07 <lambdabot>  True
22:41:31 <sbahra> > -0 == 0
22:41:32 <lambdabot>  True
22:41:56 <sbahra> > -1 % -2
22:41:57 <dons> jinjing: it uses runtime evaluation via the hs-plugins library
22:42:00 <lambdabot>      precedence parsing error
22:42:00 <lambdabot>         cannot mix `(%)' [infixl 7] and prefix ...
22:42:06 <sbahra> isk
22:43:02 <jinjing> dons: cool, so haskell can be embeded anywhere :)
22:43:09 <achilles14> hi all, what {} symbol means?
22:43:26 <ddarius> Nothing.  They are just grouping symbols as in most languages.
22:43:28 <achilles14> or where can I find document for {}
22:43:41 <ski> &sb end
22:43:41 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
22:43:49 <achilles14> ddarius: oh
22:43:49 <ski> er
22:51:48 <achilles14> ddarius: is {} reqired for data structure constructor?
22:57:07 <Korollary> @where erport
22:57:07 <lambdabot> I know nothing about erport.
22:57:10 <Korollary> @where report
22:57:11 <lambdabot> http://www.haskell.org/onlinereport/
22:57:27 <mjrosenb> sweet
22:57:29 <Korollary> achilles14: See the report. Data declarations (section 4 iirc)
22:57:36 * mjrosenb has a crc'er
22:57:40 <sbahra> Anyone here know a nice logic for formally verifying concurrent systems?
22:57:44 <sbahra> Other than TLA
22:58:04 <achilles14> Korollary: thanks
22:58:55 <ak47> hi all, i'm trying to learn haskell, and am currently struggling with io. i can do io using the do ... notation, but that effectively forces me to declare my whole program as sequential (if the function returns IO a, the only way i know how to use this value is inside another do block).  I've tried several howtos and tutorials and haven't found answer to this. As my function processes whole file in 1 go, there shouldn't be a
22:59:30 <Cale> ak47: Your message was cut off at "there shouldn't be"
22:59:37 <mjrosenb> ak47: irc limits you to 512 characters per message
22:59:54 <Cale> ak47: But the important thing to note is that within a do-block, you can use pure functions to do work on values.
22:59:54 <ak47> any ordering related issues, can anybody kick me in the right direction ?
22:59:57 <ak47> thx ;-)
23:00:14 <Cale> ak47: So the stuff which is in IO should *really* be IO, for the most part.
23:00:24 <Cale> What does your program do?
23:00:38 <mjrosenb> ak47: do notation is used for more than just IO.
23:01:24 <mjrosenb> ak47: as a general paradigm, i have 99% of my program declared without considering IO, then write a small wrapper on top of that that uses some form of IO
23:01:31 <Cale> If you're familiar with object oriented programming, and specifically with model-view-controller, your 'model' will be in pure code generally, whereas parts of the 'view' and 'controller' will be in IO.
23:02:01 <Cale> (where by 'pure' here, I simply mean non-IO)
23:02:14 <Cale> Does that help?
23:02:19 <roconnor> generally a haskell program looks like do { x<-readFile; let y= myPureFunciton x; print x }
23:02:24 <roconnor> er
23:02:26 <roconnor> print y
23:02:45 <mjrosenb> roconnor: it's alot easier to optimize the first :-p
23:02:55 <roconnor> :)
23:03:31 <ak47> well, i want to read a file containing bunch of lines (usernames), count them and depending on the count say which users are probably using this machine on a daily basis
23:04:27 <Cale> ak47: so you'll write a function which will take a list of usernames and produce another list of usernames, which is a pure function
23:04:44 <Cale> ak47: and your program will look a lot like roconnor's example.
23:05:39 <Cale> (that is, your main will consist of reading in that file, applying the pure function, and then printing the results
23:05:40 <Cale> )
23:05:40 <roconnor> mapM_ print y -- This is so common I was tempted to use it in my example
23:06:09 <ak47> so i shouldn't concern myself with the fact that io 'taints' the code into serial code, cause all pure functions will enjoy the benefits of 'pure' code ?
23:06:13 <mjrosenb> roconnor: i pray that y happens to *not* be a String
23:06:28 <roconnor> mjrosenb: often y is a list
23:06:52 <roconnor> a list of things that are not characters :)
23:06:53 <mjrosenb> roconnor: a string is a list ofChars
23:07:00 <mjrosenb> roconnor: i see
23:07:01 <mjrosenb> also
23:07:21 <mjrosenb> did Chars show up with a background color for anyone else?
23:07:39 <Cale> ak47: Well, it's not going to taint the majority of your program, which is all the logic going into counting the users
23:07:43 <roconnor> no, but there was no space between of and Chars
23:07:50 <Cale> ak47: So no, I wouldn't worry about it :)
23:09:16 <jbapple> I just installed GHC 6.8.3 from http://www.haskell.org/ghc/dist/6.8.3/ghc-6.8.3-i386-unknown-linux.tar.bz2 . http://www.haskell.org/ghc/download_ghc_683.html claims it includes profiling libraries, but I'm still getting linker errors:
23:09:16 <lambdabot> http://tinyurl.com/668geq
23:09:31 <jbapple> STCM.o: In function `s71R_info':
23:09:31 <jbapple> ghc13084_0.hc:(.text+0x26c0c): undefined reference to `containerszm0zi1zi0zi2_DataziMap_fromList_closure'
23:09:38 <jbapple> Any ideas?
23:10:02 <roconnor> I hate errors like that
23:10:05 <mjrosenb> jbapple: did you get all of your libraries updated?
23:10:15 * mjrosenb does as well
23:10:21 <jbapple> The file claims to include profiling libraries
23:10:28 <mjrosenb> gentoo has been pretty good about not breaking everything
23:10:50 <jbapple> This particular library is Data.Map, which I expect to Just Work
23:11:26 <jbapple> roconnor: Yeah, these error are not so helpful
23:12:16 <jbapple> My compiler (yes, I know this is a linker error) error horror story is: Intel's C++ compiler once gave me an 8mb error message.
23:12:22 <ak47> ok, thanks. until i discover another way to do it (if there is such), do ... will suffice ;-)
23:13:28 <roconnor> @hoogle withFile
23:13:28 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
23:13:29 <mjrosenb> jbapple: didn't happen to be using C++ for that?
23:14:52 <jbapple> mjrosenb: I have no idea what the semantics of that question are.
23:15:12 <jbapple> mjrosenb: Are you asking if I tried to compile a non-C++ file with a C++ compiler?
23:15:16 <jbapple> mjrosenb: no
23:15:49 <mjrosenb> jbapple: i mean was the error generated while attempting to compile a C++ file
23:16:11 <jbapple> mjrosenb: yes
23:16:51 <ak47> thanks again, im of to finish it (and make it about 1/10 length of the "old" lisp code ) ;-)
23:18:00 <mjrosenb> and probably 1/100th the parens
23:20:38 <jberryman> how would one convert an Int to a list of its digits?
23:21:23 <quicksilver> map read . show is the cute/ugly hack
23:21:30 <mjrosenb> jberryman: how do you want it's digits stored?
23:21:48 <mjrosenb> quicksilver: don't think that typechecs
23:22:40 <jberryman> just a list is fine; I want to play with some integer sequences: squaring the digits, then adding them. that kind of thing
23:22:50 <mjrosenb>  map (\x -> read [x]) . show
23:22:55 <jbapple> My linker problem was a module name problem
23:22:57 <mjrosenb> jberryman: a list of *what*
23:23:22 <jbapple> I had a module with a non-"Main" name
23:23:56 <roconnor> @hoogle readDigit
23:23:57 <lambdabot> No matches found
23:24:02 <roconnor> @hoogle digit
23:24:03 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
23:24:03 <lambdabot> Data.Char.digitToInt :: Char -> Int
23:24:03 <lambdabot> Data.Char.isDigit :: Char -> Bool
23:24:17 <roconnor> > map digitToInt (show 15)
23:24:19 <lambdabot>  [1,5]
23:24:47 <roconnor> > digitToInt 'a'
23:24:48 <lambdabot>  10
23:24:52 <roconnor> > digitToInt 'f'
23:24:54 <lambdabot>  15
23:24:58 <roconnor> > digitToInt 'g'
23:24:59 <lambdabot>  Exception: Char.digitToInt: not a digit 'g'
23:26:53 <jberryman> mjrosenb: sorry, a list of Ints. I didn't think to do [x] so that I could use read. thanks, both of you
23:30:57 <roconnor> @src Integer read
23:30:57 <lambdabot> Source not found. My brain just exploded
23:31:03 <roconnor> @src read Integer
23:31:03 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:51:53 <carl> im trying to compile a simple server app and im getting all sorts of undefined references like server.o: In function `s14v_info':
23:51:56 <carl> (.text+0x138): undefined reference to `networkzm2zi1zi0zi0_NetworkziSocket_listen_closure'
23:51:59 <carl> any ideas ?
23:56:30 <Korollary> are you using the --make flag for ghc?
23:56:40 <Eldanen> Holy Haskell!
23:56:46 <Korollary> holy Eldanen
23:57:00 <carl> ghc
