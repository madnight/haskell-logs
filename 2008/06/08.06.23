00:00:14 <hansfbaier> @djinn f ? a -> a
00:00:14 <lambdabot> Cannot parse command
00:00:33 <rwbarton> It looks like this has been fixed in 6.8.3... http://hackage.haskell.org/trac/ghc/ticket/998
00:00:35 <lambdabot> Title: #998 (Tab-completion of filenames does not work in GHCi 6.6) - GHC - Trac
00:00:48 <hansfbaier> ﻿@djinn help
00:00:54 <hansfbaier> @help djinn
00:00:54 <lambdabot> djinn <type>.
00:00:54 <lambdabot> Generates Haskell code from a type.
00:00:54 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
00:01:07 <hansfbaier> djinn a->a
00:01:14 <hansfbaier> @djinn a->a
00:01:14 <lambdabot> f a = a
00:02:07 <hansfbaier> @djinn a->a->(a->a)
00:02:07 <lambdabot> f _ _ a = a
00:02:43 <mmorrow> @djinn ((a -> b) -> a) -> a
00:02:43 <lambdabot> -- f cannot be realized.
00:02:49 <mmorrow> @djinn ((a -> m b) -> m a) -> m a
00:02:49 <lambdabot> -- f cannot be realized.
00:03:38 <rwbarton> @djinn (forall a b. a -> b) -> c
00:03:38 <lambdabot> -- f cannot be realized.
00:04:05 <rwbarton> @djinn (forall a. a) -> c
00:04:05 <lambdabot> -- f cannot be realized.
00:04:40 <hansfbaier> @djinn (a->a)->a
00:04:40 <lambdabot> -- f cannot be realized.
00:05:14 <hansfbaier> @djinn rwbarton->mmorrow
00:05:14 <lambdabot> -- f cannot be realized.
00:05:22 <hansfbaier> :)
00:06:03 <cjs> Is haskell.org still unhappy?
00:08:25 <mmorrow> @djinn aardvark -> aardvark
00:08:25 <lambdabot> f a = a
00:09:24 <mjrosenb> is there a way to strip the basis out of djinn?
00:09:44 <mmorrow> what is the "basis"?
00:10:15 <mmorrow> do you mean like for it to return expressions instead of decls?
00:10:16 <mjrosenb> @djinn :environment
00:10:16 <lambdabot> Invalid command
00:10:19 <mjrosenb> err
00:10:47 <mjrosenb> just run that in a new djinn session
00:11:32 <mmorrow> i'm not understanding
00:12:38 <mjrosenb> i want to run a djinn session without those types being defined
00:13:27 <mmorrow> i think it derives an expressions given a type with type vars, so there aren't actually *any* types defined (i may be completely wrong)
00:14:08 <mmorrow> (well, other than type vars and functions)
00:14:20 <mjrosenb> datatype
00:14:22 <mjrosenb> s
00:14:31 <mmorrow> oh, i dunno if it can handle that
00:14:47 <mmorrow> i think the code for djinn is on hackage
00:15:23 <mmorrow> even better, here's the darcs repo: http://www.augustsson.net/Darcs/Djinn/
00:15:24 <lambdabot> Title: Index of /Darcs/Djinn
00:17:36 <mjrosenb> perhaps djinn just doesn't like to deal with continuations
00:18:20 <mmorrow> that should be "fix"ed
00:19:12 <rwbarton> @djinn ((a->a)->a)->a
00:19:12 <lambdabot> f a = a (\ b -> b)
00:20:03 <mmorrow> oh, things are not as they seem
00:20:22 <mmorrow> (or maybe, i'm now confused as to what djinn can and cannot do)
00:21:49 <rwbarton> @djinn ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
00:21:49 <lambdabot> f a b = a (\ c _ -> b c) b
00:22:16 <mmorrow> ohhh. i see my oversight.
00:22:28 <mmorrow> forgot to expand the newtype
00:23:02 <rwbarton> Is '((a => b) => a) => a' true in classical logic?
00:24:27 <rwbarton> (yes, it is)
00:25:14 <mmorrow> what if b is "not a"?
00:25:48 <rwbarton> Well, if a is true, then the whole thing is ... => true, which is true
00:26:33 <rwbarton> If a is false, then a => b is true, so (a => b) => a is false, and ((a => b) => a) => a is true
00:27:06 <mmorrow> oh, i was interpreting the => in an incorrect way
00:27:10 <mjrosenb> right...
00:28:14 <rwbarton> @djinn (((a->r)->r)->r) -> (a->r)
00:28:14 <lambdabot> f a b = a (\ c -> c b)
00:28:48 <jsnx> rwbarton: thanks
00:29:04 <jsnx> looks like i'm going to turn into one of these bleeding edge early adopters
00:37:13 <dolio> Man, I am getting some weird code here.
00:38:40 <adu> dolio: weird code? what do you mean?
00:39:00 <dolio> dons: You ever seen core like: "$s$wa_r1ZK :: forall s_aDp. (Data.Array.Vector.Prim.BUArr.MBUArr s_aDp Int ~ Data.Array.Vector.Strict.UArr.MUArr Int s_aDp) => ..."
00:40:15 <mmorrow> dolio: what ghc are you using
00:40:18 <mmorrow> ?
00:40:27 <dolio> 6.8.3, but 6.9 does it, too.
00:40:30 <dolio> Er, 6.8.2
00:43:25 <mmorrow> hmm. i know that there are explicit type coercions in core as a result of using system Fc, but i'm not sure what exactly i'm looking at in you snippet or how to interpret it
00:44:10 <mmorrow> and when i say "are explicit type coercions in core as a result of using system Fc", this is me regurgitating my vague recollection of something i read
00:44:19 <dolio> My concern is that that type equality doesn't seem to be figured out at compile time.
00:44:36 <dolio> Or something of the sort.
00:46:07 <mmorrow> hmm. what if you put that equality constraint in your src, does it go away in the core? (or would it?)
00:47:03 <dolio> I'm not sure why there would be an equality constraint at all. All my types are as monomorphic as possible.
00:47:24 <mmorrow> hmm, i've no idea
00:48:45 <dolio> Data.Array.Vector.Strict.UArr.MUArr is weird, too. There is no D.A.V.S.U module...
00:49:37 <mmorrow> hah. i thought that was some module you wrote...weird
00:50:00 <dolio> Although my copy of 6.8.2 says there is. Maybe my uvector there is old.
00:50:45 <mmorrow> you might also want to pinch youself to rule out that this is all a dream
00:51:09 <dolio> Yeah, 6.9 gets the module name right.
00:51:19 <dolio> Still has the equality constraint, though.
00:51:43 <mmorrow> "i'm sure there's a rational explanation for this"
00:52:10 <mauke> explanation :: Rational
00:52:26 <mauke> cause :: Complex Double
00:52:49 <dolio> Anyhow, that doesn't look good for performance to me. :)
00:53:22 <mmorrow> a complex double cause!!! how is that rational!!!?
01:20:16 <masak> -quit
01:21:07 <BeelsebobWork> @pl (\f x y z -> f y z x)
01:21:07 <lambdabot> flip . (flip .)
01:24:37 <wagle> @pl \x y -> flop y
01:24:37 <lambdabot> const flop
01:24:57 <wagle> @pl \x y -> flop y
01:24:57 <lambdabot> const flop
01:25:06 <mjrosenb> :t flop
01:25:07 <wagle> @pl \x y -> flop y x
01:25:08 <lambdabot> flip flop
01:25:10 <lambdabot> Not in scope: `flop'
01:25:22 <mjrosenb> oic
01:25:30 <wagle> missed part of it..  sigh
01:45:35 <Dae> Hey
01:46:19 <Dae> Anyone know if any of the distributed/parallel haskell thingies are still alive? GPH seems to be stone dead
01:47:40 <Dae> Noone?
01:47:51 <dons> parallel haskell was merged into ghc
01:48:06 <dons> distributed haskell had a release a couple of years ago, but you'd have to contact the authors to find out more
01:49:14 <Dae> Parallel haskell is in ghc? So... I could distribute a haskell program via ghc and PVM? Or was it only the multithread part that got into ghc?
01:50:12 <dons> the shared memory parallelism abstractions are in ghc
01:50:25 <dons> so parallel strategies running on the smp runtime, on a shared memory machine
01:52:22 <Dae> Ok, so no easy ways to distribute haskell kept hacking ghc or doing all work thorugh the foreing interface. Pity
01:53:01 <dons> yeah, using hmpi or network
01:55:14 <Dae> yeah, which is quite a bit of work compared to just having it threaded
01:58:05 <dolio> dons: Any thoughts on that equality constraint in the core? Does that cause dictionary passing or something of that sort?
02:00:40 <hpaste>  dolio pasted "core problem?" at http://hpaste.org/8482
02:10:52 <hackage> New package: cabal2arch 0.3.6
02:10:52 <hackage> New package: vty 3.0.2
02:11:37 <vixey> thank you hackage
02:17:13 <vixey> what is the Uniqueness of Types property? does haskell have it?
02:18:35 <quicksilver> I imagine that refers to the idea that a term has at most one type.
02:18:40 <luqui> I am not familiar with that particular term, sounds to me like it means that every term has a single unique type
02:18:54 <quicksilver> depending how strictly you interpret that, haskell satisfies it.
02:18:55 <luqui> haskell does not have this property, but it has a related one "most general type"
02:19:05 <quicksilver> In fact, a term can have many valid types but there is almost one "most general"
02:19:08 <quicksilver> for haskell98
02:19:16 <luqui> ECHO Echo echo echo ko ko
02:19:17 <quicksilver> you lose it with RankNTypes and impredicative polymorphism.
02:19:28 <vixey> I think that every PTS has this proptery
02:19:35 <vixey> whatever the proprety is.. I don't know
02:19:36 <johnnowak> vixey: PTS?
02:19:40 <dolio> I thought H98 didn't actually have principal types or something.
02:19:45 <dolio> Technically.
02:19:51 <vixey> Pure Type System
02:19:54 <johnnowak> ah.
02:20:29 <johnnowak> dolio: do you have an example?
02:20:31 <dolio> Although I can't recall why exactly.
02:20:37 <vixey> oh wait a sec, I think Journal of Functional Programming is available online
02:21:22 <quicksilver> dolio: I think haskell 1.4 didn't have principal types
02:21:27 <quicksilver> but they fixed it in time for haskell98
02:21:31 <dolio> That could be it.
02:21:33 <vixey> oh turns out it's not, I have to buy it..
02:22:04 <dolio> johnnowak: At a guess, I'd say it has to do with type classes.
02:22:25 <quicksilver> Haskell 1.4 didn't permit constraints of the type (Eq [a]) =>
02:22:26 <dolio> I seem to recall a Wadler paper mentioning it. Let me browse them.
02:22:38 <quicksilver> therefore \x y -> [x] == [y] didn't have a principle type
02:22:41 <quicksilver> something along those lines
02:22:44 <johnnowak> ahh
02:22:45 <quicksilver> I'm not sure of the details.
02:23:02 <johnnowak> dolio: it's appreciated, but not necessary. i'll give it a look myself.
02:23:22 <dolio> Well, I'm kind of curious myself now.
02:25:42 <dolio> http://homepages.inf.ed.ac.uk/wadler/papers/overload2/overload2.ps
02:25:44 <lambdabot> http://tinyurl.com/6may4y
02:28:46 <dolio> I guess it's not that there aren't principal types. It has to do with ambiguity in inferring types in the absense of annoations.
02:29:29 <quicksilver> the read . show problem?
02:29:42 <dolio> Yeah.
02:29:56 <dolio> Well, show . read
02:30:05 <quicksilver> Yes. Some terms have types which involve variables which aren't present in the type.
02:30:11 <quicksilver> This is odd.
02:30:18 <quicksilver> Did you see that pathlogical array example someone pasted a few weeks ago?
02:30:30 <quicksilver> that contained loads of variables in teh constraint which weren't in the type.
02:30:31 <dolio> Not that I recall.
02:30:35 <quicksilver> impossible to make sense of it.
02:31:46 <quicksilver> can't find it :(
02:32:54 <chr1s> uniqueness typing is an alternative to monadic code.
02:33:06 <chr1s> but I guess that's not what you mean
02:33:32 <chr1s> it's in Clean (a language similar to Haskell)
02:35:02 <chr1s> and then principal types are the most general types, i.e. the type of (f x = x) is forall a . a -> a
02:35:31 <chr1s> you could type f x = x in a lot of ways, its type can also be Int -> Int, but it is not the most general type.
02:36:48 <dolio> Uniqueness typing isn't really an alternative to monadic code. It's an alternative to (/aid in implementing) certain monads.
02:37:03 <chr1s> dolio: you're completely right
02:37:37 <chr1s> and then there's type inference, which tries to reconstruct the principal type for an untyped expression
02:38:36 <chr1s> but in the case of Haskell, that's not always possible, because some extensions make it undecidable
02:39:03 <dolio> Well, you don't need extensions to make it ambiguous, that's what Wadler's talking about.
02:39:07 <dolio> show . read will do it.
02:40:05 <dolio> Type classes are enough.
02:40:17 <chr1s> yes, so I think type classes are an extension (qualified types)
02:40:33 <johnnowak> chr1s: an extension of what?
02:40:43 <dolio> An extension of Hindley-Milner, you mean?
02:41:02 <chr1s> of F-omega?
02:41:23 <chr1s> let me check that Wadler paper, one sec
02:42:48 <dolio> There are impredicative/higher rank type systems that have principal types (I think), but they're a bit more complex than the types you see in Haskell.
02:43:27 <johnnowak> is there any "real-world" programming language with principal typings?
02:43:30 <Saizan_> and impredicative F-omega lacks them
02:43:51 <dolio> ML?
02:44:01 <Botje> "copolyvariadic dependently-monomorphed hyperfluxads"
02:44:03 <johnnowak> dolio: ML just has principal types i believe
02:44:05 <Botje> i like that
02:44:08 <Botje> time to invent something!
02:44:15 <mmorrow> for those interested, i just put cabaled darcs repo of an implementation of catenable sequences with O(1) append at http://code.haskell.org/~morrow/code/haskell/catseq/
02:44:15 <lambdabot> Title: Index of /~morrow/code/haskell/catseq
02:44:28 <mmorrow> i'm gonna upload it to hackage eventually, but until i do
02:44:47 <dolio> johnnowak: It's not a real-world language? :)
02:44:53 <chr1s> dolio: I would guess that even with rank-n polymorphism you'd still have principal types
02:44:57 <johnnowak> dolio: it doesn't having principal typings
02:45:05 <johnnowak> dolio: it just has principal types
02:45:06 <chr1s> dolio: it's just the type inferencing that's problematic
02:45:33 <chr1s> but I'm not an expert, so I might be wrong ;)
02:45:50 <dolio> chr1s: It depends on the type system. GHC's higher-rank polymorphism doesn't have principal types.
02:46:35 <opqdonut> mmorrow: oh, that's just the old composition instead of concatenation trick
02:46:45 <mmorrow> :)
02:46:57 <opqdonut> mmorrow: i profiled the standard quicksort example using both normal concatenation and composition
02:47:05 <mmorrow> do tell
02:47:12 <opqdonut> time usage identical but composition used 30% mem
02:47:18 <mmorrow> aww
02:47:22 <opqdonut> 30% of the other solution, that is
02:47:30 <mmorrow> haha
02:47:32 <mmorrow> nice
02:47:38 <opqdonut> yeah
02:47:38 <johnnowak> HMF has higher rank types and principal types
02:47:41 <opqdonut> and surprising
02:47:44 <dolio> @hackage dlist
02:47:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
02:47:51 <opqdonut> since it keeps "less evaluated" thinks around
02:47:56 <opqdonut> guess there's less copying then
02:48:17 <opqdonut> hey, I should probably write a blog post about this
02:48:25 <mmorrow> but (.) gives you the chance to fire rules and other compiler simplifications/optimizations
02:48:25 <opqdonut> i'll throw you a link when I get around to it
02:48:30 <opqdonut> yeah
02:48:33 <mmorrow> do please
02:49:07 <chr1s> dolio: I think Pierce said something like that if there's some way to instantiate a term with type variables, then there's a general way of doing it
02:49:49 <dolio> @go first-class polymorphism with existential types
02:49:50 <lambdabot> http://citeseer.ist.psu.edu/451312.html
02:50:34 <dolio> chr1s: The problem is what type you assign to something like [id]
02:51:00 <dolio> With GHC, you have to choose between 'forall a. [a -> a]' and '[forall a. a -> a]'.
02:51:01 <opqdonut> no it's not?
02:51:05 <opqdonut> ah
02:51:06 <dolio> Neither subsumes the other.
02:51:14 <opqdonut> forgot higher rank
02:51:57 <dolio> But apparently MLF, for example, gives it a principal type of 'forall (a >= forall b. b -> b). [a]'
02:52:30 <jbapple> mmorrow: Did dlist not meet your needs?
02:52:44 <dolio> Which can be instantiated to both the types I gave above for options in GHC.
02:52:51 <chr1s> dolio: hmm, interesting
02:52:59 <quicksilver> Cute. the HMF paper crashes Preview.app
02:53:26 <dolio> That paper on existential types explains what that type means (I don't remember the details), but apparently citeseer is down at the moment.
02:53:43 <johnnowak> quicksilver: "works here" in preview.app
02:54:35 <johnnowak> HML is a simpler version of MLF with flexible types that has similar benefits
02:54:36 <dolio> johnnowak: Incidentally, what do you mean by "principal typings"? I don't know what that means.
02:55:15 <jbapple> ﻿@google principal typings
02:55:46 <jbapple> IIRC, only type systems with intersections have them
02:56:26 <dolio> Ah.
02:56:37 <quicksilver> johnnowak: looking only at the abstract it looked to me like HMF didn't claim principal types
02:56:40 <mmorrow> jbapple: i've never used dlist. why? is it similar/same?
02:56:41 <jbapple> I think they mean something like "has a most general type in all contexts", whereas principal types mean "has a most general type in any context"
02:56:43 <chr1s> interesting stuff =)
02:56:48 <jbapple> mmorrow: I think so
02:56:51 <chr1s> but I should get back to work.
02:57:04 <quicksilver> johnnowak: and Flexible types has principal types but requires annotations on polymorphic parameters
02:57:08 <johnnowak> dolio: my rough understanding is that, with principal typings, you don't need global inference for complete accuracy
02:57:21 <quicksilver> which is not really very different from ghc -XRankNTypes
02:57:23 <johnnowak> quicksilver: aye
02:57:23 <mmorrow> jbapple: ah cool. i just came across this in another module, thought it was cute, and rewrote my own version.
02:57:37 <jbapple> http://hackage.haskell.org/packages/archive/dlist/0.4.1/doc/html/Data-DList.html
02:57:38 <lambdabot> http://tinyurl.com/6ezgd9
02:58:18 <mmorrow> jbapple: haha. maybe i wont put it on hackage then...
02:58:42 <johnnowak> dolio: for example, you could infer the types of functions parameterized by some functor without the need to give a signature annotation
02:59:11 <johnnowak> if my ML terminology is correct
02:59:30 <dolio> I've not done much ML, so I wouldn't know. :)
03:00:09 <dolio> I think I get the idea, though. The first google hit was "The Essence of Principal Typings", so that should be good. :)
03:00:27 <jbapple> mmorrow: If you're interested in a challenge, Okasaki's constant-time catenable deques aren't on hackage yet
03:01:25 <mmorrow> jbapple: nice, i'll give it a shot
03:01:32 <jbapple> mmorrow: See also Martin Holters' masters thesis "Efficient Data Structures in a Lazy Functional Language"
03:01:43 <jbapple> mmorrow: (It includes some Haskell code)
03:01:52 <mmorrow> in case anyone darcs got that repo, i just exposed the implem of Seq in the export list, so reget
03:02:32 <mmorrow> ah! citeseer is down
03:02:52 <smtms> there were mirrors last time I checked
03:03:28 <mmorrow> heh, just in large font on the error page :)
03:03:56 <cjs> Hm. Does Haddock 2.0.0.0 compile under ghci-6.8.3?
03:04:20 <dolio> I'd recommend reading that paper on existential types for anyone who hasn't. It'll make you want first-class existentials (but we won't be getting them).
03:04:42 <mmorrow> smtms: mirrors are having problems too :(
03:05:45 <smtms> does the new CiteSeerX work?
03:06:18 <hpaste>  cjs pasted "haddock-2.0.0.0 under ghc-6.8.3" at http://hpaste.org/8483
03:06:24 <cjs> That's the error.
03:06:51 <mmorrow> smtms: trying my luck now
03:07:21 <jbapple> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.6348
03:07:21 <lambdabot> Title: E#cient Data Structures in a Lazy Functional Language - CiteSeerX
03:07:23 <dolio> Apparently Daan Leijen's page at MS Research doesn't have that paper...
03:07:35 * Botje boggles
03:07:41 <mmorrow> smtms: it's working!
03:07:47 <Botje> haven't citeseer still managed to un-do the ligature transformation?
03:08:03 <Botje> or any other pdf renderer?
03:08:54 <quicksilver> certain pdfs include the full text in machine readable form as well as pretty form.
03:09:02 <quicksilver> but that's up to the pdf generator you use.
03:09:14 <Botje> ah, that's cool
03:09:21 <Botje> i'm guessing latex doesn't do that, then? :)
03:09:21 <jbapple> This one has the full text
03:09:33 <jbapple> and pdfLaTeX does so by default
03:10:13 <earthy> Botje: depends on the path to the PDF. pdftex does, latex + dvipdf and latex + dvips + ps2pdf do not
03:10:17 <mmorrow> jbapple: whoa, send that again. i just spent the last 5 minutes trying to figure out how i had managed to dl it from citeseer in by browser and then abort it
03:10:40 <mmorrow> jbapple: i literally was hitting enter on a search for the same...
03:10:56 <jbapple> wget http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1.6348&rep=rep1&type=pdf
03:10:56 <lambdabot> http://tinyurl.com/6og5wp
03:11:06 <mmorrow> thanks
03:12:31 <mmorrow> got it, but by your first link http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.6348 (second didnt work)
03:12:31 <lambdabot> Title: E#cient Data Structures in a Lazy Functional Language - CiteSeerX
03:12:40 * Botje goes to read some more of the PDF standard
03:47:56 <Yoric[DT]> hi
03:48:44 <osfameron> could you implement a destructuring bind with monads?
03:48:55 <vixey> destructuring bind is ..?
03:49:16 <vixey> pattern matching already exists, it's much different to say lisp though
03:49:18 <osfameron> like (a:b:abs) = [1,2,3]
03:49:29 <osfameron> yeah, I'm thinking of languages that don't have pattern matching built in
03:49:36 <vixey> > do (a:b:abs) <- return [1,2,3] ; return (a,b,abs)
03:49:36 <lambdabot>        add an instance declaration for (Show (t (t1, t1, [t1])))
03:49:47 <osfameron> I was wondering if a monadic parser would work.  But I think the lexical scopes of the variables bound might be wrong
03:50:02 <vixey> you need lisp macros to write binding constructs
03:50:21 <vixey> > (do (a:b:abs) <- return [1,2,3] ; return (a,b,abs)) ::[(Integer,Integer,Integer)]
03:50:22 <lambdabot>  Couldn't match expected type `Integer'
03:50:29 <osfameron> well, monads *do* bind, hence the pronunciation of ">>" as "bind" :-)
03:50:29 <vixey> > (do (a:b:abs) <- return [1,2,3] ; return (a,b,abs)) ::[(Integer,Integer,[Integer])]
03:50:30 <lambdabot>  [(1,2,[3])]
03:50:36 <vixey> >>= is called bind
03:50:51 <osfameron> er, yeah, >>= even
03:50:56 <vixey> binding constructs, like lambda, let, etc are a quite different notion
03:52:22 <osfameron> yeah... though monads seem to have no trouble implementing a number of qiute different notions already :-)
03:52:47 <vixey> I'm not being clear
03:53:02 <osfameron> no no, I think it's more likely that I'm being dumb
03:53:23 <vixey> There's no way you can add a binding construct to lisp or <anything> without using a syntactic transform into lambda, let, or some other existing binding construct
03:53:45 <luqui> it's a syntactic transform anyway, monad is an algebraic thing
03:54:03 <luqui> I don't really see how one translates to the other
03:54:10 <luqui> unless you have some clever idea in mind
03:54:12 <osfameron> ok, then I have misunderstood the very brief overview I looked at on parsec
03:54:37 <osfameron> I had an idea that:  var <- parser_bit    as well as progressing the parse as a whole also bound "var" with whatever that bit was.
03:54:48 <vixey> you can parse and pattern match on text with parsec, but in most languages code and text are different things
03:55:00 <osfameron> so that at the end of the parse, you would have a lexical scope that contained vars bound to bits of an "input"
03:55:17 <luqui> osfameron, oh... hm, we may be talking past each other.
03:55:20 <osfameron> and if that input was a list... then that would be some sort of pattern matching
03:55:44 <osfameron> possibly.  I'll try and implement later, which will probably make it obvious why I'm talking nonsense :-)
03:55:56 <vixey> you're not talking nonsense
03:57:04 <vixey> it's just that if you implement pattern matching, you must have used a macro and it's not likely that writing it as a monad will help
03:57:50 <vixey> using it within a monad (like haskell) is very useful of course
03:59:31 <Saizan_> osfameron: in var <- parser_bit, var is bound to the result of parser_bit, not to the input consumed
04:00:20 <osfameron> Saizan_: ok -- could the parser bit return the input consumed as its result?
04:00:38 <Saizan_> sure
04:10:15 <_dolio> nickserv is gone?
04:10:31 <vixey> I think nickserv is still here
04:10:39 <_dolio> Hmm...
04:10:42 --- mode: irc.freenode.net set +o ChanServ
04:10:58 <opqdonut> i'm comparing two sort functions
04:10:59 <opqdonut> is "print $ sort1 xs == sort2 xs" a suitable way to force results
04:10:59 <hackage> New package: ghc-paths 0.1
04:10:59 <opqdonut> gah
04:11:00 <opqdonut> lost in a split
04:11:53 <Botje> opqdonut: sure
04:11:59 <vixey> I don't think does anything useful
04:12:01 <Botje> opqdonut: you might want to use quickcehck instead, though
04:12:09 <vixey> oh
04:12:15 <vixey> comparing, not timing
04:12:18 <vixey> nevermind me
04:14:44 <opqdonut> also, the list is generated with randomIO, will the work for this show in the right place?
04:15:01 <opqdonut> or should i somehow force the list first
04:15:16 <Botje> uh, i'd think the sorting already forces it
04:15:34 <Botje> but if you're just comparing results == will force nicely
04:15:55 <Botje> but really, i'd just use quickcheck :)
04:16:10 <Botje> that takes care of the burden of generating random lists
04:17:42 <opqdonut> yeah of course the sorting forces the random list, but will the computation load for this show up in the sort functions or main
04:17:45 <opqdonut> ?
04:19:10 <Botje> when you evaluate the list, of course
04:19:13 <Botje> so that'd be in ==
04:19:35 <Botje> which is only called in the print, which is (i assume) only called in main
04:19:50 <Botje> you could use seq, i guess
04:20:05 <Botje> but i'm not sure why you're asking this :p
04:20:09 <vixey> how about return (x == y) ; return ()
04:20:19 <vixey> would that evaluate x == y ?
04:20:54 <vixey> seems not to..
04:21:15 <quicksilver> vixey: no. return doesn't do anything special.
04:21:25 <vixey> do return ((last [1..])`seq`())
04:21:25 <opqdonut> Botje: well it could skew the profiling results...
04:21:31 <vixey> return immediatle
04:21:34 <quicksilver> right.
04:21:35 <vixey> but not ((last [1..])`seq`())
04:21:56 <quicksilver> because you didn't bind the result of the return.
04:22:04 <quicksilver> if you tried to inspect the result then of course it would run for ever.
04:26:12 <MacM3dik> http://Handy-Gratis-Aufladen.info/?id=577af8db
04:28:34 <opqdonut> mmorrow: here http://pseudo.fixme.fi/~opqdonut/blog/Fast_concatenation.html
04:28:35 <lambdabot> Title: (&#x03BB;blog. blog blog) (&#x03BB;blog. blog blog): Fast concatenation
04:28:51 <opqdonut> (that's what i was benchmarking, comments welcome)
04:29:01 <vixey> hehe "diverging since 2008"
04:29:24 <opqdonut> vixey: yeah isn't the name great :P
04:29:31 <mmorrow> opqdonut: thanks
04:29:34 <vixey> I like it
04:29:59 <vixey> btw qsort (x:xs) = qsort [a | a<-xs, a<x] . (x:) . qsort [a | a<-xs, a>=x] is Prolog code
04:30:25 <opqdonut> you mean prolog-style?
04:30:42 <opqdonut> or do you mean the list comprehensions?
04:30:57 <vixey> other than syntax, that's exactly what you'd write
04:31:06 <opqdonut> yeah, it is
04:31:26 <opqdonut> that's probably where this came from, when I first tested this I was playing around with prolog too
04:31:32 <opqdonut> now i just dug up that old code
04:32:35 <opqdonut> btw, do you think the stack size increase is justified? I got an overflow with the default but wanted a large enough test case
04:33:01 <opqdonut> I should probably follow that up with a comparison with functional mergesort
04:33:34 <mmorrow> opqdonut: qsort's an awesome choice for this benchmark
04:33:44 <opqdonut> yeah it is
04:34:02 <opqdonut> because of the normally large amount of copying that happens ;)
04:34:02 <Saizan_> apart the fact that it's not really quicksort
04:34:06 <opqdonut> with a list qsort
04:34:09 <opqdonut> Saizan_: yeah
04:34:12 <mmorrow> heh
04:34:28 <opqdonut> mergesort would be a bit more appropriate and real-world I guess
04:34:39 <vixey> if you merge the list comprehensions it is, isn't it?
04:34:50 <opqdonut> see my note at the bottom
04:34:55 <quicksilver> quicksort is
04:35:03 <mmorrow> rephrasing...a sorting algo is an awesome choice for this benchmark ;)
04:35:10 <quicksilver> a specific algorithm for the partitioning ;)
04:35:14 <gubagem> oh oh then use bubble sort
04:35:21 <opqdonut> quicksilver: yeah
04:35:21 <mmorrow> yay!
04:35:39 <quicksilver> but it doesn't really matter here.
04:35:44 <quicksilver> call it pseudo-quicksort if you like :)
04:35:49 <mmorrow> gugabem: better yet, just randomly permute the list and check for sortedness
04:36:01 <gubagem> can we actually get any slower?
04:36:15 <gubagem> I wonder what the big O of that would be
04:36:22 <mmorrow> quicksilver: yes ;)
04:36:22 <vixey> n! ..
04:36:31 <gubagem> thats quite horrible
04:36:50 <quicksilver> opqdonut: you do know that -O3 is meanigfless ;)?
04:37:06 <Botje> well, it's O(1) in the one universes where the random permutation is correct.
04:37:32 <Botje> s/one//
04:37:35 <PHO_> and if you are unlucky, it will be O(infty)
04:37:50 <opqdonut> I added a note about the quicksort name
04:37:55 <opqdonut> quicksilver: yeah :)
04:38:00 <quicksilver> opqdonut: a further point is that it's possble that the profiling overhead is for some reason worse in one case than the other.
04:38:25 <opqdonut> that might be
04:38:25 <quicksilver> since profiling adds accounting at certain points, if one algo has more accounting points than the other it may be affected worse.
04:39:18 <opqdonut> hmm, I should probably do a quick test on that
04:41:07 <ziman> is it O(n!) in average case?
04:43:25 <BONUS> is there already such a function: f g (a,b) = (g a, g b)
04:43:30 <vixey> yes
04:43:38 <BONUS> which one would that be
04:43:41 <vixey> I don't know
04:43:44 <BONUS> welp
04:43:44 <Saizan_> ?ty (***)
04:43:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:43:53 <dolio> join (***)
04:43:56 <BONUS> ah
04:44:03 <BONUS> cool
04:44:20 <vixey> :t ((&&&), join (***))
04:44:22 <lambdabot> forall (a :: * -> * -> *) b c c' (a1 :: * -> * -> *) b1 c1. (Arrow a1, Arrow a) => (a b c -> a b c' -> a b (c, c'), a1 b1 c1 -> a1 (b1, b1) (c1, c1))
04:45:09 <luqui> is there a conventional spelling for infix "flip (.)" ?
04:45:15 <quicksilver> >>>
04:45:19 <luqui> ah yes of course
04:47:52 <opqdonut> quicksilver: the profiling overheads are about the same
04:47:57 <luqui> PHO_, re: O(infty), I use that expression too.  But it does terminate with probability 1.  I wonder if there are some nice maths to describe such things...
04:48:04 <luqui> in the context of asymptotic notation perhaps.
04:48:34 <PHO_> loqui: ah, indeed...
04:48:44 <PHO_> I've never thought of that
04:49:00 <vixey> How do you read stuff like T : (Γ)s ci : (Θi [T , g])(T ti )  ?
04:49:08 <quicksilver> opqdonut: good :)
04:49:18 <vixey> what does it mean o_o
04:49:37 <luqui> vixey, out of context... nothing
04:50:00 <vixey> ci I think is the i'th constructor
04:50:04 <mmorrow> opqdonut: phew. you mean -O2 not -O3 right?
04:50:09 <vixey> T is maybe some some datatype... or something
04:50:17 <vixey> I really don't know
04:50:24 <opqdonut> mmorrow: yeah -O3 means -O2 :P
04:50:35 <mmorrow> opqdonut: hehe
04:50:52 <ziman> capital tee colon left parens capital gamma right parens... :)
04:50:57 <mmorrow> opqdonut: good to know. i'm using -O99 from now on
04:51:10 <opqdonut> --omg-optmize
04:51:15 <opqdonut> *optimize
04:51:20 <nornagon> --omg-donuts
04:51:27 <osfameron> luqui: sorry about that -- I've emailed vox to whine at them, I think I should look for another blog host
04:51:44 <opqdonut> nornagon: :P
04:52:10 <mmorrow> nornagon: --omg-where
04:53:13 * PHO_ wonders how -O3+2i means
04:53:28 <opqdonut> -O\omega
04:54:21 <nornagon> that's optimising for imagination
04:54:25 <nornagon> it makes your code more creative
04:54:52 <PHO_> oh, it's so cool
04:57:11 <nornagon> -O[cos 90  -sin 90; sin 90  cos 90] rotates your code by 90°
04:58:21 <mmorrow> opqdonut: interesting. looking forward to part 2 : http://pseudo.fixme.fi/~opqdonut/blog/Attribute_Grammars__GADTs_and_MonadFix__part_1_.html
04:58:22 <lambdabot> Title: (&#x03BB;blog. blog blog) (&#x03BB;blog. blog blog): Attribute Grammars, GADTs a ..., http://tinyurl.com/5refno
05:02:43 <opqdonut> mmorrow: yeah, many've said so
05:02:43 <opqdonut> i'll probably get around to writing it some time this week
05:10:55 <hackage> New package: ghc-paths 0.1.0.1
05:15:06 <maltem_> What, a hackage bot? Nice :)
05:18:50 <vixey> :(
05:19:02 <vixey> why are all these journals not freely available online
05:19:19 <bpalmer`> trying to make money?
05:19:50 <paolino> is this only me that I need to define this function often ?
05:19:51 <paolino> sgroupBy f = groupBy ((==) `on` f). sortBy (comparing f)
05:20:14 <luqui> might not be just you, but it's not me
05:21:13 <paolino> ok, I was hoping in a , that's Data.Ord.abracadabra :)
05:21:16 <maltem_> paolino, you may prefer sth like  map fst . groupBy snd . sortBy (comparing snd) . map (id && f)
05:21:37 <maltem_> er, id &&& f, I mean
05:21:46 <paolino> maltem, for efficence?
05:22:04 <maltem_> right, because that way you're applying f to each element only once
05:22:09 <paolino> ok
05:22:28 <paolino> that's a rewrite rule
05:23:08 <maltem_> hm, did someone ever come up with a RULE pragma to catch this?
05:23:53 <maltem_> well it would probably be to special anyway
05:25:37 <dcoutts_> bos_, dons: the gui chapter is look good :-)
05:25:43 <dcoutts_> @seen pgavin
05:25:44 <lambdabot> pgavin has changed nick to pgavin-away.
05:25:44 <lambdabot> I saw pgavin-away leaving #haskell 5h 55m 16s ago, and .
05:25:47 <pejo> vixey, scholar.google.com can often find a copy of the article that isn't hidden in some journal
05:25:57 <dcoutts_> @tell pgavin see http://book.realworldhaskell.org/beta/gui.html
05:25:57 <lambdabot> Consider it noted.
05:33:57 <hkBst> dons: in your paper http://www.cse.unsw.edu.au/~dons/papers/polymer.pdf in the piMC algorithm, it seems that identifiers `within' and `cirlcePoints' should be one and the same.
05:38:26 <hkBst> dons: on page 5 the abbrev. GDM should be GBM, B for Brownian (as in the code comments).
05:51:20 <hpaste>  morrow annotated "haddock-2.0.0.0 under ghc-6.8.3" with "darcs whatsnew" at http://hpaste.org/8483#a1
05:51:40 <hpaste>  morrow annotated "haddock-2.0.0.0 under ghc-6.8.3" with "oh, and the link just in case" at http://hpaste.org/8483#a2
05:52:58 <mmorrow> cjs: maybe this will help? http://hpaste.org/8483#a1
05:53:29 <cjs> Yes, thank you.
05:53:43 <mmorrow> :)
05:53:56 <cjs> Good timing, too; I just finished discovering that I can't use 0.9 because of what seem to be differences in the way packages work.
05:54:54 <mmorrow> heh...good luck
05:55:30 <cjs> Does that still work under 6.2?
05:55:36 <cjs> I mean, 6.8.2?
05:55:46 <mmorrow> that's what i'm not sure about
05:55:59 <mmorrow> some of the changes it accounts for are internal ghc changes
05:56:18 <cjs> Ok, gimmie about 20 minutes to apply this and test it out with 6.8.3, and then I can roll back to 6.8.2 and see.
05:56:50 <mmorrow> so i'm not sure *when* exactly they occurred (at least before ghc-6.9.20080501)
05:57:07 <cjs> Kinda surprising that they ended up in 6.8.3.
05:57:44 <cjs> BTW, I have darcs, but my copy of haddock is not in a darcs repo. What's the easiest way to apply this patch?
05:58:15 <cjs> Just by hand?
05:58:17 <mmorrow> yeah. on the other hand though, since haddock is no coupled with ghc and uses some of its internals (which aren't guaranteed to be stable), it might just be a special case of haddock
05:58:31 <cjs> Hm, you exposed what used to be other-modules?
05:59:16 <mmorrow> cjs: oh, i searched but can't find the local copy of the haddocks darcs repo that i darcs whatsnew'ed from, so i woulda made you a patch but can't (so i had to search for that hpaste paste)
05:59:38 <mmorrow> so i suppose you'll just have to go through and manually apply those diffs
05:59:42 <mmorrow> yay!
06:00:08 <cjs> Err...yay.
06:00:12 <mmorrow> haha
06:00:18 <dcoutts_> bos_, dons: reading RWH and thinking about Cabal, one thing that might make life easier (both to explain and for users to use) is a cabal command to run the program or load it in ghci. At the moment you need to know that cabal puts stuff in dist/blah and loading things in ghci is tricky if there were any bits that cabal did that were actually needed.
06:00:18 <mmorrow> (sorry)
06:00:28 <pejo> Applying diffs is just sending them through patch - what is the problem?
06:00:48 <mmorrow> he has the output of "darcs whatsnew" and that's it
06:05:13 <PHO_> mmorrow: I've been waiting forever to get haddock working with 6.8.3. Great work!
06:06:24 <cjs> Well, let's see if it compiles.
06:06:35 <cjs> unknown flags in  {-# OPTIONS #-} pragma: -fspec-constr-count=20
06:06:48 <cjs> I don't need that, do I?
06:06:59 <dcoutts_> cjs: that flag probably can only be given on the command line
06:06:59 <jfredett> comment it and find out
06:07:06 <jfredett> :)
06:07:46 <cjs> import Distribution.InstalledPackageInfo (InstalledPackageInfo,InstalledPackageInfo_(..))
06:07:51 <cjs> What's up with the underscore, there?
06:10:39 <cjs> Well, I got everything compiling....
06:12:45 <mmorrow> PHO_: yay!
06:12:52 <mmorrow> PHO_: :)
06:13:31 <cjs> Let's see what happens under 6.8.2.
06:14:23 <ToRA> byorgey: ping
06:14:34 <byorgey> ToRA: pong
06:14:47 <cjs> Constructor `HsModule' should have 8 arguments, but has been given 7
06:14:49 <ToRA> heya, does zipedit have anything like an official home page or anything?
06:14:52 <cjs> Needs an #ifdef?
06:15:06 <byorgey> ToRA: no homepage, just a darcs repo
06:15:14 <ToRA> i'm rushing a hask symp paper and wanna cite it as relevant related work
06:15:15 <mmorrow> cjs, PHO_: i just applied those diffs to a just-gotten darcs haddock. testing it and'll put it on the internet somewhere in a few minutes...
06:15:54 <byorgey> ToRA: oh!  well, I guess you could just cite my recent blog post about it?
06:15:54 <ToRA> ok no probs i'll use that
06:15:54 <PHO_> I'm just applying the patch by hand :)
06:15:59 <cjs> src/Haddock/GHC/Typecheck.hs:73:46: Couldn't match expected type `FastString.FastString' against inferred type `String'
06:16:10 <cjs> Hm. So one or the other, really.
06:16:11 <ToRA> byorgey: ah yeah
06:16:15 <ToRA> byorgey: ok cool, i'll do that
06:16:16 <ToRA> cheers
06:17:49 <hpaste>  cjs annotated "haddock-2.0.0.0 under ghc-6.8.3" with "6.8.3 working patch" at http://hpaste.org/8483#a3
06:18:35 <PHO_> cjs: thanks very much
06:18:40 <mmorrow> here's a *real* diff: http://code.haskell.org/~morrow/code/haskell/misc/haddock-ghc69.diff
06:18:41 <lambdabot> http://tinyurl.com/697qq2
06:19:05 <mmorrow> cjs: nice!
06:19:46 <mmorrow> that 6.9 diff builds on 6.9.20080504
06:20:24 <mmorrow> (and probably any 6.9 with at most one or two changes)
06:20:38 <cjs> Hey, who puts up the binary releases for ghc? I've got a NetBSD package I could add.
06:20:57 <mmorrow> cool, ask in #ghc?
06:20:59 <edwardk> @seen rwbarton
06:20:59 <lambdabot> rwbarton is in #haskell. I don't know when rwbarton last spoke.
06:21:18 <edwardk> rwbarton: i went back and simplified the list example as requested
06:21:46 <hpaste>  morrow annotated "haddock-2.0.0.0 under ghc-6.8.3" with "ghc 6.9.20080504 working patch" at http://hpaste.org/8483#a4
06:24:43 <hpaste>  morrow annotated "haddock-2.0.0.0 under ghc-6.8.3" with "clarification" at http://hpaste.org/8483#a5
06:26:53 * byorgey is now very curious as to the topic of ToRA's paper...
06:32:19 <litb> hello all
06:32:30 <litb> can i simulate a turing machine using haskell ?
06:32:36 <litb> i want to play with it
06:32:38 <byorgey> of course.
06:32:48 <litb> oh nice
06:32:50 <gubagem> @faq can Haskell simulate a turing machine?
06:32:50 <lambdabot> The answer is: Yes! Haskell can do that.
06:32:52 <litb> have you made one?
06:32:57 <byorgey> me? no.
06:33:04 <litb> lambdabot: could you please elaborate?
06:33:07 <mauke> haha
06:33:10 <litb> hmm
06:33:11 <Axman6> you can do anything with haskell
06:33:13 <mauke> @vixen could you please elaborate?
06:33:13 <lambdabot> you have very nice manors
06:33:14 <litb> oh
06:33:26 <mauke> @vixen why thanks
06:33:27 <lambdabot> my pleasure
06:33:27 <osfameron> you can model the tape with a zipper
06:33:43 <litb> oh neat
06:33:44 <gubagem> you could model the tape with a list
06:33:55 <litb> oh even neater
06:33:56 <osfameron> yeah, but the tape is theoretically infinite in both directons
06:34:00 <byorgey> litb: it shouldn't be very hard.  yes, model the tape with a list zipper (i.e. a 'before' list, 'after' list, and a current item), and a function specifying the transitions
06:34:02 * gubagem doesnt understand zippers yet
06:34:13 <mauke> gubagem: the list zipper is trivial
06:34:15 <pejo> litb, there are "fast" TM simulators available to download, if you're interested in the TM and not the implementation in Haskell.
06:34:20 <litb> gubagem: zippers are easy
06:34:20 <mauke> gubagem: it's just two stacks
06:34:22 <gubagem> the tape is supposed to be infinite in both directions?
06:34:28 <litb> > zip (+) [1..]
06:34:29 <lambdabot>  Couldn't match expected type `[a]'
06:34:33 <osfameron> according to the original specification, yeah
06:34:34 <litb> > zip (+) [1..] [2..]
06:34:35 <lambdabot>  Couldn't match expected type `[a]'
06:34:36 <gubagem> two stacks and a cursor?
06:34:37 <litb> oh
06:34:38 <mauke> litb: not a zipper
06:34:38 <litb> hmm
06:34:43 <litb> what is wrong?
06:34:44 <gubagem> thats zipping
06:34:46 <mauke> gubagem: no, just two stacks
06:35:11 * gubagem parsing list zipper into memory bankes Please wait....
06:35:14 <litb> > zip (+) [1...] [2...]
06:35:14 <lambdabot>  Parse error at "]" (column 14)
06:35:21 <mauke> to move around in the list you shove items from one stack onto the other
06:35:22 <litb> > zipWith (+) [1..] [2..]
06:35:23 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
06:35:33 <byorgey> IIRC a TM with a tape that's only infinite in one direction is equivalent in power to one with a tape infinite in both directions
06:35:58 <bpalmer`> yes.
06:35:58 <gubagem> because |Z|=|N|
06:36:03 <litb> byorgey: yeah they are all equivalent
06:36:06 <ziman> yes, you can use X² instead of X as athe alphabet
06:36:11 <litb> even a reset machine is equivalent to it
06:36:22 <pejo> Adding more tapes/RAM/etc is equivalent in power too, standard exercises to prove it in a class on computational theory.
06:36:23 <byorgey> litb: what's a reset machine?
06:36:25 <bpalmer`> a reset machine?
06:36:41 <mauke> |a|b|c> <d|e|f|g| ===> |a|b|c|d|e> <f|g|
06:36:42 <litb> byorgey: a TM that cannot move to left, instead it always resets to the tape begin
06:36:53 <byorgey> litb: oh, I see
06:37:07 <osfameron> that's be even easier to implement
06:37:17 <litb> hmm
06:37:22 <litb> but how can i modify the TM using haskell?
06:37:27 <gubagem> but id imagine coding the TM would be more difficult
06:37:33 <litb> hmm
06:37:57 <litb> anyway, quit!
06:38:00 <litb> have fun today
06:38:13 <gubagem> was he trolling or fishing
06:42:49 <luqui> I fail to see the trolliness
06:44:21 <Axman6> me too
06:44:26 <gubagem> luqui: couldnt you see his large orange hair and small plastic belly?
06:52:38 <PHO_> http://aria.cielonegro.org/darcs/haddock-2-for-ghc-6.8.3/
06:52:38 <lambdabot> Title: Index of /darcs/haddock-2-for-ghc-6.8.3
06:52:52 <PHO_> Be aware: I won't maintain this repository for the future versions of haddock
06:59:52 <byorgey> gubagem: litb has hung out here a lot in the past, definitely not a troll =)
07:01:22 <balsagoth> hi there people. can anyone tell me how to get the execution time of a function? i'm using getClockTime to get the start and the end of the execution of a function and now i want to get the diff time, but i'm no being able to apply the diffClockTimes function. Can anyone help me with this?
07:03:27 <asmanian> Im really not experienced with haskell but I'm not sure this is possible at all
07:03:53 <asmanian> If I got it right, haskell doesn't even execute functions in the imperative sense
07:03:59 <asmanian> it rewrites expressions
07:04:12 <asmanian> 'transforms' might be a better word
07:04:23 <byorgey> it's still possible to time things, although it may not behave the way you might expect.
07:04:37 <Axman6> could profile it
07:04:50 <Axman6> but, not exactly the same thing
07:05:04 <byorgey> balsagoth: for simple timing of exression evaluation, you can just load up your code in ghci, do :set +s, then type in the expressions you want to time
07:05:06 <Axman6> someone needs to write Dtrace hooks for haskell
07:06:04 <byorgey> balsagoth: as for your particular question about diffClockTimes, without seeing your code it's hard to know
07:06:05 <balsagoth> byorgey: but i want to use that value in a other funtion
07:06:31 * SamB wishes category-extras could re-document the Monad class
07:06:58 <Athas> byorgey: um, isn't there a bit of overhead not coming from the code itself?
07:07:15 <byorgey> balsagoth: well, it should be possible to do something like  do { start <- getClockTime; doOtherStuff ; end <- getClockTime ; return (diffClockTimes start end) }
07:07:17 <mmorrow> here's haddock for (at least) ghc-6.9.20080504: http://code.haskell.org/~morrow/code/haskell/misc/haddock-2.1.0_ghc-6.9.20080504_080623.tar.gz
07:07:18 <lambdabot> http://tinyurl.com/5odzyf
07:07:19 <Athas> As I read the output, evaluating 2+2 allocates over a megabyte of memory.
07:07:25 <Athas> Surely that must be because the code is being compiled?
07:07:31 <byorgey> Athas: well, yes
07:07:43 <byorgey> Athas: but for many simple things that suffices
07:08:05 <byorgey> I didn't know exactly what balsagoth wanted so I figured I would start simple and work up =)
07:08:11 <balsagoth> for example: func = do start <-getClockTime result <-some function end<-getClockTime
07:08:32 <SamB> hmm, isn't there a missing monad law?
07:08:35 <SamB> @src liftM
07:08:35 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:08:43 <balsagoth> now i want to get the diffClockTimes beetwin start and end
07:08:59 <byorgey> balsagoth: ok, then you can do something like  let diff = diffClockTimes start end
07:09:04 <Athas> Is it possible to get more elaborate information, such as memory allocated by the program, time spent in garbage-colleciton, system calls and userspace code?
07:09:32 <mmorrow> here the unpacked darcs repo (tarball is still there): http://code.haskell.org/~morrow/code/haskell/misc/haddock-2.1.0_ghc-6.9.20080504_080623/
07:09:33 <lambdabot> Title: Index of /~morrow/code/haskell/misc/haddock-2.1.0_ghc-6.9.20080504_080623, http://tinyurl.com/622yo9
07:09:34 <SamB> I'm fairly certain that there should be a law fmap f p = return . f =<< p
07:09:51 <byorgey> balsagoth: note diffClockTimes is a pure function, it does not have a return value in the IO monad so you don't want to say something like  diff <- diffClockTimes start end
07:10:25 <pejo> Athas, there's a bunch of parameters you can give through +RTS -... that prints statistics.
07:10:27 <Axman6> Athas: profiling?
07:10:52 <ToRA> SamB: there is
07:11:04 <byorgey> unfortunately, Haskell does not require that every Monad is a Functor
07:11:12 <ToRA> SamB: read the docs for C.M under class Monad
07:11:15 <Athas> Axman6: yes, but preferably more lightweight than traditional profilers.
07:11:25 <SamB> oh
07:11:28 <byorgey> balsagoth: does that help?
07:11:30 <SamB> @docs Control.Monad
07:11:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
07:11:44 <SamB> ToRA: might want to change the haskellwiki page on the monad laws?
07:11:59 <ToRA> SamB: it's not strictly a monad law though
07:12:02 <SamB> @google the monad laws
07:12:04 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
07:12:04 <lambdabot> Title: Monad laws - HaskellWiki
07:12:11 <ToRA> SamB: since haskell monads don't need to implement Functor
07:12:21 <SamB> ToRA: uh
07:12:26 <byorgey> but they should!
07:12:27 <SamB> yes they do
07:12:39 <SamB> sure the class doesn't require it...
07:12:48 <SamB> but I have nfi why
07:13:06 <ToRA> it's not necessary?
07:13:09 <balsagoth> byorgey: thanks a lot, but can you tell me how i call a function between start and end
07:13:18 * ToRA plays devils advocate...
07:14:07 <SamB> ToRA: I'm sorry, but I assure you that it is necessary.
07:14:24 <SamB> if you don't do it, someone will file a bug report
07:14:39 <SamB> (if you are fortunate enough to have users)
07:14:49 <ToRA> SamB: from a theory point of view, sure.  from literally an api/code point of view no it's not
07:15:14 <SamB> if you want to know why it's expedient...
07:15:24 * byorgey advises SamB and ToRA to use the same definition of the word 'necessary' when arguing ;)
07:15:33 <SamB> point
07:15:37 <ToRA> heh
07:15:39 <SamB> what is your definition of necessary?
07:15:56 <ToRA> mine is to get it through the compiler and any contracts in the documentation
07:16:09 <ToRA> ;)
07:16:11 <SamB> my definition for this discussion is "users of your library will consider it a bug if you don't do it"
07:17:11 <byorgey> balsagoth: Just like you wrote above, if its result is in the IO monad:  result <- someFunc
07:17:31 <byorgey> balsagoth: or if its type is IO (), you can just write  someFunc  without the result <-
07:18:04 <byorgey> balsagoth: I should again caution you, however, that because of laziness, timing things in this way will *very likely* not give you meaningful results
07:19:12 <byorgey> balsagoth: if you really need to time various things I suggest you look into profiling tools
07:19:15 <byorgey> http://haskell.org/haskellwiki/Performance
07:19:16 <lambdabot> Title: Performance - HaskellWiki
07:20:03 <balsagoth> byorgey: thanks, i will check out and reply to you later
07:20:09 <byorgey> o
07:20:12 <byorgey> *ok
07:24:10 <balsagoth> byorgey: i have a exp function defined with a cathamorphism, how can i apply the monad IO to it?
07:26:07 <SamB> ToRA: that in mind, can you explain why Functor isn't a superclass of Monad?
07:29:29 <ToRA> SamB: i don't know the real reason, i would stab a guess on it being one of a) historical or b) being annoying requiring someone who wants to derive monad quickly also requiring them to write out the functor instance if they're never going to use it
07:29:58 <ToRA> SamB: though i don't necessarily (:)) disagree with you that it shouldn't be there
07:30:11 <nornagon> surely instance (Monad m) => Functor m ?
07:30:30 <mauke> no :(
07:30:37 <ToRA> nornagon: doesn't that break if you implement Functor first
07:30:38 <vixey> :t fmap
07:30:47 <nornagon> i mean
07:30:48 <quicksilver> nornagon: that says "All m are functors"
07:30:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:30:50 <mauke> nornagon: that breaks all other Functor instances
07:30:50 <quicksilver> this is not true ;)
07:30:54 <vixey> :t return
07:30:56 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:31:00 <vixey> :t (>>=)
07:31:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:31:13 <quicksilver> ToRA: to the best of my knowledge the reason is (b)
07:31:14 <nornagon> quicksilver: "All Monads m are Functors", right?
07:31:20 <quicksilver> ToRA: I consider it to be a stupid reason.
07:31:21 <mauke> nornagon: no
07:31:22 <quicksilver> nornagon: no.
07:31:26 <nornagon> oh.
07:31:26 <quicksilver> nornagon: "All m are functors"
07:31:31 <nornagon> dang.
07:31:35 <quicksilver> instance Functor m -- all m are Functors
07:31:39 <ToRA> quicksilver: i read it as a pragmatic reason
07:31:53 <quicksilver> instance (Monad m) => Functor m -- all m are Functors, but add the constraint that they be also monads
07:32:16 <quicksilver> ToRA: well yes, it's pragmatic. But it's pragmatism I strongly disagree with.
07:32:22 <nornagon> isn't there a way to say "if m is an instance of Monad, then it is also an instance of Functor by using these bits from Monad to define the Functor functions"
07:32:25 <nornagon> ?
07:32:31 <quicksilver> nornagon: not in haskell98, no.
07:32:38 <nornagon> ah :(
07:32:38 <quicksilver> that's not how haskell instance search works.
07:32:46 <vixey> :t \f m -> do x <- m ; return (f x)
07:32:47 <quicksilver> some people view this as an annoyance.
07:32:48 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => (t1 -> t2) -> t t1 -> t t2
07:32:52 <vixey> :t  fmap
07:32:55 <quicksilver> with overlapping-instances, ghc can do something like that.
07:32:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:33:11 <EvilTerran> also undecidable-instances
07:33:21 <vixey> fmap f = (>>= return . f)
07:33:25 <quicksilver> right.
07:33:27 <quicksilver> fmap = liftM
07:33:28 <EvilTerran> you'd write it as "instance Monad m => Functor m where fmap = liftM"
07:33:31 <quicksilver> in other words.
07:33:40 <vixey> liftM oh
07:33:42 <ToRA> is instance Monad m => Applicative m true?
07:33:46 <EvilTerran> however, that on its own requires UndecidableInstances
07:33:49 <EvilTerran> ToRA, yes, (<*>) = ap
07:33:53 <ToRA> thought so
07:34:00 <edwardk> In general the fact that Functor isn't a superclass of Monad is a historical accident, because they didn't want to make you define a Functor instance.
07:34:10 <ToRA> so would you require class (Functor m, Applicative m) => Monad m ?
07:34:16 <quicksilver> edwardk: you can't say it's an accident, and then give a reason, surely?
07:34:18 <ToRA> s/Functor m,// as it's implied
07:34:25 <EvilTerran> and, if you have any other functor instances, an instance of the form "Functor m" would overlap them
07:34:26 <quicksilver> edwardk: it's *either* an accident, or it was deliberate, and that was the reason.
07:34:40 <edwardk> quicksilver: well, its nicer to say that it was an accident than to just come out and say it was a stupid decision ;)
07:34:44 <EvilTerran> ToRA, yes, that would be nice to have
07:35:00 <pjdelport> cue class aliases
07:35:24 <edwardk> the viewpoint that you shouldn't have to define a lot of classes really pervaded a lot of the Haskell 98 thinking, and really led to a lot of the warts on the language today.
07:35:29 <EvilTerran> actually, i'd probably arrange it as Functor, Pointed, Applicative, Monad
07:35:34 <ToRA> EvilTerran: but now i have to implement 3 classes every time i want a monad for a quick hack :(
07:35:36 <mauke> ToRA: just Applicative m => Monad m since Applicative requires Functor
07:35:43 <EvilTerran> (class Pointed f where pure :: a -> f a)
07:35:43 <pjdelport> http://repetae.net/recent/out/classalias.html
07:35:44 <lambdabot> Title: Class Alias Proposal for Haskell
07:35:49 <ToRA> mauke: i said that ;)
07:35:55 <mauke> oh, right
07:36:02 <edwardk> Who cares that you have to define an instance of a separate MonadZero to get fail? Nowadays you usually use monad transformers to build your monad rather than roll it directly anyways.
07:36:29 <mauke> ToRA: at least the two superclass definitions are short and mechanical
07:36:33 <EvilTerran> ToRA, there's a proposal somewhere to allow you to define methods of superclasses within the instance decleration
07:36:36 <edwardk> evilterran: well, if you open up the set of categories you can take the functor over you can't always inject Applicative into the hierarchy =/
07:36:43 <ToRA> EvilTerran: yeah, that would be nice
07:36:46 <mauke> instance Functor M where fmap = liftM; instance Applicative M where (<*>) = ap
07:36:47 <EvilTerran> edwardk, what?
07:36:51 <edwardk> evilterran: Applicative superclasses Monad only if you are in a CCC.
07:37:00 <EvilTerran> edwardk, what?
07:37:10 <vixey> is haskell not a CCC?
07:37:13 <edwardk> evilterran: so if you have a more general Functor, then you can't get the Applicative superclass
07:37:13 * EvilTerran is not a category theorist, and does not know what a CCC is
07:37:19 <edwardk> vixey: Haskell is. But if you have
07:37:20 <vixey> closed cartesian
07:37:25 <dolio> Only if you're programming Haskell. :)
07:37:32 <EvilTerran> closed cartesian... category?
07:37:50 <EvilTerran> this phrase gives me no new information. only words. :P
07:37:56 <edwardk> class (Category c, Category d) => Functor f c d | f c -> d, f d -> c where fmap :: c a b -> d (f a) (f b)
07:37:58 <vixey> closed cartesian crab
07:38:02 <edwardk> if you start there
07:38:12 <dolio> Cartesian closed categories have a curry operation.
07:38:14 <quicksilver> EvilTerran: basically a close cartesian category is one in which tuples + currying means what you think it means.
07:38:15 <edwardk> for arbitrary Category definitions c and d, of which (->) is a valid selection
07:38:27 <quicksilver> of course Hask isn't quite a CCC either
07:38:29 <quicksilver> but it's close enough.
07:38:33 <EvilTerran> quicksilver, ah, thanks
07:38:48 <edwardk> then you don't have a strong enough requirement to be able to make the more general Applicative instance a superclass of the more general Monad
07:38:55 <mauke> it's all abstract nonsense to me
07:39:09 <vixey> oh I see
07:39:35 <vixey> if (a -> b) is Hask? is there anything for forall x : a, b ?
07:40:14 <quicksilver> vixey: no idea what you're trying to ask.
07:40:46 <edwardk> evilterran: i mostly mention it because it isn't immediately obvious that making Applicative superclass Monad introduces an assumption.
07:40:52 <vixey> stil thinking about PTSs..
07:41:00 <EvilTerran> edwardk, ok. i'll take your word for it ;)
07:41:22 <edwardk> evilterran: also if you are going for pathological generality, you may want to factor out >>=/join from monad into a separate typeclass so that you can build dyads.
07:41:23 <vixey> "To a mathematician or professional logician there is one further and more difficult stage, which is to understand what all the models are and possibly to understand the structure of this collection as a mathematical domain. Hackers may be happy to manage without this, especially since the answer often comes out in inscrutable category theory.
07:41:23 <vixey> "To a mathematician or professional logician there is one further and more difficult stage, which is to understand what all the models are and possibly to understand the structure of this collection as a mathematical domain. Hackers may be happy to manage without this, especially since the answer often comes out in inscrutable category theory."
07:41:26 <vixey> oops
07:41:28 <vixey> sorry
07:41:56 <edwardk> evilterran: otherwise they can't share sugar
07:42:10 <EvilTerran> i don't know what a dyad is either :P
07:42:20 <mauke> is it like a dryad?
07:42:37 <gubagem> did you remeber to tap your forests mauke?
07:42:47 <gubagem> vixey: where is that quote from
07:42:47 <edwardk> mauke: not as pretty. basically its the smallest abstraction that contains monads and comonads, unfortunately its a little to small to be very useful.
07:42:58 <edwardk> er s/to/too
07:43:04 <pgavin> george carlin died :/
07:43:05 <lambdabot> pgavin: You have 1 new message. '/msg lambdabot @messages' to read it.
07:43:13 <twobitwork> gubagem: mmmm... mtg referrences
07:43:20 <EvilTerran> i have been wondering if there'd be some middle ground between Pointed and Applicative, though, as I feel there's uncomfortably many axioms required for Applicative that you don't need for, say, Functor
07:43:59 <EvilTerran> five laws, just for <*>
07:44:37 <vixey>  is there any category which models pure type systems
07:44:54 <quicksilver> what is a "pure type system" vixey?
07:45:03 <EvilTerran> (pure is also involved in them, but there's no axioms for just pure, as all its properties alone and with fmap are implied by its type iirc)
07:45:08 <edwardk> quicksilver: PTSs are generalizations of the lambda cube
07:45:43 <edwardk> 7 little laws, parameterized over a set of sorts, rules and axioms that together let you define any point in the cube and many points beyond by changing those parameters.
07:46:19 <edwardk> quicksilver: best introduction I've found: http://people.cs.uu.nl/johanj/MSc/jwroorda/ (with source code)
07:46:20 <lambdabot> Title: Pure Type Systems for Functional Programming
07:46:52 <edwardk> vixey: there is a categorical model for each pure type system you can construct, I don't recall where I saw the derivation of it though.
07:47:32 <edwardk> probably something by cockett and seely
07:48:29 <quicksilver> smart guys.
07:48:34 <gubagem> whats is a lambda cube?
07:49:10 <quicksilver> @go lambda cube
07:49:11 <lambdabot> http://en.wikipedia.org/wiki/Lambda_cube
07:49:54 <pgavin> @go time cube
07:49:55 <lambdabot> http://www.timecube.com/
07:49:56 <lambdabot> Title: Time Cube
07:50:10 <Apocalisp> @go weighted companion cube
07:50:11 <lambdabot> http://store.valvesoftware.com/productshowcase/productshowcase_WCC-Plush.html
07:50:11 <lambdabot> Title: Welcome to Steam
07:50:13 <edwardk> gubagem: if you start with the simply typed lambda calculus and extend it by letting types depend on types or terms depend on types or types depend on terms you get the cube. each of those 3 things defines a 'dimension' over which you can modify the type system
07:50:19 <ToRA> Apocalisp: damn, you beat me to it :p
07:50:20 <edwardk> together you get 8 points that form a cube
07:51:30 <edwardk> in one corner you have the simply typed lambda calculus. on the other you have the beginnings of the calculus of constructions.
07:52:29 <gubagem> ok so its 2^3, are there larger cubes?
07:52:48 <mar77a> > a * a == a ** a
07:52:49 <lambdabot>  False
07:53:11 <mar77a> > 2 * 2 = 2 ** 2
07:53:11 <lambdabot>  Parse error at "=" (column 7)
07:53:15 <mar77a> > 2 * 2 == 2 ** 2
07:53:16 <vixey> > a + 1 == 1 + a
07:53:17 <lambdabot>  True
07:53:18 <lambdabot>  False
07:53:22 <mar77a> whats
07:53:25 <vixey> > a == a + 0
07:53:26 <lambdabot>  False
07:53:30 <mar77a> okay
07:53:30 <ToRA> eek, why do exprs have equality implemented?
07:53:37 <vixey> Num
07:53:44 <vixey> it's a stupid eq instance though
07:53:47 <EvilTerran> @check \a -> a + 1 == 1 + a
07:53:49 <lambdabot>  OK, passed 500 tests.
07:53:55 <vixey> that would be a better one
07:54:05 <EvilTerran> impossible to implement, tho, i suspect
07:54:25 <EvilTerran> even unsafePerformIO'ing quickcheck aside
07:54:50 <mar77a> @check a*a == a**a
07:54:51 <lambdabot>  Falsifiable, after 0 tests:
07:54:55 <vixey> just interpret True as Probably, False as CertainlyNot
07:55:40 <EvilTerran> if you did it the other way, that'd be kinda like intuitionist logic, wouldn't it?
07:55:55 <vixey> what other way?
07:56:04 <EvilTerran> P: "we know P"; ¬P: "we don't know P"
07:56:23 <EvilTerran> (as compared to conventional logic, in which ¬P: "we know (not P)"
07:56:52 <edwardk> gubagem: there are a lot more pure type systems than the systems in the cube. for instance maybe you want to have polymorphic functions that take polymorphic functions as arguments yielding polymorphic results.
07:56:55 <vixey> no, ¬P still means the same in intuitionistic logic
07:57:10 <edwardk> so you get higher order polymorphism, etc. above the 'cube' you tend to just go for an arbitrary type tower in the style of Per Martin Loef, so you tend to 'ditch' the word cube and talk about a predicative type tower.
07:57:21 <quicksilver> vixey: on the contrary.
07:57:28 <quicksilver> vixey: EvilTerran's version is one common reading.
07:57:37 <quicksilver> (in a constructive or intuitionistic context)
07:57:41 <EvilTerran> quicksilver, ah, good to know i'm not crazy
07:57:49 <quicksilver> "have a proof of" is another reading.
07:57:50 <edwardk> you can build other types of structures but that is common because its regular and admits interpretation in terms of nested universes of discourse.
07:58:03 <EvilTerran> quicksilver, as in, ¬P: "we don't have a proof of P"?
07:58:07 <gubagem> could i make a lambda hypercube?
07:58:17 <vixey> quicksilver: "we don't know P" is not the same as "we have a proof of False given P" to me ...
07:58:22 <quicksilver> EvilTerran: no, "not p -> I have a proof that P leads to a contradiction"
07:58:29 <EvilTerran> ah, i see
07:58:33 <BMeph> edwardk: So, do you have IO as a comonad in your package? :)
07:58:35 <vixey> quicksilver: "we know (not P)" is the same as "we have a proof of False given P" though
07:58:36 <EvilTerran> never mind
07:58:42 <EvilTerran> i'm confused now
07:58:44 <ToRA> i though intuitionistic logic meant you didn't have (¬P v P) or something equivalent as an axiom?
07:58:52 <quicksilver> that's right.
07:58:56 <ToRA> wheras classical logic you do
07:59:17 <ToRA> *classical = conventional
08:00:15 <Botje> Segmentation fault.
08:00:16 <edwardk> gubagem: sure, pick another direction to extend the type system. in PTS terms the lambda cube is defined by picking a set of sorts {*,#}, an axioms, {*:#}, and a set of rules saying that (*,*) and some subset of{ (*,#) (#,*), (#,#) }. Picking a different set of sorts, and axioms lets you define a larger system, but its no longer in any sense minimal
08:00:29 <edwardk> BMeph: Nah, the OI comonad is an ill-founded concept
08:00:44 <Dessous> @src openFile
08:00:45 <lambdabot> Source not found. You untyped fool!
08:00:49 <edwardk> BMeph: it doesn't work for Hask, you need some sort of linearity/uniqueness guarantee to make it work
08:00:49 <Botje> the IO monad is a a much better ncept
08:01:03 <vixey> I think Luo used {*1,*2,#} for UTT
08:01:22 * Botje is enjoying Terry Pratchett's "Going Postal" very much
08:01:30 <edwardk> though UTT actually has a universe tower as well, no?
08:01:50 <edwardk> Type_i : Type_{i + 1}, etc.
08:01:55 <vixey> oh I think it does actually yes
08:02:14 <edwardk> in fact I know it does. Thats where I really finally grokked the idea from ;)
08:05:49 <dolio> What's the U for?
08:07:41 <edwardk> Unifying Theory of dependent Types
08:07:55 <edwardk> UTT
08:08:48 <edwardk> UTT = the extended calculus of constructions with a Martin-Löf style universe tower
08:09:53 <edwardk> basically if you look at it through kinda fuzzy goggles you can see most of Coq's type system.
08:10:12 <mauke> @quote semantics
08:10:12 <lambdabot> xxd says: but 90% of programming is semantics
08:10:13 <dolio> Well, I was hoping it would lead to papers, but apparently not since citeseer is down.
08:10:28 <vixey> Coq adds datatypes and pattern matching
08:10:30 <edwardk> dolio: Luo has a very nice book on the topic that I highly recommend
08:10:34 <vixey> oh and modules
08:10:41 <edwardk> heh, hence most =)
08:10:44 <vixey> which make the type system about 3x more complex o_o
08:10:49 <dolio> Computation and Reasoning?
08:11:20 <vixey> I wish I could read that book
08:11:24 <vixey> my library doesn't have it
08:11:28 * vixey was looking for it earlier
08:11:47 <edwardk> dolio: yeah
08:12:01 <edwardk> i bought a copy on a whim, and was very glad that I did so
08:12:02 <dolio> You can read it on google, apparently.
08:12:07 <vixey> it's very very expensive though...
08:12:13 <dolio> If you have the patience.
08:12:26 <vixey> dolio: some pages are missing I think
08:12:57 <edwardk> you should be able to pick it up from amazon used for like $50-60
08:12:59 <dolio> Ah, yeah, so it seems.
08:31:36 <Gilly> when doing a sort using syntax like sortBy (compare `on` f) list is there an easy way to reverse the sort on the fly?
08:31:56 <vixey> flip
08:31:56 <Gilly> something like compare function but in the reverse way is what i'm looking for
08:32:12 <vixey> > sortBy (<) [5,6,8,4]
08:32:14 <lambdabot>  Couldn't match expected type `Ordering'
08:32:18 <mrd> flip compare
08:32:21 <vixey> > sortBy (flip (comparing (<))) [5,6,8,4]
08:32:25 <Gilly> ah, thanks :)
08:32:25 <lambdabot>   add an instance declaration for (Ord (a -> Bool))
08:32:30 <mrd> but also reverse . sort :)
08:32:37 <Gilly> but reverse . sort is gonna be slower?
08:32:40 <mrd> > sortBy (flip compare) [1..4]
08:32:42 <lambdabot>  [4,3,2,1]
08:32:50 <vixey> > sortBy (flip (comparing (id))) [5,6,8,4]
08:32:51 <lambdabot>  [8,6,5,4]
08:33:02 <vixey> comparing f = compare `on` f?
08:33:06 <vixey> @src comparing
08:33:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:33:11 <mrd> not asymptotically
08:34:46 <pastorn> :type comparing
08:34:54 <pastorn> @type comparing
08:34:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:35:21 <Deewiant> Gilly: in practice, yes, reversing is slower
08:35:21 <pastorn> @type sortBy
08:35:23 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
08:36:37 <Gilly> ok, thanks all :) (although sorting the stuff i was thinking about to sort just slowed down my algorithm :/)
08:40:58 <pastorn> @src sortBy
08:40:58 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:41:09 <sclv> @seen geezusfreak
08:41:09 <pastorn> @src insertBy
08:41:09 <lambdabot> I haven't seen geezusfreak.
08:41:09 <lambdabot> insertBy _   x [] = [x]
08:41:09 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
08:41:09 <lambdabot>                                  GT -> y : insertBy cmp x ys'
08:41:09 <lambdabot>                                  _  -> x : ys
08:41:26 <vixey> @seen geezusfreeek
08:41:26 <lambdabot> I saw geezusfreeek leaving #haskell 2d 8h 56m 29s ago, and .
08:41:34 <sclv> ah, thanks vixey!
08:42:14 <sclv> anybody but geezusfreeek and me have any experience trying to compose STM and MVars with unsafeIOToSTM to create different concurrency constructs?
08:42:40 <sclv> I know its dodgy territory, but I'm getting consistent segraults.
08:42:45 <sclv> erm, segfaults.
08:43:21 <edwardk> sclv: i did some stuff with it a year or so back as i recall
08:43:30 <edwardk> can't do it at all?
08:44:10 <sclv> at the moment -- I haven't distilled down a test case though.
08:44:18 <audreyt> simple cabal question. can I have a configuration predicate like:
08:44:26 <sclv> I upgraded to 6.8.3 hoping it was just the bug with mvars that bos ran into, but no such luck...
08:44:26 <audreyt>   if package(readline)
08:44:34 <audreyt>       Build-depends: readline
08:44:39 <audreyt>         -- also set some flag here
08:44:39 <audreyt> ?
08:44:42 <dcoutts_> audreyt: no
08:44:52 <audreyt> no as in not a good idea
08:44:55 <dcoutts_> audreyt: both
08:44:56 <audreyt> or no as in not currently implemented?
08:45:00 <edwardk> you can make a flag readline, and maybe build-depends: readline for the flag
08:45:07 <edwardk> then you can test for the flag to see if readline is present
08:45:31 <edwardk> it'll try to turn it on and fail back gracefully
08:45:38 <audreyt> indeed?
08:45:42 <dcoutts_> audreyt: the reason is that you're not allowed to test if readline is present and do different things on that basis. However you can achieve something similar that is kosher.
08:45:45 <audreyt> is there some sample code somewhere?
08:45:56 <edwardk> i do something like that in the config for category-extras
08:46:22 <edwardk> http://comonad.com/haskell/category-extras/category-extras.cabal
08:46:25 <dcoutts_> audreyt: you're trying to implement an optional feature that uses readline right?
08:46:27 <edwardk> see ArrowSubclassesCategory
08:46:32 <mattam> edwardk: what's the rationale for PFunctor and QFunctor?
08:46:33 <edwardk> that uses different build-depends
08:47:03 <edwardk> mattam: type inference the lack of the ability to generate 'forall' quantification in typeclass constraints =)
08:47:04 <mattam> It seemed like high-level typeclases/fundeps hackery at first sight.
08:47:15 <edwardk> mattam: it purely exists for type inference
08:47:19 <mattam> Alright.
08:47:33 <dcoutts_> audreyt: if so, the right thing to do is declare a flag corresponding to that feature: flag cool-command-line-editing
08:47:45 <edwardk> in general if i don't use the other parameter i get screwed over by haskell's typeclass machinery.
08:47:55 <dcoutts_> audreyt: then in the lib/exe section say: if flag(cool-command-line-editing) { build-depends: readline }
08:48:06 <mattam> Also, is the Pointed/CoPointed notion standard? I failed to find a reference for it anywhere.
08:48:40 <edwardk> There was a paper that used distributive laws for pointed and copointed endofunctors over monads and comonads
08:49:41 <dcoutts_> audreyt: now a user can say they want to build with that flag on or off and it'll do the obvious thing. If the user does not specify then configure does a search to find a value of that flag that works on the system. It has a preference for picking the flag to be True if both True and False will work (and you can reverse the default if that makes more sense for your feature).
08:50:37 <audreyt> I see. thanks!
08:50:44 <pejo> edwardk, 'get screwed over by'? Is fundeps not enough to solve the problem?
08:51:44 <PHO_> if flag(with-readline) { build-depends: readline ; ghc-options: -cpp -DHAVE_READLINE=1 }
08:52:03 <dcoutts_> audreyt: the reason you can't directly do if package(foo) is a bit subtle, but basically we designed the system specifically so that packages could not do things like that because it causes headaches for automatic package management and we believe that automatic package management is vitally important (both distro packages and cabal-install style)
08:52:09 <edwardk> pejo: fraid not. you need to break the typeclass up or you wind up having to put in manual type annotations. if you think about it the PFunctor and QFunctor decompositions are the minimal set of requirements for 'first' and 'second' to work, so it makes sense that you may have a Bifunctor for which you don't know or care about the category over which the other argument comes from
08:52:20 <RayNbow> > sortBy (compare `on` (snd &&& fst)) [(2,1),(1,2),(0,3),(3,1)]
08:52:21 <lambdabot>  [(2,1),(3,1),(1,2),(0,3)]
08:52:43 <audreyt> dcoutts_: is "cabal-version: >= 1.2.1" correct if I'm to use configurations/flags?
08:52:48 <vixey> :t compare `on` (snd &&& fst)
08:52:49 <audreyt> category-extras has "cabal-version: >= 1.2"
08:52:50 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Ordering
08:52:55 <edwardk> pejo: i have fundeps, but they can't handle the case where i never use the one side of the bifunctor at all.
08:53:10 <dcoutts_> audreyt: yep, the flags syntax is new in Cabal-1.2
08:53:25 <dcoutts_> audreyt: if you leave it off then Cabal will warn you :-)
08:53:30 <audreyt> ok :)
08:53:34 <edwardk> dcoutts: yes, but 1.2 or 1.2.1?
08:53:39 <RayNbow> vixey, http://www.haskell.org/arrows/addA-comb.png
08:53:43 <pejo> edwardk, bummer.
08:53:51 <dcoutts_> edwardk: 1.2 should be fine, you may have other reasons for wanting 1.2.1
08:53:55 <edwardk> k
08:54:30 <vixey> RayNbow: What's +?
08:54:32 <dcoutts_> edwardk: in practise it doesn't matter since everyone has 1.2.3.0 or whatever pre-1.2 version they had in ghc-6.6.x
08:54:38 <edwardk> yeah
08:54:53 <RayNbow> vixey: in that diagram?
08:55:04 <vixey> oh right
08:55:15 <vixey> Ord a, Ord b => Ord (a,b)
08:55:25 <vixey> > (1,2) < (3,1)
08:55:26 <lambdabot>  True
08:55:47 <vixey> why the diagram uses + instead of ,.. I couldn't know
08:56:24 <Deewiant> > (1,20) < (3,1)
08:56:25 <lambdabot>  True
08:56:29 <RayNbow> oh, in the diagram the (+) comes from the lambda function
08:56:45 <vixey> yes they shoul use (,) in the lambda...
08:57:46 <RayNbow> vixey, only the left part of the diagram corresponds with (&&&)
08:57:59 <EvilTerran> vixey, the (+) is a literal (+). the lambda = uncurry (+)
08:58:26 <vixey> ok
08:58:32 <EvilTerran> actually, uncurry (flip (+)), but that's a technicality :P
08:59:29 <RayNbow> EvilTerran: it might be important though, when there is some evil type out there that has a weird non-associative definition for (+) :p
08:59:49 <audreyt> dcoutts_: if flag(EnableReadLine) { build-depends: readline, a, b, c, d } else { build-depends: a, b, c, d }
09:00:01 <audreyt> dcoutts_: that seems repetitive... but if I factor out a,b,c,d to outer scope
09:00:15 <audreyt> it seems that it can't be appended to readline
09:00:21 <audreyt> or am I doing it wrong?
09:00:37 <edwardk> hrmm the factoring into two build-depends: clauses works fine for me
09:01:03 <edwardk> notice in the category-extras.cabal there is a separate build-depends for mtl >= 1.1
09:01:09 <audreyt> hm.
09:01:28 <edwardk> similarly i build up ghc-options piecemeal
09:01:34 <dcoutts_> audreyt: you should be able to put a build-depends at the top level to factor it ouy
09:01:43 <edwardk> audreyt: btw, nice to see you back, long time no see.
09:01:45 <audreyt> it seems that the factor out need to be placed first
09:01:48 <audreyt> edwardk: heya
09:02:07 <edwardk> hrmm
09:02:14 <dcoutts_> audreyt: oh you mean it's sensitive to the order? hmm, if so that would be a bug.
09:02:24 <edwardk> that would be something to harass dcoutts about =)
09:02:34 <audreyt> nvm, it's sensitive to indent level
09:02:37 <audreyt> mea culpa
09:02:40 <audreyt> bbiab
09:02:48 <dcoutts_> audreyt: ah right, yes.
09:03:05 <dcoutts_> audreyt: it's a layout style, or you can use explicit {}'s
09:04:37 <dcoutts_> edwardk: yes, I think it's best practise to factor them as much as possible.
09:09:18 <dcoutts_> @seen pgavin
09:09:18 <lambdabot> pgavin is in #haskell. I last heard pgavin speak 1h 19m 24s ago.
09:10:19 <dcoutts_> pgavin: did you see the GUI chapter in RWH? :-)
09:10:49 <dons> go audreyt !
09:11:05 <hackage> New package: Pugs 6.2.13.3
09:11:05 <hackage> New package: pugs-compat 0.0.4
09:11:16 <pgavin> dcoutts_: yep
09:11:29 <Deewiant> woot, hackage-bot?
09:11:34 <dons> yep
09:11:35 <pgavin> dcoutts_: pretty cool
09:11:56 <quicksilver> I note that somebody objected to the idea of a hackage bot when first proposed.
09:11:57 <kiris> =o
09:12:04 <quicksilver> I'm glad whoever wrote it didn't know that, or ignored it. :P
09:12:09 <dcoutts_> pgavin: aye. I sent you a tiny patch for a function they should be using in that RWH chapter but was missing.
09:12:16 <dons> i did'nt know there were objections, quicksilver
09:12:24 <pgavin> dcoutts_: I just applied it to my repo
09:12:30 <dcoutts_> pgavin: :-)
09:12:33 <dons> i think i'll tweak it to print the cabal install line
09:12:49 <dcoutts_> dons: oh good idea :-)
09:13:08 <pgavin> dcoutts_: when you get a chance, can you test the win32 installer for me on your box?
09:13:10 <dcoutts_> dons: like: cabal install Pugs-6.2.13.3
09:13:14 <dcoutts_> pgavin: sure
09:13:15 <dons> yep
09:13:25 <EvilTerran> a link to the hackage page would be nice
09:13:30 <dcoutts_> dons: display pkgid should do it
09:14:56 <vixey> :(
09:15:00 <dcoutts_> dons: it needs a name other than tutorial bot :-)
09:15:12 <vixey> do you have to have 6.8.3?
09:15:14 <dcoutts_> dons: how does it work? pings the hackage latest rss feed?
09:15:22 <vixey> (for hackage pugs)
09:15:29 <dons> it grabs and diffs the rss feed once an hour
09:15:34 <pgavin> wow, someone's actually trying to rewrite gcc in c++
09:15:45 <dons> dcoutts_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rss2irc-0.1
09:15:46 <lambdabot> http://tinyurl.com/6kax8x
09:15:50 <pgavin> lol
09:15:55 <quicksilver> pgavin: they're not rewriting it.
09:16:07 <quicksilver> pgavin: they're just adjusting the C++ incompatibilities so it compiles as C++.
09:16:20 <quicksilver> you have to recognise that GCC is not written in C anyway.
09:16:27 <pgavin> quicksilver: good point
09:16:29 <quicksilver> it's written in a remarkably complex array of CPP macros.
09:16:35 <pgavin> lol
09:17:14 <pgavin> why do they want it to compile in c++ though
09:17:15 <pgavin> ?
09:17:19 <pgavin> seems silly
09:17:33 <quicksilver> because CPP macros are not really a great programming language.
09:17:40 <quicksilver> they have a few subtleties which catch many people out
09:17:47 <quicksilver> and gdb is not aware of them in a useful way
09:17:48 <dcoutts_> dons: hmm I see. I think if it's using tagsoup that it is an indication that the hackage server does not provide data in sufficiently convenient formats.
09:17:55 <quicksilver> so when you're debugging code, you're debugging expanded code.
09:18:04 <quicksilver> whilst believe me I'm no fan of C++
09:18:17 <EvilTerran> they should re-write gcc in haskell :D
09:18:17 <quicksilver> it certainly contains abstractions which are more scalable than CPP macros ;)
09:18:39 <pgavin> quicksilver: sure, ok
09:19:18 <quicksilver> EvilTerran: it would be a very interesting experiment to have a well motivated and skilled team write a C compiler in haskell and see how quickly they could appraoch gcc's code generation.
09:19:23 <dons> dcoutts_: oh, it's only using Tagsoup.Download.openURL
09:19:32 <dons> dcoutts_: but the feed package parses it easily enough
09:19:34 <quicksilver> EvilTerran: however gcc is not a trivial project, no matter how good your team ;)
09:19:40 <quicksilver> or how good your language.
09:19:59 <dcoutts_> dons: oh, so you're using tagsoup as a quick and easy wrapper over the HTTP lib
09:20:03 <dons> yep
09:20:07 <EvilTerran> i'd say nothing's a trivial project in C, so we've got a head-start already ;)
09:20:19 <dcoutts_> dons: so it's an indication that the HTTP package needs improvements :-)
09:20:22 <dons> a 'proper' openURL based on curl or HTTP would be better, but tagsoup's useful for a lot of things
09:20:53 <dons> dcoutts_: note also the sparkline graphs of uploads now on haskell.org's frontpage
09:21:00 <dons> if i didn't point those out
09:21:08 <EvilTerran> maybe some of the utility functions that don't actually have anything to do with extracting data from badly-written HTML could do with being extracted to their own package?
09:21:14 <EvilTerran> HTTP-Utils or something
09:21:16 <quicksilver> EvilTerran: no, GCC has a head-start. About 20 years of development ;)
09:21:22 <dons> dcoutts_: btw, this is enough to get structured data from hackage,
09:21:23 <dons>       RSSFeed is <- (fromJust . parseFeedString) `fmap` openURL url
09:21:28 <EvilTerran> quicksilver, doh. you win.
09:21:29 <dons> so pretty good.
09:21:38 <dcoutts_> dons: I saw the package uploaded, I'd not seen it used
09:21:43 <dons> then just take rssItemLink and rssItemTitle
09:21:59 <dcoutts_> dons: btw, Lemmih_ and I are meeting up later to hack on a happs based hackage server prototype
09:22:18 <dons> oh interesting. elliottt and i are almost done with the stuff we need.
09:22:22 <dcoutts_> dons: Lemmih_ is in Oxford for 6 weeks doing a language course
09:22:25 <dons> cool
09:22:35 <dcoutts_> dons: great, we should see about integrating the stuff
09:22:55 <dcoutts_> dons: I expect we'll be able to steal much of the existing hackage-scripts code
09:23:19 <dcoutts_> dons: just we'll be able to put it on a slightly better architecture
09:23:48 <dcoutts_> eg guarantee atomic updates of the index
09:24:06 <dons> mm
09:24:12 <dcoutts_> easier to add more data about packages and package versions
09:24:22 <dcoutts_> since it's all haskell data rather than files
09:24:54 <dcoutts_> dons: and deployment is trivial: cabal install hackage-server && ./hackage-server
09:25:01 <dcoutts_> that bit already works :-)
09:25:42 <dons> hehe
09:26:02 <dcoutts_> dons: btw, I do like the spark lines, that's nice. We should put that on the hackage web pages too :-)
09:27:26 <dcoutts_> but to be able to do that hackage needs to be easily hackable and I don't think that's the case currently
09:28:50 <dcoutts_> pgavin: I cannot install the gtk2hs rc btw. It tells me "You must be logged in as an Administrator when installing this program."
09:29:50 <dcoutts_> pgavin: I think there's a innosetup option you can set in the .iss file to say that it does not need admin access.
09:51:02 <vixey> @unpl (\x y -> y >>= \e -> map (++ e) x)
09:51:02 <lambdabot> (\ x y -> y >>= \ e -> map (\ a -> a ++ e) x)
09:51:33 <Deewiant> @redo (\ x y -> y >>= \ e -> map (\ a -> a ++ e) x)
09:51:33 <lambdabot> (\ x y -> do { e <- y; map (\ a -> a ++ e) x})
09:53:22 <dcoutts_> dons: you were asking about version ranges the other day. Cabal version ranges are very general with intersection and union. What kind of ranges can arch express? Can it do ranges like >=1 && <2 ?
09:54:09 <dcoutts_> dons: I think there's a general need for a subset that expressible in most distro package formats.
10:00:00 <ziman> @undo do { x <- xs; y <- ys; zs; as; return (x, y) }
10:00:00 <lambdabot> xs >>= \ x -> ys >>= \ y -> zs >> as >> return (x, y)
10:00:23 <ziman> @undo do { (x:_) <- xs; return x }
10:00:23 <lambdabot> xs >>= \ a -> case a of { (x : _) -> return x; _ -> fail ""}
10:01:25 <edwardk> when did undo pick up the explicit fail stuff? or has it always done that correctly?
10:01:45 <ddarius_> It's always done that.
10:01:49 <edwardk> ah nice
10:02:07 <edwardk> i guess i just avoid writing stuff that can fail =)
10:05:13 <gubagem> I can tell you all this, as a haskell neophyte, working the maybe monad to take the return value of Data.Map made me extend my idea of an exception from an error to being able to make it so no error was apparent
10:05:33 <opqdonut> ?
10:06:42 <gubagem> i have state in a hash(Data.Map) it had to return some monad, i used Maybe, and had it add a new kvp to the hash if the key wasnt already there
10:08:03 <mercury^> < vixey> mercury looks good
10:08:05 <bd_> Note that data.map is a binary (AVL) tree, not a hash
10:08:07 <mercury^> thanks for noticing
10:10:14 <zachk> bd_: I noticed that, but it works like a hash for me
10:11:23 <Saizan_> bd_: size-balanced actually
10:12:13 <bd_> hm, I thought it was AVL at some point? maybe it's changes
10:12:14 <bd_> changed*
10:12:20 <dolio> There's an AVL tree map on hackage.
10:12:35 <dolio> Possibly more than one.
10:14:06 <vixey> > let x = [1,2,3] ; y = "abc" in concatMap (\x' -> map (\y' -> (x',y')) y) x
10:14:09 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
10:16:03 <Yoric[DT]> I have a vocabulary question.
10:16:28 <Yoric[DT]> Is it correct to call Typeable "an implementation of dynamic type information"?
10:16:37 <Yoric[DT]> (or just "dynamic typing")
10:16:56 <Yoric[DT]> That is, Data.Typeable.
10:17:54 <edwardk> I always viewed it as run time type identification, but thats my c++ background showing.
10:18:23 <Yoric[DT]> Well, I nearly wrote RTTI.
10:18:33 <Yoric[DT]> But I figured that wouldn't do in a theory paper:)
10:18:37 <edwardk> hah
10:18:49 <dolio> Data.Dynamic is more like the dynamic typing thing.
10:18:58 <dolio> But, of course, it's based on Data.Typeable.
10:19:18 <edwardk> Data.Typeable associates type representations with types.
10:19:20 <Yoric[DT]> So how should I describe Data.Typeable in two words?
10:19:28 <Yoric[DT]> "Type representations"?
10:19:28 <zachk> > do {y<-[1..3];x<-['a'..'b'];return (y,x)}
10:19:29 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
10:20:15 <edwardk> type reflection?
10:20:25 <dolio> > (,) <$> [1..3] <*> "abc"
10:20:26 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
10:20:27 <zachk> ooops
10:20:34 <Yoric[DT]> Mmmhhh.... ok.
10:20:46 <Yoric[DT]> Dynamic type reflection, then.
10:21:00 <zachk> dolio you totally just 0wn3d me
10:21:13 <RayNbow> @djinn (b -> c) -> (b -> c') -> (b -> (c, c'))
10:21:14 <lambdabot> f a b c = (a c, b c)
10:21:54 <edwardk> @type (&&&)
10:21:55 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:22:03 <RayNbow> :)
10:22:19 <dolio> We need linear djinn.
10:22:26 <dolio> That will complain at you for that.
10:22:47 <RayNbow> dolio: could you elaborate?
10:23:31 <dolio> That uses c twice.
10:24:04 <vixey> yes
10:24:07 <edwardk> dolio: yeah but thats perfectly fine given what its doing
10:24:12 <vixey> linear type syntax first
10:24:32 <vixey> make it good enough for general purpose programming too :D
10:24:39 <dolio> Good idea. :)
10:24:57 <edwardk> @djinn (b -> c) -> (b -> c') -> b -> b -> (c,c')
10:24:57 <lambdabot> f a b c _ = (a c, b c)
10:25:07 <edwardk> now that one, that you could make a case for ;)
10:25:56 <vixey> so..
10:26:19 <edwardk> vixey: the problem with linear/relevant/affine/uniqueness typing is that they really tend to muck up your type signatures quite a bit. You run out of symbols fast =)
10:26:27 <vixey> how do I prove that (x',y')`elem`(do x' <- x ; y' <- y ; return (x',y')) given that x' in x and y' in y?
10:27:09 <vixey> I don't even understand linear properly.. let alone relevant, affine and uniquen
10:28:54 <dolio> Wait, there's 4?
10:29:32 <vixey> it says here in my book...
10:29:48 <edwardk> dolio: yeah, was a result i had a year or two back, you have to think about the modalities as 'forward and backwards facing' in time to see uniqueness as distinct from linearity
10:30:07 <edwardk> uniqueness is a promise that you haven't contracted or weakened yet, linearity is a promise that you won't do so.
10:30:08 <dolio> Ah, okay. I guess that gives you enough axes.
10:30:55 <edwardk> you can use temporal modal necessity and possibility to model the full lattice of restrictions and put uniqueness in the same type system with the others.
10:31:03 <dolio> And I guess some rule themselves out.
10:31:07 <edwardk> yeah
10:31:22 <edwardk> you can't have weakened' a term that you disallowed contraction on, and still have it around =)
10:31:37 <dolio> Like, you haven't dropped all references to something in the past is obvious.
10:31:44 <edwardk> yep
10:32:18 <edwardk> so when you put the modalities together you get a lattice, turns out that the lattice is separable into two parts, and you can assign a clear operational meaning to the various lattice transitions
10:33:03 <edwardk> one axis tells you if it is necessarily 'relevant' (or you can try to model that with strictness analysis to get a tighter type), which tells you if you should evaluate it strictly in an operational sense
10:33:34 <RayNbow> edwardk, dolio, where can I read more about this type stuff?
10:33:39 <RayNbow> (does TAPL cover it?)
10:33:57 <dolio> I don't know. I've just heard edwardk mutter about it in the past and picked up bits and pieces.
10:34:02 <RayNbow> heh
10:34:06 <edwardk> the other tells you 'who knows about it', uniqueness says its yours and yours alone, modify as you will, unrestricted says it may have been shared,
10:34:16 <EvilTerran> i don't think tapl talks about uniqueness types
10:34:19 <dolio> Oh, Wadler has an intro paper to linear typing that's decent.
10:34:23 <EvilTerran> i may be mistaken, tho, if it's near the back
10:34:24 <edwardk> then you have one more node which is a guarantee that you will never share it. moving from unrestricted to linear requires copying usually from an operational perspective, but lifting from uniqueness to linear works fine
10:34:27 <vixey> ATTAPL does
10:34:32 <vixey> TAPL does not
10:34:40 <edwardk> evil: actually its attapl, but attapl only talks about linearity not uniqueness
10:34:47 * RayNbow adds more entries to his To Read list
10:34:51 <EvilTerran> ok
10:35:03 <edwardk> uniqueness exists online in only a couple of papers, one a ph.d dissertation that was quite good on a variation on the clean type system
10:35:14 * EvilTerran has the remaining half of TaPL and all of ATTaPL on his reading list already
10:35:40 <edwardk> vixey: david walker's article in attapl only covers linear, relevant, affine, unrestricted.
10:35:50 <edwardk> it may hit ordered as well i don't recall
10:36:00 <EvilTerran> and i keep trying to put TaPL on all my friends' reading lists, too - "you should read this, it's brilliant" kinda thing :P
10:36:09 <edwardk> heh
10:36:36 <vixey> ATTAPL is really hard though...
10:36:39 <RayNbow> ToDo and related lists: lists that tend to grow faster than that they shrink... :p (ah well, at least the list consumer won't get hungry :p)
10:36:56 <EvilTerran> david walker's in ATTaPL? that's cool, he does lectures for us :D
10:36:57 <vixey> and the code is missing :(
10:38:13 * EvilTerran has also had lectures from Richard Bird
10:38:51 <edwardk> vixey: regarding the earlier proof. here is part of it: do x <- x'; y <- y'; return (x', y') = x >>= \x' -> y >>= \y' -> return (x',y') = x >>= \x' -> fmap ((,)x') . y = x >>= \x' -> strength x' . y.  -- you can open up the first bind and walk through from the definition to get the rest of the way there
10:39:13 <edwardk> but the strength there shows that you are just sticking some x's next to every element of y.
10:40:05 <EvilTerran> i hear he's retiring from lecturing this year, though - i hope he'll keep writing
10:40:55 <vixey> oh I like it .. if I could parameterize the proof on strength, maybe it could work for ++ and interleave and others..
10:41:52 <vixey> infact it should work for any f :: a -> a -> b.. shouldn't it ?
10:41:53 <vixey> aoeu
10:41:56 <edwardk> also: part of the proof has to come from the fact that y is not empty because you have y' \in y.
10:47:58 <mc__> I'm eager to learn Haskell and I've finally set up the environment. There a lot of Tutorials out there. Could recommend me a certain one?
10:49:05 <dons> ?google yet another haskell tutorial
10:49:06 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
10:49:08 <muhtimin> i enjoyed this one http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
10:49:11 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
10:49:50 <lament> that one is probably fun if you know scheme
10:49:59 <lament> probably less fun if you don't
10:53:48 <edwardk> mc: the real world haskell book is quite good and has drafts online
10:54:33 <edwardk> mc__: http://book.realworldhaskell.org/beta/index.html
10:54:37 <lambdabot> Title: Real World Haskell
10:55:52 <dons> oh, that's an option i should recommend more often :)
10:56:02 <dons> and its not too late to submit feedback
10:56:24 <mc__> edwardk: Thank you for your advice.
10:57:56 <edwardk> dons: heh
10:58:23 <edwardk> mc__: if you have any trouble understanding it you have the advantage that you can yell at the authors right here on channel. ;)
11:04:29 <maltem_> Has anyone ever experienced that threadDelay simply does not sleep?
11:04:50 <maltem_> Because that's what it does for me.
11:05:04 <Saizan_> maltem_: the input is in microseconds
11:05:22 <maltem_> right, even when I put huge numbers in there
11:05:27 <edwardk> maltem: how long of a nap are you trying to get?
11:05:33 <monochrom> It has always slept for me.
11:05:58 <monochrom> It has always slept with me, but that's another story. <duck>
11:06:10 <mc__> edwardk: thats good to know, I also like the their approach of publishing the book onine for free
11:06:11 <maltem_> threadDelay 20000 >> print 5 -- will instantly print 5 for me
11:06:24 <monochrom> 20 milliseconds is a long time. :)
11:06:35 <maltem_> oh damn
11:06:42 <maltem_> microseconds, not milliseconds
11:06:59 <edwardk> dons: speaking of publishing the book, is there an approximate target publish date?
11:07:20 * edwardk really should pre-order it.
11:07:42 <maltem_> monochrom etc., thanks :)
11:08:13 <vixey> this is too hard for me :S
11:08:26 <edwardk> vixey: the proof?
11:08:30 <vixey> yes
11:09:01 <vixey> I thought about proving the fst is always there, and the snd is always there, but that's too hard as well
11:09:19 <edwardk> vixey: rough synopsis, start where i left off, then show that you are getting a concatenation of a bunch of lists, then show that the lists are non-empty and that each x is in it and that each y is in it.
11:09:35 <vixey> I think it's because the result (list of tuples) is a 2D thing, but it's stored 1D
11:09:56 <vixey> oh I see
11:10:33 <edwardk> work through the >>= step by step. you can rewrite it in terms of Cons a as >>= k = k a ++ (as >>= k); Nil >>= k = Nil
11:10:37 <MyCatVerbs> maltem_: just, put a 10^5 in there, save yourself writing out all the zeroes. :)
11:10:44 <edwardk> you know your base case has a Cons because x is non-empty
11:11:10 <maltem_> MyCatVerbs: sure
11:11:16 <edwardk> and you know that your individual lists from k are non-empty because y is non-empty and you are just fmapping over it
11:11:24 <edwardk> so you just need to go through and do the details
11:11:35 <vixey> cool
11:11:48 <edwardk> that said, I have to drive half way across the state in the next 20 minutes, so i need to go. good luck =)
11:12:00 <vixey> bye, thank you
11:12:09 <edwardk> fortunately its vertically, and massachusettes is 'short' =)
11:12:16 <mrd> hah
11:12:17 <edwardk> er massachusetts
11:12:25 <mmorrow> masshole!
11:12:32 <mmorrow> :)
11:12:34 <edwardk> =)
11:12:56 <edwardk> i'm newly integrated i have yet to pick up the full set of masshole traits.
11:13:57 <pgavin> dcoutts: are you running vista, or just as a limited user under XP?
11:13:58 <mmorrow> heh
11:24:51 <RayNbow> hmm, has anyone activity graphs of hackage?
11:26:11 <EvilTerran> there's a little one by "recent package updates" on the haskell.org frontpage
11:26:32 <EvilTerran> aaand clicking on that takes you to *another* little one: http://haskell.org/haskellwiki/Hackage_statistics
11:26:33 <lambdabot> Title: Hackage statistics - HaskellWiki
11:27:07 <RayNbow> ah, thanks :)
11:29:20 <Saizan_> 5/win 23
11:31:33 <jaj> is there already a plan as to when Real World Haskell is due?
11:32:21 <dons> soon! by christmas we expect. surely earlier
11:32:35 <dons> you can preorder on amazon now, in fact
11:33:41 <jaj> oh right, I didn't know you could preorder it
11:33:49 <jaj> even on amazon.fr
11:34:13 <jaj> I'm going to do it right now ;)
11:35:12 <maltem_> I noticed that compiling with -threaded increases the number of threads a program uses by 2. Are those for threading management and garbage collection, respectively?
11:35:28 <dons> maltem_: one is the IO manager thread
11:35:37 <bd_> and also a signal thread I think
11:35:38 <dons> which handles the support for non-blocking IO and so on
11:36:17 <jaj> dons: my preorder is placed ;)
11:36:23 <bos_> i love all the interest the RWH chapter announcements get on reddit.
11:36:25 <dons> hehe.
11:36:43 <maltem_> ah ok
11:36:43 <lament> so is all the haskell stuff going to be on the programming reddit or the compsci reddit?
11:36:44 <dons> bos: this northern hemisphere summer reading season is new to me.
11:36:48 <dons> good stuff though
11:37:00 <dons> lament: bah, sub-sub-reddits are doomed to failure, imo
11:37:01 <bos> lament: nobody reads the compsci reddit.
11:37:42 <mrd> maltem_: don't forget to use +RTS -N <n-threads>
11:38:48 <RayNbow> bos: is it possible to get an RSS comments feed that only contains comments on the RWH beta chapters?
11:39:03 <bos> RayNbow: all the chapters are beta chapters now.
11:39:55 <maltem_> mrd: right, I was just wondering what goes into the extra threads
11:40:02 <RayNbow> http://book.realworldhaskell.org/feeds/comments/ <-- the links in this feed refer to http://book.realworldhaskell.org/alpha/... which I can't access :p
11:42:37 <xerox> RayNbow: try /beta/
11:44:31 <bos> RayNbow: oh, i see.
11:46:04 <sclv> oh man. concurrency and ffi FTL
11:46:13 <bos> sclv: ?
11:46:33 <sclv> I'm running into obscure issues with HDBC.Postgresql with multithreading.
11:46:40 <bos> ooh.
11:46:52 <bos> that kind of thing is usually easy to fix.
11:47:11 <sclv> right -- something's getting freed that shouldn't be or etc.
11:47:45 <sclv> Its hard to pin down exactly what though -- sometimes I get exceptions, sometimes it just dies, etc.
11:47:47 <bos> the joy of the FFI is debugging your haskell code as if it was C.
11:48:00 <sclv> right -- with multithreading.
11:48:12 <bos> and a pony.
11:48:25 <sclv> oh and since its a db interface sometimes everything just gets all screwy and the locks and hangs.
11:48:35 <sclv> everything is golden with one thread though, at least.
11:49:12 <sclv> So if one of my more useful stacktraces goes to this: HDBCzmpostgresqlzm1zi1zi4zi0_DatabaseziHDBCziPostgreSQLziStatement_zdwccall1_info ()
11:49:29 <sclv> then that's obviously a ccall in HDBC.PostgreSQL.Statement
11:49:39 <sclv> does the _info() bit mean anything?
11:49:43 <bos> beautiful, gmail is advertising treatments for dog bite injuries in a thread relating to high performance haskell.
11:50:17 <bos> haskell: for when you absolutely, positively, must have savage performance.
11:51:43 <bos> RayNbow: link should be fixed now.
11:52:26 <sclv> oh, and to add more pain, there's some sort of refcounting inserted in the helper c file for conditional finalization.
11:52:40 <hackage> New hackage package: AGI 1.1.1
11:52:40 <hackage> New hackage package: hxt 8.1.0
11:52:40 <hackage> New hackage package: Pugs 6.2.13.3
11:52:41 <hackage> New hackage package: pugs-compat 0.0.4
11:52:43 <hackage> New hackage package: ghc-paths 0.1.0.1
11:52:51 <sclv> so I'm just really unsure how to narrow down the bug further, and I'm not exactly a C memory/concurrency guru.
11:53:03 <sclv> and I don't trust lots of elements of the logic here.
11:53:09 <Botje> hackage: hi there!
11:53:23 * sclv is tempted to scrap some things and start again with takusen.
11:53:24 <Botje> is the source for hackage available somehwere?
11:53:40 <dons> Botje: its the generic rss2irc gateway, on hackage.
11:53:48 <Botje> ah
11:53:50 <Botje> thanks!
11:53:58 <Botje> i'll take a look at it then, looks cool
11:54:24 <sclv> any particular advice for me, vis a vis hunting this sort of thing down?
11:54:38 <Botje> walk softly and carry a big lambda
11:54:56 <kiris> λ_λ
11:55:23 <RayNbow> bos: http://book.realworldhaskell.org/feeds/comments/ here still refers to alpha pages?
11:56:26 <bos> RayNbow: it will probably be a few minutes before it "takes". i didn't bounce apache.
11:56:40 <RayNbow> ah
11:59:27 <pgavin> @tell dcoutts_ I've fixed the admin rights thing (I think)
11:59:28 <lambdabot> Consider it noted.
11:59:41 <mc__> the way "Real world Haskell" is written reminds me of "Practical Common Lisp"
11:59:49 <sclv> aha! in the meantime, if I just scap db connection pooling and initiate a connection per request, everything manages to do ok. which is much better than singlethreading, at least.
11:59:53 <pgavin> @tell dcoutts_ the new one is gtk2hs-0.9.13-rc2.exe
11:59:53 <lambdabot> Consider it noted.
12:01:43 <bos> mc__: i haven't read practical common lisp, but i know peter siebel.
12:01:43 <bos> RayNbow: definitely fixed now. i gave apache a bonk on the head.
12:01:54 <RayNbow> poor Apache :p
12:02:05 <sclv> anyway, yeah, I heart everything about haskell except having to talk to anything else.
12:03:34 <pgavin> lol@haskell-hall
12:06:19 <bos> haskell hall, where we nerve-gas the mice.
12:07:50 <pgavin> lol
12:08:21 <monochrom> Since haskell-hall is "freely open", may I advocate my RTFM attitude there? :)
12:08:41 <pgavin> it's pretty dumb to try and fork a mailing list over something stupid like that
12:09:43 <pgavin> monochrom: I guess if people want to rag on PHP, that would be where to do it
12:09:56 <pgavin> they should've made it haskell-flamefest@live.com
12:10:27 <monochrom> Was Stanley really moderated on haskell-cafe?
12:10:36 <pgavin> no, I don't think so
12:10:50 <byorgey> I think he actually was
12:10:53 <pgavin> I think he just got pissed that other people thought he was being inappropriate
12:11:18 <byorgey> dons said he was going to moderate him, at least
12:11:41 <pgavin> it's also silly because the PHP guys came to *us* for advice on improving their language
12:11:45 <pgavin> then he crapped all over them
12:11:48 <monochrom> I would like to know what posts of him were actually blocked. I mean just the essence of them.
12:12:53 <byorgey> I think they went something like '**** you, you ****ing Hitler, don't tell me what I can't do or I'll ****ing cap you'
12:13:33 <RayNbow> <pgavin> it's also silly because the PHP guys came to *us* for advice on improving their language <-- what did I miss? :)
12:13:43 * RayNbow wants to know all the juicy details :p
12:14:17 <pgavin> RayNbow: one sec, I'll post a link
12:14:36 <pgavin> http://article.gmane.org/gmane.comp.lang.haskell.cafe/41486
12:14:38 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:18:11 <byorgey> RayNbow: pgavin's link isn't even the half of it though.  if you really want all the juicy details you have to read the whole thread.
12:18:31 <pgavin> byorgey: indeed
12:19:12 <monochrom> Freedom is double-edged. While one has the freedom to say "PHP sucks", another has the freedom to say "shut up" too. Neither is being Hitler. However, whoever calls the other "Hitler" is the true Hitler.
12:19:25 <lament> hitler!
12:19:29 <pgavin> no yuo
12:19:45 --- mode: ChanServ set +o sjanssen
12:19:47 <RayNbow> byorgey: I started at the first message of the thread :)
12:19:52 <sjanssen> lament: hitler times two! :P
12:19:56 <bd_> monochrom: so in other words, you're hitler?
12:20:13 <monochrom> He who has op is the true... please don't ban me! :)
12:20:22 <pgavin> there are better ways to tell someone that their language (or whatever project) has problems than that
12:20:26 <vixey> Is there anything that isn't the fixpoint of a sum of products?
12:21:05 <pgavin> vixey: isn't that an overly general question?
12:21:10 --- mode: ChanServ set -o sjanssen
12:21:21 <byorgey> vixey: battleships
12:21:32 <pgavin> exactly
12:21:33 <byorgey> also pizza
12:21:41 <pgavin> and hitler too :)
12:21:51 * vixey goes on a digression to inerpret battleships as a sum of products
12:22:04 <RayNbow> :t orderPizza
12:22:05 <lambdabot> Not in scope: `orderPizza'
12:22:09 <RayNbow> bah
12:22:17 <RayNbow> lambdabot doesn't have the delicious Pizza package?
12:22:51 <Saizan_> vixey: functions?
12:23:14 <vixey> functions are just products
12:23:30 <vixey> relations (as in logic programming) are sums of products
12:23:48 <byorgey> > orderPizza
12:23:50 <lambdabot>  Pepperoni-lambda, coming up!
12:24:01 <pgavin> so recursive relations are fixpoints of sums of products?
12:24:56 <vixey> assuming that flattening and-or trees is equivalent to multiplying out equations, yes
12:25:07 <monochrom> recursive relation is fixpoint of sum-of-product transformer
12:26:30 <monochrom> Whenver you have recursive ___, there are two things you have to do. First is use fixpoint. Second is you have to go one order up.
12:26:33 <vixey> Saizan: maybe they are sums of products actually, but you can only sum distinct things i.e. Left x = .. and Right x = .., but not True = .., True = .. and False = ..
12:26:40 <RayNbow> :t orderPizza
12:26:42 <lambdabot> forall a. Sym a
12:26:43 <pgavin> monochrom: right
12:26:48 <RayNbow> Sym a?
12:27:15 <monochrom> Example.  zeroes = 0 : zeroes.  Recursive list.  It is fix (\x -> 0:x).  fixpoint of list transformer \x -> 0:x
12:28:30 <monochrom> Example.  f x = f (x+1).  (Nevermind that it's an infinite loop.)  Recursive function.  It is fix (\g -> \x -> g (x+1)).  Fixpoint of function transformer.
12:29:36 <pgavin> I like to think about fix like this:   fix f x => letrec f x = ... f ... x ...
12:29:52 <pgavin> err, fix \f x -> ... I mean
12:30:14 <monochrom> Yes, I do that too.
12:31:40 <RayNbow> byorgey, how did you define orderPizza?
12:34:47 <HunterXHunter> > iterate (2*) 1
12:34:49 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:35:09 <HunterXHunter> > iterate (2*) x
12:35:10 <lambdabot>  [x,2 * x,2 * (2 * x),2 * (2 * (2 * x)),2 * (2 * (2 * (2 * x))),2 * (2 * (2 *...
12:35:55 <vixey> letrec ? weird
12:36:06 <pgavin> not if you learned scheme first :)
12:36:48 <pgavin> > fix \f x -> x : f (2 * x)
12:36:49 <lambdabot>  Parse error at "\f" (column 5)
12:37:00 <pgavin> > fix $ \f x -> x : f (2*x)
12:37:02 <lambdabot>  <Integer -> [Integer]>
12:37:21 <pgavin> > ( fix $ \f x -> x : f (2*x) ) 1
12:37:23 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:37:42 <pgavin> not as pretty as iterate :)
12:37:48 <HunterXHunter> > ( fix $ \f x -> x : f (2*x) ) x
12:37:50 <lambdabot>  [x,2 * x,2 * (2 * x),2 * (2 * (2 * x)),2 * (2 * (2 * (2 * x))),2 * (2 * (2 *...
12:37:57 <HunterXHunter> :P
12:40:36 <vixey> @let pairs x y = do u <- x ; v <- y ; return (u,v)
12:40:36 <lambdabot> Defined.
12:40:46 <vixey> @let append = uncurry (++)
12:40:46 <lambdabot> <local>:7:17:     Ambiguous type variable `a' in the constraint:       `Monoi...
12:41:07 <vixey> > map (uncurry (++)) (pairs "abc" [1,2,3])
12:41:08 <lambdabot>   add an instance declaration for (Num Char)
12:41:08 <lambdabot>     In the expression: 1
12:41:22 <sjanssen> Caleskell fail
12:41:36 <pgavin> vixey: pairs is just zip
12:41:44 <pgavin> though more general
12:41:57 <Botje> 'a' ++ 1 is very likely to fail, yes
12:41:59 <sjanssen> pgavin: no, it isn't zip
12:41:59 <vixey> sjanseen: Really?
12:42:06 <pgavin> sjanssen: ah, you're right
12:42:14 <vixey> sjanseen: I don't think it's Cales fault
12:42:15 <pgavin> it's a product :)
12:42:22 <vixey> > map (uncurry (++)) (pairs (map return "abc") (map return [1,2,3]))
12:42:23 <lambdabot>   add an instance declaration for (Monoid (m Char))
12:42:36 <sjanssen> vixey: your definition of append would work if (++) was the Prelude version
12:42:41 <vixey> > map (uncurry (++)) (pairs (map (return.return) "abc") (map (return.return) [1,2,3]))
12:42:42 <lambdabot>        add an instance declaration for (Monoid (m (m1 Char)))
12:43:20 <vixey> > map (uncurry (++)) (pairs "abc" "xyz")
12:43:20 <lambdabot>   add an instance declaration for (Monoid Char)
12:43:27 <vixey> I don't get this...
12:43:39 <pgavin> > map (uncurry (Prelude.++)) (pairs "abc" "xyz")
12:43:40 <lambdabot>   Not in scope: `Prelude.++'
12:43:44 <Deewiant> you're still trying to do 'a' ++ 'x'
12:43:47 <vixey> @let append x y = (uncurry (++)) x y
12:43:48 <lambdabot> Defined.
12:43:55 <vixey> @let append' = (uncurry (++))
12:43:56 <lambdabot> <local>:8:19:     Ambiguous type variable `a' in the constraint:       `Monoi...
12:44:01 <Deewiant> > map (\(a,b) -> [a] ++ [b]) (pairs "abc" "xyz")
12:44:02 <lambdabot>  ["ax","ay","az","bx","by","bz","cx","cy","cz"]
12:44:10 <sjanssen> vixey: monomorphism restriction.
12:45:08 <Deewiant> > map (uncurry (Prelude.++)) (pairs (map return "abc") (map return "xyz"))
12:45:08 <lambdabot>   Not in scope: `Prelude.++'
12:45:22 <sjanssen> Deewiant: P.++
12:45:27 <shepheb> anyone have a link to info about the ARM back-end for jhc?
12:45:27 <Deewiant> > map (uncurry P.++) (pairs (map return "abc") (map return "xyz"))
12:45:28 <lambdabot>  Couldn't match expected type `[a]'
12:45:32 <Deewiant> cheers
12:45:42 <vixey> > map (uncurry (++)) (pairs (map return "abc") (map return "xyz"))
12:45:43 <lambdabot>   add an instance declaration for (Monoid (m Char))
12:45:56 <Deewiant> hmm
12:46:00 <vixey> > map appen (pairs (map return "abc") (map return "xyz"))
12:46:01 <lambdabot>   Not in scope: `appen'
12:46:04 <Deewiant> > pairs (map return "abc") (map return "xyz")
12:46:04 <lambdabot>        add an instance declaration for (Show (m1 Char), Show (m Char))
12:46:16 <Deewiant> > pairs (map return "abc") (map return "xyz") :: [([String],[String])]
12:46:17 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
12:46:24 <Deewiant> > pairs (map return "abc") (map return "xyz") :: [(String,String)]
12:46:25 <lambdabot>  [("a","x"),("a","y"),("a","z"),("b","x"),("b","y"),("b","z"),("c","x"),("c",...
12:46:54 <vixey> > map (uncurry (++)) (pairs (map return "abc") (map return "xyz") :: [(String,String)])
12:46:55 <lambdabot>  ["ax","ay","az","bx","by","bz","cx","cy","cz"]
12:46:59 <vixey> > map (uncurry (++)) (pairs (map return "abc") (map return "xyz"))
12:47:00 <lambdabot>   add an instance declaration for (Monoid (m Char))
12:47:06 <vixey> weird..
12:47:12 <Deewiant> no, it's right
12:47:16 <vixey> I think that IS a problem with ++ = mappend
12:47:18 <Deewiant> it can't know which monad you meant
12:47:30 <Deewiant> just use (:[]) in place of return
12:47:40 <vixey> > (map (uncurry (++)) (pairs (map return "abc") (map return "xyz"))) :: [String]
12:47:41 <lambdabot>  ["ax","ay","az","bx","by","bz","cx","cy","cz"]
12:47:42 <Deewiant> > map (uncurry (++)) (pairs (map return "abc") (map (:[]) "xyz"))
12:47:43 <lambdabot>  ["ax","ay","az","bx","by","bz","cx","cy","cz"]
12:47:48 <vixey> oh actually it's not
12:48:44 <Deewiant> > map (uncurry (++)) (pairs (map return "abc") (map return "xyz") :: [(Maybe Char,Maybe Char)])
12:48:45 <lambdabot>   add an instance declaration for (Monoid Char)
12:51:40 <paolino> how do I convert from Ratio Int to real truncating at n digits after decimal point?
12:52:26 <paolino> well approximating, better
12:52:31 <hackage> New hackage package: debian 1.2.1
12:53:06 <vixey> ... debian is written in haskell?
12:53:26 <pgavin> paolino: realToFrac (x%y) :: Double
12:53:26 <siponen> Nice.
12:53:43 <Snark> vixey, not yet
12:53:47 <pgavin> then trunc?
12:54:01 <pgavin> paolino: that will only give you limited precision though
12:54:17 <cjb> vixey: those are Linspire's packages, they do a lot in Haskell
12:54:19 <paolino> pgavin: where are defined these ?
12:54:22 <pgavin> which is ok I guess given you're using Ratio Int and not Ratio Integer
12:54:30 <pgavin> :t realToFrac
12:54:32 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:54:41 <pgavin> paolino: prelude
12:55:16 <paolino> > realToFrac (9 % 20)
12:55:17 <lambdabot>  0.45
12:55:39 <paolino> :i Real
12:55:47 <pgavin> paolino: if you use trunc you'll have to e.g. multiply by 10^n, then trunc, then divide by 10^n
12:55:58 <paolino> @index Real
12:55:58 <lambdabot> Prelude
12:55:58 <pgavin> but you'll lose precision with that too :)
12:56:18 <pgavin> paolino: it's a standalone function
12:56:23 <pgavin> @src realToFrac
12:56:23 <lambdabot> realToFrac = fromRational . toRational
12:56:28 <dons> http://www.reddit.com/info/6omnz/comments/
12:56:28 <lambdabot> Title: reddit.com: SoCal FP Group launched: Get your lambdas in the Sun
12:56:29 <paolino> :t trunc
12:56:30 <lambdabot> Not in scope: `trunc'
12:56:39 <pgavin> hmm
12:56:41 <pgavin> :t truncate
12:56:43 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:57:39 <dons> we've got the west coast covered now, SoCalFP, BayFP, PDXFunc, and SeattleFPG
12:57:51 <pgavin> now we just need to work on the east coast
12:57:58 <pgavin> I guess we're not as progressive over here :)
12:58:12 <hellige> and the midwest...
12:58:38 <pgavin> I guess NY has some stuff going on but that's still far from me :)
12:59:02 <hellige> i wish somebody less busy than myself would organize a chiFP.
12:59:08 <dons> well, you've got NYFP, DCFP, and Boston
12:59:36 <pgavin> how about AtlFP or TampaFP or JAXFP?
12:59:43 <dons> oh, and AustinFP
12:59:50 <mmorrow> @pl \(a,b)->(b,a)
12:59:51 <lambdabot> uncurry (flip (,))
12:59:52 <pgavin> when is Austin?
13:00:00 <dons> West Coast, East Coast, and Southern?
13:00:10 <dons> http://leibnizdream.wordpress.com/2007/12/22/new-austin-functional-programmers-group-in-2008/
13:00:10 <mmorrow> ooh, when in Austin?
13:00:11 <lambdabot> Title: New Austin Functional Programmers Group in 2008  Chance Coble, http://tinyurl.com/6j6et2
13:00:32 <mmorrow> sweer
13:00:35 <mmorrow> s/r/t/
13:01:22 <pgavin> I'my trying to get a TallyFP going :)
13:01:29 <pgavin> I'm the only member as of yet
13:01:44 <mmorrow> what's a TallyFP
13:01:48 <mmorrow> ?
13:01:53 <pgavin> tallahassee, fl :)
13:02:09 <mmorrow> ah. so you *don't* live in austin then i take it...
13:02:13 <pgavin> no
13:02:26 <pgavin> family there though
13:02:30 <mmorrow> cool
13:02:32 <paolino> pgavin: the problem says to print exactly 7 digits after decimal point , and I have Ratio Int, all numbers are between 0 and 1
13:02:50 <pgavin> paolino: you should do long division :)
13:03:32 <pgavin> paolino: there's no library function to do that
13:03:32 <paolino> hand code it ?
13:03:35 <pgavin> ya
13:03:37 <pgavin> not haqrd
13:03:46 <BMeph> Has anyone else had a problem "caballing" the network package?
13:04:19 <dons> BMeph: nope.
13:04:28 <pgavin> isn't it already cabalized?
13:04:59 <dons> yep
13:05:55 <paolino> pgavin: surely harder to me then the graph search and statistic stuff to this point, here I have to think :d
13:06:59 <sjanssen> BMeph: do you mean "cabal install"ing?
13:07:12 <paolino> pgavin: is it an unfoldr ?
13:07:38 <pgavin> paolino: it could be :)
13:07:57 <pgavin> along with take
13:08:26 <pgavin> just assume the numerator is smaller than the denominator and go from there
13:08:27 <roconnor> > product [5..10] `div` product [1..5]
13:08:29 <lambdabot>  1260
13:08:51 <roconnor> > product [6..10] `div` product [1..5]
13:08:53 <lambdabot>  252
13:09:41 <BMeph> dons: Funny thing is, I just tried c-i'ing Pugs, and c-i, and each time it claims that it can't install network-2.2.0.0
13:10:01 <BMeph> sjanssen: Ah, yes, "c-i" == "cabal-install"
13:10:09 <pgavin> BMeph: is network installed with --user?
13:10:18 <pgavin> and you're trying to install Pugs with --global
13:10:58 * BMeph goes to check if network got installed with the --user option
13:11:10 <sjanssen> ghc-pkg list network
13:12:14 <BMeph> Looks like it's the other way around - Pugs was getting installed locally.
13:12:25 <dons> BMoh, i saw that too
13:12:34 <pgavin> hmm, wierd
13:14:26 <mjrosenb> fun, yi doesn't build on here
13:14:36 <paolino> @hoogle Int -> Char
13:14:41 <lambdabot> Data.Char.intToDigit :: Int -> Char
13:14:41 <lambdabot> Data.Char.chr :: Int -> Char
13:14:41 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
13:15:07 <pgavin> paolino: also toEnum
13:15:11 <BMeph> When I saw Pugs installing readline, I knew I was in for Bad News...
13:15:45 * BMeph works on a Ween-doze machine at work. He calls it "his occupational hazard."
13:16:23 <paolino> pgavin : head. show  ?
13:19:31 <fons> hi all
13:19:39 <BMeph> Hi, fons
13:20:25 <fons> I trying to use hooks in Cabal in order to process some data files after instalation (a vhdl file which I'd like to compile)
13:20:37 <fons> Thus, I'm trying to use postInst to do it
13:20:53 <fons> but the problem is ... how do I get the data-dir from postInst?
13:23:01 <fons> @seen dcoutts
13:23:02 <lambdabot> dcoutts is in #xmonad, #haskell, #haskell-overflow, #ghc, #haskell-soc and #gentoo-haskell. I last heard dcoutts speak 8h 28m 41s ago.
13:32:40 <EvilTerran> @where ops
13:32:40 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:32:46 <glguy> ?
13:32:47 <EvilTerran> time for the IRSeekBot to die again?
13:33:14 <glguy> interesting
13:33:50 <EvilTerran> unless you guys (the ops) decided to invite him in again, i suspect the freenode opers may find it equally interesting
13:34:11 <Plareplane> who's irseekbot
13:34:50 --- mode: ChanServ set +o glguy
13:34:50 --- mode: glguy set +d IRSeekBot
13:34:51 --- mode: ChanServ set -o glguy
13:35:04 <EvilTerran> Plareplane, IRSeek send bots into loads of IRC channels to provide logs for their log-searching site
13:35:04 --- mode: ChanServ set +o glguy
13:35:05 <lament> poor irseekbot gets so much hate
13:35:05 --- mode: ChanServ set -o glguy
13:35:36 <EvilTerran> without permission of anyone involved. and have been told off, banned, k-lined, etc wherever they have dared tread
13:35:40 <lament> if irseekbot comes here, it's probably because somebody gave permission for it to be here
13:35:44 <glguy> nope
13:36:03 <EvilTerran> i imagine that would be a joint decision of the ops, so glguy would know
13:36:04 <vincenz> glguy: what's +d
13:36:06 <glguy> * #haskell Banlist: Sat Apr 19 10:31:11 *!*@*irseek/log-bot/IRSeekBot ballard.freenode.net
13:36:16 <glguy> IRSeekBot isn't using it's cloak right now
13:36:17 <lament> i was asked by irseek stuff if they could put irseekbot in a channel i'm an op in
13:36:21 <glguy> so the ban wasn't working
13:36:31 <lament> *staff
13:36:46 <glguy> no op as come forward to say that they authorized such a bot
13:37:27 <sjanssen> why do we care whether the bot is here?
13:37:38 <EvilTerran> vincenz, "Deaf. Prevents the server from sending the user any channel text."
13:37:50 <sjanssen> #haskell is already publically logged in loads of places
13:37:52 <glguy> "
13:37:59 <glguy> +d is name ban
13:38:23 <EvilTerran> (according to http://webtoman.com/opera/panel/ircdmodes.html)
13:38:24 <lambdabot> Title: IRC Modes
13:38:42 <glguy> don't use those mode for Freenode
13:39:03 <EvilTerran> oh right. how does +d differ from +b, then?
13:39:23 <glguy> b is a nick!user@host ban
13:39:28 <glguy> d is a "real name" field ban
13:39:32 <EvilTerran> i see
13:39:45 <glguy> http://freenode.net/using_the_network.shtml
13:39:45 <lambdabot> Title: 691 freenode: using the network
13:39:49 <glguy> those are the modes to look at
13:40:03 <byorgey> sjanssen: at this point I think it's the principle of the thing, since they were so sneaky and underhanded about it the first time around
13:40:28 <byorgey> although I personally don't really care
13:42:49 <EvilTerran> glguy, thanks, that'll be good to keep handy
13:42:56 <Yoric[DT]> Does anyone know how much inlining ghc will perform?
13:43:25 <Yoric[DT]> That is, assuming I have     bind e \x.f
13:43:37 <Yoric[DT]> (with bind declared or inferred INLINE)
13:43:42 <MyCatVerbs> Inlining... the whole compiler? :D
13:43:47 <Yoric[DT]> :)
13:43:56 <MyCatVerbs> I think that does bad things to your instruction cache, but go wild!
13:44:09 <Yoric[DT]> will ghc manage to remove the abstraction?
13:44:46 <Yoric[DT]> Just being curious. At the moment, I'm don't even have a copy of ghc on the computer.
13:44:58 <Yoric[DT]> (well, I probably have one just in case but I haven't checked)
13:45:06 <EvilTerran> MyCatVerbs, that was mean :P
13:45:28 <hpaste>  morrow pasted "Text.Regex.PCRE.Light fiddling" at http://hpaste.org/8484
13:45:57 * EvilTerran cannot parse "bind e \x.f"
13:46:10 <MyCatVerbs> EvilTerran: yeah, I'm not actually a very nice person. Que sera, sera.
13:46:29 <EvilTerran> o.ó
13:46:41 <Yoric[DT]> EvilTerran: sorry, did I get the syntax wrong?
13:46:48 * MyCatVerbs sets EvilTerran's chin on fire.
13:47:01 <Yoric[DT]> Oh, sorry, confusing languages.
13:47:10 <Yoric[DT]> I meant "bind e
13:47:13 <Yoric[DT]> I meant "bind e \x f"
13:47:14 <MyCatVerbs> Yoric[DT]: well, it looks like a crazy mixture of Haskell and... Quake's scripting minilanguage? :D
13:47:23 <Yoric[DT]> Well, actually lambda-calculus :)
13:47:25 <MyCatVerbs> And also lambda-calculus notation.
13:47:32 <EvilTerran> that still doesn't make sense. \s need matching ->s
13:47:34 <mauke> I think you meant bind e $ \x -> f
13:47:40 <MyCatVerbs> It was the "bind e" that made me thing of Quake.
13:47:41 <Yoric[DT]> my bad
13:47:49 * Yoric[DT] is a bit tired.
13:47:59 * Yoric[DT] has been writing a paper for about 12h today...
13:48:10 <MyCatVerbs> Ahhh, no worries.
13:48:17 <EvilTerran> yes, a non-recursive function will usually be inlined fully by ghc -O2, iir
13:48:18 <EvilTerran> c
13:48:48 <Yoric[DT]> Even if it's in a not-completely-trivial typeclass?
13:49:05 <Yoric[DT]> (i.e. a typeclass which does require a run-time dictionary)
13:49:14 <EvilTerran> in that case, presumably not
13:49:23 <MyCatVerbs> Depends mainly on how big it is, no?
13:49:51 <Yoric[DT]> But usually, for a short bind function, the compiler won't have to introduce an abstraction, am I correct?
13:49:58 <MyCatVerbs> Lots of pain involved in inlining \a -> f . g . h . i . j ... . z.
13:50:47 <EvilTerran> i believe, in the vast majority of cases, a run-time dictionary is not needed
13:52:01 <Yoric[DT]> Yeah, "not-completely-trivial" was actually a large overstatement, my bad.
13:52:09 * Yoric[DT] did mention that he's tired, didn't he?
13:52:31 <EvilTerran> iirc, that's generally only necessary for strange stuff like existentials and recursion between two different instances
13:52:46 <MyCatVerbs> Yes. We get it. We are prepared to ignore small indiscretions, and maybe some large ones too.
13:53:11 <dcoutts> fons: ping
13:53:12 <Yoric[DT]> Well, from what I understand, recursion between different instances is rather common stuff, isn't it?
13:53:22 <Yoric[DT]> At least from the samples I read:)
13:53:23 <fons> hi dcoutts
13:53:30 <EvilTerran> i mean recursion back-and-forth or something odd like that
13:53:33 <fons> I had some problesm with cabal hooks
13:53:34 <Yoric[DT]> ok
13:53:34 <MyCatVerbs> Just how large is still a matter of debate. Perhaps you might care to slaughter a few mafia members and hang their corpses up in public, see whether we'll forgive it or not. All in the interests of science, of course.
13:53:47 <quicksilver> straight forward recursion need not break inlinging.
13:53:52 <EvilTerran> <_<
13:53:56 <Yoric[DT]> MyCatVerbs: I can't, it's impure and I don't have a monad for that.
13:54:01 <fons> but I think I'm on the way to solve them, just one question, what is dataSubDir?
13:54:09 <quicksilver> just because the Foo instance for (a,b) uses the Foo instances for a and b doesn't meant all three can't get inlined and the dictionary eliminated.
13:54:15 <Yoric[DT]> ok
13:54:31 <quicksilver> but the inlining is the key
13:54:39 <dcoutts> fons: for the data files dir there is two bits, datadir and datasubdir the full path is datadir </> datasubdir
13:54:44 <EvilTerran> Yoric[DT]++ i lol'd
13:55:22 <Yoric[DT]> quicksilver: ok, thanks
13:55:34 <fons> dcoutts: that's what I thought, then the Paths_packagename.hs file is buggy (as of cabal 1.2.3) cause it only provides the datadir part
13:55:37 <dcoutts> fons: it's split this way because it lets us be compatible with autoconf where datadir gets set to something like /usr/local/share but then datsubdir defaults to the packagename </> compilerid or whatever
13:55:51 <MyCatVerbs> Yoric[DT]: offing the mob is already risky. Might as well go the whole hog and unsafePerformIO it too.
13:55:57 <Yoric[DT]> :)
13:56:25 <dcoutts> fons: no, it provides the two bits joined together
13:56:40 <dcoutts> fons: so it's just what you need at runtime
13:57:12 <Yoric[DT]> quicksilver, EvilTerran: is there any reference I could read on the inlining strategy of ghc?
13:57:20 <quicksilver> hmm
13:57:24 <quicksilver> maybe something on the wiki
13:57:33 <quicksilver> basically it's a fairly agressive size-based inliner
13:58:05 <fons> dcoutts: ok, than it's just confusing, because sometimes you call datadir to the whole thing and some others it refers to the prefix without datasubdir
13:58:12 <fons> s/than/then
13:58:27 <fons> dcoutts: thanks
13:58:34 <Yoric[DT]> quicksilver: ok
13:58:36 <dcoutts> fons: yep it's a bit confusing :-)
13:59:04 <quicksilver> Yoric[DT]: this is the place to start http://hackage.haskell.org/trac/ghc/wiki/Commentary
13:59:06 <lambdabot> Title: Commentary - GHC - Trac
13:59:14 <quicksilver> Yoric[DT]: however, I don't see anything there obviously relevant.
13:59:25 <quicksilver> Yoric[DT]: you may have to resort to glasgow-haskell-users (the mailing list)
13:59:38 <Yoric[DT]> quicksilver: actually, I browsed the wiki quickly and only found a few imprecise lines on inlining.
13:59:44 <Yoric[DT]> Mostly regarding a pragma.
14:00:07 <quicksilver> I agree. It does not appear to be a well-documented part.
14:00:30 <quicksilver> Yoric[DT]: you may well find this interesting : http://research.microsoft.com/~simonpj/Papers/inlining/
14:00:31 <lambdabot> Title: Simon Peyton Jones: papers
14:00:36 <Yoric[DT]> Thanks.
14:00:52 <sutats> Given two integers x and y, what's the best way to round x up to the closest multiple of y?
14:01:14 <quicksilver> x + (y - x`mod`y) ?
14:01:48 <sutats> Oh, wow, I don't know why I didn't think of that.
14:01:48 <quicksilver> actually that's not quite right. fixing it is an exercise to the reader :P
14:01:56 <pgavin> ceiling (x/y) * y
14:02:21 <adu> hi
14:02:25 <adu> I'm so excited!
14:02:44 <sutats> Which is more efficient? Mod or ceiling (x/y)?
14:02:53 <quicksilver> ceiling (x/y::Rational) * y perhaps
14:02:55 <pgavin> probably mod
14:03:04 <quicksilver> please don't use floating point to solve an integer problem ;0)
14:03:13 <sutats> Fair enough.
14:03:34 <pgavin> quicksilver: indeed
14:06:18 <adu> This is all I had to do to get HOC to compile with GHC-6.8.3 http://tetration.itgo.com/hs/hoc-cvs.patch
14:06:55 <adu> 6.8.3 rocks!
14:07:08 <mjrosenb> adu: any new features over 8.2?
14:07:08 <dons> sweet.
14:07:44 <sutats> quicksilver: "if (x`mod`y /= 0) then x + (y - x`mod`y) else x" is the fix, but can that be put more eloquently?
14:07:49 <adu> mjrosenb: i dunno, but I made so many more fixes to hoc, and it never compiled with ghc-6.8.2
14:08:53 <adu> uh oh
14:09:58 <hpaste>  adu pasted "hoc-cvs.patch" at http://hpaste.org/8485
14:10:04 <adu> thats better
14:11:28 <adu> :)
14:12:50 <joey_> @pl \f g -> State (\s -> (f s, g s))
14:12:50 <lambdabot> (State .) . liftM2 (,)
14:13:20 <tromp> @let roundup y x = y * (x + y-1 `div` y)
14:13:21 <lambdabot> Defined.
14:13:34 <tromp> > roundup 10 36
14:13:35 <lambdabot>  460
14:13:56 <tromp> oops
14:14:15 <tromp> @let roundup y x = y * ((x + y-1) `div` y)
14:14:16 <lambdabot> <local>:8:0:     Warning: Pattern match(es) are overlapped              In th...
14:14:25 <tromp> @let roundUp y x = y * ((x + y-1) `div` y)
14:14:26 <lambdabot> Defined.
14:14:30 <tromp> > roundUp 10 36
14:14:31 <lambdabot>  40
14:14:49 <sutats> > roundUp 10 40
14:14:50 <lambdabot>  40
14:15:03 <tromp> there you go:)
14:15:10 <sutats> Haha, thanks, much cleaner.
14:17:01 <EvilTerran> i prefer the version with rationals and ceiling
14:17:09 <EvilTerran> it probably inlines to the same thing anyway
14:17:39 <sutats> EvilTerran: Why would that be?
14:18:04 <EvilTerran> it's more immediately obvious what the rationals/ceiling version did
14:18:33 <EvilTerran> that definition followed almost immediately from the problem description
14:18:38 <tromp> at the cost of extra computation to determine the gcd
14:19:01 <EvilTerran> without the several minutes of programmer-side computation the other version required ;)
14:19:05 <dons> first post in the "daily haskell" series, http://www.reddit.com/info/6on3g/comments/
14:19:06 <lambdabot> Title: reddit.com: Daily Haskell: Download and analyse logs, and generate sparkline gra ...
14:19:22 <dons> showing how to use tagsoup, parsedate and hsparlines to generate live hackage graphs
14:19:41 <dons> enjoy!
14:20:07 <tromp> :t ceiling
14:20:09 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
14:22:23 <tromp> @let roundUp2 y x = y * ceil (x % y)
14:22:23 <lambdabot> <local>:10:19: Not in scope: `ceil'
14:22:28 <tromp> @let roundUp2 y x = y * ceiling (x % y)
14:22:29 <lambdabot> Defined.
14:22:40 <tromp> > roundUp2 10 36
14:22:42 <lambdabot>  40
14:22:46 <tromp> > roundUp2 10 40
14:22:48 <lambdabot>  40
14:23:00 <tromp> > roundUp2 10 -13
14:23:00 <lambdabot>   add an instance declaration for (Num (t -> t))
14:23:10 <tromp> > roundUp2 10 (-13)
14:23:12 <lambdabot>  -10
14:23:18 <tromp> > roundUp 10 (-13)
14:23:19 <lambdabot>  -10
14:24:17 <tromp> the eternal dilemma... how much efficiency to give up for readability?
14:24:46 <mjrosenb> tromp: infinite.  if it's the same function, the compiler should know how to handle it
14:25:06 <mjrosenb> tromp: be warned, you may not live in a fantasy world
14:26:46 <tromp> if you can write that infinitely optimizing compiler, then you'll make millions:)
14:28:21 <monochrom> if you can write the infinitely de-optimizing compiler (it turns optimized code into readable code), you'll make billions.
14:28:26 <tromp> that compiler would also reduce my function ListOfFLTCounterExamples to [] :)
14:29:28 <dons> http://www.reddit.com/r/programming/info/6on3g/comments/ upmods please :) we have misconceptions to overturn!
14:29:28 <lambdabot> Title: programming: Daily Haskell: Download and analyse logs, and generate sparkline gr ...
14:30:43 <wagle> if input == 32 then output = 2373 else fatal_error "infinite re-optimization required"
14:32:25 <sutats> What's the function to turn an Int into a String?
14:32:37 <tromp> show
14:32:40 <mjrosenb> show
14:32:57 <sutats> Ah, thanks.
14:34:51 <mjrosenb> is there a non-compiler specific module to get Word8?
14:35:20 <dons> Data.Word
14:35:26 <dons> ?hoogle Word8
14:35:27 <lambdabot> Data.Word.Word8 :: data Word8
14:35:27 <lambdabot> Data.ByteString.Internal.isSpaceWord8 :: Word8 -> Bool
14:35:45 * gwern is really pleased with this new ghc-paths library
14:35:53 <dons> gwern: oh, what's it do?
14:35:57 <gwern> it fixes one of the more unpleasant aspects of the GHC API
14:36:02 <dons> ah
14:36:05 <gwern> we can get rid of so much nasty code!
14:36:06 <mjrosenb> why on earth am i using GHC.Word
14:36:11 <Cale> > show 25
14:36:12 <lambdabot>  "25"
14:36:15 <Cale> > show [1,2,3]
14:36:16 <lambdabot>  "[1,2,3]"
14:36:28 <Cale> > show (Just "Hello")
14:36:29 <lambdabot>  "Just \"Hello\""
14:36:35 <gwern> dons: it gives you ghc --print-libdir. right now, yi and hint etc. have these big ol' Setup.hses just to provide that as a string at compile time
14:36:52 <Cale> > show "Strings are shown quoted."
14:36:53 <lambdabot>  "\"Strings are shown quoted.\""
14:36:56 <Cale> > show (show "Strings are shown quoted.")
14:36:57 <lambdabot>  "\"\\\"Strings are shown quoted.\\\"\""
14:37:00 <gwern> it still doesn't fix my import problem, obviously, but I'm still happier anyway
14:37:25 <mauke> > fix show
14:37:26 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:37:35 <dons> gwern: btw, did you see i uploaded an amended hgeometric wsith gpc.c builtin
14:37:40 <dons> so it builds out of the box now
14:37:48 <dons> instead of trying to work out how to make gpc.c installable
14:38:05 <gwern> dons: no, I didn't notice. 'sfine by me if it works, but are you sure the licensing is kosher?
14:38:24 <dons> gwern: yeah, gpc.c is freerer than gpl
14:38:32 <dons> and it has its original license
14:38:51 <dons> makes sense too, since gpc hasn't been updated in 4 years
14:38:58 <gwern> hm. strange, I remember license issues with hgeometric. maybe that was another math lib then
14:39:01 <dons> so i doubt it'll be library-ified soon
14:39:30 <ziman> > map (length . head) . iterate (drop 2) . tail . group . fix $ show
14:39:39 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262...
14:40:19 <mauke> > map pred $ iterate (join (+)) 2
14:40:20 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262...
14:40:42 <ziman> :t pred
14:40:44 <lambdabot> forall a. (Enum a) => a -> a
14:40:46 <mc__> > pi
14:40:47 <lambdabot>  3.141592653589793
14:40:59 <ziman> @src pred
14:40:59 <lambdabot> Source not found. My mind is going. I can feel it.
14:41:11 <lament> that's pathetic. Even I memorized more digits of pi than lambdabot.
14:41:13 <gwern> so anyway, that reminds of a question. is it possible to obscure a function name in haskell source? ie, I want to make sure when mueval is passed a String, it does not execute anything that calls something unsafe*. so I was thinking "just see whether "unsafe" appears in the input string", since AFAIK, there's no way to 'escape' or hide a function name (no "\u\n\s\a\f\e\PerformIO <stuff>" - the escaping would either disapear during reading, or cause a type o
14:41:19 <EvilTerran> pred is a method of Enum, its definition varies on typeclass
14:41:24 <tromp> take 4 (fix show)
14:41:25 <mauke> > pi :: CReal
14:41:26 <lambdabot>  3.1415926535897932384626433832795028841972
14:41:35 <dons> gwern: don't use string matching
14:41:37 <tromp> > take 4 (fix show)
14:41:38 <lambdabot>  "\"\\\"\\"
14:41:43 <dons> that's a horrible approach to security. use the type system
14:41:53 <pgavin> > pi :: Rational
14:41:54 <dons> lock down which modules are in scope, limiting it to a trusted base
14:41:54 <lambdabot>   add an instance declaration for (Floating Rational)
14:41:54 <lambdabot>     In the expression: ...
14:41:58 <dons> then try to type check the function
14:42:03 <mjrosenb> @src fix
14:42:03 <dons> if its unsafe, it won't type check
14:42:03 <lambdabot> fix f = let x = f x in x
14:42:08 <pgavin> > realToFrac pi :: Rational
14:42:09 <lambdabot>  884279719003555%281474976710656
14:42:12 <lament> mauke: damn, that's more :D
14:42:13 <dons> seriously, any string based work is asking for trouble
14:42:20 <mjrosenb> blast
14:42:27 <tromp> > take 8 (fix show)
14:42:28 <lambdabot>  "\"\\\"\\\\\\\"\\"
14:42:32 <lament> > 884279719003555%281474976710656 :: CReal
14:42:32 <lambdabot>  Couldn't match expected type `CReal'
14:42:51 <monochrom> mjrosenb: http://www.vex.net/~trebla/haskell/fix.xhtml  for fix
14:42:53 <ziman> > join (+) 2
14:42:54 <lambdabot>  4
14:43:14 <gwern> dons: I am using the type system, but unfortunately, the GHC API is broken w/r/t sandboxing
14:43:18 <ziman> > iterate (join (*)) 2
14:43:19 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
14:43:20 <pgavin> :t join (f :: a -> a -> a)
14:43:21 <lambdabot>     Could not deduce (SimpleReflect.FromExpr a, Show a)
14:43:21 <lambdabot>       from the context ()
14:43:21 <lambdabot>       arising from a use of `f' at <interactive>:1:6
14:43:26 <gwern> so the lambdabot approaches are insufficient
14:43:47 <mjrosenb> monochrom: i mostly wanted to know what library it's in, since it's not in prelude
14:43:51 <mjrosenb> monochrom: if any
14:43:55 <monochrom> Data.Function
14:43:56 <mauke> @index fix
14:43:57 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:43:58 <pgavin> > join (f :: a -> a -> a)
14:43:59 <dons> good luck then.
14:43:59 <lambdabot>        add (SimpleReflect.FromExpr a, Show a) to the context of
14:43:59 <lambdabot>         the p...
14:44:27 <pgavin> is guess join is using the (->) monad here?
14:44:40 <monochrom> Yes.
14:44:56 <pgavin> ok, I get it :)
14:45:11 <gwern> so offhand no one knows how to use a module function without giving its canonical name?
14:45:34 <mjrosenb> excellent
14:45:41 <ziman> > join (*) 2
14:45:42 <lambdabot>  4
14:45:56 <RayNbow> has anyone a sweet snippet showing the beauty of using pseq and/or par?
14:46:21 <RayNbow> or should I just use dons' naive parfib example?
14:46:21 <cjb> RayNbow: dons has, see his fibonacci blog post.
14:46:23 <cjb> :)
14:46:46 <dons> RayNbow: RWH has some
14:46:52 <sutats> @index join
14:46:52 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:47:16 <byorgey> RayNbow: I defined orderPizza with 'var' from the SimpleReflection library
14:47:21 <byorgey> > var "a variable"
14:47:23 <lambdabot>  a variable
14:47:34 <mjrosenb> dons: RWH?
14:47:36 <byorgey> kind of a silly hack =)
14:47:53 <dons> the book
14:48:06 <Apocalisp> > ((.) . join) 2
14:48:07 <lambdabot>   add an instance declaration for (Num (a -> a -> a1))
14:48:11 <Apocalisp> > ((.) . join) (*)
14:48:11 <lambdabot>  Add a type signature
14:48:14 <mjrosenb> dons: ok, i was going to say he does'nt touch haskell if he can avoid it
14:48:24 <RayNbow> byorgey: ah ok
14:48:30 <EvilTerran> > join f x :: Expr
14:48:31 <lambdabot>  f x x
14:48:56 <Apocalisp> > ((.) . join) (*) [0..12]
14:48:57 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144]
14:49:00 <RayNbow> byorgey: I tried using the Var constructor, but apparently the constructor isn't exported :p
14:49:12 <byorgey> RayNbow: ah, hehe =)
14:49:16 <byorgey> guess not
14:54:19 <mjrosenb> dons: how did you mention CPAN and not CTAN :(
14:54:42 <dons> heh
14:55:28 <dons> ask yourself how much of hackage you've used, and it its less than 10 packages, try something new
14:55:54 <mauke> mjrosenb: no one knows CTAN
14:56:14 <mauke> I still think hackage should have been called CHAN and hosted on 4chan.org
14:56:25 <dons> yeah, that'd be sweet
14:57:38 <dons> where's our killer app of 2008? come on peoples, more code!
14:57:55 <Cale> MOAR COAD
14:58:33 <dons> anything you need to do in your daily work, that you can't do with what's on hackage, should be a trigger to write a binding, or a new lbirary
14:59:01 <lament> LOLskell
14:59:21 <monochrom> do, a block, a monad block. reads, a generic parser. mu, a name that calls itself. var, a binding to a thunk.
14:59:41 <Cale> Let's take over /h/ with posts about Haskell.
14:59:56 <mauke> you gonna get b&
15:00:09 <mauke> haskell is clearly /d/
15:00:30 <roconnor> dons: is agda 2 on hackage?
15:00:41 <dons> roconnor: nope.
15:00:58 <dons> that'd be a start. get it on hackage, i'd have it in Arch binaries by the end of the  day
15:01:27 <roconnor> dons: hmm, my portfolio optimizer is something I use everyday.  But it isn't very generic at the moment.
15:01:43 <mauke> when will there be a ghc-6.8.3 compatible haddock?
15:02:13 <dons> roconnor: sounds useful.
15:02:24 <dons> i just roll little ghci scripts for things like that
15:02:33 <dons> but some more finance libs beyond the current quote-gathering stuff would be good
15:03:26 <Igloo> mauke: 0.9 should work
15:03:32 <roconnor> dons: it's designed to work on for http://www.ideosphere.com/ which is a peculiar market because it deals with fake money.
15:03:33 <lambdabot> Title: Foresight Exchange
15:03:40 <roconnor> makes it easier to apply math. :)
15:03:44 <dons> heh
15:03:46 <roconnor> it is more ideal
15:03:47 <mauke> Igloo: boring
15:05:00 <roconnor> oh, I generate my blog using haskell
15:05:04 <roconnor> I use that frequently
15:05:14 <roconnor> hmm
15:05:20 <roconnor> but it is a big mess
15:05:33 <mauke> huhu, someone should port Catalyst to haskell
15:05:38 <roconnor> I need to rewrite make in Haskell to clean it up
15:05:40 <monochrom> I generate my blog using google
15:05:58 <roconnor> or more realisically, wait for someone else to rewrite make in Haskell.
15:06:02 <dons> mauke: you are someone.
15:06:04 <dons> someone should!
15:06:12 <mauke> dons: but I don't understand how catalyst works
15:06:18 <mauke> also, it's heavily OO
15:06:32 <monochrom> where is that april fool goof about google blogs...  "we'll write it for you!"
15:06:32 <Cale> What is Catalyst?
15:06:33 <dons> excuses.
15:06:44 <mauke> http://catalyst.perl.org/
15:06:45 <lambdabot> Title: Catalyst - Web Framework
15:06:48 <Cale> ah
15:07:31 <dons> whatever it is you need for your day job, you should be able to do in haskell.
15:07:41 <dons> if not, that means library or binding time
15:08:31 <Cale> dons: Assuming that thing actually involves programming ;)
15:08:33 <dons> seriously, 400+ people here , some of you guys can write a library
15:09:13 <dons> Cale, or plotting pretty pictures, or playing with numbers.
15:09:23 <dons> haskell's a thinking tool. and most of us do thinking
15:09:31 <mjrosenb> dons: id3 parser?
15:09:37 <dons> would be useful.
15:09:42 <dons> a full id3 binding would be even better
15:09:53 <sw17ch> speaking of libraries, i'm still having issues wading through c2hs... i think i'm not looking at the correct documentation
15:09:54 <mauke> not me, I just do highly sophisticated pattern matching!
15:10:00 <dons> so i can write command line tools and gui tools to hack my mp3s
15:10:06 <mjrosenb> dons: i'm just writing the parser in haskell, no ffi bindings
15:10:30 <hpaste>  TomMD pasted "head [] exception, but why?" at http://hpaste.org/8486
15:10:40 <TomMD> If anyone knows why ^^^ I'm all ears
15:10:47 <BMeph> How about a binding to use Haskell libraries in C?
15:10:47 <dons> mjrosenb: even better
15:10:49 <monochrom> I do undecidable pattern matching.
15:10:50 <sw17ch> and i'm not sure how ghc manages to find my chs files when...
15:11:00 <dons> sw17ch: in cabal?
15:11:02 <sw17ch> or does ghc some how run c2hs over chs files first...
15:11:07 <dons> BMeph: foreign export does that
15:11:09 <TomMD> monochrom: Seriously, its been bugging me.
15:11:14 <dons> but more C interfaces would be sueful
15:11:30 <sw17ch> dons: no, i'm (trying) to write an FFI for ALSA
15:11:44 <dons> TomMD: whic byteststring?
15:12:16 <sw17ch> i have the easy stuff figured out.. but dealing with {# fun and {# pointer are causing me problems...
15:12:20 <sw17ch> aka, i'm not sure what i'm doing :)
15:12:30 <TomMD> dons: I imported Lazy, not sure if it matters, didn't crash for me without that field.
15:12:36 <sw17ch> and i can't find an obvious place to understand it...
15:12:48 <monochrom> TomMD: misunderstanding? I was echoing to someone else.
15:12:56 <sw17ch> gtk2hs is much to large to be able to understand the stuff transparently, but the examples that ship with c2hs are much to trivial
15:13:38 <dcoutts> sw17ch: take a look at the cairo component in gtk2hs. It's quite manageable in size and good c2hs style imho.
15:13:44 <BMeph> dons: useful, perhaps? ;)
15:14:11 <sw17ch> dcoutts, i don't mean to be insulting in any way... gtk2hs is great... especially the cairo stuff... :)
15:14:32 <Staz> Is there an advantage to currying? To me it just makes it trickier to read!
15:14:35 <dcoutts> sw17ch: I quite appreciate that gtk2hs as a whole is too big as a c2hs demo :-)
15:15:09 <dons> i just wish people would stop using wxHaskell, or fix it.
15:15:21 <dcoutts> sw17ch: my suggestion is that you look just at the cairo bit as it's much smaller and is pretty well written and uses {# fun #} hooks
15:15:24 <dons> since having half a dozen nice things on hackage that needs wxcore, but no wxcore for linux, is kind of irk
15:15:41 <dcoutts> pgavin!
15:15:41 <sw17ch> dcoutts, many {# pointer hooks?
15:15:48 <pgavin> dcoutts! :)
15:15:49 <dcoutts> sw17ch: at least one :-)
15:16:03 <pgavin> dcoutts: I think I fixed the installer
15:16:16 <dcoutts> pgavin: great, I'll try it tomorrow
15:16:27 <pgavin> k :)
15:16:32 <dcoutts> dons: btw I had a suggestion for the gtk2hs bit in the RWH GUI chapter which is to use the new attributes syntax
15:16:47 <sw17ch> dcoutts, alright, i have one that i think works... {#context lib="cairo" prefix="cairo"#}
15:16:52 <sw17ch> woops
15:16:57 <sw17ch> {#pointer *cairo_t as Cairo newtype#}
15:16:59 <dcoutts> dons: I realised there was one missing for the example you were using and I sent a patch to pgavin today to fix it.
15:17:16 <pgavin> it's in the repo already :)
15:17:39 <dcoutts> dons: basically instead of widgetSetFoo widget value we can use set widget [ wigetFoo := value ]
15:17:41 <dons> dcoutts: great. ok.
15:17:59 <dcoutts> dons: this is a syntax stolen from wxhaskell (and they stole it from yampa I think)
15:18:10 <dcoutts> dons: it uses the same attribute name for get or set
15:18:15 <dcoutts> value <- get widgetFoo
15:18:24 <pgavin> anyone else that wants to test the windows installer is welcome to :)   => http://code.haskell.org/~pgavin/gtk2hs-0.9.13-rc/gtk2hs-0.9.13-rc2.exe
15:18:25 <lambdabot> http://tinyurl.com/5eaaar
15:18:25 <dons> yep, i now it.
15:18:29 <dons> know.
15:19:05 <dcoutts> dons: and it lets you set multiple attributes in one go and do things like updates (or monadic set/updatet) rather than just simple :=
15:19:37 * BMeph eagerly clicks the link from the nice stranger on IRC...
15:19:42 <dcoutts> dons: and in some future gtk2hs release we're going to deprecate all the widgetSetFoo foo
15:20:06 <dcoutts> BMeph: it's ok :-) pgavin is the new gtk2hs release manager
15:20:47 <pgavin> heh, if it's got a virus in it I claim no responsibility :)
15:20:47 <TomMD> dons: Realized I misunderstood you.  I have tried this code snippet with bytestring 0.9.1.0 (current release) and 0.9.0.1.
15:21:19 <TomMD> dons: It has the exception with both versions and with Lazy or Strict.  Let me know if I am missing something obvious.
15:21:23 <BMeph> dcoutts: Well, YOU're a "stranger" too, y'know... ;)
15:21:38 <pgavin> BMeph: btw, it requires ghc-6.8.3
15:21:46 <dcoutts> BMeph: heh :-) yeah fair enough
15:22:59 <BMeph> pgavin: Thanks for the notice - I got it. Still trying to update my Cabal from 1.4, though... :)
15:23:15 <dcoutts> from 1.4? surely you mean to 1.4
15:23:16 <hpaste>  TomMD annotated "head [] exception, but why?" with "Simpler version" at http://hpaste.org/8486#a1
15:24:23 <monochrom> strange head explosion indeed
15:24:38 <BMeph> dcoutts: No, I mean from. I thought it was kind of funny that 1.5.1 was done before 1.4.0 was released. :)
15:24:56 <TomMD> Yeah - I keep thinking I must be stupid and missing something, but then I look again and swear thats not the case (I might be stupid, but not missing anything here).
15:25:25 <dcoutts> BMeph: aye, it's what we get for managing branches sanely, we get multiple versions on the go simultaneously
15:25:37 <Trinithis> is there a non-lazy readFile type function? If there is am I right in suspecting that if I am going to process the entire file, reading it at once would be beneficial?
15:26:04 <mjrosenb> Trinithis: it depends on the size of the file
15:26:12 <Trinithis> small files
15:26:13 <dcoutts> Trinithis: no, it's still beneficial to read it incrementally, especially if it's likely to be large
15:26:17 <TomMD> Trinithis: I suspect that if it is small then a lazy read would pull it all in one grab anyway.
15:26:26 <Trinithis> ok
15:26:34 <dcoutts> I think readFile uses 4k block or something
15:26:44 <sw17ch> when i do a ghc --make [...], how in the world does ghc pull in my *.chs files and tell me there's problems with them?
15:26:58 <Trinithis> im just coding a simple indent formatter
15:26:58 <sw17ch> especially when they aren't in the directory tree/exist?
15:27:00 <dcoutts> sw17ch: it doesn't. cabal runs c2hs on the files first.
15:27:10 <TomMD> hsc2hs you mean?
15:27:12 <dons> i see lots of newbies using: ghc --make A.hs
15:27:16 <dons> for production code.
15:27:22 <dons> I wish -O was on by default, sigh.
15:27:34 <dcoutts> TomMD: c2hs and hsc2hs are different ffi pre-processors
15:27:36 * sw17ch admits he's a newbie
15:27:39 <dons> i guess people coming from perl, python are not used to optimising compilers
15:27:55 * sw17ch comes from C... has no excuses...
15:28:16 <sw17ch> dcoutts, what if the chs files don't even exist?
15:28:28 <dcoutts> sw17ch: erm then it's not going to work :-)
15:28:29 <TomMD> dons: Optimi-whato?
15:28:32 <TomMD> ;-)
15:29:01 <sw17ch> Here's what I'm getting... PCM.chs:50:0: Invalid type signature
15:29:24 <sw17ch> is this stuff cached in the .hi or .o files some how?
15:29:35 <mauke> is there a PCM.hs?
15:29:40 <sw17ch> yes
15:29:58 <dcoutts> sw17ch: are you using Cabal or are you running c2hs manually?
15:29:58 <sw17ch> does it pull the meta info out of those comments?
15:30:02 <sw17ch> manually
15:30:25 <mauke> it probably contains LINE pragmata
15:30:28 <dcoutts> sw17ch: oh ok, so you've run c2hs to turn PCM.chs into PCM.hs
15:30:35 <sw17ch> oh... i see it now...
15:30:42 <sw17ch> too bad line 50 doesn't even exist in that file :(
15:30:50 <dcoutts> sw17ch: yes, as mauke says, it has line info pragmas to say where in the original file the error is
15:31:02 <ziman> pragmata :)
15:31:06 <dcoutts> sw17ch: if it's after the end of the original file then it's referring to the bits that c2hs generated
15:31:47 <dcoutts> sw17ch: in which case you might look at the generated PCM.hs and see what's wrong with the type signature
15:32:13 * sw17ch apologizes for being impatient
15:32:14 <dcoutts> if you give c2hs garbage it can end up generating garbage .hs files
15:32:55 * BMeph does a happy dance, now that the Gtk2hs Windows installer no longer demands to use 6.6.1
15:33:14 <dcoutts> BMeph: it didn't before, it demanded 6.6.1 or 6.8.2
15:33:44 <monochrom> confutatis pragmatatis, flammis acribus addictis.
15:34:22 <mapreduce> quidquid latine dictum..
15:34:27 <byorgey> flamnis
15:34:49 <dcoutts> BMeph: oops, I mean it asked for 6.8.1. I had a separate special build for 6.8.2
15:35:11 <pgavin> BMeph: so it works? :)
15:35:36 <BMeph> pgavin: I'll tell you in a bit - still getting used to using emacs again. :)
15:36:08 <byorgey> voca me cum haskellitis
15:36:08 <pgavin> BMeph: heh, ok :)
15:36:21 <BMeph> dcoutts: Every time I tried the "separate special build," it still asked to see my "6.6.1 ID" :|
15:36:34 <hpaste>  morrow pasted "arityT :: Type -> Int" at http://hpaste.org/8488
15:36:42 <dcoutts> BMeph: hrm
15:38:30 <BMeph> dcoutts: If it even happens again, I'll just tell IT that I got a computer virus, so I need a special setup...load Linux on my machine, and run Windows as a virtual... >;)
15:38:32 <monochrom> hehehehe
15:42:50 <hpaste>  BMeph pasted "No haddock joy in Windows-ville" at http://hpaste.org/8489
15:44:00 <pgavin> BMeph: there's a fix for that somewhere
15:44:52 <BMeph> pgavin: Good. Well, gtk-demo worked, which is much nicer to see than:
15:45:02 <BMeph> Segmentation fault (core dumped).
15:45:05 <pgavin> lol
15:45:07 <BMeph> :)
15:45:21 <pgavin> BMeph: so you were able to compile the demo with no problems?
15:45:37 <BMeph> pgavin: With nary a hiccup! :)
15:45:41 <pgavin> yay
15:46:05 <pgavin> thanks for testing it BMeph :)
15:46:12 <pgavin> @karma+ BMeph
15:46:12 <lambdabot> BMeph's karma raised to 2.
15:46:37 <mauke> I recommend using the <nick>++ syntax instead so preflex counts it too :-)
15:46:50 <BMeph> Thanks for making it testable, pgavin. :)
15:46:53 <BMeph> pgavin++
15:47:34 <pgavin> heh, I didn't change anything specifically to make that one work :)
15:47:44 <pgavin> new versions of gtk and all that though
15:48:15 <pgavin> I still need to test it under vista
15:48:26 <pgavin> but that means I have to reboot my desktop
15:48:32 <pgavin> which I don't feel like doing atm :)
15:48:58 <povman> how do i edit pages on haskell' trac?
15:54:37 <BMeph> pgavin: Sometimes, just having someone to point to, is enough to inspire effort. :)
15:57:40 <pgavin> heh, I'll probably do it tonight :)
16:01:12 <gwern> @pl unsafed z = or $ map (\f -> f z) $ map (\x -> isInfixOf x) ["unsafe", "inlinePerform", "liftIO", "Coerce"]
16:01:14 <lambdabot> unsafed = or . ($ map isInfixOf ["unsafe", "inlinePerform", "liftIO", "Coerce"]) . map . flip id
16:01:18 * gwern is a terrible programmer
16:01:58 <mjrosenb> hrmm it seems like haskell-mode is out of date with haskell's parser
16:02:17 <gwern> mjrosenb: did you look at the cvs haskell-mode?
16:02:31 <mjrosenb> gwern: no
16:03:08 <EvilTerran> @pl \z -> any (`isInfixOf` z) ["unsafe", "inlinePerform", "liftIO", "Coerce"]
16:03:09 <lambdabot> flip any ["unsafe", "inlinePerform", "liftIO", "Coerce"] . flip isInfixOf
16:03:22 <EvilTerran> i'd go for my pointful version, personally
16:03:43 <EvilTerran> although this remains the wrong way to go about making code secure
16:03:47 <BMeph> ...says the COMPLETELY unbiased opinion... ;)
16:03:57 <gwern> yeah, that looks a lot better
16:03:59 <EvilTerran> BMeph, well, which would *you* go for? :P
16:04:24 <EvilTerran> s/code/string evaluation/
16:04:29 <monochrom> x =~ "unsafe"
16:04:37 <gwern> EvilTerran: I am perfectly aware of that, which is why I have like 6 other methods of securing things, and why I curse the GHC api daily for allowing non-imported functions to be used by default
16:04:41 <fons> hi
16:04:48 <gwern> (I mean, geez)
16:05:06 <EvilTerran> "by default"? so you can turn it off?
16:05:12 <fons> why does runProcess doens't caus any exceptions if the command to run doesn't exist?
16:05:15 <BMeph> EvilTerran: Well, considering all of that "Coerce", "liftIO" and "unsafe" traffic, I'd just run away, with fingers in my ears... ;)
16:05:17 <monochrom> (I mean, geez) = (,) (I mean) (geez)
16:05:17 <fons> cause*
16:05:29 <gwern> EvilTerran: well, I say 'by default' more hopefully than anything
16:05:29 <fons> that's really strange
16:05:53 <EvilTerran> ?type liftIO
16:05:56 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
16:06:00 <gwern> I don't actually know whether the api can be made to be 'strict' like normal haskell module files
16:06:05 <EvilTerran> not sure why that one's unsafe
16:06:30 <BMeph> EvilTerran: Try m = Identity. ;)
16:06:35 <gwern> can't hurt. I don't see why one would be using that in pure expressions anyway...
16:06:46 <roconnor> Is Identity an instance of MonadIO?
16:06:56 <monochrom> whee!
16:07:12 <EvilTerran> what roconnor said
16:07:21 <BMeph> Bleagh, good call, roconnor. Stupid multi-purpose dot... :)
16:07:36 <EvilTerran> what?
16:08:03 <roconnor> is Ix safe in GHC now?
16:08:36 <gwern> was that the array allocation bug in 6.6?
16:08:59 <roconnor> more like unsafe array addressing for improper Ix instances.
16:09:32 * gwern tried it in 6.8, didn't se anything
16:10:04 <fons> wow, runProcess raises an error on windows if it cannot find the executable
16:10:19 <fons> however it returns normally in OSX
16:10:39 <fons> > runProcess "foo" [] Nothing Nothing Nothing Nothing
16:10:40 <lambdabot>   Not in scope: `runProcess'
16:10:45 <fons> logical
16:11:21 <pgavin> fons: report a bug :)
16:11:30 <fons> can someone try to call runProcess with an invalid executable name?
16:11:50 <EvilTerran> oops
16:12:04 <EvilTerran> you'd just get <IO ProcessHandle> in lambdabot, anyway
16:12:21 <pgavin> @index runProcess
16:12:22 <lambdabot> System.Process
16:13:16 <pgavin> fails on linux as well
16:13:19 <pgavin> and on my mac
16:13:29 <pgavin> err, I mean, fails to raise an error :)
16:13:59 <dons> use findExecutable
16:14:04 <dons> ?hoogle findExecutable
16:14:04 <lambdabot> System.Directory.findExecutable :: String -> IO (Maybe FilePath)
16:14:15 <dons> lots of other good path hacking stuff in the directory package
16:14:17 <mauke> @hoggle runProcess
16:14:18 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
16:14:31 <dons> oe one of the ones that looks up the path
16:15:07 <pgavin> windows probably shouldn't throw an error for that
16:15:11 <monochrom> I see. fork(); exec();  If exec() has an error, fork() wouldn't know.
16:15:26 <mauke> bah
16:15:28 <pgavin> why not?
16:15:34 <fons> dons: yep, that's what I resorted to use
16:15:36 <mauke> the two processes should communicate somehow
16:15:40 <pgavin> man wait
16:15:49 <pgavin> waitpid
16:16:29 <fons> pgavin: I think it should throw an error
16:17:06 <monochrom> Yes, waitpid tells you something.
16:17:38 <pjdelport> mauke: Python's subprocess module does that
16:17:38 <fons> the problem is that there is no way (without callig findExecutable in advance) to know if the error code returned by wait is cause by a real exitcode or an error creating the process
16:18:01 <mauke> so, bug in runProcess
16:18:22 <Athas> So, is xmonad a decent project to read to get a grasp of how Haskell is used in typical projects?
16:18:48 <fons> so either runProcess should raise an error, or retrun one
16:18:51 <dons> Athas: hmm. It shows some usual conventions for stateful, interactive apps. It's heavily intwined in X11 though.
16:18:51 <fons> return*
16:19:16 <dons> Athas: probably not a bad example of long running, server-like programs though
16:19:23 <BMeph> s/retrun/retcon/ ;)
16:20:59 <hpaste>  bs pasted "parser monad" at http://hpaste.org/8490
16:22:14 <povman_> glguy: did you know the "remember me" box doesn't work on hpaste.org?
16:22:15 <pgavin> fons: doessn't Nothing already indicate failure?
16:22:20 <BMeph> edwardk: So, any "get-up-to-speed" papers you'd recommend before tackling your extras package? I just finished Codata and comonads, and while it seemed "lacking," it worked for a introductory paper - i.e., it makes me want to find out the "real scoop" now. ;)
16:22:52 <BMeph> Shouldn't there be five Nothings? :)
16:23:24 <fons> pgavin: what nothing? the return type of runProcess is IO ProcesHandle
16:23:41 <fons> BMeph: yep, my fault
16:23:56 <pgavin> fons: oh, yes, you're correct
16:24:09 <pgavin> it should be Maybe ProcessHandle then :)
16:24:27 <pgavin> or perhaps Either String ProcessHandle
16:24:31 <fons> pgavin: IO (Maybe ProcessHandle) wouldn't require an exception
16:24:41 <pgavin> fons: that's why I mean
16:24:42 <fons> pgavin: what would be an option too
16:24:47 <pgavin> s/why/what
16:24:48 <fons> that*
16:25:03 <pgavin> I would prefer Nothing over an exception, in every case
16:25:12 <EvilTerran> -fallow-incoherent-typists
16:25:18 <EvilTerran> ;)
16:25:21 <fons> hahah
16:25:37 <pgavin> should be -XAllowIncoherentTypists :)
16:25:55 <EvilTerran> except that'd just be -XIncoherentTypists :P
16:26:31 <EvilTerran> it'd use edit distance to guess typos :D
16:28:46 <lament> yes cause we all know how well that works with lambdabot
16:28:57 <lament> @spleen shapr
16:28:57 <lambdabot> I saw shapr leaving #scannedinavian, #haskell-blah and #haskell 1d 7h 36m 39s ago, and .
16:29:07 <EvilTerran> hehe
16:29:15 <telemach> meow.
16:29:20 <telemach> errm, hello :)
16:29:24 <gwern> lament: was that supposed to demonstrate how it didn't work?
16:29:38 <lament> no, that was just random silliness
16:30:22 <mauke> @shapr lament
16:30:22 * lambdabot secretly deletes lament's source code
16:30:39 <fons> BTW, any ideas about how to chain the execution of various processes (sequentially) not continuing it the exitcode of any of them is not successful?
16:30:43 <povman_> ...
16:31:18 <EvilTerran> fons, so you want to replicate the behaviour of && in the shell?
16:31:22 <pgavin> fons: you want a short circuiting monadic &&
16:31:27 <gwern> fons: there are plenty of ways. if I was doing shell scripting, I'd use HSH and it's -|- pipe operator would give me that for free, iirc
16:31:33 <fons> ype, that's it pretty much
16:31:43 <gwern> although it's piping stdin/stdout, so not exactly && then
16:32:05 <pgavin> but do you want to pipe the outputs?
16:32:08 <fons> it would be real cool if that was included in System.Process
16:32:13 <fons> pgavin: no
16:32:32 <pgavin> it would be cooler if there was a short circuiting monad && and || in the prelude
16:32:53 <EvilTerran> (<&&>) :: Monad m => m Bool -> m Bool -> m Bool; x <&&> y = do p <- x; if p then y else return False
16:33:06 <pgavin> yes
16:33:08 <EvilTerran> maybe not the prelude, but it'd fit in Control.Monad nicely
16:33:11 <pgavin> is that in the library already?
16:33:21 <pgavin> yes, exactly
16:33:26 <pgavin> proposal time :)
16:34:45 <fons> liftM2 (&&)
16:34:55 <fons> that's simpler :)
16:35:05 <EvilTerran> fons, but it doesn't short-circuit
16:35:17 <EvilTerran> that's \x y -> do p <- x; q <- y; return (x && y)
16:35:31 <fons> true
16:36:33 <fons> > liftM2 (&&) (return False) undefined :: Maybe Bool
16:36:34 <lambdabot>  Exception: Prelude.undefined
16:37:39 <EvilTerran> i guess a takeWhileM would work, too
16:37:56 <pgavin> or MonadPlus
16:38:32 <povman_> why is gtk2hs listed as soegtk?
16:38:39 <EvilTerran> povman_, ...really?
16:38:41 <pgavin> something like mzero <&&> y = mzero
16:38:46 <dons> povman_: ?
16:38:50 <povman_> on hackage
16:38:53 <pgavin> povman_: there's an soegtk library within gtk
16:38:59 <dons> soegtk is built on top of gtk2hs
16:39:00 <pgavin> err, within gtk2hs
16:39:16 <povman_> oh - so gtk2hs isn't on there
16:39:16 <EvilTerran> er,  i mean...
16:39:18 <pgavin> but they're included in the same package :)
16:39:19 <EvilTerran> pgavin, ...really?
16:39:24 <EvilTerran> darn tab completion :P
16:39:31 <dons> povman_: right. grab gtk2hs from your distro
16:39:40 <dons> or build it yourself from haskell.org/gtk2hs
16:39:58 <dons> if its not in your distro, complain to the distro packagers, or port it
16:40:12 <povman_> that's interesting - why's it not on hackage?
16:40:32 <dons> it's from before cabal days, so doesn't yet build fully cabalised.
16:40:35 <pgavin> povman_: cabal doesn't have what's needed to build gtk2hs (yet)
16:40:40 <povman_> sure
16:42:42 <pgavin> why do monad/arrow/applicative laws seem so fuzzy sometimes?
16:42:59 <mauke> because monads are warm, fuzzy things
16:43:17 <pgavin> heh
16:43:19 <Pseudonym> Arrows are sharp.
16:43:28 <centrinia> Monads are adjoint functors. :)
16:43:36 <pgavin> heh, I wish this page existed when I was trying to figure out the list monad: http://en.wikibooks.org/wiki/Haskell/MonadPlus
16:43:37 <telemach> monads are hairy beasts.
16:43:44 <telemach> like real men (tm).
16:44:06 <Pseudonym> Actually, I find the monad laws quite warm and fuzzy, but the arrow laws are dense, thick and hairy.
16:44:12 <pgavin> what I mean, though, is it seems like everywhere you look, there's a new monad/arrow/applicative law someone forgot about
16:44:24 <pgavin> the arrow laws are pretty bad
16:44:27 <centrinia> I used to shoot arrows through monads. :)
16:44:35 <Pseudonym> I want arrow calculus.
16:44:41 <Pseudonym> The laws of arrow calculus are pretty.
16:44:45 <centrinia> There is an arrow calculus.
16:44:50 <centrinia> @google arrow calculus
16:44:51 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf
16:45:02 <pgavin> isn't that what ghc's arrows are based on?
16:45:08 <Pseudonym> No.
16:45:08 <centrinia> Hmm, that's not what I'm looking for.
16:45:22 <Pseudonym> There's a subtle difference between arrow notation and arrow calculus.
16:45:56 <centrinia> There was something on Lambda the Ultimate about this.
16:46:14 <Pseudonym> Moreover:
16:46:22 <Pseudonym> - One of the arrow laws is a theorem.
16:46:31 <Pseudonym> - Two more of them are theorems in paramteric models like Haskell.
16:48:29 <pgavin> so, you mean some of the arrow laws are proven/derived from other arrow laws?
16:48:44 <pgavin> what about the arrow calculus?
16:48:47 <centrinia> Actually, that Wadler link was what I was looking for. :)
16:49:06 <Pseudonym> The arrow calculus has fewer laws.
16:49:21 <Pseudonym> And they're sensibly motivated.
16:49:26 <pgavin> and it's complete, right?
16:49:40 <pgavin> in the non-godel sense :)
16:49:57 <Pseudonym> Yes.
16:50:21 <hansfbaier> pgavin: it is Gödel
16:50:30 <pgavin> I don't have that key :)
16:50:39 <hansfbaier> compose - o
16:50:47 <mauke> ō
16:50:51 <pgavin> that gives me ø
16:50:55 <hansfbaier> pgavin: sorry, compose  - " - o
16:51:06 <centrinia> Where is the compose key? :(
16:51:31 <mauke> ő
16:51:44 <hansfbaier> mauke: nice try :)
16:52:01 <pgavin> I still can't seem to do that
16:52:09 <pgavin> I get Æo
16:52:10 <povman_> ö
16:52:16 <mauke> Gœdel
16:52:18 <povman_> pgavin: alt-u
16:52:25 <pgavin> ö
16:52:27 <pgavin> yay
16:52:32 <povman_> you must be on a mac
16:52:32 <hackage> New hackage package: GroteTrap 0.3
16:52:36 <pgavin> yes
16:53:15 <pgavin> It's be nice if the alternate characters were also on the keys :)
16:53:24 <mauke> ℘ℰℛℒ
16:53:30 <pgavin> heh
16:54:00 <dcoutts> dons: once gtk is on hackage I think we should reject uploads where the deps are not satisfied
16:54:26 <dcoutts> dons: eg see the recent package that depends on an unreleased version of the process lib
16:55:02 <pgavin> speaking of which, would it be proper to do a release of a library that depends on ghc HEAD?
16:55:09 <pgavin> :)
16:55:12 <hansfbaier> dcoutts: Do you know of a databinding library for gtk2hs? I really like PropLang, but it is very incomplete....
16:55:47 <dcoutts> hansfbaier: the other high level layer is grapefruit
16:56:03 <dcoutts> hansfbaier: but I think it doesn't cover everything either
16:56:34 <dcoutts> hansfbaier: high level wrappers really need to be generated from a description of the gtk api, it's otherwise too much work to cover everything
16:56:59 <dcoutts> we've got the infrastructure to do that, ie the machine readable api description
16:57:49 <pgavin> dcoutts: there are so many inconsistencies in the API, wouldn't it be hard to automate like that?
16:58:14 <pgavin> dcoutts: plus you can do some cool stuff by hand coding :)
16:58:14 <povman_> what are the pros/cons of grapefruit and proplang? i always thought *fruit was the pinnacle of gui apis
16:58:26 <dcoutts> pgavin: well we've got the existing code generator that generates much of the existing gtk binding
16:59:28 <dcoutts> pgavin: of course it's true that it doesn't cover everything, but it's an order of magnitude easier to edit the result of the code gen into something working than going from scratch
17:00:11 <balsagoth> hi people
17:00:16 <roconnor> hi
17:00:54 <balsagoth> can anyone tell me how i calculate the time of this computation in a function. uncurry(^) (50, 60000)
17:01:45 <balsagoth> i know i have to use monad IO
17:02:09 <balsagoth> but i'm a kind of noob on haskel
17:02:15 <balsagoth> haskell
17:02:25 <roconnor> x <- getCPUtime; evaluate (uncurry (^) (50,60000)); y<- getCPUtime
17:02:29 <roconnor> or something similar to that.
17:02:45 <povman_> :t evaluate
17:02:47 <lambdabot> forall a. (Testable a) => a -> Gen Result
17:02:53 <balsagoth> oh noo, i miss evaluate
17:02:56 <roconnor> wrong evaluate
17:03:02 <roconnor> @hoogle evaluate
17:03:03 <balsagoth> thanks a lot
17:03:03 <lambdabot> Control.Exception.evaluate :: a -> IO a
17:03:08 <roconnor> that evaluate
17:03:14 <povman_> 1337
17:03:58 <adu> hi balsagoth
17:05:13 <balsagoth> sorry, where is evaluate?
17:05:17 <balsagoth> any module?
17:05:31 <adu> balsagoth: Control.Exception
17:05:33 <telemach> Control.Exception
17:06:23 <telemach> ﻿may i ask for help regarding a parser monad i'm writing? (http://hpaste.org/8490)
17:06:34 <telemach> i'm clueless what ghc tries to tell me.
17:07:00 <telemach> > parser.hs:44:0:
17:07:00 <telemach> >    Illegal instance declaration for `MonadError String ParseMonad'
17:07:00 <lambdabot>  Parse error at "insta..." (column 9)
17:07:00 <lambdabot>   parse error on input `}'
17:07:32 <telemach> >        (All instance types must be of the form (T t1 ... tn)
17:07:32 <telemach> >         where T is not a synonym.
17:07:32 <telemach>  
17:07:32 <lambdabot> Unbalanced parentheses
17:07:32 <lambdabot>  Parse error at "where" (column 1)
17:07:47 <balsagoth> thaks guys
17:07:50 <balsagoth> thanks
17:07:59 <povman_> thants
17:11:21 <povman_>          Use -XTypeSynonymInstances if you want to disable this.)
17:11:41 <hansfbaier> dcoutts: Grapefruit looks more complete....
17:11:55 <povman_> telemach: use -fglasgow-exts
17:11:58 <hansfbaier> dcoutts: looks like more work has gone into it...
17:12:42 <hansfbaier> dcoutts: The simplicity of PropLang against the Power of Arrows...
17:12:45 <telemach> ahh, ok
17:12:51 <telemach> thanks
17:12:57 <Pseudonym> Oh, man.
17:13:21 <Pseudonym> How come Wine 1.0 was released after 15 years and nobody noticed?
17:14:21 <glguy> in 15 years the linux applications got good enough that we didn't want to run windows apps in linux but crippled?
17:14:39 <dcoutts> hansfbaier: right
17:15:04 <telemach> glguy, there's software which simply doesn't exist for linux.
17:15:15 <Pseudonym> Yes.
17:15:17 <sjanssen> like Diablo II!
17:15:18 <telemach> and think of the  gamers ;)
17:15:19 <hansfbaier> glguy: There are real pearls there, like live for speed, which runs like a charm on wine. (though I get bored really fast by gaming....)
17:15:24 <Pseudonym> I was about to say "most of them are games".
17:15:39 <Pseudonym> I just find it amusing that it finally hit 1.0 and nobody noticed.
17:16:00 <sjanssen> I noticed
17:16:06 <sjanssen> it was on the reddit front page, even
17:16:08 <telemach> it's no special release other than the version number.
17:16:24 <hansfbaier> Pseudonym: I did. I live in Indonesia, and may businesses here have M$ inhouse apps running and getting them to play under Wine would eliminate the need for a license in many cases.
17:16:27 <Pseudonym> Ah, that must be it.
17:16:36 <Pseudonym> I don't read reddit.
17:16:56 <Pseudonym> hansfbaier: Where in Indonesia?
17:16:59 <Pseudonym> If I may ask?
17:18:58 <hansfbaier> if you know bali, that is in indonesia.
17:19:15 <hansfbaier> Pseudonym: but i live in java.
17:19:21 <hansfbaier> Pseudonym: s/in/on/
17:19:28 <Pseudonym> Yeah.
17:19:37 * Pseudonym lives in Australia; pretty much everyone here knows where Bali is
17:19:56 <Pseudonym> And Java, for that matter.
17:20:17 <Pseudonym> Selamat pagi, then.
17:20:19 <solrize> are existential types sort of a special kind of type class?
17:20:48 <Staz> what was the bot command to get a function definition?
17:20:54 <Pseudonym> @src id
17:20:54 <lambdabot> id x = x
17:20:56 <Pseudonym> That?
17:21:11 <Staz> @id length
17:21:11 <lambdabot>  length
17:21:17 <Staz> @src length
17:21:17 <lambdabot> Source not found. My brain just exploded
17:21:19 <solrize> i.e. I want something like data LookupTable a = (Ord k, Monad m) => k -> m a
17:21:38 <hansfbaier> Pseudonym: i am german though.... ;0
17:21:42 <Pseudonym> Ah. :-)
17:21:58 <dons> hansfbaier: on top of wxHaskell?
17:22:09 <Pseudonym> Well, I did two years of Bahasa Indonesia at a Lutheran school.  So there!
17:22:41 <hansfbaier> dons: what/
17:22:54 <Pseudonym> solrize: Why do you want the monad?
17:23:01 <Pseudonym> For failure?
17:23:10 <hansfbaier> dons: sorry, vmware messed up my keyboard, shift does not work anymore.
17:23:22 <hansfbaier> Pseudonym: baik sekali....
17:23:29 <Pseudonym> Woo, you've found a use for caps lock.
17:23:42 <hansfbaier> Pseudonym: doesnt work as well...
17:23:46 <Pseudonym> Right, cool.
17:24:01 * Pseudonym finds out where that is
17:24:28 <solrize> pseudonym the idea is it's a lookup function, and the lookup might fail
17:24:50 <Pseudonym> solrize: Right.  Try Edison on for size.
17:24:57 <solrize> edison?
17:25:00 <hansfbaier> dons: sorry, i did not understand your question...
17:25:24 <Pseudonym> solrize: Look it up on hackage.
17:25:27 <solrize> found it
17:26:11 <mjrosenb> its it possible to use field labels in something that isn't a datatype
17:26:13 <mjrosenb> ?
17:26:15 <Pseudonym> lookupM, for example.
17:26:19 <Pseudonym> @src lookupM
17:26:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:26:22 <Pseudonym> :t lookupM
17:26:23 <lambdabot> Not in scope: `lookupM'
17:26:28 <Pseudonym> :t Data.Edison.Assoc.lookupM
17:26:30 <lambdabot> Couldn't find qualified module.
17:26:34 <Pseudonym> OK, Edison not present on lambdabot.
17:26:49 <solrize> pseudonym, hmm, edison looks interesting but i'm not sure it's applicable to what i'm doing, basically i have a bunch of lookup structures in disk files and i want to have a type for the lookup functions
17:27:00 <solrize> i.e. usually they will run in IO
17:27:05 <Pseudonym> lookupM :: (Assoc m k, Monad rm) => k -> m a -> rm a
17:27:09 <Pseudonym> rm is the "return monad".
17:27:48 <Pseudonym> Oh, I see.
17:27:51 <Pseudonym> Different problem.
17:27:51 <solrize> that's an edison type?
17:27:52 <solrize> oh
17:28:08 <mjrosenb> anyone?
17:28:11 <solrize> well yeah, different problem, but that type signature still looks useful
17:28:13 <Pseudonym> You want the data structure to actually live in a monad.
17:28:32 <solrize> mjrosenb i've only seen field labels in newtype and data declarations
17:28:51 <solrize> pseudonym maybe that monad shouldn't be part of the type sig, but rather should be on the actual function definition
17:28:53 <mjrosenb> solrize: so you don't know...
17:29:01 <mjrosenb> i basically want a labeled tuple
17:29:17 <Pseudonym> solrize: In this case, it's actually more like this.
17:29:28 <solrize> mjrosen i think labelled tuples don't exist and you want to use a type
17:29:46 <Pseudonym> class (Ord q, Functor m) => AssocX m k | m -> k where { lookupM :: (Monad rm) => k -> m a -> rm a }
17:29:58 <Pseudonym> With other functions in the interface, obviously.
17:30:04 <Pseudonym> Sorry, that should be (Ord k).
17:30:11 <solrize> pseudonym, zomg :)
17:30:45 <solrize> why is the lookup structure in a monad?
17:30:49 <solrize> or functor, rather ?
17:31:03 <Pseudonym> Oh, that's because associations support and obvious "fmap".
17:31:06 <Pseudonym> an
17:31:17 <Pseudonym> Think of Data.Map.Map k v
17:31:19 <solrize> to map something over all the keys?
17:31:24 <Pseudonym> No, over all the values.
17:31:27 <solrize> ic
17:31:32 <Pseudonym> You can't map over the keys because of the Ord constraint.
17:31:34 <solrize> i can't have that, these structures are huge
17:31:48 <Pseudonym> Yeah, it's not suitable for on-disk data structures.
17:31:58 <Pseudonym> Are these data structures modifiable?
17:32:12 <solrize> at the moment they're read-only
17:32:28 <solrize> mutation is done with a diff-like composition
17:32:47 <solrize> i.e. big structure with a static table, smaller structure for changes, once in a while run a batch job that merges them
17:32:58 <Pseudonym> Right, so some kind of transaction processing system, perhaps.
17:33:38 <solrize> just not very many updates compared to the initial table
17:33:42 <Pseudonym> Yes.
17:43:59 <Pseudonym> Ah, yeah.  One of Alastair's students worked on that in his honours year.  (Same year as me.)
17:44:11 <Pseudonym> Oh, whiips.
17:44:29 <Pseudonym> The context is compressing short strings by using a "priming text".
17:44:46 <Pseudonym> Something that looks like English which you use to "prime" the compressor.
17:46:27 <lament> a straightforward application of bayes stats?
17:54:00 <pgavin> is there any way to turn off inlining entirely in ghc?
17:56:38 <pgavin> dons: ghc-core is awesome :)
17:56:47 <pgavin> ++dons
17:56:51 <pgavin> dons++
17:57:08 <pgavin> @karma+ dons
17:57:08 <lambdabot> dons's karma raised to 146.
17:57:45 <hansfbaier> @karma
17:57:46 <lambdabot> You have a karma of 0
17:58:01 <hansfbaier> lambdabot: whatever that means....
17:58:16 <hansfbaier> lambdabot: are you buddhist or what ;)
17:58:23 <chylli> @5
17:58:23 <lambdabot> Maybe you meant: . ? @ v
17:58:42 <lambdabot> At that point, hansfbaier was enlightened.
17:58:59 <lambdabot> If you meet lambdabot on the road, kill her.
17:59:34 <vininim> o_o
17:59:47 <monochrom> haha
18:01:06 <pgavin> is the ghc-core language typesafe?
18:01:15 <pgavin> i see stuff like `cast`
18:02:32 <chylli> can I do like this ? data A = A | B; data B = A | C; ? is it possibe two data type has same constructor ?
18:03:18 <lambdabot> It's kind of a philosophy on how to write and use libraries for C++.
18:05:09 <mmorrow> hah
18:05:17 <mmorrow> > fmap ((1+) . length) . filter (/=['"']) . group . fix $ show
18:05:25 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:05:31 <monochrom> Tonight lambdabot has a lot of opinions.
18:05:47 <monochrom> chylli: No.
18:05:48 <lambdabot> I think thinking is so important.
18:05:59 <mmorrow> @yow
18:05:59 <lambdabot> Couldn't find fortune file
18:06:26 * mmorrow looks for his favorite lambdabot quote
18:06:49 <mmorrow> <lambdabot> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!  Equip me with MISSILES!!
18:07:08 <mmorrow> lol
18:07:10 <monochrom> terror!
18:07:26 <lambdabot> Cardinal Richelieu died in 1642.
18:09:38 <jdrake> This is cool: http://la.wikipedia.org/wiki/Richelieu
18:11:07 <jdrake> > [x^2| x <- [1..18]]
18:11:09 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324]
18:11:20 <jdrake> > [2^x| x <- [1..18]]
18:11:21 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:15:04 <mjrosenb> jdrake: that page seems to not be available in english
18:15:47 <jdrake> Would you expect this? http://la.wikipedia.org/wiki/Ubuntu
18:16:06 <monochrom> linucis :)
18:16:08 <jdrake> I think I must learn latin :-)
18:16:19 <jdrake> But I bet there are loads of errors on the page
18:30:25 <joey_> > fmap ($2) . iterate ((.) (*2)) $id
18:30:26 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:32:22 <natv> It strikes me as kinda bizarre that latin wikipedia pages don't use the AD dating system, and instead use a clumsy translation of C.E.
18:33:13 <petekaz> can anyone else cabal-install dons hackage-sparks?  my build craps out with GD.
18:33:47 <petekaz> how does one troubleshoot this?
18:34:16 <hpaste>  petekaz pasted "cabal-install of gd" at http://hpaste.org/8493
18:48:07 <Staz> @src map
18:48:07 <lambdabot> map _ []     = []
18:48:07 <lambdabot> map f (x:xs) = f x : map f xs
18:48:39 <sutats> @src join
18:48:40 <lambdabot> join x =  x >>= id
18:56:03 <sandbox> does yi 0.4 work with ghc 6.8.2? I'm getting weird bytestring errors.
19:03:01 <OceanSpray> :t (.)
19:03:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:03:08 <OceanSpray> :t (.) (.)
19:03:10 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
19:03:46 <hpaste>  morrow pasted ""Dynamic" with th (or _) type annotations" at http://hpaste.org/8494
19:03:52 <OceanSpray> :t fmap
19:03:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:04:20 <OceanSpray> :t (.) . (.)
19:04:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:04:37 <hpaste>  morrow annotated ""Dynamic" with th (or _) type annotations" with "forgotten th imports" at http://hpaste.org/8494#a1
19:08:35 <adu> I'm having trouble telling the difference between wxHaskell's macosx-app and HOC's hocwrap....
19:09:03 <adu> they both take an executable and turn it into a .app bundle
19:09:32 <pgavin> is HOC maintained?
19:09:46 <adu> pgavin: I dunno, I haven't heard back from the maintainers yet
19:10:01 <adu> but if I were to maintain HOC I'd just use wxHaskell's
19:10:01 <pgavin> heh
19:10:05 <pgavin> probably not
19:10:25 <pgavin> does wxHaskell use HOC?
19:10:26 <adu> or try and rename it "wrapp" hehe
19:10:30 <adu> pgavin: nope
19:10:34 <pgavin> hmm
19:10:35 <adu> wxWidgets is all C++
19:10:41 <adu> HOC is ObjC only
19:10:53 <pgavin> right, but Cocoa is objc
19:10:56 <Pseudonym> Well... I dispute that wxWidgets is "all C++".
19:11:01 <Pseudonym> Actually it's a restricted subset of C++.
19:11:11 <Pseudonym> But that's another rant right there.
19:11:17 <adu> Pseudonym: technically Cocoa is written in CoreFoundation (which is plain C)
19:11:36 <Pseudonym> Yes.
19:11:38 <adu> so "all" is certainly the wrong word
19:13:11 <roconnor> @seen conal
19:13:12 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
19:14:02 <adu> pgavin: o, i see what you mean, but yes, there are parts of wxWidgets that are written in ObjC, but thats on the back-end (from the programmer's perspective) the front-end (the C++ API) is the only thing that is ported to hs afaik
19:14:49 <pgavin> adu: yeah, that's what I meant
19:14:55 <pgavin> adu: it has to use objc somewhere :)
19:15:02 <adu> ok you win
19:15:35 <pgavin> if they have a decent compatibility layer it could be ripped out and added to grapefruit :)
19:21:42 <dobblego> @check \xs -> let show' xs = '[' : join (intersperse "," (map show xs)) ++ "]" in show' xs == show xs -- is there a nicer show implementation for []?
19:21:44 <lambdabot>  OK, passed 500 tests.
19:26:50 <jdrake> If I have [(x,y,z) | ...] How can I do something like x <- [1..n] but for all x,y,z at the same time?
19:31:02 <dons> jdrake: parallel comprehensions, or with a zip
19:31:20 <ddarius> Use zip3
19:31:22 <jdrake> What would parallel comprehensions be?
19:31:37 <dons> > [ (x,y,z) | (x,y,z) <- zip3 [1..10] "haskell" "funky" ]
19:31:38 <lambdabot>  [(1,'h','f'),(2,'a','u'),(3,'s','n'),(4,'k','k'),(5,'e','y')]
19:31:57 <ddarius> dons: map id = id
19:32:00 <dons> -- parallel: [ (x,y,z) | x <- [1..10] | y <- "haskell" | z <- "funky" ]
19:32:12 <dons> thanks ddarius, i'll note that.
19:32:25 <ddarius> > zip3 [1..10] "haskell" "funky"
19:32:26 <lambdabot>  [(1,'h','f'),(2,'a','u'),(3,'s','n'),(4,'k','k'),(5,'e','y')]
19:32:40 <dons> Prelude> :set -XParallelListComp
19:32:40 <dons> Prelude> [ (x,y,z) | x <- [1..10] | y <- "haskell" | z <- "funky" ]
19:32:40 <dons> [(1,'h','f'),(2,'a','u'),(3,'s','n'),(4,'k','k'),(5,'e','y')]
19:32:48 <dons> sadly unappreciated syntax
19:32:58 <ddarius> happily unappreciated syntax
19:33:00 <jdrake> ok, with parallel like that, can you add a condition section at the end?
19:33:17 <jdrake> That involves x,y,z?
19:33:23 <dons> nope.
19:33:36 <jdrake> I must be able to do that
19:33:53 <dons> works ok with zip3 of course
19:34:00 <dons> > [ (x,y,z) | (x,y,z) <- zip3 [1..10] "haskell" "funky", y /= z ]
19:34:01 <lambdabot>  [(1,'h','f'),(2,'a','u'),(3,'s','n'),(5,'e','y')]
19:34:14 <jdrake> ok, I can try that
19:35:46 <jdrake> I might as well show what I am trying to do:
19:35:46 <jdrake> > pyths n = [(x,y,z) | (x,y,z) <- zip3 [1..n] [1..n] [1..n], x^2 + y^2 == z^2]
19:35:47 <lambdabot>  Parse error at "=" (column 9)
19:35:51 <jdrake> It doesn't seem to work
19:35:59 <jdrake> It returns []
19:36:49 <dons> remember that they're zipped
19:37:03 <dons> so you're just testing  n ^ 2 + n ^ 2 == n ^ 2
19:37:07 <ddarius> jdrake: You want the cartesian product.
19:37:58 <jdrake> The Programming Haskell book is asking for this in one list comprehension. I cannot think of any other way to do it.
19:38:19 <dons> > [ (x,y,z) | x <- [1..100], y <- [1..100], z <- [1..100], x^2 + y^2 == z^2 ]
19:38:21 <lambdabot>  [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25),(8,6,10),(8,15,17),(9,12,15),(...
19:38:46 <ddarius> > [(x,y) | x <- [1..3], y <- [1..3]]
19:38:47 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:38:55 <ddarius> > liftM2 (,) [1..3] [1..3]
19:38:56 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:39:06 <dons> what's the arrow combinator for liftM2 (,) ?
19:39:17 <jdrake> hmm, just a simple comman
19:39:19 <dons> i feel there used to be one, we used. but haven't spotted it recently.
19:39:26 <dons> jdrake: yeah, nested loops. not parallel loops
19:39:31 <ddarius> :t liftA2
19:39:33 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:39:45 <dons> :t liftM2 (,)
19:39:46 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
19:39:53 <dolio> (&&&)?
19:40:05 <dons> yeah, i'm looking for something that hides the tupling constructor
19:40:10 <ddarius> :t (***)
19:40:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:40:32 <ddarius> > (2*) *** (3*) $ (1,2)
19:40:34 <lambdabot>  (2,6)
19:40:47 <ddarius> > liftM2 (,) (2*) (3*) $ (1,2)
19:40:49 <lambdabot>   add an instance declaration for (Num (t, t1))
19:41:30 <ddarius> Yeah, it is what dolio said for the (r ->) monad.
19:41:51 <dons> ah yes, that's it.
19:44:00 <ddarius> > ((2*)&&&(3*))&&&(liftM2 (,) (2*) (3*)) $ 1
19:44:02 <lambdabot>  ((2,3),(2,3))
19:46:52 <jdrake> Is there any reason why mod isn't assigned to % like it is in some languages?
19:49:10 <dons> there's no technical reason I'm aware of
19:49:18 <pjdelport> > 1%2 + 3%4
19:49:19 <lambdabot>  5%4
19:49:27 <pjdelport> there's one, i guess
19:49:32 <jdrake> What is that
19:49:37 <mjrosenb> jdrake: ratios
19:49:43 <pjdelport> :t 1%2
19:49:43 <Pseudonym> I think the main reason is that it's unclear if you mean "mod" or "rem".
19:49:45 <lambdabot> forall t. (Integral t) => Ratio t
19:49:47 <dons> > 1/2 + 3/4 :: Rational
19:49:49 <lambdabot>  5%4
19:49:51 <jdrake> Interesting
19:50:03 <jdrake> I have always interpreted modulus and remainder as the same thing
19:50:08 <dobblego> jdrake, at least in Java, % is not modulus; it is remainder
19:50:25 <Pseudonym> For positive numbers, they are the same thing.
19:50:54 <jdrake> From wikipedia: "In computing, the modulo operation finds the remainder of division of one number by another."
19:51:02 <jdrake> I would be interested to know other applications.
19:51:14 <pjdelport> > (-1) `mod` 5
19:51:15 <lambdabot>  4
19:51:19 <dobblego> scala> -3 % 5
19:51:19 <dobblego> res5: Int = -3
19:51:20 <pjdelport> > (-1) `rem` 5
19:51:21 <lambdabot>  -1
19:51:25 <dobblego> > (-3) `mod` 5
19:51:26 <lambdabot>  2
19:51:34 <solrize> floor-mod versus trunc-mod
19:51:36 <jdrake> wtf?
19:51:37 <Pseudonym> > 5 `mod` (-3)
19:51:38 <lambdabot>  -1
19:51:39 <dobblego> (btw, scala == Java)
19:51:44 <Pseudonym> > 5 `rem` (-3)
19:51:45 <lambdabot>  2
19:51:49 <dons> `rem` is a little faster, in Haskell, fwiw.
19:51:56 <dobblego> > (-3) `rem` 5
19:51:58 <lambdabot>  -3
19:52:02 <dobblego> scala> -3 % 5
19:52:02 <dobblego> res5: Int = -3
19:52:14 <dobblego> @check \x y -> x `mod` y == x `rem` y
19:52:15 <lambdabot>  Exception: divide by zero
19:52:22 <dobblego> @check \x y -> y /= 0 ==> x `mod` y == x `rem` y
19:52:24 <lambdabot>  Falsifiable, after 16 tests: -2, 4
19:52:49 <SamB> vixey: you were right about cont and arrow ...
19:52:54 <SamB> vixey: those are damn hard!
19:53:10 <snhmib> is there a way to floor or ceil a double to an Int(eger)?
19:53:34 <dons> snhmib: so you can take the floor or ceiling, and truncate
19:53:39 <pjdelport> :t floor
19:53:41 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
19:53:47 <snhmib> oh doh
19:53:48 <pjdelport> :t ceil
19:53:49 <dons> > floor pi
19:53:51 <lambdabot> Not in scope: `ceil'
19:53:51 <lambdabot>  3
19:53:52 <SamB> I've yet to figure out how to make a reflexive relation for cont...
19:53:55 <snhmib> thanks :)
19:54:10 <SamB> oh, or state...
19:55:44 <Zao> Does anyone know what the GroteTrap package on hackage does? It has no website, no web docs and googling on "expression language" doesn't turn up much.
19:57:20 <dons> its something of a mystery :)
19:57:38 <dons> there's more details in the upload today
19:57:43 <mjrosenb> are there any extensible types in haskell?
19:57:48 <pjdelport> Zao: the name roughly means "Big Step", if that's any help
19:58:02 <dons> mjrosenb: yes
19:58:11 <SamB> pjdelport: is it related to semantics then?
19:58:14 <dons> "Allows quick definition of expression languages. You get a parser for free, as well as conversion from text selection to tree selection and back."
19:58:24 * mjrosenb pulls out google
19:58:27 <pjdelport> SamB: no idea
19:58:28 <dons> Zao: i'd look at   the author's websites, Jeroen Leeuwestein and Martijn van Steenbergen
19:58:42 <dons> mjrosenb: Dynamic is the main type for full runtime extensibility
19:58:59 <dons> there are other more typed mechanisms (see the "Extensible exceptions" paper)
20:00:36 <mjrosenb> dons: so i'm most familiar with the exception type in ml.  is there anything like that
20:00:47 <mjrosenb> namely, something that can be pattern matched against
20:02:50 <adu> brb
20:05:09 <jbapple> is lambdabot really finicky for anyone else?
20:05:17 <geezusfreeek> it often is
20:05:18 <povman> mjrosenb: what are you trying to do?
20:05:47 <lambdabot> Don't mess with me, primate.
20:06:02 <jbapple> "﻿lexical error at character '\65279'"? WTF does that mean?
20:06:26 <mjrosenb> povman: write an id3v2 parser
20:06:42 <jbapple> My favorite lambdabot failure mode, though, it just silence
20:06:46 <mjrosenb> povman: since the tags are a bit ill-defined, it would be nice to make it extensible
20:06:51 <jbapple> g/it/is
20:07:10 <povman> jbapple: http://www.fileformat.info/info/unicode/char/feff/index.htm
20:07:10 <lambdabot> Title: Unicode Character 'ZERO WIDTH NO-BREAK SPACE' (U+FEFF)
20:08:07 <mjrosenb> that character is f-ing vicious
20:08:14 <jbapple> povman: I don't think I typed one of those
20:08:27 <povman> you never know!
20:08:43 <jbapple> right now I'm still getting the silent treatment
20:08:52 <dogbite> hi all, i'm trying to install cabal-install and i'm told that at least the following dependencies are missing
20:08:56 <dogbite> HTTP >=3000 && <3002, zlib >=0.4
20:08:58 <dogbite> any hints?  i'm on os x
20:09:46 <povman> dogbite: http://trac.macports.org/ticket/15719
20:09:57 <lambdabot> Title: #15719 (GHC 6.8.3 needs new cabal, cabal-install) - MacPorts - Trac
20:10:04 <povman> dogbite: until then, get them off hackage and build them manually
20:10:48 <byorgey> dogbite: you can download the HTTP and zlib packages from hackage.haskell.org
20:11:26 <ddarius> dogbite: Install HTTP >= 3000 && <30002 and zlib >=0.4
20:11:28 <byorgey> dogbite: secure in the knowledge that these are the last dependencies you will ever have to install manually. =)
20:12:14 <dons> dogbite: yeah, just those two to get hold of.
20:15:56 <dogbite> okay will do and report back, thanks
20:17:12 <sandbox> is yi 0.4 kinda broken or am I just stupid?
20:18:53 <SamB> sandbox: probably the former, and likely the latter too
20:19:00 <SamB> since you are a mere human
20:19:04 <SamB> ;-P
20:19:09 <dons> hey, this is really good, http://geekrant.wordpress.com/2008/06/23/misconceptions/
20:19:10 <lambdabot> Title: Some Haskell Misconceptions: Idiomatic Code, Purity, Laziness, and IO  Geek Ran ...
20:19:18 <dons> do we know the author?
20:19:18 <geezusfreeek> dons: thanks :)
20:19:22 <dons> ah ha!
20:20:28 <dons> if people just take away "Strictness is part of an algorithm, not a low-level optimization detail" that'll have achieve a lot o fgood
20:24:20 <dogbite> thanks guys -- installing HTTP and zlib manually did the trick.
20:25:36 <ddarius> geezusfreeek: I liked the first half, I disliked the second half and I liked the addendum.
20:25:57 <geezusfreeek> ddarius: i thought that may be how it is perceived. i am thinking about just dropping the second half
20:26:31 <geezusfreeek> i am not very clear, and am bordering on incorrect i suspect
20:28:40 <geezusfreeek> although if anybody has tips on how i might improve that portion i am all ears
20:29:31 <SamB> geezusfreeek: well, RealWorld really IS a hack
20:29:46 <geezusfreeek> well, it doesn't have a _value_
20:29:46 <ddarius> geezusfreeek: The whole "RealWorld" thing is just how GHC works, there are other and better ways of modelling IO, though none of them any more authoritative.
20:30:03 <geezusfreeek> i could be more clear on that part i guess
20:30:09 <SamB> I don't know that RealWorld is actually a way of modeling IO
20:30:45 <geezusfreeek> i will insert a note somewhere that although i say this is how it actually works that it's really just a way to make the types enforce purity
20:30:45 <SamB> I was under the impression that it was just a way to make the strictness right
20:31:17 <ddarius> SamB: The ordering not the "strictness"
20:31:38 <Pseudonym> If RealWorld were linear, it would be a sensible model of IO/
20:31:49 <ddarius> SamB: But world passing isn't completely unreasonably, see Clean.
20:31:49 <SamB> okay, a way of tricking the strictness analyzer into enforcing the correct ordering
20:32:04 <mjrosenb> does streamfusion understand inverses?
20:32:04 <ddarius> SamB: The strictness analyzer is irrelevant.
20:32:21 <SamB> ddarius: that's what RealWorld is for in GHC's implementation...
20:32:38 <ddarius> SamB: The strictness analyzer doesn't even run for -O0.  IO still works without optimizations.
20:32:41 <SamB> well, okay, maybe not just the analyzer
20:32:45 <dogbite> one more related question: i now need to install 'happy' because cabal told me i did
20:32:50 <dogbite> but when i try to do that i'm told
20:32:51 <dogbite> Warning: No 'build-type' specified
20:33:00 <SamB> but making the strictness enforce the ordering
20:33:04 <dons> since its a singleton, unforgable type, it works well enough as a unique value
20:33:08 <dons> dogbite: build-type: Simple
20:33:17 <dons> dogbite: oh, the warning is harmless
20:33:17 <SamB> dons: but it is forgeable
20:33:28 <SamB> dons: see unsafePerformIO
20:33:31 <ddarius> SamB: It's just data dependencies, there is no need to bring in strictness.
20:34:15 <SamB> ddarius: I can't remember the difference anymore ;-)
20:34:25 <dons> SamB: unsafe* doesn't matter for this discussion.
20:34:47 <ddarius> SamB: Data dependencies have nothing to do with strictness, otherwise a lazy language would be strict.
20:35:00 <SamB> geezusfreeek: oh, btw, unsafeInterleaveIO doesn't actually break purity
20:35:02 <dogbite> oh, right -- just a warning message. silly me
20:35:06 <dogbite> dons: thanks
20:35:07 <SamB> because you can't catch it in a lie
20:35:34 <geezusfreeek> SamB: could you explain what you mean?
20:35:57 <ddarius> In one sense you can't, in another, more pragmatic sense, you sure can.
20:36:07 <SamB> geezusfreeek: they behave in a very unintuitive manner, but they don't break referential transparency
20:37:13 <ddarius> @index unsafeInterleaveIO
20:37:13 <lambdabot> System.IO.Unsafe
20:37:17 <Cale> SamB: well, there are some rather funny things you can construct though... for example, a list of Integer elements whose values are the order in which you've evaluated them
20:38:56 <ddarius> @hoogle randomRIO
20:38:57 <lambdabot> System.Random.randomRIO :: Random a => (a, a) -> IO a
20:39:02 <ddarius> @hoogle randomRIOs
20:39:02 <lambdabot> No matches found
20:39:08 <ddarius> @hoogle randomRsIO
20:39:08 <lambdabot> No matches found
20:39:13 <ddarius> @hoogle random
20:39:13 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
20:39:13 <lambdabot> System.Random :: module
20:39:13 <lambdabot> System.Random.Random :: class Random a
20:39:16 <ddarius> @hoogle randomR
20:39:17 <lambdabot> System.Random.randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:39:17 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
20:39:17 <lambdabot> System.Random.randomRIO :: Random a => (a, a) -> IO a
20:39:39 <SamB> Cale: yes, but from the program's point of view, it can't prove that they didn't just happen to be in that order...
20:42:06 <ddarius> Hah
20:42:39 <SamB> ddarius: hah what?
20:42:41 * ddarius made a typo: mapM_ instead of mapM in unsafeInterleaveIO $ mapM_ (\x -> print x >> return x) [0..] and proved my point even stronger.
20:47:52 <geezusfreeek> :t  unsafeInterleaveIO $ mapM_ (\x -> print x >> return x) [0..]
20:47:58 <lambdabot> Not in scope: `unsafeInterleaveIO'
20:48:13 <ddarius> System.IO.Unsafe.unsafeInterleaveIO
20:48:16 <geezusfreeek> :t System.IO.Unsafe.unsafeInterleaveIO $ mapM_ (\x -> print x >> return x) [0..]
20:48:18 <lambdabot> IO ()
20:48:26 <geezusfreeek> :t System.IO.Unsafe.unsafeInterleaveIO $ mapM (\x -> print x >> return x) [0..]
20:48:27 <lambdabot> forall a. (Enum a, Num a) => IO [a]
20:49:00 <geezusfreeek> :t mapM_
20:49:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:49:26 <geezusfreeek> oh, i was thinking mapM_ :: Monad m => (a -> m ()) -> [a] -> m ()
20:49:34 <geezusfreeek> but that makes sense, n/m
20:52:06 <mmorrow> i just wrote a QuasiQuoter for Text.Regex.PCRE called regexqq and the cabal/darcs package is at: http://code.haskell.org/~morrow/code/haskell/regexqq/
20:52:06 <lambdabot> Title: Index of /~morrow/code/haskell/regexqq
20:52:11 <mmorrow> here's a sample:
20:52:13 <mmorrow> ghci> :m + Text.Regex.PCRE.QQ
20:52:13 <mmorrow> ghci> [$rx|([aeiou]).*(er|ing|tion)([\.,!\?]*)$|] "helloing.!?!?!"
20:52:13 <mmorrow> Just ["elloing.!?!?!","e","ing",".!?!?!"]
20:52:25 <mmorrow> yay!
20:53:07 <mmorrow> docs are here: http://code.haskell.org/~morrow/code/haskell/regexqq/docs/
20:53:12 <geezusfreeek> mmorrow: hackage it
20:53:29 <mmorrow> i'm gonna for sure...
20:53:44 <mmorrow> the only "little" thing is that quasiquotes aren't in 6.8
20:54:15 <mmorrow> well, maybe they're in 6.8.3, could someone try
20:54:23 <mmorrow> ghci> :set -XQuasiQuotes
20:54:30 <mmorrow> in ghc 6.8.3??
20:55:02 * geezusfreeek needs to upgrade to 6.8.3 anyway
20:55:16 <povman> unrecognised flags: -XQuasiQuotes
20:55:34 <mmorrow> geezusfreeek: you might as well darcs get ghc-HEAD!
20:55:42 <mmorrow> povman: crap!
20:55:56 <dolio> Quasiquoting is slated for 6.10, maybe.
20:56:08 <mmorrow> it's been in 6.9 since..
20:56:14 * mmorrow checks darcs changes...
20:56:20 <geezusfreeek> mmorrow: i'm always afraid of it breaking something, though i know i shouldn't be
20:56:53 <dolio> Oh, it's already in? I wasn't sure from the 6.10 roadmap page.
20:56:57 <povman> mmorrow: http://community.haskell.org/~audreyt/qq-6.8.3.diff
20:57:14 <mmorrow> 4589:Fri Jan 18 08:55:03 CST 2008  simonpj@microsoft.com
20:57:14 <mmorrow> 4590:  * Add quasi-quotation, courtesy of Geoffrey Mainland
20:57:24 <mmorrow> povman: sweet!
20:57:28 <dolio> Oh, nice.
20:58:02 <mmorrow> geezusfreeek: sure. but you could always be sporting *both* 6.8.3 and HEAD...
20:58:27 <geezusfreeek> i haven't yet learned if/how i could use cabal-install with that setup cleanly
20:58:37 <geezusfreeek> and i really like cabal-install
20:58:50 <mmorrow> dolio: you should check out QQ, the possibilities are *endless*
20:59:06 <dolio> Yeah, I skimmed the paper. It looked pretty hot.
20:59:13 <mmorrow> yeah
20:59:49 <dolio> Since it's in, I'll have to play with it some.
20:59:55 <mmorrow> do it
20:59:59 <mmorrow> :)
21:00:42 <mmorrow> i stuck this line in my .ghci (makes like soo much easier)
21:00:43 <povman> at least you can visually differentiate between real code and qq code, unlike lisp
21:00:43 <mmorrow> :set -XQuasiQuotes -XTemplateHaskell
21:00:58 <mmorrow> totally. imagine SQL in there
21:01:04 <mmorrow> *total* separations
21:01:17 <dolio> Does it need template haskell enabled?
21:01:24 <mmorrow> and you could preproc it at compile time however you want
21:01:29 <mmorrow> dolio: yeah
21:01:54 <mmorrow> i put the newest template-haskell docs at: http://code.haskell.org/~morrow/code/haskell/misc/template-haskell-HEAD_080623/
21:01:54 <lambdabot> http://tinyurl.com/5qyynk
21:02:01 <mmorrow> since they're not on the libs page yet
21:02:20 <mmorrow> (in particular, Language.Haskell.TH.Quote)
21:03:00 <povman> what's the difference between qq and parsing a string?
21:03:27 <povman> apart from evaluation time..
21:04:58 <mmorrow> you get everything in the [$<id>|...here...|] as a string during compilation, you can then parse it (typecheck it, ...) still at sompile time, the you have to turn it in to an ExpQ
21:05:22 <mmorrow> all a quasiquoter is is
21:05:30 <mmorrow> data QuasiQuoter
21:05:30 <mmorrow>     = QuasiQuoter { quoteExp :: String -> Q Exp,
21:05:30 <mmorrow>                     quotePat :: String -> Q Pat}
21:05:46 <povman> oh patterns :)
21:05:49 <mmorrow> so, if you define
21:06:12 <mmorrow> myqq = Quasiquote (litE . stringL) (litP . stringL)
21:06:24 <mmorrow> you now have yourself the id QuasiQuoter
21:06:46 <mmorrow> the ExpQ's get evalled during splicing back to their original strings
21:07:03 <mmorrow> and the PatQs become matching literal strings
21:07:03 <povman> so [$myqq|14|] -> 14?
21:07:13 <ddarius> "14"
21:07:25 <povman> ah
21:07:25 <mmorrow> case asdf of [$rx|[a-e]*|] -> 9
21:07:37 <povman> good grief
21:07:38 <mmorrow> povman: exactly
21:07:51 <mmorrow> and that's *all* there is to it
21:08:04 <mmorrow> but look at the paper and be like "holycrap"
21:08:37 <mmorrow> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
21:08:40 <lambdabot> http://tinyurl.com/yo9sa3
21:08:42 <mmorrow> http://haskell.org/haskellwiki/Quasiquotation
21:08:43 <lambdabot> Title: Quasiquotation - HaskellWiki
21:08:52 <mmorrow> ok i gotta run :)
21:09:34 <povman> thanks mmorrow
21:09:54 <povman> so [|...|] becomes like [$haskell|...|]
21:11:15 <mmorrow> povman: *exactly*
21:11:19 <povman> aha
21:11:27 <mmorrow> :)
21:11:32 <povman> orsm
21:14:40 <thoughtpolice> QQ and comprehensive comprehensions look fun. :) i'll definitely have to check out the HEAD sometime this week.
21:16:30 <povman> sql would be really nice...
21:16:41 <povman> or, heh, java...
21:22:46 <dolio> Heh.
21:22:59 <dolio> The paper actually has an embedded C-like language.
21:25:31 <HunterXHunter2> @unpl ((.)$(.))
21:25:32 <lambdabot> (\ b c e f -> b c (e f))
21:26:06 <HunterXHunter2> > (==) 1 ((1+) 0)
21:26:08 <lambdabot>  True
21:26:20 <mauke> @unpl ((.).(.))
21:26:21 <lambdabot> (\ i b c f -> i (b c f))
21:26:28 <HunterXHunter2> @unpl ((.).(.))
21:26:29 <lambdabot> (\ i b c f -> i (b c f))
21:27:07 <HunterXHunter2> @unpl f >>= a . b . c =<< g
21:27:07 <lambdabot> (f >>= \ h -> a (b ((g >>= c) h)))
21:30:39 <solrize> @seen japple
21:30:39 <lambdabot> I haven't seen japple.
21:37:36 <solrize> re dons' link further up, someone from galois a while ago proposed (f $!! x) should evaluate x to rnf instead of whnf, and similarly for data constructors  (Foo !!Bar !!Baz)   that would cure a lot of strictness woes that strict-to-whnf annotations leave as space leaks
21:38:16 <ddarius> solrize: Not in my opinion.
21:38:53 <ddarius> solrize: To use it properly you'd have to understand what is going on and if you understood what was going on you wouldn't need them.
21:39:24 <adu> ddarius: that actually made sense
21:41:46 <ddarius> Also, I think DeepSeq or the Control.Parallel module with NFData already defines $!! to be rnf.
21:48:15 <adu> grrr
21:48:26 <adu> HOC builds, but does not install
21:48:36 <scodil> is it always true that seq and $! are unnecessary when the expression appears as the argument to a constructor with strict fields?
21:48:53 <ddarius> Yes.
21:48:59 <scodil> ok
21:49:11 <ddarius> They're potentially worse than unnecesary
21:49:17 <adu> I fear I must cabalize HOC before it will install
21:49:36 <povman> adu: was it much work getting it to compile?
21:49:59 <solrize> well, we've all seen N instances of someone trying to fix space leaks by spewing $! into more and more places in the program until the leaks go away, where $!! in one place would fix the whole thing
21:50:23 <adu> povman: with ghc-8.6.3 it was easy:
21:50:27 <adu> povman: http://hpaste.org/8485
21:50:44 <povman> wow
21:50:52 <ddarius> solrize: I've seen less of those than instances where one or a few $! would fix the whole thing.
21:51:15 <povman> is there a good tutorial on how to use $! properly?
21:51:18 <adu> povman: but the .conf files are not cabalized
21:51:36 <ddarius> solrize: foldl (flip (:)) [] is O(n) reverse, foldl' (flip (:)) [] is identical, foldl'rnf (flip (:)) [] is O(n^2) reverse.
21:52:22 <ddarius> povman: The Stack_overflow wiki page and the Performance/Accumulating_parameter page should help.
21:52:38 <solrize> ddarius yeah but all of those are way obscure
21:52:52 <ddarius> solrize: ?
21:53:15 <solrize> it's rare in examples i've seen to want more than one or two levels of unevaluated thunks in anything
21:53:38 <adu> is it possible to install manually? or is that black magic?
21:56:10 <ddarius> solrize: How is that a response to anything I've said?
21:56:49 <solrize> a natural implementation of reverse wouldn't work like that
21:56:55 <enzo_> Question: is it not possible to a function to have type IO () -> Html ?
21:56:56 <solrize> or anyway wouldn' t look like that
21:57:27 <povman> enzo_: you can do that
21:57:35 <geezusfreeek> enzo_: it is possible, but not normally recommended
21:57:38 <enzo_> without an instance for IO Html that is
21:57:45 <ddarius> solrize: What?
21:57:47 <ddarius> @src reverse
21:57:47 <lambdabot> reverse = foldl (flip (:)) []
21:58:11 <enzo_> I keep having to unsafePerformIO... I hate it..
21:58:19 <povman> ew
21:58:24 <geezusfreeek> what is it you are doing?
21:58:55 <enzo_> writing a web application
21:59:05 <ddarius> enzo_: You are doing something horribly wrong.
21:59:23 <enzo_> I know =[
22:00:04 <geezusfreeek> enzo_: if you need to use data from an IO function in pure code then you should get the data by using the IO function in the top level and then apply the pure function to it there
22:00:23 <povman> enzo_:
22:00:25 <povman> @hpastew
22:00:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:01:00 <geezusfreeek> where "in the top level" means main or an IO function called either directly or indirectly through main
22:01:14 <enzo_> I think It's WAY to many lines of code for Hpaste
22:01:22 <enzo_> 300+
22:01:38 <mjrosenb> ok, do people here know about stream fusion?
22:01:54 <solrize> dons does :)
22:01:56 <ddarius> The creators are here, so yes.
22:02:12 <mjrosenb> that works
22:02:24 <mjrosenb> i have a very general idea of how it works
22:03:10 <mjrosenb> so let's say i'm dealing with some data with the type [Int]
22:03:26 <mjrosenb> and i have compress :: [Int] -> [Int]
22:03:37 <mjrosenb> and decompress :: [Int] -> [Int]
22:04:11 <mjrosenb> and it should hold that compress . decompress == decompress . compress == id
22:05:07 <mjrosenb> and the data is in a really strange format
22:05:25 <mjrosenb> it's first some compressed data, then some uncompressed data
22:05:52 <mjrosenb> and i know how much compressed data is gonig to be after i decompress it
22:07:35 <mjrosenb> so i want to do something like let (good, garbage) = split n $ uncompress datum in (good, compress garbage)
22:08:35 <audreyt> @seen dcoutts
22:08:35 <lambdabot> dcoutts is in #xmonad, #haskell, #haskell-overflow, #ghc, #haskell-soc and #gentoo-haskell. I last heard dcoutts speak 4h 49m 41s ago.
22:08:36 <mjrosenb> if i can convince it that all of the necessary identities hold, will stream fusion be able to do eliminate the (compress . decompress) from executing?
22:09:52 <audreyt> @tell dcoutts the "flag EnableReadLine ; default true" trick didn't work. On win32 cabal-install tried to install readline as part of dependency, and upon failure, did not revert to the "flag EnableReadLine" branch but instead died with "dependency ffailed to install". Is that perhaps a bug?
22:09:52 <lambdabot> Consider it noted.
22:09:58 <ddarius> mjrosenb: If you express your functions using the stream-based versions of the library functions and everything fuses and GHC can simplify the body to id, then yes.
22:11:01 <mjrosenb> is there any good way to tell if it's actually doing that rather than doing the composition?
22:11:02 <ddarius> I doubt compress . decompress == id is true though.
22:11:26 <ddarius> mjrosenb: See how many times the stream . unstream RULE fires and look at the core.
22:11:33 <mjrosenb> ddarius: it's a really stupid function, so yeah
22:11:58 <mjrosenb> ddarius: for now it's just going to be escaping/unescaping
22:14:45 <mjrosenb> alternitavely, is there a better way of doing what i want to do?
22:14:57 <mjrosenb> because it may have to do that several times
22:15:18 <mjrosenb> and doing n^2 operatioins when 1 suffices is depressing
22:16:26 <ddarius> There are other ways of doing what you want.  For example, you could reify the operations and simplify them symbolically at run-time and interpret the result.
22:17:44 <mjrosenb> oh hey, dcoutts is also on this paper
22:17:51 <mjrosenb> reifyL
22:17:53 <mjrosenb> ?
22:18:27 <ddarius> Instead of actually doing the operations, simply make a data type that represents them.
22:19:23 <mjrosenb> ddarius: you have a url with an example or something similar
22:19:45 <mjrosenb> i can take a guess as to what it is, but i'm not sure
22:20:38 <mmorrow> mjrosenb: this is nice looking: http://www.cs.york.ac.uk/fp/darcs/hhi/source/Syntax/Syntax.hs
22:21:18 <mmorrow> simple simplification: http://www.cs.york.ac.uk/fp/darcs/hhi/source/Compiler/Simplify.hs
22:21:19 <audreyt> @tell dcoutts and if I say "flag EnableReadLine { if os(win32) { default: False } else { default: True } }", it says cabal: 'parseField' called on a non-field. Consider this a bug.
22:21:19 <lambdabot> Consider it noted.
22:22:22 <mmorrow> nice translation between two abstract reps of _: http://www.cs.york.ac.uk/fp/darcs/hhi/source/Compiler/Prog.hs
22:23:06 <mmorrow> all that code in hhi is really nice
22:23:09 <ddarius> data Expr = Compress Expr | Decompress Expr | Id String; compress = Compress; decompress = Decompress; executeExpr (Decompress (Compress e)) = executeExpr e; executeExpr (Compress (Decompress e)) = executeExpr e; executeExpr (Id s) = s; executeExpr (Compress e) = realCompress (executeExpr e); etc.
22:23:46 <mmorrow> haha, i wish we could declare lexically spoped data in lets
22:23:49 <mjrosenb> so it's basically writing a haskell interpreter, then running that
22:23:57 <mmorrow> s/spoped/scoped/
22:24:17 <mmorrow> mjrosenb: so many different ways of thinking about the same thing
22:25:16 <mjrosenb> ddarius: thanks.  that helped alot
22:25:58 <ddarius> mjrosenb: You could also always simply add a RULE that rewrites decompress . compress to id.
22:26:16 <mjrosenb> ddarius: but isn't that done at compile time?
22:26:16 <ddarius> However, if that is not true, your code is going to behave strangely.
22:26:26 <ddarius> mjrosenb: So is stream fusion.
22:26:32 <mjrosenb> hrmm
22:26:47 * mjrosenb is'nt sure if this can be done properly at compile time
22:27:15 <hpaste>  adu pasted "HOC installed" at http://hpaste.org/8495
22:30:52 <Tordek> hi
22:31:16 <mjrosenb> hey
22:31:43 <solrize> http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi   what the heck happened to this?
22:31:44 <lambdabot> Title: Haskell Users Survey
22:31:47 <solrize> scroll down
22:32:06 <Tordek> I'm trying to make a function of type [a] -> [a] -> [Bool], which takes two lists of integers, and return an element-by-element comparison
22:32:38 <mjrosenb> Frenchman Xavier Peugeot is the great great grand nephew
22:32:40 <mjrosenb> excellent
22:32:43 <pgavin> > zipWith (>) [ 1,2,3,4,5 ] [ 6,5,4,3,2 ]
22:32:44 <lambdabot>  [False,False,False,True,True]
22:32:56 <Tordek> awesome, thanks
22:33:07 <pgavin> Tordek: homework?
22:33:19 <Tordek> no, just learnin'
22:33:34 <pgavin> k, just checking :)
22:34:01 <lokathor> @pf foo x = (isLower x) || (isUpper x)
22:34:01 <lambdabot> Maybe you meant: bf pl
22:34:03 <Tordek> having that list of bools, how can I count the trues?
22:34:19 <lokathor> @pl foo x = (isLower x) || (isUpper x)
22:34:20 <lambdabot> foo = liftM2 (||) isLower isUpper
22:34:38 <pgavin> lokathor: left isLower
22:34:44 <pgavin> errm
22:35:08 <lokathor> hmm? oh i don't care about the actual tests going on, i just picked something that came to mind
22:35:22 <lokathor> the PL result is what i wanted to see
22:35:28 <pgavin> arr (join (,)) $ isLower ||| isUpper
22:35:34 <pgavin> that's what I meant to write
22:35:41 <pgavin> it's not done yet, though
22:36:39 <pgavin> (join (,)) >>> (isLower ||| isUpper) >>> (uncurry (||))
22:36:41 <pgavin> there ya go
22:36:47 <lokathor> hmm
22:36:58 <pgavin> I think :)
22:37:01 <lokathor> that seems.. not easier
22:37:09 <pgavin> no, it's not right either
22:37:27 <pgavin> not |||, should be ***
22:37:39 <pgavin> (join (,)) >>> (isLower *** isUpper) >>> (uncurry (||))
22:38:25 <lokathor> i'm using Parsec, and there's a "satisfy" parser built in, and i was wondering if i could combine several Char->Bool with an || operation in a readable way, or if i'd just be better writing out the parser across a few lines
22:38:35 <pgavin> > ((join (,)) >>> (isLower ||| isUpper) >>> (uncurry (||))) 'A'
22:38:36 <lambdabot>  Couldn't match expected type `(a, a)'
22:38:50 <pgavin> > (join (,)) >>> (isLower *** isUpper) >>> (uncurry (||)) 'A'
22:38:51 <lambdabot>  Couldn't match expected type `(Bool, Bool) -> d'
22:39:09 <pgavin> ehh
22:39:31 <lokathor> no loss
22:39:35 <pgavin> lokathor: whatever is clearest is usually best :)
22:39:59 <pgavin> point-free is not always the best in that respect
22:40:25 * mjrosenb usually doesn't like point free
22:40:57 <pgavin> > (join (,)) >>> (isLower &&& isUpper) >>> (uncurry (||)) 'A'
22:40:58 <lambdabot>  Couldn't match expected type `(a, a)' against inferred type `Char'
22:41:06 <pgavin> :t (&&&)
22:41:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:41:37 <pgavin> > (isLower &&& isUpper) >>> (uncurry (||)) $ 'A'
22:41:39 <lambdabot>  True
22:41:48 <pgavin> > (isLower &&& isUpper) >>> (uncurry (||)) $ 'A'> (isLower &&& isUpper) >>> (uncurry (||)) $ '0'
22:41:49 <lambdabot>  Couldn't match expected type `Char'
22:42:00 <pgavin> doh
22:42:08 <pgavin> > (isLower &&& isUpper) >>> (uncurry (||)) $ '0'
22:42:09 <lambdabot>  False
22:42:18 <pgavin> there you go
22:43:18 <dobblego> can quickcheck test code in IO?
22:48:53 <mmorrow> omg regexes
22:48:56 <mmorrow> ghci> tail `fmap` [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
22:48:56 <mmorrow> Just ["-","3","141592653589793"]
22:51:20 <quicksilver> mmorrow: it's going to take me a while to get used to QQ syntax.
22:51:35 <quicksilver> mmorrow: the concept is awesome, the syntax is ugly :)
22:51:53 <mmorrow> quicksilver: heh, it slowly grew on me
22:52:05 <mmorrow> now it looks pleasant
22:52:19 <solrize> dobblego hmm, there's a library that i was just reading about, for that purpose, it simulates IO with a pure type constructor
22:52:35 <hackage> New hackage package: Pugs 6.2.13.4
22:53:22 <ddarius> @google IOSpec
22:53:24 <lambdabot> http://www.cs.nott.ac.uk/~wss/repos/IOSpec/
22:53:24 <lambdabot> Title: IOSpec
22:53:41 <Tordek> how can I count all the falses in a [Bool]?
22:53:54 <solrize> yeah, that :)
22:53:55 <ddarius> length . filter not
22:54:02 <quicksilver> length . filter (==False) $ mylist
22:54:38 <quicksilver> or if you like list comp syntax try "sum [ 1 | x <- mylist, x == False]"
22:54:57 <dons> > sum [ 1 | False <- [True,False,False] ] -- useful to remember
22:55:00 <lambdabot>  2
22:55:20 * dons likes this idiom for tagsoup html parsing
22:56:17 <solrize> haha
22:56:37 <solrize> what has happened there, the pattern match True <- False has failed to the empty list?
22:56:49 <solrize> False <- True, rather
22:57:11 <dons> things that don't match are filtered out ,a bit like pattern guards (which are inspired by this trick)
22:57:20 <dons> f x | Just n <- foo = n -- pattern guards
22:57:44 <dons> ?src catMaybes
22:57:45 <lambdabot> catMaybes ls = [x | Just x <- ls]
22:57:55 <dons> beautiful :)
22:58:00 <solrize> you mean the filtering is part of the listcomp sugar rather than a consequence of ptatern matching?
22:58:19 <dons> yep
22:58:29 <dons> well, pattern matching is involved.
22:58:29 <solrize> ic, neat
22:58:34 <mmorrow> let x = [$sql|select x,min(y) as y from s group by x|] in [$sql| select y,max(x) from $x group by y|]
22:58:48 <Tordek> . is replaceable by $, but not the other way around, or is there more to $ and . than "replacing parentheses"?
22:58:51 <mmorrow> (or something similar) would be sweet
22:58:55 <dons> ?src (.)
22:58:56 <lambdabot> (f . g) x = f (g x)
22:58:56 <lambdabot> -- In lambdabot, it's been generalised to:
22:58:56 <lambdabot> (.) = fmap
22:58:58 <dons> ?src ($)
22:58:58 <lambdabot> f $ x = f x
22:59:04 <geezusfreeek> DO WANT
22:59:18 <dons> Tordek: they're quite different.
22:59:28 <mmorrow> let (<>) = flip id in (*2)<>2
22:59:30 <mmorrow> > let (<>) = flip id in (*2)<>2
22:59:31 <dons> one is function composition, one is application of a function to its argument
22:59:31 <lambdabot>   add an instance declaration for (Num ((a -> a) -> c))
22:59:36 <quicksilver> Tordek: a.b.c.d.e$f is parsed as (a.b.c.d.e) $ f
22:59:42 <mmorrow> > let (<>) = flip id in (2*)<>2
22:59:43 <lambdabot>   add an instance declaration for (Num ((t -> t) -> c))
22:59:50 <mmorrow> :t flip id
22:59:51 <lambdabot> forall b c. b -> (b -> c) -> c
22:59:54 <dons> mmorrow: isn't that roughly the comprehensive comprehensions syntax?
23:00:00 <quicksilver> Tordek: and it's equivalent to a$b$c$d$e$f, which is parsed as (a$(b$(c$(d$(e$f)))))
23:00:32 <quicksilver> Tordek: however the reson they are equivalent requires a little thought to see.
23:00:35 <mmorrow> dons: i looked into that once, but was confused as to whether the syntax was finalized, or ever really finished...
23:00:48 <dons> mmorrow: there's a generalised version in ghc.
23:00:56 <quicksilver> Tordek: certainly in isolation (.) is quite different from ($).
23:01:00 <mmorrow> i would totally use it a bunch
23:01:13 <quicksilver> I think mmorrows suggestion goes quite a long way past comprehensive comprehensions.
23:01:29 <quicksilver> comp.comp is just bolting on a couple of bits of SQL into list comps.
23:01:46 <quicksilver> mmorrow is talking about embedding the entire of SQL as a quasi-quoted DSL.
23:01:52 <quicksilver> that's a bit of a different proposition :)
23:02:02 <mmorrow> :)
23:02:19 <mmorrow> how *are* they implemented though
23:02:30 <mmorrow> or i guess, at what level
23:03:21 <quicksilver> it's an extension to the list comprehension syntactic sugar
23:03:23 <Tordek> would the simplest example of difference be in map f.g a vs map f $ g a, the second of them being somewhat meaningless?
23:03:25 <quicksilver> there is a paper on it somewhere
23:03:49 <quicksilver> Tordek: well neither of them is meaningless but one has quite different types to the other.
23:04:00 <quicksilver> :t \f g a -> map f . g a
23:04:03 <lambdabot> forall t a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> (t -> f1 (f a)) -> t -> f1 (f b)
23:04:05 <quicksilver> :t \f g a -> map f $ g a
23:04:07 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
23:04:28 <Tordek> what's a functor?
23:04:46 <mmorrow> http://hackage.haskell.org/trac/ghc/wiki/SQLLikeComprehensions
23:04:48 <lambdabot> Title: SQLLikeComprehensions - GHC - Trac
23:04:53 <allbery_b> er, remember to do that withthe haskell defs, not the lambdabot defs
23:07:17 <mmorrow> list comprehensions are really handy, i've started using them more lately and i think i like it
23:10:18 <geezusfreeek> if i was to naively implement this structure http://en.wikipedia.org/wiki/Image:Btree.svg in haskell then changing the d7 leaf would mean the entire thing has to be recreated. is there a known general pattern to follow for structures like this in purely functional languages, or is it really just a case-by-case kind of deal?
23:10:19 <lambdabot> Title: Image:Btree.svg - Wikipedia, the free encyclopedia
23:10:36 <Tordek> :t \f g a -> map f ( g a )
23:10:38 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
23:10:58 <geezusfreeek> the point of interest i mean is that the linked list at the leaves short circuits the tree
23:11:34 <geezusfreeek> i'm not trying to do anything like this right now. i am just curious
23:15:53 <adu> Tordek: do you know what a category is?
23:16:17 <silver> Top of the evening to you all
23:16:25 <adu> hi silver
23:16:28 <Tordek> >_< GHC takes forever to compile
23:16:34 <Tordek> no, adu, I don't
23:16:46 <silver> I'm new to Haskell, attempting to do a self study
23:17:02 <adu> silver: I suggest you study GHC instead... lol
23:17:09 <silver> GHC?
23:17:18 <adu> silver: instead of 'self'
23:17:28 <adu> n/m
23:17:37 <geezusfreeek> Tordek: the simplest explanation of Functor in the context of Haskell would be "anything for which a definition of fmap makes sense"
23:17:45 <geezusfreeek> :t fmap
23:17:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:18:02 <adu> silver: GHC is the Glasgow Haskell Compiler
23:18:20 <geezusfreeek> Tordek: for example, (a -> b) -> [a] -> [b], (a -> b) -> IO a -> IO b, etc.
23:18:20 <solrize> tordek  http://en.wikibooks.org/Haskell/Category_theory is well worth reading if you really want to understand haskell types
23:18:31 <audreyt> @tell dcoutts also, does Cabal in general ignore version tags? "cabal install regex-tdfa-0.92-ghc-68-build-fix" doesn't seem to work for some reason...
23:18:32 <lambdabot> Consider it noted.
23:19:00 <silver> Are there any books you recommend
23:19:05 <adu> Tordek: a more mathematical definition is that a Functor is a map from objects to objects and morphisms to morphisms
23:19:25 <solrize> silver, http://realworldhaskell.org
23:19:27 <lambdabot> Title: Real World Haskell
23:19:35 <dons> audreyt: yeah, that's right.
23:19:41 <silver> I have very little background in functional programming, a fair amount in OOP and am a Graduate student in Mathematics
23:19:46 <dons> audreyt: the regex-* forks are confusing for cabal
23:20:06 <geezusfreeek> silver: ah, then you probably won't settle for the Haskell-only explanation ;)
23:20:10 <dons> audreyt: btw, should i be putting the latest pugs uploads into arch linux? or are there regular stable releases to wait on?
23:20:24 <dons> you're releasing via hackage now?
23:20:45 <adu> silver: then you probably already know monads
23:20:47 <audreyt> yes I'm releasing via hackges now, at least for x.y.z.w releases
23:20:52 <audreyt> x.y.z releases goes to CPAN
23:20:55 <solrize> @go YAHT
23:20:56 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
23:21:07 <solrize> silver: http://en.wikibooks.org/wiki/Haskell/YAHT
23:21:08 <luqui> hahaha
23:21:08 <audreyt> the last two .w releases were there just to fix win32 build when no readline is available
23:21:16 <dons> audreyt: ok.
23:21:31 * luqui is (er, was) also a grad student in mathematics and had almost no introduction to category theory the whole time
23:21:42 <dons> audreyt: they go straight into arch, just so you know, http://aur.archlinux.org/packages.php?ID=17958
23:21:43 <lambdabot> Title: AUR (en) - pugs
23:21:47 <audreyt> dons: thanks!
23:22:01 <audreyt> dons: what do you think about a general solution of builtin-ness? I mean, having to release a regex-pcre-builtin and regex-pcre is unsatisfactory
23:22:01 <silver> I'm doing Topology personally
23:22:22 <dons> audreyt: hmm. you could take over regex-pcre
23:22:38 <dons> it just has pcre.c bundled ?
23:22:41 <audreyt> yes.
23:22:56 <audreyt> the same as you did on sqlite3, but instead it builds the builtin one by default
23:22:56 <Tordek> okay, thanks for the help
23:23:02 <Tordek> I'm gonna go to sleep now
23:23:05 <dons> right. i do that for some other things too
23:23:05 <Tordek> see ya!
23:23:12 <dons> hgeometric, mersenne-random
23:23:14 <silver> Thanks a lot everyone, I am sure I'll be back soon
23:23:15 <adu> silver: do you know what a monoid is?
23:23:22 <audreyt> which iirc would be sane if we can somehow track upstream version too as part of version or some metadata
23:23:31 <silver> a monoud, no it does not sound familiar
23:23:41 <silver> monoid
23:23:44 <dons> audreyt: i'd mail chris about it, and libraries@ . my view would be to just give you regex-pcre to look after
23:24:01 <audreyt> nod, but it'd be cool if we can use the same flag...
23:24:06 <dons> yeah
23:24:11 <adu> silver: its an associative magma with identity
23:24:15 <audreyt> i.e. builtin-sqlite3 defaults to the value of the "builtin" flag
23:24:18 <audreyt> or something like that.
23:24:30 <dons> that's not a bad idea.
23:24:37 <dons> have it as one of the conventional flags
23:24:40 <audreyt> but current cabalconf doesn't quite support that
23:24:42 <dons> yeah, i like that idea.
23:24:46 <dons> right
23:24:53 <dons> dcoutts experties.
23:25:04 <audreyt> flag builtin-sqlite3: default Null
23:25:19 <audreyt> if IfNull( flag(builtin-sqlite3) , flag(builtin) )
23:25:23 <mmorrow> silver: you'll love haskell
23:25:24 <audreyt> -- _not_ the ideal syntax
23:25:29 <audreyt> but the general idea is that
23:26:08 <audreyt> k. I'll also want to upload a new version of regex-tdfa that fixes it for GHC 6.8 properly
23:26:13 <solrize> what's the name of that french math guy with the haskell blog?
23:26:20 <audreyt> since the current fork-by-branch-tagging way can't be handled by cabal
23:26:24 <audreyt> brb
23:26:56 <silver> mmorrow: I think you are right, I have been coding in Java, but functional programming sounds more in line with what I do
23:27:17 <solrize> http://www.alpheccar.org/en/posts/index
23:27:17 <lambdabot> Title: alpheccar's blog - Index
23:27:23 <silver> It also seems to be more generally applicable than CAS such as Mathematica
23:28:26 <silver> adu: ok, I see, so its like a semi-group in a way
23:28:37 <mmorrow> silver: oh yeah, well...
23:29:46 <mmorrow> i'd say it's more applicable in that it's more general purpose than Mathematica/etc
23:29:52 <silver> it seems like a group without inverses (glancing at wikipedia)
23:30:33 <mercury^> semigroups have no identity
23:30:40 <mmorrow> while at the same time being constantly integrating something new
23:31:05 <silver> well, I suppose I should have saud groupoid
23:31:10 <silver> technically
23:31:51 <silver> ok, i'm obviously tired!
23:32:03 <mmorrow> in haskell you can exactly capture the situation there and precisely specify in prob under 40 lines
23:32:07 <mercury^> groupoid in both of its meaning is not equivalent to a monoid either :>
23:32:14 <adu> silver: yes, in fact semi-group is an old term for monoid
23:33:03 <silver> semi-group was how I learned it, in fact prior to tonight, I had never heard the term monoid- good to know
23:33:07 <adu> silver: but anyways, the point was that monoids crop up in haskell
23:33:49 <adu> silver: many math concepts find their way into haskell
23:33:51 <silver>  was reading through the Haskell 98 tutorial and did get a sense of rich group and ring theory lurking in the background
23:33:52 <vixey> SamB: I have Reader, but I did have to take the axiom of extentionality
23:34:33 <vixey> haven't actually figured out cont still..
23:35:51 <silver> adu: I look forward to that
23:36:15 <adu> wow my super numeric prelude is #4 on google!
23:36:19 <adu> http://hpaste.org/7891
23:37:48 <silver> adu: you really like Absract Algebra don't you?
23:37:54 <adu> :)
23:38:24 <silver> Ever look into Simplicial Topology or Homolgy group theory?
23:38:42 <silver> Thats what I do for fun
23:38:43 <luqui> what is that language -- I want to say OCaml -- that does ADTs using open tagged unions?
23:39:14 <adu> silver: nope
23:39:24 <luqui> so Maybe Int would be represented as, like, `Nothing () | `Just Int
23:39:47 <adu> silver: the only brush I've had with Homology is sheaf theory
23:40:07 <vixey> SamB: oops not extensionality, I meant eta
23:41:53 <silver> adu: Its cool stuff, you can characterize all surfaces- topologically speaking, by means of group theory, Homology essentially allows you to determine things like how connected a surface is, how many holes exist, etc...
23:42:28 <adu> silver: I can tell that by looking tho
23:42:49 <silver> Then from there, the imagination goes wild, String theory (if you are not morally opposed to it) is built on a foundation of topology and other such abstract forms of mathematic
23:42:55 <vixey> I had a nice realization
23:42:59 <adu> and I can still tell the difference between a donut and a coffee cup
23:43:18 <silver> perahpes in 3 space you can! ;)
23:43:29 <mmorrow> i like dipping the donut in the coffee. while wearing an innertube.
23:43:31 <vixey> and/or trees are a ring
23:43:32 <adu> hmm, i can't see if 4 space
23:43:45 <adu> silver: can you?
23:43:52 <vixey> and so logic programming can be interpreted as a fixpoint equation
23:43:59 <silver> nope, then ytou have to dip your doughnut in a Klein Bottle coffee cuo
23:44:09 <silver> cup*
23:44:15 <mmorrow> vixey: going toward a limit!
23:44:21 <adu> silver: I don't think string theory is required
23:44:26 <silver> can I visualize 4 space? no way
23:44:35 <adu> silver: I think everything can be explained with electrons and gluons
23:44:42 <vixey> can you really not visualize 4-space?
23:44:45 <mmorrow> vixey: (or co..depending on which way you're looking...)
23:45:48 <silver> well, I don't hink its possible to visualize 4 space in a geometic sense, but knowing patterns helps you represent 4-D functions using intuitive mind tricks like seeing the 4th dimension as another color or heat
23:46:18 <silver> adu: I have my thoughts of String Theory
23:46:58 <adu> I don't get string theory
23:47:13 <adu> theres no middle ground
23:47:18 <silver> O only know so much about it, but in my naiveness, I have to beg the question: If we cannot prove that it is true, and we cannot predict physical phenomena with it, whats the point?
23:47:44 <adu> who said we can't?
23:47:52 <silver> Physicsists
23:47:55 <adu> o
23:47:59 <adu> they must know
23:48:05 <silver> sorry about my bad spelling tonight
23:48:32 <dolio> There seem to be other areas that show moderately more promise, but they're not as popular as string theory.
23:48:36 <adu> that must be why I've never seen an end-to-end discussion of it
23:48:45 <mmorrow> sure, when the physicists aren't too busy with writing indices on stuff
23:48:58 <silver> The amount of energy required to probe the subatomic level deep enough to reach the sring level is so high, we would need a colider much larger than our largest one now
23:49:26 <mmorrow> and more indices!
23:49:35 <silver> I don't think String theory should be abandoned, I just hink it should be approached with caution
23:49:43 <mmorrow> i sub j j k `subsub` l
23:50:06 <silver> dolio: yes, I know some people try to merge some of those theories with string theory, such as membrane theory
23:50:36 <dolio> Well, I was thinking loop quantum gravity being one I've heard of.
23:50:40 <adu> like there was this one question my teacher asked in physics: What is the energy-level of an electron in a box? and I my answer was that it is only valid to discuss energy levels in the context of an atom, and an electron can't be in a box and an atom at the same time...
23:51:38 <dolio> Which is background independent, which is supposed to be good.
23:51:52 * vixey thinks about doing something with substructural type system today
23:51:54 <lament> what if you put an atom in a box?
23:52:17 <silver> dolio, never heard of that one, the loop in the name intrigues me though, sort of suggests homology theory!
23:52:30 <silver> or homotopy theory!
23:52:35 <adu> lament: hmm
23:52:58 <dolio> silver: I've mostly heard it mentioned in pop physics books, so I couldn't tell you. :)
23:53:07 <silver> adu: why do you say that energy only makes sense for an electron in an atom?
23:53:09 <adu> lament: i think "box" was short for finite potential well
23:53:27 <silver> dolio: gtocha :)
23:53:46 <adu> silver: not energy, energy-level
23:54:00 <adu> as in s,p,d,f
23:54:13 <dolio> The Trouble With Physics talks about it a little (probably the most I've seen), along with some other string-theory-competitors.
23:54:17 <silver> right, in a finite potential well energy is quantized into levels
23:54:41 <adu> maybe thats why I got the question wrong
23:54:58 <dolio> I think it actually mentions where the "loop" comes from, so if you want to find out, that'd be a place to look.
23:55:01 <silver> an atom (nucleous) is a finite potential well
23:55:03 <dolio> I just forget what it is. :)
23:55:23 <silver> dolio, I am familiar with the book, I will check it out
23:56:09 <silver> adu: Are you into linear algebra?
23:59:03 <mmorrow> silver: did you say you were just starting haskell? have you seen (?):     http://alberrto.googlepages.com/gslhaskell                   http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas
23:59:04 <lambdabot> Title: Alberrto - hmatrix
23:59:21 <mmorrow> gslhaskell is now hmatrix
23:59:40 <mmorrow> i love it when spacing just works out like that
