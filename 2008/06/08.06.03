00:00:01 <audreyt> oh wait, except there isn't one ;)
00:00:05 <jfredett> you could just say a headache
00:00:08 <psygnisfive> title is necessary, nor is doctype
00:00:13 <Twey> jfredett: Crap JS tutorials make my blood boil :-(
00:00:17 <sjanssen> @google inurl:haskellwiki jobs
00:00:18 <luqui> come on, haskell.org, get your act together!
00:00:19 <lambdabot> http://www.haskell.org/haskellwiki/Jobs
00:00:19 <lambdabot> Title: Jobs - HaskellWiki
00:00:30 <psygnisfive> its only required for strict XHTML stuff i believe, not HTML.
00:00:30 <Twey> psygnisfive: It's just as necessary as <html>
00:00:37 <Twey> You're wrong.
00:00:40 <psygnisfive> in whos spec?
00:00:43 <audreyt> sjanssen: I know :) it's just not jobs.perl.org which I was alluding to
00:00:55 <Twey> psygnisfive: SGML, so -- all of them.  Ever.
00:01:03 <jfredett> Twey: lol
00:01:11 <psygnisfive> lol.
00:01:14 <psygnisfive> guess what, twey
00:01:14 <sjanssen> audreyt: ah, that is pretty neat
00:01:19 <psygnisfive> HTML isnt SGML anymore. :P
00:01:32 <Twey> The specs are
00:01:46 <newsham> http://www.thenewsh.com/%7Enewsham/x/printf.html
00:01:47 <lambdabot> Title: Test page
00:01:48 <Twey> psygnisfive: http://validator.w3.org/ -- this'll catch your stupider mistakes
00:01:49 <lambdabot> Title: 81 The W3C Markup Validation Service
00:02:07 <mxc> i love th fourth entry on haskell jobs:
00:02:09 <Twey> It won't do subtle stuff like you're likely to encounter when playing with the DOM, though
00:02:14 <mxc> Erlang Training and Consulting Ltd
00:02:39 <jfredett> heh, I've been meaning to pick up erlang
00:02:57 <Twey> mxc: O.O
00:03:04 <mxc> dynamic typing scares me now
00:03:09 <mxc> twey - i dont get it
00:03:25 <Twey> Me neither :-\
00:03:25 <jfredett> dynamic typing just seems quaint to me, honestly
00:03:35 <Twey> Mmm it has its place.
00:03:52 <jfredett> it's like, "aww, look at the rubyists and pythonistas. aren't they cute with thier dynamic types"
00:03:54 <psygnisfive> twey, ok, but browsers do doctype overrides. but fine, sure, its not completely 100% valid html
00:03:55 <psygnisfive> :P
00:04:02 <jfredett> though, I still love scheme.
00:04:12 <solrize_> @pl \x->(foo x == 3)
00:04:12 <lambdabot> (3 ==) . foo
00:04:14 * luqui thinks that dynamic types and OO go well with each other...
00:04:20 <newsham> I still write more python code than haskell (mostly a function of the program sizes I typically write)
00:04:32 <Twey> psygnisfive: Just because a browser can struggle and error-correct it into shape doesn't mean that it's correct
00:04:53 <Twey> psygnisfive: Also, having the browser in quirks mode makes it a *lot* harder to write cross-browser code
00:05:01 <newsham> I dont need my compiler to prove program properties as often when I'm writing a program in 1hr and can keep all the details in my cache
00:05:03 <solrize_> dynamic typing is like putting together a jigsaw puzzle where all the pieces are 1x1 squares
00:05:05 <jfredett> Twey: to be fair, he did name the tutorial "Quick and Dirty Javascript"
00:05:08 <Twey> (because quirks modes vary between browsers far more than standards-compliance modes do)
00:05:16 <psygnisfive> ugh, kids these says with their "correctness"
00:05:16 <newsham> solrize: yah, great for prototyping :)
00:05:17 <Twey> jfredett: I haven't even got to the Javascript yet!  T_T
00:05:20 * luqui recalls that in the math world a proof is more-or-less "correct" if the reader can struggle and error-correct it into shape
00:05:53 <Twey> psygnisfive: Haskell is not the language for you.  Go away and learn COBOL or something.  :-P
00:06:07 <newsham> twey: thats not very friendly
00:06:13 <jfredett> luqui: it may be "correct" but it also gets ridiculed (along with it's author) by all those who read it.
00:06:35 <psygnisfive> twey: it doesnt help that i like dynamic typing ;)
00:06:45 <luqui> newsham, I think it was a joking retort to "kids these days with their 'correctness'"
00:06:50 <Twey> Aye
00:06:57 <luqui> (or even "kids these says [sic.] ..."
00:07:11 <luqui> (missing parenthesis [sic]
00:07:18 <mxc> actually, even side effects make me feel a little dirty at this point
00:07:26 <jfredett> I do so think, in any case, it is time for myself to get some sleep
00:07:40 <jfredett> it's 3am, thats late and shit. gnite ladies and germs.
00:07:49 <jfredett> and ERVs too.
00:07:50 <newsham> mxc: you can make good use of purity even when your language doesnt require you to
00:07:57 <Twey> 'night jfredett
00:08:03 <jfredett> and any other form of life out there, rock on!
00:08:14 <Twey> Haha
00:08:20 <newsham> ?vixen rock on
00:08:20 <lambdabot> i like that type of music too
00:08:23 <Twey> Ow, code as strings >.<
00:08:23 <olsner> ERV?
00:08:37 <newsham> twey: tcl?
00:09:03 <luqui> Endogenous retrovirus?
00:09:05 <Twey> newsham: His Javascript tutorial :-\
00:09:24 <dmwit> ?spell beuaraucracy
00:09:34 <psygnisfive> there, twey
00:09:36 <psygnisfive> replaced
00:09:38 <dmwit> *poke*
00:09:58 <psygnisfive> are you happy now you soulless beast?
00:10:26 <psygnisfive> twey, code as strings??
00:10:45 <Twey> psygnisfive: new Function() should never be used, there are no situations where it's necessary
00:11:09 <psygnisfive> there are some cases where it can be useful, but regardless, its part of the language.
00:11:17 <Twey> There aren't
00:11:26 <luqui> Twey, what is the alternative?
00:11:28 <newsham> function(dn) { return function(fn) { return fn(fn); }(function(fn) { return dn(function() { return fn(fn).apply(null, arguments); }); }); }
00:11:33 <psygnisfive> function(x,y){ ... }
00:11:37 <Twey> There's not one where it can't be replaced by a well-crafted closure
00:11:48 <Twey> Trust me, I've checked.  Extensively.  :-)
00:11:56 * luqui begs to differ
00:12:01 <luqui> not in js, but in perl
00:12:07 <Twey> luqui: Can't speak for Perl
00:12:15 <luqui> same diff really
00:12:19 <luqui> eval "" vs. new Function ()
00:12:29 <luqui> sub {} vs. function() {...}
00:12:45 <newsham> twey: whats the well crafted closure that lets you take in a user provided string and generate a javascript function based on it?
00:13:00 <psygnisfive> function(propname){ return new Function(propname, "return window." + propname); }
00:13:01 <psygnisfive> :)
00:13:02 <luqui> heh always to the extreme cases :-)
00:13:20 <psygnisfive> no actually that can be turned into a closure
00:13:20 <olsner> psygnisfive: function() { return window[propname]; }
00:13:30 <psygnisfive> shut up olsner you're not helping. :P
00:13:32 <newsham> ps: Flex (also based on ecma script) doesnt include arbitrary evals or Function()s.
00:13:44 <newsham> which can be a royal pain in the ass, for example if you want to write a parser fuzzer
00:13:48 <Twey> newsham: function a(a) { eval(a); } :-P
00:13:53 <newsham> or a test shell
00:14:04 <olsner> btw we're wildly off-topic discussing javascript closures here... move to #javscript or something?
00:14:07 <psygnisfive> anyway
00:14:14 <psygnisfive> i understand your dislike of them, twey.
00:14:17 <Twey> Yeah, true
00:14:19 <psygnisfive> but they're part of the spec
00:14:20 <psygnisfive> so
00:14:36 <luqui> so what?  I think if he was arguing anything it would be that the spec sucks...
00:14:50 <psygnisfive> well who disagrees with that, cmon
00:14:50 <psygnisfive> :P
00:14:51 <luqui> or that it doesn't suck, but right-minded programmers don't use that part of the spec
00:15:11 <luqui> like goto in C++. Except for when you get even more right minded and start using it again...
00:15:47 <luqui> (the definition of "right" is diverging from the original in this progression)
00:15:48 <newsham> goto in C++ is great when you want to implement a DFA
00:16:32 <olsner> wouldn't you rather use a loop?
00:16:45 <newsham> there's a cool parser generator paper where they generate an LALR(1) parser by spitting out the state machine as C using switches and gotos.
00:16:47 <luqui> with a bazillion state variables...
00:17:56 <olsner> ah, yes, goto can probably eliminate the state variable and replace it with a state implicit in the instruction pointer... in some cases at least
00:19:14 <newsham> http://www.cs.arizona.edu/people/todd/papers/TR95-09.ps
00:41:15 <solrize_> er, that's what yacc did 30 years ago...
00:42:26 <earthy> not really
00:42:39 <earthy> yacc generated a table-driven lalr(1) parser
00:42:57 <earthy> this paper seems to fold the table into code as well
00:43:03 <solrize_> hmm yeah ok, the tables were smaller than generating actual code, but conceptually the same thing
00:43:07 <solrize_> i think the gcc parser works like that
00:43:19 <solrize_> it takes the bison output tables and expands them into a huge nested switch
00:43:46 <earthy> yah, it's not really impressive
00:43:50 <solrize_> antlr may also be able to generate raw code
00:44:04 <solrize_> i dunno of one of those that combines the parser and scanner
00:44:08 <solrize_> that would be cool
00:44:18 <earthy> stratego
00:44:28 <solrize_> dunno what that is
00:44:40 <earthy> stratego/xt to be more exact
00:44:57 <solrize_> it would be really cool to compile parsec combinators straight into native code with extensive fusion and all that good stuff
00:45:04 <earthy> comes with an sglr parser
00:45:10 <solrize_> i haven't seen it, sounds nice
00:45:22 <earthy> scannerless generalized LR
00:47:17 <bos> @hoogle withForeignPtr
00:47:18 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
00:50:47 <qwr> http://linux.ee/~mzz/yeti/
00:50:49 <lambdabot> Title: Yeti programming language
01:08:28 <bos> @src fromJust
01:08:29 <lambdabot> fromJust Nothing  = undefined
01:08:29 <lambdabot> fromJust (Just x) = x
02:07:59 <Shimei> So I saw this livecoding performance using PLT Scheme, and had a thought. I wonder how Haskell would lend itself to something like this: http://www.youtube.com/watch?v=2O5DJTOy6EA
02:08:00 <lambdabot> Title: YouTube - Fluxus tutorial one
02:08:40 <Shimei> It would be neat to combat Haskell's academic stereotype with some art.
02:09:12 <codetoad> i noticed that the (GHC) definition of round includes:  (abs r - 0.5), where 0 < r < 0.5.  how can i deal with having a type, in this case my own defined Natural, that does not allow negatives (negate = error ..)
02:09:59 <codetoad> i guess i'd like to define my own round just for the type Ratio Natural (maybe more broad?) but i'm not sure how
02:12:11 <electronx> just wandering would it be possible to create a ruby on rails style framework in haskell?
02:13:32 <Saizan> what's the style of ruby on rails?
02:14:07 <Twey> Huge, slow, and full of magic *duck*
02:14:32 <electronx> lol
02:14:51 <electronx> but imaginge it in haskell it would be so productive and fast
02:15:08 <Twey> But still full of magic.  :-)
02:15:20 <quicksilver> hmm.
02:15:23 <quicksilver> magic duck.
02:15:26 <quicksilver> that sounds nice.
02:15:27 <electronx> but thats what makes it productive :)
02:15:41 <quicksilver> electronx: the answer is yes, of course it's possible.
02:15:53 <quicksilver> one might aim a little higher.
02:16:00 <electronx> :)
02:16:00 <quicksilver> try not to make all the design mistakes rails did.
02:16:17 <electronx> i don't know rails well enough to know its mistakes :)
02:16:36 <Shimei> Or be as slow. Lots of hype over Maglev, but that would, what, make ruby as fast as python? ;)
02:16:41 <electronx> i think that haskell is even simpler as a language then ruby
02:17:15 <electronx> maybe i'm wrong but i find learning haskell a bit easier
02:17:34 <luqui> lol
02:17:47 <electronx> i wonder whats the best site built in haskell is
02:18:10 <luqui> I know you were earnest, but it's just funny since haskell has the reputation for being the hardest language to learn   (I certainly found it more difficult than ruby)
02:18:57 <electronx> lol
02:19:08 <quicksilver> I think haskell is easier to learn than ruby if you don't have an imperative OO background
02:19:10 <quicksilver> bit hard to test that theory.
02:19:19 <electronx> i came with lots of prolog with me :)
02:19:19 <Shimei> electronx: I think that's pretty lucky of you, since I've heard a lot of CS students complain about how Haskell sucks and is line-noise, etc. etc.
02:19:32 <quicksilver> Shimei: I've heard lots of CS students complain about everything.
02:19:38 <electronx> lol
02:19:43 <quicksilver> Shimei: students are lazy, like to complain, and dislike using their brains.
02:19:56 <Shimei> Fair enough. Ah, the irony.
02:20:04 <quicksilver> haskell is not particular unique in attracting their invective :)
02:20:11 <quicksilver> you should hear what they say about java, say
02:20:14 <quicksilver> (or perhaps you have)
02:20:30 <Shimei> I complain about Java myself, so introspectively, yes. :p
02:21:11 <osfameron> some things about haskell are blindingly, magically simple, even to me coming from a procedural/oo background.  (Other things are not).
02:21:20 <Shimei> But it turns out that when I actually program in it for assignments, I enjoy doing them. So Java's not that bad.
02:21:23 <Saizan> well, it's not like they don't have a reason to complain about java..
02:21:47 <electronx> i thought ruby had too many "features" and things to remeber
02:22:22 <electronx> really enoyyed me because i was learning from a crap book but it was the only one that was up to date
02:22:45 <electronx> ruby is evolving fast i think
02:23:59 <Twey> Ruby does have a lot of magic
02:24:05 <Twey> It's on a fast track to become the next Perl
02:24:06 <cjs> Ruby does. It's got a lot of inconsistencies and extra baggage.
02:24:22 <dibblego> you call it magic; I call it a nightmare, each day
02:24:32 <cjs> Actually, they look to be unmagicing it a little bit in the next major release.
02:24:50 <luqui> I think in this group, dibblego, that's what people mean by the term
02:25:02 <osfameron> I quite fancy learning ruby (I find it hard to read even coming from a perl background)
02:25:07 <dibblego> luqui, that's great news :) and very encouraging
02:25:37 <cjs> Shimei: yeah. Just wait until you have to write a large, real world program in Java. That's when the pain starts.
02:26:04 <Shimei> cjs: I can imagine that being painful, especially with having to read other people's code.
02:26:19 <luqui> cjs, that statement has its causality backwards, I think.  Java causes it to be large...
02:26:57 <luqui> (and also real-world, in contrast to haskell ;-)
02:27:29 <Shimei> I vaguely like Ruby too, but on the other hand I don't know if it has enough pros to take it over other similar languages.
02:27:34 <codetoad> re my "round" question -- i can define instance RealFrac (Ratio Natural) to make my own round definition, but then I get an overlapping instance error
02:27:37 <dibblego> I've worked on the largest Java program on the planet and it is as far removed from "real-world" as all the other smaller ones I've worked on too
02:29:08 <luqui> codetoad, there may be some folks who can help you hack, but I think you are rather stuck by the poor definition of "round".
02:29:34 <luqui> codetoad, i.e. I don't believe there will be any clean solution to your problem
02:29:44 <luqui> as for dirty ones, I am not enough of a guru to say
02:30:09 <codetoad> luqui: should i suggest GHC change its round definition? :P
02:30:44 <cjs> Shimei: it's probably one of the better scripting languages out there. You should definitely chose it over perl. Whether you chose Ruby or Python is probably more of a "what do folks around me use" decision.
02:32:12 <audreyt> codetoad: {-# LANGUAGE FlexibleInstances #-}
02:32:12 <Shimei> cjs: Fair enough. Although I'd be tempted to consider lua (faster than ruby and smaller) or something else. if there were no concern of community size anyway. :p
02:32:21 <AllNight^> morning folks :)
02:32:22 * luqui questions choosing it over perl, if only for CPAN
02:32:23 <audreyt> codetoad: then you can define that instance
02:32:32 <AllNight^> eep! Perl!
02:32:39 <luqui> after working with lua for some time, I would not recommend it
02:32:46 * AllNight^ holds a cruficix between him & whoever mentioned Perl
02:32:47 <AllNight^> :)
02:33:19 <luqui> it has the same trouble with interop as C++, since there are many different object models and they do not work together
02:33:24 <audreyt> mmm crucifix. a new fixity category for perl5
02:33:28 <audreyt> er, perl6.
02:33:51 <luqui> sub cruicifix:<t>($leftarm, $rightarm)
02:34:16 <Shimei> luqui: Out of curiosity, what kinds of things did you work on lua with?
02:34:31 <luqui> Shimei, scripting for an MMO game
02:34:39 <Shimei> WoW? :p
02:34:50 <luqui> no, one that hasn't been released and which I promise will suck
02:35:16 <AllNight^> can I ask another quick haskell question? is there a way to define a list such that there is some (specified) TypeClass which all it's members must be members of?
02:35:26 <Shimei> Ah, I see. Interesting. I'd thought game development was one of lua's strong suits too.
02:35:39 <AllNight^> something _like_ foo :: [a::Iso] -> [a] -- which doesnt work
02:35:41 <AllNight^> :)
02:35:54 * luqui laughs.  in #haskell: "can I ask another quick haskell question?".  NO YOU MAY NOT!  What do you think this is!?
02:36:05 <AllNight^> sowwy
02:36:11 <Twey> Haha, a support room or something?
02:36:11 * AllNight^ hangs head in shame
02:36:14 <AllNight^> :P
02:36:17 <AllNight^> :)
02:36:19 <Twey> Honestly... these people
02:36:32 <Shimei> It's "programmers anonymous"
02:36:34 <Twey> AllNight^: (SomeTypeClass a) => [a]
02:36:46 <luqui> Twey, that is not quite the same
02:36:59 <luqui> AllNight^, what you want is something called "existential types", supported by a GHC extension
02:37:26 <Saizan> AllNight^: values in a list must have all the same type, if you really want them to be of different types but sharing a typeclass you've to use existential types
02:37:37 <Smokey`> re: lua convo before - Lua is used in Crytek, WoW, and I think id tech 4 used it too
02:37:46 <Twey> Oh, different types but all the same typeclass... OK
02:37:59 <audreyt> AllNight^: perhaps
02:37:59 <luqui> AllNight^, it's also likely that if you need existential types then you are thinking wrong :-)
02:38:01 <audreyt> newtype Show a => SList a = SList [a]
02:38:23 <AllNight^> ty Twey, audreyt, luqui :)
02:38:32 <audreyt> it's a newtype, so should be as fast as an ordinary list
02:38:50 <luqui> audreyt, that's a bad idea in my experience
02:38:59 <Twey> Lua is fast... nice little embedding language
02:39:06 <audreyt> luqui: why? it's not existential
02:39:21 <audreyt> (it's vanilla h98 newtype syntax iirc)
02:39:25 <luqui> oh I see, you were answering another possible interpretation of his question
02:39:34 <quicksilver> http://www.haskell.org/haskellwiki/Existential_type
02:39:35 <lambdabot> Title: Existential type - HaskellWiki
02:39:54 <luqui> though constraints on the data definition don't buy you the assumptions they should, they just add proof obligations
02:39:54 <audreyt> yeah. I agree that existentials should be avoided unless absolutely neccessary
02:40:23 <audreyt> right.
02:40:44 <luqui> i.e. in  "foo :: SList a -> SList a", we will not have an assumption of "Show a" like we should
02:41:28 * luqui ponders... if he were not afraid of the GHC code base, he would like to add an extension which adds said assumptions
02:41:45 <Saizan> luqui: just use gadt syntax and you've it
02:41:51 <audreyt> ah right. so it's not as useul as it sounds
02:42:04 <audreyt> Saizan: but then it will be existential and not a newtype (which is probably more correct)
02:42:34 <Saizan> audreyt: it can't be a newtype anyhow since it has to carry the dictionary around
02:42:45 <Saizan> but it won't necessarily be existential
02:42:47 <audreyt> right. and it doesn't have to a gadt:
02:42:49 <audreyt> data SList a = Show a => SList [a]
02:43:00 <audreyt> would be sufficient
02:43:22 <Saizan> i'm never sure if that provides the assumption or not :)
02:43:40 <audreyt> it does :)
02:44:00 <quicksilver> audreyt: it doesn't actually.
02:44:05 <quicksilver> erm
02:44:09 <quicksilver> sorry I misunderstood.
02:44:12 <quicksilver> no, I didn't,
02:44:24 <quicksilver> audreyt: that only provides the assumption under certain broken versions of GHC
02:44:29 <quicksilver> unless you turn on GADTs
02:44:32 <quicksilver> in which case it does.
02:44:38 <audreyt> all I did is turning on
02:44:39 <audreyt> {-# LANGUAGE ExistentialQuantification #-}
02:44:49 <audreyt> and then I can write foo :: SList a -> String
02:44:55 <audreyt> surely that's a supported language feature?
02:45:08 <audreyt> (GHC version 6.8.2.20080211)
02:45:16 <quicksilver> I think maybe your code doesn't mean what you think, in that case.
02:45:23 <quicksilver> I think the three 'a's are not the same
02:45:35 <quicksilver> should be just data SList = Show a => SList [a]
02:45:51 <audreyt> you mean
02:45:52 <audreyt> data SList = forall a. Show a => SList [a]
02:45:57 <quicksilver> I get confused by the various similar syntaxes.
02:46:02 <quicksilver> however I know the following:
02:46:14 <quicksilver> h98 constraints on data constructors do not provide contexts on deconstruction.
02:46:21 <quicksilver> in some versions of ghc they do (which is a bug)
02:46:33 <quicksilver> with GADTs turned on they do (which is not a bug, it's a feature)
02:46:49 <quicksilver> existentials work with the appropriate extension on.
02:47:02 <audreyt> mm. I'm seeing this from GHC:
02:47:05 <audreyt> Data constructor `SList` has a context (Use -XExistentialQuantification or -XGADTs to allow this)
02:47:22 <audreyt> so turning on either Existential or GADT would enable this feature
02:47:33 <audreyt> without either, it's a compiler error at the moment
02:47:42 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1901
02:47:43 <lambdabot> Title: #1901 (6.8.1 incorrectly infers contexts from pattern matches.) - GHC - Trac
02:47:46 <quicksilver> explains part of the issue
02:47:52 <quicksilver> without entirely resolving my own confusion :)
02:49:48 <b_jonas> something strange has just happened
02:50:07 <Saizan> funny that ExistentialQuantification enables this, nice way to expose implementation details :)
02:51:17 <quicksilver> Saizan: it's all a bit weird
02:51:26 <quicksilver> Saizan: see that bug report where it was accidentally enabled in 6.8.1
02:51:36 <quicksilver> Saizan: which made 6.8.1 h98 non-conforming
02:54:48 <Saizan> yeah, i recall when we discussed this and you reported the bug :)
02:55:39 <b_jonas> I requested the Okasaki: Purely functional data structures book on just Friday afternoon and I've just got an email it's arrived
02:55:40 <quicksilver> gosh, good memory.
02:55:51 <quicksilver> as you can see I can't remember the details myself.
02:55:57 <quicksilver> hence my garbled explanation to audreyt
02:56:17 <b_jonas> and it was an inter-library loan request and according to the catalogue the only copy was borrowed on Friday
02:57:09 <b_jonas> I think I know what I'll read today night :)
03:16:13 <AllNight^> luqui - the problem I was thinking about was say you had a Shape type class - becuase I want to keep the list of Shapes open ended ... and then I want to have a list of Shapes
03:16:28 * AllNight^ notes you saying needing existential types suggest I'm doing something wrong
03:17:01 <AllNight^> how else would you approach such a problem? (curious) :)
03:17:40 <luqui> AllNight^, right, that's a pretty OO-ish way to approach your problem.
03:17:57 <luqui> what is the problem, exactly?
03:18:08 <luqui> i.e. you're still talking in the domain of your solution :-)
03:18:28 <AllNight^> there isnt one... I'm just playing around with the language & seeing what I can & cant do - I'm a total newbie to Haskell
03:18:43 <AllNight^> though I do have experience with a number of other languages - including Java & Lisp
03:18:55 <luqui> Well in that case, existential away!
03:19:21 <AllNight^> so I probably do have an OOish mindset .. but I'd like to grok the Haskell mindset
03:19:29 <AllNight^> so I'm wondering where it differs :)
03:19:43 <electronx> #jruby
03:19:45 <luqui> it differs at a point higher level than your question... basically.
03:19:55 <luqui> hard to put it into words.
03:20:07 <luqui> I probably don't know myself.  I have trouble thinking in OO these days.
03:20:12 <b_jonas> is there any language in which yuo can you get a list of all Shapes if shape is an open-ended supertype/class/interface?
03:20:17 <mm_freak_work> is it evil to use GADTs, when i don't actually need them?
03:20:21 <luqui> (which is related to my not programming in an OO language for a year I suspect)
03:20:22 <mm_freak_work> i like the syntax =)
03:20:34 <wolverian> b_jonas, I think ruby lets you query the objectspace
03:20:53 <b_jonas> wolverian: yeah, you might be able to do such debugging tricks in other languages too
03:20:57 <luqui> yes, ruby and smalltalk come to mind
03:21:13 <luqui> but I don't think that's what AllNight^ is asking
03:21:19 <b_jonas> but it's deeper than just normal introspection
03:22:12 <b_jonas> mm_freak_work: I think it's not evil, provided you know exactly how they work and so you're sure you're just using the syntax part
03:22:20 <AllNight^> yes b_jonas - you could do it with say generics in Java List<Shape>
03:22:23 <b_jonas> but wait for real haskeller's opinion
03:22:45 <b_jonas> AllNight^: I think I'm considering a different question than you then
03:22:59 <AllNight^> although as Lists are mutable in Java you then run into the problem that List<Circle> is not a subtype of List<Shape>
03:23:09 <wolverian> AllNight^, perhaps you want a typeclass.
03:23:10 <b_jonas> I was thinking of getting the list of all subclasses/interfaces of shapes that currently exist
03:23:23 <mm_freak_work> b_jonas: i'm concerned, because GADTs are not haskell 98 and the next haskell standard is going to take some time, as it looks
03:23:42 <wolverian> AllNight^, this is in some ways quite ugly to do in haskell, if you want to get at the properties of Circles and Squares and such, partly because the record system sucks.
03:23:54 <wolverian> AllNight^, but, in any case, I suspect you want typeclasses.
03:24:28 <AllNight^> my thought was to create a Shape typeclass wolverian - and somehow define a list of shape
03:24:29 <b_jonas> AllNight^: so you just wanted a list that can contain different shapes?
03:24:36 <wolverian> AllNight^, sure.
03:24:44 <b_jonas> sorry for the misunderstanding
03:24:48 <wolverian> that works fine. :)
03:24:48 <AllNight^> yes - but keeping the list of shapes open ended b_jonas - which rules out using a sum type
03:24:50 <pejo> mm_freak, what tools are you using that only understands h98?
03:24:57 <b_jonas> well in that case I think you can do two things in haskell
03:25:15 <AllNight^> np (misunderstanding) :)
03:25:25 <b_jonas> either you use that strange existential types haskell extension which I don't really understand
03:26:14 <b_jonas> or you can try creating a data type that represents a shape by containing all methods curried on that shape
03:26:21 <b_jonas> though I'm not sure you can do that for every class
03:26:38 <AllNight^> well I _could_ use HLists - I know that ... only
03:26:42 <AllNight^> a) that seems overkill
03:26:43 <b_jonas> for example, if the shape class has a method to draw that gives its are and one that draws it on the screen,
03:26:51 <AllNight^> b) it wouldnt stop you sticking a non-shape into the list
03:27:06 <mm_freak_work> pejo: i don't use such tools…  in the end, my programs will run with GHC only, anyway =)
03:27:10 <b_jonas> you could transform it to a structure that just contains its area and a function that draws it
03:27:11 <mm_freak_work> just wanted to hear opinions
03:27:29 <b_jonas> so the data type of this structure is the same for all shapes
03:27:43 <b_jonas> but still allows you to do all operations you could do with _any_ shape
03:28:35 <b_jonas> but this could turn out to complicated, depending on the actual interface of your Shape class
03:28:53 <b_jonas> I'm not even sure it can be done in general with every classes
03:29:07 <AllNight^> ok... that's an improvement on doing it with per-shape constructors... still keeps the list of functions shapes support closed , so you cant add more in 'subtypes'
03:29:16 <AllNight^> but that would work for most implementations I think
03:29:31 * AllNight^ is just thinking about the language generally - I dont have an actual problem I'm trying to solve
03:29:43 <AllNight^> I'm just trying to learn to 'think in Haskell' :)
03:29:53 <luqui> AllNight^, well the thing is that an existential type is actually isomorphic to a method dictionary
03:29:56 <luqui> and the latter is usually simpler
03:30:25 <luqui> but my hunch, if I were solving a problem that required a solution like this, is to transpose the open-endedness 90 degrees
03:30:49 <luqui> i.e. where *functions* are dong your work, and adding new functions add new shapes
03:30:53 <AllNight^> what do you mean by 'transpose the open-endedness 90 degrees' luqui? :)
03:31:15 <luqui> That was the hunch, the next line tried to extract what the hell I thought I was talking about
03:32:05 <luqui> and I'm just rambling here, none of this is backed up, but functional programs are about what to *do*, not what things *are*
03:32:12 <luqui> i.e. the focus is not on the shapes, but on the operations
03:32:54 <luqui> this is interesting to talk in vagueries; I'm sure it would be much more satisfying if there were a concrete example to be seen :-)
03:33:13 <AllNight^> oh a minor question... why doesnt Haskell support '*' for construction tuple types a'la ML - and why use '|' to seperate constructors in datatypes & not '+' ? I would have thought using '*' / '+' would have made the connections to category theory clearer
03:33:21 * AllNight^ not complaining, just wondering :)
03:35:48 <BeelsebobWork> AllNight^: true, but from a readability stand point, the * operation is a bit odd to people who don't know the maths, and the + suggests (to again, non maths geeks) that you need to provide both, not one or the other
03:35:59 <BeelsebobWork> wheras | has a fairly commonly understood reading as 'or'
03:36:05 <quicksilver> BeelsebobWork: you can do that precisey for every class
03:36:13 <quicksilver> BeelsebobWork: sorry, misdirect
03:36:19 <quicksilver> b_jonas: you can do that precisey for every class
03:36:25 * luqui considers those pretty much arbitrary "artistic" decisions
03:36:29 <quicksilver> b_jonas: just change 'class' to 'data' and you're almost there.
03:36:37 <BeelsebobWork> luqui: agreed
03:36:51 <quicksilver> AllNight^: to keep the value syntax (expresson syntax) compatible with the type syntax
03:36:59 <quicksilver> AllNight^: * means multiple
03:37:04 <luqui> However the tuple syntax (1,2) :: (Int,Int) does not generalize to dependent types, so I'm starting to dislike it :-)
03:37:26 <BeelsebobWork> quicksilver: yeh, but not at the type level -- he's arguing that it should produce a product type when used at that level
03:38:09 <AllNight^> as BeelsebobWork says :)
03:38:23 <quicksilver> BeelsebobWork: which is why I said
03:38:25 <cjs> What's a good way to append one element to the end of a list?
03:38:30 <quicksilver> "to keep the value syntax compatible with the type syntax"
03:38:31 <quicksilver> ;)
03:38:41 <quicksilver> that's not the only way you can imagine doing it.
03:38:47 <quicksilver> but it is, as far as I know, the reason it's done.
03:38:56 <quicksilver> cjs: l ++ [x]
03:39:03 <BeelsebobWork> cjs: there aren't any "good" ways -- lists aren't good at adding things to the end
03:39:07 <BeelsebobWork> they're good at adding things to the start
03:39:09 <quicksilver> cjs: it's O(n) but if that's OK, then that's OK.
03:39:22 <cjs> I guess I'll live.
03:39:32 <BeelsebobWork> you could use a different data structure
03:39:43 <luqui> Data.Sequence comes to mind for all such things
03:39:52 <luqui> (unless you need the laziness)
03:39:58 * AllNight^ was about to suggest just that - Chris Osaki suggests some good ones in his book
03:40:00 <cjs> That would probably be more inefficient, given that these lists are typically six or eight elements. :-)
03:40:22 <BeelsebobWork> probably doesn't hurt too much to use ++ then
03:40:48 <luqui> however considering Data.Sequence slower on sequences of that size is probably a mistake
03:40:52 <luqui> without benchmarks
03:41:00 <luqui> lists are in no way more primitive than Seq
03:41:07 <BeelsebobWork> idd
03:41:08 <luqui> (except syntax)
03:41:13 <AllNight^> can I pm you a sec BeelsebobWork? :)
03:41:19 <BeelsebobWork> if you like
03:41:22 <AllNight^> ty :)
03:41:25 * BeelsebobWork ponders why
03:41:29 <vixey> ~ money for nothing ~
03:41:35 <luqui> he's going to ask you out
03:41:39 <BeelsebobWork> kinky
03:41:49 <quicksilver> luqui: Data.Sequence has slightly larger constant factors
03:41:55 <agentzh> hi, can i say something like "foldl1 (<|>) myAlternatives" while using Parsec? GHC complaints about it. what's the right way please?
03:42:00 <quicksilver> luqui: if you think about it, it has to, it's size-cached and so on.
03:42:07 <vixey> agentzh: How about msum?
03:42:21 <quicksilver> luqui: so lists will be slightly faster if they're very small.
03:42:23 <agentzh> vixey: i'll try :)
03:42:35 <quicksilver> agentzh: there is no reason that shouldn't work.
03:42:38 <luqui> quicksilver, makes sense.  the value of "very" is the question at the moment though :-)
03:42:40 <quicksilver> :t (<|>)
03:42:47 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
03:42:47 <luqui> [] is probably faster than Sequence.empty
03:42:53 <luqui> whatever that means :-)
03:43:14 <BeelsebobWork> I doubt even that
03:43:21 <BeelsebobWork> once the compiler's got it's hands on them
03:43:33 <quicksilver> [] and Sequence.empty are both singleton objects
03:43:35 <quicksilver> they're just pointers
03:43:41 * luqui knows
03:43:41 <quicksilver> (to abuse some OO terminology)
03:45:16 <quicksilver> what's cute about the way GHC does parametric poly is that the singleton [] can be shared between all types
03:45:26 <luqui> If I want to precisify my silly statement:  [] ++ [x] is probably faster than Seq.empty |> x
03:45:32 <quicksilver> yes.
03:45:37 <quicksilver> I'm sure it is.
03:45:49 <quicksilver> quite heard to measure something that fast, btu I'm sure it is.
03:45:58 <b_jonas> quicksilver: my problem is that there are lots of complications:
03:46:25 <b_jonas> 1. the instance type can appear in various places in the method types
03:46:38 <b_jonas> 2. there can be multiple interconnected classes which you have to wrap at once
03:46:56 <b_jonas> 3. there can be superclasses of the classes (including the implicit seq-able class)
03:46:59 <vixey> :t (|>)
03:47:03 <lambdabot> Not in scope: `|>'
03:47:04 <b_jonas> 4. the classes can be higher-kind
03:47:18 <b_jonas> and that's only if you don't allow extensions like fundeps
03:47:28 <quicksilver> fundeps are irrelevant
03:47:33 <b_jonas> so it might be possible to do
03:47:37 <quicksilver> fundeps only affect how GHC chooses the instance.
03:47:48 <quicksilver> if you're doing explicit dictionaries you're choosing the instance, not GHC
03:47:49 <b_jonas> but I can't say I can see the whole process
03:47:53 <quicksilver> so it's up to you how you choose it :)
03:48:00 <b_jonas> I see
03:48:10 <agentzh> ﻿vixey, ﻿quicksilver: thanks. it works for me :))
03:48:18 <vixey> cool
03:49:03 <b_jonas> um, not exactly
03:49:13 <b_jonas> because you might not want to wrap every class
03:49:16 <b_jonas> just some of them
03:49:32 <b_jonas> it would be difficult to imagine transforming the whole program by wrapping everything for every class, even Eq and stuff
03:49:34 <ziman> @hoogle Alternative
03:49:35 <lambdabot> Control.Applicative.Alternative :: class Applicative f => Alternative f
03:49:51 <vixey> @src Alternative
03:49:51 <lambdabot> class Applicative f => Alternative f where
03:49:51 <lambdabot> 	empty :: f a
03:49:51 <lambdabot> 	(<|>) :: f a -> f a -> f a
03:50:25 <quicksilver> b_jonas: well it's a decision you take on a class-by-class basis.
03:50:26 <quicksilver> IMO.
03:50:47 <quicksilver> A typeclass is a bundle of higher order functions which you ask the compiler to automatically choose for you in the type inference process.
03:51:01 <quicksilver> if it is a useful feature to get the type inferrer to pick a bundle, then that's great. Use it.
03:51:11 <quicksilver> however, if you just want a common interface to something
03:51:17 <quicksilver> just bundle the higher order functions yourself
03:51:20 <quicksilver> the class is gaining you nothing.
03:51:36 <quicksilver> in particular: if you find yourself defining dummy types for no reason other than to write instances on them
03:51:42 <quicksilver> you probably shouldn't be using typeclasses.
03:53:32 <b_jonas> quicksilver: but consider eg. how the class you want to wrap could be a superclass of a common class like Eq
03:53:44 <b_jonas> and all (or most) instances you write would derive Eq
03:53:48 <quicksilver> a superclass?
03:53:50 <quicksilver> you mean a subclass?
03:53:55 <b_jonas> yep, subclass
03:54:00 <quicksilver> *shrug*
03:54:09 <quicksilver> you just let the eq constraints bubble through your program.
03:54:12 <b_jonas> and you likely can't derive Eq for the wrapped data type which has functions
03:54:20 <quicksilver> you don't ;)
03:54:23 <b_jonas> and it's not just Eq but more complicated classes
03:54:30 <quicksilver> that doesn't matter
03:54:38 <quicksilver> you're confusing the dictionary with the underlying type
03:54:43 <quicksilver> obviously you don't put eq on the dictionary!
03:54:47 <quicksilver> you put eq on the type.
03:54:58 <quicksilver> consider ShapeClass
03:55:20 <quicksilver> data ShapeClass a = ShapeClass { draw :: a -> IO () }
03:55:35 <quicksilver> it's "a" that is going to have the Eq constraint
03:55:46 <quicksilver> not "ShapeClass a"
03:56:08 <quicksilver> doSomethingWithShapes :: Eq a => ShapeClass a -> a -> IO ()
03:57:01 <b_jonas> hmm
03:57:17 <b_jonas> that's a different way of wrapping than what I wanted to explain then
03:57:27 <quicksilver> doSomethingWithShapes :: (Eq a, ShapeClass a) => a -> IO ()
03:57:31 <quicksilver> compare the two types
03:57:34 <quicksilver> look similar?
03:57:34 <quicksilver> ;)
03:57:41 <quicksilver> all I've done is make the dictionary explicit
03:57:45 <quicksilver> make it data not class.
03:58:00 <b_jonas> I thought of a wrapping that wraps the data to a single type, not one that wraps the type
03:58:44 <b_jonas> so you'd just have a 'data ShapeData :: * = ...' which represents any shape and has fields for each method of Shape
03:58:54 <b_jonas> but wrapping the dictionary might be better, I don't know
03:59:44 <AllNight^> ok... gotta go - thanks again all, see people later :)
03:59:47 <quicksilver> b_jonas: no no :)
03:59:52 <quicksilver> b_jonas: it has to be ShapeData a
03:59:57 <quicksilver> b_jonas: you have to have a parameter for the type.
04:00:07 <quicksilver> this is the correct encoding of dictionaries, yours is broken :)
04:00:22 <b_jonas> yes, I think that might indeed be the better way
04:00:39 <b_jonas> this I think also highlights the difference between haskell classes and c++ polymorphic types
04:00:54 <b_jonas> where the latter are better to wrap similarly to what I said,
04:00:58 <quicksilver> what is a C++ polymorphic type?
04:01:06 <b_jonas> a class with virtual methods
04:01:11 <b_jonas> or a pointer to such class
04:01:27 <quicksilver> ah right.
04:01:40 <quicksilver> well C++ vtables are more general than the language permits.
04:01:46 <quicksilver> in principle any object can have any vtable
04:01:59 <quicksilver> in practive the compiler always points an object at the vtable "belonging to its class"
04:02:08 <quicksilver> so the underlying mechanism might support non-class-based-OO
04:02:09 <b_jonas> it is compiled in such a way that the method table is stored together with the data of the object
04:02:16 <quicksilver> but the implementation is class-based
04:02:25 <quicksilver> b_jonas: I don't think so, no. the method table is global.
04:02:32 <quicksilver> it's a property of the class, not the object.
04:02:40 <b_jonas> sure, but a pointer to the method table is pointed to by an object instance
04:02:41 <quicksilver> (obviously this is a compiler question)
04:02:43 <quicksilver> yes.
04:03:00 <quicksilver> vanilla C++ "nearly has" RTTI
04:03:00 <b_jonas> yep,
04:03:08 <quicksilver> because you could abuse the vtable pointer as type info
04:03:14 <quicksilver> but it's not quite good enough
04:03:23 <quicksilver> so they had to add a bit more to implement complete RTTI
04:03:30 <b_jonas> RTTI?
04:03:36 <b_jonas> oh,
04:03:37 <quicksilver> run time type identification
04:03:39 <b_jonas> real time type info
04:03:42 <b_jonas> run
04:03:43 <quicksilver> that's the C++ term for it I believe
04:03:44 <b_jonas> yep
04:03:52 <b_jonas> I don't know what the term is,
04:03:52 <quicksilver> not all types have vtables
04:03:58 <ndm> RTTI is run time type information, i think
04:03:59 <hpaste>  luqui pasted "Probably bad benchmark for list vs. seq.  Seq wins." at http://hpaste.org/8065
04:04:00 <quicksilver> that may not be the only problem.
04:04:39 <ndm> but RTTI on gcc adds about 30% to the size of binaries when turned on, its ridiculous
04:05:01 <b_jonas> anyway, passing a method table separately also obviously works for multi-parameter classes
04:05:16 <quicksilver> I wonder how much adding 'deriving Typeable' to all types adds to ghc compiled binaries? :)
04:05:18 <b_jonas> whereas wrapping each data separately probably wouldn't work
04:05:34 <quicksilver> hard to check since you'd have to recompile the whole standard lib with deriving typeable turned off.
04:05:39 <b_jonas> though I think there's a more fundamental reason than mpc
04:05:57 <quicksilver> b_jonas: yes, an MPTC just becomes a multiple param data type
04:06:07 <quicksilver> the translation is very mechanical.
04:06:19 <quicksilver> class Foo a b c where { blah :: a -> b -> c }
04:06:21 <ndm> quicksilver: my guess is not a huge amount, since it should optimise out most of the bits - calling read adds about 50Kb I think
04:06:37 <quicksilver> data Foo a b c = MkFoo { blah :: a -> b -> c }
04:07:43 <qwr> weird, reddit removed the yeti link i posted really funcking fast...
04:08:22 * qwr really don't get what was wrong with it
04:09:14 <b_jonas> ok, thanks for the explanation, quicksilver
04:09:24 <b_jonas> I'll now leave to pick up the book
04:09:26 <quicksilver> :)
04:09:28 <quicksilver> enjoy.
04:30:53 <SamB> qwr: maybe they only like non-fiction?
04:37:47 <kayess> Just a quick question about syntax: in a lambda can I still use | for multiple ifs? If so does it just go after the arrow? i.e. \x -> | opt 1 = whatever
04:37:57 <EvilRanter> you can't
04:38:01 <ibid> no, you can't
04:38:12 <kayess> that certainly explains it :)
04:38:26 <kayess> Nested ifs the only way then?
04:38:30 <EvilRanter> if you could, it'd be (\x | foo x -> this x | bar x -> that x)
04:39:10 <EvilRanter> at the moment, yeah, you're stuck with (\x -> if ...), (\x -> case () of _ | foo x -> this x | bar x -> that x)...
04:39:10 <kayess> The example I've seen uses = to separate the conditions from the answer
04:39:11 <quicksilver> kayess: (\x -> case x of ... | ....)
04:39:35 <Twey> kayess: You can use let
04:39:37 <EvilRanter> kayess, guards use the same thing after the predicate as the same thing would use without it
04:39:51 <quicksilver> EvilRanter: iI'm assuming perhaps unwarrantedly that he's matching on the structure of x as well as just guarding.
04:39:57 <quicksilver> hence not case () of _
04:40:00 <kayess> Doesn't case of use a pattern like function definition does?
04:40:11 <Twey> Case allows guards, yes
04:40:12 <vixey> let (-->) = (,) ; cond ((x,y):zs) = if x then y else cond zs in  (\x -> cond [ x == 1 --> "one" , x == 2 --> "two" , otherwise --> "I can't go that far" ]) 2
04:40:15 <EvilTerran> so, as a definition is "foo x = ...", a guarded one is "foo x | ... = ..."
04:40:15 <quicksilver> case of is very much the same as a function definition, yes.
04:40:21 <quicksilver> but you use -> instead of
04:40:22 <kayess> Actually I have a predicate (right term?) clause, not a pattern
04:40:43 <EvilTerran> and, as a case is "case x of Foo y -> ...", it's "case x of Foo y | ... -> ..."
04:40:57 <EvilTerran> by extension, a lambda would be (\x | foo x -> ...)
04:41:12 * EvilTerran would quite like being able to have one guard, by way of an assertion, but never mind
04:41:30 <EvilTerran> kayess, what you really want is a proposed extension that isn't even supported by GHC yet :P
04:41:44 <vixey> kayess: but sometimes just a where clause is fine
04:41:58 <quicksilver> wni 12
04:42:21 <EvilTerran> with that, you could write (case of x | foo x -> ... | bar x -> ...), which would desugar to the same thing as (\freshVar -> case freshVar of x | foo x -> ... | bar x -> ...)
04:43:00 <EvilTerran> (and, interestingly, (case of x -> ...) would be identical to (\x -> ...))
04:43:02 <vixey> I'd like that EvilTerran
04:43:09 <vixey> can you make fresh vars ?
04:43:14 <vixey> with Template Haskell
04:43:19 <EvilTerran> you can, yes
04:43:32 <kayess> I'll play around with a let and a where -- good practice to learn some more of this syntax
04:44:29 <EvilTerran> that's the difference between (mkName :: String -> Name) and (newName :: String -> Q Name) -- the latter adds primes (') until the name is unique
04:44:43 <quicksilver> EvilTerran: the proposal I saw wrote it as '\case' I think
04:44:46 <EvilTerran> (or something like that. guarantees uniqueness, anyway)
04:44:48 <quicksilver> pronounced LambdaCase
04:45:21 <EvilTerran> quicksilver, i knew it was called that (although forgot til you reminded me :P), but i thought the syntax was just "case of ..."
04:45:26 <vixey> LambdaCake
04:45:28 <EvilTerran> ?go haskell lambda-case
04:45:29 <lambdabot> No Result Found.
04:45:31 <vixey> that's what I want
04:45:38 <EvilTerran> the lambda-cake is a lie!
04:45:51 <jkff> Here's an example: case () of _ | 1==2 -> 2 ; _ | 1==1 -> 3
04:46:01 <jkff> Checked in ghci right now
04:46:09 <vixey> I really don't like case () of
04:46:17 <vixey> you could write instead
04:46:19 <jkff> Well, neither do I :)
04:46:27 <vixey> cond [ 1 == 2 --> 2 , 1 == 1 --> 3 ]
04:46:27 <EvilTerran> http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase
04:46:28 <lambdabot> Title: LambdaCase - Haskell Prime - Trac
04:46:40 <EvilTerran> http://hackage.haskell.org/trac/haskell-prime/wiki/MultiWayIf is also relevant
04:46:41 <lambdabot> Title: MultiWayIf - Haskell Prime - Trac
04:46:53 <quicksilver> EvilTerran: *nod* I was just reading those
04:47:04 <quicksilver> either it was proposed somewhere elase or I'm misremembering :)
04:47:24 <EvilTerran> kayess, but anyway, lacking such cunning desugarings, i think the neatest way would be (let f x | foo x = ... | bar x = ... in f)
04:47:55 <EvilTerran> or defining the function outside the expression, in a where. as someone suggested above.
04:48:03 <quicksilver> the question is, can you have your LambdaCake AndEatIt?
04:48:18 <vixey> lol
04:49:05 <EvilTerran> ?faq can haskell have its lambdacake and eat it?
04:49:06 <lambdabot> The answer is: Yes! Haskell can do that.
04:49:15 <qebab> stop saying cake!
04:49:24 <qebab> it's on my highlight ):
04:49:28 <cjs> Did someone say cake?
04:49:29 <opqdonut> :D
04:49:38 <EvilTerran> i guess lambdacake is immutable, so eating it just returns an empty cake instead of emptying the old one
04:49:55 <qebab> we use IRC at work, and when someone says cake, it usually means that someone is sharing it
04:49:58 <quicksilver> why is cake on qebab's highlight?
04:50:03 <quicksilver> you should ighligth kebab!
04:50:07 <qebab> it is the most important hilight of them all
04:50:08 <cjs> What is this, jeopardy?
04:50:19 <EvilTerran> (a *new* empty c.a.k.e)
04:50:22 <quicksilver> someone who talks a lot change their nick to cake :)
04:50:27 <shapr> What is jeopardy?
04:50:34 <EvilTerran> /nick cake
04:50:40 * EvilTerran grabs the cake and runs off
04:50:51 <cjs> It's a game show where they say the answer and you have to give the question.
04:51:22 <EvilTerran> shapr, cjs: you guys did that in the wrong order :P
04:51:24 <qebab> ):
04:51:26 <quicksilver> cjs:what is jeopary?
04:51:28 <quicksilver> damn
04:51:35 <vixey> hehe
04:51:36 <quicksilver> I thought I was playing but I can't spell.
04:51:43 <quicksilver> or typ
04:51:43 <vixey> shapr!
04:52:23 <eprst> hi. I'm new to Haskell.. I'm trying to understand how to handle exceptions when monad transformers are added to the mix: http://hpaste.org/8066 Can it be fixed without changing 'f' type?
04:53:00 <quicksilver> eprst: don't use Exception.throw
04:53:06 <EvilTerran> eprst, i would recommend using MonadError instead of Exception.throw etc
04:53:08 <quicksilver> eprst: use an exception-carrying monad.
04:53:19 <shapr> hiya vixey
04:53:30 <quicksilver> ErrorT StateT or StateT ErrorT
04:53:36 <quicksilver> depending if you want exceptions to roll back state.
04:53:49 <vixey> good afternoon
04:53:57 <Saizan> e can use IO and catchError/throwError if he needs it, anyhow
04:53:58 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
04:53:59 <lambdabot> http://tinyurl.com/sw72f
04:54:14 <eprst> and if I don't have any control on 'f', say it's a 3rd party code?
04:54:31 <quicksilver> eprst: wrap it in something which catches IO exceptions and turns them into 'mymonad expction'
04:55:12 <eprst> so, the answer to the original question "Can it be fixed without changing 'f' type?" is "no", right?
04:55:40 <EvilTerran> eprst, you can follow quicksilver's advice without changing the source or type of the original function
04:55:45 <EvilTerran> you just have to wrap it up
04:55:52 <eprst> OK, will take a look, thanks
04:55:55 <quicksilver> eprst: No. the answer is "yes".
04:56:22 <quicksilver> but there are a variety of tradeoffs involved and overall I would recommend not using IO errors in monad stacks.
04:56:28 <quicksilver> But rather using the MonadError facilities.
04:56:38 <quicksilver> (which as Saizan points out can be used in IO even so)
04:57:00 * EvilTerran notes that the earlier conversation about delicious deserts made him want to listen to The Device Has Been Modified
04:57:07 <EvilTerran> (desserts)
05:06:19 * EvilTerran suddenly has images of lambdabot talking in a glados voice
05:07:26 <EvilTerran> ?vixen are you... still alive?
05:07:26 <lambdabot> yes, i am
05:19:37 * gwern thought school was out for summer
05:19:47 <gwern> er. mischan, thanks to a cat
05:23:19 <bsdemon> Hi, can u help me? I do: str <- getLine, and then I want to convert str from IO to String... what function can I use?
05:23:39 <vixey> :t getLine
05:23:44 <lambdabot> IO String
05:23:46 <vixey> str does have type String
05:24:21 <bsdemon> ok can I do something like: str !! 1 to access first char in my str
05:24:26 <quicksilver> yes
05:24:30 <quicksilver> except that's the second char :)
05:26:07 <bsdemon> yes, yes the second) ok, i know what's my problem - it's about no brackets in "putStr str !! 1" around "str !! 1" ) sorry
05:28:13 <tchakkazulu> :t putStr
05:28:15 <lambdabot> String -> IO ()
05:29:03 <EvilTerran> bsdemon, i find a good guideline is to think of function application (the space in "f x") as being the highest precedence infix operator, and left-associative
05:29:41 <EvilTerran> so (f x y ?? g z) = ((f x) y) ?? (g z), regardless of the definitions of any of the values
05:32:14 <EvilTerran> also, :: is lower precedence than any standard operator (and not associative, altho, with -XKindAnnotations i think it's right-associative)
05:32:33 <EvilTerran> ?type undefined :: Int :: *
05:32:35 <lambdabot> parse error on input `::'
05:32:37 <EvilTerran> bother
05:32:48 <vixey> :t * :: *
05:32:50 <lambdabot> parse error on input `*'
05:34:19 <EvilTerran> ?type 3 :: (Int :: *)
05:34:20 <lambdabot> Int
05:34:42 <EvilTerran> there we go. still, no left-/right-associativity
05:35:03 <vixey> ?type (((3 :: Int) :: Int) :: Int)
05:35:05 <lambdabot> Int
05:35:07 <vixey> hehe
05:35:11 <EvilTerran> vixey, that doesn't make sense. kinds don't have kinds, nor types, and * is a kind
05:35:15 <vixey> ?type ((3 :: Int) :: Integer)
05:35:17 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
05:35:22 <EvilTerran> ?kind StateT
05:35:23 <lambdabot> * -> (* -> *) -> * -> *
05:35:32 <vixey> ?type ((undefined :: a -> b) :: b -> a)
05:35:34 <lambdabot> forall b a. b -> a
05:35:36 <vixey> yay
05:35:38 <quicksilver> ?type 3 :: Int :: Int
05:35:40 <lambdabot> parse error on input `::'
05:35:42 <vixey> I just found a unification devic
05:35:47 <vixey> ?type ((undefined :: a -> b) :: x -> b -> a)
05:35:49 <lambdabot> forall x b a. x -> b -> a
05:35:50 <EvilTerran> ?type (3 :: Num a => a) :: Int
05:35:52 <lambdabot> Int
05:35:55 <vixey> ?type ((undefined :: b -> b) :: x -> b -> a)
05:35:57 <lambdabot>     Couldn't match expected type `b -> a' against inferred type `x'
05:35:57 <lambdabot>       `x' is a rigid type variable bound by
05:35:57 <lambdabot>           the polymorphic type `forall x b a. x -> b -> a'
05:36:00 <EvilTerran> ?type (3 :: Int) :: Num a => a
05:36:02 <quicksilver> EvilTerran: explicitly non associative it looks like.
05:36:02 <lambdabot>     Couldn't match expected type `a' against inferred type `Int'
05:36:02 <lambdabot>       `a' is a rigid type variable bound by
05:36:02 <lambdabot>           the polymorphic type `forall a. (Num a) => a' at <interactive>:1:0
05:36:12 <EvilTerran> quicksilver, yeah. that makes sense, i guess
05:36:18 <vixey> ?type ((undefined :: a -> a) :: x -> p -> q)
05:36:19 <lambdabot>     Couldn't match expected type `p -> q' against inferred type `x'
05:36:19 <lambdabot>       `x' is a rigid type variable bound by
05:36:19 <lambdabot>           the polymorphic type `forall x p q. x -> p -> q'
05:36:26 <vixey> ?type ((undefined :: a -> a) :: (p -> q) -> p -> q)
05:36:27 <lambdabot> forall p q. (p -> q) -> p -> q
05:36:30 <EvilTerran> altho, as it's effectively (::) :: Expr -> Type -> Expr, it'd make more sense for it to associate left than right
05:36:32 <vixey> oh it's not quite .. unification is it
05:36:59 <EvilTerran> vixey, the outer type has to imply the inner one, i think
05:37:02 <vixey> is there any way to make ((undefined :: a -> a) :: x -> p -> q)
05:37:06 <vixey> oh
05:37:14 <vixey> ?type ((undefined :: x -> p -> q) :: a -> a)
05:37:16 <lambdabot>     Couldn't match expected type `a' against inferred type `p -> q'
05:37:16 <lambdabot>       `a' is a rigid type variable bound by
05:37:16 <lambdabot>           the polymorphic type `forall a. a -> a' at <interactive>:1:1
05:37:30 <EvilTerran> Int implies (Num a => a)
05:37:39 <EvilTerran> but (a -
05:37:54 <EvilTerran> > a) doesn't imply (ie isn't a subtype of) (x -> p -> q)
05:37:54 <lambdabot> Unbalanced parentheses
05:38:01 <EvilTerran> silly bot
05:38:12 <quicksilver> vixey: explicity given types are rigid.
05:38:25 <vixey> quicksilver, awwww that ruins the fun
05:38:30 <quicksilver> vixey: in x -> p -> q written explicitly, it's not possible to unify p->q with x
05:38:33 <quicksilver> which is what you wanted.
05:38:38 <hpaste>  ToRA pasted "Seeing unkind stars..." at http://hpaste.org/8067
05:38:43 <quicksilver> because x -> p -> q is just shorthand for
05:38:48 <ToRA> anybody think that's a bug?
05:38:51 <quicksilver> forall x p q . x -> p -> q
05:39:53 <quicksilver> ToRA: you have -XTypeOperators on?
05:40:09 <ToRA> no
05:40:32 <quicksilver> then why is it accepting (Num (*))
05:40:39 <quicksilver> (*) is not a valid type variable I don't think.
05:40:42 <quicksilver> under haskell 98.
05:41:06 <SamB> quicksilver: simpler to allow it than not?
05:41:07 <SamB> bug?
05:41:21 <ToRA> it will parse even if i do :set -XNoTypeOperators
05:41:39 <SamB> report it, anyway, and they can either document it or fix it...
05:41:46 <SamB> (if it isn't already reported...)
05:43:18 <quicksilver> I suppose there are two isseus
05:43:24 <quicksilver> except type operators at all?
05:43:31 <quicksilver> and should you assume their kind is binary?
05:43:48 <quicksilver> but either way it's a bug if ghc accepted something non-h98 without the flags on, I think.
05:43:55 <SamB> quicksilver: well, yes
05:44:10 <MyCatVerbs> @src length
05:44:10 <SamB> but so is the fact that GHC doesn't accept recursive modules ;-)
05:44:10 <lambdabot> Source not found. Are you on drugs?
05:44:57 <quicksilver> maybe so, but that's documented.
05:45:08 <SamB> yes
05:45:29 <kosmikus> 8.4.2 seems to indicate that operators as variables should work, but it seems to explicitly exclude (*)
05:45:34 <SamB> hence why I say this should either be fixed or documented, depending on how hard it would be to fix
05:45:40 <SamB> kosmikus: eh???
05:45:40 <quicksilver> agreed.
05:45:46 <SamB> why *?
05:46:36 <kosmikus> they say "The lexical syntax is the same as that for variable operators, excluding "(.)", "(!)", and "(*)"."
05:47:10 <SamB> kosmikus: oh, yes, because of kinds
05:47:22 <SamB> they should document the reason there
05:47:40 <kosmikus> sure, that's why it's rejected in the second case (with kind annotations on)
05:47:51 <kosmikus> it's not documented though that it *is* accepted in the first case
05:48:05 <SamB> er, and "." because of it's use with forall...
05:48:15 <SamB> now I really must leave for school...
05:48:24 <SamB> I'm already late and don't want to miss another bus
06:02:08 <roconnor> @pl (\x f -> f x)
06:02:09 <lambdabot> flip id
06:05:28 <roconnor> @pl \o x y f -> glue o (x (\a -> SplitL (f a) o)) (y (\a -> SplitR (f a) o))
06:05:29 <lambdabot> ap (flip . (((.) . ap) .) . ap ((.) . (.) . glue) (flip (.) . flip (flip . (SplitL .)))) (flip (.) . flip (flip . (SplitR .)))
06:23:45 <Apocalisp> To be, or not to be, that is the Maybe monad.
06:26:25 <edwardk> 2b | ~2b ~= (b + b) + (~b + ~b) ~= (Bool -> b) + (Bool -> b -> _|_) ~= Either (Bool -> b) (Bool -> b -> Void), but i guess thats kinda boring ;)
06:26:26 <yitz> Apocalisp: I always thought that was the existential type question.
06:28:25 <saml> > a = a in a
06:28:25 <lambdabot>  Parse error at "=" (column 3)
06:28:35 <edwardk> > let a = a in a
06:28:50 <lambdabot>  thread killed
06:30:01 <vixey> > let in let () = () in let in ()
06:30:03 <lambdabot>  ()
06:30:04 <mm_freak1work> not to be or to be and (not to be or to be and (not to be or to be and …)), that is the list monad
06:30:10 <vixey> lol
06:30:21 <vixey> @remember <mm_freak1work> not to be or to be and (not to be or to be and (not to be or to be and …)), that is the list monad
06:30:21 <lambdabot> It is stored.
06:30:35 <edwardk> heh
06:30:41 <nornagon> :D
06:31:58 <saml> > let x = 1 in let x = x in x
06:32:13 <lambdabot>  thread killed
06:32:22 <saml>                      ^ this x should be 1
06:32:39 <mm_freak1work> saml: you're redefining x in the inner let
06:32:43 <nornagon> i imagine you could do that in ocaml with let vs letrec
06:32:50 <nornagon> except that if you do that you're NUTS
06:32:58 <nornagon> and i hate you and i will boycott any code you write
06:32:59 <nornagon> so don't
06:33:19 <saml> > (\x -> (\x -> x + 1) x) 1
06:33:23 <lambdabot>  2
06:33:30 <vixey> nornagon: *lol*
06:36:41 <maltem> saml: lambdas cannot be used recursively the way let bindings can. (let x = x) means that x is undefined
06:36:43 <yitz> > let in 5
06:36:44 <lambdabot>  5
06:37:15 <vixey> > let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in 6
06:37:16 <lambdabot>  6
06:37:41 <maltem> saml: (\x -> x), on the other hand, is similar to let f x = x, if you call the function f
06:38:06 <vixey> there is a very subtle difference between f and (\x -> x) though
06:39:44 <mm_freak1work> maltem: let x = x means x is defined, but bottom
06:39:59 <vixey> let x = x means x = x
06:40:01 <vixey> :P
06:40:31 <twobitwork> > do x <- 1; x <- x; return x
06:40:46 <lambdabot>  thread killed
06:40:56 <vixey> > head( do x <- 1; x <- x; return x )
06:41:01 <maltem> mm_freak1work: That's just a difference in what we mean by "undefined". Your usage probably implies that Prelude.undefined is defined :)
06:41:08 <lambdabot>   add an instance declaration for (Num [[a]])
06:41:14 <edwardk> @where hbc
06:41:14 <lambdabot> I know nothing about hbc.
06:41:15 <mm_freak1work> maltem: yes =)
06:41:25 <edwardk> @where+ hbc http://www.cs.utah.edu/~hal/HBC/
06:41:25 <lambdabot> Okay.
06:41:53 <maltem> mm_freak1work: I'd call it to to be declared, rather. Or "in scope", using GHC terminology
06:42:01 <saml> let* x1 = e1; x2 = e2; ... xN = eN in e    <==>  (\x1 -> \x2 -> ... \xN -> e) e1 e2 ... eN
06:42:13 <twobitwork> let*?"
06:42:19 <vixey> hehe
06:42:28 <saml> i'm just using it to differentiate haskell let
06:42:43 <twobitwork> as in, scheme's let*?
06:42:50 <mm_freak1work> maltem: makes sense…  but what about x = x + 1?  would you consider that undefined?  i'd say it's defined as an infinitely large number
06:43:02 <yitz> > let () = x in x
06:43:12 <lambdabot>  Couldn't match expected type `()' against inferred type `Expr'
06:43:20 <mm_freak1work> > let () = 0 in ()
06:43:21 <lambdabot>   add an instance declaration for (Num ())
06:43:21 <lambdabot>     In the expression: 0
06:43:21 <lambdabot>     In a ...
06:43:26 <vixey> > let () = undefined in ()
06:43:27 <saml> maybe scheme. i dont know scheme that much twobitwork
06:43:41 <lambdabot>  thread killed
06:43:45 <twobitwork> saml: ohh... it has a let*, thought you were referring to that
06:44:07 <quicksilver> mm_freak1work: let x = x + 1 is _|_
06:44:15 <vixey> there's no difference between (\x1 ... xN -> e) e1 ... eN and ((\x1 -> ... \ xN -> e) e1) ... eN in haskell like there is in Scheme
06:44:17 <twobitwork> however, iirc, scheme's let* is more like haskell's let than scheme's let is
06:44:18 <quicksilver> mm_freak1work: you can call that undefined if you like, but you dont have to.
06:44:32 <mm_freak1work> quicksilver: you should read the backlog =)
06:44:33 <maltem> mm_freak1work: If this is, say, an Integer, then we cannot distinguish it from any other bottom Integer. If you code some lazy numeric type where this value won't be bottom, then of course...
06:45:10 <mm_freak1work> maltem: that doesn't answer my question, though…  is it "defined" in your sense?
06:45:10 <twobitwork> > do x <- Just 1; x <- x; return x
06:45:13 <lambdabot>   add an instance declaration for (Num (Maybe t))
06:45:26 <mm_freak1work> let's say it's an Integer, is it defined?
06:45:37 <twobitwork> > do x <- Just 1; x <- Just x; return x
06:45:50 <lambdabot>  Just 1
06:46:19 <maltem> mm_freak1work: I think I use "undefined" in rather the same sense as "bottom", so I'd say that (let x :: Integer; x = x + 1) is undefined
06:46:29 <twobitwork> > do Just 1 >>= (\x -> Just x >>= (\x -> return x))
06:46:30 <lambdabot>  Just 1
06:46:30 <twobitwork> oops
06:46:39 <twobitwork> heh
06:46:46 <twobitwork> > Just 1 >>= (\x -> Just x >>= (\x -> return x))
06:46:48 <lambdabot>  Just 1
06:47:46 <hpaste>  morrow pasted "3 fixes" at http://hpaste.org/8068
06:48:11 <maltem> mm_freak1work: But I do admit that my terminology is vague
06:48:19 <vixey> :t let fix f = g where g = f g in fix
06:48:34 <lambdabot> thread killed
06:48:51 <vixey> > let fix f = g where g = f g in fix (1:)
06:48:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:49:13 <vixey> I think the let and where fixes are the same
06:49:25 <mmorrow> all 3 are equiv
06:49:36 <yitz> maltem: undefined is the name of a function that *is* defined - its value is bottom. bad name for it, I guess.
06:49:49 <mmorrow> ahh, maybe i should have made that more clear...
06:50:03 <mm_freak1work> maltem: bottomness and definedness are two different concepts…  it may make sense to view them as equivalent in some situations, but not all
06:50:26 <twobitwork> @src undefined
06:50:27 <lambdabot> undefined =  error "Prelude.undefined"
06:50:43 <hpaste>  morrow annotated "3 fixes" with "clarifying: 3 equiv ways to fix" at http://hpaste.org/8068#a1
06:50:53 <saml> > let x = error "Prelude.undefined" in 1
06:51:03 <lambdabot>  1
06:51:32 <yitz> > let x = error "Prelude.undefined" in x `seq` 1
06:51:33 <vixey> : fix (`seq`seq)
06:51:35 <lambdabot>  Exception: Prelude.undefined
06:51:36 <vixey> > fix (`seq`seq)
06:51:39 <lambdabot>  Add a type signature
06:52:16 <mm_freak1work> is (repeat 0) considered bottom?
06:52:17 <maltem> mm_freak1work: Yeah, maybe I should I adjust my terminology and use "bottom" when I mean it, and use "defined" exclusively for "there is a definition for it"
06:52:26 <vixey> mm_freak1work: No
06:52:28 <maltem> mm_freak1work: No
06:52:30 <slavik> what is the difference between defining special cases for a recursive function separately versus doing an if-then-else
06:52:32 <vixey> mm_freak1work: it has a weak head normal form
06:52:33 <twobitwork> > head (repeat 0)
06:52:37 <lambdabot>  0
06:52:51 <vixey> slavik: that is the difference
06:53:03 <ivanm> dammit, haskell-mode keeps changing directories to ~/.cabal/ for some reason whenever I try and interpret a file in ghci... anyone know why?
06:53:03 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:53:08 <yitz> slavik: if then else is usually less clear
06:53:21 <mm_freak1work> so intuitively, bottom is, when extracting _any_ information takes infinite time?
06:53:42 <twobitwork> wouldn't a compiler be able to optimize pattern-matched cases better than if-then-else branching?
06:53:45 <dcoutts_> ivanm: I know why
06:53:55 <ivanm> dcoutts_: oh? pray tell
06:54:03 <yitz> mm_freak1work: bottom is when computing a value doesn't terminate.
06:54:04 <maltem> mm_freak1work: right. formally, f _|_ = _|_ for any strict (!) function f
06:54:07 <dcoutts_> ivanm: it's 'coz haskell-mode is looking for a .cabal file in the dir or dir above
06:54:25 <dcoutts_> ivanm: since it's looking to see if your project is a cabal project so looks upwards for a .cabal file
06:54:30 <ivanm> ummm..... why?
06:54:34 <mm_freak1work> ok, that makes sense
06:54:35 <maltem> mm_freak1work: This is the other way around, actually. It's what a strict function is :)
06:54:38 <dcoutts_> ivanm: and it's misinterpreting the ~/.cabal dir as a .cabal file
06:54:57 <ivanm> OK.... who's fault is this? :p
06:55:33 <maltem> yitz: It's ok if it terminates, as long as it doesn't give a result
06:55:47 <slavik> vixey, yitz: thank you. but as far as processing speed, does it matter?
06:56:00 <yitz> mm_freak1work: so (repeat 0) itself isn't bottom, but if you try to compute it the result is bottom.
06:56:45 <quicksilver> yitz: whether (repeat 0) is bottom depends on the semantics you're choosing
06:57:01 <quicksilver> there is a sense it which is it is bottom
06:57:07 <quicksilver> if your semantics doesn't admit infinite values
06:57:10 <dbueno> dcoutts_: I used packaged flattening to restrict the amount of packages that need to be encoded into the SAT problem, and now it produces invalid plans in under a second!
06:58:02 <yitz> quicksilver: ok that's fair
06:58:17 <jkff> It is not bottom because it is the limit of the sequence [bottom, 0:bottom, 0:0:bottom, 0:0:0:bottom, ...], and in lazy semantics these values are not same and only the first of them is bottom
06:58:59 <slavik> I am reading about monads in the wikibook but the topic is confusing, is there a simpler explanation of monads?
06:59:19 <ski_> slavik : definition by cases might be easier optimized than using `if' together with boolean checks
06:59:29 <maltem> mm_freak1work: btw IIRC a value has denotation bottom if and only if does not reduce to any value. In Haskell this means, it cannot be reduced to WHNF
06:59:30 <jkff> Slavik, are you russian? If yes, I have recently written a monad tutorial and I dare say that is simple :)
06:59:30 <yitz> slavik: in ghc pattern matching could even be faster, it's smarter about optimizing that i think, like when you match on different constructors.
06:59:37 <slavik> ski_: I see, that's
06:59:46 <slavik> thanks*
07:00:04 <slavik> jkff: yes :) and may I have a link?
07:00:18 <slavik> as far as I understand, monads are a special type of functions ...
07:00:24 <ski_> nope
07:00:27 <mm_freak1work> maltem: WHNF?
07:00:35 <jkff> Better drop me a note to ekirpichov@gmail.com, I have not yet published it anywhere
07:01:00 <mm_freak1work> wicked haskell normal form?
07:01:44 <maltem> mm_freak1work: weak-head normal form. Normal form means: a value rather than a term still to be computed. Weak-head means, up to the first constructor
07:01:51 <yitz> slavik: you're right that types of kind * -> * are kind of like "functions on types", but we don't call them functions, we just call them types.
07:01:55 <ski_> slavik : a monad is a type constructor (like "list of", or "tree of", or "array of"), together with a few operations over it (satisfying some laws)
07:02:22 <slavik> I see
07:02:32 <slavik> like a template thing of sorts?
07:02:37 <ski_> slavik : otoh, you might have meant a monadic `action' for some monad, e.g.
07:02:42 <ski_> @type getChar
07:02:42 <ivanm> so does anyone know if there's a fix for haskell-mode, or should I just downgrade?
07:02:45 <yitz> slavik: yes
07:02:55 <ski_> lambdabot: wake up
07:02:57 <lambdabot> thread killed
07:03:01 <ski_> getChar :: IO Char
07:03:40 <yitz> lambdabot seems to be feeling a little under the weather today.
07:03:52 <ski_> `getChar' is a monadic action, namely an `IO'-action
07:03:55 <BeelsebobWork> success!
07:03:55 <maltem> mm_freak1work: e. g. (x:xs) is already in WHNF, regardless of how far x, xs are evaluated
07:04:01 <BeelsebobWork> my type checker can deal with classes
07:04:02 <BeelsebobWork> :)
07:05:01 <ski_> slavik : a monad action, very vaguely, describes a "list" of "operations" to be performed in "sequence"
07:05:26 <mm_freak1work> maltem: ok
07:05:32 <maltem> mm_freak1work: Which is why (repeat 0) is not bottom with regard to WHNF
07:05:46 <ski_> slavik : the action monad type used determines what "flavour" of things can happen, as an effect of executing each operation
07:05:59 <quicksilver> jkff: I did say 'depends which semantics you are choosing'
07:06:27 <ski_> slavik : the `IO' monad is used for interacting with the outside world (relative to the haskell process' perspective)
07:06:31 <jkff> Well, I said the same thing :)
07:06:56 <jkff> My favourite explanation of monads is that they are a custom ; operator
07:07:08 <ski_> slavik : the `Maybe' monad is used for executing stuff where most operations can "fail" in some way, aborting the whole sequence of operations
07:07:49 <ski_> slavik : the `Writer' monad is used for logging some kind of output from each operation, as computation proceeds
07:07:59 <ski_> that's a few examples
07:08:30 <ski_> do you have any more specific question pertaining to monads ?
07:09:07 <ski_> (or have i succeeded in overloading you, yet ?)
07:09:52 <twobitwork> > do x <- Just 4; return x
07:10:05 <tibell> ivanm: what problems are you having with haskell-mode and what version are you using?
07:10:07 <lambdabot>  thread killed
07:10:07 <twobitwork> > Just 4 >>= (\x -> return x)
07:10:11 <twobitwork> ?
07:10:22 <lambdabot>  thread killed
07:10:34 <twobitwork> why is that dying?
07:10:35 <quicksilver> tibell: if there is no .cabal file in this project it searchs up to your home dir and finds your ~/.cabal/ directory
07:10:41 * twobitwork kicks lambdabot 
07:10:48 <quicksilver> tibell: and forces your inferior haskell to cd to that dir.
07:10:56 <tibell> quicksilver: right, that is annoying
07:11:04 <quicksilver> I think that was the problem ivanm was having
07:11:10 <quicksilver> > Just 4 >>= (\x -> return x)
07:11:14 <ivanm> tibell: yeah, that was it
07:11:23 <ivanm> what quicksilver said
07:11:25 <lambdabot>  thread killed
07:11:28 <yitz> @seen Cale
07:11:29 <lambdabot> I saw Cale leaving #haskell, #haskell-overflow and #ghc 2h 31m 4s ago, and .
07:11:31 <ivanm> and it's the latest version... 2.4?
07:11:48 <ivanm> it works on one file, but if I wanst to use a module that references another it doesn't work :s
07:11:50 <tibell> ivanm: I have the same problem
07:12:20 * ivanm goes to send an email to the author
07:12:23 <tibell> ivanm: it's annoying because I have my tests in a separate directory so even if it finds the .cabal file it doesn't work
07:12:48 <ivanm> heh
07:14:04 <twobitwork> > do x <- [1]; return x
07:14:13 <lambdabot>  [1]
07:14:18 <twobitwork> there we go
07:14:34 <twobitwork> > [1] >>= (\x -> return x)
07:14:37 <lambdabot>  [1]
07:15:14 <ski_> @pl (>>= return)
07:15:14 <lambdabot> id
07:15:39 <dcoutts_> dbueno: woo hoo!
07:15:49 <dcoutts_> dbueno: that's pretty quick
07:16:00 <cremetorte> is there a prepared function to split a string like this   splitat_ "Hello this is a test."  =>  ["Hello","this","is","a","test."]
07:16:18 <quicksilver> > words "hello this is a test"
07:16:19 <twobitwork> ski_: yeah, I was just going to use it as an example for slavik
07:16:22 <dbueno> dcoutts_: To be fair, "flattenPackageDescription" made the job a whole lot easier.
07:16:33 <lambdabot>  thread killed
07:16:45 <quicksilver> cremetorte: lambdabot is a bit sick, but words is the answer
07:16:55 <twobitwork> word!
07:17:04 <cremetorte> ok than you
07:17:10 <cremetorte> word "foo bar"
07:17:18 <cremetorte> k
07:17:20 <cremetorte> :)
07:17:24 <dbueno> dcoutts_: And I thought I would only implement the "unsatisfiable core" stuff after I got this working, because I thought that would only be relevant for producing good error messages ... but it's looking like it will help debugging too. =]
07:17:29 <twobitwork> no, "words" is the function... I was being silly
07:18:38 * ivanm downgrades haskell-mode so that he can actually use it :s
07:19:31 <cremetorte> thats so stupid we have to programm the function wordlist which does the same thing like words
07:19:31 <dbueno> dcoutts_: Oh, so, I meant to ask.  Would you mind looking over the semantics I've given for CondTrees, Dependencies, UnresolvedDeps, etc. to see if it comports with your intuition?
07:19:49 <cremetorte> so i just write wordlist x = words x ^^^
07:20:14 <dbueno> dcoutts_: Basically I have a type class that converts stuff to logical circuits.  Each method is short, so, it's not an unreasonable description of the semantics.  If you're willing, I'll send you an email with the class & instances, unless you'd prefer another medium.
07:22:40 <twobitwork> cremetorte: homework? :P
07:22:48 <Toxaris> cremetorte: the people in this channel are able to give you a one-liner for most Haskell exercises out there, but still, it may help you to solve them yourself.
07:22:54 <dcoutts_> dbueno: sure
07:23:09 <quicksilver> cremetorte: well maybe it's not stuipd if the objective is to test your ability to write haskell :P
07:23:19 <quicksilver> there's not much haskell ability in wordlist = words
07:24:22 <slavik> ski_: now it seems to me as if monads are like functions
07:24:56 <twobitwork> slavik: no... monads are more like containers
07:24:58 <ToRA> quicksilver: it could be worse - you could write: worldlist list = words list
07:25:10 <quicksilver> ToRA: well he did, actually.
07:25:15 <quicksilver> ToRA: I sneakily pointfreed it.
07:25:26 <ToRA> heh, oh yeah
07:25:36 <ToRA> so actually there was some haskell skill in what you wrote ;)
07:25:52 <twobitwork> slavik: http://www.haskell.org/haskellwiki/Monads_as_Containers
07:25:54 <lambdabot> Title: Monads as containers - HaskellWiki
07:26:04 <twobitwork> slavik: that tutorial really helped me
07:26:14 <ski_> slavik : why do you think they're like functions ? .. example ?
07:26:34 <twobitwork> slavik: the monad class defines certain functions for handling monads
07:26:34 <Toxaris> monads are indeed like functions, more precisely, (a -> m b) is like (a -> b) if m is a monad.
07:26:37 <slavik> ski_: the way you explained it, seemed like a function to me
07:26:43 <slavik> jkff: спасибо :)
07:26:54 <jkff>  :)
07:27:05 <Toxaris> the difference is of course that there *is* that m :)
07:27:08 <slavik> utf8?
07:27:22 <quicksilver> slavik: I suspect it's like what you think of as a function.
07:27:33 <quicksilver> slavik: but not what functional programmers typically mean by 'function'
07:27:38 <ski_> slavik : sorry, `it' being ? .. the `getChar' `IO'-action ? .. the mentions of `Maybe', `IO', et.c. ?
07:27:41 <mmorrow> (a -> m b) ~ (a -> c) if c ~ m b
07:27:46 <slavik> or is monad like a "data structure" type thing?
07:27:47 <quicksilver> slavik: namely that for a given "a" you always get the same "b"
07:28:00 <slavik> anyway, I have 2 tutorials to read before asking more stupid questions ^^
07:28:07 <slavik> I see
07:28:14 <gubagem> does the => mean monad?
07:28:17 <ski_> no
07:28:32 <twobitwork> => is for defining class constraints
07:28:35 <slavik> quicksilver: random number generator is a monad?
07:28:46 <quicksilver> slavik: almost.
07:28:56 <Toxaris> slavik: some monads are more like "data structures", others more like "control structures"
07:28:56 <ski_> gubagem : the `=>' separates constraints from the type proper, in type signatures
07:29:01 <quicksilver> slavik: to give a type to random number generation we would use a monad, yes.
07:29:10 <quicksilver> slavik: so random numbers would be an example of the kind of effect you can describe with monads.
07:29:20 <quicksilver> an RNG isn't a Monad itself, precisely.
07:29:40 <cremetorte> [i|i<-[1..],mod i 4==0]
07:30:06 <Toxaris> mmorrow: hehe that's not what I mean. I mean that (a -> m b) can be written as (a ~> b) for a suitable ~> (aka. Kleisli arrow), so that -> and ~> have something in common
07:30:13 <gubagem> where do monads fit in with arrows(functors) and objects(categories)  all from category theory
07:30:33 <hpaste>  Vag pasted "Solution for Breadth-First Numbering (Okasaki paper)" at http://hpaste.org/8069
07:30:38 <quicksilver> gubagem: I'm not sure what you mean by arrows and objects
07:31:04 <quicksilver> gubagem: in the simplest CT interpretation of programming, the objects are types, and the morphisms (arrows) are functions.
07:31:07 <gubagem> ok ive looked up the basics of category theory, and it has categories and functors(arrows) from one category to another
07:31:16 <quicksilver> functors are not arrows.
07:31:23 <quicksilver> arrows are morphisms.
07:31:30 <quicksilver> functors are something higher level than that.
07:31:36 <gubagem> a bunch of arrows together?
07:31:38 <mmorrow> Toxaris: yeah i just wanted to be painfully explicit/(obvious?) to make sure nothing became confused
07:31:48 <quicksilver> a functor is a mapping between two categories
07:31:49 <mmorrow> for whatever reason
07:31:59 <quicksilver> assigning objects to objects and morphisms to morphisms
07:32:02 <gubagem> but isnt a series of morphisms a mapping
07:32:02 <mmorrow> Toxaris: for whatever reason
07:32:04 <gubagem> oh
07:32:06 <quicksilver> satsifying a bunch of (fairly obvious) rules
07:32:16 <Toxaris> gubagem: consider the category of haskell types, with haskell functions as arrows. Now a monadic type constructor m is a endofunctor for this category, which maps a type (object) t to m t and a morphism a -> b to a -> m b.
07:32:25 <Toxaris> gubagem: or something like that
07:32:26 <slavik> quicksilver: I see
07:32:27 <edwardk> gubagem a category consists of objects and arrows between those objects (with a couple of laws aying you always have an identity arrow and that composition is associative). functors map objects and arrows from one category to another category
07:32:46 <gubagem> ok
07:32:56 <edwardk> gubagem: the only sense in which a functor is an arrow is that you can have ANOTHER category, the 'category of categories' in which each arrow is a functor.
07:33:01 <Toxaris> gubagem: hmm, do you ask for CT explained in Haskell terms or the other way around?
07:33:03 <edwardk> but in general arrows and functors are different =)
07:33:13 <gubagem> i just want to know where monads fit into CT
07:33:20 <quicksilver> monads come from CT ;)
07:33:42 <edwardk> In Haskell terms, we have a category of types, commonly denoted 'Hask'. in that arrows written -> are arrows in the category.
07:34:13 <mmorrow> one can identify the objects with their (unique!) identity morphisms and "get rid of" the objects all together
07:34:23 <Toxaris> mmorrow: yeah, but you were explicitly talking about something different from what I implicitly meant. But maybe you were not talking about what I said at all.
07:34:37 <mmorrow> i just felt like saying that to no one in particular
07:34:56 <edwardk> so a function from Int -> [Bool] is an arrow from the Int type to the [Bool] type in that category. Haskell Functors are endofunctors on the category of types, which means that they are functors from the category Hask to itself. They map arrows to arrows and objects to objects.
07:34:58 <quicksilver> gubagem: but to understand monads you need to first understand functors and natural transformations.
07:35:07 <quicksilver> gubagem: because they are involved in the defn of monads.
07:35:12 <Toxaris> mmorrow: interesting. what's the benefit of getting rid of the objects this way?
07:35:31 <mmorrow> Toxaris: since slavik is learning about monads, i just threw that out there *just incase* that may prevent some confusion *for whatever reason* to him
07:35:33 <quicksilver> you can put them on ebay
07:35:36 <ski_> gubagem : objects in the category `Cat' are categories, and morphisms/arrows therein are functors between the categories .. however, one typically does some size restrictions to avoid paradoxes
07:35:37 <quicksilver> CT for fun and profit.
07:35:48 <edwardk> Now, one way to view a category is to ignore the objects in the category entirely. Thats how Haskell functor's work. you only see the 'action' of the functor, in terms of how it affects morphisms (functions).
07:35:51 <edwardk> @type fmap
07:35:52 <gubagem> oh oh, I am trying to teach my brother how to code and I chose scheme, and showed him just an identity list thing ie [a]->[a] where [a]==[a] , then i showed him double and I think he started to get recursion
07:35:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:36:21 <gubagem> that looks like a distrubitive property to me
07:36:35 <mmorrow> Toxaris: hmm. benefit? (assuming in the cxt of haskell/programming) i'd have to think about it. In general, benefit is subjective i guess.
07:36:37 <vixey> :t (>>=)
07:36:39 <quicksilver> it is a distributive property.
07:36:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:36:41 <dbueno> dcoutts_: Sent you a description.
07:36:44 <quicksilver> with an appropriate squint.
07:36:52 <dcoutts_> dbueno: thanks
07:37:05 <quicksilver> edwardk: you can see the action on objects too, of a haskell Functor.
07:37:08 <ski_> Toxaris : no, a functor `m' wouldn't map a morphism in `a >-> b' into one in `a >-> m b'
07:37:17 <quicksilver> edwardk: Int goes to Maybe Int
07:37:38 <edwardk> quicksilver: true enough
07:37:53 <mmorrow> Toxaris: but in the cxt of using that isomorphism in haskell to make something simpler, i'm sure there's at least one case where that's the case
07:38:27 <Toxaris> ski_: I cannot follow you at all. "morphism in something"? ">->"?
07:39:06 <yitz> quicksilver: but it's always a wrapper like that, which is trivial. nothing interesting ever happens to objects under a functor.
07:39:24 <ski_> Toxaris : `a >-> b' isn't a morphism itself .. it's the "type" of a morphism .. in `f : a >-> b', `f' is the morphism
07:39:57 <Toxaris> ski_: oh of course.
07:40:26 <ski_> @type (=<<)
07:40:41 <lambdabot> thread killed
07:41:01 <ski_> lambdabot: you're having a bad day, right ?
07:41:08 <yitz> @slap lambdabot
07:41:08 * lambdabot places her fist firmly on lambdabot's jaw
07:41:25 <edwardk> gubagem: so once you have the notion of an endofunctor, a monad m is just an endofunctor equipped with a couple of additional morphisms. the category theoretic version is that they are eta and mu, where eta_a :: a -> m a, and mu_m :: m (m a) -> a
07:41:27 <yitz> @type (=<<)
07:41:42 <lambdabot> thread killed
07:41:49 <edwardk> gubagem: In Haskell those are return and join, but for various reasons we like to use an equivalent formulation in terms of return and bind (>>=) because it is closer to how we tend to use them
07:42:12 <ski_> edwardk : s/eta_a/eta_m/
07:42:16 <edwardk> gubagem: so thats basically how Haskell monads relate to category theory monads
07:42:19 <edwardk> ski: er yeah
07:42:50 * shapr sneezes repeatedly
07:43:06 <edwardk> er actually s/mu_m/mu_a/ i was going for the family of morphisms, not specialization to a monad =)
07:43:06 <ski_> m det gagna dig
07:43:20 <yitz> edwardk: check the type of mu_m
07:43:31 <edwardk> yitz: heh wow i suck today
07:43:36 <edwardk> mu_a :: m (m a) -> m a
07:44:02 <ski_> @type eta
07:44:04 <ski_> @type mu
07:44:04 <lambdabot> Not in scope: `eta'
07:44:07 <lambdabot> Not in scope: `mu'
07:44:09 <edwardk> @type return
07:44:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:44:12 <edwardk> @type join
07:44:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:44:24 <shapr> ski_: Is that like 'bless you' in Swedish?
07:44:29 <ski_> @type (=<<)  -- ok, this time ?
07:44:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:46:28 <ski_> shapr : (i've heard) it's the swedish translation of what the old romans used to say when someone was sneezing .. in english it might be something like "may it benifit you" .. meaning that you're sneezing the illness out of the body
07:46:54 <ski_> (i don't recall what the latin original would be, though)
07:47:35 <ski_> (hm, maybe it was "prosit" .. though that would then possibly seem to be an abbreviation ..)
07:47:45 <Mr_You> anyone working on gui apps with haskell?
07:47:57 <twobitwork> Mr_You: I plan to soon
07:48:06 <twobitwork> :P
07:48:18 <Mr_You> are you using bindings?
07:49:01 <Mr_You> how are you building it?
07:49:29 <ToRA> Mr_You: i use gtk2hs + glade for most things i do now
07:52:57 <Mr_You> thanks, will check into that.  I'm guessing its the only maintained kit for now?
07:53:15 <quicksilver> Mr_You: wxWidgets is maintained too
07:53:27 <quicksilver> I have used that for a very simple project
07:53:30 <Zao> Does wxWidgets work in a -threaded RTS yet?
07:54:17 <Zao> The only mention of threads I've seen thus far in the wx docs is Process.hs outsourcing work to a whole different process.
07:55:47 <quicksilver> yes, it works fine.
07:56:02 <quicksilver> You probably need to only main GUI calls from the main thread.
07:56:08 <quicksilver> at least the ones that actually draw stuff.
07:56:13 <quicksilver> but that's a decently sane idea anyway.
07:56:25 <quicksilver> (and it applies to gtk2hs and opengl as well)
07:56:54 <Zao> Does it have any way to do main thread callbacks like gtk2hs has?
07:57:20 <mmorrow> Toxaris: (in cat of haskell types w/ functions as morphs), here is (one way to exhibit) that isomorphism:
07:57:24 <mmorrow> let toId = asTypeOf
07:57:29 <mmorrow> let fromId id = id undefined
07:58:51 <twobitwork> is there something like call/cc in haskell?
07:58:53 <Mr_You> I'm slowly getting back into programming, haskell/functional programming is interesting enough for me to consider it.  But I wondering if I should consider writing a library to provide abstracted GUI functions for a more crossplatform-like development.
07:59:03 <edwardk> @type callCC
07:59:06 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
07:59:18 <twobitwork> ohhh :)
07:59:22 <edwardk> twobitwork: There is a Cont monad =)
07:59:29 <twobitwork> cool
07:59:43 <edwardk> you can mix and match ContT with other monad transformers as well
07:59:50 <twobitwork> @find callCC
07:59:52 <lambdabot> Not in scope: type variable `callCC'
07:59:56 <twobitwork> er
08:00:00 <edwardk> Control.Monad.Cont
08:00:11 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
08:00:12 <lambdabot> http://tinyurl.com/vp4ok
08:00:35 <twobitwork> heh
08:00:40 <twobitwork> > callCC callCC callCC
08:00:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> m b
08:00:41 <lambdabot>       Exp...
08:00:56 <mmorrow> haha
08:01:00 <quicksilver> Zao: I'm not sure what you mean by mainthread callbacks.
08:01:15 <quicksilver> Zao: I think the callbacks from the GUI will always be mainthread
08:01:30 <twobitwork> in scheme (call/cc call/cc call/cc) would loop forever
08:01:31 <quicksilver> if you want your own way to say "execute this in the main thread" then no, I don't think so.
08:01:43 <Zao> quicksilver: As in, from $thread being able to make the GUI pump execute an IO action later.
08:01:44 <quicksilver> Mr_You: well wxwidgets and gtk2hs are both reasonably cross platform
08:01:56 <edwardk> twobitwork: here we have types ;)
08:01:58 <quicksilver> Zao: pretty trivial to code that with a Chan (IO ())
08:02:03 <twobitwork> edwardk: yeah, it's nice
08:02:06 <quicksilver> Zao: I've done such things onces or twice
08:02:12 <Zao> But the main thread will be busy with the GUI pump, wouldn't it?
08:02:13 <ski_> twobitwork : rather `((call/cc call/cc) (call/cc call/cc))'
08:02:17 <quicksilver> Mr_You: wx perhaps more so
08:02:30 <quicksilver> Zao: well the main thread gets idle events periodically, if you ask for them.
08:02:36 <Zao> Ah.
08:02:45 <quicksilver> Zao: maybe a more general way of 'kicking' it would be useful.
08:02:50 <quicksilver> can't say I've need it myself.
08:02:52 <edwardk> Y ski, Y? =)
08:03:05 <quicksilver> mind you I tend to write openGL applications which regain control 20 times a second anyway
08:03:20 <ski_> edwardk : it's basically the same as `U U', yes
08:07:07 <Mr_You> wxHaskell looks interesting.
08:07:10 <twobitwork> ?src MonadCont >>=
08:07:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:07:14 <mmorrow> > let fix f = f (fix f) in fix id
08:07:23 <mmorrow> > mfix return
08:07:24 <lambdabot>   add an instance declaration for (Show (m a))
08:07:26 <lambdabot>  Exception: Time limit exceeded
08:07:34 <mmorrow> out of order
08:07:36 <mmorrow> > mfix return
08:07:36 <lambdabot>   add an instance declaration for (Show (m a))
08:08:11 <ski_> @src Cont (>>=)
08:08:12 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
08:09:21 <mmorrow> mfix return === return undefined
08:10:01 <ski_> > mfix return :: [()]
08:10:02 <lambdabot>  [Exception: stack overflow
08:10:06 <mmorrow> wrt types at least
08:10:16 <ski_> > mfix return :: Maybe ()
08:10:20 <mmorrow> hmm
08:10:31 <lambdabot>  thread killed
08:10:40 <mmorrow> a <- return undefined
08:10:46 <mmorrow> :t a
08:10:50 <lambdabot> Expr
08:10:50 <mmorrow> a :: GHC.Prim.Any
08:11:06 <mmorrow> like wise for mfix
08:11:09 <mmorrow> likewise
08:11:30 <mmorrow> so i guess that means they're any type you annotate them to be
08:11:43 <mmorrow> ==> undefined
08:11:44 <ski_> @type mfix return
08:11:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
08:12:05 <mmorrow> a <- mfix return
08:12:09 <mmorrow> :t a
08:12:11 <lambdabot> Expr
08:12:14 <mmorrow> a :: GHC.Prim.Any
08:12:37 <ski_> mmorrow : it appeared `mfix return :: [()]' was `[_|_]' ..
08:12:44 <mmorrow> interesting
08:13:02 <mmorrow> oh, as in return undefined
08:13:08 <ski_> so the `return _|_' thing might have merit
08:13:38 <mmorrow> hmm
08:13:39 * ski_ doesn't recall what the expected axioms of `mfix' was ..
08:14:04 <mmorrow> neither can i, but i remember the haddock doc explicitly listed them
08:19:02 <edwardk> ski: 1. f bottom = bottom <=> mfix f = bottom, 2. mfix (return . h) = return (fix . h) and 3. mfix (\x -> q >>= f x) = q >>= \y -> mfix (\x -> f x y) if x does not appear in q.
08:24:10 <vixey> ?check \a b -> a^b < b^a
08:24:12 <lambdabot>  Exception: Prelude.^: negative exponent
08:24:18 <vixey> ?check \a b -> a**b < b**a
08:24:18 <mmorrow> edwardk: thx
08:24:19 <lambdabot>  Falsifiable, after 1 tests: 0.0, 0.0
08:24:21 <ski_> (edwardk : presumably s/fix . h/fix h/)
08:24:23 <vixey> ?check \a b -> a**b > b**a
08:24:25 <lambdabot>  Falsifiable, after 0 tests: -1.0, -0.5
08:24:25 <ski_> mfix return = mfix (return . id) = return (fix id) = return _|_
08:24:36 <hpaste>  Vag annotated "Solution for Breadth-First Numbering (Okasaki paper)" with "Comments" at http://hpaste.org/8069#a1
08:24:58 <vixey> ?check \a b -> (a > 1 && b > 1) == a**b > b**a
08:24:59 <lambdabot>      precedence parsing error         cannot mix `(==)' [infix 4] and `(>)' [...
08:26:05 <mmorrow> i wanna do some rewrite rules to map all the nonterminating (fix _)s to undefined
08:26:11 * mmorrow puts that on the list
08:26:39 <mmorrow> (and nonterm (mfix _) = return undefined
08:26:40 <mmorrow> )
08:29:57 <vixey> ?check \a b -> (a > 1 && b > 1) == (a**b > b**a)
08:29:58 <lambdabot>  Falsifiable, after 2 tests: 0.0, -1.0
08:30:16 <mmorrow> (fix id |--> undefined) and (mfix (return . f) == return (fix f) by def) ==> (mfix return --> return (fix id) --> return undefined)
08:32:28 <PeakerWork> Why can't I pattern-match on an existential type?
08:32:42 <PeakerWork> "My brain just exploded" is in my compilation error message :)
08:32:46 <quicksilver> you can, but you have to use case not let
08:33:08 <PeakerWork> why? what's the difference?
08:33:37 <gwern> heh. there's *another* reimplementation of quickcheck in a non-haskell lang
08:33:39 <int-e> case bindings are never recursive.
08:34:23 <gwern> so that makes 8 QC clones now...
08:34:45 <mm_freak1work> http://arcanux.org/lambdacats/brain.jpg
08:36:37 <quicksilver> PeakerWork: let makes ghcs brain explode, while case works.
08:36:44 <quicksilver> PeakerWork: is that not a sufficient difference?
08:36:51 <quicksilver> what do you want? win a holiday by using case? :P
08:37:25 <PeakerWork> quicksilver, I am wondering what difference there is?
08:37:35 <quicksilver> then use int-e's answer.
08:37:36 <hpaste>  morrow pasted "rewrite fix id to undefined, etc" at http://hpaste.org/8070
08:37:49 <PeakerWork> ah, thanks
08:38:29 <PeakerWork> I want to delegate some code to a common function, but then it would have to return a list of the existential type (which is ok) but then I need to use the values inside the existential type but that's the part where it explodes ghc's brain
08:39:00 <quicksilver> just use case!
08:39:04 * quicksilver screams.
08:39:14 <PeakerWork> I am not sure how to use case there, and I think it would be very very clunky
08:39:16 <quicksilver> I understand you being interested in the underlying reason, it's interesting.
08:39:28 <ski_> @hpaste
08:39:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:39:31 <quicksilver> instead of let Any x = y in ....
08:39:44 <quicksilver> case y of Any x -> ....
08:39:44 <PeakerWork> its not a let, its a where
08:39:44 <quicksilver> it's not a very big change :)
08:39:46 <quicksilver> same difference.
08:40:21 <quicksilver> anyhow there's not much point arguing about it. As far as I know, case is the only answer :)
08:40:22 <hpaste>  morrow annotated "rewrite fix id to undefined, etc" with "mfix return case" at http://hpaste.org/8070#a1
08:40:38 <quicksilver> however you may dislike that, it's the only way your program will compile.
08:40:38 <vixey> is Sixteenth Annual ACM Symposium on Principles of Programming Languages available online?
08:41:01 <int-e> PeakerWork: you can also pattern match existential types in function arguments.
08:41:19 <int-e> it's just let that doesn't work.
08:41:57 <PeakerWork> int-e, let and where
08:42:05 <PeakerWork> (I was using where, not let)
08:42:08 <quicksilver> correct. let is where.
08:42:10 <quicksilver> and functions are case.
08:42:11 <int-e> right. let is where and where is let :)
08:42:12 <quicksilver> :)
08:42:16 <PeakerWork> ;-)
08:42:21 <ski_> where is let ?
08:42:28 <int-e> @seen let
08:42:28 <lambdabot> I haven't seen let.
08:42:36 <hpaste>  morrow annotated "rewrite fix id to undefined, etc" with "without rules (stack overflow)" at http://hpaste.org/8070#a2
08:42:54 <ski_> let where be ware
08:47:22 <PeakerWork> btw: anyone knows the status of the proposal to allow classes to be instances of other classes (allowing class adapters)?   This would allow fixing stuff like Functor -> Monad in a backwards-compatible way
08:47:50 <PeakerWork> class adapters are pretty cool too, because by instantiating a single class, you automatically instantiate a bunch of other classes
08:48:39 <jgrimes> anyone else had issues with harpy seg-faulting?
08:49:24 <PeakerWork> (Having to define fmap, (>>=) and return on your type's instances instead of only return and (>>=) (which allows liftM/fmap) is also suboptimal
08:51:13 <quicksilver> PeakerWork: awaiting implementation :)
08:51:31 <quicksilver> PeakerWork: none of the class alias proposals or their friends have been implemented.
08:52:50 <PeakerWork> is that called a class alias?
08:53:06 <quicksilver> no, the one you're describing is not a class alias
08:53:18 <quicksilver> however, class aliases are a related attempt to solve the same problem
08:53:24 <quicksilver> @go John Meacham Class Alias Proposal
08:53:25 <lambdabot> http://repetae.net/recent/out/classalias.html
08:53:25 <lambdabot> Title: Class Alias Proposal for Haskell
08:57:05 <mmorrow> i can't figure out how to write the rule "asTypeOf/undefined"  asTypeOf undefined = id
08:57:24 <mmorrow> the undefined always gets evaled and throws the corresponding exception
08:59:14 <mmorrow> relatedly, (fix . asTypeOf)==id
08:59:29 <Botje> hmm
08:59:37 <Botje> that class alias proposal is interesting
08:59:48 <Botje> but there's a little problem with the class alias Num
08:59:59 <Botje> is john meacham here so I can @tell him?
09:00:16 <mmorrow> jgrimes:how'd you make it segfault?
09:00:30 <ski_> Botje : JohnMeacham i think
09:00:36 <mmorrow> jgrimes: slash what's the context
09:00:41 <Botje> (negate x is defined as zero - x, while x - y is defined as x + negate y)
09:00:57 <Deewiant> preflex: seen JohnMeacham
09:00:57 <preflex>  JohnMeacham was last seen on #haskell-blah 26 days, 2 hours, 43 minutes and 56 seconds ago, saying: a headache. I don't get headaches. hmmm...
09:00:58 <jgrimes> mmorrow: by running the factorial sample, and the example application that comes with it seg faults when it is supposed to compile
09:01:25 <jgrimes> mmorrow: that is, the program compiles fine, but the JIT seg-faults
09:01:29 <Lemmih> Deewiant: Must have been a pretty bad headache.
09:01:32 <opqdonut> ?src asTypeOf
09:01:33 <lambdabot> asTypeOf = const
09:01:36 <mmorrow> jgrimes: hmm, hold on...
09:01:45 <dons> ?users
09:01:46 <lambdabot> Maximum users seen in #haskell: 465, currently: 440 (94.6%), active: 19 (4.3%)
09:01:59 <opqdonut> mmorrow: do you mean (`asTypeOf` undefined)
09:02:01 <mmorrow> opqdonut: nice find
09:02:13 <opqdonut> instead of (undefined `asTypeOf`)
09:03:40 <mmorrow> opqdonut: no, i want (asTypeOf . fix) id==id, and i have a rewrite rule that maps fix id to undefined, so...
09:04:09 <mmorrow> (Note: i'm using const in place of asTypeOf from now on)
09:04:17 <opqdonut> :)
09:04:22 <mmorrow> :)
09:04:28 <opqdonut> but you can't rewrite "const undefined = id"
09:04:32 <opqdonut> that doesn't make sense
09:04:50 <mmorrow> ohh
09:04:57 <Deewiant> can't rewrite rules be ordered somehow
09:05:17 <opqdonut> Deewiant: yes
09:05:18 <mmorrow> wait, asTypeOf != const
09:05:37 <mmorrow> of yeah, it is
09:05:39 <mmorrow> :(
09:05:39 <opqdonut> asTypeOf is const with a stricter type
09:05:40 <vixey> :t asTypeOf
09:05:42 <lambdabot> forall a. a -> a -> a
09:05:44 <opqdonut> :t const
09:05:47 <lambdabot> forall a b. a -> b -> a
09:05:54 <mmorrow> therein lies my problem
09:05:56 <vixey> :t const :: a -> a -> a
09:05:58 <lambdabot> forall a. a -> a -> a
09:06:23 <mmorrow> i want flip asTypeOf then
09:06:31 <opqdonut> yes
09:06:32 * mmorrow goes to try that
09:06:33 <opqdonut> as i suggested
09:06:36 <mmorrow> heh
09:06:39 <opqdonut> :)
09:06:47 <mmorrow> :)
09:07:08 <opqdonut> > (flip asTypeOf . fix) undefined $ 1
09:07:08 <lambdabot>  1
09:07:10 <int-e> @type (`asTypeOf` undefined)
09:07:11 <lambdabot> forall a. a -> a
09:07:12 <opqdonut> see, no rewrite needed
09:09:01 <mmorrow> success!! so,
09:09:13 <mmorrow> (fix . asTypeOf) == (flip asTypeOf . fix) id == id
09:09:24 <mmorrow> you need the rewrite for  (flip asTypeOf . fix) id
09:10:16 <mmorrow> (that rewrite being fix id -> undefined)
09:11:20 <mmorrow> (in the cat of haskell type w/ morphisms function) so that's another way to exhibit the isomorphism between the objects in (this) a cat and the identity morphisms
09:14:13 <mmorrow> jgrimes: i'm checking now...
09:18:10 <mmorrow> that should be: (fix . flip asTypeOf) == (flip asTypeOf . fix) id == id   (need another rewrite rule)
09:19:16 <dolio> No, fix . flip asTypeOf  = asTypeOf undefined
09:20:17 <mmorrow> ahhh!
09:20:25 <dolio> Who uses asTypeOf anyway?
09:20:53 <mmorrow> i just used it for the first time trying to exhibit an iso between object in a cat and the id morphisms
09:21:05 <mmorrow> random
09:21:36 <mmorrow> jgrimes: the evaluator in the example dir built without seqfaulting for me...
09:21:54 <jgrimes> mmorrow: it builds fine for me, it is just the evaluation that segfaults
09:22:04 <mmorrow> oh
09:22:28 <mmorrow> i evald 3+4 or something and no seqfault...
09:22:42 <mmorrow> hpaste a transcript leading up to a couple seqfaults
09:23:12 <quicksilver> dolio: occasionally I find asTypeOf more readable than scoped type vars
09:23:21 <jgrimes> mmorrow: any evaluation seg faults
09:23:32 <ndm> quicksilver: plus more compatible
09:23:39 <jgrimes> mmorrow: including just a number
09:23:54 <jgrimes> mmorrow: what arch are you on
09:23:56 <quicksilver> ndm: yes, although I can't say I care much about that particular case
09:24:05 <quicksilver> ndm: scoped type vars is a very important extension
09:24:05 <mmorrow> jgrimes: i was about to ask you the same. linux
09:24:08 <dolio> quicksilver: Need for scoped type variables are a relatively rare occurrence as is, though, in my experience.
09:24:13 <quicksilver> ndm: I pretty much consider it a bug in haskell 98
09:24:15 <mmorrow> jgrimes: x86
09:24:17 <ndm> quicksilver: agreed, an obvious omission
09:24:40 <mmorrow> jgrimes: yourself?
09:24:58 <jgrimes> mmorrow: I am on dual dual-core x86-64, linux.
09:24:59 <ndm> dolio: try programming SYB stuff with higher-rank types, they crop up all the time :)
09:25:31 <dolio> Ah, well, you've got me there. :)
09:25:36 <mmorrow> jgrimes: i'm not sure exact details, but i'm not sure if the code harpy emits will work there
09:25:59 <mmorrow> jgrimes: there being 64bit
09:26:10 <jgrimes> mmorrow: yeah, I'm not sure either. I didn't see anything saying that it wouldn't work, just that it didn't currently support 64-bit ops
09:27:37 <mmorrow> jgrimes: assuming 32bit ops'll run unmodified on 64b arch, there must be some setup step(s)/something that aren't being taken
09:27:49 <mmorrow> jgrimes: that's my wild off the cuff guess at least
09:27:51 <quicksilver> there is some kind of mode switch isn't there?
09:27:58 <mmorrow> that's what i'd assume
09:28:03 <quicksilver> you need to "turn on i386 mode"
09:28:05 <quicksilver> whatever that means
09:28:09 <mmorrow> yeah
09:28:30 <mmorrow> jgrimes: figure it out and add it to harpy!!
09:28:46 <jgrimes> mmorrow: Looks like thats what I need to do
09:29:13 <mmorrow> jgrimes: :)!
09:29:40 <jfredett> hrmph, anyone know where any good STM tutorials are?
09:29:54 <jfredett> I've been poking around- can't find much of anything
09:30:25 <mwc> Hahahahah, OT, but hilarious:
09:30:27 <mwc> However, if there is one myth that the C++ committee considers heresy, it must by the myth of the Sufficiently Smart Compiler (one of life’s little ironies is how this view directly results in C++ compilers having to be the most sophisticated, complex, and nuanced compilers known to man.. but I digress).
09:30:53 <jfredett> heh
09:32:03 <mar77a> > ( 1 + (sqrt 5) ) / 2
09:32:06 <lambdabot>  1.618033988749895
09:32:12 <jfredett> yay for phi
09:32:13 <mar77a> > ( 1 + (sqrt 5) ) / 2 :: CReal
09:32:14 <lambdabot>  1.6180339887498948482045868343656381177203
09:32:49 <mar77a> is it possible that irrational numbers
09:32:54 <mar77a> are rational in a certain base
09:32:58 <vixey> yes
09:33:10 <jfredett> but not transcendental numbers, right?
09:33:16 <Beelsebob> no
09:33:19 <vixey> trancendental too
09:33:22 <dolio> What?
09:33:25 <vixey> 10 in base π = π
09:33:32 <jfredett> eg pi is irrational in any base, well, except for base pi I guess
09:33:34 <dolio> You mean like base e?
09:33:35 <Beelsebob> rational numbers can't be expressed as a fraction -- no matter what base you write the numerator and denominator in
09:33:41 <Beelsebob> oh, yeh, good point
09:33:50 <Beelsebob> so if you allow irrational bases
09:33:52 <Beelsebob> then yes
09:33:56 <mar77a> well, i meant without themselves as base
09:33:59 <Beelsebob> if you only allow integer bases, then no
09:34:09 <jfredett> I think the spirit of the question was if you allow only integral bases
09:34:12 <mar77a> is tehre any proof of this
09:34:22 <jfredett> mar77a: not until you write one
09:34:29 <mar77a> will i be rich!?
09:34:31 <jfredett> mar77a: get to work, test is on thursday
09:34:35 <jfredett> mar77a: probably not
09:34:37 <dolio> Shouldn't be too hard by the definition of irrational numbers.
09:34:40 <jfredett> the life of a mathematician is hard. :P
09:34:43 <vixey> mar77a: writing some number in some base is the same as expressing a number as a polynomial
09:34:43 <Beelsebob> it's fairly obvious isn't it -- converting bases is only a matter of a representation
09:34:52 <mar77a> yes
09:34:55 <mar77a> for example
09:34:58 <mar77a> take the number in binary
09:35:09 <Beelsebob> but irrational numbers have a solid definition that is independant of the numeric representation
09:35:10 <mar77a> 1.001000100001
09:35:12 <mar77a> and so on
09:35:24 <mar77a> maybe when you convert to base 10
09:35:43 <mar77a> you get like 1.27286434 ...blah blah irrational something
09:35:52 <mar77a> even if you DO get an irational number
09:35:55 <mar77a> in the other base
09:36:00 <Beelsebob> okay, proof sketch:
09:36:06 <mar77a> it might be ...somewhat patterni..zable
09:36:07 <mar77a> lol
09:36:10 <Beelsebob> suppose you have a number that is rational base n for some integral n
09:36:18 <mar77a> nooo don't say it
09:36:23 <mar77a> i want to do this myself :<
09:36:25 <jfredett> mar77a: having a pattern and being rational are two different things
09:36:29 <Beelsebob> that means there is a finitely long representation of it in that base
09:36:40 <mar77a> i don't care about the infinite decimals
09:36:49 <mar77a> i care about finding a pattern
09:36:49 <Beelsebob> so you can convert in finite time to any other base
09:36:51 <mar77a> in some other base
09:37:01 <Beelsebob> therefore it is rational in all bases
09:37:20 <Beelsebob> which is a contradiction, because we asserted that it was irrational in some other integral base
09:37:36 <mmorrow> > let phi=(1+(sqrt 5))/2  in mapM_ (putStrLn . flip replicate '#') (fmap (fromInteger . toInteger . round) . takeWhile (>=1) . iterate (/phi) $ 80)
09:37:43 <lambdabot>  <IO ()>
09:37:44 <mmorrow> oh noIO
09:37:48 <geezusfreeek> is this about whether an irrational number can be expressed as a rational number in a different base or something?
09:37:51 <jfredett> mmorrow: pwnd by /bot
09:37:54 <mar77a> yes
09:37:55 <mmorrow> ha
09:38:03 <geezusfreeek> yeah, that's not really correct
09:38:09 <mar77a> well maybe not rational but
09:38:16 <mar77a> less irrational
09:38:16 <dolio> forward-slashbot?
09:38:20 <mar77a> as in, a patterned irrational
09:38:22 <geezusfreeek> define "less irrational"
09:38:27 <mar77a> not sure what the word is
09:38:28 <geezusfreeek> if it's patterned it's not irrational
09:38:35 <quicksilver> if the pattern is a repeat
09:38:35 <geezusfreeek> oh patterned, not repeatingh
09:38:37 <quicksilver> then it's rational.
09:38:47 <quicksilver> otherwise, well it depends what you think you mean by 'pattern'
09:38:56 <mar77a> 1.234567891011
09:38:59 <mar77a> i was told that's irrational
09:39:08 <dolio> The one he posted is irrational, I imagine.
09:39:17 <quicksilver> the number '0.01001100011100001111....'
09:39:18 <dolio> 1.001000100001000001...
09:39:20 <hpaste>  morrow pasted "phi" at http://hpaste.org/8071
09:39:20 <geezusfreeek> perhaps changing base might be a way to explore a number and find a pattern, but the best pattern will be the algorithm used to generate the irrational number
09:39:22 <quicksilver> increasing numbers of 0s and 1s
09:39:31 <quicksilver> is not only irrational but also transcendental, as I recall
09:39:38 <dolio> Yeah, that sounds right.
09:39:40 <mar77a> trascebdebtal then means
09:39:43 <quicksilver> although it's normally pretty unpleasant trying to prove things are transcendental
09:39:45 <mar77a> irrational without pattern?
09:39:52 <quicksilver> it means not the root of any polynomial.
09:39:58 <mar77a> in english :)
09:40:01 <mar77a> :(
09:40:08 <mar77a> lemme just wiki it
09:40:10 <jkff> Of any polynomial with integer coefficients
09:40:18 <quicksilver> there is no equation x^n + 4*x^3 + 2*x^2 ... = 0
09:40:22 <quicksilver> such that x is the number
09:40:39 <quicksilver> the numbers you can get using "square roots and nth roots and stuff"
09:40:44 <quicksilver> are called algebraic
09:40:54 <quicksilver> the non-algebraics are called transcendental
09:41:00 <quicksilver> e and pi are famously transcendental
09:41:16 <jkff> Nope, roots of polynomials higher than degree 4 can't generally be expressed in terms of nth roots
09:41:21 <jkff> But they are still algebraic
09:41:37 <quicksilver> jkff: that was the "and stuff" :)
09:41:42 <jkff> Ok :)
09:41:48 <jfredett> I do all my counting in base e^(sqrt(-1) * pi) + 11
09:42:11 <jkff> Wow, I imagine everyone did his counting in this base
09:42:13 <Deewiant> most do
09:42:21 <jfredett> or sometimes in the same e^(sqrt(-1)*pi) + 3. but i digress
09:42:45 <geezusfreeek> i do my counting in -10 * e^(pi*i)
09:42:54 <geezusfreeek> err
09:42:56 <jfredett> geezusfreeek: ooh fancy.
09:43:06 <geezusfreeek> i didn't realize how similar that was you yours though
09:43:11 <mar77a> i do my counting in base haskell
09:43:14 <geezusfreeek> i thought i was being clever :P
09:43:18 <mar77a> > 1 + 1
09:43:18 <lambdabot>  2
09:43:58 <byorgey> I like base ()
09:44:02 <byorgey> > [(), (), ()] ++ [(), ()]
09:44:02 <lambdabot>  [(),(),(),(),()]
09:44:15 <jfredett> byorgey: shaddup, you make me feel inadequate as a mathematician.
09:44:29 <byorgey> > [ () | () <- [(), (), ()], () <- [(), ()] ]
09:44:30 <lambdabot>  [(),(),(),(),(),()]
09:45:20 <vixey> > (fix (():)) ++ [()]
09:45:21 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
09:45:38 <mmorrow> infinity plus one!!@
09:46:34 <byorgey> > tail (fix (():))
09:46:35 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
09:46:35 <mar77a> isn't the empty set THE source of numbers
09:46:37 <mar77a> or something like that
09:46:48 <mar77a> like 0 = (), 1 = (())
09:46:51 <vixey> in ZFC you usually define numbers out of sets
09:46:52 <vixey> {}
09:46:54 <vixey> {{}}
09:47:00 <vixey> {{},{{}}}
09:47:01 <vixey> something like that
09:47:05 <mar77a> smooth
09:47:05 <byorgey> mar77a: it's one way to formalize the foundations of mathematics.
09:47:07 <quicksilver> FSOV of usually.
09:47:18 <quicksilver> I'm not sure that's really a usual definitoin so much as an example.
09:47:22 <mar77a> looks like more than one person here has a degree in math
09:47:23 <vixey> I am more keen on data N = Z | S N
09:47:24 <quicksilver> After all the point is that the definition doesn't matter.
09:47:25 <vixey> :)
09:47:37 <quicksilver> the church encoding has more to recommend it
09:47:43 <edwardk> @type \h -> return (fix . h)
09:47:49 <quicksilver> it actually reflects the meaning of the number in some way.
09:47:51 <lambdabot> forall a (f :: * -> *) (m :: * -> *). (Monad m, Functor f) => f (a -> a) -> m (f a)
09:47:58 <mmorrow> (s/the empty set/the set containing no elts/)
09:47:58 <edwardk> @type \h -> mfix (return . h)
09:48:00 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> a) -> m a
09:48:00 <vixey> yeah set theory sucks
09:48:01 <vixey> :P
09:48:06 <quicksilver> alternatively just define the numbers as the equivalences classes under cardinality
09:48:13 <quicksilver> which is a common way to define cardinals
09:48:50 <edwardk> heh that seems to conflict with the definition given in the purity property of the mdo paper.
09:49:02 <edwardk> i guess fix h it is
09:49:07 <geezusfreeek> > -10 * exp (0 :+ pi)
09:49:08 <lambdabot>  10.0 :+ (-1.2246063538223773e-15)
09:49:18 <edwardk> and a bug in http://citeseer.ist.psu.edu/erk02recursive.html =)
09:49:19 <lambdabot> Title: A Recursive do for Haskell - Erk, John (ResearchIndex)
09:49:25 <geezusfreeek> heh, i've never used Complex before
09:50:50 <dcoutts_> @arr!
09:50:51 <lambdabot> Yeh scurvy dog...
09:50:52 <ski_> @type \h -> return (fix P.. h)
09:50:54 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> a -> a) -> m (a1 -> a)
09:51:39 <Vq^> welcome back mr Coutts
09:51:39 <edwardk> ski: interestingly the got the law right 2 years earlier in their other recursive monad paper
09:51:51 <dcoutts_> Vq^: oh thanks :-)
09:51:59 <edwardk> http://citeseer.ist.psu.edu/erkok00recursive.html has the correct law
09:51:59 <lambdabot> Title: Recursive Monadic Bindings - Erkok, Launchbury (ResearchIndex)
09:52:18 <ski_> edwardk : possibly an error in translation from CT to haskell ..
09:52:36 <edwardk> i think its just a transcription error
09:52:51 <ski_> m
09:53:05 <hpaste>  morrow annotated "phi" with "omg" at http://hpaste.org/8071#a1
09:54:00 <edwardk> morrow: cute =)
09:54:55 <edwardk> morrow: you could fuse the two fmaps, no?
09:54:56 <mmorrow> heh
09:55:14 <mmorrow> probably, but quick and dirty
09:55:17 <edwardk> let phi=(1+(sqrt 5))/2; xs = fmap (flip replicate '#' . fromInteger . toInteger . round) . takeWhile (>=1) . iterate (/phi) $ 80) in mapM_ putStrLn (cycle (xs++reverse xs))
09:56:00 <mmorrow> it'd be prettier also if the doubling at the high/low points was eliminated
09:56:06 <edwardk> yeah
09:56:11 <edwardk> pretty arches though
09:56:29 <edwardk> cycle xs ++ tail (reverse xs) =)
09:56:30 <mmorrow> it's hypnotizing watching them fly by in ghci
09:56:48 <edwardk> er
09:56:52 <edwardk> @type init
09:56:54 <lambdabot> forall a. [a] -> [a]
09:57:01 <edwardk> init (reverse xs) i guess
09:57:12 <edwardk> or tail xs ++ reverse xs
09:57:16 <edwardk> probably nicer performance
09:57:34 <edwardk> or xs ++ reverse (tail xs) even
09:57:35 <edwardk> gah
09:57:42 <mmorrow> you gotta do (tail xs++tail (reverse xs))
09:57:52 <mmorrow> (i found out the hard way
09:57:54 <mmorrow> )
09:57:56 <edwardk> ah
09:59:10 <edwardk> hrmm tail xs seems to work here, or do you mean to also remove the top of the arch?
09:59:17 <mmorrow> yeah (the later)
09:59:45 <mmorrow> matter of preference
09:59:49 <dsrogers> why does init mean to remove the last element of a list?
09:59:57 <dsrogers> what is "init" short for?
10:00:01 <Igloo> Initial
10:00:09 <dsrogers> but it takes the last one.
10:00:14 <Deewiant> > init [1..10]
10:00:14 <dsrogers> why is that the initial one?
10:00:15 <lambdabot>  [1,2,3,4,5,6,7,8,9]
10:00:23 <Igloo> It returns the initial elements
10:00:25 <Deewiant> it keeps the initials
10:00:28 <mmorrow> > last [0..9]
10:00:30 <lambdabot>  9
10:00:31 <dsrogers> ah
10:00:38 <edwardk> head/tail vs last/init
10:01:08 <edwardk> crappy counter intuitive name i'll admit ;)
10:01:34 <dsrogers> are last/init as inefficient as I'm guessing?
10:01:38 <dsrogers> like O(n)?
10:01:47 <edwardk> pretty much
10:02:14 <edwardk> if you use the whole list anyways (last is definitely, init may be slightly more efficient in practice due to laziness)
10:03:18 <Deewiant> @src init
10:03:19 <lambdabot> init [x]    = []
10:03:20 <lambdabot> init (x:xs) = x : init xs
10:03:20 <lambdabot> init []     = undefined
10:04:04 <jfredett> anyone know where any good STM tutorials are?
10:04:13 <mrd> spj's papers
10:04:29 <jfredett> I've got those, was wondering if there are any others
10:04:40 <jfredett> I like to have as many as possible available
10:05:03 <mrd> not that much to it really..
10:05:07 <jfredett> darn.
10:05:10 <jfredett> okay
10:05:11 <mrd> atomic, retry, orElse
10:05:22 <jfredett> I suppose it can't be that difficult.
10:05:33 <mmorrow> write code that uses MVars and Chans, then translate it to use TMVars and TChans (that was my strategy)
10:06:02 <mrd> in a way, except that MVars can get you into trouble that TMVars won't (yay STM)
10:06:09 <edwardk> jfredett: keep yout transactions as short as you can to avoid thrashing and its generally pretty easy
10:06:09 <mmorrow> zactly
10:06:19 <mmorrow> mrd: zactly
10:06:22 <jfredett> edwardk: that shouldn't be too hard, I suppose
10:06:50 * bos reads Control.Parallel.Strategies and weeps
10:06:58 <mmorrow> mrd: that's how i arrived at the idea to move to T*
10:07:05 <mmorrow> mrd: heh
10:07:12 <dons> bos, it doesn't have a czar
10:07:20 <dons> we need a strategies czar
10:07:30 <bos> the code is complete crap.
10:07:33 <mrd> tselect = foldl orElse retry . map (\(ch, ty) -> (flip (,) ty) `fmap` readTChan ch) -- wouldn't try this w/o STM
10:07:48 <jfredett> which of SPJ's papers should I use -- http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory
10:07:50 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/yybhes
10:07:55 <jfredett> there are three --
10:08:03 <mrd> composable memory transactions
10:08:10 <dons> bos, so poor list ops and so on?
10:08:11 <jfredett> cool
10:08:14 <dons> messing up things?
10:08:14 <sclv> there was another paper about designing a specific lock free data structure with STM too
10:08:16 <edwardk> i seem to recall peyton-jones talking about how the strategy stuff pretty much evolved to this dead end, no?
10:08:21 <sclv> (not spj)
10:08:30 <dons> bos, i hope you can summarise/make recommnedations on how we can fix this stuff.
10:08:34 <bos> dons: many of the definitions for evaluating to a normal form force conversion to a list first
10:08:42 <bos> dons: e.g. arrays, maps, you name it.
10:08:47 <dons> right. so we can definitely do a new version that fixes that.
10:08:55 <bos> it's clear that barely a hint of thought went into the code.
10:08:58 <dons> they're much like writing Binary instances
10:09:16 <mrd> Drift could derive NFData
10:09:30 <sclv> bos: use traverse instead, then? (or zoinks, even fmap would work.)
10:09:35 <bos> deriving NFData isn't hard for trivial types.
10:10:25 <Pingouin> do you know a nice library that allow me to draw statistical graphics, like "Erlang Graphical Drawer" in Erlang ?
10:10:56 <bos> i'm going to shelve the idea of writing about par and strategies for RWH.
10:11:18 <mmorrow> Pingouin: find some way to use R from haskell (a continual/ongoing battle of mine)
10:12:11 <Pingouin> there isn't any library :-( ?
10:12:16 <mmorrow> (every|any) thing pales in comparison to R for statistical graphics
10:12:24 <mrd> @arr
10:12:25 <lambdabot> Arrr!
10:12:28 <sclv> a highly efficient set of parallel list strategies would be really nice, since 90% of the time, folks will probably just resort to a parMap or such...
10:12:29 <dons> Pingouin: there's a lot of chart and graphing libs now on hackage
10:12:33 <mrd> lambdabot agrees
10:13:00 <dons> bos, i wonder if you want to throw together some conclusions from this survey of the current `par` stuff
10:13:05 <bos> sclv: the existing parallel list strategies are fine.  it's very rare for parMap to do anything other than slow your code down.
10:13:10 <dons> make some suggestions on what needs fixing, what needs to be developed
10:13:24 <sclv> ah its just the rnf stuff then?
10:13:45 <mrd> i used parMap for a (fairly sizable) app once and got a speedup
10:14:02 <edwardk> mrd: i think the keyword is 'once' =)
10:14:19 <Pingouin> dons: i always forget to search on Hackage :/ in 34 libs, i hope there is a math one :) ty
10:14:23 <sclv> You just need a problem that generates a list of expensive thunks, no?
10:14:42 <dons> Pingouin: there's 534 libs on hackage now, 'chart' might be ok for graphing?
10:15:01 <mrd> yeah :) each element of the list was a solution to an independent search problem
10:15:07 <mmorrow> needs cairo (not that that's a problem)
10:15:25 <mmorrow> just fyi
10:15:44 <mmorrow> (directed at Pingouin)
10:16:08 <Pingouin> dons: yah it seems to be what i seek :) . And it is updated :D !
10:16:23 <dons> i
10:16:31 <dons> think we need a big sign on haskell.org about hackage.
10:16:48 <vixey> I got my first compiler in haskell :D
10:17:29 <vixey> it turns (1 + (3 + 4)) into PUSH 3, PUSH 4, ADD, PUSH 1, ADD
10:17:30 <Pingouin> hachage isn't well referenced, so it isn't well known :/
10:17:47 <dons> vixey: woot!
10:17:58 <dons> Pingouin: how could we improve it, so you would find it?
10:18:02 <vixey> hehe
10:18:43 <Pingouin> as you said : a big link on haskell.org :D
10:20:09 <bos> sclv: if you have a problem that is both concise, useful, and generates expensive thunks, i'm all sensory organs.
10:20:23 <mmorrow> Pingouin: also, check out hmatrix. *fast* linear algebra. (also has a plot module for shooting stuff to gnuplot a la (matlab) octave, but just for quick viewing).
10:20:25 <slavik> jkff: question ... in the tutorial, you are describing the actual monads and how they work and then the general rule about monads?
10:20:55 <bos> performance considerations apart, it's really frickin' hard to come up with good parallel programming examples that are short.
10:21:07 <sclv> bos: jdh's parallel Set.unions seems like a reasonable one (although parMap alone won't cut it)
10:21:15 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8073
10:22:04 <ddarius> vixey: You need a bit more interesting source language (or a bit more interesting target language).
10:22:26 <vixey> ddarius: I am going to add booleans and conditionals next
10:22:36 <Apocalisp> > let split = (\delim -> takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (==delim)))
10:22:36 <lambdabot>  Parse error at end of input
10:22:41 <bos> sclv: you'd think so, but i actually write a hierarchical Map.unions and it was a lose.
10:23:15 <ddarius> vixey: conditionals as in if/then/else will be a bit more interesting, loops are where things get tricky
10:23:24 <Apocalisp> please let split ...
10:23:25 <vixey> yeah I am looking forward to it :D
10:23:34 <bos> sclv: the funny thing was, the hierarchical version was faster serially than a single invocation of unions.  but the parallel version was ... meh.
10:23:39 <ddarius> vixey: It will be more fun than and infix to RPN translator.
10:23:56 <Philippa_> vixey: depending on what you're doing, you might want to add mutable cells first?
10:24:11 <sclv> bos: heh. did you chalk that up to spark cost?
10:24:19 <dons> sick of reading boring tech articles?
10:24:23 <bos> sclv: couldn't tell. no profiling tools.
10:24:27 <vixey> oh yeah I should try mutation
10:24:31 <dons> want some fun haskell optimisation blog?
10:24:38 <vixey> I can model state monad
10:24:39 <dons> try part 2 of "haskell as fast as C", http://reddit.com/info/6lx36/comments/
10:24:40 <vixey> I think
10:24:44 <dons> available to all good haskellers.
10:24:45 <dcoutts_> dons: yes please
10:24:45 <vixey> oh cool dons
10:24:46 <ddarius> Mutation is straightforward.
10:25:00 <ddarius> dons: What about bad Haskellers?
10:25:06 <dons> bos, we have no way of measuring spark costs, do we.
10:25:10 <sclv> bos: one idea could be something silly like chopping the input list in half, and then just parallelizing the unions over those two halves...
10:25:25 <dons> ddarius: also accepted.
10:25:32 <sclv> (at which point strategies doesn't buy you much, i'll grant)
10:25:34 <dons> upmods welcome.
10:26:12 <heavensrevenge> salut
10:26:29 <bos> dons: no.
10:26:49 * dolio dies a little each time he sees 'takeWhile foo . unfoldr (Just . bar)'.
10:26:57 <bos> sclv: that's essentially what i did.
10:26:59 <ddarius> dons: A reference to ndm's superopt doesn't seem inappropriate.
10:27:00 <dons> yeah, so that's a big issue, eh bos. sparks hae unknown cost.
10:27:17 <dons> ddarius: true. i should read the paper again
10:27:27 <sclv> bos: as in just two sparks total, rather than recursive parallelization?
10:27:47 <dons> but its the same thesis, ddarius, isn't it. -- high level code, more info for the compiler
10:27:49 <bos> sclv: yep.
10:27:56 <sclv> and still no benifit?
10:28:10 <dons> hmm. i'll start a strategies wiki page
10:28:17 <sclv> yikes
10:28:19 <dons> we need to collect this info somewhere.
10:30:15 <bos> dons: why doesn't CPR and currying in the compiler transform your foldl' loop into something sexy?
10:30:28 <dons> we don't have nested CPR
10:30:33 <Deewiant> dons: 'fusible list' is a broken link there, has an excess 'j' at the end
10:30:37 <dons> so (Int, Int) looks like Pair (Int x) (Int y)
10:30:45 <dons> which cpr won't get past the Pair
10:30:49 <dons> Deewiant: cheers
10:31:14 <dons> bos, maybe if foldl'-rnf hit it, the pair would unwrap first.
10:31:17 <dons> i should check that
10:31:54 * geezusfreeek upmods
10:33:09 <bos> dons: that's a great blog article.
10:33:52 <sclv> bos: a parallelized mergesort would be another obvious one to try?
10:34:08 <dons> cheers. there's 6k words now on performance stuff. i'm going to distill that into the performance chapter, with some other examples
10:34:11 <dons> and profiling stuff
10:34:25 <bos> awesome.
10:34:47 <dons> i really want readers to be able to reason concretely about the code all the way through to runtime
10:34:58 <dons> remove any doubt and unpredictability
10:35:30 <bos> sclv: i tried a parallel quicksort, which should have similar nice properties, and no dice.
10:35:56 <dcoutts_> dons: the link to the stream-fusion package has a 'j' typo suffix
10:36:02 <dons> fixed.
10:36:04 <dons> reload.
10:36:12 * sclv cries a little, inside.
10:36:21 <Deewiant> dcoutts_: I found it first!
10:36:27 <dcoutts_> so you did :-)
10:36:31 <Apocalisp> how to get a String from a ShowS?
10:36:37 <Deewiant> @hoogle ShowS
10:36:37 <vixey> @src ShowS
10:36:39 <lambdabot> Prelude.ShowS :: type ShowS
10:36:39 <lambdabot> Text.Show.ShowS :: type ShowS
10:36:39 <lambdabot> Prelude.shows :: Show a => a -> ShowS
10:36:39 <lambdabot> type ShowS = String -> String
10:36:48 <vixey> ($"")
10:36:54 <vixey> :t ($"") :: ShowS -> String
10:36:57 <bos> sclv: part of the problem there is that trying to sort a list is just a horribly cruel thing to do to oneself in any case.
10:36:58 <lambdabot> ShowS -> String
10:37:14 <bos> sclv: but in order to do a sort of an array, one really wants to do it in-place.
10:37:32 <bos> sclv: and then you're in the ST or IO monad, and lose the ability to use par.
10:38:05 <dons> we get slightly better code with fold'rnf bos
10:38:07 <dons> interesting.
10:38:12 <dons> foldl'rnf f z0 xs0 = go z0 xs0
10:38:12 <dons>   where
10:38:12 <dons>     go !z []     = z
10:38:12 <dons>     go !z (x:xs) = rnf z `seq` go (f z x) xs
10:38:31 <dons> the Int component of the state pair is unboxed.
10:38:47 <sclv> right -- so a list sort won't better an in-place sort, but a parallel list sort might still better a sequential one?
10:38:50 <dons> mm. Data.Strict.Stragies, anyone?
10:39:34 <dons> ah there we go. a proper foldl'
10:39:44 <dons> foldl'rnf f z0 xs0 = go z0 xs0
10:39:44 <dons>   where
10:39:44 <dons>     go !z []     = rnf z `seq` z
10:39:44 <dons>     go !z (x:xs) = rnf z `seq` go (f z x) xs
10:39:58 <dons> turns (Double, Int) into                -> Int# -> Double#
10:40:29 <dons> removing the lazy pair penalty
10:40:46 <sclv> dons: nice!
10:42:04 <hpaste>  dons pasted "rnf foldl'" at http://hpaste.org/8074
10:42:57 <ddarius> Perhaps we should have a RNF class but just for "tuple" types.
10:44:01 <sclv> what about the surrounding code? do the calls to `seq` lead to issues elsewhere, or to they just get rolled into the unboxing?
10:44:20 <ddarius> dons: The interesting thing about ndm's example is that no "special" help is given to the compiler either in the form of rewrite rules or having specially written library functions.
10:44:34 <ddarius> sclv: If the type gets unboxed, then seq will go away.
10:44:35 <dons> ddarius: just some large, unspecified optimisation :)
10:44:54 <dons> basically, the rules are in the ndm module of the compiler, instead of in the library
10:45:25 <dons> yeah,seq is an abstract thing. it's like `typeOf'` a remnant of the days before we had bang patterns
10:45:32 <dons> asTypeOf, I mean,
10:45:40 <dons> a function from the type before type annotations
10:45:49 <dons> so seq is the function from the time before strictness annotations
10:48:09 <ddarius> http://neilmitchell.blogspot.com/2007/07/making-haskell-faster-than-c.html
10:48:10 <Igloo> Before scoped type variables, you mean (for asTypeOf)
10:48:11 <lambdabot> Title: Neil Mitchell's Haskell Blog: Making Haskell faster than C!, http://tinyurl.com/22wrv8
10:49:13 <dons> Igloo: yeah.
10:49:36 <bos> sclv: oh, i wrote a parallel quicksort, and it either crashes with an RTS error or takes an unpredictable amount of time.
10:50:03 <bos> sclv: for example 8x longer than the same code run with -RTS -N1
10:51:35 <Igloo> bos: Is that quicksort parallel at the first split only, or at all levels?
10:51:48 <bos> Igloo: all levels currently.
10:52:05 <bos> Igloo: well, down to the point where the input list is 512 elements long.
10:53:15 <bos> but changing the depth at which i stop sparking mostly affects when the RTS crashes.
10:54:10 <bos> i think the RTS bug is fixed, but i'm waiting on a "blessed" 6.8.3 release candidate to try.
10:54:31 <bos> since i can't build the current 6.8.3 release candidate due to that network compilation problem.
10:55:24 <Igloo> That should be fixed now
10:55:52 <newsham> do any of the haskell compilers generate itanium asm?
10:56:04 <bos> Igloo: yes, i saw you closed the bug. thanks.
10:57:01 <dons> newsham: only via-C
10:57:02 <pejo> ddarius, there's a paper on ndm's homepage that is more recent than the blogpost you linked to.
10:57:34 <newsham> I bet a pure language like haskell would bet a lot easier to map to an EPIC cpu like itanium.
10:58:12 <bos> newsham: itanic is well known to be a horrible compiler target.
10:59:02 <newsham> because compiler technologies have not yet been able to statically schedule the code to the level that could maximize EPIC
10:59:12 <newsham> which seems like an interestin research problem
10:59:12 <RayNbow> dons, are there any plans of replacing Data.List by Data.List.Stream?
10:59:47 <bos> RayNbow: nope. the stream version changes some of list's strictness properties.
11:00:20 <dons> bos, not true :)
11:00:25 <dons> we were really careful about that.
11:00:32 <bos> dons: it was true a few months ago, iirc.
11:00:38 <dons> but the plan at the moment is to just use an alternative list library
11:00:49 <dons> instead of Data.List use Data.List.Stream functions
11:00:57 <bos> yeah.
11:01:19 <dons> bos, the lib has a testsuite which checks all the strictness properties. and jeremy gibbons did a proof for us, so should be ok.
11:01:34 <bos> oh, good. i wonder what i'm remembering then.
11:02:39 <dons> so as long as you can live without list comprehensions and are ok with enumFromTo over [1.. n], there's little burden
11:02:47 <pejo> dons, (late reply) what do you mean with unspecified optimisation? :-)
11:03:04 <dons> pejo: well, i'll wait till i see the formalisation
11:03:21 <newsham> too bad no monad comprehensions....
11:03:48 <pejo> dons, would the positive supercompilation paper from 96 count?
11:04:26 <dons> if that's what ndm implemented inside his yhc fork, sure.
11:05:49 <geezusfreeek> dons: you say no list comprehensions. what is this? http://www.cse.unsw.edu.au/~dons/code/streams/list/desugar/Desugar.hs
11:05:50 <sclv> is it really a fork? I thought it was just a very complex core-to-core transform.
11:05:51 <lambdabot> http://tinyurl.com/6hetoa
11:06:13 <geezusfreeek> appears to be a preprocessor for list comprehensions?
11:07:04 <pejo> dons, Figure 5 in http://www-users.cs.york.ac.uk/~ndm/downloads/draft-supero-10_dec_2007.pdf I would guess.
11:07:05 <lambdabot> http://tinyurl.com/6mfs3q
11:09:02 <dons> those look simple enough. it'd be interesting to describe how that differs from ghc's current simplifier rules
11:09:20 <dons> point 1. looks like "Case-of-Case"
11:10:29 <pejo> dons, it's really close to the deforestation algorithm described in Marlow's thesis afaik. And yes, it's the case-of-case afaik.
11:11:30 <pejo> dons, but yes, I'm interested in that as well - if GHC does so much already, why don't do full-blown deforestation?
11:12:15 <dolio> geezusfreeek: Installing Data.List.Stream won't make GHC use that preprocessor for list comprehensions, though.
11:12:24 <PeakerWork> with a mutable language, I can have an array with O(1) amortized "append" and O(1) access.  Is there any way to approximate this with vanilla Haskell data types?
11:12:26 <gpds> preflex: seen jdh31
11:12:27 <preflex>  Sorry, I haven't seen jdh31
11:13:13 <dons> geezusfreeek: that's a patch against ghc we used
11:13:14 <Deewiant> PeakerWork: I'd be surprised if the IO or ST arrays didn't have such performance
11:13:19 <dolio> PeakerWork: You could make a wrapper around one of the MArray types.
11:13:38 <dolio> To auto-expand in the way that'd get you amortized O(1) whatever.
11:16:36 <jkff> PeakerWork, it can be proven that one can't have a persistent mutable random access data structure with O(1) indexing
11:16:58 <b_jonas> jkff: that can actually be proven?
11:17:00 <b_jonas> wow
11:17:07 <b_jonas> I thought it was just suspected
11:17:27 <jkff> Yes, I asked once in a community, and someone gave a simple proof :) I'll take a minute to look it up..
11:17:40 <b_jonas> does it apply for randomized algorithms?
11:17:50 <b_jonas> like some variant of hashes?
11:18:23 <b_jonas> also, I wonder, is it for pointer machines or ones that can have array indexing as well
11:19:22 <b_jonas> by the way, I just borrowed the Okasaki book so I'll learn more about persistent structures this month
11:20:04 <PeakerWork> jkff, Deewiant: I don't mind if it isn't persistent then
11:20:33 <PeakerWork> dolio, what is MArray, and how can it be expanded in O(1) amortized?
11:21:04 <dolio> Same way you'd do it in any language with mutable arrays.
11:21:31 <b_jonas> PeakerWork: MArray is not resizable, so you have to track the length and double it if it grows too much
11:22:33 <b_jonas> but is an MArray really guaranteed to be amortized O(1) time random access if you only use the newest copy?
11:22:45 <jkff> Hm, I found the proof but I don't get it, although it is short and informal :( I guess I'm just tired, maybe tomorrow.
11:22:56 <b_jonas> jkff: oh, never mind
11:23:00 <b_jonas> it's not important
11:23:04 <quicksilver> MArray does no such clever tricks.
11:23:09 <quicksilver> old copies don't exist.
11:23:14 <quicksilver> were you thinking of DiffArray?
11:23:15 <dolio> MArrays are just ordinary mutable arrays.
11:23:29 <b_jonas> quicksilver: probably, what are MArrays then?
11:23:37 <quicksilver> just plain arrays
11:23:40 <quicksilver> C-style.
11:23:42 <b_jonas> aren't mutable arrays called IOArray and STArrays?
11:23:43 <quicksilver> a pointer.
11:23:44 <dolio> Or, it's a class that covers several types (IOArray, STArray, unboxed variants).
11:23:45 <quicksilver> if you will.
11:23:56 <quicksilver> MArray is the class that IOArray and so on inplement.
11:24:05 <jkff> OK, I'm going home, bye everyone
11:24:08 <b_jonas> oh, MArray is the class!
11:24:11 <MedeaMelana> byebye!
11:24:14 <b_jonas> IOArray implements that?
11:24:18 <quicksilver> yes.
11:24:26 <b_jonas> I thought only IArray, UArray, and DiffArray implements that
11:24:31 <b_jonas> IOArray has a different type
11:24:36 <quicksilver> IArray is a class, too.
11:24:37 <b_jonas> I'll look these up
11:24:45 <b_jonas> wtf
11:24:49 <dolio> IArray is for immutable arrays. MArray is mutable arrays.
11:24:57 * b_jonas fires up the docs
11:25:14 <quicksilver> Array is a concrete type, and instance of IArray
11:25:26 <quicksilver> IOArray is also concrete, and an instance of MArray
11:25:42 <quicksilver> for certain particular member types there are U (unboxed) variants
11:25:48 <b_jonas> right
11:26:00 <b_jonas> and IArrays have Eq elementwise, right?
11:26:24 <quicksilver> if their elements do, yes.
11:26:25 <Deewiant> no, just Ix indexwise
11:26:43 <Deewiant> @src IArray
11:26:43 <lambdabot> Source not found. You type like i drive.
11:26:52 <quicksilver> it makes sense to compare IArrays as values.
11:26:58 <quicksilver> MArrays are by nature only references.
11:27:01 <b_jonas> IArray is an abstract class, you can't extend it with new stuff
11:27:06 <b_jonas> which is why it doesn't have a source
11:27:13 <quicksilver> you can only "do stuff" to MArrays in a monad
11:27:18 <Deewiant> I was hoping for the class's definition
11:27:29 <quicksilver> so MArrays can't be Eq
11:27:37 <quicksilver> but they can have a pseudo eq
11:27:38 <Deewiant> class IArray a e where bounds :: Ix i => a i e -> (i, i)
11:28:04 <b_jonas> yes
11:28:15 <satish> hi
11:28:23 <b_jonas> and IOArray is sort of like an Array of IORef elements
11:28:24 <quicksilver> Eq e, MArray a e => pseudoCmp :: a i e -> a i e -> m Bool
11:28:34 <quicksilver> very much like.
11:28:45 <quicksilver> conversely an IORef is very much like an IOArray with only one elt.
11:29:22 <b_jonas> but can you actually use the general interface of MArray, as opposed to just IOArray?
11:29:58 <b_jonas> and there's IOUArray it seems, which is unboxed
11:30:20 <PeakerWork> dolio, ordinary mutable arrays are great for my purpose here
11:30:23 <dolio> Yeah, you can write functions that will work on any MArray.
11:30:32 <PeakerWork> I don't need persistency here
11:30:58 <mmorrow> b_jonas: IO*Array is an instance of MArray, so just call those funcs on your IO*Array
11:30:59 <b_jonas> PeakerWork: then use an IOArray I think
11:31:07 <b_jonas> mmorrow: surely
11:31:09 <mmorrow> b_jonas: (if that is what you meant)
11:31:09 <b_jonas> but I mean
11:31:12 <mmorrow> heh
11:31:29 <b_jonas> what point does the MArray class have that the instances IOArray doesn't give you?
11:31:46 <b_jonas> which is what dolio says it has,
11:31:50 <b_jonas> but I can't really see how
11:32:10 <b_jonas> does it have to do with STL?
11:32:13 <PeakerWork> @src MArray
11:32:15 <lambdabot> Source not found. Wrong!  You cheating scum!
11:32:21 <b_jonas> um
11:32:22 <PeakerWork> @hoogle MArray
11:32:22 <lambdabot> Data.Array.MArray :: module
11:32:22 <lambdabot> Data.Array.MArray.MArray :: class Monad m => MArray a e m
11:32:22 <lambdabot> Data.Array.IArray.accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
11:32:23 <b_jonas> MTL
11:32:56 <PeakerWork> the @src can't seem to find Data.Array.MArray
11:33:05 <mmorrow> i think i'm misunderstanding you. IOArray is an instance of MArray, so it gets that interface. Without MArray, it's interface (interface:=class functions) don't exist
11:33:11 <mmorrow> b_jonas: ^
11:33:26 <b_jonas> mmorrow: I know that,
11:33:29 <b_jonas> but I mean
11:33:33 <mmorrow> then i dont get it
11:33:45 <mmorrow> (don't get what you're trying to say)
11:33:47 <b_jonas> MArray is a common interface of IOArray and STArray
11:33:54 <mmorrow> yesh
11:33:54 <b_jonas> and I don't get how you could use the common interface
11:33:55 <b_jonas> that is
11:34:04 <b_jonas> what function could you write that works with both IOArray and STArray
11:34:08 <b_jonas> and uses that interface
11:34:17 <mmorrow> they're two diff functions!
11:34:37 <dolio> Same way you write functionst that work on any Num.
11:34:47 <b_jonas> dolio: sure
11:34:52 <b_jonas> but I mean meaningful functions
11:34:56 <b_jonas> number is a useful abstraction
11:35:05 <b_jonas> I can imagine functions that work on any num
11:35:09 <b_jonas> like polynomials
11:35:14 <b_jonas> polynomial evaluation
11:35:23 <b_jonas> and scalar product of vectors
11:35:25 <b_jonas> and things like that
11:35:33 <dolio> Oh, I see what you're saying. Most of the class is hidden and there are other functions defined in terms of the hidden members that you use.
11:35:44 <dolio> Like newArray, readArray, writeArray...
11:35:53 <b_jonas> dolio: um, I don't care about that
11:35:58 <dolio> The actual class has unsafeRead and stuff, but those aren't exported.
11:36:01 <b_jonas> whether it's actually exposed as a method or as a function
11:36:10 <b_jonas> matters only if I want to write a new instance
11:36:39 <b_jonas> otoh
11:36:52 <b_jonas> if those functions are written in terms or more primitive methods
11:37:04 <b_jonas> that that implementation itself could be a good use of the class
11:38:39 <mmorrow> i still don't see where you're going with this, but go on (one of us though is overlooking something (probably after the fact) obvious i'm sure)
11:38:58 <b_jonas> probably it's not important
11:39:06 <b_jonas> I just wondered what purpose that class server
11:39:09 <b_jonas> serves
11:39:12 <dolio> Yeah, I don't see the problem. Using the functions in the Data.Array.MArray module, I'm pretty sure you could write, say, a prime sieve that works in any of IOArray, STArray, IOUArray, ...
11:39:17 <mmorrow> ""that that implementation itself could be a good use of the class" : what did you mean by this?
11:40:28 <b_jonas> mmorrow: well, if the readArray etc are implemented as complicated functions from simpler methods of MArray
11:40:58 <b_jonas> than that means the MArray class is used to avoid code duplication between IOArray and STArray
11:41:13 <b_jonas> and that MArray isn't primarily and interface for me
11:41:16 <b_jonas> just an implementation thingy
11:41:20 <b_jonas> that's exposed
11:42:05 <mmorrow> i guess all classes can be viewed as sugar, since you can just deal with the dicts yourself
11:42:17 <mmorrow> but most times that would suck
11:42:18 <Ben`> how can I make a list of the numbers 1 to 10 in a random order?
11:42:19 <maltem> b_jonas: It has been an interface for the writer of such a "complicated function"
11:42:36 <lament> @hoogle random
11:42:46 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
11:42:46 <lambdabot> System.Random :: module
11:42:46 <lambdabot> System.Random.Random :: class Random a
11:43:15 <b_jonas> but Ben` wants some kind of shuffle
11:43:18 <b_jonas> let's
11:43:23 <b_jonas> @hoogle shuffle
11:43:23 <lambdabot> No matches found
11:43:29 <b_jonas> in case it's already written
11:44:09 <twobitwork> > [1] >>= (\x -> return x)
11:44:13 <lambdabot>  [1]
11:44:19 <twobitwork> yay, lambdabot is back
11:44:52 <mmorrow> b_jonas: (also, this may or may not be related, IO is just a specialized ST)
11:44:56 <Deewiant> @pl concatMap return
11:44:57 <lambdabot> id
11:44:57 <lament> Ben`: what the System.Random module does provide is a function returning a random number in a given range, so you can write the shuffle recursively.
11:45:11 <roconnor> @seen shapr
11:45:12 <lambdabot> shapr is in #scannedinavian, #haskell-soc, #haskell-blah and #haskell. I last heard shapr speak 2h 9m 51s ago.
11:45:20 <roconnor> it works!
11:45:25 <b_jonas> mmorrow: yeah, part of the problem can be that I don't really understand ST
11:45:43 <lament> @git-shapr
11:45:43 <lambdabot> shapr!!
11:45:56 <b_jonas> I know its purpose is to do IORefs and such without being inside an IO
11:46:07 <b_jonas> but I don't actually know the details
11:46:08 <Ben`> lament: but how can I stop a number coming up twice?
11:46:32 <Deewiant> it seems to me that the idea behind ST is that a function can be internally impure but externally (referentially?) pure
11:46:41 <Deewiant> e.g. many C functions
11:46:48 <b_jonas> Deewiant: exactly
11:47:02 <Baughn> Ben`: Shuffling (efficiently) is hard enough that you really want to get a library function to do it. Really.
11:47:10 <Baughn> (Which reminds me, why isn't there one?)
11:47:22 <dolio> Lists or arrays?
11:47:41 <Deewiant> for lists, use Oleg: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
11:47:43 <dolio> Shuffling lists is pretty hard (if you want efficiency).
11:47:47 <lament> Ben`: take one number out of the list. You now have a number, and a list which doesn't contain this number anymore. Do this recursively.
11:47:56 <lament> Of course if Oleg already did it in the type system, you don't have to do it.
11:47:59 <dolio> Arrays aren't too hard.
11:48:11 <Ben`> ok I'll try, thanks
11:48:15 <dolio> Mutable arrays, that is.
11:48:38 <dolio> Immutable arrays you'd probably want to go through mutable arrays internally.
11:49:28 <b_jonas> well as we just talked about ST, can't you just use STArrays internally?
11:49:33 <b_jonas> for the shuffle
11:49:44 <Deewiant> for shuffling lists: if you don't care about efficiency you can use array-style shuffling and (!!), if you care somewhat you might want to try Oleg's or converting to an array and back, if you care a lot just use arrays all the time. ;-P
11:49:45 <dolio> Yeah.
11:50:04 <b_jonas> or you can just use Seq, that just gives a bit more log n multiplier to the time, who cares?
11:51:14 <lament> he needs to shuffle a list [1..10]
11:51:19 <maltem> > let shuffle g [] = []; shuffle g xs = let (i,g') = randomR (0,length xs - 1) g; (a,b:c) = splitAt i xs in b : shuffle g' (a ++ c) in shuffle (mkStdGen 0) [1..10]
11:51:26 <dolio> Seq wouldn't be too bad, I guess.
11:51:33 <dolio> It even has log n splitAt.
11:51:34 <lambdabot>  thread killed
11:51:36 <lament> maltem: won't work of course
11:51:51 <maltem> hm?
11:51:57 <lament> lambdabot doesn't do IO
11:52:03 <maltem> there's no IO involved
11:52:07 <maltem> mkStdGen, mind
11:52:08 <roconnor> @type mkStdGen
11:52:21 <lambdabot> Int -> StdGen
11:52:36 <maltem> > let shuffle g [] = []; shuffle g xs = let (i,g') = randomR (0,length xs - 1) g; (a,b:c) = splitAt i xs in b : shuffle g' (a ++ c) in shuffle (mkStdGen 0) [1..10]
11:52:40 <roconnor> pseudorandomness is pure
11:52:41 <lambdabot>  [6,3,2,9,8,10,7,4,5,1]
11:52:43 <lament> oh, true
11:53:17 <maltem> it's totally stupid, of course
11:53:27 <b_jonas> lament: doesn't it do ST even?
11:53:35 <maltem> especially considering using length in every recursive step
11:53:41 <b_jonas> oh wait, you need random numbers
11:53:47 <b_jonas> let's forget ST then
11:54:04 <dolio> You can get a pure generator.
11:55:00 <lament> it just isn't very random
11:55:07 <lament> over multiple runs :)
11:55:16 <b_jonas> oh yeah
11:55:17 <dolio> Well, you can get the generator from IO and pass it in.
11:55:20 <b_jonas> my j evalbot used to be like that
11:55:32 <Baughn> Seed the PRNG with the hash of the list?
11:55:38 <b_jonas> as it started a new interpreter for every line you ran, it used to return the same random numbers every time
11:55:43 <b_jonas> (unless you explicitly set the seed)
11:55:56 <b_jonas> but now I've changed it to at least save the seed and restore in one session
11:56:20 <b_jonas> so a user at least gets different results if he uses sessions and reruns a command
11:56:30 <maltem> That's how passing around generators is useful: Test them without IO using mkStdGen, but use newStdGen when you really need random values
11:57:30 <b_jonas> but you still get reproducible results
11:57:47 <roconnor> > maxBound :: Integer
11:57:50 <b_jonas> it might be better to just set the random seed to a random number every time
11:57:56 <lambdabot>   add an instance declaration for (Bounded Integer)
11:57:56 <lambdabot>     In the expression: ma...
11:58:09 <roconnor> > maxBound
11:58:10 <lambdabot>  ()
11:58:17 <roconnor> right
11:58:30 <maltem> > let shuffle g 0 _ = []; shuffle g n xs = let (i,g') = randomR (0,n - 1) g; (a,b:c) = splitAt i xs in b : shuffle g' (n-1) (a ++ c) in shuffle (mkStdGen 0) 10 [1..10] -- look, Ma, optimizing ;)
11:58:31 <lambdabot>  [6,3,2,9,8,10,7,4,5,1]
11:58:36 <Baughn> > minBound -- Does this even make sense?
11:58:38 <lambdabot>  ()
11:58:58 <b_jonas> sure it does, it just defaults to something which happens to be ()
11:59:21 <hpaste>  (anonymous) annotated "SPOILER: (naive) solution to this week's google treasure hunt" with "(no title)" at http://hpaste.org/8064#a2
11:59:32 <b_jonas> > minbound :: Ordering
11:59:33 <lambdabot>   Not in scope: `minbound'
11:59:51 <b_jonas> > minBound :: Ordering -- sorry for the typo
11:59:53 <lambdabot>  LT
12:00:35 <newsham> > succ LT
12:00:50 <lambdabot>  thread killed
12:00:52 <Baughn> @uptime
12:00:52 <lambdabot> uptime: 1d 7h 46m 45s, longest uptime: 1m 10d 23h 44m 29s
12:00:59 <Baughn> @load
12:01:02 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
12:01:18 <b_jonas> wtf
12:01:20 <b_jonas> why is that killed
12:01:34 <b_jonas> @eval succ (8 :: Int)
12:02:00 <Baughn> b_jonas: Basically, lambdabot doesn't work properly
12:02:17 <b_jonas> @eval 1 + (8 :: Int)
12:02:20 <Baughn> I'd bring in my own.. if someone would kill this one. :/
12:02:28 <Baughn> b_jonas: eval does nothing
12:02:36 <b_jonas> oh yeah, it's @run
12:02:40 <Baughn> Or >
12:02:41 <b_jonas> @run succ (8 :: Int)
12:02:44 <lambdabot>  9
12:02:56 <Baughn> > succ 8
12:02:58 <lambdabot>  9
12:03:11 <b_jonas> '>' too but that won't work in a @@ etc
12:03:54 <b_jonas> it gave the correct answer now
12:03:55 <b_jonas> wow
12:04:00 <roconnor> > succ ()
12:04:06 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
12:04:08 <Baughn> The machine it's on is just horribly overloaded, I think
12:04:14 <Baughn> Though I'm not entirely sure why that should matter
12:04:25 <newsham> > succ LT
12:04:30 <lambdabot>  EQ
12:05:18 <roconnor> > max () ()
12:05:19 <lambdabot>  ()
12:05:29 <roconnor> > max () undefined
12:05:37 <lambdabot>  Exception: Prelude.undefined
12:05:45 <newsham> > fix id
12:06:00 <lambdabot>  thread killed
12:06:15 <roconnor> max could stand to be a bit more lazy for () :P
12:07:14 <newsham> that would speed up a lot of programs!  ;-)
12:09:02 <roconnor> > fix show
12:09:04 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:09:05 <b_jonas> > succ x
12:09:06 <lambdabot> Terminated
12:09:21 <xerox> Should give 'y' :)
12:09:26 <Deewiant> > fix (++())
12:09:27 <lambdabot>  ()
12:10:00 <b_jonas> rocconor: actually I looked up last time and the H89 says min/max and comparisions are strict for Bool even when they could be lazy
12:10:06 <b_jonas> so it probably says that for () too
12:10:15 <newsham> nothing succs like success
12:10:23 <roconnor> b_jonas: oh
12:10:29 <roconnor> hmm
12:10:32 <b_jonas> H98 actually
12:10:40 <roconnor> :)
12:10:45 <augustss> I like H89
12:14:34 <b_jonas> the old C standard is from 89
12:14:34 <Cale> > False < undefined
12:14:34 <lambdabot>  Exception: Prelude.undefined
12:14:34 <Cale> > True < undefined
12:14:34 <lambdabot>  Exception: Prelude.undefined
12:14:34 <b_jonas> thoguh it has a version from 90 and such complications
12:14:34 <Cale> > undefined < True
12:14:34 <lambdabot>  Exception: Prelude.undefined
12:14:34 <Cale> yep
12:14:34 <xerox> > undefined < False
12:14:34 <lambdabot>  Exception: Prelude.undefined
12:14:34 <b_jonas> but you can usually use && and || and such or refine your own
12:14:34 <b_jonas> define your own
12:14:34 <ttt--> > undefined == undefined
12:14:34 <lambdabot>  Exception: Prelude.undefined
12:14:34 <roconnor> I wish GHC had an optimization flag for --remove-case-statements-when-all-branches-are-identical
12:14:34 <Cale> Oh, right, Bool uses a derived instance for Ord, so that's probably why...
12:14:34 <b_jonas> rocconor: how'd that work?
12:14:34 <augustss> roconnor: you must write strange code
12:14:34 <Cale> case expressions...
12:14:34 <b_jonas> doesn't it only work with lazy matches?
12:14:34 <b_jonas> like
12:14:34 <roconnor> b_jonas: it would replace the case statement with the expression occuring in all expressions.
12:14:34 <Cale> The simplifier doesn't do something like that already?
12:14:34 <augustss> It's not sound
12:14:34 <roconnor> augustss: I think it has come up on occassion
12:14:34 <Cale> hmm
12:14:34 <b_jonas> 'case x in { True -> y }' can't be simplified to y
12:14:34 <b_jonas> it can be simplified to x `seq` y
12:14:34 <Cale> x `seq` y
12:14:34 <roconnor> augustss: possibly from Coq extracted code...
12:14:34 <b_jonas> yes, that
12:14:34 <augustss> roconnor: ah, yes
12:14:34 <Cale> augustss: Or after inlining...
12:14:34 <b_jonas> bur it's more complicated because the matches can be deep
12:14:34 <roconnor> augustss: as Cale suggest, I think it can occur more natively too
12:14:34 <Cale> b_jonas: I believe there's a transformation which flattens them out anyway.
12:14:34 <augustss> it's only ok if you know the scrutinized expression isn't bottom
12:14:34 <roconnor> b_jonas: what happens when x is False?
12:14:34 <b_jonas> Cale: oh yeah,
12:14:34 <newsham> shouldnt the coq extractor be smarter?
12:14:34 <dsrogers> why x seq y?  is it possible for the evaluation of y to depend on the evaluation of x?
12:14:34 <b_jonas> roconnor: oh, I dunno
12:14:45 <b_jonas> maybe I should have written () instead of True
12:15:06 <Cale> dsrogers: If x is undefined, then case x of {...} will also be undefined.
12:15:09 <augustss> x `seq` y would be a sensible rewrite
12:15:11 <roconnor> augustss: I have no problem with the optimizer moving values up the CPO, so long as it doesn move values down.
12:15:18 <dsrogers> ah
12:15:25 <Deewiant> > case undefined of _ -> 1
12:15:26 <lambdabot>  1
12:15:27 <augustss> roconnor: I have
12:15:33 <Deewiant> Cale: ??
12:15:47 <roconnor> augustss: why?
12:15:49 <Cale> er, so long as the ... actually has a refutable pattern match in it :)
12:15:50 <augustss> > case undefined of () -> 1
12:15:51 <lambdabot>  Exception: Prelude.undefined
12:16:01 <bos> boy, the new reddit blows performance chunks.
12:16:13 <roconnor> bos: thank goodness for that.
12:16:15 <b_jonas> > case [1, undefined] of { [a, _] -> a }
12:16:17 <lambdabot>  1
12:16:17 <Cale> bos: really? I haven't noticed. It's not nearly as bad as gmail.
12:16:21 <b_jonas> > case [1, undefined] of { [_, a] -> a }
12:16:22 <Deewiant> Cale: so it depends on the case whether it's (seq x) or (id)  $ y :-)
12:16:22 <lambdabot>  Exception: Prelude.undefined
12:16:27 <bos> Cale: i had no idea gmail was slow.
12:16:37 <augustss> roconnor: I prefer to preserve semantics.  If the compiler makes my code more terminating, I might miss a bug that will show up later when that particular transformation doesn't apply
12:16:47 <Cale> Deewiant: yeah
12:16:55 <roconnor> augustss: that seems unlikely.
12:17:01 <newsham> < psygnisfive> ugh, kids these says with their "correctness"
12:17:02 <b_jonas> augustss: it's not only that, but it can make it less realtime
12:17:12 <b_jonas> that is, it would wait more later
12:17:25 <augustss> roconnor: perhaps.  but mostly it's because I think semantics should be preserved
12:17:28 <b_jonas> when you actually have to evaluate x
12:17:47 <roconnor> augustss: sounds dogmatic
12:17:47 <Cale> newsham: what?
12:17:48 <b_jonas> newsham: lol
12:18:03 <augustss> roconnor: so is purity and laziness
12:18:08 <b_jonas> I prefer semantics too
12:18:20 <roconnor> augustss: true, true
12:18:43 <roconnor> augustss: let's start with an experimental flag.
12:18:59 <augustss> I can handle that
12:19:05 <roconnor> augustss: there are some signifigant practical problems with such a transformation anyways
12:19:08 <Cale> The important thing is obviously to get incorrect results as quickly as possible.
12:19:10 <b_jonas> roconnor: well, we could have a flag that meand 'do unsafe optimizations'
12:19:19 <newsham> cale: obviously :)
12:19:20 <b_jonas> gcc already has a few such optimization flags
12:19:53 <b_jonas> most notable is -ffast-math
12:20:04 <Cale> bos: Oh, reddit actually seems to be server-side slow at present.
12:20:54 <newsham> ghc -fnot-necessarily-correct
12:21:06 <b_jonas> we could have a primitive 'optimize :: x -> x' which is mostly like id except sometimes is optimized to something faster and sometimes wrong
12:21:21 <b_jonas> or better 'optimize :: x -> IO x' which is like return
12:21:26 <roconnor> b_jonas: I really don't feel this is signfigantly destroying semantics.  Any correct program should output a total value anyways.
12:21:37 <bos> yum. bloom filter code chews through a million 1KB DNA sequences in 1.6 seconds, using just 8MB of RAM.
12:21:39 <roconnor> b_jonas: this flag just allows the compiler to assume your code is correct.
12:21:42 <newsham> "Increases laziness occasionally at the expense of correctness"
12:21:51 <b_jonas> roconnor: I don't think so
12:21:57 <b_jonas> just consider an interactive program
12:21:57 <sclv> bos: awesome!
12:22:00 <b_jonas> IO-interactive
12:22:05 <newsham> "do I really want to compute this long function?  umm.. the answer's "3""
12:22:07 <b_jonas> and consider that it's like this:
12:22:33 <roconnor> newsham: it preserves corrects according to my definition of correctness.
12:22:47 <roconnor> oh
12:22:49 <Cale> This point comes up quite often...
12:22:52 <roconnor> wait you are right
12:23:14 <b_jonas> main = do { let x = compute-answer; print (x seq "yes, there is an answer"); dramatic_pause; print ("it's " ++ x) }
12:23:15 <Cale> Whether it's okay to make optimisations that turn programs which were _|_ into programs which are not.
12:23:21 <roconnor> newsham: hmm
12:23:34 <b_jonas> the mice would come back four million years later and ask the program if it has an answer
12:23:42 <b_jonas> the program says, yeah, he does
12:24:01 <b_jonas> then it pauses dramatically and computes the answer for four million years because the compiler has optimized the program to be more lazy
12:24:22 <roconnor> Cale: am i the only one who brings it up? or are there others?
12:24:24 <b_jonas> Cale: I think that's incorrect if it's actually guaranteed by a docs that it's bottom
12:24:31 <Cale> roconnor: There are others, I'm fairly sure.
12:24:36 <b_jonas> but it might be correct if the doc just says either is correct
12:24:37 <hpaste>  dolio pasted "Array shuffle" at http://hpaste.org/8077
12:24:48 <roconnor> Scotts, CPO is a means not the ends.
12:24:49 <roconnor> er
12:24:54 <roconnor> Scott's CPO is a means not the ends.
12:24:55 <dolio> Woo, scoped type variables.
12:24:58 <Cale> b_jonas: The point isn't about what's documented -- we'd change the documentation accordingly
12:25:20 <roconnor> b_jonas: I see your point.  I'm not sure I'm happy with it or not.
12:25:21 <b_jonas> Cale: for functions you can, but not for the core haskell standard like case and seq
12:25:32 <Cale> b_jonas: Sure, you'd change the standard :)
12:25:34 <b_jonas> or head
12:26:02 <b_jonas> plus, it would sometimes be bad for security
12:26:17 <roconnor> b_jonas: huh?
12:26:37 <Cale> another example is, say, applying rewrite rules like  reverse . reverse = id
12:26:46 <b_jonas> well suppose the optimizer could optimize stuff from bottom to anything
12:27:16 <roconnor> Cale: good point.  The optimizer probably already has rules that raises values in the CPO
12:27:17 <Cale> Which is strictly speaking incorrect, but it's "morally correct"
12:27:21 <psygnisfive> newsham: :)
12:27:30 <bos> @seen edwardk
12:27:31 <lambdabot> edwardk is in #haskell. I don't know when edwardk last spoke.
12:27:37 <b_jonas> it would optimize 'if passwordIsCorrect then pay amount else error "go away"' using that the second branch is always bottom
12:27:59 <psygnisfive> i think edwardk was here this morning at like 3am est
12:28:13 <b_jonas> roconnor: does it?
12:28:28 <twobitwork> 13:13 is the last time he spoke in my lastlog
12:28:30 <roconnor> b_jonas: intresting.  Not quite what I had in mind by all case branches being the same.
12:28:32 <twobitwork> (est)
12:28:42 <roconnor> b_jonas: but it is something to be careful about.
12:29:05 <b_jonas> rocconor: obviously that case is simple, but there can be more complicated cases
12:29:12 <Cale> We would have to be more careful about abusing that sort of error.
12:29:42 <roconnor> b_jonas: no, i accept what you are saying here.  It would be up to me to prove that those examples would never get simplifed.
12:29:54 <roconnor> b_jonas: I accept what you are saying here.  It would be up to me to prove that those examples would never get simplifed.
12:30:28 <roconnor> but maybe Cale is right
12:30:31 <roconnor> something to think about
12:30:32 <b_jonas> roconnor: but that's a different thing
12:30:45 <roconnor> Maybe we should have a wiki page talking about the pros and cons.
12:30:46 <b_jonas> um, maybe not
12:30:47 <b_jonas> anyway,
12:31:25 <roconnor> Hmm.
12:31:29 <b_jonas> it's like when you implement a cpu, you wouldn't make it allow user programs to execute privilaged instructions because it simplifies the implementation and such programs are meaningless anyway
12:31:34 <roconnor> I mean, I wouldn't want to optimize away seq
12:31:45 <roconnor> maybe I don't want to optimize away error in the same way.
12:32:03 <b_jonas> and while it's specified that existing privilaged instructions raise what kind of error in a cpu and how it handles that
12:32:24 <PeakerWork> Newbie's opinion: would be great if things are changed so that   reverse . reverse = id   is a legitimate optimization
12:32:25 <b_jonas> a cpu could do anything for instructions reserved for further use
12:32:30 * chessguy sighs. where are all the good employers? everyone wants me for a junior .net or java guy
12:32:39 <b_jonas> but even a future processor can't add an instruction that breaks encapsulation
12:32:47 <roconnor> b_jonas: I don't think that is analogus
12:32:57 <chessguy> @bot
12:32:57 <b_jonas> if they add an instruction it has to be something that doesn't allow privilage gains
12:32:57 <lambdabot> :)
12:33:11 <roconnor> b_jonas: I beleive there are legitimate optimization to be done by case removal
12:33:20 <chessguy> @bot
12:33:27 <lambdabot> :)
12:33:27 <roconnor> Although I should find them and point them out.
12:33:33 <b_jonas> roconnor: sure, these are just obviously simple examples I gave
12:33:53 <dolio> You could be in trouble if you wrote code like 'case passwordIsCorrect of True -> pay amount -- inexhaustive patterns on False'. But who does that?
12:34:05 <PeakerWork> I think that to reap the full benefits of FP one must be more fuzzy about bottoms and evaluation orders and not guarantee too much behavior to the user
12:34:20 <tibbe> what are people's feeling on adding namespace-like prefixes or suffixes to function names instead of using modules for namespacing? I've seen two examples just the last week and I find it a little bit worrying (e.g. foldU, elemB instead of Array.fold and BloomFilter.elem)
12:34:29 <b_jonas> dolio: well I could write 'checkPassword seq pay amount'
12:34:44 <b_jonas> or something
12:34:51 <olsner> @pl \x -> f x (g x)
12:34:51 <lambdabot> ap f g
12:35:07 <b_jonas> or even if not in a trivial way
12:35:08 <olsner> nice :) thought I recognized the form
12:35:08 <dolio> Well, I just mean that roconnor's optimization would optimize that to 'pay amount', I think.
12:35:30 <sjanssen> tibbe: I think qualified names are more common
12:35:31 <dolio> But that code is terrible to begin with.
12:35:36 <tibbe> @yarr
12:35:36 <lambdabot> Yarrr!
12:35:54 <tibbe> sjanssen: I was thinking about uvector and the recent bloomfilter libraries
12:36:06 <edwardk> heya bos
12:36:17 <sjanssen> tibbe: uvector is the odd one
12:36:21 <roconnor> dolio: I wouldn't count those case braches as being the same expression
12:36:28 <bos> hi edwardk. i was trying to find the log of our conversation yesterday, and dug it out.
12:36:42 <dolio> roconnor: There's only one branch. It's the same as itself. :)
12:36:53 <roconnor> there are two braches
12:36:53 <tibbe> sjanssen: dons doesn't usually do that, I wonder why he did it for uvector
12:37:10 <edwardk> bos: have been sitting down with a bayesian statistician trying to find a closed form for the error term
12:37:11 <tibbe> @seen dons
12:37:11 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 1h 23m 57s ago.
12:37:15 <tibbe> dons: ping
12:37:18 <b_jonas> well, it might not optimize such trivial things, but for more complicated cases possibly after other optimizations steps it could happen
12:37:23 <roconnor> one brach returns pay amount, the other branch returns error.
12:37:32 <roconnor> even if the other branch isn't written
12:37:32 <bos> edwardk: nice to have such people conveniently close by.
12:37:33 <dolio> :)
12:37:36 <edwardk> heh
12:37:39 <b_jonas> it returns a bottom
12:37:41 <tibbe> dons: why does uvector use a U suffix for function names rather than qualified namespaces like bytestring?
12:37:48 <b_jonas> error gives a bottom
12:37:50 <roconnor> both branches will appear in GHC core
12:37:57 <dolio> True, true.
12:37:58 <roconnor> and that's where the optimizer works
12:38:18 <roconnor> that is the case statement I'm talking about.
12:38:19 <b_jonas> roconnor: what about
12:38:21 <Cale> Also, isn't the case that roconnor is talking about really the one where the patterns are exhaustive anyway?
12:38:28 <roconnor> although GHC core's case is slightly different from Haskell's case
12:38:36 <edwardk> bos: well, he's in slovenia at the moment, so not exactly close by but AIM and a phone works wonders ;)
12:38:38 <Cale> The real problem is that the scrutinee of the case might be bottom.
12:38:44 <cnwdup> !hoogle block
12:38:58 <b_jonas> case (if password == correctPass then () else error "no good") of { () -> pay amount }
12:39:06 <b_jonas> there the case only has one branch
12:39:18 <b_jonas> and it's exhaustive
12:39:27 <roconnor> b_jonas: yes, that code would get optimized away
12:39:28 <dolio> Heh.
12:39:44 <Cale> But that can be avoided simply by forcing the evaluation of the scrutinee to WHNF.
12:39:46 <dolio> If you write code specifically designed to defeat his optimization, it causes problems. :)
12:39:47 <b_jonas> and even if it couldn't be bottom, you have the realtime performance problem
12:40:10 <Cale> Eh?
12:40:16 <b_jonas> dolio: but how do you know it couldn't come up in more complicated code after transformations?
12:40:23 <roconnor> performance problem?
12:40:28 <b_jonas> I don't want an optimization that usually works but you can't know it's correct
12:40:45 <b_jonas> roconnor: what I said above with the mice and the answer
12:41:06 <b_jonas> if you have to evaluate the scrutinee later
12:41:17 <roconnor> b_jonas: it is correct, depending on your definition of correct
12:41:30 <dolio> I don't. But using 'error' to avoid performing terrible side effects seems like a bad policy.
12:41:34 <b_jonas> well I don't want an interpreter work like that
12:41:45 <Cale> b_jonas: If you care about the timing there, you'd probably use evaluate to enforce the sequencing of the evaluation with IO.
12:42:05 <b_jonas> what's evaluate?
12:42:11 <roconnor> @hoogle evaluate
12:42:11 <lambdabot> Control.Exception.evaluate :: a -> IO a
12:42:20 <b_jonas> @src evaluate
12:42:20 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
12:42:28 <roconnor> ah
12:42:29 <b_jonas> do? doesn't that come out to the same thing?
12:42:36 <Cale> hm?
12:42:36 <roconnor> that'll need a pragma
12:42:51 <Cale> It's not equivalent to something which can be written in Haskell 98.
12:43:23 <roconnor> we assume that evaluate will be rewritten in some suitable way.
12:43:24 <b_jonas> Cale: really?
12:43:34 <roconnor> @src seq
12:43:34 <lambdabot> Source not found. You untyped fool!
12:44:06 <roconnor> b_jonas: the IO consturctor isn't Haskell 98
12:44:07 <Cale> evaluate x `seq` y ==> y
12:44:30 <Cale> evaluate x `catch` f ==> (return $! x) `catch` f
12:44:40 <Cale> evaluate x >>= f ==> (return $! x) >>= f
12:45:04 <Cale> The first rule there is what prevents it from being written in H98.
12:45:14 <b_jonas> Cale: hmm
12:45:21 <b_jonas> funny
12:45:37 <Cale> (It's not the same as (return $! x), though the two other rules show that it's related)
12:45:41 <b_jonas> still,
12:46:00 <Cale> Er, actually, hmm
12:46:04 <olsner> @ty (.:)
12:46:07 <lambdabot> Not in scope: `.:'
12:46:10 <b_jonas> I don't see how it would surely stop the compiler from optimizing the program with evaluate the wrong way if it worked how rocconor says
12:46:11 <Cale> No, I'm wrong, it can be written...
12:46:19 <Cale> evaluate x = (return $! x) >>= return
12:46:36 <b_jonas> Cale: hmm
12:46:36 <b_jonas> nice
12:46:51 <dolio> Not according to the specification.
12:46:55 <opqdonut> Cale: how does the first rule prevent it being written in H98
12:47:05 <b_jonas> Cale: would that work?
12:47:07 <opqdonut> `seq` isn't H98?
12:47:14 <b_jonas> Cale: can't IO be lazy in that way in H98?
12:47:17 <Cale> opqdonut: It doesn't. However it does make it different from  evaluate x = return $! x
12:47:23 <b_jonas> that is, can't it contain the return value only lazily?
12:47:49 <Cale> b_jonas: Normally, return is lazy.
12:47:56 <PeakerWork> Does anyone else find Haskell records very annoying?  A) Why does it need the fully-qualified names of the record fields when initializing a record?  B) The record name is not part of the field names so you need ugly prefixing to separate their namespace
12:48:17 <opqdonut> yeah they're a bit clumsy
12:48:33 <b_jonas> Cale: hmm
12:48:35 <Baughn> I'd say /everyone/ does, but we're waiting for a perfect solution
12:48:44 <roconnor> PeakerWork: haskell doesn't really have records.  Just sugar for making projection functions from new tuple types.
12:48:52 <b_jonas> maybe yours guarantee that it finds even the head (return) only after it evaluates
12:48:55 <b_jonas> x
12:48:55 <Cale> I agree with roconnor.
12:48:58 <b_jonas> I'm not sure how IO actually works
12:49:01 <dolio> > ((return $! undefined) >>= return :: IO a) `seq` ()
12:49:02 <lambdabot>  ()
12:49:15 <PeakerWork> Baughn, I think resolving A and B will be a big help?
12:49:15 <Heffalump> it's not just sugar for projection functions, it's sugar for update operations too
12:49:17 <ziman> data Rec = { a :: Int, b :: Int } -- (Rec 1 2) is a valid record initialization, afaik
12:49:24 <Cale> So evaluate should have a more general type, I suppose :)
12:49:27 <Heffalump> which is quite important as far as refactoring goes
12:49:31 <Baughn> PeakerWork: Sure. But as I said, we're waiting for something perfect. ;)
12:49:39 <Cale> Though it's not so useful outside the IO monad.
12:49:40 <Baughn> PeakerWork: Still, GHC has a lot of record extensions. Tka e alook
12:49:46 <smg> hello.
12:50:10 <smg> is there a bad ass solution to make out of [1,2,3,4,5,6,7,8] [3,2,1,6,5,4,8,7] ?
12:50:14 <Cale> PeakerWork: What we really want is a proper row-polymorphic system for extensible records.
12:50:18 <PeakerWork> oh yeah, updating functions should be first-class functions.. maybe the fully qualified name of "x" inside a record should be ModuleName.RecordName.x, and there should be a ....x.get/x.set or so?
12:50:30 <Cale> smg: I totally don't understand your question...
12:50:31 <b_jonas> smg: what's the rule?
12:50:36 <PeakerWork> Cale, any example of what that means?
12:50:38 <Vq^> smg: what what?
12:51:02 <Cale> PeakerWork: http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
12:51:04 <lambdabot> http://tinyurl.com/392r4k
12:51:10 <b_jonas> > const [3,2,1,6,5,4,8,7] [1,2,3,4,5,6,7,8]
12:51:11 <lambdabot>  [3,2,1,6,5,4,8,7]
12:51:19 <b_jonas> dunno
12:51:23 <Vq^> b_jonas: damn, you beat me to it :)
12:51:34 <Cale> PeakerWork: The syntax in that paper sucks, but it gives a good idea of the operations you'd want.
12:51:45 <PeakerWork> Cale, k thanks I'll check it out
12:52:02 <smg> reverse every 3 elements
12:52:21 <smg> so 1,2,3,4 become 3,2,1,4 and 1,2,3,4,5 becomes 3,2,1,5,4
12:52:27 <Cale> PeakerWork: Basically, a kind of type where you can say "this function will accept any record that has an x field and a y field with such and such types".
12:52:33 <b_jonas> smg: oh
12:52:37 <b_jonas> smg: why not?
12:52:44 <Vq^> smg: you can patternmatch on the 3 first element in a list
12:52:48 <Cale> PeakerWork: and operations for generically operating on values like that
12:52:57 <PeakerWork> Cale, so you derive class definitions from the records and auto-instantiate various records based on that?
12:53:06 <Cale> PeakerWork: Like, deleting fields, or replacing them, and so on.
12:53:21 <Vq^> smg: and then use recursion to make it work on the whole list
12:53:21 <smg> Vq^: yeah but that is not a "cool" solution :)
12:53:22 <b_jonas> > let f a:b:c:r = c:b:a:f r; f [a,b] = [b,a]; f [a] = [a]; f [] = []; in f [1,2,3,4,5,6,7,8]
12:53:22 <lambdabot>  Parse error in pattern at ";" (column 26)
12:53:25 <Cale> I'm not entirely certain how it would interact with typeclasses.
12:53:29 <Vq^> smg: i see :)
12:53:32 <PeakerWork> Cale, automatically derive: class recordWithXField where getX :: ..  ; updateX :: ...;
12:53:33 <smg> hehe
12:53:40 <b_jonas> > let { f (a:b:c:r) = c:b:a:f r; f [a,b] = [b,a]; f [a] = [a]; f [] = []; } in f [1,2,3,4,5,6,7,8]
12:53:41 <lambdabot>  [3,2,1,6,5,4,8,7]
12:53:46 <Cale> PeakerWork: Oh, there'd be no need for such classes.
12:53:46 <b_jonas> there
12:53:50 <smg> hehe
12:54:01 <b_jonas> well,
12:54:14 <PeakerWork> Cale, but you wouldn't want 2 records that have the same name by accident to be accessible with the same reader/accessor
12:54:16 <dolio> concat . map reverse . chunks 3
12:54:17 <vixey> I added booleans if/then/else and comparison now :)
12:54:26 <Cale> PeakerWork: Newtyping would solve that problem.
12:54:31 <vixey> I have no idea how to do loops yet
12:54:43 <Vq^> @hoogle chunks
12:54:44 <lambdabot> Data.ByteString.Lazy.fromChunks :: [ByteString] -> ByteString
12:54:44 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
12:54:44 <lambdabot> Data.ByteString.Lazy.Internal.foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
12:54:50 <vixey> there will probably be Monads involved
12:55:00 <dolio> Yeah, there's no chunks in the libraries.
12:55:07 <PeakerWork> Cale, why would you want to delete fields, btw? Wouldn't you want the record to be static?  I see records merely as more descriptive tuples
12:55:12 <dolio> People were talking about it a week or two ago, though.
12:55:14 <vixey> the quest for chunks continues!
12:55:18 <Vq^> i usually end up doing some weird unfoldr span/break thingie
12:55:28 <PeakerWork> Cale, (static as in their type/field list)
12:55:29 <dolio> Here, that is. Not on the libraries list where it'd actually get in. :)
12:55:30 <augustss> vixey: added if/then/else to what?
12:55:31 <Cale> PeakerWork: I mean in the sense of producing a new record that has all the fields of the original, without one in particular.
12:55:32 <Vq^> but there should be something like chunk
12:55:43 <PeakerWork> Cale, oh, at compile-time
12:55:47 <vixey> augustss: my arithmetic -> stack language
12:55:54 <augustss> ah
12:56:00 <Cale> PeakerWork: Well, both at compile and runtime...
12:56:12 <b_jonas> PeakerWork: isn't that what SML does?
12:56:16 <b_jonas> with records
12:56:18 <PeakerWork> b_jonas, what's that?
12:56:36 <Vq^> s/span\/break/splitAt/
12:56:42 <PeakerWork> Cale, I guess I'll read the paper and then understand things better...
12:56:52 <Cale> Just for the record, I would choose a rather different syntax from Daan's paper.
12:57:11 <Cale> I really hate the idea of overloading . further.
12:57:27 <PeakerWork> in a macro-less language, syntax is not that important.. you can write bidirectional syntax-convertors :)
12:57:27 <b_jonas> PeakerWork: it has types representing records containing certain named fields and maybe others, and the accessor functions work on those
12:57:55 <Cale> Someone had the lovely idea of using names which start with ' for record field names (obviously, minus those which consist of a single character followed by another ')
12:57:59 <vixey> I think there was the
12:58:02 <b_jonas> vixey: what is it that you're doing?
12:58:10 <b_jonas> am I the only one not getting the context?
12:58:13 <b_jonas> oh, augustss too
12:58:15 <b_jonas> good
12:58:18 <augustss> . should not be overloaded.  It should only be record selection :)
12:58:24 <smg> <interactive>:1:12: Not in scope: `<<='
12:58:27 <smg> wtf is that?
12:58:33 <Cale> augustss: It should only be composition, in my opinion :)
12:58:43 <smg> why don't i have <<= ?
12:58:48 <Cale> =<< ?
12:58:49 <opqdonut> not 6.8?
12:58:51 <augustss> Cale: composition is a little ring
12:58:55 <smg> no not 6.8
12:58:59 <opqdonut> <<= is a comonad thing iirc
12:59:06 <Cale> augustss: sure, but I don't have such a key on my keyboard
12:59:07 <vixey> I think that writing interpreters is easy and writing compilers is hard
12:59:12 <b_jonas> @type <<=
12:59:14 <lambdabot> parse error on input `<<='
12:59:21 <RayNbow> :t (<<=)
12:59:22 <opqdonut> vixey: well writing good compilers/interpreters is hard
12:59:26 <lambdabot> Not in scope: `<<='
12:59:26 <vixey> has anyone else found this to be true or false?
12:59:28 <opqdonut> writing basic ones is easy
12:59:30 <Cale> augustss: and composition is *so important* that it deserves a lightweight and easy to type symbol
12:59:35 <augustss> Cale: nor does your keyboard have small letters, but you eem to be able to type them anyway
12:59:37 <b_jonas> vixey: sure
12:59:43 <b_jonas> at least
12:59:46 <opqdonut> vixey: but true, interpreters are a bit easier
12:59:47 <b_jonas> writing interpreters is easier
12:59:50 <Cale> augustss: sure it does :)
12:59:50 <b_jonas> it's still not easy
12:59:59 <b_jonas> I've written some interpreters and enjoyed it
13:00:03 <b_jonas> but none of them are really complete
13:00:08 <vixey> I wrote loaaads of interpreters :)
13:00:10 <ziman> > let chunkBy n = takeWhile (not.null) . map (take n) . iterate (drop n) in concatMap reverse . chunkBy 3 $ [1..10]
13:00:13 <lambdabot>  [3,2,1,6,5,4,9,8,7,10]
13:00:17 <augustss> Cale: then your keyboard doesn't have capitals :)
13:00:20 <b_jonas> in particular, I haven't yet written an interpreter that can do lambdas
13:00:27 <b_jonas> and I want to write one at some point
13:00:29 <Cale> Actually, my keyboard does happen to have ∘, but it's much harder to type than .
13:00:34 <PeakerWork> Cale, I think its ok to overload . for record names here, because it is the same overload as the module one, in a sense (upper case followed by dot)
13:00:36 <edwardk> opqdonut: i've yet to find the use of =>> as a comonadic >>=  compelling because >> doesn't offer a symmetric option =)
13:00:55 <augustss> Cale: I do record selection much more than composition
13:00:57 <smg> let replicateN = ((=<<) . replicate)
13:01:04 <Cale> Most of the code that I write has lots and lots of composition chains in it.
13:01:18 <b_jonas> I have   …–“„”»«‘’ and similar stuff added to my keyboard
13:01:24 <Cale> and I'm already annoyed enough that module qualification uses .
13:01:25 <b_jonas> prolly that's all
13:01:30 <smg> hello Cale :)
13:01:36 <vixey> b_jonas: did you see my paste http://hpaste.org/7806
13:01:44 <Cale> I would have chosen | as the module path separator
13:01:48 <b_jonas> vixey: not yet
13:01:52 <b_jonas> I'll check it out
13:01:53 <vixey> It's really bad code I think
13:01:54 <b_jonas> I like interpreters
13:01:56 <vixey> but It works
13:02:19 <b_jonas> don't worry
13:02:25 <b_jonas> I bet I've written worse code for an interpreter
13:02:27 <vixey> (I just wrote it for my own understanding)
13:02:47 <augustss> Cale: if your programming is impeeded by using a ring for composition then you must be typing about 30 compositions per minute :)
13:02:53 <Cale> anyway, I prefer a functional notation for record projection
13:02:57 <PeakerWork> Cale, why not use a haskell syntax conversion script, you can even have your favorite editor run that script on load/save so you always see it with your preferred syntax
13:03:23 <mmorrow> i think the module path sep (not in particular '.' i don't believe) is also the case of a (the only) reduce/reduce ambiguity in ghc's parser
13:03:24 <olsner> ooh, a lens
13:03:31 <vixey> lenses ?!
13:03:34 <Cale> maybe lenses...
13:03:36 <vixey> boomerangs
13:03:53 <vixey> I'm wondering if anyone has looked at it in more detail than me
13:04:24 <Cale> get 'fieldName myRecord looks nicer to me than  myRecord.fieldName, if only that the extraction function is actually a function
13:04:34 <shapr> roconnor: You called?
13:04:37 <Cale> So you'd be able to write  map (get 'fieldName)
13:04:42 <shapr> I was at the doctor.
13:05:03 <Cale> Or if we're not using lenses, then  map 'fieldName
13:05:51 <Cale> But lenses give a rather nice field setting and deleting syntax as well.
13:06:20 <PeakerWork> 'fieldName of myRecord, for COBOL lovers
13:06:27 <vixey> is 'feildName a lens?
13:06:36 <olsner> heh, I was referring to the editing-with-local-syntax part when I mentioned lenses
13:06:38 <Cale> vixey: Potentially.
13:06:46 <vixey> is this anything like that new boomerang thing pierce came out with?
13:06:48 <mmorrow> nevermind, i think i'm confused (i'm confused about being confused)
13:06:58 <Cale> vixey: I haven't read about that.
13:07:00 <olsner> not even aware that you were talking about field access :P
13:07:13 <Cale> olsner: heh
13:07:30 <PeakerWork> that's a huge advantage of macro-free languages that's not being taken advantage of
13:07:46 <olsner> vixey: boomerang is apparently a language that has good support for lenses
13:07:54 <Cale> extend 'fieldName value myRecord
13:07:54 <olsner> or built for lenses, or something like that
13:07:56 <vixey> and what are lenses?
13:08:10 <vixey> I think they are nothing to do with views
13:08:49 <Cale> In the context of records, lenses are basically just collections of functions for performing operations on a record.
13:09:09 <Cale> Let me see if I can dig up an appropriate article...
13:09:18 <Cale> iirc, there was a nice note on twanvl's blog
13:09:27 <edwardk> twan called them functional references iirc
13:09:28 <b_jonas> I have written an interpreter that uses yacc to evaluate expressions strictly directly to the result (that is, not to a parse tree or somesuch), yet supports loops
13:09:33 <olsner> lenses is something like a type-class for updatable views (get :: a -> a'; putback :: a -> a' -> a), where putback takes a modified selection a' and incorporates it into a new a
13:10:08 <PeakerWork> so a lens is itself a record, with   get :: record->a, set :: record->a->a, del :: record->record_without_field ?
13:10:24 <Cale> yeah
13:10:41 <mmorrow> b_jonas: have you ever used happy? (you can return functions!)
13:10:42 <Cale> Or whatever set of operations you want to support.
13:10:56 <b_jonas> mmorrow: no
13:11:23 <b_jonas> what's happy? is it one of the forth-like languages?
13:11:27 <Cale> You'd then simply ensure that the field names refer to appropriate lenses, and define functions that extract the fields from the lenses.
13:11:38 <Cale> (as primitive)
13:11:43 <PeakerWork> that sounds great, when will -fglasgow-exts have it? :-)
13:12:27 <thoughtpolice> b_jonas: it allows you to generate x86 asm at runtime
13:12:29 <mmorrow> b_jonas: omg, do. it's well worth it (it's fast). once you use it once, you'll use it all the time.
13:12:40 <mmorrow> b_jonas: and alex too
13:12:43 <thoughtpolice> b_jonas: whoops, misread that. happy is here: http://haskell.org/happy
13:12:43 <lambdabot> Title: Happy: The Parser Generator for Haskell
13:12:45 <thoughtpolice> it's a parser generator :)
13:12:56 <thoughtpolice> i thought I saw 'harpy'
13:13:04 <mmorrow> heh
13:13:04 <vixey> data Progress a = Value a | Step (() -> Progress a)
13:13:09 <vixey> I think there was something like this
13:13:13 <Cale> Personally, I prefer parser combinators.
13:13:14 <vixey> and a Monad too
13:13:17 <Cale> At least usually.
13:13:46 <mmorrow> if you have to parse more than a trivial amount of stuff and you care about performance, it's happy or...?
13:14:15 <Baughn> mmorrow: Depends on how much you care. Parsec can be fast
13:14:18 <olsner> harpy for the really picky :D
13:14:18 <vixey> return x = Value x, Value x >>= f = f x, Step q >>= f = Step \x -> f >>= (q x)
13:14:18 <vixey> does that ring any bells for anyone
13:14:51 <slavik> looks like a monad?
13:15:08 <b_jonas> mmorrow: rcan you give a link?
13:15:16 <vixey> normalize (Value x) = x
13:15:19 <mapreduce> I thought Haskell had a zipWithIndex.. I suppose it's redundant given:
13:15:23 <vixey> normalize (Step f) = normalize (f ())
13:15:37 <mapreduce> > zip [1..] [3, 5 ..]
13:15:39 <Cale> zip [0..]
13:15:40 <lambdabot>  [(1,3),(2,5),(3,7),(4,9),(5,11),(6,13),(7,15),(8,17),(9,19),(10,21),(11,23),...
13:15:48 <mmorrow> Baughn: I think it depends on size of input
13:15:49 <mapreduce> I meant 0..
13:16:03 <dolio> Looks like the partiality monad in a language with strict evaluation.
13:16:16 <vixey> cool
13:16:22 <Baughn> mmorrow: Obviously, but parsec doesn't get asymptotically slower with larger input
13:16:30 <Cale> > filter (even . fst) . zip [0..] $ "Hello, world!"
13:16:31 <lambdabot>  [(0,'H'),(2,'l'),(4,'o'),(6,' '),(8,'o'),(10,'l'),(12,'!')]
13:16:31 <sclv> general lenses are fancier though in that theoretically they can index into any data structure at all, and perform conversion along the way
13:16:37 <Cale> > map snd . filter (even . fst) . zip [0..] $ "Hello, world!"
13:16:37 <lambdabot>  "Hlo ol!"
13:16:40 <Baughn> mmorrow: It depends on the sort of grammar you want to parse, too. Parsec works for different ones than happy
13:16:52 <mmorrow> but in many cases it has to read the entire input before returning any results
13:16:54 <mmorrow> http://www.haskell.org/alex/
13:16:55 <lambdabot> Title: Alex
13:17:00 <mmorrow> http://www.haskell.org/happy/
13:17:00 <lambdabot> Title: Happy: The Parser Generator for Haskell
13:17:01 <vixey> Is there like some good reference for the partiality monad?
13:17:10 <mmorrow> b_jonas: ^
13:17:11 <Baughn> mmorrow: Then you've got a very badly designed data source
13:17:12 <Cale> > [x | (n,x) <- zip [0..] "Hello, world!", even n]
13:17:13 <lambdabot>  "Hlo ol!"
13:17:25 <Baughn> mmorrow: (And any other parser would also need to read the whole thing)
13:17:28 <b_jonas> mmorrow: ok, I'll look at it
13:17:28 <RayNbow> hmm, did Haskell drop in the shootout charts? http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
13:17:30 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
13:18:01 <vixey> oh!
13:18:01 <mmorrow> Baughn: I think it's more that the parsec parsers I've tried were not optimized (wrt the expected/known input datasource) as they could be
13:18:01 <vixey> data Delay a = Now a | Later (Delay a) -- coinductive
13:18:06 <dolio> Right.
13:18:33 <vixey> return = Now
13:18:39 <vixey> Now a >>= k = k a
13:18:40 <mmorrow> Baughn: Well, that depends on what your parsing
13:18:47 <vixey> Later d >>= k = Later (d >>= k)
13:19:05 <Baughn> mmorrow: Parsec does make it very /obvious/ what it will be reading. That can be an advantage
13:19:15 <vixey> what's the partiality Monad used for?
13:19:25 <vixey> I've got one example
13:19:28 <mmorrow> Baughn: But, we're getting off topic. I don't dispute that parsec can be/is fast. I'm sure it is. *But* happy will (most) always be faster by nature of it's implementation
13:19:31 <dolio> Modelling general recursion in a total language.
13:19:52 <dolio> Or, encapsulating it.
13:19:59 <mmorrow> Baughn: especially with the --ghc flag
13:20:10 <mapreduce> > zip (True :: repeat False) "hello" `map` (\pair -> (if (fst pair) then toUpper else const) (snd pair))
13:20:11 <lambdabot>   Not in scope: type constructor or class `False'
13:20:12 <mmorrow> (uses unsafeCoerce# and raw Addr#'s
13:20:16 <sclv> RayNBow: looks like they folded the extra-languages in the shooutout into the main ones.
13:20:28 <mapreduce> > zip (True :: (repeat False)) "hello" `map` (\pair -> (if (fst pair) then toUpper else const) (snd pair))
13:20:28 <lambdabot>   Not in scope: type constructor or class `False'
13:20:29 <mapreduce> > False
13:20:30 <lambdabot>  False
13:20:39 * mapreduce fails.
13:20:53 <vixey> this is cool http://www.informatik.uni-bonn.de/~ralf/WG2.8/22/slides/tarmo.pdf
13:20:57 <dolio> cons is : in Haskell.
13:20:59 <sclv> so GHC isn't lower than before, there are just more things (Lisaac, multiple C variants, Fortran) in front of it that weren't shown before.
13:21:09 <mapreduce> > zip (True : (repeat False)) "hello" `map` (\pair -> (if (fst pair) then toUpper else const) (snd pair))
13:21:10 <lambdabot>  Couldn't match expected type `a -> b'
13:21:25 <mapreduce> dolio: Thanks. (blames Scala instead of himself)
13:21:34 <vixey> "For any monad there is a monad supporting looping"
13:21:35 <b_jonas> vixey: I've written something that's sort of a compiler once
13:21:36 <mmorrow> Baughn: Otoh, happy is very nonlightweight. I would only use it for a parser for a language.
13:21:51 <b_jonas> it compiles to a high-level language, not to assembler
13:21:51 <mmorrow> Baughn: e.g. an SQL parser or similar
13:21:53 <vixey> b_jonas: to Prolog and SML?
13:21:58 <b_jonas> yes
13:22:03 <b_jonas> that's the one
13:22:10 <b_jonas> :-)
13:22:11 <vixey> b_jonas: I saw it, really mad :P
13:22:14 <vixey> b_jonas: It's cool
13:22:21 <b_jonas> thanks
13:22:47 <sclv> If anyone wants to take a crack at the shootout problems again, it looks like Eiffel is within reach...
13:22:48 <vixey> b_jonas: I think you can get a lot for free by compiling to a hll and not really miss out on anything
13:23:00 <vixey> b_jonas: since you get linking, symbol resolution etc..etc..
13:23:06 <sclv> (and maybe even fortran!)
13:24:32 <olsner> Prolog and SML as target languages? that sounds cool
13:24:57 <b_jonas> olsner: http://www.math.bme.hu/~ambrus/pu/olvashato/
13:24:58 <lambdabot> Title: Olvashato compiler
13:25:00 <dolio> vixey: See also, General Recursion via Coinductive Types...
13:25:08 <vixey> thanks dolio
13:25:29 <vixey> (tangent, but this is cool https://www.cs.tcd.ie/~devriese/talks/cattheory.pdf )
13:25:34 <dolio> That actually shows how you can define fixed points of functions with that monad.
13:25:46 <b_jonas> vixey: wow
13:25:55 <dolio> I think, at least. It's been a while since I looked at it.
13:25:58 <b_jonas> that one uses the same representation for data and code?
13:26:02 <b_jonas> that's wierd
13:26:20 <b_jonas> how can it even work?
13:26:27 <vixey> why would you differentiate between data and code? :p
13:26:36 <b_jonas> um
13:26:40 <b_jonas> this line especially
13:26:44 <dolio> Also: http://www.cs.swan.ac.uk/BCTCS2006/Slides/Altenkirch.pdf
13:26:45 <b_jonas> whnf env x@(Lambda _ _) = x
13:26:49 <hpaste>  morrow pasted "happy parser example (from happy docs somewhere)" at http://hpaste.org/8078
13:26:52 <b_jonas> how does it store closed values?
13:26:55 <mmorrow> b_jonas: ^
13:27:03 <b_jonas> doesn't it need to depend on env?
13:27:12 <mmorrow> oh crap, formatting...
13:27:15 <vixey> b_jonas: I just say that it's in WHNF, but not total normal form
13:27:42 <b_jonas> vixey: hmm
13:28:28 <hpaste>  morrow annotated "happy parser example (from happy docs somewhere)" with "ahh! sed -r 's/\r//g'" at http://hpaste.org/8078#a1
13:29:38 <mmorrow> wait, i'm an idiot. that's an alex lexer
13:29:58 <b_jonas> vixey: ah, so it has a rewrite
13:29:59 <b_jonas> to handle that
13:30:02 <mmorrow> (no wonder i couldn't find where i got it from in the happy docs)
13:30:06 <b_jonas> which is called from the :$: rule
13:30:10 <b_jonas> tricky
13:30:17 <b_jonas> so it's a lambda calculus evaluator
13:30:24 <b_jonas> but a lazy one
13:30:26 <vixey> yes
13:30:44 <vixey> there is one way I could get a big increase in efficiency but I didn't worry about that
13:31:10 <b_jonas> oh sure
13:31:22 <b_jonas> after "lower' = ['a'..'z']" I didn't expect efficency
13:32:23 <b_jonas> actually I was lying
13:32:31 <vixey> I'd add a typechecker too
13:32:34 <b_jonas> because I did write one interpreter that handles lambda expressions
13:32:35 <vixey> just need to find a good typesystem
13:32:47 <vixey> what else did it have?
13:33:06 <b_jonas> nothing much apart from it
13:33:07 <b_jonas> it's
13:33:13 <b_jonas> a moment I'll get the url
13:33:16 <vixey> lambda is all you need anyway :D
13:33:48 <b_jonas> yep
13:34:05 <b_jonas> it has numbers but no algebraic datatypes or lists
13:34:12 <b_jonas> so you'd have to emulate those with lambdas
13:34:20 <b_jonas> http://www.jsoftware.com/jwiki/Scripts/Scheme
13:34:22 <lambdabot> Title: Scripts/Scheme - J Wiki
13:34:26 <vixey> oh!
13:34:34 <vixey> I saw the before as well!
13:34:34 <BMeph> Eh?
13:34:35 <osfameron> oooo, attempting to implement monads in Perl OO is quite instructive.  The >> pipeline looks superficially like an OO chain, but really isn't (because that omits the progressive nested lexical scopes)
13:34:47 <b_jonas> yep, I paste urls of these everywhere on irc
13:34:52 <b_jonas> so it's no wonder
13:35:03 <vixey> I was learning J a while ago
13:35:09 <vixey> but this is far above my understanding
13:35:21 <hpaste>  morrow pasted "another try at alex/happy examples" at http://hpaste.org/8079
13:35:56 <hpaste>  morrow annotated "another try at alex/happy examples" with "HaddockLex.x" at http://hpaste.org/8079#a1
13:36:16 <hpaste>  morrow annotated "another try at alex/happy examples" with "HaddockParse.y" at http://hpaste.org/8079#a2
13:36:16 <b_jonas> well it's strange because it represents functions as J functions actually, but J doesn't have lambdas, so it just binds the environment to them
13:36:49 <mmorrow> the haddock {.x,.y} are good examples because they're small and real
13:37:49 <Apocalisp> > read "10"
13:37:50 <lambdabot>  Exception: Prelude.read: no parse
13:38:16 <Baughn> > read "10" :: Float
13:38:17 <lambdabot>  10.0
13:38:27 <Apocalisp> oh yea
13:38:54 <Cale> > read "()"
13:38:55 <lambdabot>  ()
13:39:15 <Baughn> > (read.read.read) "\"\\\"10\\\"\"" :: Int
13:39:17 <lambdabot>  10
13:39:37 <vixey> what
13:39:43 <b_jonas> hmm
13:39:45 <b_jonas> how can that work?
13:39:52 <b_jonas> doens't that have one set of quotes less?
13:39:53 <Baughn> Three reads. For when you're /serious/ about reading.
13:39:55 <vixey> :t read
13:39:58 <dolio> :t read . read . read
13:39:58 <lambdabot> forall a. (Read a) => String -> a
13:40:01 <vixey> String
13:40:01 <lambdabot> forall a. (Read a) => String -> a
13:40:07 <Baughn> b_jonas: It only parses it as a string twice, though
13:40:15 <b_jonas> ah yeah
13:42:33 <Baughn> > iterate show "10"
13:42:34 <lambdabot>  ["10","\"10\"","\"\\\"10\\\"\"","\"\\\"\\\\\\\"10\\\\\\\"\\\"\"","\"\\\"\\\\...
13:42:36 <mmorrow> > foldl (.) id (repeat read) $ (fix show)
13:42:39 <lambdabot>  "
13:42:53 <Baughn> ..what
13:42:55 <vixey> lol
13:43:06 <mmorrow> heh
13:43:06 <vixey> don't touch infinity
13:43:13 <dmwit> whoa
13:43:29 <Baughn> I have a feeling that's my fault. :?
13:43:33 <dmwit> That wasn't a Terminated?
13:43:50 <dmwit> :t foldl (.) id (repeat read)
13:43:52 <lambdabot> String -> String
13:43:54 <mmorrow> no, it times out, but only produces '"'
13:44:06 <b_jonas> > fix show
13:44:07 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:44:09 <mmorrow> > head $ foldl (.) id (repeat read) $ (fix show)
13:44:12 <dmwit> mmorrow: Oh, so since it produces *some* output, \bot reports it?
13:44:12 <lambdabot> Terminated
13:44:14 <Baughn> Yes, but it should then go on to print an exception.. hang on...
13:44:18 <b_jonas> > iterate read $ fix show
13:44:19 <lambdabot>  ["\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:44:34 <b_jonas> > map (take 20) . iterate read $ fix show
13:44:43 <Baughn> dmwit: That happens if something hits an infiinite loop /without allocation/. Leaves no room to catch the XCPU exception.
13:44:45 <lambdabot>  ["\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\","Exception: Time limit exceeded
13:44:52 <mmorrow> dmwit: hmm, i dunno. when i do it in ghci i have to ^c it
13:44:52 <vixey> > fix (read.show)
13:45:07 <lambdabot>  thread killed
13:45:47 <Baughn> > show (fix (1+))
13:45:47 <dmwit> hum
13:45:59 * dmwit is mildly confused by the conflicting evidences shown here
13:46:02 <lambdabot>  thread killed
13:46:13 <Baughn> dmwit: Listen to me. I wrote the darn thing. :P
13:46:32 <Baughn> Mind you, lb is also a bit unstable right now, which makes experiments hard
13:46:33 <dons> reddit broke. huh
13:46:51 <Baughn> > show [last [1..]]
13:46:55 <lambdabot>  "[
13:47:03 <Baughn> ...okay, something's broke
13:47:22 <mmorrow> then fix it!
13:47:25 <dmwit> Baughn: But why wouldn't foldl do allocation?  That part doesn't make sense to me.
13:47:29 <vixey> Baughn: What should it do?
13:47:35 <vixey> Baughn: if not print "[
13:47:44 <Baughn> dmwit: Well, I didn't actually analyze the code, just the output
13:47:45 <dmwit> Baughn: (Back in the original foldl (.) weird-thing.)
13:47:47 <mmorrow> (attempt at humor)
13:47:55 <Baughn> vixey: It's *supposed* to print "[Exception: Time limit exceeded
13:48:00 <vixey> oh right
13:48:13 <dmwit> > last [1..]
13:48:17 <lambdabot> Terminated
13:48:48 <Baughn> > last [1..]
13:48:51 <lambdabot> Terminated
13:48:56 <Cheiron>  Exception: Time limit exceeded
13:49:05 <vixey> I think the hard bit of the partiality monad is the quotient
13:49:07 * Baughn pokes Cale
13:49:14 <dmwit> Sounds like maybe some things have changed. =)
13:49:20 <Cale> Baughn: yeah?
13:49:33 <vixey> > fun "?vixey hmm"
13:49:33 <lambdabot>  Add a type signature
13:49:34 <Cheiron>  Add a type signature
13:49:37 <vixey> :(
13:49:38 <Baughn> Cale: Are you running something other than the newest haskell.org code?
13:49:43 <Cale> Baughn: no
13:49:52 <dmwit> vixey: expr $
13:49:58 <dmwit> > expr $ fun "?vixey hmm"
13:50:03 <Cale> Baughn: Well, there are a few changes to push, perhaps, but nothing related to that
13:50:03 <lambdabot>  ?vixey hmm
13:50:07 <vixey> oh yeah
13:50:17 <dmwit> > 3 -- expr $ fun "\nvixey hmm" might be dangerous
13:50:18 <Cale> Baughn: You're probably not using the same GHC
13:50:20 <lambdabot>  3
13:50:29 <Baughn> Cale: No, I'm using vanilla 6.8.2 now
13:50:37 <dmwit> > expr $ fun "\n?vixey hmm"
13:50:39 <lambdabot>  ?vixey hmm
13:50:48 <dmwit> Ooo, maybe that's fixed.
13:50:53 <dmwit> > expr $ fun "blargle\n?vixey hmm"
13:50:54 <lambdabot>  blargle
13:50:54 <lambdabot> ?vixey hmm
13:50:58 <vixey> what
13:50:59 <dmwit> Oh, nope.
13:51:11 <vixey> P a = D a/=
13:51:15 <vixey> P a = D a/==
13:51:29 <sclv> ?ty fun
13:51:30 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
13:51:43 <vixey> what's constructive doman theory about?
13:51:52 <Baughn> Cale: Not quite vanilla lb, though. I don't think that matters, but let's see..
13:54:03 <Baughn> > last [1..]
13:54:07 <lambdabot>  out of memory (requested 1048576 bytes)
13:54:09 <Cheiron>  Exception: Time limit exceeded
13:54:10 <b_jonas> vixey: have you seen David Madore's interpreter at http://www.madore.org/~david/programs/self-int.scm
13:54:13 <b_jonas> ?
13:54:19 <Baughn> > last [1..]
13:54:23 <lambdabot>  out of memory (requested 1048576 bytes)
13:54:25 <Cheiron>  Exception: Time limit exceeded
13:55:05 <Baughn> Cale: That's not what happened earlier, obviously.. and it's either that code you haven't pushed, or something environmental. I'm leaning towards the latter.
13:55:36 <mmorrow> > head . show $ foldl (.) id (repeat read) $ (fix show)
13:55:38 <lambdabot>  '"'
13:55:53 <vixey> b_jonas: that is beautiful
13:56:09 <vixey> what a brilliant idea
13:57:27 <mmorrow> oh, that's just the same as head . show $ any string
13:57:29 <vixey> no I hadn't seen it before
13:57:46 <Baughn> s/any string/anything/
13:58:04 <mmorrow> yeah
13:58:29 <Baughn> And yes, mine manages that. Given that LB is supposedly running the same code, I suspect shenanigans. ;)
13:58:30 <mmorrow> well, i guess (Show a) => a
13:59:02 <mmorrow> shenanigans!
13:59:09 <mmorrow> great word
13:59:59 <b_jonas> vixey: yeah. perhaps read http://www.madore.org/~david/computers/quine.html too because that source code doesn't link back to it
14:00:00 <lambdabot> Title: Quines (self-replicating programs)
14:00:48 <Baughn> Hm. Actually..
14:01:05 <Baughn> > show $ last [1..] -- Why /out of memory/? This should be constant space
14:01:08 <lambdabot>  "
14:01:21 <dmwit> ?src last
14:01:21 <lambdabot> last [x]    = x
14:01:21 <lambdabot> last (_:xs) = last xs
14:01:21 <lambdabot> last []     = undefined
14:01:23 <Baughn> > last [1..] -- OKay, this.
14:01:25 <lambdabot> Terminated
14:01:34 <Baughn> > last [1..] -- Can't you be a bit consistent?
14:01:36 <lambdabot> Terminated
14:02:08 <dmwit> Very consistent!
14:02:19 <Baughn> Yes. It consistently does something I don't want.
14:02:20 <dmwit> As long as nobody joins or parts, it reports exactly the same answer. ;-)
14:02:38 <Baughn> > last [1..] -- Surely this is silly of me
14:02:41 <lambdabot>  out of memory (requested 1048576 bytes)
14:02:45 <Cheiron>  Exception: Time limit exceeded
14:02:46 <Baughn> ...!
14:02:55 <dmwit> wowm
14:03:10 <Baughn> > last [1..] -- Must have been random chance.
14:03:12 <lambdabot> Terminated
14:03:18 <Cheiron>  Exception: Time limit exceeded
14:03:20 <vixey> > var (cycle "?vixey :)\n")
14:03:20 <lambdabot>  ?vixey :)
14:03:20 <Cheiron>  ?vixey :)
14:03:24 <Cheiron> ?vixey :)
14:03:24 <Cheiron> ?vixey :)
14:03:24 <Cheiron> ?vixey :)
14:03:24 <Cheiron> ?vixey :)
14:03:24 <lambdabot> ?vixey :)
14:03:24 <Cheiron> [3 @more lines]
14:03:24 <lambdabot> :)
14:03:25 <Cheiron> <undefined>
14:03:25 <lambdabot> ?vixey :)
14:03:26 <Vq^> should we start taking bets?
14:03:26 <vixey> eex
14:03:28 <Cheiron> <undefined>
14:03:28 <lambdabot> eh?
14:03:28 <Baughn> @leave #haskell
14:03:29 <lambdabot> ?vixey :)
14:03:31 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
14:03:33 <lambdabot> ?vixey :)
14:03:35 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
14:03:37 <lambdabot> Not enough privileges
14:03:38 <trez> ! :)
14:03:55 <vixey> ok I should not have done that ...
14:04:02 <Baughn> ..that's it.
14:04:09 <Baughn> I'm going to push a patch to make it use NOTICE.
14:04:24 <vixey> why not fix var/Expr instead?
14:04:37 -lxuser(i=lxuser@gateway/tor/x-cfb92ba2c3322c01)- > var (cycle "?vixey :=\n")
14:04:38 <Baughn> I'd rather fix the fundamental problem
14:05:24 <Cale> Baughn: the trouble is that then all the people with broken IRC clients complain.
14:05:42 <Baughn> Cale: #haskell is supposed to have a higher grade of user
14:05:51 <Cale> Some IRC clients render NOTICEs by popping up a dialog box.
14:05:57 <MyCatVerbs> lambdabot: Italy! For part of it.
14:05:59 <dmwit> ouch
14:06:29 <Cale> Of course, that's a completely stupid behaviour caused by not reading the IRC protocol spec, but people still complain.
14:06:32 <b_jonas> I've made my irc bots prefix every reply on channels with your nick
14:06:36 <MyCatVerbs> Hrmmmmm. Does mIRC?
14:06:39 -Baughn(n=svein@084202038064.customer.alfanett.no)- cale: I'm /fine/ with making people complain, in fact
14:06:48 <dmwit> b_jonas: That might not help.
14:06:49 <b_jonas> but even that doesn't stop all loops
14:06:53 <dmwit> lambdabot: ?list
14:06:53 <b_jonas> yep
14:06:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:07:00 <Baughn> b_jonas: How so?
14:07:04 <dmwit> b_jonas: In particular, that would not help with \bot. =P
14:07:05 <b_jonas> the real solution would be replying with a notice
14:07:10 <MyCatVerbs> If mIRC is fine and irssi is fine, then, well, nobody really has much excuse to whine because there's no reason whatsoever to ever use a worse IRC client than one of those two.
14:07:17 <Baughn> b_jonas: Yes, that's what I was suggesting
14:07:21 <b_jonas> but people don't seem to like that
14:07:27 <b_jonas> I did try changing to a notice
14:07:32 <b_jonas> but indeed people didn't like that
14:07:34 <b_jonas> pity
14:07:36 <b_jonas> they should
14:07:45 <Cale> One thing that can be done is to ensure that all lines output are prefixed with a space, and that commands don't allow extraneous whitespace before them.
14:07:45 <b_jonas> I agree that it's an irc client problem
14:07:54 <Cale> But yeah, it should use notices.
14:08:02 <dmwit> Cale: You can get more general than that.
14:08:03 <MyCatVerbs> Could just have the bot ignore any line that starts with a #, then prefix all answers with the sequence "# "
14:08:09 <dmwit> I was talking about a scheme the other day on -blah.
14:08:18 <MyCatVerbs> Or some such chicanery along those lines.
14:08:18 <Baughn> MyCatVerbs: And that works so long as we're only talking lambdabots
14:08:40 <MyCatVerbs> Who on Earth causes bots to message other bots, though?
14:08:55 * Baughn points at vixey 
14:09:03 * vixey cries
14:09:08 <dmwit> If you make a graph of the modules, where an edge signifies that the output of the head can be used as the input for the tail, then it just reduces to a cycle check.
14:09:12 <MyCatVerbs> I mean, anyone dumb enough to trip that deserves to be beaten with a bar of soap in a so-oh hi there, vixey. ;)
14:09:16 <lxuser> MyCatVerbs, bots are supposed to reply with  NOTICE and ignore NOTICEs in input for this very reason.
14:09:40 <MyCatVerbs> lxuser: so just do that and tell anyone who complains to get a better IRC client. Job done, no?
14:09:49 <dmwit> No!
14:09:56 <vixey> hi Verbs ...
14:09:59 <dmwit> Inconveniencing the user is almost never a good idea!
14:10:23 <Baughn> Well, there is a simpler solution
14:10:27 <Baughn> We could have it ignore vixey
14:10:37 <MyCatVerbs> vixey: what did you do?
14:10:49 <orly> Baughn: You really think that will help?
14:10:52 <MyCatVerbs> orly: bugger the user!
14:10:57 -Cale(n=Cale@CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com)- If this is annoying, get a better IRC client.
14:10:58 <Baughn> orly: Not really, but it seemed the thing to say
14:11:05 * Baughn ruffles vixey's hair. There, there.
14:11:21 <vixey> :p
14:11:40 <dibblego> #haskell-blah?
14:11:44 <MyCatVerbs> Ohhhh. Heheheh.
14:11:54 * chessguy finally gets the right answer on the correct number of legal moves from initial startup
14:11:56 <quicksilver> Cale: :P
14:11:58 <MyCatVerbs> vixey: TBH, I think you deserve a cookie for breaking it in such an interesting way.
14:12:13 <vixey> well I'm going to make a cup of tea..
14:12:25 <Philippa_> mirc doesn't bring up a dialog, but it does make noise
14:12:28 <hpaste>  oddron pasted "Demonstration of Real Time Queue" at http://hpaste.org/8080
14:12:36 <quicksilver> Cale: well the point is that whatever notices used to mean, they are mostly now used for important messages.
14:12:42 <MyCatVerbs> Philippa_: even better! Soundcard stress-test! :D
14:12:42 <quicksilver> Cale: so it's convenient to highlight them
14:12:56 <Philippa_> right. The RFC doesn't reflect common practice
14:12:58 <quicksilver> (normally notices are from network services of one kind or another)
14:13:02 <Cale> quicksilver: They're intended to be rendered in the same way as PRIVMSGs.
14:13:08 <quicksilver> I know.
14:13:13 <quicksilver> I know what the spec says.
14:13:15 <dibblego> chessguy, 20?
14:13:22 <quicksilver> I have specifically instructed irssi to highlight them.
14:13:30 <b_jonas> Cale: not to me
14:13:33 <quicksilver> because in practice they are primarily used by network services
14:13:39 <b_jonas> that is, they don't annoy me
14:13:48 <quicksilver> and it's convenient to highlight messages from ChanServ, NickServ and similar things on other networks I am on.
14:14:00 <Philippa_> highlighting isn't really an issue
14:14:01 <Cale> b_jonas: Then you likely have a reasonable IRC client. :)
14:14:05 <Philippa_> it's other behaviour that's a problem
14:14:07 <b_jonas> the problem with just prefixing whitespace is that it doesn't allow to work with other bots because it's not standard
14:14:08 <chessguy> dibblego:  gold star for you!
14:14:17 <b_jonas> many bots (not mine) allow leading ws
14:14:31 <Philippa_> many bots just use privmsg anyway
14:14:33 <b_jonas> MyCatVerbs: me
14:14:38 <b_jonas> I made loops with other people's bots
14:14:41 <Philippa_> for absolutely everything
14:14:42 <quicksilver> if a patch goes into LB to make it use notice then I will either (a) no longer pay attention when people use my name in #haskell or (b) learn how to reconfigure irssi to ignore notices in #haskell.
14:14:47 <dibblego> chessguy, strange, I'd never thought about that
14:14:48 * quicksilver shrugs
14:14:50 <MyCatVerbs> b_jonas: win.
14:14:52 <b_jonas> (not with my bots, that would be too easy as I can make my bot do anything)
14:15:05 <vixey> > var "why not\njust fix this?"
14:15:07 <lambdabot>  why not
14:15:07 <lambdabot> just fix this?
14:15:22 <vixey> afaict this this the only way to make bots talk to each other
14:15:28 <EvilTerran> well, \bots
14:15:34 <b_jonas> quicksilver: no, it's global notices that do that
14:15:35 <dmwit> ?fact fact
14:15:36 <lambdabot> fact: A fact is a fact is a fact is a fact. Or not.
14:15:40 <chessguy> dibblego:  thought about what?
14:15:41 <dmwit> vixey: There's another way.
14:15:41 <vixey> ?where ?where ok yeat
14:15:41 <b_jonas> which are send by irc operators
14:15:43 <lambdabot> ?where ?where
14:15:48 <b_jonas> normal notices aren't used for important things
14:15:49 <dibblego> chessguy, the number of possible first moves
14:16:04 <Baughn> @fact-set @fact @fact @fact
14:16:04 <lambdabot> Fact recorded.
14:16:07 <b_jonas> do you actually think the notices nickserv sends you that instruct you to please identify are important?
14:16:15 <mrd> @fact @fact
14:16:15 <lambdabot>  @fact: @fact @fact
14:16:31 <EvilTerran> ?help fact
14:16:32 <lambdabot> fact <fact>, Retrieve a fact from the database
14:16:48 <b_jonas> mrd: the irc server doesn't usually send your lines back to you so you usually can't usually loop one bot
14:16:59 <b_jonas> unless you can make it send a private message to itself or something
14:17:07 <ketil> @seen bos
14:17:08 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1h 39m 36s ago.
14:17:10 <b_jonas> otoh, I have to parse memoserv's notices with my bots
14:17:12 <quicksilver> b_jonas: yes, I think the notices from nickserv and chanserv are important.
14:17:19 <MyCatVerbs> b_jonas: was gonna say, there are a few bots that can be made to do that...
14:17:21 <dmwit> ?fact-set ?fact ?fact ?fact
14:17:21 <lambdabot> Fact already exists, not updating
14:17:24 <b_jonas> even though bots should ignore notices
14:17:26 <dmwit> ?fact ?fact
14:17:26 <lambdabot> ?fact: ?fact
14:17:30 <dmwit> ?fact: ?fact
14:17:30 <lambdabot> ?fact: ?fact
14:17:31 <jsnx> @fact @fact
14:17:32 <lambdabot>  @fact: @fact @fact
14:17:41 <cjay> quicksilver: why don't you hilight on notices form *serv only instead?
14:17:43 <dmwit> Baughn: ^^
14:17:45 <jsnx> @fact-set even 2
14:17:45 <lambdabot> Fact recorded.
14:17:47 <vixey> cool dmwit
14:17:49 <jsnx> @fact-set even 4
14:17:49 <lambdabot> Fact already exists, not updating
14:17:56 <dmwit> ?fact-append even 4
14:17:57 <lambdabot> Unknown command, try @list
14:17:59 <quicksilver> b_jonas: I also think notices that a channel is logged, or that a certain policy shuold be respected in a certain channel are important.
14:18:00 <jsnx> @fact-set binary 2
14:18:00 <lambdabot> Fact recorded.
14:18:04 <vixey> @factorial 5
14:18:04 <quicksilver> cjay: I could. Maybe I will.
14:18:05 <lambdabot> Unknown command, try @list
14:18:07 <jsnx> @fact binary
14:18:07 <lambdabot> binary: 2
14:18:13 <dmwit> ?fact-add even 4
14:18:14 <lambdabot> Unknown command, try @list
14:18:20 <quicksilver> cjay: in other networks I use the services have different names like X or N
14:18:23 <jsnx> okay, we can not add to the database :(
14:18:34 <dmwit> ?fact-cons even 4
14:18:35 <lambdabot> Fact altered.
14:18:35 <Socrates`> ?fact-cons even 4
14:18:36 <lambdabot> Fact altered.
14:18:37 <dmwit> ?fact even
14:18:37 <lambdabot> even: 4 4 2
14:18:45 <vixey> ?fact-cons even 6
14:18:46 <lambdabot> Fact altered.
14:18:48 <jsnx> oic
14:18:51 <Socrates`> ?fact-snoc even 4
14:18:52 <lambdabot> Fact altered.
14:18:52 <jsnx> interesting
14:18:59 <jsnx> but it exposes facts as lists...
14:19:04 <b_jonas> quicksilver: yeah, those might be, but those are usually notices sent to you, not to channels
14:19:11 <jsnx> ...which is not something we need to se
14:19:13 <jsnx> see
14:19:21 <b_jonas> quicksilver: privmsgs or notices sent to you are usually more important than privmsgs or notices sent to a channel
14:19:25 <jsnx> complaing, complain
14:19:28 <b_jonas> because a channel isn't personal
14:19:57 <b_jonas> so I think it's private that should be considered important, not notice
14:20:03 <quicksilver> perhaps so.
14:20:07 <quicksilver> like I said, I could change things.
14:20:16 <quicksilver> it would annoy me to do so, and I might not bother. But I could.
14:20:23 <quicksilver> I'm only stating my opinion.
14:20:31 <quicksilver> It's Cale's bot, he will do as he wishes.
14:21:12 <b_jonas> quicksilver: well, my bots are used by people and I care how many people use them
14:21:24 <Cale> Note that channel messages are technically PRIVMSGs sent to the channel.
14:21:32 <b_jonas> but luckily the bots people actually use are the ones where loops aren't a problem because they're on a private channel
14:21:38 <b_jonas> Cale: yep
14:21:55 <b_jonas> Cale: that's what I said above
14:21:56 <b_jonas> I think
14:21:57 <thomashartman1> how do I add to the "include" path from inside ghci?
14:22:01 <lilac> is there a standard function a -> (a -> Bool) -> Maybe a ? (i've tried hoogle and hayoo)
14:22:08 <quicksilver> whether you said it or not, I certainly knew it :)
14:22:19 <dmwit> thomashartman1: Try :help :set
14:22:27 <quicksilver> lilac: guard (p a) >> return a, perhaps.
14:22:31 <b_jonas> it's just wierd how of all irc commands "privmsg" has to be so long whereas others you use less often are shorter
14:22:39 <lilac> quicksilver: neat :)
14:22:51 <dmwit> thomashartman1: Err, never mind about that.
14:22:56 <b_jonas> why couldn't they make everything four letters or three numbers long like in smtp?
14:23:07 <b_jonas> PRIV or MSG or something would be nicer
14:23:12 <vixey> IRC needs redesigned
14:23:12 <b_jonas> and NOTE for notice or something
14:23:18 <dmwit> quicksilver: Yay, I'm infecting #haskell!
14:23:44 <Socrates`> thomashartman1: :module +<modulename>
14:23:48 <Socrates`> If you mean what I think you mean
14:23:49 <b_jonas> vixey: well, there are some extensions servers like freenode support
14:23:59 <b_jonas> and ctcp and color stuff the clients do
14:24:02 <b_jonas> also services
14:24:42 <thomashartman1> Socrates: I don't think I mean what you think I mean. I want to load a standard module from source so I can debug it (happs)
14:24:54 <thomashartman1> with module, doesn't it have to be compiled?
14:25:27 <b_jonas> g'nite
14:26:53 <dmwit> thomashartman1: No, :m will load interpreted modules, also.
14:27:53 <thomashartman1> dmwit: ok, but how do I specify I want to read from source somewhere rather than pick up what's installed?
14:28:07 <b_jonas> why do I need to wait 3 hours for this google treasure hunt whereas it was just ten minutes for the previous ones?
14:29:43 <dmwit> thomashartman1: I'm not sure.
14:29:46 <roconnor> > 6644-2072
14:29:47 <lambdabot>  4572
14:29:49 <sclv> thomashartman1: make sure that you're at the top of the hierarchy?
14:29:51 <dmwit> thomashartman1: From the command line, -I or -L probably work.
14:29:59 <roconnor> > 1644-322-912
14:30:01 <lambdabot>  410
14:30:01 <dmwit> oh...
14:30:07 <dmwit> *rather* than what's installed
14:30:13 <dmwit> thomashartman1: ghc-pkg hide
14:30:30 <thomashartman1> I tried :set i ~/somepath but that didn't work.
14:30:41 <thomashartman1> maybe it's one of these things that can't be set from inside ghci...
14:30:42 <sclv> i.e. if you want to load Data.Something then make sure your ghci has its path set such that Data/Something.hs is reachable
14:33:48 <mm_freak> (data SomeType where Constructor :: a -> SomeType) is the same as (data SomeType = forall a. Constructor a), isn't it?  or are there some subtle differences?
14:34:33 <vixey> I still don't really understand why typed lambda calculus will always normalize
14:34:44 <vixey> simple types
14:35:22 <mux> vixey: well simply typed lambda calculus doesn't allow to express recursion
14:36:00 <vixey> I think that is a corollary
14:36:41 <chessguy> @hoogle asTypeof
14:36:42 <lambdabot> Prelude.asTypeOf :: a -> a -> a
14:36:51 <chessguy> @src asTypeof
14:36:51 <lambdabot> Source not found.
14:36:56 <vixey> const
14:36:57 <mux> vixey: it's intuitive to go this way
14:36:59 <chessguy> @src asTypeOf
14:36:59 <lambdabot> asTypeOf = const
14:37:07 <chessguy> @src const
14:37:08 <lambdabot> const x _ = x
14:37:15 <mux> or you can read the proof in TAPL or from where anywhere else, it's fairly simple
14:37:16 <chessguy> oh, duh, i'm a moron
14:37:31 <vixey> aww
14:37:35 <vixey> I should have got TAPL today
14:37:38 <mm_freak> @pl \x _ -> x
14:37:39 <lambdabot> const
14:37:43 <mm_freak> lol
14:37:53 <mm_freak> makes sense =)
14:39:41 <chessguy> @pl \_ x -> x
14:39:41 <lambdabot> const id
14:40:13 <chessguy> @type const id
14:40:14 <lambdabot> forall a b. b -> a -> a
14:42:51 <vixey> NuPrl sounds really strange
14:44:42 <quicksilver> vixey: mux calls it simple
14:44:49 <quicksilver> vixey: I would say it is extremely deep
14:44:59 <quicksilver> the normalisation theorem for intuitionistic logic
14:45:06 <mux> the normalization proof for simply typed lambda calculus?
14:45:11 <MedeaMelana> @type const id
14:45:13 <lambdabot> forall a b. b -> a -> a
14:45:19 <MedeaMelana> @type flip const
14:45:21 <lambdabot> forall a b. b -> a -> a
14:45:25 * mux gets a hold on his TAPL
14:45:27 <roconnor> @free const
14:45:28 <lambdabot> f . const x = const (f x) . g
14:45:38 <roconnor> @free flip
14:45:40 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
14:45:56 <mar77a> > 40/8
14:45:57 <lambdabot>  5.0
14:46:11 <hpaste>  osfameron pasted "lambdacamel help needed for Perl monad :-)" at http://hpaste.org/8081
14:46:32 <osfameron> (apologies to lambdas of the non-camel persuasion)
14:47:16 <mar77a> @hoogle CReal
14:47:17 <lambdabot> No matches found
14:47:31 <vixey> mar77a: roconnors fewdigits has it
14:47:53 <mux> TAPL guides you all the way through this proof
14:48:10 <vixey> are there many different proofs of this?
14:48:22 <mux> no idea at all
14:49:20 <mattam> vixey: I think so. Many model-theoretic proofs at least.
15:00:20 <TomMD> @let ping =  (const "pong")
15:00:21 <lambdabot> Defined.
15:00:26 <TomMD> > ping "me"
15:00:27 <lambdabot>  "pong"
15:03:43 <roconnor> > scaryPrint "pong"
15:03:44 <lambdabot>   Not in scope: `scaryPrint'
15:04:36 <vincenz> @unlet
15:04:37 <lambdabot> Defined.
15:04:51 <vincenz> @let ping = const $ var "pong"
15:04:51 <lambdabot> <local>:3:0:     Multiple declarations of `L.ping'     Declared at: <local>:1...
15:04:53 <vincenz> > ping "me"
15:04:55 <lambdabot>  "pong"
15:04:55 <vincenz> @undef
15:04:56 <lambdabot> Undefined.
15:04:58 <vincenz> @let ping = const $ var "pong"
15:04:59 <lambdabot> Defined.
15:05:02 <vincenz> > ping "me"
15:05:03 <lambdabot>  pong
15:15:41 <MyCatVerbs>  @index on
15:15:48 <MyCatVerbs> @index on
15:15:48 <lambdabot> bzzt
15:15:52 <MyCatVerbs> Damn you.
15:16:00 <roconnor> MyCatVerbs: I forget what index does
15:16:24 <vixey> @src on
15:16:24 <lambdabot> (*) `on` f = \x y -> f x * f y
15:16:39 <vixey> It's in Data.Function but that line is much more interesting than "import ..."
15:16:40 <byorgey> MyCatVerbs: Data.Function
15:16:56 <MyCatVerbs> vixey: I know what it's for, but I can never remember where the Hell it's defined. ;)
15:17:07 <vixey> I mean I'd rather see
15:17:07 <vixey> (*) `on` f = \x y -> f x * f y
15:17:08 <vixey> than
15:17:11 <vixey> import Data.Function
15:17:13 <vixey> in code
15:28:27 <RayNbow> hmm, I've been wondering... would a rewrite rule like the following be safe?
15:28:44 <dons> if you have to ask, then the answer is "no" :)
15:28:44 <RayNbow> sum [a,b..c] ~~> sum_arith a b c    -- (definition of sum_arith omitted)
15:28:59 <RayNbow> yeah well, it would be safe for Ints :p
15:29:03 <dons> sure. that's fine.
15:29:17 <dons> sum [a,b ..c] == sum (enumFromToBy a b c) == sumArith a b c
15:29:20 <RayNbow> but since everyone could put their own types in the Integral class
15:29:35 <dons> you could constrain the rule to types you know about
15:29:47 <dons> sum . enumFromTo will fuse under a decent system anyway
15:29:53 <dons> so you won't get a win over the general optimisation
15:30:12 <dons> but a nice example if you want to learn how rules work
15:30:18 <MyCatVerbs> Hrmn. I'm sure this has come up before, but there isn't an arbitrary-precision floating-point arithmetic system kicking about somewhere, is there?
15:30:24 <RayNbow> I'm not planning to actually write/implement a rewrite rule... I'm just thinking about it :)
15:30:42 <dons> Rational, MyCatVerbs ?
15:30:47 <dons> > 1 / pi :: Rational
15:30:49 <lambdabot>   add an instance declaration for (Floating Rational)
15:30:50 <dons> ah not pi.
15:30:56 <dons> > 1 / (7/22) :: Rational
15:30:58 <lambdabot>  22%7
15:30:58 <RayNbow> (if I would implement it... it's currently listed last on the todo list :p)
15:30:59 <MyCatVerbs> dons: yeah, I need pi specifically. ;)
15:31:05 <vixey> > pi :: CReal
15:31:06 <lambdabot>  3.1415926535897932384626433832795028841972
15:31:09 <dolio> Yeah, but sumArith could use a closed-form to find the answer, which fusing sum and enumFromTo won't do.
15:31:15 <dons> the fancy numbers package on hackage
15:31:32 <dons> dolio: yeah, custom math rules like that for specific types would be cute.
15:31:36 <dons> you could just import Math.Rules
15:31:41 <dons> and get a whole set of nice identities
15:31:45 <roconnor> dons: why do you always use array fusion instead of stream fusion in your blog examples of summing arithmetic sequences?
15:31:47 <dons> say, just for Integer
15:32:04 <dons> roconnor: they're the same fusion system. but the arrays library is active and up to date
15:32:17 <dons> since i care about performance, and lists suck there anyway
15:32:28 <roconnor> what do you mean lists suck?
15:32:36 <roconnor> I'd think arrays would suck
15:32:53 <dons> you typically care about fusion when writing high performance code, and 1-chunk lazy lists aren't usually the structure of choice
15:32:58 <roconnor> I'm very uncompelled by your exampls.
15:33:08 <dons> *shrug*
15:33:15 <dons> what more do you want?
15:33:25 <jsnx> dons: isn't the point of fusion that it does away with the list/array/whatever ?
15:33:43 <dons> right. in which case it doesn't matter what structure i use.
15:33:53 <jsnx> oic
15:34:00 <roconnor> dons:  I usually lists as stream generators, which is totally approrate for maps and folds.
15:34:02 <jsnx> so you are using arrays most of the time
15:34:07 <roconnor> dons: arrays are for random access
15:34:16 <jsnx> and so you use them for the fusion examples
15:34:38 <dons> mostly though, i'm using uvector because its fast and nice and i'm working on it actively
15:34:44 <jsnx> but is there a reason that array fusion would be faster than list fusion?
15:34:48 <dons> it does clever things like bitwise Bool packing
15:34:56 <dons> jsnx: no , the fusion system is the same
15:35:16 <roconnor> dons: oh, so I can just pretend all your examples are on lists? :P
15:35:19 <dons> but if you actually have to allocate one of these things in the end, say, for a prime sieve or to sort things, the array is going to wipe the field.
15:35:22 <roconnor> if that makes me feel better?
15:35:26 <dons> roconnor: if that helps you.
15:35:36 <Philippa_> jsnx: just the usual reasons that arrays can be faster than lists
15:35:38 <dons> its just notation for streams
15:35:46 <MyCatVerbs> dons: hang on, is there any laziness involved?
15:35:49 <roconnor> dons: okay, I find your examples more compelling now.
15:35:54 <Philippa_> with the added advantage, I guess, that fusion may let you calculate the size of array needed in advance
15:35:55 <dons> oh, phew!
15:36:10 <dons> and removing an intermediate O(n) array shows up more in the results :)
15:36:11 <MyCatVerbs> dons: like if I specify a uvector version of facs = 1 : 1 : zipWith (+) facs (tail facs) -- it won't spontaneously explode?
15:36:19 <Philippa_> which is generally a ticket to faster execution
15:36:25 <dons> MyCatVerbs: uvectors are strict, so you can't write that.
15:36:49 <MyCatVerbs> dons: oh. So, um, how *would* you write a uvector prime sieve?
15:36:50 * Botje gets ready to implement the boring part of his compiler
15:36:59 <dons> MyCatVerbs: usual way.
15:37:02 <vixey> what does it compile?
15:37:06 * roconnor doesn't normally create arrays larger than size maxBound.
15:37:12 <Botje> compiles ML to assembly
15:37:13 <Botje> or C
15:37:17 <Botje> haven't figured out which yet
15:37:19 <vixey> cool
15:37:22 <Botje> (that's what i'm about to do)
15:37:23 <vixey> how does it work?
15:37:26 <roconnor> Botje: which part is boring?
15:37:38 <Botje> code generation
15:37:44 <chessguy> @pl f c = g (h c) (k c)
15:37:44 <lambdabot> f = liftM2 g h k
15:37:59 <Botje> vixey: i'm mostly following the "compiling with continuations" book by Andrew W. Appel
15:38:07 <mmorrow> what sort of optimizations did you do?
15:38:14 <vixey> oh I've read that I liked that book a lot
15:38:15 <Botje> nothing fancy atm
15:38:24 <Botje> just some basic constant folding
15:38:29 <vixey> I'd like to own it
15:38:35 <roconnor> I can see how that could be boring
15:38:38 <MyCatVerbs> :t all
15:38:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:38:41 <Botje> it's a nice book but it's a bit outdated imo
15:38:55 <Botje> they're very wary of memory consumption
15:39:02 <Botje> (saving bytes here and there)
15:39:16 <Botje> which gets in the way of the nice compilation process
15:39:18 <psygnisfive> is haskell, when dealing with monads, you need some way of unwrapping the monad and getting out the data that in contains right?
15:39:19 <vixey> I think Marc Feeley uses the same approach with his 60 min compiler
15:39:33 <dons> psygnisfive: typically, yes.
15:39:40 <MyCatVerbs> dons: define "usual way"? Using lists, something like 2 : filter (\a -> all (\n -> (a `mod` n) /= 1 (takeWhile (\b-> (b*b) <= a))) [3,5..] -- using uvectors, what?
15:39:47 <dons> MyCatVerbs: oh no no.
15:39:51 <dons> i was thinking bitwise sieves
15:39:56 <psygnisfive> dons: and you'd have to define that for each monad, right?
15:39:59 <dons> that'd fuse though, itnerestingly.
15:40:04 <mmorrow> i got this book a few months ago and have been slowly taking it in: http://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204/ref=sr_1_1?ie=UTF8&s=books&qid=1212532764&sr=8-1
15:40:06 <lambdabot> http://tinyurl.com/6f4tug
15:40:07 <dons> psygnisfive: right.
15:40:11 <mmorrow> *so* much stuff
15:40:14 <psygnisfive> i mean, if you have a tree monad, then the contents of the tree is different than, say, the contents of just a number wrapper or whatever
15:40:25 <psygnisfive> i presume you do that when you define the monad?
15:40:33 <vixey> I have followed this approach http://www-formal.stanford.edu/jmc/mcpain.ps
15:40:43 <MyCatVerbs> dons: would it? It eats its own tail, though, repeatedly no less.
15:41:14 <dons> oh, if you want to do anything lazy, then no, don't use strict arrays
15:42:27 <vixey> Are there books about compilation which go along with formal correctness proofs?
15:43:44 <vixey> I bet there isn't one
15:43:45 <mmorrow> i think covering the entire spectrum theory-to-implem is impossible in a single book
15:44:13 <psygnisfive> ::pokes dons::
15:44:14 <hardcopy> are there any high-profile programs writtein haskell?
15:44:15 <mmorrow> my pref is getting two books at the extremes rather than a compromise that's neither this nor that
15:44:18 <hardcopy> written*
15:44:27 <mmorrow> (this applies to most anything)
15:44:39 <EvilTerran> darcs?
15:44:43 <vixey> mmorrow: which extremes?
15:44:55 <mmorrow> theory--------------------------implementation
15:45:16 <vixey> I don't know what the difference is
15:45:19 <mmorrow> i like to fill the ------------------- in myself
15:45:38 <hardcopy> what is darcs?
15:45:45 <Peaker> what does a tree monad do? What are its values, what does binding them do?
15:46:42 <mmorrow> well, the best way to represent symbol tables and generate loads and store in asm i would call implementation
15:47:32 <mmorrow> speaking categorically about limits/colimits etc as applied to types and <insert other random things> is theory
15:47:42 <mmorrow> (in my mind at least)(
15:48:23 <mmorrow> the ---------------------- is where you get to create your sculpture
15:48:39 <vixey> that's very interesting mmorrow, ty for explaining
15:48:50 <mmorrow> :)
16:07:04 <nornagon> @ft forall b. (a -> b -> b) -> b -> b
16:07:06 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
16:07:06 <lambdabot>  Press `:help' for help or `:quit' to quit.
16:07:06 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
16:07:06 <lambdabot>  > > >
16:07:09 <nornagon> uhm.
16:07:31 <mmorrow> @ft :help
16:07:33 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
16:07:33 <lambdabot>  Press `:help' for help or `:quit' to quit.
16:07:33 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
16:07:33 <lambdabot>  > > >
16:08:41 <mmorrow> @ft `ls`
16:08:43 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
16:08:43 <lambdabot>  Press `:help' for help or `:quit' to quit.
16:08:43 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
16:08:43 <lambdabot>  > > >
16:10:41 <cjay> o_O
16:12:25 <mmorrow> :)
16:16:40 <gwern> @where hs-plugins
16:16:41 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
16:17:10 <jsnx> ByteStrings are not an instance of Foldable
16:17:24 <jsnx> is this a planned thing, or an accident?
16:17:57 <jsnx> they seem pretty foldable to me :)
16:18:46 <Saizan> jsnx: Foldables need to be able to contain any type
16:18:59 <jsnx> oh, interesting
16:19:06 <jsnx> Foldable a
16:19:32 <dons> jsnx: they're not arbitrary containers.
16:19:33 <jsnx> yeah
16:19:47 <dons> even if they were, they'd have a Storable constraint
16:19:55 <jsnx> yeah
16:20:09 <jsnx> i'm define some list comprehension based parsing stuff
16:20:22 <jsnx> and i'd like it to work on bytestrings as well as strings
16:20:37 <jsnx> so i'll have to add them both to Parseable, I guess
16:21:06 <jsnx> and then put foldr, foldl, la-di-da in there
16:21:59 <gwern> wonder whether it could work with Stringable
16:22:55 <jsnx> oh, wait, damn
16:23:03 <jsnx> then i'd have to handle unicode directly
16:23:10 <jsnx> choose my poison
16:23:12 <monochrom> <3 #haskell
16:23:40 <monochrom> Choose a 64-bit rep for unicode :)
16:23:45 <jsnx> strings it is -- sorry, ByteString
16:23:48 <saml> > '붹'
16:23:48 <lambdabot>  Improperly terminated character constant at "'붹'" (column 1)
16:24:02 <jsnx> monochrom: doesn't matter, the bytes will come in all full of UTF-8
16:24:16 <jsnx> whereas String let's me operate on Char, not bytes
16:24:28 <monochrom> If you choose a 128-bit rep for unicode, you will have "enough space for one character per IPv6 address" :)
16:24:36 <monochrom> s/space/room/
16:25:13 <jsnx> unicode is 21 bits
16:25:31 <jsnx> you'd have some serious issues with unrepresentable IP addresses
16:25:35 <vixey> hi
16:25:37 <saml> unicode can be 100000000000000000000000000000000000000000000 bits
16:25:38 <vixey> :)
16:25:39 <monochrom> Unicode 21.8 will mandate 128-bit characters.
16:25:39 <bd_> monochrom: We can have a written language for every grain of sand!
16:26:00 <dons> bits are so awesome
16:26:04 <jsnx> unicode only has 21 bits worth of characters in it, though
16:28:16 <roconnor> > maxBound :: Char
16:28:17 <lambdabot>  '\1114111'
16:28:32 <saml> not if we include all elven logographs and chinese people will add more words too
16:28:56 <jsnx> saml: well, it's not the chinese who will add words
16:29:06 <jsnx> saml: it's the japanese and koreans
16:29:16 <jsnx> the chinese basically cleaned up with unihan
16:29:31 <jsnx> (it's not unikan, after all!)
16:29:34 <saml> as far as I know, jap and kor use alphabetic system
16:30:13 <jsnx> saml: they use chinese characters for all kinds of things -- and they have special variations, for names and places and so on, that were chucked by the unihan committee
16:30:19 <saml> > log 1114111 / log 2
16:30:20 <lambdabot>  20.087461546321563
16:30:38 <saml> i think it's because haskell uses UTF-8 internally
16:30:44 <saml> i mean, ghci
16:30:49 <jsnx> well, no
16:30:58 <jsnx> unicode is just that many characters
16:31:09 <jsnx> 17 bit planes of 2^16
16:31:36 <jsnx> the first plane is the 'basic multilingual plane' -- chinese, english, german, all that
16:32:03 <jsnx> the other 16 are the 'astral planes' which serve some unspecified -- some would say mysterious or even sinister -- purpose
16:32:31 <jsnx> clearly, they are in place for our alien masters, who will reveal themselves to us when they time is right
16:32:54 <jsnx> and they damn well want their missives to print nicely!
16:33:25 <jsnx> the presence of so many planes indicates an extremely heterogenous empire
16:33:53 <jsnx> probably, halo's convenant is the best likeness of the ufonauts
16:36:27 <jsnx> if you doubt that the ufonauts can influence computer technology, i need only remind you of how they are sabotaging reiser4
16:36:59 <jsnx> the ufonauts don't want us to kno
16:39:25 <newsham> doesnt ghc used 32-bit integers to store chars?
16:39:50 <dons> yes.
16:40:02 <dons> > maxBound :: Char
16:40:04 <lambdabot>  '\1114111'
16:40:09 <dons> oh, that's cute
16:40:11 <dons> ?src Char
16:40:12 <lambdabot> data Char = C# Char#
16:40:22 <dons> Char# hmm
16:40:29 <newsham> [13:27] < saml> i think it's because haskell uses UTF-8 internally
16:40:43 <dons> i didnt' know Char# was a primitive
16:40:44 <jsnx> > fromEnum (maxBound :: Char) :: Int
16:40:45 <lambdabot>  1114111
16:41:07 <dons> right, its a 32 bit value with smart constructors to keep it down to 21 bits or so
16:41:10 <dons> nice.
16:41:16 <dons> :t chr
16:41:19 <lambdabot> Int -> Char
16:41:25 <dons> > chr (maxBound :: Int)
16:41:26 <lambdabot>  Exception: Prelude.chr: bad argument
16:41:32 <dons> smart constructors :)
16:41:57 <dons> section "Char#"  {Operations on 31-bit characters.}
16:42:00 <dons> sez the prelude.
16:42:06 <newsham> maxbound doesnt necessarily imply a particular representation
16:42:26 <dons> right. it just means they go around making it look like less than 32 bits
16:42:35 <nburlett> I'm having trouble working out how to make my Application monad work with MonadError, can I get some help?
16:42:45 <jsnx> well, on 64 bit systems, i wonder what they use?
16:42:45 <nburlett> I'm using the CGI Monad Transformer
16:42:45 <dons> oh, it is probably Word sized, actually
16:43:06 <dons> ah, no
16:43:08 <jsnx> yeah
16:43:09 <dons> typedef StgWord32          StgChar;
16:43:12 <dons> there you go.
16:43:15 <dons> 32 bits of yum.
16:43:16 <jsnx> hmmm
16:43:34 <dons> #if SIZEOF_VOID_P == 8
16:43:39 <dons> typedef StgWord32          StgHalfWord;
16:43:48 <hpaste>  nburlett pasted "Adding MonadError?" at http://hpaste.org/8082
16:44:38 <nburlett> I want to use something resembling catchCGI/throwCGI
16:45:15 <Peaker> maddox's new entry is pretty good ;)
16:45:36 <edwardk> @seen bos
16:45:37 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
16:45:41 <nburlett> any suggestions?
16:45:49 <bos> que?
16:46:12 <bos> edwardk: hi
16:46:13 <edwardk> bos: you would be officially the 11th person i've heard crack the coffee comonad joke =)
16:46:43 <bos> edwardk: that sounds about right :-)
16:47:15 <edwardk> I definitely like the bit about the dual of the decaf monad though =)
16:47:29 <edwardk> Its properties are rather simple though =)
16:48:43 <edwardk> lol. it made it into this ABSTRACT: http://portal.acm.org/citation.cfm?id=1148961.1148963&coll=GUIDE&dl=
16:48:44 <lambdabot> Title: Recursive coalgebras from comonads, http://tinyurl.com/6carsh
16:48:54 <bos> alcoholic arrows would be the generalisation, due to their ability to influence both input and output.
16:49:05 <edwardk> so it is official, the coffee comonad has been mentioned in a peer reviewed publication
16:49:12 <edwardk> or at least at a workshop
16:50:02 <Saizan> nburlett: is CGIT m an instance of MonadError?
16:50:04 <edwardk> bos: it would explain the penchant for giving the type of arrows with a wiggly arrow.
16:50:14 <nburlett> Saizan:  no :-<
16:50:40 <bos> edwardk: so true
16:50:58 <nburlett> Saizan: actually, wait, it is
16:51:11 <nburlett> instance MonadError Exception (CGIT IO) ....
16:51:26 <edwardk> I mean they wobble all over the place in http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf and I'm pretty sure its one of the laws that you should take their keys.
16:52:04 <dolio> The arrow calculus has much less wobbliness.
16:52:15 <Saizan> nburlett: so it should be easy to make an instance MonadError Exception (AppT IO)
16:52:18 <Pseudonym> No, it's got big dark circles.
16:52:24 <edwardk> Thats because with too much alcohol you can't do calculus.
16:52:24 <Pseudonym> Like kohl eye shadow.
16:52:31 <nburlett> Saizan: I couldn't get that to work quite right
16:52:40 <Pseudonym> Hey!  "Alcohol" means "kohl".
16:52:49 <Pseudonym> In Arabic.
16:52:54 <Pseudonym> That's weird.
16:54:02 <nburlett> Saizan: and by "quite right" I mean at all
16:54:09 <Saizan> nburlett: oh
16:54:17 <nburlett> Saizan: I couldn't work out the types
16:54:45 <gwern> anyone know if 'Alberto Ruiz' is on #haskell?
16:56:07 <edwardk> calulus fail: http://failblog.org/2008/03/28/calculus-fail/
16:56:07 <lambdabot> Title: Calculus Fail  FAIL Blog - Fail Pictures at Failblog.ORG
16:56:15 <mmorrow> gwern: that's the hmatrix author, right? (dunno if he's on #haskell)
16:56:47 <Pseudonym> Somebody, some day, is going to come up with a clever way to mix the "FAIL" lolmeme with Prolog.
16:56:49 <nburlett> Saizan: what would the proper implementation of catchError be?
16:56:50 <gwern> mmorrow: think so, although I'm looking at vectro specifically
16:57:01 <gwern> or GSLHaskell as I think the package name is
16:57:19 <hpaste>  (anonymous) annotated "Adding MonadError?" with "not tested" at http://hpaste.org/8082#a1
16:57:21 <mmorrow> gwern: gslhaskell -> hssl -> hmatrix
16:57:48 <mmorrow> gwern: what's vectro?
16:57:50 <Saizan> nburlett: ^^^^
16:58:19 <edwardk> bos: anyways if you're looking for a simple intuition for the cofree comonad, its also known as the 'branching stream' comonad. you include one value and then wrap a functor around one value and the functor.... ad nauseum. the functor tells you how to branch.
16:58:22 <mmorrow> (it was hssl for only a few months)
16:58:33 <bos> edwardk: sure.
16:58:59 <gwern> mmorrow: the directory name I seem to have when I get from http://dis.um.es/~alberto/GSLHaskell
16:59:02 <lambdabot> Title: GSLHaskell
16:59:16 <gwern> mmorrow: so gslhaskell is old and broken, and hmatrix is on hackage?
16:59:44 <nburlett> Saizan: hm, I think i see where that's going, but it doesn't work.. I get somethign about \env shouldn't take an argument
16:59:48 * nburlett looks into it
16:59:59 <mmorrow> gwern: yeah, as i understand it, someone else wrote gslhaskell and alberto took it over, rewrote it from scratch, and now it's hmatrix
17:00:20 <mmorrow> gwern: " so gslhaskell is old and broken, and hmatrix is on hackage?": yes
17:00:33 <Saizan> nburlett: oh, right, i forgot the Reader newtype constructor
17:00:55 <gwern> great. one directory I can scrap without guilt
17:02:07 <mmorrow> heh. don't rat me out if the gslhaskell author shows up at your door with a bat for vanishing his dir...
17:02:15 <mmorrow> ;)
17:02:41 <nburlett> Saizan:  I'm not sure I follow...
17:02:58 <nburlett> Saizan: (I'm not that good at deep haskell stuff yet, as you may be able to tell)
17:04:03 <hpaste>  nburlett annotated "Adding MonadError?" with "errors?" at http://hpaste.org/8082#a2
17:04:03 <Saizan> nburlett: App $ \env -> should be App $ ReaderT $ \env ->
17:04:10 <mm_freak> is there something like C's off_t from <sys/types.h>?  something, which is always large enough
17:05:35 <nburlett> Saizan: neat, that works
17:05:53 <nburlett> Saizan: can you say soething as to why my implementation using ask doesn't work?
17:06:09 <vixey> mm_freak: Integer can hold any Integer
17:06:27 <MyCatVerbs> vixey: any integer that fits in memory. :)
17:06:35 <mm_freak> vixey: yes, but may be wasteful sometimes
17:06:42 <EvilTerran> > maxBound :: Int
17:06:43 <lambdabot>  2147483647
17:07:04 <mm_freak> but i'll use Integer for now
17:07:05 <EvilTerran> > (minBound :: Word8, maxBound :: Word8)
17:07:05 <lambdabot>  (0,255)
17:07:21 <Saizan> nburlett: it doesn't work because "runReaderT m env `catchError` (\e -> let (App m') = h e in runReaderT m' env)" is of type CGIT IO a, since we've peeled the ReaderT layer to use CGIT's catchError
17:07:59 <nburlett> Saizan:  ah, and so we need to re-add the ReaderT layer
17:08:08 <mm_freak> ok, since System.IO uses Integer for such things, i guess, i'll do that, too
17:08:11 <Saizan> nburlett: yeah, and the App constructor
17:08:22 <nburlett> Saizan: thank you very much for your help
17:08:35 <Saizan> np
17:08:59 <nburlett> now my code will have about 10 levels fewer indents
17:09:13 <Saizan> so, App . lift $ "...." would have worked
17:10:25 <mm_freak> @hoogle alloca
17:10:25 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
17:10:25 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
17:10:25 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
17:10:30 <nburlett> Saizan: it doesn't though
17:11:23 <nburlett> Saizan:  unless there's something else in the "..." than \env -> runReaderT ....
17:12:40 <Saizan> i meant ask >>= \env -> App . lift $ runReaderT ...
17:12:59 <nburlett> Saizan: ok, that makes more sense, thanks
17:29:10 <mmorrow> three papers on this (http://webkit.org/blog/189/announcing-squirrelfish/) page look interesting at first glance (haven't read them yet)
17:29:11 <lambdabot> Title: Surfin&#8217; Safari - Blog Archive  Announcing SquirrelFish
17:29:15 <mmorrow> http://citeseer.ist.psu.edu/cache/papers/cs/32018/http:zSzzSzwww.jilp.orgzSzvol5zSzv5paper12.pdf/ertl03structure.pdf
17:29:15 <lambdabot> http://tinyurl.com/5aaqc5
17:29:19 <mmorrow> http://www.sagecertification.org/events/vee05/full_papers/p153-yunhe.pdf
17:29:20 <lambdabot> http://tinyurl.com/2pykmx
17:29:24 <mmorrow> http://www.tecgraf.puc-rio.br/~lhf/ftp/doc/jucs05.pdf
17:29:33 <mmorrow> # The Structure and Performance of Efficient Interpreters (Introduces the fundamentals of virtual machine design and explains the importance of direct threading)
17:29:38 <mmorrow> # Virtual Machine Showdown: Stack Versus Registers (Details the benefits of register machines, and the importance of copy propagation)
17:29:43 <mmorrow> # The Implementation of Lua 5.0 (Outlines the implementation of a real-world register-based bytecode engine, with a sliding register window calling convention)
17:29:56 <mmorrow> </>
17:38:31 <Pseudonym> Some interesting papers.
17:38:49 <Pseudonym> Backward copy propagation is interesting.  That one hadn't occurred to me.
17:39:48 <dbueno> @seen dcoutts
17:39:49 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 1h 38m 19s ago.
17:39:52 <Pseudonym> My first semi-serious compiler (in third year undergrad) was for a stack machine, and did some targeting analysis, which is essentially backward copy propagation within a basic block.
17:40:07 <Pseudonym> But this looks like a fairly simple generalisation.
17:40:52 <Apocalisp> if I have the function (a -> b) -> a -> m b, as well as bind, can I construct return and fmap?
17:40:59 <Apocalisp> fmap, obviously
17:41:13 <Pseudonym> ?free f :: (a -> b) -> a -> M b
17:41:14 <lambdabot> h . k = p . g => $map_M h . f k = f p . g
17:41:29 <dolio> foo id should get you return, I suppose.
17:41:31 <Apocalisp> What's ?free
17:41:37 <EvilTerran> ?help free
17:41:37 <lambdabot> free <ident>. Generate theorems for free
17:41:42 <Apocalisp> nice
17:41:46 <Pseudonym> dolio: I agree, but is that a theorem?
17:41:47 <dbueno> @seen dcoutts_
17:41:48 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 7h 5m 20s ago.
17:42:11 <EvilTerran> ?type (undefined :: (a -> b) -> a -> m b) id
17:42:13 <lambdabot> forall a (m :: * -> *). a -> m a
17:42:33 <Apocalisp> makes sense, thanks
17:42:35 <EvilTerran> Pseudonym, i suspect you could formalise that as a theorem
17:43:08 <dolio> Theorem of what?
17:43:11 <jfredett> whats the ?free thing do?
17:43:37 <Philippa_> hey Smokey`_, you ended up doing another course using Haskell or what? :-)
17:43:51 <dolio> if 'f :: (a -> b) -> a -> m b' then 'f id :: a -> m a' is just type unification.
17:43:52 <Pseudonym> dolio: I mean if you have a function f :: forall a b. (a -> b) -> a -> M b
17:44:07 <Pseudonym> then is f id _provably_ return?
17:44:16 <Pseudonym> I think the answer is "no".
17:44:26 <Pseudonym> f would have to satisfy a mapping property.
17:44:50 <dolio> What's bind?
17:44:56 <Apocalisp> >>=
17:45:31 <Pseudonym> Yeah, basically, f has to satisfy the laws for "arr".
17:45:38 <dmwit> :t \f -> liftM head . replicateM 2 . return . f
17:45:42 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad m) => f a -> f (m a)
17:45:43 <Pseudonym> In that case, arr id is indeed return.
17:47:31 <dmwit> What are the laws for arr?
17:48:37 <Apocalisp> Is there a cheat sheet I can print out?
17:48:39 <Apocalisp> :-)
17:50:44 <ddarius> arr is a functor is the main one
17:51:07 <Pseudonym> In which case, arr being a functor proves that fmap is a functor.
17:51:09 <Pseudonym> Trivially.
17:52:09 <EvilTerran> ?type arr
17:52:11 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
17:52:25 <Pseudonym> ?free arr :: (a -> b) -> A a b
17:52:25 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
17:52:28 <Pseudonym> Ah.
17:52:34 <Pseudonym> This isn't the version that suppots arrows.
17:53:09 <dolio> @ft arr :: (a -> b) -> A a b
17:53:11 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
17:53:11 <lambdabot>  Press `:help' for help or `:quit' to quit.
17:53:11 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
17:53:11 <lambdabot>  > > >
17:53:24 <dolio> Nice.
17:53:38 <Pseudonym> *FreeTheorem> putStrLn $ freeTheoremStr "arr :: (a -> b) -> A a b"
17:53:39 <Pseudonym> f_4 . v1_7 = v2_8 . f_1
17:53:39 <Pseudonym> =>
17:53:40 <Pseudonym> arr v1_7 >>> arr f_4 = arr f_1 >>> arr v2_8
17:53:58 <Pseudonym> That's why I used dollar signs.
17:54:14 <Pseudonym> *FreeTheorem> putStrLn $ freeTheoremStr "myarr :: (a -> b) -> A a b"
17:54:15 <Pseudonym> f_4 . v1_7 = v2_8 . f_1
17:54:15 <Pseudonym> =>
17:54:15 <Pseudonym> myarr v1_7 >>> arr f_4 = arr f_1 >>> myarr v2_8
17:54:18 <Pseudonym> That's better.
17:54:59 <Pseudonym> Except for the renaming, of course.
17:55:06 <Pseudonym> f . p = q . g => myarr p >>> arr f = arr g >>> myarr q
18:11:39 <yav> :q
18:11:48 <yav> oops :)
18:21:21 <edwardk> @seen bos
18:21:22 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1h 22m 45s ago.
18:21:38 <edwardk> bos: http://comonad.com/reader/2008/linear-bloom-filters/
18:21:40 <lambdabot> Title: The Comonad.Reader  Linear Bloom Filters
18:28:07 <Pseudonym> edwardk: drtomc has implemented external linear hash tables using STM.
18:28:28 <Pseudonym> Very clever implementation.
18:28:49 <edwardk> Pseudonym: nice
18:28:59 <Pseudonym> Essentially, if the in-memory page that you're interested in isn't present, you abort the transaction, perform I/O, then try again.
18:29:14 <edwardk> Pseudonym: my linear hash table in STM was the first bit of Haskell I ever wrote =)
18:29:20 <Pseudonym> Cool.
18:29:22 <edwardk> but that is a very nice model
18:29:26 <Pseudonym> Nothing like a baptism by fire.
18:29:30 <edwardk> heh
18:29:42 <Pseudonym> The only real problem with it is that it's not disk transaction safe.
18:29:51 <edwardk> yeah
18:29:53 <Pseudonym> So you wouldn't use it for a mission-critical database server.
18:30:01 <Pseudonym> Still.
18:30:03 <edwardk> i just wanted an STM hash table
18:30:07 <bd_> Pseudonym: That just needs a log to be attached, though, right?
18:30:24 <bd_> Although I suppose there is a race where the in-memory components of the transaction can be seen from IO before being comitted
18:30:56 <Pseudonym> Yeah, "add a log" isn't really a complete soluitioin for transaction management. :-)
18:31:03 <bd_> :)
18:31:08 <dons> Pseudonym: are we likely to ever see this work written up?
18:31:18 <dons> it's ridiculously cool stuff
18:31:27 <Pseudonym> However, for many applications, "the index can always be rewritten" is sometimes a good answer.
18:31:27 <dons> or any web presence?
18:31:52 <bd_> For many applications said race doesn't matter, I suspect
18:31:57 <Pseudonym> dons: Actually, it's odd you mention that.  He's already given a talk on it, and his new boss has suggested he write it up.
18:32:04 <Pseudonym> It's just a matter of tuits now, I suspect.
18:32:13 <dons> woot!
18:32:30 <edwardk> Pseudonym: My major interest in linear hashing has to do with abusing it to get faster network blooms
18:32:46 <Pseudonym> Hey, data structure abuse has a long and noble tradition.
18:32:48 <edwardk> or rather to transmit bloom filters over the network faster
18:33:14 <Pseudonym> Compression is a common approach, isn't it?
18:33:29 <Pseudonym> Bloom filter =~ inverted file.
18:33:31 <edwardk> Pseudonym: its the hierarchical rollup of the resulting bloom
18:33:53 <edwardk> Pseudonym: and the sort of 'haar encoding' of the resulting bits for increasing resolution
18:34:04 <Pseudonym> I was just about to mention the Haar transform.
18:34:09 <edwardk> yeah
18:34:10 <Pseudonym> Wondering if it'd help.
18:34:19 <Pseudonym> Using xor, I assume.
18:34:27 <edwardk> I didn't want to mention it in the write up because it seemed like a bit of a stretch to describe it that way
18:34:33 <edwardk> its not actually an xor based encoding.
18:34:49 <edwardk> its or to merge them then conditional probabilities on the way down.
18:34:54 <Pseudonym> Right.
18:35:01 <Pseudonym> Makes sense.
18:35:49 <edwardk> the conditional probabilities actually make it incredibly cheap to transmit incremental updates splitting sub-blooms.
18:36:57 <ddarius> What do you do with this thing?
18:36:58 <edwardk> since they have a nice regular structure and so you can abuse the binomial theorem to avoid encoding the entire exponentiated huffman encoding into a real tree.
18:37:06 <Pseudonym> Right.
18:37:13 <edwardk> ddarius: fast distributed database joins over the network
18:37:18 <Pseudonym> I wonder if binary interpolative coding would help.
18:37:51 <edwardk> ddarius: i have 50 servers with table A, and 100 servers with table B, how do I know who has to talk to who to do the join, and how large the intermediate result set is without getting all the data in one place?
18:38:36 <edwardk> this lets you get a feel for the size of the result set almost immediately from the first packet and get incrementally more resolution until you are comfortable with the partitioning of the reduction phae.
18:38:37 <edwardk> er phase
18:38:59 <edwardk> (One of my other obsessions)
18:41:08 <Smokey`_> out of curiosity - what IDE's do you you guys use under linux, for Haskell development?
18:41:28 <edwardk> Pseudonym: i don't think it would be a win. i have exact probabilities and a hash function should be giving me 'perfectly random choice', it seems a number line is the right answer.
18:41:35 <ddarius> Hmm.  A bunch of email messages from the 18th of October and one from March 4th keep being read into my email program as new messages (every now and then).
18:41:55 <edwardk> exponentiated huffman is just there because its cheaper and easier to explain and I don't have to argue with anyone as to why its not patent encumbered)  =)
18:41:59 <ddarius> Smokey`: I use vim for all my development at home for any language.
18:42:14 * Pseudonym laughs
18:42:22 <Pseudonym> Have you looked into Golomb codes?
18:42:24 <edwardk> yeah
18:42:41 <Pseudonym> BTW, code design is one of my geekier interests.
18:42:53 <Pseudonym> Of many.
18:43:05 <Pseudonym> I never _use_ them, but I design them anyway.
18:43:15 <edwardk> The thing is they presuppose a geometric distribution to the alphabet, and I know more about its structure a priori, so they are a pretty weak way to encode this data.
18:43:38 <Pseudonym> Right.
18:44:34 <Pseudonym> One of the interesting things about inverted file compression is that things have changed a lot in the last 15 years or so.
18:44:38 <edwardk> the arithmetic compression is actually provably optimal _iff_ you presume the bloom filter was perfectly randomly encoded, but its not since it uses 1.44* the optimal amount of space.
18:45:13 <edwardk> er times the theoretically optimal amount of space that is
18:45:14 <Pseudonym> People noticed that simpler compression schemes outperform uncompressed inverted files, even if the uncompressed data fits in memory.
18:45:35 <Pseudonym> So everything is word-aligned these days.
18:45:39 <edwardk> yeah
18:45:43 <Pseudonym> Which probably doesn't help you much.
18:45:53 <Pseudonym> The network is the bottleneck, not the bit I/O.
18:46:04 <edwardk> yeah i don't care what the CPU is doing to be quite honest ;)
18:46:28 <edwardk> I'm a big bag of disks and a network, with waaaay too much horsepower to churn data between them
18:47:03 <edwardk> So I have plenty of time to try to fuse together operations, deal with zipping up vertical column stores, etc.
18:47:30 <edwardk> my goal is to minimize network bandwidth primarily and disk IO secondarily, everything else comes for free.
18:47:44 <edwardk> or might as well unless the asymptotics are crazy ;)
18:51:43 <edwardk> You know, I just realized I never did actually work out the correct conditional probabilities for splitting a linear counted bloom filter.
18:59:07 <edwardk> anyways i figured this was a decent break from category theory =)
19:08:27 <bos> edwardk: i'm about halfway through the article, nicely written.
19:16:22 <edwardk> bos: thanks. I had a bit of a 'who is the audience' problem with it
19:17:03 <edwardk> I'm not as good at the pithy one liner posts as you or dons ;)
19:17:57 <ddarius> Which article?
19:18:17 <edwardk> ddarius: http://comonad.com/reader/2008/linear-bloom-filters/
19:18:22 <lambdabot> Title: The Comonad.Reader  Linear Bloom Filters
19:18:30 <bos> edwardk: that's okay, i don't know the adjoint of an endofunctor from my elbow.
19:18:52 <sclv_> seen this yet? http://reddit.com/r/programming/info/6lzd8/comments/
19:18:52 <lambdabot> Title:
19:18:56 <edwardk> bos: heh
19:19:14 <edwardk> sclv: yeah
19:19:14 <sclv_> wadler linked it earlier, looks to be v. interesting on formalizing the expression problem.
19:19:42 <edwardk> sclv: most of what is in their library is baked into category extras with a slightly different emphasis
19:19:52 <edwardk> but its a very good read
19:20:12 <edwardk> especially since I provide squat all in the way of documentation and they do a very nice write up =)
19:21:50 <sclv_> The code for abstracting folds is v. neat.
19:23:14 <sclv_> (it reminded me of the cofree comonad and expression problem post you did quite a bit)
19:24:53 <edwardk> sclv: they are related. the first part of my cofree comonad expression problem post is basically a weaker version of this approach, the second half was a different beast since it focused on a different way to eliminate a cofree comonad
19:25:34 <edwardk> interestingly if you look at the interface functors defined in that paper I seem to recall them being just particular left Kan extensions
19:26:41 <edwardk> Also i found it odd that they referred to the interface functor as polynomial, and then promptly included exponents in it. i never did get around to asking about that
19:27:56 * sclv_ needs to do some more incomplete digestion
19:28:54 * ddarius doesn't understand people who use non-standard contractions for a very few words (short ones no less)
19:29:28 <EvilTerran> ddarius, fair point, tho i'd argue some are worth it
19:29:29 <edwardk> ihniwyata, ddarius =)
19:29:35 <EvilTerran> *grin,duck,run,etc*
19:29:46 <sclv_> random netslang -- it gets in the bones.
19:29:49 <EvilTerran> in an informal setting such as IRC, anyway
19:30:30 * EvilTerran is happy knowing for himself that he can write proper, even if no-one else believes him due to lack of evidence :P
19:43:39 * ddarius shakes fist at edwardk, "Where's my substructural logic?"
19:44:05 <ddarius> Also, johnnowak wanted to ask you a question in #oasis
19:44:38 <mrd> pirate logic is linearrr
19:44:49 <edwardk> ddarius: heh. i should blog something about that eventually, huh? =)
19:44:58 <sclv_> ?remember mrd pirate logic is linearrr
19:44:58 <lambdabot> Nice!
19:45:08 <sclv_> ?quote pirate
19:45:08 <lambdabot> mrd says: pirate logic is linearrr
19:51:54 <TomMD> ?quote work
19:51:54 <lambdabot> ndm says: its just that yacc is a C tool, so not working well is just part of life
19:56:00 <chessguy> @hoogle xor
19:56:05 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
19:56:36 <chessguy> @hoogle Bool -> Bool -> Bool
19:56:36 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
19:56:36 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
19:56:36 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
19:56:41 <ddarius> (/=)
19:56:49 <chessguy> @hoogle+
19:56:49 <lambdabot> Data.Bool.(||) :: Bool -> Bool -> Bool
19:57:20 <chessguy> bah
19:57:23 <ddarius> > [(a,b,a/=b) | a <- [True, False], b <- [True, False]]
19:57:26 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
19:57:58 <chessguy> oh!
19:57:59 <chessguy> duh
19:59:04 <chessguy> i knew i was missing something stupid
19:59:20 <ddarius> It's not immediately obvious going the one way.
20:00:34 <ddarius> <=> is obviously ==, implication is <=
20:00:53 <ddarius> (which works out to be, unfortunately, exactly opposite of what one would like)
20:00:57 * EvilTerran blinks at that arrow pointing the wrong way
20:01:33 <EvilTerran> i've seen languages that use =< for ≤. can't remember which, tho
20:02:04 <ddarius> I guess one could use reverse implication instead and use >= to avoid confusion (or more sanely, just define and operator for it.)
20:02:30 <EvilTerran> use unicode! :P
20:04:20 <Saizan> at least it's consistent with A \subset B
20:04:30 <TomMD> Is cabal capable of modifying system configuration files?
20:11:01 <bd_> I really hope it's not - last thing I want is APT, cabal, and I all fighting over some config file :)
20:12:30 <SamB_XP> TomMD: for that, you need to actually debianize your package ;-)
20:12:43 <TomMD> bd_: I should add that I want cabal to alter my .ghci file when I run "cabal install hoogle"
20:12:59 <SamB_XP> your .ghci file?
20:13:12 <bd_> the ghc package list/
20:13:12 <bd_> ?
20:13:17 <TomMD> SamB_XP: But I do not use a Debian derivative, nor do numerous other Haskell hackers I know.
20:13:27 <SamB_XP> oh what do you use?
20:13:29 <TomMD> SamB_XP, bd_: .ghci is ghci's config.
20:13:36 <SamB_XP> I know what .ghci is
20:13:41 <bd_> oh, $HOME/.ghci?
20:13:43 <SamB_XP> but what do you want it to DO to .ghci
20:13:46 <bd_> or some system-wide one?
20:13:47 <TomMD> SamB_XP: See http://www.haskell.org/haskellwiki/Hoogle#Using_Hoogle_from_GHCi
20:13:48 <lambdabot> Title: Hoogle - HaskellWiki
20:14:20 <SamB_XP> why do you think cabal should make this change?
20:14:22 <SamB_XP> I do not.
20:14:32 <TomMD> bd_: A system wide one would be good, but I just like having the :hoogle command defined, or even better - automatically load a module every time that defines a "hoogle" function that is like :hoogle but with a "take 10"
20:15:15 <SamB_XP> now, a way to have libraries of .ghci stuff would be nice, so you could just pull in one provided by the cabal package...
20:15:45 <bos> argh, ghc continues to not build.
20:15:46 <TomMD> SamB_XP: I think it would be a minorly useful cabal feature if you could enable config updates with a flag (which could be used by something like hoogle).  I suppose this is such a minority case it isn't worth it, but I just like the idea of everything being streamlined.
20:15:54 <TomMD> bos: 6.8.3?
20:16:03 <bos> TomMD: yes.
20:16:19 <TomMD> What platform?
20:16:23 <bos> this time, the build succeeds, but haddock has its knickers in a twist.
20:16:24 <bos> linux.
20:16:40 <TomMD> I've been meaning to do some testing, but haven't bothered figuring my platforms were too well tested.
20:16:48 <bos> i wouldn't take that for granted.
20:17:05 <SamB_XP> TomMD: a better way would be to come up with a mechanism and policy for allowing .ghci code like that to be provided by packages for easy import imported easily
20:17:11 <TomMD> Fedora 9 i386, Suse 10 x86_64 core2.  Ok then, I guess I'll run some builds.
20:17:13 <SamB_XP> s/ imported easily//
20:17:41 <bos> TomMD: don't worry about fedora 9, i've got that covered. actually, no i don't, not on i386.
20:17:54 <bos> TomMD: but if you're using the system's default haddock, expect the build to fail.
20:18:28 <TomMD> SamB_XP: I was basicly thinking a flag in cabal-install that could optionally add to or replace the .ghci if in --user mode.
20:18:51 <SamB_XP> TomMD: my way seems a bit more likely to be generally useful...
20:19:12 <SamB_XP> for one, it would work equally well without --user
20:19:39 <TomMD> hummm... you mean a user could type "cabal ghci-update hoogle"  or some such?
20:20:26 <TomMD> SamB_XP: I am not clear on your suggestion.  As I just stated ^^, or am a I off mark?
20:20:30 <SamB_XP> well, I suppose it would be possible to add a simple frontend like that that would add/remove imports from a user's .ghci file...
20:21:09 <TomMD> "cabal config-update [package]"... hummm... sounds like a feature ticket.
20:21:40 <SamB_XP> I was thinking along the lines of a :source command, that would load additional .ghci code by searching a list of directories...
20:22:16 <TomMD> Oh, now I get it.  I am stuck on changing cabal when you are saying change ghci.  :source [package-ghci-suppliment].
20:23:19 <SamB_XP> with a policy about what package should put what files there, and a Cabal mechanism to do it, and maybe that policy would specify a file for the purpose you envision, and cabal could then have a simple way to add/remove these imports from the command line...
20:24:26 <SamB_XP> strictly speaking, this would not entail changes to GHCi -- such a mechanism could be hacked in easily enough ...
20:24:38 <nburlett> Does anyone know how to get the last changed row ID out of HDBC?
20:24:44 <SamB_XP> :set -package cabal
20:25:06 <SamB_XP> :def source Path.To.Magic.Source.function
20:26:51 <nburlett> crud: http://software.complete.org/software/issues/show/69
20:26:52 <lambdabot> Title: Haskell Database Connectivity - Feature #69: allow accessing ID of inserted row  ...
20:30:01 <koninkje> > updateMinWithKey (\ k _ -> "test" ) (fromList[(2,"b"),(1,"a")] :: IntMap String)
20:30:04 <lambdabot>   Not in scope: type constructor or class `IntMap'
20:30:13 <koninkje> > updateMinWithKey (\ k _ -> "test" ) (fromList[(2,"b"),(1,"a")] :: Data.IntMap String)
20:30:13 <lambdabot>   Not in scope: type constructor or class `Data.IntMap'
20:31:39 <koninkje> :l Data.IntMap
20:34:53 <newsham> is modern ghc still a STG machine, or is there a newer model it uses?
20:35:25 <bos> it's still based on STG, but with many many changes over the decades.
20:35:51 <bos> STG hasn't really stood the test of time.
20:36:02 <Elly> STG?
20:36:12 <newsham> are there any papers that supercede the 1992 STG paper?
20:36:13 <koninkje> bos: is there a latest paper on what GHC uses these days?
20:36:28 <bos> no.
20:36:36 <Adamant> I thought ghc was System F?
20:36:39 <bos> there are many many papers.
20:36:48 <dolio> There's a lot of paper of small-ish changes.
20:36:59 <bos> Adamant: that's the core language, and it's System Fc.
20:37:27 <bos> System Fc is based on System F.
20:37:40 <newsham> i think it would be nice if there was a small wiki page that showed example of haskell code in and x86 code out with comments on how and why (perhaps show some minor intermediate forms for clarity)
20:38:28 <Korollary> a ghc core tutorial?
20:38:47 <newsham> nah, just some overview of what the code coming out looks like and why
20:38:53 <newsham> doesnt have to go into lots of the ghc internals
20:38:57 <TomMD> Thats a bit different than showing the virtual machine.  Atleast the 'T' of STG is well documented throughout time (thanks to the recent SPJ paper).
20:39:08 <bd_> newsham: GHC core is probably important for that explanation
20:39:14 <Elly> what does STG stand for?
20:39:25 <koninkje> Elly: Spineless Tagless G-machine
20:39:29 <TomMD> Stateless Tagless (now tagged) Graph Reduction.
20:39:34 <bd_> newsham: (core being an intermediate representation used by GHC)
20:39:44 <bos> @seen dons
20:39:45 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 2h 7m 30s ago.
20:39:58 <newsham> bd: sure, but I dont think it needs to be a tutorial on ghc core
20:40:00 <Elly> someone link me to a paper? :P
20:40:04 <TomMD> err, oops, spinelss, silly me, pay no attention.
20:40:06 <Korollary> @where stg
20:40:06 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
20:40:18 <TomMD> @where pointer tagging
20:40:18 <lambdabot> I know nothing about pointer.
20:40:28 <TomMD> @google haskell pointer tagging
20:40:29 <lambdabot> http://www.haskell.org/~simonmar/papers/ptr-tagging.pdf
20:41:07 <bd_> newsham: GHC core is probably more readable than x86 asm... :) (and it has all the performance-relevant information you'd be interested in, from what I understand)
20:42:00 <newsham> i'm saying i want x86 and you're saying i really want core
20:42:04 <newsham> and i'm repeating that i want x86.
20:42:09 <bd_> heh, okay :)
20:42:19 <SamB_XP> newsham: you really really don't!
20:42:45 <bd_> anything you want to know about performance is in core, and probably a lot more readable, too...
20:42:46 <newsham> .. anyway, like I said, i think it might be useful to show some intermediate forms to explain the resulting assembly
20:42:57 <newsham> but a tutorial on ghc core is something diff than what i'd like to see
20:43:01 <newsham> (which might be useful, too)
20:43:20 <Korollary> I think different flags lead to different core, which leads to different x86.
20:43:28 <SamB_XP> it's hard to even get a reasonable disassembly of GHC code, isn't it?
20:43:36 <newsham> but things like transforming patterns to switch statements, etc..  not really that exciting andkinda obvious from an intuitive point of view
20:44:31 <newsham> its always useful to have a rough idea of what your compiler does to your code even if you dont know every detail
20:45:23 <newsham> and since the model is so different than what imperative code gets translated to, i imagine not a lot of beginner/intermediate haskell people have a good idea.
20:45:24 <koninkje> newsham: if you really want x86 you can tell ghc to keep the intermediate files for it
20:45:27 <newsham> (at least I know I dont)
20:45:34 <newsham> konikje: yes, I'm well aware of that
20:45:47 <newsham> *sigh*
20:45:59 <newsham> <idle>
20:46:08 <koninkje> what more do you want than the actual assembly, core, and an understanding of the STG?
20:55:22 <mmorrow> punchcards!!#
20:56:52 <syntaxfree> hey, everyone who rememebrs me.
20:57:45 <dons> hey syntaxfree
20:57:56 <SamB_XP> @tell dons I can't get firefox to print entries from your blog!
20:57:57 <lambdabot> Consider it noted.
20:58:09 <dons> SamB_XP: i've heard this before. firefox is bogus
20:58:09 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:58:30 <SamB_XP> dons: you don't think it possible that you messed up the CSS somehow?
20:59:22 <dons> well, that's also possible. can you print it from planet.haskell ?
20:59:55 <dons> i should move it somewhere nice that also generated pdfs
21:00:13 <dons> those 3k word blog posts are what, 8-10 pages of text?
21:00:58 <dons> are  there any blogs that also have a [PDF] button next to the [RSS] button?
21:01:36 <koninkje> dons: do you know what the current state of haskell/java bridging/jvm-compiling is? (Since your thesis I mean; are the projects all dead now that Scala's around?)
21:02:13 <TomMD> syntaxfree: I remember you - not that we ever talked, but I always saw you around.
21:02:27 <syntaxfree> damn, I wish I could get "into" Haskell again.
21:02:39 <TomMD> You aren't now?
21:02:50 <syntaxfree> I know basic Haskell but I'm pretty much lost in current practices.
21:03:05 <syntaxfree> I saw a code snippet that used a Vector type or typeclass
21:03:14 <syntaxfree> and then there's Control.Applicative.
21:03:27 <syntaxfree> I understood the cat theory behind it, but I'm way rusty.
21:03:39 <ddarius> Just ignore all that stuff.
21:03:47 <TomMD> oh, so you aren't saying you need to learn libraries (mtl, bytestring, binary, hdbc), but you want to know more extentions>
21:03:47 <newsham> mmm applicative
21:04:12 <khafra> Say, how do I do destructive array updates in a purely functional paradigm?  Especially if I have to invent monads myself, like in javascript?
21:04:32 * vijay4114 yawns
21:04:33 <SamB_XP> I don't use control.applicative yet...
21:04:44 <bd_> khafra: MArray
21:04:45 <syntaxfree> I don't know. Doing toy project seems pointless by now and I'd like to at least understand modern code. Ideally collaborate in something.
21:04:53 <bd_> @docs Data.Array.MArray
21:04:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
21:05:00 <syntaxfree> s/toy project/toy projects/
21:05:12 <syntaxfree> yeah, I can learn libraries from Haddock dcos.
21:05:15 <syntaxfree> docs.
21:05:20 <khafra> bd: The requested URL /ghc/docs/latest/html/libraries/base/Data-Array-MArray.html was not found on this server.
21:05:28 <syntaxfree> I'm still lost in the forest of Haskell innovations.
21:05:42 <dons> koninkje: there are no projects for jvm. there's a new .NET bridge andrew appleyard wrote
21:05:47 <dons> he needs some encouragement to release it
21:07:22 <khafra> bd_: Doesn't seem to be anything on Arrays except in the marshal context there.  Perhaps if I read up on the ST monad I can build mutable arrays up from first principles in a few quick Array.prototype functions.
21:07:28 <koninkje> hmm, does that mean LambdaVM is dead then (albeit it was targeting ghc6.6)
21:07:35 <SamB_XP> dons: planet haskell appears as if tit would print adequately, though the links on the right don't appear as though they'll work properly...
21:08:19 <bd_> khafra: ah, it's moved in ghc-head, but not in the bot's index
21:08:22 <syntaxfree> I don't remember if I emailed the planet haskell people about getting my new blog i it.
21:08:23 <dons> SamB_XP: what do yo uget? i just get a truncated page.
21:08:28 <bd_> khafra: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-MArray.html (see also Data.Array.ST)
21:08:28 <lambdabot> http://tinyurl.com/2rsgh5
21:08:44 <syntaxfree> I imported all my old blogs' stuff, including data.syntaxfree, but there's no new haskell content.
21:09:00 <syntaxfree> OTOH, Haskell-oriented readers would encourage me writing Haskell content.
21:09:39 <syntaxfree> I don't have much of an incentive to write Haskell content now. My readership shifted. Then again, I don't want to impose non-Haskell content on Haskellers.
21:11:00 <syntaxfree> sorry, I'm drowning Haskell chat out.
21:11:09 <syntaxfree> will shut the fuck up now.
21:11:30 <shapr> vijay4114: ?
21:11:41 <vijay4114> i'm new to irc
21:11:45 <shapr> Hi vijay4114
21:11:49 <shapr> Are you learning Haskell?
21:11:54 <vijay4114> yes
21:11:59 <shapr> How do you like it so far?
21:11:59 <syntaxfree> vijay4114 are you new to Haskell?
21:12:06 <vijay4114> yes
21:12:15 <syntaxfree> vijay4114 cool. Maybe we can go together.
21:12:18 <khafra> bd_: Interesting.  Doesn't tell quite how I can make 'em myself, but that's probably sort of complicated.
21:12:34 <syntaxfree> I'm probably an inch ahead of you so I can do intensive tutoring.
21:12:46 <vijay4114> ok
21:13:19 <syntaxfree> that way the people who actually do stuff have free time and I get stoked on Haskell again.
21:13:19 <vijay4114> syntaxfree, how long have you been learning haskell?
21:13:27 <bd_> khafra: wait, *make* them? :)
21:13:27 <syntaxfree> vijay4114 do you have MSN or Gtalk?
21:13:34 <bd_> khafra: what's your monad going to look like?
21:14:00 <bd_> khafra: Generally speaking you want to wrap them or build on them - making a new (safe!) monad with array support will likely boil down to rewriting St
21:14:36 <syntaxfree> vijay4114: two years, I think, but it's been on and off.
21:14:44 <vijay4114> nope i don't have either :-(
21:15:00 <vijay4114> i started learning haskell 3 weeks ago
21:15:05 <syntaxfree> vijay4114 no gmail? gmail = gtalk if you enable it.
21:15:24 <vijay4114> i know but most of my friends keep on chatting at work and not cool
21:15:33 <vijay4114> so i don't use gtalk whatsoever
21:15:55 <syntaxfree> well, I can't kep logging on IRC most of the time.
21:16:03 <syntaxfree> gtalk and msn are passively there.
21:16:18 <vijay4114> oh ok, this is my first time on irc
21:17:09 <syntaxfree> anyhoo.. I could mentor you through your first steps. You'll probably outgrow me soon, but we both can profit from the initial experience.
21:17:49 <vijay4114> that'll be great
21:18:21 <syntaxfree> I just need IM contact with you. Preferably gtalk.
21:18:26 <mxc> i feel like if i had a haskell class or something i could have picked it up mcuh much faster than the tutorials i used
21:18:35 <mxc> which is funny because usually i feel the opposite
21:18:57 <mxc> maybe because learning haskell /= memorization or silly crap but a lot of deep thinking
21:19:03 <newsham> mxc: have you read any of the real world haskell chapters?
21:19:14 <newsham> also have you tried exercises ?
21:20:04 <bos> oh my, another ghc build failure.
21:21:46 <vijay4114> syntaxfree, r u there?
21:21:55 <syntaxfree> vijay4114 yeah.
21:21:57 <khafra> bd_: Yeah, the class I had to take this semester uses all javascript, but I already pretty much know javascript up to 1.5.  Taking advantage of the first class functions to do things functionally is a bit more of a challenge.
21:22:04 <syntaxfree> vijay4114 so. IM contact?
21:22:11 <vijay4114> vijay4114
21:22:15 <vijay4114> same on gtalk
21:22:22 <syntaxfree> okie.
21:22:29 <mxc> newsham - after i got through everytying else
21:22:31 <vijay4114> i'm logging on right now
21:22:32 <mxc> RW haskell is the bedy
21:22:32 <khafra> bd_: Perhaps too much of a challenge, now that I've run into a homework assignment that requires array updates.
21:22:39 <mxc> best
21:22:53 <bd_> khafra: um. I'm not sure what javascript has to do with haskell.
21:23:09 <syntaxfree> vijay4114 what have you been working at/with/
21:23:17 <syntaxfree> (just added you on gtalk)
21:24:09 <vijay4114> well right now working with ROR but keep on reading about FP in my free time
21:24:11 <khafra> bd_: It's more that there's no #functional, and people in #javascript would just look at me funny if I asked them about destructive array updates in a purely functional language.
21:24:32 <syntaxfree> vijay4114 what are you doing to learn Haskell?
21:24:45 <bd_> khafra: aah... I see. I don't think you'll be able to implement ST in Javascript though - it requires type constraints javascript can't provide in order to be sound.
21:25:01 <bd_> khafra: You could implement IOArrays - basically plain old mutable arrays, accessible only from the IO monad.
21:25:05 <vijay4114> reading tutorials on haskell.org
21:25:47 <bd_> khafra: or DiffArrays - basically, they maintain a copy of the most recent version (updated destructively), plus an undo log to replay if you access an older version
21:26:06 <bd_> so it looks like you're doing non-destructive copy+modify stuff, but better performance
21:26:33 <khafra> bd_: So, there's strict functional, pure functional, and smoke-and-mirrors functional?
21:27:16 <bd_> khafra: Well, the haskell ones are all pure functional, thanks to the type system :)
21:27:23 <bd_> well, diffarray doesn't need the type system
21:27:45 <ketil> bos?
21:27:48 <khafra> Yeah; one could arbitrarily extend the number of "shadow copies," but then I'd feel like a Microsoft file system.
21:27:52 <koninkje> khafra: strict/lazy is orthogonal to the pure/impure/smoke&mirrors axis
21:27:54 <bd_> basically, DiffArray looks pure, and is implemented internally with destructive updates - constrained so you can't /tell/ that it's doing that
21:27:55 <bos> ketil?
21:27:55 <koninkje> :)
21:28:26 <bd_> STArrays and IOArrays are for when you want to explicitly code in a destructive way, but without wrecking all the rest of the pure system (so it's embedded into a monad to provide sequencing)
21:28:29 <khafra> koninkje: Ah, yes.  Bringing functional programming into the third dimension, that's me!
21:28:52 <ketil> hi there!  I presume your example was tailored to my interests, rather than representing your own then?
21:29:06 <khafra> bd_: But the ST monad can't be done without a bit more typing than javascript's loosey-goosey system provides?
21:29:13 <bd_> khafra: correct
21:29:17 <bd_> :t newSTVar
21:29:19 <bd_> :t runST
21:29:22 <lambdabot> Not in scope: `newSTVar'
21:29:22 <lambdabot> forall a. (forall s. ST s a) -> a
21:29:28 <bd_> :t newSTRef
21:29:30 <lambdabot> Not in scope: `newSTRef'
21:29:33 <bd_> hmm
21:29:35 <bd_> @hoogle newSTRef
21:29:35 <lambdabot> Data.STRef.newSTRef :: a -> ST s (STRef s a)
21:29:35 <lambdabot> Data.STRef.Lazy.newSTRef :: a -> ST s (STRef s a)
21:29:38 <bd_> right then
21:29:51 <bd_> ST is a monad which allows you to use mutable data from a functional context
21:29:59 <khafra> Well, I feel much better about doing it procedurally when it's categorically impossible to do it functionally; I guess that'll work.
21:30:07 <bd_> but safely
21:30:18 <bd_> the trick is that, in ST, you can create mutable variables and arrays
21:30:22 <bd_> but you can't pass them outside the ST monad
21:30:26 <bd_> nor can any leak in
21:30:48 <bd_> this is ensured by the forall you can see here:
21:30:49 <bd_> :t runST
21:30:51 <lambdabot> forall a. (forall s. ST s a) -> a
21:31:03 <bos> ketil: i'm interested in the bioinformatics end of things, but i lack the time to do anything meaningful.
21:31:08 <bd_> the requirement is that, no matter what type 's' is, 'a' must always be the same
21:31:20 <bd_> now, since all of the mutable types have this 's' bound in them
21:31:25 <bd_> as well as the monad itself
21:31:31 <bos> ketil: that said, if you need any twiddles to the bloomfilter library for your needs, holler.
21:31:38 <bd_> the effect is you can't pass them - even embedded deeply in a data structure - outside the ST monad
21:31:54 <bd_> which in turn means it's impossible to violate referential integrity
21:32:01 <koninkje> and part of the trick is that no value of s ever really exists
21:32:28 <bd_> right, 's' is just part of a proof we're asking the type system to carry out
21:32:43 <bd_> we're asking the type system to prove that this computation, built out of impure primitives, is actually pure
21:32:47 <khafra> This is like quantum entanglement and shit.  I think I need to smoke a bowl and think about it again.  Preferably a bowl of Wheaties, since they have omega 3 fatty acids.
21:33:16 <bd_> or well, a proof we're asking it to verify at least
21:33:51 <bd_> khafra: a bit more : http://www.haskell.org/haskellwiki/Monad/ST
21:33:52 <lambdabot> Title: Monad/ST - HaskellWiki
21:34:13 <bd_> anyway, without a real type system - one more powerful than standard haskell98 in fact! - you can't really safely implement ST
21:34:19 <sclv> sigh. postgres is too smart
21:34:32 <koninkje> khafra: well the nice thing about the trick is that you don't need to know how it works in order to use id
21:34:35 <koninkje> s/id/it/
21:34:37 <sclv> sqlite's single writer lock means that I can interleave naturally with stm.
21:34:45 <khafra> bd_: I'll put my monitor under my pillow and sleep on it.  Thanks; the monad tutorials out there are of varying worth.
21:34:47 <bd_> you do however need to know how it works in order to replicate it :)
21:34:52 <ddarius> bd_: You probably could with extra dynamic checks.  To get a version of lazy ST would take some cleverness and/or significant inefficiency though.
21:35:07 <bd_> ddarius: you mean, work out the types in runST itself?
21:35:15 <sclv> postgres' optimistic strategy is more efficient, but doesn't map neatly to interleaving atomicity
21:35:29 <koninkje> bd_: true that. Though you'd need rank-2 polymorphism if you wanted to use the same approach
21:36:05 <ddarius> bd_: I mean switch from using types to enforce the abstraction to using dynamic checks.
21:36:13 <bd_> ah
21:36:31 <bd_> I don't think that's necessarily possible without extreme rigor though - JS doesn't enforce any purity as is...
21:37:57 <khafra> I saw somebody online talking about monads in javascript, but he was using some framework I hadn't seen and I didn't really get it.
21:40:17 <sclv> now i need to use explicit locks. yikes.
21:40:56 <sclv> khafra: possibly the maybe monad. that's acquired some popularity as an idiom in various dynamic languages.
21:42:07 <khafra> sclv: Design patterny?
21:42:16 <khafra> Anyway, goodnight all; I have much on which to cogitate now
21:49:33 * sclv has come to the conclusion that mvcc is some bs
21:50:01 <bensonk> so is lambdabot like eggdrop?
21:50:29 <sjanssen> @vixen are you like eggdrop?
21:50:30 <lambdabot> i'd say i like
21:51:07 <bensonk> somebody told me that haskell is almost as good as c for writing cool stuff in
21:51:30 <sjanssen> bensonk: lambdabot is an IRC bot, but the similarity ends there
21:51:37 <bensonk> o rly?
21:51:43 <sjanssen> s/almost as good as/better than/
21:51:47 <sjanssen> :)
21:51:53 <bensonk> its hard to install
21:52:02 <sjanssen> Haskell is?
21:52:03 <bensonk> i tried foar liek 3 hours
21:52:06 <bensonk> no
21:52:06 <Draconx> "emerge ghc" - not hard at all.
21:52:08 <bensonk> lambdabot
21:52:17 <sjanssen> bensonk: oh yeah, lambdabot is a bit of a mess
21:52:19 <bensonk> Okay, enough playing stupid, it's too hard.
21:52:30 <bensonk> A good majority of the haskell ebuilds appear to be fucking broken.
21:52:34 <bensonk> It really bothered me.
21:52:51 <bensonk> I installed the layman overlay for haskell, which is cool, and started trying to install some deps for lambdabot.
21:53:10 <sjanssen> the Haskell overlay should be considered experimental only
21:53:11 <bensonk> (I did a darcs get --partial on the lambdabot sources and tried to build, got a list of deps)
21:53:24 <bensonk> Well, the stuff in main portage is pretty shot to hell too.
21:53:42 <sjanssen> but I'm sure #gentoo-haskell or the bug tracker would love to hear from you
21:53:43 <bensonk> A number of packages depend on an old version of cabal and a lot of them depend on newer ones.
21:53:54 <sjanssen> IME, Gentoo's Haskell stuff works pretty well in general
21:53:55 <bensonk> A lot of the stuff that lambdabot depends on is ~x86
21:54:22 <bensonk> It appears to me that one or more ebuild writers fail at identifying deps
21:54:29 <Draconx> and how is that a problem with the main portage tree?
21:54:46 <bensonk> At least twice I had cabal say "this package depends on _______" in an emerge.
21:55:05 <bensonk> I was able to emerge _______ and get it to install fine.
21:55:20 <bensonk> Which leads me to believe that somebody fails at dependency checking.
21:55:30 <bensonk> I found it pretty frustrating, and thought I'd come ask about it.
21:55:46 <bensonk> If you all think it's fine, then I'm sure I just have unreasonable expectations of ebuild writers.
21:56:06 <bensonk> I know the old standard "if it's not good enough for you, why don't you fix it?", and I'd love to, but I just don't have time right now.
21:56:18 <bensonk> I'm in my last two weeks of my undergraduate degree.
21:56:33 <vijay4114> sb
21:56:36 <sjanssen> bensonk: please see #gentoo-haskell, somebody with the ability to fix it will notice there
21:56:59 <bensonk> In about 3 weeks, if I remember, I will come back with an enumerated list of everything I'm bitching about here.
21:57:24 <bensonk> If I'm feeling particularly energetic, it may come with some patches.
21:57:26 <vijay4114> anyone know how to scroll in irssi
21:57:30 <bensonk> page up and page down.
21:57:43 <sjanssen> so why complain if you won't even take the smallest of steps to help fix the bugs?
21:57:57 <bensonk> I wanted to know what the feeling of the community was.
21:58:24 <dons> gentoo package dep issues? to be fixed by the gentoo package people. they're quite active, and will be happy to know of any issues
21:58:36 <bensonk> From my experience, I feel like the state of haskell on gentoo is pretty hideous, and I wanted to know if people agreed.
21:58:57 <bensonk> I'm also not terribly impressed with lambdabot's cabal file, but that's a different issue.
21:59:03 <dons> talk to the #gentoo-haskell team. afaik, there are more haskell packages available on gentoo than any other system.
21:59:17 <bensonk> That'd be great if they actually worked.
21:59:18 <bensonk> :-P
21:59:24 <sjanssen> bensonk: the stuff in portage should be solid, overlay will be a mixed bag
21:59:26 <bensonk> and I will talk to them.
21:59:28 <sclv> anyone here have much experience with integrating different transactional locking systems?
21:59:43 <dons> do you have all the info you need to puruse the issue now, bensonk ?
22:00:03 <dons> throwing up notes on a wiki page might be a good idea, if you're keen.
22:00:06 <sjanssen> though I have to admit I haven't been on Gentoo for 6 months
22:00:17 <bensonk> dons: I think so.  I will pursue it in a few weeks when I don't have a chem minor resting on a test I very much need to do well on.
22:00:22 <dons> ok.
22:00:32 <bensonk> Thanks for your input.
22:00:48 <sjanssen> somebody should fix lambdabot
22:01:03 <bensonk> I'm going to shut up and watch the traffic going on here for a while and see if I can learn something. :-)
22:01:18 <dons> i've been a little unhappy that it has becomes more unstable over the past few months, sjanssen. it really needs a rewrite of its core.
22:01:25 <dons> but its a lot of work, unfortunately.
22:01:37 <sjanssen> dons: I'm talking purely from a building/distribution standpoint
22:01:45 <sjanssen> but I'm sure there are lots of actual runtime bugs too
22:01:57 <dons> it needs someone with time to pay to the install process.
22:02:02 <sjanssen> right
22:02:12 * sclv wonders if it wouldn't be a good candidate for an undergrad thesis?
22:02:15 <dons> its a typical post-Makefile system. lots of make-ish complexities
22:02:24 <sjanssen> I started killing BotPP recently, and it got pretty ugly
22:02:24 <bensonk> There's a particularly broken instance of lambdabot running in #decorum if anybody's interested in seeing runtime errors. :-/
22:02:52 <dons> bensonk: you can just have the central lambdabot join, if you like
22:03:25 <dons> this is what a build system looks like if you let an irc channel write it
22:03:41 <sjanssen> over what, 6 years?
22:03:52 <dons> yep
22:04:11 <Pseudonym> Oh, man.
22:04:23 <dons> Pseudonym: feeling your age? :)
22:04:28 <Pseudonym> I'm trying to envisage an IRC channel-created make process.
22:04:32 <dons> heh
22:04:37 <bensonk> Does it look like autoconf?
22:04:45 <dons> its not so bad, no.
22:04:46 <sjanssen> it uses autoconf
22:04:51 <Pseudonym> foo : foo.o a/s/l ERIC SUX
22:04:57 <dons> hehe
22:05:10 <dons> sjanssen: oh wow, so it does.
22:05:25 <dons> ah, to find out where gm4 is :)
22:05:31 <dons> which makes *perfect sense*
22:05:37 <sjanssen> @version
22:05:37 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
22:05:37 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:05:45 <dons> this, children, is what distribute was like before cabal
22:05:47 <sjanssen> also to generate that info
22:05:58 <dons> s/distribution/
22:06:04 <sjanssen> do we care enough about @version to require autoconf?
22:06:25 <dons> nah, just use the cabal generated .hs version number
22:06:35 <vijay4114> bye all
22:06:38 <dons> we used to be getting patches 10-20 a day, so it was fun
22:06:38 <sjanssen> it won't give us patch number, but meh
22:06:48 <dons> well, patch number also breaks hackage distribution
22:07:50 <sjanssen> I seem to have 31 more patches than this lambdabot
22:10:16 <sjanssen> dons: should plugins/RunPlugs automatically determine which packages to link in?
22:14:05 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8084
22:14:15 <tieTYT2> how's myTakeWhile look?
22:15:01 <tieTYT2> @src takeWhile
22:15:01 <lambdabot> takeWhile _ []                 =  []
22:15:01 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
22:15:01 <lambdabot>                    | otherwise =  []
22:15:22 <bensonk> damn, haskell is ridiculously pretty.
22:15:28 <Elly> I need to learn to use the | notation
22:15:29 <bensonk> I've been writing a lot of C and Python recently...
22:15:39 <Elly> bensonk: I extend my sympathies
22:15:40 <tieTYT2> Elly: it's easy
22:15:48 <Elly> I've been debugging a lot of C++ lately :(
22:16:03 <tieTYT2> @src foldr
22:16:03 <lambdabot> foldr f z []     = z
22:16:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:16:04 <bensonk> How do you do things without using guard notation?  That sounds very difficult.
22:16:26 <Elly> if p x then x : takeWhile p xs else []
22:16:47 <Elly> @src foldl
22:16:47 <lambdabot> foldl f z []     = z
22:16:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:16:51 <Elly> aha, I did have it right
22:17:34 <sjanssen> tieTYT2: your indentation looks a bit funny, are you using tabs?
22:17:50 <tieTYT2> sjanssen: yes, but i told my editor to make tabs = 4 spaces
22:18:01 <sjanssen> tieTYT2: don't do that
22:18:06 <tieTYT2> what should i do then?
22:18:10 <sjanssen> Haskell says that tabs are 8 spaces
22:18:21 <sjanssen> the best thing is to never use tabs in Haskell source
22:18:29 <tieTYT2> well i'm not
22:18:33 <ddarius> the best thing is never to use tabs
22:18:39 <tieTYT2> i made tabs literally = 4 spaces
22:18:51 <sjanssen> ah, that's fine
22:19:04 <tieTYT2> but i must not be using a monospaced font or something
22:19:07 <sjanssen> tieTYT2: your |'s don't line up, which is a bit weird
22:19:10 <tieTYT2> cause i can't get my |'s to line up
22:19:27 <tieTYT2> anyone know a common monospaced font?
22:19:43 <bensonk> I use the expandtab option in vim, so even if I hit tab I still get spaces.
22:20:04 <Elly> man I hate xfontsel
22:20:10 <sjanssen> tieTYT2: Courier is available pretty much everywhere (but is pretty ugly)
22:20:15 <Elly> bensonk: that has interesting effects on makefiles :(
22:20:25 <tieTYT2> ah ctrl+f11 turns it on in my editor
22:20:41 <tieTYT2> alright these pastes should look better in the future
22:20:52 <sjanssen> what editor doesn't use a monospace font?
22:21:12 <Elly> SciTE doesn't by default
22:21:16 <bensonk> Elly: I believe vim is smart enough to override the option when you're in a makefile.
22:21:24 <Elly> bensonk: I must have smart mode turned off :P
22:21:49 <sjanssen> tieTYT2: anyway, the definition looks good, I've only got small style complaints
22:21:57 <bensonk> At any rate, you can still get a real tab with <ctrl-v><tab>
22:22:10 <sjanssen> redundant parens around helper and the indentation
22:22:13 <tieTYT2> ok cool
22:22:28 <tieTYT2> is it normal for the foldr diagram to make perfect sense to me but the @src to be confusing as hell?
22:22:36 <sjanssen> @src foldr
22:22:37 <lambdabot> foldr f z []     = z
22:22:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:22:47 <sjanssen> tieTYT2: perhaps
22:23:16 <sjanssen> > foldr f z [1 .. 5]
22:23:31 <lambdabot>  thread killed
22:23:32 <tieTYT2> hm
22:23:40 <sjanssen> hmm, why would this die?
22:23:41 <tieTYT2> > foldr f z [1..5]
22:23:44 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
22:23:47 <tieTYT2> spaces?
22:23:54 <tieTYT2> that still took a long ass time
22:24:02 <tieTYT2> oh i get it now
22:24:03 <sjanssen> probably the box is under heavy load
22:24:37 <tieTYT2> so when f evaluates, (foldr f z xs) is passed in as a single argument
22:24:50 <tieTYT2> i just had a brainfart wrt haskell syntax
22:25:15 <Elly> hm
22:25:20 <Elly> I wish there was a way to do that normally
22:25:23 <tieTYT2> so it's interesting, I could have f 3 = []
22:25:28 <Elly> (make it expand an expression with variables still in
22:25:31 <Elly> )
22:25:47 <tieTYT2> and then from lazy evaluation, if I even got to that point, the rest would be ignored right?
22:26:13 <sjanssen> tieTYT2: yes, this is exactly what myTakeWhile does in fact
22:26:27 <tieTYT2> right, i figured but it's hard to visualize
22:26:31 <tieTYT2> f 1 (f 2 (f [] (f 4 (f 5 z))))
22:26:39 <tieTYT2> err
22:26:44 <Elly> that's not right
22:26:45 <tieTYT2> f 1 (f 2 ([] (f 4 (f 5 z))))
22:26:52 <sjanssen> also not right
22:26:55 <Elly> [] isn't a function
22:26:55 <tieTYT2> that's how i visualize it
22:26:56 <sjanssen> [] is not a function
22:27:08 <sjanssen> Elly: bah, you are too fast!
22:27:13 <Elly> sjanssen: ;)
22:27:22 <tieTYT2> ah i get it
22:27:27 <tieTYT2> so f takes x and whatever
22:27:33 <tieTYT2> and returns [] from EVERYTHING
22:27:44 <koninkje> Elly: well it's a nullary function...
22:27:52 <tieTYT2> i hate the fact that I can make something work then I have to take 25 minutes to figure out why it does
22:28:03 <koninkje> (granted not what most people think of as "functions")
22:28:03 <sjanssen> koninkje: there is no such term in Haskell
22:28:08 <tieTYT2> it's like my subconscious can do functional programming but my conscious can't :P
22:28:11 <sjanssen> koninkje: there are only functions of one argument
22:28:42 <koninkje> sjanssen: they're all closures so far as I'm aware
22:29:02 <sjanssen> closures are orthogonal here
22:29:12 <sjanssen> functions are things that unify with (a -> b)
22:29:27 <sjanssen> [x] doesn't unify with (a -> b)
22:30:18 <sjanssen> koninkje: besides, in what way is [] a closure?
22:31:00 <tieTYT2> rwh should define lambda earlier..
22:31:03 <koninkje> sjanssen: the way it's represented in memory (unless that particular aspect of the STG has changed)
22:31:09 <tieTYT2> a lambda is just an anonymous function right?
22:31:13 <ddarius> Yes.
22:31:27 <tieTYT2> ie let f x = even x in .... is the same as (\even x) ?
22:31:27 <sjanssen> koninkje: [] is a constructor, so it is represented directly
22:31:50 <ddarius> tieTYT: No.
22:31:51 <koninkje> sjanssen: "directly" as what? constructors are functions too
22:31:58 <tieTYT2> ah i think my syntax is wrong
22:32:06 <Elly> tieTYT2: (\x -> x + 1) is a lambda
22:32:18 <Elly> tieTYT2: all functions are "lambdas", though; some of them just have names
22:32:47 <koninkje> tieTYT2: "let foo x y z = e" === "let foo = \x y z -> e"
22:32:51 <Elly> (is the \ syntax supposed to evoke \lambda syntax from lambda calculus? it certainly does for me :P)
22:33:04 <ddarius> Yes
22:33:09 <Korollary> mission accomplished
22:33:12 <tieTYT2> ok cool
22:34:22 <sjanssen> koninkje: (in GHC) [] has a representation that is distinct from functions and thunks
22:35:01 <sjanssen> also, why should we define what is and is not a function according to a certain implementation strategy?
22:37:15 <jsnx> dons: that fusion entry on your blog is cool
22:37:56 <Elly> where is dons' blog?
22:37:57 <tieTYT2> can someone describe what groupBy does?
22:37:59 <Elly> I forgot :(
22:38:00 <tieTYT2> i don't want to look at the src
22:38:05 <tieTYT2> cause i plan to implement it
22:38:17 <jsnx> http://cgi.cse.unsw.edu.au/~dons/blog/2008/06/04#fast-fusion
22:38:17 <lambdabot> Title: Haskell hacking
22:38:39 <jsnx> tieTYT2: is groupBy in SQL?
22:38:43 <tieTYT2> no
22:38:45 <Elly> tieTYT2: see the definition of group
22:38:47 <tieTYT2> it's in List.Data
22:38:55 <tieTYT2> err
22:38:56 <tieTYT2> Data.List
22:38:59 <Elly> tieTYT2: what group does is pretty simple; groupBy is just an extension of it
22:39:12 <tieTYT2> @src group
22:39:13 <lambdabot> group = groupBy (==)
22:39:13 <sjanssen> > groupBy (==) [1, 1, 2, 1, 3, 3, 1, 1, 3]
22:39:15 <lambdabot>  [[1,1],[2],[1],[3,3],[1,1],[3]]
22:39:47 <tieTYT2> ok i get it
22:39:57 <tieTYT2> thanks
22:40:53 <tieTYT2> > groupBy (\a b -> even (a + b)) [1, 1, 2, 1, 3, 3, 1, 1, 3]
22:40:53 <Elly> > groupBy (\x y -> x `mod` 3 == y `mod` 3) [1, 4, 6, 2, 8, 3, 4, 9, 0]
22:40:58 <lambdabot>  [[1,1],[2],[1,3,3,1,1,3]]
22:40:58 <lambdabot>  [[1,4],[6],[2,8],[3],[4],[9,0]]
22:41:05 <tieTYT2> hm, i did something wrong
22:41:21 <tieTYT2> oh
22:41:26 <Elly> look at what I did
22:42:12 <tieTYT2> Elly: yours takes too much brain power :P
22:42:24 <Elly> no it doesn't
22:42:31 <Elly> two numbers are "equal" if they are equal mod 3
22:42:32 <tieTYT2> you've got more brain power than i do
22:42:45 <dmwit> tieTYT2: Why do you think you did something wrong?
22:42:45 <Elly> I doubt that
22:42:55 <Elly> I just spent 10 hours at work and my brain feels like it is stuffed with cotton wool
22:42:59 <tieTYT2> dmwit: i got confused by Elly's paste, i thought lambdabot said that
22:43:05 <dmwit> Oh, heh.
22:43:12 * Elly doesn't look like lambdabot
22:43:15 <tieTYT2> here's what i'm confused about in my example
22:43:21 <Korollary> cotton wool. Hmm..
22:43:29 <tieTYT2> > groupBy (\a b -> even (a + b)) [1, 1, 2, 1, 3, 3, 1, 1, 3]
22:43:31 <lambdabot>  [[1,1],[2],[1,3,3,1,1,3]]
22:43:50 <Elly> so you say two elements are equal if their sum is even
22:43:50 <dmwit> tieTYT2: Note that groupBy is only specified in a way that works well for true equivalence classes.
22:43:51 <roconnor> what is the domain for austria?
22:43:57 <Korollary> at
22:43:58 <Elly> roconnor: .au
22:44:02 <tieTYT2> for that last one, is it doing even (1 + 3) then even (4 + 3)?
22:44:03 <Elly> oh, austria
22:44:04 <roconnor> at
22:44:05 <Elly> sorry
22:44:11 <Elly> I read australia :P
22:44:17 <dmwit> tieTYT2: In particular, each element of a "group" is compared against the first element of the group, not against the previous element of the group.
22:44:19 <Korollary> you just spent 10 hours at work
22:44:38 <roconnor> anyone know what the austrian passenger train site is?
22:44:42 <roconnor> oebb.at?
22:44:50 <Elly> Korollary: it's true, I did
22:44:54 <Elly> roconnor: google might
22:44:56 <dmwit> tieTYT2: No, each element is compared against the "head" of the currently growing group.  If they're "equal", the group grows; otherwise, a new group starts.
22:44:58 <tieTYT2> dmwit: i see, i was not aware of that
22:45:22 <tieTYT2> ok, that's a really complex function IMO
22:45:27 <roconnor> it turned up oebb.at (searching for .at sites)
22:45:30 <roconnor> seems right.
22:45:31 <tieTYT2> well the rules of it
22:45:39 <tieTYT2> i'll try to impl it now
22:45:48 <dmwit> tieTYT2: It's very simple, provided the function you supply is an equivalence relation. ;-)
22:46:08 <tieTYT2> what's an equivalence relation besides ==?
22:46:22 * roconnor tries reading german
22:46:22 <Elly> equal mod N
22:46:30 <dmwit> Any relation that's transitive and complete.
22:46:31 <Korollary> roconnor: Try Bourbaki in -blah
22:46:31 <Elly> 'within epsilon of each other'
22:46:32 <tieTYT2> you mean like <,>,/=,...
22:46:38 <Elly> also known as floating-point equivalence :)
22:46:46 <dmwit> (<) and (>) are *not* equivalence relations.
22:46:53 <bos> @hoogle throwDyn
22:46:53 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
22:46:53 <lambdabot> Control.Exception.throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
22:46:56 <dmwit> Neither is (/=).
22:47:07 <Elly> for vectors, identical inner product could be an equivalence relation
22:47:28 <Korollary> membership in partitions of a set
22:47:29 <koninkje> structural equivalence of trees/dags/graphs
22:47:33 <dmwit> Oops, I meant transitive and reflexive, sorry.
22:48:21 <dmwit> tieTYT2: Do you know the formal meaning of relation?
22:48:32 <dmwit> (Have you seen relations represented as graphs?)
22:49:53 <tieTYT2> i'm not sure
22:50:05 <tieTYT2> i can't remember if i've learned that or not
22:50:16 <dmwit> Do you want to?
22:50:33 <tieTYT2> yeah
22:50:36 <dmwit> Okay.
22:50:58 <dmwit> Given a set S, a relation is a set of pairs (a, b) in S x S.
22:51:22 <dmwit> Usually we call the relation R, and we say aRb if (a, b) is in R.
22:51:24 <tieTYT2> what's S x S mean?
22:51:29 <dmwit> The cartesian product.
22:51:30 <quicksilver> (S , S)
22:51:35 <quicksilver> in haskell notation
22:51:35 <Elly> pairs of elements from S
22:51:36 <dmwit> i.e. tuples, in Haskell.
22:51:51 <Elly> (it's exactly the same as cross product)
22:52:06 <dmwit> The important bit is that they are *ordered* pairs, so (a, b) and (b, a) are not necessarily the same.
22:52:09 <dmwit> Good so far?
22:52:25 <tieTYT2> if i ignore small details in the middle, yes :)
22:52:32 <dmwit> Which details?
22:52:42 <dmwit> (You need to get this part, because everything builds on this. =)
22:52:46 <visof> is there any one using ghc6.8.2 under netbsd?
22:53:19 <tieTYT2> ok i think i get it
22:53:22 <dmwit> ok
22:53:53 <dmwit> So, you know a whole bunch of relations; (<) can be thought of as a relation, for example.
22:54:05 <dmwit> So can (==).
22:54:06 <tieTYT2> a<b
22:54:21 <Elly> you would say "(a, b) is in <" if a < b
22:54:22 <dmwit> Right, so "a<b" means (a, b) is in the relation (<).
22:54:37 <Elly> since < is the set of all pairs (a,b) such that a < b
22:54:45 <dmwit> Note that (b, a) is not in (<).
22:54:59 <tieTYT2> iff (a,b) is, that is
22:55:02 <tieTYT2> right?
22:55:04 <dmwit> If you have this property: "(a, b) in R implies (b, a) in R", then R is called "reflexive".
22:55:10 <dmwit> tieTYT2: right
22:55:19 <tieTYT2> ok gotcha
22:55:27 <tieTYT2> yeah i've learned this stuff before, i just forgot it
22:55:33 <dmwit> Yup. =)
22:55:38 <quicksilver> that's actually called "symmetric"
22:55:39 <dmwit> Here's the transitive property:
22:55:47 <dmwit> quicksilver: Oh, you're right.
22:55:52 <quicksilver> "reflexive" is the property "for all a, (a,a) is in R"
22:55:54 <quicksilver> ;)
22:55:58 <dmwit> right
22:56:07 <quicksilver> You want them both and also transitive which dmwit is just about to explain.
22:56:19 <tieTYT2> so is == reflexive then?
22:56:22 <dmwit> Okay, "transitive" means "if (a, b) is in R and (b, c) is in R, then (a, c) is in R".
22:56:26 <dmwit> tieTYT2: yes
22:56:41 <tieTYT2> nothing else really comes to mind as reflexive
22:56:45 <tieTYT2> ok i understand transitive
22:56:48 <dmwit> Okay.
22:57:01 <dmwit> Equivalence relations are reflexive, transitive, and symmetric.
22:57:13 <koninkje> tieTYT2: the identity relation is also reflexive
22:57:27 <dmwit> tieTYT2: It can also be interesting to think of these things in terms of graphs.
22:58:07 <dmwit> tieTYT2: So, you can picture a relation R on the set S as such: each element of S is a node, and each pair (a, b) in R is an (directed) edge from a to b.
22:58:35 <dmwit> Take a second to think about that, then try to tell me what each of the three properties mean in terms of relation graphs.
22:59:21 <koninkje> tieTYT2: (Though the distinction between "identity" and "equality" depends on the domain, e.g. nodes in a graph could be considered "equal" if they have the same label, but they won't be identical unless they are indeed the same node. For integers there isn't really a difference)
23:00:29 <tieTYT2> hm, to me i would think that symmetric would be a line at a 45 degree angle
23:00:40 <dmwit> oh, hm
23:00:51 <dmwit> Maybe I didn't explain the graph thing properly. =P
23:00:54 <jsnx> so, i wonder what kind of mathematical object Ptr is
23:01:18 <Saizan> tieTYT2: not graph as in calculus
23:01:23 <dmwit> tieTYT2: The sense of "graph" isn't like "graphing a function".
23:01:24 <jsnx> it's not a Functor, since Ptr(id(X)) /= id(Ptr(X))
23:01:37 <dmwit> tieTYT2: I'm talking about the discrete-math kind of graph, which has nodes and edges.
23:02:07 <tieTYT2> well i think that'll take a whole other lesson
23:02:11 <tieTYT2> as i've also forgot all that stuff
23:02:38 <Elly> they are a tuple of sets (N, E), which are respectively sets of nodes and sets of edges
23:02:40 <dmwit> Well, ok.
23:03:02 <dmwit> tieTYT2: You have to tell us when you're saturated.
23:03:10 <dmwit> We love this stuff, we could talk all day if you let us. =)
23:03:15 <tieTYT2> hah
23:03:23 <Elly> yeah, discrete math is ridiculously beautiful
23:03:25 <tieTYT2> ok well i got it until this point i think
23:03:31 <dmwit> Okay, let's talk graphs!
23:03:49 <tieTYT2> i just forgot descrete mathematics
23:03:50 <quicksilver> jsnx: right, similarly IORef and STRef and MVar are not functors
23:04:01 <dmwit> tieTYT2: http://en.wikipedia.org/wiki/Image:Directed.svg  Here's a graph.
23:04:13 <tieTYT2> oh
23:04:17 <tieTYT2> ok that's easier than i thought
23:04:20 <dmwit> yeah =)
23:04:26 <tieTYT2> i thought you were talking about the elongated F
23:04:29 <Elly> it is simpler than the formal definition makes it sound
23:04:30 <tieTYT2> or f rather
23:04:38 <tieTYT2> ok i'd consider that transitive
23:04:45 <Elly> tieTYT2: try writing a Haskell graph type :P
23:05:00 <dmwit> tieTYT2: It's not transitive.
23:05:21 <tieTYT2> dmwit: no?
23:05:21 <dmwit> tieTYT2: Let the nodes be TL (top left), TR (top right), B.
23:05:30 <tieTYT2> ok
23:05:34 <dmwit> tieTYT2: TR -> B -> TL, but TR -/> TL
23:06:05 <tieTYT2> so it needs arrows in opposite directions?
23:06:13 <tieTYT2> also in opposite, that is
23:06:17 <dmwit> It needs arrows in both directions.
23:06:21 <dmwit> But let's go one step at a time.
23:07:04 <dmwit> Do you now see how to represent relations as graphs?
23:07:19 <tieTYT2> that one, at least
23:07:26 <dmwit> Each node is an element of the underlying set, and an edge from a to b means aRb.
23:07:30 <tieTYT2> would reflective be one node and an edge to itself?
23:07:37 <tieTYT2> sorry
23:07:40 <tieTYT2> symmettrical
23:07:51 <dmwit> Reflexive means xRx, for all x.
23:07:51 <Elly> reflexive is indeed a node with an edge to itself
23:08:06 <dmwit> So, reflexive graphs indeed have self-edges on every node.
23:08:06 <tieTYT2> Elly: i meant symmetric, actually
23:08:11 <dmwit> Can you see what symmetric means?
23:08:22 <dmwit> tieTYT2: No, symmetric does not imply self edges.
23:08:32 <dmwit> tieTYT2: Remember, symmetric means aRb implies bRa.
23:08:40 <dmwit> Can you see what that would mean for a graph?
23:08:52 <tieTYT2> oh i got confused
23:08:59 <tieTYT2> i thought that's what reflective meant
23:09:12 <dmwit> That's what I said at first, but I was wrong. =)
23:09:20 <tieTYT2> dayam, well that'll be hard to remember now
23:09:21 <dmwit> (I always get these names mixed up, too.)
23:09:21 <tieTYT2> anyway
23:09:33 <tieTYT2> symmetric means two nodes both pointing to each other
23:09:42 <dmwit> Well, be a little careful.
23:09:58 <dmwit> It sounds like you're saying no relation on a set of three items can be symmetric, which isn't true.
23:10:30 <dmwit> i.e. the graph of a symmetric relation need not be restricted to only two nodes
23:10:46 <tieTYT2> so all nodes point to each other?
23:10:54 <tieTYT2> can't you say the same about transitive?
23:10:58 <dmwit> That's not quite required, either.
23:11:02 <tieTYT2> transitive isn't restricted to 3
23:11:09 <dmwit> Here's the thing:
23:11:39 <dmwit> We require that aRb implies bRa, but we don't require aRb in the first place.  aRb could be false for some a, b.
23:12:36 <tieTYT2> ok
23:12:44 <tieTYT2> just like b<a earlier
23:12:49 <tieTYT2> but i don't know how to represent that rule
23:13:01 <Elly> well
23:13:04 <dmwit> It's tricky. =)
23:13:07 <tieTYT2> is that where a "for all a,b..." terminology is used?
23:13:10 <dmwit> How about an example, maybe?
23:13:17 <Elly> if aRb, what does that tell you about the nodes representing a and b?
23:13:52 <tieTYT2> um that bRa too?
23:13:57 <roconnor> @seen anyone from austria
23:13:57 <lambdabot> I haven't seen anyone.
23:14:04 <Elly> good, but what does that mean about the graph?
23:14:13 <Elly> what is true about the graph if aRb?
23:14:26 <mxc> for sending values across a network between two haskell processes, is the only way to encode with Data.Binary and send the ByteStrings?
23:14:49 <dmwit> mxc: That's probably the simplest way.
23:14:52 <sjanssen> mxc: that certainly isn't the only way
23:15:00 <sjanssen> mxc: Read/Show is probably the simplest
23:15:13 <tieTYT2> i donno, besides what i said earlier
23:15:13 <sjanssen> but you'll hit a wall wrt. performance
23:15:19 <mxc> well, speed is not super critical but is important
23:15:34 <dmwit> tieTYT2: Let's ignore reflexivity for now.  What does aRb mean in a graph?
23:15:36 <mxc> yeah, data.binary should be much faster, i would think
23:15:44 <tieTYT2> o->o ?
23:15:52 <dmwit> Right, a->b.
23:15:52 <Elly> put names on those
23:15:53 <tieTYT2> where o is a node, -> is an edge
23:15:58 <tieTYT2> ok
23:15:59 <Elly> yep
23:16:02 <dmwit> tieTYT2: Oh, but these are *specific* nodes.
23:16:07 <tieTYT2> also b -> a
23:16:09 <dmwit> tieTYT2: Maybe this is the bit that's confusing you.
23:16:12 <dmwit> tieTYT2: Yes, exactly!
23:16:15 <Elly> so if aRb means a -> b in the graph, and aRb <=> bRa
23:16:16 <Elly> yep :)
23:16:18 <tieTYT2> i thoguth i already said that
23:16:19 <mxc> next question, in doing this, it seems that with every message I would need to manually count the number of bytes in the encoded data and send that number in the message header so that the receiver knows when the message ends, is that basically true?
23:16:28 <tieTYT2> that for 2 nodes, the arrows point to each other
23:16:36 <tieTYT2> what was wrong with that?  That i didn't label them?
23:16:40 <sjanssen> mxc: yes, you'll need to do something like this
23:16:59 <dmwit> tieTYT2: No, the problem is that you're implying exactly two nodes in the graph, and you're implying exactly two edges in the graph.
23:17:14 <dmwit> tieTYT2: But you could have two nodes and no edges, or some other number of nodes, or ...
23:17:41 <tieTYT2> why is two nodes and no edges allowed?
23:17:41 <sjanssen> mxc: or perhaps you can do something clever with lazy IO
23:17:52 <tieTYT2> i thought you said that aRb does not have to be true
23:17:55 <dmwit> tieTYT2: Well, call the two nodes a and b, as before.
23:17:57 <mxc> sjanssen: but i'm not clever
23:18:04 <dmwit> tieTYT2: Exactly. aRb is false, and bRa is false.
23:18:08 <dmwit> tieTYT2: So there are no edges.
23:18:24 <tieTYT2> that's reflective?
23:18:27 <dmwit> yes
23:18:29 <dmwit> recall:
23:18:35 <dmwit> "aRb implies bRa"
23:18:46 <dmwit> Since "aRb" is false for every pair, that statement is true for every pair.
23:18:52 <mxc> sjannsen: also intend to use UDP broadcast, so i wouldn't really have access to the IO handles, just Network.sendTo
23:19:08 <dmwit> (Because "false implies x" is true for x = false or x = true.)
23:19:17 <Elly> whee, false implies everything :)
23:19:24 <sjanssen> mxc: length prefixed is probably smartest, then.  Hopefully your packets are small-ish?
23:19:28 <mxc> actually, i just broadcasted my ignorance of haskell networking
23:19:30 <dmwit> "false implies unicorns exist"
23:19:44 <tieTYT2> that confused me :P
23:19:47 <dmwit> It might make more sense to say it this way:
23:19:54 <mxc> sjanssen: avg size probably < 1k
23:19:57 <mxc> 1KB
23:20:00 <dmwit> "(It is raining and it is not raining) implies  (unicorns exist)."
23:20:17 <dmwit> tieTYT2: Since it is never true that it is both raining and not raining, it doesn't matter what we say on the right.
23:20:28 <mxc> though, for perfomance, will probably pool messages, so it will be completely under my control
23:20:37 <tieTYT2> ok, i still don't get what that has to do with reflectivity
23:20:44 <tieTYT2> cause you can flip the sides?
23:21:06 <dmwit> Reflexivity says that for all possible pairs (a,b), if aRb then bRa.
23:21:22 <conal> new blog post: "Functional linear maps", http://reddit.com/goto?id=6m0e3
23:21:22 <lambdabot> Title:
23:21:27 <dmwit> Now, if for all possible pairs aRb is false, then reflexivity holds in a kind of trivial, uninteresting way.
23:21:40 <tieTYT2> i see
23:21:54 <dmwit> If we graphed such a relation, it would be a bunch of nodes with no edges.
23:21:55 <tieTYT2> but wouldn't that mean the nodes would have lines to each other?
23:22:00 <Elly> dmwit: false implies false seems somewhat tangential here :P
23:22:09 <conal> i tweaked the intro since planet.haskell picked it up.  hopefully will refresh.
23:22:20 <dmwit> tieTYT2: No, there's no lines, since there's no pairs in the relation R.
23:22:47 <tieTYT2> hm
23:23:11 <dmwit> tieTYT2: Let S={1, 2, 3}, R={} the empty relation.
23:23:14 <tieTYT2> ok well to sum it up, the graph will have a->b and b->a or just a b?
23:23:25 <dmwit> tieTYT2: yes
23:23:47 <dmwit> tieTYT2: We sometimes call this an "undirected" graph.
23:24:03 <dmwit> tieTYT2: So called because for each pair, you either have an arrow both ways, or you have no arrow at all.
23:24:16 <tieTYT2> ok
23:24:36 <dmwit> Okay, so we have: symmetry (self-loops) and reflexivity (undirected graphs).
23:24:41 <dmwit> Are you ready to try transitivity?
23:24:47 <dmwit> This is the trickiest one. =)
23:25:16 <dmwit> (On a side note: here's an example of an undirected graph: http://en.wikipedia.org/wiki/Image:6n-graf.svg )
23:25:16 <lambdabot> Title: Image:6n-graf.svg - Wikipedia, the free encyclopedia
23:25:31 <Saizan> wasn't the naked writer monad in base?
23:25:39 <tieTYT2> if a=b and b=c and you know a=c, does that mean that c=a?
23:25:50 <dmwit> Only if you have reflexivity.
23:25:55 <dmwit> Not all relations have reflexivity.
23:26:07 <dmwit> (<=) is a great example where reflexivity fails.
23:26:08 <tieTYT2> ok
23:26:25 <tieTYT2> so then i'd expect this to be transitive: http://en.wikipedia.org/wiki/Image:Directed.svg
23:26:28 <tieTYT2> oh wait
23:26:44 <dmwit> Not quite. =)
23:26:48 <Saizan> dmwit: you keep confusing reflexivity and simmetry :)
23:27:00 <dmwit> augh
23:27:17 <dmwit> Where did I do it this time?
23:27:19 <tieTYT2> a->b b->c a->c
23:27:24 <quicksilver> Saizan: it's in mtl; if you consider mtl base then yes ;)
23:27:39 <quicksilver> < dmwit> (<=) is a great example where reflexivity fails.
23:27:44 <dmwit> yeah
23:27:46 <dmwit> crap
23:27:51 <quicksilver> (<=) is reflexive but not symmetric :)
23:27:54 <dmwit> No wonder tieTYT2 is getting confused. =P
23:28:06 <dmwit> I should really hand this explanation off to somebody else.
23:28:19 <dmwit> tieTYT2: right
23:28:25 <tieTYT2> dmwit: why is that the hardest?
23:28:31 <dmwit> tieTYT2: It's hard to formulate a concise description of what this means in a graph.
23:28:35 <mxc> :%s/simmetry/symmetry
23:28:52 <tieTYT2> seems like a shortcut to me
23:28:56 <dmwit> Exactly!
23:28:56 <tieTYT2> from a to c
23:29:04 <tieTYT2> when you can also go from a to b to c
23:29:20 <dmwit> tieTYT2: Basically, if any "path" from a to z exists, then there is an edge a -> z.
23:29:58 <tieTYT2> can someone redefine symmetric and reflective so I know which is which?
23:30:04 * dmwit stays silent
23:30:34 <jkff> Reflective: x R x. Symmetric: x R y && y R x ==> x == y. Transitive: If two vertices are reachable, they are connected by an edge
23:30:42 <jkff> Oh
23:30:47 <jkff> Symmetric: x R y ==> y R x
23:30:51 <dmwit> ?slap jkff
23:30:51 * lambdabot secretly deletes jkff's source code
23:31:21 <jkff> Hmm?
23:31:27 <tieTYT2> i see
23:31:38 <tieTYT2> i'd think the exact opposite about those two
23:31:49 <dmwit> As jkff alluded to, there are many other possible properties that are interesting.
23:31:50 <tieTYT2> actually nm
23:31:52 <tieTYT2> makes sense
23:32:05 <jkff> You can understand reflective as an actual reflection: x R x , x 'reflects' in the mirror of R
23:32:19 <dmwit> :%s/reflective/reflexive/g
23:32:22 <jkff> Yep
23:32:36 <dmwit> Okay.
23:32:42 <dmwit> Are you ready for the final jump?
23:32:48 <quicksilver> alternatively, a relation is reflexive it if "contains" the equality relation.
23:33:08 <dmwit> Equivalence relations are ones with reflexivity, symmetry, and transitivity.
23:33:23 <tieTYT2> ok
23:33:26 <dmwit> 30 bonus points if you can figure out what that means in the graph representation before somebody else here shouts it out.
23:33:33 <dmwit> =)
23:33:43 * jkff shuts his mouth with his hands
23:34:45 <Elly> :P
23:34:50 <tieTYT2> i donno, is it like the transitive one where every node points to itself and it's unidirectional?
23:34:57 <dmwit> Anybody with a capital letter in their nick who doesn't mind me testing something real quick?
23:35:02 <Elly> "like" how?
23:35:06 <Elly> dmwit: go for it
23:35:08 <Pseudonym> Depends what it is.
23:35:12 <Pseudonym> Otherwise, go for it.
23:35:20 <dmwit> Elly: Thanks, done.
23:35:22 <tieTYT2> i'm not sure how to describe it
23:35:28 <Elly> I didn't see anything
23:35:30 <jkff> Ok: Equivalence is just connectivity in an undirected graph, that's all
23:35:44 <Elly> jkff: hey!
23:35:45 <tieTYT2> what's connectivity?
23:35:50 <jkff> Reachability
23:35:59 <jkff> Existence of a path
23:36:06 <tieTYT2> it doesn't have to point to itself?
23:36:14 <dmwit> Each node must point to itself.
23:36:19 <dmwit> In addition:
23:36:39 <dmwit> You can "partition" the graph into smaller sets, where each node in a smaller set points to *all* the other nodes in the smaller set.
23:37:02 <tieTYT2> directly or indirectly?
23:37:05 <jkff> So, a graph is an equivalence relation if it consists of several disjoint cliques (complete graphs) with self-loops
23:37:11 <dmwit> tieTYT2: directly
23:37:24 <dmwit> tieTYT2: If they point to each other indirectly, transitivity gives them a direct pointer.
23:37:33 <tieTYT2> ah
23:37:43 <tieTYT2> ok so for every node there's a connection to itself and every other node
23:37:52 <jkff> Every other _equivalent_ node
23:37:53 <dmwit> Every other node *within its clique*.
23:38:11 <tieTYT2> what's the a clique?
23:38:15 <tieTYT2> a subset?
23:38:18 <Elly> mmm, k-cliques
23:38:25 <Elly> tieTYT2: a set of nodes, all of which are connected to each other
23:38:42 <Elly> a subgraph which is completely connected
23:38:45 <tieTYT2> why did you need to bring up the clique?
23:38:56 <dmwit> It's jargon.
23:39:03 <Elly> because dmwit couldn't help himself, I suspect :P
23:39:10 <Elly> graph theory will do that to you
23:39:23 <tieTYT2> if the clique follows those rules, but another subset doesn't, doesn't that mean you don't have equivalence between the two?
23:39:24 <dmwit> tieTYT2: The point is, not every node in the graph points to every other node.
23:39:29 <tieTYT2> oh
23:39:48 <tieTYT2> i don't get why not
23:39:49 <dmwit> tieTYT2: Only nodes within a "region" (or "clique" ;-) need to point to each other.
23:39:52 <jkff> If every node points to every other node, that means that they are all equivalent to each other
23:40:08 <dmwit> tieTYT2: For example, consider the equivalence relation 1<->2, 3<->4.
23:40:20 <dmwit> tieTYT2: 1 and 2 form a clique, as do 3 and 4.
23:40:32 <dmwit> tieTYT2: There are no edges from 1 to 3, yet this is still an equivalence relation.
23:40:46 <tieTYT2> 1 to 3 is an equivalence relation?
23:40:47 <dmwit> (Assume self edges, which are too hard to draw in ASCII graphics. =)
23:40:53 <dmwit> tieTYT2: no
23:41:07 <tieTYT2> ok so you have two equivalence relations
23:41:08 <Elly> the whole set {(1, 2), (3, 4)} is an equivalence relation
23:41:15 <dmwit> Elly: no it isn't
23:41:25 <Elly> why not?
23:41:37 <Elly> earlier we were talking about things being in equivalence relations
23:41:38 <dmwit> {(1, 2), (2, 1), (3, 4), (4, 3), (1, 1), (2, 2), (3, 3), (4, 4)} is an equivalence relation
23:41:39 <jkff> Suppose you have a set of villages and some villages are connected by roads. If two villages are reachable from each other, then sooner or later they build a direct road.
23:41:40 <jkff>  Also, sonner or later they start to speak the same language. Then what you end up with is a graph of villages depicting the equivalence relation 'speak the same language'.
23:41:42 <Elly> to have something in it it has to be a set
23:41:54 <Elly> dmwit: I made the other things implicit :P
23:42:19 <dmwit> Elly: I think that's confusing until the terms are understood. ;-)
23:42:25 <Elly> okay, fair enough
23:42:30 <Elly> mental compression occured
23:42:46 <dmwit> tieTYT2: Okay.  So.  In case not enough people are talking at you right now.
23:43:14 <dmwit> tieTYT2: I'm going back to the graph 1 <-> 2  3 <-> 4.  (The full set of the corresponding equivalence relation is above.)
23:43:15 <tieTYT2> why is that an equivalence relation when there's no connection from 2 to 3?
23:43:35 <dmwit> tieTYT2: Which of the properties suggests that there should be a 2->3 edge?
23:43:48 <tieTYT2> none but you said it's _an_ equivalence relation
23:43:53 <dmwit> It is.
23:44:03 <tieTYT2> i espected you to say _two_ equivalence relations
23:44:03 <dmwit> It is a relation, and it satisfies the three properties.
23:44:10 <tieTYT2> expected
23:44:11 <jkff> Equivalence relation is not when *everyone* is equivalent, it is a relation that depicts a sensible notion of equivalence. Some things are equivalent to each other, some are not
23:44:13 <dmwit> No, it is a single equivalence relation.
23:44:22 <Elly> tieTYT2: the whole graph is an equivalence relatio
23:44:26 <dmwit> Right, jkff said it well.
23:44:42 <dmwit> tieTYT2: This equivalence relation defines two equivalence classes, which may be what you are thinking of.
23:44:46 <dmwit> (More jargon.)
23:44:51 <jkff> But if A is equivalent to B and B is equivalent to C, then A should be equivalent to C; also everyone should be equivalent to himself, and if A eq B, then B eq A. That's rather sensible.
23:44:55 <tieTYT2> ok
23:44:59 <tieTYT2> so i think my terminology is off
23:45:06 <dmwit> ("Equivalence classes" are the set-theory version of the "cliques" from graph theory.)
23:45:09 <tieTYT2> but hopefully i understand the importance of the discussion
23:45:21 <jkff> btw, what did the discussion start with?
23:45:26 <dmwit> jkff: groupBy
23:45:27 * tieTYT2 can't remember
23:45:29 <tieTYT2> oh right
23:45:50 <dmwit> If any of the three properties is off, groupBy can act strangely. =)
23:47:21 <dmwit> > groupBy (<) [8,8,8] -- if we don't have symmetry, things won't be grouped with themselves
23:47:22 <lambdabot>  [[8],[8],[8]]
23:47:51 <jkff> The whole point of equivalence is indistinguishibility in some sense. You can'd distinguish anyone from himself (reflexivity), if you can't distinguish A from B, then neither can you B from A (symmetry), and in a similar fashion one can interpret transitivity
23:47:51 <dmwit> > (groupBy (<) [10,9,8], groupBy (<) [8,9,10]) -- if we don't have reflexivity, permuting a single group can give a different result
23:47:52 <lambdabot>  ([[10],[9],[8]],[[8,9,10]])
23:47:59 <jkff> Transitivity is the trickiest one
23:48:06 <jkff> And the least sensible
23:48:16 <dmwit> "least sensible"?
23:48:24 <jkff> For example, you can think that two numbers are indistinguishable if they differ by less than 0.01
23:48:35 <jkff> This looks sensible but does not possess transitivity
23:48:47 <dmwit> Damn it, I switched reflexive and symmetric again.
23:48:47 <Elly> hrm
23:48:57 <Elly> so I was wrong about "within epsilon" being an equivalence relation, then
23:49:24 <jkff> Because |1.006 - 1| < 0.01, |0.991 - 0.1| < 0.01, but |1.006 - 0.991| > 0.01
23:50:13 <dmwit> ?let nonTransitive x y = ((x + 2) `mod` 4) /= (y `mod` 4)
23:50:15 <lambdabot> Defined.
23:50:51 <dmwit> > (groupBy nonTransitive [1,2,3], groupBy nonTransitive [1,3,2])
23:50:52 <lambdabot>  ([[1,2],[3]],[[1],[3,2]])
23:51:10 <dmwit> So again, permuting a single "group" can give different results.
23:52:33 <Saizan> dmwit: if you permute the input list groupBy gives different results even with an equivalence relation
23:52:43 <dmwit> Well, up to ordering within groups.
23:53:03 <dmwit> well...
23:53:08 <dmwit> Okay, here's what I want to say:
23:53:22 <dmwit> hum
23:53:29 <dmwit> It's tricky to express this. =)
23:54:26 <dmwit> But at the very least, things should be grouped with themselves, and permuting the order of a sequence of things that were grouped together should at worst permute the group they were in.
23:54:45 <Saizan> > groupBy (\x y -> x `mod` 3 == y `mod 3) [0,1,3]
23:54:45 <lambdabot>  Parse error at "3)" (column 38)
23:54:57 <Saizan> > groupBy (\x y -> x `mod` 3 == y `mod` 3) [0,1,3]
23:55:05 <lambdabot>  [[0],[1],[3]]
23:55:14 <Saizan> > groupBy (\x y -> x `mod` 3 == y `mod` 3) [0,3,1]
23:55:15 <lambdabot>  [[0,3],[1]]
23:55:31 <dmwit> right
23:55:37 <dmwit> But the property I stated holds.
23:55:47 <dmwit> (That last property, there.)
23:55:56 <dmwit> Whereas with non-equivalence-relations, it does not.
23:56:59 <Saizan> ah, yeah, permuting the subsequences won't matter
23:57:28 <dmwit> Incidentally, it is kind of a fun exercise to come up with a relation that is reflexive and symmetric, but not transitive.
23:58:13 <jkff> groupBy doesn't seem like a very good example for explaining equivalence relations, which are inherently orderless, because groupBy works on a list, not on a set, and it can't be used to see which items in the list are equivalent. dmwit, I gave such an example shortly above :)
23:58:36 <dmwit> I agree, groupBy is a bad example.
23:58:49 <jkff> However if the OP's original question was what is the first argument of groupBy, then we can't avoid it :)
23:58:51 <dmwit> It went the other way, actually: we were discussing groupBy, and *then* equivalence relations came up
23:58:55 <jkff> I see
23:59:04 <dmwit> Incidentally, what was the example you gave?
23:59:28 <jkff> The 'within epsilon' relation on numbers
23:59:37 <dmwit> But that's not an equivalence relation.
23:59:44 <Elly> we know :P
23:59:45 <jkff> Yes, but you didn't ask for one
23:59:53 <dmwit> oh
