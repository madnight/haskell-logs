00:00:04 <Eldanen> Hiya.
00:02:32 <quicksilver> carl: you need --make
00:04:43 <nornagon> hi carl :P
00:06:25 <mjrosenb> is there a good web page that gives what do-notation desugars into?
00:06:40 <Korollary> mjrosenb: The report has it
00:07:12 * mjrosenb remembers the report being quite dense
00:07:20 <Korollary> It's probably in the syntax section
00:08:25 <Korollary> http://haskell.org/onlinereport/exps.html#sect3.14
00:08:25 <lambdabot> Title: The Haskell 98 Report: Expressions
00:15:07 <mjrosenb> ok, it appears that just the do-notation from monads can't do what i want it to do
00:15:14 * mjrosenb checks out arrows
00:15:48 <ejt> mjrosenb: what do you want it to do ?
00:15:52 <Korollary> Not that I know arrows, but they may not be what you're looking for.
00:15:59 <ivanm> ejt: he wants magic! :p
00:16:14 <Eldanen> abaracadabra!
00:16:19 <ivanm> @hoogle [a] -> [a] -> [a]
00:16:20 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
00:16:20 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
00:16:20 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
00:16:31 <ivanm> hmmm.... is there a list intersection function?
00:17:06 <glguy> :t intersection
00:17:06 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
00:17:07 <lambdabot> Not in scope: `intersection'
00:17:11 <glguy> :t intersect
00:17:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
00:17:12 <ivanm> @hoogle inter
00:17:13 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
00:17:13 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
00:17:13 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
00:17:13 <dolio> @hoogle intersect
00:17:14 <lambdabot> Data.List.intersect :: Eq a => [a] -> [a] -> [a]
00:17:14 <lambdabot> Data.List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
00:17:16 <lambdabot> Data.Set.intersection :: Ord a => Set a -> Set a -> Set a
00:17:27 <ivanm> yay!
00:17:46 <glguy> Why the hell do I keep getting the same message!?!
00:17:53 <glguy> X-(
00:18:03 <ivanm> glguy: because lambdabot's state never gets saved after you read it?
00:18:04 <mjrosenb> i basically want to have some data that is invisibly passed to every function that I, and silently returned from every function
00:18:33 <glguy> ivanm: lambdabot's state hasn't been saved since last month
00:18:34 <ejt> mjrosenb: State monad
00:18:37 <glguy> it would seem
00:18:38 <ivanm> heh
00:18:52 <Korollary> glguy: 12:00 ... 12:00 ... 12:000
00:19:07 <ivanm> on a slightly different note... what would be better? filter (\ x -> x `elem` xs) or using a fold to create a membership function from the xs list?
00:19:12 <glguy>  davidL asked 26d 6h 54m 40s ago: â€¦
00:19:23 <glguy> that's old state
00:19:23 <mjrosenb> ejt: right, but i dont' think the state monad would really be apropriate, since i'm just removing elements from a list
00:19:39 <Korollary> ivanm: Would Data.Set be a better fit (you speak of membership ...)
00:20:17 <ejt> mjrosenb: I'm out of ideas then
00:20:24 <ivanm> Korollary: I'm using lists, and converting both to sets and back would probably not be worth it
00:20:38 <quicksilver> mjrosenb: sounds like the 'Supply' monad then
00:20:38 <ivanm> especially since the testing list probably wouldn't be that big anyway
00:20:49 <quicksilver> mjrosenb: which is a state monad treated as an pop-only stack.
00:21:59 <mjrosenb> quicksilver: sounds sexy
00:22:57 * ivanm is coming up against problems using FGL where all query functions return lists of nodes rather than the actual subgraphs in question
00:24:33 <mjrosenb> hrmm, supply isn't in the standard library
00:24:41 <davidL> glguy: :)
00:27:05 <ivanm> @pl \(p,n,a,s) -> (f p, n, a, f s)
00:27:05 <lambdabot> (line 1, column 6):
00:27:05 <lambdabot> unexpected ","
00:27:05 <lambdabot> expecting letter or digit, operator or ")"
00:27:05 <lambdabot> ambiguous use of a non associative operator
00:27:12 <ivanm> why doesn't @pl like this?
00:29:27 <Korollary> @pl \(p,n) -> (p,n)
00:29:27 <lambdabot> id
00:29:32 <Korollary> @pl \(p,n) -> (f p,n)
00:29:32 <lambdabot> first f
00:29:44 <Korollary> @pl \(p,n,a) -> (f p,n, a)
00:29:44 <lambdabot> (line 1, column 6):
00:29:44 <lambdabot> unexpected ","
00:29:44 <lambdabot> expecting letter or digit, operator or ")"
00:29:44 <lambdabot> ambiguous use of a non associative operator
00:29:48 <Korollary> odd
00:30:06 <Korollary> heh
00:30:24 <mjrosenb> it looks like that's coming from the pattern
00:30:36 <ivanm> looks like it only likes pairs, not general n-tuples
00:34:12 <roconnor> @hoogle withEnv
00:34:13 <lambdabot> No matches found
00:34:16 <roconnor> @hoogle with
00:34:16 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
00:34:16 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
00:34:16 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
00:34:23 <roconnor> @hoogle Reader
00:34:23 <lambdabot> Control.Arrow.Transformer.Reader :: module
00:34:24 <lambdabot> Control.Monad.Reader :: module
00:34:24 <lambdabot> Control.Monad.Reader.Reader :: newtype Reader r a
00:34:53 <roconnor> @hoogle (r->r) -> Reader r a -> Reader r a
00:34:53 <lambdabot> Control.Monad.Reader.withReader :: (r' -> r) -> Reader r a -> Reader r' a
00:38:15 <quicksilver> @go monadsupply
00:38:16 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
00:38:16 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
00:38:20 <quicksilver> mjrosenb: ^^
00:39:24 <mjrosenb> quicksilver: so i just take that code, and add it into my project?
00:40:00 <wjt> class MonadSupply isn't actually defined there afaict
00:40:38 <mjrosenb> it seems like it is
00:41:24 * mjrosenb should find out how the state monad works first
00:50:16 <mjrosenb> hrmm, methinks higher order functions could make this quite easy
00:50:25 <mjrosenb> and probably quite inefficient
00:51:44 <wjt> hmm, yeah, more like I can't read.
00:51:59 <mjrosenb> still don't think i'll be using it
00:52:11 <mjrosenb> unless performance dies using higher order functions
00:53:29 <mjrosenb> :(
00:53:45 <mjrosenb> so i have the basic idea for this monad down
00:53:59 <mjrosenb> so I'm calling it monad BinParse
00:54:06 <mjrosenb> and i went to implement it
00:54:27 <mjrosenb> and i thought Oh, the BinParse monad could do this really easily
00:56:36 <mjrosenb> hrmm, i don't like the proliferation of constructors, but i'd imagine those can be dealt with
01:25:18 * mjrosenb seems to be confused about instantiating type classes again
01:25:25 <mjrosenb> if i have a class BitReader
01:25:51 <mjrosenb> why can i not say instance Num a => BitReader a where...
01:30:14 <opqdonut> well you can
01:30:24 <opqdonut> but that'll conflict with all other instances of BitReader
01:30:34 <opqdonut> you see, the class constraint doesn't really count
01:30:51 <mjrosenb> i see
01:30:58 <mjrosenb> that's most unfortunate
01:31:02 <opqdonut> the semantics of "instance Num a => BitReader a where" is "here's an instance of BitReader for _all types_ a (but it'll work only for (Num a))
01:31:06 <opqdonut> "
01:31:08 <opqdonut> yeah it is
01:31:24 <opqdonut> but you can work around that by using, iirc, UndecideableInstances
01:31:36 <opqdonut> that'll make ghc choose the most specific instance available
01:32:24 <mjrosenb> so I'll have to use a newtype and say instance Num a => BitReader (BitRead a)
01:32:52 <opqdonut> mm, OverlappingInstances was the right one sorry
01:32:59 <mjrosenb> that's more annoying than it seems
01:33:02 <opqdonut> yeah, or use a newtype if you want to stay H98
01:33:17 * mjrosenb enjoys H98
01:33:28 <opqdonut> :)
01:33:47 <opqdonut> the class instance restrictions in H98 are its most bothersome feature
01:33:47 <opqdonut> IMO
01:34:02 <mjrosenb> agreed
01:34:36 <mjrosenb> like, these numbers are supposed to be directly fed into another function that really can't have the wrappers
01:34:56 <opqdonut> yeah, you'll have to fmap or something
01:35:17 <mjrosenb> eww
01:41:18 <mjrosenb> ok, this works
01:41:28 <mjrosenb> and i have NO CLUE how or why it works
01:41:38 <mjrosenb> i just made all of the types match up
01:41:43 <mjrosenb> and it works
01:44:15 <yitz> mjrosenb: why do you need this type class to begin with? often these kinds of problems stem from design that is poisoned with OO-think. I still fall into that trap myself sometimes.
01:45:54 <mjrosenb> yitz: this may be entirely possible
01:46:02 <quicksilver> OOthink is doubleplusbad
01:46:44 <mjrosenb> so as the class name implies, this is for a bitreader.  i givet it a stream of bits, and it gives me back a value
01:46:57 <glguy> While reading a recent SCOTUS opinion I found a sentence "Petitioners make a purely functional argument, as well. Read as a whole, they say, the assignments in this litigation constitute nothing more than a contract for legal services."
01:47:16 <glguy> petitioners adopting Haskell perhaps?
01:47:40 <mjrosenb> the part that seems to be working is unrelated to the typeclass
01:48:00 <osfameron> meh, jobserve.co.uk has nothing for "f# or haskell or erlang or ocaml or clojure" (although it does helpfully ask if I meant "oral" instead of "ocaml")
01:48:34 <quicksilver> and did you?
01:48:49 <yitz> mjrosenb: sounds like you want some of your implementations to be common to all Num types, and other parts vary. is that right?
01:49:45 <mjrosenb> yitz: i'd like it to work just like the read function
01:49:58 <mjrosenb> only not structured on top of readS
01:50:32 <quicksilver> mjrosenb: FWIW have you looked at data.binary and data-binary0strict?
01:50:45 <mjrosenb> quicksilver: yes
01:51:07 <yitz> mjrosenb: right, but your attempt at "instance Num a => ...
01:51:26 <yitz>  make me think that you want to share implementation between some of the types.
01:51:54 <mjrosenb> quicksilver: wait, data.binary, not data.bits?
01:53:26 <mjrosenb> yitz: ok, yeah, from the point of view from the implementation of BitReader for the Num a's it would be nice if there was only one implementation
01:53:27 <yitz> mjrosenb: yes, data.binary is the usual way. quicksilver is right, look at that first.
01:55:12 <mjrosenb> gah, right, but that only handles Word8's
01:55:19 <yitz> mjrosenb: so can you write regular polymorphic functions - not class methods - that do the common stuff, and then use those inside the method implementations for each type?
01:55:41 <yitz> mjrosenb: your data isn't coming in a byte at a time?
01:56:12 <mjrosenb> it's coming one byte at a time, but i need to look at it between 1 and 12 bits at a time
01:56:21 <mjrosenb> thus the pain
01:56:24 <quicksilver> mjrosenb: then you want data-binary-strict
01:56:29 <quicksilver> mjrosenb: which has bit-aligned ops
01:56:56 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-strict
01:56:58 <lambdabot> http://tinyurl.com/5l796c
01:57:02 <quicksilver> I agree that this is not clear form the name ;)
01:57:10 <quicksilver> I only learnt this myself last week by reading the cafe.
01:57:24 <mjrosenb> do tell
01:57:40 <quicksilver> well, that binary-strict has bitaligned operations
01:57:43 <quicksilver> instead of bytealigned
01:58:21 <mjrosenb> there does'nt seem to be any haddock for it
01:58:41 <yitz> quicksilver: why should that be special to the strict version? the lazy one should just pull in however many bytes it needs to supply the requested bits.
02:01:00 <quicksilver> yitz: because they are different libraries with different apis and different features :)
02:01:18 <quicksilver> mjrosenb: there is, but it's not autogenerated online presumably due to some kind of build failure on the hackage machine.
02:01:58 <mjrosenb> anyhow, this seems to be doing what i need it to do
02:02:06 <mjrosenb> in an eerily nice syntax
02:02:44 <mjrosenb> the types seem a bit messed up, but oh well
02:06:49 <yitz> quicksilver: ah, i didn't realize that the strict library is a whole different animal. sounds like an opportunity for collaboration :)
02:10:15 <quicksilver> yes, would be nice to have them merged
02:16:04 <osfameron> quicksilver: heh ;-)  I really was expecting more FP jobs -- there seem to be more in the States than UK from a brief google
02:33:53 <ivanm> concatMap (filter p . f) would be better than filter p . concatMap f, wouldn't it?
02:34:13 <opqdonut> yeah
02:34:25 <ivanm> good-o
02:34:28 <opqdonut> but if stream fusion works they'll be equivalent
02:34:38 <opqdonut> probably no performance difference in ghc
02:34:44 <ivanm> *nod*
02:34:55 <cetin> any gtk2hs devs here?
02:34:58 <ivanm> so I'd probably want to stick with the latter for readability purposes?
02:35:03 <ivanm> @seen dcoutts_
02:35:03 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
02:35:09 <opqdonut> ivanm: yeah probably
02:35:11 <ivanm> :(
02:35:24 <ivanm> opqdonut: does ghc _definitely_ optimise that out?
02:35:29 <ivanm> or do you just think so?
02:35:41 <opqdonut> well b/c of laziness they're pretty similar
02:35:44 <opqdonut> in terms of performance
02:35:54 <opqdonut> the former does one (:) more per filtered element
02:37:40 <ivanm> *nod*
02:37:46 <ivanm> which is probably negligible
02:38:54 <yitz> the former filters over [[a]], the latter over [a], so p is also a tiny notch faster in the latter
02:39:42 <ivanm> yitz: no, p still filters over [a] in both...
02:39:57 <yitz> ah, we're mapping it. ok
02:40:09 <opqdonut> yeah
02:40:25 <opqdonut> it's a (small) constant factor and not anything like n vs n^2
02:41:33 <yitz> you know, i am always focused on making code readable and maintainable, the real cost. thinking about those kinds of performance differences is almost always premature optimization.
02:46:06 <mjrosenb> yitz: i agree with you up to a point
02:46:43 <mjrosenb> although my deep down opinion is that you should implement it the readable way
02:46:56 <mjrosenb> then make sure the compiler knows how to do the right thing
02:47:05 <mjrosenb> and fix it if it doesn't
02:47:46 <yitz> where "the right thing" means good enough to get this particular job done well.
02:48:49 <mjrosenb> not really
02:49:19 <mjrosenb> then the compiler takes on all of the hodge-podge that was forced out of your well-maintained, slow code
02:49:45 <mjrosenb> you shold also make sure that your optimizations are general enough to be elegant
02:49:51 <mjrosenb> if that makes any sense
02:50:17 <yitz> yeah, when possible.
02:51:32 <yitz> also: "fix it" includes helping to fix the compiler - giving support to the compiler team in their constant efforts to find ways to run the readable code efficiently in the future.
02:51:50 <mjrosenb> indeed
02:53:04 <mjrosenb> gah, i can't be inside the Maybe monad and another monad at once
02:53:06 * mjrosenb is sad
02:53:51 <Botje> haskell enforces monogamy >:)
02:54:08 <cjs> Monad Transformer!
02:54:19 <ivanm> Haskell == Catholic Programming Language? :p
02:55:11 * matthew-_ withdraws from this conversation at the last minute...
02:55:43 <jinjing> hmm, is there a way to runtime evaluation in haskell with scoped bindings
02:57:43 <ivanm> matthew-_: any particular reason why?
02:57:53 <ejt> jinjing: you want dynamically scoped vars ?  if so have a look at the writer monad
02:58:07 <jinjing> ivanm: not really, just curious
02:58:17 <povman> does anyone know of something like applyToFirstMatching :: (a->Bool) -> (a->a) -> [a] -> [a]
02:58:19 <ivanm> jinjing: ummm.... what?
02:58:49 <ivanm> povman: possibly use partition?
02:59:32 <jinjing> ivanm: nvm, wrong line :J)
02:59:38 <ivanm> heh
03:00:12 <Botje> povman: use the break function, then check if the right part is nonempty and apply f if so,
03:00:14 <mjrosenb> povman: i'd probably do something involving mayMaybe
03:00:24 <povman> close - but i need something like applyToFirstMatching (>3) (const 0) [0 1 2 3 4 5 6] ==> [0 1 2 3 0 5 6]
03:00:50 <mjrosenb> povman: and take the (a -> Bool) and (a -> a) and make it into a single function
03:00:57 <ejt> povman:
03:00:58 <ejt> Prelude> let atfm p fn xs = let (as, b : bs) = break p xs in as ++ (fn b) : bs
03:00:58 <ejt> Prelude> atfm even (+1) [1, 3, 4, 5, 7]
03:00:59 <mjrosenb> povman: oh....
03:01:05 <povman> mjrosenb: ;)
03:01:28 <ejt> hmm, I'm going to get kicked for doing peoples homework
03:01:33 <povman> it's not homework
03:01:36 <mjrosenb> povman: yeah' i ran into a similar problem earlier today
03:02:09 <povman> i could write it _myself_ but was wondering if there's something hidden away in the standard libs
03:02:10 <ejt> povman: in that case, there you go
03:02:15 <povman> ejt thanks
03:02:33 <ejt> povman: I think it's way too specific to be in the prelude
03:02:44 <roconnor> > break (>3) [0..6]
03:02:45 <jinjing> ejt: thanks, reading writer monad
03:02:47 <lambdabot>  ([0,1,2,3],[4,5,6])
03:03:02 <povman> ejt: break is close enough
03:03:17 <ejt> break fn = partition (not . fn)
03:03:52 <povman> @src break
03:03:52 <lambdabot> break p =  span (not . p)
03:03:55 <povman> ...
03:04:01 * mjrosenb wants to stab a monad
03:04:15 <roconnor> > (id *** (\(a:as) -> 0:as)) . (break (>3)) $ [0..6]
03:04:16 <lambdabot>  ([0,1,2,3],[0,5,6])
03:04:34 <roconnor> > uncurry (++) . (id *** (\(a:as) -> 0:as)) . (break (>3)) $ [0..6]
03:04:35 <lambdabot>  [0,1,2,3,0,5,6]
03:04:56 <roconnor> > uncurry (++) . (id *** (\(a:as) -> (const 0 a):as)) . (break (>3)) $ [0..6]
03:04:58 <lambdabot>  [0,1,2,3,0,5,6]
03:05:01 <ivanm> mjrosenb: which one?
03:05:16 <ivanm> roconnor: why not use second instead of id *** ?
03:05:24 <mjrosenb> ivanm: Maybe.... i want to be in the Maybe monad and another one at once
03:05:39 <ejt> jinjing: sorry, I meant Reader monad
03:05:47 <roconnor> @unpl uncurry (++) . (id *** (\(a:as) -> (const 0 a):as)) . (break (>3))
03:05:47 <lambdabot> (\ g -> uncurry (++) (((\ b -> b) *** \ (a : as) -> 0 : as) (break (\ d -> d > 3) g)))
03:05:52 <povman> there is a point where haskell code stops being legible.
03:06:06 <quicksilver> yes, the point when you start writing it badly? :)
03:06:15 <quicksilver> well written code is always legible. In any language.
03:06:21 <roconnor> ivanm: I need fst and snd
03:06:28 <jinjing> ejt: heh, thanks, i'll first try reverting what i learned in the writer one
03:06:34 <povman> i think for me anything involving *** is illegible atm
03:06:49 <Saizan> mjrosenb: that can be done with monad transformers
03:06:56 <povman> also, needlessly pointfree code is hard for me
03:07:10 <quicksilver> needlessly pointfree code is hard for most people :)
03:07:11 * mjrosenb will look into exception monads and whatnot
03:07:17 <ejt> povman: the arrows paper is a good read, it helped me with Monads a lot too
03:07:30 <roconnor> > (\(as,(b:bs)) -> as++[const 0 b]++bs) . (break (>3)) $ [0..6]
03:07:31 <mjrosenb> since that's more or less what i'm doing with Maybe
03:07:32 <lambdabot>  [0,1,2,3,0,5,6]
03:07:43 <ivanm> roconnor: OK, just that AFAICT (id *** f) = second f
03:07:59 <roconnor> ivanm: oh second
03:08:02 <roconnor> I wasn thinking snd
03:08:06 <ivanm> heh
03:08:32 <roconnor> the lambda notation is better anyways
03:08:53 <roconnor> although what I have isn't quite right yet
03:08:59 <roconnor> > (\(as,(b:bs)) -> as++[const 0 b]++bs) . (break (>3)) $ [0..3]
03:09:01 <lambdabot>   Non-exhaustive patterns in lambda
03:09:08 <roconnor> but it is close
03:09:54 <mjrosenb> why can exceptions only be thrown from within the IO monad?
03:10:41 <roconnor> is that true?
03:11:01 <mjrosenb> all of the handlers deal with IO a
03:11:13 <ejt> mjrosenb: it's true for IO exceptions
03:11:15 <roconnor> @type throw
03:11:16 <lambdabot> Not in scope: `throw'
03:11:21 <roconnor> @hoogle throw
03:11:21 <lambdabot> Control.Exception.throw :: Exception -> a
03:11:22 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
03:11:22 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
03:11:31 <roconnor> Control.Exception.throw :: Exception -> a -- no IO
03:11:58 <mjrosenb> ejt: how do i handle a non-IO exception?
03:12:12 <roconnor> mjrosenb: are you trying to ask "why can exceptions only be caught from within IO?"
03:12:47 <mjrosenb> roconnor: perhaps
03:12:54 * mjrosenb is tired
03:13:07 <roconnor> because exceptions need to be sequenced
03:13:25 <roconnor> use MonadError for non IO based exceptions.
03:13:51 * mjrosenb checks it out
03:14:21 <roconnor> @hoogle catchError
03:14:21 <lambdabot> Control.Monad.Error.Class.catchError :: MonadError e m => m a -> (e -> m a) -> m a
03:20:54 <ak47> hi everybody, i've got this little problem. i have some code that functions correctly when called manually, but when i unleash map on a filled list it returns nothing
03:20:58 <ak47> http://hpaste.org/8632
03:21:44 <int-e> ak47: you want mapM (or mapM_ really)
03:22:24 <ak47> can you point me to some docs explaining why ?
03:22:27 <ejt> you're returning a list of Monads
03:22:27 <EvilTerran> you're getting back an IO [IO (...)]
03:22:36 <ejt> rather than sequencing them
03:22:42 <EvilTerran> that's just a list of actions, return'ed
03:22:50 <EvilTerran> instead you just want an IO [...]
03:22:51 <Zao> An IO action is just a value.
03:22:55 <ADEpt> ak47: so replace last line with "print $ mapM ..."
03:22:58 <int-e> sorry, you need the results, so mapM.
03:23:08 <EvilTerran> ?type mapM
03:23:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:23:21 <ak47> ok, back to school with me. thanks ;-)
03:23:26 <EvilTerran> ?type mapM_
03:23:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:23:38 <EvilTerran> mapM_ is like mapM only it throws the results away
03:24:09 <EvilTerran> so is more efficient, as can be used where a "m ()" type is specifically required
03:24:32 <EvilTerran> ADEpt, shouldn't that be "print =<< mapM ..."?
03:27:09 <ADEpt> EvilTerran: oh. of course
03:27:43 <ak47> i can't wait for the "aha moment" of haskell. lisp was a lot easier to grok, and it was pretty good feeling "finally getting it", so i can only hope won't stain my pant when (if) i finally get haskell ;-)))
03:27:57 <ak47> pant -> pants
03:31:38 <ejt> ak47: start putting the function types in
03:32:32 <ejt> ak47: it'll help you think more about what you're doing, and the compiler can be a bit more helpful about pointing out your mistakes
03:34:46 <RayNbow> ak47: personally I think Haskell opens up such a large world that you'll experience many "aha!" moments in the future :p
03:37:25 <Dae> So...mmm.. is there -any- syntactic sugar for MArrays? they are so extremely much harder to use than IArrays....
03:40:41 <quicksilver> Dae: harder how?
03:42:08 <Dae> quicksilver:  I lack the // of the IArrays, for updating a bunch of elements, rather than a single one
03:43:29 <quicksilver> IArray version: arr // assocs
03:43:52 <quicksilver> MArray version: forM_ assocs $ \(i,e) -> writeArray arr i e
03:44:08 <Dae> :o
03:44:10 <quicksilver> fractionally clumsier but not a big problem IMO ;)
03:44:24 <Dae> Right on! Thank you very much :)
03:44:24 <quicksilver> still fits on one line comfortably enough
03:44:48 <RayNbow> @pl \(i,e) -> writeArray arr i e
03:44:48 <lambdabot> uncurry (writeArray arr)
03:45:06 * quicksilver nods
03:45:20 <quicksilver> I thought uncurry might be considered less readable.
03:45:21 * RayNbow notices lambdabot is back \o/
03:45:37 <quicksilver> it only saves a couple of chars, although it does save naming i and e.
03:46:41 <RayNbow> oh, I agree that the version with the lambda is clearer
03:48:38 <Dae> so....mmm..... couold the assocs refer to the array I'm modifying, or would i be getting modified stuff?
03:48:44 <luite_> RayNbow: but many 'wtf' moments in the present ;)
03:49:37 <RayNbow> luite_: people just experience "wtf"s with Haskell because they are conservative and have a hard time rewiring their brains :p
03:49:51 <RayNbow> but then again, that's just human's nature :p
03:50:07 <Dae> RayNbow: True that.... haskell is made of wtf :D
03:50:16 <quicksilver> Dae: it can refer to the array you're modifying; values are immutabe.
03:50:30 <quicksilver> Dae: of course you'd have to fetch the values with a 'readArray' in a previous line.
03:50:34 <quicksilver> such is the nature of MArrays.
03:51:16 <Dae> quicksilver: Ok.... I get the feeling I'll want to avoid them whenever I can
03:53:44 <ak47> > ejt	ak47: start putting the function types in --> i will, this was my first "program", to compare what i've already done in lisp to haskell.
03:53:45 <lambdabot>  Parse error at "in" (column 44)
03:53:52 <ak47>  i know its far from perfect, but i can check first point on the checklist : make it work. now to the next point: make it right.
03:54:50 <Dae> ak47: Doing it the other way around is almost always a lot faster..... god knows how many erros I've introduced in a refactoring process
03:57:21 <ak47> 2 dae> will try to remember it, but ever felt that anxiousness to have your first program actually do something instead of just stacking types on top of themselves ? ;-)
03:57:59 <ulfdoz> duschgel ist für mädchen.
03:58:04 <ulfdoz> ECHAN, sorry
03:58:09 <Dae> ak47: All the time ;)
03:58:34 <ak47> btw, as a _sworn enemy_ of static typing, i must say haskell seems the first lang where they might serve some purpose ;-)
03:58:56 <quicksilver> Dae: Yes. MArrays are clumsy and only to be used when necessary.
03:59:01 <quicksilver> Like manual memory management.
03:59:04 <quicksilver> Which, in a sense, they are.
03:59:53 <osfameron> ak47: yeah, the types seem to either get out of the way and manage themselves, or actually do something useful a lot of the time, even coming at it from a dynamic language perspective
04:00:24 <Dae> quicksilver: yeah, sometimes there just seems to be no real atlernative
04:01:00 <ak47> well, thanks a lot for the help everybody, i'm off to wallow some more in the typed goodness of haskell ;-))) and not to worry, i'll be probably back soon whining for some more help ;-)
04:07:04 <Dae> is there a way to force-envoke the garbage collector?
04:14:00 <quicksilver> Dae: System.Mem.performGC
04:14:16 <Dae> thank you very much
04:29:15 <povman> it feels like a `f` b == f b a
04:29:28 <povman> * should ==
04:30:16 <povman> so stuff like elem could be written the right way around
04:30:18 <Zao> > let f = (-) in 4 `f` 3
04:30:22 <lambdabot>  1
04:30:39 <povman> i mean
04:30:41 <Zao> povman: Or rewrite elem.
04:30:43 <quicksilver> > 1 `elem` [1,2,3,4]
04:30:44 <opqdonut> povman: hell no
04:30:45 <lambdabot>  True
04:30:48 <Zao> :t elem
04:30:48 <povman> > 3 `elem` [1,2,3,4]
04:30:50 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:30:51 <lambdabot>  True
04:30:54 <povman> makes sense
04:30:55 <opqdonut> elem is the right way around already
04:30:55 <quicksilver> this seems like "the right way around" to me.
04:31:00 <opqdonut> if you think elem ~ \in
04:31:14 <povman> that's _right_, but what i mean is:
04:31:21 <povman> > (elem 3) [1,2,3,4]
04:31:23 <lambdabot>  True
04:31:26 <povman> is the wrong way around
04:31:36 <quicksilver> > (3 `elem`) [1,2,3,4])
04:31:36 <lambdabot> Unbalanced parentheses
04:31:39 <quicksilver> > (3 `elem`) [1,2,3,4]
04:31:39 <opqdonut> how come?
04:31:40 <lambdabot>  True
04:32:06 <povman> (elem [1,2,3,4]) should be the function that returns true if its input is an element of [1..4
04:32:22 <quicksilver> (`elem` [1,2,3,4]) is that.
04:32:38 <povman> i know :) but it feels wrong
04:32:45 <quicksilver> only to you.
04:32:57 <quicksilver> ergo, it is you that feels wrong, not it :)
04:33:04 <MyCatVerbs> Some people have a single element which must be searched for in many lists.
04:33:14 <povman> MyCatVerbs: how often.
04:33:15 <MyCatVerbs> Other people have a single list, in which many elements must be searched for.
04:33:43 <MyCatVerbs> povman: I don't know, but attempting to measure it would take so long that we'd never actually get anything done.
04:33:56 <MyCatVerbs> povman: now shut up and use flip.
04:34:07 <povman> ...
04:34:11 <povman> ok how about this
04:34:11 <opqdonut> :D
04:34:26 <povman> map (*2) == function to multiply all elements of input list by 2
04:34:26 <quicksilver> there is no perfect ordering for binary functions.
04:34:39 <quicksilver> You can always think of occasions when the other would be handy.
04:34:55 <quicksilver> However, the current ordering of elem is correct for 99,973 out of every 100,000 occasions
04:34:57 <MyCatVerbs> quicksilver: hence we have flip! And infix function sections!
04:35:00 <quicksilver> which is a good choice.
04:35:08 <MyCatVerbs> quicksilver: and made-up-on-the-spot statistics!
04:35:09 <quicksilver> and (`elem`) sections suffice for the rest.
04:35:19 <povman> then [1..4] `map` (*2) reads more naturally than (*2) `map` [1..4]
04:35:40 <opqdonut> not every function is intended to be used as infix
04:35:52 <quicksilver> I think map (*2) [1..4] reads most naturally
04:35:56 <quicksilver> of those cases :P
04:35:56 <opqdonut> and flipping along with `` would just complicate things
04:35:58 <opqdonut> quicksilver: yes
04:36:01 <povman> but if infix worked the other way around, every function _could_ be used as infix
04:36:05 <MyCatVerbs> povman: really? Because [1..4] `fmap` (*2) and [1..4] <$> (*2) seem pretty natural to me.
04:36:06 <quicksilver> rubbish.
04:36:18 <idnar> (*2) . [1..4]
04:36:19 <povman> MyCatVerbs: exactly
04:36:22 <quicksilver> if infix was the other way around it would be just as bad (or in fact worse)
04:36:25 <MyCatVerbs> povman: if infix worked the other way around, it'd be one extra bloody pointless rule to remember.
04:36:30 <povman> MyCatVerbs: that's not how map works now
04:36:37 <MyCatVerbs> ...
04:36:47 <MyCatVerbs> povman: that is exactly how map works now, you dope.
04:36:48 <quicksilver> what on earth makes you think it would be better the other way around?
04:36:48 <povman> > [1..4] `map` (*2)
04:36:49 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
04:37:05 <idnar> is not!
04:37:05 <quicksilver> you have 1 example where you believe the other would be better (map)
04:37:09 <MyCatVerbs> idnar: oh, pants.
04:37:14 <idnar> heh
04:37:15 <quicksilver> which I don't often want to use infix
04:37:22 <quicksilver> and there are hundres which work better this way...
04:37:34 <povman> eg
04:37:35 <MyCatVerbs> povman: damn you, your idea is so stupid that it's already confusing me. :P
04:37:45 <povman> it's a great idea :)
04:38:01 <MyCatVerbs> povman: (*2) `map` [1..4] -- same as (*2) `fmap` [1..4] -- same as (*2) <$> [1..4]
04:38:06 <psyklops> > (*2) [2,4..24]
04:38:09 <lambdabot>   add an instance declaration for (Num [t])
04:38:17 <psyklops> > (*2) . [2,4..24]
04:38:19 <lambdabot>  [4,8,12,16,20,24,28,32,36,40,44,48]
04:38:45 <MyCatVerbs> povman: that last one is more important than the ones preceeding it, because (<$>) is just a synonym for `fmap`, and yet it works identically to how ($) works. Which is perfect.
04:39:08 <MyCatVerbs> > (+1) <$> [1..4]
04:39:14 <lambdabot>  [2,3,4,5]
04:39:31 * povman creates new links in his brain
04:39:33 <MyCatVerbs> > (+1) $ 1
04:39:35 <lambdabot>  2
04:39:43 <povman> i'm reading `map` wrong then
04:39:44 <MyCatVerbs> See, consistency. It's nice.
04:40:21 <povman> it's really just elem that bugs me
04:41:06 <PeakerWork> povman, felem = flip elem ?
04:41:29 <povman> i guess - it just seems to defy the style of the rest of the prelude
04:41:35 <quicksilver> povman: but why does elem bug you?
04:41:43 <quicksilver> 1 `elem` [1,2,3,4]
04:41:49 <quicksilver> "1 is an element of [1,2,3,4]"
04:41:56 <quicksilver> I'm sure that's the more natural of the two choices.
04:42:21 <quicksilver> [1,2,3,4] `contains` 1 or [1,2,3,4] `has` 1
04:42:23 <povman> quicksilver: but that's a different way of reading infix functions than for map
04:42:25 <quicksilver> if you wanted the other way.
04:42:32 <quicksilver> povman: different how?
04:42:33 <povman> o rly
04:42:50 <idnar> (*2) `map` [1...4] -- "the function *2 is mapped over the list [1...4]"
04:43:01 <idnar> er, delete the "is" probably
04:43:12 <quicksilver> well map wasn't designed for sensible infix reading, particularly.
04:43:16 <quicksilver> However elem definitly was.
04:43:47 <povman> i can see that nobody else hates elem like i do.
04:44:21 <quicksilver> certainly true, but I also don't understand your reason.
04:44:24 <quicksilver> and I"m interested.
04:44:31 <povman> because i want (elem [1,2,3,4])
04:44:34 <povman> :(
04:44:44 <quicksilver> (`elem` [1,2,3,4])
04:44:46 <quicksilver> you have it.
04:44:48 <povman> gah
04:44:51 <quicksilver> that's the natural haskell idiom
04:44:59 <quicksilver> because you're "missing out the subject"
04:44:59 <povman> but (map (*2)) works
04:45:11 <quicksilver> indeed.
04:45:17 <Zao> let canhas = flip elem in [1..4] `canhas` 3
04:45:25 <quicksilver> map is not designed for infix reading as I said.
04:45:27 <Zao> > let canhas = flip elem in [1..4] `canhas` 3
04:45:29 <lambdabot>  True
04:45:31 <povman> yeah i see that
04:45:40 <quicksilver> (`isInfixOf` "haystack")
04:45:51 <quicksilver> (`isSuffixOf` "file.jpeg")
04:46:01 <quicksilver> the (`foo` bar) idiom is a natural one.
04:47:11 <povman> ok so some functions are designed to be infix
04:47:20 <povman> if this was lisp, i'd be right :)
04:51:38 <shapr> @seen edwardk
04:51:38 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
04:51:56 <shapr> preflex: seen edwardk
04:51:56 <preflex>  edwardk was last seen on #haskell 13 hours, 2 minutes and 14 seconds ago, saying: brb
04:52:19 <ddarius> He has an extended notion of "right back"
04:52:39 <quicksilver> he was honestly intended to come straight here
04:52:42 <quicksilver> but he was lured away
04:52:55 <quicksilver> he encountered a particular seductive zygomorphism
04:54:19 <povman> that is the geekiest word for woman i've ever seen
04:56:14 <EvilTerran> altho you could think about map as an infix, and that'd make sense
04:56:24 <EvilTerran> you'd just need to read it differently
04:56:30 <EvilTerran> > (+1) . [2,3,4]
04:56:32 <lambdabot>  [3,4,5]
04:56:39 <povman> :t (.)
04:56:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:56:44 <EvilTerran> ?src (.)
04:56:44 <lambdabot> (f . g) x = f (g x)
04:56:44 <lambdabot> -- In lambdabot, it's been generalised to:
04:56:44 <lambdabot> (.) = fmap
04:56:46 <povman> ohhhh
04:57:06 <EvilTerran> blame Cale
04:57:17 <byorgey> preflex: seen Gilly
04:57:17 <preflex>  Gilly was last seen on #haskell 2 days, 22 hours, 12 minutes and 31 seconds ago, saying: byorgey: nvm - that article .lhs suffices and i found it :) (excellent stuff, btw. i did something similar (though only counting the number of multipartitions) using the same idea of viewing them as vectors, but your code is neat and now i'd need to enumerate :)
05:01:10 <EvilTerran> preflex, have you encountered fmap as (.) before?
05:01:12 <EvilTerran> er, povman
05:01:20 <EvilTerran> darn tab complete
05:01:24 <povman> no, it's fun though
05:01:39 <povman> i only just learned about <$>
05:01:50 <EvilTerran> it's "instance Functor (e ->) where fmap = (.)"
05:02:06 <EvilTerran> except you can't write that, you have to write ((->) e). but it comes to the same thing.
05:02:33 <EvilTerran> i find it makes sense if you compare it to the way the Functor instance works for (Map e)
05:03:18 <EvilTerran> 'cos (Map e a) and ((->) e a) are both mappings from e to a
05:03:50 <EvilTerran> where e is the "key" and a is the "value", and then fmap (f :: a -> b) gives you a mapping from e to b
05:03:50 <ddarius> It doesn't make sense on its own?
05:04:31 <EvilTerran> ddarius, it makes sense that (.) is the only implementation of fmap for (e ->), but i didn't find it intuitive that (e ->) was a functor in the first place
05:04:44 <EvilTerran> ?type fmap
05:04:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:05:04 <povman> that makes sense
05:05:07 <EvilTerran> ?djinn (a -> b) -> ((->) e) a -> ((->) e) b
05:05:08 <lambdabot> Cannot parse command
05:05:23 <EvilTerran> ?djinn (a -> b) -> (e -> a) -> (e -> b)
05:05:24 <lambdabot> f a b c = a (b c)
05:05:50 <povman> did that just invent an implementation for that type sig?
05:05:55 <EvilTerran> yes. yes it did.
05:05:58 <EvilTerran> ?where djinn
05:05:58 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
05:06:12 <povman> what the insane
05:06:22 <povman> so much for programmers :D
05:06:22 <EvilTerran> it uses the Curry-Howard isomorphism, which identifies theorems with types and proofs with implementations
05:07:10 <EvilTerran> and then it searches the proof (expression) space for a something that proves (satisfies) the given theorem (type)
05:07:40 <povman> so assuming you defined your types well enough you could automatically derive real programs
05:07:51 <EvilTerran> for instance, "const :: a -> b -> a" is effectively the copy rule from formal logic
05:07:59 <EvilTerran> if you read -> as "implies"
05:08:35 <EvilTerran> and "(,) :: a -> b -> (a,b)" is like "and-intro: a => b => (a && b)"
05:09:04 <ddarius> EvilTerran: (e ->) is actually one of the most important/basic functors in CT.
05:09:22 <EvilTerran> "Left :: a -> Either a b" and "Right :: b -> Either a b" are or-intro-1 and 2 respectively
05:10:31 <EvilTerran> and "either :: Either l r -> (l -> a) -> (r -> a) -> a" is or-elim, etcetc
05:11:00 <ziman> @djinn a -> Maybe b
05:11:01 <lambdabot> f _ = Nothing
05:11:01 <EvilTerran> it's really rather clever
05:11:06 <ziman> clever ;)
05:11:23 <EvilTerran> ddarius, it does seem to be a trend that the most fundamental stuff from CT is the least immediately intuitive ;)
05:11:58 <ddarius> EvilTerran: This is a rather straightforward example.
05:12:01 <povman> what's ct?
05:12:21 <povman> oh nm
05:12:39 <povman> category theory
05:12:41 <profmakx> category theory
05:13:12 <EvilTerran> but, as i said, i find the identity "(fmap f m !) = fmap f . (m !)" to be quite instructive for following this one
05:14:04 <ddarius> EvilTerran: I don't think I've ever heard const referred to as the "copy" rule.  That would be more like (a -> a -> b) -> a -> b to me.
05:14:15 <povman> it'd be nice if ghci had an option to automatically derive Show for everything for debugging
05:14:50 <EvilTerran> ddarius, actually, i think id would be closer to what my lecturer called the "copy rule", seeing as ISTR that was pretty much just "copy: a |- a"
05:14:52 <ddarius> It can't.
05:15:02 <povman> then again maybe not.
05:15:06 <EvilTerran> povman, instance Show (a -> b) where...
05:15:15 <povman> all my ideas suck today :)
05:15:19 <ddarius> I can see that being called copy, though it's usually just "axiom"
05:15:23 <ddarius> or id.
05:15:39 <quicksilver> the rules are called weakning and contraction.
05:15:40 <EvilTerran> it makes sense to call it copy for natural deduction proofs
05:16:27 <quicksilver> in programming terms, contraction says you are allowed to use an argument twice, and weakening says you are allowed to ignore an argument.
05:16:46 <quicksilver> restricting these rules takes you to various linear (substructural) ways of formalising programming.
05:17:14 <quicksilver> in that context "const" is weakening.
05:17:15 <EvilTerran> [1. a (assumption); [2. b (assumption); 3. a (copy, 1)]; 4. b -> a (modus ponens, 2-3)]; 5. a -> (b -> a) (modus ponens, 1-4)
05:17:37 <quicksilver> weakening and contraction are invisible in proofs like that.
05:18:04 <quicksilver> Indeed, compared to Gentzen style ND, the value of proofs like that is precisely that they internalise weakening and contraction.
05:18:09 <EvilTerran> quicksilver, so removing one or other of those gives you stuff like linear logic?
05:18:17 <quicksilver> for more information on this topic, please see my thesis :P
05:18:21 <quicksilver> yes.
05:18:26 <ddarius> Removing both gives you linear logic.
05:18:45 <ddarius> Removing just contraction gives you affine logic, and just weakening relevant logic.
05:18:46 <EvilTerran> link please? i'll put it in my Great Big Folder o' PDFs to Read On The Train
05:18:56 <ddarius> You can also remove the structural rule exchange.
05:19:10 <quicksilver> http://www.dcs.qmul.ac.uk/researchgp/common/display.php?b=27079&type=99
05:19:12 <lambdabot> Title: Research Reports Publications Detail, http://tinyurl.com/6347mz
05:19:27 <ddarius> Presumably you could also remove the structural rule that makes contexts associative, but not many have gone that far.
05:34:00 <mar77a> > map (\x -> x ++ ".haskell.org now back up") ["hackage","darcs"]
05:34:06 <lambdabot>  ["hackage.haskell.org now back up","darcs.haskell.org now back up"]
05:34:30 <quicksilver> good point
05:34:34 <RayNbow> @pl (\x -> x ++ ".haskell.org now back up")
05:34:34 <lambdabot> (++ ".haskell.org now back up")
05:34:41 <quicksilver> ah, it's already in topic
05:34:57 <mar77a> yeah but it's not expressed in a haskellish manner :(
05:35:23 <quicksilver> oh I see
05:35:48 <quicksilver> > ["hackage","darcs"].(++".haskell.org now back up")
05:35:51 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
05:35:55 <quicksilver> bah
05:35:59 <quicksilver> caleskell is dead
05:36:09 <quicksilver> ah no
05:36:11 <quicksilver> I'm stupid.
05:36:21 <PeakerWork> @src scanl
05:36:21 <lambdabot> scanl f q ls = q : case ls of
05:36:21 <lambdabot>     []   -> []
05:36:21 <lambdabot>     x:xs -> scanl f (f q x) xs
05:36:26 <quicksilver> > (++".haskell.org now back up").["hackage","darcs"]
05:36:27 <lambdabot>  ["hackage.haskell.org now back up","darcs.haskell.org now back up"]
05:36:30 <PeakerWork> @src scanr
05:36:30 <lambdabot> scanr _ q0 []     =  [q0]
05:36:30 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
05:36:30 <lambdabot>     where qs@(q:_) = scanr f q0 xs
05:37:26 <PeakerWork> scanr lets you lazily pull out the start without computing the rest, and scanl doesn't?
05:37:37 <RayNbow> >> (++ ".haskell.org now back up") `fmap` ["hackage", "darcs"]
05:37:40 <RayNbow> oops
05:37:42 <RayNbow> > (++ ".haskell.org now back up") `fmap` ["hackage", "darcs"]
05:37:44 <lambdabot>  ["hackage.haskell.org now back up","darcs.haskell.org now back up"]
05:41:30 <povman> @pl pickFirst f xs = case break f xs of (prefix, []) -> (prefix, Nothing, []); (prefix, a:as) -> (prefix, Just a, as)
05:41:30 <lambdabot> (line 1, column 50):
05:41:30 <lambdabot> unexpected ">" or "-"
05:41:30 <lambdabot> expecting variable, "(", operator or end of input
05:50:06 <mapreduce> Are methods in typeclasses dispatched on the types of more than one argument?
05:51:21 <Saizan> well, they are dispatched according to which types are parameters of the class
05:51:38 * mjrosenb is quite annoyed by haskell's  attitude towards exception handling
05:51:42 <SamB_XP_> they are dispatched on as many as it takes to figure out what instance provides the method
05:51:50 <povman> mjrosenb: ?
05:52:39 <mjrosenb> it seems like exceptions are either non-catchable, IO exceptions, or need to be handled via a monad
05:52:48 <SamB_XP_> actually, the types don't need to be argument types either ;-P
05:52:58 <SamB_XP_> > pi :: Float
05:53:00 <lambdabot>  3.1415927
05:53:04 <SamB_XP_> > pi :: Double
05:53:05 <lambdabot>  3.141592653589793
05:53:11 <SamB_XP_> > pi :: Complex Double
05:53:12 <lambdabot>  3.141592653589793 :+ 0.0
05:53:23 <povman> @src pi
05:53:24 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:53:37 <SamB_XP_> @src Floating
05:53:37 <lambdabot> class  (Fractional a) => Floating a  where
05:53:37 <lambdabot>     pi                                                      :: a
05:53:37 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
05:53:37 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
05:53:37 <lambdabot>     (**), logBase                                           :: a -> a -> a
05:53:46 <povman> ohh
05:54:59 <mar77a> is impementing ln through taylor expansions and then exponentiation through ln and e a good approach?
05:55:28 <SamB_XP_> mar77a: what are you doing?
05:55:35 <quicksilver> I can remember what's considered to be the fastest converging way to calculate log
05:55:51 <quicksilver> I doubt it's taylor, taylor are mainly for fun (easy to reason about) not for calculation.
05:55:52 <mar77a> trying to write a math lib using addition and other basic stuffs
05:55:59 <mar77a> which one is it, quicksilver ?
05:56:06 <quicksilver> like I said, I can't remember.
05:56:14 <mar77a> 08:55 < quicksilver> I can remember
05:56:14 <mar77a> :D
05:56:17 * mjrosenb would imagine newton's method on e^x
05:56:30 <mjrosenb> it's what they use for sqrt in hardware
05:56:30 <quicksilver> ;)
05:57:55 <quicksilver> mar77a: google for fast logarithm?
05:58:18 <quicksilver> if fast doesn't matter and you just need it to work, then binary chop is simple ;)
05:58:31 <SamB_XP_> quicksilver: sounds brutal
05:58:36 <quicksilver> from one perspective, newton's method is like a binary chop enhanced by using gradients.
05:59:35 <SamB_XP_> is binary chop just a fancy word for binary search over a range of numbers?
05:59:54 <quicksilver> yes.
05:59:58 * mjrosenb thinks he knows how to do useful exception handling
05:59:59 <quicksilver> not really a fancy word, either.
06:00:31 <quicksilver> SamB_XP_: binary search somehow implies finite or at least locally finite, to me.
06:01:05 <quicksilver> SamB_XP_: binary chop is over an infinitely subdividable domain.
06:01:24 <quicksilver> it's a good general purpose algorithm for continuity.
06:01:32 <quicksilver> Indeed, it has been used as a definition for real numbers.
06:03:43 <chessguy> @bot
06:03:43 <lambdabot> :)
06:04:36 <Cale> > let f x = x^3 - 2*x + 2; f' x = 3*x^2 - 2; newt x = x - f x / f' x in iterate newt 0
06:04:37 <lambdabot>  [0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0...
06:06:26 <SamB_XP_> hmm. first time in a long time that mozilla's add-on update phase on startup actually managed to download all the updates...
06:06:31 <gwern-away> so I'm looking through Data.List, and I can't seem to see - is there no function which will like me make it act like lines, but splitting on empty lines and not merely newlines?
06:07:09 <vixey> filter (not.null) . lines or something ?
06:07:10 <quicksilver> no.
06:07:17 <quicksilver> there is no generalisation for lines or words.
06:07:21 <quicksilver> they are speshul.
06:07:30 <gwern> :(
06:07:46 <SamB_XP_> if there were, they would be of this type:
06:08:02 <gwern> quicksilver: you mean there is no generaliztion period, or just we don't have one defined?
06:08:04 <SamB_XP_> (a -> Bool) -> [a] -> [[a]]
06:08:14 <quicksilver> gwern: we don't have one defined.
06:08:17 <SamB_XP_> gwern: obviously the latter
06:08:18 <quicksilver> It is often requested.
06:08:20 <povman> ?djinn (a -> Bool) -> [a] -> [[a]]
06:08:20 <lambdabot> -- f cannot be realized.
06:08:29 <SamB_XP_> djinn doesn't understand lists
06:08:31 <quicksilver> I often speculate that it is because there are too many variations
06:08:32 <gwern> @hoogle (a -> Bool) -> [a] -> [[a]]
06:08:33 <lambdabot> Distribution.Simple.Utils.breaks :: (a -> Bool) -> [a] -> [[a]]
06:08:38 <SamB_XP_> because they are a recursive type
06:08:39 <quicksilver> and it's hard to guess the right one
06:08:43 <gwern> ...
06:08:47 <quicksilver> and design a good UI
06:08:50 <quicksilver> the variations are:
06:08:55 <gwern> so Cabal defines it. I would not have guessed
06:08:56 <SamB_XP_> it would certainly give you this definition if it tried to do anything:
06:08:58 <quicksilver> 1) include delimeters in result or not?
06:09:00 <vixey> > breaks (=='$') "thdaoeu$htauoedht$htdaedtaue$ae$aeouhdeut$aehotdau"
06:09:01 <lambdabot>   Not in scope: `breaks'
06:09:08 <SamB_XP_> f _ _ = []
06:09:09 <quicksilver> 2) coalesce adjacent delimeters or not?
06:09:10 <vixey> > Distribution.Simple.Utils.breaks (=='$') "thdaoeu$htauoedht$htdaedtaue$ae$aeouhdeut$aehotdau"
06:09:10 <mjrosenb> is there any way to say 'this doesn't return' as a type?
06:09:13 <lambdabot>   Not in scope: `Distribution.Simple.Utils.breaks'
06:09:16 <vixey> :[
06:09:19 <vixey> mjrosenb: No
06:09:26 <gwern> quicksilver: just imitate lines.
06:09:26 <quicksilver> 2) specifiy delimiters as [a], (a -> Bool) or ([a] -> Bool)
06:09:27 <vixey> mjrosenb: () is common
06:09:33 <gwern> > lines "foo\n\nbar"
06:09:33 <quicksilver> sorry, that's 3)
06:09:37 <lambdabot>  ["foo","","bar"]
06:09:43 <mjrosenb> vixey: not does not return a value... does not return
06:09:45 <gwern> , includes delimiter
06:09:51 <mm_freak_work> i've seen the efficiency of laziness come up a few times as a topic on usenetâ€¦  what do you think?  will disciple eventually win over haskell?
06:09:53 <quicksilver> gwern: lines + words are not consistent with each other.
06:10:08 <vixey> mjrosenb: there's no way to say that ....
06:10:16 <vixey> mjrosenb: People sometimes use ()
06:10:16 <mm_freak_work> will the next or a future haskell version be strict by default?
06:10:19 <gwern> quicksilver: they're not consistent with bytestring's versions either, iirc
06:10:24 <quicksilver> mjrosenb: forall a. a
06:10:30 <mjrosenb> i want the compiler to know that i have a value; which if it ever att
06:10:31 <SamB_XP_> words and lines take choice (1) as "not"
06:10:32 <vixey> > filter (not.null) . lines $ "foo\n\nbar"
06:10:33 <lambdabot>  ["foo","bar"]
06:10:34 <mjrosenb> err
06:10:41 <gwern> mm_freak_work: unlikely, and almost certainly not
06:10:44 <vixey> mjrosenb: You can't tell hte compiler that
06:10:48 <mjrosenb> quicksilver: can that be part of a datatype
06:10:48 <quicksilver> SamB_XP_: but they differ on (2)
06:11:08 <mjrosenb> or does it need to be quantified outside of the declaration
06:11:14 <quicksilver> and you can't tell about (3) because it's implicit.
06:11:24 <quicksilver> mjrosenb: you can, but it's likely you're not making sense.
06:11:26 <SamB_XP_> and (a -> Bool) would be the choice for (3) I would expect linesBy and wordsBy to take
06:11:33 <quicksilver> mjrosenb: can you specify a little more?
06:11:39 <vixey> mjrosenb: Maybe you want Cont Monad instead
06:11:44 <gwern>  > filter (not.null) . lines $ "foo\nfoo\nfoo\n\nbar" -- ideally I'd get [["foo", "foo", "foo"], ["bar"]] or something remiscent
06:11:55 <mjrosenb> vixey: yeah, i was trying to avoid using that
06:11:56 <SamB_XP_> since it would be, afaik, adequate to implement words and lines
06:12:01 <vixey> mjrosenb: why?
06:12:17 <quicksilver> SamB_XP_: what about leading/trailing delimeters?
06:12:21 <mm_freak_work> gwern: dunnoâ€¦  i somehow agreeâ€¦  i like laziness, but in most cases it's just in the way
06:12:31 <SamB_XP_> quicksilver: hmm, leading/trailing?
06:12:43 <SamB_XP_> > words "   foo"
06:12:45 <lambdabot>  ["foo"]
06:12:46 <quicksilver> SamB_XP_: in a way that's a bit like (2) adjaent delimeters
06:12:52 <quicksilver> as I say, it separates lines and words.
06:12:52 <SamB_XP_> > lines "\n\nfoo"
06:12:53 <lambdabot>  ["","","foo"]
06:12:55 <gwern> mm_freak_work: I think a lot of the advantages are hidden
06:12:57 <SamB_XP_> indeed
06:13:08 <SamB_XP_> lines would be a heck of a lot easier to generalize
06:13:10 <gwern> yay, inconsistency
06:13:16 <mjrosenb> i'm already going to be inside of a monad.  it will be ugly to work with a second monad
06:13:19 <SamB_XP_> > lines "foo\n"
06:13:21 <lambdabot>  ["foo"]
06:13:24 <quicksilver> mjrosenb: no it won't.
06:13:27 <SamB_XP_> but still not trivial
06:13:40 <quicksilver> mjrosenb: if you're already working in a monad that makes it much easier to add another.
06:13:53 <SamB_XP_> I almost wish lines demanded a final "\n" :-(
06:13:53 <quicksilver> mjrosenb: that's one of the advantages :)
06:13:54 <mjrosenb> quicksilver: howso?
06:14:01 <quicksilver> mjrosenb: because you're already using monadic style.
06:14:03 <SamB_XP_> > unlines ["foo"]
06:14:05 <lambdabot>  "foo\n"
06:14:12 <quicksilver> you just make your monad a bit deeper
06:14:24 <mjrosenb> quicksilver: i have not found this to be the case when working on a line of 10 operations, and needing to switch into a different monad
06:14:25 <gwern> @src lines
06:14:25 <lambdabot> Source not found. Maybe you made a typo?
06:14:28 <mjrosenb> or better yet
06:14:46 <mjrosenb> having a line of 10, and needing to put a different monad on every line
06:14:46 <SamB_XP_> well, "unlines . lines" is a minimal emacs replacement ;-P
06:14:52 <povman> for haskell' has anyone considered removing map from Data.List and renaming fmap to map?
06:15:03 <mm_freak_work> would a strict haskell still use monads?  i like that concept
06:15:09 <Cale> mm_freak_work: why not?
06:15:15 <quicksilver> mjrosenb: you don't put a different monad on every line
06:15:28 <quicksilver> mjrosenb: you design/use the monad which has all the functionality you need
06:15:30 <SamB_XP_> povman: we probably won't get it into haskell' due to issues with the package layout that are not yet resolved
06:15:31 <quicksilver> mjrosenb: and use it throught
06:15:33 <quicksilver> throughout
06:15:40 <SamB_XP_> and, er, with GHC's wired-in types
06:15:40 <quicksilver> at least, that's what you typically do.
06:15:44 <olsner> povman: I believe the "new name" for map, fmap, (<$>) and liftM is (.)
06:15:48 <mapreduce> quicksilver: Doesn't that have an n^2 problem?
06:15:51 <mm_freak_work> povman: i have, but a lot of people disagree here, because a list-special 'map' seems to be easier to comprehend for beginners
06:15:55 <vixey> > splitOn "" . splitOn '\n' $ "foo\nfoo\nfoo\n\nbar"
06:15:57 <lambdabot>  [["foo","foo","foo"],["bar"],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
06:15:59 <quicksilver> mapreduce: which?
06:16:00 <Cale> mapreduce: n^2 problem?
06:16:10 <SamB_XP_> povman: I don't expect we'll be able to fix the Monad heirarchy until GHC's base split is well along
06:16:12 <povman> but wouldn't it not break anything?
06:16:19 <mjrosenb> quicksilver: so if i have a Foo monad and a Maybe monad, and i want to use each of them with their independent properties?
06:16:26 <mm_freak_work> Cale: i've read about how disciple solves that
06:16:32 <quicksilver> mjrosenb: you use FooT Maybe or MaybeT Foo
06:16:33 <vixey> mjrosenb: Have you heard of monad transformer stacks?
06:16:37 <mm_freak_work> it doesn't use monads
06:16:39 <quicksilver> mjrosenb: depending which one is what you ned.
06:16:43 <mapreduce> Suppose programmers A and B each have code that uses different combinations of X, Y and Z.  You have AXY, AXZ, AYZ, AXYZ, BXY, BXZ, BYZ and BXYZ, potentially.
06:16:47 <SamB_XP_> GHC will also have to be a bit more flexible in terms of where it gets what are currently the Monad methods ;-)
06:16:54 <mm_freak_work> Cale: and a lot of people seem to prefer Clean's uniqueness types
06:16:56 <mapreduce> where X, Y and Z are monads.
06:16:57 <quicksilver> mapreduce: Yes. Is that a problem?
06:17:13 <Cale> mm_freak_work: I'd be seriously tempted to design an IO monad for clean.
06:17:16 <mapreduce> quicksilver: It looks like gratuitous amounts of names.
06:17:20 <quicksilver> mapreduce: couldn't I apply that to any program which uses multiple libraries?
06:17:40 <quicksilver> mapreduce: like having a name for every function is gratuitous amounts of names? ;)
06:17:42 <mapreduce> quicksilver: No, as you don't normally use two libraries by creating a third that wraps them both.
06:17:51 <SamB_XP_> and I think we may need to standardize the location of what goes into IO's Monad instance
06:17:54 * mjrosenb will use Monad.Cont for now
06:17:54 <quicksilver> no one is talking about creating a third library.
06:18:07 <Cale> mm_freak_work: Note that Clean and Disciple only solve the problem of what to do with IO, and not what to do with your parsing library, or nondeterminism.
06:18:26 <quicksilver> X provides XTrans, Y provides YTrans, you can choose to use XTrans Y or YTrans X
06:18:32 <mm_freak_work> Cale: i prefer monads, too, but it seems like Clean performs better than haskell in many regards
06:18:33 <quicksilver> there is no third library.
06:18:36 <mapreduce> I see.
06:18:49 <Cale> mm_freak_work: That's more to do with their compiler than anything.
06:18:54 <mm_freak_work> i've read that Clean's way of solving things gives the compiler much more information
06:19:06 <quicksilver> if you read SPJ's hair shirt talk
06:19:11 <quicksilver> which, of course, is only his opinion
06:19:18 <SamB_XP_> Cale: nice of them to volunteer to turn their compiler into a Haskell compiler, eh?
06:19:20 <quicksilver> it is clear that laziness is the thing he absolutely does not regret.
06:19:35 <Cale> SamB_XP_: Yeah, I heard something about that :)
06:19:36 <quicksilver> if he redesigned haskell from scratch 100 times, he would make it lazy 100 times.
06:19:43 <SamB_XP_> quicksilver: the thing that keeps us pure, yes
06:19:53 <quicksilver> right.
06:19:54 <SamB_XP_> it seems like laziness is a bit of a hair shirt itself ;-)
06:20:01 <quicksilver> well of course.
06:20:09 <quicksilver> Many worthwhile things are difficult.
06:20:13 <quicksilver> ;)
06:20:15 <quicksilver> sometimes.
06:20:19 <povman> so in haskell' (.) = fmap?
06:20:30 <Cale> povman: I wish :)
06:20:32 <quicksilver> I doubt it.
06:20:35 <SamB_XP_> what is the traditional purpose of the hair shirt?
06:20:38 <SamB_XP_> I forget atm...
06:20:39 <mm_freak_work> quicksilver: i agree with him about that, but others are right in that you'd use much less laziness annotations than you use strictness annotations right now
06:20:56 <SamB_XP_> povman: only in Cale's dreams
06:20:58 <Cale> povman: I've proposed it, but I'm not sure people are going to accept it. Put in a word for it on the haskell-prime mailing list if you like the idea :)
06:21:18 <SamB_XP_> I honestly don't want that to be the default ;-P
06:21:18 <povman> i can imagine it would not break anything and provide a bunch more flexibility
06:21:22 <vixey> why does Haskell' matter?
06:21:25 <mm_freak_work> Cale: i don't like the idea of (.) = fmap, because it's hardly comprehensible
06:21:36 <Cale> mm_freak_work: It's very comprehensible.
06:21:46 <vixey> @w80 comprehensible
06:21:47 <lambdabot> *** "comprehensible" wn "WordNet (r) 2.0"
06:21:47 <lambdabot> comprehensible
06:21:47 <lambdabot>      adj : capable of being comprehended or understood; "an idea
06:21:47 <lambdabot>            comprehensible to the average mind" [syn: {comprehendible}]
06:21:47 <lambdabot>            [ant: {incomprehensible}]
06:21:47 <Cale> mm_freak_work: It's just slightly different
06:22:18 <povman> i'm sick of writing Set.map, List.map Map.map all over the place
06:22:21 <mapreduce> comprehendible is reprehensible.
06:22:25 <quicksilver> mm_freak_work: I doubt that.
06:22:26 <mm_freak_work> Cale: would you use it for anything else than function composition?
06:22:29 <SamB_XP_> Cale: you know, that can actually be offered by an additional library, unlike fixing the Monad heirarchy...
06:22:31 <Cale> mm_freak_work: sure
06:22:33 <quicksilver> mm_freak_work: I have some 10s of thousands of lines of haskell.
06:22:41 <SamB_XP_> Cale: you can do it right now
06:22:42 <povman> mm_freak_work: it's meaning doesn't change
06:22:44 <Cale> mm_freak_work: I'd use it in the IO monad all the time if it was in the Prelude.
06:22:55 <quicksilver> mm_freak_work: and in that space I have perhaps 50 strictness annotations.
06:22:59 <SamB_XP_> Cale: write a module that exports your version of what Prelude should look like
06:23:00 <vixey> the Prelude is very irritating
06:23:02 <vixey> :t length
06:23:05 <lambdabot> forall a. [a] -> Int
06:23:09 <quicksilver> mm_freak_work: presumably if it was strict by default I'd have at least thousands of laziness annotations.
06:23:10 <SamB_XP_> call it CalePrelude
06:23:12 <Cale> SamB_XP_: It's still too annoying to have to use.
06:23:20 <mm_freak_work> quicksilver: true
06:23:28 <Cale> SamB_XP_: because you have to hide the prelude definitions in every module
06:23:32 <SamB_XP_> then we can write import Prelude (); import CalePrelude in our files
06:23:35 <vixey> -XBetterPrelude
06:23:35 <dmwit> SamB_XP_: Hair shirts were used in the Bible as a form of atonement for wrongdoing.
06:23:39 <mm_freak_work> Cale: could you name an example?
06:23:47 <quicksilver> Cale: arguably *that* is a deficiency of our module import system.
06:23:51 <Athas`> What's common Haskell practice for arrays: indexing from 0 or 1?
06:23:52 <SamB_XP_> dmwit: hmm. I thought that was called "sackcloth and ashes"
06:23:59 <Cale> mm_freak_work: Sure, almost anywhere that you presently use fmap.
06:24:00 <vixey> Athas`: eithers fine
06:24:03 <mm_freak_work> Athas`: there isn't any
06:24:06 <SamB_XP_> maybe they made their sacks of different stuff back then
06:24:13 <Cale> mm_freak_work: Huh?
06:24:20 <Cale> mm_freak_work: oh, there isn't a convention
06:24:23 <quicksilver> Cale: we should (1) fix the module import system so that you can easily experiment with alternate preludes.
06:24:32 <mm_freak_work> yes =)
06:24:33 <quicksilver> Cale: (2) experiment with excellent alternate preludes
06:24:33 <Cale> Athas`: Arrays have arbitrary ranges of indices.
06:24:44 <quicksilver> Cale: (3) download Calude and
06:24:45 <Cale> Athas`: they need not even be integers, necessarily.
06:24:48 <quicksilver> Cale: (4) profit.
06:24:52 <vixey> if you make a new Prelude make sure that [] Monad can be replaces
06:24:56 <mm_freak_work> > sin . Just 3
06:25:00 <Cale> Athas`: pairs of integers are common for 2D arrays, for example
06:25:00 <lambdabot>  Just 0.1411200080598672
06:25:15 <mm_freak_work> dunno, i like the fmap version better
06:25:20 <Athas`> Cale: I know, but if you create a plain two-dimensional table of integers (with no special semantic significant), would it be more common to index from (0,0) or (1,1)?
06:25:27 <mm_freak_work> maybe because i like words more than symbolic operators
06:25:29 <quicksilver> whatever suited your domain
06:25:43 <mm_freak_work> > fmap sin (Just 3)
06:25:43 <lambdabot>  Just 0.1411200080598672
06:25:44 <quicksilver> I use (0,0) when that is actually coordinates into R^2, probably
06:25:50 <mapreduce> mm_freak_work: Words get in the way when they're no longer relevant to your domain.
06:25:52 <Cale> mm_freak_work: You'd have things like  read . getLine  for readLn, rather than fmap read getLine
06:25:52 <quicksilver> but I'd use (1,1) if it was an exercise in number theory.
06:25:55 <Zao> > fmap sin Nothing
06:25:57 <lambdabot>  Nothing
06:26:02 <povman> mm_freak_work: the idea is to eliminate specific implementations of map all over the place
06:26:02 <Cale> (as a simple example)
06:26:07 <dmwit> Athas`: If there's no other meaning for your indices, why not use 0-based for consistency with all other languages?
06:26:20 <quicksilver> Athas`: Haskell frees you to make the indices what they want, so you can choose indices which actually mean something.
06:26:31 * quicksilver has arrays indexed into by "Faces of a cube"
06:26:40 <mm_freak_work> hmm
06:27:10 <Athas`> dmwit: that is what I intend to do, since the indices have no special meaning.
06:27:27 <mm_freak_work> Cale: that's exactly my concernâ€¦  it's not function composition anymore and is hence quite confusing, especially for beginners
06:27:31 <povman> Athas`: no special meaning? why are you using an array?
06:27:38 <mm_freak_work> beginners expect something like (read . getLine) not to work
06:27:42 <SamB_XP_> I might not use a base
06:27:53 <Athas`> povman: for efficient lookup.
06:27:53 <vixey> stop worrying about beginners
06:27:58 <SamB_XP_> perhaps my domain would include pairs with negative integers in them?
06:27:59 <Cale> mm_freak_work: and there might be a bit of surprise when it does, but it's a good learning experience
06:28:24 <Athas`> I didn't assume Haskell list indexing was O(1). Was that assumption wrong?
06:28:29 <SamB_XP_> Cale: the "import CalePrelude" would make it clear that there was something up ;-)
06:28:35 <vixey> It's O(n)
06:28:38 <povman> Athas`: surely your numbers mean something somewhere
06:28:40 <vixey> @src (!!)
06:28:40 <lambdabot> xs     !! n | n < 0 = undefined
06:28:40 <lambdabot> []     !! _         = undefined
06:28:40 <lambdabot> (x:_)  !! 0         = x
06:28:40 <lambdabot> (_:xs) !! n         = xs !! (n-1)
06:28:42 <Cale> Note also the functor law that   fmap (f . g) x = fmap f (fmap g x),  that if you rewrite that law using (.) instead of fmap, you get  (f . g) . x = f . (g . x)
06:28:44 <mm_freak_work> Cale: it makes sense to give an fmap operator, but i wouldn't substitute (.) for it
06:28:47 <quicksilver> Athas`: no, but Data.Map is a better choice for efficient lookup in most cases.
06:28:50 <Athas`> povman: no, it's an exercise, they're just integers.
06:28:56 <povman> oh ok :D
06:28:58 <Cale> SamB_XP_: Why not just make it the default?
06:29:05 <SamB_XP_> Cale: with your change, would we then have a "compose" function that had the type (.) used to have?
06:29:13 <Cale> SamB_XP_: Why?
06:29:19 <SamB_XP_> for teaching
06:29:24 <mm_freak_work> Cale: it's about the same as dropping 'map' in favor of 'fmap'
06:29:30 <SamB_XP_> mm_freak_work: not really
06:29:36 <Cale> SamB_XP_: I think there ought to be a teaching Prelude, but it shouldn't be our main one :)
06:29:42 <SamB_XP_> that's just reverting an existing change
06:29:49 <Cale> SamB_XP_: Also, different teachers like to teach things differently.
06:29:51 <mm_freak_work> SamB_XP_: which one?
06:29:58 <Cale> Personally, I wouldn't mind teaching about functors early on :)
06:30:15 <Cale> mm_freak_work: map used to be fmap
06:30:22 <mm_freak_work> ah, ok
06:30:24 <SamB_XP_> Cale: true, but I don't think having a compose function in Prelude (or Data.Function?) would hurt...
06:30:33 <Cale> SamB_XP_: Sure, it wouldn't hurt.
06:30:48 <SamB_XP_> and it would be handy for showing to newbies
06:30:57 <SamB_XP_> already we have to use P.. in here
06:31:05 <mm_freak_work> wellâ€¦  most people are just not curious and patient enough to learn all that
06:31:09 <SamB_XP_> (which has a decidedly ugly look...)
06:31:44 <Cale> mm_freak_work: Because we'd still have that (f . g) . x = f . (g . x), you have a nice guarantee that when you're trying to figure out what functor instance is being used, you only have to look at the type of the last thing in a composition chain.
06:31:51 <Cale> mm_freak_work: All the others must be functions.
06:32:09 <Cale> mm_freak_work: They're already learning Haskell :)
06:32:27 <povman> my code has become beautiful since i learned about <$>
06:32:34 <povman> it's such a pretty operator
06:32:36 <SamB_XP_> teach me
06:32:37 <mm_freak_work> @src <$>
06:32:37 <lambdabot> f <$> a = fmap f a
06:32:55 * SamB_XP_ has been sadly negligent wrt Applicative
06:33:00 <mm_freak_work> > sin <$> Just 3
06:33:11 <lambdabot>  Just 0.1411200080598672
06:33:13 <SamB_XP_> @type (<$>)
06:33:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:33:22 <Cale> It's yet-another-fmap
06:33:31 <SamB_XP_> oh, that's not even Applicative proper
06:33:36 <Cale> right
06:33:41 <SamB_XP_> that's just an applicative-style name
06:34:00 <SamB_XP_> @index <$>
06:34:00 <lambdabot> bzzt
06:34:13 <SamB_XP_> @index (<$>)
06:34:13 <lambdabot> bzzt
06:34:15 <quicksilver> looks nice though
06:34:24 <quicksilver> lns <- lines <$> readFile "foo.txt"
06:34:39 <Cale> I'd still prefer to be able to write
06:34:45 <Cale> lns <- lines . readFile "foo.txt"
06:34:55 <quicksilver> sure.
06:35:06 <quicksilver> so would I.
06:35:10 <vixey> words . lines . readFile "foo.txt"
06:35:15 <vixey> it composes !
06:35:15 <vixey> aoe
06:35:18 <quicksilver> But I do agree that polymorphism is confusing until you understand it.
06:35:36 <quicksilver> in particular, vixeys example is a good one.
06:35:44 <vixey> the confusing bit is that there's two kinds of polymorphism
06:35:45 <Cale> vixey: I'm pretty sure that you need a map there
06:35:51 <povman> > Just (*2) <*> Just [1,2,3,4]
06:35:53 <lambdabot>   add an instance declaration for (Num [t])
06:35:54 <quicksilver> yes I think he does
06:35:57 <mm_freak_work> lns <- liftM lines $ readFile "foo.txt"  -- that's how i used to code it
06:35:59 <quicksilver> but I don't think that's the point :)
06:36:01 <SamB> oh good...
06:36:12 <povman> > Just (*2) <*> Just 3
06:36:13 <lambdabot>  Just 6
06:36:21 <povman> > Nothing <*> Just 3
06:36:23 <lambdabot>  Nothing
06:36:42 <povman> > Just (*2) <*> Nothing
06:36:44 <lambdabot>  Nothing
06:36:46 <povman> ...
06:36:56 <mm_freak_work> > [*2] <*> [2,3,4]
06:36:56 <lambdabot>  Parse error at "*2]" (column 2)
06:37:02 <mm_freak_work> > [(*2)] <*> [2,3,4]
06:37:04 <lambdabot>  [4,6,8]
06:37:09 <mm_freak_work> > [(*2),(*3)] <*> [2,3,4]
06:37:11 <lambdabot>  [4,6,8,6,9,12]
06:37:21 <SamB> somehow my emacs-under-screen has stopped showing signs of confusion regarding the locations of unicode characters in the terminal window
06:37:42 <mm_freak_work> @src (<*>)
06:37:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:37:57 <povman> mm_freak_work: it's in class Applicative
06:38:04 <mm_freak_work> ah, ok
06:38:11 <povman> > Just True <|> Nothing
06:38:13 <lambdabot>  Just True
06:38:23 <povman> > Just True <|> Just False
06:38:25 <lambdabot>  Just True
06:38:31 <povman> > Nothing <|> Just False
06:38:33 <lambdabot>  Just False
06:39:34 <SamB> too bad it still won't accept things like â‡‹ via SCIM :-(
06:40:09 <vixey> yes
06:40:19 <vixey> it would be nice if you could choose which unicode characters are upper and lowercase
06:40:40 <Cale> Unicode specifies that, iirc.
06:40:41 <vixey> it's really sort of useless currently
06:40:56 <vixey> Cale: yeah but it doesn't specify it exactly the way I want
06:41:01 <Cale> oh?
06:41:19 <vixey> sometimes I would like symbols lowercase other times uppercase ..
06:41:48 <SamB> it would also be nice if Haskell would let you use uncased letters
06:42:15 <SamB> in theory, anyway
06:44:09 <vixey> something like infix would be good
06:44:33 <vixey> (to declare what case haskell should interpret a symbol for this module)
06:49:23 <swiert> @seen mattam
06:49:23 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
06:49:42 <swiert> hmm. That's unfortunate.
06:49:56 <vixey> preflex: seen mattam
06:49:56 <preflex>  mattam was last seen on #haskell 21 hours, 58 minutes and 25 seconds ago, saying: The point would be that the derived propositional equality on coinds would be bisimulation, I'm not sure about the definitional one, not much is decidable there.
06:52:45 <ziman> > Nothing `mplus` Just False
06:52:54 <lambdabot>  Just False
06:55:23 <Taggnostr> is there something like python's dir() and help() in haskell?
06:55:58 <kpreid> Taggnostr: in ghci, :browse, :info
06:56:12 <kpreid> hoogle links to docs
06:57:01 <Taggnostr> thanks
07:12:11 <BONUS> how would you guys get the all the diagonals of a matrix?
07:12:28 <BONUS> i've found a way but its rather inelegant and off by one
07:12:31 <BONUS> what i mean is if you have
07:12:57 <BONUS> [[2,1],[3,4]] that it produces [[2],[3,1],[4]]
07:13:19 <Cale> Oh, the antidiagonals then.
07:13:27 <BONUS> yeah
07:13:29 <Cale> hmm
07:14:29 <Deewiant> [[7,8,9],[4,5,6],[1,2,3]] to [[7],[8,4],[9,5,1],[6,2],[3]] ?
07:14:29 <BONUS> i wrote one function to do it but like i said, its butt ugly and usually leaves out exactly one diagonal :[
07:14:39 <Cale> Deewiant: yeah
07:14:41 <BONUS> yeah
07:14:50 <Deewiant> hmm
07:15:37 <BONUS> if you knock that 7 out of the first row and then take the first 2 elements of the first column you get [8,4]
07:15:59 <BONUS> if you then knock out the 8 and 4 out of the first two rows and take the first 3 elements of the first column you get 9,5,1
07:16:10 <Cale> So you need an extra number to start with to tell you how many rows to steal from.
07:16:14 <BONUS> thats something i've figured out but i dont know if its useful
07:16:29 <Cale> Alternately, you could just stuff everything into an array and then index it cleverly.
07:16:35 <BONUS> hmm
07:16:45 <BONUS> that could work yeah
07:17:04 * Dae thanks the ghc guys for the profiler
07:17:17 <Cale> The row and column indices add to a constant along any one antidiagonal.
07:17:37 <BONUS> hmm
07:17:45 <Cale> However, that works only if your list of lists is rectangular.
07:17:58 <BONUS> yeah, i was thinking on rectangular matrices
07:19:14 <Cale> and there are n + m - 1 such diagonals, where n is the number of rows, and m the number of columns.
07:20:26 <BONUS> yeah thats true
07:21:15 <BONUS> im probably gonna find some clever way to address array indices
07:21:22 <BONUS> gonna use pairs for the indices and then work from there
07:24:36 <Cale> diagonals xs = diag 1 xs
07:24:36 <Cale> diag n [] = []
07:24:36 <Cale> diag n ([]:xs) = diag n xs
07:24:36 <Cale> diag n xs = (ys >>= take 1) : diag (n+1) (map (drop 1) ys ++ zs)
07:24:36 <Cale>     where (ys,zs) = splitAt n xs
07:24:42 <Cale> Or you could do something like that
07:25:41 <matthew-_> would intersection on Data.Sequence be more efficient than on Data.Set or is Data.Set known optimal?
07:25:52 <matthew-_> the paper says merge on Sequence is O(m log(m/n)) so I don't see why intersection would be worse. Intersect on Data.Set is O(m + n).
07:27:12 <quicksilver> well O(m log(m/n)) and O(m+n) are relatively hard to compare.
07:27:16 <BONUS> Cale wow thats cool
07:27:26 <matthew-_> quicksilver: yeah, that's what I'm just graphing
07:27:27 <matthew-_> badly
07:27:28 <quicksilver> critical point is when n = (log 2) m
07:27:31 <quicksilver> or something ?
07:28:08 <matthew-_> I can't remember those rules ... drawing pictures is easier ;)
07:31:00 <Cale> m + n = m log(m/n) when m = n / W(1/e), where W(1/e) is about 0.278
07:33:13 <matthew-_> right, they're all the same then
07:33:54 <matthew-_> actually, no
07:34:31 <matthew-_> when n and m are big, the difference is substantial to the favour of the sequence version
07:36:03 <Deewiant> when n is big, rather
07:36:14 <jon_of_arc> Yep
07:36:21 <Deewiant> if m >> n then Set is faster
07:36:41 <matthew-_> but not to the same extent
07:37:23 <Deewiant> > let a m n = m + n; b m n = m * log (m/n) in map ($ (15000, 100)) [uncurry a, uncurry b]
07:37:25 <lambdabot>  [15100.0,75159.52941144383]
07:37:35 <Deewiant> > let a m n = m + n; b m n = m * log (m/n) in map ($ (15000, 10000)) [uncurry a, uncurry b]
07:37:37 <lambdabot>  [25000.0,6081.976621622466]
07:38:24 <matthew-_> ahh, but from the paper:
07:38:24 <matthew-_> "                                             It can be shown that merge is asymp-
07:38:24 <matthew-_> totically optimal: it takes Î˜(m log(n/m)) amortized time where m and n are the
07:38:24 <matthew-_> lengths of the shorter and longer input sequences respectively
07:38:26 <matthew-_> "
07:38:45 <matthew-_> so n is always > m
07:39:13 <matthew-_> or at least >=
07:39:16 <Deewiant> > let a m n = m + n; b m n = m * log (m/n) in map ($ (10000, 15000)) [uncurry a, uncurry b]
07:39:18 <lambdabot>  [25000.0,-4054.6510810816444]
07:39:20 <Deewiant> > let a m n = m + n; b m n = m * log (m/n) in map ($ (100, 15000)) [uncurry a, uncurry b]
07:39:21 <lambdabot>  [15100.0,-501.0635294096256]
07:39:36 <Deewiant> hmm, negative time :-)
07:39:40 <matthew-_> Deewiant: that's n / m, not m / n
07:39:55 <quicksilver> negative running time is great
07:39:57 <Deewiant> oh, you posted m/n earlier
07:40:04 <matthew-_> Deewiant: then I'm a fool
07:40:06 <Deewiant> > let a m n = m + n; b m n = m * log (n/m) in map ($ (100, 15000)) [uncurry a, uncurry b]
07:40:08 <lambdabot>  [15100.0,501.0635294096256]
07:40:09 <Deewiant> > let a m n = m + n; b m n = m * log (n/m) in map ($ (10000, 15000)) [uncurry a, uncurry b]
07:40:11 <lambdabot>  [25000.0,4054.651081081644]
07:40:12 <quicksilver> I have a solution to the backpack problem which runs in O(-m^3)
07:40:12 <Deewiant> heh
07:40:15 <quicksilver> I'm going to patent it.
07:40:25 <Deewiant> alright, seems to be asymptotically quite a bit better
07:40:38 <Deewiant> matthew-_: but don't forget about constant factors!
07:40:39 <mauke> O(log n + m*i)
07:40:43 <Deewiant> benchmark it if it matters
07:40:45 <quicksilver> mauke wins.
07:40:46 <matthew-_> so, it's just a shame that Data.Sequence seems to be a crippled version
07:41:01 <matthew-_> Deewiant: sure, some benchmarking will be required
07:42:03 <matthew-_> ahh, the version on hackage is the richer one
07:43:49 <obk> Is there a way to match a constructor without also specifying the # of parameters? E.g. if I have data FooBar = Foo { foo1 :: Type1, foo :: Type2, ... } | Bar { ... }, then define a function doSomething foo@Foo = ... instead of doSomething foo@(Foo _ _ ...) = ... ?
07:44:19 <_zenon_> Foo { }
07:44:21 <_zenon_> i think
07:44:28 <ziman> a constructor has always a constant number of parameters, doesn't it?
07:44:30 <EvilTerran> yep
07:44:36 <Deewiant> doSomething foo@(Foo{})
07:44:36 <EvilTerran> Foo{}
07:44:57 <mauke> doSomething foo@Foo{}  -- OPTOMIZED
07:44:58 <EvilTerran> even works for constructors that aren't declared as records, owing to a happy coincidence in the wording in the spec
07:44:59 <Cale> matthew-_: Yeah, people always ask for things like priority queues and it's annoying that we have Data.Sequence, but not the nice finger-tree implementation of PQ's.
07:45:30 <_zenon_> mor on this here if you want    http://en.wikibooks.org/wiki/Haskell/Pattern_matching
07:45:55 <EvilTerran> Sets make for pretty good PQs, don't they?
07:46:12 <mauke> sets? how?
07:46:16 <Deewiant> not ordered
07:46:17 <EvilTerran> or Maps
07:46:40 <EvilTerran> ?hoogle findMin
07:46:41 <lambdabot> Data.Set.findMin :: Set a -> a
07:46:41 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
07:46:41 <lambdabot> Data.IntSet.findMin :: IntSet -> Int
07:46:49 <obk> ziman: Each one, sure, bt if you have data SomeThing = Many | Possible | Ones | Each | With | Different | Number
07:46:49 <EvilTerran> they're ordered :P
07:46:56 <EvilTerran> O(log n)
07:47:09 <Deewiant> oh right, because they're trees and not hash tables
07:47:36 <obk> _zenon_: Thanks! Obvious in retrospect :-)
07:47:38 <EvilTerran> i imagine a good PQ implementation would have O(1) findMin, but (log n)'s practically a constant factor anyway :P
07:47:39 <Deewiant> so yeah, that way they're like binary heaps
07:47:57 <Deewiant> fibonacci heaps are the classic 'complicated' PQ implementation
07:47:58 <_zenon_> obk: no problem :) Always lovely to help ;)
07:49:51 <mauke> you can just put a cache in front of your PQ to get O(1) findMin
07:50:34 <mauke> also, http://search.cpan.org/src/MAUKE/Data-PrioQ-SkewBinomial-0.03/lib/Data/PrioQ/SkewBinomial.pm
07:50:36 <lambdabot> http://tinyurl.com/6m5xwr
07:50:38 <Cale> O(log n) is the same thing as O(1) anyway :)
07:50:51 <Deewiant> >_<
07:50:53 <Cale> There are no truly O(1) operations, except ones which don't access anything :)
07:51:37 <quicksilver> nop; # O(1)
07:52:31 <Deewiant> O(word size) is close enough to O(1) :-P
07:52:59 <quicksilver> it is.
07:53:08 <quicksilver> but it's also no closer than any other flavour of O(log n)
07:53:09 <Deewiant> but anything bigger isn't. ;-)
07:53:20 <quicksilver> ergo, all flavours of O(log n) are close enough to O(1).
07:53:54 <Cale> log(n) is bounded by the word size
07:54:39 <mauke> > 658000 ** (1/3)
07:54:40 <lambdabot>  86.97784259800092
07:55:42 <ToRA> there isn't anything in the stdlib isomorphic to data Id x = Id x is there?
07:55:58 <mauke> @src Identity
07:55:59 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
07:56:07 <ToRA> ta
07:56:07 <mauke> @index Identity
07:56:07 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
07:58:13 <_zenon_> you will need . The Monad Template Library
08:00:43 <BMeph> Hmm? Is mtl in extralibs?
08:01:01 <Deewiant> isn't it in the base libs
08:01:13 <_zenon_> I had to grab it with apt get
08:01:49 <_zenon_> libghc6-mtl-dev - Haskell monad transformer library for GHC
08:08:18 <hpaste>  Peaker pasted "Design question" at http://hpaste.org/8636
08:10:21 <PeakerWork> can anyone look at my problem -- what can I use instead of a "finalized" (in Java terminology?) IntDelta type - that still lets people write code for various kinds of deltas that anyone can write?
08:12:41 <vixey> @bot
08:12:41 <lambdabot> :)
08:12:52 <therp> if I get your question correctly use type classes
08:12:57 <vixey> > 1+1
08:12:58 <lambdabot>  2
08:14:34 <quicksilver> PeakerWork: who is going to provide the function : dt -> (t->t)
08:14:40 <PeakerWork> therp, the problem with that is that you can't "pattern match" the types then
08:14:42 <quicksilver> PeakerWork: which is required to calculate with the delta.s
08:14:45 <quicksilver> and "when".
08:14:53 <PeakerWork> quicksilver, each new delta type implementor
08:14:57 <hpaste>  bd_ annotated "Design question" with "PeakerWork, how's this look? (untested)" at http://hpaste.org/8636#a1
08:15:06 <bd_> that'll need the fundeps extension
08:15:25 <bd_> incidentally, these deltas could form a monoid too
08:15:46 <quicksilver> then it is probably type classes you want, yes.
08:16:34 <hpaste>  bd_ annotated "Design question" with "alternate approach" at http://hpaste.org/8636#a2
08:16:47 <bd_> :)
08:19:03 <PeakerWork> bd_, Not sure - that makes NumDelta always be AddDelta?
08:19:11 <PeakerWork> (NumAdd that is)
08:19:58 <bd_> PeakerWork: It can be whatever you want
08:20:09 <bd_> eg: mulDelta n = Delta . (* n)
08:20:12 <PeakerWork> quicksilver, probably part of the Delta class (applyDelta)
08:20:29 <bd_> my second example is just a delta function wrapped in a newtype
08:20:47 <Taggnostr> can I define a function to accept both an int and a list or just an int?
08:21:57 <quicksilver> Taggnostr: sure
08:22:08 <quicksilver> f : Either (Int,[Int]) Int -> blah
08:22:09 <BMeph> Taggnostr: That doesn't sound like it makes sense. You could, though, define a type class with both lists and Ints, and define a function that does whatever for each type.
08:23:11 <BMeph> Assuming, you want the list to be a list of Ints, and not, say a String, of a list of Floats... ;)
08:23:29 <quicksilver> surely an Either is a bit more lightweight than a typeclass :P
08:23:32 <hpaste>  bd_ annotated "Design question" with "the second form becomes a monoid (so does the first if you give it a zero element)" at http://hpaste.org/8636#a3
08:24:06 <bd_> quicksilver: depends on how and if it's inlined, I'd think
08:24:21 <quicksilver> bd_: I'm not answering PeakerWork I'm answering Taggnostr
08:24:24 <BMeph> Inlining FTW! :)
08:24:25 <quicksilver> bd_: different question :)
08:24:37 <bd_> quicksilver: still! :)
08:24:38 <Taggnostr> I'm trying to do a function that accepts an int and return its digits as a list of ints, like 123 -> [1,2,3]
08:24:50 <quicksilver> and I meant conceptually lightweight not implementation.
08:25:04 <bd_> :t digitToInt
08:25:11 <bd_> lambdabot?
08:25:16 <lambdabot> Char -> Int
08:25:26 <bd_> !botsnack
08:26:04 <_zenon_> Taggnostr: Pick out the 1's, 10's and 100's and so forth with modulo
08:26:13 <Taggnostr> so far I did "let int2list n (xs) = if n < 10 then n:xs else (int2list (n `div` 10) ((n `mod` 10):xs))", but it doesn't work, but at least it doesn't return any error when I declare it
08:26:33 <Cale> > take 10 $ iterate (`div` 10) 123
08:26:34 <Taggnostr> with [xs] instead of (xs) it returns an error
08:26:35 <lambdabot>  [123,12,1,0,0,0,0,0,0,0]
08:26:53 <Cale> > takeWhile (/= 0) . iterate (`div` 10) $ 123
08:26:58 <lambdabot>  [123,12,1]
08:27:00 <BMeph> Taggnostr: (Numeric.)showInt does that. :)
08:27:07 <bd_> > (map digitToInt . show) 12345
08:27:09 <lambdabot>  [1,2,3,4,5]
08:27:24 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 123
08:27:26 <lambdabot>  [3,2,1]
08:27:31 <BMeph> Taggnostr: However, if you're doing it just to get a grip on the language, then go ahead. :)
08:27:39 <Taggnostr> yep
08:27:55 <Taggnostr> what is wrong in what I did?
08:28:15 <Cale> > let int2list n (xs) = if n < 10 then n:xs else (int2list (n `div` 10) ((n `mod` 10):xs)) in int2list 123
08:28:16 <lambdabot>  <[Integer] -> [Integer]>
08:28:24 <Cale> > let int2list n (xs) = if n < 10 then n:xs else (int2list (n `div` 10) ((n `mod` 10):xs)) in int2list 123 []
08:28:25 <bd_> > let int2list n (xs) = if n < 10 then n:xs else (int2list (n `div` 10) ((n `mod` 10):xs)) in int2list 123 []
08:28:26 <lambdabot>  [1,2,3]
08:28:27 <lambdabot>  [1,2,3]
08:28:33 <bd_> heh
08:28:34 <bd_> works?
08:28:40 <Cale> It appears to :)
08:28:43 <_zenon_> hehe
08:28:57 <Cale> > let int2list n (xs) = if n < 10 then n:xs else (int2list (n `div` 10) ((n `mod` 10):xs)) in int2list 57319824 []
08:28:59 <lambdabot>  [5,7,3,1,9,8,2,4]
08:29:03 <bd_> the explicit tail recursion is typically bad style for haskell, though (with laziness it doesn't help as much as you'd think)
08:29:15 <BMeph> Taggnostr: Just as an FYI, [xs] is a singleton list with the value of xs "in the first spot".
08:29:50 <Taggnostr> what do you mean? with just an element?
08:29:53 <_zenon_> yes
08:30:01 <_zenon_> the element could however be a list
08:30:11 <bd_> > [[[[[[[[[[0]]]]]]]]]]
08:30:13 <lambdabot>  [[[[[[[[[[0]]]]]]]]]]
08:30:17 <BMeph> > flip Numeric.showInt "" 407893473
08:30:19 <lambdabot>  "407893473"
08:30:40 <bd_> BMeph: why not just show? :)
08:30:52 <ak47> hi, anybody knows if cabal is able to handle proxy and how i should feed the setting to him (on linux exporting http_proxy doesn't seem to be enough)
08:30:58 <bd_> with inlining and whatnot I'd be surprised if explicit showInt was any more efficient
08:31:20 <BMeph> bd_: Er, because I was confused as to what showInt actually does? :)
08:31:48 <Taggnostr> and what's wrong with let int2list n = int2list (n `div` 10) [n `mod` 10] ?
08:31:49 <BMeph> > map digitToInt . show $ 407893473
08:31:50 <lambdabot>  [4,0,7,8,9,3,4,7,3]
08:32:32 <bd_> oh, fair enough :)
08:32:39 <bd_> > showInt 40852323 "foo"
08:32:40 <lambdabot>  "40852323foo"
08:32:57 <bd_> Silly standards writers and their micro-optimizations :)
08:34:40 <Taggnostr> if I do let int2list n = int2list (n `div` 10) [n `mod` 10], shouldn't it use the definition of int2list n (xs)?
08:35:00 <Cale> bd_: Well, it is a matter of complexity at least :)
08:35:55 <BMeph> Taggnostr: What's wrong there, is you're using a "one-argument function" (LHS) as if it were a "two-argument function" on the RHS.
08:36:12 <Saizan> Taggnostr: no.. the int2list on the LHS refers to the int2list you're defining, to get overloading like that you need typeclasses
08:36:22 <PeakerWork> bd_, if you use the alternate approach, how can convertDelta work?
08:36:24 <Saizan> s/LHS/RHS/
08:36:32 <Taggnostr> uhm
08:36:50 <zeno> has adding "default values" to functions ever been concidered? e.g. f x (y=10)=x+y;> f 5=15.
08:36:59 <PeakerWork> bd_, Note I am trying to have the "delta conversion" lose as little information as possible. If it has to treat the delta as an opaque function/replacement of the value then it lost all useful information
08:37:00 <_zenon_> (\x -> show x >>= \y -> digitToInt y:[]) 323131
08:37:06 <_zenon_> am I too late? ooo
08:37:38 <_zenon_> > (\x -> show x >>= \y -> digitToInt y:[]) 323131
08:37:40 <lambdabot>  [3,2,3,1,3,1]
08:37:51 <Taggnostr> what zeno said would be nice, does it work?
08:38:38 <PeakerWork> quicksilver, if I use typeclasses, can I pattern-match things like convertDelta does?
08:38:41 <BMeph> Taggnostr: This isn't overloading the function here, but partial application - you're using a function that "takes more arguments," but not specifying them. If you changed (xs) into .(++xs), or something like that semantically (am I using that right? :), it'd work.
08:39:39 <igel> zeno: and what's the type of (f 3)?
08:39:45 <igel> Int or Int -> Int?
08:40:03 <zeno> would be a different function with the same name, i see how that could cause problems
08:40:09 <PeakerWork> quicksilver, I mean, if IntDelta is a typeclass, and IntAdd and IntMultiply are both type instances of that class, how can a function handle either case?
08:40:17 <PeakerWork> quicksilver, (other than using Typeable casts)
08:40:30 <zeno> igel: would be Int
08:40:38 <Taggnostr> I first did let int2list n (xs) = ...; and then let int2list n = int2list int list; assuming that the second will use the first declaration of int2list when it see that there are 2 args
08:41:01 <igel> zeno: and how do you address the original (2 parameter) function?
08:41:11 <igel> eg in zipWith f
08:41:11 <quicksilver> PeakerWork: IntDelta isn't a typeclass
08:41:17 <quicksilver> PeakerWork: IntDelta is an *instance*
08:41:25 <quicksilver> PeakerWork: the general notion of delta is the typeclass.
08:41:41 <igel> the problem is, that "f" has an ambigous type
08:42:05 <igel> which is (afaik) the reason why there's no function overloading
08:42:13 <_zenon_> have to go home
08:42:17 <PeakerWork> quicksilver, but isn't that already the way it was in my example?
08:42:26 <_zenon_> return _zenon
08:42:44 <zeno> igel: you could make some syntatic sugar that f^ is f using a default, f^^ using 2
08:42:51 <PeakerWork> quicksilver, I have a Delta class - and IntDelta is an instance. But if IntDelta is an instance, then Add/Multiply are the operations it can express. I want other people to be able to add new types of IntDeltas (Int->Int) except (+x) and (*x)
08:42:57 <igel> that might work
08:43:09 <zeno> then different functions so no ambiguous types
08:43:35 <ak47> anybody here using cabal behind proxy ? seems like it should be supported (seen some mails from late 2007) but i have no luck so far ...
08:43:39 <ak47> tried setting http_proxy and HTTP_PROXY, ping can resolve the host name, but cabal reports getHostByName: does not exist (no such host entry)
08:44:45 <quicksilver> PeakerWork: ah I didn't understand that to be your question.
08:45:09 <quicksilver> PeakerWork: you're right in thinking that you can't have extensible ADTs in this sense.
08:45:21 <PeakerWork> quicksilver, Except with Typeable?
08:45:21 <quicksilver> after all you could write a case expression in one file which looked like a complete case
08:45:28 <quicksilver> and then something be added in another file.
08:45:34 <quicksilver> Typeable doesn't give you an extensible ADT>
08:45:51 <quicksilver> it gives you a way of storing a type in a type-neutral container.
08:46:37 <igel> zeno: btw, i think i've seen a workaround for default parameters:
08:46:44 <zeno> igel: could even get fancy, f (y=1) (z=5) = x-y; f^^ = -4;f^ 7=2;f~^ 7=-6
08:46:55 <PeakerWork> quicksilver, they idea is that the delta types are layered. Meaning that if someone adds a new (Int->Int) delta type, as part of making it an IntDelta instance he'd specify how it is converted to an IntReplace (a simple (const x)) so that anyone who handles IntReplace can handle any delta. At worst, it would have to be converted to IntReplace
08:47:31 <igel> let the first parameter be a struct holding all "actual" parameters
08:47:33 <PeakerWork> quicksilver, So any int delta can be represented as an IntReplace, but that loses information - and preferrably you can get the full information, and only when impossible, use an IntReplace
08:47:47 <igel> and define a defaultstruct
08:48:04 <quicksilver> PeakerWork: you can certainly do that, yes.
08:48:07 <igel> then you can call "f (defaultstruct { foo = bar})"
08:48:24 <igel> and everything but the "foo" field will be set as in defaultstruct
08:48:36 <igel> of course that's not beautiful at all
08:48:48 <BMeph> Taggnostr: Your int2list are both the same function - Haskell does not do the "different argument declarations means it is a different function" ting. :)
08:48:57 <zeno> igel: my idea could be done with just a macro i think
08:49:07 <zeno> and might be quite convenient :)
08:49:11 <BMeph> s/int2list/int2list declarations/
08:49:12 <kevinEllis> Hi, does anyone here know what "rigid types" are in GHC? (something relating to type classes?) I'm getting errors relating to them, and I have no idea how to fix them.
08:49:39 <igel> zeno: write a patch ;)
08:50:01 <Taggnostr> but is the problem that I'm using int2list with 2 arguments in the RHS where in the LHS it has only one?
08:50:10 <BMeph> kevinEllis: It means that you're using something declared in a way that disagrees with how you just defined it. Hpaste may help us point out what specifically is the problem. :)
08:50:15 <zeno> igel: does a GHC extension, or jsut a haskell macro sound better to you??
08:50:44 <Cale> kevinEllis: Well... probably you can ignore the term 'rigid'
08:50:54 <kevinEllis> BMeph: Here's the hpaste, someone (sort of) answered the question but I don't really understand it.... http://hpaste.org/8581
08:50:56 <igel> zeno: i have no clue, nether patched ghc
08:51:08 <igel> never^^
08:51:39 <Taggnostr> maybe I'm doing something wrong
08:51:59 <Cale> kevinEllis: A rigid type variable is the usual sort :)
08:52:31 <zeno> this seems like how to do it -> http://www.haskell.org/haskellwiki/Template_Haskell
08:52:31 <lambdabot> Title: Template Haskell - HaskellWiki
08:52:33 <Cale> kevinEllis: Your errors probably have to do with your function's implementation being less polymorphic than the type signature suggests.
08:52:46 <mar77a> what module should i use to parse binary data
08:52:49 <Cale> kevinEllis: If you'll hpaste the code, I can have a look
08:52:50 <mar77a> "unpacking"
08:52:54 <mar77a> @hoogle unpack
08:52:54 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
08:52:54 <lambdabot> Data.ByteString.Char8.unpack :: ByteString -> [Char]
08:52:54 <lambdabot> Data.ByteString.Lazy.unpack :: ByteString -> [Word8]
08:53:00 <kevinEllis> http://hpaste.org/8581
08:53:03 <mar77a> mm
08:53:10 <Taggnostr> if I declare 2 function that accepts different parameters, will the last overwrite the first if they have the same name?
08:53:48 <quicksilver> it will be an error
08:53:52 <quicksilver> in the same scope
08:53:52 <mar77a> compile time error?
08:53:56 <quicksilver> yes.
08:54:08 <quicksilver> in enclosing scopes it's perfectly legal and the inner one takes precedence.
08:54:12 <Dae> Does someone know... will ghc always allocated all the ram needed for an array or will it only allocate for the part actually being used? Like, say I have a recursive function which takes an array, modifies a few elements with // and passes it on to itself, will  ghc give me a thousand arrays, or just a single?
08:54:19 <Cale> kevinEllis: toList is supposed to be able to produce a list of type c for any type c which is an instance of Chromosome
08:54:28 <Cale> kevinEllis: But xs has a specific type.
08:54:43 <SyntaxNinja> w00t
08:54:45 <quicksilver> > let x = 1 in let x = 2 in x
08:54:46 <lambdabot>  2
08:54:55 <Cale> kevinEllis: You need some function to generalise from a specific type of chromosome to a general one there.
08:55:09 <Cale> (at least, if that's really the type you want toList to have)
08:55:24 <gwern> @tell boegel ok, I've tried re-sending my hray patches with a darcs 1.0.9 I have. if it doesn't work for you still, I figure the problem is on your end. (also, did you figure out what blocked compiling darcs 2? might be a bug)
08:55:24 <lambdabot> Consider it noted.
08:55:31 <Taggnostr> so isn't there an easy way to have a function that accepts different parameters?
08:55:36 <kevinEllis> Cale: no, I want the toList function to convert a population of type (Population c) to [c]
08:55:38 <jstanley> Anyone feel like helping out a haddock noob? I'm running it via haddock -B /path/to/lib/ghc-6.8.2 File.hs but being told it "failed to load all needed modules". Verbosity switch gives no more information.
08:56:15 <Cale> kevinEllis: So that's not the type you want it to have.
08:56:26 <Dae> Taggnostr: No dice, it's agains't the haskell way of thinking. You could do it partially with classes though
08:57:09 <Cale> kevinEllis: See, where you declared it in the class Population, c is a type variable, which means that it must be polymorphic.
08:57:19 <Taggnostr> and when I do let foo 0 = 1 and let foo n = foo (n-1) it works because the number and type of the parameter is the same, right?
08:57:48 <Cale> kevinEllis: You might actually want a functional dependency -- that is, for any population type p, there is some type c for which toList :: p -> c, uniquely determined by the type p
08:58:01 <Cale> kevinEllis: For that, the class declaration would look like:
08:58:15 <Cale> class Population c p | p -> c where
08:58:16 <Cale>   ...
08:58:25 <Cale> Or perhaps:
08:58:32 <Cale> class (Chromosome c) => Population c p | p -> c where
08:59:05 <Dae> Taggnostr: yes
08:59:13 <Cale> (you'll need appropriate extensions for that, of course -- it's not Haskell 98)
09:00:13 <Cale> {-# LANGUAGE FunctionalDependencies #-}  should do it.
09:00:20 <kevinEllis> That is, the c's have the same type
09:00:32 <Cale> kevinEllis: Right.
09:00:34 <Taggnostr> so I'll always have to call my int2list function passing an empty list as second parameter, right?
09:00:44 <Cale> kevinEllis: Whereas with the type that toList presently has, they needn't be.
09:01:36 <Dae> Taggnostr: no, but you might get a stack overflow if you don't
09:02:24 <Taggnostr> if I don't pass a list as the second arg it raises an error
09:03:06 <Taggnostr> how can I get a stack overlow?
09:03:19 <vixey> > last [1..]
09:03:31 <lambdabot>  out of memory (requested 1048576 bytes)
09:03:33 <Taggnostr> with my int2list function I mean
09:03:43 <vixey> why not call it intToList ?
09:03:54 <jinjing> i thought last was lazy
09:04:05 <vixey> jinjing: everything in haskell is lazy
09:04:06 <mm_freak_work> > [..10]
09:04:06 <lambdabot>  Parse error at "..10]" (column 2)
09:04:13 <Cale> Taggnostr: stack overflows typically happen when the distance from the root of the currently evaluating expression to the first reducible subexpression gets large
09:04:40 <jinjing> vixey: i c
09:04:41 <Dae> Taggnostr: if you don't make your int2list tail recursive, you can get a stack overflow
09:04:52 <Cale> That typically happens when you've written some tail-recursive function that builds up a large expression in a parameter without evaluating it as it goes.
09:04:59 <Cale> Dae: the opposite
09:05:07 <mm_freak_work> > fix (1+)
09:05:09 <Cale> tail recursion tends to cause stack overflows
09:05:17 <Taggnostr> uhm
09:05:18 <Dae> Cale: Yes, ofcourse.... my bad
09:05:23 <lambdabot>  thread killed
09:05:49 <mm_freak_work> > length $ fix (1:)
09:05:50 <Dae> Taggnostr: meaning that going like "fix n = n:(fix (n-1))"
09:06:02 <lambdabot> Terminated
09:06:18 <Dae> Taggnostr: that's tail recursive, and it's not smart.
09:06:40 <Cale> If you're going to write something tail recursive, at the very least, use -O
09:06:55 <Taggnostr> -O?
09:06:57 <vixey> that's not tail recursive
09:07:01 <Cale> Optimisation :)
09:07:06 <chylli> what is newline in haskell? '\n' ?
09:07:11 <vixey> fix n l = fix (n-1) (n:l) is
09:07:23 <mm_freak_work> chylli: a line-feed in strings is '\n'
09:07:26 <Cale> The strictness analyser will run then, and hopefully help the expressions get evaluated before it's too late
09:07:29 <vixey> chylli: yes, why?
09:07:33 <Taggnostr> is what I did tail-recursive?
09:07:38 <Cale> Otherwise, you need to add a strictness annotation.
09:07:49 <chylli> vixey: is '\n' or "\n" ? I need a char
09:07:49 <Cale> Where's your code?
09:07:54 <lilachaze> haskell's weird wrt tail recursion
09:08:00 <Dae> Taggnostr: no, it's cool, you're bringing the list along, so
09:08:00 <mm_freak_work> chylli: '\n' is Char
09:08:02 <Deewiant> ?ty '\n'
09:08:02 <lilachaze> or at least, different from most other languages
09:08:03 <lambdabot> Char
09:08:09 <chylli> thanks
09:08:17 <vixey> chylli: In ghci you can use :t <expression> to check the type of an expression
09:08:49 <jstanley> Anyone feel like helping out a haddock noob? I'm running it via haddock -B /path/to/lib/ghc-6.8.2 File.hs but being told it "failed to load all needed modules". Verbosity switch gives no more information.  Trying it on a very small input file yields "couldn't find link destinations for GHC.IOBase.IO."
09:08:56 <Cale> Taggnostr: are you accumulating something in a parameter?
09:09:00 <mm_freak_work> lilachaze: haskell optimizes well for tail-recursion, but the opposite doesn't hold, and that's what i like about GHC =)
09:09:13 <Taggnostr> yes, and passing it around
09:09:22 <chylli> vixey: I know, I just not sure '\
09:09:26 <chylli> '
09:09:28 <Cale> Taggnostr: let me give you a small example :)
09:09:35 <chylli> '\' has special means
09:09:43 <Taggnostr> let int2list n (xs) = if n < 10 then n:xs else (int2list (n `div` 10) ((n `mod` 10):xs)) <- I'm doing this
09:09:48 <tcr> Does anyone know what's up with ndm? I tried to reach him via mail, but he hasn't replied so far.
09:09:52 <quicksilver> you still want tail recursion for simple types
09:09:53 <Cale> Taggnostr: it's important to realise that lazy evaluation is outermost first
09:10:03 <quicksilver> you want functions of the form [a] -> Int to be tail recursive.
09:10:09 <Cale> Taggnostr: so let's evaluate that function applied to something :)
09:10:15 <chylli> then what is NUL (0x0), CR  (0xd), and LF (0xa)
09:10:20 <Cale> int2list 123 []
09:10:29 <quicksilver> for recursive types it suffices to be productive.
09:10:41 <Cale> -> if 123 < 10 then 123:[] else (int2list (123 `div` 10) ((123 `mod` 10):[]))
09:10:47 <Cale> -> if False then 123:[] else (int2list (123 `div` 10) ((123 `mod` 10):[]))
09:11:00 <Cale> -> int2list (123 `div` 10) ((123 `mod` 10):[])
09:11:09 <chylli> ?ty '0x0'
09:11:10 <lambdabot> lexical error in string/character literal at character 'x'
09:11:24 <vixey> ?ty '\0'
09:11:25 <lambdabot> Char
09:11:32 <chylli> thanks
09:11:41 <Cale> -> if (123 `div` 10) < 10 then (123 `div` 10):((123 `mod` 10):[]) else (int2list ((123 `div` 10) `div` 10) (((123 `div` 10) `mod` 10):((123 `mod` 10):[])))
09:11:51 <roconnor> @seeen dcoutts_
09:11:51 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
09:11:58 <chylli> ?ty '\a'
09:11:59 <lambdabot> Char
09:12:14 <vixey> ?ty '\bel'
09:12:14 <Cale> -> if 12 < 10 then 12:((123 `mod` 10):[]) else (int2list (12 `div` 10) ((12 `mod` 10):((123 `mod` 10):[])))
09:12:15 <lambdabot> lexical error in string/character literal at character 'b'
09:12:23 <chylli> ?ty "\0"
09:12:24 <lambdabot> [Char]
09:12:25 <Cale> -> if False then 12:((123 `mod` 10):[]) else (int2list (12 `div` 10) ((12 `mod` 10):((123 `mod` 10):[])))
09:12:26 <vixey> ?ty '\BEL'
09:12:27 <lambdabot> Char
09:12:30 <Cale> -> int2list (12 `div` 10) ((12 `mod` 10):((123 `mod` 10):[]))
09:12:54 <Taggnostr> :O
09:13:22 <Cale> That's the actual order in which it's being evaluated.
09:15:37 <Cale> I'm not sure how a large expression could really build up there actually.
09:15:47 <Cale> What example are you getting a stack overflow with?
09:16:04 <Taggnostr> I'm not getting a stack overflow
09:16:07 <Cale> oh
09:16:17 <Cale> Then why were people talking about stack overflows?
09:16:18 <Cale> hehe
09:16:31 <Taggnostr> don't know :P
09:16:34 <Cale> Well, when you use accumulating parameters like that, it's always something to think about
09:16:53 <Cale> It's easy to write a stack overflow if you're not careful about how you're using the accumulating parameter
09:17:02 <Taggnostr> if I start with a very large number for example?
09:17:04 <Cale> But you're using a constructor, so it should be okay.
09:17:13 <vixey> umm
09:17:17 <vixey>  <Taggnostr> how can I get a stack overlow?
09:17:17 <vixey>  <Taggnostr> with my int2list function I mean
09:17:55 <Taggnostr> <Dae> Taggnostr: no, but you might get a stack overflow if you don't
09:17:56 <Cale> If instead of (:), you were using (+) (and starting things off with 0, say), then with very large numbers, the way you currently have the thing written, you could get a stack overflow.
09:18:45 <Taggnostr> what is a contructor?
09:19:16 <Cale> Taggnostr: A data constructor...
09:19:28 <Cale> Taggnostr: those things which are valid to pattern match against, I suppose
09:20:52 <Taggnostr> ok
09:22:43 <vixey> hmm
09:22:46 <vixey> "Compilation algorithms found in textbooks are imperative in nature."
09:23:24 <vixey> I think that is probably just historic reasons
09:23:35 <Cale> vixey: I'm not so sure that's even true, really :)
09:24:28 <Cale> Sure, in lots of books, they're probably written in imperative pseudocode, but compilation is a pretty purely-functional sort of process.
09:25:28 <Dae> vixey: also, a lot of algorithms are really really hard to rewrite as being purely functional
09:25:37 <quicksilver> Cale: people probably confuse "forward moving" with "imperative".
09:25:51 <quicksilver> Dae: on the contrary, a lot of algorithms are *REALLY* hard to rewrite as imperative.
09:26:26 <quicksilver> the problem of correctly rewriting a spec (almost invariable functional) into an imperative program is almost the entire problem of modern software engineering.
09:26:29 <quicksilver> and it's hard.
09:26:56 <quicksilver> Cale: because many compilers work "forwards" over the code from beginning to end in 1,2,3 or more passes, they think they must be imperative.
09:27:17 <Dae> quicksilver: Well, I'm still having problems rewriting iterative algorithms...
09:27:44 <quicksilver> that's just practice.
09:27:46 <quicksilver> not difficultly
09:27:48 <quicksilver> (no offence)
09:28:03 <quicksilver> you've trained yourself through considerable hardship to think that way.
09:28:07 <quicksilver> it takes time to unthink.
09:28:09 <Dae> quicksilver: But.. it's very hard not to loose speed unless you want to rewrite your algorithm as a monad
09:28:10 <LordBrain> jstanley, you still having haddock problems?
09:29:10 <vixey> speed is the least of problems in writing programs today
09:29:26 <matthew-_> ok, so my implementation of intersection has one more call to split (which is O(log(min(i,n-i)))) per recursive step, compared to merge, which is known O(m + log(n/m))
09:30:06 <Cale> Dae: if you pick sensible datastructures, going from something which uses mutation to something which is pure typically costs only a negligible logarithmic factor.
09:30:28 <quicksilver> Dae: there are some algorithms are very fast with a simplistic mutable store like a C array.
09:30:33 <quicksilver> some of these were quite hard to write, the first time.
09:30:40 <quicksilver> but now they've been written, we can all benefit.
09:30:58 <quicksilver> However, if you're writing a more complex algorithm from scratch, it's much easier to write them in a functional style.
09:32:09 <Dae> quicksilver: Example: Jacobi Eigenvalue. How would you rewrite it in a pure language without it getting needlessly messy or getting a loss in speed and memory?
09:32:28 <__tmp> I think I've seen this debate once or twice before :)
09:32:35 <quicksilver> Pure langauges don't specify their memory use.
09:32:42 <Dae> Sorry, I'm just doing it this very moment, and I find myself more and more inclined to use the foreign interface
09:32:55 <vixey> Dae: It's not a bad thing to use that
09:33:05 <quicksilver> therefore I can lie, and tell you that I have a compier which I'm not going to share with you which acheives better memory efficiency that your hardcoded C.
09:33:11 <quicksilver> of course, I'd be lying, I don't.
09:33:38 <quicksilver> Your absolutely right, C is the king of memory usage because its execution and compilation model gives you tight and precise control of your memory management.
09:34:13 <Cale> You're
09:34:14 <Gowilla> doesn't it have alignment requirements?
09:34:24 <Baughn> No, the machine does
09:34:36 <quicksilver> unfortunately, the disadvantage is that the C gives you right and precise control of your memory management.
09:34:41 <Heffalump> yeah, ok
09:34:43 <quicksilver> tight.
09:34:45 <quicksilver> damn typing.
09:34:57 <quicksilver> manual memory management is a pain. However it is not pain without gain.
09:34:57 <Baughn> I thought haskellers /liked/ typing? ;_;
09:35:00 <Dae> quicksilver: but I'm not talking constant factors, I'm talking it being O(n) worse
09:35:01 <lilachaze> quicksilver: what's your definition of pure language in this context?
09:35:25 <quicksilver> lilachaze: which context? In one sentence my definition was "fictional language with SufficientlySmartCompiler"
09:35:40 <quicksilver> in the next sentence my definition is "GHC".
09:35:54 <Baughn> Dae: Then you've made a mistake with your algorithm. Hm, there was a book on designing algorithms for lazy, purely functional languages here somewhere..
09:35:57 <quicksilver> Dae: shouldn't be O(n) worse, really.
09:35:58 <lilachaze> quicksilver: sorry, i meant in "pure languages don't specify their memory use"
09:36:17 <Dae> quicksilver: Ok, I'll give you an example.... if you tell me how to use hpaste ;)
09:37:06 <Dae> nevermind that, I think I figured :p
09:37:09 <quicksilver> ;)
09:37:14 <quicksilver> but yes, it will be worse.
09:37:16 <quicksilver> I agree entirely.
09:37:25 <quicksilver> GHC is not the be all and end all of memory efficiency.
09:37:48 <quicksilver> if memory layouts become more sophisticated and asymmetric multiprocessing becomes the norm
09:37:54 <quicksilver> then C may start to lose out again
09:38:03 <quicksilver> since the simplistic memory management may turn out to be wrong :)
09:38:06 <quicksilver> but that day is not yet here.
09:38:13 <Baughn> I've found that a number of small utilities use less memory with ghc because I don't (a) suck the entire input into memory at once, or (b) do so in overly large chunks
09:38:34 <lilachaze> it's much much easier to write lazy code in haskell (kinda obviously)
09:38:38 <Baughn> Granted, that's just a matter of effort. I don't want to work that hard to write things I use once.
09:38:55 <hpaste>  Dae pasted "QR algorithm" at http://hpaste.org/8637
09:39:16 <lilachaze> but conversely it's easier to reason about, and hence to optimize for, memory usage in C.
09:40:05 <Baughn> True. I have a lot of issues with memory leaks in haskell. >_<
09:40:32 <Cale> http://en.wikipedia.org/wiki/Jacobi_eigenvalue_algorithm#Description sounds pretty purely functional
09:40:33 <lambdabot> http://tinyurl.com/2ovoeo
09:40:36 * roconnor has a lot of memory leaks in C
09:40:55 <quicksilver> Dae: sum $! and sqrt $! are pointless btw ;)
09:41:15 <Cale> yeah, sum and sqrt are already strict functions
09:41:19 <roconnor> @pl sum $!
09:41:19 <lambdabot> (line 1, column 7):
09:41:19 <lambdabot> unexpected end of input
09:41:19 <lambdabot> expecting white space or simple term
09:41:34 <lilachaze> although presumably "sum foo" is better than "sum $! foo" wrt memory usage...
09:41:45 <lilachaze> actually, scratch that, whnf and all
09:41:46 <Baughn> lilachaze: Shouldn't be
09:42:01 <Cale> I'm willing to bet that it compiles to the exact same thing
09:42:07 <Dae> quicksilver: Really? That function alone is using an amazing amount of memory, so I was trying to get out of it by making it stricter....
09:42:11 <Baughn> Force the sum, and you'll force the entire list that gets summed. It cannot be otherwsise, so..
09:42:21 <lilachaze> Baughn: no, right you are. for some reason my brain misidentified $! as reducing to normal form rather than whfn
09:42:23 <Cale> Dae: those annotations don't change the existing strictness at all
09:42:55 <Baughn> lilachaze: Nope, though it would be nice if there was a rnf equivalent that doesn't need an explicit instance
09:43:16 <Cale> Dae: Before you can evaluate sum xs, you must evaluate xs anyway.
09:43:20 <lilachaze> Baughn: 's clearly been a long day for me :)
09:43:35 <Cale> Dae: so there's no point in putting the evaluation of xs into WHNF before that
09:43:35 <_dolio> That's a lot of intermediate arrays.
09:43:38 <_dolio> And lsits.
09:43:46 <dolio> Lists, even.
09:43:53 <quicksilver> I think it's proablby fair to say taht algorithm is easier to read than the imperative equivalent
09:43:57 <quicksilver> so that's one win, at least.
09:43:58 <Dae> Cale: Right, i thought maybe it just added the computation to the list, soto speak
09:44:07 <quicksilver> You will improve memory usage by unboxing all the arrays.
09:44:14 <quicksilver> that might be fairly significant speed wise
09:44:21 <quicksilver> it wil have the side effect of making everything strict.
09:44:28 <quicksilver> unboxed arrays are value-strict by necessity
09:44:35 <Dae> quicksilver: can't, most of them  are defined by themselves
09:44:38 <Cale> Yeah, switch to UArray and see what happens :)
09:44:54 <Cale> You should only have to change the types :)
09:45:08 <Dae> but in order to keep on the functional wagon, I need to have arrays defined by themselves, and thus I can't use Uarrays
09:45:29 <Cale> oh, right, you're recursively defining some of these
09:45:30 <quicksilver> oh I see
09:45:33 <quicksilver> value recursion
09:45:39 <Cale> So you really do need thunks in there
09:46:08 <Dae> Yeah.... the real problem is the a'' array. It has a dimension more than the imperative version....
09:46:23 <vixey> hehe * Dependent types is all I know. * I need to make money. * DTP can save mankind, and I want to help.
09:47:36 <Baughn> Lately, I've been using fmap instead of bothering to import control.monad just for liftM. Is that good style, or should I be bothering?
09:47:52 <vixey> don't you use . instead of liftM
09:48:11 <LordBrain> Are we looking at Dae's source somewhere?
09:48:24 <Baughn> vixey: Oh, good idea
09:48:34 <Dae> LordBrain: >	Dae pasted "QR algorithm" at http://hpaste.org/8637
09:48:38 <vixey> I wish it was my idea :p
09:48:43 <LordBrain> thankyou
09:48:59 <vixey> @w80 czar
09:48:59 <lambdabot> *** "czar" wn "WordNet (r) 2.0"
09:48:59 <lambdabot> czar
09:48:59 <lambdabot>      n 1: a male monarch or emperor (especially of Russia prior to
09:48:59 <lambdabot>           1917) [syn: {tsar}, {tzar}]
09:48:59 <lambdabot>      2: a person having great power
09:49:06 <vixey> oo pick me
09:49:57 <Cale> Baughn: I think it's fine myself.
09:50:08 <vixey> :t \e p x -> case e of p -> x == x == x
09:50:09 <lambdabot>     precedence parsing error
09:50:09 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' [infix 4] in the same infix expression
09:50:25 <lilachaze> Baughn: it gives you the wrong type... your functions will be all (Functor m, Monad m) => ... rather than just (Monad m) => ...
09:50:34 <Cale> Dae: are you storing all the iterations of the algorithm?
09:50:37 <LordBrain> i like (>>$) = flip fmap
09:50:49 <LordBrain> then my code reads left to right
09:51:17 <vixey> LordBrain: that sounds awful :(
09:51:19 <Dae> Cale: Yes, that's the problem
09:51:21 <LordBrain> lol
09:51:24 <LordBrain> why?
09:51:26 <LordBrain> which part?
09:51:33 <vixey> it's like turning half your code inside out
09:51:40 <LordBrain> no it's not
09:51:41 <Cale> Dae: If the imperative version avoids that, surely the functional one can too?
09:51:42 <Baughn> lilachaze: True. No, this is mostly for throwaways.
09:51:45 <dolio> Clearly you should switch to (=<<) so your code reads right to left.
09:52:19 <quicksilver> Baughn: I always import Control.Applicative((<$>)) instead.
09:52:20 <LordBrain> well. maybe if I can configure my editor to insert the characters that way too...
09:52:23 <Dae> Cale: I'm sure it can, I just can't see my way out of it without using the ST Monad. http://www.phys.au.dk/subatom/nucltheo/Numeric/Current/lineq.pdf for the basic algorithm
09:52:50 <Baughn> quicksilver: ..I see I'm going to have to learn what that does.
09:52:56 <quicksilver> Dae: general pattern is replace a for loop with a fold.
09:53:02 <quicksilver> Baughn: same as liftM or fmap
09:53:08 <quicksilver> Baughn: just infix and pretty like a christmas tree
09:53:24 <Baughn> @type <$>
09:53:25 <lambdabot> parse error on input `<$>'
09:53:29 <Baughn> @type (<$>)
09:53:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:53:32 <quicksilver> Dae: so your array which stores every iteration turns into the input (and output) of the fold.
09:53:43 <quicksilver> Dae: input is iteration (i-1) output is iteration i.
09:53:58 <LordBrain> @src (<$>)
09:53:58 <lambdabot> f <$> a = fmap f a
09:53:59 <Cale> Dae: okay, I'll do as direct a translation of the algorithm in that paper as I can manage :)
09:54:05 <vixey> augustss_: What is the reasoning for 'DTP needs one standard notation.'?
09:55:14 <nominolo> @seen swiert
09:55:14 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
09:55:15 <Dae> quicksilver: not quite sure what you mean?
09:55:19 <vixey> (and what does that really mean?)
09:55:29 <quicksilver> :t foldr
09:55:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:55:34 <Baughn> quicksilver: ..pretty...
09:55:37 <vixey> preflex: seen sweirt
09:55:37 <preflex>  Sorry, I haven't seen sweirt
09:55:40 <quicksilver> Dae: (a -> b -> b) in the foldr.
09:55:49 <quicksilver> Dae: the input "b" is last iteration of the arrary
09:55:51 <Deewiant> preflex: seen swiert
09:55:51 <preflex>  swiert was last seen on #haskell 3 hours, 6 minutes and 10 seconds ago, saying: hmm. That's unfortunate.
09:55:55 <quicksilver> Dae: the output "b" is the next one
09:55:57 <vixey> oops :[
09:56:04 <quicksilver> Dae: that way they're not all in memory at once
09:56:10 <quicksilver> just the last one and the next one :)
09:56:25 <quicksilver> you may not need to use "a" it might only be the loop counter in your case.
09:56:52 <Deewiant> if you don't need "a" then just use iterate, or?
09:57:03 <quicksilver> maybe yes.
09:57:17 <quicksilver> but in the general pattern you often do need "a" ;)
09:58:30 <Dae> quicksilver: ok, i thinki understand
10:00:18 <t3l3mach> does that latest repository version of haddock compile with ghc 6.8.3?
10:14:00 <Dae> quicksilver: I still need to pay the copy cost of the copying and array each iteration, right?
10:19:26 <Baughn> @src words
10:19:27 <lambdabot> words s = case dropWhile isSpace s of
10:19:27 <lambdabot>     "" -> []
10:19:27 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:25:44 <dons> Igloo: i'll have a poke around 'random'
10:26:43 <dons> though 2280 looks like its avoiding the Integer conversion System.Random uses
10:26:48 <dons> which would explain the speed
10:27:05 <Igloo> dons: Great, thanks!
10:27:19 <Igloo> Why is System.Random doing Integer conversion? I thought it was all 32bit internally
10:27:50 <dons> the internal state is Int, yep
10:27:51 <dons> data StdGen  = StdGen Int32 Int32
10:28:06 <dons> but
10:28:07 <dons> instance Random Int where randomR (a,b) g = randomIvalInteger (toInteger a, toInteger b) g
10:28:11 <dons> :(
10:28:34 <dons> augustss has said expressed surprise it is in use in its original form
10:29:09 <dons> mersenne-random-pure64 avoids all this stuff, fwiw, by using native Double and Word generation depending on the type
10:29:14 <dons> rather than all this Integer monkey business
10:30:39 <hpaste>  obk pasted "Strange weakness in type checker" at http://hpaste.org/8638
10:31:24 * obk found a strange edge case in the type checker... causing me to write boilerplate code... a pity.
10:32:35 <dons> byorgey: two wacky stories, lazy evaluation in D, http://www.digitalmars.com/d/2.0/lazy-evaluation.html  and parallel strategies in Java, http://apocalisp.wordpress.com/2008/06/30/parallel-list-transformations/
10:32:35 <lambdabot> Title: LazyEvaluationOfFunctionArguments - D Programming Language 2.0 - Digital Mars
10:38:49 <Deewiant> wacky? :-P
10:42:54 <paolino> how you break a list in pieces of given length ?
10:42:54 <paolino> sgroup ::  [Int] -> [a] -> [[a]]
10:43:42 <paolino> I could only get down to use mapAccumL, but I hope there is something nicer
10:43:43 <vixey> there should be  take/drop :: Int -> [a] -> ([a],[a])
10:43:56 <vixey> then you could just iterate it
10:43:57 <Saizan> ?type splitAt
10:44:06 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:44:07 <Deewiant> > let x `inGroupsOf` n = map (take n) . takeWhile (not.null) . iterate (drop n) $ x in [1..10] `inGroupsOf` 3
10:44:10 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
10:44:32 <Deewiant> I've been posting that a lot lately, maybe I should alias it to something :-P
10:44:42 <paolino> Deewiant: I ment lenghts
10:44:43 <vixey> Deewiant: that's not quite the same thing
10:45:05 <Deewiant> no?
10:45:11 <Deewiant> ah, [Int]
10:45:14 <Deewiant> missed that
10:45:15 <paolino> sgroup xs ys = snd $ mapAccumL (\ys x -> swap $ splitAt x ys) ys xs
10:45:16 <paolino> 	where swap (a,b) = (b,a)
10:46:32 <asdftimo> hello, i'm trying to make a list of the iterations of the totient function using the following command (with the 'totient' function already defined):
10:46:34 <asdftimo> totlist = (totient 10) : (totient (last totlist))
10:46:53 <asdftimo> i get   "Couldn't match expected type `[Int]' against inferred type `Int'"
10:47:08 <asdftimo> how can i make this work?
10:47:48 <solrize> totient returns an int
10:47:55 <Gilly> totlist = iterate totient 10
10:47:58 <Saizan> ?ty evalState . mapM (State . splitAt)
10:47:58 <lambdabot> forall a. [Int] -> [a] -> [[a]]
10:48:07 <solrize> to get that to typecheck you want   totlist = (totient 10) : [totient (last tolist)]
10:48:14 <solrize> but i think that won't work even if it typechecks
10:48:48 <Saizan> > let sgroup = evalState . mapM (State . splitAt) in sgroup [1,2,3] [1..10]
10:48:49 <lambdabot>  [[1],[2,3],[4,5,6]]
10:48:51 <solrize> :t iterate
10:48:52 <lambdabot> forall a. (a -> a) -> a -> [a]
10:49:21 <solrize> >take 5 (iterate square 3) where square x = x*x
10:49:25 <solrize> > take 5 (iterate square 3) where square x = x*x
10:49:25 <lambdabot>  Parse error at "where" (column 27)
10:49:30 <paolino> Saizan, can you explain, please ?
10:49:39 <solrize> > take 5 (iterate (\x->(x*x)))
10:49:40 <lambdabot>  Couldn't match expected type `[a]'
10:49:46 <solrize> > take 5 (iterate (\x->(x*x)) 3)
10:49:47 <lambdabot>  [3,9,81,6561,43046721]
10:49:53 <asdftimo> @solrize: that didn't work
10:49:53 <lambdabot> Unknown command, try @list
10:50:14 <paolino> :t State
10:50:15 <solrize> :t last
10:50:15 <lambdabot> forall s a. (s -> (a, s)) -> State s a
10:50:16 <lambdabot> forall a. [a] -> a
10:51:00 <solrize> asdftimo i think you want to write something like iterate
10:51:02 <paolino> :t State splitAt
10:51:03 <solrize> @src iterate
10:51:03 <lambdabot> iterate f x =  x : iterate f (f x)
10:51:03 <lambdabot>     Couldn't match expected type `(a, Int)'
10:51:03 <lambdabot>            against inferred type `[a1] -> ([a1], [a1])'
10:51:03 <lambdabot>     Probable cause: `splitAt' is applied to too few arguments
10:51:23 <asdftimo> solrize, thanks, i'll go read up
10:51:41 <paolino> :t \n -> State (splitAt n)
10:51:42 <lambdabot> forall a. Int -> State [a] [a]
10:52:56 <asdftimo> works great solrize thanks a lot
11:06:01 <_zenon_> >:i show
11:06:45 <_zenon_> ?ty show
11:06:46 <lambdabot> forall a. (Show a) => a -> String
11:12:48 <_zenon_> ?ty liftM
11:12:49 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:12:57 <_zenon_> ! I knew it!
11:13:25 <_zenon_> It's a liftM def, in hpaste, I have never been to that page before, but now I got there,
11:14:39 <_zenon_> ?ty fmap
11:14:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:14:47 <_zenon_> or more like fmap :)
11:16:47 <augustss_> vixey: if you want to be able to read other peoples code and share code, you need one notation
11:18:22 <LordBrain> why do people dislike code that reads left to right?  Is it too non-mathematical? I had a topology professor who defined his notation so that function composition read left to right... and when his students complained he argued that they ought not get too attached to notation.
11:19:21 <_zenon_> LordBrain: how do you mean?
11:19:34 <LordBrain> i use (>>$) = flip fmap
11:19:46 <LordBrain> vixey & dolio seemed to think it an abomination
11:20:34 <Deewiant> just import Prelude hiding ((.)) and define . as that :-)
11:22:01 <LordBrain> well i thought using a new symbol would be better than using one that people think they know
11:22:21 <Deewiant> true, it is
11:22:34 <Deewiant> >>$ just seems a bit verbose
11:22:35 <vixey> LordBrain: Just because I don't like it doesn't mean it's a bad idea
11:22:43 <Deewiant> just like >>>
11:22:47 <vixey> LordBrain: i.e. if it works well for you then by all means it's a good idea
11:23:25 <LordBrain> sure i'd prefer one character symbols but they're in short supply
11:23:36 <LordBrain> and i use >>= anyway
11:24:06 <jeffersonheard> Anyone tried using Gtk.Pixbufs for textures in OpenGL and Gtk2hs?
11:25:59 <jeffersonheard> it looks like I'd use withStorableArray to get the contents and then load the texture data that way, but I wasn't sure
11:43:01 <PeakerWork> flip (<$>) = (>$<) maybe?
11:45:02 <nyingen> So, I was trying to build the 'network' package on ghc-6.8.3, but it fails with an error 'Not in scope: openFd'
11:45:26 <nyingen> Not sure whether this is a known bug, version incompatibility, or what
11:46:03 <Igloo> Probably a version incompatibility
11:46:17 <Cale> nyingen: which version of the network package?
11:46:19 <Igloo> The latest version should build
11:46:33 <nyingen> network-2.2.0.0
11:47:50 <nyingen> I think I downloaded it from Hackage yesterday, but I'll double check
11:48:02 <Cale> yeah, that appears to be the latest
11:48:08 <Cale> I've built that with 6.8.3
11:48:15 <Cale> So I'm not sure what the problem is...
11:48:24 <nyingen> Hm
11:49:57 <nyingen> I'll check the output of the configure script, I guess, though it didn't emit any error messages
11:51:05 <nyingen> what is openFd?
11:52:36 <int-e> @index openFd
11:52:36 <lambdabot> System.Posix.IO, System.Posix
11:52:49 <int-e> @type System.Posix.IO.openFd
11:52:50 <lambdabot> FilePath -> System.Posix.IO.OpenMode -> Maybe System.Posix.Types.FileMode -> System.Posix.IO.OpenFileFlags -> IO System.Posix.Types.Fd
11:53:06 <int-e> a low level function for opening files on posix systems
11:53:57 <int-e> so what's your OS?
11:54:18 <nyingen> int-e: This would be debian testing
11:54:38 <maltem> How do I compile Yi to include the console frontend? (yi -fvty  =>  Panic: frontend not found)
11:55:50 <int-e> nyingen: hmm, it should work then. (but I haven't built the hackage version, I've installed it as a bundled (extra) library with ghc)
11:56:41 <nyingen> int-e: I see
11:57:31 <nyingen> I'm actually trying to build HXT, which depends on 'network', but I ran into various problems attempting to build its dependencies with debian's Haskell packages
11:57:47 <nyingen> So I tried compiling the latest ghc release from source, and now this.
11:58:28 <Cale> nyingen: Btw, to save time next time, there's a generic linux binary which works well on debian and ubuntu.
11:58:39 <maltem> (Nevermind... it turned out to be a cabal flag)
11:58:50 <PeakerWork> why aren't the names identical to those of the equivalent C functions? It could make it more obvious what the function really is
11:59:01 <PeakerWork> (openFd -> open)
11:59:48 <nyingen> Cale: Yeah, I saw that, but wasn't sure whether it would work well for me
12:00:10 <nyingen> Cale: good to know
12:02:35 <maltem> Wait, do mind. I get the same error even if the vty frontend *is* compiled. No yi hacker around?
12:08:30 <mapreduce> How would you achieve recursion in a typed language that isn't lazy, using lambdas instead of named procedures?
12:08:45 <mapreduce> E.g., Haskell has fix, and lisp has (lambda (f x) (f f x)).
12:09:07 <vixey> mapreduce: Read SICP
12:09:13 <vixey> oh
12:09:15 <vixey> typed, it's impossible
12:09:23 <roconnor> vixey: that's not true
12:09:32 <vixey> or look at roconnors blog
12:09:38 <roconnor> http://r6.ca/blog/20060919T084800Z.html
12:09:38 <lambdabot> Title: Y Combinator in Haskell
12:09:39 <vixey> but the point of types is to make this impossible
12:09:48 <asdftimo> hello, i am generating a very long list (10000+) with filter, and i was wondering if there was a way to incrementally print elements of the list as they are filtered. is this possible?
12:10:08 <augur> er.. why would recursion require an untyped language? o_O
12:10:17 <mapreduce> vixey: I've read sicp. :)
12:10:31 <Deewiant> asdftimo: mapM_ print . filter condition $ list should do it
12:10:39 <mapreduce> augur: It doesn't, but the trivial version is an infinite type.
12:10:47 <mapreduce> > \f x -> f f x
12:10:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
12:10:48 <lambdabot>     ...
12:10:49 <Cale> newtype Rec a = In { out :: Rec a -> a }
12:10:49 <Cale> y :: (a -> a) -> a
12:10:49 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
12:10:50 <augur> an infinite type?
12:11:01 <asdftimo> thanks Deewiant ill try that
12:11:26 <maltem> mapreduce: You could provide (lazy) fix as a language primitive, but that would be cheating I guess
12:12:36 <Cale> Yeah, in Haskell, you can make a definition like   fix f = x where x = f x
12:12:59 <Cale> (or:  fix f = let x = f x in x )
12:13:00 <maltem> (For those who search IRC logs: --force-recompile solved the yi-vty issue for me)
12:13:08 <roconnor> :) I think Cairo doesn't like drawing lines segments that are shorter tha the line width.
12:18:40 <byorgey> hi all!
12:18:43 * byorgey waves
12:19:27 <mapreduce> maltem: I think you could do the lisp way at the cost of type-safety.
12:20:02 <Cale> You can write the Y combinator directly with an appropriate type as I showed above :)
12:20:27 <opqdonut> yeah but it need letrec :)
12:20:34 <Cale> @let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
12:20:41 <Cale> No it doesn't :)
12:20:49 <lambdabot> thread killed
12:20:49 <Cale> Just needs a particular recursive type :)
12:20:53 <Cale> er...
12:21:32 <Cale> huh, code.h.o is being slow again
12:22:28 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\f n -> if n == 0 then 1 else n * f (n-1)) 10
12:22:36 <lambdabot>  3628800
12:23:14 <Cale> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) is recognisable as a slightly-annotated version of the usual y combinator :)
12:23:51 <Cale> Oh, the @let did go through
12:24:01 <Cale> > y (\f n -> if n == 0 then 1 else n * f (n-1)) 10
12:24:02 <lambdabot>  Couldn't match expected type `((a -> a) -> a -> a) -> t1 -> t'
12:24:12 <Cale> huh
12:24:13 <Cale> :t y
12:24:28 <lambdabot> thread killed
12:24:30 <Cale> :t y
12:24:52 <Cale> @undefine
12:24:56 <lambdabot> Undefined.
12:25:12 <Cale> Interesting... maybe the inliner is choking :)
12:25:39 <int-e> @let y f = (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
12:25:48 <int-e> > y (\f n -> if n == 0 then 1 else n * f (n-1)) 10
12:25:54 <lambdabot>  Couldn't match expected type `((a -> a) -> a -> a) -> t1 -> t'
12:25:55 <lambdabot> thread killed
12:26:02 <int-e> yeah, funny.
12:26:57 <mapreduce> I'll have to try to understand that code to see if I can port it then. :)
12:28:03 <Cale> That works locally, anyway :)
12:28:43 <int-e> :t y
12:28:44 <lambdabot> Expr
12:28:48 <opqdonut> Cale: yeah okay, recursive types is enough too
12:30:42 <asdftimo> hello, i need help editing this line so that it appends to a designated file:
12:30:43 <asdftimo> main = mapM_ print $ filter(\n -> p n==n) $ [1..10000]
12:31:46 <_zenon_> ?ty mapM_ print $ filter(\n -> p n==n) $ [1..10000]
12:32:01 <lambdabot> thread killed
12:32:34 <asdftimo> i dont understand _zenon_
12:33:56 <asdftimo> right now it is printing to the command prompt, i need it to print to a file
12:34:42 <_zenon_> asdftimo: You will have to excuse me, but I am currently on many places at the same time. :) But my fastest suggestion is using writeFile
12:34:53 <_zenon_> you can see more here http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3AwriteFile
12:34:54 <lambdabot> http://tinyurl.com/ovjef
12:35:08 <_zenon_> writeFile :: FilePath -> String -> IO ()        -- Defined in System.IO
12:35:34 <_zenon_>  mapM_ writeFile "myfile" $ filter(\n -> p n==n) $ [1..10000]
12:35:38 <_zenon_> something like that
12:36:22 <Baughn> He'll have to use openFile to make it /append/, though
12:36:33 <asdftimo> _zenon_ : Couldn't match expected type `FilePath' against inferred type `Char'
12:37:14 <EvilTerran> if it's a new file, (writeFile "..." . unlines . filter (\n -> p n==n) $ [1..10000]) would work
12:37:32 <EvilTerran> er, s/unlines/unlines.map show/
12:38:51 <asdftimo> i need it to print incrementally, which is why i used mapM_
12:40:05 <EvilTerran> why?
12:40:23 <EvilTerran> writefile . unlines will consume the list lazily as well
12:40:51 <asdftimo> im going to have it running up to probably 1,000,000 and i need to checkup on the program
12:41:18 <asdftimo> and see where it stopped if i decide to break it
12:41:25 <Deewiant> EvilTerran: but you need to hFlush or hSetBuffering to get incremental output
12:41:53 <Baughn> Block-buffering also gives you incremental output, just.. less so
12:41:58 <Deewiant> :-)
12:42:09 <EvilTerran> Deewiant, er, do you?
12:42:10 <Deewiant> the default block size is 16384 bytes IIRC
12:42:19 <Baughn> Cargo-culting hFlush is a bad idea, anyhow. You should understand /why/ to use it, so..
12:42:29 <EvilTerran> ah, i see, so you will get incremental output, just really big increments
12:42:42 <Deewiant> yep
12:42:53 <Baughn> On the posix level, yep
12:43:05 <Baughn> On the haskell level, it's probably per-char incremental
12:44:03 <Deewiant> I think System.IO does its own buffering
12:44:16 <Deewiant> or then it's somewhere in the C-- bits
12:44:36 <Deewiant> but hPutStr isn't really mapM_ hPutChar, for instance
12:45:01 <roconnor> @src hPutStr
12:45:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:45:04 <Deewiant> except in NoBuffering mode
12:45:35 <roconnor> Deewiant: does hPutStr/hPutChar have anything to do with buffering?
12:45:41 <roconnor> I'd be surprised
12:46:22 * roconnor expects hPutStr to really be mapM_ hPutChar
12:46:24 <Deewiant> I can't remember for certain
12:46:44 <Deewiant> it's not, though
12:46:57 <Deewiant> it does a case on the buffering mode
12:46:58 <dafra> hi, how to convert 1.0 to 1 ?
12:47:12 <Deewiant> and then calls functions like writeBlocks or writeLines or whatnot
12:47:12 <dafra> sorry, I mean the ipposite
12:47:18 <dafra> opposite
12:47:19 <Deewiant> > fromIntegral 1 :: Double
12:47:20 <lambdabot>  1.0
12:48:26 <roconnor> > realToFrac 1 :: Double
12:48:28 <lambdabot>  1.0
12:48:38 <Deewiant> > realToFrac (1 :: Int) :: Double
12:48:39 <lambdabot>  1.0
12:48:40 <asdftimo> how can you write a list to a file? can you use writefile?
12:48:41 <Deewiant> darn
12:49:14 <roconnor> Deewiant: the problem is that Real is a dumb name for that class
12:49:30 <Deewiant> ?ty realToFrac
12:49:37 <int-e> > show [1,2,3]
12:49:40 <lambdabot>  "[1,2,3]"
12:49:46 <lambdabot> thread killed
12:49:51 <Deewiant> ?instances RealFrac
12:49:52 <int-e> @src print
12:49:53 <lambdabot> Double, Float
12:49:53 <lambdabot> print x = putStrLn (show x)
12:49:56 <Deewiant> ?ty realToFrac
12:50:09 <int-e> asdftimo: does that help?
12:50:12 <lambdabot> thread killed
12:50:17 <roconnor> @hoogle realToFrac
12:50:28 <asdftimo> it is stored as a variable (t) so i can't do "t"
12:50:32 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
12:51:10 <asdftimo> sorry hold on let me catch up :)
12:51:11 <Deewiant> ?instances Real
12:51:13 <lambdabot> Double, Float, Int, Integer
12:51:26 <roconnor> asdftimo: a list of what?
12:51:49 <asdftimo> roconnor: just a list of numbers
12:52:03 <cjay> how come Ratio is no instance of Real?
12:52:23 <roconnor> cjay: Ratio is a type constructor, not a type
12:52:43 <roconnor> hmm
12:53:08 <cjay> oh
12:53:41 <int-e> cjay: instance (Integral a) => Real (Ratio a) -- Defined in GHC.Real
12:53:48 <cjay> i see
12:58:41 <Cale> :t appendFile
12:58:51 <Cale> hmm
12:58:56 <lambdabot> thread killed
12:59:03 <Cale> @undefine
12:59:06 <lambdabot> Undefined.
12:59:23 <Cale> :t appendFile
12:59:24 <lambdabot> FilePath -> String -> IO ()
13:01:32 <dmhouse> Anyone recommend a really easy-to-use (i.e., I'm recommending this to my Grandma) FTP client for Windows?
13:02:40 <opqdonut> filezilla is the best one i've used
13:02:41 <roconnor> dmhouse: firefox?
13:02:59 <roconnor> oh, you want to upload?
13:03:41 <dmhouse> I want to upload, yeah.
13:04:05 <zachk> cuteftp?
13:04:05 <dmhouse> roconnor: so FireFTP would count, but I don't think she runs Firefox, so it'd be a bit of a faff.
13:05:24 <dmhouse> I thought about just suggesting using the built-in functionality of Windows Explorer, does anyone know if this is just an XP-or-newer feature? I can't remember but I have a feeling she might be running something a bit older. Maybe not though.
13:07:53 <roconnor> dmhouse: any reason you are not using samba / NetBIOS ?
13:08:30 <dmhouse> roconnor: instead of FTP, you mean? Well, I don't administer the server.
13:08:39 <roconnor> oh
13:08:39 <roconnor> ok
13:08:49 <dafra> Where to download darcs for Windows ? The link from http://wiki.darcs.net/DarcsWiki/CategoryBinaries fails.
13:08:51 <lambdabot> Title: CategoryBinaries - DarcsWiki
13:09:14 <dafra> i mean binaries
13:23:35 <dafra> @pl \(a,b) -> a + b
13:23:35 <lambdabot> uncurry (+)
13:24:23 <dafra> @pl \(a,b) -> a + b < 10
13:24:23 <lambdabot> uncurry (flip flip 10 . ((<) .) . (+))
13:25:05 <dafra> @pl \(a,b) (c,d) -> compare d b
13:25:05 <lambdabot> (. snd) . flip compare . snd
13:25:17 <dafra> @pl \(a,b) (c,d) -> compare bd
13:25:17 <lambdabot> const (const (compare bd))
13:25:25 <dafra> @pl \(a,b) (c,d) -> compare b d
13:25:25 <lambdabot> (. snd) . compare . snd
13:25:42 <EvilTerran> comparing snd
13:25:58 <dafra> :type comparing
13:26:11 <EvilTerran> ?type comparing
13:26:12 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:26:19 <EvilTerran> it's :t, ?type, or @types
13:26:22 <EvilTerran> er, @type, even
13:26:42 <dafra> @src comparing
13:26:43 <lambdabot> Source not found. There are some things that I just don't know.
13:27:51 <dafra> @ho comparing
13:27:52 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
13:27:59 <dafra> @hoggle comparing
13:28:04 <dafra> @hoogle comparing
13:28:07 <EvilTerran> comparing f x y = compare (f x) (f y)
13:28:07 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:28:08 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:28:20 <EvilTerran> comparing f = compare `on` f
13:28:41 <dafra> wow
13:28:51 <dafra> @type on
13:28:52 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:28:53 <dmhouse> compare f x y = f x `compare` f y.
13:29:04 <dmhouse> Err, that's on, sorry.
13:29:12 <dmhouse> No, it's not.
13:29:14 * dmhouse stops talking.
13:29:17 <dmhouse> compare f x y = f x `compare` f y.
13:29:26 <EvilTerran> "comparing f x y =..."
13:29:40 <dmhouse> on f g x y = f x `g` f y, up to order of parameters which I can never remember.
13:31:10 <dafra> "on" is what I was looking for
13:31:28 <opqdonut> dmhouse: yeah that's the right order
13:31:32 <dafra> sooooo many combinators to learn :)
13:31:37 <dmhouse> on is fairly handy.
13:32:03 <opqdonut> i prefer the "(f `on` g) x y = g x `f` g y" definition
13:32:14 <opqdonut> oh, now that i wrote that out it seems you got f and g backwards
13:34:34 <Saizan> ?type on
13:34:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:36:07 <FordCortina> @src repeat
13:36:07 <lambdabot> repeat x = xs where xs = x : xs
13:48:14 <lumi> I'm trying to do the Project Euler problem 14, and I'm kinda having trouble
13:48:58 <byorgey> lumi: what's the trouble?
13:49:08 <lumi> I solved it in Perl no problem, but in Haskell I had stack overflows in my first, naive, recursive solution
13:49:30 <byorgey> lumi: yeah, I remember having trouble with that one too.
13:50:38 <lumi> byorgey: Well, I flattened it (or I think I did), but it still seems to overflow, and takes ages to compute anything... And I can't see why, because afaics it should be linear time
13:51:59 <byorgey> lumi: my guess is that you're running into problems with laziness -- that your program is (in linear time) building up a huge unevaluated computation which blows the stack when it is actually forced to be evaluated.
13:52:18 <byorgey> @wiki Stack_overflow
13:52:18 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
13:52:36 <lumi> byorgey: Hmm... So should I throw seq's at it? Something like that?
13:52:43 <byorgey> lumi: you might try reading that page, it has a good discussion of the issues involved
13:53:13 <byorgey> lumi: hehe, that's one way to do it, although without really knowing what's going on that may prove frustrating
13:53:25 <byorgey> lumi: if you paste your code on hpaste.org I could take a look at it
13:53:26 <lumi> It's strange, because any thunks would be building the map, but I think it should be forced when I lookup...
13:53:43 <paolino> mmhh, is there a function on a Data.Map which gets an association deleting it, or I must access the map twice ?
13:53:44 <hpaste>  lumi pasted "Stack overflowing for some reason" at http://hpaste.org/8639
13:54:28 <byorgey> paolino: not that I know of
13:54:49 <lumi> Also it takes a zillion years before it dies
13:56:05 <paolino> byorgey: should I use partition ?
13:56:18 <byorgey> paolino: partition?
13:56:35 <lumi> Actually now as I thing of it, I'm not sure this overflows? My last try sure did. But the C version runs in a few seconds, and the Perl version as well, and this hasn't returned yet for just ONE path
13:56:56 <sjanssen> lumi: what does the memory consumption look like?
13:57:27 <lumi> sjanssen: Arrh. Judging by the flailing my box just did, not good
13:57:30 <zachk> openbsd question: is there a way to get colors working under openbsd console?
13:58:55 <dafra> in a list comprehension, I want to pattern match against a list of pairs only when it has only one element, but "let [(a,b)] = mylist" fails with "irrefutable pattern fails". What does that mean ?
13:59:21 <sjanssen> dafra: it means that the mylist doesn't have one element
13:59:51 <paolino> byorgey: pick x = first (head . elems) . partition (==x) ?
14:00:17 <dafra> sure, is it possible to filter out that case without "not(null mylist), null(tail mylist)" ?
14:00:21 <paolino> pick :: k -> Map k a -> (a,Map k a)
14:00:42 <sjanssen> paolino: that is definitely slower than looking up the element then deleting
14:00:49 <sjanssen> paolino: note that partition is O(n)
14:01:03 <RayNbow> just wondering, any Haskellers here that have tried out Scala? (or are using it?)
14:01:14 <paolino> sjanssen: right
14:01:17 <sjanssen> paolino: look at updateLookupWithKey
14:01:32 <lament> i have very briefly looked at scala and found it lacking
14:01:38 <dafra> used to use Scala a bit
14:01:42 <lament> but i have little use for java api anyway
14:01:55 <RayNbow> lament: lacking in which area(s)?
14:02:05 <dafra> type inference :)
14:02:06 <lament> RayNbow: elegance :D
14:02:07 * RayNbow has only watched a talk on Scala
14:02:08 <lumi> dafra: case mylist of [(a,b)] -> blah; _ -> more_blah
14:02:23 <lament> RayNbow: "let's take this broken thing and make it better by adding more stuff to it"
14:02:33 <lament> RayNbow: and then they don't have break out of for loops :(
14:02:46 <lumi> Oh sry, missed the list comprehension...
14:03:04 <dafra> lumi, yes list comprehension
14:03:07 <lumi> dafra: But what do you want to happen when the pattern fails?
14:03:13 <paolino> sjanssen: it looks the right one
14:03:20 <dafra> a failure :)
14:03:40 <dafra> i once read that when a patten match fails, the monad fails
14:03:46 <sjanssen> dafra: where does mylist come from?  Is it generated in the list comprehension?
14:03:52 <dafra> but here i get an exception :(
14:04:02 <lumi> dafra: I guess list comprehensions don't fail nicely?
14:04:09 <dafra> Scala is like F# : ocaml for the JVM
14:04:23 <dafra> Cal is much closer to haskell obviously
14:04:30 <lumi> dafra: I'd expect it to fail like in do notation, and I guess it doesn't
14:04:38 <sjanssen> dafra: only '<-' bound patterns fail, non-matching let bindings always return _|_
14:04:44 <RayNbow> dafra: I found Scala's syntax more pleasing than F#'s, for what I've seen of it
14:04:58 <RayNbow> (but I've only seen a small bit)
14:05:03 <dafra> i prefer f# syntax, and it has real type inference
14:05:23 <dafra> but your framework decides between F# and Scala, not you
14:05:45 <lumi> dafra: You're using 'let' inside a list comprehension?
14:05:48 <dafra> sjanssen: <- patterns possible in list comprehension ?
14:05:55 <dafra> i use let
14:06:17 <lumi> > [x | (x,y) <- []]
14:06:21 <lambdabot>  []
14:06:27 <lumi> Works as advertised :)
14:06:44 <RayNbow> <dafra> but your framework decides between F# and Scala, not you <-- I don't have any requirements :)
14:07:01 <RayNbow> the great freedom of learning stuff in your spare time
14:07:07 <dafra> RayNbow: then haskell is fine
14:07:29 <RayNbow> dafra: I'm still using Haskell and learning new bits every day :)
14:07:34 <dafra> lumi: you cheat, I want [(x,y)] <- mylist
14:07:49 <Associat0r> I like F# more than scala
14:07:57 <Associat0r> syntax wise and sematically
14:08:03 <dafra> +1
14:08:10 <RayNbow> but that doesn't mean I'm not going to try out a new language every now and then
14:08:14 <Associat0r> the #light syntax that is
14:08:16 <Saizan> > [x | [(x,y)] <- return []]
14:08:17 <lambdabot>  []
14:08:27 <dibblego> F# lacks higher-kinds and implicit function arguments
14:08:57 <dafra> saizan++
14:09:04 <Associat0r> true
14:09:28 <Associat0r> I have read they were added or something but not sure
14:09:29 <dafra> Saizan: i forget the "return", thx
14:09:48 <Associat0r> the implicit fun args
14:10:05 <Associat0r> does scala have higher kinds?
14:10:08 <dibblego> yes
14:10:14 <sjanssen> dibblego: are implicit function arguments actually useful?  (I know the GHC extension is more-or-less hated)
14:10:26 <dibblego> sjanssen, most absolutely definitely (e.g. you can encode type-classes)
14:10:31 <sjanssen> oh
14:10:43 <sjanssen> so the actual complaint is that scala doesn't have type classes :)
14:10:52 <dibblego> Scala implicits > type-classes
14:10:57 <dafra> Scala has higher *kinds* ???
14:11:00 <dibblego> other way around :)
14:11:12 <dibblego> dafra, sure
14:11:20 <lament> kind inference!
14:11:27 <dibblego> http://projects.workingmouse.com/public/scalaz/branches/3.0/src/main/scalaz/control/Applicative.scala
14:11:28 <RayNbow> dafra: you're wondering what a kind is?
14:11:29 <lambdabot> http://tinyurl.com/5op3bo
14:11:35 <dibblego> no, it won't infer higher-kinds - ever
14:11:48 <RayNbow> @faq can Haskell infer higher-kinds?
14:11:48 <lambdabot> The answer is: Yes! Haskell can do that.
14:11:55 <dafra> a little bit : kind of types
14:12:36 <RayNbow> hmm...
14:12:37 <RayNbow> "The... the the the... the language spec... oh, my god. I've gotta blog about this. It's, like, ninety percent [about the type system]. It's the biggest type system you've ever seen in your life, by 5x. Not by an order of magnitude, but man! There are type types, and type type types; there's complexity...
14:12:37 <RayNbow> They have this concept called complexity complexity<T> Meaning it's not just complexity; it's not just complexity-complexity: it's parameterized complexity-complexity. (mild laughter) OK? Whoo! I mean, this thing has types on its types on its types. It's gnarly." <-- Scala
14:12:44 <dibblego> @faq can Haskell kill the dragon on the first stage of The Last Ninja (Commodore 64)? If so, how?
14:12:45 <lambdabot> The answer is: Yes! Haskell can do that.
14:12:52 <dafra> but still struggling to grok monads, so higher kinds wil be for later
14:13:01 <dibblego> RayNbow, ignore the tripe from the idiot club
14:13:07 <dafra> can Haskell make some coffee ?
14:13:23 <dafra> @faq can Haskell make some coffee ?
14:13:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:13:39 <vixey> @faq can haskell help
14:13:40 <lambdabot> The answer is: Yes! Haskell can do that.
14:13:47 <RayNbow> dibblego: that quote actually made me curious about Scala's type system :p
14:13:53 <Apocalisp> @. elite faq
14:13:53 <lambdabot> thE aNs\/\/Er iz: Y3$! |-|4SK3ll c4n Do 7ha7.
14:14:03 <dafra> lol
14:14:18 <_zenon_> @faq can haskell haskell ?
14:14:18 <lambdabot> The answer is: Yes! Haskell can do that.
14:14:24 <_zenon_> oO
14:14:29 <RayNbow> @faq Can Haskell feed me?
14:14:29 <lambdabot> The answer is: Yes! Haskell can do that.
14:14:30 <dibblego> RayNbow, that quote made me remember how stupid people are (I prefer the illusion that they are not *that* stupid)
14:14:32 <RayNbow> > orderPizza
14:14:40 <Apocalisp> OK, here's the secret. @faq always outputs the same string.
14:14:43 <lambdabot>   Not in scope: `orderPizza'
14:14:46 <RayNbow> ah crap
14:14:50 <RayNbow> lambdabot forgot about orderPizza
14:14:54 <Associat0r> type classes might be added in F# later on
14:14:57 <dafra> @faq Data.List
14:14:57 <lambdabot> The answer is: Yes! Haskell can do that.
14:15:05 <Apocalisp> @let orderPizza = launchMissiles
14:15:13 <lambdabot> <local>:1:13: Not in scope: `launchMissiles'
14:15:23 <dibblego> I killed the dragon! woot!
14:15:50 <Apocalisp> dibblego: Congrats!
14:16:04 <dibblego> you have to smoke bomb from a specific place
14:16:19 <HunterXHunter4> ?fag can has sum pizzah?
14:16:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:16:21 <dafra> anyone knows how to download darcs ?
14:16:28 <dafra> for Windows, binaries
14:16:36 <dafra> the link does not work for me
14:17:34 <dafra> each time I ask for it, i get silence :)
14:17:45 <RayNbow> > orderPizza
14:17:47 <lambdabot>  Pepperoni-lambda, coming up!
14:17:48 <sjanssen> dibblego: is it necessary to write the types in each method for the Applicative instances?
14:17:55 <RayNbow> there, byorgey's orderPizza definition restored :)
14:18:07 <byorgey> heh =)
14:18:18 <sjanssen> dibblego: "def apply[A, B](f: Option[A => B], a: Option[A])" would be inferred in Haskell
14:18:28 <dibblego> sjanssen, you can use the Applicative instance as the 'this.object' argument with an implicit, then you needn't type annotate explicitly
14:18:39 <dibblego> sjanssen, yes that is inferred, since A and B are kinded *
14:18:50 <dibblego> sjanssen, oh you mean in the methods? yes that is necessary
14:19:10 <dibblego> a user would write apply(x, y) though
14:19:33 <dibblego> Scala's inferencer is perhaps its most annoying part
14:19:42 <sioraiocht> hear hear!
14:20:06 <sioraiocht> scala's inferencer and I are actually in a UN-recognised conflict
14:20:32 <dibblego> if you use the language in a specific way, you don't have to bend it so much; which leads to a contention
14:20:35 <sioraiocht> they're going to have to send in peacekeeping to suppress the violence, soon
14:20:54 <sjanssen> dibblego: do you have any samples that use Applicative (or any other encoded type classes)
14:21:02 <hpaste>  lumi annotated "Stack overflowing for some reason" with "(no title)" at http://hpaste.org/8639#a2
14:21:12 <dibblego> sjanssen, http://blog.tmorris.net/applicative-functors-in-scala/
14:21:13 <lambdabot> Title: Î» Tony&#8217;s blog Î» » Blog Archive » Applicative Functors in Scala
14:21:52 <dibblego> sjanssen, there are also many usage examples http://projects.workingmouse.com/public/scalaz/artifacts/latest/demo/scalazdemo/control/
14:21:54 <lambdabot> http://tinyurl.com/5t5p7l
14:24:27 <Associat0r> dibblego: do you know felix?
14:24:32 <dibblego> nope
14:24:54 <dafra> felix is kind of weird
14:25:03 <Associat0r> http://felix-lang.org/
14:25:04 <dafra> and the main developper stopped working on it
14:25:06 <lambdabot> Title: Felix | The Smart Upgrade from C++
14:25:21 <Associat0r> dafra : he stopped?
14:25:23 <Associat0r> why?
14:25:25 <dafra> i never managed to build it on my home
14:25:40 <dafra> he bought a boat and went for a cruise
14:25:45 <sjanssen> dibblego: Some(7) <*> None won't type?  Why not?
14:26:23 <dolio> 7 isn't a function?
14:26:23 <dibblego> sjanssen, because None is of type Option[Nothing] and the type inferencer is not clever enough to determine that it is ok
14:26:38 <dibblego> (None: Option[Int]) would type
14:26:55 <dibblego> Nothing == least type
14:26:57 <sjanssen> that seems silly
14:26:58 <Associat0r> mailing list says he is still working on it
14:27:04 <dibblego> sjanssen, another annoyance
14:27:18 <dafra> he started again, then, thats good news
14:27:35 <dibblego> def none[T]: Option[T] == None
14:27:40 <dibblego> then you could write none[Int]
14:27:53 <mattam> No implicit generalization in Scala?
14:27:55 <dibblego> apparently, there is work being done to alleviate that particular problem
14:28:12 <dibblego> mattam, yes, but only when inferencing in a forward direction
14:28:21 <dibblego> s/==/=
14:28:33 <dafra> Scala does type deduction only
14:28:54 <mattam> What does it mean? You can type: [Î»x, x : forall A, A -> A]?
14:28:56 <sjanssen> dibblego: why did you decide to flip the fixity of <*>?
14:29:40 <dafra> F# tries to infer parameter types, but that doesnt work well when you use OOP classes
14:29:41 <dibblego> sjanssen, if you suffix a function name with : you can flip it; I have both functions; but otherwise, you'd have to explicitly specify the type constructor for the applicative
14:29:59 <dibblego> I have another method <*>: where you needn't specify type annotations
14:30:01 <sjanssen> oh, because of the method thing
14:30:04 <dibblego> right
14:30:18 <dafra> because of the subtype thing
14:30:28 <sjanssen> this is the sort of thing that makes me worry about Scala -- it seems so arbitrary
14:30:43 <mattam> What's forward inference?
14:30:51 <dibblego> it's not arbitrary; just very complicated, however, it has made the right decisions in light of how busted Java is
14:30:52 <sjanssen> note that this comes from someone that doesn't really know it
14:31:06 <dafra> return type inferred from parameters type
14:31:10 <dibblego> I'd rather complicated and useful than Java, despite my frustrations at times
14:31:24 <sjanssen> but when argument order is dictated by bustedness in your type inferencer ...
14:31:37 <sjanssen> that is bordering on absurdity
14:31:41 <hpaste>  guenni pasted "hello world not working in expected sequence" at http://hpaste.org/8640
14:31:42 <dibblego> yes, but I don't think the type inferencer can be improved given Java
14:31:59 <dibblego> (i.e. nominal subtyping, uncontrolled side-effects)
14:32:26 <mattam> Ok... so I don't see how implicit generalization is forward.
14:32:34 <dibblego> the Scala authors have never intended code as powerful as that Applicative; nor its users - they do not embrace abstraction as the Haskell community does
14:32:44 <sjanssen> guenni2: hSetBuffering stdout NoBuffering
14:32:57 <mauke> sjanssen: noooooo
14:33:00 <sjanssen> guenni2: or add an hFlush after the first putStr
14:33:02 <guenni2> sjanssen: sry?
14:33:11 <sjanssen> @hoogle hSetBuffering
14:33:16 <mauke> I don't want a write(2) for each character :(
14:33:19 <lambdabot> System.IO.hSetBuffering :: Handle -> BufferMode -> IO ()
14:33:31 <sjanssen> @docs System.IO
14:33:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
14:33:54 <guenni2> sjanssen: thx
14:34:32 <dibblego> the Scala API makes me worry more about Scala than anything else; they truly hate adding abstractions and useful functions (Option is missing a join ffs!)
14:34:51 <mattam> dibblego: care to elaborate on this forward inference/implicit generalization?
14:35:10 <dibblego> mattam, in what way?
14:35:27 <Associat0r> dibblego : does scala have a light indent syntax?
14:35:50 <dibblego> Associat0r, not really (kind of, but it's not that great)
14:36:09 <dibblego> Associat0r, you can replace semi-colons with newlines in imperative code
14:36:18 <mattam> Well, I don't see how you can make implicit generalization part of a forward inference algorithm, if you're not allowed to make up new type variables in forward inference.
14:36:23 <paolino> elems . fromListWith (++)  has linear complexity ?
14:36:51 <dibblego> mattam, I'd only be speculating if I were to try to answer that; I know who could answer it though (Odersky et. al.)
14:37:09 <sjanssen> paolino: O(n log n) at least -- the input must be sorted
14:37:17 <mattam> Ok, fine. I'll have a look some day :)
14:37:18 <Associat0r> scala just seems too verbose to me
14:37:34 <dibblego> yes it's definitely verbose given Haskell
14:37:44 <dibblego> but I'd prefer it over F# any day of the week
14:38:00 <CaptinShmit> Is this the channel for chatting about Eddy Haskell from "Leave it to Beaver?"
14:38:04 <paolino> sjanssen: then I can sort and group to the same job I suppose
14:38:13 <dibblego> (I couldn't live without higher-kinds for example)
14:38:24 <sjanssen> paolino: yes, this is probably faster
14:38:44 <vixey> CaptinShmit: #Haskell-blah
14:38:57 <Associat0r> higher kinds may come later in F#
14:39:02 <sjanssen> CaptinShmit: this is for discussing the programming language Haskell.  See haskell.org
14:39:10 <dibblego> Associat0r, I might switch that day :)
14:39:12 <CaptinShmit> My bad!
14:40:02 <Associat0r> btw which kind of FRP do you guys recommend?
14:40:22 <dafra> none :)
14:40:57 <Associat0r> I have read a little about yampa
14:41:07 <Associat0r> dafra : none why?
14:41:32 <dafra> to be a bad guy
14:41:45 <dafra> seriously, frp GUIs are ugly
14:41:55 <dafra> for other uses, i dont know
14:42:15 <povman> dafra: do you mean the code or the graphics?
14:42:20 <dafra> the graphics
14:42:29 <dafra> arrows are nice
14:42:58 <povman> indeed - anyone who has seen gtk2hs code is now blind
14:43:07 <Associat0r> I am only interested in the code side of it
14:43:20 <dafra> and some gtk2hs controls are ugly too( filechooser)
14:44:30 <povman> there aren't really any other alternatives (afaik)
14:45:30 <dafra> anyone uses darcs on windows ?
14:45:59 <Toxaris> dafra: yes
14:46:09 <dafra> where did you get the binaries ?
14:46:43 <dafra> the links here : http://wiki.darcs.net/DarcsWiki/CategoryBinaries doeent work for me
14:46:44 <lambdabot> Title: CategoryBinaries - DarcsWiki
14:47:36 <Toxaris> dafra: that's where I download mine, and I tried just now, and it works
14:47:46 <kryptiskt> dafra: It has an invalid certificate
14:48:03 <Toxaris> dafra: but there were some infors about invalid certificates, which I ignored
14:48:04 <kryptiskt> use a more insecure browser
14:48:41 <dafra> good idea
14:48:42 <matthew_-> ok, constant overheads on fingertree are extensive. I can't make the intersection of finger trees get within the same ballpark as Data.Set
14:49:20 <ddarius> Are finger trees designed to support efficient intersection?  Data.Set certainly is.
14:49:45 <matthew_-> ddarius: well, yeah I discussed this earlier
14:49:49 <matthew_-> the complexity is lower
14:51:27 <matthew_-> it's O(m + log(n/m)) where n >= m
14:51:48 <matthew_-> which is better than for Data.Set (O(m + n))
14:53:15 <hpaste>  matthew-_ pasted "benchmarking finger trees?" at http://hpaste.org/8641
14:53:46 <matthew_-> but I'm also including in the benchmark the cost of the insert, which may be more expensive. Plus there may well be other things I've got wrong
14:54:50 <sjanssen> matthew_-: the strictness annotation on Key may hurt more than help
14:56:20 <matthew_-> I've tried it both on and off
14:56:28 <matthew_-> no difference really
14:57:45 <FordCortina> @src seq
14:57:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:58:04 <matthew_-> oh lol, it's just the cost of insert
14:58:06 <FordCortina> :t seq
14:58:07 <matthew_-> FT intersect is faster
14:58:08 <lambdabot> forall a t. a -> t -> t
14:58:15 <mattam> case viewl as' of EmptyL -> intersect bs' as'
14:58:18 <FordCortina> @hoogle seq
14:58:18 <lambdabot> Prelude.seq :: a -> b -> b
14:58:18 <lambdabot> Data.Sequence.Seq :: data Seq a
14:58:18 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
14:58:25 <mattam> you could shortcut that
15:00:01 <hpaste>  matthew-_ annotated "benchmarking finger trees?" with "insert appears to be expensive" at http://hpaste.org/8641#a1
15:00:37 <matthew_-> maybe Set.fromList is strict
15:01:14 <matthew_-> fromList xs
15:01:14 <matthew_->   = foldlStrict ins empty xs
15:01:17 <matthew_-> yep, appears it is
15:01:18 <matthew_-> cool
15:01:23 <sjanssen> it has to be
15:01:29 <_zenon_> return _zenon_  , into the IRLMonad
15:01:41 <matthew_-> sjanssen: why?
15:02:05 <mattam> matthew_-: you can rewrite this call to intersect bs' as' to empty I think.
15:02:49 <sjanssen> matthew_-: because elements are kept in order, and you have to examine each element of the input to determine that order
15:03:21 <jstanley> How can I get haddock 0.8 to link to the haskell hierachical lib documentation online? --use-index='http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html' doesn't seem to be doing the trick.
15:03:22 <lambdabot> http://tinyurl.com/5spd7e
15:04:07 <matthew_-> mattam: that saves at most 1 call ;)
15:04:34 <RayNbow> http://www.animenewsnetwork.com/news/2008-06-30/japanese-animation-dvd-ranking-june-18-25
15:04:35 <lambdabot> Title: Japanese Animation DVD Ranking, June 18â€“25 - Anime News Network, http://tinyurl.com/5qv79e
15:04:37 <RayNbow> ah crap
15:04:39 <RayNbow> wrong channel
15:04:46 <mattam> matthew_-: nope, if you have many more elements in bs' you will fold over all of them, no?
15:04:54 <matthew_-> args are swapped
15:05:34 <mattam> Ah right.
15:06:31 <kryptiskt> too bad, I hoped they had made a haskell anime
15:06:49 <mattam> insert would be more efficient searching for >= Key partition first probably.
15:09:51 <sjanssen> matthew_-: 'foldr insert' is not the best way to build your Set, I imagine
15:09:58 <sjanssen> matthew_-: try foldl' (flip insert)
15:10:32 <glguy> What the best way to strictly insert something into a map?
15:11:31 <matthew_-> sjanssen: woah - that's MUCH faster now
15:11:41 <matthew_-> in terms of total running time
15:11:44 <RayNbow> <kryptiskt> too bad, I hoped they had made a haskell anime <-- a small Haskell cameo would be sufficiently awesome... I doubt we'll ever see a Haskell anime :p
15:12:04 <sjanssen> matthew_-: how many elements are you inserting?  Remember that foldr will require O(n) extra stack
15:12:26 <sjanssen> glguy: I assume you want to modify the old value somehow?
15:12:29 <matthew_-> 10000 elems in both n and m
15:12:45 <mattam> matthew_-: Are you sure the [(l, _) = split (<= Key x) l'] in insert is correct?
15:12:51 <HunterXHunterX> omg haskell anime is teh win
15:12:53 <matthew_-> mattam: yes, test the code
15:13:32 <sjanssen> glguy: insertWith'
15:13:44 * sjanssen didn't think that function was in there
15:14:28 <matthew_-> ok, so with foldl' and including the construction in the benchmarks, fingertrees are 10x slower than set. But just the intersection on its own, I can't get a non-zero reading for finger trees, and can for sets
15:14:30 <mattam> Well, I suppose you're right. And I should be sleeping instead of trying to find bugs in your code :)
15:14:58 <matthew_-> mattam: incorrect - you should always be finding bugs in my code ;)
15:15:10 <mattam> argh
15:15:40 <glguy> sjanssen: I was using alter
15:15:57 <glguy> ut I seem to have fixed it now...
15:16:01 <sjanssen> matthew_-: perhaps it would be faster to construct your OrdSeq with some sort of merge sort?  (is there also a fast algorithm for merge?)
15:16:14 <matthew_-> sjanssen: yes, in the code ;)
15:16:41 <sjanssen> glguy: alter (\m -> case m of Just !x -> ...; Nothing -> ...)
15:16:49 <matthew_-> but I was really just trying to test the intersection. merge has the same complexity as intersection
15:17:04 <shapr> yow
15:17:08 <glguy> sjanssen: yeah, I solved it in a very similar way. result `seq` Just result
15:19:33 <matthew_-> my god. Even with 1,000,000 elems in both finger trees, the intersection is instantanious
15:19:59 <vixey> that's almost a million !
15:20:14 <matthew_-> well, almost. It's actually the length of the random list
15:20:23 <matthew_-> and the finger trees and sets will both remove duplicates
15:20:40 <matthew_-> so they won't be a million long. But they will both be built from the same list, and so will be the same size
15:20:45 <matthew_-> > time ./FingerTreeTest 1000000 1000000 0 2000000 10000 2010000 20 +RTS -K128M
15:20:45 <matthew_-> asdftimo: 0.0; Set: 7.320455e-2
15:20:47 <lambdabot>   Not in scope: data constructor `K128M'
15:21:03 <matthew_-> oops, my shell PS1 is not helpful ;)
15:21:27 <matthew_-> and s/asdftimo/FT/
15:22:49 <sjanssen> hmm
15:23:28 <sjanssen> matthew_-: testing the speed of showing the entire structure isn't necessarily the best way
15:23:45 <matthew_-> sjanssen: sure. But I couldn't think of what else to do
15:24:18 <sjanssen> intersect is sufficiently strict that `seq` will do
15:25:28 <matthew_-> yeah, but that's not going to reduce the time ;)
15:25:40 <matthew_-> ...though maybe for Set?
15:25:52 <sjanssen> I don't know
15:25:57 <sjanssen> how large is the intersection?
15:26:05 <matthew_-> big
15:26:49 <matthew_-> so the lists building both m and n are both 1,000,000 elems long. And those are drawn from between 0 and 2,000,000 for m and between 10,000 and 2,010,000 for n
15:27:35 <matthew_-> removing show seems to double the speed for Set. But it's still FT: 0.0; Set: 3.820235e-2
15:28:39 <matthew_-> so the vast majority of n should overlap with the vast majority of m
15:30:14 <matthew_-> something must be wrong, even without the division, I'm getting 0 reported for the FT intersect time. It would appear it's not doing any work
15:30:50 <mattam> matthew_-: I still suspect your insert is buggy. It seems to get rid of every element less than the element you insert along with the duplicates. I can't test, but if you can try a insert 3 (insert 1 empty) you'll see if I'm wrong.
15:32:01 <matthew_-> mattam: oopsy.
15:32:05 <noecksit> hello, today at work i finally read through arrows and its really interesting concepts
15:32:19 <matthew_-> mattam: you're right. Now aren't you glad you didn't go to bed? ;)
15:32:32 <noecksit> but it seems that it is not applicable to much except parsers
15:32:41 <mattam> I can go now? ;)
15:32:45 <noecksit> am i wrong?
15:32:55 <ddarius> noecksit: Yes.
15:33:19 <noecksit> ddarius : what are some other stuff that I may apply it to?
15:34:15 <ddarius> The typical examples are often stream-processing type applications.
15:34:41 <matthew_-> mattam: yeah, the second split should be == Key shouldn't it?
15:34:53 <noecksit> would it work well for network sockets?
15:35:02 <ddarius> mattam: You should have run while you could've.
15:35:09 <mattam> Yep.
15:35:33 <mattam> I'm sleeping, NOW!
15:35:46 <matthew_-> thank you, mattam!
15:35:47 <ddarius> noecksit: That question doesn't make much sense.
15:36:02 <noecksit> like i have a network socket that im keeping in a recursive loop forever, could i somehow modify it to use arrows?
15:37:00 <noecksit> well, u said stream-type processing, a socket listening for data can be considered a stream, right?
15:37:01 <ddarius> noecksit: You are missing what arrows capture.  If you get monads, the idea is similar.
15:38:29 <ddarius> Yes, arrows can be used for capturing the notion of a stream processing program.  They aren't streams or a particular action on streams.
15:38:52 <noecksit> as far as i understand, what you can do with arrows that you cant do with monads is have a computation that brances off into two functions
15:39:05 <noecksit> but it may be more than that
15:39:24 <ddarius> noecksit: You have it backwards.  Arrows can't "do" any more than monads.  Every monad gives rise to a Kleisli arrow.
15:39:44 <ddarius> noecksit: Arrows are a weaker, but therefore more generally applicable notion.
15:40:29 <ddarius> noecksit: The usual thing one thinks about is that arrows let you guide the program with static as well as dynamic information.
15:40:32 <noecksit> so monads can do more than arrows?
15:40:45 <ddarius> noecksit: Yes, but less things are monads.
15:41:13 <noecksit> http://en.wikibooks.org/wiki/Haskell/Arrows says "they can do everything monads can do, and more"
15:41:38 <Toxaris> noecksit: "can do" is not exactly well-defined
15:41:55 <dolio> That's probably supposed to mean that all monads give rise to arrows, but there are additional arrows beyond that.
15:42:17 <Toxaris> noecksit: both monads and arrows are abstractions. abstractions don't do anything. specific instances do something.
15:42:52 <ddarius> noecksit: Anything you write monadically could be written using arrow notation by using the Kleisli arrow, but there is less you can do with something knowing that it is only an arrow.
15:42:54 <Toxaris> noecksit: now, abstractions are useless if you have only one instance, so the interesting point is when you have more then one instance, and you want to write a function which works for all instances.
15:43:03 <Toxaris> noecksit: like, e.g., mapM for all monads.
15:44:18 <dibblego> perhaps better rephrase would be "all data structures that are monads, are also arrows; there are more data structures that are arrows (but not monads)"
15:44:36 <ddarius> dibblego: "give rise to arrows"
15:44:47 <dibblego> or just that :)
15:45:20 <noecksit> ddarius: there is less you can do with something knowing that it is only an arrow, but more you can do with it knowing that it is a monad?
15:45:39 <ddarius> noecksit: Yes.
15:45:53 <Toxaris> noecksit: since for every monad, there is an corresponding arrow, you can use a arrow-processing function for monads, too. this is not possible the other way around. therefore, arrow-processing functions "can do more" then monad-processing functions, because they are applicable to more types
15:46:01 <matthew_-> sjanssen: ahh. with a working insert, fingertrees seem about 20 times slower
15:46:20 <ddarius> The wording in the wikibook is misleading at best.
15:46:22 <hpaste>  morrow pasted "minimal getOpt with regexqq" at http://hpaste.org/8642
15:46:46 <Toxaris> noecksit: on the other hand, a monad-processing function can use its knowledge that it has indeed a monad, and do monad-specific things with it, so it can "do more"
15:47:19 <Toxaris> noecksit: so, "can do more" is not usefull to understand anything :(
15:47:46 <noecksit> i think i sort of understand, ill need to look at Kleisli arrows i guess
15:48:16 <Toxaris> dibblego: are arrows about data structures? the "canonical" example surely is (->), which I don't see as a data structure normally.
15:48:39 <dibblego> Toxaris, I see that as a data structure, but that's just me
15:48:40 <ddarius> noecksit: One rarely has need or want to use the Kleisli arrow as the monad notation is quite a bit more perspicuous than the arrow notation.
15:49:03 <noecksit> kind of like, knowing that a data structure is an Int, you can do more functions on it, but knowing that it is just an a, you can't use the same functions on it?
15:49:51 <ddarius> noecksit: A better example is that there are a lot more functions Int -> Int than there are forall a. a -> a, but you can apply the latter to a lot more things (everything actually).
15:50:28 <noecksit> k
15:50:33 <shapr> What did I miss?
15:50:45 <ddarius> shapr: You missed the Rapture.  I'm sorry.
15:50:48 <Toxaris> noecksit: compare the typeclasses Eq and Ord.
15:50:54 <shapr> aww
15:51:19 <hellige> i really hate the "more general" comment about abstractions.
15:51:22 <hellige> and this is exactly why.
15:51:41 <hellige> you've always got to scratch your head and say "ok, now which way do they mean this..."
15:51:41 <shapr> hellige: Fix it! It's a wikibook!
15:51:53 <hellige> shapr: well, true, but the usage is pervasive.
15:52:02 <shapr> Well, you can fix one bit :-)
15:52:11 <hellige> and i think that at least in the haskell community it's pretty consistent.
15:53:20 <shapr> re-educate the community!
15:53:23 <shapr> Write a blog post that fixes it!
15:53:53 <noecksit> are there any "good" or better arrow tutorials or papers to recommend?
15:54:29 <shapr> @index (+++)
15:54:29 <lambdabot> Control.Arrow, Text.Html, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
15:54:34 <hpaste>  matthew-_ annotated "benchmarking finger trees?" with "final version. Now bed." at http://hpaste.org/8641#a2
15:54:42 <ddarius> @where arrow
15:54:42 <lambdabot> I know nothing about arrow.
15:54:46 <ddarius> what the?
15:55:03 <dibblego> @where arrows
15:55:03 <lambdabot> http://www.haskell.org/arrows/
15:55:14 <ddarius> Curses.
15:55:20 <hellige> shapr: ok, you win!
15:55:24 <shapr> yay!
15:55:37 <shapr> @index name_
15:55:38 <lambdabot> bzzt
15:55:39 <shapr> hmm
15:55:44 <hellige> the wikibook now says: Arrows are a generalization of monads: every monad gives rise to an arrow, but not all arrows are monads.
15:55:52 * dons has to pick a job title for a new set of business cards
15:55:57 <dons> "Assitant to the Compiler" ?
15:55:58 <noecksit> dibblego : yeah, i saw that one actually
15:56:03 <hellige> instead of the previous "they can do everything monads can do, and more."
15:56:05 <Toxaris> "not all arrows give rise to monads"
15:56:14 <Toxaris> :)
15:56:19 <Botje> dons: Grand Inquisitor to the Lambda?
15:56:20 <dons> "Secretary of StateT" ?
15:56:26 <hellige> Toxaris: well, i figured i could take a shortcut there, but maybe not. ;)
15:56:27 <ddarius> +the
15:56:29 <dibblego> I think the Eq/Ord comparison is a good one to use
15:56:31 <dons> hmm, inquisitor eh?
15:56:33 <shapr> ADEpt: y0
15:56:37 <shapr> @seen ADEpt
15:56:37 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:56:39 <pirothezero> anyone know if xcode is abs. necessary for use with hugs98 on OS X ?
15:57:00 <Botje> i highly doubt that
15:57:04 <mauke> preflex: seen ADEpt
15:57:04 <preflex>  ADEpt was last seen on #haskell 12 hours, 29 minutes and 54 seconds ago, saying: EvilTerran: oh. of course
15:57:05 <shapr> dons: Abstract Speed Racer ?
15:57:16 <Botje> compiler jockey!
15:57:30 <dons> "Director of Abstractions"?
15:57:54 <Toxaris> hellige: actually, I think it should read "Arrows are an alternative for Monads" or something like that, if you generalize Monads, you arrive at Functors, but not at Arrows imho.
15:57:56 <dons> we have one guy already chose "Metabarrista"
15:58:12 <shapr> Futumorph?
15:58:37 <shapr> Stewart of the Community?
15:58:48 <hellige> Toxaris: well, i'm not sure about that. wadler et al just had a paper about this, didn't they?
15:58:56 <shapr> shh, he's here!
15:59:04 <edwardk> =P
15:59:09 * shapr snickers
15:59:13 <ddarius> Everyone back to work.
15:59:17 <shapr> right!
15:59:20 * edwardk twixes
15:59:23 <dons> quick, look busy!!
15:59:38 <sebell> pirothezero: What version of OS X/platform?
15:59:51 <hellige> Toxaris: We revisit the connection between three notions of computation: Moggi's monads, Hughes's arrows and McBride and Paterson's idioms (also called applicative functors). We show that idioms are equivalent to arrows that satisfy the type isomorphism A ~> B = 1 ~> (A -> B) and that monads are equivalent to arrows that satisfy the type isomorphism A ~> B = A -> (1 ~> B). Further, idioms embed into arrows and arrows embed into monads.
15:59:55 <shapr> dons: Secretary of StateT is pretty good.
15:59:58 <hellige> there's the one.
16:00:06 * osfameron moves his blog to somewhere less comment-unfriendly
16:00:29 <dons> I also like Director of Abstractions
16:00:51 <Botje> "go back to splitting those lambdas!"
16:01:20 <macondo> Have you ever heard about Haskel being taught in Argentina?
16:01:29 <shapr> Haskell is being taught in Boston.
16:01:29 <Toxaris> hellige: sounds quite interesting
16:01:47 <shapr> Both of the new hires in my area have had classes involving Haskell.
16:01:59 <shapr> @users
16:01:59 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:02:01 <dons> Monadic Architect?
16:02:03 <shapr> preflex: @users
16:02:12 <dibblego> dons, Director of Abstraction
16:02:14 <dons> Monadic Cosmonaut
16:02:29 <shapr> Tribes of Monadic Grad students roam the campus!
16:02:39 <RayNbow> <dons> Monadic Cosmonaut <-- wait... Monads in Space?
16:02:42 <macondo> No, nobody teaches Haskel: Haskell would be better
16:02:50 <dons> Abstraction Engineer
16:03:29 <Toxaris> RayNbow: sure, carrying nuclear waste around
16:04:20 <RayNbow> but will it be a sequel or a prequel to Pigs in Space, Toxaris?
16:05:07 <Toxaris> RayNbow: Is the Cotime Comonad a time machine?
16:05:36 <RayNbow> sorry, I'm not a Co-master yet
16:05:46 <tp76> You guys makes Haskell look less attractive ;-p
16:06:00 <RayNbow> I'm limited to corecursion (fibs = 0 : 1 : zipWith (+) (tail fibs) fibs)
16:07:11 <Toxaris> Is a monadic cosmonaut dual to a comonadic smonaut?
16:09:55 <RayNbow> Toxaris: no idea, perhaps we should ask reddit? :p
16:13:11 <mmorrow>  > ghci> let isLeap x=x`mod`4==0&&(x`mod`100/=0||x`mod`400==0);ds=[31,28,31,30,31,30,31,31,30,31,30,31];daysInM y m = let n=(m-1)`mod`12+1 in if isLeap y&&n==2 then 29 else ds!!(n-1) in daysInM 1324 2
16:13:22 <mmorrow>  > let isLeap x=x`mod`4==0&&(x`mod`100/=0||x`mod`400==0);ds=[31,28,31,30,31,30,31,31,30,31,30,31];daysInM y m = let n=(m-1)`mod`12+1 in if isLeap y&&n==2 then 29 else ds!!(n-1) in daysInM 1324 2
16:13:28 <mmorrow> > let isLeap x=x`mod`4==0&&(x`mod`100/=0||x`mod`400==0);ds=[31,28,31,30,31,30,31,31,30,31,30,31];daysInM y m = let n=(m-1)`mod`12+1 in if isLeap y&&n==2 then 29 else ds!!(n-1) in daysInM 1324 2
16:13:31 <lambdabot>  29
16:13:34 <mmorrow> heh
16:40:42 <BMeph69> ?users
16:40:43 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:40:50 <shapr> preflex: ?users
16:40:52 <shapr> foo
16:41:01 <vixey> 430 users
16:41:10 <vixey> I don't know anything more than taht..
16:42:20 <mauke> preflex doesn't track users
17:01:49 <Apocalisp> is there a graphical notation for function types?
17:03:35 <vixey> t -> u
17:04:55 <povman> Apocalisp: also check out eros
17:14:47 <pjdelport> Apocalisp: specifically http://www.haskell.org/haskellwiki/Eros
17:14:48 <lambdabot> Title: Eros - HaskellWiki
17:15:49 <pjdelport> also http://www.haskell.org/haskellwiki/TV
17:15:52 <lambdabot> Title: Tangible Value - HaskellWiki
17:15:58 <pjdelport> there's a nifty demo video somewhere
17:16:13 <povman> is it possible to generalise the translation between the recursive fib function and the zip version?
17:21:12 <vixey> povman: yes
17:21:48 <povman> enough to be generally useful?
17:22:06 <vixey> povman: it's occasionally useful.. for homework questions and so on
17:26:23 <shapr> hello world!
17:26:59 <the_world> hello
17:27:03 <shapr> hiya!
17:27:54 <shapr> y0 edwardk2
17:28:14 <edwardk2> it worked
17:28:23 <shapr> yes, I think it did.
17:28:38 <shae> It also works for multiple clients at once.
17:29:12 <shapr> next step is to get a lambdabot clone running via jabber...
17:32:53 <gwern> dyamnuh. my script is screwed up! It's just doing some text muncching, but it's  turning a 70kb file into a 2gb fille
17:34:28 * gwern wonders how I so eppically screewed up. the code seems ffairly straaightforward...
17:34:39 <shapr> I think your keyboard has some problems.
17:34:54 <the_world> I think we know whats wrong with his script now...
17:35:17 <gwern> shapr: no, that's system load problems  from accidentallyy ttrying to execute said 2/4gb shell script
17:36:02 <shapr> oh
17:39:57 * Peaker is still struggling with the notion of transparent computations. Computations that I can either "apply" to an input, or pattern-match (non-exhaustively, due to an open world) to check which computation it is. The set of computations should be extensible
17:42:30 <Peaker> Maybe I can start instead by reimplementing the incremental computation monad as an arrow
17:46:03 <dibblego> does C# 3 have the equivalent of List fold?
17:48:19 <Apocalisp> surely
17:48:39 <Apocalisp> if not, it should be easy enough to write
17:50:44 <dibblego> found it
17:50:52 <dibblego> Enumerable.Aggregate
17:51:01 <dibblego> (Select -> map, Where -> filter)
17:51:12 <dibblego> (is there unfold? m hopes are diminishing)
17:54:30 <dolio> Maybe C# 3 is a total language with only inductive types?
17:57:35 <mar77a> hey when i do ^O in nano to save i see an option to save as DOS format
17:57:39 <mar77a> but i've no clue how to access it
17:57:41 <mar77a> any ideas?
17:58:04 <mauke> É¯Ä±ÊŒ Çsn
17:58:17 <mar77a> oh god bad characters in my irssi
17:58:19 <mar77a> what?
17:59:00 <sebell> Don't listen to the poor misguided soul
18:01:21 <ddarius> mauke: You have too much time on your hands.
18:01:43 <mauke> why?
18:02:22 <ddarius> Let's find crazy upside-down characters or decent approximates.
18:02:27 <sanxiyn> Hello, is this correct channel for asking Hat (Haskell Tracer) help?
18:03:18 <mauke> ddarius: just ask the internet
18:03:45 <sanxiyn> ddarius: http://www.sevenwires.com/play/UpsideDownLetters.html
18:03:46 <lambdabot> Title: How to type upside down letters and text in HTML
18:07:00 <sanxiyn> With $ hmake -hat -package ... I get:
18:07:06 <sanxiyn> hat-trans IsarSym2Latex.hs
18:07:06 <sanxiyn> hat-trans: Variable or constructor not in scope: isLetter
18:07:28 <sanxiyn> Debian unstable, GHC 6.8.2, Hat 2.05.
18:08:03 <sanxiyn> Relevant lines are:
18:08:11 <sanxiyn> import Data.Char(isLetter)
18:08:18 <sanxiyn> ... isLetter c || c == ' ' || ...
18:08:58 <sanxiyn> Looking at http://www.haskell.org/hat/libraries.html
18:08:59 <lambdabot> Title: Libraries in Hat
18:09:05 <sanxiyn> Data.Char is said to be "supported".
18:09:21 <sanxiyn> So, 1) what's going on? 2) how do I fix it?
18:10:07 <mauke> does isAlpha work?
18:11:35 <sanxiyn> mauke: Yes it does! Is it a magic ?!
18:11:56 <mauke> isAlpha is the "standard" name
18:12:02 <mauke> I don't know where isLetter comes from
18:12:11 <sanxiyn> (Hat is complaining about other things, but isLette error is no more.)
18:12:25 <sanxiyn> mauke: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#v%3AisLetter
18:12:26 <lambdabot> http://tinyurl.com/56t3xh
18:13:23 <mauke> I know it's there but it's not in Char (isAlpha is, though)
18:13:29 <mauke> (Char is the Haskell98 module)
18:13:40 <sanxiyn> ok
18:14:15 <dolio> Why are both of those in there?
18:14:31 <dolio> The docs even say they're equivalent to one another.
18:14:32 <sanxiyn> No idea.
18:15:16 <dolio> That's kind of an unusual move for the standard libraries.
18:15:23 <mauke> nah
18:15:31 <sanxiyn> Argh, Data.Map is not supported by Hat.
18:15:32 <mauke> Haskell is obsessed with renaming standard functions
18:15:47 <edwardk> mauke: yeah =/
18:15:51 <sanxiyn> Hm is there a way to ignore Data.Map, for example, by telling Hat not to trace it?
18:16:08 <dolio> There are lots of examples of functions that do the same thing with slightly different types.
18:16:13 <mauke> even if it's an 1:1 port of an existing C interface and there are no real docs, WE MUST USE COMPLETELY DIFFERENT NAMES
18:16:42 <edwardk> mauke: i blame it on folks trying to make the interface more haskelly
18:16:47 <dolio> But I can't think of many that have the exact same type and behavior with different names (in the same module).
18:17:02 <sanxiyn> mauke: That seems to be a wise move.
18:17:05 <mauke> yes, because executeFile is more Haskelly than exec
18:17:27 <sanxiyn> New wine into new wineskins, etc.
18:17:33 <sanxiyn> Was it old wine?
18:17:44 <edwardk> i think this is a pretty old whine ;)
18:18:00 <proq> old wine
18:18:14 <proq> rather, new wine into old wineskins  :P
18:18:33 <sanxiyn> Anyway, wines are good, and thank you for help!
18:18:50 <mauke> also, getProcessStatus is obviously superior to waitpid
18:20:02 <sanxiyn> mauke: getProcessStatus is 16 characters, much longer than waitpid, therefore it reveals the function's glory better.
18:20:18 <mauke> what is this, java?
18:20:21 <edwardk> note to self, keep the posix api for kata simple and don't rename things in it lest mauke hurt me ;)
18:20:40 <dolio> No, no. Shorter is better. Just look at Arc.
18:21:02 <edwardk> mauke: especially since we're so loquacious when it comes to the rest of our libraries. liftM, arr, init, ...
18:21:08 <mauke> hah. exactly
18:21:39 <dolio> What would init expand into? I'm not exactly sure.
18:21:44 <mauke> getProgName--
18:22:15 <mauke> is there any way to get at argv[0] from Haskell?
18:22:51 <dolio> It's not what you just decremented?
18:23:02 <mauke> nope
18:23:25 <mauke> getProgName returns the name of the program as it was invoked. However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked.
18:23:44 <mauke> what if I want argv[0], not the program name?
18:24:03 <sanxiyn> mauke: Be careful: troops of the Republic of Haskell might get at you.
18:24:07 <mauke> or what if I need the path information?
18:24:09 <sanxiyn> http://lisperati.com/landoflisp/panel63.html
18:24:31 <dolio> mauke: Just write your main in C and use the FFI. Easy as pie. :)
18:25:41 <mauke> my "solution" in preflex is to ignore getProgName and call readSymbolicLink "/proc/self/exe" instead
18:26:00 <sanxiyn> mauke: Call GetMainExecutable on Windows.
18:26:05 <mauke> (can't use readlink, that would be too obvious)
18:26:48 <mauke> preflex probably doesn't work on windows anyway
18:27:14 <sanxiyn> oops GetModuleFilename, I mean.
18:27:37 <proq> mauke: what's wrong with: main = do args <- getargs
18:27:49 <mauke> proq: doesn't include argv[0]
18:27:53 <proq>                              putStrLn ("args:" ++ args !! 0)
18:27:55 <jre2> any know what to set in a .cabal file to imply --executables when running Setup.hs haddock? I can't seem to find anything in cabal's manual
18:28:07 <proq> mauke: oh, right
18:28:14 <mauke> FOR YOUR CONVENIENCE
18:29:18 <sanxiyn> If you want relocatable binary, http://www.autopackage.org/docs/binreloc/ is one solution that does work.
18:29:23 <lambdabot> Title: Guide to Making Relocatable Applications :: autopackage
18:29:27 <sanxiyn> It's definitely overengineered though.
18:30:16 <shachaf> Hey, RWH has an animal!
18:30:31 <shachaf> I didn't hear about that.
18:30:56 <sebell> mauke: You could findExecutable on getProgName, but that's pretty brittle
18:31:35 <mauke> sebell: yeah, that doesn't work
18:32:02 <mauke> preflex wants to re-exec itself
18:32:09 <mauke> and it's not in the path
18:55:38 <noecksit> @src Control.Comonad
18:55:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:58:39 <dolio> @where category-extras
18:58:39 <lambdabot> I know nothing about category-extras.
18:59:12 <dolio> @hackage category-extras
18:59:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
18:59:34 <dolio> That's where you'll find Control.Comonad
19:11:31 <dons> mmorrow: http://aur.archlinux.org/packages.php?ID=18179 :)
19:11:32 <lambdabot> Title: AUR (en) - hstidy
19:14:22 <mmorrow> dons: awesome. phew, for a second i there i thought there already was an hstidy
19:14:38 <mmorrow> s/i//
19:15:21 <mmorrow> that was fast :)
19:15:44 <dons> its automated.
19:15:57 <dons> if you publish type correct code on hackage, it'll be packaged for Arch
19:16:37 <mmorrow> heh
19:16:50 <chessguy> what's Arch?
19:17:34 <mmorrow> http://www.archlinux.org/\
19:17:49 <chessguy> ah
19:17:57 <chessguy> you could have just said "a linux distro" :)
19:18:51 <mmorrow> the middle mouse button's just one buttone though :)
19:19:28 <mmorrow> (one of thinkpads' greatest feature)
19:19:32 <mmorrow> s
19:20:33 <mmorrow> chessguy: did you ever mess around with chess and monoids further?
19:20:56 <chessguy> mmorrow: i did not. i don't know the CT well enough
19:25:08 <mmorrow> i'm sure it'll come together
19:25:44 * chessguy shrugs. it was just an idea, and a rather vague one at that
19:27:52 <mmorrow> heh very, but thinks always fall into place with handwaving
19:28:37 <mmorrow> i'm sure the *CT* will come together :)
19:30:10 <chessguy> i was thinking that it would be cool to learn CT by implementing various structures in haskell....except....it's hard to say whether or not the implementations are _right_, because it's hard to actually find anything to _do_ with them
19:32:38 <mmorrow> chessguy: totally
19:34:08 <cjs> You can use them to wave your arms about dramatically.
19:35:18 <chessguy> haha
19:35:49 <ddarius> chessguy: The proof one has all finite limits if one has a terminal object, finite products and finite equalizers is a unification algorithm.
19:36:13 <chessguy> ddarius: huh?
19:37:20 <dtog> Hey, isn't a terminal object a product of 0 objects?
19:37:43 <ddarius> dtog: Yes.  So you can drop that.  Usually one says pairs and equalizers.
19:38:05 <chessguy> ddarius:  i wasn't talking about proofs, just concrete examples of what to do with instances of groups, categories, morphisms, etc.
19:38:32 <mmorrow> ddarius: interesting. have you seen this paper (probably)? http://www.haskell.org/th/papers/Typing_Template_Haskell__Soft_Types.ps
19:38:33 <lambdabot> http://tinyurl.com/5okp6c
19:39:26 <mmorrow> ddarius: it seems to be unification and it's dual are pushout/pullback-esque
19:39:36 <mmorrow> seems to *me*
19:39:48 <chessguy> anyway, wife says it's bedtime. until tomorrow!
19:40:05 <ddarius> chessguy: I'm saying you can write a function, parameterized by these things, that's more or less just a transcription/formalization of that proof and you've written a unification algorithm.
19:40:09 <ddarius> Crap
19:41:03 <mmorrow> hah
19:41:05 <ddarius> mmorrow: http://www.cs.ucsd.edu/~goguen/pps/subs.ps Read that.
19:41:05 <Korollary> His wife unified him
19:41:38 <mmorrow> ddarius: ooh, exciting
19:42:13 <ddarius> It's kind of weird because of Goguen's desire to be "simple."
19:48:31 <mmorrow> interesting..
19:48:55 <ddarius> @tell chessguy http://www.cs.man.ac.uk/~david/categories/  Read the "Manual" which is actually a book.
19:48:55 <lambdabot> Consider it noted.
19:52:16 <ddarius> mmorrow: See also chapter 8 of that book.
20:01:36 <cjs> Haskell really seems to force me towards bottom-up programming.
20:01:52 <cjs> It's harder to leave lower-level stuff unimplemented or partially implemented.
20:02:06 <SamB> cjs: well it's about time you learned that
20:02:20 <cjs> It's not really a good thing, at least not for me.
20:02:21 <SamB> (the habbit of bottom-up programming, I mean)
20:02:40 <SamB> how come?
20:02:43 <cjs> Why? Again? I did it for a long time, and lessened my use of it greatly for good reasons.
20:03:01 <cjs> I find mysylf building little bits to store and access data too early, and then discovering I built the wrong ones.
20:03:15 <cjs> (Not usually completely wrong, mind you, but wrong enough that the need noticable work to fix.)
20:04:01 <lament> cjs: Me Too!
20:04:10 <SamB> hmm.
20:04:33 <dons> cjs, you're organising the Tokyo Society for the Application of Currying meeting today?
20:04:34 <SamB> Well, how do you think it ought to go ?
20:04:37 <cjs> But maybe I should be trying to make better use of defining lower-level functions with appropriate types, but as undefined, and letting the type system be my tester.
20:04:40 <cjs> dons: That was last week.
20:04:44 <dons> ah
20:04:50 <dons> yes, so i see.
20:05:21 <dons> btw, is starling-software.com a haskell company that should be on the haskell.org industry page?
20:05:42 <SamB> cjs: or you could write your code in Coq and use Axioms ;-P
20:05:48 <dons> i.e. you do something in haskell commercially, or are moving that way? :)
20:05:56 <lament> there's a society for application of currying?
20:06:12 * dons pimps the industry page, http://haskell.org/haskellwiki/Haskell_in_industry
20:06:20 <SamB> I want a society for the partial application of currying
20:06:20 <lament> is there one for application of the singleton pattern?
20:06:33 <ddarius> lament: There is one for the application of Schoenfinkeling
20:07:26 <lament> heh
20:07:55 <cjs> I'm writing an automated options trading system.
20:08:17 <cjs> So yes, completely commercial. It's about 80% of my work, and about 40% of our company's.
20:08:29 <dons> and you're using haskell in some way?
20:08:37 <cjs> For that trading system, yes.
20:08:45 <dons> woot, you get to join the industry page then :)
20:08:50 <cjs> We're intending to move most of our stuff over to Haskell over the next few years.
20:08:56 <dons> wonderful!
20:09:00 <cjs> Assuming that I can manage to lean it. :-)
20:09:06 <cjs> s/lean/learn/
20:09:06 <lament> haha
20:09:06 <dons> be sure to lean on the community then.
20:09:26 <dons> the cool thing about haskell is that you've got a bunch of people and companies collaborating on the infrastructure
20:09:29 <cjb> cjs: I see you're working particularly hard on it!
20:09:30 <cjs> Yes, I have been. Particularly here. I'm going to see if I can scrounge up the cash to get to CUFP this year, actually.
20:09:32 <dons> so just ask if you need it :)
20:09:39 <cjs> Thanks!
20:09:58 <dons> we particularly like to know about libs and tools that need work, prior to hackathons
20:10:04 <cjs> Though a lot of it is there. Production-quality compiler, good tools (e.g., profiler), ByteString....
20:10:31 <cjb> cjs: (that was an 80%+40% joke.  I can't tell whether you were making a joke, and now other people won't be able to tell that I was making a joke because it wasn't very obvious, and so everything sucks.)
20:10:37 <dons> yes, there's enough support to do most things now
20:10:50 <cjs> cjb: Heh. That's what you get for getting too self-referential.
20:11:30 <ddarius> @protontorpedo
20:12:12 <cjs> I looked at Haskell, O'Caml and Scala before starting this project. Scala was really just there in case I needed to run on a JVM, which I don't, thank God. O'Caml has nastier syntax, doesn't seem as sophisticated in terms of control structures, and appears as if it's going to lose to Haskell in terms of performance in the next few years.
20:13:25 <dons> haskell has community momentum :)
20:13:59 <cjs> Hugely. And having so much great research happning on the compiler side is a big help, though the way it gets translated into production-quality compilers is unusual.
20:14:34 <cjs> Anyway, what's needed. _Real World Haskell_ looks like a good start. Picking up the idioms and more sophisticated control structures is damn hard.
20:14:36 <dons> the short path from research to commercial deployment is quite unusual
20:14:42 <dons> right.
20:15:01 <cjs> I've done well over 50 full days of Haskell programming, and I'm still struggling.
20:15:17 <dons> we need  to build up the general understanding of how to program effectively in a purely functional way, exploiting all the benefits, and understanding the drawbacks
20:15:31 <cjs> (Though part of it is just my poor functional list-handling skills; I did _The Little Schemer_ before this, and that was about it.)
20:16:34 <Associat0r> cjs did you look at F#?
20:17:00 <cjs> Nope. Windows kills me: too hard to automate, too hard to fix when it breaks, and it costs money.
20:17:02 <dons> cjs: i added your details to http://haskell.org/haskellwiki/Haskell_in_industry#Haskell_in_Industry  , feel free to clarify/ elaborate
20:17:10 <cjs> dons: thanks!
20:17:13 <Associat0r> it works on mono too
20:18:00 <jre2> Associat0r: F# seems to have stolen ocaml's approach to syntax- ugly
20:18:21 <Associat0r> looks ok with the #light directive
20:18:43 <cjs> I'm not sure how bad O'Caml's syntax really is. I didn't like it much from the beginning, but that awful, awful book put me off everything O'Caml so badly that it's now hard to distinguish what its real problems are.
20:18:52 <uebayasi> there are windows automation tools.  ridiculously expensive tho :)
20:19:25 <cjs> And easier to use than shell scripts?
20:19:31 <Associat0r> autoit?
20:19:34 <Associat0r> is free
20:19:41 <cjs> Especially for someone who's been writing shell scripts for 25 years? :-)
20:19:42 <Associat0r> then there is powershell
20:19:44 <Associat0r> also free
20:20:50 <cjs> I'm not going to get into a discussion about Windows. Anybody who's run an ISP knows what I mean.
20:21:08 <Associat0r> well you don't need to run it on windows
20:21:19 <Associat0r> there is mono remember
20:22:02 <dolio> How well does it work on mono?
20:22:10 <dons> Associat0r: remember you're already in #haskell, which is built around an entirely free language, compiler, library and toolchain set, and developed by the open source community :)
20:22:18 <cjs> Well, even if the compiler is better than O'Caml's, which I doubt, I still have to deal with .NET overhead and suckage. I find it difficult to believe that I'm actually going to produce faster programs with it than with ghc, or even as fast.
20:23:00 <glguy> "Any sufficiently complicated Lisp or Ruby program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Haskell."
20:23:28 <cjs> Yeah, there's also that. I'm working in the financial industry, remember, where "the vendor didn't provide good support/a bug fix/whatever" is not an acceptable excuse for system problems.
20:23:56 <cjs> Basically, if the compiler's broken, I'm expected to fix it myself if I can't find someone else to do so. :-)
20:24:16 <dons> being locked onto windows is something i think some institutions regret now, i've heard.
20:24:36 <Associat0r> dons : I understand but I mainly mentioned it because he mentioned scala and ocaml and jvm
20:24:42 <dons> sure :)
20:24:44 <dolio> Who said that? I've heard before: "Any sufficiently complicated Lisp program contains an ML program in the comments."
20:25:04 <dons> sounds like a glguy-ism
20:25:31 <glguy> dons: It is from the *blogosphere*
20:25:33 <mjrosenb> if i'm in a monad (let's say state), and i want to do samething that basically uses the list-monad notation to update the state?
20:25:55 <dolio> You mean a list comprehension?
20:26:03 <dons> glguy: that's a core competency in the programmer expertise matrix.
20:26:18 <glguy> dons: blogosphere quotation?
20:26:22 <mjrosenb> dolio: well that's syntatic sugar for the list monad, so yes
20:26:40 <dons> ah, it was reg?
20:26:42 <dolio> mjrosenb: That only works with lists unfortunately.
20:27:05 <dons> oh, raganwald is quoting someone else, http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html
20:27:06 <glguy> dons: reganwald
20:27:08 <dolio> There was an old language Gofer (I think that's the one) that had monad comprehensions.
20:27:13 <mjrosenb> dolio: yes.  i want to construct a list along with modifying the state
20:27:13 <glguy> raganwald
20:27:51 <glguy> dons: It isn't clear if he is quoting someone or not
20:28:02 <dons> ah it was originally revence, http://freeshells.ch/~revence/no-c.txt
20:28:13 <dons> "They can list the features of their recent efforts, and
20:28:13 <dons> never realise they just wrote an ad hoc, informally-specified, bug-ridden, slow
20:28:13 <dons> implementation of half of Haskell, garbage collector, #define-dependent
20:28:13 <dons> portability and all."
20:28:43 <dons> glguy: re. competence, http://www.indiangeek.net/wp-content/uploads/Programmer competency matrix.htm
20:29:00 <dons> "Maintains a blog in which personal insights and thoughts on programming are shared" is in the Level 3 competency :)
20:29:05 <glguy> lol
20:29:16 <dons> it's that easy!!
20:29:47 <dons> if you understand laziness, currying and continuations you get   to level 2 language knowledge
20:30:26 <dons> "Codes to detect possible exception before, maintain consistent exception handling strategy in all layers of code, come up with guidelines on exception handling for entire system." is also level 3
20:30:39 <dons> hmm, normal haskell practice is a lot of level 3 competency. interesting.
20:30:54 <dons> haha, "File has license header, summary, well commented, consistent white space usage. The file should look beautiful"
20:30:57 <dons> also level 3.
20:31:08 <Associat0r> why do I get 404?
20:31:10 <jre2> B-trees and tries are considered advanced?
20:31:22 <dons> http://www.indiangeek.net/wp-content/uploads/Programmer%20competency%20matrix.htm
20:31:35 <cjb> Associat0r: it's a long url with spaces in.  you probably hit a linebreak.
20:31:41 <dons> jre2: for the average joe, yes.
20:32:08 <dons> bloomfilers, fingertrees, generalised tries, zippers == level 4.
20:32:32 <Associat0r> thanks
20:32:41 <dons> "has tried out darcs/git' == level 3.
20:33:00 <Korollary> how awesomely arbitrary
20:33:14 <jre2> does running 'mkcabal' count for build automation?
20:33:45 <dons> "member of #haskell", free level 3 sticker and parking validated.
20:35:00 <cjs> Holy heck, I hit level 3 on one of those "computer science" ones. (systems programming).
20:36:32 <cjs> Actually, maybe the matrix needs another level. Like "1 (Level 4)".
20:37:52 <geezusfreeek> i don't know, i could look up to somebody who has the entire level 3 column
20:38:02 <dons> its curious there's no FILE * -> Handle function in the unix package.
20:38:06 <geezusfreeek> i have a fair bit of it, but definitely not all
20:38:36 <cjs> Yeah, I've got more of it than I think I should have.
20:38:43 <geezusfreeek> same
20:38:57 <dons> column 3 has "10+ years of professional experience" as one requirement
20:38:59 <cjs> Or maybe I'm just intimidated by learning Haskell and feeling stupid (and having to think hard!) for the first time in years.
20:39:14 <geezusfreeek> dons: that would definitely be one of the ones i don't have
20:39:14 <dons> cjs, but think of all the level 3 points you get now :)
20:40:01 <dons> "Code assumptions are verified using asserts" level 3.
20:40:09 <dons> if you use the type system == level 4.
20:40:11 <cjs> True. But though fun and challanging, they don't really seem like anything on the level of category theory, to me.
20:40:54 <geezusfreeek> i think category theory is one of those things that you shouldn't _have_ to know to be considered a very advanced programmer
20:41:03 <geezusfreeek> but knowing it is certainly an indicator
20:41:32 <cjs> Still, building a distributed system to serve video to fifteen million users per day is kinda neat. (Another project of ours.)
20:41:48 <dons> in haskell? (i wish :)
20:41:50 <jre2> the Design Patterns book should be a mark against you..
20:41:53 <geezusfreeek> sounds like practical experience to me
20:42:02 <cjb> cjs: I'd go as far as saying that category theory is mathematics, and not programming.
20:42:11 <cjb> Very few programmers need such an understanding of mathematics.
20:42:11 <geezusfreeek> damn, mark against me then
20:42:30 <ddarius> dolio: Haskell had monad comprehensions earlier.
20:42:32 <jre2> cjb: I'd say you have a false diachotomy
20:42:38 <vixey> keep that horrible maths stuff well away from my programs!
20:42:39 <cjs> Really? I thought you weren't a *real* programmer until you understood all that.
20:42:48 <dolio> ddarius: Oh? Which versions?
20:42:55 * dons moves some more asserts into the type system
20:44:45 <ddarius> dolio: Haskell 1.4 did.  I'm pretty sure one or two more earlier versions did.
20:45:02 <dolio> Huh, I didn't realize they were only taken out for 98.
20:45:10 <dons> yeah. quite recent.
20:45:12 <dolio> That's going on my list.
20:45:26 <dons> spj has stated that -fmonad-comprehensions will be accepted
20:45:29 <dons> if you send in the patch
20:45:43 <Associat0r> I think programming should become math
20:46:09 <geezusfreeek> isn't that was computer science is supposed to sort of be?
20:46:15 <ddarius> dolio: list?
20:46:49 <dolio> ddarius: Of ways 1.4 was nicer than 98.
20:47:07 <ddarius> Programming is not math?
20:47:31 <ddarius> dolio: Just read the 1.4 Report.
20:47:41 <dons> we should wear "Haskell 1.4 rules!" to the HW this year
20:48:05 <dons> wave "Bring back 1.4" placards
20:50:40 <ddarius> Cripes.  Shadowing id bit me in the butt (very mildly)
20:51:04 <dons> ah
20:51:44 <cjs> Darn, this options stuff is really a PITA.
20:52:39 <cjs> The way you have strikes, and then each strike has a call or put, then each of those has a bid or offer, each of which has a calculated volatitlity, then you go backwards through the whole thing to generate orders, argh! The data flow is killing me!
20:53:28 <dolio> Apparently the report still calls them list comprehensions.
20:53:44 <povman> so you can't be a level 3 programmer and use haskell :(
20:54:18 * ddarius is going to have to write an occurs-chekc
20:54:45 <SamB> povman: level 3?
20:54:56 <povman> SamB:
20:54:59 <povman> ugh
20:55:01 <povman> SamB: http://www.indiangeek.net/wp-content/uploads/Programmer%20competency%20matrix.htm
20:55:44 <dolio> According to some guy's arbitrary list of 'which things are better than others' in computer programming. :)
20:55:50 <dolio> But of course.
20:55:56 <povman> that list is lame
20:57:05 <nus> "Real Programmers flip switches".. "What?!? a Formula Translator?" (-;
20:57:57 <SamB> he expects one guy to do wall those things?
20:58:11 <ddarius> Bah.  This paper is just telling me what I already knew.  I was hoping it tell me something I didn't think of.
20:58:40 <wagle> real programmers juggle wirewrap tools
20:59:02 <SamB> I say he should be willing to accept one guy who can do 50% of those things as a level 3 ;-P
21:00:01 <SamB> povman: and I assume use of Haskell is almost required
21:00:18 <SamB> povman: because I'm fairly certain these things are additive
21:00:31 <dolio> Yes.
21:00:49 <povman> i picked up half the level 3 stuff in 6 months, i don't know how he requires 10+ years of experience
21:01:02 <SamB> but you ALSO have to know Erlang or Oz
21:01:16 <dolio> You must read both "For Dummies" books and SICP.
21:01:42 <SamB> well, I don't think level 0 and 1 accumulate consistantly...
21:02:32 <dibblego> consistently
21:03:01 <SamB> I don't think I spell consistantly either
21:03:10 <SamB> but just this once I'll make an acception
21:03:22 <hpaste>  dogbite pasted "haskell cafe rotate array question" at http://hpaste.org/8644
21:04:10 <dons> that's a list  :)
21:04:13 <dogbite> my rotateAmount solution in the pasted code isn't good because it's worse than linear due to haskell lists
21:04:22 <dogbite> yes, sadly
21:04:30 <dolio> Use an array.
21:04:36 <dogbite> so if i switched it to use an array i'm good to go?
21:04:52 <dogbite> i was reading this beast
21:04:53 <dogbite> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
21:04:54 <dons> maybe a Sequence would also be ok.
21:05:28 <dogbite> what's the appropriate array to use?
21:05:30 <dons> since diving into mutation heavy impure arrays probably is overkill?
21:05:47 <dons> or does this need O(1) updates (not O(log n) ?)
21:05:59 <dogbite> i think i only need O(1) access
21:06:06 <dogbite> i don't think i need updates
21:06:22 <dons> ah ok. Data.Array is fine then. you build it once, then just read in O(1)
21:06:50 <dogbite> okay i'll read about Data.Array
21:06:53 <dons> if O(log n) updates and indexing works, Data.Sequence would also be fine.
21:07:09 <dons> basically, for arrays, change !! to !, and go from O(n) to O(1) indexing
21:07:10 <dogbite> oh, O(log n) indexing is fine i think
21:07:21 <dons> you can introduce or eliminate arrays via lists too
21:07:40 <dolio> You'll need to do (! lowestIndex) instead of head, too.
21:07:44 <dolio> But other than that...
21:07:56 <dons> > listArray (0,9) [1..10]
21:08:11 <dons> oh, we don't have bots anymore in this channel?
21:08:22 <dolio> preflex: seen lambdabot
21:08:22 <preflex>  lambdabot was last seen on #haskell 1 hour, 19 minutes and 27 seconds ago, saying: Consider it noted.
21:08:27 <dons> what's up with that?
21:08:37 * dons rememvers the good old days
21:08:39 <lambdac> hello
21:08:52 <lambdac> > listArray (0,9) [1..10]
21:09:04 <glguy> lambdabot is probably restoring its state from last month
21:09:12 <glguy> and when it comes back online I'll get a message
21:09:28 <dolio> lambdabot is still running on code.haskell.org
21:09:35 <SamB> lambdac: YOU aren't supposed to do that
21:09:42 <SamB> > listArray (0,9) [1..10]
21:09:44 <lambdac>  array (0,9) [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
21:09:49 <SamB> *I* am
21:09:57 <SamB> get it right
21:10:02 <lambdac> I know that thanks :)
21:10:33 <SamB> @localtime #haskell
21:13:10 <jre2> dons: is your website hand written html, or is it generated at all?
21:16:11 <dons> which website?
21:16:29 <jre2> http://www.cse.unsw.edu.au/~dons/
21:16:30 <lambdac> Title: Don Stewart
21:16:50 <dons> hand written many moons ago, with a small number of support scripts. blog subdirectory is generated.
21:22:08 <dogbite> is it possible to pattern match like (y1:y2:[]) on the Data.Array?
21:22:10 <dogbite> i'm guessing no?
21:22:49 <glguy> you could convert the array to a list first
21:22:53 <glguy> :t Data.Array.elems
21:22:54 <vixey> dogbite: no but you can pattern match on the elems
21:22:56 <lambdac> forall i e. (Ix i) => Array i e -> [e]
21:23:38 <dogbite> thanks but i think that will make the running time linear, right?
21:23:48 <vixey> um...
21:23:54 <vixey> when n = 2, O(n) isn't that bad
21:24:21 <dogbite> oh so it's lazy?
21:24:33 <dogbite> like it will notice that it can't match onc eit generates a list of size 3?
21:24:39 <vixey> Haskell is lazy
21:24:44 <vixey> I think
21:24:56 <vixey> why don't you match on the bounds first?
21:25:07 <dogbite> k
21:25:23 <vixey> @src elems
21:25:24 <lambdac> elems arr@(Array l u _) = [unsafeAt arr i | i <- [0 .. rangeSize (l,u) - 1]]
21:31:30 <dons> Array's are lazy, UArray's aren't (same interface, different modules)
21:31:45 <dons> so the elements will only be computed on demand in an Array
21:31:54 <dogbite> okay
21:32:03 <dogbite> i'm not going to use elems
21:32:11 <dogbite> the function sure isn't as fun when you use arrays
21:32:18 <dogbite> it wasn't even that fun with lists
21:32:29 <dogbite> :-)
21:48:01 <hpaste>  dogdrool annotated "haskell cafe rotate array question" with "Updated rotateAmount to use Data.Array" at http://hpaste.org/8644#a1
21:48:01 <fons> hi
21:48:17 <dogbite> okay, now it seems decent
21:48:19 <fons> I'm trying to get a monad equivalent of or
21:48:26 <fons> sorry, of any
21:48:34 <dogbite> allowing for the linear array construction which seems fine
21:48:43 <fons> but unfortunately what I got so far doesn't short circuit
21:49:00 <fons> > any (\_ -> True) [1,undefined]
21:49:02 <lambdac>  True
21:49:56 <fons> > let anyM p =  liftM or. mapM p in anyM (\_ -> return True) [1, undefined]
21:49:58 <lambdac>   add an instance declaration for (Show (m Bool))
21:50:39 <fons> uhm ... I got an undefined error in my command line
21:50:43 <ddarius> anyM p [] = return True; anyM p (m:ms) = do b <- liftM p m; if b then return True else anyM p ms
21:50:59 <ddarius> fons: That can easily be expressed with a foldr.
21:52:06 <fons> ddarius: foldM you mean?
21:52:25 <dogbite> thanks all for discussing my little rotateAmount function.  tomorrow night i'll do the next question although that one looks simple.
21:52:45 <Apocalisp> If I find myself having to use (((return . return) .) .), am I doing it wrong? :)
21:53:04 <dolio> Removing too many points.
21:53:31 <Apocalisp> @unpl (((return . return) .) .)
21:53:32 <lambdac> (\ b h k -> return (return (b h k)))
21:56:14 <Apocalisp> what's a generalization of (return .) , (((return . return .) .), ((((return . return . return) .) .) .), etc.?
21:58:18 <Apocalisp> ?type (return .)
21:58:20 <lambdac> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
21:58:38 <Apocalisp> ?type (((return . return) .) .)
21:58:40 <lambdac> forall (m :: * -> *) b (m1 :: * -> *) a a1. (Monad m1, Monad m) => (a1 -> a -> b) -> a1 -> a -> m (m1 b)
21:58:48 <Apocalisp> ?type ((((return . return . return) .) .) .)
21:58:50 <lambdac> forall (m :: * -> *) (m1 :: * -> *) b (m2 :: * -> *) a a1 a2. (Monad m2, Monad m1, Monad m) => (a2 -> a1 -> a -> b) -> a2 -> a1 -> a -> m (m1 (m2 b))
22:06:05 <ddarius> fons: No, I mean foldr.
22:07:11 <ddarius> :t foldM
22:07:13 <lambdac> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:08:07 <ddarius> @src foldM
22:08:08 <lambdac> foldM _ a []     = return a
22:08:08 <lambdac> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
22:09:12 <ddarius> :t foldr (\m ms -> do b <- liftM p m; if b then return True else ms) (return True)
22:09:14 <lambdac>     Couldn't match expected type `a1 -> t' against inferred type `Expr'
22:09:14 <lambdac>     In the first argument of `liftM', namely `p'
22:09:14 <lambdac>     In a 'do' expression: b <- liftM p m
22:09:25 <ddarius> :t \p -> foldr (\m ms -> do b <- liftM p m; if b then return True else ms) (return True)
22:09:27 <lambdac> forall (t :: * -> *) a1. (Monad t) => (a1 -> Bool) -> [t a1] -> t Bool
22:09:28 <fons> > let {a <||> b = do {p <- a; if p then return True else b}; orM = foldr (<||>) (return False); anyM p = orM . mapM p; anyM (\_ -> return True) [1,undefined]}
22:09:29 <lambdac>  Parse error at "}" (column 156)
22:10:00 <fons> > let {a <||> b = do {p <- a; if p then return True else b}; orM = foldr (<||>) (return False); anyM p = orM . mapM p} in  anyM (\_ -> return True) [1,undefined]
22:10:02 <lambdac>  [True,True]
22:10:49 <ddarius> :t \p -> foldr (\m ms -> do b <- p m; if b then return True else ms) (return True)
22:10:51 <lambdac> forall a (t :: * -> *). (Monad t) => (a -> t Bool) -> [a] -> t Bool
22:13:07 <fons> > let {a <||> b = do {p <- a; if p then return True else b}; orM = foldr (<||>) (return False); anyM p = orM . map p} in  anyM (\_ -> return True) [1,undefined]
22:13:08 <lambdac>   add an instance declaration for (Show (t Bool))
22:14:07 <fons> ok, whatever, I don't know why lambdac doesn't like monads as output but it works in the command line
22:14:26 <fons> that definition seems to short circuit results
22:14:46 <hpaste>  morrow annotated "QR algorithm" with "after being run through hstidy :)" at http://hpaste.org/8637#a1
22:19:08 * ddarius reads some old skool Conal
22:19:16 <ddarius> Or rather downloads it to read later.
22:24:15 <mmorrow> ddarius: that computational cat theory book is great! i can't believe i haven't come across it until now.
22:27:50 <mmorrow> (in case anyone is wondering:   http://www.cs.man.ac.uk/~david/categories/    )
22:27:52 <lambdac> Title: Categories
22:28:35 <ddarius> mmorrow: Well the book is only 20 years old.
22:30:25 <mmorrow> ddarius: that says something to me about category theory and functional programming
22:31:11 <mmorrow> ddarius: imagine reading C from 1988 implementing whatever the cutting edge <insert-random-something-pdes> algorithm
22:31:40 <mmorrow> (was at the time)
22:41:43 <mattr__> does anyone have a module/function that prints data as trees (probably using Data.Generics)?
22:53:30 <mmorrow> mattr__: what type of data in particular, and what would a be in Tree a?
22:53:43 <mattr__> arbitrary data type
22:54:04 <mattr__> but output as a tree
22:54:26 <mattr__> whereas deriving show outuputs as tuples (kinda)
22:54:54 <mmorrow> ah, so essentially you want to show it, then parse the shown string as an expression, *then* print that (the AST of the parsed output of show) ?
22:55:16 <mattr__> I should be able to see list as
22:55:17 <mattr__> ---- Cons ---- Nil
22:55:17 <mattr__>           |---------Nil
22:55:24 <mattr__> grrr
22:55:32 <mattr__> proportional fonts :(
22:55:39 <mmorrow> check out drawTree and drawForest in Data.Tree
22:55:41 <mattr__> ha
22:55:44 <mmorrow> nice little function
22:55:44 <mattr__> and Cons Nil NIl
22:55:45 <mmorrow> s
22:55:46 <mattr__> is crap
22:55:48 <mattr__> :)
22:55:54 <mattr__> Cons 5 Nil :)
22:57:08 <mattr__> nice, so I just need to get my data into a rose tree
22:58:56 <mattr__> hey - does anyone know a function that will convert an data from an arbitrary type into a Rose tree? :)
22:59:13 <roconnor> unsafeCoerce
22:59:38 <ski> const undefined
23:00:08 <roconnor> fix id
23:00:26 <ski> const (fix id)
23:00:36 <roconnor> undefined
23:01:58 <ski> you win
23:02:18 <roconnor> it is a hollow victory
23:03:16 <ski> hm .. maybe "an arbitrary type" could be construed to mean `forall a. a' ?
23:03:44 <quicksilver> obk: that's not really an edge case, and the type checker certainl doesn't enumerate stuff in the way you suggest it does
23:04:06 <hpaste>  morrow pasted "list to tree and pprint" at http://hpaste.org/8645
23:04:22 <obk> quicksilver: Well... it is weird...
23:04:31 <mmorrow> mattr__: does that paste do anything you're thinking of?
23:04:49 <obk> And it does enumerate cases well enough to detect when cases overlap
23:05:01 <mmorrow> mattr__: ipprint is on hackage
23:05:19 <obk> I guess this is tied up with the record types in genera, which I understand nobody is very happy with anyway
23:05:37 <solrize> general
23:05:46 <quicksilver> obk: it's got nothing to do with record types.
23:05:54 <solrize> for a minute i thought you meant genera the common lisp environment :P
23:05:59 <quicksilver> obk: record types are only a funny syntax for ordinary product types.
23:06:12 <mjrosenb> how do i make lambdabot give me the point free version of a snippet of code
23:06:16 <obk> I suppose so. Well then, that makes it stranger
23:06:23 <mjrosenb> and is there some cli program that will do that?
23:06:36 <solrize> @pl f x y z
23:06:38 <lambdac> f x y z
23:06:44 <obk> I find it funny that saying "record { field = field record }" is not a no-op, type-wise
23:06:54 <solrize> @pl \x -> (f x) * (g x)
23:06:55 <lambdac> liftM2 (*) f g
23:06:56 <mattr__> brb
23:07:00 <mjrosenb> @pl (\x -> f x && g x)
23:07:01 <lambdac> liftM2 (&&) f g
23:07:14 <mjrosenb> :t liftM2
23:07:16 <lambdac> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:07:19 <quicksilver> obk: why don't you just say mapB foobar@Bar{} = foobar ?
23:07:28 <_zenon_> ?ty (\x -> f x && g x)
23:07:30 <lambdac> forall t. (FromExpr (t -> Bool)) => t -> Bool
23:07:32 <obk> Because GHC won;t compile it
23:07:59 <solrize> let m=(383^383::Integer) in (fromIntegral m :: Int)
23:08:06 <solrize> > let m=(383^383::Integer) in (fromIntegral m :: Int)
23:08:08 <lambdac>  -1313866113
23:08:09 <solrize> booh
23:09:42 <quicksilver> obk: OK, sorry, I understand the issue now :)
23:09:56 <obk> It is strange, right?
23:10:01 <quicksilver> obk: but you're quite wrong to picture it enumerating fields and looking for bs...
23:10:22 * obk has no idea how it works internally
23:10:42 <obk> Maybe you could clarify?
23:11:01 <quicksilver> I had no idea that record update to lead to polymorphic functions.
23:11:06 <quicksilver> that's very intruiging.
23:11:17 <quicksilver> 'could lead to'
23:11:32 <obk> Yes, I was suprised myself...
23:12:20 <solrize> does anyone know how the ghc c backend works?  does it go from c-- to c, or directly from core to c?
23:12:26 <ski> (ddarius : McBride or Elliott ?)
23:13:20 <quicksilver> it must be to do with the way it desugars record update, obk.
23:13:33 <mmorrow> solrize: in ghc c-- and c are mutually exclusive
23:13:58 <obk> quicksilver: Right. Which seems to be different for "polymorphic" fields. Strange.
23:14:10 <solrize> mmorrow thanks
23:14:20 <mmorrow> solrize: :)
23:18:16 <cjs> I must be starting to get at least slightly better at Haskell, since stuff seems to compile for me a lot more often now.
23:19:18 <solrize> my stuff rarely compiles on the first try but i'm getting better at dealing with the error messages
23:19:58 <solrize> there's still a lot of times when there's something i want to do that should be straightforward but i flat out can't figure out how
23:20:20 <_zenon_> it's cowardice to compile withour errors :)
23:22:29 <lumi> In GHC, do 'let's change stack behaviour?
23:23:09 <mmorrow> i think they allocate a thunk in the heap
23:23:18 <mmorrow> beyond that i don't know
23:23:50 <mmorrow> but i can't see how they would touch anything with the stack ?
23:24:24 <lumi> mmorrow: I have this function that overflows the stack when written legibly, but when it's written point free it doesn't seem to
23:24:35 <mmorrow> lumi: ah
23:24:49 <lumi> mmorrow: I thought they'd compile down to the same thing, but obviously I don't know nuffin' about nuffin' :P
23:24:52 <quicksilver> obk: well not really; it just demonstrates that record update desugars to reconstruction.
23:25:00 <mmorrow> probably need to `seq` your accumulator because the let-created thunks are blowing your stack
23:25:05 <quicksilver> obk: and reconstruction is, of course, polymorphic.
23:25:16 <mmorrow> @src foldl
23:25:17 <lambdac> foldl f z []     = z
23:25:17 <lambdac> foldl f z (x:xs) = foldl f (f z x) xs
23:25:18 <mmorrow> @src foldl'
23:25:19 <lambdac> foldl' f a []     = a
23:25:19 <lambdac> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:25:22 <obk> quicksilver: But why doesn't it desugar to reconstruction for "polymorphic" fields?
23:25:33 <quicksilver> obk: it does. that's why it works.
23:25:48 <obk> quicksilver: Not if you use the "bazI" field it doesn;t!
23:25:56 <quicksilver> obk: that's why your example which spuriously "re-sets" barI type checks
23:26:17 <obk> So why doesn't using "bazI" work then?
23:26:34 <quicksilver> obk: because with bazI you hit another kind of update
23:26:41 <quicksilver> you hit the multiple-constructor update path.
23:27:13 <obk> I guess so... I just found the whole combined behavior puzzling
23:27:14 <quicksilver> obk: foobar { bazI = 3 } can deal with Foo *and* Bar tags.
23:27:34 <quicksilver> you might imagine that the compier can see that, in fact, you have a Bar tag here.
23:27:39 <quicksilver> but that's not how typechecking works.
23:27:49 <obk> quicksilver: yes, but when inside foo foobar@Bar{} it should ""know" it is a Bar... right?
23:27:52 <quicksilver> typechecking always runs in isolation, not taking context into accunt
23:28:00 <quicksilver> that's a bit of a vague thing I've just said
23:28:04 <quicksilver> but that's the general idea :)
23:28:19 * obk though typechecking was all about context :-)
23:28:36 <quicksilver> \foobar -> foobar { barI = 1 } :: FooBar a t -> FooBar a b
23:28:40 <quicksilver> that's the type of the bar update
23:28:53 <quicksilver> \foobar -> foobar { bazI = 1 } :: FooBar a b -> FooBar a b
23:29:01 <quicksilver> and that's the type of the baz one
23:29:14 <obk> Seems the same... yet one works and the other does not
23:29:20 <quicksilver> they're not the same types :)
23:29:34 <quicksilver> that first type is polymorphic forall a b t
23:29:37 <quicksilver> the second only forall a b
23:29:42 <quicksilver> the first is more polymorphic
23:29:44 <obk> Ah
23:29:53 * obk hmmms
23:30:13 <quicksilver> however, I think your other point about reconstruction is interesting.
23:30:14 <lumi> mmorrow: Oh, hm. But the expression was strict on the let, because it was 'let l = blah in l `max` n'... I still don't understand why it behaves differently
23:30:17 <quicksilver> that actually reduces sharing.
23:30:38 <wuxia> waht does:
23:30:42 <wuxia> ghc shape.hs
23:30:42 <wuxia> /usr/lib/ghc-6.8.2/libHSrts.a(Main.o): In function `real_main':
23:30:43 <quicksilver> the "spurious reconstruction" in foobar { barI = barI foobar }
23:30:44 <mmorrow> lumi: hmm, could you paste the code i'm interested to see
23:30:44 <wuxia> (.text+0x12): undefined reference to `__stginit_ZCMain'
23:30:47 <wuxia> /usr/lib/ghc-6.8.2/libHSrts.a(Main.o): In function `real_main':
23:30:49 <wuxia> (.text+0x26): undefined reference to `ZCMain_main_closure'
23:30:51 <obk> quicksilver: It also has some interesting interactions with lazyness, come to think of it (I was bitten by that when writing a streaming parser)
23:30:52 <wuxia> mean ?
23:31:02 <quicksilver> creates a new heap cell
23:31:07 <quicksilver> when in fact, you could reuse the old one
23:31:14 <quicksilver> (since heap cells are polymorphic in principle)
23:31:41 <obk> Hey, lets not diss it, it means a work around the type checking problem... if it was "smart" enough they way you describe, I'd be SOL
23:32:39 <obk> Of course in principle you are right, it is redundant
23:32:52 <quicksilver> no, it would still type check
23:32:55 <quicksilver> just not waste space
23:33:01 <obk> That would be nice
23:33:04 <quicksilver> it could reuse the old heap cell at a different type
23:33:12 <quicksilver> GHC already does this in other cases
23:33:28 <quicksilver> e.g.: a :: [Int]; a = []; b :: [Char]; b = []
23:33:42 <quicksilver> even though a and b are different types they can be represented by the same heap cell
23:33:49 <quicksilver> (and they will be)
23:33:55 <quicksilver> in a compiled program there is at most one []
23:34:09 <quicksilver> this is semantically transparent.
23:34:13 <obk> Yes, but I imagine [] is a very special case...
23:34:26 <mmorrow> luni: heh, just saw that you already did
23:34:30 <obk> I is after all the designated "null" type in LISP :-)
23:34:55 <dolio> There's also at most one Nothing.
23:35:08 <obk> And () for that matter
23:35:33 <dolio> () has a single concrete type, though, so that's less surprising.
23:35:52 <obk> Right, my point was that Haskell has multiple "no value" values...
23:35:53 <_zenon_> ?ty ()
23:35:56 <lambdac> ()
23:36:00 <quicksilver> obk: no it's not a special case.
23:36:05 <quicksilver> obk: "Nothing" is the same
23:36:11 <obk> () isn't; [] is
23:36:22 <quicksilver> there is one "nothing" per type but GHC can allocate just one on the heap
23:36:28 <quicksilver> similarly although more obscurely
23:36:32 <_zenon_> _|_
23:36:36 <quicksilver> "Left 1" :: Either Int a
23:36:42 <quicksilver> can be shared between differet 'a' types
23:36:43 <quicksilver> and so on.
23:37:01 <obk> Right
23:37:07 <quicksilver> obk: anyhow, some aspects of what we are discussing are described at http://hackage.haskell.org/trac/haskell-prime/wiki/ExistingRecords
23:37:10 <lambdac> Title: ExistingRecords - Haskell Prime - Trac, http://tinyurl.com/5sksvc
23:37:14 <hpaste>  lumi pasted "Stack overflow crazy?" at http://hpaste.org/8646
23:37:30 <quicksilver> obk: about half way down "Polymorphic record update take II"
23:37:35 <lumi> mmorrow: VoilÃ¡
23:37:52 * obk is looking
23:38:48 * mmorrow looks
23:39:22 <mattr__> mmorrow+
23:39:39 <mattr__> mmorrow: thanyou - that is exactly what I want
23:39:41 <obk> Hmmm... -XREcordWildCards...
23:39:50 <lumi> mmorrow: New datapoint: switching arguments for max (max l m instead of max m l) seems to make it go away as well.. I guess it's not the let
23:42:23 <dolio> A guess: the order of the arguments to max affects the order in which the expressions in 'iterate f x' get reduced.
23:43:01 <dolio> One order causes xi to be reduced before x(i+1).
23:43:20 <dolio> The other goes straight to x(max), which causes a stack overflow.
23:43:56 <dolio> That's just a guess, though.
23:45:14 <lumi> dolio: That makes sense, although it's hard for me to anticipate
23:45:39 <dolio> Yeah.
23:45:57 <mmorrow> mattr__: awesome
23:46:31 <mmorrow> lumi: i just realized that the inferred types for lp and lp' (w/out tysigs) are
23:46:34 <mmorrow> lp :: [Integer] -> Int
23:46:39 <mmorrow> lp' :: [Int] -> Int
23:47:30 <mmorrow> lumi: that's not it
23:47:33 <TSC> Shouldn't they both be Int, because of "length" ?
23:48:26 <lumi> mmorrow: That's.. freaky
23:48:36 <mmorrow> my ghci spit that out
23:49:14 <mmorrow> oh...i was wrong
23:49:21 <mmorrow> ;)
23:49:38 <mmorrow> lumi: what is the point of the let l = length(pth n) in m `max` l in lp ?
23:50:12 <mmorrow> oops
23:50:21 <dolio> They're both [Integer] -> Int
23:50:29 <mmorrow> yeah..
23:50:44 <lumi> mmorrow: It's left over from when this function built maps to memoize the path lengths
23:50:58 <mmorrow> ooh, exciting
23:51:03 <lumi> Which was what I was actually trying to do and still haven't managed to accomplish
23:51:13 <lumi> What with all the stack overflows and all :P
23:51:20 <mmorrow> hate those
23:51:43 <mmorrow> i think i have a little paths/reachable function somewhere..
23:52:13 <lumi> This is problem 14 from Project Euler
23:52:42 <lumi> Annoyingly, it was easy to solve in Perl, in just seconds, but I can't get an answer from Haskell
23:53:04 <lament> damn that stupid perl, it's always easy to write stuff in it!
23:53:28 <lumi> lament: Yes, that's exactly what I meant
23:54:39 <hpaste>  morrow pasted "reachable" at http://hpaste.org/8647
23:55:20 <mmorrow> it's just like in Data.Graph, but with lists instead of arrays
23:55:56 <vixey> how come f . g = id is not enough to prove g . f = id?
23:56:41 <dolio> Let's see...
23:56:54 <vixey> I have found a boring example
23:57:11 <dolio> f _ = () ; g () = 5
23:57:31 <vixey> hmm
23:57:32 <vixey> yes
23:57:59 <vixey> does this say something about the cardinalities of the sets
23:58:32 <vixey> or would having some information about the cardinality let you prove g . f = id?
