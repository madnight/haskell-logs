00:00:26 <roconnor> Saizan_: that's only due to another problem with Haskell.  Map should take the Ord instance, not each function.
00:00:56 <sjanssen> roconnor: will we still be able to write Data.Map.union?
00:01:05 <roconnor> this is the same problem that keeps Map and Set from being a monad (I think)
00:01:46 <roconnor> sure, beucase Map (Ord1 a) and Map (Ord2 a) would be different types, and you couldn't union them.
00:02:01 <sjanssen> what are Ord1 and Ord2?
00:02:17 <mm_freak> is IO preferable over ST, if i don't need state threads and i'm not going to call a function from pure code?
00:02:19 <roconnor> two different instances of Ord for a
00:02:35 <mm_freak> the function itself is a pure function
00:02:40 <roconnor> mm_freak: no
00:02:49 <roconnor> ST is always preferable to IO
00:02:59 <u_quark> so, if i understand correctly i can;t change the way lists are "shown" ?
00:03:06 <roconnor> well,  unless you care concerned about portability
00:03:22 <mm_freak> roconnor: can IO be preferable for performance?  or is ST usually faster?
00:03:40 <roconnor> mm_freak: I'm pretty sure the produce the same code
00:03:42 <sjanssen> mm_freak: IO is ST RealWorld under the hood -- there should be no difference
00:03:42 <mm_freak> my intuition says they're equivalently fast
00:03:49 <sjanssen> @src IO
00:03:50 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
00:03:53 <sjanssen> @src ST
00:03:53 <lambdabot> newtype ST s a = ST (STRep s a)
00:03:58 <sjanssen> @src STRep
00:03:58 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
00:03:59 <roconnor> @src STRep
00:03:59 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
00:04:03 <mm_freak> ah ok, thanks
00:05:14 <sjanssen> roconnor: you know, we can already do these tricks in Haskell
00:05:39 <roconnor> what tricks?
00:05:40 <smg> hello.
00:05:53 <sjanssen> class Ord' d k | d -> k where compare :: d -> k -> k -> Ordering
00:05:57 <smg> data Foo = Foo { Arg1 :: String } fails
00:05:58 <smg> why?
00:05:59 <sjanssen> roconnor: name dictionaries with types
00:06:13 <sjanssen> smg: fields must be lower cased
00:06:18 <smg> ahh
00:07:27 <smg> sjanssen:
00:07:38 <smg> data Foo = Foo { arg1 :: String, arg2 :: String } fails too??
00:08:14 <quicksilver> looks fine to me, smg. Problem is elsewhere?
00:08:29 <sjanssen> data FlipCmp a; instance Ord a => Ord' (FlipCmp a) a where compare = const (flip compare)
00:08:41 <smg> quicksilver: k
00:09:07 <u_quark> anyway: tnx all
00:09:08 <sjanssen> roconnor: then we have data Map' (d :: * -> *) k a = ...
00:09:25 <quicksilver> sjanssen: yes, it's a nice trick.
00:09:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8252
00:09:46 <smg> quicksilver: can you look at paste?
00:09:57 <Saizan_> sjanssen: d :: * in Ord'
00:10:02 <quicksilver> smg: mussing comma after String
00:10:14 <sjanssen> Saizan_: ah, right
00:11:55 <smg> thanks
00:12:00 <smg> quicksilver: how can i access now the elements?
00:12:07 <smg> if i create a new Match?
00:12:13 <mm_freak> arg1 var
00:12:22 <smg> mm_freak: ?
00:13:22 <smg> k
00:13:23 <sjanssen> smg: field accessors are normal functions, literally write 'arg1 var' where Var is your record and arg1 is your field
00:13:27 <smg> thanks
00:13:39 <mm_freak> "data Foo = Foo { arg1 :: String, arg2 :: String }" is the same as "data Foo = Foo String String", but makes available record syntax for changing elements (var { arg2 = "xyz" }) and automatically provides accessor functions arg1 and arg2
00:14:20 <mm_freak> s/elements/fields/
00:16:06 <mm_freak> btw, is there some way to use this with GADTs?
00:16:22 <^Someone^> Where can I get these Haskell libs from? - unix, readline, arrows, binary, plugins, oeis, numers
00:16:27 <smg> hey
00:16:33 <smg> i cannot concat my own datatype
00:16:35 <smg> what is that?
00:16:45 <sclv> Someone: some of those should come with your ghc instlal in extralibs
00:16:48 <Gilly> btw, do ppl usually actually make data fields named like Apple {color :: String} and Banana {color :: String} and use qualified imports or do they use fields named something like colorApple?
00:16:51 <vixey> smg: What is the type of concat?
00:16:52 <EvilTerran> data Foo a where Bar { this, that :: String } :: Foo Int -- mm_freak
00:17:02 <^Someone^> These don't
00:17:03 <sclv> look at hackage for the rest.
00:17:11 <sclv> ?where hackage
00:17:11 <lambdabot> http://hackage.haskell.org/
00:17:13 <smg> vixey: [a]
00:17:13 <smg> ..
00:17:18 <^Someone^> Ty sclv
00:17:34 <vixey> smg: wrong...
00:17:44 <mm_freak> EvilTerran: great, thanks
00:17:55 <Deewiant> Gilly: I'd use something like aColour and bColour... or maybe make a class Colourful a where colour :: a -> String
00:17:59 <sclv> mm_freak: pretty sure that record syntax breaks with anything vaguely non h '98
00:18:28 <mm_freak> sclv: EvilTerran's version works fine
00:18:46 <sclv> cool.
00:18:57 <sclv> I know I've run into trouble with foralls hidden in records.
00:19:04 <mm_freak> though i'll stick with h98's data syntax for records
00:19:31 <Gilly> Deewiant: right, classes just aren't an option everytime :) and OTOH aColor and bColor are probably harder to remember (depending how consistent you are with your naming and how many data types begin with A or B :))
00:20:19 <smg> brb visq
00:20:19 <smg> vixey:
00:20:24 <smg> i have CS lecture
00:20:25 <smg> see you
00:20:29 <sclv> if the records are sufficiently complex, and the project is also, I think  qualified imports are fine.
00:20:52 <Saizan_> Gilly: altough we tend to write things like data Fruit = Apple {color :: String } | Banana {color :: String }
00:21:49 <sclv> I dislike that actually, because you can get lots of partiality if you're not careful.
00:22:03 <Gilly> Saizan_: I agree my example was a poor one... but, say, many objects have identifiers and to access that identifier it would be natural to use the 'identifier' -function.
00:22:37 <quicksilver> Gilly: feields like coloarApple, as a rule.
00:22:44 <quicksilver> Gilly: speaking only for myself
00:23:14 <quicksilver> Gilly: e.g. data TextureParms = TP { tpMapping :: .., tpEnv :: ..., tpThis :: ... }
00:23:24 <Gilly> right
00:23:36 <quicksilver> but I'm experimenting with using lenses as an alternative
00:23:43 <quicksilver> at which point direct use of field names will be deprecated
00:23:44 <Gilly> lenses?
00:24:08 <quicksilver> they're like composable field names
00:24:15 <quicksilver> no where did twanvl's blog post go?
00:24:17 <Gilly> any paper online?
00:24:20 <sjanssen> quicksilver: how do you find lenses?
00:25:03 <quicksilver> sjanssen: useful in some cases at least
00:25:06 <sjanssen> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
00:25:07 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
00:25:22 <sjanssen> quicksilver: I kicked around the idea of using them in xmonad
00:25:34 <quicksilver> Gilly: sjanssen has found the blog post I was looking for
00:26:01 <sjanssen> the boilerplate involved in defining them is rather annoying though
00:26:02 <quicksilver> sjanssen: I have a couple of uses of them I'm quite happy with, although they're a bit clunky at the moment.
00:26:33 <quicksilver> I use them for "deep editing" of a field within a nested structure
00:26:41 <fUD> Cya
00:26:45 <quicksilver> and I use them for implementing an imperative-style cached computation
00:27:03 <quicksilver> objAmbientL   = objL<.>Lens (\ms -> (objAmbient ms , \v -> ms {objAmbient = v}))
00:27:21 <quicksilver> sjanssen: it's only one line of boilerlplate and it could a be automated in principle
00:27:34 <quicksilver> (currently I just use editor search and replace and it's not too hard)
00:27:50 <quicksilver> when I'm happy with my recipe I'll see about a Data.Derive recipe
00:27:57 <quicksilver> win 26
00:28:03 <Gilly> quicksilver: yea i noticed, that looks interesting :)
00:28:30 <quicksilver> Gilly: I'm not sure many people have enough experience with using them in large programs.
00:28:39 <quicksilver> but they're definitely interesting which is why I'm experimenting with them.
00:30:31 <Saizan_> quicksilver: imperative-style cached?
00:31:52 <quicksilver> Saizan_: like in C you might write a function with a local static variable
00:31:54 <osfameron> morning
00:32:06 <quicksilver> Saizan_: and it would only perform the computation / allocate the resource first time you call it
00:32:49 <quicksilver> Saizan_: actually it's slightly cleverer : it assumes the parameters are members of 'Eq' and it recalculates/acquires resource when the parameters change.
00:32:53 <quicksilver> otherwise it returns the old version.
00:32:57 <osfameron> I've been playing with faking monads using generators (the Python example) and I have an idea that it's actually the wrong thing to do (not sure it plays well with Lists, as doesn't the coroutine just get resumed again at the wrong place? i.e. might need continuations instead)
00:33:20 <quicksilver> I use it to render textures / generate geometry on the CPU without regenerating every frame if nothing has changed
00:33:37 <Saizan_> quicksilver: do you have the code available somewhere? i'm working with something similar for gsoc
00:33:53 <quicksilver> Saizan_: sure. let me hpaste some bits.
00:34:41 <hpaste>  quicksilver pasted "withCachedResource" at http://hpaste.org/8253
00:35:14 <hpaste>  quicksilver pasted "Lens code" at http://hpaste.org/8254
00:35:30 <quicksilver> Saizan_: there you are. It's not particularly clever.
00:35:32 <quicksilver> it's useful though :)
00:38:42 <quicksilver> I'm not remotely sure I have the right set of Lens primitives. It's certainly not a complete set, it's missing the modify stuff.
00:39:13 <tchakkazulu> quicksilver: Have you had a look at http://hackage.haskell.org/packages/archive/data-accessor/0.0.1/doc/html/Data-Accessor.html ?
00:39:14 <lambdabot> http://tinyurl.com/6mztqv
00:39:21 <tchakkazulu> Seems to do most of the lens thing.
00:39:21 <Saizan_> what's MonadLens though?
00:39:23 <quicksilver> tchakkazulu: no
00:39:40 <quicksilver> Saizan_: something like a lens but hidden inside a monad
00:39:51 <quicksilver> in MonadState, get/set is an example of such
00:39:59 <quicksilver> in IO, readIORef/writeIORef is an example
00:40:17 <quicksilver> I found I often wanted to apply my lenses into monadstates
00:40:26 <quicksilver> tchakkazulu: looking at it now :)
00:41:15 <quicksilver> tchakkazulu: that's interesting, it has the monadlens idea too
00:41:15 <Saizan_> my bigger problem is how to reasonably pass resources around..
00:41:19 <quicksilver> although slightly less general.
00:41:38 <quicksilver> Saizan_: wrapped up in haskell data types? I'm not sure what you're asking.
00:43:04 <tchakkazulu> quicksilver: Yeah. Though I'm not very sure if the monadlens adds anything besides handling references.
00:43:11 <tchakkazulu> Then again, that itself is useful.
00:43:24 <quicksilver> tchakkazulu: I find monad lenses in IO quite common.
00:43:31 <aliaser> /?
00:43:31 <quicksilver> tchakkazulu: e.g. a subfield of an IORef
00:43:42 <quicksilver> tchakkazulu: working with subfields of IORefs is quite clumsy...
00:44:00 <quicksilver> also main libraries like gtk2hs and openGL have "IORef-like" things.
00:44:09 <quicksilver> StateVar, hopengl calls them
00:44:13 <quicksilver> not sure what gtk2hs calls them.
00:46:17 <tchakkazulu> quicksilver: Ah, okay. Fair enough :)
00:47:05 <quicksilver> tchakkazulu: but it's true that, more often, I use the monadstate version.
00:47:12 <quicksilver> definitely preferable.
00:47:29 <quicksilver> I prefer to plumb my IORefs into state monads if I can.
00:47:39 <quicksilver> so only the outer layer can 'see' that they are actually IORefs
00:49:27 <tchakkazulu> I tend to use Reader for State-wannabes that use IORef.
00:49:39 <quicksilver> gah
00:49:43 <quicksilver> code smell!
00:49:46 <tchakkazulu> But yeah. I find myself writing State-subfield modify functions every time as well, so I was pleasantly surprised at that library.
00:50:01 <quicksilver> State s is always nicer than Reader (IORef s)
00:54:34 <tchakkazulu> Oh, agreed.
00:54:59 <tchakkazulu> It was useful with MVars when writing a state monad that can fork and share state, though.
00:54:59 <lvhuashu2008> 有人在不？
00:55:26 <mauke> /ban
01:00:37 <quicksilver> tchakkazulu: yes, the mvar stuff is interesting.
01:00:49 <quicksilver> tchakkazulu: I'd rather hide it under the hood but it's not entirely clear how you do that.
01:00:59 <quicksilver> tchakkazulu: monadlenses can help in a sense.
01:01:04 <quicksilver> (MVars can be IOLenses)
01:02:46 <hpaste>  quicksilver pasted "lens notation makes nested object update easier" at http://hpaste.org/8255
01:02:57 <tchakkazulu> quicksilver: Indeed. Indeed.
01:03:05 <quicksilver> edven with that paste I'm not entirely happy
01:03:06 <tchakkazulu> quicksilver: In that module, they're invisible.
01:03:44 <tchakkazulu> quicksilver: It has the same interface as the standard StateT monad (with a restriction of MonadIO), just uses MVars.
01:03:52 * quicksilver nods
01:04:06 <quicksilver> but you need to think about how atomic your actions are, sometimes
01:04:34 <tchakkazulu> Yeah. That's my main problem with it.
01:04:34 <quicksilver> you need to be careful about "long-running" actions of type (s -> ms)
01:05:00 <quicksilver> and conversely, you need to be very cautious about just using get and set
01:05:06 <quicksilver> get and put, arther
01:05:19 <quicksilver> because it's all too easy to "put back an old version" and ignore another thread's changes.
01:05:33 <tchakkazulu> Yeah.
01:05:57 <quicksilver> I can't currently see and interface which makes this transparent to the client code. The client code need to have some awareness that it's in a threaded env
01:06:04 <quicksilver> maybe it's too much to hope that it would be any different.
01:06:34 <tchakkazulu> Well... that's kinda the point of my module.
01:06:55 <tchakkazulu> I had introduced a class MonadFork with fork :: m () -> m ThreadId.
01:07:12 <tchakkazulu> Though, yes, every function using it should know that there may be others.
01:07:19 * quicksilver nods.
01:07:35 <quicksilver> that's very nice.
01:07:44 <quicksilver> did you read my cafe post about "monadic tunnelling" ?
01:08:03 <tchakkazulu> Hmm, no?
01:08:45 <^Someone^> I'm trying to install the unix lib
01:08:57 * tchakkazulu browses the -cafe archive.
01:09:05 <^Someone^> And I'm getting an error - Setup: Cannot find: sh
01:09:24 <quicksilver> let me dig it up. Damn inconsistent google and dodgy 3G internet connections.
01:09:29 <quicksilver> tchakkazulu: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
01:09:30 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
01:09:37 <^Someone^> What's sh?
01:09:44 <quicksilver> it's the unnix shell.
01:09:54 <tchakkazulu> quicksilver: Ah, thanks.
01:10:01 <^Someone^> Oh, so I can't install that lib on windows :|
01:10:02 <quicksilver> I presume you need a unix environment to install the unix package.
01:10:06 <^Someone^> That does make sense
01:10:06 <quicksilver> cygwin might work.
01:10:13 <^Someone^> Oh, thanks
01:10:36 <tchakkazulu> quicksilver: Ah, yes! I remember it but forgot about it.
01:10:40 <dmwit> I was under the impression that the unix package was cross-platform.
01:10:56 <quicksilver> I could well be wrong, then, dmwit :)
01:10:59 <quicksilver> I was only guessing.
01:11:01 <tchakkazulu> (if that makes sense at all...)
01:11:19 <quicksilver> tchakkazulu: yes, it does :) It means you stole the ideas without recalling the source.
01:11:23 <quicksilver> tchakkazulu: :P
01:11:28 <mauke> System.Posix doesn't exactly sound portable
01:11:38 <quicksilver> there is nothing profound in it,
01:11:48 <quicksilver> but I remain surprised that it's not discussed / solved more often.
01:12:45 <dmwit> mauke: Anything in particular that strikes you as hard to do on a Windows system?
01:12:59 <mauke> signals
01:13:09 <mauke> fork, exec
01:13:17 <dmwit> fork, exec are doable
01:13:33 <dmwit> It is not obvious that signals are doable. =P
01:13:40 <mauke> with cygwin maybe
01:14:02 <dmwit> I know it's been said before, but isn't the doze kernel POSIX-compliant?
01:14:35 <mauke> I'd also be surprised if windows did termios
01:14:58 <^Someone^> Error when trying to install lib binary - Setup:Error: Could not find module: Data.Binary with any suffix: ["hi"]
01:15:53 <dmwit> No, it doesn't seem to.
01:16:04 <dmwit> So maybe quicksilver is right; it could require cygwin after all.
01:16:34 <Saizan_> quicksilver: somethign like that should be on hackage, not restricted to IO maybe
01:17:33 <tchakkazulu> quicksilver: Without having read further, is that the same thread as where the "MonadHoist" class was proposed.
01:17:54 <tchakkazulu> quicksilver: Where "hoist" would do what the promote functions in that first post do?
01:20:18 <quicksilver> tchakkazulu: MonadHoist doesn't ring a bell, I think I must have missed that thread.
01:20:29 <quicksilver> tchakkazulu: which is surprising, since it sounds like the kind of one I'd read :)
01:20:55 <quicksilver> Saizan_: Probably. The IO restriction is a legacy from an old version you're right.
01:21:09 <quicksilver> Saizan_: I'm still experimenting with the interface though.
01:22:18 <tchakkazulu> quicksilver: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040890.html
01:22:18 <lambdabot> Title: [Haskell-cafe] hoisting as well as lifting and returning, http://tinyurl.com/665ce9
01:24:09 <quicksilver> tchakkazulu: yes, promot is the same idea as hoist, definitely.
01:24:17 <quicksilver> tchakkazulu: promote wasn't really the point of the post though :)
01:24:31 <quicksilver> tchakkazulu: the point was embed and callback
01:25:20 <Saizan_> promote is considerably easier, you only have a monad to deal with
01:26:23 <tchakkazulu> quicksilver: Heh, yeah. And those are cool too. But I tend to get distracted in such ways ;)
01:28:08 <quicksilver> I agree whole-heartedly with yitz's reply to that post.
01:28:32 <quicksilver> I have on occasion writen functions in StateT that should really be in MonadState
01:28:50 <quicksilver> just because it's "Easier" to use runStateT $ \st ->
01:28:53 <quicksilver> than get and put.
01:29:04 <quicksilver> laziness. Every programmer's greatest asset and worst liability.
01:32:20 <^Someone^> How do I set the install path for installing a lib?
01:32:34 <^Someone^> All the libraries got installed in a different partition
01:33:02 <Lemmih> ^Someone^: cabal configure --prefix=...
01:33:44 <^Someone^> Ty
01:33:56 <solrize> is there some idiomatic way to express in a data declaration that [foo] is a list of 374 foo's?
01:34:58 <quicksilver> solrize: no, not really.
01:35:05 <dibblego> data Foo374 a = Foo374 a a a a a a a a a a a a ...
01:35:20 <solrize> dibblego :-P
01:35:24 <solrize> quicksilver thanks
01:35:42 <^Someone^> Lemmih: That's just for the first step, right? Do I have to do that for build and install as well?
01:36:48 <^Someone^> I see that I don't
01:36:51 <^Someone^> Ty :)
01:36:55 <solrize> actually it's more like data Foo374 = { n :: Integer, x :: [Foo] }   where the length of x is n
01:37:41 <solrize> i guess i just write the data constructor to take care of it
01:38:14 <quicksilver> yes, that's probably the best way.
01:38:25 <quicksilver> There will always be some invariants you can't express in the type system.
01:39:11 <Lemmih> ^Someone^: Why isn't the default location good enough, btw?
01:39:23 <solrize> i wasn't exactly looking to handle it in the type system (not possible since n isn't known at compile time), just wondering if there was a way to document something like that in the annotation
01:39:55 <vixey> solrize -- length of x is n
01:40:00 <solrize> yeah :)
01:40:08 <^Someone^> It's the partition windows is installed in. I install everything else in a different partition as far as I can
01:40:25 <vixey> solrize -- length x == n
01:40:27 <vixey> oops
01:40:36 <vixey> didn't mean ..
01:40:50 <^Someone^> That (the other partition) is  where ghc is installed too, but all the libs I installed just now got installed in the first partition
01:41:08 <solrize> maybe i'll write  data Foo374 = { n :: Integer, x :: [Foo] {- n -} }
01:41:12 <solrize> there are a lot of these structures
01:41:18 <^Someone^> I prefer having them all in one place
01:41:35 <solrize> i wish the constructor namespaces were separate for each type
01:41:48 <vixey> solrize: is the only point of 'n' to stop you recalulating length over and over?
01:41:58 <solrize> i'm envisioning some kind of macro or TH kludge to do this stuff
01:42:04 <solrize> no n is to know how many records to read from a file
01:45:11 <solrize> the "power of pi" paper is interesting re problems like this
01:52:59 <dmwit> *Main> timeEquality (foldb1 (*) [2..100000])
01:53:03 <dmwit> 0.546624s
01:53:10 <dmwit> *Main> timeEquality (foldl1' (*) [2..100000])
01:53:13 <dmwit> 9.977159s
01:53:16 <dmwit> Yay!
01:59:09 <quicksilver> solrize: how about writing it as a quickcheck property
01:59:33 <quicksilver> solrize: prop_foo374 = \foo -> (length (x foo) == (n foo))
01:59:50 <quicksilver> solrize: that is (a) good documentation and (b) something you can call as an assertion if you want
01:59:58 <quicksilver> e.g. in a "Debugging" mode, check all the invariants
02:00:01 <quicksilver> or as part of a test suit
02:00:02 <quicksilver> etc etc
02:03:22 <NameAlreadyInUse> is there an int to string function?
02:03:34 <quicksilver> show
02:03:46 <NameAlreadyInUse> ty
02:04:31 <mauke> printf :-)
02:06:52 <NameAlreadyInUse> .. there is printf in haskell?
02:06:57 <quicksilver> there is.
02:07:03 <quicksilver> I don't really recommend its usage
02:07:11 <quicksilver> but it does have its points
02:10:49 <cjs> ixdy, vixey: Sorry about that. Client suddenly came by. Anyway, I'm working at starling-software.com, and writing an automated options trading system.
02:12:17 <Armored_Azrael> I've used Cabal for simple builds before, but this one is very, very abnormal. Am I going to have any luck translating my makefile or should I just leave it a makefile?
02:12:35 <vixey> cjs: So it's basically a robot that trades stuff and generates money?
02:12:47 <Armored_Azrael> http://plhs.matthewmaurer.org/darcsweb/darcsweb.cgi?r=plhs;a=headblob;f=/Makefile
02:12:48 <lambdabot> Title: darcs - plhs, http://tinyurl.com/6e6bd2
02:13:03 <Armored_Azrael> For reference on what the build procedure I'm considering transforming is.
02:13:26 <cjs> vixey: That's it.
02:13:38 <vixey> cjs: that's so cool :)
02:13:53 <cjs> Yeah, I thought so. At least, if one does it in Haskell.
02:14:13 <vixey> I don't mind what it's done in just such a futuristic thing
02:14:31 <cjs> My client's last version was in Java. He was thinking about using Java for this one, too, until I told him he'd have to find another developer for that. :-)
02:17:06 <NameAlreadyInUse> good on you cjs
02:18:53 <hpaste>  dmwit pasted "computers are fast" at http://hpaste.org/8256
02:18:56 <dmwit> sorry
02:19:14 <dmwit> I was on the "announce" check box and hit enter instead of space.
02:23:14 <Armored_Azrael> No opinions on whether or not it's a waste of time to try to transform that makefile?
02:27:22 <dmwit> Well... deinstall is going to be an annoying thing to target with Cabal.
02:27:47 <dmwit> deinstall, install, test would be annoying.
02:27:59 <dmwit> The rest shouldn't be much of a problem, really.
02:28:44 <dmwit> I know several projects bundle and bind to a C library while using Cabal, so that should be possible.
02:29:19 <dmwit> And it doesn't look like SHC appears anywhere, so there shouldn't be any cross-compiler gymnastics necessary.
02:30:24 <Armored_Azrael> So, the main problem is the make. The install/deinstall can be separated
02:30:30 <Armored_Azrael> s/make/build/
02:31:12 <Armored_Azrael> However, I don't know how to tell cabal to not give --make, and to specify it needs to use -shared in the final linking phase.
02:31:40 <dcoutts> Armored_Azrael: it always uses --make
02:31:52 <dcoutts> you can add extra args using --ghc-option=
02:32:40 <Armored_Azrael> dcoutts: I know how to add extra args, but I don't want shared  until the last link phase, (or it won't build) and I can't use --make, because ghc doesn't believe me when I tell it it can produce shared objects.
02:33:28 <dcoutts> @seen thetallguy
02:33:29 <lambdabot> thetallguy is in #haskell. I last heard thetallguy speak 3h 29m 10s ago.
02:34:46 <dcoutts> Armored_Azrael: shared/PIC objects are not really supported in ghc-6.8
02:34:52 <dcoutts> there's some preliminary support
02:35:02 <dcoutts> and Cabal can call ghc to make shared libs
02:35:14 <dcoutts> but I understand it doesn't work very well on the ghc side of things yet
02:35:34 <Armored_Azrael> dcoutts: I have shared libs being built with this makefile.
02:35:50 <dcoutts> Armored_Azrael: cabal has --enable-shared but I can't say how well it works
02:36:18 <Armored_Azrael> dcoutts: However, ghc will report
02:36:18 <Armored_Azrael> link: GHC not built to link this way: LinkDynLib
02:36:18 <Armored_Azrael> if it has the --make flag
02:36:21 <Armored_Azrael> and not go.
02:36:29 <Armored_Azrael> Without the --make flag, the build goes as planned.
02:36:36 <dcoutts> weird
02:37:02 <dcoutts> Armored_Azrael: well there's no way to do it without --make using Cabal
02:37:15 <Armored_Azrael> dcoutts: OK, thanks anyways.
02:37:22 <dcoutts> as I say, it's not realyl expected to work with 6.8 but should do with 6.10
02:37:39 <Armored_Azrael> Yeah, I know. Unfortunately this project is due in under 12 hours :P
02:37:47 <Armored_Azrael> And I don't think the release schedule is that fast.
02:37:58 <dcoutts> heh
02:38:11 <dcoutts> Armored_Azrael: you're making a plugin for postgresql server? that's cool
02:38:16 <Armored_Azrael> Yeah.
02:38:27 <Armored_Azrael> It works, but I have to make it build on other systems now.
02:38:38 <dcoutts> Armored_Azrael: you should write up how you did it. I'm sure people will be interested.
02:38:52 <Armored_Azrael> This will all show up on the website, hopefully before the project is due :P
02:39:08 <Armored_Azrael> Right now I'm waiting on my ghc rebuild to get fPIC enabled in a .deb instead of just on my system.
02:39:30 <dcoutts> Armored_Azrael: I think there's little choice here but to use a makefile or a dev version of ghc
02:39:42 <Armored_Azrael> Dev GHC hasn't compiled for a while
02:39:52 <Armored_Azrael> So looks like it's a Makefile
02:39:57 <Armored_Azrael> not the end of the world though
02:40:56 <Armored_Azrael> I also have to package YHC sadly :P
02:41:04 <dcoutts> Armored_Azrael: to be honest, I'm impressed you got it working at all
02:41:06 <Armored_Azrael> (code is stored as bytecode compiled in the table)
02:41:31 <Armored_Azrael> It took a bit of doing, but on some level, the ghc build process is just linking.
02:41:31 <dcoutts> oh yhc bytecode stored in the db itself?
02:41:36 <Armored_Azrael> Yes.
02:41:39 <dcoutts> nice
02:41:53 <dcoutts> I look forward to the writeup :-)
02:41:59 <Armored_Azrael> Check MakeMod and ExecMod to see an example usage
02:46:43 <quicksilver> bytecode in the DB
02:46:46 <quicksilver> sounds funky!
03:09:29 <FordCortina> > let x = \x -> True
03:09:30 <lambdabot>  Parse error at end of input
03:13:22 <FordCortina> @undefine
03:13:23 <lambdabot> Undefined.
03:13:34 <FordCortina> @let x = \x -> True
03:13:35 <lambdabot> Defined.
03:13:49 <FordCortina> > x 1
03:13:49 <lambdabot> Terminated
03:13:54 <FordCortina> huh?
03:14:10 <wjt> @let seems to be busted
03:14:10 <lambdabot>  Parse error
03:14:16 <PHO_> > exitFailure
03:14:16 <lambdabot>   Not in scope: `exitFailure'
03:14:18 <wjt> @let three = 3
03:14:18 <lambdabot> Defined.
03:14:19 <wjt> > three
03:14:20 <lambdabot> Terminated
03:14:21 <FordCortina> ah ok
03:14:26 <PHO_> > System.Exit.exitFailure
03:14:26 <lambdabot>   Not in scope: `System.Exit.exitFailure'
03:16:50 <FordCortina> @djinn (a -> Bool) -> (a -> Bool) -> a -> Bool
03:16:51 <lambdabot> f a b c =
03:16:51 <lambdabot>     case b c of
03:16:51 <lambdabot>     False -> a c
03:16:51 <lambdabot>     True -> False
03:17:29 <PHO_> > repeat 1
03:17:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:17:35 <FordCortina> @pl case b c of; False -> a c; True -> False
03:17:35 <lambdabot> (line 1, column 12):
03:17:36 <lambdabot> unexpected ";"
03:17:36 <lambdabot> expecting variable, "(", operator or end of input
03:17:52 <FordCortina> @pl f a b c = case b c of; False -> a c; True -> False
03:17:52 <lambdabot> (line 1, column 22):
03:17:52 <lambdabot> unexpected ";"
03:17:52 <lambdabot> expecting variable, "(", operator or end of input
03:18:22 <ziman> FordCortina, @pl doesn't accept case
03:18:43 <FordCortina> ah... was worth a try
03:19:01 <PHO_> > 10000^10000
03:19:01 <FordCortina> i was trying to find a way of combining two funcation of type a->Bool
03:19:02 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
03:19:08 <FordCortina> without a lambda
03:19:13 <FordCortina> basically
03:19:19 <FordCortina> And ing them
03:19:22 <ziman> FordCortina, what should the resulting function do?
03:19:41 <FordCortina> ok in lambda form
03:19:50 <quicksilver> FordCortina: liftM2 (&&)
03:20:01 <ziman> @pl \f g x -> (f x) && (g x)
03:20:02 <lambdabot> liftM2 (&&)
03:20:16 <quicksilver> liftM2 (&&) (>5) (<10) $ 8
03:20:20 <quicksilver> > liftM2 (&&) (>5) (<10) $ 8
03:20:21 <lambdabot>  True
03:20:23 <quicksilver> > liftM2 (&&) (>5) (<10) $ 12
03:20:23 <FordCortina> \f g x -> (f x) && (g x)
03:20:24 <ziman> which monad is that?
03:20:25 <lambdabot>  False
03:20:29 <FordCortina> thanks quicksilver
03:20:30 <quicksilver> ziman: reader monad
03:20:37 <quicksilver> aka "share the same parameter" monad
03:20:47 <tchakkazulu> (need Control.Monad.Instances for that, to get the ((->) r) monad)
03:21:20 <ziman> quicksilver, thanks, i'll take a look at it
03:21:41 <quicksilver> there are also related tricks in Control.Arrow
03:22:28 <quicksilver> ((>5) &&& (<10)) 12
03:22:32 <quicksilver> > ((>5) &&& (<10)) 12
03:22:34 <lambdabot>  (True,False)
03:22:44 <quicksilver> you could then combine that with uncurry (&&)
03:22:48 <quicksilver> which might be a little perverse.
03:26:01 <ziman> liftM1 would be fmap?
03:27:25 <quicksilver> right.
03:27:29 <quicksilver> also known as liftM
03:27:32 <quicksilver> and (<$>)
03:27:37 <quicksilver> and liftA
03:27:44 <quicksilver> (<$>) is my favourite thoug.
03:32:58 <dolio> <$> has so many symbols, though. Maybe we could use something shorter...
03:33:04 <dolio> Like . or something. :)
03:33:20 <dcoutts_> pah
03:33:21 <vixey> :t (<$>)
03:33:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:33:42 <quicksilver> dolio: good plan.
03:33:48 <dcoutts_> (->) type is special, I don't like overloading (.)
03:33:51 <vixey> (f:: * ョ *)
03:34:12 <dolio> Personally I prefer overloading (.) to Category.
03:34:43 <quicksilver> intuitively that seems much nicer.
03:34:45 <dcoutts_> <$> is nicer than fmap, that's for sure
03:34:58 <quicksilver> Although fmap is much more useful than Category.. in my experience
03:35:11 <dolio> Yeah. It's a conundrum.
03:35:13 <quicksilver> but category.. does feel like a more natural way to generalise Prelude..
03:35:32 <vixey> scrap prelude and start again
03:35:32 <dcoutts_> @src Category
03:35:32 <lambdabot> Source not found. Sorry.
03:35:41 <vixey> start with chunks
03:35:47 <vixey> and (.) = (>>>) or whatever it is
03:42:20 <|Jedai|> (.) = flip (>>>)
03:42:26 <vixey> ok <<<
03:44:32 <solrize> quicksilver, re my question earlier about foobar374, i wasn't looking as much for a type/error checking assertion, as a way of telling data.binary how much stuff to read
03:53:05 <quicksilver> solrize: *nod* well of course Data.Binary's automatic instance for lists does write length information...
03:56:08 <solrize> quicksilver it's for reading not writing.  the file format is fixed, an integer N followed by N records of a particular structure
03:57:37 <quicksilver> right.
03:57:48 <quicksilver> well you can't use Data.Binary's automatic deriving for fixed file formats.
03:58:43 <solrize> i was kind of hoping i could, but i can either handwrite the instances or in principle (i don't understand SYB nearly well enough in practice) concoct my own deriver
04:00:55 <quicksilver> yes, hadnwriting the instances is easy enough.
04:01:21 <solrize> well there's quite a few so it's messy
04:02:29 <shapr> yarr!
04:02:45 <ivanm> this is OT, but does anyone know a way in bash I can have a list/array/whatever of compiler flags and get every possible combination of flags? (i.e. for each flag i, either include it or don't)
04:02:59 * ivanm passes shapr a '@'
04:03:08 <shapr> @yarr!
04:03:08 <lambdabot> Smartly me lass
04:03:12 <shapr> Ah, much better.
04:03:18 <solrize> cc -{a,}{b,}{c,}
04:03:37 <ivanm> ooohhhhh...... didn't think about that...
04:03:44 <Armored_Azrael> Anyone know how to get haddock to detect installed libraries when generating documentation, or at least link back to the HHL?
04:04:20 <vixey> @yarrr
04:04:20 <lambdabot> Shiver me timbers!
04:04:38 <ivanm> thanks solrize++
04:04:58 <cjs> @yarrrrrrrrr
04:04:58 <lambdabot> Unknown command, try @list
04:05:01 <ivanm> now I just have to find a way of automatically turning {a,b,c} to {a,}{b,}{c,} ;-)
04:05:10 <ivanm> @yow
04:05:11 <lambdabot> I'm QUIETLY reading the latest issue of "BOWLING WORLD" while my wife
04:05:11 <lambdabot> and two children stand QUIETLY BY ...
04:05:21 <shapr> @quote ghc
04:05:22 <lambdabot> ghc says: absApply: Duff function
04:06:26 <Vq^> shapr: g'day formarn
04:07:11 <shapr> g'day
04:08:05 <FordCortina> @pl \(x,y) f -> (f x,f y)
04:08:05 <lambdabot> uncurry ((. flip id) . ap . ((,) .) . flip id)
04:08:21 <FordCortina> hmm
04:09:07 <vixey> :couldn't it be (f&&&f)
04:09:14 <vixey> no wait not that..
04:10:10 <wjt> > (f *** f) (x,y) :: (Expr, Expr)
04:10:11 <Vq^> join (***) -- perhaps?
04:10:11 <lambdabot>  (f x,f y)
04:11:39 <dmwit> That type is too restrictive.
04:11:53 <dmwit> join (***) is less polymorphic than f *** f.
04:12:08 <dmwit> > join (***) (+1) (3%5, 0.6)
04:12:10 <lambdabot>  (8%5,8%5)
04:12:15 <xerox> Why?
04:12:23 <dmwit> > join (***) (+1) (1::Int, 1::Double)
04:12:24 <lambdabot>  Couldn't match expected type `Int' against inferred type `Double'
04:12:36 <dmwit> > ((+1) *** (+1)) (1::Int, 1::Double)
04:12:37 <lambdabot>  (2,2.0)
04:12:56 <Vq^> dmwit: but thats not (f *** f)
04:13:15 <dmwit> > let f = (+1) in (f *** f) (1::Int, 1::Double) -- yes it is
04:13:17 <lambdabot>  (2,2.0)
04:13:37 <Vq^> oh
04:13:50 <Vq^> so it is :)
04:14:15 <dmwit> I just alpha-reduced it in my head. ;-)
04:17:38 <quicksilver> well, haskell doesn't have first-class polymorphism by default ;)
04:26:38 <vixey> @seen monochrom
04:26:38 <lambdabot> I haven't seen monochrom.
04:33:52 <TSC> Does Bertram Felgenhauer hang around here?
04:34:18 <vixey> @seen Bertram Felgenhauer
04:34:19 <lambdabot> I haven't seen Bertram.
04:34:27 <TSC> Thanks
04:34:34 <vixey> that's the best I could do :[
04:34:37 <TSC> (:
04:34:38 <dcoutts_> TSC: int-e
04:34:56 <TSC> Thanks, dcoutts_
04:35:01 <dcoutts_> @seen int-e
04:35:02 <lambdabot> I haven't seen int-e.
04:35:05 <dcoutts_> bah
04:35:17 <vixey> @seen ANYOnE
04:35:17 <lambdabot> I haven't seen ANYOnE.
04:35:28 <vixey> ?users
04:35:29 <lambdabot> Maximum users seen in #haskell: 417, currently: 413 (99.0%), active: 11 (2.7%)
04:38:27 <tensh> @karma
04:38:28 <lambdabot> You have a karma of 1
04:38:37 <tensh> :)
04:43:43 <levi13> Hi, I'm trying to make an instance of applicative but having problems
04:44:09 <levi13> I was hoping that I could make functions of the form   a -> f b (where f is also an instance of Applicative) an instance of applicative
04:44:23 <dmwit> ?src Applicative
04:44:24 <lambdabot> class Functor f => Applicative f where
04:44:24 <lambdabot>     pure  :: a -> f a
04:44:24 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:44:56 <Saizan_> well (->) e is an applicative
04:45:14 <Saizan_> so you can get the applicative by composition
04:45:15 <dmwit> yep
04:45:19 <dmwit> :t const
04:45:20 <dmwit> :t ap
04:45:21 <lambdabot> forall a b. a -> b -> a
04:45:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:45:28 <levi13> yes, so I would like (->) a (f b) to be applicative, but I'm not sure I can make it have kind * -> *
04:45:32 <dmwit> Well, I guess any Monad is an Applicative.
04:45:51 <dmwit> levi13: No, an Applicative instance must unary kind.
04:46:25 <Saizan_> dmwit: uh? f :: * -> * in the class declaration
04:46:29 <dmwit> sorry
04:46:57 <dmwit> But it can't have kind * -> * -> *, as he wants.
04:47:17 <dmwit> newtype Foo f a b = Foo (a -> f b)
04:47:33 <Saizan_> he doesn't, the problem is that we don't have composition at the type level without extensions
04:47:37 <dmwit> instance Applicative f => Applicative (Foo f) where ... -- can't work
04:47:58 <dmwit> ... Applicative (Foo f a) where ... -- might work
04:48:54 <dolio> Extensions?
04:49:09 <dmwit> Though I'm not sure what pure would be.
04:49:19 <Saizan_> dmwit: pure = pure . pure
04:49:36 <Saizan_> dolio: you can't have type synonims in instance heads, iirc
04:49:47 <dmwit> Ah, yeah.
04:50:03 * dmwit had to think a while to expand the type signature of pure
04:50:21 <levi13> I'm wanting pure to be   pure f = pure . f
04:50:33 <levi13> :t \f -> pure . f
04:50:34 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f1, Applicative f) => f1 a -> f1 (f a)
04:50:45 <dolio> You won't be making a type synonym instance with any extension (aside from full-on type lambdas/partial application or something).
04:50:46 <levi13> hmm, maybe not?
04:51:35 <dolio> I'm sure TypeCompose has an appropriate instance.
04:51:37 <levi13> that's a different type to what ghci is giving ghci says  (Applicative f) => (a -> b) -> a -> f b
04:51:45 <dolio> For ((->) a) `O` f
04:51:58 <quicksilver> the problem is that the Applicative instance for (->) a wins
04:52:03 <quicksilver> it's fully polymorphic
04:52:05 <dmwit> :t \f -> pure Prelude. f
04:52:06 <lambdabot> Not in scope: data constructor `Prelude'
04:52:11 <dmwit> :t \f -> pure Prelude.. f
04:52:11 <quicksilver> so it doesn't try to find the cleverer one
04:52:13 <lambdabot> forall b (f :: * -> *) a. (Applicative f) => (a -> b) -> a -> f b
04:52:17 <quicksilver> you'd need to scatter newtypes in betwee
04:52:24 <quicksilver> to find the instance you're after.
04:52:33 <quicksilver> (I mean, to help GHC find the right instance)
04:52:55 <Saizan_> however pure f = pure . f doesn't work
04:54:26 <levi13> where I got to this from was from looking at functions of type a -> Maybe b
04:54:52 <dolio> @hackage TypeCompose
04:54:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose
04:55:03 <levi13> I wanted to combine two of these, so have a function of type  (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
04:55:53 <levi13> it could be implmeneted as   maybeFuncCombine f g = \a -> f a <|> g a
04:56:15 <levi13> as this doesn't depend on Maybe specifically, I was looking at whether it could be more general (and how much more)
04:57:36 <levi13> :t \f g -> (a -> f a <|> g a)
04:57:38 <lambdabot> parse error on input `->'
04:57:44 <levi13> :t \f g -> (\a -> f a <|> g a)
04:57:45 <lambdabot> forall t (f :: * -> *) a. (Alternative f) => (t -> f a) -> (t -> f a) -> t -> f a
04:58:12 <dolio> @type \f g -> runKleisli (Kleisli f <+> Kleisli g)
04:58:13 <lambdabot>     Ambiguous occurrence `<+>'
04:58:13 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/imports.h:59:0-33
04:58:13 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/imports.h:67:0-46
04:58:20 <dolio> Bah.
04:58:26 <dolio> @type \f g -> runKleisli (Kleisli f Control.Arrow.<+> Kleisli g)
04:58:27 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m) => (a -> m b) -> (a -> m b) -> a -> m b
04:59:09 <levi13> ah interesting. Kleisli arrows may be what I'm after instead
04:59:26 <dolio> I wonder if that's a useful enough combinator to have in Control.Monad/Applicative.
04:59:33 <dolio> Like (<=<) and (>=>)
05:00:30 <Saizan_> ?ty liftM2 mplus
05:00:32 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
05:00:53 <Saizan_> that's the same, right?
05:00:55 <dolio> Yeah, that's it, too.
05:01:21 <dolio> I suppose that means it's not necessary.
05:01:27 <dolio> Or, urgent, at least.
05:02:15 <Saizan_> it's also (<|>) for Alternative f => (->) e `O` f
05:02:54 <dolio> I don't see that instance in TypeCompose, though.
05:04:16 <dolio> Of course, maybe you if you try to do that, you run into overlapping instances for 'Alternative g => g `O` f' and 'Alternative f => g `O` f'.
05:04:19 <dolio> If they're both valid.
05:04:39 <dolio> Which at a guess, they probably are.
05:05:35 <Saizan_> yeah
05:06:25 <Saizan_> not to mention Alternative f, Alternative g => f `O` g
05:06:52 <dolio> Yeah.
05:08:09 * dolio goes to get some pancakes.
05:08:11 <huangjs> well, someone asked me "How find the recursive definition of a problem if it has one?" I don't know how to answer it. follow the invariants? trial and error? Does anybody have some ideas?
05:11:37 <quicksilver> isn't the recursive definition normally the obvious one? :)
05:11:47 <quicksilver> it's the closed form which is normally hard to work out.
05:16:02 <huangjs> quicksilver: question: how do you express KMP search algorithm in a recursive way?
05:23:59 <sioraiocht> I have a qusetion about this code http://hpaste.org/8258 . Is it safe to use a where clause to define a statement that may not be safe, but then use a guard to check its safety before using it in the body of a function
05:24:18 <SamB_XP> sioraiocht: statement?
05:24:31 <sioraiocht> SamB_XP: sorry, an expression
05:24:48 <SamB_XP> but it's perfectly fine to have definitions that might bottom out in a where clause...
05:24:52 <sioraiocht> okay
05:25:16 <ziman> sioraiocht, a value will not be computed unless used
05:25:26 <ziman> (laziness)
05:25:32 <sioraiocht> right, was just making sure ;)
05:25:36 <SamB_XP> I mean, it's fine to have them at the top level too ;-)
05:25:49 <SamB_XP> undefined, for instance ;-)
05:26:03 <ziman> @src undefined
05:26:04 <lambdabot> undefined =  error "Prelude.undefined"
05:26:10 <sioraiocht> I just have a lot of long expressions that may/may not be used in a given run of a function
05:29:37 <ziman> > undefined and False
05:29:39 <lambdabot>  Exception: Prelude.undefined
05:29:44 <ziman> > False and undefined
05:29:45 <lambdabot>  Couldn't match expected type `([Bool] -> Bool) -> a -> t'
05:30:00 <ziman> > False && undefined
05:30:02 <lambdabot>  False
05:30:15 <ziman> > undefined && False
05:30:17 <lambdabot>  Exception: Prelude.undefined
05:31:20 <ziman> i wonder whether it is possible to have unbiased logical operators
05:31:46 <mm_freak> can i change IO's idea of a line-feed?
05:32:03 <RayNbow> ziman: unbiased logical operators?
05:32:09 <vixey> ziman: you shouldn't be able to
05:32:14 <dcoutts_> int-e: TSC was looking for you
05:32:29 <vixey> ziman: you can't really know if something is undefined until you know what it is, and figuring that out might take infinite time
05:32:37 <quicksilver> well you can have this :
05:32:39 <Draconx> vixey, you could evaluate the operands in parallel, though.
05:32:52 <quicksilver> and a b = a `seq` b `seq` (a && b)
05:32:55 <vixey> Draconx: That's doesn't solve the general program though
05:32:56 <quicksilver> that would be unbiased.
05:33:08 <vixey> oh I thought you were wanting
05:33:15 <vixey> undefined && False = False
05:33:31 <vixey> why don't you just define && like as a 4 case truth table then
05:33:31 <quicksilver> there's more than one way to be unbiased :)
05:33:38 <quicksilver> I took the least fixed point.
05:33:43 <quicksilver> vixey: that won't help.
05:33:44 <Draconx> vixey, I'm not entirely sure what the "general problem" is, but I assumed it was along the lines of "if one operand runs infinitely, but the other halts and is enough to know the result of the operation, we should get that result"
05:33:50 <ziman> i meant if one of the operands is false then the whole expression is false, regardless of the other operand
05:34:05 <quicksilver> you can do taht using unsafePermformIO and forkIO
05:34:08 <quicksilver> it's not pretty :)
05:34:11 <ziman> :)
05:34:40 <vixey> > let True&&True=True;True&&False=False;False&&True=False;False&&False=False in False && undefined
05:34:41 <lambdabot>  Exception: Prelude.undefined
05:34:45 <vixey> > let True&&True=True;True&&False=False;False&&True=False;False&&False=False in undefined && False
05:34:46 <lambdabot>  Exception: Prelude.undefined
05:35:08 <quicksilver> oh, I see what you mean.
05:35:09 <quicksilver> Yes :)
05:35:21 <ziman> > let _ && False = False; False && _ = False; True && x = x; x && True = x in undefined && False
05:35:22 <lambdabot>      Warning: Pattern match(es) are overlapped
05:35:22 <lambdabot>              In the definition...
05:35:30 <ziman> blah blah.. :)
05:35:59 <mm_freak> let a :&&: b = unsafePerformIO (catch (return a) (\_ -> return False)) && unsafePerformIO (catch (return b) (\_ -> return False)) in False :&&: False
05:36:06 <mm_freak> > let a :&&: b = unsafePerformIO (catch (return a) (\_ -> return False)) && unsafePerformIO (catch (return b) (\_ -> return False)) in False :&&: False
05:36:07 <lambdabot>   Not in scope: data constructor `:&&:'
05:36:17 <mm_freak> huh?
05:36:26 <mm_freak> > let a .&&. b = unsafePerformIO (catch (return a) (\_ -> return False)) && unsafePerformIO (catch (return b) (\_ -> return False)) in False .&&. False
05:36:27 <lambdabot>   Not in scope: `unsafePerformIO'
05:36:38 <mm_freak> ok, lambdabot doesn
05:36:41 <mm_freak> ok, lambdabot doesn't help here =)
05:37:07 <quicksilver> catch could be used to catch an explicitly 'undefined'
05:37:11 <quicksilver> but doesn't catch _|_ in general
05:37:15 <quicksilver> that's why ou need to fork.
05:37:19 <mm_freak> true
05:37:23 <mm_freak> you'd need a timeout
05:37:26 <ziman> mm_freak, undefined .&&. False still gives undefined ;)
05:37:44 <int-e> dcoutts_: hmm thanks, he didn't say why though. Oh well, I'll be around for a bit.
05:37:50 <mm_freak> ziman: indeed
05:37:52 <quicksilver> you don't need a timeout
05:37:58 <quicksilver> you just need to run the two in parallel.
05:38:05 <int-e> TSC: pong
05:38:11 <ziman> i don't even know if what i'm requesting is consistent
05:38:14 <mm_freak> quicksilver: what if both are bottom?
05:38:24 <ziman> then the answer should be bottom
05:38:34 <quicksilver> then the answer should be bottom, yes.
05:38:59 <mm_freak> ziman: well, you're asking for something that isn't (&&)
05:40:29 <ziman> mm_freak, yes, but it is closer to my idea of `smart' bool ops ;)
05:41:42 <ivanm> solrize: with that bash expansion thingy... do you know how I can get a variable to be the expansion? i.e. x={"a","b"} doens't get expanded to "a b" :s
05:41:50 <ziman> well, i think one problem is that we use Bool & undefined instead of Maybe Bool, it seems like misuse to me
05:42:41 <ziman> from that point of view, quicksilver's a `seq` b `seq` a && b should be what we want
05:43:51 <gwern> > let x = x in x
05:43:52 <mm_freak> ziman: not really, because it needs parallelity
05:43:57 <gwern> > let x = x + 1 in x
05:44:01 <gwern> > let x = 1 + x in x
05:44:07 <lambdabot>  thread killed
05:44:12 <lambdabot>  thread killed
05:44:17 <lambdabot>  thread killed
05:44:26 <mm_freak> ziman: at some point you need to decide, which side is better to evaluate first, or you evaluate both sides simultaneously
05:45:05 <mm_freak> and without real OS threading (or smart yielding in your individual threads, which will be difficult), it will be just the same as (&&) =)
05:45:16 <Botje> bah
05:45:21 <ziman> and as it cannot (?) be decided in advance, it needs parallelity
05:45:23 <Botje> my compiler _ALMOST_ works
05:45:34 <Botje> but it blows up on ackermann(4,1)
05:45:48 <mm_freak> ziman: the compiler may be able to decide that, but usually yes, you'll need parallelity
05:46:10 <quicksilver> mm_freak: eh? why is that not bottom?
05:46:20 <quicksilver> mm_freak: I don't understnad your observation.
05:46:35 <quicksilver> mm_freak: bottom && bottom is definition bottom.
05:46:55 <ziman> mm_freak, i think it's the Halting problem
05:47:01 <ziman> i need to go now, i'll think about it
05:47:21 <pejo> ziman, it is - you're trying to decide if arbitrary terms will terminate.
05:47:31 <mm_freak> quicksilver: uhm, did i question that?
05:47:50 <quicksilver> 13:38 < mm_freak> quicksilver: what if both are bottom?
05:47:51 <quicksilver> 13:38 < ziman> then the answer should be bottom
05:47:55 <quicksilver> 13:38 < mm_freak> ziman: well, you're asking for something that isn't (&&)
05:48:30 <mm_freak> quicksilver: i was referring to the fact that ⊥ && x == ⊥
05:49:08 <mm_freak> if ⊥ .&&. x is not necessarily ⊥, then (.&&.) is not the same as (&&)
05:49:20 <quicksilver> sure.
05:49:29 <quicksilver> but it's fairly clear what an 'unbiased version of &&' means
05:49:40 <quicksilver> whilst still being faithful to the strict (&&)
05:51:56 <mm_freak> yeah, that's clear
05:52:04 <mm_freak> one problem i see is that you need OS threads
05:52:17 <mm_freak> otherwise it's still biased to the first forked thread
05:56:22 <ddarius> Botje: You should use a typed intermediate language and a typed assembly.
05:57:05 <ddarius> mm_freak: All you need is threads implemented by the (language) system however and a bit of fairness.
05:57:50 <mm_freak> ddarius: i don't know any haskell RTS implementation, which does that without explicit preemption points, which are impossible in this case
05:58:16 <ddarius> mm_freak: GHC will do that almost without needing OS threads.
05:58:28 <ddarius> GHC however doesn't guarantee that "bit of fairness", though it could.
05:58:34 <mm_freak> ddarius: it won't, because the computations run are pure
05:58:57 <mm_freak> GHC works with preemption points like IO actions (i've tested that)
05:59:10 <ddarius> GHC yields on the heap check.
05:59:23 <quicksilver> mm_freak: GHC pre-empts on memory allocation
05:59:35 <quicksilver> only a tightly spinning allocation-free computation can resist.
05:59:41 <ddarius> You can monopolize the CPU by having a tight loop with no allocation (though that's difficult to do for real code)
05:59:49 <quicksilver> fortunately those aren't common. Unfortunately they exist.
05:59:53 <mm_freak> hmm
05:59:56 <ddarius> GHC could easily change this behaviour, but it would cost performance all around.
06:00:15 <dolio> They'll get more common if dons has anything to say about it. :)
06:00:35 <ddarius> dolio: Indeed, and it may become necessary for GHC to explicitly insert "safe" points.
06:00:39 <Philippa_> ddarius: it really ought to be a compiler switch IMO
06:01:13 <ddarius> Philippa_: I'd prefer a "primitive" that guarantees a yield (in addition to a switch)
06:02:03 <cjs> Do we have a fixed-precision decimal data type in Haskell?
06:02:16 <Philippa_> ddarius: give or take an unsafePerformIO, isn't there one already?
06:02:18 <ddarius> I believe there is one on hackage or somewhere.
06:02:36 <ddarius> Philippa_: I'm pretty sure some primitives, e.g. lazy, could probably already be used for it.
06:03:12 <quicksilver> cjs: Yes, Data.Fixed.
06:03:48 <ddarius> quicksilver: I'm not sure if cjs meant base-10 by decimal.
06:04:47 <quicksilver> neither am I, but the answer I gave is the best I have :)
06:04:48 <cjs> No, I meant as in fixed-point numbers.
06:05:10 <ddarius> cjs: Okay, then Data.Fixed is what you want.
06:05:11 <quicksilver> Data.Fixed's mechanisms ought to be portable to other bases but maybe it puts its exponents to base10 by default.
06:05:19 <cjs> Yes, it looks like it. And base 10 is fine.
06:05:21 <ddarius> There is also a library somewhere for working with base-10 numbers.
06:05:38 <cjs> My client would kill me if I started showing him option strike prices in another base. :-)
06:05:43 <ddarius> Data.Fixed is the obvious implementation of a fixed precision number.
06:05:55 <quicksilver> but it does have a slight preference for 10 as the base.
06:06:19 <cjs> Though, duh, I just realized, I'm going to take a big speed hit over Double if I use that, aren't I?
06:06:46 <ddarius> I doubt it.
06:06:52 <ddarius> It's probably about comparable.
06:06:58 <mm_freak> ddarius, quicksilver: strict folds seem to be such "tight loops"
06:07:01 <cjs> Really? Won't Doubles just use the FPU?
06:07:05 <ddarius> Back in the day fixed point was faster that floating point.
06:07:15 <quicksilver> ddarius: it's Integer that is the overhead.
06:07:16 <mm_freak> if the computation done by them is on simple data types like Int
06:07:18 <ddarius> mm_freak: Yes.  Thank GHC.
06:07:29 <quicksilver> I would guess it's of the order of 2x to 4x slower
06:07:36 <quicksilver> (Data.Fixed over Double)
06:07:40 <ddarius> quicksilver: Aren't there Fixed that are Int/Word based?
06:07:43 <quicksilver> cjs: I'd be surprised if it matters to you.
06:07:58 <quicksilver> cjs: it seems unlikely that the speed of the mathops is the bottleneck in your program.
06:08:05 <cjs> It may well. I'm doing a fair amount of calculation.
06:08:17 <dolio> 'newtype Fixed a = MkFixed Integer deriving (Eq, Ord)'
06:08:18 <quicksilver> speed of network marshalling/demarshalling is normally orders of magnitude slower.
06:08:31 <quicksilver> (than even Integer mathops)
06:08:37 <cjs> No, the network stuff is no problem. It's a pretty simple protocol, and Data.ByteString rocks.
06:08:43 <quicksilver> heck, with the current rations of memory speed to CPU speed
06:08:50 <dolio> The only other datatypes in there are the resolutions.
06:08:55 <quicksilver> even Integer math is not that slow compared to memory load times.
06:09:13 <quicksilver> cjs: well the only good advice we can give you is to try and see.
06:09:13 <Axman6> has integer math ever been that slow?
06:09:25 <quicksilver> as I say, I will be surprised if it's slow.
06:09:32 <quicksilver> Axman6: sure, it involves function calls.
06:09:32 <cjs> Well, we'll soon see. But I'd like to recalculate the full model with every message, and the model seems to involve a fair amount of math.
06:09:34 <ddarius> Axman6: Arbitrary precision integers, yes.
06:09:39 <quicksilver> function calls are quite a bit slower than opcode.s
06:09:44 <ddarius> Axman6: Integer is an unbounded integer type.
06:09:51 <ddarius> > 2^100
06:09:53 <lambdabot>  1267650600228229401496703205376
06:10:07 <quicksilver> cjs: it should be relatively easy to write your code in a way which makes the switch between Double and Data.Fixed rather simple.
06:10:12 <Axman6> ah, i see
06:10:21 <cjs> That's a good thought. I'll look at it and keep that in mind.
06:10:25 <quicksilver> cjs: what did you say they were using before? Java? I very much doubt Data.Fixed is any slower than java's alternative.
06:10:31 <cjs> Though the main issue that just came up is floating point equality.
06:10:43 <quicksilver> yes, that's a fair concern.
06:10:46 <cjs> So it's not like I care that much outside of things like that, which gives me other solutions.
06:11:02 <quicksilver> myself I'd use Data.Fixed for financial stuff as my first attempt
06:11:08 <quicksilver> if it's too slow I'd rethink.
06:11:21 <cjs> quicksilver: Yeah, but I sold Haskell as being much faster than Java. :-)
06:11:21 <quicksilver> (It wouldn't be hard to copy-paste Data.Fixed and change Integer to Int ;)
06:11:51 <quicksilver> Java is faster than it deserves to be as a *lot* of work has gone into those JITs.
06:11:54 <cjs> quicksilver: Keep in mind, this is not stuff where small rounding errors will make a difference. It's market models, not accounting.
06:12:38 <cjs> (Well, depending on the propagation of these "small" rounding errors, of course. All the usual FP caveats apply.)
06:12:48 <quicksilver> cjs: Oh, fair enough.
06:13:04 <gwern> man. this is so weird. I'm writing a haskell evaluator, and it will *sometimes* kill > let x = x + 1 in x for running out of stack, but randomly it seems to change depending on whether I cd to /tmp and set nice to 19
06:13:08 <cjs> Anyway, I'll look at Data.Fixed, keep it in mind, and just do something easy until I can get enough code to profile.
06:14:14 <mm_freak> actually, fixed point arithmetic is much faster in base 2
06:14:24 <mm_freak> almost as fast as integer arithmetic
06:14:36 * cjs bricks mm_freak.
06:14:37 <opqdonut> gah
06:14:52 <opqdonut> i kept misunderstanding "fixed point" in that sentence
06:15:09 * cjs laughs!
06:15:15 <cjs> Sorry, my bad.
06:15:17 <mm_freak> huh?
06:15:23 <mm_freak> did i misunderstand something?
06:15:30 <dolio> Like x = f x?
06:15:54 <opqdonut> dolio: yep
06:15:55 <opqdonut> :P
06:17:58 <dolio> I suppose that's what would usually be talked about in here.
06:18:15 <opqdonut> yeah
06:18:28 <quicksilver> mm_freak: only if you have have optimised machine code for it.
06:18:30 <quicksilver> mm_freak: but, yes.
06:18:51 <quicksilver> mind you quite a few CPUs have opcodes for base 10 stuff too.
06:19:05 <quicksilver> and very compilers generate this kind of cleverness reliably ;)
06:20:19 <cjs> What? People still use BCD?
06:21:33 <Philippa_> cjs: it's the cleanest way to know you've met certain legal requirements
06:21:40 <mm_freak> quicksilver: (+) and (-) are exactly the same for fixed point, and (*) and (/) are a matter of bit-shifting
06:21:58 <quicksilver> mm_freak: Yes, I'm not stupid. I do know that :)
06:22:19 <quicksilver> mm_freak: You could say the same for floating point except with an additional bit-shifting stage :P
06:22:24 <mm_freak> quicksilver: you don't need optimized machine code for that…  that's what i mean =)
06:22:25 <lilachaze> have there been any studies on the rate of bug introduction in, say, C++ versus Haskell?
06:22:30 <quicksilver> yes you do.
06:22:37 <cjs> Philippa_: Hm. Ok, I can see that.
06:22:39 <quicksilver> you need a compiler which actually generates the correct machine opcodes
06:22:46 <quicksilver> and handles overflow correctly
06:22:51 <quicksilver> otherwise you have incorrect code.
06:22:58 <quicksilver> or slow code :)
06:23:04 <mm_freak> quicksilver: you describe that in the instances
06:23:06 <quicksilver> depending which way it went wrong.
06:23:25 <quicksilver> yes, it's obvious how to encode it in haskell classes.
06:23:29 <cjs> lilachaze: I think Haskell has been shown to have more bugs per line than C++. :-)
06:23:30 <quicksilver> that's what Data.Fixed does.
06:23:46 <lilachaze> cjs: sure, but bugs per equivalent functionality?
06:23:48 <mm_freak> quicksilver: but my point is that base-2 fixed point is faster than base-10 fixed point
06:23:55 <quicksilver> I'm just saying that your compiler probably won't generate two opcodes per (*)
06:24:06 <quicksilver> even if you can imagine a machine code implementation which is only two opcodes
06:24:24 <Vq^> cjs: thats easily countered, just add a lot of ascii-art comments to the haskell-programs
06:24:46 <mm_freak> i just wanted to note that if you need fixed point, use base 2 if you can…  that's it…  and really, i know that you're not stupid ;)
06:24:59 <mm_freak> you're the one helping me all the time =)
06:27:20 <pejo> lilachaze, there was a case study about Erlang and C++ for some kind of telecom software. Close enough?
06:27:54 <cjs> Having just done four solid days of Erlang, I'd be careful about equating it to Haskell.
06:28:10 <dolio> Haskell has more or less bugs?
06:28:17 <dolio> Or, encourages.
06:28:29 <cjs> But it does seem to me that Haskell would probably be better than Erlang.
06:28:36 <cjs> I found Erlang pretty painful. No typechecker!
06:29:19 <xd> it comes with an app that does checking
06:29:45 <cjs> Oh, does it? Damn, I could have used that.
06:30:11 <xd> http://erlang.org/doc/apps/dialyzer/index.html
06:30:12 <lambdabot> Title: Dialyzer Reference Manual
06:30:57 <lilachaze> pejo: that sounds interesting, yes. google found this: www.erlang.se/publications/xjobb/c++-vs-erlang.ps.gz
06:31:49 <cjs> lilachaze: Why in particular are you looking for such studies?
06:32:01 <pejo> lilachaze, I was thinking of "Evaluating high-level distributed language constructs" by Nystrm, Trinder, and King.
06:37:29 <lilachaze> cjs: just curious. the safety or otherwise of c++ just came up on ##c++. :)
06:38:48 <cjs> Safety. Heh. :-)
06:45:57 <quicksilver> C++ is safe like a scalpel.
06:46:07 <quicksilver> Fine for qualified surgeons under sterile conditions.
06:46:37 <dolio> It's dependently typed, so you should be able to do all kinds of great theorem proving about your programs. :)
06:47:58 <Saizan_> and then kill yourself with a pointer?
06:49:49 <quicksilver> dolio: although a theorem of sufficient complexity will be rejected by your compiler ;)
06:50:00 <dolio> Heh.
06:50:17 <quicksilver> type-recursion is depth-limited AIUI.
06:50:26 <quicksilver> mind you g++ probably has flags for that kind of thing.
06:50:31 <pejo> quicksilver, that's normally a tunable.
06:50:37 <quicksilver> I dare say some of it is exponential too
06:51:01 <dolio> Well, since templates are turing complete, they're inconsistent as a logic anyway, I guess, so your proofs have no weight. :)
06:51:29 <vixey> it's sort of like proofs in haskell
06:51:45 <vixey> you can write them but you really need to understand it fully to know if the proof hasy any meaning at all
06:53:04 <Saizan_> well you've to evaluate them to a normal form to see if the proof is valid or not, i guess?
06:53:09 <dolio> Haskell's type system isn't Turing complete unless you turn on a few extensions, though.
06:53:29 <vixey> even without extensions, undefined :: a
06:54:00 <vixey> so weird stuff can creep in
06:54:10 <dolio> Although, if you're using type classes, it's hard to do any interesting programming in the type system without undecidable instances.
06:54:17 <dolio> Type families are a better at that.
06:54:34 <hpaste>  cjs pasted "awkward" at http://hpaste.org/8259
06:54:41 <cjs> What's the clever way of doing that?
06:55:01 <cjs> I'm thinking something with >>=.
06:55:02 <quicksilver> cjs: the clever way to do that is to ask #haskell ?
06:55:03 <quicksilver> ;)
06:55:03 <dolio> Yeah, I suppose every type is inhabited, too.
06:55:11 <vixey> you can use >>= yes
06:55:14 <dolio> So there is no proper False.
06:55:21 <cjs> quicksilver wins a prize!
06:55:21 <quicksilver> cjs: just <$> actually
06:55:25 <quicksilver> (aka fmap or liftM)
06:55:34 <mrd> fmap over quotes
06:55:39 <quicksilver> sort . nub . map (strikePrice. instrument) <$> quotes
06:55:45 <quicksilver> is how I would write it
06:56:01 <mrd> i would do the same thing... except I would yell "COBRA!!"
06:56:13 <quicksilver> (at which point you have a one-line do-block and you can remove the do)
06:56:21 <cjs> Hm. fmap. <$>. New territory for me.
06:56:36 <quicksilver> (a <- x; return (f a)) is fmap f x
06:56:40 <quicksilver> aka liftM f x
06:56:43 <mrd> on a monad
06:56:44 <quicksilver> aka f <$> x
06:56:53 <quicksilver> I prefer the final notation.
06:57:01 <quicksilver> f $ x --- normal value x
06:57:09 <quicksilver> f <$> x -- x calculated by monadic action
06:57:39 <cjs> Gah. "No instance for (Functor QuoteCalc)".
06:57:44 <cnwdup> I am experimenting with a small IRC bot but once I set up the whole modules, I get a compiling error I cannot really deal with. Might someone of you have a look? http://hpaste.org/8260 I don't know why type variable `b' is ambiguous.
06:57:49 <cjs> Ok, this is something I probably hack on tomorrow morning.
06:58:00 <mrd> cjs: you didn't write a Functor instance for your Monad?
06:58:07 <cjs> No. Is that bad?
06:58:10 <mrd> yes
06:58:16 <cjs> Oops. :-)
06:58:21 <cnwdup> (If you need more code abstracts, tell me. I thought that was the relevant part.)
06:58:24 <cjs> Good thing I asked!
06:58:27 <quicksilver> cjs: instance Functor QuoteCalc where fmap = liftM
06:58:31 <mrd> it's trivial.  fmap :: (a -> b) -> QuoteCalc a -> QuoteCalc b
06:58:36 <quicksilver> cjs: fortunately they're easy to write.
06:58:49 <quicksilver> it's a "bug" in the haskell standard libraries that Monads aren't automatically functors.
06:59:02 <mrd> Monad should depend on functor
06:59:06 <quicksilver> it's a further "bug" in the class system that it's not quite as easy to fix the first bug as we'd hope.
06:59:07 <cjs> Ah, I was kinda wondering about that, actually. In some sort of vague way.
06:59:24 <Saizan_> cnwdup: you've to fix the type of the elements of the Map
06:59:46 <vixey> cnwdup: What if you remove the type annotation?
07:00:17 <Saizan_> cnwdup: or, more generally, add a type annotation to st
07:01:23 <cnwdup> saizan_: How should that look like? I came up with runBot (st::Plugin a=>IRCState a) cf but that didn't help.
07:01:32 <cnwdup> vixey: What do you mean? Which type annotation?
07:01:43 <Saizan_> cnwdup: no, you've to choose a concrete 'a0
07:01:45 <Saizan_> 'a'
07:01:53 <vixey> runBot :: Plugin b => IRCState b -> IRCConfig -> IO ()
07:02:00 <Saizan_> or maybe you're misunderstanding typeclasses
07:02:00 <vixey> if you remove this line, what happens?
07:02:19 <cnwdup> saizan_: How should I do that? All I know about is that the element in the map is of class Plugin.
07:02:39 <cnwdup> vixey: No change. Still the same error.
07:03:29 <Saizan_> cnwdup: that's not good, you've to choose a type for it somewhere
07:04:01 <quicksilver> sounds like you want an existential, cnwdup
07:04:18 <cnwdup> quicksilver: I achieve that with forall, don't I?
07:04:30 <quicksilver> no.
07:04:46 <quicksilver> existentials have to be explicit wrappers.
07:05:06 <quicksilver> (or a higher kinded encoding which avoids the wrapper but probably isn't worth it)
07:05:18 <cnwdup> Can you point me to a link or something? It's the first time I have to deal with that.
07:05:30 <quicksilver> http://www.haskell.org/haskellwiki/Existential_type
07:05:31 <lambdabot> Title: Existential type - HaskellWiki
07:06:33 <cnwdup> Thank you.
07:15:46 <ziman> @djinn (a -> Bool) -> [a] -> [a]
07:15:46 <lambdabot> f _ a = a
07:15:50 <ziman> :D
07:16:19 <ziman> @djinn (a -> b) -> [a] -> [b]
07:16:19 <vixey> ?djinn [[a]] -> a
07:16:19 <lambdabot> -- f cannot be realized.
07:16:20 <lambdabot> -- f cannot be realized.
07:16:31 <vixey> f _ _ = []
07:17:29 <ttt--> @type head . head
07:17:31 <lambdabot> forall a. [[a]] -> a
07:17:43 * ttt-- outsmarts djinn!
07:18:32 <vixey> ?djinn (a -> b) -> (a -> b -> c) -> (c -> d) -> (a -> d)
07:18:33 <lambdabot> f a b c d = c (b d (a d))
07:22:05 <ttt--> why can't it do the head . head one?
07:22:14 <dolio> djinn doesn't do lists.
07:22:34 <dolio> Or anything with recursively defined types, really.
07:22:38 <ziman> @djinn (a -> b) -> m a -> m b
07:22:39 <lambdabot> -- f cannot be realized.
07:23:21 <vixey> I still haven't figured out if djinn+typeclasses is decideable
07:23:56 <vixey> maybe trying to code it would make things clearer
07:24:35 <dolio> djinn already does type classes.
07:25:39 <ttt--> @djinn Integer
07:25:39 <lambdabot> -- f cannot be realized.
07:25:46 <ttt--> @djinn Num a => a
07:25:46 <lambdabot> Cannot parse command
07:25:48 <vixey> ?djinn-env
07:25:48 <lambdabot> data () = ()
07:25:48 <lambdabot> data Either a b = Left a | Right b
07:25:48 <lambdabot> data Maybe a = Nothing | Just a
07:25:48 <lambdabot> data Bool = False | True
07:25:48 <lambdabot> data Void
07:25:50 <lambdabot> type Not x = x -> Void
07:25:52 <lambdabot> class Eq a where (==) :: a -> a -> Bool
07:26:10 <ttt--> @djinn (Num a) => a
07:26:10 <vixey> ?djinn Int -> Bool
07:26:10 <lambdabot> f _ = False
07:26:33 <ttt--> @djinn (Num a) => a
07:26:38 <dolio> It just adds all the functions in the type class as parameters for the function to find.
07:27:11 <opqdonut> ?djinn (x -> Not x) -> Not x
07:27:12 <lambdabot> f a b = a b b
07:27:13 <dolio> So 'Eq a => Sig' = '(a -> a -> Bool) -> Sig'
07:28:26 <vixey> I think that you could encode factorization problems with that
07:28:41 <vixey> but I have no idea how to get a non-terminating loop with it
07:30:30 <dolio> I don't see how that gives you any more power than prepending all the functions manually.
07:30:50 <vixey> for example: m (m a) -> m a
07:30:54 <dolio> Except that you can fit more into the line length limit.
07:31:26 <vixey> since m is a variable, it's a lot different to Maybe (Maybe a) -> Mayba
07:32:27 <dolio> But it doesn't give you any power over writing '(m (m a) -> m a) -> Sig'.
07:33:09 <vixey> > m (m a) -> m a -> m (m (m (m a))) -> m a
07:33:09 <lambdabot>  Parse error at "->" (column 9)
07:33:12 <vixey> ?djinn m (m a) -> m a -> m (m (m (m a))) -> m a
07:33:12 <lambdabot> f _ a _ = a
07:33:19 <vixey> ?djinn m (m a) -> m a -> m (m (m (m a))) -> m (m (m a))
07:33:20 <lambdabot> -- f cannot be realized.
07:33:51 <vixey> ?djinn (m (m a) -> m a) -> m (m (m (m (m (m a)))) -> m (m (m a))
07:33:52 <lambdabot> Cannot parse command
07:34:02 <vixey> ?djinn (m (m a) -> m a) -> m (m (m (m (m (m a))))) -> m (m (m a))
07:34:02 <lambdabot> -- f cannot be realized.
07:34:04 <dolio> djinn doesn't really do polymorphism.
07:34:25 <dolio> You can't instantiate a to m (m a').
07:34:28 <vixey> oh so it's polymorphism that would make it really tough
07:35:02 <dolio> Yeah, it kind of makes most type classes not very interesting.
07:35:30 <dolio> @djinn-add class Functor f where map :: (a -> b) -> f a -> f b
07:35:51 <dolio> @djinn (Functor f) => (b -> c) -> f b -> f c
07:35:51 <lambdabot> -- f cannot be realized.
07:36:03 <dolio> @djinn (Functor f) => (a -> b) -> f a -> f b
07:36:03 <lambdabot> f = map
07:37:22 <cnwdup> quicksilver: Thanks for your tip again. It seems to be exactly what I wanted. (-:
07:37:48 <dolio> @djinn (Functor f) => f a -> (a -> b) -> f b
07:37:49 <lambdabot> f a b = map b a
07:38:06 <dolio> Those two may be the only things you can actually do with Functor.
07:38:38 <quicksilver> cnwdup: your description was fairly precise, I was pretty sure :)
07:38:48 <dolio> @djinn (Functor f) => (() -> b) -> f () -> f b
07:38:48 <lambdabot> -- f cannot be realized.
07:45:36 <viller> why can't I write x=4 into ghci?
07:46:04 <dolio> write 'let x = 4'
07:46:25 <viller> why do I have to write let?
07:46:37 <viller> I'm a newb (you probably understood it already)
07:46:44 <vixey> ghci is pretending to be a big IO do block
07:46:49 <dolio> ghci evaluates expressions, x = 4 is a declaration.
07:47:45 <viller> but I can still use x=4 in regular programs (.hs)?
07:47:58 <dolio> Yeah. In a .hs, the top level is a list of declarations.
07:48:15 <dolio> So, for example, you can't just write 'print 5' in the middle of a .hs file.
07:48:33 <quicksilver> ghci is not quite like a file
07:48:36 <quicksilver> this causes much confusion
07:48:43 <quicksilver> probably it would be better if it was more like a file
07:48:53 <quicksilver> but, ghci is mostlly about evaluating expressions
07:48:55 <quicksilver> like (1+2)
07:49:01 <quicksilver> or (my_cool_function 5)
07:49:09 <viller> ok
07:49:10 <quicksilver> and you can't write things like that bare in a file
07:49:22 <quicksilver> so it could be argued that ghci is irreversible different from a file.
07:51:25 <smg> hello.
07:51:37 <smg> is there a good resource where i can learn type checking calculations?
07:51:45 <opqdonut> TAPL
07:51:47 <opqdonut> :)
07:52:25 <smg> opqdonut: really? :P
07:52:41 <opqdonut> yeah
07:52:48 <smg> also unification and so on?
07:53:07 <opqdonut> you mean for impredicative polymorphism?
07:53:17 <opqdonut> yes, it has that too
07:53:46 <opqdonut> typechecking algorithms for system F, F_\omega and \lambda_\omega and subtyping
07:55:47 <vixey> I think people just don't read the manual...
07:57:52 <mar77a> need help with this guys http://hpaste.org/8261
07:58:21 <mar77a> if anyone can tell what i'm doing wrong
07:58:57 <mar77a> i mean, the problem's i need a way to halt the execution if the log is corrupted (which happens)
08:04:40 <viller> this site: http://www.willamette.edu/~fruehr/haskell/evolution.html says something about n+k patterns in the 4th example. What are n+k patterns and why are they bad?
08:04:41 <lambdabot> Title: The Evolution of a Haskell Programmer
08:05:23 <vixey> they aren't bad
08:05:28 <int-e> @type \(n+1) -> n
08:05:30 <lambdabot> forall t. (Integral t) => t -> t
08:05:37 <vixey> it's just another language irregularity
08:07:00 <viller> so it's ok to use them?
08:07:19 <viller> I mean is it considered a good practice to use them
08:07:20 <mar77a> how's this for a quote: "you make less sense than a goto in haskell"
08:07:28 <dolio> They have their good and bad points. Most people tend not to use them.
08:07:33 <vixey> that's your choice
08:08:36 <viller> what's the alternative? If/else?
08:08:51 <vixey> instead of
08:09:04 <vixey> f (x+1) = (x+1) * f x
08:09:05 <vixey> write
08:09:12 <vixey> f x = x * f (x-1)
08:09:32 <quicksilver> the worst thing about n+k patterns is that they don't generalise
08:09:51 <quicksilver> if you have n+k patterns where are my x ~>. y patterns?
08:09:56 <vixey> aren't views the generalization?
08:10:04 <quicksilver> yes, and haskell doesn't have views.
08:10:15 <quicksilver> so they are a bit of an isolated feature.
08:10:53 <lilachaze> mar77a: i'm sure someone's written a goto monad :)
08:11:01 <mar77a> :<
08:11:05 <smg> mh.
08:11:12 <smg> i need to calculate the type of map snd ...
08:11:29 <vixey> :t map snd
08:11:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f b
08:11:33 <vixey> juts type it into haskell
08:11:50 <lilachaze> mar77a: although it probably requires rdo notation to reference later labels
08:12:10 <vixey> I doubt goto is a monad
08:12:40 <lilachaze> that sounds like a challenge :)
08:13:45 <quicksilver> goto is a monad in a sense, vixey
08:13:55 <quicksilver> you can use the monad to collect label references
08:14:08 <quicksilver> see Harpy
08:14:18 <quicksilver> which has a code-gen monad using that trick, IIRC>
08:14:31 <smg> vixey: no i need to calculate it on my own
08:14:47 <vixey> ok then
08:15:01 <hpaste>  mar77a pasted "why the warning?" at http://hpaste.org/8262
08:15:14 <vixey> that's a cool trick
08:15:17 <mar77a> "overlapped patterns" or something like that
08:15:57 <vixey> mar77a: You could collapse all those cases into just logsplit _ = corrupt
08:16:13 <mar77a> ah
08:16:13 <smg> vixey: i know, but manually calculate is bad :(
08:16:40 <mar77a> yeah that makes perfect sense
08:17:03 <mar77a> ok now i have the quadtuples
08:17:05 <Botje> smg: manually calculating types is one of the steps towards "getting" haskell
08:18:17 <mar77a> but how would i go around the destructive update i'd use in C
08:19:05 <byorgey> mar77a: hm? which destructive update?
08:19:28 <vixey> maybe with recursion
08:19:32 <mar77a> well in C++ i'd declare a map or something and do map[nickname]++;
08:19:37 <Botje> mar77a: what do you want to do?
08:19:37 <mar77a> (for example to count the kills)
08:20:07 <mar77a> that ^
08:20:27 <mar77a> i'm parsing a log with the form date\nkiller\nvictim\nweapon
08:20:28 <mar77a> and so on
08:20:38 <Botje> foldl' (\map (a,b,c,d) -> doSomething) empty logsp
08:20:52 <smg> Botje: i know
08:20:55 <FordCortina> hmm ive got a function that essentially goes from Map a (b,b) -> Map (b,b). There are two variations of this function. They differ only in that the locations of "fst" and "snd" are transposed
08:21:05 <smg> but it's bad if your teacher tells you what monomorphic and polymorphic is in about 5 mins...
08:21:11 <FordCortina> is there a good tactic for implementing this?
08:21:13 <smg> and you need then to calculate type with miller of map snd..
08:21:17 <smg> it's really annoying
08:21:22 <Botje> where empty is the appropriate empty for your datastructure
08:21:31 <Botje> mar77a: for example you could use a Data.Map
08:21:40 <Botje> and then have a Map PlayerName KillCount
08:21:44 <Botje> and work from there
08:22:14 <FordCortina> or maybe I should make a function pass the "unpairing" functions as a couple?
08:22:21 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8263
08:22:24 <mar77a> hm
08:22:39 <smg> Botje: you may look at the paste?
08:22:47 <Armored_Azrael> If anyone who was interested in my project is still awake, it's now pretty much done for now. Stuff is up at plhs.matthewmaurer.org
08:24:16 <Botje> smg: the "=> b = (g,h)" step looks rather wrong to me
08:24:24 <mar77a> but map doesn't allow for stringed keys does it
08:24:35 <mar77a> Data.Map i mean
08:24:37 <Botje> mar77a: sure it does
08:24:50 <mar77a> String is an instance of Ord?
08:24:50 <Botje> Map accepts anything that's ordered as a key
08:24:55 <Botje> sure
08:25:03 <mar77a> odd ..sort of
08:25:10 <Botje> @instances Ord
08:25:11 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:25:18 <Botje> String = [Char]
08:25:36 <Botje> [a] is Ord of a is ord
08:25:44 <Botje> and since a = Char is Ord, it's okay
08:25:48 <dcoutts_> Armored_Azrael: what kind of applications do you have in mind? is this for a specific project?
08:25:49 <cjs> FordCortina: Typically, you'd pass in the function that deconstructs the data structure in the way you need.
08:25:51 <FordCortina> oh heck its worse than i thought,
08:26:10 <FordCortina> there's no common type for fst and snd is there?
08:26:21 <vixey> (a,a) -> a
08:27:16 <ziman> > compare () ()
08:27:17 <lambdabot>  EQ
08:27:26 <FordCortina> thanks vixey
08:27:35 <cjs> Actually, the "comparing" function might provide some insight.
08:27:38 <mar77a> are "-"s allowed in function names
08:27:46 <Botje> no
08:27:51 <mar77a> how about underscores
08:27:53 <Botje> yes
08:27:55 <mar77a> k
08:28:06 <Botje> I generally use camelCase for functions and names_with_underscores for variabels
08:28:06 <smg> Botje: how would you do it?
08:28:09 <ziman> mar77a, however, haskell functions usually use camelCase
08:28:18 <mar77a> right
08:28:20 <Botje> smg: it's all correct, but that one line is just nonsense
08:28:45 <cjs> What's the difference between a function and a variable?
08:29:03 <vixey> none
08:29:15 <mar77a> what is the [] of Data.Map
08:29:16 <FordCortina> is there a way to say "opposite of fst" in haskell?
08:29:26 <FordCortina> im probably pushing my luck
08:29:29 <vixey> opposite doesn't really mean much
08:29:32 <int-e> FordCortina: what kind of opposite? 'snd'?
08:29:36 <mehrheit> mar77a, empty
08:29:36 <FordCortina> yeh
08:29:37 <Armored_Azrael> dcoutts_: This was the project :P. But the applications I had in mind are essentially rapid prototyping of analysis/correlation over data sets. You eliminate the data transfer so it goes faster, and the typed safety lets you write code more rapidly.
08:29:51 <cjs> A: Hey, what's that noise?
08:29:59 <cjs> B: Oh, it's just two functions having an argument.
08:30:10 <FordCortina> yes exactly what is "opposite"
08:30:18 <FordCortina> ?
08:30:24 <vixey> you said it
08:30:25 <vixey> a
08:30:48 <dcoutts_> Armored_Azrael: I worked with postgres a lot some years ago. I remember thinking wouldn't it be great to have haskell as a postgres embedded language. :-) Can it be used to define postgres functions that you can use in queries and stored procedures?
08:31:27 <Botje> FordCortina: opposite f (a,b) = f (b,a) -- :)
08:32:40 <int-e> FordCortina: it depends on the context. you used the word, you should know your context.
08:33:44 <FordCortina> int-e: yes your right. what i meant was that i know what i mean... but the computer doesnt ;)
08:37:25 <quicksilver> you could try to formalise opposite
08:37:26 <mar77a> gah i have no idea what i am doing when i work with...not lists
08:37:31 <quicksilver> using a type class.
08:37:31 <FordCortina> thanks Botje
08:37:39 <quicksilver> there might be a number of ways to do it
08:37:49 <quicksilver> if it does mean something, I'm sure you could work it out :)
08:37:54 <FordCortina> quicksilver yes it would be interesting
08:38:22 <mauke> @nixon
08:38:23 <lambdabot> I brought myself down. I impeached myself by resigning.
08:41:29 <PHO_> opposite fst = snd, opposite reverse = id, and opposite forkIO should be killThread
08:41:51 <sorear> @join ##php-quirk
08:43:28 <ndm> I have a GHC question :)
08:43:28 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:03 <ndm> runhaskell -cpp -package ghc Main.hs Foo.hs -B c:/ghc/ghc-6.8.2 --hoogle
08:44:20 <ndm> that's want i want to write, and have it run (its running haddock 2.0 from the darcs repo)O
08:44:36 <ndm> but i get the error: <interactive>:1:154:
08:44:40 <ndm>     attempting to use module `Main' (Main.hs) which is not loaded
08:44:42 <ndm> which makes me sad :(
08:44:46 <ndm> @messages
08:44:46 <lambdabot> Botje said 6d 21h 44m 12s ago: Can you give me a pong when you're here? I've got a question about uniplate.
08:44:57 <ndm> anyone any idea where it/I am going wrong?
08:46:13 <lumi> Hi, can someone help me with a typing question?
08:46:36 <mar77a> ask in #socrates
08:46:40 <mauke> dvorak
08:46:42 <Botje> lumi: go ahead
08:47:29 <Armored_Azrael> dcoutts_: Not in that way. Postgres doesn't allow for the handler to take over the job of CREATE FUNCTION, so I'd have to always compile the function if I made them postgres functions. If you want to just use them in queries though, the typed tables that it creates will do just fine as long as you keep the queries inside your module.
08:48:02 <lumi> Well, I'm trying to write a function  :: [(forall a. St -> Maybe a)] -> St -> IO ()
08:48:07 <Armored_Azrael> dcoutts_: If you want a quick look at what the usage would probably look vaguely like, check out MakeMod and ExecMod
08:48:14 <dcoutts_> Armored_Azrael: oh, CREATE FUNCTION has to use a compiled binary function? I thought one could use perl & python etc with CREATE FUNCTION.
08:48:29 <Armored_Azrael> No
08:48:35 <Armored_Azrael> CREATE FUNCTION can use non-binary
08:48:42 <Armored_Azrael> but it only stores the source if it uses non-binary
08:48:53 <Armored_Azrael> I need the bytecode
08:48:54 <lumi> Or so. But the type looks wrong to me, and I don't know how to fix it; ghci also thinks I'm wrong
08:49:12 <Armored_Azrael> Otherwise, you're going to be recompiling every module and function dependency every time you call something
08:49:18 <Armored_Azrael> Which is really annoying and slow
08:49:47 <dcoutts_> Armored_Azrael: ooh, I see.
08:49:57 <lumi> For IO () you can read Bool there
08:50:14 <dcoutts_> Armored_Azrael: seems like that's something we should ask the postgresql people for. Compiling to bytecode would help perl and python too.
08:50:41 <Armored_Azrael> True, though not nearly as much :P
08:50:57 <dcoutts_> true, but people like every bit of extra performance
08:51:14 <dcoutts_> though if they're using perl & python perhaps they do not care :-)
08:51:32 <Armored_Azrael> Esp. if they're using perl+python on the database
08:52:00 <lumi> I want to check a bunch of fields for some state St that they're all Just{}
08:53:34 <Armored_Azrael> To be fair, I didn't think this idea through very well. Third week of term we were supposed to have a project idea, so I came up with one. Then I did nearly no work until this last weekend, and then rushed really hard through it.
08:53:48 <Armored_Azrael> So it's probably got quite a few design flaws.
08:53:58 <Botje> lumi: all isJust $ fields ?
08:54:16 <Armored_Azrael> (by came up with one, I mean I remembered this about 30 minutes before one was due)
08:54:32 <lumi> Botje:
08:54:34 <lumi> Er,
08:54:42 <lumi> But the fields are of different types
08:54:49 <lumi> all isJust :: forall a. [Maybe a] -> Bool
08:54:52 <Botje> then how can they be in a list?
08:54:54 <lumi> The forall is scoped wrong
08:55:05 <lumi> That's what I'm asking :P
08:55:27 <lumi> Can I make the list forget the field type so they can all live together in harmony?
08:55:40 <dcoutts_> Armored_Azrael: so you've handed it in now then?
08:55:48 <Botje> uhh, you could try using Dynamic or HList ?
08:55:55 <Botje> that's all i know
08:56:18 <Botje> perhaps someone else can help you better :(
08:56:39 <Armored_Azrael> dcoutts_: No, I'm writing a slideshow. I present in 6 hours.
08:56:57 <dcoutts_> Armored_Azrael: good luck!
08:57:25 <lumi> Botje: Thanks :)
08:57:42 <lumi> It's just a little utility thing that I can do without, but I guess I'll give it a miss this time
08:57:45 <byorgey> lumi: lists in Haskell must be homogeneous, all the elements must have the same type.
08:58:05 <quicksilver> lumi: yes, you can use an existential.
08:58:10 <byorgey> lumi: if you want lists with elements of 'different' types you must use existential types, or something like HList
08:58:16 <quicksilver> lumi: for this particular example it would be totally pointless
08:58:40 <FordCortina> hmm backspace is not working for me in ghci?
08:58:47 <FordCortina> do i need some vt setting?
08:59:00 <lumi> quicksilver: Would I need to make a data type to carry the existential?
09:00:24 <sclv> lumi: you could do that, but if you're packing things in a list to only run one function they all have in common, the easier way to do it is just to run the function before you pack them in the list.
09:00:51 <PHO_> lumi: how about Dynamic?
09:00:55 <sclv> alternately you could use a printf type trick, but that's also more trouble than its worth.
09:00:59 <cnwdup> Can't I write to an Handle which is kept semi-closed by the call of hGetContents?
09:01:27 <lumi> Thank you all, I thought I could do this as a localized tiny hack, but I guess it wasn't to be :)
09:01:27 <sclv> Dynamic probably doesn't have enough power for this, although Generics would... but again... why.
09:02:51 <byorgey> cnwdup: probably not.
09:03:19 <cnwdup> byorgey: Ok. Then does getStrLn strip just \n from the read line or \r\n in whole?
09:04:19 <FordCortina> is it normal for backspace and delete not to work in ghci?
09:04:20 <byorgey> cnwdup: I'm not sure.
09:04:29 <byorgey> FordCortina: no, that's strange.
09:04:42 <lumi> sclv: Yes, it does come down to "why", and a minor improvement in readability in one place is not worth a lot of added unreadable mess elsewhere
09:04:42 <FordCortina> byorgey: it works fine in bash
09:04:48 <byorgey> FordCortina: have they worked before?
09:04:51 <quicksilver> symptom of broken term type or broken readline library.
09:04:54 <quicksilver> are on you OSX >
09:04:55 <quicksilver> ?
09:05:02 <lumi> FordCortina: I think it has to do with readline version
09:05:05 <FordCortina> quicksilver: im on debian
09:05:11 <quicksilver> then that's very odd.
09:05:17 <quicksilver> debian should have up to date and working readline
09:05:18 <Armored_Azrael> FordCortina: On debian there's an easy hack that fixes this for most programs
09:05:25 <Armored_Azrael> FordCortina: Install rlwrap
09:05:31 <lumi> FordCortina: Or "might have to do". Are you on a Mac?
09:05:35 <Armored_Azrael> FordCortina: then do rlwrap foo
09:05:38 <quicksilver> Igloo: aware of any ongoing ghci/readline issues on debian installs?
09:05:55 <Igloo> quicksilver: No
09:06:25 <smg> Botje: may you bother i you?
09:06:28 <quicksilver> Igloo: FordCortina reports delete/backspace working in bash but not in ghci.
09:06:38 <quicksilver> Which is odd because bash and ghci should both be using readline
09:06:47 <quicksilver> so everything should be the same.
09:07:10 <Igloo> FordCortina: Is this using the Debian ghc6 package?
09:07:17 <FordCortina> no
09:07:27 <Igloo> Do you have libreadline-dev installed?
09:07:31 <FordCortina> i used the binary of ghc 6.8.2
09:08:05 <FordCortina> and then recompiled ghc 6.8.2 with ghc 6.8.2 ( for the hell of it)
09:08:45 <FordCortina> i dont have readline-dev installed no
09:08:56 <Igloo> Sorry, I mean libreadline5-dev?
09:09:17 <FordCortina> actually, yes i have that
09:09:35 <FordCortina> libreadline5-dev
09:10:15 <FordCortina> ghci works fine in emacs
09:10:22 <quicksilver> emacs handles the term itself
09:10:27 <quicksilver> hiding it from ghci.
09:10:33 <Botje> smg: mmm?
09:10:44 <Armored_Azrael> FordCortina: Are you using a funny terminal emulator?
09:11:01 <Igloo> Do you still have the build tree? Does libraries/readline look like it built?
09:11:04 <FordCortina> im using gnome terminal, but the same thing happens at the console
09:11:24 <FordCortina> ill have a look for it
09:11:41 <PHO_> FordCortina: try ldd and see if libreadline is linked
09:13:04 <vixey> Botje: Do you have code online?
09:13:08 <FordCortina> ldd on ghci?
09:13:16 <FordCortina> ldd /usr/local/bin/ghci
09:13:32 <FordCortina> it says its not dynamic
09:13:39 <PHO_> yes. but ghci itself is a shell script, so you have to do something like
09:13:49 <PHO_> % ldd /usr/pkg/lib/ghc-6.6.1/ghc-6.6.1
09:13:50 <FordCortina> hmm looking at the build tree....
09:13:58 <Botje> vixey: vixey of my compiler?
09:14:04 <vixey> yeah
09:14:04 <Botje> s/vixey//
09:14:14 <vixey> or other stuff... I am bored
09:14:46 <FordCortina> i cant see any .o files in libraries/readline subdir
09:15:38 <Botje> vixey: i'm darcs pushing now, hang on
09:15:39 <FordCortina> PHO_: i dont have a /usr/pkg heirarchy
09:15:47 <FordCortina> PHO_: im on debian
09:17:01 <PHO_> FordCortina: you installed GHC into /usr/local? then
09:17:15 <PHO_> % ldd /usr/local/lib/ghc-*/ghc-*
09:17:51 <Botje> vixey: darcs get http://infogroep.be/~dharnie/milc
09:17:52 <lambdabot> Title: Index of /~dharnie/milc
09:18:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8264
09:18:39 <vixey> cool thanks
09:18:39 <quicksilver> FordCortina: don't compile your own ghc, would be my advice.
09:18:39 <quicksilver> FordCortina: use the debian packages. They work :)
09:18:39 <FordCortina> rl-wrap didnt seem to work
09:18:39 <Botje> it's a bit messy because i'm in full-on hacking mode
09:18:49 <vixey> good :p
09:19:04 <FordCortina> quicksilver: so long as you are happy with ghc 6.6
09:20:12 <FordCortina> ill try that PHO_
09:20:23 <FordCortina> yes it is in local
09:20:48 <quicksilver> there are debian pacakges of 6.8.x
09:21:22 <FordCortina> in unstable... I would have to backport and compile those wouldnt i?
09:21:50 <FordCortina> doesnt look like libreadline is linked
09:22:16 <quicksilver> either use unstable, or just try those source packages
09:22:22 <quicksilver> they are likely to work I guess
09:22:24 <quicksilver> not tried it.
09:22:33 <PHO_> FordCortina: try examining libraries/readline/config.log to see what happened on libreadline detection
09:23:29 <nolrai_> > let f = (\ (x, y) -> case x of 1 -> Just y) in (f (1,3), f (2,3))
09:23:31 <lambdabot>   Non-exhaustive patterns in case
09:23:35 <FordCortina> no config.log there :(
09:23:40 <FordCortina> looking in the root dir
09:24:19 <FordCortina> ive just been trying to recompile
09:24:28 <FordCortina> so things might have changed just now
09:24:32 <FordCortina> "configure:2827: checking whether ghc has readline package
09:24:32 <FordCortina> configure:2838: result: yes"
09:27:04 <FordCortina> im recompiling now, if used ./configure --with-readline=yes
09:27:08 <FordCortina> ive*
09:27:40 <vixey> :t count
09:27:41 <lambdabot> Not in scope: `count'
09:27:53 <hircus> @faq
09:27:55 <lambdabot> The answer is: Yes! Haskell can do that.
09:29:14 <vixey> mm this is awesome
09:29:17 <vixey> cpsOptimize :: CPS -> CPS
09:29:17 <vixey> cpsOptimize = execState (replicateM 10 optimizations)
09:29:17 <vixey>   where optimizations = sequence [flatten, cfold, cse, deadVar, inlineSmall]
09:29:25 <PHO_> FordCortina: I guess that would be the best way to try. Good luck :)
09:29:36 <FordCortina> thanks :)
09:30:51 <PHO_> ?faq Can Haskell compute the sum of all natural numbers in a finite time?
09:30:51 <lambdabot> The answer is: Yes! Haskell can do that.
09:31:19 <PHO_> I thought you'd say so lambdabot
09:31:22 <vixey> > sum . extendSequence [1,2,3,4,5,6,7,8]
09:31:22 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
09:31:28 <vixey> > sum . extendSequence $ [1,2,3,4,5,6,7,8]
09:31:29 <lambdabot>  3003
09:32:01 <PHO_> > sum [1..]
09:32:09 <lambdabot>  out of memory (requested 1048576 bytes)
09:32:13 <PHO_> lol
09:32:15 <mauke> > sum [1..] :: Int
09:32:19 <lambdabot> Terminated
09:32:23 <PHO_> you said you can :)
09:32:37 <mauke> 1e42 years is a finite time
09:38:10 <PHO_> ?faq Can Haskell commit genocide against all operational languages (including Lisp) and build The Republic of Haskell?
09:38:11 <lambdabot> The answer is: Yes! Haskell can do that.
09:38:28 <pizza_> shouldn't the result simply be Infinity?
09:38:59 <PHO_> pizza_: ah, you're right
09:39:07 <vixey> no
09:39:09 <vixey> :t sum
09:39:11 <lambdabot> forall a. (Num a) => [a] -> a
09:39:13 <Tigran`> @src IO fmap
09:39:13 <lambdabot> fmap f x = x >>= (return . f)
09:39:28 <mm_freak> x >>= f = join (fmap f x)  -- is this always correct?
09:39:52 <byorgey> mm_freak: it should be
09:40:05 <mauke> mm_freak: yes, unless the programmer hates you
09:40:06 <byorgey> if the instances involved are 'well-behaved'
09:40:16 <mauke> join (liftM f x), on the other hand
09:40:35 <lilachaze> ?faq Can Haskell represent a function a -> Bool which returns True if reducing the argument to WHNF will terminate and returns False otherwise?
09:40:35 <lambdabot> The answer is: Yes! Haskell can do that.
09:40:52 <ddarius> @hoogle isBottom
09:40:53 <lambdabot> No matches found
09:41:03 <ddarius> :t Test.QuickCheck.Batch.isBottom
09:41:05 <lambdabot> forall a. a -> Bool
09:41:07 <geezusfreeek> not infinity
09:41:14 <mm_freak> byorgey, mauke: assuming that the type is a real functor
09:41:24 <geezusfreeek> Prelude> last [1..] :: Int
09:41:24 <geezusfreeek> 2147483647
09:41:42 <mauke> for a sane type, fmap == liftM
09:41:48 <mauke> @src liftM
09:41:48 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:41:51 <mauke> @src join
09:41:51 <lambdabot> join x =  x >>= id
09:41:52 <PHO_> > last [1..] :: Integer
09:41:56 <lambdabot> Terminated
09:42:02 <geezusfreeek> it takes a while
09:42:13 <geezusfreeek> especially with 64bit ghc
09:42:19 <geezusfreeek> i ran it on 32bit
09:42:34 <mauke> so we have join (liftM f x) = (x >>= return . f) >>= id
09:43:28 <geezusfreeek> and doing it for Integer shouldn't terminate AFAIK
09:43:59 <tobias_tud> is there a faster version of Data.Map? my program runs a few minutes and a function only querying values and inserting new values takes 30% of the time
09:44:50 <dcoutts_> tobias_tud: what type of keys are you using?
09:44:51 <PHO_> tobias_tud, If you use Int for key, you can use IntMap
09:45:58 <mrd> IntMaps are pretty nice if you can use em
09:46:08 <elvengirl> Hi all, I'm not a programmer but I'm trying to learn Haskell. I'm reading this tutorial (http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics), but I can't do the exercises. I don't understood some basic concepts and the application of some commands. Somebody knows another tutorial that can I study?
09:46:08 <tobias_tud> i use an own data type. but im using much strings
09:46:09 <PHO_> @hoogle EdisonCore
09:46:09 <lambdabot> No matches found
09:46:25 <mauke> elvengirl: I don't know tutorials but I can answer concrete questions
09:46:36 <dcoutts_> tobias_tud: if you have to use Ord then Data.Map is about as fast as it gets. So either improve your Ord instance to do less work or use another type to identify your values.
09:46:40 <tobias_tud> i'd like to assign each Formula a unique int, and each unique int a formula
09:46:54 <mauke> BiMap?
09:47:02 <PHO_> tobias_tud, IFAIR EdisonCore has a suffix tree. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore
09:47:05 <lambdabot> http://tinyurl.com/3bnhme
09:47:26 <dcoutts_> tobias_tud: eg if you're using String as the key type then some kind of trie might be faster, or for Int there's IntMap or a generlaised trie that follows the structure of your type.
09:47:52 <tobias_tud> okay, thank you very much :-). i'll try it
09:47:54 <dcoutts_> tobias_tud: so if you give each a unique int then IntMap is a good choice.
09:48:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8265
09:48:54 <dcoutts_> tobias_tud: though it'll still be difficult/slow to map from formula to id, but id to formula can be quick.
09:49:20 <FordCortina> backspace and delete fixed ! :)
09:49:22 <FordCortina> thanks all
09:49:30 <elvengirl> mauke: Thanks. For exemple, I didn't understand what map do and when I can use it.
09:50:10 <mauke> map f [x1, x2, x3] == [f x1, f x2, f x3]
09:50:14 <tobias_tud> yes, from id to formula is really quick, because i only query only once each id
09:50:24 <mauke> you use it when you want to apply a function to each element in a list
09:50:37 <mauke> and get a list of the results
09:50:39 <smg> btw is there something for type checking/unification on the web related to haskell?
09:51:03 <Philippa_> @go Typing Haskell In Haskell
09:51:04 <lambdabot> http://citeseer.ist.psu.edu/424440.html
09:51:04 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
09:51:10 <elvengirl> to each element.... ok
09:52:22 <mauke> > 2 * 5
09:52:22 <lambdabot>  10
09:52:22 <mauke> > map (2 *) [5, 6, 10, 42]
09:52:22 <lambdabot>  [10,12,20,84]
09:52:23 <elvengirl> =)
09:52:23 <maltem> elvengirl, also called pointwise
09:52:55 <yav> does anyone know of a haskell library that can deal with the cpio format?
09:53:07 <thetallguy> dcoutts_: you rang?
09:53:45 <maltem> (that is, "pointwise" is another wording for "to each element")
09:56:00 <elvengirl> (thank you for this question...)
09:56:00 <mauke> > map odd [1 .. 4]
09:56:00 <lambdabot>  [True,False,True,False]
09:56:00 <tobias_tud> hm, is there perhaps a good datastructure for querying key and value and not just key?
09:56:00 <PHO_> yav, hackageDB doesn't seem to have anything like that
09:56:01 <vixey> two maps
09:56:01 <tobias_tud> hehe
09:56:01 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
09:56:01 <elvengirl> I don't know what is odd. =P
09:56:01 <mauke> 'odd' checks whether a number is odd
09:56:01 <tobias_tud> ah, thank you. forgot it
09:56:01 <mauke> where "odd" = not divisible by 2
09:56:01 <byorgey> > odd 2
09:56:01 <lambdabot>  False
09:56:03 <Philippa_> elvengirl: map isn't a "built in command" or anything like that, by the way. It's just a name for an ordinary function much as you can define yourself
09:56:05 <PHO_> bimap! didn't know such library was present
09:56:05 <byorgey> > odd 3
09:56:05 <vixey> elvengirl: any number 2*k+1 where k is natural
09:56:06 <lambdabot>  True
09:56:28 <Philippa_> there are a few built-in things - let, case, do, where - but not many
09:56:51 <Philippa_> otherwise, functions are functions and all work the same. It's a pretty consistent language
09:57:08 <elvengirl> ok
09:57:19 <yav> googling found an IRC snipplet where someone mentions haskelkl bindings to libarchive...
10:00:04 * PHO_ is going to sleep
10:10:56 <elvengirl> Is there a list of functions?
10:12:21 <mauke> of all functions ever?
10:12:21 <mauke> that would be hueg
10:12:21 <philipp_> does cabal allow non-systemwide registrations? i.e. http://paste.debian.net/6143/
10:12:21 <mauke> configure with --user
10:12:21 <cjb> elvengirl: http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html has the basics.
10:12:21 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
10:12:25 <elvengirl> thanks
12:21:39 --- topic: '["Read my lips: no more side effects!", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ "]'
12:21:39 --- topic: set by dons on [Wed Jun 04 11:14:29 2008]
12:21:45 <FordCortina> mauke: i must have written it down wrong then....
12:21:49 <tchakkazulu> ?type uncurry h . (g *** f) $ (x,y)
12:21:51 <lambdabot>     Ambiguous type variable `c' in the constraints:
12:21:51 <lambdabot>       `SimpleReflect.FromExpr c'
12:21:51 <lambdabot>         arising from a use of `g' at <interactive>:1:13
12:21:53 <int-e> mercury^: the conceptual flaw (besides the syntactical) is that dividing 10^6*n by maxBound :: Int will produce the same overflow that we're trying to avoid
12:22:08 <tchakkazulu> ?type \f g h x y -> uncurry h . (g *** f) $ (x,y)
12:22:09 <lambdabot> forall c b c1 b' c'. (b' -> c') -> (b -> c1) -> (c1 -> c' -> c) -> b -> b' -> c
12:22:35 <tchakkazulu> Hrm. Not really :-/
12:22:43 <mauke> why not?
12:22:50 <tchakkazulu> Still the lambda.
12:23:05 <tchakkazulu> Though the function is correct if you unify b' and c'; and b and c1.
12:23:16 <mercury^> int-e: that could be fixed with a fromEnum though I think
12:23:50 <mauke> :t \f g h -> (uncurry h . (g *** f) .) . (,)
12:23:51 <lambdabot>     The operator `.' [infixr 9] of a section
12:23:51 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
12:23:51 <lambdabot>         in the section: `(uncurry h . (g *** f) .)'
12:24:03 <mauke> :t \f g h -> ((uncurry h . (g *** f)) .) . (,)
12:24:05 <lambdabot> forall c c1 c' a b. (b -> c') -> (a -> c1) -> (c1 -> c' -> c) -> a -> b -> c
12:24:20 <int-e> mercury^: also, threadDelay maxBound  is too long. try  sleep n = replicateM_ (n `quot` chunk) (threadDelay (10^6 * chunk)) >> threadDelay ((n `rem` chunk) * 10^6) where chunk :: Int; chunk = maxBound `quot` 10^6
12:24:26 <FordCortina> mauke: if f, g and h are already defined then it would look like this \ x y -> h (f x) (g x)
12:24:44 <mauke> FordCortina: ?
12:24:53 <mauke> why are you telling me this?
12:24:55 <int-e> mercury^: err, no, it's not too long, sorry.
12:25:09 <FordCortina> mauke: ah maybe you weret talking to me
12:25:16 <FordCortina> ...
12:25:17 <FordCortina> sry
12:25:50 <FordCortina> mauke said: " I can simplify if g = f or x = y "
12:25:56 <mauke> yes
12:26:05 <byorgey> anyone know if there's a way to get more than just the most recent 20 items in an RSS feed from Planet Haskell?
12:26:05 <int-e> mercury^: but you'd need something like  fromInteger (quot (toInteger n * 10^6) (toInteger (maxBound::Int)))
12:26:40 <mercury^> yes, I only intended to make the idea clear with my snippet, not to provide something that actually compiles and works
12:27:13 <mauke> \x y -> h (f x) (f y) can be written as h `on` f
12:27:17 <FordCortina> tchakkazulu: thanks for your help
12:27:24 <mauke> \x y -> h (f x) (g x) can be written as liftM2 h f g
12:27:41 <mauke> but I don't know a compact simplification of the general version
12:28:37 <FordCortina> mauke: i though of liftM2 actually because f and g have different return types (i think anyway)
12:28:46 <FordCortina> oops
12:29:24 <FordCortina> i thought of liftM2 actually (but it didnt work)* because f and g have different return types (i think anyway)
12:30:27 <dolio> @type \f g h -> curry $ g *** f >>> uncurry h
12:30:29 <lambdabot> forall a b c c' c1. (b -> c') -> (a -> c) -> (c -> c' -> c1) -> a -> b -> c1
12:31:35 <FordCortina> it works in the general case tho :S
12:32:04 <roconnor> @pl \f g h -> curry $ g *** f >>> uncurry h
12:32:05 <lambdabot> ((curry .) .) . flip flip uncurry . (((.) . (>>>)) .) . flip (***)
12:32:42 <FordCortina> @type liftM2 (\x y -> x) (\x -> x) (\y -> y)
12:32:43 <lambdabot> forall a1. a1 -> a1
12:33:30 <FordCortina> @type liftM2 (\x y -> x) ((\x -> x) :: a -> Bool) (\y -> y)
12:33:32 <lambdabot>     Couldn't match expected type `Bool' against inferred type `a'
12:33:32 <lambdabot>       `a' is a rigid type variable bound by
12:33:32 <lambdabot>           the polymorphic type `forall a. a -> Bool' at <interactive>:1:20
12:33:44 <FordCortina> @type liftM2 (\x y -> x) ((\x -> x) :: Bool -> Bool) (\y -> y)
12:33:46 <lambdabot> Bool -> Bool
12:34:06 <FordCortina> @type liftM2 (\x y -> x) ((\x -> x) :: Bool -> Bool) ((\y -> y) :: Int -> Int)
12:34:07 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Int'
12:34:07 <lambdabot>       Expected type: Bool -> a2
12:34:07 <lambdabot>       Inferred type: Int -> Int
12:34:40 <FordCortina> @type liftM2 (\x y -> x) ((\x -> x) :: Bool -> Bool) ((\y -> y) :: Bool -> Bool)
12:34:46 <lambdabot> Bool -> Bool
12:35:04 <FordCortina> the types make a difference
12:35:22 <FordCortina> evil lambdas it is then.... :S
12:35:40 <bsdemon> hello, what about Dijkstra's algotithm for type Graph = (Int, Int -> Int -> Boolean), where first - number of vertices, second - mapping, which returns True if vertices are connected?
12:36:04 <FordCortina> roconnor: thanks for the example with arrows
12:36:40 <FordCortina> :S
12:39:33 <roconnor> @unpl \f g h -> curry $ g *** f >>> uncurry h
12:39:33 <lambdabot> \ f g h -> (curry (g *** f)) >>> (uncurry h)
12:40:07 <mauke> @unpl 1 + 2 * 3
12:40:07 <lambdabot> (1 + (2 * 3))
12:40:14 <mauke> yay, deparse
12:40:57 <roconnor> parsing / unparsing is an adjuctions?
12:45:52 <byorgey> bsdemon: what about it?
12:47:18 <bsdemon> byorgey: the main problem is to store path
12:47:42 <bsdemon> maybe my representation graph is incorrect for this algorithm?
12:48:19 <dpiponi> How do I deal with this: "Setup.lhs: category-extras.cabal:35: Parse of field 'extensions' failed." I'm not very good with cabal.
12:48:53 <byorgey> well, that representation is isomorphic to an adjacency matrix, should be fine
12:49:08 <byorgey> dpiponi: what version of Cabal do you have?
12:49:15 <int-e> dpiponi: install a newer cabal, I guess
12:49:18 <byorgey> IIRC, category-extras requires Cabal-1.4
12:50:28 <int-e> which menas that the   cabal-version:          >= 1.2   in its cabal file is wrong
12:51:56 <dpiponi> I'll try a newer cabal then.
12:52:47 <bsdemon> byorgey: thanks!
12:53:05 <byorgey> hm, I can't find anything that says Cabal-1.4, maybe I was thinking of something else
12:53:13 <byorgey> but still, a newer Cabal might be the solution
12:57:09 <FordCortina> @pl \f g x -> (g x) . (f x)
12:57:09 <lambdabot> flip (liftM2 (.))
12:57:35 <mm_freak> what's the best way to write auxilliary functions for an instance?
12:58:00 <mm_freak> they should only be visible to the instance
12:58:59 <lumi> mm_freak: Write the instance in its own module?
12:59:13 <dpiponi> Looks like the >=1.2 was wrong as a newer version builds category-extras fine. Thanks.
12:59:16 <mm_freak> lumi: that's what i'm trying to prevent
13:00:22 <lumi> mm_freak: If you need the function for more than one of the instance functions, I can't think of another way
13:08:25 <mm_freak> wb people
13:08:29 <mm_freak> i missed you =)
13:09:16 <roconnor> I wonder if I should use an infix triangle (a ◁ l) instead of (cons a l) in my paper
13:09:38 <Cale> roconnor: yes :)
13:10:08 * byorgey agrees
13:10:12 <Cale> roconnor: well, it worked out okay for the finger trees paper anyway :)
13:10:40 <dolio> I'd go for the triangle.
13:10:58 <monochrom> Infix nice.
13:11:44 <augur> X_X
13:11:48 <augur> so many netsplits :(
13:12:09 <monochrom> Even for "if b then p else q", Hoare writes p◁b▷q and I find it ingenious.
13:12:41 <augur> p if b otherwise q? :P
13:13:39 <dolio> Too Python.
13:13:52 <monochrom> There is no reason to hack an English phrase to match notation to the point of preserving operand order.
13:13:57 <mauke> $p if $b or ($q, undef);
13:14:12 <roconnor> I'm using l ▷ a ◁ r for binary trees in my other paper
13:15:00 <mauke> well, technically p() if b() or do { q_(); undef };
13:15:00 <monochrom> The point of notation is to liberate from natural language, to gain another perspective.
13:16:00 <marcot> What's the priority of ``?
13:16:05 <marcot> is it infixr or infixl?
13:16:09 <mauke> none
13:16:15 <mauke> `` doesn't exist
13:16:26 <roconnor> I think he means `foo`.
13:16:29 <marcot> I mean functions with ``.
13:16:32 <marcot> like `mod`
13:16:33 <Deewiant> > id `id` 1 `id` 2
13:16:34 <lambdabot>   add an instance declaration for (Num (t -> a))
13:16:36 <marcot> or `cons`
13:16:36 <mauke> that depends on the priority of `foo`
13:16:38 <Deewiant> oops
13:16:42 <Deewiant> > id `id` id `id` 2
13:16:44 <lambdabot>  2
13:16:45 <mauke> like any operator
13:16:57 <roconnor> mauke: when you don't give it an explicit priority
13:17:10 <mauke> yes
13:17:28 <marcot> you can set the priority of a functions and if it's infixr or infixl?
13:17:38 <dolio> infixl 9 by default?
13:17:41 <dolio> Something like that.
13:18:28 <marcot> > 5 `(-)` 1 `(-)` 2
13:18:28 <lambdabot>  Parse error at "(-)`" (column 4)
13:18:34 <dons> lambdabot: @join #arch-haskell
13:18:38 <dolio> > let cons = (:) in 1 `cons` 2 `cons` []
13:18:39 <lambdabot>   add an instance declaration for (Num [t])
13:18:48 <mauke> marcot: good thinking, but `...` is limited to words
13:18:49 <dons> Cale: can you add #arch-haskell to the default config?
13:19:02 <roconnor> hmm
13:19:08 <roconnor> I only use cons in one place
13:19:13 <dolio> > let cons = (:) in 1 : 2 `cons` []
13:19:15 <lambdabot>  [1,2]
13:19:16 <roconnor> maybe I'll keep it as cons then.
13:19:37 <marcot> > 10 `mod` 6 `mod` 3
13:19:38 <lambdabot>  1
13:19:57 <Deewiant> I think mod and div have explicit infixities
13:20:03 <dolio> It's definitely infixl by default.
13:20:04 <marcot> infixl then.
13:20:26 <dolio> Not sure about the precedence.
13:20:44 <marcot> let minus = (-) in 5 `minus` 1 `minus` 2
13:20:53 <marcot> > ﻿let minus = (-) in 5 `minus` 1 `minus` 2
13:20:53 <lambdabot>  Illegal character ''\187''
13:20:53 <lambdabot>  at "let" (column 2)
13:20:56 <dolio> It's high, though, so I'll guess 9 (which is the max, I think?).
13:21:10 <roconnor> > let foo = const $ const 0 in 1 `foo` 2 `foo` 3
13:21:11 <lambdabot>  0
13:21:26 <roconnor> > let minus = (-) in 5 `minus` 1 `minus` 2
13:21:27 <lambdabot>  2
13:21:36 <marcot> What was wrong with mine?
13:22:03 <roconnor> marcot: you put character 187 before your let
13:22:09 <mauke> marcot: you used a ZERO WIDTH NO-BREAK SPACE
13:22:17 <mauke> that's character 0xfeff
13:22:21 <tusho> > cons 1 2
13:22:21 <lambdabot>   Not in scope: `cons'
13:22:28 <marcot> I don't know how I did this.
13:23:00 <marcot> maybe copying my other line in pidgin caused this.
13:23:14 <Cale> dons: done
13:23:43 <mauke> what privileged commands does lambdabot have?
13:23:56 <marcot> Gotta go. Bye. =)
13:24:43 <monochrom> Next, someone will write haskell code in MSWord and wonder why it causes parse errors.
13:24:53 <orbitz> haha
13:25:04 <orbitz> sadly i've seen many peopel save their C program as a .doc
13:25:16 <mauke> "but I did the colors and all!"
13:25:36 <orbitz> "word has syntax highlighting, see i can make 'for' green"
13:25:54 <mauke> @vixen how do I culted cargo?
13:25:54 <lambdabot> however you want
13:26:15 <dons> Cale++
13:26:28 <dons> dcoutts: so you are suggesting not using
13:26:29 <dons>   runhaskell Setup.lhs register --gen-script
13:26:29 <dons>   runhaskell Setup.lhs unregister --gen-script
13:26:39 <dons> as the main way to create package registration hooks?
13:28:33 <mar77a> ?karma
13:28:33 <lambdabot> You have a karma of 0
13:28:37 <mar77a> ?karma johnny
13:28:38 <lambdabot> johnny has a karma of 0
13:28:42 <mar77a> ?karma dons
13:28:42 <lambdabot> dons has a karma of 142
13:28:44 <dolio> dons: I've got a fannkuch implementation using uvectors that's a couple seconds slower (on my machine) than the one on the shootout.
13:28:48 <mar77a> !
13:28:53 <dons> dolio: oh great!
13:28:57 <dons> we sould be able to tune it from there.
13:29:02 <dolio> dons: My STUArray version is significantly slower than uvector, though.
13:29:03 <dons> dolio: i started on an STUArray version
13:29:16 <dons> dolio: we should be able to get identical, or better results, imo
13:29:18 <mauke> preflex: karma dons
13:29:18 <preflex>  karma for dons: 3
13:29:20 <dolio> I'm not exactly sure why. Less inlining?
13:29:31 <dons> there's nothing fundamental about the problem that we should be identical to C, with ST arrays
13:29:44 <dons> dolio: how about we start a shootout repo somewhere?
13:29:48 <dons> i've lots of drafts for most problems
13:29:53 <dons> but it makes sense to collaborate
13:30:01 <dons> at least, post your ST fannkuch and i'll have a poke around
13:30:28 <dolio> Well, let me translate the uvector one back to ST. I refactored it a bit to be less hideous.
13:30:46 <dons> make sure you keep the old versions around
13:39:32 <mauke> @msg #haskell success
13:39:32 <lambdabot> success
13:40:09 <mauke> somehow this seems like a security hole
13:41:04 <orbitz> @msg mauke it's not
13:41:04 <lambdabot> Not enough privileges
13:41:33 <mauke> you don't have admin privileges on lambdabot
13:41:51 <orbitz> see, no hole!
13:42:05 <mauke> me neither
13:42:12 <mauke> I haxed it
13:42:53 <roconnor> @add-admin roconnor
13:42:53 <lambdabot> Unknown command, try @list
13:45:04 <dolio> dons: http://hpaste.org/8271
13:45:08 <vincenz> @hoogle hex
13:45:09 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
13:45:09 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
13:45:09 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
13:45:34 <dolio> That takes around 16 seconds on my machine, and the uvector version takes around 12.
13:48:17 <dolio> Current shootout entry takes about 10.
13:48:52 <byorgey> hmm, how do I create an account on sequence.complete.org?
13:49:27 <byorgey> there doesn't seem to be a link anywhere
13:49:34 <byorgey> dons? CosmicRay?
13:50:04 <CosmicRay> yes?
13:50:15 * CosmicRay looks
13:50:31 <CosmicRay> oh right, I think I have to set these up because ospammers were adding them
13:50:37 <CosmicRay> I should talk to the people at pdx about that
13:51:00 <byorgey> ah, I see
13:51:10 <byorgey> well, could you be so kind as to create an account for me?
13:51:15 <CosmicRay> yes
13:51:16 <byorgey> I have an issue of the HWN to upload =)
13:51:23 <CosmicRay> msg me your preferred username and email address
13:51:32 <byorgey> ok
13:54:37 <dons> dolio: -funbox-strict-fields?
13:55:19 <philipp_> is there some other plotting library other than Chart?
13:55:30 <dons> dolio: ok, i'll have a look. that's pretty much what I was going to do too
13:55:33 <dolio> Doesn't make a difference.
13:55:43 <dons> dolio: i'll dive into the core
13:56:02 <dons> byorgey: exciting.
13:56:59 <byorgey> dons: =)
13:59:42 <dolio> dons: Good luck. It gets inlined into a single function. :)
14:00:09 <dons> dolio: yeah, i see.
14:00:28 <dons> i'll just comment back in functions one by one, cross checking against the C veriosn
14:00:32 <dons> and the clean one.
14:00:44 <dons> i know we can nail this benchmark. arrays are easy
14:01:45 <mauke> btw, what happened in http://shootout.alioth.debian.org/debian/benchmark.php?test=threadring&lang=all ?
14:01:46 <lambdabot> Title: thread-ring benchmark | Debian : AMD&#8482; Sempron&#8482; Computer Language Ben ..., http://tinyurl.com/5nmnqh
14:02:01 <mauke> I thought custom schedulers were disallowed
14:05:11 <dons> mauke: oh, for the java one?
14:05:26 <mauke> yeah
14:05:32 <dons> looks dodgy, yeah
14:05:38 <dolio> Just wait until they get their multiprocessor box up.
14:05:51 <dons> the erlang ones seem to have got faster too
14:06:01 <dons> we might want to look at why
14:06:26 <sjanssen> whoa, how is Erlang beating us now?
14:06:37 <dons> yeah. looks like it.
14:07:06 <kscaldef> probably upgraded to a more recent release of Erlang
14:07:07 <sjanssen> the Java entry is definitely cheating
14:07:14 <dons> yeah, that's possible, kscaldef
14:07:30 <sjanssen> kscaldef: the new version more than halved the run time?
14:07:30 <dons> i'll ping isaac about the gcj one
14:07:40 <kscaldef> they were a bit out of date the last time I looked at that benchmark
14:07:58 <sjanssen> doesn't look like any trickery is used
14:08:17 <dons> is it the same implementation as before?
14:09:19 <kscaldef> hmm... maybe I'm dumb but I can't actually figure our what erlang version they are running
14:09:31 <dons> "cooperative threads… and
14:09:31 <dons> other programs with custom schedulers will be listed as interesting
14:09:33 <dons> alternative implementations. "
14:09:44 <dons> looks like the java one falls directly out under that.
14:09:58 <dons> i mailed isaac .
14:10:55 <dolio> That gcj entry is identical to the alternative Java6 -server entry.
14:11:00 <dolio> Except it runs way, way, slower.
14:11:04 <dolio> (gcj, that is).
14:11:33 <dolio> Well, perhaps not way, way.
14:11:52 <Saizan_> is it me or java uses only one thread there?
14:12:11 <kscaldef> the erlang entry is the same as it's always been
14:12:12 <dolio> Yeah, it won't take advantage of multiple processors.
14:12:19 <dons> byorgey++
14:12:21 <dons> HWN!!
14:12:31 <byorgey> =D
14:12:46 <kscaldef> dolio: I don't think multiple processors is going to help anyone on that benchmark
14:12:55 <dons> byorgey: so you should put the sequence.haskell.org link on reddit now, with a nice title
14:13:01 <dons> i think i have suggested titles in the README
14:13:06 <dons> along with mailling the linux journal
14:13:06 <dons> gusy
14:13:33 <RayNbow> [ http://channel9.msdn.com/posts/Dan/C9-Bytes-Stephen-Toub-demos-Ray-Tracing-with-Parallel-Fx/ ] "Stephen Toub, a Program Manager on the Parallel Fx team, demos how to get 400+% performance increase in a CPU intensive Ray Tracing program by switching one line of code from a regular for loop to using the Parallel.For command." <-- I wish I got this kind of speedup when I was programming something in High Performance Fortran :p
14:13:42 <lambdabot> http://tinyurl.com/6p6ors
14:13:48 <byorgey> dons: it would probably be better to wait for next week for that.
14:14:01 <byorgey> this one is kind of just a dump of as much stuff as I could gather.
14:14:26 <dolio> kscaldef: You couldn't pass N tokens at once?
14:14:37 <byorgey> but you can post it to reddit if you like, I personally don't care all that much about reddit ;)
14:14:50 <kscaldef> I think that would be considered cheating
14:15:10 <dolio> I mean if threads were running on multiple processors.
14:15:23 <kscaldef> "pass a token between one thread and the next thread"
14:15:33 <dons> byorgey: yep, sure.
14:15:40 <kscaldef> the rules imply a single token to me
14:16:01 <byorgey> dons: so just to be clear, the stuff in the README about uploading to 'News' on the wiki can be ignored, right?
14:16:08 <dons> yep.
14:16:15 <dons> that's now automated. we use hackage
14:16:19 <byorgey> right, cool
14:17:05 <byorgey> dons: and what is the generated pdf for?
14:17:27 <dons> at chalmers bringert prints it out and puts it outside his office
14:17:38 <byorgey> oh, I see =)
14:17:54 <opqdonut> what do you guys use to syntax-hl haskell in your blogs?
14:17:59 <dons> HsColour
14:18:05 <opqdonut> ah
14:18:11 <dolio> kscaldef: Hmm, I guess you're right, looking at the implementations.
14:18:23 <mar77a> need help with this thingo:
14:18:23 <mar77a> logSplit logName = logSplit $ (tail . lines) raw
14:18:24 <mar77a>     where raw <- readFile logName
14:18:43 <mauke> <- can't be used outside of do
14:19:02 <Botje> .oO(do notation considered harmful)
14:19:12 <mar77a> er so how do i go around this?
14:19:24 <mauke> that's infinite recursion anyway
14:19:38 <mauke> logSplit = logSplit
14:19:39 <mar77a> oh yeah forgot something
14:19:49 <mar77a> 2nd one is actually logSplit'
14:20:11 <Botje> mar77a: logSplit' . tail . lines `liftM` readFile logName
14:20:20 <mar77a> liftM?
14:20:20 <mauke> logSplit logName = logSplit' . drop 1 . lines =<< readFile logName
14:20:36 <mauke> fmap
14:20:43 <Botje> mar77a: well, it depends on the type of logSplit', really
14:20:52 <Botje> if logSplit returns IO a, you need mauke's version
14:21:00 <kscaldef> mar77a: liftM lifts a pure function into a monad
14:21:00 <Botje> if it returns a, you can use mine
14:21:25 <dolio> GHC still beats Erlang on the Pentium 4 benchmarks, apparently.
14:21:27 <mar77a> http://hpaste.org/8272
14:21:34 <dolio> And Erlang beats Erlang HiPE there.
14:22:28 <mauke> ok, then `liftM` instead of =<<
14:22:38 <mauke> and logSp should be bound with <-, not let
14:24:13 <mar77a> where is liftM defined?
14:24:26 <dons> Control.Monad
14:24:32 <dons> ?hoogle liftM
14:24:32 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:24:32 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:24:32 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:24:34 <dons> ?src liftM
14:24:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:25:03 <Apocalisp> Does Haskell have an equivalent to Scala's/Erlang's threadless actors?
14:25:10 <mar77a> if only i understood monads
14:25:28 <Apocalisp> mar77a: You too can understand monads.
14:25:31 <mauke> you don't need to understand monads, only IO's >>=
14:25:33 <mauke> and return
14:26:03 <mauke> here's an incomplete introduction: http://mauke.ath.cx/stuff/haskell/how-to-io.html
14:26:05 <lambdabot> Title: Haskell: How To IO
14:27:00 <Apocalisp> mar77a: Which languages have you used before?
14:27:00 <mar77a> logSplit logName = logSplit' $ (tail . lines) `liftM` readFile logName is giving me some error
14:27:03 <dolio> dons: Incidentally, that ScopedTypeVariables and the 'forall s.' in the type of fannkuch is unnecessary now. It's a relic from when I had it written a different way.
14:27:25 <mar77a> Apocalisp c, c++, php, ruby
14:27:44 <kscaldef> mar77a: you can also stay pretty close to what you had before, just add a "do"
14:28:05 <kscaldef> logSplit logname = do raw <- readFile logName
14:28:14 <kscaldef>   logSplit' $ (tail . lines) raw
14:28:26 <mauke> mar77a: yeah, because you added the $
14:28:39 <mar77a> i added the wha
14:29:24 <Saizan_> Apocalisp: forkIO spawns a userland thread that gets mapped to an available OS thread by the RTS, so they are very cheap, but there's no library for the actor model
14:32:02 <quicksilver> byorgey++ # HWN
14:32:10 <quicksilver> byorgey++ # that's got to be worth at least 2.
14:32:19 <byorgey> hehe, thanks =)
14:32:27 <mar77a> BAH
14:32:32 <mar77a> logSplit logName = do
14:32:32 <mar77a>     raw <- readFile logName
14:32:32 <mar77a>     logSplit' $ (tail . lines) raw
14:32:35 <mar77a> doesn't work either
14:32:41 <monochrom> Eh? Haskell Seaonal News is back!  <duck>
14:32:46 <mauke> missing return
14:32:50 <monochrom> byorgey++
14:33:01 <mar77a> return?
14:33:02 <mar77a> where?
14:33:03 <mauke> return . logSplit' . tail . lines $ raw
14:33:42 <mar77a> no :(
14:33:45 <Apocalisp> Saizan: I'm not convinced that the actor model is the way to go, but it seems like a good idea to be able to suspend with "once this expression obtains a value, call me", rather than "wait for this expression to obtain a value"
14:34:18 <Apocalisp> Am I imagining things? Are threads cheap enough to have millions of them sitting around idle?
14:34:41 <dons> Apocalisp: 100s of thousands, anyway, yes.
14:34:42 <mauke> YES
14:34:43 <dons> they're cheap
14:34:46 <mauke> haskell threads certainly are very cheap
14:34:56 <dons> write a test program :)
14:35:08 <mauke> http://mauke.ath.cx/stuff/haskell/stress.hs
14:35:09 <mar77a> now i can't print the list argh
14:35:16 <mauke> mar77a: you don't have a list
14:35:28 <mar77a> what do i have
14:35:35 <mar77a> i want a list to be returned
14:35:43 <mauke> an action that when executed will return a list
14:35:51 <mauke> at least that's what you get with 'let'
14:36:19 <mar77a> doesn't make sense
14:36:21 <mar77a> well it does
14:36:32 <mar77a> but why do i have to use the <- instead of let and =
14:36:50 <Apocalisp> I wonder what it is about JVM threads that necessitates Scala having a library around threadless concurrency.
14:36:52 <mauke> because <- actually executes the action
14:36:52 <mauke> (not true)
14:36:53 <quicksilver> <- is to unwrap something from a monad
14:37:07 <quicksilver> = is just giving a new name to an expression
14:37:24 <mauke> <- transports you into a hypothetical future where the action has been executed
14:37:35 <mar77a> why does the function return an action which needs to be 'executed'
14:37:42 <mar77a> and not the actual result of executing it
14:37:45 <mauke> because that's how haskell does side effects
14:37:59 <mauke> did http://mauke.ath.cx/stuff/haskell/how-to-io.html get through?
14:38:14 <lambdabot> Title: Haskell: How To IO
14:38:14 <mar77a> nope
14:38:15 <monochrom> Apocalisp: Many OSes probably don't run hundreds of threads very well.
14:38:44 <mauke> lambdabot can access it
14:38:57 <mar77a> well i have to click it first
14:38:59 <mar77a> x)
14:39:33 <MyCatVerbs> monochrom: -no- OSes run hundreds of threads very well.
14:39:41 <MyCatVerbs> monochrom: well, hundreds might be doable. Thousands is pushing it.
14:39:57 <MyCatVerbs> monochrom: hence, n:m green threading for the win! ^^
14:39:59 <CosmicRay> mar77a: you may find the material on book.realworldhaskell.org/beta interesting, and if not, leave us a comment ;-)
14:40:10 <kscaldef> hundreds of mostly idle threads is no real problem at all
14:40:29 <monochrom> GHC RTS is an OS that runs hundreds of threads very well.  <duck>
14:40:53 <bos> MyCatVerbs: linux handles tens of thousands of threads just fine.
14:40:56 <mauke> no quack!
14:40:56 <kscaldef> my machine currently has 279 threads in 82 processes and is quite happy
14:40:56 <MyCatVerbs> kscaldef: thousands is nasty if you aren't using an O(1) scheduler, and not all multiuser OSes do.
14:41:20 <Apocalisp> It seems like this kind of thing should be taken care of by the OS / runtime at any rate.
14:41:36 <MyCatVerbs> bos: I'm pondering how to benchmark that to find out.
14:41:53 <monochrom> should be, yes. present state, no, so people have to work around, sadly.
14:42:05 <MyCatVerbs> bos: certainly on the language shootout, it's clear to see that all the languages with green threading totally blow pthreads away on the threading benchmark... artificial as it is.
14:42:22 <MyCatVerbs> monochrom: eh. Less of an OS, more of a partially-applied interpreter.
14:42:36 <bos> MyCatVerbs: you'd want to use clone directly, perhaps?
14:42:50 <monochrom> all programs "should" be proven both correct and efficient anyway.  <shrug> <duck> :)
14:44:32 <CosmicRay> mar77a: specifically, http://book.realworldhaskell.org/beta/io.html may be interesting
14:44:35 <lambdabot> Title: Chapter 9. I/O
14:46:48 <mar77a> thank you
14:46:55 <mar77a> i'll get back to you when i'm done reading
14:47:08 <CosmicRay> mar77a: I guess I should warn you that this is a shameless plug.
14:47:20 <mar77a> define:plug
14:47:34 <CosmicRay> mar77a: that's part of a book that I'm working on with bos and dons, and I wrote that particular chapter
14:47:48 <awesame> :t fmap
14:47:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:47:53 <CosmicRay> unless you hate it, in which case I'll blame it all on bos ;-)
14:47:56 <mar77a> :)
14:48:05 <awesame> why does hpaste.org say that hpaste has the same type as fmap?
14:48:27 * CosmicRay blinks.  hpaste has the same type as fmap?  what function is hpaste?
14:48:40 <mauke> @paste
14:48:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:48:45 <dons> i think hpaste is a histozygomonomorphism
14:48:52 <dons> it needs a more accurate type
14:48:55 <dolio> awesame: It doesn't. Hpaste works on fs that aren't functors.
14:48:57 <CosmicRay> heh
14:49:14 <awesame> dolio: oh, I see
14:49:19 <dolio> :)
14:49:25 <elliottt> maybe if it had an rss feed, it could be a functor
14:49:34 <MyCatVerbs> bos: hrmn. That might actually rock out loud.
14:49:36 <sjanssen> clearly hpaste is equivalent to _|_
14:49:59 <elliottt> no, that's reddit :)
14:50:05 <awesame> shouldn't it be in the IO monad?
14:50:07 <CosmicRay> sjanssen: hpaste may be more similar to /dev/null
14:50:10 <sjanssen> or const $ const _|_
14:50:23 <sjanssen> or const _|_
14:50:31 <CosmicRay> or /dev/random
14:50:41 <CosmicRay> you can read and write to it, but you may not get back out what you put in.
14:50:45 <mar77a> CosmicRay, when i saw "It is easy to work with and important to understand." i almost shat myself in the nuts
14:50:50 <CosmicRay> haha
14:50:55 <awesame> I don't think I understand how to read that type, actually
14:50:59 <CosmicRay> <burns> excellent </burns>
14:51:06 <awesame> (a -> b) -> f a -> f b
14:51:07 <CosmicRay> mar77a: hopefully after you read that chapter, you will agree ;-)
14:51:27 <awesame> I read "f a" as meaning that a must be and instance of f
14:51:39 <CosmicRay> mar77a: I initially wanted to write a book on Haskell because so many tutorials covered I/O so poorly
14:51:43 <awesame> but what does that mean for "(a -> b)"?
14:51:56 * monochrom loves _|_
14:51:56 <awesame> is that the same as if it said (f a -> f b)?
14:51:57 <sjanssen> awesame: that isn't what "f a" means
14:51:59 <dolio> awesame: f is a variable of kind * -> *.
14:52:11 <CosmicRay> mar77a: to me, a systems programmer, I/O is key to just about everything.  and haskell's I/O system happens to be very slick.  it just works differently.
14:52:21 <mar77a> define:slick
14:52:30 <mar77a> english is not my first language
14:52:41 <dolio> It's just like the f in fmap, except there's no class constraint on what it can be.
14:52:41 <CosmicRay> slick == cool, nice, awesome, etc.
14:52:47 <gubagem> mar77a: what is your first language
14:53:00 <mar77a> gubagem: haskell.
14:53:00 <awesame> so I think I understand what dolio said, but don't have any examples of how that's not the same as constraining a to be an instance of f
14:53:03 <CosmicRay> heh
14:53:05 <mar77a> i wish... spanish :p
14:53:07 <gubagem> slick is something so cool and awesome it slips by you as if it was covered in lubricant
14:53:15 <CosmicRay> heh
14:53:19 <dolio> f isn't a class.
14:53:20 <awesame> oh, oh
14:53:37 <yaxu> anyone from london hug here?  there's hidden spam on the site
14:53:59 <sjanssen> awesame: do you have any examples of how that *is* the same as constraining a to be an instance of f?
14:54:04 <dolio> You could instantiate f to Maybe or IO or Ptr or ...
14:54:10 <CosmicRay> mar77a: I do not equate "easy to work with" with "intuitive to an imperative programmer", by the way ;-)
14:54:11 <awesame> yeah, sorry, I was confused somehow
14:54:18 <sjanssen> awesame: class constraints are always on the left side of =>
14:54:23 <awesame> f is a type constructor
14:54:30 <awesame> so now that makes sense
14:54:37 <mar77a> sadly
14:54:39 <mar77a> ok time to read
14:55:26 <CosmicRay> mar77a: I am often annoyed by people that confuse "easy to use" with "easy to learn".  (Not saying you're one, just an observation.)  I don't think Haskell's I/O system is particularly difficult to learn, but it is difficult to *explain* or teach.  which may be why there is so little quality coverage
14:56:23 <monochrom> I think Haskell I/O is pretty ordinary imperative programming afterall.
14:57:32 <monochrom> You say "do getChar; putChar; ..." and they are carried out, sequentially and eagerly, just like everyone else.
14:57:33 <CosmicRay> well sure, it can be used that way, even in a do block...  but that doesn't really give people a full understanding of it
14:57:41 <mar77a> monads aren't something everyone has to deal with
14:57:52 <CosmicRay> see there's another thing.  monads shouldn't be scary.
14:57:55 <mauke> monads are completely irrelevant for understanding IO
14:57:57 <CosmicRay> they are, but they shouldn't be.
14:57:57 <monochrom> You say "x `catch` y" and you've got exception handling, just like everyone else.
14:58:07 <CosmicRay> right.  and our IO chapter is before our monad chapter.
14:58:09 <awesame> CosmicRay: I stongly agree!
14:58:26 <CosmicRay> monochrom: yeah but start introducting hGetContents and suddenly we are very different than everyone else.
14:58:30 <awesame> all the blog to tutorials are like, "so, monads, these are going to confuse you and like blow your mind"
14:58:40 <CosmicRay> that is pretty much true ;-)
14:58:41 <awesame> but then they turn out to be simple, just always explained badly
14:58:52 <monochrom> hGetContents can be postponed as advanced topic
14:58:55 <CosmicRay> there are a lot of things about Haskell that are difficult to explain well ;-)
14:59:04 <awesame> they're important, but not so confusing
14:59:06 <CosmicRay> monochrom: but man, hGetContents is the really cool blow-your-mind feature! :-)
14:59:21 <ddarius> hGetContents makes us more the same as everyone else
14:59:34 <quicksilver> oh and there's me thinking hGetContents was the blow-you-mind bug! :-)
14:59:38 <CosmicRay> hehe
14:59:38 <quicksilver> I must have got confused.
14:59:43 <CosmicRay> evidentally
15:00:06 <CosmicRay> take that from a person that writes libraries using unsafeInterleaveIO to return database result sets and FTP command results ;-)
15:00:12 <gubagem> or not calling hClose....cause who knows when my file might actually get read
15:00:14 <RayNbow> http://www.reddit.com/r/programming/info/6mt7z/comments/c04b74s <-- since when can you install packages like this?
15:00:14 <lambdabot> Title: programming: Haskell performance is on par with OCaml
15:00:25 <mar77a> CosmicRay if there's something annoying about the text
15:00:31 <mar77a> is that on 800x600 you have to keep moving horizontally
15:00:38 <ddarius> RayNbow: For quite a while now.
15:01:03 <monochrom> So, it comes down to CosmicRay thinking unsafeInterleavIO as cool. :)
15:01:07 <CosmicRay> mar77a: that is probably a fluke of the formatter bos is using for this version.  this is going to be published by O'Reilly in a dead tree edition and presumably sold online in safari and whatnot later.
15:01:12 <CosmicRay> heh
15:01:20 <CosmicRay> monochrom: cool in an evil sort of way ;-)
15:01:35 <bos> mar77a: i don't have any 800x600 screens to test on
15:01:44 <mar77a> it falls short by
15:01:45 <CosmicRay> monochrom: like rm, really.  can do all sorts of good things, or it lets colleagues accidentally delete /var on a file server in a split second
15:01:46 <mar77a> 5 pixels
15:01:48 <RayNbow> ddarius: what is `cabal` exactly? A Haskell script or an executable?
15:02:01 <RayNbow> (it isn't available on my path)
15:02:02 <MyCatVerbs> bos: simulate one! Use Xnest, or even an Xvnc on localhost? :)
15:02:04 <monochrom> hGetContents and unsafeInterleaveIO are powerful and need care. User must carefully set up the right environment, then they do wonder. In arbitrary environments, they run wild.
15:02:05 <CosmicRay> RayNbow: also a library, for added confusion.
15:02:05 <dolio> Make sure your book isn't printed in 800x600.
15:02:08 <CosmicRay> heh
15:02:13 <mar77a> :D
15:02:44 <bos> MyCatVerbs: i don't have time to do that sort of tuning, alas.
15:02:49 <RayNbow> CosmicRay: ah, thx
15:05:06 <CosmicRay> incidentally if any of you with strong I/O opinions want to comment on that chapter and tell me why I suck, public comments are available ;-)
15:05:52 <monochrom> You have done system programming. You cannot suck. :)
15:05:58 <CosmicRay> heh
15:06:30 * CosmicRay will have to write that down
15:08:09 <sjanssen> @where cabal-install
15:08:10 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
15:08:15 <mar77a> it's too annoying to read, bos you think you can do something
15:08:31 <MyCatVerbs> bos: oh fair enough, I just meant to point out that it's feasible without adding extra hardware.
15:08:32 <sjanssen> RayNbow: ^^^
15:08:50 <mar77a> just reduce the width of the div or whatever contains the whole thing a few pixels
15:08:55 <mar77a> 5 or so will do
15:10:05 <mar77a> brb
15:10:28 <MyCatVerbs> monochrom: uh, that doesn't guarantee non-suckiness.
15:10:37 <MyCatVerbs> monochrom: it's quite possible to suck even despite system programming.
15:11:04 <MyCatVerbs> monochrom: albeit, it's not quite possible to suck despite system programming that actually works nicely. Thaaaat's the distinction you might want to draw.
15:11:45 <igel> hi
15:11:52 <igel> is there a problem with hackage.org?
15:12:03 <sjanssen> igel: you want hackage.haskell.org
15:12:27 <igel> i've just checked a package for upload and it complains about not being able to extract the .cabal file from an archive...
15:12:48 <igel> sjanssen: there's an extra channel?
15:13:07 <sjanssen> igel: no, I just wanted to point out the the url is hackage.haskell.org, not hackage.org
15:13:11 <sjanssen> #haskell is fine
15:13:21 <sjanssen> igel: what sort of archive is it?  How did you make it?
15:13:37 <igel> oh, my typo^^
15:13:50 <igel> ./Setup.lhs sdist
15:14:05 <igel> with main = defaultMain
15:14:10 <sjanssen> hmm, that should certainly work
15:14:11 <igel> nothing special
15:14:19 <sjanssen> and you got a .tar.gz out of it?
15:14:20 <igel> the archive seems to be ok as well
15:14:27 <igel> yes
15:14:45 <igel> with the .cabal, LICENCE and source files in it
15:14:52 <igel> properly named as far as i can see
15:15:27 <igel> hackage responds:
15:15:27 <igel> 400 Error in upload
15:15:27 <igel> could not extract random-acces-list-0.1/random-acces-list.cabal from random-acces-list-0.1.tar.gz
15:15:35 <mar77a> back. what do you think, bos ?
15:15:35 <sjanssen> there was a package uploaded just a few minutes ago, so hackage seems to be okay
15:15:57 <sjanssen> igel: do you realize you misspelled 'access'?
15:16:15 <igel> yeah :D
15:16:18 <mauke> how did you create the tarball?
15:16:34 <CosmicRay> mar77a: I don't think this is trivial to fix, and I think he said he doesn't have time to look into it now
15:16:49 <mar77a> ok i'll manage
15:16:56 <CosmicRay> this is basically a site for our reviewers and the book is really moving towards production now so we don't have a lot of time to focus on that stuff anymore
15:17:09 <sjanssen> igel: maybe this is a case sensitivity thing?  hackage is a Linux which is case sensitive, you might have trouble if you're on OS X or Windows
15:17:11 <mar77a> ahh
15:17:20 <CosmicRay> maybe if you print to a file you could view it in some viewer that lets you zoom out or something?  just a guess
15:17:35 <bos> mar77a: try changing the width of the div in firebug and see if it helps.  if it does, i'll apply a change.
15:17:44 <RayNbow> <sjanssen> RayNbow: ^^^ <-- sorry for the later reply, but I already found it. Thanks anyway :)
15:18:02 <bos> mar77a: but i don't have time to go on a fishing expedition with repeated small tweaks.
15:18:04 <igel> sjanssen: let me try the correct spelling at first, just a sec
15:18:13 <mar77a> never used firebug :x
15:19:25 <sjanssen> mar77a: you can also just turn page style off (under View > Page Style in firefox)
15:19:39 <mar77a> ah very interesting
15:19:41 <mar77a> that'll do
15:21:29 <mar77a> actually
15:21:32 <mar77a> i reduced the font size
15:23:07 <igel> sjanssen: now it works
15:23:13 <sjanssen> excellent
15:23:31 <igel> i had the type on the Name field of the .cabal, but not in its filename
15:23:42 <igel> thanks!
15:27:11 <gubagem> ok so i have defined a datatype using the data keyword and record syntax
15:27:34 <gubagem> now i want to return a new copy of that data structure with one 'field' changed
15:27:46 <mauke> old{ field = new }
15:27:47 <sjanssen> old { field = newvalue }
15:27:48 <gubagem> is there any way of me skipping all the boiler code?
15:27:56 <gubagem> just like that?!!!
15:28:10 <monochrom> kiss haskell
15:28:29 * gubagem bows before the almighty power of the lambda and design by a commitee that had brains on it
15:29:18 <sjanssen> gubagem: enjoy this syntax -- it is about the only good thing about Haskell records
15:29:33 <Tigran> Why does everyone slater record syntax?
15:29:36 <Tigran> I like it :(
15:29:48 <gubagem> that and adding functionality to datatypes with deriving
15:29:50 <byorgey> well, it could be a lot better
15:30:15 <sjanssen> Tigran: setting fields is syntax rather than a function
15:30:20 <byorgey> by comparison to everything else in Haskell it is positively ugly
15:30:22 <Tigran> I don't like the "}" and "{", but that's just aesthetics really
15:31:06 <Tigran> Maybe I've just not worked with sufficiently large records for it to ever bother me
15:32:03 <Cale> Well, the real problem is not with the current record syntax -- it's fine as a kind of sugar on top of algebraic datatypes. The real problem is that Haskell doesn't have a proper record system.
15:32:15 <tusho> [23:31]  <sjanssen> Tigran: setting fields is syntax rather than a function
15:32:22 <tusho> i'd like to see the type!
15:32:42 <Cale> tusho: that's easy :)
15:33:10 <tusho> Cale: i'm waiting
15:33:36 <Cale> Well, one solution is to make field labels be pairs consisting of a setter and getter
15:33:48 <ziman> what if i wanted to map "set member `field' to newvalue" over a list?
15:34:13 <augustss> Hmmm, so why shouldn't record updating be a function?  The section syntax could be reused ({x=5}) for the function that sets field x=5
15:34:19 <Cale> If the record type in question is R and the field type is A, then the getter has type R -> A, and the setter has type A -> R -> R
15:34:21 <tusho> Cale: example?
15:34:32 <tusho> hm
15:34:33 <tusho> well yeah
15:34:35 <tusho> but
15:34:37 <Cale> and you'd have functions set and get for extracting those
15:34:40 <tusho> how do you generate setter names from getters?
15:34:44 <tusho> x=?
15:34:55 <tusho> foo= 2 `on` record
15:34:56 <tusho> maybe
15:34:56 <Cale> So you'd write  get fieldName recordValue
15:35:02 <tusho> ah
15:35:09 <tusho> Cale: no, 'on'
15:35:10 <Cale> or  set fieldName value recordValue
15:35:12 <tusho> fieldName `on` record
15:35:18 <Cale> on is taken ;)
15:35:26 <tusho> and, uh, set fieldName value `on` record
15:35:31 <tusho> you'd need to make on polymorphic
15:35:31 <tusho> :P
15:35:35 <Cale> Why on?
15:35:57 <tusho> Cale: it reads properly
15:36:00 <Cale> It seems best that the getter and setter are just ordinary functions.
15:36:15 <tusho> But codes uglily
15:36:19 <Cale> I'm not sure what the purpose of the on function would be
15:36:22 <Tigran> Hmm, a nice intuitive operator would be preferrable I think
15:36:54 <Cale> @where fref
15:36:54 <lambdabot> I know nothing about fref.
15:37:06 <roconnor> @quote nuclear
15:37:06 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
15:37:14 <sjanssen> @google functional references
15:37:15 <lambdabot> No Result Found.
15:37:17 <tusho> Cale: to read better.
15:37:18 <roconnor> @quote nuclear
15:37:18 <lambdabot> cjeris says: instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
15:37:20 <Cale> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
15:37:21 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
15:37:37 <roconnor> @quote island
15:37:37 <lambdabot> ghc says: Unable to mmap( MAP_FIXED ) for Jump Islands
15:37:45 <Cale> However, that still isn't a proper record system.
15:37:51 <dcoutts> @seen thetallgu1
15:37:51 <lambdabot> thetallgu1 is in #haskell. I don't know when thetallgu1 last spoke.
15:38:11 <Cale> It's just more sugar on top of algebraic datatypes. Field names would still be disjoint between types.
15:38:24 <mauke> preflex: seen thetallgu1
15:38:24 <preflex>  thetallgu1 was last seen on #haskell 9 days, 3 hours, 20 minutes and 42 seconds ago, saying: ?seen igloo
15:38:31 <mauke> hah
15:38:35 <dcoutts> @tell thetallguy we keep missing each other :-) did you get cabal-install doing what you want? if not ask on cabal-devel mailing list or ask me
15:38:36 <lambdabot> Consider it noted.
15:38:36 <tusho> @quote ghc
15:38:36 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
15:38:50 <monochrom> haha
15:38:51 <tusho> wow
15:38:54 <tusho> when does it say that
15:39:05 <gwern> hm. what is 1000000 milliseconds?
15:39:05 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:39:15 <gwern> @messages
15:39:16 <lambdabot> thetallguy said 4h 4m 29s ago: Thanks for the patches. Applied the Timing patch. Jeremy has the other.
15:39:18 <tusho> gwern: 79 hours.
15:39:20 <tusho> Duh.
15:39:20 <monochrom> > 1000000 / 1000
15:39:22 <lambdabot>  1000.0
15:39:36 <Cale> @google 1000000 milliseconds in seconds
15:39:38 <lambdabot> http://www.sengpielaudio.com/calculator-millisecond.htm
15:39:38 <lambdabot> Title: Milliseconds and microseconds to seconds second - milli micro mikro s ms to s t ...
15:39:40 <gwern> tusho: ...that's not even a integer power of ten
15:39:41 <Cale> bah
15:39:51 <Cale> That used to work...
15:39:54 <ziman> hm, this FRef thing seems nice...
15:39:56 <tusho> gwern: SO
15:40:16 <Tigran> > 1000000 / 1000 / 60 / 60 / 24
15:40:17 <lambdabot>  1.1574074074074075e-2
15:40:30 <gwern> ah, a millisecond is 1/1000th a second
15:40:50 <tusho> how amazing
15:40:50 <tusho> :P
15:41:39 <gwern> anyone know whether a forkIO'd thread inherits nicedness and resource limits?
15:41:59 <Cale> gwern: It's part of the same process, so yes.
15:42:24 <Tigran> Hmm, is there a lib for converting colours from/to hex/rgb/strings etc?
15:42:32 <bos> gwern: it doesn't have any existence at all as far as the OS is concerned.
15:42:54 <gwern> I see
15:43:46 <tusho> gwern: forkIO just creates a userland thread
15:43:48 <tusho> inside the same process
15:45:09 <gwern> ah, good. so my fork-off-the-evaluation-and-then-sleep-and-kill-it seems to work
15:45:25 <roconnor> > 120/135
15:45:27 <lambdabot>  0.8888888888888888
15:45:38 <sjanssen> gwern: where fork == forkIO?
15:46:01 <gwern> yes
15:46:28 <gwern> is that insufficiently isolated? could the forkIO thread hang the main thread so the sleep/killThread never gets run?
15:46:40 <Cale> actually, unfortunately yes
15:46:42 <sjanssen> that won't work -- try "let f :: Int -> Int; f x = f $! (x+1) in f 0
15:47:02 <Cale> Tight loops which do no allocation will never get killed.
15:47:11 <Cale> Which is really unfortunate.
15:47:50 <gwern> strange. I've been testing it with 'let x = x + 1 in x' and 'let x = 1 + x in x' and they seemed to correctly either blow the stack or time limits
15:48:06 <sjanssen> gwern: Haskell evaluation in lambdabot really does have to use a separate process
15:48:13 <sjanssen> gwern: try x :: Int
15:48:22 <sjanssen> erm, actually that will blow the stack
15:48:25 <gwern> sjanssen: actually, your example won't typecheck
15:48:32 <gwern> gwern@craft:10132~/bin/mubot>echo "let f :: Int -> Int; f x = f $! (x+1) in f 0" | ./example                          [ 6:48PM]
15:48:37 <gwern> example: Expression does not type check.
15:49:26 <sjanssen> umm, it should
15:50:18 <gwern> is $! some sort of extension or nonhaskell98 thing?
15:50:23 <sjanssen> nope
15:50:23 <gwern> @info ($!)
15:50:24 <lambdabot> ($!)
15:50:28 <sjanssen> @src ($!)
15:50:28 <lambdabot> f $! x = x `seq` f x
15:50:36 <sjanssen> in Prelude.
15:51:31 <gwern> oh, it was a quoting problem it seems
15:51:40 <sjanssen> oh, $!
15:51:44 <gwern> apparently 'seq' is one of the coreutils?
15:51:51 <gwern> gwern@craft:10134~/bin/mubot>echo 'let f :: Int -> Int; f x = f `seq` (x+1) in f 0' | ./example                       [ 6:50PM]
15:51:55 <gwern> Expression type: Int
15:51:57 <gwern> ; result: "1"
15:52:07 <sjanssen> gwern: f `seq` (x+1) isn't the same thing
15:52:12 <sjanssen> "coreutils"?
15:52:17 <sjanssen> it is in the Prelude
15:52:32 <gwern> sjanssen: try 'man seq' :)
15:52:32 <nus> $! is a bash syntax too (-:
15:52:42 <gwern> huh. this is strange
15:52:44 <gwern> gwern@craft:10136~/bin/mubot>echo 'let f :: Int -> Int; f x = f $! (x+1) in f 0' | ./example                          [ 6:52PM]
15:52:44 <sjanssen> gwern: seq isn't the problem, $! is a shell variable
15:52:47 <gwern> Expression type: Int
15:52:50 <gwern> ; result: "example: Time limit exceeded
15:53:01 <sjanssen> gwern: does your script compile with optimizations?
15:53:30 <gwern> I do not know. the Hint library wraps around the GHC API. I compiled the binary with -O2 if that's what you mean, and -threaded as well
15:53:48 <sjanssen> I mean the compilation of the expression
15:54:02 <sjanssen> it must not compile with -O
15:54:10 <sjanssen> gwern: "let x = x in x" might trigger the issue
15:54:22 <nus> ?src (seq)
15:54:22 <lambdabot> Source not found. Are you on drugs?
15:54:38 <nus> ?src drugs
15:54:38 <lambdabot> Source not found. I feel much better now.
15:54:43 <sjanssen> nus: seq is a magic function built into the compiler
15:54:57 <gwern> sjanssen:  gwern@craft:10137~/bin/mubot>echo 'let x = x in x' | ./example                                                        [ 6:52PM]
15:54:57 <nus> sjanssen, there's no magic
15:55:01 <gwern> Expression type: t
15:55:03 <gwern> ; result: "example: Time limit exceeded
15:55:10 <nus> sjanssen, :-P :-)
15:56:52 <sjanssen> gwern: are you using both rlimits and killThread?
15:57:12 <gwern> yes, of course
15:57:21 <sjanssen> oh, that should be okay then
15:57:31 <gwern> I intend to throw in a cd to /tmp and a nice call as soon as I've gotten things reliably working
15:57:32 <tusho> anyone?
15:57:33 <sjanssen> rlimits will catch computations that never allocate
15:57:51 <sjanssen> gwern: why bother with a cd to /tmp?  IO is not allowed
15:58:04 <sjanssen> tusho: what?
15:58:28 <gwern> just in case. I figure I can't get away with a chroot, but if I cd somewhere like /tmp, that will at least screw up relative path names
15:58:46 <tusho> sjanssen: interested in a hobix/blosxom clone in Haskell
15:58:46 <sjanssen> gwern: but the script can always cd back
15:58:49 <tusho> (that's actually maintained.)
15:58:56 <sjanssen> it is not difficult to guess where Cale runs lambdabot
15:59:08 <sjanssen> tusho: I haven't heard of one
15:59:15 * nus thinks primops.txt definitions would do too for @src
15:59:26 <gwern> sjanssen: one more step for an evil script to do, right? every bit counts, and it's easy enough to add in
15:59:41 <sjanssen> gwern: that bit doesn't count for anything, IMO :)
15:59:49 <tusho> sjanssen: I mean are you interested in one!
15:59:50 <sjanssen> gwern: security through obscurity and all that
15:59:53 <tusho> Specifically, is #haskell
15:59:58 <sjanssen> tusho: actually, I might be
16:00:10 <nus> (that'd require some@thing to tell you what's a "head normal form")
16:00:16 <tusho> sjanssen: yay
16:00:16 <gwern> what is a hobix?
16:00:17 <sjanssen> tusho: my greatest wish is for a blogging system that accepts literate style Haskell as input
16:00:18 <tusho> why, in particular?
16:00:39 <tusho> gwern: the white pantsuit of weblahhing!
16:00:39 <tusho> duh!
16:00:42 <tusho> (And websyting.)
16:00:44 <tusho> http://hobix.com/
16:00:44 <lambdabot> Title: hobix&you!! feel yeah!!
16:00:54 <tusho> (Warning: high amounts of insanity.)
16:01:02 <tusho> sjanssen: write a plugin for it, then, and rejoice ;)
16:01:04 <ikillyou> #hellas
16:01:11 <tusho> ikillyou: i kill you
16:01:12 <tusho> for SPAM
16:01:20 <ikillyou> oook
16:01:26 <ikillyou> SPAMSPAM
16:01:31 <tusho> go away
16:01:39 <ikillyou> go kill yourself
16:01:40 <Armored_Azrael> Woo. Presentation complete.
16:01:43 <ikillyou> internet nerd
16:01:49 <sjanssen> ikillyou: are you here to talk about Haskell?
16:01:51 <ikillyou> pshh
16:01:53 <ikillyou> no
16:01:53 <gwern> my mind. I can feel it going. I can feel it going dave
16:01:56 <tusho> ikillyou: i'm already dead unfortunately
16:01:57 <ikillyou> who's haskell?
16:01:59 <ikillyou> bahaha
16:02:01 --- mode: ChanServ set +o sjanssen
16:02:02 <tusho> being an internet killed me
16:02:03 <ikillyou> seriously
16:02:05 <tusho> now piss off.
16:02:07 --- kick: ikillyou was kicked by sjanssen (sjanssen)
16:02:10 <tusho> wow
16:02:13 <tusho> being an internet
16:02:13 <tusho> xD
16:03:30 <sjanssen> gwern: so mubot, eh?
16:03:50 <olsner> tusho: yeah, being an internet is bound to do horrible things to you... might even kill you :P
16:04:10 * olsner will never be an internet
16:04:16 <gwern> sjanssen: but if course :)
16:04:30 * gwern lacks imagination, but it struck me as a logical name
16:04:47 <thetallgu1> ?seen dcoutts
16:04:47 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 26m 12s ago.
16:04:49 <solrize> what's ikillyou?  some evil mutation of mahir?
16:04:53 <sjanssen> gwern: I think it would be good to separate the Haskell execution part from lambdabot
16:04:55 <tusho> solrize: an idiot
16:04:57 <gwern> also, it's infinitely easier for me to spell than lambda. I made so many compilation errors because I can't spell lambdab right
16:05:00 <tusho> his channel seems to be for some kidna internet radio
16:05:09 <tusho> gwern: lambdab
16:05:20 <tusho> @remember qwern I made so many compilation errors because I can't spell lambdab right
16:05:20 <lambdabot> Okay.
16:05:30 <gwern> sjanssen: that's sort of my idea - pipe the haskell expressions over to a seperate binary
16:05:50 <sjanssen> gwern: so even if you only write a new interpreter script, you should release it on hackage -- we can start using it in lambdabot
16:06:01 <nus> hmm, lambdabot> :t Num --  invalid ghci output: no type signature
16:06:02 <gwern> and at some glorious point, I might be able to rip out all the hs-plugins stuff from lambdabot!
16:06:07 <sjanssen> (or a lambdabot' if that gets written)
16:06:13 <tusho> sjanssen: heh
16:06:14 <sjanssen> gwern: exactly!
16:06:19 <tusho> lamdabot' isn't a valid nick
16:06:20 <tusho> :<
16:06:23 <sjanssen> aww
16:06:28 <tusho> i'd so write it though.
16:06:47 --- mode: ChanServ set -o sjanssen
16:07:06 <gwern> anyway, if you want to see what I have of mubot so far, see http://hpaste.org/8273
16:07:20 <gwern> note that you need Hint installed! the ghc api is too painful to use raw :)
16:08:00 <thetallgu1> @tell dcoutts yes, patches underway to make it more scriptable.  First one modifies 'cabal fetch' to output path of tarball,so another script can work on it.
16:08:00 <lambdabot> Consider it noted.
16:08:41 <nus> ?version
16:08:41 <lambdabot> lambdabot 4p664, GHC 6.8.2 (Linux i686 2.40GHz)
16:08:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:09:54 * gwern adds my build/test script and expected output to the hpaste
16:10:20 <gwern> (http://hpaste.org/8273#a2)
16:12:03 <sjanssen> gwern: do we have bindings for nice?
16:12:36 <gwern> sjanssen: yes, in import System.Posix.Process (nice)
16:12:50 <gwern> (may be surprising, I know)
16:12:56 <sjanssen> it is
16:13:07 <sjanssen> System.Posix is actually pretty complete, which is great
16:13:48 <sjanssen> gwern: this looks pretty good to me
16:13:51 <sjanssen> darcs repo time!
16:13:54 <gwern> hm. why would cd'ing to /tmp change my results? I still don't get that
16:14:12 <gwern> sjanssen: only if you manage it! I find adming darcs repos and web sites scary and unpleasant
16:14:50 <sjanssen> darcs repos are easy!
16:15:00 <sjanssen> gwern: you have an account on code.h.o, by the way
16:15:07 <sjanssen> do you want commit access to lambdabot?
16:15:23 <gwern> sure, why not
16:15:35 <gwern> I'm fine darcs sending stuff, but if you want to give it to me
16:16:00 <sjanssen> you may 'darcs push gwern@code.haskell.org/srv/code/lambdabot' now
16:16:10 <gwern> ok, so nice and cd/tmp are working. now I need to find a strict getContents...
16:16:39 <sjanssen> gwern: it might be simpler to use arguments to pass the imports and expressions
16:17:20 <gwern> arguments?
16:17:40 <tusho> gwern: like this
16:17:42 <sjanssen> mueval --import Data.List --timelimit 3 'let x = x in x'
16:17:43 <gwern> sjanssen: are you certain that is how a darcs push works? I see 'darcs failed:  Not a repository: gwern@code.haskell.org/srv/code/lambdabot (gwern@code.haskell.org/srv/code/lambdabot/_darcs/inventory: openFile: does not exist (No such file or directory))'
16:17:49 <tusho> GOD DAMNIT, WHY CAN'T YOU ACCEPT THAT I WANT THESE IMPORTS?
16:17:56 <tusho> AGH! YOU'RE SO STUPID! I WANT _THIS_ EXPRESSION!
16:17:58 <tusho> see?
16:18:02 <sjanssen> gwern: I forgot the colon between the host and the path
16:18:03 <gwern> tusho: because you touch yourself at night
16:18:10 <tusho> gwern: oh. good point.
16:19:24 <sjanssen> gwern: using arguments rather than stdin will actually simplify things for the caller
16:19:26 <gwern> sjanssen: alright, I like that idea. is there something in the stdlibs for that?
16:19:31 <tusho> gwern: yes
16:19:33 <tusho> System>GetOpt
16:19:35 <tusho> or whatevs
16:19:52 <tusho> oh darn, my haskell hobix clone will be so awesome
16:20:04 <tusho> hmm...
16:20:10 <mauke> sorry, that name is already taken
16:20:17 <tusho> mauke: what
16:20:26 <tusho> what do you mean?
16:20:33 <mauke> “awesome”
16:20:36 <tusho> haha
16:20:42 <mauke> @where awesome
16:20:43 <lambdabot> I know nothing about awesome.
16:20:45 <tusho> the WM
16:20:47 <tusho> yeah
16:20:53 <tusho> anyway - what haskell template engines are there save for HStringTemplate?
16:20:54 <mauke> @where+ awesome http://awesome.naquadah.org/
16:20:54 <lambdabot> Good to know.
16:20:57 <tusho> talking actually embedding haskell code here
16:21:03 <mauke> @slush
16:24:14 <gwern> @tell Cale don't bother applying my last 19 patches, I already darcs pushed them
16:24:14 <lambdabot> Consider it noted.
16:24:32 <dolio> @flesh
16:24:32 <lambdabot> Not enough privileges
16:24:54 <nus> @hoogle lookupOEIS
16:24:55 <lambdabot> No matches found
16:25:54 <gwern> sjanssen: do you know of any getopt users? the doc isn't terribly clear to me
16:26:34 <nus> @hoogle lookupSequence
16:26:35 <lambdabot> No matches found
16:26:58 <tusho> gwern: it's pretty simple
16:26:59 <tusho> it has examples
16:27:00 <sjanssen> gwern: not off the top of my head.  The examples seem fairly clear
16:27:20 <gwern> bah. fine, i will muddle through in my usual inimicable fashion
16:27:50 <mauke> heh, getopt didn't make sense to me initially
16:28:10 <mauke> then I thought about how I'd design a getopt in haskell and arrived at nearly the same interface
16:31:11 <Vq^_> mauke: hah, i've done that with a series of things in haskell :)
16:34:37 <roconnor> Surprisingly, I'm starting to thinkg /. comments are of higher quality than reddit comments.
16:34:53 <Pseudonym> It depends what level you view comments at.
16:35:04 <roconnor> Pseudonym: slashdot or reddit?
16:35:07 <Pseudonym> Slashdot.
16:35:26 <roconnor> good or bad?
16:35:39 <Pseudonym> It's the infinite monkeys principle, but slashdot also has a good selection pressure.
16:35:46 <Pseudonym> The moderation system, for all its faults, works most of the time.
16:35:56 <roconnor> reddit seems to have the opposite selection pressure.
16:36:09 <Vq^> i feel like the standard visible /. comments has improved quite a lot recently
16:36:14 <Pseudonym> I don't read reddit.
16:36:22 <Pseudonym> It's not worth it./
16:36:41 <roconnor> example 67 point comment on science reddit: http://www.reddit.com/info/6mz8t/comments/c04bkbl
16:36:46 <lambdabot> Title: reddit.com: Ovulation moment caught on camera (with pics)
16:37:05 <roconnor> *sigh*
16:37:28 <roconnor> we need more http://xkcd.com/322/
16:37:29 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:37:36 <mauke> +67 insightful
16:37:56 <tusho> -1, Avocado
16:38:36 <Pseudonym> I think there's something to be said for an upper limit on the moderation score.
16:38:43 <roconnor> oh
16:38:49 <tusho> roconnor: that edit is pretty funny, thouh
16:38:51 <tusho> *though
16:38:52 <Pseudonym> And a limit on the number of moderation points you can hand out.
16:38:57 <roconnor> went up to 69 while talking here.
16:40:40 <roconnor> tusho: what is funny about the edit?
16:44:08 <mmorrow> mauke: hellyesh! i've been trying to figure out how to do this for a while and it's soo simple: http://mauke.ath.cx/stuff/haskell/hell.hs
16:44:19 <mauke> :-)
16:44:23 <mmorrow> :)
16:44:29 <tusho> :)
16:44:48 <mauke> ☺
16:45:01 <tusho> ☻
16:45:12 <mauke> ☕
16:45:35 <tusho> ⌘
16:45:35 <mmorrow> ☠
16:45:48 <tusho> ¤
16:45:49 <mmorrow> ☣
16:45:52 <mauke> ☭
16:45:57 <mmorrow> ☢
16:45:58 <tusho> ℵ
16:46:00 <mauke> ☃
16:46:04 <tusho> ∀
16:46:11 <mauke> ‽
16:46:12 <tusho> ∅
16:46:39 <Vq^> q       (behold the flipped 'p'!)
16:46:42 <tusho> C-C-C-COMBO BREAKER!
16:46:50 <tusho> that was amazing
16:46:51 <tusho> I love you all
16:47:12 <tusho> will you all have my babies :D
16:47:17 <tusho> i beg you :(
16:47:23 <sjanssen> mauke: is preflex's source online?
16:47:41 <tusho> sjanssen: i don't think it's written in haskell
16:47:44 <tusho> correct if wrong :)
16:47:44 <MyCatVerbs> tusho: why, are your babies somehow unacceptable to you?
16:47:49 <tusho> MyCatVerbs: yep
16:48:00 <thetallgu1> @messages
16:48:00 <lambdabot> You don't have any new messages.
16:48:02 <tusho> i'm baby-ist
16:48:09 <mmorrow> you bastard!
16:48:16 <mauke> sjanssen: it can be accessed at http://mauke.ath.cx/preflex/
16:48:17 <lambdabot> Title: Index of /preflex
16:48:25 <mauke> it's not really supposed to be a public project, though
16:48:44 <sjanssen> mauke: thanks.  Why shouldn't it be public?
16:49:21 <tusho> is this where I plug my own irc bot
16:49:48 <mauke> it's my first bot. many things in there are just experiments
16:49:59 <mauke> all kinds of ad-hockery
16:50:08 <Pseudonym> Just as a piece of advice, if it's a new bot, send it to a new channel first.
16:50:20 <Pseudonym> Then when you've discovered that it doesn't misbehave, send it here.
16:50:24 <tusho> Pseudonym: who was that addressed to?
16:50:30 <sjanssen> preflex: seen Pseudonym
16:50:30 <preflex>  Pseudonym was last seen on #haskell 10 seconds ago, saying: Then when you've discovered that it doesn't misbehave, send it here.
16:50:43 <sjanssen> preflex has been in #haskell for quite some time now
16:50:53 <Pseudonym> Yes.
16:50:59 <Pseudonym> tusho: Anyone with a new bot.
16:51:04 <roconnor> Pseudonym: preflex has been here for quite some time now.
16:51:05 <tusho>     Faggotry,      -- preflex source
16:51:19 <mauke> preflex was inspired by lambdabot. a central feature is that it doesn't lose state, ever. :-)
16:51:23 <Pseudonym> Clearly, preflex is steam-powered and runs on wood.
16:51:33 <tusho> mauke: and it has a data type called Faggotry, obviously
16:51:39 <Pseudonym> Which is very responsible, using bio fuels.
16:51:59 <mauke> heh, where did I use that
16:52:10 <tusho> mauke: it's in Preflex.hs
16:52:11 <Vq^> all programs should have that datatype
16:52:13 <tusho> no wait
16:52:15 <tusho> MonadIRC.hs
16:52:35 <mauke> ah, yes
16:52:54 <mauke> because POSIXTime has dysfunctional Read/Show instances
16:53:25 <mmorrow> does anyone have an idea why this would be happening:
16:53:27 <mmorrow> Invalid repository:  http://morrow.jypsis.com/code/hm
16:53:27 <mmorrow> darcs failed:  Failed to download URL http://morrow.jypsis.com/code/hm/_darcs/inventory : HTTP error (404?)
16:53:28 <lambdabot> Title: Index of /code/hm
16:53:41 <mmorrow> (it exists)
16:54:20 <elliottt> preflex: uptime
16:54:23 <elliottt> no luck.
16:54:33 <tusho> elliottt: three ts?
16:54:40 <elliottt> three indeed :)
16:54:50 <mauke> elliottt: /whois preflex preflex
16:54:50 <elliottt> and i make good use of them too.
16:54:59 <sjanssen> > "ellio" ++ repeat 't'
16:55:00 <lambdabot>  "elliotttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt...
16:55:02 <tusho> elliottt: is that your real name
16:55:08 <elliottt> trevor elliott
16:55:14 <elliottt> hence the nick.
16:55:19 <tusho> mine is elliott! hird.
16:55:25 <mauke> how about telliott?
16:55:30 <tusho> mauke: i was about to say that
16:55:34 <tusho> TellIOTT
16:55:34 <mmorrow> me too
16:55:40 <elliottt> well, the cs department gave me elliottt, and i decided that i liked that :)
16:55:43 <tusho> the (Tell IO) transformer tarnsformer
16:56:06 <sjanssen> @uptime
16:56:06 <lambdabot> uptime: 22h 29m 41s, longest uptime: 1m 10d 23h 44m 29s
16:56:26 <tusho> 1 minute max uptime? ;)))
16:56:32 <sjanssen> tusho: month
16:56:35 <Pseudonym> There was an undergrad at my department in the early 90s who got his initials as his login id.
16:56:38 <tusho> sjanssen: ;))) <-- NOTE
16:56:39 <Pseudonym> His initials were gid.
16:56:46 <elliottt> hehe
16:56:55 <Pseudonym> Every Unix geek had fun with that.
16:57:00 <elliottt> i bet :)
16:57:04 <tusho> I don't have a middle name.
16:57:09 <tusho> I cannot rms/jwz myself.
16:57:21 <tusho> Well. 'eh'.
16:57:23 <Pseudonym> The fun part is that the guy who assigned it was probably kre, who wrote the quota system in Unix.
16:57:44 <tusho> I should invent a middle initial.
16:57:48 <tusho> Like 'z'. 'ezh'.
16:57:54 <tusho> Or 'g'. 'egh'. Or 's'. 'esh'.
16:57:54 <nus> gwern, looking at the changelog, you broke the oeis plugin?
16:57:58 <mauke> j. for 'jay'.
16:58:12 <roconnor> use ZERO-WIDTH-JOINEN
16:58:12 <tusho> mauke: there's a guy called j on B Nomic
16:58:16 <roconnor> JOINEr
16:58:20 <tusho> roconnor: that may cause some problems.
16:58:31 <mauke> Michael J. Fox (born Michael Andrew Fox on June 9, 1961)
16:58:49 <mmorrow> i think the hosting co i'm using sucks
16:58:49 <FordCortina> @pl  \f (x,y) -> (f x,f y)
16:58:49 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:59:16 <tusho> Hm. I think the problem is that 'e' and 'h' don't like being near each other.
16:59:32 <mauke> FordCortina: join (***)
16:59:42 <FordCortina> :t join (***)
16:59:44 <tusho> if I changed my name to Elliott R. Zot, that would work
16:59:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
16:59:53 <tusho> erzot.
17:00:19 <FordCortina> thanks mauke, ill make a note of that
17:00:19 <nus> gwern, oh, you mention sending the patches to byorgey
17:06:42 <gwern> tusho: don't feel bad. my initials form a vaguely self-deprecatory word
17:07:23 <gwern> nus: yes, the patches should be incorporated by now both in darcs oeis and hackage
17:07:37 <mauke> g?b
17:08:02 <tusho> gwern: hmm ... g...
17:08:03 <tusho> gay?
17:08:11 <tusho> ah, hm
17:08:13 <tusho> Branwen
17:08:14 <tusho> gb
17:08:36 <mauke> GEB
17:08:43 <nus> gwern, yep, have just found oeis-0.2 (-:
17:08:58 <tusho> mauke: Goëdel, Escher, Bach
17:08:58 <tusho> :-P
17:09:14 <tusho> err
17:09:19 <tusho> Gödel
17:10:49 <dancor> Gö^:e&ouml;del
17:11:13 <mauke> \"o
17:11:16 <tusho> dancor: lol wut
17:12:35 <mmorrow> preflex: nickometer mmorrow
17:12:36 <preflex>  mmorrow is 0% lame
17:12:40 <mmorrow> l33t
17:12:54 <mmorrow> preflex: nickometer preflex
17:12:54 <preflex>  preflex is 0% lame
17:13:03 <mmorrow> preflex: nickometer albacoretuna
17:13:04 <preflex>  albacoretuna is 0% lame
17:13:10 <mmorrow> preflex: nickometer joe
17:13:11 <preflex>  joe is 0% lame
17:13:12 <tusho> preflex: nickometer tusho
17:13:12 <preflex>  tusho is 0% lame
17:13:18 <tusho> preflex: nickometer ANUSFART
17:13:18 <preflex>  ANUSFART is 99.8747% lame
17:13:22 <tusho> hah
17:13:57 <ziman> preflex, nickometer Gödel
17:13:57 <preflex>  Gödel is 40% lame
17:14:00 <ziman> :)
17:14:25 <tusho> preflex: nickometer oklopol
17:14:25 <preflex>  oklopol is 0% lame
17:14:31 <tusho> preflex: nickometer æ
17:14:31 <preflex>  æ is 38% lame
17:14:32 <Armored_Azrael> preflex, nickometer rms
17:14:32 <preflex>  rms is 0% lame
17:14:36 <mmorrow> preflex: nickometer a
17:14:36 <preflex>  a is 0% lame
17:14:37 <tusho> does it look for unicode and UPPERCASE
17:14:38 <mmorrow> preflex: nickometer A
17:14:38 <preflex>  A is 8% lame
17:14:41 <mmorrow> preflex: nickometer aa
17:14:41 <preflex>  aa is 0% lame
17:14:44 <mmorrow> preflex: nickometer aA
17:14:44 <preflex>  aA is 8% lame
17:14:45 <tusho> preflex: nickometer ABCDEFGHIJKLMNOPQRSTUVWXYZ
17:14:45 <preflex>  ABCDEFGHIJKLMNOPQRSTUVWXYZ is 99.962595% lame
17:14:46 <mmorrow> preflex: nickometer Aa
17:14:46 <preflex>  Aa is 0% lame
17:14:48 <mmorrow> preflex: nickometer AA
17:14:48 <preflex>  AA is 14% lame
17:14:50 <tusho> oic
17:14:54 <tusho> that's kind of a lame statistic
17:14:55 <mauke> it's more that it fails to look for unicode
17:14:58 <tusho> preflex: nickometer assfart
17:14:58 <preflex>  assfart is 0% lame
17:15:04 <sjanssen> preflex: nickometer sjanssen
17:15:04 <preflex>  sjanssen is 0% lame
17:15:09 <tusho> preflex: nickometer my mother
17:15:10 <preflex>  my mother is 14% lame
17:15:11 <sjanssen> yes!
17:15:13 <tusho> wtf
17:15:15 <tusho> 14%?
17:15:16 <Armored_Azrael> spaces
17:15:19 <tusho> oh
17:15:32 <Armored_Azrael> preflex: nickometer foo bar baz
17:15:32 <preflex>  foo bar baz is 26% lame
17:15:35 <Armored_Azrael> see?
17:15:39 <tusho> preflex: nickometer
17:15:39 <preflex>   is 0% lame
17:15:47 <ziman> preflex, nickometer ~^l33t_N1cK^~
17:15:47 <preflex>  ~^l33t_N1cK^~ is 99.910166% lame
17:15:54 <Pseudonym> preflex: nickometer CrashOverride
17:15:54 <preflex>  CrashOverride is 0% lame
17:15:56 <mauke> preflex: nickometer mar77a
17:15:56 <preflex>  mar77a is 28% lame
17:16:15 <tusho> preflex: nickometer ~*^tuDaY I wuRkD DowN ThA sTreeT^*~
17:16:15 <preflex>  ~*^tuDaY I wuRkD DowN ThA sTreeT^*~ is 99.99200853% lame
17:16:28 <tusho> uh haskell what the hell is that
17:16:32 <mar77a> how's it lame :(
17:16:32 <tusho> never heard of it
17:16:38 <Armored_Azrael> preflex: \"foo\"
17:16:39 <tusho> mar77a: numbers
17:16:42 <mar77a> fine
17:16:46 <mauke> l33tsp34k
17:16:59 <tusho> mauke: mar77a isn't very stupid thoughu
17:17:03 <mmorrow> preflex: nickometer syd
17:17:03 <preflex>  syd is 0% lame
17:17:08 <mmorrow> preflex: nickometer syd_
17:17:08 <preflex>  syd_ is 14% lame
17:17:10 <mauke> preflex: nickometer syd-
17:17:10 <preflex>  syd- is 14% lame
17:17:12 <tusho> mauke: nickometer ChanServ
17:17:16 <tusho> er
17:17:16 <tusho> HA
17:17:19 <tusho> preflex: nickometer ChanServ
17:17:19 <preflex>  ChanServ is 0% lame
17:17:21 <mauke> tusho: 0%
17:17:23 <tusho> preflex: nickometer a11235
17:17:24 <preflex>  a11235 is 73% lame
17:17:29 <tusho> I think he might be sad at that
17:17:34 <tusho> preflex: nickometer _MaK_
17:17:35 <preflex>  _MaK_ is 26% lame
17:17:38 <tusho> preflex: nickometer allbery_b
17:17:38 <preflex>  allbery_b is 14% lame
17:17:40 <tusho> ok, that meter sucks
17:17:42 <tusho> and I'm done
17:17:53 <mar77a> psh it's fine :<
17:18:07 <tusho> mar77a: i agree
17:18:32 <allbery_b> *eyebrow*
17:18:46 <mmorrow> preflex: + nine!
17:18:53 <mmorrow> preflex: . four
17:19:05 <mmorrow> preflex: . nine
17:19:06 <mmorrow> preflex: . nine!
17:19:26 <mmorrow> preflex: + 8 9
17:19:29 <mauke> hmm
17:19:38 <mauke> preflex: get nine
17:19:38 <preflex>  factoid not found
17:19:39 <mmorrow> preflex: . 8
17:19:43 <mmorrow> preflex: . 9
17:19:44 <mauke> I think we have a bug
17:19:50 <mmorrow> ohnos
17:20:05 <mmorrow> preflex: get 8
17:20:05 <preflex>  9
17:20:08 <mmorrow> ah
17:20:29 <mmorrow> preflex: + 9 8
17:20:31 <mmorrow> preflex: get 8
17:20:32 <preflex>  9
17:20:33 <mmorrow> preflex: get 9
17:20:33 <preflex>  8
17:20:58 <mmorrow> preflex: + 9 "preflex: get 8"
17:21:03 <mmorrow> preflex: get 9
17:21:03 <preflex>  "preflex: get 8"
17:21:07 <mmorrow> preflex: + 9 preflex: get 8
17:21:08 <mmorrow> preflex: get 9
17:21:08 <preflex>  preflex: get 8
17:21:29 <mmorrow> wily
17:22:55 <mmorrow> preflex: + 9 \bpreflex: get 8
17:22:57 <mmorrow> preflex: get 9
17:22:57 <preflex>  \bpreflex: get 8
17:23:08 <mmorrow> oh snap
17:25:48 <mar77a> congrats, CosmicRay
17:25:53 <mar77a> this text REALLY helped
17:30:10 <mauke> preflex: . 9
17:30:10 <preflex>  \bpreflex: get 8
17:30:14 <mauke> fixed
17:30:51 <mauke> I <3 smooth upgrades
17:33:01 <monochrom> @botsnack
17:33:01 <lambdabot> :)
17:33:14 <monochrom> botty lovely
17:33:46 <mauke> preflex: version
17:33:46 <preflex>  7.613
17:35:33 <tusho> preflex: hugs
17:35:38 <tusho> I want preflex to give me hugs.
17:35:40 <tusho> Fix ASAP.
17:36:26 <mauke> but it runs on ghc :(
17:36:44 <tusho> mauke: don't worry, hugs doesn't give people hugs
17:36:48 <tusho> you can give people hugs without hugs,.
17:36:56 <mauke> the hugless hug
17:37:00 <mauke> KOAN
17:38:53 <tusho> mauke: very zen
17:38:54 <tusho> but, no
17:38:58 <tusho> it is NOT ZEN AT ALL, YOU IDIOT
17:39:03 <tusho> now medidate on that for precisely 3 seconds
17:39:04 <mauke> the zenless zen
17:39:11 <tusho> you will gain enlightenmenYOU IDIOT
17:39:20 <tusho> that should break you out of your meditation. welcome to the real world.
17:39:21 <mauke> I prefer xmonad
17:39:27 <tusho> or is it the fake world, I don't know
17:39:56 <monochrom> If Budhha explains enlightenment but there is no one around, what language does he speak in?
17:40:09 <monochrom> (Of course he speaks Haskell too!...)
17:41:54 <tusho> monochrom: this is simple:
17:42:11 <tusho> > let enlightenment = enlightenment; around = [] in enlightenment
17:42:16 <tusho> Clearly, that's in Haskell.
17:42:19 <tusho> Thus, problem solved.
17:42:26 <lambdabot>  thread killed
17:43:00 <mauke> if you meet a thread on the road, kill the thread
17:43:03 <tusho> lambdabot doesn't understand it.
17:43:05 <monochrom> lambdabot:  killed Budhha!
17:43:18 <monochrom> s/: //
17:48:31 <mmorrow> @seen hpaste
17:48:31 <lambdabot> I saw hpaste leaving #haskell 7h 18m 17s ago, and .
17:49:05 <mmorrow> mauke: "call a string + disassembling with harpy": http://hpaste.org/8274
17:49:26 <mmorrow> :)
17:54:13 * byorgey bakes an asparagus-tomato-basil-lambda pizza
18:13:03 <mar77a> CosmicRay++
18:13:05 <mar77a> dons++
18:13:19 <mar77a> this book is good :)
18:14:16 <dolio> mmorrow: Nice.
18:14:23 <ddarius> bos too
18:15:12 <tusho> * byorgey bakes an asparagus-tomato-basil-lambda pizza
18:15:13 <tusho> mmm
18:15:31 <byorgey> =)
18:15:41 <dolio> bos++
18:15:57 <mmorrow> dolio: so psyched for the impending hackery
18:16:46 <dolio> mmorrow: Reminds me of old IOCCC stuff I read in a book, where the program was 'main = [list of random seeming numbers];'
18:17:24 <mmorrow> heh. i wonder if harpy has an asm parser...
18:18:33 <tusho> dolio: the best ones are main = string
18:18:36 <tusho> i've seen like
18:18:40 <tusho> main="\107";
18:20:01 <mmorrow> with mauke's code it'd be pretty simple to make a function so that you could be main = go "\107"
18:21:13 <mmorrow> with the harpy disassembler you could disasm any (x86-32) binary, pattern match instrs via it's Instruction datatype, then mangle away
18:22:22 <tusho> mmorrow: awesome program -
18:22:28 <tusho> disassembles its own binary
18:22:29 <tusho> tweaks it
18:22:35 <tusho> and replaces itself with the new version in memory
18:22:41 <gwern> byorgey: 'haskellites'?
18:22:41 <tusho> in HASKELL
18:22:47 <TSC> in the type system
18:22:57 <mmorrow> tusho: totally! you could do crazy stuff
18:23:05 <byorgey> gwern: hehe, what would you use?
18:23:12 <tusho> mmorrow: hm, an idea
18:23:17 <tusho> an IOCCC entry that doesn't break the rules
18:23:25 <tusho> but what it does, is modify itself to be a program that does break the rules
18:23:26 <tusho> :D
18:23:33 <gwern> byorgey: what everyone else does, 'Haskellers'
18:23:40 <byorgey> gwern: but that's boring.
18:24:05 <mmorrow> tusho: cunning
18:24:11 <byorgey> if everyone else jumped off a cliff...?  ;)
18:25:08 <gwern> @quote cliff
18:25:09 <lambdabot> No quotes match. Just what do you think you're doing Dave?
18:25:13 <gwern> @quote polyvariadic
18:25:13 <lambdabot> No quotes match. You untyped fool!
18:25:30 <gwern> @remember Botje [on googling for polyvariadic typeclasses] OH GOD THE FIRST HIT IS OLEGS SITE! / *ahum* / I meant, "yay, reading material"
18:25:30 <lambdabot> It is forever etched in my memory.
18:25:31 <mar77a> why can't i use fst on let temp = openTempFile "." "tempfile"
18:25:34 <gwern> @quote polyvariadic
18:25:35 <lambdabot> Botje says: [on googling for polyvariadic typeclasses] OH GOD THE FIRST HIT IS OLEGS SITE! / *ahum* / I meant, "yay, reading material"
18:25:38 <mar77a> fst temp and snd temp give errors
18:25:54 <vixey> :t openTempFile
18:25:55 <tusho> mar77a: type
18:25:55 <lambdabot> Not in scope: `openTempFile'
18:25:59 <tusho> it's IO Something
18:26:00 <tusho> not Something
18:26:06 <gwern> @quote i-will-not-use-fail-stick
18:26:06 <lambdabot> No quotes match. There are some things that I just don't know.
18:26:07 <tusho> @quote oleg
18:26:07 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
18:26:13 <vixey> mar77a: Well what are the types of things?
18:26:13 <tusho> @quote oleg
18:26:13 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
18:26:19 <mar77a> o_o
18:26:24 <ddarius> @google "Lennart Augustsson" IOCCC
18:26:26 <lambdabot> http://www.ioccc.org/winners.html
18:26:26 <lambdabot> Title: Winners - about the authors of winning IOCCC entries
18:26:33 <gwern> @remember quicksilver *quicksilver beats Deewiant with the i-will-not-use-fail-stick [Deewiant] quicksilver: I'm willing to accept a good alternative. [quicksilver] no. all you are permitted to accept is a beating.
18:26:34 <lambdabot> It is forever etched in my memory.
18:26:44 <gwern> @quote i-will-not-use-fail-stick
18:26:44 <lambdabot> quicksilver says: *quicksilver beats Deewiant with the i-will-not-use-fail-stick [Deewiant] quicksilver: I'm willing to accept a good alternative. [quicksilver] no. all you are permitted to accept
18:26:44 <lambdabot> is a beating.
18:26:59 <gwern> @quote aztec
18:26:59 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
18:27:02 <idnar> @quote @quote stick
18:27:02 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
18:27:03 <idnar> oops
18:27:05 <idnar> @quote stick
18:27:05 <lambdabot> shapr says: Aha, so that's the sticky stuff on my keyboard!
18:27:10 <gwern> @quote fix club
18:27:10 <lambdabot> No quotes for this person. Are you on drugs?
18:27:13 <tusho> @quote @quote
18:27:13 <lambdabot> mauke says: @quote vim
18:27:18 <idnar> @quote vim
18:27:19 <lambdabot> mauke says: @quote vim
18:27:19 <tusho> @quote @quote
18:27:19 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
18:27:24 <idnar> *rolleyes*
18:27:28 <idnar> @quote sarahbot
18:27:29 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
18:27:30 <gwern> @quote mauke <mauke> the first rule of fix club is "the first rule of fix club is "the first rule of fix club is...
18:27:30 <lambdabot> No quotes match.
18:27:36 <gwern> @remember mauke <mauke> the first rule of fix club is "the first rule of fix club is "the first rule of fix club is...
18:27:37 <lambdabot> I will remember.
18:27:38 <mar77a> i'm using ghci tho
18:27:38 <tusho> lambdabot: later tell lambdabot @quote lambdabot
18:27:41 <idnar> hahaha @ fix club
18:27:41 <gwern> @quote fix club
18:27:41 <lambdabot> No quotes for this person. You type like i drive.
18:27:52 <mar77a> openTempFile returns a tuple, with the filename and the handle
18:27:54 <tusho> @quote @quote tusho: @quote @quote
18:27:54 <lambdabot> No quotes for this person. Do you think like you type?
18:27:58 <gwern> @quote first rule
18:27:58 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
18:27:59 <tusho> @remember @quote tusho: @quote @quote
18:27:59 <lambdabot> It is stored.
18:28:05 <gwern> @quote mauke
18:28:05 <vixey> mar77a: but what is the type in haskell syntax?
18:28:05 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
18:28:09 <gwern> @quote mauke
18:28:09 <lambdabot> mauke says: haskell software should move from alpha to beta to eta, then lambda
18:28:12 <gwern> @quote mauke
18:28:12 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
18:28:14 <mar77a> the type of what?
18:28:15 <gwern> @quote mauke
18:28:15 <lambdabot> mauke says: the first rule of fix club is "the first rule of fix club is "the first rule of fix cl...
18:28:20 <gwern> there we go
18:28:50 <mar77a> the tuple? IO (FilePath, Handle)
18:28:51 <tusho> :t fmap fix
18:28:52 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
18:28:56 <tusho> :t fmap fix return
18:28:57 <lambdabot> forall a. a -> a
18:29:02 <tusho> huh
18:29:03 <vixey> mar77a: so you can do somthing like
18:29:05 <tusho> does that actually work
18:29:06 <gwern> byorgey: so where did you get the quotes from if not lambdabot?
18:29:07 <tusho> > fmap fix return 2
18:29:08 <lambdabot>  2
18:29:10 <tusho> wow
18:29:10 <vixey> do (l,r) <- temp
18:29:12 <tusho> HOW
18:29:12 <vixey>    use l
18:29:14 <vixey>    use r
18:29:15 <byorgey> tusho: and when you understand that, you will be enlightened =)
18:29:16 <vixey> etc
18:29:21 <tusho> byorgey: BUT.
18:29:28 <byorgey> gwern: I just grepped through the #haskell logs for @remember
18:29:30 <mar77a> no comprendo
18:29:35 <mar77a> hombre si si
18:29:38 <vixey> mar77a: You have not seen do notation
18:29:43 <vixey> mar77a: ?
18:29:47 <mar77a> i have
18:29:54 <vixey> mar77a: what don't you understand?
18:29:55 <mar77a> sort of :)
18:30:01 <mar77a> do (l,r) <- temp
18:30:08 <tusho> @quote @remember
18:30:08 <lambdabot> LoganCapaldo says: that quote is so awesome I'd @remember it again if it weren't already remembered
18:30:10 <vixey> look at this function
18:30:12 <tusho> @quote @remember
18:30:12 <lambdabot> fasta says: I think the @remember command is way overused.
18:30:13 <vixey> f (x,y) = x+y
18:30:20 <tusho> ooh, wait a sceond
18:30:22 <vixey> does that make sense?
18:30:23 <tusho> @remember lambdabot LoganCapaldo says: that quote is so awesome I'd @remember it again if it weren't already remembered
18:30:24 <lambdabot> Nice!
18:30:27 <mar77a> it does
18:30:27 <tusho> MWAHAHAHA!
18:30:34 <tusho> @quote lambdabot @remember
18:30:34 <lambdabot> lambdabot says: LoganCapaldo says: that quote is so awesome I'd @remember it again if it weren't already remembered
18:30:38 <vixey> do <pattern> <- <action>
18:30:42 <vixey> is basically the same
18:30:58 <vixey> except instead of a function application, it's really, <action> >>= \<pattern> -> ...
18:31:05 <mar77a> ack
18:31:36 <vixey> so you can think of it as unboxing the monadic action for the scope of the do block
18:31:41 <tusho> vixey: you just confused him with that last line
18:31:41 <tusho> <3
18:31:47 <mar77a> no no
18:31:48 <mar77a> i get it
18:32:25 <mmorrow> ddarius: nice pointer: http://www.ioccc.org/1996/august.c
18:32:38 <tusho> mmorrow: What the hell.
18:32:42 <tusho> Well, most of that is in a comment..
18:32:46 <dolio> Yeah, that one's something.
18:32:52 <mar77a> it's IO (FilePath, Handle)
18:32:52 <tusho> It starts at int m[Z];
18:32:53 <tusho> Does it not?
18:32:57 <mar77a> not (IO FilePath, IO Handle)
18:33:23 <mmorrow> tusho: http://www.ioccc.org/years.html#1996_august
18:33:24 <lambdabot> Title: Previous IOCCC Winners
18:33:42 <gwern> byorgey: interesting. so I guess lambdabot must've lost those quotes
18:33:56 <byorgey> gwern: yeah, it seems to happen a lot.
18:34:01 <tusho> mmorrow: a c compiler?
18:34:19 <byorgey> every time \bot goes down there's a part of her state that hadn't been flushed
18:34:29 <mmorrow> are you reading http://www.ioccc.org/1996/august.hint ? crazy.
18:35:59 <gwern> 'About half of what I watch is animé, which tends to feature young characters who look even younger than they are, and most of the other half is either satirical panel shows or cop dramas, both of which tend to star comedians and actors in their 40s or older. So I can say with confidence that my viewing choices aren't influenced much by looks, or you'd have to draw some pretty weird conclusions.' <-- lol at SamB
18:37:35 <tusho> gwern: animé? is that like what people who watch anime say when they're trying to make it sound more cultured then they see it as being perceived?
18:37:37 <Botje> vixey: good $LOCALTIME, what did you think of the compiler? :)
18:37:42 <Botje> @quote yay
18:37:43 <lambdabot> Botje says: [on googling for polyvariadic typeclasses] OH GOD THE FIRST HIT IS OLEGS SITE! / *ahum* / I meant, "yay, reading material"
18:37:49 <Botje> hmm
18:37:54 <mmorrow> Botje: it's awesome
18:37:55 <Botje> i could've sworn it was in there
18:37:55 <tusho> @quote yay
18:37:56 <lambdabot> Botje says: [on googling for polyvariadic typeclasses] OH GOD THE FIRST HIT IS OLEGS SITE! / *ahum* / I meant, "yay, reading material"
18:37:59 <vixey> Botje: just insane :)
18:38:08 <tusho> yaeh
18:38:10 <tusho> very insane
18:38:11 <tusho> *yeah
18:38:29 <Botje> well, you are what you code, so i'm not going to deny that :)
18:38:45 <tusho> Botje: wait.
18:38:47 <tusho> YOU made that?
18:38:52 <Botje> milc? yes
18:38:58 <tusho> my lord.
18:39:02 <vixey> hehe
18:39:39 <mmorrow> tusho: you're not thinking of the ioccc entry are you?
18:40:10 <mmorrow> http://infogroep.be/~dharnie/milc
18:40:17 <lambdabot> Title: Index of /~dharnie/milc
18:41:00 <tusho> mmorrow: oh.
18:41:01 <tusho> yes.
18:41:32 <mmorrow> heh
18:41:44 <tusho> what is milkc
18:41:46 <tusho> milc
18:41:48 <tusho> c with continuations?
18:42:00 <mmorrow> it's botje's ml to c compiler project
18:42:01 <Botje> ml to C, in haskell
18:42:28 <dolio> http://www.ioccc.org/1988/robison.c   This one's pretty amusing.
18:42:41 <vixey> Botje: I am thinking about doing a haskell compiler now
18:42:54 <ddarius> A compiler of Haskell?
18:42:58 <dolio> Back when I was reading the book about the contest, I didn't understand why the description said that the assignment statement was 'controversial.'
18:43:46 <vixey> well mini-haskell
18:43:58 <ddarius> vixey: Why?
18:44:32 <Botje> vixey: be sure to pick up a(n online) copy of "implementation of functional programming languages"
18:45:09 <Botje> while it's a bit dated (it's as old as I am), it's a good read and very inspiring
18:45:10 <dolio> mmorrow: http://www.ioccc.org/1984/mullender.c
18:45:30 <mmorrow> dolio: awesome
18:47:04 <mmorrow> ha, built it with gcc and seqfault
18:47:09 <mmorrow> then i read the hint
18:47:10 <vixey> ddarius: well I'm mostly interested in proving correctness of it
18:47:11 <mmorrow> NOTE: If your machine is not a Vax-11 or pdp-11, this program will
18:47:11 <mmorrow>       not execute correctly.  In later years, machine dependent
18:47:11 <mmorrow>       code was discouraged.
18:47:25 <ddarius> vixey: Against what specification?
18:47:42 <vixey> ddarius: an interpreter
18:49:33 <mmorrow> it's great to know though that
18:49:37 <mmorrow> short main[] = { ... };
18:49:45 <mmorrow> will build with gcc though
18:50:51 <dolio> Yeah. Much better than inline assembly.
18:51:05 <vixey> ddarius: I could be wrong, but I get the impression it would be very simple (since it's pure) and it's a much more interesting language that exp ::= num int|+ exp exp
18:51:47 <ddarius> The core of Haskell is simple; many of the parts that make it distinctive are not.
18:52:09 <mmorrow> http://www.ioccc.org/1984/anonymous.c
18:52:17 <mmorrow> int i;main(){for(;i["]<i;++i){--i;}"];read('-'-'-',i+++"hell\
18:52:18 <mmorrow> o, world!\n",'/'/'/'));}read(j,i,p){write(j/p+p,i---j,i/i);}
18:52:19 <Botje> "haskell is like other languages except where it's not"? :)
18:53:05 <dolio> Yeah, that's a good one.
18:53:43 <dolio> That exploits the fact that i[string] = *(i + string) = string[i].
18:54:10 <mmorrow> whoa http://www.ioccc.org/years.html#1992_buzzard.2
18:54:10 <lambdabot> Title: Previous IOCCC Winners
18:55:09 <mmorrow> dolio: my new favorite C: i[string] = *(i + string) = string[i]
18:55:49 <tusho> mmorrow: wow, that is actually valid
18:55:50 <tusho> awesome
18:56:17 <tusho> char*i;int s;s[i]=*(s+i)=i[s];
18:56:21 <tusho> that's gotta be useful somehow
18:57:18 <Botje> it is when you're writing obfu code >:)
18:57:29 <tusho> Botje: no, I mean literally that line
18:57:34 <mmorrow> tusho: has to be
18:57:39 <tusho> a[b]=*(c+d)=e[f]
18:57:52 <byorgey> equational reasoning in C!  =P
18:58:33 * shapr boings
18:58:43 <byorgey> hi shapr!
18:58:50 <shapr> hiya byorgey!
18:59:03 <byorgey> how goes it?
18:59:09 <shapr> Fun! I'm coding on my XO
18:59:11 <shapr> How's code for you?
18:59:24 <papermachine> I want an XO :(
18:59:39 <byorgey> good!  I'm building automated tools to help me interactively create the HWN =)
18:59:41 <shapr> papermachine: They're cheap on ebay.
18:59:42 <gwern> tusho: I actually assume that the writer is french when anime is spelt that way
18:59:47 <shapr> byorgey: Cool! You took over HWN?
18:59:51 <byorgey> yup
18:59:53 <mmorrow> if C had a "jump" that's essentially goto but whose target isn't restricted to be in the function enclosing it, C would be SO sweet
19:00:02 <byorgey> just sent out my first issue today
19:00:07 <shapr> Awesome!
19:00:08 * shapr looks
19:00:10 <byorgey> motto: 'Putting the W back in HWN'  ;)
19:00:13 <shapr> haha
19:00:18 <shapr> I haven't tried GHC on my XO yet...
19:00:19 <shapr> or xmonad
19:00:20 <tusho> gwern: 'anime' is not from french
19:00:22 <tusho> despite rumours
19:01:11 <mmorrow> byorgey++
19:01:53 <nolrai_> * needs idea for something cool to program.
19:01:53 <mmorrow> shapr: awesome, i got 2
19:02:40 <tusho> nolrai_: /me. Use it.
19:03:00 <nolrai_> tusho++
19:03:11 * nolrai_ is using /me
19:04:16 <mrd> mmorrow: longjmp?
19:04:25 <mrd> setjmp
19:05:17 <monochrom> yeah, was about to call it "Haskell Buffered News"
19:05:23 <gwern> nolrai_: you need an idea for stuff to do?
19:05:25 <gwern> nolrai_: I actually have a whole TODO list for you...
19:05:34 <monochrom> haha, Haskell LazyByteString News :)
19:05:42 <byorgey> nolrai_: a cellular automaton simulator; a simply-typed lambda calculus interpreter; a particle phyiscs simulation; ... ?
19:05:58 <byorgey> monochrom: hehe
19:05:59 <mmorrow> mrd: garbage! :)
19:06:08 <gwern> nolrai_: http://hpaste.org/8275
19:06:21 <gwern> nolrai_: if you can't find anything in there worth doing, then there's something wrong wit'ye
19:07:00 <tusho> Tomorrow, I think I'm going to work on my blosxom/hobix clone. Then I'll write a plugin for keeping todo lists.
19:07:08 <tusho> Then, gwern, who will use anything Haskell, will use it.
19:07:08 <tusho> Profit.
19:07:23 * gwern gives up. screw it, I can't figure out GetOpt. I'll adhoc it as usual
19:07:41 <dolio> There was a getopt tutorial somewhere a while back.
19:07:49 <mmorrow> mrd: f(){F: jump G;} g(){G: jump F;} main(){jump F;}
19:07:54 <byorgey> gwern: wow, that's quite a todo list!
19:07:55 <dolio> Which I used to help me write the one program I've ever used it for.
19:08:02 <tusho> bye for today :) and gwern, I WILL MAKE YOU USE IT
19:08:03 <tusho> WHATEVER THE COST
19:08:09 <dolio> I think it was on dons' website.
19:08:13 <dolio> But I'm not sure.
19:08:14 <nolrai_> gwern, byorgey, thanks!
19:08:27 <gwern> byorgey: things will never get done if I don't write them down
19:08:27 <gwern> byorgey: you should see my list of books to read...
19:08:34 <byorgey> gwern: hehe, I bet
19:08:54 <byorgey> gwern: I like the idea of of \bot plugin to notify of hackage uploads
19:09:03 * gwern keeps track: I just added the 67th page of books
19:09:05 * ddarius writes things down to not do them.
19:09:22 <mmorrow> gwern: me too. * BNF Converter <http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/>
19:09:25 <gwern> yeah. it *should* be very easy now that hackage does rss feeds
19:09:31 <byorgey> yup
19:09:52 <vixey> get nolrai to do it :p
19:09:54 <byorgey> well, maybe it should be a standalone bot, like hpaste
19:10:21 <byorgey> I don't know if lambdabot has any mechanism for doing something in a timed loop, rather than just responding to messages
19:10:25 <shapr> Too bad \bot isn't a distributed service.
19:10:31 <shapr> byorgey: It did at one point.
19:10:36 <shapr> iirc, andersca wrote a pizza timer.
19:10:36 <byorgey> oh, really?  ok
19:10:43 <shapr> I think he did...
19:10:51 <vixey> why do you say "Functional reactive programming is in a sorry state"?
19:11:14 <shapr> Well, FRP is probably in the best state ever... but I still want to use it for real applications.
19:11:41 <gwern> mmorrow: there are a lot of good things to get done. I personally would *really* like to see the EHC compiler(s) up on hackage, but bnfc is a prereq, iirc
19:12:02 <gwern> vixey: it's confusing as hell what to use, and tere are very few examples. (I'm very familiar with frag, and it's messy and complex enough it'd be hard to learn from)
19:12:19 <gwern> (I mean, there are like 3 or 4 different half-active research groups occasionally pooping out unsupport and bitrotting libraries)
19:13:14 <shapr> Yeah, but frag isn't a very good example at all.
19:13:41 <shapr> Frag was pretty much a raw port of a bunch of C examples to Haskell for the BSP code at least.
19:14:08 <shapr> Frag doesn't even begin to compare to conal's FRP code.
19:14:51 <gwern> which only furthers my point - what is the biggest working and compiling app using FRP? I've only ever seen frag seriously put forth
19:15:26 <gwern> (conal's code is very nice, I'll admit, but he is rightly more concerned with getting the theory right than on humdrum community and software engineering matters, if you follow)
19:15:56 <shapr> I think conal is far more connected to the pragmatic world than many Haskell projects I've seen.
19:18:22 <gwern> I know you mean that as a compliment :)
19:18:33 <shapr> I think it is a compliment :-)
19:19:23 * ddarius forgot what he was going to do.
19:19:30 <shapr> ddarius: You wrote it down, didn't you?
19:19:48 <ddarius> shapr: I only write down things I don't plan to do.
19:19:59 <geezusfreeek> i am working on frp as well, mostly based on conal's work, but i too have gotten wrapped up in the theory of it
19:20:08 <geezusfreeek> originally i just wanted to make a game :P
19:20:41 <geezusfreeek> the problem though isn't really theory so much as getting a not sucky immplementation
19:20:41 <ddarius> geezusfreeek: You were probably warned about that when you started Haskell.
19:21:27 <geezusfreeek> i'm currently one my seventh or eighth rewrite
19:21:30 <geezusfreeek> *on
19:22:12 <geezusfreeek> the main problem conal and i seem to be sharing in both our code bases is little space leaks here and there
19:22:33 <gubagem> geezusfreeek: what do you keep rewriting?
19:22:49 <geezusfreeek> my FRP library
19:23:19 <vixey> what is FRP
19:23:29 <geezusfreeek> functional reactive programming
19:23:34 <geezusfreeek> ?where FRP
19:23:34 <lambdabot> I know nothing about frp.
19:23:38 <vixey> what's that though?
19:23:56 <gubagem> are you doing that 'signal' thing, or are you doing it another way
19:24:14 <gubagem> vixey: its something you can simulate robots with easily or make a game like Quake 3 called Frag
19:24:30 <cjs> @faq Can Haskell do FRP?
19:24:30 <lambdabot> The answer is: Yes! Haskell can do that.
19:24:33 * gubagem other then that gubagem has no idea and drools all over himself in the corner 
19:24:35 <cjs> How does she know?
19:25:04 <cjs> Vixey: Are you familiar with _The Haskell School of Design_?
19:25:13 <vixey> no
19:25:15 <gwern> we hope to generalize FRP so you can one day make a game like Quake 3, but not need to call it Frag
19:25:22 <cjs> Ah, you should definitely get yourself a copy.
19:25:32 <cjs> It's got a boatload of FRP stuff.
19:25:47 <vixey> not the haskell school of expression?
19:25:56 <cjs> Oh, right.
19:25:57 <vixey> (I can't find the design one)
19:26:01 <geezusfreeek> vixey: it's basically a different way of composing things meant to be a nice, more declarative way of dealing with interdependent effects
19:26:04 <cjs> It's "Expression."
19:26:08 <cjs> I always get that wrong.
19:26:12 <geezusfreeek> that is not a formal definition though
19:26:28 <geezusfreeek> gubagem: my version is based on the semantics described in http://conal.net/papers/simply-reactive/
19:26:29 <lambdabot> Title: Simply efficient functional reactivity
19:26:34 <gubagem> would it be better for writing a mud?
19:26:43 <geezusfreeek> although i am now deviating a little bit from those
19:26:44 <cjs> Anyway, it's actually a rather advanced book, IMHO, but it does more than any other to show just how cool haskell can really be.
19:27:04 <geezusfreeek> i personally wan't too impress with HSOE
19:27:26 <cjs> Really? Give me your thoughts on that.
19:27:47 <geezusfreeek> it's been a while. i think to be fair i would have to have a copy in front of me again
19:28:03 <cjs> Just general thoughts. I won't hold you to them. I'm just curious.
19:28:05 <geezusfreeek> cjs: i will get the copy from my university's library sometime this week and then get back to you
19:28:13 <cjs> Thanks.
19:29:18 <geezusfreeek> i have seen good reviews for it since i read it. perhaps i approached it from the wrong point of view
19:29:50 <geezusfreeek> gubagem: FRP for a MUD?
19:29:55 <cjs> I think it's pretty cool. It just moves really quickly into pretty advanced stuff.
19:30:12 <geezusfreeek> i have never written a MUD. not very familiar with how they work.
19:31:43 <geezusfreeek> i suspect that FRP is general enough for all programs, but that doesn't mean it is the best paradigm for them all by any means
19:33:04 <cjs> Well, it's new enough that we will probably be another ten years or so before we start to come up with really good forms of it.
19:33:12 <geezusfreeek> true
19:33:29 <vixey> I am so missing the point of frp
19:33:47 <cjs> I keep having to remind myself that, despite Haskell itself being twenty years old, a lot of the techniques are much newer.
19:34:00 <vixey> I thought it was just for animating things
19:34:07 <cjs> I was very entertaind by reading a textbook on learning Haskell that did pre-monadic I/O.
19:34:10 <shapr> vixey: I see it like a spreadsheet, where changing one value can change all the others.
19:34:11 <geezusfreeek> vixey: could you fill in the blank in "FRP seems to just be an obfuscated form of ________"? or is it some other kind of objection you have?
19:34:14 <geezusfreeek> ah i see
19:34:23 <gwern> man. dons getopt example isn't too bad, but it's useless for me since it doesn't cover the hard parts I need
19:34:24 <geezusfreeek> not, it is for many more things than just animations
19:34:40 <dolio> People originally developed it (as I understand) for robot control.
19:34:55 <dolio> Or, at least, that was one of the earliest haskell frameworks.
19:35:00 <dolio> Yampa.
19:35:04 <shapr> Robot Soccer!
19:35:05 <shapr> That was fun.
19:35:08 <geezusfreeek> shapr: except that with FRP, the order you change things also is important
19:35:22 * gwern goes to take a nap and work off the frustration
19:35:35 <geezusfreeek> although that may depend on the implementation… hmm
19:35:57 <geezusfreeek> s/implementation/particular api/ ... i suppose frp isn't mature enough to make such generalizations though
19:44:18 <papermachine> Wow, this FRP stuff is fascinating.
19:45:09 <gubagem> it looks to me like lots of pretty symbols and little hats over variable names >:E <--vampire face
19:45:43 <papermachine> Maths are cute ^_^
19:46:52 <cjs> There has been talk about using Unicode to write haskell programs so that we can use real arrows and all of that.
19:47:12 <hexpuem> is gmapQl the way to make generic merge operations for a set of types / subtypes?
19:47:17 <hexpuem> its hard to understand how the function even works haha
19:48:23 <nus> does CLIM incremental redisplay ring a bell?-)
19:48:37 <nus> wrt FRP
19:50:30 <geezusfreeek> never heard of it, but based on a hasty skim over google results, it sounds like that might be a good candidate for using FRP in its implementation
19:58:58 <gubagem> i dont know if i like this paper, it just keeps talking about a rat
19:59:24 <conal> hey -- my ears are buzzing.  FRP chat.
19:59:37 <papermachine> hey: you rock.
19:59:53 <papermachine> not that anonymous gratitude means much, but eh.
20:00:03 <Korollary> paypal may be an option
20:00:08 <papermachine> broke.
20:00:47 <conal> thanks.  i love hearing about interest in frp!
20:01:23 <gubagem> conal: is it good at games/simulation in general
20:01:41 <conal> gubagem: that's the idea.
20:01:43 <gubagem> oh and what is all this stuff i keep hearing about hundreds of thousands of threads in haskell, is that for real?
20:02:32 <edwardk> gubagem: sounds like erlang
20:02:42 <shapr> But could you do it with...
20:02:45 <shapr> dialgebras?
20:02:52 <edwardk> di di di
20:02:59 <conal> gubagem: as far as i know, my recent frp implementation (in the "simply" paper) is the first multi-threaded pure frp implementation.  i don't really know how well it performs yet.
20:03:02 <sjanssen> gubagem: thousands is certainly doable, 100k might be a bit much
20:03:12 <atp> i sense a meme coming on
20:04:03 <thetallguy> conal: sure you don't just have mosquitoes?
20:04:03 <lambdabot> thetallguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:04:06 <conal> the new frp threading is all hidden in the implementation of an "unambiguous choice" operator, with purely functional semantics.
20:04:24 <conal> thetallguy: mosquitoes??
20:04:43 <shapr> di pro pre futu so la te di!
20:04:43 <thetallguy> buzzing in your ears
20:04:48 <conal> oh!
20:04:52 <thetallguy> shapr is speaking in tongues
20:04:57 * shapr sings the morphism song
20:05:07 <shapr> It's like do re mi, but for morphisms.
20:05:14 <edwardk> oh yeah, conal: http://flint.cs.yale.edu/trifonov/papers/pfrp.pdf has far better semantics than what i was talking about the other day, yet still ditches the global clock.
20:05:15 <thetallguy> conal: btw, I'm getting closer to answering your question about handling external commands...
20:05:26 <thetallguy> conal: I suspect you've forgotten asking by now...
20:05:44 <conal> edwardk: i read that paper.  wasn't too excited.
20:06:17 <conal> hey all, i'm leaving for belgium tomorrow morning and will be there for 3 months -- until icfp.
20:06:19 <edwardk> yeah me neither, but i can at least see the utility of blur and shuffle to model the fact that the events lose ordering across process boundaries
20:06:22 <shapr> conal: Have fun!
20:06:30 <shapr> conal: Will be offline during that time?
20:06:34 <conal> shapr: thx!
20:06:35 <thetallguy> shapr: that song keeps changing tune...
20:06:45 <edwardk> that reminds me i need to actually see if i can still get an affordable flight to iceland
20:06:45 <shapr> edwardk is making up new notes.
20:06:50 <conal> shapr: i'll be online.  typically at different times.
20:07:01 <gubagem> I like this part where it talks about merging a sorted infinite stream of sorted infinite streams into a single sorted infinite stream
20:07:08 <thetallguy> conal: have a good trip.  Bring us back a belgian fry
20:07:09 <shapr> Has anyone built ghc 6.8 or 6.9 for the OLPC XO?
20:07:25 <conal> i'll be working on FRP-based authoring of reactive 3D content.
20:07:34 <shapr> Cool!
20:07:43 <conal> gubagem: in my "simply" paper?
20:07:56 <conal> thetallguy: with mayo?
20:08:04 <nolrai_> @ty Control.Monad.forM
20:08:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
20:08:08 <cjs> If it's infinite in length, do you then care whether the sort is O(n log n) or O(n^2) or whatever?
20:08:17 <cjs> :-)
20:08:20 <nolrai_> @hoogle for
20:08:20 <lambdabot> Data.Traversable.for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
20:08:20 <lambdabot> Control.Monad.forM :: Monad m => [a] -> (a -> m b) -> m [b]
20:08:20 <lambdabot> Control.Monad.forM_ :: Monad m => [a] -> (a -> m b) -> m ()
20:08:28 <shapr> foo, only ghc 6.6.1 is available in the default olpc repo.
20:09:11 * shapr notes that cjb is extremely helpful for all things XO
20:09:31 <gubagem> conal: well its on conal.net so it probably is yours
20:09:36 <gubagem> yes the simply one
20:10:18 <cjb> shapr: I'm helpful because I expect there's a good chance that my help will be shared/magnified/turned into code ;-)
20:10:19 <thetallguy> conal: or vinegar
20:10:25 <shapr> cjb: smart!
20:10:45 <nus> so, IIUC, an FRP application could be it's own scheduler?
20:11:54 <edwardk> cjb: sneaky
20:12:12 <edwardk> cjb: i think shapr is trying to force an xo into my hands for the same reasons ;)
20:12:15 <conal> nus: probably so.  perhaps using derivative bounds and such to adaptively schedule sampling of continuous behaviors in such a way as to minimize error.
20:12:31 * shapr grins evilly
20:13:17 <Maciej> Does anyone know what's the current status of Lava?
20:13:22 <edwardk> hot
20:13:23 <shapr> It's still alive?
20:13:37 <shapr> I thought Satnam Singh pretty much abandoned it when he left Xilinx?
20:13:55 <Maciej> Is there support for full VHDL language?
20:14:08 <shapr> Last I heard the only use of Lava in the wild was the version for which Chalmers had a special dispensation from Xilinx.
20:14:09 <gubagem> vhdl?
20:14:31 <thoughtpolice> shapr: people've gotten xmonad working on the XO; when looking at it on the xmonad wiki, it looked like the person just installed it and X11 using yum
20:14:37 * shapr tries that
20:14:53 <shapr> thoughtpolice: Er, does xmonad build with ghc 6.6.1?
20:15:02 <sjanssen> yes
20:15:30 <shapr> Maciej: I thought Lava produced netlists directly, but it's a been a long time.
20:15:58 <shapr> There was a GPL version up on the Xilinx website for three days or so, but I didn't get around to downloading it then :-(
20:15:59 <shapr> I wish I had.
20:16:13 <shapr> Then Xilinx pulled it.
20:16:55 <Maciej> shapr: I had a glance trough the code. There is a converter for VHDL.
20:16:59 <nus> conal, also looks like a nice way for an application to cooperate with the real evaluation planner, providing 'hints' upstream
20:17:03 <shapr> Where'd you find the code??
20:17:12 <shapr> Maciej: Do you have the chalmers flavor?
20:17:32 <Maciej> I'm not sure
20:17:32 <shapr> Did YOU download it during those three days it was online?
20:17:37 * shapr wants to know!
20:17:53 * shapr boings fractiously
20:17:57 <Maciej> Oh yes, it is the chalmers version: http://www.cs.chalmers.se/~koen/Lava/download.html
20:17:58 <lambdabot> Title: The Lava Homepage: Download
20:18:34 <shapr> Maciej: I know that version is different from what was up at Xilinx, but I don't know what the differences were.
20:19:08 <shapr> Maciej: Have you tried it?
20:19:20 <shapr> I've never gotten around to getting a Xilinx FPGA.
20:19:39 <Maciej> shapr: Not yet.
20:20:11 <SamB_XP> what was wrong with http://raintown.org/lava/lava-0.2.tar.gz ?
20:20:41 <idnar> @src isSuffixOf
20:20:42 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
20:20:52 * idnar rolls his eyes
20:20:55 <idnar> @src isPrefixOf
20:20:55 <lambdabot> isPrefixOf [] _          = True
20:20:55 <lambdabot> isPrefixOf _  []         = False
20:20:55 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
20:20:59 <shapr> SamB_XP: I've never seen that!
20:21:25 <SamB_XP> I should really try that at school sometime...
20:21:27 <shapr> I only have 0.1a in my Haskell dir.
20:21:53 <chessguy> i had to laugh at a problem i had to solve for an interview today
20:22:49 <SamB_XP> because, you know, I haven't got anywhere near enough space to install the ISE
20:22:55 <Maciej> shapr: The Xilinx version is only for FPGAs?
20:22:55 <noecksit> hello, is ghc-6.8.2 compilable on the gentoo overlay? i get an error saying econf failed
20:22:56 <SamB_XP> nor have I an FPGA
20:23:01 <chessguy> it was like "here's a definition of fibonacci: fib(1) = 1; fib(2) = 1; fib(n) = fib(n-1)+fib(n-2). now write a recursive definition of fib"
20:23:05 <noecksit> the error is "checking for path to top of build tree... pwd: timer_create: Operation not supported"
20:23:25 <SamB_XP> however, my school has like 5 or 7 of them
20:23:47 <chessguy> i had to try hard to not write "remove the parens and feed into ghc
20:23:52 <chessguy> done."
20:24:20 <joed> Work eh...
20:24:21 <SamB_XP> is step 1 even needed?
20:24:33 <shapr> Maciej: That's what I thought.
20:24:36 <cjs> chessguy: Oh, that's got to be funny.
20:24:36 <SamB_XP> @let fib(1) = 1; fib(2) = 1; fib(n) = fib(n-1)+fib(n-2)
20:24:37 <lambdabot> Defined.
20:24:52 <SamB_XP> > fib 0
20:24:55 <lambdabot>  Exception: stack overflow
20:24:58 <SamB_XP> > fib 1
20:24:59 <lambdabot>  1
20:25:00 <gubagem> couldnt you keep the parentheses even
20:25:04 <SamB_XP> > fib 2
20:25:05 <lambdabot>  1
20:25:07 <chessguy> > fib(9)
20:25:08 <lambdabot>  34
20:25:12 <chessguy> true
20:25:16 <gubagem> >fib(40)
20:25:35 <SamB_XP> gubagem: missed a space you have
20:25:45 <gubagem> oh i thought it was just taking a long time
20:25:50 <Maciej> SamB_XP: This version seems to bee more up to date.
20:25:51 <gubagem> > fib(40)
20:26:01 <lambdabot>  Exception: Time limit exceeded
20:26:06 <gubagem> > fib(20)
20:26:08 <lambdabot>  6765
20:26:14 <SamB_XP> Maciej: which version, the chalmers one?
20:26:25 <SamB_XP> yes the xilinx one is surely bitrotted regardless
20:27:03 <SamB_XP> shapr: btw there is also a webpage at http://raintown.org/lava
20:27:08 * shapr looks
20:27:09 <lambdabot> Title: The Lava Hardware Description Language
20:27:41 <Maciej> SamB_XP: The raintown version
20:27:44 <chessguy> it was a pain in the butt to come up with an imperative method to do it, especially since step 2 was to improve the method, so i had to write a naive recursive one, and then a linear iterative, but still imperative, one
20:28:12 <SamB_XP> what is this imperative of which you speak?
20:28:24 <chessguy> it's der suckage
20:28:36 <gubagem> i wanna see i wanna see
20:29:23 <chessguy> hm?
20:29:25 <SamB_XP> you should have printed out "the evolution of a Haskell programmer" for them
20:29:33 <chessguy> haha
20:29:39 <chessguy> that would've been awesome
20:29:45 <chessguy> i thought that was for factorial though
20:29:46 <monochrom> This interview shows you the existence of dumb questions.
20:30:07 <chessguy> monochrom:  oh, it gets better: the second question was applying a design pattern :)
20:30:07 <SamB_XP> hey, have we added augustss' C version of fib to that ?
20:30:39 <SamB_XP> chessguy: did you mumble something about using typeclasses
20:30:40 <SamB_XP> ?
20:30:55 <chessguy> oh man, i so wanted to
20:31:00 <monochrom> It is especially ironic because it is the practitioners themselves who cry "who cares about fib apart from academics".
20:31:38 <SamB_XP> of course, the academics care about fib about as much as the practitioners care about hello world
20:31:39 <chessguy> it was actually a good interview though
20:32:15 <SamB_XP> (Some of the ones in "the evolution" were trying to parallel GNU Hello, no doubt. But I've yet to see a fib that can read email...)
20:32:42 <nus> chessguy, what was the good part?-)
20:33:14 <SamB_XP> ... the part where they told you you didn't have to take the job?
20:33:15 <ddarius> SamB_XP: The evolution of a Haskell programmer is factorial as chessguy suggests.
20:33:27 <monochrom> It's hard to create a joke on fib reading email... :)
20:33:36 <SamB_XP> ddarius: oh. was there a difference?
20:34:05 <chessguy> nus:  absolutely kicking butt on the test, and then also finding out that there is a company who actually believes in and practices iterative development
20:34:17 <SamB_XP> each is a silly example that the "practitioners" claim nobody cares about
20:34:33 <SamB_XP> why doesn't they have fib in the evolution too?
20:35:04 <SamB_XP> chessguy: what is the other kind of development that companies believe in?
20:35:10 <ddarius> SamB_XP: The evolution of a Haskell programmer isn't different programs, it's different ways of implementing factorial.
20:35:10 <chessguy> waterfall
20:35:11 <monochrom> fib is a different evolution. I mean, one evolution, one function. don't be confusing.
20:35:22 <SamB_XP> well, why isn't it a series then
20:35:34 <SamB_XP> with a "fact" and a "fib" and so on
20:35:43 <monochrom> someone hasn't found time to write an evolution of fib, ok?
20:35:49 <SamB_XP> okay okay
20:36:09 <SamB_XP> chessguy: who believes in that anymore?
20:36:29 <monochrom> it's like asking "why hasn't there been a haskell ffi binding for mathematica"
20:36:39 <dolio> I'm not sure you could get as many examples out of fib.
20:36:41 <chessguy> SamB_XP:  my last company, for one
20:37:06 <ddarius> monochrom: There sorta is one.
20:37:06 <cjs> A lot of companies *say* they're agile now, but aren't anyway.
20:37:14 <monochrom> interesting
20:37:26 <chessguy> cjs:  how do you define whether or not a company is agile?
20:37:27 <dolio> Although you could do histomorphisms.
20:37:52 <cjs> I don't define it. I know it by looking at how they work. And anyway, it's a continuum, not an on/off kinda thing.
20:37:52 <nus> dolio, well, interval arithmetics could be thrown @ fib, too (-:
20:37:58 * gubagem figures tommorow is another day as his eyes droop 
20:38:07 <chessguy> cjs:  fair enough
20:38:15 <ddarius> nus: We could apply abstract stone duality.
20:38:22 <chessguy> cjs:  except that you just described it in a very boolean fashion :)
20:38:22 <SamB_XP> I've yet to see an instance where tomorrow is not another day
20:38:23 <monochrom> I use Extreme Typing.
20:38:26 <cjs> (I do XP coaching, BTW, if an argument from authority helps.)
20:38:30 <cjs> :-)
20:38:48 <cjs> chessguy: Yeah, I shoulda said "not very agile."
20:38:49 <SamB_XP> monochrom: I use more extreme typing
20:39:04 <atp> my typing is even more extreme
20:39:07 <atp> ha
20:39:14 <SamB_XP> atp: what typing do you use?
20:39:17 <nus> ddarius, "The evolution strikes back with constructive math and Fibonacci" ?-)
20:39:43 <SamB_XP> can you do ASD in Haskell?
20:39:48 <chessguy> cjs:  i'd like to discuss more of this. got time to talk in -blah?
20:40:05 <cjs> chessguy: Sure. #haskell-blah?
20:40:12 <chessguy> cjs:  correct
20:40:47 <SamB_XP> it's over here!
20:43:28 <atp> SamB: dvorak, of course
20:43:45 <mmorrow> asdfasd;lkjh https://trac.ccs.neu.edu/trac/larceny/browser/trunk/larceny_src/Asm/Intel/Experiments?rev=2790
20:43:49 <shapr> atp: Are you using the "I am not a Koala" modified dvorak layout?
20:43:52 <lambdabot> http://tinyurl.com/5utqbf
20:43:57 <SamB_XP> atp: I think dependent typing is more extreme than dvorak, don't you agree?
20:43:59 <atp> shapr: no, what's that?
20:44:22 <atp> SamB_XP: i don't know... i'm not sure it's good to be dependent on typing, even if it is dvorak
20:44:26 <shapr> atp: It moves all the modifier keys under the thumbs so you don't have to chord with your pinkies. Gets rid of emacs pinky entirely.
20:44:34 <atp> hm
20:44:37 <mmorrow> that link is to ==> {ccall,linker,tailcall}.scm loader.c winloader.c
20:44:51 <SamB_XP> even hindly-milner is more extreme than dvorak
20:44:59 <atp> shapr: haven't heard of it, actually.  i remap most of my emacs keys anyway, and since i started out on sun boxes my ctrl is always on caps-lock
20:45:00 <shapr> atp: I use a kinesis QD keyboard though.
20:45:14 <atp> shapr: but i typically swap alt & ctrl in emacs
20:45:22 <solrize> @y f = f (y f)let
20:45:23 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . ? @ v
20:45:35 <solrize> @let y f = f (y f)
20:45:35 <lambdabot> <local>:2:9:     Ambiguous occurrence `y'     It could refer to either `L.y',...
20:45:42 <atp> shapr: and i have a lot of commonly used keys (like movement keys and suchlike) mapped to the home row
20:45:44 <mmorrow> https://trac.ccs.neu.edu/trac/larceny/browser/trunk/larceny_src/Asm/Intel/Experiments/ccall.scm?rev=2790
20:45:45 <lambdabot> http://tinyurl.com/5ljhxm
20:45:47 <solrize> @let yy f = f (yy f)
20:45:48 <lambdabot> Defined.
20:45:51 <solrize> :t yy
20:45:53 <lambdabot> forall t. (t -> t) -> t
20:45:58 <shapr> atp: Do you use emacs?
20:46:04 <atp> shapr: less these days
20:46:21 <shapr> Ah, I have a bunch of emacs bindings for efficiency.
20:46:21 <SamB_XP> atp: what do you use instead?
20:46:42 <solrize> @let fac = yy (\f n -> if (n==0) then 1 else n * f (n-1))
20:46:42 <lambdabot> Defined.
20:46:46 <atp> SamB_XP: i don't.  nothing beats emacs, it's not that i've replaced it
20:46:49 <solrize> >fac 7
20:47:06 <SamB_XP> atp: so... you've been editing less text?
20:47:10 <atp> SamB_XP: it's that i spend most of my time at work and they won't let me use emacs there, as i've mentioned
20:47:19 <solrize> > fac 7
20:47:20 <lambdabot>  5040
20:47:23 <atp> SamB_XP: yeah, pretty much.
20:47:53 <atp> SamB_XP: also, while i lived in China, chinese + unicode was really broken in emacs (this has since been fixed) so i started using vim a lot
20:48:13 <atp> SamB_XP: i don't actually like vim much, but i use it for a lot of one-off editing tasks
20:48:21 <atp> as a result of the habit i formed
20:48:57 <brad`> i just tried installing the xml package (the galois binding). after a succesful installation, ghc-pkg shows it being in my "user" registery, but when i try to bring it into ghci with ":m Text.XML.Light", i see "module main:Text.XML.Light is not loaded". any ideas???
20:49:14 <shapr> hi brad, welcome to Haskellers Anonymous.
20:49:19 <monochrom> solrize: you can use "fix" in place of "yy".
20:49:27 <brad`> hi shapr
20:49:41 <shapr> My name is shapr, and I'm a Haskeller.
20:49:47 <atp> hi shapr
20:49:55 <roconnor> hi shapr
20:50:10 <monochrom> hi shapr
20:50:11 <shapr> brad`: Er, but seriously... did you install it as a different user?
20:50:12 * ddarius isn't very anonymous.
20:50:16 <atp> my name is atp, and i'm a haskeller.  i've been side-effect free for three months now.
20:50:21 <shapr> hi atp
20:50:31 <solrize> :t fix
20:50:31 <roconnor> hi atp
20:50:32 <lambdabot> forall a. (a -> a) -> a
20:50:42 <roconnor> @hoogle fix
20:50:43 <lambdabot> Data.Function.fix :: (a -> a) -> a
20:50:43 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:50:43 <lambdabot> Control.Monad.Fix :: module
20:50:51 <atp> last week i was tempted to use mutable state, but thanks to the help i've gotten in #haskell, i was able to overcome that urge.
20:50:53 <atp> haha
20:50:57 <atp> anyway, i've got to go to bed
20:50:58 * shapr cheers for atp
20:50:59 <atp> night guys
20:51:03 <shapr> g'night!
20:51:05 <sjanssen> brad`: 'cd ..' -- ghci gets confused when you're in a source directory with that module
20:51:05 <brad`> no shapr, it appears to be in my own "user" registry
20:51:12 <brad`> OH!
20:51:28 <solrize> monochrom i thought Y could not be typed ... ?
20:51:46 <monochrom> But yy and fix can be.
20:51:46 <mmorrow> everything you never wanted to know about stdcalls: http://msdn.microsoft.com/en-us/library/cc267763.aspx
20:53:16 <monochrom> Y cannot be typed because it provides recursion without using language builtin recursion.
20:53:43 <monochrom> yy and fix can be typed because they provide recursion by using language builtin recursion.
20:53:54 <monochrom> I guess that's confusing :)
20:53:57 <mmorrow> *prime* quote: Actually, I'm sure you can decompile VB6. My friend used VB6 to draw some GUI's (the program is from microsoft) and then he did the coding and everything. I used a VB decompiler and I was able to get past his password on the program. Not sure if that's what you mean but I'll throw it out there anyways.
20:54:02 <shapr> brad`: What?
20:54:38 <monochrom> Y is a lambda term that cannot be typed.  yy and fix are implemented by recursion, not Y's lambda term.
20:55:37 <roconnor> monochrom: Y can be typed: http://r6.ca/blog/20060919T084800Z.html
20:55:37 <lambdabot> Title: Y Combinator in Haskell
20:56:47 <monochrom> That blog is implemented by recursion.
20:57:05 <mrd> \ f. (\ x. f (x x)) (\ x. f (x x ))  -- i just typed it
20:57:13 <brad`> thanks sjanssen, you were right, take care folks
20:57:38 <monochrom> "newtype Mu ... = ... Mu ..." uses as much language builtin recursion as "yy ... = ... yy ..."
20:58:19 <monochrom> mrd does Extreme Typing too :)
21:00:02 <solrize> oh, i see, fix is implemented with recursion which is a syntactic hack that is essentially Y under the clothes
21:01:04 <mrd> if you flash your Y in public you'll go to jail
21:01:25 <monochrom> naughty
21:01:43 <ddarius> If we had equi-recursive types though...
21:02:08 <ddarius> solrize: Perhaps semantically, but operationally the Y combinator is a crappy choice.
21:02:10 <mrd> ...we'd still be waiting for ghc to compile our programs?
21:02:13 <roconnor> ddarius: ... we'd catch a lot fewer errors?
21:02:19 <solrize> ddarius yes of course ;)
21:02:26 <monochrom> hahahaha mrd
21:02:38 <solrize> equi-recursive?
21:02:44 <mmorrow> http://cm.bell-labs.com/cm/cs/who/dmr/clcs.html
21:03:18 <mmorrow> The C Language Calling Sequence
21:03:18 <mmorrow>     S. C. Johnson
21:03:18 <mmorrow>     D. M. Ritchie
21:03:18 <mmorrow>     Bell Laboratories
21:03:18 <mmorrow>     September, 1981
21:03:36 <ddarius> solrize: You know those type errors like, "Occurs check failed: a = a -> b would give infinite type"?  Equi-recursive types would accept all of those.
21:03:51 <mmorrow> http://en.wikibooks.org/wiki/Reverse_Engineering/Calling_Conventions
21:03:52 <lambdabot> Title: x86 Disassembly/Calling Conventions - Wikibooks, collection of open-content text ..., http://tinyurl.com/6hyx4o
21:04:18 <MoonPatrol> what the fuck is a monad
21:04:33 <shapr> It's an abstraction, just like objects are abstractions.
21:04:52 <solrize> wow, a reverse engineering wikibook
21:05:01 <MoonPatrol> but this guy on dal net was telling me how object-oriented programming was like god, how it doesn't exist.
21:05:02 <shapr> MoonPatrol: Does that answer your question?
21:05:12 <shapr> Er... ok?
21:05:13 <dobblego> he's a crazy guy
21:05:18 <MoonPatrol> WHOA!
21:05:20 <MoonPatrol> you're everywhere.
21:05:21 <dobblego> :)
21:05:33 <monochrom> troll orange alert
21:05:48 --- mode: ChanServ set +o sjanssen
21:06:03 <dobblego> it's ok; I was getting a bit out of hand
21:06:13 <conal> MoonPatrol: Monad is an interface that several useful types implement
21:06:14 <dobblego> there are many monad tutorials available
21:07:06 <dobblego> a monad is essentially, two functions and three laws about those functions
21:07:21 <dobblego> @google you cound have invented monads
21:07:22 <lambdabot> http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
21:07:22 <lambdabot> Title: Yet Another Language Geek : The Marvels of Monads
21:07:26 <dobblego> @google you could have invented monads
21:07:26 <conal> so Monad is nothing particularly special.  it's not integral to haskell in any way.
21:07:27 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
21:07:27 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
21:07:29 <mmorrow> preflex: nickometer MoonPatrol
21:07:29 <preflex>  MoonPatrol is 0% lame
21:07:35 <mmorrow> lucky
21:07:36 <dobblego> MoonPatrol, try reading that ^^
21:08:12 <dobblego> MoonPatrol, if you have any questions, please feel free to ask in here
21:08:47 <shapr> MoonPatrol: You know how object oriented programming is a way of thinking about code that makes it easy to stick bits together and have them work after connecting them?
21:09:13 <shapr> Monads are just a different way of sticking bits of code together, with the same goal... that they work the same way before and after being connected.
21:09:31 <SamB_XP> shapr: ... since when is that what OO is?
21:09:54 <shapr> That's the goal at least, yeah?
21:10:01 <shapr> hiya coffeemug!
21:10:06 <SamB_XP> how often is it achieved?
21:10:22 <shapr> well
21:10:29 <ddarius> SamB_XP: Depends on the problem and the implementors.
21:10:33 <coffeemug> hi shapr
21:10:38 <coffeemug> hello everyone
21:10:50 <geezusfreeek> a good OO programmer can still manage to make their code composable, much of the time
21:11:00 <geezusfreeek> it is just... not worth the effort to me ;)
21:11:19 <MoonPatrol> interesting
21:11:36 <MoonPatrol> I feel like I just got on a rowboat and jumped in the ocean.
21:11:51 <shapr> We're the helpful dolphins around you.
21:11:51 <dobblego> MoonPatrol, welcome to programming in the real world :)
21:12:02 * shapr brings a tasty fish to MoonPatrol 
21:12:13 <mmorrow> http://en.wikipedia.org/wiki/X86_calling_conventions
21:12:16 * geezusfreeek fends off an OO shark
21:12:45 * shapr grins
21:12:54 <mmorrow> MoonPatrol: hope you brought you poncho and rubber ducky!!@
21:13:04 <sw17ch> i think i've asked this before, but i need a way to use something like Control.Monad.forever with a check to a "stop" condition each time through
21:13:19 <sw17ch> (in this case, checking i we've consumed all the input yet)
21:13:23 <MoonPatrol> im still not quite following what is entirely bad about OO though
21:13:37 <MoonPatrol> or at least some of the concepts
21:13:57 <Pseudonym> Is OO bad?
21:14:03 <Pseudonym> I thought it was just different.
21:14:10 <geezusfreeek> sw17ch: maybe you would like mfix?
21:14:13 <MoonPatrol> well i have no idea what it is anymore
21:14:21 <dobblego> is what Java calls OO bad?
21:14:23 <Pseudonym> The enemy is mutable global state.  OO replaces this with lots of local states.  FP replaces this with no state.
21:14:34 <MoonPatrol> its just what they were cramming into our heads in college
21:14:40 <Pseudonym> dobblego: What Java calls OO is, according to Alan Perlis, not OO.
21:14:47 <Pseudonym> Or was it Kay?
21:14:48 <monochrom> FP replaces state by church.  <duck>
21:14:57 <dobblego> Pseudonym, and I'd have to agree
21:15:06 <geezusfreeek> dobblego: i would say Java's OO is bad. in my opinion, OO is best in dynamic languages, but a lot of people yell at me for that one
21:15:08 <Pseudonym> I think it was Kay.
21:15:12 * Pseudonym gets his alans confused
21:15:17 <joed> can you make it billable hours though?
21:15:27 <geezusfreeek> Kay said C++ is not OO
21:15:33 <sw17ch> geezusfreeek, i don't think so
21:15:34 <geezusfreeek> nothing about Java that i can recall
21:15:38 <Korollary> Kay says a lot of things
21:15:44 <sw17ch> but close
21:15:49 <geezusfreeek> sw17ch: okay, what kind of type should this function have then?
21:16:14 <thetallguy> MoonPatrol: I've been musing about this explanation of why OO is bad
21:16:47 <dobblego> personally, I consider OO to be an anti-concept, so it is neither good nor bad
21:16:49 <thetallguy> MoonPatrol: it originated with smalltalk and graphical UI's, where they were trying to make interfaces that felt like real objects
21:16:51 <geezusfreeek> Pseudonym: yes that is how i think of it often as well
21:16:54 <sw17ch> geezusfreeek, well, i'm not sure
21:17:00 <sw17ch> a monadic version of takeWhile
21:17:14 <thetallguy> MoonPatrol: the problem is, real objects are nothing like objects in memory
21:17:17 <geezusfreeek> @hoogle takeWhile
21:17:18 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
21:17:18 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
21:17:18 <lambdabot> Data.ByteString.takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
21:17:19 <sw17ch> i could be wrong about the mfix thing, i'm just not all that familiar with it
21:17:27 <shapr> MoonPatrol: Personally, I think OO is just different from the monadic abstraction. They both have advantages.
21:17:41 <geezusfreeek> sw17ch: so something like (a -> Bool) -> m a -> m a?
21:17:44 <MoonPatrol> i've never even heard of the monadic abstraction
21:17:44 <thetallguy> MoonPatrol: they can't be copied arbitrarily, for example
21:17:54 <sw17ch> geezusfreeek, yes
21:17:58 <sw17ch> that's the one
21:18:02 <shapr> MoonPatrol: Well, there's a bunch of cool stuff out there in the world :-)
21:18:11 <shapr> MoonPatrol: Have you done anything with stack based languages?
21:18:14 <sw17ch> ... except that the (a -> Bool) isn't quite that
21:18:26 <MoonPatrol> shapr, finished my first year of CS, so no not really
21:18:28 <geezusfreeek> a -> m Bool?
21:18:29 <thetallguy> MoonPatrol: computational objects seem more like mathematics to us FP folks
21:18:30 <sw17ch> because my situation needs the monad to check something about it self...
21:18:30 <Pseudonym> Java is essentially Modula-3 with a C-like syntax, correct?
21:18:32 <SamB_XP> I've never seen an OO system I truly liked for being OO that was not dynamic...
21:18:34 <Pseudonym> At least Java 1.0 is.
21:18:52 <sw17ch> geezusfreeek, bah ,here's what i'm doing... i'm reading in a PCM file and parsing out the RIFF data sections
21:19:10 <Pseudonym> I think that Modula-3 was more explicit about the fact that what Java calls an "object" is actually an instantiable module.
21:19:12 <sw17ch> all fine and dandy, but i want it to keep looking for sub chunks while there's still data in the BytEString
21:19:12 <thetallguy> Pseudonym: interesting.  Modula-3 didn't have a set run-time
21:19:15 <shapr> MoonPatrol: #haskell has a bunch of different computer science ideas flowing past all the time, if you hang out here you'll quickly be exposed to lot sof nifty stuff.
21:19:24 <Pseudonym> Not that there's anything wrong with instantiable modules.
21:19:29 <sw17ch> Data.Binary.Get provides remaining which returns an Int64 with the number of bytes left
21:19:37 <thetallguy> Pseudonym: but I think otherwise you're not far off.
21:19:39 <shapr> MoonPatrol: You should make up your own mind about how the monadic abstraction compares to the object oriented abstraction.
21:19:54 <sw17ch> i want this function f to check whether or not remaining produces n >0 before applying the monad again
21:19:59 <MoonPatrol> shapr: its kind of hard since its all new to me
21:20:03 <solrize> pseudonym not really, java has a lot of reflection hair and is spec'd in terms of a virtual machine that has to enforce security on class instances (i.e. it assumes there are malicious objects running inside the jvm)
21:20:13 <sw17ch> this sounds so easy, but i'm having a hard time wrapping my head around it... :\
21:20:17 <shapr> MoonPatrol: Personally, I think the prototype oriented abstraction is superior to the object oriented abstraction, because I don't like having two different axes, class and instance.
21:20:25 <MoonPatrol> now i feel kind of stuck and don't know what i should be learning
21:20:28 <SamB_XP> MoonPatrol: what are you taking CS for?
21:20:31 <shapr> MoonPatrol: Well, grab onto a nearby life preserver and ask the friendly dolphins!
21:20:31 <thetallguy> MoonPatrol: no hurry on monad opinions
21:20:44 <sw17ch> shapr, are dolphins usually friendly?
21:20:52 <geezusfreeek> shapr: yes, JavaScript and Io FTW!
21:20:52 <MoonPatrol> SamB_XP, to do cool things with computers, I'd like to do distributed computing type things
21:20:56 * thetallguy thinks of shapr more as a kangaroo, what with all the boinging
21:21:02 <shapr> Hah!
21:21:07 <shapr> thetallguy: Was I boinging when you met me?
21:21:13 <shapr> sw17ch: Sure!
21:21:17 <shapr> sw17ch: Unless you're a fish.
21:21:18 <Pseudonym> solrize: Ignoring the VM for the moment, I'm thinking about the language specifically.
21:21:25 <sw17ch> shapr, or a shark?
21:21:26 <thetallguy> shapr: I decline to answer...
21:21:27 <sw17ch> :)
21:21:33 <Pseudonym> The reflection stuff is interesting, I take your point on that.
21:21:36 <solrize> monads are a traditional stumbling block for beginning haskellers, just like understanding recursion for beginning programmers in more traditional languages
21:21:38 <shapr> thetallguy: I honestly don't remember :-)
21:21:38 <sw17ch> MoonPatrol, I just finished my undergrad CS work... :)
21:21:44 <shapr> thetallguy: C'mon, we had lunch together at ICFP, yeah?
21:21:55 <thetallguy> shapr: i don't remember it until the channel
21:21:57 <thetallguy> later
21:22:00 <SamB_XP> MoonPatrol: since when do they cover that in an undergrad CS program?
21:22:18 <MoonPatrol> SamB_XP they don't, its just something I'd like to be able to learn about and do
21:22:18 <shapr> sw17ch: Now that you mention it, sharks do get really friendly in some cases.
21:22:23 <solrize> pseudonym the original gcj implementers said "oh this is just a c++ subset with slightly different surface syntax, so we'll write a gcc front end for it, use the normal gcc code generator and that will be that"
21:22:31 <thetallguy> shapr: you were lively, but I don't remember explicit boinging
21:22:40 <shapr> Heh, ok :-)
21:22:43 <solrize> but they had to punt that approach pretty much totally
21:22:46 <thetallguy> so, what's zip `ap` tail all about?
21:22:48 <MoonPatrol> what fucking network am i on anyway?
21:22:49 <shapr> thetallguy: I was actually being shy...
21:22:58 <shapr> MoonPatrol: This is freenode. Not nearly enough sex here :-(
21:22:58 <solrize> i'm not sure quite what the issues are though
21:23:03 <SamB_XP> MoonPatrol: this is the same old freenode
21:23:11 <solrize> that would be on #haskell-blah :)
21:23:26 <shapr> solrize: exactly
21:23:30 <MoonPatrol> oh okay, haha, cause i was on dal too, i didn't know if my client screwed up or not
21:23:32 <SamB_XP> MoonPatrol: there are other networks?
21:23:37 <thetallguy> ?type zip `ap` tail
21:23:39 <lambdabot> forall b. [b] -> [(b, b)]
21:23:46 * SamB_XP is kidding
21:23:50 <sw17ch> SamB_XP: I covered distributed and high performance computing in undergrad
21:23:56 * SamB_XP is actually connected to no less then four on this computer
21:24:10 <thetallguy> > (zip `ap` tail) [1..5]
21:24:11 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
21:24:44 <thetallguy> > (zip3 `ap` tail) [1..5]
21:24:44 <MoonPatrol> so im not sure if i should even be bothering to learn C++ or Java, or what i should be doing, or should i be learning haskell or what
21:24:45 <lambdabot>  Add a type signature
21:24:57 <dobblego> MoonPatrol, that's a no-brainer
21:24:59 <Korollary> you should learn them all
21:25:01 <MoonPatrol> i want to learn it all, but i know i have to go down some certain path at a point
21:25:07 <ddarius> What Korollary said and then some.
21:25:17 <thetallguy> MoonPatrol: what's your current working set?
21:25:18 <SamB_XP> Java is too boring for me to learn
21:25:20 <MoonPatrol> because i know what they will want me to knwo and be able to do
21:25:24 <shapr> MoonPatrol: Just pick one that looks good, learn it, and get back to the others later.
21:25:27 <MoonPatrol> Java and some C/C++ at the moment
21:25:28 <geezusfreeek> MoonPatrol: distributed computing? Erlang is a good choice for that
21:25:38 <shapr> MoonPatrol: #haskell is just over seven years old now, we'll still be here if you decide to come back later :-)
21:25:50 <shapr> MoonPatrol: And I bet #haskell is far more friendly than most programming language communities you'll find.
21:26:00 <thetallguy> shapr: unless you boing us into orbit
21:26:07 <MoonPatrol> shapr, definitely talks about much more interesting things than "hey guys i have a homework question.."
21:26:11 <mmorrow> MoonPatrol: whatever langs you learn, make sure two are C and Haskell
21:26:11 <Pseudonym> It's a bit disturbing that "C/C++" is taught as one entity.
21:26:11 * shapr BOINGS!
21:26:16 <shapr> MoonPatrol: haha
21:26:28 <MoonPatrol> dobblego there blew me away whenever i busted in on #java on dal net
21:26:32 <shapr> MoonPatrol: Yes, I used to spend time in #java as well.
21:26:38 <thetallguy> MoonPatrol: I'd recommend learning some Haskell. Even if you work in C++ all the time, it will help.
21:26:42 <dobblego> MoonPatrol, I'm good at that :)
21:26:45 <shapr> Though it was here in freenode, not in dalnet.
21:26:53 <Pseudonym> Actually, Haskell helps a lot in understanding recent developments in C++.
21:27:01 <MoonPatrol> i tried to learn C first, but i never got very far in the book
21:27:09 <thetallguy> MoonPatrol: see the recent announcement about the ACM curriculum proposals to include FP
21:27:23 <geezusfreeek> MoonPatrol: haskell will prepare you for languages of the future since most new things seem to be derived from functional languages nowadays
21:27:34 <shapr> Hey, we should have a #haskell birthday party next year.
21:27:44 <shapr> We missed the #haskell birthday by six weeks this time!
21:27:56 <sw17ch> geezusfreeek, i figured out the type signature
21:28:01 <sw17ch> geezusfreeek, replicateWhile :: (Monad m) => m Bool -> m a -> m [a]
21:28:07 <MoonPatrol> i just know that whatever i pick up in college is going to a) have to pay my loans b) buy my girlfriend some fancy toys and c) get me some cool stuff to play with and d) not suck
21:28:19 * araujo wouldn't like to see +300 haskellers drunk in a single room ....
21:28:24 <ddarius> Pseudonym: Haskell helps a lot in understanding recent developments in many mainstream languages.
21:28:37 <shapr> MoonPatrol: You can do that with just about any language for the first few years, but some languages keep on paying back...
21:29:01 <MoonPatrol> whatever i do though, i don't want to be a mediocre and crappy computer scientist that comes out of some diploma mill
21:29:03 <sw17ch> MoonPatrol, learn to learn, what you learn in school besides that is mostly useless
21:29:19 <SamB_XP> sw17ch: since when do they teach that in school?
21:29:36 <sw17ch> SamB_XP, how to learn? or how to do distributed computing... :P
21:29:40 <shapr> MoonPatrol: That's the most important part! As long as you decide to kick ass, you'll be fine!
21:29:42 <SamB_XP> the former of course
21:29:45 <mrd> learning is not useful in industry, why should they teach it in school!
21:29:46 * ddarius didn't learn to learn at school.
21:29:57 <sw17ch> SamB_XP: http://www.calvin.edu/ Liberal arts school.
21:29:58 <lambdabot> Title: Calvin College
21:29:59 <MoonPatrol> sw17ch, i suppose that's why im here, i mean, i guarantee none of my counterparts in the curriculum are doing anything this summer to learn more
21:29:59 <shapr> I didn't learn to learn at school either.
21:30:05 <shapr> I should really get a degree :-/
21:30:11 <SamB_XP> mrd: ... does anyone actually think that?
21:30:30 <shapr> SamB_XP: Very few people at my job actually think about programming after 5pm.
21:30:34 <shapr> I find that sad :-(
21:30:40 <araujo> ha
21:30:40 <Pseudonym> I find it weird that "Calvin" and "liberal" can be used in the same sentence.
21:30:43 <araujo> yeah that happens
21:30:47 * mmorrow looks for that programmer salary link for MoonPatrol
21:30:47 <sw17ch> MoonPatrol, then you're ahead already. to be a good computer scientist, you need to *love* the field. and i mean it, live, eat, breath this stuff
21:31:02 <shapr> Yeah!
21:31:04 <SamB_XP> shapr: it might be good if I didn't do so much thinking about programming before *or* after 5
21:31:07 <shapr> And skip sleep for it!
21:31:07 <mrd> SamB_XP: i'd imagine anyone who only goes to school to get a job ...
21:31:08 <sw17ch> sw17ch, every awesome CSer i know does it, not for the money, but because to them, there is nothing cooler
21:31:09 <shapr> Speaking of which...
21:31:13 <MoonPatrol> i love it, im just afraid that because i don't understand some things that that is going to hold me back
21:31:17 <mmorrow> MoonPatrol: http://theunixgeek.blogspot.com/2008/06/programming-salaries.html
21:31:18 <lambdabot> Title: The Unix Geek: Programming Salaries
21:31:29 <ddarius> MoonPatrol: Then understand them.
21:31:30 <dobblego> MoonPatrol, we all don't understand some things; that's the fun part
21:31:34 <SamB_XP> mrd: what does that have to do with liking to learn or not?
21:31:43 <joed> MoonPatrol: did you want that haskell gig?
21:31:45 <sw17ch> MoonPatrol, don't be afraid of not understanding... why do you think i'm here? I can't figure out this stupid function.. such a simple concept, but i'm entirely lost :)
21:32:28 <MoonPatrol> holy crap, that's a ton of money for a programmer
21:32:33 <sw17ch> can some one verify the $200K thing for me? i don't believe it
21:32:39 <shapr> MoonPatrol: Yeah, I started the #haskell channel without a computer science degree and zero math background... but I learned it!
21:32:44 <MoonPatrol> i suppose thats for language research?
21:32:51 <sw17ch> actually, most of that list seems really high
21:32:54 <joed> shar++
21:33:01 <sw17ch> (I live in Michigan though... and our economy is all sorts of fail right now)
21:33:08 <SamB_XP> I seek to expand the horizons of my knowledge -- invariably this will leave me with more and more that I know I don't know...
21:33:16 <MoonPatrol> shapr, what did you read to get there though?
21:33:17 <mrd> SamB_XP: because if you're "just" learning to get a job, then you probably don't like to do it
21:33:20 <shapr> sw17ch: It's probably because of Credit Suisse, Galois Connections, BlueSpec, and that sort of thing.
21:33:34 <joed> Blah.
21:33:44 <joed> You change that in 3 months.
21:33:48 <SamB_XP> mrd: but ... what relationship does ... learning ... have with ... school?
21:33:52 <shapr> MoonPatrol: Not so much, I spent a lot of time asking questions here on #haskell, and I spent a lot of time reading existing code and trying to write my own code.
21:34:06 <mrd> SamB_XP: up to you :)
21:34:12 <sw17ch> shapr, ... i wish i could find some place like that around here
21:34:21 <SamB_XP> I can't stop learning regardless
21:34:22 <sw17ch> :)
21:34:23 <shapr> sw17ch: If you got the Haskillz, you'll get the job.
21:34:40 <SamB_XP> it's an addiction
21:34:53 <sw17ch> shapr, well, that's just the thing... how good do i need to be? i
21:35:01 <shapr> sw17ch: keep on going till you get hired :-)
21:35:04 <sw17ch> 'm the best haskell programmer i know... but... i'm one of two :)
21:35:05 <MoonPatrol> shapr, so as far as the math goes, no reference books?
21:35:27 <sw17ch> shapr, i'm still trying to get Haskell into Aerospace
21:35:27 <shapr> MoonPatrol: Nah, I read a bunch of wikipedia, haskellwiki, asked questions here, that sort of stuff.
21:35:38 <mmorrow> MoonPatrol: take the abstract algebra two-semester sequence in the math dept at your school, you'll *definitely* not regret it
21:35:45 <sw17ch> MoonPatrol, my best resource for Haskell has been the patience of people in #haskell
21:35:52 <joed> Oh wow.
21:36:15 <shapr> joed: svensk?
21:36:22 <joed> shapr: Yep.
21:36:24 <sw17ch> Any one know how to build this?
21:36:26 <sw17ch> replicateWhile :: (Monad m) => m Bool -> m a -> m [a]
21:36:26 <solrize> haskell is kind of a gateway drug into a lot of math geekdom... i got sidetracked a lot into that stuff from trying to learn haskell.  but i think you don't need to really know much math per se, that isn't fairly straightforward to pick up
21:36:27 <shapr> kul
21:36:38 <joed> shapr: Ere inte :)
21:36:49 <shapr> Hey, I like Sweden :-)
21:36:59 <joed> shapr: satt bara och lysnade.
21:37:15 <shapr> I gotta start hanging out with the Swedes in Boston.
21:37:33 <joed> Send me the questions as I said before.
21:37:41 <geezusfreeek> @type \mcond action -> map fromJust . takeWhile isJust <$> sequence (repeat (do cond <- mcond; if cond then Just <$> action else return Nothing))
21:37:43 <lambdabot> forall a (f :: * -> *). (Monad f, Functor f) => f Bool -> f a -> f [a]
21:38:16 <geezusfreeek> sw17ch: ^ it ain't as pretty as it could be
21:38:20 <shapr> joed: Which questions?
21:38:20 <sw17ch> geezusfreeek, wow!
21:38:24 <Cale> solrize: I agree with that judgement, though I have my own take on it, given that I started learning Haskell during a Bachelor's degree in mathematics. My mathematical knowledge didn't help that much directly in learning Haskell, but thinking in a mathematical way did.
21:38:25 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
21:38:26 * shapr is sleepy and forgetful.
21:38:27 <solrize> if you know some abstract algebra and some calculus (neither are necessary) then this may make sense: most langauges are sort of calculus-like in flavor, while haskell is more algebra-like
21:38:32 <sw17ch> @pl \mcond action -> map fromJust . takeWhile isJust <$> sequence (repeat (do cond <- mcond; if cond then Just <$> action else return Nothing))
21:38:32 <lambdabot> (line 1, column 88):
21:38:32 <lambdabot> unexpected ";"
21:38:32 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
21:38:39 <joed> shapr: any on swedish.
21:38:57 <joed> shapr: I sure as hell won't help you on haskell.
21:38:58 <solrize> so engineers who have studied calculus a lot and had an easy time with other languages still find haskell has a steeper learning curve
21:38:58 <geezusfreeek> pl doesn't like do notation
21:38:59 <shapr> joed: Can you handle antique Swedish from before 1900?
21:39:03 <shapr> joed: haha
21:39:14 <sw17ch> geezusfreeek, i wish it did
21:39:22 <joed> shapr: I actually may be able to push that down on the lines.
21:39:37 * shapr got a few pre-1900 Swedish books today.
21:39:41 <geezusfreeek> sw17ch: there is surely a cleaner way to do it using mfix, but i didn't feel like doing any work beyond using lambdabot
21:39:49 <joed> shapr: I do speak german/french/ecnglis
21:39:56 <shapr> tres bien!
21:40:10 <sw17ch> geezusfreeek, many thanks as it is
21:40:18 <geezusfreeek> sw17ch: if you want to use @pl then you could just manual desugar it first
21:40:20 <sw17ch> i'll spend the next while parsing it though :)
21:40:20 <shapr> joed: What's uppfinnare ?
21:40:32 <joed> shapr: inventor
21:40:34 <geezusfreeek> but i don't think it will come out pretty
21:40:35 <shapr> ah cool!
21:40:38 <shapr> Thanks!
21:40:46 <shapr> Ok now I really have to sleep
21:40:48 * shapr &
21:41:10 <geezusfreeek> sw17ch: don't use that :P
21:41:16 <geezusfreeek> sw17ch: you will infinite loop
21:41:19 <mmorrow> :t replicateWhile mb = let go mb ma = mb >>= \b -> if b then Left () else Right ma >> go mb ma ; fromRight (Right a) = a ; isLeft a | Left _ <- a = True | otherwise = False in sequence . fmap fromRight . takeWhile (not . isLeft) . go mb
21:41:20 <lambdabot> parse error on input `='
21:41:23 <mmorrow> crap
21:41:32 <geezusfreeek> sw17ch: right type, wrong effects
21:41:34 <mmorrow> :t let replicateWhile mb = let go mb ma = mb >>= \b -> if b then Left () else Right ma >> go mb ma ; fromRight (Right a) = a ; isLeft a | Left _ <- a = True | otherwise = False in sequence . fmap fromRight . takeWhile (not . isLeft) . go mb
21:41:35 <lambdabot> <no location info>:
21:41:35 <lambdabot>     not an expression: `let replicateWhile mb = let go mb ma = mb >>= \b -> if b then Left () else Right ma >> go mb ma ; fromRight (Right a) = a ; isLeft a | Left _ <- a = True | otherwise = False
21:41:35 <lambdabot> in sequence . fmap fromRight . takeWhile (not . isLeft) . go mb'
21:42:33 <mmorrow> :t let replicateWhile mb ma = let go mb ma = mb >>= \b -> if b then Left () else Right ma >> go mb ma ; fromRight (Right a) = a ; isLeft a | Left _ <- a = True | otherwise = False in sequence . fmap fromRight . takeWhile (not . isLeft) . go mb $ ma in replicateWhile
21:42:34 <lambdabot>     Couldn't match expected type `[Either t (m a)]'
21:42:34 <lambdabot>            against inferred type `Either () b'
21:42:34 <lambdabot>       Expected type: a1 -> [Either t (m a)]
21:42:47 * geezusfreeek sighs and opens a test editor
21:43:00 <sw17ch> hahaha
21:43:09 <mmorrow> heh
21:43:20 <solrize> cale you've been using agda, right?  that's even geekier than haskell
21:44:01 <sw17ch> ps, what's <$> defined as?
21:44:11 <geezusfreeek> sw17ch: should the conditional be tested before the first execution or after?
21:44:13 <solrize> @src (<$>)
21:44:13 <lambdabot> f <$> a = fmap f a
21:44:19 <sw17ch> geezusfreeek, before for sure
21:44:24 <mmorrow> :t let replicateWhile mb ma = let go mb ma = mb >>= \b -> if b then [return (Left ())] else return (Right ma) : go mb ma ; fromRight (Right a) = a ; isLeft a | Left _ <- a = True | otherwise = False in sequence . fmap fromRight . takeWhile (not . isLeft) . go mb $ ma in replicateWhile
21:44:26 <lambdabot>     No instance for (Error ())
21:44:26 <lambdabot>       arising from a use of `sequence' at <interactive>:1:199-206
21:44:26 <lambdabot>     Possible fix: add an instance declaration for (Error ())
21:44:27 <MoonPatrol> its like 1 am and im chilling out on my couch
21:44:29 <mmorrow> ahhhhhhhh
21:44:48 <MoonPatrol> hey wait a second i can take this to my room...
21:44:48 <MoonPatrol> im on wireless
21:45:39 <nolrai_> @src <*>
21:45:39 <lambdabot> Source not found.
21:45:49 <nolrai_> @src (<*>)
21:45:49 <lambdabot> Source not found.
21:45:58 <nolrai_> eh
21:46:08 <sw17ch> is sequence strict?
21:46:49 <geezusfreeek> sw17ch: yes :(
21:47:02 <sw17ch> geezusfreeek, frick, i understand the problem now :)
21:47:07 <sw17ch> good idea any way...
21:47:22 <geezusfreeek> :t \mcond action -> do cond <- mcond; if cond then liftM2 (:) action (replicateWhile mcond action) else return []
21:47:24 <lambdabot> Not in scope: `replicateWhile'
21:47:28 <sw17ch> this is one of those things that seems so obvious... but when i try to write it... ... nope
21:47:31 <geezusfreeek> whoops
21:47:34 <sw17ch> hehe
21:47:37 <geezusfreeek> :t replicateWhile mcond action = do cond <- mcond; if cond then liftM2 (:) action (replicateWhile mcond action) else return []
21:47:38 <lambdabot> parse error on input `='
21:47:44 <geezusfreeek> bleh
21:47:48 <sw17ch> hpaste?
21:47:54 <geezusfreeek> :t let replicateWhile mcond action = do cond <- mcond; if cond then liftM2 (:) action (replicateWhile mcond action) else return [] in replicateWhile
21:47:55 <lambdabot> forall (t :: * -> *) a1. (Monad t) => t Bool -> t a1 -> t [a1]
21:47:59 <mmorrow> l33t
21:48:10 <geezusfreeek> explicit recursion ftw!
21:48:13 --- mode: ChanServ set -o sjanssen
21:48:14 <mmorrow> FTW
21:48:17 <geezusfreeek> mfix could still be prettier i think
21:48:27 <sw17ch> wow, now i wish i understood mfix
21:48:42 <SamB_XP> sw17ch: 'tis the "time machine" function
21:48:45 <sw17ch> seriously, for such a simple concept, that's hard :)
21:48:56 <mrd> :t mfix
21:48:58 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
21:49:23 <geezusfreeek> @src IO mfix
21:49:23 <lambdabot> mfix = fixIO
21:49:29 <geezusfreeek> @src fixIO
21:49:30 <lambdabot> Source not found. That's something I cannot allow to happen.
21:49:34 <geezusfreeek> :(
21:49:38 <geezusfreeek> @hoogle fixIO
21:49:38 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
21:49:39 <sjanssen> @type \mcond action -> fix $ \again -> do cond <- mcond; if cond then liftM2 (:) action again else return []
21:49:41 <lambdabot> forall (t :: * -> *) a1. (Monad t) => t Bool -> t a1 -> t [a1]
21:50:01 <geezusfreeek> ooh, partly there!
21:50:13 <sjanssen> what else do you want?
21:50:26 <sjanssen> I don't think mfix is useful here
21:50:34 <geezusfreeek> something that upon further thinking would probably be ugly pointfree stuff
21:50:56 <sjanssen> the 'if' statement is a problem for pointfree
21:51:03 <geezusfreeek> yeah
21:51:07 <sw17ch> geezusfreeek, i like yours
21:51:17 <geezusfreeek> i wish 'if' was just a function
21:51:25 <sw17ch> ... i hate the if statement now ... it's such a pain
21:51:32 <sw17ch> actually, that started a few months ago
21:51:45 <sw17ch> it started with me hating all other implementations of if which don't return values
21:51:48 <sw17ch> then just hating all ifs
21:52:06 <geezusfreeek> could just define your own
21:52:10 <geezusfreeek> that is what @pl does
21:52:11 <MoonPatrol> so what is haskell primarily used for?
21:52:24 <sjanssen> @let bool t f False = f; bool t f True = t
21:52:24 <lambdabot> Defined.
21:52:32 <geezusfreeek> MoonPatrol: it's pretty general, really
21:52:34 <sw17ch> MoonPatrol,  what ever I can
21:52:42 <sw17ch> I'm writing a PCM audio player right now
21:53:07 <sjanssen> @type \mcond action -> fix $ \again -> mcond >>= bool (liftM2 (:) action again) (return [])
21:53:08 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m Bool -> m a1 -> m [a1]
21:53:35 <geezusfreeek> @pl fix $ \again -> mcond >>= bool (liftM2 (:) action again) (return [])
21:53:35 <lambdabot> fix ((mcond >>=) . flip bool (return []) . liftM2 (:) action)
21:53:49 <sw17ch> now that is much nicer
21:53:55 <MoonPatrol> could you write UI with it?
21:54:02 <geezusfreeek> @pl \mcond action -> fix $ \again -> mcond >>= bool (liftM2 (:) action again)
21:54:02 <lambdabot> (fix .) . (. ((bool .) . liftM2 (:))) . (.) . (>>=)
21:54:06 <geezusfreeek> woah
21:54:41 <MoonPatrol> so is the stuff they're copying and pasting haskell code or is that something else?
21:54:44 <sw17ch> MoonPatrol: Haskell has really nice bindings to Gtk+, wxWidgets, and others
21:54:57 <sw17ch> MoonPatrol, yeah, the last thing there is the function i was looking for
21:55:00 <geezusfreeek> MoonPatrol: we're golfing a haskell snippet a little bit
21:55:09 <MoonPatrol> sw17ch, ah cool, Gtk+ is very handy indeed :-)
21:55:14 <geezusfreeek> MoonPatrol: sometimes comes out tiny but unreadable
21:55:21 <geezusfreeek> like any other language though
21:55:26 <sw17ch> MoonPatrol, if you haven't used libglade, check that out too
21:55:30 <geezusfreeek> @unpl (fix .) . (. ((bool .) . liftM2 (:))) . (.) . (>>=)
21:55:31 <lambdabot> (\ n z -> fix (\ k -> n >>= (bool (z >>= \ d -> k >>= \ c -> return ((:) d c)))))
21:55:42 <sw17ch> ouch
21:55:56 <MoonPatrol> yeah i have no idea what any of that stuff means
21:55:58 <MoonPatrol> i thought they were mathematical proofs
21:56:06 <MoonPatrol> sw17ch, alright i'll be sure to do that
21:56:20 <geezusfreeek> MoonPatrol: well, earlier we were using the type system to check our code
21:56:24 <geezusfreeek> :t (fix .) . (. ((bool .) . liftM2 (:))) . (.) . (>>=)
21:56:25 <lambdabot>     Couldn't match expected type `[]' against inferred type `(->) Bool'
21:56:25 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
21:56:25 <lambdabot>     In the second argument of `(.)', namely `(>>=)'
21:56:32 <geezusfreeek> wha—?
21:56:38 <sjanssen> @type \mcond action -> many (mcond >>= guard >> action)
21:56:40 <lambdabot> forall (f :: * -> *) a. (Alternative f, MonadPlus f) => f Bool -> f a -> f [a]
21:56:41 <sw17ch> MoonPatrol, me either... i'm still trying to figure it out
21:56:43 <sjanssen> yes!
21:56:48 <geezusfreeek> sjanssen: WIN
21:56:54 <sjanssen> Control.Applicative ftw
21:57:08 <geezusfreeek> @pl \mcond action -> many (mcond >>= guard >> action)
21:57:08 <lambdabot> (many .) . (>>) . (guard =<<)
21:57:09 <sw17ch> wow, that's so awesome :)
21:57:14 <geezusfreeek> i like that one there
21:57:17 <sw17ch> and now i actually understand it :)
21:57:28 <sjanssen> and we don't need to involve Monad if we add a few helper functions
21:58:01 <sjanssen> @let aguard False = empty; aguard True = pure ()
21:58:02 <lambdabot> Defined.
21:58:17 <geezusfreeek> :t \action -> many (mcond >>= guard >> action)
21:58:19 <lambdabot> Not in scope: `mcond'
21:58:19 <sjanssen> actually, I think we still need join :(
21:58:25 <geezusfreeek> @pl \action -> many (mcond >>= guard >> action)
21:58:25 <lambdabot> many . ((guard =<< mcond) >>)
21:58:46 * sw17ch wipes eyes, and thinks he should tackle some of this in the morning
21:58:55 <geezusfreeek> :t \mcond -> many . ((guard =<< mcond) >>)
21:58:57 <lambdabot> forall (m :: * -> *) b. (MonadPlus m, Alternative m) => m Bool -> m b -> m [b]
21:59:02 <sw17ch> sjanssen, what's the chance something like that ends up in Control.Monad ?
21:59:28 <sjanssen> sw17ch: I dunno, you'd need to demonstrate a good use for it
21:59:38 <sw17ch> hah, just sec, i have it
21:59:43 <sw17ch> well, i'll just describe it
21:59:48 <roconnor> @type many
21:59:49 <geezusfreeek> sjanssen: i think his use is for buffering
21:59:50 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
21:59:58 <roconnor> @src many
21:59:59 <lambdabot> Source not found.
22:00:03 <sw17ch> i'm using Data.Binary.Get to read in PCM audio data and the related sub chunks in a RIFF data format
22:00:36 <sw17ch> there's never a guarantee how many of these things there will be in the file, and i want a way to keep reading until the Data.Binary.Get.remaining value is 0
22:00:37 <sjanssen> is the Get an instance of MonadPlus/Alternative?
22:01:09 <sw17ch> and we define the mcond to be do { v <- remaining ; if (v > 0) then True else False }
22:01:46 <sw17ch> replicateWhile then takes mcond getRIFFSubChunk  as arguments
22:01:57 <sw17ch> which produces a list of all the sub chunks in the file
22:02:08 <sw17ch> i've needed the concept elsewhere
22:02:20 <sw17ch> usually when it comes to consuming input until something changes
22:02:35 <sw17ch> Control.Monad.forever with a condition
22:02:46 <sjanssen> sw17ch: mcond = fmap (> 0) remaining -- :)
22:03:06 <sw17ch> oh frick
22:03:07 <sw17ch> you're right
22:03:12 * sw17ch decides bed is a good idea
22:04:00 <sw17ch> was that a suitable description of my problem?
22:04:28 <sjanssen> yes
22:05:31 <thetallguy> @src any
22:05:31 <lambdabot> any p =  or . map p
22:05:44 <thetallguy> ?type or
22:05:45 <lambdabot> [Bool] -> Bool
22:05:56 <sw17ch> wait, which version did we decide was the best for replicateWhile?
22:06:27 <thetallguy> > or $ [False ..] ++ [True]
22:06:28 <lambdabot>  True
22:06:39 <nolrai_> :t (, 1)
22:06:40 <lambdabot> parse error on input `1'
22:06:41 <hexpuem> how would i go about merging two datatypes generically using Data.Generic stuff? I want to break down two records to their primitive components and apply a type specific merge to each element
22:06:45 <thetallguy> > [False ..]
22:06:46 <lambdabot>  [False,True]
22:06:57 <hexpuem> gzipWithT or gmapQl or something else?
22:07:24 <thetallguy> > or $ repeat False ++ [True]
22:07:28 <sw17ch> oh dang... sjanssen i see why you asked that now :) "No instances for (Alternative Get, MonadPlus Get)"
22:07:38 <lambdabot> Terminated
22:10:42 <sw17ch> @where hpaste
22:10:42 <lambdabot> http://hpaste.org/
22:11:32 <sw17ch> http://hpaste.org/8277
22:13:50 <sw17ch> http://hpaste.org/8278 (with unix endlines... woops)
22:17:53 <sw17ch> sjanssen++
22:17:55 <sw17ch> geezusfreeek++
22:18:14 <sw17ch> thanks for the help all, i'm going to bed
22:18:23 <geezusfreeek> sw17ch: np, gnite
22:20:54 <nolrai_> @ty Data.Array.listArray
22:20:55 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
22:42:07 <mm_freak_> that would rather be something like:  modifySTRef sjanssen (+1) >> modifySTRef geezusfreeek (+1)
22:42:10 <mm_freak_> =)
22:50:44 <user317> is ther a way to uninstall with cabal-install
22:51:32 <nus> @hoogle Resource
22:51:32 <lambdabot> No matches found
22:53:31 <ivanm> user317: dont' think so...
22:53:36 <ivanm> @seen dcoutts
22:53:36 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 7h 15m 1s ago.
22:53:39 <ivanm> @seen dcoutts_
22:53:39 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 13h 4m 45s ago.
22:53:54 <nus> ?hackage resource
22:53:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/resource
22:54:28 <hexpuem> can anyone tell me what compiler flag i need to get mkTT to compile in http://www.cs.vu.nl/boilerplate/testsuite/gzip/Main.hs
22:54:31 <hexpuem> -fno-monomorphism-restriction doesnt help
23:09:13 <Saizan_> hexpuem: which error do you get?
23:09:47 <hexpuem> cant bind scoped type variables
23:10:01 <hexpuem> if i add forall a. to the F:: definition that part is fine
23:10:11 <hexpuem> but i cant get the ( :: a) parts in the case switch to work
23:13:21 <Saizan_> are you sure you need all those type annotations?
23:13:56 <hexpuem> doesnt compile if i take them out haha
23:14:29 <Saizan_> ah right, it doesn't know anything about the return type of f
23:15:16 <hexpuem> http://www.cs.vu.nl/boilerplate/testsuite/gzip/CompanyDatatypes.hs has the datatype defines it imports if you were trying to build
23:15:22 <lambdabot> http://tinyurl.com/5p62lp
23:15:42 <Saizan_> ?hoogle mkT
23:15:43 <lambdabot> Data.Generics.Aliases.mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
23:15:43 <lambdabot> Data.Typeable.mkTyCon :: String -> TyCon
23:15:43 <lambdabot> Data.Typeable.mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
23:17:47 <Saizan_> i'd remove the annotations and write "cast (f x' y' `asTypeOf` x' `asTypeOf` y')", or write a full signature for mkTT
23:18:46 * Elly metal hands
23:19:10 <hexpuem> ok ill see if i can figure them out haha
23:19:10 <Elly> my kernel brings up all the processors of an SMP system :)
23:22:10 <ixdy> Elly: ... what does that have to do with haskell?
23:23:04 <Elly> why would I talk about haskell in here? o_O
23:23:18 <Elly> sometimes you make no sense, ixdy :P
23:36:39 <hexpuem> hmm looks like mkTT is in some version of Data.Generics
23:49:24 --- mode: irc.freenode.net set +o ChanServ
23:50:59 <dons> anyone else notice agl was behind this new 'obfuscated TCP'?
23:52:53 <Elly> 'obfuscated tcp'??
23:53:15 <dons> http://code.google.com/p/obstcp/
23:53:16 <lambdabot> Title: obstcp - Google Code
23:53:50 <Elly> interesting
23:55:41 <dons> he's written an awful lot of intersting haskell network stuff too, http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fcgi-bin%2Fhackage-scripts%2Fpackage&as_q=Adam+Langley
23:55:42 <lambdabot> Title: Adam Langley site:hackage.haskell.org/cgi-bin/hackage-scripts/package - Google S ..., http://tinyurl.com/6dlmbb
