00:08:30 <dons> dmwit: use pcre :)
00:08:53 <dmwit> Then I have to parse Perl regexes... probably even harder. =)
00:09:52 <chessguy> @pl setColor c = setToMoveColor (switchColor (toMoveColor c)) c
00:09:53 <lambdabot> setColor = setToMoveColor =<< switchColor . toMoveColor
00:10:38 <chessguy> @pl setTarget c = setPiece to (getPiece from c) c
00:10:38 <lambdabot> setTarget = setPiece to =<< getPiece from
00:12:21 <dmwit> dons: Unless PCRE has a way to intersect regexes and test emptiness of regexes...?
00:12:43 * dmwit doesn't see it in a quick perusal of the Text.Regex.PCRE.Light docs.
00:21:38 <ivanm> dons: is there any particular reason mkcabal depends on exactly version 0.3 of pcre-light>
00:21:40 <ivanm> ?
00:34:25 <dons> ivanm: sounds wrong.
00:34:51 <dons> i need to port mkcabal to cabal 1.4
00:34:53 <dons> the new syntax
01:00:06 <dmwit> Could somebody not on a Linux box tell me what ("[]" =~ "" :: [String]) reports?  ((=~) is in Text.Regex.Posix)
01:00:28 <dmwit> I'm having trouble understanding the POSIX spec, as it doesn't seem to line up with the results I get here.
01:00:46 <dmwit> I want to know whether I have a buggy implementation, or I'm misinterpreting the spec.
01:02:09 <Taggnostr> I don't know about haskell, but [] are metacharacters, so if you want to match literal [] you have to escape them
01:02:23 <dmwit> I do not want to match literal [].
01:02:28 <dmwit> I want to understand the spec.
01:02:43 <dmwit> i.e. what *should* [] match?
01:03:06 <dmwit> My reading of the spec says it should not match any string (!), but it seems to match the empty string here.
01:03:18 <Taggnostr> probably nothing
01:03:39 <Taggnostr> and nothing and the empty string are equal
01:03:51 <dmwit> That is not true.
01:03:58 <dmwit> or...
01:04:07 <thoughtpolice> when I do "[]" =~ "" :: [String] on my windows xp box (ghc 6.8.2,) I get:
01:04:40 <Taggnostr> why it shouldn't be true?
01:04:47 <thoughtpolice> '*** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 14,"empty (sub)expression")) '
01:05:02 <dmwit> Taggnostr: Because \emptyset /= {\emptyset} ?
01:05:10 <dmwit> thoughtpolice: Okay, thanks.
01:06:00 <dmwit> Taggnostr: A little less obtusely:
01:06:14 <dmwit> The set containing the empty string and the empty set should not be equal.
01:06:17 <mm_freak> is FlexibleInstances an evil extension?  i'd like an instance like this:  instance BitField IntegerBitField m where  -- m is a monad (which is already implied by the class BitField)
01:06:37 <dmwit> So letting your language be the empty set should be different from letting your language be the set containing the empty string.
01:06:52 <dmwit> i.e. [] matching nothing should not be the same as [] matching the empty string.
01:08:08 <Taggnostr> python says that '[]' is an invalid regex
01:08:18 <dmwit> Okay.
01:08:31 <dmwit> I like that behavior, I'll stick with it.
01:08:41 <Taggnostr> same with perl
01:09:16 <dmwit> But perl doesn't use POSIX regexen... so that vote doesn't count.
01:09:46 <Taggnostr> btw, what are you trying to do?
01:09:56 <dmwit> Parse POSIX regexes into NFAs.
01:10:19 <dmwit> The end-goal is to find out if two POSIX regexes have any string in common.
01:10:35 <dmwit> (Though I'd be happy to use any other reasonably easy-to-parse spec.)
01:10:51 <dmwit> (Or if it's already been done, that's even better. =)
01:12:04 <Taggnostr> have you seen http://swtch.com/~rsc/regexp/regexp1.html ?
01:12:06 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
01:12:16 <dmwit> Sure.
01:12:26 <Taggnostr> nice
01:12:42 <dmwit> I've also done a basic automata class, which covered the same content. ;-)
01:13:23 <dmwit> I've actually already got the NFA/matcher/intersector bit done.
01:13:39 <dmwit> Just have to parse some form of regex into my Regex data type. =)
01:13:47 <mm_freak> i have a class with three functions fa, fb and fc…  the minimal complete definition is (fa or (fb and fc))…  can i express this in the class?
01:14:03 <dmwit> mm_freak: Yes, provide default definitions for all three.
01:14:44 <mm_freak> dmwit: yes, but i'd like it to demand (fa or (fb and fc)) for instances, because otherwise all three are bottom
01:14:57 <dmwit> Right, there's no way to declare that.
01:15:10 <mm_freak> ok, thanks
01:15:11 <dmwit> But the usual thing is to document it in comments and leave the programmer to their own peril if they ignore them.
01:15:24 <dmwit> (Several of the Prelude classes do this, I believe.)
01:30:46 <mm_freak> does implementing ST need magic?  (if you don't want to use unsafe things)
01:31:25 <dmwit> It needs rank-2 types, at least.
01:31:26 <xerox> I don't think so, it's type level ensured safety
01:32:36 <dolio> It needs unsafeCoerce.
01:32:50 <dolio> Or typeable, I suppose.
01:33:23 <dolio> But typeable just hides unsafeCoerce unless you're using GADTs (and thus have a limited number of typeable things).
01:34:26 <Saizan_> and you also need some memory primitives if you want constant lookups
01:35:49 <mm_freak> but i think, i could just do something like:  data ST s a = ST [StateEntry] a
01:35:51 <mm_freak> couldn't i?
01:36:09 * dolio is gradually growing less fond of this formulation of proofs over coinductive objects.
01:37:01 <bluestorm> I'd be interested in feedback on a small article (5 pages, most of them being code) I just wrote, "fold and unfold on fixpoint types"
01:37:09 <bluestorm> ( http://bluestorm.info/tmp/fixpoint_types.pdf )
01:37:42 <Saizan_> mm_freak: you've to deal with the fact that every STRef can have a different type parameter
01:38:00 <bluestorm> it's only a neat idea i had during a class, and i'm quite sure (although i'm not familiar with the literature in the field at all, as i'm not a computer scientist) that it's nothing new
01:39:18 <mm_freak> Saizan_: yes, StateEntry could be about anything
01:39:22 <maltem> Anyone familiar with the wxhaskell binary for Mac? It installs its files, but it does not register a ghc package here...
01:39:27 <bluestorm> but still i found it funny enough to try to write a "real" article from it
01:41:58 <mm_freak> bluestorm: interesting idea
01:43:04 <Saizan_> bluestorm: nice insight :) there are quite a number of papers on that and generalizations, you might be interested in category-extras to see how that models to in haskell
01:43:18 <dmwit> > chr 9
01:43:21 <lambdabot>  '\t'
01:43:24 <dmwit> chr ' '
01:43:27 <dmwit> > chr 32
01:43:28 <lambdabot>  ' '
01:43:31 <bluestorm> Saizan_: category-extras is a haskell package ?
01:43:40 <Saizan_> bluestorm: yes, on hackage
01:45:07 <Saizan_> ?google bananas lenses barbed-wire
01:45:10 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
01:45:10 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
01:47:10 <Saizan_> bluestorm: that's a good starting paper, probalby ^^^^
01:47:43 <bluestorm> ana g = InF . fmap (ana g) . g
01:47:47 <bluestorm> looks like it :p
01:48:49 <Saizan_> yeah :)
01:49:54 <mm_freak> there's almost nothing that you couldn't move from values to types =)
01:52:28 <bauchus> is there an example for the ALUT package? I don't know how to use Sound.ALUT.Initialization.
01:53:03 <Saizan_> mm_freak: it depends on how pleasant you require the encoding to be :)
01:53:18 * audreyt wonders what's the type-land equivalent to Data.Dynamic values.
01:54:17 <bluestorm> i have been frustrated at first with the impossibility to write a type equation without constructor like  "type Fix f = f (Fix f)", but it's actually convenient to make the  (f (Fix f)) -> Fix f  step explicit
01:56:14 <Saizan_> ah, yeah, the wrap/unwrap of the newtype gets a bit noisy, but it's the pain to pay for the lack of equi-recursive types
01:57:31 <bluestorm> (i glanced at the paper and category-extras source code : seems very interesting, but is there a trick to manage that much different names and similar-looking notations at the same time ?)
01:58:22 <Saizan_> (manage in what sense?)
01:58:28 <bluestorm> hm
01:58:30 <bluestorm> in my head :)
01:59:02 <Saizan_> heh :D
01:59:43 <Saizan_> well, it's not a package used in everyday programming... (yet?)
02:02:12 <bluestorm> Anamorphism and Catamorphism are ok (and the analogy with similar greek-rooted words might help a bit), but then there are hylo and paramorphism, seems category-extras is even richer, i'm waiting for a patamorphism :]
02:04:14 <Dzlk> bluestorm: the category-theoretic expression of 'pataphysics?
02:05:43 <Saizan_> zygo- histo- futu- etc.. but it seems they can be expressed in terms of a more general combinator and some distributive laws
02:07:07 <bauchus> grr, haskell with ALUT+OpenAL segfaults :-(
02:13:52 <roderyk> does someone here have a shortcut for lhs2Tex? I'd like to do something like: \newcommand{\cc}[1]{ghci-prompt> \begin{code}#1\end{code}}
02:14:11 <roderyk> and it would be nice if it just parses the code (w/o trying to exec it)
02:14:50 <roderyk> I just want to be able to write something like \cc{zip [1..5] [1..5]} and have it pretty-print for my presentation : )
02:15:45 <maltem> roderyk: Inline Haskell for lhs2tex goes between | |, IIRC
02:17:27 <roderyk> maltem: brilliant! thanks :)
02:19:09 <bauchus> can I search with a type specification for a haskell function, e.g. ([a] -> a => head)?
02:19:18 <dmwit> ?hoogle [a] -> a
02:19:18 <lambdabot> Prelude.head :: [a] -> a
02:19:18 <lambdabot> Prelude.last :: [a] -> a
02:19:18 <lambdabot> Data.List.head :: [a] -> a
02:19:24 <bauchus> cool
02:19:40 <bauchus> ?hoogle Float -> Double
02:19:40 <lambdabot> No matches, try a more general search
02:19:42 <Smokey`_> what's the difference between Prelude.head and Data.List.head ?
02:19:49 <dmwit> Nothing.
02:20:05 <Smokey`_> then why have both?
02:20:21 <dmwit> For people who hide the Prelude.
02:20:31 <Vq^> Smokey`_: the logical place for it is in Data.List
02:21:45 <Saizan_> prelude re-exports it for convenience
02:23:00 <dmwit> heh
02:23:28 <dmwit> ?remember Saizan Prelude re-exports Data.List.head for convenience
02:23:28 <lambdabot> It is stored.
02:24:08 <Saizan_> was it funny?:)
02:24:20 <dmwit> Yep! =)
02:25:42 <bauchus> ?type realToFrac
02:25:45 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
02:29:05 <mxc> :t (<=)
02:29:07 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:31:12 <ttt--> :t (=>)
02:31:14 <lambdabot> parse error on input `=>'
02:31:41 <ttt--> :t (->)
02:31:43 <lambdabot> parse error on input `->'
02:31:56 <QtPlatypus> :t (>=)
02:31:58 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:32:37 <dmwit> ttt--: Those are syntax...
02:33:29 <Saizan_> :kind (->)
02:33:37 <Saizan_> @kind (->)
02:33:38 <lambdabot> ?? -> ? -> *
02:35:41 <ttt--> what are those question marks?
02:35:51 <ttt--> :kind (=>)
02:35:58 <ttt--> @kind (=>)
02:36:00 <lambdabot> parse error on input `=>'
02:36:05 <dmwit> You must take the kind of a type.
02:36:11 <dmwit> (=>) is not a type, so...
02:36:21 <Saizan_> (=>) is only syntax, it divides the typeclass context from the actual type
02:37:16 <Saizan_> e.g. show :: Show => a -> String means that show can take an argument of any type that's an instance of the class Show, and returns a String
02:37:17 <ivanm> dons: k
02:37:32 <ttt--> Doesn't it give the function an extra input (the instance dictionary)?
02:37:41 <dmwit> *kind* of
02:37:47 <dmwit> But only in the compiler's mind.
02:38:01 <Saizan_> ttt--: that's an implementation detail, it's not exposed in the language
02:38:19 <Saizan_> some compilers do that differently in fact
02:47:11 <ttt--> i dont understand why it says "?" in stead of "*" in :kind (->)
02:47:19 <dolio> ?? is the union of * and #
02:47:19 <lambdabot>  is the union of * and #
02:47:33 <dolio>  ? is the union of ?? and (#)
02:47:37 <ivanm> lol
02:49:20 <ttt--> is # the boxed types?
02:49:26 <dolio> Unboxed.
02:49:31 <dolio> (#) is unboxed tuples.
02:49:32 <ttt--> right
02:52:19 <hpaste>  dcoutts pasted "BuildReport" at http://hpaste.org/8189
02:52:26 <dcoutts> can anyone help me review whether this ^^^ notion of cabal/hackage build report is at all sensible
02:52:45 <dcoutts> or is it just over complex?
02:53:23 <ttt--> is there a reason only allowing (#) in the second argument?
02:53:40 <dolio> Unboxed tuples are only allowed in return values.
02:53:58 <dolio> They're for returning multiple results in registers.
02:54:02 <ttt--> i see, thanks
02:54:11 <ivanm> dcoutts: I wonder if buildOS and buildArch can be combined...
02:55:08 <thoughtpolice> dcoutts: seems pretty straightforward to me.
02:55:55 <thoughtpolice> you have a data type for each step in the process, each datatype has a constructor for the possible outcomes. simple enough.
02:56:09 <Saizan_> dcoutts: why buildCabalVersion is commented out? it can be different from the one cabal-install is compiled against, no?
02:57:20 <thoughtpolice> dcoutts: the only thing that's slightly weird to me is how you nested the data types, so each data type representing a step has a constructor representing the next step
02:57:29 <thoughtpolice> and it's status
02:57:33 <thoughtpolice> other than that it seems perfectly clear
02:58:06 <dcoutts> Saizan_: oh, it's commented out because I cannot gather that info yet, it's doable though
02:58:43 <dcoutts> thoughtpolice: right, the reason for the nesting is because is reflects the dependencies between the phases
02:58:54 <dcoutts> thoughtpolice: but I dunno if that's worth it
02:59:02 <ski_> why's `(#)' not allowed as kind for for argument position types, then ? .. "curried arguments suffices" ?
02:59:31 <ski_> s/for for/for/
02:59:31 <dcoutts> ivanm: could be... (OS, Arch)! :-)
02:59:47 <ivanm> yeah, something like that
02:59:54 <dcoutts> ivanm: we already have OS and Arch types so it seems sensible to re-use them
02:59:55 <ivanm> only because OS and Arch are often tied closely together
03:00:02 <ivanm> oh, OK, fair enough
03:00:03 <dolio> ski_: I imagine.
03:00:10 <thoughtpolice> dcoutts: yes; only said it was a little weird, not that it didn't make sense.
03:00:45 <thoughtpolice> imo that code seems perfectly reasonable and represents pretty much all the possible steps/outcomes/necessary information needed for build reports :)
03:01:02 <dcoutts> thoughtpolice: 'k :-)
03:02:16 <thoughtpolice> dcoutts: the only noticable thing I can see missing which I think would make a big difference is the compiler used and its version
03:02:36 <dolio> ski_: You can already call a function with multiple arguments without heap allocation, but that's not true for returning multiple values without unboxed tuples. Or, at least, I imagine that's the rationale.
03:02:49 <dcoutts> -- | The Haskell compiler (and hopefully version) used
03:02:50 <dcoutts> buildCompiler          :: CompilerId,
03:02:55 <dcoutts> thoughtpolice: it's there
03:03:08 <thoughtpolice> oh right, must have overlooked it. :) nevermind me.
03:03:30 <dcoutts> the one we're missing is versions of other build tools, like happy, haddock etc
03:03:49 <dcoutts> and that's because the current cabal architecture makes that info really hard to recover
03:04:08 <ivanm> dcoutts: does PackageIdentifier include version as well?
03:04:14 <dcoutts> ivanm: yes
03:04:20 <ivanm> *nod*
03:04:29 <ivanm> FlagAssignment is a list then of the compile flags used?
03:04:32 <dcoutts> since for custom Setup.hs scripts we have to call an external binary and then how do we get it to tell us what versions of build tools it found?
03:04:42 * ski_ for some reason is not happy with it .. but is not sure why
03:04:48 <Gilly> In haskell, when making a network server serving multiple clients simultaneously, is it usually done by forking for each process or select calls? In my case the clients are not independent.
03:04:53 <ivanm> ski_: what, with the BuildReport setup?
03:04:55 <dcoutts> ivanm: the cabal configuration flags
03:05:25 <ski_> ivanm : no, with `(#)'
03:05:35 <ivanm> ski_: oh, OK...
03:05:45 <dcoutts> ivanm: so not ghc flags or other command line flags, just the Bool values of the flags defined in the .cabal file
03:06:03 <ivanm> *nod*
03:06:17 <ivanm> but my point was that it's more than just one flag :p
03:06:32 <Saizan_> Gilly: ones uses GHC's lightwieght threads with forkIO
03:06:38 <dcoutts> ivanm: yes, it's a total flag assignment
03:08:22 <Gilly> Saizan_: okies... now i guess i got to read about the communication between threads since the clients need to be able to interact
03:09:09 <Saizan_> Gilly: yeah, see Control.Concurrent.{MVar,Chan}
03:10:00 <Gilly> right, thanks :)
03:10:16 <ertai> > \f g x -> (f x, g x)
03:10:17 <lambdabot>  Add a type signature
03:10:48 <ski_> @type (&&&)
03:10:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:11:04 <ski_> @type \f g x -> (f x, g x)
03:11:05 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
03:11:13 <ski_> @type \f g -> f &&& g
03:11:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:11:25 <ski_> @type \f g x -> (f &&& g) x
03:11:27 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
03:12:00 <ski_> (aka `liftM2 (,)')
03:12:02 <ertai> ski_: thanks!
03:12:16 <ertai> @src (&&&)
03:12:16 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
03:12:47 <ski_> @type \f g x -> liftM2 (,) f g x
03:12:49 <lambdabot> forall t a1 a2. (Monad ((->) t)) => (t -> a1) -> (t -> a2) -> t -> (a1, a2)
03:14:33 <Gilly> Saizan_: so if i understood this correctly i can make a separate chan between some engine and every client and make the engine check all of those chans in a loop
03:15:03 <ertai> @src (***)
03:15:04 <lambdabot> f *** g = first f >>> second g
03:16:25 <Saizan_> Gilly: or use a single chan where all the clients write and the engine reads
03:17:34 <Saizan_> reading from multiple channels in a single threads require busy waiting
03:17:36 <Gilly> hm, which would be faster? or is there any difference? i'd have to give some signature to every message then indicating which client sent the message
03:17:57 <Gilly> oh true
03:18:05 <Gilly> so single channel it is :)
03:19:19 <Saizan_> or you could use STM which has orElse and so can wait on multiple blocking calls
03:50:25 <asm> I find it very hard to get into the functional thinking
03:50:40 <asm> example: say I want to build a simple neuro-net
03:50:57 <asm> ie imperatively speaking: there is an array with values
03:51:06 <asm> and an matrix width edge weight
03:51:38 <asm> and according to the edge weights the array values would be summed up in another array (of the same size)
03:52:10 <asm> than there would be a function running over the result values to determine the next values to be fired
03:52:16 <asm> that would be one cycle
03:52:33 <asm> what would be the way to implemnt such thing in a functional manner?
03:54:47 <Heffalump> so the new values are just the matrix product of the edge weights with the old values?
03:56:37 <asm> yeah one could say so
03:56:40 <lilachaze> @index on
03:56:40 <lambdabot> bzzt
03:57:08 <asm> I dont have an idea about matrices in haskell, though
03:57:15 <Saizan_> then you can use the same data structures, you just create a new array instead of updating the old
03:58:00 <maltem> asm: Matrices can be modeled as YourFavorouriteArrayType (Int,Int) e, for example, Array (Int,Int) Double
03:58:07 <lilachaze> > nub ((==) `on` fst) ["this", "is", "a", "test"]
03:58:08 <lambdabot>  Couldn't match expected type `[a]'
03:58:22 <maltem> asm: That's an array indexed by pairs of Ints
03:58:34 <Heffalump> lilachaze: nub doesn't take an equality function
03:58:36 <Heffalump> @type nubBy
03:58:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
03:58:45 <lilachaze> > nubBy ((==) `on` fst) ["this", "is", "a", "test"]
03:58:46 <lambdabot>  Couldn't match expected type `(a, b)'
03:58:51 <Heffalump> that does, but you don't have a list of pairs so it still won't work
03:58:59 <lilachaze> > nubBy ((==) `on` head) ["this", "is", "a", "test"]
03:58:59 <Heffalump> do you mean (==) `on` head ?
03:59:01 <lambdabot>  ["this","is","a"]
03:59:02 <asm> thnx maltem so I'll try to learn a bit about arrays first I guess :)
03:59:13 <lilachaze> Heffalump: too early in the morning for me :)
03:59:35 <Heffalump> well, you seem quicker at correcting yourself than I am :-)
03:59:35 <lilachaze> is 'on' a lambdabot special, or is it in a library somewhere?
04:00:06 <maltem> asm: As for immutable arrays, they are easy. Just dig through Data.Array. The most interesting thing is how to construct an array, via "array", "listArray" and friends
04:00:32 <maltem> lilachaze: A new addition to Data.Function
04:00:46 <maltem> that is, Data.Function is the new addition :)
04:01:32 <dcoutts> Heffalump: Data.Function
04:02:31 <Heffalump> dcoutts: are you just behind with the conversation and talking to the wrong person about `on`, or was there some other reason I should know about it? :-)
04:02:52 <dcoutts> oops
04:03:04 <lilachaze> looks like lambdabot's @index is out of date then :)
04:03:18 <dcoutts> Heffalump: sorry, wrong line, it was lilachaze who asked
04:03:58 <maltem> asm: Also, you will find two array interfaces (type classes), IArray and MArray for immutable/mutable arrays. They are handy when performance becomes a concern, and when you want to try out what array datatype fits your needs best, because you won't need to change your function definitions when changing to a different array implementation
04:05:28 <asm> oh thats sounds like senseful encapsulation
04:07:10 <asm> how could I make a type alias that says something like: "Whenever I say 'Edges' I mean a 2d-array with int values"?
04:07:41 <asm> (I guess its obvious for a haskell coder, but not for me ;))
04:08:20 <opqdonut> type Edges = Array (Int,Int) Int
04:08:25 <opqdonut> or something to that effect
04:09:59 <asm> thnx
04:15:10 <dcoutts> Igloo: does debian's popcorn do anything to try and prevent forging or ballot stuffing?
04:15:36 <Igloo> No
04:15:48 <dcoutts> Igloo: I'm wondering about anonymous build results, the problem is they have to be clear so that people can convince themselves they're not giving out identifying information
04:16:00 <dcoutts> but that also makes them easy to modify
04:16:24 <dcoutts> perhaps it just doesn't matter as it's all statistical anyway
04:20:42 <Igloo> I think we can worry about abuse if it happens. It should be easy to spot
04:30:15 <audreyt> @tell dons http://openafp.org/dist/SQLite.hs now has createAggregatePrim in addition to createFunction(Prim), courtesy of clkao, fyi :)
04:30:15 <lambdabot> Consider it noted.
04:49:51 <roderyk> using lhs2Tex \begin{code} ... \end{code}  I get " LaTeX Error: There's no line here to end." when code is more than one statement. (the actual code compiles fine when loaded into ghci). I'm sure I'm just missing something obvious, having never worked with this before. Suggestions?
04:50:47 <Saul__> did you run lhs2tex before the latex compiler?
04:51:28 <wolverian> rubber is nice, and supports running lhs2tex automatically
04:51:36 <hukolele> what is my error in: factors' p = [ n | n <- [1..(toInteger.floor.sqrt)p], p `mod` n == 0 ]
04:52:13 <hukolele> ghc says : No instance for (RealFrac Integer)
04:52:17 <hukolele> but...
04:52:19 <Syzygy-> :t sqrt
04:52:21 <lambdabot> forall a. (Floating a) => a -> a
04:52:24 <Syzygy-> :t floor
04:52:26 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
04:52:35 <Syzygy-> Ah. Floor needs your type to implement RealFrac.
04:52:46 <hukolele> :t (toInteger.floor.sqrt)
04:52:47 <lambdabot> forall a. (Floating a, RealFrac a) => a -> Integer
04:52:59 <Syzygy-> :t (toInteger.floor.sqrt.fromInteger)
04:53:01 <lambdabot> Integer -> Integer
04:53:15 <Syzygy-> > (toInteger.floor.sqrt.fromInteger) 15
04:53:17 <lambdabot>  3
04:53:18 <hukolele> that its
04:53:22 <hukolele> thanks
04:53:37 <hukolele> :t fromInteger
04:53:39 <lambdabot> forall a. (Num a) => Integer -> a
04:54:11 <Saul__> roderyk: run lhs2TeX on your .lhs file to produce a .tex file and compile that with latex
04:54:38 <lilachaze> hukolele: beware; that's not a reliable way to get a square root for large integers. the conversion via Floating is lossy.
04:54:57 <roderyk> Saul__: sorry, I wasn't clear:  lhs2TeX present2.lhs > present2.tex && pdflatex present2.tex
04:55:15 <roderyk> it only works as long as \begin{code} .. \end{code} are one statement long
04:55:26 <roderyk> inline |code| also seems to work
04:55:49 <Saul__> ok
04:55:55 <Saul__> Then I'm not sure
04:56:16 <Saul__> I've only used it once so far, so I'm not exactly a pro either
04:56:32 <hukolele> lilachaze: anyway is not correct cause the factors can be greater than their sqrt
04:56:56 <hukolele> just asking because it trows me that strange error for me
04:57:09 <hukolele> thanks anyway
04:58:38 <hukolele> how can I evaluate an expression here in lambdabot?
04:58:48 <Saul__> > id 3
04:58:49 <lambdabot>  3
04:59:00 <hukolele> ok :)
04:59:17 <hukolele> > putStrLn "thx"
04:59:19 <lambdabot>  <IO ()>
04:59:37 <ski_> @help run
04:59:37 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:00:04 <Saul__> run id 3
05:00:10 <ski_> @run id 3
05:00:11 <lambdabot>  3
05:00:18 <Saul__> ah of course :)
05:01:47 <hukolele> > (toInteger.floor.sqrt.fromInteger) 10000000000000000000000000000000000000000000000000000000
05:01:49 <lambdabot>  3162277660168379365112938496
05:02:25 <hukolele> > 3162277660168379365112938496 * 3162277660168379365112938496
05:02:26 <lambdabot>  10000000000000000209431609176305434969493825183878742016
05:02:52 <hukolele> (toInteger.sqrt.fromInteger) 10000000000000000000000000000000000000000000000000000000
05:03:04 <hukolele> > (toInteger.floor.sqrt.fromInteger) 10000000000000000000000000000000000000000000000000000000
05:03:06 <lambdabot>  3162277660168379365112938496
05:03:15 <ski_> > (3162277660168379365112938496 - 1) ^ 2
05:03:16 <lambdabot>  10000000000000000209431609169980879649157066453652865025
05:03:35 <ski_> floating point approximation errors
05:03:46 <audreyt>  
05:04:00 <hukolele> maybe because the floor?
05:04:20 <olsner> :t sqrt
05:04:22 <lambdabot> forall a. (Floating a) => a -> a
05:04:40 <hukolele> > (toInteger.sqrt.fromInteger) 10000000000000000000000000000000000000000000000000000000
05:04:41 <lambdabot>  Add a type signature
05:04:42 <ski_> you could define an `integralSqrt', i suppose
05:05:08 <olsner> > length "0000000000000000000000000000000000000000000000000000000"
05:05:09 <lambdabot>  55
05:05:16 <ski_> (or, hm, at least for `Integer')
05:06:05 <ski_> @type toInteger
05:06:07 <lambdabot> forall a. (Integral a) => a -> Integer
05:06:43 <ski_> hukolele : which type is both in `Integral' and `Floating' ? .. that's what lambdabot meant to ask
05:07:05 <ski_> @type floor
05:07:07 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
05:07:31 <hukolele> omg pain in my brain
05:07:47 <olsner> good pain, good pain ;-)
05:07:49 <hukolele> haskell rulez, what about clean?
05:08:05 <ski_> it's clean
05:08:18 <hukolele> cleaner than haskell?
05:08:52 <ski_> > Clean `cleanerThan` Haskell
05:08:52 <lambdabot>   Not in scope: data constructor `Haskell'
05:09:33 <hukolele> lol... so its not cleaner... (close-world assuptiom)
05:10:24 <hukolele> nobody is in #clean
05:10:42 <Dzlk> It's been cleaned out.
05:10:45 <ski_> bah, (rather possibly the question was inadmissible)
05:11:34 <ski_> hukolele : i think they have a mailing list
05:12:24 <hukolele> I guess they don't have as much support as haskell
05:16:37 <Saul__> I don't know much about Clean, but I heard it's a lot faster than Haskell
05:16:43 <Saul__> it nears C speeds
05:17:17 <Saul__> It can apparently compile itself in 7 seconds
05:17:53 <QtPlatypus> Thats faster then gcc can compile itself.
05:18:41 <Saul__> Well C is a pretty bloated language, so that isn't a really fair comparison
05:19:30 <Saul__> I'm sure a C compiler in Clean wouldn't compile gcc in 7 seconds either
05:19:30 <QtPlatypus> Thats the first time I've heard C described as bloated.  C++ sure but C.
05:20:49 <Saizan_> however GHC benchmarks compete with C these days too
05:21:09 <Saul__> Well maybe C isn't, but gcc is
05:21:34 <QtPlatypus> Point taken, I think it has a fortran compiler amounst other things in there.
05:22:41 <JaffaCake> @seen Igloo
05:22:42 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1h 1m 59s ago.
05:23:12 <Saul__> Saizan_: GHC isn't that bad either, but Clean is just really fast
05:23:22 <JaffaCake> Igloo: we have a few worrying-looking test failures on Windows
05:23:45 <ttmrichter> Saul__: Where can I download Clean to get a look at it?
05:24:34 <Saul__> ttmrichter: http://clean.cs.ru.nl/
05:24:38 <araujo> There exist a problem with Clean though
05:24:40 <lambdabot> Title: Home
05:24:44 <araujo> it is not Haskell
05:24:53 <ttmrichter> Thanks.
05:25:22 <Igloo> JaffaCake: Oh, I forgot about that, thanks
05:25:58 <Saul__> araujo: That's true, but that is the reason that it is so fast
05:26:28 <Saul__> Haskell just has a couple of language features that don't lend themselves for fast compilation
05:26:40 <Saul__> They were taken out in Clean
05:26:48 <hukolele> but is it as fast to code in as haskell?
05:26:54 <hukolele> what features?
05:27:10 <JaffaCake> Igloo: no problem - I meant to look into them before I left on Thursday but didn't have time
05:27:35 * JaffaCake is in Tucson at ISMM/PLDI
05:27:50 <Saul__> I'm not exactly sure, but I think they redid some numeric stuff, took out operator sections and used a different IO model based on uniqueness types
05:27:59 <Spark> i want to see the lock inference paper
05:28:03 <Spark> but can't afford to go to pldi
05:28:04 <Saul__> monadic IO is available but not as fast
05:28:34 <Saul__> and the numeric stuff means that 1.0 :: Double instead of 1.0 :: Num a => a
05:28:50 <Saul__> and I'm not even sure about the operator sections
05:28:54 <Spark> Saul__: why is that a benefit?
05:29:01 <Igloo> Hmm, looks like problems with stdcall and viaC
05:29:02 <Spark> losing the subtyping between primitives
05:29:48 <Saul__> I think it saves on conversions
05:29:51 <araujo> Saul_, features such as?
05:30:14 <hukolele> so lets say Clean is a castrated haskell
05:30:44 <Saul__> hukolele: Yeah you could say that I guess
05:30:52 <Saizan_> typeclass polymorphism means that you've more indirections when using methods of the class, but GHC can often specialize, especially for numeric types
05:30:53 <araujo> If you take a look at the shootout language page, the difference isn't that big really
05:31:36 <Saul__> araujo: It's likely that the GHC crew learned from Clean and sped things up
05:31:43 <frevidar> In Data.Array.IArray, part of ghc, why isn't the index a parameter of the class?
05:32:23 <Saizan_> frevidar: because arrays are supposed to work with every index
05:32:35 <Saizan_> Ix i => i, i mean
05:33:04 <Saul__> But basically all I just said is straight from the mouth of Rinus Plasmeijer, one of the designers of Clean, I don't have any experience with it myself
05:33:27 <frevidar> saizan: so any array should accept every index?
05:33:43 <olsner> I'm considering buying okasaki's purely functional data structures ... should I?
05:33:51 <araujo> Saul_, And ghc is continually improving :-]
05:34:32 <Saizan_> frevidar: by "any array" you mean any type of array or any array-value
05:34:34 <Saizan_> ?
05:34:40 <Saizan_> in the latter case no
05:35:31 <frevidar> saizan_: I think I mean any type of array
05:36:17 <Saul__> Yeah ghc and clean both improve and learn from eachother, with the small language changes in clean accounting for the difference that remains between them
05:37:17 <Saizan_> so yeah, for example you can create arrays both of type Array and UArray that use any index you choose, e.g. Array Int a, UArray (Int,Int) a, Array (Int,Int) a, etc..
05:38:00 <Saizan_> but  'a' there must be one type for which there's a corresponding IArray instance
05:39:56 <frevidar> saizan_: I guess I'm a little bit confused about whats on this page: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
05:39:57 <lambdabot> http://tinyurl.com/333ztl
05:39:58 <Saizan_> Saul__: from what i've read some of the difference arises because GHC's assembly code generator is not excellent, but they are working on it
05:40:37 <frevidar> saizan_: the class IArray takes parameters a and e but then it talks about in the definitions the type
05:41:00 <frevidar> (cont) "a i e"
05:41:42 <frevidar> I don't understand the type system entirely, but that seems to imply that an array needs an element type and an index type
05:41:51 <Saizan_> yeah, a is the type of array, e is the type of elements, and i is the type of the index
05:42:02 <Saizan_> right
05:42:26 <Saizan_> but the class doesn't have i as parameter
05:42:58 <Saizan_> and that makes so every instance of IArray must work for any index type
05:43:05 <frevidar> so why is IArray only have the element as a parameter but when arrays are used in the function definitions they need an index and an element as a parameter
05:43:22 <frevidar> saizan_: ah, ok...
05:43:54 <frevidar> saizan: I think
05:44:04 <thoughtpolice> Saizan_: when GHC 6.10 hits with the completely native code backend, that is when the fun will start. :)
05:44:19 <thoughtpolice> er, I meant that for Saul__
05:44:23 <Saizan_> classes in haskell are only predicates on types with a connected interface, quite different from OOP ones
05:44:24 <thoughtpolice> stupid tab-complete :(
05:47:00 <frevidar> saizan_: so why not leave the element type out of the IArray definition?
05:47:27 <frevidar> saizan_: why not make it an IArray a instead of IArray a e?
05:48:53 <Saizan_> frevidar: because some instances have to restrict the types of elements they can work on
05:49:06 <Saizan_> frevidar: like UArray
05:49:51 <frevidar> saizan_: ah, ok. That makes sense now
05:51:40 <frevidar> saizan_: thanks!
05:52:38 <dcoutts> aaarg! URI doesn't use a derived Read/Show
05:52:49 <dcoutts> which means you cannot embed it in other structures usefully
05:55:10 <Saul__> Saizan_, thoughtpolice: Ok that should be cool
05:55:55 <Igloo> JaffaCake: These failures all happen with 6.8.2, so they aren't regressions at least
05:56:15 <JaffaCake> oh really?
05:56:38 <JaffaCake> 1288 is new isn't it?
05:56:49 <Igloo> Oh, hang on, I might have screwed up the commandline
05:57:35 <Igloo> JaffaCake: OK, ignore that, I'll test again  :-)
05:57:44 <JaffaCake> ah, ok
05:57:59 <JaffaCake> I'm sure 1288 was working, that's strange
06:02:24 <hpaste>  dcoutts annotated "BuildReport" with "example" at http://hpaste.org/8189#a1
06:08:50 <Igloo> JaffaCake: OK, here's the proper diff: http://hpaste.org/8190
06:09:26 <Igloo> JaffaCake: i.e. 6.8.3 is strictly better, except for the win32002 test where it's just different
06:10:24 <Igloo> (diff is from 6.8.2 output to the 6.8.3 output, for the tests that 6.8.3 failed in the nightly build)
06:10:29 <JaffaCake> that's strange, ghc-e003 and ghc-e005 are failing in the nightlies
06:13:57 <Igloo> Hmm, my 6.8 HEAD is failing ghc-e003 and ghc-e005, but the installed snapshot passes them
06:14:33 <Igloo> The snapshot is stage 2, right? I wonder if only stage 3 is broken
06:21:00 <Armored_Azrael> Is there any way to get GHC to allow module cycles?
06:21:09 <audreyt> Armored_Azrael: .hs-boot
06:22:06 <Armored_Azrael> (Messed up in my design phase, not enough time to fix it :P)
06:23:14 <audreyt> Armored_Azrael: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
06:23:14 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
06:29:17 <Gilly> let's suppose i have a map which i update (thus yielding a new map) in IO monad in a loop running forever. will ghc try to store infinitely many maps thus eating all the memory?
06:30:13 <Armored_Azrael> Whee. Project builds now
06:32:51 <Saizan_> Gilly: unless you're trying to return a list of those maps then no
06:33:00 <Saizan_> s/then//
06:33:59 <Gilly> ok, so forever $ do map <- updateMap map is perfectly fine?
06:34:55 <Gilly> (where forever a = do a ; forever a)
06:36:32 <Saizan_> Gilly: it's fine, just keep in mind that it obviously won't ever return a value
06:37:04 <nornagon> Gilly: um, no, the last statement in a do expression must be an actual statment
06:37:07 <nornagon> not a <-
06:37:13 <nornagon> or a let
06:37:26 <Gilly> nornagon: :)
06:38:07 <Gilly> Saizan_: hrm, i have this bad feeling that i'm not yet familiar enough with the way haskell evaluates things
06:39:18 <Saizan_> Gilly: in IO it's quite similar to how it works in imperative languages
06:39:49 <Gilly> ok
06:40:28 <Saizan_> and consider that you've garbage collection, so the parts of the previous map that are no longer referenced can be freed
06:41:02 <Gilly> yea
06:42:22 <frwmanners> Why the heck does the following code compile?
06:42:30 <frwmanners>  {-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleInstances #-}
06:42:30 <frwmanners>  module AssocTypesParadox       where
06:42:30 <frwmanners>  class Mul a b  where
06:42:30 <frwmanners>                 type MulResult a b :: *
06:42:30 <frwmanners>                 mul :: a -> b -> MulResult a b
06:42:32 <frwmanners>  instance Mul a b => Mul a [b]  where
06:42:35 <frwmanners>                 type MulResult a [b] = [MulResult a b]
06:42:38 <frwmanners>                 mul a = map (mul a)
06:42:40 <frwmanners>  instance Mul Int Float where
06:42:43 <frwmanners>                 type MulResult Int Float = Float
06:42:45 <frwmanners>                 mul a b = (fromIntegral a) * b
06:42:47 <frwmanners>  f :: (Mul a b, MulResult a b ~ b) => Bool -> a -> b -> [b]
06:42:50 <frwmanners>  f b x y = if b then mul x [y] else [y]
06:42:55 <nornagon> eep
06:42:59 <nornagon> please:
06:43:01 <nornagon> ?paste
06:43:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:43:02 <Saizan_> frwmanners: use hpaste.org
06:43:10 <frwmanners> Ok
06:43:41 <hpaste>  frwmanners pasted "AssocTypesParadox" at http://hpaste.org/8191
06:43:50 <frwmanners> Sorry 'bout that
06:45:13 <Saizan_> frwmanners: where's the paradox?
06:45:33 <frwmanners> Saizan_: I thought you could only use monotypes in Associated Type stuff
06:45:53 <frwmanners> Saizan_: It throws an error unless you have that type signature there
06:46:11 <Heffalump> Saizan_: the type signature on f?
06:46:17 <frwmanners> Saizan_: yep
06:46:28 <Heffalump> s/Saizan_/frwmanners/
06:46:47 <frwmanners> Heffalump: Sorry
06:47:13 <frwmanners> Heffalump: yep
06:47:24 * edwardk waves hello.
06:47:55 * ivanm waves back
06:47:58 <frwmanners> There's an implicit forall on a, b, which shouldn't be allowed when we use the type synonym
06:48:03 <vincenz> @hoogle join
06:48:04 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
06:48:04 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
06:48:04 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
06:48:05 <Saizan_> well monotypes means types with no quantifiers, not types without variables
06:48:09 * edwardk finally had coexponentials make sense to him.
06:48:58 <Saizan_> frwmanners: yeah, but you're not saying MulResult (forall a. a) b
06:49:10 <frwmanners> Saizan_: Hmm.  I'm trying to ascertain how Associated Types manage to realize this is a legal type signature, whereas related ones are undecidable
06:49:52 <frwmanners> Saizan_: And by extension why it does throw a monotype error when there is no type signature
06:52:06 <edwardk> a coexponential's coapply, if you change the notation slightly yields coapply :: b -> (b - a) + a  which fits perfectly with my notion of how to subtract generating functions for types. if you have refined types like open polymorphic variants it says that b - a is a b that is not also an instance of a.
06:52:28 <edwardk> and if you look at the signature of coapply, it does what you'd naturally expect a signature for subtraction to do in types
06:54:03 <edwardk> the issue is cocurry :: (c -> (b + a)) -> (c - b) -> a
06:54:47 <edwardk> which lacks a nice interpretation in terms of that model for me anyways
06:55:31 <Saizan_> frwmanners: it seems like arguments need to be monotypes to reduce the type synonim, but with that signature you're effectively delaying the reduction
06:56:07 <edwardk> adding cocurry, etc is where it appears that CCCs that are co-CCCs blow up.
06:56:31 <frwmanners> Saizan_: I see.  So how does it know when I've given a bad type signature which cannot be delayed?
06:56:39 <edwardk> trying to figure out if we view 'coapply' as a way to describe partial views if it is comparatively harmless.
06:58:56 <hpaste>  frwmanners annotated "AssocTypesParadox" with "(no title)" at http://hpaste.org/8191#a1
06:59:13 <frwmanners> Saizan_: E.g. the minor variant in the pastebin
06:59:23 <Saizan_> frwmanners: by looking at which types you're applying the methods and the instances in scope
07:00:42 <edwardk> ok, coapply as view checks out for me
07:01:38 <frwmanners> Saizan_: Right.  The second example is the example of something that doesn't terminate with FDs, because it keeps bouncing the type backwards and forwards, so I was wondering how ATs manage not to fall into the same trap.
07:01:53 <edwardk> is coevil good? =)
07:13:44 <edwardk> Ah anyways, cocurry makes sense if you read -> as > (or more canonically <=) cocurry :: (c <= b + a) -> (c - b <= a) reads off exactly like a statement about a poset
07:15:17 <roconnor> c - b?
07:16:00 <edwardk> roconnor: i was working up coexponentials to tie back to the generating function stuff.
07:16:04 <EvilTerran> ?bot
07:16:05 <lambdabot> :)
07:17:00 <edwardk> roconnor: a coexponential looks like subtraction of types. coapply :: b -> (b - a) + a      works out fine, its when you add cocurry and uncocurry that things blow up.
07:17:19 <EvilTerran> @check \p q -> (p < q) == (not p && q)
07:17:20 <lambdabot>  OK, passed 500 tests.
07:17:27 <roconnor> ok
07:17:35 <EvilTerran> er
07:17:42 <Saizan_> the different interpretation of arrows is justified?
07:17:53 <edwardk> saizan: the <= ?
07:18:10 <EvilTerran> @check \p q -> (p <= q) == (not p || q) -- that's the one we were after
07:18:11 <lambdabot>  OK, passed 500 tests.
07:18:16 <Saizan_> yeah, and that in cocurry you use both -> and (<=)
07:18:41 <roconnor> @scheck \p q -> (p <= q) == (not p || q)
07:18:43 <lambdabot>   Completed 4 test(s) without failure.
07:18:55 <EvilTerran> seeing as (p ==> q) = (not p || q)
07:18:57 <edwardk> saizan: ah thats because cocurry is an assertion of the existence of a morphism given another morphism, so the middle -> is 'extralogical' from the perspective of the category.
07:19:58 <Saizan_> i see
07:20:21 <roconnor> edwardk: this is the same - that I've seen in the lambad-mu-mu-tilde calculus
07:20:26 <edwardk> its like how if you generalize monadic bind :: (a ~> m b) -> (m a ~> m b)   the ~> is the hom for whatever category you are working over the -> is the fact that we witness this relationship in Hask
07:20:35 <edwardk> roconnor: yeah its not new
07:21:17 <Adamant> what's the category theory version of "Catagory Theory for Idiots"?
07:21:20 <edwardk> roconnor: i just was thinking about how to put together a blog post about what causes you to blow up into a poset when you are a CCC and CoCCC.
07:21:50 <edwardk> saizan: er rather its that we witness that relationship by writing a function in Hask
07:21:54 <roconnor> blow up into a poset?
07:22:12 <roconnor> aren't all posets categories?
07:22:23 <ecks>  /join #gtk
07:22:38 <edwardk> roconnor: if you can curry and cocurry, do there exist any interesting morphisms in the category?
07:22:45 <roconnor> oh
07:22:58 <roconnor> not sure I'd use the term blow-up :)
07:23:01 <edwardk> roconnor: turns out if you are a CCC and a CoCCC you lose all the interesting structure. you constrained yourself too much
07:23:06 <roconnor> more like collapse down.
07:23:07 <edwardk> ok, collapse =)
07:23:19 <roconnor> or co-blow-up
07:23:22 <edwardk> heh
07:23:48 <frevidar> I have a function that internally generates a data structure, but it doesn't return that data structure, it only returns a function that refers to that data structure. Is it possible to determine the type of that structure as part of the function call instead of hardcoding it?
07:23:49 <edwardk> roconnor: anyways what i was playing with was modeling the kinds of partial views (lenses) offered by f# as coapplication
07:23:55 <EvilTerran> ... so does "lapse" mean "blow up", then? that kinda makes sense...
07:24:05 <frevidar> I guess sort of like a template in c++?
07:24:34 <EvilTerran> frevidar, if i understand you right, it sounds like a job for a typeclass
07:24:55 <Saizan_> it's more like phantom types
07:25:30 <Saizan_> frevidar: you've to make the type of that structure appear somewhere in the type of your function, maybe with a fake parameter
07:25:50 <frevidar> for example, if I had a function in c++ say template <class T> int f<T>(int) where T could be some sort of buffer, say std::vector<int>, or maybe something else
07:26:01 <edwardk> roconnor: its more interesting to me in my untyped setting, but i was playing with it here
07:26:23 <Pingoui1> I want to create some constants attainable from anywhere in my program. What's the more idiomatic way to do that ? Something like "constant = 3" could makes name crashes, doesn't it ?
07:27:47 <Saizan_> Pingoui1: you can use the module system to manage the namespaces if it happens to be a problem
07:28:34 <Saizan_> frevidar: can you paste some haskell code where you're trying to do this?
07:30:12 <hpaste>  frevidar pasted "Want to replace "Array i (e,e)" and "Array i e" with "T i e" where T can be chosen at the call site" at http://hpaste.org/8192
07:30:19 <Pingoui1> Saizan_ : ok, so ther's no solution like a "CONSTANT = 3" in Ruby or a #define in C ?
07:30:33 <frevidar> saizan_: in the paste
07:31:29 <Saizan_> Pingoui1: you can use #define in haskell too, but it's not idiomatic for constants imo
07:33:42 <cjay> can someone recommend simple a way to do ssl connections to a irc server? is using hsgnutls the best way? HsOpenSSL seems to lack handshake stuff, but I'm not sure.
07:34:50 <Saizan_> frevidar: the simplest solution is to take an array as argument, ignore it, but use `asTypeOf` to make your generated array of the same type
07:35:32 <frevidar> saizan_: ah, ok. Are there other solutions?
07:36:07 <frevidar> (not that thats a bad solution, just wondering if there are any options)
07:36:20 <Pingoui1> Saizan_ : allright :) . A last question : from Haskell side, something like "constant = 3" is a constant function or a variable in the module namespace ?
07:36:30 <hpaste>  (anonymous) annotated "Want to replace "Array i (e,e)" and "Array i e" with "T i e" where T can be chosen at the call site" with "like this" at http://hpaste.org/8192#a1
07:38:28 <Saizan_> Pingoui1: it's a constant value, haskell variables are not mutable cells
07:39:29 <bluestorm> Saizan_: i've been thinking of one last thing concerning the fold/unfold
07:39:39 <Pingoui1> Saizan_ : ok thank you indeed ;) .
07:39:41 <Saizan_> frevidar: well they all need to make the type of the array appear in the overall type of tridiagonal_solve, either among arguments or return values
07:40:27 <Saizan_> bluestorm: being?:)
07:40:40 <bluestorm> fold_left cannot be (or "cannot be easily") transposed to trees or other recursive data structures because it requires, to be tail-recursive, that there is only one "recursive hole" per derecursified type
07:40:41 <frevidar> saizan_: the issue with that solution is that I'll have to add two extra arguments, as theres an Array i e and an Array i (e, e)
07:41:06 <bluestorm> is there a way to express that constraint (i think the used term is "linerarity" ?) at the type level ?
07:41:49 <bluestorm> i think that monads or even only function composition can be used to ensure linearity in the treatment of values
07:42:23 <bluestorm> (this was just an open question, probably nonsensical :)
07:42:46 <Saizan_> frevidar: you can manage to have only one
07:44:01 <bluestorm> hm
07:44:14 <Saizan_> uhm, i'm not so strong on the theory
07:44:16 <bluestorm> i'm not sure fold_left can manage lazy infinite structures
07:44:29 <Saizan_> fold_left can't
07:44:36 <Saizan_> if you mean foldl
07:46:14 <hpaste>  (anonymous) annotated "Want to replace "Array i (e,e)" and "Array i e" with "T i e" where T can be chosen at the call site" with "one arguemtn for both types" at http://hpaste.org/8192#a2
07:46:36 <roconnor> @seen magnus
07:46:37 <lambdabot> I haven't seen magnus.
07:46:58 <Saizan_> bluestorm: foldl has to recurse to the end of the list before it can return any value
07:47:33 <bluestorm> yeah, maybe tail-recursion is not so useful in haskell anyway
07:49:02 <Saizan_> it's the cause stack overflows if you don't add some strictness annotations, of if the compiler doesn't optimize for you
07:52:08 <Saizan_> bluestorm: do you know about data and codata?
07:52:13 <bluestorm> hmm
07:52:27 <bluestorm> read a tiny bit in a paper from Turner iirc.
07:53:46 <Saizan_> since a catamorphism is usually defined on data, i.e. least fixed point of a functor, so finite structures
07:54:17 <Saizan_> and ana- (unfoldr) for codata
07:54:24 <bluestorm> but in a lazyness setting they work on infinite structures too, can't they ?
07:54:57 <Saizan_> yeah, if the (f a -> a) function is sufficiently lazy
07:55:03 <bluestorm> (eg. you could define a perfectly sane "takeWhile" as a fold over an infinite stream)
07:55:59 <bluestorm> but in a strict language (actually i mostly use OCaml), this wouldn't work indeed
07:57:22 <bluestorm> hm
07:57:33 <bluestorm> you just said "least fixed point" : are there other fixed points ?
07:57:49 <bluestorm> i could see non-termination as a fixed point, but not a very interesting one
07:57:59 <Saizan_> greatest fixed point
07:58:11 <Saizan_> which is what is used to define codata
07:58:37 <Saizan_> but in haskell they are the same :)
07:58:53 <bluestorm> so how can we tell the difference ?
07:59:10 <frevidar> saizan_: was that typef supposed to be "typef"?
07:59:59 <Saizan_> frevidar: what do you mean? it's not a String
08:00:21 <frevidar> saizan_: is typef a typo?
08:00:39 <Saizan_> bluestorm: well, we don't, just pointing out that the theory makes this distinction :)
08:00:44 <frevidar> I just did a google for typef on haskell.org and didn't find anything, thats all
08:01:04 <Saizan_> frevidar: typef is just an arbitrary name, i define it at the bottom of the paste
08:01:25 <Saizan_> it was short for typefunction in my head :)
08:02:06 <frevidar> saizan_: ah, oops. Thanks :)
08:03:08 <Saizan_> bluestorm: since a catamorphism is not guaranteed to terminate on codata, while it is on data
08:03:33 <bluestorm> i see
08:04:54 <Saizan_> frevidar: does it make sense?
08:05:59 <frevidar> saizan_: It does. So would "template haskell" give me another way of doing this, if you know about that? or is template haskell not like c++ templates?
08:06:44 <Saizan_> frevidar: template haskell is more like lisp macros
08:11:22 <igel> hi
08:11:31 <igel> i need complete binary trees
08:11:37 <frevidar> saizan_: ah, ok, so template haskell doesn't really extend the type system, it just leads you run some code a compile time yes?
08:11:50 <igel> (this means, that each child of a node needs to have the same size)
08:12:03 <igel> is it possible to ensure this with haskell's type system?
08:12:26 <Saizan_> frevidar: exactly, generating new code
08:13:14 <wangor> sorry, this is very basic question - can I somehow put actions inside functions ? or only functions inside actions ? (I imagine it this way fun x y = parseSth getLine x y)
08:13:41 <Heffalump> actions are just functions or values themselves
08:13:43 <noecksit> hello, i have an idea about a monad but im not sure if i know how to implement it
08:13:50 <Heffalump> so you can put them anywhere you like, as long as the types match up
08:14:03 <wangor> ok, thanks
08:14:12 <Heffalump> to actually run them, you either need to invoke the run operation of the monad in question, or return them as results
08:14:23 <Heffalump> (and then run them elsewhere)
08:14:29 <noecksit> what i need to do is parse a string and get certain values, 5 of them, and then at the end create a data container of them
08:15:36 <noecksit> the way i have it right now is "do white <- parse findWhite; wrk <- parse find Wrk .. function (Room white wrk ..)"
08:16:25 <noecksit> however the parsing could fail, and in that case i just return a "" string, but I think I should return a Maybe String rather than a String
08:17:44 <noecksit> so right now, im just creating a Room with empty strings, i was hoping I could do better and detect if any of the outputs are nothing and in that case just return () rather than creating a new data type
08:17:45 <BONUS> whats the function for finding a third root
08:18:06 <MyCatVerbs> BONUS: (**(1/3)), offhand.
08:18:16 <BONUS> ah i didnt know you can do ** on fractals
08:18:16 <BONUS> kewl
08:18:24 <MyCatVerbs> ...can you? oO
08:18:45 <BONUS> O_O
08:19:13 <noecksit> i could check each output from the parse monad to see if its nothing, but I thought it would be better to use >>= since I know that if a parameter is Nothing a computation fails
08:19:56 <MyCatVerbs> BONUS: (**(1/3)) has type Floating a => a -> a -- the 1/3 there will usually be a Float or Double.
08:20:23 <BONUS> ah yeah
08:20:24 <noecksit> but how could i pass the value from the first parsing, to the second parsing, to the third parsing and so on?
08:20:38 <BONUS> float, of course
08:20:49 <MyCatVerbs> BONUS: and doing ** on a fractal is a rather more... involved operation than doing ** on a _fraction_. Which is what I think you meant, no?
08:21:11 <MyCatVerbs> Aha! That's where I put that banana.
08:21:37 <BONUS> ahah, yes :D
08:21:49 * MyCatVerbs takeMVar hand >>= writeChan stomach
08:22:31 <BONUS> man juggling with numeric types is really a pain sometimes
08:22:40 <MyCatVerbs> Hehehe. mathematician :: Coffee -> IO Theorem.
08:23:27 <Saizan_> noecksit: are you already using a parsing monad?
08:23:43 <BONUS> how would you check if a number is a cube
08:23:44 <BONUS> in haskell
08:23:47 <noecksit> Saizan_: yes, im using parsec
08:23:59 <BONUS> (round (n**(1/3))**3 == n
08:24:04 <BONUS> seems to whine a lot
08:24:06 <BONUS> about types
08:24:45 <bauchus> ?where atExit
08:24:45 <lambdabot> I know nothing about atexit.
08:24:51 <bauchus> :-(
08:25:19 <MyCatVerbs> BONUS: replace n there with fromInteger n -- or fromIntegral n
08:25:56 <BONUS> yeah i tried that too
08:25:59 <BONUS> doesnt seem to cut it
08:26:17 <noecksit> they have a Left for error, but I'm not sure how I could it
08:26:18 <MyCatVerbs> BONUS: IMHO, the about types is actually a beautiful feature. No more numerical-C-disease where precision suddenly disappears out the window because of an implicit conversion I missed.
08:26:46 <BONUS> yeah, i agree
08:26:56 <Saizan_> noecksit: so you could have .e.g parseRoom :: Parser Room, which would fail in the parsec monad if any of the components fail, and use "liftM Just parseRoom <|> return Nothing"
08:27:00 <BONUS> but sometimes you'd just like to do some quick inprecise number crunching
08:27:11 <MyCatVerbs> noecksit: there's a Monad and a MonadFail instance for Either String in, I think, Control.Monad.Instances.
08:27:26 <Saizan_> MyCatVerbs: MonadError
08:27:35 <MyCatVerbs> Saizan_: whoops, of course.
08:27:57 <MyCatVerbs> BONUS: hpaste the context and the error, please?
08:28:07 <BONUS> sure
08:28:08 <BONUS> just a sec
08:28:29 <MyCatVerbs> BONUS: (the trick is to always have a H-M inferrer running as a background process in your brain, like Oleg. ;)
08:28:37 <BONUS> haha
08:28:49 <BONUS> wait got it figured out
08:28:51 <BONUS> i was using round
08:28:58 <BONUS> and i had to put fromIntegral
08:29:03 <Saizan_> MyCatVerbs: Oleg has a prolog implementation, also
08:29:05 <BONUS> to round too
08:29:14 <MyCatVerbs> Saizan_: uhhhh...
08:29:27 <Philippa_> MyCatVerbs: to handle the typeclass stuff
08:29:28 <BONUS> basically i had to put 3 fromIntegrals ughghghg
08:29:38 <BONUS> isCube n = (fromIntegral (round ((fromIntegral n)**(1/3))))**3 == (fromIntegral n)
08:29:42 <MyCatVerbs> Saizan_: H-M pretty much _is_ Prolog, or at least isomorphic to it. Just with the occurs check put back in.
08:29:50 <MyCatVerbs> Saizan_: isn't it?
08:31:08 <Saizan_> MyCatVerbs: you refer to unification? the MTCP + fundep tricks looks much more like logic programming though :)
08:31:23 <MyCatVerbs> BONUS: isCube n = let m = (fromIntegral n)**(1/3) in fromIntegral m == round m -- two! :D
08:31:33 <BONUS> hmmmmmm!
08:31:41 <MyCatVerbs> Saizan_: MTCP?
08:32:15 <Saizan_> err MPTC, MultiParameterTypeClasses
08:32:23 <MyCatVerbs> Oh right, of course.
08:32:38 <noecksit> Saizan_ : im not parsing the whole Room though, im parsing each individual entity and then at the end combining it into a Room data type
08:33:26 <MyCatVerbs> Yes, but I was referring to just plain H98. MTCP+fundeps is Turing-complete, and that kinda invalidates pretty much every possible remark you might wish to make about the whole process.. :)
08:34:55 <Saizan_> MTCP+fundeps+some other flags
08:35:01 <hpaste>  noecksit pasted "(no title)" at http://hpaste.org/8193
08:35:08 <Saizan_> which oleg usually enables anyway :)
08:36:30 <MyCatVerbs> Saizan_: {-# OPTIONS-GHC -fglasgow-exts #-} is just another way of saying, "Eh, whatever. I was gonna pull them all individually -anyway-..."
08:38:00 <Saizan_> no, you need overlapping and undecidable instances, which are not enabled by -fglasgow-exts as they are not safe enough
08:39:19 <Saizan_> noecksit: i'd make getParsed return Nothing or Just x, and then use "liftM5 Room white wrk black brk move" to get a Maybe Room
08:39:20 <MyCatVerbs> Ohhh, I see.
08:40:54 <Saizan_> ?ty liftM5 -- exists?
08:40:57 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
08:41:35 <Botje> all the way up to liftM7
08:42:10 <BONUS> `ap` owns
08:42:13 <MyCatVerbs> Bah, humbug. By the time you've reached liftM4 and above, surely anyone sane would take that as a sign to start using ap.
08:43:30 <smg> BONUS: why?
08:43:44 <BONUS> idk, it seems cleaner to me then using liftM3483
08:44:20 <BONUS> > return (*) `ap` (Just 3) `ap` (Just 9)
08:44:21 <lambdabot>  Just 27
08:44:32 <BONUS> > return (*) `ap` (Just 3) `ap` Nothing
08:44:33 <lambdabot>  Nothing
08:44:43 <Saizan_> using 3483 ap-s is not so elegant either :)
08:44:47 <smg> > (*) 3 9
08:44:48 <lambdabot>  27
08:44:49 <smg> ?
08:45:10 <BONUS> its a matter of preference i guess
08:45:24 <Syzygy-> Saizan_: Isn't <$> equivalent to `ap`?
08:45:28 <MyCatVerbs> liftMn f p1 p2 p3 ... pn = (return f) `ap` p1 `ap` p2 `ap` p3 `ap` ... pn
08:45:59 <MyCatVerbs> Syzygy-: <$> is another way of writing fmap.
08:45:59 <Baughn> Does GHC do any runtime code generation?
08:46:06 <Syzygy-> Ah.
08:46:09 <Saizan_> Syzygy-: <*> is
08:46:12 <Baughn> I mean, without me asking it to do so?
08:46:14 <Syzygy-> Oooooh.
08:46:28 <Syzygy-> > return (*) <*> (Just 3) <*> (Just 9)
08:46:30 <lambdabot>  Just 27
08:46:40 <MyCatVerbs> Baughn: yup.
08:46:53 <Syzygy-> > liftM2 (*) (Just 3) (Just 9)
08:46:54 <lambdabot>  Just 27
08:47:01 <Baughn> MyCatVerbs: That explains these results. :(
08:47:06 <Baughn> MyCatVerbs: Any references on that?
08:47:08 <MyCatVerbs> Baughn: if you want to pass a Haskell closure to a C function using the FFI, it generates a trampoline.
08:47:28 <noecksit> ok, it seems that white, wrk, black, brk, move are all Maybe [Char], but the constructors of Room expect String, wouldn't i need to do fromJust first?
08:47:35 <Baughn> MyCatVerbs: And that's it? Hmm..
08:47:50 <MyCatVerbs> Baughn: which is a tiny little stub function that loads the required instane variables then jumps into the function body. It's so that you can call the function from C just by doing *pointer() instead of *pointer(instancevariables);
08:47:59 <Baughn> MyCatVerbs: I'm not doing FFI in this program, so I think I'm losing symbols somewhere. *reads more source*
08:48:08 <MyCatVerbs> Baughn: I think so. That's the only one I -know- of, anyway.
08:48:50 <frevidar> I've been thinking about something igel asked earlier.
08:48:56 <Saizan_> noecksit: liftM5 will care about it for you, yielding Nothing if any of them is Nothing
08:49:11 <Baughn> MyCatVerbs: Such closures may be functions of a sort, but it wouldn't get in the way of serializing thunks - they'd never.. be.... drat.
08:49:19 <frevidar> is it possible to do something like this?
08:49:21 <frevidar> data Natural = Zero | Succ Natural
08:49:22 <frevidar> data Tree (Succ Natural) = Tree (Tree Natural) (Tree Natural)
08:49:23 <smg> omg, my haskell instructor can't read my haskell code...
08:49:24 <frevidar> data Tree Zero = Leaf
08:49:31 <frevidar> I know thats not real haskell code
08:49:38 <MyCatVerbs> Baughn: hrmn?
08:50:22 <Syzygy-> smg: Hehe
08:50:26 <Baughn> MyCatVerbs: Just thinking out loud. You could perfectly well have a thunk that, when dethunked, calls a C function with an already-evaluated haskell function trampoline for a parameter
08:50:27 <MyCatVerbs> Baughn: closures, lambdas, whatever. All partial applications generate closures, too. map (==) [1..7] gives you no less than seven! :)
08:50:31 <Saizan_> frevidar: but there's a way to write almost that in haskell
08:50:40 <smg> Syzygy-: :(
08:50:41 <Syzygy-> smg: Are you writing illegible, or is he not sophisticated enough? :)
08:50:46 <igel> frevidar: the thing is i don't know how to realise this without a c++ template like feature
08:50:49 <noecksit> it says "couldnt match expected type "IO String" agains "Maybe [Char]", would i need to do "liftIO" on it as well?
08:50:57 <smg> Syzygy-: exercise1 = (any((>1) . length) . group . words)
08:51:05 <smg> Syzygy-: he does not understand and give me 0 points...
08:51:13 <smg> Syzygy-: also i commented that code...
08:51:20 <Baughn> MyCatVerbs: There's a fundamental difference between thunks and runtime code generation. Simple thunks can be reduced to a symbol plus some arguments, but runtime-generated code won't have a symbol or, if it does, still won't be around for the next run
08:51:23 <frevidar> saizan_: how so?
08:51:29 <Syzygy-> smg: And you were supposed to figure out whether there was any repetitions in the words?
08:51:39 <Baughn> MyCatVerbs: They should be regenerateable, but I'll have to handle that specially. :/
08:51:40 <noecksit> oh, im not in the IO monad there
08:51:42 <smg> Syzygy-: yes
08:51:46 <Syzygy-> Perfectly fine code imo
08:51:53 <igel> :D
08:51:58 <Baughn> That's not my current issue, though. *goes away*
08:52:01 <smg> imho too but he says "that code no one understands"
08:52:07 <Syzygy-> You could use a little bit more white-space, but ...
08:52:34 <smg> i'm annoyed now :|
08:52:39 <MyCatVerbs> Baughn: I've no clue what you're up to there. The trampolining that GHC does for the FFI is quite distinct from the thunking mechanism.
08:52:40 <igel> maybe he's just embarressed that you can solve the task in just one line ;)
08:54:01 <MyCatVerbs> smg: perhaps he's teaching from a textbook, reading one chapter ahead of what he's set the students each time, and hasn't gotten to the part on point-free style yet? ;P
08:54:05 <pozic> smg: can you state the exact problem?
08:54:11 <pozic> smg: I think your solution is wrong.
08:54:19 <smg> pozic: i see
08:54:19 <Baughn> MyCatVerbs: I'm building some machinery to be able to serialize thunks, simple enough
08:54:38 <jamii> Stupid irc blocking network
08:54:38 <pozic> smg: ?
08:54:39 <hpaste>  Saizan pasted "complete binary tree" at http://hpaste.org/8194
08:54:42 <jamii> Stupid web client
08:54:58 <MyCatVerbs> Baughn: isn't that, y'know, intractable?
08:55:02 <Baughn> MyCatVerbs: And clone them, though that's simpler. The only problem is.. among my problems is, runtime code generation makes it hard to serialize anything
08:55:07 <Baughn> MyCatVerbs: Not to my knowledge
08:55:13 <jamii> Anyway: having trouble building the collections library. I have Ranged-sets installed by cabal-install. ghc-pkg says it registered properly in a hidden dir in my home folder, but the build fails with:
08:55:19 <Syzygy-> > (any((>1) . length) . group . words) "a b c b a"
08:55:20 <lambdabot>  False
08:55:21 <MyCatVerbs> Baughn: I mean, what if one of those thunks contains an unsafeInterleaveIO'd call to read from a handle?
08:55:21 <jamii> Setup.hs: At least the following dependencies are missing:
08:55:25 <Syzygy-> > (any((>1) . length) . group . words) "a b c c b a"
08:55:26 <lambdabot>  True
08:55:30 <jamii> Ranged-sets -any
08:55:30 <Saizan_> igel, frevidar: 17:53        smg : omg, my haskell instructor can't read my haskell code...
08:55:36 <jamii> ghc-pkg list gives:
08:55:44 <Baughn> MyCatVerbs: That's the user's problem
08:55:45 <pozic> Syzygy-: right, I had a different, but semantically same test.
08:55:49 <Saizan_> http://hpaste.org/8194
08:55:52 <jamii> Ranged-sets-0.2.0
08:56:05 <MyCatVerbs> Baughn: fair 'nuff.
08:56:08 <Baughn> MyCatVerbs: It's *unsafe*. This is just another caveat to add to its documentation.
08:56:14 <jamii> '/home/jamie/.ghc/i386-linux-6.8.2/package.conf:
08:56:24 <pozic> Syzygy-: too bad that having leet Haskell skills still requires one to think.
08:56:57 <Baughn> MyCatVerbs: Anyway, it has to do a deep copy of parameters (stopping at thunks, of course), so you want to be very careful about what you pass to the serializer
08:57:30 <MyCatVerbs> Baughn: *nodnod*.
08:57:35 <MyCatVerbs> Baughn: what's it being used for?
08:57:48 <frevidar> saizan_: nice!
08:58:03 <Baughn> MyCatVerbs: Dunno yet; I'm sure people will figure something out.
08:58:18 <MyCatVerbs> pozic: not only that, but the leeter you get, the more of the easy problems become solved, leaving only the harder ones behind. ;)
08:58:34 <Baughn> MyCatVerbs: Being able to pass arbitrary haskell structures over a network.. could be useful
08:58:38 <MyCatVerbs> Baughn: ehhh? But what are _you_ planning to use it for?
08:59:05 <Baughn> MyCatVerbs: Ideally, to replace a lot of explicit laziness and serialization code in a game I'm working on
08:59:10 <MyCatVerbs> Baughn: oh, fair enough. Aren't there places where a combinatorial explosion could occur, though?
08:59:27 <Saizan_> frevidar: i forgot the a parameter in many positions, btw
08:59:43 <Codex_> passing functions over network is pretty tricky business.
08:59:46 <noecksit> hello, how does ghc determine which monad to use when encapsulating with liftM5?
08:59:55 <Baughn> MyCatVerbs: No. Worst-case, you might serialize a reference that ends up packing in the /entire/ state of your haskell program, but that's still linear
09:00:08 <Botje> noecksit: the context it's used in, and the arguments
09:00:12 <Botje> like any function, really
09:00:15 <MyCatVerbs> Baughn: buhhhh... fucking big-O notation. Constants matter sometimes, dammit! ;)
09:00:17 <Baughn> Codex_: I'm not passing functions, just symbols. It won't work if you aren't running approximately the same code on both ends
09:00:30 <pozic> noecksit: by type-inference
09:00:33 <Saizan_> noecksit: by the type of the parameters and how the result is used
09:00:36 <noecksit> because I am not in the IO monad, and my parameters are the Maybe monad, but it still thinks its IO
09:00:46 <Baughn> MyCatVerbs: I don't want to see the constant that could make O(n) worse than O(n!) -_-
09:00:55 <Botje> noecksit: try setting the type manually
09:01:10 <Baughn> Codex_: Yes, it's tricky, and yes, this is a very limited approach - but it's a lot better than nothing
09:01:11 <MyCatVerbs> Baughn: put a ceiling on n and set the constants high.
09:01:13 <Botje> liftM5 ... ..... :: Maybe Something
09:01:13 <pozic> noecksit: you mean you think you are not in the IO monad :)
09:01:32 <Baughn> MyCatVerbs: If you put a ceiling on n, then it's O(1) in any case. :P
09:01:36 <Botje> but yeah, chances are you're using IO somehwere
09:01:59 <noecksit> pozic: well my monad returns a ReaderT monad, not an IO monad
09:02:28 <noecksit> oh, im using liftIO before than that i didnt notice
09:02:34 <pozic> noecksit: if you are using ghc-6.8.2, you are wrong.
09:03:30 <MyCatVerbs> Baughn: not... quite. After all, many things in the world are limited to a maximum n of about... roughly 3e80, since it's difficult to encode more data than there are protons in the universe.
09:03:52 <Baughn> MyCatVerbs: Correct, therefore everything is O(1)
09:03:55 <Baughn> Mathematically speaking
09:04:06 <MyCatVerbs> Baughn: and yet we still feel comfortable talking about asymptotics. :)
09:04:14 <pozic> MyCatVerbs: isn't that an estimate or has there been some proof that says there is an upperbound?
09:04:24 <Baughn> MyCatVerbs: Because we can imagine how the functions would act if there /weren't/ limits
09:04:25 <MyCatVerbs> pozic: that is an estimate.
09:04:43 <Baughn> pozic: It's still possible that it's infinite. Might not even be a countable one
09:04:56 <MyCatVerbs> Baughn: pffft, imagination. Fine enough, but here in the real world we want -results-! :D
09:05:53 <MyCatVerbs> pozic: but of course, there's always the outside possibility that current astronomy is really really far off the mark, and the universe is actually much bigger or smaller or maybe the question itself is somehow meaningless.
09:06:03 <MyCatVerbs> pozic: I wouldn't hold my breath for that, though.
09:06:32 <Baughn> MyCatVerbs: Ah, it's entirely possible that the geometry of space-time is anything but flat at large scales
09:07:23 <Baughn> And I think there's one version where the universe is very tiny but multiply connected in odd fractal-ish fashions that's still consistent with evidence
09:07:34 <Baughn> Though the "flat infinite universe" version is certainly a lot simpler
09:08:22 <MyCatVerbs> Baughn: it's entirely possible that we exist entirely on the surface of a donut which is about to be eaten by a pan-dimensional alien called Frederick, and you could probably wrangle -that- to be consistent with observations too, given enough work. Wouldn't be very parsimonious, though. ;)
09:10:39 <Baughn> MyCatVerbs: There's complex, and then there's _complex_. Your version would be orders of magnitude less likely than even the fractal universe. :P
09:12:07 <Baughn> MyCatVerbs: Remember, the bayesian prior for any laws of physics is inversely proportional to the exponentiation of their kolmogorov complexity. Probably.
09:12:38 <MyCatVerbs> Baughn: "remember!?" I didn't know that in the first place.
09:12:58 <Baughn> MyCatVerbs: Perhaps, but now you can remember. :P
09:12:59 <MyCatVerbs> Baughn: I probably will now, though. It's a bloody good way of formalising the idea of parsimony.
09:13:00 <pozic> Baughn: isn't that a meaningless proposition?
09:13:20 <MyCatVerbs> pozic: it's the assumption that pretty much all physis is based on.
09:13:22 <Baughn> pozic: Nope. Actually, it's the formalization of occam's razor
09:13:39 <Baughn> pozic: There are very good reasons to believe it's also true
09:13:44 <pozic> Baughn: yes, I understand it is the formalisation of occam's razor.
09:13:53 <Baughn> Not just for the laws of physics, but for /any/ statement
09:13:59 <MyCatVerbs> pozic: we _could_ model the universe as a giant mess of special cases, but instead we try to construct general laws. We prefer the general laws because they're simpler, have lower complexity.
09:14:19 <Baughn> And because, according to statistics, lower complexity means higher probability
09:14:24 <pozic> MyCatVerbs: Kolmogorov complexity is just one kind of complexity.
09:14:31 <Baughn> Add *one bit* to the description of a theory, and you need twice as much evidence to prove it
09:15:07 <Baughn> pozic: True, but it's a jolly good one that fits very well with reality
09:15:30 <ttt--> "Any small explanation also has equivalent big explanations, so there are more explanations of it, so it has a bigger chance of being true (given all explanations have equal chance)"  <- is that correct?
09:15:45 <Baughn> ttt--: YEs, that's another way of putting it
09:15:47 <ttt--> the correct way to interpret that law
09:16:10 <ttt--> that's how i tried to understand it, but i'm not sure if it's correct
09:17:11 <Baughn> For any reasonably complex theory, if you're not biased, you need a lot more evidence to pick it out of the soup of possible theories than you need to then prove it. That's another simple derivation
09:18:19 <Baughn> (A theory 60 bits long would need 60 bits of evidence to find (at the very least), and then each further bit doubles its probability. Mst theories take more than sixty bits to describe..)
09:18:32 <Baughn> ..and when did this turn into #metaphysics?
09:19:21 <pozic> Baughn: someone claimed everything was O(1).
09:19:28 <Baughn> pozic: Oh, right
09:19:33 <Baughn> Oops
09:21:07 <wangor> sorry is there a empty instruction (nop, pass) in Haskell ? (need to fill else with something in an action)
09:21:08 <pozic> Can anybody else run this code in 5.5 seconds compiled? http://therning.org/magnus/archives/353?&owa_from=feed&owa_sid=
09:21:28 <Baughn> wangor: return ()
09:21:31 <wangor> thanks
09:21:33 <pozic> wangor: return <value of type you are interested in>
09:21:46 <pozic> wangor: return undefined works always
09:21:55 <Baughn> wangor: return undefined. Unless you then try to /use/ it. :P
09:22:00 <mehrheit> :t when -- wagnor
09:22:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:22:07 <Baughn> wangor: Oh, but normally you don't /need/ something like this..
09:22:14 <MyCatVerbs> Baughn: heh. I do that all the time.
09:22:17 <wangor> I see, thanks
09:22:17 <mehrheit> if without the else
09:22:25 <pozic> wangor: or return (error "OMG, WHAT ARE YOU DOING?!!!")
09:23:07 <geezusfreeek> :t error
09:23:08 <lambdabot> forall a. [Char] -> a
09:23:11 <MyCatVerbs> Baughn: if foo then bar else return undefined, where I'm not interested in the answer. I even usually have: nuffin = return undefined, for purposes of: if foo then bar else nuffin. :)
09:23:18 <pozic> I ran that code and after 24 minutes (!) it still didn't have an answer ready.
09:23:41 <Baughn> MyCatVerbs: See, that'S what when is for
09:23:48 <mmorrow> (slightly on topic) i always thought the coolest part of general relativity is how once you cross an event horizon the time dim in your metric flips sign...so as you approach the center of the black hole you approach the beginning of time (although general relativity can't account for *the* center, which is considered a shortcoming of the theory)
09:25:11 <mmorrow> how far an interpretation of that should go is another story...
09:26:38 <TomMD> So if I "jump into" a black hole I can, for an extemely brief period of time, see the original Haskell committee?
09:26:47 <Baughn> "collide _ Singularity = undefined"
09:26:58 <MyCatVerbs> Baughn: doesn't really suffice though. Lots of places, I want to use actions that return things other than () for their side effects.
09:27:09 <mmorrow> you can't ever get back to the other side of the event horizon, so no
09:27:18 <MyCatVerbs> Baughn: and putting (>> ()) on the end of them doesn't really seem like a very nice option. :P
09:27:44 <mrd> TomMD: or, you could travel 20 light years away ... instantly?
09:27:53 <Baughn> MyCatVerbs: dropV f = f >> return () -- or something
09:27:57 <mmorrow> unless the center of all black holes was wired to point of the big bang or something
09:28:15 <maltem> when_ p x = if p then x >> return () else return ()
09:28:37 <TomMD> mmorrow: I'm willing to take the risk, for the sake of renaming haskell to "Curry".
09:28:43 <mmorrow> heh
09:29:23 <mmorrow> scrunch up *really tightly* into a ball so you're not ripped apart atom-by-atom
09:29:24 <MyCatVerbs> Baughn: er, nein, danke. That's just saying dropV = (>> return ()), which is... negligible, more or less. Just a few fewer characters.
09:29:38 <chessguy> Baughn, MyCatVerbs  i was just wondering yesterday if there should be a standard function like that
09:29:50 <chessguy> Monad m => m a -> m ()
09:30:13 <Saizan_> TomMD: there's already a logic-functional language named curry, though
09:30:16 <TomMD> mmorrow: Sounds good.  I'll model it in using the probabalistic functional programming package and working with Hawkings.
09:30:24 <MyCatVerbs> Baughn: I'd rather have ehWhatever b a = if b then a else return undefined -- in ehWhatever foo bar
09:30:49 <TomMD> Saizan_: You aren't thinking three dimensional - I can name Haskell Curry before that Curry exists!
09:31:18 <chessguy> i was going to call it 'discard' though
09:31:21 * TomMD is not sure if that "Back to the Future" quote was correct.
09:31:26 <mmorrow> TomMD: to infinity and beyond!
09:31:28 <maltem> MyCatVerbs: It would make me uneasy to throw undefineds around where they aren't necessary
09:31:29 <Baughn> TomMD: Four-dimensional. Despite what star (trek|wars) teaches, space is not two-dimensional.
09:31:38 <pozic> TomMD: why would they care about some crazy guy from the future?
09:32:16 <TomMD> pozic: I'll be sure to go back with complete psychological understanding of all the members.
09:32:29 <noecksit> hello, im not sure if anyone remembers, but i think for my example i need to use MaybeT rather than the Maybe datatype
09:32:56 <TomMD> Step 1: Meet with all members of original Haskell committee to make profile.  Step 2: ?  Step 3: rename Haskell!
09:34:13 <MyCatVerbs> maltem: (>>= return ()) ignores the output type of its parameter too. Just with a \_ -> ... instead of an undefined.
09:34:33 <Baughn> TomMD: I dislike paradoxes. Please don't do that.
09:34:48 <MyCatVerbs> maltem: type-wise, I don't see any particlar difference in magnitude between their sinfulnesses.
09:35:13 <MyCatVerbs> maltem: as far as being intrinsically scared of undefineds goes, uh, fear no evil?
09:35:48 <Baughn> MyCatVerbs: The only reason yours works is because very few people check to make sure () is, in fact, () and not bottom
09:36:04 <Baughn> See no evil ineed
09:36:05 <MyCatVerbs> Baughn: s/very few/no/
09:36:18 <Saizan_> noecksit: use let instead of those <-
09:36:33 <MyCatVerbs> Baughn: under what possible situation would you care to try to distinguish () from _|_?
09:37:12 <mmorrow> Baughn: Good point, if TomMD every manages to rename Haskell to Curry via entering a black hole and somehow reaching our past Haskell would already be Curry and we wouldn't be having a discussion so sadly TomMD is ripped apart atom-by-atom when he finally tries :(
09:37:45 <noecksit> Saizan_ : what do u mean? let white = getParsed ..?
09:37:55 <astrolabe> But maybe an earlier TomMD renamed Curry to Haskell.
09:37:57 <MyCatVerbs> mmorrow: not -quite-. Black holes are quicker than that, they'd be able to rip up a few atoms in parallel at least. ;)
09:38:11 <geezusfreeek> MyCatVerbs: as far as value does, i can't think of an example, but the type suggested by undefined (fully polymorphic) might allow things to compile that are otherwise invalid if it is not constrained by a type annotation
09:38:22 <mmorrow> atoms-by-atoms ;)
09:38:35 <pozic> Or, just maybe the time cops intervened...
09:38:59 <mmorrow> those bastards!
09:39:20 <Saizan_> noecksit: yeah, but it depends on how you define getParsed
09:39:39 <maltem> MyCatVerbs: I mean, once you have an undefined somewhere, someone _might_ at some point feed into a strict function, and boom.
09:39:40 <Baughn> MyCatVerbs: If I use deep-rwhnf or some such in a parallel program, for one
09:40:14 <geezusfreeek> for example, if i have putStrLn' str = putStrLn str >> return undefined, then that would allow me to do something stupid like x <- putStrLn' "foo", giving me an undefined x that i can use anywhere
09:40:15 <Baughn> MyCatVerbs: It's very unlikely that your style will hit back, but once it /does/, debugging it could be.. hairy
09:40:23 <noecksit> Saizan_ : i defined it a monad
09:40:43 <noecksit> its actually just a wrapper around parse from parsec
09:41:28 <MyCatVerbs> Baughn: debugging it? Nah. Just assert that all instanes of ehWhatever end up on the left hand side of an >>.
09:42:45 <MyCatVerbs> That, pretty much without exception, gets used exclusively in IO-heavy code where a lot of mucking around with descriptors and resources is being done - not buried in computational code.
09:43:35 <noecksit> what!! i dont have Control.Monad.Maybe, that sux
09:43:40 <MyCatVerbs> Alternatively, you could formulate ehWhatever cond action = if cond then action >> return () else return () -- but that is, IMO, gratituous.
09:43:54 <Saizan_> noecksit: if you define it to return just a Maybe String then you can run all that portion of the code in the Maybe monad
09:43:56 <MyCatVerbs> noecksit: ewwww. Debian or Ubuntu machine?
09:44:03 <Saizan_> and get a Maybe Room
09:45:03 <noecksit> MyCatVerbs : gentoo actually
09:45:46 <Saizan_> there's no Control.Monad.Maybe ..
09:45:55 <TomMD> noecksit: There is no Maybe, there is Just or just Nothing.
09:45:59 <Saizan_> in the standard libraries at least
09:46:08 <bauchus> how can I write this code better? mapM_ closeDevice $ maybeToList device
09:46:26 <TomMD> The RWH book has an chapter where they build what should be Control.Monad.Maybe
09:46:27 <Deewiant> fmap closeDevice device
09:46:37 <Baughn> bauchus: Looks good to me
09:46:55 <noecksit> http://hackage.haskell.org/packages/archive/MaybeT/0.1.1/doc/html/Control-Monad-Maybe.html
09:46:56 <lambdabot> http://tinyurl.com/6oyyaq
09:46:59 <Saizan_> Deewiant: not quite
09:47:11 <Baughn> fmap would involve building up a list of return values that then get GC'd
09:47:11 <TomMD> mapM_ (fmap closeDevice) device
09:47:32 <Deewiant> @ty maybeToList
09:47:34 <lambdabot> forall a. Maybe a -> [a]
09:47:34 <Saizan_> ?type maybeToList
09:47:36 <lambdabot> forall a. Maybe a -> [a]
09:47:44 <noecksit> i thought it would be included if Control.Monad.Reader or Control.Monad.State are included
09:48:01 <Saizan_> ?type \closeDevice device -> mapM_ closeDevide $ maybeToList device
09:48:02 <Deewiant> well, (fmap closeDevice device) >> return () ?
09:48:03 <lambdabot> Not in scope: `closeDevide'
09:48:11 <Saizan_> ?type \closeDevice device -> mapM_ closeDevixe $ maybeToList device
09:48:12 <lambdabot> Not in scope: `closeDevixe'
09:48:14 <Saizan_> ?type \closeDevice device -> mapM_ closeDevice $ maybeToList device
09:48:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> Maybe a -> m ()
09:48:27 <bauchus> ok, i'll keep my code. thanks
09:48:50 <Deewiant> ?ty \closeDevice device -> fmap closeDevice device >> return ()
09:48:52 <lambdabot> forall a a1 (m :: * -> *). (Monad m, Functor m) => (a -> a1) -> m a -> m ()
09:49:03 <Deewiant> ah, right
09:49:11 <Saizan_> Deewiant: fmap closeDevice device would give Maybe (m a)
09:49:13 <noecksit> omg, this is becoming a pain, i think ill just check each return manually
09:49:36 <pozic> Why does one write about Python in a Haskell book?
09:50:58 <pozic> Just because the author happens to know something about Python? Every programmer can read "pseudo-code", AFAIK, no need to drag in any reference to Python, but maybe that has already changed...
09:51:13 <vixey> pozic: Yeah wikipedia is guilty of that too
09:51:14 <hpaste>  (anonymous) annotated "(no title)" with "with let" at http://hpaste.org/8193#a1
09:51:25 <vixey> pozic: It's a shame but what can you do?
09:52:01 <pozic> vixey: I could rewrite the book, but I have little interest in doing so.
09:52:58 <vixey> > let sieve (p:rest) = p:sieve [r | r <- rest, r ‘rem‘ p /= 0] in seive 2
09:52:58 <lambdabot>  Illegal character ''\128''
09:52:58 <lambdabot>  at "rem..." (column 49)
09:53:24 <pozic> vixey: do not copy paste from acrobat reader...
09:53:24 <vixey> > let sieve (p:rest) = p:sieve [r | r <- rest, r `rem` p /= 0] in seive [2..]
09:53:25 <lambdabot>   Not in scope: `seive'
09:53:31 <vixey> > let sieve (p:rest) = p:sieve [r | r <- rest, r `rem` p /= 0] in sieve [2..]
09:53:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:53:48 <vixey> pozic yes :*
09:53:53 <vixey> :( *
09:54:05 <bauchus> Today I had some troubles with Haskells OpenAL packages. Segfaults with the gentoo openal package... The solution is to use openal-soft (but there is no gentoo package). Then it starts to work really fine...
09:54:33 <noecksit> Saizan_: that looks simple
09:54:45 <pozic> bauchus: /j #gentoo-haskell
10:00:48 <noecksit> heh, that works, too bad i couldnt figure it out on my own though
10:14:39 <dancor> :pl \ l -> concatMap (uncurry zip . first repeat) $ zip l (tail $ tails l)
10:14:49 <dancor> @bot
10:14:50 <lambdabot> :)
10:14:53 <dancor> @pl \ l -> concatMap (uncurry zip . first repeat) $ zip l (tail $ tails l)
10:14:53 <lambdabot> (uncurry zip . first repeat =<<) . ap zip (tail . tails)
10:18:41 <dancor> tail . tails  is more useful that i would have thought
10:18:56 <dancor> better than head . heads :)
10:19:24 <slava> how would you write this in haskell -- given a sequence of integers, group it into subsequences of consecutive integers
10:19:41 <slava> [1,2,3,5,6,1,3] => [[1,2,3],[5,6],[1],[3]]
10:19:47 <slava> i mean i know how to write the general lgorithm in a million ways
10:19:55 <slava> but there must be a cute point-free oneliner :)
10:20:54 <dancor> seems like you need to pre-and-post manip on a group, or thread state thru
10:22:20 <dancor> or something cool with zip l (tail l)
10:24:05 <dancor> stateful groupBy variant might be the most general
10:24:06 <SamB> slava: I don't think we have the function for it yet...
10:25:35 <SamB> > groupBy (\x y -> x+1 == y) [1,2,3,5,6,1,3]
10:25:36 <lambdabot>  [[1,2],[3],[5,6],[1],[3]]
10:25:41 <SamB> nope.
10:26:08 <SamB> (I was just checking if the *implementation* of groupBy also did this...)
10:26:34 <SamB> @type groupBy
10:26:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
10:26:45 <SamB> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
10:26:45 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
10:27:02 <SamB> so what would the name of the function be?
10:27:24 <SamB> I'm sure I've wanted it before...
10:27:42 <dancor> well is it :: (a -> a -> s -> (s, Bool)) -> [a] -> [[a]]
10:27:54 <dancor> oh and initial state
10:28:01 <Saizan_> why state?
10:28:18 <dancor> well i guess it depends how general you're going for
10:28:19 <SamB> dancor: no, the one I was thinking of would be a valid implementation of groupBy
10:28:24 <slava> i think you can do it without state
10:28:24 <dancor> ah
10:28:28 <slava> first compite the offsets where you need to split
10:28:31 <slava> then split the lista long those
10:28:32 <dancor> groupByContig
10:28:42 <slava> :t groupByContig
10:28:44 <lambdabot> Not in scope: `groupByContig'
10:28:45 <slava> no such thing? :)
10:28:51 <Saizan_> no
10:29:09 <SamB> slava: it isn't there yet
10:29:20 <SamB> why do you think I'm asking what it ought to be named?
10:34:21 <Saizan_> > (\xs -> map (map snd) . groupBy (\_ (x,y) -> x + 1 == y) $ zip (undefined:xs) xs ) [1,2,3,5,6,1,3]
10:34:22 <lambdabot>  [[1,2,3],[5,6],[1],[3]]
10:34:29 <Saizan_> not sure if it works in general
10:35:14 <dancor> looks general to me
10:37:17 <Saizan_> ?pl \xs -> map (map snd) . groupBy (\_ (x,y) -> x + 1 == y) $ zip (undefined:xs) xs
10:37:17 <lambdabot> map (map snd) . groupBy (const (uncurry ((==) . (1 +)))) . (zip =<< (undefined :))
10:37:37 <xerox> "undefined :)"
10:38:07 <Baughn> For a moment I thought lb had gone rampant
10:38:18 <dancor> strong lb
11:08:24 <roconnor> > groupBy (\x y -> (succ x) = y) [1,2,3,5,6,1,3]
11:08:24 <lambdabot>  Parse error at "=" (column 27)
11:08:30 <roconnor> > groupBy (\x y -> (succ x) == y) [1,2,3,5,6,1,3]
11:08:31 <lambdabot>  [[1,2],[3],[5,6],[1],[3]]
11:08:43 <roconnor> oh right
11:08:53 <roconnor> too bad
11:09:07 * roconnor sees SamB's attempt now
11:09:19 <Cale> That groupBy behaviour is actually quite handy in certain cases though.
11:10:21 <jgrimes> for some reason HRSS isn't using any of the data it reads in (I am pretty sure it is reading in the .rss from strace output)
11:11:07 <Cale> My HRSS?
11:11:17 <jgrimes> Cale: yes
11:11:34 <Cale> odd.
11:11:43 <Cale> It worked the last time I touched it.
11:12:35 <Cale> What RSS feed are you using it on?
11:12:38 <roconnor> > groupBy (<) [1,2,3,5,6,1,3]
11:12:39 <lambdabot>  [[1,2,3,5,6],[1,3]]
11:12:44 <roconnor> monotone!
11:13:04 <Cale> roconnor: yeah, it's quite handy for grouping documents into a tree based on section levels.
11:13:06 <jgrimes> Cale: the ones you've listed on the page, and I've tried a few others
11:13:21 <roconnor> Cale: ah
11:13:21 <Cale> Interesting. I'll give it a shot.
11:14:13 <roconnor> Cale: I don't think groupBy's behaviour is for non-equivalence relations is portable.
11:14:23 <Cale> roconnor: it is.
11:14:28 <roconnor> Despite the fact that a strict reading of H'98 says it is.
11:14:41 <Cale> I think it ought to be anyway.
11:15:09 <Cale> It's also sort of reliable based on the fact that it's rather awkward to write groupBy in any other way.
11:15:24 <Cale> jgrimes: Uh, I just tried it and it worked for me.
11:15:29 <roconnor> Cale: and what is your opinion about sort?  Should the every sort implemenation make exactly the same comparisons? (although this is a slight different issue)
11:15:33 <eu-prleu-peupeu> hi
11:16:16 <jgrimes> Cale: interesting. I wonder what my system could be doing that is messing this up
11:16:41 <Cale> roconnor: That's a good question. It matters more for sortBy than for sort.
11:17:12 <roconnor> @src sortBy
11:17:12 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:17:19 <Cale> roconnor: But yeah, it makes sense for sort to be something more sensible than insertion sort.
11:17:37 <roconnor> But that violates H'98!!
11:17:40 <roconnor> :P
11:17:43 <Cale> Indeed it does.
11:17:56 <Cale> But maybe that's a problem with H'98 :)
11:18:17 <roconnor> If there is a problem with H'98, that is everyone's problem
11:18:27 <Cale> There are lots of problems with H'98.
11:18:49 <Cale> Many of which I don't even expect to be fixed in the next release of the standard.
11:18:56 <roconnor> Perhaps Haskell' should say that these definitions of *By only specify the behaviour for equivalence relations.
11:19:13 <roconnor> Cale: we still want you to write your own standard.
11:19:22 <Cale> I think that groupBy's behaviour for non-equivalence-relations should be preserved.
11:20:00 <Cale> But I'm more ambivalent about sort/sortBy
11:20:34 <roconnor> that seems hard to justify
11:21:41 <Cale> Well, it's a useful thing to be able to say 'break this list into chunks by repeatedly picking an element and then taking elements while the comparison succeeds'
11:21:47 <SamB> roconnor: what part did you read that told you that groupBy's behaviour is portable?
11:21:49 <Cale> (with that first element)
11:22:27 <Cale> SamB: The report gives an implementation of groupBy which is supposed to specify the semantics.
11:22:34 <SamB> Cale: it does?
11:22:38 <Cale> yep
11:22:44 <SamB> that's dumb
11:22:54 <Cale> http://haskell.org/onlinereport/list.html
11:22:55 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
11:22:56 <atp> groupBy is sort of wacky
11:22:57 <roconnor> Cale: or with the last element.  That would be just as useful a function
11:22:58 <Cale> groupBy                 :: (a -> a -> Bool) -> [a] -> [[a]]
11:22:58 <Cale> groupBy eq []           =  []
11:22:58 <Cale> groupBy eq (x:xs)       =  (x:ys) : groupBy eq zs
11:22:58 <Cale>                            where (ys,zs) = span (eq x) xs
11:23:18 <Cale> roconnor: It would also be a useful function, but not quite as useful, imo :)
11:23:38 <Cale> Note that it's also harder to write that function.
11:23:48 <atp> how about this?
11:23:50 <atp> equivClasses :: (a -> a -> Bool) -> [a] -> [[a]]
11:23:50 <atp> equivClasses m xs = go [] m xs
11:23:50 <atp>     where
11:23:50 <atp>         go cl _ [] = cl
11:23:50 <atp>         go cl m (x:xs) = go (place cl m x) m xs
11:23:51 <atp>         place [] _ x = [[x]]
11:23:54 <atp>         place (c:cl) m x = if m x (head c) then (x : c) : cl else c : place cl m x
11:24:12 <atp> is there something like that in the standard libs anywhere
11:24:14 <atp> i use it a lot
11:24:31 <SamB> Cale: I thought that section was Informative
11:24:33 <SamB> not normative
11:24:44 <SamB> 17.3  List transformations
11:24:47 <roconnor> Cale: actually both these functions would be more useful than groupBy for equivalence relations.
11:24:47 <SamB> 17.6  The "By" operations
11:24:58 <SamB> don't *these* specify the behaviour of groupBy?
11:25:04 <roconnor> Cale: I've aways found group and groupBy to be a little dumb.
11:25:12 <roconnor> the never quite do what you want
11:25:26 <atp> group can be useful
11:25:28 <roconnor> map (head &&& id) . group
11:25:34 <roconnor> that is what we want.
11:25:48 <Cale> hm?
11:25:56 <atp> that's a trivial extension
11:26:01 <roconnor> or that is how I always use group :)
11:26:22 <atp> the main thing about group that annoys me is that its behaviour depends on how the list is sorted
11:26:32 <atp> but i guess that's what it's supposed to do
11:26:39 <Cale> But that's a useful thing!
11:26:52 <atp> right, but often i have a set that i want to split up into equivalence classes
11:27:06 <atp> and that seems like a useful enough thing that i shouldn't need to write my own function to do that every time i need it
11:27:07 <Cale> group . sort ?
11:27:11 <SamB> both the implementation given in the report and the one that checks contiguous elements would be usefull...
11:27:21 <Cale> (of course, that relies on an ordering)
11:27:23 <atp> Cale: that works if your equality is ==
11:27:30 <atp> Cale: but what if it's == (mod n) ?
11:27:32 <roconnor> atp: someone is working on a multi-set class
11:27:35 <roconnor> IIRC
11:27:38 <roconnor> er
11:27:43 <roconnor> a mutli-set module
11:27:43 <atp> Cale: the function i pasted above works fine for that stuff
11:27:53 <SamB> atp: sortby (compare `on` (`mod` n))
11:27:56 <roconnor> or was it multi-map?
11:28:12 <Cale> atp: You could also take the implementation of groupBy and replace span with partition
11:28:25 <atp> SamB: hm, interesting.  but that still requires Ord when all you may want is Eq.
11:28:38 <atp> SamB: but i did not know you could do that.
11:28:49 <atp> > sortBy (compare `on` (`mod` 3)) [1 .. 5]
11:28:51 <lambdabot>  [3,1,4,2,5]
11:28:58 <SamB> Cale: do you follow my argument that groupBy could just as well do what slava needed and still be H98?
11:29:09 <mib_t9n39hll> hello?
11:29:16 <Lemmih> hi?
11:29:19 <atp> mib_t9n39hll: just ask your question :)
11:29:25 <mib_t9n39hll> is this html forum?
11:29:27 <atp> no
11:29:31 <Cale> SamB: Somewhat, but I'm not sure that I totally agree. Anyway, all the implementations conform to the behaviour that GHC's does.
11:29:47 <mib_t9n39hll> ok thanks
11:29:50 <Cale> mib_t9n39hll: This channel is about the functional programming language called Haskell.
11:30:09 <mib_t9n39hll> i typed html codin in and this came up
11:30:17 <mib_t9n39hll> idk
11:30:55 <SamB> Cale: so it comes down to the Haskell spec not being specific about which stuff is Normative and which is Informative
11:31:07 <SamB> doesn't it?
11:31:11 <Cale> I suppose.
11:31:41 <Cale> I take it all as potentially normative, but I don't really agree with following it to the letter.
11:31:42 <SamB> but if this were a W3C spec, the code at the bottom would be informative...
11:31:44 <SamB> it always is
11:32:34 <atp> ?index on
11:32:35 <lambdabot> bzzt
11:32:44 <SamB> and yes, blindly following H98 to the letter would be idiotic
11:32:47 <Cale> Haskell 98 is sort of obsolete anyway, in that most programs don't work with plain Haskell 98 these days anyway.
11:32:53 <atp> @type on
11:32:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:33:00 <Cale> equivBy                 :: (a -> a -> Bool) -> [a] -> [[a]]
11:33:00 <Cale> equivBy eq []           =  []
11:33:00 <Cale> equivBy eq (x:xs)       =  (x:ys) : equivBy eq zs
11:33:00 <Cale>                            where (ys,zs) = partition (eq x) xs
11:33:25 <vixey> @src on
11:33:25 <lambdabot> (*) `on` f = \x y -> f x * f y
11:33:36 <SamB> hmm.
11:33:39 <SamB> I has an idea.
11:33:40 <Cale> atp: I'm not quite sure, because the function you pasted above is a little hard for me to read, but I think that does the same thing.
11:33:51 <SamB> We should take the library out of the language spec.
11:33:59 <atp> Cale: yeah, it uses direct recursion, yours is easier to read i think, let me try it out
11:34:26 <Cale> atp: I arrived at it by taking the definition of groupBy and replacing span with partition.
11:34:36 <SamB> if Agda can do it in it's implementation, surely so can Haskell 98!
11:34:47 <Cale> Maybe we should have an even more general function...
11:35:25 <SamB> Cale: what do you think?
11:35:43 <vixey> SamB: I think that's a good idea, but I like Scheme..
11:36:13 <SamB> vixey: well, I only want to do it because having the library in the language spec makes the language implementations wire too much stuff in
11:36:14 <Cale> SamB: Yeah. I think I could get behind that idea.
11:36:27 <SamB> thereby making it harder to change the libraries
11:36:38 <SamB> thereby making it harder to change the library spec
11:36:54 <atp> Cale: it seems to be the same
11:37:08 <Cale> Of course, the real reason that it's hard to change the libraries is that so much code relies on them.
11:37:22 <SamB> Cale: that is also true
11:37:29 <Cale> chunk :: ((a -> Bool) -> [a] -> ([a],[a])) -> (a -> a -> Bool) -> [a] -> [[a]]
11:37:49 <SamB> but if the specs were decoupled, the implementations would have to unwire the wired-in things that make it hard to play with alternatives
11:37:53 <Cale> groupBy = chunk span
11:37:59 <Cale> equivBy = chunk partition
11:38:06 <atp> yeah, that's not a bad idea
11:38:37 <atp> would that make slava's groupBy easier to implement I wonder?
11:38:39 <Cale> SamB: There are a few things which are worrisome, like the various bits of syntax sugar.
11:38:39 <SamB> Cale: don't you think?
11:38:49 <Cale> SamB: But otherwise, yes, that would be good.
11:38:54 <SamB> Cale: that is exactly why I want it done
11:39:01 <Cale> See, we can't really fix the definition of Monad.
11:39:11 <Cale> Because do-notation relies on fail.
11:39:21 <SamB> we can do it
11:39:26 <SamB> never say can't
11:39:29 <vixey> what is wrong with just importing your own prelude?
11:39:36 <Cale> Well, yes, I mean without fixing GHC itself.
11:39:53 <SamB> that's *exactly* why I want the specs decoupled
11:39:56 <atp> fail is evil anyway
11:40:06 <Cale> Hey, want to make a mini-fork of GHC to fix this stuff?
11:40:18 <SamB> hmm. nice idea.
11:40:19 <atp> add back in monad comprehensions while you're at it :)
11:40:27 <SamB> so when is the next release?
11:40:35 <Cale> 6.10?
11:40:36 <name> any good guide for me as a python coder why and how I should use haskell?
11:40:45 <atp> why is up to you
11:40:46 <SamB> or should we fork the last release?
11:41:02 <atp> as for how, there are lots of tutorials on haskell.org
11:41:09 <atp> or linked to from there
11:41:10 <SamB> name: because it's fun
11:41:47 <atp> i sort of feel like it's weird to come on to a forum and ask other people to convince you why you should be a part of their community
11:41:59 <atp> maybe i'm off base on that
11:42:04 <Cale> name: One good reason to learn it is that it will give you a somewhat broader outlook on the question of how to write programs.
11:42:21 <name> atp: no. i just wanted to know what the advantages are..
11:42:46 <Cale> name: It has a really good type system that doesn't get in your way, while helping to prevent bugs.
11:42:58 <SamB> name: it isn't as brain-exploding as call/cc, and is much more fun
11:43:05 <atp> call/cc is pretty fun :)
11:43:13 <atp> plus you can do call/cc in haskell
11:43:21 <SamB> not really
11:43:30 <name> and from the sample code it seems to me it is more for mathematical problems compared to other languages, am i mistaken?
11:43:36 <Cale> Actually, rather than list a bunch of things I like about Haskell, let me point you at a post I made...
11:43:37 * vixey still wished for deriving Cata/Folds whatever
11:43:48 <SamB> you can do something much less brain-explodey in Haskell though
11:44:00 <SamB> name: not really
11:44:01 <atp> name: that's largely a result of there being a lot of academics and active researchers in the haskell community
11:44:10 <atp> name: it has little to do with the language per se
11:44:17 <SamB> name: it's we like to convert our problems into mathematics
11:44:31 <SamB> er. s/it's/it's that/
11:44:46 <dons> name, its just a technique. look at hackage.haskell.org, libraries for everything.
11:44:47 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:45:07 <name> well afk for dinner, will be back bit later :)
11:45:11 <ddarius> name: xmonad is just a big exercise in abstract algebra
11:45:13 <Cale> name: http://www.reddit.com/info/2bxc1/comments/c2bzw7
11:45:14 <lambdabot> Title: reddit.com: Ask Reddit: What is Haskell good for?
11:45:14 <dons> the technique is to think hard about what abstractions from mathematics apply to the code, making the code, simpler, cleaner, more robust
11:45:24 <dons> ddarius: :)
11:45:33 <Cale> name: That outlines some of the reasons that I like Haskell.
11:45:38 <SamB> dons: you have an escaped comma in there
11:45:43 <atp> most things end up being a big excersize in abstract algebra, i think
11:45:46 <name> thank you
11:46:02 <atp> wow that was a good speel
11:46:10 <atp> exercise even
11:46:26 <SamB> atp: if you think about them correctly, yeah...
11:47:05 * SamB bets nobody else in his signals class would dream of applying abstract algebra to the subject ;-)
11:47:25 <atp> i love algebra
11:47:35 <SamB> least of all the teacher
11:47:41 <vixey> I kind of think typeclasses could be more sophisticated
11:47:46 <SamB> he seems unclear on the distinction between formal and informal
11:47:57 <atp> are you in grad school?
11:47:59 <SamB> vixey: how so?
11:48:05 <vixey> I'm not sure horn clauses is the right way to dispatch
11:48:06 <SamB> unfortunately no
11:48:07 <dons> sclv: nice work. http://www.indeed.com/salary?q1=haskell+programmer&l1=&tm=1
11:48:09 <lambdabot> Title: haskell programmer Salaries - Free Salary Search
11:48:13 <atp> SamB: major?
11:48:16 <SamB> EE
11:48:19 <atp> ick
11:48:24 <atp> join the dark side
11:48:24 <SamB> CS is a joke though
11:48:26 <atp> switch to math
11:48:30 <atp> CS is a joke
11:48:32 <atp> math
11:48:36 <atp> you know you want it :)
11:48:48 <SamB> I dunno
11:48:59 <SamB> I think the math department here kinda sucks
11:49:06 <atp> what school?
11:49:28 <SamB> er. by here, I mean Widener University, though I'm not there today.
11:49:48 <atp> ah.  don't know enough about them to comment.
11:50:55 <dons> "Average haskell programmer salaries for job postings nationwide are 263% higher than average salaries for all job postings nationwide"
11:50:58 <SamB> anyway, the teacher of my signals class doesn't seem to realize that finding a counterexample is a quite formal way to prove that something isn't true ;-)
11:50:58 <dons> this is why we like haskell :)
11:51:16 <atp> SamB: ouch.
11:51:28 <dons> anyone use console rss readers?
11:51:41 <SamB> apparantly in his mind "formal" means "the hard way"
11:51:46 <atp> dons: nice. although, i have to say, i'd like haskell just fine even if that weren't the case ;p
11:51:58 <dons> its the cherry on top, atp
11:52:17 <atp> SamB: I was EECS for one year at uni... switched to math... much more pleasurable
11:52:20 <TomMD> Did that survey say anything about Erlang?  I guess that would just be the average Ericsson Enginner pay.
11:52:22 <chessguy> what the heck? the average haskell salary is 200k?
11:52:34 <dons> TomMD: yeah, 99k.
11:52:36 <TomMD> Blame Galois
11:52:51 <dons> Blame credit suisse, barclay's capital and deutsche bank
11:53:01 <TomMD> Good point.
11:53:12 <atp> i work in finance, i wish we used haskell here :(
11:53:17 <TomMD> I was told those have a 25%/year turn over.
11:53:28 <atp> it's mostly SAS and VB, unfortunately, but then i don't work as a programmer so i don't really care one way or another
11:53:28 <TomMD> atp: F#?
11:53:32 <TomMD> oh
11:53:39 <SamB> well, maybe people like to take a break after earning all that dough
11:54:06 <Heffalump> TomMD: what do?
11:54:09 <atp> i actually solved a major problem with a network server written in haskell that took me about 20 minutes to write and IT had a shitfit
11:54:18 <Codex_> big salary doesnt help if you have no time to spend it on anything :)
11:54:25 <dons> atp, awesome.
11:54:30 <TomMD> Finance sector, specifically groups like CS.
11:54:34 <atp> not a good shitfit, unfortunately
11:54:43 <dons> atp, oh, its not good when you write your own?
11:54:44 <Heffalump> TomMD: who told you that?
11:54:45 <atp> "why do you have a compiler?! you're not a developer!"
11:54:56 <atp> "blah blah blah SAS70 blah blah blah audit"
11:54:56 <dons> oops
11:55:00 <TomMD> heffalump: Byron Cook
11:55:02 <atp> yeah
11:55:07 <dons> atp++ fight the good fight!
11:55:14 <Heffalump> he said that CS has a 25% turnover? What of?
11:55:15 <dons> this is how haskell starts in the backroom
11:55:24 <Korollary> don't fight lawyers
11:55:27 <dons> atp, you should blog about this :) its a nice story.
11:55:47 <TomMD> Heffalump: He didn't say any exact company, just said that in the realm of automated stock trading the average employee lasts 4 years.
11:55:54 <Heffalump> oh, right
11:56:03 <atp> dons: i had to reimplement it in excel :( it took me 3 weeks to get a network server working by plugging into the win32 network dlls... and the thing crashes constantly
11:56:11 <atp> not surprisingly, since excel is not designed for that
11:56:18 <Heffalump> automated as in done by computers with human oversight?
11:56:35 <olsner> "had to"? :(
11:56:42 <atp> they took my haskell away!
11:56:59 <TomMD> Heffalump: Yes, that is what I thought he was saying.  Systems where a bug in your code will cost a million a minute until you shut it off ;-)
11:57:08 <Heffalump> TomMD: I don't think Haskell is used in any such systems
11:57:15 <atp> i told them "we need this to work, do you understand, we have millions of dollars (literally) running on this"
11:57:22 <Heffalump> if it is, I haven't heard of any, anyway
11:57:25 <atp> IT: "you're not a developer, no compilers, rules is rules"
11:57:27 <TomMD> I didn't say that was the case, did I?  I didn't mean too at any rate.
11:57:29 <atp> sigh
11:57:35 <vixey> ~ money for nothing, theorems for free, I want my GHC ~
11:57:50 <atp> theorems for free?
11:57:51 <TomMD> I think these customers are why MSFT pushed F#, though.
11:57:51 <atp> hehe
11:57:59 <vixey> @free map
11:57:59 <SamB> atp: how can they take your haskell away?
11:58:01 <lambdabot> Expected variable or '.'
11:58:01 <olsner> maybe you need to get hired as a "developer" then, and do the same job you're doing now, only being able to do it properly :P
11:58:15 * vixey frowns
11:58:21 <xerox> You could hire GHC to give you consulences, you give it specifications and it returns programs.
11:58:22 <Heffalump> ah. I assumed you were talking about Haskell programmers at banks. Mistakenly, I guess.
11:58:23 <atp> olsner: yeah, and get paid a hell of a lot less... i'm a quant analyst
11:58:31 <olsner> oh, okay
11:58:37 <atp> olsner: and the developer types are using VB anyway, just not in excel...
11:58:38 <xerox> ...and you put some cents in a box every time.
11:58:47 <atp> i hate VB
11:59:00 <atp> what i hate most about it is how it encourages everyone to copy paste like mad
11:59:05 <SamB> atp: ask them if they use a compiler
11:59:17 <TomMD> "Whats a compiler"
11:59:25 <atp> they're not stupid, just paranoid
11:59:40 <SamB> aren't there some compilers that everyone uses?
11:59:42 <atp> one of the IT people confided in a coworker that i was a "high threat level" as far as they were concerned
11:59:53 <Heffalump> atp: who do you work for? (if that's not sensitive information given this conversation :-)
12:00:46 <atp> Heffalump: it is sort of sensitive... i work for a global growth manager, we do long-only products and some levered stuff (mainly 130-30s) that i work on, we have about 20 bil under management
12:01:02 <atp> you may be able to deduce it from that, but that's all i'm going to say :p
12:01:08 <olsner> this is sounding more and more like something for the daily wtf
12:01:16 <Korollary> it may not be
12:01:24 <atp> no, i don't think so
12:01:35 <atp> i'm not a developer, not a programmer, i'm just extremely lazy and hate doing things manually
12:01:36 <SamB> olsner: not enough anonymity I think
12:01:46 * Heffalump doesn't know enough about the industry to deduce it :-)
12:01:49 <SamB> atp: eh?
12:01:55 <SamB> I thought that was how programmer was defined
12:01:57 <atp> i mean employed as
12:02:02 <Heffalump> how can you be a quant without programming, OOI? Don't you need to deliver your models somehow?
12:02:02 <atp> it's not my job description, you know?
12:02:16 <atp> Heffalump: yeah.  we do it in SAS, primarily.
12:02:24 <SamB> what is your job description?
12:02:36 <atp> i'm a portfolio risk specialist
12:02:42 <SamB> that's a title
12:02:43 <atp> i build risk models
12:02:50 <SamB> that's programming
12:02:58 <atp> sort of
12:03:03 <atp> more math and stats than anything
12:03:13 <atp> it's actually quite dull :(
12:03:17 <atp> but it pays well
12:03:18 <SamB> these risk models need to be run, yes?
12:03:23 <atp> yes
12:03:38 <SamB> how do you do that with no compiler?
12:03:44 <atp> we use SAS for that, which we are allowed by the BOFHs in IT to use...
12:04:01 <SamB> why don't you tell them to take it away if you aren't allowed any compilers?
12:04:21 <atp> SamB: unfortunately, the real world does not work this way :(
12:04:32 <TomMD> Thanks to this conversation I am crossing the financial sector off of my list of potential future careers.
12:04:38 <SamB> oh, btw, if they were BOFHs wouldn't you be dead in an elevator by now?
12:04:42 <atp> haha
12:04:46 <atp> most likely :p
12:04:46 <Heffalump> our group (I work for Credit Suisse's quant group) controls the technology we use as well as developing the models
12:05:15 <atp> Heffalump: how's credit suisse?  i interviewed there a few years back, it didn't pan out
12:05:26 <atp> it seemed fairly... intense.
12:05:29 <atp> good pay but not much life
12:05:51 <SamB> TomMD: maybe you better just make sure to get in your contract that control of the technologies you use is yours
12:06:12 <atp> SamB: the likelihood of that happening in almost any shop is pretty much nil.
12:06:16 <TomMD> SamB: That is actually a driving factor in my job search.
12:06:18 <Heffalump> atp: for what group?
12:06:30 <Heffalump> I like it. I don't work particularly long hours for banking, either.
12:06:48 <SamB> well, *near* you in the organization, at least
12:06:56 <Heffalump> SamB: if you need to get that in your contract, you won't be able to.
12:07:10 <atp> Heffalump: it would have been in the quant group, i suppose, but i'm not sure.  they were interested in me because i speak chinese, i think.
12:07:12 <SamB> well, whatever
12:07:13 <Heffalump> no organisation will change an entire working culture for one low-level hire
12:07:22 <atp> yeah
12:07:36 <SamB> I meant ... get one where that's in the standard contract
12:07:48 <Heffalump> it won't be, even in places where that's the way things work
12:07:56 <SamB> oh.
12:08:03 <TomMD> Just look for a flexible work place.
12:08:08 <cnwdup> :t withJust
12:08:10 <lambdabot> Not in scope: `withJust'
12:08:13 <atp> you're best off deciding what tools you want to use and finding companies that use them
12:08:21 <atp> rather than trying to get them to give you flexibility, because they won't.
12:08:22 <cnwdup> :t whenJust
12:08:25 <lambdabot> Not in scope: `whenJust'
12:08:27 <SamB> well how do you make sure to get a job at a place like that then?
12:08:43 <Korollary> you're best off finding the best people to work with and use whatever tools are necessary.
12:08:51 <SamB> hmm.
12:09:02 <atp> that's my opinion too, but i'm pretty tool-agnostic... at the end of the day i mostly care about alpha
12:09:02 <Heffalump> do some decent research about the place before committing to it
12:09:10 <SamB> hmm.
12:09:27 <TomMD> SamB: Graduating soon?
12:09:29 <SamB> I guess a good start is to look for jobs that are looking for people like you?
12:09:36 <SamB> TomMD: not terribly
12:09:41 <Heffalump> SamB: yep
12:09:44 <TomMD> Within a year?
12:09:45 <Heffalump> and word-of-mouth
12:09:47 <SamB> just started as a junior...
12:10:13 <atp> SamB: don't get the wrong idea, i actually love where i work
12:10:20 <atp> SamB: no matter where you work there will always be complaints
12:10:30 <atp> SamB: it's like school in that way actually
12:11:37 <SamB> atp: I can't imagine loving to work in a place where they take away your compiler just because you write one network server that saves millions...
12:11:58 <Korollary> it's not 'your' compiler btw
12:12:15 <TomMD> Try to imaging a place that won't give you the compiler in the first place because it might be evil.
12:12:24 <SamB> Korollary: it's under the BSD license, of course it is
12:12:28 <atp> SamB: sure, but look.  I know I'm competent.  But they don't know that.  I wasn't hired to be a developer.  I didn't go through that tech-style interview.  What if I wrote something buggy that was a security hazard?
12:12:34 <atp> SamB: they don't grok haskell, they can't audit it
12:12:51 <SamB> atp: and ... how exactly does writing it in Excel help with this problem?
12:13:00 <Korollary> SamB: Anything you use belongs to your employer.
12:13:03 <atp> SamB: it doesn't.  i needed it to work so i circumvented the problem.
12:13:04 <SamB> they CAN audit that?
12:13:09 <SamB> Korollary: not GHC
12:13:17 <SamB> Korollary: well, not any more than to me
12:13:19 <atp> no, Korollary is right.
12:13:39 <atp> anything you do on their systems belongs to them.  that also means that they're the ones that take responsibility if shit goes haywire.
12:13:51 <SamB> in fact, I bet I have more patches in GHC than most employers do
12:14:10 <atp> SamB: you're not understanding what he means
12:14:17 <atp> SamB: he means that anything you run on their systems belongs to them
12:14:50 <SamB> I don't understand this concept of software ownership
12:15:05 <TomMD> SamB: How about the concept of security policy?
12:15:06 <Korollary> Nobody but you thinks about ownership
12:15:14 <TomMD> They don't want it running, so they take it away.
12:15:19 <SamB> well, "your" is an ownership word
12:15:25 <SamB> as is "my"
12:15:27 <atp> TomMD groks it, that's what i mean.
12:15:44 <atp> SamB: the working world is very feudal, unfortunately :p
12:15:45 <Korollary> It's not about license. You called it 'my' compiler. It's not 'yours'. If it's a choice, it's a 'company' choice.
12:15:48 <SamB> that's like ... taking away your calculator because it's the wrong brand
12:16:03 <atp> which could happen.  take the CFA some time.
12:16:17 <SamB> the what?
12:16:22 <atp> CFA... it's an exam
12:16:26 <SamB> oh, on exams sure
12:16:38 <atp> why is it ok on exams?
12:16:50 <atp> i mean, why do you see these as separate things?
12:16:51 <SamB> atp: they warn you about it before hand
12:16:59 <atp> well, they warned me.  technically.
12:17:03 <atp> no non-approved software.
12:17:06 <SamB> oh.
12:17:08 <atp> yeah.
12:17:09 <atp> :)
12:17:13 <atp> i'm just a rebel that way.
12:17:17 <SamB> and you still took the job?
12:17:37 <atp> oh, yeah.  it's in the industry i want to be in, and we kick ass.
12:17:41 <TomMD> SamB: Most (perhaps 99%+) places say "no unapproved software".
12:17:43 <Korollary> Similar conditions apply to varying degrees everywhere
12:18:02 <SamB> TomMD: that's an intolerable restriction for a programmer to be subjected to.
12:18:02 <atp> our returns humiliated goldman last year :)
12:18:19 <atp> SamB: even for professional programmers, that's how it works unfortunately
12:18:27 <atp> SamB: in 90% of cases.
12:18:27 <TomMD> Unapproved software is how confidential / personal data leaks in the mind of the security admin.
12:18:36 <SamB> because, you know, the program I wrote 5 minutes ago is unlikely to be approved software.
12:18:42 <atp> that's different.
12:18:47 <Lycurgus> except for the few free
12:18:49 <SamB> not really
12:18:51 <Lycurgus> the very few
12:18:52 <TomMD> SamB: Anything in house is naturally "approved"
12:19:05 <TomMD> SamB: But you can't download and install that binary... nooooo... it could be malware.
12:19:06 <atp> there's a "paper" trail for that sort of thing
12:19:17 <SamB> so if I write my own Haskell compiler in Excel, it's okay?
12:19:18 <atp> they know what you wrote and how it was written
12:19:27 <atp> SamB: i actually wrote a basic scheme interpreter in excel
12:19:38 <atp> SamB: not having first-class functions bugs the shit out of me
12:19:49 <SamB> that's not going to actually teach anyone Haskell
12:20:10 <atp> what's not going to?
12:20:14 <atp> how is that relevant?
12:20:19 <atp> they're not there to teach you haskell
12:20:24 <Heffalump> atp: we have first-class functions in Excel :-)
12:20:30 <SamB> no, I meant they still won't know Haskell
12:20:39 <atp> Heffalump: we do?
12:20:46 <Heffalump> we = Credit Suisse
12:20:48 <SamB> so how does it make them suddenly okay with you writing Haskell if you implement it in Excel first?
12:20:49 <atp> Heffalump: are you talking about an AddressOf hack?
12:21:03 <atp> Heffalump: yeah, you can do it with an external dll
12:21:18 <atp> Heffalump: it bugs me enough that i may just write one in bloody machine language
12:21:19 <Heffalump> right, and we've basically implemented Excel's semantics in our external DLL.
12:21:24 <atp> Heffalump: don't need a compiler for that :)
12:21:44 <atp> anyway not wanting a compiler i can understand, but they took away emacs too :(
12:21:51 <mmorrow> Heffalump: how is that implemented (to the extent that you can/want to discuss it)??
12:21:52 <cnwdup> :t fmap
12:21:53 <SamB> atp: oh... kay...
12:21:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:22:06 <atp> luckily they didn't find my stashed copy of vim
12:22:07 <SamB> atp: and ... what did they give you in return?
12:22:28 <atp> SamB: experience, a heck of a lot of money, and the opportunity to learn
12:22:49 <Korollary> windows shops are not too keen on emacs anyway
12:23:32 <atp> SamB: i like CS/math enough that i do it enough on my own.  i don't need to do it for work.  in fact, having worked as a developer in the past, i find it frustrating... the corners marketing typically makes you cut... it offends my sense of rightness :)
12:23:49 <atp> i don't have that same issues with finance
12:24:10 <mmorrow> Heffalump: (although it may be obvious to windows targetting programmers) in particular how are you adding functions to excel?
12:24:13 <Heffalump> mmorrow: well, we have ways of defining functions in Excel, ways of getting those functions out of Excel to our external engine for simulating Excel, and an external engine that behaves like Excel
12:24:15 <SamB> I guess because they know exactly what's at stake in finance?
12:24:28 <atp> Heffalump: 2003 or 2007?
12:24:31 <Heffalump> mmorrow: there's a standard interface to do that
12:24:34 <Heffalump> atp: 2000/2003.
12:24:37 <atp> us too.
12:24:44 <SamB> I mean, it's fairly obvious that MONEY is at stake in finance ;-)
12:24:53 <atp> yes
12:25:06 <atp> nothing like being told "fuck this up, and the firm could lose 20 million dollars"
12:25:23 <atp> it puts things in perspective
12:25:49 <Korollary> although that stress can mount up quickly
12:25:51 <TomMD> Just shy of the 'people will die' catagory, huh?   Good place to be.
12:26:02 <atp> yeah :)
12:26:05 <SamB> well, at least they won't be asking you to do lousy work
12:26:12 <SamB> which kind of stress is worse?
12:26:16 <SamB> which kind of stress is worse?
12:26:20 <SamB> hrmm.
12:26:20 <atp> ok guys, i gotta go
12:26:24 <TomMD> later
12:26:36 * SamB wonders why he didn't see that the first time???
12:27:38 <mmorrow> Heffalump: ah. so for instance, could one pass in a standard excel func as a param into one of your higher order funcs? if so, then do you reimplement all the standard excell funcs, or somehow use excels implementation of that func to calc your answer, OR do you "compile" that higher order function call to a some valid excell expression and insert *that* back in the cell?
12:27:53 <mmorrow> excel
12:30:37 <TomMD> SamB: Do you have any Haskell packages?
12:30:53 <SamB> TomMD: why do you ask?
12:31:24 <TomMD> I'm typically curious and like to attach IRC nicks to hackage packages in my mind.
12:31:24 <SamB> and what do you mean?
12:31:39 <TomMD> Are you the maintainer of anything on Hackage?
12:31:47 <SamB> well, the only one I'd like to mention is ZMachine
12:32:20 <SamB> gwern posted it to hackage, but I wrote it
12:32:51 <TomMD> I see.
12:33:07 <SamB> haven't touched it lately
12:33:46 <TomMD> Thats cool.  Some of my packages I hacked together on a whim that it might be useful then... no love after that.
12:34:35 <SamB> well, I stopped mostly because I couldn't figure out a tolerable way to get a character matrix widget in GTK
12:35:06 <TomMD> GUIs are a pain - I've only ever done one (well, two that each performed the same function).
12:41:26 <Lycurgus> does MD mean the state or the profession?
12:41:54 <TomMD> LOL, neither.  They are initials.
12:42:15 <Cale> Interestingly, his hostname contains md as well :)
12:42:28 <mmorrow> heh, i figured you were a doctor too
12:42:54 <Lycurgus> good, cause if it was Medical Doctor, Master Dillettante would also be implicit.
12:43:07 <smg> Lycurgus: lol
12:43:29 <bla123> i wonder, why GUIs actually are a pain
12:43:29 <TomMD> People often think Doctor, but no, I haven't a PhD.
12:44:06 <TomMD> bla123: I consider them a pain because they don't add any real capability while taking a fair amount of time and their correctness is largely a matter of opinion.
12:44:53 <Lycurgus> are you talking about GUIs like X, Windows, ST, etc.?
12:45:38 <bla123> TomMD: i know that from my own experience - i'm rather wondering, why it is so difficult to write a good GUI library that is at least fun to use
12:45:38 <mmorrow> i thought you were hanging out on irc in between removing bullets and birthing babies, etc
12:45:47 <mmorrow> well, not really but medicaldoctor
12:45:48 <bla123> Lycurgus: anything graphical that has buttons and the like ;-)
12:46:03 <TomMD> There is nothing worse than: 1) Write cool, business changing program  2) Explain and show to manager 3) Manager doesn't get it 4) You (or even worse, a coworder) write a GUI for program 5) Manager says "wow, way to go, this is great stuff, why don't more people do things like this?"
12:46:07 <noecksit> im trying to do alot of stuff with gtk right now and its not much fun
12:46:18 <Lycurgus> well why not start a rant on operating systems or databases?
12:46:23 <conal> bla123: maybe because people habitually think of GUIs imperatively.
12:46:40 <TomMD> bla123: I didn't have too much difficulty using QT long, long ago.
12:46:52 <mmorrow> Heffalump: have i asked too much? (ie you could tell me but then you'd have to kill me?)
12:46:57 <Lycurgus> or since this is haskell, generalized system packages.
12:47:14 <bla123> looking at hackage and haskell.org there seem to be quite some ideas how you could proram GUIs differently
12:48:00 <TomMD> Mmorrow: No, I hang out on IRC between work and sleep, thats about it ;-).
12:48:00 <bla123> but those packages typically seem to be half-implemented and dead
12:48:00 <noecksit> i think typical users will never touch some software if it wasnt gui
12:48:00 <Heffalump> mmorrow: no, you couldn't pass in a standard excel func, without wrapping it first.
12:48:00 <Heffalump> but we do reimplement all the standard excel funcs
12:48:01 <Cale> bla123: This is true and very unfortunate.
12:48:24 <noecksit> by typical i mean a regular windows user
12:48:39 <bla123> Cale: i wonder if those orphaned projects just weren't good enough or if there is a pearl slumbering somewhere that could be the solution
12:48:45 <mmorrow> Heffalump: i was thinking along the lines of any representation of a func (e.g. possibly a string).
12:49:11 <mmorrow> Heffalump: then you go 'oh, you're talking about "mid"'
12:49:13 <TomMD> The dead "Haskell GUI problem" is partly the annoying issues with getting the correct C library.  WXHaskell has been stuck at an old wx version for a while now (perhaps its fixed, I'm not sure).  If you could just 'cabal install' a GUI library then it would probably get more community interest.
12:49:27 <bla123> noecksit: i think there is nothing wrong about that - not every computer user is a programmer
12:49:45 <Heffalump> mmorrow: ah, in that case yes.
12:49:46 <mmorrow> TomMD: heh
12:50:02 <Cale> TomMD: Well, there was a new release in March...
12:50:36 <vixey> bla123: this is a shame
12:50:55 <mmorrow> Heffalump: interesting... so did you have to reimplement all the excel funcs, or can you get at excel's implems somehow?
12:51:16 <bla123> vixey: er ... the gui problem or that not everyone is a programmer? ;-)
12:52:07 <Heffalump> the former :-(
12:52:12 <TomMD> Cale: According to the hackage package description: "At present, it works with wxWidgets 2.6 (and sadly, not with with wxWidgets 2.8)"
12:52:20 <TomMD> So I don't think it is fixed up yet.
12:53:18 <mmorrow> Heffalump: heh, probably for the best. every so often i browse gnumerics source. it's interesting.
12:54:35 <noecksit> bla123 : well, i dont think u need to be a programmer to use smthing like a shell but some people just refuse to learn about it, probably because theyre not used to it
12:55:21 <noecksit> yet i think its a lot better than using a graphical folder viewer
12:55:22 <ddarius> noecksit: There was an article a while back about someone who taught beginning computer users and why he preferred to begin with the commandline.
12:56:30 <bla123> noecksit: hm, i have the feeling that most people think in terms of exclusive or when UIs are concerned
12:56:44 <bla123> noecksuit: they are either raphical or textual
12:56:54 <bla123> noecksuit: i'd like to have the best of both worlds
12:57:03 <ddarius> I think this is it: http://www.osnews.com/story/6282
12:57:04 <lambdabot> Title: The Command Line - The Best Newbie Interface?
12:57:06 <Cale> bla123: Tried Mathematica 6?
12:57:17 <bla123> Cale: no
12:57:36 <bla123> Cale: is there something special about its ui?
12:57:56 <noecksit> bla123: yeah, for some stuff, you can't get around not using a GUI, like browsing the web, but for others a non-gui i think is better
12:58:03 <Cale> bla123: It has a notebook interface which basically gives you a commandline, but you can use that commandline to construct GUI elements which both react to and influence the state of other things.
12:58:23 <bla123> Cale: sounds interesting
12:58:47 <Cale> User interface elements are first class values.
12:59:19 <bla123> maybe one could have some kind of command-line on every gui-window
12:59:27 <noecksit> ddarius : thanx
12:59:42 <bla123> buttons could have names, that can be called directly, pipes per drag&drop and the like
13:00:40 <bla123> or, to put it as short as Cale: user interface elements as first class values ;-)
13:00:43 <Cale> bla123: They have this nice function called Manipulate as well, which lets you build interfaces for manipulating the free variables in some expression and see the results live.
13:01:15 <Cale> It's just a function built in terms of the lower level functions for constructing GUI elements.
13:01:30 <bla123> Cale: i feel i'm already starting to like mathematica ;-)
13:02:33 <dmwit> "It gave the users the impression that they would actually have to state specifically how to break the computer>'
13:02:40 <Cale> http://cale.yi.org/autoshare/Screenshot-Dynamic.png -- here's a screenshot showing a simple example without Manipulate
13:02:56 <dmwit> Yet in my experience, way more people have done dangerous CLI errors than have done dangerous GUI errors.
13:03:10 <Cale> bla123: Changing that slider will affect the value of the variable a, which will cause the plot to be updated immediately.
13:03:11 <mmorrow> Cale: do you have/are there any (good example) screenshots somewhere?
13:03:24 <bla123> Cale: nice
13:03:48 <bla123> Cale: it reminds me of some video i saw, but i don't remember the name of the library
13:03:54 <mmorrow> ha. just saw the link
13:04:01 <ddarius> dmwit: perception /= reality, further most GUIs don't easily give you access to as much "dangerous" behaviour in my experience.
13:04:09 <bla123> Cale: it was about tangible values
13:04:15 <ddarius> TV
13:04:22 <ddarius> and Eros
13:04:33 <Cale> http://cale.yi.org/autoshare/Screenshot-DynamicPolynomial3D.png
13:04:33 <bla123> Cale: the author built some cheap sample gui where he did functional composition and application in a gui manner
13:04:39 <bla123> ddarius: exactly
13:04:49 <mmorrow> Cale: cool.
13:04:56 <Cale> There's a more complicated example, using the Manipulate function and lots of variables :)
13:04:57 <ddarius> bla123: The author would be conal.
13:05:31 <noecksit> we use Mathematica alot in our university, I think one of the professors there helped out or smthing
13:05:33 <Cale> But you can put other values, not just graphs inside Manipulate as well.
13:06:16 <mmorrow> Show us the most wow thing you can throw off the top off your head.
13:06:19 <noecksit> its too bad its not free
13:06:22 <bla123> this is the video: http://www.youtube.com/watch?v=faJ8N0giqzw ("Tangible Functional Programming", warning lasts an hour)
13:06:23 <lambdabot> Title: YouTube - Tangible Functional Programming
13:08:36 <mmorrow> i've wanted to write some javascript in browser thing which is essentially like the glade designer program, but the controls and what they are constructing is one and the same.
13:08:45 <mmorrow> this makes me think of that somehow
13:09:34 <mmorrow>  i don't know javascript well enough yet and have only toyed with the yhc js stuff, so in time...
13:12:50 <Cale> http://www.wolfram.com/products/mathematica/newin6/content/DynamicInteractivity/ -- here are a bunch of animated (but not interactive) examples
13:12:52 <lambdabot> Title: Dynamic Interactivity, http://tinyurl.com/3xtzj7
13:13:54 <mmorrow> Cale: perfect
13:14:22 <Cale> http://www.wolfram.com/products/mathematica/newin6/content/UnificationOfGraphicsTextAndControls/ shows some nice examples of how graphics and controls are first class :)
13:14:22 <lambdabot> Title: Unification of Graphics, Text & Controls, http://tinyurl.com/38kdqv
13:14:48 <Cale> http://www.wolfram.com/products/mathematica/newin6/content/SymbolicInterfaceConstruction/
13:14:49 <lambdabot> Title: Symbolic Interface Construction, http://tinyurl.com/56xocl
13:15:50 <mmorrow> Cale: holy shit!
13:16:02 <mmorrow> exactly
13:17:31 <mmorrow> well, not *exactly*. exactly if you could construct some minimal control interface that can manipulate itself via itself into any other control interface
13:17:58 <Cale> hm?
13:18:45 <mmorrow> i'm just rambling...i wanna make a js-in-browser app to do something along those lines w/ html forms/modifying the dom tree/js
13:19:20 <Cale> I would really really like a mathematica-like notebook interface for Haskell.
13:19:31 <ddarius> A webpage creator webpage.
13:19:39 <mmorrow> ddarius: yesh!
13:19:44 <mmorrow> Cale: yesh!
13:21:33 <chessguy> @pl \b -> (b, map (\m -> f m b) (l b)))
13:21:34 <lambdabot> (line 1, column 35):
13:21:34 <lambdabot> unexpected ")"
13:21:34 <lambdabot> expecting variable, "(", operator or end of input
13:21:52 <dmwit> Cale: I guess you've seen the notebook interface project thingy?
13:22:01 <chessguy> @pl \b -> (b, map (\m -> f m b) (l b))
13:22:01 <dmwit> I can't remember what it's called...
13:22:01 <lambdabot> ap (,) (ap (map . flip f) l)
13:22:06 <Cale> dmwit: Hm?
13:22:09 <Cale> dmwit: For Haskell?
13:22:16 <dmwit> yeah...
13:22:28 <Cale> No, I haven't
13:22:30 <Cale> Where is that?
13:22:36 <tusho> wow, the topic shortified
13:22:37 <bla123> Cale: those demos are really impressive
13:22:42 <dmwit> Let me see if I can find it.
13:22:52 <tusho> i think the topic should be more exciting than [String]
13:22:59 <tusho> a constant [String] literal no less
13:23:12 <bla123> Cale: seems like they got the integration of GUI and command-line right
13:27:08 <dmwit> I don't even know what to search for any more.
13:27:16 <dmwit> ?where state
13:27:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
13:27:48 <opqdonut> hmm, notebook interface?
13:36:27 <ddarius> dmwit: You're not thinking of Vital are you?
13:36:43 <dmwit> I *am* thinking of vital!
13:36:46 <dmwit> ddarius++
13:37:14 <dmwit> Cale: I was thinking of Vital: http://www.cs.kent.ac.uk/projects/vital/
13:37:15 <lambdabot> Title: Vital homepage
13:37:30 <Cale> Oh, yes, I have seen Vital.
13:39:34 <mmorrow> ideas in Fudgets are interesting: http://www.md.chalmers.se/Cs/Research/Functional/Fudgets/
13:39:35 <lambdabot> Title: Fudgets Home Page
13:40:58 <gwern> @seen Cale
13:40:58 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 3m 27s ago.
13:41:09 <gwern> oops. er.
13:41:17 <gwern> Cale: you're the lambdabot maintainer now, right?
13:42:33 <Cale> gwern: yeah
13:42:52 <Cale> gwern: in the sense that I keep it running and apply patches when I get them
13:43:14 <gwern> Cale: I was thinking of splitting some of the scripts and stuff out of lambdabot. like, scripts/BF.hs is a complete brainfuck interpreter which has little to do with lambabot
13:43:22 <Cale> sure
13:43:32 <gwern> (seems kind of silly to have it only in lambdabot)
13:44:12 <ddarius> Cale: If I ever finish this linear logic language implementation maybe I'll make a lambdabot interface for it.
13:44:16 <Cale> that reminds me that I should make sure that all the patches in my lb repo are in the public one
13:44:43 <b_jonas> gwern: but what would you gain by splitting?
13:45:04 <b_jonas> oh, you mean lambdabot would still have it, but there'd be a copy outside as well?
13:45:05 <b_jonas> I see
13:45:10 <gwern> b_jonas: well, for starters it would be easier for me when/if I ever get around to writing a lambdabot replacement
13:45:16 <b_jonas> not splitting as in removing it from lambdabot
13:45:21 <b_jonas> sorry
13:45:35 <Cale> uhh... I think I'll do that when code.h.o isn't randomly sending TERM signals to my processes.
13:45:42 <gwern> b_jonas: actually, I was figuring that I would remove it from lambdabot entirely, and perhaps do a executable/library split
13:46:06 <gwern> Cale: also, all the readmes and stuff still say dons is the maintainer :)
13:46:10 <gwern> (maybe want to change those)
13:46:12 <b_jonas> gwern: yeah, but remove as in split the code and make lambdabot include that library
13:46:39 <b_jonas> gwern: change those? no, it's not worth for Cale to do that :)
13:46:40 <gwern> b_jonas: right. cabal makes this sort of thing easier on us
13:46:48 <b_jonas> only if dons complains
13:47:06 <gwern> b_jonas: are you saying it is a sinister plot by Cale of laziness!
13:47:07 <gwern> UNPOSSIBLE
13:47:08 <Cale> Heh, I should make dons send me a patch ;)
13:47:23 <b_jonas> I'm quite lazy in this kind of thing too
13:47:39 <b_jonas> I should have written libraries to embed a J interpreter in perl and ruby for ages
13:47:41 <b_jonas> but no
13:47:49 <b_jonas> I just hacked the support right in two evalbots
13:47:54 <b_jonas> those evalbots sort of work
13:47:58 <gwern> it's kind of strange, there seems to be nothing at all for brainfuck on hackage; which is strange since haskellers seem to brainfuck all the time
13:48:05 <b_jonas> but no-one else can do the embedding easily now
13:48:29 <SamB> gwern: we are quite capable of writing our own brainfuck interpreters in tiny amounts of code
13:48:30 <b_jonas> whereas if I published those codes as separate modules, both the bots and other users would be happier
13:48:49 <gwern> SamB: bah
13:49:09 <SamB> hey, I had mine on hawiki
13:49:12 <b_jonas> same for the binary heap code. I wrote a new binary heap module for perl but haven't published it even though I know I wrote it because the existing modules weren't good for my use
13:49:23 <SamB> but then hawiki went away
13:50:13 <b_jonas> the source of my evalbot starts with pagefuls of code that's perfectly useable outside of the bot
13:50:48 <SamB> b_jonas: why not right this wrong?
13:50:50 <gwern> SamB: hawiki is still around
13:51:00 <SamB> gwern: since when ?
13:51:01 <gwern> just relicense your page and move it over to the haskell wiki
13:51:08 <b_jonas> SamB: you know, I don't really care about the ruby community
13:51:13 <SamB> I already relicensed it
13:51:18 <b_jonas> they should write their own modules if they want to
13:51:25 <SamB> b_jonas: oh, I thought you had a perl one...
13:51:55 <gwern> SamB: it's hidden away deep in the recesses of haskell.org, but I've seen it
13:52:02 <b_jonas> yeah, if I make anything public, that will be perl modules
13:52:10 <b_jonas> for interfacing J and for the binary heap and stuff
13:52:33 <SamB> gwern: some derivative of my interpreter may even have been copied over
13:52:47 <SamB> but it wasn't mine anymore really...
13:56:42 <dons> python apps rock. "TypeError: iter must be a GtkTreeIter"
13:57:06 <newsham> dons: thats not really fair :)
13:57:30 <Botje> yaaaay
13:57:36 <dons> well, a python app just crashed on me , with a type error at runtime.
13:57:39 <Botje> my compiler does closure conversion in a sensible (ish) way!
13:57:47 <newsham> oh, I see your point
13:57:56 <newsham> i thought you meant something else
13:58:08 <Korollary> the crash probably was caused by gtk
13:58:32 <b_jonas> Botje: what compiler are you doing?
13:58:47 <vixey> Botje good :P
13:58:48 <Botje> b_jonas: i'm compiling ML to assembly (or C) in haskell
13:58:58 <mmorrow> sweet
13:59:08 <b_jonas> ah, that's a nice task
13:59:09 <Botje> vixey: the trick was to insert the closures as "functions" into each letrec
13:59:23 <mmorrow> how are you handling tail calls in C?
13:59:23 <b_jonas> if you can do closure conversion, that's indeed nice
13:59:35 <Botje> mmorrow: i'm using continuations
13:59:38 <dons> Botje: just for fun?
13:59:46 <dons> would be a nice thing to write about
13:59:47 <Botje> dons: it's for my compilers course
13:59:52 <Botje> but i'm having _WAY_ more fun than i'm supposed to :)
14:00:05 <b_jonas> Botje: yeah
14:00:10 <b_jonas> I guessed so
14:00:15 <dons> hehe. yeah, the unsw course i tutored did a MiniML compiler, which was definitely a lot of fun
14:00:23 <Botje> the other guys are using C++
14:00:26 <dons> hah
14:00:28 <dons> suckers.
14:00:31 <Botje> they're at 2klock each
14:00:37 <Botje> *loc
14:00:45 <Botje> while i'm at 871 loc
14:00:50 <b_jonas> Botje: do they work in groups of one?
14:00:53 <Botje> yes
14:01:03 <b_jonas> I see
14:01:07 <Botje> there's only 6 students for the course, so groups would be a bit silly
14:01:07 <dons> statically typed FP is the killer app for compiler writing
14:01:26 <b_jonas> on the course where I had to write parsers I had a bit of fun too
14:01:32 <b_jonas> but I didn't get anything useful
14:01:43 <Botje> i'm using uniplate and parsec
14:02:22 <b_jonas> Botje: you're not writing the SML module system too, are you?
14:02:33 <Botje> b_jonas: no, i'm limiting myself to a subset
14:02:50 <newsham> I think its odd that FP compilers and non FP compilers be in the same class
14:02:51 <Botje> i'm not doing call/cc, i'm not doing mutation, and i'm not doing modules/structures/functors
14:02:54 <newsham> they're pretty different things
14:03:13 <mmorrow> Botje: by "using continuations" do you mean returning vals and a funcptr (or something) to a trampoline which calls that func w/ the vals, or just never return'ing and growing the stack?
14:03:18 <b_jonas> what ml has call/cc?
14:03:32 <SamB> how can it?
14:03:33 <Botje> dons: once i'm done-ish i'll clean up the code a bit and possibly do a writeup
14:03:36 <mmorrow> Botje: (in C)
14:03:39 <SamB> isn't call/cc invalid syntax in ml?
14:04:07 <Botje> mmorrow: uh, just jumping into functions instead of calling them, i guess
14:04:09 <b_jonas> no mutation? do you mean you're doing optimiztions on the code that assume no side effects?
14:04:27 <Botje> i'm only just beginning on the C side
14:04:34 <Botje> b_jonas: indeed, i'm only allowing print for now
14:04:45 <Botje> if i have time left i'll introduce more side effects
14:04:51 <ddarius> b_jonas: SML/NJ
14:04:57 <b_jonas> I thought ref was easy to implement
14:05:10 <mmorrow> Botje: but but how can you do that if you are generatiing only C? (is it C+asm?)
14:05:10 <b_jonas> I mean, it's just five functions or so
14:05:18 <dons> i think there's scope for a good '21st century compiler construction in Haskell' book
14:05:40 <b_jonas> a constructor, a getter, a setter, and two for the garbage collector
14:06:03 <Botje> mmorrow: while (true) { cont = *cont(args); }
14:06:08 <Botje> approximately
14:06:15 <Botje> i'm learning as i go along :)
14:06:41 <mmorrow> Botje: check out http://darcs.haskell.org/ghc/rts/Interpreter.c , it may or may not be helpful
14:06:49 <newsham> stg paper said they did something like that and it had some nice side effects for tracing/debugging
14:06:52 <b_jonas> also, are you doing the crazy builtin overloading standard ml has?
14:06:58 <newsham> since all your conts dispatch in one place
14:07:06 <Botje> b_jonas: ML has overloading?
14:07:10 <mmorrow> Botje: ineresting, i'll have to think about that
14:07:13 <Botje> are you referring to + vs +. ?
14:07:15 <mmorrow> interesting
14:07:20 <b_jonas> Botje: yep
14:07:26 <b_jonas> standard ml has those under the same name
14:07:29 <Botje> ah
14:07:32 <Botje> i'll see
14:07:37 <Botje> atm they're implemented separately
14:07:42 <Botje> i don't have a type system yet, either
14:07:49 <b_jonas> it has a limited set of builtin functions that work on more than one numeric and/or string types
14:07:50 <Botje> once I get types i can probably do overloading The Right Way(tm)
14:07:56 <Botje> I might even introduce typeclasses! :)
14:07:57 <b_jonas> and it has some overloaded number literals
14:08:15 <mmorrow> isn't let-related polymorphism the only polymorphism?
14:08:26 <mmorrow> (or something)
14:08:31 <b_jonas> Botje: oh, the Right Way would be easy
14:08:35 <b_jonas> the problem is,
14:08:45 <b_jonas> that standard ML itself isn't doing it the right way
14:08:48 <therp> anyone familiar with static analysis? flow graphs, fixed points, chain complete pos, etc. is there anything like that but with the focus on functional languages?
14:08:57 <b_jonas> to do it the way they require is difficult I think
14:09:56 <Botje> mmorrow: it looks interesting; i'll digg up my copy of implementation of functional programming languages and see how StG works, agan
14:09:56 <b_jonas> oh, and sml has limited typeclasses in that it has one standard typeclass (Eq) that can restrict anything
14:09:56 <therp> Botje: you would rather like to read the StG 'paper'
14:09:59 <b_jonas> so the type checker has to handle that if you want to do things correctly
14:10:10 <mmorrow> Botje: :)
14:10:26 <b_jonas> but you could just invent or find some saner ML-like language
14:10:37 <b_jonas> one that doesn't have the crazyness of standard ml
14:10:42 <Botje> b_jonas: :)
14:10:47 <Botje> i'm already writing a bastardized ML
14:10:48 <b_jonas> the standard ml standard library is good though
14:10:58 <Botje> so i might just add typeclasses
14:11:04 <mmorrow> therp: i bought http://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1212959383&sr=8-1 a few months ago and it seems fairly thorough, but minimal (<5 pages) about functional langs in partic. So i'm having to do the translation myself :(.
14:11:06 <lambdabot> http://tinyurl.com/6og3or
14:13:14 <b_jonas> yeah, just use a haskell-like type system with an ml-like syntax and ml-like strict semantics
14:13:14 <ddarius> Who wants ML-like syntax?
14:13:14 <b_jonas> ddarius: ok, then a haskell-like type system and haskell=like syntax (with some modifications to better adapt to side-effects) and ml-like semantics? is that better?
14:13:14 <dons> yeah, there's a real lack of a modern book on typed compilation-by-transformatoin compiler design
14:13:29 <b_jonas> dons: yeah
14:13:31 <therp> mmorrow: hm, if it contains imperative parts, it's likely that I have read about similar analysis concept in the last two terms.. so I guess I want something as modular as static analysis for type systems. dependent types look nice although they don't seem to embrace modularity at all
14:13:43 <dons> half the optimisations in ghc are not in any textbook, just research papers
14:14:01 <gwern> Cale: I'm sending the brainfuck lambdabot changes now; it'd be good if you could decide tonight, so I could upload the package
14:14:08 <SamB> therp: eh?
14:14:28 <b_jonas> gwern: is the unlambda interpreter only in lamdbabot as well?
14:14:33 <gwern> b_jonas: haskell syntax and ml semantics? reminds me a little of DDC
14:14:35 <SamB> what's this about dependant types and lack of modularity?
14:14:53 <Cale> gwern: decide?
14:14:54 <gwern> b_jonas: there is *a* unlambda interp, sure, but I don't know about only
14:14:56 <b_jonas> gwern: I mean, ML syntax has builtin progn/begin stuff
14:14:56 <gwern> lemme look
14:15:00 <ddarius> b_jonas: Yes.
14:15:13 <Cale> gwern: you mean whether to apply?
14:15:21 <mmorrow> therp: that book is the nittygritty implementation issues, and for that it seems (of what i've seen) the only book of its kind and seems to be the most up-to-date and extensive book of it's kind
14:15:21 <therp> SamB: it seems that you have to stuff two unrelated proofs into a single type just to be able to express that you function has these two properties
14:15:24 <gwern> Cale: yes
14:15:44 <SamB> therp: eh?
14:15:53 <ddarius> dons: I don't think optimizing lazy functional programs are in any textbooks other than the old one by SPJ.
14:15:55 <mmorrow> therp: ignore the parts of that that don't make sense, was editing and hit enter. the meaning should be clear though
14:16:04 <therp> SamB: I don't know how to respond to sentences like "eh?"
14:16:14 <gwern> b_jonas: I guess so. the only hits for haskell unlambda is http://www.haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters#Unlambda and that links to dons's old lambdabot repo :)
14:16:15 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2868t9
14:16:18 <Cale> gwern: Well, if code.h.o starts working properly, I should be able to do that quickly.
14:16:21 <mattam> therp: dependent types provide type-theoretic semantics to modules and abstract data types.
14:16:23 <gwern> b_jonas: you want me to split it out?
14:16:23 <SamB> therp: there's no reason you have to include proofs in your implementations
14:16:43 <b_jonas> gwern: no, I don't need it
14:16:56 <mattam> Yeah, you can have them separately just as well.
14:17:21 <dons> ddarius: right, its a bit of a gap in the market. 20 years of new research and techniques since the spj/lester book
14:17:28 <therp> SamB: as dependent typing is undecidable, I have to include proofs as there is no proper type inference here. at least that's what I've heard.
14:17:32 <mmorrow> i think ghc is the best textbook for modern implem of unctional langs
14:17:38 <SamB> therp: eh?
14:17:50 <therp> SamB: eh?
14:17:51 <SamB> therp: you don't need the theorems in the types either
14:18:18 <SamB> you can have other names that name proofs
14:18:19 <mattam> What proofs are you talking about here?
14:19:01 <therp> let's put that into the context of the upcoming paper about "Easy".. aka "Simply Easy!"
14:19:19 <SamB> hmm, haven't read that one...
14:20:06 <therp> I'd say that annotating functions with their types so that they can be typed checked, is the hard work here
14:20:32 <mmorrow> therp: unless the course you took was a job writing a compiler to-be-used for real world critical tasks, then you most def didn't cover everything in that book
14:20:45 <mmorrow> :)
14:21:42 <mattam> Well, types are not proofs. It's the other way around :)
14:21:44 <therp> mmorrow: I'm only interested in how to do static analysis, verification, inference.. I'm not particularly interested in how to do the rest of the compilers
14:22:02 <mmorrow> ahh, in that case that book isn't for you
14:22:03 <therp> mattam: yes, that's right :)
14:22:09 <SamB> therp: what exactly do you think we put in our types?
14:22:46 <gwern> jam. delicious delicious jam
14:22:51 <mmorrow> therp: otoh, if optimization is one of the thing which matters to you, the that book is *definitely* for you.
14:23:10 <mmorrow> s/thing/things/    s/the/then/
14:23:17 <mattam> What's important is that if you write H-M typable programs you will not need annotations (almost).
14:23:57 <ddarius> mattam: No, HM doesn't ever require annotations.  Adding type classes or polymorphic recursion (or many other things) does.
14:24:07 <therp> samb: by Curry-Howard, I'd say that types are propositions, and code that yields particular types fulfills these propositions
14:24:45 <ddarius> :t undefined :: a -> b
14:24:47 <lambdabot> forall a b. a -> b
14:25:13 <SamB> therp: but you never prove commutativity of addition in the implementation of the addition function...
14:25:17 <mattam> ddarius: hence the (almost). Also, many dep-typed languages enforce explicit type quantifiers, which you might consider as annotations as well.
14:25:35 <mmorrow> :t undefined :: ((a -> b) -> a) -> b
14:25:36 <lambdabot> forall a b. ((a -> b) -> a) -> b
14:25:46 <mmorrow> :t undefined :: ((forall b. a -> b) -> a) -> b
14:25:48 <lambdabot> forall a b. ((forall b1. a -> b1) -> a) -> b
14:25:51 <mattam> ddarius: I mean writting them in a dependently-typed language.
14:25:51 <ddarius> Dependently typed languages don't have Hindley-Milner type systems.
14:26:29 <therp> SamB: isn't there a way to express commutativity with types?
14:26:45 <ddarius> Maybe I misunderstood the original statement.
14:26:45 <SamB> therp: yes
14:26:51 <SamB> but not the type of the commutative function
14:27:04 <SamB> the type of a proof that the function is commutative
14:27:07 <therp> SamB: how would that work?
14:27:11 <ddarius> You could have + : {| int, int |} -> int
14:27:58 <SamB> therp: well, you have "add : nat -> nat -> nat"
14:28:50 <SamB> and "add_commutative : forall a b : nat, a + b == b + a"
14:28:52 <SamB> er.
14:29:18 <b_jonas> ddarius: what does "{| int, int |}" mean there?
14:29:22 <SamB> and where "a + b" is somewhere defined to be sugar for "add a b"
14:29:31 <ddarius> b_jonas: The bag containing int and int.
14:29:34 <mattam> There's a misunderstanding. Take a HM-typable program written in Haskell (wo typeclasses etc). My claim is that it can be elaborated into a well-typed term in most dep-typed languages with a minimum of annotations.
14:30:08 <SamB> yeah, shouldn't need nearly as many annotations as GHC's Core
14:30:52 <therp> SamB: and add_commutative is what type of object?
14:31:05 <SamB> the type is "forall a b : nat, a + b == b + a"
14:31:16 <therp> and the "code"?
14:31:18 <mattam> We could even allow some implicit let-generalization in the elaboration (someone's working on that in Coq) to recover full ML-like inference.
14:31:23 <SamB> the code is a proof
14:31:33 <therp> I'd say that would be the proof, but how does it look like?
14:32:17 <SamB> therp: depends on the language
14:32:50 <SamB> also I can never remember how to prove that
14:33:00 <koninkje> is there a way to get lambdabot to dump all quotes for a person?
14:33:05 <b_jonas> the proof?
14:33:25 <therp> SamB: if Nat is defined Peano style, I would say that it requires two inductions, at least that's what I remember from the last proof of commutativity I've seen
14:33:32 <b_jonas> well, the first step is that you prove transfinite induction and transfinite recursion,
14:33:34 <koninkje> (where "dump" == print)
14:33:36 <b_jonas> then you define omega
14:33:42 <SamB> b_jonas: what???
14:33:51 <b_jonas> then you define natural numbers and prove induction on them
14:33:59 <b_jonas> (that is, the peano axioms)
14:34:07 <SamB> b_jonas: what's this transfinite stuff for?
14:34:29 <b_jonas> SamB: well, I start from ZFC you know
14:34:46 <b_jonas> (you only need ZF minus regularity for this simple thing actually)
14:34:46 <SamB> b_jonas: isn't that non-constructive?
14:35:22 <b_jonas> don't think so
14:35:27 <SamB> oh
14:35:36 <b_jonas> no idea what non-constructive is really
14:35:42 <b_jonas> or do you mean constructive or what?
14:36:46 <b_jonas> dunno
14:36:53 <b_jonas> I'm just talking in the air really
14:37:15 <b_jonas> anyway, once you have the peano axioms,
14:38:08 <b_jonas> you define addittion with the recursion add 0 y = y; add (x + 1) y = (add x y) + 1
14:38:22 <mattam> I thought it wasn't possible to build a system where you can give a constructive proof of transfinite induction, because you can't represent all ordinals.
14:38:54 <b_jonas> then you prove by induction on x that (for each y natural: x + y = y + x)
14:39:23 <b_jonas> first, you prove this for x is 0 by induction on y
14:39:41 <SamB> b_jonas: in any case, a decent dependantly typed programming environment will find the induction principle for you...
14:40:48 <therp> SamB: could you give me hint what would be such a decent environments?
14:40:56 <therp> I'd like to play around with them/it a bit
14:40:59 <SamB> therp: well, coq is okay...
14:41:20 <SamB> Agda is interesting, but might make you hate Haskell's syntax for a while
14:41:21 <b_jonas> then whatever
14:41:22 <therp> hm, I intended to look at CoQ anyway
14:41:29 <b_jonas> I don't really remember all this kind of thing now
14:41:51 <b_jonas> maybe you don't even mess with this since you get it from a more general theorem
14:42:01 <b_jonas> but I'm quite sure you can prove it from the peano axioms easily too
14:42:08 <therp> SamB: I'm coming from Lisp. I dislike everything that doesn't have enough parenthesis (( :) )
14:42:12 <b_jonas> I did think about that six years ago
14:42:21 <b_jonas> and I think I got some proof
14:42:30 <SamB> if this is the peano axioms:
14:42:31 <therp> SamB: do you know CoqArt?
14:42:36 <SamB> therp: not really
14:42:46 <therp> I was wondering if its a good book to start with
14:43:28 * roconnor thinks "type errors messages are hard to understand" is a poor reason for not using type systems.
14:43:59 <b_jonas> roconnor: yeah
14:44:10 <therp> roconnor: depends on the lifespan of your code
14:44:16 <b_jonas> plus, it's not even true if you annotate each global with an exact type
14:44:20 <SamB> therp: well, I think Agda's syntax is what you would have gotten in Lisp if they had ever remembered to add syntax ;-)
14:44:32 <therp> I wouldn't like to think about types on my shell..
14:44:35 <EvilTerran> Agda's rather haskell-inspired, isn't it?
14:44:38 <SamB> well, maybe not
14:44:46 <b_jonas> which is a fair thing to do if you want to compare with untyped stuff
14:45:05 <newsham> i'm not sure coqart is a great way to start.  I think you might want to start with some type theory papers or book
14:45:11 <roconnor> therp: I'm not sure lifespan affects my decision
14:45:20 <roconnor> therp: hmm, maybe
14:45:34 <EvilTerran> lifespan = forever, to a first approximation.
14:45:40 <b_jonas> good night
14:45:54 <SamB> EvilTerran: except shell commands that have scrolled out of the buffer
14:46:03 <EvilTerran> well, true
14:46:05 <SamB> and the history
14:46:12 <therp> newsham: I'm half way through http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ already.. I'm not sure if that helps though
14:46:12 <lambdabot> Title: Type Theory and Functional Programming
14:46:21 <newsham> agda is very haskell-like.  it doest do any of the automatic tactics for you like coq and isabelle do
14:46:38 <EvilTerran> otoh, it's a viable general-purpose language, from what i hear
14:46:48 <EvilTerran> while i doubt the same could really be said of coq
14:47:01 <SamB> EvilTerran: well, guess which has type classes though
14:47:16 <EvilTerran> (i'm not being scornful of Coq or anything - being a research language is a laudable goal too)
14:47:18 <newsham> therp: if you already ahve some of the theory, I'd recommend http://www.cs.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf and playing around with agda
14:47:29 <EvilTerran> SamB, i'm guessing you can load them into Coq, if they aren't there already
14:47:32 <newsham> the paper is a nice intro because it gives real examples
14:47:42 <SamB> EvilTerran: they are there
14:47:47 <EvilTerran> not sure if agda's fancy-schmancy enough to pull that off
14:48:03 <SamB> Agda doesn't support loading language features
14:48:15 <EvilTerran> quite
14:48:23 * EvilTerran goes to check his laundry
14:48:49 <roconnor> therp: I learned dependent type theory from that book.
14:49:44 <therp> roconnor: I really appreciate that such high quality books are freely available on the net
14:50:15 <therp> newsham: sounds interesting. thanks for the link
14:50:27 <roconnor> therp: the notion of equality changes from system to system, other than that what you learn should be widely applicable.
14:50:42 <SamB> does it now?
14:50:44 <roconnor> equality is a very subtle issue.
14:50:57 <SamB> so what doesn't use propositional equality?
14:51:03 <newsham> therp: requires some work though, they leave some of the steps to the reader :)
14:51:25 <therp> newsham: that's ok, the summer is coming :)
14:51:34 <roconnor> SamB: Coq uses an inductive definition of leibniz equality
14:51:42 <roconnor> Agda has the K axiom
14:51:52 <roconnor> OTT has its own observational equality
14:52:02 <SamB> doesn't Agda also use the leibniz equality though?
14:52:13 <roconnor> and TT from the book TTFP has it's own equality that is different still.
14:52:21 <roconnor> Not sure how to describe that one.
14:52:33 <roconnor> The all call it Leibniz
14:52:35 <roconnor> They
14:52:38 <SamB> oh.
14:52:55 <SamB> but doesn't agda also use the inductive datatype?
14:53:02 <newsham> the type theory book i'm reading talks about many alternatives for equality
14:53:32 <roconnor> SamB, yes but AFAIK Agda doesn't use destructors.  It has some pattern match semantics instead.
14:53:55 <SamB> destructors?
14:53:58 <SamB> like what?
14:54:00 <roconnor> I'm starting to think "Leibinz" equality just means "the most refined equality available for the system".
14:54:00 <newsham> oh, heh, its the same book (TTFP)
14:54:14 <roconnor> SamB: primitive recursion
14:54:26 <roconnor> Actually Coq doesn't use destructors either, it uses match and fixpoint.
14:54:36 <newsham> agda2 has pattern matching for deconstructors
14:54:42 <newsham> there's also the "with..." pattern matching stuff
14:54:51 <gwern> Cale: I'm sending a single patch bundle, containing my brainfuck patches, my unlambda patches, and my cabal/readme/style/todo/authors edits
14:54:55 <SamB> I would assume that Agda is doing the same thing, only with less syntax
14:54:59 <roconnor> the semantics of agda2's pattern matching implies the K axiom
14:55:10 <Cale> gwern: okay, thanks!
14:55:13 <newsham> i wish i knew what that meant :)
14:55:13 <roconnor> which is a good thing IMHO
14:55:35 <SamB> yeah.
14:55:44 <roconnor> newsham: the K axioms says proves that there is only one proof of A = A, reflexivity.
14:55:48 <roconnor> K axiom
14:55:55 <newsham> ahh
14:55:55 <SamB> I was surprised that Coq was unable to prove K...
14:56:20 <roconnor> newsham: homotopy(?) models of type theory don't satifiy the K axiom
14:56:25 <SamB> I mean, how the heck can there be another constructor of that type?
14:56:34 <roconnor> there can be more than one loop from a point to itself.
14:56:34 <opqdonut> homotopy models?
14:56:45 <roconnor> corresponding to more than one proof of  A=A.
14:56:47 <SamB> and that constructor will only have that type if it has that value as argument...
14:57:13 <roconnor> opqdonut: I don't know too much about homotopy models.
14:58:09 <SamB> hmm. Perhaps Coq's lack of K is why they need Prop?
14:58:39 <roconnor> SamB: I think that is unrelated.
14:58:51 <roconnor> Coq doesn't "need" Prop.
14:59:01 <roconnor> AFAIK
14:59:20 <mattam> You can work in Coq without ever using Prop.
14:59:46 <mattam> At least in principle :)
14:59:47 <SamB> yes, but what about using the libraries?
15:00:01 <SamB> and ... you know ... tactics?
15:00:30 <roconnor> most tactics don't care about Prop
15:00:33 <roconnor> tauto might
15:00:40 <roconnor> but tauto should be fixed. :)
15:00:59 <roconnor> replace it with djinn.
15:01:07 <SamB> I was thinking more along the lines of tactics that use specific things in the library
15:01:15 <SamB> which happen to somehow involve Prop
15:01:33 <roconnor> SamB, the only one that comes to my mind is tauto
15:01:39 <roconnor> Hmm, maybe rewrite too. :(
15:01:41 <mattam> And rewrite.
15:01:52 <roconnor> oh
15:01:53 <mattam> And inversion.
15:01:54 <roconnor> and inversion
15:01:56 <roconnor> *sigh*
15:02:00 <mattam> :)
15:02:11 <SamB> so few?
15:02:18 <roconnor> I wonder if inversion can be written to not use eq.
15:02:31 <roconnor> I suspect it can
15:02:43 <RayNbow> @pl (\x y -> (x,y))
15:02:43 <lambdabot> (,)
15:02:45 <roconnor> actually inversion should be rewritten anyways to implement Conor's algorithm IIRC.
15:02:47 <RayNbow> ^ luite
15:02:50 <SamB> it should be possible to use it on any "leibiz" equality, yes?
15:03:01 <SamB> er, with the n
15:03:02 <mattam> I don't think so. You can only get so far with using substitution only.
15:03:16 <SamB> I meant...
15:03:19 <SamB> any
15:03:24 <RayNbow> @pl (\x y -> [x,y])
15:03:25 <lambdabot> (. return) . (:)
15:03:41 <mattam> roconnor: I did that already! dependent destruction/induction in Coq.Program.Equality.
15:04:27 <SamB> datatype with the same form as eq, but with any of Set, Type, Prop...
15:05:01 <mattam> SamB: I think it's only a matter of changing "eq" by "eqT" somewhere in rewrite's code.
15:05:07 <roconnor> mattam: did you replace inverson?
15:05:41 <mattam> No. I'm not masochist.
15:05:57 <roconnor> *sigh*
15:05:58 <roconnor> :)
15:08:20 <RayNbow> @pl (\x y-> concat (zipWith ((. return) . (:)) x y))
15:08:20 <lambdabot> (join .) . zipWith ((. return) . (:))
15:09:06 <tusho> @src Comonad
15:09:07 <lambdabot> Source not found. Take a stress pill and think things over.
15:09:26 <RayNbow> just wondering... can someone here actually read pointless definitions? :p
15:09:53 <dmwit> Mostly yes.
15:10:03 <tusho> :t (join .) . zipWith ((. return) . (:))
15:10:05 <lambdabot> forall a. [a] -> [a] -> [a]
15:10:16 <tusho> > ((join .) . zipWith ((. return) . (:))) [1,2,3] [4,5,6]
15:10:18 <lambdabot>  [1,4,2,5,3,6]
15:10:18 <RayNbow> tusho: it's a truncated interleave style function
15:10:26 <tusho> Cool, I guess.
15:10:28 <RayNbow> dmwit: really?
15:10:30 <vixey> roconnor: regarding inversion, which replacement??
15:10:33 <vixey> -?
15:10:40 * RayNbow can only read simple pl definitions :p
15:10:50 <dmwit> There's some tricks.
15:10:58 <davidL> noob question, how do I use guards with a function that returns 'm Bool'?
15:11:06 <dmwit> (. return) . (:) = \a b -> [a, b]
15:11:10 <RayNbow> my head probably explodes the moment a pl definition contains more than 1 composition
15:11:16 <dmwit> From there it's pretty obvious.
15:11:36 <tusho> davidL: can't
15:11:40 <dmwit> davidL: x <- m; guard x
15:11:46 <tusho> dmwit: think he meant function guards
15:11:49 <tusho> f a | b = c
15:11:56 <dmwit> oh
15:11:59 <davidL> yeah
15:12:19 <roconnor> vixey: mattam's dependent induction
15:12:21 <dmwit> You can't but there's a lot of functions to make things nice.
15:12:24 <dmwit> :t guard
15:12:26 <dmwit> :t when
15:12:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:12:27 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:12:43 <Peaker_> Why MonadPlus?
15:12:46 <dmwit> :t \p x -> guard (p x) >> return x -- one I define in module Dmwit
15:12:48 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
15:12:59 <dmwit> Peaker_: So it has a distinguished (non-fail) value to return for False.
15:13:17 <Peaker_> oh, ok
15:13:23 <davidL> thanks dmwit
15:14:11 <dmwit> :t filterM -- could also be relevant
15:14:12 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:15:29 <Peaker_> davidL: What is the function's type?
15:15:49 <davidL> (MonadReader State m) => Int -> m Bool
15:17:10 <dmwit> You could runReader it if you *really* wanted that.
15:17:19 <dmwit> But that would sort of negate the convenience of MonadReader.
15:17:33 <davidL> I'll use guard
15:17:47 <dmwit> yep, good choice
15:18:11 <Peaker_> Why can't you use normal guards then?   returnsMonadicBool | 0 = return True ; | n = return False ?
15:18:34 <dmwit> Peaker_: That's the function he wants to use in the guard.
15:18:40 <dmwit> f :: Int -> m Bool
15:18:48 <Peaker_> oh
15:19:16 <Peaker_> I think I understood that the first time I read it and then misunderstood the second time :)
15:19:43 * dmwit wanders off in search of food
15:19:56 <davidL> thanks again ;)
15:20:44 <tusho> Peaker_: | 0?
15:20:46 <Eurialo> sorry, can someone explain in a few words what the heck fptools are? googling "fptools" did not helped :|
15:20:48 <tusho> hah
15:21:29 <SamB> Eurialo: fptools was the name of the CVS repository where GHC lived
15:22:07 <Eurialo> SamB: thanks... so it is/was just a repository's name :)
15:22:31 <SamB> I think a few other repositories were split off of it
15:22:36 <SamB> but yes
15:22:43 <SamB> just the name of a CVS repository
15:23:10 <Eurialo> well, a quite misleading name, in my opinion :)
15:23:24 <SamB> why?
15:23:37 <SamB> I think all of the things in it were FP tools
15:24:31 <Eurialo> it looked more like a library's name, or something like that, to me :)
15:36:15 <purejadekid> I'm having trouble getting ghc 6.8.2 to install in Mac OS X Leopard and I suspect it has something to do with readline 5.2 (which I also cannot get to install from source). gcc gives this weird error:
15:36:16 <purejadekid> i686-apple-darwin9-gcc-4.0.1: -compatibility_version only allowed with -dynamiclib
15:37:06 <gwern> Cale: I'm going to upload unlambda and brainfuck if you have no issues, then
15:38:32 <purejadekid> yeah GHC 6.8.2 install errors out at: Installing: /usr/local/lib/ghc-6.8.2/lib/readline-1.0.1.0
15:41:06 <gwern> ok. anyone want to cabal-install unlambda or brainfuck?
15:41:25 <tusho> gwern: no, I imagine the implementations are of very poor quality
15:41:32 <tusho> most toy BF and UL ones are
15:41:51 <gwern> what would you do in BF or UL that wasn't toy?
15:42:02 <tusho> gwern: not much, but there are very good optimizing BF compilers
15:42:05 <gwern> (toy implementations for toy programs)
15:42:07 <tusho> and UL is in fact compilabl
15:42:07 <tusho> e
15:42:16 <tusho> it only makes sense to have the best haskell implementations up
15:42:21 <tusho> remind me tomorrow, i'll write some ;-)
15:42:36 <gwern> tusho: well, if by 'best' you mean only, I agree...
15:42:48 <tusho> gwern: i don't think you realise how many optimizations apply to bf
15:42:49 <tusho> a lot do
15:42:52 <tusho> and it can be very fast
15:42:58 <tusho> (there's a 2mb text adventure written in BF)
15:42:59 <tusho> and ONLY bf
15:43:02 <tusho> it's fun
15:43:05 <tusho> and it sucks on a slow impl
15:43:27 <tusho> (Technically written in a dialect of basic designed to compile to bf, but that source isn't public so.)
15:43:27 <tusho> it's fun as in i actually play it
15:43:27 <gwern> SamB: hey, I found your bf interpreter: http://haskell.org/haskellwiki/Short_examples/BF_interpreter
15:43:27 <lambdabot> Title: Short examples/BF interpreter - HaskellWiki
15:43:45 <SamB_XP> gwern: that isn't really the same one that I wrote
15:43:57 <SamB_XP> since it had undergone a lot of changes on hawiki...
15:44:07 <gwern> well, there's also this implementation: http://sabbatical-year.blogspot.com/2008/01/brainfuck-its-last-one-i-promise.html
15:44:09 <lambdabot> Title: my sabbatical year diary: Brainfuck - it's the last one, I promise, http://tinyurl.com/3boata
15:44:18 <gwern> the author seems to've done a fair bit of optimization
15:45:12 <tusho> bah, nobody cares about super-fast BF implementations :<
15:45:35 <tusho> i have compiled underload into C, though, which looks uncompilable at first glance
15:45:40 <tusho> i was rewriting it in haskell at one point
16:00:47 <tusho> Z
16:01:01 * roconnor tries to remember what a connection on a manafold is.
16:01:13 <mauke> not enough mana
16:01:24 <slava> roconnor: its a means of 'transporting' tangent vectors from one point to another
16:02:16 <roconnor> ok
16:03:43 <roconnor> slava: the resulting vector depends on the path taken I suppose.
16:03:57 <slava> i don't recall
16:04:03 <slava> a good book on differential geometry will have details
16:04:27 <roconnor> I should get a good book on differential geometry.
16:04:40 <roconnor> I never did buy spivak
16:04:55 <roconnor> not sure spivak's book counts as good.
16:04:57 <tusho> roconnor: e never bought spivak, so eir copy of spivak is non-existant
16:05:02 <tusho> oh that was so lame
16:05:08 <tusho> :\
16:05:11 <roconnor> :)
16:05:19 <tusho> i blame agora
16:07:45 <purejadekid> I got readline 5.2 to compile on Mac OS X based on this Japanese webpage (Google Translate!): http://d.hatena.ne.jp/agw/20071107
16:07:46 <lambdabot> Title: Building the GNU Readline Library on Leopard - agw
16:09:05 <purejadekid> summary: just load readline-5.2/support/shobj-conf and on line 171 change darwin[78]* to darwin[789]*, then ./configure, make, etc.
16:12:28 <RyanT5000> is there an http user agent for haskell like cpan's mechanize?
16:14:10 <purejadekid> Can anyone help me with GHC 6.8.2 failing mid make install (OS X):
16:14:16 <purejadekid> installPackage: Multiple files with extension buildinfo
16:14:27 <purejadekid> make[1]: *** [install.library.Cabal] Error 1
16:17:46 <roconnor> hmm, a connection seems to be a function of two vectors to one vector.
16:19:20 <purejadekid> anyone know where to bang my head when I can't install GHC 6.8.2? submit a bug? email? get help?
16:19:42 <purejadekid> I tried the advice here: http://hackage.haskell.org/trac/ghc/wiki/Building/MacOSX
16:19:43 <lambdabot> Title: Building/MacOSX - GHC - Trac
16:19:51 <gubagem> go try nhc??
16:19:57 <gubagem> or give everyone some Hugs
16:21:32 <cladhaire> purejadekid: honestly, the best bet is to use macports
16:21:41 <purejadekid> like fink?
16:21:45 <cladhaire> no, macports :P
16:21:54 <cladhaire> http://www.macports.org/
16:22:02 <cladhaire> then its just a matter of sudo port install ghc
16:22:20 <cladhaire> I tried a bunch of methods including bootstrapping, compiling straight, compiling a readline package
16:22:30 <cladhaire> and while they _can_ work.. none of them are easy
16:22:46 <purejadekid> ok thank you!
16:22:52 <clad|sleep> you're welcome!
16:28:26 <roconnor> GL(n) is connected as a manifold?
16:28:28 <roconnor> how?
16:28:48 <chessguy> i installed GHC via macports, it's quite easy
16:29:19 <purejadekid> :-) I'm installing macports now
16:29:23 <ddarius> roconnor: Why wouldn't it be?
16:29:36 <purejadekid> why did I even use fink? are they related?
16:29:54 <tusho> no, they're not
16:29:59 <tusho> fink sucks, macports doesn't
16:30:04 <roconnor> ddarius: positive determinant and negative determinant
16:30:31 <roconnor> I guess these two sheets get arbitrarily close to each other, but still
16:30:43 <roconnor> aren't these two sets open and disjoint?
16:31:06 <hpaste>  Mr.Elendig pasted "xmonad.hs error" at http://hpaste.org/8197
16:31:17 <roconnor> oh
16:32:02 <roconnor> I think maybe it is saying that GL+(n) is connected as a manifold.
16:43:33 <atp> sometimes, manifolds have many folds
16:43:37 <atp> bwahaha
16:46:26 * ddarius wishes Haskell had refinement types now
16:53:26 <dogbite> what's the best place to get the probabilistic functional programming package?
16:53:38 <dogbite> is this it?
16:53:40 <dogbite> http://web.engr.oregonstate.edu/~erwig/pfp/pfp-jun06.tar.gz
16:53:57 <jamii> How recent is the hackage version?
16:54:44 <cjay> can someone confirm that :show modules doesn't work on ghci 6.8.2?
16:55:11 <EvilTerran> ... what's meant to happen?
16:55:29 <ivanm> cjay: works here...
16:55:41 <cjay> weird
16:55:55 <cjay> EvilTerran: should output the same stuff as in the default prompt
16:55:59 <EvilTerran> doesn't seem to work here... i get no output, even after :m+'ing something
16:55:59 <ivanm> ghci Foo.hs... then :show modules shows Foo (Foo.hs, interpreted)
16:56:11 <dogbite> jamii: i'm not sure.  is this it?
16:56:12 <dogbite> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/probability
16:56:13 <ivanm> cjay: I think it only works for interpreted modules
16:56:14 <lambdabot> http://tinyurl.com/5jrxmr
16:56:17 <ivanm> not compiled ones
16:56:31 <cjay> ivanm: oh I see, my fault
16:56:45 <cjay> or rather the documentation's fault
16:57:23 <ivanm> heh
16:58:44 <jamii> dogbite: I cant find a version number in the first one but the hackage version was updated march 11. Probably means its the most recent...?
16:59:25 <dogbite> yeah i think it's likely more recent, just not sure if it's the same thing
17:00:09 <jamii> Most of the module names are the same. The hackage one has a couple more modules
17:12:39 <dogbite> jamil: thanks
17:34:15 <dons> alberto ruiz's hmatrix/easyVision stuff is freakingly awesome, http://alberrto.googlepages.com/easyvision
17:34:16 <lambdabot> Title: Alberrto - easyVision
17:35:14 <koninkje> dogbite: depending on what you're trying to do with probabilities, I have a module (as yet unpublished) for doing log-space manipulation of floats to avoid underflow issues
17:36:44 <dons> and there's an excellent blog, http://www.reddit.com/info/6mjry/comments/
17:36:45 <lambdabot> Title: reddit.com: Vanishing Points: freakingly awesome computer vision work in Haskell
17:45:22 <augur> freakingly? lol
17:45:35 <dmwit> s/ng/sh/
17:45:45 <augur> ;)
17:45:50 <dons> no no. its freaking-ly awesome.
17:45:59 <augur> like you're freaking!
17:46:01 <dons> it freaks you out.
17:46:13 <augur> in a manner that is freaking! :p
17:46:14 <dons> though it is also freakish -- only a freak could do it.
17:46:42 <dons> dcoutts: there's a really cool binding to IPP, the super zippy intel image library inside easyVision
17:46:52 <dons> lots of good stuff waiting to be cabalised, http://www.intel.com/cd/software/products/asmo-na/eng/perflib/ipp/302910.htm
17:46:58 <lambdabot> http://tinyurl.com/yawtuq
17:48:39 <atp> hey, has anyone here played with coconut?
17:50:40 <edwardk> ugliest type ever:  synchro :: Bifunctor h Hask Hask Hask => Bialgebra m n c -> (h x (Either a c) -> m c) -> Trialgebra (f x) (g x) (h x) a -> ((h x a, b) -> k x b) -> ((h x a, j x b) -> h x (Either a (g x a, b))) -> Bialgebra (k x) (j x) b -> (g x a, b) -> c
17:51:41 <edwardk> I know what it does, and why it does it but that type there is officially I think the upper limit of complexity for any type I'm willing to allow into category-extras =)
17:54:47 <cjay> ouch :)
17:56:33 <chessguy> @pl \t -> f (a t)
17:56:33 <lambdabot> f . a
17:56:40 <edwardk> that was the hardest morphism i've been able to find in literature ;)
17:57:45 <vixey> I didn't know Bifunctor h Hask Hask Hask would be legal
17:58:18 <edwardk> I defined Bifunctor to take 3 categories are arguments
17:58:22 <edwardk> er as
17:58:38 <atp> wow
17:58:40 <edwardk> weakened to only require a QFunctor now
17:58:47 <atp> Bifunctors ftw
17:58:59 <atp> i didn't realize we had a type class for those
17:59:06 <atp> or is that only in category-extras, edwardk?
17:59:09 <dmwit> We don't.
17:59:10 <edwardk> atp: its in category-extras
17:59:10 <dmwit> yep
17:59:13 <atp> nice.
17:59:36 <edwardk> same with Bialgebra and Trialgebra
17:59:54 <atp> can you post the bifunctor class or point me to a link?  is (a,b) an instance?
18:00:01 <atp> what about (->) ?
18:00:22 <vixey> @hackage category-extras
18:00:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
18:00:46 <edwardk> atp: instance Bifunctor (->) (Dual (->)) (->) (->) is in there and instance Bifunctor (,) (->) (->) (->) is also
18:01:07 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.0/doc/html/Control-Functor.html
18:01:08 <atp> awesome
18:01:09 <lambdabot> http://tinyurl.com/6o7gpm
18:01:14 <atp> thanks mate, i'll check it out
18:01:20 <edwardk> type Hask = (->) for readability
18:01:51 <atp> ah, i was wondering
18:02:06 <edwardk> PFunctor and QFunctor exist because there are times when i can't infer enough of the type to know the parameters for Bifunctor uniquely enough
18:02:32 <atp> interesting.  is that a limitation of the type system?
18:03:05 <atp> i have often wanted a bifunctor type class with an instance for (,)
18:03:49 <atp> oh wow
18:03:57 <atp> i see what you mean about PFunctor and QFunctor now
18:05:45 <edwardk> atp: anyways there are defs in there for Either and (,), but they don't show in the haddock
18:05:54 <atp> nod
18:06:02 <atp> unfortunately there's no source code link on this but i can download it
18:06:17 <edwardk> http://comonad.com/haskell/category-extras/ is where i work on it
18:06:17 <lambdabot> Title: Index of /haskell/category-extras
18:06:23 <edwardk> that has code
18:06:36 <atp> awesome!
18:07:37 <atp> hm, so are these definitions generic enough that we can define a monad in a category theoretic way?
18:07:41 <atp> as a functor, i mean?
18:07:53 <atp> and comonads for that matter
18:08:23 <edwardk> well, i stopepd short of that because i would have to give up access to the standard library monads. but its not hard to extend. i have a CFunctor that is a 'categorical functor'
18:08:33 <atp> oh nice, second = (.)
18:08:35 <atp> hehe
18:08:54 <edwardk> a CMonad would be a categorical monad in my syntax, so instance CMonad m k would take a category k as a parameter
18:08:55 <SamB_XP> edwardk: too bad those things are wired in
18:09:21 <atp> SamB_XP: more ammunition for your "no library in the language spec" battle
18:09:25 <edwardk> heh
18:09:54 <atp> anyway it doesn't need to be called Monad, CMonad is fine for playing with
18:10:29 <atp> this is really elegant edwardk, i like
18:10:55 <edwardk> atp: http://comonad.com/haskell/category-extras/src/Control/Functor/Categorical.hs has the categorical functor stuff. http://comonad.com/haskell/category-extras/src/Control/Monad/Categorical.hs has the categorical monad stuff but i just haven't defined any instances yet
18:10:56 <lambdabot> http://tinyurl.com/5szvf3
18:11:18 <atp> i wonder, does bimap always need to be lazy in the bifunctor argument?
18:11:38 <atp> i notice for (,) you have a lazy def
18:11:49 <edwardk> atp: well, otherwise it is unduly strict
18:12:05 <edwardk> nothing forces the pattern match there.
18:12:22 <atp> nod
18:12:46 <edwardk> atp: if your pair had a bottom in it using a strict match would evaluate to bottom when the irrefutable pattern won't, it costs little, so i went with the irrefutable form
18:13:49 <atp> yeah, that makes sense.  no need to unwrap, since it's a product
18:13:57 <gwern> @index infix
18:13:57 <lambdabot> bzzt
18:14:06 <gwern> @index isInfixOf
18:14:06 <lambdabot> bzzt
18:14:16 <gwern> @index head
18:14:16 <lambdabot> Data.List, Prelude
18:14:18 <edwardk> my main issue with CMonad is that it looks too much like Comonad
18:14:27 <atp> hm
18:14:37 <atp> yeah, that's true.  What about CatMonad or something?
18:15:00 <edwardk> atp: that would strike me as a monad in the category Cat, which is a different beast, coz a Cat-Monad is a well defined concept ;)
18:15:08 <atp> ah good point
18:15:21 <atp> MonadC ?
18:15:22 <atp> hehe
18:15:31 <edwardk> so i wanted to reserve CatFoo for cat level concepts.
18:15:38 <atp> yeah, that makes perfect sense.
18:15:46 <edwardk> and Monad' is too easy to miss seeing
18:15:50 <atp> but you know, honestly, anyone using CMonad will know the difference
18:16:05 <atp> MonadC could be ok?
18:16:07 <edwardk> nd all my other variants parameterized, higher order, indexed, Bi... all use prefixes
18:16:28 <atp> hm
18:16:36 <atp> well, Monad' would break that anyway
18:16:40 <edwardk> yeah
18:16:48 <edwardk> i think CMonad is the lesser of evils
18:16:58 <atp> yeah, honestly i doubt that would bite me
18:17:28 <SamB_XP> if it bit ME, it would only because I had somehow managed to miss the "o" key
18:17:32 <twanvl> How about GenMonad?
18:17:45 <SamB_XP> and hey, that would have been a problem anyway
18:17:46 <atp> SamB_XP: and screw up the caps
18:17:48 <edwardk> major caveat re CMonad for consistency with the rest of my library and to avoid requiring exponentials in every category over which it works bind is flipped around a bit
18:18:25 <atp> you're not defining bind in terms of unit/bind and fmap?
18:18:28 <atp> err
18:18:30 <atp> unit/join?
18:18:43 <edwardk> twanvl: I thought about using G as a prefix for it, but GFoo has been sort of claimed for GADT purposes ala ghani.
18:19:02 <edwardk> atp: nah, i define bind and join metacircularly, so you can use join or bind to define the monad. so you get to pick
18:19:03 <atp> it's amazing how much stuff is taken already
18:19:15 <atp> edwardk: ah, that's even better.
18:19:33 <atp> i've never been a fan of calling it return :/
18:19:56 <atp> it only rarely ever coincides with that word's usual meaning in programming
18:19:59 <edwardk> atp: i stuck with return because it is a well known mnemonic and less scary to people
18:20:05 <atp> yeah, i know
18:20:09 <atp> i'm not suggesting that you change it
18:20:17 <atp> i think the choice back when it was made was ill-advised though
18:20:20 <edwardk> atp: same reason i use extract and extend for comonads rather than counit/cobind
18:20:35 <atp> yeah
18:20:39 <SamB_XP> yeah... return isn't very much like what it does...
18:20:51 <atp> especially when we write return foo >>= f >>= g ...
18:20:56 <atp> or something similar
18:21:02 <atp> that really confuses imperative programmers :)
18:21:05 <SamB_XP> we never actually write that
18:21:13 <atp> sure, we write f foo >>= g but that's not the point
18:21:14 <atp> we could
18:21:24 <atp> it's legal
18:21:27 <SamB_XP> it is
18:22:01 <atp> i think lift wouldn't have been bad
18:22:11 <atp> but that's used elsewhere
18:22:13 <edwardk> lift is used sooo many places though
18:22:15 <atp> yeah
18:22:20 <atp> but i mean, conceptually
18:22:25 <atp> that's probably closest to what it does
18:22:31 <twanvl> I think pure is a good name for it
18:22:32 <edwardk> everything wants to be called lift. its like larry wall's rule about how every language feature wants to use the (:) for syntax.
18:22:34 <atp> it's just such a generic math word
18:22:37 <Dzlk> raise?
18:22:41 <atp> nah
18:22:44 <atp> too much like exceptions
18:22:45 <Dzlk> but that sounds like an exception.
18:23:01 <edwardk> my personal favorite it 'ok'
18:23:06 <atp> haha
18:23:13 <edwardk> er is
18:23:22 <atp> but i do a lot of ok <- someFuncThatReturnMonadBool ; if ok then ...
18:23:30 <SamB_XP> next...
18:23:41 <SamB_XP> @let like a = a
18:23:43 <lambdabot> Defined.
18:23:59 <atp> > like 5
18:24:01 <lambdabot>  5
18:24:08 <edwardk> yeah, well, in my case it was because my toy language has a very erlang like structure and Ok is used traditionally in erlang for the purpose of 'right' in the exception handling monad we've bastardized Either into being.
18:24:32 <atp> don't we have a type Error = Either somewhere
18:24:36 <atp> we definitely have ErrorT
18:24:58 <gwern> @index gelem
18:24:58 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive
18:24:59 <edwardk> atp: unfortunately, we use Either for the Exception monad.
18:25:08 <atp> right
18:25:10 <gwern> @index geFloat#
18:25:11 <lambdabot> bzzt
18:25:11 <atp> i mean, i know that
18:25:11 <edwardk> atp: instance Error a => Monad (Either a)
18:25:13 <edwardk> suck
18:25:14 <edwardk> =)
18:25:19 <atp> ouch.
18:25:26 <edwardk> it mucks up my apomorphisms
18:25:31 <dolio> Oh yeah, Error is a class.
18:25:33 <edwardk> because those want the REAL either monad.
18:25:35 <gwern> @index generalCategory
18:25:35 <lambdabot> bzzt
18:25:44 <gwern> hm.
18:25:48 <gwern> @seen Cale
18:25:48 <dolio> That's kind of wonky.
18:25:48 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
18:25:59 <edwardk> so i wind up having to define Control.Monad.Either and ignore the fact that Control.Monad.Error even exists in category-extras
18:26:02 <twanvl> As usual, fail is to blame here
18:26:25 * atp hates fail.
18:26:25 <edwardk> heya dolio
18:26:31 <dolio> Yo.
18:26:37 <edwardk> dolio: http://comonad.com/haskell/category-extras/src/Control/Morphism/Prepro.hs contains the prepromorphism stuff you asked about way back when
18:26:37 <lambdabot> http://tinyurl.com/66o39k
18:26:38 <gwern> @ask Cale hey, does scripts/GenHaddock.hs work where you are? where I am, it seems odd and baroque, and it doesn't write anything because of 'let docfiles = filter ("doc-index-"`isPrefixOf`) files'
18:26:39 <lambdabot> Consider it noted.
18:26:58 <dolio> Ah. I never got around to reading that paper.
18:27:01 <edwardk> dolio: and all of the standard morphisms have been updated with prepro/postpro variants
18:27:12 <dons> dcoutts: interesting issue. in a non-allocating loop we'd like to float touch# outside the loop
18:27:23 <dons> though is there any runtime cost for: touch# @ ForeignPtrContents ww2_s1Ns s2_a1HU ?
18:27:24 <edwardk> also, officially the worst morphism ever (type wise): http://comonad.com/haskell/category-extras/src/Control/Morphism/Synchro.hs
18:27:25 <lambdabot> http://tinyurl.com/5m8rdp
18:28:06 <twanvl> ouch
18:28:11 <atp> that's the one you mentioned earlier eh?
18:28:17 <dolio> Oh, you took the plunge and made bifunctors associated with categories, eh?
18:28:29 <edwardk> atp: yeah
18:28:36 <atp> edwardk: you have a math link?
18:28:40 <atp> edwardk: re synchro morphism?
18:28:45 <edwardk> dolio: yeah. i have categorical functors, but i haven't swapped it out
18:28:54 <edwardk> atp: yeah martin erwig has a paper on them one sec.
18:29:05 <edwardk> http://web.engr.oregonstate.edu/~erwig/papers/RandomAccessADT_AMAST00.pdf
18:29:06 <lambdabot> http://tinyurl.com/59zdxn
18:29:07 <dolio> Wow, that synchromorphism is ridonkulous.
18:29:19 <edwardk> dolio: i decided for once not to generalize it ;)
18:29:38 <dons> i'm a big fan of this hmatrix lib. its really good work.
18:29:38 <atp> thanks
18:29:42 <edwardk> dolio: but the prepro and postpro morphisms generalized perfectly into monadic and comonadic variants
18:29:48 <dons> i think we've a new best recommendation for people asking about arrays stuff
18:29:57 <dons> numerics, anyway
18:30:30 <edwardk> dolio: which means that the para-prepro mentioned in the paper is just the use of my distributive law combinator for paramorphisms with a generalized prepromorphism for instance.
18:30:49 <dolio> Nice.
18:31:11 <edwardk> and that you can do things like build up zygohistomorphic prepromorphisms if you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor.
18:31:13 <atp> i love this channel.
18:31:23 <dolio> Whats :~>? Natural transformation?
18:31:27 <edwardk> dolio: yeah
18:31:52 <edwardk> dolio: i thought it read better. i had a couple of people ask me if Nats were numbers ;)
18:32:01 <dolio> Heh.
18:32:02 <edwardk> :~> at least looks arrow-like
18:32:07 <dolio> Yeah.
18:32:10 <roconnor> zygohistomorphic prepromorphisms?
18:32:15 <roconnor> @wiki zygohistomorphic prepromorphisms
18:32:15 <lambdabot> http://www.haskell.org/haskellwiki/zygohistomorphic_prepromorphisms
18:32:19 <roconnor> ah
18:32:27 <dmwit> It also looks like a devilishly happy guy with a broken nose. :~>
18:32:38 <edwardk> roconnor: heh
18:32:58 <dolio> @wiki plutonium atom totality theory
18:32:58 <lambdabot> http://www.haskell.org/haskellwiki/plutonium_atom_totality_theory
18:33:04 <atp> i think zygohistomorphic prepromorphisms should be what we respond when people ask how to do IO in haskell without monads from now on
18:33:06 <edwardk> roconnor: basically with category extras i took the basic foo- morphisms and abstracted out what they do
18:33:29 <edwardk> roconnor: then you can graft together the prefixes by using a bunch of distributive law combinators to build up whatever morphism you want.
18:35:07 <edwardk> zygo implements semi-mutual recursion like a zygomorphism. para gives you access to your result ala a paramorphism. the ones that make sense as (co)monad transformers get implemented as such, for instance there is a distributive law for ZygoT, which lifts a distributive law for the base comonad and adds a comonad reader transformer and uses a semi-mutual recursive helper function to break it down.
18:36:38 <edwardk> roconnor: i was able to prove that you can take the core construction for a paramorphism and modify a generalized catamorphism to make it 'paramorphic' by using transformers i write a lot less code than the approach where i just handcoded each case.
18:37:17 <roconnor> @wiki zygohistomorphic prepromorphisms
18:37:17 <lambdabot> http://www.haskell.org/haskellwiki/zygohistomorphic_prepromorphisms
18:37:22 <roconnor> better
18:37:34 <edwardk> lol
18:38:01 <roconnor> we can post it to programming.reddit.com now
18:38:06 <vixey> hehehe
18:38:20 <dolio> Now you're going to burn out haskell.org when all the google hits for that get redirected to the wiki.
18:38:22 <edwardk> heh, you'll get modded about as high as i see to get on programming.reddit.com ;)
18:38:33 <edwardk> er as i seem to get
18:39:59 <dolio> edwardk: You should try to tie twitter into your blog posts more. Then you'll get high ratings.
18:40:38 <edwardk> anyways zygohistomorphic_prepromorphism f = g_prepro (distZygoT (liftAlgebra f) (distHisto id)) -- unless you want a generalized zygomorphism.
18:41:56 <edwardk> zygohistomorphic_prepromorphism :: Algebra f b -> GAlgebra f (Cofree f) a -> (f :~> f) -> FixF f -> a
18:42:28 <edwardk> give it the semi-mutual recursive algebra, the generalized algebra for the histomorphic part and the natural transformation for the prepromorphism
18:42:30 <atp> have you been blogging about this stuff recently?
18:42:35 <edwardk> atp: comonad.com
18:42:37 <edwardk> there is quite a bit
18:42:42 <atp> i know you stopped submitting that stuff to proggit but you should do it anyway
18:42:49 <edwardk> if you go back about 15 posts i introduced chronomorphisms
18:43:20 <edwardk> i was planning on posting about prepro and postpro getting 'practical' implementations
18:43:29 <atp> sometimes i feel like the nerds on proggit really only want to read about stuff they already know and are allergic to anything that stretches their brains
18:43:37 <edwardk> yeah
18:43:52 <edwardk> i get pretty good feedback on math.reddit at least my kan extension stuff did
18:44:07 <atp> well those were very awesome and relatively accessible entries
18:44:28 <roconnor> edwardk: got it
18:44:30 <roconnor> @wiki zygohistomorphic prepromorphisms
18:44:31 <lambdabot> http://www.haskell.org/haskellwiki/zygohistomorphic_prepromorphisms
18:44:38 <atp> what does this wiki command do?
18:45:18 <atp> ah, it just returns the link
18:45:25 <edwardk> roconnor: import Control.Morphism.Zygo; import Control.Morphism.Prepro; import Control.Morphism.Histo; import Control.Functor.Algebra
18:45:31 <atp> i thought maybe it took a snapshot of what was being said in the irc channel and posted it on the wiki
18:45:34 <atp> that might not be a bad feature
18:45:44 <atp> it could always get cleaned up
18:45:45 <atp> later
18:46:10 <roconnor> edwardk: done
18:46:12 <Dzlk> Or it could make an edit page with the irc snapshot in the buffer.
18:46:33 <edwardk> oh and Control.Functor.Extras for :~> =)
18:46:52 <roconnor> edwardk: your posts are on my "someday understand" list.
18:47:01 <atp> Dzlk: that would be good too, but more difficult to do, since lambdabot can't make stuff appear in your browser :)
18:48:04 <atp> but to be honest, there are a lot of very interesting discussions that happen here that are essentially documented nowhere else
18:48:08 <edwardk> anyways it would appear that with Synchro out of the way i'm out of morphisms =)
18:48:17 <atp> you've got them all? :)
18:48:42 <edwardk> Yeah, I think I've got every recursion scheme I've ever seen in print and a lot that have never been talked about
18:48:47 <atp> :~> for natural transformations looks good in fonts where the tilde isn't up high
18:49:00 <atp> i like
18:49:58 <atp> edwardk: that's pretty awesome, really.  did you generate a bunch of new ones with your distributive law combinator?
18:50:07 <edwardk> interestingly i generalized all the histo and futu stuff to run over (co)density (co)monads of the (co)free (co)monad of the base functor rather than just the (co)free (co)monad, which seems to lead to nice properties
18:50:28 <atp> is this part of your research or just something you're doing for fun?
18:50:46 <sclv> http://www.haskell.org/haskellwiki/Real_World
18:50:47 <lambdabot> Title: Real World - HaskellWiki
18:51:02 <atp> zygohistomorphic prepromorhisms... that's really a mouthful :p
18:51:05 <edwardk> atp: well, the g_hylo is new, chrono subsumes dynamorphisms, and everything lower on the foodchain. the zygo, para, etc. transformers are new as far as they go
18:51:06 <roconnor> I like how we got Zygohistomorphic prepromorphisms documented on the wiki before catamorphism
18:51:13 <edwardk> roconnor: lol
18:51:45 <atp> that's because we all know what catamorphisms are already... it's less interesting than documenting stuff we don't all know
18:52:00 <atp> catamorphisms anamorphisms and hylomorphisms are all pretty basic fp stuff
18:52:03 <sclv> for some values of we all
18:52:05 <edwardk> atp: i'm a defense contractor. i don't actually get to play with this for a 'day job', so this is pretty much all for fun. i'm planning on writing some papers on the topic, since i'm still an academic at heart, but i'm not in publish or perish mode.
18:52:43 <atp> edwardk: nice.  it's a good hobby, and you're advancing all our understandings.  keep it up:)
18:53:04 <sclv> edwardk: if you go though and document and describe clearly with sample code, you could not only get some papers.. you could get a book.
18:53:09 <edwardk> atp: you realize category-extras started out as the standard library for my toy language right? =-)
18:53:16 <atp> i didn't actually
18:53:56 <atp> sclv: his blog posts are actually remarkably clear
18:54:05 <ddarius> sclv: That would be a really boring book.
18:54:06 <atp> sclv: read them with a paper and pencil
18:54:40 <edwardk> atp: i figured it would be funny to take and just assume the appropriate Ph.D's required for general purpose understanding of the principles behind everything and see what shook out as a library for an untyped language.
18:54:43 <sclv> atp: oh I know, but the library as a whole still isn't all there yet, because its in so much process.
18:55:01 <edwardk> sclv: yeah i do need to go through and document the bejeezus out of it
18:55:05 <dons> edwardk: is there a reason not to call category-extras just 'category'
18:55:13 <dons> since it seems to be pretty much *the* CT lib
18:55:22 <edwardk> dons: or categories?
18:55:40 <roconnor> are Strong Hylozygomorphism Trifunctor Transformations even real?
18:55:46 <edwardk> dons: not really other than the issue of how to move it in Hackage =)
18:55:53 <atp> roconnor: lol
18:55:53 <dons> well, it'd be a new package
18:56:10 <sclv> starting from the simpler stuff (including briefly, yes, cata, ana, etc) and building all the way up would be a really interesting book i actually think.
18:56:19 <atp> i agree with sclv
18:56:33 <atp> and ddarius is just being a curmudgeon, because very esoteric stuff seems to toot his horn
18:56:42 * atp pokes ddarius.
18:56:46 <edwardk> dons: to be quite honest the main reason its category-extras was because that was the name dolio and zednenem had been using. i just folded in the stuff that was in my comonad transformer library into it and kept building.
18:56:54 <dolio> It's too elementary for ddarius.
18:56:59 <ddarius> It would be fine a collection of papers, but it's too narrow for a book.
18:57:03 <atp> everything is too elementary for ddarius
18:57:39 <atp> most good math textbooks start out that way
18:58:06 <sclv> ddarius: not like a fancy maths books -- like a textbook/intro to applications of category theory concepts type book.
18:58:28 <ddarius> sclv: In that regard, it would be horrible.  Again, it's way too narrow.
18:58:29 <edwardk> right now i could really use a good coauthor for papers. I just have had little time to sit down and bring myself to wade through the academic publishing process.
18:58:31 <sclv> which would also be suggestive about how to think about it in day to day programming
18:58:34 <atp> i think even just a nice reference of recursion schemes would be cool.
18:59:02 <ddarius> sclv: It would be like a -chapter- of such a book.
18:59:02 <edwardk> atp: i'm planning on blogging at least a 'what does each of the distributive law combinators give me' post sometime soon
18:59:12 <sclv> ddarius: they have whole series of books just on regexps. seriously.
18:59:24 <atp> that's because kleene algebras are cool
18:59:36 <ddarius> sclv: No doubt full of various applications and regexes aren't a small field.
18:59:48 <hpaste>  mm_freak pasted "Handy MonadRef class (should be in base!)" at http://hpaste.org/8199
18:59:53 <sclv> as opposed to every recursion scheme ever?
19:00:50 <edwardk> mm_freak you forgot STM / TVar
19:00:58 <mrd> automata theory is a big field
19:01:11 <atp> edwardk: i definitely would enjoy reading such a blog entry
19:01:12 <mm_freak> edwardk: well, a lot of things are missing in base ;)
19:01:18 <ddarius> mm_freak: The idea has come up many, many times.
19:01:42 <edwardk> i think they are waiting for class associated types
19:01:54 <edwardk> coz the CAT version of that is nicer
19:01:59 <mm_freak> i'm always reinventing trivial things like 'whileM' or 'isqrt'
19:02:16 <ddarius> A good isqrt isn't trivial.
19:02:25 <mm_freak> but the idea is trivial
19:02:35 <atp> you can use newton's method
19:02:40 <dolio> You have to keep in mind that most papers on any particular recursion scheme are like 10 - 15 pages or so, and most of them introduce all the more elementary schemes leading up to the one the paper's about.
19:02:52 <dolio> So if you do them all at once, it's probably not a book.
19:03:04 <edwardk> yeah
19:03:15 <atp> it could be a short book.  alonzo church's seminal work was like what, 60 pages long?
19:03:19 <atp> 100 maybe?
19:03:25 <edwardk> though fokkinga got 120+ pages out of cata/ana/hylo/prepro and postpro ;)
19:03:28 <sclv> ddarius: much better therefore that we have a good one in base than everyone reinvents a "good-enough" one
19:03:46 <ddarius> sclv: I wasn't disagreeing.
19:04:07 <atp> the nice thing about a newton's method version of isqrt is that it stays in Q
19:04:18 <atp> unfortunately it's not very fast
19:04:22 <mm_freak> ddarius: if there were a bad implementation of 'isqrt' in base, the people would go and optimize the hell out of it, but since it isn't there, there are only a few niche projects
19:04:41 <atp> i know i've written various versions of isqrt
19:04:47 <atp> having it in base makes sense
19:05:14 <roconnor> it'd be nice if isqrt was bound to gmp
19:06:16 <mm_freak> atp: newton's method would be sufficient for a start…  you wouldn't call such a function from high performance code
19:06:34 <mm_freak> roconnor: that will probably never happen
19:06:50 <dolio> edwardk: Fokkinga's table of contents looks like he's got an entire introduction to category theory in there. :)
19:06:51 <atp> mm_freak: yeah.  and it can be generalized to any Integral
19:06:54 <roconnor> people say that and I've never understood why
19:06:57 <atp> mm_freak: it has some very nice properties
19:07:01 <ddarius> mm_freak: Why wouldn't it? It's the right way to go.
19:07:03 <roconnor> I mean + and * are bound to gmp.
19:07:26 <edwardk> dolio: it pretty much serves as an intro to category theory through the squiggol approach
19:07:27 <mm_freak> roconnor: the GHC developers would like to move away from GMP (because of licensing issues), and being more dependent on it would be counterintuitive =)
19:07:40 <roconnor> mm_freak: pfft not really
19:07:45 <atp> gmp is the best out there
19:07:51 <gubagem> whats the squiggol approach
19:07:54 <roconnor> if people are going to make a replacement for GMP, they can write a square root
19:08:12 * gubagem wonders who squiggol and gmp are
19:08:23 <atp> gmp is GNU Multi Precision
19:08:30 <roconnor> > 2^2^32 -- gmp at work
19:08:33 <atp> and squiggol is a programming language
19:08:36 <roconnor> er
19:08:38 <roconnor> too big
19:08:42 <mm_freak> gubagem: GMP is about the fastest library for bignum arithmetic
19:08:43 <lambdabot> Terminated
19:08:45 <edwardk> gubagem: its the name for the 'Bird-Meertens' formalism.
19:08:58 <roconnor> > 2^2^2
19:08:59 <lambdabot>  16
19:09:03 <roconnor> > 2^2^2^2
19:09:04 <lambdabot>  65536
19:09:06 <mm_freak> roconnor: 2^n is easy for GMP anyway
19:09:09 <atp> i believe there's a wiki entry on squiggol...
19:09:10 <dolio> It's a language designed to be good for algebraic reasoning about programs.
19:09:11 <roconnor> > 2^2^2^2^2
19:09:12 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
19:09:15 <mm_freak> > mod (3^10000) 17#
19:09:15 <lambdabot>   parse error on input `}'
19:09:16 <mm_freak> > mod (3^10000) 17
19:09:17 <edwardk> gubagem what it means in practice is you tend to write in pointfree style using explicit recursion combinators like cata/ana, etc.
19:09:18 <lambdabot>  1
19:09:20 <roconnor> ^^ GMP at work
19:09:28 <edwardk> its not a language so much as a notational convention.
19:09:31 <mm_freak> > mod (3^100000) 17
19:09:33 <lambdabot>  1
19:09:37 <mm_freak> > mod (3^1000000) 17
19:09:38 <lambdabot>  1
19:09:41 <mm_freak> > mod (3^10000000) 17
19:09:43 <atp> edwardk: you're right, i was confused.
19:09:45 <lambdabot>  1
19:09:49 <atp> not a programming language :)
19:09:49 <mm_freak> > mod (3^100000000) 17
19:10:03 <lambdabot> Terminated
19:10:04 <mm_freak> =)
19:10:14 <roconnor> 1
19:10:31 <dolio> gubagem: Function Programming with Bananas, Lenses ... gives a pretty good taste, if you're interested.
19:10:31 <gubagem> so squiggol is a decent thing to check out and ghc people just want to get away from gpl stuff
19:10:36 <edwardk> anyways its where a lot of our function names come from filter, inits, tails, map, fold, etc.
19:11:05 <dolio> Functional, even.
19:11:13 <edwardk> cata-, ana-, hylo-, and para- morphisms all come from one of the last major papers to strongly emphasize that style.
19:11:13 <atp> SQUIGOL
19:11:14 <atp> hehe
19:12:38 <hexpuem> How would you go about converting from one type to another using Data.generic? for example i need to convert Ints to GVInt for gtk
19:13:27 <mmorrow> love how with editline ghci just exits *all* the time
19:13:50 <mmorrow> if it wasnt for the new history there would be rage
19:13:52 <dolio> hexpuem: fromIntegral is what you'd use, I imagine.
19:14:09 <mmorrow> (on the topic of from gpl)
19:14:33 <hexpuem> well i want to be able to have the GUI table reflect on my datastructure and figure out which types to use itself
19:14:58 <hexpuem> since you can pull field names from the records with Data.generic all thats missing is the xxx -> GVxxx conversion
19:15:45 <gwern> @seen dcoutts
19:15:45 <lambdabot> dcoutts is in #xmonad, #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 4h 29m 9s ago.
19:16:39 <sclv> hexpuem: i don't understand?
19:17:15 <gwern> @ask dcoutts so I'm looking at some debian-related packages, and they all keep their license info in 'debian/copyright' and not 'LICENSE' or 'COPYING'. doing a 'license-file: debian/copyright' seems to fail: "copy debian/copyright to /home/gwern/bin/share/doc/MIME-1.2.8/debian/copyright Setup: /home/gwern/bin/share/doc/MIME-1.2.8/debian: copyFile: does not exist (No such file or directory)". is this a known problem?
19:17:15 <lambdabot> Consider it noted.
19:17:26 <sclv> GVint is a constructor. \x -> GVint x is how you apply it?
19:17:45 <hexpuem> yea
19:17:51 <hexpuem> but its not always going to be GVint
19:18:06 <hexpuem> it needs to reflect to see if it is going to make a GVint or GVString etc
19:18:18 <sclv> oh gotcha.
19:18:22 <sclv> use a typeclass
19:19:07 <sclv> class ToGV a where toGV :: a -> GenericValue
19:19:17 <sclv> instance ToGV Int where toGV = GVint
19:19:23 <hexpuem> yea good idea
19:19:28 <hexpuem> think im still missing something to get it working though
19:19:28 <hexpuem> haha
19:19:47 <hexpuem> can maybe use gmapQ
19:19:49 <sclv> on the other hand, with generics it gets a bit more complicated...
19:21:54 <sclv> you need to learn how to use extQ and friends
19:22:07 <hexpuem> k ill take a look, thanks
19:25:59 --- mode: irc.freenode.net set +o ChanServ
19:30:36 <vixey> > 1+1
19:30:37 <lambdabot>  2
19:31:01 <sclv> what's the convention with package names?
19:31:26 <sclv> some are StudlyCaps, some are alllower, is there any rhyme or reason?
19:31:33 <dons> almost all are lower case
19:31:43 <dons> looks better in .cabal files :)
19:31:59 <sclv> yeah, I've done it both ways and regret it.
19:32:02 <dolio> Be bold, make your packages all caps.
19:32:18 <dons> i regret XMonadContrib
19:32:54 <shachaf> dons: You mean the repository name?
19:33:02 <shachaf> Mine is xmonad-contrib locally. :-)
19:33:54 <sclv> dons: btw, is there a lightweight soap-lib kicking about galois that might be up on the list for opensourcing?
19:34:07 * sclv crosses his fingers without much expectation
19:35:30 <sclv> haifa just looks too crufty to salvage
19:36:22 <dons> soap, nah.
19:36:37 <dons> there are a couple of other things in the works, but not soap.
19:37:11 <dons> mightn't be too hard to roll one up on top of xml
19:37:38 <sclv> yep -- the spec is pretty huge for the whole deal, but I'll make do with a subset.
19:37:53 <dons> yeah, keep it in the flavour of say, the xml and json libraries. light, simple, easy.
19:38:05 <sclv> plus the model maps pretty terribly to functional languages anyway
19:39:09 <sclv> I was pondering using the galois xml lib more generally for what i'm working on, but I'm not sure if the complexity of hxt isn't worth it yet.
19:41:38 <gwern> ah, darn. bytestring has broken haxml, it seems
19:41:44 <gwern> 2
19:41:44 <gwern> 2src/Text/XML/HaXml/ByteStringPP.hs:27:74: Module `Data.ByteString.Lazy.Char8' does not export `join'
19:41:56 <roconnor> @go Cayley-Hamilton theorem
19:41:58 <lambdabot> http://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem
19:42:32 <dons> gwern: interesting. that's been deprecated for a year or so now. easy enough to fix -- use intercalate. send malcolmw a patch
19:43:28 <dolio> gwern: You should fix up collections to build on 6.8.
19:44:02 <dons> i didn't know haxml used bytestrings. interesting.
19:44:12 <dons> i wonder if you can get bytestrings all the way through haxml?
19:44:41 <gwern> dolio: eh? isn't collections one of the split-base packages? how does it not work on 6.8?
19:45:08 <gwern> dons: I have a theory the darcs haxml works and malcolm just hasn't released it to hackage yet
19:45:12 <gwern> (this was cabal-install)
19:45:28 <dolio> gwern: There's another collections on hackage, which has lots of classes and extra data structures (similar to edison, but modelled more on the stuff in the standard libs).
19:45:28 <dons> could be, could be.
19:46:16 <dolio> The 6.8 build log says stuff about hidden bytestring packages, so it probably needs to be updated to split base.
19:46:18 <gwern> man, I can't wait until more people start using hashed darcs repos, so repeated downloads would go so much faster
19:46:29 <dolio> Of course, it has a bad name now, too, I guess.
19:47:09 <gwern> dolio: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections right? any idea whether there/where is the darcs repo?
19:47:10 <lambdabot> http://tinyurl.com/63pbz5
19:47:28 <dolio> gwern: Dunno.
19:47:46 <gwern> @where collections
19:47:46 <lambdabot> I know nothing about collections.
19:48:00 <noecksit> hello, is Data.Function part of ghc-6.8 only?
19:49:26 <mmorrow> i believe so
19:49:49 <dolio> I guess Data.Collections.Foldable is somewhat obselete, too, although it looks slightly improved over the one in the standard libs.
19:50:02 <dolio> (Since it has null, among other things.
19:50:07 <sclv> http://code.haskell.org/collections/
19:50:08 <lambdabot> Title: Index of /collections
19:50:14 <sclv> gwern ^^
19:50:35 <gwern> thanx
19:52:26 <dolio> Hmm, some of that is already on hackage.
19:52:32 <dolio> COrdering, for instance.
19:52:36 <dolio> Maybe it's been split up.
19:53:34 <dolio> So is Data.Tree.AVL.
19:54:03 <gwern> sclv: why do you suppose it is split between 6.6 and 6.8?
19:54:32 <sclv> beats me
19:55:04 <dolio> They probably didn't bother to make a .cabal that builds on both 6.6 and 6.8.
19:56:59 <dolio> I don't see any obvious package names for collections-api on hackage, though.
19:57:38 <dolio> Which is what got me actually thinking about it, since Andrew Coppin was complaining about the lack of general collections interfaces in the standard libs.
19:58:40 <dons> he wasn't complaining was he? that seems unlikely.
19:59:11 <dolio> Well, call it what you want. I agree with him, more or less.
19:59:25 <dolio> We have folding/traversing covered pretty well, but there are a lot of gaps.
19:59:40 * sclv politely appreciates dons' wry humor.
19:59:57 <dons> more libraries!
20:00:00 <sclv> ?go ListLike
20:00:01 <lambdabot> http://software.complete.org/software/projects/show/listlike
20:00:01 <lambdabot> Title: ListLike - Overview - Software.Complete.Org
20:00:29 <dolio> collections covers a lot of the gaps.
20:00:30 <dons> i'm going to write a little post about haskell as a glue language this week. its all about libraries on hackage, and haskell as the glue for the data structure transformations between them
20:00:36 <dons> strongly typed glue. we're getting there.
20:00:58 <dons> i think we're almost at a point where the 'in the large' benefits are starting to appear, thanks to hackage
20:01:13 <dons> easy, safe, flexible composition/glue
20:02:24 <dolio> Of course, I don't know what algorithm you could be writing that uses lists that you want to translate to sets that wouldn't be covered by Foldable/Traversible/Monoid.
20:02:47 <dolio> That is, translate without rewriting anything.
20:03:48 <sclv> we really should bring a Pointed class into base...
20:07:11 <dolio> Yeah, that'd be one of the few things missing.
20:07:39 <dolio> Of course, Set couldn't be Pointed.
20:08:37 <sclv> why not?
20:08:48 <sclv> I thought the Ord constraint was only applied at a function level...
20:08:56 <dolio> Same problem as making it a Functor or Monad.
20:09:22 <sclv> ?hoogle Singleton
20:09:22 <lambdabot> Data.ByteString.singleton :: Word8 -> ByteString
20:09:22 <lambdabot> Data.Set.singleton :: a -> Set a
20:09:22 <lambdabot> Data.Sequence.singleton :: a -> Seq a
20:09:31 <dolio> Oh, wait, you're right.
20:09:54 <dolio> Well, good show, then.
20:13:37 <hpaste>  morrow pasted "steps (2 of them) to fix old arrow instances" at http://hpaste.org/8200
20:15:21 <mmorrow> slogging through hxt-8.0.0 now...
20:15:36 <mmorrow> (dep of yhcjs)
20:18:28 <dons> nice. the haskell.org front page is updating automatically now, as new packages are uploaded.
20:19:33 <dons> i wonder if i could generate a weekly summmary, and send it off to planet.haskell automatically.
20:20:23 <mmorrow> @pl \s x -> (s,[x])
20:20:23 <lambdabot> (. return) . (,)
20:25:32 <chessguy> whee
20:29:17 <TomMD> Yay, hsXenCtrl 0.0.5 is out the door - thats all the xenctrl.h bound (except just a couple fixme's).  Now for higher level fun!
20:36:30 <hpaste>  morrow pasted "hxt-8.0.0 diff to work with ghc6.9" at http://hpaste.org/8201
20:41:00 <byorgey> dons: if you're looking for someone to take over the HWN, I'd be willing.
20:41:06 <hpaste>  dogbite pasted "all subsets of a given size, using selection without repetition" at http://hpaste.org/8202
20:41:21 <dogbite> can anybody tell me if there's a better way to do that?
20:41:29 <dogbite> i feel like it's begging to use the list monad
20:41:38 <dogbite> or even a list comprehension
20:41:45 <dogbite> (same thing i suppose?)
20:42:06 <edwardk> hrmm, does anyone have a better name than Bind or Join for a class that includes just er... join?
20:42:35 <vixey> dogbite: map (take n) . permutations
20:42:49 <vixey> actually no' that wouldn't quite work
20:42:57 <edwardk> porting fokkinga's dyads to haskell (they are slightly weaker than the BiKleisli arrows I've been using)
20:43:17 <roconnor> > replicateM 2 [1..3]
20:43:19 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
20:43:27 <roconnor> mm
20:43:29 <roconnor> not quite
20:43:49 <dogbite> hmm
20:44:06 <dogbite> i don't know permutations
20:44:22 <dogbite> roconnor is close -- just has the repetitions in there
20:44:28 <dogbite> could maybe be filtered out...
20:44:51 <vixey> not if the input had reptitions
20:44:55 <roconnor> > filter (\x -> length x == 2) . permutations $ [1..3]
20:44:56 <lambdabot>   Not in scope: `permutations'
20:45:11 <roconnor> not efficent
20:45:19 <dogbite> right assume the input has no repeititions
20:45:26 <byorgey> dogbite: that looks pretty good, but I'd make a few changes
20:45:33 <dogbite> byorgey: shoot
20:45:41 <byorgey> dogbite: for one thing your code will not work on infinite lists, because of the length check
20:45:50 <byorgey> so it would be nice if it were lazier
20:46:29 <dogbite> the (++) makes it sorta non-lazy?
20:46:39 <byorgey> hm, I guess I'd have to think about the best way to do that a little harder
20:46:57 <byorgey> dogbite: anyway, another trivial observation is that you can write (c:) instead of \g -> c:g  =)
20:47:03 <roconnor> dogbite: it isn't the ++, it is the call to length
20:47:04 <dogbite> i feel like it's begging to use tails too
20:47:08 <dons> byorgey: yeah, i'll send you an email with details.
20:47:15 <dons> i'd be happy for you to take over!
20:47:19 <newsham> > length [1..]
20:47:22 <lambdabot> Terminated
20:47:24 <byorgey> dons: ok, cool =)
20:47:33 <dogbite> ah, length yes
20:47:35 <dons> byorgey: there's repos and scripts, i'll summarise everything for you tomorrow.
20:47:39 <newsham> > [1,2,3] ++ [5..]
20:47:40 <lambdabot>  [1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:47:50 <byorgey> dons: yeah, I thought you had some nice scripts for it, awesome
20:47:52 <dons> the big thing, i think, is to think about how to automate more aspects of it, or the burden gets too great.
20:48:01 <dogbite> newsham: i gotcha... cool
20:48:03 <byorgey> dons: for sure.
20:48:26 <TomMD> A thought: Filtering the packages so that new versions of the same package don't clutter things.
20:48:28 <byorgey> I was already thinking along those lines, I'm glad to hear I won't have to start from scratch =)
20:48:32 <dogbite> byorgey: thanks -- yeah, (:) can be used, good point
20:48:35 <dons> TomMD: on the front page?
20:48:39 <hpaste>  ianbentley pasted "interface" at http://hpaste.org/8203
20:48:43 <TomMD> Ex: I have released many versions of hsXenCtrl and they are cluttering the page.
20:48:45 <TomMD> dons: Yes.
20:48:52 <dons> ok, that's easy enough.
20:48:59 <dons> i'll just nub them on the package name
20:49:23 <TomMD> sounds good, so long as the list being nubbed is only what appears on the front page (not for all time)
20:49:32 <dons> yep.
20:49:44 <dolio> > let foo 0 l = [[]] ; foo x [] = [] ; foo n l = [ x:ys | (x:xs) <- tails l, ys <- foo (n-1) xs ] in foo 11 [1..10]
20:49:45 <lambdabot>  []
20:49:45 <dons> its just a tiny bit of glue code between tagsoup and the feed library siggy wrote
20:49:49 <dons> easy to tweak
20:49:50 <dolio> > let foo 0 l = [[]] ; foo x [] = [] ; foo n l = [ x:ys | (x:xs) <- tails l, ys <- foo (n-1) xs ] in foo 10 [1..10]
20:49:52 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10]]
20:49:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8204
20:50:00 <dolio> > let foo 0 l = [[]] ; foo x [] = [] ; foo n l = [ x:ys | (x:xs) <- tails l, ys <- foo (n-1) xs ] in foo 9 [1..10]
20:50:01 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,10],[1,2,3,4,5,6,7,9,10],[1,2,3,4,5,6,...
20:50:10 <dons> it updates the front page once an hour, fwiw
20:50:29 <hpaste>  byorgey annotated "all subsets of a given size, using selection without repetition" with "some code I wrote once to do the same thing, for comparison -- very similar" at http://hpaste.org/8202#a1
20:50:45 <dolio> > let foo 0 l = [[]] ; foo x [] = [] ; foo n l = [ x:ys | (x:xs) <- tails l, ys <- foo (n-1) xs ] in foo 9 [1..]
20:50:46 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,10],[1,2,3,4,5,6,7,8,11],[1,2,3,4,5,6,...
20:51:08 <byorgey> dogbite: upon further reflection, though, even though my version is 'lazy enough' (I don't call length), it still doesn't work well on infinite lists
20:51:16 <hpaste>  (anonymous) annotated "all subsets of a given size, using selection without repetition" with "(no title)" at http://hpaste.org/8202#a2
20:51:24 <byorgey> dogbite: since you don't get every choice at a finite index
20:51:36 <dogbite> byorgey: wow lok at that code!
20:51:50 <byorgey> i.e. choose 3 [1..]  gives you [1,2,3], [1,2,4], [1,2,5], [1,2,6], [1,2,7] ...
20:52:22 <dolio> Just use that diagonalization monad. :)
20:52:28 <dogbite> byorgey: yes but on finite lists, does it work?
20:52:56 <dogbite> byorgey: when 'n' exceeds the size of the tail or list
20:52:58 <byorgey> dogbite: sure.
20:53:20 <tsuwabuki> [[1,2,x]|x<-[3..]]
20:53:25 <roconnor> dogbite: it works because of choose _ [] = []
20:53:28 <hpaste>  morrow pasted "need mkTag implem to get pgbuild to work" at http://hpaste.org/8205
20:53:41 <roconnor> dogbite: if you choose to much you end up doing map (map (map .... [])
20:53:50 <roconnor> dogbite: which is just []
20:54:14 <dogbite> oh, i see.  yes
20:54:32 <dogbite> okay well that's brilliant then.  the base case is cleaner too
20:54:36 <mmorrow> does anyone happen to be super-familiar with hxt-8.0.0 and could help with a simple implem of mkTag: http://hpaste.org/8205#a0 ?? Thanks. This is last obstacle to get pgbuild working with hxt-8.0.0 and ghc6.9
20:54:40 <vixey> @src sequence
20:54:40 <lambdabot> sequence []     = return []
20:54:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:54:40 <lambdabot> --OR
20:54:40 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:55:00 <roconnor> byorgey: how do we turn that code into a hylozygowhatevermorphism?
20:55:01 <mmorrow> i have never used hxt and can't figure it out
20:55:13 <dogbite> choose is a better name
20:55:17 <byorgey> roconnor: hmm, excellent question
20:55:18 <dogbite> due to the math
20:55:36 <roconnor> choose is quite a good name.
20:55:36 <dogbite> thanks all -- that's a lot of help
20:55:44 <bos> dons: i'm reinstalling ghc now
20:55:57 <roconnor> @seen edwardk
20:55:58 <lambdabot> edwardk is in #haskell. I last heard edwardk speak 13m 1s ago.
20:56:06 <dogbite> i guess only problem with choose -- and i suppose why i avoided it
20:56:10 <dogbite> is it collides a lot
20:56:11 <dons> bos: oh, it was your playing around with different versions of things?
20:56:26 <bos> dons: not afaik, just trying to cover the bases
20:56:28 <dogbite> i'm looking at the probabilistic functional programming package
20:56:30 <edwardk> roconnor: heya
20:56:37 <dons> ok. i suspect just an update clash between old and new bytestrings.
20:56:46 <bos> yes.
20:56:56 <roconnor> edwardk: how do we turn http://hpaste.org/8202#a1 into a zygohylowhatevermorphism?
20:56:57 <vixey> what do you mean collides?
20:57:10 <byorgey> dogbite: you could also use the name 'selectACertainNumberOfThingsWithoutRepetitionFromThisList'  =)
20:57:13 <dogbite> just that choose is also in that PFP module, etc
20:57:33 <dogbite> byorgey: yeah but i don't have visual studio for haskell yet
20:57:39 <mmorrow> if it helps, here are the haddock docs i just gen (w/ haddock 2.1.0): http://morrow.jypsis.com/hxt-8.0.0/
20:57:42 <byorgey> haha!
20:57:49 <edwardk> roconnor: usually? sick a graduate student on it, and tell them they can get their Ph.D dissertation on the topic ;)
20:58:03 <dons> bos, ping me when its ready to go, i'm done here, and want to commit the chapter to beta.
20:58:13 <mmorrow> (pgbuild is the page builder for yhcjs)
20:58:35 <hpaste>  ianbentley pasted "(no title)" at http://hpaste.org/8206
20:58:35 <byorgey> edwardk: haha =)
20:58:36 <edwardk> roconnor: that said, hrmm, translating choose wouldn't be too hard
20:59:08 <SamB_XP> edwardk: that sounds HORRIBLY inefficient
20:59:21 <edwardk> samb: meh, graduate students are cheap ;)
20:59:59 <SamB_XP> you blow a phd student on each hpaste-sized supercalafragilisticexpialamorphism?
21:00:21 <dons> what was SPJ's joke about loading another grad student into his shotgun?
21:00:22 <bos> dons: it's built now. you might want to go into book/tools and make clean
21:00:29 <dons> ok. will do. cheers, bos.
21:00:33 <bos> np
21:00:36 <edwardk> samb: i never said that i -used- this formalism did i? =)
21:01:07 <SamB_XP> SPJ doesn't even want a PhD...
21:01:18 <edwardk> besides i'm unlikely to be blowing phd students any time soon. unless they really don't like me and are holding a gun to my head.
21:01:22 <bos> i finally thought of a decent parallel strategies example.
21:01:29 <TomMD> SamB_XP: What do you mean?
21:01:35 <SamB_XP> edwardk: not that kind of blow
21:01:45 <hpaste>  morrow annotated "need mkTag implem to get pgbuild to work" with "not xhtml funcs (ie not trivial)" at http://hpaste.org/8205#a1
21:02:01 <SamB_XP> TomMD: he doesn't want to be known as Dr. Jones...
21:02:10 <hpaste>  ianbentley pasted "(no title)" at http://hpaste.org/8207
21:02:25 <edwardk> samb: especially after that last movie
21:02:34 <dons> bos, woot! that's good news.
21:02:56 <TomMD> is it somehow using bloomfilters? ;-)
21:03:08 <bos> dons: using concurrent haskell to chunk a huge bytestring, then parallel map followed by a fold to reduce.
21:03:30 <bos> why did it take me so frickin long to think of *mapreduce* as an example in a book about functional programming?
21:03:39 <dons> HAH.
21:03:47 <dons> yeah, buzz word friendly and all
21:03:50 * dons smacks head
21:04:02 <SamB_XP> hhehehe
21:04:04 <edwardk> anyone have a nice name for a monad sans 'return'? or a comonad sans 'extract'?
21:04:10 <bos> it's like, what, only the world's best known functional programming example. after fib.
21:04:20 <edwardk> i need something to call 'half of a dyad' so i can make the typeclasses work
21:04:27 <SamB_XP> bos: probably BEFORE fib
21:04:31 <deli2323> You could make a type that is parameterized by another type.
21:04:40 <deli2323> say, data modularRing Int
21:04:44 <SamB_XP> fib doesn't even use HOFs
21:04:45 <dons> bos, "concurrent haskell to chunk a huge bytestring"
21:04:48 <SamB_XP> it's a lousy example
21:04:52 <TomMD> But there is no mapReduce 'hadoop' equivalent written in a functional language!
21:04:54 <dons> i wonder if you could load a lazy bytestring and 'toChunks' it?
21:05:11 <deli2323> then, you could instantiate  the ring with an integer
21:05:13 <deli2323> such as
21:05:16 <bos> SamB_XP: that was what my people term a "joke"
21:05:19 <deli2323> data mod7 = modularRing 7
21:05:23 <TomMD> I brought this up in #Erlang thinking that would be the ideal language for such a task (not that I know erlang).
21:05:29 <dons> toChunks :: ByteString -> [S.ByteString]
21:05:29 <dons> toChunks cs = foldrChunks (:) [] cs
21:05:30 <SamB_XP> bos: oh
21:05:40 <SamB_XP> maybe your people should practice being funny ?
21:05:42 <dons>  free chunking?
21:05:42 <bos> dons: i think the chunk size might be too arbitrary.
21:06:12 <dons> well, it'll depend on what's been done to the bytestring. it'll be cache sized if just loaded from a file
21:06:14 <hpaste>  ianbentley pasted "dhclient ath0" at http://hpaste.org/8208
21:06:38 <dons> interesting idea though. free parallel bytestrings
21:06:43 <bos> dons: what i specifically had in mind was taking a Handle representing a file, seeking to offsets of a few hundred MB into it and finding the nearest newline boundary, then reading from those offsets as ByteStrings to give a list of chunks.
21:06:51 <dons> ah right.
21:07:15 <dons> hmm. parallel sum-file on the shootout could be done that way
21:07:18 <bos> the problem with the 64KB chunk boundary is that it doesn't map to anything in particular.
21:07:24 <dons> parMap over file chunks, fold to sum
21:07:31 <deli2323> Can anyone tell me the correct way to parameterize a type in haskell?
21:07:34 <dons> yep. i see.
21:07:35 <bos> in fact, i wrote the file chunking code months ago
21:07:42 <dons> deli2323: data T a = T a -- parameterised type
21:07:48 <bos> i love examples that i can just dust off and reuse.
21:07:58 <dons> yeah. that's good.
21:08:20 <bos> now i need to just, er, find it.
21:09:25 <deli2323> dons: thanks.  So say a is Int.  Then you could have T 7 and T 6 be different types?  Maybe have T7 = T7 ?
21:09:34 <deli2323> Haskell is sweet.
21:09:54 <vixey> you can't use values to index types
21:10:01 <bos> @hoogle fix
21:10:01 <lambdabot> Data.Function.fix :: (a -> a) -> a
21:10:01 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
21:10:01 <lambdabot> Control.Monad.Fix :: module
21:10:03 <hpaste>  (anonymous) annotated "interface" with "(no title)" at http://hpaste.org/8203#a1
21:10:03 <vixey> but if you have a type named Seven, then T Seven is fine
21:10:04 <roconnor> at least not in Haskell.
21:10:08 <bd_> deli2323: Unfortunately dependent types aren't supported in haskell yet :)
21:10:15 <vixey> yet? :p
21:10:38 <vixey> what's this peirces law about ((a -> b) -> a) -> a  ?
21:10:46 <vixey> who would ever think that's true
21:10:47 <ddarius> :t callCC
21:10:47 <bd_> deli2323: You could make a data Zero; data Succ n; and do things like T (Succ (Succ (Succ (Succ (Succ (Succ (Succ n)))))))
21:10:48 <edwardk> vixey: sure, figure out a type inference algorithm for them in general, solve the halting problem, and i'm sure they'll implement it ;)
21:10:49 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:10:58 <ddarius> vixey: It is true in classical logic.
21:11:22 <vixey> edwardk: all the fun programming is in types anyway, why take away the good bit :p
21:11:26 <vixey> it doesn't make sense to me
21:11:54 <vixey> I suppose any derivation of ((a -> b) -> a) -> a will have to use excluded middle or something equivalent then?
21:12:00 <byorgey> note, in classical logic we must have either a or (not a).
21:12:14 <bd_> deli2323: actually, I did read a paper on how to encode an arbitrary value into a haskell type... let me dig it up
21:12:19 <ddarius> vixey: Assuming Pierce's law is equivalent to assuming excluded middel.
21:12:22 <vixey> oh is it that
21:12:26 <vixey> a -> b isn't provable
21:12:30 <dons> ah, you want number-paramaterised types
21:12:36 <vixey> so clearly ~(a -> b)
21:12:38 <dons> not type-paramaterised types :)
21:12:49 <byorgey> if (not a), then (a -> b) is true, so ((a -> b) -> a) is false.
21:12:50 <bd_> deli2323: http://okmij.org/ftp/Haskell/types.html#Prepose a bit high level, but you might find it interesting (if confusing!)
21:12:51 <lambdabot> Title: Haskell Programming: Types
21:13:18 <roconnor> @djinn ((a -> b) -> a) -> a -> Either (not (not a) -> a) (not (not b) -> b)
21:13:21 <lambdabot> f _ a = Left (\ _ -> a)
21:13:26 <roconnor> oops
21:13:34 <roconnor> @djinn (((a -> b) -> a) -> a) -> Either (not (not a) -> a) (not (not b) -> b)
21:13:34 <lambdabot> -- f cannot be realized.
21:13:37 <ddarius> Not
21:13:38 <byorgey> hence if we have ((a -> b) -> a), we must have a (by the LEM).
21:13:39 <roconnor> :/
21:13:40 <ddarius> not is a variable
21:13:49 <roconnor> @djinn (((a -> b) -> a) -> a) -> Either (Not (Not a) -> a) (Not (Not b) -> b)
21:13:49 <lambdabot> -- f cannot be realized.
21:14:30 <vixey> > let True >> True = True ; False >> _ = True ; _ >> _ = False in map (\(a,b) -> ((a >> b) >> a) >> a) [(True,True),(True,False),(False,True),(False,False)]
21:14:31 <lambdabot>  [True,True,True,True]
21:14:36 <vixey> I suppose that is the proof there?
21:14:43 <hpaste>  (anonymous) annotated "dhclient ath0" with "(no title)" at http://hpaste.org/8208#a1
21:14:43 <vixey> since P \/ ~P
21:14:43 <roconnor> @djinn ((Not (Not a) -> a),(Not (Not b) -> b)) -> (((a -> b) -> a) -> a)
21:14:43 <ddarius> vixey:  http://www.thenewsh.com/~newsham/formal/curryhoward/
21:14:44 <lambdabot> f (a, _) b = a (\ c -> void (c (b (\ d -> void (c d)))))
21:14:45 <lambdabot> Title: The Curry-Howard Correspondence in Haskell
21:14:52 <byorgey> vixey: indeed.
21:15:21 <bos> hm, do i introduce unsafeInterleaveIO here?
21:18:51 <vixey> so classical logic can be embedded in a monad? the callcc one
21:19:11 <ddarius> Yes.
21:19:11 <Saizan_> yeah
21:19:21 <ddarius> Proving excluded middle is interesting.
21:19:29 <ddarius> That link above goes through all this.
21:19:32 <Saizan_> Cont r a corresponds to Not (Not a)
21:19:44 <vixey> yeah it' is interesting
21:19:51 <ddarius> (Although I don't think it discusses callCC <=> Pierce)
21:20:18 <hpaste>  (anonymous) annotated "dhclient ath0" with "(no title)" at http://hpaste.org/8208#a2
21:20:56 <deli2323> dons.
21:21:02 <vixey> another nice one here is (~p -> p) -> p, reductio ad absurdum
21:21:05 <deli2323> I think you're right. Number Parameterized types.
21:21:08 <deli2323> How do you do it?
21:21:30 <vixey> deli2323: Why do you want to parameterize on a number?
21:21:41 <bd_> deli2323: did you read that paper I linked? There's a nice example in it :)
21:22:00 <bd_> wait, that's not the paper itself
21:22:03 <bd_> hmm where was it
21:22:16 <ddarius> vixey: That's Peirce's law again.
21:22:21 <dons> pretty tricky. you'd be able to use the http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-int or http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level libs, if you're into serious bounds checking fun in types
21:22:23 <lambdabot> http://tinyurl.com/5ubxbb
21:22:34 <deli2323> vixey: Modular arithmetic is one example.
21:22:53 <dons> check ou tthe type-* libs for numbers-in-types programming fun.
21:22:58 <dons> you'll be able to write a paper about it afterwards
21:23:02 <deli2323> Languages less sweet than haskell often force you to think of modular arithmetic as first taking place "in the integers"
21:23:03 <bd_> grr
21:23:07 <bd_> I had the link to it...
21:23:14 <deli2323> and then "reducing" via the modulus.
21:23:27 <byorgey> deli2323: you can also use a dependently typed language, which allow values in types very naturally.  I'd recommend Agda2 since it has many similarities to Haskell.
21:24:06 <bd_> deli2323: http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf modular arithmetic is exactly the example they use :)
21:24:10 <deli2323> In haskell, you should be able to think of multiplication as a binary operation on the type, say mod7.
21:24:22 <deli2323> bd_: thanks
21:24:28 <hpaste>  (anonymous) annotated "dhclient ath0" with "(no title)" at http://hpaste.org/8208#a3
21:24:55 <mmorrow> > nub . fmap (`mod`7) $ [0..]
21:25:00 <lambdabot>  [0,1,2,3,4,5,6
21:25:12 <Saizan_> is hpaste being used as the #debian pastebin?
21:25:45 <bd_> they have their own, in theory
21:26:37 <mmorrow> the field Z_p, p=7
21:27:20 <mmorrow> i dunno how to best typify that though..
21:27:37 * byorgey convinced some math professors to try Haskell today! =D
21:28:03 <mmorrow> byorgey: nice!
21:29:08 <ddarius> byorgey: To do what kind of things?
21:29:34 <byorgey> ddarius: exploratory number theory, maybe some other stuff
21:31:48 <vixey> @src Num
21:31:49 <lambdabot> class  (Eq a, Show a) => Num a  where
21:31:49 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:31:49 <lambdabot>     negate, abs, signum     :: a -> a
21:31:49 <lambdabot>     fromInteger             :: Integer -> a
21:34:20 <deli2323> dons: those libraries seem pretty heavy.  For now would it be easier just to read the paper that bd_ linked and follow that construction?
21:34:56 <Saizan_> deli2323: probably yes
21:35:03 <dons> i'm not sure , actually, what the lightest way to get type level integers is. probably Oleg's.
21:35:12 <dons> there's a wiki intro i wrote a while back, let me find it
21:35:20 <bd_> oleg's is the one I linked :)
21:35:35 <dons> http://haskell.org/haskellwiki/Smart_constructors#Compile-time_checking_:_the_type_system
21:35:37 <lambdabot> Title: Smart constructors - HaskellWiki, http://tinyurl.com/jx22g
21:35:50 <dons> shows how to do some basic math in the type system to enforce numeric constraints
21:36:04 <dons> a simplified variants of oleg's type level decimals
21:36:18 <dons> there's likely nicer ways now with type families, i suspect
21:36:39 <sjanssen> deli2323: why can't the libraries be heavy?  It's a library, so you don't have to worry about it :)
21:37:44 <Saizan_> sjanssen: having a clue about how the class hackery works will help with error messages, though
21:37:49 <edwardk> dons: most of the nice ways with type families need total type families iirc
21:37:56 * byorgey `ap` bed
21:37:58 <byorgey> night all!
21:38:01 <dons> night byorgey
21:38:45 <hpaste>  vicky pasted "probably *not* what you wanted" at http://hpaste.org/8210
21:38:54 <vixey> deli2323: well I tried it out..
21:40:30 <deli2323> yeah?
21:40:49 <deli2323> bedtime for deli2323
21:41:00 <vixey> deli2323: that's what I got http://hpaste.org/8210
21:41:00 <deli2323> I can't go without hearing from vixey though.
21:41:06 <Saizan_> vixey: that's almost like that oleg's paper :)
21:42:09 <deli2323> Woah.  So did it work?
21:42:19 <vixey> well test gives the result 1
21:42:30 <vixey> which is 7 + 8 mod 2 (S (S Z)) stands for 2
21:43:18 <vixey> Saizan, just looking at the paper now... he even called it unM (where I called mine unZ) ;s
21:44:27 <deli2323> well this is very exciting for me.  It must wait until morning though for more thought.
21:44:38 <deli2323> I have marked your references and I appreciate all your hlep.
21:44:42 <hpaste>  ianbentley annotated "interface" with "wpasupp.conf" at http://hpaste.org/8203#a2
21:44:45 <deli2323> s/hlep/help/
21:44:48 <deli2323> good night.
21:44:55 <vixey> night
22:01:20 <dmwit> Haskell has the lowest salaries. =/
22:01:24 <dmwit> http://theunixgeek.blogspot.com/2008/06/programming-salaries.html
22:01:25 <lambdabot> Title: The Unix Geek: Programming Salaries
22:01:28 <dons> hehe, no...
22:01:32 <dons> use "haskell programmer"
22:01:38 <dons> otherwise you get the town of haskell
22:01:53 <dmwit> Okay, Haskell programmers get the lowest salaries.
22:02:06 <sjanssen> dmwit: several things seem fishy about those results
22:02:10 <dons> no, not quite.
22:02:31 <dons> http://www.indeed.com/salary?q1=haskell+programmer&l1=&tm=1
22:02:31 <lambdabot> Title: haskell programmer Salaries - Free Salary Search
22:02:43 <sjanssen> for example Objective C vs. Mac OS X vs. Cocoa
22:03:06 <sjanssen> why so much disparity when they'd almost certainly be used simultaneously?
22:03:06 <adu> hollly crap!
22:03:09 <adu> wow!
22:03:17 <vixey> hi adu :)
22:03:21 <adu> I want a haskell job for sure now~!
22:03:22 <dons> sjanssen: the town of haskell screws up results?
22:03:39 <adu> hi vixey
22:03:46 <adu> vixey: how are you today?
22:04:05 <sjanssen> dons: I'm talking about the OS X results (OS X is the only environment that uses Objective C AFAIK)
22:04:17 <adu> sjanssen: and GNUstep
22:04:21 <sjanssen> dons: but yeah, even "haskell programmer" might only turn up programmers for the town of Haskell, TX
22:04:41 <sjanssen> adu: and how many paying jobs use GNUstep?
22:04:49 <adu> sjanssen: hmm...
22:04:53 <dons> yeah, its all pretty silly
22:05:55 <sjanssen> dons: "haskell programmer" is off the charts!
22:06:16 <sjanssen> http://www.indeed.com/salary?q1=haskell+programmer&l1=&tm=1
22:06:17 <lambdabot> Title: haskell programmer Salaries - Free Salary Search
22:06:44 <dons> yeah, that matches my expectation, more accurately.
22:06:50 <sjanssen> that high?
22:07:15 <dons> finance jobs.
22:07:15 <vixey> so what sort of things does a haskell programmer do?
22:07:49 <dons> vixey: programming in haskell, mostly.
22:07:50 <sutats> If I have <f :: String -> (String, String)> and I want to pass the result of readFile in as an argument to f, what do I need to do?
22:07:51 <adu> vixey: gaming
22:08:12 <dons> sutats: do x <- readFile "foo" ; print (f x)
22:08:13 <adu> vixey: and cryptoggraphy
22:08:15 <dons> something like that?
22:08:21 <adu> vixey: and telecommunications
22:08:30 <sutats> dons: Yeah, I think that looks right, thanks.
22:09:14 <adu> vixey: and not to mention, possibly getting paid to work on darcs if its being used for another project, and people need someone to add features that will let them work with darcs and their other projects...
22:09:33 <shachaf> sutats: f <$> readFile "f"?
22:09:36 <vixey> I am thinking about what I could do it's hard, I don't think I would do games or crypto or telecommunications :[
22:10:08 <sutats> shachaf: Oh, does that work too? I like that form better.
22:10:28 <hpaste>  morrow annotated "probably *not* what you wanted" with "beyond monoids..." at http://hpaste.org/8210#a1
22:10:45 <shachaf> sutats: That has type FilePath -> IO (String,String)
22:11:04 <vixey> morrow: so we need to have an instance Prime x for every x that is prime?
22:11:13 <vixey> or p^n or whatever
22:11:26 <shachaf> Just IO (String,String), rather.
22:11:44 <shachaf> If you give it the argument.
22:12:12 <sutats> shachaf: Is that functionally equivalent to the method dons posted?
22:12:24 <hpaste>  morrow annotated "probably *not* what you wanted" with "silly me" at http://hpaste.org/8210#a2
22:12:39 <shachaf> Sure, (<$>) = fmap, which is liftM.
22:12:42 <shachaf> @src liftM
22:12:43 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:13:11 <sutats> shachaf: Hm, thanks, let me take a closer look at that.
22:15:35 <hpaste>  morrow annotated "probably *not* what you wanted" with "3/5 = 2" at http://hpaste.org/8210#a5
22:17:23 <sutats> shachaf: If I wanted to use <$> in ghci, do I need to do something first?
22:17:37 <shachaf> :m + Control.Applicative
22:19:22 <nolrai_> @unmtl ReaderT Board (ListT (State (Set ((Int, Int), Direction)))) t
22:19:22 <lambdabot> Board -> Set ((Int, Int), Direction) -> ([t], Set ((Int, Int), Direction))
22:20:48 <mmorrow> vixey: hmm, my first thought is to have a collection of types representing the elts of Z_p (==[0..p-1]), then some container for those (like a class or a gadt or ?) and then i dunno
22:21:03 <nolrai_> :t (lift . lift) return
22:21:05 <lambdabot> forall (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) a (m :: * -> *). (Monad m, MonadTrans t1, Monad (t1 ((->) a)), MonadTrans t) => t (t1 ((->) a)) (m a)
22:21:46 <nolrai_> :t lift return
22:21:48 <lambdabot> forall a (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => t ((->) a) (m a)
22:22:32 <nolrai_> :t lift
22:22:34 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
22:23:01 <vixey> mmorrow: If you could possibly have 0 :: Z n (for any n at all), the 1 :: Z (S n) for any n.. and so on, then you can always be sure that Z x has exactly x elements, I have no idea how that could be coded though
22:23:02 <mmorrow> vixey: i guess a way would be to have a class ToInt a where toInt :: a -> Int, a bunch of empty data decs, use toInt to get (undefined::SomeNum) -> Int, do the calc in Int(eger), the unsafeCoerce undefined to the correct type somehow
22:23:18 <sutats> shachaf: I'm a tad confused: "liftM f $ readFile path" works, but "f <$> readFile path" doesn't.
22:23:34 <shachaf> sutats: Did you import Control.Applicative?
22:23:45 <shachaf> Does "fmap f $ readFile path" work?
22:24:03 <mmorrow> vixey: but that assumes the unsafeCoerce way out (which in this case should be perfectly safe) is acceptable
22:24:19 <vixey> I don't mind unsafeCoerce
22:24:28 <vixey> I'm not sure it's the only way though
22:24:34 <sutats> shachaf: The fmap version works, and I did import Control.Applicative.
22:24:44 <sutats> shachaf: It's expecting String, when it's inferring IO String
22:25:02 <shachaf> That's odd. Perhaps this is some sort of precedence problem?
22:25:19 <mmorrow> vixey: oh i'm sure it's definitely not the *only* way, just *a* way. hmm, gotta think about it, be back in a bit though:)
22:26:00 <sutats> shachaf: Ah, yes, good catch. That was the issue.
22:26:54 <nolrai_> :t (lift . return)
22:26:56 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) a. (Monad m, MonadTrans t) => a -> t m a
22:29:10 <nolrai_> Is there a way to turn a "[a]" into a "ListT m a"?
22:30:09 <vixey> @src ListT
22:30:09 <lambdabot> Source not found. It can only be attributed to human error.
22:30:18 <Heffalump> ListT . return ?
22:30:27 <Heffalump> @type ListT . return
22:30:29 <lambdabot> Not in scope: data constructor `ListT'
22:30:34 <Heffalump> @type Control.Monad.List.ListT . return
22:30:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> Control.Monad.List.ListT m a
22:31:05 <nolrai_> this is me in awe.
22:32:08 <nolrai_> :t (lift . Control.Monad.List.ListT . return)
22:32:10 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a. (Monad m, MonadTrans t) => [a] -> t (Control.Monad.List.ListT m) a
22:32:22 <nolrai_> nice.
22:42:33 <nolrai_> :t Control.Monad.Reader.runReaderT
22:42:35 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
23:13:48 <hpaste>  morrow annotated "probably *not* what you wanted" with "solution(ish) with type families" at http://hpaste.org/8210#a6
23:16:50 <dons> i wish we could tag thiiiings on hpaste
23:16:57 <dons> tagged as 'type families'
23:21:59 <hpaste>  morrow annotated "probably *not* what you wanted" with "and class for Zp" at http://hpaste.org/8210#a7
23:27:28 <mxc_> dons - not sure where to put this on your site, but are you planning on covering CPS or FRP in your book?
23:27:55 <mxc_> though, I have started putting in (most likely lame and ill-informed) comments on the beta site
23:28:45 <mxc_> i guess FRP might go in under GUI programming
23:28:49 <tsuwabuki> What is CPS abbreviation?
23:28:59 <bos> mxc_: neither.
23:28:59 <mxc_> continuation passing style
23:29:08 <mxc_> bos = brian o'sullivan?
23:29:14 <bos> bryan, yes.
23:29:21 <mxc_> ah
23:29:43 <mxc_> it took me a while to realize that the mercurial manual author and one of the RWH authors were the same person
23:30:03 <mxc_> anyway, it looks fantastic so far, pretty eager to buy it when it comes out
23:30:04 <bos> heh.
23:30:25 <mxc_> i guess its because I kind of assumed that its was dogmatic that haskellers need to use darcs
23:30:37 <mxc_> (but i like hg, so i'm glad you wrote the manual)
23:31:18 <mxc_> and the idea of a public beta for a book is fantastic
23:31:30 <hpaste>  morrow annotated "probably *not* what you wanted" with "it works!" at http://hpaste.org/8210#a8
23:32:00 <mmorrow> vixey: :)!
23:32:10 <dons> mxc_, i doubt it. FRP used in anything real world yet?
23:32:26 <dons> we're getting there, but its not good to speculate on technologies
23:32:35 <mxc_> isn't wxFruit based on it?
23:32:35 <mmorrow> dons: tagging would be awesome, as would search.
23:32:57 <mxc_> i remember back when I was at jsc, they sponsored a project to do a FRP GUI lib for ocaml
23:33:08 <dons> yeah, the new wxFruit is frp based
23:33:34 <dons> mmorrow: yeah
23:33:37 <mxc_> no idea how complete wxFruit is, or if its anybetter than the classic wx wrapper
23:33:47 <dons> mmorrow: i'll talk to glguy about it
23:34:30 <dolio> mmorrow: What was the object of all that?
23:34:56 <mmorrow> dons: nice!
23:35:11 <Dzlk> I almost used flapjax for a paid project but ended up deciding FRP was over-engineering for that site. Unfortunately.
23:35:11 <dolio> Modular arithmetic in the type system?
23:35:20 <mmorrow> dolio: to do multiplication in Zp for prime p (a multiplicative group) in the type system
23:35:56 <mmorrow> dolio: yeah, in particular deal with a*b=1 where a and b are multiplicative inverses
23:47:15 <hpaste>  morrow annotated "probably *not* what you wanted" with "clarifying the motivation for the type instances" at http://hpaste.org/8210#a9
23:51:02 <hpaste>  morrow annotated "probably *not* what you wanted" with "module Z_7 where ..." at http://hpaste.org/8210#a10
23:51:35 <vixey> mmorrow: wow!
23:52:06 <mmorrow> vixey: :)
23:52:47 <^Someone^> Hey vixey :)
23:52:55 <mmorrow> vixey: i'd never really used type instances before and over the course of that realized how useful they could be
