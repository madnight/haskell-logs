00:00:36 <quicksilver> you can kill one with killThreads
00:01:03 <quicksilver> but it's probably simpler to let it finish.
00:01:17 <chylli> ok. got it.
00:01:47 <adu> what does this mean: dist/build/HOC/Base.o: unknown symbol `_autoreleaseObject'
00:02:23 <quicksilver> it means you linked it wrong.
00:02:31 <adu> quicksilver: o
00:03:30 <adu> so how do you specify that a haskell library needs to be linked with a C library and that the C library must be built first?
00:04:42 <quicksilver> the answer to the first part is to put the C library on the command line
00:04:51 <quicksilver> ghc --make foo.hs library.o
00:05:04 <quicksilver> the answer to the second part is "using a build system, perhaps make"
00:05:42 <codacola> curious, is recursion generally used in place of "for" and "while" loops?
00:06:38 <adu> codacola: i'd say list comprehensions are about as common as recursion for that sort of thing
00:07:35 <rwbarton> codacola: and when list comprehensions don't fit the bill, we also have foldl, scanl, etc.
00:07:42 <rwbarton> (which are implemented using recursion)
00:07:46 <glguy> recursion is less common than using higher-order functions like forM
00:07:46 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
00:07:59 <codacola> ah
00:08:45 <glguy> (which happen to use recursion internally)
00:09:13 <quicksilver> codacola: alternatively "yes". But often indirectly.
00:09:25 <quicksilver> by using other constructs which use recursion.
00:09:37 <quicksilver> A more interesting comparision is to say that lists are used instead of for loops.
00:09:51 <codacola> i was just curious since so far my book has touched on recursion, but hasnt mentioned loops. and just read that haskell has no loop structure
00:12:46 <osfameron> or maybe it has lots of loop structures, so you don't have to rely on just 'for' loops
00:13:49 <araujo> hello
00:13:59 <quicksilver> I imagine the point codacola's book is making is that it doesn't have them as a language structure.
00:14:05 <quicksilver> they're just library functions.
00:16:03 <osfameron> yeah
00:16:14 <osfameron> of course in haskell it's quite easy to add a for loop if you really want one
00:17:41 <quicksilver> :t forM_
00:17:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
00:18:35 <sieni> isn't foldl pretty similar to a for loop anyway?
00:19:04 <quicksilver> it's an example of one of the kinds of things you can do with a for loop, yes.
00:19:11 <quicksilver> most of the list functions are.
00:19:18 <quicksilver> hence my claim "lists are used instead of for loops"
00:19:51 <sieni> well there's not a facility to break out, but that should be easy to add
00:20:23 <quicksilver> well that takes you to forM_ ;)
00:20:52 <TSC> If you want to break, make sure the output is lazy and just stop evaluating it
00:21:24 <quicksilver> that is an answer as long as monadic effects aren't involved, yes.
00:21:39 <adu> codacola: whoever said that (about "no loop structure") doesn't know FP
00:21:47 <Cale> TSC: but you can't do that in the plain IO monad, you need to be able to capture the continuation of the forM_ to break.
00:22:11 <TSC> Sure, not in IO -- I was thinking of pure things
00:22:35 <codacola> Haskell has no loops because it doesn’t need them. There is no “for” or “while” in Haskell.
00:22:37 <Cale> Oh, then yeah, that's true :)
00:22:53 <Cale> codacola: Well, not built in anyway :)
00:22:55 <quicksilver> codacola: as I said, the point here is that they are not language constructs.
00:22:55 <TSC> Dirty monadic things are more complicated, of course
00:23:00 <quicksilver> codacola: they do indeed exists.
00:23:06 <quicksilver> codacola: forM and forM_, for example.
00:23:32 <quicksilver> the interesting point is that because you can implement your own looping structures it's like being able to customise the language.
00:26:13 <osfameron> codacola: I did an exercise implementing for loops in haskell here http://osfameron.vox.com/library/post/for-loops-in-haskell.html
00:31:14 <ivanm> when using ghci, how can I set it up so that it can find files in other directories?
00:31:45 <ivanm> i.e. if I have module Foo and module Data.Bar which imports Foo (which is in the root directory), ghci says that it can't find Foo :s
00:33:46 <rwbarton> works fine for me, as long as ghci is running in the directory containing Foo.hs...
00:34:09 <ivanm> hmmm.... I'm running it within emacs' haskell-mode... :s
00:34:28 <rwbarton> you can check what directory it's running in with M-x pwd
00:34:40 <ivanm> OK, that works
00:34:51 <ivanm> just did :cd in ghci
00:34:54 <ivanm> thanks rwbarton
00:34:55 <rwbarton> I suggest killing ghci, starting it from Foo.hs, then switching to Data/Bar.hs...
00:34:58 <rwbarton> oh, good to know :)
00:35:57 <ivanm> well, I originally started with Foo.hs :s
01:04:32 <adu> YES!
01:04:43 <ivanm> adu: WHY?
01:04:56 <adu> I have successfully abstracted the HOC ifgen tool to parse frameworks OTHER than Foundation and AppKit :)
01:05:28 <adu> it just parsed CoreGraphics
01:05:36 <sjanssen> adu: cool stuff
01:05:47 <sjanssen> so Haskell bindings to all of OS X for free?
01:06:09 <adu> well, there may be some name clashes, which can be handled in the "binding script"
01:06:30 <adu> this is the command I used for CoreGraphics:
01:06:34 <adu> ./fw2hs -f CoreGraphics -b ../Bindings/binding-script.txt -F /System/Library/Frameworks/ApplicationServices.framework/Frameworks
01:07:07 <adu> the "binding-script.txt" is just the binding script that was already there
01:08:34 <adu> sjanssen: you use mac?
01:08:46 <sjanssen> adu: nah
01:10:13 <ivanm> sjanssen: what _do_ you use now then?
01:10:40 <quicksilver> sjanssen runs haskell programs in his head.
01:10:45 <quicksilver> much more efficent.
01:10:53 <ivanm> heh
01:11:26 <ivanm> @remember quicksilver [on what OS sjanssen uses] sjanssen runs haskell programs in his head; much more efficent.
01:11:26 <lambdabot> Nice!
01:14:26 <sjanssen> ivanm: I'm using Ubuntu lately
01:14:35 <quicksilver> dons: does the UVector stuff have C-FFI array compatibility as a goal?
01:14:53 <ivanm> sjanssen: *nod*
01:14:59 <ivanm> that's right... hence your nm problems :p
01:15:49 <sjanssen> ivanm: yes, I'm aware that it doesn't make much sense to use Ubuntu given the amount I whine about compulsory GUIs :)
01:15:57 <ivanm> heh
01:16:57 <adu> DebDebDeb.ian.org
01:17:37 <sjanssen> adu: no such host
01:17:44 <adu> it was a joke
01:17:56 <adu> www.debian.org
01:25:21 <jinok> hey all, has anyone played with pcap in haskell?
01:34:09 <vincenz> @seen conal
01:34:09 <lambdabot> I haven't seen conal.
02:16:50 <zeno__> is this valid? (require insances of class G to provide types for s a and p) class G g s a p | g -> s, g -> a, g -> p where ...
02:17:19 <zeno__> ghc says (Use -XMultiParamTypeClasses to allow multi-parameter classes) but im not sure i have the syntax right
02:23:22 <quicksilver> zeno__: looks fine.
02:29:27 <zeno__> quicksilver: thanks, i have to add -XFunctionalDependencies -XTypeSynonymInstances too though :(
02:32:19 <quicksilver> zeno__: well what you pasted certainly doesn't require type synonyms but yes obviously if you use fnudeps you need fundeps.
02:35:31 <zeno__> its just wierd because i used them before but dont remember getting that error
02:52:13 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:13 <lambdabot> Title: Meine >> EM << Schlampe
02:52:15 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:15 <lambdabot> Title: Meine >> EM << Schlampe
02:52:17 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:17 <lambdabot> Title: Meine >> EM << Schlampe
02:52:19 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:19 <lambdabot> Title: Meine >> EM << Schlampe
02:52:21 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:21 <lambdabot> Title: Meine >> EM << Schlampe
02:52:23 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:24 <lambdabot> Title: Meine >> EM << Schlampe
02:52:25 <|Alterego|> MES PHOTOS NUES http://www.meine-nackte-ex.net/?uid=133794
02:52:25 <lambdabot> Title: Meine >> EM << Schlampe
02:53:38 <therp> if I use an immutable array in a tail recursive style (so the old immutable array is discarded), will GHC rewrite that into something stateful?
02:53:45 <gal_bolle> so he is spamming bilingual french-german haskellers ? That's a niche market
02:53:45 <therp> or do I have to use the ST monad
02:56:29 <ziman> i'd like to know that, too
02:57:31 <quicksilver> therp: no.
02:57:50 <quicksilver> therp: there is no system for automaticaly rewriting code to its mutable version.
02:57:59 <therp> quicksilver: thanks
02:58:10 <quicksilver> it's quite an interesting area, it's quite hard to predict when that's an optimisation I believe.
02:59:07 <therp> Hm, for the code I have in mind it is pretty safe optimisation. there are no other functions, just a tail recursive call that hands a modified array to its next invocation.
02:59:29 <ziman> can't that kind of rewrite be applied on each tail-recursive function?
03:00:16 <therp> kinda. tail recursive gives you in-place updatable variables with new content
03:00:53 <therp> but when the new content==array this doesn't automatically mean that the old array is reused.
03:01:28 <ziman> because arrays are `deep' structures and only the top-level pointer/reference is replaced?
03:01:36 <therp> would be nice though as arrays are just a generalization of variables, and what's possible for "simple variables" is certainly possible for "a set of index variables" too..
03:02:04 <therp> ziman: I think so. At least I would be surprised if GHC doesn't make that kind of optimization.
03:02:22 <therp> I think it's even forced to do so, as you quickly run out of stack without TC-optimization..
03:03:00 <therp> but I'm not intimate with the code generator.. these are just guesses..
03:03:00 <ziman> tail call optimization is crucial in such languages :)
03:12:53 <therp> are there any special hooks in GHC to execute the ST monad in a stateful manner? (rumors have it that this is the case for the IO Monad)
03:13:11 <therp> or is GHC sufficiently smart to optimize that to stateful code?
03:18:37 <quicksilver> I don't understand your question.
03:18:43 <quicksilver> Or what you mean by stafeful, for that matter.
03:19:06 <quicksilver> what does "executing the IO monad in a stateful manner" mean?
03:19:10 <quicksilver> ?
03:19:27 <quicksilver> the IO monad is executed according to its semantics, which includes plenty of state.
03:19:48 <quicksilver> the ST monad is executed in the same way, since it is the IO monad in a magic cloak.
03:40:45 <smg> hello
03:42:40 <RayNbow> http://www.reddit.com/r/programming/info/6oz7k/comments/ <-- reddit's broken (what else is new? :p), it says there are 3 comments...
03:42:41 <lambdabot> Title: programming: Obsidian: programming GPUs with Haskell :: PDF
03:42:45 <RayNbow> I can only see 2 :p
03:48:42 <therp> quicksilver: if I have (a >>= (\b -> c)) I could imagine that >>= builds up an object that in the context of an IO monad transforms the "IO state"
03:49:09 <therp> quicksilver: so, object gets build and latter if I drop a state into that object it will give me a new state
03:50:32 <quicksilver> well only in a sense, therp
03:50:36 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8551
03:50:37 <quicksilver> RealWorld# doesn't really exist
03:50:41 <quicksilver> don't take it too seriously.
03:50:45 <smg> http://hpaste.org/8551 <-- this fails with my grammar
03:50:45 <quicksilver> it's a model, a way of thinking.
03:50:50 <smg> someone can tell me what is wrong?
03:50:56 <smg> parse error at (line 1, column 2):
03:50:56 <smg> unexpected "5"
03:50:57 <smg> expecting "<"
03:50:58 <therp> quicksilver: right, that's why it's not handled that way in the RTS< right?
03:51:01 <smg> but the grammar is okay..
03:51:05 <therp> -<
03:51:17 <quicksilver> in actual fact IO is executed in haskell much like in an imperative language.
03:51:26 <quicksilver> (in GHC)
03:51:45 <kalven> @src GonadT
03:51:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:51:53 <quicksilver> a >>= (\b -> c) calls a, returns the value and passes it to b.
03:52:29 <therp> quicksilver: so for instance, if I write something like a ReaderWriter monad that is so to speak stateful for a single variable, GHC will not handle that as stateful execution like for IO#
03:52:50 <SamB_XP_> RealWorld# is a zero-byte type
03:52:53 <quicksilver> I honestly don't know what you mean by stateful.
03:53:06 <quicksilver> I think you're using that in a meaningless way.
03:53:18 <quicksilver> what do you think a "stateful execution" is?
03:53:35 <SamB_XP_> GHC doesn't really know much about statefulness
03:53:36 <quicksilver> smg: your grammar is not okay, in fact.
03:54:01 <mauke> smg: it expects a '<' because it's in doNode whose first element is char '<'
03:54:01 <quicksilver> smg: doNode is wrong. missin "doNumber"
03:54:49 <quicksilver> therp: can you be (even more) concrete?
03:54:53 <quicksilver> in your question.
03:54:57 <smg> quicksilver: ah
03:56:18 <therp> quicksilver: I'll try. http://www.haskell.org/all_about_monads/html/statemonad.html - if you look at the definition of >>= for state you basically see that it's chaining state transformers together. State $ \s -> ... builds up a new function
03:56:18 <lambdabot> Title: The State monad
03:56:59 <therp> quicksilver: I somehow have the feeling that this must be totally inefficient
03:58:24 <SamB_XP_> don't see the connection
03:58:25 <smg> quicksilver: thank you
03:59:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8552
03:59:20 <smg> http://hpaste.org/8552 <-- i have modified it that way quicksilver
03:59:26 <therp> quicksilver: as it is busy passing around tuples of the return value and the state
03:59:32 <smg> unexpected "9"
03:59:33 <smg> expecting "<"
03:59:36 <smg> now i have this error
03:59:55 <SamB_XP_> therp: well, okay, those tuples might not do wonders for the efficiency
04:00:11 <mauke> where did it get the "9" from?
04:00:16 <smg> ah i found the error mauke
04:00:23 <smg>  doNumber = try (doDigit >> doNumber) <|> (doDigit)$
04:00:27 <smg> so it need to be
04:00:29 <mauke> wtf
04:00:39 <mauke> doNumber = many1 digit
04:00:50 <smg> many1 does that?
04:00:56 <mauke> what did you think it does?
04:01:09 <SamB_XP_> except without the backtracking
04:01:28 <SamB_XP_> (or the need to store the information required for backtracking)
04:01:50 <therp> SamB_XP_: so it would be more efficient when we would store one part of the tuple "somewhere else" and modify it on-demand. there is no danger from lazyness as the State monad forces execution of one-step after another..
04:02:06 <smg> parse succeeded: "<50<10<20><30>><1<2><3>>>"
04:02:12 <smg> mauke: now i need to generate that tree
04:02:20 <smg> how would i do that?
04:02:33 <mauke> return appropriate values from your parsers
04:02:34 <SamB_XP_> therp: I was just thinking that an unboxed tuple would be more efficient ;-)
04:02:44 <smg> mauke: that is it?
04:03:09 <therp> SamB_XP_: I was rather thinking of the model of execution..
04:03:16 <smg> doLeaf = do { char '<'; num <- doNumber; char '>'; return num}
04:03:16 <quicksilver> therp: not as bad as you think, really.
04:03:18 <smg> mauke: that way?
04:03:23 <mauke> yeah
04:03:26 <quicksilver> therp: the optimiser is quite clever.
04:03:34 <mauke> actually, return (Tree num)
04:03:52 <SamB_XP_> therp: you don't think storing the values in registers is good enough?
04:03:56 <quicksilver> therp: the definitions for >>= get inlined at point of use and all kinds of unfodling can occur.
04:03:58 <smg> k
04:04:19 <therp> quicksilver: but there is no passing around of State in the IO monad, as for instance RealWorld#, right? So that leads me to conclude there is a profound difference in the execution of these two
04:04:41 <quicksilver> instead you pass around IORefs
04:04:45 <quicksilver> same different
04:04:48 <mauke> yes, you can't pipe the real world through a haskell function
04:04:58 <smg> mh somehow i get many type errors mauke
04:05:00 <quicksilver> in the IO monad, your IORef value is the thing that gets passed
04:05:05 <quicksilver> that's the "pointer to the state"
04:05:16 <quicksilver> in the State monad the "pointer to the state" is the implicit pointer
04:05:23 <quicksilver> not much different in principle.
04:05:34 <SamB_XP_> quicksilver: but passing the IORef around is more like Reader
04:05:47 <SamB_XP_> well, ReaderT would be more useful obviously ;-)
04:06:13 <quicksilver> SamB_XP_: but the point is, in both cases, something is passed.
04:06:23 <quicksilver> using the IO monad doesn't magically mean nothing is being passed around.
04:06:28 <SamB_XP_> yup
04:06:42 <smg> mauke: may you help me a bit?
04:06:44 <SamB_XP_> but in the ReaderT case you don't have those tuples
04:06:50 <quicksilver> converesly, ghc's optimisation stage is pretty good at reducing these things
04:06:59 <mauke> smg: no
04:07:16 <quicksilver> the tuples in the State case will often be eliminated.
04:07:23 <smg> mauke: :(
04:08:06 <quicksilver> GHC's optimiser can optimise out code of the form "case (1,2) of (a,b) -> a"
04:08:16 <quicksilver> and, with inlining, the State monad tends to produce code like that.
04:09:31 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8554
04:09:36 <therp> quicksilver: I was not so much thinking about IORef to access variables, but more like how side effects like readln are handled. with the State monad it's obvious that >>= builds up a unary function that waits to be executed. I imagine for the IO monad building up things does actually cause execution. so 'print "foobar" >>= (\_ -> ...)' will not build up a unary function like in State where RealWorld# is supposed to be dropped in
04:09:36 <therp> later
04:09:44 <smg> i pasted it maybe someone can figure out what i am doin wrong
04:09:45 <smg> http://hpaste.org/8554
04:09:57 <therp> s/readln/println/
04:10:30 <quicksilver> therp: well, there is a neat interaction between laziness and execution.
04:10:47 <quicksilver> of course, simply building up an IO action doesn't exeucute it.
04:10:51 <therp> quicksilver: what do you mean by 'neat' in that context?
04:11:04 <smg> someone sees the error?
04:11:05 <quicksilver> but on the other hand, the building doesn't happen at all until you do decide to execute it
04:11:09 <quicksilver> because of laziness.
04:11:18 <therp> yes, correct
04:11:27 <quicksilver> so in practice the execution is interleaved with the building.
04:11:38 <quicksilver> which reduces to almost the situation in an imperative language.
04:12:01 <quicksilver> that is why mapM_ works at all on infinite lists in IO.
04:12:07 <smg> quicksilver: maybe you?
04:12:45 <quicksilver> smg: I think the error messgae is rather clear.
04:13:27 <smg> no, i tried to figure out with it, but i won't get it :(
04:14:08 <nothingmuch> how do I tetll the cabal cmd line util to use a specific version of Cabal?
04:14:09 <quicksilver> you have said that doNode is a Praser Char.
04:14:11 <quicksilver> it is not.
04:14:19 <nothingmuch> yi-0.3 wants 1.2.3.0
04:14:28 <quicksilver> the last return statement in doNode does not return a Parser Char.
04:14:30 <nothingmuch> and latest doesn't compile
04:14:33 <quicksilver> return a Char, rather.
04:15:16 <smg> ah
04:15:38 <smg> quicksilver: yeah but i need to return that tree
04:17:09 <quicksilver> you do, yes.
04:17:21 <smg> mh
04:17:40 <quicksilver> so change the type of doNode
04:17:48 <quicksilver> which part are you not seeing?
04:18:44 <smg> i just don't know how to return from that functions
04:19:01 <smg> http://hpaste.org/8555 i have this
04:19:10 <smg> how would i then return a Leaf with Value 50 after i have parsed that?
04:19:27 <therp> quicksilver: hmm so there is actually nothing special in ">>=" of the IO monad?
04:22:06 <smg> quicksilver: do you understand me? =(
04:22:10 <therp> quicksilver: I'm sorry for the imprecise questions..
04:23:02 <nothingmuch> therp: in ghci type :i IO, that provides some insight
04:23:31 <nothingmuch> in the abstract there is nothing special about >>=
04:23:57 <nothingmuch> i'm going to guess ghc implements it in a special way for efficiency
04:24:23 <therp> the only difference between a State and IO that some IO operations have "real" side effects when they are evaluated
04:24:23 <nothingmuch> but the special bits are in the IO functions themselves, >>= just chains them in the right order
04:24:30 <byorgey> nothingmuch: the easiest way would be to edit yi's .cabal file to put a requirement on the cabal version.
04:24:44 <byorgey> I think there is a particular field for that, although I forget its name
04:24:47 <nothingmuch> byorgey: it does that but the cabal cmd line utility doesn't seem to let it work
04:24:48 <ziman> smg, i suggest you write a title for and sign each your post/paste :) and annotate the original post instead of creating a new one. it requires too much effort to keep track of what progress you've been doing this way :)
04:25:08 <nothingmuch> nopasting..
04:25:08 <smg> k
04:25:10 <b_jonas> I think the magic is not in the IO functions onr the >>= but what the runtime does with the value of main apart from just evaluating it
04:25:24 <ziman> smg, why did you make doNumber's type Parser Char?
04:25:25 <therp> nothingmuch: thanks, I always thought that IO was somehow specially executed
04:25:32 <nothingmuch> it is
04:25:35 <b_jonas> (or what ghci does with an io value apart from evaluating, which is just the same)
04:25:39 <nothingmuch> but nothing in the type gives that away
04:25:40 <ziman> smg, do you want to return a Char from that parser? i don't think so..
04:25:49 <smg> ziman: do you know what i do?
04:26:01 <ziman> smg, the same with doLeaf
04:26:01 <smg> i parse the input (as a string) and then i need to build that Tree...
04:26:03 <nothingmuch> therp: http://www.haskell.org/all_about_monads/html/iomonad.html#definition
04:26:04 <lambdabot> Title: The IO monad, http://tinyurl.com/5n4kv9
04:26:13 <ziman> smg, i know, i did that yesterday
04:26:20 <smg> http://hpaste.org/8556 <--
04:26:25 <b_jonas> (or what unsafePerformIO does, if I may say that)
04:26:34 <smg> so it is Parser Tree Int ziman ?
04:26:53 <b_jonas> and the problem is, I don't even understand what it actually does
04:27:24 <maltem> b_jonas: I think that's the point of the abstraction :)
04:27:37 <ziman> smg, if you want doLeaf to return Tree Int, the it's Parser (Tree Int); mind the precedence
04:27:48 <ziman> umm, associativity
04:28:02 <nothingmuch> hmm
04:28:03 <quicksilver> therp: correcty. nothing special.
04:28:13 <nothingmuch> http://hpaste.org/new is very unresponsive
04:28:15 <quicksilver> therp: the special bit is the way ghc actually executes the IO.
04:28:28 <quicksilver> but nothing articularly special in >>=
04:28:42 <b_jonas> maltem: by abstraction, do you mean you don't actually have to know what it does exactly, just a couple of rules for what it does if fed with print, x>>=y, etc?
04:29:03 <nothingmuch> http://scsys.co.uk:8001/16376
04:29:22 <hpaste>  (anonymous) annotated "problem" with "(no title)" at http://hpaste.org/8556#a1
04:29:28 <smg> ziman: i pasted it?
04:29:47 <nothingmuch> byorgey: that paste was for you
04:30:00 <byorgey> nothingmuch: I see it.  that is indeed strange...
04:30:15 <maltem> b_jonas: Right. When talking Haskell we don't have to worry what "performing an IO action" might all involve, we just talk about the IO actions themselves
04:30:33 <byorgey> nothingmuch: maybe try doing a 'cabal clean' first?
04:30:39 <nothingmuch> byorgey: i did
04:30:44 <byorgey> nothingmuch: ok.
04:30:48 <nothingmuch> http://scsys.co.uk:8001/16377
04:30:52 <b_jonas> maltem: yes, I think I like that view
04:30:53 <nothingmuch> that's how latest fails
04:31:00 <maltem> b_jonas: evidently unsafePerformIO breaks that abstraction :)
04:31:08 <nothingmuch> presumably it expects a utf8-string with more features than the one I have
04:31:47 <byorgey> nothingmuch: then the only other thing I can suggest is to click your heels three times and say "I wish dcoutts was here"
04:32:02 <nothingmuch> @summon dcoutts
04:32:02 <lambdabot> Unknown command, try @list
04:32:07 <nothingmuch> =(
04:32:40 <b_jonas> maltem: I think the intention is that you use it safely in pure functions that don't break it
04:32:45 <nothingmuch> btw, http://nothingmuch.woobling.org/yi.png
04:32:54 <b_jonas> where those pure functions could involve returning an IO type
04:32:57 <nothingmuch> i think the .jp defs are more amusing =)
04:33:13 <b_jonas> or they might not, if you use unsafePerformIO as just a tool
04:33:51 * nothingmuch found unsafePerformIO useful as a development tool
04:34:10 <nothingmuch> kinda like undefined
04:34:26 <b_jonas> nothingmuch: you mean like debugging printfs?
04:34:34 <nothingmuch> for instance
04:34:42 <nothingmuch> or for slurping some data in
04:35:01 <nothingmuch> when you feel like cheating in general =)
04:35:13 <byorgey> nothingmuch: did you read the faq on the yi wiki?
04:35:28 <nothingmuch> *blush*
04:35:31 <nothingmuch> i didn't realize there was one
04:35:37 <byorgey> nothingmuch: hehe =)
04:35:42 <byorgey> nothingmuch: it suggests doing ghc -package Cabal-1.2.3.0 --make Setup.hs
04:35:56 <byorgey> and then running ./Setup configure, etc
04:36:35 <quicksilver> I've use unsafePerformIO with readFile to read static data
04:36:37 <quicksilver> when I was being lazy
04:36:47 <quicksilver> I think that's one of the less offensive uses
04:36:58 <quicksilver> although it's generally a hack I'd aim to remove later
04:37:22 <nothingmuch> byorgey: ta =)
04:37:30 <nothingmuch> the latest problem is also in the FAQ
04:37:33 <nothingmuch> reading up on it
04:37:34 <SamB> by building a .hs file from the data that you had been unsafeReadFile-ing?
04:37:52 <SamB> using, perhaps, a perl script?
04:38:11 <quicksilver> by readFile'ing it in main and passing parsed value around appropriately.
04:38:12 <SamB> or even a Haskell script
04:38:27 <nothingmuch> byorgey++ # yi-0.3 breaks much later in the compilation now ;-)
04:38:36 <SamB> oh, you mean it wasn't just static data that should be in the executable anyway?
04:38:39 <quicksilver> but alternatively by implementing Data.Binary and then using don's crafty script to turn binary serialisation into compressed haskell source?
04:38:46 <byorgey> nothingmuch: ah, excellent =)
04:39:01 * byorgey is inspired to try building yi again
04:39:05 <quicksilver> s/n's/ns'/
04:39:10 <b_jonas> I see
04:39:10 <nothingmuch> afrgh
04:39:13 <nothingmuch> *headdesk*
04:39:24 <nothingmuch> seems like the same problem as the 0.4 one
04:39:26 <nothingmuch> regexp vs. bytestring
04:39:41 <byorgey> yeah, the dreaded bytestring diamond dependency problem?
04:39:56 <nothingmuch> *nod*
04:40:08 <quicksilver> it is said that Yi testers are encouraged to purchase steel-reinforced desks first. With padding.
04:40:16 <nothingmuch> =)
04:40:18 <maltem> byorgey, nothingmuch: I even managed to build yi some days ago, and guess what, it would startup!
04:40:34 * nothingmuch is hoping that yi would be a good excuse to hack more hs
04:41:24 <byorgey> maltem: amazing! =O
04:41:26 <nothingmuch> oh well, not today
04:54:04 <hcube> how can i access a "float vector3f[3]" C array from haskell ? what datatype should i define to handle C functions using this vector type  (float [3])?
04:55:02 <hcube> i'm new to haskell, i've briefly read the FFI doc, but i dont hav much time
04:56:32 <ragadab> can't compile cabal on ubuntu - i run runhaskell Setup.hs configure, then build it with runhaskell Setup.hs build, but error Setup.hs: Run the 'configure' command first.
04:57:58 <Saizan_> ragadab: weird, does dist/setup-config exists?
04:58:23 <ragadab> where it?
04:59:28 <Saizan_> in the directory where you're running runhaskell Setup.hs configure
04:59:44 <Saizan_> which should be the one containing Cabal.cabal and the sources
05:00:30 <ragadab> its empty
05:01:35 <Saizan_> dist is empty? does runhaskell Setup.hs configure report any error?
05:02:26 <ragadab> no, only one string - Configuring Cabal-1.4.0.1...
05:04:40 <Saizan_> that's weird, i'd try removing the dist directory and run configure again
05:05:15 <lorne> hcube: I'd guess Ptr CFloat
05:06:13 <ragadab> Saizan_: same situation, what i should check?
05:08:35 <quicksilver> hcube: the answer is indeed Ptr CFloat
05:14:54 <hcube> quicksilver: and how can i get values from Ptr CFloat ?
05:15:02 <lorne> hcube: peekElemOff
05:15:30 <hcube> ok, thanks :)
05:16:13 <quicksilver> or perhaps peekArray to get all three at once.
05:16:29 <quicksilver> use you can probably use the storable instance for opengl's Vector3 type, with a little care.
05:22:52 <visof> i want to learn haskell debugginf?
05:23:02 <visof> is there any good tutorial for this?
05:23:23 <visof> debugging*
05:23:56 <quicksilver> visof: I'm sure tehre is some stuff on the gchi dbugger, but that's not the way I debug haskell.
05:24:13 <quicksilver> I debug haskell by running the function which is misbehaving in ghci
05:24:16 <quicksilver> until I understand why
05:24:25 <quicksilver> and perhaps building regression test case or quick check properties
05:25:01 <visof> quicksilver what about a profiling?
05:25:58 <ragadab> guys, how i may setup haskell in ubuntu? what way is best?
05:26:36 <Saizan_> ragadab: i don't know what could cause that problem, here it builds fine, runghc Setup.hs configure -v3 should give you more info on what is happening
05:27:05 <ragadab> Saizan_: thank u
05:27:09 <quicksilver> visof: there is stuff about profiling in the GHC manual
05:27:36 <visof> okay
05:29:37 <pejo> visof, there's an article about the debugger in the latest (?) Monad Reader.
05:37:00 <visof> thanks pejo
05:37:05 <visof> i found it
05:40:51 <visof> "The last statement in a 'do' construct must be an expression", what this mean?
05:41:13 <EvilTerran> it can't be a let-with-no-in, nor can it be a <-
05:41:35 <EvilTerran> because the overall return value of the do block is determined by the last statement
05:42:08 <visof> example?
05:42:09 <chessguy> > sortBy (comparing `on` fst) [(2,3),(1,2)]
05:42:11 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> a
05:42:11 <lambdabot>     Probabl...
05:42:25 <EvilTerran> do x <- foo -- not allowed
05:42:31 <EvilTerran> do let x = foo -- also not allowed
05:42:35 <EvilTerran> do foo -- ok
05:42:36 <chessguy> > sortBy (comparing fst) [(2,3),(1,2)]
05:42:38 <lambdabot>  [(1,2),(2,3)]
05:43:09 <Syzygy|de> > sortBy (compare `on` fst) [(2,3),(1,2)]
05:43:10 <lambdabot>  [(1,2),(2,3)]
05:43:13 <EvilTerran> it doesn't make sense for the last statement to be anything but an expression, the de-sugaring to >>=s wouldn't workj
05:43:23 <Syzygy|de> > sortBy (compare `on` (+)) [(2,3),(1,2)]
05:43:23 <lambdabot>        add an instance declaration for
05:43:23 <lambdabot>       (Num (t, t1), Ord ((t, t1) -> (t...
05:43:31 <Syzygy|de> > sortBy (compare `on` (curry (+))) [(2,3),(1,2)]
05:43:31 <lambdabot>        add an instance declaration for
05:43:31 <lambdabot>       (Num ((t, t1), b), Ord (b -> ((t...
05:43:36 <Syzygy|de> > sortBy (compare `on` (uncurry (+))) [(2,3),(1,2)]
05:43:37 <lambdabot>  [(1,2),(2,3)]
05:43:43 <Syzygy|de> > sortBy (compare `on` (uncurry (+))) [(2,3),(1,8)]
05:43:44 <lambdabot>  [(2,3),(1,8)]
05:43:47 <Syzygy|de> :)
05:44:10 <nus> @src on
05:44:10 <lambdabot> (*) `on` f = \x y -> f x * f y
05:44:23 <EvilTerran> > sortBy (comparing $ uncurry (+)) [(2,3),(1,8),(1,2)]
05:44:24 <lambdabot>  [(1,2),(2,3),(1,8)]
05:44:39 <EvilTerran> comparing = (compare `on`)
05:44:51 <quicksilver> in practice it normally means that the last statement wasn't what you intended the last statement to be
05:44:57 <quicksilver> because you made an indentation error :)
05:45:01 <quicksilver> at least, that's my experience.
05:45:16 <nus> huh, (*) ?
05:45:23 <EvilTerran> nus, it's just a name
05:45:25 <Syzygy|de> nus: Local definition of a 2-ary function.
05:45:39 <Liempt> http://usera.imagecave.com/chocolatelover/snappy8.jpg
05:45:47 <EvilTerran> > let f (??) x = x ?? x in f (,) 2
05:45:48 <lambdabot>  (2,2)
05:45:51 <Syzygy|de> What that says is equivalent to > on f2 f = \x y -> f2 (f x) (f y)
05:46:47 <nus> oh, pattern-matching
05:46:57 <nus> been thinking of operator (*)
05:47:46 <EvilTerran> ?type let (`f`) `on` g = \x y -> g x `f` g y in on
05:47:48 <lambdabot> parse error on input `)'
05:47:50 <EvilTerran> hm
05:47:56 <EvilTerran> ?type let f `on` g = \x y -> g x `f` g y in on
05:47:58 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
06:06:28 <mjk> class M02 a where
06:06:41 <mjk> (==) :: a -> a -> Bool
06:07:02 <mjk> instance (Eq a, Eq b) => M02 (a, b) where
06:07:33 <mjk> (x, y) == (u, v)     = x == u && y == v
06:07:50 <mjk> I define a class and it's instance, but it's not correct, what't problem?
06:09:08 <dolio> That won't work because (==) is already part of the Eq class.
06:09:17 <dolio> It can't also be a method of the M02 class.
06:10:24 <dolio> Unless they're in separate namespaces, and you qualify the calls to one of them.
06:10:27 <quicksilver> it can be if it's in another module
06:10:28 <quicksilver> right.
06:10:43 <quicksilver> but then your instances needs to disambiguate
06:12:57 <mjk> i am perplexed by it.
06:13:15 <quicksilver> wihch part?
06:19:25 <nus> hmm, it barfs at qualifying the (==) in the function definition
06:20:42 <dcoutts_> ragadab: did you get Cabal working or still having problems?
06:28:02 <LemmihSchool> dcoutts_: Did you work out how to use HAppS-State?
06:33:57 <ragadab> dcoutts still here
06:35:02 <hpaste>  hukolele pasted "perceptron in haskell" at http://hpaste.org/8557
06:36:50 <hukolele> my perceptron doesnt works, help!
06:37:25 <gwern> did you try to get it to learn a xor function? everyone knows perceptrons are broken!
06:38:12 <hukolele> it doesnt works trying to learn and function
06:38:25 <hukolele> "and" function i mean
06:39:59 * gwern is joking, I don't really know how to fix broken perceptron code - all I can do is crack AI-related jokes
06:58:54 <ivanm> anyone here familiar with FGL?
07:08:46 <lorne> hukolele: I think the problem is with the random threshold
07:12:09 <hpaste>  visof pasted "(no title)" at http://hpaste.org/8559
07:12:33 <visof> it doesn't work for me
07:13:17 <visof> 1.hs:5:3: Parse error in pattern
07:13:18 <visof> Failed, modules loaded: none
07:13:26 <ragadab> can't get cabal install worked. i reinstall ghc, but it dont change anything
07:13:43 <ragadab> what i may do more?
07:15:55 <mauke> visof: what you pasted works fine here
07:16:25 <visof> so
07:16:32 <visof> what is the problem here?
07:16:46 <mauke> what you pasted isn't the code you're trying to run
07:17:04 <LemmihSchool> visof: Do you have any tabs in the code?
07:17:54 <visof> i don't think so
07:19:04 <visof> it's working
07:19:10 <visof> i tried it
07:19:37 <visof> the problem was in spaces
07:19:48 <visof> but why this?
07:20:10 <visof> are tabs and spaces causing problems?
07:20:20 <dmwit> tabs are (roughly) equivalent to 8 spaces
07:21:18 <BMeph> dmwit: Unless they're equivalent to FOUR spaces. Or to three. ;p
07:21:39 <dmwit> Right, hence the (roughly) bit.
07:22:10 <Saizan_> the bottom line is to never use tabs so that you can't disagree on the length of a tab
07:22:18 <mauke> or always use tabs
07:22:25 <lorne> @src iterate
07:22:26 <lambdabot> iterate f x =  x : iterate f (f x)
07:22:32 <dmwit> Somebody suggested making tab a lexical error; seems like a nice idea to me.
07:22:57 <lorne> hukolele: the cases where it prints nothing is when the randomly generated perceptron is correct and the debugging string is ""
07:23:07 <RayNbow> I want my tabs to be equivalent to 3.14 spaces
07:23:35 <dmwit> Use Word?
07:24:29 <sbahra> Saizan_, why?
07:24:41 <sbahra> You should use tabs as much as possible, so you *can* modify tab width if necessary.
07:24:46 <RayNbow> dmwit: does Word have a Haskell plugin? ^_^
07:24:59 <sbahra> Though, I'm not sure what the situation is in haskell. :-P
07:25:17 <quicksilver> sbahra: in haskell it's not a good idea
07:25:30 <mauke> sbahra: that works for your own code
07:25:31 <mjk> i'v defined a class and it's instance,like the following:
07:25:31 <quicksilver> unless you have the fabled "SufficientlySmartEditor"
07:25:42 <quicksilver> which can mix tabs and spaces safel.
07:25:44 <dmwit> Tabs are fine, if they're done consistently, and only for indentation (not alignment).
07:25:48 <mauke> sbahra: but no one else uses that style, so it's hard to stay consistent
07:25:53 <mjk> type Point = (Int, Int)
07:26:04 <mjk> class M02 a where
07:26:11 <quicksilver> dmwit: tricky to use with "do blah\n   blah"
07:26:21 <mjk> equal :: a->a->Bool
07:26:21 <dmwit> Right, the problem is in the "if they're done consistently" part.
07:26:33 <dmwit> quicksilver: "do\n\tblah\tblah"
07:26:34 <mjk> instance M02 Point where
07:26:34 <quicksilver> dmwit: haskell indentation requires 3 spaces on the next line
07:26:38 <sbahra> mauke, no one else uses what style? A lot of projects have strict style guidelines.
07:26:38 <quicksilver> right
07:26:47 <sbahra> mauke, or do you mean in haskell in general?
07:26:52 <mauke> sbahra: using tabs for indentation in haskell
07:26:54 <mjk> equal a b = (fst a == fst b) && (snd a == snd b)
07:26:55 <sbahra> I'm still learning haskell, very early stages.
07:26:58 <sbahra> I see.
07:26:59 <quicksilver> dmwit: right, so you have to cut off a whole bunch of haskell possibilities
07:27:08 <dmwit> mjk: equal a b = a == b
07:27:16 <mjk> but it isn't correct, why?
07:27:33 <dmwit> mjk: You can't make type-synonyms instances.
07:27:38 <quicksilver> dmwit: including "let x = "
07:27:40 <mauke> sbahra: many people seem to use alignment oriented indentation
07:27:49 <quicksilver> dmwit: and "where x = "
07:27:59 <dmwit> mjk: Either newtype it or enable the proper extension.
07:28:01 <quicksilver> dmwit: basically you need a lot more newlines, i fyou're going ot use tabs.
07:28:10 <Deewiant> sbahra: there's so much aligning stuff in haskell that it's the only language for which I don't use tabs
07:28:11 <dmwit> mjk: But there's already a class Eq for that, so...
07:28:31 <quicksilver> mjk: in future, you will get more effective help if you (a) paste your code to hpaste.org and (b) tell us the exact error message instead of "it went wrong"
07:28:36 <dmwit> quicksilver: where is no problem, let might be annoying
07:29:15 <mauke> just start a new line after 'let'
07:29:24 <quicksilver> mauke: as I said, you need a lot more newlines
07:29:26 <mjk> h004.hs:15:0:
07:29:26 <mjk>     Illegal instance declaration for `M02 Point'
07:29:26 <mjk>         (All instance types must be of the form (T t1 ... tn)
07:29:26 <mjk>          where T is not a synonym.
07:29:26 <mjk>          Use -XTypeSynonymInstances if you want to disable this.)
07:29:27 <mjk>     In the instance declaration for `M02 Point'
07:29:29 <mjk> Failed, modules loaded: none.
07:29:48 <quicksilver> mauke: and, as you said, other people don't program in this style :)
07:29:57 <mauke> quicksilver: I do
07:30:03 <mauke> I just don't do it with tabs
07:30:06 <quicksilver> mjk: well, the error message tells you exactly waht's wrong and how to fix it.
07:30:20 <EvilTerran> mjk, we prefer if you use hpaste.org for text of more than a line or two
07:30:29 <quicksilver> mjk: you can't make type synonyms instances, although you can turn on the extension if you like.
07:30:31 <mauke> also, layout let is not that common in my code
07:31:04 <quicksilver> mauke: definitely. it's a fine way tocode but the point is that other people's (relatively widely used ) styles are not compatible with it
07:31:09 <quicksilver> I think that's what you were saying too.
07:31:19 <quicksilver> do you start newlines after case x of, too?
07:31:25 <dmwit> Yeah, I can't really think of the last time I used layout let, either.
07:31:30 <mauke> quicksilver: of course
07:31:31 <dmwit> quicksilver: definitely
07:31:47 <mauke> don't tell me you indent the following lines to the part after "of"
07:31:52 <mjk> quicksilver: i havn't any clue
07:32:01 <quicksilver> I quite often have code like let x = sin this \n y = cos this
07:32:14 <quicksilver> mjk: did you understand my answer? dmwit gave it too?
07:32:21 <nus> mjk, are you using ghci?
07:32:21 <quicksilver> mjk: haskell does not permit type synonyms to be instances.
07:32:31 <quicksilver> mjk: GHC has an extension which permits that.
07:32:42 <quicksilver> mjk: the flag to enable that extension was given in the error message.
07:32:44 <maltem> let's are easy when you use 4-space indentation anyway
07:32:53 <quicksilver> maltem: yes, that's a useful coincidence :)
07:33:06 <dino-> Is it better to just use a newtype in this case and deal with the constructor than to use that extension?
07:33:06 <mjk> nus: yes
07:33:16 <quicksilver> dino-: in my opinion yes.
07:33:24 <quicksilver> dino-: if fact, I'd use a data not a newtype.
07:33:33 <mauke> maltem: but that feels like hardcoding magic constants :(
07:33:35 <quicksilver> I would always prefer data Point = Pt Int Int
07:33:40 <quicksilver> to type POint = (Int,Int)
07:33:42 <quicksilver> etc.
07:33:43 <dino-> ya
07:34:06 <dino-> So, tell me then, why is type instancing not permitted in the first place?
07:34:12 <nus> mjk, :s -XTypeSynonymInstances before :l
07:34:22 <mjk> use POint is still raising error
07:34:50 <quicksilver> dino-: haskell98 took a very conservative approach to legal instance declarations in several ways.
07:34:56 <quicksilver> dino-: I'm not entirely sure why.
07:35:16 <mjk> nus: use :s -XTypeSynonymInstances is still raising error
07:35:28 <maltem> mauke, quicksilver: Yeah and it fails for case statements. Why does "case" have four letters anyway? It's only three sounds!
07:35:45 <quicksilver> dino-: I imagine with type synonym instances the fear is that you might imagine you can have seaprate instances for (Int,Int) and type Point = (Int,Int)
07:35:56 <quicksilver> dino-: when of course you can't because they are the same type.
07:35:57 <mjk> nus: yes, load is OK
07:36:02 <pejo> quicksilver, because it wasn't controversial, so the standard could get 'done', I'd imagine.
07:36:19 <dino-> quicksilver: I can see that getting scary. Because they're the same type with basically an alias.
07:36:25 <mauke> (Int,Int) is invalid anyway
07:36:31 <quicksilver> pejo: well yes, that's a meta-reason. But yes.
07:36:40 <mauke> you can only have instances for (a, b)
07:36:42 <quicksilver> yup (Int,Int) is invalid for another reason ;)
07:37:34 <pejo> quicksilver, what is meta about having a standard?
07:38:57 <Liempt> Ahem.
07:39:10 <Liempt> I believe it is now time for a brief intermission.
07:39:33 * byorgey stands up and stretches
07:39:34 <Liempt> LET'S ALL GO TO THE LOBBY, LET'S ALL GO TO THE LOBBY, LET'S ALL GO TO THE LOBBY
07:39:39 <Liempt> TO GET OURSELVES SOME SNACKS.
07:39:45 <Liempt> That is all.
07:39:47 <Liempt> Please carry on.
07:39:52 <dmwit> done and Done, good sir!
07:39:54 <ivanm> OK, for some reason I'm not thinking straight... if I have a function f :: a -> Maybe b, and I want to use it to construct a value of type Maybe (a,b), what do I have to do without manually doing a case or something?
07:40:00 * byorgey sells chocolate-coated malted lambdas
07:40:08 <byorgey> for exorbitant prices
07:40:11 <ivanm> heh
07:40:28 <mauke> @djinn a -> (a -> Maybe b) -> Maybe (a,b)
07:40:29 <dmwit> a >>= return &&& f
07:40:30 <lambdabot> f a b =
07:40:30 <lambdabot>     case b a of
07:40:30 <lambdabot>     Nothing -> Nothing
07:40:30 <lambdabot>     Just c -> Just (a, c)
07:40:39 <quicksilver> pejo: my point was, that there must have been a reason the alternrnatives were controversial.
07:40:39 <dmwit> Oh... not quite.  Hum.
07:40:43 <Saizan_> ?ty \a f -> fmap ((,) a) (f a)
07:40:47 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => a -> (a -> f a1) -> f (a, a1)
07:40:57 <RayNbow> byorgey: how much for a pepperoni lambda?
07:41:02 <quicksilver> pejo: otherwise the suggestion of taking the less controversial version wouldn't have arisen.
07:41:25 <ivanm> (and to make matters more interesting, the value I'm passing in is of type Maybe a :p)
07:41:30 <byorgey> RayNbow: 90 dollars, or 3 Euros, whichever is less
07:41:39 <dmwit> f a g = do { b <- g a; return (a, b) } -- another possibility, ivanm
07:41:40 <gbacon> > let { trim = let f = reverse . dropWhile isSpace in f . f; (a,b) = break isSpace "foo bar baz" } in (a,b)
07:41:43 <ivanm> Saizan_: hmmmm..... didn't think about that...
07:41:46 <lambdabot>  ("foo"," bar baz")
07:42:01 <gbacon> > let { trim = let f = reverse . dropWhile isSpace in f . f; (a,b) = second trim $ break isSpace "foo bar baz" } in (a,b)
07:42:02 <lambdabot>  ("foo","bar baz")
07:42:27 <dmwit> > words "foo bar baz"
07:42:28 <lambdabot>  ["foo","bar","baz"]
07:42:39 <gbacon> > let { trim = let f = reverse . dropWhile isSpace in f . f; (a,b) = break isSpace "foo bar baz" <$> second trim} in (a,b)
07:42:39 <lambdabot>  Couldn't match expected type `a -> t'
07:42:56 <Saizan_> ?pl \f -> f . f
07:42:56 <lambdabot> join (.)
07:43:41 <byorgey> @type \f -> uncurry (fmap . (,)) . (id &&& f)
07:43:43 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> a1 -> f (a1, a)
07:43:49 <byorgey> w00t!
07:43:49 * ivanm really wishes there was a way to check the types of items in a where block :s
07:44:26 <RayNbow> <byorgey> RayNbow: 90 dollars, or 3 Euros, whichever is less <-- 3 EUR it is :p
07:44:35 <RayNbow> well, currently
07:44:42 <RayNbow> you never know with the dollar :)
07:44:42 <ivanm> byorgey: yes, but I kind of implicitly meant some code that was _cleaner_ than doing it manually :p
07:44:44 <byorgey> RayNbow: indeed =)
07:44:44 <opqdonut> > let fix f = let f' = f . f' in f' undefined in fix (1:)
07:44:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:44:48 <opqdonut> wow
07:44:50 <byorgey> ivanm: hehe, right
07:44:53 <gbacon> ?i second
07:44:54 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
07:44:58 <gbacon> ?index second
07:44:58 <lambdabot> Control.Arrow
07:45:59 <ivanm> for some reason, Saizan_'s didn't work... but dmwits dead
07:46:12 <byorgey> oh no!
07:46:12 <ivanm> even though IMHO it's kind of ugly to have an inline monad :s
07:46:26 * byorgey mourns the loss of dmwit
07:46:33 <ivanm> heh
07:46:35 <ivanm> s/dead/did
07:46:38 <ivanm> happy now?
07:46:50 * ivanm didn't even spot that until byorgey mentioned "loss"
07:46:57 <byorgey> hehe =)
07:47:21 <opqdonut> ?src fix
07:47:21 <lambdabot> fix f = let x = f x in x
07:47:32 * RayNbow just notices there is a nice article on zippers on wikibooks...
07:47:54 * RayNbow adds it to the To Read list
07:48:32 <RayNbow> Haskell distracts you too much from RL duties :p
07:49:22 <dcoutts_> ragadab: perhaps you can use hpaste to show what you get when you do: ghc --make Setup && ./Setup configure -v3
07:49:24 <dcoutts_> @hpaste
07:49:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:53:08 <hackage> New hackage package: HDBC 1.1.5
07:54:50 <hpaste>  ragadab pasted "(no title)" at http://hpaste.org/8560
07:55:54 <ragadab> dcoutts_ - ready
07:57:07 <dcoutts_> ragadab: and that paste has not be cut off? the trace just stops after "/usr/bin/ghc is version 6.8.2" ?
07:57:11 <dcoutts_> be/been
07:57:30 * gwern is vaguely appalled at how many unsafePerformIOs there are in ghc/libraries' source
07:57:53 <osfameron> why?
07:57:58 <osfameron> isn't that *exactly* where you want them?
07:58:09 <dcoutts_> gwern: there are loads in bytestring, we could do it with out if we used a different rep
07:58:12 <osfameron> so they can be nicely encapsulated and we don't have to use them mostly
07:58:14 <ragadab> oh
07:58:17 <ragadab> moment
07:58:26 <dcoutts_> ragadab: you can annotate the existing paste
07:58:28 <gwern> it makes my idea of improving mueval's blacklist that much harder, since I need to see whether they could leak and be abused
07:58:48 <dcoutts_> ragadab: hpaste limits each one to 5k I think
07:59:07 <hpaste>  ragadab pasted "cabal build error" at http://hpaste.org/8561
07:59:23 <dcoutts_> ragadab: hpaste limits each one to 5k I think
07:59:36 <ragadab> oh. i paste last part
07:59:39 <dcoutts_> ragadab: so use the annotate like at the top
07:59:45 <dcoutts_> like/link
07:59:57 <dcoutts_> to add the next bit
08:00:11 <hpaste>  ragadab annotated "cabal build error" with "cabal build error" at http://hpaste.org/8561#a1
08:00:51 <dcoutts_> ragadab: hmm, that's bad. Segmentation fault
08:01:20 <ragadab> yes
08:01:22 <ragadab> bad
08:01:35 <dcoutts_> It's not clear what is segfaulting there
08:01:46 <ragadab> so?
08:01:47 <dcoutts_> it could be Setup, or ghc or gcc
08:02:23 <ragadab> ok, i found info about install in wiki, so ill try, and then report here
08:02:35 <ragadab> i reinstall ghc
08:02:41 <ragadab> i will
08:02:44 <dcoutts_> ragadab: wait a sec
08:02:54 <ragadab> ok ) thank u
08:02:59 <dcoutts_> ragadab: lets see if we can figure out which program is failing
08:03:10 <ragadab> it will be great
08:04:04 <dcoutts_> ragadab: try: echo "int foo() {}" > test.c && /usr/bin/ghc -c test.c -o test.o
08:04:39 <Liempt> I lost my pointfree abilities while killing communist japs in 'nam.
08:04:57 <Liempt> We lost so many good men out there.
08:05:01 <Liempt> :'(
08:05:02 <ragadab> тщерштп рфззуты
08:05:12 <ragadab> ops. nothing happens
08:05:29 <dcoutts_> 'k, so that works
08:05:46 <quicksilver> Liempt: that's probably on the borderline of what some people might consider offensive.
08:05:52 <quicksilver> Liempt: and it's not got much to do with #haskell.
08:06:21 <Liempt> Oh, absolutely nothing really to do with Haskell.
08:06:38 <gwern> Liempt: japs in 'nam?
08:06:41 <Liempt> And if people find patent nonsense offensive they should become less fragile.
08:06:43 <smg> hello people.
08:06:49 <Liempt> But I'm sorry for offending if I did.
08:07:12 <dcoutts_> Liempt: I often find patents offencive :-)
08:07:23 <Liempt> ^_^
08:07:37 <dcoutts_> ragadab: yeah, I guess try reinstalling ghc.
08:07:45 <dcoutts_> ragadab: you're on ubuntu did you say?
08:08:12 <ivanm> is there a short cut for (f *** f) ?
08:08:19 * gwern is still wondering how you would've killed any Japs in 'nam
08:08:30 <ragadab> yes
08:08:31 <mauke> ivanm: join (***)
08:08:37 <ivanm> ahhhh
08:08:40 <ivanm> thanks mauke
08:08:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8562
08:09:06 <maltem> ivanm: For some given meaning of shortcut :)
08:09:13 <ivanm> heh
08:09:20 <ragadab> dcoutts_ i will reinstall it from debian repo, as described in wiki
08:09:25 <ivanm> turns out I can't use it anyway, I forgot I changed one of my types :s
08:09:32 <smg> i pasted something at 8562 maybe someone has an idea :)
08:10:05 <Liempt> gwern: That's the joke.
08:10:34 <kpreid> smg: how about using the 'many' / 'many1' combinators?
08:10:45 <smg> kpreid: and then?
08:10:48 <kpreid> smg: that said, the thing to do is write your parse actions to return a parse tree
08:11:14 <kpreid> either that or return the max height directly, if that's all you care about
08:11:29 <smg> yeah i jsut care about the height
08:11:31 <gwern> Liempt: ah. humor - it is a difficult concept.
08:11:41 <smg> but i have no guess how to do that, i thought now about 30 mins about that problem
08:11:42 <Liempt> I'm not so good at it, apparently.
08:12:19 <smg>  return the max height directly <--
08:12:23 <smg> what does this mean kpreid?
08:12:37 <kpreid> smg: well,doG should 'return 0' in the second case; the first is okay
08:12:57 <kpreid> doH should return 1 or return fmap (1+) doP
08:13:05 <maltem> smg: If you just care about the height, why then a proper parser, actually? sum . map (\c -> case c of '/' -> 1; '\\' -> -1; '-' -> 0)
08:13:05 <smg> ahh
08:13:07 <kpreid> also look up the 'bracket' combinator
08:13:08 <smg> why fmap?
08:13:21 <smg> maltem: because i need to exercise this
08:13:28 <maltem> smg: ah sorry, the maximum height you said
08:13:29 <smg> i write in a 2 weeks a test about that
08:13:33 <kpreid> you could write p <- doP; return (1+ p) but fmap is easier
08:14:22 <int-e> smg: have you seen the  scanl  function?
08:14:31 <smg> yes
08:14:43 <kpreid> smg: also I think your grammar could be much simplified by allowing empties
08:14:56 <int-e> smg: I'd build the maximum height function from that and  maximum.
08:15:17 <maltem> smg: right, if it shall be a parser, kpreid is right in that it should actually return something useful (i. e. a parse tree or something)
08:16:45 <kpreid> parseit = fmap maximum $ many1 tree; tree = (fmap (1+) $ bracket (char '/') (char '\\') parseit) <|> (do char '_'; return 0)
08:17:02 <kpreid> smg: I think that should do it, with the only difference being that it will parse ""
08:17:43 <smg> hrhr
08:17:46 <smg> fmap maximum
08:17:53 <kpreid> @type fmap maximum
08:17:54 <lambdabot> forall a (f :: * -> *). (Functor f, Ord a) => f [a] -> f a
08:18:26 <smg> wait wait that kills me :)
08:18:28 <kpreid> so it just takes maximum of the list from many1
08:18:50 <kpreid> I use fmap becaue many1 returns a parser-returning-list, not a list
08:18:51 <smg> wtf is bracket?
08:19:03 <kpreid> @type Text.ParserCombinators.Parsec.bracket
08:19:10 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.bracket'
08:19:12 <kpreid> hm
08:19:14 <smg> ah :)
08:19:15 <quicksilver> bracket is a parsec builtin for bracketed stuff
08:19:16 <kpreid> I may have the name wrong
08:19:28 <kpreid> bracket a c b parses a,b,c but returns the value of b
08:19:37 <mauke> char '/' *> parseit <* char '\\'
08:19:42 <mauke> <3
08:19:49 <quicksilver> "between"
08:19:50 <quicksilver> it's called.
08:19:56 <kpreid> @type Text.ParserCombinators.Parsec.between
08:19:58 <lambdabot> forall tok st open close a. Text.ParserCombinators.Parsec.Prim.GenParser tok st open -> Text.ParserCombinators.Parsec.Prim.GenParser tok st close -> Text.ParserCombinators.Parsec.Prim.GenParser tok
08:19:58 <lambdabot> st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
08:20:01 <kpreid> quicksilver: thanks
08:20:04 <kpreid> lambdabot: no thanks
08:20:12 <quicksilver> I prefer mauke's version though
08:20:19 <quicksilver> *> and <* ftw
08:20:28 <kpreid> @where (*>)
08:20:28 <lambdabot> I know nothing about (*>).
08:20:30 <kpreid> @where *>
08:20:31 <lambdabot> I know nothing about *>.
08:20:34 <quicksilver> Control.Applicative
08:20:37 <kpreid> ah
08:20:38 <maltem> (1+) <$> char '/' *> parseit <* char '\\', even
08:20:43 <Arnar_> hey guys..
08:20:46 <kpreid> @type (*>)
08:20:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:20:53 <kpreid> @type (<*)
08:20:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:21:13 <quicksilver> matthew-_: char '/' *> ( (1+) <$> parseit ) <* char '\\'
08:21:14 <kpreid> interesting
08:21:19 <quicksilver> maltem: IMO that's nicer.
08:21:22 <quicksilver> matthew-_: sorry :)
08:21:26 <Arnar_> I just posted a short blog on parsec parsing, I'd appreciate it if someone would look over and see if they see major areas for improvement
08:21:26 * quicksilver curses tab key
08:21:44 <maltem> ah ok :)
08:21:51 <Arnar_> I'm not soliciting traffic (there are no ads), but here's the link: http://www.hvergi.net/2008/06/parsing-json-with-haskell/
08:21:53 <lambdabot> Title: /dev/collective  Blog Archive  Parsing JSON with Haskell
08:21:58 <maltem> I don't even know whether my version has right precedence
08:22:35 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8562#a1
08:22:43 <smg> i have now this hrhr :D
08:22:44 <mauke> @index (<*)
08:22:45 <lambdabot> bzzt
08:22:53 <quicksilver> maltem: me neither :)
08:23:08 <quicksilver> maltem: btu I'd probably use parens to be sure, in this case.
08:23:55 <kpreid> smg: that won't work because you're discarding doZ inside the second case of doP. I really suggest using a different version of the grammar; this one is very messy
08:24:09 <kpreid> it appears to be going to lengths to avoid empty productions(?)
08:24:17 <kpreid> but parsec doesn't mind them
08:24:27 <smg> kpreid: hrhr but it works
08:24:32 <maltem> quicksilver: aha, both (<$>) and (<*) are infixl 4, so I would have been in a need of parens too
08:24:43 <kpreid> smg: try it on /\_
08:25:06 <kpreid> er
08:25:17 <kpreid> try it on /\//\\_
08:25:26 <smg> *Main> height "/\\_"
08:25:26 <smg> Max height: 1
08:25:43 <smg> *Main> height "/\\//\\\\_"
08:25:43 <smg> Max height: 2
08:25:54 <kpreid> hum...oh
08:26:05 <kpreid> try this: //\_\
08:26:08 <smg> k
08:26:39 <maltem> kpreid: I suppose the right side of doP will never chime in?
08:26:41 <gwern> > any $ filter (<1) [1..]
08:26:43 <lambdabot>  Couldn't match expected type `a -> Bool'
08:26:50 <smg> kpreid: this fails, why?
08:27:13 <maltem> kpreid: Because doZ is necessary
08:27:17 <smg> k
08:27:22 <gwern> @hoogle any
08:27:23 <kpreid> smg: fails to parse or fails to give the right answer?
08:27:23 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
08:27:23 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
08:27:23 <lambdabot> Data.Foldable.any :: Foldable t => (a -> Bool) -> t a -> Bool
08:27:24 <tromp> @let x=0
08:27:25 <lambdabot> Defined.
08:27:27 <maltem> ah, wrong moment to hit the return key
08:27:29 <tromp> > x :: Int
08:27:30 <lambdabot> Terminated
08:27:44 <tromp> :t x
08:27:45 <gwern> > any (<1) [1..]
08:27:47 <lambdabot>     Ambiguous occurrence `x'
08:27:47 <lambdabot>     It could refer to either `L.x', defined at <local>:17:0
08:27:47 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/imports.h:71:0-32
08:27:54 <byorgey> hi Arnar_
08:27:54 <maltem> kpreid: I mean, because doZ is necessary for doZ >> doP
08:27:56 <lambdabot>  Exception: Time limit exceeded
08:28:04 <smg> kpreid: fails to parse
08:28:05 <tromp> @let xxx=0
08:28:06 <lambdabot> Defined.
08:28:08 <gwern> > any (>1) [1..]
08:28:09 <tromp> :t xxx
08:28:09 <lambdabot>  True
08:28:11 <lambdabot> forall t. (Num t) => t
08:28:19 <tromp> > xxx::Int
08:28:20 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
08:28:51 <mauke> > [x]
08:28:51 <lambdabot> Terminated
08:28:58 <mauke> @define
08:28:59 <lambdabot> Undefined.
08:29:04 <kpreid> smg: I don't recall parsec's parsing strategy well enough to explain the problem well
08:29:22 <kpreid> but I think the problem is that you have try x <|> x >> ...
08:29:32 <gwern> hm, any is lazy like I thought. good
08:30:00 <kpreid> smg: a correct version of doP is just many1 doZ, so you don't need it at all; parseit does the same thing
08:30:18 <kpreid> smg: really, use the version I gave you; it is much less twisty
08:30:29 <kpreid> this is overcomplicated and hard to think about
08:30:59 <gwern> I'm kind of curious, anyone know what ObjectIO is and why GHC needs to support it especially?
08:31:21 <quicksilver> gwern: http://www.haskell.org/ObjectIO/ I presume
08:31:21 <lambdabot> Title: Object I/O for Haskell
08:32:12 <gwern> ...weird. does anyone even use it?
08:32:25 <gwern> I think the only places I've seen it mentioned before is the ghc build files
08:33:31 <audreyt> it's a port of the ObjectIO UI from Clean
08:33:51 <byorgey> Arnar_: looks nice!
08:34:00 <byorgey> Arnar_: personally, I'm partial to using Parsec with an Applicative instance, but there's nothing wrong with using the monadic interface.
08:34:07 * gwern can read, but that doesn't explain why it's given especial treatment or why it's even there if no one uses it
08:34:30 * EvilTerran finds that Applicative suits Parsec very well, too
08:34:36 <EvilTerran> *> and <* are particularly useful
08:34:42 <audreyt> because it predates most of other GUI/HS attempts?
08:34:58 <EvilTerran> it'd be nice if it used Alternative's <|>
08:35:05 <audreyt> (i.e., it's given special treatment because it was the only one, and noone uses it because there are more modern alternatives?)
08:35:20 <gwern> so sheer lazy inertia is the reason it's still around?
08:35:23 <gwern> that's a reason, I suppose, but not a good one obviously
08:35:46 <audreyt> it's also the reason for rts/dotnet/.
08:36:02 <gwern> audreyt: incidentally, pugs now builds for me. I have no idea what to do with it, but it does install :)
08:36:14 <audreyt> whee :)
08:37:00 * EvilTerran tries to remember the proposed distinction between Additive/(<+>) and Alternative/(<|>)
08:37:04 <audreyt> dunno... you can try
08:37:09 <audreyt> pugs -e 'say [*] 1..10'
08:37:12 <audreyt> and confuse your friends?
08:37:15 <gwern> audreyt: I was kind of wondering, what made you restart your pugs involvement? I was under the impression that you had more or less decamped for a year or so
08:37:26 <audreyt> I was very ill.
08:37:35 <audreyt> hepatitis and burnout in general
08:37:40 <monochrom> Food additives yummy.
08:37:49 <audreyt> I'm now less ill. that's all :)
08:37:52 <EvilTerran> i think the distinguishing property for <|> was idempotence... can't remember the one for <+>, though
08:38:17 <gwern> hepatitis, ouch. (but wait, iirc wasn't that chronic and incurable? better go read WP)
08:38:22 <audreyt> gwern: for about one year I can't focus for more than 30min period without collapsing...
08:38:23 <quicksilver> EvilTerran: probably either commutativity, or nothing?
08:38:32 <monochrom> <+> is commutative group IIUC
08:38:36 <smg> <kpreid> parseit = fmap maximum $ many1 tree; tree = (fmap (1+) $ bracket (char '/') (char '\\') parseit) <|> (do char '_'; return 0)
08:38:45 <ziman> @hoogle CReal
08:38:45 <lambdabot> No matches found
08:38:49 <Saizan_> isn't it the same distinction as MonadOr and MonadElse?
08:39:08 <byorgey> audreyt: wow.  glad you are less ill now!
08:39:23 <Arnar_> byorgey: hey, thanks for looking at my post..
08:39:35 <EvilTerran> quicksilver, monochrom: but wouldn't commutativity mean that (++) wouldn't fit (<+>)?
08:39:38 <Arnar_> byorgey: what do you mean by "applicative" here?
08:39:39 <audreyt> gwern: fortunately I'm among the curable ones using modern medicine (Lamivudine).
08:39:59 <monochrom> Oh oops. I may be wrong then.
08:40:04 <byorgey> Arnar_: I mean using an instance of Control.Applicative
08:40:13 <EvilTerran> i think it may've been something involving distrobution over <*>
08:40:24 * Arnar_ has a feeling he's about to learn something cool now..
08:40:29 <EvilTerran> *distributivity
08:40:36 <byorgey> Arnar_: hold on, I will find you some links
08:40:56 <quicksilver> Arnar_: many monadic uses of parsec take the following form:
08:41:00 <gwern> 'Lamivudine has been used for treatment of chronic hepatitis B at a lower dose than for treatment of HIV. It improves the seroconversion of e-antigen positive hepatitis B and also improves histology staging of the liver. Long term use of lamivudine unfortunately leads to emergence of a resistant hepatitis B virus (YMDD) mutant. Despite this, lamivudine is still used widely as it is well tolerated.' <-- interesting
08:41:13 <quicksilver> Arnar_: do { a <- aprod; b <- bprod; c <- cprod; return (Foo a b c) }
08:41:20 <quicksilver> Arnar_: look familiar?
08:41:47 <Arnar_> quicksilver: yes :)
08:41:56 <quicksilver> Arnar_: it has been observed that to do this does not require the full force of monad. YOu can do it using a weaker/more general notioan called "Applicative"
08:42:00 <Arnar_> I was actually thinking "there must be a better way"
08:42:02 <audreyt> gwern: yes, but I was using it at the activation, so as a result I'm not even chronic :)
08:42:02 <EvilTerran> another example: using Control.Applicative, (between (sym "[") (sym "]") (commaSep lexer value)) could be written as (sym "[" *> commaSep lexer value <* sym "]")
08:42:05 <byorgey> Arnar_: http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
08:42:06 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  The basics of applicative functors,  ..., http://tinyurl.com/2lrb68
08:42:11 <Arnar_> byorgey: thanks
08:42:19 <quicksilver> and you would write "Foo <$> aprod <*> bprod <*> cprod"
08:42:30 <quicksilver> which is simpler-looking.
08:42:53 <Arnar_> awesome..
08:42:53 <byorgey> of course, you could also write that as liftM3 Foo aprod bprod cprod
08:43:03 <EvilTerran> keyValue = (,) <$> stringLiteral lexer <*> (sym ":" *> value)
08:43:03 <gwern> audreyt: still, that's good. people were pointing at pugs as an example of a large haskell project failing, which given roundy burning out on darcs, was really bad publicity we could do without
08:43:07 <Arnar_> right.. like I did
08:43:22 <byorgey> but the *> and <* stuff in particular is also a reason to use Applicative
08:43:25 <EvilTerran> etc
08:43:34 <audreyt> gwern: haskell _does_ cause burnouts easier than other languages
08:43:48 <audreyt> gwern: abstraction leads to insanity, you know...
08:43:57 <EvilTerran> (*>) for applicative behaves the same as (>>) for monad
08:44:14 <EvilTerran> and (<*) acts like liftM2 const
08:44:22 <audreyt> "Haskell: Executable Abstract Nonsense"
08:44:50 <EvilTerran> x <* y = "run x, then run y, returning the result of x"
08:45:19 <gwern> audreyt: yeah, but I think we know how to manage things now, there are a few principles: break stuff out to libs as far as possible; let cabal/hackage handle packaging/distribution; maintain a good suite of QC tests; and fight cruft as much as possible. it's working out very well for xmonad so far
08:45:51 <quicksilver> the problem is once you've caught the abstraction bug
08:45:55 <Arnar_> thanks byorgey++ quicksilver++ EvilTerran++ :)
08:46:00 <quicksilver> you are forever looking at your code thinking...
08:46:09 <kpreid> btw, I was thinking Parsec had a 'bracket' combinator probably because of the other 'bracket's...
08:46:14 <kpreid> @hoogle bracket
08:46:15 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:46:15 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
08:46:15 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:46:30 <quicksilver> "actually this is a special case of something more general and more beautiful"
08:46:34 <pejo> gwern, isn't xmonad much much smaller than darcs/pugs?
08:46:35 <gwern> Text.ParserCombinators.Parsec.Token.brackets
08:46:38 <quicksilver> sadly that turns out to be *always* true.
08:46:43 <dino-> audreyt: (reading back) Wow, sorry to hear about that illness. I'm glad you're doing better!
08:46:44 <audreyt> gwern: with due respect, hacking xmonad doesn't quiet resemble hacking advanced type systems...
08:46:51 <visof> can i show the source code of the functions from ghci ?
08:46:52 <quicksilver> infinite recursion into beauty.
08:46:59 <visof> or how can i do this?
08:47:17 <audreyt> gwern: but yes, I agree. one of the things I'm doing for pugs is simply partitioning into small (and hopefully reusable to other projects, like stringable-atom) cabal packages.
08:47:23 <gwern> pejo: we're at 10k lines for everyone, last I heard, which is pretty substantial
08:47:25 <kpreid> audreyt: if abstraction leads to insanity, then we're all doomed
08:47:37 <gwern> and it's written by all sorts of authors
08:47:52 <EvilTerran> quicksilver, it's better than always looking at your code thinking "actually, this is a special case of something more general and more beautiful, but i can't implement it as such because i'm not using haskell at the moment"
08:48:12 <quicksilver> EvilTerran: better? Yes. More productive? I'm not sure :)
08:48:36 <quicksilver> given the choice between productivity and infinite descent into beauty, I choose the latter.
08:48:40 <EvilTerran> it is if that makes you want to spend several hours trying to embed the haskell type system in whatever language you're using
08:48:43 <audreyt> kpreid: "And, isn't sanity really just a one-trick pony anyway? I mean all you get is one trick, rational thinking, but when you're good and crazy, oooh, oooh, the sky is the limit..."
08:48:49 <pejo> The perfect is the enemy of the good.
08:48:55 <monochrom> abstraction leads to insanity. insanity leads to discovery (or creativity). we are so not doomed.
08:48:58 <gwern> audreyt: I realize that, but advanced type stuff is often dangerous. look at darcs - I'm sure it's been damaged by roundy & co trying out the advanced type witness hackery
08:49:23 <audreyt> *nod*
08:49:23 <byorgey> quicksilver: ITYM infinite ascent =)
08:49:34 <gwern> I mean, you can't even compile darcs on 6.8.x
08:49:40 <audreyt> sadly perl6 itself has one of the most sophisticated and less-than-rigorous type systems out there
08:49:45 <audreyt> so there's no avoiding it either way...
08:49:58 <gwern> and this fact has necessitated a ton of complexity just in build scripts and CPP directives and includes and bug reports...
08:50:11 <audreyt> what, darcs is 6.9-only nowadays?
08:50:14 <audreyt> type families?
08:50:17 <audreyt> or view patterns?
08:50:48 <gwern> audreyt: no, it's possible to strip out all the type witness stuff by way of 'build scripts and CPP directives...' and compile it normally
08:51:08 <audreyt> I'd say CPP directives are even more brain damaging than advanced type systems...
08:51:09 <gwern> roundy develops it using 6.6 where apparently the witnesses work, and I don't know how it deals with 6.9/6.10
08:51:22 <thetallguy> ?seen conal
08:51:22 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
08:51:25 <byorgey> audreyt: heh, hear hear!
08:51:46 <gwern> and even worse, the record hook? it uses type witnesses in the build
08:51:56 <audreyt> oy.
08:52:10 <gwern> so every so often, the bug tracker sees a bug: 'Hey, uh, guys, darcs compiles fine for me, but I went to record a patch......'
08:52:27 <Arnar_> kpreid: thanks for pointing out brackets.. changed the post..
08:52:54 <audreyt> gwern: in any case, pugs needs to wait for ghc 6.10 for the next major milestone
08:53:00 <audreyt> gwern: because all my new code is using QQs
08:53:09 <audreyt> and there's just no way to emulate it without QQs
08:53:22 <audreyt> so you can say I'm in the same trap here...
08:53:24 <gwern> QQs?
08:53:25 <pejo> audrey, quasi quotes?
08:53:27 <audreyt> yeah.
08:53:28 <Feuerbach> Which array types provide O(1) updates?
08:53:29 <EvilTerran> "We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold."
08:53:30 <gwern> quasi-quotation, I take it
08:53:41 <audreyt> (a patch is available against ghc 6.8.3.)
08:54:06 <RayNbow> Feuerbach: there are probably several
08:54:17 <gwern> EvilTerran: "Of the nefandous hylomorphisms which they gibbered of, the rugose identities unfolded, I dare speak not!"
08:54:19 <RayNbow> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
08:54:20 <lambdabot> http://tinyurl.com/2288uq
08:54:32 <conal> thetallguy: hi
08:54:32 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
08:54:44 <mauke> preflex: remember EvilTerran "We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold."
08:55:19 <audreyt> o/~ the phantom of the typesystem is here o/~
08:55:25 * gwern thought my contribution was even more lovecraftian :( I even used 'rugose'! what more do you want, dammit
08:55:27 <EvilTerran> gwern, er, i'm paraphrasing the opening lines of Fear and Loathing... what're you quoting?
08:56:08 <gwern> (oh good grief. I keep telling myself I need to read/watch that, and I keep putting it off, and this is what it gets me >.<)
08:56:28 <EvilTerran> i just watched it last night, so my head is full of lines from it
08:57:04 <EvilTerran> (lines of script, not lines of, er, powder. honest.)
08:57:43 <gwern> all I know about fer and loathing is that it has something to do with bats. and drugs.
08:58:27 <Feuerbach> RayNbow: what about DiffArray? AFAIU (//) takes O(n) time, where n is size of array
08:59:24 <mauke> :t (//)
08:59:25 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
08:59:26 <Feuerbach> but it is stated to be as efficient as mutable arrays..
08:59:35 <quicksilver> the rumour is that the constant factors are so high that in fact DiffArray is always slower than the pure alternative
08:59:42 <mauke> should be O(m) where m == length updates
08:59:46 <quicksilver> although its algorithmic complexity may be better.
08:59:51 <monochrom> @remember audreyt o/~ the phantom of the typesystem is here o/~
08:59:51 <lambdabot> It is forever etched in my memory.
09:00:27 <quicksilver> Feuerbach: all the array types which permit updates at all (i.e. all the mutable ones) have O(1) update
09:00:34 <audreyt> @remember audreyt o/~ the phantom of the typesystem is here / inside my mind! o/~
09:00:34 <lambdabot> Done.
09:00:34 <quicksilver> of a single cell, that is.
09:01:03 <quicksilver> Feuerbach: however, free your thoughts from O(1), for it does not exist.
09:01:17 <quicksilver> instead worry about good algorithms for your actual problems.
09:01:41 <Feuerbach> quicksilver: but C arrays are certainly O(1)?
09:01:43 <oldsalt> how do i install modules with profiling support via cabal?ß
09:01:50 <quicksilver> Feuerbach: no, there is no O(1).
09:01:52 <dcoutts_> oldsalt: -p
09:01:53 <gwern> only when they are sufficiently small
09:01:57 <gwern> oldsalt: configure -p?
09:02:03 <monochrom> O(1) exists. Just not in reality.
09:02:07 <quicksilver> Feuerbach: C arrays are O(log n) like all other structures.
09:02:09 <Feuerbach> mauke: thanks, I've probably misread it. Now I see it's O(d)
09:02:12 <monochrom> O(1) exists mathematically.
09:02:21 <dcoutts_> oldsalt: for future reference consult --help, it has a full list
09:02:39 <oldsalt> it says
09:02:42 <oldsalt> Setup.hs: Unrecognised flags:
09:02:42 <oldsalt>  -p
09:02:54 <monochrom> Or turn it around. O(1) is the only reality. O(n), O(log n), ... don't exist in reality.
09:03:00 <quicksilver> ;)
09:03:11 <quicksilver> my way around is more useful.
09:03:29 <quicksilver> it's very relevant to distinguish between n^2, n and 1.
09:03:32 <gwern> oldsalt: 'runhaskell Setup configure -p' is failing for you?
09:03:41 <monochrom> Either way you expose much hypocrisy of the performance freaks.
09:03:57 <oldsalt> yes
09:04:27 <Feuerbach> ok, another question: what is more efficient on updates, Array.Diff or Sequence?
09:04:37 <quicksilver> Sequence almost certainly.
09:04:38 <oldsalt> oh, now it works, i tried it with a different package
09:04:52 <oldsalt> thank you
09:05:37 <EvilTerran> i don't trust DiffArrays. i'd be more inclined to use STArrays, if i was sure i wanted a mutable array
09:05:55 <gwern> oldsalt: incidentally, profiling is an all or nothing deal - if you want package foo profiled, every package it uses need to have been installed profiling (and so on recursively)
09:06:15 <oldsalt> yes i know, think i started with the wrong package
09:06:50 <RayNbow> hmm, quicksilver, what structure would you recommend for an in-place perfect shuffle algorithm?
09:07:35 <EvilTerran> if it must be in-place, you'll need some kind of mutable structure - i'd recommend STArray
09:07:45 <dolio> Seconded.
09:07:55 <quicksilver> RayNbow: if your intention is to demonstrate the standard imperative approach, then I agree.
09:08:06 <quicksilver> A mutable array is the correct data structure for that algorithm
09:08:19 <EvilTerran> well, i'd write MArray-generic code
09:08:33 <quicksilver> of course if you just want a perfect shuffle then you should see oleg's code
09:08:39 <quicksilver> which is a functional perfect shuffle :)
09:08:44 <RayNbow> I know about oleg's version :)
09:08:55 <RayNbow> or well, I skimmed his article
09:09:00 <RayNbow> didn't read it in details yet
09:10:35 <smg> wiki: ll-parser
09:11:52 <quicksilver> just like a mutable array is the correct data structyre if you want to demonstrate the imperative quicksort.
09:12:09 <quicksilver> but the fact that mutable arrays are the right data structure for these toy demonstrations
09:12:37 <quicksilver> doesn't actually mean that they are the right structure for many useful, practical algorithms.
09:12:49 <quicksilver> they are for some, certainly.
09:14:19 <monochrom> Ha, quicksort considered "toy", Tony will be so hurt. :)
09:20:22 <smg> hey quicksilver how are you
09:24:20 <quicksilver> I'm ok thanks. How are you?
09:26:02 <smg> quicksilver: good good, you did help me very good days ago. :]
09:28:41 <Si> Does anyone know off-hand what the type theoretic reason behind type-class instance parameters not being permitted of the form "forall a . SomeClass a => a -> b" ?
09:29:37 <quicksilver> "type-class instance parameters" ?
09:29:45 <quicksilver> what do you mean?
09:29:49 <Si> err, let me rephrase that
09:30:07 <Si> i.e. instance Eq (forall a . SomeClass a => a -> b)
09:30:31 <quicksilver> that woudl be equivalent to
09:30:48 <quicksilver> instance SomeClass a => Eq (a -> b)
09:31:00 <opqdonut> mhmm
09:31:10 <quicksilver> which is legal with flexible instances as far as I know.
09:31:13 <opqdonut> since the implementation doesn't know anything else than the SomeClass constraint on a
09:31:26 <quicksilver> it might not mean what you hoped, of course.
09:31:51 <quicksilver> if you were hoping for an existential, then the answer is it's fine but you have to bury the existential in a type.
09:32:05 <Si> yes, I know, that's what I'm doing
09:32:20 <Si> just wondering why it wasn't directly possible
09:32:49 <quicksilver> because the parser / type inferrer needs to know where the existential stops and the value starts
09:32:54 <quicksilver> which is what the constructor does
09:33:01 <quicksilver> you could imagine special syntax for this instead.
09:34:32 <quicksilver> Si: for example, consider (), which is an instance of Show.
09:35:02 <quicksilver> and data Showable = forall a . Show a => MkShowable a
09:35:41 <quicksilver> how can ghc distinguish  between () as (), and () as a Showable?
09:35:51 <quicksilver> does the term "()" no longer have a unique type?
09:36:05 <quicksilver> after all, () is obviously, in some sense, an instance of exists a . Show a
09:36:17 <quicksilver> the answer we take is to force the use of constructor
09:36:21 <quicksilver> so () :: ()
09:36:27 <quicksilver> and (MkShowable ()) :: Showable
09:36:38 <quicksilver> that way we don't have to give up principle types
09:36:40 <quicksilver> and such nice things.
09:38:51 <Si> and that goes the same for functions, e.g. forall a . Class a => a -> a?
09:42:14 <quicksilver> Si: well the argument is the same in each case.
09:42:31 <quicksilver> Si: we need a way to distinguish term-as-existential and term-as-particular-type
09:42:48 <quicksilver> Si: the constructor is a convenient syntactic hook to hang that on.
09:42:54 <Si> ok, thanks
09:43:07 <quicksilver> you can certainly imagine systems which don't do this
09:43:12 <quicksilver> but it makes type inference pretty hairy
09:43:22 <quicksilver> each term has many many possible interpretations
09:43:32 <LordBrain> system's which don't do what?
09:43:32 <ragadab> dcoutts_ - it works - i install binary from haskell site
09:43:35 <quicksilver> depending on how many of its "aspects" you existential
09:43:44 <dcoutts_> ragadab: great!
09:43:52 <dolio> Daan Leijen's paper First-class Polymorphism with Existential Types describes alternate system.
09:43:53 <quicksilver> LordBrain: require an explicit tag to signal an existential term.
09:44:06 <dcoutts_> ragadab: where was the previous binary from? we should tell the people who made it that it does not work fully.
09:44:11 <ragadab> dcoutts_: thank you for
09:44:11 <quicksilver> dolio: does it cover typeclasses? I have a feeling they make it worse.
09:44:17 <quicksilver> dolio: maybe not in an important way.
09:44:26 <LordBrain> anyone have haddock working with ghc 6.8.2 ?
09:44:33 <dolio> It just never infers something as existential unless it's specifically annotated as such (or, some sub-term is so annotated).
09:44:40 <dolio> No, it doesn't do type classes.
09:44:42 * quicksilver nods
09:44:44 <ragadab> dcoutts_: from ubuntu repo, i will send bug
09:44:50 <quicksilver> that seems reasonable.
09:45:05 <quicksilver> the GHC solution minimises annotations.
09:45:08 <dolio> He worked with SPJ to try to add first-class existentials to GHC at a time, didn't he?
09:45:18 <dolio> And SPJ decided it was too complicated.
09:45:23 <quicksilver> (but that does not extend to universals, of course)
09:45:49 <quicksilver> dolio: I have certainly seen him say that it would require adding a specific existential into Core, and he considered it and didn't think it was worth it.
09:46:07 <quicksilver> him = SPJ there.
09:46:32 <dolio> That paper is pretty alluring, but I don't use existentials much as it is.
09:46:45 <dolio> So yeah, I don't know how worth it it'd be.
09:46:55 <quicksilver> I don't find the constructor is a big problem.
09:47:10 <quicksilver> it's a bit weird when you can't abstract patterns you expect to be able to abstract.
09:47:24 <quicksilver> [MkFoo a,MkFoo b,MkFoo c] is not the same as map MkFoo [a,b,c]
09:47:28 <quicksilver> that's a bit weird/annoying.
09:48:06 <LordBrain> [a,b,c] would be a heterogenous list?
09:48:52 <quicksilver> LordBrain: well yes, in that example it's "trying to be"
09:49:03 <quicksilver> and of course you're not allowed that in haskell, so it unifies them all to the same type.
09:49:19 <LordBrain> oh i see what you are talking about
09:49:31 <quicksilver> looking at the language purely syntatically, it's strange not to be able to apply a familiar transformation
09:49:42 <quicksilver> [f a,f b,f c] -> map f [a,b,c]
09:49:55 <LordBrain> yes
09:50:04 <quicksilver> may not be valid for polymorphic f
09:50:34 <quicksilver> this problem is not unique to existentials, but existential constructors are an example of such polymorphism.
09:52:17 <LordBrain> the real issue there is the lack of a heterogenous list
09:52:25 <quicksilver> maybe it is, maybe it isn't.
09:52:37 <quicksilver> maybe it's the lack of a heterogenous "map"
09:52:44 <quicksilver> there is a heterogenous list in the prelude
09:52:51 <quicksilver> (a,(b,(c,()))) :P
09:53:09 <hackage> New hackage package: Shu-thing 1.1.1
09:53:09 <hackage> New hackage package: zipedit 0.2.3
09:53:09 <hackage> New hackage package: chp 1.0.2
09:53:09 <hackage> New hackage package: Monadius 0.92
09:53:09 <hackage> New hackage package: mueval 0.3.1
09:53:09 <LordBrain> hmmm yeah, but if we use that we should sugar it up!
09:53:11 <dolio> Whereas with first-class existentials you get to say: 'map (f :: forall a. a -> b) ([a, b, c] :: [exists a. a]) :: [b]
09:53:28 <quicksilver> dolio: precisement.
09:53:44 <quicksilver> dolio: actually the annotation on f is hopefully not necessary.
09:53:55 <dolio> Right. I just put it there to be clear.
09:54:52 <LordBrain> hmm i'm not familiar with exists a. a
09:55:05 <byorgey> LordBrain: it's pseudo-haskell
09:55:33 <LordBrain> that might explain why i'm not familiar with it :)
09:57:00 <dolio> To do it in actual haskell you'd have to do 'data Top = forall a. T a ; map (f :: Top -> b) ([T a, T b, T c] :: [Top])'
09:57:03 <dolio> Or something of the sort.
09:57:29 <dolio> Although the annotations would be totally unnecessary in that case.
09:57:32 <quicksilver> LordBrain: and that's what HList is.
09:57:32 <quicksilver> LordBrain: sugared-up tuples, with a network of clever TCs.
09:57:32 <quicksilver> and it has a heterogenous fold.
09:57:32 <quicksilver> and I think map?
09:57:34 <dolio> Which is rather the point.
09:57:51 <LordBrain> hlist doesn't come with ghc tho
09:57:54 <LordBrain> :)
09:58:12 <LordBrain> maybe it should
09:59:10 <dolio> I think we're moving away from the 'everything comes with GHC' model.
09:59:18 <LordBrain> oh
10:00:16 <dcoutts_> yep
10:00:32 <dcoutts_> but we're going to have platform releases as well
10:00:44 <LordBrain> platform releases?
10:01:09 <dcoutts_> the whole collection of packages needed for haskell development
10:01:15 <dcoutts_> ie ghc + standard libs and tools
10:01:37 <LordBrain> we don't have that already?
10:01:46 <dcoutts_> but platform releases do not need to be synchronised with ghc releases, in fact it's much harder if they are synchronised
10:01:59 <dcoutts_> LordBrain: sort of but it's too hard to manager
10:02:02 <dcoutts_> manage
10:02:12 <LordBrain> you  mean, like a mac os x haskell platform release?
10:02:14 <dcoutts_> and it's missing lots of useful libs and comes with few tools
10:02:24 <dcoutts_> right, but for each major platform
10:02:37 <dcoutts_> eg, ghc releases do not bundle alex, happy, haddock
10:02:38 <LordBrain> hmm
10:02:45 <LordBrain> right
10:02:47 <dcoutts_> yet they're part of the standard toolchain right?
10:02:56 <LordBrain> speaking of which... i'm having trouble with haddock
10:03:06 <dcoutts_> so we want the platform to be ghc + a blessed set of packages from hackage
10:03:26 <LordBrain> everythign you need to compile ghc?
10:04:06 <LordBrain> that sounds good
10:04:26 <glguy> So the difference is that fewer packages will be included in a GHC "release" bundle?
10:04:45 <dcoutts_> glguy: right, just ghc and the libs needed to bootstrap it
10:05:02 <glguy> freeing up the libraries to move independently
10:05:10 <glguy> like the great breakup of X?
10:05:23 <dcoutts_> glguy: we've pretty much done that already
10:05:26 <LordBrain> so.. ghc will make a release... then we wait for it to get integrated into the platform release... and then we upgrade?
10:05:32 <dcoutts_> glguy: current ghc release don't include that much
10:05:43 <glguy> Right, I'm just trying to understand what's changing
10:05:47 <dcoutts_> LordBrain: right
10:06:01 <dcoutts_> glguy: the thing is, currently we get a lot of lib releases synchronised with ghc
10:06:05 <dcoutts_> and that's hard to manager
10:06:16 <dcoutts_> it slows down ghc releases
10:06:22 <BMeph> dcoutts_: So how will TH fit into this scheme?
10:06:26 <Botje> "what are we going to do tonight, brain?" "same thing we do every night, pinky: put out a new release bundle!"
10:06:27 <LordBrain> kind of like debian... there is an upstream release.. then we wait for it to get into unstable or testing or whatever we are using...
10:06:42 <glguy> I can't wait years
10:06:46 <dcoutts_> LordBrain: more like the relationship between Gtk+ and GNOME
10:07:09 <dcoutts_> Gtk+ has >9 month release cycles while GNOME has independent 6 month release cycles
10:07:16 <glguy> So if GHC:Gtk+::GNOME:?
10:07:23 <glguy> errrr
10:07:27 <glguy> So if GHC:Gtk+::?:GNOME
10:07:40 <dcoutts_> glguy: the haskell platform releases
10:07:51 <glguy> What what will it be *called* :)
10:07:58 <glguy> haskell-platform-release-1.2.3?
10:07:58 <dcoutts_> we don't have a specific name yet
10:08:01 <LordBrain> ghc:platform::gtk+:gnome
10:08:24 <dcoutts_> glguy: and as for version numbers, it might make more sense to use dates
10:10:45 <LordBrain> i do prefer numbers to catchy tags like 'woody' or 'gutsy'
10:10:49 <LordBrain> hehehe
10:11:54 <LordBrain> we could have a 12-month release cycle for platforms and call it haskell-platform-2008
10:13:02 <dcoutts_> 12 months is too long I think
10:13:08 <dcoutts_> GNOME seems to have got this right
10:13:18 <LordBrain> alright
10:13:32 <dcoutts_> they are so good at doing releases now that they've become really boring :-)
10:13:46 <dcoutts_> they just work, no overruns
10:15:27 <jamii> cabal: There is no package named happs-tutorial
10:15:28 <LordBrain> well maybe we can find some alternative calendar system which happens to have approximately 6 months to a year
10:15:35 <jamii> Lies, i tell you, lies
10:15:46 <dcoutts_> jamii: update the list of packages first
10:16:06 <dcoutts_> LordBrain: gentoo uses 2007.0 2007.1 etc
10:16:11 <jamii> Ah. Thanks
10:16:14 <dcoutts_> jamii: ie cabal update
10:21:44 <LordBrain> maybe we should line it up with universities on the semester system
10:25:02 <EvilTerran> LordBrain, could use the discordian calendar, that's got five seasons
10:25:13 <LordBrain> 2007fall, 2007spring
10:25:39 <EvilTerran> 2007beaurocracy
10:25:53 <LordBrain> oh, and a short summer cycle, for those people doing the google summer of code
10:26:04 <EvilTerran> 2007aftermath
10:26:20 <LordBrain> i dont think 2007.1 is any less beaurocratic than 2007fall
10:27:56 <LordBrain> we should base it all on whatever glasgow university uses
10:27:59 <LordBrain> lol
10:30:41 <EvilTerran> seasons would work well
10:31:03 <EvilTerran> maybe skewed a bit so autumn/winter/spring line up with university terms
10:37:43 <LordBrain> hmm maybe should do it by holidays, a christmas release would be cool... like a big present
10:40:39 <EvilTerran> call the releases christmas, easter, exams, and matriculation ;)
10:43:02 <paolino> ice, flowers,cheese,monsoon
10:45:14 <bitrot> how about sync the releases with Dogfish Head's 120 IPA releases?
10:46:33 <Saizan_> ?where lambdabot
10:46:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:46:41 <Saizan_> ?version
10:46:41 <lambdabot> lambdabot 4p664, GHC 6.8.2 (Linux i686 2.40GHz)
10:46:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:47:27 <LordBrain> when was haskell curry's birthday?
10:47:56 <Deewiant> 1900-09-12
10:48:13 <LordBrain> hmmm
10:51:50 <ziman> i have 3x78 + 1x280 MB image files and I need to gather some statistics over them (like, Σx², Σxy, ...). I used lazy bytestrings + hGetContents and foldl'-ed over them. however, the program seems to eat all available memory and then it gets killed. Is there a strategy to carry out this without being explicitly procedural in IO? (or other concise way)
10:51:51 <LordBrain> hmmm ghc's first beta release was on april fools day
10:52:17 <LordBrain> we could do two releases, april fools and christmas
10:52:51 <LordBrain> but the april fools ones would always be java.
10:53:09 <hackage> New hackage package: hburg 1.1.2
10:54:14 <dons> ziman: how are you compiling it?
10:54:44 <dons> ziman: if in doubt, i'd write an recursive loop over the input first.
10:55:09 <dons> ziman: see e.g. the sum-file benchmark on the shootout
10:55:23 <dons> ziman: or this kind of thing, http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
10:55:24 <lambdabot> Title: Haskell hacking
10:59:05 <vixey> I was thinking about writing a tutorial about something
10:59:29 * vixey wonders if she knows anything that could be useful to others..
10:59:34 <nowhea> monads
10:59:39 <nowhea> :-P
10:59:42 <vixey> hehe
11:00:00 <sclv_> functors
11:00:07 <sclv_> trees
11:00:12 <vixey> well I was thinking about doing a simple programming language tutorial with a type system, .. but I don't know if it would be good
11:00:56 <vixey> oh yeah maybe that's been done to death though
11:01:03 <ziman> dons, i compile it ghc --make -O2 stats.hs
11:01:13 <mjrosenb> is there a recommended method for [Word8] -> String for utf16 encoded strings?
11:01:54 <vixey> :t map(fromEnum.toEnum) :: [Word8] -> String
11:01:58 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
11:01:58 <lambdabot>       Expected type: a -> Char
11:01:58 <lambdabot>       Inferred type: a -> Int
11:02:01 <vixey> :t map(toEnum.fromEnum) :: [Word8] -> String
11:02:04 <lambdabot> [Word8] -> String
11:02:19 <dons> ziman: without looking further at the code its hard to say, but in general, as long as you're not unpacking bytestrings, you'll get very good performance. and if in doubt, use recursion
11:02:21 <vixey> I don't know if that would work actually..
11:02:39 <dons> this kind of thing, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
11:02:40 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/ys3ony
11:02:47 <ziman> dons, oh, i do unpack bytestrings at an early stage
11:02:53 <mjrosenb> vixey: it wouldn't.  utf16 is stored as 2 bytes / character
11:03:11 <dons> ziman: ah there you go
11:03:11 <ziman> i thought the resulting lists would be lazy as well
11:03:22 <vixey> maybe.. map(toEnum.fromEnum) . sum . chunks 2
11:03:26 <rwbarton> mjrosenb: Technically, there are some >2-byte characters, right?
11:03:27 <dons> ziman: it might be that unpack is a bit too strict
11:03:41 <dons> ziman: also String uses 16x more space than bytestrings
11:03:52 <rwbarton> mjrosenb: (You probably don't care about them in practice)
11:03:54 <dons> so if its strict, its really strict
11:03:56 <mjrosenb> nwf: probably
11:04:00 <dons> and performance will suck
11:04:16 <ziman> dons, I use this transformation: map ((/255) . fromIntegral) . unpack
11:04:38 <ziman> which converts the bytes into Doubles
11:05:10 <dons> too expensive.
11:05:16 <ziman> okay, i'll try to convert at the core
11:05:25 <mjrosenb> In computing, UTF-16 (16-bit Unicode Transformation Format) is a variable-length character encoding for Unicode, capable of encoding the entire Unicode repertoire. The encoding form maps code points (characters) into a sequence of 16-bit words, called code units.
11:05:30 <mjrosenb> ow.
11:05:41 <dons> ziman: you should be able to avoid the unpack
11:05:54 <mauke>     No instance for (Functor ((,) ByteString))
11:05:55 <mauke>       arising from a use of `fmap' at Preflex/String.hs:32:23-39
11:05:56 <dons> ziman: though you're generating a list of Double?
11:05:58 <mauke> how did I do that?
11:06:04 <dons> ziman: maybe you should be using hmatrix or friends
11:06:37 <mjrosenb> mauke: unix c+p?
11:07:26 <ziman> dons, i'll take a look at the things you've suggested, thanks
11:08:24 <mauke> @index Functor
11:08:24 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:08:43 <sclv_> anyone familiar with issues with haskell threadsafety when doing lots of file io?
11:08:44 <sclv_> I
11:08:52 <sclv_> erm, I'm getting the following segfault:
11:08:55 <sclv_> #0  0x0000000000a54ca5 in cmpLocks ()
11:08:55 <sclv_> #1  0x0000000000a67c19 in lookupHashTable ()
11:08:55 <sclv_> #2  0x0000000000a54d91 in lockFile ()
11:08:55 <sclv_> #3  0x00000000009c269f in base_GHCziHandle_zdLr5QQzdwccall_info ()
11:09:26 <slarba> d'oh
11:09:40 <sclv_> anone seen this before?
11:09:49 <mjrosenb> sclv_: that looks sort of like an issue someone had in here a few months ago
11:10:25 <sclv_> contention for the locking table I suppose?
11:11:03 <sclv_> any suggestions? a lower level API that'll let me just work around this for now?
11:11:15 <mjrosenb> i have no idea what his problem was; just it was a segfault inside of a locking function
11:13:28 <mauke> how can I force cabal to reinstall a package?
11:13:39 <Deewiant> you can't
11:13:43 <dcoutts> mauke: unregister it first
11:14:26 <mauke> bah
11:14:26 <sclv_> cripes
11:14:35 <mauke> 'cabal' should be 'cabal --help'
11:14:35 <dcoutts> mauke: and file a feature request http://hackage.haskell.org/trac/hackage/newticket
11:14:52 <dcoutts> mauke: ok, file two feature requests :-)
11:14:58 <dcoutts> mauke: I'm not sure that I agree though
11:15:10 <dcoutts> $ cabal
11:15:10 <dcoutts> no command given (try --help)
11:15:11 <mauke> no time, I have to get my development environment working again
11:15:17 <Deewiant> dcoutts: I filed that request already, no?
11:15:21 <dcoutts> it does after all suggest --help
11:15:27 <mauke> ghc-6.8.3 broke everything
11:15:35 <dcoutts> Deewiant: yeah I though so but I didn't immediately see it
11:15:43 <dcoutts> Deewiant: what was a keyword?
11:16:05 <Deewiant> beats me
11:16:06 <dcoutts> ahh, found it http://hackage.haskell.org/trac/hackage/ticket/301
11:16:09 <lambdabot> Title: #301 (No way to reinstall current version of a package) - Hackage - Trac
11:16:11 <fons> hi all
11:16:25 <mauke> after reinstalling 6.8.2 I'm getting weird linker errors and ((,) a) is not a Functor anymore
11:17:18 <dcoutts> mauke: so add your comments to http://hackage.haskell.org/trac/hackage/ticket/301
11:17:20 <lambdabot> Title: #301 (No way to reinstall current version of a package) - Hackage - Trac
11:17:21 <mjrosenb> once again, anyone know of a way to get [Word8] -> String with UTF16 decoding?
11:17:28 <mauke> ghc-6.8.2: unknown package: network-2.1.0.0 (dependency of miniplex-0.3.3)
11:17:31 <mauke> how can that happen?
11:18:20 <mauke> I mean, cabal has just successsfully built and installed miniplex
11:18:45 <dcoutts> mauke: "ghc-pkg check" will tell you that there are packages with missing deps
11:19:06 <mauke> ok, but why does it think miniplex depends on network-2.1.0.0?
11:19:23 <dcoutts> mauke: well presumably because it does, that's what it was built with
11:19:37 <dcoutts> mauke: you can check using ghc-pkg field miniples depends
11:20:04 <mauke> I get two "depends:" lines
11:20:17 <dcoutts> mauke: because you've got two versions of miniplex installed
11:20:24 <dcoutts> see ghc-pkg list miniplex
11:20:27 <mauke> ah!
11:20:45 <mauke> problem solved. thank you
11:20:58 <mjrosenb> mauke: i had that issue with portage : (
11:21:20 <byorgey> hi fons
11:21:20 <osfameron> what's the canonical way to convert '1' to 1::Integer ?
11:21:27 <mauke> argh
11:21:30 <fons> hi byorgey
11:21:30 <Deewiant> > ord '1'
11:21:32 <lambdabot>  49
11:21:37 <byorgey> osfameron: what do you mean?  it doesn't need 'conversion'
11:21:39 <mauke> why doesn't ghc-pkg unregister take multiple arguments?
11:21:59 <byorgey> osfameron: wait, by '1' do you mean '1' :: Char ?
11:22:14 <osfameron> byorgey: yes, sorry, I thought that was clear by the single quotes
11:22:17 <Deewiant> > digitToInt '1'
11:22:19 <lambdabot>  1
11:22:29 <byorgey> ah, Deewiant beat me to it =)
11:22:35 <mauke> dcoutts++
11:22:44 <sclv_> oh man. bytestring fixed one issue, and now I have another... distilling testcases is hard, and I'm running into all sorts of roadbumps using serious threading with STM.
11:22:45 <Deewiant> I had to look up the function name :-/
11:22:49 <osfameron> Deewiant: thanks
11:22:55 <mauke> dcoutts: do you also happen to know why I'm getting 'No instance for (Functor ((,) ByteString))'?
11:22:57 <Deewiant> no problem
11:23:02 <orbitz> does the haskell standard make any gurantees about the encoding of a Char?
11:23:09 <byorgey> osfameron: it should have been clear, but in many contexts single quotes are just used to delineate code, like 'map f [1..3]', so my brain just ignored them =)
11:23:19 <osfameron> I was looking for parseInt and fromChar and all kinds of things :-)
11:23:23 <Deewiant> I think it only says that it represents a Unicode code point
11:23:29 <mauke> orbitz: Chars have no encoding
11:23:30 <sclv_> anyone gotten a segfault on stg_atomically_frame_info before?
11:23:30 <osfameron> byorgey: heh, np, I should have been clearer
11:23:43 <Deewiant> mauke: sure they do, they're 4-byte integers
11:23:54 <mauke> Deewiant: no
11:23:58 <orbitz> is a Char an integer?!
11:24:02 <mauke> no
11:24:09 <Deewiant> 'no'?
11:24:14 <mauke> this isn't C
11:24:19 <orbitz> is it's size guranteed to be 1 byte or anything like that
11:24:25 <orbitz> its*
11:24:32 <Deewiant> its size in GHC is 4 bytes, as I said
11:24:34 <mauke> orbitz: no, haskell values have no size
11:24:38 <Deewiant> (or at least the latest GHC)
11:24:47 <Deewiant> mauke: it's an instance of Storable, it has size
11:24:48 <orbitz> Deewiant: how did you determine that?
11:24:54 <Deewiant> > sizeOf '1'
11:24:54 <lambdabot>   Not in scope: `sizeOf'
11:24:57 <Deewiant> meh
11:25:02 <mauke> Deewiant: that has nothing to do with its size
11:25:05 <Deewiant> @hoogle sizeOf
11:25:06 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
11:25:12 <mjrosenb> Deewiant: is that platform indipendent?
11:25:13 <mauke> Storable just defines a serialization format
11:25:16 <Deewiant> > Foreign.Storable.sizeOf '1'
11:25:17 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
11:25:40 <mauke> is Char even an instance of Storable?
11:25:53 <orbitz> sizeOf work son it, so it apepars so..
11:26:00 <Deewiant> yes, it is
11:26:08 <orbitz> Prelude> Foreign.Storable.sizeOf '1' => 4
11:26:15 <Deewiant> mjrosenb: and yes, it should be, but I'm not sure
11:26:24 <orbitz> does that mean internally it is represented as 4 bytes though?
11:26:27 <mauke> orbitz: no
11:26:31 <Deewiant> it probably is
11:26:38 <Deewiant> but mauke's right, it doesn't have to mean that
11:26:51 <mjrosenb> Deewiant: you know of any utf16 decoders?
11:27:00 <Deewiant> not in haskell, no
11:27:08 <twobitwork> any idea why this would give a stack overflow?   (id, align) <- zip [1 .. n] . map fromInt . take n $ Random.randomRs (-1, 1) gen
11:27:10 <Deewiant> probably not that hard to write though
11:27:43 <twobitwork> fromInt is just a simple function, and the behavior doesn't change without it
11:28:18 <mjrosenb> twobitwork: everything is written recursively
11:28:24 <dolio> randomRs is probably the problem, if I had to guess.
11:28:26 <twobitwork> ohh, and I get the stack overflow when trying to, i.e., take the head of the list
11:28:38 <mjrosenb> twobitwork: and the ghci interpreter doesn't do cps conversion
11:28:45 <dolio> Really, the head?
11:28:48 <twobitwork> yep
11:29:34 <hpaste>  twobitwork pasted "(no title)" at http://hpaste.org/8563
11:31:02 <twobitwork> and, doesn't zip stop when one of the lists runs out?
11:31:16 <dcoutts> mauke: re Functor (,) a, are you using 6.8.3 or .2 now?
11:32:16 <dcoutts> mauke: I believe the instance was incorrectly exported from some H98 modules such as Array and that it was fixed in 6.8.3.
11:32:45 <dcoutts> mauke: that instance (and others) have always been defined in Control.Monad.Instances
11:33:42 <tromp> > zip [] [undefined]
11:33:43 <lambdabot>  []
11:34:01 <mrd> lay-Z
11:34:33 <tromp> > zip [] (undefined:undefined)
11:34:34 <lambdabot>  []
11:34:40 <mauke> dcoutts: I'm using 6.8.2 now
11:34:50 <ziman> > zip [] undefined
11:34:51 <lambdabot>  []
11:34:52 <tromp> > zip (undefined:undefined) []
11:34:53 <lambdabot>  []
11:34:56 <dolio> What's randChar do?
11:35:02 <mauke> the code worked with both 6.8.2 and 6.8.3 before
11:35:09 <tromp> > zip undefined []
11:35:11 <lambdabot>  Exception: Prelude.undefined
11:35:17 <dcoutts> mauke: well either, way that is defined in Control.Monad.Instances
11:35:33 <twobitwork> dolio: just returns a structure
11:35:53 <mauke> hmm
11:36:05 <dcoutts> mauke: are you sure you didn't change any imports?
11:36:08 <dolio> Are you sure that's not what's overflowing?
11:36:18 <mauke> dcoutts: I didn't change the code at all
11:36:23 <dcoutts> mauke: or rebuild against different versions of deps?
11:36:38 <dcoutts> which may have changed their imports
11:36:39 <hpaste>  twobitwork annotated "(no title)" with "(no title)" at http://hpaste.org/8563#a1
11:36:44 <mauke> dcoutts: that's more likely
11:36:47 <twobitwork> dolio: there's randChar
11:37:13 <dolio> Huh.
11:37:17 <mauke> the imports were Prelude, Data.Char, Data.ByteString.Char8 and Data.ByteString.Lazy
11:37:31 <twobitwork> er... I wonder if I'm stepping on the predefined Char...
11:37:34 <mauke> I randomly blame bytestring
11:37:52 <twobitwork> no, Char is the constructor, the type is called Character
11:38:51 <twobitwork> randomRs has to be lazy... or it would never work
11:38:59 <mauke> Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString' against inferred type `L.ByteString'
11:39:26 <mauke> so how do I find out which package pulls 0.9.0.1 in, and how do I fix it? :-)
11:40:46 <dolio> twobitwork: I'm afraid I don't believe that this is overflowing. :)
11:41:01 <rwbarton> twobitwork: works fine for me if I replace fromInt with id and randChar with (,)
11:41:25 <rwbarton> But, I don't know what some of the types are supposed to be
11:41:26 <Baughn> mauke: I imagine you can scan the package description files.. somehow..
11:41:32 <dcoutts> mauke: building using cabal install? or manually?
11:41:33 <Baughn> mauke: But you fix it by recompiling that package.
11:42:07 <mauke> dcoutts: I'm currently building something manually
11:42:12 <dcoutts> mauke: cabal install picks the deps so as to avoid that problem
11:42:13 <hpaste>  twobitwork annotated "(no title)" with "the types" at http://hpaste.org/8563#a2
11:42:17 <mauke> ./Setup build, etc
11:42:52 <rwbarton> Well, now I can replicate it...
11:43:27 <twobitwork> rwbarton:  you get the overflow?
11:43:39 <rwbarton> Yes
11:43:45 <rwbarton> twobitwork: It's because you haven't defined show :)
11:43:49 <twobitwork> ok... at least I know I'm not just going crazy
11:44:44 <twobitwork> rwbarton: oh.........
11:44:49 * twobitwork facepalms
11:44:58 <twobitwork> its always the simplest thing
11:45:41 <mauke> hmm. it's building now but I may have broken my ghc installation
11:45:44 <mauke> we'll see :-)
11:47:09 <mauke> ghc-pkg--  # no man page
11:47:36 <twobitwork> so, why doesn't ghc just complain about not having show defined?
11:48:04 <rwbarton> Because in class Show, show is defined in terms of showsPrec, and showsPrec is defined in terms of show
11:48:14 <rwbarton> (so that you can define either one)
11:49:18 <Deewiant> > let decodeUtf16BE xs = let f [x] = [x]; f [a,b] = if a >= 0xd800 && a <= 0xdbff then [0x10000 + ((a .&. 0x3ff) `shiftL` 10) .|. (b .&. 0x3ff)] else [a,b] in map chr $ concatMap f $ (`inGroupsOf` 2) $ map (\[a,b] -> (a `shiftL` 8) .|. b) (xs `inGroupsOf` 2) in decodeUtf16BE [0x6c,0x34,0,0x7a,0xd8,0x34,0xdd,0x1e]
11:49:19 <dolio> It should complain if not instance Show ... is defined, though.
11:49:19 <lambdabot>  "\27700z\119070"
11:49:35 <dolio> The only way it'd loop is if you did 'instance Show ... where' and then didn't write any methods.
11:49:35 <rwbarton> Unfortunately ghc can't parse the comment "Minimal complete definition: show or showsPrec" :)
11:49:42 <Deewiant> twobitwork: UTF-16 decoder ^
11:49:49 <Deewiant> not you
11:49:52 <Deewiant> mjrosenb: you
11:50:18 <twobitwork> rwbarton: ahhhhhh
11:50:21 <twobitwork> I seeeee
11:50:46 <mjrosenb> wow
11:50:55 <rwbarton> Arguably, it should just know, for Prelude classes
11:51:19 * byorgey downloads papers
11:51:22 <byorgey> mmmmmm papers
11:51:46 <mjrosenb> Deewiant: i had been expecting a module that ships with ghc, but that works
11:51:58 <Deewiant> heh
11:52:15 <Deewiant> inGroupsOf is left as an exercise for the reader
11:52:47 <mjrosenb> Deewiant: thanks... shouldn't be that hard
11:53:43 <Deewiant> no problem... it can be defined in many ways
11:54:51 <Deewiant> oh, and that results in garbage if you get an one-part surrogate
11:54:57 <Deewiant> s/an /a /
11:55:05 <Baughn> Has anyone successfully built haddock against GHC 6.8.3?
11:55:54 <mjrosenb> Deewiant: one-part surrogate?
11:56:03 <osfameron> hmm, the factorial examples on Evolution of a Haskell Programmer don't have caching examples -- I'd have thought it was a good candidate for that
11:56:10 <Deewiant> like 0xd800 without the latter half of the code point
11:56:23 <Igloo> Baughn: 0.9 should work
11:56:29 <mjrosenb> i see
11:56:30 <Deewiant> mjrosenb: http://en.wikipedia.org/wiki/UTF-16#Encoding_of_characters_outside_the_BMP
11:56:31 <lambdabot> http://tinyurl.com/a8k8g
11:56:40 <mjrosenb> Deewiant: reading that now
11:57:04 <Deewiant> in general that assumes valid input
11:57:19 <Apocalisp> Is there any other name for functional-style programming that doesn't involve a pun which implies that other styles of programming are nonfunctional, i.e. don't work?
11:57:33 <Baughn> Igloo: But it's on 2.1.0 now..?
11:57:42 <mjrosenb> Deewiant: i may have to spice it up a bit... i'm not going to trust mp3's from the internets to be correct
11:57:55 <Baughn> Well, so long as it builds documentation, I guess.
11:57:56 <mrd> Apocalisp: practical programming?
11:57:57 <Deewiant> :-)
11:58:10 <Apocalisp> as opposed to impractical programming? :)
11:58:14 <Deewiant> mjrosenb: I suggest http://tools.ietf.org/html/rfc2781
11:58:18 <mrd> of course ..
11:58:22 <lambdabot> Title: RFC 2781 - UTF-16, an encoding of ISO 10646
11:58:36 <prb> Baughn: I found some hPasted'd patches there were sufficient to get Haddock 2.1.0 built on 6.8.3.
11:58:45 <prb> Baughn: Try Googling around a bit.
11:58:59 <Deewiant> I managed to get it to build, but it wouldn't link :-/
11:59:59 <Apocalisp> type-honest programming
12:00:10 <Deewiant> Baughn: http://www.hpaste.org/8483 maybe
12:00:10 <mrd> typical programming?
12:00:16 <Apocalisp> haha
12:01:46 <romildo> Hi.
12:01:52 <mjrosenb> hey
12:02:21 <Baughn> Deewiant: That worked
12:03:00 <prb> Baughn: http://www.hpaste.org/8483#a3 Is the one that I used.
12:05:49 <alperbaba> hello is there a document how can i configure haskell+emacs+haskell-doc connection
12:05:54 <romildo> Why, when I "import Graphics.UI.Gtk", cellLayoutPackStart and cellLayoutSetAttributes are not in scope?
12:06:13 <alperbaba> i am using debian and there are a lot of package
12:06:39 <mrd> alperbaba: the haskell-mode package, and see the README
12:06:51 <slarba> hah
12:06:54 <mrd> all debian packages come with documentation in /usr/share/<package-name>
12:06:55 <slarba> "This image was acquired at the Phoenix landing site on day 5 of the mission on the surface of Mars, or Sol 4, after the May 25, 2008, landing. The optical microscope acquired this image at 12:34:19 local solar time. The camera pointing was elevation null degrees and azimuth null degrees."
12:07:06 <slarba> null...
12:07:35 <Deewiant> better than NaN
12:08:00 <flux> a certain mailing list archive has all dates as Nan.Nan.Nan Nan:Nan:Nan
12:08:05 <flux> slightly annoying
12:08:08 <Deewiant> meh, haddock still won't link
12:08:27 <mux> <gps> In null meters, turn right.
12:08:39 <flux> turn null?
12:08:51 <ziman> null right
12:09:00 <mux> turn NaN degrees right
12:09:03 <flux> "Null around when possible"
12:09:12 <mux> what a wonderful world we are going to live in
12:09:35 <mrd> sorry, all debian packages come with documentation in /usr/share/doc/<package-name>
12:09:39 <mrd> just noticed
12:10:11 <alperbaba> which haskell compiler do you recommend?
12:10:19 <mrd> ghc
12:10:36 <mrd> apt-get install ghc6 haskell-mode
12:10:58 <Baughn> ghc, self-installed. debian is.. /slow/.
12:11:15 <mrd> slow?
12:11:24 <rwbarton> 6.8.2 isn't new enough?
12:11:30 <rwbarton> That's in testing
12:11:35 <Baughn> testing?
12:11:37 <dino-> s/slow/old/
12:11:40 <rwbarton> lenny
12:11:46 <Baughn> Mixing testing and stable is a bad idea, I've found. :/
12:11:47 <dino-> Are they up to 6.8.2 in testing?
12:12:03 <Baughn> They're on 6.6.4 in stable
12:12:18 <Baughn> Wait. 6.6-3.
12:12:20 <mrd> stable only receives updates for security purposes
12:12:21 <pawlik> hm. what's the type of f x = x * sin .1 ?
12:12:29 <Deewiant> ?ty f x = x * sin .1
12:12:30 <lambdabot> parse error on input `='
12:12:35 <Deewiant> ?ty let f x = x * sin .1 in f
12:12:37 <lambdabot> forall (f :: * -> *) a. (Functor f, Num (f a), Floating a) => f a -> f a
12:12:39 <mrd> :t \ x -> x*sin 0.1
12:12:40 <lambdabot> forall a. (Floating a) => a -> a
12:12:41 <Baughn> @type \x -> x*sin .1
12:12:42 <mjrosenb> Deewiant: what should the type of inGroupsOf be?
12:12:43 <lambdabot> forall a (f :: * -> *). (Functor f, Num (f a), Floating a) => f a -> f a
12:12:53 <mjrosenb> oh.. i may have it backwards
12:12:55 <Deewiant> mjrosenb: [a] -> Int -> [[a]]
12:13:04 <Baughn> That seems odd
12:13:07 <Baughn> @type (*)
12:13:08 <lambdabot> forall a. (Num a) => a -> a -> a
12:13:14 <Deewiant> that's correct
12:13:17 <mjrosenb> indeed
12:13:17 <Deewiant> x * sin . 1
12:13:21 <Baughn> Functor?
12:13:26 <Deewiant> ?ty (.)
12:13:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:13:33 <mjrosenb> i wrote it as Int -> [a] -> [[a]]
12:13:47 <Deewiant> mjrosenb: that works too, just change my code
12:13:50 <dino-> This is saying 6.8.2 for lenny (testing) atm: http://packages.debian.org/search?keywords=ghc&searchon=names&suite=testing&section=all
12:13:52 <lambdabot> Title: Debian -- Package Search Results -- ghc, http://tinyurl.com/5b7yt7
12:13:53 <Baughn> @type \x -> x*sin 0.1
12:13:55 <lambdabot> forall a. (Floating a) => a -> a
12:13:57 <ziman> Deewiant, that's a good name. i've always used chunkBy for that, which breaks convention (...By should take a predicate)
12:13:58 <Deewiant> I prefer my way so you can write foo `inGroupsOf` bar
12:14:04 <Baughn> ..that's more reasonable
12:14:28 <[knap]> I'm trying to import a Module but i get the error "Failed to load interface for "Module":" can anyone help?
12:14:29 <Deewiant> ziman: yeah, everyone seems to have their own name for this :-)
12:14:36 <Deewiant> and I still can't link haddock :-/
12:14:43 <alperbaba> and i read about ghc but not clearly understand if it is an interpreter or a compiler ?
12:14:47 <Deewiant> oh well
12:14:52 <Deewiant> alperbaba: both
12:15:57 <[knap]> alperbaba it's a compiler
12:16:07 <[knap]> hugs and ghci are interpreters
12:16:13 <alperbaba> Deewiant: i mean that when i compiled a code could it run without ghc
12:16:17 <mjrosenb> Deewiant: i just tried what you gave me, and i got non-exhaustive patterns in lambda
12:16:28 <mjrosenb> alperbaba: it will be an elf executable
12:16:48 <alperbaba> mjrosenb: ok i see :)
12:16:54 <alperbaba> mjrosenb: thanks
12:17:16 <mauke> alperbaba: you can even copy the executable to a different machine and run it there
12:17:28 <Deewiant> mjrosenb: yeah, that's one place where it assumes valid input :-)
12:17:38 <mauke> I may have had to install gmp, though
12:17:44 <Deewiant> mjrosenb: it'll work given valid data (and compiled with warnings off)
12:18:44 <mjrosenb> Deewiant: this was on the sample input that you gave it
12:19:03 <mjrosenb> Deewiant: perhaps my inGroupsOf does not do what you thought it would
12:19:03 <Deewiant> like said, compile with warnings off :-)
12:19:09 <Deewiant> perhaps
12:19:19 <Deewiant> > [1..10] `inGroupsOf` 3
12:19:19 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:19:56 <vixey> :t inGroupsOf
12:19:57 <mjrosenb> Deewiant: this was an exception.  turning warnings off does'nt make exceptions go away
12:19:57 <lambdabot> forall a. [a] -> Int -> [[a]]
12:20:02 <vixey> that's a weird name for what it does
12:20:24 <Deewiant> mjrosenb: ah, I thought it was a compiler warning (there is such a warning)
12:20:34 <mjrosenb> wait, this already exists?
12:20:40 <mjrosenb> @src inGroupsOf
12:20:40 <lambdabot> Source not found. stty: unknown mode: doofus
12:20:43 <Deewiant> no, that's my @let-definition
12:20:49 <mjrosenb> ah
12:21:28 <mjrosenb> indeed... my implementation is wrong
12:27:28 <mjrosenb> rwbarton: is that supposed to look like anything in particular when output?
12:28:47 <alperbaba> where can i find haskell mode README file
12:29:28 <paolino> how can I write f if f 5 = [5,6,7,8,9,8,7,6,5] ?
12:30:02 <Baughn> paolino: Is this homework?
12:30:24 <Baughn> > let f n = [n..9] ++ [8..n] in f 5
12:30:25 <lambdabot>  [5,6,7,8,9]
12:30:30 <paolino> mmhh, I'm not a student no more
12:30:31 <mauke> > let f 5 = [5,6,7,8,9,8,7,6,5] in f 5
12:30:32 <lambdabot>  [5,6,7,8,9,8,7,6,5]
12:30:40 <mauke> voilà
12:30:41 <MyCatVerbs> f = const [5,6,7,8,9,8,7,6,5], of course. ;P
12:30:46 <Baughn> > let f n = [n..9] ++ [8,7..n] in f 5
12:30:47 <lambdabot>  [5,6,7,8,9,8,7,6,5]
12:30:50 <paolino> let r k = let v = take k [k..] in v ++ tail (reverse v)
12:30:53 <Deewiant> > let f n = [n..2*n-1] ++ [2*n-1,2*n..n] in f 5
12:30:54 <lambdabot>  [5,6,7,8,9]
12:31:00 <Deewiant> > let f n = [n..2*n-1] ++ [2*n-1,2*n-2..n] in f 5
12:31:01 <lambdabot>  [5,6,7,8,9,9,8,7,6,5]
12:31:07 <Deewiant> oops
12:31:12 <alperbaba> mrd: i can't find readme file. Do you know where it is?
12:31:14 <Deewiant> > let f n = [n..2*n-1] ++ tail [2*n-1,2*n-2..n] in f 5
12:31:15 <lambdabot>  [5,6,7,8,9,8,7,6,5]
12:31:19 <Deewiant> :-P
12:31:47 <byorgey> alperbaba: have you looked at http://www.haskell.org/haskell-mode/ ?
12:31:47 <lambdabot> Title: Haskell Mode for Emacs
12:31:51 <Baughn> > let f n = [n..9] ++ [8,7..n] in f 12
12:31:52 <lambdabot>  []
12:31:57 <paolino> I was hoping in a loeb :-P
12:31:58 <Baughn> > let f n = [n..9] ++ [8,7..n] in f 7
12:31:59 <lambdabot>  [7,8,9,8,7]
12:32:07 <MyCatVerbs> > let f n = let l = [n..2*n-1] in l ++ tail (reverse l) in f 6
12:32:08 <lambdabot>  [6,7,8,9,10,11,10,9,8,7,6]
12:32:21 <Deewiant> > let f n = let l = [n..2*n-1] in l ++ tail (reverse l) in f 1
12:32:21 <Baughn> > let f n = [n..9] ++ [8,7..n] in f
12:32:22 <lambdabot>  [1]
12:32:23 <lambdabot>  <Integer -> [Integer]>
12:32:23 <Baughn> > let f n = [n..9] ++ [8,7..n] in f 8
12:32:25 <lambdabot>  [8,9,8]
12:32:25 <Deewiant> > let f n = let l = [n..2*n-1] in l ++ tail (reverse l) in f 0
12:32:26 <lambdabot>  Exception: Prelude.tail: empty list
12:32:49 <Baughn> @desugar [8,7..8]
12:32:49 <lambdabot> Unknown command, try @list
12:32:51 * Baughn pouts
12:32:58 <MyCatVerbs> > let f = "Your matrilineal ancestry!" in [5..9]++[8,7..5]
12:32:58 <Deewiant> @undo [8,7..8]
12:32:58 <lambdabot> [8, 7 .. 8]
12:32:59 <lambdabot>  [5,6,7,8,9,8,7,6,5]
12:33:53 <paolino> Baughn: I'm trying to do problem D of google code jam
12:34:47 <Baughn> paolino: I don't suppose they'd accept "f=const[5,6,7,8,9,8,7,6,5]"?
12:34:53 <mrd> alperbaba: not in /usr/share/doc?
12:35:06 <paolino> which I hope noone has for homework ever
12:35:07 <mrd> alperbaba: debian's haskell-mode package should set it up to work in emacs automatically
12:35:46 <Baughn> paolino: One of my homework problems back in ninth grade was to prove fermat's last theorem. I got three pages in.
12:36:23 <paolino> http://hpaste.org/8553
12:36:24 <byorgey> heh, my number theory prof was fond of giving us open problems on exams
12:36:43 <ziman> :D
12:36:46 <twobitwork> is ghc lazy about constants? or does it do compile-time constant folding?
12:36:52 <Baughn> twobitwork: Yes.
12:37:03 <paolino> someone resolved it in 1.13 hours.minutes
12:37:09 <paolino> O_O
12:37:12 <twobitwork> Baughn: ?
12:37:23 <mjrosenb> paolino: link?
12:37:28 <Baughn> twobitwork: Both. Which it picks depends on the cost, and quite likely the size of the result.
12:37:47 <twobitwork> ahh, I see
12:38:00 <twobitwork> but for like, Int constants, I'm guess it will do folding...
12:38:02 <paolino> mjrosenb: you want my coockie to read that
12:38:12 <paolino> or be logged
12:38:12 <Baughn> twobitwork: But when it /doesn't/ do it at compile time, they get attributed to CAFs in the profiler
12:38:29 <twobitwork> CAFs?
12:38:34 <Baughn> twobitwork: Yes indeed. No need to worry about something like "42*7".
12:38:36 <mjrosenb> coockie?
12:38:48 <byorgey> paolino: hm, aren't you just finding a weighted shortest path in the game state graph?
12:38:53 <twobitwork> Baughn: what about x*2 where x is a global constant
12:39:14 <Baughn> twobitwork: No problem. Chances are it'll still optimize it even if x is defined in a different /package/.
12:39:29 <twobitwork> cool
12:39:34 <paolino> mjrosenb:  http://code.google.com/codejam/
12:39:35 <lambdabot> Title: Google - Code Jam
12:39:54 <twobitwork> I guess I could always look at the asm if I'm really worried about it
12:39:57 <byorgey> but I guess you have to expand nodes lazily because constructing the entire game state graph could be a bit... prohibitive =)
12:40:09 <paolino> byorgey: big set has 75 pieces to place
12:40:17 <byorgey> yikes
12:41:11 <paolino> > let fact 1 = 1; fact n = n * fact n - 1 in fact 75
12:41:12 <lambdabot>  Exception: stack overflow
12:41:31 <Baughn> (n-1)
12:41:36 <paolino> ops
12:42:03 <paolino> ﻿> let fact 1 = 1; fact n = n * fact (n - 1) in log $ fromInteger $ fact 75
12:42:31 <paolino> anyway it is prohibitive
12:42:53 <mjrosenb> paolino: how did you get the problem from the codejam site?
12:43:04 <paolino> you must login
12:43:08 <byorgey> > product [1..75]
12:43:09 <lambdabot>  2480914081139539809194647711659403366092624388657012283779589451265584267757...
12:43:23 <Baughn> > foldr (*) 0 [1..75[
12:43:23 <lambdabot>  Parse error at end of input
12:43:25 <Baughn> > foldr (*) 0 [1..75]
12:43:26 <lambdabot>  0
12:43:31 <byorgey> > length . show . product $ [1..75]
12:43:32 <lambdabot>  110
12:43:35 <Baughn> Well, that's not so bad
12:43:49 <Deewiant> Baughn: 0 * _ = 0 :-)
12:44:08 <Baughn> Deewiant: You mean n! isn't /supposed/ to be 0?
12:44:40 <mjrosenb> paolino: okee
12:44:43 <paolino> 6 people made it right in less than 2 hours
12:44:52 <tromp> > product []
12:44:53 <lambdabot>  1
12:45:01 <mmorrow> @seen rwbarton
12:45:01 <lambdabot> rwbarton is in #haskell. I last heard rwbarton speak 33m 21s ago.
12:45:03 <Baughn> @src product
12:45:03 <lambdabot> product = foldl (*) 1
12:45:14 <Baughn> ..should be foldl', I say.
12:45:22 <mmorrow> rwbarton: ping
12:45:34 <Baughn> > length$show$foldl (*) 1 [1..1000000]
12:45:34 <psyklops> wait... that does something?
12:45:41 <ziman> the same for sum
12:45:43 <ziman> @src sum
12:45:43 <lambdabot> sum = foldl (+) 0
12:45:49 <lambdabot> Terminated
12:45:56 <mmorrow> yeah, they should totally be foldl'
12:45:57 <ziman> sum overflows the stack
12:45:59 <mjrosenb> Baughn: that wouldn' work on a list of lenght 0.
12:46:02 <Baughn> ziman: Which is technically correct, but relies on the strictness analyser to avoid stack overflow
12:46:04 <tromp> no point in using foldl'
12:46:10 <rwbarton> mmorrow: Hi
12:46:18 <mmorrow> foldl (+) 0 [1..10000000000]
12:46:39 <mmorrow> rwbarton: hey, did you see the pattern QQ splices?
12:46:45 <mmorrow> > foldl (+) 0 [1..10000000000]
12:46:51 <tromp> since partial results just as big as the thunk
12:46:58 <lambdabot> Terminated
12:47:05 <mmorrow> > foldl (+) 0 [1..1000000]
12:47:07 <lambdabot>  500000500000
12:47:19 <rwbarton> mmorrow: did I see them? where?
12:47:30 <mmorrow> rwbarton: heh, hold on
12:47:45 <mmorrow> http://hpaste.org/8534
12:47:45 <GrayShade> i know this is stupid, but i want to specialize this ListT to use IO as its inner monad: http://hpaste.org/8564 . could this work?
12:48:07 <mmorrow> http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.2.tar.bz2
12:48:07 <lambdabot> http://tinyurl.com/5m2grk
12:48:24 <mmorrow> rwbarton: i added them to the patched ghc-6.8.3!
12:49:06 <mmorrow> rwbarton: suprisingly, doing so wasn't as painful as i thought it was gonna be
12:49:10 <paolino> byorgey: in fact they pay 45 points for the big set , while only 25 for the small, where size is <= 15
12:49:16 <rwbarton> mmorrow: I see, cool.
12:49:25 <mmorrow> rwbarton: :)
12:49:28 <rwbarton> mmorrow: I managed to build and install a ghc-6.9 on my fifth attempt :)
12:49:38 <paolino> > product [1..15]
12:49:39 <mmorrow> rwbarton: of course, if you're using 6.9 it's a moot point...
12:49:39 <lambdabot>  1307674368000
12:49:52 <mmorrow> rwbarton: nice! 6.9 is the awesome
12:49:55 <paolino> mhhh, still unfeasable
12:50:40 <rwbarton> mmorrow: my installation is kind of broken, though.  no readline in ghci.  even backspace doesn't work!
12:51:13 <mmorrow> rwbarton: heh, i struggled with that for about a week before i figured it out..
12:51:38 <mmorrow> rwbarton: install the editline library (maybe editline-devel if there is one i can't remember)
12:52:18 <mmorrow> then rebuild ghc (cuz i think the presence of editline needs to be picked up in ./configure)
12:52:35 <mmorrow> i just did sudo yum install -y *editline*
12:52:56 <mmorrow> i'm sure apt-get'll do the same
12:53:11 <rwbarton> I see, some kind of readline replacement
12:53:24 <mmorrow> yeah, they switched to editline since it's not gpl
12:53:37 <fons> Does anyone know about a translator from Language.Haskell.Syntax to Language.Haskell.TH.Syntax?
12:53:55 <mmorrow> the plus (although this is easily implemented with readline) is that ghci now has a *persistent* history!
12:54:17 <mmorrow> the minus is that for some reason ghci just *aborts* randomly ALL the time
12:54:36 <mmorrow> (onyl aborts when you're hitting enter on an empty prompt thankfully)
12:55:07 <mmorrow> but the history makes that bearable
12:55:17 <dolio> "I noticed that it appears that Haskell has a much larger community of computer linguists, bloggers, advocates and forum participants, but it is lagging behind OCaml in serious users and practical libraries (like MPI and binary serialization)."
12:55:34 <mmorrow> what's MPI?
12:55:46 <ddarius> Message Passing Interface or something like that.
12:55:51 <mmorrow> ah
12:56:17 <mjrosenb> does it have ^o == execute currently viewed history & move to the next history entry?
12:56:33 <mmorrow> mjrosenb: hmm, i'll check
12:56:51 <mjrosenb> i know bash has that and it's amazing
12:56:56 <mmorrow> no
12:57:06 <mjrosenb> : (
12:57:11 <mmorrow> that does sound amazing, i never knew about that
12:57:24 <byorgey> =O
12:57:25 <mmorrow> mjrosenb: it'd probably be easy to add yourself though
12:57:28 <byorgey> I never knew about that either!
12:57:34 <mmorrow> mjrosenb: that would be awesome!
13:04:51 <mmorrow> rwbarton: i saw your paste http://hpaste.org/8526 about pattern matching and regex qqs. i totally want to extended the regexToPatQ, and plan to make time over the weekend. have you played with the code in your paste any further?
13:05:23 <paolino> byorgey: you have any idea on the strategy to follow for  that game ?
13:06:17 <paolino> aside geometry  which is another problem for me :)
13:06:48 <Feuerbach> I want to generate nonzero vector for QuickCheck, but this code does not terminate:
13:06:57 <Feuerbach> nonzeroVec = do {vec <- arbitrary; if norm vec > 0 then return vec else nonzeroVec}
13:07:08 <byorgey> paolino: I would probably do a breadth-first (by total score, not by number of moves) search through the game space, storing already computed nodes in some sort of hash table
13:07:24 <Deewiant> Feuerbach: arbitrary probably always returns one with norm 0?
13:07:28 <byorgey> paolino: that's just my initial thoughts, no idea how well that would really work
13:07:37 <Feuerbach> Deewiant: probably. But why?
13:07:43 <Feuerbach> it should be random
13:07:44 <rwbarton> mmorrow: Yes.  There are some technical problems though.  See my recent thread on the template-haskell mailing list
13:07:49 <Deewiant> beats me
13:08:04 <mjrosenb> paolino: that problem doesn't look hard at all
13:08:40 <mmorrow> rwbarton: nice, haven't been there today yet, going now. i guess i should announce regexqq there as well.
13:09:52 <mmorrow> rwbarton: oh, i read that as haskell-cafe...ok
13:09:52 <paolino> mjrosenb: that doesn't help much :d
13:13:32 <hpaste>  sclv pasted "unsafeIOToSTM is *really* unsafe" at http://hpaste.org/8565
13:14:12 <mmorrow> rwbarton: totally! i tried to do that at first with regexToPatQ but failed (for obvious reasons), but that would be ideal.
13:14:17 <paolino> mjrosenb: aside I cannot find the right way to express the metric for the board, they want the best solution
13:22:45 <mjrosenb> paolino: yeah, best solution
13:48:52 <hpaste>  ziman pasted "exhausts all system memory for large files" at http://hpaste.org/8566
13:49:49 <ziman> could somebody take a look at it? it's quite large but at the top i summarized which functions (and in which order) are evaluated
13:50:34 <ziman> i didn't want to reduce it because i might throw away some subtle & important things
13:52:01 <alperbaba> how can i open haskell-documention while i am coding i want to write code with documentation
13:52:08 <alperbaba> for emacs
13:53:50 <rwbarton> ziman: where you write "acc `seq` acc .+. current", I think unfortunately that doesn't force all of the components of acc
13:54:00 <rwbarton> > undefined `seq` 2
13:54:05 <lambdabot>  Exception: Prelude.undefined
13:54:06 <rwbarton> > (undefined, undefined) `seq` 2
13:54:07 <lambdabot>  2
13:54:22 <ziman> oh
13:54:39 <ziman> rwbarton, that's a good idea, thanks!
13:56:49 <ziman> rwbarton, works in constant space, great ;)
14:04:01 <joey_> Is Kleene Star defined over arbitrary monoids anywhere in the standard libraries?
14:04:53 <EvilTerran> what'd that be? mconcat . repeat?
14:09:47 <ddarius> \a -> iterate (a `mappend`) mempty ?
14:09:51 <joey_> Hmm.
14:09:55 <joey_> That looks closer
14:10:10 <alperbaba> hello i am using emacs and i want to see documentation while i am coding? how can i see doumentation in a buffer
14:10:28 <alperbaba> i've installed it with apt-get
14:13:26 <nus> alperbaba, what documentation?
14:17:02 <alperbaba> nus: which i installed apt-get install haskell-doc
14:17:47 <alperbaba> i've installed it with apt-get
14:19:28 <dons> just to let everyone know: darcs.haskell.org and hackage.haskell.org will be going offline in the next few hours
14:19:38 <dons> as all the servers are moved to a new location (and faster connection)
14:19:47 <dons> they'll reappear inside the next 24 hours
14:19:55 <nus> alperbaba, so you've got yourself the files. C-x C-f <path-to-the-file>
14:20:09 <waern> dons: argh!
14:20:37 <dons> code.haskell.org and www.haskell.org are *not* affected
14:20:57 <dons> it will mean systems that download from hackage won't be working
14:21:08 <dons> we should look at mirroring hackage on code.haskell.org after this, actually
14:21:17 <dons> i might just do that now...
14:21:17 <byorgey> alperbaba: as far as I know there isn't any automated system for seeing the documentation inside emacs.
14:21:25 <byorgey> alperbaba: mostly they are in html format.
14:21:57 <dons> planet.haskell.org will also be down
14:22:03 <alperbaba> byorgey: yes most probably it show it with html codes
14:23:04 <alperbaba> byorgey: i am trying to learn emacs also so i have some problems i am searching
14:23:42 <nus> alperbaba, get yourself emacs-w3m
14:24:19 <alperbaba> nus: what is that
14:26:02 <nus> alperbaba, ask APT about w3m-el or some such
14:26:28 <rwbarton> It's a web browser that runs inside emacs
14:26:45 <waern> can cabal-install's install command build haddock documentation somehow?
14:26:50 <nus> alperbaba, also wiki.emacs.org is your friend
14:27:06 <dons> waern: not yet, afaik
14:27:07 <dcoutts> waern: I think that's currently the most requested feature
14:27:11 <waern> mmkay
14:27:15 <alperbaba> nus: ok
14:27:18 <dcoutts> most frequently requested
14:27:18 <dons> soon people will forget about how to use Setup.hs :)
14:27:24 <dcoutts> yay
14:27:35 <dons> i already forget to add them to projects sometimes
14:27:42 <dons> dcoutts: note the downtime coming up for hackage and darcs.h.o
14:27:43 <waern> I'd like to build haddock docs for all hackage packages automatically -- should I get the hackage program that does that?
14:27:46 <dcoutts> dons: yep
14:28:02 <dcoutts> dons: yes, you don't need Setup.hs at all. sdist will add it automatically for you.
14:28:25 <dons> ah good
14:28:29 <dons> as long as things on hackage have Setup.hs
14:28:40 <dcoutts> dons: yes, we check for it
14:29:00 <byorgey> dcoutts: o rly?  nice =)
14:29:09 <dcoutts> waern: btw, if you have a suggestion about the haddock issue, please comment on: http://hackage.haskell.org/trac/hackage/ticket/206
14:29:10 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
14:29:22 <nus> alperbaba, actually its emacswiki.org (I rely too much on google, I guess)
14:29:51 <dons> dcoutts: i think we should start mirroring hackage after this move, btw
14:29:58 <dons> maybe on a chalmers machine, and code.haskell.org
14:30:07 <LordBrain> Can anyone give me suggestions on this haddock issue? http://hpaste.org/8545
14:30:13 <dcoutts> dons: as backup or as a real mirror?
14:30:16 <LordBrain> i don't know where to go from here
14:30:17 <dons> a true mirror
14:30:21 <dons> so all the tools can work
14:30:33 <praseodym> what's the type of 'curry id'?
14:30:40 <tromp> i got cabal-install-0.5.1, but don't know how to build it
14:30:44 <dcoutts> dons: and can we make mirrors transparent (reflective?)
14:30:51 <vixey> :t curry id
14:30:54 <lambdabot> forall a b. a -> b -> (a, b)
14:30:54 <dons> they might be read only
14:31:06 <dons> hackage will be doing down in 1 hour.
14:31:17 <dons> so if you've some cabal install to do, or tickets, do it now!
14:31:19 <praseodym> :t curry head
14:31:20 <dcoutts> dons: sure, read only is fine. I just don't know much about how to do mirroring at least not automatically.
14:31:21 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
14:31:21 <lambdabot>       Expected type: (a, b) -> c
14:31:21 <lambdabot>       Inferred type: [a1] -> a1
14:31:25 <waern> LordBrain: http://trac.haskell.org/haddock/ticket/10
14:31:31 <lambdabot> Title: #10 (Starting the module with -- | doc followed by a declaration doesn't parse)  ...
14:31:33 <dons> dcoutts: oh, its not too hard. lots of tools for it
14:31:34 <dcoutts> tromp: same way you install every other cabal package
14:31:35 <dons> esp. since we've a simple dir structure
14:31:40 <praseodym> vixey: ty
14:32:00 <tromp> dcoutts, that's my problem. i never used cabal before:(
14:32:20 <dcoutts> dons: right, but no people or tools will know to use the mirror, that's my point
14:32:38 <dcoutts> dons: keeping the mirrors up to date is just cron + rsync or whatever
14:32:40 <tromp> i guess i still need cabal itself
14:32:46 <waern> LordBrain: this is a very irritating bug
14:32:56 <dcoutts> tromp: yes you do and the other deps of cabal-install
14:33:02 <LordBrain> thanks waern
14:33:09 <LordBrain> this is my first haddock use, and i had no idea
14:33:13 <dcoutts> tromp: once you get Cabal, see the README, or see the instructions on the cabal website
14:33:23 <waern> LordBrain: yeah, it trips up new users
14:33:58 <LordBrain> yeah... i thought my configuration or somethign was all wrong
14:34:09 <LordBrain> been messing with it since yesterday
14:34:39 <dcoutts> waern: I'm especially interested in suggestions about how to manage all the cabal haddock flags when the user is just doing "cabal install foo", eg do we need to let them use --css etc?
14:35:10 <waern> dcoutts: mmkay... I'll have a look. I now remember I've read this ticket before :P
14:35:16 <dcoutts> waern: or what about generating hoogle dbs? or internal docs or whatever
14:35:20 <dcoutts> waern: thanks
14:35:40 <dcoutts> waern: implementing it is probably easy, but I don't know what the UI should be
14:35:53 <waern> dcoutts: ok
14:36:14 <LordBrain> waern, now i get this message and i dont see any html file anywhere: jimcrayne@joe-craynes-mac-pro:~$ haddock -B/opt/local/lib/ghc-6.8.2/ test.hs -o test.html
14:36:14 <LordBrain> Warning: main:Main: could not find link destinations for:
14:36:28 <LordBrain> GHC.Float.Float
14:36:39 <waern> LordBrain: you need to add --html
14:37:07 <praseodym> > uncurry head ([tail],"tail")
14:37:08 <lambdabot>  "ail"
14:37:26 <LordBrain> thanks again
14:37:33 <LordBrain> what's with that warning?
14:37:36 <praseodym> > head ([tail],"tail")
14:37:37 <lambdabot>  Couldn't match expected type `[a]'
14:37:46 <dons> dcoutts: right, i'd actually want to run the machine so that say, hackage.chalmers.se worked
14:38:59 <praseodym> :t uncurry head
14:39:00 <lambdabot> forall b c. ([b -> c], b) -> c
14:39:06 <dcoutts> dons: and how do we get say cabal-install to use the right mirror? or do we not try to do it automatically?
14:39:13 <dons> no, not automatically.
14:39:19 <dons> just publish the list
14:39:22 <dcoutts> ok, that's much simpler then
14:39:24 <dons> as for most distros
14:39:29 <dcoutts> dons: but only one for uploads
14:39:37 <dons> yeah, that's sipmlest
14:39:38 <dcoutts> and editing meta data and stuff
14:39:39 <praseodym> > uncurry head ("tail","tail")
14:39:39 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Char'
14:39:42 <waern> LordBrain: it can't find installed docs for the base package. To get that, you need to download the GHC sources and install the documentation with your current Haddock, then pass the paths to the installed docs with the --read-interface flag
14:39:42 <dons> most traffic is read only
14:40:02 <dcoutts> dons: so in fact a proxy would probably do
14:40:06 <waern> LordBrain: you can skip the --read-interface part if you use Cabal, because Cabal does that for you
14:40:24 <praseodym> :t uncurry
14:40:26 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:41:42 <praseodym> :T curry
14:41:45 <praseodym> :t curry
14:41:46 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:43:13 <praseodym> > uncurry $ head ([tail],"tail")
14:43:14 <lambdabot>  Couldn't match expected type `[a]'
14:43:19 <praseodym> > uncurry . head ([tail],"tail")
14:43:20 <lambdabot>  Couldn't match expected type `[a]'
14:43:31 <LordBrain> thanks waern... i will make a note of that for later, i have to go now, you've been very helpful. I appreciate it
14:43:43 <LordBrain> @karma +waern
14:43:43 <lambdabot> +waern has a karma of 0
14:43:48 <LordBrain> somethign like that
14:43:48 <waern> LordBrain: no problem
14:44:00 <LordBrain> @karma waern +1
14:44:00 <lambdabot> waern has a karma of 0
14:44:05 <LordBrain> i dont know how that works
14:44:10 <LordBrain> @karma++ waern
14:44:10 <lambdabot> waern's karma raised to 1.
14:44:13 <LordBrain> there
14:45:30 <Baughn> > uncurry (head.head) ("foo","bar")
14:45:31 <lambdabot>  Couldn't match expected type `[b -> c]'
14:46:00 <sutats> What library should I be using to work with JPGs and PNGs?
14:53:32 <praseodym> > uncurry head (["tail"],"tail")
14:53:33 <lambdabot>  Couldn't match expected type `b -> c'
14:53:47 <praseodym> > uncurry tail ([head],"tail")
14:53:48 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
14:53:58 <praseodym> I love tricky functions..
14:54:05 <praseodym> > head tail
14:54:06 <lambdabot>  Couldn't match expected type `[a]'
14:54:13 <praseodym> > :t head tail
14:54:13 <lambdabot>   parse error on input `:'
14:54:18 <praseodym> :t head tail
14:54:20 <lambdabot>     Couldn't match expected type `[a]'
14:54:20 <lambdabot>            against inferred type `[a1] -> [a1]'
14:54:20 <lambdabot>     In the first argument of `head', namely `tail'
14:55:00 <sutats> :t head . tail
14:55:02 <lambdabot> forall a. [a] -> a
14:55:42 <vixey> :t foldr (.) id
14:55:43 <lambdabot> forall a. [a -> a] -> a -> a
14:56:55 <praseodym> > head . tail "test"
14:56:55 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
14:58:42 <tromp> > head . tail $ "test"
14:58:44 <lambdabot>  'e'
14:59:11 <praseodym> > head [tail] "test"
14:59:12 <lambdabot>  "est"
14:59:16 <Baughn> Out of curiosity, is anyone working on concurrent or incremental GC for ghc?
15:00:48 <praseodym> what's the associativity in functions?
15:01:06 <Baughn> Ultimate. Function application binds more tightly than anything else.
15:01:11 <vixey> f x y z = ((f x) y) z
15:01:19 <ziman> left. :)
15:01:48 <praseodym> I see, that's why I couldn't get my head around the uncurry function. thanks :-)
15:02:13 <vixey> a -> b -> c = a -> (b -> c)
15:02:21 <rwbarton> @seen mmorrow
15:02:21 <lambdabot> mmorrow is in #haskell and #ghc. I last heard mmorrow speak 1h 48m 9s ago.
15:02:39 <praseodym> > head [[head]] [tail] "test"
15:02:39 <lambdabot>  Couldn't match expected type `[[a] -> [a]] -> [Char] -> t'
15:02:51 <praseodym> > head [head] [tail] "test"
15:02:52 <lambdabot>  "est"
15:03:05 <praseodym> I see :)
15:07:49 <mapreduce> What are the []s for?
15:08:07 <Zao> :t [head]
15:08:09 <lambdabot> forall a. [[a] -> a]
15:08:22 <MyCatVerbs> mapreduce: lists.
15:08:24 <Baughn> mapreduce: It makes it a one-element list, same as usual
15:08:28 <mapreduce> ah, heh
15:08:33 <mmorrow> rwbarton: i'm here
15:08:48 <Baughn> Heh. I actually didn't realize the syntax was that flexible
15:09:22 <mapreduce> :t head [head] [tail]
15:09:23 <lambdabot> forall a. [a] -> [a]
15:09:49 <mapreduce> *whimper*
15:09:55 <mmorrow> i just realized the (after the fact obvious kinda) that you can do at the *top* level (e.g.):
15:09:55 <mapreduce> :t head [head]
15:09:57 <lambdabot> forall a. [a] -> a
15:10:10 <mmorrow> [comma,dot,colon,semi] = ",.:;"
15:10:18 <mmorrow> *so* convenient
15:10:25 <mapreduce> > head [head] "test"
15:10:26 <lambdabot>  't'
15:10:36 <Baughn> mmorrow: Neat!
15:10:41 <mapreduce> Something just clicked.
15:10:46 <Baughn> Just goes to show, haskell still has more to teach you
15:10:53 <Baughn> (for all values of "you")
15:10:54 <mmorrow> Baughn: yeah, i was like "Whoa!" when it worked
15:11:04 <joey_> mmorrow: Ye, it's especially handy with Text.Regex of type (String, String, String, [String])
15:11:28 <joey_> Since you can pretty much garuntee the length of the list at the end
15:11:29 <mmorrow> joey_: interesting
15:11:36 <rwbarton> mmorrow: fons was interested in regexqq.  I cc'ed you on my response
15:12:04 <mmorrow> rwbarton: cool, i'll check
15:14:34 <praseodym> > [comma]
15:14:35 <lambdabot>  [,]
15:15:12 <nus> heh, would fully l17n'ized haskell be right-associative? for RTL languages?-)
15:15:56 <lament> l17n ? :)
15:16:06 <BMeph> mmorrow: Just wondering, but how tough would it be to "break out" just the quasiquoting stuff into its own module?
15:16:14 <Baughn> nus: What a horrible idea. ;)
15:16:25 <Baughn> There are good reasons not to localize programming languages. Or documentation or variable names.
15:16:45 <Baughn> (English is the One True Language. And I'm speaking as a norwegian.)
15:16:52 <rwbarton> :t comma
15:16:54 <lambdabot> Doc
15:17:04 <Baughn> :t head comma
15:17:06 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Doc'
15:17:06 <lambdabot>     In the first argument of `head', namely `comma'
15:17:08 <mmorrow> BMeph: not hard at all. actually, i'm glad you asked because i've wrote a little (about 40 lines) program that'll takes a string on stdin and spits out a skeleton QQ module on stdout
15:17:10 <lament> what do you know, there's no l17n but there's a relevant ul17n: ultrastandardization
15:17:14 <mmorrow> i'll paste it
15:18:32 <BMeph> mmorrow: Intriguing... :)
15:19:21 <hpaste>  oldsalt pasted "polymorphism problem" at http://hpaste.org/8567
15:19:27 <oldsalt> i am having a hard time inserting a polymorphic type as a record field. can anyone help me on that one?
15:20:54 <Baughn> oldsalt: You need to either make t an argument of the data type constructor, or use an existential
15:21:04 <praseodym> nus: then, of course, we'd have inverse assignments as well.. that's nice
15:21:23 <praseodym> like 10 = a; a*20 = b
15:21:33 <oldsalt> Baughn, so TheData has to depend on t?
15:21:42 <Baughn> oldsalt: Or use an existential
15:21:42 <rwbarton> oldsalt: data TheData a = forall t. TheClass t a => TheData ...
15:21:49 <rwbarton> I think
15:21:52 <praseodym> and 0/10 = b -> divide by zero error
15:21:52 <Baughn> oldsalt: As it is, there is insufficient information for it to decide /which/ TheClass is to be used. It could store the dictionary when you make it (though then you can only use relevant, non-type-escaping functions in the class.
15:22:07 <Baughn> oldsalt: ), but you haven't told it to.
15:22:30 <oldsalt> guys, i feel stupid again
15:22:35 <oldsalt> i really tried hard
15:22:47 <vixey> 0/10 -> dividy by 10 error
15:22:59 <oldsalt> and again it is so easy
15:23:12 <Baughn> oldsalt: If you have a Foo a => a.. you can only use functions that act directly on the a if you have a concrete (parametric) type for a
15:23:35 <Baughn> oldsalt: You can only /create/ a value when you have the exact type it should be, period, for obvious reasons
15:23:43 <nus> بلاه = foldr (*) [١..١٠]
15:23:57 <praseodym> vixey: not in an RTL programming language :-)
15:23:58 <nus> (-'
15:24:15 <hpaste>  morrow pasted "QQMod: QuasiQuoter module skeleton generator" at http://hpaste.org/8568
15:24:20 <Baughn> oldsalt: But you can /use/ the functions in Foo (that don't return a in any sense.. well, except for using function in Foo on the a again) by using existential quantification to tell it to store the dictionary in the data structure alongside the a
15:24:49 <hpaste>  morrow annotated "QQMod: QuasiQuoter module skeleton generator" with "usage" at http://hpaste.org/8568#a1
15:25:15 <mmorrow> BMeph: !
15:25:28 <vixey> What's RTL?
15:25:38 <Baughn> oldsalt: Does that make sense? There's a lot of documentation on this, but it'd really be easier to make t a parameter ot TheClass if that doesn't get in the way
15:25:42 <praseodym> vixey: right-to-left, like arabic languages
15:26:06 <oldsalt> yes, making t a parameter seems to be the way i have to choose
15:26:25 <oldsalt> i am not understanding everything you are writing (my technical english sucks)
15:27:17 <oldsalt> but thank you a lot. i am trying to work it out like you told me, but i have to adjust it in my real module which has some more lines than my silly example
15:27:43 <hpaste>  morrow annotated "QQMod: QuasiQuoter module skeleton generator" with "explanation" at http://hpaste.org/8568#a2
15:27:49 <Baughn> oldsalt: That's usually best, when you can do it. But note that existential quantification is one of the simpler ways to do a few OO things in haskell, so it's worth learning at some point
15:28:38 <oldsalt> is existentential quantification like using "forall"?
15:29:01 <Baughn> Well.. technically, forall is universal quantification; existential quantification would be using exists
15:29:29 <Baughn> But haskell doesn't support exists, and forall does the same thing when put one level further in.. I'm not too sure of the exact relationship there, to be honest
15:29:38 <Baughn> So yes, when you see forall, that's what's going on. Usually.
15:30:08 <RayNbow> there's a paper that briefly describes how it works [as a side note]
15:30:27 <oldsalt> ah, ok. forall is on my tolearn-list and i think i should give it more priority
15:30:52 <RayNbow> http://citeseer.ist.psu.edu/kieburtz99codata.html
15:30:53 <lambdabot> Title: Codata and Comonads in Haskell - Kieburtz (ResearchIndex)
15:30:55 <vixey> :t id
15:30:56 <lambdabot> forall a. a -> a
15:30:59 <RayNbow> page 3
15:31:02 <RayNbow> left column
15:31:28 <RayNbow> it shows the logical equivalence between forall and exists
15:31:50 * RayNbow doesn't understand it though :p
15:32:16 * Baughn blinks
15:32:29 <Baughn> That.. "pdf"... consists of images of text
15:32:32 <Baughn> Oh dear
15:32:40 <mmorrow> haha, i love that
15:32:52 <MyCatVerbs> Baughn: not even OCRed?
15:33:12 <Baughn> MyCatVerbs: Not printed
15:33:19 <atp> @index fix
15:33:19 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:33:39 <Baughn> MyCatVerbs: Zooming in reveals that it's been fed through a pdf printer or some such, but not scanned or anything
15:33:44 <Baughn> The pixels are perfect
15:33:45 <byorgey> yeah, sometimes older scanned papers are like that... I just printed out a 28-page such pdf today, it took for*ever*
15:34:05 <byorgey> oh, this one isn't scanned?  weird
15:34:14 <RayNbow> it's probably a weird conversion from the PS version
15:34:18 <atp> > fix $ (0:) . (1:) . ap (zipWith (+)) tail
15:34:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:34:25 <atp> whee
15:34:28 <Baughn> Quite. But it's definitely image data; the filesize shows it, as does the slowness.
15:34:33 * Baughn tries the ps
15:34:43 <MyCatVerbs> Baughn: so it's text converted to vectors? Ah, fair enough.
15:34:53 <MyCatVerbs> Baughn: just so long as it isn't bitmapped, ewww.
15:34:56 <Baughn> MyCatVerbs: Bitmapped.
15:35:03 <RayNbow> the PS version contains text [or at least gsview allows me to extract the text]
15:35:10 * atp hugs fix.
15:35:28 * RayNbow needs a better PS viewer for Windows though...
15:35:38 * sieni ghci fix
15:35:38 <MyCatVerbs> Baughn: oh whaaaaat, gross. I thought you meant it was all perfect curves. :/
15:35:47 <Baughn> Hm. Actually, I'm not sure
15:35:54 <Baughn> It /might/ be my pdf viewer that's going crazy
15:36:05 <Baughn> The ps has the same effect, but definitely does contain text
15:36:06 <oldsalt> Baughn; "adding the t" worked fine for me. i think i will go with that and postpone the learning session
15:36:22 <RayNbow> just out of curiousity, why the hell does citeseer offer an image version of a paper? :p
15:36:35 <atp> for people who don't have pdf or ps viewers probably
15:36:42 <atp> citeseer is the win
15:37:12 <Baughn> oldsalt: The neat part is that, if you /don't/, a TheData Int is a TheData Int despite the internal t being different, so you can put them in a list, map over them, etc.
15:37:15 <RayNbow> http://citeseer.ist.psu.edu/images/ba/b5/84/e0/6cbdab1eabc1cb6625e2ca82c68a5660/3.png <-- even people without a pdf or ps viewer don't want to read this :p
15:37:50 <MyCatVerbs> atp: seconded, thirded, and in fact {all the cardinals exceeding two}'d.
15:37:53 <EvilTerran> RayNbow, maybe if it used antialiasing and was twice the rez, i might read that
15:38:03 <MyCatVerbs> atp: citeseer FTW. ^_^
15:38:18 <EvilTerran> but i value my eyes too much to destroy them on that monstrosity
15:38:22 <RayNbow> :p
15:38:27 <oldsalt> Baughn: ah, i see the advantage. but my type is pretty special and i think i will not need that functionality
15:38:34 <sutats> What library should I be using to work with JPGs and PNGs?
15:38:43 <atp> oh, that's not so bad
15:38:54 <atp> i mean admittedly it isn't anti-aliased
15:38:56 <hpaste>  joey_ pasted "Can anyone "kleene" (<-- har har) this up?" at http://hpaste.org/8569
15:38:59 <atp> but it's readable
15:39:40 <atp> what if you really really needed to know how to implement a complex functional data structure and your IT department didn't let you download a pdf reader?
15:39:46 <atp> citeseer to the rescue!
15:39:47 <Baughn> MyCatVerbs: Well, there's definitely text in there. I don't get what's going on, but it must be my viewer.
15:40:06 <Baughn> atp: Download the ps, open in notepad? :P
15:40:29 <atp> Baughn: if the ps is written in such a way that it contains readable text, that's fine, but many ps files don't
15:40:54 <atp> i guess you could write a ps interpreter directly in machine language using notepad, and then open the file
15:40:56 <Baughn> atp: I write my .ps files by hand. They're quite readable.
15:41:07 <atp> that might be doable
15:41:17 <RayNbow> <atp> what if you really really needed to know how to implement a complex functional data structure and your IT department didn't let you download a pdf reader? <-- use my Windows Mobile phone? :p
15:41:21 <atp> Baughn: many ps files are machine-generated and illegible
15:41:46 <atp> RayNbow: my facist ip department forbids the use of cells at work
15:41:52 <Baughn> atp: I wrote a lisp-to-ps compiler some time ago that's been very handy. Well, okay, so it's really /that/ I'm using, but..
15:42:01 <atp> still cool.
15:42:08 <RayNbow> atp: please tell me you're kidding?
15:42:12 <Baughn> It makes graphs very tiny and zoomable. :D
15:42:13 <atp> RayNbow: nope.
15:42:31 <atp> RayNbow: of course, they're understandable paranoid about security, so...
15:42:39 <RayNbow> :p
15:51:47 <vixey> @quote
15:51:47 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
15:52:16 <vixey> @quote
15:52:17 <lambdabot> mrd says: the best preprocessor for java is rm
15:55:05 <nus> heh, sometimes you really need to add '-rf' to that [-:
15:56:20 <leoncamel> the haskell will first evaluate the express in same infix priority from left to right ?
15:56:49 <leoncamel> then it evaluate the sub-expressions with higher infix priority ?
16:00:21 <roconnor> leoncamel: I wouldn't use the word "evaluate" here
16:02:38 <vixey> leoncamel: Do you know what a weak head normal form is?
16:03:50 <leoncamel> roconnor: hmm, why ? maybe I can't express my question with right words.
16:05:28 <leoncamel> vixey: what do you mean ? I just confused about the lazy evaluation in haskell.
16:06:06 <vixey> leoncamel: Do you know what "weak head normal form" means?
16:06:27 <leoncamel> vixey: no. never heard about it .
16:07:11 <leoncamel> vixey: googling for it .
16:07:42 <vixey> leoncamel: a Constructor like (Just <whatever>), or a lambda (\x -> <whatever>) are in WHNF
16:07:50 <vixey> leoncamel: something like f x isn't though
16:08:03 <roconnor> leoncamel: is your question about evaluation or parsing?
16:08:25 <vixey> leoncamel: you can look at lazy evaluation as tugging on an expression until it's in WHNF then evaluting the insides
16:08:55 <leoncamel> roconnor: I am confused about the Lazy Evaluation in Haskell. I want know how haskell consider the evalutaion exactly ..
16:09:02 <roconnor> leoncamel: fixity and levels only affect the generation of the abstract syntax tree, and has nothing to do with evaluation.
16:09:52 <roconnor> leoncamel: beginners and intermediate haskell programers should simply ignore evaluation order in haskell.
16:10:01 <roconnor> because it doesn't matter.
16:10:41 <vixey> leoncamel: I gave you a kind of informal explanation about how it works, did it not make sense?
16:11:27 <roconnor> instead think of expressions as values
16:15:29 <hpaste>  (anonymous) pasted "broken FFT DIT" at http://hpaste.org/8570
16:16:06 <leoncamel> vixey: hmm, not very clear. but does WHNF only appear in lambda expression ?
16:17:24 <vixey> leoncamel: out of every possible term in haskell only a few of them can be called WHNF, those are ones which are constructor applied to some expression or lambda expression
16:18:05 <leoncamel> roconnor: why the order is not important ? for performance consideration, the evaluation order will affact the performance ? right ?
16:18:46 <EvilTerran> leoncamel, it doesn't affect the result of the program, tho
16:19:17 <roconnor> leoncamel: evaluation order affects performance somewhat (usually memory related performace more than anything).  But a beginner shouldn't worry about performance too much.
16:19:40 <EvilTerran> the report (the haskell standard) doesn't specify evaluation order - it barely touches on such things as performance at all
16:19:42 <leoncamel> vixey: OK. thanks.
16:20:22 <EvilTerran> (about the only performance-related-ish things i can think of are newtypes and strict fields
16:20:39 <roconnor> (unfortunately several beginner exercises invoving integers runs into some of these performace issues right away, which are actually less of a problem in more intermediate exercises)
16:20:46 <vixey> leoncamel: for example:  (\x -> (.) Just (+1)) (7 + 3)  is not in WHNF
16:20:50 <leoncamel> roconnor: OK. In haskell, we just describe the problem, and we shouldn't consider how to solve the problem in some order ?
16:21:01 <roconnor> leoncamel: that's right
16:21:02 <vixey> oops
16:21:11 <vixey> leoncamel: for example:  (\x -> ((.) Just (+1)) x) (7 + 3)
16:21:46 <vixey> leoncamel: you can pull on it a few times ~> ((.) Just (+1)) (7 + 3) ~> Just ((+1) (7 + 3)) and now it's in WHNF
16:22:47 <vixey> leoncamel: a pattern match:  case f x of ... Just x -> _ ; Nothing -> should just take one WHNF to choose which case to go
16:23:14 <vixey> (but it will only do so when the value of the result of the case is required)
16:24:20 <leoncamel> vixey: sorry, I am confused about the expression "(\x -> ((.) Just (+1)) x) (7 + 3)". why the result is "11" ?
16:25:01 <vixey> I never mentioned 11
16:25:38 <chessguy> > ((.) Just (+1)) 10
16:25:39 <leoncamel> vixey: I paste it into ghci, the result is "11"
16:25:41 <lambdabot>  Just 11
16:26:16 <chessguy> leoncamel: do you understand how i got from your expression to that one?
16:26:42 <leoncamel> chessguy: :). yes.
16:26:47 <vixey> :S
16:26:51 <chessguy> @pl (.)
16:26:51 <lambdabot> (.)
16:26:56 <chessguy> @src (.)
16:26:56 <lambdabot> (f . g) x = f (g x)
16:26:56 <lambdabot> -- In lambdabot, it's been generalised to:
16:26:56 <lambdabot> (.) = fmap
16:27:06 <vixey> chessguy, wasn't really lazy evaluation
16:27:26 <chessguy> so now we've got Just ((+1) x)
16:27:40 <chessguy> err, Just ((+1) 10)
16:27:51 <chessguy> vixey:  bah.
16:28:01 <chessguy> it's called didactic liberties
16:28:30 <vixey> just incase you didn't know
16:28:42 <chessguy> @go haskell wiki lazy evaluation
16:28:43 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
16:28:43 <lambdabot> Title: Introduction - HaskellWiki
16:29:33 <chessguy> hrm. where'd my lazy evaluation page go?
16:30:14 <chessguy> ah, there it is: http://haskell.org/haskellwiki/Haskell/Lazy_evaluation
16:30:15 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
16:32:18 <mmorrow> rwbarton: what would be the correct method to send my recent mail to the list so that it's inserted into the correct place in the tree?
16:34:04 <mmorrow> oh i think i have a guess, trying that...
16:35:43 <leoncamel> :). thanks. more clear than before .
16:37:11 <telemac1> i deleted my old ghc installation, downloaded the newest version and now hackage is down and i can't install any further. doh.
16:37:22 <telemac1> time to go to bed..
16:37:24 <telemac1> n8
16:37:51 <Baughn> telemac1: Eh? It's up..
16:38:09 * Baughn blinks. Huh. It /was/ up, twenty seconds ago
16:40:06 <shapr> What did I miss?
16:40:13 <mjrosenb> i  have a list that has 30,000,000 Bool's in it
16:40:27 <mjrosenb> why is ghci taking up over 4G of RAM?
16:40:44 <shapr> Is it a strict list?
16:40:54 <Baughn> > 30000000 * 8 * 3 / 1024^3
16:40:55 <lambdabot>  0.6705522537231445
16:41:08 <Baughn> ..that's odd
16:41:26 <mjrosenb> shapr: no, but i did just compute it's length
16:41:27 <mjrosenb> oh.
16:41:30 <Baughn> mjrosenb: You're on a 256-bit machine?
16:41:44 <mjrosenb> it has a ton of lambdas that will evaluate each position
16:41:57 <mjrosenb> and the lambdas each have a context
16:42:08 <leoncamel> a stupid question. can I write a function, which takes variable parameters ?
16:42:08 <mjrosenb> Baughn: i wish... 64
16:42:12 <Baughn> I don't think the finished list should take more than .67GB, even on a 64-bit machine
16:42:20 <Baughn> Two words for each list element, plus one for the bool
16:42:57 <geezusfreeek> leoncamel: not a stupid question. there is no direct way, but i think there are some type system hack-ish ways to do it
16:43:31 <shapr> geezusfreeek: polyvariadic args!
16:43:41 <geezusfreeek> ??
16:43:57 <geezusfreeek> i guess you mean there is a non-hack-ish way?
16:44:11 <Baughn> mjrosenb: Yeah. On my 32-bit machine it's exactly half that, so.. three words per.
16:44:16 <shapr> @go polyvariadic arguments
16:44:17 <lambdabot> http://okmij.org/ftp/Haskell/vararg-fn.lhs
16:44:26 <shapr> geezusfreeek: Well, it's an oleg...
16:44:33 <geezusfreeek> oh, oleg :P
16:44:38 <shapr> Depends on whether you consider that hackish or not.
16:45:08 <mjrosenb> Baughn: so you're saying that it should be much smaller than what it is currently?
16:45:13 <geezusfreeek> i tend to consider a lot of oleg solutions to be impractical for large programs, which i guess would be considered hackish
16:45:41 <Baughn> mjrosenb: No, I'm saying your generation is more complex than (replicate 30000000 True) and you're seeing memory use from /that/. The finished product /will/ be less than a gig
16:45:57 <vixey> geezusfreeek: depends on what they are solutions too
16:45:57 <vixey> to *
16:46:11 <mjrosenb> Baughn: ok, it's the bit representation of a file
16:46:12 <mjrosenb> also
16:46:14 <geezusfreeek> that is true. i'm just over-generalizing
16:46:15 <Baughn> mjrosenb: That said, you could save a lot of memory by using STUArray to build it - that'd make it one /bit/ per bool
16:46:22 <Cale> Oleg has a strange way of pointing out the weaknesses of Haskell's type system by highlighting its strengths.
16:46:34 <Baughn> mjrosenb: Or, if it's just reading in a file, use UArray
16:46:39 <geezusfreeek> Cale: well-put
16:46:41 <mjrosenb> i just declared xor and applied it once
16:46:49 <mjrosenb> and it hasn't come back yet
16:47:03 <Baughn> ..well, it's doing /something/ odd
16:47:08 <Baughn> Cna I see the code?
16:47:20 <shapr> ooh, code?
16:47:33 <mjrosenb> Baughn: which coode?
16:47:51 <mjrosenb> Baughn: it will take a wwhile.  most of my system has been paged out
16:47:54 <Baughn> mjrosenb: The code that makes your list. Shouldn't be more than a few lines, right?
16:48:02 <Baughn> mjrosenb: I dare say it's time to killall -9 ghc. :P
16:49:17 <mjrosenb> bitRead c = map (testBit c) bitOrder
16:49:24 <mjrosenb> bitify = concatMap bitRead
16:49:35 <mjrosenb> mostly those two
16:49:57 <mjrosenb> so with 4G of ram on here, it's still mostly usable
16:50:16 <leoncamel> can I generate *.lhs file into document ? for example, html, latex, or something else.
16:50:23 <mjrosenb> also seem to be giving my hd a workout
16:50:39 <Baughn> mjrosenb: A thunk can be a fairly large structure, compared to a bool that's a single word
16:50:41 <shapr> @seen LeCamarade
16:50:41 <lambdabot> I haven't seen LeCamarade.
16:50:43 <shapr> foo
16:51:07 <sutats> What library should I be using to work with JPGs and PNGs?
16:51:13 <Baughn> mjrosenb: I don't know what you're doing, but I really think you should consider using it with STUArray. You'd get a literal hundred-fold saving in memory.
16:51:18 <mjrosenb> which was more or less what i was saying
16:51:32 <mjrosenb> i'm looking into it as we speak
16:51:50 <mjrosenb> Baughn: does it allow me to do list-stlye pattern matching on it?
16:51:53 <Baughn> mjrosenb: Also, in the future, pass +RTS -M500m or something to your program; it'll make it crash before exceeding some amount of memory, instead of horrifying your system
16:51:53 <shapr> sutats: Adam Langley has a JPG lib.
16:52:02 <shapr> I'm not sure about a PNG lib.
16:52:23 <Baughn> mjrosenb: Not as easily; it's basically a C-type array
16:52:39 <mjrosenb> hrmm
16:52:40 <mjrosenb> :(
16:52:41 <sutats> shapr: Hm, okay, I noticed there's a GD library too, but I'm not sure how solid it is.
16:52:42 <Baughn> mjrosenb: The alternative is to handle your list as a stream, so you get the advantage of laziness
16:53:00 <Baughn> mjrosenb: (Which, if possible, would make it work in a few /kilobytes/
16:53:18 <mjrosenb> Baughn: well in practice, I'll never need the whole anything in ram at ance
16:53:53 <Baughn> mjrosenb: But do you jump around, or work from one end to the other?
16:54:06 <mjrosenb> run through it linearly
16:54:10 <shapr> sutats: Have you checked the library list on hackage.haskell.org ?
16:54:37 <Baughn> mjrosenb: Then that shouldn't be a problem. Just be careful not to use length on it.. or run without -H500m, just in case. ;)
16:54:40 <Baughn> Er, -M500m
16:55:00 <sutats> shapr: Yeah, I have, and there are a few libraries that seem to be able to do it.
16:55:04 <mjrosenb> yeah... i've noticed
16:55:07 <sutats> shapr: I was hoping for one to stick out from the rest.
16:55:22 <shapr> sutats: Or if you're bored, you could write one of your own using the Real World Haskell file format parsing examples :-)
16:56:11 <mjrosenb> *hopefully* deforistation should eliminate the lists entirely
16:56:51 <sutats> shapr: I was actually planning on playing around with an image compression implementation of my own.
16:56:57 <shapr> sutats: oh cool!
16:58:12 <LordBrain> what's the standard way of uninstalling something i installed with Setup.lhs install ?
16:58:16 <Baughn> mjrosenb: So.. [bool,bool,bool] is just three words per element; [function making bool plus arguments,...] is a lot more. ;)
16:58:25 <LordBrain> there's no uninstall command
16:58:33 <Baughn> LordBrain: There isn't one
16:58:54 <shapr> ghc-pkg unregister ?
16:58:54 <LordBrain> why isn't there?
16:58:54 <Baughn> So far there isn't enough software around for that to be a problem
16:58:59 <sutats> shapr: But it would be nice to get familiar with a good JPG manipulation library first.
16:59:11 <Baughn> LordBrain: Nobody has written one. There /is/ enough information to do so, certainly
16:59:25 <Baughn> shapr: That just removes it from the package registry; the files are left behind
16:59:34 <LordBrain> well that's rather unfriendly
16:59:39 <LordBrain> to newcomers
17:00:25 <vixey> why don't you just delete the files?
17:00:26 <LordBrain> how do i uninstall haddock?
17:00:34 <vixey> this is what I have done
17:00:35 <LordBrain> where are they to delete?
17:01:14 <Baughn> LordBrain: Why do you want to?
17:01:16 <geezusfreeek> i used to worry about that, but really, unregistering has proven good enough for me
17:01:29 <vixey> maybe running the installer will print out where it's putting the files
17:01:43 <LordBrain> Baughn, well i see it is in macports, and since i'm using the macports ghc, i thought maybe it would be cleaner to use the macports haddock
17:02:04 <LordBrain> it's a prior version... but i'm ok with that for now
17:02:06 <Baughn> LordBrain: Possibly. Well, try which haddock, then delete the binary
17:02:37 <Baughn> LordBrain: My own preferred solution is to delete all /usr/local/*. A bit slashy, but I've got a script to recreate it
17:03:21 <LordBrain> everything under /usr/local?
17:03:24 <LordBrain> that's crazy
17:03:33 <LordBrain> i dont have a script to recreate that
17:03:39 <mapreduce> That's amusing.
17:03:42 <solrize> this would never happen in haskell: i sent in a search query to a certain python program, but left the query field empty, expecting to get back an error message.  instead it found a bunch of books written by the diet doctor Gary Null.
17:04:01 <BMeph> ROFLMAO!
17:04:02 <geezusfreeek> sure it could happen in haskell
17:04:08 <Baughn> LordBrain: Might want one
17:04:09 <mapreduce> solrize: Magic.
17:04:11 <solrize> hehe
17:04:15 <mjrosenb> Baughn: LOL
17:04:20 <mjrosenb> errr
17:05:25 <vixey> lol
17:05:50 <vixey> @remember <solrize> this would never happen in haskell: i sent in a search query to a certain python program, but left the query field empty, expecting to get back an error message.  instead it found a bunch of books written by the diet doctor Gary Null.
17:05:50 <lambdabot> It is forever etched in my memory.
17:06:03 <mapreduce> @quote python
17:06:03 <lambdabot> sieni says: python, like php, is just training wheels without the bike
17:06:08 <shapr> Real World Haskell r0xx!
17:06:32 <shapr> @quote null
17:06:32 <lambdabot> <solrize> says: this would never happen in haskell: i sent in a search query to a certain python program, but left the query field empty, expecting to get back an error message.  instead it found a
17:06:32 <lambdabot> bunch of books written by the diet doctor Gary Null.
17:06:47 <mapreduce> shapr: To be followed by "So You've Been Forced Into Writing Haskell; Here's How To Write It Like C"?
17:06:52 <cjb> that doesn't make much sense
17:07:11 <cjb> since Python has no concept of null, and instead has the None object
17:07:33 <shapr> Maybe the db binding layer takes None as null?
17:08:06 <cjb> that might be it, or the C layer if it's a frontend to Lucene or so
17:09:47 <LordBrain> my mouse cursor is moving even tho my mouse is still
17:10:17 <Baughn> LordBrain: A hacker did it
17:10:24 <LordBrain> coudl be
17:10:32 <mapreduce> Alyssa again.
17:10:47 <solrize> i guess that's what python does when you dereference a null pointer ;-)
17:11:17 <mapreduce> Or it's what your DB does when you pass it null.
17:11:18 <shapr> Microsoft gave a presentation to my dev group yesterday. Surprisingly, they tried to skip past anonymous functions and lazy eval in LINQ, I guess the presenter thought it would scare most people.
17:11:29 <solrize> mapreduce, yeah
17:11:34 <mapreduce> shapr: hehe
17:12:04 <shapr> Last month the subject was visual studio, and the presenter claimed that F# was Microsoft's clone of Haskell.
17:12:35 <shapr> I told him he should really learn Haskell.
17:12:47 <vixey> Does F# have mutable variables and strict evaluation?
17:12:53 <mapreduce> The lazy eval in linq is really quite good.
17:12:54 <solrize> F# is ocaml
17:12:58 <shapr> vixey: yup
17:13:04 <shapr> F# is really microsoft's clone of ML.
17:13:18 <solrize> it's more of a repackaging than a clone
17:13:25 <shapr> ML.net ?
17:13:29 <vixey> shapr: geez.. It's a shame someone would mix things up so badly
17:13:32 <Pseudonym> Or, perhaps, a mutation rather thana clone.
17:13:35 <solrize> i.e. it's ocaml with some .net libraries and some modifications to the surface syntax
17:13:38 <solrize> but it's the ocaml codebase
17:13:44 <solrize> right, mutation
17:14:04 * mjrosenb tries to run foldl (/=) False on the list to see if the results are any nicer
17:14:15 <vixey> but it's probably more *powerful* than ocaml and a variety of other buzzwords
17:14:25 <mjrosenb> no.
17:14:31 * shapr shrugs
17:14:34 <shapr> I haven't used F#
17:14:41 <roconnor> > 119/93 :: CReal
17:14:41 <Baughn> mjrosenb: They should be. That would actually force it to be evaluated.
17:14:42 <lambdabot>  1.2795698924731182795698924731182795698925
17:14:59 <Baughn> mjrosenb: Though you'll want foldl'
17:16:00 <mjrosenb> Baughn: taking up 3991m ram currently
17:16:06 <mjrosenb> Baughn: what's the difference?
17:16:16 <solrize> http://research.microsoft.com/fsharp/fsharp.aspx
17:16:28 <mjrosenb> i assume i need to import list first?
17:16:53 <Baughn> mjrosenb: foldl' is explicitly strict. foldl is pretty much only useful if/when the strictness analyzer turns it into foldl'
17:17:00 <solrize> they use "generic" when they mean "polymorphic"
17:17:47 <mjrosenb> i see
17:18:04 <Baughn> > foldl f a [b,c,d]
17:18:05 <lambdabot>  f (f (f a b) c) d
17:18:12 <Baughn> > foldr f a [b,c,d]
17:18:13 <lambdabot>  f b (f c (f d a))
17:18:51 <Baughn> mjrosenb: Well, as you see. foldr is potentially lazier, but if laziness doesn't help, it fails by not being tail-recursive
17:18:59 <mjrosenb> woah, foldl just gave a stack overflow
17:19:08 * mjrosenb blinks
17:19:25 <Baughn> mjrosenb: foldl' is tail-recursive, which means it produces a giant list of thunks that eventually turns into a stack overflow on evaluation
17:19:35 <mar77a> Maybe is used for optional function arguments?
17:19:49 <mar77a> http://haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html#v%3ArunProcess like here?
17:19:49 <Baughn> mjrosenb: Rather, foldl is. foldl' evaluates the thunks as it makes them, removing the stack overflow
17:19:50 <lambdabot> http://tinyurl.com/38wv7e
17:19:51 <mjrosenb> Baughn: with or without the prime? because this was without
17:19:57 <mjrosenb> ok then
17:19:59 <Baughn> mjrosenb: Yeah, my bad
17:20:08 <Baughn> mar77a: Yes, typically
17:20:27 <mjrosenb> also, i think ghci runs a gc pass before it processes every input
17:20:34 <mar77a> is it considered good practice?
17:20:44 <mjrosenb> because import List hasn't come back yet
17:20:48 * mjrosenb kills ghci
17:21:14 <Baughn> mjrosenb: You noticed that? Actually, the ghc rts runs a GC pass whenever /anythign/ has happened and the system then proceeds to be idle for a fraction of a second, to take advantage of the downtime
17:21:37 <Baughn> mar77a: It's pretty common. As opposed to what?
17:22:08 <mar77a> well i remember when i asked if it was possible to define functions with optional (read: default) arguments i was told not
17:22:13 <mjrosenb> gc passes on swap are slow
17:22:14 <mar77a> but this seems like a nice trick
17:22:26 <Baughn> mjrosenb: Oh, and you /really/ should run with +RTS -H500m or something, when experimenting with this
17:22:33 <Baughn> -M500m, I mean
17:22:51 <Baughn> mar77a: Well, the argument isn't optional then. It's just sometimes Nothing.
17:22:56 <mjrosenb> pass that into ghci?
17:23:03 <mar77a> capisce
17:23:08 <Baughn> mjrosenb: Or any other ghc-produced program, yes
17:23:23 <Baughn> mjrosenb: ghci is actually ghc, which is itself a ghc-produced program
17:23:31 <mjrosenb> Baughn: i've noticed
17:23:41 <mjrosenb> ghc-86.8.2 -interactive
17:23:56 <mjrosenb> err --interactive
17:23:59 <LordBrain> 86?
17:24:20 <mjrosenb> 6.8.2
17:24:25 <LordBrain> thought so
17:24:41 <LordBrain> so you had the number of characters right at least
17:24:47 <LordBrain> :)
17:24:48 <mjrosenb> my system is lagging a bit.  i tried to correct it, but my system didn't catch all of the ^H's
17:25:18 <mjrosenb> where is foldl' located
17:25:18 <LordBrain> i see
17:25:28 <mjrosenb> ?
17:25:32 <mjrosenb> it's not in List
17:26:01 <LordBrain> @hoogle foldl'
17:26:01 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
17:26:01 <lambdabot> Data.Foldable.foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
17:26:01 <lambdabot> Data.ByteString.foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
17:26:33 <LordBrain> people don't use List anymore, we all use Data.List now, get with the times
17:26:41 <LordBrain> :)
17:26:58 <mjrosenb> is List an alias for Data.List?
17:27:00 <Baughn> List is the H'98 variant, which has no extensions
17:27:07 <Baughn> foldl' is an extension
17:27:10 <mjrosenb> i see
17:27:45 <vixey> huh?!
17:27:46 <Baughn> H'98 sees no need for it, since it doesn't alter results a whit. And a sufficiently smart compiler /will/ turn foldl into foldl'
17:27:54 <Baughn> Actually, ghc -O2 usually manages just that
17:27:56 <vixey> if a product is (,) the coproduct is a sum (Either)
17:27:56 <mjrosenb> ooh, does this mean that there are extensions in Data.Maybe as well?
17:28:12 <Baughn> Could be
17:28:18 <vixey> :t (,)
17:28:20 <lambdabot> forall a b. a -> b -> (a, b)
17:28:21 <Baughn> There certainly wouldn"t be in Maybe
17:28:28 <vixey> :t Left
17:28:29 <lambdabot> forall a b. a -> Either a b
17:29:04 <ddarius> Baughn: No compiler could be "smart" enough to turn foldl into foldl' any time it could be.
17:29:21 <Baughn> ddarius: Thus the "usually"
17:30:14 <ddarius> Baughn: Also, there are times when foldl' -will- lead to a different function than foldl and thus a smart compiler definitely should -not- change one into the other.
17:30:25 <ddarius> Yet, foldl' is still what you want.
17:30:41 <Baughn> ddarius: With regards to bottoms, am I right?
17:32:06 <ddarius> Baughn: Yes, they'll be different with regards to what values they are defined for.
17:33:01 <mjrosenb> i still want a few functions to be in the Maybe library
17:34:00 <LordBrain> can Setup.lhs give me a list of files it installs?
17:34:14 <mjrosenb> hey, with foldl' it runs in almost no memory :)
17:34:25 <mjrosenb> htat being slightly over 2 gigs
17:34:44 <ddarius> You almost never want foldl.
17:35:06 <Baughn> > foldr f a [b,c,d]
17:35:06 <mar77a> blargh what's the point in defining your own infix functions if most are taken and you have to use Main.symbol(s)
17:35:07 <lambdabot>  f b (f c (f d a))
17:35:15 <mar77a> is there any way to hide default prelude functions?
17:35:25 <Zao> import Prelude hiding (omg,wtf,bbq)
17:35:31 <Baughn> mjrosenb: See that? If "f b (..)" will return a value /without/ looking at the second argument, foldr is good
17:35:51 <mjrosenb> Baughn: yes, i know
17:36:03 <Baughn> mjrosenb: But if it has to do that, and the second does the same, and so on....
17:36:03 <vixey> import Prelude hiding ((.))
17:36:07 <vixey> (.) = fmap
17:36:10 <mjrosenb> very rarely do i have those
17:36:16 <vixey> :)
17:36:16 <mar77a> weird
17:36:17 <mar77a> when i do
17:36:18 <mar77a> import Prelude hiding((+))
17:36:19 <mar77a> (+) a b = a + b
17:36:28 <mar77a> it hangs when i try "2+3"
17:36:37 <Zao> You're calling yourself.
17:36:46 <vixey> mar77a: obviously
17:36:48 <Baughn> ddarius: Oh, but could you construct a use for foldl that doesn't look totally artificial? ;)
17:36:54 <LordBrain> yeah that's recursion
17:36:56 <vixey> mar77a: call it f instead of (+)
17:37:18 <mar77a> doh
17:37:20 <mar77a> LoL
17:37:31 <mjrosenb> so i'd like map :: (a -> b) -> Maybe a -> Maybe b; mapPartial :: (a -> Maybe b) -> Maybe a -> Maybe b and condenso :: Maybe Maybe a -> Maybe a
17:37:54 <vixey> > 7 Prelude.+ 6
17:37:56 <lambdabot>  13
17:37:58 <mjrosenb> i've ended up writing all of them at one point or other in my ramblings
17:38:07 <vixey> :t join
17:38:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:38:19 <LordBrain> you could try Prelude.(+) maybe
17:38:27 <vixey> mjrosenb: I think they all exist already with different names
17:38:43 <vixey> :t flip (>>=)
17:38:43 <ddarius> Baughn: I couldn't think of one when I originally wrote Stack_overflow.  However, there are cases where there is no clear choice between any of foldl', foldl or foldr.
17:38:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
17:38:47 <LordBrain> not sure if that notation works with operators
17:38:53 <mjrosenb> vixey: in Data.Maybe, i don't see anything with the correct types
17:39:07 <vixey> LordBrain: I just gave an example
17:39:16 <vixey> mjrosenb: look at lambdabot
17:39:17 <LordBrain> oh
17:39:24 <vixey> sub m for Maybe
17:39:30 <mjrosenb> vixey: how?
17:39:33 <LordBrain> my eyes can't be everywhere at once
17:39:34 <vixey> :t fmap
17:39:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:39:36 <LordBrain> sorry
17:39:55 <vixey> how what?
17:40:07 <mjrosenb> vixey: how should i look at lambdabot?
17:40:08 <vininim> :t lift
17:40:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
17:40:24 <vixey> in this IRC channel
17:40:27 <LordBrain> mjrosenb, cross-eyed?
17:40:31 <LordBrain> :)
17:40:51 <mjrosenb> cool, I can see a dolphin in lambdabot
17:40:55 <LordBrain> with your head tilted
17:41:29 <LordBrain> now i want a lambda tee shirt
17:41:52 <mjrosenb> right, so iirc, there's some way of giving lambdabot a type signature and it would give functions matching that signature
17:42:03 <LordBrain> hoogle
17:42:05 <mjrosenb> but i don't remember how to do that
17:42:17 <mjrosenb> @hoogle a -> a
17:42:18 <lambdabot> Prelude.id :: a -> a
17:42:18 <lambdabot> Data.Function.id :: a -> a
17:42:18 <lambdabot> GHC.Exts.breakpoint :: a -> a
17:42:30 <LordBrain> is that what you meant?
17:42:30 <Baughn> @djinn Int -> Int
17:42:33 <lambdabot> f a = a
17:42:33 <mjrosenb> cool
17:42:49 <LordBrain> tehre's also @djinn like Baughn used
17:42:55 <mjrosenb> Baughn: that does'nt give library functions though
17:43:07 <mjrosenb> i already know the code that each of these needs to be
17:43:20 <mjrosenb> @hoogle Maybe Maybe a -> Maybe a
17:43:21 <lambdabot> No matches, try a more general search
17:43:22 <Baughn> @hoogle a
17:43:22 <lambdabot> Prelude.abs :: Num a => a -> a
17:43:23 <lambdabot> Prelude.asin :: Floating a => a -> a
17:43:23 <lambdabot> Prelude.acos :: Floating a => a -> a
17:43:28 <vininim> : liftM (+1) $ Just 1
17:43:28 <Baughn> mjrosenb: join
17:43:34 <LordBrain> mjrosenb, i use the firefox plugin for hoogle, http://www.haskell.org/hoogle/
17:43:34 <lambdabot> Title: Hoogle
17:43:36 <vininim> :t liftM (+1) $ Just 1
17:43:38 <lambdabot> forall a1. (Num a1) => Maybe a1
17:43:41 <Baughn> > join (Just (Just 2))
17:43:45 <lambdabot>  Just 2
17:43:48 * mjrosenb doesn't use firefox
17:43:50 <vininim> > liftM (+1) $ Just 1
17:43:51 <lambdabot>  Just 2
17:44:05 <LordBrain> oh, well you can use the website still
17:44:05 <vininim> mjrosenb: Maybe is a monad
17:44:12 <LordBrain> bookmark it or something
17:44:19 <Apocalisp> maybe it is, maybe it isn't
17:44:28 <LordBrain> unless you're on irc everytime you write haskell anyway
17:44:30 <mjrosenb> vininim: i know.  i've been using that fact
17:44:42 <mjrosenb> i'd like a cli interface to hoogle
17:45:00 <LordBrain> i think there is one, but i dont have it
17:45:22 <mjrosenb> LordBrain: any idea what it's called
17:45:29 <LordBrain> hoogle
17:45:34 <LordBrain> heh
17:45:35 <vininim> > Just1 >>= return.(+1)
17:45:36 <lambdabot>   Not in scope: data constructor `Just1'
17:45:40 <vininim> > Just 1 >>= return.(+1)
17:45:41 <lambdabot>  Just 2
17:45:47 <LordBrain> lambdabot uses that under the hood i think
17:45:58 <Baughn> mjrosenb: cabal install hoogle. ;)
17:45:59 <LordBrain> i think some peopel have hoogle in their ghci
17:47:06 <mjrosenb> Baughn: i tend to not use cabal... but i'll get it
17:47:21 <mjrosenb> LordBrain: that would be sexy
17:48:48 <ddarius> liftM == fmap
17:48:53 <LordBrain> http://www.haskell.org/haskellwiki/Hoogle
17:48:54 <lambdabot> Title: Hoogle - HaskellWiki
17:49:38 <vininim> idioms < monads =P
17:50:25 <LordBrain> i like the >>$ notation
17:50:52 <LordBrain> > let (>>$) = flip fmap in Just 1 >>$ (+1)
17:50:53 <lambdabot>  Just 2
17:50:56 <vixey> @hoogle Idiom
17:50:56 <lambdabot> No matches found
17:51:27 <vixey> LordBrain: I prefer
17:51:29 <LordBrain> i got that from someone in here... maybe dons
17:51:36 <vixey> > (+1) . Just 1
17:51:37 <lambdabot>  Just 2
17:51:42 <vininim> @hoogle Applicative
17:51:43 <lambdabot> Control.Applicative :: module
17:51:43 <lambdabot> Control.Applicative.Applicative :: class Functor f => Applicative f
17:52:05 <dolio> <$> you mean?
17:52:27 <LordBrain> @src (<$>)
17:52:27 <lambdabot> f <$> a = fmap f a
17:52:32 <dolio> Actually, I guess that's fmap, not flip fmap.
17:54:36 <LordBrain> i like to see it in that left to right order
17:54:41 <mjrosenb> vixey: that works because there's an instance of Applicitive Maybe?
17:54:54 <LordBrain> mjrosenb, it works because she redefined (.)
17:55:02 <mjrosenb> oohh
17:55:05 <mjrosenb> i see
17:55:10 <geezusfreeek> :t (.)
17:55:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:55:18 <LordBrain> @src (.)
17:55:19 <lambdabot> (f . g) x = f (g x)
17:55:19 <lambdabot> -- In lambdabot, it's been generalised to:
17:55:19 <lambdabot> (.) = fmap
17:55:23 <ddarius> LordBrain: Cale did, not vixey
17:55:39 <LordBrain> they both do
17:55:45 <LordBrain> i guess
17:55:58 <vixey> though I do use this :)
17:56:09 <mjrosenb> right, is there any page of STUarray, the only useful hit on google seems to be down
17:57:09 <LordBrain> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-ST.html
17:57:09 <lambdabot> http://tinyurl.com/5a3dys
17:58:02 <sutats> What's the difference between STUArray and UArray in terms of when you want to use one over the other?
17:58:11 <mjrosenb> have i ever mentioned that you guys are awesome?
17:58:13 <ddarius> One's mutable one isn't.
18:02:51 <sutats> Is one more efficient than the other?
18:03:12 <dolio> Depends on the task.
18:03:25 <sutats> Could you elaborate on that?
18:03:39 <dolio> If you need to mutate it, then STUArray is more efficient.
18:03:39 <sutats> Cases where each one is more efficient?
18:04:23 <ddarius> sutats: Mutable v. immutable is a huge difference.  You simply wouldn't use them in the same situations.
18:04:38 <dolio> Otherwise, they're probably about the same, I guess.
18:05:22 <sutats> So say you want to read a binary file into an array, do some operations on it, and write it back out? You probably want STUArray?
18:05:24 <dolio> Although the mutable one requires monadic style, while the immutable one can be used in pure code, so they'd be quite different in practice.
18:06:05 <ddarius> sutats: It depends on what operations you want to do.
18:06:40 <ddarius> sutats: It's like a hash table v. a list.  Which you want depends on what you want to do.
18:07:28 <sutats> ddarius: Okay, makes sense. The size of what you're reading in needs to be taken into consideration too, because UArray would duplicate it, right?
18:08:48 <ddarius> sutats: If you wanted to "update an element" of the UArray, yes, you'd get a copy.  But say you wanted to increment all elements by one, then you'd only need a copy temporarily (and that conceivably could be optimized away).
18:08:55 <LordBrain> i've never seen anyone insulted in #haskell for simply not knowing something already.. I can't say the same for very many language help channels...  Perhaps there are some positive cultural side effects to this language over other ones.. Perhaps it is a positive legacy to the language's historical roots in academia.
18:09:19 <LordBrain> or perhaps i'm severly biased :)
18:09:20 <mapreduce> LordBrain: I think it's the lack of compulsory XML.
18:09:29 <LordBrain> lol
18:09:35 <mjrosenb> LordBrain: sml is also really nice.. a bit empty,  but nice
18:09:52 <mmorrow> haha => cat /dev/urandom | /dev/audio& ; while [[ true ]]; do cat /dev/urandom | /dev/fb0; done
18:09:58 <mmorrow> http://code.haskell.org/~morrow/code/images/catnullfbaudio.jpg
18:10:12 <mjrosenb> #bash has many arguments, but not usually for noobs
18:10:22 <mapreduce> #scala is 1/8 the size of #haskell but similar in that way.
18:10:22 <mjrosenb> mmorrow: shouldn't the first | be a >?
18:10:26 <sutats> ddarius: Hm, okay, I think I'm getting the difference. Thanks.
18:10:31 <mmorrow> yeah
18:10:37 <mmorrow> mjrosenb: yes
18:10:55 <LordBrain> maybe it will be different when managers are pushing haskell down people's throats or something
18:11:08 <mmorrow> also, i don't think it'd work to background the first one on the same lines as the second, but you get the idea
18:11:17 <mmorrow> s/lines/line/
18:11:24 <ddarius> LordBrain: 'cuz of all those managers pushing Lisp down people's throats...
18:11:26 <Baughn> mmorrow: Works fine, but by replacing the ; with &
18:11:31 <Baughn> You can't have /both/
18:11:34 <mmorrow> interesting
18:11:43 <LordBrain> ah you've had some negative lisp experiences huh
18:11:53 <mmorrow> that's probably why it never worked for me :)
18:11:56 <ddarius> LordBrain: No.  Not really.  But I have seen the community.
18:12:02 <LordBrain> i see
18:12:11 <Baughn> Persecution complex?
18:12:24 <mapreduce> Lispers are a lot less united in ideas.
18:12:27 <LordBrain> yeah i've seen ugly stuff in c and c++ groups
18:12:55 <LordBrain> less unity is possibly good for creativity
18:12:56 <mapreduce> (loop for i in stop using loop you idiot)
18:13:55 <vixey> loop is wonderful
18:13:57 <LordBrain> hmmmm
18:14:05 <geezusfreeek> mmorrow: try piping /dev/mouse into /dev/audio
18:14:45 <mjrosenb> geezusfreeek: does'nt work as well as i'd like
18:14:50 <mmorrow> ooh, NICE one. trying now
18:17:06 <mmorrow> omg that's freaking awesome. i'm in a coffee shop, so i didn't do to /dev/audio, but just sudo cat /dev/input/mouse1 is pretty entertaining
18:17:17 <mmorrow> i've never thought do dump the mouse input before
18:17:36 <mjrosenb> at the beginnign of running a bunch of commands, run script /dev/dsp
18:17:48 <mjrosenb> also running script log
18:17:51 <mjrosenb> then cat log
18:17:58 <mjrosenb> is a really bad idea
18:18:23 <geezusfreeek> lol
18:19:15 <geezusfreeek> wait… why?
18:19:20 <mmorrow> lol just did it, then cat /dev/urandom
18:19:44 <mmorrow> would prob be better with dumping a bunch of more structured output
18:19:58 <geezusfreeek> the script log followed by cat log wouldn't really do anything, would it?
18:20:27 <mmorrow> it just wires you're /dev/stdout to /dev/dsp
18:20:33 <SamB> mmorrow: it's great for testing if your mouse is producing input!
18:20:41 <mmorrow> hehe
18:20:48 <SamB> works also for joysticks
18:21:00 <mjrosenb> geezusfreeek: well if you run cat log before script exits....
18:21:04 <SamB> if you haven't got the more appropriate tool installed
18:21:11 <Zao> SamB: You cannot beat FreeBSD and the Razer Lachesis mouse, which got misidentified by the input drivers as a keyboard.
18:21:42 <SamB> Zao: what sort of connectivity does it have?
18:21:42 <geezusfreeek> it would output the contents of the log so far...
18:21:50 <Zao> USB.
18:22:09 <mjrosenb> so i think on one of my computers either linux or a chipset was able to tell that i had 2 ps2 keyboards plugged in
18:22:11 <SamB> how does it manage such a crazy feat?
18:22:24 <SamB> it's definately the mouse's fault...
18:22:54 <Zao> If I recall correctly, there were some intellimouse-related munging in the driver that miscategorized it or something.
18:23:07 <geezusfreeek> dangit, os x has broken /dev almost completely
18:23:37 <geezusfreeek> almost nothing there. no /dev/mouse, /dev/audio, equivalents, anything like that
18:24:34 <SamB> Zao: oh. so it was MS's fault ?
18:25:21 <Zao> SamB: Indirectly.
18:26:01 <SamB> hmm. how did the intellimouse code miscategorize a mouse as a keyboard?
18:27:38 <mjrosenb> geezusfreeek: /dev/input/{mouse*,mice}, /dev/dsp?
18:27:40 <Zao> SamB: http://freebsd.monkey.org/freebsd-usb/200805/msg00101.html
18:27:43 <lambdabot> Title: usb/123959: [usb][mouse] add support for Razer Lachesis 4000dpi usb mouse
18:27:55 <Zao> SamB: Seems to have been a hack around that some mice tended to stay in boot protocol state or something.
18:27:55 <geezusfreeek> mjrosenb: no /dev/input either
18:28:06 <geezusfreeek> or /dev/dsp
18:28:46 <SamB> geezusfreeek: what do you have?
18:28:50 <geezusfreeek> leopard
18:28:53 <SamB> anyway, none of those things are standard
18:28:56 <geezusfreeek> os x borked it
18:28:58 <SamB> no, I meant what nodes are in /dev?
18:29:07 <SamB> /dev/tty, I assume...
18:30:20 <geezusfreeek> tty*, pty*, rdisk*, disk*, *random, zero, std*, just stuff like that
18:30:31 <mjrosenb> null
18:30:34 <geezusfreeek> right
18:30:46 <geezusfreeek> also some dtrace stuff, which i imagine is pretty nice
18:30:50 <SamB> geezusfreeek: well, anything else really can't be expected to be there
18:31:00 <geezusfreeek> i am just used to linux, is all
18:31:06 <geezusfreeek> and that other stuff used to be there
18:31:09 <geezusfreeek> just got taken out in leopard
18:31:13 <SamB> oh?
18:31:17 <geezusfreeek> not that it all worked correctly in the first place
18:31:21 <geezusfreeek> but some of it did
18:31:31 <SamB> well, maybe they decided to take it out so others could put stuff that actually worked in?
18:31:43 <geezusfreeek> i don't know
18:31:54 <mjrosenb> is there any way of forcing ghc to perform a gc pass?
18:32:01 <geezusfreeek> i really wouldn't have used them for anything but little tricks and games anyway i guess
18:32:45 <geezusfreeek> mjrosenb: programmatically?
18:33:11 <SamB> mjrosenb: I'm fairly certain that there is something you can call that will request a gc...
18:33:13 <mjrosenb> err, there was supposed to be an i -- ghci
18:33:17 <SamB> @hoogle gc
18:33:17 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
18:33:17 <lambdabot> Data.Typeable.gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
18:33:17 <lambdabot> Data.Typeable.gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
18:33:22 <SamB> hmm, not there though
18:33:29 <SamB> @hoogle garbage
18:33:29 <lambdabot> No matches found
18:33:32 <mjrosenb> but if it works in ghc, it will work in ghci as wel
18:35:00 <rwbarton> @hoogle performGC
18:35:00 <lambdabot> System.Mem.performGC :: IO ()
18:38:20 <vixey> you know you have categories for functions and allegories for relations, is there an analogue for both changing the arrow to dependent product?
18:40:03 <dmwit> :t msum
18:40:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:40:18 <dmwit> ?hoogle Monoid m => [m] -> m
18:40:19 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
18:40:19 <lambdabot> Prelude.head :: [a] -> a
18:40:19 <lambdabot> Prelude.last :: [a] -> a
18:40:33 <vininim> @hoogle [m a] -> m a
18:40:34 <lambdabot> Prelude.head :: [a] -> a
18:40:34 <lambdabot> Prelude.last :: [a] -> a
18:40:34 <lambdabot> Data.List.head :: [a] -> a
18:40:48 <vininim> @hoogle (Monad m) => [m a] -> m a
18:40:49 <lambdabot> Prelude.head :: [a] -> a
18:40:49 <lambdabot> Prelude.last :: [a] -> a
18:40:49 <lambdabot> Data.List.head :: [a] -> a
18:42:10 <dmwit> :t \xs -> map mconcat ([0..] >>= flip replicateM xs)
18:42:12 <lambdabot> forall a. (Monoid a) => [a] -> [a]
18:42:38 <hpaste>  dmwit annotated "Can anyone "kleene" (<-- har har) this up?" with "one-liner" at http://hpaste.org/8569#a1
18:42:55 <byorgey> vininim: Hoogle 3 doesn't deal well with types like m a... but Hoogle 4 will! =)
18:43:22 <dmwit> Nonsense.
18:43:29 <dmwit> ?hoogle Monad m => [m a] -> m [a]
18:43:30 <lambdabot> Prelude.head :: [a] -> a
18:43:30 <lambdabot> Prelude.last :: [a] -> a
18:43:30 <lambdabot> Data.List.head :: [a] -> a
18:43:40 <dmwit> Well, I'll be damned.
18:43:42 * byorgey refrains from saying 'I told you so'
18:43:47 <vininim> lol
18:43:51 <dmwit> Why come it worked for Monoid, then?
18:44:12 <byorgey> dmwit: it probably ignored the monoid bit and just returned functions of type [a] -> a.
18:44:16 <byorgey> there aren't too many of them.
18:44:24 <dmwit> ?hoogle [m] -> m
18:44:25 <lambdabot> Prelude.head :: [a] -> a
18:44:25 <lambdabot> Prelude.last :: [a] -> a
18:44:25 <lambdabot> Data.List.head :: [a] -> a
18:44:33 <byorgey> huh
18:44:34 <dmwit> It seems to actually use the Monoid bit.
18:44:41 <byorgey> apparently it does.
18:44:42 <vininim> @hoogle repeatM
18:44:42 <lambdabot> No matches found
18:44:44 <dmwit> But then, the "m" isn't a type constructor, just a type.
18:44:48 <dmwit> Maybe that's the difference.
18:44:54 <dmwit> Anyway, to answer vininim's query:
18:44:56 <byorgey> oh, maybe it's just type constructors it doesn't deal with well.
18:44:56 <dmwit> :t sequence
18:44:57 <byorgey> yeah.
18:44:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:45:10 <byorgey> @type fmap mconcat . sequence
18:45:11 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m, Monoid a) => [m a] -> m a
18:45:24 <byorgey> Monad m, Functor m  <--- bleh
18:45:31 <vininim> thanks!
18:45:41 <dmwit> byorgey: Better than Monad f, Functor f. ;-)
18:45:44 <vininim> Prelude System.Mem Control.Monad> sequence $ repeat performGC
18:45:52 <vininim> =P
18:45:55 <dmwit> heh
18:46:05 <dmwit> forever performGC -- superior
18:46:05 <vixey> @hoogle Monoid
18:46:06 <lambdabot> Data.Monoid :: module
18:46:06 <lambdabot> Data.Monoid.Monoid :: class Monoid a
18:46:07 <byorgey> dmwit: heh. I'm just 'bleh'ing the fact that both Functor and Monad are necessary.  the latter should imply the former.
18:46:12 <dmwit> I know.
18:46:27 <byorgey> @type liftM mconcat . sequence -- ugly hack
18:46:28 <lambdabot> forall (m :: * -> *) a. (Monad m, Monoid a) => [m a] -> m a
18:47:01 <dmwit> ?seen povman
18:47:01 <lambdabot> I saw povman leaving #haskell 18h 53m 46s ago, and .
18:47:12 <dmwit> :t replicateM
18:47:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:47:22 <dmwit> Oh, whoops, that paste wasn't quite right.
18:47:34 <dmwit> If you manage to get your Int up to 2^31+1...
18:51:11 <vininim> wow, no keyboard interrupt from ghci. it's not a harmless thing to performGC
18:53:43 <pjdelport> is hackage.haskell.org down?
18:54:05 <mmorrow> yeah, apparently it's moving physical location
18:54:09 <mmorrow> s
18:54:22 <pjdelport> ah
18:56:44 <mar77a> what algorthm does List.sort use?
18:56:57 <dmwit> It's not specified by the Report.
18:57:09 <mar77a> which one does ghc implement?
18:57:11 <dmwit> But it's probably mergesort in most implementations.
18:57:28 <mjrosenb> mergesort on lists is pretty
18:57:39 <dmwit> yep
18:57:40 <vixey> it's insertion sort in lambdabot
18:57:46 <dmwit> ?source Data.List
18:57:46 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:58:12 <dmwit> That link doesn't seem to be working.
18:59:27 <pjdelport> that's the same machine as hackage.haskell.org
18:59:33 <pjdelport> monk.galois.com
18:59:33 <dmwit> ah
19:02:09 <mar77a> @src product
19:02:09 <lambdabot> product = foldl (*) 1
19:02:19 <mar77a> why foldl and not foldr?
19:02:29 <dmwit> To prevent stack overflows.
19:02:42 <mar77a> how does that work
19:02:46 <dmwit> product' = foldl' (*) 1 -- is even better
19:02:53 <dmwit> sum' = foldl' (+) 0 -- this, too
19:03:29 <dmwit> mar77a: In the case that (*) is strict, I guess?
19:03:52 <dmwit> I'll let the experts say for sure, though.
19:03:58 <mar77a> strict?
19:05:47 <byorgey> http://haskell.org/haskellwiki/Stack_overflow
19:05:47 <lambdabot> Title: Stack overflow - HaskellWiki
19:06:54 <rwbarton> How do I efficiently turn a Ptr Char8 and a size into a ByteString?
19:07:41 <vininim> @hoogle (a -> b) -> [m a] -> [m b]
19:07:42 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
19:07:42 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
19:07:42 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
19:08:46 <mar77a> ouch
19:08:55 <mar77a> need a bit of help understanding the error
19:08:56 <mar77a> catMaybes :: [Maybe a] -> [a]
19:08:56 <mar77a> catMaybes [] = []
19:08:57 <mar77a> catMaybes (x:xs) = (\(Just x) -> x) : catMaybes xs
19:09:40 <mar77a> oh
19:09:57 <mar77a> hehe forgot the argument to the lambda
19:09:58 <mar77a> nvm
19:10:29 <ddarius> mar77a: That's not the same function as catMaybes, and (\(Just x) -> x) is already in the standard library as fromJust.
19:10:39 <ddarius> In fact, your whole function is just map fromJust
19:11:08 <mjrosenb> ddarius: errr, i don't think so
19:11:20 <dmwit> I'm afraid he's right on this one.
19:11:31 <byorgey> @type fmap . fmap
19:11:31 <dmwit> That's gonna give a run-time error if there's a Nothing in the list.
19:11:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:11:33 <mjrosenb> i mean
19:11:36 <byorgey> vininim: ^^^
19:11:40 <mar77a> yeah
19:11:42 <mar77a> it does indeed
19:11:46 <mar77a> but how do i get around it
19:11:46 <mjrosenb> err
19:11:48 <mjrosenb> nevermind
19:11:52 <dmwit> mar77a: case
19:12:01 <dmwit> mar77a: Or, use list comprehensions.
19:12:05 <ddarius> mar77a: What do you want to happen in the "Nothing" case, i.e. on the list [Nothing]?
19:12:10 <dmwit> mar77a: In a comprehension, pattern matches call fail instead of error.
19:12:13 <mar77a> hmm
19:12:16 <vininim> byorgey: thanks
19:12:21 <mar77a> fail?
19:12:29 <dmwit> yeah =/
19:12:30 <dmwit> :t fail
19:12:30 <byorgey> fail is fail
19:12:31 <mjrosenb> .. right, catMaybes is different from map fromJust
19:12:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
19:13:24 <mar77a> argh
19:13:29 <mar77a> can i push nothing onto a list
19:13:39 <dmwit> ?
19:13:43 <vininim> actually, it's not quite what i want
19:14:00 <dmwit> byorgey: You used one too few fmaps for that to be awesome.
19:14:02 <mar77a> if x:[] == [], what is x
19:14:03 <dmwit> :t fmap fmap fmap
19:14:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:14:20 <vininim> I want (Functor f1, functor f) => (f a -> f b) -> f (f1 a) -> f (f1 b)
19:14:27 <dmwit> mar77a: There is no solution.
19:14:32 <mar77a> well that sucks
19:14:37 <dmwit> mar77a: x:[] /= []
19:14:43 <dmwit> mar77a: Why?
19:14:54 <dmwit> mar77a: You can just pass the list on if you don't want to prepend anything.
19:14:58 <byorgey> dmwit: oh! darnit, you're right
19:15:00 <mar77a> i have a function that has to push something onto a list
19:15:02 <vininim> sounds like some monadtransforming
19:15:13 <mar77a> but i want it not to push something under certain situations
19:15:23 <mar77a> or to push "void"
19:15:43 <mjrosenb> mar77a: (if foo then (x:) else id) list
19:15:56 <mar77a> let me show you the code
19:16:10 * mjrosenb thinks that's kinda nasty though
19:16:10 <hpaste>  mar77a pasted "ze codenburger" at http://hpaste.org/8571
19:16:43 <dmwit> mar77a: Wrong approach, sorry.
19:17:02 <mar77a> yeah, that way i can only blame it on myself
19:17:08 <mar77a> what's the right approach
19:17:18 <dmwit> catMaybes (Just x:xs) = ...
19:17:23 <dmwit> catMaybes (Nothing:xs) = ...
19:17:34 <dmwit> might need more parens on the first line there
19:17:35 <mar77a> hmm
19:18:01 <dmwit> There's a lot of solutions, really.
19:18:06 <mar77a> this one looks neat
19:18:17 <mar77a> i didn't know you could pattern match inside another pattern match
19:18:24 <dmwit> You can keep your current pattern match and do an additional case, or use mjrosenb's suggestion, or...
19:18:31 <mjrosenb> mar77a: yes, patterns are defined recursively
19:18:37 <dmwit> This one is also kind of sneaky:
19:18:37 <byorgey> @type \f -> traverse . fmap f . traverse
19:18:39 <lambdabot> Not in scope: `traverse'
19:18:39 <lambdabot> Not in scope: `traverse'
19:18:54 <mjrosenb> my solution is not endorsed by me
19:18:58 <byorgey> @type Data.Traversable.sequence
19:18:59 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
19:19:01 <rwbarton> vininim: There was some discussion about the type (f a -> f b) -> f (f1 a) -> f (f1 b) a few days ago
19:19:05 <mjrosenb> anyone else here think it's nasty?
19:19:13 <mar77a> is there anything \wrong\ with it, dmwit ?
19:19:14 <rwbarton> Yes, that was the result of the discussion :)
19:19:15 <dmwit> [x | predicate] ++ xs -- x:xs if predicate is true, xs otherwise
19:19:18 <byorgey> @type \f -> Data.Traversable.sequence . fmap f . Data.Traversable.sequence
19:19:19 <lambdabot> forall (m :: * -> *) a (t :: * -> *) (m1 :: * -> *) a1. (Monad m1, Data.Traversable.Traversable t, Monad m, Data.Traversable.Traversable m1) => (t a1 -> m a) -> t (m1 a1) -> m (m1 a)
19:19:22 <dmwit> mar77a: Wrong with what?
19:19:28 <byorgey> er, not quite =P
19:19:34 <mar77a> the way i (you) solved it
19:19:38 <byorgey> vininim: anyway, I don't think it's possible to do that with just Functors
19:20:16 <dmwit> mar77a: There's certainly nothing wrong with multiple pattern matches, if that's what you're asking.
19:20:29 * byorgey `ap` Maine
19:20:32 <byorgey> later folks
19:20:44 <dmwit> > let catMaybes xs = [x | Just x <- xs] in catMaybes [Maybe 3, Nothing] -- this is very pretty, though
19:20:49 <lambdabot>   Not in scope: data constructor `Maybe'
19:20:55 <mar77a> Just
19:20:55 <dmwit> quite
19:21:02 <mar77a> yeah i find it more elegant
19:21:12 <vininim> laster
19:21:40 <dolio> @type foldr (maybe id (:)) []
19:21:42 <lambdabot> forall a. [Maybe a] -> [a]
19:22:07 <mar77a> @src maybe
19:22:07 <lambdabot> maybe n _ Nothing  = n
19:22:07 <lambdabot> maybe _ f (Just x) = f x
19:22:12 <dmwit> :t maybe id
19:22:14 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
19:22:20 <vixey> :t map fromJust . filter isJust
19:22:22 <lambdabot> forall a. [Maybe a] -> [a]
19:22:38 <mar77a> @hoogle isJust
19:22:39 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
19:22:45 <mar77a> do'h
19:22:54 <dolio> Two passes? Tsk tsk. :)
19:23:19 <mar77a> so much useless coding
19:23:22 <mar77a> thanks to the prelude
19:23:24 <dmwit> :t concatMap maybeToList -- this is getting silly
19:23:27 <mar77a> and standard library
19:23:27 <lambdabot> forall a. [Maybe a] -> [a]
19:23:43 <vixey> filteringMap (fromJust`when`isJust)
19:24:09 <noecksit> @seen dcoutts
19:24:09 <lambdabot> dcoutts is in #gentoo-haskell, #xmonad, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 4h 44m 7s ago.
19:25:02 <pjdelport> :t (maybeToList =<<)
19:25:06 <lambdabot> forall a. [Maybe a] -> [a]
19:25:24 <mjrosenb> is there an easy way to muck with ghci's readline foo? I'd like the ^O functionality of bash
19:25:26 <rwbarton> @pl \xs -> [x | Just x <- xs]
19:25:26 <lambdabot> return . ((x | Just x) <-)
19:25:30 <rwbarton> Not likely!
19:25:49 <dolio> @. pl undo \xs -> [x | Just x <- xs]
19:25:49 <lambdabot> (line 1, column 37):
19:25:49 <lambdabot> unexpected "{"
19:25:49 <lambdabot> expecting variable, "(", operator or ")"
19:26:03 <dmwit> rwbarton: Heh, no.
19:26:35 <dmwit> ?. pl undo \xs -> do { Just x <- xs; return x }
19:26:35 <lambdabot> (line 1, column 33):
19:26:35 <lambdabot> unexpected "{"
19:26:35 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
19:27:12 <vixey> :t (^>>)
19:27:13 <lambdabot> forall b c (a :: * -> * -> *) d. (Arrow a) => (b -> c) -> a c d -> a b d
19:27:28 <dmwit> ?undo do { Just x <- xs; return x }
19:27:28 <lambdabot> xs >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
19:27:42 <dmwit> Mmm, yeah, ?pl can't do case.
19:27:45 <vixey> what :S
19:27:54 <vixey> @src (^>>)
19:27:54 <lambdabot> f ^>> a = arr f >>> a
19:28:08 <mar77a> @arr
19:28:08 <lambdabot> I want me grog!
19:28:13 <vixey> odd
19:28:15 <dmwit> ?pl \a -> case a of -- vixey
19:28:15 <lambdabot> flip case of
19:28:45 <vixey> what dmwit
19:28:50 <dmwit> i.e. ?pl parsed things okay (wrong, but okay) up to "case a of ", then died on the '{'.
19:30:06 <vininim> @pl \f -> Data.Traversable.sequence . fmap f . Data.Traversable.sequence
19:30:06 <lambdabot> (Data.Traversable.sequence .) . (. Data.Traversable.sequence) . fmap
19:30:43 <vixey> :t (?f .) . (. ?g)
19:30:45 <lambdabot> forall b a b1 (f :: * -> *). (?g::f a, Functor f, ?f::b1 -> b) => (a -> b1) -> f b
19:31:11 <mar77a> map' f xs = foldr ((:).f) [] xs
19:31:17 <mar77a> what is the best folding function in this case?
19:31:22 <Armored_Azrael> Hey, if n > k, can anyone see why this occasionally produces negative numbers?
19:31:24 <Armored_Azrael>                            return $ (numerator x) `div` (denominator x)) (foldr (*) 1 $ map (\(x, y) -> (fromIntegral x) / (fromIntegral y)) (zip [(k+1)..n] [1..(n - k)]))
19:31:27 <vininim> ((Data.Traversable.sequence .) . (. Data.Traversable.sequence) . fmap) (sort) (fmap return [10, 9, 8, 6])
19:31:30 <vininim> >((Data.Traversable.sequence .) . (. Data.Traversable.sequence) . fmap) (sort) (fmap return [10, 9, 8, 6])
19:31:30 <dmwit> mar77a: foldr is the right one
19:32:40 <TomMD> oh no!  Lambdabot is down due to the move?
19:32:45 <TomMD> ?bot
19:32:45 <lambdabot> :)
19:32:46 <vininim> > ((Data.Traversable.sequence .) . (. Data.Traversable.sequence) . fmap) (sort) ((fmap return [10, 9, 8, 6])::[Maybe Integer])
19:32:49 <lambdabot>  [Just 6,Just 8,Just 9,Just 10]
19:32:56 <dmwit> Armored_Azrael: That doesn't look valid to me.
19:33:08 <dmwit> Armored_Azrael: There are mismatched parens, for one thing.
19:33:10 <vininim> yay! \o\ /o/
19:33:11 <vixey> Armoured_Azrael: what's your actual code
19:33:12 <Armored_Azrael> dmwit: Oh, sorry, I'll put the front half on
19:33:31 <dmwit> vixey: Quit that, you freaking Brit.
19:33:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8572
19:33:52 <mjrosenb> Armored_Azrael: also, wouldn't you want to use zipWith?
19:33:59 <rwbarton> Armored_Azrael: Probably your Ints are overflowing.
19:34:13 <rwbarton> Armored_Azrael: Maybe use Integer?
19:34:17 <mjrosenb> Armored_Azrael: also, also hi
19:34:19 <Armored_Azrael> rwbarton: That's what I thought, but that's why there's a fromIntegral
19:34:34 <Armored_Azrael> mjrosenb: Yes, I recognize you, and you're correct, for style I should use zipWith
19:34:48 <rwbarton> I think fromIntegral is getting instantiated at Integer -> Ratio Int
19:34:51 <rwbarton> (but I could be way off)
19:35:25 <Armored_Azrael> rwbarton: Oh, so I should typesign it into Integral a => a -> Ratio Integer ?
19:35:26 <dmwit> Yes, it has to be.
19:35:39 <dmwit> Armored_Azrael: The culprit is your top-level type signature.
19:35:57 <dmwit> Armored_Azrael: Return IO Integer (or Integral a => IO a) and you'll be in better shape, maybe?
19:36:17 <Armored_Azrael> dmwit: At the end it should be int sized
19:36:29 <Armored_Azrael> I just need it to not overflow during the evaluation stage pre-division
19:36:43 <rwbarton> Armored_Azrael: Then you'll need a fromInteger between return and its argument
19:36:50 <Armored_Azrael> ok
19:37:32 <rwbarton> That will *probably* work on its own, but putting in some type signatures is definitely a good idea
19:39:52 <jdrake> Has anyone seen glguy lately?
19:42:32 <gwern> preflex: seen glguy
19:42:32 <preflex>  glguy was last seen on #haskell 9 hours, 34 minutes and 34 seconds ago, saying: haskell-platform-release-1.2.3?
19:45:25 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8572#a1
19:45:47 <Armored_Azrael> So, I added type signatures, and it still isn't working as expected
19:46:45 <mjrosenb> Armored_Azrael: have you tried out a properly typed helper function, and a 'cast' aroud the outside?
19:47:15 <Armored_Azrael> There is a cast--the fromInteger on the return
19:47:23 <rwbarton> Armored_Azrael: Can you give a particular n and k for which it fails?
19:47:28 <Armored_Azrael> sure, one sec
19:50:01 <Armored_Azrael> 67 35
19:50:41 <rwbarton> I'm pretty sure 67 choose 35 is much greater than 2^32...
19:50:59 <rwbarton> ...it should be close to 2^64 even
19:52:37 <rwbarton> > product [67-35+1..67] / product [1..35] > 2^64
19:52:38 <lambdabot>  False
19:52:41 <rwbarton> > product [67-35+1..67] / product [1..35] > 2^62
19:52:42 <lambdabot>  True
19:52:47 <Armored_Azrael> I see.
19:52:48 <rwbarton> > product [67-35+1..67] / product [1..35] > 2^63
19:52:49 <lambdabot>  True
19:52:56 <Armored_Azrael> Hm. Thanks then guys
19:53:14 <noecksit> hello, i recently read about cabal-install, and i wonder how it differs from other package management software like portage
19:53:41 <mjrosenb> noecksit: you may want hackport-darcs
19:54:02 <noecksit> mjrosenb : wasnt that for a mac?
19:54:02 <mjrosenb> noecksit: it can generate an ebuild for anything on hackage
19:54:04 <vininim> noecksit: it only deals with cabalized packages, while portage is more general and can deal with different build systems
19:54:10 <vixey> > product [67-35+1..67] / product [1..35]
19:54:12 <allbery_b> hackage / cabal-install, like ruby gems / perl modules / python eggs, are for the things the OS vendor either doesn't package or isn't up to date enough on
19:54:12 <lambdabot>  1.3413576695470565e19
19:54:28 <vixey> > product ([67-35+1..67] \\ [1..35])
19:54:29 <lambdabot>  3529525662153455013215570189186777498682088488960000000
19:54:46 <noecksit> i tried using the haskell overlay but it always seems broken and i can never compile something without errors
19:54:54 <noecksit> like ghc for instance
19:55:05 <mjrosenb> noecksit: you should report those on #gentoo-haskell
19:55:14 <mjrosenb> noecksit: which ghc version?
19:55:27 <mjrosenb> i've only had ghc issues on my alpha
19:55:53 <noecksit> yeah, im just saying in general, theres always smthing broken
19:55:56 <mjrosenb> and well, i can't imagine that alpha builds are horribly well maintained
19:56:13 <mjrosenb> noecksit: so i've only had issues with yi so far
19:56:22 <SamB> mjrosenb: you mean builds FOR alpha, or that thing that comes before beta?
19:56:31 <noecksit> ghc-6.8.2 actually, i tried to emerge happs and i couldnt compile it on any of my four comps
19:57:13 <mdmkolbe|work> I have a local functions I want to name "init" and "read", but they conflict with the Prelude function names.  Is there a way I can tell GHC to not import those from the prelude?
19:57:25 <mjrosenb> SamB: no, the alpha architecture
19:57:26 <noecksit> so cabal-install should prevent this hopefully?
19:57:52 <mjrosenb> noecksit: iirc, ghc-6.8.2 is is portage, and the version in the overlay shouldn't be used
19:58:10 <noecksit> one last question, does it install binaries or does it compile from source?
19:58:10 <SamB> mjrosenb: hmm, I seem to have gotten confused since you and mjrosenb share color, name, and capitalization pattern...
19:58:33 <SamB> mdmkolbe|work: "import Prelude ()"
19:59:04 <mjrosenb> SamB: your last statement confused me
19:59:06 <SamB> mdmkolbe|work: or otherwise import Prelude explicitly, but not all of it
19:59:09 <mjrosenb> to say the least
19:59:22 <SamB> mjrosenb: er, you and noecksit
19:59:25 <SamB> sorry
19:59:37 * mjrosenb tries to install happs
20:00:05 * vixey bet's happs wont built
20:00:24 <SamB> well, seeing as built is the past perfect
20:00:35 <SamB> and won't is the future tense
20:00:41 <rwbarton> I think you made a typo in every non-proper noun in that sentence
20:00:51 <mdmkolbe|work> SamB, I can probably make that work, but since I use a number of parts from the Prelude (e.g. "." and "$" and "map", etc.) is there some way to say "import Prelude except (read, init)"?
20:01:18 <vixey> s/except/hiding/
20:01:20 <SamB> mdmkolbe|work: the keyword is "hiding"
20:01:26 <SamB> so yes
20:01:49 <SamB> the critical point is that the implict "import Prelude" goes away when you explicitly import Prelude somehow
20:02:37 <mdmkolbe|work> SamB, awsome!  Yeah I didn't expect that last point but it makes sense.
20:02:52 <shapr> Is hackage down?
20:02:57 <mjrosenb> shapr: yes
20:03:00 <shapr> foo
20:03:08 <mjrosenb> this should be put into the topic
20:05:17 <shapr> I want a copy of HCodecs :-/
20:05:22 <SamB> can I send email to a jabber address?
20:05:33 <shapr> SamB: If it's a gtalk address...
20:06:28 * SamB is trying to email mattam 
20:06:44 <shapr> He's moving to Boston, isn't he?
20:06:57 <SamB> is he?
20:06:57 <hpaste>  morrow pasted "BoolExp" at http://hpaste.org/8573
20:07:10 <SamB> that will be nice
20:07:39 <SamB> IRCing with people in western europe is so annoying
20:08:14 <SamB> well, I mean, the ones who keep sensible hours
20:08:27 <SamB> well, probably all of europe ;-)
20:09:19 <vixey> ahahaha
20:09:22 <vixey> [true,false] = fmap Lit [True,False]
20:09:32 <mmorrow> just discovered that yesterday
20:09:33 <vixey> mmorrow awesome
20:09:37 <mmorrow> so convenient
20:09:44 <mmorrow> :)
20:09:54 <mjrosenb> noecksit: hey, when did you try to install happs?
20:09:55 <vixey> so ridiculous :P
20:10:08 <mmorrow> haha
20:10:30 <vixey> mmorrow,  what's this paste about?
20:11:23 <mmorrow> i found that module in an old directory and was messing with it. i'm pretty sure there are extraneous cases in both eval *and* simplify
20:11:34 <ddarius> (true,false) = (Lit True, Lit False) ...
20:11:39 <vixey> oh I see
20:11:45 <mmorrow> and a GADT would get rid of unsafeCoerce
20:11:48 <vixey> do you remember why you use unsafeCoerce ?
20:11:59 <mmorrow> but i could have just used Lit True or Lit False...;)
20:12:09 <vixey> was just thinking that ddarius
20:12:12 <SamB> weren't they trying to take that syntax out of h'?
20:12:20 <SamB> or something along those lines?
20:12:24 <mmorrow> just cuz i wanted to keep the [true,false] at the top level
20:12:27 <mmorrow> haha
20:12:41 <mmorrow> ddarius: ahh. clever.
20:13:54 <mmorrow> hmm, i don't know though if that'd change anything actually
20:14:11 <rwbarton> unsafeCoerce is just to get around the monomorphism restriction?
20:16:04 <hpaste>  morrow annotated "BoolExp" with "without unsafeCoerce" at http://hpaste.org/8573#a1
20:16:20 <rwbarton> wait, what I said makes no sense
20:17:11 <mmorrow> rwbarton: true and false being Exp (forall a.a) and unsafeCoercing them in the simplify function's need because it's (Exp a -> Exp a)
20:17:22 <mmorrow> s/need/needed/
20:17:23 <lambdabot> !paste
20:17:23 <hpaste> Haskell paste bin: http://hpaste.org/
20:17:55 <vixey> what the hell was going through your head when you wrote this :p
20:18:10 <lambdabot> vixey: be nice!
20:18:31 <ivanm> noecksit: I hear you're having problems with the happs ebuild in the gentoo-haskell overlay?
20:18:33 <mmorrow> haha, i can't remember *when* i wrote it
20:18:49 <vixey> no I like it, it's just.. mad
20:19:15 <mmorrow> i'm just loco
20:21:53 <mmorrow> as an actual answer, i was experimenting with simplifying and then functionizing ASTs :)
20:22:45 <mdmkolbe|work> @pl foreach xs = msum $ map return xs
20:22:45 <lambdabot> foreach = msum . map return
20:23:07 <ddarius> Did you need @pl to tell yo uthat?
20:24:05 <mdmkolbe|work> ddarius: no, but I thought maybe @pl might find an existing function that does that.
20:24:29 <mdmkolbe|work> Right now I'm writing that as my own little helper but if there is already such a beast I would use it.
20:24:41 <ddarius> @. hoogle type msum . map return
20:24:43 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *). ('
20:24:47 <ddarius> Curses!
20:24:52 <mmorrow> Drats!
20:25:05 <mdmkolbe|work> @curses
20:25:05 <lambdabot> Unknown command, try @list
20:25:11 <dmwit> :t msum . map return
20:25:13 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
20:25:15 <ddarius> @tell ndm Perhaps have Hoogle parse the type signatures GHC outputs (if you haven't already done that)
20:25:15 <lambdabot> Consider it noted.
20:25:36 <mjrosenb> @hoogle (a -> (b,c)) -> a -> (b,c)
20:25:37 <lambdabot> No matches, try a more general search
20:25:45 <mjrosenb> @hoogle a -> (a -> (b,c)) -> (b,c)
20:25:46 <lambdabot> No matches, try a more general search
20:25:54 <mdmkolbe|work> @hoogle [a] -> m a
20:25:54 <mjrosenb> no
20:25:54 <lambdabot> Prelude.head :: [a] -> a
20:25:54 <lambdabot> Prelude.last :: [a] -> a
20:25:54 <lambdabot> Data.List.head :: [a] -> a
20:25:56 <mjrosenb> rather
20:26:01 <vixey> id
20:26:01 <dmwit> :t mapM
20:26:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:26:11 <vixey> flip id
20:26:12 <mjrosenb> @hoogle a -> (a -> b, a -> c)) -> (b,c)
20:26:12 <lambdabot> hoogle: src/Hoogle/Parser.hs:124:17-29: Irrefutable pattern failed for pattern (a, [])
20:26:12 <lambdabot>  
20:26:19 <mjrosenb> @hoogle a -> (a -> b, a -> c) -> (b,c)
20:26:19 <lambdabot> No matches, try a more general search
20:26:34 <dmwit> mdmkolbe|work: I think that's the best definition for that exact behavior.
20:26:48 <vixey> :t (+++)
20:26:48 <vixey> :t (|||)
20:26:48 <vixey> :t (***)
20:26:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
20:26:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:26:53 <mdmkolbe|work> dmwit: you mean the original version I had?
20:26:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
20:26:54 <dmwit> mdmkolbe|work: There are similar functions with slightly different behaviors, like sequence, mapM id, etc.
20:27:04 <dmwit> mdmkolbe|work: Yes, I mean your original foreach = msum . map return
20:27:29 <rwbarton> @hoogle MonadSum m => a
20:27:29 <lambdabot> Prelude.undefined :: a
20:27:29 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
20:27:29 <lambdabot> Control.Monad.Reader.Class.ask :: MonadReader r m => m r
20:27:31 <dmwit> (Actually, now that I say it out loud, mapM id is probably === sequence.)
20:27:39 <rwbarton> @hoogle MonadPlus m => a
20:27:39 <lambdabot> Prelude.undefined :: a
20:27:39 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
20:27:39 <lambdabot> Control.Monad.Reader.Class.ask :: MonadReader r m => m r
20:27:45 <ddarius> dmwit: It is.
20:27:49 <ddarius> @src mapM
20:27:49 <lambdabot> mapM f as = sequence (map f as)
20:27:53 <mdmkolbe|work> dmwit: yeah, I need it to simulate for loops, e.g. "do x <- foreach [0..10]; y <- foreach [0..x], etc" so compatness is at a premium
20:28:22 <ddarius> mdmkolbe|work: ... do x <- [0..10]; y <- [0..x]; ...
20:28:27 <mjrosenb> gah, why does hoogle do searches for 'similar types' rather than 'isomorphic types'
20:28:43 <ddarius> mjrosenb: Wait for Hoogle 4
20:28:57 <mdmkolbe|work> ddarius, I'm using a compound monad of which ListT is only a part
20:29:07 * mjrosenb waits
20:29:59 <mdmkolbe|work> thus x <- [0..10] doesn't work
20:30:22 <mjrosenb> ooh, i see what the firefox plugin for hoogle does
20:30:28 * mjrosenb makes one for conkeror
20:30:43 <dmwit> You need a plugin?
20:30:49 <dmwit> I just have a keyword-ed bookmark.
20:31:14 <dmwit> Stick "h a -> [a]" in the location bar and get back sweet sugary repeat.
20:32:00 <vixey> does constant folding & eta reduction count as partial evaluation
20:32:07 <mjrosenb> dmwit: that's about the closest thing to a plugin that i use
20:32:09 <vixey> what else is there?
20:32:18 <vixey> your paste got me wondering mmorrow
20:32:34 <mmorrow> oooh, about what?
20:32:35 * mjrosenb read that as e.t.a. reduction and was confused
20:33:18 * mmorrow finds the link that made him remember about that module 
20:33:25 <vixey> oh and unfolding definitions like eas in supercompilation
20:34:07 <mjrosenb> yay supercompilation
20:35:13 <edwardk> @pl \da -> apply (apply (fmap k m) da) da
20:35:13 <lambdabot> apply =<< apply (fmap k m)
20:35:56 <mmorrow> hmm, i can't seem to find what i'm looking for, it was more me remembering something i (apparently just thought) i'd seen that made me think of BoolExp
20:36:30 <mmorrow> vixey: totally! that paste also has me thinking in the same way...
20:37:26 <mmorrow> found it!
20:37:30 <mmorrow> http://www.cs.york.ac.uk/fp/darcs/hhi/source/Eval/Eval.hs
20:37:38 <mxc-wrk> hello everyone
20:37:47 <mxc-wrk> anyone have experience with hdbc-odbc and mysql?
20:40:34 <shapr> @seen wadler
20:40:35 <lambdabot> I haven't seen wadler.
20:44:30 <jdrake> Can I have an infinite list defined at the top level with let and not have it infinitely figure itself out?
20:44:56 <vixey> jdrake yes
20:45:24 <jdrake> Now, if I were to not use let, would it infinitely evaluate?
20:45:25 <mjrosenb> jdrake: this is usually the default
20:45:29 <mjrosenb> jdrake: no
20:45:39 <jdrake> I have had it do it before
20:45:39 <dmwit> let is not legal at the top level
20:45:49 <jdrake> I mean in a module dmwit
20:45:54 <jdrake> Like a source file
20:45:54 <dmwit> So do I.
20:46:00 <jdrake> I thought it was
20:46:11 <dmwit> It would be completely redundant, even if it was.
20:47:31 * mjrosenb assumed that by top level he meant in the ghci environment
20:48:08 <dons> jdrake: x = [1..] -- done.
20:48:09 <dmwit> What would the not-top-level be, then? =)
20:48:20 <jdrake> mjrosenb: My apologies, I should have been more specific.
20:50:32 <shapr> Could I mix quickcheck and hpc directly? That is, can hpc's coverage information be returned from a single call?
20:53:54 <jdrake> What exactly was the meanings of . and $?
20:55:19 <pjdelport> jdrake: . is function composition, and $ function application
20:55:50 <jdrake> So . combines functions? I am not entirely sure about theuse of $
20:55:55 <ddarius> @src (.)
20:55:55 <lambdabot> (f . g) x = f (g x)
20:55:55 <lambdabot> -- In lambdabot, it's been generalised to:
20:55:55 <lambdabot> (.) = fmap
20:55:58 <ddarius> @src ($)
20:55:58 <lambdabot> f $ x = f x
20:56:14 <Zao> $ reduces the number of parens you need, generally.
20:56:34 <Zao> foo (bar (baz qux))) becomes foo $ bar $ baz qux
20:56:39 <jdrake> @src (/=)
20:56:39 <lambdabot> x /= y = not (x == y)
20:56:41 <Zao> or (foo.bar.baz) qux
20:56:57 <pjdelport> or foo . bar . baz $ quux
20:57:11 <jdrake> hmm
20:57:34 <Korollary> @info $
20:57:35 <lambdabot> ($)
20:57:39 <Korollary> excellent
20:57:45 <pjdelport> jdrake: . is just one of many ways to combine functions
20:57:53 <dmwit> ?undo $
20:57:53 <lambdabot> ($)
20:57:56 <dmwit> Korollary: ^^
20:57:59 <Korollary> well, it's low precedence and right-assoc, which is the real trick.
20:58:01 <shapr> Ahem, as I was saying...
20:58:20 <dmwit> No, no, no, ($) isn't right-assoc, it's wrong-assoc.
20:58:38 <pjdelport> @remember dmwit No, no, no, ($) isn't right-assoc, it's wrong-assoc.
20:58:38 <lambdabot> Nice!
21:01:26 <chylli> hPutStrLn hdl ( "welcome " ++ name ++ "!" ) I got  !elcome hello
21:01:30 <chylli> why ?
21:01:52 <dmwit> Does name contain \r?
21:02:46 <chylli> I got name by name <- hGetLine handle
21:03:11 <chylli> so it may include \r ?
21:03:18 <dmwit> I don't know.
21:03:21 <chylli>   hPutStrLn hdl $ "what's your name?"
21:03:21 <chylli>   name <- hGetLine hdl
21:03:21 <chylli>   hPutStrLn hdl ( "welcome " ++ name ++ "!" )
21:03:31 <pjdelport> chylli: that's what you'll see if it includes \r, so it probably does
21:03:36 <dmwit> Why don't you look at the file you wrote in a real editor and see what's really in there?
21:03:55 <chylli> dmwit: it is a socket, not file
21:04:26 <pjdelport> chylli: telnet?
21:04:29 <chylli> yes
21:04:35 <dmwit> So set hdl to an open file and run it again?
21:04:43 <pjdelport> telnet sends \r\n, IINM
21:04:51 <pjdelport> which would explain it
21:05:22 <chylli> pjdelport: ok, thanks
21:10:07 <vixey> hey mmorrow?
21:11:26 <vixey> oh actually ignore me
21:11:41 <shapr> no!
21:11:59 <shapr> @users
21:11:59 <lambdabot> Maximum users seen in #haskell: 469, currently: 416 (88.7%), active: 13 (3.1%)
21:12:24 <vixey> is this a good way to do it?
21:12:24 <vixey> repeatProgress f x = let fx = f x in if x == fx then x else repeatProgress f fx
21:12:54 <vixey> it's supposed to apply f until you reach an idempotent value
21:13:39 <pjdelport> what about cycles?
21:13:52 <mauke> :t fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate ?f
21:13:53 <lambdabot> forall a. (?f::a -> a, Eq a) => a -> a
21:14:02 <vixey> loops can loop which is fine
21:14:19 <solrize> hackage is down?  :(
21:16:18 <dmwit> solrize: Word on the street is its moving.
21:16:56 <mauke> all over the internets
21:17:13 <mauke> just try random ip addresses
21:17:16 <ivanm> for those emacs users here, how do you manage your darcs repos?
21:18:41 <sm> darcsum.el
21:24:15 <ivanm> sm: from here? http://chneukirchen.org/repos/darcsum/darcsum.el
21:24:31 <sm> yes that's it
21:30:03 <mmorrow> hey vixey
21:30:37 <mmorrow> oh...ignore
21:31:26 <vixey> sorry I just got confused for a sec :p
21:31:55 <mmorrow> :)
21:32:54 <dmwit> hey dmwit
21:32:57 <dmwit> err... nm
21:33:44 <mmorrow> you really got yourself there!
21:34:56 <ivanm> sm: how do you add files to the repo using it? I tried using darcsum-whatsnew, but it didn't do anything :s
21:35:38 <sm> not everything works .. I use command line for some things
21:36:02 <sm> $ darcs add, then g to refresh and I think you need to mark (m) the file before commiting
21:37:01 <psyklops> :t socketToHandle
21:37:03 <lambdabot> Not in scope: `socketToHandle'
21:37:08 <psyklops> yeah I know right?
21:37:29 <psyklops> I'm trying to write a simple "server" that just listens on a port and spits out whatever is sent at it
21:37:43 <dmwit> ?hoogle Socket -> Handle
21:37:44 <lambdabot> No matches, try a more general search
21:37:44 <psyklops> but when you do listenOn, it gives you a socket
21:37:44 <^Someone^> Echo!
21:39:11 <mauke> :t listenOn
21:39:13 <lambdabot> Not in scope: `listenOn'
21:39:26 <psyklops> it's in Network
21:39:27 <mmorrow> psyklops: i have a echoserver oneliner someone pasted a while back, i'll try to find it
21:40:45 <ivanm> sm: hmmm.... might end up being easier to stick with the command line after all
21:40:57 <ivanm> and I'm finding ecb more annoying than useful as well :p
21:41:22 <sm> I find it easier than the command line for browsing/recording a lot of changes
21:42:00 <sm> a pity it's not more polished
21:42:04 <ivanm> *nod*
21:42:52 <psyklops> ah.. I figured it out I think
21:42:58 <psyklops> the accept function is what I need
21:43:12 <psyklops> Socket -> IO (Handle, HostName, PortNumber)
21:43:41 <mauke> @hoogle accept
21:43:42 <lambdabot> No matches found
21:43:42 <psyklops> just need to know when to accept... hmm
21:44:03 <psyklops> hoogle doesn't cover libraries..
21:44:10 <mauke> <3 accept :: Socket -> IO (Socket, SockAddr)
21:44:14 <psyklops> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html#v%3Aaccept
21:44:15 <lambdabot> http://tinyurl.com/yz42xr
21:44:30 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html#v%3Aaccept
21:44:31 <lambdabot> http://tinyurl.com/fkdb4
21:44:50 <mauke> I have a simple server here
21:45:13 <psyklops> I'm trying to challenge myself by actually coming up with the code myself
21:45:17 <mauke> it uses listenOn with a socket file
21:45:26 <mauke> then there's an accept loop
21:45:35 <mauke> it spawns a thread for each accepted socket
21:45:51 <mauke> the threads use recv and send
21:45:53 <psyklops> I don't know how to do that though
21:45:54 <vixey> mmorrow: ok I had a shot at this
21:48:33 <psyklops> I can't wrap my head around how I would manage multiple connections at once, so this is beyond me
21:48:43 <psyklops> I went over the IRC bot tutorial
21:49:02 <mauke> I do it with threads
21:49:05 <psyklops> that was simple, just connect to the server and you can put stuff out to it or recieve, no big deal
21:49:26 <psyklops> How do you do threads?
21:49:31 <mauke> forkIO
21:49:38 <mmorrow> psyklops: http://hpaste.org/4860
21:49:39 <psyklops> uh oh
21:49:42 <mmorrow> vixey: do tell
21:50:07 <vixey> I'm pasting but it's going really slow :(
21:50:08 <mmorrow> psyklops: it wasn't the one i was thinking of but it's one
21:50:12 <mmorrow> vixey: cool
21:50:48 <mauke> what is this handle print thing?
21:51:04 <psyklops> hPrint?
21:51:04 <mmorrow> mauke: i dunno, not my code
21:51:27 <psyklops> where at?
21:51:33 <mmorrow> doesn't that just print the exception in the case of one?
21:51:35 <psyklops> oh, handle print... I see
21:51:39 <mauke> ah
21:52:01 <mmorrow> that anonymous, always the trickster!
21:52:09 <glguy> @seen dons
21:52:09 <lambdabot> dons is in #xmonad, #arch-haskell and #haskell. I last heard dons speak 1h 4m 1s ago.
21:52:12 <hpaste>  vicky annotated "BoolExp" with "partial eval" at http://hpaste.org/8573#a2
21:52:18 <psyklops> :t handle
21:52:19 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
21:53:21 <vixey> I used HOAS! lol for the first time I got to try it out
21:53:37 <mmorrow> vixey: ooh, exciting. i'll have to look at it for a bit
21:55:08 <ddarius> vixey: What was the point of that exercise?
21:57:46 <vixey> ddarius: I just wanted to try out HOAS (which I read about today) and I'm bored waiting for linux to download..
21:58:50 <mmorrow> vixey: oh, cool. in the original BoolExp i had things like simplify (And e f) = simplify (And (simplify e) (simplify f)) and it worked for some things, but when i was messing with it before i pasted i found that some things were causing it to infinite loop. from what i've grokked so far, your simplify---simplestep combo sidesteps that
21:59:26 <mmorrow> "in a sense" or something (i could be completely off point though, still grokking)
21:59:58 <vixey> no I specifically do simplification in that (3 stages) to guarantee it terminates
22:00:55 <mmorrow> hmm, just realized that simplStep never calls simplify...
22:01:02 <Heffalump> mmorrow: how would it work for anything in that form? Wouldn't it loop on any And?
22:01:11 <ddarius> vixey: Write a fold for your type.
22:01:19 <vixey> you just have to have a couple of really simple invarients
22:01:33 <vixey> and you can put this kind of thing in a theorem prover with Acc
22:01:38 <mmorrow> Heffalump: oh i just realized why it was working. i'll paste the original version of the code....
22:02:41 <vixey> ddarius: the reason I didn't use a fold was because I would lose the documentation "(x :$: y) = " instead it's just a big list of functions
22:02:49 <vixey> ddarius: I'm not sure of a good approach
22:04:33 <vixey> actually the type of the fold would be terrific..
22:06:16 <hpaste>  vicky annotated "BoolExp" with "another simpler" at http://hpaste.org/8573#a3
22:09:39 <hpaste>  morrow annotated "BoolExp" with "original version" at http://hpaste.org/8573#a4
22:10:37 <hpaste>  morrow annotated "BoolExp" with "but (with the original version) this loops" at http://hpaste.org/8573#a5
22:11:35 <mmorrow> Heffalump: so, it actually would work with some cases in the new version, but things like (simplify (id `xor` not)) cause it to loop
22:15:20 <mmorrow> Heffalump: so the answer to your original question would be...because there are multiple (And _ _) cases, and some of them return a result rather than recurse
22:16:49 <leoncamel> > print "%d" 10
22:16:50 <lambdabot>  Couldn't match expected type `t1 -> t'
22:16:57 <leoncamel> > printf "%d" 10
22:16:59 <lambdabot>  Add a type signature
22:19:36 <vixey> by the way, any idea why my eval is so slow?
22:20:06 <vixey> It's much faster than a lazy interpreter I wrote was that used rewriting on terms but It's much slower than say a scheme interpreter in scheme would be
22:20:12 <vixey> naive scheme*
22:20:37 <mmorrow> still grokking
22:24:10 <vixey> (I think I figured out why.. checking now)
22:25:41 <vixey> :t fix
22:25:43 <lambdabot> forall a. (a -> a) -> a
22:26:22 <vixey> @index fix
22:26:23 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
22:27:25 <vixey> @src fix
22:27:25 <lambdabot> fix f = let x = f x in x
22:38:03 <vixey> yay
22:38:11 <vixey> I got it efficient
22:39:04 <vixey> just add Fix :: Term (x -> x) -> Term x, eval (Fix f) = fix (eval f) and define recursive functions in terms of fixed points
22:40:42 <dons> glguy: ?
22:44:45 <vixey> hey you know in haskell when you write something like
22:44:45 <vixey> map f (x:xs) = f x : map f xs
22:45:07 <vixey> does the compiler load it up like map = fix ...
22:45:12 <vixey> ?
22:45:27 <vixey> well the whole module is a bunch of mutually recursive functions
22:45:42 <vixey> how is it that you get sharing when you didn't use fix?
22:51:39 <mmorrow> vixey: cool module. i've been messing with turning eval into eval' :: Term t -> (t -> t) -> t but running into a feww trouble spots, anyhow i gotta do some other work but plan on playing with your code soon
22:51:47 <mmorrow> :)
22:51:56 <leoncamel> I can't find paraellel package in my Ubuntu box. How can I install it ? or is there any ubuntu package source ?
22:52:18 <vixey> mmorrow: ty for the inspiration
22:53:05 <mmorrow> vixey: no prob, lemme know if you mess with it further
22:54:18 <ooxwo> Hey does anyone know why I would get a "parse error on input 'import'" on this:
22:54:26 <ooxwo> foreign import ccall "GetCurrentProcess" getCurrentProcess :: Ptr ProcessSerialNumber -> IO Int16
22:54:26 <ooxwo>  
22:55:08 <mmorrow> heh, just saw your comment about Fix. the couple type errors i was trying to resolve with eval' were "cannot ... x = x -> x", so...
22:55:15 <vixey> @hoogle (a -> b) -> ((b -> a) -> a) -> a
22:55:16 <lambdabot> No matches, try a more general search
22:55:18 <rwbarton> You need {-# LANGUAGE ForeignFunctionInterface #-}
22:56:00 <ooxwo> rwbarton:  Is that haskell code?  Do I put that with the module declaration?
22:56:13 <mmorrow> rwbarton: i wrote a little quasiquote module skeleton generator, if you haven't seen it: http://hpaste.org/8568
22:56:21 <rwbarton> That's a comment/pragma, it goes at the top of your haskell source.
22:57:32 <ooxwo> rwbarton:  Ah, thanks trying that now.
22:57:53 <rwbarton> Or you can compile with -XForeignFunctionInterface instead
22:58:11 <rwbarton> mmorrow: Yes, I saw it.  Plan to write a bunch of them do you :
22:58:12 <rwbarton> :)
22:58:53 <rwbarton> So [$foo|...|] calls fooQQ?  That's slightly magical
22:59:11 <mmorrow> haha. i already have a directory filled with _.hs that are all just the ouput of qqmod.
22:59:36 <ahunter> Hey, anyone around who might be able to answer some questions about the GHC RTS--in particular, the GC's large block handling?
23:00:43 <mmorrow> i know next to nothing about the gc, but have you checked out the GHC commentary?
23:01:08 <mmorrow> if so, the ghc src is probably gonna be your best bet
23:01:08 <ahunter> Yeah, somewhat painstakingly.
23:01:13 <mmorrow> heh
23:02:34 <mmorrow> crap, darcs.haskell.org is still down, so if you don't have a local copy of the src you'll prob have to dl a tarball from haskell.org/ghc...
23:02:39 <ahunter> I'
23:02:48 <ahunter> I'm a bit ahead of you; I've been source diving for a while
23:02:54 <mmorrow> nice!
23:03:01 <ahunter> just hitting a wall on one point, and figured it might be worth asking around
23:03:19 <ooxwo> rwbarton:  Thanks that did the trick!  Now I know about comment/pragmas...
23:03:27 <mmorrow> ahunter: what are your thoughts so far/what's the wall?
23:03:53 <vixey> There's a puzzle, does there exist a non trivial function in haskell with type (a -> b) -> ((b -> a) -> a) -> a
23:04:05 <mmorrow> rwbarton: "So [$foo|...|] calls fooQQ?  That's slightly magical" umm, i dont think so....
23:04:36 <ahunter> mmorrow: my thoughts involve a certain amount of rage; it's a big, big system and hard to just dive into
23:05:01 <mmorrow> rwbarton: but that does make me realize i should change how qqmod name the QuasiQuoter to allow stdin to completely determine it...
23:05:20 <mmorrow> ahunter: hahah. totally
23:05:34 <ahunter> mmorrow:I'm starting to get used to it, though, which helps.  I'm currently trying to figure out exactly where large allocations happen.  It seems they do it in scheduleHandleHeapOverflow in rts/Schedule.c, but they never (seem) to set BF_LARGE, which scares me a bit
23:06:14 <rwbarton> mmorrow: Oh, I was guessing that was how it worked from the output of your script
23:06:22 <visof> where Char.toUpper?
23:06:33 <mxc-wrk> @hoogle replace
23:06:33 <lambdabot> Data.Array.Diff.replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
23:06:33 <lambdabot> System.FilePath.Windows.replaceExtension :: FilePath -> String -> FilePath
23:06:33 <lambdabot> System.FilePath.Windows.replaceFileName :: FilePath -> String -> FilePath
23:06:37 <mxc-wrk> @hoogle substitute
23:06:38 <lambdabot> No matches found
23:06:40 <mxc-wrk> @hoogle find
23:06:40 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
23:06:40 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:06:40 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
23:06:55 <mmorrow> rwbarton: ah
23:07:39 <chylli> my chat server : http://hpaste.org/8574
23:07:51 <mmorrow> ahunter: hmm, looking at rts/Schedule.c now (not that i'm gonna be able to answer any questions or am even able to try wrt the gc)
23:08:04 <chylli> when I using installHandler sigPIPE Ignore Nothing; to ignore sigpipe,
23:08:05 <chylli>  
23:08:13 <chylli> the server print nothing to client
23:08:20 <chylli> why ?
23:09:04 <mmorrow> ahunter: where is BF_LARGE defined??
23:09:20 <mmorrow> (obviously not in Schedule.c)
23:09:25 <ahunter> mmorrow: include/Block.h
23:09:36 <mmorrow> cool
23:11:08 <mmorrow> ahunter: how do you mean they never set it? (what version of ghc are you looking at?)
23:11:16 <mmorrow> #define BF_LARGE     2
23:11:36 <mmorrow> i'm looking at ghc-HEAD as of maybe a week ago
23:12:02 <ahunter> erm, I mean that they when they allocate a large block they never set the flag on the appropriate bdescr
23:12:09 <mmorrow> ah.
23:12:37 <ahunter> at least, they only set BF_LARGE in the allocate() family which (I think) is not how we get memory for a large alloc
23:13:01 <chylli> @hoogle installHandler
23:13:01 <lambdabot> GHC.ConsoleHandler.installHandler :: Handler -> IO Handler
23:13:57 <chylli> any one give some advice ?
23:15:22 <mmorrow> hmm, perhaps a BF_LARGE is reserved for gc-monitored allocations and the other places where it appears it should be set are handled by some equivalent mark?
23:15:43 <mmorrow> just an off the cuff random guess...:)
23:16:26 <mmorrow> "some equivalent mark" for non-gc-monitored allocs
23:16:39 <ahunter> mmorrow: that's not, as best as I can tell, how the GC works; the documentation all (I think) claims that any object larger than a threshhold will be marked thus and treated differently) and the evac/scav code *seems* to back me up...
23:16:44 <mmorrow> but i'm presupposing here alo
23:16:46 <mmorrow> heh
23:17:01 <psyklops> So that echo server I was shown a while ago, I want every line sent to be echoed to all handles
23:17:10 <psyklops> I can't come up with a solution
23:17:41 <mmorrow> ahunter: i'm not doubting that you're correct, i'm trying to say that i'm most likely wrong :)
23:17:45 <ahunter> heh
23:17:49 <mmorrow> hehe
23:20:56 <mmorrow> #define LARGE_OBJECT_THRESHOLD ((nat)(BLOCK_SIZE * 8 / 10))
23:26:10 <mmorrow> ooh, Adjustor*.* look interesting
23:26:31 <telemach> morning
23:26:41 <mmorrow> heh, love comments that begin "Now here's something obscure for you:..."
23:28:05 <OceanSpray> is (f . g a) equivalent to ((f . g) a) ?
23:28:25 <vixey> no
23:28:35 <rwbarton> No, function application has higher precendence than any other operation
23:28:51 <chylli> rwbarton: can you help me ?
23:29:17 <lament> my best comment was about a function (in objective C) that converted an array of objects (each containing an array of children) into a single string: "...effectively performing a monadic join"
23:29:20 <OceanSpray> ok, then I must be thinking wrong.
23:29:37 <rwbarton> chylli: this is some problem involving sigpipe?
23:29:37 <mmorrow> comment at top of dyn-wrapper.c: "Have mercy with this creature born in cross-platform wasteland."
23:29:45 <chylli> rwbarton: yes
23:29:53 <chylli> when i remove that line
23:29:53 <lament> that will get code reviewed by Microsoft, hope they gouge their eyes out
23:29:58 <chylli> every thing is ok
23:30:02 <vixey> > (+1) . (*2) 6
23:30:03 <lambdabot>   add an instance declaration for (Num (f a))
23:30:07 <vixey> > ((+1) . (*2)) 6
23:30:08 <lambdabot>  13
23:31:25 <rwbarton> where is installHandler from?
23:31:36 <telemach> btw does someone know what's up with hackage?
23:32:36 <chylli> rwbarton: import System.Posix.Signals
23:32:36 <chylli>  
23:32:36 <chylli>  
23:33:15 <chylli> here is why add this : http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
23:33:16 <lambdabot> http://tinyurl.com/2znny8
23:33:22 <chylli> the last lines
23:35:25 <vixey> hm
23:38:40 <OceanSpray> :t (+1) . (*2) 6
23:38:42 <lambdabot> forall a (f :: * -> *). (Functor f, Num (f a), Num a) => f a
23:39:50 <vixey> :t head 6
23:39:51 <lambdabot> forall a. (Num [a]) => a
23:40:08 <vixey> numbers are stupid
23:40:59 <vixey> why not make it an error, "no typeclass like that exists"?
23:41:11 <OceanSpray> > head 6
23:41:12 <lambdabot>   add an instance declaration for (Num [a])
23:41:29 <OceanSpray> head (6 :: Int)
23:41:34 <OceanSpray> > head (6 :: Int)
23:41:35 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
23:41:38 <vixey> I mean why not make it a type time error, not a value time one
23:41:45 <OceanSpray> Can't it just do that every time?
23:41:59 <dibblego> head 6 = () -- :)
23:42:01 <vixey> do what?
23:42:16 <vixey> heh
23:42:42 <OceanSpray> oh forget it.
23:42:59 <rwbarton> chylli: I don't really understand what's going on.  But I think it might simplify things if you did all the setup (install signal handlers, open a socket, etc.) after the forkProcess
23:43:58 <rwbarton> chylli: for example, I have no idea whether a child process inherits its parent's signal masks.
23:44:34 <mmorrow> psyklops: "...I want every line sent to be echoed to all handles" could be done with Chan's from Control.Concurrent.Chan
23:44:44 <rwbarton> chylli: Or, you could just get rid of the forkProcess and handle backgrounding in a shell script, say
23:45:00 <chylli> rwbarton: let me try.
23:45:23 <chylli> rwbarton: what if I set sig handle after forkio ?
23:45:37 <psyklops> mmorrow: excellent, that does look useful
23:46:12 <mmorrow> psyklops: look in to MVars also => Control.Concurrent.MVar
23:46:32 <chylli> rwbarton: ok now
23:46:39 <chylli> rwbarton: thanks very much.
23:46:57 <rwbarton> chylli: Yes, it started working for me when I got rid of forkProcess
23:47:09 <ivanm> if I'm applying a fold in which I want to go through the entire list and order isn't important, it doesn't really matter whether I use foldr or foldl', does it?
23:47:10 <vixey> ohh this is tricky
23:47:15 <vixey> parse "\x -> x" ~> Lam (\x -> Var x)
23:47:26 <chylli> rwbarton: i'm not remove it, but set sig handle after forkprocess
23:47:35 <vixey> ivanm: yes it matters
23:47:49 <ivanm> vixey: in what way?
23:48:11 <vixey> ivanm: look at the types of both functions, they're subtly different
23:48:21 <chylli> rwbarton: but .... the sigPIPE still not ignore :(
23:48:36 <ivanm> vixey: that's just a matter of which way you write the function though, isn't it?
23:48:46 <mmorrow> ivanm: which one to use would be determined by what you're building as you're folding
23:49:11 <vixey> ivanm: foldr f z (reverse l) = foldl (flip f) z l
23:49:14 <ivanm> I have a list of elements I'm removing from my graph
23:49:28 <vixey> so it's more than just order of the list that matters
23:49:30 <ivanm> so my original question should have specified that I meant in terms of complexity, etc.
23:49:32 <vixey> =
23:49:39 <vixey> ivanm: is that clear?
23:50:00 <ivanm> vixey: yes...
23:50:06 <ivanm> I think :p
23:50:41 <ivanm> in this case, I don't think the order of elements in the list matters
23:51:24 <ivanm> e.g. consider foldr delete to foldl' (flip delete) ... does it matter which I choose, as they'll both have the same end result?
23:51:36 <mmorrow> by "determined" i mean in terms of foldr vs. foldl used to "build" certain things could results in (for example) O(n^2) vs. O(n)
23:51:55 <ivanm> *nod*
23:51:59 <mmorrow> which is exactly the case with foldl/foldr for (++)
23:52:23 <ivanm> though what I'm doing is analogous to that list example I just put up
23:52:47 <ivanm> so I'm using the fold to remove elements rather than add them
23:53:16 <rwbarton> chylli: how can you tell?
23:53:41 <chylli> rwbarton: telnet to localhost 7000, and kill it.
23:53:48 <chylli> and telnet again
23:53:52 <chylli> the server will be die
23:54:12 <chylli> rwbarton: thanks any way. I must go out. bye
23:54:33 <mmorrow> > last $ foldr (++) [] (take 1000000 . repeat $ [0..9])
23:54:35 <lambdabot>  9
23:54:37 <mmorrow> > last $ foldl (++) [] (take 1000000 . repeat $ [0..9])
23:54:39 <lambdabot>  Exception: stack overflow
23:55:00 <mmorrow> > foldr (+) 0 [0..10000000]
23:55:02 <lambdabot>  Exception: stack overflow
23:55:03 <vixey> yeah I have got no idea how to write a parser that emits HOAS in a simple typed language
23:55:04 <mmorrow> > foldl (+) 0 [0..10000000]
23:55:12 <lambdabot>  50000005000000
23:55:20 <ivanm> mmorrow: though I _was_ asking bout foldr vs foldl' :p
23:55:27 <vixey> of type checking ADT to produce HOAS either
23:55:33 <mmorrow> ivanm: i'm just having fun
23:55:37 <olsner> ivanm: sounds like foldr would allow you to evaluate heads of the list without fully evaluating the tails, which foldl maybe would not
23:55:38 <ivanm> heh
23:55:41 <vixey> what is the secret? :)
23:56:00 <olsner> depending on what "delete" does of course
23:56:05 <ivanm> wait, hang on... why did the foldr one die?
23:56:21 <mmorrow> stack overflow
23:56:24 <ivanm> oh, wait, that's right... it delays execution
23:56:28 <ivanm> I thought that was foldl :s
23:56:36 * ivanm can never keep those two straight
23:56:51 <mmorrow> > foldl f 0 [0..9]
23:56:52 <lambdabot>  Add a type signature
23:57:02 <ivanm> heh
23:57:15 <rwbarton> :t
23:57:15 <mmorrow> > foldl f 0 (replicate 8 a)
23:57:16 <rwbarton> :t x
23:57:18 <adu> I just got a development interview
23:57:19 <lambdabot>  Add a type signature
23:57:19 <mmorrow> > foldl f z (replicate 8 a)
23:57:21 <lambdabot> Expr
23:57:23 <lambdabot>  f (f (f (f (f (f (f (f z a) a) a) a) a) a) a) a
23:57:30 <mmorrow> > foldr f z (replicate 8 a)
23:57:32 <lambdabot>  f a (f a (f a (f a (f a (f a (f a (f a z)))))))
23:57:32 <ivanm> so in that summation example, does it matter if you use foldl or foldl' ?
23:57:32 <rwbarton> :t x+y
23:57:34 <lambdabot> Expr
23:57:38 <rwbarton> :t 0::Expr
23:57:40 <lambdabot> Expr
23:57:45 <rwbarton> > 0::Expr
23:57:46 <mmorrow> ivanm: oh, it does matter
23:57:46 <lambdabot>  0
23:57:51 <ivanm> > foldl' f z (replicate 8 a)
23:57:52 <lambdabot>  f (f (f (f (f (f (f (f z a) a) a) a) a) a) a) a
23:57:54 <adu> and the whole time I was laughing
23:57:56 <mmorrow> i pretty much always use foldl
23:57:56 <rwbarton> > [0..9] :: [Expr]
23:57:58 <mmorrow> i pretty much always use foldl'
23:57:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
23:58:05 <mmorrow> i *meant* foldl'
23:58:06 <ivanm> *nod*
23:58:09 <ivanm> heh
23:58:17 <ivanm> it forces evaluation, right?
23:58:20 <mmorrow> rwbarton: ah
23:58:20 <ivanm> rather than delaying it?
23:58:25 <mmorrow> @src foldl'
23:58:25 <lambdabot> foldl' f a []     = a
23:58:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:58:27 <adu> because all they wanted me to do was implement (unwords . reverse . words) in C
23:58:29 <mmorrow> @src foldl
23:58:29 <lambdabot> foldl f z []     = z
23:58:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:58:43 <rwbarton> > (foldl f 0 [0..9]) :: Expr
23:58:45 <lambdabot>  f (f (f (f (f (f (f (f (f (f 0 0) 1) 2) 3) 4) 5) 6) 7) 8) 9
23:58:51 <rwbarton> hmm, weird
23:58:53 <vixey> > take 5 (foldl' (1:) undefined (replicate 5 ()))
23:58:54 <lambdabot>  Couldn't match expected type `b -> [t]' against inferred type `[t]'
23:58:55 <rwbarton> :t (foldl f 0 [0..9])
23:58:57 <lambdabot> forall a. (SimpleReflect.FromExpr a, Num a) => a
23:59:20 <mmorrow> > foldl f z (replicate 4 a)
23:59:22 <lambdabot>  f (f (f (f z a) a) a) a
23:59:32 <rwbarton> :t f
23:59:34 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:59:37 <vixey> > take 5 (foldl' (1:) undefined (replicate 5 ()))
23:59:37 <rwbarton> ah
23:59:37 <lambdabot>  Couldn't match expected type `b -> [t]' against inferred type `[t]'
