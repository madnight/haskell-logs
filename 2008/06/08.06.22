00:00:13 <vixey> so... what's the point in it?
00:04:13 <dolio> Apparently his point is that the confusion was caused by being too lenient with the evaluation of coinductive types.
00:04:40 <dolio> Or something like that.
00:05:12 <dolio> Rather than being too strict, as one might hope for. :)
00:05:39 <vixey> oh
00:05:51 <vixey> there's not really any possible way to define eliminators for coinductives?
00:08:19 <vixey> well inductives -> eliminators is a solved problem, and if coinductives are really co-.. doesn't that mean you can reduce one problem to the other?
00:09:22 <dolio> Well, since coinductives are co, they have producers rather than eliminators, right?
00:09:30 <dolio> Unfolds instead of folds.
00:09:40 <dolio> And instead of constructors they have destructors.
00:10:31 <vixey> yes, that is true but I think you have to have special conditions on the use the unfold, whereas any well typed use of an eliminator is acceptable
00:10:43 <dolio> The proposal the one fellow on the Agda list made was that coinductive pattern matching is sugar for destructors.
00:10:45 <vixey> (I could be wrong about that though, I'm not totally sure)
00:11:57 <vixey> what is a destructor like?
00:12:30 <dolio> Well, constructors and destructors are related to the (co)algebraic semantics, I think.
00:12:47 <vixey> is fromJust a destructor?
00:12:49 <dolio> So a destructor is like A -> F A.
00:13:25 <dolio> Whereas a constructor is like F A -> A.
00:13:50 <vixey> :t Just
00:13:52 <lambdabot> forall a. a -> Maybe a
00:14:13 <vixey> I don't really understand
00:14:24 <dolio> Or, cons :: (a, [a]) -> [a] is a constructor, whereas headTail :: Stream a -> (a, Stream a) is a destructor.
00:14:40 <vixey> oh ok
00:15:19 <dolio> Destructors let you make an observation on a coinductive object.
00:16:02 <vixey> I see, that makes perfect sense now, thank for explaining
00:16:19 <dolio> And eliminators are related to the fact that inductive data types are terminal algebras.
00:16:31 <vixey> I wonder how the algorithm would look for desugaring pattern matching into destructors
00:16:44 <dolio> Whereas producers/unfolds would be related to coinductive types as terminal coalgebras.
00:16:51 <dolio> Sorry, that should be initial algebras.
00:16:54 <vixey> yeah I heard about initial and terminal algebras but I still can't tell them apart :s
00:17:18 <dolio> Yeah, I get initial and terminal swapped some amount of the time.
00:17:44 <vixey> hm maybe I'll add data type to my PTS checker..
00:18:38 <vixey> I wonder if there's some kind of negativity condition for coinductive definitions
00:18:45 <vixey> (like the positivity condition for inductives)
00:18:55 <dolio> I finally got around to reading A Tutorial on (Co)Induction and (Co)Algebras or whatever, but I'm still not certain how bisimulation would fit into Agda.
00:19:29 <dolio> I think you still want strictly positive types.
00:19:48 <dolio> Or functors. Whatever it is. :)
00:22:05 <dolio> I'm also unclear on indexed/dependent coinductive types. I don't think I've seen anything that gets into them yet.
00:26:22 <vixey> I still don't really know what coinduction is for
00:26:43 <vixey> I was thinking about maybe [mini]-haskell language semantics
00:28:27 <dolio> Well, anything where you do unfolding, obivously.
00:29:13 <dolio> OOP is coinductive/coalgebraic, I guess.
00:29:31 <dolio> You have an opaque object and can make observations of it (destructors).
00:29:48 <dolio> Or any abstract data, I guess.
00:30:18 <dolio> I have a paper I haven't read yet, Unfolding Abstract Datatypes, that says that coinductive/coalgebraic reasoning is the right stuff to use for abstract datatypes.
00:39:47 <mmorrow> vixey: intitial and terminal is just: initial object has a unique morphism to every/any elt => 1 is initial object in ring of Integers thought of as cat, where for n an Integer the unique map from initial obj (1) to n is (*n)
00:40:29 <mmorrow> terminal has a unique map from every/any obj to it => 0 is terminal in Integers, where is n an Integer, (*0) is the unique map to 0
00:41:00 <mmorrow> cleaning the previous stmt up:
00:41:42 <mmorrow> "the" terminal obj has a unique map from every/any obj to it => 0 is terminal in Integers, where (*0) is the unique map to 0 from any n an Integer
00:46:24 <mmorrow> and of note is that (*1) and (+0) as functors (Z -> Z) are isomorphic to id :: Z -> Z (and to each other)
00:47:43 <adu> how are (*1) and (+0) not equivalent to id?
00:48:20 <mmorrow> they "are isomorphic to id"
00:48:39 <mmorrow> :)
00:48:51 <ski_> what are the morphisms ?
00:49:00 <dolio> What category is this?
00:49:17 <adu> a functor category, obviously
00:49:32 <mmorrow> well, i'm freely abusing notation
00:49:33 <ski_> "<mmorrow> .. ring of Integers thought of as cat .."
00:49:51 <dolio> Ah, was skimming too fast.
00:50:42 <adu> my favorite functor is the Carleman matrix
00:50:53 <mmorrow> ski_: i guess i mean "the single object category Z with morphisms => for every n `elem` Z, (*n) and (+n) are morphisms"
00:51:27 <ski_> `Z' being the object ?
00:51:35 <mmorrow> yes
00:51:58 <solrize_> :t (>>=)
00:52:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:52:15 <ski_> and composition closure for the morphisms ?
00:52:27 <mmorrow> and since their's only  a single object, lets think of automorphisms of that object as functors from it "thought of as a category" to itself
00:52:30 <adu> :t (flip (>>=))
00:52:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
00:52:59 <mmorrow> s/automorphisms/endomorphisms/
00:53:09 <mmorrow> (being general)
00:53:13 <ski_> why not any .. was just going ask about that :)
00:53:24 <mmorrow> :)
00:54:15 <ski_> so `(* 2) . (+ 1)' is a morphism, too ?
00:54:56 <dolio> You might want to go with natural numbers.
00:55:04 <dolio> Otherwise I'm not sure 0 is terminal.
00:55:09 <mmorrow> ski_: yes!
00:55:16 <mmorrow> (it would have to be)
00:56:02 <ski_> (i was thinking you maybe wanted some strange quotient category or something ..)
00:56:05 <dolio> Since both (*0) and (+ -n) are n -> 0
00:56:43 <mmorrow> so, we're in parallel thinking of (*2) . (+1) as a morph Z->Z of the object Z in the  cat consisting of only that objects and a bunch of endos, and as a Functor from that cat (let's also call it Z) to itself
00:57:08 <adu> the Carleman functor maps (complex numbers, holomorphic functions) -> (Vandermonde vectors, Carleman matrices)
00:59:09 <mmorrow> (i guess we'd also have to say how it as a functor acts on functions, but just say it "does the most obvious thing" or something)
00:59:26 <ski_> mmorrow : are you talking about a functor over the nameless category ? or over the object `Z', somehow regarded as a category ?
01:00:01 <paolino> ot: anyone solved (or not) problem B of the training session of google code jam and want to unbug my idea ?
01:00:13 <mmorrow> ski_: heh. i think with my prev stmt, that's cleared up, or maybe i'm misunderstanding your question.
01:00:15 * dolio still isn't entirely sure what we're talking about.
01:00:30 <ski_> likewise
01:01:02 <mmorrow> i'm running in to slight difficulty trying to retroactively rigorize my abuse of notation ;)
01:01:23 <mmorrow> *but*, i'm sure i could make it precise, and am going to think about it
01:01:38 <adu> mmorrow: ok
01:01:42 <ski_> (in soviet russia, notation abuses you !)
01:01:47 <dolio> I'd just drop it and go with Natural numbers with <= as morphisms. :)
01:01:53 <dolio> Or maybe N + infinity.
01:02:15 <mmorrow> hmm
01:02:25 <dolio> (For a terminal object).
01:05:14 <adu> I made an icon for Yi!
01:05:25 <adu> http://img48.imageshack.us/img48/9071/mydreamyn1.png
01:06:08 <mmorrow> that's pretty rad
01:06:27 <adu> now I just need a macosx-ized program to go with it
01:06:58 <Axman6> what is Yi?
01:07:11 <adu> Axman6: its an editor written in Haskell
01:07:16 <Axman6> ah, nice
01:07:36 <smtms> I'm sure every European or American will associate these strokes in the icon with Yi instantly...
01:07:48 <Axman6> could find out how gimp packages itself for OS X, and see if you can get something like that working
01:08:18 <mmorrow> you should have the lambda background in the little-icon version too
01:08:41 <mmorrow> it's like the universal fp logo
01:08:48 <Axman6> adu: what's the LaTeX app?
01:09:09 <adu> hmm, maybe I just thought it might distract the eye in the icon-form
01:09:22 <rwbarton> Axman6: It's TeXShop
01:09:28 <adu> Axman6: its TeXshop, a macosx environment for making tex docs
01:09:41 <Axman6> i use TextMate personally
01:09:58 <adu> i use emacs for everything else
01:10:04 <mmorrow> adu: fair enough
01:10:19 <adu> i find the syntax highlighting in emacs is better than anything I would have to pay money for
01:11:08 <Axman6> fark. been compiling GHC all day, and i can't get readline support, although macports can, and it doesn't seem to be doing anything special
01:11:23 <dons> adu: nice
01:11:37 <dons> adu, does ghci have an icon?
01:12:01 <adu> dons: I think the Installer version does, but the MacPorts version, no
01:12:17 <dons> ah, the disk image installable version?
01:12:22 <adu> dons: yes
01:12:43 <dons> cool
01:14:57 <cjs_> haskell.org is unhappy again.
01:17:02 <cjs_> Is there a mirror of this server somewhere? I am helpless without docs.
01:17:43 <dons> i wonder if its under load.
01:17:56 <dons> mirrors would be a great idea, actually.
01:18:11 <dons> shouldn't be too hard to mirror a mediawiki
01:19:51 <cjs_> I'd run one, no problem.
01:19:54 <GrayShade> cvs.haskell.org works, though
01:20:05 <smtms> adu, what's that app between Firefox and Safari on your Dock?
01:20:13 <cjs_> Probably you could just rsync the lot of it, and turn off edits on the mirrors.
01:20:22 <cjs_> Anyway, you want to let me rsync docroot, I'm all there.
01:20:23 <adu> smtms: LimeWire
01:21:32 <astrolabe> I want a data structure into which I can efficiently insert elements using a Double key, and then efficiently look up the first element with key greater than some query key.  Do I need to write my own self-balancing binary tree?
01:21:58 <Soliah> Could someone give me a simple function that illustrates lazy evaluation?
01:22:12 <dolio> > [1..]
01:22:14 <cinimod> www.haskell.org seems to have stopped working. Any admins around?
01:22:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:22:30 <astrolabe> > head [1..]
01:22:32 <lambdabot>  1
01:23:12 <mmorrow> > let f = \Just _ -> 42 in f (Just undefined)
01:23:13 <lambdabot>      Constructor `Just' should have 1 argument, but has been given 0
01:23:13 <lambdabot>     In t...
01:23:24 <mmorrow> > let f = \(Just _) -> 42 in f (Just undefined)
01:23:25 <lambdabot>  42
01:23:35 <cinimod> Ah I see it's already been noticed. cvs.haskell.org is on a different server.
01:25:02 <GrayShade> there's some documentation (Hugs?) on that one
01:25:22 <mmorrow> > let f = \x -> if x==0 then "never" else "reached" in f undefined
01:25:23 <lambdabot>  "Exception: Prelude.undefined
01:26:20 <mmorrow> > let f = \_ -> if True then "never" else "reached" in f undefined
01:26:22 <lambdabot>  "never"
01:32:18 <gwern> hm. is haskell.org down?
01:32:24 <solrize_> yep
01:32:36 <mmorrow> looks like it from me
01:32:45 <gwern> how irksome
01:32:52 <cjs_> Is there any other place I can get an API reference? Or download one to use locally?
01:33:24 <gwern> your ghc package should've come with docs, or else as a ghc-doc package
01:33:33 <gwern> try /usr/share/doc/ghc-something iirc
01:33:35 <HunterXHunterX> > [1..] !! 10
01:33:37 <lambdabot>  11
01:33:39 <astrolabe> cjs_: I've just realised that when I installed ghc, it put the hierarchical libraries documentation on my machine.
01:34:02 <astrolabe> chs_: Which OS do you have?
01:34:29 <astrolabe> file:///usr/share/doc/ghc6-doc/libraries/index.html
01:34:54 <gwern> 'We could have written the Bool instance by generating integer values between 0 and 1 instead, using choose, and then mapping them onto the booleans'....
01:35:08 * gwern wonders what integer values lie between 0 and 1
01:35:17 <dons> gwern: add a comment.
01:36:19 <gwern> dons: incidentally, I'm really pleased to see a section on the 'reference implementation' checking. that's my favorite QC technique
01:36:43 <dons> yeah, mine too :)
01:36:49 <dons> great for data structures
01:37:03 <dons> and quite different to the run of the mill unit testing
01:37:07 <cjs_> astrolabe: Unfortunately, my package doesn't do that.
01:37:16 <cjs_> I'm on NetBSD.
01:37:16 <gwern> really saved my bacon on darcs bytestring stuff too
01:37:24 <dons> 'zactly
01:38:34 <vixey> adu, here?
01:38:41 <gwern> I wonder sometimes - moore's law has cranked once or twice since QC was first released. maybe the default number of tests should be increased
01:38:43 <adu> vixey: yes
01:38:52 <dons> haskell.org's back up
01:39:02 <vixey> adu, Well I thought I should start writing an objective c bridge but it went really badly
01:39:14 <vixey> adu, I wonder if you had any success with c2hs?
01:39:26 <dons> you guys documenting the new obj-c effort on the wiki?
01:39:30 <adu> I've never used c2hs
01:39:40 <adu> dons: nope, but I could
01:39:43 <dons> gwern: did i show you the new sparklines for hackage daily uploads on the haskell frontpage?
01:39:50 <vixey> adu, (actually it didn't go really badly, it should be straightforward if c2hs can be made to work)
01:39:51 <dons> i think they're cute and nifty.
01:40:03 <gwern> dons: incidentally, any idea when qc 2 will be out? that might force some revision of this chapter, dunno
01:40:05 <adu> dons: HOC got through parsing around 200 ObjC files today :)
01:40:11 <dons> adu: sweet
01:40:27 <dons> gwern: nah, it has no maintainer. so in the same league as parsec3 -- not game changing
01:40:43 <adu> vixey: isn't c2hs related to gtk2hs?
01:40:47 <gwern> dons: no. I noticed in the hackage rss hackage-sparklines, buthadn't looked't
01:41:01 <vixey> adu, I think so
01:41:04 * gwern looks at haskell.org. ooh shiny
01:41:20 <dons> gwern: so each day the front page is auto-edited by hackage2wiki, and the sparkline generated for the monthly stats
01:41:32 <gwern> dons: ah. I had remembered you saying we could expect qc2 a couple months ago when a thesis or something got finished
01:41:42 <dons> yeah, it's on the todo list
01:42:20 <gwern> so each bar is a day, then?
01:42:22 <dons> yep
01:42:27 <dons> click on it, it's a link
01:42:39 * gwern sees
01:42:51 <Soliah> dolio, HunterXHunterX: Thanks.
01:43:13 <gwern> huh. pretty spiky. there's at least 2 places where it abruptly jumps in the by-month graph
01:43:19 <astrolabe> cjs_: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries
01:43:42 <astrolabe> Not brilliant though.
01:46:16 <adu> dons: all I could find was this:
01:46:18 <adu> http://www.haskell.org/haskellwiki/Missing_tutorials
01:46:19 <lambdabot> Title: Missing tutorials - HaskellWiki
01:46:47 <dons> adu: oh, i was suggesting a new page be created
01:47:02 <adu> ok :)
01:48:37 <mmorrow> "cute and nifty" exactly describe sparklines
01:51:12 <gwern> ah, pugs fails to cabal-install
01:51:18 <gwern> should've known it'd be too good to be true
01:51:27 <vixey> for me too
01:51:34 <dons> works for me.
01:51:34 <vixey> but I have pugs already installed
01:51:49 <dons> it's even in the arch overlay already
01:52:00 <dons> be sure to get the latest versions of the dependencies
01:52:47 <gwern> well, maybe deps are the problem. cabal-upgrade barfs on me because of hpc
01:52:56 <gwern> so I can't even see what else would be upgraded
01:53:04 <gwern> (--dry-run fails immediately)
01:53:13 <gwern> you guys think this is a cabal bug?
02:00:57 <gwern> ah, I have to specify -v
02:01:00 <gwern> that makes sense
02:04:35 <gmosx> hello
02:06:00 <adu> hello
02:10:13 <hackage> New package: Ranged-sets 0.2.1
02:11:13 <vixey> o_o
02:11:30 <dolio> Heh.
02:12:10 <gmosx> Is the XSLT lib in HXT suitable for production work?
02:16:33 <adu> gmosx: i've never used HXT
02:18:57 <gmosx> adu: any other xslt lib for haskell?
02:19:36 <adu> nope
02:19:48 <adu> i've only used xsltproc
02:20:05 <gmosx> what is xsltproc?
02:21:19 <adu> gmosx: so far as I know its the standard XSLT processing utility, maybe because it comes with libxslt
02:21:55 <gmosx> ah ;-)
02:21:58 <mmorrow> new desktop background: http://lisperati.com/landoflisp/panel53.html
02:22:17 <mmorrow> (explanation: http://lisperati.com/landoflisp/panel55.html)
02:22:21 <mmorrow> lol
02:22:49 <mmorrow> (oops, i meant explanation: http://lisperati.com/landoflisp/panel56.html)
02:23:10 <mmorrow> oll
02:24:41 <prc> hello
02:24:42 <prc> :)
02:25:23 <prc> anybody here?
02:25:32 <dolio> No.
02:25:35 <prc> :))
02:25:40 <prc> good..
02:25:48 <mmorrow> prc: http://lisperati.com/landoflisp/panel56.html
02:26:24 <gmosx> bye!
02:27:11 <mmorrow> :)\
02:27:31 <mmorrow> s/\\//
02:27:46 <vixey> s!\!!
02:28:28 <Deewiant> unterminated 's' command
02:30:22 <Axman6> pifish!
02:30:55 <pifish> Axman!
02:33:15 <gwern> personally, I'm a big fan of the one scene where the judge is rearing up invoking the Republic of haskell
02:33:29 <gwern> the scene with the wiz inciting the lispers to not defect to the other side is also good
02:34:04 <adu> I can't tell which side they were trying to portray in a good light...
02:34:56 <gwern> that's good. it's not a clear-cut issue
02:34:56 <gwern> anyone who tells you other is being religious about it
02:35:35 <gwern> imagine how unpleasant parts of haskell could be if we didn't have various type breakers like unsafePeformIO or unsafeCoerce stuff
02:36:10 <gwern> ...as much as they make it difficult to do things like write a bot which safely evaluates haskell expressions
02:37:40 <gwern> 'Of course, I have the luxury of mostly reviewing Python code, and Python makes it ridiculously easy to embed useful documentation. What’s more, automated API-documentation generators don’t seem to be as popular in Python as they are in some other languages, which means the lazy attitude of “a big list of function names and argument signatures should be all the documentation you need” thankfully is not prevalent in Python. ' :(
02:37:46 <gwern> http://www.b-list.org/weblog/2008/jun/21/documentation/
02:37:47 <lambdabot> Title: Let&#39;s talk about documentation
02:46:51 <adu> yey
02:47:11 <adu> I hacked GIMPskel to launch Yi
02:48:35 <dolio> Huh, apparently you can do this: "i :: Bool -> Int# ; i True = 0#"
02:49:10 <adu> what does 0# mean?
02:49:25 <dolio> 0# is unboxed 0.
02:49:35 <dolio> It's like a machine integer.
02:52:12 <Axman6> > let i True = 0# in i True
02:52:12 <lambdabot>  Parse error at "in" (column 17)
02:52:18 <Axman6> :\
02:53:02 <hpaste>  norbi pasted "network-minihttp build erro" at http://hpaste.org/8467
02:53:05 <Axman6> :t 0#
02:53:06 <lambdabot> GHC.Prim.Int#
02:53:21 <norbi> I'm having trouble building network-minihttp. I get the error http://hpaste.org/8467
02:53:33 <norbi> Any ideas?
02:54:13 <dolio> Apparently "i :: Bool -> Int# ; i True = 0# ; i False = error "foo"" also works.
02:54:19 <dolio> Which surprises me more, I suppose.
02:56:09 <dolio> Go in and add OverloadedStrings to the LANGUAGE extension list somewhere.
02:56:37 <dolio> Or get a newer bytestring maybe. I'm not sure.
02:57:53 <norbi> I've checked the source file and the OverloadedString is already added...
02:58:08 <norbi> I'm going to check the bytestring version
02:59:26 <dolio> You could add a call to pack in the appropriate place, too.
03:00:17 <dolio> I suppose the fact that it was talking about IsString at all was an indication that OverloadedStrings was already in there.
03:00:58 <mmorrow> (somewhat related) it seems like you can get a large part of Data.Generics with $(lift =<< reify ''Whatever) and tag :: a -> Int
03:00:58 <mmorrow> tag a = I# (dataToTag# a)
03:01:55 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8468
03:02:14 <mmorrow> import (this might be needed for something: GHC.Prim),  dataToTag# is in GHC.Base, I# is in GHC.Exts
03:07:25 <astrolabe> Real World Haskell is at the top of reddit for me
03:19:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8469
03:20:36 <adu> I got the Yi.app working, should I post to the haskell wiki?
03:22:23 <adu> I also got wxHaskell working
03:29:41 <hpaste>  EvilTerran annotated "(no title)" with "style details" at http://hpaste.org/8469#a1
03:50:38 <ski_> @type let i :: Bool -> (# GHC.Prim.Int# , Int #) ; i True = (# 0# , 0 #) ; i False = error "foo" in i
03:50:40 <lambdabot> Bool -> (# GHC.Prim.Int#, Int #)
03:50:48 <ski_> @type error
03:50:50 <lambdabot> forall a. [Char] -> a
03:51:31 <ski_> more like `forall (a :: ?). String -> a', it seems
03:53:16 <EvilTerran> ?type error :: String -> GHC.Prim.Int#
03:53:18 <lambdabot> String -> GHC.Prim.Int#
03:53:27 <Deewiant> does "forall a." imply that a has kind *, then?
03:54:02 <EvilTerran> it can infer that it may be (* -> *) or whatever, too
03:54:24 <vixey> wont it always annotate it when the kind isn't *?
03:54:48 <EvilTerran> ghc will
03:54:58 <EvilTerran> but kind annotations are an extension (but then, so are foralls)
03:54:58 <ski_> @type return
03:55:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
03:55:18 <EvilTerran> if you don't have -XKindAnnotations, i imagine it won't annotate anything
03:56:57 <EvilTerran> "In particular: error :: forall (a::?). String -> a; (->) :: ?? -> ? -> *; (\(x::(t::??)) -> ...)"
03:57:21 <EvilTerran> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
03:57:24 <lambdabot> http://tinyurl.com/y76qhn
03:57:27 <EvilTerran> (paraphrasing)
04:00:43 <norbi> updating bytestring to the latest version fixed my network-minihttp build error
04:08:40 <dancor> it is necessary to use try to make a parsec parser for /* .. */ comments right?
04:10:24 <hackage> New package: ASN1 0.0.1.1
04:10:29 <lilachaze> @hoogle [a] -> Int -> (a -> a) -> [a]
04:10:30 <lambdabot> No matches, try a more general search
04:12:29 <dancor> map with a counter?
04:12:37 <lilachaze> dancor: yes, for a character parser. you don't want to commit to 'it's a comment' when you see just a '/'.
04:12:54 <lilachaze> dancor: map with a position
04:14:17 <lilachaze> > let at l n f = take n l ++ [f (l!!n)] ++ drop (n+1) l in [1,2,3,4,5] `at` 3 (2*)
04:14:18 <lambdabot>        add an instance declaration for (Num ((t -> t) -> Int))
04:14:34 <hpaste>  milyin pasted "prime factors" at http://hpaste.org/8470
04:15:00 <vixey> [a] -> (Integer -> a -> a) -> [a]
04:15:04 <vixey> you mean this right?
04:15:23 <vixey> :t \l f -> zipWith f [27..] l
04:15:25 <lambdabot> forall a b c. (Enum a, Num a) => [b] -> (a -> b -> c) -> [c]
04:15:25 <lilachaze> vixey: no, i only want to transform one element
04:15:48 <lilachaze> > let at l n f = take n l ++ [f (l!!n)] ++ drop (n+1) l in ([1,2,3,4,5] `at` 3) (2*)
04:15:49 <lambdabot>  [1,2,3,8,5]
04:17:21 <lilachaze> @hoogle Int -> (a -> a) -> [a] -> [a]
04:17:22 <lambdabot> No matches, try a more general search
04:17:35 <vixey> start with \l f -> zipWith f [0..] l
04:17:37 <hpaste>  Deewiant pasted "applyAt" at http://hpaste.org/8471
04:17:42 <dancor> > zipWith (\ i -> if i == 3 then (2 *) else id) [1..5]
04:17:43 <lambdabot>  <[Integer] -> [Integer]>
04:18:18 <lilachaze> ick :)
04:18:36 <vixey> ick? that's a great way
04:19:06 <dancor> > zipWith (\ i -> if i == 3 then (2 *) else id) [1..] [1..5]
04:19:07 <lambdabot>  [1,2,6,4,5]
04:19:08 <lilachaze> it's unclear IMO :)
04:19:27 <dancor> > zipWith (\ i -> if i == 3 then (2 *) else id) [0..] [1..5]
04:19:28 <lambdabot>  [1,2,3,8,5]
04:19:29 <vixey> I don't think it could be clearer..
04:19:39 <paolino> is it possible to write this with fix ?
04:19:39 <paolino> so (x:xs) = map (x:)(so xs) ++ so xs
04:19:59 <lilachaze> at n f l = h ++ [f (head t)] ++ drop 1 t where (h,t) = splitAt n l
04:20:01 <vixey> :t let so (x:xs) = map (x:) (so xs) ++ so xs in so
04:20:03 <lambdabot> forall t (f :: * -> *). (Monoid (f [t]), Functor f) => [t] -> f [t]
04:20:03 <lilachaze> ^^ i'd say that's clearer
04:20:06 <Deewiant> ?pl so (x:xs) = map (x:) (so xs) ++ so xs
04:20:06 <lambdabot> so = fix ((`ap` tail) . (. head) . (flip =<< (liftM2 (++) .) . flip ((.) . map . (:))))
04:21:39 <lilachaze> at n f l = h ++ [f e] ++ t where (h,e:t) = splitAt n l -- clearer still
04:21:44 * dancor is surprised he can't find any /* .. */ parsec example
04:22:12 <paolino> what is the name of those subsets?
04:22:38 <paolino> base case is :so [x] = [[x]]
04:23:02 <paolino> *Main> so [1,2,3,4]
04:23:02 <lilachaze> dancor: fwiw, i do /* ... */ stripping outside of parsec in my C lexer.
04:23:02 <paolino> [[1,2,3,4],[1,2,4],[1,3,4],[1,4],[2,3,4],[2,4],[3,4],[4]]
04:23:13 <lilachaze> dancor: but ISTR that parsec has some builtin stuff to do that
04:23:35 <lilachaze> paolino: subsequences?
04:24:36 <eu-prleu-peupeu> hello
04:25:02 <paolino> lilachaze: ie. [1,2] is missing
04:26:22 <eu-prleu-peupeu> is there any haskell lib for solving partial differential equations ?
04:26:24 <dancor> paolino: well it would be with base case so [x] = [[]]..
04:26:33 <dancor> err so [] = [[]]
04:26:53 <dancor> what is the use of your so instead of powerset?
04:27:30 <dancor> it looks like powerset but must containt last element
04:28:14 <paolino> mmhh, I wonder if thet is what I want :d
04:29:23 <dancor> @pl \ l -> l ++ map (x:) l
04:29:23 <lambdabot> ap (++) (map (x :))
04:29:45 <paolino> dancor: I need to identify all the ordered subsequencies
04:29:58 <Axman6> @src ap
04:29:58 <lambdabot> ap = liftM2 id
04:30:05 <dancor> paolino: you want  so [] = [[]]
04:30:17 <dancor> not so [x] = [[x]]
04:30:56 <dancor> and you might as well call 'so' powerList or something :)
04:32:18 <paolino> mmhh, there is no need to have 1,2 if I cut 1,2,3,4 when element 3 < element 2
04:33:33 <dancor> i would prob just do like  filter isOrdered . powerList  unless i needed it to be faster
04:33:58 <lilachaze> i'd call it subsequences not powerList, myself :)
04:34:46 <paolino> the thing is that when 1,2 fail I should rule out all the 1,2,.. subsequencies
04:35:05 <lilachaze> paolino: perhaps you can tell us something about the problem you're trying to solve?
04:35:53 <qwr> could you suggest some channel, where discussion of non-haskell functional language design would be ok? :)
04:36:03 <paolino> lilachaze: the problem is find the longest ordered sublist of a list of orderable elements
04:37:16 <paolino> sublist of possibly non adiacent elements
04:39:02 <vixey> qwr: #lispcafe
04:39:15 <qwr> thx
04:39:43 <paolino> lilachaze: does it make sense ?
04:40:38 <pjdelport> qwr: #oasis
04:42:13 <dancor> paolino: use inits, finding largest subseq each elem is start of, and take biggest one?
04:42:29 <rabbit64> Did anyone use ghc with cmake here?
04:43:07 <dancor> s/inits/tails
04:43:10 <paolino> dancor, you must include sublists with non adiacent elements
04:44:01 <paolino> like 1,4,5 are valid indices of a possible solution
04:44:18 <dancor> paolino: map (\ l -> filter (>= head l) l) . tails $ [6, 2, 1, 8, 9, 4, 5]
04:44:27 <dancor> then take biggest
04:44:38 <dancor> oh hm
04:44:42 <dancor> fail
04:46:01 <dancor> well how is that idea but using helper func instead of filter (>= head l)
04:48:33 <paolino> but tails is not producing all the sublists
04:48:46 <dancor> seriously i would do the filter isOrdered . powerList thing
04:51:51 <dancor> otherwise for better perf write helper biggestOrderedSubseqStartingWithFirstElem and map that over tails and take biggest result
04:54:55 <vixey> ?go algebraic datatype
04:54:56 <lambdabot> http://en.wikipedia.org/wiki/Algebraic_data_types
04:55:37 <vixey> lambda, mu, sum, product and unit is what you need?
04:56:35 <lilachaze> paolino: sorry, distracted. sounds like a dynamic programming approach would probably be best
04:56:46 <lilachaze> that is, if efficiency is important
04:57:21 * lilachaze not entirely sure that's workable thinking about it...
04:57:58 * dancor is not sure you can get under O(n^2)
04:58:35 <lilachaze> sure, but filtering the subsequences is O(2^n)...
04:58:48 <dancor> lilachaze: the second idea is O(n^2)
04:59:42 <lilachaze> dancor: heh, yep, that's the DP solution :)
05:00:13 <dancor> but there is no building up of the answer?
05:00:57 * dancor thought that dp = recursion + memoization
05:01:00 <lilachaze> dancor: there is if you want to avoid exponential time
05:02:11 <dancor> lilachaze: no, you can just look at each elem as a starting elem (n) and find the biggest for that one (times n).  then take the biggest of the n answers (n).  n^2 + n = n^2
05:02:30 <Beelsebob_> why couldn't you get under n^2?
05:02:45 <Beelsebob_> just scan along the list, keeping an accumulator of your biggst ordered sequence
05:02:52 <Beelsebob_> and your current ordered sequence
05:02:55 <Beelsebob_> length of both
05:03:03 <Beelsebob_> and swap them over when you get a new longest
05:03:03 <olsner> ... isn't this a standard problem you can look up easily in one of those textbooks? :P
05:03:22 <lilachaze> Beelsebob_: it would be easy if we were looking for the longest ordered substring :)
05:03:34 <dancor> Beelsebob_: what if halfway along the current-second-longest-subseq is the one that is part of the final longest?
05:03:48 <dancor> you can't just keep longest
05:03:50 <dancor> as you go
05:04:26 <Beelsebob_> dancor: it isn't -- if you have a long ordered sequence that starts at position i, then p(i-1) by definition is not less than p(i) because otherwise the start would be earlier
05:04:36 <dancor> Beelsebob_: ok right
05:04:37 <Beelsebob_> lilachaze: oh, I must have missed the question -- what's the problem?
05:05:16 <lilachaze> Beelsebob_: find the longest ordered subsequence of a sequence.
05:05:32 <Beelsebob_> right, so that's what I just explain an O(n) algorithm for... didn't I?
05:05:43 <lilachaze> Beelsebob_: your algo fails for [1,9,10,2,3,4,5,6,7], right?
05:05:47 <dancor> Beelsebob_: 10,11,12,1,2,3,4,5,13
05:05:51 <dancor> hm
05:06:00 <Beelsebob_> why is that a problem for it?
05:06:05 <dancor> no problem, i guess you are right..
05:06:33 <paolino> [1,4,2,5,3] -> ?
05:06:57 <dancor> Beelsebob_: i think you do have a problem with lilachaze's example
05:07:08 <Beelsebob_> dancor: can you explain why?
05:07:14 <paolino> [1,2,3]
05:07:23 <paolino> everyone agrees ?
05:07:29 <dancor> Beelsebob_: at 2 your biggest subseq is 1,9,10
05:07:43 <dancor> Beelsebob_: so you will never find 1..7 by the end
05:08:03 <Beelsebob_> oh hang on -- you want to find [1,2,3,4,5,6,7] in that list?
05:08:10 <lilachaze> yes
05:08:17 <Beelsebob_> I am indeed misinterpretting the problem then
05:08:27 <Beelsebob_> I expected that you wanted [2,3,4,5,6,7] from that
05:08:33 <paolino> eh
05:08:44 <Beelsebob_> that is the longest sub-list which is entirely ordered
05:08:50 <Beelsebob_> [1,2,3,4,5,6,7] isn't a sub-list
05:09:14 <lilachaze> we want the longest subsequence, not the longest substring :)
05:09:32 <Beelsebob_> hmm, *ponders* you may be able to get lower than O(n^2) though -- what if you were to perform my algo, and collect up all of the substrings
05:09:44 <Beelsebob_> then sort them by start and end point
05:09:47 <Beelsebob_> to see if they can be joined
05:09:54 <Beelsebob_> can that get you down to O(n log n)
05:09:55 <Beelsebob_> ?
05:10:07 <Beelsebob_> I suspect not, but I can't fully see it yet
05:10:11 <vixey> :t either
05:10:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:10:30 <olsner> something like head . sortOnDescending length . filter isOrdered . powerList is what we're looking for
05:10:38 <dancor> Beelsebob_: so we get [1,9,10] and [2..7] here
05:10:40 <olsner> *you
05:10:54 <Beelsebob_> ah yeh, I see what's wrong there
05:11:02 <Saizan> http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem
05:11:03 <lambdabot> http://tinyurl.com/3cnopa
05:11:04 <Beelsebob_> so yeh, it doesn't sound like you can really get below O(n^2)
05:12:05 <dancor> Beelsebob_: well wikipedia now says you can :)
05:12:11 <Beelsebob_> it does indeed
05:12:20 <Beelsebob_> and yeh, the algo is almost what I was on the trail of there
05:12:25 <Beelsebob_> I just didn't quite see it fully
05:14:43 <vixey> :t bool
05:14:45 <lambdabot> Not in scope: `bool'
05:18:48 <RayNbow> @kind Bool
05:18:50 <lambdabot> *
05:19:55 <paolino> bool :: a -> a -> Bool -> a
05:20:14 <paolino> :t maybe
05:20:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:26:04 <lilachaze> @index comparing
05:26:04 <lambdabot> bzzt
05:26:33 <RayNbow> @index compare
05:26:33 <lambdabot> Prelude
05:26:37 <RayNbow> that one?
05:29:30 <TSC> comparing is in Data.Ord
05:32:02 <vixey> what do you call the list of bindings a pattern match makes?
05:33:56 <dancor> @pl \ f -> try (string "*/") <|> (anyToken >> f)
05:33:56 <lambdabot> (try (string "*/") <|>) . (anyToken >>)
05:34:26 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8472
05:35:08 <lilachaze> @hoogle (a -> [b] -> b) -> [a] -> [b]
05:35:08 <lambdabot> No matches, try a more general search
05:35:29 <lilachaze> @djinn (a -> [b] -> b) -> [a] -> [b]
05:35:29 <lambdabot> -- f cannot be realized.
05:35:31 <paolino> :t isPrefixOf
05:35:33 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:35:50 <dancor> djinn doesn't do lists
05:35:56 <dancor> sadly
05:35:56 <paolino> > isPrefixOf [1] [1,2]
05:35:58 <lambdabot>  True
05:36:21 <Axman6> heh, that function was in our comp examp
05:36:24 <Axman6> exam*
05:37:03 <lilachaze> Axman6: which one?
05:37:06 <Axman6> had to figure out what a function with a non-sensicle name did, and suggest a better name
05:37:10 <Axman6> isPrefixOf
05:37:25 <Axman6> that's a much better name than the one i came up with :P
05:37:52 <lilachaze> from a python background, i'd have gone with startsWith :)
05:38:06 <Axman6> i think i said beginsWith
05:38:11 <Axman6> or begins
05:38:43 <Axman6> so you could have [1,2,3] `begins` [1,2,3,4,5]
05:42:10 <EvilTerran> isPrefixOf is, likewise, one of those made-for-infix names
05:44:42 <lilachaze> @let longestIncreasingSubsequence = snd . maximumBy (comparing fst) . foldr (\a b -> bestStartingWith a b:b) [] where bestStartingWith x best = maximumBy (comparing fst) $ [(1,[x])] ++ (map ((1+) *** (x:)) . filter (\(_,y:ys) -> y >= x) $ best)
05:44:43 <lambdabot> <local>:4:80:     Ambiguous type variable `a' in the constraint:       `Ord a...
05:49:17 <lilachaze> > longestIncreasingSubsequence [1,3,4,5,9,10,2,3,4,5,6]
05:49:18 <lambdabot>  [1,2,3,4,5,6]
05:50:17 <paolino> ﻿> longestIncreasingSubsequence [1,7,5,9]
05:50:41 <paolino> @bot
05:50:42 <lambdabot> :)
05:51:04 <paolino> ﻿> longestIncreasingSubsequence [1,7,5,9]
05:51:34 <lilachaze> i think it's @let only for me :/
05:53:54 <byorgey> no, paolino has a funny non-breaking space character or something before the > instead of a normal space
05:53:54 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
05:54:33 <byorgey> @seen gwern
05:54:33 <lambdabot> I saw gwern leaving #darcs, #xmonad and #haskell 1h 4m 14s ago, and .
05:54:59 <byorgey> @tell gwern yes, http://code.haskell.org/~byorgey/code/hwn is the new canonical location.
05:54:59 <lambdabot> Consider it noted.
05:55:12 <paolino> > longestIncreasingSubsequence [1,7,5,9]
05:55:13 <lambdabot>  [1,5,9]
05:56:08 <paolino> lilachaze: nice, you can do google code jam :)
05:57:03 <paolino> is that O n^2 ?
05:57:22 <lilachaze> yes
05:57:45 <lilachaze> it might be faster (because the worst case doesn't exist) but i've not proved a better bound yet
06:00:00 <paolino> :t comparing
06:00:03 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:00:16 <paolino> :t (compare `on`)
06:00:17 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
06:00:24 <lilachaze> paolino: i'm reasonably sure it's Θ(n^2)
06:03:06 <paolino> ﻿> longestIncreasingSubsequence [1,7,5,9,4]
06:03:20 <paolino> > longestIncreasingSubsequence [1,7,5,9,4]
06:03:22 <lambdabot>  [1,5,9]
06:05:57 <paolino> for sure there has to be a cut condition , somewhere
06:07:12 <paolino> but I still has to understand the algo
06:11:28 <paolino> lilachaze: what is best ?
06:13:40 <paolino> the length coupled with the list ?
06:18:44 <paolino> it's nice and subtle we can keep one best
06:20:23 <EvilTerran> what if the longest increasing subsequence is infinite? :P
06:23:03 <paolino> lilachaze: you don't keep one only best ...
06:25:39 <Axman6> > last [1..]
06:25:45 <lambdabot> Terminated
06:25:49 <Axman6> :o
06:27:42 <tobias_tud> hi, could somebody gives me something like mapM for filter? so i can write filterM?
06:28:23 <vixey> :t mapM . filter ?f
06:28:25 <lambdabot>     Couldn't match expected type `a -> m b'
06:28:25 <lambdabot>            against inferred type `[a1]'
06:28:25 <lambdabot>     Probable cause: `filter' is applied to too many arguments
06:28:54 <vixey> :t liftM filter ?p . mapM ?f
06:28:56 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m, ?f::a1 -> m b, ?p::m [b] -> a -> Bool) => [a1] -> [a] -> [a]
06:29:22 <tobias_tud> hu? :-)
06:29:44 <EvilTerran> ?type filterM
06:29:46 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:32:53 <tobias_tud> okay, thanks. is there a very efficient way to convert an int to a string?
06:33:40 <RayNbow> > show 421
06:33:42 <lambdabot>  "421"
06:34:37 <EvilTerran> ?hoogle showDec
06:34:39 <lambdabot> No matches found
06:34:42 <EvilTerran> ?hoogle showInt
06:34:42 <lambdabot> Numeric.showInt :: Integral a => a -> ShowS
06:34:42 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
06:35:29 <EvilTerran> tobias_tud, the stuff in the Numeric module is probably a bit better than the Show instance
06:35:46 <EvilTerran> but you could just use show initially and improve later if it turns out to be too slow
06:38:48 <tobias_tud> yeah, but now this is the key problem that this uses 30% of the running time
06:39:00 <tobias_tud> i'll test the numeric thing
06:39:02 <tobias_tud> thanks
06:39:15 <EvilTerran> also, it may make things faster to use something other than lists
06:39:42 <EvilTerran> depending on how many characters you're munching through, the bytestring/list speed difference might be relevant
06:43:23 <gubagem> is there a "major difference" between ghc 6.8 and ghc 6.6?
06:45:57 <eu-prleu-peupeu> gubagem: it adds 0.2 to the number...
06:46:07 <gubagem> yes i figured that would be the first answer i get
06:46:18 <gubagem> 6.6 does have nice pretty ascii art when it starts though
06:46:31 <eu-prleu-peupeu> yes, indeed
06:46:47 <eu-prleu-peupeu> they should have changed it to 8.8
06:47:04 <gubagem> why inflate the major version number like that
06:47:29 <eu-prleu-peupeu> 6.6 -> 8.8 -> 10.10
06:47:30 <eu-prleu-peupeu> whatever
06:47:45 <gubagem> > do {x<-[3..4];[1..2];return (x,42)}
06:47:46 <lambdabot>  [(3,42),(3,42),(4,42),(4,42)]
06:48:02 <gubagem> eu-prleu-peupeu: can you explain why that doubles up like that?
06:48:11 <eu-prleu-peupeu> no
06:48:17 <gubagem> I cant either
06:48:27 <vixey> > do {x<-[3..4];[1..20];return (x,42)}
06:48:29 <lambdabot>  [(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42...
06:48:58 <gubagem> I can read into it what it will return, but I do not understand the process by which it does it
06:49:00 <vixey> > do {x<-[3..4];unused<-[1..20];return (x,42)}
06:49:02 <lambdabot>  [(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42...
06:49:19 <vixey> > [3..4]>>=\x -> [1..20]>>= \unused -> return (x,42)
06:49:19 <lambdabot>  Parse error at "->" (column 13)
06:49:29 <vixey> > [3..4] >>= \ x -> [1..20] >>= \ unused -> return (x,42)
06:49:30 <lambdabot>  [(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42),(3,42...
06:49:46 <vixey> (>>=) = flip concatMap
06:50:08 <gubagem> oh oh i think i get it now its like when i map a constant to over a list of N just to get a list of constants that is N long
06:51:05 <gubagem> vixey: now that is in a do block, so it is monadic code, but which monad would it be, does it just make one up?
06:51:22 <vixey> x<-[3..4];...
06:51:29 <vixey> [3..4] is a list, so it's the list monad
06:51:44 <vixey> this is chosen by the type inference
06:51:56 <gubagem> so I couldnt use the same trick in a do block of io?
06:52:33 <vixey> :t do x <- readLine ; [1..10] ; return x
06:52:35 <lambdabot> Not in scope: `readLine'
06:52:40 <vixey> :t do x <- getLine ; [1..10] ; return x
06:52:42 <lambdabot>     Couldn't match expected type `IO t' against inferred type `[a]'
06:52:42 <lambdabot>     In the expression: [1 .. 10]
06:52:42 <lambdabot>     In a 'do' expression: [1 .. 10]
06:53:03 <vixey> :t do x <- getLine ; return x
06:53:05 <lambdabot> IO String
06:53:13 <vixey> :t do [1..10] ; return ()
06:53:14 <lambdabot> [()]
06:54:23 <EvilTerran> :t do Nothing
06:54:25 <lambdabot> forall a. Maybe a
06:54:28 * gubagem wishes his school taught haskell instead of Java
06:54:49 <vixey> if they taught haskell you'd just wish they taught java instead
06:55:23 <gubagem> I have run into the weak record syntax of haskell, its the only thing I dont like so far
06:55:40 <EvilTerran> gubagem, hit the monomorphism restriction yet?
06:55:46 <vixey> I don't like (++ "x" ++) not working
06:55:57 <gubagem> EvilTerran: no whats that?
06:55:58 <EvilTerran> or all the trouble caused by the (-) syntax?
06:56:17 <gubagem> yes I have seen that one, I find it a bit strange, but not really too bad
06:56:32 <vixey> it's horrible
06:56:37 <vixey> such an awful mistake
06:56:46 <gubagem> is there a 'fix' ?
06:56:54 <EvilTerran> gubagem, approximately, the Dreaded Monomorphism Restriction means that things that look like constants are made to be non-polymorphic unless you explicitly make them otherwise
06:56:55 <vixey> not using haskell
06:57:08 <EvilTerran> so they're properly constant
06:57:24 <gubagem> mmmm
06:57:52 <gubagem> I dont like how i can pass in field selectors of records into the nice record syntax for "mutating" the record
06:58:00 <EvilTerran> ?type sum
06:58:00 <gubagem> how i can not pass in ....
06:58:01 <lambdabot> forall a. (Num a) => [a] -> a
06:58:18 <EvilTerran> otherwise, if you said, say, "x = sum [...]", you'd end up with x :: Num a => a
06:58:30 <EvilTerran> and x would get re-calculated every time you used it. which would be bad.
06:59:18 <gubagem> EvilTerran: that is if you do not type it as forall a.?
06:59:20 <EvilTerran> you can think of a class context as being kinda like an extra parameter, if you bend your brain in the right direction
06:59:51 <gubagem> well I will bend my brain three times to the left direction and end up bending it in the right direction only requires two more brain bends
06:59:56 <EvilTerran> for instance, you could think of "foo :: Eq a => ..." as "foo :: (a -> a -> Bool) -> ..."
07:00:15 <EvilTerran> with the extra parameter being filled in for you by the typechecker
07:01:27 <EvilTerran> as a result, something which looks constant (eg, "x = sum [...]" as above) but that has a class-polymorphic type ends up having this implicit parameter, so isn't constant, so gets re-calculated everywhere
07:01:34 <gubagem> EvilTerran: your type explanations are slightly over my proverbial head
07:01:36 <gubagem> oh
07:02:12 <gubagem> EvilTerran: is there any way recalculating would be a good thing?
07:02:17 <EvilTerran> the monomorphism restriction tries to prevent this, and breaks eta-conversion in the process
07:02:43 <EvilTerran> in that "foo x = ..." will work in certain cases where "foo = \x -> ..." won't
07:03:04 <EvilTerran> gubagem, well, if you *want* the term to be polymorphic, it can be handy
07:03:41 <gubagem> EvilTerran: I am at the point of just passing state around and threading it through my mutating functions
07:05:02 <pgavin> @seen dcoutts_
07:05:02 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 1d 20h 46m 44s ago.
07:05:15 <EvilTerran> gubagem, ok, maybe <http://haskell.org/onlinereport/decls.html#sect:monomorphism-restriction> will be a little over your head at this point, then
07:05:15 <lambdabot> http://haskell.org/onlinereport/decls.html#sect:monomorphism-restriction>
07:05:19 <mattam> @type 1
07:05:21 <lambdabot> forall t. (Num t) => t
07:05:28 <EvilTerran> ?bot
07:05:28 <lambdabot> :)
07:05:33 <EvilTerran> huh
07:07:18 <EvilTerran> gubagem, anyway, it's something to be aware of. if you start getting weird type errors around something defined in a "simple pattern binding" (ie "foo = ...", with just a parameterless name on the left), it may be the monomorphism restriction causing trouble. then would be the time to learn the details, i guess
07:09:24 <gubagem> EvilTerran: Thank you for warning me of this particular pitfall /me goes back to reading 20 articles on monads
07:09:32 <litb> hello again
07:14:00 <RayNbow> gubagem, have you watched the video on monads that's on channel9?
07:14:13 <RayNbow> ( http://channel9.msdn.com/ShowPost.aspx?PostID=358968 )
07:14:50 <RayNbow> direct link to WMV (a bit more than 1 GB): http://mschnlnine.vo.llnwd.net/d1/ch9/0/Beckman_On_Monads.wmv
07:16:58 <And[y]> hi. how can i use a list comprehension to give out a list of one and the same element X times ? :>
07:17:50 <Saizan> > let x = 5 in [() | _ <- [1..x]]
07:17:51 <lambdabot>  [(),(),(),(),()]
07:18:31 <RayNbow> And[y]: but why would you use list comprehensions?
07:18:38 <RayNbow> for fun? :)
07:19:25 <And[y]> coz it seems, that i don't understand the basic function of list comprehension and wanted a practical example ;)
07:19:45 <BONUS> > take 5 . repeat $ ()
07:19:47 <lambdabot>  [(),(),(),(),()]
07:19:52 <mauke> > replicate 5 ()
07:19:54 <lambdabot>  [(),(),(),(),()]
07:19:55 <vixey> > replicate 5 ()
07:19:56 <lambdabot>  [(),(),(),(),()]
07:20:03 <mauke> list comprehensions can transform, filter and flatten lists
07:20:36 <tobias_tud> how does showInt works? showInt 3 doesn't work :-(
07:20:37 <And[y]> im quiet new to this so thanks all so far :)
07:20:50 <mauke> :t showInt
07:20:52 <lambdabot> forall a. (Integral a) => a -> String -> String
07:20:57 <mauke> > showInt 3 ""
07:20:59 <lambdabot>  "3"
07:21:02 <RayNbow> @index showInt
07:21:02 <lambdabot> Numeric
07:21:29 <tobias_tud> ah, okay
07:21:31 <mauke> why would you use showInt?
07:22:28 <tobias_tud> because show i too slow, but showInt can't produce negative integers?
07:22:40 <mauke> how is show too slow?
07:22:46 <tobias_tud> 30% of the runtime
07:23:00 <Deewiant> > showInt (-3) ""
07:23:01 <lambdabot>  "Exception: Numeric.showInt: can't show negative numbers
07:23:04 <Deewiant> O_o
07:23:28 <tobias_tud> so, i'll have to do a work around the neg. values?
07:23:43 <mauke> what is your program doing?
07:25:01 <tobias_tud> it produces a big file of integer values that is human readable
07:25:37 <pgavin> tobias_tud: are you by any chance appending these integer values to a big long string?
07:26:31 <tobias_tud> i'll tested this, too. but it seems  to be very slow, so i'll decided not to build a big string. the function takes a small list of ints and writes it to a file
07:27:45 <pgavin> tobias_tud: ok, so you're basically doing fPutStr (showInt n) on each int?
07:27:54 <pgavin> err, hPutStr
07:28:00 <pgavin> too much C :)
07:28:06 <tobias_tud> yes
07:28:10 <gubagem> RayNbow: thanks for this video link , its pretty good
07:28:28 <pgavin> hmm, show shouldn't be slow as long as you're doing it like that
07:28:37 <tobias_tud> im a noob in haskell, but the program works :-) but, a little bit too slow
07:28:51 <pgavin> can you post the code?
07:29:27 <tobias_tud> outputDisj poss handle = do    hPutStr handle $ unwords $ map show poss
07:30:07 <tobias_tud> poss = [1, 2, -3, 4, ...]
07:30:34 <RayNbow> gubagem: you're welcome :)
07:31:23 <Toxaris> I want to write a parser which is able to recover after an error (by skipping part of the input). Is this possible with Parsec / with some other parser combinator approach?
07:32:00 <pgavin> tobias_tud: that should be pretty fast
07:32:00 <Toxaris> I could write it with try in Parsec, if   getErrors :: Parser [ParserError]   would exist
07:32:19 <Toxaris> or maybe I could write it, I'm not too sure.
07:32:24 <tobias_tud> and there is no way to do it even faster?
07:32:43 <Deewiant> maybe mapM_ (hPutStrLn handle . show) poss
07:32:53 <astrolabe> Toxaris: How will you know how much input to skip?
07:33:10 <Toxaris> astrolabe: the language is designed in a way which makes this possible
07:33:32 <Saizan> just knowing that it has failed isn't enough?
07:33:52 <Toxaris> astrolabe: e.g., top-level declarations are seperated by semicolons, so when parsing a top level decl fails, I could skip up to the next semicolon
07:34:04 <astrolabe> Toxaris: Maybe have a multi-stage parser, for which only the last stage can fail?  (Like having a super-lexer).
07:34:48 <astrolabe> I guess you couldn't use parsecs errors, you'd need your own.
07:35:12 <pgavin> Toxaris: can you just break up the input on semicolons first, then run each substring through parsec?
07:35:21 <sw17ch> is there a way to ask hsc2hs (using #enum and friends) to put the constants into a data type which implements Enum?
07:35:43 <sw17ch> in c: enum {A,B,C,D,E};
07:35:51 <pgavin> sw17ch: you'd have to code out the whole datatype
07:35:58 <sw17ch> pgavin, grr... i thought so
07:36:08 <pgavin> sw17ch: :)
07:36:08 <Saizan> c2hs can
07:36:24 <Toxaris> Saizan: my goal is to output as much error information as possible, for display in an IDE, similiar to how "real compilers" handle errors
07:36:50 <sw17ch> Saizan, for some reason i was under the impression that i wasn't supposed to use c2hs any more...
07:36:58 <pgavin> sw17ch: no, not at all
07:37:12 <sw17ch> cool... :)
07:37:14 <pgavin> sw17ch: I mean, no that's not the case
07:37:22 <pgavin> yeah, go ahead
07:37:34 <sw17ch> pgavin, so what is the preferred method of doing this then... I'm building an interface to /usr/include/alsa
07:37:51 <pgavin> sw17ch: either c2hs or hsc2hs
07:38:00 <pgavin> sw17ch: they each have their uses
07:38:17 <sw17ch> pgavin, is there a way to tell which i should be using?
07:38:20 <audreyt> is there a way to derive Data.Binary.Get/Put instances that does not involve manual copy/pasting?
07:38:20 <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.
07:38:25 <pgavin> sw17ch: generally, c2hs is great for generating function prototypes
07:38:26 <audreyt> (via TH or DrIFT)
07:38:38 <pgavin> sw17ch: hsc2hs is better for lists of numerical constants, etc
07:38:40 <Saizan> audreyt: yes, see derive on hackage
07:38:53 <audreyt> k, and does that work for cyclical data?
07:39:04 <Saizan> i think DrIFT has a derivation too
07:39:14 <audreyt> DrIFT's is the old "NewBinary"
07:39:16 <audreyt> iirc
07:39:17 <sw17ch> pgavin, this is a ton of functions, a bunch of structs and a headache full of enums :)
07:39:28 <pgavin> sw17ch: just use c2hs for everything, that's best
07:39:37 <sw17ch> pgavin, excellent
07:39:37 <sw17ch> thanks
07:39:41 <Toxaris> pgavin: yeah that's what I will probably do, the top-level-decl ";" is the most important "recovering point" anyway. (but there are others, e.g. a pair of brackets can never contain another pair of brackets in my language, so I could recover at the closing bracket
07:39:49 <pgavin> sw17ch: you'll have to either write Storable instances for the structs, or use nothing but pointers
07:40:12 <sw17ch> pgavin, I'm fine with writing the Storable instances
07:40:14 <Saizan> audreyt: mmh, by cyclical you mean like "tying the know"? that appears as infinite data..
07:40:20 <sw17ch> there's a lot of structs, none of them are all that complicatd
07:40:21 <Saizan> "knot"
07:40:27 <sw17ch> ...not that a struct can be complicated
07:40:29 <pgavin> sw17ch: ok, that's good
07:40:37 <pgavin> sw17ch: one warning, c2hs doesn't play well with cabal
07:40:57 <sw17ch> as in the cabal install i just did was a bad thing?
07:40:59 <pgavin> sw17ch: you'll have to order the modules in the cabal file by their dependencies on each other
07:41:07 <sw17ch> ohh... i see
07:41:22 <pgavin> because cabal doesn't know about the .chi files etc.
07:41:38 <Saizan> yet.
07:41:43 <pgavin> Saizan: :)
07:42:08 <Toxaris> astrolabe: Yes, that's the problem: I would have to create my own error messages and my own backtracking strategy. so basically, I would write my own parser combinator library.
07:42:26 <Toxaris> astrolabe: which would probably a sensible approach to my problem, but is a bit costly for this project :)
07:43:43 <pgavin> Saizan: you should use hsc2hs wherever you need to grab #define'd constants from a header
07:43:52 <pgavin> err, sorry, that was to sw17ch :)
07:44:04 <pgavin> sw17ch: c2hs can't do those
07:44:42 <sw17ch> pgavin, well, for the #defines (if it turns out that i need them) i'll do by hand... again, not too many of them
07:44:47 <sw17ch> thanks
07:45:04 <pgavin> sw17ch: np
07:45:36 <Saizan> Toxaris: i've never used it, but http://www.cs.uu.nl/wiki/HUT/ParserCombinators has a notion of error-recovering/correction
07:46:51 <paolino> :t comparing
07:46:53 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:47:36 <paolino> is there something like that for groupBy ?
07:47:42 <paolino> :t groupBy
07:47:44 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
07:48:03 <mauke> :t on
07:48:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:48:05 <gubagem> I am getting from this video that a group is a monoid, is a ring a monoid, or should i pester #math
07:48:16 <mauke> a ring is a group
07:48:51 <paolino> :t groupBy (on length)
07:48:53 <lambdabot>     Couldn't match expected type `[a] -> c' against inferred type `Int'
07:48:53 <lambdabot>     Probable cause: `length' is applied to too many arguments
07:48:53 <lambdabot>     In the first argument of `on', namely `length'
07:49:05 <Deewiant> :t groupBy (flip on length)
07:49:06 <lambdabot>     Couldn't match expected type `Int -> Int -> c'
07:49:06 <lambdabot>            against inferred type `[a]'
07:49:06 <lambdabot>     Probable cause: `flip' is applied to too few arguments
07:49:17 <Deewiant> :t groupBy
07:49:19 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
07:49:27 <mauke> :t groupBy ((==) `on` length)
07:49:28 <Toxaris> Saizan: thanks for the pointer, I will have a look at this
07:49:29 <lambdabot> forall a. [[a]] -> [[[a]]]
07:49:47 <Deewiant> ?ty \x -> groupBy (x `on` length)
07:49:48 <lambdabot> forall a. (Int -> Int -> Bool) -> [[a]] -> [[[a]]]
07:49:52 <paolino> aha
07:57:12 <paolino> is there a way to avoid reversing a sorted list without explicitly reverse the comparing function ?
07:58:02 <paolino> ehm, s/avoid//
07:58:41 <astrolabe> > reverse [1..10]
07:58:42 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
08:01:47 <Deewiant> > sortBy (flip compare) [1..10]
08:01:48 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
08:02:28 <mauke> > sortBy ((toEnum . (2 -) . fromEnum .) . compare) [1..10]
08:02:29 <lambdabot>      The operator `.' [infixr 9] of a section
08:02:29 <lambdabot>         must have lower precede...
08:02:39 <mauke> > sortBy (((toEnum . (2 -) . fromEnum) .) . compare) [1..10]
08:02:41 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
08:02:47 <paolino> :d, ok I'm chocked
08:02:54 <sw17ch> pgavin: got c2hs working... was exactly what i was looking for. thanks again
08:02:54 <Deewiant> ?unpl ((toEnum . (2 -) . fromEnum) .) . compare
08:02:54 <lambdabot> (\ e n -> toEnum (2 - (fromEnum (compare e n))))
08:03:34 <paolino> @let uncompare = flip compare
08:03:34 <lambdabot> <local>:5:17:     Ambiguous type variable `a' in the constraint:       `Ord a...
08:03:43 <gwern> @tell SamB_XP_ hey, did you see? my zmachine bug apparently got fixed
08:03:43 <lambdabot> Consider it noted.
08:04:57 <paolino> :t on $ flip compare
08:04:59 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
08:05:51 <gwern> @tell byorgey maybe you should look into asking dons to merge his http://code.haskell.org/~dons/code/hwn into yours or redirect it or something
08:05:51 <lambdabot> Consider it noted.
08:08:54 <paolino> mmh if there are both minimum and maximum , there should be a upsort and downsort, and extremantBy alone
08:09:19 <mauke> :t maximumBy
08:09:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
08:10:29 <paolino> minimumBy f == maximumBy (flip compare `on` f ) ?
08:11:07 <Saizan> .. == maximumBy (flip f)
08:11:20 <paolino> right
08:13:49 <Deewiant> assuming f is a total ordering
08:15:08 <EvilTerran> :t (flip compare `on`)
08:15:10 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
08:15:28 <EvilTerran> :t flip . comparing
08:15:29 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:20:02 <HunterXHunterX> > curry id
08:20:03 <lambdabot>  Add a type signature
08:20:51 <Deewiant> > curry id 1 2
08:20:52 <lambdabot>  (1,2)
08:21:06 <gwern> @seen Lemmih
08:21:06 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I don't know when Lemmih last spoke.
08:21:11 <ziman> > (,) 1 2
08:21:13 <lambdabot>  (1,2)
08:21:18 <gwern> better email him then...
08:21:24 <gwern> @where xslt
08:21:24 <lambdabot> I know nothing about xslt.
08:21:28 <mauke> preflex: seen Lemmih
08:21:28 <preflex>  Lemmih was last seen on #haskell 7 days, 1 hour, 13 minutes and 42 seconds ago, saying: tobias_tud: hPutStr handle $ unwords $ map show intLst
08:22:40 * gwern will assume Lemmih's xslt is from http://darcs.haskell.org/\~lemmih/haskell-xslt/
08:23:00 <mauke> 404
08:23:18 <Deewiant> s/\\//
08:23:30 <HunterXHunterX> > curry id f g
08:23:31 <lambdabot>  Add a type signature
08:23:56 <HunterXHunterX> @type curry
08:23:58 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:25:25 <Saizan> > curry id x y
08:25:27 <lambdabot>  (x,y)
08:28:47 <And[y]> any idea what this function does and how it is called: f2 x y = [z x | z <- y] ?? :)
08:29:17 <mauke> sequence
08:29:17 <And[y]> as i said: i'm new to list comprehension ... i don't even know how to call f2 ;/
08:29:21 <Deewiant> @. pl undo \x y -> [z x | z <- y]
08:29:21 <pgavin> :t [z x | z <- y]
08:29:22 <lambdabot> (=<<) . flip flip [] . ((:) .) . flip id
08:29:23 <lambdabot>     Couldn't match expected type `[t]' against inferred type `Expr'
08:29:23 <lambdabot>     In a list comprehension: z <- y
08:29:33 <Deewiant> @ty \x y -> [z x | z <- y]
08:29:35 <lambdabot> forall t t1. t -> [t -> t1] -> [t1]
08:29:56 <pgavin> y :: [a -> b], x :: a
08:30:07 <Deewiant> @ty \x y -> map ($x) y
08:30:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
08:30:13 <mauke> And[y]: y is a list of functions
08:30:16 <Deewiant> @ty \x y -> Prelude.map ($x) y
08:30:17 <lambdabot> forall a b. a -> [a -> b] -> [b]
08:30:18 <Tobsan> @pl (x:xs) = xs ++ [x]
08:30:18 <lambdabot> (line 1, column 8):
08:30:18 <lambdabot> unexpected "="
08:30:18 <lambdabot> expecting variable, "(", operator or end of input
08:30:21 <Tobsan> oh
08:30:24 <Deewiant> @pl \x y -> Prelude.map ($x) y
08:30:24 <lambdabot> Prelude.map . flip id
08:30:44 <pgavin> :t [z x | z <- (y :: [a -> b])]
08:30:44 <Tobsan> @pl \(x:xs) -> xs ++ [x]
08:30:44 <lambdabot> ap (flip (++) . return . head) tail
08:30:46 <lambdabot>     Couldn't match expected type `[a -> b]'
08:30:46 <lambdabot>            against inferred type `Expr'
08:30:46 <lambdabot>     In a list comprehension: z <- (y :: [a -> b])
08:30:48 <mauke> > let f2 x y = [z x | z <- y] in f2 2 [id, negate, (+3), (^2)]
08:30:50 <lambdabot>  [2,-2,5,4]
08:31:08 <mauke> > let f2 = flip sequence in f2 2 [id, negate, (+3), (^2)]
08:31:09 <lambdabot>  [2,-2,5,4]
08:31:11 <And[y]> that looks complicated :D
08:31:33 <EvilTerran> > let f2 x y = [z x | z <- y] in f2 x [f,g,h]
08:31:33 <lambdabot>  Add a type signature
08:31:37 <EvilTerran> > let f2 x y = [z x | z <- y] in f2 x [f,g,h] :: [Expr]
08:31:38 <lambdabot>  [f x,g x,h x]
08:31:45 <EvilTerran> And[y], does that make it any clearer?
08:31:50 <pgavin> And[y]: map takes a function and a list of values, f2 takes a list of functions and a value
08:31:56 <And[y]> yeah, ofc. thank you :)
08:32:26 <And[y]> i didn't even knew about passing a list of functions as parameter :D
08:32:35 <mauke> functions are values
08:32:47 <pgavin> you could probably call your f2 comap
08:33:26 <And[y]> i just found this snippet on the web and was wondering about what that should do ;)
08:33:31 <mauke> > [ f 2 | f <- [id, negate, (* 3), (+ 10)] ]
08:33:33 <lambdabot>  [2,-2,6,12]
08:33:48 <mauke> pgavin: I'd just use sequence
08:34:05 <pgavin> mauke: or that :)
08:34:30 <pgavin> anyone know how to build ghc so threading works?
08:34:54 <maltem> > map ($2) [id, negate, (* 3), (+ 10)]
08:34:56 <lambdabot>  [2,-2,6,12]
08:36:27 <gwern> @tell Lemmih incoming patch for xslt. if you want, I could upload to hackage
08:36:27 <lambdabot> Consider it noted.
08:36:49 <gwern> pgavin: compile with -threaded and use +RTS -N4 -RTS on the executable?
08:36:54 <maltem> pgavin: should there be anything special to it?
08:37:17 <maltem> pgavin: Oh, you mean how to compile your program?
08:37:22 <pgavin> gwern: It keeps telling me I don't have thr libraries
08:37:56 <pgavin> umm, the ghc compile fails with that error
08:38:13 <maltem> What error?
08:38:33 <pgavin> about the thr libraries
08:39:00 <maltem> I read that, I asked what the error message is
08:39:09 <maltem> ah
08:39:11 <maltem> sorry
08:39:17 <pgavin> umm, give me a minute, I'll copy and paste the erro
08:39:41 <pgavin> I mean, I shouldn't need any special build.mk settings, right?
08:39:41 <maltem> that's "the THR libraries"?
08:39:52 <pgavin> maltem: yep :)
08:40:12 <maltem> I took it for "the libraries" first ;)
08:40:29 <pgavin> maltem: gotcha :)
08:41:14 <maltem> Now, do you have libthr?
08:41:36 <pgavin> libthr?
08:42:07 <maltem> Dunno, it's you who started this thr thing :)
08:42:20 <pgavin> oh, heh
08:42:34 <pgavin> well, you know how for profiling you have the p libraries?
08:42:52 <pgavin> you'd have libHSblah.a, libHSblah.p_a, libHSblah.thr_a, etc
08:43:56 <Igloo> pgavin: What are you trying to do, and what error are you getting?
08:44:25 <pgavin> I want to compile ghc on mac osx so that I can use it to compile threaded stuff
08:44:36 <Igloo> What do you mean by "threaded stuff"?
08:44:45 <pgavin> use +RTS -N2
08:45:01 <Igloo> You don't need threaded libraries
08:45:07 <pgavin> Igloo: ok, I thought now
08:45:09 <pgavin> *not
08:45:33 <gwern> yeah, threaded libraries don't actually exist, iirc
08:45:51 <maltem> well libHSrts_thr.a does exist, for the RTS
08:46:02 <pgavin> if I were to use an empty build.mk I'd get a threading-capable ghc, right?
08:46:04 <gwern> profiled, yes. profiled executables, yes. threaded profiled executables, ditto. but threaded or threaded profiled libraries? can't say I've heard them
08:46:17 <Igloo> pgavin: Yes
08:46:56 <pgavin> ok, well, when I try to use the resulting ghc to compile a threaded app, it isn't compiled against the threaded RTS
08:47:15 <mauke> define "threaded app"
08:47:16 <Igloo> What command are you running, and what makes you think that?
08:47:18 <Saizan> pgavin: do you use -threaded when compiling that app?
08:47:26 <pgavin> Saizan: yep
08:47:46 <Igloo> Oh, it's possible OS X doesn't support -N
08:47:49 <Igloo> Hang on
08:47:59 <Igloo> This is 6.8.3 presumably?
08:48:08 <pgavin> Igloo: well, yeah, and HEAD as well
08:48:16 <pgavin> I've had trouble with both
08:48:38 <pgavin> mauke: I want par to work :)
08:48:43 <gwern> ah, macs
08:48:51 <gwern> they're almost as much trouble as Windows
08:48:57 <pgavin> lol
08:49:09 <pgavin> at least they run unix :)
08:49:30 <mauke> just install linux
08:49:38 <gwern> a bastardized increasingly non-standard and difficult to support 'unix', I suppose
08:49:53 <Igloo> pgavin: What does   make show VALUE=GhcWithSMP   say at the root of the build tree?
08:50:07 <gwern> seriously, was Mac OS X this hard to support in the early years? when I hear all the troubles mac users have, I am put in mind of the Divine Comedy
08:50:35 <pgavin> Igloo: YES
08:50:47 <maltem> Igloo: FWIW, ghc 6.8.2 on OS X does support -N
08:51:23 <Igloo> pgavin: OK, so what command are you running?
08:52:02 <pgavin> Igloo: I'm rebuilding ghc right now, I'm going to let it finish then retry what I want to do
08:52:31 <pgavin> Igloo: then I'll paste any errors I get
09:08:01 <roconnor> > 0/0 < 0/0
09:08:02 <lambdabot>  False
09:08:09 <roconnor> > 0/0 > 0/0
09:08:10 <lambdabot>  False
09:08:53 <mauke> > 0/0 == 0/0
09:08:54 <HunterXHunterX> > 0/0 == 0/0
09:08:58 <lambdabot>  False
09:08:58 <lambdabot>  False
09:09:27 <gwern> heh. I apparently have 380 darcs repos on my computer
09:09:31 <HunterXHunterX> > 0/0 == 1/0
09:09:32 <lambdabot>  False
09:09:33 <gwern> (maybe I should clean up a little)
09:09:44 <HunterXHunterX> > 1/1 == 1/1
09:09:45 <lambdabot>  True
09:10:40 <mauke> > 1/0 == 1/0
09:10:41 <lambdabot>  True
09:11:17 <HunterXHunterX> > 0/0
09:11:18 <lambdabot>  NaN
09:11:23 <HunterXHunterX> > 1/0
09:11:24 <lambdabot>  Infinity
09:11:29 <roconnor> > 0/0 `compare` 0/0
09:11:30 <lambdabot>   add an instance declaration for (Fractional Ordering)
09:11:46 <roconnor> hmm
09:11:51 <roconnor> > (0/0) `compare` (0/0)
09:11:53 <lambdabot>  GT
09:12:58 <HunterXHunterX> > (1/0) `compare` (0/0)
09:12:59 <lambdabot>  GT
09:13:05 <HunterXHunterX> > (0/0) `compare` (1/0)
09:13:06 <lambdabot>  GT
09:13:55 <roconnor> > sort [(-1/0),(0/0),(1/0)]
09:13:56 <lambdabot>  [Infinity,NaN,-Infinity]
09:14:12 <roconnor> > sort $ sort [(-1/0),(0/0),(1/0)]
09:14:14 <lambdabot>  [-Infinity,NaN,Infinity]
09:14:24 <roconnor> > iterate sort [(-1/0),(0/0),(1/0)]
09:14:26 <lambdabot>  [[-Infinity,NaN,Infinity],[Infinity,NaN,-Infinity],[-Infinity,NaN,Infinity],...
09:14:33 <vininim> wut
09:16:08 <HunterXHunterX> wtf
09:17:07 <Deewiant> is this... unexpected somehow? :-P
09:20:55 <roconnor> I'm torn between thinking comparing NaN should be an error, or blaming the user for passing NaN.
09:21:12 <roconnor> > iterate sort [(-1/0),(0/0),(1/0)]::[[Rational]]
09:21:13 <lambdabot>  [[Exception: Ratio.%: zero denominator
09:21:33 <roconnor> returing an error may not be so unreasonable.
09:21:44 <vixey> I just realized something...
09:21:54 <vixey> there's no point in specifiying the order that pattern matching is done in
09:22:22 <vixey> oh wait _ ruins that
09:29:01 <EvilTerran> vixey, left-to-right, you mean?
09:29:47 <vixey> EvilTerran: on second thoughts, what I said was just completely wrong
09:30:34 <EvilTerran> i think it's mostly important when there may be _|_s about
09:30:44 <ddarius> EvilTerran: Of course.
09:31:34 <EvilTerran> you get different strictness semantics if you match in a different order
09:31:39 <HunterXHunterX> > iterate (+) 1
09:31:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
09:31:40 <lambdabot>     Probabl...
09:32:03 <HunterXHunterX> > iterate (++) 1
09:32:04 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
09:32:04 <lambdabot>     Probabl...
09:32:24 <ziman> > iterate (+1) 1
09:32:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:32:35 <ziman> > iterate f x
09:32:36 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
09:32:54 <mjrosenb> wait' what?
09:33:21 <mjrosenb> oh, it's taking f to be a constructor ?
09:33:40 <ddarius> :t f
09:33:42 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:33:44 <atp> no, the whole f and x thing is a convenient hack :)
09:33:44 <ddarius> :t x
09:33:47 <lambdabot> Expr
09:33:48 <HunterXHunterX> > iterate (+1) x
09:33:49 <lambdabot>  [x,x + 1,x + 1 + 1,x + 1 + 1 + 1,x + 1 + 1 + 1 + 1,x + 1 + 1 + 1 + 1 + 1,x +...
09:34:05 <atp> you can use f, g and h (i think?) as functions, and x y and z as variables
09:34:34 <mjrosenb> oh i see..
09:34:38 <mjrosenb> nice to know
09:34:47 <HunterXHunterX> > f g h x y z
09:34:47 <lambdabot>  Add a type signature
09:34:48 <atp> it's a part of lambdabot, although it's trivial to write your own Expr type that does the same thing.
09:35:47 <HunterXHunterX> @pl \f x -> g h x
09:35:47 <lambdabot> const (g h)
09:35:54 <ddarius> It's just a library that lambdabot loads.  I believe it is on hackage, otherwise you can download it from here
09:35:58 <ddarius> @where simplereflect
09:35:58 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:36:29 <HunterXHunterX> > const (g h)
09:36:30 <lambdabot>  Add a type signature
09:36:35 <mjrosenb> how did the (+1) thing work then?
09:36:52 <mauke> Num instance
09:36:55 <EvilTerran> you can use any letters as variables, but only f,g,h are polymorphic to be able to take parameters
09:37:07 <mjrosenb> i see
09:37:13 <EvilTerran> ?type x
09:37:14 <EvilTerran> ?type f
09:37:14 <lambdabot> Expr
09:37:16 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:37:17 * mjrosenb will have to play around with that
09:37:22 <vixey> @src Expr (+)
09:37:22 <lambdabot> Source not found. My brain just exploded
09:37:26 <ddarius> mjrosenb: See that blog for the details (though I think it has been slightly expanded since then)
09:37:29 <EvilTerran> ?instances-importing SimpleReflect FromExpr
09:37:29 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
09:37:32 <HunterXHunterX> @src f
09:37:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:37:37 <EvilTerran> ?instances-importing SimpleReflect SimpleReflect.FromExpr
09:37:38 <lambdabot> Couldn't find class `SimpleReflect.FromExpr'. Try @instances-importing
09:37:38 <HunterXHunterX> lol
09:37:42 <EvilTerran> bah
09:37:48 <EvilTerran> > fun "f"
09:37:49 <lambdabot>  Add a type signature
09:37:53 <EvilTerran> ?type fun "f"
09:37:55 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:38:03 <EvilTerran> ?type var "x"
09:38:05 <lambdabot> forall a. Sym a
09:38:09 <vixey> > fun "fun" :: Expr
09:38:10 <lambdabot>  fun
09:38:24 <EvilTerran> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
09:38:26 <lambdabot>  > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
09:39:11 <HunterXHunterX> nice quine?
09:39:30 <EvilTerran> ty
09:39:43 <ddarius> Not quite a quine, though it works out because EvilTerran's nick is one character longer than lambdabot's.
09:39:43 <EvilTerran> @quine
09:39:43 <lambdabot> Maybe you meant: quit quote
09:39:48 <newsham> > map (flip ($) 5) $ iterate (\f n -> if n == 0 then 1 else n * f (n-1)) id
09:39:50 <lambdabot>  [5,20,60,120,120,0,120,120,120,120,120,120,120,120,120,120,120,120,120,120,1...
09:39:54 <HunterXHunterX> oh
09:40:02 <HunterXHunterX> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
09:40:03 <lambdabot>  > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
09:40:21 <vixey> > var . ((++) <*> show) $ "x\n> var . ((++) <*> show) $ "
09:40:22 <lambdabot>  x
09:40:22 <lambdabot> > var . ((++) <*> show) $ "x\n> var . ((++) <*> show) $ "
09:40:41 <EvilTerran> ddarius, i'd argue that the leading space isn't part of the program's output, it's only put there by the bot, so it remains a proper quine
09:40:53 <EvilTerran> but then, i came up with that, so of course i'm gonna defend it :P
09:44:54 <newsham> why is the 5th element of the list for that iterate above a zero?
09:45:04 <newsham> > (map (flip ($) 5) $ iterate (\f n -> if n == 0 then 1 else n * f (n-1)) id) !! 5
09:45:06 <lambdabot>  0
09:45:15 <newsham> when the 4th and 6th are 120?
09:46:18 <newsham> oh, nevermind
09:46:41 <newsham> (because I'm using "id" for my bottom)
09:47:14 <newsham> > (map (flip ($) 5) $ iterate (\f n -> if n == 0 then 1 else n * f (n-1)) (const (-1))) !! 5
09:47:15 <lambdabot>  -120
09:47:18 <newsham> > (map (flip ($) 5) $ iterate (\f n -> if n == 0 then 1 else n * f (n-1)) (const (-1)))
09:47:19 <lambdabot>  [-1,-5,-20,-60,-120,-120,120,120,120,120,120,120,120,120,120,120,120,120,120...
09:58:42 <BONUS> man, &&& owns
09:59:30 <oldsalt> what can i do to convince ghc that a certain package is not hidden?
09:59:52 <gwern> oldsalt: I'm guessing it's a cabalized package?
09:59:52 <Zao> -package foo ?
10:00:17 <oldsalt> gwer: yes
10:00:22 <oldsalt> +n ;)
10:00:33 <oldsalt> and i reinstalled it
10:00:43 <gwern> oldsalt: ah. in that case, add the base package name to the 'build-depends:' field
10:00:47 <gwern> and which one is it?
10:00:57 <oldsalt> directory-1.0.0.0
10:01:18 * gwern meant what is the offending package which is failing to compile
10:02:17 <oldsalt> my package won't compile because ghc thinks that directory-1.0.0.0 is hidden
10:03:02 <maltem> oldsalt: The thing is, cabal hides everything by default, to make the programmer list all dependencies explicitly
10:03:23 <peter_12> I'm not a haskell programmer, I'm writing JavaScript, but I think the a group of pure-functional programmers might have the answer I'm seeking.
10:03:38 <oldsalt> maltem: that might be the right push for me
10:03:38 <peter_12> I'm working on the concepts of MVC-ish server-side web framework that is very functional.
10:03:59 <peter_12> For a blog application, one action takes submitted form parameters and sends them to a function updateArticle to validate the parameters and update a database row. What should updateArticle do if the submitted data is not valid?
10:04:25 <peter_12> I'm stumped trying to find an elegant answer to this problem
10:04:27 <EvilTerran> call an error handler callback parameter?
10:04:40 <EvilTerran> let your users decide for you :P
10:04:42 <gubagem> maybe the Maybe Monad is what you need
10:04:48 <gwern> peter_12: you mean what should the return type be? Maybe, I'd say
10:05:00 <peter_12> EvilTerran: I hadn't thought of that
10:05:28 <EvilTerran> good default beheviour would be to throw an exception, if such a thing exists in javascript (i forget)
10:05:32 <oldsalt> gwern, maltem: i forgot to add directory to the dependencies of my package. maybe is shouldn't work on sundays. thank you
10:05:38 <maltem> Maybe is misplaced if the action itself calls updateArticle, as opposed to returning something to be fed into updateArticle
10:05:49 <EvilTerran> indeed
10:05:50 <gubagem> can the user update an already posted valid blog entry?
10:05:53 <peter_12> EvilTerran: yes exceptions exist
10:06:05 <EvilTerran> "update a database row" is not a very pure-functional concept
10:06:10 <gwern> oldsalt: well, that's what I told you to do. anyway, is this package public?
10:06:26 <peter_12> gubagem: yes a user can update an article
10:06:28 <oldsalt> semi-public
10:06:51 <oldsalt> sorry for getting you wrong
10:07:07 <peter_12> gubagem: maltem: I don't know about Maybe Modad
10:07:14 <peter_12> *n
10:07:22 <gwern> aw, Maybe is like the easiest monad to use
10:07:36 <EvilTerran> i don't think it'd really make sense to use in this context
10:07:40 <gwern> I didn't even realize it was a monad until I saw people in #haskell talking about the 'Maybe monad' :)
10:08:10 <EvilTerran> given that, as there's side-effects, you'd probably end up wanting IOT Maybe :P
10:08:27 <peter_12> EvilTerran: You are right. Updating a row is not very functional but let's say that is an innocuous side effiect
10:08:35 <gwern> well, wouldn't you check for well-formedness before you went anywhere near the database?
10:09:30 <EvilTerran> peter_12, another possibility would be to seperate validating the submitted data and actually doing the update
10:09:46 <peter_12> gwern: the idea is the updateArticle function is the one gateway to the database. It *has* to validate before calling the database
10:09:55 <awesame> omg, is there no built-in factorial function in haskell?
10:10:07 <mauke> awesame: no
10:10:11 <awesame> that's just ridiculous, I'm sure I can dig up 100 implementations...
10:10:22 <ddarius> > let fac = product . enumFromTo 1 in fac 5
10:10:24 <mauke> awesame: ... so?
10:10:26 <lambdabot>  120
10:10:27 <sioraiocht> awesame: yes...
10:10:32 <EvilTerran> update = updateArticle(foo, bar, baz); if (update != null) update(); // this is how i'd be tempted to do it - have updateArticle return a function, or null if the parameters aren't valid
10:10:34 <hackage> New package: hgeometric 0.0.2
10:10:34 <hackage> New package: haskell-in-space 0.1.1
10:10:37 <gwern> bikeshed, meet awesame. awesame, bikeshed.  perhaps you'd like to discuss aesthetics
10:10:54 <EvilTerran> ?where factorial
10:10:54 <ddarius> You rarely need the actual factorial function.
10:10:54 <lambdabot> I know nothing about factorial.
10:11:00 <mauke> s/rarely/never/
10:11:03 <EvilTerran> peter_12, how does that approach sound?
10:11:07 <ddarius> @where evolution
10:11:08 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
10:11:10 <Deewiant> > let fac = product . enumFromTo 2 in fac 5 -- faster ;-)
10:11:11 <lambdabot>  120
10:11:14 <EvilTerran> ddarius, ah, that's the one
10:11:22 <awesame> gwern: that wasn't about aesthetics, it was a joke
10:12:18 <awesame> I went to compute a factorial and thought it was funny that I actually needed to write a factorial function in a functional language for a real-world project
10:12:33 <EvilTerran> peter_12, all the validation would happen in the body proper of updateArticle, and then the body of the returned function would just do the update
10:12:35 <peter_12> EvilTerran: I'm not sure the benefit with your suggestion but it is interesting. The issue is if the parameters are not correct then the server response should be a page with the error messages displayed.
10:12:59 <peter_12> EvilTerran: why not just have updateArticle call the function you are suggesting it returns?
10:13:06 <EvilTerran> if you're going so high-level as "display an error page", we'd need much more background knowledge
10:13:08 <gwern> awesame: you know I was referring to the famous freebsd 'painting the bikeshed' email right, and understood the implied criticism of including any particular factorial in base libraries?
10:13:26 <EvilTerran> peter_12, well, you could just return a boolean indicating success or failure
10:13:32 <EvilTerran> i was just thinking about it in a haskell-y way
10:14:03 <peter_12> EvilTerran: why does returning a boolean not mesh with the haskell-y way?
10:14:16 <awesame> gwern: wait, so you were saying that picking a fact implementation would be a disaster?
10:14:33 <gwern> well, if the bool is False, does that mean it didn't validate, or that it failed to successfully make it to the database?
10:14:42 <mauke> gwern: yes
10:14:54 <EvilTerran> peter_12, well, in haskell, i'd be tempted to have updateArticle return a Maybe (IO ()), ie Nothing (null) if the parameters are bad, or a little bundle of side-effects with no interesting return value (an IO ()) if the parameters are ok
10:15:02 <gwern> awesame: basically. there's so damn many ways to write it with so many different characteristics, any implementation would displease someone
10:15:17 <gwern> mauke: see, that's what I mean...
10:15:21 <EvilTerran> peter_12, while returning Bool would translate into updateArticle returning an IO Bool
10:15:43 <EvilTerran> peter_12, it makes a difference in haskell, as, in the Maybe version, i know *no* side-effects happened if i get back Nothing
10:16:25 <EvilTerran> peter_12, while, if i'm getting back an IO Bool, that's a bundle of side effects that yield a Bool when run
10:16:40 <peter_12> EvilTerran: ok
10:16:57 <EvilTerran> but it doesn't matter in javascript. just return a bool or something, it's simpler :P
10:17:31 <peter_12> I've been thinking updateArticle would throw an error object with messages about what is invalid
10:17:43 <peter_12> otherwise return true
10:18:02 <peter_12> and all side effects are in a database transaction so it is all or none
10:18:05 <ddarius> Why would it return true?  Would it ever return false?
10:18:22 <peter_12> ddarius: no. I suppose it could return undefined
10:18:30 <hcube> hi, how can i import a void f() C function in haskell via FFI ?
10:18:41 <hcube> i use ghc
10:18:48 <ddarius> @where ffi
10:18:49 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:20:39 <hcube> there is no void type in ffi
10:21:27 <Cale> hcube: Use ()
10:21:48 <Cale> Like Foo -> Bar -> IO ()
10:21:48 <hcube> i've found something in ffi doc
10:22:15 <Cale> Or if it's  void f (), that would be IO ()
10:27:33 <nburlett> wtf: haskell-src-1.0.1.2 depends on haskell-src-1.0.1.2 which failed to install.
10:27:48 <mjrosenb> erm
10:28:11 <Saizan> nburlett: that's a roundabout way to tell you there was a problem installing it
10:28:35 <Saizan> because in general the two packages could be different
10:29:00 <nburlett> Saizan: on odd error message. Any ideas on what to do to fix it?
10:29:19 <nburlett> I did "cabal upgrade cabal" to get it
10:29:47 <EvilTerran> i guess "haskell-src-1.0.1.2 (which) failed to install" is the important bit of that message
10:29:48 <Saizan> it didn't report any errors earlier?
10:30:17 <nburlett> oh, I see the error now! cabal: The program happy is required but it could not be found
10:30:49 <nburlett> it was buried in a bunch of other output
10:32:11 <nburlett> although, cabal install happy gives me "not in scope: `buildVerbose'"
10:34:11 <Saizan> compiling Setup.lhs?
10:34:47 <nburlett> yes
10:36:05 <gwern> yeah, dependencies on executables like happy or alex is a known infelicity of cabal
10:36:16 <gwern> there's an open bug report if you want to contribute your thoughts, btw
10:37:29 <nburlett> gwern: I currently have two thoughts... One, it should work. Two, The cleveland airport sucks
10:37:36 <nburlett> ok, the second one is not related
10:37:56 <Saizan> nburlett: that buildVerbose error means the Setup.lhs is not compatible with your version of cabal
10:38:06 <gwern> well, knowing that it's biting people is a useful thing to add
10:38:07 <Saizan> i think
10:38:13 <gwern> bonus points if what was bitten was a noob
10:38:54 <nburlett> Saizan: ah. Well, since it came up when I was trying to upgrade cabal, that doesn't seem helpful :->
10:39:02 <nburlett> gwern: I'm not a _complete_ noob :->
10:39:32 <Saizan> nburlett: which version do you have?
10:39:47 <nburlett> cabal-install version 0.4.6
10:39:48 <nburlett> using version 1.5.1 of the Cabal library
10:40:12 <gwern> is cabal-install supposed to work with 1.5.1?
10:40:29 <nburlett> dunno, I thought it did in the past
10:40:45 <Saizan> gwern: well, 1.5.1 and 1.4 are not that different
10:40:50 <gwern> I remember dcoutts warning me they were going to do breaking changes for 1.5.1, and that when cabal-install specified 1.4 - It Were Serious Dependency; I are Serious Cabal
10:41:03 <nburlett> basically, I'm trying to get some work done on my personal machine while I'm stuck in the airport
10:41:07 <nburlett> hold on, brb...
10:42:13 <nburlett> grr, doesn't look like i"m making it on standby for this flight
10:42:14 <Saizan> nburlett: i'd ghc-pkg hide any 1.5.* Cabal version you might have installed and retry installing happy, that way Setup.lhs should be compiled against a stable release and work
10:42:59 <gwern> nburlett: I missed a flight once. I was on standby for 3 flights, and barely made it home the same day. that was a bad day.
10:44:01 <Heffalump> the one time I missed a flight I had an expensive business-class ticket so it didn't matter much
10:44:16 <nburlett> well, I'm just trying to get on an earlier flight
10:44:19 <Heffalump> though I ended up at the wrong London airport
10:44:27 <nburlett> Heffalump: oops
10:45:01 <Heffalump> well, at least it was the right city :-)
10:45:11 <nburlett> Saizan: should I use download happy manually for this?
10:45:26 <gwern> hm, this is weird.. the hxt darcs repo has no cabal file, yet it is on hackage
10:46:24 <Saizan> nburlett: that's not required, but if you download it manually you can ghc --make -package Cabal-1.2.3.0 instead of hiding the other packages
10:46:40 <Saizan> ghc --make -package Cabal-1.2.3.0 Setup.lhs, i meant
10:46:47 <nburlett> ok
10:47:14 <Saizan> and then use that executable for the rest, of course
10:49:18 <nburlett> ok, it's happier now
10:49:19 <nburlett> thank you
10:49:23 <nburlett> (no pun intended)
10:49:56 <Saizan> heh :)
10:51:34 <nburlett> gah, now I get Package mtl is required by several packages, but they require inconsistent versions
10:52:07 <nburlett> *sigh* I should just give up for now
10:52:28 <mjrosenb> is there any way to read in the contents of a file in ghci and not have it print the contents to the terminal?
10:52:38 <vixey> you weren't trying to use software, were you? :o
10:52:51 <vixey> it's all broke
10:53:23 <gwern> mjrosenb: sure
10:53:27 <sjanssen> mjrosenb: :set -fno-print-bind-result
10:53:35 <gwern> readFile "/etc/passwd" >> return (), is the most obvious
10:53:51 <gwern> since printing the result () is no printing, effecitvely :)
10:54:05 <mjrosenb> gwern: i want to bind the data to a variable
10:54:14 <mjrosenb> so sjanssen seems to have a better solution
10:55:01 <gwern> mjrosenb: then you could do 'let foo = readFile "/etc/passwd"'
10:55:11 <gwern> and you'd see nothing until you called foo, obviously
10:55:37 <mjrosenb> right, but that binds foo to an IO [string]
10:55:40 <mjrosenb> not a string
10:56:15 <sjanssen> gwern: or he could just use -fno-print-bind-result
10:56:20 <gwern> sure, but that's what readFile returns, an IO String, not a String
10:56:34 <gwern> sjanssen: yeah, but then he'd not understand all the neat and wonderful stuff of ghci...
10:56:52 <nburlett> well, I'm going to try to board this flight and see what happens
10:56:53 <nburlett> cya
10:57:08 * gwern is still a little sore at ghci for allowing unrestricted function calls
10:57:08 <sjanssen> gwern: "let f = readFile ..." and "f' <- readFile ..." are not the same thing
10:57:52 <gwern> yes,,,
10:57:52 <sjanssen> gwern: in the first, f is bound to an IO action that will read a file if executed
10:58:17 <sjanssen> gwern: in the second, f' is bound to the result of the file read
10:58:33 <gwern> a local definition, and the latter a lambda variable, yes
10:59:04 <sjanssen> lambda isn't really involved here
10:59:38 * gwern thought the do desguared to the monad functions, and the monad functions to lambda definitions, but whatever
10:59:47 <vixey> (x <- y; ...) = (y >>= \x ->...)
11:00:18 <vixey> (let y = x; ...) = ((\y ->...)x)
11:00:53 <vixey> no that's wrong
11:01:14 <vixey> can't replace let with lambda
11:01:59 <ddarius> You can sometimes
11:02:35 <atp> you can't generally?
11:02:47 <atp> in scheme let is just a macro around lambda i thought
11:02:58 <vixey> scheme isn't typed
11:03:01 <vixey> > (\id -> (id 3, id "foo")) (\i -> i)
11:03:02 <lambdabot>   add an instance declaration for (Num [Char])
11:03:13 <vixey> > let id = (\i -> i) in (id 3, id "foo"))
11:03:14 <lambdabot> Unbalanced parentheses
11:03:33 <atp> hm, interesting
11:03:40 <vixey> > let id = (\i -> i) in (id 3, id "foo")
11:03:42 <lambdabot>  (3,"foo")
11:04:27 <vixey> oh ddarius, does lollymon have any coinductive features?
11:04:33 <vixey> lollimo
11:04:39 <vixey> I was reading about coLP
11:05:13 <ddarius> Not explicitly.
11:05:17 <ddarius> No.
11:05:22 <vixey> seemed interested but I didn't really see any practical uses (yet)
11:07:04 <nburlett_> oh well, that didn't work
11:48:56 * byorgey grills lambdaburgers
11:48:56 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
11:49:29 * tusho grills byorgey 
11:49:40 <byorgey> ouch!
11:49:46 <byorgey> or do you mean the inquisition kind?
11:49:57 <tusho> both
11:50:00 <tusho> simultaneously
11:50:08 <EvilTerran> i didn't expect that
11:50:29 <jfredett> this isn't blah, you too, keep the naughty bits out. :/
11:50:48 <EvilTerran> it's not like you guys were using it :P
11:51:04 <jfredett> :)
11:51:13 <byorgey> @seen dons
11:51:13 <lambdabot> dons is in #haskell, #xmonad, #ghc, #arch-haskell and #haskell-soc. I last heard dons speak 27m 33s ago.
11:51:30 <vixey> what's the point in explicit substitutions?
11:51:49 <EvilTerran> in what context?
11:52:13 <vixey> like dealing with a functional languages syntax
11:53:18 <EvilTerran> as in "((\x.E) E') evaluates to (E[x\E'])" kinda thing?
11:53:44 <EvilTerran> (the [x\E'] bit. aka [E'/x], [x |-> E'], ...)
11:54:03 * byorgey can NEVER keep that straight
11:54:24 <EvilTerran> the part over the "fraction" overwrites the other bit
11:54:28 <EvilTerran> is how i remember it
11:54:36 <byorgey> ah, OVERwrites
11:54:40 <EvilTerran> yes :D
11:54:41 <byorgey> I like that =)
11:55:11 * vixey writes (X-->Y) and says that wherever Y was, X will be now
11:55:17 <dcoutts> @seen pgavin
11:55:17 <lambdabot> I saw pgavin leaving #haskell 2h 30m 4s ago, and .
11:55:45 <vixey> (except with the usual capture avoid rules)
11:55:46 <EvilTerran> although i hear at least one of our lecturers does it the other way, that seems to be fairly standard convention
11:56:06 <EvilTerran> (and that meant the course textbook was wrong too, seeing as he wrote the thing)
11:59:46 <EvilTerran> when I saw [x |-> E] used, i think the "x |-> E" part was that lecturer's notation for an anonymous function, with the | indicating that any partial bits of the function get replaced by id
12:01:34 <EvilTerran> and then the []s were meant to be a catamorphism-brackets-esque notation for fmap
12:01:49 <dblhelix> any lattice-theory experts in the house?
12:01:56 <EvilTerran> which i thought was really quite clever
12:02:37 <EvilTerran> so he'd write "((\x.E) E')  --eval->  [x |-> E']E"
12:04:33 <And[y]> how do i transform a string to a list, where every char is one element? :>
12:04:41 <vixey> id
12:04:47 <vincenz> vixey: evil
12:05:02 <Botje> And[y]: id!
12:05:14 <EvilTerran> ?src String
12:05:15 <vixey> vincenz :p
12:05:15 <lambdabot> type String = [Char]
12:05:16 <Botje> a String is already defined as a list of characters
12:05:20 <And[y]> > id "123"
12:05:21 <lambdabot>  "123"
12:05:23 <Botje> > take 4 "cookies"
12:05:24 <lambdabot>  "cook"
12:05:38 <vixey> > ['1','2','3'] == id "123"
12:05:39 <lambdabot>  True
12:05:41 <vixey> > ['1','2','3'] == "123"
12:05:42 <lambdabot>  True
12:06:01 <EvilTerran> map show "123"
12:06:04 <EvilTerran> > map show "123" -- err
12:06:05 <lambdabot>  ["'1'","'2'","'3'"]
12:06:23 <And[y]> ok, i guess i understand, thank you :)
12:06:28 <EvilTerran> although what lambdabot said is the most important bit - that comes straight out of the h98 report
12:06:38 <vixey> > (++"]") . ("["++) . intercalate "," . map show $ "123"
12:06:40 <lambdabot>  "['1','2','3']"
12:07:01 <vixey> > read .(++"]") . ("["++) . intercalate "," . map show $ "123"
12:07:02 <lambdabot>  Exception: Prelude.read: no parse
12:07:19 <EvilTerran> types default to ()
12:07:26 <joey``> > read .(++"]") . ("["++) . intercalate "," . map show $ "123"
12:07:26 <joey``> (20:06:28) (lambdabot) Exception: Prelude.read: no parse
12:07:27 <lambdabot>  Exception: Prelude.read: no parse
12:07:29 <EvilTerran> > read .(++"]") . ("["++) . intercalate "," . map show $ "123" :: String
12:07:31 <lambdabot>  "123"
12:07:31 <joey``> Bah.
12:08:24 <EvilTerran> @check (==) -- this is also why quickcheck seems to think all values are equal
12:08:26 <lambdabot>  OK, passed 500 tests.
12:08:52 <vixey> randomized testing is dangerous
12:09:04 <vixey> @check \x y -> x * y == 36574
12:09:04 <EvilTerran> it is if you accidentally end up with a sample size of 1
12:09:05 <lambdabot>  Falsifiable, after 0 tests: 2, -1
12:09:08 <vixey> @check \x y -> x * y /= 36574
12:09:09 <lambdabot>  OK, passed 500 tests.
12:09:10 <joey``> @check (==) :: Int -> Int -> Bool
12:09:11 <lambdabot>  Falsifiable, after 0 tests: 1, -2
12:09:12 <vixey> @check \x y -> x * y /= 36574
12:09:13 <lambdabot>  OK, passed 500 tests.
12:09:28 <EvilTerran> @vixen is 36574 prime?
12:09:29 <lambdabot> first you tell me.
12:09:32 <vixey> you will never scratch the surface of possible bugs with randomized testing
12:09:43 <EvilTerran> i agree
12:09:48 <joey``> Is an even number prime?
12:09:53 <vixey> 2
12:10:00 <sjanssen> @smallcheck \x y -> x * y /= 36574
12:10:00 <lambdabot> Unknown command, try @list
12:10:02 <Heffalump> vixey: you can find a surprising number that way, though
12:10:06 <sjanssen> @scheck \x y -> x * y /= 36574
12:10:07 <lambdabot>   Completed 169 test(s) without failure.
12:10:10 <vixey> Heffalump, heeh
12:10:19 <EvilTerran> that's why i like the sound of languages with built-in totality proofs and such
12:10:20 <sjanssen> hmm, only 169 tests?
12:10:40 <vixey> EvilTerran: the sound, but not the ...?
12:10:55 <EvilTerran> syntax... would that be taste?
12:11:07 <EvilTerran> given "syntactic sugar" as a phrase
12:11:20 <Heffalump> it's a nice idea, but it's very hard work to actually write the proofs as you go, IME (with using GADTs to enforce that kind of property)
12:11:36 <vixey> hey if you design a good one today it could be very influencial :)
12:12:19 <EvilTerran> i might look at it for my finals project.
12:12:49 <EvilTerran> i've always wanted my own programming language :P
12:13:42 <vixey> nn :)
12:16:30 <atp> hey vixey, i was thinking about your lambda/let example ... if you recall you used (\id -> (id 3, id "foo")) (\i -> i) as an example to show why lambda isn't sufficient for let in typed languages.  but what if you specify that the argument id is polymorphic?  is there some way around that with existential types?
12:17:11 <atp> like (\id :: (forall a . a -> a) -> (id 3, id "foo")) (\i -> i) or something?
12:18:14 <EvilTerran> atp, indeed, that's the point of rank n types
12:18:37 <atp> right, so assuming you have rank-n types, isn't let actually just sugar for lambda then?
12:18:48 <atp> because ddarius and vixey were saying it wasn't generally
12:19:09 <EvilTerran> you nearly got the syntax right, too - that should be (\(id :: forall a . a -> a) -> ...)
12:19:19 <EvilTerran> i think, in that case, it is
12:20:03 <atp> yeah, i hadn't actually tried it, i just had the thought
12:20:15 <EvilTerran> it just isn't true in the general case of any typesystem applied to the lambda-calculus
12:20:32 <atp> hm...
12:20:37 <atp> so there's still a counterexample then?
12:20:40 <EvilTerran> eg, one without rank n types
12:20:45 <atp> oh, i see.
12:20:56 <EvilTerran> sorry, that was a bit incoherent
12:21:04 <atp> because it's pretty elegant in scheme anyway how let is just a macro around lambda
12:21:21 <atp> but let is a keyword in GHC core,
12:21:29 <atp> which makes me think that it isn't that simple
12:21:40 <EvilTerran> there's other differences too
12:21:49 <EvilTerran> > let (x,y) = undefined in "ok"
12:21:50 <lambdabot>  "ok"
12:22:00 <EvilTerran> > (\(x,y) -> "ok") undefined
12:22:01 <lambdabot>  "Exception: Prelude.undefined
12:22:09 <atp> ah
12:22:11 <atp> but
12:22:18 <EvilTerran> > (\ ~(x,y) -> "ok") undefined
12:22:19 <lambdabot>  "ok"
12:22:21 <atp> right
12:22:24 <atp> i was just going to do that
12:22:25 <EvilTerran> *that* makes them the same
12:22:33 <Botje> EvilTerran++ # now I finally get why ~ exists!
12:22:37 <atp> so let is a lazy lambda then
12:22:42 <EvilTerran> i had it in my chat history - i had an unfair advantage :P
12:22:52 <atp> :)
12:23:10 <EvilTerran> effectively, yes, it's a lazy lambda, but one where the parameter has to be there as well
12:23:31 <atp> how do you mean?
12:24:22 <EvilTerran> (\var -> body) param == (let var = param in body)  - you need to specify what would be the parameter to the lambda immediately in the let syntax
12:24:39 <atp> ah, i see what you mean.
12:24:41 <EvilTerran> there's no equivalent to just (\var -> body)
12:25:00 <atp> right, but i guess i meant that you could always desugar (let var = param in body) into a lambda expression
12:25:29 <EvilTerran> in some type systems
12:25:29 <pgavin> @seen dcoutts_
12:25:30 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 2d 2h 7m 11s ago.
12:25:30 <atp> although... there's still the whole let/letrec thing
12:25:43 <mattam> Not before typechecking and let-generalization.
12:26:07 <atp> mattam: explain?
12:26:10 <mattam> Core's lambda is Sytem F's lambda right?
12:26:15 <atp> yeah.
12:26:22 <atp> at least, afaik.
12:27:01 <mattam> Well, you can't transform lets to lambdas before doing HM generalization as let-in's are treated specially.
12:28:13 <atp> i guess what i'm really looking for is a concrete example of when one cannot desugar
12:28:36 <atp> i don't doubt that that's the case
12:28:40 <atp> i'm just curious as to when
12:28:42 <mrd> for polymorphic binding
12:28:50 <swiert> atp: let id x = x in (id 3, id 'c')
12:28:51 <mattam> That's what you were talking about just before. (\id -> (id true, id "false")) (\x -> x) is not typable. let id x = x in (id true, id "false") is.
12:29:19 <dcoutts> pgavin: sorry, I'm just heading out, unless you're v. quick! :-)
12:29:19 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
12:29:30 <atp> (\(id :: forall a . a -> a) -> (id 3, id "foo")) (\i -> i) should work, shouldn't it?
12:29:44 <EvilTerran> that's not System F any more
12:29:51 <mrd> it's not rank1
12:29:52 <atp> ah.
12:29:53 <EvilTerran> you've gone along one of the edges of the lambda cube
12:29:54 <pgavin> no, I got your patch & applied it
12:30:08 <mrd> System F should be ok with that though
12:30:10 <pgavin> theres a rc of the release on code as well
12:30:26 <dcoutts> pgavin: so I see, good work!
12:30:34 <mrd> modulo appropriate insertion of type lambdas and applications
12:30:59 <mattam> Certainly System F is, but GHC's typechecker?
12:31:10 <mrd> maybe with extensions? :)
12:31:16 <pgavin> dcoutts: thanks, I'll give a couple days for people to test the rc, then announce the actual release after that
12:31:56 <atp> i guess my thesis is: if you have rank-n polymorphism in your type system and lazy pattern matching, then let can be generally desugared to a pure lambda expression
12:31:57 <EvilTerran> h98 does not include forall.s - there's an implicit one around the outside of every type signature
12:32:00 <atp> or rather hypothesis
12:32:02 <EvilTerran> so no rank n types
12:32:06 <atp> right, i know
12:32:27 <atp> but let's talk about GHC haskell :)
12:32:38 <mrd> EvilTerran: ok, but you said System F, not h98
12:33:02 <EvilTerran> i think i agree about your thesis. your conditions are sufficient, if perhaps not necessary
12:33:13 <atp> hm...
12:33:22 <atp> i think it would be more fun if i were wrong though :p
12:33:24 <pgavin> speaking of which, does anyone here have ghc-6.8.3 installed on windows?
12:34:04 <atp> pgavin: doesn't seem like it
12:34:17 <pgavin> atp: ?
12:34:37 <EvilTerran> mrd, my bad. i'd forgotten what exactly system-f was exactly
12:34:51 <atp> is there a good system f reference floating around, apropos?
12:34:59 * EvilTerran deletes one "exactly"
12:35:08 <mrd> exactly one exactly
12:35:19 <mrd> atp: tapl? :)
12:35:27 <atp> tapl?
12:35:42 <EvilTerran> ?where tapl
12:35:42 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:35:50 <mrd> atp: it's simply the terms involving lambdas, application, type-lambdas, and type-application and the forall-type, and function-type
12:36:08 <atp> seems like a good thing to understand better than i do
12:36:30 <atp> oh, a book.  is this worth the purchase?
12:36:33 <mrd> yes
12:36:43 <atp> hm, i'll go ahead and order it then.
12:36:46 <mattam> Proofs and Types by Girard & al too.
12:36:48 <atp> thanks for the pointer
12:37:04 <And[y]> @src ord
12:37:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:37:23 <mrd> Harper discusses it too, free book: http://www.cs.cmu.edu/~rwh/plbook
12:37:25 <lambdabot> Title: Index of /~rwh/plbook
12:38:26 <atp> i've actually been looking for a good dead-tree reference on type theory
12:38:49 <atp> i like books
12:39:08 <mrd> TAPL would be the place to start
12:39:28 <atp> ok.  i'll order it on amazon right now! :p
12:39:29 <pgavin> heh, I just bought that book
12:39:32 <pgavin> good one
12:39:35 <atp> you like it?
12:39:52 <pgavin> yes, it's easy to understand and comprehensive
12:40:10 <EvilTerran> And[y], http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#ord ;)
12:40:11 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yqjxlq
12:40:38 <pgavin> also, this one is good: http://www.amazon.com/Abstract-Computing-Machines-Calculus-Perspective/dp/B000VHVT1G/
12:40:41 <lambdabot> http://tinyurl.com/5ranvc
12:41:16 <pgavin> the author goes over about a dozen abstract machines for lambda calculus programs
12:42:49 <pgavin> the g-machine is in there, but not the stg machine
12:46:56 <And[y]> ah, thanks :D
12:52:46 <And[y]> @src iterate
12:52:46 <lambdabot> iterate f x =  x : iterate f (f x)
12:53:37 <And[y]> ok, that makes sense :)
12:54:25 <shepheb_> anyone know the LaTeX for the bananas, lenses, envelopes and barbed wire? (and do they work on WordPress?)
12:56:01 <mrd> stmarysrd pkg might have them
12:57:25 <mrd> you can probably obtain the symbols by combining others and using math spacing.  i don't know what wordpress supports.
12:59:29 <mrd> http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf
12:59:30 <lambdabot> http://tinyurl.com/5583t
12:59:31 <mrd> enjoy
13:03:37 <shepheb_> mrd: I'm doing a bit of a Haskell translation of key parts of Bananas,...; so I'll just use a Haskell-style notation anyway
13:03:53 <mrd> yea it's more modern to say fold, unfold, i think anyhow
13:10:05 <hansfbaier> anyone with experience in building lambdabot?
13:12:52 <tusho> hansfbaier: i
13:12:59 <tusho> 'm an accredited lambdabot builder professional
13:13:02 <tusho> :-P
13:15:07 <hansfbaier> tusho: just trying to get the deps together.
13:15:19 <hansfbaier> tusho: there seems to be an error in the ./build script.
13:15:24 <tusho> sorry, I don't actually know
13:15:29 <tusho> your working just amused me :(
13:15:33 <tusho> i'm sure someone knows though
13:23:06 <shachaf> What is this "Haskell Hall" thing?
13:28:03 <edwardk> shepheb: i usually just use negative spacing between the appropriate symbols
13:28:40 <edwardk> cata = (| |) ana = [( )] para = <{  }> hylo = [[ ]], etc.
13:29:27 <edwardk> shepheb: what parts are you translating?
13:29:53 <mrd> i'm not sure if wordpress supports \!
13:32:24 <dons> shachaf: it is PR Stanley's fork of -cafe@ after getting moderated last week
13:32:45 <edwardk> forking cafe, what?
13:32:47 <dons> rather than stop calling people nazis, he set up his own list.
13:32:51 <Heffalump> oh, he got moderated?
13:32:56 <Heffalump> I assumed he'd just finally piped down.
13:33:10 <dons> the worst email got moderated, and he stopped sending after that
13:33:15 <edwardk> ah i just saw the message
13:33:35 <Heffalump> if you know that it's him for sure, could you post to say that?
13:33:48 <dons> ok. i do know for sure.
13:34:02 <dons> http://www.freelists.org/list/haskell
13:34:03 <lambdabot> Title: FreeLists / Haskell Hall
13:34:09 <dons> click on the archives
13:34:18 <dons> http://www.freelists.org/archives/haskell/06-2008/
13:34:19 <lambdabot> Title: FreeLists / haskell / 06-2008
13:34:31 <Heffalump> he's also the guy that posts lots of clueless questions, right?
13:34:37 <dons> yep
13:34:51 <dons> oh, i deleted his email.
13:36:11 <dons> anyone got qtHaskell installed?
13:36:13 <dons>  http://sourceforge.net/projects/qthaskell/
13:36:25 <dons> i keep forgetting it exists. sourceforge is like a blackhole for haskell stuff
13:36:38 <jcreigh> haha, one post.
13:36:45 <TomMD> What? A Haskell project that is open and not on Hackage?  Thats a sin!
13:36:59 <dons> well, it is easy to forget about things not in the central repo
13:37:12 <dons> i'd wager qthaskell hasn't been distroised anywhere yet
13:37:15 <ddarius> "If it's not on hackage, it doesn't exist."
13:37:27 <dons> and cabal install won't work, so that's a big penalty.
13:37:57 <dons> at a minimum, you'd make something like the haskell.org/gtk2hs site, to build some kind of community
13:42:35 <sandbox> is there a way to pack a Char8 literal at compile time?
13:42:53 <dons> yeah, just pack "foo" :: ByteString will work
13:43:09 <dons> compile with -ddump-simpl-stats and look for the pack/packAddress rule to fire
13:43:23 <sandbox> okay, thanks
13:44:06 <Botje> I thought bytestrings would support GHC 6.8's fromString interface?
13:44:27 <dons> they do, also
13:44:32 <dons> if you use LANGUAGE OverloadedStrings
13:44:43 <Botje> oh, it's an extension
13:44:47 <Botje> i see
13:53:20 <sandbox> @hoogle packAddress
13:53:20 <lambdabot> Data.ByteString.Unsafe.unsafePackAddress :: Addr# -> IO ByteString
13:53:21 <lambdabot> Data.ByteString.Unsafe.unsafePackAddressLen :: Int -> Addr# -> IO ByteString
13:53:31 <sandbox> where is packAddress?
13:59:32 <dons> Data.ByteString.Unsafe..unsafePackAddress
14:00:05 <dons> {-# RULES
14:00:05 <dons> "ByteString pack/packAddress" forall s .
14:00:05 <dons>    pack (unpackCString# s) = inlinePerformIO (B.unsafePackAddress s)
14:00:05 <dons>  #-}
14:00:21 <dons> you shouldn't need to use it explicitly, as pack "foo" wil lfire it
14:00:32 <sandbox> I see, thanks again
14:03:20 <Botje> @hoogle inlinePerformIO
14:03:21 <lambdabot> Data.ByteString.Internal.inlinePerformIO :: IO a -> a
14:04:35 <Botje> ah
14:04:47 <Botje> for those that wondered, it's the same as unsafeperformio, but it tells GHC it's okay to inline
14:12:37 <dons> so not ok if you allocate, since it will be much easier to duplicate work, or potentially reorder operations
14:17:51 <vininim> Is there any distro-independent hackageDB dependency resolver/fetcher?
14:17:52 <jekor> When I {-# OPTIONS_GHC -fglasgow-exts -lavformat #-} I get a link error (using ghc --make), but if I add -lavformat on the commandline (ghc -lavformat --make file.lhs), it works. Am I doing something wrong?
14:18:13 <mauke> vininim: like cabal-install?
14:20:52 <Botje> jekor: i'm guessing because GHC doesn't know it's supposed to pass that -l option to the linker oto
14:20:55 <Botje> *too
14:22:52 <vininim> mauke: exactly, thanks!
14:22:59 <jekor> Weird. Is there somewhere I can read more about the linking process?
14:25:21 <Botje> the GHC users guide, i assume
14:25:26 <jekor> Thanks.
14:51:25 <sw17ch> I'm trying to build a c2hs file for the alsa libraries. While c2hs is mostly clear, i'm curious what i'm supposed to do about declared, but undefined structs. Any one have any insight?
14:52:01 <Saizan_> anyone knows where i can download "Monads for incremental computing" Carlsson 2002? i find only broken links
14:52:24 <dons> hmm. i work with magnu carlsson..
14:52:54 <Cale> sw17ch: Usually on the Haskell side, the trick went something like  newtype Foo = Foo (Ptr Foo),  iirc.
14:53:31 <sw17ch> typedef struct _snd_pcm snd_pcm_t;
14:53:39 <sw17ch> _snd_pcm isn't defined anywhere in the header files afaik
14:53:40 <sw17ch> :)
14:53:56 <dons> no acm account, Saizan_ ?
14:54:19 <Saizan_> no :\
14:54:33 <olsner> my university has a proxy-like thing for ACM; maybe yours has too
14:54:53 <Saizan_> well i probably just have to wait for citeseer to work again
14:56:29 <sw17ch> Cale: you don't have any specific reference do you?
14:57:45 <Saizan_> sw17ch: if it's not defined you just have to pass pointers of that type between functions, right?
14:58:23 <Cale> sw17ch: well, it's been a while since I touched the FFI or c2hs... How is that type used? If it's like Saizan says, the example I gave is a good representation on the Haskell side of things.
14:58:24 <sw17ch> Saizan_, this ffi stuff is very new to me :) so i'm not sure... i'm working through it a little slow
14:58:36 <sw17ch> it's only ever used as a pointer
14:59:15 <sw17ch> or a double pointer
14:59:52 <Saizan_> yeah, that's what i meant
15:00:09 <Cale> Right, so you can, if you want, use the punny recursive  newtype SndPCM = SndPCM (Ptr SndPCM)
15:00:23 <Cale> and that ought to be allowed in FFI import decls.
15:00:32 <sw17ch> neato, i'm sure i'll be back
15:00:34 <sw17ch> thanks
15:00:51 <Cale> and it'll ensure that you don't get things mixed up with other pointer types that way
15:01:33 <sw17ch> oh duh, the example is just a little farther down the page...
15:01:43 <sw17ch> {#pointer *GtkObject as Object newtype#}
15:02:33 <Cale> Yeah, that probably makes one of those automatically for you :)
15:05:54 <sw17ch> Cale: one more... this is also still on the same page... what about a **ptr?
15:06:24 <Cale> Well, you can probably do the same thing with two stars.
15:06:48 <sw17ch> well, that makes sense.. .since i managed to forget the stars in the first set i did... wow i'm on top of things today
15:15:50 <OceanSpray> Is there any way to "partially" compile a haskell program?
15:17:06 <OceanSpray> For example, if the compilation of a module requires the use of some of the functions and data that it defines?
15:20:49 <roconnor> Heffalump: thanks for your response re: ethical investing.
15:22:05 <byorgey> OceanSpray: I don't think so.
15:22:28 <OceanSpray> well, shit.
15:22:46 <byorgey> OceanSpray: what exactly are you trying to do?
15:22:49 <byorgey> maybe you can use TH?
15:23:16 <byorgey> TH comiles things in 'stages' so you can have compilation of some parts depend on functions and data defined by other parts
15:23:29 <OceanSpray> I'm trying to do something very similar.
15:24:41 <OceanSpray> Liskell is dead.
15:24:45 <OceanSpray> no movement.
15:24:54 <OceanSpray> So I thought I'd try something.
15:25:17 <OceanSpray> Write a Lisp syntax -> Haskell compiler
15:25:52 <OceanSpray> with macros that are essentially Haskell functions :: List -> List
15:26:07 <OceanSpray> but then I'd need to RUN those functions to compile,
15:26:28 <OceanSpray> but I need to compile before I can RUN.
15:26:44 <OceanSpray> so, it's pretty much impossible without some serious plumbing work.
15:28:43 <byorgey> sounds scary ;)
15:29:20 <byorgey> well, you can poke around in the GHC API, but I wouldn't get your hopes up.
15:29:31 <OceanSpray> maybe I can fake it.
15:30:17 <OceanSpray> "extract" some code, run ghci on it, use to expand some macros.
15:30:21 <OceanSpray> wash, rinse, repeat.
15:30:58 <OceanSpray> But that seems VERY ugly.
15:40:17 <TomMD> Heres a (perhaps new) idea: rss2cabal-install
15:40:48 <dons> heh, auto install anything new?
15:41:05 <dons> well, it'd be a buildbot wouldn't it?
15:41:14 <dons> TomMD: btw, you visiting this week or next?
15:41:24 <dons> maybe we can do some infrastructure hacking!
15:41:40 <monochrom> @type foldr
15:41:42 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:53:02 <TomMD> dons: I'll be in next week.
15:53:19 <dons> sweet.
15:54:19 <tobias_tud> somebody there who know me?
15:54:23 <OceanSpray> I'll be in my bunk.
15:57:55 <dons> gwern: around?
16:03:08 <scodil> is there a way to get ghc-core to parse and beautify a core file I've already made? (ping dons)
16:03:31 <dons> scodil: intersting. no.
16:03:41 <dons> well, there's always a way, but it involves programming
16:03:55 <scodil> its just that this compilation is taking a long time and I don't need to see the object code generated
16:03:59 <scodil> but its no biggie
16:04:44 <sutats> Would Haskell work well for writing an operating system?
16:05:04 <scodil> someone tried that i think
16:05:11 <scodil> is trying?
16:05:16 <sutats> I know some exist, like House and Kinetic.
16:05:29 <sutats> But I'm just curious as to how well they work.
16:05:51 <scodil> depends on your definition of "well"
16:06:06 <scodil> unlikely to surpass linux or bsd, ever, simply as a function of effort
16:06:16 <dons> they are used in a small number of commercial systems, for niche high assurance domains
16:06:18 <scodil> but I'm sure they've got some neat features
16:06:39 <sutats> So probably won't see it on the desktop soon, if at all?
16:07:03 <scodil> hah! you'll be lucky to see lots of haskell _apps_ on the desktop soon.
16:07:14 <dons> as an alternative to linux? no, of course not. but as something you might buy if you have particular security problems, yes, perhaps.
16:07:33 <dons> scodil: write some more code then!
16:07:38 <scodil> hey I'm doing my part
16:07:40 <dons> the revolution begins here, with code. written by us.
16:07:42 <sutats> dons: What's stopping it, if anything?
16:08:02 <sutats> Lack of interest? Or is there a technical issue too?
16:08:08 <monochrom> think of why people chose Windows.
16:08:24 <sandbox> A group wrote a formally verified micro-kernel in haskell and is now rewriting it in C, so I assume there are still some performance issues
16:08:26 <dons> sutats: nothing. like i said, i work at a company that sells things that use haskell kernel components
16:08:37 <OceanSpray> The Revolution Will Not Be Blogged.
16:08:52 <dons> sandbox: right, the verified kernels are typically for embedded domains
16:08:52 <sandbox> just due to the ugly (but usually fast) style C promotes
16:08:55 <dons> where resources are tight.
16:09:21 <dons> so you implement an executable model in haskell, then translate (or extract) C from that, for example
16:09:29 <scodil> but there's no reason you couldn't do that in haskell, right? Foreign gives you all the same tools as C
16:09:57 <sutats> Is the performance hit that noticeable?
16:10:40 <hackage> New package: hgeometric 0.0.2.1
16:10:40 <hackage> New package: frag 1.1.1
16:10:40 <povman> sandbox: is this the NICTA group?
16:10:42 <dons> scodil: right. i'm of the view you can do anything you need to, and the FFI is there as a backup
16:10:54 * monochrom blinks at hackage
16:11:12 <dons> monochrom: is that ok?
16:11:17 <sandbox> I'm not actually sure, just some mention of it on the hurd mailing list
16:11:25 <monochrom> It's new magic :)
16:11:29 <dons> it's a tiny tool i wrote, rss2irc, an rss gateway for irc
16:11:52 <dons> i figure a cloud of niche bots is a more scalable approach than hacking lambdabot endlessly
16:11:57 <monochrom> amazing magic
16:12:27 <monochrom> Yes, verily.
16:12:31 <povman> what haskell needs is a screencast
16:12:57 <povman> that's how ruby took off
16:13:09 <ddarius> One day there will be more bots in this channel than people.
16:13:11 <Associat0r> sutats systems haskell
16:13:43 <Associat0r> google "systems haskell"
16:13:55 <monochrom> I disbelieve in screencasts. Saw one promoting J or K, what a waste of time, 10 minutes of watching the guy typing code key-by-key that could easily be read in under 1 minute.
16:13:59 <byorgey> dons++ # hackage bot =)
16:14:19 <scodil> screencasts show off dev environments, not languages
16:14:24 <byorgey> monochrom: that sounds like a particularly poor example of a screencast...
16:14:25 <kpreid> what scodil said
16:14:39 <monochrom> The guy compared Java to J or K. The part where he hijacked your time to watch him type out the verbose Java code totally sucked.
16:14:45 <povman> well, it needs a 'killer app' :)
16:14:51 <lament> for a while i thought monochrom meant the j/k navigation keys in Vi
16:14:59 <byorgey> dons: think the hackage bot should quote a bit of the package synopsis too?
16:15:14 <scodil> screen casts should echo the keyboard like subtitles
16:15:29 <scodil> so you can see how fast people are typing
16:15:33 <dons> byorgey: not a bad idea at all
16:15:40 <scodil> and what crazy emacs macros their cheating with
16:15:43 <scodil> they're
16:15:48 <sutats> Associat0r: Thanks, I'll look into it.
16:16:09 <byorgey> dons: just the name and version doesn't tell me much, if I don't already know what the package is/does
16:16:18 <dons> good point.
16:16:28 <monochrom> Moreover, due to today's limit on user interfacing over video players, screencasts (and generally all videos) are practically unnavigatible.  Unlike hyperlinked web pages where you can glance, you can jump, you can skip, you control your pace.
16:16:36 <shachaf> Maybe a URL would be nice.
16:16:38 <Associat0r> sutats : you could also look at bit-c but that is no haskell
16:17:05 <Associat0r> http://www.bitc-lang.org/
16:17:05 <lambdabot> Title: The BitC Programming Language
16:17:06 * monochrom totally disbelieves in videos.  Completely one-dimensional.
16:17:17 <shachaf> (That was addressed a dons, sorry.)
16:17:22 <dons> it is a pity we don't have a general purpose irc bot library yet
16:17:31 <scodil> monochrom: that and we nerds typically have nasal, irritating voices. Makes for terrible narration. Print is definitely best.
16:17:34 <dons> elliottt was working on one, though, so maybe we'll have one this week.
16:17:49 <povman> umm
16:18:03 <byorgey> dons: oh, also, could you put a note in your hwn repo pointing to mine instead?  c.h.o/~byorgey/code/hwn
16:18:22 <dons> yep
16:18:22 <byorgey> dons: gwern was confused earlier as to why there were two repos
16:18:29 <dons> yes
16:18:42 <sutats> Associat0r: Ah, safety of Haskell with speed closer to that of C?
16:18:53 <byorgey> I've already changed links on the HWN wiki page and so forth
16:19:19 <dons> ok. i changed the motd of the cse one.
16:19:26 <byorgey> cool, thaks
16:19:29 <byorgey> thanks, even
16:19:42 <Associat0r> sutats: http://felix-lang.org/ is also interesting
16:19:43 <lambdabot> Title: Felix | The Smart Upgrade from C++
16:20:02 <povman> can someone explain this: Preserve mutability as a first-class notion in the language. Monads, effect types, and the like are wonderful things, but languages that rely on them have yet to demonstrate acceptable performance on systems problems.
16:20:34 <lament> mutability as a first-class notion??
16:20:41 <povman> no, what makes monads slow?
16:20:43 <lament> first-class "mutability particles"?
16:20:44 <dons> povman: hmm, it is arguing for easy mutability
16:20:53 <dons> i guess like ST or FFI monads allow.
16:21:33 <dons> there is a misconception in there that monads somehow only emultate mutability, rather than allowing true mutation
16:21:40 <dons> which is false. (e.g. ST or IO)
16:21:48 <povman> their argument is that they allow pure evil into their language because monads are 'slow'
16:21:52 <byorgey> huh? how does an effect typing system have anything to do with performance?
16:21:55 <dons> since ST allows true mutation with raw machine access.
16:22:07 <dons> povman: yes, that makes no sense.
16:22:16 <scodil> well, to be fair, reference cells aren't the same as mutable values
16:22:17 <dons> povman: but people don't understand monads, so well, sigh.
16:22:35 <povman> then... what's fast about bitc?
16:22:38 <dobblego> people don't understand the evility of side-effects either
16:22:43 <dons> scodil: ST allows raw access to the machine, (not just STRef)
16:22:52 <dons> so you could write a device driver in ST.
16:23:01 <dons> and it really would be doing much the same as the C version
16:23:06 <dons> ptr arithmetic and all
16:24:31 <byorgey> "my cursory inspection of this thing I don't understand clearly shows that it is not yet as fast as possible.  therefore it is bad."
16:25:00 <povman> if i write a fast function in c and translate it to ST, how close will ghc get to the original?
16:25:08 <povman> or is that too vague
16:26:38 <scodil> depends on a few things. how much allocation you do is probably the most important. IMO if you can eliminate all heap usage, you can be within 100%-150% of C fairly easily
16:26:53 <scodil> using unboxed arrays for everything gets you almost there
16:28:31 <mmorrow> scodil: did that thing you were compiling with the huge unfolding threshold ever finish compiling?
16:28:41 <scodil> HAH I'm trying to get a core file right now
16:28:47 <scodil> its taking _forever_
16:28:47 <mmorrow> haha
16:28:57 <mmorrow> what is is?
16:29:00 <dons> povman: ST should produce pretty much identical code.
16:29:03 <scodil> the core files last night were like 80K lines
16:29:06 <mmorrow> s/is/it/
16:29:44 <sandbox> why does haskell use 32 bit strings instead of something like utf16?
16:30:00 <sandbox> I'm fairly new so I may just be missing something obvious
16:30:06 <scodil> mmorrow: its a vector math library, with some linear algebra stuff. The program I'm compiling now just inverts 3mil. 4x4 matrices of doubles.
16:30:06 <povman> maybe it's worth properly haskell'ing this MPEG decoder :)
16:30:25 <dons> sandbox: it uses 32 bit Char to represent unicode code points
16:30:48 <mmorrow> scodil: heh
16:31:01 <Associat0r> dons what about the garbage collector where will you leave that?
16:31:30 <sandbox> why did they choose that over something like utf16 though?
16:32:01 <sandbox> or does it have utf16 support?
16:32:20 <dons> Associat0r: leave it?
16:32:43 <Cale> sandbox: utf16 is an encoding
16:32:47 <Associat0r> if you want identical C code
16:32:48 <scodil> mmorrow: for simple stuff like adding vectors, matrix multiplication and determinants, it unfolds into closed-form expressions and goes really fast. But this gaussian elimination has some branches and I think that hindering the optimization. But I can't tell if I can't get it to write a core file
16:33:00 <dons> Associat0r: if it doesn't allocate on the heap, the GC isn't involved.
16:33:17 <dons> so if the C code doesn't malloc, nor should the haskell need GC.
16:33:30 <Cale> sandbox: Char is supposed to represent an arbitrary unicode codepoint abstractly.
16:33:35 <Associat0r> but what about size?
16:33:49 <Associat0r> the GC is still there right but idle?
16:34:04 <Cale> (so it's really encoding independent)
16:34:16 <sandbox> ah, thanks
16:35:15 <mmorrow> scodil: did you  write this linalg library? if not which/what/where is it? i'd be interested in checking it out.
16:35:53 <scodil> Yeah I wrote this. It doesn't do much. Just what you need for 3d graphics.
16:36:05 <Associat0r> dons: ?
16:36:32 <mmorrow> scodil: cool. what are you doing with 3d graphics?
16:37:17 <scodil> I hope to release it once I can get this gaussian elimination working reasonably. If I set the unfolding threshold high enough (like 999) it takes only twice as long as C. But thats kind of high to ask.
16:37:17 <dons> Associat0r: oh, you mean the runtime? yes. the GC is part of the runtime, so its linked in.
16:37:49 <mmorrow> scodil: have you checked out the hmatrix package or the new blas package? (i haven't used to blas package for anything other than messing with it but plan to).
16:37:57 <Associat0r> how hard would it be to strip it out?
16:38:14 <dons> Associat0r: hard, to impossible
16:38:19 <dons> since its a key part of the runtime.
16:38:20 <scodil> Yeah I've used hmatrix back when it was called hgsl. Its nice. But something feels wrong about using it for 3x3 and 4x4
16:38:27 <dons> so it'd be a port to a new runtime, effectively.
16:38:35 <scodil> I'm used to C++ where you can make really nice templated matrix types. Trying to do the same thing in a haskelly way
16:38:53 <dons> scodil: i'd love to see a nice version of the n-body implementation on the shootout
16:38:58 <dons> its begging for a decent vector type
16:39:11 <mmorrow> scodil: sounds fun, good luck
16:39:12 <dons> we take heat from the MLers for beating them with low level code
16:39:45 <shachaf> Which is somewhat reasonable, I think.
16:40:13 <dons> given how good ghc is with data Vector = Vector !Double !Double !Double (3 FP registers)
16:40:22 <dons> its a good time to look again at some of those gunky old entries
16:40:26 <dons> bring them up to scratch
16:41:03 <thoughtpolice> like fannkuch perhaps? :)
16:41:06 <scodil> I use a list type, data (:.) a b = !a :. b, so a 3d vector is like Double :. Double :. Double :. (). I write all the functions like list functions, using type classes. And then I have pack/unpack to create these things from an optimized type like you suggest, dons. It works well. Abstract function specifications with type and dimension-specific instances.
16:41:17 <scodil> but there's ALOT of fundep programming. Might be a turnoff to some.
16:42:21 <dons> that's a strange type. i wonder what the runtime presentation you end up with is.
16:42:34 <scodil> its awesome, if i don't say so myself.
16:42:49 <dons> monomorphic strict product types are the safest bet, since they're guaranteed to unbox into and out of a function
16:42:59 <dons> leaving you with tight register only loops that don't allocate.
16:44:11 <scodil> Let me paste some core... hold on
16:45:00 <ddarius> Associat0r: You may find the language Virgil interesting.
16:45:42 <RayNbow> hmm... http://www.reddit.com/r/programming/info/6of7m/comments/c04fz5i <-- wxHaskell doesn't build anymore?
16:45:44 <lambdabot> Title: programming: Real World Haskell: ten new draft chapters - GUIs, concurrency, web ...
16:45:50 <hpaste>  dons pasted "register only loops" at http://hpaste.org/8473
16:45:53 * RayNbow managed to build it a few months ago
16:46:05 <ddarius> whew, the estimated minutes remaining is ticking down faster than seconds.
16:46:24 <mofmog> i'm looking over my data structure's class's textbook on data structures... in java
16:46:25 <RayNbow> (it took a lot of effort though, since I had to try out several wxWidget versions until I found one that worked)
16:46:30 <mofmog> my eyes have already glazed over
16:46:58 <Associat0r> ddarius : thanks but that is not a FP
16:47:00 <mofmog> "DO this stupid thing in java to do something extra useless"
16:47:06 <Associat0r> FPL
16:49:10 <ddarius> Associat0r: FP isn't relevant to the issues you are talking about.  It's the difference between high-level and low-level code.  Further, many of the techniques used in Virgil could no doubt be used in FPLs.
16:49:56 <povman> mofmog: does it really say that? you might want a different book
16:51:20 <Associat0r> ddarius : but it still uses a CG right?
16:52:59 <dons> RayNbow: i think it does, i just can't build it. there's enough new packages that i imagine someone's building it.
16:53:08 <povman> Associat0r: "Thus a Virgil program can easily run without an operating system, a scheduler, or a garbage collector."
16:53:50 <hpaste>  scodil pasted "multiply 4x4 matrix of doubles" at http://hpaste.org/8474
16:54:00 <Associat0r> ah thanks
16:55:08 <mofmog> povman: it's a required text -_-
16:55:19 <mofmog> i wish the department would just make us buy the knuth set
16:55:23 <mofmog> so i can have an excuse for buying it
16:55:24 <povman> :p i was kidding anyway
16:55:37 <scodil> dons: check out the core there on that paste
16:55:49 <dons> looks good!
16:55:55 <mofmog> last semester's text was SICP. The decline in quality between the texts is oddly perceptible...
16:56:09 <dons> -O2 -fvia-C -optc-O2 -fexcess-precision and I'd expect good asm
16:56:31 <dons> scodil: you going to put it under a good name? Data.Vector.Something ?
16:56:44 <povman> wow
16:57:02 <dons> scodil: the unboxed return is excellent
16:57:50 <Associat0r> I'd rather use something like bitc then
16:57:55 <Associat0r> "Because BitC needs to be compilable in a non-colleted mode (subject to language restrictions), it is strongly desirable to stack-allocate continuations. "
16:57:58 <scodil> I'm still fidgeting with the gaussian elimination. If I can get that to run smoothly without ungodly unfolding thresholds, I'll upload it
16:58:03 <kfish> mofmog, complain to your department, there's no excuse for teaching with java
16:58:08 <Associat0r> povman
16:58:15 <dons> scodil: i'd be happy to look over it before you release.
16:58:21 <dons> we need more good numerics/arrays options.
16:58:22 <scodil> I'm telling you its nasty
16:58:32 <povman> hm
16:58:34 <scodil> TONS of classes and instances with fundeps
16:58:35 <dons> all the more reason to have some eyes
16:59:02 <dons> well, make sure there's some examples in the haddocks then
16:59:07 <povman> is it possible to eliminate the GC through analysis?
16:59:15 <povman> ie is it not impossible?
16:59:33 <scodil> can you tell haddock not to list instances? if not then it will be of no use to me. Too much noise.
16:59:48 <dons> you can hide arbitrary things
16:59:56 <dons> the key step is to have some api docs and examples on hackage
16:59:58 <dons> or its a black box
17:00:11 <ddarius> povman: Impossible in general, but you could make a conservative analysis.
17:00:18 <dons> kfish: btw, hogg needs an update to build with split-base
17:00:22 <dons> want a patch?
17:00:44 <povman> ddarius: is there a paper?
17:00:53 <dons> kfish: Codec/Container/Ogg/Chain.hs:15:17:
17:00:53 <dons>     Could not find module `Data.ByteString.Lazy':
17:00:53 <dons>       it is a member of package bytestring-0.9.1.0, which is hidden
17:00:58 <dons> povman: look at region inference
17:01:06 <dons> and some papers by Appel, Tofte et al on region inference
17:01:10 <ddarius> povman: There are many different analyses you could perform
17:01:46 <RayNbow> <dons> RayNbow: i think it does, i just can't build it. <-- but you're not running Windows, right?
17:02:00 * RayNbow has only tried building wxHaskell under Windows
17:02:17 <dons> RayNbow: right. i think its workign on windows. conal uses it there.
17:02:25 <dons> its failing, right at the end , with wxgtk on linux
17:03:47 <RayNbow> the only problem I have with Haskell is building the damn packages... it reminds me of dependency hell :p
17:03:58 <povman> RayNbow: cabal-install
17:03:59 <dons> RayNbow: cabal install
17:04:04 <povman> jinx
17:04:07 <RayNbow> :p
17:04:14 <dons> the whole thing is designed for auto dep resolution
17:04:21 <dons> so if you're not using that, you're doing it wrong :)
17:04:29 <RayNbow> I haven't downloaded cabal-install yet
17:04:41 <RayNbow> but I'm postponing it till I have the time to upgrade to GHC 6.8.3 :p
17:05:11 <RayNbow> (currently busy with other stuff)
17:05:19 <dons> do not delay! cabal install cabal-install today!
17:06:02 <povman> pff, if only you didn't have to install cabal, http, zlib (etc?) to get it in the first place
17:06:39 <sandbox> hackport :)
17:06:40 * RayNbow is good at delaying things... don't do/execute/evaluate/etc. things until it's necessary... :p
17:06:52 <dons> povman: what distro are you on?
17:07:00 <povman> *shame
17:07:04 <dons> if cabal-install isn't available in binary form for you distro, then you know who to talk to.
17:07:19 <povman> ok i'll do that
17:07:55 <dons> basically, minimal haskell support for a distro *must* be: ghc, core libs, extra libs, cabal 1.4.x , cabal install
17:08:04 <dons> anything less than that is substandard, and not accredited
17:08:19 <thoughtpolice> i've got cabal-install installed, but I really, amazingly, incredibly hate the whole 'multiple bytestrings are installed and built against each other thing', a lot.
17:08:31 <thoughtpolice> does cabal 1.4/cabal-install 0.5 fix that, for the most part?
17:08:39 <dons> thoughtpolice:so that you can solve by installing ghc, then upgrading bytestring, then upgrading cgi.
17:08:42 <dons> done.
17:09:07 <dons> you get better warnings, and more things build. really, either don't upgrade bytestring, or upgrade it, and rebuild things that use it.
17:09:15 <thoughtpolice> dons: still, it can be a hassle when you might want to use bytestring and the GHC API. I've also naturally had issues with hs-plugins
17:09:23 <dons> ghc-api is an issues, yes.
17:09:33 <thoughtpolice> that's really the only thing I'm worried about
17:09:41 <thoughtpolice> other than that cabal-install == win, for sure. :)
17:09:43 <dons> luckily bytestring is stable now, so it won't be an issue in the next release of ghc
17:09:51 <thoughtpolice> yay. :)
17:10:57 <gubagem> > do {x<-[1..3];y<-[1..3];return (x,y)}
17:10:59 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
17:11:11 <thoughtpolice> dons: since I don't think I'll run into that issue as much in the next few days I might run a full cabal-upgrade; that particular thing is the only thing that worries me
17:11:15 <gubagem> thats the cartesian product correct?
17:11:20 <thoughtpolice> luckily older packages will still exist, at least...
17:11:58 <dons> kfish: can we get a hogg 0.4 on hackage please? 0.3 won't build
17:12:30 <dons> kfish: also, a request, remove ListMergeTest from the .cabal file (enable it onl ywith a flag(debug), since it doesn't make sense to install that into user space
17:13:06 <ddarius> gubagem: Yes.
17:13:14 <ddarius> > liftM2 (,) [1..3] [1..3]
17:13:15 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
17:13:28 * gubagem goes whoaaaa
17:14:04 <povman> :t liftM2
17:14:05 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:14:15 <povman> :t liftM
17:14:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:14:18 <dons> what's liftM2 (,) in Arrows?
17:14:46 <thoughtpolice> also, has anybody notified the haddock maintainer that it's not working with GHC 6.8.3? slightly annoying, that.
17:14:57 <gubagem> wait a second, so  , is a function/operator?
17:14:59 <dons> :t liftM2 (,)
17:15:02 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:15:08 <dobblego> ?type (,)
17:15:09 <ddarius> gubagem: It's a constructor.
17:15:10 <lambdabot> forall a b. a -> b -> (a, b)
17:15:44 <povman> > (,) 1 2
17:15:46 <lambdabot>  (1,2)
17:17:50 <gubagem> so how would i do (,) 1 2 3?
17:18:00 <gubagem> to make a 3tuple
17:18:05 <povman> (,,) 1 2 3
17:18:10 <povman> > (,,) 1 2 3
17:18:12 <lambdabot>  (1,2,3)
17:18:49 <povman> > (,,) 1 2 3 :: (,,) Int Int Int
17:18:51 <lambdabot>  (1,2,3)
17:19:00 <scodil> I know people have asked before, but is there any kind of superinlining pragma? Something like "really really really inline it always and inline anything that inlines it." I get 3x speedup if I use -funfolding-creation-threshold=999, but that's a big hammer.
17:21:10 <dons> {-# INLINE #-} plus unfolding
17:21:25 <scodil> That's it, huh.
17:22:00 <dons> that's it.
17:22:17 <dons> look at how uvector does it
17:22:27 <dons> its designed to be entirely inlined and specialised
17:22:32 <scodil> Ok well, with reasonable unfolding its 3x slower than C. With max unfolding its 20% slower than C, but takes about 100x longer to compile. I guess I can just put that in the comments. "If you REALLY need speed, use -funfonding-use-threshold=999, or just bind to C"
17:23:22 <dons> use flag(fast) perhaps
17:23:24 <dons> in the .cabal file
17:23:32 <dons> so the user would say, cabal install mylib -ffast
17:23:48 <scodil> I still have to read up on cabal
17:24:28 <dons> the uvector library has a n example of a conditional flag like this
17:25:21 <scodil> I'm still pretty stoked with 20% slower than C. I had forgotten about all that -fvia-C voodoo. That made a big improvement.
17:27:29 * atsampson checks the time in Samoa...
17:27:31 <dons> yeah, that's good, scodil
17:28:08 <ivanm> is there a guide somewhere on how to properly use the resources on code.haskell.org?
17:28:26 <dons> there's some advice on the wiki
17:28:57 <ivanm> oh? all I could find was the link to create an account :s
17:31:44 <byorgey> ivanm: look on community.haskell.org
17:31:53 <byorgey> there's some information there
17:31:55 <ivanm> oh, wait, under "how to use your project"?
17:31:58 <byorgey> yup
17:32:14 <ivanm> OK.... just have to wait for my project to get approved then :p
17:32:21 * ivanm somehow missed that link before :s
17:33:32 <byorgey> atsampson: submitting a paper? =)
17:37:13 <atsampson> byorgey: that's the plan, although at the moment "rewriting" may be a more accurate verb
17:37:23 * RayNbow slaps himself
17:37:26 <byorgey> atsampson: well, good luck =)
17:37:31 * RayNbow almost blew up his virtual memory again...
17:38:30 <atsampson> thank you ;)
17:38:39 <monochrom> how could you blow up your virtual memory? it is not physical...
17:39:10 <ivanm> monochrom: a virtual bomb?
17:39:23 <gubagem> someone set us up the bomb
17:39:40 <ivanm> indeed
17:39:42 <monochrom> "The virtual I virtually blew up my virtual memory."
17:40:12 <RayNbow> monochrom: fear my skills to blew up virtual stuff :p
17:40:20 <RayNbow> *blow
17:40:35 <monochrom> virtual fear, virtual skill
17:40:50 <ivanm> RayNbow: OK, you're good at blowing up virtual stuff? blow up all of Java's good parts... :p
17:41:21 <RayNbow> :p
17:41:49 <gubagem> ivanm: what Java has good parts?
17:42:39 <monochrom> haha
17:58:19 <RayNbow> hmm, has anyone tried cracking http://projecteuler.net/index.php?section=problems&id=197 yet?
17:58:20 <lambdabot> Title: Problem 197 - Project Euler
17:58:56 <RayNbow> simply trying to compute it won't do as it would take a lot of time
17:58:59 <Zao> I see they scale rather hard in difficulty.
17:59:20 <RayNbow> and as an added bonus, u_1000 == u_10000 when you lack precision :p
17:59:29 <byorgey> RayNbow: I solved that one
17:59:41 <byorgey> RayNbow: it's actually not that hard, I suggest you play around with it a bit more =)
17:59:42 <Zao> I'll bruteforce it on my TI-83+ :P
17:59:43 <atp> which one was that?
18:00:12 <atp> oooo
18:00:14 <kfish> dons: re: hogg, noted, thanks :-) patch would be good too ;-)
18:00:15 <atp> that looks like fun
18:01:15 <RayNbow> byorgey: lemme guess... I probably should get a pencil and a piece of paper? :p
18:01:17 <dons> kfish: patch not needed. 0.4.0 looks ready
18:02:06 <atp> that doesn't seem too difficult actually.
18:03:12 <kfish> dons: ah, for splitBase, yeah
18:03:28 <RayNbow> oh great, someone broke reddit :p
18:03:40 <RayNbow> (ah, n/m, it's up again...)
18:03:54 <ddarius> I'll have to try harder next time.
18:07:48 <ivanm> gubagem: that was kind of my point... it only have "virtual" good parts :p
18:15:32 * dolio chuckles.
18:16:45 <vininim> Why are Arrows called "generalization of Monads" if they are equivalent in power?(Or are they?)
18:16:54 <mauke> they are less powerful
18:17:11 <dolio> There are things that are arrows but not monads, but not vice versa.
18:17:21 <mauke> more general = less power
18:18:25 <dolio> That may not be true given the Idioms/Arrows/Monads paper Wadler and company recently produced.
18:18:44 <dolio> Depending on how you define "general" and "power" of course.
18:24:39 <povman> mauke: if you can define monads in terms of arrows, doesn't that make them at least as powerful?
18:25:01 <mauke> can you?
18:25:06 <adu> hi
18:25:25 <adu> I uploaded Yi.app
18:25:34 <povman> adu!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
18:25:46 <adu> hi povman
18:26:18 <adu> whats with (repeat '!')?
18:26:47 <povman> i got really excited thinking you'd suddenly updated hoc
18:26:56 <adu> o
18:27:00 <adu> no not yet
18:27:05 <ddarius> Monads give rise to arrows.
18:27:11 <dolio> That was only replicate 36 '!'
18:27:17 <adu> just playing around with an .app wrapper
18:27:48 <mauke> values of β will give rise to dom!
18:28:35 <adu> povman: but I'm working on it
18:30:43 <adu> what exactly do [t| ... |] and [d| ... |] mean?
18:30:58 <dolio> They're template haskell.
18:31:00 <byorgey> I think that's template Haskell syntax
18:31:09 <adu> ic
18:31:17 <dolio> [t| ... |] turns whatever's inside to the appropriate representation of the type in template haskell.
18:31:23 <dolio> [d| ... |] reifies declarations.
18:32:00 <dolio> [| ... |] does expressions.
18:32:06 <dolio> There may be more, I'm not sure.
18:32:33 <adu> can you have assignments in side these [?| ... |]
18:32:49 <dolio> Assignments?
18:33:25 <hpaste>  adu pasted "Assignments" at http://hpaste.org/8475
18:33:39 <dolio> If the quasiquoting goes in, I guess there will be something like [:foo| ... |], too, where you can define your own translation.
18:34:05 <dolio> Not necessarily related to template haskell, other than the syntax.
18:34:34 <dolio> Oh, well in Haskell, 'foo = bar' is a declaration.
18:34:46 <adu> o wait, that is a declaration...
18:34:53 <adu> ok i see
18:34:57 <dolio> You're giving the name foo to the expression bar. It's not an assignment like in C or something.
18:35:17 <adu> i know how it works, I'm just bad with terminology
18:35:19 <povman> adu: TH is missing lots if niceness, you're better off using Language.Haskell.TH.* to make templates
18:35:46 <povman> *of
18:36:05 <mauke> no, off
18:36:13 <adu> mauke: if => of
18:36:19 <mauke> oh
18:36:27 <mauke> I didn't even see that :-)
18:36:31 <pgavin> is there any way to find out what lines of code a CAF in the profiler output corresponds to?
18:36:48 <mauke> my internal word scanner is pattern-based
18:43:15 <hpaste>  morrow pasted "comment from jhc/E/TypeCheck.hs" at http://hpaste.org/8476
18:46:00 <povman> is it just me or does the 'remember me' box on hpaste not work at all?
18:46:18 <pgavin> no, it doesn't work for me either
18:46:25 <dolio> It's never worked for me.
18:46:32 <povman> lol
18:47:13 <dolio> Huh, jhc allows unboxed tuples as arguments.
18:48:43 <mmorrow> check out the src, it's nice: http://repetae.net/repos/jhc
18:48:43 <lambdabot> Title: Index of /repos/jhc
18:49:04 <ddarius> It's never worked.
18:49:10 <mmorrow> hehe
19:04:51 <hpaste>  Haegin pasted "ghc-pkg list" at http://hpaste.org/8477
19:06:20 <dolio> @remember qwe1234 i know haskell, ocaml, scheme and prolog better than you ever will.
19:06:20 <lambdabot> It is stored.
19:08:13 <dons> dolio: :)
19:08:20 <dons> dolio: did you see mfp's comments about fannkuch (again!)
19:08:34 <dons> we need a clean, fast fannkuch and nbod
19:08:35 <dons> y
19:08:37 <dolio> It's a hot topic, apparently.
19:08:44 <dons> even if they use say, hmatrix , i wouldn't care
19:08:50 <dons> we'd have something to point to
19:10:24 <dolio> uvector can get close, but GHC still misses some unboxing.
19:10:47 <dolio> STUArray (and, I assume IOUArray) is a little worse than that.
19:10:59 <Elly> what are they, exactly?
19:11:07 <dons> i don't understand why we're not identical to C, fwiw
19:12:23 <adu> dons: in terms of Arrays?
19:13:12 <dons> adu, no, a couple of specific benchmarks i've not analysed in a long time are about 2-3x slower than i'd expect
19:13:20 <adu> ic
19:13:30 <Elly> 2man
19:13:31 <Elly> er
19:13:31 <mmorrow> omg, haskell takes 48.72 seconds in the nbody! this needs to be fixed asap!
19:13:41 <Elly> man, one of these days I should just sit down and actually learn Haskell
19:13:55 <adu> Elly: how about today?
19:14:07 * mmorrow starts reading nbody description
19:14:09 <dons> mmorrow: yeah, its too slow. given there are published papers on fast nbody in haskell...
19:14:19 <Elly> adu: :O
19:14:20 <adu> Elly: you wanna learn syntax, semantics, libraryies, or practical stuff?
19:14:21 <dons> and we've a set of good array libraries now for numerics
19:14:29 <Elly> adu: all of the above? :P
19:14:31 <dolio> Oh, the uvector unboxing issue has nothing to do with uvector, though, I think. It's just certain ST returns not getting unboxed.
19:14:45 <dons> dolio: yeah, that's one thing at least
19:14:48 <mmorrow> dons: papers? perfect
19:14:50 <Elly> adu: I already know SML pretty well, but I'm not good at doing "practical" stuff in it - all my experience with it is academic
19:14:52 <povman> Elly: i prerequisite for learning haskell is that you have written a paper on functional programming
19:15:02 <dons> nbody's an interesting problem.
19:15:04 <Elly> povman: I hope not
19:15:07 <povman> :p
19:15:10 <dons> you need to update a small set of vectors
19:15:11 <byorgey> nah, you just need a PhD
19:15:17 <adu> Elly: then the only new theoretical part will be type-classes
19:15:20 <dolio> dons: I don't know why it's not the same as C either, but even Addr# and MBA# are a factor of 2 slower than C arrays, I think.
19:15:21 <dons> dolio: we've not tried nbody, have we?
19:15:29 <dons> dolio: yeah, that's the bit i don't get.
19:15:30 <Elly> adu: I think I understand those
19:15:37 <adu> Elly: then you know Haskell
19:15:44 <dons> dolio: since else where that's not the case (e.g. nsieve-bits)
19:15:44 <adu> at least, theoretically
19:15:51 <mjrosenb> Elly: you need to take 312
19:15:52 <dolio> I haven't. tried nbody, no. It's a lot more complicated than fannkuch. :)
19:15:57 <Elly> adu: unfortunately, there's a gap between theory and practice :P
19:15:59 * dons uploads 401 haskell libraries and tools to the arch haskell overlay today
19:16:01 <povman> Elly: try to solve some of the rubyquiz's
19:16:05 <povman> (in haskell)
19:16:07 <Elly> mjrosenb: yes, yes, I know; I'm taking constructive logic
19:16:10 <mjrosenb> adu: there are some other strange things about haskell that you never use in sml
19:16:14 <byorgey> dons: that's insane.
19:16:21 <dons> frag works :)
19:16:23 <Elly> monads don't exist in SML
19:16:24 <adu> Elly: so you want practical stuff then, because everything else you can get with Hoogle
19:16:42 <Elly> adu: probably
19:16:52 <adu> Elly: technically, Monads are part of the libraries
19:16:52 <mjrosenb> Elly: there's also a bunch of syntatic sugar, but that's mostly easy
19:17:02 <Elly> I think I have a grasp of most of the syntactic sugar
19:17:37 <mjrosenb> yeah, aren't monads mostly syntatic sugar and a few libraries that you could write yourselves
19:17:46 <byorgey> mjrosenb: indeed.
19:17:53 <povman> and a really bad name
19:17:59 <adu> Elly: so what do you want to write? a replacement for 'ps'? how about a unix version of 'tree'?
19:18:02 <byorgey> the syntactic sugar (do-notation) is the only thing that is 'baked in'
19:18:11 <rwbarton> povman: Be glad they didn't end up getting called "triples"!
19:18:13 <Elly> adu: sure :)
19:18:15 <mjrosenb> yeah
19:18:31 * mjrosenb just found out that do notation could be used for all monads
19:18:32 * Elly waits for rubyquiz to load
19:18:38 <mjrosenb> such as Maybe
19:18:40 * byorgey rather likes the name 'monad'
19:18:45 <adu> the only unix equivalent of 'tree' is "find . -print"
19:18:54 <povman> if a programmer designed them they'd be called Function Chains
19:18:56 <adu> and it doens't look pretty anyways
19:18:56 * byorgey doesn't understand why everyone is always hating on the word 'monad'
19:18:58 <mmorrow> haha, JavaScript SpiderMonkey 	finishes in 3,447.99 (but finishes nonetheless, which is awesome)
19:19:12 <mmorrow> (that's in seconds, for nbody)
19:19:43 <povman> byorgey: it scares people who don't want to know category theory
19:19:46 <mjrosenb> mmorrow: is that one of the great language shootout tests?
19:19:47 <dons> i want to build up a culture of 'daily haskell' here, where everyone's comfortable using haskell to solve all their daily tasks, or able to start on a library or ffi binding to enable that.
19:19:57 <byorgey> povman: no, it scares people who don't want to learn anything new
19:20:02 <mmorrow> mjrosenb: yeah, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=all
19:20:04 <lambdabot> Title: n-body benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ..., http://tinyurl.com/og2cd
19:20:12 <dons> if a good percent get comfortable enough with what's on hackage -- which is enough to solve most things -- we'd really be able to produce a lot of useful software
19:20:28 <Elly> dons: I still use perl (or recently, ruby) for my daily tasks :\
19:20:51 <povman> byorgey: it's hardly a difficult concept... it's what you'd get if you were trying to write imperative code with a list, then realised you needed previous values
19:20:58 <mmorrow> dons: awesome!
19:21:01 <dons> well, i see no advantage to ruby -- haskell faster, and has the same set of libs. so there's definitely a possibility
19:21:14 <dons> mm, we really should be able to do a good version of this, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=gcc&id=0
19:21:15 <lambdabot> Title: n-body C GNU gcc program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer La ..., http://tinyurl.com/5krnwy
19:21:28 <dons> its those mutable updates that need a good bit of sugar
19:21:30 <byorgey> povman: but given that the concept needs a name, 'monad' is just as good a name as anything else
19:21:37 <Elly> dons: in ruby, I can do `ls` (for example)
19:21:37 <dons> and a nice vector type to abstract over the reads and writes
19:21:41 <byorgey> povman: you don't necessarily need to learn where the name 'monad' actually comes from
19:21:44 <Elly> dons: what's the haskell way to do ``?
19:21:53 <dons> Elly: getDirectoryContents >>= print
19:22:08 <dons> familiarity with libraries is key
19:22:14 <Elly> dons: that's how you do `ls`; I'm wondering how you do `` generally
19:22:14 <povman> byorgey: maybe it's because it's always accompanied by a reference to CT :)
19:22:17 <dons> *assume* there's a module on hackage that does what you need now.
19:22:26 <dons> Elly: oh, you mean running a process
19:22:29 <Elly> yep
19:22:29 <mmorrow> Elly: http://hpaste.org/8455
19:22:30 <dons> using the 'process' library
19:22:40 <dons> do s <- readProcess "ls" [] ; print s
19:22:44 * Elly does not know haskell's libraries at all
19:22:57 <mmorrow> Elly: that link solves your problem completely
19:23:12 <dons> yeah, there's 550 libraries on hackage
19:23:17 <byorgey> povman: perhaps. of course, I love category theory (and wanted to learn it as soon as I heard about it the first time), so I may not be the best qualified to comment on the subject ;)
19:23:19 <dons> that's a lot of pre-canned solutions waiting for you
19:23:36 <Elly> it's true
19:23:46 <Elly> it does sort of pale in comparison to CPAN though
19:23:49 <dons> modern haskell really is becoming a process of gluing together libraries
19:23:52 <mmorrow> whoa, what is "readProcess"?
19:24:04 <dons> mmorrow: like readFile but for processes
19:24:05 <mmorrow> s/what/where from/
19:24:06 <byorgey> mmorrow: a... function?
19:24:35 <mmorrow> i'm not familiar with that func and want to be
19:24:45 <byorgey> @hoogle readProcess
19:24:45 <lambdabot> No matches found
19:24:55 <dons> hmm. we need a tour of hackage series
19:25:59 <povman> this discussion is too much fun, must concentrate
19:26:23 <mmorrow> oh, i found it.
19:26:36 <dons> hmm, so
19:26:37 <dons> struct planet { double x, y, z; double vx, vy, vz; double mass;
19:26:39 <dons> }
19:26:44 <Elly> so where actually does readProcess come from/
19:26:47 <dons> we need a mutable array of those.
19:26:51 <mmorrow> http://hackage.haskell.org/packages/archive/process/1.0.0.0/doc/html/System-Process.html
19:26:52 <lambdabot> http://tinyurl.com/65szul
19:26:55 <Elly> s/\//?/
19:27:13 <dons> dolio: so what, Storable Planet ?
19:27:25 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
19:27:25 <rwbarton> (Does the mass really ever change?)
19:27:26 <lambdabot> http://tinyurl.com/38wv7e
19:27:31 <dons> rwbarton: nope.
19:27:47 <dons> the x,y,z and velocities are updated a lot though
19:27:52 <mmorrow> i guess i intially found runInteractiveProcess and never looked back
19:27:57 <Pseudonym> rwbarton: Only at relativistic speeds.
19:27:59 <dons> and the results are small enough to fit in the cache
19:28:15 <Pseudonym> And arguably, not even then.
19:28:15 <dons> basically, you need to have an identical representation to C here
19:28:30 <thoughtpolice> dons: too bad we can't use uvector for the shootout, it would probably be a great win. :)
19:28:40 <mmorrow> why not!
19:28:41 <mmorrow> ?
19:28:52 <dons> thoughtpolice: yeah, instance UElem Planet
19:28:52 <Elly> high-speed number crunching on data sets made of primitives :O
19:28:54 <dons> is easy enough
19:29:00 <thoughtpolice> shootout entries can only use the standard libraries
19:29:03 <mmorrow> oh
19:29:11 <dons> so that means STUArray
19:29:18 <mmorrow> cool
19:29:25 <thoughtpolice> dons: on the note of uvector, the .cabal needs a small patch to build on 6.8.3
19:29:26 <dons> or Storable, with an instance for reading and writing Planet
19:29:29 <dons> thoughtpolice: oh?
19:29:44 <thoughtpolice> dons: yeah, there's a conditional that makes ghc-prim a requirement if ghc > 6.8.2
19:29:51 <thoughtpolice> but it doesn't exist still in 6.8.3
19:29:53 <Elly> I should just remove ubuntu's ghc and install the one from the website
19:29:56 <dons> thoughtpolice: oh oops
19:29:56 <dolio> dons: I've not done much with Storable type stuff. You'd probably know better than I.
19:30:05 <Elly> ubuntu's still using 6.6.1
19:30:20 <dons> dolio: ever defined a custom STUArray element type?
19:30:37 <dolio> I've looked into it, but not done it.
19:31:09 <dons> i don't think we actually tried that for nbody
19:32:02 <dons> a big thing is that these double-math loops simply can't allocate on the heap
19:32:08 <dons> you've got to stay inside the cache
19:32:24 <dolio> @yarr
19:32:24 <lambdabot> I'll crush ye barnacles!
19:32:45 <dolio> As I suspected, static argument transform de-optimizes my MBA# fannkuch in 6.9.
19:34:31 <dolio> Looks like it de-optimizes the existing one, too.
19:34:32 <dons> dolio: the clean entry is a good model
19:34:35 <dons> we should be able to do that.
19:34:37 <dons> for nbody
19:34:47 <dons> they've got nice array syntax, sigh
19:35:12 <dons> ocaml's oddly slow there.
19:35:21 <edwardk> Hrmm does anyone who actually likes all this constructive algorithmics stuff feel like taking a look over the last 3 posts on http://comonad.com/reader for obvious typos before they hit planet haskell =)
19:35:31 <lambdabot> Title: The Comonad.Reader
19:36:43 <Elly> dons: where is your blog again? I keep forgetting :(
19:38:44 <ddarius> edwardk: First line of the Catamorphism one: "Catamorphisms are generalizations of Haskell's unfoldr."
19:39:01 <edwardk> ah
19:39:03 <edwardk> woops
19:39:18 <edwardk> fixed
19:39:40 <dolio> Man, the current nbody entry is crazy.
19:39:40 <edwardk> Thats what I get for just spewing words onto a page =)
19:40:19 <dons> dolio: lots of old crap there.
19:40:40 <edwardk> I figure once I start getting some of the other ones in there I can crosslink them or something, and maybe move it to a haskell.org or something once I think its stable.
19:41:21 <dolio> Wow, clean is a factor of 3 faster.
19:41:30 <ddarius> edwardk: A slight typo in the futumorphism entry
19:41:44 <dons> dolio: though note, arrays are wired in to the compiler in Clean.
19:41:52 <dolio> Yeah.
19:42:09 * Elly pokes dons
19:42:14 <edwardk> ddarius: i'm missing it
19:42:20 <hpaste>  adu pasted "tree.hs template" at http://hpaste.org/8478
19:42:30 <edwardk> oh duh
19:42:32 <adu> Elly: here, I made it easy for you
19:42:35 <ddarius> edwardk: An extra 'a'
19:42:52 <ddarius> "returning a multiple levels"
19:42:56 <edwardk> got it
19:42:59 <byorgey> edwardk: wow, this is great!
19:43:00 <Elly> adu: I'd rather figure it out for myself, but thanks anyway :)
19:43:01 <byorgey> edwardk++
19:43:06 <adu> Elly: ok
19:43:28 <dolio> Clean is a factor of around 2.5 faster on fannkuch, so they're obviously doing something better than GHC with arrays.
19:43:37 <edwardk> byorgey: does the format for the field guide entries seem complete enough? I don't want to cover all of the derivations, but I think covering all of the pertinent results is a good idea
19:43:48 <dons> Elly: google will find it :)
19:43:55 <byorgey> edwardk: looks ok to me.
19:45:00 <Elly> wow, haskell gets trashed by java on nbody :|
19:45:13 <adu> ouch
19:45:25 <dons> Elly: everything gets trashed by java on nbody
19:45:31 <dons> its a java standard benchmark :)
19:45:41 <dons> still, its something of a mystery
19:45:45 <dons> we hold ourselves to higher standards.
19:46:06 <Elly> well, they have mutable variables
19:46:17 <Elly> and probably a pretty good JIT codegen by now
19:46:47 <dolio> GHC beats Forth on nbody, somehow. :)
19:47:31 <dolio> Maybe bigForth isn't very good.
19:48:00 <byorgey> edwardk: the greek 'para' really means 'beside' more than 'close to'
19:48:22 <edwardk> ah true
19:48:36 <Elly> dons: no, GForth isn't very good :P
19:48:58 <Elly> SML with MLton does respectably
19:49:01 <Elly> er, s/dons/dolio/
19:49:10 <adu> is it a problem with nbody.hs or ghc?
19:49:21 <TomMD> Hummm, I do not believe frag is supposed to segfault.
19:49:53 <Axman6> TomMD: nah you have to beat it before it segfaults
19:50:04 <Axman6> damn, i want to write a game like that
19:50:21 <TomMD> "frag leveleg" segfaults instantly, it seems thats the only thing it will do for me.
19:50:33 <edwardk> I'm thinking about submitting to run a half-day tutorial on comonads, comonad transformers and maybe some of the constructive algorithmics stuff for the DEFUN track at the ICFP this year. What do you think people would like to have covered?
19:50:35 <adu> Axman6: lol, that would be so anticlimactic
19:50:36 <dons> TomMD: works for me. :)
19:50:42 <dons> x86_64/linux
19:50:53 <mmorrow> here's the C program that loses to java by 0.04 seconds: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=gcc&id=0
19:50:54 <lambdabot> Title: n-body C GNU gcc program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer La ..., http://tinyurl.com/5krnwy
19:51:03 <TomMD> dons: It worked for me in the past (x86/Linux) but now (x86_64/Linux) it is being stubborn.
19:51:07 <Axman6> Error: "YOu have won, congratulations!"
19:51:13 <Axman6> Segfault.
19:51:20 <Axman6> s/O/o
19:51:25 <TomMD> Nothing like some SIGSEGV before bed.
19:51:42 <adu> maybe because its printing so much
19:52:44 <vininim> it seems c++ > c in s.a.d.o
19:53:51 <mmorrow> is template-haskell ok to use in the shootout? (in the extreme case, the a table of answer could just be computed at compile-time)
19:54:00 <twanvl> edwardk: I think an example in more familiar haskell notation or perhaps a list of library functions that are actually *morphisms would be really helpful
19:54:00 <adu> sado = shootout.alioth.debian.org?
19:54:28 <dolio> mmorrow: Does that sound like it'd be acceptable? :)
19:54:45 <mmorrow> dolio: not the extreme case, but possibly a shade of gray?
19:54:49 <edwardk> twanvl: yeah. i figured i'd start with the sort of standard list reductions in cata, and factorial for para, etc. some time tomorrow
19:54:58 <mlh> mmorrow: I guess you could do the same with C++
19:55:22 <edwardk> twanvl: i do like the idea of going through and implementing standard library functions as foo-morphisms
19:56:03 <dolio> They're pretty anal about eliminating anything like that that would give one language a huge advantage over others.
19:56:14 <mmorrow> yeah, i suppose. th would probably get the entry disqualified even if it wasn't being used to "cheat" due to the inevitable jerknee reaction it'll most likely cause
19:56:21 <dolio> Or would prevent the benchmark from measuring what they're actually trying to measure.
19:56:35 <mlh> wah?
19:56:53 <mmorrow> dolio: now that you put it that way, i see totally
19:58:17 <dolio> Yeah, I mean, I could precompute the output of the fannkuch benchmark for up to n=12 or something, but the runtime of that program would tell you nothing about the speed of array indexing.
19:58:36 <dolio> Until they bumped it up to n=13, of course. :)
19:58:46 <Elly> holy crap, ruby's time is 4847 seconds
19:59:06 <mlh> maybe there's a case for including the time of compilation :-)
19:59:38 <dolio> Heh. Ruby wins, no compilation time!
19:59:55 <mlh> sh(1) ftw
20:00:02 <ivanm> dolio: what, it beats python as well? :o
20:00:16 <dolio> Well, you'd have plenty in a tie for first.
20:00:27 <TomMD> Its not too often my users care how long the compile took me.  It isn't even that often my boss cares how long a compile took.
20:00:30 <dolio> Although it'd beat Python (Psyco).
20:01:14 <mlh> TomMD: sure, again, it depends what you're doing.  java fans complain that including 'startup time' is unfair
20:02:16 <rwbarton> edwardk: in the Paramorphism diagram, should the lower left corner be  F(X \times \mu F)?
20:02:19 <edwardk> twanvl: i started adding examples.
20:02:31 <TomMD> mlh: Yeah, I just think sometimes people get a bit to deep in the synthetic benchmarks - not trying to derail your conversation though, sorry if it did.
20:02:35 <edwardk> rwbarton: refresh, is it fixed?
20:02:48 <edwardk> i think i got it about 10 minutes back
20:02:50 <edwardk> =)
20:03:06 <rwbarton> edwardk: Excellent :)
20:03:19 <mlh> TomMD: no probs, I find s.a.d.o, but I agree people get too wound up in the raw figures
20:03:21 <rwbarton> Took me longer than that to figure out what was going on
20:03:41 <mlh> "I find s.a.d.o. fascinating but ....."
20:03:49 <edwardk> no problem. i accidentally said \cross rather than \times coz i'm used to my own bindings for latex
20:04:00 <Elly> hehe, the Io result
20:04:28 <dolio> Java's startup time doesn't seem to be that bad anymore.
20:04:38 <dolio> 0.19 seconds.
20:04:41 <rwbarton> I see
20:05:02 <dolio> Better than Groovy (which runs on the JVM, no?) 4.4 seconds.
20:05:34 <Elly> woah, Eiffel is close to C
20:06:32 <twanvl> edwardk: the example looks good, it makes it a lot easier to understand
20:07:06 <scodil> whats the story with code.haskell.org? Can anyone host a project there?
20:07:22 <edwardk> adding factorial to para as well
20:07:24 <rwbarton> edwardk: Same thing in the first line of the Derivation
20:07:36 <edwardk> rwbarton: ah good catch
20:09:44 <rwbarton> edwardk: I wonder if it would be a good idea to fix the variable 'a' in your catamorphism example (to, say, Integer)
20:10:01 <edwardk> for sum? or length?
20:10:01 <rwbarton> edwardk: I got confused at first because I was thinking about the functor a |-> [a] rather than X |-> 1 + a * X
20:10:06 <dolio> dons: FYI: memcpy doesn't appear to be a big deal. I changed my MBA# version of fannkuch to use memcpy, and it didn't appear to be faster.
20:10:25 <edwardk> rwbarton: hrmm.
20:10:43 <edwardk> i also need to make it an instance of Functor, woops
20:11:34 <dons> dolio: good to know
20:11:39 <edwardk> heh this factorial example is turning out to be a pain in the ass, i forgot how much i hate peano arithmetic =)
20:12:53 <dolio> Although I suppose there's a question of why memcpy (written in C) isn't faster than going via Haskell array access, which otherwise appears to be significantly slower than C. :)
20:15:41 <Elly> heh, it still amuses me that Tor makes google's language change randomly
20:16:23 <dolio> Or maybe it is slower (testing again), just not that much.
20:17:21 <Elly> where is System.Process documented? Hoogle gives me a bunch of spurious results :\
20:17:47 <Elly> nevermind, I found http://www.haskell.org/ghc/docs/latest/html/libraries/
20:18:02 <dolio> If it is making a difference, it's like 5% in this benchmark.
20:18:17 <edwardk> ok, slapped together a factorial example for para
20:19:07 <ddarius> paraNat (*) 1
20:19:36 <edwardk> yeah but given the minimalist setting, i had to define Nat first ;)
20:20:03 <ddarius> Nat is easy, it's multiplication that is annoying (still easy, just a bit tedious)
20:20:16 <dolio> What is that? Factorial?
20:21:05 <ddarius> > let paraNat s z 0 = z; paraNat s z n = s n (paraNat s z (n - 1)) in paraNat (*) 1 5
20:21:07 <lambdabot>  120
20:22:32 <vininim> I implemented simulated annealing in python one week ago, using lambda, movement candidates lists and random.sample(), and numpy to make it not too slow at array reference... how naive I was. =P
20:26:20 * adu reads about TH
20:28:20 <adu> is there any way to avoid using [d| ...|] and use [| ... |] instead?
20:28:48 <vininim> A simulated annealing framework for haskell, like GPlib@hackage sounds fun.
20:30:00 <dolio> [d| ... |] and [| ... |] are for different things. Why would you want to exclusively use one and not the other?
20:31:43 <adu> i dunno
20:31:47 <Elly> I've never seen that syntax before; what does it do?
20:31:50 <adu> I'm still learning about TH
20:32:18 <Elly> :t lines
20:32:19 <lambdabot> String -> [String]
20:32:35 <adu> dolio, because http://hpaste.org/8475 is not compiling
20:32:44 <dolio> Strictly speaking, you don't ever have to use [d| ... |] or [| ... |], you can instead use Language.Haskell.TH to explicitly build a syntax tree.
20:32:58 <dolio> But using the quoting can be a lot simpler in many cases.
20:33:05 <hpaste>  adu annotated "Assignments" with "error" at http://hpaste.org/8475#a1
20:33:17 <scodil> anyone else get a link error about readline with ghc6.8.3 on ubuntu?
20:33:53 <scodil> nm
20:34:33 <dolio> Which is line 58?
20:34:44 <adu> dolio: "exportArgument = return"
20:36:05 <dolio> Not sure what the problem is.
20:46:56 <adu> do you need to put anything at the top for "foreign import"? like OPTIONS -fglasgow-exts?
20:47:20 <dons> LANGUAGE ForeignFunctionInterface
20:47:58 <Zao> or -ffffi on the command line.
20:48:05 <Zao> Erm, drop an f.
20:48:37 <byorgey> -fffffffffffi
20:51:03 <adu> lol
20:52:42 <Pseudonym> You add more f's if the code is more foreign.
20:53:07 <Pseudonym> You link to Scheme code using -fi, but Malbolge code using -fffffffi.
20:53:11 <Elly> so if you're linking against COBOL running on a VAX with RPC over DECNet, you have to pass -fffffffffffffffffffffffffffffffffffffffffffffffffi?
20:53:29 <Pseudonym> And, of course, Haskell code using just -i!
20:53:35 <Elly> what about SML?
20:54:00 <Zao> Elly: Then you'd get command lines that would not fit on your typical IRIX shell.
20:54:22 <Elly> Zao: all the Irix machines I've used (which is one :P) have supported lines that long
20:54:54 <Elly> I also have root on a real microVAX II :D
20:55:01 <Elly> (it's offline though :()
20:55:01 <Zao> Elly: The maximum command length is 20k, I've heard.
20:56:11 <Zao> I wish that my O2 wouldn't wedge after being exercised for a while. I also wish it had a GHC :P
20:56:15 <Elly> eh, that's big enough
20:57:54 <adu> well, maybe 6.8.3 will fix it
21:00:55 <dolio> @hoogle MutableByteArray# -> Ptr a
21:00:55 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Ptr a'
21:03:25 <scodil> anyone else get compile errors building haddock2?
21:03:55 <mmorrow> i was thinking about the shootout, and it seems fundamentally flawed, in the sense that it's not really a competition between *languages* but between compilers. So for instance, a haskell program that given a particular input value, generated specialized (machine) code for that input value, then runs it by turning it into a FunPtr and using foreign import "dynamic", would almost certainly be disqualified. BUT a java JIT is considere
21:03:55 <mmorrow> d OK.
21:04:55 <hansfbaier> mmorrow: is there a JIT for haskell?
21:04:59 <hpaste>  dons pasted "a better nbody?" at http://hpaste.org/8479
21:05:10 <dons> dolio: i think that'll look a lot better, fwiw ^
21:05:22 <mmorrow> hansfbaier: it'd be easy so make a jit for a partic problem
21:05:36 <mmorrow> hansfbaier: *but* doing so would prob be consisdered cheating
21:05:46 <mmorrow> *this* is the fundamental flaw i see
21:06:06 <dolio> dons: Does that perform the same?
21:06:11 <ddarius> The shootout -is- a comparison between language implementations.
21:06:17 <dons> dolio: well, i've only got to the initialisation phase.
21:06:23 <dons> we'll see how the main loops work, but i'm hopeful
21:06:23 <dolio> Ah.
21:06:27 <dons> same representation as C.
21:06:42 <hansfbaier> anyone knows whether incremental (realtime) garbage collecting has been implemented in ghc?
21:06:49 <dons> the fact we can't derive STUArray for product types is tedious
21:06:59 <dons> hansfbaier: a concurrent collector, no.
21:06:59 <ddarius> It has, but not in the main branch, and what was has bitrotted.
21:06:59 <dolio> Yeah.
21:07:05 <dons> ghc just got a parallel collector
21:07:06 <mmorrow> ddarius: i'd call it a comparison between language implementations (but what language any two are implementing is irrelevant)
21:07:12 <dons> ddarius: oh, from gum days?
21:07:23 <ddarius> dons: Not that long ago.
21:07:27 <ddarius> @google non-stop haskell
21:07:28 <lambdabot> http://research.microsoft.com/~simonpj/papers/inc-gc.htm
21:07:29 <lambdabot> Title: Simon Peyton Jones: papers
21:07:31 <dons> hmm. ah right
21:07:38 <dons> yes, good point!
21:08:59 <dons> dolio: i'm hopeful Planet will be taken apart into FPU registers
21:09:07 <dolio> Is there automatic deriving for PArr stuff?
21:09:16 <dons> yeah
21:10:27 <mmorrow> ddarius: (in the sense that if a particular language gives the programmer to do things compilerish easily at runtime it doesn't matter, since this is disallowed. so the *power/expressiveness/whatever* of a the language becomes irrelevant because hose techniques are disallowed due to not every lang having them)
21:11:06 <mmorrow> (excellent english, mmorrow)
21:11:43 <mar77a> if i had to choose one book or tutorial to print
21:11:49 <mar77a> on haskell, which one should i?
21:12:00 <mmorrow> ddarius: now that i read that, it strikes me as somewhat bullshitish, but i think i just phrased it poorly
21:12:04 <adu> mar77a: the GHC manual
21:12:15 <mar77a> where can i find it
21:17:43 <adu> mar77a: http://www.haskell.org/tutorial/ is also good
21:17:43 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
21:18:21 <adu> mar77a: http://haskell.org/haskellwiki/GHC is where the GHC manual is
21:18:22 <lambdabot> Title: GHC - HaskellWiki
21:18:34 <adu> but I just realized its just under 300 pages, you might not want to print it
21:18:54 <mar77a> :)
21:19:10 <adu> mar77a: or you can do as I did, and just print out the Haskell98 language definition, and read that
21:20:27 <adu> mar77a: but then again, the haskell report is also just under 300 pages too...
21:20:29 <mmorrow> dons: the end of your code at http://hpaste.org/8479 got chopped
21:20:34 <mar77a> lol
21:21:04 <mmorrow> mar77a: that's what i did too
21:21:17 <mar77a> i think i can print 300 pages
21:21:24 <mmorrow> mar77a: at first you're like oh shitcrap
21:21:53 <mmorrow> mar77a: and then you're like pffft easy
21:22:23 <adu> mar77a: you could just print out pages 115-140 (the Prelude)
21:23:13 <dons> mmorrow: yeah, i'll let you know when its done.
21:23:19 <adu> mmorrow: lol
21:23:21 <mmorrow> adu: definitely, i had that printing out with me always until i more or less had it memorized
21:23:36 <mmorrow> adu: heh
21:23:36 <mar77a> lemme take a look at the report
21:23:53 <mmorrow> ("that thing" being the prelude)
21:24:03 <mmorrow> dons: awesome
21:24:35 <mar77a> whatsafuck
21:24:48 <mar77a> this is wayyyyy to detailed
21:24:49 <mar77a> too
21:25:08 <mmorrow> mar77a: i *told* you at first you're like "oh shitcrap"
21:25:28 <adu> mar77a: thats the only way it could fit in 300 pages :)
21:25:38 <mar77a> well
21:25:46 <mar77a> it's certainly not "The Haskell Programming Language"
21:26:03 <mar77a> since "The C++ Pro.." is like 900 pages
21:26:15 <mar77a> i own TCPL but i don't really know how many pages it is
21:27:31 <adu> mar77a: memorize haskell98-report and you will be an expert :)
21:28:03 <mar77a> yeah i'm definitely printing it
21:28:24 <mar77a> see, my father owns a fotocopier machines distrib
21:28:36 <mar77a> when they test machines they usually just print random stuff
21:28:46 <mar77a> hehe, gotta take advantage f it
21:28:49 <mar77a> of even
21:29:39 <adu> I think the page that took the longest time for me to memorize was page 27 ("do" notation)
21:30:13 <mar77a> i think they changed it since you downloaded it cause in page 27 i see "layout"
21:30:41 <adu> I'm talking about the page numbers at the top, page 27 is actually page 41 in the pdf
21:32:19 <adu> anyways, igtg
21:48:56 <hpaste>  jdrake pasted "Caear Cipher.lhs any suggestions?" at http://hpaste.org/8480
21:51:04 <jbapple> I had a funny complexity thought today: If you store one true and one reversed copy of a structure that offers cons and snoc, you immediately get reversal for O(1)
21:51:14 <jbapple> Every other operation takes twice as long
21:51:27 <jbapple> (well, every other modifying operation)
21:51:59 <mrd> jbapple: there are some data structures which are like that
21:52:07 <mrd> ever read purely functional data structures?
21:52:23 <QtPlatypus> jbapple: Doubly linked lists get you that.
21:52:50 <jbapple> mrd: yes, but I don't know which data structures you're thinking of
21:54:07 <jbapple> QtPlatypus: Can you write purely functional doubly-linked lists?
21:54:23 <Heffalump> QtPlatypus: only if you have some way to swap all next/prev pointers in O(1) time
21:55:19 <ivanm> jdrake: it might be an idea to simplify your procedure by taking it mod 26
21:55:37 <jdrake> ivanm: What do you mean precisely?
21:56:33 <flx> however, how do you offer a snoc to a functional list?
21:56:34 <ivanm> jdrake: write another function like this:
21:56:43 <mmorrow> man, this STUArray stuff is killing me...pushing onward...
21:57:04 <ivanm> wrapLetterBy diff c = (c - diff + n) `mod` 26 + diff
21:57:27 <dobblego> @where dlist
21:57:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
21:57:31 <Heffalump> flx: the easiest way is to store a pair of normal lists xs, ys to represent the list xs ++ reverse ys - then you just snoc onto ys.
21:57:33 <jbapple> In a lazy language like Haskell, assuming you only ever inspect the true version of the list, all of the modifying thunks are suspened on the reversed version, so you pay the cost of the modifications only after a reverse
21:57:36 <dobblego> flx, ^^
21:57:38 <ivanm> so you have then: if (isLower c) then wrapLetterBy (ord `a`) c
21:57:48 <ivanm> then do something similar for capitals
21:57:57 <Heffalump> jbapple: well, you pay the memory cost, and a small thunk allocation cost
21:57:58 <mmorrow> ohhhh, i see my *critical* oversight was.....
21:58:07 <jbapple> @google finger trees
21:58:08 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
21:58:08 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
21:58:25 <jbapple> Heffalump: good point
21:59:29 <jdrake> hmm
22:01:46 <mmorrow> i wonder around what data size the additional overhead of using Seq would become less that that incurred by the reverse xs ++ ys for ([a],[a]) (or something)
22:01:56 <mmorrow> s/that that/than that/
22:02:24 <jdrake> lovely
22:02:25 <jdrake> Thank you
22:02:32 <vininim> mmm what is the sintax for paramitized datas with classes? data Foo x = (Num x) => Foo x ?
22:02:44 <vininim> *parameterized
22:03:15 <Heffalump> mmorrow: I have a vague recollection that finger trees are around a factor of 12 slower than lists
22:03:17 <jbapple> mmorrow: Do you mean Seq as in Edison or seq as in strictness?
22:03:46 <mmorrow> Seq as in Data.Sequence as in a particular instance of a finger tree
22:03:56 <mmorrow> Heffalump: hmm
22:04:26 <mmorrow> jbapple: i've looked at edison but never used it. how is it?
22:04:39 <jbapple> mmorrow: undocumented
22:04:47 <mmorrow> jbapple: heh
22:05:07 <jbapple> mmorrow: But often fater than what's available in other libraries
22:05:37 <mmorrow> jbapple: interesting, i haven't looked in to it in a few months, perhaps i will
22:05:55 <jbapple> mmorrow: I keep meaning to get around to writing a Data.Heap replacement that uses Okasaki's skew heap, which is available in Edison
22:06:50 <jbapple> It has O(1) meld and insert
22:07:16 <vininim> mm it seems to have another name... Existential Quantification.. and yes, the sintax is that one. =P
22:07:18 <jbapple> mmorrow: also, I meant faster, not "fater", whatever that is
22:07:22 <mmorrow> jbapple: ooh, i happen to have pfds within arms reach...
22:07:30 * mmorrow open pfds
22:07:45 <jbapple> mmorrow: PDFs of what?
22:07:49 <mmorrow> jbapple: fater...more fateful???
22:08:01 <mmorrow> jbapple: oh heh, purely functional data structures
22:08:35 <dancor> @pl \ xs -> (f (head xs)):(tail xs)
22:08:35 <lambdabot> ap ((:) . f . head) tail
22:09:33 <jbapple> mmorrow: Also useful is Purely functional representations of catenable sorted lists
22:09:37 <jbapple> @google Purely functional representations of catenable sorted lists
22:09:39 <lambdabot> http://citeseer.ist.psu.edu/572587.html
22:09:46 <jbapple> drate citeseer is down
22:09:48 <jbapple> *drat
22:10:01 <mmorrow> blast!
22:10:05 <jbapple> http://www.math.tau.ac.il/%7Ehaimk/papers/loglog23.ps
22:10:30 <jbapple> Kaplan & Tarjan claim O(lg (lg n)) concat, though Hinze and Paterson are dubious
22:10:35 <mmorrow> nice, that link worked
22:10:44 <jbapple> They say the expect to get O(1) concat
22:10:48 <mmorrow> hmm
22:10:50 <jbapple> But that was many years ago
22:11:01 <jbapple> But Tarjan is not to be doubted.
22:11:04 <jbapple> Or he will crush you.
22:11:09 <mmorrow> haha
22:11:11 <jbapple> in O(lg * n) time
22:11:18 <mmorrow> O(hahaha)
22:15:44 <jcreigh> there's really only two types of functions: O(fast enough) and O(not fast enough)
22:16:18 <adu> jcreigh: isn't that a little bit subjective?
22:17:16 <adu> any mac users in here?
22:18:18 <pgavin> adu: yeah
22:18:44 <jcreigh> adu: well, in the Real World, something is either fast enough for what you're trying to do, or not fast enough. If it's the latter, you can either try to find a faster way, or throw more servers at the problem.
22:19:32 <adu> pgavin: did you see I made a Yi.app?
22:19:51 <pgavin> adu: where's that?
22:19:55 <adu> http://haskell.org/haskellwiki/Yi
22:19:56 <lambdabot> Title: Yi - HaskellWiki
22:20:01 <adu> half-way down
22:20:15 <pgavin> cool, I'll try it out
22:20:21 <pgavin> against gtk?
22:20:31 <adu> pgavin: ya gtk, for now
22:20:36 <pgavin> awesome, its in macports
22:20:40 <adu> pgavin: it also assumes you've already installed yi with macports
22:21:04 <olsner> gtk? so it ends up running in X11 rather than as a native program?
22:21:09 <adu> pgavin: and it doesn't check to see if X11 is running... things to fix
22:21:21 <pgavin> adu: so how do you bootstrap it?
22:21:39 <adu> I yanked GIMPskel and made it run yi instead of gimp
22:21:55 <adu> and made an icon too
22:22:36 <pgavin> why would it need to depend on itself like that?
22:23:34 <adu> well, eventually, you would put the binaries (the stuff in /opt/local/...) inside Yi.app/Contents/local or something so you could just download Yi.app and not even need MacPorts
22:23:59 <pgavin> right..
22:24:33 <dolio> dons: You know a good way of diagnosing the cause of "internal error: ARR_WORDS object entered!"
22:24:56 <adu> but right now its more of a launcher button, less of a distribution
22:25:14 <adu> pgavin: what do you mean "bootstrap"?
22:25:43 <pgavin> oh, nevermind... I misread:  pgavin: it also assumes you've already installed yi with macports
22:25:57 <pgavin> I thought you meant the macport assumes that
22:26:37 <pgavin> lol@me
22:26:41 <adu> :)
22:27:05 <pgavin> ok, I think I'm going to bed now :)
22:27:08 <pgavin> @localtime
22:27:09 <lambdabot> Local time for pgavin is Mon Jun 23 01:27:09 2008
22:27:12 <adu> ok
22:27:15 <pgavin> :)
22:27:27 <adu> pgavin: east coast too?
22:27:36 <pgavin> ye, tallahassee
22:28:26 <pgavin> gnight, all :)
22:30:15 <adu> gnight
22:30:15 <olsner> heh, so yi basically means fix id? clever :)
22:30:43 <adu> olsner: according to the combinator perspective, yes
22:31:23 <dons> dolio: wow
22:31:36 <adu> i suppose you could also say that is the definition of "righteousness" as well...
22:31:39 <dons> olsner: yeah, that's the meaning of the   name
22:31:49 <dolio> dons: Is that a real GHC error (to be reported) or is it a bad index in my uvector code?
22:32:13 <dolio> (Only happens on 6.9, incidentally, not on 6.8.2.)
22:32:58 <dolio> I've seen errors similar to that and it was my fault.
22:35:43 <dons> hmm. i've never seen that, dolio
22:40:07 <mmorrow> wow, jhc really is really fast
22:40:40 <dolio> When it compiles.
22:40:53 <mmorrow> true that
22:40:57 <mmorrow> ;)
22:41:51 <olsner> fast as in compiling quickly or as in producing fast code?
22:42:02 <dolio> It doesn't compile quickly.
22:42:03 <mmorrow> producing *fast* code
22:43:58 <adu> is there a list of high-priority Haskell projects?
22:44:04 <olsner> but, jhc isn't that old... how can it be noticably better than ghc which has had years of work on it?
22:44:42 <mmorrow> it make different design decisions
22:44:51 <mmorrow> and does *whole* program analysis
22:45:03 <mmorrow> s/make/makes/
22:46:18 <olsner> I was under the impression that ghc also did inter-module analysis and optimization, but maybe it only does much weaker analyses than jhc
22:48:25 <adu> For example, GNU has http://www.fsf.org/campaigns/priority.html
22:48:25 <lambdabot> Title: High Priority Free Software Projects - Free Software Foundation
22:48:36 <adu> Is there a similar page for Haskell projects?
22:49:22 <sjanssen> adu: not that I'm aware of
22:49:31 <dolio> jhc also produces better errors, like this one: http://hpaste.org/6471
22:49:47 <sjanssen> the most important, in my opinion at least, is Cabal
22:50:16 <mmorrow> olsner: here's something related (from 2005 but still) => http://repetae.net/dw/darcsweb.cgi?r=jhc;a=annotate_shade;f=/docs/jhc-vs-ghc-assembly.txt
22:50:17 <lambdabot> Title: darcs - jhc, http://tinyurl.com/5q6jxk
22:50:35 <mjrosenb_> dolio: that's a better error?
22:50:37 <olsner> dolio: hmm, sarcastic are we? :P
22:50:39 <sjanssen> dolio: to be fair, that's a tricky bit of type checking
22:51:24 <olsner> "user error" :) it should come with taunts and insults to mix that up a bit
22:51:36 <sjanssen> mjrosenb_: a better error would be no error at all -- the code is valid
22:51:50 <mjrosenb_> sjanssen: oic
22:52:57 <dolio> That was 3 months ago, as you can see. It might work now. :)
22:52:57 <olsner> f x n = f (x,x) (n-1) shouldn't type-check, should it?
22:53:18 <sjanssen> @type let f x n = f (x, x) (n-1) in f
22:53:20 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
22:53:20 <lambdabot>       Expected type: (t, t) -> a -> t1
22:53:20 <lambdabot>       Inferred type: t -> a -> t1
22:53:28 <dolio> If x is showable, so is (x,x).
22:53:37 <sjanssen> hrmph, monomorphism?
22:53:56 <dolio> No, I think you always need a signature for polymorphic recursion.
22:54:06 <olsner> @type let f :: Show a => a -> Int -> String; f x n = f (x, x) (n-1) in f
22:54:08 <lambdabot> forall a. (Show a) => a -> Int -> String
22:55:02 <olsner> hmm, yes, so it's not *really* recursing to itself, just to a very similar function for a different a?
22:55:19 <mjrosenb_> oh god that's horrible
22:55:27 <dolio> One of the few places in H98 where that happens.
22:55:56 <quicksilver> on the contrary, it's not horrible it's a thing of beauty ;)
22:56:54 <dolio> No, it's recursing to itself.
22:57:29 <dolio> In GHC, you're just passing a different dictionary to the recursive call.
22:57:36 <dolio> I don't know how JHC would handle it.
22:58:09 <quicksilver> well depending how you view a class-polymorphic function, olsner's explanation is a sensible one.
22:58:19 <mjrosenb> dolio: wait, the dictionaries are dynamically allocated?
22:58:29 <quicksilver> a class-polymorphic function can be considered a family of functions.
22:58:35 <quicksilver> mjrosenb: yes, in extremis they are.
22:58:45 <quicksilver> mjrosenb: in practice they're often global.
22:58:48 <mjrosenb> :-o
22:59:00 <quicksilver> because in most programs use a fixed set of types, for the most part.
22:59:03 <mjrosenb> i'd expect them to be global for efficency reasons
22:59:05 <mjrosenb> right
22:59:09 <quicksilver> dolio: JHC would pass the type itself.
22:59:24 <rwbarton> You can use this kind of trick to write mod' :: (Num a => a) -> Integer -> Integer which does all the computations in its first argument mod its second argument.
22:59:43 <dolio> I guess that's what I would have guessed.
22:59:58 <quicksilver> JHC's intermediate language is lambda-cube like and has types-as-values.
23:00:21 <dolio> Yeah, I knew that, actually. :)
23:00:45 <quicksilver> I would guess this bug shows some problem in correctly packaging the use of (,)-as-a-type-constructor
23:04:52 <mmorrow> dolio: funny you should wonder about how jhc implements type classes, i was just reading: http://repetae.net/dw/darcsweb.cgi?r=jhc;a=annotate_shade;f=/docs/type-classes.txt
23:04:53 <lambdabot> Title: darcs - jhc, http://tinyurl.com/5f3r5l
23:05:20 <dolio> Well, I knew that JHC uses type-case, essentially.
23:06:15 <dolio> I just didn't have a mental picture of how it would go about handling that polymorphic recursion.
23:07:18 <dolio> I guess it would build up the type, and then recurse over it.
23:07:45 <dolio> As opposed to building dictionary functions from others and then applying at the end.
23:08:41 <dolio> But one doesn't usually think of types as being runtime phenomena in Haskell (although I guess in JHC, they sometimes must be).
23:09:30 <mmorrow> yeah, i'm not yet clear on that (not finished reading that txt file)
23:09:57 <quicksilver> well in terms of how haskell uses it it is a fairly weak kind of "types at runtime" AIUI.
23:10:17 <quicksilver> you can more of less think of it as an opaque ADT used to index a global table of dictionaries.
23:10:41 <dolio> Yeah, that file says it's based on GADT pattern matching, which makes some sense, I guess.
23:12:33 <quicksilver> "All types end up being eliminated except in the exact places where a dictionary '  191 would have been passed in a traditional implementation.
23:12:37 <quicksilver> "
23:12:46 <quicksilver> (sorry about the line number) but that's the point, I think.
23:16:29 <mmorrow> interesting...
23:16:34 * mmorrow reads on
23:17:28 <Trinithis> what's the txt file? I just signed on
23:17:33 <hansfbaier> @google realtime haskell
23:17:34 <lambdabot> No Result Found.
23:17:43 <mmorrow> http://repetae.net/dw/darcsweb.cgi?r=jhc;a=annotate_shade;f=/docs/type-classes.txt
23:17:44 <lambdabot> Title: darcs - jhc, http://tinyurl.com/5f3r5l
23:17:54 <hansfbaier> @google incremental garbage collector
23:17:54 <lambdabot> http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
23:18:08 <mmorrow> Trinithis: description of jhc's typeclass implementation
23:18:19 <Trinithis> jhc?
23:18:23 <hansfbaier> ﻿@google incremental garbage collector haskell
23:18:37 <mmorrow> http://repetae.net/computer/jhc/
23:18:37 <lambdabot> Title: jhc
23:18:47 <Trinithis> ty
23:19:09 <mmorrow> np
23:19:24 <mjrosenb> jhc is quite awesome
23:19:56 <Trinithis> hows it compare to ghc?
23:20:24 <olsner> by the sound of it, it really rocks the llama's back end
23:22:14 <dolio> Huh, interesting. JHC could theoretically do Data.Dynamic without unsafeCoerce.
23:22:36 <quicksilver> yes, true existentials-at-the-type-level
23:22:52 <quicksilver> JHC's core also supports non-parametric polymorphism
23:23:07 <quicksilver> it contains "other" functions of type (a->b)->[a]->[b]
23:23:20 <quicksilver> although of course you can't reach them, compiling from haskell.
23:23:26 <dolio> Right.
23:24:07 <quicksilver> On the other hand, JHC is whole program compiling and surely has some quadratic and cubic factors
23:24:14 <quicksilver> if not even an exponential one
23:24:23 <quicksilver> so it may not be possible to scale it as it stands.
23:25:26 <quicksilver> dolio: actually John said somethign about how he implemented dynamic in JHC in response to a comment I made a few months back
23:25:30 <quicksilver> let me see if I can find it.
23:27:12 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2008-May/042860.html
23:27:13 <lambdabot> Title: [Haskell-cafe] Data.Dynamic over the wire, http://tinyurl.com/6bwtka
23:27:18 <quicksilver> not quite as relevant as I thought.
23:27:45 <mmorrow> Trinithis: i wouldn't stop using ghc for it, but i can see using jhc instead of ghc in particular instances that play to its strengths
23:28:15 <Trinithis> mmk
23:28:17 <adu_> dons: is ftp.cse.unsw.edu.au down?
23:28:17 <mmorrow> Trinithis: what these particular instances may be i can't say yet, since i've never used jhc before 1 hour ago
23:28:28 <mmorrow> ;)
23:28:38 <Trinithis> seems like it's just a prototype at the moment anyway
23:28:56 <mmorrow> something like that i guess
23:30:10 <dolio> Can't do that in Agda, I guess.
23:30:29 <dolio> Can't pattern match on Set.
23:32:02 <dancor> > case "aa" of {c:c:[] -> 4}
23:32:03 <lambdabot>      Conflicting definitions for `c'
23:32:03 <lambdabot>     In a case alternative
23:32:19 <dancor> i keep wanting pattern matching to be cooler i think
23:33:11 <mmorrow> intersting:
23:33:12 <mmorrow> "And since types are only erased if they are not used, one is free to
23:33:12 <mmorrow> experiment with other methods of using run-time type information without
23:33:12 <mmorrow> modifying the back end."
23:34:41 <mmorrow> > case "aa" of {_:_:[] -> 4}
23:34:42 <lambdabot>  4
23:34:54 <mmorrow> > case "aa" of {_:_:_ -> 4}
23:34:55 <lambdabot>  4
23:35:02 <dancor> > case "aa" of {c:c:[] -> c}
23:35:02 <lambdabot>      Conflicting definitions for `c'
23:35:02 <lambdabot>     In a case alternative
23:35:07 <rwbarton> I think the intent was
23:35:15 <rwbarton> > case "aa" of {c:c':[] | c == c' -> c}
23:35:16 <lambdabot>  'a'
23:35:21 <mmorrow> oh
23:35:27 <rwbarton> I've made that mistake before :)
23:35:42 <mmorrow> > case "aa" of {(c@_):c:_ -> 4}
23:35:43 <lambdabot>      Conflicting definitions for `c'
23:35:43 <lambdabot>     In a case alternative
23:35:59 <dancor> > case "ab" of {c:c':[] | c == c' -> c; _ -> '!'}
23:36:00 <lambdabot>  '!'
23:36:06 <dancor> cool
23:37:00 <mmorrow> > case "aa" of a:b:_ | a==b -> c ; _ -> '!'
23:37:00 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
23:37:15 <mmorrow> dang
23:37:24 <mmorrow> > case "aa" of a:b:_ | a==b -> a ; _ -> '!'
23:37:25 <lambdabot>  'a'
23:37:28 <mmorrow> oh
23:38:03 <dancor> you don't need curly's for one-liner case?
23:38:14 <mmorrow> oh nos
23:39:03 <mmorrow> > let a = case "aa" of a:b:_ | a==b -> a ; _ -> '!' ; b = '_' in [a,b]
23:39:04 <lambdabot>  Parse error at "=" (column 55)
23:39:08 <mmorrow> aww
23:39:21 <mmorrow> > let a = (case "aa" of a:b:_ | a==b -> a ; _ -> '!') ; b = '_' in [a,b]
23:39:22 <lambdabot>  "a_"
23:44:43 <jsnx> i have a question about GHCi, and i asked in #ghc but no-one is around
23:45:09 <jsnx> i hope it is alright if i ask here
23:46:05 <adu> jsnx: ask away
23:46:07 <jsnx> i'm working on a file for the module Data.Foo.Baz, and it is in  ./Data/Foo/Baz.hs
23:46:17 <jsnx> I'd like to write :l D<TAB>/F<TAB>/B<TAB><NL>
23:46:24 <jsnx> but it only tab completes the first part, the directory name 'Data/',  and won't do anything after that
23:47:47 <jsnx> how do i fix it so it does tab completion on full paths?
23:47:54 <adu> jsnx: hmm you're right
23:48:12 <jsnx> oh ack
23:48:36 <adu> jsnx: are you using 6.8.2?
23:48:42 <jsnx> adu: aye
23:48:47 <jsnx> adu: and you?
23:48:52 <adu> ya
23:49:06 <jsnx> i've noticed this for awhile, though
23:49:15 <jsnx> started using ghci in 6.6 times
23:49:43 <adu> when I try it and do dir<TAB> then I can tab-complete dir/dir/dir/dir/dir/dir/dir
23:49:46 <adu> its kinda funny
23:50:13 <jsnx> it only tab completes file names from the present directory, it seems
23:55:51 <adu> jsnx: if I were you I'd start with ghc-6.8.2/compiler/ghci/InteractiveUI.hs
23:55:59 <adu> jsnx: and see where that leads
23:56:13 <jsnx> adu: thanks for the tip, i'll check that out
23:58:31 <adu> jsnx: it might have something to do with "completeWord"
23:59:09 <adu> jsnx: or "completeFilename"
