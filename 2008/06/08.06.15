00:02:55 <nus> heh, try to wrap your head around the state and find yourself reading about "the universe monad" and Leibnitz. I luv Huskill.
00:11:01 <Cale> nus: Wrong kind of monad though...
00:11:43 <nus> Cale, wrong in what sense?
00:12:00 <Cale> That sense of the term monad (the philosophical one) has a different (and more direct) etymology than the sense which is used in Category theory and Haskell.
00:12:21 <Cale> The sense used in Category theory and Haskell is a portmanteau of monoid and triad.
00:14:12 <Cale> It's unrelated to the philosophical use of the word, which comes essentially directly from greek.
00:14:32 <Cale> (meaning unit, unity)
00:15:19 <nus> Cale, ah. Actually I've been referring to therp's(?) http://clemens.endorphin.org/weblog/ where he talks about "the universe monad" which I've tried to find a reference.
00:15:20 <lambdabot> Title: clemens.endorphin.org/weblog - clemens.endorphin.org
00:15:43 <Cale> Ah, okay :)
00:15:52 <nus> Cale, the LiskellMonad, as he calls it.
00:16:13 <Cale> Yeah, of course that one's related :)
00:19:32 <Cale> Leibniz however was a few hundred years too early for the Category theory sense of the term :) But perhaps some of his mathematics has been generalised in such a way as to relate?
00:35:38 <gwern> sjanssen: btw, I've added --print-type to mueval
00:35:41 <cinimod> I've never heard monads called triads - triples yes - who used triad?
00:36:42 <gwern> the chinese
00:36:48 * gwern groans at my joke. how terrible
00:37:15 <nus> it's Pythagoreans attempt to bootstrap ontology using Church numerals (-;
00:38:59 <sjanssen> gwern: neat
00:39:38 <gwern> sjanssen: I'd do another upload, but I need to wait for the hint maintainer to incorporate my patch and upload
00:40:05 <sjanssen> gwern: meh, no need for a new release for every single new feature :)
00:41:09 * gwern belives in release early release often
00:42:16 <gwern> also, there's the optimization stuff I added, the 3 or 4 new tests, better tests, real -threaded support, and more effective watchdogs in addition to --print-type
00:42:21 * gwern hasn't had much to do tonight :)
00:55:25 <Mr_Awesome> is there an efficient way to do a map operation that also keeps track of indexes?
00:55:44 <vixey> you can zipWith _ _ [0..]
00:55:53 <vixey> that way you have a pair (element,index)
00:57:31 <Mr_Awesome> ah, indeed. there is also a zipWithM, which is what i really needed :)
00:57:34 <Mr_Awesome> thanks, vixey
00:57:45 <vixey> :t zipWithM
00:57:49 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
00:58:01 <vixey> :t sequence.zipWith
00:58:03 <lambdabot>     Couldn't match expected type `[m a]'
00:58:03 <lambdabot>            against inferred type `[a1] -> [b] -> [c]'
00:58:03 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
00:58:09 <vixey> oh, :/
00:59:40 <ski_> @type \f as bs -> sequence (zipWithM f as bs)
00:59:42 <lambdabot> forall a b c. (a -> b -> [c]) -> [a] -> [b] -> [[c]]
01:00:11 <vixey> ski!
01:00:25 <ski_> ?
01:00:28 <vixey> hi
01:00:36 <ski_> hiya
01:00:42 <vixey> I compiled my prolog toplevel today
01:00:50 <ski_> cool !
01:01:55 <ski_> > sequence (zipWithM (\a b -> [d | d <- [1..a+b] , d `mod` a+b == 0]) [1,4,5] [2,3])
01:01:57 <lambdabot>  [[]]
01:02:45 <ski_> > sequence (zipWithM (\a b -> [d | d <- [1..a+b] , d `mod` (a+b) == 0]) [1,4,5] [2,3])
01:02:47 <lambdabot>  [[3],[7]]
01:07:11 <ski_> > sequence (zipWithM (\a b -> [d | d <- [1..a+b] , (a+b) `mod` d == 0]) [1,4] [2,5])  -- er, arguments of `mod' was in the other order ..
01:07:13 <lambdabot>  [[1,1,1,3,3,3],[1,1,1,3,3,9],[1,1,1,3,3,3],[1,1,1,3,3,9],[1,1,1,1,3,3],[1,1,...
01:07:53 <vixey> what is this?
01:08:59 <ski_> i'm not sure .. just tried to see if i could find something fun using the `sequence' of a `zipWithM' call
01:09:41 <vixey> > sequence (zipWithM (\a b -> [ (a,b,d) | d <- [1..a+b] , (a+b) `mod` d == 0]) [1..5] [1..5])
01:09:42 <lambdabot>  [[(1,1,1),(1,1,1),(1,1,1),(1,1,1),(1,1,1),(1,1,1),(1,1,1),(1,1,1),(1,1,1),(1...
01:39:22 <gwern> yeesh! fixing collections took a while
01:39:46 <gwern> I hope jpb applies my patches soon before I forget to add fixed packages to hackage
03:43:20 <dafra> > 1 + 1
03:43:23 <lambdabot>  2
03:44:21 <RayNbow> > let x == y = True    in   1==2
03:44:22 <lambdabot>  True
03:44:34 <RayNbow> everything's possible in Haskell :p
03:45:26 <Syzygy|de> :t sort
03:45:28 <lambdabot> forall a. (Ord a) => [a] -> [a]
03:45:37 <Syzygy|de> > let x < y = True in sort [1,2,3,4]
03:45:39 <lambdabot>  [1,2,3,4]
03:45:44 <Syzygy|de> > let x < y = True in sort [4,2,3,1]
03:45:45 <lambdabot>  [1,2,3,4]
03:45:48 <Syzygy|de> Awwww.
03:46:00 <Syzygy|de> ?info Ord
03:46:00 <lambdabot> Ord
03:46:13 <idnar> :t sortBy
03:46:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:47:05 <idnar> > let x < y = True in sortBy (<) [4,2,3,1]
03:47:06 <lambdabot>  Couldn't match expected type `Ordering'
03:47:11 <idnar> oh
03:47:19 <idnar> > let x < y = EQ in sortBy (<) [4,2,3,1]
03:47:20 <lambdabot>  [4,2,3,1]
03:47:24 <idnar> (except that's a nonsensical name)
03:47:56 <Syzygy|de> > let 3<y = EQ; x<y = GT in sortBy (<) [4,2,3,1]
03:47:57 <lambdabot>  [3,1,2,4]
04:00:59 <DRMacIver> Hm. Can I get cabal to emit multiple executables?
04:06:09 <ToRA> DRMacIver: I'm fairly sure matthew-_ managed to do it in the cabal file for Distract
04:07:12 <Saizan> DRMacIver: use multiple Executable stanzas
04:08:58 <DRMacIver> Thanks
04:11:45 <OXIj> i need cbrt (cubic root) function, but seems haskell has only sqrt. any ideas?
04:13:28 <HunterXHunter> cube root = x^(1/3)
04:13:32 <ToRA> > 27 ** (1/3) ?
04:13:32 <lambdabot>   parse error on input `}'
04:13:39 <ToRA> > 27 ** (1/3)
04:13:40 <lambdabot>  3.0
04:14:16 <HunterXHunter> welcome to math 101
04:14:24 <OXIj> oh. i even not thought about this. thx
04:15:27 <ToRA> it's a bit like asking what the boolean xor function is in haskell...
04:15:41 <DRMacIver> It's kindof annoying that Haskell uses different operators for integer and fractional powers.
04:15:51 <DRMacIver> Although it's better than the misappropriation of ^ to mean xor. :)
04:17:19 <mxc> i know this is unrelated, but are erlang 'processes' really just threads?
04:17:28 <mxc> reading about all this "erlang style concurrency in...."
04:17:41 <mxc> i dont see how the 'processes' could actually be separate machine processes
04:17:50 <DRMacIver> They're green processes.
04:17:50 <Axman6> they aren't
04:17:58 <Axman6> green threads?
04:17:58 <DRMacIver> In much the same way that Haskell threads are green threads
04:18:02 <mxc> so basically just haskell threads?
04:18:09 <mxc> i.e. user level threads
04:18:17 <mxc> green=user level?
04:18:51 <DRMacIver> They're a bit more isolated than Haskell threads. They don't share heaps.
04:18:56 <mxc> so this whole big sh1t about erlang is basically just user level threads with message queues?
04:18:57 <DRMacIver> Yes, user level.
04:19:34 <Axman6> erlang is awesome, don't knock it
04:19:43 <mxc> isn't everything in haskell basically allocated on the stack anyway?
04:19:44 <DRMacIver> Yep. All it is is user level threads with message queues, isolated heaps, transparent distribution and extremely robust built in fault tolerance.
04:19:52 <DRMacIver> Nothing to write home about. ;)
04:19:54 <mxc> not knocking erlang
04:20:08 <DRMacIver> As far as I know GHC doesn't even use the stack
04:20:11 <mxc> just all this big sh1t about how every language in the world needs 'erlang style concurrency'
04:20:25 <Axman6> well it does
04:21:05 <DRMacIver> Haskell is as close to having erlang style concurrency as most non erlang languages get. :) But it doesn't have the fault tolerance or transparent distribution.
04:21:05 <HunterXHunter> i wish erlang had haskell style syntax
04:21:09 <HunterXHunter> makes life so much easier
04:21:31 <mxc> i'd like to see "haskell style referential transparency in..."
04:21:35 <ToRA> DRMacIver: doesn't the runtime pass arguments on the stack it knows will be strictly used that are primitive?
04:21:36 <mxc> oh wait..  haha
04:22:21 <mxc> how are the erlang processes more fault tolerant?
04:22:45 <mxc> if a haskell thread has an unhandled exception, it doesn't bring the whole thing crashing down, does it?
04:23:23 <DRMacIver> ToRA: Does it? You could be right. But the impression I'd always got was that ghc went to great lengths to avoid ever touching the stack.
04:23:31 <Axman6> mxc: the message queues use patern matching to only recieve valid data for one
04:23:39 <DRMacIver> mxc: No, but it doesn't restart automatically either.
04:23:47 <mxc> i see
04:24:02 <Axman6> so you don't get an error if you pass something that a process can't handle, it just skips it
04:25:11 <Staz> I have finished evaluating a bit of syntax using semantic algebra. I am left with the output (1,(2,output))
04:25:13 <mxc> so in that sense, no different than a fault tolerant use of Data.Binary to encode/decode messages
04:25:21 <Staz> is it ok to say this is equal to (1,2,output)
04:25:27 <Staz> just so I finish of nicely? :)
04:25:45 <mxc> i think i 'accidentally' implemented a good deal of 'erlang style concurrency' on my own without even realizing it thren
04:26:52 <DRMacIver> The individual bits of erlang style concurrency aren't that hard to do. Its advantage is that it pushes it to great extremes and does it extremely well.
04:26:59 <mxc> yeah
04:27:07 <mxc> fair enough
04:27:28 <DRMacIver> No one is saying that a shared nothing actors model is hard to write. Particularly in a language where you already have immutable data for free.
04:27:30 <mxc> i do actually detest people who underestimate the value of small conveniences in languages
04:27:56 <mxc> like, "so what, you have lambdas? we have function pointers" ok, but the ease of use makes a huge difference
04:28:13 <mxc> so i'm with you on htat
04:28:18 <DRMacIver> Incidentally, one instance of where Haskell threads *can* bring the whole system crashing down and erlang processes can't is what happens if you run out of memory
04:28:34 <mxc> really?
04:28:42 <mxc> pretty impresive that erlang can handle that
04:28:43 <DRMacIver> Erlang heaps are local to the process.
04:29:01 <DRMacIver> So if you run out of memory in one process it just dies and gets restarted.
04:29:04 <mxc> so just one process dies?
04:29:09 <DRMacIver> Right
04:33:02 <Axman6> erlang is very impressive
04:34:09 <mxc> isn't erlang not statically typed?
04:34:26 <Axman6> from what i can tell, no
04:34:26 <mxc> i'm basically bathing in the HM coolaid
04:34:35 <Axman6> which annoys me too
04:34:45 <Axman6> since i started with haskell (like 5 months ago...)
04:34:48 <mxc> static typing just eliminates HUGE classes of errors
04:35:04 <mxc> i've noticed in haskell and ocaml, once you compile, your basically 90% done
04:35:13 <mxc> in other languages, its closer to 10%
04:35:31 <mxc> although, i dont have much experience with dynamically typed, FP so i could be wrong
04:36:35 <DRMacIver> I think that's an instance of preaching to the choir. :)
04:37:09 <mxc> the choir tends to be the friendliest audience
04:37:33 <Axman6> shut up!
04:37:36 <Axman6> >_>
04:37:39 <mxc> ?
04:37:50 <mxc> i love the BDSM analogy to typing
04:38:03 <mxc> dynamic typing = S&M.  freedom, but lots of pain
04:38:29 <mxc> static = B&D:  less control, but no pain.  freedom through slavery etc
04:38:45 <mxc> forget where i saw that
04:43:14 <dancor> @pl \ x -> f x ++ g x
04:43:14 <lambdabot> liftM2 (++) f g
04:43:54 <dancor> @pl \ x -> f x ++ g x ++ h x
04:43:55 <lambdabot> liftM2 (++) f (liftM2 (++) g h)
04:44:05 <dancor> @type liftM2 (++) f (liftM2 (++) g h)
04:44:08 <lambdabot> forall (m :: * -> *) a1. (Monad m, SimpleReflect.FromExpr (m a1), Monoid a1) => m a1
04:46:25 <dancor> i'm surprised that doesn't generalize better
04:46:29 <dancor> i bet it does
04:46:31 <Axman6> @type \x -> x
04:46:32 <lambdabot> forall t. t -> t
04:46:35 <Axman6> :o
04:46:57 <dancor> oh, concat . map ($ x)
04:47:18 <dancor> wait no, i want it in terms of the functions
04:47:22 <dancor> i don't know what i want
04:49:38 <mxc> what does @pl do?
04:50:28 <dancor> converts to point-free style
04:50:59 <dancor> @pl \ f g -> f x ++ g x
04:50:59 <lambdabot> (. ($ x)) . (++) . ($ x)
04:51:40 <dancor> http://www.haskell.org/haskellwiki/Pointfree
04:51:41 <lambdabot> Title: Pointfree - HaskellWiki
04:52:34 <mxc> cool
04:52:42 <mxc> pl = pointless?
04:52:48 <mxc> hehe
04:52:48 <dancor> yes
04:52:48 <mxc> :)
04:53:08 <dancor> so you don't use it without realizing it is often silly
04:54:00 <mxc> @pl \x y -> x + y
04:54:01 <lambdabot> (+)
04:54:30 <HunterXHunter> very pointless :P
04:54:50 <Axman6> @pl \f g x -> f (f x ++ g x)
04:54:50 <lambdabot> liftM2 (.) (.) (liftM2 (++))
04:55:09 <mxc> does pointless programming in haskell impose the same performance penlaty as in ocaml:  http://ocaml.janestcapital.com/?q=node/30
04:55:10 <lambdabot> Title: The dangers of being too partial | ocaml.janestreet.com
04:55:35 <dancor> mxc: idk but probably not, it's really common
04:55:41 <Axman6> @pl \f g x -> (g (g x ++ f x)) ++ (f (f x ++ g x))
04:55:42 <lambdabot> ap (ap . (liftM2 (++) .) . ap (.) . flip (liftM2 (++))) (liftM2 (.) (.) (liftM2 (++)))
04:56:10 <Axman6> @pl \f g x -> (g (g x ++ f x)) . (f (f x ++ g x)) x
04:56:11 <lambdabot> ap (ap . (liftM2 (.) .) . ap (.) . flip (liftM2 (++))) (flip flip id . (ap .) . liftM2 (.) (.) (liftM2 (++)))
04:56:28 <Axman6> @pl \f g x -> (g (f . g x ++ f x)) . (f (f x ++ g x)) x
04:56:30 <lambdabot> ap (ap . (liftM2 (.) .) . ap (.) . (flip =<< (liftM2 (++) .) . (.) . (.))) (flip flip id . (ap .) . liftM2 (.) (.) (liftM2 (++)))
04:56:51 <Axman6> i don't even know what this doing any more, it's just fun seeing how long it takes lambdabot
04:56:59 <Axman6> @pl \f g x -> (g (f . g x ++ f x)) . (f (g . f x ++ g x)) x
04:57:01 <dancor> @dos
04:57:03 <lambdabot> ap (ap . (liftM2 fmap .) . ap (.) . (flip =<< (liftM2 (++) .) . (.) . (.))) (flip flip id . (ap .) . liftM2 (.) (.) (join . ((ap . ((++) .)) .) . flip ((.) . (.))))
04:57:03 <lambdabot> optimization suspended, use @pl-resume to continue.
04:57:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
04:57:48 <dancor> pl-resume to continue trying to optimize that particular one?
05:01:07 <telexicon> hmm
05:01:09 <telexicon> haskell
05:05:29 <olsner_> @pl-resume
05:05:30 <lambdabot> ap (ap . (liftM2 fmap .) . ap (.) . (flip =<< (liftM2 (++) .) . (.) . (.))) (flip flip id . (ap .) . liftM2 (.) (.) (join . (liftM2 (++) .) . flip ((.) . (.))))
05:06:02 <stevan> is there any reason for using the time module over the old-time module?
05:12:58 <dancor> stevan: i imagine the reasons are the same for why the new time module was written :)
05:14:52 <stevan> is the old one broken in some respect or is it just a matter of taste (the interfaces are a bit different)?
05:16:21 <Sadache> hello
05:16:53 <Sadache> can someone point me to an easy way to install a good haskell editor on windows
05:17:24 <dancor> Sadache: i think most people use emacs or vim
05:17:38 <dancor> stevan: i can't tell or find anything on google
05:17:44 <Sadache> i tried to install emacs and vm but it never worked for me, yes i am a used to installers on windows
05:19:35 <Sadache> any simple way to configure emacs for haskell?
05:19:53 <stevan> dancor: me neither, that's why i asked here. :-) i'm not sure if the "old-" prefix should be interpreted as a warning or not...
05:20:22 <Sadache> i ve got emacs 22.2
05:20:54 <Sadache> and haskell-mode-2.4
05:22:32 <Sadache> but i couln't get to configure it
05:23:25 <stevan> @google emacs haskell mode
05:23:25 <lambdabot> http://www.haskell.org/haskell-mode/
05:23:26 <lambdabot> Title: Haskell Mode for Emacs
05:29:47 <Sadache> it talks about an init file that i dont find
05:31:57 <ttt--> you can just make an empty .emacs file in your home directory
05:32:16 <ttt--> and add the lines like that web site says
05:33:05 <Sadache> ok i ll try that
05:39:43 <Sadache> ttt--: an empty file with the name .emacs in the bin directory works?
05:40:56 <Sadache> i added an init.el with the lines inside in the bin directory next to the emacs.exe but it doesnt work
05:42:36 <stevan> @google home directory windows
05:42:38 <lambdabot> http://en.wikipedia.org/wiki/Home_directory
05:43:19 <ttt--> it has to be named ".emacs", i think
05:43:52 <Sadache> windows does not allow an extension without a name
05:44:22 <Axman6> haha
05:44:56 <wjt> oh, is this why _darcs is so-called?
05:45:00 <olsner_> Sadache: it does though, explorer just won't let you do it in the GUI
05:52:07 <Sadache> olsner_: and how to do it otherwise... :s
05:52:14 <olsner_> cmd :)
05:53:09 <olsner_> hmm, otoh, I think they might've called the file _emacs on windows
05:55:58 <hukolele> "seq" does work as expected also in ghc interactive mode??
05:57:45 <aCiD2> you can use .emacs
06:03:58 <tobias_tud> has IOUArray some limitations? if i switch from IOArray to IOUArray, then x <- newArray (1, size^4) (Set 1) causes an error No instance for (MArray IOUArray Cell IO)
06:04:47 <tobias_tud> in the wiki they said, you can switch from IOArray to IOUArray just by replacing the types
06:05:21 <Sadache> i put the _emacs file in my home directory, and wrote the lines indicated pointing to the haskell-mode in the home directory and it still does not work
06:05:34 <Sadache> I open emacs and it does not even color haskell code
06:06:47 <hukolele> Sadache: do you use xemacs over win? or linux? anyway I think it must be .emacs not _emacs
06:06:57 <Lemmih> tobias_tud: UArray is only for types that can be unboxed.
06:07:07 <Sadache> i am using emacs on windows xp
06:07:32 <tobias_tud> so, own datatypes are incompatible with IOUArray?
06:07:51 <mapreduce> .emacs not _emacs, yes
06:08:14 <hukolele> Sadache: I use xemacs on winxp, and I have colored code
06:08:27 <Lemmih> tobias_tud: Yes.
06:08:56 <hukolele> just following the instructions on the readme file of the haskell-mode package
06:12:05 <hukolele> maybe you must add "(add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock)" to your .emacs file to colouring your code
06:15:03 <hukolele> Sadache: you can try also to manually enter in emacs "M-x turn-on-font-lock"
06:17:33 <tobias_tud> Lemmih: Is it possible to have an IOUArray Int (IOUArray Int Int) ?
06:17:48 <hpaste>  fredo pasted "exercise 11.16 a" at http://hpaste.org/8346
06:18:35 <Lemmih> tobias_tud: I doubt it.
06:19:14 <tobias_tud> hm, is there a two dimensional IOUArray?
06:26:43 <Toxaris> tobias_tud: use (Int, Int) as index?
06:28:38 <Toxaris> tobias_tud: i.e. IOUArray (Int, Int) Int
06:28:54 <tobias_tud> thx
06:29:12 <igel> instance (Ix a, Ix b) => Ix (a, b)
06:29:14 <igel> ^^
06:29:15 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8347
06:32:19 <Toxaris> > map (abs . uncurry (-)) [(3, 5), (5, 3)]
06:32:22 <lambdabot>  [2,2]
06:33:07 <Toxaris> > map rangeSize [(3, 5), (5, 3)]
06:33:09 <lambdabot>  [3,0]
06:41:19 <tobias_tud> Toxaris: and how can i create a new array? my intention doesn't work
06:42:49 <Toxaris> tobias_tud: myArray <- newArray ((0, 0), (5, 10)) 0
06:43:20 <Toxaris> tobias_tud: in a do block in the IO monad, creates an array with the given size and initial elements of value 0
06:44:33 <Toxaris> > rangeSize ((0, 0), (5, 10))
06:44:34 <lambdabot>  66
06:44:39 <Toxaris> with a total of 66 elements :)
06:45:48 <tobias_tud> my intention was correct, but this causes an error: lala = do	myArray <- newArray ((0, 0), (5, 10)) 0	return myArray
06:46:25 <tobias_tud> ah
06:46:28 <tobias_tud> ok, it works
06:46:38 <tobias_tud> thank you
06:46:43 <Toxaris> :t do {myArray <- newArray ((0, 0), (5, 10)) 0; return myArray}
06:46:46 <lambdabot> Not in scope: `newArray'
06:46:49 <Toxaris> :(
06:48:12 <Toxaris> tobias_tud: make sure you specify the types somewhere, so that the newArray call is known to create an IOUArray, not some other variant of MArray
06:49:08 <Toxaris> tobias_tud: e.g. createMyArray :: Int -> Int -> IO (IOUArray (Int, Int) Int); createMyArray m n = newArray ((0, 0), (m - 1, n - 1)) 0
06:50:20 <CVirus> data Poly = [Int] ... is this possible ?
06:51:24 <Tigran> CVirus: You need to provide a constructor name, or use type/newtype
06:51:35 <Tigran> data Poly = P [Int]
06:51:42 <CVirus> any other way ?
06:51:42 <Tigran> Or type Poly = [Int]
06:52:37 <CVirus> thanks
06:52:46 <panzi> hi
06:54:56 <panzi> I have to write a parser with parsec (actually it's not parsec but a minimal clone; it works the same way) that parses a grammatic and returns the parsed tokens as a list. if there is an invalid token a special token (Err) has to be appended to this list and parsing shall end
06:55:39 <panzi> but parsec is abacktracking parser. if there is a invalid token, it starts backtracking (which is good, normally)
06:56:53 <panzi> if a token (Err) is returned on an error parsing continues, but the Err token shall eat all remaining input (so says the assignment). but when my expression needs another token following the current one, the expression will fail
06:57:07 <panzi> so all I get in the case on an error is [Err]
06:57:45 <panzi> no other parsed token is returned because no whole expression could be parsed and hence the backtracking the already parsed parts of the expression are discarded
06:57:59 <panzi> does anyone know a solution to this kind of problem?
06:58:22 <panzi> a simple lexer would work, but that would not validate the grammer
06:58:22 <TomMD> does anyone else have a problem doing 'cabal install hunit'?
07:02:52 <tobias_tud> is there a fast and memory efficient way to write some Ints into a text file?
07:06:07 <hpaste>  tobias_tud pasted "write ints to text file" at http://hpaste.org/8348
07:06:28 <tobias_tud> has anyone ideas how to improve this function?
07:06:38 <Lemmih> tobias_tud: Does the encoding matter?
07:06:56 <CVirus> got a haskell exam tomorrow ffs
07:07:15 <CVirus> can't I take this channel with me :-p
07:07:16 <tobias_tud> the encoding? it must be a text file. it should be human readable
07:07:46 <Lemmih> tobias_tud: hPutStr handle $ unwords $ map show intLst
07:08:12 <tobias_tud> thanks Lemmih, i'll try it
07:12:25 <TomMD> CVirus: Which uni?
07:13:25 <CVirus> TomMD: German University in Cairo
07:13:28 <tobias_tud> Lemmih: your code is better, instead 6.5% of running time, only 4% and uses only 5.5% alloc inseat of 12%. nice function :-)
07:13:47 <CVirus> TomMD: tell me you're studying there too :-D
07:13:48 <HunterXHunter> you're so lucky! we get C and java tests :(
07:13:58 <TomMD> CVirus: Nope, not studying right now, sorry.
07:13:58 <CVirus> same too
07:14:11 <CVirus> HunterXHunter: tomorrow's exam is C, Prolog and Haskell
07:14:19 <TomMD> But I was stuck with Dynamic C in my undergrad career, so you are lucky
07:14:22 <CVirus> HunterXHunter: Java exam next week
07:14:23 <HunterXHunter> wow nice
07:14:37 <HunterXHunter> we only ever learned c and java
07:14:42 <TomMD> CVirus: A languages course?
07:14:50 <CVirus> it's not really nice to learn 3 programming languages 14 hours before the exam
07:14:55 <CVirus> TomMD: concepts of programming languages
07:15:14 <TomMD> Have you learned any that have no ability to dynamically allocate memory?
07:15:50 <CVirus> can Haskell dynamically allocate memory ?
07:15:54 <TomMD> Yep
07:15:58 <CVirus> I see
07:16:01 <CVirus> no then
07:16:09 <HunterXHunter> me neither
07:16:15 <TomMD> I suppose I should have said:
07:16:17 <TomMD> ?faq
07:16:17 <lambdabot> The answer is: Yes! Haskell can do that.
07:16:18 <dolio> How many are there?
07:16:31 <dolio> C doesn't, but it has library routines for it.
07:16:33 <CVirus> never heard about any
07:16:41 <TomMD> dolio: I've only ever used one such language (dynamic C, the word dynamic I'm sure was a joke)
07:16:44 <CVirus> you can dynamically allocate memory in C
07:16:47 <HunterXHunter> ?fag can haskell dynamically allocate memory?
07:16:48 <lambdabot> The answer is: Yes! Haskell can do that.
07:17:18 <HunterXHunter> ?can haskell dynamically allocate memory?
07:17:19 <lambdabot> Maybe you meant: faq map run wn
07:18:10 <TomMD> ?faq Can Haskell provide strict resource limits, making it useful for embedded environments?
07:18:10 <lambdabot> The answer is: Yes! Haskell can do that.
07:18:18 <TomMD> I think lambdabot lies
07:18:20 <dolio> Heh.
07:18:40 <ivanm> TomMD: sure it can... _if_ you write a library, etc. for it to do so :p
07:19:04 <TomMD> ivanm: I think there are fundamental concepts missing from the language
07:19:08 <dolio> Anyhow, it depends on whether you consider malloc/etc. as part of "C the language."
07:19:16 <TomMD> You would need an extension to do what I would want it to do.
07:20:52 <TomMD> dolio: When I have to do without malloc, I don't generally consider the task 'C' - it is easier if management understand that there is a difference between developing a *nix app in 'C' and developing something embedded that can't make use of any common libraries in 'C'.
07:21:30 <dolio> Sure.
07:21:56 <slowriot> Sorry for this non-haskell question. I'm trying to program my own lock algorithms in C#. Where would be a good place to go to ask questions when I need help?
07:22:23 <luite> you join #haskell just for that? :)
07:22:34 <TomMD> lock?  What is this, the dark ages, why doesn't this billion dollar language have a good implementation of STM?
07:22:37 <slowriot> yeah, you guys are smart
07:22:50 <slowriot> TomMD: It probably does
07:22:51 <panzi> ?faq can haskell smoke pot?
07:22:52 <lambdabot> The answer is: Yes! Haskell can do that.
07:22:59 <slowriot> heh
07:23:03 <slowriot> actually, I don't know
07:23:07 <luite> slowriot: what kind of locking do you need?
07:23:14 <panzi> I think the bot allways answers yes
07:23:19 <slowriot> I'm coding a bakery lock, but I'm having deadlock trouble
07:23:20 <dolio> I just think that's one of the interesting quirks about C. The language proper doesn't do a whole lot of anything. "Everything is a library" might be its slogan.
07:23:23 <TomMD> All I can say is "look for the C# room".  I really don't know anything about C# beyond "Its just Java!" which isn't really true anymore.
07:23:42 <Tigran> slowriot: Probably try ##csharp
07:24:05 <slowriot> yeah, I don't think anyone there knows about multithreading, except giraffe
07:24:33 <TomMD> whats there to know?  Just "cabal install dph"
07:24:37 <hpaste>  adrian neumann pasted "Lindenmayer System" at http://hpaste.org/8349
07:25:18 <slowriot> I just need to find someone knowledgable about lock algorithms and multithreading in general
07:26:03 <slowriot>  maybe #C ?
07:26:06 <slowriot> or #C++ ?
07:27:04 <pejo> TomMD, have you seen Hume for example?
07:27:10 <gubagem> how about Java++
07:27:41 <dolio> There used to be a J++. Maybe there still is.
07:28:03 <dolio> It was just a Microsoft implementation of Java with its proprietary libraries, though.
07:28:11 <gubagem> :-(
07:28:26 <luite> slowriot: but you already know the algorithm, right? there must be pseudocode for it that should be relatively straightforward to translate to C#. you might also want to have a look at other, simpler, algorithms, like Peterson's (wikipedia?)
07:28:37 <dolio> They probably ditched it some time after C# came out.
07:28:51 <slowriot> luite: I do have psuedocode for it
07:29:22 <Tigran> slowriot: Is this an assignment that requires the use of lamport's?
07:29:33 <Tigran> If not, I'd suggest something a little higher level
07:29:35 <slowriot> luite: first I read over the algorithm and gained an understanding of it. Then I coded it. Then I reviewed the code against the pseudo code that I'm using as reference. Still can't figure out what's wrong.
07:29:50 <monochrom> <3 #haskell
07:29:58 <slowriot> Tigran: nope. I'm just trying to learn about multithreading
07:30:41 <Tigran> I'm afraid I don't know much about lamport's in particular, but I'm sure there's people here that can help with general concurrency problems
07:31:01 <Tigran> As mentioned eariler, you might want to consider looking into petersons, deckers, semaphores, monitors etc.
07:31:03 <TomMD> pejo: Hume? No.  Link?
07:31:14 <mar77a> how can i load more than one module when using ghci?
07:31:29 <Tigran> mar77a: :m +<modulename>
07:31:30 <Zao> import or :m +
07:31:56 <luite> slowriot: hm, I don't have enough experience with C# to know what's going on. it might be that some shared data might be cached locally for each thread, so that updates are not visible outside the thread. you usually need some platform or language constructs to force these updates (synchronized in java, volatile in C)
07:32:09 <slowriot> Tigran: I could do that. But I would still have a gap in my understanding of multithreading. Wouldn't it be better just to solve the problem I am currently having?
07:32:20 <Tigran> slowriot: I guess it also comes down to whether you're interested in low level concurrency ideas: Mutex/Cond. Syn, or higher level, like managing threads and processes
07:32:37 <TomMD> mar77a: After loading too many modules you probably want to ":set prompt blah"
07:32:50 <Tigran> True, but there doesn't appear to be anyone around that can help!
07:33:00 <pejo> TomMD, www.hume-lang.org
07:33:03 <XGas> Why is the ghci's usage format very similar to vim?
07:33:11 <TomMD> pejo: thanks, I'll look
07:34:32 <monochrom> I once read the Java spec. If a variable is not declared "synchronise", the computer is not obliged to ensure all threads see the same value. Perhaps same for C#.
07:34:46 <luite> monochrom: yep that's what I said ;)
07:34:55 <Tigran> It's actually worse than that
07:35:41 <Tigran> There's no garuntee that from the perspective of other threads, that the update has happened, nor that there is atomicity for non-volative fields, or that the ordering of critical sections is preserved
07:36:14 <Tigran> Having said that, it's not as if anyone really programs anything large scale and concurrent in Java using low level algorithms
07:36:15 <monochrom> One way to look at it is the computer is allowed multiple physical copies. Lamport's algorithm assume one physical copy. (Actually probably Lamport's assumes something weaker, but still confounded by blatantly multiple unsync'ed physical copies.)
07:37:31 <luite> And a non-final member variable might not be initialized if used from non-synchronized methods: so even if the constructor returned, the object might not be fully initialized when used in another thread
07:39:31 <monochrom> Don't try to play with classical critical-section algorithms with Java and C#. The classical algorithms are intended for bare metal.
07:40:23 <Tigran> Monitors work well for corse-grained concurrency
07:40:38 <Tigran> And fine-grained can be handled with java.util.concurrent
07:42:04 <Tigran> (Assuming you're using Java ofc, no idea about C#)
07:42:46 <dolio> Man, we even get beat by CAL on fannkuch.
07:44:42 <slowriot> pastebin doesn't seem to be working
07:45:27 <dolio> Looks like it's working here.
07:45:42 <slowriot> oh, wrong channel
07:45:49 <monochrom> haha
07:47:44 <slowriot> I ended up using hpaste anyway
07:47:51 <slowriot> my code is here if anyone is interested: http://hpaste.org/8350
08:21:09 <hpaste>  tobias_tud pasted "performance problem?" at http://hpaste.org/8351
08:21:39 <tobias_tud> perhaps anybody knows why this function is so slow?
08:21:45 <tobias_tud> (ony 4 lines)
08:22:34 <tobias_tud> and why this function needs 50% of alloc
08:23:34 <Saizan> you've to add the definition of Sudoku and removePossibility
08:23:48 * Staz is the semantics master now! :)
08:24:02 <Staz> Spent the entire day evaluating simple programs
08:24:22 <Staz> and I understand continuations now :)
08:24:57 <hpaste>  tobias_tud pasted "performance problem?" at http://hpaste.org/8352
08:25:02 <dafra> CAL is fast thanks to java native aeeays
08:25:05 <dafra> arays
08:25:39 <dafra> maybe dons's uvector will speed up Haskell(s fannkuch
08:27:14 <tobias_tud> Saizan: do you have an idea? removePossibility is really fast, but removePossibilities is slow
08:28:30 <Saizan> tobias_tud: no, sorry
08:28:47 <rwbarton> maybe removePossibility is getting inlined into removePossibilities, which is confusing the profiler
08:30:03 <tobias_tud> so you think removePossibility is the slow function?
08:30:10 <rwbarton> i.e., it's really removePossibility that's using all the time and space
08:30:30 <rwbarton> I mean, since removePossibilities basically does nothing but call it
08:31:04 <gort> @pl scanm f z xs = zipWith f (scanl f z xs) (tail $ scanr f z xs)
08:31:04 <lambdabot> scanm = ap (ap . (ap .) . ap ((.) . (.) . zipWith) scanl) (((tail .) .) . scanr)
08:31:43 <gort> eek
08:31:58 <dafra> @src ap
08:31:58 <lambdabot> ap = liftM2 id
08:32:48 <gort> @type ap
08:32:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:33:02 <tobias_tud> hm. but the profiler tell me how much time it spends on removePossibility.
08:34:06 <dafra> @pl maxa a b = if a < b then b else a
08:34:06 <lambdabot> maxa = flip =<< join . (if' .) . (<)
08:34:40 <dafra> @pl mina a b = if a < b then a else b
08:34:40 <lambdabot> mina = join . (flip =<< (if' .) . (<))
08:35:23 <rwbarton> you can try adding {-# NOINLINE removePossibility #-} anyways, I guess
08:44:53 <tobias_tud> rwbarton: this doesn't change the profile file
08:46:13 <tobias_tud> okay, one other question: has anyone experience about telling ghc to use the intel c compiler?
08:47:55 <tobias_tud> i'd like to know if i use the intel c compiler, the binary runs faster on intel core quad machines
08:47:58 <monochrom> ghc probably assumes gcc all long.
08:48:19 <pejo> tobias, unless someone has 'fixed' the evil mangler for icc it will probably run a lot slower than with gcc.
08:49:24 <tobias_tud> hm, okay, thanks. icc stands for what?
08:49:30 <pejo> monochrom, icc supports a bunch of gcc-extensions, the linux kernel can be compiled with it for example.
08:49:44 <pejo> tobias, intel c compiler
08:49:49 <tobias_tud> ah, ok :-)
08:50:02 <monochrom> Oh, oops, nice.
08:51:17 <Botje> @instances Monoid
08:51:29 <monochrom> remark. "evil mangler" modifies assembly code by turning more recursive calls to jumps.
08:51:33 <lambdabot> Couldn't find class `Monoid'. Try @instances-importing
08:51:45 <Botje> uh?
08:51:50 <Botje> @instances-importing Monoid
08:52:04 <monochrom> @bot
08:52:05 <lambdabot> Couldn't find class `Monoid'. Try @instances-importing
08:52:05 <lambdabot> :)
08:52:08 <Botje> did \bot get lobotomized?
08:53:05 <panzi> ?faq forall
08:53:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:53:17 <panzi> ?faq what is forall
08:53:17 <lambdabot> The answer is: Yes! Haskell can do that.
08:53:43 <monochrom> I'll see if I can find the appropriate haskellwiki pages for you.
08:54:19 <monochrom> panzi: http://www.haskell.org/haskellwiki/Rank-N_types
08:54:20 <lambdabot> Title: Rank-N types - HaskellWiki
08:56:19 <panzi> ic
08:58:09 <tobias_tud> can i access one IOArray in several threads?
08:58:56 <sarehu_> safely?
08:58:57 <Baughn> tobias_tud: Yes, but you'd have to synchronize access
08:59:33 <Baughn> tobias_tud: Try to do whatever you're doing functionally instead?
08:59:38 <Baughn> (What /are/ you doing?)
08:59:39 <tobias_tud> and if one will access only the left side and the other the right side?
09:00:04 <Baughn> tobias_tud: Grey area. It /might/ be fine, but there is no guarantee of safety.
09:01:00 <tobias_tud> Baughn: i changes a very big array very often and it takes too much time
09:01:13 <sw17ch> tobias_tud, will a zipper not work?
09:02:00 <shapr> @yow
09:02:00 <lambdabot> Couldn't find fortune file
09:02:03 <shapr> @quote
09:02:03 <lambdabot> bos says: * bos is 6 months old, and can lift small buildings (after a bottle of milk) // Botje> bos: .. into what monad?
09:02:06 <tobias_tud> sw17ch: i'm confused, how should me help zip?
09:02:20 <sw17ch> a zipper is a structure, not the compression format
09:02:22 <tobias_tud> Baughn: so... should i try that? :-)
09:02:30 <sw17ch> hehe, let me find the article...
09:02:30 <monochrom> IOArray is not the fastest. IOUArray is the fastest.
09:02:42 <sw17ch> http://en.wikibooks.org/wiki/Haskell/Zippers
09:02:58 <monochrom> also http://www.haskell.org/haskellwiki/Zipper
09:02:58 <lambdabot> Title: Zipper - HaskellWiki
09:03:29 <sw17ch> though, i'm not sure how you'd do this with multiple threads... :)
09:03:32 <Baughn> tobias_tud: You'll have to ask wiser heads than me. My intuition claims it will be fine, but I have no /evidence/, and it could equally well be the worst sort of bug.
09:03:55 <Baughn> tobias_tud: Personally, I'd try to rework the algorithm so you don't need to do that
09:04:11 <tobias_tud> ah, thx.
09:04:52 <Baughn> tobias_tud: Did you write it yourself? By your description, it sounds very much like an algorithm intended for an imperative language. Not an ideal fit for haskell..
09:04:54 <tobias_tud> IOUArray is faster... but i have currently no idea how to change it
09:05:41 <mrd> i've written algorithms using multiple threads and one array
09:05:54 <mrd> like merge, which is divide-and-conquer
09:06:07 <Baughn> IOUarray is faster in some situations. You can't tie the knot with an IOUarray, though...
09:06:17 <Baughn> Sometimes just an Array will do fine
09:06:18 <tobias_tud> i've just started learning haskell three weeks ago. and my team said we should use haskell (but the team never coded one line). but my solver is fast. two minutes for a 15x15 sudoku (instead of a normal 3x3 sudoku)
09:06:30 <monochrom> onoes
09:06:58 <shapr> tobias_tud: Yay! Keep on learning!
09:07:12 <sw17ch> tobias_tud, very good
09:07:59 <sw17ch> tobias_tud, I'd encourage you to keep working on this language even after your project is finished. This was (and continues to be) the most gratifying language I've ever learned.
09:07:59 <tobias_tud> yeah, but i have to do it in 30 seconds and the only thing that needs time is to remove the possibilities :-(
09:08:02 <monochrom> We need a drinking game for sudoku, web app, and project euler.
09:08:24 <sw17ch> monochrom, would that be the race to 0.13 ? :)
09:08:29 <dolio> 15x15 instead of 3x3? Does that mean the entire grid is like 255x255 instead of 9x9?
09:08:38 <monochrom> What is 0.13?
09:08:57 <tobias_tud> you have 255 possibilities each cell instead of 9
09:08:59 <sw17ch> http://xkcd.com/323/
09:08:59 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
09:09:12 <dolio> Er, 225, even.
09:09:16 <edward1> dolio: i wrote some larger sudoku puzzles for a LINGUIST contest a couple years back
09:09:21 <monochrom> haha ok
09:09:30 <mrd> generalized sudoku is NP-hard, no?
09:09:35 <tobias_tud> i like haskell, but i hate haskell's arrays ;-) just confusing for a c++ programmer
09:09:38 <edward1> http://linguistlist.org/donation/fund-drive2006/games-puzzles/mega.cfm
09:09:39 <lambdabot> http://tinyurl.com/6k7z2v
09:09:47 <sw17ch> tobias_tud, I try not to use arrays
09:09:55 <sw17ch> only when there's absolutely no other way to do it
09:10:56 <tobias_tud> but i often have to change a value in the grid. so, is there a way around?
09:10:58 <dolio> edward1: So, that's a yes, then. n^2 blocks of n^2 cells.
09:11:04 <edward1> dolio: yeah
09:11:28 <monochrom> not sure why a sudoku solver needs many threads.
09:11:36 <shapr> Can be parallel?
09:11:36 <monochrom> oh, nevermind, multiple cores.
09:11:57 <edward1> dolio: and nothing restricts you to integers for keys, after all you only use the uniqueness of elements out of a set, so http://linguistlist.org/donation/fund-drive2006/games-puzzles/lingoku.cfm is valid as well
09:11:58 <lambdabot> Title: Lingoku, http://tinyurl.com/5pbh9h
09:12:16 <monochrom> I'm still using a single core computer and there is no parallelism benefit no matter how many thousand threads you throw at it.
09:12:33 <dolio> Heh.
09:12:44 <mrd> monochrom: get with the program!
09:13:04 * dolio is in the same boat.
09:13:20 <monochrom> My laptop doesn't even have separate video ram.
09:13:37 <mrd> actually this machine is an old Athlon too
09:15:08 <mrd> tobias_tud: well, you can certainly use multiple threads and access the same array.  the usual cautions apply, as you don't know when some piece of code is going to run relative to another.
09:15:34 <mrd> you may get enough speed-up just by using IOUArrays
09:16:25 <monochrom> Parallelized soduko solver (or any parallelized backtracking search) should not use one single array. The single array defeats the parallelism.
09:16:37 <rwbarton> tobias_tud: in your paste, I think the line "writeArray sudoku i (Unset b)" is unnecessary
09:16:58 <tobias_tud> i test it
09:17:13 <monochrom> Now that you decide to use multiple arrays, it is also questionable whether you need them mutable or not.
09:17:34 <sw17ch> tobias_tud, well, as long as your operations on the array are mostly sequential, a zipper structure will work great for you
09:17:35 <rwbarton> also, you could move the mapM_ to inside the second case in readPossibility so you only do the "readArray sudoku i" once
09:17:48 <sw17ch> honestly, i hate sudoku, so i don't have a clue how you'd write a solver for it :)
09:18:11 <monochrom> Just think of it as Chess search :)
09:18:29 <sw17ch> oh, well okay :)
09:18:37 * monochrom logs on to a US DoD computer and plays tic-tac-toe.
09:19:20 <mrd> sudoku would be somewhat different from a chess game search, which is usually some form of alpha-beta mini-max
09:19:24 <monochrom> This is a newer version than before, so launch_missiles :: STM () is safer. :)
09:19:25 <tobias_tud> ah, thanks for these useful information. (i hate sudokus, too), but i can win a prize if i'm the best :-).
09:19:27 <mrd> since you don't play an opponent
09:20:20 <shapr> tobias_tud: Win the prize!
09:20:54 <sw17ch> tobias_tud, best of luck, but i must go see the inlaws now...
09:20:57 * sw17ch slinks away...
09:21:04 <shapr> oboy
09:21:05 <tobias_tud> thanks
09:21:11 * shapr throws speed lambdas
09:21:22 <shapr> hoi swiert
09:23:41 <DRMacIver> Huh. "can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)" is probably a bad sign, isn't it?
09:23:50 <DRMacIver> (on trying to use hsmagick for something)
09:25:10 * edward1 finally figured out where the definition for dialgebras that led him down the wrong path. they treat bialgebras as dialgebras over the product category, not dialgebras in the base category.
09:28:19 <shapr> @users
09:28:19 <lambdabot> Maximum users seen in #haskell: 458, currently: 458 (100.0%), active: 16 (3.5%)
09:32:40 <tobias_tud> wow, removePossibilities is amazing fast :-). i just changed the logic and... wow. only 3gb alloc instead of 5gb and... wow, only 8% of execution time. and... WOw, thanks for your really useful information :-)
09:33:19 * shapr boings
09:37:58 <Baughn> Still mostly lurkers, though
09:45:38 <edwardk> um, what is the difference between the constructors HsPRec and HsPApp in Language.Haskell.Syntax?  http://cvs.haskell.org/Hugs/pages/libraries/haskell-src/Language-Haskell-Syntax.html i guess i just don't get what a labelled pattern is?
09:45:39 <lambdabot> http://tinyurl.com/6ep4y2
09:45:56 <edwardk> they are both constructors in HsPat
09:49:47 <pejo> Does anyone happen to know how to nest 2 case-statements in haskell.sty? I get a very weird placement of the "of" for the first case-statement.
09:50:18 <shapr> edwardk: Already seen "HsPRec HsQName [HsPatField]	labelled pattern" and "HsPApp HsQName [HsPat]	data constructor and argument patterns" ?
09:50:30 <edwardk> yeah
09:50:40 <edwardk> trying to figure out what they represent though
09:50:50 <Baughn> edwardk: I think it's supposed to be "labelled /record/ pattern"
09:50:53 <edwardk> prettyPrec p (HsPApp n ps) = parensIf (p > 1) $ myFsep (pretty n : map pretty ps)
09:51:00 <mattam> Records ?
09:51:07 <shapr> My first guess it's foo input@(Foo x y) =
09:51:15 <edwardk> prettyPrec _ (HsPRec c fields) = pretty c <> (braceList . map pretty $ fields)
09:51:16 <edwardk> ahh
09:51:23 <edwardk> PRec is for records then?
09:51:24 <Baughn> shapr: Isn't that HsPAsPat?
09:51:33 <shapr> oh
09:51:34 <shapr> hm
09:51:57 <Baughn> It's just, we have HsPRec HsQName [HsPatField]
09:51:58 <edwardk> Baughn: sorry yeah that makes perfect sense
09:52:11 <Baughn> And HsPatField is marked as "An fpat in a labeled record pattern"
09:52:26 <edwardk> ok, makes perfect sense
09:52:57 <Baughn> ..I don't think I've seen one of those in the wild,though. How would it look, textually?
09:53:25 <shapr> What's a labelled record pattern?
09:53:33 <edwardk> foo (MyRec { field = x }) = do soemthing with x
09:53:37 <shapr> ah
09:53:55 <Baughn> Where x is an arbitrary pattern, i guess. That makes sense..
09:53:57 <edwardk> hence the bracelist around the pretty printed field
09:54:10 * shapr tries that
09:54:35 <edwardk> i was transliterating some of language.haskell.* to support kata since i decided i didn't like my old parser
09:54:52 <edwardk> and i tripped over that bit. since i don't have labeled fields i don't have to deal with it so much ;)
09:56:00 <shapr> Cool, that really does work.
09:56:12 <edwardk> yeah i used to use them a lot
09:56:25 <edwardk> just completely spaced on them when trying to figure out the cases for the pattern matcher =)
10:00:04 <TomMD> lazyness leaks are evil
10:04:11 <Baughn> TomMD: Mm. I must admit, when I write haskell I think in terms of graph reduction and dethunking, not really functional programming
10:04:44 <Baughn> Though obviously there's a lot of overlap, not taking the laziness into account leads to.. well, leaks. :P
10:06:33 <therp>     Could not find module `Data.ByteString.Base'. is this module obsolete? hoogle doesn't know it anymore
10:06:42 <TomMD> Data.ByteString.Internal
10:06:47 <Baughn> therp: Yes, use.. that
10:06:53 <Baughn> THough it's not a straight renaming
10:07:15 <Baughn> therp: Really, just remove the import and see what breaks. Then go looking for those. The API has changed too.
10:07:21 <therp> Agda 2.1.2 seems to use it..
10:07:22 <Baughn> (It's /internal/, see..)
10:08:08 <therp> hmm. whatever Base.LPS was..
10:08:48 <therp> shrug.. I guess I should go back to ghc 6.6 to play around with Agda..
10:08:52 <TomMD> Data.ByteString.Lazy.Internal
10:09:13 <TomMD> LPS == Lazy Packed String ~ Lazy ByteString
10:09:28 <_varz> implementation question: i have defined a pushdown automata and need to verify if a string is valid for that PDA ... should i go for generating the LR table or just simulating a pile and traveling my PDA will do the job (from a haskell point of view) ??
10:09:38 <pejo> therp, I think you want Agda from darcs, 2.1.2 is "really old" I think.
10:10:05 <therp> pejo: think so too.. but 2.1.2 was prepackage in the gentoo-haskell repository
10:10:07 <monochrom> Coding the PDA seems much less work.
10:10:10 <TomMD> Pejo: So Agda developers are like me "Release early, forget to release often"
10:10:11 <TomMD> ?
10:12:03 <pejo> TomMD, I think you have to ask them for their official standpoint. I'm sure they would like a helping hand though.
10:12:08 <therp> hmm.. QuickCheck >=2.0 required for Agda from darcs..
10:12:15 <_varz> monochrom, hmm do you think it would result in a valid solution to my problem ?
10:12:24 <Baughn> TomMD: Well, if it never gets to a stable point of release..
10:12:47 <Baughn> TomMD: I'm surde they wouldn't mind if you branched off and polished one version or other
10:12:54 <monochrom> It will be valid.
10:13:15 <pejo> therp, http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php has building instructions on it iirc.
10:13:17 <lambdabot> Title: 14 The Agda Wiki - Main 4b
10:16:00 <_varz> monochrom, thx for the tip, i'll point my eyes into that solution then ...
10:16:08 <ecks> hello, i wrote a little "Writing a Network Client" post
10:16:16 <ecks> http://ecks.homeunix.net/wordpress/
10:16:27 <swiert> hoi shapr
10:17:15 <ecks> its mostly for myself but if anyone finds it useful let me know
10:23:43 * shapr waves
10:24:13 <swiert> shapr: how's life?
10:24:38 <shapr> Lots of fun, playing with OLPC XO, writing Python. How's your life?
10:25:21 <swiert> Lots of thesis writing - and not much fun atm.
10:25:35 <pafcu> http://underhanded.xcott.com/ Writining underhanded code in C is easy, but doing it in Haskell would be a real challenge
10:25:36 <lambdabot> Title: 19 The Underhanded C Contest a
10:25:37 <shapr> But you'll profit from your thesis for a long time!
10:25:38 <swiert> Plus plenty of worrying about where the next job is coming from.
10:26:02 <shapr> Ah, I can understand that.
10:26:20 <Baughn> pafcu: If the underhandedness is supposed to be bad efficiency in some circumstances.. I imagine we could handle that. ;)
10:26:23 <pejo> swiert, no current plans?
10:26:25 <shapr> swiert: If you can't find anything else, I could probably find you a C# job ;-)
10:26:57 <pafcu> Baughn: Well, you're supposed to do something nasty, but in a way that's hard to spot in the source code
10:27:25 <Baughn> pafcu: It's not too hard to avoid lazy space leaks, but /debugging/ them...
10:27:28 <swiert> pejo, shapr: Well - the post-doc job market is pretty tight at the moment.
10:27:49 <shapr> You could work in um 'industry' for a year or two and then do post-doc work?
10:27:50 <pafcu> e.g the current challenge to create a program that seemingly removes parts of an image, but doesn't really do it
10:27:56 <swiert> I've got plenty of ideas for research proposals, just very little certainty.
10:28:12 <pafcu> No surprising buffer overflows or such that you can rely on in C
10:28:15 <swiert> shapr: Yep. That's what I'm definitely considering.
10:28:24 <Baughn> pejo: Yeah, that one should be fun. Are you entering?
10:28:41 <shapr> swiert: Working in Boston would be a stimulating experience. Lots of smart people here.
10:28:58 <swiert> shapr: Yeah - definitely. Did you know mattam's moving there?
10:29:14 <Baughn> Er, *paf
10:29:17 <Baughn> ..*pafco
10:29:20 <shapr> No, when?
10:29:29 <shapr> It'd be great to meet him.
10:29:36 <sclv_> wouldn't be hard to write underhanded code in haskell that depended on the reviewer thinking mainly in C.
10:29:36 <pafcu> Baughn: Yep, coded my submission today
10:29:41 <shapr> salut mattam!
10:29:48 <Baughn> pafcu: No need to be in a hurry. ;)
10:29:52 <swiert> As soon as he finishes his PhD, I think.
10:30:04 <shapr> Spiffy!
10:30:06 <Baughn> pafcu: (How are you doing it? I'm curious.. well, suppose that's a secret)
10:30:25 <pafcu> <100 lines of code, fully documented, and still most people wouldn't spot the error
10:30:48 <sclv_> or taking advantage of something like shadowing
10:30:49 <Baughn> That was a complete non-answer. Oh well, don't mind me. :P
10:31:28 <pafcu> Baughn: You'll see after I've won :-)
10:31:50 <Baughn> pafcu: You mean, after I've won. :P
10:33:03 <pafcu> I'm just waiting for some Haskell guru to submit a one-liner that wins :-) (You don't have to use C even though it's in the contests name)
10:33:38 <Baughn> pafcu: No, you can use C++ instead, maybe
10:33:47 <Baughn> It also says "Mail your C file to..."
10:34:09 <Baughn> I really don't think a haskell entry would win. :P
10:34:11 <pafcu> The FAQ states: "If you actually want to do something like that, then sure. No COBOL, please."
10:34:23 <Baughn> Yes. I am equating Haskell to COBOL.
10:34:41 <Baughn> ..let the flaying begin
10:34:44 <mauke> BURN HIM
10:35:23 <sclv_> writing underhanded haskell is an interesting task though. shadowing is one way you could do it, or confusing x' and x'' or such. alternately, dropping into FFI for "efficiency"
10:35:24 <Baughn> pafcu: The point is, it has to be a C-like language. C is fine; so is C++, mostly. C-- might be. Haskell is way over on the other side of "fine".
10:35:54 <sclv_> not sure if anyone has any other ideas
10:36:18 <DRMacIver> If nothing else it makes it much harder to review the submission as I doubt the person organising it knows Haskell
10:36:35 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
10:36:36 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
10:36:53 <sclv_> overlapping pattern matches maybe
10:37:02 <sclv_> or confusing (x:xs) with [x:xs]
10:37:16 <mauke> overlapping patterns are easily found with -Wall
10:37:18 <DRMacIver> sclv_: Hm. You could potentially do something interesting with type classes, where the behaviour of something depends quite sensitively on which instance is selected
10:37:20 <Baughn> sclv_: If it was that easy to write malevolent code in haskell, I probably wouldn't like it so much. ;)
10:37:42 <Baughn> The use of type classes for solving this problem would be a black mark on its own. It's /too simple/
10:37:47 <DRMacIver> (And not provide type annotations in the relevant area where the inferred type is surprising)
10:38:11 <Baughn> ..though haskell users do have a tendency to pick the most succinct way to solve problems, complexity be damned
10:38:13 <DRMacIver> Baughn: Depends on whether you can use an existing one. :)
10:38:15 <sclv_> mauke: yeah, so are shadowed names, but the code is supposed to pass visual inspection more than anything else.
10:38:45 <sclv_> DRMacIver: actually, yeah, getting something inferred to an Int when it should be an Integer wouldn't be a bad way to go.
10:39:36 <DRMacIver> sclv_: Or even a smaller type. For example you could addition on a word type where the reader would expect it to be promoted to an Int but actually the literal is overloaded to be a word.
10:39:58 <DRMacIver> um. A Word8 that is.
10:40:11 <sclv_> Baughn: the interesting thing about thinking about this is it makes you think about the places where haskell does have gotchas that come up when coding.
10:40:37 <PeakerWork> Baughn, you mean simplicity be damned :)
10:40:41 <sclv_> the fact that some projects don't code to the standard of a clean -Wall surprises me.
10:41:15 <PeakerWork> you could use malicious instances of Typeable
10:41:27 <PeakerWork> (methinks Typeable is a horrible hack)
10:41:35 <sclv_> PeakerWork: yeah, but declaring your own instance of Typeable would be a dead giveaway!
10:41:45 <DRMacIver> Too obvious. If someone manually defines an instance of Typeable they're clearly Doing It Wrong
10:41:57 <sclv_> Typeable is fine, with the exception that you're allowed to define your own instances at all.
10:42:09 <PeakerWork> sclv_, Why escape a perfect type system? :-)
10:42:43 <sclv_> PeakerWork: Dynamics are usually pointless, but not always, but Generics are a bearer of great mana.
10:42:59 <PeakerWork> sclv_, when does it make sense to use Typeable?
10:43:03 <Saizan> it's just that we hate finite universes
10:43:03 <mauke> @let a === b = cast a == Just b
10:43:06 <lambdabot> Defined.
10:43:12 <mauke> > 12 == "12"
10:43:13 <lambdabot>   add an instance declaration for (Num [Char])
10:43:13 <sclv_> PeakerWork: any time that you're using generics.
10:43:15 <mauke> > 12 === "12"
10:43:16 <lambdabot>  False
10:43:22 <PeakerWork> sclv_, example?
10:43:39 <ddarius> mauke: You have a lot more work to do to get PHP semantics.
10:43:41 <sclv_> um, transforming code trees?
10:43:42 <chessguy> > 12 === 12
10:43:43 <lambdabot>  True
10:43:53 <Baughn> @src cast
10:43:53 <lambdabot> Source not found. It can only be attributed to human error.
10:44:04 <PeakerWork> @type cast
10:44:06 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
10:44:35 <chessguy> @src Typeable
10:44:35 <lambdabot> Source not found. Take a stress pill and think things over.
10:45:00 <PeakerWork> > (cast "5") :: Maybe Int
10:45:02 <lambdabot>  Nothing
10:45:09 <PeakerWork> what can it cast?
10:45:31 <sclv_> PeakerWork: also, auto-marshalling between formats, see for example the rJSON library... or the Generics extension of HStringTemplate even.
10:45:39 <mauke> > cast () :: Just ()
10:45:40 <lambdabot>   Not in scope: type constructor or class `Just'
10:45:45 <mauke> > cast () :: Maybe ()
10:45:46 <lambdabot>  Just ()
10:46:54 <PeakerWork> sclv_, can't you use existential types for JSON stuff?
10:47:36 <PeakerWork> mauke, cast behaving like Just is not very impressive :)
10:47:56 <sclv_> the point isn't to pack in dictionaries (that's what Dynamic is for) -- the point is, e.g., to define a record structure and get free serialization to/from JSON for it.
10:48:02 <dolio> dafra: Unfortunately, I've already rewritten fannkuch to use uvector, and it's slower than the existing Haskell implementation. We're working on it, though.
10:48:08 <mauke> PeakerWork: it is if it also behaves like const Nothing at the same time!
10:48:09 <dolio> (Sorry about the delayed response.)
10:48:35 <ddarius> sclv_: Uniplate
10:49:06 <sclv_> ddarius: well, assuming you only have one data type, sure. but I don't think uniplate has creation functions, just traversals and transformations?
10:49:46 <sclv_> i.e. you can get serialization, but not deserialization?
10:50:36 <sclv_> on the other hand, I think that syb-with-class is less dependent on Typeable, although it still somewhat is...
10:50:46 <dolio> And the version currently on the shootout uses malloc and raw addresses and such, which doesn't bode well at the moment, I suppose.
10:50:47 <sclv_> you might be able to remove the dependency there entirely?
10:51:06 <dolio> If that's still slower than CAL and Python (Psyco) and such.
10:52:18 <sadache> I lost my day trying to configure one haskell editor and I failed
10:52:56 <sadache> what is a .Cabal file or a cabal typical procedure? I am a windows user
10:53:31 <sclv_> dolio: are we using the best algorithm?
10:53:42 <sclv_> silly question I know, but I wonder nonetheless...
10:53:52 <PeakerWork> mauke, Using Typeable hacks?
10:54:14 <PeakerWork> mauke, when is cast useful?
10:54:30 <mauke> PeakerWork: for downcasting a generic message to a specific type
10:54:34 <dolio> Almost all the (higher up) implementations are copied from the same source (C, as far as I know), and we're no different.
10:54:45 <PeakerWork> mauke, ah
10:55:18 <mauke> I use it in preflex (technique stolen from xmonad)
10:55:36 <PeakerWork> sclv_, why does JSON serialization need Dynamics while read/show don't?
10:55:44 <Saizan> sadache: a .cabal file is a description of the package you're installing, such that you can use a Setup.hs script (usually included in the package) to build and install it
10:55:59 <sclv_> PeakerWork: not dynamics, generics!
10:56:21 <PeakerWork> sclv_, where can I read about the difference?
10:56:29 <sclv_> the point is that each read/show encodes a whole bunch of stuff, including, e.g. the type name.
10:56:41 <sclv_> they're written for you, so you don't see it.
10:57:04 <sclv_> if you had to write read/shows by hand you'd appreciate how much work scrap your boilerplate can save you.
10:57:10 <sclv_> @where syb
10:57:10 <lambdabot> http://www.cs.vu.nl/boilerplate
10:57:15 <PeakerWork> sclv_, doesn't JSON also encode the "type name"? ({ for dicts, [ for lists, etc)
10:57:16 <sclv_> PeakerWork: ^^
10:57:46 <sclv_> PeakerWork: right. if you're deserializing to a boring json structure only.
10:57:59 <sclv_> but what if you want to serialize/deserialize to *any* record type "for free"?
10:59:08 <sadache> i ve got the setup.lhs, what should i do then?
11:00:03 <mauke> runhaskell Setup configure
11:00:07 <PeakerWork> sadache, I think its best to get cabal-install to work so you can only set up one package manually - and the rest automatically
11:00:07 <sadache> i am trying to run leksah
11:00:20 <mauke> runhaskell Setup build
11:00:26 <sadache> but i dont find any executable after running the setup
11:01:58 <sadache> but ho to get cabal-install to work?
11:02:02 <sadache> how
11:04:38 <PeakerWork> sadache, same way you're getting your current package to work.  as mauke said: use "runhaskell Setup configure", and then "runhaskell Setup build", and then "runhaskell Setup install"
11:05:28 <sadache> but it gives me "not in scope" error
11:05:39 <xif> hey, does Haskell support any sort of literal notation for rational numbers?
11:05:54 <ddarius> xif: You can just write 1/2 and it will do the right thing.
11:06:00 <dolio> > 3 % 4
11:06:06 <lambdabot>  3%4
11:06:11 <xif> ddarius: it seems to convert to a float :/
11:06:21 <ddarius> > 1/2 :: Rational
11:06:22 <lambdabot>  1%2
11:06:55 <xif> hm, but typing 1%2 doesn't seem to work on ghci
11:07:10 <dolio> You need to have Data.Ratio imported.
11:07:29 <dolio> @index Rational
11:07:29 <lambdabot> Prelude, Data.Ratio
11:07:36 <PeakerWork> > 2/4 :: Rational
11:07:37 <lambdabot>  1%2
11:07:48 <dolio> @index (%)
11:07:48 <lambdabot> Data.Ratio
11:07:56 <PeakerWork> > sqrt 2 :: Rational
11:07:59 <lambdabot>   add an instance declaration for (Floating Rational)
11:07:59 <lambdabot>     In the expression: ...
11:08:00 <xif> cool, thanks.
11:08:16 <xif> btw, how does it know to translate 1.6666... to 1%6?
11:08:38 <dolio> Where would it get 1.6666... from?
11:08:57 <ecks> hello, is it possible to have ghc slotted kind of like gcc or java?
11:09:08 <vixey> 1.6666 = 16666/1000
11:09:16 <vixey> almost..
11:09:22 <sadache> when i use runhaskell build it gives me out of scope error
11:09:39 <PeakerWork> vixey, it wouldn't do the long division, but instead it would probably find the gcd and divide both by that
11:09:59 <panzi> lambdabot: help
11:10:11 <ddarius> slotted?
11:10:12 <chessguy> @help
11:10:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:10:25 <panzi> ic
11:10:47 <xif> dolio: Prelude> (1/3)
11:10:47 <xif> 0.3333333333333333
11:10:47 <xif> Prelude> (1/3) :: Rational
11:10:47 <xif> 1%3
11:10:59 <dolio> @type 1/3
11:11:15 <lambdabot> thread killed
11:11:19 <xif> 1/3 :: (Fractional t) => t
11:11:20 <dolio> Anyway, it's not 0.33333...
11:11:33 <xif> yeah, seems like 0.333 is only a representation.
11:11:38 <xif> (the only rational explanation)
11:11:50 <dolio> Internally that gets represented as something like: fromRational (1 :: Rational) / fromRational (3 :: Rational).
11:11:51 <sadache> :'( I just want syntax highlighting
11:11:56 <rwbarton> when you add :: Rational, it's doing type inference and 1 and 3 represent values of type Rational
11:12:12 <dolio> When it defaults to Double, it gets displayedd like 0.333, but that's not what the literal is.
11:12:15 <ddarius> xif: The default default is to default to Double
11:12:31 <vixey> sadache: emacs does it
11:12:42 <ddarius> Every editor that does syntax highlighting does it.
11:12:45 <xif> I see, interesting.
11:12:52 <sadache> vixey: I ve never used emacs before
11:13:10 <sadache> and i tried to configure it and i didnt succeed
11:13:24 <sadache> no error but it doesn't highlight the syntax
11:13:58 <PeakerWork> sadache, you need to use "(global-font-lock-mode t)" in your emacs initialization file
11:14:03 <PeakerWork> (or something like that)
11:14:11 <sadache> i did
11:14:15 <vixey> try this http://www.haskell.org/haskell-mode/
11:14:16 <sadache> it didnt work
11:14:16 <lambdabot> Title: Haskell Mode for Emacs
11:14:38 <sadache> i spent 4 hours trying to get it to work, with no result
11:14:53 <xif> hmmm, how do I import code on GHCI?  `import Data.Ratio` doesn't work
11:14:58 <vixey> did you try this haskell-mode?
11:15:07 <dolio> xif: :m + Data.Ratio
11:15:18 <TomMD1> Anyone here besides dons use arch linux?
11:15:29 <xif> dolio: kewlness, thanks again.
11:15:30 <panjj> hello
11:15:32 <sadache> i downloaded haskell-mode
11:15:39 <TomMD1> hello panjj
11:15:42 <xif> with that level of math support, ghci is a pretty handy tool.
11:15:43 <PeakerWork> xif, ghci is not really an "interactive Haskell mode" unfortunately, using its own different ways to do things..
11:15:48 <sadache> and pointed out the .emacs file to it
11:16:01 <ecks> oh yeah, i mean where you can change your compiler with smthing like "gcc-config" where u dont have to reinstall a new version every time
11:16:04 <PeakerWork> sadache, using (require ..) ?
11:16:13 <vixey> and then open a .hs file in emacs?
11:16:19 <vixey> and it didn't color it?
11:16:23 <panjj> i need help about two assingment in haskell
11:16:30 <panjj> to write two simple functions
11:16:40 <PeakerWork> sadache, your emacs initialization should have a (require 'haskell-mode) in it, too. Then if you still don't get highlighting, try to use   M-x haskell-mode   and see if that works, it should narrow the problem down
11:16:49 <xif> PeakerWork: yeah, I'm starting to notice that. my greatest concern about Haskell is that I'm going to feel I've "downgraded" to it from a dynamic language, if it doesn't support nice runtime work like Ruby and Python do.
11:17:13 <panjj> can please anbody help
11:17:15 <vixey> xif: What do you want to do at runtime?
11:17:54 <xif> vixey: import modules, run arbitrary and/or generated code, that sort of thing :)
11:17:56 <chessguy> panjj:  you haven't asked your actual question yet
11:18:16 <PeakerWork> xif, afaik, you can't (don't want) to eval/exec Haskell strings in runtime.  ghci is pretty lame compared to the Python interactive shell, too.  Its got dependency/version problems too.  But its awesome enough to make up for it :)
11:18:17 <chessguy> panjj:  we're not going to do it for you, but we might be able to point you in the right direction
11:18:20 <vixey> xif: You can do both of those, I don't know about "that sort of thing" though
11:18:37 <sadache> i have (load "~/emacs/haskell-mode/haskell-mode")
11:18:47 <sadache> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
11:18:52 <PeakerWork> xif, I don't ever auto-generate python code, myself. I simply generate runtime closures, instead
11:18:57 <sadache> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
11:19:07 <sadache> (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock)
11:19:16 <chessguy> sadache:  why not just pastebin?
11:19:19 <vixey> sadache; I'm not sure what ~ means on windowns
11:19:30 <xif> PeakerWork: cool, though I wonder why vixey just said you can exec code at runtime.
11:19:42 <sadache> pastebin?
11:19:45 <vixey> xif: It's because you can
11:19:47 <chessguy> @paste
11:19:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:19:52 <vixey> xif: and you were asking about it..
11:20:23 <xif> vixey: yeah, but PeakerWork just said you can't do it.
11:20:28 <hpaste>  Sadache pasted ".emacs haskell-mode" at http://hpaste.org/8353
11:20:52 <panjj> ok the assigment write function that takes out blank signs(tabulator,empty space,dot, and two dots) from ARRAY
11:21:08 <panjj> second: Write a function that checks whether the first letter of each word is capital ( "John Mark Pero" -> Yes, "Joseph Goran mark" -> No).
11:21:36 <vixey> @hoogle upper
11:21:40 <lambdabot> Text.ParserCombinators.Parsec.Char.upper :: CharParser st Char
11:21:40 <lambdabot> Data.Char.UppercaseLetter :: GeneralCategory
11:21:40 <lambdabot> Data.Char.isUpper :: Char -> Bool
11:22:28 <vixey> > words "John Mark Pero"
11:22:31 <lambdabot>  ["John","Mark","Pero"]
11:22:36 <chessguy> vixey:  it's homework
11:22:40 <chessguy> vixey:  don't give him the answer
11:23:28 <chessguy> panjj:  for the first question, are you sure it's supposed to be an array, and not a string? can you give us an example?
11:23:34 <panjj> my god yes its a homework but i dont have 2 months to learn haskell i also need to make a varioation of paint in silverlight
11:23:38 <sadache> and i guess emacs loads fine the haskell-mode but i don't why it does not change any thing
11:24:03 <vixey> 2 months to learn haskell is a bit optimistic..
11:24:10 <panjj> yes
11:24:10 <saml> what is complexity of scanl ?
11:24:12 <chessguy> panjj:  as i said, we're wiling to help, just not to do your work for you
11:24:14 <mauke> I vote /ban *!*@*.hr
11:24:15 <panjj> and we have 4 weeks
11:24:18 <panjj> jeej
11:24:22 <panjj> even less
11:24:27 <saml> isn't it O(n!) ?
11:24:42 <chessguy> saml:  complexity is a bit sticky in haskell
11:24:50 <ddarius> saml: No
11:24:51 <panjj> chessguy: maybe i transle it wrong its a string
11:24:57 <saml> > scanl f z [a,b,c,d,e] :: Expr
11:25:13 <lambdabot>  thread killed
11:25:20 <PeakerWork> why is lambdabot so slow? :)
11:25:22 <mauke> actually, make that /ban %*!*@*.hr
11:25:39 <chessguy> panjj:  so the object is to strip certain characters out of a string, yes?
11:25:52 <vixey> > concat . words $ "aoeu aeou eao u.,p "
11:25:54 <lambdabot>  "aoeuaeoueaou.,p"
11:26:04 <panjj> chessguy: yes!
11:26:08 <xif> OK, another newbeish question. why does the expression `1%2 * 2%3` error out?
11:26:16 <vixey> > 1%2 * 2%3
11:26:17 <lambdabot>   add an instance declaration for (Integral (Ratio t))
11:26:18 <chessguy> panjj:  ok, what are your thoughts so far on how to start?
11:26:28 <vixey> > (1%2) * (2%3)
11:26:30 <lambdabot>  1%3
11:26:41 <saml> scanl f z [x1,x2,...] ==  [z, z `f` x1, (z `f` x1) `f` x2, ...] let's say it memoize
11:26:45 <xif> vixey: weird, shouldn't it do that automatically?
11:27:01 <ddarius> @src scanl
11:27:01 <lambdabot> scanl f q ls = q : case ls of
11:27:01 <lambdabot>     []   -> []
11:27:01 <lambdabot>     x:xs -> scanl f (f q x) xs
11:27:02 <vixey> xif: no spaces don't change operator precedence
11:27:10 <panjj> cheesguy: i have no thoughts really
11:27:19 <panjj> we have a stupid organization
11:27:19 <mauke> > 1%2 * 2%3 :: Expr
11:27:20 <rwbarton> it's probably parsing it as (1%2 * 2) % 3 and trying to construct the type Ratio (Ratio Integer)
11:27:20 <lambdabot>  Couldn't match expected type `Expr'
11:27:24 <vixey> (1%2 * 2%3) is the same as (1 % 2*2 % 3)
11:27:24 <ddarius> saml: Does that look O(n!) complexity to you?
11:27:30 <xif> vixey: I see, thank you.
11:27:31 <panjj> im learning silverlight now
11:27:35 <chessguy> panjj:  ok, what typ is the function you need to write?
11:27:39 <chessguy> *type
11:27:48 <saml> ddarius: no that looks like O(n) given (:) is constant
11:28:11 <panjj> its not determined
11:28:18 <chessguy> panjj:  sure it is
11:28:19 <panjj> it can be any type
11:28:23 <panjj> hmm
11:28:24 <chessguy> panjj:  from the problem description
11:28:40 <chessguy> panjj:  do you know any haskell?
11:28:44 <panjj> it cant be a function form haskell
11:28:52 <panjj> chessguy: no
11:28:57 <panjj> ony rules and theory
11:28:59 <chessguy> oh
11:29:08 <chessguy> what do you mean, 'rules and theory'?
11:29:12 <mauke> do you know any programming language?
11:29:42 <panjj> : yes c++ c# risc amd, Frisc,
11:30:18 <chessguy> hm
11:30:25 <chessguy> how would you do it in C#?
11:30:31 <chessguy> (generally)
11:31:09 <panjj> put a string in it put in in a field and with for petlja check every letter
11:31:26 <chessguy> bah
11:31:30 <panjj> put string into field
11:31:55 <chessguy> ok, let's start with this. see if you can figure out what this means:
11:31:58 <chessguy> @type toUpper
11:32:10 <lambdabot> Char -> Char
11:32:57 <sadache> my emacs does not recognize the M-x in M-x haskell-mode
11:33:27 <chessguy> sadache:  try <ESC> x
11:33:33 <mauke> *facepalm*
11:33:36 <mattam> Alt-x/Escape x
11:34:17 <dufflebunk> How do I export an instance of a class? Do I need to?
11:34:28 <vixey> sadache: If you open a .hs file emacs should go into haskell mode automatically though
11:34:53 <sadache> it gives  Cannot open load file: haskell-font-lock
11:35:27 <rwbarton> dufflebunk: I think it's automatic, you don't need to
11:35:38 <vixey> panjj: In haskell, f x y z is the same as (((f x) y) z), the types need to match up, so if x :: a (x has type a), y :: b, z :: c, and f :: a -> b -> c -> k then that code will typecheck and run
11:36:26 <chessguy> vixey:  he's gone
11:37:22 <PeakerWork> also note that a -> b -> c -> k  is the same as a -> (b -> (c -> k))
11:39:51 <ianL_> i am new to haskell and want to know what type of programs is haskell usually used to make
11:40:04 <mar77a> project euler :p
11:40:16 <chessguy> a chess program :)
11:40:23 <chessguy> ...if you want to pull your hair out :)
11:40:32 <Zao> I shell script in Haskell :)
11:40:32 <ddarius> ianL_: It's been used for a whole variety of programs.
11:40:56 <Zao> Whipping something up in haskell tends to be faster than looking up the obscure tcsh reference manual.
11:41:17 <mauke> ianL_: IRC bots
11:41:21 <ianL_> ok
11:41:24 <vixey> interpreters
11:41:29 <mauke> window managers
11:41:32 <ddarius> Quake clones
11:41:37 <mauke> compilers
11:41:44 <ianL_> so basically i can meake the same type of programs i usually write in python in haskell
11:41:46 <chessguy> ianL_:  maybe this will give you some ideas? http://haskell.org/haskellwiki/Category:Code
11:41:47 <lambdabot> Title: Category:Code - HaskellWiki
11:41:49 <ddarius> Natural language analyzers
11:41:50 <mauke> version control systems
11:42:05 <ddarius> ianL_: You can make anything you want.
11:42:07 <ianL_> thanks chessguy
11:42:23 <ianL_> ok
11:42:25 <dafra> chessguy : i have begun a go program, and Haskell arrays are a pain compared to others
11:42:39 <ddarius> chessguy: This page and hackage would be better: http://haskell.org/haskellwiki/Applications_and_libraries
11:42:40 <lambdabot> Title: Applications and libraries - HaskellWiki
11:42:45 <sadache> thanks guys, i ve got it working (emacs with haskell-mode)
11:42:47 <chessguy> dafra:  no arguments there. i use a Map instead
11:42:59 <chessguy> ddarius:  that's a matter of opinion
11:42:59 <Zao> Rumor has it that Haskell is Turing complete, is that true?
11:43:27 <chessguy> Zao:  sure it is. it's just layers on top of lambda calculus, which is already turing complete
11:43:28 <ddarius> Zao: Only if you have a Turing machine, which you don't.
11:43:28 <dafra> a Map isnt even O(1) access time :(
11:43:46 <mauke> my maps are
11:43:48 <vixey> it's layers upon system Fw which is not turing complete
11:44:04 <vixey> you have named definitions though which lets you give recursive definitions
11:44:10 <mauke> O(4 billion) is still O(1)
11:44:11 <dafra> btw, any1 using yi editor out there ?
11:44:44 <dafra> sure mauke, my Map is an immutable array, s O(1) too
11:44:50 <RayNbow> vixey: got a link to some resources on system Fw?
11:45:01 <dafra> except that i cant compute more than 300k positions per seconds
11:45:16 <dafra> chess programs do something like 5M
11:45:21 <vixey> the book TAPL would be better than anything I've read online
11:45:54 <RayNbow> vixey: damn... I'm still at chapter 8 or something :p
11:45:56 <ecks> dafra: im trying to make smthing like that also, except i havent gotten to the go logic yet
11:46:54 <dafra> strict languages have nice backtrackable arrays that give a pure interface and mutate under the hood, but lazy languages cannot
11:47:18 <dafra> or hard to use
11:47:41 <ddarius> dafra: wtf?  Eagerness/laziness is irrelevant.
11:48:50 <dafra> some heuristics depend on what is on the board, and what the heuristic was the move before (eg number of neighbours)
11:49:07 <dafra> in a strict language, you only need to acess the current array
11:49:43 <dafra> but in lazy languages, using a heuristic can trigger computation of the same heuristics for previous positions, acessing the older arrays
11:50:09 <dafra> so, the only solition I found is copy the entire array each time :(
11:50:27 <dafra> what is TAPL ?
11:50:39 <Zao> Knuth's book.
11:50:49 <dafra> ah : it is terrific
11:50:50 <vixey> I was not talking about anything by knuth
11:50:52 <ddarius> Zao: No it's not.  That would be TAOCP
11:50:56 <dafra> this guy has 3 brains
11:50:56 <Zao> Oh, right.
11:50:57 <audreyt> no, Pierce's book.
11:51:17 <Zao> I haven't read any of them :(
11:51:26 * ddarius imagines in horror a "programming languages" book written by Knuth.
11:51:40 <vixey> heheh
11:51:48 <dafra> the problem is that Knuth is too strong foer us to follow him
11:51:54 <dafra> he even likes gotos :)
11:52:04 <aFlag> foer?
11:52:07 <dafra> for
11:52:25 <aFlag> he seems to love C
11:52:37 * RayNbow has a copy of TAOCP...
11:52:45 <RayNbow> but it's damn hard to read :p
11:52:45 <aFlag> He has good ideas, though
11:52:50 <aFlag> I like literate programming
11:52:58 <vixey> but does he know haskell?
11:53:13 <aFlag> he probably have heard of it
11:53:15 <dafra> i guess he would hate it
11:53:34 <dafra> he likes low leval stuff, like manual allocation
11:53:41 <ddarius> TeX is a call-by-name, imperative programming language (to look at it optimistically)
11:53:46 <aFlag> but I never seen he coding on haskell
11:53:54 <dafra> TeX is nothing but a bunch of macros
11:54:06 <ddarius> dafra: Which is call-by-name
11:54:51 <dafra> there was an attempt to turn Tex into a real language
11:55:11 <vixey> it is a real language
11:55:14 <aFlag> I think he'd argue that if you use literate programming the formal language you use to tell the computer what to do doesn't matter much
11:55:14 <dafra> good project for Google summer of code :)
11:55:40 <dafra> haskell 's Text.TeX :)
11:56:18 <dafra> yes, knuth programs with paper and pencil after all
11:58:09 <aFlag> and for the sort of things he do there's probably not that much difference
11:58:15 <Syzygy|de> Text.TeX as a reimplementation of TeX as an EDSL? Or what?
11:58:36 <Syzygy|de> dafra: LaTeX is nothing but a bunch of macros. TeX is a bit more than just a bunch of macros.
11:58:47 <Syzygy|de> Not much, but...
12:02:35 <therp> newsham: thanks for the pointer to the "Dependent types at work" paper. I really like the way it's written.
12:04:21 <newsham> therp: glad you found it useful.  It really helped things gell for me.
12:04:50 <newsham> i have some of the exercises in agda online if you're interested
12:06:19 <therp> newsham: sure, exercises are always good
12:06:41 <newsham> http://www.thenewsh.com/%7Enewsham/x/atwork.agda
12:06:53 <newsham> although i deviated from some of their definitions in places
12:07:11 <tobias_tud> is such a thing possible in haskell? type Enc = [Formula] -> [Enc] -> [Formula] -> Formula
12:07:22 <newsham> if you find shorter solutions for some of them, i'd love to hear :)
12:07:26 <mauke> tobias_tud: not with 'type'
12:07:45 <newsham> "type" doesnt like the recursions
12:07:59 <therp> newsham: thanks
12:08:00 <tobias_tud> yes, i experienced it
12:08:26 <Tigran> Wrap it up in a data constructor
12:08:28 <tobias_tud> but how can i get around? i want to give a function another function and another function
12:08:43 <Tigran> It's inconvinient, but works non-the-less
12:09:01 <mauke> newtype Enc = E ([Formula] -> [Enc] -> [Formula] -> Formula)
12:09:42 <tobias_tud> thanks, i hope it works
12:10:12 <vixey> that's an odd type, what's it for
12:10:14 <vixey> ?
12:10:19 <mauke> > case return 2 of Just{} -> ()
12:10:22 <lambdabot>  ()
12:10:44 <Baughn> tobias_tud: At the assembly level, only newtype and data produce a new thunk/pointer; type is a pure type alias, so recursion is resolved strictly, so self-recursion is an infinite loop..
12:10:56 <mauke> what
12:11:10 <mauke> Baughn: this is purely a design issue
12:11:18 <vixey> > case () of {} -> ()
12:11:19 <lambdabot>  Parse error at "}" (column 13)
12:11:19 <mauke> recursive types work
12:11:38 <Baughn> Sure they do, but not with type
12:11:44 <mauke> also, newtype doesn't introduce a pointer
12:12:14 <mauke> E is a no-op to keep the type checker happy
12:12:45 <Baughn> I must be reading this output wrong, then
12:12:50 <Baughn> tobias_tud: ..so disregard that
12:13:07 <Baughn> You're /sure/ it doesn't add pointers?
12:13:19 <mauke> that's sort of the point, isn't it?
12:13:24 <mauke> otherwise you could just use data instead
12:13:38 <Baughn> I figured newtype deriving was most of the point
12:14:29 <Baughn> More to the.. point, I'm seeing data structures here that are very hard to explain if it doesn't, but that could be any of a hundred different things. Attacking haskell with gdb is a bit like emptying the ocean with a hand-pump
12:14:51 <mauke> # let f x = x x;;
12:14:51 <mauke> val f : ('a -> 'b as 'a) -> 'b = <fun>
12:15:01 <mauke> no infinite loop
12:15:23 <vixey> what language is that?
12:15:25 <vixey> oh ocaml
12:15:28 <mauke> ocaml -rectypes
12:15:31 <vixey> thanks
12:16:41 <Baughn> Hm. Yes.
12:17:07 <Baughn> I'm trying to serialize thunks.. it doesn't work; it crashes if any newtypes are involved. Granted, it crashes a lot regardless.
12:18:34 <ddarius> newtype deriving isn't Haskell 98
12:19:06 <Baughn> That doesn't bother me
12:19:06 <Peaker> say, why is FranTK not visible to cabal-install?
12:19:49 <ddarius> Baughn: My point is that newtype deriving can't be the point of newtype if newtype deriving isn't Haskell 98 and newtype is.
12:21:37 <vixey> what is a thunk inside ghc?
12:22:52 <Peaker> vixey, I think its a function that computes something without any arguments
12:23:09 <Peaker> vixey, (its arguments/lexical scope are/is already bound)
12:23:16 <vixey> inside GHC
12:24:59 <petekaz> How do I define this function in point free form?  "mnums line = (drop 2 . words) line >>= return . read"   My first go was "mnums = drop 2 . words >>= return . read" then I tried the "mnums = return . read =<< drop 2 . words", but none work correctly.
12:25:11 <Baughn> @pl mnums line = (drop 2 . words)  line >>= return . read
12:25:11 <lambdabot> mnums = (read `fmap`) . drop 2 . words
12:25:36 <mauke> mnums line = liftM read ((drop 2 . words) line)
12:25:49 <mauke> mnums line = (liftM read . drop 2 . words) lines
12:25:58 <mauke> mnums = liftM read . drop 2 . words
12:26:10 <petekaz> thanks.
12:26:20 <mauke> this assumes you know that >>= return . is liftM
12:28:57 <dafra> is it possible to make coffee with Haskell ?
12:29:04 <dons> ?faq
12:29:05 <lambdabot> The answer is: Yes! Haskell can do that.
12:29:10 <dafra> lol
12:29:12 <dafra> i love it
12:29:29 <byorgey> wasn't there a post recently about the coffee comonad? ;)
12:29:41 <petekaz> Is there ever a time to prefer fmap over liftM when working with a monad?  Based on what I've read, it just seems safer to use liftM as it can be implemented without knowledge of the monad.  But I see lots of people still using fmap.
12:29:47 <byorgey> @go coffee comonad
12:29:48 <lambdabot> http://www.serpentine.com/blog/2008/06/03/the-coffee-comonad/
12:29:52 <byorgey> there it is =)
12:29:58 <mauke> petekaz: er, so can fmap
12:30:11 <mauke> plus fmap is in the Prelude
12:30:19 <Baughn> petekaz: Well, fmap should be liftM for a monad.. though apparently there are issues with having a default instance
12:30:28 <vixey> Ooops...Where did you get such a link ?
12:30:28 <vixey> Server cannot locate what you are looking for !
12:30:30 <vixey> :(
12:30:47 <petekaz> Oh, I see.  I misinterpreted what I read in RWH.
12:30:55 <sjanssen> petekaz: personally, I always use fmap.  However, this will occasionally require an extra Functor constraint in addition to Monad
12:31:13 <byorgey> hm, he seems to have deleted his post on the coffee comonad, sad! =(
12:31:24 <petekaz> But one is not guaranteed that a monad is a functor though (technically) even though almost all monads are instance of functors right?
12:31:33 <Peaker> using fmap and ap(?) is also a neat way around needing liftMn for n <- [1..]
12:31:44 <byorgey> petekaz: from a categorical point of view, all monads are functors.
12:31:44 <mauke> "a comathematician is a device for turning papers into ffee"
12:31:49 <Peaker> petekaz, Monads should have been a Functor subclass
12:31:58 <Baughn> petekaz: If it turns out it isn't, you should be perfectly fine with instancing it yourself
12:32:02 <petekaz> Peaker: yeah, when I read that in RWH, I thought it was pretty interesting.
12:32:03 <mauke> Peaker: same for liftM and ap
12:32:35 <mauke> instance Functor M where fmap = liftM  -- works for all monads M
12:32:40 <Peaker> mauke, yeah but since liftM2/3/etc exist, if you use liftM you were supposed to use liftM2 and not liftM/ap :)
12:32:41 <mauke> you just can't automate it
12:32:45 <Baughn> mauke: If you have a mathematician, a comathematician, and some coffee or paper, do you get infinite energy?
12:33:08 <vixey> Baughn!
12:33:18 <vixey> Have you read asimovs The Last Question?
12:33:26 <Baughn> Yes, of course
12:33:29 <vixey> :D
12:33:35 <Baughn> The ending was a cop-out
12:33:49 <byorgey> Baughn: no, you need a source of 'co' as input =)
12:33:56 <opqdonut> :D
12:33:58 <mauke> > repeat "co"
12:34:01 <lambdabot>  ["co","co","co","co","co","co","co","co","co","co","co","co","co","co","co",...
12:34:04 <byorgey> note that comathematicians only produce ffee
12:34:19 <opqdonut> :D
12:35:10 <swiert> I thought comathematicians nsume ffee.
12:35:19 <audreyt> why should someone want halfwidth white circles?
12:35:37 <Cale> comathematicians turn theorems into coffee
12:35:52 <ziman> > 0xffee
12:35:53 <lambdabot>  65518
12:36:05 <vixey> _ 
12:36:20 <Baughn> > 0xc0fee
12:36:22 <tusho> Cale: I want a comathematician
12:36:22 <lambdabot>  790510
12:36:31 <mauke> 
12:36:36 <tusho> > 0xc0ffee
12:36:37 <lambdabot>  12648430
12:36:49 <tusho> JEEZ I COULD REALLY DO WITH SOME 12648430
12:37:13 <ibid> gesundheit
12:37:34 <Cale> I could too...
12:37:54 <shapr> me too
12:37:58 <shapr> But I have j0lt, so...
12:38:24 <vixey> preflex: nickometer j0lt
12:38:24 <preflex>  j0lt is 31% lame
12:38:30 <shapr> ouch
12:38:32 * Cale goes off to make some espresso.
12:39:37 <Baughn> preflex: nickometer 
12:39:37 <preflex>   is 99.99650956% lame
12:39:43 <tusho> hah
12:39:48 <tusho> someone give me a unicode bomb
12:39:52 <TomMD> preflex: TomMD
12:40:11 <tusho> preflex: nickometer TomMB
12:40:11 <preflex>  TomMB is 18% lame
12:40:12 <tusho> preflex: nickometer TomMD
12:40:12 <preflex>  TomMD is 18% lame
12:40:23 <mauke> tusho: don't have one
12:40:25 <TomMD> preflex: nickometer tommd
12:40:25 <preflex>  tommd is 0% lame
12:40:30 <TomMD> So close!
12:40:45 <Baughn> preflex: nickometer Tommd
12:40:45 <preflex>  Tommd is 0% lame
12:42:07 <roconnor> preflex: nicometer
12:42:17 <roconnor> preflex: nickometer
12:42:17 <preflex>  roconnor is 0% lame
12:43:02 <allbery_b> preflex: nickometer
12:43:02 <preflex>  allbery_b is 14% lame
12:43:08 <allbery_b> *snort*
12:43:32 <byorgey> preflex: nickometer
12:43:32 <preflex>  byorgey is 0% lame
12:43:34 <opqdonut> preflex: nickomenter
12:43:42 <CVirus> I can't understand the differnet between type and data ?
12:43:42 <byorgey> opqdonut is 105% lame
12:43:45 <Baughn> preflex: nickometer Xzprtq
12:43:45 <preflex>  Xzprtq is 0% lame
12:43:56 <opqdonut> byorgey: ;)
12:43:58 <Baughn> ..I think it's broken
12:44:16 <byorgey> CVirus: type just creates a synonym, whereas data creates a new data type with its own data constructors.
12:44:23 <vixey> CVirus: type just makes a name for an existing type, data produces type constructors
12:44:24 <mauke> CVirus: data defines a new type, type makes a new name for an existing type
12:44:40 <mauke> compare typedef/struct in C
12:45:33 <CVirus> thanks
12:45:51 <dcoutts> Peaker: if ghc-pkg knows about FranTK then so will Cabal/cabal-install
12:45:51 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:46:02 <Cale> heh, 3-channel audio :)
12:46:48 <mapreduce> preflex: nickometer x5c_g
12:46:48 <preflex>  x5c_g is 31% lame
12:46:50 <dcoutts> gwern: btw, I've not built the cabal docs with haddock-2.x, only with 0.9
12:47:27 <Cale> CVirus: newtype lies somewhere in between those two. It creates a genuinely new type (which is treated as distinct by the type system) which is equivalent to an existing type.
12:47:43 <Cale> CVirus: (and generally has the same runtime representation)
12:52:58 <CVirus> data Anniversary a = Birthday String Int Int Int
12:53:01 <CVirus> what does a stand for ?
12:53:09 <mauke> any type
12:53:11 <CVirus> or what does it represent
12:53:12 <CVirus> hmm
12:53:14 <mauke> it's a type parameter
12:53:25 <mauke> @src Maybe
12:53:25 <lambdabot> data Maybe a = Nothing | Just a
12:54:00 <CVirus> this is really confusing
12:54:03 <ohub> :t Just 1
12:54:05 <lambdabot> forall t. (Num t) => Maybe t
12:54:08 <CVirus> suggestions for a page that describes this ?
12:54:16 <mauke> haskell.org
12:54:20 <CVirus> thanks
12:54:20 <CVirus> brb
12:54:26 <mauke> CVirus: what programming lan
12:54:40 <Cale> ...
13:00:14 <therp> newsham: it seems the dep.typ.@work paper is not written in Literate Agda :) I'm getting so used to error free papers.. the S combinator page 7 is wrong.. there is an 'x' missing
13:00:24 <dufflebunk> cale: It generally has the same runtime representation, but not always?
13:00:40 <swiert> therp: which paper is that?
13:00:46 <Cale> dufflebunk: The standard doesn't actually say that it does.
13:00:55 <Peaker> what was the name of the provably-halting turing-incomplete language?
13:01:00 <dufflebunk> Cale: Ah, ok/
13:01:02 <Cale> dufflebunk: Because the standard doesn't say anything about the runtime representations of things.
13:01:14 <vixey> there are many
13:01:15 <therp> swiert: http://www.cs.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf
13:01:31 <Cale> But the important thing is that the types behave in exactly the same fashion.
13:01:40 <swiert> therp: ah ok. ta.
13:01:48 <Cale> Peaker: Perhaps you're thinking of Charity.
13:03:31 <Peaker> Cale, thanks
13:03:58 <vixey> Charity is based on a kind of CAM I think?
13:04:33 <ddarius> Charity is based on CT, yes.  No reason to talk about abstract machines.
13:06:21 <Peaker> dcoutts, you're the cabal-install guy right?
13:07:46 <dcoutts> Peaker: yep
13:08:28 <Peaker> dcoutts, can you cabal install happy?
13:09:01 <dcoutts> Peaker: not on windows
13:09:13 * dcoutts tries on linux...
13:09:27 <Peaker> dcoutts, on Ubuntu - I guess its not really a cabal thing but happy fails to find "buildVerbose" in scope
13:09:48 <dcoutts> Peaker: and what version of cabal-install is that?
13:10:07 <dcoutts> Peaker: I'm guessing 1.3.x and you've also got Cabal lib 1.5.x
13:10:15 <dcoutts> erm
13:10:29 <dcoutts> I mean cabal-install 0.4.x and Cabal lib 1.5.x
13:10:32 <Peaker> cabal-install version 0.4.6 using version 1.5.1 of the Cabal library
13:10:37 <dons> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
13:10:37 <dons> ./configure script then use 'build-type: Simple'.
13:10:37 <dcoutts> right, upgrade
13:10:46 <dons> yep, builds fine here.
13:10:50 <dcoutts> dons: it needs the custom build type
13:11:00 <Peaker> dcoutts, safe to use cabal-install/cabal from darcs?
13:11:09 <Peaker> dcoutts, with ghc 6.8.2?
13:11:10 <dcoutts> problem is, cabal is building the Setup.hs against Cabal-1.5 rather than 1.4
13:11:32 <dcoutts> Peaker: if you want the darcs version then you need the cabal-1.4 darcs branch
13:11:41 <dcoutts> Peaker: or you can use the releases from hackage
13:11:55 <Peaker> dcoutts, my experience led me to believe that the darcs one are more stable :)
13:12:09 <dcoutts> Peaker: I did a release on Thursday
13:12:19 <dons> just grab cabal stable from hackage
13:12:30 <dons> it's remarkably robust -- no problems in over 100 packages installed so far
13:12:49 <dcoutts> I recently changed cabal-install to select the version of the Cabal lib so that there is a greater chance of it working
13:13:04 <dcoutts> it now prefers the version of the Cabal lib that cabal-install was itself built with
13:13:27 <dcoutts> second to that, it prefers the same major version, then any stable version, and after that, the latest version
13:13:39 <dcoutts> it used to just always pick the latest version
13:13:55 <dcoutts> which in Peaker's case meant using the 1.5.x devel version which has incompatible API changes
13:14:44 <Peaker> dcoutts, to install the cabal/cabal-install from hackage I'd have to rename/remove ~/.cabal and ~/.ghc ?
13:14:45 <dcoutts> Peaker: so you can cabal install cabal-install-0.5.0 :-)
13:14:56 <dcoutts> Peaker: no, no need to do that
13:15:10 <dcoutts> should just work
13:15:25 <OceanSpray> Is there a compiler that compiles TO Haskell?
13:15:37 <dcoutts> Peaker: might have to tweak your ~/.cabal/config file
13:15:49 <dcoutts> OceanSpray: lots, what would you want to compile from?
13:15:52 <hpaste>  Peaker pasted "cabal install cabal-install-0.5.0" at http://hpaste.org/8354
13:16:28 <OceanSpray> dcoutts, can you gimme a link?
13:16:36 <Peaker> dcoutts, any idea what to do about that?
13:16:38 <dcoutts> Peaker: heh, ironic that the exact problem that the latest cabal-install solves is the problem you get when trying to install it :-)
13:16:46 <Peaker> dcoutts, heh
13:17:05 <Peaker> dcoutts, so remove everything and install from scratch?
13:17:16 <OceanSpray> I was just wondering, because the Haskell 98 report mentions easier code generation the reason for the inclusion of curly-brackets and semicolons
13:17:37 <mauke> you don't need a compiler for that
13:17:46 <dcoutts> OceanSpray: not really, my point is that there are lots of little hacky compilers people write from little languages into Haskell. So what you're looking for probably depend on what language you're interested in compiling *from*.
13:18:01 <OceanSpray> oh.
13:18:05 <mauke> look at using preprocessors like cpp for haskell
13:18:06 <dcoutts> OceanSpray: ohh I see, so you just want any old example?
13:18:10 <OceanSpray> yes
13:18:19 <mauke> or things like Data.Derive
13:18:29 <dcoutts> OceanSpray: I can't actually think of one that uses {} style
13:18:47 <dcoutts> OceanSpray: eg the gtk2hs code gen produces human readable code, not {} style
13:18:56 <dcoutts> OceanSpray: same for alex, happy etc
13:19:15 <OceanSpray> hmm.
13:19:36 <Peaker> dcoutts, so installing cabal-install-0.5.0 and cabal-1.4.0.0 from hackage is a good idea?
13:19:47 * Peaker is installing it all from scratch
13:19:56 <dcoutts> Peaker: Yes it is a good idea. As for the consistency issue, you could first re-install zlib, that'd probably fix it.
13:20:20 <OceanSpray> "Haskell permits the omission of the braces and semicolons used in several grammar productions, by using layout to convey the same information. This allows both layout-sensitive and layout-insensitive styles of coding, which can be freely mixed within one program. Because layout is not required, Haskell programs can be straightforwardly produced by other programs."
13:20:40 <dcoutts> Peaker: or just install cabal-install manually and specify --constraint='bytestring==0.9.0.1' when you configure cabal-install
13:20:54 <Peaker> dcoutts, thanks! I'll try that
13:28:10 <LimCore> hello
13:28:26 <LimCore> how usable is haskel nowdays for real life desktop applications, comared to c++?
13:28:36 <mauke> about two
13:28:53 <mapreduce> I'd say 3, verging on infinity.
13:29:44 <olsner> somewhere between x and y, certainly
13:29:44 <olsner> no, wait, #haskell is supposed to be helpful
13:29:53 <dons> dcoutts: so did cabal-install get announced yet?
13:30:06 <dons> with a big stick/carrot encouragement to get cabal-install into all "out-of-the-box" distros?
13:30:30 <shapr> LimCore: I think Haskell isn't so good for embedded applications, like.. 16k of ram isn't enough. But for desktop-style apps, I'd say Haskell is more real life than C++
13:30:49 <shapr> I do wish the win32 code were better maintained, but I could fix that problem by maintaining it myself :-)
13:30:49 <dons> shapr: how about on the iphone?
13:30:59 <shapr> I dunno, has anyone tried it?
13:31:10 <mapreduce> What's the smallest amount of Haskell I can use to create a segfault?
13:31:11 <Baughn> shapr: I see no reason haskell should be any worse for embedded systems than any other GC'd language
13:31:12 <dons> no, but soon...
13:31:29 <shapr> mapreduce: unsafeCoerce?
13:31:31 <dons> mapreduce: haskell98? none.
13:31:38 <dons> you have to use the FFI, or find a bug.
13:32:00 <dons> it's a good puzzle :)
13:32:14 <Baughn> Or instance Typeable badly? ;)
13:32:23 <mauke> -> unsafeCoerce
13:32:27 <dons> not h98.
13:32:49 <shapr> LimCore: Got any specific applications in mind?
13:32:53 <Baughn> Well, just make an endless loop. One bottom is as good as another, right?
13:33:29 <OceanSpray> That's what she said.
13:33:35 <shapr> oj
13:34:12 <sjanssen> mapreduce: IORef + unsafePerformIO can create a segfault
13:34:42 <sjanssen> (neither are in Haskell '98 but both are widely available)
13:34:56 <Baughn> Hm. Does GHC use segfaults to improve the GC performance?
13:35:03 <Baughn> If so, just about any program would produce segfaults. ;)
13:35:24 <mauke> wait, no IORefs in H98?
13:35:29 <sjanssen> I don't think so
13:36:03 <dons> nice, "Thanks to the beta chapters of the Real World Haskell book I was able to finally 'get it'.
13:36:06 <dons> Haskell is elegant, powerful and surprisingly pragmatic.
13:36:09 <dons> "
13:36:11 <dons> pragmatic, woot!
13:36:24 <shapr> dons: Where's that from?
13:36:24 <mapreduce> @go real world haskell
13:36:25 <lambdabot> http://www.realworldhaskell.org/blog/
13:36:25 <lambdabot> Title: Real World Haskell
13:36:38 <dons> http://blog.gmosx.com/2008/06/finance-and-haskell.html
13:36:39 <lambdabot> Title: I have always been here: Finance and Haskell
13:36:40 <dons> just a little blog post
13:36:41 <sjanssen> @type Foreign.peek Foreign.nullPtr -- these are actually in a standard
13:36:45 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO a
13:36:52 <rwbarton> mapreduce: you could try writing garbage to /proc/self/mem, on linux
13:37:19 <Baughn> /proc/self/mem isn't in the standard. ;)
13:37:44 <mauke> raiseSignal sigSEGV
13:37:50 <mauke> yay
13:38:04 <sjanssen> requires FFI and/or extra libraries
13:38:06 <dons> byorgey: do you have an rss feed reader installed?
13:38:13 <dons> very useful for finding these sneaky blog articles
13:42:48 <dons> dcoutts: we need a 'haskell platform' list!
13:42:58 <dons> its hard working out what to prioritise on a new platform
13:47:35 <shapr> Yeah!
13:49:31 <dons> ghc, cabal-install, then happy, haddock, alex, haxml, binary, what next?
13:49:51 <dons> since i don't think i can get all of hackage into the "out-of-the-box" arch linux
13:49:58 <dons> but a core platform enough to do everything useful
13:50:06 <dons> oh, gtk2hs + cairo, since all the fun games need that.
13:50:09 <dons> and hopengl
13:51:26 <OceanSpray> hopegl
13:51:36 <OceanSpray> dons, you use archlinux?
13:51:48 <dons> yes. join #arch-haskell :)
13:53:08 <dons> http://wiki.archlinux.org/index.php/Haskell_package_guidelines covers the main story
13:53:09 <lambdabot> Title: ArchWiki :: Haskell package guidelines - ArchWiki
13:53:43 <roconnor> what is arch-linux?  I fear it is some combination of arch and linux.
13:54:15 <dons> ?go arch linux
13:54:15 <lambdabot> http://www.archlinux.org/
13:54:15 <lambdabot> Title: Arch Linux
13:54:21 <dons> a BSD-like linux distro
13:54:32 <roconnor> anything to do with gnu-arch?
13:54:37 <dons> nope.
13:54:47 <dons> with a strong "wiki" culture, of anyone can contribute anything
13:55:03 <roconnor> dons: I figured you'd be using nixos
13:55:21 <dons> hey, don't stereotype me
13:55:30 <dons> i don't like to be type cast :)
13:55:35 <roconnor> :)
13:56:15 <LimCore> hi, how usable is haskel nowdays for real life desktop applications, comared to c++?
13:56:49 <dons> entirely usable, LimCore. there are several widely distributed open-source haskell desktop apps now
13:57:24 <dons> check out the range of things on hackage.haskell.org
13:57:24 <LimCore> and how hard is it to learn when knowing c++?
13:57:38 <RayNbow> LimCore: do you only know C++?
13:57:39 <dons> hmm, its quite different to C++, but at least they're both staticall ytyped
13:57:45 <LimCore> is writting regular imperative functions easy in haskel?
13:57:56 <LimCore> RayNbow: c++ php pascal java
13:58:23 <mauke> LimCore: reasonably easy
13:58:24 <jdrake> Haskell:   Our shields cannot repel a type system of that magnitude!
13:58:35 <mauke> some parts feel more like asm than C
13:58:36 <LimCore> which of things available in C++ I can not use in haskel easly?   Most of my code is fine with normal imperative approach
13:58:37 <RayNbow> then prepare for a mind blowing experience :p
13:59:03 <Korollary> most of code is fine with anything
13:59:12 <mauke> LimCore: classes, templates, exceptions, new/delete, namespaces, arrays, ...
13:59:23 * LimCore facepalms
13:59:26 <dons> Korollary++
13:59:27 <LimCore> what about OOP then?
13:59:34 <mauke> LimCore: not really
13:59:36 <dons> LimCore: i think you should read up on haskell a bit first :)
13:59:46 <dons> it's not descended from, or related to C++, in any way.
13:59:47 <mauke> there is a library (OOHaskell) but I don't think it makes sense to write C++ in Haskell
14:00:32 <conal> LimCore: you can program imperatively in Haskell.  but then you're not really learning functional programming, which is what makes haskell great.
14:01:14 <Baughn> LimCore: If you can't imagine how to program a GUI non-imperatively, I suggest you look at functional reactive programming. There are solutions - good ones, too.
14:01:41 <conal> imperative thinking is a habit.  it can be overcome.
14:02:01 <monochrom> Most of the time you don't use full OOP anyway. The fragment you use has alternatives in Haskell, e.g., typeclasses.
14:03:40 <Korollary> imperative thinking is necessitated by the CPU's cost model
14:04:04 <Baughn> Korollary: Huh?
14:04:14 <Baughn> @users
14:04:14 <lambdabot> Maximum users seen in #haskell: 471, currently: 426 (90.4%), active: 23 (5.4%)
14:04:23 <roconnor> optimizeUI :: Output UI IU (Markets -> Claim -> Int -> (Double, Double))
14:04:25 <roconnor> optimizeUI =
14:04:29 <roconnor>   lambda (readIn []::Input UI Markets)
14:04:29 <roconnor>    (lambda (choices l (head l))
14:04:29 <roconnor>     (lambda (islider (1,99) 50)
14:04:29 <roconnor>             (pair showDisplay showDisplay)))
14:04:29 <roconnor>  where
14:04:30 <roconnor>   l = map fst $ sortBy (compare `on` snd) fxNameGraph
14:04:35 <roconnor> that's my GUI
14:04:38 <roconnor> appicaiton
14:04:45 <mauke> looks like lisp
14:04:47 <roconnor> Granted it is a pretty small GUI
14:05:03 <roconnor> 1 drop down, 1 slider, and two output boxes
14:05:28 <ddarius> IU?
14:05:38 <Korollary> interface user
14:05:50 <RayNbow> UI = monad, IU = comonad?
14:06:10 * RayNbow is just guessing
14:07:18 <telexicon> so complicated :S
14:07:18 <roconnor> that is the GUI part only.  No logic
14:07:20 <roconnor> IMHO lambda is a bad name.  I think it should really be arrow
14:07:20 <roconnor> but I'm not sure
14:08:13 <monochrom> 5 lines of code is complicated?
14:08:13 <roconnor> then the UI is attached to the actual functionality:
14:08:13 <roconnor> optimizeTV =
14:08:13 <roconnor>   tv optimizeUI
14:08:13 <roconnor>    (\m c i -> optimizeHoldings m c (fromIntegral i))
14:08:29 <monochrom> Equivalent Java code is about twice that.
14:09:02 <roconnor> UI's are composable:
14:09:06 <roconnor> optimizeMarketsTV = marketsTV ->| optimizeTV
14:09:20 <ddarius> monochrom: Probably more than that since you would have to add event handlers for the input.
14:09:21 <dcoutts> dons: not announced yet
14:09:22 <roconnor> and can form an application
14:09:25 <roconnor> main = do
14:09:25 <roconnor>   runTV optimizeMarketsTV
14:09:37 <Baughn> @users
14:09:41 <roconnor> that that, my friend, is how we do it.
14:10:31 * monochrom finally understands "joe programmer"s definition of complexity: how much you can do by one line of code. For example Java is 20 times more complex than asm.
14:10:35 <roconnor> UIs are typed and can only be attached to functions of the appropriate type.
14:11:02 <dcoutts> dons: re platform list, lets start small
14:11:14 <dons> dcoutts: i think you could do a good announcement tomorrow then
14:11:19 <dons> maybe do a blog post, in prime time :)
14:11:21 <dons> with examples
14:11:21 <dcoutts> dons: I'd really like to use the platform set as a QA hurdle
14:11:35 <dons> agreed
14:11:39 <dcoutts> dons: yes, I want to blog about solving the diamond dep problem
14:11:53 <Beelsebob> monochrom: how much you can do in one line isn't a good measure -- how much you can *clearly* do in one line possibly is
14:12:00 <dcoutts> dons: and I'll announce too
14:12:03 <Beelsebob> e.g. I can do a whole lot of stuff in one line of brainfuck
14:12:51 <roconnor> ddarius: lambda is a function that takes a input widgit and and output widget and produces a union of the two (which is an output widget)
14:13:06 <ddarius> roconnor: Why are you telling me?
14:13:14 <Baughn> roconnor: Why do you call it lambda?
14:13:38 <roconnor> ddarius: oops, should have sent that to mauke
14:13:38 <ddarius> Baughn: He's using a library.
14:13:57 <telexicon> monochrom, not necessarily
14:13:57 <Baughn> Hm. right. roconnor: Which library?
14:14:02 <telexicon> monochrom, its a balance
14:14:13 <roconnor> Baughn: conal calls it lambda.
14:14:50 <roconnor> because it is related to making UIs for functions
14:14:50 <roconnor> But I'm pretty sure it should be called arrow
14:14:53 <dcoutts> dons: also, the workload for managing a platform grows almost-linearly with the size (this is my experience from gentoo) so having automation is vital if we're not to have it become a huge time drain
14:14:53 <roconnor> (which is also related to functions)
14:15:08 <zebinho> hello i need help about one assigment in haskell could somebody please help me :)
14:15:12 <telexicon> between how much you can do on a single line vs how many lines it takes to do something
14:15:19 <zebinho> hello i need help about one assigment in haskell could somebody please help me :)
14:15:39 <dcoutts> dons: so everyone using the new cabal-install is collecting build reports but we're not uploading them centrally yet. That should be a priority.
14:15:40 <Beelsebob> zebinho: things we don't help with (1) school assignments... things we do help with (1) problems understanding Haskell concepts
14:15:41 <monochrom> Beelsebob: I am clearly not endorsing the measure I described.
14:16:24 <zebinho> hmm why dont you help with school assigmnets...also i'm on college
14:16:26 <Beelsebob> so I recommend you phrase your problem with your assignment in a way that we can help you understand Haskell better -- and then we're fairly likely to help
14:16:34 <RayNbow> roconnor, did I miss anything during the netsplit? :p
14:16:47 <Beelsebob> we don't help with school/college assignments because the point is to test whether *you* understand the concepts
14:16:54 <Beelsebob> not whether an IRC channel somewhere does
14:17:15 <Beelsebob> *if* you understand the concepts after an IRC channel helps you understand them, that's a bonus though
14:17:50 <roconnor> RayNbow: a little
14:17:55 <mauke> heh, maybe I should start doing people's haskell homework in C
14:17:56 <monochrom> I think everyone has the freedom to ask homework questions, unclear questions, incomplete questions, empty questions... And everyone has the freedom to apply /ignore on them.
14:18:12 <RayNbow> roconnor, did you see the following two lines?
14:18:12 <RayNbow> <RayNbow> UI = monad, IU = comonad?
14:18:12 <RayNbow> * RayNbow is just guessing
14:18:24 <telexicon> does the standard library have hashes (sha1, md5) or maybe even hmac-sha1?
14:18:31 <roconnor> I'm not sure if that is true or false
14:18:45 <mauke> depends on your definition of "standard library"
14:18:51 * monochrom 's 10-year experience of IRC says that it's futile to actually teach how to ask clear questions.
14:19:08 <zebinho> Beelsebob: so in a way if someone gives us a week to write somethin in haskell and in silverlight
14:19:11 <zebinho> thats ok
14:19:12 <roconnor> @where crypto
14:19:13 <lambdabot> http://www.haskell.org/crypto
14:19:19 <RayNbow> roconnor: which GUI module did you use for your application?
14:19:20 <mauke> zebinho: no, it's irrelevant
14:19:24 <vininim> ^
14:19:27 <vixey> zebinho: Did your teacher tell you to come to #haskell?
14:19:28 <roconnor> @hackage crypto
14:19:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/crypto
14:19:32 <zebinho> no
14:19:35 <roconnor> RayNbow: GuiTV
14:19:54 <zebinho> i found it while i was reading about haskell that it has this IRC group
14:19:56 <vixey> zebinho: just because you're not the first person from that class to come here and complain about their teache
14:19:58 <Beelsebob> monochrom: sure -- I was merely explaining the prevailing attitude in here -- which seems to be help people understand concepts, don't do their homework for them
14:19:58 <dafra> @hackage uvector
14:19:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector
14:20:25 <zebinho> yes i know they told on forum aobut this...
14:20:33 <osfameron> zebinho: why don't you stop arguing the point, explain your assignment, and how far you've got trying to work through it yourself?
14:20:41 <vixey> I think it's silly to complain about bad teachers, the only one you can rely on teaching you is yourself
14:20:54 <vixey> everything else is a plus
14:21:08 <vininim> except silverlight :)
14:21:18 <roconnor> telexicon: http://hackage.haskell.org/packages/archive/Crypto/4.1.0/Crypto.cabal
14:21:20 <zebinho> yes thats true about teaching yourself...but first come to my college :)
14:21:20 <lambdabot> http://tinyurl.com/6s9qrk
14:21:34 <monochrom> I prefer to see more haskell stuff in this channel and less repetition of lectures on what homework intends.
14:22:01 <monochrom> (The latter lectures should just be posted on haskellwiki and referred to every time.)
14:22:10 * roconnor wonders how fast Sha2 is in GHC 6.8
14:23:03 <zebinho> ok the assigment is to write a function that deletes from string every blank space ( tabulator, empty space, dots, two dots) )
14:23:32 <vininim> you have one week to do that?
14:23:41 <mauke> what's a two dots?
14:23:46 <zebinho> :
14:23:47 <Baughn> zebinho: Without using built-in functions?
14:23:52 <zebinho> yes
14:23:55 <zebinho> without
14:24:06 <Baughn> (That would normally be a one-liner)
14:24:11 <vixey> maybe we should open #haskell-school
14:24:19 <mauke> sub foo { $_[0] =~ tr/ \t.://d }
14:24:22 <Baughn> zebinho: Okay. Do you understand how to do it /with/ built-in functions?
14:24:26 <vixey> lol
14:24:44 <roconnor> /d ?
14:24:53 <mauke> delete
14:25:09 <roconnor> why not g?
14:25:14 <mauke> because tr/// has no g flag
14:25:20 <roconnor> oh
14:25:25 * roconnor doesn't know what tr is
14:25:44 <mauke> "transliterate"
14:26:10 <mauke> tr/abc/123/ turns a into 1, b into 2, etc
14:26:10 <augustss> The 'tr' command is very useful :)
14:26:10 <vininim> while we are off-topic, perl6 seems to be interesting, I hope it gets done before it gets irrelevant.
14:26:11 <Baughn> So =~ is a function that takes a variable and feeds it through the rhs function then puts it back? Or am I thinking too haskelly?
14:26:31 <mauke> Baughn: sort of, except less general
14:26:52 <mauke> =~ is a binding operator. it's limited to m//, s/// and tr/// (any others?)
14:27:17 <Baughn> Any particular reason for that restriction?
14:27:36 <mauke> it doesn't make sense for other operations
14:28:11 <Baughn> So, no foo =~ (+1), I guess
14:28:12 <osfameron> Perl 5 doesn't have an overarching design, just lots of exceptions to rules (much like English)
14:28:29 <mauke> Baughn: no, =~ doesn't necessarily modify anything
14:28:57 <mauke> it just binds an operator to a target
14:28:57 <Baughn> mauke: Okay. Before you say anything else.. should I learn perl? Would it /help/?
14:29:01 <Korollary> I think perl 5 is 60% syntactic sugar
14:29:14 <mauke> Baughn: you are learning perl right now :-)
14:30:26 --- topic: '["Read my lips: no more side effects!", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ "]'
14:30:26 --- topic: set by dons on [Wed Jun 04 11:14:29 2008]
14:30:26 --- names: list (clog greenrd mercury^ shachaf koninkje_away inimino1 inimino2 eno lucca dcoutts_ Mr_Awesome idnar Dunearhp cinimod uebayasi ecks hexpuem olsner Beelsebob sw17ch Minstrell__ OceanSpray ixdy_ MaK1 unknown_ inimino drbean Shurique Tomas kandinski atsampson gubagem nolrai_ sunnavy ydo dionoea quicksilver jql faXx cods newsham DuClare dogbite laz0r arguile Oatschool qebab czShadoW miasma funktio thorkilnaur GNU\caust1c Syzygy|de DRMacIver dogmaT_)
14:30:26 --- names: list (Laney gds jones- kpk ibid earthy twifkak Caelum Japsu arjanoosting audreyt allbery_b hellige Philippa_ ksandstr rms clkao nnunley wolverian kaol nornagon Elly rey_ cladhaire dufflebunk Mitar MrDomino vincenz ohub pejo Apocalisp johnlunney edwinb Lemmih ski_ maskd pa-ching byorgey agemo tessier_ sek Vulpyne wli mokus eyck warmenhoven klugez pantsd__ jmsaunde loop preflex orbitz fdr- dcoutts Spark chr1s jamesjb mauke Nafai mattam yango bran_)
14:30:26 --- names: list (jahgru Jaak pengrate sieni awesame l_a_m pragma_ dancor tchakkaway @ChanServ lilachaze ichor b4taylor tilman liyang` Staz acura mightybyte shawn__ osfameron levitation[A] agentzh thetallguy astrolabe sjanssen TSC Khisanth encryptio PHO_ slarba dobblego opqdonut jao Vq^ ubajas nothingmuch Fubar^ obk frederik_ Korollary Defty ertai Nanar ziman Twigathy flori puusorsa flux Deewiant ZsoL Heffalump bd_ integral frwmanners loupgaroublond nasloc__)
14:30:26 --- names: list (jleedev saiam dvekravy kosmikus Jiten Choko mattiast_ wadcom tuukkah Zao mar77a Anthraxx cjb czakey dc-Ankan kolmodin felipe dons hukolele xsdg sffubs sheyll Paks m4thrick petekaz And[y] Baughn vixey Botje Arnar pastorn Draconx noj davidL Ugarte liesen_ glith_ buff_dri1kslot kalven_ xian Maddas_ mux AshyIsMe mm_freak Shimei elias` ac jre2_ arossato- mrd cnwdup BeelsebobWork_ gal_bolle praseodymium jelmer Lunchy HKhan nominolo eek jonafan)
14:30:26 --- names: list (mwti roconnor binary42 littledan proq pizza_ smtms cjay btipling birkenfeld Adamant lispy Poeir_ hpaste sarehu_ rue netx Cale stylus OnionKnight ivan rwbarton Caelum_ yahooooo borism noddyB fnordus raxas Ingmar nwf jdavis dibblego KinkyBlackGoat ulfdoz scook0 r0bby dort atp sutats_ Axman6 augustss znutar falseep Gilly sbahra Dessous therp iblechbot ttt-- aik__ Saul_ basti_ snhmib Nshag Toxaris der_eq zoq XGas mxc stevan ivanm thingwath)
14:30:26 --- names: list (lekro zeno telexicon ttmrichter BCoppens juplols opqdonut_ dblog phlpp Dybber foff gweiqi twanvl dolio monochrom Averell- globra a11235 danjam yoeljacobsen mejja araujo QtPlatypus edwardk cubix erg0t leoncamel conal Tigran rdd IanXX xif cognominal_ gwern Itkovian tusho shag gbeshers authentic aFlag fadec mapreduce SimonRC ikegami-- glguy Peaker sclv swiert panzi skorpan dafra sykopomp Modius SuttoL sad0ur takuan_dozo Corun Shimuuar twobitwork)
14:30:26 --- names: list (mathrick jdrake Valodim_ Plareplane_ twadleigh Liskni_si Saizan pakmei mornfall xd bos31337 oldsalt_ dje whoppix_ lstor_ jfredett tverwaes vininim MyCatVerbs ToRA wjt elliottt hjon Riastradh lament Tobsan hkBst shepheb_ zebinho slava tromp xinming pierre- RayNbow spoop simony wagle Poeir geocalc lambdabot solrize matthew-_ smg tessier brandon andun wangor shapr[ Dreamer SubStack MarcWeber Taggnostr jon_gw jamii shepheb__ xci_ equanimi1y)
14:30:26 --- names: list (lQg_ pjd_ tero-_ mlh_ deemon_ jmo-_ @Igloo gubagem1 ArthurClemens_ augur ddarius kpreid BONUS blbrown mattrepl mlh oubiwann fxr saccade equanimity kawfee gbacon zamez)
14:30:48 <mauke> Baughn: it doesn't mean anything
14:31:09 <Baughn> So when you used it in a sentence..?
14:31:28 <mauke> it's used to describe what =~ does
14:31:41 <dons> dcoutts: maybe a good time to publish those libs failing to build due to trivial reasons?
14:31:42 <mauke> that doesn't mean it has an independent definition
14:31:50 <zebinho> Baughn: i dont know whats the built in fuction
14:32:05 <zebinho> i'm looking and i dont know where to find
14:32:11 <zebinho> give me half an hour
14:32:13 <dcoutts> dons: I don't yet have a good presentation form for that. I could do something using the build reports from my machine.
14:32:42 <Baughn> zebinho: There is, of course, no function that does /exactly/ what you've been asked to do. There is one that almost does, and can be mangled into doing so quite easily. Good luck.
14:32:49 <mauke> m// is a search, s/// and tr/// are search&replace. =~ tells them on which value to act. that's it, more or less
14:32:54 <Baughn> zebinho: Hint: type String = [Char]
14:35:59 <joe2757> hi all
14:36:12 <augustss> hi
14:36:39 <joe2757> im wondering if anyone uses the eclipse haskell plugin for development
14:36:40 <osfameron> :t isDigit
14:36:48 <lambdabot> Char -> Bool
14:37:08 <Korollary> joe2757: I tried, but couldn't make it work to my satisfaction
14:37:45 <joe2757> Korollary: that's my experience so far, too; what do you use?
14:37:46 <osfameron> @pl (\x -> isDigit x || isAscii x)
14:37:46 <lambdabot> liftM2 (||) isDigit isAscii
14:37:50 <osfameron> eeeek!
14:38:18 <mauke> readerwned
14:38:50 <Korollary> joe2757: I tried 0.8 as downloaded by eclipse itself (I was expecting 0.9), which compiled things fine, but indentation was broken. Then I downloaded 0.11 myself, which I couldn't get to compile sources.
14:38:51 <osfameron> is that the clearest way to do it?
14:39:01 <mauke> :t flip any [isDigit, isAscii] . flip id
14:39:03 <lambdabot> Char -> Bool
14:49:27 --- mode: irc.freenode.net set +o Igloo
14:49:27 --- mode: irc.freenode.net set +o ChanServ
14:49:27 <vixey> augustss, me too, and things like (++ "x" ++) would be nice as well
14:49:27 <marcot> @type (0,)
14:49:27 <lambdabot> parse error on input `)'
14:49:27 <vixey> but writing a haskell parser seems quite hard .. so I didn't try
14:49:27 <augustss> vixey: it is
14:49:27 <marcot> I thought I could use , like +
14:49:27 <vixey> (,) (,,) (,,,) ... are function names
14:49:27 <augustss> vixey: no one has succeeded yet, as far as i know
14:49:27 <marcot> hum..
14:49:27 <skorpan> what about parsec?
14:49:27 <vixey> augustss: huh?!
14:49:30 <mauke> vixey: there is no conforming haskell parser
14:49:37 <vixey> why not?
14:49:41 <augustss> vixet: all know haskell compiler have known parsing bugs
14:49:44 <mauke> because the spec sucks
14:50:47 <Korollary> joe2757: actually, now 0.11 seems to work
14:50:48 <augustss> mauke: the spec was written before any implementation
14:51:02 <marcot> Do you use col 80 as a limit for haskell code?
14:51:14 <augustss> marcot: I don't
14:51:18 <zebinho> hey
14:51:27 <joe2757> Korollary: out of the box?  no config necessary?
14:51:53 <osfameron> that  liftM2 (||) isDigit isAscii doesn't work
14:52:01 <osfameron> No instance for (Monad ((->) Char))
14:52:11 <osfameron> :t  liftM2 (||) isDigit isAscii
14:52:12 <lambdabot> Char -> Bool
14:52:15 <osfameron> meh
14:52:17 <mauke> osfameron: import Control.Monad.Reader
14:52:20 <jganetsk_> i have a basic haskell question
14:52:26 <zebinho> so can anybody help me with my school assigment
14:52:33 <augustss> jganetsk_: we have basic haskell answers
14:52:39 <mauke> zebinho: no, I can only answer questions
14:52:46 <zebinho> ok
14:53:07 <marcot> augustss: but what limit do you use?
14:53:10 <jganetsk_> i just made a data type, Heap a
14:53:12 <zebinho> how to check that a string has some type of sign in it
14:53:20 <jganetsk_> it only works for Ord a
14:53:23 <marcot> augustss: or you use just good sense?
14:53:29 <Korollary> joe2757: 0.11 needs to be downloaded and manually linked. Other than that, I didn't do anything.
14:53:33 <mauke> jganetsk_: no, the type works for any a
14:53:33 <augustss> marcot: no fixed number, probably around 150
14:53:40 <jganetsk_> ok
14:53:44 <mauke> zebinho: check each character
14:53:44 <osfameron> zebinho: what would you try?  To check if a character was a space, for example?
14:53:54 <jganetsk_> right, many of my functions have an Ord a => requirement on them
14:54:05 <mauke> or rather, check the first character, then the rest
14:54:09 <mauke> (maybe)
14:54:21 <jganetsk_> i'm trying to implement the Foldable class
14:54:26 <jganetsk_> but the Ord a requirement has gotten in the way
14:54:38 <zebinho> yes
14:54:50 <jganetsk_> zebinho, is that yes to me?
14:54:50 <augustss> jganetsk_: you've run into the most annoying problem that the Haskell type system has at the moment
14:54:57 <zebinho> osfameron:yes
14:54:57 <jganetsk_> ok
14:55:07 <augustss> jganetsk_: there's no satisfying workaround
14:55:09 <jganetsk_> augustss, so i can't get around this rigth now?
14:55:10 <jganetsk_> ok
14:55:20 <jganetsk_> is there work on this issue?
14:55:27 <augustss> jganetsk_: I was actually looking at the problem just 5 minutes ago
14:56:05 <augustss> jganetsk_: I will again plead for working on it when I talk to (Haskell) people this week
14:56:32 <osfameron> zebinho: if you really have no ideas at all what to do, try reading a tutorial.  YAHT is online, for example here http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics
14:56:49 <osfameron> zebinho: you've been told that a string is a *list" of *char*aracters.
14:57:07 <osfameron> zebinho: look for functions that deal with those things
14:57:42 <jganetsk_> augustss, but i guess, in some sense , the current behavior is correct?
14:57:58 <augustss> jganetsk_: yes, it is
14:58:08 <augustss> jganetsk_: just very annoying
14:58:10 <osfameron> bedtime!
14:59:11 <augustss> jganetsk_: you can google 'restricted monad' for more of the same
14:59:56 <mauke> int contains(char c, const char *s) { return *s && (*s == c || contains(c, s + 1)); }
15:00:44 <zebinho> jganetsk: i know what string is but i dont have i dont know 3 weeks to resolve problem aobut this haskell i have other things to do on college this i s rather simple but i dont understand the haskell at all because i dont have time to study it...it sprobably two or three line solution....i mean i came here to look help and you point me to tutorilas........like i have my whole life to read them....
15:01:06 <mauke> er, what did you expect?
15:01:10 <mauke> that we write the program for you?
15:01:25 <Zao> Now that's rather silly.
15:01:28 <Centrinia> Has anyone ever written a second order quine: a program written in language A that prints out the source code for a program in language B that prints out the source code for the original program?
15:01:30 <zebinho> is this souch a problem..you alreday wrote to me 30 lines
15:01:36 <Zao> zebinho: Yes, it is.
15:01:41 <augustss> Centrinia: yes
15:01:55 <Centrinia> Where? :D
15:02:06 <augustss> Centrinia: http://sigfpe.blogspot.com/2008/02/third-order-quine-in-three-languages.html
15:02:07 <lambdabot> Title: A Neighborhood of Infinity: A Third Order Quine in Three Languages, http://tinyurl.com/yudlkm
15:02:20 <augustss> it's third order
15:02:30 <Centrinia> Nice. :D
15:03:01 <mauke> Centrinia: http://www.ioccc.org/2000/dhyang.c
15:04:15 <zebinho> is there any other haskell hat on this IRC?
15:05:08 <zebinho> chat*
15:05:16 <Centrinia> contains c s =  null $ filter (==c) s
15:05:25 <mauke> heh
15:05:35 <mauke> except he can't use filter or null (or elem)
15:05:41 <mapreduce> zebinho: I think it might be best to consult your lecturer.
15:06:16 <augustss> zebinho: you'll find people reluctant to do homework
15:06:26 <Centrinia> contains c s = and $ map (==c) s
15:06:44 <Zao> contains c s = 1 >= (length.filter) (==c) $ cycle s
15:07:10 <zebinho> my profesor is an idiot
15:07:11 <Centrinia> Wait, I need sleep.
15:07:12 <zebinho> :)
15:07:14 <Centrinia> I did that wrong. :|
15:07:21 <Zao> zebinho: The same can be said about you.
15:07:46 <zebinho> maybe from his prespective
15:07:58 <zebinho> perspective
15:08:17 <marcot> zebinho: de onde voc , cara?
15:08:47 <zebinho> english?:D
15:08:56 <Centrinia> contains :: (Eq a) => a -> [a] -> Bool
15:09:09 <Zao> zebinho: May I strongly suggest that you do the best of the situation and make a genuine attempt at learning the language instead of just cheating your way through the course.
15:09:10 <marcot> zebinho: where are you from?
15:09:30 <mauke> preflex: ? .hr
15:09:30 <preflex>  Croatia
15:09:52 <marcot> another bot?
15:10:20 <marcot> mauke: thanks.
15:10:30 <zebinho> yes Croatia
15:10:32 <marcot> That's because it sounds very much like portuguese.
15:10:39 <Centrinia> zebinho, I'll give you this: contains (Eq a) => [a] -> [a] -> Bool; contains a b = or $ map (==a) $ map (take (length a)) (tails b)
15:10:42 <newsham> augustss: see first 3 at http://codepad.org/users/haskell
15:11:33 <zebinho> tnx Cetrinia
15:14:01 <monochrom> We are still lecturing on student ethics?
15:14:20 <newsham> cant we get over ethnics already?
15:14:25 <Centrinia> let contains a b = or $ map (==a) $ map (take (length a)) (inits b) in (contains "oo" "google",containsn "ooo" "google")
15:14:35 <mar77a> > Just a
15:14:37 <lambdabot>  Just a
15:14:41 <Centrinia> > let contains a b = or $ map (==a) $ map (take (length a)) (inits b) in (contains "oo" "google",containsn "ooo" "google")
15:14:42 <lambdabot>   Not in scope: `containsn'
15:14:45 <Centrinia> Hmm, what happened to lambdabot?
15:14:58 <mar77a> > Just Nothing
15:14:59 <lambdabot>  Just Nothing
15:15:07 <Centrinia> Oh.
15:16:38 <Centrinia> > let contains a b = or $ map (==a) $ map (take (length a)) (tails b) in (contains "oo" "google",contains "ooo" "google")
15:16:39 <lambdabot>  (True,False)
15:16:52 <Centrinia> There. :)
15:17:13 <mauke> > "oo" `isInfixOf` "google"
15:17:15 <vixey> ooh
15:17:15 <lambdabot>  True
15:17:18 <vixey> contains is nice
15:17:21 <newsham> > let isSubstr a = any (isPrefixOf a) . tails in isSubstr "oo" "google"
15:17:23 <lambdabot>  True
15:17:33 <newsham> > let isSubstr a = any (isPrefixOf a) . tails in isSubstr "ooo" "google"
15:17:34 <lambdabot>  False
15:17:35 <vixey> @src isInfixOf
15:17:35 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:17:36 <mauke> I WIN
15:17:41 <vixey> You could use KMP
15:17:49 <vixey> I think it doesn't fit in one line though :P
15:18:39 <roconnor> @where KMP
15:18:39 <lambdabot> I know nothing about kmp.
15:19:02 <newsham> is there a KMP over Data.Sequence?
15:19:16 <vixey> the best bit about KMP I read it in Cormans algorithms book where it's introduced as a refinement of FSA
15:19:17 <roconnor> @where + KMP http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
15:19:17 <lambdabot> I know nothing about +.
15:19:28 <roconnor> @where+ KMP http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
15:19:28 <lambdabot> Okay.
15:19:36 <roconnor> @where KMP
15:19:36 <lambdabot> http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
15:19:45 <marcot> Is preflex another bot?
15:20:05 <roconnor> marcot: yes
15:20:13 <mauke> preflex: are you a bot?
15:20:13 <preflex>  yes.
15:20:27 <marcot> roconnor: written in haskell alson?
15:20:30 <vixey> oh http://okmij.org/ftp/Computation/lightweight-dependent-typing.html#Accompanying
15:20:32 <lambdabot> Title: Lightweight Dependent-type Programming, http://tinyurl.com/ylrm54
15:20:35 <newsham> ?bot
15:20:35 <lambdabot> :)
15:20:43 <roconnor> @where preflex
15:20:44 <lambdabot> I know nothing about preflex.
15:21:01 <newsham> preflex: info
15:21:11 <newsham> preflex: about
15:21:16 <newsham> preflex: help?
15:21:17 <mauke> ENOENT
15:21:21 <vixey> they are writing KMP in dependent ML in Haskell
15:22:33 <zebinho> Centrinia: could you please repeeta the code for me
15:23:00 <marcot> preflex: can you give help?
15:23:05 <marcot> =(
15:23:07 <mauke> preflex: help
15:23:07 <preflex>  try 'help help' or see 'list' for available commands
15:23:14 <vixey> preflex: calc 884848*2
15:23:14 <preflex>  1769696
15:23:53 <marcot> it's in haskell?
15:23:55 <dafra> preflex: calc [1..]
15:23:55 <preflex>  Lexical error
15:24:02 <mauke> marcot: yes
15:24:03 <dafra> preflex:  [1..]
15:24:32 <dafra> hmm
15:24:42 <dafra> preflex:  calc 1 + 1
15:24:43 <preflex>  2
15:24:55 <dafra> preflex:  help help
15:24:55 <preflex>  help COMMAND - show help for a command
15:25:02 <Baughn> preflex: calc f x = 2 in f 1
15:25:02 <preflex>  Lexical error
15:25:12 <Baughn> preflex: calc let f x = 2 in f 1
15:25:12 <preflex>  Lexical error
15:25:29 <dafra> preflex:  list
15:25:30 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma]; Nickometer: [nickometer]; Seen: [seen]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]
15:26:24 <newsham> preflex: version
15:26:24 <preflex>  2.876
15:26:40 <mauke> preflex: help version
15:26:40 <preflex>  version - print a random number
15:26:50 <vixey> haha
15:27:11 <newsham> i was hpoing for a random url
15:28:06 <newsham> preflex: store this that
15:28:17 <newsham> preflex: get this
15:28:17 <preflex>  that
15:30:36 <jganetsk_> is there a list of all the type classes taht come with the standard library?
15:31:00 <vixey> ?where report
15:31:01 <lambdabot> http://www.haskell.org/onlinereport/
15:31:12 <jganetsk_> thx
15:31:27 <vixey> I just got that link for me..
15:31:29 <mapreduce> Is it a bit redundant to have 'online' in a http URL?
15:32:14 <vixey> jganetsk_: http://www.haskell.org/onlinereport/prelude-index.html
15:32:15 <lambdabot> Title: Haskell 98 Prelude Index
15:32:33 <jganetsk_> but what about other modules, like Data?
15:32:40 <vixey> they are not standard
15:32:55 <jganetsk_> really? those are ghc?
15:34:23 <newsham> hugs also supports heirarchical libs, no?  but non std
15:34:33 <newsham> where "std" means "in the std"
15:34:52 <newsham> not to be confused with "ordinary, used by everyone"
15:56:59 <CVirus> eval  (Plus  e e`) = Foo (i+j) where (Foo i, Foo j) = (eval e, eval e`)
15:57:12 <CVirus> what is "where"
15:57:19 <CVirus> where can I read about it I mean
15:57:28 <mauke> in the language definition :-)
15:57:36 <mauke> 'where' creates a local declaration block
15:57:49 <mauke> also, ` should be '
15:57:55 <augustss> CVirus: it's like 'let'
15:58:06 <augustss> kinda
15:58:52 <CVirus> I just can't figure out why it is used in this example
15:59:07 <mauke> to unwrap the results of recursive eval cals
15:59:08 <mauke> +l
15:59:14 <vixey> CVirus: That's where the values i and j come from
15:59:30 <vixey> where is this code from by the way?
15:59:54 <mauke> eval (Plus e e') = let Foo i = eval e; Foo j = eval e' in Foo (i + j)  -- same thing
16:00:50 <CVirus> vixey: my lecture notes
16:01:02 <vixey> ok
16:01:11 <vixey> just thinking that Foo is a bit weird
16:01:19 <vixey> I wonder if it's pointless
16:01:34 <CVirus> let me paste you the complete example somewhere
16:01:37 <CVirus> give me a minute
16:01:44 <vixey> thansk
16:05:12 <gubagem> can haskell dynamically load haskell modules into a running haskell program?
16:05:44 <mauke> yes and no
16:06:22 <gubagem> Just yes| nothing? ;)
16:07:59 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
16:08:01 <lambdabot> http://tinyurl.com/5mbt3u
16:08:40 <CVirus> vixey: http://rafb.net/p/CxoVXA69.html
16:08:40 <lambdabot> Title: Nopaste - No description
16:09:14 <CVirus> good bot
16:09:24 * CVirus pats lambdabot
16:09:26 <vixey> ok it's not Foo.. this makes some sense :)
16:09:28 <mauke> @botsnack
16:09:29 <lambdabot> :)
16:09:45 <CVirus> vixey: there's an error by the way
16:09:49 <CVirus> can't figure it out
16:10:11 <vixey> yes you can
16:10:18 <vixey> just listen to what mauke said
16:11:20 <CVirus> still .. can't figure it out
16:11:27 <CVirus> new to haskell .. sorry
16:11:31 <mauke> figure what out
16:11:44 <vixey> would you like to see a different way to write this code?
16:12:06 <CVirus> sure
16:12:10 <CVirus> I hope it's easier
16:12:36 <CVirus> I just commented out all the lines except the "data" and the function signature
16:12:44 <CVirus> and yet there's an error in the function's signature
16:12:46 <CVirus> out of scope
16:12:49 <mauke> WHAT ERROR
16:12:57 <CVirus> Missing binding for variable "eval" in type signature
16:13:03 <mauke> ah, better
16:13:04 <CVirus> sorry
16:13:07 <mauke> are you on hugs?
16:13:13 <CVirus> yup
16:13:19 <mauke> that means 'eval' is undefined
16:13:37 <CVirus> oh .. got that
16:13:41 <vixey> CVirus, http://rafb.net/p/cNN2y615.txt
16:13:45 <mauke> you can't just write a type signature for things that don't exist
16:14:00 <mauke> heh, GADTs
16:14:34 <CVirus> vixey: thanks
16:14:50 <mauke> make it even more EXPERT with 'data Expr :: * -> * where ...'
16:15:14 <vixey> I think the GADT version is much simpler :)
16:15:14 <CVirus> expert ? I just started learning haskell a few hours ago .. heh
16:15:22 <CVirus> eval (Plus e e`) = I (i+j) where (I i, I j) = (eval e, eval e`)
16:15:28 <CVirus> Syntax error in declaration (unexpected `)')
16:15:30 <mauke> does hugs even do GADTs?
16:15:36 <vixey> CVirus: listen to what mauke said
16:15:46 <vixey> "` should be '"
16:15:53 <vixey> `'s have special meaning in haskell
16:16:05 <CVirus> ahhh
16:16:18 <CVirus> thanks alot
16:16:26 <vixey> you cannot use ` in a variable name, but ' is ok
16:16:37 <CVirus> now I get it :-D
16:16:48 <CVirus> Thanks again
16:17:09 <vixey> but this primitive boxing/unboxing with I and B is quite sickly
16:17:21 <vixey> so there is a good alternative
16:22:23 <dons> dcoutts: we need to crack down on these hackage libraries that include 'test' executables
16:22:32 <dons> first, it screws up my detection of what is a library
16:22:48 <dons> and secondly, things like 'numbers' install a 'test binary that clashes with /usr/bin/test , for example
16:22:55 <dons> crypto distributes runTest
16:25:09 <dancor> what is the right way to have (a, b) + (c, d) = (a + c, b + d)
16:25:17 <dancor> just make (.+) ?
16:25:43 <mauke> > (a :+ b) + (c :+ d)
16:25:45 <lambdabot>   add an instance declaration for (RealFloat Expr)
16:25:49 <mauke> :-(
16:25:59 <Pseudonym> dancor: There is no "right way", but that way works.
16:26:12 <Pseudonym> I often use <+> in such situations.
16:26:37 <vixey> instance Num a => Num (a,a) where
16:26:48 <vixey>  (a, b) + (c, d) = (a + c, b + d)
16:26:53 <dancor> Num is cheating
16:27:04 <mauke> I sometimes tell my Haskell to count the length of an infinite list just to make my laptop warm and put it on my lap. When I close my eyes, it feels almost like a girl is sitting there ;_;
16:27:06 <vixey> dancor: I don't know what you mean
16:27:19 <dancor> vixey: well * doesn't make sense for me here, so Num feels dirty
16:27:33 <Botje> mauke: pffrt. haskell finishes that in 8.3 seconds.
16:27:36 <Botje> barely enough time to get warm
16:27:57 <Pseudonym> Num is wrong.
16:27:59 <vixey> dancor:  (a, b) * (c, d) = (a * c - b * d, a * d + b * c)
16:28:08 <Pseudonym> @hoogle Num
16:28:10 <lambdabot> Prelude.Num :: class (Eq a, Show a) => Num a
16:28:10 <lambdabot> Numeric :: module
16:28:10 <lambdabot> GHC.Conc.numCapabilities :: Int
16:28:47 <Pseudonym> What's a reasonable meaning for fromInteger?
16:29:13 <vixey>  fromInteger x = (fromInteger x, 0)
16:29:26 <Pseudonym> Why not fromInteger x = (fromInteger x, fromInteger x)?
16:29:34 <vixey> as you wish
16:29:41 <Pseudonym> That's my point.
16:29:47 <vixey> I was making a ring
16:29:48 <Pseudonym> There's no _one_ good meaning.
16:29:51 <vixey> or feild actually
16:30:02 <Pseudonym> Well in that case, surely:
16:30:02 <vixey> (x,y) = x :+ y seems fine
16:30:04 <mauke> fromInteger x = join (***) fromInteger (x `quotRem` 7)
16:30:10 <Pseudonym> fromInteger x = (fromInteger x, fromInteger 1)
16:30:23 <Pseudonym> If you're making a field.
16:30:27 <vixey> anyway my entire code was just two lines
16:30:38 <vixey> I don't care about (*) or fromIntegral
16:30:57 <Pseudonym> The actual problem here is that Num is fat and greedy.
16:31:04 <Pseudonym> ?go Num is such a fat and greedy class
16:31:05 <lambdabot> No Result Found.
16:31:08 <Pseudonym> Hmm.
16:31:11 <vixey> hehe
16:31:13 <mauke> ?go foo
16:31:13 <lambdabot> http://en.wikipedia.org/wiki/Foo
16:32:13 <Pseudonym> ?quote DanWeston If you want to marry Cinderella, you have to take her ugly stepsisters too.
16:32:13 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
16:32:23 <Pseudonym> ?remember DanWeston If you want to marry Cinderella, you have to take her ugly stepsisters too.
16:32:23 <lambdabot> I will never forget.
16:32:32 <Pseudonym> That's a reference to the Num class.
16:33:22 <vixey> I like no implicit prelude
16:33:37 <mauke> -fno-explicit-prelude
16:33:46 <Pseudonym> There's something nice about having to import Int if you want to use Ints.
16:37:49 <dobblego> let c p = return mzero p -- fine; let c = return mzero -- fails to compile, wtf?
16:37:59 <dons> dcoutts: does hackage warn about license-file/license incompatibilties?
16:38:28 <Pseudonym> :t let c p = return mzero p in c
16:38:30 <lambdabot> forall t (m :: * -> *) a. (MonadPlus m) => t -> m a
16:38:35 <Pseudonym> :t let c = return mzero in c
16:38:37 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, MonadPlus m1) => m (m1 a)
16:38:58 <Pseudonym> dobblego: Monomorphism restriction, by any chance?
16:39:12 <dobblego> Pseudonym, yes I think so, thanks; didn't think of that
16:41:08 <hpaste>  dolio annotated "ST vs. uvector benchmarks" with "MutableByteArray#" at http://hpaste.org/8345#a7
16:56:47 <dolio> @seen dons
16:56:47 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc, #ghc and #arch-haskell. I last heard dons speak 18m 48s ago.
16:56:54 <dons> dolio:
16:57:28 <dolio> If that benchmark is any indication, reads/writes to MutableByteArray#s are slower than to Addr#s.
16:57:47 <dolio> Although, on the upside, your uvector somehow manages to beat my hand-coded MutableByteArray code. :)
16:57:51 <dons> that's odd. they should be the same primitives underneath
16:57:56 <dons> ah right.
17:01:05 <dolio> dons: At least, the ones from newByteArray#
17:01:44 <augustss> dons: just shows you need to improve your coding skillz ;)
17:03:00 <bos31337> ooh, maybe i can write a parallel collaborative filter using the example mapreduce code
17:04:33 <dons> dolio: so the uvector library result is outperforming the hand written one? hehe ok.
17:04:38 <dons> well ,that at least gives us something to look at
17:04:51 <dolio> Yeah, it seems that way, at least.
17:06:29 <dolio> For giggles, I also rewrote the fannkuch benchmark unboxing everything and using mutable byte arrays, and it was about on par with uvector.
17:06:48 <CVirus> how can I define both deriving Show and Eq for the same data type ?
17:07:00 <vixey> deriving (Show, Eq)
17:07:16 <CVirus> vixey: thanks
17:07:17 <dolio> So uvector is plenty optimized, I guess, it's just that mutable byte arrays are slower than addrs.
17:07:54 <dons> i'm a bit suspicious about that. there might be a GC overhead, but since we're supposed to be generating non-allocating loops, they should be pretty much the same
17:08:02 <dolio> And STUArray has problems with unboxing.
17:08:40 <dons> well, it's overly overloaded, making things a bit harder.
17:08:49 <dons> a couple more specialisations need to fire, than with uvector
17:09:17 <mapreduce> dons: What software did you use for the comments system on the book?
17:10:31 <dons> django, and lots of bos customisations, iirc
17:11:12 <bos> django's just an app server, so i wrote an app with it.
17:11:58 <mapreduce> I see, thanks.
17:11:58 <dolio> Incidentally, I looked up your book today at one of the terminals at Borders, and bos gets sole credit. :)
17:12:18 <bos> i'm sure that will be fixed once the thing is out.
17:13:25 <dolio> They might only list the first author in the summary. I'm not sure.
17:13:25 <Pseudonym> I wouldn't put too much faith in the Borders catalogue system.
17:13:32 <Pseudonym> I don't think they ever clean it up.
17:13:35 <dolio> First by first name...
17:14:04 <mapreduce> I just find it depressing that most books seem to be priced according to the number of pages they have.
17:14:15 <mapreduce> (UK, though)
17:14:42 <mapreduce> A refreshing outlier was a 1000-page collection of Arthur C. Clarke short stories. :)
17:14:56 <Pseudonym> mapreduce: K&R is also a notable outlier.
17:17:03 <monochrom> I have only looked at Haskell and Java books. They are priced according to the number of pages they have. E.g., a Java is 500 pages and $30, a Haskell book is 200 pages and $60.
17:18:12 <Pseudonym> K&R, back in the day, was 272 pages, and about 70 AUD at its worst.
17:18:15 <idnar> monochrom: so the fewer pages in the book, the more it costs?
17:18:46 <monochrom> Yeah!
17:19:36 <idnar> I guess Cisco training manuals don't follow that pricing scheme :P
17:19:41 <QtPlatypus> I've noticed something odd.  Most of my time as a professional programer has been spent debugging rather then writing code, however none of my classes at Uni talked about the nature of bugs and debugging techqueeks, that I had to learn via tradation and T&E.
17:19:52 <dolio> dons: Oh, found the reason my code was slower. It's now at or a little ahead of uvector, although addr still seems to edge it out.
17:20:02 <Pseudonym> Cisco is like PayPal or the mafia. You don't give them money because you want to.
17:20:19 * dolio longs for static argument transform.
17:20:46 * QtPlatypus should write a book with 0 pages and charge a value that approches postive infinity.
17:21:20 <monochrom> Four years is not enough to teach debugging anyway.
17:21:34 <gubagem> how hard is it to get ghc working on openBSD without a net connection
17:23:06 <QtPlatypus> monochrom: True enought, but I think that some advice would have been helpfull.  The whole point of education is so that we don't have to waste time discovering some trival thruths for ourselves.
17:25:48 <monochrom> A degree in criminology may help.
17:26:21 <dolio> Reversing a size-10 array of Ints 800 million times: Addr# 22 seconds, uvector/MutableByteArray# 26 seconds.
17:27:07 <mmorrow> haha, 800 million of anything sounds like a supervillain ransom request
17:27:21 <Botje> rofl :)
17:27:57 <monochrom> "We have your daughter. You must do 800 million pushups to get her back."
17:28:14 <mmorrow> "and we're using Addr#s!"
17:28:36 <dolio> That, along with overhead from copying (Addr# can use memcpy, ByteArray# only has above reads/writes) is, I imagine, the source of the slow-down on fannkuch.
17:32:03 <dolio> And then we have to figure out why Addr#/MutableByteArray# is slower than Java arrays, I guess. :)
17:36:53 <dons> dolio: interesting. got code for just the reversal?
17:38:48 <dolio> Yeah, it's the second set of benchmarks here: http://hpaste.org/8345#a7
17:39:09 <dons> looking...
17:39:53 <dolio> The MutableByteArray# code goes faster if you change go' to eliminate passing around the static 'arr' argument.
17:40:31 <dons> ah, that's not surprising. ghc only recently got the static argument transformation. it does spot this under some other circumstances , but its still a good idea to do that yourself
17:42:09 <dolio> Yeah, I have been, but, for instance the Addr# fannkuch code doesn't bother, so I thought it might not matter, but I guess it does.
17:42:18 <dons> hmm
17:42:35 <dolio> I guess that might mean the Ptr code there could go even faster...
17:43:30 <dolio> Matter in this instance, that is. I've seen that transformation cause dramatic speedups elsewhere.
17:43:58 <OceanSpray> Holy netsplit, Batman!
17:44:27 <dons> yea, the Addr# version generates nice code
17:44:36 <dons> hand written core has a nice property that it doesn't get optimised any further
17:44:42 <dons> so you know exactly what you're getting
17:46:00 <dons> hmm, yes, good difference between Addr and MutableArray
17:47:35 <dolio> Doing static argument transform on that Addr# code actually makes it slower.
17:47:59 <dons> those worker/wrapper splits on reverse mean it can be productive to inline the top level function
17:48:37 <dons> hmm, still a good bit slower than Addr#
17:49:41 <dons> so I wonder if readIntArray# is different significantly to  readIntOffAddr#
17:50:17 <dons> since the 'reverse' loops are basically identical
17:53:04 <sarehu_> I have invented a Haskell function that lets you stab people in the face on the internet.
17:53:27 <sarehu_> > (last . cycle) "sarehu_"
17:53:42 <lambdabot>  thread killed
17:53:45 <sarehu_> what
17:53:52 <sarehu_> :'( your messages are different
17:54:15 <dons> dcoutts: seen this, http://people.debian.org/~nomeata/hackagevsdebian.html
17:54:15 <lambdabot> Title: Haskell Package Version Tracker
17:54:19 <dons> nomeata's done a good job there
17:55:44 <dons> Igloo: weird, http://www.kroesen.net/
17:55:46 <lambdabot> Title: Haskell - HaskellWiki
17:56:10 <mapreduce> Is foldl1 what mere mortals call reduce?
17:56:27 <mmorrow> yesh
17:57:06 <monochrom> No, not mere mortals.
17:57:31 <newsham> python reduce can also be foldl
17:58:13 <mmorrow> (yesh, without addressing the mortals reference and only speaking for perl's ?::List)
17:58:14 <dolio> Are MutableByteArrays# bigger structures than Addrs#?
17:58:30 <mapreduce> Thanks
17:58:57 <dons> dolio: a little, they store a length prefix.
17:58:58 <newsham> >>> def f(a,b) : return '(%s + %s)' % (a,b)
17:59:00 <newsham> >>> reduce(f, [1,2,3], 0)
17:59:03 <newsham> '(((0 + 1) + 2) + 3)'
17:59:16 <newsham> > foldl (+) z [a,b,c]
17:59:17 <lambdabot>  z + a + b + c
17:59:24 <dolio> Ah. I guess that might explain the different behavior with the transform there.
17:59:51 <dolio> I suppose transforming it might bump the Addr# out of a register or something.
18:00:03 <dolio> Where an array wouldn't be there anyway, or something.
18:00:16 <monochrom> > foldl op z [a,b,c]
18:00:17 <lambdabot>   Not in scope: `op'
18:00:21 <monochrom> > foldl o z [a,b,c]
18:00:22 <lambdabot>  Couldn't match expected type `a -> b -> a'
18:00:27 <monochrom> > foldl o z [a,b,c] :: Expr
18:00:28 <lambdabot>  Couldn't match expected type `a -> b -> a'
18:00:36 <dolio> > foldl f z [a,b,c]
18:00:37 <lambdabot>  f (f (f z a) b) c
18:00:45 <dolio> o isn't a function.
18:00:48 <monochrom> Thanks.
18:00:57 <dolio> Only f, g and h.
18:02:35 <newsham> > f
18:02:36 <lambdabot>  Add a type signature
18:02:41 <newsham> ?type f
18:02:43 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
18:02:56 <newsham> > f :: Int -> Int
18:02:57 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
18:02:57 <lambdabot>     In th...
18:03:15 <newsham> err blah dumb
18:03:33 <mapreduce> :t scanl
18:03:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:04:00 <newsham> > scanl (+) z [a,b,c]
18:04:01 <lambdabot>  [z,z + a,z + a + b,z + a + b + c]
18:04:23 <newsham> scanl == awesome foldl debugger
18:11:06 <roconnor> > catalog
18:11:07 <lambdabot>   Not in scope: `catalog'
18:14:06 <roconnor> > POKE 51,0:CONT
18:14:06 <lambdabot>   parse error on input `,'
18:15:32 <newsham> > poke 'c' nullPtr
18:15:33 <lambdabot>   Not in scope: `nullPtr'
18:21:10 <monochrom> lambdabot is not applesoft
18:22:09 <newsham> http://codepad.org/Q8cgS6x8
18:24:39 <mmorrow> segfault citay!
19:03:01 <CVirus> 4 hours to my exam and I haven't slept yet
19:03:03 <CVirus> fuck it
19:03:43 * monochrom hypnotizes CVirus.
19:04:45 <CVirus> anyone around got a "Concepts of Programming Languages" exam tomorrow at the German University in Cairo ?
19:05:04 <CVirus> brb .. smoke
19:22:23 <dancor> @pl \ x -> f x && g x
19:22:23 <lambdabot> liftM2 (&&) f g
19:23:40 <jganetsk_> does haskell have records?
19:23:51 <Botje> yes
19:23:57 <Botje> however, they are all scratched
19:24:01 <jganetsk_> scratched?
19:24:21 <Botje> monty python joke.
19:24:27 <dancor> is the biggest scratch that the accessors functions scope globally
19:24:37 <dancor> s/accessors/accessor
19:24:39 <nornagon> pretty much
19:24:47 <Botje> man
19:24:49 <mauke> no, it's the lack of functional references
19:24:53 <Botje> this build of firefox3 is _CRASHY_
19:25:27 <dancor> i sometimes find things get a little boilerplatey with updating records
19:25:44 <dancor> like at the bottom of http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
19:25:45 <lambdabot> http://tinyurl.com/y3585u
19:26:08 <jganetsk_> where can i find a good reference for the record syntax?
19:26:14 <mauke> @where report
19:26:15 <lambdabot> http://www.haskell.org/onlinereport/
19:26:30 <dancor> gentle introduction has section too
19:27:08 <dancor> http://www.haskell.org/newtutorial/moretypes.html
19:27:09 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
19:27:16 <dancor> 6.2
19:27:55 <ddarius> http://web.archive.org/web/20061011094943/http://haskell.org/hawiki/UsingRecords
19:27:56 <lambdabot> Title: UsingRecords - The Haskell Wiki, http://tinyurl.com/25vh3y
19:29:12 <sclv> outside of generating frefs (which would hopefully allow access to the name of the field as well) I'm actually increasingly opposed to any further extensions to the record system.
19:29:33 <EvilTerran> while i'd be inclined to gut it completely, TBH
19:29:37 <sclv> I can't see how they'd play well with some of the existing *nice* features of record accessors.
19:30:13 <EvilTerran> i could really go for extensible records. something like that paper describing them in terms of "row types"
19:30:39 <sclv> given an accessor function now, you can determine what type it accesses and what type it generates.
19:31:10 <sclv> with an extensible record system, especially one that hid typeclasses beneath it, I'm not sure how much of that you could get.
19:31:37 <sclv> I'm not even sure if you could get workable frefs with an extensible record system?
19:32:55 <sclv> instead you're getting almost a whole new type language grafted in.
19:33:05 <dolio> I'm not sure what would change besides the types of the frefs.
19:33:45 <dolio> Instead of being wired to a specific record type, they'd be frefs for any extensible record with a particular field name.
19:33:57 <sclv> I dunno. I guess I'd just have to play with an implementation a bit. But the deterministic type information you get from plain accessor functions is actually really useful.
19:35:20 <sclv> I suppose if you got enough new expressive power you could maybe get hlist-style functionality for "free". But there's a bunch of kinks that would have to be worked out first.
19:35:29 <dolio> Although I suppose you have to decide whether an fref setter can add a field to an extensible record that doesn't have that field, or if it can only change the field of a record that already has that it.
19:35:46 <KinkyBlackGoat> I really should make 'kinks' not hilight me in coding rooms, you people use it too often.
19:35:53 * KinkyBlackGoat waddles off to quietland again.
19:36:17 <dancor> /nick md5(self)
19:38:23 <sclv> I guess the litmus test for me would be -- could I use this system to write a simple, typesafe, embedded database dsl in haskell?
19:39:02 <gwern> I dunno about simple, but haven't the haskelldb and related projects sort of done that?
19:39:10 <gwern> there seem to be a number of talking-to-dbs-in-haskell projects
19:39:10 <sclv> if yes, it solves more than it hurts. if no, it hurts more than it solves.
19:39:18 <byorgey> dons: thanks for the link (to the haskell+finance blog post), how did you find that?  I set up a Google Alert thingy searching for 'Haskell' in blogs, but it seems it didn't find that one
19:39:30 <sclv> gwern: yeah, but haskelldb actually rolls its own record-like class.
19:41:26 <dons> byorgey: i'll send you links to the rss feeds i use
19:41:31 <byorgey> dons: cool, thanks
19:41:40 <sclv> byorgey: oh, that guy wrote me a note asking for a tip or two. he's using hstringtemplate :-)
19:41:48 <andyjgill_> Hi dons
19:41:48 <byorgey> sclv: ah, I see =)
19:42:12 <byorgey> maybe I should send out an appeal for links/stories/etc.
19:42:24 <byorgey> probably not a bad idea, just to put it in people's minds
19:45:30 <gwern> so anyway, does anyone here know how to change the user of a running program?
19:45:44 <gwern> as I said on -cafe, there's setUID, but that's useless
19:47:01 <mauke> why is it useless?
19:48:29 <sclv> seteuid?
19:48:48 <sclv> setreuid?
19:49:11 <gwern> mauke: as far as I can tell, it only takes the UID parameter. I know no way of going from the symbolic username "mubot" say, to a UID, and it does not accept a password string
19:49:25 <mauke> getpwnam
19:49:38 <gwern> so you need be either root (have permission to become anyone) or perhaps have the target account set up in some special way to not requite password?
19:49:49 <gwern> neither requirement is palatable for mueval
19:49:49 <mauke> a.k.a. getUserEntryForName
19:50:02 <mauke> er, that's how unix works
19:50:17 <mauke> you can't just change your privileges (unless you're root)
19:50:51 <mauke> the password thing is purely userspace
19:51:03 <mauke> you still need something with root privileges
19:52:22 <RyanT5000> quick straw poll: how many people here would switch jobs to a company that wrote in haskell?
19:52:26 <RyanT5000> (same salary, etc.)
19:52:34 <gwern> userspace or no, I still need something String -> String -> IO (), and I haven't found it
19:53:45 <Draconx> gwern, why don't you write it?
19:53:57 <gwern> RyanT5000: ceterus paribus?
19:54:07 <gwern> Draconx: because that's work and I hate duplicating existing code
19:54:24 <Draconx> gwern, lookup username, verify password, setuid.  Not much to duplicate.
19:54:28 <dons> RyanT5000: yeah!
19:55:01 <sclv> gwern: you can create an account that's got limited permissions, and set the set-uid bit to that?
19:55:16 <cjs_> Duplicating exsting security-related code is always risksy.
19:55:29 <sclv> then it can swap between its limited perms and the perms of the account that runs it using seteuid?
19:55:41 <sclv> and you need no root!
19:55:42 <dancor> duplicating code is always risky
19:55:46 <gwern> sclv: but how do I have permission to setuid to that? as mauke's been saying, the straight setUID approach requires root, AFAIK
19:55:50 <sclv> (except to set up the accounts to begin with anyway?)
19:56:01 <sclv> gwern. not setuid. seteuid.
19:56:04 <cjs> Setuid requires root, yes. But sudo does not.
19:56:11 <Draconx> gwern, depends on what you setuid to.
19:56:12 <gwern> cjs: yeah, I'm especially wary when it comes to security. security is extremely hard
19:56:22 <sclv> seteuid doesn't require root. its much more limited.
19:56:58 <gwern> @hoogle euid
19:56:59 <lambdabot> No matches found
19:57:01 <sclv> http://www.opengroup.org/onlinepubs/009695399/functions/seteuid.html
19:57:03 <lambdabot> Title: seteuid, http://tinyurl.com/69yc9f
19:57:04 <RyanT5000> gwern: yeah
19:57:59 <sclv> gwern: if you're not root, it only lets you swap between the uid of the set-uid bit and the uid of the user that runs it.
19:58:04 <sclv> which is all you really need.
19:58:31 <gwern> so how does one create an account which allows itself to be seteuid'd with?
19:59:34 <gwern> and I guess seteid and setegid are not in the haskell standard libs?
19:59:45 <cjs> Any account can. You swap between the guy that ran the program, and the owner of the suid program.
19:59:53 <dancor> so MonadPlus 'supports choice' just in that mplus might return first or second arg?
20:00:12 <dancor> (though obviously it could return anything it wants also, seems like)
20:01:00 <dolio> Depends on the MonadPlus. [] returns both, in a sense.
20:01:21 <dancor> > mplus [4, 5] [6, 7]
20:01:24 <lambdabot>  [4,5,6,7]
20:02:08 * gwern is confused. I'll come back to this later
20:05:35 <adu> I need an idea
20:05:45 <adu> my mind is blank
20:05:54 <dancor> adu: make yi cool
20:06:05 <adu> dancor: thats a brilliant idea
20:06:09 <dancor> i want to use it but i have high cool standards
20:06:10 <adu> dancor: I'll do it
20:06:12 <dancor> ok
20:06:13 <dancor> nice
20:07:05 <john_argentina_b> hi
20:07:17 <john_argentina_b> who work with haskell???
20:07:19 <mmorrow> RyanT5000: i think you need to reword your question: http://theunixgeek.blogspot.com/2008/06/programming-salaries.html
20:07:19 <lambdabot> Title: The Unix Geek: Programming Salaries
20:07:25 <dons> ?users
20:07:25 <lambdabot> Maximum users seen in #haskell: 471, currently: 412 (87.5%), active: 17 (4.1%)
20:08:27 <dons> john_argentina_b: many of the people in this channel work with haskell every day
20:08:53 <slava> except for dons, he's mostly writing xml these days
20:09:05 <dons> slava: :)
20:09:10 <john_argentina_b> i have curse of haskell
20:09:14 <john_argentina_b> i am from argentina
20:09:26 <adu> john_argentina_b: what?
20:09:42 <dancor> course, maybe?
20:09:42 <john_argentina_b> i am studing computer sciene
20:09:42 <vixey> adu: what kind of idea?
20:09:56 <adu> vixey: and idea of what to work on in Haskell
20:09:59 <vixey> adu: how about eating peas with a knife
20:10:02 <vixey> adu: oh, haskell..
20:10:04 <adu> I want to do something with Haskell
20:10:46 <vixey> adu: Why don't you write an interactive geometry editor?
20:10:46 <adu> so I wrote a Haskell app that puts 2 rectangles on the screen, then i forgot why...
20:10:46 <john_argentina_b> i dont understund the objetive of program with haskell...
20:10:46 <john_argentina_b> jajaj
20:10:46 <dons> adu, more apps please. we've 500+ libraries on hackage.haskell.org, but maybe only 50 apps
20:10:46 <dons> of which perhaps 5 are well known.
20:10:52 <adu> john_argentina_b: the objective is to make it work... obviously!
20:11:07 <vixey> adu, using what library?
20:11:12 <adu> Hopengl
20:11:13 <dons> john_argentina_b: the objective is to make programming easier, faster, simpler, safer.
20:11:16 <vixey> hm
20:11:23 <vixey> I didn't want to use opengl for this
20:11:24 <roconnor> dons: easier?
20:11:36 <john_argentina_b> java? .net?
20:11:40 <dons> yes. goes with "safer"
20:11:43 <john_argentina_b> imperative paradigma
20:11:45 <adu> how about wxYi ?
20:11:54 <john_argentina_b> where are you from?
20:12:32 <vixey> what is a GUI library that works well for mac (and ideally others)?
20:12:35 * ddarius doesn't program using Haskell because he thinks it is harder.
20:12:44 <dons> vixey: gtk2hs
20:12:53 <vixey> ok I will try gtk2hs again
20:13:24 <vixey> how are you supposed to install gtx?
20:13:27 <adu> vixey: ya, mac supports X11 too
20:13:28 <vixey> gtk*
20:13:43 <john_argentina_b> where are you from?
20:13:47 <dons> vixey: download the .tar.gz, build it following the usual instructions
20:13:57 <adu> john_argentina_b: who are you talking to?
20:14:18 <john_argentina_b> all of you
20:14:30 <vixey> I mean the actual gtk library written in C
20:14:34 <adu> thats it, I'm going to build gtkYi / wxYi -- it'll be great
20:14:36 <cjs> There's a page on haskell.org that gives locations, etc.
20:14:39 <vixey> ro C++ or whatever it's made of
20:15:13 <adu> vixey: everything that begins with "g" is written in C, everything that begins with "k" is written in C++
20:15:33 <dolio> dons: Is -ddump-flatC supposed to be the way to get the C generated in -fvia-c? It doesn't seem to be working for me.
20:15:58 <mmorrow> whoa didn't know about -ddump-flatC
20:16:15 <john_argentina_b> f :: int -> int
20:18:59 <adu> Gnome => C
20:19:02 <adu> KDE => C++
20:20:27 <sbahra> A good amount of GNOME applications are C++ too
20:20:40 <sbahra> And "recently", some C#.
20:20:47 <sbahra> And taking into account some others, python.
20:20:52 <Pseudonym> BTW, KDE =/> C++
20:21:11 <Pseudonym> KDE is written in the related language C++-without-exceptions.
20:21:18 <sbahra> heh
20:21:49 <adu> you can do KDE apps in C?
20:22:15 <dolio> Yes. There are C bindings.
20:22:26 <cjb> likewise GTK in C++.
20:23:52 <dancor> @pl \ a b -> g (f a b)
20:23:53 <lambdabot> (g .) . f
20:24:10 <dancor> @pl \ a b c -> g (f a b c)
20:24:10 <lambdabot> ((g .) .) . f
20:24:25 <dancor> i see a pattern
20:24:42 <ddarius> :t (.)
20:24:43 <ddarius> :t (.) . (.)
20:24:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:24:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:24:49 <ddarius> :t (.) . (.) . (.)
20:24:51 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
20:25:05 <dancor> the dots are mind-blowing but powerful
20:25:20 <OceanSpray> what what?
20:25:31 <ddarius> The dots are just function composition.
20:25:37 <dancor> in function monad does (>>=) = (.)
20:25:53 <dancor> @src (>>=) :: (Monad (x ->))
20:25:54 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:26:02 <dancor> @yow
20:26:02 <lambdabot> Couldn't find fortune file
20:26:15 <dancor> i hope that is just a particularly meta yow
20:26:16 <OceanSpray> @src (.)
20:26:16 <lambdabot> (f . g) x = f (g x)
20:26:16 <lambdabot> -- In lambdabot, it's been generalised to:
20:26:16 <lambdabot> (.) = fmap
20:26:39 <dancor> @metayow
20:26:39 <lambdabot> Unknown command, try @list
20:26:43 <OceanSpray> @src fmap
20:26:43 <lambdabot> Source not found. My mind is going. I can feel it.
20:26:50 <OceanSpray> :t fmap
20:26:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:26:57 <OceanSpray> what's a functor?
20:27:16 <dancor> @pl \ c -> f a b c d
20:27:16 <lambdabot> flip (f a b) d
20:27:17 <dobblego> anything that adheres to that signature and follows the laws of identity and composition
20:28:12 <dobblego> OceanSpray, replace f with [] and say "the list functor"
20:28:26 <OceanSpray> oooh
20:28:28 <dobblego> since map :: (a -> b) -> [] a -> [] b
20:28:48 <atp> (we write [] a as [a], of course)
20:28:49 <dobblego> ?type fmap :: (a -> b) -> Maybe a -> Maybe b
20:28:51 <lambdabot> forall a b. (a -> b) -> Maybe a -> Maybe b
20:29:28 <dobblego> does the list functor follow the law of identity?
20:29:32 <atp> OceanSpray: fmap can be thought of as taking a function and a container, and applying that function to the element(s) in the container
20:29:35 <dobblego> @check \x map id x == x -- well?
20:29:36 <lambdabot>  Parse error at "==" (column 13)
20:29:36 <ddarius> :t [] :: [] a
20:29:38 <lambdabot> forall a. [a]
20:29:42 <dobblego> @check \x -> map id x == x -- well?
20:29:43 <lambdabot>   add an instance declaration for (Eq (f a))
20:29:49 <dobblego> @check \x -> map id x == (x :: [Int]) -- well?
20:29:50 <lambdabot>  OK, passed 500 tests.
20:30:23 <atp> so like (*2) `fmap` (Just 4)
20:30:30 <atp> > (*2) `fmap` (Just 4)
20:30:32 <lambdabot>  Just 8
20:31:03 <atp> i personally like to use <$> (which is an infix version of fmap), defined in Control.Applicative
20:31:20 <dancor> where is the source of Monad (x ->) anyway
20:31:32 <atp> Control.Monad.Reader I think
20:32:06 <atp> @src (>>=) :: Reader
20:32:07 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:32:09 <atp> hm
20:32:24 <atp> @instances Monad
20:32:24 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:32:24 <Mr_Awesome> is there a way to iterate through an Array as quickly as you could in, say, C?
20:32:32 <noecksit> atp: is there a difference between the $ in Control.Applicative and the one imported from prelude?
20:32:42 <atp> noecksit: <$>, not $
20:32:47 <atp> noecksit: not the same operator
20:32:49 <dancor> lbot has the source to like only one function
20:33:01 <atp> noecksit: and yes, a big difference... f $ x is the same as f x
20:33:18 <cjs> Mr_Awesome: yes, pretty much. Even faster, for anything complex that you don't want to entirely hand-optimize in C.
20:33:22 <noecksit> allright
20:33:24 <atp> noecksit: but f <$> c x will do something like c (f x)  for some container c
20:33:25 <ddarius> @src Reader (>>=)
20:33:25 <lambdabot> Source not found. My pet ferret can type better than you!
20:33:30 <atp> noecksit: intuitively, anyway
20:33:52 <cjs> Maybe a quick look at dons' wordcount example would be enlightening.
20:34:08 <atp> ddarius: i think it's because it's Reader r
20:34:21 <atp> ddarius: Reader by itself has the wrong kind
20:35:23 <ddarius> atp: That's not the issue.
20:35:33 <atp> ddarius: is it more broken than that?
20:36:04 <ddarius> It's not broken, it just doesn't have that example.
20:36:11 <ddarius> @src -> (>>=)
20:36:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:36:18 <dolio> @src (->) (>>=)
20:36:18 <lambdabot> f >>= k = \ r -> k (f r) r
20:36:24 <dancor> amazing
20:36:40 <atp> hehe
20:36:54 <ddarius> @src (->) fmap
20:36:54 <lambdabot> fmap = (.)
20:40:05 <dancor> @pl \ y -> g (\ x -> f x y)
20:40:05 <lambdabot> g . flip f
20:42:24 <roconnor> @hoogle Reader
20:42:30 <lambdabot> Control.Monad.Reader :: module
20:42:30 <lambdabot> Control.Monad.Reader.Reader :: newtype Reader r a
20:42:30 <lambdabot> Control.Monad.Reader.Reader :: (r -> a) -> Reader r a
20:43:41 <heavensrevenge> hello
20:46:22 <dobblego> hello heavensrevenge
20:46:52 <heavensrevenge> in germany ive got a whole load of video lectures
20:47:04 <heavensrevenge> 26.5 GB from this 1 functioal programming haskell coure
20:48:18 <mar77a> that's a lot of bits
20:48:50 <roconnor> wow, Forth seems almost as much fun as assembly
20:49:00 <heavensrevenge> lol
20:49:02 <vixey> not fun at all?
20:49:20 <heavensrevenge> well, should i put this suckker on bittorrent or something??
20:49:25 <roconnor> assembly is fun is very limited contexts
20:49:29 <ddarius> Assembly is fun.
20:49:31 <heavensrevenge> its 26.5GB massive
20:49:44 <roconnor> bit torrent sounds good
20:49:56 <heavensrevenge> why not make an indirect asm implementation/translator in haskell??
20:50:17 <vixey> @go harpy
20:50:18 <lambdabot> http://en.wikipedia.org/wiki/Harpy
20:50:19 <vixey> like this?
20:50:25 <vixey> if that is even the right thing
20:50:52 <vixey> I don't understand this http://www.gtk.org/download-macos.html
20:50:52 <lambdabot> Title: GTK+ - Download for Mac OS
20:51:06 <vixey> is anyone actually using gtk2hs on mac?
20:51:20 <roconnor> heavensrevenge: I did that already: http://haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
20:51:22 <heavensrevenge> u mean happy?
20:52:31 <heavensrevenge> cool stuff roconnor :)
20:53:54 <roconnor> learning mdo was like learning recursion all over again.
20:55:13 <heavensrevenge> i havent read that monad.reader issue yet, and havent read many actually....
20:55:41 <vixey> dons, do you get gtk like: svn checkout http://svn.gnome.org/svn/gtk+/trunk gtk
20:55:42 <heavensrevenge> seeing how i just started haskell 1-2 weeks ago :)
20:55:54 <vixey> and compile that?
20:56:00 <vixey> before installing gtk2hs
21:10:52 <Mr_Awesome> which would in general be more efficient, IORef (Array i e) or Array i (IORef e) ?
21:12:52 <dolio> IOArray i e
21:13:05 <ddarius> It depends on what you are doing.
21:14:29 <vixey> I think that gtk2hs doesn't work on mac
21:16:31 <cjs> I've had issues with it on a Mac.
21:19:32 <Mr_Awesome> dolio: well, actually im using yampa, so the real question would require a replacement of IORef with (SF input)
21:20:23 <Mr_Awesome> basically, each step im changing every element in the array
21:20:50 <dolio> Every element all at once?
21:21:46 <Mr_Awesome> dolio: i think so. using something like amap, for instance. im not sure exactly how im going to do it since there are so painfully few operators for arrays
21:22:12 <dolio> You could probably go with IORef (Array i e) then.
21:24:22 <Mr_Awesome> another stumbling block ive encountered with Arrays is that there neither seems to be an iteration with indices *and* elements nor a way to iterate through two arrays at once (without translating them into lists)
21:25:10 <vixey> @hoogle Arrays
21:25:10 <lambdabot> No matches found
21:25:11 <vixey> @hoogle Array
21:25:12 <lambdabot> Foreign.Marshal.Array :: module
21:25:12 <lambdabot> Data.Array :: module
21:25:12 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
21:25:48 <rwbarton> @hoogle assocs
21:25:49 <lambdabot> Data.Map.assocs :: Map k a -> [(k, a)]
21:25:49 <lambdabot> Data.IntMap.assocs :: IntMap a -> [(Key, a)]
21:25:49 <lambdabot> Data.Array.IArray.assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
21:26:31 <Mr_Awesome> rwbarton: doesnt translating into a list defeat the purpose of having an array?
21:26:57 <vixey> what is the purpose of an Array?
21:27:16 <roconnor> fast random access?
21:27:47 <Mr_Awesome> fast update
21:28:19 <cjs> There must be more to it than that. You can extremely quickly update a list just by consing something on to the front of it.
21:28:23 <ddarius> Mr_Awesome: http://citeseer.ist.psu.edu/534505.html
21:28:24 <lambdabot> Title: An Approach to Fast Arrays in Haskell - Chakravarty, Keller (ResearchIndex)
21:29:39 <Mr_Awesome> cjs: i have a heightmap, a grid with a few hundred points, which all need to be integrated twice and then updated
21:31:18 <rwbarton> Oh, I thought that was what you wanted for "iteration with indices and elements"
21:32:19 <vixey> no I think fromList is a prefectly fine way to create an array
21:32:29 <vixey> you know exactly what element of the list corresponds to which index
21:32:39 <vixey> and you also have the original array to lookup
21:32:46 <vixey> so it's not really a map
21:32:57 <vixey> You are just creating a new array based on some input
21:33:20 <vixey> & this way you don't have to convert the original to a list
21:33:47 <vixey> or fromList is the wrong name, but the idea's the same
21:37:40 <ddarius> Going through lists seriously slows down the array libraries.
21:45:06 <adu> I can't compile Yi
21:45:21 <adu> Setup.hs:34:12: Not in scope: `compilerPath'
21:45:23 <adu> Setup.hs:54:14: Not in scope: `rawSystemVerbose'
21:47:01 <sjanssen> adu: you've probably got the wrong version of Cabal
21:47:24 <adu> proly
21:48:50 <sjanssen> IIRC, it requires the darcs version
21:54:45 <adu> how do I find out which version I have?
21:57:16 <adu> aha i have lib/ghc-6.8.2/lib/Cabal-1.2.3.0/libHSCabal-1.2.3.0.a
21:57:24 <rwbarton> ghc-pkg list maybe
21:57:31 <adu> perhaps I should try 1.4.0.0
21:58:13 <adu> o wow! i didn't know ghc-pkg existed!
21:58:27 <adu> thanks
21:58:31 <rwbarton> You now know everything I know about it :)
21:58:38 <adu> :)
21:59:00 <newsham> angels dance upwards
22:00:12 <adu> wow, you can also do "ghc-pkg field Cabal version"
22:00:28 <adu> that is really nice
22:01:14 <Mr_Awesome> nihilism eschews wobbly sacrilegious hamsters and monkeys
22:02:28 <Snark> hi
22:02:38 <Snark> I have a slight problem with "Programming with arrows"
22:03:05 <Snark> the following doesn't work :
22:03:07 <Snark> count w = readFile >>>
22:03:07 <Snark>           arr words >>> arr (filter (== w)) >>> arr length >>>
22:03:07 <Snark>           print
22:03:20 <Snark> which is pretty annoying for a first example of using arrows :-/
22:03:52 <vixey> >>> makes a pyoww sound
22:04:08 <adu> Mr_Awesome: It is sagacious to eshew obfuscation.
22:05:03 <Mr_Awesome> Snark: define "doesn't work"
22:05:55 <Snark> type mismatch is "doesn't work"
22:06:19 <Snark> Expected type: IO String -> c Inferred type: String -> [String]  In the first argument of `arr', namely `words'
22:06:20 <newsham> ?type readFile
22:06:48 <newsham> ?bot
22:07:03 <lambdabot> FilePath -> IO String
22:07:03 <lambdabot> :)
22:07:31 <adu> vixey: lol
22:14:47 <adu> ?check 2==(1+1)
22:14:48 <lambdabot>  OK, passed 500 tests.
22:15:29 <sjanssen> @scheck 2==(1+1)
22:15:32 <lambdabot>   Completed 1 test(s) without failure.
22:15:38 <sjanssen> scheck is smarter :)
22:15:45 <newsham> > flip runKleisli "test" $ Kleisli readFile >>> arr words >>> arr (filter (== "test")) >>> arr length >>> arr print
22:15:45 <adu> ic
22:15:46 <lambdabot>  <IO (IO ())>
22:15:57 <vixey> > ((==)`on`show) (1+1) (2)
22:15:59 <lambdabot>  True
22:16:05 <newsham> > flip runKleisli "test" $ Kleisli readFile >>> arr words >>> arr (filter (== "test")) >>> arr length >>> Kleisli print
22:16:06 <lambdabot>  <IO ()>
22:17:20 <adu> @scheck n==((n+1)-1)
22:17:21 <lambdabot>   Failed test no. 1. Test values follow.:
22:17:49 <adu> @scheck \n->n==((n+1)-1)
22:17:51 <lambdabot>   Completed 13 test(s) without failure.
22:20:12 <Snark> newsham, I don't exactly get what the flipping is about
22:20:51 <newsham> runKleisli :: arrow -> (a -> m b).
22:21:00 <newsham> I want to give it "a" before the arrow
22:21:12 <newsham> ie provide the filename "test" for the "readFile"
22:21:43 <newsham> > runKleisli (Kleisli readFile >>> arr words >>> arr (filter (== "test")) >>> arr length >>> Kleisli print) "test"
22:21:44 <lambdabot>  <IO ()>
22:21:47 <newsham> flip is not necessary
22:26:31 <newsham> > readFile "test" >>= return.words >>= return.(filter (== "test")) >>= return.length >>= print
22:26:32 <lambdabot>  <IO ()>
22:26:59 <dolio> > (print <=< (return . length . filter (== "test") . words) <=< readFile) "test"
22:27:00 <lambdabot>  <IO ()>
22:27:38 <newsham> > readFile "test" >>= return.length.(filter (== "test")).words >>= print
22:27:39 <lambdabot>  <IO ()>
22:27:55 <dolio> > print <=< return . length . filter (== "test") . words <=< readFile
22:27:56 <lambdabot>  <[Char] -> IO ()>
22:28:23 <vixey> hehe http://d.hatena.ne.jp/yoshihiro503/20070720
22:28:27 <lambdabot> Title:  - 
22:28:40 <sjanssen> > print =<< length <$> filter (== "test") <$> words <$> readFile "test"
22:28:41 <lambdabot>  <IO ()>
22:29:04 <newsham> sj wins
22:29:10 <newsham> go applicative
22:29:10 <vixey> lambdabot: you should try UTF-8 sometime.. you might even like it
22:29:23 <sjanssen> newsham: just Functor with some new sugar
22:30:06 <shachaf> sjanssen: Weren't you against (<$>) a while ago?
22:30:07 <Mr_Awesome> :t (<$>)
22:30:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:30:11 <dolio> Oh, wait, what am I doing?
22:30:13 <Mr_Awesome> :t fmap
22:30:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:30:19 <lambdabot> vixey: no thank you
22:30:28 <dolio> > print . length . filter (== "test) . words <=< readFile
22:30:28 <lambdabot> Unbalanced parentheses
22:30:36 <dolio> > print . length . filter (== "test") . words <=< readFile
22:30:37 <lambdabot>  <[Char] -> IO ()>
22:30:44 <sjanssen> shachaf: yeah, I typically prefer fmap
22:30:53 <sjanssen> I'd actually write that as:
22:31:04 <shachaf> (Is (.) still fmap here? :-) )
22:31:13 <Snark> uh...
22:31:18 <sjanssen> > print . length . filter (== "test") . words =<< readFile "asdf"
22:31:19 <lambdabot>  <IO ()>
22:31:38 <sjanssen> shachaf: yes, #haskell is still bizarro-Cale-land
22:32:00 <vixey> hpaste wont load for me :[
22:32:32 <shachaf> What's bizarro about it?
22:32:46 <roconnor> @type (.)
22:32:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:33:01 <Cale> @type (Prelude..)
22:33:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:33:32 <Mr_Awesome> but why?
22:34:10 <roconnor> it's caleskell
22:34:21 <vixey> it's perfectly normal haskell
22:34:49 <roconnor> Haskell the way Cale wants it rather than how it is.
22:35:02 <newsham> when using established notation, do no introduce suprises
22:35:14 <roconnor> It is used to confused people, among other uses.
22:35:26 <vixey> anyone who's written code should be fine with it, we define hundreds of totally new functions in a program
22:35:45 <dolio> I think more complaining about potential confusion goes on than actual confusion.
22:36:01 <vixey> changing the definition of a few things (in a backwards compatable way as well) should not be confusing to anyone
22:36:01 <shachaf> dolio: That might be because nobody actually uses it. :-)
22:36:11 <Mr_Awesome> > (+ 1) . Just 2
22:36:14 <lambdabot>  Just 3
22:36:19 <Mr_Awesome> haha
22:36:23 * shachaf is for (.) = map = fmap, though.
22:36:36 <vixey> I quite like the idea of getting rid of fmap
22:36:44 <Mr_Awesome> im with vixey
22:36:47 <vixey> yay
22:37:09 <Mr_Awesome> i think most people are
22:38:21 <newsham> > (\f -> [f-3, 2*f]) . [10,20,30]
22:38:23 <lambdabot>  [[7,20],[17,40],[27,60]]
22:38:31 <shachaf> @ty map
22:38:33 <newsham> totally what people expect
22:38:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:38:36 <shachaf> @src (.)
22:38:36 <lambdabot> (f . g) x = f (g x)
22:38:36 <lambdabot> -- In lambdabot, it's been generalised to:
22:38:36 <lambdabot> (.) = fmap
22:38:38 <shachaf> @src map
22:38:38 <lambdabot> map _ []     = []
22:38:39 <lambdabot> map f (x:xs) = f x : map f xs
22:38:53 <shachaf> map's @src should get a comment too.
22:39:41 <sjanssen> shachaf: if (.) = map = fmap, should we even keep map around?
22:39:55 <shachaf> sjanssen: You mean fmap.
22:40:04 <shachaf> map is a good name.
22:40:11 <sjanssen> no, I mean map
22:40:24 <roconnor> > id . fail
22:40:25 <lambdabot>  Add a type signature
22:40:27 <sjanssen> but fmap could go too
22:40:28 <newsham> perhaps we can come up with more names?
22:40:33 <dolio> Why would you get rid of map and keep fmap?
22:40:34 <newsham> how about <*>?
22:40:35 <roconnor> > id Prelude.. fail
22:40:36 <lambdabot>   Not in scope: `Prelude..'
22:40:45 <vixey> map is a good name
22:40:50 <roconnor> > (Prelude..) id fail
22:40:50 <vixey> fmap I don't like..
22:40:50 <lambdabot>   Not in scope: `Prelude..'
22:40:52 <shachaf> Why? It should be class Functor f where map :: (a -> b) -> f a -> f b
22:40:57 <sjanssen> > id P.. fail
22:40:58 <lambdabot>  Add a type signature
22:41:22 <roconnor> > map id fail
22:41:23 <lambdabot>  Add a type signature
22:41:25 <newsham> > (\f -> [f-3, 2*f]) <$> [10,20,30]
22:41:26 <lambdabot>  [[7,20],[17,40],[27,60]]
22:41:31 <newsham> > (\f -> [f-3, 2*f]) `map` [10,20,30]
22:41:32 <lambdabot>  [[7,20],[17,40],[27,60]]
22:41:34 <newsham> > (\f -> [f-3, 2*f]) `fmap` [10,20,30]
22:41:35 <lambdabot>  [[7,20],[17,40],[27,60]]
22:41:40 <newsham> > (\f -> [f-3, 2*f]) . [10,20,30]
22:41:41 <lambdabot>  [[7,20],[17,40],[27,60]]
22:42:06 <roconnor> > id . (fail "x")
22:42:07 <lambdabot>   add an instance declaration for (Show (f a))
22:42:13 <roconnor> > id P.. (fail "x")
22:42:14 <lambdabot>  Add a type signature
22:42:22 <roconnor> > id `map` (fail "x")
22:42:23 <lambdabot>   add an instance declaration for (Show (f a))
22:42:40 <roconnor> ?
22:42:49 <roconnor> @type map
22:42:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:42:57 <roconnor> > id `L.map` (fail "x")
22:42:58 <lambdabot>   add an instance declaration for (Show (f a))
22:43:15 <roconnor> fuck caleskell
22:43:19 <shachaf> > fail "x" -- fmap id == id anyway
22:43:19 <lambdabot>   add an instance declaration for (Show (m a))
22:43:30 <dolio> L is the name of the lambdabot module.
22:43:38 <dolio> Since before Cale took it over.
22:43:43 <sjanssen> roconnor: P.map
22:43:51 <roconnor> oh right prelude
22:43:56 <roconnor> > id `P.map` (fail "x")
22:43:57 <lambdabot>  []
22:43:58 <sjanssen> import qualified Prelude as P
22:44:25 <roconnor> all those are different
22:44:44 <roconnor> using caleskell means writing out more type sigs
22:44:53 <roconnor> or using qualified names
22:45:14 <shachaf> roconnor: Where do you ever use map id (fail "x")?
22:45:24 <roconnor> all over the place. :)
22:45:25 <shachaf> I'd guess that it would just get inferred later on anyway.
22:45:34 <sjanssen> roconnor: to be fair, your example only compiles with GHC's -fextended-default-rules hack
22:45:57 <roconnor> sjanssen: even map id (fail "x") ?
22:46:09 <dolio> shachaf: When contriving an example to prove some point, of course.
22:46:16 <sjanssen> roconnor: to be more specific, show (map id (fail "x"))
22:46:40 <roconnor> sjanssen: works fine for me in GHCi
22:46:57 <sjanssen> roconnor: -fextended-default-rules was invented for ghci :)
22:47:00 <roconnor> oh
22:47:05 <roconnor> damn polymorphism
22:47:28 <roconnor> > map (+1) (fail "caleskell")
22:47:29 <lambdabot>   add an instance declaration for (Show (f a))
22:48:06 <shachaf> roconnor: Your example doesn't work.
22:48:12 <shachaf> Because Cale would also get rid of fail. :-)
22:48:23 <roconnor> > map (+1) mzero
22:48:24 <lambdabot>   add an instance declaration for (Show (f a))
22:48:28 <roconnor> there
22:48:33 <shachaf> That's better.
22:48:40 <roconnor> something similar to that might reasonably come up in #haskell
22:49:02 <shachaf> I want "map (+1) mzero" to work for any MonadZero.
22:49:06 <shachaf> Is that unreasonable?
22:49:37 <roconnor> shachaf: use fmap or <$>
22:49:58 <shachaf> roconnor: Why? "map" doesn't imply [] anywhere.
22:50:12 <sclv> ?ty map
22:50:13 <shachaf> If you *specifically* want a list map, then use an appropriate function.
22:50:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:50:22 <sclv> ?ty P.map
22:50:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:50:28 <roconnor> shachaf: like what?
22:50:29 <sclv> there we are
22:50:31 <roconnor> map!
22:50:40 <vixey> (.) doesn't imply []
22:50:43 <shachaf> Data.List.map, or mapList, or something.
22:50:43 <vixey> that's for sure
22:51:02 <shachaf> vixey: (.) isn't a word, so it implies less.
22:51:20 <roconnor> > Data.List.map (+1) mzero
22:51:21 <lambdabot>   Not in scope: `Data.List.map'
22:51:21 <sjanssen> I can live with map = fmap, but (.) = fmap is another story
22:51:24 <shachaf> But the little circle generally is only used for function-like things.
22:51:30 <roconnor> > mapList (+1) mzero
22:51:30 <lambdabot>   Not in scope: `mapList'
22:51:38 <shachaf> @let mapList = P.map
22:51:39 <lambdabot> Defined.
22:51:40 <roconnor> shachaf: didn't work
22:51:50 <shachaf> Sure, this isn't the full Caleskell.
22:52:03 <sjanssen> does mapList deserve a name?
22:52:14 <roconnor> if Cales wants Caleskell it should be on #caleskell.
22:52:46 <vixey> and hackage too :)
22:53:09 <shachaf> sjanssen: Other maps get names, why not mapList?
22:53:18 <shachaf> Either names or places in qualified modules, anyway.
22:53:25 <roconnor> and there should be a caleskell 2008 doc
22:53:34 <sjanssen> shachaf: which maps have names?
22:54:05 <roconnor> there is mapMap .. nope it's called map  there is mapSet ... nope called map
22:54:11 <roconnor> ...
22:54:25 <sjanssen> shachaf: huh, I guess there are a few -- mapMaybe for example
22:54:41 <roconnor> @src mapMaybe
22:54:41 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:54:47 <sjanssen> oh, but mapMaybe isn't fmap with the Maybe Functor
22:54:49 <roconnor> @hoogle mapMaybe
22:54:49 <lambdabot> Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
22:54:49 <lambdabot> Data.Map.mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
22:54:49 <lambdabot> Data.IntMap.mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
22:54:58 <smg> hellol
22:55:53 <sjanssen> mapMaybe f = concatMap (maybe [] return . f)
22:56:00 <shachaf> Either names or implementations in qualified modules.
22:57:35 <adu> wierd
22:57:48 <telexicon> what would cause this error when trying to build a cabal package? Setup.hs: Crypto.cabal:51: 'Executable' stanza starting with field 'executable symmetrictest main-is'
22:57:57 <adu> when i run "ghc-pkg field Cabal version" now, it gives both 1.2.3.0 and 1.4.0.0
22:58:06 <adu> is it supposed to do that?
22:59:16 <shachaf> @ty let fmapDefault = Data.Traversable.fmapDefault; amap = Data.Array.IArray.amap; mapP = GHC.PArr.mapP in second`fmap`(fmapDefault(liftA>>>liftM).amap(mapP<$>map))
22:59:18 <lambdabot> forall d (f :: * -> *) (m :: * -> *) a b (f1 :: * -> *) (a1 :: * -> * -> *) i. (Functor f1, Monad m, Applicative f, Arrow a1, Data.Traversable.Traversable (a1 i), Ix i, Data.Array.Base.IArray a1 ([:
22:59:18 <lambdabot> f1 a:] -> [:f1 b:]), Data.Array.Base.IArray a1 (a -> b)) => a1 i (a -> b) -> a1 (d, i) (d, m (f [:f1 a:]) -> m (f [:f1 b:]))
22:59:41 <shachaf> (Not all of those names are fmaps, though.)
23:04:02 <telexicon> wow, everyone seems to have disappeared in a hurry
23:05:08 <sjanssen> telexicon: your Cabal is too old
23:05:25 <sjanssen> adu: yep, Haskell libraries are slotted
23:05:40 <telexicon> sjanssen, the libraries on my distro?
23:05:43 <sjanssen> telexicon: where too old means < 1.2
23:06:01 <sjanssen> telexicon: right
23:06:25 <telexicon> k, ill try it on my laptop
23:07:28 <telexicon> thanks
23:14:20 <roconnor> @free foldr
23:14:22 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
23:14:42 <roconnor> @free unfoldr
23:14:44 <lambdabot> $map_Maybe ($map_Pair g f) . h = k . f => $map g . unfoldr h = unfoldr k . f
23:15:27 <roconnor> @free mapAccumL
23:15:28 <lambdabot> (forall x. $map_Pair f h . k x = p (f x) . g) => $map_Pair f ($map h) . mapAccumL k y = mapAccumL p (f y) . $map g
23:16:33 <roconnor> @free length
23:16:34 <lambdabot> length = length . $map f
23:17:14 <roconnor> @free words
23:17:16 <lambdabot> $map $id . words = words
23:17:25 <roconnor> \o/
23:17:30 <vixey> that's a dumb theorem
23:17:48 <newsham> you get what you pay for
23:18:47 <roconnor> @free and
23:18:49 <lambdabot> and = and . $map $id
23:19:08 <Pseudonym> :t words
23:19:09 <lambdabot> String -> [String]
23:19:18 <Pseudonym> Interesting.  But you make a good point.
23:19:23 <Pseudonym> $map $id should be $id
23:19:36 <Pseudonym> Or, indeed, $map_Pair $id $id
23:19:54 <Pseudonym> ?free True
23:19:54 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
23:19:59 <Pseudonym> ?free chr
23:20:01 <lambdabot> chr = chr
23:20:05 <Pseudonym> That
23:20:12 <Pseudonym> 's what a degenerate theorem should look like.
23:20:47 <sclv> @let foo f x = unwords . f. words $ x
23:20:48 <lambdabot> Defined.
23:20:48 <roconnor> @free asTypeOf
23:20:50 <lambdabot> f . asTypeOf x = asTypeOf (f x) . f
23:20:51 <sclv> ?ty foo
23:20:53 <lambdabot> ([String] -> [String]) -> String -> String
23:20:56 <sclv> ?free foo
23:20:58 <lambdabot> $map $id . f = g . $map $id => foo f = foo g
23:21:30 <sclv> see? that's reasonable.
23:21:39 <Pseudonym> Well, no.
23:21:44 <Pseudonym> f = g => foo f = foo g
23:21:48 <Pseudonym> Which means foo = foo
23:22:26 <roconnor> @free either
23:22:28 <lambdabot> g . k = p . f => g . q = f1 . h => g . either k q = either p f1 . $map_Either f h
23:22:28 <Pseudonym> The problem here is that ?free doesn't know that fmap id = id.
23:22:47 <roconnor> map_Either?
23:22:51 <sclv> hmm
23:23:00 <roconnor> oh
23:23:02 <roconnor> two arguements
23:23:03 <Pseudonym> $map_Either is... well, Either is a bifunctor.
23:23:05 <Pseudonym> Right.
23:23:31 <roconnor> @free could be a little more descriptive
23:23:31 <lambdabot> Extra stuff at end of line
23:23:40 <roconnor> @free catch
23:23:41 <lambdabot> $map_IO f . catch x = catch ($map_IO f x) . (.) ($map_IO f)
23:24:14 <roconnor> @src IO map
23:24:15 <lambdabot> Source not found. My pet ferret can type better than you!
23:24:23 <roconnor> @src IO fmap
23:24:23 <lambdabot> fmap f x = x >>= (return . f)
23:25:29 <roconnor> @src Cont callCC
23:25:29 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
23:26:12 <roconnor> @free on
23:26:14 <lambdabot> (forall x. g . k x = p (f x) . f) => f . q = f1 . h => g . on k q y = on p f1 (h y) . h
23:26:56 <newsham> ?free (.) (.)
23:26:56 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
23:27:10 <Pseudonym> :t (.) (.)
23:27:11 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
23:27:21 <roconnor> so far @free sortBy has been the only intresting theorem.
23:27:28 <Pseudonym> ?free foo :: F (a -> b) -> F (G a -> G b)
23:27:28 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map_F h x = y) => (forall f1 f2. $map_G g . f1 = f2 . $map_G f
23:27:28 <lambdabot> =>                q f1 = f2) => $map_F q (foo x) = foo y
23:28:01 <Pseudonym> The version of ?free that _isn't_ in lambdabot has discovered a very interesting theorem.
23:28:25 <roconnor> Pseudonym: oh?
23:28:30 <Pseudonym> Consider:
23:28:35 <Pseudonym> idA :: a ~> a
23:28:42 <Pseudonym> This has a free theorem:
23:28:46 <newsham> is ?free well published?
23:28:47 <Pseudonym> idA >>> arr f = arr f >>> idA
23:28:54 <Pseudonym> However.
23:29:07 <Pseudonym> This is just to justify that arrows have free theorems.
23:29:15 <Pseudonym> The interesting theorem that it came up with is:
23:29:23 <Pseudonym> If p >>> arr f = arr g >>> q,
23:29:24 <Pseudonym> then first p >>> arr (f >< h) = arr (g >< h) >>> first q.
23:29:31 <Pseudonym> That's the free theorem for first.
23:29:37 <Pseudonym> Using >< to mean $map_Pair.
23:29:59 <Pseudonym> The reason why this is interesting is that two of the arrow laws are consequences of that free theorem.
23:30:00 <roconnor> hmm
23:30:10 <Pseudonym>     f >>> arr id = arr id >>> f
23:30:11 <Pseudonym> = (free theorem for first)
23:30:11 <Pseudonym>     first f >>> arr (id >< g) = arr (id >< g) >>> first f
23:30:19 <Pseudonym> Which is the exchange law.
23:30:25 <Pseudonym> For example.
23:30:27 <roconnor> so we don't have to prove those arrow laws?
23:30:32 <Pseudonym> Not in parametric models.
23:30:43 <roconnor> that's nice to know.
23:30:46 <Pseudonym> And Phil Wadler proved another one of them.
23:30:53 <Pseudonym> p >>> arr id = p
23:30:58 <Pseudonym> That's a theorem.
23:31:13 <Pseudonym> Oh, the other one that's a theorem is the extension law.
23:31:13 <roconnor> a free one?
23:31:18 <Pseudonym> No.
23:31:24 <roconnor> an expensive one.
23:31:33 <Pseudonym> Well, not quite.
23:31:40 <Pseudonym> p >>> arr id = p is true even in non-parametric models.
23:31:48 <Pseudonym> In that it's a consequence of the other laws.
23:31:53 <roconnor> oh right
23:31:55 <roconnor> I read that
23:31:58 <Pseudonym> It doesn't require any free theorems to prove it.
23:32:07 <roconnor> cheaper than free
23:32:13 <Pseudonym> Yeah.
23:32:24 <Pseudonym> All you have to do is read a Phil Wadler paper. What's freer than that?
23:33:22 <Pseudonym> So theoretically, the right unit law is a stronger result.
23:33:25 <roconnor> @free foo :: ((((a -> b) -> a) -> a) -> b) -> b
23:33:25 <lambdabot> (forall p q. (forall f1 f2. (forall f3 f4. g . f3 = f4 . f                                           =>                                            f (f1 f3) = f2 f4)                            =>
23:33:25 <lambdabot>                          f (p f1) = q f2)             =>              g (h p) = k q) => g (foo h) = foo k
23:33:36 <Pseudonym> But practically, the other two laws reduce the burden as much.
23:35:39 <adu> how do I get Cabal 1.5.1?
23:37:04 <Saizan> adu: darcs get http://darcs.haskell.org/cabal , it's the developement version though
23:37:14 <lambdabot> Title: Index of /cabal
23:37:16 <adu> ok
23:37:21 <adu> hope thats >1.5.1
23:37:36 <Pseudonym> In fact, the theorem for sortBy isn't that interesting either in a sense.
23:37:55 <Pseudonym> It's just the free theorem for sort in higher-order form.
23:38:08 <Pseudonym> (Which ?free can't handle, since it doesn't understand typeclasses.)
23:38:13 <Pseudonym> The free theorem for sort is:
23:38:22 <Pseudonym> If f is an Ord-homomorphism, then map f commutes with sort.
23:38:40 <adu> Saizan: thanks
23:39:39 <Pseudonym> i.e. if compare (f x) (f y) = compare x y, then map f . sort = sort . map f
23:43:24 <Beelsebob> I fail te see why equality says anything about monotonicity
23:43:47 <Beelsebob> oh hang on
23:43:57 <Beelsebob> you're saynig if f is an Ord-homomorphism
23:44:02 <Beelsebob> fail
23:44:08 <httpdss> recursion question: i have a recursive function with its base case and and the recursive case. it receives a tuple (a,b) if a == b then True (base case) no the recursive case, i want to control the values new values for (a,b) tuple, and for example, if a == 10 then stop that recursion branch and continue with other branches
23:44:17 <Pseudonym> Right.
23:44:33 <httpdss> can that be possible ??
23:45:11 <httpdss> now*
23:45:23 <Beelsebob> httpdss: hmm rec_f (a,b) | a == b = baseCase (a,b) | a == 10 = do something magical | otherwise = recursiveCase
23:45:25 <Beelsebob> ?
23:45:27 <Beelsebob> that?
23:46:16 <adu> hmm i had to edit fingertree
23:46:22 <Beelsebob> incidentally...
23:46:23 <Beelsebob> recursive question: if I have a recursive function then recursive question, and otherwise I'm not writing Haskell.
23:46:23 <Snark> grrmm...
23:46:45 <Snark> I don't get how I can wrap several states :-/
23:47:08 <httpdss> Beelsebob, mmm .. yeah but i dont know how to handle the "do something magical" ...
23:47:13 <vixey> @remember Beelsebob recursive question: if I have a recursive function then recursive question, and otherwise I'm not writing Haskell.
23:47:13 <lambdabot> Good to know.
23:47:22 <Beelsebob> okay, so what's the magical thing you need to do httpds?
23:47:27 <TSC> httpdss: It seems like you might want to return a list of solutions
23:47:40 <TSC> In which case, the a==10 branch is just []
23:48:00 <TSC> Which means "no solutions lie in this subtree"
23:48:38 <TSC> And if you construct the list lazily (naturally!), it only searches as far as necessary to produce the solutions you want
23:49:44 <httpdss> Beelsebob, the magical thing needs to go cutting of solutions so it doesnt go to infinity ...
23:51:04 <httpdss> TSC, hmm interesting approach let me see how can i put that into my problem ...
23:52:13 <telexicon> i have a package installed, its in my ghc's package.conf but when i try to use a module in the package ghc cant find it, do i have to specify something when building my app with ghc?
23:52:46 <TSC> Try "-package xxx"
23:53:10 <telexicon> it still doesnt find it, im using ghc --make
23:53:45 <TSC> And "ghc-pkg list xxx" finds it?
23:53:54 <telexicon> yes
23:55:15 <httpdss> TSC, i have a base case which returns True if condition a ==b is met ... but no condition of returning False is the base case is never met :S would this be automatically controlled somehow ?
