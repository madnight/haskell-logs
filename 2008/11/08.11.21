00:00:25 <twb> Ruby is just a crap port of some CL ideas to a Python clone
00:00:36 <twb> I say: if you want CL, just use CL'
00:00:49 <SubStack> too many parens
00:00:52 <twb> At least CL is compiled and has (admittedly, optional) static typing
00:01:19 <twb> SubStack: anyone paying attentions to the parens isn't a Lisper
00:01:20 <pstickne> twb:  Ruby borrows more from ST than CL.
00:01:30 <twb> pstickne: I suppose that's a fair call
00:01:39 <sjanssen> pstickne: ST?
00:01:45 <pstickne> SmallTalk(-80)
00:01:45 <twb> s/CL/ST/ in the above, then ;-)
00:01:50 <sjanssen> ah
00:02:30 <twb> I guess I've never understood why Ruby needed to be a whole new language, rather than libraries and extensions for an existing language
00:02:47 <pstickne> twb:  well, not a Python clone ;-), but it does just borrow a bunch of previous features, makes some things easier, and butchers others -- I don't think I'd ever consider it 'cutting edge'
00:03:08 <twb> pstickne: oh sure, I'd never call it "cutting edge"; rather a pastiche or rehash
00:04:11 <twb> Yeah, "pastiche" is exactly the right term for Ruby
00:04:20 <SubStack> ?wn pastiche
00:04:20 <lambdabot> *** "pastiche" wn "WordNet (r) 2.0"
00:04:20 <lambdabot> pastiche
00:04:20 <lambdabot>      n 1: a musical composition consisting of a series of songs or
00:04:20 <lambdabot>           other musical pieces from various sources [syn: {medley},
00:04:20 <lambdabot>            {potpourri}]
00:04:22 <lambdabot>      2: a work of art that imitates the style of some previous work
00:04:32 <twb> "In this usage, a work is called pastiche if it is cobbled together in imitation of several original works."
00:04:34 <twb> http://en.wikipedia.org/wiki/Pastiche
00:04:36 <lambdabot> Title: Pastiche - Wikipedia, the free encyclopedia
00:04:53 <SubStack> in the perl tradition
00:05:02 <twb> More so than Perll
00:05:07 <twb> Perl was just Awk
00:05:18 <mlesniak> with a worse syntax ;)
00:05:43 <twb> Well, since I can't fix this haddock stuff, I'm goin' home
00:06:57 <dons> why is cobbling a frowned upon technique?
00:07:15 <dons> while composition is respected :)
00:07:18 <twb> dons: it implies a bad job
00:07:27 <twb> dons: as opposed to "synthesis"
00:07:32 <dons> like cobblers for shoes? or cobble stones?
00:08:15 <twb> "cobbling" implies cannibalizing other systems for parts, then putting those parts together in a way that might work, but is abhorrent -- e.g. Frankenstein's monster.
00:08:26 <twb> At least, that's *my* view
00:08:39 <pumpkin> is it normal for many of the things I attempt to install via cabal to fail?
00:08:47 <dons> "Etymology: Middle English coblen, perhaps back-formation from cobelere cobbler
00:08:47 <dons> Date: 15th century
00:08:48 <dons> 1chiefly British : to mend or patch coarsely"
00:08:57 <pumpkin> I can understand ones with native dependencies that I don't have installed
00:09:09 <dons> pumpkin: no, it is not normal.
00:09:17 <pumpkin> hrm
00:09:21 <dons> are you using cabal-install?
00:09:23 <pumpkin> yup
00:09:29 <dons> what is failing and why?
00:09:37 <dons> you should get fairly clear error messages
00:10:44 <pumpkin> for example, I try cabal install reify, and it gives me a load of stuff and eventually complains about a missing symbol to the linker: http://pastie.org/320423
00:10:45 <lambdabot> Title: #320423 - Pastie
00:11:04 <pumpkin> I guess it's just using deprecated APIs?
00:11:16 <pumpkin> or flags actually
00:12:44 <dons> well, it's all fine up to the linker error
00:12:46 <dons> warnigns are ok
00:12:58 <dons> 282   "_reifyC", referenced from:
00:12:58 <dons> 283       _s1Ju_info in ReifyHs.o
00:13:02 <pumpkin> yeah
00:13:08 <dons> that is bad though
00:13:13 <dons> let's try.
00:13:28 <dons> Linking dist/build/reify/reify ...
00:13:28 <dons> dist/build/reify/reify-tmp/ReifyHs.o: In function `s1Je_info':
00:13:28 <dons> (.text+0x1ab1): undefined reference to `reifyC'
00:13:28 <dons> collect2: ld returned 1 exit status
00:13:36 <dons> so report that to the author please
00:13:51 <dons> note that hackage doesn't have a quality control mechanism, other than looking at the build reports.
00:13:53 <pumpkin> is there a centralized way to do that, or do I just send an email?
00:14:02 <dons> atm, you send an email
00:14:33 <sjanssen> tested-with:         GHC==6.5
00:14:35 <sjanssen> old
00:14:41 <pumpkin> ah
00:14:57 <pumpkin> does that mean the author probably stopped caring?
00:15:03 <pumpkin> or should I remind him anyway?
00:15:29 <pumpkin> I also have issues like http://pastie.org/320424
00:15:30 <lambdabot> Title: #320424 - Pastie
00:15:33 <sjanssen> it looks like someone other than the author uploaded it
00:15:55 <vegai> has anyone made polls recently about the spread of Haskell around the globe?
00:16:58 <sjanssen> pumpkin: I think the package was not properly cabalized
00:16:59 <pumpkin> is there a notion of a maintainer in hackage? I only just started using it
00:17:04 <pumpkin> ah
00:17:14 <pumpkin> sjanssen: you mean for the reify or the halex?
00:17:16 <dons> ancient
00:17:25 <sjanssen> pumpkin: reify
00:17:26 <mlesniak> vegai, or some measurement of the size of the scientific community around haskell?
00:17:43 <sjanssen> this is why I think uploading random code found on the internet to hackage is of dubious utility...
00:17:43 <dons> vegai: or distribution of IP addresses in hackage downloads?
00:17:47 <vegai> mlesniak: I'm more interested in use outside the scientific community
00:17:58 <vegai> dons: oh, that would be nice
00:18:01 <dons> sjanssen: i think it'll be swamped by real uploads soon enough
00:18:02 <vegai> dons: you have that information?
00:18:17 <dons> vegai: no, but it would be possible to obtain. i don't think it should be public though
00:18:21 <pumpkin> dons: you still think it's worthwhile notifying the author if it's likely he didn't put it there in the first place?
00:18:22 <dons> it would have to be anonymized.
00:18:28 <dons> pumpkin: probably not, no.
00:18:30 <vegai> sure
00:18:32 <dons> you could attempt to fix the error
00:18:39 <dons> who's the author?
00:18:40 <sjanssen> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reify did reify ever actually build for you?
00:18:40 <lambdabot> Title: HackageDB: reify-0.1
00:18:41 <dons> lemmih?
00:18:48 <pumpkin> dons: bernie pope?
00:18:50 <dons> oh, bernie.
00:18:58 <dons> so no, he's not doing haskell anymore afai, and his code is really old
00:19:02 <pumpkin> ah :)
00:19:05 <dons> Build failure ghc-6.10 (log), ghc-6.8 (log)
00:19:16 <dons> is a clue that it won't work. as is the difference between uploader and author
00:19:35 <pumpkin> dons: I actually just went over the big list of hackage packages and grabbed ones that looked interesting (and had several failures)
00:19:36 <sjanssen> pumpkin: the HaLeX error looks like a GHC 6.10 compatibility issue
00:19:41 <pumpkin> ah ok
00:19:42 <Lemmih> dons: Not all the broken packages are mine.
00:19:53 <dons> Lemmih: oh, i thought you wrote a reification tool :)
00:20:00 <dons> i didn't mean to imply your packages are borken :)
00:20:05 <pumpkin> sjanssen: they added a permutations function to List and Halex assumed it wasn't there or something?
00:20:27 <sjanssen> pumpkin: right, Data.List.permutations clashes with a function that halex has defined
00:20:36 <pumpkin> I see, I see
00:20:37 <Lemmih> dons: I kid (:
00:20:37 <pumpkin> hmm
00:20:41 <dons> hehe
00:20:46 <sjanssen> pumpkin: the easy fix is "import Data.List hiding (permutations)"
00:21:13 <sjanssen> pumpkin: or you could constrain it to base < 4
00:21:16 <pumpkin> ok, I'll try that
00:21:29 <pumpkin> it looks like a simple enough fix even for inexperienced me
00:21:38 <pumpkin> I also had some other weird cabalish issues
00:21:49 <pumpkin> if anyone hasn't already died of boredom with my problems
00:22:24 <sjanssen> how do other package repositories deal with the compatibility problem?
00:22:32 <dons> you could just install everything that builds
00:22:38 <dons> cabal install $(cat /my/complete/list)
00:23:04 <pumpkin> dons: nah, lots of stuff there that I definitely don't need :P
00:23:10 <dons> hehe
00:23:18 <dons> well, if its just what you /need/
00:23:26 <pumpkin> but I had some problems that seemed more package related than code related
00:23:38 <pumpkin> dons: I only "need" the prelude, I guess :P
00:23:43 <dons> a good 85% or so build   (and e..g there are Arch packages)
00:23:50 <sjanssen> @seen conal
00:23:50 <lambdabot> I saw conal leaving #haskell and #ghc 45m 40s ago, and .
00:24:09 * sjanssen wonders what he did to deserve credit for http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unamb
00:24:09 <lambdabot> Title: HackageDB: unamb-0.1.2
00:24:46 <pumpkin> anyone tried the language-c package? it complained about me not having happy or alex, but didn't even try to resolve the dependency and just fetch them (I did it myself manually, but I was wondering why it hadn't tried)
00:25:57 <dons> it is well written and commercially used
00:26:09 <dons> cabal doesn't track tool dependencies like alex or happy
00:26:14 <dons> there's an open bug for it
00:26:32 <pumpkin> the language-c is commercially used?
00:26:34 <dons> yes
00:26:36 <pumpkin> it looked pretty neat
00:26:42 <dons> it is quite good
00:27:06 <dons> doing some static analysis work?
00:27:59 <pumpkin> I actually do a fair amount of reverse engineering, and loading up pre-existing headers can facilitate stuff a lot
00:28:10 <pumpkin> as a form of knowledge about the binary
00:28:26 <pumpkin> it could be done with ctags but there's more info in there
00:28:34 <dons> interesting
00:28:58 <dons> i think haskell would be a good choice for building reverse engineering tools that work at a semantic level
00:29:31 <pumpkin> yeah, I've been doing a lot of work in ruby so far, but I then fell in love with haskell and have been too busy playing with it (when not doing real work)
00:30:11 <dons> ?userrs
00:30:11 <lambdabot> Maximum users seen in #haskell: 566, currently: 513 (90.6%), active: 13 (2.5%)
00:30:17 <dons> we reached a new all time high today, btw
00:30:28 <pumpkin> after the kirindave blog post? :P
00:30:37 <dons> i'm hopefully we'll enter freenode's top 10 by end of year. a few more copis of RWH
00:30:39 <olsner> sweet, more failure at avoiding success
00:30:50 <dons> we're ahead of #c for the first time
00:31:06 <dons> i imagine once a few people get rwh and read them over vacation breaks, january might be busy
00:31:09 <pumpkin> only a couple dozen below ##c++
00:31:29 <pumpkin> is @pl pointfree on hackage?
00:31:39 <dons> and, more importantly, people are writing 2+ new libs a day on average
00:31:48 <dons> 253 users have uploaded 2581 versions of 885 packages.
00:32:08 <dons> i wonder if we'll reach the 1000th haskell package before the end of the year
00:32:24 <dons> 115 packages to go, 40 days. so would be just about doable...
00:32:44 * sjanssen tries to think of a funny package to upload as #1000
00:32:54 <dons> exciting times
00:33:11 <dons> one of the first packages was the nop package
00:33:16 <sjanssen> if only hnop hadn't been written, that would make a fantastic 1000th package
00:33:23 <dons> yeah
00:33:33 <olsner> maybe haltingproblem? :P
00:33:33 <dons> Tue Sep  5 23:37:35 UTC 2006 IanLynagh iconv 0.2
00:33:38 <dons> first package, interesting
00:33:41 <pumpkin> are there guidelines on how to write a good binding to a native library? I'd really like to be able to call TAO and PETSc from haskell but neither have any libraries in haskell
00:33:46 <olsner> "Solves some instances of the halting problem."
00:34:02 <pumpkin> microsoft's doing research into that supposedly
00:34:07 <dons> pumpkin: read the RWH FFI chapter
00:34:07 <pumpkin> although I haven't actually looked for any of it
00:34:46 <mlesniak> How many pages does the pdf version of rwh have?
00:34:52 <dons> the hackage upload trend has a trend http://galois.com/~dons/images/hackage-daily-graph.png
00:34:57 <dons> mlesniak: 710
00:36:00 <mlesniak> dons, thanks. another question you might be able to answer: if I order the copy from o'reilly, how much delay would be for shipping? (background: amazon.de would send it on the next day but I'm interested in obtaining both the pdf and paper version)
00:36:29 <mlesniak> (uhh, my english is getting worse over time ..)
00:36:54 <dons> mlesniak: i'm not sure about shipping
00:37:04 <mlesniak> dons, ok,
00:39:14 <dons> the pdf (and other 'ebook' versions) are available now, of course.
00:39:48 <dons> so give copies to your ruby friends and make the world a better place in 2009 :)
00:40:04 <mlesniak> :-D
00:40:36 <Twey> What's the nicest way to split a list on the last instance of an element?
00:40:53 <dons> reverse it ?
00:41:18 <dons> bytestring has some 'find from end' functions, but only because its complexity is the same in either direction
00:41:26 <Kvasir> > (break 8) . reverse [0..10]
00:41:26 <lambdabot>   Couldn't match expected type `a -> [a1]'
00:41:27 <pumpkin> dons: the ffi chapter in rwh is very nice, thanks
00:41:35 <Kvasir> > (break 8) . reverse $ [0..10]
00:41:36 <lambdabot>       No instance for (Num (a -> Bool))
00:41:36 <lambdabot>        arising from the literal `8' a...
00:41:42 <Kvasir> :O
00:41:50 <Twey> I was doing reverse . takeWhile (/= el)
00:42:09 <Twey> But if there's no instance of el, I'd like it to return empty
00:42:40 <dons> pumpkin: you're obligated to buy a copy now ;) (well, o'reilly wants to see a justification for open sourcing the book, so if it actually does sell well, they'll likely do more open ones)
00:42:46 <Kvasir> > break 8 [0..10]
00:42:47 <lambdabot>       No instance for (Num (a -> Bool))
00:42:47 <lambdabot>        arising from the literal `8' a...
00:42:55 <pumpkin> dons: I was planning to :)
00:43:00 <Kvasir> uhm, how was it?
00:43:20 <dons> :t break
00:43:20 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:43:22 <dons> :t splitAt
00:43:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
00:43:38 <arw_> > break (== 8) [0..10]
00:43:39 <lambdabot>   ([0,1,2,3,4,5,6,7],[8,9,10])
00:43:59 <Twey> Aha
00:44:06 <Twey> Thanks :)
00:44:44 <dons> sjanssen: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/darcs-2.1.2.2
00:44:46 <lambdabot> Title: HackageDB: darcs-2.1.2.2, http://tinyurl.com/6j2b7u
00:44:57 <arw_> all those functions take a predicate, that is a function that returns a bool if there is a match.
00:45:27 <Kvasir> i'm pretty sure there was a function like break that accepted the element
00:45:44 <Kvasir> > (break (==8)) . reverse $ [0..10]
00:45:45 <lambdabot>   ([10,9],[8,7,6,5,4,3,2,1,0])
00:46:48 <arw_> you can always do a breakEq x l = break (== x) l
00:46:57 <Kvasir> Twey, something like that?
00:47:52 <Twey> Kvasir: Close, but:
00:48:00 <Twey> > break (== 11) [0..10]
00:48:02 <lambdabot>   ([0,1,2,3,4,5,6,7,8,9,10],[])
00:48:22 <Kvasir> arw_, i was reading http://book.realworldhaskell.org/read/functional-programming.html yesterday, but it seems there's no such function
00:48:23 <lambdabot> Title: Chapter 4. Functional programming
00:48:34 <Twey> Which means that if I reverse it, I get the whole thing back, instead of an empty list
00:49:07 <Twey> arw_: breakEq = break . (==)
00:49:08 <Twey> :)
00:49:25 <Kvasir> what do you want to obtain from that?
00:49:26 <Twey> I think that reads more nicely
00:49:45 <arw_> Twey: point-free is always nicer, yes :)
00:49:51 <Twey> Not always
00:50:08 <arw_> na, always. obscure is also a form of nice :)
00:50:31 <Twey> Kvasir: foo "bar|baz|quux" ===> "quux"; foo "bar" ===> ""
00:50:33 <dolio> @pl \e h l o -> h e l l o
00:50:33 <lambdabot> flip flip id . (ap .) . flip id
00:50:39 <arw_> bbl
00:50:47 <Twey> arw_: Haha, maybe :-P
00:51:22 <Twey> flip flip id?
00:51:24 <Twey> Woah
00:51:32 <dolio> @type flip flip
00:51:32 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
00:51:59 <Twey> That's a little mind-boggling
00:52:56 <Twey> a `id` b meaning function application still throws me for a small loop
00:53:32 <RayNbow> Twey: `id` has a different precedence and fixity than $
00:55:02 <pumpkin> dons: why does the FFI example in the book choose to take a ByteString rather than just a string? wouldn't it be even nicer to call if you didn't have to pack your expression before passing it in?
00:55:10 <pumpkin> (for compile)
00:55:33 <Trinithis> > null `id` []
00:55:34 <lambdabot>   True
00:55:40 <dmwit> Without looking at the context, let me just point out that ByteStrings are generally used for efficiency, not convenience.
00:55:49 <Twey> RayNbow: I know, I know
00:55:59 <dmwit> :t flip flip id
00:56:00 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
00:56:22 <pumpkin> hmm
00:56:28 <Trinithis> I thought you could only do `foo` on operators that are at least binary
00:56:31 <dmwit> > flip flip id (\x y -> 3) x
00:56:33 <lambdabot>   3
00:56:53 <dmwit> Trinithis: id is binary
00:57:01 <dmwit> :t id :: (a -> b) -> (a -> b)
00:57:01 <Trinithis> :t id
00:57:03 <lambdabot> forall a. a -> a
00:57:03 <lambdabot> forall a b. (a -> b) -> a -> b
00:57:39 <Trinithis> huh
00:57:41 <dmwit> id is n-ary, for all n =)
00:58:06 <RayNbow> @djinn (a -> b -> c) -> a -> b -> c
00:58:06 <lambdabot> f a = a
00:58:13 <RayNbow> ^ proof for 3-ary :p
00:58:25 <Trinithis> I get it
01:05:12 <pumpkin> omg voodoo http://hpaste.org/7116
01:08:03 <sam__> Do anybody know a good video tutorial for DrScheme?
01:08:26 <pumpkin> "The TVar parameterized type is a mutable variable that we can read or write inside an atomically block." whoa, /mutable/???
01:08:29 * pumpkin faints
01:09:51 <pumpkin> :t readTVar
01:09:52 <lambdabot> Not in scope: `readTVar'
01:10:02 <pumpkin> hmm
01:10:22 <pumpkin> :m + Control.Concurrent.STM
01:10:29 <pumpkin> :(
01:10:50 <idnar> @type Control.Concurrent.STM.readTVar
01:10:51 <lambdabot> forall a. GHC.Conc.TVar a -> GHC.Conc.STM a
01:11:07 <hackage> Uploaded to hackage: haskeline 0.4
01:11:09 <pumpkin> ah, so it's not really "mutable"
01:11:12 <pumpkin> right?
01:11:55 <dolio> What do you mean?
01:13:18 <pumpkin> well, I was just surprised to see it called a mutable variable when I thought such things weren't allowed in haskell
01:13:35 <pumpkin> but it's just passing state along in the usual way through a monad, right?
01:13:45 <Trinithis> yes
01:13:51 <Trinithis> just like io
01:15:58 <dolio> IO and STM and such don't really pass along the state, though.
01:16:41 <pumpkin> oh
01:16:49 <pumpkin> but we're supposed to believe that's how it's working, right?
01:16:50 <pumpkin> :P
01:16:54 <dolio> They enforce sequencing, and do real mutable updates (or IO and ST do. STM is for concurrency).
01:16:54 <jeffz> pumpkin: see also, Data.IORef and Control.Concurrent.MVar
01:16:58 <Trinithis> I thought in theory, one could view IO as a state monad. What is it then?
01:17:23 <pumpkin> the things I've been reading have said that, where the state of the IO is "the world"
01:17:49 <pumpkin> I feel very powerful every time I print a string knowing I've captured the universe in those two letters
01:17:57 <dolio> You can view it as a state monad, but the state isn't just some value like State. It's The Real World.
01:18:35 <dolio> And implementationally, it's just a token to ensure that things happen in the right order.
01:18:46 <Trinithis> But we CAN fit the real world on out computers!
01:20:40 <mapreduce> The real world is somewhere between the water cooler and the printer.
01:28:37 <quicksilver> is there anything beyond the water cooler?
01:32:29 <earthy> an arie? at this time of the morning?
01:36:51 <yaxu> anyone know the fastest way of getting a hardcopy of realworldhaskell in the uk?  direct from o'reilly or amazon or?
01:53:19 <rog_> can anyone tell me what the "~" in this error message means?     Could not deduce (PType (PAppl t (a -> b))) from the context ((t, a) ~ (t1, a1), PType a1, PType b, PType t1)
01:53:50 <thoughtpolice> it means type equality
01:54:17 <thoughtpolice> so (t, a) ~ (t1, a1) = t == t1 && a == a1
01:54:37 <rog_> thoughtpolice: ok, thanks.
01:54:53 <mapreduce> Where is there a good definition of kinds?
01:56:24 <quicksilver> thoughtpolice: well, t ~ t1 && a ~ a1 ;P
01:56:36 <quicksilver> you can think of it as 'unifies with'
01:56:38 <thoughtpolice> :p
01:56:51 <quicksilver> mapreduce: Right here.
01:56:58 <quicksilver> kinds are sets of types
01:57:15 <mapreduce> Yes, I was just hoping to point someone at it.
01:57:27 <thoughtpolice> omg win: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-November/016112.html
01:57:28 <lambdabot> Title: ghci-haskeline (was: Re: ANNOUNCE: GHC version 6.10.1 - EditLine / terminal inco ..., http://tinyurl.com/68n9o5
01:57:49 * thoughtpolice has already built and changed the symlink of ghci -> ghci-haskeline
01:58:00 <hugo__> :)
01:58:08 <hugo__> just wanted to say that i love you guys
02:08:45 * mlesniak sings "Love is in the air..."
02:09:21 <yaxu> how nice
02:09:41 <Stephan202> :D
02:11:06 <mapreduce> I thought it was exhaust fumes.
02:11:07 <hackage> Uploaded to hackage: hmeap 0.6
02:26:17 * yaxu returns to haskell after about a year away
02:26:37 <yaxu> seems to be like riding a bike
02:27:05 <yaxu> I can still hack it but my old code has rotted
02:27:29 * yaxu stretches a metaphor
02:28:58 <Twey> I think that's rather more mixing than stretching :-P
02:31:26 <mapreduce> It is definitely like riding a bike.  I keep falling off.
02:32:15 * Twey grins.
02:34:34 <Twey> Heh
02:34:42 <Twey> « Useful Idioms that will blow your mind (unless you already know them :) »
02:34:52 <Twey> 'cale wuz here'
02:36:42 <Twey> Ooh, here's a nice one
02:37:01 <yaxu> i've got a language, you can hack it if you like it's got a monad, a compiler that infers and lots of parser combinator libraries that make it look good
02:37:06 <Twey>   foldr (\a ~(x,y) -> (a:y,x)) ([],[])
02:37:24 <EvilTerran> > foldr (\a ~(x,y) -> (a:y,x)) ([],[]) [0..]
02:37:25 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
02:37:26 <Twey> Who was using something like that before?
02:37:28 <yaxu> (syd barrett RIP)
02:37:30 <luqui> @pl \c f g -
02:37:31 <lambdabot> (line 1, column 8):
02:37:31 <lambdabot> unexpected end of input
02:37:31 <lambdabot> expecting "->"
02:37:43 <luqui> @pl \c f g -> \x y -> f x `c` g y
02:37:44 <lambdabot> ((flip . ((.) .)) .) . (.)
02:37:53 * EvilTerran knew that one, honest <.<  >.>
02:38:37 <Twey> Heheh
02:39:16 <quicksilver> @pl \f c g -> \x y -> f x `c` g y
02:39:16 <lambdabot> ((flip . ((.) .)) .) . flip (.)
02:39:41 <Twey> Hmm
02:39:53 <Twey> I'm not entirely sure I get that
02:40:34 <luqui> @pl \f x -> f x x x x x x x x x x x
02:40:34 <Twey> If we have foldr (\a ~(x, y) -> ...) ([], []) then isn't the first `a` going to be ([], [])?
02:40:36 <lambdabot> join . join . join . join . join . join . join . join . join . join
02:40:43 <luqui> oh, of course :-)
02:41:03 <Twey> Heh
02:41:35 <Twey> Oh, it's foldr, so the second argument is the initial?
02:42:07 <Twey> > foldr (\a b -> b) 1 [2]
02:42:09 <lambdabot>   1
02:42:14 <Twey> I see
02:42:20 <Twey> Odd, but right-ho
02:43:03 <Twey> Aw, foldr.com and foldl.com are down
02:43:51 <luqui> @pl (\x -> f (x x)) (\x -> f (x x))
02:44:25 <luqui> uhhhh...
02:44:26 <luqui> @bot
02:44:28 <quicksilver> @botsnack
02:44:38 <quicksilver> cool. luqui tied a knot in lambdabot's head.
02:44:51 <Twey> @pl \(Foo x) -> x
02:44:58 <Twey> Hahaha
02:45:03 <Twey> Seems so
02:45:13 <hugo__> wow, the ap monad function is really REALLY great :D
02:45:27 <hugo__> i found out about it now :) in a monad tutorial somewhere...
02:45:30 <luqui> hugo__, sure.  it's just <*>
02:45:47 <hugo__> yes, but it also lifts
02:45:47 <Twey> (well, should be)
02:45:53 <luqui> hugo__, i.e. Applicative is a typeclass with "return' and "ap"
02:46:12 <hugo__> i dont understand the type sintax and semantic :/
02:46:15 <luqui> which is weaker than monad (and easier to optimize in many cases)
02:46:19 <lambdabot> Plugin `pl' failed with: thread killed
02:46:20 <lambdabot> :)
02:46:20 <lambdabot> :)
02:46:29 <hugo__> oh nice :)
02:46:29 <hugo__> yes
02:46:34 <Twey> Hehe
02:46:36 <Twey> @pl \(Foo x) -> x
02:46:53 <Twey> ... uh.
02:47:21 <Twey> @botsnack
02:47:39 <Twey> Right... \b needs some fixing?
02:47:50 <quicksilver> Cale: ping
02:48:06 <RayNbow> > uncurry zip . foldr (\a ~(x,y) -> (a:y,x)) ([],[])  $  [0..]
02:51:35 <EvilTerran> , uncurry zip . foldr (\a ~(x,y) -> (a:y,x)) ([],[])  $  [0..]
02:51:42 <lunabot>  [(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(2...
03:09:31 <Fox-2> hey
03:11:30 <Fox-2> i want to intercept some keyboard input like LeftArrow with a haskell function. How can i do this?
03:12:54 <Fox-2> http://hpaste.org/12241
03:13:39 <BeelsebobWork> Fox-2: you can, but it's nicer to use `isPrefixOf`
03:14:23 <Fox-2> BeelsebobWork: can you give me an example function?
03:15:35 <sheyll> hi
03:15:43 <BeelsebobWork> Fox-2: http://hpaste.org/12241#a1
03:15:49 <sheyll> I cannot compile ghc 6.10.1 in ubuntu 8.10
03:15:52 <BeelsebobWork> oh wait -- I fail at reading your question
03:16:01 <sheyll> has anyone experienced similar problems
03:16:02 <sheyll> ?
03:16:07 <BeelsebobWork> you should be able to intercept the left and right arrow control characters, yes
03:16:26 <Fox-2> And how?
03:16:29 <dcoutts> sheyll: we'd need more details
03:16:38 <sheyll> ok...
03:16:59 <Peaker> Fox-2: you're writing a tokenizer, or a keyboard input handler?
03:17:18 <Peaker> Fox-2: if you want control over keyboard input, you don't typically input a string
03:19:01 <Fox-2> I have to write a compiler for MGPL, its like GPL, but without some features of GPL. There we´ve to compile PONG and SpaceInvaders, where Keyboard input is needed
03:19:25 <Peaker> GPL?
03:19:25 <sheyll> I cannot paste to hpaste.org; the first thing that goes wrong is: configure: error: editline not found, so this package cannot be built
03:19:34 <Fox-2> GamingProgrammingLanguage
03:19:59 <Peaker> Fox-2: which library are you using to access user input and to draw/etc?
03:20:20 <sheyll> but building continues until it bails out with: Warning: in export list of "GHC.Base": module not found: "GHC.Bool" (and others)
03:20:48 <sheyll> and later on things like: Warning: ghc-6.10.1:InstEnv: could not find link destinations for: ...
03:21:14 <sheyll> these are warnings, no errors right?
03:22:00 <Peaker> sheyll: you can download the ghc-6.10.1 binaries
03:22:15 <sheyll> I need to build ghc for rhel4
03:22:52 <Peaker> sheyll: you can try to apt-get install libeditline-dev libedit-dev
03:23:01 <sheyll> so I downloaded ghc 6.10 to my ubuntu and tryd to follow the directions given here: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
03:23:05 <Fox-2> Peaker: I dont know what you mean, I am new to haskell
03:23:28 <Peaker> Fox-2: are you using console input/output, X, SDL, or what?
03:23:30 <EvilTerran> Fox-2, what you're attempting sounds rather complex for a beginner
03:23:55 <rog_> still struggling on using dynamic types. i wanted to add some automatic marshalling to and from my type representation, and this (http://hpaste.org/12242#a0) is the result. unfortunately, i can't seem to find a scheme for making functions work. there are two (failed) attempts at the end of that paste. any ideas?
03:24:03 <Fox-2> say this my professor ;)
03:24:07 <Fox-2> +to
03:24:14 <sheyll> anyway: make install seems to work, but make hc-file-bundle Project=ghc fails
03:24:41 <sheyll> and editline is only for ghci(andalso optional), correct?
03:25:40 <Peaker> Fox-2: what kind of interaction with the user will your game thing have?
03:26:05 <rog_> currently, i can do unPV (mkPV ([5 :: Double, 6, 7], 7 :: Int)) :: ([Double], Int) and it works
03:26:36 <Fox-2> Peaker: http://hpaste.org/12243#a0 I have to scan and parse something like this.
03:27:35 <rog_> ... but i'd like to be able to do: (mkPV $ (+) :@ (5 :: Double) :~ 6) and be able to unmarshal it. the solution eludes me!
03:28:19 <Peaker> Fox-2: OK, what platform do you want it to run on?
03:29:24 <rog_> (i'm wondering if there's some reason that it's not actually possible)
03:29:43 <Fox-2> Peaker: Windows
03:30:15 <Peaker> Fox-2: you have any idea of how you're going to get user input or draw stuff?
03:30:23 <sheyll> what is the fastest way to get a more or less recent ghc on rhel4?
03:30:38 <Fox-2> Peaker: No thats actually my problem
03:31:04 <lispy> rog_: unmarshall?
03:31:18 <Peaker> Fox-2: you could use SDL
03:31:31 <lispy> rog_: are you even using the FFI?
03:31:40 <rog_> lispy: go back from the existential representation to the originally typed representation
03:31:45 <rog_> lispy: no
03:32:34 <lispy> rog_: I've not used Data.Typeable (though I know of it), but you realize the insane-ness of converting back after converting to existentials right?  That the type is lost in the conversion to existential?
03:33:03 <rog_> lispy: no, not if you use Typeable.cast
03:33:51 <lispy> rog_: only if you saved the type class information with the existential
03:34:44 <lispy> hmm...actually even then
03:34:52 <lispy> I dunno, it's weird :)
03:35:02 <rog_> lispy: if the type you're putting in is Typeable, and you know exactly what you're getting out, then there should be no problem
03:36:42 <rog_> lispy: the point of all this is that i can do some generic manipulation in a type-agnostic fashion when everything is in its existential form, and then get it back out again afterwards
03:37:22 <Fox-2> Peaker: sounds good, i downloaded it, how can i use it now
03:37:37 <lispy> rog_: but the type 'a' is agnostic already :)
03:38:20 <Peaker> Fox-2: http://hpaste.org/12244 contains a couple of utility modules I wrote around SDL
03:38:42 <rog_> lispy: yeah, i guess i mean in partially-agnostic fashion. i.e. the structure of the type matters, but we don't care too much about the contents.
03:38:51 <Peaker> Fox-2: http://hpaste.org/12245 has a jumping text example
03:38:55 <Peaker> Fox-2: that uses these
03:39:01 <quicksilver> I think you might be using existentials when you could just use conventional polymorphism, rog.
03:39:15 <quicksilver> (by making the type a parameter instead of making it unknown)
03:39:37 <rog_> quicksilver: i wish
03:40:02 <lispy> ?src take
03:40:11 <lispy> stupid lambdabot
03:40:32 <rog_> quicksilver: i've been thinking about this for weeks now, and i haven't come up with a decent way of doing it that way (or any other way)
03:40:43 <lispy> rog_: I don't understand what would fail to work if you used a type parameter
03:41:12 <rog_> lispy: there are many types involved. we're operating on a heterogeneous structure.
03:41:28 <Fox-2> Peaker: where i´ve to copy the source files?
03:41:50 <lispy> rog_: are you doing HOAS?
03:42:01 <rog_> lispy: i can easily define the bahaviour for a single type, but when you've got a record of such types, it's not so easy
03:42:07 <rog_> lispy: HOAS?
03:42:14 <lispy> nevermind :)
03:42:41 <Peaker> Fox-2: If you're not yet up-to-speed about how modules work and how to build a Haskell program, why are you trying to write a compiler? :)
03:42:58 <Peaker> Fox-2: start with the basics, learn how to build modules, go through a tutorial?
03:43:50 <lispy> rog_: I suspect you've put your type class constraints and your existentials in the wrong place by putting them into PValue directly
03:43:53 <rog_> lispy: google isn't very helpful on HOAS... i've seen in talked about on haskell-cafe. Higher-Order-Analytical-Stucture ? :-)
03:44:01 <rog_> s/in/it
03:44:03 <Fox-2> Peaker: Cause i´ve to made it for my credit points ;)
03:44:29 <lispy> rog_: I forgot the difinition.  But your code reminds me of something I saw in a paper yesterday about HOAS
03:44:47 <Peaker> Fox-2: I think you should go through a Haskell tutorial first..
03:45:32 <Fox-2> Peaker: Do you know where i find an good tutorial?
03:46:06 <Peaker> Fox-2: www.learnyouahaskell.com
03:46:28 <Fox-2> Peaker: Thanks
03:46:37 <rog_> lispy: i can't see how to put them anywhere else. by doing that, i can have a list of (to haskell) uniform type that is actually manipulated to change type underneath, although to haskell it's still the same type...
03:46:56 <lispy> rog_: hmm..maybe I'm wrong about the existentials being in side PValue...I guess with it the way it is and derving Typeable we should still it expect it to use the instance for 'a'
03:47:21 <ski_> "My reasoning was simple, by writing a Haskell compiler in Haskell I will double my language learning speed since I will not only have to learn how to program in it by forcing myself to complete a non-trivial project, but also its subtle semantics and dark corners since I actually needed to implement it correctly."
03:47:47 <Twey> "Also, I am a masochist.'
03:47:54 <ski_> "Writing a compiler is also doubly efficient to begin with, since if you self-compile improvements not only give you a better optimizer, but also speed up your self-compiled compiler."
03:48:08 <quicksilver> johnmeacham++ # he's the man.
03:48:29 <ski_> "All in all I figure I was making very good use of my time. For some reason, when I explain my reasoning to other people they look at me like I am crazy, but I can detect no flaw in my logic."
03:48:31 <Twey> Doesn't that make it *infinitely* faster?  :-P
03:48:51 <rog_> oh i see, Higher Order Abstract Syntax
03:48:54 <Twey> Faster compiler -> faster code -> faster compiler -> ...
03:49:00 <lispy> rog_: oh right, yeah that's it
03:50:17 <lispy> rog_: I'll find the paper it reminds me of
03:51:08 <lispy> rog_: http://www.reddit.com/r/programming/comments/6toia/a_typepreserving_compiler_in_haskell_dependent/
03:53:46 <mapreduce> ski_: Perhaps there is a danger of preserving screwups between versions accidentally.
03:54:14 <rog_> lispy: ta. i think the proper solution is probably to use template haskell. perhaps something that allows some kind of map over a record type, generating a new record type. but the documentation for TH seems quite scattered.
03:54:18 <Twey> Hahaha
03:55:20 <ski_> mapreduce : in the sense of "trusing trust" ?
03:55:28 <lispy> rog_: I doubt that will work
03:55:30 <lispy> :)
03:55:34 <rog_> lispy: no?
03:55:49 <lispy> rog_: rewriting PValue to use GADT syntax will probably help
03:55:59 <rog_> lispy: i tried that.
03:56:15 <mapreduce> ski_: That'd be a paper on the subject?
03:57:17 <rog_> lispy: the problem is that i need to be able to get access to the internal structure of the GADT. but, as far as i can see, most GADTs lose the types that went into making them.
03:57:23 <quicksilver> rog_: if you have any inclination to post a reasonable description of your problem to the -cafe, I'll take the time to think about a serious answer.
03:57:32 <lispy> rog_: you could then make a visible in the type of PValue, I believe, then separate the existential aspect from PValue when you want to store them in a collection, or use an HList, etc.
03:57:42 <quicksilver> rog_: the problem is when I normally talk to you I'm at work. And this problem is not a newbie question I can answer in 5 minutes ;)
03:57:44 <lispy> rog_: wha?
03:58:03 <rog_> quicksilver: i understand
03:58:27 <quicksilver> FWIW, I believe that making the type a parameter of PValue is the right direction.
03:58:41 <rog_> quicksilver: the problem is i'm not sure of the best level to phrase the problem at.
03:58:43 <quicksilver> as lispy says you can always patch in some existential at a higher level.
03:59:06 <quicksilver> rog_: the ideal way would be code which almost works. An example using 3 PValues at three different types, say
03:59:19 <quicksilver> and what you need to be able to express about them but can't.
04:00:00 <ski_> mapreduce : Ken Thompson <http://64.233.183.132/search?q=cache:LBdX1cmGcjcJ:cm.bell-labs.com/who/ken/trust.html+reflections+on+trusing+trust&hl=en&ct=clnk&cd=2> (the direct link appers down atm)
04:00:13 <Fox-2> Cya
04:00:15 <ski_> "Reflections on Trusting Trust"
04:00:32 <mapreduce> ski_: Yeah, I've read it, but forgot the title.
04:00:46 <ski_> ok
04:01:05 <Peaker> is there a cofunctor defined anywhere for (Flip (->) r) ?
04:01:05 <ski_> so, yea or nay ?
04:01:16 <thoughtpolice> that's such a good read
04:01:42 <ski_> argh ..
04:01:51 <ski_> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Contra.html
04:03:45 <ski_> (on short browsing, i see no such instance there)
04:05:40 <ski_> (just to make clear .. there are *co*-variant functors and *contra*-variant functors .. `Functor' in haskell is of the former kind)
04:11:02 <shapr> I keep forgetting that.
04:11:07 <hackage> Uploaded to hackage: hsc3-process 0.0.0
04:14:12 <ski_> @yarr
04:22:09 <Raevel_> http://www.gnuvola.org/software/j/gnugo/gnugo.el
04:22:15 <Raevel_> oops, wrong channel
04:22:22 <quicksilver> bens__:
04:22:25 <quicksilver> gah
04:22:25 <quicksilver> sorry
04:22:43 <askentask> anyone know of a good beginner tutorial for implementing typesystems? guess there is no easy such thing. but basically as my projexcts grow in python and other dynamic languages i start to wish I had static typing. and not java-like one, if thats the price i have to pay i prefer dynamic typing. but haskell-like. would it be hard to implement static typing in Scheme? could you run some typechecking program independent of the lisp-compile
04:22:50 <quicksilver> BeelsebobWork: InfixApplicative : So that when you code Arkanoid in Reactive, your combinators look like mini Arkanoid bats ;)
04:23:40 <quicksilver> askentask: I'm not aware of a tutorial. SPJ wrote some good stuff about the implementation of GHC. Otherwise there is TAPL (the book).
04:25:41 <askentask> tapl = ?
04:26:01 <mapreduce> @go TAPL
04:26:18 <mapreduce> Types and Programming Languages, by Benjamin Pierce.
04:26:35 <askentask> quicksilver: ok but is it possible like i said, write a typechecking-program that checks types and it could work independantly of the compiler
04:26:44 <askentask> must be right
04:27:11 <Raevel_> i'm pretty sure pierce confirms that in the book
04:27:24 <askentask> so i could stat at the top of a file, store evry variable ina program and for each type have all ossible methods and then i check if anyd of the mthods performed ona var is  in the same group
04:27:34 <mapreduce> askentask: TAPL says that it's generally a good idea to design the syntax around the typesystem.
04:27:35 <hugo__> what is the difference between the reader monad and the state monad ?
04:27:47 <quicksilver> hugo__: you can't alter the value in the reader monad
04:27:51 <mapreduce> The converse of that would be that retrofitting a typesystem onto a language is probably often going to hurt.
04:27:59 <quicksilver> (and therefore it is not returned to you, because it can't have changed)
04:27:59 <mapreduce> Though for Scheme it might not be so bad.
04:28:18 <hugo__> ah ok
04:32:41 <ski_> mapreduce : what's the type of `or' ?
04:35:27 <ttomm> :t (||)
04:35:44 <ski_> (||) :: Bool -> Bool -> Bool
04:37:05 <askentask> mapreduce: im thinking about doing it for clojure(lisp on the jvm)
04:37:56 <ski_> (>>=) :: State x a -> (a -> Reader x b) -> Reader x b  -- hmhm
04:43:29 <stulli> > map (+1) [1..10]
04:44:06 <stulli> > map (+1) [1..10]
04:44:18 <Badger> ?vixen hi
04:44:21 <Badger> :o
04:44:31 * Badger performs CPR on lambdabot 
04:45:15 <Badger> CLEAR!
04:45:20 <Badger> *bzzzt*
04:46:01 <ski_>   [2,3,4,5,6,7,8,9,10,11]
04:46:02 <ski_>   [2,3,4,5,6,7,8,9,10,11]
04:46:09 <ski_>   Hello there, yourself.
04:49:26 <askentask> in haskell we have zip to zip8, seems like a limit of the typesystem. in java that limit doesnt exists, does it? so is that a price we pay for the type-inference?
04:50:13 <luite_> you mean with variable length argument lists in java?
04:50:25 <quicksilver> askentask: there is no limit of the haskell type system.
04:50:34 <quicksilver> askentask: they just got bored with writing zip functions after 8.
04:50:52 <quicksilver> individual implementations are permitted to impose a limit if they wish to, though
04:51:05 <askentask> i dont really know java very well but in clojure i can zip as many lists i want. in haskell i have to pass 2 lists to zip, 3 to zip3 etc
04:51:10 <quicksilver> , (1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0)
04:51:18 <lunabot>  luna: No instance for (GHC.Show.Show
04:51:23 <quicksilver> ah, yes.
04:51:32 <quicksilver> GHC has 30-tuples, but they don't have a show instance.
04:51:48 <askentask> yes coudlnt there be 1 zip fucntijn that zips any amount of lists?
04:51:54 <quicksilver> askentask: haskell functions have a fixed number of parameters.
04:51:59 <quicksilver> askentask: you could give it a list of lists though.
04:52:12 <luite_> askentask: only if you supply a list of lists, and don't return tuples, but lists again
04:52:32 <jsn> askentask: yes, there could be such a function
04:52:36 <luite_> hm, wouldn't that be transpose?
04:53:00 <jsn> we could just write a typeclass for it
04:53:17 <jsn> no one has bothered to do it, but haskell does not make it impossible
04:53:32 <quicksilver> in a sense that wouldn't be a single function though.
04:53:40 <jsn> a good example is print (Text.Printf in the standard library)
04:53:48 <quicksilver> it would be a typeclass polymorphic function which is a family of functions.
04:53:50 <quicksilver> but yes.
04:53:54 <jsn> quicksilver: sure, but it would present a uniform interface
04:54:27 <jsn> askentask: haskell makes "single dispatch" on the _result_ type easy-peasy
04:54:35 <ski_> would it work over the infinitude of different tuple types ?
04:55:02 <jsn> ski_: well, printf does that, right?
04:55:09 <ski_> not that i recall
04:55:18 <jsn> ski_: it's not tuples but varargs
04:55:22 <quicksilver> nothing works over the infinitude of tuple types
04:55:28 <quicksilver> since the tuple types have nothing in common
04:55:33 <quicksilver> they are just distinct types.
04:55:36 <jsn> right
04:55:53 <jsn> but zip could be done with varargs, like printf
04:56:12 <ski_> `printf' "finally" returns a `String'
04:56:20 <BONUS> i think ziplists are fine
04:56:20 <quicksilver> it couldn't return a list of tuples
04:56:25 <ski_> what would `zipN' "finally" return ?
04:56:26 <quicksilver> which is what zip does
04:56:28 <jsn> ah, wait, damn
04:56:32 <jsn> you are right
04:56:35 <jsn> curses
04:56:39 <quicksilver> it could return a list of lists.
04:56:41 <jsn> it'd have to return a list of lists
04:56:53 <quicksilver> but that imposes a different type restriction.
04:56:58 <jsn> yes
04:57:09 <ski_> or a list of `(a,(b,(..(z,())..)))'
04:57:15 * quicksilver nods
04:57:21 <jsn> ski_: which would not be so bad
04:57:35 <luite_> until you need to get the fst.snd.fst.fst.snd element ;)
04:57:48 <luite_> oh wait :)
04:58:08 <luite_> it would be more an iterate snd
04:58:20 <jsn> basically, that is like having a fixed length cons list
04:58:57 <ski_> hm .. maybe we should hype using balanced binary trees for simulating general tuples in a structural way, instead of that "church numeral" representation
04:59:22 <quicksilver> jsn: it is, roughly, what HList is.
04:59:43 <jsn> so, i bet you we could have polymorphic zip for the 17 tuple types
04:59:54 <jsn> and it would satisfy most everybody
05:02:01 <jsn> ski_: i understand what you meant now, about the tuple types
05:02:10 <jsn> for some reason i thought you meant a tuple of lists
05:02:10 <ski_> hm .. so maybe given a natural number, represented as a positional binary numeral, in types, we would have a type-class derive the appropriate shape of the balanced tree, plus handling accessors, et.c. ..
05:02:45 <jsn> askentask: so, i hope you appreciate that there is no reason in the type system not to have generic zipping
05:03:01 <askentask> so would it be hard or soemthing a half-assed haskellprogrammer could do? might teach me a lot...
05:03:14 <jsn> askentask: okay, just a minute
05:03:44 <sclv> uh -- hi guys! did anyone mention http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#t%3AZipList
05:04:28 <sclv> ZipLists are one of the motivating examples for applicatives --being more than a functor but less than a monad.
05:05:04 <ski_> sclv : good find !
05:05:15 <quicksilver> ZipLists are a monad actually.
05:05:20 <quicksilver> unless I misremember.
05:05:24 <quicksilver> they're just a different one.
05:05:36 <ski_> return = repeat  -- istr
05:05:49 <quicksilver> and join = take the diagonal
05:06:07 <quicksilver> has to be infinite stream to satisfy the laws.
05:06:18 <ski_> right, istr that
05:06:33 <quicksilver> so interesting, [a] is technicaly only a monad for finite lists
05:06:42 <quicksilver> and ZipList a is technically only a monad for infinite lists
05:06:58 <quicksilver> so they are actually *not* an example of two different monad structures on the same data type.
05:07:05 <Deeem2031> how do i convert a Int -> Int to a Int -> Float function?
05:07:13 <BONUS> haha, interesting
05:07:14 <sclv> oh, neat.
05:07:15 <quicksilver> Deeem2031: compose it with fromIntegral.
05:07:17 <BONUS> indeed
05:07:18 <ski_> (fromIntegral .)
05:07:45 <Deeem2031> fromIntegral (f x) does not seem to work
05:07:53 <quicksilver> it should do.
05:08:05 <Deeem2031> "Instance of Integral Float required for definition"
05:08:16 <Deeem2031> dunno what that mean
05:08:19 <quicksilver> you have something else wrong.
05:08:28 <ski_> Deeem2031> :t f
05:08:28 <quicksilver> something else is requriing it to be an integer
05:08:32 <quicksilver> hpaste your code perhaps.
05:08:44 <Deeem2031> ah, ok found the mistake already ^^
05:13:05 <askentask> jsn: and i do appreciate it :9
05:13:21 <jsn> askentask: it'll be a little while
05:15:04 <askentask> for what? im not asking you to do it for me :P
05:15:08 <askentask> you dont have to
05:15:20 <askentask> i want to myself if it is not to hard
05:31:14 <lilac> quicksilver: why is [] not a monad for infinite lists?
05:32:46 <BONUS> laws dont hold up prolly
05:33:02 <lilac> it's got to be associativity of (>=>), but i don't see it yet...
05:34:27 <ski_> i don't see it
05:34:28 <BONUS> hmm
05:34:58 <ski_>   join . return = id  -- seems to hold
05:35:04 <ski_>   join . fmap return = id  -- seems to hold
05:35:23 <ski_>   join . fmap join = join . join  -- is the hardest case
05:35:33 <ski_> @type join . fmap join
05:35:54 <ski_> join . fmap join :: [[[a]]] -> [a]
05:36:23 <lilac> so, joining the inner lists must commute with joining the outer lists
05:36:37 <lilac> surely that holds?
05:36:59 <BONUS> hmm also i dont see why ([1..] >>= f) >>= g = [1..] >>= (f >=> g) shouldnt hold for instance
05:37:45 <ski_>     join . fmap join $ [[[f i j k | k <- [0..]] | j <- [0..]] | i <- [0..]]
05:37:57 <ski_>   = join [join [[f i j k | k <- [0..]] | j <- [0..]] | i <- [0..]]
05:38:22 <lilac> perhaps an easier question, why is ZipList not a monad on finite lists?
05:38:27 <ski_>   = join [join [f i 0 k | k <- [0..]] | i <- [0..]]  -- right ?
05:38:41 <quicksilver> lilac: in do { a <- [0..], b <- [0..], return (a,b) } you never get past "0" in one of the coordinates
05:38:52 <quicksilver> lilac: that's the key problem IIRC.
05:39:08 <ski_> lilac : what is the diagonal of `[[0,1,2],[3],[4,5,6,7]]' ?
05:39:33 <quicksilver> just one infinite list doesn't brake it, but two do.
05:39:46 <ski_> hm, my last line above should of course have been
05:39:54 <ski_>   = join [[f i 0 k | k <- [0..]] | i <- [0..]]  -- right ?
05:41:08 <lilac> ski_: [0] ?
05:41:19 * lilac suspects that's not associative
05:41:22 <ski_>   = [f 0 0 k | k <- [0..]]
05:43:06 <ski_>   = join [[f 0 j k | k <- [0..]] | j <- [0..]]
05:43:36 <ski_>   = join . join $ [[[f i j k | k <- [0..]] | j <- [0..]] | i <- [0..]]
05:43:44 <ski_> i think that's it
05:44:54 <lilac> quicksilver: this appears to be associative: (const [0..]) >=> (\a -> map ((,) a) [0..]) >=> (\(a,b) -> map ((,,) a b) [0..])
05:45:24 <ski_> lilac : the problem with finite `ZipList's had, iirc, to do with taking diagonal in the two ways `join . join' vs. `join . fmap join' in an infinite "cube" .. problem being that taking diagonals perpendicular to one axis can lose more values that doing it the other way
05:45:45 <ski_> lilac : in the above example `6' is "lost"
05:46:10 <lilac> ski_: doesn't that happen either way around, though?
05:46:20 <FunctorSalad> ,bot
05:46:29 <lunabot>  luna: Not in scope: `bot'
05:46:31 <ski_> quicksilver : so, even though `(++)' loses its right argument when the left is infinite, i don't think that will disturb the laws
05:46:52 <ski_> lilac : i had some half-ass example i'm trying to recall
05:46:53 <quicksilver> ski_: hmm. maybe you're right.
05:47:18 <ski_> quicksilver : i found it easiers to visualize as an infinte "cube", there as well
05:47:26 <ski_> s/rs/st/
05:47:38 <FunctorSalad> what's a ZipList? :(
05:47:43 <lilac> ski_: i'd think that final size = max i. (i,i,i) in indices of ZipList, no matter which way you go?
05:47:53 <quicksilver> ski_: you think because the left-bias is consistent it's ok. hmm.
05:48:02 <ski_> exactly
05:48:15 <quicksilver> maybe you're right. I have only a memory that it isn't.
05:48:26 <ski_> (dang, lambdabot's still in lala-land ..)
05:48:57 <ski_> FunctorSalad : "like a list", but `lifM2' zips instead of tries every combination
05:49:06 <ski_> s//t/
05:49:33 <FunctorSalad> hmm
05:50:02 <ski_> > return (+) `ap` [100,200] `ap` [3,4]
05:50:11 <ski_>   [103,104,203,204]
05:50:28 <ski_> > runZipList $ return (+) `ap` ZipList [100,200] `ap` ZipList [3,4]
05:50:33 <ski_>   [103,203]
05:50:47 <lilac> shouldn't that be [103,204]?
05:50:52 <ski_> er, right
05:50:52 <FunctorSalad> @type runZipList
05:50:56 <ski_>   [103,204]
05:51:14 <FunctorSalad> oops ;)
05:51:15 <ski_> except `ZipList' is probably not in `Monad', so you'd have to replace `return' by `pure' and `ap' by `<$>' (iirc)
05:51:28 <ski_>   runZipList :: ZipList a -> [a]
05:51:32 <FunctorSalad> :)
05:51:39 <lilac> preferably replace return f `ap` with f <$>
05:51:44 <ski_>   newtype ZipList a = ZipList {runZipList :: [a]}
05:51:48 <lilac> and `ap` with <*>
05:52:11 * ski_ always confuses up `<*>' and `<$>'
05:52:25 <lilac> ski_: <$> is like $ (between function and argument)
05:52:40 <lilac> ski_: <*> is like product on types (imagine the function weren't curried)
05:52:42 <ski_> yes, i suppose i could maybe recall it like that
05:52:48 <ski_> `<*>' is a bad name, imo
05:52:54 <FunctorSalad> a mnemonic I recently found is that <*> does a cartesian product for the actual List monad
05:53:10 <ski_> it (to me) suggests the operator is "symmetric", but it's not
05:53:15 <FunctorSalad> (well, and then does application)
05:53:19 <lilac> FunctorSalad: it's inner product on ZipLists, i guess :)
05:53:36 <ski_> `<*' and `<$' would be better ..
05:53:58 <Deewiant> , (,) <$> [100,200] <*> [10,20]
05:54:01 <lunabot>  [(100,10),(100,20),(200,10),(200,20)]
05:54:03 <quicksilver> ski_: interesting point.
05:54:19 <quicksilver> ski_: I think they were intended just to look like a box drawn behind the operators
05:54:28 <quicksilver> ski_: i.e. to make them look different
05:54:36 <quicksilver> but it does make them look symmetric.
05:54:48 <quicksilver> however, they use the < > for other purposes, now
05:54:57 <FunctorSalad> lilac: <*> fs xs = [f1 x1, f2 x2, ...] ?
05:55:09 <quicksilver> note that <$ $> <* and *> are all also there ;)
05:55:21 <FunctorSalad> (for ZipList)
05:55:37 <ski_> (the other argument against them is that they're taking up namespace .. `<*>' are sortof a "standard" name for any "variant" on `*' you make temporarily ..)
05:55:38 <lilac> FunctorSalad: yes, i think that's right.
05:55:45 <quicksilver> *> and <* are very useful in parsers.
05:56:02 <FunctorSalad> ski_: you could use arrows instead ;)
05:56:04 <lilac> is *> the same as <$> ?
05:56:13 <quicksilver> bracketedexpr = bra *> expr <* ket
05:56:15 <ski_> FunctorSalad : it's not the same
05:56:27 <quicksilver> the arrows point at the bit you want to return.
05:56:34 <FunctorSalad> ArrowApply is equivalent to Monad I thought
05:56:55 <quicksilver> FunctorSalad: arrowapply means that the arrow is the kleisli arrow of a monad.
05:57:05 <quicksilver> which you can reconstruct if you want, from the arrow.
05:58:38 <ski_> quicksilver : yes, `<$',`$>',`<*',`*>',`<**>' all look silly to me, too :) .. (especially `<**>') .. but i suppose i've not really thought about `<* blah *>' much
05:59:31 <quicksilver> ski_: well symbolic operators are pretty limited in the extent that they can be mnemonic.
05:59:39 <quicksilver> and the namespace is frustratingly small.
05:59:49 <FunctorSalad> utf-8!
05:59:57 <quicksilver> so really it's a question of letting standard usages evolve and getting used to them.
06:00:10 <FunctorSalad> I think utf-8 actually works if you use parentheses
06:00:20 <quicksilver> it works without parentheses.
06:00:24 <FunctorSalad> hmm
06:00:35 <quicksilver> apparently most utf-8 input methods do not give convenient access to the mathematical planes, though.
06:00:35 <FunctorSalad> for symbolic operators?
06:00:45 <quicksilver> yes, if unicode thinks it is a symbol, GHC does.
06:00:51 <FunctorSalad> quicksilver: there's a latex IM for scim
06:01:12 <quicksilver> if unicode thinks it's alphabetical, GHC treats it as an identifier.
06:01:19 <FunctorSalad> ∫
06:01:20 <quicksilver> there's a latex IM for emacs, I think.
06:01:25 <FunctorSalad> yes
06:01:30 <FunctorSalad> it's called 'tex' though
06:01:37 <quicksilver> but I'm not very keen in the idea of typing '\smalltriangleleft'
06:01:43 <quicksilver> every time I want to use a Data.Sequence
06:01:46 <quicksilver> (or whatever)
06:02:01 <FunctorSalad> I think an unambiguous prefix will do
06:02:03 <jsn> askentask: this does not exactly do what i want
06:02:04 <jsn> http://github.com/jsnx/haskell-demos/tree/master/generic_zip%2FGenericZip.hs
06:02:22 <quicksilver> you will note that I wrote the latex package which enables you to use haskell-like operators instead of long latex escape sequences.
06:02:38 <jsn> GHC seems to get tripped up on the heterogenuous example
06:02:50 <jsn> but the simple example works as expected
06:04:09 <FunctorSalad> quicksilver: I think the emacs IM isn't hard to modify either
06:04:18 <quicksilver> FunctorSalad: you're probably right. I've never tried.
06:04:19 <FunctorSalad> IIRC it's just a list in an .el file
06:04:45 <quicksilver> My concern is that some part of my convenient everyday toolchain would not support utf8 well.
06:04:47 <jsn> askentask: basically, you have to annotate the heck out of the heterogenuous example to make it work
06:05:03 <quicksilver> but maybe the time is approaching to give it a try.
06:05:07 <jsn> quicksilver: what part of your toolchain would that be?
06:05:12 <quicksilver> jsn: I dunno really.
06:05:18 <quicksilver> it's an irrational concern
06:05:18 <FunctorSalad> yeah, almost everything seems to have an encoding flag now
06:05:23 <quicksilver> ctags? find? grep?
06:05:35 <jsn> yeah, and it usually defaults to UTF8
06:05:52 <jsn> i don't know about ctags
06:06:11 <jsn> but i doubt you'll have any trouble with find, grep, sed, &c.
06:06:43 <jsn> does anybody have any ideas about getting the heterogenous example in the code i posted earlier to work without annotations?
06:07:13 <jsn> do i need to turn on some kind of enhanced type defaulting?
06:09:44 <FunctorSalad> don't do "/exec find . ∫" ;)
06:10:03 <FunctorSalad> at least it didn't print to channel
06:10:11 <jsn> hehe
06:10:21 <jsn> well, it depends also what your locale is set to
06:10:42 <quicksilver> jsn: hmm (your GenericZip)
06:10:50 <FunctorSalad> the problem isn't the ∫, it's that I forgot the -iname
06:10:51 <jsn> quicksilver: aye
06:11:01 <jsn> quicksilver: how do i make it better?
06:11:14 <quicksilver> I don't understand that error message.
06:11:33 <jsn> i don't get it, either
06:11:48 <FunctorSalad> quicksilver: find on a file named '∫' works here
06:11:51 <quicksilver> it's some interaction with the fact that 0 is an overloaded constant.
06:11:53 <jsn> it seems to be saying, it can not infer that [0..9] is [Int]
06:12:01 <jsn> hmm
06:12:40 <jsn> well, if i remove the 0, it makes no difference
06:12:51 <quicksilver> not just 0 :P
06:12:53 <quicksilver> all the numbers.
06:12:57 <jsn> right
06:13:05 <quicksilver> you'll fine it works OK if you stick to non overloaded literals
06:13:08 <quicksilver> like chars and ()s
06:13:10 <jsn> right
06:13:23 <jsn> but why don't the defaulting rules kick in here?
06:13:39 <quicksilver> well you have an explicit type sign anyway.
06:13:43 <quicksilver> OK, I know what it is.
06:13:46 <jsn> oh?
06:14:08 <quicksilver> it can see the instance for [Int] -> [Char] -> [Float] -> [(Int,Char,Float)]
06:14:09 <quicksilver> but...
06:14:16 <quicksilver> that doesn't prohibit another instance existing
06:14:33 <quicksilver> of the form [Rubbish] -> [Char] -> [OtherRubbish] -> [(Int,Char,Float)]
06:15:03 <quicksilver> (such that Rubbish is a member of Integral and OtherRubbish of Fractional)
06:15:04 <quicksilver> I guess.
06:15:16 <quicksilver> such an instance would not overlap with the ones you gave
06:15:22 <quicksilver> so there is nothing to say that one might not exist.
06:15:51 <jsn> curses
06:16:00 <quicksilver> this is what fds are for
06:16:16 <quicksilver> to show that some parts of the type entirely determine other parts of the type
06:16:18 <jsn> i don't see how they would help in this scenario
06:16:20 <quicksilver> (also associated types)
06:16:29 <jsn> oh, aha
06:16:47 <quicksilver> you'd say that the (a,b,c,d) part was enoguh to determine the whole type of f
06:17:13 <quicksilver> not particularly easy to get it right for this example though
06:17:17 <quicksilver> easier with ATs perhaps?
06:17:30 <jsn> ATs ?
06:18:01 <jsn> associated types?
06:19:44 * quicksilver nods
06:19:46 <Peaker> #clean seems empty. Is anyone using Clean?
06:20:26 <Twey> OK, so I'm certain I'm Doing It Wrong here
06:21:20 <Twey> What do you do if you have a type (data Value = String String | Number Double | Object (M.Map String Value)), and you want to use just one of the constructors in another type?
06:21:40 <Twey> E.G. data Scope = NoScope | Scope Object
06:22:09 <quicksilver> Twey: you can't.
06:22:09 <Peaker> Twey: You should probably have an extra type that only has that data constructor and use it in both?
06:22:16 <quicksilver> Twey: constructors are not types.
06:22:22 <quicksilver> Twey: occasionally this is annoying.
06:22:35 <quicksilver> occasionally I wish every constructor was automatically a type
06:22:40 <Twey> Mmkay, thanks.
06:22:56 <quicksilver> Twey: if that intrigues you, read "Data Types a la carte"
06:22:58 <Peaker> I'm reading the bi-directional arrow paper and it has a very weird notion of what the standard <*> is
06:23:16 <Twey> quicksilver: It sound somewhat messy
06:23:21 <Twey> sounds**
06:23:22 <mapreduce> askentask: What have you been thinking of doing in clojure?  I appear to have lost context.
06:23:40 <quicksilver> mapreduce: askentask has been talking about patching a type-system onto it
06:23:43 <quicksilver> as a separate program.
06:25:00 <mapreduce> Ah, yes.
06:25:23 <mapreduce> I don't know clojure, but it probably has some JVM-induced brain damage.
06:25:57 <mapreduce> I'd probably go for Scheme (and if the JVM was a plus, sisc).
06:26:09 <jsn> askentask: so, i guess this isn't so easy in haskell
06:26:29 <Peaker> goddamn all the silly unicode symbols in PDF's.. I wish I knew what Haskell thing they were referring
06:26:44 <jsn> Peaker: LOLz
06:26:45 <jsn> yeah
06:27:02 <Twey> Heh, so I now have nested types like this: ValueEx (PrimV (String "foo"))
06:27:21 <Twey> Peaker: Have you seen the Unicode Prelude?
06:27:28 <Twey> It's probably literal code in that :)
06:30:49 <jsn> quicksilver: i'm having trouble understanding how to use associated types for this
06:30:58 <Twey> And that's now wrapped in a couple of monads, so wrapS = return . return . ValueEx . PrimV . String
06:31:20 <quicksilver> jsn: I can't help you there. I know what they are but no idea how to use them.
06:31:27 <jsn> heh
06:31:32 <quicksilver> I've never tried.
06:37:56 <conal> is there a way to package up an #include like to share across (be #include'd into) various other haskell packages?
06:39:09 <Peaker> Twey: nope, haven't seen it
06:40:32 <Twey> Oh dear, GNOME... recursive error messages!
06:41:00 <mapreduce> GINAE - GINAE IS NOT AN ERROR
06:41:29 <Twey> let errorMsg = "Failed to contact configuration server; some possible causes are that you need to enable TCP/IP networking for ORBit, or you have stale NFS locks due to a system crash. See http://www.gnome.org/projects/gconf/ for information. (Details -  1: " ++ errorMsg in errorMsg
06:41:57 <jsn> Twey: what kind of system are you on?
06:42:07 <Twey> jsn: ArchLinux
06:42:17 <jsn> you set it up yourself?
06:42:20 <Debugger> I would kill the guy who invented recursive acronyms.
06:42:20 <Twey> x86
06:42:26 <Twey> Pretty much, yeah
06:42:28 <jsn> it's not in a network or something
06:42:36 <Twey> I mean, I didn't build it from scratch or anything.
06:42:42 <Twey> Just a LAN
06:42:43 <jsn> Debugger: you would, but...
06:43:01 <jsn> Twey: ah, well, it's odd that it expects a remote server
06:43:08 <Twey> Debugger: But it would cause recursion?
06:43:32 <Twey> jsn: Nah, it's actually a local socket
06:43:47 <Twey> Sorry, I missed out a chunk of the error message
06:43:54 <Peaker> hmm.. Its unlike Haskell to have theoretically-unsound stuff like arrow extensions that "assume" (or hand-wave away) their incompatibility with "arr" (Reading the bidirectional arrow paper..)
06:44:16 <Twey> "Failed to get connection to session: Failed to connect to socket /tmp/dbus-MbvVvK9CsO: Connection refused"
06:44:21 <Peaker> Maybe with class aliases, the arrow classes can be rehauled to make more sense
06:44:44 <quicksilver> Peaker: Control.Category was introduced to represent composable things which don't support arrows.
06:44:54 <Twey> Peaker: :-\  Oo-er
06:44:55 <Twey> What *are* class aliases?
06:45:16 <quicksilver> @go class alias proposal haskell
06:45:21 * quicksilver sighs
06:45:28 <Peaker> http://repetae.net/recent/out/classalias.html
06:45:37 <Twey> Heh, thanks
06:46:05 * Twey will read it in about half an hour, when the page has loaded.
06:46:19 <Peaker> quicksilver: Category seems nice, but first/***/etc should probably be in an extension class independently of "arr"
06:46:31 <Peaker> Twey: it loads instantly here
06:47:18 <orbitz> :t map
06:48:15 <xenoblitz> hi guys... I was wondering if anyone ever used a type class to be able to define a higher order function which is able to handle functions of varying arity
06:48:31 <Peaker> <Peakerbot> forall a b. (a->b) -> [a] -> [b]
06:48:44 <SamB> hmm, higher order?
06:48:45 <SamB> not sure.
06:48:49 <xenoblitz> for example
06:48:54 <SamB> printf uses a trick of that sort though
06:49:26 <quicksilver> xenoblitz: I can't see why you woudln't be able to do it.
06:49:31 <orbitz> hrm, what is the dfiference between map and fmap?  I see a differencein type but i'm not getting teh Functor part
06:49:33 <quicksilver> it sounds like a terrible idea, though.
06:49:44 <xenoblitz> Simulate (TypeA)
06:49:44 <xenoblitz> Simulate (TypeA -> TypeA) TypeA
06:49:44 <xenoblitz> Simulate (TypeA,TypeA -> TypeA) (TypeA,TypeA) ... and so on
06:49:46 <quicksilver> Printf should be viewed as an example of what not to do :)
06:50:05 <xenoblitz> make that last line
06:50:11 <xenoblitz> ﻿Simulate ((TypeA,TypeA) -> TypeA) (TypeA,TypeA)
06:50:46 <xenoblitz> oh and small simulate not Simulate
06:50:49 <xenoblitz> any ideas?
06:51:49 <Peaker> orbitz: fmap is general to all functors (including lists), and map is specific to just lists
06:52:44 <Peaker> orbitz: A type constructor (such as List, IO, or any other type of kind *->*) can be a Functor if it has a way to "map" the value[s] that is/are in a sense "inside" it
06:52:45 <quicksilver> xenoblitz: isn't that just simulate (a -> TypeA) a ?
06:53:14 <Twey> Ooh, class aliases look very cool
06:53:31 <xenoblitz> quicksilver: hmmm types really confuse me in this context... but yes i think you are right
06:53:44 <xenoblitz> quicksilver: (that said I am sure you are right)
06:53:47 <Twey> orbitz: map = fmap, but only for lists.
06:53:54 <orbitz> Peaker: do you have a specific example of something other than a list?
06:54:09 <Twey> @instances Functor
06:54:20 <Twey> Oh, \b is dead.
06:54:29 <quicksilver> orbitz: Maybee
06:54:31 <Peaker> orbitz: IO
06:54:33 <Twey> :(
06:54:38 <Peaker> orbitz: Maybe is an easier example though, yeah ;)
06:55:03 <orbitz> why would i want to fmap over a Maybe?
06:55:07 <Peaker> orbitz: (Maybe a) allows you to fmap the value inside the maybe if there is one, or leave it a simple Nothing if there isn't one
06:55:28 <Twey> fmap (*5) (Just 3) -- ===> Just 15
06:55:32 <lilac> ------------------------------------------------------------------------------(richards@blackett)-(14:54/08-11-21)-
06:55:35 <lilac> `-->
06:55:36 <Twey> fmap (*5) Nothing -- ===> Nothing
06:55:38 <Peaker> orbitz: You want to change the contents of the maybe, without pattern-matching the Nothing case for which you don't care
06:55:43 <Twey> lilac: *blink*
06:55:48 <lilac> oops, sorry. i meant http://hpaste.org/12246
06:55:52 <xenoblitz> quicksilver: ok so i wrote a class with has a function called simulate :: a -> Bool for example... how do I extend it in the way I expressed above? or at least where can I read about this sort of stuff?
06:55:53 <lilac> stupid x clipboard grr
06:55:55 <Twey> Hehe
06:56:04 <Peaker> orbitz: also, code that you write that uses generic classes like Functor will be useful for all the Functors in existence (there are plenty!) rather than be specific to some type
06:56:04 <orbitz> could i use fmap to do that over a [Maybe a]?
06:56:16 <Peaker> orbitz: yes,  fmap.fmap  maps over [Maybe a]
06:56:17 <Twey> orbitz: That would be fmap . fmap
06:56:29 <lilac> xenoblitz: http://hpaste.org/12246 <-- varying arity with typeclasses
06:56:32 <Twey> Or map . fmap, whichever you prefer
06:56:34 <quicksilver> xenoblitz: I've not currently seen any reason why it needs to be a class.
06:56:53 <orbitz> thanks
06:56:58 <mgdtgd> hi
06:56:59 <quicksilver> xenoblitz: and why you can't just use simulate :: (a -> TypeA) -> a -> whatever...
06:57:05 <Peaker> orbitz: for every Functor that "Wraps" your value, you can compose another fmap to "penetrate" the wrapper and access the value inside
06:57:05 <quicksilver> but then, I'm not sure what you're trying to do.
06:57:20 <mgdtgd> I'm looking for a simple, elegant solution to pretty printing a binary tree
06:57:30 <quicksilver> xenoblitz: quicksilver's rule 1 : If you think you want a typeclass, think again.
06:57:39 <Twey> orbitz: It's like liftM, but for Functors.  :)
06:57:39 <xenoblitz> lilac: thanks but that's complex for me :/
06:57:51 <geezusfreeek> mgdtgd: deriving Show ;)
06:58:00 <lilac> xenoblitz: as quicksilver says, you probably don't /want/ to do that, but you /can/...
06:58:09 <mgdtgd> geezusfreeek: _pretty_ printing
06:58:16 <xenoblitz> ok let me give you my context
06:58:29 <xenoblitz> imagine you are using haskell for circuits...
06:58:35 <xenoblitz> some gates have 1 input
06:58:37 <xenoblitz> some have 2
06:58:37 <mgdtgd> by pretty printing I mean: every node sits between its children, one line above them
06:58:38 <xenoblitz> for example
06:58:42 <xenoblitz> and you want to simulate them
06:58:47 <orbitz> what does liftM do?
06:58:49 <geezusfreeek> mgdtgd: i was just being silly
06:58:49 <SamB> xenoblitz: you could use tuples ;-P
06:58:55 <lilac> xenoblitz: you're modelling them as functions?
06:58:58 <xenoblitz> yes
06:58:59 <Peaker> orbitz: liftM = fmap
06:59:06 <xenoblitz> example
06:59:11 <jpcooper> orbitz, applies a function to the contents of a monadic value
06:59:14 <SamB> (that's the way Lava did it in one life ...)
06:59:19 <lilac> xenoblitz: why not 'not :: Expr -> Expr', 'nand :: Expr -> Expr -> Expr', etc...
06:59:24 <xenoblitz> SamB: yes :P
06:59:25 <geezusfreeek> but i must go, so no time to discuss pretty printing, sorry
06:59:42 <quicksilver> mgdtgd: Text.PrettyPrint?
06:59:47 <xenoblitz> yes lilac
06:59:48 <orbitz> are liftM and fmap exactly the same?
06:59:50 <mgdtgd> I need to program it myself
06:59:57 <xenoblitz> then how do you simulate an orG or an andG with just one function
06:59:58 <Peaker> orbitz: The class hierarchy *should* have been: Functors => Applicatives => Monads  but due to unfortunate historical reasons, it isn't.  Since Monad is more expressive than Functor/Applicative, you can express all of their methods with just the monadic (return, >>=)
07:00:06 <mgdtgd> it's a kind of homework, just not mine. But I need to explain it to others
07:00:11 <SamB> orbitz: they should always be identical whenever they occur at the same type, yes
07:00:14 <mgdtgd> so it would be good to know the solution myself
07:00:15 <Peaker> orbitz: the expression of fmap is called liftM, that of <*> is called ap, that of pure is called return
07:00:26 <quicksilver> mgdtgd: read the paper reference in the docs of Text.PrettyPrint
07:00:43 <mgdtgd> are they suitable for beginners?
07:00:53 <mgdtgd> it's a CS 101 course
07:00:54 <Peaker> orbitz: if Monad subclassed Applicative as it should have, we wouldn't need that duality
07:00:56 <quicksilver> read it and let me know.
07:00:57 <SamB> mgdtgd: beginning readers or ?
07:01:08 <Peaker> orbitz: we also have sequence VS. sequenceA and others :-(
07:01:23 <SamB> Peaker: now, now
07:01:26 <SamB> how could it have ?
07:01:32 <SamB> Applicative was invented second!
07:01:36 <lilac> xenoblitz: i'm not sure i understand the question. you can write and a b = not $ nand a b; or a b = nand (not a) (not b)
07:01:48 <Peaker> SamB: class aliases and less backwards compatibility :)
07:01:50 <SamB> it's Functor that it has no excuse for not subclassing
07:02:04 <SamB> Peaker: well, you might notice that nobody has implemented those
07:02:06 <Twey> mgdtgd: You'd have better luck doing it horizontally
07:02:20 <xenoblitz> lilac: I used that .... sort of simulate $ andG true false for example
07:02:23 <SamB> JHC can parse them but that's about it ...
07:02:26 <xenoblitz> but i want a higher order function... :P
07:02:38 <Twey> With a straight line across the top, starting in the top left corner and branching down
07:03:04 <Twey> That's the only solution of which I can think that can be done lazily
07:03:05 <orbitz> Peaker, SamB thanks, i'm sure i'll be back for more since i didn't quite follow all of that
07:03:12 <mgdtgd> I thought of a complicated way using BFS. But that's too complicated
07:03:15 <lilac> Peaker: i don't think the class heirarchy is that clear cut. Functor => Pointed, Function => Applicative, (Arrow, Pointed, Applicative) => Monad. but that'd be a complete pain
07:03:16 <Twey> (and simply)
07:03:41 <Peaker> orbitz: basically a Functor is a value[s] "container" that allows you to modify the contained value[s] while its still inside.  An Applicative is a "container" that allows you to run a pure function/computation using multiple containers as input (combining multiple contained results in one computation)
07:03:44 <SamB> Twey: what about the line going down the left ?
07:04:13 <lilac> Peaker: and there are many more 'base' classes you might want to add to Monad. I think the haskell approach to this issue is /far/ from perfect
07:04:18 <quicksilver> lilac: My experience is that Functor, Applicative and Monad are very commonly useful :)
07:04:19 <Peaker> lilac: that's even more fine-grained, and might be better, maybe it is possible with class alises?
07:04:24 <quicksilver> lilac: and that POinted is not.
07:04:35 <quicksilver> lilac: I think F > A > M would be far better than what we have now.
07:04:40 <quicksilver> even if not perfect.
07:04:51 <Twey> SamB: Oh, that works too.  :)
07:04:59 <SamB> lilac: well, we aren't going to give up just because we are far from perfect
07:05:12 <Peaker> orbitz: and a Monad is like "Applicative" except it allows you to "dynamically" choose which container to combine based on contained values (applicative makes you choose which containers to choose without looking at any contained values)
07:05:13 <Twey> Ends up being variable-height, though
07:05:17 <lilac> quicksilver: i don't disagree. however, i think a better language would allow the author of Pointed to say 'all Monads are Pointeds' without losing the ability to say 'this non-Monad is Pointed'
07:05:17 <Twey> Hard to format
07:05:21 <xenoblitz> I guess no one can help me with this... still thanks all the same :)
07:05:22 <SamB> we have to approach perfection by stopping in the places we can actually find that seem like they might be on the way
07:05:41 <SamB> you know ?
07:06:23 <SamB> Twey: what's wrong with variable height ?
07:06:26 <Peaker> lilac, quicksilver: Wouldn't class aliases allow us to have high-granularity classes like Pointed without giving away convenience?
07:06:28 <orbitz> Peaker: hrm ok
07:06:29 <SamB> isn't variable width worse ?
07:06:48 <Peaker> orbitz: its probably clearer if examples are used :)
07:06:59 <orbitz> Peaker: i think it would be :) suggested reading?
07:07:07 <SamB> Peaker: well, you'd still have to incorporate the hierarchy changes in the code for the classes that need to be subclasses ...
07:07:08 <lilac> sometimes i wonder if things'd be better if typeclasses were allowed only one member, with another concept (say Axiom) to represent rules about combinations thereof. that and aliases to save typing and make error messages nicer
07:07:25 <Peaker> orbitz: there's "the" paper about arrows, applicatives and monads, but I can't read it (too much math notation for me)...
07:07:47 <orbitz> Peaker: that doesn't bode well for me either then
07:07:51 <Twey> SamB: Variable width, sorry.
07:07:53 <xenoblitz> quicksilver: what are forall and that stuff called in haskell, you told me about them last time when I asked if it is possible to have the compiler decide the type at compile time
07:08:03 <lilac> xenoblitz: existentials?
07:08:06 <xenoblitz> quicksilver: ps totally unrelated question
07:08:12 <xenoblitz> lilac: oh thanks
07:08:23 <SamB> Twey: well, I mean, having to put things of variable width next to one another seems pretty tricky
07:08:57 <Peaker> orbitz: Hmm.. I don't know. Maybe I ought to write something up
07:09:03 <Twey> SamB: Right
07:09:07 <orbitz> Peaker: i agree!
07:09:26 <Twey> Which is why, since the items are variable-width, it's better to do it with the line across the top
07:09:45 <Twey> That way they don't have to go next to one another, they have to go beneath one another
07:09:50 <SamB> Peaker: what, you mean the one with all the isomorphisms and so forth ?
07:09:59 <Twey> And they're fixed-height
07:10:02 <Peaker> SamB: What?
07:10:08 <SamB> Peaker: that is NOT an introduction, if you meant that ...
07:10:20 <SamB> I guess not
07:10:30 <Peaker> SamB: I never saw any simple explanation explaining the basic: Functors let you map, Applicatives let you combine, Monads let you combine dynamically
07:11:16 <Peaker> SamB: with some examples of types that are Functors but not Applicatives, Applicatives but not Monads, etc
07:11:33 <Peaker> I don't know many examples of types that are Applicatives but not Monads, myself
07:11:46 <Peaker> I think conal's Behavior is one, but it "should" be a Monad
07:12:11 <conal> agreed.
07:12:23 <Peaker> I keep thinking that the Arrow-based optimized context-free parser could have been an Applicative-based parser, to serve as a good example
07:12:26 <conal> my favorite Applicative example is a UI
07:12:38 <Peaker> conal: Your Phooey's UI is a Monad, though, isn't it?
07:12:40 <conal> as in Phooey
07:12:46 <conal> ummm.....
07:12:56 <conal> i doubt it.  checking.
07:13:12 <Peaker> http://www.haskell.org/haskellwiki/Phooey#Monad
07:13:39 <Peaker> also, it is conceivable that some parts of the UI will change based on the current "result" of other parts
07:13:54 <quicksilver> I also don't know of any good examples of things which are Applicative but not Monad, except for the s-d parser.
07:14:04 <Peaker> quicksilver: "s-d" ?
07:14:12 <quicksilver> swierstra-duponcheel
07:14:33 <quicksilver> and Behaviour, as you said, but I don't think that counts.
07:15:21 <conal> Peaker: oh yeah.  phooey style UI is a monad, but TV-style isn't, and i think can't be.
07:15:42 <conal> and the TV style (also Eros style) is much more functional/composable
07:15:57 <Peaker> conal: come to think of it, Phooey style UI has just a result, not a "current result", so it being a monad does not really mean the UI is any more dynamic, right?
07:16:59 <quicksilver> conal: TV style isn't Applicative though is it?
07:17:35 <quicksilver> yes, dynamism for monads is a fiddlesome word.
07:17:40 <quicksilver> the reader monad is a monad ;)
07:17:44 <quicksilver> and it's not very 'dynamic'
07:18:13 <Peaker> I wonder if something like parsec can be written on top of Applicative to just sequence grammars and then be optimized into a Flying Spaghetti Monster
07:18:35 <Peaker> quicksilver: sure its dynamic, I choose a completely different function to apply next based on the result of the previous function
07:18:48 * quicksilver nods
07:18:51 <quicksilver> OK, fair enouguh.
07:19:03 <Peaker> though that dynamism does not add much to the one you already get in fmap itself
07:19:06 <Peaker> (in the case of reader)
07:19:20 <conal> oh dear.  i've forgotten my own libraries.
07:19:29 <Peaker> conal: heh :-)
07:19:31 <quicksilver> well parsec is a perfectly well behaved instance of applicative, but that doesn't make it magically optimise :)
07:19:56 <conal> sry.  i think there's something about Applicative, non-monadic UIs, but i can't seem to pull it out right now.
07:20:24 <quicksilver> the point is rather than by providing only an applicative instance, you open up other implementation ppossibilities - and these possibilities forbid a sensible monad instance.
07:20:39 <quicksilver> but, eulogising to one side, the S-D parser is the only actual example I know of.
07:20:57 <Peaker> quicksilver: I guess non-Monad instances are really about performance
07:20:58 <quicksilver> ah, I have one other.
07:21:04 <quicksilver> the PU combinators are not a monad.
07:21:08 <quicksilver> hmm. But are they applicative?
07:21:09 <Peaker> PU?
07:21:21 <quicksilver> PickleUnpickle
07:21:54 <quicksilver> no, of course they're not.
07:22:01 <quicksilver> they're not even functors
07:22:04 * quicksilver slaps quicksilver 
07:22:07 <Peaker> Yeah, we talked about it the other day
07:22:09 <quicksilver> they're merely an Expfuncrtor.
07:22:21 <Peaker> ExpFunctor applies bijective mappings?
07:22:25 <quicksilver> yes.
07:22:37 <quicksilver> wrap :: (a->b, b->a) -> PU a -> PU b
07:22:38 <lilac> has anyone written an arrow-based parser which can be converted to parse tables at compile time?
07:22:59 <quicksilver> lilac: the S-D parser is an applicative parser with approximately that property.
07:23:15 <quicksilver> it can be converted to next-symbol-lookup tables at compile time.
07:23:37 <lilac> i didn't realise applicative was restrictive enough for that :)
07:23:38 <Peaker> I guess the inability to choose which results to combine based on those results really sums up to either A) A performance decision (you need the information sooner to optimize)  B) A case where you were forced to choose which results to combine earlier
07:23:46 <conal> oh -- i think i remember the issue about Phooey.  I wanted a slider input widget to have type 'UI Float' (or 'UI Int').  I could get that type in the applicative approach, while in the monadic approach the best i could do was a type like 'UI (Behavior Float)'.
07:23:46 <quicksilver> lilac: you should read the paper it's great.
07:24:22 <conal> and then TV has a different style of interface (more functional/composable), and is easily layered on top of Applicative Phooey.
07:24:28 <Peaker> conal: I thought it used UI (Reactive Float) in either case anyway (that UI results were "static"
07:25:14 <conal> Peaker: UI (Reactive Float) for the monadic style and UI Float for the applicative style.
07:25:30 <lilac> quicksilver: this paper: "Deterministic, error-correcting combinator parsers"?
07:25:37 <quicksilver> lilac: that sounds right, yes.
07:25:46 <conal> Peaker: A.UI = M.UI :. Reactive  (A=applicative, M=monad)
07:25:49 * lilac adds it to the queue
07:26:28 <quicksilver> lilac: they were one of the motivations behind the original applicative paper, indeed
07:26:30 <conal> Peaker: which is convenient, since applicatives compose into applicatives.
07:26:58 <Peaker> conal: so M.UI is only allowed to look at "static" results of previous UI's when choosing the next UI to compose, so that you don't get flaky UI choosing based on user inputs?
07:27:05 <quicksilver> lilac: however, it seems that my memory is 100% wrong.
07:27:07 * quicksilver sighs.
07:27:26 <quicksilver> S-D parsers are the interesting example of an *arrow* which does not occur as the kleisli arrow of a monad.
07:27:46 <quicksilver> but there is clearly an applicative hook-up somewhere
07:27:49 <Peaker> conal: can Phooey build/use different UI's based on user inputs?
07:27:52 <quicksilver> because it's mentioned in the applicative paper.
07:28:00 * quicksilver can't remember any more.
07:28:19 <conal> Peaker: in a sense, the monadic version can.
07:28:48 <conal> Peaker: but i don't think it would look that way, because the dependence would be on a behavior.
07:29:13 <Peaker> conal: Then you get: (Behavior UI) -- can you "run" that?
07:29:20 <Peaker> conal: Use the UI there, that is
07:29:47 <conal> Peaker: i wouldn't know what to do with a Behavior UI.
07:30:15 <quicksilver> render it!
07:30:17 <Peaker> conal: " because the dependence would be on a behavior." --> doesn't that mean you end up with a UI nested inside a Behavior?
07:32:02 <conal> Peaker: not necessarily.  output widgets are constructed by passing in behaviors and so in that "build/use different UI's based on user inputs?".  but i don't think that's really what you had in mind.
07:33:26 <quicksilver> I assume Peaker means UIs which change dynamically
07:33:32 <quicksilver> new dialog boxes appearing/vanishing
07:33:38 <quicksilver> controls appearing and going away
07:34:14 <Giraffe> hrm, the example code from the person who wrote HDBC uses almost entirely do blocks in the code...
07:34:16 <conal> quicksilver: i think so also, and no i don't think you'd find the vocabulary in phooey to get that sort of thing.
07:34:20 <Giraffe> is this just really bad practice?
07:34:51 <quicksilver> not really, Giraffe
07:35:07 <quicksilver> although some people find the stacatto nature of do block code rather annoying
07:35:15 <quicksilver> and so there has been a trend towards combinators instead.
07:35:22 <Giraffe> right
07:35:31 <quicksilver> nothing wrong with a do block if it's the best way to express a problem clearly, IMO.
07:35:54 <quicksilver> conal: interesting. That's actually one of the things I wondered when I read the TV paper but I never got around to asking you about.
07:35:59 <Giraffe> oh, i agree, and it's kinda tough to avoid it with HDBC anyway, given that it exists pretty much entirely within the IO monad
07:36:25 <quicksilver> conal: One of the things I find most intriguing about reactive is whether it will help me do modal applications (I think I alluded to that in a mailing list post)
07:36:52 <quicksilver> conal: one of my toys has a main menu mode, a playing mode, a networked-chatting mode, and the imperative code for that is pretty nasty.
07:37:01 <Giraffe> oh, i just saw reactive
07:37:04 <Giraffe> now i'm interested
07:37:19 <conal> quicksilver: oh yeah.  i saw that note.  i'm really curious also.
07:37:48 <quicksilver> I'm "working up to" rewriting that toy
07:37:57 <quicksilver> working on something simpler first to get my head around the fundioms.
07:38:20 <quicksilver> initially I dived straight into it, but it was too hard since I was inexperienced with reactice.
07:38:24 <quicksilver> s/ice/ive/;
07:39:09 <DukeDave1> Hey
07:39:20 <DukeDave1> Damn, am I coming up as DukeDave1 ?
07:39:33 <Giraffe> yep
07:39:46 <orbitz> does last.fm use haskell?
07:39:52 <DukeDave1> It occurs to me that's not even possible
07:40:00 <DukeDave1> orbitz: If I get my way, yes :)
07:40:04 <Giraffe> well i guess it is now!
07:40:11 <Giraffe> oh wow, DukeDave1, really?
07:40:18 <orbitz> are you the kind of guy that gets his way?
07:40:41 <DukeDave1> Ah we're pretty open, whatever is the right tool for the job
07:40:48 <orbitz> cool
07:41:13 <orbitz> we are like that where i am too, the bosses decide the right tool is always Java for some reason though :)
07:41:24 <Giraffe> orbitz, my condolences
07:41:48 <DukeDave1> Ah well I'm trying to make it easier to integrate by fixing up the Thrift Haskell bindings
07:41:49 <conal> quicksilver: i think we'll all learn a lot in the process of playing with FRP, and i expect it to evolve for a while.
07:41:56 <DukeDave1> Which is why I'm here :)
07:42:08 <DukeDave1> But first I'm going to get rid of this pesky DukeDave
07:42:23 <DukeDave1> So I'll brb
07:42:41 <Giraffe> conal, i'm actually going to be involved in a research project involving functional reactive work this summer
07:42:52 <Giraffe> it's really engrossing stuff
07:42:54 <conal> Giraffe: you are?!  cool.  i'd love to hear more.
07:44:31 <Giraffe> basically it revolves around designing diagrams by using a functional reactive language, most likely LISP/scheme based
07:45:49 <conal> Giraffe: neat.  please let me know how it goes.
07:47:22 <monochrom> haha lazy cat
08:27:51 <sm> morning, all
08:28:21 <sm> I'm trying to write tfilter: Filter any TestLists in a Test, recursively, preserving the structure.
08:28:35 <sm> and spending too much time. Has anyone got something like this ?
08:28:48 <quicksilver> what's a TestList, what's a Test?
08:28:58 <sm> HUnit things
08:29:13 <quicksilver> ah.
08:29:35 <quicksilver> doesn't look too hard though?
08:29:45 <quicksilver> just a simple recursive function?
08:30:48 <sm> http://hpaste.org/12248 is what I have (where are you pastebot ?)
08:30:53 <quicksilver> tfilter (TestList l) = filter p (map tfilter l)
08:31:38 <quicksilver> well I missed the p parameter out
08:31:41 <quicksilver> but that's the idea
08:31:53 <quicksilver> tfilter p (TestList l) = filter p (map (tfilter p)r l)
08:31:58 <quicksilver> tfilter p (TestList l) = filter p (map (tfilter p) l)
08:32:26 <quicksilver> tfilter p (TestLabel l t) = TestLabel l (tfilter p t)
08:32:34 <twanvl> and then maybe wrap it back up in a TestList?
08:32:34 <quicksilver> tfilter p t = t
08:32:45 <quicksilver> gah, you're right twanvl ;)
08:33:02 <sm> I had something like that earlier, but there was a problem.. maybe I had it wrong
08:33:54 <sm> also I guess I was trying to mention only TestList and not the other constructors explicitly.. for "future-proofness".. which I guess was silly
08:35:39 <sm> I often find myself going in circles trying out new code, without being able to truly simplify, I think because there are hidden assumptions and decisions I have made
08:41:30 <sm> ok, there's v2 at http://hpaste.org/12248#a1 . It returns an empty TestList.
08:42:15 <sm> (like the previous)
08:42:43 <ivan_> is there any good graph library for haskell?
08:43:37 <ToRA|MSR> graph as in trees, acyclic, directed etc. or graphs as in bar chart?
08:43:53 <ivan_> trees, acyclics etc.
08:44:05 <ToRA|MSR> Data.Graph.Inductive out of fgl?
08:45:50 <ivan_> i have tried Data.Graph but it is not good, because you canot build graphs with your vertix lable, you have to number them, and it is impossible to remove a vertex from the graph
08:46:35 <ToRA|MSR> ivan_: have a look at Data.Graph.Inductive.Graph
08:47:19 <chowmeined> why does this run getLine before putStr? http://hpaste.org/12249
08:47:36 <mauke> suffering from buffering, maybe
08:47:49 <mauke> also, readLn
08:48:10 <mauke> or just reads, no need for try/evaluate
08:48:12 <chowmeined> ah yes, buffering
08:48:14 <ToRA|MSR> ivan_: wrt numbering i usually build a Data.Graph using graphFromEdges and then convert that to a D.G.I.G
08:48:18 <chowmeined> mauke, thanks
08:48:27 <mauke> @hoogle flush
08:48:50 <mauke> @bot
08:49:13 <mauke> preflex: seen lambdabot
08:49:13 <preflex>  lambdabot was last seen on #haskell 6 hours, 2 minutes and 54 seconds ago, saying: :)
08:49:29 <quicksilver> sm: I suspect that your predicate never returns true
08:49:44 <quicksilver> sm: did you try it with tfilter (const True) ?
08:50:26 <sm> quicksilver: good idea.. that returns them all
08:50:51 <quicksilver> ok, so tfilter isn't broken.
08:50:53 <quicksilver> just your predicate.
08:53:00 <ivan_> ToRA|MSR: yes but the conversion is as hard as building it from scratch using mkGraph
08:55:13 <ivan_> ToRA|MSR: what lib do i need? It can't find when importing the Inductive.Graph
08:55:30 <mauke> what's the error message?
08:55:35 <ToRA|MSR> fgl from hackage
09:00:03 <Raevel> @hoogle (a,a) -> (a -> b) -> (b,b)
09:00:15 <chowmeined> mauke, http://hpaste.org/12250 better?
09:00:24 <Raevel> i think lambdabot hates me
09:00:32 <mauke> Raevel: it's dead
09:00:37 <Raevel> :*/
09:00:44 <Raevel> at least it's not me!
09:00:52 <mauke> chowmeined: I'd use reads
09:02:12 <chowmeined> mauke, because its pure?
09:02:12 <mauke> the basic structure seems ok
09:02:16 <mauke> yeah
09:02:24 <chowmeined> i guess it'd be nice to avoid exceptions
09:02:26 <mauke> you don't need the :: IO Integer annotation
09:02:34 <chowmeined> too bad there isnt one that uses Maybe or Either
09:02:54 <mauke> :t listToMaybe . reads
09:03:00 <mauke> :-|
09:03:03 <chowmeined> lol
09:03:12 <quicksilver> chowmeined: yes. "read" is broken and should never be used.
09:03:19 <mauke> listToMaybe . reads :: (Read a) => String -> Maybe (a, String)
09:03:21 <quicksilver> use "reads" or a convenient wrapper around it.
09:03:36 <Kaylaisfat> This lang hurts my brain ^.^
09:03:39 <chowmeined> quicksilver, what do you mean read is broken?
09:04:23 <quicksilver> chowmeined: it's not sensible to catch exceptions from a pure function
09:04:39 <quicksilver> pure functions should never throw exceptions except to signal unrecoverable error.
09:04:55 <quicksilver> when I say "read is broken" I'm being hyperbolic
09:05:00 <chowmeined> which means never
09:05:05 <mapreduce> > head []
09:05:07 <quicksilver> but read should only be used when you know it will succeed.
09:05:10 <chowmeined> theres no such thing as an unrecoverable error
09:05:24 <quicksilver> by "unrecoverable" I mean "this is a bug in your program"
09:05:26 <mauke> hardware failure
09:05:33 <chowmeined> abort is lame like that
09:05:33 <gio123>  is somebody here from UK or USA??
09:05:42 <quicksilver> programming bug as distinct from user misbehaviour / bad data etc.
09:05:45 <mapreduce> gio123: Probably 50% of us.
09:05:59 <chowmeined> mauke, yet software tries to be robust in the face of that (see zfs)
09:06:12 <quicksilver> you should only ever call "head" on a list you know to be non-empty - similarly, you should never use read unless you know it will definitely parse.
09:06:33 <quicksilver> if there is a possibility of parse failure, use 'reads' or some nice wrapper around that.
09:06:51 <chowmeined> or parsec for complex stuff
09:07:17 <quicksilver> yes
09:07:22 <quicksilver> or other parse library of our preference.
09:07:30 <quicksilver> s/our/your/ ;)
09:08:26 <gio123>  is somebody here from UK or USA??
09:08:35 <chowmeined> gio123, that question was already answered
09:08:35 <dcoutts_> gio123: many
09:09:27 <gio123> can somebody for usa or uk pm me for a minute?
09:10:02 <dcoutts_> gio123: I suggest you say why, or nobody is likely to do so
09:10:44 <Beelsebob> > "are you awake \bot?"
09:10:50 <Beelsebob> apparently not
09:10:55 <Peaker> , "What about you?"
09:10:57 <lunabot>  "What about you?"
09:11:03 <gio123> dcoutts_: filling application form and 1 question is confusing me
09:11:15 <Beelsebob> yeh, it's \bot I want -- she's in #macosxdev doing not much interesting
09:11:26 * Beelsebob pokes Cale 
09:12:29 <chowmeined> how about this? http://hpaste.org/12251
09:12:56 <chowmeined> hmm, i guess that one type can be inferred
09:13:16 <mauke> yeah, that looks better
09:13:33 <chowmeined> ill just drop the s :: [(Integer, String)] because it can be inferred from the outer function's type
09:13:57 <quicksilver> Beelsebob: someone broke her by asking her to PL the Y combinator
09:14:06 <Giraffe> ahahaha
09:14:06 <chowmeined> mauke, thanks for your suggestions
09:14:12 <Beelsebob> quicksilver: >.<
09:14:18 <sm> quicksilver: no, I think tfilter was wrong
09:14:20 <quicksilver> at least that's when she broke
09:14:23 <quicksilver> so I assume that's why ;)
09:14:28 <sm> this works: tfilter p (TestList ts) = TestList $ filter (any p . tflatten) $ map (tfilter p) ts
09:14:42 <sm> where tflatten: Flatten a Test containing TestLists into a list of single tests
09:16:14 <sm> because the thing being filtered is a list of possibly deep TestList structures, not simple tests
09:16:35 <sm> good enough. phew. moving on. thank you!
09:17:11 <chowmeined> question though, why does reads return a list?
09:17:41 <ivan_>  Ambiguous type variable `gr' in the constraint:
09:17:42 <ivan_>       `Graph gr' arising from a use of `empty' a
09:18:04 <ivan_> how do i fix this, the Graph is a class gr
09:18:53 <skorpan> ivan_: it's clearly infeasible
09:18:57 <quicksilver> sm: well yes, with deep maps there are some choices to make about where you apply the predicate.
09:19:13 <quicksilver> chowmeined: in case there is more than one possible parse (ambiguous parsers)
09:19:24 <chowmeined> quicksilver, ew
09:19:26 <quicksilver> chowmeined: none of the standard implementations have that behaviour, though.
09:19:26 <ivan_> skorpan: oh yea
09:19:32 <Cale> @bot
09:19:35 <quicksilver> chowmeined: so I'm not quite sure why they chose that interface ;)
09:19:36 <Cale> hmm
09:19:50 <skorpan> ivan_: it would help if you could paste the code you're using
09:22:50 <ivan_> the code is empty, i am suing the Inductive.Graph library, and when calling the function emtpy it gives me the error
09:23:20 <mauke> , typeOf undefined
09:23:22 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
09:23:56 <quicksilver> I don't think suing libraries is productive.
09:23:56 <Peaker> @seen wchoggs
09:24:02 <quicksilver> They can't even afford lawyers.
09:24:04 <Peaker> ,seen wchoggs
09:24:06 <lunabot>  luna: Not in scope: `seen'
09:24:14 <quicksilver> preflex: seen wchogg
09:24:14 <mauke> preflex: seen wchoggs
09:24:14 <preflex>  Sorry, I haven't seen wchoggs
09:24:16 <preflex>  wchogg was last seen on #haskell 2 days, 14 hours, 3 minutes and 31 seconds ago, saying: And...lispy gets the award for awkward child molestation joke of the night.  Everyone gim 'im a hand.
09:24:33 <Peaker> what a way to leave
09:24:59 <vegai> hey guys. I was wondering if I was wrong saying this: http://www.reddit.com/r/programming/comments/7dxr0/interview_with_erlangs_joe_armstrong_garbage/c06fg0a
09:25:06 <Peaker> preflex: unpl join (&&&)
09:25:20 <mauke> \x -> x &&& x
09:25:32 <vegai> basically I'm saying that Haskell has most (all?) OO-features, more or less
09:25:34 <Peaker> I was wondering if it answers question from way above ;)
09:25:53 <Peaker> (a,a) -> (a -> b) -> (b,b)      (though its actually flip that)
09:26:13 <Peaker> preflex: @type join (&&&)
09:26:22 <Peaker> preflex only listens to the elite?
09:26:23 <quicksilver> vegai: no, you're right.
09:26:34 <quicksilver> vegai: the interesting debate is which is more convenient, I guess.
09:26:35 <mauke> Peaker: no, it's just not a lambdabot
09:26:40 <roconnor> vegai: isn't the core of OO considered to be dyanmic dispatch (for some reason)?
09:26:55 <quicksilver> roconnor: haskell can do dynamic dispatch.
09:27:01 <quicksilver> by more-or-less explicitly modelling the vtable.
09:27:10 <quicksilver> depending what flavour of dynamic dispatch you're after.
09:27:21 <quicksilver> So, the debate is about convenience rather than expressibility.
09:27:26 <Peaker> ah, I actually wanted  join (***)
09:27:50 <Peaker> Raevel: if you're still here,   join (***) is what you wanted :)
09:31:55 <Peaker> vegai: added a reply
09:32:29 <ivan_> skorpan: search for Data.Graph.Inductive.Graph
09:32:51 <roconnor> quicksilver: Ya, I was unsure if the class system is analogous to dynamic dispact
09:33:01 <quicksilver> roconnor: no, definitely not.
09:33:06 <roconnor> quicksilver: because it is really static dispatch.
09:33:18 <vixey> hello
09:33:18 <quicksilver> roconnor: you can build a java-class like system in haskell, but you wouldn't use typeclasses to do so
09:33:23 <roconnor> and IMHO, it fixes some of the problems with dynamic dispatch.
09:33:30 <quicksilver> (at least, not in the most literal way, they might be part of a solution in some ways)
09:33:52 <roconnor> quicksilver: oh, you are talking about something like Oleg's OOHaskell?
09:34:02 <quicksilver> perhaps. I'm just speaking in general terms.
09:34:05 <skorpan> ivan_: i think you'll have to instantiate Graph
09:34:17 <quicksilver> I'm saying "Show me an OO idiom, and we can do that in Haskell too"
09:34:25 <quicksilver> it may seem more cumbersome, possibly.
09:34:31 <quicksilver> depending on your expectations and use-cases.
09:34:54 <quicksilver> the WX interface has an amusing way to model subclasses, for example.
09:34:57 <hugo__> is happs terribly slow, or is it just me ?
09:34:59 <hugo__> oops
09:35:00 <hugo__> hpaste
09:35:01 <hugo__> :P
09:35:05 <skorpan> ivan_: there are, according to the documentation, two instances of DynGraph
09:35:12 <skorpan> "DynGraph Gr"
09:35:24 <skorpan> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-PatriciaTree.html#t%3AGr
09:35:32 <skorpan> that's where Gr is defined
09:37:03 <ivan_> skorpan: but this is capital G r
09:38:39 <skorpan> ivan_: yes, that's an instance of DynGraph, which you may use
09:39:10 <ivan_> skorpan: i fixed it, imported .Inductive only, and run empty :: (Gr () ())
09:39:14 <skorpan> it's just a parametrized data type
09:39:17 <vegai> Peaker: thank you
09:39:31 <skorpan> ivan_: well now your program typechecks, but i'm not so sure it makes any sense
09:40:14 <vegai> ah, interesting point
09:40:51 <ivan_> skorpan: yes, i tryed my own graph now, it shows stuff =)
09:41:26 <skorpan> ivan_: cool
09:46:16 <Vulpyne> Has anyone noticed that internal Haddock anchor links don't work at all in Opera?
09:46:56 <gwern> @seen chrisdone
09:47:55 <gwern> @bot
09:48:06 <BONUS> Vulpyne: yeah
09:48:11 <BONUS> which sucks but oh hell
09:48:13 <sm> here's my test runner, lets you run tests matched by name - http://hpaste.org/12248#a2
09:48:15 <gwern> hm.
09:48:21 <gwern> > 1+1
09:48:46 <gwern> Cale: lambdabot is dead
09:49:08 <mauke> for now, preflex provides 'seen' and 'tell'
09:49:13 <vixey> sm, this is not the whole code?
09:49:18 <gwern> preflex: seen chrisdone
09:49:18 <preflex>  chrisdone was last seen on #haskell 4 days, 17 hours, 22 minutes and 2 seconds ago, saying: Tip of the Day: In haskell, `readFile' means read a file into a string. In PHP, `readfile' means print it.
09:49:27 <sm> vixey: no, not quite
09:49:35 <gwern> preflex: tell chrisdone http://www.reddit.com/r/haskell/comments/7dirv/what_is_ghci_on_acid/ says lambdabot no longer works with your GOA. is that true? how can we fix that?
09:49:35 <preflex>  Consider it noted.
09:50:30 <gwern> chrisdone: ping
09:50:58 <sm> vixey: unittests & functests are just standard HUnit TestLists
09:51:10 <Cale> @bot
09:51:15 <lambdabot> :)
09:51:19 <Twey> Hmm... why is ghc so huge?  x.x
09:51:28 <vixey> do you still control lambdabot Cale?
09:51:34 <Cale> yes
09:51:45 <Twey> Ah, \b is alive
09:51:46 <lilac> quicksilver: that's like saying that C can do dynamic dispatch, or that assembler is homoiconic
09:51:56 <vixey> can you turn off monomorphism restriction? :)
09:52:14 <vixey> lilac, (assembly is usually considered homoiconic)
09:52:23 <vixey> @let foo = fmap
09:52:28 <lilac> quicksilver: re UTC+17:27
09:52:31 <lambdabot>  <local>:24:6:
09:52:37 <lambdabot>      Ambiguous type variable `f' in the constraint:
09:52:43 <lambdabot> Plugin `eval' failed with: thread killed
09:52:47 <Cale> @undefine
09:52:50 <hugo__> im having this stress: http://hpaste.org/12252
09:52:54 <Twey> ... kind of alive
09:52:54 <Cale> er
09:52:55 <hugo__> why is this ?
09:52:58 <Cale> Right.
09:53:14 <Cale> @let foo x = fmap x
09:53:19 <lambdabot>  Defined.
09:53:19 <Peaker> I wrote a long explanation of what I think is the "anti-OO" view is: http://www.reddit.com/r/programming/comments/7dxr0/interview_with_erlangs_joe_armstrong_garbage/c06gz2v
09:53:29 <lambdabot> Title: Peaker comments on Interview with Erlang's Joe Armstrong: Garbage Collection, Re ..., http://tinyurl.com/6z32cz
09:53:30 <lilac> vixey: yes. but it's not really /usefully/ homoiconic, because it's not easy to manipulate machine code from machine code
09:53:32 <Peaker> vegai: near your comment, there
09:53:43 <Cale> hugo__: Two different versions of the process package are being used?
09:53:53 <Cale> hugo__: At least, that's what it sounds like...
09:53:56 <hugo__> is that possible ?
09:54:01 <hugo__> im only calling it once
09:54:05 <lilac> vixey: i guess i mean, there's a difference between what a language makes possible (hopefully, any computable function) and what it makes easy
09:54:37 <vixey> any computable function??
09:54:55 <vegai> Peaker: magnifient! Thanks again
09:54:56 <kynky> as opposed to those which arent
09:55:10 <Cale> hugo__: Is it your own code which you're trying to build, or is it something I could download/
09:55:11 <Cale> ?
09:55:27 <vegai> I'll have to submit that since you cannot save comments otherwise...
09:55:37 <hugo__> its in happs
09:55:41 <hugo__> in module HAppS.Server.SimpleHTTP
09:55:58 <hugo__> maybe i have downloaded two versions of the same lib by mistake :/
09:57:07 <Peaker> vegai: I wonder if anyone has expressed these opinions more concisely/coherently anywhere else
09:57:17 <gwern> hee hee. 'interview with erlang's joe armstrong garbage'
09:57:28 <vixey> heh
09:57:48 <hugo__> i have downloaded happs, and happs-tutorial, and when i run the tutorial on ghci, it blows
10:02:05 <geezusfreeek> this isn't really a haskell question, but i was just wondering if any DB guys could help me out with this. this is a common problem in relational DB design as far as i know, but i'm having trouble thinking of it in terms other than functional. i want to model a data like data Foo = Foo a | Bar b c | Wibble d e f in a relational database with good referential integrity.
10:02:11 <geezusfreeek> i may have evern asked this here before
10:02:16 <geezusfreeek> *even
10:04:16 <Cale> geezusfreeek: Databases really need proper algebraic types ;)
10:04:23 <geezusfreeek> Cale, quite so!
10:05:48 <geezusfreeek> okay, restating it as data Foo = Bar a b | Wibble c d e for convenience in describing what i'm trying right now...
10:06:02 <Lemmih> hugo__: Blows?
10:06:12 <geezusfreeek> i have a Foo table, a Bar table, and a Wibble table, where the Bar and Wibble tables reference into Foo
10:06:30 <hugo__> Lemmih: yeah, like a bomb...
10:06:31 <Cale> geezusfreeek: I suppose the hard bit is ensuring that something isn't both a Bar and a Wibble
10:06:35 <geezusfreeek> exactly
10:06:45 <geezusfreeek> i could write custom CHECK code, but it would be huge
10:06:58 <geezusfreeek> since there are many many "constructors" in my actual data
10:07:28 <Cale> I'm not terribly familiar with database design, but I ran into this problem myself before, so I'd be interested to see what you come up with.
10:07:38 <hugo__> isn't happs 0.9.3 a stable version ?
10:07:41 <geezusfreeek> i've hit it many times, never finding a simple solution
10:07:46 <hugo__> maybe i should revert to 0.9.2 instead :/
10:07:47 <dons> pretty stable.
10:07:56 <dons> hugo__: nah, you should be using the newest one
10:08:00 <hugo__> hmm ok
10:08:14 <hugo__> i guess i've made some mistake on the installation then :/
10:08:39 <Cale> geezusfreeek: Another fun one is where you want to associate sets of elements of one table with elements of another. It requires you to create a new table with indexes into both.
10:09:02 <Lemmih> hugo__: 0.9.3 is more stable than 0.9.2
10:09:12 <hugo__> im using 0.9.3.1
10:09:14 <geezusfreeek> Cale, that i don't mind so much. at least there are no referential integrity problems left open
10:09:17 <Lemmih> hugo__: What's the error you're getting?
10:09:46 <Cale> geezusfreeek: Well, yeah, it's just hella inconvenient. Every table in your database should be a type, IMO.
10:10:01 <hugo__> well, when i run the happs tutorial, ghci exists with this error: http://hpaste.org/12252
10:10:24 <geezusfreeek> join tables are at least a part of the relational calculus and allows you to refer to such relations as nouns
10:10:27 <hugo__> i do a :l Main (which runs okay), then i do a runInGhci, and it exists with that error
10:10:33 <geezusfreeek> which can be very convenient
10:10:40 <Cale> (and sets of elements as well)
10:10:51 <Lemmih> hugo__: Try 'ghci -package process'.
10:11:03 <geezusfreeek> i just wish relational databases has sum types
10:11:20 <Cale> It would be interesting to see a database which had Haskell's type system.
10:11:22 <geezusfreeek> postgresql has enumerators and product types, but no sum type :(
10:11:25 <Lemmih> hugo__: Without loading happs-tutorial.
10:11:37 <geezusfreeek> i could write a custom type i suppose
10:11:44 <geezusfreeek> but... yuck
10:11:58 <dino-> Speaking of db and happs, I was intrigued with the idea of using happs' data storage capabilities alone without the http server parts. In lieu of SQL db. But have not done anything with this yet.
10:12:15 <Cale> geezusfreeek: You could also store a tag explicitly.
10:12:24 <dino-> It seems to be organized such that you could though.
10:12:27 <geezusfreeek> Cale, yeah, which also still requires custom CHECK code
10:12:36 <Lemmih> hugo__: Sigh, I'm being dense.
10:12:43 <hugo__> oh
10:12:48 <hugo__> hmm
10:12:49 <geezusfreeek> for each and every possible foreign key constraint...
10:12:50 <Lemmih> hugo__: What does 'cabal configure' say?
10:13:00 <hugo__> in the happs server ?
10:13:08 <Lemmih> hugo__: In happs-tutorial.
10:13:19 <geezusfreeek> dino-, yeah, it would be good for that
10:13:34 <hugo__> nothing at all
10:13:38 <geezusfreeek> i have though about trying out some revision control stuff with HAppS-State
10:13:42 <geezusfreeek> *thought
10:14:04 <dino-> Ignoring the downside of concurrent access to the data, it sounds sweet to dump the middleman and work directly with Haskell data types with persistence.
10:15:23 <kynky> use some locking ?
10:15:27 <dino-> Well, I don't know that there's a downside there either. Just imagining you would need to get something involved to share this across processes. Maybe one of the threading APIs.
10:16:40 * geezusfreeek wonders about implementing a relational database _on_ HAppS-State...
10:16:43 <dino-> kynky: ya
10:18:00 <dino-> geezusfreeek: Interesting thought, make data types at runtime or perhaps compile time based on create table SQL.
10:18:23 <Cale> It would be nice to see someone come up with something nicer than SQL.
10:18:38 <Vulpyne> Is there any way with GHC to make it generate a shared object that can be called by C, when the C code has no knowledge that it's loading a Haskell module?
10:18:42 <dino-> Cale: mmhmm
10:19:34 <Vulpyne> From what I've read, it seems like doing this would be extremely difficult. :(
10:19:37 <Cale> HaskellDB was definitely headed in that direction.
10:20:03 <Cale> Vulpyne: No, it's impossible. You have to initialise the Haskell runtime somewhere.
10:20:54 <Vulpyne> Cale: Would it be possible by always generating a C wrapper to do that? And linking the C with the haskell to make a shared object.
10:20:56 <Cale> Also, I'm not sure whether it's possible to create shared objects with GHC.
10:21:07 <Vulpyne> It seems to be.
10:21:53 <geezusfreeek> Vulpyne, sure, you could create a C wrapper and compile an object file from that, but it would just contain the haskell RTS within it
10:21:54 <Vulpyne> With the wrapper method, it seems like it would be hard to know when to call hs_exit (the docs say multiple calls to hs_init is okay though). But the hosting application could have more than one Haskell module loaded.
10:22:21 <geezusfreeek> and you could require that client code call and init and deinit function to use the object file
10:22:34 <Vulpyne> I really want to write a Haskell module for an application that I don't have any control over, and its plugin handling method is loading .so files.
10:22:36 <geezusfreeek> many other libraries already require that anyway, so it wouldn't be out of the ordinary
10:23:02 <geezusfreeek> Vulpyne, most programs that take plugins have init and deinit callbacks, don't they?
10:23:03 <Vulpyne> Yeah, there are init/deinit methods for it, but what if you have two Haskell modules loaded by it?
10:23:16 <Vulpyne> Would there be two runtimes existing concurrently?
10:23:24 <Cale> Vulpyne: I would hope so...
10:23:50 <Cale> Vulpyne: But if not, then that's rather hard.
10:23:54 <Vulpyne> Hmm, I guess that method may work.
10:24:30 <Vulpyne> It would seem weird and inefficient two have two runtimes doing stuff at the same time, each GCing their own sections, and whatever.
10:24:49 <Cale> The Haskell runtime would get statically linked with each of the .so's.
10:25:15 <Vulpyne> Well, you can make shared objects dynamically link to other shared objects.
10:25:25 <Vulpyne> And there's a shared version of the runtimes if I'm not mistaken.
10:25:48 <Cale> Yes, but as far as I know, GHC isn't capable of dynamic linking.
10:25:54 <Cale> oh?
10:26:29 <Cale> Such a thing did exist on Mac OS for a while, I'm not sure if it still does, or if it got implemented on other platforms.
10:26:31 <Vulpyne> Maybe it would be better to have one "haskell support" module and have that load haskell modules when told to, then multiple ones could share the same runtime.
10:26:35 <Vulpyne> "haskmodule.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (FreeBSD), not stripped"
10:26:41 <Vulpyne> From a haskell file compiled with ghc -shared.
10:26:54 <Vulpyne> So it created it, whether it will actually WORK, I do not know.
10:27:07 <Cale> uh... -shared ?
10:27:12 <Cale> Is that documented?
10:27:42 <Vulpyne> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker
10:27:43 <lambdabot> Title: 5.10.�Options related to a particular phase, http://tinyurl.com/smq5n
10:28:02 <Cale> Interesting...
10:28:15 <Cale> That must be new.
10:28:26 <Vulpyne> I know -static has been around for quite a while.
10:28:44 <Vulpyne> Actually, that's not the same thing. Nevermind.
10:28:51 <Vulpyne> static/dynamic, not static/shared.
10:29:11 <Vulpyne> A problem I see with making a haskell module handler module is the stub files.
10:29:24 <Vulpyne> The haskell module handler couldn't know in advance all the haskell modules it may be asked to load.
10:31:07 <Cale> I thought position independent code didn't work on anything but Mac OS X...
10:31:22 <Cale> But perhaps they fixed it.
10:31:23 <Vulpyne> Well, it may not work, but it compiled and created a .so :)
10:31:39 <Vulpyne> I have yet to actually load it and run it, because the other issues I'd face once I passed that stage occured to me.
10:33:03 <Vulpyne> Also, the ghc version I have is a very recent snapshot of 6.10... So maybe stuff recently got fixed there.
10:37:06 <dons> hudak's speaking at QCon today, about music iirc
10:37:09 <dons> or right now.
10:37:26 <dons> all over the tweets
10:40:35 <dino-> Hey, did everyone buy their rwh ebook? http://ui3.info/d/rwh/
10:40:36 <lambdabot> Title: Real World Haskell on Sony PRS-505 ebook reader
10:40:54 <profmakx> ha. i will have a seminar on dependent types next wednesday
10:41:00 <dons> thanks for the pictures dino- !
10:41:06 <dons> very very cool
10:41:31 <vixey> profmakx, cool why
10:41:32 <dino-> dons: I sent that url to your galois email, hope that was cool
10:41:50 <dons> yeah, i forward it to o'reilly, who got very excited
10:41:55 <dino-> For you, it's work related
10:42:23 <dons> anyone got rwh on an iphone?
10:42:29 <dino-> dons: O'R got excited? Huh, that's cool!
10:42:41 <dons> yeah, i think they might blog about the ebook versions now
10:42:45 <profmakx> vixey, because I asked the logic group here in st. andrews whether i may attend their seminars ;)
10:42:52 <profmakx> perhaps i will learn stuff properly now
10:43:56 <vixey> ooh
10:44:03 <vixey> st. andrews they do work on epigram don't they
10:45:02 <profmakx> i think so
10:45:11 <dino-> I can't believe they're selling the book this way, unencrypted ebook in several formats. Fantastic.
10:45:55 <profmakx> i am a phd in maths here and want to use functional programming for computational algebra, but i sneak into every piece of useful seminar i can get ;)
10:46:31 <dino-> I have to admit I had already long ago used pavuk to vacuum the rwh in-progress. Assuming it was going to be that or paper.
10:47:16 <kynky> thought the site was still up
10:47:41 <dino-> kynky: I'm sure it is, but I wasn't anticipating being given an actual correctly published ebook from O'R.
10:48:02 <Vulpyne> Oh noes: ./haskmodule.so: Undefined symbol "stg_CAF_BLACKHOLE_info" :( It almost sounds like it's purposefully trying to prevent what I'm doing.
10:48:06 <cnwdup> Are there alsa bindings for haskell or what should I use if I want to play music files using haskell?
10:48:43 <kynky> there is always hackage, and if not then ffi
10:49:28 <Cale> Lots of people have done sound stuff with Haskell, so I would be surprised if there wasn't something suitable already.
10:50:30 <cnwdup> Most of them appear to midi based which isn't suitable for the "play that mp3 file" task.
10:50:40 <Cale> geezusfreeek: Yeah, I think all you can do is to define separate tables for each combination of cases, and then define queries which join them.
10:50:56 <Cale> iirc, there are fairly complete SDL bindings...
10:51:01 <kynky> ffi with alsa libs ?
10:51:21 <Saizan_> cnwdup: there's gstreamer in gtk2hs, at least in the dev version
10:51:47 <cnwdup> kynky: So noone hasn't done this already?
10:52:02 <kynky> yeah , got the gtk darcs version working with ghc 6.10.1
10:52:17 <kynky> gtk2hs i mean
10:52:51 <kynky> cnwdup, no idea
10:52:59 <dons> ?users
10:52:59 <lambdabot> Maximum users seen in #haskell: 558, currently: 548 (98.2%), active: 11 (2.0%)
10:53:39 <Cale> If my connection didn't totally suck right now on account of running a torrent through this crappy linksys router, I would check hackage for you.
10:58:45 <geezusfreeek> Cale, yeah i think i'm going to have to resort to custom CHECKs rather than elegant design
10:59:16 <Cale> geezusfreeek: In some sense, the result of that query is the thing you want.
10:59:35 <Cale> geezusfreeek: Because each row in the result must have come from either one table or the other.
11:00:31 <geezusfreeek> Cale, yeah, but i don't want the NULLs :P i'll deal with it
11:01:33 <Cale> geezusfreeek: hmm, you could extend each table with a constant tag as you're taking the union, and join the tag fields.
11:02:20 <geezusfreeek> Cale, i'm not too worried about the querying. mostly the data integrity.
11:02:52 <geezusfreeek> i'll just use some CHECKs and TRIGGERs
11:02:53 <Cale> Well, data integrity would be enforced by the fact that you can't edit the results of the query directly.
11:03:18 <Cale> You always have to insert rows into one of the two tables which you're unioning.
11:03:29 <geezusfreeek> i have MANY tables, not just two
11:03:46 <geezusfreeek> each with different columns
11:04:26 <Cale> Right, so you'll end up with exactly one set of columns which is not NULL in the union, and this will correspond to which table it came from.
11:04:53 <Cale> (and you can make this data more available by adding a tag column)
11:05:06 <geezusfreeek> Cale, yeah. i believe no matter how i design the DB, this is how an appropriate query will return results
11:06:50 <Cale> It's really unfortunate...
11:11:08 <hackage> Uploaded to hackage: flickr 0.3.0
11:41:03 <jberryman> not exactly Haskell-related, but I've never done any database programming, but wondered how I would go about storing a very large tree structure on disk. learn sql?
11:41:38 <geezusfreeek> jberryman, you could do that or look into B-trees or something
11:42:56 <geezusfreeek> SQL probably isn't so great for modeling trees anyway
11:43:29 <pumpkin> you can model it generally just representing the nodes
11:43:33 <jberryman> B-trees are what some filesystems use right?
11:43:37 <pumpkin> but then you need to manually query for every node in the tree
11:43:48 <pumpkin> otherwise, there's a range representation specifically for trees
11:43:59 <pumpkin> that allows you to query for subtrees in a single query, but it's a bit of a pain
11:44:57 <Twey> It's ugly
11:44:58 <Samy> jberryman, yes
11:45:14 <Samy> jberryman, if you want something simple to look, look at the Berkeley Database
11:47:27 <jberryman> Samy, I do. thanks for the advice.
11:55:16 <vixey> > 1+1
11:55:20 <lambdabot>   2
11:57:08 <BONUS> haha, the good old 2
11:58:56 <lispy> > let 1 + 1 = 7 in 1 + 1
11:58:57 <lambdabot>   7
11:59:02 <vixey> lies
11:59:25 <lispy> > let 1 + 1 = 7 in 1 + 1 + 8
11:59:26 <lambdabot>   * Exception: /tmp/6563630152877811442:71:60-68: Non-exhaustive patterns in ...
11:59:30 <lispy> doh!
12:00:02 <lispy> > let 1 + 1 = 3 in let f (n+1) = n in f 1
12:00:04 <lambdabot>   0
12:00:15 * lispy expected 2
12:00:25 <lispy> actually, wait
12:00:35 <lispy> what would I have expected
12:01:37 <lispy> stupid n+k patterns
12:01:51 <profmakx> that is disturbing
12:02:47 <lispy> profmakx: there is a classic thread in the haskell mailing list archives about this n+k madness...should it use Prelude.(+) or a local definition...
12:02:50 <profmakx> on the other hand... one you do by hand what the compiler should do it gets less disturbing
12:03:03 <profmakx> but more confusing
12:03:35 <lispy> and do n+k work if the type is Num and not Int or Integer?
12:04:03 <profmakx> yeah, I get the impression that things I took for granted for a long time are not so easily deduced that I might like
12:04:06 <profmakx> if at all
12:04:08 <lispy> > let f (n+1) = n in f g
12:04:09 <lambdabot>   Add a type signature
12:04:14 <lispy> > let f (n+1) = n in f g :: Expr
12:04:15 <lambdabot>   g - 1
12:04:21 <olsner> doesn't it like desugar into something like f n' | n' >= 1 = let n = n' - 1 in ...?
12:04:48 <olsner> maybe without the guard though
12:04:58 <lispy> yeah, let's test that
12:05:14 <lispy> > let f (n+1) = n in f (-5)
12:05:16 <lambdabot>   * Exception: /tmp/6157392081236715654:71:44-54: Non-exhaustive patterns in ...
12:05:23 <lispy> > let f (n+1) = n in f (5)
12:05:24 <lambdabot>   4
12:05:36 <lispy> so it needs Ord and Num
12:05:45 <lispy> :t (>=)
12:05:46 <lambdabot> forall a. (Ord a) => a -> a -> Bool
12:06:26 <olsner> > let f (n+1) = n in f True
12:06:27 <lambdabot>       No instance for (Integral Bool)
12:06:27 <lambdabot>        arising from a use of `f' at <in...
12:07:28 <olsner> > let f (n+3) = n in f (5)
12:07:30 <lambdabot>   2
12:07:38 <olsner> > let f (n+0) = n in f (5)
12:07:39 <lambdabot>   5
12:07:45 <olsner> > let f (n-7) = n in f (5)
12:07:46 <lambdabot>   <no location info>: Parse error in pattern
12:07:58 <olsner> > let f (n+(-7)) = n in f (5)
12:07:59 <lambdabot>   <no location info>: Parse error in pattern
12:08:35 <profmakx> so if it has Num
12:08:37 <Giraffe> hmm
12:08:39 <profmakx> why doesnt - work?
12:08:45 <profmakx> or am i being totally stupid?
12:09:12 <Giraffe> is it possible to make a data type that i can refer to in general and with respect to that type itself?
12:09:26 <Giraffe> i.e. an Animal is a Dog or a Cat, but i can still make Dogs and Cats
12:09:54 <idnar> @type let f (n+1) = n in f True
12:09:55 <lambdabot>     No instance for (Integral Bool)
12:09:56 <lambdabot>       arising from a use of `f' at <interactive>:1:19-24
12:09:56 <lambdabot>     Possible fix: add an instance declaration for (Integral Bool)
12:10:05 <idnar> @type let f (n+1) = n in f x
12:10:06 <lambdabot> Expr
12:10:11 <idnar> @type let f (n+1) = n in f x :: Expr
12:10:12 <lambdabot> Expr
12:10:35 <idnar> @type (-)
12:10:36 <lambdabot> forall a. (Num a) => a -> a -> a
12:11:10 <olsner> profmakx: because it's a special-case convenience syntax for "+ k", where k is a non-negative constant
12:11:17 <idnar> why does it want Integral?
12:11:52 <profmakx> ah ok, so its just for providing convenience in formulating certain recursions
12:12:22 <idnar> @type let f (n+1) = n in f
12:12:23 <lambdabot> forall t. (Integral t) => t -> t
12:12:44 <olsner> yep, that's it... I just don't think it's used a lot...
12:12:52 <camior> Giraffe: Could you elaborate on that?
12:13:05 <Giraffe> camior, i'll give you the specific issue
12:13:30 <Giraffe> i have a structure in which i want to store database command information
12:13:59 <Giraffe> actually, you know what, i should probably do it with algebraic data types and pattern matching
12:14:31 <lispy> Giraffe: That's pretty much what I say everyday when I get out of bed.
12:14:32 <skorpan> is there any emacs functionality for sorting haskell functions alphabetically?
12:15:11 <lispy> skorpan: you want to go something like M-x sort-declarations-region ?
12:15:21 <lispy> skorpan: and have it organize the region?
12:16:16 <skorpan> lispy: never heard of that, maybe that's it!
12:16:32 * lispy just made that up to illustrate an example :)
12:16:37 <skorpan> okay, i don't seem to have that function using haskell and haskell-ind
12:16:42 <skorpan> oh, right :)
12:16:47 <skorpan> yes, that is indeed what i want
12:17:03 <skorpan> i'd write one myself, but i'm not keen on reinventing the wheel
12:17:19 <skorpan> especially not since i'd invent an oval shaped one
12:17:45 <lispy> skorpan: well...my first thought is that I'm not sure I'd trust the haskell-mode to parse out the individual functions correctly given how poorly it handles things like indentation :)
12:18:07 <skorpan> someone should write a new haskell mode... a simpler one.
12:18:15 <skorpan> haskell-ind takes 2000 LOCs or so iirc
12:18:31 <lispy> in my experience elisp  is surprisingly verbose
12:18:45 <skorpan> i know, but at least it has nice functions such as map etc.
12:18:53 <lispy> skorpan: well...there is yi, a haskell based editor that can emulate emacs
12:19:04 <skorpan> i know
12:19:16 <skorpan> i (kind of) know jean-philippe personally
12:19:18 <lispy> and I started working on a elisp compiler that I meant to some day use with yi
12:19:24 <lispy> oh cool
12:19:51 <skorpan> he's been a course assitant in a bunch of courses that i've taken
12:19:58 <skorpan> among them, "advanced functional programming"
12:20:00 <lispy> I started going over board though...and adding things like tail call ...
12:20:08 <skorpan> ulf norell (agda author) was the examinator (is that a word?)
12:20:21 <lispy> examinator is not a word :)
12:20:25 <skorpan> examinor?
12:20:26 <lispy> proctor?
12:20:29 <skorpan> M-x ispell RET
12:20:40 <lispy> examinor, yeah that makes more sense
12:20:43 <Botje> grand inquisitor of the lambda revolution?
12:20:46 <skorpan> "examiner" ispell tells me
12:21:04 <lispy> I'll take "examiner" for $300, Alex
12:21:09 <skorpan> :)
12:21:30 <lispy> "In skorpan's class, this role was filled by Ulf Norell"
12:21:45 <lispy> "Who was the examiner?"
12:21:53 <skorpan> lol
12:26:08 <olsner> skorpan: 'examinator' is swedish :P
12:26:23 <skorpan> olsner: yup, i tried some swenglish there :)
12:26:34 <lispy> examinator is what we would call the Arnold if he was giving a test
12:26:46 <lispy> "the Arnold"
12:26:50 <lispy> lol, I can't type
12:27:07 <skorpan> lol
12:27:11 <olsner> works better if you capitalize it like The Arnold
12:27:15 <skorpan> i think arnold deserves "the" as a title
12:27:45 <lispy> I can has embarrassing typo?
12:27:57 <skorpan> learn you a haskell mate
12:28:06 <skorpan> are nested guards disallowed in haskell?
12:28:13 <lispy> example?
12:28:14 <Deewiant> yes
12:28:34 <skorpan> f x | x < 0 = ..
12:28:34 <skorpan>     | otherwise | ...
12:28:36 <Deewiant> a paper, IIRC the pattern bindings one, mentioned them briefly
12:28:39 <Deewiant> er
12:28:43 <Deewiant> pattern guards one*
12:28:53 <Deewiant> but they've not been implemented anywhere I know of.
12:29:04 <lispy> skorpan: well, in that particular case you wouldn't need the | after otherwise
12:29:39 <lispy> > let f x | x < 0 = x | x > 0 = 10 | otherwise = 0 in f 12
12:29:40 <lambdabot>   10
12:29:58 <Deewiant> I've missed them once or twice, when having to duplicate a final fall-through case to a nested case statement
12:30:19 <lispy> ?src otherwise
12:30:20 <lambdabot> otherwise = True
12:30:26 <skorpan> lispy: well suppose i had f :: Int -> Int -> Int
12:30:32 <skorpan> i.e. i had other arguments to check
12:30:44 <skorpan> oh, wait
12:30:46 <skorpan> i'm an idiot.
12:30:53 <lispy> > if otherwise then otherwise else otherwise
12:30:55 <skorpan> i don't need them, you're correct
12:30:55 <lambdabot>   True
12:31:49 <lispy> does the prelude have other named constants?
12:31:52 <lispy> besides otherwise?
12:32:12 <skorpan> it's not a keyword?
12:32:13 <lispy> :t tell
12:32:14 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
12:32:51 <lispy> :t let me = const in tell (me otherwise)
12:32:52 <lambdabot> forall b (m :: * -> *). (MonadWriter (b -> Bool) m) => m ()
12:33:36 <Cale> :t otherwise
12:33:36 <lambdabot> Bool
12:33:43 <Twey> @src on
12:33:43 <lambdabot> (*) `on` f = \x y -> f x * f y
12:33:45 <Deewiant> Something like (nonsense function, just an example) "f x y | x < 0 = (case () of _ | y > 0 -> Just (LT,GT) | y < 0 -> Just (LT,LT) | otherwise -> Nothing) | x > 0 = Just (GT,EQ) | otherwise = Nothing" is along the lines of what I was thinking of: note the identical 'otherwises'
12:34:33 <lispy> :t unless
12:34:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:34:42 <dino-> > show otherwise
12:34:43 <lambdabot>   "True"
12:34:48 <lispy> > unless otherwise (Just 1)
12:34:49 <lambdabot>       No instance for (Num ())
12:34:49 <lambdabot>        arising from the literal `1' at <intera...
12:34:58 <lispy> > unless otherwise (Just ())
12:34:59 <lambdabot>   Just ()
12:35:03 <Cale> lispy: Well, depending on what you consider a constant.
12:35:18 <Cale> There are polymorphic constants, pi, minBound, and maxBound
12:35:35 <lispy> I like "unless otherwse"
12:35:39 <lispy> :t unless otherwise
12:35:40 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> m ()
12:35:53 <lispy> :t until
12:35:54 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
12:36:24 <Twey> @pl \g f x y -> f x `g` f y
12:36:25 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:36:49 <Twey> Oh dear oh dear :-P
12:37:17 <lispy> > unless otherwise main
12:37:18 <lambdabot>   Not in scope: `main'
12:37:23 <Cale> I think the condition passed to until should take two parameters...
12:37:26 <lispy> > Main.main
12:37:27 <lambdabot>       Failed to load interface for `Main':
12:37:27 <lambdabot>        Use -v to see a list of the...
12:37:56 <lispy> :t foldl iterate
12:37:57 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[a]'
12:37:57 <lambdabot>     Probable cause: `iterate' is applied to too many arguments
12:37:57 <lambdabot>     In the first argument of `foldl', namely `iterate'
12:38:16 <Cale> > unless otherwise (return ())
12:38:17 <lambdabot>       No instance for (Show (m ()))
12:38:17 <lambdabot>        arising from a use of `show' at <i...
12:40:22 <lispy> > if otherwise then unless otherwise (return ()) else return ()
12:40:23 <lambdabot>       No instance for (Show (m ()))
12:40:23 <lambdabot>        arising from a use of `show' at <i...
12:57:45 <orgthingy> Hello!!
12:57:49 <orgthingy> does haskell pay bills?
12:58:01 <orgthingy> any job offers for haskell programming language?
12:58:14 <Ferdirand> @faq Does haskell pay bills ?
12:58:15 <lambdabot> The answer is: Yes! Haskell can do that.
12:58:18 <Lemmih> orgthingy: There are a few.
12:59:03 <skorpan> is there any "lazy" way to check that the length of a list is less than a given integer?
12:59:13 <skorpan> i mean a built-in function
12:59:33 <vixey> skorpan, convert the Integer into Natural
12:59:40 <vixey> then you can use <
12:59:41 <geezusfreeek> Cale, just for the record, i've settled on a foo table that has a tag column and id column. the tag contains the name of a table, and the id contains the id of a row in the referenced table. the tag itself references into a table where each row is the name of a table for which this is intended (it may be extended later, so an enum type is not ideal). there are CHECK contraints that verify that the tags are valid tables with id columns and that the
12:59:41 <geezusfreeek> re is a row in the appropriate table corresponding to the calue in the id column
12:59:42 <BONUS_> \xs n -> length xs < n
12:59:50 <skorpan> BONUS_: not lazy
12:59:56 <vixey> skorpan, yes it is
12:59:58 <BONUS_> sure it's lazy
12:59:59 <skorpan> is it?
13:00:01 <BONUS_> yeah
13:00:02 <vixey> :t fromIntegral :: Integer -> Natural
13:00:03 <lambdabot> Integer -> Natural
13:00:06 <vixey> so try
13:00:07 <skorpan> i tried that on an infinite list, didn't terminate
13:00:17 <vixey> > length [1..] < (1000 :: Natural)
13:00:18 <lambdabot>   Couldn't match expected type `Int' against inferred type `Natural'
13:00:20 <vixey> :/
13:00:27 <vixey> > fromIntegral (length [1..]) < (1000 :: Natural)
13:00:28 <BONUS_> oh you mean like that
13:00:42 <lambdabot>   mueval: Prelude.read: no parse
13:00:43 <BONUS_> it is essentially lazy but not in the way you want yes
13:00:46 <skorpan> i'm using Int, not Integer by the way
13:00:49 <Cale> > not . null . drop 1000 $ [1..]
13:00:54 <lambdabot>   True
13:00:55 <vixey> turn the Int into a Natural then .......
13:01:07 <Cale> > not . null . drop 1000 $ [1..500]
13:01:09 <lambdabot>   False
13:01:12 <vixey> > genericLength [1..] < (1000 :: Natural)
13:01:13 <lambdabot>   False
13:01:24 <vixey> > genericLength [1..100] > infinity
13:01:25 <lambdabot>   False
13:01:30 <skorpan> where is Natural defined? in Prelude?
13:01:46 <Cale> I believe it's part of the numbers package...
13:01:58 <skorpan> i'm not too keen on using custom packages for this
13:02:12 <BONUS_> that method with drop is pretty cool yeah
13:02:20 <Cale> Then just use my way :)
13:02:22 <skorpan> not very intuitive though... oh well, i'll just use that.
13:02:34 <BONUS_> you could also write your own recursive function
13:03:00 <ikegami__> I'm looking the new monadic parser library 'parsec3' http://code.haskell.org/parsec3/
13:03:01 <lambdabot> Title: Index of /parsec3
13:03:25 <skorpan> BONUS_: that was what i was considering initially
13:03:26 <ikegami__> Simple question: When do we need the monad translater? (or a monad?)
13:03:43 <vixey> skorpan, ???
13:03:48 <skorpan> vixey: what?
13:03:53 <ikegami__> I'm quite satisfied the original parsec (not parsec3)
13:03:55 <BONUS_> let lessElemsThan n [] = True; lessElemsThan n (x:xs) = lessElemsThan (n-1) xs
13:04:01 <BONUS_> won't work for negative ns
13:04:08 <BONUS_> also havent tested this :]
13:04:09 <vixey> skorpan, "'m not too keen on using custom packages for this" it's like 2 lines of code
13:04:17 <vixey> :t (>)
13:04:17 <ikegami__> and can't imagine how to use monad in parsec
13:04:20 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:04:26 <vixey> data N = Zero | Succ N
13:04:30 <vixey> instance Ord N where
13:04:30 <ikegami__> perhaps for errors?
13:04:35 <skorpan> vixey: doesn't matter, this is just for school
13:04:38 <Cale> ikegami__: Parsec is itself a monad, so the monad combinators apply to it.
13:04:43 <skorpan> (this is *not* part of the assignment though)
13:04:47 <vixey> skorpan, You don't understand what I 'am saying
13:05:08 <skorpan> vixey: oh, i get what you're saying now
13:05:26 <ikegami__> Cale: ah, yes; you are definitely right
13:05:38 <Cale> ikegami__: If p is a parser, and f is a function from results of p to parsers, then p >>= f is a parser which parses the initial part of the input with p, then applies f to the result of that to give the parser which parses the rest.
13:06:11 <Cale> ikegami__: return x is the parser which always succeeds without eating any characters, and returns x as the result.
13:06:49 <ikegami__> ok
13:07:32 <Cale> So, do x; y; z  is effectively the concatenation of parsers x, y, and z
13:07:50 <skorpan> question: http://hpaste.org/12257
13:07:55 <BONUS_> only you throw away the results of x and y
13:07:57 <Cale> (sequence generalises that pattern to lists of parsers)
13:08:08 <Cale> BONUS_: right.
13:08:31 <ikegami__> Then, we can concatenate several different parsers, for example
13:08:37 <ikegami__> interesting
13:08:44 <BONUS_> skorpan: your len is just like the length in the standard library
13:08:59 <BONUS_> only the standard library length does _:xs
13:09:02 <skorpan> BONUS_: so why isn't this lazy?
13:09:20 <Cale> skorpan: What do you mean by lazy here?
13:09:30 <skorpan> Cale: why doesn't 3 < len [1..] terminate?
13:09:31 <BONUS_> yeah i think you're confusing the terms a bit
13:09:34 <Cale> skorpan: len is strict, it pattern matches the list.
13:10:03 <ikegami__> Thanks to Cale, I'm going to plan to make monadic transformer interface for Packrat Parser
13:10:04 <Cale> skorpan: But whether it'll necessarily pattern match the entire list depends on the type of number.
13:10:05 <Deewiant> > 3 < (genericLength [1..] :: Natural)
13:10:06 <lambdabot>   True
13:10:14 <BONUS> for instance
13:10:15 <skorpan> @src genericLength
13:10:15 <BONUS> say you do
13:10:15 <lambdabot> genericLength []    = 0
13:10:16 <lambdabot> genericLength (_:l) = 1 + genericLength l
13:10:17 <pumpkin> is do just syntactic sugar for big lines of >> ?
13:10:22 <Cale> pumpkin: and >>=
13:10:23 <largos> does anyone happen to know if the current darcs version of cabal-install compiles? (I'm running into a compile error, but it may be system-specific)
13:10:24 <BONUS> print 3 < length [1...]
13:10:25 <ikegami__> which can parse left recursive rule
13:10:30 <skorpan> what is it with Natural!?
13:10:33 <largos> http://hpaste.org/12259
13:10:35 <Cale> pumpkin: which handles the case where you have something like v <- x
13:10:36 <BONUS> the expression (3 < length [1..]) is lazy
13:10:41 <BONUS> but because you want to print its result
13:10:44 <Cale> skorpan: Natural is a lazy natural type.
13:10:44 <BONUS> it has to be evaluated
13:10:45 <pumpkin> Cale: oh yeah, forgot about that
13:10:58 <Lemmih> largos: Update your cabal.
13:11:05 <BONUS> and for that to be evaluated, you have to evaluate the (<) function
13:11:08 <hackage> Uploaded to hackage: haskell-src-exts 0.4.3.1
13:11:15 <largos> Lemmih: ah, thanks!
13:11:15 <BONUS> which has to evaluate both its parameters to see which is bigger
13:11:23 <Cale> skorpan: See, for Integer,  1 + (...)  can't be pattern matched without evaluating the (...)
13:11:23 <BONUS> so then 3 is evaluated eazily
13:11:38 <BONUS> but when you force evaluation on length [1..], it naturally hangs
13:11:58 <BONUS> because you know something that the compiler doesnt
13:12:12 <BONUS> you know that you're only interested if the length is more than 3
13:12:29 <BONUS> but the compiler doesnt really *know* that, so it tries to get the whole length before comparing it
13:12:38 <Cale> Also, there's the issue that Integers can be negative.
13:12:44 <skorpan> so basically creating a lazy length function for Integers is impossible in haskell?
13:12:50 <skorpan> Cale: they can't?
13:13:02 <Cale> So you always have to evaluate an entire Integer sum to decide if it's greater than a given value.
13:13:09 <Deewiant> Integers are strict: you either have a value or don't.
13:13:10 <BONUS> but if you express it with the drop method or directly with a recursive function that checks explicitly if a list is longer than some x
13:13:32 <Cale> Just looking at an expression like 1 + (...) :: Integer, even if the Integer type had a lazy representation, you can't tell that's positive. (...) might evaluate to -2
13:13:33 <BONUS> its lazy in that it will be evaluated only when it needs to
13:13:40 <byorgey> skorpan: it's possible with a lazy natural number type, but not with Integer.
13:13:44 <skorpan> okay, i'll try to convince myself on the way home. i have to go now, thanks for your help!
13:13:50 <BONUS> take care
13:15:00 <Cale> ikegami__: Applicative notation is also nice.
13:15:28 <Cale> ikegami__: and if you define the monadic combinators, you might as well go ahead and define an instance of Applicative and Functor as well.
13:15:50 <BONUS> also Alternative
13:16:00 <Cale> Yeah, for parsers especially :)
13:17:02 <Cale> ikegami__: I should warn you though, that monadically constructed parsers can never handle left-recursion properly. But you might already have functions for composing left-recursive parsers that work out.
13:17:22 <BONUS> haha in my data structures class yesterday the prof wrote the Java code for parsing an arithmetic expression. he used up like two chalks.
13:17:31 <Cale> haha
13:17:37 <BONUS> and all the time i had a stupid smirk on my face from knowing how little haskell would be needed for that
13:17:59 <BONUS> even if you didnt use parsec but wrote your own little parsing monad with a StateT or whatever
13:18:49 <Cale> A parser for things is a function from strings to lists of pairs of strings and things.
13:18:55 <BONUS> haha
13:18:59 <BONUS> that's from hutton's book
13:19:00 <BONUS> isnt it
13:19:02 <Botje> BONUS: you should've snuck to the front and written the parsec code next to it
13:19:08 <BONUS> hahaha
13:19:16 <Cale> I don't know, I remember seeing a little comic with that at some point.
13:19:28 <BONUS> thats also in hutton's book yeah
13:19:32 <Botje> "who wrote this abstract grammar on the board!" "it's executable code!"
13:19:41 <BONUS> haha
13:20:41 <BONUS> also interesting anectode: part of an assignment was to implement some algoritm recursively and iteratively. so i ask the assistant prof "what if we're using a language that doesn't support iteration?"
13:20:55 <BONUS> and he actually said: "i can't believe such a language exists"
13:20:59 <pumpkin> :o
13:21:02 <pumpkin> fail prof
13:21:07 <BONUS> and i was like: forget it, i'll do it in python
13:21:21 <Botje> ouch ..
13:21:30 <gwern> couldn't've you done it in the state monad...
13:21:31 <Botje> BONUS: can't you point to LYAH and get exemptions from classes?
13:21:32 <Cale> Haskell supports iteration...
13:21:50 <Cale> via recursion.
13:21:59 <BONUS> well classes aren't mandatory, just the assignments
13:22:06 <BONUS> so thats cool i guess :]
13:22:08 <BONUS> Cale: yeah
13:22:34 <Cale> Hehe, implement a for-loop, and then use that ;)
13:22:43 <BONUS> haha
13:22:52 <BONUS> a forM in State or something like that
13:22:55 <monadwr> BONUS: Does your teacher know your book?
13:22:59 <BONUS> nah
13:23:04 <BONUS> dont think anyone at my uni does
13:24:00 <BONUS> i write it for myself and the knowledge-hungry newbies anyway :)
13:24:24 <Cale> Your prof sounds like he could use your book ;)
13:24:29 <BONUS> hahaha
13:24:46 <BONUS> in a kind of roadblock right now cause i'm writing about I/O and it's the part i kind of find the least interesting
13:24:58 <BONUS> especially since i'm not explaining about monads, just I/O with the monads hidden
13:25:08 <monadwr> http://failblog.files.wordpress.com/2008/11/fail-owned-locked-door-security-fail.jpg
13:25:10 <lambdabot> http://tinyurl.com/6gfc2o
13:25:54 <Botje> BONUS: i'd be willing to review that chapter :p
13:26:02 <Botje> think others would be too
13:26:11 <BONUS> yeah, that would be great actually
13:26:56 <BONUS> because i'm not so enthusiastic about I/O i'm going to approach explaining that with more care
13:27:39 <Vulpyne> cale: I almost got the loading an arbitrary haskell shared module into C thing working! But it crashes in allocateLocal. :(
13:27:52 <BONUS> but i think it's still gonna be good. i find it important to explain what I/O actions actually are, instead of letting the reader think it's just special syntax for imperative programming
13:28:06 <monadwr> BONUS: Why don't you write about IO + monads
13:28:25 <BONUS> i.e. that putStr isnt a function that takes a string and prints it, but a function from strings to I/O actions
13:28:29 <Cale> Well, the fact that IO is a monad is sort of inessential.
13:28:35 <BONUS> monadwr: hmm, i'll probably do IO + monads later
13:28:42 <BONUS> in the monads chapter
13:28:44 <Cale> But the fact that IO actions are values is.
13:28:47 <BONUS> cause it might be too confusing for starters
13:29:06 <Cale> (and that evaluation doesn't cause them to execute)
13:29:37 <BONUS> yeah, lots of people think that because they are performed when they're a result of an expression in GHCI
13:30:39 * Badger pings Twey horrifically.
13:30:41 <Peaker> BONUS: I find the Subtext 1 view of what IO is pretty interesting
13:31:10 <Peaker> BONUS: he shows them in a GUI as functions from RealWorld -> (RealWorld, a), where you can "expand" the result RealWorld, and see hypothetical futures
13:31:13 <Cale> I found actually using Subtext to be a rather painfully slow way to program.
13:31:28 <Peaker> Cale: I didn't manage to actually use it, and from his presentations, I figure the UI is horrible :)
13:31:40 <Peaker> Cale: but the ideas are extremely interesting..
13:31:45 <BONUS> yeah
13:31:52 <Cale> It sounds like a good idea, but when you actually try it, it's less impressive.
13:31:57 <Botje> is subtext that cool boolean expression builder thing?
13:32:05 <Cale> Botje: That's the second one.
13:32:12 <Peaker> Cale: Well, the devil is in the details. He seems to have gone for a mouse-based UI, for example, which is a shame
13:32:42 <Peaker> Cale: Me and a couple of friends wrote, in order to prove a point, a prototype of a non-textual editor in C that approximates much of the look&feel of a text editor
13:33:08 <Peaker> Cale: But since it has the AST available at all times, its easier to implement advanced features in the editor. It was in Python, though, and we found out we were re-inventing Haskell as a DSL on top of Python, so we dropped that to learn Haskell :)
13:33:23 <Peaker> s/in C/of C
13:33:55 <Peaker> so it looks like a syntax-highlighted text editor, but you navigate between AST entities, rather than text characters
13:34:13 <Cale> Well, that's a decent idea. I've wanted to have something like that for a while.
13:34:14 <Peaker> and you edit a name of a variable, not a piece of text - so all of the named references are updated accordingly
13:34:31 <SamB> Peaker: and it doesn't crash as much as TeXmacs, I guess ;-P
13:34:53 <Peaker> SamB: we dumped it pretty early when we realized we were reinventing functional programming over Python
13:34:58 <Peaker> SamB: so it doesn't do that much ;)
13:35:19 <SamB> oh you mean you haven't gotten the haskell port off the ground yet ?
13:35:32 <Cale> I'm not entirely certain that updating all the variable names is really what you'd want as a default.
13:35:46 <Cale> What if you really wanted to change what it was that name pointed at?
13:35:49 <SamB> me either
13:35:55 <Cale> I think that's a more common edit than renaming everything.
13:35:55 <Peaker> Cale: you "enter" the variable with a key, then edit its name, alternatively, you can edit the link itself or hit a key to do that (then you get a search prompt for what other name to use)
13:36:17 <Peaker> Cale: deciding which UI action is cheaper is of course possible, even configurable
13:36:20 <Peaker> (in theory :-)
13:36:53 <Peaker> SamB: Well, we learned Haskell by now, for sure, but we haven't yet allocated time to implement it in Haskell, and we want to use FRP for it, and before we do, we want to toy with more basic FRP stuff
13:37:32 <shapr> @yow !
13:37:32 <lambdabot> YOW!!  Up ahead!  It's a DONUT HUT!!
13:37:33 <shapr> @users
13:37:33 <lambdabot> Maximum users seen in #haskell: 558, currently: 541 (97.0%), active: 23 (4.3%)
13:37:36 <shapr> Yay!
13:37:47 <Cale> Peaker: Have you ever used Mathematica?
13:37:52 <Peaker> Cale: nope
13:38:22 <Peaker> Cale: if every key on the keyboard is associated to a sensible operation on the AST, rather than mostly unsensible edits that form syntactic errors, I suspect editing efficiency will increase, not decrease
13:38:23 <Cale> You might look into getting access to a copy of Mathematica 6/7 and playing with its notebook interface.
13:38:52 <Cale> (seeing as you're interested in programming UIs)
13:39:03 <Deewiant> Not 5?
13:39:07 <Peaker> Cale: note made
13:39:12 <Cale> 5 wasn't nearly as cool.
13:40:09 <Cale> 6+ have some really cool FRP-like ways to design GUIs.
13:40:17 <Cale> In place, in the code. :)
13:40:45 <Deewiant> I haven't really used it for GUIs, I mostly use it for maths ;-)
13:41:05 <BONUS> this is why mathematica 7 is cool: http://www.wolfram.com/products/mathematica/newin7/content/BuiltInImageProcessing/ApplyImageProcessingToArbitraryMathematicaExpressions.html
13:41:11 <lambdabot> Title: Apply Image Processing to Arbitrary Mathematica Expressions, http://tinyurl.com/6pnh5f
13:41:34 <Cale> Deewiant: Well, you can design nice GUIs for exploring mathematical ideas.
13:41:49 <Deewiant> Yes, of course.
13:42:44 <Cale> Manipulate[ContourPlot3D[a x^2 + b y^2 + c z^2 + d x^2 y + e y^2 z + f z^2 x + g x^3 + h y^3 + i z^3 == 1, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, Mesh -> None, ContourStyle -> Directive[Opacity[0.8]]], {{a, 1}, -2,
13:42:45 <Cale>    2}, {{b, 1}, -2, 2}, {{c, 1}, -2, 2}, {{d, 0}, -2, 2}, {{e, 0}, -2, 2}, {{f, 0}, -2, 2}, {{g, 0}, -2, 2}, {{h, 0}, -2, 2}, {{i, 0}, -2, 2}, ControlPlacement -> Right]
13:42:53 <Cale> (try that out :)
13:43:56 <Deewiant> N/A in my 5.2
13:44:04 <Cale> (It creates a nice dynamic 3D plot of the solutions to that cubic equation, with the parameters controlled by sliders)
13:47:22 <Cale> http://cale.yi.org/share/Screenshot-DynamicPolynomial3D.png -- looks like this
13:47:35 <Cale> Manipulate is not primitive though.
13:47:36 <Deewiant> Cute :-)
13:48:16 <opqdonut> ah, mathematica
13:48:23 <Cale> It's written in terms of Dynamic, and Slider (as well as a bunch of other controls)
13:48:59 <Cale> Dynamic[expr] represents an object that displays as the dynamically updated current value of expr.
13:49:50 <Cale> So if the value of expr changes, the frontend updates all the Dynamic objects so as to display the current value.
13:51:02 <Cale> Slider[x, {xmin, xmax}] (among other variants) displays as a slider control with bounds xmin and xmax, which updates the definition of x as it is moved.
13:51:16 <dons> interesting
13:54:32 <Cale> Oh, I should also point out that values wrapped in Dynamic normally allow you to edit them as well, in any way that they provide for, which causes the value to be updated.
13:54:50 <dons> dcoutts_: benefit of our ghc + hackage/platform apporach.
13:54:53 <dons> "I use REE with all my sites but there's still a big problem. Matz' official VM gets released without any concern for whether or not Rails runs under it."
13:55:02 <dons> while we try to make sure everything runs
13:56:28 <dons> ?users
13:56:28 <lambdabot> Maximum users seen in #haskell: 558, currently: 544 (97.5%), active: 20 (3.7%)
13:56:37 <jpcooper> is the technical term for existential type, existential type?
13:56:44 <dons> yes :)
13:56:58 <jpcooper> I wonder if SpringerLink will have any papers on them
13:57:00 <jpcooper> whether*
13:57:08 <dons> there's a few famous ones from the 80s
14:01:18 <mlesniak> out of curiosity: how does lambdabot define an active user?
14:01:46 <Botje> probably "talked within X minutes"
14:02:02 <kaol> @losers
14:02:02 <lambdabot> Maximum users seen in #haskell: 558, currently: 545 (97.7%), active: 19 (3.5%)
14:05:55 <BONUS> haha
14:07:17 <yuuki_> Does anyone know whether or not one-combinator calculi like iota can construct a combinator with type a -> a ?
14:08:26 <Cale> Um I don't know about iota specifically, but I don't see why it should be impossible.
14:09:11 <Cale> What's the definition of iota?
14:09:20 <yuuki> iota is xSK
14:09:51 <yuuki> let s x y z = x z ( y z ); k x y = x in \ x -> x s k
14:09:55 <pejo> Suppose i install a postInst hook in Setup.lhs. I then do "let dirs = absoluteInstallDirs pkg_descr lbi NoCopyDest", and get a "internal error InstallDirs.libsubdir". Hm?
14:09:58 <yuuki> that will give you the type of iota
14:10:23 <olsner> hmm, if your one-combinator calculus is complete, it can construct any lambda expression
14:10:55 <yuuki> olsner, I think it can construct any lambda expression, but not necessarily with the proper types
14:11:50 <opqdonut> :t let s x y z = x z ( y z ); k x y = x; i x = x s k in i i
14:11:51 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
14:11:51 <lambdabot>     Probable cause: `i' is applied to too many arguments
14:11:51 <lambdabot>     In the first argument of `i', namely `i'
14:12:00 <opqdonut> ii should be I
14:12:01 <Cale> :t let s x y z = x z ( y z ); k x y = x; i x = x s k in i k k k
14:12:02 <lambdabot> forall t. t -> t
14:12:12 <opqdonut> :)
14:12:19 <tromp> \x.x K S K works well too
14:12:31 <yuuki> for instance, I can be defined as either SKK or SKS, but the type of SKK is p -> p and the type of SKS is (p -> q -> r) -> (p -> q -> r)
14:13:11 <yuuki> whoa.  How'd you do that, Cale? :p
14:13:18 <Cale> yuuki: Experimentation.
14:13:28 <yuuki> Cale, oh I see, you used k and not just i
14:13:42 <Cale> Yeah, applying i to itself gives something ill-typed.
14:14:00 <olsner> @ty id const const const
14:14:01 <lambdabot> forall a b. a -> b -> a
14:14:47 <Cale> yuuki: (As does any self-application)
14:15:07 <yuuki> Cale, hmm
14:15:25 <yuuki> It seems to me therefore that a typed single-combinator calculus cannot be complete
14:15:50 <Cale> A typed single-combinator calculus has at most one element.
14:16:07 <Cale> (okay, exactly one ;)
14:16:13 <opqdonut> :)
14:16:18 <olsner> @ty (\x -> x ap const) const const const
14:16:19 <lambdabot> forall a. a -> a
14:16:33 <zeta-> Hi I'm trying to get gtk2hs-0.9.13 installed on ghc-6.10.1, but I get an error when make gets to Glib.o -- should I go back to 6.8.2?
14:16:55 <Cale> Er, actually...
14:16:59 <olsner> @ty const ap const const const
14:17:00 <lambdabot> forall b. b -> b
14:17:10 <Cale> Well, with polymorphism, you can do some clever things.
14:17:10 <yuuki> Where are you guys getting ap?  I'm in hugs98 right now
14:17:17 <Cale> yuuki: ap = S
14:17:24 <Cale> yuuki: It's in Control.Monad
14:17:29 <yuuki> Thanks
14:17:33 <Cale> (you'll also want Control.Monad.Instances)
14:17:35 <olsner> yuuki: control.monad and control.monad.instances for the function-monad instance iirc
14:17:50 <Cale> :t const
14:17:50 <lambdabot> forall a b. a -> b -> a
14:17:52 <Cale> :t const const
14:17:53 <lambdabot> forall a b b1. b1 -> a -> b -> a
14:17:58 <Cale> :t const (const const)
14:17:59 <lambdabot> forall a b b1 b2. b2 -> b1 -> a -> b -> a
14:18:13 <opqdonut> yeah, the const-calculus has more than one element
14:18:14 <Cale> So there you have an infinite one, but you need polytypes.
14:18:23 <tromp> :t ap const undef
14:18:23 <opqdonut> as does the fmap one
14:18:24 <lambdabot> Not in scope: `undef'
14:18:28 <tromp> :t ap const undefined
14:18:29 <lambdabot> forall a. a -> a
14:18:36 <opqdonut> :t fmap fmap fmap `fmap` fmap fmap
14:18:37 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) a1 b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> a1 -> b) -> f (f1 a) -> f (f1 (f2 a1 -> f2 b))
14:19:12 <Cale> With fmap, it's even less clear that those are all the 'same'.
14:19:19 <opqdonut> true, that
14:19:21 <opqdonut> :t (.) (.) (.) . (.) (.)
14:19:22 <opqdonut> there
14:19:22 <lambdabot> forall a a1 b c a2 a3. (a3 -> b -> c) -> (a -> a1 -> a3) -> a -> a1 -> (a2 -> b) -> a2 -> c
14:19:32 <Cale> Yes, that's better :)
14:19:36 <opqdonut> tit-calculus
14:19:58 <yuuki> Cale, you mean polymorphic types?
14:20:02 <Cale> yuuki: yeah
14:20:02 <olsner> how far can you get with only the boobies-combinator?
14:20:10 <Cale> Function composition?
14:20:26 <olsner> or (.).(.)
14:20:37 <Plouj> @pl func5 f l = foldr (\x y -> f (y,x)) 0 l
14:20:37 <lambdabot> func5 = flip foldr 0 . (. flip (,)) . (.)
14:20:46 <yuuki> Hmm... so it seems SK calculus is much better than iota
14:21:05 <Cale> I'm reasonably sure you can't get id from that one.
14:21:27 <Cale> (from just combinations of composition)
14:21:50 <Cale> But I'd be happy to see it if you can.
14:21:55 <olsner> @ty let b = (.).(.) in b b
14:21:56 <lambdabot> forall b c a a1 a2 a3. (a2 -> a3 -> b -> c) -> a2 -> a3 -> (a -> a1 -> b) -> a -> a1 -> c
14:22:03 <yuuki> well, iota iota is id
14:22:09 <yuuki> Just not with the right type
14:22:17 <FalconNL> Does anyone happen to know if there's a version of QuickCheck 2.x that builds on ghc 6.10?
14:22:58 <olsner> Cale: yeah, I think it's probably impossible... how would you go about proving that it is impossible though?
14:23:14 <Cale> olsner: Possibly some invariant on the structure of the type.
14:24:21 <Cale> FalconNL: Does 2.1.0.1 not build?
14:24:42 <Cale> FalconNL: I just did  cabal install QuickCheck-2.1.0.1  successfully.
14:25:00 <FalconNL> Cale: neither according to hackagedb nor my own testing. I'm doing it manually though
14:25:18 <Cale> FalconNL: Use cabal install, it's more fun :)
14:25:29 <Cale> What error message are you getting, anyway?
14:25:56 <FalconNL> one sec, I'll recreate them. As for cabal: does it work correctly on Windows?
14:27:28 <FalconNL> Cale: http://hpaste.org/12264
14:27:50 <Cale> FalconNL: It ought to.
14:31:53 <gwern> FalconNL: I hear cabal works well on windows
14:31:58 <gwern> compared to all the alternatives anyway
14:32:38 <FalconNL> I just installed the cabal package, but now I'm trying to figure out how to actually use it
14:33:04 <ddarius> Cabal is a library
14:33:33 <yuuki> whoa!  I found a one-combinator basis for typed lambda
14:34:16 <yuuki> I don't know who originally discovered it.  It's Xx = xKSK
14:34:47 <yuuki> :t let s x y z = x z ( y z ); k x y = x; h x = x k s k in h ( h h )
14:34:48 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
14:34:49 <mlesniak> Is vim a good haskell editor for linux or are there other, non-obvious, alternatives?
14:35:03 <mlesniak> (Don't want to start an editor-flamewar!)
14:35:04 <yuuki> :t let s x y z = x z ( y z ); k x y = x; h x = x k s k in h h h
14:35:05 <lambdabot> forall t t1. t -> t1 -> t
14:35:09 <ddarius> yuuki: That's not technically a combinator
14:35:13 <Cale> mlesniak: Anything which can convert tabs to spaces.
14:35:20 <mlesniak> Cale, Ok, Thanks
14:35:32 <yuuki> Why is it not a combinator?
14:35:32 <mlesniak> Cale, then sed is a good editor ;)
14:35:42 <opqdonut> ?src reverse
14:35:43 <lambdabot> reverse = foldl (flip (:)) []
14:35:46 <Asgaroth> mlesniak: You might try yi, which is written and extensible in haskell.
14:35:49 <Cale> mlesniak: (and make sure you turn that option on -- in vim, it's set expandtab
14:35:53 <opqdonut> heh, is that the report definition?
14:36:04 <Asgaroth> mlesniak: And emacs i probably one of your "obvious alternatives".
14:36:06 <Cale> Yeah, yi is *nearly* usable.
14:36:06 <mlesniak> Asgaroth, will take a look, thanks
14:36:20 <Asgaroth> *is
14:36:27 <mlesniak> Cale, what's your definition of nearly?
14:36:52 <Cale> mlesniak: Well, it would be usable for editing Haskell code, but it's a little tricky to set up.
14:37:00 <yuuki> ddarius, what is the definition of combinator that you're using?
14:37:08 <dolio> yuuki: h has free variables.
14:37:12 <Cale> And it tries to do some things to make editing Haskell code with layout easier, but it currently does it poorly.
14:37:25 <mlesniak> Ok, so I'll stick with vim
14:37:40 <yuuki> dolio, are you sure?  Where are the free variables?
14:37:44 <Cale> emacs is also decent.
14:37:47 <dolio> k and s.
14:38:11 <yuuki> Hmm, but k and s are just defined that way for simplicity.  They could all be put in the same definition
14:38:37 <dolio> Well, I assume that's what ddarius is talking about, since that's technically the definition of a combinator.
14:39:41 <alsonk> anyone wanna donate some advice on how to avoid recursive imports?
14:40:08 <dolio> Can you express it in the form of 'x <arg list> = <some string of said args>'? That might disqualify it, too, I suppose. I'm not sure.
14:40:42 <Twey> alsonk: Don't put functions that depend on one another in separate modules :-P
14:40:47 <alsonk> ;)
14:40:48 * Lemmih grins.
14:40:52 <dolio> Since right now it's 'x (\a b -> a) (\f g x -> f x (g x)) (\a b -> a)' in a sense.
14:41:20 <alsonk> Twey: yeah, the issue is more how do I structure my code to avoid it...
14:41:23 <Lemmih> alsonk: I'm sure we can help you with specific problems.
14:42:10 <Cale> Haskell is supposed to support mutually recursive modules, but GHC fails to implement it correctly.
14:42:34 <alsonk> here's the issue - I've got an Environment type which holds a bunch of other types [say, a Thing].  Environment holds Thing, but Thing needs to be able to interact with Environment.
14:43:13 <alsonk> I've got a bunch of different types that I'm holding in the Environment, too.
14:43:25 <alsonk> Currently, I'm using Dynamics but I feel all slimey
14:43:34 <Lemmih> alsonk: It's common to put types in a separate module.
14:43:58 <alsonk> wait... that seems really obvious...
14:44:02 <alsonk> cripes
14:44:17 <alsonk> don't tell me that I've been wrestling with smoke...
14:44:54 <alsonk> I never even considered not representing my types in a hierarchy of files.
14:45:10 <dolio> :t let s x y z = x z ( y z ); k x y = x; h x = x k s k in h
14:45:11 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. ((t -> t1 -> t) -> ((t2 -> t3 -> t4) -> (t2 -> t3) -> t2 -> t4) -> (t5 -> t6 -> t5) -> t7) -> t7
14:45:52 <shapr> Anybody know someplace where I can ask newbie questions about IBM BladeCenters and get clueful answers?
14:46:06 <dolio> @djinn ((t -> t1 -> t) -> ((t2 -> t3 -> t4) -> (t2 -> t3) -> t2 -> t4) -> (t5 -> t6 -> t5) -> t7) -> t7
14:46:06 <lambdabot> f a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
14:46:52 <yuuki> dolio, so it is a combinator apparently :)
14:47:17 <dolio> yuuki: It looks like either you have to have s and k defined already to put it in 'h <args> = <string of applications>' in which case you have 3 combinators. :)
14:48:44 <alsonk> Lemmih: thanks for the tip.  Seems like a pretty clear solution.  One that I've seen used plenty, but never really grokked.
14:49:14 <dolio> (I guess my previous complaint about "free variables" was wrong, since wikipedia says you can use previously defined combinators.)
14:49:31 <ddarius> dolio: Combinators are constants.
14:49:49 <opqdonut> there's no real consensus on what a combinator is
14:50:29 <ddarius> opqdonut: There are a few technical notions of combinator with formal definitions.
14:50:33 <opqdonut> but a pretty common one is that C x0..xn = <permutation of xi>
14:50:47 <opqdonut> ddarius: yeah
14:50:55 <ddarius> opqdonut: It certainly doesn't have to be a permutation.
14:51:03 <ddarius> S wouldn't even qualify under that definition.
14:51:06 <opqdonut> yeah sorry
14:51:09 <opqdonut> not a proper permutation
14:51:10 <ddarius> Or K for that matter.
14:51:19 <opqdonut> but something containing xi and applications
14:51:52 <testingaaa> hello
14:51:58 <testingaaa> Is anyone willing to help me out with my website?
14:52:05 <testingaaa> For some reason my video is not loading
14:52:05 <testingaaa> www.lendlot.com
14:52:14 <testingaaa> nothing is loading
14:52:18 <testingaaa> at least in that frame
14:52:33 <Lemmih> testingaaa: Doesn't sound very Haskell related.
14:52:39 <testingaaa> lol
14:52:42 <yuuki> I hope your website is written in Haskell :)
14:52:51 <testingaaa> I know an Eddie Haskell...
14:53:05 <testingaaa> but that was probably before programmiong
14:53:17 <olsner> I'd say a combinator can even be defined as C x0..xn = any lambda expression without free variables
14:53:40 <testingaaa> How can anyone actually enjoy programminG?
14:53:52 <yuuki> olsner, wouldn't Xx = xKSK be a combinator in that case?
14:53:53 <testingaaa> since it can be outsourced for 2$ an hour
14:53:59 <opqdonut> yuuki: yeah
14:54:11 <opqdonut> testingaaa: depends on the type of programming ;)
14:54:17 <Lemmih> @where ops
14:54:17 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:54:23 <opqdonut> sure, anyone can crank out JAVA SOA B2B ENTERPRISE applications
14:54:25 <glguy> ?
14:54:27 <opqdonut> once the architecture is set
14:54:28 <sjanssen> Lemmih: you rang?
14:54:30 --- mode: ChanServ set +o glguy
14:54:34 --- mode: glguy set +b %testingaaa!*@*
14:54:36 <opqdonut> but a compiler, for instance, takes somewhat more
14:54:57 <opqdonut> :)
14:55:26 <glguy> sjanssen, if you aren't identified, you'll have a hard time racing me for the ops ;)
14:56:08 <Botje> i'm amazed #haskell gets trolled less often than, say, #perl
14:56:21 <olsner> you are?
14:56:37 --- mode: glguy set -o glguy
14:56:48 <olsner> I've always mostly equated coding perl and trolling
14:56:57 <opqdonut> :D
14:57:06 <opqdonut> ?remember olsner I've always mostly equated coding perl and trolling
14:57:07 <lambdabot> It is forever etched in my memory.
14:57:11 <allbery_b> how many people even know about #haskell (or for that matter Haskell)?  perl is far more visible
14:57:31 * dolio always chooses his hobbies by how well they pay.
14:57:35 <yuuki> I'm surprised the haskell channel is this big
14:57:36 <Botje> #haskell has almost as many people in it
14:57:44 <shapr> yuuki: Big but FRIENDLY!
14:57:52 <ddarius> yuuki: Incidentally, Rosser invented that combinator.
14:57:53 <Botje> and i think trolls don't quite care about the topic
14:58:02 <yuuki> ddarius, thanks!
14:58:05 <shapr> dolio: haha
14:58:08 <Botje> perhaps our friendly community scares away trolls :)
14:58:13 <yuuki> Yes, people are always willing to talk about combinators with me in here :)
14:58:21 <shapr> Botje: Nah, our friendly community squishes trolls with great justice.
14:58:34 <Botje> or that :p
14:59:15 <yuuki> Is there a way to get the type checker to reveal its series of inferences?
14:59:19 <ddarius> yuuki: You would probably find this paper interesting: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.5163 (and it's where I got that piece of information)
14:59:25 <lambdabot> Title: The systematic construction of a one-combinator basis for Lambdaterms,” Formal ...
15:00:25 <olsner> ddarius: hmm, I thought fokker invented the X combinator? or did they both call theirs 'X'?
15:01:36 <olsner> bah, that paper compares five different combinators calling them all X
15:01:39 <yuuki> Thank you, ddarius
15:02:53 <olsner> @ty \f -> f ap (\x y z -> x)
15:02:54 <lambdabot> forall (m :: * -> *) a b t t1 t2 t3. (Monad m) => ((m (a -> b) -> m a -> m b) -> (t -> t1 -> t2 -> t) -> t3) -> t3
15:05:21 <yuuki> So I wonder if the type of X can be used to prove the type of S, K, and I
15:06:34 <olsner> if you express S, K and I as combinations of X, shouldn't that be pretty trivial?
15:08:14 <olsner> otoh, I know next to nothing about combining combinatory logic and typed lambda calculus
15:10:14 <BONUS> how many monads do you guys think there are that aren't specialized versions of the existing standard monads (state, writer, reader, error, etc.)
15:10:22 <yuuki> olsner, I think you might have to already have K's type as a theorem in order to derive it from X's type
15:10:23 <BONUS> or their transformer versions
15:11:05 <ddarius> BONUS: Most of them are combinations, not specializations.
15:11:24 <ddarius> However, I think there are aleph_naught of them.
15:11:34 <BONUS> yeah, that's a better way to put it
15:13:32 <olsner> might it be possible to derive a limited set of monad transformers that can be used to express an isomorphic monad for any monad expressible in haskell?
15:15:10 <BONUS> that would certainly be something, hmm
15:16:15 <olsner> essentially you need to be able to encode any possible haskell data type and any possible implementation of the Monad class functions in the monad type
15:18:15 <BMeph> olsner: If there is a way, I'd hate to use continuation transformers for it - that just sounds...messy. :/
15:19:11 <pumpkin_> is there a list of typical haskell conventions anywhere? file naming, function naming (case and such), indentation and so on?
15:19:25 <dolio> Every monad is just a specialization of the capabilities of IO. :)
15:20:01 <ddarius> dolio: If that's true, it true in a rather roundabout way.
15:20:06 <dolio> (Technically, I guess IO doesn't do continuations, so you need those wrapped on top of it.)
15:20:18 <olsner> BMeph: if you don't have continuation transformers in the base, you'd still have to have enough stuff in the base to build continuations transformers from
15:20:32 <ddarius> dolio: IO may be able to do continuations.
15:20:47 <Cale> dolio: Nondeterminism?
15:21:01 <Cale> I want to see the list monad in IO.
15:21:06 <Cale> ;)
15:21:23 <dolio> ddarius: I suppose it can, since Oleg told me once that SPJ/Danvy/Etc.'s could be implemented with ST.
15:21:39 <dolio> Their delimited continuation monad, that is.
15:21:45 <ddarius> dolio: Not by itself.
15:22:07 <olsner> @src IO
15:22:07 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:22:32 <ddarius> dolio: If IO can do it, it is due to it's threading capabilities.
15:22:57 <dolio> Anyhow, worst case, you could implement native continuations and throw them into IO.
15:23:07 <dolio> Cale: And continuations get you the list monad, essentially.
15:23:07 <olsner> there's nothing that keeps the runtime system from adding to the IO monad with e.g. continuations and nondeterminism, right?
15:24:09 <Apocalisp> What do you call a type with a zero and cons?
15:24:10 <olsner> (except, maybe, having only one actual RealWorld to play with, but that's just a practical problem :P)
15:24:10 <vixey> you can already do those though? what would you add
15:24:20 <ddarius> dolio: Of course, that doesn't quite answer BONUS's question.  The embedding of another monad into the delimited continuation monad, uses the operations of the embedded monad.
15:24:20 <vixey> Apocalisp, a list
15:24:30 <vixey> Apocalisp, or R* if you like
15:24:43 <Apocalisp> R*?
15:24:59 <vixey> yeah "R* is the new [a]"
15:25:03 <vixey> :)
15:25:06 <Apocalisp> hah
15:25:20 <dolio> ddarius: Sure.
15:26:03 <olsner> where does "R*" come from?
15:26:05 <ddarius> Apocalisp: Define what you mean by "zero" and "cons"?
15:26:40 <olsner> "a sequence of 0 or more real numbers"?
15:27:57 <Apocalisp> maybe if I modify the question. What do you call an algebra FA->A that consists of (() -> A) and ((E, A) -> A)?
15:28:22 <olsner> abstract nonsense? :P
15:28:23 <Apocalisp> looking for googlable terms :)
15:28:32 <pumpkin> is there anything beyond http://www.mail-archive.com/haskell@haskell.org/msg03989.html and its replies that covers typical haskell conventions?
15:28:37 <lambdabot> Title: Haskell conventions (was: RE: how to write a simple cat)
15:28:44 <Cale> Apocalisp: E is a monoid?
15:28:47 <BMeph> Cale: How is the list monad different from the sequence monad? :)
15:28:48 <Cale> Apocalisp: er...
15:28:57 <Cale> BMeph: Sequence monad?
15:28:57 <Apocalisp> for all E, I think
15:29:23 <BMeph> Cale: Er, sure. :)
15:29:43 <ddarius> Apocalisp: Look up initial algebras.
15:30:07 <ddarius> Beyond that, that's just an arbitrary List algebra.
15:30:26 <Apocalisp> alright then. Thanks for that rivet.
15:30:49 <Cale> Apocalisp: er, right. So this is a functor something like: data F a = Unit a | Tagged E a
15:30:57 <FalconNL> Hmm... is QuickCheck 2.1.0.1 supposed to be several orders of magnitude slower than version 1.2.0.0 or am I doing something wrong?
15:31:17 <Apocalisp> Cale: Yes, like that.
15:31:33 <ddarius> F should be 1+ExA not A+ExA
15:31:54 <Cale> ddarius: Not by his description, should it?
15:32:30 <dons> FalconNL: no idea.
15:32:36 <ddarius> Hom(1+ExA, A) ~ (Hom(1,A), Hom(ExA,A))
15:35:12 <FalconNL> http://hpaste.org/12266. The 1.2.0.0 checks 100.000 cases in around 6 seconds. the 2.1.0.1 version takes 9 seconds just to get up to 10.000 cases.
15:35:49 <jeffwheeler> Does HOC support 6.10?
15:36:19 <jeffwheeler> I'm having trouble compiling it on my machine.
15:37:16 <Phyx-> hi, i was wondering if anyone knows how to fix the "OK, so we have *56* packages total that no longer compile with GHC 6.10, but
15:37:21 <Phyx-> oops
15:37:43 <Phyx-> hi, i was wondering if anyone knows how to fix the arrow related problems ghc 6.10 brought
15:38:19 <Phyx-> more specifically, i'm getting "`>>>' is not a (visible) method of class `Arrow'"
15:40:55 <tomh> phyx- i got that arrow too
15:41:08 <tomh> *error
15:41:13 <tomh> my teacher fixed it
15:41:31 <Phyx-> do you know how?
15:41:37 <tomh> if i recall correctly there is an alias method for it
15:41:42 <hcube> hi!
15:42:27 <tomh> but he hacked his own sourcecode to use that instead of >>>
15:42:45 <hcube> does anybody know or use Conal Elliott's reactive library ?
15:43:23 <dons> yes and yes.
15:43:35 <hcube> is there a good tutorial or documentation for frp or afrp ?
15:43:47 <dons> mm. on the wiki I guess.
15:43:55 <dons> haskell.org , look for the Reactive page
15:44:23 <hcube> there is a small (and unfinished) tutorial about reactive
15:44:51 <orbitz> i don't think the intro to Deep Impact is accurate
15:45:40 <BMeph> Phyx-: Can't you just import C.Category directly, and solve that? :)
15:46:51 <hcube> i know haskell and monads and arrows and i've written an hopengl based program, but i've never written a reactive program. the first what i'd like to do is a bouncing ball, but i dont know how to start
15:46:57 <Phyx-> BMeph: uh.. what's C.Category?
15:47:01 <hcube> *where
15:47:24 <Phyx-> i'm giving this a try atm. http://www.haskell.org/haskellwiki/Upgrading_packages#Arrow_instances
15:47:26 <lambdabot> Title: Upgrading packages - HaskellWiki, http://tinyurl.com/34xdwl
15:48:39 <BMeph> Phyx-: Sorry, Control.Category, from which Control.Arrow now derives.
15:49:00 <Phyx-> nah, i still get the same errors
15:49:24 <Phyx-> i also have another one to solve since pure was removed from Arrow it seems
15:50:36 <tomh> there is an alias method for it
15:50:56 <pumpkin> is there anywhere explaining how fgl works? the docs on the site are 8 years old, but the package itself seems actively maintained, and the stuff in the docs no longer seems to apply
15:50:57 <yuuki> Is there a good source to learn about the features of the haskell type checker?
15:52:07 <pumpkin> ah, I guess I can see some examples in the source
15:52:22 <BMeph> Phyx-: Right, I just looked at the Control.Arrow docs, which says that (>>>) and (<<<) are both exported. That is a puzzler, then. :(
15:52:38 <Phyx-> are the docs new?
15:53:09 <Phyx-> the upgrade wiki says
15:53:11 <Phyx-> The relevant change is essentially that Arrow became a subclass of Category. To be exact:
15:53:14 <Phyx-> (.) is a new function, in Category. (>>>) was removed from Arrow and made a function.
15:53:22 <Phyx-> so i'll try and do that
15:53:26 <orbitz> is there a version of unwords that takes a seperator?
15:54:24 <FalconNL> orbitz: don't think so, but concat . intersperse separator should work
15:55:03 <Phyx-> ok, solved one
15:55:14 <Phyx-> BMeph: >>> was indeed moved to category
15:55:20 <orbitz> FalconNL: tahnks
15:55:32 <Phyx-> now i need to figure out what happened/replaced pure
15:56:43 <British0zzy> why are side effects bad? is it to do with code reuse? code generation? type-system would freak out otherwise?
15:57:07 <orbitz> British0zzy: understanding the program
15:58:12 <olsner> side effects are for data what unrestricted, randomized goto's sprinkled all over your program would do for control flow
15:58:18 <British0zzy> wouldn't you admit that in certain situations side effects can make the program easier to understand?
15:58:30 <orbitz> British0zzy: such as?
15:59:10 <orbitz> British0zzy: just to be clear, haskell provides a way of distinctly knowing which peices of code cause side effects and which do not
16:00:26 <British0zzy> certain situations can be improved with dynamic scope
16:00:38 <British0zzy> or 'aspect oriented' programming
16:00:51 * Twey laughs.
16:01:04 <flux> well, there are certain things that can be difficult to achieve with purity, such as memoization
16:01:14 <flux> but.. aspect oriented programming.. well..
16:01:14 <Twey> AOP can be accomplished in any of several different ways, none of which involve dynamic scope.
16:01:16 <orbitz> British0zzy: do you have an example?
16:02:15 <olsner> flux: the thing about memoization though is that it actually has a pure interface if you pretend like the memoization cache doesn't exist
16:05:47 <pumpkin> is there any way to get @src-like behavior (from lambdabot) in ghci?
16:06:05 <orbitz> i'd imagine you could pull it out of lambdabot at worst case?
16:06:15 <British0zzy> well, i another language factor, you can change the way certain functions work by using dynamic scope
16:06:20 <British0zzy> ie http://pastebin.com/m5f3c63f1
16:06:26 <BMeph> pumpkin: Is ":i" not good enough for you? :)
16:06:38 <pumpkin> oh my!
16:06:40 <pumpkin> I had no idea :P
16:06:55 <pumpkin> oh wait
16:06:57 <pumpkin> it only shows types
16:07:03 <orbitz>  don't see any sorc in :i...
16:07:07 <British0zzy> the function 'with-file-reader' changes the readln functions to read ascii or utf8
16:07:08 <orbitz> am i not using it right?
16:07:22 <British0zzy> (the language is stack based)
16:07:56 <pumpkin> :list works with stuff I write
16:08:08 <pumpkin> but since I wrote it I don't really need to know
16:08:18 <dons> British0zzy: we use function composition to compose existing functions into new ones with new behaviour
16:08:25 <dons> its a different paradigm
16:09:18 <Cale> British0zzy: I fail to see how that's an example of using dynamic scope...
16:09:24 <Cale> British0zzy: (in the thing you pasted)
16:09:58 <dons> maybe you mean something by 'dynamic scope' that's different to what we're expecting?
16:10:17 <Phyx-> "pure is no longer a method of the Arrow class; use arr instead."
16:10:18 <dons> since that just looks like a higher order function to me.
16:10:20 <Phyx-> finally
16:10:21 <Phyx-> lol
16:10:29 <Phyx-> found it in the release notes
16:10:35 <dons> or even just function composition
16:11:08 <dons> readFile >>= toUTF8 . unzip  kind of thing
16:11:09 <British0zzy> the function 'with-file-reader' changes the value of a global to utf8 or ascii for everything within the [ ]
16:11:43 <dons> ok, but that's nothing too magic. we use higher order functions, or function composition, for that kind of use case all the time.
16:11:54 <British0zzy> right, that makes sense
16:12:10 <Cale> British0zzy: Instead of altering a global, you just have that be a function parameter ;)
16:12:14 <dons> all without sacrificing static analysis
16:12:25 <dons> or purity.
16:12:52 <sjanssen> British0zzy: is the global thread local?
16:13:24 <dons> if it really modifies a global (setting a new parser in motion), is that thread safe?
16:13:31 <dons> well, factor's not multithreaded
16:13:33 <dons> so probably not.
16:13:40 <sjanssen> really, no threads at all?
16:13:55 <dons> kind of hard to do parallelism with global state floating around.
16:14:01 <British0zzy> you can spawn some threads
16:14:11 <British0zzy> but no real support for threads
16:14:16 <procyon112> is there an easy way to clean a darcs repo? i.e., I want to remove all stray files that are not in the repo (temporary build files, emacs autosaves, etc.)
16:14:17 <sjanssen> British0zzy: so will with-file-reader in one thread change the encoding in other threads?
16:14:27 <British0zzy> probably not
16:14:42 <dons> sjanssen: i think it tweaks which encoding the readln block will use
16:14:47 <shapr> procyon112: Pull to another dir?
16:14:57 <sjanssen> procyon112: you could "darcs get" it, delete the old repo, then move the copy into place
16:15:06 <sjanssen> procyon112: note this will nuke any unrecorded changes you have
16:15:12 <shapr> right
16:15:20 <procyon112> shapr, sjanssen: hrmph.. I was afraid you would say that...
16:15:25 <dons> asking "is that weird trick threadsafe" shouldb e our first question these days :)
16:16:01 <sjanssen> British0zzy: to do something like that in Haskell, we'd use ReaderT, which is like a lexical scope Monad
16:17:23 <British0zzy> how does one reduce the number of arguments a function takes? couldn't you have functions with an unwieldy number of arguments?
16:17:40 <dons> ?
16:17:46 <dons> how many arguments to functions typically take?
16:17:48 <dons> 2 ? 3 ?
16:18:05 <orbitz> 23?
16:18:16 <dons> British0zzy: could you elaborate?
16:18:18 <sjanssen> functions take 1 argument, always. :)
16:18:23 <FalconNL> British0zzy: for functions with a lot of parameters it is common to use a data structure to hold them
16:18:40 <British0zzy> are there objects in haskell?
16:18:47 <dons> data structures
16:19:05 <sjanssen> @src Maybe
16:19:05 <lambdabot> data Maybe a = Nothing | Just a
16:19:08 <sjanssen> @src []
16:19:08 <lambdabot> data [] a = [] | a : [a]
16:19:14 * pumpkin wants @src in his ghci
16:19:15 <sjanssen> @src Either
16:19:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:19:16 * pumpkin throws a tantrum
16:19:20 <sjanssen> a few examples
16:19:23 <dons> so recursive, sum or product types. "algebraic data types"
16:19:26 <ddarius> pumpkin: You can use lambdabot from GHCi.
16:19:39 <pumpkin> :o
16:19:45 <dons> there's also generalised algebraic data types, which are a rather new development in programming language thoery
16:19:48 <FalconNL> British0zzy: As an example, QuickCheck uses the State data structure to hold 12 parameters: http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck-State.html#t%3AState
16:19:50 <lambdabot> Title: Test.QuickCheck.State, http://tinyurl.com/5rnocx
16:20:17 <pumpkin> dons: aren't those behind that voodoo for zipN I saw?
16:20:30 <dons> quite possibly, they're pretty powerful
16:20:46 * sjanssen doesn't see the appeal in zipN
16:20:54 <dons> isn't it just a toy?
16:21:05 <sjanssen> probably
16:21:20 <sjanssen> but I find the zipWith ($) approach much more satisfying
16:21:21 <pumpkin> it feels dirty to  stick how many arguments a function takes in the name :P
16:21:31 <pumpkin> to my untrained eye at least
16:21:59 <polveroj> the Applicative instance for ZipLists is also nice
16:22:36 <jpcooper> wouldn't ZipLists be a transpose function?
16:22:39 <sjanssen> > let zipping = repeat; (-|-) = zipWith ($) in zipping (,,) -|- [1 ..] -|- [1..] -|- [1..]
16:22:40 <lambdabot>   [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(1...
16:22:56 <dons> hah
16:23:02 <dons> -|- eh?
16:23:09 <sjanssen> probably not the best choice
16:23:53 <pumpkin> lol
16:23:54 <sjanssen> alternatively: pure (,,) <*> ZipList [1 ..] <*> ZipList [1 ..] <*> ZipList [1 ..]
16:24:12 <olsner> @ty zipWith id
16:24:13 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
16:24:17 <olsner> @ty ap
16:24:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:24:38 <Beelsebob_> you mean zipList [1..] <^(,,)^> zipList [1..] <*> zipList [1..]?
16:24:40 <sjanssen> olsner: (<*>) is most definitely not ap in this case -- ZipList is not a Monad
16:25:01 <sjanssen> Beelsebob_: eh, infix doesn't seem to help that at all
16:25:23 <sjanssen> I might use it for (,), but not for anything higher
16:25:26 <polveroj> well, it's sorta incidental that (<*>) and ap belong to different typeclasses
16:25:52 <polveroj> since all Monads are Applicative with (<*>) = ap
16:27:27 <polveroj> speaking of which, what exactly is the categorical justication for the Applicative laws?
16:27:39 <orbitz> @src words
16:27:40 <lambdabot> words s = case dropWhile isSpace s of
16:27:40 <lambdabot>     "" -> []
16:27:40 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:33:30 <kyagrd> Let me ask you some cabal questions.
16:33:39 <dons> no!!
16:33:43 <dons> oh, ok. proceed.
16:33:48 <Phyx-> lol
16:34:07 <kyagrd> Very simple one :) Do you know how .cabal/config works? I've failed to edit it, and manual says self explanatory.
16:34:20 <Phyx-> speaking of which
16:34:44 <Phyx-> why doesn't configure --prefix=<value> update the dataDirectory value to use that prefix?
16:34:54 <kyagrd> Say, I wanted to by default generate build reports .  I thought it would work if I just delete the -- haskell comment looking thing
16:34:56 <pumpkin> hmm
16:35:25 <pumpkin> when I try to install protocol buffers in cabal, it complains about Data.Generics being provided by base-3.0.3.0 and syb
16:36:15 <Lemmih> pumpkin: Sounds like it was expecting base-4.
16:36:24 <pumpkin> but I have base 4, I think
16:36:28 <pumpkin> ghc 6.10
16:36:37 <pumpkin> Glasgow Haskell Compiler, Version 6.10.1, for Haskell 98, stage 2 booted by GHC version 6.8.3
16:38:34 <kyagrd> Warning: Error parsing config file /home/kyagrd/.cabal/config:9: "True"
16:38:35 <kyagrd> Warning: Using default configuration.
16:38:35 <kyagrd>  
16:39:08 <kyagrd> I edited the .cabal/config file and had a line "build-reports: True" and I got that error msg
16:41:32 <gwern> sure you have the right version?
16:42:07 <byorgey> kyagrd: maybe try changing it to 'true' instead of 'True'?
16:42:13 <byorgey> sounds like a bug, whatever it is
16:42:27 <gwern> it shouldn't be true but True, I'm sure
16:42:39 <pumpkin> anyone else have an idea about my protocol-buffers issue?
16:43:04 <kyagrd> I tried that already, and many other words like 1 but all the same
16:43:22 <Phyx-> "warning: no newline at end of file"
16:43:24 <Phyx-> ehh wtf?
16:43:34 <kyagrd> I wonder how I can put my username and password into the config file when I get an Hackage account
16:45:07 <jeffz> Phyx-: it's customary for lines to end with a newline
16:45:13 <byorgey> hm, now where was that page on the wiki about migrating to GHC 6.10?
16:45:39 <byorgey> might come in handy for pumpkin
16:45:52 <byorgey> oops, pumpkin left
16:47:35 <Phyx-> jeffz: the lines in my programs almost never end with a newline on the last line and i've never gotten that warning before
16:47:53 <Phyx-> and before adding some pragmas i didn't have them now either
16:48:14 <gwern> kyagrd: I'm not sure you can use build-reports in a config
16:48:29 <gwern> I'm looking at the cabal-install sources and it doesn't seem to be anything but a CLI option
16:48:44 <Phyx-> but ok, it makes it happy
16:48:48 <Phyx-> so i won't complain
16:49:16 <kyagrd> Well it is commedted in the default config file, so I presumed It would work. Maybe an unimplemented fuature?
16:49:46 <explicitjelly> :bs
16:49:49 <explicitjelly> >bs
16:49:51 <jeffz> Phyx-: I'm not sure why it's a warning, but I've found that if you write a parser you find there to be a case where parsing lines and then parsing a line that ends at eof
16:49:53 <explicitjelly> ?bs
16:49:54 <lambdabot>  Done.
16:49:54 <gwern> @seen dcoutts_
16:49:55 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
16:49:59 <gwern> @seen dcoutts
16:49:59 <explicitjelly> "Done."?
16:49:59 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
16:50:31 <dcoutts> gwern: is it quick? I'm going to bed...
16:50:34 <gwern> hm. looks like Lemmih broke cabal-install
16:50:51 <gwern> dcoutts: scroll up. someone is confused that build-reports: True doesn't work in cabal/config. is this expected or a bug?
16:51:03 <gwern> also Lemmih broke cabal-install compilation for me :)
16:51:24 <Phyx-> jeffz: yeah, i know it makes sense for parsing. I think it's a warning because it's the last line
16:51:34 <dcoutts> Lemmih: what is this LHC ?
16:51:37 <gwern> dcoutts: 'Distribution/Client/Dependency.hs:46:27: Module `Distribution.Compiler' does not export `CompilerFlavor(LHC)'' <-- I blame Lemmih for this compile failure :)
16:51:42 <gwern> dcoutts: his fork of JHC
16:51:45 <Phyx-> i'm off to bed, thanks for all the help
16:51:55 <dcoutts> gwern: it does if you use the latest Cabal lib apparently
16:52:02 <dons> gwern: right.
16:52:09 <dcoutts> gwern: Lemmih added support for LHC in Cabal
16:52:26 * gwern groans. fine fine. maybe deps should've been bumped then...
16:52:32 <dcoutts> probably so
16:52:38 * dcoutts will do so later
16:52:49 <gwern> dcoutts: anyway, the build-reports option?
16:53:35 <dcoutts> gwern: I'm not sure
16:53:42 <dcoutts> gwern: please report it
16:54:02 <gwern> alright
16:54:28 <dcoutts> gwern: ta
16:54:33 <thoughtpolice> he mentioned something about that
16:54:33 <thoughtpolice> dcoutts: so i can get the darcs of cabal and cabal-install and use it?
16:54:51 <dcoutts> thoughtpolice: for LHC?
16:55:28 <thoughtpolice> dcoutts: ya
16:55:38 <dcoutts> thoughtpolice: I've not tried it, I only just pulled the patches, I'll review them tomorrow
16:55:47 <Lemmih> dcoutts: thoughtpolice Yes.
16:55:47 <thoughtpolice> dcoutts: k
16:56:22 <solrize> how much memory do i need to run fairly lightweight ghc-compiled applications?  i'm wondering if a g1 smartphone could be a ghc target
16:56:48 <thoughtpolice> you're going to need to port GHC
16:56:48 <dons> about 1M
16:57:18 <solrize> cool, that's fairly small
16:57:28 <dons> right.
16:57:39 <solrize> thoughtpolice i don't want to actually compile on the phone, i want to cross compile apps for the phone
16:57:45 <dons> my xmonad is using 2.7M
16:57:54 <solrize> you have xmonad on a g1??
16:58:00 <thoughtpolice> the problem is ghc isn't really a cross compiler
16:58:03 <dons> firefox is using 256M
16:58:07 <dons> solrize: no.
16:58:12 <solrize> ic
16:58:21 <thoughtpolice> for xmonad on the debian phone or whatever, i thought that someone used an unregisterd ghc build on that platform to create an xmonad binary?
16:58:42 <dons> on the debian phone, we just used ghc for the ar
16:58:43 <dons> arm
16:58:51 <dons> right
16:58:53 <thoughtpolice> i'm not entirely sure, but getting ghc to function reliably as a cross compiler is not possible as it stands.
16:58:59 <dons> right
16:59:05 <solrize> hmm
16:59:26 <thoughtpolice> plans are for the build system in ghc 6.12 to support porting again and if the backend works out, the compiler can end up as a cross compiler, yeah
16:59:37 <thoughtpolice> but right now you need at least an unregistered GHC on the phone to compile apps
16:59:41 <RayNbow> I need a sanity check... could anyone please tell me why I decided to include this in a TeX document? http://xs133.xs.to/xs133/08475/fibs2350.png
16:59:46 <solrize> ahh, maybe i'll sit back and wait for 6.12
17:01:07 <thoughtpolice> solrize: there was discussion for a while about ghc on the ARM (specifically phones iirc,) and there's a wiki page - http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc
17:01:09 <lambdabot> Title: ArmLinuxGhc - GHC - Trac
17:01:28 <solrize> raynbow i dunno, i don't find that diagram especially necessary for understanding that zip idiom
17:01:44 <solrize> that's jhc
17:01:46 <solrize> but interesting
17:02:12 <solrize> oh wait then it's hugs then i guess gcc
17:02:15 <solrize> what does unregistered mean?
17:02:30 <solrize> unregisterised i mean
17:02:42 <thoughtpolice> solrize: yeah, jhc (and now lhc?) are designed to be cross compilers by outputting ISO C
17:03:12 <solrize> ghc has -fvia-c
17:03:39 <solrize> but i think haskell is confusing enough without having to deal with 3 different dialects, so i want to stick with ghc, which has more interesting extensions
17:04:17 <thoughtpolice> solrize: jhc does work for h98, so if you want that then it's viable :]
17:04:47 <thoughtpolice> solrize: -fvia-C outputs C code that links to the RTS and whatnot, but all that code depends on platform-dependent stuff that you get when you configure, build and install it
17:05:01 <thoughtpolice> solrize: look here re: unregistered - http://hackage.haskell.org/trac/ghc/wiki/Building/Porting#PortingGHCtoanewplatform
17:05:03 <lambdabot> Title: Building/Porting - GHC - Trac, http://tinyurl.com/u77xk
17:05:05 <solrize> ic.
17:05:49 <RayNbow> solrize: but would it be a helpful diagram for less experienced Haskell readers?
17:06:24 <solrize> i think i was inexperienced (even more so than now) when i first encountered that.  the diagram is pretty good though, if you don't want to mess with a drawing program
17:08:30 <RayNbow> I don't really like drawing programs... they never do what I want them to do :p
17:09:12 <solrize> i forget the name of that old unix one that you just described the boxes you wanted and the arrows between them, and it ran a constraint solver to size and place everything
17:10:23 <thoughtpolice> Lemmih: using cabal install how can I build the base in lib/ for lhc? i tried putting a basic Setup.hs in there and cabal install but no avail, and lhc --build-hl=base.cabal fails
17:10:57 <Lemmih> thoughtpolice: No Setup.hs is needed. Just 'cabal install --lhc'.
17:11:09 <hackage> Uploaded to hackage: printxosd 0.1
17:11:11 <thoughtpolice> Lemmih: nothing happens :[
17:11:21 <Lemmih> thoughtpolice: Define nothing.
17:11:25 <orbitz> why is foo . bar not equal to foo bar ?
17:11:28 <solrize> i wonder if it's feasible to take some low-rent scheme interpreter, hack lazy evaluation into it, then take GHC Core and throw away all the type info and convert it to S-expressions and interpret it
17:11:33 <thoughtpolice> Lemmih: no output at all, $? is set to 1
17:12:02 <solrize> i guess there's the issue of dictionary passing polymorphism
17:12:06 <orbitz> ohh durh
17:12:06 <orbitz> i knwo why
17:12:52 <ddarius> orbitz: Because (.) isn't id
17:13:10 <Lemmih> thoughtpolice: This is what I see: http://hpaste.org/12267
17:13:17 <orbitz> ddarius: righ right
17:14:48 <thoughtpolice> Lemmih: http://hpaste.org/12267#a1
17:15:17 <Lemmih> thoughtpolice: Try with -v.
17:17:05 <thoughtpolice> Lemmih: http://hpaste.org/12267#a2
17:20:59 <thoughtpolice> Lemmih: bbl
17:24:29 <Lemmih> @tell thoughtpolice Patch pushed to Cabal.
17:24:29 <lambdabot> Consider it noted.
17:39:39 <dons> Cale: didn't  someone else do this, http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
17:39:42 <lambdabot> Title: Mathematics and Computation » A Haskell monad for infinite search in finite tim ..., http://tinyurl.com/5zjtz2
17:41:14 <Cale> dons: That same guy did related work.
17:42:37 <monadwr> dons: Nice link.
17:42:49 <monadwr> I should blog about haskell sometime.
17:43:57 <monadwr> Hm, pretty recent as well
17:47:12 <monadwr> Hm, why does ubuntu find it necessary to run outdated versions of ghc ...
17:47:47 <b\6> installed ghc 6.10.1, but lots of cabal stuff seems busted. array, for instance.
17:47:57 <gwern> monadwr: because the debian guys do
17:48:10 <Lemmih> b\6: Busted?
17:48:20 <b\6> Lemmih: like, cabal install fails.
17:48:56 <monadwr> gwern: I should go back to fbsd, but linux has better support for my laptop. Unless I feel fussed enough to write device drivers for all my unsupported hardware, I'm probably going to be equally frustrated with it
17:49:13 <monadwr> Then again, I haven't looked at the 7.* changelogs.
17:49:23 <Badger> monadwr: write them! :D
17:49:35 * Badger hopes monadwr has a broadcom card.
17:49:40 <monadwr> Badger: Might be a worthy task for haskell projects.
17:49:59 <Botje> mmm, haskell device driver
17:50:12 <Badger> o_O
17:51:07 <monadwr> monadwr@oven:~$ lspci | grep 802
17:51:08 <monadwr> 02:00.0 Network controller: Broadcom Corporation BCM4312 802.11b/g (rev 01)
17:51:16 <Badger> Perfect. :)
17:51:18 <b\6> maybe it's just a problem with haskore. looks as if haskore wants array-0.1.0.0, which i guess is pretty old.
17:51:25 <gwern> monadwr: it's just a lot of manpower
17:51:38 <yuuki> Hmm I think the haskell type checker is wrong:
17:51:38 <yuuki> :t let s x y z = x z ( y z ); k x y = x; h x = x k s k in h h
17:51:39 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
17:51:44 <yuuki> This should lead to an infinite type
17:52:09 <monadwr> Botje: I'm fairly new to haskell, are there a lot of kernel-land tasks in haskell that are commonplace?
17:53:14 <Botje> i was half-joking
17:53:17 <monadwr> I guess there may be a few.
17:53:30 <Botje> i don't think haskell is really feasible for serious device drivers
17:53:34 <Botje> unless you make everything strict
17:53:40 <Botje> at which point you might as well use ML
17:54:14 <Badger> monadwr: go on, write b43 for fbsd ;)
17:54:21 <monadwr> Afaik, there were some projects done with 'House', but I'm not so sure.
17:55:09 <monadwr> Badger: You're pretty funny.
17:55:25 <moonlite> @pl filter (\x -> and (map ($x) ps))
17:55:25 <lambdabot> filter (and . flip map ps . flip id)
17:55:48 <Badger> monadwr: you've crushed my hopes and dreams.
17:55:56 <monadwr> I hope so.
17:56:42 <gerryxiao> hello to all
17:57:06 <gerryxiao> i'm new to haskell, trying to understand Monad
17:57:11 <monadwr> Ubuntu is just pretty horrible.
17:57:16 <monadwr> gerryxiao: What confuses you?
17:57:26 <gerryxiao> reader monad
17:57:29 <dolio> Ubuntu is still on 6.8.2, eh?
17:57:40 <gerryxiao> yes
17:57:47 <monadwr> dolio: Yes.
17:58:01 <gerryxiao> why ubuntu is horrible?
17:58:18 <gwern> it's not ubuntu's fault
17:58:19 <monadwr> gerryxiao: Because it was built around usability, instead of functionality.
17:58:20 <dolio> That may be okay. 6.8.3 introduced a specialization bug which slowed down some code (for instance, stuff on the shootout).
17:58:26 <gwern> they just reuse debian's packages
17:58:33 <monadwr> What confuses you about reader monads?
17:58:35 <dolio> So sticking with 6.8.2 makes our shootout results on Ubuntu look better. :)
17:58:41 <Cale> gerryxiao: Its dev cycle is optimally misaligned with the GHC dev cycle.
17:58:47 <gerryxiao> monawr,  (Reader r) >>=f Reader $\e -> f ( r e ) e
17:59:22 <gerryxiao> this f (r  e) e , how to get  an 'a'?
17:59:30 <Saizan_> :t let s x y z = x z ( y z ); k x y = x; h x = x k s k in (\h -> h h) h
17:59:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:59:31 <lambdabot>     Probable cause: `h' is applied to too many arguments
17:59:31 <lambdabot>     In the expression: h h
17:59:45 <Botje> gerryxiao: the a is the result of executing f
17:59:47 <Cale> gerryxiao: Let's have a look at the "unwrapped" reader monad, which is functions from a fixed type e.
17:59:48 <Saizan_> yuuki: ^^^^
17:59:49 <Botje> if that's waht you're asking
18:00:15 <gerryxiao> Botje: but f only on arg not two
18:00:15 <yuuki> Saizan_, I see.  So simplification occurred before type inference?
18:00:24 <gerryxiao> s/on/one
18:00:28 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
18:00:28 <povman> i'm trying to make a C main which calls a haskell function, but i don't know what things to link in
18:00:29 <lambdabot>   ("hello","olleh","HELLO")
18:00:29 <dolio> (\h -> h h) doesn't have a non-infinite rank-1 type.
18:00:41 <povman> can anyone tell me?
18:00:43 <Cale> povman: Compile your C program with GHC.
18:00:51 <Saizan_> yuuki: the two h in your expression are instanced to different types
18:00:57 <Cale> povman: (It will run gcc appropriately)
18:01:01 <povman> ohh
18:01:06 <yuuki> Saizan_, that's okay, isn't it?
18:01:20 <yuuki> I don't want them to have to be the same type
18:01:23 <gerryxiao> f (r e)  sems is a reader monad, but the "e" at the tail do what?
18:01:37 <moonlite> @pl \xs -> any (head xs ==) ['0'..'9']
18:01:38 <lambdabot> flip any ['0'..'9'] . (==) . head
18:01:51 <gerryxiao> \e-> f (r e)  e
18:01:55 <Cale> gerryxiao: In this monad, the computations are just functions from the environment. "Running" such an action is just applying the function.
18:02:13 <yuuki> Saizan, it should still get an infinite type error if they are instanced to different types
18:02:29 <gerryxiao> Cale:  i know , but i can't figure out this compution
18:02:43 <Cale> gerryxiao: So what is (x >>= f) supposed to do? It's supposed to 'run' x, and then take the result of that, and apply f to it to get a new computation to run.
18:02:45 <yuuki> Saizan_, is there a way to see the "proof" or the steps that the type inferencer uses to arrive at the type conclusion?
18:03:02 <povman> Cale: The function `main' is not defined in module `Main'
18:03:14 <Saizan_> yuuki: sadly no
18:03:17 <povman> oh..
18:03:29 <gerryxiao> r  e => a ;   f a => Reader e b;  but f (r e) e =>?
18:03:37 <Cale> gerryxiao: So it will apply x to the environment, (x e), and then apply f, to get f (x e), and then run that f (x e) e
18:04:08 <Cale> >>= is kind of a hard operation to start with for the reader monad.
18:04:13 <gerryxiao> Cale, you can't call a reader Monad to a E
18:04:33 <Cale> gerryxiao: hm?
18:04:59 <gerryxiao>  f ( x e ) is a monad?
18:05:00 <Cale> gerryxiao: I'm ignoring the newtype wrapper here.
18:05:03 <Saizan_> yuuki: i don't see why you'd get an infinite type though
18:05:09 <Cale> No, it's a value, values are never monads.
18:05:14 <Cale> Monads are type constructors.
18:05:20 <povman> aha, got it
18:05:37 <Cale> But it's a computation in the reader monad, if you want.
18:05:39 <yuuki> Saizan_, well, I'm trying to derive the type by hand and I get contradictions
18:05:43 <gerryxiao> cale, it 's a monad value
18:05:59 <Saizan_> ?ty let s x y z = x z ( y z ); k x y = x; h x = x k s k in h
18:06:00 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. ((t -> t1 -> t) -> ((t2 -> t3 -> t4) -> (t2 -> t3) -> t2 -> t4) -> (t5 -> t6 -> t5) -> t7) -> t7
18:06:02 <Cale> Okay, let's start from the beginning here...
18:06:20 <dolio> That type's going to be a pain to work with.
18:06:25 <Cale> Maybe to deal with the noise, come to #haskell-overflow, so the definitions won't scroll away so quickly.
18:06:25 <gerryxiao> but it's not a function
18:06:27 <Saizan_> yeah.
18:06:33 <yuuki> Yes :)
18:06:43 <dolio> @type let s x y z = x z ( y z ); k x y = x; h x = x k s k in h h
18:06:44 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
18:07:05 <yuuki> Yes, that's what I get if I use hugs
18:07:12 <yuuki> But I don't think that it's correct
18:07:46 <Cale> gerryxiao: ?
18:08:03 <yuuki> If you try to fit h into the type of h's antecedent, then you get an infinite type
18:08:22 <gerryxiao> cale:  if  \e-> f (r e) e change to \e -> runReader ( f (r e) e, i will understand
18:08:45 <gerryxiao> cale:  if  \e-> f (r e) e change to \e -> runReader ( f (r e)) e, i will understand
18:08:50 <Cale> gerryxiao: okay, yeah, that's how the wrapped version will look, with an extra  Reader (...) wrapping the whole thing.
18:08:53 <Saizan_> yuuki: i think you're getting problems with capturing of variables
18:09:13 <yuuki> Saizan_, I'm not sure what that means :)
18:09:19 <Cale> gerryxiao: (->) e  is also a monad, and involves less wrapping and unwrapping.
18:09:53 <dolio> Did you start with one h with all the types like iN and the other with types like jN?
18:10:20 <gerryxiao> Cale:  it seems not concerned with wraping stuff
18:10:38 <gerryxiao> maybe syntax problem
18:10:42 <dolio> Because if I tried doing alpha conversion as I went, I'd expect to make mistakes.
18:10:53 <Cale> But yeah, if you want,  newtype Reader e a = Reader { runReader :: e -> a },  then you probably want something like  x >>= f = Reader (\e -> let v = runReader x e in runReader (f v) e)
18:11:09 <hackage> Uploaded to hackage: peano-inf 0.6.1
18:11:13 <yuuki> Yes, I started with the entire type of h
18:11:36 <Cale> Rather than  (x >>= f) e = f (x e) e
18:11:57 <gerryxiao> Cale, your code is  easy to understand :)
18:11:58 <Cale> (but it's the same thing, modulo the wrapping and unwrapping)
18:12:19 <dolio> I wonder if I still have a Hindley-Milner type inferencer around here. I could try getting that to dump out the unifications...
18:12:43 <BMeph> h h == h k s k == k k s k s k == k k s k == k k
18:12:49 <yuuki> That'd be awesome, I'm searching for one on the net
18:12:50 <gerryxiao> \e-> f (r e ) e   looks like function calling
18:13:13 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
18:13:15 <lambdabot>   ("hello","olleh","HELLO")
18:13:24 <yuuki> BMeph, yes, that's true
18:13:24 <TomMD> Ok, I've got to ask why LHC exists.  Why the fork?
18:13:25 <Cale> ^^ that's in the (->) e monad.
18:13:29 <Cale> LHC?
18:13:33 <Saizan_> BMeph: that doesn't mean it's welltyped :P but yeah the type inferred by hugs/ghci is consistent with that
18:13:34 <TomMD> @hackage lhc
18:13:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lhc
18:13:38 <yuuki> BMepth, the problem is the type
18:13:40 <gerryxiao> Cale:  where can i get wraping docs about this?
18:13:44 <TomMD> Seems to be a fork of yhc.
18:13:49 <TomMD> by none other than lemmih
18:13:54 <Saizan_> TomMD: cabalization
18:14:16 <TomMD> Is that it?  The dev notes imply he's been looking at the JHC code and perhaps fixing things?
18:14:23 <TomMD> s/yhc/jhc/  btw
18:14:48 <Cale> gerryxiao: hmm, I'm not sure. Docs about the wrapped Reader monad?
18:15:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
18:15:11 <lambdabot> Title: Control.Monad.Reader, http://tinyurl.com/ona24
18:15:24 <BMeph> yuuki: Okay, I'll bite - why is the type a problem? :)
18:15:26 <gerryxiao> (->) e
18:15:34 <Cale> Ah, well...
18:15:42 <Cale> The instance is in Control.Monad.Instances
18:15:50 <Cale> It's just:
18:15:50 <Lemmih> TomMD: I actively develop lhc.
18:15:53 <Saizan_> TomMD: the fork happened because the main author is against cabalization, i don't know what will happen in the future :)
18:15:56 <Cale> instance Monad ((->) e) where
18:16:00 <yuuki> BMeph, when I try to infer the type by hand I get an infinite type. I could just be making a mistake
18:16:02 <Cale>   return x e = x
18:16:03 <dolio> yuuki: Found it. Hold on...
18:16:11 <TomMD> Lemmih: So what does the future hold for lhc?
18:16:17 <Cale>   (x >>= f) e = f (x e) e
18:16:42 <Lemmih> TomMD: It'll be much faster and far less memory intensive.
18:17:01 <yuuki> dolio, sweet!
18:17:03 <gwern> Lemmih: you didn't answer earlier, but your attempts to 'nudge' meachem failed I take it
18:17:06 <Cale> Why was the main author of yhc against cabalisation?
18:17:11 <Debugger> lhc will destroy us all!!!
18:17:12 <BMeph> yuuki: Do you get an infinite type from inferring 'k k'? :)
18:17:15 * Debugger hides.
18:17:16 <TomMD> Great!  And you forked just because of cabalization?
18:17:25 <gwern> Cale: you mean jhc?
18:17:29 <Cale> er...
18:17:30 <Lemmih> gwern: Yes, he doesn't want anything to do with cabal.
18:17:31 <Cale> jhc?
18:17:42 <Cale> okay
18:17:43 <gwern> I didn't know the yhc devs were against cabalization... what with yhc-core on hackage and all
18:17:49 <dmwit_> Debugger: wrong lhc ;-)
18:17:49 <Cale> jhc then :)
18:17:50 <yuuki> Bmeph, no, I get the same as Haskell in that case
18:17:56 <Debugger> dmwit_: :)
18:17:58 <gwern> yhc /= jhc, jhc ~= lhc
18:18:03 <Saizan_> Lemmih: do you know if there's some implementation of extensible records in it?
18:18:10 <Lemmih> Cale: He thinks Cabal is badly designed.
18:18:10 <gwern> ghc, nhc, and ehc are also all separate compilers :)
18:18:21 <Cale> Debugger, dmwit_: though, is there even a "right" LHC in that context?
18:18:24 <TomMD> I must use cabal + lhc to install all of hackage now...
18:18:26 <Cale> Lemmih: Oh?
18:18:26 <gwern> we may need a family chart soon...
18:18:27 <Lemmih> Saizan_: I have no idea.
18:18:41 <EvilTerran> gwern, jhc is like the large hadron collider? O.o
18:18:44 <gerryxiao> Cale:  (x >>= f) e = f (x e) e still use a monad value as function?
18:18:52 <gwern> TomMD: that may not be possible. lhc/jhc has always been very limited in what it can compile
18:19:01 <gwern> not to mention the missing extensions and stuff
18:19:02 * dmwit_ awaits the super-size hadron collider
18:19:12 <Lemmih> Cale: He's a fan of franchise: http://www.mail-archive.com/haskell-cafe@haskell.org/msg40088.html
18:19:14 <lambdabot> Title: [Haskell-cafe] announcing franchise 0.0, http://tinyurl.com/5bykmw
18:19:30 <Cale> gerryxiao: Since the monad is (->) e (the partial application of the function type constructor), computations in that monad have type (->) e a which is usually written e -> a
18:19:43 <BMeph> yuuki: So, you're saying that you do not get 'k k' from 'h h', is that it? :)
18:19:53 <Cale> gerryxiao: So the computations in that monad *are* functions.
18:20:15 <gerryxiao> Cale: still a bit confused
18:20:17 <yuuki> BMeph, for example, I = SKK = SKS, but SKK and SKS have different types
18:20:28 <Cale> gerryxiao: Okay... a monad is a type constructor, right?
18:20:38 <gerryxiao> Cale,yes
18:21:05 <Cale> (->) :: * -> * -> *  -- that is, it takes two types, and produces a type (of functions from the first type to the second)
18:21:08 <yuuki> BMeph, the type of SKK is a -> a and the type of SKS is (a -> b -> c) -> (a -> b -> c)
18:21:16 <yuuki> BMeph, surprising, isn't it? :)
18:21:20 <ddarius> dons: That was an awesome article.
18:21:28 <Cale> So it's not quite the right kind to be a monad, but if you apply it to some type e...
18:21:34 <Cale> (->) e :: * -> *
18:21:44 <ddarius> :t ap const
18:21:45 <lambdabot> forall a b. (a -> b) -> a -> a
18:21:45 <Cale> It takes a type, and gives another. So it *could* be a monad.
18:22:04 <yuuki> :t ap const ap
18:22:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
18:22:10 <Cale> We just have to work out what the operations will do.
18:22:13 <yuuki> :t ap const const
18:22:14 <lambdabot> forall a. a -> a
18:22:17 <BMeph> yuuki: Yes, it is. What types do you get? :)
18:22:28 <yuuki> Look at the above two type inferences
18:22:31 <Cale> We have  return :: a -> m a, and in this case, m = (->) e, so  return :: a -> (e -> a)
18:22:43 <monadwr> Night.
18:23:09 <Cale> and (>>=) :: m a -> (a -> m b) -> m b, so in this case (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
18:23:22 * BMeph looks up the pages...and gains Enlightenment!
18:23:33 <dons> heya TomMD
18:23:35 <gerryxiao> Cale,by now works
18:23:41 * BMeph then immediately tosses it away, since he prefers KDE...
18:23:49 <dons> ddarius: yeah, impressive stuff
18:24:08 <yuuki> BMeph, if we could infer the types by the simplified expressions, then the types of SKK and SKS would be the same
18:24:14 <BMeph> yuuki: Okay, I see. Interesting.
18:24:24 <yuuki> BMeph, yes, I was surprised as well
18:24:33 <Cale> and the question is then what are the operations of these types, and do they satisfy the monad laws? There's really only one way to define operations (nonstupidly) which have those types, and indeed they do give you a monad.
18:24:55 <Cale> @djinn (e -> a) -> (a -> (e -> b)) -> (e -> b)
18:24:55 <lambdabot> f a b c = b (a c) c
18:25:24 <Cale> Or, more readably,
18:25:33 <gerryxiao> Cale : you use this deducing Reader Monad ">>="
18:25:36 <Cale> (x >>= f) e = f (x e) e
18:25:41 <Cale> yeah
18:25:43 <TomMD> dons: Hows it going?
18:25:44 <gwern> @tell dcoutts reported at http://hackage.haskell.org/trac/hackage/ticket/412
18:25:44 <lambdabot> Consider it noted.
18:25:56 <Cale> So the Reader monad is secretly just functions from a fixed type e again!
18:26:06 <Cale> It's just wrapped up a bit.
18:26:28 <yuuki> dolio, any discoveries? :)
18:26:31 <dons> its cute that you can 'darcs get cabal' and 'cabal install darcs'
18:26:35 * dons <3 mutual recursion
18:26:53 <dons> TomMD: good. busy. just back from texas, talking about parallelism in haskell
18:27:04 <Cale> gerryxiao: Does that make some amount of sense? :)
18:27:06 <BMeph> yuuki: It isn't that surprizing - after all, (.) and ($) have different types, as well. :)
18:27:16 <TomMD> Yes, I heard that was happening.  Good times - did thoughtpolice make it?
18:27:33 <yuuki> Bmeph, I'm not familiar with those.  Sorry, I'm a haskell noob :)  I'm mostly just here to talk about combinators
18:27:36 <dons> i don't think so. the FP world isn't as closely associated with the supercomputing community as i'd like.
18:27:40 <dons> next year though SC09 is in portland
18:27:48 <dons> so we should have a bigger presence
18:28:02 <gerryxiao> Cale: hmm, seems i need a bit time to figure it out
18:28:03 <dolio> yuuki: I'm modifying it a bit to make it do what you want (I hope).
18:28:10 <yuuki> woot ;)
18:28:16 <Cale> gerryxiao: This function monad is actually really handy.
18:28:21 <TomMD> I'll be arriving in time, yay!  More conferences to Portland!
18:28:21 <Saizan_> BMeph: you mean ($) and id ?
18:28:29 <dons> woot
18:28:30 <Cale> gerryxiao: Mostly because of the various things in Control.Monad
18:28:33 <BMeph> yuuki: Oops, how about: id and ($) aren't the same type? :)
18:28:58 <yuuki> BMeph, is there a way to see the definition of ($)?
18:29:05 <Cale> gerryxiao: For example, we have sequence :: (Monad m) => [m a] -> m [a], which in this case, is  sequence :: [e -> a] -> e -> [a]
18:29:07 <Saizan_> @src ($)
18:29:07 <lambdabot> f $ x = f x
18:29:07 <ddarius> @src ($)
18:29:08 <lambdabot> f $ x = f x
18:29:25 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
18:29:25 <yuuki> @src id
18:29:25 <lambdabot> id x = x
18:29:26 <lambdabot>   [5,7,10,25,32]
18:29:47 <ddarius> @pl ($)
18:29:47 <yuuki> Bmepth, aren't ($) and id very different?
18:29:47 <lambdabot> id
18:29:49 <Saizan_> or ($) = id :: (a -> b) -> (a -> b)
18:30:17 <Cale> and join :: (Monad m) => m (m a) -> m a specialises to  join :: (e -> e -> a) -> e -> a
18:30:22 <yuuki> @pl id
18:30:22 <Cale> > join (*) 5
18:30:23 <lambdabot> id
18:30:24 <lambdabot>   25
18:30:55 <BMeph> yuuki: Different? Oh, yes...and no. ;)
18:30:59 <gerryxiao> Cale,  i know  (->) e now
18:31:18 <Cale> Great.
18:31:21 <yuuki> BMepth, $ means application as far as I can tell
18:31:31 <Cale> So Reader is just a different way of thinking of that same thing.
18:31:37 <povman> is this valid: foreign export ccall "hs_main" main' :: IO ()
18:32:14 <povman> then to call hs_main(); from a C program?
18:32:22 <povman> because i get a Bus Error....
18:32:51 <Cale> Computations of type  Reader e a  are things which are allowed to read from an environment of type e before resulting in a value of type a
18:33:00 <BMeph> yuuki: Yes, but: think about what applying a function to '$' does, as opposed to applying a function to 'id'. You'll get the same result. :)
18:33:09 <Cale> But what is that? It's just a function from e to a
18:33:29 <gerryxiao> Cale:  thx
18:33:48 <Cale> And we have operations like ask
18:33:53 <Cale> ask :: Reader e e
18:33:54 <yuuki> BMepth, you mean applying $ to a function and applying id to a function, right?
18:34:10 <Cale> But it should be obvious which function represents that one :)
18:34:17 <Cale> It's just the identity function.
18:34:49 <gerryxiao> get environmnet
18:34:50 <yuuki> BMepth, in other words, $ f x  is the same as i f x
18:34:51 <Cale> > (do x <- ask; return (x ++ x)) "Hello"
18:34:52 <lambdabot>   "HelloHello"
18:35:10 <Cale> (It's available in the (->) e monad as well, because it actually works in any MonadReader)
18:35:16 <yuuki> BMepth, (taking away infix)
18:35:26 <Cale> > runReader (do x <- ask; return (x ++ x)) "Hello"
18:35:27 <lambdabot>   "HelloHello"
18:35:31 <Cale> same thing ;)
18:35:33 * gwern reads TMR
18:35:36 <gwern> 'This last limerick’s quite hard for me,
18:35:37 <gwern> If you read on, I’m sure you’ll agree.
18:35:37 <gwern> I struggle and sigh,
18:35:37 <gwern> For no matter how I trie,
18:35:37 <gwern> I just don’t know how to pronounce trie.
18:36:24 <povman> lol
18:36:24 <Cale> The first trie is pronounced 'try' and the second is pronounced 'tree', I think. :)
18:37:00 <gwern> yes, to make it scan as a limerick you need to use both proununciations of trie
18:38:12 <BMeph> yuuki: Right. Similarly, for two-argument functions, SKS and SKK will give the same answer. They're not identical, but given a particular domain, they are. :)
18:38:32 <BMeph> Er, s/are/work the same/ :)
18:38:40 <Cale> > (do x <- id; return (x ++ x)) "Hello"
18:38:41 <lambdabot>   "HelloHello"
18:38:51 <yuuki> Bmeph yes, except I think that SKS and SKK are always identical
18:39:36 <yuuki> BMeph that's why the difference in types are so confusing to me :)
18:39:43 <BMeph> yuuki: In a combinatorial workd, they are. ;)
18:40:58 <BMeph> yuuki: "modulo your definition of 'identical'" ;)
18:41:19 <BMeph> s/workd/world/
18:42:33 <yuuki> BMepth, let's just say that the fact that: given Kxy -> x, Sxyz -> xz(yz) then SKK and SKS have different types is very suprising to me
18:44:09 <Saizan_> with eager evaluation it makes more sense
18:44:12 <yuuki> given that SK(the moon is made of green cheese) should be identical to SKK
18:44:17 <BMeph> yuuki: Let's just say that coming from a combinatorics background, I'm surprized that types make sense to you at all, heh-heh. :)
18:45:03 <yuuki> Saizan, I think I see what you mean... could you elaborate?
18:45:23 <BMeph> yuuki: Welcome to the world of lazy evaluation of strictly-typed values! ;)
18:46:38 <Saizan_> yuuki: Sxyz -> xz(yz), in eager evaluation you've to reduce (yz) first, so z must have a type that y accepts
18:47:11 <Saizan_> even if x is going to discard it
18:47:20 <yuuki> Saizan, that makes sense!
18:48:13 <dons> seems like a good weekend to write a bytestring tire
18:48:16 <dons> trie!!
18:48:34 <gwern> sure, but how do you pronounce that?
18:48:44 <BMeph> yuuki: Aye, that's exactly why it works out that way - Haskell is non-strict in values, but strict in types.
18:49:20 <gwern> non-strict types... o.0 I am unsure I want to pursue that thought further
18:49:35 <dons> parts of the program you don't call won't get type checked :)
18:49:38 <Saizan_> we already mix data and codata..
18:49:55 <yuuki> Hmm... non-strict types sounds kind of nice
18:50:08 <dmwit> Sounds like Python to me.
18:50:13 <yuuki> It seems like it'd be equivalent to runtime type checking
18:50:22 <gwern> dons: but how would one compile such a program? seems to me that... yeah, what yuuki said
18:50:26 <dmwit> ...which implies that I think Python is not nice.  That implication is false.
18:50:31 <fnord123> Is there a channel for cabal specific troubleshooting?
18:50:37 <dons> this is the channel
18:50:38 <dons> or #ghc
18:50:40 <dons> if dcoutts is around
18:50:50 <dons> i'd try #ghc
18:50:54 <dmwit> Hah, I beat yuuki *and* gwern!  man
18:51:16 <yuuki> dmwit, haha
18:51:22 <dmwit> And now to disappear so nobody can disagree with me!
18:51:32 <gwern> the man was as good as his word!
18:52:12 <yuuki> Although, in the case of things like SKS you could do pinhole optimizations that would note that the second S is not invoked
18:52:27 <yuuki> So it wouldn't have to be runtime checking
18:55:30 <yuuki> But yes, checking non-strict types would involve running the program in some capacity
18:56:30 <solrize> how lovely, a poem about the halting problem (via wadler).  http://ling.ed.ac.uk/~gpullum/loopsnoop.pdf
18:56:37 <lambdabot> Title: cache:http://ling.ed.ac.uk/~gpullum/loopsnoop.pdf - Google Search
18:57:14 <yuuki> solrize, the halting problem relies on infinity, right? :)
18:57:46 <solrize> hmm?  i don't think so
18:59:28 <yuuki> solrize, I thought finite machines were turing-incomplete and therefore didn't succumb to the halting problem
18:59:50 <solrize> unbounded /= infinite
19:03:58 <dolio> yuuki: http://hpaste.org/12272
19:04:33 <dolio> It got cut off at the end. That last line should be "vs = ['a'..'z']"
19:05:27 <dolio> Anyhow, if you load that into ghci, and run "test", it prints out two types for h, one for h h, and all the substitutions in the unifier of all of them.
19:05:47 <dolio> It's not ideal, but it was kind of a hack-job of a type checker in the first place.
19:07:48 <ddarius> Certainly, if nothing else, non-termination requires an infinity of steps.
19:08:43 <dolio> If you want to see all the types its unifying, you could wrap the whole thing in a WriterT transformer, annotate calls to "unify" with a "tell" and print those out at the end, too.
19:09:44 * gwern notices I am credited in the hoogle section of TMR. hm. My cabal contributions weren't *that* major
19:10:06 <yuuki> dolio, I get a whole bunch of errors when loading that into ghci
19:10:27 <dolio> You do?
19:11:09 <yuuki> yeah... I'm a haskell newb
19:11:25 <yuuki> If it's not too much, could you paste the output?
19:11:52 <jeffz> yuuki, did you save it in a file and then load the file with ghci?
19:11:56 <yuuki> Yes
19:12:11 <dolio> Okay, it's annotated with the output.
19:12:18 <yuuki> I saved it to a file named infer and then I did cat infer | ghci
19:12:25 <yuuki> Thanks!
19:12:46 <jeffz> ghci infer.hs
19:12:52 <jeffz> or ghci RET :l infer.hs RET
19:13:41 <yuuki> dolio, the type of h1 and h2 seem strange
19:13:57 <yuuki> instead of (e -> f -> g -> j) the type should be the type of S
19:14:15 <dolio> Hmm...
19:17:06 <dolio> Yeah, I may have been lax in my substituting into returned types...
19:23:17 <lispy> ?tell dcoutts if we wanted to start posting dev snapshots of darcs to hackage, 1) is weekly too often?  It seems like it would pollute hackage. 2) should we post them as darcs-snapshot or is using the 'darcs' package name okay?  I say this while intending to give them a version number like 2.1.2.20081116 or 2.1.2.numberofpatches, and I'd rather those be "out of sequence" with people that want stable releases.
19:23:18 <lambdabot> Consider it noted.
19:25:45 <dolio> yuuki: Okay, I think it's working now. I also added the writer bit, so it shows what things it unifies in order.
19:26:30 <yuuki> Wow, it's a long proof
19:26:43 <yuuki> I'll check it out and see if I can find what I was doing wrong
19:26:58 <dolio> Not all of that is for h h. There's stuff for inferring two copies of h as well.
19:52:52 <yuuki> dolio, I found my mistake!
19:52:58 <yuuki> Thank you
19:53:11 <dolio> No problem.
19:53:19 <yuuki> I had assumed somewhere in my proof that the the two K's in KSK were a single instance
19:53:43 <dolio> Ah. That'd do it.
19:53:46 <yuuki> Probably because I was representing both of them with 'K'
19:57:32 <pumpkin_> can anyone help me get protocol buffers installed? it seems to be confused that Data.Generics is offered both by base and syb
19:58:11 <dons> just mail the author
19:58:17 <Saizan_> ?hackage protocol-buffers
19:58:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/protocol-buffers
19:58:18 <dons> chris should reply pretty promptly
19:58:31 <dons> he probably hasn't tried with 6.10
19:59:04 <pumpkin_> the site said it worked on 6.10 so I was wondering if it was something I'd done
19:59:36 <quuxman> So does it bother anyone else that side effects such as updating an IORef are in the same category as launching missles?
20:00:01 <Riastradh> Use STRefs!
20:00:37 <Cale> Yep, that's what the ST monad is for :)
20:00:48 <quuxman> ok
20:01:11 <Saizan_> pumpkin_: the .cabal file should say base > 3 && < 5 instead of base >= 3
20:01:19 <pumpkin_> ah
20:02:03 <pumpkin_> can I just go edit my ~/.cabal/packages/...
20:02:16 <pumpkin_> it appears to be in a tarball
20:02:34 <Saizan_> extract that tarball somewhere and build from there
20:02:42 <gwern> sure. I usually copy the tarball to ~/ and work from  there
20:02:58 <gwern> find .cabal|grep protocol-buffers, cp etc.
20:03:17 <pumpkin_> I've never installed a cabal package without cabal-install before
20:03:26 <Cale> pumpkin_: You can still use cabal install
20:03:28 <Saizan_> there should be a cabal unpack soon :)
20:03:31 <Cale> pumpkin_: With no other parameters.
20:03:47 <Cale> (from the directory which the .cabal file is in)
20:04:01 <pumpkin_> ah
20:04:52 <pumpkin_> it still fails even with > 3
20:05:16 <pumpkin_> I'd expect it to not affect the behavior, because I have 4 I think
20:05:26 <yuuki> Hmm... I'm starting to question the point of having an axiomatic system based on X = KSK.  The axiom is a little hard to understand intuitively :)
20:06:00 <dolio> It's 1 instead of 2!
20:06:54 <Saizan_> pumpkin_: on 6.10 you should have both base-4.0.0.0 and base-3.0.3.0
20:06:55 <yuuki> Haha, yes :)  I guess if you understand the K and S combinators then it doesn't seem so hard to believe in X :)
20:07:16 <pumpkin_> Saizan_: hmm, the issue is that it says two different packages offer Data.Generics though
20:07:23 <pumpkin_> same error with > 3
20:07:41 <yuuki> Oh, and application and X are representable in bit strings, so that is a nice Godel numbering
20:07:57 <geezusfreeek> @djinn (a -> b -> c) -> (a -> b) -> a -> c
20:07:57 <lambdabot> f a b c = a c (b c)
20:08:46 <geezusfreeek> is that not the same as S?
20:09:03 <yuuki> @djinn ((a -> b -> a) -> ((c -> d -> e) -> (c -> d) -> c -> e) -> (f -> g -> f) -> h) -> h
20:09:04 <lambdabot> f a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
20:09:14 <yuuki> Yes, it's the same as S
20:09:30 <geezusfreeek> a K = const
20:09:36 <geezusfreeek> so K S K = S ?
20:09:42 <yuuki> What I just ran through djinn is the single axiom of a system of combinatory logic with the same strength as the SK basis
20:09:59 <yuuki> sorry, Xx = xKSK
20:10:09 <geezusfreeek> heh, i thought something was up there
20:10:14 <yuuki> hehe, my bad
20:10:17 <geezusfreeek> @pl f a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
20:10:18 <lambdabot> f = flip (flip ($ const) ap) (const id)
20:10:45 <Saizan_> pumpkin_: it looks like base > 3 isn't being respected, base == 4.* is working for me though
20:10:54 <yuuki> geezusfreeek, what is @pl?
20:11:14 <geezusfreeek> yuuki: stands for "pointless." makes functions point free
20:11:30 <geezusfreeek> also unpl
20:11:32 <geezusfreeek> @unpl f = flip (flip ($ const) ap) (const id)
20:11:32 <pumpkin_> Saizan_: yay, thank you
20:11:32 <lambdabot> f c = c (\ g _ -> g) (\ n o -> n >>= \ l -> o >>= \ k -> return (l k)) (\ _ j -> j)
20:11:59 <ddarius> @help pl
20:12:00 <lambdabot> pointless <expr>. Play with pointfree code.
20:12:17 <pumpkin_> @help djinn
20:12:18 <lambdabot> djinn <type>.
20:12:18 <lambdabot> Generates Haskell code from a type.
20:12:18 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:12:19 <roconnor> @djinn (a -> (b -> Bool) -> Maybe b) -> ((a -> Bool) -> Maybe a) -> (b -> Bool) -> Maybe b
20:12:19 <lambdabot> f a b c =
20:12:20 <lambdabot>     case b (\ _ -> False) of
20:12:20 <lambdabot>     Nothing -> Nothing
20:12:22 <lambdabot>     Just d -> case a d (\ e ->
20:12:24 <lambdabot>                         case a d (\ _ -> False) of
20:12:26 <lambdabot>                         Nothing -> case a d (\ _ -> True) of
20:12:28 <lambdabot>                                    Nothing -> c e
20:12:30 <lambdabot>                                    Just _ -> False
20:12:32 <lambdabot>                         Just f -> c f) of
20:12:34 <lambdabot>               Nothing -> Nothing
20:12:36 <lambdabot> Plugin `djinn' failed with: thread killed
20:12:37 <geezusfreeek> :o
20:12:42 <Saizan_> pumpkin_: mailing the maintainer is still a valid idea :)
20:12:44 <pumpkin_> wow
20:12:45 <yuuki> geezusfreeek, interestingly, Fokker's X ( \ f -> f S ( \ x y z -> x ) ) does not work
20:12:50 <pumpkin_> Saizan_: just sent him one :)
20:13:08 <geezusfreeek> :t \ f -> f S ( \ x y z -> x )
20:13:09 <lambdabot> Not in scope: data constructor `S'
20:13:12 <geezusfreeek> woops
20:13:43 <geezusfreeek> :t \ f -> f (\a b c -> a c (b c)) ( \ x y z -> x )
20:13:44 <lambdabot> forall t t1 t2 t3 t4 t5 t6. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t5 -> t3) -> t6) -> t6
20:13:58 <yuuki> If you apply that to itself you get an infinite type
20:14:01 <roconnor> @djinn (a -> (b -> Bool) -> b) -> ((a -> Bool) ->  a) -> (b -> Bool) -> b
20:14:01 <lambdabot> f a b c =
20:14:01 <lambdabot>     a (b (\ _ -> False)) (\ _ ->
20:14:01 <lambdabot>                           c (a (b (\ _ -> False)) (\ _ -> False)))
20:14:09 <geezusfreeek> @pl \ f -> f (\a b c -> a c (b c)) ( \ x y z -> x )
20:14:09 <lambdabot> flip ($ ap) (const . const)
20:14:28 <geezusfreeek> :t let x = flip ($ ap) (const . const) in x x
20:14:29 <lambdabot>     Occurs check: cannot construct the infinite type:
20:14:30 <lambdabot>       a = b2 -> b1 -> a -> b
20:14:30 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:14:57 <yuuki> So Rosser's X is the smallest single basis combinator that is well-typed
20:15:01 <geezusfreeek> :t (\x -> x x) (\x -> x x)
20:15:02 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:15:03 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:15:03 <lambdabot>     In the expression: x x
20:15:56 <Saizan_> pumpkin_: ah, now i see the problem with using base > 3:  3.0.3.0 > 3 :)
20:16:06 <pumpkin_> oh :) makes sense
20:16:08 <yuuki> In Rosser, K = XXX and S = X(XX).  In Fokker K = XX and S = X(XX)
20:16:34 <yuuki> It's surprising that one of them is well-typed and the other isn't
20:17:33 <yuuki> This is Fokker's paper.  It doesn't involve typing, so he doesn't mention that his basis isn't well-typed
20:17:35 <yuuki> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.555
20:17:36 <lambdabot> Title: The systematic construction of a one-combinator basis for Lambdaterms,” Formal ...
20:17:59 <geezusfreeek> i think i have skimmed it before
20:18:24 <geezusfreeek> ah yes, i remember reading about its derivation
20:18:55 <yuuki> I haven't checked the other bases to see if they are well-typed or not
20:19:30 <geezusfreeek> what exactly do you mean by "well typed" here, anyway? expressible in the simply typed lambda calculus?
20:19:57 <yuuki> Well, the Fokker version leads to an infinite type when K is constructed
20:20:43 <geezusfreeek> oh, you mean S and/or K are not well typed, i see what you are getting at now
20:20:49 <yuuki> Yes
20:21:13 <yuuki> So with respect to a typed lambda calculus, Fokker's X can't express every possible lambda expression
20:21:15 <geezusfreeek> kind of like Y in the lambda calculus
20:22:40 <yuuki> geezusfreeek is it impossible to type Y in the calculus of constructions?
20:23:29 <geezusfreeek> yuuki: is that really the right conclusion to draw, that Fokker's X can't express every typed lambda expression? clearly it can express things which are _not_ typed lambda expressions
20:23:38 <Saizan_> Y id doesn't terminate, and being CoC strong normalizing..
20:23:47 <geezusfreeek> yuuki: Y can't be expressed in CoC, no
20:23:51 <yuuki> I guess strong normalization and termination are exclusive
20:24:23 <yuuki> geezusfreeek, well I don't see how Fokker's X can express K : (a -> b -> a)
20:27:11 <yuuki> Hmm... is there really no recursion in CoC?
20:27:31 <geezusfreeek> sure there is
20:27:38 <yuuki> Terminating recursion
20:27:41 <geezusfreeek> yes
20:27:50 <yuuki> Which is the only thing you really want
20:28:05 <dolio> There's no general recursion.
20:28:17 <Saizan_> you do structural recursion on inductive types
20:28:17 <geezusfreeek> yuuki: sometimes you want corecursion
20:28:47 <yuuki> Shouldn't corecursion be possible as long as it's provably terminating?
20:29:04 <roconnor> ... except coinductive types makes the system no longer confluent ...
20:29:27 <geezusfreeek> but i _like_ coinductive types :(
20:29:56 <yuuki> I just added a few words to my vocabulary :p
20:30:59 <yuuki> It seems like there should be a lambda hypercube, more facets to discover and add to CoC without violating strong normalization
20:31:29 <geezusfreeek> yuuki: there are extensions you can add, of course
20:31:54 <Saizan_> so the order of evaluation matters again with coinductive types?
20:31:56 <geezusfreeek> i'm not sure i would say they are completely orthogonal though
20:32:23 <roconnor> Saizan_: hmm
20:32:58 <roconnor> I guess it must.
20:33:14 <roconnor> not sure
20:33:52 <roconnor> I guess I shouse say that the coinductive system in CoC violates subject reduction
20:34:07 <roconnor> which I believe implies it is no longer confluent.
20:34:35 <yuuki> @google cofluent
20:34:38 <lambdabot> http://www.cofluentdesign.com/
20:34:38 <lambdabot> Title: CoFluent Design - Home
20:34:43 <roconnor> confluent
20:34:44 <geezusfreeek> yuuki: spell check ;)
20:34:53 <yuuki> haha
20:35:01 <geezusfreeek> yuuki: it means that you arrive at the same place no matter what path you take, basically
20:35:06 <roconnor> confluent == Church-Rosser ... if that helps
20:35:19 <yuuki> It's a part of strong normalization
20:35:58 <Saizan_> do you have a short definition for subject reduction too? :)
20:36:21 <yuuki> No, I am in need of one :)
20:36:53 <roconnor> subject reduction means that evalutation perserves the type
20:37:31 <yuuki> yikes.  That's important
20:37:38 <roconnor> or reducing any redex preserves the type
20:38:10 <roconnor> yuuki: apparently of so little importance, that no Coq users notices for 6 years.
20:38:21 <yuuki> haha
20:38:22 <roconnor> :)
20:38:42 <geezusfreeek> i was very disappointed when i read about it
20:38:50 <yuuki> It sounds like the problem I was having with I = SKS
20:38:55 <roconnor> then an Agda implementor was like "Hey, how do they do it in Coq with out violating subject reduction?"
20:39:01 <roconnor> goes looks
20:39:05 <geezusfreeek> "oh crap"
20:39:07 <roconnor> oh, they don't
20:39:07 <yuuki> applying the reduction rule obliterates the type of SKS
20:41:04 <yuuki> If the type system is the only part of lambda calculus that corresponds with proofs, then what is the point of the evaluation side for a system like Coq?
20:41:22 <dolio> It probably should have been noticed earlier, since papers that actually used coinductive types had to insert stuff that was essentially "evaluate now" into their proofs.
20:41:45 <dolio> But being able to do that in Coq kind of hides it, where it looks more terrible in Agda.
20:42:29 <roconnor> yuuki: the terms corrrespond to proofs
20:42:35 <roconnor> the types correspond to formula
20:42:40 <roconnor> aka theorems
20:43:19 <yuuki> Hmm...  that makes sense... I think
20:43:55 <roconnor> evaluation allows you to prove the type 2 + 2 = 4 by (refl_eq 4)  (or refl_eq (2+2))
20:44:47 <roconnor> (refl_eq 4) has type 4 = 4, which is the _same_ type as 2 + 2 = 4
20:45:23 <yuuki> Hmm
20:47:03 <yuuki> Can't you just look at the type of 4 and the type of 2 + 2 and then have your proof?  I'm not seeing where the evaluation comes in
20:47:51 <gwern> so let's see, 4 :: Int, (2 + 2) :: Int, Int == Int, therefore 4 == (2+2)?
20:48:08 <gwern> (1 :: Int, 2 :: Int; Int == Int, therefore 1 == 2 :))
20:48:43 <roconnor> (refl_eq 4) has type 4 = 4 (by the definition of refl_eq (proof by reflexivity))
20:48:59 <roconnor> I want to claim that (refl_eq 4) also has type 2 + 2 = 4
20:49:27 <roconnor> so the type checker compares 4 = 4 to 2 + 2 = 4 by putting both in normal form, and checking if they are the same
20:49:36 <roconnor> 4 = 4 is already in normal form
20:49:47 <geezusfreeek> yuuki: the types have to be normalized so that they will unify properly, which is why you need the evaluation
20:49:52 <roconnor> 2 + 2 = 4 is not because the expression (2 + 2) can be further reduced.
20:50:01 <yuuki> I see...
20:50:05 <roconnor> so the evaluation mechanism normalizse (2 + 2) and gets 4
20:50:12 <roconnor> so the normal form of 2 + 2 = 4 is 4 = 4
20:50:16 <roconnor> which matches
20:50:20 <roconnor> and we have a valid proof
20:50:29 <yuuki> So you can normalize via evaluation or modus ponens/unification
20:51:13 <roconnor> in this case evaluation means beta-iota-delta-zeta reduction
20:51:22 * pumpkin_ 's head explodes
20:51:36 <geezusfreeek> ha
20:51:37 <yuuki> Although I'm skeptical of evaluation to some extent because it has destroyed types for me in the past
20:51:56 <pumpkin_> I can deal with all the other jargon you're throwing around, but beta-iota-delta-zeta reduction??
20:52:00 <roconnor> evaluation only destroys coinductive types
20:52:03 <roconnor> :P
20:52:04 <pumpkin_> (says the bleeding neck)
20:52:05 <geezusfreeek> destroyed types how?
20:52:20 <yuuki> For example, how do I evaluate SKS in a way that doesn't destroy the type of SKS?
20:52:28 <dolio> You don't prove a = b for coinductive types, anyhow.
20:52:33 <yuuki> which is (a -> b -> c) -> (a -> b -> c)
20:52:33 <dolio> You prove that a is a bisimulation of b.
20:53:50 <dolio> (Because = is kind of useless, for the afforementioned reasons.)
20:53:52 <Saizan_> i guess you've to annotate terms with types
20:53:55 <geezusfreeek> yuuki: i don't understand that question. you mean evaluating SKS doesn't preserve types?
20:53:59 <yuuki> Yes
20:54:21 <yuuki> Well, unless I am not evaluating it correctly
20:54:37 <geezusfreeek> :t (\a b c -> a c (b c)) const (\a b c -> a c (b c))
20:54:38 <lambdabot> forall t t1 t2. (t1 -> t2 -> t) -> t1 -> t2 -> t
20:54:53 <roconnor> SKS isn't a proper term in CoC.  You are missing type anonotations
20:54:58 <int-e> @type ap const ap
20:55:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
20:55:17 <geezusfreeek> @pl (\a b c -> a c (b c)) const (\a b c -> a c (b c))
20:55:17 <lambdabot> id
20:55:24 <geezusfreeek> :t id
20:55:25 <lambdabot> forall a. a -> a
20:55:32 <geezusfreeek> yuuki: looks fine to me :)
20:55:45 <roconnor> geezusfreeek: those two types are not the same
20:55:59 <geezusfreeek> roconnor: i'm being silly again
20:56:05 <yuuki> That's what I'm not understanding
20:56:12 <dolio>  @pl plays loose with the rules.
20:56:15 <geezusfreeek> i meant to make a wink
20:56:27 <dolio> It freely substitutes terms with terms of a more general type.
20:56:28 <roconnor> yuuki: types are not preserved by curry style lambda calculus
20:56:35 <yuuki> I see
20:56:41 <roconnor> yuuki: evaluation might generalize the types
20:56:44 <int-e> @pl (\a b c -> a c (b c))
20:56:44 <lambdabot> ap
20:57:09 <roconnor> ... I think
20:57:14 <yuuki> Hmm, I'll have to play around with type annotations
20:57:15 <roconnor> I'm not sure if what I say is true or not.
20:57:29 <dolio> Seems plausible.
20:57:35 <int-e> @pl (>>= return)
20:57:35 <lambdabot> id
20:58:06 <pumpkin_> @src Either
20:58:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:58:07 <Saizan_> SKS does recude to I, and if you look at I by itself you get a more general type
20:58:14 <pumpkin_> @type Either
20:58:15 <lambdabot> Not in scope: data constructor `Either'
20:58:16 <rskjr> oh snap
20:58:20 <roconnor> S_a,b,c K_foo,bar ...
20:58:25 <roconnor> @kind Either
20:58:26 <lambdabot> * -> * -> *
21:00:07 <geezusfreeek> roconnor: what do you mean "curry style" lambda calculus?
21:00:18 <dolio> roconnor: Were zeta, delta and iota reduction invented for the type systems invented for Coq? All the google hits look like Coq-related documents. :)
21:01:09 <dolio> I guess delta gets non-Coq hits.
21:01:20 <roconnor> geezusfreeek: curry style has lambda expression like \x->x, church style has expressions like \x:a -> x
21:01:28 <roconnor> or maybe the other way around
21:01:53 <yuuki> Hmm, it seems that type unification is all that is needed for proofs
21:02:00 <roconnor> dolio: could be.  I've only heard of them for CoC, but the terms are general enough that they could be reused other places.
21:02:36 <geezusfreeek> yuuki: yes, but you need evaluation to make interesting types unify :)
21:02:49 <yuuki> Nevermind, you need unification plus modus ponens, or evaluation, which is the same as modus ponens and unification
21:03:11 <roconnor> modus ponens is beta-reduction?
21:03:40 <yuuki> Yes, I think so.  Beta-reduction reduces function application, right?
21:04:46 <dolio> Modus ponens is the (logic equivalent of) typing rule for application, no?
21:04:48 <yuuki> modus ponens is p -> q, p => q
21:04:55 <geezusfreeek> @djinn (a -> b) -> a -> b
21:04:55 <lambdabot> f a = a
21:05:03 <geezusfreeek> ^ modus ponens
21:05:10 <roconnor> beta-reduction reduces function application
21:05:11 <dolio> (a -> b) /\ a |- b or something like that.
21:05:30 <int-e> @type (,)
21:05:31 <lambdabot> forall a b. a -> b -> (a, b)
21:06:08 <yuuki> Wow, so modus ponens is a less general version of id
21:06:31 <yuuki> @djinn a -> (a -> b) -> b
21:06:31 <lambdabot> f a b = b a
21:06:41 <roconnor> MP typically refers to the rules that allows (f x) to be a valid term (regardless of reduction).
21:07:38 <yuuki> Hmm, in a hilbert style proof there is unification (substitution) and MP only
21:08:00 <roconnor> and axioms
21:08:09 <yuuki> I think MP corresponds to evaluation of applications
21:08:36 <roconnor> but again MP corresponds to the rule that allow you to place combinators next to each outher (S K)
21:09:08 <roconnor> evaluation of proofs is kinda extra-logical.
21:09:18 <roconnor> (at least classically speaking)
21:09:35 <yuuki> I see what you're saying
21:09:51 <geezusfreeek> hmm, according to TAPL, System F does have preservation of types
21:10:06 <geezusfreeek> which i would have expected
21:10:10 <yuuki> Yes
21:10:14 <yuuki> That's what I expected
21:10:23 <pumpkin_> @src liftM2
21:10:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:10:24 <geezusfreeek> so why the suggestion that evaluating expressions might generalize the types?
21:10:38 <geezusfreeek> i may be missing a distinction
21:10:39 <pumpkin_> oh my, it actually makes sense to me now
21:10:42 <yuuki> I think I just wasn't doing it right
21:10:57 <roconnor> geezusfreeek: is that church style system F or curry style system F?
21:10:58 <yuuki> I wasn't using type annotations
21:11:13 <geezusfreeek> roconnor: i will have to look up the differences ;)
21:11:38 <dolio> geezusfreeek: I think the implication is that if you infer the type of an expression (of an expression where lambda parameters are not annotated), and then normalize it and infer it, you may get different results.
21:11:46 <roconnor> potentially system F always referes to one of those styles.  I'm not so familiar with the details of system F.
21:12:56 <geezusfreeek> dolio: you mean it's not the type system, it's the inference engine?
21:12:57 <dolio> (\a b c -> a c (b c)) (\a b -> a) (\a b c -> a c (b c)) gets you one result, and (\a -> a) gets you another.
21:13:36 <dolio> Whereas if you have to annotate all those as bs and cs, the (\a -> a) at the end has a different annotation on a than you might infer.
21:14:06 <geezusfreeek> dolio: ah i see, so it is just the inference engine then
21:14:14 <dolio> Yeah.
21:14:41 <roconnor> curry style system F probably has "principle types" for terms.  is that the right word?
21:15:11 <dolio> Is System F limited to rank-1 types?
21:15:18 <yuuki> Is all of this common knowledge in the haskell crowd? :)
21:15:34 <dolio> I can never remember.
21:15:38 <Saizan_> having principle types means that every term has a single most general type
21:15:41 <gwern> yuuki: sometimes I really wonder
21:16:23 <CosmicRay> good evening everyone
21:16:29 <Saizan_> i think System F refers to rank-N, so it shouldn't have them
21:16:30 <yuuki> gwern, I tried asking the math room these questions and they just kind of gave up :p
21:16:53 <Saizan_> judging from the papers about type inference for higher-rank polymorphism
21:17:23 <geezusfreeek> looking at the syntax in TAPL it looks like rank N
21:17:34 <procyon112> yuuki: You might have better luck in a logic room :)
21:17:42 <yuuki> I thought that there were still principle types in rank-N
21:18:25 * roconnor finds #math useless.  Anytime he asks a non-trival question, they accuse it of being a homework problem.
21:18:25 <yuuki> Hmm, shouldn't that be principal rather than principle?
21:18:39 <roconnor> could be
21:18:48 <Saizan_> yeah, principal
21:19:15 <roconnor> @wn principle
21:19:16 <lambdabot> *** "principle" wn "WordNet (r) 2.0"
21:19:16 <lambdabot> principle
21:19:16 <lambdabot>      n 1: a basic generalization that is accepted as true and that can
21:19:16 <lambdabot>           be used as a basis for reasoning or conduct; "their
21:19:16 <lambdabot>           principles of composition characterized all their works"
21:19:18 <lambdabot> [14 @more lines]
21:19:24 <roconnor> @wn principal
21:19:25 <lambdabot> *** "principal" wn "WordNet (r) 2.0"
21:19:25 <lambdabot> principal
21:19:25 <lambdabot>      adj : most important element; "the chief aim of living"; "the main
21:19:26 <lambdabot>            doors were of solid glass"; "the principal rivers of
21:19:29 <lambdabot>            America"; "the principal example"; "policemen were
21:19:30 <lambdabot> [12 @more lines]
21:19:36 <roconnor> ah
21:19:48 <Saizan_> (and i could be confusing the problems of impredicative instantiation with higher-rank..)
21:19:53 <roconnor> that makes sense
21:20:10 <pumpkin_> what's the nicest way to parse binary sturctures in files into useful ones in haskell? I need support for varying endianness
21:20:27 <pumpkin_> I found a few options on hackage but was wondering if anyone had tried any of them
21:20:31 <geezusfreeek> from TAPL on System F: T ::= X | T->T | forall X . T
21:21:28 <Saizan_> pumpkin_: the binary package is the preferred choice
21:21:45 <geezusfreeek> X is type variable, T->T is function type, forall X . T is universal type
21:21:47 <Saizan_> pumpkin_: probably using the Get/Put monads directly rather than the Binary class
21:22:13 <pumpkin_> Saizan_: I'll take a look, thanks
21:23:33 <Saizan_> geezusfreeek: and if i've id = \a:*,x:a -> x, i can have x = id (forall a. a -> a) with x : (forall a. a -> a) -> (forall a. a -> a) ?
21:24:00 <pumpkin_> Saizan_: no support for reading floats it seems?
21:24:40 <pumpkin_> ah well, not that big a deal
21:27:37 <geezusfreeek> Saizan_: looks like it to me
21:28:32 * Saizan_ should actually read TAPL asap
21:29:19 <pumpkin_> I think BONUS must wait until he's on druge before he posts to his twitter
21:29:34 <geezusfreeek> i'm looking at: selfApp = \x:forall X.X->X. x [forall X.X->X] x; which has type (forall X. X->X) -> (forall X. X->X)
21:29:37 <roconnor> I though BONUS was a girl.
21:29:42 <pumpkin_> oh is it?
21:29:46 <pumpkin_> sorry then :)
21:29:47 <roconnor> I'm not sure
21:31:08 <pumpkin_> well <gender neutral pronoun> must wait until <gender neutral pronoun>'s on drugs before <gender neutral pronoun> posts to <gender neutral possessive pronoun> twitter
21:31:21 <Saizan_> where is it?
21:31:30 <geezusfreeek> page 345
21:32:11 <roconnor> @where BONUS
21:32:11 <lambdabot> I know nothing about bonus.
21:32:20 <pumpkin_> http://twitter.com/bonus500
21:32:21 <lambdabot> Title: Twitter / bonus500
21:34:07 <roconnor> hmm, I'm torn between the content, and the rainbow unicorn background.
21:34:14 <pumpkin_> :P
21:34:25 <pumpkin_> no gender stereotyping allowed!
21:35:15 <august> what about hormonal influences stereotyping
21:35:33 <pumpkin_> ohai august!
21:36:55 <august> also read that ruby post
21:36:58 <august> awful
21:37:18 <pumpkin> it's not as bad as he makes it out to be, but it's not great
21:37:33 <pumpkin> august: if you decide to hang out in here, beware of the beta-iota-delta-zeta reduction
21:37:38 <pumpkin> your head might expldoe
21:37:42 * pumpkin points to his bleeding stump
21:38:01 <geezusfreeek> what ruby post?
21:38:08 <august> as long as that's not the same as exploding
21:38:08 <pumpkin> the kirindave pessimistic one
21:38:31 <pumpkin> it's better than explstagging
21:39:00 <geezusfreeek> "the opposite of momentum"?
21:39:08 <pumpkin> yup
21:39:45 <august> omg berkeley.edu
21:39:47 <dolio> Is id (forall a. a -> a) allowed? That seems like it would lead to problems at first blush...
21:40:29 <ddarius> It depends on whether the system is predicative or impredicative.
21:40:37 <dolio> Right.
21:40:52 <august> is that like flammable and inflammable?
21:41:46 <Saizan_> that's related to the infamous runST $ (..)
21:42:33 <dolio> Somewhat.
21:42:35 <geezusfreeek> oh man i remember hitting that when i was still new to all this and being all WTF?
21:43:23 <Saizan_> well, you need to instantiate the type of ($) impredicatively for that to work, afaiu
21:43:26 <geezusfreeek> well, i still consider myself new to all this
21:43:36 <dolio> > ($) :: ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a
21:43:37 <lambdabot>       Overlapping instances for Show
21:43:37 <lambdabot>                                  (((fora...
21:43:43 <dolio> :t ($) :: ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a
21:43:44 <lambdabot> forall a. ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a
21:43:58 <geezusfreeek> :t ($)
21:43:58 <lambdabot> forall a b. (a -> b) -> a -> b
21:44:02 <dolio> The issue is whether GHC automatically does it for you.
21:44:18 <dolio> I think.
21:44:22 <Saizan_> yeah
21:45:02 <Cale> Yeah, normally type variables won't be instantiated to polymorphic types.
21:46:03 <Saizan_> http://research.microsoft.com/~simonpj/papers/boxy/
21:46:03 <lambdabot> Title: Simon Peyton Jones: papers
21:46:09 <Cale> (as in, types containing foralls directly)
21:47:00 <geezusfreeek> isn't it the case that rank-n types can't be inferred generally anyway?
21:47:04 <dolio> Well, this isn't the usual 'rank-2-types-won't-be-inferred' issue, though.
21:47:18 <dolio> As I understand it.
21:47:44 <dolio> It's that ($) takes two arguments, and you need to check the left one first to know you're supposed to instantiate the right one with an impredicative type.
21:47:50 <dolio> Or, a higher-rank type, that is.
21:48:14 <dolio> So for a while they let that happen.
21:48:42 <dolio> But that's arbitrary, because right-to-left is an equally valid choice, or something like that.
21:49:30 <Saizan_> that FPH paper claims to solve the problem of impredicativity requiring annotations only to lambdas, and eta-expansion in rare cases, iirc
21:50:02 <geezusfreeek> oh thanks for linking that
21:50:03 <dolio> Whereas they've since thrown the left-to-right instantiation out, and it no longer works.
21:50:07 <Cale> I wonder how exactly HML, MLF and FPH compare with one another.
21:50:19 <august> doh
21:50:26 <august> as i was saying
21:50:29 <august> lambda calculus, i remember learning about that way back in um... some point in high school
21:50:32 <august> when a took a class that was in scheme
21:50:52 <dolio> Impressive.
21:50:53 <Cale> HML is apparently a simplification and restriction of MLF
21:51:17 <august> i was reminded of that also because it was at berkeley
21:51:26 <Saizan_> they extend the type language though
21:51:32 * roconnor thinks that august isn't augustus
21:51:42 * august thinks that i'm me
21:51:49 <Cale> Oh, nice, the HΜL paper contains a table comparing them :)
21:51:51 <august> he's him*
21:52:08 <august> self
21:52:23 * sclv is shocked that august is not the august personality he had understood him to be.
21:52:41 <solrize> what's a simple example of an impredicative type ?
21:52:59 <ddarius> solrize: Types aren't impredicative.  Type systems are.
21:53:06 <Cale> roconnor: Augustsson, you mean?
21:53:28 <BMeph> dons: ping
21:53:36 <dolio> Yeah, I misspoke.
21:53:38 <roconnor> Cale: yes
21:53:59 <roconnor> Cale: I forget his nick
21:54:03 <geezusfreeek> dangit i've been talking type systems instead of working on my frp things
21:54:06 <ddarius> augusts
21:54:09 <Cale> augustss
21:54:22 <ddarius> What Cale said.
21:54:32 <roconnor> oh right
21:54:32 <Cale> (Probably an 8 character username limit somewhere)
21:54:33 <lament> augustsss
21:54:39 <geezusfreeek> augustssss
21:54:46 <roconnor> augustsssss
21:54:58 <geezusfreeek> > "august" ++ repeat 's'
21:55:00 <lambdabot>   "augustssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss...
21:55:04 <pumpkin> lol
21:55:09 <dolio> solrize: A type system is impredicative if you can instantiate a type variable with a type like 'forall t. t -> t'.
21:55:13 <august> anyway…
21:55:20 <pumpkin> > cycle "august"
21:55:22 <lambdabot>   "augustaugustaugustaugustaugustaugustaugustaugustaugustaugustaugustaugustau...
21:56:02 <solrize> ddarius, dolio, thanks.  dolio, that would mean F1 is impredicative?
21:56:02 <dolio> So you could have 'id : forall a. a -> a' and get 'id (forall b. b -> b) : (forall b. b -> b) -> (forall b. b -> b)'
21:56:40 <dons> BMeph: always here.
21:56:40 <laziest> > map ("august" ++) (iterate ('s':) [])
21:56:41 <lambdabot>   ["august","augusts","augustss","augustsss","augustssss","augustsssss","augu...
21:57:02 <BMeph> dons: But always awake? ;)
21:57:04 <august> this client made a smiley icon
21:57:05 <august> stupid...
21:57:06 <dons> nope.
21:57:16 <solrize> @hoogle fix
21:57:17 <lambdabot> Data.Function fix :: (a -> a) -> a
21:57:17 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
21:57:17 <lambdabot> module Control.Monad.Fix
21:57:27 <dolio> F1 is the simply typed lambda calculus, no?
21:57:43 <solrize> dolio, F1 = polymorphic STLC, i thought
21:57:46 <BMeph> dons: Anyway, I just wanted to clarify: that xosd works with X, right?
21:58:14 <dons> BMeph: right
21:58:23 <solrize> i'm still trying to grok your example
21:58:28 <dons> you need libxosd install of course
21:59:19 <solrize> but, it doesn't look valie, b is bound 2 separate times
21:59:26 <solrize> s/valie/valid
21:59:33 <BMeph> dons: Yet, it doesn't have a 'unix' dependency? I guess you could run it on OS X (no relation) as well, but still... :)
22:00:12 <dolio> It's a higher-rank type.
22:01:00 <solrize> i'm not reading it properly
22:01:04 <Saizan_> they are not in scope at the same time, anyway
22:01:48 <solrize> saizan, that's the point, they're independent of each other so that expression is uninhabited
22:02:14 <Saizan_> it could have been written "id (forall a. a -> a) : (forall b. b -> b) -> (forall c. c -> c)
22:02:27 <Saizan_> solrize: why?
22:02:31 <solrize> what's the : ?
22:02:38 <Saizan_> like :: in haskell
22:02:41 <solrize> ok
22:03:12 <Saizan_> :t \(x :: forall a. a -> a) -> x
22:03:13 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
22:03:17 <solrize> so the claim is you can choose b and c independently of each other and have id : b -> c  for arbitrary b and c
22:03:36 <Saizan_> no
22:04:05 <solrize> the last example makes senes
22:04:06 <Saizan_> (forall b. b -> b) is the same type as (forall c. c -> c), they are alpha-equivalent
22:04:07 <solrize> sense
22:05:36 <solrize> is (forall b. b->b) a type?
22:05:44 <solrize> i.e. is there a value of that type?
22:05:53 <dolio> Yes. The polymorphic identity function.
22:05:53 <Saizan_> yes
22:06:06 <lament> :t id
22:06:07 <lambdabot> forall a. a -> a
22:06:12 <Saizan_> \b:*,x:b -> x
22:06:13 <solrize> ok
22:06:32 <solrize> id id
22:06:34 <solrize> > id id
22:06:35 <lambdabot>       Overlapping instances for Show (a -> a)
22:06:35 <lambdabot>        arising from a use of `s...
22:06:40 <lament> solrize: it's id
22:06:41 <solrize> :)
22:06:45 <Saizan_> :t id id
22:06:46 <lambdabot> forall a. a -> a
22:07:02 <solrize> ic
22:07:04 <solrize> yeah
22:07:10 <solrize> where is the impredicativity?
22:07:22 <Saizan_> :t (id :: (forall b. b -> b) -> (forall c. c -> c)) id
22:07:23 <lambdabot> forall c. c -> c
22:07:39 <Saizan_> there, sort of
22:08:08 <Saizan_> it's less clear since in haskell we don't do type instantiation explicitly
22:08:16 <Saizan_> nor abstraction
22:08:46 <dolio> You can kind of get around it in the "id id" example.
22:08:49 <orbitz> can i search for a sublist in a list?
22:08:58 * BMeph thinks it would be awesome to be able to have a list of types...
22:09:05 <solrize> i thought impredicative meant self-referential in some way
22:09:22 <orbitz> BMeph: what woudl you do with a list of types?
22:09:36 <solrize> orbitz, you mean you want to find [3,4,5] in [1,2,3,4,5,6,7] ?
22:09:38 <geezusfreeek> :t let id = undefined :: forall a. a -> a in id id
22:09:39 <lambdabot> forall a. a -> a
22:09:49 <dolio> Since you can write something like: id id = /\a:*. \x:a -> id ((a -> a) -> (a -> a)) (id (a -> a)) x
22:09:50 <orbitz> solrize: specifically String
22:10:03 <solrize> @hoogle substring
22:10:03 <lambdabot> Data.ByteString breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
22:10:04 <lambdabot> Data.ByteString.Char8 breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
22:10:04 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
22:10:26 <Saizan_> solrize: ah, in that sense i'm not sure, but maybe it refers to the selfApp geezusfreeek pasted earlier
22:10:29 <solrize> orbitz i think there's a function like that but i'm not remembering.
22:10:41 <orbitz> solrize: i looked though Data.List but didn't see anything obvious
22:10:44 <solrize> @hoogle String->String->String
22:10:45 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
22:10:45 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
22:10:45 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
22:10:55 <solrize> @hoogle [a]->[a]->[a]
22:10:56 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
22:10:56 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
22:10:56 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:11:14 <Saizan_> geezusfre : i'm looking at: selfApp = \x:forall X.X->X. x [forall X.X->X] x; which has type (forall X. X->X) -> (forall X. X->X)
22:11:42 <orbitz> solrize: maybe String -> String -> Maybe String?
22:11:59 <dons> BMeph: it just needs libxosd
22:12:02 <orbitz> @hoogle String->String->Maybe String
22:12:03 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
22:12:04 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
22:12:04 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
22:12:20 <solrize> you could use a regexp :)
22:12:31 <orbitz> @hoogle [a]->[a]->Maybe [a]
22:12:32 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
22:12:32 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
22:12:32 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
22:12:34 <orbitz> solrize: you're evil
22:12:42 <FunctorSalad> orbitz: there's a package for the efficient algorithms http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stringsearch
22:12:47 <FunctorSalad> (for ByteString)
22:12:48 <lambdabot> Title: HackageDB: stringsearch-0.2.1.1, http://tinyurl.com/5b84x7
22:13:09 * orbitz is just using String
22:13:13 <sclv> isInfixOf
22:13:28 <sclv> > [1,2,3] `isInfixOf` [0,1,2,3,4]
22:13:30 <lambdabot>   True
22:13:38 <orbitz> solrize: ohhh!
22:13:40 <orbitz> err
22:13:42 <orbitz> sclv: oh!!!
22:13:58 <orbitz> thanks
22:14:05 <sclv> @hoogle [a] -> [a] -> Bool
22:14:05 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
22:14:06 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
22:14:06 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
22:14:16 <sclv> get the type signature right and hoogle comes to the rescue :-)
22:14:26 <pumpkin> what's the haskell convention for type names containing (common) acronyms?
22:14:39 <orbitz> sclv: haha
22:14:49 <pumpkin> for example, would HTTPMethod look bad?
22:15:17 <FunctorSalad> I don't like the look but I've seen it used that way
22:15:37 <orbitz> FunctorSalad: what would you prefer?
22:15:45 <FunctorSalad> maybe HttpMethod
22:15:45 <Saizan_> if it's in a HTTP module or something i'd just use Method
22:16:07 <FunctorSalad> yes, or that
22:16:09 <ddarius> @hoogle http
22:16:09 <lambdabot> package HTTP
22:16:10 <lambdabot> package HTTP-Simple
22:16:10 <lambdabot> Text.XHtml.Frameset httpequiv :: String -> HtmlAttr
22:16:18 <ddarius> @hoogle+
22:16:18 <lambdabot> Text.XHtml.Strict httpequiv :: String -> HtmlAttr
22:16:18 <lambdabot> Text.XHtml.Transitional httpequiv :: String -> HtmlAttr
22:16:18 <lambdabot> package lighttpd-conf
22:16:51 <ddarius> Anyway, that suggests the answer indirectly
22:17:25 <pumpkin> FunctorSalad, Saizan_: how about CpuType, or CPUType? I'm trying to structure types for binary processing
22:19:19 <Saizan_> from XHtml it looks like we go for camelCase even for acronyms
22:19:39 <FunctorSalad> @hoogle XML
22:19:39 <lambdabot> package xml
22:19:40 <lambdabot> package xml-parsec
22:19:40 <lambdabot> package xml2x
22:19:50 <Saizan_> and it looks better, imo
22:19:58 <FunctorSalad> @hoogle+
22:19:58 <lambdabot> package generic-xml
22:19:58 <lambdabot> package HaXml
22:19:58 <lambdabot> package libxml
22:20:02 <FunctorSalad> @hoogle+
22:20:36 <FunctorSalad> hmm
22:21:07 <pumpkin> hmm
22:21:09 <pumpkin> ok
22:21:14 <pumpkin> so I should go with CpuType
22:21:26 <pumpkin> so many decisions
22:25:16 <august> i like that way myself
22:29:38 <Giraffe> is it worth packing Strings into ByteStrings if i'm going to be doing a LOT of input and output?
22:29:50 <Giraffe> i know pack is O(n), so...
22:30:10 <Giraffe> basically it just seems like it'd shrink the size of the database
22:30:58 <Lemmih> Giraffe: You don't have to unpack the bytestring to do IO.
22:31:18 <dolio> solrize: The self-reference comes from the fact that in (forall a. t), the a ranges over things that themselves contain quantifications that range over all types, including the one you're defining.
22:31:32 <Giraffe> Lemmih, oh?
22:31:58 <Giraffe> so i can do putStrLn (B.pack "foo") and it'll work?
22:32:22 <Lemmih> Giraffe: B.putStrLn, yes.
22:32:28 <Saizan_> Giraffe: Data.ByteString has I/O functions for bytestrings
22:32:40 <Giraffe> huh!
22:32:55 <Giraffe> well imagine that :D
22:33:11 <Saizan_> so you can both read and write bytestrings directly
22:33:24 <Giraffe> that is absolutely awesome
22:35:10 <dons> Giraffe: either use bytestrings or strings
22:35:14 <dons> don't mix them, as a rule
22:35:18 <Giraffe> dons, gotcha
22:35:26 <dons> unpack should have a warning on it
22:35:40 <Giraffe> so for output, how would i do printing of messages?
22:35:52 <Giraffe> B.putStrLn and then...
22:35:59 <dons> yeah?
22:36:10 <Giraffe> well i mean would i need to use pack?
22:36:19 <dons> oh, you want a 'print' ?
22:36:21 <dons> :t print
22:36:22 <lambdabot> forall a. (Show a) => a -> IO ()
22:36:33 <Giraffe> print is nice but it parses newlines
22:36:39 <Giraffe> so it sometimes limits its helpfulness
22:36:45 <dons> i'm not sure what you're trying to do
22:36:48 <mauke> print parses nothing
22:36:59 <Giraffe> > print "Hello\nworld"
22:37:00 <lambdabot>   * Exception: "<IO ()>"
22:37:20 <dons> you want to do bytestring IO? so use the bytestring IO functions
22:37:27 <dons> do you need to parse or pretty print structures?
22:37:38 <dons> then using Data.Binary or the bytestring-show or bytestring-lexing package make sense
22:37:53 <Giraffe> mmk
22:38:07 <pumpkin> using ByteString and Data.Binary isn't bad, right
22:38:08 <pumpkin> ?
22:38:14 <dons> not bad at all
22:38:23 <pumpkin> I'm parsing a complex binary sturcture
22:38:28 <pumpkin> also, Data.Int for 64 bit ints?
22:38:32 <Giraffe> i should be using bytestrings instead of strings if i'm managing, say, a database of hundreds of records of books, right? :P
22:38:32 <pumpkin> Int64?
22:38:38 <dons> Data.Binary is designed for parsing binary structures efficiently
22:38:42 <dons> Giraffe: yes.
22:38:53 <dons> pumpkin: right
22:38:55 <mauke> hundreds? sounds small
22:38:56 <dons> use explicit sizes
22:39:09 <Giraffe> mauke, it's for managing e-books
22:39:11 <dons> Giraffe: so you need to parse some foreign format?
22:39:51 <Giraffe> dons, no, i just need to make sure that when a list of a hundred books gets spewed onto the screen the user doesn't have time to make coffee while it does that
22:40:19 <dons> oh, so just use bytestring io functions
22:40:35 <pumpkin> dons: can I make a list of types somehow? I have a binary structure that contains a list of "commands", and there's an int that specifies what kind of command follows... is there some way I can avoid a large (20ish items) case statement for constructing al the subtypes?
22:40:39 <Giraffe> bytestring is how i want to do that, but...if i want to just print a message telling the user what's going on, it seems silly do do B.putStrLn (pack ...)
22:40:46 <Giraffe> to do*
22:40:51 <dons> pumpkin: use Data.Typeable?
22:41:03 <pumpkin> ah, haven't seen that before, I'll go read about it
22:41:07 <dons> Giraffe: oh, sure. you could use String there.
22:41:09 <mauke> Giraffe: er, so use putStrLn "whatever"
22:41:17 <Giraffe> oh!
22:41:19 <dons> Giraffe: or use OverloadedStrings to avoid the need to pack
22:41:32 <Giraffe> i see, so for outputting messages it's ok
22:41:33 <dons> you're just dumping bytes into a handle. doesn't matter how they get there
22:41:41 <Giraffe> but you mean i shouldn't be doing something like...
22:41:50 <dons> dont' pass around big Strings
22:42:02 <Giraffe> well, adding a list like [ByteString foo, String bar] into the DB
22:42:05 <Giraffe> or the program in general
22:42:28 <Giraffe> that certainly makes sense
22:42:34 <dons> do you have a nice interface  to the DB defined?
22:42:39 <Giraffe> yeah
22:42:52 <dons> i'd probably use Data.Binary for all the DB access, or maybe a real DB binding like takusen
22:43:00 <dons> if you've got a real db on the other end
22:43:00 <Giraffe> i'm using HDBC
22:43:07 <Giraffe> with SQLite
22:43:28 <dons> ok.
22:43:35 <pumpkin> dons: how would the Typeable help with this? having representable types sounds nice but there don't seem to be examples of how to use it
22:43:37 <dons> now its all much clearer
22:43:52 <dons> pumpkin: you want to serialies values with their types?
22:44:00 <Giraffe> yeah, i mean the stuff is working fine, but i've only done tests of 3, 4, 5 entries
22:44:03 <dons> so that when you parse them back in your can dispatch to the correct instances?
22:44:11 <Giraffe> right
22:44:13 <pumpkin> dons: well, it's a predefined data format that I'm just loading in (and I can't change the format)
22:44:14 <dons> Giraffe: you'll probably be ok for the db.
22:44:18 <dons> hdbc's used in big systems
22:44:22 <Giraffe> but if i can use bytestring IO too, it's fine!
22:44:36 <pumpkin> dons: but otherwise, yeah, I just need some way to say "give me the type corresponding to the integer 14"
22:44:37 <Giraffe> i should've known about that
22:44:41 <vegai> John Goerzen talked about implementing an IMAP library in August
22:44:46 <vegai> anyone know if he wrote some code yet?
22:44:53 <Giraffe> it'd be a pretty useless string implementation if it couldn't work with IO :P
22:45:01 <dons>  vegai checked on hackage?
22:45:23 <dons> maybe ping john.
22:46:36 <ddarius> pumpkin: Just make a table and look it up.
22:46:55 <pumpkin> ddarius: that's what I was asking, how to stick a bunch of types into a list that I can !! into
22:48:09 <ddarius> pumpkin: You probably want a discriminated union type for this anyway, so there isn't any problem.
22:48:21 <pumpkin> :o
22:48:23 <ddarius> But if you don't, then you can use Dynamic which is related to Typeable.
22:49:17 <pumpkin> hmm
22:50:06 <pumpkin> how does a discriminated union type work?
22:50:40 <ddarius> data Foo = Bar Int | Baz String | Quux Char Int
22:50:48 <pumpkin> oh, that's what I was writing
22:51:14 <pumpkin> but I still don't know how to pick out the nth type constructor
22:52:04 <ddarius> If they are all homogenous, you just store them as functions in a table/list.  If they aren't all the same type, then store the parsing functions Data -> Foo.
22:53:35 <ddarius> Of course, if all the constructors take the same types, then you could just store a pair of that data and an enumeration.
22:54:03 <pumpkin> they don't all take the same type
22:58:28 <dons> ?users
22:58:28 <lambdabot> Maximum users seen in #haskell: 558, currently: 482 (86.4%), active: 9 (1.9%)
22:58:32 <Giraffe> hmm, dons, how would you recommend checking ByteStrings to see what they look like?
22:58:44 <Giraffe> for example, i have to parse input for a user's command
22:59:00 <Giraffe> so i'd have case inpStr of...what?
22:59:43 <dons> using head/tail and matching functions like isPrefixOf
23:00:04 <dons> foo x | pack "bar" `isPrefixOf` x = ...
23:00:18 <Giraffe> ahh
23:00:35 <roconnor> view patterns?
23:00:45 <Enzo_H> Hello. I have recently developed a function parser that many people in the community may find to be quite useful. How do I go about posting this parser on haskell.org?
23:00:50 <dons> would love to see an example, roconnor. but i expect yes, they might help
23:01:01 <dons> Enzo_H: just create a new package on the wiki
23:01:10 <dons> then perhaps mention it on the haskell reddit
23:01:18 * roconnor hasn't used view patterns
23:01:28 <Enzo_H> dons thanks
23:02:32 <ddarius> You could write foo (isPrefixOf "bar" -> True) = ... but that would be ugly
23:03:00 <dolio> , let zipWith f ((f -> g) : (zipWith f -> h)) ((g -> c) : (h -> cs)) = c : cs in zipWith (+) [1..10] [11..20]
23:03:07 <lunabot>  luna: <interactive>:1:54-124: Non-exhaustive patterns in function zipWith
23:03:42 <dolio> , let zipWith _ [] _ = [] ; zipWith _ _ [] = [] ; zipWith f ((f -> g) : (zipWith f -> h)) ((g -> c) : (h -> cs)) = c : cs in zipWith (+) [1..10] [11..20]
23:03:44 <lunabot>  [12,14,16,18,20,22,24,26,28,30]
23:04:37 <ddarius> Such a great improvement over: zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys ...
23:05:32 <dolio> Totally.
23:06:07 <pumpkin> http://hpaste.org/12273 this is my first real chunk of haskell code and I was wondering if anyone could comment on it (style, naming, indentation, punctuation, module naming and so on)... the idea is to load the Mac OS object format into a usable format in haskell (and these are a few of the types that would be doing that)
23:09:06 <vegai> pumpkin: SubUmbrellaCommand { subUmbrella :: B.ByteString }  et al could perhaps be just SubUmbrellaCommand B.ByteString
23:10:09 <pumpkin> that makes sense
23:10:25 <pumpkin> that means the only way to extract the string would be pattern matching, right?
23:11:14 <Saizan_> right
23:11:32 <Saizan_> maybe you could drop the Command suffix
23:11:51 --- mode: ChanServ set +o glguy
23:11:57 --- mode: glguy set -b %testingaaa!*@*
23:12:02 --- mode: glguy set -o glguy
23:12:15 <ddarius> matchPrefix prefix bs | prefix `isPrefixOf` bs = Just $ drop (length prefix) bs | otherwise = Nothing -- reference implementation
23:14:41 <pumpkin> Saizan_: sounds good, I'll merge some things too
23:17:19 <pumpkin> also, is there some way to use the same function name to access two different attributes? I could do flags (MachO machO) = foo ; flags (Segment seg) = bar, but if I do it in the curly brackets it complains about a duplicate function
23:17:30 <pumpkin> *two different attributes on different types
23:21:15 <august> ghc is on macports?
23:21:24 <pumpkin> yeah, but an older version
23:21:24 <yuuki> Yes
23:21:33 <Saizan> pumpkin: you've to define them in different modules, or use a typeclass
23:21:34 <yuuki> 6.10.1 is there
23:21:44 <pumpkin> there's a package on the ghc site with the latest version that also doesn't require compiling from scratch
23:21:56 <pumpkin> yuuki: hmm, I could've sworn I got 6.8 from macports yesterday
23:22:10 <pumpkin> without explicitly requesting an older version
23:22:13 <august> i like that ports compiles
23:22:18 <yuuki> I definitely have 6.10.1
23:22:21 <pumpkin> :o
23:22:29 <august> ghc                            lang/ghc       6.8.3        The Glorious Glasgow Haskell Compilation System
23:23:24 <dons> you'd want 6.8.x or 6.10
23:23:30 <dons> august: looks good
23:23:58 <yuuki> pumpkin, I also got my copy from macports
23:24:03 <yuuki> did you do a selfupdate?
23:24:19 <pumpkin> yuuki: I thought mine was up to date, let me check
23:24:21 <august> no, it failed :(
23:24:30 <august> $ sudo port selfupdate Password: Error: /opt/local/bin/port: port selfupdate failed: Couldn't sync the ports tree: Synchronization the local ports tree failed doing rsync
23:24:47 <pumpkin> maybe reinstall macports
23:25:17 <august> 6.8 is fine for starting out
23:25:38 <pumpkin> august: port sync
23:25:42 <pumpkin> and it'll have 6.10 :P
23:25:45 * pumpkin feels stupid now
23:26:02 <pumpkin> I spent an hour compiling ghc 6.8 on my macbook air yesterday and then just deleted it
23:26:10 <august> it's installying 6.8.3 right now
23:26:15 <august> -y
23:26:18 <dons> pumpkin: good for testing your cpu
23:27:03 <august> it's installing perl?
23:28:06 <pumpkin> august: do 6.10!!!
23:28:08 <pumpkin> :P
23:29:07 <august> after it finishes building perl5.8
23:29:14 <pumpkin> o.O
23:31:27 <Cale> Why would you compile GHC yourself? Are you hacking on it?
23:31:48 <dolio> Readline support?
23:32:01 <august> $ sudo port sync Password: port sync failed: Synchronization the local ports tree failed doing rsync
23:32:04 <vegai> some weaker operating systems don't support large sets of precompiled binary packages
23:32:14 <Cale> dolio: Ah, there's a good point.
23:32:18 <august> cale: that's how mac ports does it
23:32:28 <Cale> august: You don't need to get GHC from macports.
23:32:39 <Cale> august: There's a nice package available from the GHC website.
23:33:11 <august> why are people so adverse to compling?
23:33:34 <august> especially when it's all done for you
23:33:37 <Cale> Because it wastes time and electricity.
23:34:05 <august> so does this argument
23:34:12 <Cale> If there are already binaries which are available for your platform, then download those. If not, you should contribute what you build.
23:34:17 <sjanssen> august: not nearly as much as compiling something :)
23:34:41 <sjanssen> also, you'll never have an unexpected compile error with a binary
23:35:07 <sjanssen> back when I used a Mac, I recall build failures with several different packages
23:35:32 <august> sjanssen: macports hardly ever errors out
23:35:44 <Cale> http://haskell.org/ghc/download_ghc_6_10_1.html#macosxintel
23:35:45 <lambdabot> Title: GHC: Download version 6.10.1
23:35:47 <august> it has already calculated all the dependencies
23:36:08 <dons> simple complexity. have one person compile it once, rather than trying to set up the build environment O(n) times.
23:36:30 <august> why are there 2 there
23:36:31 <dons> if your goal is to get the code running on as many machines as possible, removing failure points like that is the obvious thing to do
23:36:34 <sjanssen> august: the problem is that every single machine potentially has a different configuration of packages
23:36:54 <sjanssen> august: so it might build on my machine, but fail on yours
23:36:58 <dons> we've been thinking about this a lot of late, august :) so you triggered a hot topic
23:37:08 <sjanssen> Gentoo has this problem in spades
23:37:10 <august> sjanssen: they potentially have missing libraries that are needed
23:37:13 <august> as that page says
23:37:33 <dons> there's 888 haskell libraries on hackage now. they've appeard mostly this year. that gets people thinking about compilation and distribution
23:37:39 <Cale> You probably want the .pkg installer, if I'm not mistaken.
23:38:08 <august> i've found that more often than not that the official release of whatever is missing nice features because it has to be too generic
23:38:27 <Cale> august: Really? More often than not?
23:38:29 <august> readline
23:38:36 <august> is usually the missing piece
23:38:41 <sjanssen> august: yes, this can be a problem.  Luckily GHC doesn't have to many optional things
23:39:17 <Cale> libedit2 isn't *so* bad, once you make sure to add a config file...
23:39:42 <august> that's not a very good argument
23:39:46 <Cale> Though I've heard the problems were worse on mac.
23:40:14 * Cale checks the bug tracker to see if there's been any progress.
23:41:20 <dons> readline was replaced because it has the wrong license
23:41:29 <dons> editline is adequate, but there's not a good standard distribution of it.
23:41:40 <dons> so the user experience can be poor on some systems, without configuration
23:41:59 <dons> in particular, some systems have an old version of editline , (i think the mac might be in this category)
23:42:41 <Cale_> Was there some kind of legal threat involving readline?
23:42:50 <Cale_> Or just a potential one?
23:43:52 <august> dons: good thing mac ports installs the latest versions of tools it knows about
23:44:54 <Lemmih> Cale: How do you add a config file?
23:44:55 <dons> Cale: no thread, just wrong license
23:45:04 <dons> threat.
23:45:18 <august> yep, it installed the newest readline
23:45:26 <august> 5.2
23:46:54 <vegai> editline seems to have an advantage over readline. ghci compiled against it remembers your previous history
23:47:01 <vegai> could be just a configuration issue, though.
23:47:20 <august> ipython remembers your previous history just fine
23:47:33 <Cale> Lemmih: vim .editrc and add a line:  bind '^[[3~' ed-delete-next-char
23:47:39 <vegai> ok, so they just hadn't implemented that before 6.10
23:47:41 <Cale> Lemmih: It fixed the delete key for me.
23:47:55 <august> ah yes
23:48:03 <august> the delete key is special on macs
23:48:29 <august> i have to use ^H in screen when ssh'd into linux boxes sometimes
23:48:58 <Lemmih> Cale: Ah! That has been annoying the crap out of me.
23:49:54 <Saizan> Cale: no way to make it grok utf-8, right?
23:49:55 <Lemmih> Cale: Got any fixes for shift-left, shift-right?
23:50:25 <Cale> Lemmih: ?
23:51:50 <Lemmih> Cale: Moving the cursor to the next/previous word.
23:52:05 <august> meta-f
23:52:15 <august> :D
23:53:26 <Lemmih> Cale: Nevermind, found the man page.
