00:00:01 <ski> ok
00:00:07 <omy> yep :)
00:00:23 <TSC> BeelsebobWork: Make sure the program terminates properly, or the prof file might be empty
00:00:34 <ski> try grouping the `ln (x^x)' with the `- x', and mutatis mutandis for the two other terms ..
00:00:46 <BeelsebobWork> TSC: oh! I know what it'll be
00:00:53 <BeelsebobWork> GLUT programs never terminate correctly
00:00:54 <BeelsebobWork> even if they do
00:01:05 <BeelsebobWork> they just call exit, and dump everything :(
00:01:12 <ben_h> seeya folks
00:01:13 <TSC> Really?
00:01:29 <rwbarton_> what if you call exitWith yourself?
00:01:41 <TSC> They don't exit the glut loop and continue whatever called the loop-starter?
00:03:11 <omy> ski : i've tried that... but can't figure out a way to group only ln(x^x) and -x without affecting other parts too...
00:03:18 <rwbarton_> omy: if x > y then this equation is equivalent to (log x - log y) / (x - y) >= 1 / x; this is a statement about calculus...
00:04:08 <omy> rwbarton_, but x doesn't need to be greater than y... it can, but it doesn't have to.
00:04:13 <rwbarton_> sure, whatever.
00:04:28 <rwbarton_> I'm saying that you need to use some calculus to do this
00:04:36 <rwbarton_> I mean, what are you going to do with log anyways?
00:04:58 <omy> at least, that's a start point for me...
00:05:19 <omy> i'm completly new to this... i'm just starting to learn it... :)
00:05:33 <omy> now i know i need to go look into calculus...
00:05:38 <omy> :)
00:15:16 <ski> @check \x -> x >= 0 ==> x^2 >= 0
00:15:17 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
00:15:17 <lambdabot>           ...
00:15:20 <ski> ?
00:15:25 <kosmikus> Taejo: oh, I only now realize who you are. Have you become a Haskell programmer after all?
00:19:46 <Taejo> kosmikus: are you confusing me with someone else? I've been dabbling in Haskell for ages
00:20:13 <Taejo> well, over a year
00:26:02 <surrealization> hi room, I'm trying to install ghc-core with cabal but I get the error message Module `System.Process' does not export `readProcess'
00:26:14 <surrealization> ghc 6.8.2 ghc-core 0.4.1
00:26:31 <surrealization> linux i386 (fedora 9)
00:39:28 <alc> hmm, that can be reduced to: ln(t) + 1/t >= 1
00:40:08 <alc> where t = x/y
00:40:15 <sandbox> will using destructive updates in King's dfs use substantially less space than with a set?
00:49:47 <mdmkolbe> I'm trying to build a cabal package, but I've run into this error "Prelude> :m System.PAPI
00:49:47 <mdmkolbe> module main:System.PAPI is not loaded" What does it mean?
00:51:19 <lispy> mdmkolbe: do you mean :m + System.PAPI ?
00:51:59 <mdmkolbe> lispy: that also gives the same errro
00:52:18 <lispy> I don't know then
00:54:04 <mdmkolbe> Hmm, it looks like http://www.haskell.org/pipermail/glasgow-haskell-bugs/2007-February/007300.html explains what is going on
00:54:06 <lambdabot> Title: [GHC] #1125: "module main:Foo is not loaded" when trying to load a module from a ..., http://tinyurl.com/6xcmqm
00:54:52 <rwbarton_> that was more or less my guess, although I don't understand the last paragraph
00:55:48 <Taejo> what are the disadvantages of -funbox-strict-fields?
01:02:33 <therp> JaffaCake1: you pinged me yesterday, because of the ghc -shared issue?
01:03:09 <JaffaCake1> yeah - is it the patch I pointed out in the ticket?
01:03:10 <therp> JaffaCake1: yes, my patch is wrong/inverse. that should be !defined instead of defined
01:03:18 <JaffaCake1> right, thanks
01:03:24 <therp> JaffaCake1: but I agree, we need some test cases here
01:03:45 <JaffaCake1> just a simple 'ghc -shared Foo.hs' test would be useful
01:04:35 <therp> JaffaCake1: that would be covered anyway by a buildbot that does "./configure --enable-shared"
01:05:07 <JaffaCake1> right, but we don't have that working on Win yet
01:09:20 <therp> JaffaCake1: that shouldn't prevent us from making progress on linux/elf.
01:09:42 <JaffaCake1> right
01:20:33 <vegchef> i tripped over the fact that (case X of Y -> Z) and (let Y = X in Z) are not the same. can you give me a familiar or natural example that would break if the definition of 'let' didn't contain the irrefutability tildes.
01:21:30 <Peaker> vegchef: I think case simply always forces the expression, whereas let only forces those expressions that are needed in the "in" clause.
01:22:15 <Peaker> vegchef: I think the ~ irrefutability means that even when you do use an element of a pattern in the "in" clause, it will still be lazy, until it too is forced
01:30:15 <sjanssen> vegchef: is there a good reason for let and case to be the same?
01:31:14 <dolio> If let evaluated things like case, then irrelevant stuff in a let could change the value of the expression.
01:31:34 <dolio> 5 /= let x :: Int ; x = x + 1 in 5
01:31:41 <dolio> For instance.
01:32:40 <rwbarton> > case undefined of _ -> 3
01:32:41 <lambdabot>   3
01:32:44 <rwbarton> > case undefined of x -> 3
01:32:45 <lambdabot>   3
01:33:20 <rwbarton> I guess there's no difference unless patterns with constructors in them are involved
01:34:02 <dolio> 5 /= let x :: Int ; (x + 1) = x + 1 in 5 -- :P
01:35:11 <Peaker> dolio: does that compile?
01:35:12 <dolio> Anyhow, case evaluates things when it has to, and let never has to.
01:36:07 <dolio> Technically I guess case evaluates some things it doesn't have to, but that's the way the cookie crumbles.
01:36:24 <Peaker> If you have:  let f Nothing = 5 ; f (Just x) = (x+1) ; in f blah            is it different at all from:   case blah of Nothing -> 5 ; Just x -> x+1 ?
01:36:59 <rwbarton> dolio: what things does it evaluate that it doesn't have to?  Like   case b of True -> 3; False -> 3  ?
01:37:21 <Peaker> @src seq
01:37:22 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:37:31 <dolio> > case undefined of (x, y) -> 5
01:37:32 <lambdabot>   * Exception: Prelude.undefined
01:37:53 <Peaker> will this work?   seq x y = case x of _ -> y
01:38:25 <quicksilver> Peaker: To answer you "f blah" question, those are not different. function definitions are case.
01:38:30 <dolio> It's not necessary to evaluate that undefined to determine which branch of the case to take, but it gets evaluated anyhow.
01:38:49 <sandbox> can anyone tell me why this takes so much memory?   http://hpaste.org/11810
01:38:50 <quicksilver> Peaker: to answer your second question, no, that's not seq.
01:38:52 <Peaker> quicksilver: so a "let" that happens to define a function is actually a "case"? Or does it take having more than 1 pattern?
01:39:04 <quicksilver> Peaker: seq is not definable in haskel.
01:39:05 <sandbox> dfs stolen from King and Launchbury paper
01:39:16 <quicksilver> Peaker: well, no not really. It's still a "let" at the top level.
01:39:18 <Kvasir> what is seq?
01:39:29 <quicksilver> Peaker: it's just defining an "f" which uses "case"
01:39:32 <Peaker> quicksilver: why does "case x of _ -> y"  not do what seq does?
01:39:45 <quicksilver> Peaker: case only evaluates enough to match the constructors in the pattern
01:39:50 <Peaker> quicksilver: oh
01:39:56 <quicksilver> "_" has no constructors => no evaluation at all.
01:39:59 <sandbox> on a graph with a few hundred thousand nodes it takes GBs
01:40:13 <quicksilver> Kvasir: seq is a primitive to force WHNF evaluation.
01:40:14 <dolio> rwbarton: If you consider the reason that case "has to" evaluate things is that it needs to decide which of multiple branches to take, which is, I think, a convenient way of thinking about it.
01:40:45 <quicksilver> dolio: case always confirms that the value matches the pattern.
01:40:48 <Kvasir> WHNF?
01:40:59 <quicksilver> and does enough evaluation to confirm that.
01:41:00 <dolio> Whereas a let never branches, so there's no need to do evaluation.
01:41:07 <quicksilver> dolio: (I know you know this, I'm just giving another way to say it)
01:41:11 <Peaker> quicksilver: so it is only possible to force things in Haskell if you know their contents (both case and strictness annotations), or by using the magic ones (seq and seq-based)?
01:41:31 <quicksilver> Peaker: strictness annotations are more closely related to seq than case.
01:41:45 <quicksilver> Peaker: that is, strictness annotations would not be expressible in "haskell-without-seq"
01:42:02 <quicksilver> @go haskell whnf
01:42:05 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Laziness
01:42:08 <quicksilver> Kvasir: ^^
01:42:34 <Kvasir> thanks
01:42:56 <Peaker> quicksilver: but doesn't that mean I can implement seq via strictness annotations?
01:43:14 <quicksilver> seq !x y = y
01:43:15 <quicksilver> I think.
01:43:45 <dolio> Looks right to me.
01:44:28 <dolio> > (case undefined of Nothing -> 1 ; Just _ -> 2) `seq` ()
01:44:29 <quicksilver> or {data Dummy a b = Dummy !a b; seq x y = case Dummy x y of {Dummy x y -> y} }
01:44:30 <lambdabot>   * Exception: Prelude.undefined
01:44:38 <Peaker> I hope that 20 years from now, someone will have written a CSE/strictness heuristic runtime that makes strictness and sharing specifications unnecessary
01:44:57 <quicksilver> @faq will haskell have solved the halting problem in 20 years, as Peaker hopes?
01:44:57 <lambdabot> The answer is: Yes! Haskell can do that.
01:45:05 <Peaker> quicksilver: :)
01:45:24 <Peaker> Humans are doing heuristics, hopefully in 20 years, computers will do these heuristics at least as good ;)
01:46:49 <Peaker> Except humans don't generally have access to rich runtime data and sophisticated platform-dependent tricks, whereas this system will have
01:47:39 <ibid> and except humans know what they intend, whereas the system will have to guess
01:48:08 <Ferdirand> humans are all about platform-dependent tricks !
01:48:12 <unenough> humans know waht they intend?
01:48:28 <Axman6> they pretend to
01:48:33 <unenough> not even
01:49:05 <ibid> they usually know what they intend. of course, the system will have the additional trouble that the program probably doesn't reflect the humans' intentions :)
01:49:14 <Peaker> ibid: I think that's the essence of high-level languages -- communicating intent, rather than the "how"
01:50:06 <ibid> Peaker: yes, high level languages communicate more of the intent than the low level languages. no, high level languages do not communicate the *whole* intent
01:50:11 <Peaker> ibid: it might mean, indeed, that we will have to specify high-level information about our expectation of performance.. We already do this when we choose the appropriate data structures, but we might also use annotations (which would be better as they are more general than strictness annotations)
01:50:59 <Peaker> ibid: whenever an intention has to be "guessed", just propagate this to the source level and require high-level annotations
01:51:37 <ibid> Peaker: and once you've managed that, someone'll come to #haskell and express the hope compilers will be in twenty years smart enough to do without those annotations :)
01:51:53 <Peaker> Also, a runtime system such as that, if it is part of the whole computing platform (and thus shared amongst all of the code executing on a computer) can mean more efficient resource management (If a resource is now more scarce, it may dynamically change the strictness or sharing behavior)
01:54:44 <BeelsebobWork> :/ is it just me or are profiles wildly inaccurate in ghc 6.10.1?
01:54:57 <BeelsebobWork> I'm getting it reporting spending 470% of my time in SYSTEM
01:55:05 <BeelsebobWork> and 1200% of my time in the garbage collector
01:55:12 <quicksilver> that sounds a bit bogus.
01:55:17 <profmakx> four-and-a-half times the fun!
01:55:18 <quicksilver> sounds like you want to report it to g-h-u
01:55:31 <BeelsebobWork> k, will do
01:55:33 <quicksilver> I guess the parallel GC is pretty efficient if it can use 1200% runtime.
01:55:37 <BeelsebobWork> hehe
01:55:50 <BeelsebobWork> especially while only using 1 CPU according to activity monitor
01:55:53 <Taejo> If anyone's interested in my take on the mean/multiple-folds issue, take a look at http://squing.blogspot.com/2008/11/beautiful-folding.html
01:55:54 <lambdabot> Title: The Most Fuun You Can Have: Beautiful folding
01:56:01 <vegchef> what still bugs me a bit are the default (forced) tildes in the report's definition of 'let'. dolio gave an example (thanks). the tildes are there so i can write (let (x,y) = undefined in 5). mmh.
01:56:04 <BeelsebobWork> in fact, 1200% in a 4 core system is pretty impressive even if it is multi-threading
01:56:05 <quicksilver> BeelsebobWork: I keep hitting frustrating 'minor issues' scaffolding openGL onto reactive.
01:56:12 <BeelsebobWork> quicksilver: hmm?
01:56:20 <quicksilver> BeelsebobWork: latest one is I already have a Behaviour (Int,Int) for mouse position
01:56:23 <quicksilver> that works well
01:56:27 <BeelsebobWork> uhhuh
01:56:33 <quicksilver> but if I want to translate that into world coords
01:56:40 <quicksilver> I have to use unProject, which is embedded in IO
01:56:50 <quicksilver> and it's not entirely obvious how often you have to call it
01:56:55 <quicksilver> (any time any of the matrices changes)
01:57:07 <quicksilver> which means I have to model all my matrices in a reactive way probably.
01:57:12 <quicksilver> which is frustrating, for a minor feature ;)
01:57:21 <BeelsebobWork> what you could do I guess is translate (1,1) into world coords
01:57:27 <BeelsebobWork> and then use that as a basis for offsetting the rest
01:57:31 <BeelsebobWork> and redo it in your reshape function
01:57:40 * quicksilver nods
01:57:44 <quicksilver> it's not just reshape though
01:57:50 <BeelsebobWork> oh, neither it is
01:57:51 <quicksilver> it's any function which might cause the view to pan or scan
01:57:53 <BeelsebobWork> yeh, that's really not ideal
01:57:54 <quicksilver> or zoon
01:57:55 <quicksilver> zoom.
01:57:57 <BeelsebobWork> yep
01:58:16 <quicksilver> well clearly the right answer is a proper reactive model of my whole modelview transform.
01:58:17 <BeelsebobWork> hmm, that's deffinately one to poke conal about
01:58:24 <quicksilver> I'll look in his opengl scaffold
01:58:27 <BeelsebobWork> oh, yeh
01:58:27 <quicksilver> I bet he solved it .
01:58:58 <BeelsebobWork> the biggest problem I think you'll hit atm is if you start trying to deal with mouse clicks or keyboard input...
01:59:07 <BeelsebobWork> you won't get events, until the next event comes in
01:59:13 <BeelsebobWork> because there's a lazyness issue at the moment
01:59:17 * quicksilver nods
01:59:30 <quicksilver> I have seen a related bug in my implementation.
01:59:40 <quicksilver> quite hard to get this perfectly right.
01:59:48 <BeelsebobWork> I think camio has ideas on how to solve it, but I'm not sure how conal feels about his solution
01:59:53 <BeelsebobWork> yeh -- it's really rather subtle
02:00:03 <BeelsebobWork> it'll be so so sweet when it's all set up right, and working nicely
02:00:23 <quicksilver> I need to clean up my 'ticker' events too
02:00:34 <quicksilver> currently my 'ticker' events use threadDelay which is not accurate
02:00:36 <BeelsebobWork> did you see my code for the demo of my obj loader? -- reactive makes it really rather lovely
02:00:40 <quicksilver> really they should use precise times.
02:00:41 * quicksilver nods
02:00:43 <BeelsebobWork> oh, yeh
02:00:44 <quicksilver> yes, it looked nice :)
02:00:52 <BeelsebobWork> threadDelay is not fun
02:01:28 <quicksilver> but a pure timed event has no wakeup property
02:01:39 <quicksilver> so a pure timed event won't "kick" your event pump
02:01:40 <BeelsebobWork> no, which is difficult
02:01:50 <quicksilver> unless you happen to have a sufficiently regular stream of other events
02:01:55 <quicksilver> which might be ok for some programs.
02:02:10 <BeelsebobWork> it rather relies on the user continuously moving the mouse
02:02:16 <quicksilver> for example, if I'm redrawing the screen N times a second any way, using GLUT timer events
02:02:23 <quicksilver> then that kicks my event pump once each frame anyway
02:02:28 <quicksilver> and that might be good enough.
02:02:43 <BeelsebobWork> yeh, I think that's what conal's binding does
02:02:55 <BeelsebobWork> although it only actually redraws if the value of the behavior has changed I think
02:04:40 <BeelsebobWork> oh cool -- that appears to have been a good patch -- I managed to gut memory usage on my uber-taxing huge obj model from 2.3GB down to 235MB
02:05:18 <quicksilver> \o/
02:05:21 <BeelsebobWork> that's probably close to the limit -- the obj file is 200MB
02:05:27 <quicksilver> BeelsebobWork: I'm redrawing every frame in this particular app
02:05:35 <quicksilver> because it's safe to assume the screen has always changed.
02:05:43 <quicksilver> but of course that isn't suitable for all programs.
02:05:53 <quicksilver> sometimes you really don't want to waste time redrawing if there is no need.
02:05:56 <BeelsebobWork> indeed
02:06:09 <BeelsebobWork> anything that's just a standard GUI you only really want to redraw when stuff changes
02:06:20 <quicksilver> I'm also trying to come up with primitives for attracting animated GUI elements
02:06:29 <quicksilver> subtle stuff like mouseovers which fade in over a short time
02:06:33 <BeelsebobWork> if you watch the GL driver monitor in OS X -- the GUI usually actually only swaps its buffers at about 4fps
02:06:36 <BeelsebobWork> even when you move the mouse
02:06:53 <BeelsebobWork> yeh -- that'd be really lovely
02:06:54 <quicksilver> the mouse is probaby hardware isn't it?
02:07:13 <BeelsebobWork> yeh, but that's still gonna show up in the graphics card driver
02:07:30 <quicksilver> reactive really makes you think about subtle stuff
02:07:34 <BeelsebobWork> yeh
02:07:37 <quicksilver> if you have an element fading in an out
02:07:38 <BeelsebobWork> which is annoying atm
02:07:40 <quicksilver> at which point is it clickable?
02:07:43 <dolio> vegchef: I think the appropriate way to think about it is what each is for. let is for giving things convenient local names, and case is for expressing control flow. Since the latter potentially requires examining data to see which pattern it conforms to, it obviously needs to evaluate things, while the former doesn't.
02:07:46 <Peaker> quicksilver: you don't have a Monad instance for Reactive/Events - how can you choose a reactive/event source based on other reactive/event sources?
02:07:57 <quicksilver> Peaker: I have 'joinE'
02:08:01 <quicksilver> which is "most of a monad instance"
02:08:02 <BeelsebobWork> Peaker: sure you have a monad instance
02:08:09 <quicksilver> BeelsebobWork: *I* don't
02:08:12 <BeelsebobWork> oh, I see
02:08:14 <Peaker> quicksilver: why do you have a comment questioning its reasonability as a Monad instance?
02:08:21 <BeelsebobWork> but -- return for events is *really* easy
02:08:29 <BeelsebobWork> join is the really subtle nasty one
02:08:29 <quicksilver> BeelsebobWork: I have that too.
02:08:34 <quicksilver> (I have a full Applicative instance)
02:08:37 <quicksilver> I just haven't joined the dots.
02:08:39 <dolio> The fact that let is defined in terms of case and irrefutable patterns (which assert the inherent non-branchiness of let) is kind of incidental.
02:08:42 <BeelsebobWork> oh, okay
02:08:53 <quicksilver> Peaker: because I question its reasonability ;)
02:09:06 <Peaker> quicksilver: does it not hold up to the monad laws?
02:09:29 <dolio> (Although understanding why irrefutable patterns delay evaluation is similar, I suppose.)
02:09:29 <quicksilver> well, it does except for annoying concerns about the ordering of simultaneous events
02:09:52 <Peaker> why is it important to have simultaneous events? Why not have total ordering between all events?
02:10:00 <quicksilver> because you generate events from other ones
02:10:04 <quicksilver> using, e.g., fmap
02:10:11 <quicksilver> and then you get simultaneous ones.
02:10:14 <BeelsebobWork> indeed
02:10:26 <quicksilver> (fmap show e) is simultanous with (e) at all points
02:10:28 <quicksilver> (obviously!)
02:10:37 <BeelsebobWork> and even if you make fmap introduce an infinitely short delay, you still have problems
02:10:40 <Peaker> and then if you have inconsistent ordering between them, what are the consequences?
02:10:49 <BeelsebobWork> which of (fmap show e) and (fmap read e) comes first?
02:10:53 <quicksilver> a failure to meet a strict reading of the monad laws.
02:11:01 <quicksilver> it may not be *that* important.
02:11:12 <quicksilver> but if you construct a 'Reactive' out of the Event
02:11:15 <quicksilver> it gets pretty odd
02:11:25 <quicksilver> because which one comes last, holds sway for a long period of time
02:12:08 <quicksilver> 0 `Stepper` ( ((+1) `fmap` e) `mappend` ((+5) `fmap` e) )
02:12:13 <BeelsebobWork> quicksilver: incidentally, I believe what's causing the hold up with the lazyness issue is a strict reading of the functor laws
02:12:17 <quicksilver> ^^ the mappend of two simultaneous events.
02:12:20 <BeelsebobWork> the functor laws say you *can't* be lazy
02:12:23 <quicksilver> which one "wins"
02:12:24 <Peaker> quicksilver: Yeah, I understand now
02:12:27 <quicksilver> in the sense of coming last...
02:12:32 <quicksilver> makes a long term distance.
02:12:35 <BeelsebobWork> because then fmap id _|_ = _|_ `Stepper` _|_
02:12:40 <Peaker> quicksilver: so you want to have a consistent left-bias there
02:12:46 <quicksilver> Peaker: yes, almost certainly.
02:13:00 <quicksilver> Peaker: but then you need that bias to be consistently preserved by the monad operations too.
02:13:09 <quicksilver> which is not impossible to achieve, surely
02:13:14 <quicksilver> but it means you have to be very careful.
02:13:19 <Peaker> quicksilver: using threads under the hood it sounds very difficult
02:13:25 <quicksilver> Peaker: yes, it is.
02:13:49 <BeelsebobWork> yeh, joinE is pretty much the centre of all the subtleties and nastyness in trying to implement reactive totally right
02:13:55 <quicksilver> one of conal's key objectives is to get a correctly deterministic mappend.
02:14:11 <Peaker> The problem with the non-threaded implementations was the caching/sharing of reactive values, right?
02:14:23 <quicksilver> BeelsebobWork: I have always taken the view that "laws" only apply to the total fragment of haskell
02:14:36 <quicksilver> BeelsebobWork: and you're allowed to ignore their effect on _|_-rich values.
02:14:44 <BeelsebobWork> hmm, interesting view
02:14:59 <BeelsebobWork> I suspect a reasonable one too
02:15:11 <BeelsebobWork> because in reality _|_ *does* equal _|_ `Stepper` _|_
02:15:17 <BeelsebobWork> because it's the only value it could ever be
02:15:54 <quicksilver> an alternative view is not to exclude _|_ entirely, but to exclude 'seq' from your observational equivalence
02:16:09 <quicksilver> and decide something satisfies a law if you can't tell it apart using the primitives you have
02:16:14 <quicksilver> (and seq isn't one of them)
02:16:32 <quicksilver> You presumably can't distinguish (_|_) and (_|_ `Stepper` _|_) without seq.
02:16:40 <quicksilver> I didn't think that through without saying it.
02:16:45 <quicksilver> s/without/before/
02:16:47 <quicksilver> damn words!
02:16:48 <vegchef> dolio: thanks
02:16:51 * BeelsebobWork ponders
02:17:00 <BeelsebobWork> no, I don't think you can tell the difference
02:18:22 <BeelsebobWork> hmm, Ivan is saying OpenCL comes out next month
02:18:26 <BeelsebobWork> that should win
02:19:48 <Axman6> who's Ivan?
02:20:01 <BeelsebobWork> a guy I work with
02:20:06 <rog_> @pl (\ mv -> mv >>= return . (,) 1)
02:20:06 <lambdabot> ((,) 1 `fmap`)
02:20:16 <BeelsebobWork> apparently that's Khronos' deadline for it, so they may yet fuck up
02:20:33 <rog_> hmm. i don't understand that transformation...
02:20:59 <BeelsebobWork> looks sensible to me -- you take the value in mv
02:21:00 <jsn> CL is what?
02:21:02 <BeelsebobWork> you extract it in the bind
02:21:05 <BeelsebobWork> you pair it with 1
02:21:07 <BeelsebobWork> and you return it
02:21:13 <BeelsebobWork> i.e. you run pair with 1 inside the value mv
02:21:18 <BeelsebobWork> which is fmap
02:21:22 <BeelsebobWork> jsn: ComputeLanguage
02:21:30 <jsn> interesting
02:21:34 <BeelsebobWork> it's CUDA but more flexible, and cross-card compatible
02:21:49 <BeelsebobWork> flexible enough that 'software' graphics engines can be written in it
02:23:05 <rog_> BeelsebobWork: i'm sure it's sensible. i can't quite see what functor instance fmap is working on there.
02:23:22 <BeelsebobWork> rog_: whatever functor mv is
02:23:51 <BeelsebobWork> all monads are functors -- fmap = liftM
02:24:01 <rog_> BeelsebobWork: but what's to say that mv is a functor?
02:24:05 <BeelsebobWork> it's a monad
02:24:07 <bd_> All monads are functors in theory - unfortunately, the types are not structured like that
02:24:08 <BeelsebobWork> therefor it's a functor
02:24:25 <bd_> so to be a /correct/ pointfreeification in Haskell, it needs to use liftM in this case
02:24:31 <BeelsebobWork> true
02:24:43 <BeelsebobWork> or just poke you with a stick to write a functor instance with fmap = liftM
02:25:02 <bd_> better yet, reform haskell so that happens automatically :)
02:25:09 <BeelsebobWork> that too
02:25:16 <BeelsebobWork> and so we get applicative for free too
02:25:27 <quicksilver> yeah, @pl believes all monads are functors
02:25:28 <rog_> bd_: oh i see. so strictly speaking the transormation wasn't actually correct. that's why i was confused!
02:25:43 <bd_> rog_: right, it's fine in category theory, but this isn't category theory :)
02:26:17 <rog_> gotcha. i'll run off now.
02:26:54 <Peaker> It is nicer to specify just return/>>=  than specifying fmap, pure, <*> and join
02:27:12 <BeelsebobWork> Peaker: assuming you *can* specify return/>>=
02:27:17 <bd_> depends on the monad
02:27:30 <bd_> I find a definition in terms of fmap/join/return more natural for [], for example
02:27:36 <Peaker> BeelsebobWork: yeah, it could be nice if the Monad class specified how to also derive instances for all of the super-classes
02:27:51 <BeelsebobWork> it would be nice, yes
02:28:26 <bd_> the only problem then is what if module A defines type X, module B has an Monad instance for X, and module C (importing only A) has a Functor instance
02:28:43 <BeelsebobWork> it would need some new syntax I guess -- in that saying data X = ... deriving (Functor, Applicative) would be rather nasty -- it wouldn't be clear at that point *why* you could derive them
02:28:50 <Peaker> bd_: I think you could just see the Monad instance in that case as being a Functor,Applicative,Monad instance all defined at the same place
02:29:09 <BeelsebobWork> bd_: yeh, that's the standard orphan instance problem though
02:29:17 <bd_> I guess
02:29:42 <bd_> probably more natural to allow classes which require superclasses to also provide a default instance
02:29:48 <Peaker> instance MonadFull Blah where .... -- this would have return/>>= desugar to defining Functor and Applicative instances too, whereas  instance Monad where .. would require join and not define Functor/Applicative
02:30:06 <bd_> class Functor m => Monad m where instance Functor m where ...
02:30:32 <Peaker> bd_: I think you'd want to have both MonadFull and Monad so you can define >>=/return   vs.   join   for the separate cases
02:30:45 <rog_> i find it much more intuitive phrased like: liftM ((,) 1)
02:30:49 <bd_> if we don't see a Functor m instance at the point where a Monad m instance is created, then we create a functor instance then
02:30:56 <bd_> if we do, then we skip the automatic derivation
02:31:09 <bd_> then if you prefer you can define functor and the like
02:31:28 <BeelsebobWork> bd_: that's a nice idea actually
02:31:33 <bd_> moreover, if join is then pushed into Monad, you can literally simply define fmap, join, and return
02:31:36 <Peaker> bd_: but if there is a Functor/Applicative instance, why require re-specifying pure?
02:31:38 <quicksilver> there is the class alias proposal along these general lines
02:31:47 <bd_> Peaker: I'm not familiar enough with Applicative to comment on that
02:31:56 <bd_> :t pure
02:31:57 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
02:32:06 <bd_> pure is analogous to return, then?
02:32:17 <Peaker> Yeah
02:32:31 <Peaker> bd_: Applicative has:  pure=return,  bf<*>bx = do { f<-bf;x<-bx; return (f x) }
02:32:52 <quicksilver> coming from the other direction, if you already have Functor and Applicative all you need is join.
02:32:57 <Peaker> bd_: Basically applicative adds return to Functor, and the ability to use multiple "boxed" values inside a single computation
02:33:10 <quicksilver> so you'd specify 1 method for Functor, two for Applicative, and one for Monad.
02:33:37 <quicksilver> which is a saving overall if, in fact, you do want all three instances.
02:33:40 <quicksilver> (and you should)
02:33:41 <Peaker> quicksilver: That's why I think you should be able to specify either Monad after having Applicative, via "join", or specify Functor,Applicative, and Monad all in one blow, by specifying >>= and return
02:34:13 <quicksilver> perhaps.
02:34:19 <quicksilver> doesn't seem worth the effort to me.
02:34:37 <quicksilver> I always find that starting with fmap is more natural, at least.
02:35:07 * rog_ thinks it's a pity that (x,) is not equivalent to ((,) x)
02:35:35 <BeelsebobWork> rog_: it's a pitty that (,) isn't an operator
02:35:38 <BeelsebobWork> is the bottom line
02:35:51 <Peaker> class Functor f .. ; class Functor a => Applicative a .. ; class Applicative m => Monad m where join :: m (m a) -> m a ;   class MonadFull m deriving (Functor, Applicative, Monad) where return :: ... ; (>>=) :: ... ; fmap = ... ; pure = ... ; f<*>x = ... ; join = ...
02:35:55 <BeelsebobWork> (who cares about list syntactic sugar, it gains us 2 characters)
02:36:19 <rog_> but it looks like an operator when used as (,)...
02:36:20 <Peaker> so a "class deriving" could be syntax sugar to defining multiple classes with a simpler interface
02:36:53 <Peaker> (equivalent to manually specifying the multiple instances)
02:37:01 <Peaker> Hey, maybe I can implement it with TH?
02:37:06 <BeelsebobWork> it would be rather nice just to have data (a,b) = a , b
02:37:06 * Peaker needs to learn TH
02:37:10 <BeelsebobWork> and then be done with it
02:37:29 <Peaker> BeelsebobWork: yeah, its even worse that there are (,,) (,,,) etc :(
02:37:52 <BeelsebobWork> Peaker: yeh -- gief pairs, and pairs that aren't a special case -- bin tuples, and bin the list syntactic sugar
02:38:01 <bd_> http://hpaste.org/11812 <-- right then, actual example code for my class extension idea :)
02:38:14 <BeelsebobWork> hmm, actually, it would be data a , b = a , b
02:38:29 <BeelsebobWork> to be able to use the right syntax in the type sig
02:38:31 <Peaker> BeelsebobWork: yeah, the required parens are annoying
02:39:02 <BeelsebobWork> Peaker: yeh, and without them, you can make tuples (with a few extra bottoms) easily
02:39:19 <BeelsebobWork> add a few strictness annotations, and you have tuples if you *really* want them
02:40:29 <Peaker> bd_: it seems nice, but perhaps a bit confusing that you get some arbitrary subset of the classes auto-implemented, based on a history of definitions. May make it hard to understand where instances are coming from
02:41:13 <bd_> Peaker: the idea is the class is specifying the semantics for the instances it's also demanding - so if you declare instances with differing semantics, you already have a bug
02:41:19 <Peaker> bd_: I guess that can be easily resolved by requiring the instance definition to repeat the specification of what is auto-derived
02:41:36 <bd_> instance Monad Maybe where instance Functor Maybe, sort of thing?
02:41:44 <Peaker> bd_: True, but operational semantics may still vary, and you may have bugs in your instances
02:41:59 <Peaker> bd_: instance Monad Maybe (deriving Applicative) where ...
02:42:00 <bd_> Peaker: this is why you avoid writing your own instances when they can be derived :)
02:42:16 <bd_> Peaker: that breaks existing code, though
02:42:42 <Peaker> bd_: ghc 6.10 broke a lot of code anyway.. This is a big change, it should break code :)
02:42:52 <bd_> hehe :)
02:43:11 <bd_> while we're at it, let's make foldl strict
02:43:43 <Peaker> bd_: If you want backwards compatibility, you could have a whole new class hierarchy (duplicate Functor, Applicative, Monad) with different names, and have the power to auto-derive the old
02:49:34 <Axman6> i'm reading the beautiful code, beautiful concurrency pdf, and it says in part of it that IO actions can't be performed in STM actions. you can do it the other way around though, right?
02:50:29 <quicksilver> yes
02:50:35 <quicksilver> @hoogle atomically
02:50:35 <lambdabot> Control.Exception NestedAtomically :: Exception
02:50:39 <quicksilver> heh
02:50:43 <quicksilver> that's not what i wanted to show you.
02:50:50 <quicksilver> Axman6: atomically :: STM a -> IO a
02:50:55 <Peaker> You can do *everything* in IO :-)
02:50:56 <quicksilver> is the primitive to 'run' an STM action in IO.
02:51:24 <quicksilver> of course the lack of a clean way to extend STM is one of its limitations.
02:51:58 <quicksilver> I'm not sure quite what you need.
02:52:05 <quicksilver> actions with "at-commit" parts is one thing
02:52:12 <quicksilver> actions with "on-rollback" parts is another
02:53:02 <Peaker> Hmm, could a bracket-like construct be used for embedding IO in STM?
02:53:08 <quicksilver> makeSTM :: IO a {- the bit you run immediately -} -> IO () {- the bit you run on commit -} -> IO () {- the bit you run on rollback -} -> STM a
02:53:17 <quicksilver> yeah, something along the general lines of bracket.
02:53:29 <quicksilver> I think you probably want a way for the actions to communicate (like you get in bracket)
02:53:50 <quicksilver> and one would need to write down the rules about how it was required to behave.
02:53:52 <Peaker> just put the commit/rollback ones inside (a->) ?
02:53:57 <quicksilver> or (b ->)
02:53:59 <quicksilver> possibly
02:54:04 <Axman6> quicksilver: ah yes, of course
02:54:05 <quicksilver> and change the first one to IO (a,b)
02:54:19 <Peaker> quicksilver: yeah
02:54:33 <quicksilver> you pprobably want some 'private stuff' which doesn't get returned by your STM a
02:54:37 <quicksilver> in general.
02:54:49 <quicksilver> this ideas are pretty obvious, so I'm sure the STM guys thought them through.
02:55:03 <quicksilver> JaffaCake: did anyone have any proposals on an extensible STM?
02:56:18 <JaffaCake> extensible in what sense?
02:56:51 <quicksilver> JaffaCake: in the sense of build an STM action out of "stuff to run mmediately" "stuff to run if we commit" and "stuff to run if we rollback"
02:57:15 <quicksilver> JaffaCake: something like unsafeMakeSTM :: IO (a,b) -> (b -> IO ()) -> (b -> IO ()) -> STM a
02:57:22 <JaffaCake> got to disappear now, ask me about this later
02:57:25 <quicksilver> ok ;)
02:57:32 <JaffaCake> summary: yes we'd like that
02:57:32 <Peaker> any prettier way to express: map (*) (iterate (256*) 1) ?
02:57:50 <Peaker> (doing little-endian decode of an arbitrary size)
02:57:57 <Deewiant> map f . iterate g = iterate (f.g) ?
02:58:18 <Peaker> Deewiant: is that true?
02:58:23 <Deewiant> isn't it?
02:58:28 <Deewiant> no it's not
02:58:37 <Deewiant> so I guess not then
02:58:46 <Peaker> Deewiant: that would make the next iterations see f.g instead of g.. f may lose information
02:58:58 <Deewiant> yep, it's rather obviously not :-P
02:59:13 <Deewiant> might not even type-check
03:00:01 <Peaker> I think every time someone here used iterate, someone suggested a nicer way, so "iterate" raises a red flag for me :)
03:00:17 <quicksilver> Peaker: that looks pretty good to me, to be honest.
03:00:29 <Peaker> ok, thanks
03:06:38 <BeelsebobWork> damn it
03:06:39 <BeelsebobWork> http://www.cs.kent.ac.uk/people/rpg/tatd2/normals.png
03:06:40 <BeelsebobWork> closer
03:06:43 <BeelsebobWork> but still not right
03:08:49 <Peaker> decodeULE size = fmap sum $ sequence $ take size $ map (flip fmap (fmap fromIntegral getWord8) . (*)) (iterate (256*) 1)
03:08:50 <Peaker> yuck!
03:10:58 <Deewiant> ?ty \f -> flip fmap f . (*)
03:10:59 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> a -> f a
03:13:56 <magthe> is there an integer factorisation algorithm already implemented in the Haskell standard libs?
03:22:41 <Peaker> I now have:
03:22:44 <Peaker> decodeULE size = fmap sum $ mapM (`fmap` getWord8Num) digitMultipliers
03:22:45 <Peaker>     where getWord8Num = fmap fromIntegral getWord8
03:22:45 <Peaker>           digitMultipliers = take size $ map (*) (iterate (256*) 1)
03:23:02 <Peaker> I think its perhaps more comprehensible...
03:30:30 <cads__>  /j #debian
03:30:52 <cads__> bleh.
03:31:21 <Peaker> cads__: ha ha, now we are all exposed to your evil plan
03:31:58 <cads__> with haskell and debian I will conquer the world!
03:32:06 <Badger> \o/
03:35:11 <Peaker> @index on
03:35:11 <lambdabot> bzzt
03:35:17 <Peaker> Where's on again?
03:36:02 <Peaker> @hoogle on
03:36:02 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:36:02 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
03:36:02 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:36:05 <Peaker> ok that works
03:36:59 <rog_> Peaker: out of interest, what's a nice way of using that idiom? i'm sure there's a better way than: zipWith id (map (*) (iterate ((256 *)) 1)) (take 4 $ repeat 1); and (map (*) (iterate ((256 *)) 1)) <*> (take 4 $ repeat 1) didn't do what i thought it might...
03:38:20 <Peaker> rog_: You use <*> of the list applicative there, so it'd give you a catesian product..
03:38:41 <rog_> Peaker: indeed... i thought it might have been equivalent to zipWith...
03:38:45 <Peaker> rog_: I realized my code should not at all be in Get/Put monad but actually work on ByteStrings directly so I replaced it, heh
03:39:00 <Peaker> rog_: There's an alternative instance of the List Applicative that does zipWith
03:39:06 <Peaker> @hoogle ListZip
03:39:06 <lambdabot> No results found
03:39:09 <Peaker> @hoogle ZipList
03:39:10 <lambdabot> Control.Applicative newtype ZipList a
03:39:10 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
03:39:10 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
03:39:37 <rog_> Peaker: how do you hide particular instances from a module?
03:39:48 <Peaker> rog_: I don't know
03:40:02 <quicksilver> rog_: you don't.
03:40:07 <Peaker> > (+) <$> ZipList [4,5,6] <*> ZipList [1,2,3]
03:40:08 <lambdabot>       No instance for (Show (ZipList a))
03:40:08 <lambdabot>        arising from a use of `show' ...
03:40:12 <quicksilver> rog_: instances are global
03:40:20 <Peaker> @src ZipList
03:40:20 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:40:23 <quicksilver> rog_: any attempt to deny that, or pretend they can be hidden, only defers the pain.
03:40:41 <Peaker> @hoogle unZipList
03:40:41 <lambdabot> No results found
03:40:48 <Peaker> how do you take something out of a ZipList?
03:40:59 <quicksilver> getZipList
03:41:04 <quicksilver> (it was in your hoogle search just now :P)
03:41:07 <rog_> ok. that's fine if all instances are inevitable, i guess.
03:41:26 <Peaker> oh, I missed it, oops :)
03:41:28 <quicksilver> rog_: if you want an alternative one, you use a newtype
03:41:40 <Peaker> It would be nice if the naming convention was always  unTypeName
03:41:45 <Peaker> > getZipList $ (+) <$> ZipList [4,5,6] <*> ZipList [1,2,3]
03:41:46 <lambdabot>   [5,7,9]
03:41:46 <quicksilver> rog_: if you want several per type, you made a mistake in thinking htis problem was best solved by a type class :)
03:41:57 <quicksilver> rog_: drop back to "just" using higher order functions instead.
03:42:22 <Peaker> rog_: ^^ applicative that does zipping
03:43:15 <rog_> quicksilver: it's interesting, though, that distinction between the "usual" instance for Applicative [], and the ZipList one. who gets to decide what's the global instance?
03:43:43 <rog_> quicksilver: it seems that neither is more correct than the other
03:44:25 <nominolo|msr> > (+) <$> [1,2] <*> [3,4]
03:44:27 <lambdabot>   [4,5,5,6]
03:44:45 <rog_> quicksilver: ... but because someone decided that cartesian products were the way to go, doing it the other way is more painful...
03:44:51 <nominolo|msr> rog_: because that's the monad instance
03:45:21 <nominolo|msr> rog_: which has been around for much longer
03:45:39 <rog_> nominolo|msr: sure. but the monad instance could have been defined in terms of zipWith too.
03:45:42 <quicksilver> rog_: yes, it's interesting. Typeclasses aren't very good for things which naturally have lots of instances.
03:45:49 <nominolo|msr> rog_: no
03:46:03 <nominolo|msr> rog_: zipList is not a monad
03:46:04 <rog_> nominolo|msr: why not?
03:46:10 <quicksilver> rog_: Monoid is a terrible typeclass, for example :)
03:46:43 <nominolo|msr> rog_: i didn't check, but i think that's what was said in the Applicative paper
03:46:56 <quicksilver> I'm pretty sure ZipList is a monad over infinite lists
03:47:06 <nominolo|msr> quicksilver: ...
03:47:06 <quicksilver> although I can't remember which ordering you choose for join.
03:47:18 <quicksilver> it's not a very useful monad.
03:47:53 <quicksilver> it's worth remarking that the true domain of ZipList is strictly infinite lists
03:48:02 <quicksilver> whilst the true domain of the standard list instance is strictly finite lists
03:48:07 <quicksilver> so in a sense they don't really conflict.
03:48:31 <nominolo|msr> quicksilver: except you cannot express this
03:48:44 <quicksilver> well, not in haskell.
03:48:46 <Peaker> quicksilver: why are finite lists not in the domain of ZipList?
03:48:50 <nominolo|msr> unless you do newtype ZipList a = a `Zcons` (ZipList a)
03:48:51 <quicksilver> you can express it in english, I just did ;)
03:48:53 <rog_> i always find it intriguing the way people say "A *is* a B". instead of "A can be defined as a B"
03:49:04 <quicksilver> although mabye not very well
03:49:05 <nominolo|msr> er, data
03:49:31 <Peaker> Yeah, why not express infinite lists with a different type than finite lists, really?
03:49:53 <nominolo|msr> Peaker: because then you need explicit coerciens everywhere
03:49:53 <quicksilver> Peaker: because the behaviour of zipWith (cutting off at the shortest list) actually breaks the rules
03:49:54 * Axman6 senses revolution!
03:50:05 <Peaker> quicksilver: oh
03:50:11 <quicksilver> Peaker: except on infinite lists when there is no cutting off.
03:50:18 <Peaker> quicksilver: Yeah, I understand, thanks
03:50:51 <quicksilver> you can express strictly infinite in a weak sense
03:51:00 <quicksilver> (the sense of 'infinite or _|_')
03:51:03 <nominolo|msr> quicksilver: only if it allows different types for each argument
03:51:05 <rog_> quicksilver: isn't ZipList a monad over all lists of the same length?
03:51:05 <quicksilver> but you can't express strictly finite.
03:51:15 <quicksilver> rog_: no, you can't "join" that.
03:51:28 <rog_> ah, i see.
03:51:29 <quicksilver> How you do get from [[a]] to [a], of the same length
03:51:47 <rog_> yup
03:51:48 <Peaker> is ZipList a proper Applicative for finite lists of the same length, at least?
03:52:03 <quicksilver> yes.
03:52:10 <quicksilver> all the finite sub cases are fine.
03:52:18 <quicksilver> data Vec4 a = Vec4 a a a a
03:52:25 <quicksilver> is a nicely behaved applicative, for example.
03:52:35 <quicksilver> it's just mixing and matching different lengths which doesn't work.
03:53:22 <rog_> quicksilver: why is the "truncate at shortest" rule a problem for that?
03:53:37 <quicksilver> disobeys one of the applicative laws, as far as I remember
03:53:51 <rog_> i was trying to work out which one
03:54:58 <Peaker> @src ZipList pure
03:54:59 <lambdabot> Source not found. It can only be attributed to human error.
03:55:15 <Peaker> > getZipList (pure 5)
03:55:16 <lambdabot>       Ambiguous occurrence `pure'
03:55:17 <lambdabot>      It could refer to either `Control.Appl...
03:55:20 <rog_> oh of course, pure id <*> [2, 4] = [2], not [2, 4]
03:55:38 <rog_> but... pure id is surely repeat id
03:55:41 <rog_> hmm
03:55:45 <Peaker> > getZipList (Control.Applicative.pure 5)
03:55:45 <quicksilver> yup, that's not the problem
03:55:46 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
03:56:29 <Peaker> if ZipList is a newtype anyhow, why not have it be an infinite-list-only type? You co-erce it to a list with getZipList anyhow?
03:56:40 <Axman6> how would you a) make and b) use a ZipList if it is strictly infinite? and can it possibly have more than one value in it?
04:00:46 <rog_> Axman6: can ([5, 6, 7] ++ undefined) be treated as infinite?
04:01:03 <Peaker> Axman6: data InfList a = a `InfCons` (InfList a)   ;   repeatInf x = x `InfCons` (repeatInf x)
04:01:27 <Axman6> Peaker: what if i want differing values in it?>
04:01:38 <Peaker> @src cycle
04:01:38 <lambdabot> cycle [] = undefined
04:01:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
04:02:25 * Axman6 redefines: data InfList a = a :z (InfList a) -- for pattern matching purposes
04:02:30 <Axman6> that would be valid right?
04:02:34 <Peaker> Axman6: I guess with something like Cycle for InfList
04:02:39 <Peaker> Axman6: (:) is taken for lists already
04:02:45 <Peaker> @index (:)
04:02:45 <lambdabot> bzzt
04:02:53 <Axman6> can't you use : in data constructors?
04:02:54 <Peaker> Maybe you could import Prelude hiding (:) and do that
04:03:45 <rog_> mkinflist [] = undefined; mkinflist (x : xs) = InfList x  (mkinflist xs)
04:04:23 <rog_> Axman6: you can't combine : and letters
04:05:26 <rog_> i still haven't worked out why zipWith on non-infinite lists isn't a proper instance of Applicative
04:05:29 <Axman6> ok, well, data InfList a = a +:+ (InfList a)
04:05:42 <rog_> Axman6: it has to start with a :
04:05:59 <Axman6> ok, well, data InfList a = a :+~ (InfList a)
04:05:59 <rog_> (i think)
04:06:04 <rog_> :-)
04:06:18 <Axman6> a plus infinity
04:07:35 <rog_> what about data InfList a = a :∞ (InfList a) ? :-)
04:08:12 <rog_> (although i suppose ∞ is already sidelined as a representation of a number...)
04:08:18 <Axman6> i sense windows having problems with that
04:08:48 <Axman6> with darcs, when i want to 'checkout' a repository thing, do i use get or pull?
04:08:52 <rog_> bah. if everyone starts really using unicode, the world'll catch up pretty quick...
04:09:00 <Axman6> i hope so
04:09:08 <Axman6> 
04:09:36 <rog_> just as long as they're not using utf-16... ☺
04:09:49 <Axman6> heh, i can see that fine
04:10:44 <rog_> i haven't installed it yet, but in my dreams ghc 6.10 does utf-8 properly.
04:11:44 <Peaker> I wonder if: http://hpaste.org/11817  is useful/makes any sense
04:12:28 <Peaker> I am trying to write a pickler combinator, and I can't have even a Functor instance, because you can't "fmap" a Codec for some type, as an ordinary function is not enough
04:15:01 <rog_> Peaker: i did something like that some time ago, when thinking about converting interfaces to use different type, when there were functions taking the type as argument as well as returning it.
04:15:11 <rog_> i didn't end up using it though.
04:15:24 <rog_> maybe i've misunderstood your aim
04:15:50 <Peaker> then you need a "Dummy" value for that type, right?
04:16:17 <rog_> Peaker: Dummy?
04:16:36 <Peaker> rog_: If you don't have an arg for the function, what do you give it?
04:17:24 <rog_> Peaker: you define essentially the same interface, but in terms of the new type rather than the old. any incoming arguments you change to the old type; and returned types you change to the new type.
04:17:37 <rog_> Peaker: so you always do have an arg for the function.
04:17:58 <rog_> Peaker: i'm sure this is all old hat though.
04:18:12 <Peaker> Can you show a code example? I am not sure I understand
04:19:35 <rog_> Peaker: http://hpaste.org/11817#a1
04:19:52 <rog_> Peaker: caveat: i was only a couple of weeks into haskell at the time
04:20:35 <Peaker> @pl Fn1 (\a -> f (g (rf a)))
04:20:36 <lambdabot> Fn1 (f . g . rf)
04:21:20 <rog_> Peaker: sure. i hadn't really got my head around point-free code.
04:21:36 <quicksilver> Peaker: you can only fmap a codec with invertible functions.
04:21:48 <quicksilver> Peaker: perhaps you know this and are just asking how to do it?
04:22:03 <dcoutts> sjanssen, mmorrow: you had some Qs about InstallDirs ?
04:22:13 <Peaker> quicksilver: yeah, I was wondering if my Functor/Applicative/Monad hierarchy http://hpaste.org/11817  for invertible functions made sense
04:22:36 <Peaker> perhaps s/Adaptable/Reversible
04:22:48 <quicksilver> hmm.
04:22:58 <quicksilver> I've never thought about extending this to Applicative or Monad.
04:23:08 <quicksilver> I wouldn't have expected it to be meaningful.
04:23:14 <quicksilver> My expecations are often wrong though :)
04:23:54 <Peaker> quicksilver: I am hoping my pickler combinator can use a "monadic" interface so you can choose the next codec's based on the result values of previous codecs (either parsed or given)
04:24:31 <Peaker> (in the case of decoding, the next parsers will be chosen based on the previous parses.  In the case of encoding, the next encoders will be chosen based on the arguments given to previous encoders)
04:26:20 <Peaker> while Binary tries to serialize types in some arbitrary way, this pickler combinator should let you specify the wire-formats precisely, and would let you have a nice type front-end to these wire formats
04:26:35 <Peaker> (s/Binary/deriving Binary)
04:33:33 <deeflex> I need to check if an element is a space from a list. in my recursion I have isSpace (head input). But isSpace is Char->Bool.
04:34:15 <Axman6> deeflex: could you give examples of input and output?
04:35:12 <Axman6> i'm not sure if you want something like 'all isSpace xs'
04:35:25 <deeflex> Well I'm trying to create a tokenizer.  ["bla bla", " ", "a"] => ["bla bla", "a"]
04:35:48 <Axman6> so filter isSpace xs?
04:36:02 <deeflex> aha never thought of that hehe
04:36:03 <deeflex> let me try
04:36:15 <quicksilver> Peaker: I have thought about this problem more than once but it sounds to me like you're getting further than I ever did.
04:37:37 <deeflex> Axman6: filter isSpace ["bla bla", " "]
04:37:45 <deeflex> gives a type error
04:37:57 <deeflex> does not match [Char] -> Bool
04:38:31 <Lemmih> > filter (not . all isSpace) ["Hello", "  ", "World"]
04:38:33 <lambdabot>   ["Hello","World"]
04:40:27 <deeflex> Lemmih: ok thanks
04:43:19 <Beelsebob> deeflex: do you understand why you get the type error?
04:45:26 <BONUS> " " and ' ' is different
04:45:29 <BONUS> " " is like [' ']
04:45:35 <deeflex> Beelsebob: no not really
04:45:44 <BONUS> isSpace is a function that takes a character
04:45:47 <BONUS> so ' ' or 'a' or 'b'
04:45:50 <Beelsebob> deeflex: well, isSpace expects to get a character
04:45:53 <Beelsebob> you gave it a string
04:45:56 <BONUS> whereas " " is a strin
04:45:57 <BONUS> g
04:45:59 <Beelsebob> which is a list of characters
04:46:13 <Beelsebob> what all does is asks "does isSpace return true for all the things in this list"
04:46:14 <deeflex> yes I understood that. So tried to find a function String-> Char
04:46:36 <Beelsebob> well the problem there is that there's no sensible function with that type
04:46:47 <deeflex> ye ok
04:46:49 <Beelsebob> because if you have one of those you will only test *one* of the many characters in the string
04:46:58 <Beelsebob> what you want to do is test *all* the characters in the string
04:47:03 <Beelsebob> which is what the all function does
04:47:48 <deeflex> yes but isSpace first checks the list right?
04:47:56 <Beelsebob> no
04:48:00 <Beelsebob> @src all
04:48:01 <lambdabot> all p =  and . map p
04:48:09 <Beelsebob> all applies isSpace to all the things in the list
04:48:10 <deeflex> ah
04:48:15 <Beelsebob> which gets you a list of True/False values
04:48:22 <Beelsebob> and it then ands all the answers together
04:48:47 <deeflex> but how can isSpace be still be applied to a list of Strings?
04:48:57 <Peaker> is this the right syntax for fundeps: class Adapter a b c | a->b, a->c where ..
04:48:59 <Beelsebob> the point is that it isn't
04:49:14 <Beelsebob> filter applies (not . all isSpace) to each string
04:49:22 <Beelsebob> all isSpace applies isSpace to each character
04:50:13 <Beelsebob> > isSpace ' '
04:50:13 <Beelsebob> > filter isSpace "jam ham spam"
04:50:18 <lambdabot>   True
04:50:18 <lambdabot>   "  "
04:50:23 <Beelsebob> > filter (not . isSpace) "jam ham spam"
04:50:24 <lambdabot>   "jamhamspam"
04:50:58 <deeflex> ok cool
04:51:22 <Beelsebob> note that isSpace is filter's first argument
04:51:29 <Beelsebob> and "jam ham spam" is filter's second argument
04:51:39 <Beelsebob> this is filter (isSpace) ("jam ham spam")
04:51:48 <Beelsebob> not filter (isSpace ("jam ham spam"))
04:54:52 <deeflex> ok got it..but how isSpace is applied to a list of strings is  a bit confusing.
04:55:06 <Beelsebob> @src filter
04:55:06 <lambdabot> filter _ []     = []
04:55:06 <lambdabot> filter p (x:xs)
04:55:06 <lambdabot>     | p x       = x : filter p xs
04:55:06 <lambdabot>     | otherwise = filter p xs
04:55:18 <Beelsebob> filter takes a function, and applies it to every element of the list
04:55:27 <Beelsebob> it keeps only the elements for which the function returns true
04:56:01 <Beelsebob> > filter (> 5) [1,2,3,4,5,6,7,8,9]
04:56:03 <lambdabot>   [6,7,8,9]
04:56:08 <deeflex> exactly
04:56:30 <Beelsebob> so filter isSpace is a function from Strings to Strings
04:56:43 <Beelsebob> all isSpace is a function from Strings to Bools
04:56:53 <Beelsebob> > all isSpace "jam ham spam"
04:56:54 <lambdabot>   False
04:56:57 <Beelsebob> > all "    "
04:56:58 <lambdabot>   Couldn't match expected type `a -> Bool'
04:57:00 <Beelsebob> oops
04:57:04 <Beelsebob> > all isSpace "      "
04:57:05 <lambdabot>   True
04:57:43 <Beelsebob> not is a function from Bool -> Bool
04:57:52 <Beelsebob> so not . all isSpace is a function from String -> Bool
04:58:11 <Beelsebob> and finally filter (not . all isSpace) is a function from [String] -> Bool
04:58:18 <Beelsebob> bah
04:58:20 <deeflex> ok thanks...helpful people here today :)
04:58:23 <Beelsebob> [String] -> [String] even
04:58:43 <deeflex> eloge for Beelsebob lol
05:14:42 <Axman6> could someone tell me what IORefs are for?
05:15:43 <ToRA|MSR> creating shared variables
05:15:55 <Axman6> and are they ar all like MVars/TVars
05:15:58 <Axman6> at*
05:16:14 <quicksilver> Axman6: a way to append additional state to the IO monad
05:16:16 <ToRA|MSR> yes in terms of the fact that they are essentially a pointer to a value
05:16:26 <quicksilver> so you can thread arbitrary mutable state through IO actions
05:16:37 <Axman6> i see, i think
05:16:47 <ToRA|MSR> but they all have difference concurrency / blocking / synchronisation properties
05:16:48 <quicksilver> MVars are "just" thread-safe IORefs
05:16:57 <quicksilver> for some particular meaning of thread-safe
05:17:05 <quicksilver> but as a guideline, you use MVars not IORefs if you're using threads.
05:17:16 <quicksilver> TVars are an optimistic concurrency version of MVars
05:17:19 <Axman6> yeah i've been playing with MVars and some STM stuff using TVars
05:17:21 <ToRA|MSR> there is an atomic update for IORefs though isn't there?
05:17:26 <quicksilver> yes
05:17:29 <ToRA|MSR> (is that thread safe?)
05:17:39 <quicksilver> IORefs are safe in the weak sense of not crashing
05:17:47 <quicksilver> but they're not a very composable construct, for threading.
05:17:49 <Axman6> heh
05:18:29 <quicksilver> in particular, IORefs are vulnerable to write-fighting
05:18:42 <Peaker> Aren't MVars also not completely composable, in the sense locking-code isn't, given that MVars are pretty analogous to locks?
05:18:44 <quicksilver> MVars can be safe from that depending how you wish to use them.
05:18:54 <Axman6> so, two threads write at the same time, and the later one gets to write?
05:18:58 <quicksilver> Peaker: nobody has a completely composable concurency abstraction ;)
05:19:08 <quicksilver> Peaker: except for processes which do not communicate with each other at all.
05:19:11 <Peaker> quicksilver: what about par?
05:19:14 <Peaker> ah
05:19:24 <quicksilver> MVar have some better composability properties than IORef
05:19:33 <quicksilver> TVars are generally speaking even better
05:19:36 <Axman6> and TVars even more so?
05:19:40 <quicksilver> but there are lots of other choices in the design space.
05:19:45 <Peaker> maybe we should not have communicating concurrent entities then? :)
05:19:50 <Axman6> heh, so close to pulling a Beelsebob on me
05:19:52 <deeflex> Beelsebob: you know when I try to call tokenize like: convert (tokenize c) I get another type error. It says c is of type [Char] and it doesn't match [String].
05:19:54 <Peaker> (only "under the hood", that is)
05:20:16 <deeflex> I believe you said it was a function from [String] to [String].
05:24:39 <quicksilver> Axman6: what's "pulling a Beelsebob" ?
05:25:06 <Peaker> quicksilver: I'm trying to get the equivalent of (+) <$> leInt <*> leInt   to work (encoder=encode 2 ints, return their sum,  decoder=decode 2 ints, return their sum).  This requires a bidirectional (+), which I can define as: data Plus = Plus { unPlus :: (a,b) },  but then partial application is unclear..
05:25:18 <Axman6> the number of times i go to say something, type it, and hit enter just after Beelsebob says the same thing is scary, and frequent enough to warrant a name
05:25:29 <quicksilver> ah.
05:26:08 <quicksilver> Peaker: Yes. I see the problem.
05:26:13 <quicksilver> Peaker: I don't see the solution though :(
05:28:09 <Peaker> I could use this instead: data Apply f a = { unApply :: (f, a) } ; (Apply (Apply (+) 1) 2)
05:28:29 <Peaker> (I think)
05:28:57 <Peaker> So I can manipulate expressions, rather than values
05:30:10 <Peaker> I'm not sure if it makes any sense.. I'll try to implement
05:32:09 <EvilTerran> deeflex, wouldn't it be String -> [String]?
05:32:40 <EvilTerran> ?type words -- kinda analagous to "tokenise"
05:32:41 <lambdabot> String -> [String]
05:34:35 <Axman6> EvilTerran: he was using something that would take input like ["blah bah", " ", "thing"]
05:34:45 <Axman6> so, [String] -> [String]
05:35:04 <EvilTerran> Axman6, ahhh. that's what i get for coming into the middle of a conversation.
05:35:22 <Axman6> i'm still unsure what he wants though :)
05:35:41 <u_quark> has anybody tried building hint with ghc 6.10.1 ?
05:36:54 <xenoblitz> hi guys... if i have a type class defined as class Valued a where ... is it possible to create an instance of it sort of like instance Valued (MyDatatype a) where... and if yes what am I looking for so I look it up?
05:36:58 <joelr1> good morning
05:37:04 <joelr1> umm... afernoon, actually
05:37:12 <trittweil> Can anyone provide some enlightenment on http://hpaste.org/11820 ?  I don't understand the interplay of `do', `when', and `error'.
05:37:40 <joelr1> how do i check out ghc from github? i tried a clone of ghc-hq/ghc.git but, apparently, not everything is checked out. do i still need to run darcs-all get?
05:38:14 <u_quark> is there a way to access the old ghc api ?
05:39:48 <EvilTerran> trittweil, i don't think 'error' works how you think it works
05:39:59 <quicksilver> xenoblitz: yes.
05:40:13 <EvilTerran> also, that is an incredibly imperative-style solution
05:40:20 <quicksilver> xenoblitz: there's nothing to lookup really, what you've said is fine.
05:41:00 <quicksilver> trittweil: that use of MapM is confusing me.
05:41:00 <xenoblitz> quicksilver: thanks, I must be writing something wrong...I'll rewrite it and let you know if it works or not
05:41:09 <quicksilver> trittweil: in what sense is 'HsBinds' a monad?
05:42:34 <EvilTerran> quicksilver, it's not, the mapM's working in State
05:42:38 <trittweil> quicksilver: It isn't.
05:43:05 <xenoblitz> quicksilver & co: http://hpaste.org/11821 here's the code and my error
05:43:14 <Axman6> :t join
05:43:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:43:34 <EvilTerran> xenoblitz, ah, well, i think the error explains
05:43:41 <quicksilver> Ah. There is an evalState
05:43:43 <quicksilver> I can't read :)
05:43:47 <EvilTerran> "All instance types must be of the form (T a1 ... an)
05:43:47 <EvilTerran>  where a1 ... an are type *variables*"
05:44:09 <quicksilver> xenoblitz: haskell98 is broken.
05:44:12 <trittweil> EvilTerran: How does error work?
05:44:14 <quicksilver> xenoblitz: use "FlexibleInstances"
05:44:20 <EvilTerran> (unless you use FlexibleInstances, which i would)
05:44:33 <quicksilver> trittweil: error is not exception handling and 'State' doesn't have any exception handling facilities.
05:44:42 <EvilTerran> what quicksilver said
05:44:55 <trittweil> quicksilver: So what is error?
05:44:58 <joelr1> JaffaCake: ping
05:44:58 <quicksilver> trittweil: error just embeds a lazily evaluated bomb which doesn't explode until somebody tries to inspect it.
05:45:02 <Axman6> > if 1 > 2 then "ok" else error "wut?"
05:45:02 <EvilTerran> error "..." is an undefined value that happens to produce the string in "..." when you try to evaluate it
05:45:03 <lambdabot>   "* Exception: wut?
05:45:13 <quicksilver> trittweil: error is for marking programming errors
05:45:15 <EvilTerran> > (1, undefined)
05:45:16 <Axman6> :t error
05:45:17 <lambdabot>   (1,* Exception: Prelude.undefined
05:45:17 <lambdabot> forall a. [Char] -> a
05:45:18 <quicksilver> "error not exception"
05:45:22 <EvilTerran> > (1, error "oh dear")
05:45:24 <lambdabot>   (1,* Exception: oh dear
05:45:28 <quicksilver> according to the distinction some people choose to make
05:45:37 <xenoblitz> EvilTerran, quicksilver: so I just must use that -XFlex... ?
05:45:41 <quicksilver> xenoblitz: yes.
05:45:42 <EvilTerran> > fst (1, error "but this works fine. laziness etc.")
05:45:44 <lambdabot>   1
05:45:52 <Axman6> quicksilver: well, exceptions can be recovered from right?
05:45:54 * BeelsebobWork wishes people would use Either String a, rather than calling Error
05:45:56 <trittweil> Ok, I see.
05:46:03 <BeelsebobWork> or more to the point MonadFail m => m a
05:46:07 <EvilTerran> xenoblitz, or put {-# LANGUAGE FlexibleInstances #-} at the top of the file
05:46:33 <xenoblitz> quicksilver, EvilTerran: thanks guys
05:46:37 <EvilTerran> :)
05:47:17 <quicksilver> trittweil: I imagine you want ErrorT State or StateT Error
05:47:52 <EvilTerran> quicksilver, ... or to stop thinking in terms of loops and mutable variables? that might help too...
05:48:10 <Peaker> I think I also reached the conclusion that a bidirectional monad would have to have: bind :: m a -> (a -> m b) -> m (a, b)   instead of (>>=)
05:48:13 <joelr1> so does anyone know how to build ghc from git?
05:48:27 <EvilTerran> Peaker, bidirectional monad? O.o
05:48:45 * EvilTerran is reminded of the "backwards state" monad
05:49:01 <xenoblitz> quicksilver, EvilTerran: is it possible however to create a class which instead of taking just Valued a takes Valued (Square a) or is that like a blasphemy?
05:49:24 <Peaker> EvilTerran: I want something kinda like a monad (apparently its not really that similar to a monad anymore) for a pickler combinator
05:49:57 <EvilTerran> Peaker, i see
05:50:15 <EvilTerran> pickling sounds like it'd be a job for Writer, potentially
05:52:23 <Peaker> I think I had it all wrong, arrg.. I'll start over
05:52:59 <quicksilver> xenoblitz: I'm not sure I know what you want.
05:53:18 <quicksilver> xenoblitz: class Valued a where value :: Square a -> Double
05:53:28 <quicksilver> xenoblitz: is for example perfectly legal
05:55:39 <xenoblitz> quicksilver: look I want something of the form that whenever a is in class Valued, so is Square a
05:56:09 <Peaker> xenoblitz: instance Valued a => Valued (Square a) where ... ?
05:56:39 <xenoblitz> Peaker: possibly, I don't know how to write it or what such a thing is called so I can look it up
05:59:07 <Peaker> I just understood that there is an inherent assymetry between the encoder and decoder:  The encoder can make arbitrary decisions that both have to accept...
05:59:15 <Peaker> And I had no representation of that
05:59:43 <quicksilver> Peaker: the simplest interesting one is string with length prefix
05:59:55 <quicksilver> Peaker: if your combinators can handle that, they're on the right track.
05:59:55 <Peaker> quicksilver: that's not arbitrary though
06:00:12 <Peaker> quicksilver: Something like escaping/not-escaping a string that needs no escaping is..
06:00:36 <quicksilver> ah yes.
06:00:42 <quicksilver> when there is more than one correct encoding
06:00:47 <quicksilver> and both must correctly decode
06:01:18 <FunctorSalad> shouldn't there be a variant of readProcess for bytestrings? :)
06:02:14 <quicksilver> xenoblitz: there is nothing to have a name.
06:02:18 <FunctorSalad> probably just have to change the type signatures in the readProcess source, but maybe it could be in the library I mean
06:02:24 <quicksilver> xenoblitz: that's a perfectly valid form of instance.
06:02:36 <quicksilver> xenoblitz: in fact the standard library is full of instances of that form
06:02:47 <quicksilver> xenoblitz: like instance (Show a) => Show [a]
06:03:47 <xenoblitz> quicksilver: yes, I guess I must be missing some detail
06:03:47 <xenoblitz> hehe
06:04:26 <FunctorSalad> quicksilver: hmm isn't that at least -XOverlappingInstances?
06:05:08 <FunctorSalad> nevermind
06:05:11 <xenoblitz> quicksilver & co: instance Valued (Square ChessPiece) where value square = valueSquareChess square gives me the same -XFlexibleInstances error... so its a normal thing i guess
06:05:13 <xenoblitz> right?
06:06:41 <FunctorSalad> ( quicksilver : I was thinking of instance X a, instance X a => instance X [a] for some reason)
06:07:09 <quicksilver> xenoblitz: eh? now you're going back to what we talked about the first time.
06:07:13 <mr_H> hello
06:07:20 <quicksilver> xenoblitz: we already told you that needed flexible instances
06:07:36 <quicksilver> xenoblitz: instance Values a => Valued (Square a) does not, though.
06:08:13 <xenoblitz> quicksilver: sorry about that, things were still a bit unclear. thanks once more
06:10:29 <trittweil> EvilTerran: http://hpaste.org/11820#a1
06:11:37 <Peaker> now I have something like: encoderChoice :: a -> b -> Codec b -> (b -> Codec a) -> Codec a
06:11:44 <trittweil> EvilTerran: This works now. Any comments? I'm not particularly sure that it's really more readable than the imperative solution.
06:11:57 <Peaker> and similar-to-(>>=) pair :: Codec a -> (a -> Codec b) -> Codec (a, b)
06:12:19 <Peaker> I guess I can try to find the right type-classes later
06:12:45 <Peaker> oops, that was supposed to be (a -> b) -> ...
06:13:21 <EvilTerran> trittweil, a few well-chosen names might make that clearer
06:15:14 <quicksilver> trittweil: you still shouldn't use "error" for something which isn't actually a programming error.
06:20:18 <joelr1> Igloo: ping
06:21:36 <samll> > 850 * 77.1
06:21:37 <lambdabot>   65534.99999999999
06:21:55 <samll> > round (850 * 77.1) :: Int8
06:21:56 <lambdabot>   -1
06:22:00 <samll> yay
06:22:58 <Igloo> samll: Hmm, can you file a bug, please?
06:23:11 <samll> no it's not a bug
06:23:31 <Igloo> Oh, so it isn't, sorry, I'm being dopey
06:23:39 * Igloo was thinking Word8
06:23:52 <samll> it's how functional programming works. Excel has similar feature too because it's functional programming
06:24:06 <xenoblitz> trittweil: from the little I know error is your very very very last resort :P
06:24:20 <samll> > round (850 * 77.1) :: Word8
06:24:21 <lambdabot>   255
06:25:21 * EvilTerran considers using "error" to indicate user error to be analogous to dumping out a message to stderr and calling exit() in C
06:25:56 <EvilTerran> er, delete "to indicate user error", that'll make more sense
06:26:22 <Axman6> Igloo: don't know if you saw it, but i found out what my compile problem qith 6.10.1 was on OS X
06:26:47 <Igloo> Axman6: The wrongly-named file? Tht was very strange
06:26:50 <Axman6> the file you asked me to check for had had some random number appended to the end of the filename, so it was thingo.hs0000655
06:27:02 <Axman6> indeed :\
06:27:11 <Axman6> but, not a GHC error, so s'ok :)
06:27:25 <Igloo> Axman6: Did you use darcs to get the code?
06:27:40 <Axman6> no, just the tarballs
06:27:55 <Igloo> Oh, that's even stranger. The 6.10.1 tarballs?
06:28:00 <Axman6> probably Finder being stupid (it was doing some odd stuff at the time)
06:28:04 <Axman6> yeah
06:28:17 <joelr1> Igloo: is there a way to build ghc from the git repo (github)?
06:28:24 <Igloo> Axman6: Can you see if unpacking it again gives the right filename or not please?
06:28:32 <Axman6> sure
06:28:41 <Badger> is there meant to be a relatively easy way to get cabal on windows?
06:28:45 <Igloo> joelr1: I'm not sure if the script to check out the other repos work at the moment
06:29:04 <Badger> where you don't have to grab all the tarballs for HTTP, etc.
06:29:07 <joelr1> Igloo: sync-all you mean? seems to want darcs
06:29:20 <trittweil> quicksilver: Yes, I know.
06:29:35 <Igloo> joelr1: It needs to use darcs, as the other repos aren't gittified
06:29:40 <trittweil> quicksilver: It's on mz todo to get rid of it in the code base.
06:29:40 <joelr1> Igloo: ok, assuming i got darcs installed and cloned the git repo, what then?
06:29:51 <joelr1> Igloo: sync-all get --partial?
06:30:10 <Axman6> Igloo: same thing, very odd. could be a unarchiver bug though
06:30:12 <Igloo> joelr1: I'm not sure. We use the darcs repo currently
06:30:33 <Axman6> what would be the command line way to open the tar.bz2?
06:30:58 <joelr1> Igloo: eta for complete git switch?
06:31:04 <Igloo> Axman6: Which file is it again?
06:31:09 <Igloo> joelr1: After 6.10.2
06:31:11 <Axman6> extralibs
06:31:22 <Axman6> ghc-6.10.1-src-extralibs.tar.bz2
06:31:22 <joelr1> Igloo: thanks
06:31:24 <Igloo> Axman6: Which file in that tarball, though
06:31:34 <Axman6> sec
06:31:50 <Igloo> "tar -jxf ghc-6.10.1-src-extralibs.tar.bz2" is the commandline way. Or possibly gtar instead of tar
06:31:59 <Axman6> libraries/dph/dph-prim-seq/Data/Array/Parallel/Unlifted/Sequential/Segmented/Subarrays.hs0000664
06:33:21 <Igloo> Ah, the filename is exactly 100 characters long
06:33:29 <Igloo> There's something special about that in tar files
06:34:11 <Axman6> heh, i see
06:34:11 <trittweil> Is there something like filter2 :: (a -> b -> Bool) -> [a] -> [b] -> [a]?
06:34:45 <Axman6> Igloo: yeah it's a bug in the unarchiver i use, tar on the commandline works fine
06:35:17 <Igloo> OK. Is that unarchiver something that comes with OS X?
06:35:31 <Vq^> trittweil: not really
06:35:43 <byorgey> trittweil: no, but you could do something like zip up the lists with the predicate, filter on that, then project back out
06:36:04 <trittweil> Of course, I'd be interested in something less verbose
06:36:05 <Vq^> trittweil: parallel list comprehensions might be a solution
06:36:07 <Axman6> Igloo: nah, it's called The Unarchiver. i'll let the devs know
06:36:14 <Igloo> OK, great, thanks!
06:36:41 <Vq^> [x | x <- xs | y <- ys, p x y]
06:36:54 <Vq^> (not actually tested anything like that myself)
06:36:57 <byorgey> @type \f as bs -> map snd $ filter fst $ zipWith (f &&& const) as bs
06:36:58 <lambdabot>     Couldn't match expected type `b1 -> (Bool, b)'
06:36:58 <lambdabot>            against inferred type `(c, b2 -> a)'
06:36:58 <lambdabot>     Probable cause: `&&&' is applied to too many arguments
06:37:11 <Badger> uhoh
06:37:17 <Badger> everybody think happy thoughts
06:37:24 <Badger> smile, look calm...
06:37:31 <byorgey> oh, hm, that won't work
06:38:49 <byorgey> @type \f as bs -> map fst $ filter (uncurry f) $ zip as bs
06:38:50 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> [a]
06:38:54 <byorgey> that's better =)
06:39:32 <byorgey> trittweil: in fact, just defining  filter2 f as bs = filter (uncurry f) $ zip as bs  is more general
06:39:45 <byorgey> @type \f as bs -> filter (uncurry f) $ zip as bs
06:39:46 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> [(a, b)]
06:40:04 <byorgey> then you can project out whatever you want from the result
06:52:00 <jeffersonheard> Hello folks, this morning (my time, anyway) looking to generate indices into an array with an enormous stride....  2048 rows of 6144 bytes apiece, with a rowstride of 18482 or some such horrible number.  I can't do that with a [1..n] generator, I assume.
06:52:12 <jeffersonheard> wondering how best to do it in a function
06:52:47 <BeelsebobWork> > take 2048 [0,18482..] :: [Integer]
06:52:49 <lambdabot>   [0,18482,36964,55446,73928,92410,110892,129374,147856,166338,184820,203302,...
06:52:51 <BeelsebobWork> done
06:53:10 <jeffersonheard> oh.  duh.  brainfart
06:53:12 <jeffersonheard> thanks
06:53:21 <BeelsebobWork> :P
06:53:39 <BeelsebobWork> just glad it wasn't me brain farting for once :P
06:55:16 <profmakx> BeelsebobWork you are dealing with normal vectors on ridiculously large objects
06:55:26 <profmakx> btw. why dont you try with smaller ones?
06:55:46 <BeelsebobWork> profmakx: already tried with smaller ones -- I can't reproduce the bug in a smaller model
06:55:55 <profmakx> gnarf
06:56:40 <pizza_> how do i split a list into a list of N-size lists, i.e. foo 2 [0..3] -> [[0,1],[2,3]]
06:57:01 <pizza_> i should ask.. is there a standard function for doing so?
06:57:57 <quicksilver> let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n) in groupsOf 2 [0..]
06:58:01 <quicksilver> > let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n) in groupsOf 2 [0..]
06:58:03 <lambdabot>   [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,...
06:58:11 <quicksilver> pizza_: that's the definition, and name, that I use
07:00:57 <pizza_> quicksilver: thanks
07:02:19 <Taggnostr> I did a function like that
07:02:44 <Taggnostr> http://hpaste.org/11668
07:02:57 <pao> Hi :-)
07:03:08 <pao> I'm developing a ffi binding for a math library
07:03:44 <pao> my problem is that i'd like to get rid of IO monad ...
07:04:13 <pao> the function I'm binding has a clear semantics of referential transparency
07:04:23 <Peaker> pao: if you're wrapping a pure computation, you can probably use unsafePerformIO?
07:04:39 <pao> Peaker: yep... that was the idea
07:04:52 <Peaker> @type unsafePerformIO
07:04:54 <lambdabot> Not in scope: `unsafePerformIO'
07:05:01 <Peaker> @type System.Unsafe.unsafePerformIO
07:05:02 <lambdabot> Couldn't find qualified module.
07:05:10 <Peaker> @hoogle unsafePerformIO
07:05:11 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:05:11 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
07:05:22 <pao> Peaker: the only the side effect is being unable to allocate memory for the input array
07:06:00 <pao> Peaker: is using unsafePerformIO in this situation considered "acceptable"?
07:06:38 <ToRA|MSR> i thought you could mark ffi functions as pure and not put the return in io in the first place?
07:06:45 <thoughtpolice> you can
07:07:10 <thoughtpolice> the types of ffi-imported functions is whatever you want in terms of IO-or-not
07:07:21 <pao> ToRA|MSR: the problem is that I need to use malloc
07:07:34 <pao> @hoogle malloc
07:07:34 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
07:07:34 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
07:07:34 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
07:08:47 <ToRA|MSR> ah ok
07:09:21 <pao> the question is... what happens if malloc fails and I have it wrapped in unsafePerformIO?
07:09:33 <b_jonas> I understand what tell does, but what do the other two methods of MonadWriter do?
07:09:42 <b_jonas> @src listen
07:09:43 <lambdabot> Source not found. That's something I cannot allow to happen.
07:09:48 <b_jonas> @src MonadWriter
07:09:49 <lambdabot> Source not found. Sorry.
07:10:14 <b_jonas> @src Writer listen
07:10:14 <lambdabot> Source not found. Are you on drugs?
07:10:19 <b_jonas> @src listen Writer
07:10:20 <lambdabot> Source not found.
07:10:34 <quicksilver> b_jonas: listen permits the monad to read the current log
07:11:03 <b_jonas> I see
07:11:05 <b_jonas> how about pass?
07:11:29 <quicksilver> pass is weird. I don't really understand why that's chosen as a primitive.
07:11:34 <quicksilver> censor is easier to understand
07:11:36 <quicksilver> :t censor
07:11:38 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
07:11:44 <quicksilver> that's just a map over the log.
07:12:27 <quicksilver> pass is kind of the same except the action gets to return its own censoring function.
07:12:32 <quicksilver> I don't know why that's a better primitive ;)
07:16:57 <b_jonas> so listen reads not the log that's already been written but the log of an action passed to it?
07:17:37 <quicksilver> b_jonas: yup.
07:17:57 <b_jonas> and it also tells that, apparently
07:17:58 <b_jonas> strange
07:18:40 <quicksilver> it doesn't prevent the action it is listening to from telling, no
07:18:52 <quicksilver> like I say, I don't really understand why they chose those primitives :)
07:21:24 <b_jonas> it's sort of like Reader
07:21:39 <b_jonas> that has the strange method "local" too
07:21:52 <quicksilver> local seems marginally less strange
07:21:56 <quicksilver> but I've never wanted it, I must admit
07:22:32 <b_jonas> but at least as I understand how these monads work, I could implement a new class and monad (or transformer) myself
07:22:37 <b_jonas> which has exactly what I want
07:24:16 <quicksilver> or indeed use the existing transformers for implementation
07:24:24 <quicksilver> and just add your interface
07:27:25 <sw17ch> Is it usually good to build with -O2 in GHC?
07:27:36 <sw17ch> (6.8.3)
07:27:37 <b_jonas> another question. is the IO-global random generator slot that Data.Random provides thread-local and a new one is splitted when you forkIO, or is it program-global and locked when you use it from one thread?
07:27:40 <BeelsebobWork> depends on whether you're getting any speedup with it
07:27:47 <BeelsebobWork> you can get fairly enormous speed up though
07:28:13 <sw17ch> BeelsebobWork, i'm just wondering b/c runhaskell Setup sdist is telling me that i might not want to do that
07:28:20 <b_jonas> I think the thumb rule is that you should use -O when you want fast compilation (almost as fast as unoptimized) when you develop, and -O2 when you want the final product
07:28:23 <BeelsebobWork> e.g. loading a moderately complex obj model goes from 30 seconds to 0.4 seconds with -O2 instead of -O0
07:28:33 <b_jonas> but I'm not sure how well that works with ghc
07:29:05 <BeelsebobWork> sw17ch: I generally write a test program for my library
07:29:10 <BeelsebobWork> and check whether it really is faster with -O2
07:29:17 <BeelsebobWork> I usually find it's fairly massively faster
07:29:25 * sw17ch decides to leave it in... 
07:29:37 <sw17ch> it's hard to measure the performance of this program without spending a bit of time to set it up
07:29:50 <sw17ch> Either way... it's still plenty fast
07:30:17 <sw17ch> Scurry currently runs at about 80% of the total link throughput. The latency is hardly noticable. (0.25 ms)
07:30:58 <quicksilver> BeelsebobWork: surely the question here is -O2 over -O1
07:31:01 <quicksilver> (not over -O0)
07:31:12 <quicksilver> that's what the cabal warning is supposed to be about
07:31:30 <quicksilver> O2 is quite a bit slower at compiling and not always significantly faster than -O1 at running.
07:31:39 <quicksilver> in certain cases it can be slower.
07:32:13 <sw17ch> does -On generate C code instead of GHC's code generator?
07:32:20 <quicksilver> no.
07:32:53 <quicksilver> b_jonas: the System.Random global RNG is program global, and I strongly suspect it's an IORef and thus not strictly thread safe.
07:33:05 <quicksilver> probably doesn't matter unless you're doing crypto or you need reproducibility.
07:33:19 <b_jonas> ok, thanks
07:33:21 <quicksilver> b_jonas: I can't check because the source links on the library doc are gone :(
07:33:36 <b_jonas> I seem to remember it's an IORef as well
07:33:52 <sw17ch> Before I start on this, is any one aware if work has been done to make a binding library to libgcrypt?
07:34:02 <b_jonas> I guess if I use random from multiple threads I'll just put a random generator in the state
07:34:36 <BeelsebobWork> http://www.cs.kent.ac.uk/people/rpg/tatd2/normals.png <-- giggle
07:49:31 <jeffersonheard> uhm...  I didn't realize http://hpaste.org/11823 would be that slow.  Just indexing through the generator is taking more than a minute
07:50:41 <quicksilver> jeffersonheard: force it to use Int or it will default to Integer
07:51:05 <jeffersonheard> k
07:51:20 <quicksilver> [(0::Int)..2048*2048*3]
07:51:36 <quicksilver> there was also a bug in the .. instance but I unforunately can't remember the details
07:51:43 <quicksilver> > length [0..2048*2048*3]
07:51:45 <lambdabot>   12582913
07:51:47 <quicksilver> > length [0..2048*2048*3]
07:51:49 <lambdabot>   12582913
07:51:52 <pozic> Anyone who doesn't think this is "beautiful", but just a silly hack? http://squing.blogspot.com/2008/11/beautiful-folding.html
07:51:53 <lambdabot> Title: The Most Fuun You Can Have: Beautiful folding
07:51:55 <quicksilver> that doesn't take more than a minute.
07:52:02 <quicksilver> > length [(0::Int)..2048*2048*3]
07:52:04 <lambdabot>   12582913
07:52:05 <quicksilver> > length [(0::Int)..2048*2048*3]
07:52:07 <lambdabot>   12582913
07:52:08 * quicksilver shrugs
07:53:18 <jeffersonheard> in pure code, no...  it shouldn't be any different with the forM_ I wouldn't think, but I've been known to be wrong
07:53:34 <pozic> jeffersonheard: did you solve your prevous problem already?
07:54:10 <jeffersonheard> pozic, yes.  Everything works, in fact, except that I discovered my pixbuf had serious stride issues
07:54:33 <pozic> serious stride issues?
07:54:48 <jeffersonheard> > length . take 2048 $ [0,18432..]
07:54:50 <lambdabot>   2048
07:55:13 <pozic> jeffersonheard: what do you mean?
07:55:14 <jeffersonheard> as in the distnace between rows was much different than I was expecting.
07:55:40 <jeffersonheard> fixing that led to the problem I'm trying to fix now
07:56:01 <pozic> jeffersonheard: so you encoded a 2d structure with a list?
07:56:26 <jeffersonheard> can't be helped.  that's how the GdkPixbuf is stored
07:56:36 <jeffersonheard> and it has to be poked into a single pointer
07:56:49 <albdogo> has anyone implemented a trie in haskell
07:56:50 <pozic> jeffersonheard: it's not a 2d array? That's odd.
07:56:59 <pozic> albdogo: yes
07:57:09 <jeffersonheard> > length . concat . map (\n -> take 6144 [n..]) $ [ take 2048 $ [0,18432..]
07:57:10 <lambdabot>   <no location info>: parse error on input `;'
07:57:11 <pozic> albdogo: there is a library on Hackage, if that's your question.
07:57:25 <albdogo> what is hackage
07:57:34 <dmwit_> ?where hackage
07:57:35 <lambdabot> http://hackage.haskell.org/
07:57:46 <albdogo> ok ty
07:58:54 <dmwit_> jeffersonheard: Wait, what's this about pixbuf's storage mechanism?
07:59:19 <jeffersonheard> > length . concat . map (\n -> take 6144 [n..]) . take 2048 $ [0,18432..]
07:59:26 <lambdabot>   12582912
07:59:40 <jeffersonheard> dmwit_: it stores the whole thing as a single, long 1d array
07:59:53 <dmwit_> Right.  Not a *list*, though.
08:00:17 <jeffersonheard> no, def not.
08:00:25 <dmwit_> And it gives a function that tells the striding information...
08:00:35 <jeffersonheard> yeah, which I forgot to call earlier
08:00:45 <dmwit_> ah =)
08:01:01 <jeffersonheard> now fixing, but I've run into the speed problem
08:01:38 <jeffersonheard> quicksilver:  I get this from ghci when I do this:  length . concat . map (\n -> take 6144 [n..]) $ take 2048 $ [0,18432..]
08:01:44 <jeffersonheard> ^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?12582912
08:01:51 <jeffersonheard> fresh ghci instance
08:01:57 <jeffersonheard> and it takes a few secs to complete
08:02:23 <albdogo> @src trie
08:02:23 <lambdabot> Source not found. That's something I cannot allow to happen.
08:02:54 <dmwit_> jeffersonheard: Wow, that is definitely not normal behavior.
08:02:58 <dmwit_> What version of GHC?
08:03:16 <jeffersonheard> 6.8.3 on Ubuntu 8.10
08:03:46 <jeffersonheard> yeah, this is seriously my problem...
08:03:51 <dmwit_> That's basically what I'm using.
08:03:53 <jeffersonheard> >  forM_ (concat . map (\n -> take 6144 [n..]) $ take 2048 $ [0,18432..]) (\_ -> return ())
08:03:54 <lambdabot>       No instance for (Show (m ()))
08:03:54 <lambdabot>        arising from a use of `show' at <i...
08:04:06 <jeffersonheard> >  forM_ (concat . map (\n -> take 6144 [n..]) $ take 2048 $ [0,18432..]) (\_ -> return "m")
08:04:07 <lambdabot>       No instance for (Show (m ()))
08:04:07 <lambdabot>        arising from a use of `show' at <i...
08:04:12 <dmwit_> I would recommend trying to install GHC again or *something*, because that's definitely not right. =P
08:04:14 <jeffersonheard> well, fine then, lambdabot
08:04:27 <dmwit_> jeffersonheard: Specify a monad instance.
08:04:38 <jeffersonheard> >  forM_ (concat . map (\n -> take 6144 [n..]) $ take 2048 $ [0,18432..]) (\_ -> return ()) :: IO ()
08:04:40 <lambdabot>   * Exception: "<IO ()>"
08:04:42 <pozic> jeffersonheard: that expression works with 6.8.2.
08:04:48 <Botje> jeffersonheard: works for me, ghc 6.8.3 on ubuntu 8.10
08:04:57 <albdogo> i only see memoTries
08:04:58 <jeffersonheard> pozic, how long does it take?
08:04:59 <Botje> are you sure it's not your terminal or somesuch?
08:05:04 <jeffersonheard> Botje, are you on 64bit or 32?
08:05:06 <jeffersonheard> I'm on 64
08:05:08 <Botje> 32bit
08:05:09 <pozic> jeffersonheard: more than a few seconds.
08:05:36 <albdogo> isnt there tries in the standard libraries?
08:05:46 <Deewiant> nope
08:05:47 <jeffersonheard> right... so in any case, I should write out a function by hand and not try to use the generators
08:05:54 <dmwit_> albdogo: No.  But there are packages on Hackage that do it.
08:05:54 <jeffersonheard> just to speed things along
08:05:54 <Botje> doesn't happen on debian 64bit 6.8.2
08:05:57 <pozic> jeffersonheard: a computation over 12 million objects.
08:06:15 <pozic> jeffersonheard: so, that's to be expected.
08:06:17 <jeffersonheard> pozic, or a for loop over 12 million Ints
08:06:18 <dmwit_> albdogo: I don't think anybody really considers a dependency on a Hackage package controversial in any way, either, so feel free to use them.
08:06:31 <pozic> jeffersonheard: ghci doesn't optimise.
08:06:55 <pozic> jeffersonheard: and it works on Integers, probably.
08:07:03 <jeffersonheard> no, pozic, but I'm getting the same or worse behaviour after "ghc -O -fvia-C -optc-O2"
08:07:09 <jeffersonheard> using ints
08:07:19 <albdogo> i want to make an index generator
08:07:20 <pozic> jeffersonheard: why do you go via C?
08:07:34 <albdogo> but I dont find monads for tries
08:07:40 <jeffersonheard> because it was faster.  tried out a bunch of different optimization flags
08:07:57 <trofi> what does profiler show?
08:08:31 <jeffersonheard> about to get there...  I know that the memory performance is good, because it was bad before, and by bad I meant I had to do a -kSz to get it to run at all
08:08:33 <jeffersonheard> i
08:09:25 <albdogo> a monadic trie is what i need, any ideas?
08:09:38 <Deewiant> monadic how?
08:09:54 <pozic> jeffersonheard: 0m2.784s
08:09:58 <pozic> jeffersonheard: that's what I get.
08:09:58 <albdogo> the functions of the trie
08:10:19 <Deewiant> for example?
08:10:39 <albdogo> insertion of a word into the trie
08:10:39 <jeffersonheard> that's pretty reasonable. and entirely unlike what I get, oddly
08:10:53 <jeffersonheard> same code, just stuffed it in a main.hs and compiled with -O
08:11:04 <Deewiant> albdogo: why would it have to be monadic?
08:11:07 <pozic> jeffersonheard:  ghc --make -O2 Jeffersonheard.hs
08:11:12 <jeffersonheard> 0m30.751 sec.  on an 8-core opteron
08:11:18 <pozic> jeffersonheard: o.O
08:11:19 <albdogo> i dont know
08:11:20 <b_jonas> what's all your opinion about this module mutual dependency feature in ghc? are there any caveats? is it as easy to separete code to compilation units if you're allowed to use it as in say C?
08:11:32 <jeffersonheard> I think it's like someone said.  time to reinstall GHC
08:11:34 <pozic> jeffersonheard: ok, I made some small changes.
08:11:34 <jeffersonheard> :P
08:11:40 <pozic> jeffersonheard: wait
08:11:54 <albdogo> direct recursion can do the job?
08:11:55 <pozic> jeffersonheard: main =  print (length . concat . map (\n -> take 6144 [(n::Int)..]) $ take 2048 $ [(0::Int),18432..])
08:12:23 <pozic> jeffersonheard: it's in the type annotations, probably.
08:13:19 <pozic> jeffersonheard: you should be able to make it faster by using the extra cores, of course.
08:13:26 <b_jonas> the link to the GHC user's guide in pdf from http://haskell.org/haskellwiki/GHC is broken
08:13:28 <lambdabot> Title: GHC - HaskellWiki
08:13:30 <albdogo> I can make data Trie = Leaf | Branch Char [Trie]
08:13:53 <albdogo> i figured out that a monad is simpler if i find some
08:14:02 <jeffersonheard> be nice, but the extra cores were conflicting with Gtk's OpenGL interface yesterday, so I'm forgoeing them for now.  This thing worked fine before they decided it needed to be shiny
08:14:12 <jeffersonheard> I was happy with the perf. using GdkPixbuf and Cairo
08:14:16 <pozic> jeffersonheard: be nice?
08:14:28 <jeffersonheard> it'd be nice
08:14:32 <pozic> jeffersonheard: oh, right.
08:14:32 <jeffersonheard> if I could use the extra cores
08:14:51 <jeffersonheard> I'll probably get there, but I'm in one-problem-at-a-time mode atm
08:15:00 <pozic> jeffersonheard: have you compiled gtk2hs with profiling libraries?
08:15:07 <jeffersonheard> no
08:15:34 <jeffersonheard> and multithreaded gtk was working, but not gtk with gl
08:15:40 <b_jonas> the archived many-html version does work though, and it's for 6.10.1 so it's fresh
08:15:52 <Cale> albdogo: Oh, you mean like a trie with IO or ST references in it?
08:16:07 <Cale> albdogo: So that you can do mutating updates?
08:16:27 <albdogo> yes, something like that
08:16:59 <Cale> albdogo: It might be worth trying to just use Data.Map instead of lists at first. They have logarithmic update, and if your alphabet is finite, that's constant time :)
08:17:23 <albdogo> Data.Map is a hash table¿
08:17:32 <pozic> Cale: finding an optimal algorithm for a problem is also O(1) ;)
08:17:43 <pozic> albdogo: no, it's better.
08:17:52 <Cale> albdogo: Balanced binary trees.
08:18:04 <pozic> albdogo: the O(1) lookup is non-sense for hash tables.
08:18:07 <albdogo> what
08:18:10 <pozic> albdogo: it's only expected.
08:18:12 <albdogo> wait *
08:18:23 <Deewiant> and it doesn't include the time to compute the hash :-)
08:18:28 <Cale> pozic: Also, it fails to count the time needed to compute the hash.
08:18:30 <Cale> yeah
08:19:10 <BONUS> why would the time needed to compute the hash have to be considered in big O notation?
08:19:17 <Cale> If a hash function is capable of sending n elements to distinct values, it must be observing at least O(log n) bits of the input.
08:19:53 <albdogo> but Cale, arnt tries more efficient than avl tries for the task of creating indixes?
08:19:57 <Cale> Which means that a good-enough hash function takes at least logarithmic time.
08:20:00 <albdogo> indexes*
08:20:16 <quicksilver> Cale: and array lookup also takes at least logarithmic time
08:20:19 <Cale> albdogo: I'm not saying to use Data.Map for the whole thing, just in place of the lists.
08:20:25 <quicksilver> Cale: by a fairly similar argument.
08:20:29 <Cale> quicksilver: right.
08:20:33 <albdogo> ah ic
08:21:11 <Deewiant> albdogo: I'm writing a trie library at the moment, if that's any consolation :-)
08:22:06 <albdogo> can i see the code
08:22:22 <Deewiant> it's not really ready; what do you want to see?
08:22:37 <albdogo> have u programmed insertion?
08:22:44 <Deewiant> yep
08:23:13 <albdogo> can i see that pls
08:23:47 <Deewiant> the current version only has sets for Enum keys though
08:24:15 <albdogo> ic
08:24:25 <jeffersonheard> pozic, the following code takes no time at all: http://hpaste.org/11824
08:24:47 <albdogo> u can use a Ord class
08:24:48 <Deewiant> albdogo: http://hpaste.org/11825
08:24:49 <jeffersonheard> yay strictness annotations and no cons allocations
08:24:55 <albdogo> deewiant?
08:25:11 <Deewiant> albdogo: Enum with IntMaps is better than Ord with Maps
08:25:13 <albdogo> i just say to be more generic
08:25:26 <dmwit_> jeffersonheard: It also doesn't do anything.
08:25:27 <Deewiant> most generic is an Eq class
08:25:30 <Cale> jeffersonheard: What does that code actually do?
08:25:43 <albdogo> Ord for the ordered insertions
08:26:03 <Deewiant> albdogo: but yes, it will support Eq/Ord/Enum key types out of the box as well as the ability to construct tries for different key types :-)
08:26:08 <albdogo> bc i need the output ordered
08:26:11 <Cale> jeffersonheard: Does it get optimised to  return ()  by the compiler?
08:26:13 <jeffersonheard> dmwit_, Cale: I realize that.  I was using generators for indexing and it was taking 30 seconds.  that took no time at all
08:26:13 <dmwit_> albdogo: Are you confusing trees and tries?
08:26:24 <albdogo> nop
08:26:46 <albdogo> i dont know the class Enum
08:26:56 <jeffersonheard> the point being that I'll add some body to it in a minute -- the array copy I was doing (from PixbufData Int Word8) to a Ptr Word8
08:27:08 <Deewiant> albdogo: to get it out ordered is just a matter of getting the keys out of the map in order, and both IntMap and Map support 'toAscList' :-)
08:27:11 <Cale> jeffersonheard: ah
08:27:51 <jeffersonheard> Cale: getElems from MArray ends up copying all of the array to Haskell's memory before it pokes it into the Ptr Word8, which was inefficient, and caused a massive amount of overhead
08:27:53 <Cale> jeffersonheard: You might consider writing it with guards instead of if/then/else
08:27:56 <bos> @seen juhp
08:27:56 <lambdabot> juhp is in #haskell. I don't know when juhp last spoke.
08:28:27 <jeffersonheard> Cale: of course.
08:28:46 <jeffersonheard> and not hardcoding all the indices
08:28:50 <jeffersonheard> :P
08:28:59 <Cale> jeffersonheard: Ah, yeah, if you're only accessing the foreign array once, chances are that converting it to an MArray is going to be too slow.
08:29:12 <Cale> er...
08:29:20 <Cale> Or is it going the other way around?
08:29:57 <jeffersonheard> The other way around.  Using the MArray to poke into the foreign array, but the MArray interface to GdkPixbuf allows me to do an unsafeRead without copying the entire array into memory
08:30:12 <jeffersonheard> using getElems is head-strict,  it seems
08:30:33 <roconnor> shapr[: http://www.ams.org/notices/200811/
08:30:35 <lambdabot> Title: Notices of the American Mathematical Society
08:30:44 <jeffersonheard> so copying from foreign memory to haskell memory to foreign memory was horribly inefficient
08:32:13 <whoppix> Hello. Can anyone recommend an IDE that is suited for writing Haskell, that runs on linux (x86_64)? Eclipse is not an option, unfortunately.
08:32:23 <Vq^> whoppix: emacs
08:32:24 <quicksilver> whoppix: emacs.
08:32:39 <jeffersonheard> whoppix, leksah if you want an IDE
08:32:42 <quicksilver> (it was a trick question. There are no good IDEs. And there are certainly no good haskell IDEs)
08:32:44 <jeffersonheard> I use vi
08:33:12 <roconnor> how is yi doing nowadays?
08:33:16 <Vq^> quicksilver: "good" wasn't among the requirements
08:33:17 <boyscared> haskell-mode on emacs :P
08:33:18 <thoughtpolice> it works
08:33:19 <whoppix> quicksilver, Vq^, can emacs do the usual stuff, like code introspection, outlining, calltip completion and such?
08:33:23 <dcoutts> roconnor: ok I think
08:33:27 <quicksilver> whoppix: nope.
08:33:39 <quicksilver> it can do outlining.
08:33:54 <quicksilver> there are a few fragments of introspection.
08:33:59 <thoughtpolice> roconnor: yi 0.5 works pretty well
08:34:01 <jeffersonheard> if you feel like wrangling ctags, then it can do calltip completion
08:34:01 <quicksilver> there is no smart completion.
08:34:09 <jeffersonheard> or rather, introspection
08:34:10 <jeffersonheard> not completion
08:34:29 <quicksilver> nobody has a smart completer for haskell.
08:34:37 <quicksilver> I'm not entirely sure anybody knows how to write own, even.
08:34:42 <quicksilver> it's not obvious to me.
08:34:48 <whoppix> doesn't GHCi kinda completes some things?
08:34:58 <quicksilver> Java has this very convenient thing.method(stuff.othermethod())
08:35:08 <quicksilver> which enables you to chekc the type of 'thing' and then list its methods
08:35:18 <quicksilver> most of that doesn't conveniently apply to haskell's syntax.
08:35:28 <quicksilver> whoppix: yes, very simple completion of symbols is easy enough.
08:35:35 <jeffersonheard> quicksilver: and you know, that was one thing that I thought should be fairly "easy" given all the type algebra.  One of these days I'd like to see someone try context-aware voice recognition on a type-safe language
08:35:41 <quicksilver> emacs's built in completion does that fine.
08:35:50 <quicksilver> jeffersonheard: the problem is that partial programs don't type check.
08:35:57 <quicksilver> jeffersonheard: partial programs are just meaningless.
08:36:15 <albdogo> Deewiant can u put a piece of software in here
08:36:28 <quicksilver> jeffersonheard: to solve this problem you need to identify "holes" - bits of code which the programmer hasn't filled in yet
08:36:38 <Deewiant> albdogo: the whole thing is a bit too long to be pasted
08:36:39 <quicksilver> jeffersonheard: and perform type inference with that hole as a free type variable.
08:36:40 <albdogo> its just to see if monadic is better or not
08:36:48 <quicksilver> jeffersonheard: it's not trivial ;)
08:37:03 <albdogo> ok Deewiant
08:37:21 <jeffersonheard> quicksilver, I figured that out once I tried it...  gave up
08:37:27 <quicksilver> jeffersonheard: yeah.
08:37:29 <Deewiant> albdogo: remember, don't optimize until you need to :-)
08:37:36 <quicksilver> it's an interesting thing to do, and it would be fun to have it working.
08:37:43 <quicksilver> infix operators make it really hard
08:37:50 <jeffersonheard> originally tried it with OCaml, actually, several years ago
08:37:50 <Deewiant> albdogo: if you're happy with your current performance then stick with that, saves me the trouble of uploading a file ;-)
08:37:55 <quicksilver> foo <$> bar <*> baz
08:38:07 <albdogo> its ok dwweint
08:38:12 <albdogo> deewiant
08:38:16 <quicksilver> ^^ suppose I am partway through typing this, and the insertion point is just before I'm about to type <$>
08:38:16 <pozic> jeffersonheard: that seems like register code, yes.
08:38:28 <quicksilver> how on earth can it guess my plan is to type a new infix operator?
08:38:46 <quicksilver> after the <$> things might be a bit better.
08:38:52 <jeffersonheard> yeah
08:39:06 <quicksilver> then you have to worry about right and left association.
08:39:10 <pozic> jeffersonheard: I don't see how you read your PixbugData, though, as the documentation is broken.
08:39:20 <pozic> jeffersonheard: (some links don't work)
08:39:21 <quicksilver> to be fair, the java IDEs can't cope with infix operators very well either.
08:39:33 <quicksilver> but the difference is that most of Java code is boring method calls.
08:39:33 <jeffersonheard> doc is broken on the gtk2hs site?
08:39:36 <quicksilver> so they work in the common case.
08:39:40 <jeffersonheard> I'm using it now...
08:39:48 <quicksilver> lots of haskell code, in my experience, is infix operators.
08:39:48 <pozic> jeffersonheard: http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.8/Graphics.UI.Gtk.Gdk.Pixbuf.html#t%3APixbuf
08:39:50 <lambdabot> Title: Graphics.UI.Gtk.Gdk.Pixbuf, http://tinyurl.com/5rgpj7
08:39:58 <pozic> jeffersonheard: and then a link to the HasBounds class.
08:40:01 <jeffersonheard> oh right
08:40:23 <jeffersonheard> yeah.  you use MArray .readArray or Data.Array.Base.unsafeRead to pull a Word8 from it
08:40:26 <jeffersonheard> took awhile to figure that out
08:40:46 <albdogo> ok, g2g
08:40:51 <albdogo> see ya next time
08:44:16 <FunctorSalad> it seems that any utility function "a -> IO b" would benefit from being turned into "(MonadIO m) => a -> m b" so the caller isn't cluttered with liftIOs... am I missing something?
08:45:41 <sbahra> mmorrow, http://www.achronix.com/index.php
08:45:45 <sbahra> mmorrow, looked at that yet
08:45:46 <sbahra> ?
08:46:00 <sbahra> @tell mmorrow http://www.achronix.com/index.php
08:46:01 <lambdabot> Consider it noted.
08:48:01 <jeffersonheard> is there a language pragma for bang patterns?
08:48:09 <Deewiant> BangPatterns?
08:48:12 <jeffersonheard> nope
08:48:24 <jeffersonheard> oh wait
08:48:25 <jeffersonheard> missing comma
08:48:27 <jeffersonheard> yes
08:48:29 <Deewiant> heh
08:50:34 <quicksilver> FunctorSalad: no you're not.
08:50:46 <quicksilver> FunctorSalad: in fact, I propose the FFI itself should have that type.
08:50:58 <quicksilver> FunctorSalad: however, it doesn't help you with callbacks :-/
08:51:39 <conal> @seen BeelsebobWork
08:51:39 <lambdabot> BeelsebobWork is in #haskell and #ghc. I last heard BeelsebobWork speak 1h 17m 2s ago.
08:54:49 <Deewiant> argh, why do the *By functions in Data.List have more restrictive types than they could have
08:57:36 <quicksilver> :t nubBy
08:57:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
08:57:40 <quicksilver> Deewiant: ?
08:59:31 <Deewiant> quicksilver: mostly the ones that take more than one parameter in addition to the function :-)
08:59:41 <Deewiant> e.g. deleteBy
08:59:44 <Deewiant> :t deleteBy
08:59:45 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
08:59:50 <Deewiant> ?ty let deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys in deleteBy
08:59:51 <lambdabot> forall t t1. (t -> t1 -> Bool) -> t -> [t1] -> [t1]
08:59:59 <Deewiant> (just copy-pasting the definition)
09:00:08 <quicksilver> oh, that's an odd one.
09:00:34 <quicksilver> why isn't that just defined in terms of filter?
09:00:49 <Deewiant> because it only deletes one
09:00:51 <saml> > average [1 .. 1000000000]
09:00:51 <lambdabot>   Not in scope: `average'
09:00:54 <quicksilver> ah.
09:00:57 <Deewiant> > deleteBy (== 1) [1,1,2]
09:00:58 <lambdabot>   Couldn't match expected type `a -> Bool'
09:01:02 <Deewiant> > deleteBy (==) 1 [1,1,2]
09:01:04 <lambdabot>   [1,2]
09:01:14 <quicksilver> I don't understand why it wants two arguments
09:01:20 <Deewiant> there was discussion about this in 2001 related to the H98 report
09:01:20 <quicksilver> (==) 1 instead of just (==1)
09:01:22 <saml> > let average x = sum x / length x in average [1 .. 1000000000]
09:01:23 <lambdabot>       No instance for (Fractional Int)
09:01:23 <lambdabot>        arising from a use of `/' at <i...
09:01:25 <quicksilver> (in this example)
09:01:37 <Deewiant> the thread is "Haskell 98 Report" in haskell-general
09:01:52 <quicksilver> I wonder why it isn't deleteBy :: (a -> Bool) -> [a] -> [a]
09:01:52 <Deewiant> quicksilver: for duality with 'delete :: a -> [a] -> [a]'
09:02:14 <Deewiant> so that delete = deleteBy (==)
09:02:29 * quicksilver nods
09:02:29 <Deewiant> it's arguable whether that's a good reason but that's most likely the reason :-)
09:02:31 <quicksilver> OK.
09:02:34 <quicksilver> I'm sure you're right.
09:02:51 <quicksilver> I'd rather have deleteIf :: (a -> Bool) -> [a] -> [a]
09:03:05 <quicksilver> ... avoiding use of 'By' to avoid making that parallel ...
09:03:19 <conal> and maybe call it "deleteFirst"
09:04:12 <quicksilver> yeah, better name.
09:04:45 <Deewiant> it appears to have been wanted to be the case that 'foo :: Eq a => type' --> 'fooBy :: (a -> a -> Bool) -> type' and 'foo = fooBy (==)', and similarly s/Eq/Ord/ and s/(==)/compare/
09:04:55 <whoppix> @index filter
09:05:00 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
09:05:05 <quicksilver> Deewiant: yes, I can understand the consistency argument.
09:05:12 <quicksilver> Deewiant: although I think deleteBy is pretty weird as a result :)
09:05:25 <Deewiant> but this somewhat sucks since now I have to copy-paste the definitions into my code, just changing the type signatures.
09:05:28 <quicksilver> Deewiant: I'd have been tempted to drop deleteBy entirely on grounds of questionable use.
09:05:42 <quicksilver> god knows there are more interesting functions ommitted from the Prelude
09:05:44 <Deewiant> quicksilver: it's used to define deleteFirstsBy.
09:05:51 <quicksilver> like groupsOf (half-inverse to concat)
09:05:52 <Deewiant> which makes it handy in that form, I guess.
09:11:19 <Deewiant> heh, sweet
09:11:20 <Deewiant> deleteFirstsBy = foldl' . flip . deleteBy . flip
09:11:33 <quicksilver> ;)
09:11:58 <Deewiant> ?ty \f -> foldl' . flip . f . flip
09:11:59 <lambdabot> forall a c a1 b c1. ((b -> a1 -> c1) -> a -> c -> c) -> (a1 -> b -> c1) -> c -> [a] -> c
09:13:59 <saml> > 1 :: maxBound
09:14:00 <lambdabot>       Could not deduce (Num maxBound) from the context ()
09:14:00 <lambdabot>        arising from...
09:14:31 <saml> how can I get bound of Int?
09:14:43 <b_jonas> > maxBound :: Int
09:14:44 <lambdabot>   9223372036854775807
09:14:59 <saml> thanks b_jonas
09:15:11 <b_jonas> saml: also there's the asTypeOf function
09:15:38 <b_jonas> > maxBound `asTypeOf` (1 :: Int)
09:15:40 <lambdabot>   9223372036854775807
09:15:44 <b_jonas> > maxBound `asTypeOf` (1 :: Integer)
09:15:45 <lambdabot>       No instance for (Bounded Integer)
09:15:45 <lambdabot>        arising from a use of `maxBoun...
09:16:09 <b_jonas> so you can write maxBound `asTypeOf` x to get the maxBound of the type of the number x
09:21:58 <mib_ewisth> need to write a parser and am not able to define the grammar, get unexpected `;' error between lines, help please
09:22:56 <Saizan> mib_ewisth: paste your code on hpaste.org
09:23:01 <liwp> is this with parsec?
09:24:20 <mib_ewisth> pasted
09:24:33 <liwp> url?
09:24:53 <mib_ewisth> http://hpaste.org/11827
09:25:33 <liwp> you get the error when compiling this?
09:25:37 <saml> > maxBound `asTypeOf` "a"
09:25:38 <lambdabot>       No instance for (Bounded [Char])
09:25:38 <lambdabot>        arising from a use of `maxBound...
09:25:48 <mib_ewisth> yeah
09:25:55 <Saizan> mib_ewisth: that's not haskell syntax
09:26:03 <saml> > maxBound `asTypeOf` 'ㅁ'
09:26:04 <lambdabot>   '\1114111'
09:26:46 <liwp> are you tyring to use a parser generator or something like that, e.g. happy?
09:26:48 <saml> bounded data types ftw
09:26:53 <idnar> that looks more like BNF
09:27:32 <mib_ewisth> that's from the textbook, im not sure how the syntax would look like
09:28:38 <mib_ewisth> don't know what a parser generator is...
09:28:55 <Saizan> that's BNF, an abstract notation for grammars, in haskell you've to translate that to code using parser combinators
09:29:19 <liwp> a parser gnerator takes a grammar definiton (like the one you have) and generates a parser, i.e. executable code from it
09:29:41 <liwp> it makes it a lot faster to implement a parser from a grammar definiton
09:30:51 <liwp> so you can either try to use a parser generator like Happy to generate a parser, or use parsec to code the parser yourself. It's relatively straight forward to implement you grammar in parsec
09:33:52 <pozic> liwp: can Happy do left recursive grammars?
09:34:13 <liwp> i actually haven't used happy myself, so i dunno
09:34:41 <liwp> AFAIK happy is basically the ecquivalent of yacc in haskell
09:34:43 <Saizan> happy produces an LR parser, iirc, so it should
09:35:19 <jekor`> I'm trying to run the App monad from http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell, but within FastCGI instead of CGI. runFastCGIConcurrent' expects CGI CGIResult -> IO () but I have App CGIResult -> IO (), and I'm at a complete loss for how to do this the proper way.
09:35:22 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2n99cj
09:36:45 <mib_ewisth> this is for an assignment so i really doubt I'm supposed to use a generator to do it
09:38:21 <liwp> in that case parsec you make sense
09:38:35 <liwp> google for parsec and try to find an example
09:38:49 <liwp> your grammar should translate pretty easily to parsec
09:39:10 <Saizan> jekor`: you've to modify runApp
09:41:01 <dons> ?seen Cale
09:41:02 <lambdabot> I saw Cale leaving #haskell, #ghc and #haskell-overflow 21m 17s ago, and .
09:41:03 <dons> wow
09:41:12 <jekor`> Saizan: So I have to somehow call runFastCGIConcurrent' from within runApp?
09:43:01 <mib_ewisth> alright thanks
09:53:59 <Saizan> jekor`: the point is that runReaderT a c :: CGI CGIResult, so you can use it with functions that expect that type
09:55:00 <Saizan> jekor`: but with runFastCGIConcurrent it forks a thread for each request instead of executing a new instance of the script, so you shouldn't open and keep active a single connection up front
09:56:19 <wjt> The Community server, http://community.haskell.org/, has two new
09:56:19 <lambdabot> Title: Haskell Community Server
09:56:27 <wjt> argh!
09:56:48 <jekor`> Saizan: Thanks. I was concerned about the database handle being used concurrently.
09:56:49 * wjt discovers a downside of configuring his middle button to be both scroll and click :(
09:57:37 <jekor`> Oh...
10:00:07 <b_jonas> hmm
10:00:19 <b_jonas> the testsuite gave me some failures
10:03:42 <b_jonas> here is the output: http://erxz.com/pb/13319
10:03:43 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
10:03:49 <b_jonas> what should I do now?
10:04:04 <albdogo> hi
10:07:43 <saml> hi albdogo
10:08:13 <albdogo> hi
10:08:23 <albdogo> im trying to implement tries in haskell
10:08:30 <saml> what is tries?
10:08:35 <saml> try-except ?
10:08:40 <albdogo> no
10:08:54 <profmakx> tries are a data structure
10:08:58 <albdogo> its a tree for storing words
10:09:26 <saml> data Trie a = Leaf a | Branch (Trie a) (Tria a) ??
10:09:46 <albdogo> i have data Trie = Root | Leaf | Branch Char [Trie]
10:10:16 <sbahra> y Root?
10:10:22 <albdogo> oic
10:10:30 <albdogo> it is not necessary
10:10:37 <albdogo> data Trie = Leaf | Branch Char [Trie]
10:10:59 <albdogo> now i need an insert fucntion
10:11:15 <b_jonas> albdogo: so how would that store if a word ends in an internal point?
10:11:22 <sm> good morning all.. on with my "real world" haskell issue, which I understand better now. I fetch a feed with non-ascii content,  then I print the xml using Text.XML.Light.Output.ppTopElement. At this point the non-ascii characters are converted to html entities. I want them left alone, with the xml specifying utf8 encoding. Am I doing something wrong ? Is this a bug in the xml light package ?
10:12:19 <albdogo> it keeps marked by a leaf node b_jonas
10:12:35 <b_jonas> albdogo: but what if you have a word and a prefix of it as well?
10:12:46 <albdogo> i put a leaf
10:12:51 <b_jonas> oh, I see
10:13:05 <albdogo> yep
10:13:09 <b_jonas> so the whole trie would be of type [Trie], not of type Trie then
10:13:21 <b_jonas> makes sense
10:13:48 <albdogo> maybe i had to add Root [Trie]
10:13:59 <b_jonas> not to that type
10:14:20 <b_jonas> you could define a separate type for it as an abstraction, but you don't want to have roots inside the trie
10:14:21 <albdogo> why not
10:14:27 <sbahra> Why yes?
10:14:45 <albdogo> why not
10:15:01 <b_jonas> because it doesn't make much sense to have a root inside the list of a branch
10:15:05 <albdogo> so i would keep a list for the tree?
10:15:19 <sbahra> No.
10:15:23 <b_jonas> you can define a separate wrapper type or a type synonym for the root
10:15:34 <b_jonas> and work with that
10:15:41 <sbahra> albdogo, so what problem are you having with the insert function?
10:16:04 <albdogo> theres is a time i dont use haskell
10:16:27 <albdogo> I'm trying to program the insertion function
10:16:32 <albdogo> and i dont know how
10:16:36 <b_jonas> like data TrieNode = Leaf | Branch Char [Trie]; data Trie = Trie TrieNode; emptyTrie :: Trie; emptyTrie = Trie []; insertTrie :: Trie -> [Char] -> Trie;
10:16:44 <albdogo> insert x Leaf = Branch x Leaf:[]
10:16:49 <b_jonas> albdogo: sure, but first decide about the representation
10:17:14 <albdogo> The list for the brothership is ok?
10:17:19 <b_jonas> no wait, the one I supposed is no good
10:17:27 <b_jonas> you don't want those two data I just wrote
10:17:54 <b_jonas> because when you recurse down the trie, you want to work with the list at the top the same way as the list in the middle
10:18:11 <albdogo> yeah
10:18:25 <ddarius> fix (Branch 'a' . return)
10:18:31 <b_jonas> so either you handle just plain lists, or make Branch have a root in it (so you have two mutually recursive types)
10:18:41 <b_jonas> or there might be a third solution that's even simpler
10:18:58 <albdogo> which one
10:19:05 <b_jonas> dunno
10:19:11 <albdogo> hehe
10:19:34 <b_jonas> anyone else listening?
10:19:45 <vixey> not me
10:20:49 <b_jonas> if no-one is listening then it's probably up to you albdogo: mutually recursive or the top of the trie is a list (or a type synonym of it)?
10:21:10 <velco> http://www.reddit.com/r/programming/comments/7bzb7/bitc_is_a_new_systems_programming_language_it/c068os3
10:21:13 <lambdabot> Title: psnively comments on BitC is a new systems programming language. It seeks to com ..., http://tinyurl.com/6lzfkj
10:21:22 <b_jonas> so the first one would be data TrieNode = Leaf | Branch Char Trie; data Trie = [TrieNode];
10:21:26 <albdogo> i can put a dummy Branch
10:21:33 <velco> is mutability and type inference even related ?
10:21:55 <b_jonas> um
10:21:59 <b_jonas> so the first one would be data TrieNode = Leaf | Branch Char Trie; data Trie = Trie [TrieNode];
10:22:03 <b_jonas> of course
10:22:20 <b_jonas> and the second would be data TrieNode = Leaf | Branch Char Trie; type Trie = [TrieNode];
10:22:31 <b_jonas> well, it's not much of a difference so let's suppose the first one
10:22:52 <b_jonas> so your empty trie would be emptyTrie = Trie [];
10:22:56 <albdogo> the second one i prefer
10:23:09 <albdogo> nop?
10:23:11 <b_jonas> ok, then emptyTrie :: Trie; emptyTrie = [];
10:23:17 <albdogo> ok
10:23:32 <vixey> velco: took a look at the documentation yet?
10:23:38 <b_jonas> the insert function would have type insertTrie :: Trie -> [Char] -> Trie;
10:23:48 <velco> vixey: no
10:23:57 <albdogo> String
10:24:01 <vixey> velco: oh right then
10:24:04 <b_jonas> and then to write the body of the function you just need to consider three cases depending on which constructor of the trie and the char you take
10:24:05 <velco> vixey: well, took a quicjk look
10:24:19 <velco> vixey: but didn;t read it all
10:24:22 <b_jonas> to insert an empty string, you need to add a leaf, right?
10:24:36 <b_jonas> um, just two, not four
10:24:37 <albdogo> right
10:25:07 <b_jonas> well, you have to think of duplicates too
10:25:23 <b_jonas> what if the trie already has the string? would you add another leaf or id?
10:25:29 <velco> ah, ok, found that paper
10:25:43 <albdogo> add anorther leaf
10:25:58 <b_jonas> insertTrie t [] = Leaf : t;
10:26:00 <b_jonas> that's easy then
10:26:20 <b_jonas> for the other case you have to read the list though because you clearly don't want to add two branches of the same char
10:26:51 <b_jonas> so then for a non-empty string you'd need two cases depending on whether the trie has a branch of the first character of that string
10:27:38 <velco> however the paper starts with a gross violation of C standard :|
10:28:01 <albdogo> i dont know bjonas
10:28:23 <b_jonas> now we can do that in two ways: either you recurse on the list of trienodes, so you have three cases (empty trie in which case you add a new branch, first node matches character, or anything else in which case you insert to the rest of the list)
10:28:25 <albdogo> much time since im not programing
10:28:28 <b_jonas> or you use list functions
10:28:45 <b_jonas> would you want to use the list functions from the library to search for the matching branch?
10:29:03 <albdogo> which are those
10:29:12 <albdogo> i dont know much the libraris
10:29:37 <b_jonas> well, let's recurse then
10:29:48 <albdogo> theres another representation
10:30:17 <albdogo> Trie = Leaf | Brancha Trie Trie
10:30:26 <albdogo> Trie = Leaf | Branch Char Trie Trie
10:30:42 <b_jonas> you said you wanted to allow two leafs
10:30:45 <albdogo> one would be the brother and the other being the first child
10:31:03 <b_jonas> this new one only allows exactly one leaf on each list
10:31:07 <b_jonas> so that's definitely no good
10:31:07 <albdogo> no mor than one leaf in a list
10:31:11 <b_jonas> this one has the error I mentioned
10:31:27 <albdogo> ok
10:31:27 <b_jonas> let's just stick to the first repr I think
10:31:33 <albdogo> ok
10:32:05 <b_jonas> so it's insertTrie [] (s : f) = [Branch s (insertTrie [] f)]; I guess
10:32:10 <albdogo> we have insertTrie t [] = Leaf:t
10:33:43 <albdogo> could it be monadic?
10:33:50 <albdogo> maybe is simpler
10:33:52 <vixey> albdogo: What's a monad for?
10:34:01 <albdogo> a monad?
10:34:04 <albdogo> for computing
10:34:16 <b_jonas> no
10:34:23 <vixey> interesting answer
10:34:45 <vixey> hello shoenfinkel
10:35:26 <albdogo> bjonas, i think it would be easier if we put a dummy root
10:35:28 <b_jonas> I guess it shall be five cases or so
10:35:43 <albdogo> with the ^ caracteer
10:35:50 <albdogo> or some other one
10:36:20 <albdogo> the lists is better if they are ordered
10:36:23 <b_jonas> ok, wait a minute
10:36:27 <albdogo> ok
10:36:30 <albdogo> :D
10:36:32 <b_jonas> I'll try to write it and see what it becomes
10:36:38 <b_jonas> you can try to write your version meanwhile
10:36:46 <albdogo> ok
10:38:08 <vixey> velco, why not ask ?
10:40:40 <velco> vixey: sorry, ask what ?
10:41:32 <vixey> velco, your question again
10:42:04 <velco> oh, I found their paper:
10:42:07 <velco> http://www.bitc-lang.org/docs/papers/mutinfer2006.html
10:42:18 <lambdabot> Title: Design of Type and Mutability Inference in BitC
10:42:31 <velco> and it answers my question
10:42:45 <velco> (not that I'm convinced, but I got what they mean)
10:45:20 <dejones> Anyone know if something similar to the formal verification support in BitC is available in Haskell?
10:45:21 <dejones> http://www.bitc-lang.org/docs/bitc/spec.html#17
10:45:22 <lambdabot> Title: BitC Language Specification
10:46:23 * vixey (has to look away incase someone says quickcheck)
10:47:32 <omy> is there a way to simplify this even further?  e^(x-y) >= (x^x)/(y^x)
10:49:50 <dejones> vixey: lol.
10:50:41 <vininim> > e
10:50:43 <lambdabot>   e
10:50:44 <albdogo> there are two types os leaves b_jonas
10:50:49 <albdogo> of+
10:50:52 <vininim> > exp 1
10:50:54 <lambdabot>   2.718281828459045
10:51:13 <vininim> > exp (10-4) >= (10^10)/(4^10)
10:51:14 <lambdabot>   False
10:52:17 <b_jonas> albdogo: here's what I got: http://erxz.com/pb/13320
10:52:19 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
10:52:28 <b_jonas> could some haskeller read it and recommend how it could be made better?
10:53:31 <vixey> b_jonas, are you writing albdogos homework? :p
10:53:48 <albdogo> does that work?
10:55:25 <albdogo> it is not homework
10:55:26 <pozic> Since when is that a trie?
10:55:45 <b_jonas> pozic: I think it is
10:55:49 <b_jonas> vixey: yes
10:55:57 <pozic> Or: what is according to you the defining property of a trie?
10:56:25 <b_jonas> pozic: look up in Knuth vol III
10:56:33 <pozic> b_jonas: did you?
10:57:25 <b_jonas> I've read it recently because I was so lucky that I could buy a Knuth vol III which is normally really hard to get here
10:57:41 <b_jonas> so hard that I don't have a vol I and vol II even though I'm willing to pay for those too
10:57:50 <b_jonas> ok, anyway, as for the useful part
10:58:08 <b_jonas> the property of a trie is that in each node it branches according to teh first letter of the words it stores
10:58:21 <pozic> b_jonas: sure, and that's not what you do.
10:58:30 <b_jonas> so you look up the first letter in the first level of the three, then the second letter in the second level
10:58:33 <b_jonas> etc
10:58:34 <Deewiant> looks awfully complicated compared to http://hpaste.org/11825 but that's just me :-)
10:58:35 <b_jonas> is it not? I think I do that
10:58:37 <albdogo> i think jonas implementation is good
10:59:17 <pozic> Oh, missed the []. Still it will be slow, if you alphabet has non-constant size.
10:59:30 <pozic> Or |alphabet| slower than optimal.
10:59:36 <b_jonas> pozic: well, yeah
10:59:43 <b_jonas> it's not a bitwise version
10:59:56 <albdogo> alphabet is always bounded above
11:00:16 <albdogo> and it is 26 letters for english
11:00:20 <albdogo> only
11:00:38 <stevan> hi, i'm trying to install ghc 6.10 with editline support on an old system which i dont have root access on. after some struggle, with compiler flags, include and library paths, i managed to configure and build it, but when doing make install i get the following error: "installPackage: Error: Could not find module: System.Console.Editline with any suffix: ["hi"] make[1]: *** [install.library.editline] Error 1". what does that mean? ...
11:00:42 <b_jonas> the output shows it branches according to the first character
11:00:44 <stevan> ... configure said that it found editline! thanks.
11:01:01 <pozic> albdogo: where is the problem description?
11:01:13 <albdogo> the problem description?
11:01:20 <Baughn> stevan: Ah, why aren't you using the binary package?
11:01:30 <bos> @seen dcoutts
11:01:30 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 37m 54s ago.
11:02:27 <stevan> Baughn: no, source. the systems libc is too old for binary, i think (atleast it was in 6.8.3, so i figured it would be now too).
11:04:23 <Baughn> stevan: How are you telling configure where editline is?
11:05:10 <albdogo> jonas: u dont check if Leaf is already in the list
11:05:11 <stevan> Baughn: ./configure LDFLAGS="-L/scratch/ghc6.10/editline/lib/" CPPFLAGS="-I/scratch/ghc6.10/editline/include/ -I/scratch/ghc6.10/editline/include/editline/" LIBS="-ledit -lcurses" --prefix=/scratch/ghc6.10/ghc-with-editline/
11:05:14 <albdogo> insertTrie [] t = (Leaf : t);
11:05:57 <b_jonas> this might be better to write with some list function like split
11:06:01 <b_jonas> @type split
11:06:02 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
11:06:10 <b_jonas> no, not that then
11:06:13 <b_jonas> @type break
11:06:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:06:30 <albdogo> why not an ordered insertion?
11:06:44 <albdogo> having into account that Leaf is the least member
11:06:53 <Baughn> stevan: Hm, are you sure you want a runtime dependency on /scratch?
11:06:54 <b_jonas> albdogo: didn't you say you wanted to add another leaf if you add a word again?
11:07:10 <albdogo> it has to be the same word
11:07:15 <b_jonas> albdogo: if you don't want, change it so it checks for the leaf
11:07:17 <albdogo> i dont want duplicate
11:07:23 <b_jonas> well, change it so then
11:07:29 <stevan> Baughn: but, this seems to be a cabal problem, no? btw ghc-pkg list lists editline.
11:07:32 <b_jonas> the same way as in the branch case
11:07:38 <Baughn> stevan: But more to the point, in 6.8 at least, passing any environment variables to configure in this way does not propagate to sub-packages, such as the haskell editline package..
11:07:42 <albdogo> ok
11:07:46 <Baughn> ..er, guess that's fixed then
11:07:58 <b_jonas> I don't think ordering would help much, but you could try it
11:09:13 <Baughn> stevan: One option that worked for me in the past was to install ghc without readline support, then install readline and the package, then reinstall ghc - it'd use the already-installed package while compiling, which seems to be fine
11:11:26 <stevan> Baughn: i could try that, thanks. btw, i noticed thing didn't propagate to sub-packages using the env vars; is there a better way to do it?
11:12:09 <Baughn> stevan: Ah.. no. Not to my knowledge.
11:12:09 <Baughn> It's a bit of a problem.
11:12:22 <Baughn> Basicaly, if your prerequisites aren't all in /usr or /usr/loca, you're SOL
11:13:21 <adityam> @pl f x y = abs x <= y
11:13:22 <lambdabot> f = (<=) . abs
11:14:16 <gwern> @seen dcoutts_
11:14:16 <lambdabot> dcoutts_ is in #haskell, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts_ last spoke.
11:14:37 <gwern> @seen dcoutts
11:14:37 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 51m 1s ago.
11:15:47 <gwern> @ask dcoutts so I've been wondering. what exactly is the 'mozembed' stuff in gtk2hs good for? (Icant compile gtk2hs to actually try) I want a WSYIWG HTML editor, ideally, but AFAIC mozembed is just about calling firefox to display a HTML doc as part of the gui
11:15:48 <lambdabot> Consider it noted.
11:16:13 <adityam> @pl f x y = vectorMax (abs x) <= y
11:16:14 <lambdabot> f = (<=) . vectorMax . abs
11:18:31 <dcoutts> gwern: you're right, that's all it is
11:18:59 <gwern> aw. :(
11:19:25 <bos> dcoutts: is gtk2hs 0.9.13 expected to compile with ghc 6.10.1?
11:19:27 <gwern> that could actually be useful, but not really for my desires. no way to close the edit -> display -> edit loop
11:19:40 <dcoutts> bos: I don't think so
11:19:45 <gwern> guess I'll stick with the customize-yi approach
11:19:54 <dcoutts> bos: try the darcs version
11:19:56 <bos> dcoutts: ok, that's what i was observing, just wondered if it was me
11:20:05 <bos> dcoutts: will do
11:20:20 <dcoutts> bos: it was released before ghc-6.10 and has it's own build system so was highly likely to break
11:20:28 <gwern> I've never been able to compile darcs gtk2hs. v. frustrating
11:20:41 <dcoutts> all the cabal packages only work because cabal itself was updated for ghc-6.10
11:20:50 <dcoutts> gwern: any idea why?
11:21:13 <gwern> dcoutts: it's a strange can't find *.*.Glib.String message
11:21:29 <dcoutts> it'll be an earlier error
11:21:39 <gwern> I've been running into it for what is probably literally years now, on various linux systems
11:22:06 <dcoutts> gwern: but the tarballs work ok?
11:22:19 <dcoutts> gwern: perhaps you've got a weird version of autoconf
11:22:25 <gwern> dunno, never tried the tarballs
11:22:42 <gwern> my personal theory is that it has something to do with the many instances of stuff like 'svgcairo/Graphics/Rendering/Cairo/SVG.chs.pp:207: error: missing expression between '(' and ')''
11:23:27 <dons> yay, darcs roadmap, http://lists.osuosl.org/pipermail/darcs-users/2008-November/015545.html
11:23:29 <lambdabot> Title: [darcs-users] darcs roadmap proposal, http://tinyurl.com/6lx8p7
11:23:32 <dcoutts> gwern: that's a broken version testing macro
11:24:09 <gwern> dcoutts: is that bad?
11:24:21 <Wechner> hello, i have one quick question: is it possible to add prerequisites to data types with type arguments? e. g. data Tree a = ... is it possible to limit it to Eq types, etc.?
11:24:29 <stevan> Baughn: hmm, ghc-6.10-pkg lists editline, but configure fails to find editline. removing 6.10 from the path and trying again with 6.8.1 (which also has the editline cabal package installed) works tho. any idea why?
11:24:31 <dcoutts> gwern: check gtk2hs-config.h what does the #define _GTK_MAJOR_VERSION look like?
11:25:00 <rwbarton> Wechner: possible, but generally not useful
11:25:05 <dcoutts> stevan: --user vs --global confusion?
11:25:13 <gwern> #define _GTK_MAJOR_VERSION ()
11:25:14 <Baughn> stevan: None.
11:25:31 <dcoutts> gwern: right, so that's the source, the question is why that's not generated properly
11:25:55 <Wechner> rwbarton: I want to give it a try here just to test, how does the syntax look like?
11:26:18 <gwern> dcoutts: well, configure seems happy. it checks for gtk, finds it, etc.
11:26:50 <rwbarton> Wechner: data Eq a => Tree a = ...   I think
11:26:58 <gwern> dcoutts: http://hpaste.org/11832
11:27:38 <dcoutts> gwern: try hacking configure.ac to add some debug output around the line that defines GTK_MAJOR_VERSION
11:27:58 <dcoutts> gwern: and what version of autoconf are you running?
11:28:27 <dcoutts> gwern: does autoreconf give any warnings?
11:28:47 <gwern> autoconf 2.61
11:29:05 <gwern> autorecon is silent
11:29:05 <ushdf> checking whether build environment is sane... yes
11:29:45 <adityam> @pl f (x,z) y = vectorMax (abs x) <= y
11:29:45 <lambdabot> f = (<=) . vectorMax . abs . fst
11:29:53 <gwern> hm. there is no line in configure.ac pertaining to GTK_MAJOR_VERSION
11:29:58 <gwern> maybe my repo is bad
11:30:14 <gwern> but no, that can't be it - the tarball is broken as well
11:30:28 <dcoutts> gwern: ah, it's changed slightly in the latest darcs version
11:34:34 <adityam> @pl f (x,y) (a, b) = abs (x-a)
11:34:35 <lambdabot> f = (`ap` snd) . (. fst) . ((const . abs) .) . (-) . fst
11:35:35 <dcoutts> gwern: the current darcs version uses GTKHS_PACKAGE_ADD_CHECK_VERSION(gtk+-2.0, GTK, Gtk+)
11:35:54 <dcoutts> gwern: which should define GTK_MAJOR_VERSION
11:36:47 <dcoutts> gwern: in the generated configure add debug code to the bit where it defines GTK_MAJOR_VERSION and extends the confdefs.h
11:37:26 * lispy waves at the people of Haskell
11:37:47 <Apocalisp> _o/
11:38:01 <dcoutts> hia lispy
11:38:47 * lispy sees mention of someone using Coq in #darcs-theory to double check Camp
11:38:52 <lispy> cool!
11:40:34 <adityam> @pl f x y z = fst ( g x y z)
11:40:35 <lambdabot> f = ((fst .) .) . g
11:41:30 <Badger> heh
11:41:33 <Badger> list got fixed.
11:41:42 <lispy> Why would someone prefer epigram over agda over coq over cayenne, etc.  What are the relative strengths of them?
11:45:32 <Saul__> lispy: coq is much more focused on proofs, agda is a lot like haskell, epigram has this weird derivation-tree syntax and cayenne I don't know (but isn't developed anymore iirc)
11:46:21 <lispy> Saul__: thanks.  That helps a lot.  BTW, someone here has been using cayenne a lot lately so it may be under development again.
11:47:10 <adityam> I was reading dons blog regarding mean of a list. Why isn't mean defined as follows
11:47:10 <adityam> let mean xs = last $ zipWith (/) (scanl1 (+) xs) [1::Double .. ]
11:47:10 <adityam> > let mean xs = last $ zipWith (/) (scanl1 (+) xs) [1::Double .. ] in mean [1..100]
11:47:10 <lambdabot>   50.5
11:47:11 <Saul__> agda and epigram are actually pretty similar, although epigram is more explicit in how you do things (so you have to say what type of recursion you use), while in agda it just checks if what you did is okay
11:47:55 <Saul__> lispy: And coq works more as a proof assistent, where you use various tactics to derive something
11:48:38 <lispy> Saul__: oh, but I thought epigram's selling point was that you can say where you're unsure and have it help you fill in the blanks
11:49:18 <Saul__> Yeah you create functions in a very interactive way
11:49:21 <Saul__> step by step
11:49:33 <Saul__> and the system helps you by providing feedback
11:49:38 <ystael> You can do this in Coq too, using the 'refine' tactic or the Program construct.  You _can_ program in Coq without using the proof automation and tactic features at all; they just help when you want to reason about your program later.
11:49:45 <Saul__> agda has something similar, but less structured
11:51:21 <Saul__> I must say that I have very limited experience with epigram and coq though, so I can't say exactly how it works there
11:56:03 <albdogo> how can one make a tree a monad?
11:56:44 * Badger chuckles at BONUS 
11:57:04 <Badger> "Repeating yourself (three times) while programming is about as desirable as getting kicked inna head. "
11:57:20 <Badger> :)
11:57:29 <Saul__> albdogo: What kind of tree?
11:57:38 <albdogo> a binary one
11:57:59 <lament> albdogo: you need to make up semantics
11:58:04 <Saul__> albdogo: So with values on leafs only?
11:58:20 <lament> in particular, you need to make up semantics for join
11:58:34 <lament> given a binary tree of binary trees, how do you turn it into a binary tree?
11:58:57 <albdogo> thats the problem
11:58:59 <lament> (if values are only on the leafs, it's trivial)
12:01:22 <albdogo> how is that trivial
12:01:38 <Saul__> lament: I never really though about this before, but it really is trivial
12:01:39 <lament> albdogo: just imagine it
12:01:45 <lament> how does such a tree look like?
12:02:00 <Saul__> albdogo: A tree of trees is a tree, so you're done
12:02:07 <pozic> dcoutts: with gnomevfs installed, ./configure --enable-profiling && make fails for latests released gtk2hs.
12:02:37 <lament> Saul__: yeah, it sounds like typical monad material :)
12:02:48 <albdogo> but when trees
12:02:54 <albdogo> are in inner nodes
12:03:04 <dcoutts> pozic: report it to pgavin or the users mailing list
12:03:04 <albdogo> how can u get a new tree
12:03:11 <Saizan> data Tree a = Leaf a | Branch (Tree a) (Tree a)
12:03:14 <albdogo> bc in lists it is easy
12:03:32 <Saul__> You replace each leaf by a new tree
12:04:02 <albdogo> and if u got  | Branch a (Tree a) (Tree a)
12:04:02 <Saul__> because you apply the new function to each of the leafs
12:04:09 <Saizan> so e.g. Branch (Leaf (Leaf 1)) (Leaf (Branch (Leaf 2) (Leaf 3)) :: Tree (Tree Int)
12:04:15 <pozic> dcoutts: you are not the maintainer anymore?
12:04:25 <Saul__> and the result is a new tree with those leafs replaced by new trees
12:04:40 <Saul__> But that in itself is a valid tree, so you're done
12:04:55 <albdogo> yes , but with trees on the leaves only
12:05:12 <Saizan> and it's easy to transform that to  Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3)) :: Tree Int
12:05:17 <albdogo> what would the do semantics be for those trees u say
12:05:45 <albdogo> what im trying to comprehend is monads
12:06:11 <Saul__> albdogo: I don't see a clear one for those kinds of trees
12:06:28 <rwbarton> albdogo: It's basically nondeterminism, like []
12:06:29 <Saul__> albdogo: You might make one, but there isn't an obvious one in that case
12:06:43 <lament> albdogo: not everything can or should be made into a monad
12:06:47 <Saizan> in a tree monad (m >>= f) substitutes the Leaf nodes with the trees resulting from "f" applied to the elements in those Leafs
12:06:55 <rwbarton> albdogo: except `mplus` isn't associative
12:07:08 <albdogo> but if in lists is easy matter, in trees might be also
12:07:10 <Saul__> lament: I was literally typing in the same thing (that not everything is a monad)
12:07:14 <vixey> hello
12:07:14 <shapr> roconnor: Yes! That's it!
12:07:35 <shapr> roconnor: Had you already read that?
12:07:37 <shapr> hi vixey!
12:07:49 <vixey> :)
12:07:51 <rwbarton> albdogo: Imagine Node a as return a, Branch l r as l `mplus` r
12:07:52 <dcoutts> pozic: I've not really been active in gtk2hs development, Alex has always been maintainer and pgavin is the release manager
12:08:06 <albdogo> i dont remember the mplus monad
12:08:06 <dcoutts> pozic: erm Alex/Axel
12:08:14 <pozic> dcoutts: Then this is old too: http://www.haskell.org/gtk2hs/development/#authors_and_acknowledgements
12:08:17 <lambdabot> Title: Gtk2Hs » Development, http://tinyurl.com/5aw4np
12:08:22 <pozic> dcoutts: that says you are.
12:08:29 <Saul__> albdogo: Well for the trees with only values in the leaves it is pretty easy, just like for lists and Maybe
12:08:36 <dcoutts> pozic: mm, true
12:09:49 <Saul__> albdogo: But you say you're trying to understand monads, so do you think you understand the Maybe and List monad?
12:10:15 * shapr hugs vixey
12:10:17 <Saul__> albdogo: Because if you don't, it might not be useful to think about tree monads already
12:10:18 <roconnor> shapr: nope, it was new to me.
12:10:26 <shapr> roconnor: Cool! I found something nifty!
12:10:28 <albdogo> i understand list monad
12:10:43 <rwbarton> albdogo: I could have said "imagine Node a as a computation which returns a, imagine Branch l r as a computation which makes a choice then does the computation l or r"
12:10:50 <albdogo> its just that ive not seen a tree monad yet
12:11:00 <stevan> ghc-pkg lists editline but when trying to configure 6.10 it fails to detect it: http://pastebin.com/d549c66b7 any suggestions? thanks.
12:11:06 <rwbarton> albdogo: at the end you have a tree of all possible sequences of choices the computation might have made, and the results of those computations
12:11:15 <Saul__> albdogo: Well that is because hardly anyone uses them
12:11:22 <Philonous> @src mplus
12:11:22 <lambdabot> Source not found. Are you on drugs?
12:11:38 <albdogo> @src Mplus
12:11:39 <lambdabot> Source not found. Take a stress pill and think things over.
12:11:50 <rwbarton> @src MonadPlus
12:11:50 <lambdabot> Source not found. You speak an infinite deal of nothing
12:12:10 <Philonous> How do I search for the defintion of mplus in a specific MonadPlus?
12:12:18 <Philonous> Say, Maybe?
12:12:25 <Deewiant> ?src Maybe mplus
12:12:26 <lambdabot> Nothing `mplus` ys = ys
12:12:26 <lambdabot> xs      `mplus` ys = xs
12:12:26 <Jedai> @src Maybe mplus
12:12:26 <lambdabot> Nothing `mplus` ys = ys
12:12:26 <lambdabot> xs      `mplus` ys = xs
12:12:40 <Philonous> Thanks
12:13:54 <Saul__> albdogo: I think you should focus on the state monad next, then you'll have a good working knowledge of what monads can do
12:14:24 <BONUS_> ugh
12:14:29 <Saul__> albdogo: and then use monads for a while before trying to define your own
12:14:32 <BONUS_> i keep getting disconnected from freenode i dont know wtf
12:15:16 <Saul__> albdogo: That's what I did anyway
12:15:28 <BONUS> Badger: you called? :)
12:16:13 <albdogo> its was just to know what a monad for trees can do
12:16:26 <Japsu> a monad to save the trees
12:17:27 <Philonous> I'm wondering how join works on trees
12:17:47 <vixey> @src join
12:17:47 <lambdabot> join x =  x >>= id
12:18:06 <vixey> so have you get >>= on trees?
12:18:11 <mornfall> Wow. How is it possible that map /= (M.fromList $ M.toList map)?
12:18:19 <vixey> because you can just unfold some things to get the join definition
12:18:22 <Philonous> No, But I understand >>= in terms of join
12:18:25 <vininim> mmmm... what was the alternative to list concat that is more efficient?
12:18:35 <cow_2001> newbie question: in HUGS and YAHT, how do i run: map Char.isLower "abcd"
12:18:39 <vixey> How do you write >>= in terms of join?
12:18:40 <vixey> :t join
12:18:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:18:43 <vixey> :t join . f
12:18:44 <lambdabot> forall (m :: * -> *) a a1. (SimpleReflect.FromExpr (m (m a)), Show a1, Monad m) => a1 -> m a
12:18:46 <vixey> :t join . ?f
12:18:47 <lambdabot> forall (m :: * -> *) a a1. (?f::a1 -> m (m a), Monad m) => a1 -> m a
12:18:58 <Saul__> albdogo: Well I hope you do now
12:19:00 <vixey> is it even possible
12:19:02 <vixey> :t fmap join
12:19:03 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad m) => f (m (m a)) -> f (m a)
12:19:07 <vixey> :t fmap join return
12:19:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
12:19:11 <Philonous> join.map
12:19:13 <Philonous> I think
12:19:18 <vixey> :t join . fmap
12:19:20 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
12:19:20 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
12:19:20 <lambdabot>     In the second argument of `(.)', namely `fmap'
12:19:29 <vixey> > (fmap join return) "foo"
12:19:30 <cow_2001> lambdabot: isLower
12:19:30 <lambdabot>   "foo"
12:19:34 <vixey> > (fmap join return) "/lol"
12:19:36 <lambdabot>   "/lol"
12:19:36 <albdogo> yes, more or less
12:20:05 <dobblego> @type \f x -> join (fmap f x)
12:20:06 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a -> m a1) -> m a -> m a1
12:20:09 <mornfall> Ahw.
12:20:19 <Saizan> ?type (join .) . fmap
12:20:20 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
12:20:22 <FunctorSalad> when spawning a subprocess, how can I write something to the sub's stdin, then connect the parent's stdin to the sub's?
12:20:39 <albdogo> what would do this
12:20:53 <Philonous> m >>= f ≡ join ((map f) m)
12:20:54 <albdogo> do x<-t1; y <-t2; return (x,y)
12:21:04 <albdogo> in lists is the cartesian product
12:22:35 <Philonous> @pl \m f -> join (map f m)
12:22:35 <lambdabot> (join .) . flip map
12:23:03 <Deewiant> flip concatMap
12:23:03 <b_jonas> sequence?
12:23:31 <dobblego> @pl \m f -> join (fmap f m)
12:23:32 <lambdabot> (join .) . flip fmap
12:23:43 <dobblego> @pl \f m -> join (fmap f n)
12:23:43 <lambdabot> const . join . flip fmap n
12:23:56 <dobblego> @pl \f m -> join (fmap f m)
12:23:56 <lambdabot> (=<<)
12:24:01 <b_jonas> > sequence ["abc", "123"] -- that's cartesian product
12:24:03 <lambdabot>   ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
12:24:19 <vixey> , [$i| (,) "foo" "bar" |]
12:24:24 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
12:24:55 <b_jonas> except maybe it would be better to give a version that gives a list of all combinations even if some of the lists are infinite
12:24:56 <vixey> , [$i| ("foo","bar") |]
12:25:00 <lunabot>  luna: applicateQ fails.
12:25:04 <vixey> lol
12:25:37 <Badger> BONUS: just enjoying your intriguingly illustrated tutorial. :P
12:26:35 <BONUS> oh haha. awesome
12:29:12 <Saul__> albdogo: I've defined the tree monad at http://hpaste.org/11835
12:29:29 <vixey> @go free monad
12:29:31 <lambdabot> No Result Found.
12:30:23 <albdogo> thank you very much Saul :)
12:30:29 <Philonous> Ok, for trees which have values only in the leafes it comes quite natural.
12:30:57 <vixey> hi byorgey
12:31:07 <byorgey> hi vixey!
12:31:34 <byorgey> how
12:31:41 <byorgey> *how's it going?
12:31:49 <byorgey> darn ' is right next to the Enter key
12:32:48 <gwern> this community.haskell.org stuff is underrated - I didn't realize one could put up as many darcs repo as one liked
12:32:48 <Saul__> albdogo: No problem, you actually got me interested
12:32:56 <gwern> eg. my home dir: http://community.haskell.org/~gwern/
12:32:57 <lambdabot> Title: Index of /~gwern
12:33:59 <byorgey> yup =)
12:34:41 <vixey> I couldn't get a community account
12:34:52 <bode> hey
12:34:56 <vixey> hi
12:35:13 <vininim_> wait, it seems (++) is lazy friendly.
12:36:47 <sbahra> vixey, why not?
12:37:21 <sbahra> http://community.haskell.org/~gwern/bin/bin/darcs-smtp
12:37:22 <sbahra> Damn!
12:40:56 <vixey> > 99999999999999999999999999999999999999999999+1
12:40:57 <lambdabot>   100000000000000000000000000000000000000000000
12:41:10 <vixey> > 1111111111111111111111111111111111111111111^2
12:41:11 <lambdabot>   123456790123456790123456790123456790123456765432098765432098765432098765432...
12:41:40 <vixey> > iterate (9*) 1
12:41:42 <lambdabot>   [1,9,81,729,6561,59049,531441,4782969,43046721,387420489,3486784401,3138105...
12:41:59 <sbahra> vixey, why couldn't you get a community account?
12:43:13 <sbahra> Must be the obesity.
12:43:41 <gwern> sbahra: yes, it's an ugly script I know
12:43:43 <dons> vixey: i'm sure you can get an account..
12:43:46 <gwern> sbahra: but it works for my purposes
12:46:41 <b_jonas> eek
12:46:56 <b_jonas> I installed ghc-6.10.1 and the editline in it COMPLETELY doesn't work
12:47:26 <b_jonas> insomuch that you can't even backspace in it, neither with ^H nor with ^8
12:47:37 <bode> bad
12:48:19 <b_jonas> ^U doesn't work either
12:48:30 <Saizan> standard question: do you have libedit installed? with the header files if you've built ghc from sources?
12:49:06 <b_jonas> but runghc can indeed read from the standard output now if called with no parameters
12:49:27 <b_jonas> runghc <<<'main = putStrLn "foo"' # works, though it takes lots of time
12:49:58 <b_jonas> I still have ghci-6.8.3 installed so I can use that, but still, this is bad
12:53:03 <b_jonas> so what do I do now?
12:53:35 <bode> I would build from source
12:54:03 <b_jonas> I built it from source
12:54:37 <albdogo> well, i g2g
12:54:39 <b_jonas> that's likely how it went so wrong
12:54:48 <albdogo> bye all
12:54:59 <vixey> > 2 ^ (fix succ)
12:55:04 <Saizan> b_jonas: did you have the header files for libedit installed?
12:55:15 <lambdabot>   thread killed
12:55:28 <b_jonas> libedit... let me look
12:55:52 <b_jonas> configure:2853: checking whether ghc has editline package
12:55:53 <b_jonas> configure:2864: result: no
12:55:58 <b_jonas> that's what config.log says
12:56:00 <b_jonas> so no
12:56:19 <b_jonas> I'll install them
12:56:42 <vixey> I had this great idea yesterday
12:56:45 <b_jonas> still even without them it should read from the stdin in canonical mode not mess up the terminal completely so I can't backspace
12:56:50 <b_jonas> thanks for the help
12:56:52 <vixey> today I realized it's rubbish :/
12:56:59 <b_jonas> any other library I should install as well?
12:57:05 <b_jonas> I'll install libedit-dev from package?
12:57:18 <Saizan> b_jonas: you may have to install the editline package on the host ghc, also
12:57:23 <b_jonas> is it libedit-dev or libeditline-dev?
12:57:48 <b_jonas> Saizan: why would I need that? it builds in two stages
12:58:26 <Saizan> b_jonas: i'm probably wrong, yeah :)
12:58:44 <Saizan> it doesn't hurt, i guess
12:58:54 <bode> have lambdabot a own channel with no chatters?
12:58:59 <b_jonas> well, I'll try that if this doesn't work here
12:59:03 <b_jonas> bode: private message it
12:59:20 <b_jonas> Saizan: so which of the two debs do I need: libedit-dev or libeditline-dev?
12:59:30 <b_jonas> fuck the developers who choose such generic names
12:59:31 <bode> b_jonas: yeah but a channel would nice
12:59:50 <b_jonas> bode: for my bot I have created one
12:59:57 <b_jonas> it's not so useful though
12:59:59 <Saizan> b_jonas: i don't use debian anymore, so i don't know
12:59:59 <bode> 'cause my irc client can't create a private dialog on start automatically
13:00:13 <b_jonas> ok, I'll just look at the configure output if it finds it
13:00:18 <b_jonas> I installed libedit-dev
13:00:30 <bode> b_jonas: show me
13:00:40 <b_jonas> shouldn't README mention this dependency?
13:00:46 <b_jonas> bode: it's not a haskell bot
13:00:50 <b_jonas> but the channel is #jeval
13:01:03 <b_jonas> I used it to test the bot
13:01:05 <b_jonas> and it still joins it
13:01:06 <bode> :|
13:02:08 <sbahra> heh
13:02:11 <b_jonas> basically private message is usually just as good as a channel
13:02:47 <bode> matter of taste
13:04:16 <vixey> bode, #haskell.ru
13:04:32 <bode> lol that's an idea
13:05:02 <dons> ?users
13:05:02 <lambdabot> Maximum users seen in #haskell: 552, currently: 533 (96.6%), active: 12 (2.3%)
13:05:22 <dons> new hs.
13:05:32 <bode> Maximum users seen in #haskell.ru: 3, currently: 3 (100.0%), active: 2 (66.7%)
13:05:36 <ushdf> wait dons are you DBS?
13:05:49 <b_jonas> it can't find editline
13:05:54 <dons> i'm one of the DBS, yes.
13:05:57 <b_jonas> I guess it probably needs the haskell editline package
13:06:03 <ushdf> that's funny, i know someone with your name
13:06:03 <b_jonas> let me try that
13:06:09 <b_jonas> hmm, wait
13:06:13 <dons> ushdf: its moderately common (a very traditional name)
13:06:15 <ushdf> at least with the b. in the initial
13:06:23 <b_jonas> if it needs the haskell editline package, wouldn't it have it now that I have ghc-5.10.1 installed?
13:06:32 <b_jonas> like whoever told on this channel
13:06:36 <askentasken> anyone here good with Coq?
13:06:37 <ushdf> anyway, is there a dock in xmonad yet
13:06:47 <ushdf> or do i have to write one
13:06:51 <vixey> askentashken; lol
13:06:51 <dons> ushdf:  a dock? it supports gnome docks.
13:06:53 <mofmog> how do i get infinite (or as infinite as you can get) in haskell?
13:06:54 <b_jonas> as it say "checking whether _ghc_ has the editline package".
13:07:02 <ushdf> hmph
13:07:04 <vixey> mofmog, fix succ
13:07:05 <bode> I read a documentation about haskell from 1996... it is too deprecated?
13:07:08 <dons> mofmog: "get infinite" ?
13:07:10 <vixey> > 1 < infinity
13:07:11 <lambdabot>   True
13:07:17 <dons> bode: not for basics.
13:07:24 <dons> but for libraries, yes. for the compiler, yes.
13:07:25 <mofmog> i mean, infinite precision
13:07:35 <bode> hokay. because it is in my native language
13:07:37 <mofmog> i need to do 8*(1-(1/2)**52)
13:07:42 <vixey> mofmog: CReal
13:07:43 <vixey> > pi :: CReal
13:07:44 <lambdabot>   3.1415926535897932384626433832795028841972
13:07:52 <mofmog> ahh ok
13:07:52 <vixey> > 8*(1-(1/2)**52 :: CReal
13:07:53 <lambdabot>   <no location info>: parse error on input `;'
13:07:54 <dons> mofmog: oh, CReal.
13:07:57 <dons> or Ratio or ..
13:08:00 <vixey> > 8*(1-(1/2)**52) :: CReal
13:08:01 <lambdabot>   7.9999999999999982236431605997495353221893
13:08:07 <mofmog> which library is it in?
13:08:15 <vixey> CReal library
13:08:19 <rwbarton> > (1+1/1000)^1000 :: CReal
13:08:21 <lambdabot>   2.7169239322358924573830881219475771889643
13:08:31 <vixey> lim n -> infinity
13:08:33 <askentasken> vixey: do you like Coq? Dons said you helped him with getting Coq to work. He said you knew the ins and outs of Coq. He said you usually play with Coq every friday night.
13:08:55 <vixey> > (1+1/infinity)^infinity :: CReal
13:08:56 <lambdabot>   Couldn't match expected type `CReal'
13:09:01 <vixey> askentashken; ok
13:09:07 <askentasken> just kiddin
13:09:17 <Taejo> dons: sorry for dissing your code in my blog
13:09:29 <askentasken> but anyone here that knows how to make a simple proof with C-o-q
13:09:31 <askentasken> ?
13:09:33 <dons> Taejo: oh?
13:09:37 <dons> Taejo: which blog? :)
13:09:43 <Taejo> beautiful folding
13:09:44 <b_jonas> why can't it just read from stdin
13:09:45 <mauke> what does C-o-q do in emacs?
13:09:48 <vixey> askentashken; You have read the user manual?
13:09:53 <dons> Taejo: oh. hehe. i didn't notice a diss.
13:09:57 <jdrake> Can anyone recommend a good tutorial for the parsec in ghc (6.8)? The chapter in the hutton book is not useful to me as it does not deal directly with Parsec or what I am doing.
13:10:01 <askentasken> like mathematicinas seem to be good at understanding things from just an explanation but i need examples
13:10:05 <Taejo> "Don's solution is even uglier (sorry, Don)"
13:10:05 * dons rereads
13:10:09 <vixey> jdrake: the parsec docementation
13:10:09 <dons> dude!
13:10:10 <dons> fusion
13:10:14 <Vulpyne> Creates a blank line and enters a 'q'. :)
13:10:29 <vixey> askentashken; have you read the user manual?
13:10:31 <dons> oh, you didn't link to my 'high level' solution
13:10:42 <dons> which was the following article (the one about solving it with fusion, while getting the same speed)
13:10:42 <Taejo> dons: no, I didn't know there was one
13:11:06 <dons> Taejo: the followup, http://cgi.cse.unsw.edu.au/~dons/blog/2008/06/04#fast-fusion
13:11:08 <lambdabot> Title: Haskell hacking
13:11:26 <dons> was working out how to the manual recursion perf. while still using combinators.
13:11:42 <dons> might still be too ugly. its a left fold.
13:11:42 <Taejo> dons: literature-search-fail
13:11:54 <dons>     mean n m = s / fromIntegral l
13:11:54 <dons>       where
13:11:54 <dons>         P s l = foldlU k (P 0 0) (enumFromToFracU n m)
13:11:57 <jdrake> vixey: I am having some issues understanding it when it gets into lexing, specifically the code doesn't even compile. I saw a reference to a new of parsec being released this year while the parsec docs (parsec.pdf) seems to be old.
13:11:58 <dons>         k (P s l) a = P (s+a) (l+1)
13:12:10 <dons> not sure if that counts as ugly though. but its damn fast.
13:12:11 <vixey> jdrake: ah this is GHC fault I think
13:12:31 <vixey> jdrake, they did this cool thing where they  break lots of old code by 'improving' the libraries
13:12:52 <bode> link http://tunes.org/~coreyr/ and http://meme.b9.com is broken/moved on http://tunes.org/~nef/logs/haskell/
13:12:55 <Taejo> dons: heh, well I think mine is prettier. You still own me speedwise
13:12:57 <vixey> jdrake, did you get some error about no monad instance for foo?
13:13:05 <vixey> Taejo, where is yours?
13:13:12 <jdrake> vixey: Let me try to compile it now
13:13:18 <dons> Taejo: yeah, we still want to write:  sum xs / length xs
13:13:23 <Taejo> vixey: http://squing.blogspot.com/2008/11/beautiful-folding.html
13:13:24 <lambdabot> Title: The Most Fuun You Can Have: Beautiful folding
13:13:26 <dons> so anything that gets us closer is interesting
13:13:43 <Taejo> dons: yeah, hence the wishful-thinking rewrite rules at the end of my post
13:13:59 <vixey> Taejo, oh yeah, found it a bit weird.. dunno why you use all this strictness and introduce a type for Fold
13:14:06 <vixey> Taejo, did you read:
13:14:14 <vixey> ?go why attribute grammars matter
13:14:15 <vixey> ?
13:14:16 <lambdabot> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
13:14:16 <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki
13:14:25 <dons> there was a comment on reddit on my original article that walked through the rewrite rules required. neelk's comment.
13:14:30 <vixey> I think this is the best way
13:16:01 <Taejo> vixey: yeah, I read that. Preprocessors bug me, though, and I wanted to see what I could do
13:16:42 <vixey> You can do this without a preprocessor, kind of like parsec vs yacc
13:16:53 <Taejo> vixey: ok, I didn't see that
13:17:30 <jdrake> vixey: Page 13 in parsec.pdf has the lexer using something called haskellDef with makeTokenParser
13:17:39 <jdrake> I don't know what this is or where to get it
13:17:55 <Taejo> vixey: I need the strict pair for the fold to be strict not just in the pair, but also the elements of the pair
13:17:59 <vixey> @hoogle makeTokenParser
13:18:00 <lambdabot> Text.Parsec.Token makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m
13:18:00 <lambdabot> Text.ParserCombinators.Parsec.Token makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m
13:18:27 <jdrake> To be honest, I would like a simple thing that doesn't try to do mathematical expressions.
13:18:32 <jdrake> @hoogle haskellDef
13:18:33 <lambdabot> Text.Parsec.Language haskellDef :: LanguageDef st
13:18:33 <lambdabot> Text.ParserCombinators.Parsec.Language haskellDef :: LanguageDef st
13:19:30 <jdrake> @hoogle reservedOpNames
13:19:31 <lambdabot> Text.Parsec.Token reservedOpNames :: GenLanguageDef s u m -> [String]
13:19:31 <lambdabot> Text.ParserCombinators.Parsec.Language reservedOpNames :: GenLanguageDef s u m -> [String]
13:19:31 <lambdabot> Text.ParserCombinators.Parsec.Token reservedOpNames :: GenLanguageDef s u m -> [String]
13:19:51 <rwbarton> > reservedOpNames haskellDef
13:19:52 <lambdabot>   Not in scope: `reservedOpNames'Not in scope: `haskellDef'
13:19:56 <jdrake> Well it compiles now
13:20:29 <Taejo> dons: to do stream fusion, do I just import Data.List.Stream?
13:24:22 <vixey> why do people write open source software .. but not release the source code?
13:25:14 <sbahra> ...?
13:25:22 <rwbarton> they don't, obviously
13:25:39 <sbahra> Open-source software doesn't mean freely distributed though.
13:25:48 <dons> Taejo: i'd use the uvector package. but you can also use the stream-fusion package for lists
13:25:52 <sbahra> s/ed/ed software/
13:25:56 <dons> the lists one is less tested performance-wise.
13:26:08 <dons> Taejo: but yes, import Data.List.Stream, and hide functions from Data.List (and Prelude)
13:26:13 <frosty00014> You guys know if there's a snowball (assembly) channel?
13:26:41 <dons> probably not.
13:31:54 <frosty00014> Anyone with experience?
13:32:14 <Taejo> dons: really, the idea was to try and get something as nicely composable as plain-ol' sum and length... speed issues still need examination
13:32:39 <dons> Taejo: sure
13:36:16 * Taejo gets owned by type-defaulting *again*
13:36:57 * vixey is handing out free -XNoMonomorphismRestriction :)
13:36:59 <Taejo> twanvl: thanks for the Applicative instance
13:41:30 <ushdf> i have the coolest email now
13:43:51 * ushdf yawns
13:44:30 <jsn> ushdf: oh?
13:45:38 <ushdf> oh
13:51:02 <Taejo> is there a tool to compare to ELF executable for equality modulo stuff like creation date?
13:56:13 <vixey> > 999999999999999999999999999999999999999999999^2
13:56:15 <lambdabot>   999999999999999999999999999999999999999999998000000000000000000000000000000...
13:56:34 <cow_2001> any good editor for haskell which does indentation and syntax colouring and is not vim or emacs?
13:56:45 <aeolist> it's bigger than what YOU can handle
13:56:49 <BMeph> vixey: Is there a point to all the long-digit spam? :)
13:56:54 <aeolist> cow_2001: gvim!
13:57:02 <lament> cow_2001: possibly eclipse with some plugin
13:57:12 <aeolist> BMeph: they want to haxxor lambdabot but it knows better
13:57:12 <vixey> .. I like it :(
13:57:16 <roconnor> > 2^999999999999999999999999999999999999999999999
13:57:18 <cow_2001> aeolist: /me weeps
13:57:32 <lambdabot>   thread killed
13:57:51 <aeolist> scribes?
13:57:59 <roconnor> some days I wish I had a langauge where everything was polynomial bound.
13:58:03 <BMeph> vixey: ...okay, so if you like it, why the frowny-face? ;)
13:58:36 <vixey> roconnor: simply typed lambda calculus !!!!?
13:59:01 <cow_2001> i'll be trying scribes
13:59:08 <roconnor> vixey: that doesn't sound polynomial bound
13:59:14 <vixey> I thought it was
13:59:29 <roconnor> vixey: even primitive recursion isn't polynomial bound
13:59:39 <roconnor> and primitive recursion sucks
13:59:55 <cow_2001> i'm a primitive regression
14:00:21 * Taejo is even more primitive than primitive recursion: he's a primitive GOTO
14:00:30 <vixey> it says: Schwichtenberg showed in 1976 that in \lambda^\to exactly the extended polynomials are representable as functions over Church numerals
14:00:45 <vixey> but that's not the result I meant
14:01:35 <prof_nimnul> cow_2001: I use Eclipse with that plugin - and it's very poor.
14:02:20 <roconnor> hmm
14:02:20 <prof_nimnul> cow_2001: The best I could find is Visual Haskell - but you need Visual Studio 2003 or 2005, and it only works with GHC 6.6
14:02:33 <roconnor> can the simply typed lambda calculus represent primitive recursion?
14:02:41 <roconnor> maybe I'm worng
14:02:43 <roconnor> rong
14:02:44 <roconnor> wrong
14:02:46 <roconnor> see
14:03:58 <cow_2001> kate used to have a commandline
14:04:04 <cow_2001> but it doesn't have indentation
14:04:05 <prof_nimnul> cow_2001: There is also Scintilla
14:04:11 <prof_nimnul> it?
14:04:12 <Taejo> cow_2001: they took the commandline out?
14:04:21 <cow_2001> Taejo: i think so
14:04:54 <Taejo> probably I good thing, actually... I used to do everything in there and suddenly think "why am I doing this?"
14:04:55 <cow_2001> qscintilla?
14:05:29 <prof_nimnul> http://www.scintilla.org/
14:05:30 <lambdabot> Title: Scintilla and SciTE
14:05:35 <Taejo> I only use Kate in programming competitions, because I'm a Vim guy, my one team-mate is an emacs guy, and the other doesn't know either
14:05:49 <jsn> cow_2001: i have some helpful vim macros
14:08:21 <cow_2001> so it's eclipse, qscintella, scribbles, vim+macros, and...
14:08:52 <roconnor> I use kate
14:08:57 <roconnor> but it isn't an IDE
14:09:08 <roconnor> or at least I don't use it as one
14:09:32 <cow_2001> roconnor: do you still have the commandline?
14:09:39 <jsn> my development environment is actually screen with vim and GHCi
14:09:55 <roconnor> I use a terminal window myself
14:09:58 <jsn> i honestly haven't used even integrated error highlighting for a long time
14:10:02 <cow_2001> do you really devel stuff with haskell...?
14:10:09 <jsn> cow_2001: yes
14:10:26 <cow_2001> i know mldonkey is written with  haskell
14:10:34 <jsn> cow_2001: that's the way i do all my other development (sh, python, sed) in that environment
14:10:38 <vixey> cow_2001, lol
14:10:44 <vixey> cow_2001, no it's not
14:10:45 <jsn> s/in that environment//
14:10:47 <aeolist> that would be ocaml
14:10:51 <mwotton> there's an interesting tension between language-based programmers and environment-based programmers
14:10:53 <cow_2001> vixey: O_o
14:11:01 <mwotton> to a certain extent, you have to choose
14:11:05 <dons> cow_2001: conjure, the bit torrent client, is written in haskell. mldonkey is written in .. ml
14:11:13 <aeolist> ocaml
14:11:19 <roconnor> cow_2001: well depends on what you mean by really
14:11:22 <dons> ocaml has left the land of ml now?
14:11:26 <roconnor> I have a hackage package
14:11:31 <roconnor> that probably counts for something
14:11:32 <dons> go roconnor !
14:11:37 <jsn> mwotton: i think "environment based" programmers are by far the most conservative
14:11:47 <mwotton> btw, g'day dons, been a while :)
14:11:51 <jsn> mwotton: they are tied in place by their tools
14:12:00 <roconnor> But I mostly write little programs to solve little problems.
14:12:01 <mwotton> jsn: maybe. i'm not making value judgments here.
14:12:03 <roconnor> for myself
14:12:06 <dobblego> what is an "environment based" programmer?
14:12:17 <prof_nimnul> IDE-based I think
14:12:20 <prof_nimnul> Like me
14:12:33 <lament> dobblego: someone who's not a nut that thinks that the programming language is the only important tool in the dev toolchain
14:12:38 <cow_2001> i'm a language based
14:12:39 <jsn> i assume it means, you are not willing to move to a new language till the IDE is really good
14:12:47 <aeolist> i didnt say that to argue, but ml usually refers to either standard ml or ml family, not caml or ocaml or lazy ml or whatever
14:12:55 <jsn> lament: i don't think that's a fair assesment
14:12:58 <velco> one that uses one devel environment to program in many languages, as one who programs in one language using whatever dev environment is around ? :P
14:13:04 <jsn> lament: what you are describing is a wise programmer
14:13:06 <rodprice> I'm new to irc; forgive me if I screw up:  does yi compile with GHC 6.10.1?
14:13:08 <velco> +as opposed to*
14:13:15 <jsn> lament: not an environment based programmer
14:13:16 <lament> jsn: i'm fine with that, too :)
14:13:34 <cow_2001> i'm installing qscintella
14:13:35 <rwbarton> jsn: I think that parsed as "someone who's not ( a nut that thinks that the programming language is the only important tool in the dev toolchain )"
14:13:53 <prof_nimnul> q? I really meant SciTE
14:14:04 <jsn> lament: an environment based programmer is someone who doesn't use linux for C++, for example
14:14:25 <Philonous> I wonder how F# fits into the ml family. It is basically ocaml + .NET bindings, isn't it?
14:14:25 <jsn> who finds that highlighting of errors, &c. is helpful to their productivity
14:14:27 <cow_2001> prof_nimnul: oh alright
14:14:37 <jsn> Philonous: it is certainly an ML
14:14:44 <mwotton> rodprice: one would assume so - what sort of errors are you getting?
14:14:50 <vixey> jsn, is haskell an ML?
14:14:56 <lament> jsn: who would think that highlighting errors is not important to their productivity? A nut.
14:14:57 <prof_nimnul> ah I ic... qscintilla is scintilla using Qt
14:15:09 <mwotton> lament: it's a trade-off, though
14:15:19 <jsn> lament: no, that's not a nut
14:15:23 <jsn> lament: i'm not a nut
14:15:27 <lament> a nut of the worst kind, like RMS
14:15:30 <prof_nimnul> There's also Komodo Edit - it's based on Scintilla too
14:15:36 <jsn> lament: no, he uses emacs
14:15:39 <lament> exactly
14:15:43 <mwotton> i went to some reasonable effort to get flymake and haskell set up in emacs because i do like that feedback about compilation etc
14:15:46 <jsn> they have everything in emacs
14:15:47 <lament> RMS didn't even open an IDE until last year
14:15:54 <jsn> emacs is an IDE
14:15:58 <lament> no, it's not
14:15:59 <mwotton> but it's not enough to push me in the direction of using a less capable language
14:16:05 <mwotton> i don't think it is.
14:16:05 <lament> have you never seen the RMS post about Eclipse?
14:16:12 <rodprice> lots of dependencies on array-0.1.0.0, which fails to compile with a duplicate instance error in Data.Array.IO.Internals
14:16:16 <badsheepy> arent all turing complete languages equally capable :)
14:16:19 <rwbarton> in any case, emacs has C-c ` for jumping to errors
14:16:25 <mwotton> badsheepy: go sit in the corner :)
14:16:31 <prof_nimnul> emacs is so feature-rich that you can call it an OS
14:16:34 <jsn> lament: i think it's a nut who sticks with java for RAD, for example, because moving to ruby would deprive them of their error highlighting
14:16:39 <vixey> badsheepy, no ..
14:16:55 <prof_nimnul> but unfortunately it isn't a gui os
14:17:10 <vixey> badsheepy, 'turing complete' is pretty much completely irrelevant to how useful a tool is in practice
14:17:15 <jsn> lament: would you consider someone who uses sh without error highlighting a nut?
14:17:24 <erikc> i cant think of the last time 'error highlighting' has helped me
14:17:25 <badsheepy> i wasnt arguing they were equally efficient :p
14:17:30 <lament> sh does error highlighting?
14:17:35 <prof_nimnul> jsn: nobody writes 100 KLOC in sh
14:17:36 <mwotton> vixey: i think badsheepy was taking the piss :)
14:17:40 <jsn> lament: no, that's my point
14:17:53 <jsn> lament: however, it is certainly the right tool for the job in many cases
14:18:06 <jsn> prof_nimnul: no, but how many of your projects are that big?
14:18:21 <lament> jsn: oh. certainly.
14:18:28 <ddarius> vixey: Haskell is not an ML.
14:18:34 <jsn> lament: an "environment based" programmer is one, i think, who is unwilling to see that trade off
14:18:39 <vixey> ddarius, why not ?
14:18:49 <mwotton> erikc: i find it really helpful with typeful programming languages. all it's doing is shortening the loop between checking if something compiles and fixing the bugs, and if you're using the type system to enforce correctness, that's pretty valuable.
14:18:56 <vixey> ddarius, is it because of there being no module system/functors?
14:18:59 <lament> jsn: so both environment- and language- based programmers are different kind of nuts with ridiculous tunnel vision
14:19:00 <ddarius> Because it's a rather different language
14:19:17 <lament> jsn: it's good that we're above that!
14:19:18 <jsn> prof_nimnul: it is also hard to make a far comparison based on LOC
14:19:27 <jsn> lament: i am not, though
14:19:29 <prof_nimnul> jsn: my main project is 15 KLOC, but I do it ALONE. A team project of 100KLOC is not always considered even a medium sized project
14:19:35 <rwbarton> Is there a word for "a language like those in the ML and Haskell families"?
14:19:41 <ddarius> vixey: There isn't an objective determination of this, but Haskell is usually considered the representative for it's own family of languages.
14:20:01 <Philonous> rwbarton: functional languages?
14:20:05 <jsn> rwbarton: statically typed, typed inferring, strongly typed?
14:20:17 <lament> rwbarton: functional languages with HM-based type systems
14:20:18 <jsn> Philonous: unfortunately, scheme is also in that family
14:20:22 <rwbarton> Philonous: I want to exclude Lisp/Scheme/etc.
14:20:41 <ddarius> rwbarton: Usually statically typed functional languages is a fine enough categorization.
14:21:03 <jsn> prof_nimnul: i think part of the trade off is that, with sh, you can write a lot less code than you would with java for a certain domain
14:21:22 <jsn> prof_nimnul: if you actually have 100kLOC to write for that domain, maybe sh is the right choice
14:21:42 <jsn> prof_nimnul: i mean, how big is portage?
14:23:00 <prof_nimnul> jsn: I'm not talking that SH is not a right tool. I'm talking that usual scenarios of sh don't assume 100KLOC, so nobody uses an IDE for sh
14:23:12 <jsn> ah, i see
14:24:13 <jsn> i wonder how we would find out if any really large projects are done by people using only vim or a relatively limited emacs?
14:24:29 <erikc> jsn: ibm db2 is done in vim
14:24:37 <erikc> and C
14:24:37 <jsn> erikc: really?
14:24:40 <lament> vim is done in emacs
14:24:44 <lament> i mean vim
14:24:49 <jsn> erikc: how do you know?
14:24:52 <erikc> i worked on it
14:24:56 <dobblego> ibm db2 is a brand, not software
14:24:59 <jsn> erikc: oh, cool
14:25:02 <erikc> ok, the database engine
14:25:06 <erikc> which is huge
14:25:13 <jsn> erikc: did you work on any of the clustering stuff?
14:25:15 <dobblego> and a steaming pile of poop :)
14:25:28 <erikc> dobblego: maybe so :)
14:25:32 <jsn> dobblego: relative to... ?
14:25:33 <erikc> nah, i did backup/restore/logfile stuff
14:25:38 <jsn> ah
14:25:42 <dobblego> jsn, software written by first year university students
14:25:45 <ddarius> dobblego: Most software is a steaming pile of poop.
14:25:48 <velco> heh
14:25:52 <dobblego> ddarius, I use the term relatively
14:26:00 <erikc> and i did it as an internship ship, so dobblego's statement is true :)
14:26:08 <jsn> heh
14:26:09 <dobblego> I worked on ibm db2 udb :)
14:26:11 <erikc> haha
14:26:15 <erikc> in toronto?
14:26:16 <jsn> udb = ?
14:26:22 <dobblego> no, Gold Coast Australia
14:26:25 <erikc> ah
14:26:46 <erikc> ibm's xl compilers are all vim/emacs and c++, ibm's jit is developed in vim
14:27:00 <prof_nimnul> jsn: DB2 Universal Database I think
14:27:07 <dobblego> I was lecturing at the time, failing one or two students thinking "you know, these student's work is far better than that which I deal with every day at IBM"
14:28:34 <jsn> lament: my personal bias is that things get better, so i want to be able to trade-up quickly
14:28:53 <jsn> lament: i pay a price for that, for sure
14:28:57 <mwotton> dobblego: yeah, corporate software dev is pretty weird
14:29:24 <prof_nimnul> dobblego: It's much harder to write good software 40 hrs a week and keeping schedule than to write a hello world for university
14:29:24 <mwotton> i've started recruiting my mates from uni instead - it's the only way we seem to be able to get smart people
14:29:27 <dobblego> mwotton, I find it difficult to even call it software development, while retaining meaning in the notion
14:29:28 <ddarius> The world is held together by bubble gum and shoe laces.
14:29:37 <prof_nimnul> dobblego: Even different skill sets are involved
14:29:45 <dobblego> prof_nimnul, I've heard all the irrational justifications in the world
14:30:32 <lament> software development is a much broader field than programming proper
14:30:41 <prof_nimnul> dobblego: The market is irrational
14:30:43 <erikc> one thing i dont like about IDEs is it lets ppl make really complicated bs cause the IDE helps them deal with the complexity, so it seems 'acceptable'
14:30:44 <lament> the goals are different
14:30:55 <dobblego> prof_nimnul, no, it is perfectly rational; it just looks irrational if it is misunderstood
14:31:17 <jsn> the market may take a while to converge, though
14:31:27 <roconnor> I'd be happy if I had an editor that told me the types of stuff.
14:31:31 <lament> erikc: yes. Complex stuff is bad. Take GHC for example. Wouldn't it be better to just write in assembly? Then you can't write very complex stuff easily.
14:31:38 <jsn> hehe
14:31:39 <vixey> I thought emacs did that
14:31:45 <roconnor> although that seems like a hard problem
14:31:47 <dobblego> roconnor, eclipse does that for Scala
14:31:51 <akorn> from a philosophical point of view, isn't it strange that "state" seems to be the source of all evil in data processing ?
14:31:55 <vixey> lament: GHC is bloody complex for no good reason
14:31:56 <mwotton> vixey: think it does for library functions
14:32:01 <jsn> akorn: haha
14:32:02 <akorn> or is it the concept of assigment ?
14:32:04 <ddarius> roconnor: Program in Perl, then you won't have to worry about that problem.
14:32:06 <lament> vixey: they must have written it in an IDE!
14:32:14 <lament> s/Perl/Tcl
14:32:22 <ddarius> s/Tcl/Forth
14:32:22 <lament> then the editor can tell you type of everything
14:32:24 <prof_nimnul> dobblego: I agree. I just means that scientists, engineers and businessmen each think that the other two are irrational. So the corporate dev seems irrational because it's driven by marketing
14:32:34 <lament> it's String!
14:32:44 <dobblego> prof_nimnul, I agree, but I also believe that they are all wrong
14:32:56 <prof_nimnul> dobblego: Of course they are wrong
14:33:17 <lament> they're not wrong, they have tunnel vision
14:33:27 <prof_nimnul> isn't it the same?
14:33:34 <ddarius> lament: Having tunnel vision doesn't make you right.
14:33:35 <dobblego> corporate development is not driven by marketing; it survives by marketing and manipulating consumers by deception
14:33:59 <erikc> lament: i'd rather deal with complex haskell code without an ide than stateful object insanity c++ with an ide
14:33:59 <dobblego> it is driven by the greed of economical elitists
14:34:06 <erikc> any day of the week
14:34:12 <ddarius> Moral of the story, consumers are stupid.
14:34:14 <vixey> I'd rather deal with simple code
14:34:18 <vixey> :/
14:34:19 <mwotton> dobblego: i don't think you need to bring morality into it
14:34:23 <vixey> who wouldn't ?
14:34:26 <dobblego> mwhitney, morality?
14:34:26 <jsn> haskell is prettier than most other languages
14:34:28 <erikc> indeed
14:34:29 <lament> erikc: That just tells us about your skills and preferences.
14:34:39 <mwotton> if you were an intelligent greedy elitist, you'd still want good code
14:34:39 <jsn> when there are problems, they are least really interesting
14:34:41 <lament> erikc: namely, that you're better at haskell than at C++
14:34:45 <erikc> hah
14:34:48 <erikc> no, im better at c++
14:34:57 <prof_nimnul> jsn: Not when you do very abstract stuff
14:35:08 <lament> erikc: ok, that you prefer haskell to C++, then. I'm not surprised. :)
14:35:09 <jsn> prof_nimnul: yeah, that stuff is really interesting, actually
14:35:10 <ddarius> State quite definitely adds a very significant level of complexity.
14:35:17 <lament> erikc: but it's not an argument against IDEs.
14:35:23 <akorn> can haskell be considered as a "formal system" as in Godel's Theorem?
14:35:28 <erikc> its not, thats true
14:35:29 <lament> A nice IDE for haskell would certainly be great!
14:35:37 <lament> akorn: yes.
14:35:49 <mwotton> lament: the tricky bit is keeping up with the research, i think
14:35:59 <akorn> lament: interesting.
14:36:05 <mwotton> look at all the cool new stuff with indexed type families we just got with 6.10
14:36:09 <vixey> just team up with Peaker and the others that want to write this stuff
14:36:17 <mwotton> you'd have to update all the tools to cope with it too...
14:36:21 <badsheepy> i dont think haskell is prettier when it comes to io etc, but thats cause i have no idea what im doing...
14:36:24 <vixey> If you actually do it, you will have the best tool in existence very quickly
14:36:28 <prof_nimnul> jsn: That stuff looks no more maintainable than all that template metaprogramming in C++ (boost, loki etc)
14:36:37 <jsn> badsheepy: i think it is pretty with pointers, even
14:36:53 <prof_nimnul> jsn: Most people need a simple instrument with reasonable level of abstraction
14:36:58 <akorn> lament: but conventional programming languages with side effects are not formal systems in that sense?
14:37:33 <akorn> or more accurately, programs written with conventional programming languages
14:37:39 <lament> akorn: they are
14:37:39 <jsn> prof_nimnul: the intersection between template metaprogramming and haskell's abstraction facilities is pretty broad
14:37:46 <prof_nimnul> jsn: A lot of abstraction makes industrial development harder - because while it saves LOC, it requires more skilled team
14:37:51 <jsn> prof_nimnul: when you say that stuff, you mean, type classes?
14:38:27 <prof_nimnul> jsn: Type classes are very simple stuff. I mean not basic type classes, but say SYB kind of stuff.
14:38:34 <jsn> prof_nimnul: actually, one thing i really appreciate about haskell's type classes is the way it facilitates perl-like "contexts" for things
14:38:39 <jsn> like regular expressions
14:38:52 <prof_nimnul> jsn: Functional dependencies etc
14:39:19 <mathijs> Hi all, I just coded up my first haskell program, which is basically just some data transformation. I would like to use this routine from a ruby program, currently it reads a string from stdin which is parsed as an array of floats, some calculations are performed, and an array is written back to stdout. my ruby program starts the application on startup and whenever it needs to calculate, communicated through stdout/stdin.
14:39:27 <jsn> prof_nimnul: i find that very helpful when i want to put a bunch of types under a uniform interface
14:39:43 <jsn> prof_nimnul: can c++ templates even do functional depencencies?
14:40:08 <akorn> lament: stemming from the fact that in the end they are turned into simple cpu instructions ?
14:40:12 <jsn> well, you can stuff a type variable into the namespace of a class somehow, i think
14:40:35 <jsn> mathijs: and the problem is ... ?
14:40:37 <mathijs> my ruby program starts the application on startup and whenever it needs to calculate, communicated through stdout/stdin. Now, I'm wondering if I can gain some performance by making ruby and the haskell program communicate through a socket instead of stdin/stdout. Will a socket be faster?
14:40:50 <jsn> no
14:40:54 <erikc> jsn: yes, using partial instantiation
14:41:23 <jsn> erikc: how do you do fundeps with partial instantiiation?
14:41:25 <mwotton> mathijs: seems unlikely
14:41:29 <roconnor> is MonadRandom in hackage?
14:41:40 <mwotton> but should be pretty easy to run some little benchmarks
14:41:41 <prof_nimnul> jsn: Most people don't need that - only senior devs are supposed to be able to do template metaprogramming, so it isn't used widely
14:42:00 <jsn> well, that's loony
14:42:28 <jsn> the people who provide the regex library, though, are senior devs
14:42:36 <jsn> so you can think of it that way, if you want
14:42:37 <prof_nimnul> jsn: but it's why Java is so successful - even junior dev can understand any code
14:42:41 <lament> akorn: no, i'm pretty sure that staying in the language is fine
14:42:54 <mathijs> I don't have any performance problems at the moment, but since I'm learning haskell I'm first just doing small parts of existing programs in haskell and need some way to get data back and forth. I know about FFI, but that's a bit too advanced for me atm, especially since I'm not interfacing with c.
14:43:03 <sjanssen> mathijs: local sockets and pipes are essentially the same thing
14:43:05 <prof_nimnul> jsn: There's always should be a balance - like abstraction vs learning curve
14:43:17 <jsn> prof_nimnul: C and C++ are also successful
14:43:31 <akorn> lament: yeah i ment that is everything that is run on a conventional cpu a "formal system" ?
14:43:59 <rwbarton> mathijs: You might get better performance from doing your communication in a binary format, rather than a text representation
14:44:06 <jsn> prof_nimnul: we are speaking in generalities, i fear
14:44:06 <akorn> no matter how complex layer of os, frameworks, libraries and applications are built on it
14:44:09 <lament> akorn: Yes. IO and randomness are not allowed; everything else is simple logic
14:44:09 <mathijs> sjanssen: so without starting to use FFI, the way I do it right now is performance-wise the best I can get?
14:44:22 <mathijs> rwbarton: ok
14:44:32 <prof_nimnul> jsn: But C++ is successful not because it's metaprogramming - most C++ software looks very similar to java, nobody uses complex features such as partial specialization every day
14:44:53 <vixey> :o
14:44:59 <lament> C++ is successful because it's successful. Success breeds success.
14:45:00 <vixey> I never ever heard of partial specialization before
14:45:07 <mathijs> rwbarton: but then I need to write a parser for that, now I can just use Read's abilities.
14:45:09 <prof_nimnul> lament: yep
14:45:13 <jsn> prof_nimnul: i think what you're missing is that a lot of very basic abstractions are implemented with typeclasses, and that they are simple to understand
14:45:38 <sjanssen> mathijs: if you're having performance problems, Read is probably the reason
14:45:39 <rwbarton> mathijs: Yes
14:45:41 <prof_nimnul> jsn: Typeclasses are very basic stuff, I agree
14:45:47 <rwbarton> mathijs: On the Haskell side, you can try Data.Binary
14:45:56 <jsn> prof_nimnul: so where is this steep curve you are talking about?
14:46:31 <prof_nimnul> jsn: but SYB-style stuff is not just plain simple typeclasses like Eq/Show
14:46:34 <mathijs> well, like I said, I don't have any performance problems right now, but I'dd like to do everything I can before moving to FFI, so a binary format might be worth a try
14:46:53 <jsn> prof_nimnul: so, how is the C++ solution to that problem area simpler?
14:47:07 <akorn> imo C++ managed to provide some nice OO functionality at the same time being low-level enough that time when efficiency still did matter.
14:47:17 <jsn> prof_nimnul: it's not good enough to tell me, "the haskell research is complex!"
14:47:38 <akorn> soon after, java and other managed OO languages took over.
14:47:41 <jsn> prof_nimnul: that's like me pointing to alexandrescu's book as an example of baseline C++
14:48:23 <jsn> if you can talk about a specific problem, that would help me to see what you mean
14:48:43 <prof_nimnul> jsn: No no. I only trying to prove my sentence that Haskell is beautiful only if you do basic stuff
14:49:06 <jsn> it is beautiful even in the complex stuff, though -- certainly compared to C++
14:49:25 <jsn> prof_nimnul: do you think templates are more beautiful?
14:50:44 <akorn> jsn: what about GUI programming in Haskell ?
14:50:55 <jsn> akorn: o_O
14:50:59 <jsn> haven't done it
14:51:16 <roconnor> heh heh.  Matthias has calculated that to expand the definition of the number "1" fully in terms of Bourbaki primitives requiresover 4 trillion symbols.
14:51:50 <ystael> I thought Bourbaki used the von Neumann construction of the ordinals?  That makes it just {{}}
14:51:56 <rwbarton> Which number 1?  (The real number? complex number? rational number? etc.)
14:52:29 <mwotton> that depends on what the meaning of 'is' is.
14:52:30 <roconnor> yeah, I was wondering that
14:53:10 <prof_nimnul> jsn: They are about the same. Of course List a declaration is a beautiful thing, but SYB tricks are not more beautiful than partial specialization and cast overloading tricks
14:53:13 <akorn> few days ago i tried to ask what Haskell is _really_ suitable for
14:53:18 <quicksilver> ystael: 4 trillion? 4? these concepts are very similar to pure mathematicians.
14:53:32 <akorn> people said that basically everything.
14:53:32 <vixey> akorn: factorial and fibonacci calculation
14:53:37 <jsn> akorn: i don't think that question is well motivated
14:53:49 <prof_nimnul> akorn: I think it's really suitable for graph rewriting applications, such as compilers
14:53:51 <jsn> akorn: what would be a good answer?
14:54:03 <mauke> jsn: writing programs!
14:54:18 <jsn> mauke: that was the answer that displeased akorn before
14:54:24 <akorn> jsn: don't understand me wrong. I'm interested in the language and don't have any prejudice against it as such
14:55:32 <prof_nimnul> mauke: Haskell is not that good when you deal with a lot of state and effects
14:55:34 <Badger> @faq Can Haskell do things that even Haskell can't do?
14:55:35 <lambdabot> The answer is: Yes! Haskell can do that.
14:55:35 <akorn> Well.. for example.. a good answer would be: "it's good for data transformations" like XSLT is for XML based data. But it is not that well suited for example fully-fledged GUI applications
14:55:46 <mauke> prof_nimnul: yes, it is
14:55:48 <jsn> prof_nimnul: i would say you are in error
14:55:49 <akorn> maybe I was looking for something in that direction...
14:55:50 <sleven> is it hard to make guis in haskell? im doing imageprocessing now and im working with python(as a frontend, fortran,c ,c++ etc as backend)
14:56:16 <sleven> i see how a reactive functional gui could work
14:56:33 <vixey> It's easy to write a trivial gui program in haskell
14:56:41 <vixey> I don't know what it's like doing anything more
14:56:43 <rwbarton> Haskell is not that good for programming in an object-oriented mindset (whatever that means)
14:56:50 <jsn> rwbarton: right
14:57:10 <dolio> At worst, I imagine it's not any worse than any other language, if you just go with straight gtkhs.
14:57:16 <prof_nimnul> akorn: It is good for data transformation. It's not very good for GUI, but it's still good if GUI is only a small part of app
14:57:17 <sleven> ok
14:57:20 <akorn> I'm not here to argue that Haskell is a bad language, but just interested that can you _really_ do some stuff without unreasonable complexity
14:57:22 <dons> sleven: pretty much identical to say, python, for e.g. gtk guis
14:57:25 <jsn> prof_nimnul: why do you say that?
14:57:26 <Lemmih> An object-oriented mindset is not that good for programming.
14:57:33 <vixey> oh!
14:57:34 <dons> Lemmih++
14:57:45 <vixey>  haskell is rubbish for parsing logs if you're a newbie :p
14:57:47 <dons> heh
14:57:54 <jsn> akorn: it isn't the complexity that gets you
14:57:55 <dons> get you some bytestrings
14:58:00 <jsn> akorn: it's habits
14:58:37 <quicksilver> prof_nimnul: I think GUIs are pretty awkward and I don't think haskell makes them any worse than any other language.
14:58:45 <mwotton> dons: that's your answer to everything
14:58:48 <quicksilver> prof_nimnul: tool support is what makes GUIs bearable, not language features.
14:59:04 <quicksilver> (and you can use glade with gtk2hs as far as I know, for what it's worth)
14:59:37 <rwbarton> Haskell is also not that good for writing programs when you don't know what you want your program to do. :)
14:59:49 <erikc> haha
15:00:19 <Badger> weird
15:00:20 <prof_nimnul> prof_nimnul: Tools is only a workaround for poor languages
15:00:26 <prof_nimnul> prof_nimnul: Tools are only a workaround for poor languages )
15:00:28 <rwbarton> Lemmih: that is my viewpoint as well, but I figure maybe it's just because of the domains I tend to program in.
15:00:39 <Badger> why does "str":"ing" think that "ing" is Char and "str" is [Char]?
15:00:52 <mauke> Badger: no
15:00:54 <akorn> rwbarton: I can understand that's a valuable wisdom :)
15:00:56 <dobblego> > "str" ++ "ing"
15:00:57 <lambdabot>   "string"
15:00:59 <vixey> or poor minds, like ones that can't remember how to spell necessarily ..
15:00:59 <lament> :t (:)
15:01:00 <lambdabot> forall a. a -> [a] -> [a]
15:01:00 <mauke> Badger: look at the type of (:)
15:01:01 <dobblego> :type (:)
15:01:02 <Badger> oh, silly
15:01:06 <dobblego> ?type (:)
15:01:07 <lambdabot> forall a. a -> [a] -> [a]
15:01:18 <dobblego> > "str" : ["ing"]
15:01:20 <lambdabot>   ["str","ing"]
15:01:23 * Badger slaps Badger 
15:01:32 <Badger> thankyou.
15:01:44 <mauke> > "str":"ing"  :[]
15:01:45 <lambdabot>   ["str","ing"]
15:02:31 <quicksilver> prof_nimnul: that's a defensible point of view, but my point there is no other language which makes GUIs so easy that the tools are not needed.
15:02:35 <prof_nimnul> ("str", "ing")
15:02:51 <prof_nimnul> > ("str", "ing")
15:02:52 <lambdabot>   ("str","ing")
15:02:59 <quicksilver> prof_nimnul: a sizeable proportion of todays GUIs are in Java and C# and they are no magic bullets.
15:03:09 <vixey> the best way to make a GUI is using a GUI of course
15:03:15 <prof_nimnul> quicksilver: There is XUL-style languages
15:03:20 <prof_nimnul> quicksilver: There are XUL-style languages
15:03:24 <vixey> not typing out a grid bag layout
15:03:35 <akorn> quicksilver: so GUIs are no problem for haskell ?
15:03:48 <quicksilver> akorn: I don't find they're a *particular* problem.
15:03:59 <quicksilver> programming complex GUIs is hard in any language.
15:04:08 <quicksilver> I don't find haskell has properties which makes this harder than, say, Java.
15:04:14 <ddarius> Doing something hard is hard.
15:04:15 <dobblego> @google totally gridbag
15:04:19 <quicksilver> right.
15:04:22 <lambdabot> http://madbean.com/anim/totallygridbag
15:04:22 <lambdabot> Title: madbean » Totally Gridbag
15:04:34 <quicksilver> on the contrary, I find Haskell has abstractions which make it slightly easier.
15:04:48 <quicksilver> at least haskell is better than removing the boilerplate of repetive work.
15:04:48 <prof_nimnul> quicksilver: But gui state manipulation looks better in imperative languages.
15:04:53 <akorn> ok.. im just trying to get some honest answers.. usually when questioned like this, people never say what are the real practical problems of the language
15:04:57 <dobblego> I think quicksilver has nailed it
15:05:09 <vixey> akorn: the numbers in haskell are completely awful
15:05:18 <quicksilver> prof_nimnul: the world has only two really good imperative languages
15:05:21 <quicksilver> prof_nimnul: haskell and ML
15:05:23 <ddarius> vixey: They are still comparable or better than most.
15:05:30 <geezusfreeek> prof_nimnul: haskell is as imperative as it needs to be (however, much research is being done on declaratively programming GUIs as well)
15:05:31 <vixey> akorn: they use - as a prefix operator which ruins the syntax and there is no subtyping between different kinds of number
15:05:51 <erikc> i think the web demonstrated that for relatively simple guis, logic programming is king :) (relational dbs + view requests + update requests)
15:05:51 <ddarius> vixey: There is almost no subtyping in actuality anyway.
15:06:09 * araujo still considered GUI programming is the finest out there
15:06:17 <araujo> on Haskell, that is it
15:06:18 <araujo> :-)
15:06:32 <quicksilver> prof_nimnul: I wrote a combined Java/ML project
15:06:34 <vixey> ddarius: I don't understand why everyone doesn't agree that algol style numeric types are the one and only good way to implement numbers
15:06:34 <prof_nimnul> akorn: The real problem with Haskell is learning to use laziness properly
15:06:45 <quicksilver> prof_nimnul: I expected (this was years ago) that Java would be more suited to the GUI parts
15:06:53 <quicksilver> I ended up moving everything into the ML part of the app
15:07:09 <quicksilver> prof_nimnul: now you've hit the nail on the head.
15:07:23 <quicksilver> haskell's key disadvantage is learning to cope correctly with laziness and space leaks.
15:07:27 <prof_nimnul> akorn: Big programs seem to impossible to write without using profiling to detect "leaks" due to excessive thunks/graph nodes buildup
15:07:39 <geezusfreeek> yeah. laziness is awesome, but a clear stumbling block and perhaps should not be the default
15:07:41 <ddarius> Nah, the hard part (for some) seems to be realizing that Haskell -is- a lazy language.
15:07:43 <vixey> the solution is to not write big programs
15:07:43 <mauke> prof_nimnul: that's not a problem if you write C in Haskell
15:07:50 <quicksilver> lack of real-time scheduling is a problem in some domains.
15:08:01 <quicksilver> (to be fair that's not rally a language fault, it's an implementation fault)
15:08:04 <akorn> prof_nimnul: ok.. i can understand the problem
15:08:08 <prof_nimnul> quicksilver: Jave libraries introduced layouts, which helped a lot. But XUL went further
15:08:13 <geezusfreeek> i am always back and forth on whether lazy-by-default is so great
15:08:27 <quicksilver> but the fact remains we don't have an implementation with any timeliness guarantee,.
15:08:39 <akorn> my first haskell program was a fibonacci sequence implemented ... no sorry _defined_ ... incorrectly ;)
15:08:41 <ddarius> geezusfreeek: It doesn't really matter.  The issues are mixing laziness and eagerness.
15:09:01 <quicksilver> prof_nimnul: I've never worked with XUL. THe people I know who have tend to look green and run off to be ill. But maybe that's maligning it ;)
15:09:13 <prof_nimnul> mauke: write Haskell and pretend I'm writing C?
15:09:48 <mauke> prof_nimnul: no, think in C and write in Haskell syntax
15:10:15 <geezusfreeek> ddarius: exactly. that's why i wonder whether it would be better to just be strict by default since it would fit expectations better
15:10:40 <ddarius> geezusfreeek: It only fits the expectations of people who are used to strict languages better.
15:10:48 <geezusfreeek> for anybody who is used to or regularly has to use strict languages besides haskell anyway
15:10:49 <ddarius> Both violate "naive" expectations.
15:10:52 <akorn> i think i can implement pretty complex things in procedural languages and actually understand pretty well how the algorithm will work
15:11:01 <akorn> but find it hard to convert to haskell
15:11:13 <vixey> akorn, you can do procedural programming in Haskell too
15:11:13 <mauke> akorn: do repmin in a procedural language
15:11:15 <geezusfreeek> ddarius: right, but, as you say, it doesn't really matter which is default
15:11:21 <akorn> maybe i dont truly understand what im doing then :P
15:11:31 <geezusfreeek> so might as well go with what people are used to
15:11:55 <vixey> mauke, what's repmin?
15:12:16 <ddarius> vixey: An archetypical cyclic programming example.
15:12:18 <akorn> i understand that im reducing the problem into small mechanical pieces that i repeat in loops and such
15:12:29 <mauke> given a tree, replace all elements by the minimum value in the tree
15:12:34 <mauke> but retain the shape
15:12:43 <vixey> oh that's easy
15:12:49 <akorn> and where the concept of assignment is more favorite building brick :(
15:12:52 <vixey> void * leaves = malloc(99999999999);
15:12:57 <akorn> more = my
15:13:03 <vixey> collect_leaves(leaves);
15:13:08 <ddarius> mauke: Easily solved by an extra level of indirection which is what the cyclic programming example essentially does behind the scenes.
15:13:20 <mauke> vixey: using a single tree traversal
15:13:27 <vixey> while(1) *(leaves++) = 4;
15:13:32 <vixey> what do I win!
15:13:40 <mauke> ddarius: but that tends to infect your whole program
15:13:46 <ddarius> mauke: Agreed.
15:13:51 <mauke> vixey: 4 is wrong
15:14:09 <olsner> excessive paranthetisation award for not just writing *leaves++?
15:14:10 <prof_nimnul> I think codata can do most things people expect from laziness. One of the problems with laziness is that it creates too much sharing when it isn't necessary
15:14:19 <vixey> mauke, my C is totally wrong but this is basically what the haskell program does .. except the array of pointers to leaves is implicit
15:14:22 <vixey> (isn't it?)
15:14:31 <prof_nimnul> prof_nimnul: So laziness shouldn't be by default
15:14:32 <mauke> vixey: no
15:14:35 <ddarius> Laziness doesn't create sharing at all.
15:14:43 <jsn> it is so frustrating that cabal is essentially single user
15:14:48 <geezusfreeek> prof_nimnul: that doesn't seem right to me
15:15:06 <akorn> do you remember what was the first big "conceptual revelation" when moving from procedural languages to haskell .. that made you able to apply your problems to haskell more easily ?
15:15:07 <vixey> mauke, can you write it in C ?
15:15:08 <jsn> i don't even know which parts to alter so that is becomes multi-user
15:15:22 <mauke> vixey: not sanely
15:15:32 <vixey> I'm curious how it would look
15:15:34 <ddarius> With a level of indirection it is trivial.
15:15:48 <geezusfreeek> you can just as easily have the same sharing in a strict language too, no?
15:16:05 <vixey> mauke, do you make a value type that may be a value or a pointer to a value type ?
15:16:14 <erikc> akorn: that a function's type specifies the exact side effects, if any, it has
15:16:15 <mauke> vixey: yeah, basically
15:16:20 <vixey> ok then
15:16:21 <prof_nimnul> ddarius: It does. The excessive sharing is the only thing why we need graph reductors such as G-machine or ABC-machine
15:16:26 <geezusfreeek> and a call-by-name language (vs. call-by-need) has no sharing, but is considered "lazy"
15:16:38 <vixey> that is how I think about the haskell program at the operational level
15:17:00 <prof_nimnul> geezusfreek: The problem is that Haskell is not just call by need - it uses call by need and normal reduction order
15:17:03 <akorn> erikc: wow.. thats pretty good. i think i can understand the point.
15:17:34 <vixey> prof_nimnul: if we didn't use <abstract machine> we'd use <different abstract machine> though..
15:17:53 <prof_nimnul> vixey: G-machine is not just an abstract machine
15:17:58 <geezusfreeek> prof_nimnul: i don't understand why this implies that laziness -> sharing though
15:18:06 <vixey> prof_nimnul: is it a way of life? :P
15:18:13 <vixey> prof_nimnul: I don't know what you mean at all ....
15:18:29 <prof_nimnul> vixey: Let me explain then
15:19:22 <gwern> jsn: if you install as root, what's not multi-user about cabal?
15:19:32 <dons> shapr: wanna see the next big thing?
15:19:34 <ddarius> prof_nimnul: Laziness adds sharing as compared to call-by-name, but you really, really don't want call-by-name to be the default.
15:19:41 <dons>  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gitit
15:19:43 <geezusfreeek> the argument as i've interpreted it looks like this: haskell is a lazy language, and haskell has a lot of sharing, therefore laziness implies sharing
15:19:53 <jsn> gwern: wouldn't it just install everything in /root/.cabal?
15:20:02 <ddarius> geezusfreeek: Actually, "laziness" usually means "call-by-need" (as opposed to call-by-name)
15:20:13 <jsn> gwern: it certainly doesn't behave well when i install under sudo
15:20:21 <geezusfreeek> ddarius: really? i actually have seen laziness used much more liberally than that
15:20:23 <ddarius> prof_nimnul: Nothing is shared unless it has the same name, just like in any other language.
15:20:34 <jsn> the bootstrap script has --user all over, it to
15:20:43 <gwern> jsn: well, then use one of the converters then
15:20:43 <vixey> geezusfreeek: I usually heard 'haskell isn't -lazy- it's non-strict' & 'lazy evaluation guarantees that you have sharing in these circumstances: <omitted>'
15:20:45 <ddarius> geezusfreeek: It is used more liberally than that, but such usage is incorrect.  Most people don't really care though.
15:20:48 <jsn> i deleted that but i've still got weird problems
15:20:52 <jsn> gwern: converters?
15:20:56 <gwern> I know .deb has no multi-user issues
15:21:01 <geezusfreeek> ddarius: ah!
15:21:06 * geezusfreeek rewires his mind
15:21:10 <sleven> why are GUIs hard anyway? like Tkinter for python makes it very easy to create A GUI but to create it really like I want it...damn that's tricky. why is it so hard to write a library(I assume it is hard since I ahev never found an easy intuitive one) which I can use to just declare the GUI's look or use a "drag-and-drop"-tool. is there a good GUI-tool for any language? one that I can use the mouth for. A gui for making guis...
15:21:23 <jsn> gwern: you mean, to make debian files and whatever?
15:21:29 <vixey> when I write haskell I pretend it is lazy evaluation though,, if the compiler does something else it's probably doing something sensible
15:21:34 <gwern> jsn: sure
15:21:46 <mwotton> sleven: apple's interface builder is pretty slick
15:21:49 <prof_nimnul> ddarius: Of course I don't.
15:21:51 <jsn> gwern: why don't i just keep altering cabal instead :)
15:22:03 <akorn> One of my problems learning the language is that i seem think particular problems so tightly in terms of the procedural implementation that I need to step a level up and see what I actually want.
15:22:04 <vixey> prof_nimnul: please do ,,
15:22:13 <vixey> prof_nimnul: or did I miss it ?
15:22:13 <akorn> this i can understand
15:22:15 <gwern> jsn: converting to your native package sounds easier to me
15:22:30 <jsn> gwern: what makes you think i can do that?
15:22:35 <prof_nimnul> vixey: It will take some time to find a good example
15:22:45 <jsn> gwern: it dumps Mac ports or Gentoo ebuilds?
15:22:47 <prof_nimnul> vixey: So be patient
15:23:01 <ddarius> prof_nimnul: There was a transformation call "full laziness" that -did- increase sharing, but it has since been removed or at least restricted.
15:23:21 <gwern> jsn: because we have tools for that sort of thing on hackage
15:23:30 <geezusfreeek> what is wrong with sharing, anyway?
15:23:49 <jsn> gwern: that actually doesn't save me any trouble at all
15:23:53 <rwbarton> akorn: do you have a particular area of problems in mind?
15:24:04 <ddarius> geezusfreeek: Nothing is wrong with sharing, especially in a pure language.  Increased or decreased sharing from what the programmer expected can cause problems.
15:24:20 <jsn> gwern: if you actually know something about the internals of cabal, and were willing to guide me in making it multi-user, that would help
15:24:21 <gwern> jsn: whine whine whine! see if I try to help you again
15:24:22 <rwbarton> akorn: I've found with a lot of graph algorithms, say, I don't really have any better ideas about how to write them in Haskell than just a straightforward translation of some imperative code.
15:24:33 <jsn> gwern: you didn't try to help
15:24:45 <jsn> gwern: you tried to tell me that what i wanted is stupid
15:25:24 * gwern never used that word
15:25:47 <ddarius> geezusfreeek: The problem with increased sharing is that it may keep something alive longer than expected potentially leading to space-leaks, the problem with decreased sharing is increased redundant work.
15:25:47 * jsn did not use quote marks
15:25:53 <quicksilver> jsn: installing as root, but using --user does a local install for root
15:26:11 <quicksilver> jsn: however you can install using --global, which does an install for all users on the system.
15:26:25 <jsn> quicksilver: really?
15:26:27 <jsn> thank you
15:26:35 <quicksilver> jsn: (you will obviously need write permission to certain directories at install time, which probably means running the last step as root)
15:26:49 <jsn> is there anyway to create a global .cabal?
15:27:00 <jsn> quicksilver: i do all this stuff with sudo
15:27:08 <quicksilver> sudo alone isn't enough
15:27:10 <akorn> rwbarton: is it top-down or bottom-up method that you usually apply in haskell ?
15:27:13 <quicksilver> --user remains the default even under sudo
15:27:25 <quicksilver> as a matter of good practice I don't normally compile under sudo though
15:27:28 <quicksilver> just install
15:27:30 <akorn> when thinking of entities consisting of simpler entities etc.
15:27:51 <quicksilver> akorn: both actually. I can never quite make my mind up.
15:28:01 <quicksilver> akorn: probably bottom up slightly more often, though.
15:28:07 <rwbarton> akorn: frankly most of the program I write are short enough (< 100 lines) that I can't really say
15:28:24 <vixey> akorn, is there a name for when you postulate the existence of stuff that makes writing your program _trivial_, use that.. then write those bits using the same idea
15:28:28 <quicksilver> akorn: define basic type, define basic operations, test those, then work on next layer up.
15:28:28 * Saizan uses cabal install --global --root-cmd=sudo
15:28:38 <geezusfreeek> rwbarton: i know you didn't ask me, but i will do either one depending on circumstances. i usually pick an abstraction i want, stub it out from the top with type declarations and `undefined`, then implement it from the bottom, recursing as i need more abstractions
15:28:41 <vixey> akorn: (I usually find myself taking that approach when programming haskell)
15:28:43 <quicksilver> vixey: that's top-down, I think.
15:28:44 <rwbarton> vixey: that sounds a lot like top-down to me
15:28:46 <jsn> Saizan: ah, thank you
15:28:47 <ddarius> vixey: That's is usually top-down design.
15:28:54 <vixey> ok thanks all
15:28:55 <jsn> is this stuff documented anywhere?
15:29:02 <rwbarton> geezusfreeek: oh yes, it's true.  I do use 'undefined' a lot.
15:29:03 <akorn> ok.. i was just wondering if theres some language specific constraint making it more natural to think it in one way of the other
15:29:12 <geezusfreeek> oops
15:29:22 <geezusfreeek> i meant to point to akorn
15:29:25 <quicksilver> jsn: I've never actually used cabal. I'm just an advanced AI which picks up received wisdom in this channel ;)
15:29:34 <quicksilver> I would think there ought to be docs somewhere...
15:29:48 <jsn> i tried to find them, really
15:30:05 <ddarius> @where cabal
15:30:06 <lambdabot> http://www.haskell.org/cabal
15:30:08 <jsn> i came in this channel and asked about the "global" section in the config
15:30:16 <Saizan> well, cabal install --help is where i start
15:30:19 <jsn> but was not able to get any answers
15:30:39 <quicksilver> you got them in the end ;)
15:30:45 <quicksilver> not enough people know how cabal works.
15:30:49 <jsn> after a month, yes
15:30:54 <quicksilver> I believe this situation is improving, though.
15:31:05 <jsn> quicksilver: well, now i will hang out here and be sure to answer questions
15:31:14 <ddarius> On that page, there is a link "Download (and documentation)" and on that page is a link to a User's Guide and also a link to API Documentation.
15:31:27 <mlesniak> Hi. A short question which can probably be answered by a link which google did not provide ;-). I try to install xmonad, which needs the haskell bindings to x11. I have a fresh ubuntu 8.10 and installed x11-dev. But when I run "runhaskell Setup.hs configure --user --prefix=/home/mlesniak/opt/" I get the errormessage "checking for X... no
15:31:27 <mlesniak> configure: error: X11 libraries not found, so X11 package cannot be built
15:31:27 <mlesniak> ". The config.log does not help much ;)
15:31:38 <Saizan> a message on haskell-cafe can be useful when you can't find an answer from #haskell
15:31:39 <mlesniak> (Uh, sorry for partial flooding)
15:32:25 <rwbarton> mlesniak: what package are you building when you get that message?
15:32:26 <ddarius> mlesniak: You need the X11 Haskell package
15:32:51 <Vulpyne> That was an error message from trying to install the X11 Haskell package. Most likely it's not looking for the libraries in the right place.
15:33:01 <ddarius> http://xmonad.org/intro.html
15:33:06 <lambdabot> Title: xmonad : building and installation
15:33:07 <mlesniak> rwbarton, ddarius: I used the X11 package from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11 (Link from the documentation of xmonad)
15:33:09 <lambdabot> Title: HackageDB: X11-1.4.4
15:33:50 <mlesniak> Vulpyne: Yes, the X11 Package. But I thought x11-dev (the ubuntu package) is installed in the default location under /usr/bla and setup.hs searches there for it, too
15:33:55 <Vulpyne> Putting "extra-lib-dirs : /path/to/x11/libs" into the .cabal file will probably solve that problem.
15:34:08 <rwbarton> mlesniak: You can try the libghc6-x11-dev Ubuntu package first, that will be the easiest thing if it works
15:34:08 <mlesniak> Vulpyne: Thanks, will try it
15:34:18 <Vulpyne> Sure.
15:34:19 <rwbarton> (i.e. if it's sufficiently recent for xmonad)
15:34:25 <mlesniak> rwbarton: another good idea, thanks
15:35:16 <prof_nimnul> vixey: ok... The example is just let a = 3 + 5 in a + a
15:35:31 <vixey> prof_nimnul, aha
15:35:41 <vixey> what about it?
15:37:04 <prof_nimnul> vixey: When lazy haskell evaluates this expression, it allocates a node in heap which stores 3 + 5 expression
15:37:21 <prof_nimnul> vixey: When non-lazy ML evaluates this expression, it doesn't allocate any nodes
15:37:30 <prof_nimnul> vixey: Let me explain step by step
15:37:38 <ddarius> prof_nimnul: It allocates space for 'a', in a very naive view.
15:37:47 <akorn> i guess everything you do in Haskell is "exact", i can understand this is most often a good thing
15:38:04 <ddarius> In practice, neither allocates space for this example (unless + is unusual which won't happen in ML)
15:38:21 <prof_nimnul> ddarius: The example is very naive of course. Haskell tries to avoid node allocation when possible, but sometimes that cannot be avoided
15:38:38 <ddarius> prof_nimnul: Both ML and Haskell will allocate space for 'a' in a naive view.
15:38:53 <vixey> so not understanding what this example illustrates
15:38:53 <prof_nimnul> ddarius: but not for 3 + 8
15:39:07 <prof_nimnul> vixey: I'm not finished yet :-)
15:39:42 <akorn> but have you ran into some applications where it would be nice to just do some "heuristic" stuff where it would be excessively complicated to express the same thing as a function?
15:39:59 <ddarius> akorn: Wtf are you talking about?
15:40:09 <akorn> :D
15:40:10 <ddarius> akorn: Haskell is no more or less "exact" than any other language.
15:40:13 <geezusfreeek> akorn: i find it excessively complicated to program in imperative languages now
15:40:13 <prof_nimnul> vixey: ML does the following
15:40:22 <prof_nimnul> vixey: root: let a = 3 + 5 in a + a
15:40:27 <vixey> I knowhow the both execute
15:40:33 <vixey> btw, so you can skip that if you like
15:40:52 <prof_nimnul> vixey: root: let a = 8 in a + a
15:41:02 <prof_nimnul> vixey: root: 8 + 8
15:41:08 <prof_nimnul> vixey: root: 16
15:41:24 <prof_nimnul> vixey: Haskell does the following:
15:41:35 <prof_nimnul> root: let a = 3 + 5 in a + a
15:41:41 <prof_nimnul> root: @node1 + @node1; node1: 3 + 5
15:41:48 <prof_nimnul> root: @node1 + @node1; node1: 8
15:41:59 <prof_nimnul> root: 8 + 8
15:42:04 <akorn> ddarius: isn't a function definition in haskell by definition "exact" as such.. compared to some function in C that alters a global variable causing all hell break loose in other threads etc.
15:42:05 <prof_nimnul> root: 16
15:42:14 <ddarius> akorn: Define "exact"
15:42:17 <geezusfreeek> akorn: you mean pure?
15:42:33 <vixey> akorn, you have model global variables in haskell
15:42:38 <akorn> i think i mean pure yeah...
15:42:41 <rwbarton> akorn: This is what I meant by "knowing what you want your program to do"
15:42:44 <prof_nimnul> vixey: The idea that Haskell allocates a separate node1 with a thunk
15:42:49 <vixey> akorn, it is also possible to write programs that don't work
15:43:10 <prof_nimnul> vixey: And creates a structure with 2 pointers
15:43:20 <vixey> prof_nimnul: I would not make a comparison like that without giveng formal descriptions of abstract machines for each language ..
15:43:29 <prof_nimnul> vixey: And such structure is impossible to avoid
15:44:00 <akorn> yeah i can understand this is generally desirable.. but has there ever been situations where you have hoped that haskell gave you mercy ;)
15:44:05 <prof_nimnul> vixey: Then you need to read a book on graph reduction systems
15:44:11 <vixey> prof_nimnul: it is possible to get that ML execution in haskell via annotations
15:44:26 <vixey> prof_nimnul: Did you have a point or just wanted to insult me ?
15:44:30 <prof_nimnul> vixey: Like Plasmejers
15:44:43 <rwbarton> @quote audreyt sea
15:44:43 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
15:44:51 <rwbarton> @quote trace
15:44:52 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
15:44:58 <erikc> akorn: there are escape hatches
15:45:15 <geezusfreeek> akorn: haskell is what some people call a "bondage and discipline" language. it's what we're into :)
15:45:25 <prof_nimnul> vixey: I have a point, but giving formal specification for abstract machines is not a simple explanation
15:45:28 <geezusfreeek> akorn: but i jest. there are ways to thwart it
15:45:31 <akorn> i failed to express what i really mean
15:45:35 <vixey> prof_nimnul, so what it is?
15:45:39 <akorn> even here in irc ;)
15:45:44 <vixey> prof_nimnul, (because I am sort of getting fed up of talking to you)
15:45:59 <akorn> geezusfreeek: hehe.. i guess thats what i mean
15:46:57 <geezusfreeek> akorn: we pretty much only use such escape hatches if there is _no_ way to otherwise do what we want, and even when we have to do it, we usually wrap it in the purest abstraction we can
15:47:07 <prof_nimnul> prof_nimnul: The point is that lazy evaluation creates excessive indirection nodes in compairson with strict evaluation, and those extra nodes are a big performance overhead
15:47:27 <geezusfreeek> prof_nimnul: if they are such a big performance overhead then explain http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=ocaml
15:47:31 <akorn> geezusfreeek: ok, i can understand that.
15:47:39 <lambdabot> Title: Haskell GHC benchmarks | Ubuntu : Intel® Q6600® Computer Language Benchmarks G ..., http://tinyurl.com/698byw
15:47:46 <vixey> heh
15:48:02 <prof_nimnul> prof_nimnul: and you don't need these nodes when evaluating let a = 3 + 5 in a + a - only when you need lazy lists
15:48:14 <ddarius> prof_nimnul: At worse, there is a constant factor overhead in memory used.  Admittedly, they can be used at different times leading to higher peak memory usage, but none of this is any more or less sharing than ML and of course the opposite situation can occur where ML uses a lot of memory all at once and Haskell would spread it out.
15:48:17 <erikc> akorn: in the same way that C has an escape hatch to assembly code if you want to do something that C cant, like say, change stacks for coroutines
15:48:19 <vixey> prof_nimnul, you might have missed my earlier comment
15:48:22 <vixey> prof_nimnul: it is possible to get that ML execution in haskell via annotation
15:48:24 <dons> prof_nimnul: hehe. lazy overheads are rarely left in haskell code.
15:48:36 <dons> only when laziness is actually used.
15:48:38 <rwbarton> especially the shootout code
15:48:50 <dons> which is why lazy languages like haskell and clean are so damn fast.
15:48:53 <vixey> prof_nimnul, I know what you're saying but in practice this has never been a problem (or even noticeable) for me
15:49:31 <prof_nimnul> dons: Only in small programs. For larger programs, current strictness analyzer isn't that good
15:49:40 <dons> prof_nimnul: do you have a bug to report?
15:49:48 <geezusfreeek> prof_nimnul: ghc is pretty smart about this, and if you use haskell enough then you get to where you can see whether something will be a thunk or not, most of the time
15:49:55 <prof_nimnul> dons: In analyzer?
15:50:08 <dons> yes. since it "isn't so good in larger probrams"?
15:50:15 <geezusfreeek> prof_nimnul: please provide evidence for these claims, because i have seen plenty of evidence to the contrary
15:50:17 <dons> i'd love to know what th eissue is.
15:51:14 <rwbarton> prof_nimnul: the ghc strictness analyzer is a lot better than the ml laziness analyzer
15:51:24 <vixey> rwbarton: hehe
15:51:31 <dons> but he's just making random assertions without evidence, so its kind of silly.
15:51:37 <ddarius> rwbarton: I was thinking the same thing, but wasn't going to say it.
15:51:57 <prof_nimnul> rwbarton: It's worse than Clean analyzer. And not only because of linear types not present in Haskell
15:52:22 <ddarius> prof_nimnul: You utterly missed rwbarton's point.
15:53:34 <dcoutts> jsn: did you get your global install issues sorted out?
15:53:42 <dons> prof_nimnul: do you have any evidence for these interesting assertions? "worse", "not so good", etc.
15:53:43 <prof_nimnul> dons: Yes, I'm just making random assertions right now. I'll show an example when Cleans analyzer works better, and then we'll continue this conversation.
15:53:44 <akorn> what about some probabilistic models where you want the outcome of some function to be random given some constraints?
15:54:04 <vixey> akorn, that's impossible in haskell :p
15:54:06 <dons> prof_nimnul: hehe. ok. we'd all love to see Clean giving some competition to GHC.
15:54:17 <vixey> akorn, (just kidding ... there are some monads which I saw do that I think..)
15:54:24 <dons> but unbacked assertions in #haskell are farily pointless
15:54:29 <jsn> dcoutts: haven't tried the recommended way yet -- meeting
15:54:34 <dons> prof_nimnul: and presumably bug reports.
15:54:50 <akorn> vixey: hehe.. i was wondering there was something for that since haskell has support for IO :)
15:55:09 <vixey> prof_nimnul: actually if you do come up with an example that makes essential use of linear types I'd be really interested in seeing that (since I have seen no cases where they really shine yet)
15:55:10 <prof_nimnul> dons: I do. At least I believe so. But filing a bug report will take some time - I just remember myself meeting some strange performance anomalies when porting from Clean to Haskell.
15:55:33 <dons> examples welcome.
15:55:45 <prof_nimnul> dons: yep
15:55:54 <dons> ghc needs some competition, so if you're working on this stuff, its a great chance to contribute
15:56:06 <dcoutts> jsn: cabal install --global --root-cmd=sudo is probably what you want
15:56:58 <dcoutts> dons: does the arch libedit package include a config file? I straced ghci and it doesn't even look for a global config file /etc/anything only ~/.editrc
15:57:28 <dons> dcoutts: that's what i'm wondering too
15:57:48 <dons> prof_nimnul: how's the haskell-parsing front-end to Clean coming along?
15:58:00 <akorn> learning haskell drunk is difficult :P
15:58:03 <dcoutts> dons: lemme know if you find out
15:58:19 * dcoutts :: Sleep -> IO ()
15:58:42 <ddarius> akorn: Well tomorrow you'll remember that you had a great revelation and all became clear, but you won't remember what that revelation was.
15:58:53 <akorn> ddarius: hehe i hope so :)
15:59:12 <prof_nimnul> dons: I'm not a Clean developer - I'm a user. The only thing I remember is that Clean 2.3 with Haskell front-end is going to be ready "soon"
15:59:22 <akorn> these chats have helped me a great deal though :)
15:59:37 <dons> though that's been the case for a couple of years.
15:59:42 <akorn> there are some very intelligent and helpful people out here
15:59:48 <akorn> willing to help people
16:00:01 <dons> if you're a user though, and you spot any difference in performance between clean and ghc, definitely we're interested
16:00:12 <dons> we hardly hear anything about clean anymore.
16:00:34 <ddarius> Clean code is rarely directly comparable to Haskell code.
16:01:36 <dons> well. as much as say, ocaml. maybe more so for "naive" stuff
16:02:08 <roconnor> ddarius: persumably the backend is more comparible to Haskell.
16:02:08 <jsn> dcoutts: thank you
16:02:26 <erikc> sigh, it depresses me so much that i spent my day deciphering 42 files of .h/.cpp containing 5000 LOC for a 'blackboard pattern' with dozens of entry points...
16:02:35 <erikc> and now when i understand the whole thing, i can convert it to ... to 1 pure function that takes a 3-tuple and generates a 3-tuple
16:02:58 <ddarius> roconnor: I doubt it is too much more or less comparable to Haskell than O'Caml's or ML's.
16:03:33 <ddarius> Actually, GHC's backend should be starting to look rather similar to one of the SMLs' backends.
16:03:50 <dons> yeah.
16:04:08 <dons> all these ML guys working on it too, the commit log looks like an SML backend :)
16:04:25 <lament> erikc: one pure function 5000 lines long?
16:04:33 <ddarius> Well part of it is inspired by an idea that was applied to an SML backend.
16:04:44 <erikc> lament: i didnt implement it yet, i'd say ~500 lines long
16:05:02 <ddarius> lament: 5000 would be impressive.  I've only almost gotten up to 1000.
16:05:07 <erikc> sorry, 500 lines for the data + code
16:05:34 <ddarius> And let me tell you GHC (at least 5.4.3 era I believe) really doesn't like 1000 line long functions.
16:07:15 <erikc> lament: every class has the whole gamut of oo wankery, even if its just a tuple, its all just noise
16:07:28 <lament> ddarius: you have a single function 1000 lines long?
16:07:35 <whoppix> ddarius, 1k lines for one function? Needs some serious refactoring...? :)
16:07:45 <ddarius> lament: It was I think 982.
16:07:48 <lament> nice
16:07:59 <lament> erikc: very few things are just tuples
16:08:07 <ddarius> whoppix: I did split it into more functions but GHC just inlined them back in.
16:08:16 <whoppix> ah well
16:08:31 <erikc> a struct is just a tuple with names :), you dont need virtual getters and setters
16:08:55 <ddarius> Yeah, some OO people have an aversion to data.
16:09:00 <gaze> I hate to incite a flamewar but with a reasonable amount of effort will I be able to squeeze more performance out of ghc or ocamlc? I've heard that ghc has changed a lot recently
16:09:25 <ddarius> gaze: Which one do you know better?  The answer to that answers your question.
16:11:22 <lament> erikc: there're very good reasons for being able to overload assignment
16:12:14 <mwotton> http://hpaste.org/11837
16:12:34 <mwotton> i'm getting a stack overflow on this code, which is sort of puzzling to me
16:12:35 <prof_nimnul> dons: Are there any chances to get Win32/x64 support any time soon? Mingw/x64 seems to be around for quite a long time already
16:12:35 <lament> erikc: (which is why haskell has records, with the equivalent of getters and setters, and the fact that they are NOT virtual is a huge annoyance to everybody)
16:13:11 <ddarius> lament: No one is annoyed that they are not virtual.
16:13:12 <erikc> it is? it hasnt bothered me :)
16:13:15 <mwotton> anyone see any particularly stupid mistakes in there?
16:14:13 <ddarius> mwotton: The problem is probably in other code.
16:14:15 <jeffwheeler> Is there a darcs repo for regex-tdfa? I can't seem to build it on 6.10.1, and other stuff depends on it.
16:14:21 <BMeph> Say, has anyone read any of Jonathan Edwards' papers of the stuff leading up to Subtext?
16:14:36 <mwotton> ddarius: well, it works ok without the caching code
16:14:36 <ddarius> BMeph: I'm sure someone has.
16:14:40 <jeffwheeler> I mean that I can't build 0.95.1.
16:14:51 <mwotton> and giving the -xc option shows the last thing called was Main.getDict
16:14:52 <lispy> subtext....that sounds familiar
16:15:03 <lament> ddarius: i suppose it's just annoying that you can't reuse the names
16:15:31 <lament> for unrelated record types
16:15:36 <ivanm> for some reason, pandoc 1.1 doesn't like haddock 2.4... even though pandoc 1.0.0.1 docs managed to get built by haddock 2.2.* :s
16:15:41 <ddarius> lament: To some, yes.  That's very different from OO overloading.
16:15:58 <ddarius> mwotton: It could be the Binary instance for Maps.
16:16:33 <mwotton> ah, hadn't thought of that.
16:16:55 <BMeph> ddarius: Okay, 'cause I just got finished with his paper on conditionals, and there's a hilarious sentence he uses on describing how his "schematic tables" deal with sequencing tasks.
16:17:40 <ddarius> mwotton: If you just change 'flag' to False it works fine?
16:17:44 <BMeph> "All operations with side-effects are represented as functions called actions that transform states." -- I feel as if I've heard of something like this before, but I don't remember where... ;)
16:18:08 <dons> prof_nimnul: well, ask MSR. they fund most of ghc's develoment. if there's win/x64 machiens to be had.
16:20:32 <mwotton> ddarius: yep
16:21:31 <mwotton> think i found out why - for some reason, the implementation of binary for Map looks at the length first
16:22:54 <mwotton> so we get an assoc-list for the whole map, then find the length of that, then serialise that.
16:23:42 <ddarius> The Binary instances tend to be non-lazy which is bad for large data structures.
16:24:04 <ddarius> Just write your own putMap/getMap that is lazier.
16:24:16 <shapr> dons: I can't install gitit
16:24:19 <mwotton> yeah, that looks like the best option
16:24:21 <shapr> Are you having the same problem?
16:24:25 <shapr> mwotton: y0! long time no see!
16:24:27 <mwotton> thanks ddarius
16:24:37 <mwotton> yeah, you too mate :)
16:24:49 <ddarius> mwotton: There should be a library of lazier Binary instances/functions somewhere, but I have no idea if it has an instance/function for Maps.
16:24:50 <mwotton> the bastards at optus made me a manager... no more code :/
16:25:13 <rwbarton> mwotton: I think there was a thread on haskell-cafe@ about the Binary Map instance recently
16:25:31 <mwotton> http://www.nabble.com/two-problems-with-Data.Binary-and-Data.ByteString-td18954800.html
16:25:37 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - two problems with Data.Binary and Data.ByteStr ..., http://tinyurl.com/6h84fh
16:25:42 <mwotton> rwbarton: that one?
16:25:54 <erikc> sorry, i just went one further level up and looked at the read/write patterns for those tuples, and the entire system reduces to ... 1 pure function that takes 1 list and generates 2 lists, with no continuation state
16:25:56 * erikc cries
16:26:06 <shapr> erikc: Yay!
16:26:10 <erikc> i need a new job
16:26:14 <rwbarton> mwotton: even more recent I thik
16:26:19 <ddarius> erikc: I recommend construction worker.
16:26:31 <mwotton> erikc: i have perl jobs available :)
16:26:32 <erikc> at least i'd get some sun
16:26:47 <joed> http://www.youtube.com/watch?v=QFQyib5ZQZY
16:26:48 <lambdabot> Title: YouTube - ding fries are done
16:26:58 <shapr> The closest I get to sun is that I occasionally use Java.
16:27:08 <erikc> behaaaaaaave!
16:27:14 <ddarius> shapr: I bet the building you work in actually has windows.
16:27:23 <shapr> ddarius: Yeah, I wish it had Linux instead :-(
16:27:44 <ddarius> This conversation is actually starting to be disturbing.
16:28:00 <ddarius> CS needs to start making up some of its own words.
16:28:01 <dons> shapr: why can't you install it?
16:28:28 <shapr> Company hardware, you get what you get.
16:28:36 <shapr> If it's not on the approved software list, you can't have it.
16:28:42 <mwotton> shapr: vmware + you = not friends?
16:29:05 <Nafai> shapr: I'd hate to work at a company like that :(
16:29:12 <shapr> Actually, I have to use VMWare for SharePoint development.
16:29:19 <shapr> Nafai: Yeah, I know what you mean.
16:29:23 <dons> shapr: you're working on sharepoint?
16:29:35 <shapr> There's still some question as to whether emacs in on the approved software list.
16:29:42 <shapr> dons: Yeah, sort of...
16:29:47 <shapr> SharePoint is the focus killer...
16:30:04 <Nafai> shapr: Lemme guess, you don't have Administrative access to your machine?
16:30:05 <shapr> The smallest change requires 1 minute and 20 seconds minimum feedback time.
16:30:15 <mwotton> shapr: probably best to wait and see, it's only been out a decade or twelve, right?
16:30:26 <shapr> Nafai: I can install programs, but there are parts of the laptop that I cannot access, that is correct.
16:30:50 <shapr> mwotton: Yeah, I just dunno about that one.
16:31:00 <Nafai> shapr: My Father-in-law has the same problem at Dell.  He even has to fight to have programs necessary for his job installed
16:31:36 <shapr> For one task, no one could find our copy of PhotoShop after a week of looking, so I just installed the GIMP and did the task in five minutes.
16:31:43 <erikc> heh, those kinds of policies are the equivalent of handcuffing your police officers
16:32:07 <shapr> There's much that could be improved where I work.
16:32:19 <Nafai> shapr: Wow, I'd go fricken' crazy
16:32:21 <shapr> We can't get an external monitor for the laptop, and I can't bring in my own.
16:32:51 <mwotton> oh, ouch. just using the laptop screen is strictly for cafe hacking
16:33:18 <erikc> hehe, i wanted to bring in my home machine to work on, since it compiles our codebase from clean in 2 mins vs ~20 on my work machine, no dice
16:33:19 <shapr> I have acquired an external screen, but it's strictly against the rules.
16:33:40 <erikc> its like, please, please, let me make you money
16:33:46 <shapr> erikc: Similarly, I can do sharepoint development with much better feedback times on my Linux box.
16:34:19 <shapr> So, does anyone know where I could host some IBM BladeCenter blades? :-/
16:34:25 <Nafai> shapr: Were you aware of these policies when you were hired?
16:34:32 <Nafai> shapr: Or were they big surprises?
16:34:46 <shapr> Nafai: I'm contracting there, my actual employer is cool.
16:34:54 <Nafai> shapr: Ah, okay :)
16:35:02 <shapr> Nafai: And no, I wasn't aware of those policies. I was seriously grumpy the first few months.
16:35:15 <Nafai> Luckily I have a friend that works at the place I'm awaiting an offer from
16:35:21 <Nafai> So I know of what things are like on the inside
16:35:33 <Nafai> I would hate to sign up and be hit by something like that
16:35:39 <shapr> Now I just have a cycle of five minutes to make some changes, two minutes of reading reddit, repeat
16:35:41 <erikc> o yea, shapr, i read your blog, did you say you got a mercury blade for like 50 bucks?
16:35:52 <shapr> erikc: Yup, I have four now.
16:36:02 <erikc> uh, from where
16:36:05 <erikc> i want a dozen :)
16:36:19 <shapr> Do you have a working installed chassis?
16:36:25 <erikc> nope
16:36:52 <shapr> I can get the chassis easily enough, I just can't power it...
16:37:41 <erikc> i do my spu development on a ps3 with linux, a blade would be a nice upgrade
16:38:24 <shapr> erikc: If I find someplace to put 'em, I'll give you an account.
16:39:18 <erikc> cool
16:40:38 <shapr> My original purpose was to try NDP on the Cell, but ChilliX said it requires UMA instead of NUMA, and I already know the SPUs probably can't do anything with Haskell. 256k of memory is not enough.
16:40:58 <shapr> There could be a SPU DSL, but I can't think of any better uses.
16:41:26 <erikc> ndp == nested data par?
16:41:29 <shapr> yup
16:41:52 <shapr> It's too bad, I even have some infiniband daughterboards :-/
16:41:54 <erikc> i think someone at queens university did a dsl for spu
16:42:02 <shapr> in/for Haskell?
16:42:05 <erikc> yea
16:42:08 <dons> mmm
16:42:20 <shapr> whoa!
16:42:24 <dons> shapr: and there are people on -cafe@ interested too
16:42:28 <shapr> Oh?
16:42:34 <dons> shapr: you should ask for input on -cafe@
16:42:40 <shapr> Good idea!
16:42:40 <dons> chad scherrer's interested, iirc.
16:42:51 <dons> i remember him asking about it a year ago or more.
16:43:51 <shapr> erikc: I got my PCIe Cell Accelerator Board for $30 :-)
16:43:56 <sbahra> Wow
16:44:02 <sbahra> shapr, how/where?
16:44:05 <erikc> whaa
16:44:08 <erikc> indeed, where :)
16:44:26 <shapr> Some very confused person on ebay had it listed with a bunch of MFM/RLL drives.
16:44:33 <erikc> wow
16:44:38 <dons> hehe
16:44:51 <newsham> eBandit
16:45:26 <ddarius> It's immoral to let a sucker keep his money.
16:45:31 * shapr tries to think of more Haskell oriented uses for a bunch of Cell hardware.
16:45:46 <newsham> render unto sucker that which is suckers
16:46:09 <dolio> Use stream processing for high performance type checking!
16:46:16 <shapr> dolio: Would that really work?
16:46:35 <dolio> Probably not.
16:46:41 <sbahra> shapr, wow, great find
16:47:45 * ddarius wishes "Coming soon" meant less than a month.
16:48:51 <shapr> sbahra: The warehouse that sold me all these goodies is about half an hour's drive away, I'm thinking I should drop by and check their bins in person.
16:49:00 <erikc> i'd write spu code in C and then have haskell on the ppu to allocate/schedule/retire the workloads based on a dependency graph
16:50:39 <shapr> Do you think that would keep the SPUs fed?
16:50:44 <dolio> Do I need to reinstall cabal-install now that I've installed 6.10.1?
16:50:56 <dolio> Right now it seems to be using all my memory to do dependency analysis.
16:51:17 <dons> ddarius: ?
16:51:53 <ddarius> dons: Nothing relevant.
16:52:06 <erikc> shapr: yea, there are optimizations that can be done if not
16:52:11 <dons> fwiw, "RWH will be sent to the printers" next friday.
16:52:16 <ddarius> shapr: See what they are throwing away!
16:52:24 <dons> start the press.
16:52:26 <bos31337> really? cool!
16:52:34 <dons> bos31337: you didn't see that comment?
16:52:45 <bos> dons: no
16:53:13 <bos> dons: where?
16:53:39 <dons> from Laurel, iirc.
16:53:45 <dons> checking...
16:53:59 <shapr> dons: Awesome!
16:54:27 <shapr> erikc: What sort of spu programming do you do?
16:54:27 <dons> bos, loranah mentioned it.
16:54:50 <erikc> ps3 games
16:54:55 <Saizan> dolio: yes, you should have updated it before, actually
16:55:03 <dolio> Heh.
16:55:05 <bos> thanks
16:55:15 <dons> bos, forwarded.
16:55:30 <erikc> i actually dont do much spu programming, just a lot of spu debugging, sadly
16:57:45 <erikc> sony has done an admirable job of idiot proofing spu programming, but the result is ppl can write code fairly easily, and then have no clue how to proceed when it things go wrong, and im the guy who knows the asm, abi, loader, debugger, profiler details
16:58:06 <shapr> I'm still learning, I'm a newbie.
16:58:11 <shapr> Now I know who to ask =)
16:58:21 <erikc> sure :)
16:58:46 <shapr> erikc: Oh hey, is there some way for SPUs to send each other data directly? via the EIB maybe?
16:59:00 <shapr> Or is DMA to main memory and back to the LS the only way?
16:59:32 <erikc> each LS is mem-mapped to main memory so you can DMA directly between those maps
16:59:38 <shapr> I wonder if 256k ls would be enough for parallelizing proof assistants.
16:59:42 <shapr> Ah, excellent!
16:59:56 <shapr> And it goes directly via the eib?
17:00:24 <erikc> yup, to my knowledge, my knowledge gap is eib-related stuff
17:00:54 <newsham> newbie http://www.thenewsh.com/~jack/2008-oct/picspage/100_1249-nav.html
17:00:55 <lambdabot> Title: newbie
17:02:45 <shapr> newsham: your child process?
17:03:07 <shapr> erikc: This SPU DSL is awesome :_)
17:03:23 <shapr> I wonder if McMaster would host my blades...
17:03:27 <shapr> @seen cale
17:03:27 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I don't know when cale last spoke.
17:03:44 <shapr> newsham: cute pic
17:06:56 <mwotton> is there a particular reason Ints are 32 bits on mac os? I'd have expected 64 to be the standard...
17:07:18 <ivanm> mwotton: IIRC, they're slowly transitioning to a 64bit system
17:07:44 <mwotton> ah, fair enough. am just missing IntMap specialised to 64bit keys
17:07:48 <jsn> mwotton: aren't macs mostly 32bit ?
17:08:13 <thoughtpolice> core2's are 64bit
17:08:43 <mwotton> which is what i have, and i don't care about portability even a little bit :)
17:08:55 <mwotton> (prototyping etc)
17:09:00 <dolio> It's not just a question of the chip, though.
17:09:16 <dolio> For instance, when I run 32-bit linux on my Athlon64, I get 32-bit Ints.
17:09:32 <rwbarton> Same here with linux on Core 2 Duos.
17:09:39 <mwotton> yeah. i think mac has some translation stuff for running 32 bit code
17:10:25 <rwbarton> ghc is probably running in that translation layer
17:10:40 <rwbarton> unless you got a 64-bit version (I don't know if there is one, but ghc runs on my old 32-bit mac)
17:12:37 <rwbarton> Oh, I guess Macs have the universal binary thing.
17:17:38 <jsn> rwbarton:  universal binary was for OS9 and OS X
17:18:45 <rwbarton> It was also for 68K/PPC before OS X, and I think now it's for PPC/x86/x86_64/etc. on OS X
17:19:16 <jsn> rwbarton: oh, really?
17:19:24 <jsn> did not remember that
17:19:29 <rwbarton> I guess they were called "fat binaries"
17:19:40 <rwbarton> not "universal binaries"
17:20:07 <jsn> ah
17:23:54 <sbahra> dons, line 762 of Main.hs in cabal2arch has a typo
17:25:24 <Axman6> jsn: yeah OS X binaries can now be PPC, PPC64, x86 and x86_64 in the one file
17:26:53 <Axman6> urgh, seems like it's impossible for me to get conjure from anywhere, keeps failing on one specific patch, which i can download just fine using wgat
17:28:15 <sjanssen> Axman6: does darcs get --partial help?
17:28:43 * Axman6 tries
17:31:13 <gwern> Axman6: if you're going to work on conjure, it'd be cool if you could fix the Int-related max-file-size bug
17:31:41 * gwern wonders if Lemmih ever applied my conjure patches
17:31:51 <gwern> oops. seems he didn't
17:31:52 <Axman6> i was more thinking of playing with it... but i have about three months off uni coming up, so who knows
17:31:54 <gwern> bad Lemmih
17:32:09 <Axman6> rawr!
17:32:12 <Axman6> still can;t get it
17:32:22 <Axman6> darcs failed:  Failed to download URL http://j.mongers.org/pub/haskell/darcs/conjure/_darcs/patches/20051110213306-b42ee-db2aa56ccf9e64495d3142de99cdee6a02021244.gz: resource exhausted
17:32:33 <gwern> Axman6: I can tar up my repo for you
17:32:35 <lambdabot> http://tinyurl.com/6arfre
17:32:45 <gwern> you'd get my cabalization patches too
17:32:47 <Axman6> that would be appreciated, thanks :)
17:32:59 <gwern> but that
17:33:03 <gwern> is a strange url
17:33:10 <gwern> you're pulling from j.mongers.org?
17:33:17 <gwern> I thought conjure was at http://darcs.haskell.org/~lemmih/conjure
17:33:22 <lambdabot> Title: Index of /~lemmih/conjure
17:33:30 <Axman6> yeah, i was getting it from someone where else, but i was getting the same errors
17:33:52 <Axman6> yeah, i was getting it from there
17:34:05 <gwern> uh oh, my repo seems to be corrupt
17:34:06 <gwern> hum
17:35:24 <xcthulhu> I am vaguely aware of a map-reduce implementation in haskell, are there any other cool parallel processing systems for haskell?
17:36:26 <jdrake> Has anyone ever done any syntax highlighting for haskell in nano?
17:36:45 <Axman6> hooray, --partial managed to get it from darcs.haskell.org!
17:37:03 <gwern> Axman6: anyway, to go back to the Int bug - the problem seems to be that buried way down the stack, the definition of a file's length used Int, and Int propagates upwards from there. the worst part is, that original definition was interfacing with various FFI calls
17:37:20 <gwern> I'm not good with FFI stuff, so when i traced the errant Int back to there, I was kind of stuck
17:37:31 <Axman6> oh, ew
17:37:43 <Axman6> yeah, way past my level
17:38:06 <gwern> Axman6: well, poke around src/Conjure/FileSystem
17:38:06 <Axman6> Milestone 2: Yet to be defined. -- heh
17:38:09 <gwern> maybe you can handle it
17:39:01 <gwern> (the annoying thing is that I know someone like dons or sjanssen could fix it in 20 or 30 minutes because of their C knowledge, but I don't even know where to being)
17:39:35 <Axman6> heh, me either
17:42:20 * Axman6 wonders if changing everything to CLongs would help...
17:42:23 <Axman6> >_>
17:42:34 <gwern> Axman6: give it a try I suppose
17:42:39 <Axman6> yeah... breakfast time
17:42:45 <rwbarton> CLong is probably the same as CInt on lots of platforms
17:43:04 <gwern> although I'll admit it can be rough finding a torrent with a single file big enough to trigger the error
17:43:15 <gwern> iirc, it has to be about 5 gigs
17:46:59 <cdfh> is anyone here using Yi as their default editor for Haskell?
17:48:24 <gwern> cdfh: I think jp does, but he's not here
17:48:34 <gwern> you'd have better luck asking on yi-devel
17:51:48 <mwotton> oh,  yow. cabal's taking 2.7 gigs of memory...
17:52:17 <cdfh> gwern: k, thanks; i'm thinking of migrating from emacs
17:52:27 <cdfh> it looks (and feels) much cleaner
17:52:49 <lispy> I've seen kitty litter boxes that are cleaner than emacs :)
17:52:56 <gwern> cdfh: it is, but it is also much less feature complete, bug-free, and following darcs yi (which is a must) can be difficult
17:52:58 <cdfh> :-)
17:53:01 <lispy> don't get me wrong, I like emacs
17:53:03 <gwern> I myself am currently locked out due to deps
17:53:24 <gwern> cdfh: I don't say this to discourage you but just make sure that you understand what you're getting into
17:53:48 <cdfh> indeed - i won't delete my .emacs file just yet :-)
17:54:33 <cdfh> my reasoning is that emacs is realistically, only going to get more messy; whereas Yi will hopefully improve
17:55:36 <Saizan> mwotton: just upgraded to 6.10 without upgrading cabal-install to 0.6?
17:56:03 <lispy> cdfh: I found it depends.  If you just consume emacs without writing any elisp.  It can stay pretty clean.  But...once you start down that road where you write your frist 100 lines of elisp to get something working...it quickly turns into a tarpit.
17:56:30 <Nafai> Great
17:56:33 <lispy> I lost a lot of hours of my life writing elisp
17:56:35 <Nafai> Now I want to try out Yi again
17:56:35 <cdfh> lispy: yes. i don't write much elisp, but that's perhaps because it's elisp :-)
17:57:18 * lispy even has a pet project that is a x86 compiler for elisp...he had hoped to someday port it to Yi for efficient emacs emulation
17:58:28 <mwotton_> lispy: that'd be really cool. obviously emacs isn't the best possible environment, but there's too much cool stuff in there to abandon...
17:59:16 <lispy> mwotton: that was exactly my reasoning.  We could start using Yi today and porting things over as we get time
18:01:38 <enzo_1> Is the determinant of a square matrix always equal to the determinant of that same matrix transposed?
18:02:01 <ddarius> enzo_1: Yes.
18:02:18 <enzo_1> thanks ddarius
18:03:16 <mwotton> #haskell: providing high quality 1-bit answers since 200
18:03:23 <mwotton> 2000, even.
18:03:59 <xcthulhu> lispy: Is there any cool latex writing stuff for Yi yet?
18:04:06 <Saizan> mwotton: btw, still having a problem with cabal's space leak?
18:04:28 <xcthulhu> lispy: I'm guessing no...
18:04:29 <jdrake> @hoogle emptyDef
18:04:30 <lambdabot> Text.Parsec.Language emptyDef :: LanguageDef st
18:04:30 <lambdabot> Text.ParserCombinators.Parsec.Language emptyDef :: LanguageDef st
18:05:39 <cdfh> enzo_1: "A matrix and its transpose have the same determinant:", http://en.wikipedia.org/wiki/Determinant#Properties (just to confirm)
18:05:40 <lambdabot> Title: Determinant - Wikipedia, the free encyclopedia
18:06:30 <xcthulhu> The infallible argument via Wikipedia
18:06:36 <xcthulhu> :)
18:07:30 <gaze> what's the syntax to coerce "x <- readln" to use the string version?
18:07:35 <cdfh> :-)
18:07:36 <mwotton> Saizan: yes - was crapping out at finding dependencies
18:08:02 <Saizan> mwotton: you're on 6.10 i guess, upgrade manually to cabal 0.6
18:08:10 <mwotton> realised i was using ghc 6.8, switched to 6.10, and now i'm trying to get cabal not to fall over because of an empty user db as in ghc bug 2201
18:08:16 <mwotton> righto
18:08:43 <ddarius> Who needs authority when you have proof?  <f(I),I> = <I,f^T(I)>
18:08:45 <ddarius> QED
18:09:00 <mwotton> can't upgrade from within cabal? quis cabaliet cabales?
18:09:37 <Saizan> mwotton: well, only if you make it use another ghc to build the new cabal
18:10:02 <Saizan> mwotton: like "cabal install cabal-install -w ghc-6.8.3" if you've 6.8.3 installed
18:10:55 <mwotton> so that'll make it install using 6.10?
18:11:13 <Saizan> ah, you may need cabal update first
18:11:49 <Saizan> mwotton: the point is that cabal-install < 0.6 has a bug triggered by the packages that come with 6.10
18:11:58 <mwotton> ah, gotcha
18:12:51 <gwern> cdfh: my long-term goal is to switch over to yi when I can actually compile it, write syntaxhighlighting for sh-style files, and then grin and bear the missing features
18:13:17 <mwotton> gwern: revelling in the joys of self-denial :)
18:13:21 <Saizan> the -w flag tells it to use that specific compiler instead of defaulting to `which ghc`
18:13:39 <gwern> mwotton: well, I lost some features going from stumpwm -> xmonad, but it was good for me in the long-run
18:13:55 <mwotton> i still miss tiling WMs
18:14:03 <mwotton> doesn't play so nice with macos, unfortunately
18:14:19 <gwern> another example: I accidentally deleted my  multi-gigabyte collection of wallpapers. I decided to bite the bullet, set my 'wallpaper' to pure black, and never again spend time hunting down novel wallpapers
18:14:31 <gwern> withdrawal was painful, but I survived and am better for it
18:15:05 <gwern> an even better example: I acidentally destroyed my windows installation. I decided: why not use that ubuntu disk lying around? I've been meaning to try linux...
18:15:24 <mwotton> heh. destruction and rebirth...
18:15:27 <ddarius> Born-again xmonad users; the worst kind.
18:16:05 <Saizan> you accidentally what?
18:16:08 <gwern> ddarius: better than dwm snake-handlers
18:16:14 <gwern> Saizan: my entire windows installation!
18:16:23 <Axman6> gwern: but but... now you can't have them change every 5 seconds like i do :(
18:16:24 <Cale> http://www.reddit.com/r/programming/comments/7bxgm/beautiful_folding_in_haskell_how_to_write_a/c06909o -- what do people think of this idea?
18:16:25 <gwern> (bah, a new haddock bug)
18:16:27 <lambdabot> Title: cgibbard comments on Beautiful folding in Haskell : how to write a memory-friend ..., http://tinyurl.com/5rfhs7
18:16:53 <lispy> xcthulhu: that's a good question, but I haven't used Yi for 2-3 years :)
18:17:29 <gwern> Cale: it's a bad idea and you should feel bad. er.. I mean, isn't there enough syntax in haskell already?
18:17:40 <Cale> gwern: Well, there's no syntax for this.
18:17:53 <gwern> %x isn't syntax?
18:17:56 <dolio> @type (%)
18:17:57 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:18:03 <Cale> gwern: In fact, it's not so much the syntax, but the underlying mechanism that I care about.
18:18:10 <Saizan> one could use a primitive like dup :: a -> (a,a) instead
18:18:34 <Cale> gwern: It's a bigger change to the evaluator than it is to the parser ;)
18:18:51 <Saizan> Cale: have you thought of other examples where it would be useful?
18:19:06 <cdfh> xcthulhu, lispy: just checked now - Yi has LaTeX syntax highlighting
18:19:23 <Cale> Saizan: I have seen other cases where too much sharing creates memory leaks.
18:19:48 <gwern> Cale: it just seems a bit of a narrow change. wuoldn't it better to just have smarter implementations and the standard optimization techniques?
18:19:53 <Cale> I'm not sure if I have one handy though :)
18:20:18 <gaze> is there any way to get haskell to flush stdout or whatever buffering it has of it?
18:20:20 <sjanssen> Cale: it is hard to imagine how that would work
18:20:32 <Cale> sjanssen: Probably by copying.
18:20:39 <rwbarton> Cale: This sounds a little bit like Clean "macros" (about which I know next to nothing)
18:20:47 <sjanssen> Cale: would there be a difference between "let x = [1 .. 10] in mean x" and "mean [1 .. 10]"?
18:20:51 <lispy> cdfh: nice
18:21:03 <Cale> sjanssen: no, I wouldn't think so.
18:21:43 <Cale> sjanssen: the idea is that you'd effectively switch from lazy evaluation to normal-order evaluatio
18:21:44 <Cale> n
18:21:51 <Axman6> Cale: what do you think of my idea for 'memoise this function' syntax? f $x = somethingCostly x / (mostCost x * reallyCostly x) would memoise the result of f x in the runtime
18:21:55 <sjanssen> Cale: what about "mean $! [1 .. 10]"?
18:22:37 <dolio> So instead of a mean that takes forever and uses all your memory, it's just a mean that takes forever. :)
18:23:53 <Axman6> had a semi heated discussion on whether it was a good idea or not, where most people were beginning to think it would be a good idea by the end of it
18:24:27 <sjanssen> Axman6: I don't think that syntax is good
18:24:39 <sjanssen> Axman6: ($) is already too overloaded in Haskell
18:24:46 <Axman6> well, something there
18:24:51 <ddarius> I don't see why that would require any syntax.
18:24:59 <Cale> sjanssen: That one is a bit tougher, because you have to decide whether to look inside data constructors for unevaluated expressions.
18:25:05 <sjanssen> Axman6: also, shouldn't memoization be an annotation on the function rather than the argument?
18:25:16 <Cale> sjanssen: But I don't think it would hurt too badly in most cases to take a copy.
18:25:55 <sjanssen> Cale: I'm just trying to imagine how this could work
18:25:58 <rwbarton> Cale: You only want to copy thunks, not values?
18:26:07 <Axman6> sjanssen: yeah, that would make more sense, though might make it confusing to the beginner when they write @f x = ...; f 2 or @f 2, but not too hard to figure out i guess
18:26:09 <sjanssen> the thunk case is easy, just copy it
18:26:10 <Cale> Hmm, I wonder how often sharing issues come up with values that are already evaluated into WHNF.
18:26:20 <Cale> sjanssen: right...
18:26:22 <Nafai> Dang, I need to upgrade cabal so I can compile Yi
18:26:31 <shapr> Cale: Does mcmaster have a bunch of bladeservers?
18:26:37 <sjanssen> Cale: it would be silly if "mean [1 .. 10]" worked, but "mean (1 : [2 .. 10])" didn't
18:26:49 <Cale> shapr: I have no idea.
18:27:00 <Cale> shapr: I was only there for a few months.
18:27:04 <shapr> oh, ok
18:27:12 <Cale> shapr: And mostly used separate equipment from other projects.
18:27:31 <shapr> It seems that coconut does something with the Cell cpu, just curious about that.
18:27:36 <Nafai> How do I find out what version of Cabal I have?
18:27:51 <sjanssen> Nafai: ghc-pkg list Cabal
18:27:59 <xcthulhu> cdfh: I am kind of spoiled by modern latex editors - the best ones have an interface for clicking on parts of the document and going to the corresponding portion of the original document.
18:28:06 <gwern> 'That is, after I send a bundle, I have a guaranteed minimum twenty-four hour window in which to discover (and amend, resend) cock-ups, and other denizens have that same window in which to review the patch and scream something like "Noooooo!  Don't apply this; doing so will cause the heavens to fall and the ground to be rent asunder."'
18:28:07 <Cale> sjanssen: Yeah. So it might have to go down into the evaluated portion of a value, taking copies of constructors as well as thunks.
18:29:14 <Axman6> so, any more thoughts on a memoisation syntax?
18:29:17 <xcthulhu> cdfh: And literate coding is totally a must for me sadly...
18:29:26 <sjanssen> Cale: I think a better foundation is a function: copy :: a -> a
18:29:40 <Axman6> i think it should be syntax, so the programmer can specify what's expensive and what's not
18:30:04 <sjanssen> Cale: at least in GHC that is possible as a primop
18:30:10 <Cale> sjanssen: hmm, yes.
18:30:16 <dolio> Axman6: I'm not sure it warrants a syntax, since you can basically write a library to do it yourself (I wonder if there's one on Hackage).
18:30:19 <Axman6> should make naive fib n much faster
18:30:23 <dolio> Unless the runtime is going to do some extra magic.
18:30:41 <Axman6> dolio: that's what i'm proposing, the runtime handles it
18:30:56 <rwbarton> dolio: I believe there are at least two! :)
18:31:02 <dolio> Heh.
18:31:03 <Cale> sjanssen: Of course, carefully sequencing the copying in with the rest becomes important.
18:31:14 <Axman6> so you can tell it, hey, this function's hard to compute, but easy to store the result, so... do that
18:31:29 <Cale> sjanssen: it would have to be something like:   mean xs = ys `seq` sum xs / genericLength ys where ys = copy xs
18:31:31 <ddarius> Axman6: There is no reason for the run-time to handle it, and there are reasons to not have the run-time handle it.  The run-time, though, could provide some primitives to support it.
18:31:35 <sjanssen> Cale: right
18:31:50 <dolio> Yeah, but you can do that with a few combinators, and it isn't significantly harder than using an extra syntax.
18:32:26 <dolio> rwbarton: data-memocombinators and MemoTrie?
18:32:40 <rwbarton> dolio: Those both sound familiar
18:33:13 <Axman6> i just think it would be nice to have a way to do it, without having to type more than a single extra character, and worry about how it works, seems a vary haskelly idea to me
18:33:26 <MarcWeber> ping int-e
18:33:46 <sjanssen> Axman6: I think you need to worry about how it works, there are too many different implementations
18:33:49 <int-e> MarcWeber: pong
18:34:12 <MarcWeber> What is the status of your git-darcs-import tool?
18:34:14 <Axman6> sjanssen: what do you mean?
18:34:15 <sjanssen> Axman6: should functions be memoized by reference or value?
18:34:26 <dolio> MemoTrie looks about like what I've written in the past.
18:34:32 <MarcWeber> Do you have a more up to date version which can be compiled against the darcs darcs version?
18:34:36 <sjanssen> Axman6: what sort of asymptotic bounds can we expect?
18:35:02 <sjanssen> Axman6: will the run time always memoize a result, or will old results be garbage collected after a while?
18:35:03 <MarcWeber> int-e: Do you have considered asking the darcs team wether they would like to add it to the distribution?
18:37:17 <int-e> MarcWeber: I'm afraid I haven't touched the code in 3 months (http://repo.or.cz/w/git-darcs-import.git is current except for one addition to the TODO file)
18:37:18 <Axman6> sjanssen: well, i'm saying it would be used with functions with easily stored results, so the size would be unlikely to use too much memory, and it'd me up to the programmer to test whether it used too much memory, just like ! in datatypes
18:37:19 <lambdabot> Title: Public Git Hosting - git-darcs-import.git/summary
18:37:48 <MarcWeber> int-e Do you mind me trying to update it?
18:38:03 <int-e> MarcWeber: no, not at all.
18:39:40 <int-e> MarcWeber: I've been meaning to update it and , but keep doing other stuff instead. Feedback will help my motivation *g*
18:40:15 <jdrake> I am trying to follow http://www.hvergi.net/2008/06/parsing-json-with-haskell/ to implement a minimal TeX parser (my own subset) that might work something like this: http://hpaste.org/11840  The code I have been able to come up with is http://hpaste.org/11841  which so far does not actually implement anything. I am having trouble figuring out how a lexer would actually be constructed. Any ideas that might direct me?
18:40:57 <shapr> Yow, I am overwhelmed by Haskell on Cell goodness!
18:41:04 <jekor``> \nick jekor
18:41:08 <jekor``> Woops
18:41:20 <shapr> Doc Anand does some amazing stuff - http://www.cas.mcmaster.ca/~anand/papers/preprints.html
18:41:21 <lambdabot> Title: Preprints
18:42:12 <mwotton_> hey, should cabal-install work with ghc
18:42:15 <mwotton_> 6.10?
18:42:50 <mwotton_> am getting "Class Exception used as a type"n
18:44:56 <int-e> huh, darcs.net is down?
18:45:56 <int-e> MarcWeber: do you mind if I message you?
18:46:32 <mwotton> ah, i suck. old version. sorry.
18:47:15 <gwern> int-e: yes
18:47:23 <gwern> int-e: it responds to ping, tho
18:52:28 <Axman6> where can i get info on the FFI for C?
18:52:28 <jdrake> @hoogle parseTest
18:52:29 <lambdabot> Text.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
18:52:29 <lambdabot> Text.ParserCombinators.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
18:52:29 <lambdabot> Distribution.ParseUtils parseTestedWithQ :: ReadP r (CompilerFlavor, VersionRange)
18:52:47 <int-e> MarcWeber: and no, I haven't approached the darcs folks about it - in fact I'd be much happier about darcs providing a library instead, but didn't want to do the required work - not the least that of convincing the darcs folks that this is worthwhile.
18:53:16 <MarcWeber> They've been talking about it..
18:53:42 <MarcWeber> But having them take care would definitely prevent it from getting bit rotted.. And if it works it's definitely worth it.
18:54:10 <gwern> int-e: I think eric is behind libdarcs
18:54:21 <gwern> his roadmap seems to include it vigorously
18:54:46 <gwern> (which is nice, since I've been championing the idea for a long time. it was a major reason for me to cabalize darcs)
19:00:04 <jekor> Saizan: Thanks for the help. I finally figured out. It's amazing how simple it ended up being and yet it took me days to figure it out. But your comment did it.
19:00:42 <ddarius> Cale: Quiz's post is a lot more interesting and useful than your suggestion, while being a lot less complicated to support/implement.
19:00:45 <Axman6> jekor: mind if i ask what you were doing?
19:01:06 <jekor> Axman6: Using a monad transformer to extend the CGI monad with a Reader for FastCGI.
19:01:20 <Axman6> ah ha..
19:01:27 <jekor> Going to simplify my program so much...
19:01:32 <ddarius> Cale: If you could find a more compelling case where call-by-name would significantly simplify a problem and wasn't replacing stupid code with slightly less stupid code, I might find it more interesting.
19:08:14 <Axman6> heh, SPJ is very fun to watch
19:10:59 <ddarius> Axman6: Indeed.
19:11:08 <Axman6> he's so animated
19:11:40 <ddarius> Indeed.
19:14:03 <prof_nimnul> @src foldl
19:14:04 <lambdabot> foldl f z []     = z
19:14:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:14:33 <Axman6> > foldl f 1 [b,c,d,e]
19:14:34 <lambdabot>   Add a type signature
19:14:37 <Axman6> > foldl f a [b,c,d,e]
19:14:39 <lambdabot>   f (f (f (f a b) c) d) e
19:30:04 <Axman6> eh, ghc 6.10.1 must be finishing building, my MBP just ground to a halt because haddock was using emormous amounts of memory
19:30:10 <Axman6> (this is on a 4GB system too)
19:36:32 <Korollary> I built it on a 512MB machine.
19:38:27 <Axman6> hooray, installed
19:38:52 <prof_nimnul> http://hpaste.org/11842
19:39:08 <prof_nimnul> Why foldA doesn't work?
19:40:50 <Cale> prof_nimnul: Because foldA (which is foldl) builds up a giant expression, and only tries to evaluate that expression at the end
19:41:25 <Cale> (this is assuming that you don't have optimisations turned on, which would make the two equivalent (I would hope)
19:41:29 <Cale> )
19:41:37 <prof_nimnul> Cale: The problem that -O2 doesn't help
19:43:36 <prof_nimnul> Cale: And foldA is not a foldl, because foldl magically works :-)
19:44:07 <Axman6> @src foldl
19:44:07 <lambdabot> foldl f z []     = z
19:44:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:44:19 <Axman6> looks a lot like foldl to me :)
19:44:24 <Cale> oh, right, foldl has nice fusion rules
19:44:43 <prof_nimnul> what the fusion rules have to do with seq?
19:45:35 <ddarius> Cale: I don't believe it's fusion.  foldl is (or at least wasn't) written as lambdabot states in the GHC source.
19:46:08 <Cale> hmm
19:46:13 <rwbarton> Maybe the strictness analyzer can't see through the first argument of foldA somehow
19:46:19 <prof_nimnul> yeah
19:46:27 <prof_nimnul> that's what I was saying earlier today
19:46:41 <prof_nimnul> basically, you cannot rely on strictness analyzer
19:46:47 <jsn> shapr: great video
19:47:33 <Cale> prof_nimnul: But you *should* be able to rely on it. If it doesn't work, then that's a bug :)
19:49:31 <prof_nimnul> Cale: yes, I mean that you cannot rely on the analyzer because it's buggy
19:50:03 <ddarius> Cale: That's silly in general.
19:50:08 <ddarius> It's not buggy.
19:50:27 <ddarius> (Well, it probably is, but this isn't a manifestation of it.)
19:51:25 <Cale> ddarius: Really? It shouldn't be able to determine that (+) here is strict, and strictify the fold?
19:52:02 <prof_nimnul> It is not a manifestation, but at least now I don't look so stupid now as I was earlier today saying that laziness overhead is usually big and you need to profile big programs to find laziness "leaks"
19:52:12 <shapr> Cale: Did Anand ever release and/or open source Coconut or any of its parts?
19:52:12 <juhp> @seen bos
19:52:13 <lambdabot> I saw bos leaving #ghc and #haskell 2h 23m 25s ago, and .
19:52:33 <Cale> shapr: I'm not sure. I haven't been in communication with those guys for the last few years.
19:52:40 <shapr> Ok, just checking.
19:53:02 <ddarius> prof_nimnul: This issue isn't any of the issue you mentioned.  I explicitly mentioned this case earlier.
19:53:08 <Cale> prof_nimnul: I'm not sure I would say that it's "usually big"
19:53:32 <Cale> prof_nimnul: There are very specific cases where laziness costs a lot, and this is one of them.
19:53:43 <chrisdone> I saw bos leaving #ghc and #haskell 2h 23m 25s ago, and .
19:53:44 <ddarius> prof_nimnul: As I said before, laziness adds at worst a constant factor more in memory usage, but it can change when it occurs leading to an asymptotically higher peak memory usage.
19:53:46 <chrisdone> :t (and .)
19:53:47 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
19:54:39 <prof_nimnul> It's usually asymptotically big - e.g. the foldA here is O(N) on memory instead of O(1)
19:54:40 <ddarius> prof_nimnul: However, it also cuts the other way and laziness can and does routinely lead to asymptotically lower peak memory usage (and potentially even asymptotically less total memory usage) by again changing when things occur.
19:55:04 <rwbarton> As well as less time usage
19:55:13 <Cale> prof_nimnul: "usually"?
19:55:54 <rwbarton> prof_nimnul: In a strict language you have to allocate the list [1..100*1000*1000], you know
19:56:47 <Axman6> is there anything that needs to be done with cabal-install after upgrading to 6.10.1?
19:56:50 <prof_nimnul> rwbarton: First, the only thing we discuss here is that GHC strictness analyzer has bugs and you cannot rely on it
19:57:10 <prof_nimnul> rwbarton: so your argument is offtopic
19:57:22 <ddarius> prof_nimnul: Strictness analysis is undecidable, you can never rely on it.
19:57:31 <prof_nimnul> rwbarton: Second, in a strict language I can make .. returning a stream
19:57:39 <ddarius> GHC's analyzer is not buggy.  It could perhaps be improved, but this is an employment theorem.
19:57:43 <rwbarton> prof_nimnul: If I'm offtopic, it's because I can't tell what you're trying to argue.
19:57:54 <rwbarton> prof_nimnul: Similarly, in Haskell you have a primitive called seq.
19:57:54 <ddarius> prof_nimnul: That's switching to lazy evaluation.  In Haskell I can add a seq.
19:58:30 <prof_nimnul> ddarius: I know that analysis isn't decidable. But people here said that current version is good enough. Now I just proved it isn't
19:58:50 <Cale> prof_nimnul: The relative rarity of occurrences of seq in real Haskell programs seems like good evidence that lazy evaluation is not a bad default.
19:59:26 * shapr hopes to get the spiffy Cell DSL
19:59:27 <Cale> Of course, there are occurrences of things built using seq, like foldl'
20:00:14 <Axman6> wow, ghci starts up so much faster with 6.10.1
20:00:18 <FunctorSalad_> btw, how about just keeping track of the dimension if you're going to compute the mean of enormous vectors? ;) (j/k, of course this is besides the point)
20:00:26 <prof_nimnul> cale: There is "relative rarity of occurrence" of Haskell programs which handle big data volumes
20:00:48 <prof_nimnul> and if the volume is small, you don't even need memory management
20:01:30 <Axman6> hmmm.... ok, can't use the arrow keys or delete in ghci anymore
20:01:43 <Cale> prof_nimnul: It's not just large amounts of data being processed which makes strict evaluation necessary. It's summarizing large amounts of information into a piece of data with relatively few separately-evaluable components.
20:02:43 <FunctorSalad_> Axman6: and in haskell-mode I get a ^J after pressing enter
20:02:53 <FunctorSalad_> (still works though)
20:03:00 <Cale> prof_nimnul: But such things are usually folds of some sort, and so we just need appropriate combinators, like foldl', for reducing large structures into small ones.
20:04:28 <Cale> I'm willing to argue that this is in fact the only time that you need strict evaluation (when summarising large structures into small ones)
20:04:51 <prof_nimnul> cale: yes, but usual Prelude folds don't work on trees, and people iterating data A b c = B b | C c | D will inevitably get into that leak trouble
20:05:06 <Cale> hm?
20:05:30 <Cale> That's not even a recursive data type...
20:05:48 <prof_nimnul> y, my mistake
20:06:22 <chrisdone> so, punning in ghc 6.10 is totally awesome
20:06:27 <chrisdone> something I've wanted for ages
20:06:31 <rwbarton> Cale: Seems plausible, given that there seems to be some relationship between unfolds and lazy evaluation.
20:07:01 <Axman6> chrisdone: whating?
20:07:17 <chrisdone> Axman6: punning records
20:07:32 <chrisdone> fizzle C ({ foo = bar}) = zot bar, or some such
20:07:39 <FunctorSalad_> special feature if your identifiers contain a pun? :)
20:08:02 <chrisdone> I haven't actually tried it yet, my friend told me about it before
20:08:29 * chrisdone tries it
20:09:34 <ddarius> chrisdone: That was a completely jacked up example.  Even fixing the syntax errors, that's normal record syntax.
20:09:51 <ddarius> The example you'd want is fizzle (C { foo }) = zot foo
20:10:16 <prof_nimnul> rwbarton: I'm trying to argue that profiling and putting seq is necessary in any big project
20:10:26 <chrisdone> "jacked up" as in HARDCORE?
20:10:34 <ddarius> prof_nimnul: Using seq is necessary.  Period.
20:10:49 <prof_nimnul> ddarius: great
20:10:59 <ddarius> prof_nimnul: No one has argued otherwise.  I'm pretty sure dons didn't understand what you meant by "good enough."
20:11:36 <ddarius> chrisdone: "jacked up" as in wrong
20:11:51 <Cale> While I won't argue that using seq and derived combinators is absolutely necessary, I still think strictness analysis could do a good deal better.
20:11:52 <chrisdone> ddarius: that seems more concise
20:12:11 <ddarius> chrisdone: I didn't choose "jacked up" for concision.
20:12:35 <ddarius> Cale: s/necessary/unnecessary/ ?
20:12:53 <Cale> er, heh, yeah
20:13:05 <Cale> er, actually, I mean I won't argue against that point
20:13:51 <ddarius> Cale: In my opinion, even given -perfect- strictness analysis, it would still be a bad idea to write code that relies on it (especially if you are then not going to have strictness annotations anywhere) because the strictness behaviour of code is pretty fragile.
20:14:33 <ddarius> In my opinion, using 'seq' (or equivalents) to state what you intend is much better.
20:14:37 <chrisdone> ddarius: why did you choose it?
20:14:44 <ddarius> chrisdone: Color.
20:14:44 <Cale> I suppose that's reasonable.
20:16:04 <waynemokane> is there a way to capture output within a live ghci session and redirect it to a file?
20:16:09 <FunctorSalad_> mean = uncurry (/) . foldl1 ((+) *** (+)) . map (id &&& const 1)
20:16:25 <FunctorSalad_> would that work? ;)
20:17:18 <Cale> waynemokane: writeFile "filename.txt" (show x)
20:18:11 <FunctorSalad_> > let mean = uncurry (/) . foldl1 ((+) *** (+)) . map (id &&& const 1) in mean [1..10]
20:18:12 <lambdabot>   Couldn't match expected type `(b, b') -> (b, b')'
20:18:44 <Axman6> :t (id &&& const 1)
20:18:45 <lambdabot> forall a t. (Num t) => a -> (a, t)
20:18:47 <waynemokane> Cale: thanks, did not think of that, got distracted by some discussion of ":redir" but apparently it's not real
20:19:17 <dolio> (+) *** (+) isn't what you want it to be.
20:20:37 <FunctorSalad_> > ( (+) *** (+) ) (1,2) (3,4)
20:20:38 <lambdabot>   Couldn't match expected type `t1 -> t'
20:21:10 <dolio> @type (+) *** (+)
20:21:11 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
20:21:27 <chrisdone> :t (+)
20:21:28 <lambdabot> forall a. (Num a) => a -> a -> a
20:21:31 <Asztal> @pl \(a,b) (c,d) -> (a+b,c+d)
20:21:33 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (+) . (((.) . (.) . (,)) .) . (+))
20:21:45 <Asztal> lovely
20:21:54 <omg911> > tr d n = (truncate (d*n))/d
20:21:55 <lambdabot>   <no location info>: parse error on input `='
20:21:58 <dolio> @type uncurry (***) $ (+) *** (+)
20:21:59 <lambdabot>     Couldn't match expected type `(b, c)'
20:21:59 <lambdabot>            against inferred type `a -> a -> a'
20:21:59 <lambdabot>     In the first argument of `(***)', namely `(+)'
20:22:04 <omg911> > let tr d n = (truncate (d*n))/d
20:22:06 <lambdabot>   <no location info>: parse error on input `;'
20:22:13 <dolio> @type uncurry (***) . (+) *** (+)
20:22:14 <lambdabot>     Couldn't match expected type `(a b c, a b' c')'
20:22:15 <lambdabot>            against inferred type `a1 -> a1'
20:22:15 <lambdabot>     Probable cause: `+' is applied to too few arguments
20:22:19 <dolio> @type uncurry (***) <<< (+) *** (+)
20:22:20 <lambdabot> forall b b'. (Num b', Num b) => (b, b') -> (b, b') -> (b, b')
20:23:03 <FunctorSalad_> > (curry ((uncurry (+)) *** (uncurry (+)))) (1,2) (3,4)
20:23:04 <lambdabot>   (3,7)
20:23:08 <FunctorSalad_> \o/
20:23:44 <omg911> > let tr d n = (truncate (d*n))/d
20:23:46 <lambdabot>   <no location info>: parse error on input `;'
20:24:06 <omg911> uh what's this error for?
20:24:18 <Axman6> > let tr d n = (truncate (d*n))/d in tr 3 5
20:24:19 <lambdabot>   Add a type signature
20:24:20 <ddarius> omg911: That isn't an expression.
20:24:36 <Axman6> > let tr d n = (truncate (d*n))/d :: Double in tr 3 5
20:24:37 <lambdabot>       No instance for (Integral Double)
20:24:37 <lambdabot>        arising from a use of `truncat...
20:24:41 <Axman6> rawr
20:24:59 <omg911> oh ok so i'm trying to use this function but can't seem to get around these type errors
20:25:02 <FunctorSalad_> @instances (Int,Int)
20:25:03 <omg911> driving me nuts
20:25:04 <lambdabot> Couldn't find class `(Int,Int)'. Try @instances-importing
20:25:24 <FunctorSalad_> @info (Int,Int)
20:25:24 <lambdabot> (Int, Int)
20:25:27 <ddarius> omg911: What are the types of each of the subexpressions?
20:25:30 <Axman6> :t let tr d n = (truncate (d*n))/d in tr
20:25:31 <lambdabot> forall a. (RealFrac a, Integral a) => a -> a -> a
20:25:33 <omg911> i want tr to truncate a double to d significant digits
20:25:47 <FunctorSalad_> hmm, lambda doesn't do "of what is this an instance", does it
20:26:07 <omg911> ddarius: d is Int, n is Double
20:26:20 <dolio> @type uncurry (/) . foldr (\x -> (+x) *** (+1)) (0,0)
20:26:21 <lambdabot> forall b'. (Fractional b') => [b'] -> b'
20:27:00 <jsn> shapr: does the link he give in the slide have it, you think
20:27:15 <jsn> shapr: i didn't check, but i guess the code is part of some Cell SDK now
20:27:16 <FunctorSalad_> dolio: that everything is curried really gets into way with arrows... maybe a case for a template
20:27:39 <dolio> Template?
20:28:49 <FunctorSalad_> hmm, now that I think of it I'm not sure how one would curry/uncurry everything in a given block of code
20:30:59 <FunctorSalad_> what I did just somehow looked like "conjugate with curry"
20:32:28 <FunctorSalad_> anyway, (&&&) is nice to remain pointless in situations where you are going to need something twice
20:32:45 <FunctorSalad_> (like this mean example)
20:34:51 <lispy> conjugate with curry?
20:35:06 <heatsink> spicy.
20:35:32 <lispy> Stop.  Conjugate and curry.
20:36:24 <jeffwheeler> I can't seem to build regex-tdfa 0.95.1 or the unstable version from Darcs with 6.10.1. I'm getting an error compiling Data.IntMap.EnumMap with a type error.
20:36:33 <FunctorSalad_> lispy: like "curry . F . uncurry" where F is some higher order function that eats uncurried functions, but you have curried stuff on the outside
20:36:53 <lispy> ?pl \f -> curry . f . uncurry
20:36:53 <lambdabot> (curry .) . (. uncurry)
20:37:18 <lispy> ?type \f -> curry . f . uncurry
20:37:19 <lambdabot> forall a b c a1 b1 c1. (((a1, b1) -> c1) -> (a, b) -> c) -> (a1 -> b1 -> c1) -> a -> b -> c
20:37:32 <jeffwheeler> Should I use an older version of regex-tdfa, or something else?
20:38:40 <jeffwheeler> This is the error I'm getting when compiling: http://hpaste.org/11843
20:38:53 <ddarius> omg911: That's only two subexpressions.
20:42:02 <heatsink> jeffwheeler, IIRC Data.Map.lookup changed from (Monad m => k -> Map k a -> m a) to (k -> Map k a -> Maybe a).  You could try making the corresponding change to regex-tdfa.
20:42:46 <waynemokane> is there a way to simplify
20:42:46 <waynemokane> do res <- someMonadicAction a b c
20:42:46 <waynemokane>     return res
20:42:56 <jeffwheeler> heatsink: hmm, I'll play with that; thanks
20:43:00 <heatsink> someMonadicAction a b c
20:43:05 <jeffwheeler> I'm not an expert, so I'm in a little over my head.
20:44:21 <jeffwheeler> Ah ha; that got it passed. I changed "(Enum key,Monad m) => key -> EnumMap key a -> m a" to "(Enum key) => key -> EnumMap key a -> Maybe a". Thanks!
20:44:40 <lispy> why does the new ghci 6.10 release have so many problems with editline?  Is tihs a change from a previous library?
20:45:09 <Cale> lispy: It used to use readline
20:45:19 <dolio> Didn't it use editline in 6.8, though?
20:45:24 <Cale> no.
20:45:30 <lispy> Cale: do you know the rationale for the change?
20:45:33 * FunctorSalad_ paints "bring back readline" sign ;)
20:45:40 <Cale> lispy: I'm assuming licensing.
20:45:43 <Axman6> the libedit problem thing is a real PITA
20:46:03 <FunctorSalad_> I thought readline was made by GNU?
20:46:06 <lispy> Yeah, it seems to be screwing lots of people
20:46:16 <Cale> FunctorSalad_: GHC is BSD licensed.
20:46:28 <FunctorSalad_> Cale: oh :(
20:46:28 <lispy> So why not Haskline :)
20:47:02 <Cale> In fact, most Haskell software at the moment is BSD licensed.
20:47:27 <Axman6> good, screw GNU
20:47:29 <FunctorSalad_> *too tired to start license argument* ;)
20:47:57 <sctb> What is the problem with editline?
20:48:09 <Axman6> you can;t edit lines in ghci
20:48:10 <Cale> sctb: It doesn't handle the delete key correctly.
20:48:18 <lispy> sctb: lots of complains from the masses about keys not working like they used it
20:48:20 <Axman6> all the arrow keys fail for me too
20:48:21 <lispy> to*
20:48:32 <Cale> Axman6: Ah, it's not quite that bad for me.
20:48:46 <Cale> Axman6: I just have to remember to use backspace instead of delete.
20:48:53 <sctb> Mmm. Does this happen when using comint-mode in Emacs?
20:48:59 <Axman6> Cale: both fail for me
20:49:26 <Cale> Axman6: Which platform?
20:49:32 <Axman6> OS X
20:49:37 <Cale> ah, okay
20:49:43 <Cale> I'm on Ubuntu
20:49:57 <Cale> Is there a ticket for that?
20:50:17 <Axman6> not sure, i'll check once i'm finished lunch
20:50:25 <Cale> I submitted a ticket for the delete key problem under linux.
20:52:51 <sctb> To answer my own question, it seems that the behavior under Emacs is the same for 6.8 and 6.10
20:54:15 <sctb> I'm fairly certain I built 6.8 without readline anyways...
20:57:21 <Axman6> hmm, well, the test program at http://hackage.haskell.org/trac/ghc/ticket/2606#comment:4 works fine on OS X
21:04:02 <ellisk> Hi, I was wondering why this code doesn't typecheck: (\id -> (id (+)) (id 1) (id 2)) (\x -> x)
21:05:07 <dolio> It requires higher-rank polymorphism.
21:05:13 <ellisk> > (\id -> (id (+)) (id 1) (id 2)) (\x -> x)
21:05:14 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
21:05:14 <lambdabot>    ...
21:05:41 <ellisk> What's higher-rank polymorphism and why doesn't haskell have it?
21:05:52 <ellisk> Or would it be hard to explain?
21:05:58 <dolio> Well, consider your first function there.
21:06:00 <ddarius>  > (\(id :: forall a. a -> a) -> (id (+)) (id 1) (id 2)) (\x -> x)
21:06:16 <ddarius> > (\(id :: forall a. a -> a) -> (id (+)) (id 1) (id 2)) (\x -> x)
21:06:18 <lambdabot>   3
21:06:20 <dmwit> > let id x = x in id (+) (id 1) (id 2)
21:06:21 <lambdabot>   3
21:06:22 <dolio> Its type is: (forall a. a -> a) -> Int (or something like that).
21:07:19 <dmwit> ellisk: Higher-rank polymorphism has "forall"s to the left of arrows.  Haskell disables it by default because type-inference is undecidable if you allow it.
21:07:33 <dmwit> (Actually, I think rank-2 polymorphism is still decidable, but rank-3 and up definitely no.)
21:07:39 <dmwit> (But I could be wrong about that.)
21:07:47 <ddarius> "disables" is a poor choice of wording
21:08:15 <dolio> It's also problematic because there are no principle types unless you fancify your type system more than Haskell does.
21:08:22 <ellisk> So if it was putting in the forall's, then it could never figure out types?
21:08:38 <dolio> Yes, if you turn on the GHC extension.
21:08:54 <dmwit> Not quite.  If it had to guess foralls, you could potentially build a function for which guessing the type put it in an infinite loop.
21:09:06 <dmwit> That is not the same as *never* figuring out the right answer.
21:09:11 <dolio> Sorry, I totally misread that question.
21:10:05 <ellisk> If you'll excuse my noobish-ness, what is the problem with putting in forall's everywhere? If guessing is what causes the infinite loop, then what is the problem?
21:10:29 <dmwit> The more foralls you put in, the fewer things fit the type.
21:10:37 <dmwit> roughly
21:11:47 <ellisk> I thought that foralls could only make  the  type more general? Wouldn't that make *more* things fit the type?
21:12:08 <dmwit> Fewer things fit a more general type.
21:12:18 <dolio> What is the type of [id]?
21:12:18 <dmwit> Consider what fits (forall a. a) vs. (Int).
21:12:42 <ellisk> Everything fits (forall a. a) and only ints fit (Int)?
21:12:46 <dmwit> There's 0, 1, 2, ... for Int, but none of those are (forall a. a)'s, even though (forall a. a) is more general.
21:13:14 <dmwit> ellisk: Think carefully about what (forall a. a) means.
21:13:16 <dmwit> ellisk: It means:
21:13:42 <dmwit> ellisk: You say you have a value of type (forall a. a).  Then I get to choose a type, and you have to produce a value with that type.
21:14:00 <dmwit> ellisk: But I could choose any type I wanted -- maybe Int, maybe String -- and your value has to fit that type.
21:14:22 <ellisk> Oh, I see.
21:14:22 <dmwit> ellisk: The only thing in Haskell that has the type (forall a. a) is an infinite loop that never returns... not so very many things!
21:15:27 <dolio> The type that every value fits in is actually (exists a. a).
21:15:45 <ellisk> Would let x = x in x :: (forall a. a)? GHCi just told me it has type "t", but ghc seems to leave out the forall's.
21:16:00 <ddarius> :t let x = x in x
21:16:01 <lambdabot> forall t. t
21:16:05 <dmwit> ellisk: That's correct.
21:16:21 <ellisk> Why does lambdabot put in the forall's and ghci doesn't?
21:16:24 <ellisk> :t map
21:16:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:16:28 <ddarius> ellisk: 'forall' is an extension to Haskell 98
21:16:35 <dmwit> ellisk: lambdabot has some extensions enabled.
21:16:47 <ddarius> :t fmap
21:16:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:16:51 <Axman6> Cale: hmm, interestingly, the ghc i built (not the macports one) works fine
21:17:00 <dmwit> In this case, it's probably RankNTypes that's giving that nice behavior.
21:17:06 <dolio> If you enable RankNTypes (among others), ghci will proably start printing them.
21:18:17 <ellisk> Thank you for your explanations. They make sense to me now.
21:20:25 <Axman6> ah ha, my ghc build didn't pickup editline
21:20:29 <Axman6> so it must be using readline
21:20:42 <dolio> Lucky you.
21:20:59 <dolio> You get to use unicode. :)
21:21:25 <Axman6> i get to delete and use the arrow keys to edit things too
21:21:39 * dolio is so jealous.
21:22:21 <waynemokane> is the if' function described here always considered better than if-then-else?   http://www.haskell.org/haskellwiki/If-then-else
21:22:23 <lambdabot> Title: If-then-else - HaskellWiki
21:22:25 <sctb> Why should line editing be part of GHC? Isn't rlwrap or Emacs sufficient?
21:22:47 <Axman6> sctb: ghci
21:22:52 <Axman6> very very important
21:23:55 <dmwit> waynemokane: It's convenient, but usually guards sort of take the pain out of if-then-else anyway.
21:24:10 <sctb> That doesn't address my question, rlwrap or Emacs or some-other-line-editing-wrapper would handle ghci just fine
21:24:54 <dolio> waynemokane: I wouldn't want to give up if-then-else, personally.
21:25:49 <dolio> Although having something like if' would be useful in some situations, too.
21:26:43 <wy_> hello
21:27:08 <ddarius> If we add polytypism, if' is just fold{|Bool|}
21:27:15 <dolio> But replacing existing if-expressions with 'if (foo) (bar) (baz)' (where the parentheses would probably be required frequently) isn't a win if you ask me.
21:27:19 <wy> ah, my other window..
21:27:31 <dmwit_> sctb: I think readline/editline is a lot lighter weight than emacs, and probably more Windows-friendly, too.
21:27:43 <dolio> Especially since there's widespread opposition to changing ($) so you'd be able to write 'if foo $ bar $ baz'.
21:27:59 <dolio> Or 'if $ foo $ bar $ baz'.
21:28:43 <sctb> dmwit_: rlwrap would be equivalent to readline, but without having to link
21:28:53 <Draconx|Laptop> Cale, I was able to make ghci 6.10 handle my delete key by adding "bind '^[]3~' ed-delete-next-char to ~/.editrc
21:29:04 <Draconx|Laptop> er, that should be '^[[3~'
21:29:09 <wy> I got some unknown names from a ppt: Intersection Problem, Library Problem, and the Visible Plumbing Problem. I found no reference to them online
21:29:20 <Cale> Draconx|Laptop: ah, thanks
21:29:22 <wy> Does anyone know some of them?
21:29:34 <Draconx|Laptop> where ^[[3~ is the escape code that rxvt-unicode emits for that key.
21:30:12 <Cale> Draconx|Laptop: yeah, that works nicely, thanks :)
21:30:13 <sclv> hey haskell crowd!
21:31:02 <conal> hey sclv!
21:32:02 <alexsuraci> http://gist.github.com/23030 Probably a loaded question, but could someone explain why this does what it does?
21:32:05 <lambdabot> Title: gist: 23030 — GitHub
21:32:05 <sclv> curious if people think this is really a bug: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-November/015920.html
21:32:11 <lambdabot> Title: ghc bug?, http://tinyurl.com/5sna6r
21:32:34 <sclv> I'm strongly leaning to the "yes" side, but I have some nagging feeling this is documented and explained somewhere.
21:33:12 <dolio> sclv: I'd say not a bug.
21:33:20 <Cale> sclv: mm... lack of a feature?
21:33:41 <Axman6> > let f x = [x ++ "!", x ++ "."] in "Hi" >>= f
21:33:42 <sclv> As I understand it, if you write the type equations, you can prove the two terms logically equivalent.
21:33:42 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
21:33:44 <ddarius> foo and bar don't have the same type, what is surprising there?
21:34:08 <Axman6> > let f x = [x ++ "!", x ++ "."] :: String -> [String] in "Hi" >>= f
21:34:09 <lambdabot>   Couldn't match expected type `String -> [String]'
21:34:19 <sclv> i.e. what possible harm could come from letting the forall float outside the constructor here?
21:34:24 <Axman6> > let f x = [x ++ "!", x ++ "."] in ["Hi"] >>= f
21:34:25 <lambdabot>   ["Hi!","Hi."]
21:34:31 <ddarius> sclv: In general it could change sharing.
21:34:34 <Axman6> > let f x = [x ++ "!", x ++ "."] in ["Hi"] >>= f >>= f
21:34:35 <lambdabot>   ["Hi!!","Hi!.","Hi.!","Hi.."]
21:34:41 <Cale> sclv: What happens if you replace foo's definition instead?
21:34:47 <sclv> same thing.
21:34:51 <Cale> okay
21:35:04 <Axman6> > let f x = [x ++ "!", x ++ "."] in [""] >>= f >>= f
21:35:05 <lambdabot>   ["!!","!.",".!",".."]
21:35:27 <sclv> the behavior of the latter is more constrained by the former... but never in a good way?
21:36:22 <sclv> the behavior you'd expect from the latter would probably be better captured by "(forall b. b) -> String" instead of "forall b. b-> String" I'd think?
21:36:24 <Axman6> uh...wtf. ok, maybe my ghci doesn't work fine. it deletes the wrong characters :|
21:36:58 <Axman6> if i write test| (where | is the cursor), and hit delete, it deletes s
21:37:34 <Axman6> hmm, that could be my fault actually
21:37:37 <sclv> The issue I guess being that looking strictly at the types from a type-theory standpoint, ghc doesn't do what you'd expect. So I'm sort of hoping for a good explanation of why this should be/is the case.
21:37:54 <Cale> for me, it deletes the t, and then moves the cursor on top of the s for some reason
21:37:59 <Cale> (rather than after the s)
21:38:21 <Axman6> Cale: it's because of that thing you stuck in ~/.editrc
21:38:30 <Axman6> i did it too
21:38:43 <ddarius> sclv: Equivalent but not equal is already a good enough reason, but I suspect that they may also be subtly different too (in Haskell) beyond the sharing issue.
21:38:44 <Cale> Well, it's better than what it did before.
21:38:45 <zloog> Hi, http://hpaste.org/11845 is giving me an  Not in scope: type variable `gridDims' error. What I want is for all values of type TetrisBoard to have those dimensions, is there a way to do that without hardcoding in the width and height?
21:38:54 <Cale> Which was to insert a ~ while beeping at me.
21:39:34 * Cale looks
21:40:23 <Cale> (sorry, my connection and/or hpaste are slow)
21:40:29 <sclv> so yes foo and bar are different, but that's part of the problem -- why isn't bar automatically turned into foo?
21:40:37 <sclv> i.e. why isn't the forall floated out by default?
21:40:38 <Cale> ah, okay
21:40:46 <Cale> zloog: gridDims is not a type
21:40:51 <ddarius> sclv: Incidentally, (forall b. b) -> String and (forall b. b -> String) are very different types, I'm not quite sure what you were saying in that sentence though.
21:41:06 <Cale> zloog: The first parameter to the Array type constructor is the type of indices.
21:41:11 <ddarius> sclv: That would decrease sharing.
21:41:15 <sclv> ddarius: that sentence might be a bit sketchy, sure.
21:41:47 <Cale> zloog: Not the size of the array. That is not enforceable in the type system with the standard Haskell Array type.
21:41:50 <zloog> Cale: Ohh, so is there a way to declare a type of things that are arrays of a certain dimension?
21:41:52 <sclv> and in fact, looking at it, its nonsense.
21:41:56 <zloog> Cale: Ah
21:41:57 <Cale> zloog: yes.
21:42:12 <Cale> zloog: You can index arrays using any type of value which is in the typeclass Ix.
21:42:18 <sclv> but what gets shared in bar that isn't in foo?
21:42:19 <rwbarton> sclv: Certainly forall a. Foo a => (a, Bool) is not the same as (forall a. Foo a => a, Bool).
21:42:27 <Mzzz> Is it correct to say in "f $! e", "e" is evaluated to WHNF before "f" is applied to it? If yes, does it mean when we say "evaluate exp" in Haskell, what we really mean is "evaluate exp to (the nearest) WHNF"?
21:42:33 <Cale> zloog: There are instances of Ix for pair and other tuple types.
21:42:42 <sclv> rwbarton -- why not?
21:42:43 <ddarius> sclv: bar is one value, foo is a different value for each type
21:42:48 <Cale> Mzzz: I would say yes.
21:42:54 <zloog> Cale: Yea, but I cant make it so TetrisBoard's can only have a certain width/height can I?
21:42:57 <Cale> Mzzz: on both counts.
21:43:00 <ddarius> sclv: With explicit type abstractions and applications this is clear.
21:43:08 <rwbarton> sclv: because in the latter, the second half of the pair is either True or False, but in the former, it can be a class function of a
21:43:24 <Mzzz> Cale: I see
21:43:29 <sclv> ah!
21:43:41 <Cale> zloog: You can write a function to construct them which ensures they do, and use a proper datatype for which you do not export the data constructor.
21:43:42 <sclv> ok, thanks! that makes sense.
21:44:00 <zloog> Cale: Sure, thanks
21:44:13 <sclv> I initially thought they were obviously different types, but was nearly convinced of the opposite today. Now I can sort of get why my intuition made sense to begin with.
21:45:07 <Axman6> hmm, STM can be really slow when using -Nn
21:45:42 <Axman6> got a pretty simple program that runs in about 0.3s with -N1, but can take over 5 with -N2, and longer the higher n gets
21:46:17 <ddarius> sclv: If Haskell products were categorical products and the adjunction defining function spaces held then it would follow that the forall could be moved out of that pair, but those aren't true (at least naively) and thus it doesn't -immediately- follow that that is the case, though it could still be true.
21:46:49 <dolio> sclv: Bug the GHC guys to extend the type system to have MLF-like principle types for higher-rank types. :)
21:49:06 <sclv> so either live with they fact that they can't be unified, or manually introduce eta expansion... cool. I'm just glad I sort of get it now.. this has been bugging me all day.
21:50:14 <sclv> the easy way to see it I guess, is if the second part of the pair were not 0 but "trace 'hi there' $ 0"...
21:50:44 <ddarius> sclv: If you add side-effects, then the changes in sharing become observable.
21:51:01 <ddarius> (and thus the types simply become inequivalent)
21:52:00 <sclv> right. makes sense now.
22:03:22 <Mzzz> Is there some "easy implementation" of Haskell out there that one can use to learn more about how Haskell works?
22:03:56 <Cale> There are papers you can read...
22:04:43 <dmwit> The implementations I know of are ghc, nhc, yhc, jhc.
22:04:50 <Cale> Are you just interested in knowing how lazy evaluation proceeds? It's possible to understand that without even getting into how you'd implement it on a real computer :)
22:04:51 <dmwit> You might find one of them simple enough to read.
22:05:44 <dolio> There's also helium and hbc.
22:06:05 <dolio> You think the compiler that implements a beginner's subset of haskell will be the easiest to read? :)
22:06:14 <Mzzz> Cale: That's the motivation, but I'm also wants to know more
22:06:55 <Mzzz> dolio: May be
22:07:19 <dolio> Oh, and hugs if you just want to know how to evaluate things.
22:07:34 <dolio> Since it's an interpreter, and presumably doesn't have to bother with code generation.
22:07:50 <Mzzz> Emm
22:07:53 <Cale> Mzzz: Well, lazy evaluation is just outermost-first evaluation, plus a little optimisation which says that if a function parameter occurs multiple times in the body of a function, then evaluation is shared between the copies.
22:07:55 <rwbarton> hugs is written in C, though
22:08:04 <dolio> Yeah. There's the rub. :)
22:08:21 <Cale> Mzzz: I can give my usual example... consider the function:  double x = x + x
22:08:26 <Mzzz> I'm familiar with C :)
22:08:31 <Cale> Mzzz: and the expression  double (double 5)
22:08:59 <Cale> Mzzz: Under strict evaluation, which you're probably quite used to, reduction is innermost-first
22:09:03 <Cale> So it goes:
22:09:06 <Cale> double (double 5)
22:09:10 <Cale> -> double (5 + 5)
22:09:13 <Cale> -> double 10
22:09:16 <Cale> -> 10 + 10
22:09:19 <Cale> -> 20
22:09:37 <Cale> Under plain outermost-first evaluation, we have:
22:09:41 <Cale> double (double 5)
22:09:55 <Cale> -> (double 5) + (double 5)
22:10:01 <Cale> -> (5 + 5) + (double 5)
22:10:04 <Cale> -> 10 + (double 5)
22:10:07 <Cale> -> 10 + (5 + 5)
22:10:09 <Cale> -> 10 + 10
22:10:11 <Cale> -> 20
22:10:31 <lispy> > fix double
22:10:32 <lambdabot>   Couldn't match expected type `Double' against inferred type `Doc'
22:10:35 <Cale> Of course, you can see that there's a bit of a problem: the work done computing double 5 is duplicated.
22:10:51 <lispy> :t double
22:10:52 <lambdabot> Double -> Doc
22:11:00 <lispy> ??
22:11:05 <Cale> This is because the parameter x to the function double occurs twice in x + x, the body of the function
22:11:11 <dmwit> lispy: pretty-printing
22:11:37 <Cale> Mzzz: Following?
22:11:44 <Mzzz> Yes
22:11:56 <dolio> > hsep . map double $ [1..10]
22:11:57 <lambdabot>   1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0
22:12:50 <Mzzz> Cale: Thanks a lot
22:12:52 <Cale> Mzzz: Okay, so lazy evaluation fixes this problem by sharing evaluation between the copies. I'll represent this with a let expression.
22:12:57 <Cale> double (double 5)
22:13:03 <Cale> -> let x = double 5 in x + x
22:13:08 <Cale> -> let x = 5 + 5 in x + x
22:13:11 <Cale> -> let x = 10 in x + x
22:13:15 <Cale> -> 20
22:13:46 <Cale> Of course, in a machine implementation, that's usually represented by the two copies of x being pointers pointing to the same thing.
22:14:01 <Mzzz> Mzzz: I see. That's the thunk thing, right?
22:14:04 <Cale> yeah
22:14:52 <Mzzz> Cale: Thanks again :)
22:15:05 <Cale> One possible implementation of Haskell values would be as pairs consisting of a pointer to either code or a value, and a boolean flag specifying which.
22:15:58 <Cale> When the value is evaluated the first time, the boolean flag is false (say), and so the pointer is followed to some code to execute to compute the value, after which the pointer is updated to point at that value, and the flag is set.
22:16:18 <Cale> On subsequent evaluations, the pointer is already pointing at the value, so it doesn't need to be recomputed.
22:16:36 <Mzzz> I see
22:16:50 <Cale> This isn't how GHC does things though, it's more clever. Values are just represented as a pointer which always points to code.
22:17:20 <Cale> The first time the code runs, the pointer is updated to point at another chunk of code which returns the value immediately.
22:17:37 <Cale> (this way you have no boolean flag to test)
22:18:00 <Mzzz> Emm
22:18:09 <dons> for thow around earlier, here's prof_nimen's discovery of haskell's weirdness http://hpaste.org/11842
22:18:15 <dons> those.
22:19:09 <Cale> dons: yeah, it would be nice if the strictness analyser did a better job in that case
22:20:41 <dolio> So, foldl'?
22:21:02 <Cale> dons: for some reason, with foldl, which ought to be the same as foldA, it seems to optimise the thing properly.
22:22:22 <Cale> hmm, no RULES firing.
22:22:36 <sjanssen> @src foldl
22:22:37 <lambdabot> foldl f z []     = z
22:22:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:22:41 <sjanssen> that isn't the real source.
22:23:07 <sjanssen> foldl f z xs = lgo z xs
22:23:08 <sjanssen>              where
22:23:08 <sjanssen>                 lgo z []     =  z
22:23:08 <sjanssen>                 lgo z (x:xs) = lgo (f z x) xs
22:23:16 <Cale> Oh, right, that problem.
22:23:26 <sjanssen> Cale: GHC can't inline foldA, but it can inline foldl
22:24:02 <sjanssen> and presumably that enables some strictness analysis
22:24:29 <dons> Cale: well, actually, foldl should catch it here.
22:24:50 <dons> i'd be interested to see what Clean did here.
22:24:52 <sjanssen> -- We write foldl as a non-recursive thing, so that it
22:24:52 <sjanssen> -- can be inlined, and then (often) strictness-analysed,
22:24:52 <sjanssen> -- and hence the classic space leak on foldl (+) 0 xs
22:25:01 <dons> zactly
22:25:01 <sjanssen> Cale: comments from GHC.List
22:25:22 <dons> so i'm not sure if he's arguing that Clean gets the recursive case
22:25:27 <dons> or if he's just complaining
22:25:31 <Cale> sjanssen: Right, GHC ought to transform foldA first.
22:25:51 <sjanssen> I don't think it knows how to do that transform
22:25:52 <Cale> (so that it can then inline it)
22:27:10 <rwbarton> Oh, I see.  GHC can't say "foldl is strict in z if f is"
22:27:23 <rwbarton> ("if f is strict in its first argument")
22:27:34 <dolio> I wonder if the static argument transform in 6.10 gets that.
22:27:42 <Cale> dolio: I'm using 6.10...
22:27:49 <dolio> I guess that's a no.
22:28:01 <dons> btw, kids, check out http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gitit-0.1.1
22:28:05 <sjanssen> does anyone know if the recursive wrapper thing is written up on the wiki?  We should be sure to add this to the performance page
22:28:07 <lambdabot> Title: HackageDB: gitit-0.1.1, http://tinyurl.com/57aeq5
22:28:16 <dons> mm.
22:28:19 <dons> sjanssen: as a technique?
22:28:25 <dons> i'm not sure worker/wrapper is written up
22:28:28 <dons> its folklore
22:28:37 <sjanssen> dons: and the specific implications with GHC's optimizer
22:28:40 <Cale> It might also be worth having a strictness analyser which was able to deal with conditionals like that at least to some extent.
22:28:42 <dolio> They were talking about SATing and seeing if it inlines (and un-SATing if it doesn't), but I guess they decided against that.
22:29:13 <Cale> dolio: Yeah, I heard something about that too.
22:29:29 <Cale> dolio: I'd kind of expected this to get worked out.
22:30:06 <dolio> foldr should get SATed (I think), since it has two static arguments. :)
22:31:06 <sjanssen> so GHC doesn't bother to apply SAT on foldl because only one argument is static?
22:32:37 <dolio> Yeah. Their heuristic doesn't bother SATing for less than two arguments, because the overhead of of the transform negates the savings of not passing arguments, or something.
22:34:24 <Cale> Heh, adding an extra spurious static argument to foldA doesn't seem to help though :P
22:34:42 <sjanssen> from http://www.haskell.org/haskellwiki/Performance#Additional_Tips "foldl' over foldr unless you have to use foldr. " does that seem like bad advice?
22:34:44 <lambdabot> Title: Performance - HaskellWiki
22:35:00 <Cale> It seems like bad advice to me.
22:35:20 <Cale> My heuristic is foldr unless you have to use something else, in which case foldl' is your next most likely bet.
22:35:33 <dolio> Cale: Does it not trigger SAT, or does it not help strictness analysis?
22:35:50 <Cale> dolio: I'm not sure. The code still performs poorly.
22:36:03 <adityam> @pl f (x,y) = x-y
22:36:04 <lambdabot> f = uncurry (-)
22:36:47 <adimit> hey guys, just a horribly noobish quick question: f returns a Just a and I want to use the a, but outside of Maybe. How do I un-lift the type?
22:37:01 <Cale> adimit: case
22:37:04 <Cale> case f x of
22:37:07 <Cale>  Nothing -> ...
22:37:16 <Cale>  Just u -> ... u ...
22:37:52 <adimit> Cale: yes, thanks. But I'd rather not use case. Actually, I think that's a  flaw of the design, because at this point I *know* I won't return Nothing.
22:38:01 <Cale> Oh, then fromJust
22:38:05 <adimit> So I wanted to short-circut case.
22:38:16 <adimit> ah, fromJust. Thanks :-)
22:38:21 <Cale> You can also have case with a single branch :P
22:38:32 <adimit> yes, but that looks incredibly ugly.
22:38:43 <Cale> agreed :)
22:38:44 <adimit> especially since I already am in a case block.
22:38:48 <Vulpyne> There's also isJust and isNothing functions.
22:39:14 <Cale> If you have a bunch of case expressions with  Nothing -> Nothing  chained together, you might want to consider thinking of Maybe as a monad :)
22:40:22 <mwotton> no, monads are just for IO. everyone knows that.
22:40:23 <Cale> > let dict = zip [1..] (words "hello there world") in do x <- lookup 1 dict; y <- lookup 3 dict; return (x,y)
22:40:24 <lambdabot>   Just ("hello","world")
22:40:35 <Cale> > let dict = zip [1..] (words "hello there world") in do x <- lookup 1 dict; y <- lookup 5 dict; return (x,y)
22:40:36 <lambdabot>   Nothing
22:40:44 <sjanssen> mwotton: repent, sinner!
22:40:45 * mwotton waits for someone to beat him to death with a monad transformer
22:40:55 <mwotton> ah, there we go
22:41:09 * Cale twists mwotton's arm with a distributive law
22:41:10 <sjanssen> mwotton: RepenT!
22:41:23 <sjanssen> (it is the transformer version of Repn)
22:41:24 <adimit> uhm. probably :-) but it's really just a function that takes a list's first three items, and returns Nothing if the list is less than three in cardinality. I use that function recursively, shortening the list in the process.
22:41:54 <adimit> but then I check for [] instead of first going the recursive step and waiting for Nothing to happen, so I simply needed to unJust the value.
22:42:13 <adimit> thanks for your hints, Cale!
22:43:09 <dolio> Cale: Looks like ghc removes the spurious argument. (foldA f q z (e:es) = foldA f q (f z e) es ; foldA f q z [] = z)
22:46:08 <dolio> Cale: I don't see SAT in a foldR either, though...
22:47:18 <dolio> Maybe they pulled that out of this release entirely?
22:49:31 <adityam> @pl f x = 1 - u `g` x
22:49:31 <lambdabot> f = (-) 1 . (u `g`)
22:51:01 <pumpkin_> @pl f x = x ^ 2
22:51:02 <lambdabot> f = (^ 2)
22:51:10 <pumpkin_> how does that thing work?
22:54:35 <dolio> Just applies various rules. Shouldn't be too hard to work them out, if you know the right functions.
22:54:51 <dolio> \x -> f x ==> f
22:55:21 <dolio> \x -> f x y ==> \x -> flip f y x ==> flip f y
22:55:23 <dolio> Etc.
22:55:41 <dmwit> ?pl \x -> f x (g x)
22:55:42 <lambdabot> ap f g
22:56:13 <dmwit> ?pl \x -> f (g x) x
22:56:13 <lambdabot> f =<< g
22:56:39 <dmwit> ?pl \x -> f (g x)
22:56:39 <lambdabot> f . g
22:56:49 <dmwit> Let's see, what other things does it know...
22:56:59 <dolio> @pl \x y -> (x,y)
22:57:00 <lambdabot> (,)
22:57:05 <dmwit> ?pl \x y -> if z then x else y
22:57:05 <lambdabot> if' z
22:57:08 <dolio> I guess that's kind of obvious.
22:57:26 <pumpkin_> didn't know about if'
22:57:29 <dmwit> ?pl \[x, y] -> x + y
22:57:29 <lambdabot> (line 1, column 2):
22:57:29 <lambdabot> unexpected "["
22:57:29 <lambdabot> expecting pattern
22:57:33 <dmwit> pumpkin_: It doesn't exist.
22:57:37 <dmwit> ?pl \x y -> [x, y]
22:57:37 <lambdabot> (. return) . (:)
22:57:38 <pumpkin_> ok
22:58:00 <pumpkin_> so why did it reduce it to if'?
22:58:02 <pumpkin_> @src if'
22:58:03 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:58:06 <pumpkin_> o.O
22:58:16 <dmwit> if' p t f = if p then t else f
22:58:28 <dolio> @pl \(x, y) -> (f x, y)
22:58:29 <pumpkin_> yeah
22:58:29 <lambdabot> first f
22:58:32 <dmwit> The ?pl command uses that because it can't really do syntax transformations.
22:58:45 <zloog> Can I have my local lambdabot read my current directory and answer questions about it?
22:58:46 <pumpkin_> ah I see
22:58:48 <dmwit> dolio: Wait, since when did ?pl do arrows?
22:58:58 <dmwit> ?pl \f g (x,y) -> (f x, g y)
22:58:59 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
22:59:03 <dmwit> Oh, okay. =)
22:59:10 <dolio> It doesn't, in general. I think it just knows first.
22:59:23 <pumpkin_> wow
22:59:24 <dolio> @pl \(x, y) -> (x, f y)
22:59:24 <lambdabot> second f
22:59:39 <dolio> @pl \(x, y) -> (f x, g y)
22:59:39 <lambdabot> f *** g
22:59:47 <dolio> Oh, well, a little more, I guess.
22:59:57 <dmwit> It's not very smart about when to apply them, though.
23:00:05 <dolio> @pl \x -> (f x, g x)
23:00:05 <lambdabot> liftM2 (,) f g
23:00:09 <dolio> Yeah.
23:00:42 <dolio> I was kind of expecting fmap instead of second.
23:01:28 <rwbarton> I added (&&&) to my local copy of pointfree :)
23:01:52 <dmwit> I added 3 to my local copy of pointfree.
23:01:56 <dolio> It fails to use uncurry/curry frequently, too.
23:02:38 <dolio> @pl \f x y -> f (x, y)
23:02:38 <lambdabot> (. (,)) . (.)
23:02:53 <dolio> @pl \f (x, y) -> f x y
23:02:53 <lambdabot> (`ap` snd) . (. fst)
23:03:36 <rwbarton> dmwit: Hmm?
23:05:06 <dmwit> exactly
23:05:40 <rwbarton> @pl 1 + 1 + 1
23:05:40 <lambdabot> 3
23:06:03 <dolio> @pl \x y -> y + x
23:06:04 <lambdabot> (+)
23:06:51 <mrd> huh
23:07:09 <mrd> it knows commutivity?
23:07:59 <dolio> It assumes it for (+) and (*).
23:08:00 <seafood> Hey Haskeller's. Does anyone here think that Haskell could be a good language to write web applications in?
23:08:32 <dobblego> yes
23:08:51 <seafood> dobblego: What do you think it's strengths would be?
23:09:05 <dobblego> the usual, composition and abstraction
23:09:17 <Cale> Haskell's strengths are very general purpose ones.
23:09:20 <dons> seafood: there's a lot of new db bindings and frontend layers (see kibro, panda et al on hackage)
23:09:42 <dons> json, json-rpc, xml, sqlite, hdbc, takusen. all the bits you need.
23:10:13 <seafood> I'll be working on a website soon, can't say what just yet, and I wonder if Haskell is the right language to go with.
23:10:14 <Cale> There's also a new project to create a Django-like framework, called Ella.
23:10:31 <seafood> Cale: What distinguishes Django?
23:10:32 <dons> seafood: of the fp languages, i think its the most competitive in this area, by a good maring.
23:10:42 <dons> margin.
23:10:44 <dons> weird.
23:10:54 <dons> seafood: django's a big well known python api
23:10:57 <Cale> seafood: A particular means of dispatching code based on the structure of the URL.
23:11:40 <dons> happs is also seeing more use (new hackage server, git-based wiki launched today et al)
23:11:53 <dons> things have progressed a lot from a year ago
23:12:05 <rwbarton> git-based wiki?
23:12:07 * rwbarton is intrigued
23:12:11 <pumpkin_> I'
23:12:14 <dons> gitit, on hackage.
23:12:22 <pumpkin_> I've been looking for something like that for a while
23:12:27 <dons> uhhu
23:12:39 <dons> by the author of pandoc, fwiw
23:12:47 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gitit
23:12:48 <lambdabot> Title: HackageDB: gitit-0.1.1
23:13:03 <rwbarton> Is there a demo running somewhere?
23:13:05 <dons> Lemmih: did you see gitit?
23:13:16 <dons> not that i'm aware of. not even announced yet.
23:13:21 <dons> just leaded onto hackage
23:13:43 <seafood> Alright, I'll phrase my question another way. Say I came to you and said, "Haskell is my favourite language, I've been writing in it for years but I fear that there just isn't enough library support to create a really good Web 2.0 application in Haskell"
23:13:45 <seafood> What would you say?
23:13:58 <dons> the libraries are there.
23:14:07 <seafood> dons: Nice answer :)
23:14:23 <dons> seafood: galois released a dozen web libraries in january.
23:14:27 <seafood> Also, it'll be a one man project so I don't have to worry about training people.
23:14:36 <Nafai> Will Cabal 1.6.0 work with GHC 6.8.2 or does it require 6.10?
23:15:08 <dons> what are you constraints? what kind of db access? cgi/fastcgi / .. some other framework? javascript involved? what communications layer? xml-rpc or json?
23:15:51 <dons> (i'd say: look at hdbc or takusen, use the json lib for transport, and fastcgi)
23:15:52 <seafood> dons: I don't know yet. Javascript would be involved.
23:16:09 <dons> or, see if happs is a good container.
23:16:50 <dons> and you get to rest comfortably that ghc/forkio scales a way bit beyond rails or python on a single box :)
23:17:39 <dons> seafood: also, talk to the tupil guys. they're using galois' web libs (and others) to do run a web dev company using haskell.
23:17:50 <dons> seafood: http://tupil.com/ smart peoples.
23:17:53 <seafood> dons: I've used Ruby on Rails and while I think the libraries are well designed and there is a good philosophy behind its design the language, Ruby, blows.
23:17:59 <lambdabot> Title: (,) tupil
23:18:36 <dons> and familiarise yourself with hackage.haskell.org. there's millions of lines of code there to reuse.
23:19:49 <seafood> dons: Thanks for the tupil link. Looks awesome.
23:20:06 <dons> chris and eelco should be able to offer sensible advice.
23:29:50 <ushdf_> anybody know any advanced projects for SDL in haskell
23:31:18 <ushdf_> i need some libraries, baby
23:33:33 <seafood> dons: I'd like, as much as possible, to avoid Javascript. Any work been done on translating from other languages to Javascript, so that you can avoid all its gotchas. I watched a bunch of vids from Douglas Crockford about it and there are many indeed!
23:34:52 <rwbarton> seafood: there is an experimental javascript backend for the yhc compiler, and plans to port it to hugs
23:35:08 <adimit> ok, another stupid question. Say, I have a data type and two different ways to sort it (in my case: a point and different ways to sort it in relation to the coordinate plane.) Can I define two instances of Ord Point? Or should I somehow pass an ordering function to sort?
23:35:33 <rwbarton> @type sortBy
23:35:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:35:52 <adimit> rwbarton: thanks! that looks like what I want.
23:42:23 <Nafai> Yay for "cabal install"
23:42:32 <glguy> PE#215 has a neat trie solution
23:43:20 <dons> seafood: there are javascript pretty printers and analysers, but its kind of unavoidable if you want to do fancy browswer-side things
23:44:23 <pumpkin_> I came across a paper a while back for a good indexing scheme for regex-based searches (where you wouldn't have to cover all the data to find matches)
23:44:32 <pumpkin_> anyone know what I'm talking about?
23:44:50 <Taejo> @src ap
23:44:50 <lambdabot> ap = liftM2 id
23:49:34 <Nafai> I'm trying to cabal install parsec, and it is grabbing version 2.1.0 instead of 3.0.0
23:50:22 <ttt--> hi, is it possible to build ghc with bytestring-0.9.1.3?
23:50:47 <Nafai> Is there any way to force it to do 3.0?
23:50:48 <ttt--> i always get dependency errors because some packages have 9.1.3 and some have 9.0.1.1
23:50:56 <rwbarton> cabal install parsec-3.0.0 should do it
23:51:08 <ttt--> Nafai, or do cabal update first
23:51:29 <Nafai> rwbarton: Thanks
23:51:44 <Nafai> ttt--: That wasn't fixing the problem for some reason
